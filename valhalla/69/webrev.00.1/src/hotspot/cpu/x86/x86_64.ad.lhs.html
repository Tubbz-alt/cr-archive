<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 //
    2 // Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // AMD64 Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // archtecture.
   31 
   32 register %{
   33 //----------Architecture Description Register Definitions----------------------
   34 // General Registers
   35 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   36 //                   ideal register type, encoding );
   37 // Register Save Types:
   38 //
   39 // NS  = No-Save:       The register allocator assumes that these registers
   40 //                      can be used without saving upon entry to the method, &amp;
   41 //                      that they do not need to be saved at call sites.
   42 //
   43 // SOC = Save-On-Call:  The register allocator assumes that these registers
   44 //                      can be used without saving upon entry to the method,
   45 //                      but that they must be saved at call sites.
   46 //
   47 // SOE = Save-On-Entry: The register allocator assumes that these registers
   48 //                      must be saved before using them upon entry to the
   49 //                      method, but they do not need to be saved at call
   50 //                      sites.
   51 //
   52 // AS  = Always-Save:   The register allocator assumes that these registers
   53 //                      must be saved before using them upon entry to the
   54 //                      method, &amp; that they must be saved at call sites.
   55 //
   56 // Ideal Register Type is used to determine how to save &amp; restore a
   57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   59 //
   60 // The encoding number is the actual bit-pattern placed into the opcodes.
   61 
   62 // General Registers
   63 // R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when
   64 // used as byte registers)
   65 
   66 // Previously set RBX, RSI, and RDI as save-on-entry for java code
   67 // Turn off SOE in java-code due to frequent use of uncommon-traps.
   68 // Now that allocator is better, turn on RSI and RDI as SOE registers.
   69 
   70 reg_def RAX  (SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg());
   71 reg_def RAX_H(SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg()-&gt;next());
   72 
   73 reg_def RCX  (SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg());
   74 reg_def RCX_H(SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg()-&gt;next());
   75 
   76 reg_def RDX  (SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg());
   77 reg_def RDX_H(SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg()-&gt;next());
   78 
   79 reg_def RBX  (SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg());
   80 reg_def RBX_H(SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg()-&gt;next());
   81 
   82 reg_def RSP  (NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg());
   83 reg_def RSP_H(NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg()-&gt;next());
   84 
   85 // now that adapter frames are gone RBP is always saved and restored by the prolog/epilog code
   86 reg_def RBP  (NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg());
   87 reg_def RBP_H(NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg()-&gt;next());
   88 
   89 #ifdef _WIN64
   90 
   91 reg_def RSI  (SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg());
   92 reg_def RSI_H(SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
   93 
   94 reg_def RDI  (SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg());
   95 reg_def RDI_H(SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
   96 
   97 #else
   98 
   99 reg_def RSI  (SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg());
  100 reg_def RSI_H(SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
  101 
  102 reg_def RDI  (SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg());
  103 reg_def RDI_H(SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
  104 
  105 #endif
  106 
  107 reg_def R8   (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg());
  108 reg_def R8_H (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg()-&gt;next());
  109 
  110 reg_def R9   (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg());
  111 reg_def R9_H (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg()-&gt;next());
  112 
  113 reg_def R10  (SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg());
  114 reg_def R10_H(SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg()-&gt;next());
  115 
  116 reg_def R11  (SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg());
  117 reg_def R11_H(SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg()-&gt;next());
  118 
  119 reg_def R12  (SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg());
  120 reg_def R12_H(SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg()-&gt;next());
  121 
  122 reg_def R13  (SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg());
  123 reg_def R13_H(SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg()-&gt;next());
  124 
  125 reg_def R14  (SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg());
  126 reg_def R14_H(SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg()-&gt;next());
  127 
  128 reg_def R15  (SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg());
  129 reg_def R15_H(SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg()-&gt;next());
  130 
  131 
  132 // Floating Point Registers
  133 
  134 // Specify priority of register selection within phases of register
  135 // allocation.  Highest priority is first.  A useful heuristic is to
  136 // give registers a low priority when they are required by machine
  137 // instructions, like EAX and EDX on I486, and choose no-save registers
  138 // before save-on-call, &amp; save-on-call before save-on-entry.  Registers
  139 // which participate in fixed calling sequences should come last.
  140 // Registers which are used as pairs must fall on an even boundary.
  141 
  142 alloc_class chunk0(R10,         R10_H,
  143                    R11,         R11_H,
  144                    R8,          R8_H,
  145                    R9,          R9_H,
  146                    R12,         R12_H,
  147                    RCX,         RCX_H,
  148                    RBX,         RBX_H,
  149                    RDI,         RDI_H,
  150                    RDX,         RDX_H,
  151                    RSI,         RSI_H,
  152                    RAX,         RAX_H,
  153                    RBP,         RBP_H,
  154                    R13,         R13_H,
  155                    R14,         R14_H,
  156                    R15,         R15_H,
  157                    RSP,         RSP_H);
  158 
  159 
  160 //----------Architecture Description Register Classes--------------------------
  161 // Several register classes are automatically defined based upon information in
  162 // this architecture description.
  163 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  164 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  165 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  166 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  167 //
  168 
  169 // Empty register class.
  170 reg_class no_reg();
  171 
  172 // Class for all pointer/long registers
  173 reg_class all_reg(RAX, RAX_H,
  174                   RDX, RDX_H,
  175                   RBP, RBP_H,
  176                   RDI, RDI_H,
  177                   RSI, RSI_H,
  178                   RCX, RCX_H,
  179                   RBX, RBX_H,
  180                   RSP, RSP_H,
  181                   R8,  R8_H,
  182                   R9,  R9_H,
  183                   R10, R10_H,
  184                   R11, R11_H,
  185                   R12, R12_H,
  186                   R13, R13_H,
  187                   R14, R14_H,
  188                   R15, R15_H);
  189 
  190 // Class for all int registers
  191 reg_class all_int_reg(RAX
  192                       RDX,
  193                       RBP,
  194                       RDI,
  195                       RSI,
  196                       RCX,
  197                       RBX,
  198                       R8,
  199                       R9,
  200                       R10,
  201                       R11,
  202                       R12,
  203                       R13,
  204                       R14);
  205 
  206 // Class for all pointer registers
  207 reg_class any_reg %{
  208   return _ANY_REG_mask;
  209 %}
  210 
  211 // Class for all pointer registers (excluding RSP)
  212 reg_class ptr_reg %{
  213   return _PTR_REG_mask;
  214 %}
  215 
  216 // Class for all pointer registers (excluding RSP and RBP)
  217 reg_class ptr_reg_no_rbp %{
  218   return _PTR_REG_NO_RBP_mask;
  219 %}
  220 
  221 // Class for all pointer registers (excluding RAX and RSP)
  222 reg_class ptr_no_rax_reg %{
  223   return _PTR_NO_RAX_REG_mask;
  224 %}
  225 
  226 // Class for all pointer registers (excluding RAX, RBX, and RSP)
  227 reg_class ptr_no_rax_rbx_reg %{
  228   return _PTR_NO_RAX_RBX_REG_mask;
  229 %}
  230 
  231 // Class for all long registers (excluding RSP)
  232 reg_class long_reg %{
  233   return _LONG_REG_mask;
  234 %}
  235 
  236 // Class for all long registers (excluding RAX, RDX and RSP)
  237 reg_class long_no_rax_rdx_reg %{
  238   return _LONG_NO_RAX_RDX_REG_mask;
  239 %}
  240 
  241 // Class for all long registers (excluding RCX and RSP)
  242 reg_class long_no_rcx_reg %{
  243   return _LONG_NO_RCX_REG_mask;
  244 %}
  245 
  246 // Class for all int registers (excluding RSP)
  247 reg_class int_reg %{
  248   return _INT_REG_mask;
  249 %}
  250 
  251 // Class for all int registers (excluding RAX, RDX, and RSP)
  252 reg_class int_no_rax_rdx_reg %{
  253   return _INT_NO_RAX_RDX_REG_mask;
  254 %}
  255 
  256 // Class for all int registers (excluding RCX and RSP)
  257 reg_class int_no_rcx_reg %{
  258   return _INT_NO_RCX_REG_mask;
  259 %}
  260 
  261 // Singleton class for RAX pointer register
  262 reg_class ptr_rax_reg(RAX, RAX_H);
  263 
  264 // Singleton class for RBX pointer register
  265 reg_class ptr_rbx_reg(RBX, RBX_H);
  266 
  267 // Singleton class for RSI pointer register
  268 reg_class ptr_rsi_reg(RSI, RSI_H);
  269 
  270 // Singleton class for RBP pointer register
  271 reg_class ptr_rbp_reg(RBP, RBP_H);
  272 
  273 // Singleton class for RDI pointer register
  274 reg_class ptr_rdi_reg(RDI, RDI_H);
  275 
  276 // Singleton class for stack pointer
  277 reg_class ptr_rsp_reg(RSP, RSP_H);
  278 
  279 // Singleton class for TLS pointer
  280 reg_class ptr_r15_reg(R15, R15_H);
  281 
  282 // Singleton class for RAX long register
  283 reg_class long_rax_reg(RAX, RAX_H);
  284 
  285 // Singleton class for RCX long register
  286 reg_class long_rcx_reg(RCX, RCX_H);
  287 
  288 // Singleton class for RDX long register
  289 reg_class long_rdx_reg(RDX, RDX_H);
  290 
  291 // Singleton class for RAX int register
  292 reg_class int_rax_reg(RAX);
  293 
  294 // Singleton class for RBX int register
  295 reg_class int_rbx_reg(RBX);
  296 
  297 // Singleton class for RCX int register
  298 reg_class int_rcx_reg(RCX);
  299 
  300 // Singleton class for RCX int register
  301 reg_class int_rdx_reg(RDX);
  302 
  303 // Singleton class for RCX int register
  304 reg_class int_rdi_reg(RDI);
  305 
  306 // Singleton class for instruction pointer
  307 // reg_class ip_reg(RIP);
  308 
  309 %}
  310 
  311 //----------SOURCE BLOCK-------------------------------------------------------
  312 // This is a block of C++ code which provides values, functions, and
  313 // definitions necessary in the rest of the architecture description
  314 source_hpp %{
  315 
  316 extern RegMask _ANY_REG_mask;
  317 extern RegMask _PTR_REG_mask;
  318 extern RegMask _PTR_REG_NO_RBP_mask;
  319 extern RegMask _PTR_NO_RAX_REG_mask;
  320 extern RegMask _PTR_NO_RAX_RBX_REG_mask;
  321 extern RegMask _LONG_REG_mask;
  322 extern RegMask _LONG_NO_RAX_RDX_REG_mask;
  323 extern RegMask _LONG_NO_RCX_REG_mask;
  324 extern RegMask _INT_REG_mask;
  325 extern RegMask _INT_NO_RAX_RDX_REG_mask;
  326 extern RegMask _INT_NO_RCX_REG_mask;
  327 
  328 extern RegMask _STACK_OR_PTR_REG_mask;
  329 extern RegMask _STACK_OR_LONG_REG_mask;
  330 extern RegMask _STACK_OR_INT_REG_mask;
  331 
  332 inline const RegMask&amp; STACK_OR_PTR_REG_mask()  { return _STACK_OR_PTR_REG_mask;  }
  333 inline const RegMask&amp; STACK_OR_LONG_REG_mask() { return _STACK_OR_LONG_REG_mask; }
  334 inline const RegMask&amp; STACK_OR_INT_REG_mask()  { return _STACK_OR_INT_REG_mask;  }
  335 
  336 %}
  337 
  338 source %{
  339 #define   RELOC_IMM64    Assembler::imm_operand
  340 #define   RELOC_DISP32   Assembler::disp32_operand
  341 
  342 #define __ _masm.
  343 
  344 RegMask _ANY_REG_mask;
  345 RegMask _PTR_REG_mask;
  346 RegMask _PTR_REG_NO_RBP_mask;
  347 RegMask _PTR_NO_RAX_REG_mask;
  348 RegMask _PTR_NO_RAX_RBX_REG_mask;
  349 RegMask _LONG_REG_mask;
  350 RegMask _LONG_NO_RAX_RDX_REG_mask;
  351 RegMask _LONG_NO_RCX_REG_mask;
  352 RegMask _INT_REG_mask;
  353 RegMask _INT_NO_RAX_RDX_REG_mask;
  354 RegMask _INT_NO_RCX_REG_mask;
  355 RegMask _STACK_OR_PTR_REG_mask;
  356 RegMask _STACK_OR_LONG_REG_mask;
  357 RegMask _STACK_OR_INT_REG_mask;
  358 
  359 static bool need_r12_heapbase() {
  360   return UseCompressedOops;
  361 }
  362 
  363 void reg_mask_init() {
  364   // _ALL_REG_mask is generated by adlc from the all_reg register class below.
  365   // We derive a number of subsets from it.
  366   _ANY_REG_mask = _ALL_REG_mask;
  367 
  368   if (PreserveFramePointer) {
  369     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  370     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  371   }
  372   if (need_r12_heapbase()) {
  373     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  374     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()-&gt;next()));
  375   }
  376 
  377   _PTR_REG_mask = _ANY_REG_mask;
  378   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()));
  379   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()-&gt;next()));
  380   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()));
  381   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()-&gt;next()));
  382 
  383   _STACK_OR_PTR_REG_mask = _PTR_REG_mask;
  384   _STACK_OR_PTR_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  385 
  386   _PTR_REG_NO_RBP_mask = _PTR_REG_mask;
  387   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  388   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  389 
  390   _PTR_NO_RAX_REG_mask = _PTR_REG_mask;
  391   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  392   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  393 
  394   _PTR_NO_RAX_RBX_REG_mask = _PTR_NO_RAX_REG_mask;
  395   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()));
  396   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()-&gt;next()));
  397 
  398   _LONG_REG_mask = _PTR_REG_mask;
  399   _STACK_OR_LONG_REG_mask = _LONG_REG_mask;
  400   _STACK_OR_LONG_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  401 
  402   _LONG_NO_RAX_RDX_REG_mask = _LONG_REG_mask;
  403   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  404   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  405   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  406   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()-&gt;next()));
  407 
  408   _LONG_NO_RCX_REG_mask = _LONG_REG_mask;
  409   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  410   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()-&gt;next()));
  411 
  412   _INT_REG_mask = _ALL_INT_REG_mask;
  413   if (PreserveFramePointer) {
  414     _INT_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  415   }
  416   if (need_r12_heapbase()) {
  417     _INT_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  418   }
  419 
  420   _STACK_OR_INT_REG_mask = _INT_REG_mask;
  421   _STACK_OR_INT_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  422 
  423   _INT_NO_RAX_RDX_REG_mask = _INT_REG_mask;
  424   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  425   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  426 
  427   _INT_NO_RCX_REG_mask = _INT_REG_mask;
  428   _INT_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  429 }
  430 
  431 static bool generate_vzeroupper(Compile* C) {
  432   return (VM_Version::supports_vzeroupper() &amp;&amp; (C-&gt;max_vector_size() &gt; 16 || C-&gt;clear_upper_avx() == true)) ? true: false;  // Generate vzeroupper
  433 }
  434 
  435 static int clear_avx_size() {
  436   return generate_vzeroupper(Compile::current()) ? 3: 0;  // vzeroupper
  437 }
  438 
  439 // !!!!! Special hack to get all types of calls to specify the byte offset
  440 //       from the start of the call to the point where the return address
  441 //       will point.
  442 int MachCallStaticJavaNode::ret_addr_offset()
  443 {
  444   int offset = 5; // 5 bytes from start of call to where return address points
  445   offset += clear_avx_size();
  446   return offset;
  447 }
  448 
  449 int MachCallDynamicJavaNode::ret_addr_offset()
  450 {
  451   int offset = 15; // 15 bytes from start of call to where return address points
  452   offset += clear_avx_size();
  453   return offset;
  454 }
  455 
  456 int MachCallRuntimeNode::ret_addr_offset() {
  457   int offset = 13; // movq r10,#addr; callq (r10)
  458   offset += clear_avx_size();
  459   return offset;
  460 }
  461 
  462 //
  463 // Compute padding required for nodes which need alignment
  464 //
  465 
  466 // The address of the call instruction needs to be 4-byte aligned to
  467 // ensure that it does not span a cache line so that it can be patched.
  468 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
  469 {
  470   current_offset += clear_avx_size(); // skip vzeroupper
  471   current_offset += 1; // skip call opcode byte
  472   return align_up(current_offset, alignment_required()) - current_offset;
  473 }
  474 
  475 // The address of the call instruction needs to be 4-byte aligned to
  476 // ensure that it does not span a cache line so that it can be patched.
  477 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
  478 {
  479   current_offset += clear_avx_size(); // skip vzeroupper
  480   current_offset += 11; // skip movq instruction + call opcode byte
  481   return align_up(current_offset, alignment_required()) - current_offset;
  482 }
  483 
  484 // EMIT_RM()
  485 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
  486   unsigned char c = (unsigned char) ((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
  487   cbuf.insts()-&gt;emit_int8(c);
  488 }
  489 
  490 // EMIT_CC()
  491 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
  492   unsigned char c = (unsigned char) (f1 | f2);
  493   cbuf.insts()-&gt;emit_int8(c);
  494 }
  495 
  496 // EMIT_OPCODE()
  497 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
  498   cbuf.insts()-&gt;emit_int8((unsigned char) code);
  499 }
  500 
  501 // EMIT_OPCODE() w/ relocation information
  502 void emit_opcode(CodeBuffer &amp;cbuf,
  503                  int code, relocInfo::relocType reloc, int offset, int format)
  504 {
  505   cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);
  506   emit_opcode(cbuf, code);
  507 }
  508 
  509 // EMIT_D8()
  510 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
  511   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
  512 }
  513 
  514 // EMIT_D16()
  515 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
  516   cbuf.insts()-&gt;emit_int16(d16);
  517 }
  518 
  519 // EMIT_D32()
  520 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
  521   cbuf.insts()-&gt;emit_int32(d32);
  522 }
  523 
  524 // EMIT_D64()
  525 void emit_d64(CodeBuffer &amp;cbuf, int64_t d64) {
  526   cbuf.insts()-&gt;emit_int64(d64);
  527 }
  528 
  529 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  530 void emit_d32_reloc(CodeBuffer&amp; cbuf,
  531                     int d32,
  532                     relocInfo::relocType reloc,
  533                     int format)
  534 {
  535   assert(reloc != relocInfo::external_word_type, &quot;use 2-arg emit_d32_reloc&quot;);
  536   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  537   cbuf.insts()-&gt;emit_int32(d32);
  538 }
  539 
  540 // emit 32 bit value and construct relocation entry from RelocationHolder
  541 void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
  542 #ifdef ASSERT
  543   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  544       d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
  545     assert(Universe::heap()-&gt;is_in((address)(intptr_t)d32), &quot;should be real oop&quot;);
  546     assert(oopDesc::is_oop(cast_to_oop((intptr_t)d32)), &quot;cannot embed broken oops in code&quot;);
  547   }
  548 #endif
  549   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  550   cbuf.insts()-&gt;emit_int32(d32);
  551 }
  552 
  553 void emit_d32_reloc(CodeBuffer&amp; cbuf, address addr) {
  554   address next_ip = cbuf.insts_end() + 4;
  555   emit_d32_reloc(cbuf, (int) (addr - next_ip),
  556                  external_word_Relocation::spec(addr),
  557                  RELOC_DISP32);
  558 }
  559 
  560 
  561 // emit 64 bit value and construct relocation entry from relocInfo::relocType
  562 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
  563   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  564   cbuf.insts()-&gt;emit_int64(d64);
  565 }
  566 
  567 // emit 64 bit value and construct relocation entry from RelocationHolder
  568 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
  569 #ifdef ASSERT
  570   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  571       d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
  572     assert(Universe::heap()-&gt;is_in((address)d64), &quot;should be real oop&quot;);
  573     assert(oopDesc::is_oop(cast_to_oop(d64)), &quot;cannot embed broken oops in code&quot;);
  574   }
  575 #endif
  576   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  577   cbuf.insts()-&gt;emit_int64(d64);
  578 }
  579 
  580 // Access stack slot for load or store
  581 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp)
  582 {
  583   emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
  584   if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80) {
  585     emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
  586     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  587     emit_d8(cbuf, disp);     // Displacement  // R/M byte
  588   } else {
  589     emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
  590     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  591     emit_d32(cbuf, disp);     // Displacement // R/M byte
  592   }
  593 }
  594 
  595    // rRegI ereg, memory mem) %{    // emit_reg_mem
  596 void encode_RegMem(CodeBuffer &amp;cbuf,
  597                    int reg,
  598                    int base, int index, int scale, int disp, relocInfo::relocType disp_reloc)
  599 {
  600   assert(disp_reloc == relocInfo::none, &quot;cannot have disp&quot;);
  601   int regenc = reg &amp; 7;
  602   int baseenc = base &amp; 7;
  603   int indexenc = index &amp; 7;
  604 
  605   // There is no index &amp; no scale, use form without SIB byte
  606   if (index == 0x4 &amp;&amp; scale == 0 &amp;&amp; base != RSP_enc &amp;&amp; base != R12_enc) {
  607     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  608     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  609       emit_rm(cbuf, 0x0, regenc, baseenc); // *
  610     } else if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  611       // If 8-bit displacement, mode 0x1
  612       emit_rm(cbuf, 0x1, regenc, baseenc); // *
  613       emit_d8(cbuf, disp);
  614     } else {
  615       // If 32-bit displacement
  616       if (base == -1) { // Special flag for absolute address
  617         emit_rm(cbuf, 0x0, regenc, 0x5); // *
  618         if (disp_reloc != relocInfo::none) {
  619           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  620         } else {
  621           emit_d32(cbuf, disp);
  622         }
  623       } else {
  624         // Normal base + offset
  625         emit_rm(cbuf, 0x2, regenc, baseenc); // *
  626         if (disp_reloc != relocInfo::none) {
  627           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  628         } else {
  629           emit_d32(cbuf, disp);
  630         }
  631       }
  632     }
  633   } else {
  634     // Else, encode with the SIB byte
  635     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  636     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  637       // If no displacement
  638       emit_rm(cbuf, 0x0, regenc, 0x4); // *
  639       emit_rm(cbuf, scale, indexenc, baseenc);
  640     } else {
  641       if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  642         // If 8-bit displacement, mode 0x1
  643         emit_rm(cbuf, 0x1, regenc, 0x4); // *
  644         emit_rm(cbuf, scale, indexenc, baseenc);
  645         emit_d8(cbuf, disp);
  646       } else {
  647         // If 32-bit displacement
  648         if (base == 0x04 ) {
  649           emit_rm(cbuf, 0x2, regenc, 0x4);
  650           emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
  651         } else {
  652           emit_rm(cbuf, 0x2, regenc, 0x4);
  653           emit_rm(cbuf, scale, indexenc, baseenc); // *
  654         }
  655         if (disp_reloc != relocInfo::none) {
  656           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  657         } else {
  658           emit_d32(cbuf, disp);
  659         }
  660       }
  661     }
  662   }
  663 }
  664 
  665 // This could be in MacroAssembler but it&#39;s fairly C2 specific
  666 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
  667   Label exit;
  668   __ jccb(Assembler::noParity, exit);
  669   __ pushf();
  670   //
  671   // comiss/ucomiss instructions set ZF,PF,CF flags and
  672   // zero OF,AF,SF for NaN values.
  673   // Fixup flags by zeroing ZF,PF so that compare of NaN
  674   // values returns &#39;less than&#39; result (CF is set).
  675   // Leave the rest of flags unchanged.
  676   //
  677   //    7 6 5 4 3 2 1 0
  678   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
  679   //    0 0 1 0 1 0 1 1   (0x2B)
  680   //
  681   __ andq(Address(rsp, 0), 0xffffff2b);
  682   __ popf();
  683   __ bind(exit);
  684 }
  685 
  686 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  687   Label done;
  688   __ movl(dst, -1);
  689   __ jcc(Assembler::parity, done);
  690   __ jcc(Assembler::below, done);
  691   __ setb(Assembler::notEqual, dst);
  692   __ movzbl(dst, dst);
  693   __ bind(done);
  694 }
  695 
  696 // Math.min()    # Math.max()
  697 // --------------------------
  698 // ucomis[s/d]   #
  699 // ja   -&gt; b     # a
  700 // jp   -&gt; NaN   # NaN
  701 // jb   -&gt; a     # b
  702 // je            #
  703 // |-jz -&gt; a | b # a &amp; b
  704 // |    -&gt; a     #
  705 void emit_fp_min_max(MacroAssembler&amp; _masm, XMMRegister dst,
  706                      XMMRegister a, XMMRegister b,
  707                      XMMRegister xmmt, Register rt,
  708                      bool min, bool single) {
  709 
  710   Label nan, zero, below, above, done;
  711 
  712   if (single)
  713     __ ucomiss(a, b);
  714   else
  715     __ ucomisd(a, b);
  716 
  717   if (dst-&gt;encoding() != (min ? b : a)-&gt;encoding())
  718     __ jccb(Assembler::above, above); // CF=0 &amp; ZF=0
  719   else
  720     __ jccb(Assembler::above, done);
  721 
  722   __ jccb(Assembler::parity, nan);  // PF=1
  723   __ jccb(Assembler::below, below); // CF=1
  724 
  725   // equal
  726   __ vpxor(xmmt, xmmt, xmmt, Assembler::AVX_128bit);
  727   if (single) {
  728     __ ucomiss(a, xmmt);
  729     __ jccb(Assembler::equal, zero);
  730 
  731     __ movflt(dst, a);
  732     __ jmp(done);
  733   }
  734   else {
  735     __ ucomisd(a, xmmt);
  736     __ jccb(Assembler::equal, zero);
  737 
  738     __ movdbl(dst, a);
  739     __ jmp(done);
  740   }
  741 
  742   __ bind(zero);
  743   if (min)
  744     __ vpor(dst, a, b, Assembler::AVX_128bit);
  745   else
  746     __ vpand(dst, a, b, Assembler::AVX_128bit);
  747 
  748   __ jmp(done);
  749 
  750   __ bind(above);
  751   if (single)
  752     __ movflt(dst, min ? b : a);
  753   else
  754     __ movdbl(dst, min ? b : a);
  755 
  756   __ jmp(done);
  757 
  758   __ bind(nan);
  759   if (single) {
  760     __ movl(rt, 0x7fc00000); // Float.NaN
  761     __ movdl(dst, rt);
  762   }
  763   else {
  764     __ mov64(rt, 0x7ff8000000000000L); // Double.NaN
  765     __ movdq(dst, rt);
  766   }
  767   __ jmp(done);
  768 
  769   __ bind(below);
  770   if (single)
  771     __ movflt(dst, min ? a : b);
  772   else
  773     __ movdbl(dst, min ? a : b);
  774 
  775   __ bind(done);
  776 }
  777 
  778 //=============================================================================
  779 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  780 
  781 int ConstantTable::calculate_table_base_offset() const {
  782   return 0;  // absolute addressing, no offset
  783 }
  784 
  785 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  786 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  787   ShouldNotReachHere();
  788 }
  789 
  790 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  791   // Empty encoding
  792 }
  793 
  794 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  795   return 0;
  796 }
  797 
  798 #ifndef PRODUCT
  799 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  800   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  801 }
  802 #endif
  803 
  804 
  805 //=============================================================================
  806 #ifndef PRODUCT
  807 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  808   Compile* C = ra_-&gt;C;
  809 
  810   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  811   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();
  812   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  813   // Remove wordSize for return addr which is already pushed.
  814   framesize -= wordSize;
  815 
  816   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {
  817     framesize -= wordSize;
  818     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  819     st-&gt;print(&quot;\n\t&quot;);
  820     st-&gt;print(&quot;pushq   rbp\t# Save rbp&quot;);
  821     if (PreserveFramePointer) {
  822         st-&gt;print(&quot;\n\t&quot;);
  823         st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  824     }
  825     if (framesize) {
  826       st-&gt;print(&quot;\n\t&quot;);
  827       st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  828     }
  829   } else {
  830     st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  831     st-&gt;print(&quot;\n\t&quot;);
  832     framesize -= wordSize;
  833     st-&gt;print(&quot;movq    [rsp + #%d], rbp\t# Save rbp&quot;,framesize);
  834     if (PreserveFramePointer) {
  835       st-&gt;print(&quot;\n\t&quot;);
  836       st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  837       if (framesize &gt; 0) {
  838         st-&gt;print(&quot;\n\t&quot;);
  839         st-&gt;print(&quot;addq    rbp, #%d&quot;, framesize);
  840       }
  841     }
  842   }
  843 
  844   if (VerifyStackAtCalls) {
  845     st-&gt;print(&quot;\n\t&quot;);
  846     framesize -= wordSize;
  847     st-&gt;print(&quot;movq    [rsp + #%d], 0xbadb100d\t# Majik cookie for stack depth check&quot;,framesize);
  848 #ifdef ASSERT
  849     st-&gt;print(&quot;\n\t&quot;);
  850     st-&gt;print(&quot;# stack alignment check&quot;);
  851 #endif
  852   }
  853   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  854     st-&gt;print(&quot;\n\t&quot;);
  855     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  856     st-&gt;print(&quot;\n\t&quot;);
  857     st-&gt;print(&quot;je      fast_entry\t&quot;);
  858     st-&gt;print(&quot;\n\t&quot;);
  859     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  860     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  861   }
  862   st-&gt;cr();
  863 }
  864 #endif
  865 
  866 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  867   Compile* C = ra_-&gt;C;
  868   MacroAssembler _masm(&amp;cbuf);
  869 
<a name="1" id="anc1"></a><span class="line-removed">  870   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-removed">  871   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
<span class="line-removed">  872 </span>
  873   if (C-&gt;clinit_barrier_on_entry()) {
  874     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  875     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  876 
  877     Label L_skip_barrier;
  878     Register klass = rscratch1;
  879 
  880     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  881     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  882 
  883     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  884 
  885     __ bind(L_skip_barrier);
  886   }
  887 
<a name="2" id="anc2"></a><span class="line-modified">  888   __ verified_entry(framesize, C-&gt;output()-&gt;need_stack_bang(bangsize)?bangsize:0, false, C-&gt;stub_function() != NULL);</span>






  889 
  890   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  891 
  892   if (C-&gt;has_mach_constant_base_node()) {
  893     // NOTE: We set the table base offset here because users might be
  894     // emitted before MachConstantBaseNode.
  895     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  896     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  897   }
  898 }
  899 
<a name="3" id="anc3"></a><span class="line-removed">  900 uint MachPrologNode::size(PhaseRegAlloc* ra_) const</span>
<span class="line-removed">  901 {</span>
<span class="line-removed">  902   return MachNode::size(ra_); // too many variables; just compute it</span>
<span class="line-removed">  903                               // the hard way</span>
<span class="line-removed">  904 }</span>
<span class="line-removed">  905 </span>
  906 int MachPrologNode::reloc() const
  907 {
  908   return 0; // a large enough number
  909 }
  910 
  911 //=============================================================================
  912 #ifndef PRODUCT
  913 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  914 {
  915   Compile* C = ra_-&gt;C;
  916   if (generate_vzeroupper(C)) {
  917     st-&gt;print(&quot;vzeroupper&quot;);
  918     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  919   }
  920 
  921   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  922   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  923   // Remove word for return adr already pushed
  924   // and RBP
  925   framesize -= 2*wordSize;
  926 
  927   if (framesize) {
  928     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  929     st-&gt;print(&quot;\t&quot;);
  930   }
  931 
  932   st-&gt;print_cr(&quot;popq    rbp&quot;);
  933   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  934     st-&gt;print(&quot;\t&quot;);
  935     st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  936                  &quot;testl   rax, [rscratch1]\t&quot;
  937                  &quot;# Safepoint: poll for GC&quot;);
  938   }
  939 }
  940 #endif
  941 
  942 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  943 {
  944   Compile* C = ra_-&gt;C;
  945   MacroAssembler _masm(&amp;cbuf);
  946 
  947   if (generate_vzeroupper(C)) {
  948     // Clear upper bits of YMM registers when current compiled code uses
  949     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  950     __ vzeroupper();
  951   }
  952 
<a name="4" id="anc4"></a><span class="line-modified">  953   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  954   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);</span>
<span class="line-modified">  955   // Remove word for return adr already pushed</span>
<span class="line-removed">  956   // and RBP</span>
<span class="line-removed">  957   framesize -= 2*wordSize;</span>
<span class="line-removed">  958 </span>
<span class="line-removed">  959   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here</span>
<span class="line-removed">  960 </span>
<span class="line-removed">  961   if (framesize) {</span>
<span class="line-removed">  962     emit_opcode(cbuf, Assembler::REX_W);</span>
<span class="line-removed">  963     if (framesize &lt; 0x80) {</span>
<span class="line-removed">  964       emit_opcode(cbuf, 0x83); // addq rsp, #framesize</span>
<span class="line-removed">  965       emit_rm(cbuf, 0x3, 0x00, RSP_enc);</span>
<span class="line-removed">  966       emit_d8(cbuf, framesize);</span>
<span class="line-removed">  967     } else {</span>
<span class="line-removed">  968       emit_opcode(cbuf, 0x81); // addq rsp, #framesize</span>
<span class="line-removed">  969       emit_rm(cbuf, 0x3, 0x00, RSP_enc);</span>
<span class="line-removed">  970       emit_d32(cbuf, framesize);</span>
<span class="line-removed">  971     }</span>
<span class="line-removed">  972   }</span>
<span class="line-removed">  973 </span>
<span class="line-removed">  974   // popq rbp</span>
<span class="line-removed">  975   emit_opcode(cbuf, 0x58 | RBP_enc);</span>
  976 
  977   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  978     __ reserved_stack_check();
  979   }
  980 
  981   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  982     MacroAssembler _masm(&amp;cbuf);
  983     __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  984     __ relocate(relocInfo::poll_return_type);
  985     __ testl(rax, Address(rscratch1, 0));
  986   }
  987 }
  988 
<a name="5" id="anc5"></a><span class="line-removed">  989 uint MachEpilogNode::size(PhaseRegAlloc* ra_) const</span>
<span class="line-removed">  990 {</span>
<span class="line-removed">  991   return MachNode::size(ra_); // too many variables; just compute it</span>
<span class="line-removed">  992                               // the hard way</span>
<span class="line-removed">  993 }</span>
<span class="line-removed">  994 </span>
  995 int MachEpilogNode::reloc() const
  996 {
  997   return 2; // a large enough number
  998 }
  999 
 1000 const Pipeline* MachEpilogNode::pipeline() const
 1001 {
 1002   return MachNode::pipeline_class();
 1003 }
 1004 
 1005 //=============================================================================
 1006 
 1007 enum RC {
 1008   rc_bad,
 1009   rc_int,
 1010   rc_float,
 1011   rc_stack
 1012 };
 1013 
 1014 static enum RC rc_class(OptoReg::Name reg)
 1015 {
 1016   if( !OptoReg::is_valid(reg)  ) return rc_bad;
 1017 
 1018   if (OptoReg::is_stack(reg)) return rc_stack;
 1019 
 1020   VMReg r = OptoReg::as_VMReg(reg);
 1021 
 1022   if (r-&gt;is_Register()) return rc_int;
 1023 
 1024   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
 1025   return rc_float;
 1026 }
 1027 
 1028 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
 1029 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
 1030                           int src_hi, int dst_hi, uint ireg, outputStream* st);
 1031 
 1032 int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
 1033                      int stack_offset, int reg, uint ireg, outputStream* st);
 1034 
 1035 static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
 1036                                       int dst_offset, uint ireg, outputStream* st) {
 1037   if (cbuf) {
 1038     MacroAssembler _masm(cbuf);
 1039     switch (ireg) {
 1040     case Op_VecS:
 1041       __ movq(Address(rsp, -8), rax);
 1042       __ movl(rax, Address(rsp, src_offset));
 1043       __ movl(Address(rsp, dst_offset), rax);
 1044       __ movq(rax, Address(rsp, -8));
 1045       break;
 1046     case Op_VecD:
 1047       __ pushq(Address(rsp, src_offset));
 1048       __ popq (Address(rsp, dst_offset));
 1049       break;
 1050     case Op_VecX:
 1051       __ pushq(Address(rsp, src_offset));
 1052       __ popq (Address(rsp, dst_offset));
 1053       __ pushq(Address(rsp, src_offset+8));
 1054       __ popq (Address(rsp, dst_offset+8));
 1055       break;
 1056     case Op_VecY:
 1057       __ vmovdqu(Address(rsp, -32), xmm0);
 1058       __ vmovdqu(xmm0, Address(rsp, src_offset));
 1059       __ vmovdqu(Address(rsp, dst_offset), xmm0);
 1060       __ vmovdqu(xmm0, Address(rsp, -32));
 1061       break;
 1062     case Op_VecZ:
 1063       __ evmovdquq(Address(rsp, -64), xmm0, 2);
 1064       __ evmovdquq(xmm0, Address(rsp, src_offset), 2);
 1065       __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);
 1066       __ evmovdquq(xmm0, Address(rsp, -64), 2);
 1067       break;
 1068     default:
 1069       ShouldNotReachHere();
 1070     }
 1071 #ifndef PRODUCT
 1072   } else {
 1073     switch (ireg) {
 1074     case Op_VecS:
 1075       st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1076                 &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1077                 &quot;movl    [rsp + #%d], rax\n\t&quot;
 1078                 &quot;movq    rax, [rsp - #8]&quot;,
 1079                 src_offset, dst_offset);
 1080       break;
 1081     case Op_VecD:
 1082       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1083                 &quot;popq    [rsp + #%d]&quot;,
 1084                 src_offset, dst_offset);
 1085       break;
 1086      case Op_VecX:
 1087       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 128-bit mem-mem spill\n\t&quot;
 1088                 &quot;popq    [rsp + #%d]\n\t&quot;
 1089                 &quot;pushq   [rsp + #%d]\n\t&quot;
 1090                 &quot;popq    [rsp + #%d]&quot;,
 1091                 src_offset, dst_offset, src_offset+8, dst_offset+8);
 1092       break;
 1093     case Op_VecY:
 1094       st-&gt;print(&quot;vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t&quot;
 1095                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1096                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1097                 &quot;vmovdqu xmm0, [rsp - #32]&quot;,
 1098                 src_offset, dst_offset);
 1099       break;
 1100     case Op_VecZ:
 1101       st-&gt;print(&quot;vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t&quot;
 1102                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1103                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1104                 &quot;vmovdqu xmm0, [rsp - #64]&quot;,
 1105                 src_offset, dst_offset);
 1106       break;
 1107     default:
 1108       ShouldNotReachHere();
 1109     }
 1110 #endif
 1111   }
 1112 }
 1113 
 1114 uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
 1115                                        PhaseRegAlloc* ra_,
 1116                                        bool do_size,
 1117                                        outputStream* st) const {
 1118   assert(cbuf != NULL || st  != NULL, &quot;sanity&quot;);
 1119   // Get registers to move
 1120   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
 1121   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
 1122   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this);
 1123   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this);
 1124 
 1125   enum RC src_second_rc = rc_class(src_second);
 1126   enum RC src_first_rc = rc_class(src_first);
 1127   enum RC dst_second_rc = rc_class(dst_second);
 1128   enum RC dst_first_rc = rc_class(dst_first);
 1129 
 1130   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first),
 1131          &quot;must move at least 1 register&quot; );
 1132 
 1133   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
 1134     // Self copy, no move
 1135     return 0;
 1136   }
 1137   if (bottom_type()-&gt;isa_vect() != NULL) {
 1138     uint ireg = ideal_reg();
 1139     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), &quot;sanity&quot;);
 1140     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), &quot;sanity&quot;);
 1141     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1142       // mem -&gt; mem
 1143       int src_offset = ra_-&gt;reg2offset(src_first);
 1144       int dst_offset = ra_-&gt;reg2offset(dst_first);
 1145       vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);
 1146     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
 1147       vec_mov_helper(cbuf, false, src_first, dst_first, src_second, dst_second, ireg, st);
 1148     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
 1149       int stack_offset = ra_-&gt;reg2offset(dst_first);
 1150       vec_spill_helper(cbuf, false, false, stack_offset, src_first, ireg, st);
 1151     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_float ) {
 1152       int stack_offset = ra_-&gt;reg2offset(src_first);
 1153       vec_spill_helper(cbuf, false, true,  stack_offset, dst_first, ireg, st);
 1154     } else {
 1155       ShouldNotReachHere();
 1156     }
 1157     return 0;
 1158   }
 1159   if (src_first_rc == rc_stack) {
 1160     // mem -&gt;
 1161     if (dst_first_rc == rc_stack) {
 1162       // mem -&gt; mem
 1163       assert(src_second != dst_first, &quot;overlap&quot;);
 1164       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1165           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1166         // 64-bit
 1167         int src_offset = ra_-&gt;reg2offset(src_first);
 1168         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1169         if (cbuf) {
 1170           MacroAssembler _masm(cbuf);
 1171           __ pushq(Address(rsp, src_offset));
 1172           __ popq (Address(rsp, dst_offset));
 1173 #ifndef PRODUCT
 1174         } else {
 1175           st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1176                     &quot;popq    [rsp + #%d]&quot;,
 1177                      src_offset, dst_offset);
 1178 #endif
 1179         }
 1180       } else {
 1181         // 32-bit
 1182         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1183         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1184         // No pushl/popl, so:
 1185         int src_offset = ra_-&gt;reg2offset(src_first);
 1186         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1187         if (cbuf) {
 1188           MacroAssembler _masm(cbuf);
 1189           __ movq(Address(rsp, -8), rax);
 1190           __ movl(rax, Address(rsp, src_offset));
 1191           __ movl(Address(rsp, dst_offset), rax);
 1192           __ movq(rax, Address(rsp, -8));
 1193 #ifndef PRODUCT
 1194         } else {
 1195           st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1196                     &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1197                     &quot;movl    [rsp + #%d], rax\n\t&quot;
 1198                     &quot;movq    rax, [rsp - #8]&quot;,
 1199                      src_offset, dst_offset);
 1200 #endif
 1201         }
 1202       }
 1203       return 0;
 1204     } else if (dst_first_rc == rc_int) {
 1205       // mem -&gt; gpr
 1206       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1207           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1208         // 64-bit
 1209         int offset = ra_-&gt;reg2offset(src_first);
 1210         if (cbuf) {
 1211           MacroAssembler _masm(cbuf);
 1212           __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1213 #ifndef PRODUCT
 1214         } else {
 1215           st-&gt;print(&quot;movq    %s, [rsp + #%d]\t# spill&quot;,
 1216                      Matcher::regName[dst_first],
 1217                      offset);
 1218 #endif
 1219         }
 1220       } else {
 1221         // 32-bit
 1222         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1223         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1224         int offset = ra_-&gt;reg2offset(src_first);
 1225         if (cbuf) {
 1226           MacroAssembler _masm(cbuf);
 1227           __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1228 #ifndef PRODUCT
 1229         } else {
 1230           st-&gt;print(&quot;movl    %s, [rsp + #%d]\t# spill&quot;,
 1231                      Matcher::regName[dst_first],
 1232                      offset);
 1233 #endif
 1234         }
 1235       }
 1236       return 0;
 1237     } else if (dst_first_rc == rc_float) {
 1238       // mem-&gt; xmm
 1239       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1240           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1241         // 64-bit
 1242         int offset = ra_-&gt;reg2offset(src_first);
 1243         if (cbuf) {
 1244           MacroAssembler _masm(cbuf);
 1245           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1246 #ifndef PRODUCT
 1247         } else {
 1248           st-&gt;print(&quot;%s  %s, [rsp + #%d]\t# spill&quot;,
 1249                      UseXmmLoadAndClearUpper ? &quot;movsd &quot; : &quot;movlpd&quot;,
 1250                      Matcher::regName[dst_first],
 1251                      offset);
 1252 #endif
 1253         }
 1254       } else {
 1255         // 32-bit
 1256         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1257         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1258         int offset = ra_-&gt;reg2offset(src_first);
 1259         if (cbuf) {
 1260           MacroAssembler _masm(cbuf);
 1261           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1262 #ifndef PRODUCT
 1263         } else {
 1264           st-&gt;print(&quot;movss   %s, [rsp + #%d]\t# spill&quot;,
 1265                      Matcher::regName[dst_first],
 1266                      offset);
 1267 #endif
 1268         }
 1269       }
 1270       return 0;
 1271     }
 1272   } else if (src_first_rc == rc_int) {
 1273     // gpr -&gt;
 1274     if (dst_first_rc == rc_stack) {
 1275       // gpr -&gt; mem
 1276       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1277           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1278         // 64-bit
 1279         int offset = ra_-&gt;reg2offset(dst_first);
 1280         if (cbuf) {
 1281           MacroAssembler _masm(cbuf);
 1282           __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1283 #ifndef PRODUCT
 1284         } else {
 1285           st-&gt;print(&quot;movq    [rsp + #%d], %s\t# spill&quot;,
 1286                      offset,
 1287                      Matcher::regName[src_first]);
 1288 #endif
 1289         }
 1290       } else {
 1291         // 32-bit
 1292         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1293         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1294         int offset = ra_-&gt;reg2offset(dst_first);
 1295         if (cbuf) {
 1296           MacroAssembler _masm(cbuf);
 1297           __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1298 #ifndef PRODUCT
 1299         } else {
 1300           st-&gt;print(&quot;movl    [rsp + #%d], %s\t# spill&quot;,
 1301                      offset,
 1302                      Matcher::regName[src_first]);
 1303 #endif
 1304         }
 1305       }
 1306       return 0;
 1307     } else if (dst_first_rc == rc_int) {
 1308       // gpr -&gt; gpr
 1309       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1310           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1311         // 64-bit
 1312         if (cbuf) {
 1313           MacroAssembler _masm(cbuf);
 1314           __ movq(as_Register(Matcher::_regEncode[dst_first]),
 1315                   as_Register(Matcher::_regEncode[src_first]));
 1316 #ifndef PRODUCT
 1317         } else {
 1318           st-&gt;print(&quot;movq    %s, %s\t# spill&quot;,
 1319                      Matcher::regName[dst_first],
 1320                      Matcher::regName[src_first]);
 1321 #endif
 1322         }
 1323         return 0;
 1324       } else {
 1325         // 32-bit
 1326         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1327         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1328         if (cbuf) {
 1329           MacroAssembler _masm(cbuf);
 1330           __ movl(as_Register(Matcher::_regEncode[dst_first]),
 1331                   as_Register(Matcher::_regEncode[src_first]));
 1332 #ifndef PRODUCT
 1333         } else {
 1334           st-&gt;print(&quot;movl    %s, %s\t# spill&quot;,
 1335                      Matcher::regName[dst_first],
 1336                      Matcher::regName[src_first]);
 1337 #endif
 1338         }
 1339         return 0;
 1340       }
 1341     } else if (dst_first_rc == rc_float) {
 1342       // gpr -&gt; xmm
 1343       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1344           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1345         // 64-bit
 1346         if (cbuf) {
 1347           MacroAssembler _masm(cbuf);
 1348           __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1349 #ifndef PRODUCT
 1350         } else {
 1351           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1352                      Matcher::regName[dst_first],
 1353                      Matcher::regName[src_first]);
 1354 #endif
 1355         }
 1356       } else {
 1357         // 32-bit
 1358         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1359         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1360         if (cbuf) {
 1361           MacroAssembler _masm(cbuf);
 1362           __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1363 #ifndef PRODUCT
 1364         } else {
 1365           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1366                      Matcher::regName[dst_first],
 1367                      Matcher::regName[src_first]);
 1368 #endif
 1369         }
 1370       }
 1371       return 0;
 1372     }
 1373   } else if (src_first_rc == rc_float) {
 1374     // xmm -&gt;
 1375     if (dst_first_rc == rc_stack) {
 1376       // xmm -&gt; mem
 1377       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1378           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1379         // 64-bit
 1380         int offset = ra_-&gt;reg2offset(dst_first);
 1381         if (cbuf) {
 1382           MacroAssembler _masm(cbuf);
 1383           __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1384 #ifndef PRODUCT
 1385         } else {
 1386           st-&gt;print(&quot;movsd   [rsp + #%d], %s\t# spill&quot;,
 1387                      offset,
 1388                      Matcher::regName[src_first]);
 1389 #endif
 1390         }
 1391       } else {
 1392         // 32-bit
 1393         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1394         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1395         int offset = ra_-&gt;reg2offset(dst_first);
 1396         if (cbuf) {
 1397           MacroAssembler _masm(cbuf);
 1398           __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1399 #ifndef PRODUCT
 1400         } else {
 1401           st-&gt;print(&quot;movss   [rsp + #%d], %s\t# spill&quot;,
 1402                      offset,
 1403                      Matcher::regName[src_first]);
 1404 #endif
 1405         }
 1406       }
 1407       return 0;
 1408     } else if (dst_first_rc == rc_int) {
 1409       // xmm -&gt; gpr
 1410       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1411           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1412         // 64-bit
 1413         if (cbuf) {
 1414           MacroAssembler _masm(cbuf);
 1415           __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1416 #ifndef PRODUCT
 1417         } else {
 1418           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1419                      Matcher::regName[dst_first],
 1420                      Matcher::regName[src_first]);
 1421 #endif
 1422         }
 1423       } else {
 1424         // 32-bit
 1425         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1426         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1427         if (cbuf) {
 1428           MacroAssembler _masm(cbuf);
 1429           __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1430 #ifndef PRODUCT
 1431         } else {
 1432           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1433                      Matcher::regName[dst_first],
 1434                      Matcher::regName[src_first]);
 1435 #endif
 1436         }
 1437       }
 1438       return 0;
 1439     } else if (dst_first_rc == rc_float) {
 1440       // xmm -&gt; xmm
 1441       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1442           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1443         // 64-bit
 1444         if (cbuf) {
 1445           MacroAssembler _masm(cbuf);
 1446           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1447 #ifndef PRODUCT
 1448         } else {
 1449           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1450                      UseXmmRegToRegMoveAll ? &quot;movapd&quot; : &quot;movsd &quot;,
 1451                      Matcher::regName[dst_first],
 1452                      Matcher::regName[src_first]);
 1453 #endif
 1454         }
 1455       } else {
 1456         // 32-bit
 1457         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1458         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1459         if (cbuf) {
 1460           MacroAssembler _masm(cbuf);
 1461           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1462 #ifndef PRODUCT
 1463         } else {
 1464           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1465                      UseXmmRegToRegMoveAll ? &quot;movaps&quot; : &quot;movss &quot;,
 1466                      Matcher::regName[dst_first],
 1467                      Matcher::regName[src_first]);
 1468 #endif
 1469         }
 1470       }
 1471       return 0;
 1472     }
 1473   }
 1474 
 1475   assert(0,&quot; foo &quot;);
 1476   Unimplemented();
 1477   return 0;
 1478 }
 1479 
 1480 #ifndef PRODUCT
 1481 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1482   implementation(NULL, ra_, false, st);
 1483 }
 1484 #endif
 1485 
 1486 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1487   implementation(&amp;cbuf, ra_, false, NULL);
 1488 }
 1489 
 1490 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1491   return MachNode::size(ra_);
 1492 }
 1493 
 1494 //=============================================================================
 1495 #ifndef PRODUCT
 1496 void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1497 {
 1498   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1499   int reg = ra_-&gt;get_reg_first(this);
 1500   st-&gt;print(&quot;leaq    %s, [rsp + #%d]\t# box lock&quot;,
 1501             Matcher::regName[reg], offset);
 1502 }
 1503 #endif
 1504 
 1505 void BoxLockNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1506 {
 1507   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1508   int reg = ra_-&gt;get_encode(this);
 1509   if (offset &gt;= 0x80) {
 1510     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1511     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1512     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1513     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1514     emit_d32(cbuf, offset);
 1515   } else {
 1516     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1517     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1518     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1519     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1520     emit_d8(cbuf, offset);
 1521   }
 1522 }
 1523 
 1524 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1525 {
 1526   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1527   return (offset &lt; 0x80) ? 5 : 8; // REX
 1528 }
 1529 
<a name="6" id="anc6"></a>



























 1530 //=============================================================================
 1531 #ifndef PRODUCT
 1532 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1533 {
 1534   if (UseCompressedClassPointers) {
 1535     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1536     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1537     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1538   } else {
 1539     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1540                  &quot;# Inline cache check&quot;);
 1541   }
 1542   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1543   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1544 }
 1545 #endif
 1546 
 1547 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1548 {
 1549   MacroAssembler masm(&amp;cbuf);
 1550   uint insts_size = cbuf.insts_size();
 1551   if (UseCompressedClassPointers) {
 1552     masm.load_klass(rscratch1, j_rarg0, rscratch2);
 1553     masm.cmpptr(rax, rscratch1);
 1554   } else {
 1555     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1556   }
 1557 
 1558   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1559 
 1560   /* WARNING these NOPs are critical so that verified entry point is properly
 1561      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1562   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1563   if (OptoBreakpoint) {
 1564     // Leave space for int3
 1565     nops_cnt -= 1;
 1566   }
 1567   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1568   if (nops_cnt &gt; 0)
 1569     masm.nop(nops_cnt);
 1570 }
 1571 
<a name="7" id="anc7"></a><span class="line-removed"> 1572 uint MachUEPNode::size(PhaseRegAlloc* ra_) const</span>
<span class="line-removed"> 1573 {</span>
<span class="line-removed"> 1574   return MachNode::size(ra_); // too many variables; just compute it</span>
<span class="line-removed"> 1575                               // the hard way</span>
<span class="line-removed"> 1576 }</span>
<span class="line-removed"> 1577 </span>
<span class="line-removed"> 1578 </span>
 1579 //=============================================================================
 1580 
 1581 int Matcher::regnum_to_fpu_offset(int regnum)
 1582 {
 1583   return regnum - 32; // The FP registers are in the second chunk
 1584 }
 1585 
 1586 // This is UltraSparc specific, true just means we have fast l2f conversion
 1587 const bool Matcher::convL2FSupported(void) {
 1588   return true;
 1589 }
 1590 
 1591 // Is this branch offset short enough that a short branch can be used?
 1592 //
 1593 // NOTE: If the platform does not provide any short branch variants, then
 1594 //       this method should return false for offset 0.
 1595 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1596   // The passed offset is relative to address of the branch.
 1597   // On 86 a branch displacement is calculated relative to address
 1598   // of a next instruction.
 1599   offset -= br_size;
 1600 
 1601   // the short version of jmpConUCF2 contains multiple branches,
 1602   // making the reach slightly less
 1603   if (rule == jmpConUCF2_rule)
 1604     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
 1605   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
 1606 }
 1607 
 1608 const bool Matcher::isSimpleConstant64(jlong value) {
 1609   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1610   //return value == (int) value;  // Cf. storeImmL and immL32.
 1611 
 1612   // Probably always true, even if a temp register is required.
 1613   return true;
 1614 }
 1615 
 1616 // The ecx parameter to rep stosq for the ClearArray node is in words.
 1617 const bool Matcher::init_array_count_is_in_bytes = false;
 1618 
 1619 // No additional cost for CMOVL.
 1620 const int Matcher::long_cmove_cost() { return 0; }
 1621 
 1622 // No CMOVF/CMOVD with SSE2
 1623 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1624 
 1625 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1626 const bool Matcher::require_postalloc_expand = false;
 1627 
 1628 // Do we need to mask the count passed to shift instructions or does
 1629 // the cpu only look at the lower 5/6 bits anyway?
 1630 const bool Matcher::need_masked_shift_count = false;
 1631 
 1632 bool Matcher::narrow_oop_use_complex_address() {
 1633   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1634   return (LogMinObjAlignmentInBytes &lt;= 3);
 1635 }
 1636 
 1637 bool Matcher::narrow_klass_use_complex_address() {
 1638   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1639   return (LogKlassAlignmentInBytes &lt;= 3);
 1640 }
 1641 
 1642 bool Matcher::const_oop_prefer_decode() {
 1643   // Prefer ConN+DecodeN over ConP.
 1644   return true;
 1645 }
 1646 
 1647 bool Matcher::const_klass_prefer_decode() {
 1648   // TODO: Either support matching DecodeNKlass (heap-based) in operand
 1649   //       or condisider the following:
 1650   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 1651   //return CompressedKlassPointers::base() == NULL;
 1652   return true;
 1653 }
 1654 
 1655 // Is it better to copy float constants, or load them directly from
 1656 // memory?  Intel can load a float constant from a direct address,
 1657 // requiring no extra registers.  Most RISCs will have to materialize
 1658 // an address into a register first, so they would do better to copy
 1659 // the constant from stack.
 1660 const bool Matcher::rematerialize_float_constants = true; // XXX
 1661 
 1662 // If CPU can load and store mis-aligned doubles directly then no
 1663 // fixup is needed.  Else we split the double into 2 integer pieces
 1664 // and move it piece-by-piece.  Only happens when passing doubles into
 1665 // C code as the Java calling convention forces doubles to be aligned.
 1666 const bool Matcher::misaligned_doubles_ok = true;
 1667 
 1668 // No-op on amd64
 1669 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
 1670 
 1671 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1672 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1673 
 1674 // Are floats conerted to double when stored to stack during deoptimization?
 1675 // On x64 it is stored without convertion so we can use normal access.
 1676 bool Matcher::float_in_double() { return false; }
 1677 
 1678 // Do ints take an entire long register or just half?
 1679 const bool Matcher::int_in_long = true;
 1680 
 1681 // Return whether or not this register is ever used as an argument.
 1682 // This function is used on startup to build the trampoline stubs in
 1683 // generateOptoStub.  Registers not mentioned will be killed by the VM
 1684 // call in the trampoline, and arguments in those registers not be
 1685 // available to the callee.
 1686 bool Matcher::can_be_java_arg(int reg)
 1687 {
 1688   return
 1689     reg ==  RDI_num || reg == RDI_H_num ||
 1690     reg ==  RSI_num || reg == RSI_H_num ||
 1691     reg ==  RDX_num || reg == RDX_H_num ||
 1692     reg ==  RCX_num || reg == RCX_H_num ||
 1693     reg ==   R8_num || reg ==  R8_H_num ||
 1694     reg ==   R9_num || reg ==  R9_H_num ||
 1695     reg ==  R12_num || reg == R12_H_num ||
 1696     reg == XMM0_num || reg == XMM0b_num ||
 1697     reg == XMM1_num || reg == XMM1b_num ||
 1698     reg == XMM2_num || reg == XMM2b_num ||
 1699     reg == XMM3_num || reg == XMM3b_num ||
 1700     reg == XMM4_num || reg == XMM4b_num ||
 1701     reg == XMM5_num || reg == XMM5b_num ||
 1702     reg == XMM6_num || reg == XMM6b_num ||
 1703     reg == XMM7_num || reg == XMM7b_num;
 1704 }
 1705 
 1706 bool Matcher::is_spillable_arg(int reg)
 1707 {
 1708   return can_be_java_arg(reg);
 1709 }
 1710 
 1711 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1712   // In 64 bit mode a code which use multiply when
 1713   // devisor is constant is faster than hardware
 1714   // DIV instruction (it uses MulHiL).
 1715   return false;
 1716 }
 1717 
 1718 // Register for DIVI projection of divmodI
 1719 RegMask Matcher::divI_proj_mask() {
 1720   return INT_RAX_REG_mask();
 1721 }
 1722 
 1723 // Register for MODI projection of divmodI
 1724 RegMask Matcher::modI_proj_mask() {
 1725   return INT_RDX_REG_mask();
 1726 }
 1727 
 1728 // Register for DIVL projection of divmodL
 1729 RegMask Matcher::divL_proj_mask() {
 1730   return LONG_RAX_REG_mask();
 1731 }
 1732 
 1733 // Register for MODL projection of divmodL
 1734 RegMask Matcher::modL_proj_mask() {
 1735   return LONG_RDX_REG_mask();
 1736 }
 1737 
 1738 // Register for saving SP into on method handle invokes. Not used on x86_64.
 1739 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1740     return NO_REG_mask();
 1741 }
 1742 
 1743 %}
 1744 
 1745 //----------ENCODING BLOCK-----------------------------------------------------
 1746 // This block specifies the encoding classes used by the compiler to
 1747 // output byte streams.  Encoding classes are parameterized macros
 1748 // used by Machine Instruction Nodes in order to generate the bit
 1749 // encoding of the instruction.  Operands specify their base encoding
 1750 // interface with the interface keyword.  There are currently
 1751 // supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &amp;
 1752 // COND_INTER.  REG_INTER causes an operand to generate a function
 1753 // which returns its register number when queried.  CONST_INTER causes
 1754 // an operand to generate a function which returns the value of the
 1755 // constant when queried.  MEMORY_INTER causes an operand to generate
 1756 // four functions which return the Base Register, the Index Register,
 1757 // the Scale Value, and the Offset Value of the operand when queried.
 1758 // COND_INTER causes an operand to generate six functions which return
 1759 // the encoding code (ie - encoding bits for the instruction)
 1760 // associated with each basic boolean condition for a conditional
 1761 // instruction.
 1762 //
 1763 // Instructions specify two basic values for encoding.  Again, a
 1764 // function is available to check if the constant displacement is an
 1765 // oop. They use the ins_encode keyword to specify their encoding
 1766 // classes (which must be a sequence of enc_class names, and their
 1767 // parameters, specified in the encoding block), and they use the
 1768 // opcode keyword to specify, in order, their primary, secondary, and
 1769 // tertiary opcode.  Only the opcode sections which a particular
 1770 // instruction needs for encoding need to be specified.
 1771 encode %{
 1772   // Build emit functions for each basic byte or larger field in the
 1773   // intel encoding scheme (opcode, rm, sib, immediate), and call them
 1774   // from C++ code in the enc_class source block.  Emit functions will
 1775   // live in the main source block for now.  In future, we can
 1776   // generalize this by adding a syntax that specifies the sizes of
 1777   // fields in an order, so that the adlc can build the emit functions
 1778   // automagically
 1779 
 1780   // Emit primary opcode
 1781   enc_class OpcP
 1782   %{
 1783     emit_opcode(cbuf, $primary);
 1784   %}
 1785 
 1786   // Emit secondary opcode
 1787   enc_class OpcS
 1788   %{
 1789     emit_opcode(cbuf, $secondary);
 1790   %}
 1791 
 1792   // Emit tertiary opcode
 1793   enc_class OpcT
 1794   %{
 1795     emit_opcode(cbuf, $tertiary);
 1796   %}
 1797 
 1798   // Emit opcode directly
 1799   enc_class Opcode(immI d8)
 1800   %{
 1801     emit_opcode(cbuf, $d8$$constant);
 1802   %}
 1803 
 1804   // Emit size prefix
 1805   enc_class SizePrefix
 1806   %{
 1807     emit_opcode(cbuf, 0x66);
 1808   %}
 1809 
 1810   enc_class reg(rRegI reg)
 1811   %{
 1812     emit_rm(cbuf, 0x3, 0, $reg$$reg &amp; 7);
 1813   %}
 1814 
 1815   enc_class reg_reg(rRegI dst, rRegI src)
 1816   %{
 1817     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1818   %}
 1819 
 1820   enc_class opc_reg_reg(immI opcode, rRegI dst, rRegI src)
 1821   %{
 1822     emit_opcode(cbuf, $opcode$$constant);
 1823     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1824   %}
 1825 
 1826   enc_class cdql_enc(no_rax_rdx_RegI div)
 1827   %{
 1828     // Full implementation of Java idiv and irem; checks for
 1829     // special case as described in JVM spec., p.243 &amp; p.271.
 1830     //
 1831     //         normal case                           special case
 1832     //
 1833     // input : rax: dividend                         min_int
 1834     //         reg: divisor                          -1
 1835     //
 1836     // output: rax: quotient  (= rax idiv reg)       min_int
 1837     //         rdx: remainder (= rax irem reg)       0
 1838     //
 1839     //  Code sequnce:
 1840     //
 1841     //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
 1842     //    5:   75 07/08                jne    e &lt;normal&gt;
 1843     //    7:   33 d2                   xor    %edx,%edx
 1844     //  [div &gt;= 8 -&gt; offset + 1]
 1845     //  [REX_B]
 1846     //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
 1847     //    c:   74 03/04                je     11 &lt;done&gt;
 1848     // 000000000000000e &lt;normal&gt;:
 1849     //    e:   99                      cltd
 1850     //  [div &gt;= 8 -&gt; offset + 1]
 1851     //  [REX_B]
 1852     //    f:   f7 f9                   idiv   $div
 1853     // 0000000000000011 &lt;done&gt;:
 1854 
 1855     // cmp    $0x80000000,%eax
 1856     emit_opcode(cbuf, 0x3d);
 1857     emit_d8(cbuf, 0x00);
 1858     emit_d8(cbuf, 0x00);
 1859     emit_d8(cbuf, 0x00);
 1860     emit_d8(cbuf, 0x80);
 1861 
 1862     // jne    e &lt;normal&gt;
 1863     emit_opcode(cbuf, 0x75);
 1864     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x07 : 0x08);
 1865 
 1866     // xor    %edx,%edx
 1867     emit_opcode(cbuf, 0x33);
 1868     emit_d8(cbuf, 0xD2);
 1869 
 1870     // cmp    $0xffffffffffffffff,%ecx
 1871     if ($div$$reg &gt;= 8) {
 1872       emit_opcode(cbuf, Assembler::REX_B);
 1873     }
 1874     emit_opcode(cbuf, 0x83);
 1875     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1876     emit_d8(cbuf, 0xFF);
 1877 
 1878     // je     11 &lt;done&gt;
 1879     emit_opcode(cbuf, 0x74);
 1880     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x03 : 0x04);
 1881 
 1882     // &lt;normal&gt;
 1883     // cltd
 1884     emit_opcode(cbuf, 0x99);
 1885 
 1886     // idivl (note: must be emitted by the user of this rule)
 1887     // &lt;done&gt;
 1888   %}
 1889 
 1890   enc_class cdqq_enc(no_rax_rdx_RegL div)
 1891   %{
 1892     // Full implementation of Java ldiv and lrem; checks for
 1893     // special case as described in JVM spec., p.243 &amp; p.271.
 1894     //
 1895     //         normal case                           special case
 1896     //
 1897     // input : rax: dividend                         min_long
 1898     //         reg: divisor                          -1
 1899     //
 1900     // output: rax: quotient  (= rax idiv reg)       min_long
 1901     //         rdx: remainder (= rax irem reg)       0
 1902     //
 1903     //  Code sequnce:
 1904     //
 1905     //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
 1906     //    7:   00 00 80
 1907     //    a:   48 39 d0                cmp    %rdx,%rax
 1908     //    d:   75 08                   jne    17 &lt;normal&gt;
 1909     //    f:   33 d2                   xor    %edx,%edx
 1910     //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
 1911     //   15:   74 05                   je     1c &lt;done&gt;
 1912     // 0000000000000017 &lt;normal&gt;:
 1913     //   17:   48 99                   cqto
 1914     //   19:   48 f7 f9                idiv   $div
 1915     // 000000000000001c &lt;done&gt;:
 1916 
 1917     // mov    $0x8000000000000000,%rdx
 1918     emit_opcode(cbuf, Assembler::REX_W);
 1919     emit_opcode(cbuf, 0xBA);
 1920     emit_d8(cbuf, 0x00);
 1921     emit_d8(cbuf, 0x00);
 1922     emit_d8(cbuf, 0x00);
 1923     emit_d8(cbuf, 0x00);
 1924     emit_d8(cbuf, 0x00);
 1925     emit_d8(cbuf, 0x00);
 1926     emit_d8(cbuf, 0x00);
 1927     emit_d8(cbuf, 0x80);
 1928 
 1929     // cmp    %rdx,%rax
 1930     emit_opcode(cbuf, Assembler::REX_W);
 1931     emit_opcode(cbuf, 0x39);
 1932     emit_d8(cbuf, 0xD0);
 1933 
 1934     // jne    17 &lt;normal&gt;
 1935     emit_opcode(cbuf, 0x75);
 1936     emit_d8(cbuf, 0x08);
 1937 
 1938     // xor    %edx,%edx
 1939     emit_opcode(cbuf, 0x33);
 1940     emit_d8(cbuf, 0xD2);
 1941 
 1942     // cmp    $0xffffffffffffffff,$div
 1943     emit_opcode(cbuf, $div$$reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WB);
 1944     emit_opcode(cbuf, 0x83);
 1945     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1946     emit_d8(cbuf, 0xFF);
 1947 
 1948     // je     1e &lt;done&gt;
 1949     emit_opcode(cbuf, 0x74);
 1950     emit_d8(cbuf, 0x05);
 1951 
 1952     // &lt;normal&gt;
 1953     // cqto
 1954     emit_opcode(cbuf, Assembler::REX_W);
 1955     emit_opcode(cbuf, 0x99);
 1956 
 1957     // idivq (note: must be emitted by the user of this rule)
 1958     // &lt;done&gt;
 1959   %}
 1960 
 1961   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
 1962   enc_class OpcSE(immI imm)
 1963   %{
 1964     // Emit primary opcode and set sign-extend bit
 1965     // Check for 8-bit immediate, and set sign extend bit in opcode
 1966     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1967       emit_opcode(cbuf, $primary | 0x02);
 1968     } else {
 1969       // 32-bit immediate
 1970       emit_opcode(cbuf, $primary);
 1971     }
 1972   %}
 1973 
 1974   enc_class OpcSErm(rRegI dst, immI imm)
 1975   %{
 1976     // OpcSEr/m
 1977     int dstenc = $dst$$reg;
 1978     if (dstenc &gt;= 8) {
 1979       emit_opcode(cbuf, Assembler::REX_B);
 1980       dstenc -= 8;
 1981     }
 1982     // Emit primary opcode and set sign-extend bit
 1983     // Check for 8-bit immediate, and set sign extend bit in opcode
 1984     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1985       emit_opcode(cbuf, $primary | 0x02);
 1986     } else {
 1987       // 32-bit immediate
 1988       emit_opcode(cbuf, $primary);
 1989     }
 1990     // Emit r/m byte with secondary opcode, after primary opcode.
 1991     emit_rm(cbuf, 0x3, $secondary, dstenc);
 1992   %}
 1993 
 1994   enc_class OpcSErm_wide(rRegL dst, immI imm)
 1995   %{
 1996     // OpcSEr/m
 1997     int dstenc = $dst$$reg;
 1998     if (dstenc &lt; 8) {
 1999       emit_opcode(cbuf, Assembler::REX_W);
 2000     } else {
 2001       emit_opcode(cbuf, Assembler::REX_WB);
 2002       dstenc -= 8;
 2003     }
 2004     // Emit primary opcode and set sign-extend bit
 2005     // Check for 8-bit immediate, and set sign extend bit in opcode
 2006     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2007       emit_opcode(cbuf, $primary | 0x02);
 2008     } else {
 2009       // 32-bit immediate
 2010       emit_opcode(cbuf, $primary);
 2011     }
 2012     // Emit r/m byte with secondary opcode, after primary opcode.
 2013     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2014   %}
 2015 
 2016   enc_class Con8or32(immI imm)
 2017   %{
 2018     // Check for 8-bit immediate, and set sign extend bit in opcode
 2019     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2020       $$$emit8$imm$$constant;
 2021     } else {
 2022       // 32-bit immediate
 2023       $$$emit32$imm$$constant;
 2024     }
 2025   %}
 2026 
 2027   enc_class opc2_reg(rRegI dst)
 2028   %{
 2029     // BSWAP
 2030     emit_cc(cbuf, $secondary, $dst$$reg);
 2031   %}
 2032 
 2033   enc_class opc3_reg(rRegI dst)
 2034   %{
 2035     // BSWAP
 2036     emit_cc(cbuf, $tertiary, $dst$$reg);
 2037   %}
 2038 
 2039   enc_class reg_opc(rRegI div)
 2040   %{
 2041     // INC, DEC, IDIV, IMOD, JMP indirect, ...
 2042     emit_rm(cbuf, 0x3, $secondary, $div$$reg &amp; 7);
 2043   %}
 2044 
 2045   enc_class enc_cmov(cmpOp cop)
 2046   %{
 2047     // CMOV
 2048     $$$emit8$primary;
 2049     emit_cc(cbuf, $secondary, $cop$$cmpcode);
 2050   %}
 2051 
 2052   enc_class enc_PartialSubtypeCheck()
 2053   %{
 2054     Register Rrdi = as_Register(RDI_enc); // result register
 2055     Register Rrax = as_Register(RAX_enc); // super class
 2056     Register Rrcx = as_Register(RCX_enc); // killed
 2057     Register Rrsi = as_Register(RSI_enc); // sub class
 2058     Label miss;
 2059     const bool set_cond_codes = true;
 2060 
 2061     MacroAssembler _masm(&amp;cbuf);
 2062     __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
 2063                                      NULL, &amp;miss,
 2064                                      /*set_cond_codes:*/ true);
 2065     if ($primary) {
 2066       __ xorptr(Rrdi, Rrdi);
 2067     }
 2068     __ bind(miss);
 2069   %}
 2070 
 2071   enc_class clear_avx %{
 2072     debug_only(int off0 = cbuf.insts_size());
 2073     if (generate_vzeroupper(Compile::current())) {
 2074       // Clear upper bits of YMM registers to avoid AVX &lt;-&gt; SSE transition penalty
 2075       // Clear upper bits of YMM registers when current compiled code uses
 2076       // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 2077       MacroAssembler _masm(&amp;cbuf);
 2078       __ vzeroupper();
 2079     }
 2080     debug_only(int off1 = cbuf.insts_size());
 2081     assert(off1 - off0 == clear_avx_size(), &quot;correct size prediction&quot;);
 2082   %}
 2083 
 2084   enc_class Java_To_Runtime(method meth) %{
 2085     // No relocation needed
 2086     MacroAssembler _masm(&amp;cbuf);
 2087     __ mov64(r10, (int64_t) $meth$$method);
 2088     __ call(r10);
 2089   %}
 2090 
 2091   enc_class Java_To_Interpreter(method meth)
 2092   %{
 2093     // CALL Java_To_Interpreter
 2094     // This is the instruction starting address for relocation info.
 2095     cbuf.set_insts_mark();
 2096     $$$emit8$primary;
 2097     // CALL directly to the runtime
 2098     emit_d32_reloc(cbuf,
 2099                    (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2100                    runtime_call_Relocation::spec(),
 2101                    RELOC_DISP32);
 2102   %}
 2103 
 2104   enc_class Java_Static_Call(method meth)
 2105   %{
 2106     // JAVA STATIC CALL
 2107     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
 2108     // determine who we intended to call.
 2109     cbuf.set_insts_mark();
 2110     $$$emit8$primary;
 2111 
 2112     if (!_method) {
 2113       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2114                      runtime_call_Relocation::spec(),
 2115                      RELOC_DISP32);
 2116     } else {
 2117       int method_index = resolved_method_index(cbuf);
 2118       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2119                                                   : static_call_Relocation::spec(method_index);
 2120       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2121                      rspec, RELOC_DISP32);
 2122       // Emit stubs for static call.
 2123       address mark = cbuf.insts_mark();
 2124       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf, mark);
 2125       if (stub == NULL) {
 2126         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2127         return;
 2128       }
 2129 #if INCLUDE_AOT
 2130       CompiledStaticCall::emit_to_aot_stub(cbuf, mark);
 2131 #endif
 2132     }
 2133   %}
 2134 
 2135   enc_class Java_Dynamic_Call(method meth) %{
 2136     MacroAssembler _masm(&amp;cbuf);
 2137     __ ic_call((address)$meth$$method, resolved_method_index(cbuf));
 2138   %}
 2139 
 2140   enc_class Java_Compiled_Call(method meth)
 2141   %{
 2142     // JAVA COMPILED CALL
 2143     int disp = in_bytes(Method:: from_compiled_offset());
 2144 
 2145     // XXX XXX offset is 128 is 1.5 NON-PRODUCT !!!
 2146     // assert(-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80, &quot;compiled_code_offset isn&#39;t small&quot;);
 2147 
 2148     // callq *disp(%rax)
 2149     cbuf.set_insts_mark();
 2150     $$$emit8$primary;
 2151     if (disp &lt; 0x80) {
 2152       emit_rm(cbuf, 0x01, $secondary, RAX_enc); // R/M byte
 2153       emit_d8(cbuf, disp); // Displacement
 2154     } else {
 2155       emit_rm(cbuf, 0x02, $secondary, RAX_enc); // R/M byte
 2156       emit_d32(cbuf, disp); // Displacement
 2157     }
 2158   %}
 2159 
 2160   enc_class reg_opc_imm(rRegI dst, immI8 shift)
 2161   %{
 2162     // SAL, SAR, SHR
 2163     int dstenc = $dst$$reg;
 2164     if (dstenc &gt;= 8) {
 2165       emit_opcode(cbuf, Assembler::REX_B);
 2166       dstenc -= 8;
 2167     }
 2168     $$$emit8$primary;
 2169     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2170     $$$emit8$shift$$constant;
 2171   %}
 2172 
 2173   enc_class reg_opc_imm_wide(rRegL dst, immI8 shift)
 2174   %{
 2175     // SAL, SAR, SHR
 2176     int dstenc = $dst$$reg;
 2177     if (dstenc &lt; 8) {
 2178       emit_opcode(cbuf, Assembler::REX_W);
 2179     } else {
 2180       emit_opcode(cbuf, Assembler::REX_WB);
 2181       dstenc -= 8;
 2182     }
 2183     $$$emit8$primary;
 2184     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2185     $$$emit8$shift$$constant;
 2186   %}
 2187 
 2188   enc_class load_immI(rRegI dst, immI src)
 2189   %{
 2190     int dstenc = $dst$$reg;
 2191     if (dstenc &gt;= 8) {
 2192       emit_opcode(cbuf, Assembler::REX_B);
 2193       dstenc -= 8;
 2194     }
 2195     emit_opcode(cbuf, 0xB8 | dstenc);
 2196     $$$emit32$src$$constant;
 2197   %}
 2198 
 2199   enc_class load_immL(rRegL dst, immL src)
 2200   %{
 2201     int dstenc = $dst$$reg;
 2202     if (dstenc &lt; 8) {
 2203       emit_opcode(cbuf, Assembler::REX_W);
 2204     } else {
 2205       emit_opcode(cbuf, Assembler::REX_WB);
 2206       dstenc -= 8;
 2207     }
 2208     emit_opcode(cbuf, 0xB8 | dstenc);
 2209     emit_d64(cbuf, $src$$constant);
 2210   %}
 2211 
 2212   enc_class load_immUL32(rRegL dst, immUL32 src)
 2213   %{
 2214     // same as load_immI, but this time we care about zeroes in the high word
 2215     int dstenc = $dst$$reg;
 2216     if (dstenc &gt;= 8) {
 2217       emit_opcode(cbuf, Assembler::REX_B);
 2218       dstenc -= 8;
 2219     }
 2220     emit_opcode(cbuf, 0xB8 | dstenc);
 2221     $$$emit32$src$$constant;
 2222   %}
 2223 
 2224   enc_class load_immL32(rRegL dst, immL32 src)
 2225   %{
 2226     int dstenc = $dst$$reg;
 2227     if (dstenc &lt; 8) {
 2228       emit_opcode(cbuf, Assembler::REX_W);
 2229     } else {
 2230       emit_opcode(cbuf, Assembler::REX_WB);
 2231       dstenc -= 8;
 2232     }
 2233     emit_opcode(cbuf, 0xC7);
 2234     emit_rm(cbuf, 0x03, 0x00, dstenc);
 2235     $$$emit32$src$$constant;
 2236   %}
 2237 
 2238   enc_class load_immP31(rRegP dst, immP32 src)
 2239   %{
 2240     // same as load_immI, but this time we care about zeroes in the high word
 2241     int dstenc = $dst$$reg;
 2242     if (dstenc &gt;= 8) {
 2243       emit_opcode(cbuf, Assembler::REX_B);
 2244       dstenc -= 8;
 2245     }
 2246     emit_opcode(cbuf, 0xB8 | dstenc);
 2247     $$$emit32$src$$constant;
 2248   %}
 2249 
 2250   enc_class load_immP(rRegP dst, immP src)
 2251   %{
 2252     int dstenc = $dst$$reg;
 2253     if (dstenc &lt; 8) {
 2254       emit_opcode(cbuf, Assembler::REX_W);
 2255     } else {
 2256       emit_opcode(cbuf, Assembler::REX_WB);
 2257       dstenc -= 8;
 2258     }
 2259     emit_opcode(cbuf, 0xB8 | dstenc);
 2260     // This next line should be generated from ADLC
 2261     if ($src-&gt;constant_reloc() != relocInfo::none) {
 2262       emit_d64_reloc(cbuf, $src$$constant, $src-&gt;constant_reloc(), RELOC_IMM64);
 2263     } else {
 2264       emit_d64(cbuf, $src$$constant);
 2265     }
 2266   %}
 2267 
 2268   enc_class Con32(immI src)
 2269   %{
 2270     // Output immediate
 2271     $$$emit32$src$$constant;
 2272   %}
 2273 
 2274   enc_class Con32F_as_bits(immF src)
 2275   %{
 2276     // Output Float immediate bits
 2277     jfloat jf = $src$$constant;
 2278     jint jf_as_bits = jint_cast(jf);
 2279     emit_d32(cbuf, jf_as_bits);
 2280   %}
 2281 
 2282   enc_class Con16(immI src)
 2283   %{
 2284     // Output immediate
 2285     $$$emit16$src$$constant;
 2286   %}
 2287 
 2288   // How is this different from Con32??? XXX
 2289   enc_class Con_d32(immI src)
 2290   %{
 2291     emit_d32(cbuf,$src$$constant);
 2292   %}
 2293 
 2294   enc_class conmemref (rRegP t1) %{    // Con32(storeImmI)
 2295     // Output immediate memory reference
 2296     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
 2297     emit_d32(cbuf, 0x00);
 2298   %}
 2299 
 2300   enc_class lock_prefix()
 2301   %{
 2302     emit_opcode(cbuf, 0xF0); // lock
 2303   %}
 2304 
 2305   enc_class REX_mem(memory mem)
 2306   %{
 2307     if ($mem$$base &gt;= 8) {
 2308       if ($mem$$index &lt; 8) {
 2309         emit_opcode(cbuf, Assembler::REX_B);
 2310       } else {
 2311         emit_opcode(cbuf, Assembler::REX_XB);
 2312       }
 2313     } else {
 2314       if ($mem$$index &gt;= 8) {
 2315         emit_opcode(cbuf, Assembler::REX_X);
 2316       }
 2317     }
 2318   %}
 2319 
 2320   enc_class REX_mem_wide(memory mem)
 2321   %{
 2322     if ($mem$$base &gt;= 8) {
 2323       if ($mem$$index &lt; 8) {
 2324         emit_opcode(cbuf, Assembler::REX_WB);
 2325       } else {
 2326         emit_opcode(cbuf, Assembler::REX_WXB);
 2327       }
 2328     } else {
 2329       if ($mem$$index &lt; 8) {
 2330         emit_opcode(cbuf, Assembler::REX_W);
 2331       } else {
 2332         emit_opcode(cbuf, Assembler::REX_WX);
 2333       }
 2334     }
 2335   %}
 2336 
 2337   // for byte regs
 2338   enc_class REX_breg(rRegI reg)
 2339   %{
 2340     if ($reg$$reg &gt;= 4) {
 2341       emit_opcode(cbuf, $reg$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2342     }
 2343   %}
 2344 
 2345   // for byte regs
 2346   enc_class REX_reg_breg(rRegI dst, rRegI src)
 2347   %{
 2348     if ($dst$$reg &lt; 8) {
 2349       if ($src$$reg &gt;= 4) {
 2350         emit_opcode(cbuf, $src$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2351       }
 2352     } else {
 2353       if ($src$$reg &lt; 8) {
 2354         emit_opcode(cbuf, Assembler::REX_R);
 2355       } else {
 2356         emit_opcode(cbuf, Assembler::REX_RB);
 2357       }
 2358     }
 2359   %}
 2360 
 2361   // for byte regs
 2362   enc_class REX_breg_mem(rRegI reg, memory mem)
 2363   %{
 2364     if ($reg$$reg &lt; 8) {
 2365       if ($mem$$base &lt; 8) {
 2366         if ($mem$$index &gt;= 8) {
 2367           emit_opcode(cbuf, Assembler::REX_X);
 2368         } else if ($reg$$reg &gt;= 4) {
 2369           emit_opcode(cbuf, Assembler::REX);
 2370         }
 2371       } else {
 2372         if ($mem$$index &lt; 8) {
 2373           emit_opcode(cbuf, Assembler::REX_B);
 2374         } else {
 2375           emit_opcode(cbuf, Assembler::REX_XB);
 2376         }
 2377       }
 2378     } else {
 2379       if ($mem$$base &lt; 8) {
 2380         if ($mem$$index &lt; 8) {
 2381           emit_opcode(cbuf, Assembler::REX_R);
 2382         } else {
 2383           emit_opcode(cbuf, Assembler::REX_RX);
 2384         }
 2385       } else {
 2386         if ($mem$$index &lt; 8) {
 2387           emit_opcode(cbuf, Assembler::REX_RB);
 2388         } else {
 2389           emit_opcode(cbuf, Assembler::REX_RXB);
 2390         }
 2391       }
 2392     }
 2393   %}
 2394 
 2395   enc_class REX_reg(rRegI reg)
 2396   %{
 2397     if ($reg$$reg &gt;= 8) {
 2398       emit_opcode(cbuf, Assembler::REX_B);
 2399     }
 2400   %}
 2401 
 2402   enc_class REX_reg_wide(rRegI reg)
 2403   %{
 2404     if ($reg$$reg &lt; 8) {
 2405       emit_opcode(cbuf, Assembler::REX_W);
 2406     } else {
 2407       emit_opcode(cbuf, Assembler::REX_WB);
 2408     }
 2409   %}
 2410 
 2411   enc_class REX_reg_reg(rRegI dst, rRegI src)
 2412   %{
 2413     if ($dst$$reg &lt; 8) {
 2414       if ($src$$reg &gt;= 8) {
 2415         emit_opcode(cbuf, Assembler::REX_B);
 2416       }
 2417     } else {
 2418       if ($src$$reg &lt; 8) {
 2419         emit_opcode(cbuf, Assembler::REX_R);
 2420       } else {
 2421         emit_opcode(cbuf, Assembler::REX_RB);
 2422       }
 2423     }
 2424   %}
 2425 
 2426   enc_class REX_reg_reg_wide(rRegI dst, rRegI src)
 2427   %{
 2428     if ($dst$$reg &lt; 8) {
 2429       if ($src$$reg &lt; 8) {
 2430         emit_opcode(cbuf, Assembler::REX_W);
 2431       } else {
 2432         emit_opcode(cbuf, Assembler::REX_WB);
 2433       }
 2434     } else {
 2435       if ($src$$reg &lt; 8) {
 2436         emit_opcode(cbuf, Assembler::REX_WR);
 2437       } else {
 2438         emit_opcode(cbuf, Assembler::REX_WRB);
 2439       }
 2440     }
 2441   %}
 2442 
 2443   enc_class REX_reg_mem(rRegI reg, memory mem)
 2444   %{
 2445     if ($reg$$reg &lt; 8) {
 2446       if ($mem$$base &lt; 8) {
 2447         if ($mem$$index &gt;= 8) {
 2448           emit_opcode(cbuf, Assembler::REX_X);
 2449         }
 2450       } else {
 2451         if ($mem$$index &lt; 8) {
 2452           emit_opcode(cbuf, Assembler::REX_B);
 2453         } else {
 2454           emit_opcode(cbuf, Assembler::REX_XB);
 2455         }
 2456       }
 2457     } else {
 2458       if ($mem$$base &lt; 8) {
 2459         if ($mem$$index &lt; 8) {
 2460           emit_opcode(cbuf, Assembler::REX_R);
 2461         } else {
 2462           emit_opcode(cbuf, Assembler::REX_RX);
 2463         }
 2464       } else {
 2465         if ($mem$$index &lt; 8) {
 2466           emit_opcode(cbuf, Assembler::REX_RB);
 2467         } else {
 2468           emit_opcode(cbuf, Assembler::REX_RXB);
 2469         }
 2470       }
 2471     }
 2472   %}
 2473 
 2474   enc_class REX_reg_mem_wide(rRegL reg, memory mem)
 2475   %{
 2476     if ($reg$$reg &lt; 8) {
 2477       if ($mem$$base &lt; 8) {
 2478         if ($mem$$index &lt; 8) {
 2479           emit_opcode(cbuf, Assembler::REX_W);
 2480         } else {
 2481           emit_opcode(cbuf, Assembler::REX_WX);
 2482         }
 2483       } else {
 2484         if ($mem$$index &lt; 8) {
 2485           emit_opcode(cbuf, Assembler::REX_WB);
 2486         } else {
 2487           emit_opcode(cbuf, Assembler::REX_WXB);
 2488         }
 2489       }
 2490     } else {
 2491       if ($mem$$base &lt; 8) {
 2492         if ($mem$$index &lt; 8) {
 2493           emit_opcode(cbuf, Assembler::REX_WR);
 2494         } else {
 2495           emit_opcode(cbuf, Assembler::REX_WRX);
 2496         }
 2497       } else {
 2498         if ($mem$$index &lt; 8) {
 2499           emit_opcode(cbuf, Assembler::REX_WRB);
 2500         } else {
 2501           emit_opcode(cbuf, Assembler::REX_WRXB);
 2502         }
 2503       }
 2504     }
 2505   %}
 2506 
 2507   enc_class reg_mem(rRegI ereg, memory mem)
 2508   %{
 2509     // High registers handle in encode_RegMem
 2510     int reg = $ereg$$reg;
 2511     int base = $mem$$base;
 2512     int index = $mem$$index;
 2513     int scale = $mem$$scale;
 2514     int disp = $mem$$disp;
 2515     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
 2516 
 2517     encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
 2518   %}
 2519 
 2520   enc_class RM_opc_mem(immI rm_opcode, memory mem)
 2521   %{
 2522     int rm_byte_opcode = $rm_opcode$$constant;
 2523 
 2524     // High registers handle in encode_RegMem
 2525     int base = $mem$$base;
 2526     int index = $mem$$index;
 2527     int scale = $mem$$scale;
 2528     int displace = $mem$$disp;
 2529 
 2530     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();       // disp-as-oop when
 2531                                             // working with static
 2532                                             // globals
 2533     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
 2534                   disp_reloc);
 2535   %}
 2536 
 2537   enc_class reg_lea(rRegI dst, rRegI src0, immI src1)
 2538   %{
 2539     int reg_encoding = $dst$$reg;
 2540     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
 2541     int index        = 0x04;            // 0x04 indicates no index
 2542     int scale        = 0x00;            // 0x00 indicates no scale
 2543     int displace     = $src1$$constant; // 0x00 indicates no displacement
 2544     relocInfo::relocType disp_reloc = relocInfo::none;
 2545     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
 2546                   disp_reloc);
 2547   %}
 2548 
 2549   enc_class neg_reg(rRegI dst)
 2550   %{
 2551     int dstenc = $dst$$reg;
 2552     if (dstenc &gt;= 8) {
 2553       emit_opcode(cbuf, Assembler::REX_B);
 2554       dstenc -= 8;
 2555     }
 2556     // NEG $dst
 2557     emit_opcode(cbuf, 0xF7);
 2558     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2559   %}
 2560 
 2561   enc_class neg_reg_wide(rRegI dst)
 2562   %{
 2563     int dstenc = $dst$$reg;
 2564     if (dstenc &lt; 8) {
 2565       emit_opcode(cbuf, Assembler::REX_W);
 2566     } else {
 2567       emit_opcode(cbuf, Assembler::REX_WB);
 2568       dstenc -= 8;
 2569     }
 2570     // NEG $dst
 2571     emit_opcode(cbuf, 0xF7);
 2572     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2573   %}
 2574 
 2575   enc_class setLT_reg(rRegI dst)
 2576   %{
 2577     int dstenc = $dst$$reg;
 2578     if (dstenc &gt;= 8) {
 2579       emit_opcode(cbuf, Assembler::REX_B);
 2580       dstenc -= 8;
 2581     } else if (dstenc &gt;= 4) {
 2582       emit_opcode(cbuf, Assembler::REX);
 2583     }
 2584     // SETLT $dst
 2585     emit_opcode(cbuf, 0x0F);
 2586     emit_opcode(cbuf, 0x9C);
 2587     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2588   %}
 2589 
 2590   enc_class setNZ_reg(rRegI dst)
 2591   %{
 2592     int dstenc = $dst$$reg;
 2593     if (dstenc &gt;= 8) {
 2594       emit_opcode(cbuf, Assembler::REX_B);
 2595       dstenc -= 8;
 2596     } else if (dstenc &gt;= 4) {
 2597       emit_opcode(cbuf, Assembler::REX);
 2598     }
 2599     // SETNZ $dst
 2600     emit_opcode(cbuf, 0x0F);
 2601     emit_opcode(cbuf, 0x95);
 2602     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2603   %}
 2604 
 2605 
 2606   // Compare the lonogs and set -1, 0, or 1 into dst
 2607   enc_class cmpl3_flag(rRegL src1, rRegL src2, rRegI dst)
 2608   %{
 2609     int src1enc = $src1$$reg;
 2610     int src2enc = $src2$$reg;
 2611     int dstenc = $dst$$reg;
 2612 
 2613     // cmpq $src1, $src2
 2614     if (src1enc &lt; 8) {
 2615       if (src2enc &lt; 8) {
 2616         emit_opcode(cbuf, Assembler::REX_W);
 2617       } else {
 2618         emit_opcode(cbuf, Assembler::REX_WB);
 2619       }
 2620     } else {
 2621       if (src2enc &lt; 8) {
 2622         emit_opcode(cbuf, Assembler::REX_WR);
 2623       } else {
 2624         emit_opcode(cbuf, Assembler::REX_WRB);
 2625       }
 2626     }
 2627     emit_opcode(cbuf, 0x3B);
 2628     emit_rm(cbuf, 0x3, src1enc &amp; 7, src2enc &amp; 7);
 2629 
 2630     // movl $dst, -1
 2631     if (dstenc &gt;= 8) {
 2632       emit_opcode(cbuf, Assembler::REX_B);
 2633     }
 2634     emit_opcode(cbuf, 0xB8 | (dstenc &amp; 7));
 2635     emit_d32(cbuf, -1);
 2636 
 2637     // jl,s done
 2638     emit_opcode(cbuf, 0x7C);
 2639     emit_d8(cbuf, dstenc &lt; 4 ? 0x06 : 0x08);
 2640 
 2641     // setne $dst
 2642     if (dstenc &gt;= 4) {
 2643       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2644     }
 2645     emit_opcode(cbuf, 0x0F);
 2646     emit_opcode(cbuf, 0x95);
 2647     emit_opcode(cbuf, 0xC0 | (dstenc &amp; 7));
 2648 
 2649     // movzbl $dst, $dst
 2650     if (dstenc &gt;= 4) {
 2651       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_RB);
 2652     }
 2653     emit_opcode(cbuf, 0x0F);
 2654     emit_opcode(cbuf, 0xB6);
 2655     emit_rm(cbuf, 0x3, dstenc &amp; 7, dstenc &amp; 7);
 2656   %}
 2657 
 2658   enc_class Push_ResultXD(regD dst) %{
 2659     MacroAssembler _masm(&amp;cbuf);
 2660     __ fstp_d(Address(rsp, 0));
 2661     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
 2662     __ addptr(rsp, 8);
 2663   %}
 2664 
 2665   enc_class Push_SrcXD(regD src) %{
 2666     MacroAssembler _masm(&amp;cbuf);
 2667     __ subptr(rsp, 8);
 2668     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2669     __ fld_d(Address(rsp, 0));
 2670   %}
 2671 
 2672 
 2673   enc_class enc_rethrow()
 2674   %{
 2675     cbuf.set_insts_mark();
 2676     emit_opcode(cbuf, 0xE9); // jmp entry
 2677     emit_d32_reloc(cbuf,
 2678                    (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),
 2679                    runtime_call_Relocation::spec(),
 2680                    RELOC_DISP32);
 2681   %}
 2682 
 2683 %}
 2684 
 2685 
 2686 
 2687 //----------FRAME--------------------------------------------------------------
 2688 // Definition of frame structure and management information.
 2689 //
 2690 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2691 //                             |   (to get allocators register number
 2692 //  G  Owned by    |        |  v    add OptoReg::stack0())
 2693 //  r   CALLER     |        |
 2694 //  o     |        +--------+      pad to even-align allocators stack-slot
 2695 //  w     V        |  pad0  |        numbers; owned by CALLER
 2696 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2697 //  h     ^        |   in   |  5
 2698 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2699 //  |     |        |        |  3
 2700 //  |     |        +--------+
 2701 //  V     |        | old out|      Empty on Intel, window on Sparc
 2702 //        |    old |preserve|      Must be even aligned.
 2703 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
 2704 //        |        |   in   |  3   area for Intel ret address
 2705 //     Owned by    |preserve|      Empty on Sparc.
 2706 //       SELF      +--------+
 2707 //        |        |  pad2  |  2   pad to align old SP
 2708 //        |        +--------+  1
 2709 //        |        | locks  |  0
 2710 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
 2711 //        |        |  pad1  | 11   pad to align new SP
 2712 //        |        +--------+
 2713 //        |        |        | 10
 2714 //        |        | spills |  9   spills
 2715 //        V        |        |  8   (pad0 slot for callee)
 2716 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 2717 //        ^        |  out   |  7
 2718 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 2719 //     Owned by    +--------+
 2720 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 2721 //        |    new |preserve|      Must be even-aligned.
 2722 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 2723 //        |        |        |
 2724 //
 2725 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 2726 //         known from SELF&#39;s arguments and the Java calling convention.
 2727 //         Region 6-7 is determined per call site.
 2728 // Note 2: If the calling convention leaves holes in the incoming argument
 2729 //         area, those holes are owned by SELF.  Holes in the outgoing area
 2730 //         are owned by the CALLEE.  Holes should not be nessecary in the
 2731 //         incoming area, as the Java calling convention is completely under
 2732 //         the control of the AD file.  Doubles can be sorted and packed to
 2733 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
 2734 //         varargs C calling conventions.
 2735 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 2736 //         even aligned with pad0 as needed.
 2737 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 2738 //         region 6-11 is even aligned; it may be padded out more so that
 2739 //         the region from SP to FP meets the minimum stack alignment.
 2740 // Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
 2741 //         alignment.  Region 11, pad1, may be dynamically extended so that
 2742 //         SP meets the minimum alignment.
 2743 
 2744 frame
 2745 %{
 2746   // What direction does stack grow in (assumed to be same for C &amp; Java)
 2747   stack_direction(TOWARDS_LOW);
 2748 
 2749   // These three registers define part of the calling convention
 2750   // between compiled code and the interpreter.
 2751   inline_cache_reg(RAX);                // Inline Cache Register
 2752   interpreter_method_oop_reg(RBX);      // Method Oop Register when
 2753                                         // calling interpreter
 2754 
 2755   // Optional: name the operand used by cisc-spilling to access
 2756   // [stack_pointer + offset]
 2757   cisc_spilling_operand_name(indOffset32);
 2758 
 2759   // Number of stack slots consumed by locking an object
 2760   sync_stack_slots(2);
 2761 
 2762   // Compiled code&#39;s Frame Pointer
 2763   frame_pointer(RSP);
 2764 
 2765   // Interpreter stores its frame pointer in a register which is
 2766   // stored to the stack by I2CAdaptors.
 2767   // I2CAdaptors convert from interpreted java to compiled java.
 2768   interpreter_frame_pointer(RBP);
 2769 
 2770   // Stack alignment requirement
 2771   stack_alignment(StackAlignmentInBytes); // Alignment size in bytes (128-bit -&gt; 16 bytes)
 2772 
 2773   // Number of stack slots between incoming argument block and the start of
 2774   // a new frame.  The PROLOG must add this many slots to the stack.  The
 2775   // EPILOG must remove this many slots.  amd64 needs two slots for
 2776   // return address.
 2777   in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);
 2778 
 2779   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 2780   // for calls to C.  Supports the var-args backing area for register parms.
 2781   varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes/BytesPerInt);
 2782 
 2783   // The after-PROLOG location of the return address.  Location of
 2784   // return address specifies a type (REG or STACK) and a number
 2785   // representing the register number (i.e. - use a register name) or
 2786   // stack slot.
 2787   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
 2788   // Otherwise, it is above the locks and verification slot and alignment word
 2789   return_addr(STACK - 2 +
 2790               align_up((Compile::current()-&gt;in_preserve_stack_slots() +
 2791                         Compile::current()-&gt;fixed_slots()),
 2792                        stack_alignment_in_slots()));
 2793 
 2794   // Body of function which returns an integer array locating
 2795   // arguments either in registers or in stack slots.  Passed an array
 2796   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 2797   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2798   // arguments for a CALLEE.  Incoming stack arguments are
 2799   // automatically biased by the preserve_stack_slots field above.
 2800 
 2801   calling_convention
 2802   %{
 2803     // No difference between ingoing/outgoing just pass false
 2804     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 2805   %}
 2806 
 2807   c_calling_convention
 2808   %{
 2809     // This is obviously always outgoing
 2810     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 2811   %}
 2812 
 2813   // Location of compiled Java return values.  Same as C for now.
 2814   return_value
 2815   %{
 2816     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL,
 2817            &quot;only return normal values&quot;);
 2818 
 2819     static const int lo[Op_RegL + 1] = {
 2820       0,
 2821       0,
 2822       RAX_num,  // Op_RegN
 2823       RAX_num,  // Op_RegI
 2824       RAX_num,  // Op_RegP
 2825       XMM0_num, // Op_RegF
 2826       XMM0_num, // Op_RegD
 2827       RAX_num   // Op_RegL
 2828     };
 2829     static const int hi[Op_RegL + 1] = {
 2830       0,
 2831       0,
 2832       OptoReg::Bad, // Op_RegN
 2833       OptoReg::Bad, // Op_RegI
 2834       RAX_H_num,    // Op_RegP
 2835       OptoReg::Bad, // Op_RegF
 2836       XMM0b_num,    // Op_RegD
 2837       RAX_H_num     // Op_RegL
 2838     };
 2839     // Excluded flags and vector registers.
 2840     assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, &quot;missing type&quot;);
 2841     return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
 2842   %}
 2843 %}
 2844 
 2845 //----------ATTRIBUTES---------------------------------------------------------
 2846 //----------Operand Attributes-------------------------------------------------
 2847 op_attrib op_cost(0);        // Required cost attribute
 2848 
 2849 //----------Instruction Attributes---------------------------------------------
 2850 ins_attrib ins_cost(100);       // Required cost attribute
 2851 ins_attrib ins_size(8);         // Required size attribute (in bits)
 2852 ins_attrib ins_short_branch(0); // Required flag: is this instruction
 2853                                 // a non-matching short branch variant
 2854                                 // of some long branch?
 2855 ins_attrib ins_alignment(1);    // Required alignment attribute (must
 2856                                 // be a power of 2) specifies the
 2857                                 // alignment that some part of the
 2858                                 // instruction (not necessarily the
 2859                                 // start) requires.  If &gt; 1, a
 2860                                 // compute_padding() function must be
 2861                                 // provided for the instruction
 2862 
 2863 //----------OPERANDS-----------------------------------------------------------
 2864 // Operand definitions must precede instruction definitions for correct parsing
 2865 // in the ADLC because operands constitute user defined types which are used in
 2866 // instruction definitions.
 2867 
 2868 //----------Simple Operands----------------------------------------------------
 2869 // Immediate Operands
 2870 // Integer Immediate
 2871 operand immI()
 2872 %{
 2873   match(ConI);
 2874 
 2875   op_cost(10);
 2876   format %{ %}
 2877   interface(CONST_INTER);
 2878 %}
 2879 
 2880 // Constant for test vs zero
 2881 operand immI0()
 2882 %{
 2883   predicate(n-&gt;get_int() == 0);
 2884   match(ConI);
 2885 
 2886   op_cost(0);
 2887   format %{ %}
 2888   interface(CONST_INTER);
 2889 %}
 2890 
 2891 // Constant for increment
 2892 operand immI1()
 2893 %{
 2894   predicate(n-&gt;get_int() == 1);
 2895   match(ConI);
 2896 
 2897   op_cost(0);
 2898   format %{ %}
 2899   interface(CONST_INTER);
 2900 %}
 2901 
 2902 // Constant for decrement
 2903 operand immI_M1()
 2904 %{
 2905   predicate(n-&gt;get_int() == -1);
 2906   match(ConI);
 2907 
 2908   op_cost(0);
 2909   format %{ %}
 2910   interface(CONST_INTER);
 2911 %}
 2912 
 2913 // Valid scale values for addressing modes
 2914 operand immI2()
 2915 %{
 2916   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 2917   match(ConI);
 2918 
 2919   format %{ %}
 2920   interface(CONST_INTER);
 2921 %}
 2922 
 2923 operand immI8()
 2924 %{
 2925   predicate((-0x80 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 0x80));
 2926   match(ConI);
 2927 
 2928   op_cost(5);
 2929   format %{ %}
 2930   interface(CONST_INTER);
 2931 %}
 2932 
 2933 operand immU8()
 2934 %{
 2935   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 255));
 2936   match(ConI);
 2937 
 2938   op_cost(5);
 2939   format %{ %}
 2940   interface(CONST_INTER);
 2941 %}
 2942 
 2943 operand immI16()
 2944 %{
 2945   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 2946   match(ConI);
 2947 
 2948   op_cost(10);
 2949   format %{ %}
 2950   interface(CONST_INTER);
 2951 %}
 2952 
 2953 // Int Immediate non-negative
 2954 operand immU31()
 2955 %{
 2956   predicate(n-&gt;get_int() &gt;= 0);
 2957   match(ConI);
 2958 
 2959   op_cost(0);
 2960   format %{ %}
 2961   interface(CONST_INTER);
 2962 %}
 2963 
 2964 // Constant for long shifts
 2965 operand immI_32()
 2966 %{
 2967   predicate( n-&gt;get_int() == 32 );
 2968   match(ConI);
 2969 
 2970   op_cost(0);
 2971   format %{ %}
 2972   interface(CONST_INTER);
 2973 %}
 2974 
 2975 // Constant for long shifts
 2976 operand immI_64()
 2977 %{
 2978   predicate( n-&gt;get_int() == 64 );
 2979   match(ConI);
 2980 
 2981   op_cost(0);
 2982   format %{ %}
 2983   interface(CONST_INTER);
 2984 %}
 2985 
 2986 // Pointer Immediate
 2987 operand immP()
 2988 %{
 2989   match(ConP);
 2990 
 2991   op_cost(10);
 2992   format %{ %}
 2993   interface(CONST_INTER);
 2994 %}
 2995 
 2996 // NULL Pointer Immediate
 2997 operand immP0()
 2998 %{
 2999   predicate(n-&gt;get_ptr() == 0);
 3000   match(ConP);
 3001 
 3002   op_cost(5);
 3003   format %{ %}
 3004   interface(CONST_INTER);
 3005 %}
 3006 
 3007 // Pointer Immediate
 3008 operand immN() %{
 3009   match(ConN);
 3010 
 3011   op_cost(10);
 3012   format %{ %}
 3013   interface(CONST_INTER);
 3014 %}
 3015 
 3016 operand immNKlass() %{
 3017   match(ConNKlass);
 3018 
 3019   op_cost(10);
 3020   format %{ %}
 3021   interface(CONST_INTER);
 3022 %}
 3023 
 3024 // NULL Pointer Immediate
 3025 operand immN0() %{
 3026   predicate(n-&gt;get_narrowcon() == 0);
 3027   match(ConN);
 3028 
 3029   op_cost(5);
 3030   format %{ %}
 3031   interface(CONST_INTER);
 3032 %}
 3033 
 3034 operand immP31()
 3035 %{
 3036   predicate(n-&gt;as_Type()-&gt;type()-&gt;reloc() == relocInfo::none
 3037             &amp;&amp; (n-&gt;get_ptr() &gt;&gt; 31) == 0);
 3038   match(ConP);
 3039 
 3040   op_cost(5);
 3041   format %{ %}
 3042   interface(CONST_INTER);
 3043 %}
 3044 
 3045 
 3046 // Long Immediate
 3047 operand immL()
 3048 %{
 3049   match(ConL);
 3050 
 3051   op_cost(20);
 3052   format %{ %}
 3053   interface(CONST_INTER);
 3054 %}
 3055 
 3056 // Long Immediate 8-bit
 3057 operand immL8()
 3058 %{
 3059   predicate(-0x80L &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80L);
 3060   match(ConL);
 3061 
 3062   op_cost(5);
 3063   format %{ %}
 3064   interface(CONST_INTER);
 3065 %}
 3066 
 3067 // Long Immediate 32-bit unsigned
 3068 operand immUL32()
 3069 %{
 3070   predicate(n-&gt;get_long() == (unsigned int) (n-&gt;get_long()));
 3071   match(ConL);
 3072 
 3073   op_cost(10);
 3074   format %{ %}
 3075   interface(CONST_INTER);
 3076 %}
 3077 
 3078 // Long Immediate 32-bit signed
 3079 operand immL32()
 3080 %{
 3081   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
 3082   match(ConL);
 3083 
 3084   op_cost(15);
 3085   format %{ %}
 3086   interface(CONST_INTER);
 3087 %}
 3088 
 3089 operand immL_Pow2()
 3090 %{
 3091   predicate(is_power_of_2((julong)n-&gt;get_long()));
 3092   match(ConL);
 3093 
 3094   op_cost(15);
 3095   format %{ %}
 3096   interface(CONST_INTER);
 3097 %}
 3098 
 3099 operand immL_NotPow2()
 3100 %{
 3101   predicate(is_power_of_2((julong)~n-&gt;get_long()));
 3102   match(ConL);
 3103 
 3104   op_cost(15);
 3105   format %{ %}
 3106   interface(CONST_INTER);
 3107 %}
 3108 
 3109 // Long Immediate zero
 3110 operand immL0()
 3111 %{
 3112   predicate(n-&gt;get_long() == 0L);
 3113   match(ConL);
 3114 
 3115   op_cost(10);
 3116   format %{ %}
 3117   interface(CONST_INTER);
 3118 %}
 3119 
 3120 // Constant for increment
 3121 operand immL1()
 3122 %{
 3123   predicate(n-&gt;get_long() == 1);
 3124   match(ConL);
 3125 
 3126   format %{ %}
 3127   interface(CONST_INTER);
 3128 %}
 3129 
 3130 // Constant for decrement
 3131 operand immL_M1()
 3132 %{
 3133   predicate(n-&gt;get_long() == -1);
 3134   match(ConL);
 3135 
 3136   format %{ %}
 3137   interface(CONST_INTER);
 3138 %}
 3139 
 3140 // Long Immediate: the value 10
 3141 operand immL10()
 3142 %{
 3143   predicate(n-&gt;get_long() == 10);
 3144   match(ConL);
 3145 
 3146   format %{ %}
 3147   interface(CONST_INTER);
 3148 %}
 3149 
 3150 // Long immediate from 0 to 127.
 3151 // Used for a shorter form of long mul by 10.
 3152 operand immL_127()
 3153 %{
 3154   predicate(0 &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80);
 3155   match(ConL);
 3156 
 3157   op_cost(10);
 3158   format %{ %}
 3159   interface(CONST_INTER);
 3160 %}
 3161 
 3162 // Long Immediate: low 32-bit mask
 3163 operand immL_32bits()
 3164 %{
 3165   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3166   match(ConL);
 3167   op_cost(20);
 3168 
 3169   format %{ %}
 3170   interface(CONST_INTER);
 3171 %}
 3172 
 3173 // Float Immediate zero
 3174 operand immF0()
 3175 %{
 3176   predicate(jint_cast(n-&gt;getf()) == 0);
 3177   match(ConF);
 3178 
 3179   op_cost(5);
 3180   format %{ %}
 3181   interface(CONST_INTER);
 3182 %}
 3183 
 3184 // Float Immediate
 3185 operand immF()
 3186 %{
 3187   match(ConF);
 3188 
 3189   op_cost(15);
 3190   format %{ %}
 3191   interface(CONST_INTER);
 3192 %}
 3193 
 3194 // Double Immediate zero
 3195 operand immD0()
 3196 %{
 3197   predicate(jlong_cast(n-&gt;getd()) == 0);
 3198   match(ConD);
 3199 
 3200   op_cost(5);
 3201   format %{ %}
 3202   interface(CONST_INTER);
 3203 %}
 3204 
 3205 // Double Immediate
 3206 operand immD()
 3207 %{
 3208   match(ConD);
 3209 
 3210   op_cost(15);
 3211   format %{ %}
 3212   interface(CONST_INTER);
 3213 %}
 3214 
 3215 // Immediates for special shifts (sign extend)
 3216 
 3217 // Constants for increment
 3218 operand immI_16()
 3219 %{
 3220   predicate(n-&gt;get_int() == 16);
 3221   match(ConI);
 3222 
 3223   format %{ %}
 3224   interface(CONST_INTER);
 3225 %}
 3226 
 3227 operand immI_24()
 3228 %{
 3229   predicate(n-&gt;get_int() == 24);
 3230   match(ConI);
 3231 
 3232   format %{ %}
 3233   interface(CONST_INTER);
 3234 %}
 3235 
 3236 // Constant for byte-wide masking
 3237 operand immI_255()
 3238 %{
 3239   predicate(n-&gt;get_int() == 255);
 3240   match(ConI);
 3241 
 3242   format %{ %}
 3243   interface(CONST_INTER);
 3244 %}
 3245 
 3246 // Constant for short-wide masking
 3247 operand immI_65535()
 3248 %{
 3249   predicate(n-&gt;get_int() == 65535);
 3250   match(ConI);
 3251 
 3252   format %{ %}
 3253   interface(CONST_INTER);
 3254 %}
 3255 
 3256 // Constant for byte-wide masking
 3257 operand immL_255()
 3258 %{
 3259   predicate(n-&gt;get_long() == 255);
 3260   match(ConL);
 3261 
 3262   format %{ %}
 3263   interface(CONST_INTER);
 3264 %}
 3265 
 3266 // Constant for short-wide masking
 3267 operand immL_65535()
 3268 %{
 3269   predicate(n-&gt;get_long() == 65535);
 3270   match(ConL);
 3271 
 3272   format %{ %}
 3273   interface(CONST_INTER);
 3274 %}
 3275 
 3276 // Register Operands
 3277 // Integer Register
 3278 operand rRegI()
 3279 %{
 3280   constraint(ALLOC_IN_RC(int_reg));
 3281   match(RegI);
 3282 
 3283   match(rax_RegI);
 3284   match(rbx_RegI);
 3285   match(rcx_RegI);
 3286   match(rdx_RegI);
 3287   match(rdi_RegI);
 3288 
 3289   format %{ %}
 3290   interface(REG_INTER);
 3291 %}
 3292 
 3293 // Special Registers
 3294 operand rax_RegI()
 3295 %{
 3296   constraint(ALLOC_IN_RC(int_rax_reg));
 3297   match(RegI);
 3298   match(rRegI);
 3299 
 3300   format %{ &quot;RAX&quot; %}
 3301   interface(REG_INTER);
 3302 %}
 3303 
 3304 // Special Registers
 3305 operand rbx_RegI()
 3306 %{
 3307   constraint(ALLOC_IN_RC(int_rbx_reg));
 3308   match(RegI);
 3309   match(rRegI);
 3310 
 3311   format %{ &quot;RBX&quot; %}
 3312   interface(REG_INTER);
 3313 %}
 3314 
 3315 operand rcx_RegI()
 3316 %{
 3317   constraint(ALLOC_IN_RC(int_rcx_reg));
 3318   match(RegI);
 3319   match(rRegI);
 3320 
 3321   format %{ &quot;RCX&quot; %}
 3322   interface(REG_INTER);
 3323 %}
 3324 
 3325 operand rdx_RegI()
 3326 %{
 3327   constraint(ALLOC_IN_RC(int_rdx_reg));
 3328   match(RegI);
 3329   match(rRegI);
 3330 
 3331   format %{ &quot;RDX&quot; %}
 3332   interface(REG_INTER);
 3333 %}
 3334 
 3335 operand rdi_RegI()
 3336 %{
 3337   constraint(ALLOC_IN_RC(int_rdi_reg));
 3338   match(RegI);
 3339   match(rRegI);
 3340 
 3341   format %{ &quot;RDI&quot; %}
 3342   interface(REG_INTER);
 3343 %}
 3344 
 3345 operand no_rcx_RegI()
 3346 %{
 3347   constraint(ALLOC_IN_RC(int_no_rcx_reg));
 3348   match(RegI);
 3349   match(rax_RegI);
 3350   match(rbx_RegI);
 3351   match(rdx_RegI);
 3352   match(rdi_RegI);
 3353 
 3354   format %{ %}
 3355   interface(REG_INTER);
 3356 %}
 3357 
 3358 operand no_rax_rdx_RegI()
 3359 %{
 3360   constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));
 3361   match(RegI);
 3362   match(rbx_RegI);
 3363   match(rcx_RegI);
 3364   match(rdi_RegI);
 3365 
 3366   format %{ %}
 3367   interface(REG_INTER);
 3368 %}
 3369 
 3370 // Pointer Register
 3371 operand any_RegP()
 3372 %{
 3373   constraint(ALLOC_IN_RC(any_reg));
 3374   match(RegP);
 3375   match(rax_RegP);
 3376   match(rbx_RegP);
 3377   match(rdi_RegP);
 3378   match(rsi_RegP);
 3379   match(rbp_RegP);
 3380   match(r15_RegP);
 3381   match(rRegP);
 3382 
 3383   format %{ %}
 3384   interface(REG_INTER);
 3385 %}
 3386 
 3387 operand rRegP()
 3388 %{
 3389   constraint(ALLOC_IN_RC(ptr_reg));
 3390   match(RegP);
 3391   match(rax_RegP);
 3392   match(rbx_RegP);
 3393   match(rdi_RegP);
 3394   match(rsi_RegP);
 3395   match(rbp_RegP);  // See Q&amp;A below about
 3396   match(r15_RegP);  // r15_RegP and rbp_RegP.
 3397 
 3398   format %{ %}
 3399   interface(REG_INTER);
 3400 %}
 3401 
 3402 operand rRegN() %{
 3403   constraint(ALLOC_IN_RC(int_reg));
 3404   match(RegN);
 3405 
 3406   format %{ %}
 3407   interface(REG_INTER);
 3408 %}
 3409 
 3410 // Question: Why is r15_RegP (the read-only TLS register) a match for rRegP?
 3411 // Answer: Operand match rules govern the DFA as it processes instruction inputs.
 3412 // It&#39;s fine for an instruction input that expects rRegP to match a r15_RegP.
 3413 // The output of an instruction is controlled by the allocator, which respects
 3414 // register class masks, not match rules.  Unless an instruction mentions
 3415 // r15_RegP or any_RegP explicitly as its output, r15 will not be considered
 3416 // by the allocator as an input.
 3417 // The same logic applies to rbp_RegP being a match for rRegP: If PreserveFramePointer==true,
 3418 // the RBP is used as a proper frame pointer and is not included in ptr_reg. As a
 3419 // result, RBP is not included in the output of the instruction either.
 3420 
 3421 operand no_rax_RegP()
 3422 %{
 3423   constraint(ALLOC_IN_RC(ptr_no_rax_reg));
 3424   match(RegP);
 3425   match(rbx_RegP);
 3426   match(rsi_RegP);
 3427   match(rdi_RegP);
 3428 
 3429   format %{ %}
 3430   interface(REG_INTER);
 3431 %}
 3432 
 3433 // This operand is not allowed to use RBP even if
 3434 // RBP is not used to hold the frame pointer.
 3435 operand no_rbp_RegP()
 3436 %{
 3437   constraint(ALLOC_IN_RC(ptr_reg_no_rbp));
 3438   match(RegP);
 3439   match(rbx_RegP);
 3440   match(rsi_RegP);
 3441   match(rdi_RegP);
 3442 
 3443   format %{ %}
 3444   interface(REG_INTER);
 3445 %}
 3446 
 3447 operand no_rax_rbx_RegP()
 3448 %{
 3449   constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));
 3450   match(RegP);
 3451   match(rsi_RegP);
 3452   match(rdi_RegP);
 3453 
 3454   format %{ %}
 3455   interface(REG_INTER);
 3456 %}
 3457 
 3458 // Special Registers
 3459 // Return a pointer value
 3460 operand rax_RegP()
 3461 %{
 3462   constraint(ALLOC_IN_RC(ptr_rax_reg));
 3463   match(RegP);
 3464   match(rRegP);
 3465 
 3466   format %{ %}
 3467   interface(REG_INTER);
 3468 %}
 3469 
 3470 // Special Registers
 3471 // Return a compressed pointer value
 3472 operand rax_RegN()
 3473 %{
 3474   constraint(ALLOC_IN_RC(int_rax_reg));
 3475   match(RegN);
 3476   match(rRegN);
 3477 
 3478   format %{ %}
 3479   interface(REG_INTER);
 3480 %}
 3481 
 3482 // Used in AtomicAdd
 3483 operand rbx_RegP()
 3484 %{
 3485   constraint(ALLOC_IN_RC(ptr_rbx_reg));
 3486   match(RegP);
 3487   match(rRegP);
 3488 
 3489   format %{ %}
 3490   interface(REG_INTER);
 3491 %}
 3492 
 3493 operand rsi_RegP()
 3494 %{
 3495   constraint(ALLOC_IN_RC(ptr_rsi_reg));
 3496   match(RegP);
 3497   match(rRegP);
 3498 
 3499   format %{ %}
 3500   interface(REG_INTER);
 3501 %}
 3502 
 3503 operand rbp_RegP()
 3504 %{
 3505   constraint(ALLOC_IN_RC(ptr_rbp_reg));
 3506   match(RegP);
 3507   match(rRegP);
 3508 
 3509   format %{ %}
 3510   interface(REG_INTER);
 3511 %}
 3512 
 3513 // Used in rep stosq
 3514 operand rdi_RegP()
 3515 %{
 3516   constraint(ALLOC_IN_RC(ptr_rdi_reg));
 3517   match(RegP);
 3518   match(rRegP);
 3519 
 3520   format %{ %}
 3521   interface(REG_INTER);
 3522 %}
 3523 
 3524 operand r15_RegP()
 3525 %{
 3526   constraint(ALLOC_IN_RC(ptr_r15_reg));
 3527   match(RegP);
 3528   match(rRegP);
 3529 
 3530   format %{ %}
 3531   interface(REG_INTER);
 3532 %}
 3533 
 3534 operand rRegL()
 3535 %{
 3536   constraint(ALLOC_IN_RC(long_reg));
 3537   match(RegL);
 3538   match(rax_RegL);
 3539   match(rdx_RegL);
 3540 
 3541   format %{ %}
 3542   interface(REG_INTER);
 3543 %}
 3544 
 3545 // Special Registers
 3546 operand no_rax_rdx_RegL()
 3547 %{
 3548   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3549   match(RegL);
 3550   match(rRegL);
 3551 
 3552   format %{ %}
 3553   interface(REG_INTER);
 3554 %}
 3555 
 3556 operand no_rax_RegL()
 3557 %{
 3558   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3559   match(RegL);
 3560   match(rRegL);
 3561   match(rdx_RegL);
 3562 
 3563   format %{ %}
 3564   interface(REG_INTER);
 3565 %}
 3566 
 3567 operand no_rcx_RegL()
 3568 %{
 3569   constraint(ALLOC_IN_RC(long_no_rcx_reg));
 3570   match(RegL);
 3571   match(rRegL);
 3572 
 3573   format %{ %}
 3574   interface(REG_INTER);
 3575 %}
 3576 
 3577 operand rax_RegL()
 3578 %{
 3579   constraint(ALLOC_IN_RC(long_rax_reg));
 3580   match(RegL);
 3581   match(rRegL);
 3582 
 3583   format %{ &quot;RAX&quot; %}
 3584   interface(REG_INTER);
 3585 %}
 3586 
 3587 operand rcx_RegL()
 3588 %{
 3589   constraint(ALLOC_IN_RC(long_rcx_reg));
 3590   match(RegL);
 3591   match(rRegL);
 3592 
 3593   format %{ %}
 3594   interface(REG_INTER);
 3595 %}
 3596 
 3597 operand rdx_RegL()
 3598 %{
 3599   constraint(ALLOC_IN_RC(long_rdx_reg));
 3600   match(RegL);
 3601   match(rRegL);
 3602 
 3603   format %{ %}
 3604   interface(REG_INTER);
 3605 %}
 3606 
 3607 // Flags register, used as output of compare instructions
 3608 operand rFlagsReg()
 3609 %{
 3610   constraint(ALLOC_IN_RC(int_flags));
 3611   match(RegFlags);
 3612 
 3613   format %{ &quot;RFLAGS&quot; %}
 3614   interface(REG_INTER);
 3615 %}
 3616 
 3617 // Flags register, used as output of FLOATING POINT compare instructions
 3618 operand rFlagsRegU()
 3619 %{
 3620   constraint(ALLOC_IN_RC(int_flags));
 3621   match(RegFlags);
 3622 
 3623   format %{ &quot;RFLAGS_U&quot; %}
 3624   interface(REG_INTER);
 3625 %}
 3626 
 3627 operand rFlagsRegUCF() %{
 3628   constraint(ALLOC_IN_RC(int_flags));
 3629   match(RegFlags);
 3630   predicate(false);
 3631 
 3632   format %{ &quot;RFLAGS_U_CF&quot; %}
 3633   interface(REG_INTER);
 3634 %}
 3635 
 3636 // Float register operands
 3637 operand regF() %{
 3638    constraint(ALLOC_IN_RC(float_reg));
 3639    match(RegF);
 3640 
 3641    format %{ %}
 3642    interface(REG_INTER);
 3643 %}
 3644 
 3645 // Float register operands
 3646 operand legRegF() %{
 3647    constraint(ALLOC_IN_RC(float_reg_legacy));
 3648    match(RegF);
 3649 
 3650    format %{ %}
 3651    interface(REG_INTER);
 3652 %}
 3653 
 3654 // Float register operands
 3655 operand vlRegF() %{
 3656    constraint(ALLOC_IN_RC(float_reg_vl));
 3657    match(RegF);
 3658 
 3659    format %{ %}
 3660    interface(REG_INTER);
 3661 %}
 3662 
 3663 // Double register operands
 3664 operand regD() %{
 3665    constraint(ALLOC_IN_RC(double_reg));
 3666    match(RegD);
 3667 
 3668    format %{ %}
 3669    interface(REG_INTER);
 3670 %}
 3671 
 3672 // Double register operands
 3673 operand legRegD() %{
 3674    constraint(ALLOC_IN_RC(double_reg_legacy));
 3675    match(RegD);
 3676 
 3677    format %{ %}
 3678    interface(REG_INTER);
 3679 %}
 3680 
 3681 // Double register operands
 3682 operand vlRegD() %{
 3683    constraint(ALLOC_IN_RC(double_reg_vl));
 3684    match(RegD);
 3685 
 3686    format %{ %}
 3687    interface(REG_INTER);
 3688 %}
 3689 
 3690 //----------Memory Operands----------------------------------------------------
 3691 // Direct Memory Operand
 3692 // operand direct(immP addr)
 3693 // %{
 3694 //   match(addr);
 3695 
 3696 //   format %{ &quot;[$addr]&quot; %}
 3697 //   interface(MEMORY_INTER) %{
 3698 //     base(0xFFFFFFFF);
 3699 //     index(0x4);
 3700 //     scale(0x0);
 3701 //     disp($addr);
 3702 //   %}
 3703 // %}
 3704 
 3705 // Indirect Memory Operand
 3706 operand indirect(any_RegP reg)
 3707 %{
 3708   constraint(ALLOC_IN_RC(ptr_reg));
 3709   match(reg);
 3710 
 3711   format %{ &quot;[$reg]&quot; %}
 3712   interface(MEMORY_INTER) %{
 3713     base($reg);
 3714     index(0x4);
 3715     scale(0x0);
 3716     disp(0x0);
 3717   %}
 3718 %}
 3719 
 3720 // Indirect Memory Plus Short Offset Operand
 3721 operand indOffset8(any_RegP reg, immL8 off)
 3722 %{
 3723   constraint(ALLOC_IN_RC(ptr_reg));
 3724   match(AddP reg off);
 3725 
 3726   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3727   interface(MEMORY_INTER) %{
 3728     base($reg);
 3729     index(0x4);
 3730     scale(0x0);
 3731     disp($off);
 3732   %}
 3733 %}
 3734 
 3735 // Indirect Memory Plus Long Offset Operand
 3736 operand indOffset32(any_RegP reg, immL32 off)
 3737 %{
 3738   constraint(ALLOC_IN_RC(ptr_reg));
 3739   match(AddP reg off);
 3740 
 3741   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3742   interface(MEMORY_INTER) %{
 3743     base($reg);
 3744     index(0x4);
 3745     scale(0x0);
 3746     disp($off);
 3747   %}
 3748 %}
 3749 
 3750 // Indirect Memory Plus Index Register Plus Offset Operand
 3751 operand indIndexOffset(any_RegP reg, rRegL lreg, immL32 off)
 3752 %{
 3753   constraint(ALLOC_IN_RC(ptr_reg));
 3754   match(AddP (AddP reg lreg) off);
 3755 
 3756   op_cost(10);
 3757   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3758   interface(MEMORY_INTER) %{
 3759     base($reg);
 3760     index($lreg);
 3761     scale(0x0);
 3762     disp($off);
 3763   %}
 3764 %}
 3765 
 3766 // Indirect Memory Plus Index Register Plus Offset Operand
 3767 operand indIndex(any_RegP reg, rRegL lreg)
 3768 %{
 3769   constraint(ALLOC_IN_RC(ptr_reg));
 3770   match(AddP reg lreg);
 3771 
 3772   op_cost(10);
 3773   format %{&quot;[$reg + $lreg]&quot; %}
 3774   interface(MEMORY_INTER) %{
 3775     base($reg);
 3776     index($lreg);
 3777     scale(0x0);
 3778     disp(0x0);
 3779   %}
 3780 %}
 3781 
 3782 // Indirect Memory Times Scale Plus Index Register
 3783 operand indIndexScale(any_RegP reg, rRegL lreg, immI2 scale)
 3784 %{
 3785   constraint(ALLOC_IN_RC(ptr_reg));
 3786   match(AddP reg (LShiftL lreg scale));
 3787 
 3788   op_cost(10);
 3789   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3790   interface(MEMORY_INTER) %{
 3791     base($reg);
 3792     index($lreg);
 3793     scale($scale);
 3794     disp(0x0);
 3795   %}
 3796 %}
 3797 
 3798 operand indPosIndexScale(any_RegP reg, rRegI idx, immI2 scale)
 3799 %{
 3800   constraint(ALLOC_IN_RC(ptr_reg));
 3801   predicate(n-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3802   match(AddP reg (LShiftL (ConvI2L idx) scale));
 3803 
 3804   op_cost(10);
 3805   format %{&quot;[$reg + pos $idx &lt;&lt; $scale]&quot; %}
 3806   interface(MEMORY_INTER) %{
 3807     base($reg);
 3808     index($idx);
 3809     scale($scale);
 3810     disp(0x0);
 3811   %}
 3812 %}
 3813 
 3814 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3815 operand indIndexScaleOffset(any_RegP reg, immL32 off, rRegL lreg, immI2 scale)
 3816 %{
 3817   constraint(ALLOC_IN_RC(ptr_reg));
 3818   match(AddP (AddP reg (LShiftL lreg scale)) off);
 3819 
 3820   op_cost(10);
 3821   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3822   interface(MEMORY_INTER) %{
 3823     base($reg);
 3824     index($lreg);
 3825     scale($scale);
 3826     disp($off);
 3827   %}
 3828 %}
 3829 
 3830 // Indirect Memory Plus Positive Index Register Plus Offset Operand
 3831 operand indPosIndexOffset(any_RegP reg, immL32 off, rRegI idx)
 3832 %{
 3833   constraint(ALLOC_IN_RC(ptr_reg));
 3834   predicate(n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3835   match(AddP (AddP reg (ConvI2L idx)) off);
 3836 
 3837   op_cost(10);
 3838   format %{&quot;[$reg + $off + $idx]&quot; %}
 3839   interface(MEMORY_INTER) %{
 3840     base($reg);
 3841     index($idx);
 3842     scale(0x0);
 3843     disp($off);
 3844   %}
 3845 %}
 3846 
 3847 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3848 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3849 %{
 3850   constraint(ALLOC_IN_RC(ptr_reg));
 3851   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3852   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3853 
 3854   op_cost(10);
 3855   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3856   interface(MEMORY_INTER) %{
 3857     base($reg);
 3858     index($idx);
 3859     scale($scale);
 3860     disp($off);
 3861   %}
 3862 %}
 3863 
<a name="8" id="anc8"></a>















 3864 // Indirect Narrow Oop Plus Offset Operand
 3865 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
 3866 // we can&#39;t free r12 even with CompressedOops::base() == NULL.
 3867 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
 3868   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3869   constraint(ALLOC_IN_RC(ptr_reg));
 3870   match(AddP (DecodeN reg) off);
 3871 
 3872   op_cost(10);
 3873   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3874   interface(MEMORY_INTER) %{
 3875     base(0xc); // R12
 3876     index($reg);
 3877     scale(0x3);
 3878     disp($off);
 3879   %}
 3880 %}
 3881 
 3882 // Indirect Memory Operand
 3883 operand indirectNarrow(rRegN reg)
 3884 %{
 3885   predicate(CompressedOops::shift() == 0);
 3886   constraint(ALLOC_IN_RC(ptr_reg));
 3887   match(DecodeN reg);
 3888 
 3889   format %{ &quot;[$reg]&quot; %}
 3890   interface(MEMORY_INTER) %{
 3891     base($reg);
 3892     index(0x4);
 3893     scale(0x0);
 3894     disp(0x0);
 3895   %}
 3896 %}
 3897 
 3898 // Indirect Memory Plus Short Offset Operand
 3899 operand indOffset8Narrow(rRegN reg, immL8 off)
 3900 %{
 3901   predicate(CompressedOops::shift() == 0);
 3902   constraint(ALLOC_IN_RC(ptr_reg));
 3903   match(AddP (DecodeN reg) off);
 3904 
 3905   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3906   interface(MEMORY_INTER) %{
 3907     base($reg);
 3908     index(0x4);
 3909     scale(0x0);
 3910     disp($off);
 3911   %}
 3912 %}
 3913 
 3914 // Indirect Memory Plus Long Offset Operand
 3915 operand indOffset32Narrow(rRegN reg, immL32 off)
 3916 %{
 3917   predicate(CompressedOops::shift() == 0);
 3918   constraint(ALLOC_IN_RC(ptr_reg));
 3919   match(AddP (DecodeN reg) off);
 3920 
 3921   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3922   interface(MEMORY_INTER) %{
 3923     base($reg);
 3924     index(0x4);
 3925     scale(0x0);
 3926     disp($off);
 3927   %}
 3928 %}
 3929 
 3930 // Indirect Memory Plus Index Register Plus Offset Operand
 3931 operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
 3932 %{
 3933   predicate(CompressedOops::shift() == 0);
 3934   constraint(ALLOC_IN_RC(ptr_reg));
 3935   match(AddP (AddP (DecodeN reg) lreg) off);
 3936 
 3937   op_cost(10);
 3938   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3939   interface(MEMORY_INTER) %{
 3940     base($reg);
 3941     index($lreg);
 3942     scale(0x0);
 3943     disp($off);
 3944   %}
 3945 %}
 3946 
 3947 // Indirect Memory Plus Index Register Plus Offset Operand
 3948 operand indIndexNarrow(rRegN reg, rRegL lreg)
 3949 %{
 3950   predicate(CompressedOops::shift() == 0);
 3951   constraint(ALLOC_IN_RC(ptr_reg));
 3952   match(AddP (DecodeN reg) lreg);
 3953 
 3954   op_cost(10);
 3955   format %{&quot;[$reg + $lreg]&quot; %}
 3956   interface(MEMORY_INTER) %{
 3957     base($reg);
 3958     index($lreg);
 3959     scale(0x0);
 3960     disp(0x0);
 3961   %}
 3962 %}
 3963 
 3964 // Indirect Memory Times Scale Plus Index Register
 3965 operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
 3966 %{
 3967   predicate(CompressedOops::shift() == 0);
 3968   constraint(ALLOC_IN_RC(ptr_reg));
 3969   match(AddP (DecodeN reg) (LShiftL lreg scale));
 3970 
 3971   op_cost(10);
 3972   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3973   interface(MEMORY_INTER) %{
 3974     base($reg);
 3975     index($lreg);
 3976     scale($scale);
 3977     disp(0x0);
 3978   %}
 3979 %}
 3980 
 3981 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3982 operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
 3983 %{
 3984   predicate(CompressedOops::shift() == 0);
 3985   constraint(ALLOC_IN_RC(ptr_reg));
 3986   match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
 3987 
 3988   op_cost(10);
 3989   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3990   interface(MEMORY_INTER) %{
 3991     base($reg);
 3992     index($lreg);
 3993     scale($scale);
 3994     disp($off);
 3995   %}
 3996 %}
 3997 
 3998 // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
 3999 operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
 4000 %{
 4001   constraint(ALLOC_IN_RC(ptr_reg));
 4002   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4003   match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
 4004 
 4005   op_cost(10);
 4006   format %{&quot;[$reg + $off + $idx]&quot; %}
 4007   interface(MEMORY_INTER) %{
 4008     base($reg);
 4009     index($idx);
 4010     scale(0x0);
 4011     disp($off);
 4012   %}
 4013 %}
 4014 
 4015 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 4016 operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
 4017 %{
 4018   constraint(ALLOC_IN_RC(ptr_reg));
 4019   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4020   match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
 4021 
 4022   op_cost(10);
 4023   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 4024   interface(MEMORY_INTER) %{
 4025     base($reg);
 4026     index($idx);
 4027     scale($scale);
 4028     disp($off);
 4029   %}
 4030 %}
 4031 
 4032 //----------Special Memory Operands--------------------------------------------
 4033 // Stack Slot Operand - This operand is used for loading and storing temporary
 4034 //                      values on the stack where a match requires a value to
 4035 //                      flow through memory.
 4036 operand stackSlotP(sRegP reg)
 4037 %{
 4038   constraint(ALLOC_IN_RC(stack_slots));
 4039   // No match rule because this operand is only generated in matching
 4040 
 4041   format %{ &quot;[$reg]&quot; %}
 4042   interface(MEMORY_INTER) %{
 4043     base(0x4);   // RSP
 4044     index(0x4);  // No Index
 4045     scale(0x0);  // No Scale
 4046     disp($reg);  // Stack Offset
 4047   %}
 4048 %}
 4049 
 4050 operand stackSlotI(sRegI reg)
 4051 %{
 4052   constraint(ALLOC_IN_RC(stack_slots));
 4053   // No match rule because this operand is only generated in matching
 4054 
 4055   format %{ &quot;[$reg]&quot; %}
 4056   interface(MEMORY_INTER) %{
 4057     base(0x4);   // RSP
 4058     index(0x4);  // No Index
 4059     scale(0x0);  // No Scale
 4060     disp($reg);  // Stack Offset
 4061   %}
 4062 %}
 4063 
 4064 operand stackSlotF(sRegF reg)
 4065 %{
 4066   constraint(ALLOC_IN_RC(stack_slots));
 4067   // No match rule because this operand is only generated in matching
 4068 
 4069   format %{ &quot;[$reg]&quot; %}
 4070   interface(MEMORY_INTER) %{
 4071     base(0x4);   // RSP
 4072     index(0x4);  // No Index
 4073     scale(0x0);  // No Scale
 4074     disp($reg);  // Stack Offset
 4075   %}
 4076 %}
 4077 
 4078 operand stackSlotD(sRegD reg)
 4079 %{
 4080   constraint(ALLOC_IN_RC(stack_slots));
 4081   // No match rule because this operand is only generated in matching
 4082 
 4083   format %{ &quot;[$reg]&quot; %}
 4084   interface(MEMORY_INTER) %{
 4085     base(0x4);   // RSP
 4086     index(0x4);  // No Index
 4087     scale(0x0);  // No Scale
 4088     disp($reg);  // Stack Offset
 4089   %}
 4090 %}
 4091 operand stackSlotL(sRegL reg)
 4092 %{
 4093   constraint(ALLOC_IN_RC(stack_slots));
 4094   // No match rule because this operand is only generated in matching
 4095 
 4096   format %{ &quot;[$reg]&quot; %}
 4097   interface(MEMORY_INTER) %{
 4098     base(0x4);   // RSP
 4099     index(0x4);  // No Index
 4100     scale(0x0);  // No Scale
 4101     disp($reg);  // Stack Offset
 4102   %}
 4103 %}
 4104 
 4105 //----------Conditional Branch Operands----------------------------------------
 4106 // Comparison Op  - This is the operation of the comparison, and is limited to
 4107 //                  the following set of codes:
 4108 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4109 //
 4110 // Other attributes of the comparison, such as unsignedness, are specified
 4111 // by the comparison instruction that sets a condition code flags register.
 4112 // That result is represented by a flags operand whose subtype is appropriate
 4113 // to the unsignedness (etc.) of the comparison.
 4114 //
 4115 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4116 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4117 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4118 
 4119 // Comparision Code
 4120 operand cmpOp()
 4121 %{
 4122   match(Bool);
 4123 
 4124   format %{ &quot;&quot; %}
 4125   interface(COND_INTER) %{
 4126     equal(0x4, &quot;e&quot;);
 4127     not_equal(0x5, &quot;ne&quot;);
 4128     less(0xC, &quot;l&quot;);
 4129     greater_equal(0xD, &quot;ge&quot;);
 4130     less_equal(0xE, &quot;le&quot;);
 4131     greater(0xF, &quot;g&quot;);
 4132     overflow(0x0, &quot;o&quot;);
 4133     no_overflow(0x1, &quot;no&quot;);
 4134   %}
 4135 %}
 4136 
 4137 // Comparison Code, unsigned compare.  Used by FP also, with
 4138 // C2 (unordered) turned into GT or LT already.  The other bits
 4139 // C0 and C3 are turned into Carry &amp; Zero flags.
 4140 operand cmpOpU()
 4141 %{
 4142   match(Bool);
 4143 
 4144   format %{ &quot;&quot; %}
 4145   interface(COND_INTER) %{
 4146     equal(0x4, &quot;e&quot;);
 4147     not_equal(0x5, &quot;ne&quot;);
 4148     less(0x2, &quot;b&quot;);
 4149     greater_equal(0x3, &quot;nb&quot;);
 4150     less_equal(0x6, &quot;be&quot;);
 4151     greater(0x7, &quot;nbe&quot;);
 4152     overflow(0x0, &quot;o&quot;);
 4153     no_overflow(0x1, &quot;no&quot;);
 4154   %}
 4155 %}
 4156 
 4157 
 4158 // Floating comparisons that don&#39;t require any fixup for the unordered case
 4159 operand cmpOpUCF() %{
 4160   match(Bool);
 4161   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4162             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
 4163             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
 4164             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
 4165   format %{ &quot;&quot; %}
 4166   interface(COND_INTER) %{
 4167     equal(0x4, &quot;e&quot;);
 4168     not_equal(0x5, &quot;ne&quot;);
 4169     less(0x2, &quot;b&quot;);
 4170     greater_equal(0x3, &quot;nb&quot;);
 4171     less_equal(0x6, &quot;be&quot;);
 4172     greater(0x7, &quot;nbe&quot;);
 4173     overflow(0x0, &quot;o&quot;);
 4174     no_overflow(0x1, &quot;no&quot;);
 4175   %}
 4176 %}
 4177 
 4178 
 4179 // Floating comparisons that can be fixed up with extra conditional jumps
 4180 operand cmpOpUCF2() %{
 4181   match(Bool);
 4182   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4183             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4184   format %{ &quot;&quot; %}
 4185   interface(COND_INTER) %{
 4186     equal(0x4, &quot;e&quot;);
 4187     not_equal(0x5, &quot;ne&quot;);
 4188     less(0x2, &quot;b&quot;);
 4189     greater_equal(0x3, &quot;nb&quot;);
 4190     less_equal(0x6, &quot;be&quot;);
 4191     greater(0x7, &quot;nbe&quot;);
 4192     overflow(0x0, &quot;o&quot;);
 4193     no_overflow(0x1, &quot;no&quot;);
 4194   %}
 4195 %}
 4196 
 4197 //----------OPERAND CLASSES----------------------------------------------------
 4198 // Operand Classes are groups of operands that are used as to simplify
 4199 // instruction definitions by not requiring the AD writer to specify separate
 4200 // instructions for every form of operand when the instruction accepts
 4201 // multiple operand types with the same basic encoding and format.  The classic
 4202 // case of this is memory operands.
 4203 
 4204 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4205                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
<a name="9" id="anc9"></a><span class="line-modified"> 4206                indCompressedOopOffset,</span>
 4207                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4208                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4209                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4210 
 4211 //----------PIPELINE-----------------------------------------------------------
 4212 // Rules which define the behavior of the target architectures pipeline.
 4213 pipeline %{
 4214 
 4215 //----------ATTRIBUTES---------------------------------------------------------
 4216 attributes %{
 4217   variable_size_instructions;        // Fixed size instructions
 4218   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4219   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4220   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4221   instruction_fetch_units = 1;       // of 16 bytes
 4222 
 4223   // List of nop instructions
 4224   nops( MachNop );
 4225 %}
 4226 
 4227 //----------RESOURCES----------------------------------------------------------
 4228 // Resources are the functional units available to the machine
 4229 
 4230 // Generic P2/P3 pipeline
 4231 // 3 decoders, only D0 handles big operands; a &quot;bundle&quot; is the limit of
 4232 // 3 instructions decoded per cycle.
 4233 // 2 load/store ops per cycle, 1 branch, 1 FPU,
 4234 // 3 ALU op, only ALU0 handles mul instructions.
 4235 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
 4236            MS0, MS1, MS2, MEM = MS0 | MS1 | MS2,
 4237            BR, FPU,
 4238            ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);
 4239 
 4240 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4241 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4242 
 4243 // Generic P2/P3 pipeline
 4244 pipe_desc(S0, S1, S2, S3, S4, S5);
 4245 
 4246 //----------PIPELINE CLASSES---------------------------------------------------
 4247 // Pipeline Classes describe the stages in which input and output are
 4248 // referenced by the hardware pipeline.
 4249 
 4250 // Naming convention: ialu or fpu
 4251 // Then: _reg
 4252 // Then: _reg if there is a 2nd register
 4253 // Then: _long if it&#39;s a pair of instructions implementing a long
 4254 // Then: _fat if it requires the big decoder
 4255 //   Or: _mem if it requires the big decoder and a memory unit.
 4256 
 4257 // Integer ALU reg operation
 4258 pipe_class ialu_reg(rRegI dst)
 4259 %{
 4260     single_instruction;
 4261     dst    : S4(write);
 4262     dst    : S3(read);
 4263     DECODE : S0;        // any decoder
 4264     ALU    : S3;        // any alu
 4265 %}
 4266 
 4267 // Long ALU reg operation
 4268 pipe_class ialu_reg_long(rRegL dst)
 4269 %{
 4270     instruction_count(2);
 4271     dst    : S4(write);
 4272     dst    : S3(read);
 4273     DECODE : S0(2);     // any 2 decoders
 4274     ALU    : S3(2);     // both alus
 4275 %}
 4276 
 4277 // Integer ALU reg operation using big decoder
 4278 pipe_class ialu_reg_fat(rRegI dst)
 4279 %{
 4280     single_instruction;
 4281     dst    : S4(write);
 4282     dst    : S3(read);
 4283     D0     : S0;        // big decoder only
 4284     ALU    : S3;        // any alu
 4285 %}
 4286 
 4287 // Long ALU reg operation using big decoder
 4288 pipe_class ialu_reg_long_fat(rRegL dst)
 4289 %{
 4290     instruction_count(2);
 4291     dst    : S4(write);
 4292     dst    : S3(read);
 4293     D0     : S0(2);     // big decoder only; twice
 4294     ALU    : S3(2);     // any 2 alus
 4295 %}
 4296 
 4297 // Integer ALU reg-reg operation
 4298 pipe_class ialu_reg_reg(rRegI dst, rRegI src)
 4299 %{
 4300     single_instruction;
 4301     dst    : S4(write);
 4302     src    : S3(read);
 4303     DECODE : S0;        // any decoder
 4304     ALU    : S3;        // any alu
 4305 %}
 4306 
 4307 // Long ALU reg-reg operation
 4308 pipe_class ialu_reg_reg_long(rRegL dst, rRegL src)
 4309 %{
 4310     instruction_count(2);
 4311     dst    : S4(write);
 4312     src    : S3(read);
 4313     DECODE : S0(2);     // any 2 decoders
 4314     ALU    : S3(2);     // both alus
 4315 %}
 4316 
 4317 // Integer ALU reg-reg operation
 4318 pipe_class ialu_reg_reg_fat(rRegI dst, memory src)
 4319 %{
 4320     single_instruction;
 4321     dst    : S4(write);
 4322     src    : S3(read);
 4323     D0     : S0;        // big decoder only
 4324     ALU    : S3;        // any alu
 4325 %}
 4326 
 4327 // Long ALU reg-reg operation
 4328 pipe_class ialu_reg_reg_long_fat(rRegL dst, rRegL src)
 4329 %{
 4330     instruction_count(2);
 4331     dst    : S4(write);
 4332     src    : S3(read);
 4333     D0     : S0(2);     // big decoder only; twice
 4334     ALU    : S3(2);     // both alus
 4335 %}
 4336 
 4337 // Integer ALU reg-mem operation
 4338 pipe_class ialu_reg_mem(rRegI dst, memory mem)
 4339 %{
 4340     single_instruction;
 4341     dst    : S5(write);
 4342     mem    : S3(read);
 4343     D0     : S0;        // big decoder only
 4344     ALU    : S4;        // any alu
 4345     MEM    : S3;        // any mem
 4346 %}
 4347 
 4348 // Integer mem operation (prefetch)
 4349 pipe_class ialu_mem(memory mem)
 4350 %{
 4351     single_instruction;
 4352     mem    : S3(read);
 4353     D0     : S0;        // big decoder only
 4354     MEM    : S3;        // any mem
 4355 %}
 4356 
 4357 // Integer Store to Memory
 4358 pipe_class ialu_mem_reg(memory mem, rRegI src)
 4359 %{
 4360     single_instruction;
 4361     mem    : S3(read);
 4362     src    : S5(read);
 4363     D0     : S0;        // big decoder only
 4364     ALU    : S4;        // any alu
 4365     MEM    : S3;
 4366 %}
 4367 
 4368 // // Long Store to Memory
 4369 // pipe_class ialu_mem_long_reg(memory mem, rRegL src)
 4370 // %{
 4371 //     instruction_count(2);
 4372 //     mem    : S3(read);
 4373 //     src    : S5(read);
 4374 //     D0     : S0(2);          // big decoder only; twice
 4375 //     ALU    : S4(2);     // any 2 alus
 4376 //     MEM    : S3(2);  // Both mems
 4377 // %}
 4378 
 4379 // Integer Store to Memory
 4380 pipe_class ialu_mem_imm(memory mem)
 4381 %{
 4382     single_instruction;
 4383     mem    : S3(read);
 4384     D0     : S0;        // big decoder only
 4385     ALU    : S4;        // any alu
 4386     MEM    : S3;
 4387 %}
 4388 
 4389 // Integer ALU0 reg-reg operation
 4390 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)
 4391 %{
 4392     single_instruction;
 4393     dst    : S4(write);
 4394     src    : S3(read);
 4395     D0     : S0;        // Big decoder only
 4396     ALU0   : S3;        // only alu0
 4397 %}
 4398 
 4399 // Integer ALU0 reg-mem operation
 4400 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)
 4401 %{
 4402     single_instruction;
 4403     dst    : S5(write);
 4404     mem    : S3(read);
 4405     D0     : S0;        // big decoder only
 4406     ALU0   : S4;        // ALU0 only
 4407     MEM    : S3;        // any mem
 4408 %}
 4409 
 4410 // Integer ALU reg-reg operation
 4411 pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)
 4412 %{
 4413     single_instruction;
 4414     cr     : S4(write);
 4415     src1   : S3(read);
 4416     src2   : S3(read);
 4417     DECODE : S0;        // any decoder
 4418     ALU    : S3;        // any alu
 4419 %}
 4420 
 4421 // Integer ALU reg-imm operation
 4422 pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)
 4423 %{
 4424     single_instruction;
 4425     cr     : S4(write);
 4426     src1   : S3(read);
 4427     DECODE : S0;        // any decoder
 4428     ALU    : S3;        // any alu
 4429 %}
 4430 
 4431 // Integer ALU reg-mem operation
 4432 pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)
 4433 %{
 4434     single_instruction;
 4435     cr     : S4(write);
 4436     src1   : S3(read);
 4437     src2   : S3(read);
 4438     D0     : S0;        // big decoder only
 4439     ALU    : S4;        // any alu
 4440     MEM    : S3;
 4441 %}
 4442 
 4443 // Conditional move reg-reg
 4444 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)
 4445 %{
 4446     instruction_count(4);
 4447     y      : S4(read);
 4448     q      : S3(read);
 4449     p      : S3(read);
 4450     DECODE : S0(4);     // any decoder
 4451 %}
 4452 
 4453 // Conditional move reg-reg
 4454 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)
 4455 %{
 4456     single_instruction;
 4457     dst    : S4(write);
 4458     src    : S3(read);
 4459     cr     : S3(read);
 4460     DECODE : S0;        // any decoder
 4461 %}
 4462 
 4463 // Conditional move reg-mem
 4464 pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)
 4465 %{
 4466     single_instruction;
 4467     dst    : S4(write);
 4468     src    : S3(read);
 4469     cr     : S3(read);
 4470     DECODE : S0;        // any decoder
 4471     MEM    : S3;
 4472 %}
 4473 
 4474 // Conditional move reg-reg long
 4475 pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)
 4476 %{
 4477     single_instruction;
 4478     dst    : S4(write);
 4479     src    : S3(read);
 4480     cr     : S3(read);
 4481     DECODE : S0(2);     // any 2 decoders
 4482 %}
 4483 
 4484 // XXX
 4485 // // Conditional move double reg-reg
 4486 // pipe_class pipe_cmovD_reg( rFlagsReg cr, regDPR1 dst, regD src)
 4487 // %{
 4488 //     single_instruction;
 4489 //     dst    : S4(write);
 4490 //     src    : S3(read);
 4491 //     cr     : S3(read);
 4492 //     DECODE : S0;     // any decoder
 4493 // %}
 4494 
 4495 // Float reg-reg operation
 4496 pipe_class fpu_reg(regD dst)
 4497 %{
 4498     instruction_count(2);
 4499     dst    : S3(read);
 4500     DECODE : S0(2);     // any 2 decoders
 4501     FPU    : S3;
 4502 %}
 4503 
 4504 // Float reg-reg operation
 4505 pipe_class fpu_reg_reg(regD dst, regD src)
 4506 %{
 4507     instruction_count(2);
 4508     dst    : S4(write);
 4509     src    : S3(read);
 4510     DECODE : S0(2);     // any 2 decoders
 4511     FPU    : S3;
 4512 %}
 4513 
 4514 // Float reg-reg operation
 4515 pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)
 4516 %{
 4517     instruction_count(3);
 4518     dst    : S4(write);
 4519     src1   : S3(read);
 4520     src2   : S3(read);
 4521     DECODE : S0(3);     // any 3 decoders
 4522     FPU    : S3(2);
 4523 %}
 4524 
 4525 // Float reg-reg operation
 4526 pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)
 4527 %{
 4528     instruction_count(4);
 4529     dst    : S4(write);
 4530     src1   : S3(read);
 4531     src2   : S3(read);
 4532     src3   : S3(read);
 4533     DECODE : S0(4);     // any 3 decoders
 4534     FPU    : S3(2);
 4535 %}
 4536 
 4537 // Float reg-reg operation
 4538 pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)
 4539 %{
 4540     instruction_count(4);
 4541     dst    : S4(write);
 4542     src1   : S3(read);
 4543     src2   : S3(read);
 4544     src3   : S3(read);
 4545     DECODE : S1(3);     // any 3 decoders
 4546     D0     : S0;        // Big decoder only
 4547     FPU    : S3(2);
 4548     MEM    : S3;
 4549 %}
 4550 
 4551 // Float reg-mem operation
 4552 pipe_class fpu_reg_mem(regD dst, memory mem)
 4553 %{
 4554     instruction_count(2);
 4555     dst    : S5(write);
 4556     mem    : S3(read);
 4557     D0     : S0;        // big decoder only
 4558     DECODE : S1;        // any decoder for FPU POP
 4559     FPU    : S4;
 4560     MEM    : S3;        // any mem
 4561 %}
 4562 
 4563 // Float reg-mem operation
 4564 pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)
 4565 %{
 4566     instruction_count(3);
 4567     dst    : S5(write);
 4568     src1   : S3(read);
 4569     mem    : S3(read);
 4570     D0     : S0;        // big decoder only
 4571     DECODE : S1(2);     // any decoder for FPU POP
 4572     FPU    : S4;
 4573     MEM    : S3;        // any mem
 4574 %}
 4575 
 4576 // Float mem-reg operation
 4577 pipe_class fpu_mem_reg(memory mem, regD src)
 4578 %{
 4579     instruction_count(2);
 4580     src    : S5(read);
 4581     mem    : S3(read);
 4582     DECODE : S0;        // any decoder for FPU PUSH
 4583     D0     : S1;        // big decoder only
 4584     FPU    : S4;
 4585     MEM    : S3;        // any mem
 4586 %}
 4587 
 4588 pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)
 4589 %{
 4590     instruction_count(3);
 4591     src1   : S3(read);
 4592     src2   : S3(read);
 4593     mem    : S3(read);
 4594     DECODE : S0(2);     // any decoder for FPU PUSH
 4595     D0     : S1;        // big decoder only
 4596     FPU    : S4;
 4597     MEM    : S3;        // any mem
 4598 %}
 4599 
 4600 pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)
 4601 %{
 4602     instruction_count(3);
 4603     src1   : S3(read);
 4604     src2   : S3(read);
 4605     mem    : S4(read);
 4606     DECODE : S0;        // any decoder for FPU PUSH
 4607     D0     : S0(2);     // big decoder only
 4608     FPU    : S4;
 4609     MEM    : S3(2);     // any mem
 4610 %}
 4611 
 4612 pipe_class fpu_mem_mem(memory dst, memory src1)
 4613 %{
 4614     instruction_count(2);
 4615     src1   : S3(read);
 4616     dst    : S4(read);
 4617     D0     : S0(2);     // big decoder only
 4618     MEM    : S3(2);     // any mem
 4619 %}
 4620 
 4621 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)
 4622 %{
 4623     instruction_count(3);
 4624     src1   : S3(read);
 4625     src2   : S3(read);
 4626     dst    : S4(read);
 4627     D0     : S0(3);     // big decoder only
 4628     FPU    : S4;
 4629     MEM    : S3(3);     // any mem
 4630 %}
 4631 
 4632 pipe_class fpu_mem_reg_con(memory mem, regD src1)
 4633 %{
 4634     instruction_count(3);
 4635     src1   : S4(read);
 4636     mem    : S4(read);
 4637     DECODE : S0;        // any decoder for FPU PUSH
 4638     D0     : S0(2);     // big decoder only
 4639     FPU    : S4;
 4640     MEM    : S3(2);     // any mem
 4641 %}
 4642 
 4643 // Float load constant
 4644 pipe_class fpu_reg_con(regD dst)
 4645 %{
 4646     instruction_count(2);
 4647     dst    : S5(write);
 4648     D0     : S0;        // big decoder only for the load
 4649     DECODE : S1;        // any decoder for FPU POP
 4650     FPU    : S4;
 4651     MEM    : S3;        // any mem
 4652 %}
 4653 
 4654 // Float load constant
 4655 pipe_class fpu_reg_reg_con(regD dst, regD src)
 4656 %{
 4657     instruction_count(3);
 4658     dst    : S5(write);
 4659     src    : S3(read);
 4660     D0     : S0;        // big decoder only for the load
 4661     DECODE : S1(2);     // any decoder for FPU POP
 4662     FPU    : S4;
 4663     MEM    : S3;        // any mem
 4664 %}
 4665 
 4666 // UnConditional branch
 4667 pipe_class pipe_jmp(label labl)
 4668 %{
 4669     single_instruction;
 4670     BR   : S3;
 4671 %}
 4672 
 4673 // Conditional branch
 4674 pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)
 4675 %{
 4676     single_instruction;
 4677     cr    : S1(read);
 4678     BR    : S3;
 4679 %}
 4680 
 4681 // Allocation idiom
 4682 pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)
 4683 %{
 4684     instruction_count(1); force_serialization;
 4685     fixed_latency(6);
 4686     heap_ptr : S3(read);
 4687     DECODE   : S0(3);
 4688     D0       : S2;
 4689     MEM      : S3;
 4690     ALU      : S3(2);
 4691     dst      : S5(write);
 4692     BR       : S5;
 4693 %}
 4694 
 4695 // Generic big/slow expanded idiom
 4696 pipe_class pipe_slow()
 4697 %{
 4698     instruction_count(10); multiple_bundles; force_serialization;
 4699     fixed_latency(100);
 4700     D0  : S0(2);
 4701     MEM : S3(2);
 4702 %}
 4703 
 4704 // The real do-nothing guy
 4705 pipe_class empty()
 4706 %{
 4707     instruction_count(0);
 4708 %}
 4709 
 4710 // Define the class for the Nop node
 4711 define
 4712 %{
 4713    MachNop = empty;
 4714 %}
 4715 
 4716 %}
 4717 
 4718 //----------INSTRUCTIONS-------------------------------------------------------
 4719 //
 4720 // match      -- States which machine-independent subtree may be replaced
 4721 //               by this instruction.
 4722 // ins_cost   -- The estimated cost of this instruction is used by instruction
 4723 //               selection to identify a minimum cost tree of machine
 4724 //               instructions that matches a tree of machine-independent
 4725 //               instructions.
 4726 // format     -- A string providing the disassembly for this instruction.
 4727 //               The value of an instruction&#39;s operand may be inserted
 4728 //               by referring to it with a &#39;$&#39; prefix.
 4729 // opcode     -- Three instruction opcodes may be provided.  These are referred
 4730 //               to within an encode class as $primary, $secondary, and $tertiary
 4731 //               rrspectively.  The primary opcode is commonly used to
 4732 //               indicate the type of machine instruction, while secondary
 4733 //               and tertiary are often used for prefix options or addressing
 4734 //               modes.
 4735 // ins_encode -- A list of encode classes with parameters. The encode class
 4736 //               name must have been defined in an &#39;enc_class&#39; specification
 4737 //               in the encode section of the architecture description.
 4738 
 4739 
 4740 //----------Load/Store/Move Instructions---------------------------------------
 4741 //----------Load Instructions--------------------------------------------------
 4742 
 4743 // Load Byte (8 bit signed)
 4744 instruct loadB(rRegI dst, memory mem)
 4745 %{
 4746   match(Set dst (LoadB mem));
 4747 
 4748   ins_cost(125);
 4749   format %{ &quot;movsbl  $dst, $mem\t# byte&quot; %}
 4750 
 4751   ins_encode %{
 4752     __ movsbl($dst$$Register, $mem$$Address);
 4753   %}
 4754 
 4755   ins_pipe(ialu_reg_mem);
 4756 %}
 4757 
 4758 // Load Byte (8 bit signed) into Long Register
 4759 instruct loadB2L(rRegL dst, memory mem)
 4760 %{
 4761   match(Set dst (ConvI2L (LoadB mem)));
 4762 
 4763   ins_cost(125);
 4764   format %{ &quot;movsbq  $dst, $mem\t# byte -&gt; long&quot; %}
 4765 
 4766   ins_encode %{
 4767     __ movsbq($dst$$Register, $mem$$Address);
 4768   %}
 4769 
 4770   ins_pipe(ialu_reg_mem);
 4771 %}
 4772 
 4773 // Load Unsigned Byte (8 bit UNsigned)
 4774 instruct loadUB(rRegI dst, memory mem)
 4775 %{
 4776   match(Set dst (LoadUB mem));
 4777 
 4778   ins_cost(125);
 4779   format %{ &quot;movzbl  $dst, $mem\t# ubyte&quot; %}
 4780 
 4781   ins_encode %{
 4782     __ movzbl($dst$$Register, $mem$$Address);
 4783   %}
 4784 
 4785   ins_pipe(ialu_reg_mem);
 4786 %}
 4787 
 4788 // Load Unsigned Byte (8 bit UNsigned) into Long Register
 4789 instruct loadUB2L(rRegL dst, memory mem)
 4790 %{
 4791   match(Set dst (ConvI2L (LoadUB mem)));
 4792 
 4793   ins_cost(125);
 4794   format %{ &quot;movzbq  $dst, $mem\t# ubyte -&gt; long&quot; %}
 4795 
 4796   ins_encode %{
 4797     __ movzbq($dst$$Register, $mem$$Address);
 4798   %}
 4799 
 4800   ins_pipe(ialu_reg_mem);
 4801 %}
 4802 
 4803 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
 4804 instruct loadUB2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4805   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 4806   effect(KILL cr);
 4807 
 4808   format %{ &quot;movzbq  $dst, $mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 4809             &quot;andl    $dst, right_n_bits($mask, 8)&quot; %}
 4810   ins_encode %{
 4811     Register Rdst = $dst$$Register;
 4812     __ movzbq(Rdst, $mem$$Address);
 4813     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
 4814   %}
 4815   ins_pipe(ialu_reg_mem);
 4816 %}
 4817 
 4818 // Load Short (16 bit signed)
 4819 instruct loadS(rRegI dst, memory mem)
 4820 %{
 4821   match(Set dst (LoadS mem));
 4822 
 4823   ins_cost(125);
 4824   format %{ &quot;movswl $dst, $mem\t# short&quot; %}
 4825 
 4826   ins_encode %{
 4827     __ movswl($dst$$Register, $mem$$Address);
 4828   %}
 4829 
 4830   ins_pipe(ialu_reg_mem);
 4831 %}
 4832 
 4833 // Load Short (16 bit signed) to Byte (8 bit signed)
 4834 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4835   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 4836 
 4837   ins_cost(125);
 4838   format %{ &quot;movsbl $dst, $mem\t# short -&gt; byte&quot; %}
 4839   ins_encode %{
 4840     __ movsbl($dst$$Register, $mem$$Address);
 4841   %}
 4842   ins_pipe(ialu_reg_mem);
 4843 %}
 4844 
 4845 // Load Short (16 bit signed) into Long Register
 4846 instruct loadS2L(rRegL dst, memory mem)
 4847 %{
 4848   match(Set dst (ConvI2L (LoadS mem)));
 4849 
 4850   ins_cost(125);
 4851   format %{ &quot;movswq $dst, $mem\t# short -&gt; long&quot; %}
 4852 
 4853   ins_encode %{
 4854     __ movswq($dst$$Register, $mem$$Address);
 4855   %}
 4856 
 4857   ins_pipe(ialu_reg_mem);
 4858 %}
 4859 
 4860 // Load Unsigned Short/Char (16 bit UNsigned)
 4861 instruct loadUS(rRegI dst, memory mem)
 4862 %{
 4863   match(Set dst (LoadUS mem));
 4864 
 4865   ins_cost(125);
 4866   format %{ &quot;movzwl  $dst, $mem\t# ushort/char&quot; %}
 4867 
 4868   ins_encode %{
 4869     __ movzwl($dst$$Register, $mem$$Address);
 4870   %}
 4871 
 4872   ins_pipe(ialu_reg_mem);
 4873 %}
 4874 
 4875 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 4876 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4877   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 4878 
 4879   ins_cost(125);
 4880   format %{ &quot;movsbl $dst, $mem\t# ushort -&gt; byte&quot; %}
 4881   ins_encode %{
 4882     __ movsbl($dst$$Register, $mem$$Address);
 4883   %}
 4884   ins_pipe(ialu_reg_mem);
 4885 %}
 4886 
 4887 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
 4888 instruct loadUS2L(rRegL dst, memory mem)
 4889 %{
 4890   match(Set dst (ConvI2L (LoadUS mem)));
 4891 
 4892   ins_cost(125);
 4893   format %{ &quot;movzwq  $dst, $mem\t# ushort/char -&gt; long&quot; %}
 4894 
 4895   ins_encode %{
 4896     __ movzwq($dst$$Register, $mem$$Address);
 4897   %}
 4898 
 4899   ins_pipe(ialu_reg_mem);
 4900 %}
 4901 
 4902 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
 4903 instruct loadUS2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 4904   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4905 
 4906   format %{ &quot;movzbq  $dst, $mem\t# ushort/char &amp; 0xFF -&gt; long&quot; %}
 4907   ins_encode %{
 4908     __ movzbq($dst$$Register, $mem$$Address);
 4909   %}
 4910   ins_pipe(ialu_reg_mem);
 4911 %}
 4912 
 4913 // Load Unsigned Short/Char (16 bit UNsigned) with 32-bit mask into Long Register
 4914 instruct loadUS2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4915   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4916   effect(KILL cr);
 4917 
 4918   format %{ &quot;movzwq  $dst, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 4919             &quot;andl    $dst, right_n_bits($mask, 16)&quot; %}
 4920   ins_encode %{
 4921     Register Rdst = $dst$$Register;
 4922     __ movzwq(Rdst, $mem$$Address);
 4923     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
 4924   %}
 4925   ins_pipe(ialu_reg_mem);
 4926 %}
 4927 
 4928 // Load Integer
 4929 instruct loadI(rRegI dst, memory mem)
 4930 %{
 4931   match(Set dst (LoadI mem));
 4932 
 4933   ins_cost(125);
 4934   format %{ &quot;movl    $dst, $mem\t# int&quot; %}
 4935 
 4936   ins_encode %{
 4937     __ movl($dst$$Register, $mem$$Address);
 4938   %}
 4939 
 4940   ins_pipe(ialu_reg_mem);
 4941 %}
 4942 
 4943 // Load Integer (32 bit signed) to Byte (8 bit signed)
 4944 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4945   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 4946 
 4947   ins_cost(125);
 4948   format %{ &quot;movsbl  $dst, $mem\t# int -&gt; byte&quot; %}
 4949   ins_encode %{
 4950     __ movsbl($dst$$Register, $mem$$Address);
 4951   %}
 4952   ins_pipe(ialu_reg_mem);
 4953 %}
 4954 
 4955 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
 4956 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
 4957   match(Set dst (AndI (LoadI mem) mask));
 4958 
 4959   ins_cost(125);
 4960   format %{ &quot;movzbl  $dst, $mem\t# int -&gt; ubyte&quot; %}
 4961   ins_encode %{
 4962     __ movzbl($dst$$Register, $mem$$Address);
 4963   %}
 4964   ins_pipe(ialu_reg_mem);
 4965 %}
 4966 
 4967 // Load Integer (32 bit signed) to Short (16 bit signed)
 4968 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
 4969   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 4970 
 4971   ins_cost(125);
 4972   format %{ &quot;movswl  $dst, $mem\t# int -&gt; short&quot; %}
 4973   ins_encode %{
 4974     __ movswl($dst$$Register, $mem$$Address);
 4975   %}
 4976   ins_pipe(ialu_reg_mem);
 4977 %}
 4978 
 4979 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
 4980 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
 4981   match(Set dst (AndI (LoadI mem) mask));
 4982 
 4983   ins_cost(125);
 4984   format %{ &quot;movzwl  $dst, $mem\t# int -&gt; ushort/char&quot; %}
 4985   ins_encode %{
 4986     __ movzwl($dst$$Register, $mem$$Address);
 4987   %}
 4988   ins_pipe(ialu_reg_mem);
 4989 %}
 4990 
 4991 // Load Integer into Long Register
 4992 instruct loadI2L(rRegL dst, memory mem)
 4993 %{
 4994   match(Set dst (ConvI2L (LoadI mem)));
 4995 
 4996   ins_cost(125);
 4997   format %{ &quot;movslq  $dst, $mem\t# int -&gt; long&quot; %}
 4998 
 4999   ins_encode %{
 5000     __ movslq($dst$$Register, $mem$$Address);
 5001   %}
 5002 
 5003   ins_pipe(ialu_reg_mem);
 5004 %}
 5005 
 5006 // Load Integer with mask 0xFF into Long Register
 5007 instruct loadI2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 5008   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5009 
 5010   format %{ &quot;movzbq  $dst, $mem\t# int &amp; 0xFF -&gt; long&quot; %}
 5011   ins_encode %{
 5012     __ movzbq($dst$$Register, $mem$$Address);
 5013   %}
 5014   ins_pipe(ialu_reg_mem);
 5015 %}
 5016 
 5017 // Load Integer with mask 0xFFFF into Long Register
 5018 instruct loadI2L_immI_65535(rRegL dst, memory mem, immI_65535 mask) %{
 5019   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5020 
 5021   format %{ &quot;movzwq  $dst, $mem\t# int &amp; 0xFFFF -&gt; long&quot; %}
 5022   ins_encode %{
 5023     __ movzwq($dst$$Register, $mem$$Address);
 5024   %}
 5025   ins_pipe(ialu_reg_mem);
 5026 %}
 5027 
 5028 // Load Integer with a 31-bit mask into Long Register
 5029 instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{
 5030   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5031   effect(KILL cr);
 5032 
 5033   format %{ &quot;movl    $dst, $mem\t# int &amp; 31-bit mask -&gt; long\n\t&quot;
 5034             &quot;andl    $dst, $mask&quot; %}
 5035   ins_encode %{
 5036     Register Rdst = $dst$$Register;
 5037     __ movl(Rdst, $mem$$Address);
 5038     __ andl(Rdst, $mask$$constant);
 5039   %}
 5040   ins_pipe(ialu_reg_mem);
 5041 %}
 5042 
 5043 // Load Unsigned Integer into Long Register
 5044 instruct loadUI2L(rRegL dst, memory mem, immL_32bits mask)
 5045 %{
 5046   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5047 
 5048   ins_cost(125);
 5049   format %{ &quot;movl    $dst, $mem\t# uint -&gt; long&quot; %}
 5050 
 5051   ins_encode %{
 5052     __ movl($dst$$Register, $mem$$Address);
 5053   %}
 5054 
 5055   ins_pipe(ialu_reg_mem);
 5056 %}
 5057 
 5058 // Load Long
 5059 instruct loadL(rRegL dst, memory mem)
 5060 %{
 5061   match(Set dst (LoadL mem));
 5062 
 5063   ins_cost(125);
 5064   format %{ &quot;movq    $dst, $mem\t# long&quot; %}
 5065 
 5066   ins_encode %{
 5067     __ movq($dst$$Register, $mem$$Address);
 5068   %}
 5069 
 5070   ins_pipe(ialu_reg_mem); // XXX
 5071 %}
 5072 
 5073 // Load Range
 5074 instruct loadRange(rRegI dst, memory mem)
 5075 %{
 5076   match(Set dst (LoadRange mem));
 5077 
 5078   ins_cost(125); // XXX
 5079   format %{ &quot;movl    $dst, $mem\t# range&quot; %}
 5080   opcode(0x8B);
 5081   ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
 5082   ins_pipe(ialu_reg_mem);
 5083 %}
 5084 
 5085 // Load Pointer
 5086 instruct loadP(rRegP dst, memory mem)
 5087 %{
 5088   match(Set dst (LoadP mem));
 5089   predicate(n-&gt;as_Load()-&gt;barrier_data() == 0);
 5090 
 5091   ins_cost(125); // XXX
 5092   format %{ &quot;movq    $dst, $mem\t# ptr&quot; %}
 5093   opcode(0x8B);
 5094   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5095   ins_pipe(ialu_reg_mem); // XXX
 5096 %}
 5097 
 5098 // Load Compressed Pointer
 5099 instruct loadN(rRegN dst, memory mem)
 5100 %{
 5101    match(Set dst (LoadN mem));
 5102 
 5103    ins_cost(125); // XXX
 5104    format %{ &quot;movl    $dst, $mem\t# compressed ptr&quot; %}
 5105    ins_encode %{
 5106      __ movl($dst$$Register, $mem$$Address);
 5107    %}
 5108    ins_pipe(ialu_reg_mem); // XXX
 5109 %}
 5110 
 5111 
 5112 // Load Klass Pointer
 5113 instruct loadKlass(rRegP dst, memory mem)
 5114 %{
 5115   match(Set dst (LoadKlass mem));
 5116 
 5117   ins_cost(125); // XXX
 5118   format %{ &quot;movq    $dst, $mem\t# class&quot; %}
 5119   opcode(0x8B);
 5120   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5121   ins_pipe(ialu_reg_mem); // XXX
 5122 %}
 5123 
 5124 // Load narrow Klass Pointer
 5125 instruct loadNKlass(rRegN dst, memory mem)
 5126 %{
 5127   match(Set dst (LoadNKlass mem));
 5128 
 5129   ins_cost(125); // XXX
 5130   format %{ &quot;movl    $dst, $mem\t# compressed klass ptr&quot; %}
 5131   ins_encode %{
 5132     __ movl($dst$$Register, $mem$$Address);
 5133   %}
 5134   ins_pipe(ialu_reg_mem); // XXX
 5135 %}
 5136 
 5137 // Load Float
 5138 instruct loadF(regF dst, memory mem)
 5139 %{
 5140   match(Set dst (LoadF mem));
 5141 
 5142   ins_cost(145); // XXX
 5143   format %{ &quot;movss   $dst, $mem\t# float&quot; %}
 5144   ins_encode %{
 5145     __ movflt($dst$$XMMRegister, $mem$$Address);
 5146   %}
 5147   ins_pipe(pipe_slow); // XXX
 5148 %}
 5149 
 5150 // Load Float
 5151 instruct MoveF2VL(vlRegF dst, regF src) %{
 5152   match(Set dst src);
 5153   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5154   ins_encode %{
 5155     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5156   %}
 5157   ins_pipe( fpu_reg_reg );
 5158 %}
 5159 
 5160 // Load Float
 5161 instruct MoveF2LEG(legRegF dst, regF src) %{
 5162   match(Set dst src);
 5163   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5164   ins_encode %{
 5165     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5166   %}
 5167   ins_pipe( fpu_reg_reg );
 5168 %}
 5169 
 5170 // Load Float
 5171 instruct MoveVL2F(regF dst, vlRegF src) %{
 5172   match(Set dst src);
 5173   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5174   ins_encode %{
 5175     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5176   %}
 5177   ins_pipe( fpu_reg_reg );
 5178 %}
 5179 
 5180 // Load Float
 5181 instruct MoveLEG2F(regF dst, legRegF src) %{
 5182   match(Set dst src);
 5183   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5184   ins_encode %{
 5185     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5186   %}
 5187   ins_pipe( fpu_reg_reg );
 5188 %}
 5189 
 5190 // Load Double
 5191 instruct loadD_partial(regD dst, memory mem)
 5192 %{
 5193   predicate(!UseXmmLoadAndClearUpper);
 5194   match(Set dst (LoadD mem));
 5195 
 5196   ins_cost(145); // XXX
 5197   format %{ &quot;movlpd  $dst, $mem\t# double&quot; %}
 5198   ins_encode %{
 5199     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5200   %}
 5201   ins_pipe(pipe_slow); // XXX
 5202 %}
 5203 
 5204 instruct loadD(regD dst, memory mem)
 5205 %{
 5206   predicate(UseXmmLoadAndClearUpper);
 5207   match(Set dst (LoadD mem));
 5208 
 5209   ins_cost(145); // XXX
 5210   format %{ &quot;movsd   $dst, $mem\t# double&quot; %}
 5211   ins_encode %{
 5212     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5213   %}
 5214   ins_pipe(pipe_slow); // XXX
 5215 %}
 5216 
 5217 // Load Double
 5218 instruct MoveD2VL(vlRegD dst, regD src) %{
 5219   match(Set dst src);
 5220   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5221   ins_encode %{
 5222     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5223   %}
 5224   ins_pipe( fpu_reg_reg );
 5225 %}
 5226 
 5227 // Load Double
 5228 instruct MoveD2LEG(legRegD dst, regD src) %{
 5229   match(Set dst src);
 5230   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5231   ins_encode %{
 5232     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5233   %}
 5234   ins_pipe( fpu_reg_reg );
 5235 %}
 5236 
 5237 // Load Double
 5238 instruct MoveVL2D(regD dst, vlRegD src) %{
 5239   match(Set dst src);
 5240   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5241   ins_encode %{
 5242     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5243   %}
 5244   ins_pipe( fpu_reg_reg );
 5245 %}
 5246 
 5247 // Load Double
 5248 instruct MoveLEG2D(regD dst, legRegD src) %{
 5249   match(Set dst src);
 5250   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5251   ins_encode %{
 5252     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5253   %}
 5254   ins_pipe( fpu_reg_reg );
 5255 %}
 5256 
 5257 // Following pseudo code describes the algorithm for max[FD]:
 5258 // Min algorithm is on similar lines
 5259 //  btmp = (b &lt; +0.0) ? a : b
 5260 //  atmp = (b &lt; +0.0) ? b : a
 5261 //  Tmp  = Max_Float(atmp , btmp)
 5262 //  Res  = (atmp == NaN) ? atmp : Tmp
 5263 
 5264 // max = java.lang.Math.max(float a, float b)
 5265 instruct maxF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5266   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5267   match(Set dst (MaxF a b));
 5268   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5269   format %{
 5270      &quot;blendvps         $btmp,$b,$a,$b           \n\t&quot;
 5271      &quot;blendvps         $atmp,$a,$b,$b           \n\t&quot;
 5272      &quot;vmaxss           $tmp,$atmp,$btmp         \n\t&quot;
 5273      &quot;cmpps.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5274      &quot;blendvps         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5275   %}
 5276   ins_encode %{
 5277     int vector_len = Assembler::AVX_128bit;
 5278     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5279     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5280     __ vmaxss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5281     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5282     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5283  %}
 5284   ins_pipe( pipe_slow );
 5285 %}
 5286 
 5287 instruct maxF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5288   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5289   match(Set dst (MaxF a b));
 5290   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5291 
 5292   format %{ &quot;$dst = max($a, $b)\t# intrinsic (float)&quot; %}
 5293   ins_encode %{
 5294     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5295                     false /*min*/, true /*single*/);
 5296   %}
 5297   ins_pipe( pipe_slow );
 5298 %}
 5299 
 5300 // max = java.lang.Math.max(double a, double b)
 5301 instruct maxD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5302   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5303   match(Set dst (MaxD a b));
 5304   effect(USE a, USE b, TEMP atmp, TEMP btmp, TEMP tmp);
 5305   format %{
 5306      &quot;blendvpd         $btmp,$b,$a,$b            \n\t&quot;
 5307      &quot;blendvpd         $atmp,$a,$b,$b            \n\t&quot;
 5308      &quot;vmaxsd           $tmp,$atmp,$btmp          \n\t&quot;
 5309      &quot;cmppd.unordered  $btmp,$atmp,$atmp         \n\t&quot;
 5310      &quot;blendvpd         $dst,$tmp,$atmp,$btmp     \n\t&quot;
 5311   %}
 5312   ins_encode %{
 5313     int vector_len = Assembler::AVX_128bit;
 5314     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5315     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5316     __ vmaxsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5317     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5318     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5319   %}
 5320   ins_pipe( pipe_slow );
 5321 %}
 5322 
 5323 instruct maxD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5324   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5325   match(Set dst (MaxD a b));
 5326   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5327 
 5328   format %{ &quot;$dst = max($a, $b)\t# intrinsic (double)&quot; %}
 5329   ins_encode %{
 5330     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5331                     false /*min*/, false /*single*/);
 5332   %}
 5333   ins_pipe( pipe_slow );
 5334 %}
 5335 
 5336 // min = java.lang.Math.min(float a, float b)
 5337 instruct minF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5338   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5339   match(Set dst (MinF a b));
 5340   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5341   format %{
 5342      &quot;blendvps         $atmp,$a,$b,$a             \n\t&quot;
 5343      &quot;blendvps         $btmp,$b,$a,$a             \n\t&quot;
 5344      &quot;vminss           $tmp,$atmp,$btmp           \n\t&quot;
 5345      &quot;cmpps.unordered  $btmp,$atmp,$atmp          \n\t&quot;
 5346      &quot;blendvps         $dst,$tmp,$atmp,$btmp      \n\t&quot;
 5347   %}
 5348   ins_encode %{
 5349     int vector_len = Assembler::AVX_128bit;
 5350     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5351     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5352     __ vminss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5353     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5354     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5355   %}
 5356   ins_pipe( pipe_slow );
 5357 %}
 5358 
 5359 instruct minF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5360   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5361   match(Set dst (MinF a b));
 5362   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5363 
 5364   format %{ &quot;$dst = min($a, $b)\t# intrinsic (float)&quot; %}
 5365   ins_encode %{
 5366     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5367                     true /*min*/, true /*single*/);
 5368   %}
 5369   ins_pipe( pipe_slow );
 5370 %}
 5371 
 5372 // min = java.lang.Math.min(double a, double b)
 5373 instruct minD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5374   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5375   match(Set dst (MinD a b));
 5376   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5377   format %{
 5378      &quot;blendvpd         $atmp,$a,$b,$a           \n\t&quot;
 5379      &quot;blendvpd         $btmp,$b,$a,$a           \n\t&quot;
 5380      &quot;vminsd           $tmp,$atmp,$btmp         \n\t&quot;
 5381      &quot;cmppd.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5382      &quot;blendvpd         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5383   %}
 5384   ins_encode %{
 5385     int vector_len = Assembler::AVX_128bit;
 5386     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5387     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5388     __ vminsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5389     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5390     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5391   %}
 5392   ins_pipe( pipe_slow );
 5393 %}
 5394 
 5395 instruct minD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5396   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5397   match(Set dst (MinD a b));
 5398   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5399 
 5400   format %{ &quot;$dst = min($a, $b)\t# intrinsic (double)&quot; %}
 5401   ins_encode %{
 5402     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5403                     true /*min*/, false /*single*/);
 5404   %}
 5405   ins_pipe( pipe_slow );
 5406 %}
 5407 
 5408 // Load Effective Address
 5409 instruct leaP8(rRegP dst, indOffset8 mem)
 5410 %{
 5411   match(Set dst mem);
 5412 
 5413   ins_cost(110); // XXX
 5414   format %{ &quot;leaq    $dst, $mem\t# ptr 8&quot; %}
 5415   opcode(0x8D);
 5416   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5417   ins_pipe(ialu_reg_reg_fat);
 5418 %}
 5419 
 5420 instruct leaP32(rRegP dst, indOffset32 mem)
 5421 %{
 5422   match(Set dst mem);
 5423 
 5424   ins_cost(110);
 5425   format %{ &quot;leaq    $dst, $mem\t# ptr 32&quot; %}
 5426   opcode(0x8D);
 5427   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5428   ins_pipe(ialu_reg_reg_fat);
 5429 %}
 5430 
 5431 // instruct leaPIdx(rRegP dst, indIndex mem)
 5432 // %{
 5433 //   match(Set dst mem);
 5434 
 5435 //   ins_cost(110);
 5436 //   format %{ &quot;leaq    $dst, $mem\t# ptr idx&quot; %}
 5437 //   opcode(0x8D);
 5438 //   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5439 //   ins_pipe(ialu_reg_reg_fat);
 5440 // %}
 5441 
 5442 instruct leaPIdxOff(rRegP dst, indIndexOffset mem)
 5443 %{
 5444   match(Set dst mem);
 5445 
 5446   ins_cost(110);
 5447   format %{ &quot;leaq    $dst, $mem\t# ptr idxoff&quot; %}
 5448   opcode(0x8D);
 5449   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5450   ins_pipe(ialu_reg_reg_fat);
 5451 %}
 5452 
 5453 instruct leaPIdxScale(rRegP dst, indIndexScale mem)
 5454 %{
 5455   match(Set dst mem);
 5456 
 5457   ins_cost(110);
 5458   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5459   opcode(0x8D);
 5460   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5461   ins_pipe(ialu_reg_reg_fat);
 5462 %}
 5463 
 5464 instruct leaPPosIdxScale(rRegP dst, indPosIndexScale mem)
 5465 %{
 5466   match(Set dst mem);
 5467 
 5468   ins_cost(110);
 5469   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5470   opcode(0x8D);
 5471   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5472   ins_pipe(ialu_reg_reg_fat);
 5473 %}
 5474 
 5475 instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)
 5476 %{
 5477   match(Set dst mem);
 5478 
 5479   ins_cost(110);
 5480   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoff&quot; %}
 5481   opcode(0x8D);
 5482   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5483   ins_pipe(ialu_reg_reg_fat);
 5484 %}
 5485 
 5486 instruct leaPPosIdxOff(rRegP dst, indPosIndexOffset mem)
 5487 %{
 5488   match(Set dst mem);
 5489 
 5490   ins_cost(110);
 5491   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoff&quot; %}
 5492   opcode(0x8D);
 5493   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5494   ins_pipe(ialu_reg_reg_fat);
 5495 %}
 5496 
 5497 instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)
 5498 %{
 5499   match(Set dst mem);
 5500 
 5501   ins_cost(110);
 5502   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoff&quot; %}
 5503   opcode(0x8D);
 5504   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5505   ins_pipe(ialu_reg_reg_fat);
 5506 %}
 5507 
 5508 // Load Effective Address which uses Narrow (32-bits) oop
 5509 instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
 5510 %{
 5511   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() != 0));
 5512   match(Set dst mem);
 5513 
 5514   ins_cost(110);
 5515   format %{ &quot;leaq    $dst, $mem\t# ptr compressedoopoff32&quot; %}
 5516   opcode(0x8D);
 5517   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5518   ins_pipe(ialu_reg_reg_fat);
 5519 %}
 5520 
 5521 instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
 5522 %{
 5523   predicate(CompressedOops::shift() == 0);
 5524   match(Set dst mem);
 5525 
 5526   ins_cost(110); // XXX
 5527   format %{ &quot;leaq    $dst, $mem\t# ptr off8narrow&quot; %}
 5528   opcode(0x8D);
 5529   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5530   ins_pipe(ialu_reg_reg_fat);
 5531 %}
 5532 
 5533 instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
 5534 %{
 5535   predicate(CompressedOops::shift() == 0);
 5536   match(Set dst mem);
 5537 
 5538   ins_cost(110);
 5539   format %{ &quot;leaq    $dst, $mem\t# ptr off32narrow&quot; %}
 5540   opcode(0x8D);
 5541   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5542   ins_pipe(ialu_reg_reg_fat);
 5543 %}
 5544 
 5545 instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
 5546 %{
 5547   predicate(CompressedOops::shift() == 0);
 5548   match(Set dst mem);
 5549 
 5550   ins_cost(110);
 5551   format %{ &quot;leaq    $dst, $mem\t# ptr idxoffnarrow&quot; %}
 5552   opcode(0x8D);
 5553   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5554   ins_pipe(ialu_reg_reg_fat);
 5555 %}
 5556 
 5557 instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
 5558 %{
 5559   predicate(CompressedOops::shift() == 0);
 5560   match(Set dst mem);
 5561 
 5562   ins_cost(110);
 5563   format %{ &quot;leaq    $dst, $mem\t# ptr idxscalenarrow&quot; %}
 5564   opcode(0x8D);
 5565   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5566   ins_pipe(ialu_reg_reg_fat);
 5567 %}
 5568 
 5569 instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
 5570 %{
 5571   predicate(CompressedOops::shift() == 0);
 5572   match(Set dst mem);
 5573 
 5574   ins_cost(110);
 5575   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoffnarrow&quot; %}
 5576   opcode(0x8D);
 5577   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5578   ins_pipe(ialu_reg_reg_fat);
 5579 %}
 5580 
 5581 instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
 5582 %{
 5583   predicate(CompressedOops::shift() == 0);
 5584   match(Set dst mem);
 5585 
 5586   ins_cost(110);
 5587   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoffnarrow&quot; %}
 5588   opcode(0x8D);
 5589   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5590   ins_pipe(ialu_reg_reg_fat);
 5591 %}
 5592 
 5593 instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
 5594 %{
 5595   predicate(CompressedOops::shift() == 0);
 5596   match(Set dst mem);
 5597 
 5598   ins_cost(110);
 5599   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoffnarrow&quot; %}
 5600   opcode(0x8D);
 5601   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5602   ins_pipe(ialu_reg_reg_fat);
 5603 %}
 5604 
 5605 instruct loadConI(rRegI dst, immI src)
 5606 %{
 5607   match(Set dst src);
 5608 
 5609   format %{ &quot;movl    $dst, $src\t# int&quot; %}
 5610   ins_encode(load_immI(dst, src));
 5611   ins_pipe(ialu_reg_fat); // XXX
 5612 %}
 5613 
 5614 instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
 5615 %{
 5616   match(Set dst src);
 5617   effect(KILL cr);
 5618 
 5619   ins_cost(50);
 5620   format %{ &quot;xorl    $dst, $dst\t# int&quot; %}
 5621   opcode(0x33); /* + rd */
 5622   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5623   ins_pipe(ialu_reg);
 5624 %}
 5625 
 5626 instruct loadConL(rRegL dst, immL src)
 5627 %{
 5628   match(Set dst src);
 5629 
 5630   ins_cost(150);
 5631   format %{ &quot;movq    $dst, $src\t# long&quot; %}
 5632   ins_encode(load_immL(dst, src));
 5633   ins_pipe(ialu_reg);
 5634 %}
 5635 
 5636 instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)
 5637 %{
 5638   match(Set dst src);
 5639   effect(KILL cr);
 5640 
 5641   ins_cost(50);
 5642   format %{ &quot;xorl    $dst, $dst\t# long&quot; %}
 5643   opcode(0x33); /* + rd */
 5644   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5645   ins_pipe(ialu_reg); // XXX
 5646 %}
 5647 
 5648 instruct loadConUL32(rRegL dst, immUL32 src)
 5649 %{
 5650   match(Set dst src);
 5651 
 5652   ins_cost(60);
 5653   format %{ &quot;movl    $dst, $src\t# long (unsigned 32-bit)&quot; %}
 5654   ins_encode(load_immUL32(dst, src));
 5655   ins_pipe(ialu_reg);
 5656 %}
 5657 
 5658 instruct loadConL32(rRegL dst, immL32 src)
 5659 %{
 5660   match(Set dst src);
 5661 
 5662   ins_cost(70);
 5663   format %{ &quot;movq    $dst, $src\t# long (32-bit)&quot; %}
 5664   ins_encode(load_immL32(dst, src));
 5665   ins_pipe(ialu_reg);
 5666 %}
 5667 
 5668 instruct loadConP(rRegP dst, immP con) %{
 5669   match(Set dst con);
 5670 
 5671   format %{ &quot;movq    $dst, $con\t# ptr&quot; %}
 5672   ins_encode(load_immP(dst, con));
 5673   ins_pipe(ialu_reg_fat); // XXX
 5674 %}
 5675 
 5676 instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)
 5677 %{
 5678   match(Set dst src);
 5679   effect(KILL cr);
 5680 
 5681   ins_cost(50);
 5682   format %{ &quot;xorl    $dst, $dst\t# ptr&quot; %}
 5683   opcode(0x33); /* + rd */
 5684   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5685   ins_pipe(ialu_reg);
 5686 %}
 5687 
 5688 instruct loadConP31(rRegP dst, immP31 src, rFlagsReg cr)
 5689 %{
 5690   match(Set dst src);
 5691   effect(KILL cr);
 5692 
 5693   ins_cost(60);
 5694   format %{ &quot;movl    $dst, $src\t# ptr (positive 32-bit)&quot; %}
 5695   ins_encode(load_immP31(dst, src));
 5696   ins_pipe(ialu_reg);
 5697 %}
 5698 
 5699 instruct loadConF(regF dst, immF con) %{
 5700   match(Set dst con);
 5701   ins_cost(125);
 5702   format %{ &quot;movss   $dst, [$constantaddress]\t# load from constant table: float=$con&quot; %}
 5703   ins_encode %{
 5704     __ movflt($dst$$XMMRegister, $constantaddress($con));
 5705   %}
 5706   ins_pipe(pipe_slow);
 5707 %}
 5708 
 5709 instruct loadConN0(rRegN dst, immN0 src, rFlagsReg cr) %{
 5710   match(Set dst src);
 5711   effect(KILL cr);
 5712   format %{ &quot;xorq    $dst, $src\t# compressed NULL ptr&quot; %}
 5713   ins_encode %{
 5714     __ xorq($dst$$Register, $dst$$Register);
 5715   %}
 5716   ins_pipe(ialu_reg);
 5717 %}
 5718 
 5719 instruct loadConN(rRegN dst, immN src) %{
 5720   match(Set dst src);
 5721 
 5722   ins_cost(125);
 5723   format %{ &quot;movl    $dst, $src\t# compressed ptr&quot; %}
 5724   ins_encode %{
 5725     address con = (address)$src$$constant;
 5726     if (con == NULL) {
 5727       ShouldNotReachHere();
 5728     } else {
 5729       __ set_narrow_oop($dst$$Register, (jobject)$src$$constant);
 5730     }
 5731   %}
 5732   ins_pipe(ialu_reg_fat); // XXX
 5733 %}
 5734 
 5735 instruct loadConNKlass(rRegN dst, immNKlass src) %{
 5736   match(Set dst src);
 5737 
 5738   ins_cost(125);
 5739   format %{ &quot;movl    $dst, $src\t# compressed klass ptr&quot; %}
 5740   ins_encode %{
 5741     address con = (address)$src$$constant;
 5742     if (con == NULL) {
 5743       ShouldNotReachHere();
 5744     } else {
 5745       __ set_narrow_klass($dst$$Register, (Klass*)$src$$constant);
 5746     }
 5747   %}
 5748   ins_pipe(ialu_reg_fat); // XXX
 5749 %}
 5750 
 5751 instruct loadConF0(regF dst, immF0 src)
 5752 %{
 5753   match(Set dst src);
 5754   ins_cost(100);
 5755 
 5756   format %{ &quot;xorps   $dst, $dst\t# float 0.0&quot; %}
 5757   ins_encode %{
 5758     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
 5759   %}
 5760   ins_pipe(pipe_slow);
 5761 %}
 5762 
 5763 // Use the same format since predicate() can not be used here.
 5764 instruct loadConD(regD dst, immD con) %{
 5765   match(Set dst con);
 5766   ins_cost(125);
 5767   format %{ &quot;movsd   $dst, [$constantaddress]\t# load from constant table: double=$con&quot; %}
 5768   ins_encode %{
 5769     __ movdbl($dst$$XMMRegister, $constantaddress($con));
 5770   %}
 5771   ins_pipe(pipe_slow);
 5772 %}
 5773 
 5774 instruct loadConD0(regD dst, immD0 src)
 5775 %{
 5776   match(Set dst src);
 5777   ins_cost(100);
 5778 
 5779   format %{ &quot;xorpd   $dst, $dst\t# double 0.0&quot; %}
 5780   ins_encode %{
 5781     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
 5782   %}
 5783   ins_pipe(pipe_slow);
 5784 %}
 5785 
 5786 instruct loadSSI(rRegI dst, stackSlotI src)
 5787 %{
 5788   match(Set dst src);
 5789 
 5790   ins_cost(125);
 5791   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 5792   opcode(0x8B);
 5793   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 5794   ins_pipe(ialu_reg_mem);
 5795 %}
 5796 
 5797 instruct loadSSL(rRegL dst, stackSlotL src)
 5798 %{
 5799   match(Set dst src);
 5800 
 5801   ins_cost(125);
 5802   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 5803   opcode(0x8B);
 5804   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5805   ins_pipe(ialu_reg_mem);
 5806 %}
 5807 
 5808 instruct loadSSP(rRegP dst, stackSlotP src)
 5809 %{
 5810   match(Set dst src);
 5811 
 5812   ins_cost(125);
 5813   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 5814   opcode(0x8B);
 5815   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5816   ins_pipe(ialu_reg_mem);
 5817 %}
 5818 
 5819 instruct loadSSF(regF dst, stackSlotF src)
 5820 %{
 5821   match(Set dst src);
 5822 
 5823   ins_cost(125);
 5824   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 5825   ins_encode %{
 5826     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
 5827   %}
 5828   ins_pipe(pipe_slow); // XXX
 5829 %}
 5830 
 5831 // Use the same format since predicate() can not be used here.
 5832 instruct loadSSD(regD dst, stackSlotD src)
 5833 %{
 5834   match(Set dst src);
 5835 
 5836   ins_cost(125);
 5837   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 5838   ins_encode  %{
 5839     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
 5840   %}
 5841   ins_pipe(pipe_slow); // XXX
 5842 %}
 5843 
 5844 // Prefetch instructions for allocation.
 5845 // Must be safe to execute with invalid address (cannot fault).
 5846 
 5847 instruct prefetchAlloc( memory mem ) %{
 5848   predicate(AllocatePrefetchInstr==3);
 5849   match(PrefetchAllocation mem);
 5850   ins_cost(125);
 5851 
 5852   format %{ &quot;PREFETCHW $mem\t# Prefetch allocation into level 1 cache and mark modified&quot; %}
 5853   ins_encode %{
 5854     __ prefetchw($mem$$Address);
 5855   %}
 5856   ins_pipe(ialu_mem);
 5857 %}
 5858 
 5859 instruct prefetchAllocNTA( memory mem ) %{
 5860   predicate(AllocatePrefetchInstr==0);
 5861   match(PrefetchAllocation mem);
 5862   ins_cost(125);
 5863 
 5864   format %{ &quot;PREFETCHNTA $mem\t# Prefetch allocation to non-temporal cache for write&quot; %}
 5865   ins_encode %{
 5866     __ prefetchnta($mem$$Address);
 5867   %}
 5868   ins_pipe(ialu_mem);
 5869 %}
 5870 
 5871 instruct prefetchAllocT0( memory mem ) %{
 5872   predicate(AllocatePrefetchInstr==1);
 5873   match(PrefetchAllocation mem);
 5874   ins_cost(125);
 5875 
 5876   format %{ &quot;PREFETCHT0 $mem\t# Prefetch allocation to level 1 and 2 caches for write&quot; %}
 5877   ins_encode %{
 5878     __ prefetcht0($mem$$Address);
 5879   %}
 5880   ins_pipe(ialu_mem);
 5881 %}
 5882 
 5883 instruct prefetchAllocT2( memory mem ) %{
 5884   predicate(AllocatePrefetchInstr==2);
 5885   match(PrefetchAllocation mem);
 5886   ins_cost(125);
 5887 
 5888   format %{ &quot;PREFETCHT2 $mem\t# Prefetch allocation to level 2 cache for write&quot; %}
 5889   ins_encode %{
 5890     __ prefetcht2($mem$$Address);
 5891   %}
 5892   ins_pipe(ialu_mem);
 5893 %}
 5894 
 5895 //----------Store Instructions-------------------------------------------------
 5896 
 5897 // Store Byte
 5898 instruct storeB(memory mem, rRegI src)
 5899 %{
 5900   match(Set mem (StoreB mem src));
 5901 
 5902   ins_cost(125); // XXX
 5903   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 5904   opcode(0x88);
 5905   ins_encode(REX_breg_mem(src, mem), OpcP, reg_mem(src, mem));
 5906   ins_pipe(ialu_mem_reg);
 5907 %}
 5908 
 5909 // Store Char/Short
 5910 instruct storeC(memory mem, rRegI src)
 5911 %{
 5912   match(Set mem (StoreC mem src));
 5913 
 5914   ins_cost(125); // XXX
 5915   format %{ &quot;movw    $mem, $src\t# char/short&quot; %}
 5916   opcode(0x89);
 5917   ins_encode(SizePrefix, REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5918   ins_pipe(ialu_mem_reg);
 5919 %}
 5920 
 5921 // Store Integer
 5922 instruct storeI(memory mem, rRegI src)
 5923 %{
 5924   match(Set mem (StoreI mem src));
 5925 
 5926   ins_cost(125); // XXX
 5927   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 5928   opcode(0x89);
 5929   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5930   ins_pipe(ialu_mem_reg);
 5931 %}
 5932 
 5933 // Store Long
 5934 instruct storeL(memory mem, rRegL src)
 5935 %{
 5936   match(Set mem (StoreL mem src));
 5937 
 5938   ins_cost(125); // XXX
 5939   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 5940   opcode(0x89);
 5941   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5942   ins_pipe(ialu_mem_reg); // XXX
 5943 %}
 5944 
 5945 // Store Pointer
 5946 instruct storeP(memory mem, any_RegP src)
 5947 %{
 5948   match(Set mem (StoreP mem src));
 5949 
 5950   ins_cost(125); // XXX
 5951   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5952   opcode(0x89);
 5953   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5954   ins_pipe(ialu_mem_reg);
 5955 %}
 5956 
 5957 instruct storeImmP0(memory mem, immP0 zero)
 5958 %{
 5959   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 5960   match(Set mem (StoreP mem zero));
 5961 
 5962   ins_cost(125); // XXX
 5963   format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
 5964   ins_encode %{
 5965     __ movq($mem$$Address, r12);
 5966   %}
 5967   ins_pipe(ialu_mem_reg);
 5968 %}
 5969 
 5970 // Store NULL Pointer, mark word, or other simple pointer constant.
 5971 instruct storeImmP(memory mem, immP31 src)
 5972 %{
 5973   match(Set mem (StoreP mem src));
 5974 
 5975   ins_cost(150); // XXX
 5976   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5977   opcode(0xC7); /* C7 /0 */
 5978   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 5979   ins_pipe(ialu_mem_imm);
 5980 %}
 5981 
 5982 // Store Compressed Pointer
 5983 instruct storeN(memory mem, rRegN src)
 5984 %{
 5985   match(Set mem (StoreN mem src));
 5986 
 5987   ins_cost(125); // XXX
 5988   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 5989   ins_encode %{
 5990     __ movl($mem$$Address, $src$$Register);
 5991   %}
 5992   ins_pipe(ialu_mem_reg);
 5993 %}
 5994 
 5995 instruct storeNKlass(memory mem, rRegN src)
 5996 %{
 5997   match(Set mem (StoreNKlass mem src));
 5998 
 5999   ins_cost(125); // XXX
 6000   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6001   ins_encode %{
 6002     __ movl($mem$$Address, $src$$Register);
 6003   %}
 6004   ins_pipe(ialu_mem_reg);
 6005 %}
 6006 
 6007 instruct storeImmN0(memory mem, immN0 zero)
 6008 %{
 6009   predicate(CompressedOops::base() == NULL);
 6010   match(Set mem (StoreN mem zero));
 6011 
 6012   ins_cost(125); // XXX
 6013   format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
 6014   ins_encode %{
 6015     __ movl($mem$$Address, r12);
 6016   %}
 6017   ins_pipe(ialu_mem_reg);
 6018 %}
 6019 
 6020 instruct storeImmN(memory mem, immN src)
 6021 %{
 6022   match(Set mem (StoreN mem src));
 6023 
 6024   ins_cost(150); // XXX
 6025   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6026   ins_encode %{
 6027     address con = (address)$src$$constant;
 6028     if (con == NULL) {
 6029       __ movl($mem$$Address, (int32_t)0);
 6030     } else {
 6031       __ set_narrow_oop($mem$$Address, (jobject)$src$$constant);
 6032     }
 6033   %}
 6034   ins_pipe(ialu_mem_imm);
 6035 %}
 6036 
 6037 instruct storeImmNKlass(memory mem, immNKlass src)
 6038 %{
 6039   match(Set mem (StoreNKlass mem src));
 6040 
 6041   ins_cost(150); // XXX
 6042   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6043   ins_encode %{
 6044     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
 6045   %}
 6046   ins_pipe(ialu_mem_imm);
 6047 %}
 6048 
 6049 // Store Integer Immediate
 6050 instruct storeImmI0(memory mem, immI0 zero)
 6051 %{
 6052   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6053   match(Set mem (StoreI mem zero));
 6054 
 6055   ins_cost(125); // XXX
 6056   format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
 6057   ins_encode %{
 6058     __ movl($mem$$Address, r12);
 6059   %}
 6060   ins_pipe(ialu_mem_reg);
 6061 %}
 6062 
 6063 instruct storeImmI(memory mem, immI src)
 6064 %{
 6065   match(Set mem (StoreI mem src));
 6066 
 6067   ins_cost(150);
 6068   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 6069   opcode(0xC7); /* C7 /0 */
 6070   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6071   ins_pipe(ialu_mem_imm);
 6072 %}
 6073 
 6074 // Store Long Immediate
 6075 instruct storeImmL0(memory mem, immL0 zero)
 6076 %{
 6077   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6078   match(Set mem (StoreL mem zero));
 6079 
 6080   ins_cost(125); // XXX
 6081   format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
 6082   ins_encode %{
 6083     __ movq($mem$$Address, r12);
 6084   %}
 6085   ins_pipe(ialu_mem_reg);
 6086 %}
 6087 
 6088 instruct storeImmL(memory mem, immL32 src)
 6089 %{
 6090   match(Set mem (StoreL mem src));
 6091 
 6092   ins_cost(150);
 6093   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6094   opcode(0xC7); /* C7 /0 */
 6095   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6096   ins_pipe(ialu_mem_imm);
 6097 %}
 6098 
 6099 // Store Short/Char Immediate
 6100 instruct storeImmC0(memory mem, immI0 zero)
 6101 %{
 6102   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6103   match(Set mem (StoreC mem zero));
 6104 
 6105   ins_cost(125); // XXX
 6106   format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6107   ins_encode %{
 6108     __ movw($mem$$Address, r12);
 6109   %}
 6110   ins_pipe(ialu_mem_reg);
 6111 %}
 6112 
 6113 instruct storeImmI16(memory mem, immI16 src)
 6114 %{
 6115   predicate(UseStoreImmI16);
 6116   match(Set mem (StoreC mem src));
 6117 
 6118   ins_cost(150);
 6119   format %{ &quot;movw    $mem, $src\t# short/char&quot; %}
 6120   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
 6121   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
 6122   ins_pipe(ialu_mem_imm);
 6123 %}
 6124 
 6125 // Store Byte Immediate
 6126 instruct storeImmB0(memory mem, immI0 zero)
 6127 %{
 6128   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6129   match(Set mem (StoreB mem zero));
 6130 
 6131   ins_cost(125); // XXX
 6132   format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6133   ins_encode %{
 6134     __ movb($mem$$Address, r12);
 6135   %}
 6136   ins_pipe(ialu_mem_reg);
 6137 %}
 6138 
 6139 instruct storeImmB(memory mem, immI8 src)
 6140 %{
 6141   match(Set mem (StoreB mem src));
 6142 
 6143   ins_cost(150); // XXX
 6144   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 6145   opcode(0xC6); /* C6 /0 */
 6146   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6147   ins_pipe(ialu_mem_imm);
 6148 %}
 6149 
 6150 // Store CMS card-mark Immediate
 6151 instruct storeImmCM0_reg(memory mem, immI0 zero)
 6152 %{
 6153   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6154   match(Set mem (StoreCM mem zero));
 6155 
 6156   ins_cost(125); // XXX
 6157   format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
 6158   ins_encode %{
 6159     __ movb($mem$$Address, r12);
 6160   %}
 6161   ins_pipe(ialu_mem_reg);
 6162 %}
 6163 
 6164 instruct storeImmCM0(memory mem, immI0 src)
 6165 %{
 6166   match(Set mem (StoreCM mem src));
 6167 
 6168   ins_cost(150); // XXX
 6169   format %{ &quot;movb    $mem, $src\t# CMS card-mark byte 0&quot; %}
 6170   opcode(0xC6); /* C6 /0 */
 6171   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6172   ins_pipe(ialu_mem_imm);
 6173 %}
 6174 
 6175 // Store Float
 6176 instruct storeF(memory mem, regF src)
 6177 %{
 6178   match(Set mem (StoreF mem src));
 6179 
 6180   ins_cost(95); // XXX
 6181   format %{ &quot;movss   $mem, $src\t# float&quot; %}
 6182   ins_encode %{
 6183     __ movflt($mem$$Address, $src$$XMMRegister);
 6184   %}
 6185   ins_pipe(pipe_slow); // XXX
 6186 %}
 6187 
 6188 // Store immediate Float value (it is faster than store from XMM register)
 6189 instruct storeF0(memory mem, immF0 zero)
 6190 %{
 6191   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6192   match(Set mem (StoreF mem zero));
 6193 
 6194   ins_cost(25); // XXX
 6195   format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
 6196   ins_encode %{
 6197     __ movl($mem$$Address, r12);
 6198   %}
 6199   ins_pipe(ialu_mem_reg);
 6200 %}
 6201 
 6202 instruct storeF_imm(memory mem, immF src)
 6203 %{
 6204   match(Set mem (StoreF mem src));
 6205 
 6206   ins_cost(50);
 6207   format %{ &quot;movl    $mem, $src\t# float&quot; %}
 6208   opcode(0xC7); /* C7 /0 */
 6209   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6210   ins_pipe(ialu_mem_imm);
 6211 %}
 6212 
 6213 // Store Double
 6214 instruct storeD(memory mem, regD src)
 6215 %{
 6216   match(Set mem (StoreD mem src));
 6217 
 6218   ins_cost(95); // XXX
 6219   format %{ &quot;movsd   $mem, $src\t# double&quot; %}
 6220   ins_encode %{
 6221     __ movdbl($mem$$Address, $src$$XMMRegister);
 6222   %}
 6223   ins_pipe(pipe_slow); // XXX
 6224 %}
 6225 
 6226 // Store immediate double 0.0 (it is faster than store from XMM register)
 6227 instruct storeD0_imm(memory mem, immD0 src)
 6228 %{
 6229   predicate(!UseCompressedOops || (CompressedOops::base() != NULL));
 6230   match(Set mem (StoreD mem src));
 6231 
 6232   ins_cost(50);
 6233   format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
 6234   opcode(0xC7); /* C7 /0 */
 6235   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6236   ins_pipe(ialu_mem_imm);
 6237 %}
 6238 
 6239 instruct storeD0(memory mem, immD0 zero)
 6240 %{
 6241   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL));
 6242   match(Set mem (StoreD mem zero));
 6243 
 6244   ins_cost(25); // XXX
 6245   format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
 6246   ins_encode %{
 6247     __ movq($mem$$Address, r12);
 6248   %}
 6249   ins_pipe(ialu_mem_reg);
 6250 %}
 6251 
 6252 instruct storeSSI(stackSlotI dst, rRegI src)
 6253 %{
 6254   match(Set dst src);
 6255 
 6256   ins_cost(100);
 6257   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 6258   opcode(0x89);
 6259   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 6260   ins_pipe( ialu_mem_reg );
 6261 %}
 6262 
 6263 instruct storeSSL(stackSlotL dst, rRegL src)
 6264 %{
 6265   match(Set dst src);
 6266 
 6267   ins_cost(100);
 6268   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 6269   opcode(0x89);
 6270   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6271   ins_pipe(ialu_mem_reg);
 6272 %}
 6273 
 6274 instruct storeSSP(stackSlotP dst, rRegP src)
 6275 %{
 6276   match(Set dst src);
 6277 
 6278   ins_cost(100);
 6279   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 6280   opcode(0x89);
 6281   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6282   ins_pipe(ialu_mem_reg);
 6283 %}
 6284 
 6285 instruct storeSSF(stackSlotF dst, regF src)
 6286 %{
 6287   match(Set dst src);
 6288 
 6289   ins_cost(95); // XXX
 6290   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 6291   ins_encode %{
 6292     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6293   %}
 6294   ins_pipe(pipe_slow); // XXX
 6295 %}
 6296 
 6297 instruct storeSSD(stackSlotD dst, regD src)
 6298 %{
 6299   match(Set dst src);
 6300 
 6301   ins_cost(95); // XXX
 6302   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 6303   ins_encode %{
 6304     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6305   %}
 6306   ins_pipe(pipe_slow); // XXX
 6307 %}
 6308 
 6309 instruct cacheWB(indirect addr)
 6310 %{
 6311   predicate(VM_Version::supports_data_cache_line_flush());
 6312   match(CacheWB addr);
 6313 
 6314   ins_cost(100);
 6315   format %{&quot;cache wb $addr&quot; %}
 6316   ins_encode %{
 6317     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);
 6318     assert($addr$$disp == 0, &quot;should be&quot;);
 6319     __ cache_wb(Address($addr$$base$$Register, 0));
 6320   %}
 6321   ins_pipe(pipe_slow); // XXX
 6322 %}
 6323 
 6324 instruct cacheWBPreSync()
 6325 %{
 6326   predicate(VM_Version::supports_data_cache_line_flush());
 6327   match(CacheWBPreSync);
 6328 
 6329   ins_cost(100);
 6330   format %{&quot;cache wb presync&quot; %}
 6331   ins_encode %{
 6332     __ cache_wbsync(true);
 6333   %}
 6334   ins_pipe(pipe_slow); // XXX
 6335 %}
 6336 
 6337 instruct cacheWBPostSync()
 6338 %{
 6339   predicate(VM_Version::supports_data_cache_line_flush());
 6340   match(CacheWBPostSync);
 6341 
 6342   ins_cost(100);
 6343   format %{&quot;cache wb postsync&quot; %}
 6344   ins_encode %{
 6345     __ cache_wbsync(false);
 6346   %}
 6347   ins_pipe(pipe_slow); // XXX
 6348 %}
 6349 
 6350 //----------BSWAP Instructions-------------------------------------------------
 6351 instruct bytes_reverse_int(rRegI dst) %{
 6352   match(Set dst (ReverseBytesI dst));
 6353 
 6354   format %{ &quot;bswapl  $dst&quot; %}
 6355   opcode(0x0F, 0xC8);  /*Opcode 0F /C8 */
 6356   ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );
 6357   ins_pipe( ialu_reg );
 6358 %}
 6359 
 6360 instruct bytes_reverse_long(rRegL dst) %{
 6361   match(Set dst (ReverseBytesL dst));
 6362 
 6363   format %{ &quot;bswapq  $dst&quot; %}
 6364   opcode(0x0F, 0xC8); /* Opcode 0F /C8 */
 6365   ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );
 6366   ins_pipe( ialu_reg);
 6367 %}
 6368 
 6369 instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{
 6370   match(Set dst (ReverseBytesUS dst));
 6371   effect(KILL cr);
 6372 
 6373   format %{ &quot;bswapl  $dst\n\t&quot;
 6374             &quot;shrl    $dst,16\n\t&quot; %}
 6375   ins_encode %{
 6376     __ bswapl($dst$$Register);
 6377     __ shrl($dst$$Register, 16);
 6378   %}
 6379   ins_pipe( ialu_reg );
 6380 %}
 6381 
 6382 instruct bytes_reverse_short(rRegI dst, rFlagsReg cr) %{
 6383   match(Set dst (ReverseBytesS dst));
 6384   effect(KILL cr);
 6385 
 6386   format %{ &quot;bswapl  $dst\n\t&quot;
 6387             &quot;sar     $dst,16\n\t&quot; %}
 6388   ins_encode %{
 6389     __ bswapl($dst$$Register);
 6390     __ sarl($dst$$Register, 16);
 6391   %}
 6392   ins_pipe( ialu_reg );
 6393 %}
 6394 
 6395 //---------- Zeros Count Instructions ------------------------------------------
 6396 
 6397 instruct countLeadingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6398   predicate(UseCountLeadingZerosInstruction);
 6399   match(Set dst (CountLeadingZerosI src));
 6400   effect(KILL cr);
 6401 
 6402   format %{ &quot;lzcntl  $dst, $src\t# count leading zeros (int)&quot; %}
 6403   ins_encode %{
 6404     __ lzcntl($dst$$Register, $src$$Register);
 6405   %}
 6406   ins_pipe(ialu_reg);
 6407 %}
 6408 
 6409 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, rFlagsReg cr) %{
 6410   predicate(!UseCountLeadingZerosInstruction);
 6411   match(Set dst (CountLeadingZerosI src));
 6412   effect(KILL cr);
 6413 
 6414   format %{ &quot;bsrl    $dst, $src\t# count leading zeros (int)\n\t&quot;
 6415             &quot;jnz     skip\n\t&quot;
 6416             &quot;movl    $dst, -1\n&quot;
 6417       &quot;skip:\n\t&quot;
 6418             &quot;negl    $dst\n\t&quot;
 6419             &quot;addl    $dst, 31&quot; %}
 6420   ins_encode %{
 6421     Register Rdst = $dst$$Register;
 6422     Register Rsrc = $src$$Register;
 6423     Label skip;
 6424     __ bsrl(Rdst, Rsrc);
 6425     __ jccb(Assembler::notZero, skip);
 6426     __ movl(Rdst, -1);
 6427     __ bind(skip);
 6428     __ negl(Rdst);
 6429     __ addl(Rdst, BitsPerInt - 1);
 6430   %}
 6431   ins_pipe(ialu_reg);
 6432 %}
 6433 
 6434 instruct countLeadingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6435   predicate(UseCountLeadingZerosInstruction);
 6436   match(Set dst (CountLeadingZerosL src));
 6437   effect(KILL cr);
 6438 
 6439   format %{ &quot;lzcntq  $dst, $src\t# count leading zeros (long)&quot; %}
 6440   ins_encode %{
 6441     __ lzcntq($dst$$Register, $src$$Register);
 6442   %}
 6443   ins_pipe(ialu_reg);
 6444 %}
 6445 
 6446 instruct countLeadingZerosL_bsr(rRegI dst, rRegL src, rFlagsReg cr) %{
 6447   predicate(!UseCountLeadingZerosInstruction);
 6448   match(Set dst (CountLeadingZerosL src));
 6449   effect(KILL cr);
 6450 
 6451   format %{ &quot;bsrq    $dst, $src\t# count leading zeros (long)\n\t&quot;
 6452             &quot;jnz     skip\n\t&quot;
 6453             &quot;movl    $dst, -1\n&quot;
 6454       &quot;skip:\n\t&quot;
 6455             &quot;negl    $dst\n\t&quot;
 6456             &quot;addl    $dst, 63&quot; %}
 6457   ins_encode %{
 6458     Register Rdst = $dst$$Register;
 6459     Register Rsrc = $src$$Register;
 6460     Label skip;
 6461     __ bsrq(Rdst, Rsrc);
 6462     __ jccb(Assembler::notZero, skip);
 6463     __ movl(Rdst, -1);
 6464     __ bind(skip);
 6465     __ negl(Rdst);
 6466     __ addl(Rdst, BitsPerLong - 1);
 6467   %}
 6468   ins_pipe(ialu_reg);
 6469 %}
 6470 
 6471 instruct countTrailingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6472   predicate(UseCountTrailingZerosInstruction);
 6473   match(Set dst (CountTrailingZerosI src));
 6474   effect(KILL cr);
 6475 
 6476   format %{ &quot;tzcntl    $dst, $src\t# count trailing zeros (int)&quot; %}
 6477   ins_encode %{
 6478     __ tzcntl($dst$$Register, $src$$Register);
 6479   %}
 6480   ins_pipe(ialu_reg);
 6481 %}
 6482 
 6483 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, rFlagsReg cr) %{
 6484   predicate(!UseCountTrailingZerosInstruction);
 6485   match(Set dst (CountTrailingZerosI src));
 6486   effect(KILL cr);
 6487 
 6488   format %{ &quot;bsfl    $dst, $src\t# count trailing zeros (int)\n\t&quot;
 6489             &quot;jnz     done\n\t&quot;
 6490             &quot;movl    $dst, 32\n&quot;
 6491       &quot;done:&quot; %}
 6492   ins_encode %{
 6493     Register Rdst = $dst$$Register;
 6494     Label done;
 6495     __ bsfl(Rdst, $src$$Register);
 6496     __ jccb(Assembler::notZero, done);
 6497     __ movl(Rdst, BitsPerInt);
 6498     __ bind(done);
 6499   %}
 6500   ins_pipe(ialu_reg);
 6501 %}
 6502 
 6503 instruct countTrailingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6504   predicate(UseCountTrailingZerosInstruction);
 6505   match(Set dst (CountTrailingZerosL src));
 6506   effect(KILL cr);
 6507 
 6508   format %{ &quot;tzcntq    $dst, $src\t# count trailing zeros (long)&quot; %}
 6509   ins_encode %{
 6510     __ tzcntq($dst$$Register, $src$$Register);
 6511   %}
 6512   ins_pipe(ialu_reg);
 6513 %}
 6514 
 6515 instruct countTrailingZerosL_bsf(rRegI dst, rRegL src, rFlagsReg cr) %{
 6516   predicate(!UseCountTrailingZerosInstruction);
 6517   match(Set dst (CountTrailingZerosL src));
 6518   effect(KILL cr);
 6519 
 6520   format %{ &quot;bsfq    $dst, $src\t# count trailing zeros (long)\n\t&quot;
 6521             &quot;jnz     done\n\t&quot;
 6522             &quot;movl    $dst, 64\n&quot;
 6523       &quot;done:&quot; %}
 6524   ins_encode %{
 6525     Register Rdst = $dst$$Register;
 6526     Label done;
 6527     __ bsfq(Rdst, $src$$Register);
 6528     __ jccb(Assembler::notZero, done);
 6529     __ movl(Rdst, BitsPerLong);
 6530     __ bind(done);
 6531   %}
 6532   ins_pipe(ialu_reg);
 6533 %}
 6534 
 6535 
 6536 //---------- Population Count Instructions -------------------------------------
 6537 
 6538 instruct popCountI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6539   predicate(UsePopCountInstruction);
 6540   match(Set dst (PopCountI src));
 6541   effect(KILL cr);
 6542 
 6543   format %{ &quot;popcnt  $dst, $src&quot; %}
 6544   ins_encode %{
 6545     __ popcntl($dst$$Register, $src$$Register);
 6546   %}
 6547   ins_pipe(ialu_reg);
 6548 %}
 6549 
 6550 instruct popCountI_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6551   predicate(UsePopCountInstruction);
 6552   match(Set dst (PopCountI (LoadI mem)));
 6553   effect(KILL cr);
 6554 
 6555   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6556   ins_encode %{
 6557     __ popcntl($dst$$Register, $mem$$Address);
 6558   %}
 6559   ins_pipe(ialu_reg);
 6560 %}
 6561 
 6562 // Note: Long.bitCount(long) returns an int.
 6563 instruct popCountL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6564   predicate(UsePopCountInstruction);
 6565   match(Set dst (PopCountL src));
 6566   effect(KILL cr);
 6567 
 6568   format %{ &quot;popcnt  $dst, $src&quot; %}
 6569   ins_encode %{
 6570     __ popcntq($dst$$Register, $src$$Register);
 6571   %}
 6572   ins_pipe(ialu_reg);
 6573 %}
 6574 
 6575 // Note: Long.bitCount(long) returns an int.
 6576 instruct popCountL_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6577   predicate(UsePopCountInstruction);
 6578   match(Set dst (PopCountL (LoadL mem)));
 6579   effect(KILL cr);
 6580 
 6581   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6582   ins_encode %{
 6583     __ popcntq($dst$$Register, $mem$$Address);
 6584   %}
 6585   ins_pipe(ialu_reg);
 6586 %}
 6587 
 6588 
 6589 //----------MemBar Instructions-----------------------------------------------
 6590 // Memory barrier flavors
 6591 
 6592 instruct membar_acquire()
 6593 %{
 6594   match(MemBarAcquire);
 6595   match(LoadFence);
 6596   ins_cost(0);
 6597 
 6598   size(0);
 6599   format %{ &quot;MEMBAR-acquire ! (empty encoding)&quot; %}
 6600   ins_encode();
 6601   ins_pipe(empty);
 6602 %}
 6603 
 6604 instruct membar_acquire_lock()
 6605 %{
 6606   match(MemBarAcquireLock);
 6607   ins_cost(0);
 6608 
 6609   size(0);
 6610   format %{ &quot;MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)&quot; %}
 6611   ins_encode();
 6612   ins_pipe(empty);
 6613 %}
 6614 
 6615 instruct membar_release()
 6616 %{
 6617   match(MemBarRelease);
 6618   match(StoreFence);
 6619   ins_cost(0);
 6620 
 6621   size(0);
 6622   format %{ &quot;MEMBAR-release ! (empty encoding)&quot; %}
 6623   ins_encode();
 6624   ins_pipe(empty);
 6625 %}
 6626 
 6627 instruct membar_release_lock()
 6628 %{
 6629   match(MemBarReleaseLock);
 6630   ins_cost(0);
 6631 
 6632   size(0);
 6633   format %{ &quot;MEMBAR-release (a FastUnlock follows so empty encoding)&quot; %}
 6634   ins_encode();
 6635   ins_pipe(empty);
 6636 %}
 6637 
 6638 instruct membar_volatile(rFlagsReg cr) %{
 6639   match(MemBarVolatile);
 6640   effect(KILL cr);
 6641   ins_cost(400);
 6642 
 6643   format %{
 6644     $$template
 6645     $$emit$$&quot;lock addl [rsp + #0], 0\t! membar_volatile&quot;
 6646   %}
 6647   ins_encode %{
 6648     __ membar(Assembler::StoreLoad);
 6649   %}
 6650   ins_pipe(pipe_slow);
 6651 %}
 6652 
 6653 instruct unnecessary_membar_volatile()
 6654 %{
 6655   match(MemBarVolatile);
 6656   predicate(Matcher::post_store_load_barrier(n));
 6657   ins_cost(0);
 6658 
 6659   size(0);
 6660   format %{ &quot;MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6661   ins_encode();
 6662   ins_pipe(empty);
 6663 %}
 6664 
 6665 instruct membar_storestore() %{
 6666   match(MemBarStoreStore);
 6667   ins_cost(0);
 6668 
 6669   size(0);
 6670   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6671   ins_encode( );
 6672   ins_pipe(empty);
 6673 %}
 6674 
 6675 //----------Move Instructions--------------------------------------------------
 6676 
 6677 instruct castX2P(rRegP dst, rRegL src)
 6678 %{
 6679   match(Set dst (CastX2P src));
 6680 
 6681   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6682   ins_encode %{
 6683     if ($dst$$reg != $src$$reg) {
 6684       __ movptr($dst$$Register, $src$$Register);
 6685     }
 6686   %}
 6687   ins_pipe(ialu_reg_reg); // XXX
 6688 %}
 6689 
<a name="10" id="anc10"></a>












 6690 instruct castP2X(rRegL dst, rRegP src)
 6691 %{
 6692   match(Set dst (CastP2X src));
 6693 
 6694   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6695   ins_encode %{
 6696     if ($dst$$reg != $src$$reg) {
 6697       __ movptr($dst$$Register, $src$$Register);
 6698     }
 6699   %}
 6700   ins_pipe(ialu_reg_reg); // XXX
 6701 %}
 6702 
<a name="11" id="anc11"></a>


























 6703 // Convert oop into int for vectors alignment masking
 6704 instruct convP2I(rRegI dst, rRegP src)
 6705 %{
 6706   match(Set dst (ConvL2I (CastP2X src)));
 6707 
 6708   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6709   ins_encode %{
 6710     __ movl($dst$$Register, $src$$Register);
 6711   %}
 6712   ins_pipe(ialu_reg_reg); // XXX
 6713 %}
 6714 
 6715 // Convert compressed oop into int for vectors alignment masking
 6716 // in case of 32bit oops (heap &lt; 4Gb).
 6717 instruct convN2I(rRegI dst, rRegN src)
 6718 %{
 6719   predicate(CompressedOops::shift() == 0);
 6720   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6721 
 6722   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
 6723   ins_encode %{
 6724     __ movl($dst$$Register, $src$$Register);
 6725   %}
 6726   ins_pipe(ialu_reg_reg); // XXX
 6727 %}
 6728 
 6729 // Convert oop pointer into compressed form
 6730 instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{
 6731   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 6732   match(Set dst (EncodeP src));
 6733   effect(KILL cr);
 6734   format %{ &quot;encode_heap_oop $dst,$src&quot; %}
 6735   ins_encode %{
 6736     Register s = $src$$Register;
 6737     Register d = $dst$$Register;
 6738     if (s != d) {
 6739       __ movq(d, s);
 6740     }
 6741     __ encode_heap_oop(d);
 6742   %}
 6743   ins_pipe(ialu_reg_long);
 6744 %}
 6745 
 6746 instruct encodeHeapOop_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6747   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
 6748   match(Set dst (EncodeP src));
 6749   effect(KILL cr);
 6750   format %{ &quot;encode_heap_oop_not_null $dst,$src&quot; %}
 6751   ins_encode %{
 6752     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);
 6753   %}
 6754   ins_pipe(ialu_reg_long);
 6755 %}
 6756 
 6757 instruct decodeHeapOop(rRegP dst, rRegN src, rFlagsReg cr) %{
 6758   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 6759             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::Constant);
 6760   match(Set dst (DecodeN src));
 6761   effect(KILL cr);
 6762   format %{ &quot;decode_heap_oop $dst,$src&quot; %}
 6763   ins_encode %{
 6764     Register s = $src$$Register;
 6765     Register d = $dst$$Register;
 6766     if (s != d) {
 6767       __ movq(d, s);
 6768     }
 6769     __ decode_heap_oop(d);
 6770   %}
 6771   ins_pipe(ialu_reg_long);
 6772 %}
 6773 
 6774 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6775   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
 6776             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
 6777   match(Set dst (DecodeN src));
 6778   effect(KILL cr);
 6779   format %{ &quot;decode_heap_oop_not_null $dst,$src&quot; %}
 6780   ins_encode %{
 6781     Register s = $src$$Register;
 6782     Register d = $dst$$Register;
 6783     if (s != d) {
 6784       __ decode_heap_oop_not_null(d, s);
 6785     } else {
 6786       __ decode_heap_oop_not_null(d);
 6787     }
 6788   %}
 6789   ins_pipe(ialu_reg_long);
 6790 %}
 6791 
 6792 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6793   match(Set dst (EncodePKlass src));
 6794   effect(TEMP dst, KILL cr);
 6795   format %{ &quot;encode_and_move_klass_not_null $dst,$src&quot; %}
 6796   ins_encode %{
 6797     __ encode_and_move_klass_not_null($dst$$Register, $src$$Register);
 6798   %}
 6799   ins_pipe(ialu_reg_long);
 6800 %}
 6801 
 6802 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6803   match(Set dst (DecodeNKlass src));
 6804   effect(TEMP dst, KILL cr);
 6805   format %{ &quot;decode_and_move_klass_not_null $dst,$src&quot; %}
 6806   ins_encode %{
 6807     __ decode_and_move_klass_not_null($dst$$Register, $src$$Register);
 6808   %}
 6809   ins_pipe(ialu_reg_long);
 6810 %}
 6811 
 6812 //----------Conditional Move---------------------------------------------------
 6813 // Jump
 6814 // dummy instruction for generating temp registers
 6815 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
 6816   match(Jump (LShiftL switch_val shift));
 6817   ins_cost(350);
 6818   predicate(false);
 6819   effect(TEMP dest);
 6820 
 6821   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6822             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t&quot; %}
 6823   ins_encode %{
 6824     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6825     // to do that and the compiler is using that register as one it can allocate.
 6826     // So we build it all by hand.
 6827     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
 6828     // ArrayAddress dispatch(table, index);
 6829     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
 6830     __ lea($dest$$Register, $constantaddress);
 6831     __ jmp(dispatch);
 6832   %}
 6833   ins_pipe(pipe_jmp);
 6834 %}
 6835 
 6836 instruct jumpXtnd_addr(rRegL switch_val, immI2 shift, immL32 offset, rRegI dest) %{
 6837   match(Jump (AddL (LShiftL switch_val shift) offset));
 6838   ins_cost(350);
 6839   effect(TEMP dest);
 6840 
 6841   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6842             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift + $offset]\n\t&quot; %}
 6843   ins_encode %{
 6844     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6845     // to do that and the compiler is using that register as one it can allocate.
 6846     // So we build it all by hand.
 6847     // Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6848     // ArrayAddress dispatch(table, index);
 6849     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6850     __ lea($dest$$Register, $constantaddress);
 6851     __ jmp(dispatch);
 6852   %}
 6853   ins_pipe(pipe_jmp);
 6854 %}
 6855 
 6856 instruct jumpXtnd(rRegL switch_val, rRegI dest) %{
 6857   match(Jump switch_val);
 6858   ins_cost(350);
 6859   effect(TEMP dest);
 6860 
 6861   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6862             &quot;jmp     [$dest + $switch_val]\n\t&quot; %}
 6863   ins_encode %{
 6864     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6865     // to do that and the compiler is using that register as one it can allocate.
 6866     // So we build it all by hand.
 6867     // Address index(noreg, switch_reg, Address::times_1);
 6868     // ArrayAddress dispatch(table, index);
 6869     Address dispatch($dest$$Register, $switch_val$$Register, Address::times_1);
 6870     __ lea($dest$$Register, $constantaddress);
 6871     __ jmp(dispatch);
 6872   %}
 6873   ins_pipe(pipe_jmp);
 6874 %}
 6875 
 6876 // Conditional move
 6877 instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)
 6878 %{
 6879   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6880 
 6881   ins_cost(200); // XXX
 6882   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6883   opcode(0x0F, 0x40);
 6884   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6885   ins_pipe(pipe_cmov_reg);
 6886 %}
 6887 
 6888 instruct cmovI_regU(cmpOpU cop, rFlagsRegU cr, rRegI dst, rRegI src) %{
 6889   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6890 
 6891   ins_cost(200); // XXX
 6892   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6893   opcode(0x0F, 0x40);
 6894   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6895   ins_pipe(pipe_cmov_reg);
 6896 %}
 6897 
 6898 instruct cmovI_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{
 6899   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6900   ins_cost(200);
 6901   expand %{
 6902     cmovI_regU(cop, cr, dst, src);
 6903   %}
 6904 %}
 6905 
 6906 // Conditional move
 6907 instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src) %{
 6908   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6909 
 6910   ins_cost(250); // XXX
 6911   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6912   opcode(0x0F, 0x40);
 6913   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 6914   ins_pipe(pipe_cmov_mem);
 6915 %}
 6916 
 6917 // Conditional move
 6918 instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)
 6919 %{
 6920   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6921 
 6922   ins_cost(250); // XXX
 6923   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6924   opcode(0x0F, 0x40);
 6925   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 6926   ins_pipe(pipe_cmov_mem);
 6927 %}
 6928 
 6929 instruct cmovI_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, memory src) %{
 6930   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6931   ins_cost(250);
 6932   expand %{
 6933     cmovI_memU(cop, cr, dst, src);
 6934   %}
 6935 %}
 6936 
 6937 // Conditional move
 6938 instruct cmovN_reg(rRegN dst, rRegN src, rFlagsReg cr, cmpOp cop)
 6939 %{
 6940   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6941 
 6942   ins_cost(200); // XXX
 6943   format %{ &quot;cmovl$cop $dst, $src\t# signed, compressed ptr&quot; %}
 6944   opcode(0x0F, 0x40);
 6945   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6946   ins_pipe(pipe_cmov_reg);
 6947 %}
 6948 
 6949 // Conditional move
 6950 instruct cmovN_regU(cmpOpU cop, rFlagsRegU cr, rRegN dst, rRegN src)
 6951 %{
 6952   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6953 
 6954   ins_cost(200); // XXX
 6955   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, compressed ptr&quot; %}
 6956   opcode(0x0F, 0x40);
 6957   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6958   ins_pipe(pipe_cmov_reg);
 6959 %}
 6960 
 6961 instruct cmovN_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{
 6962   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 6963   ins_cost(200);
 6964   expand %{
 6965     cmovN_regU(cop, cr, dst, src);
 6966   %}
 6967 %}
 6968 
 6969 // Conditional move
 6970 instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)
 6971 %{
 6972   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6973 
 6974   ins_cost(200); // XXX
 6975   format %{ &quot;cmovq$cop $dst, $src\t# signed, ptr&quot; %}
 6976   opcode(0x0F, 0x40);
 6977   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6978   ins_pipe(pipe_cmov_reg);  // XXX
 6979 %}
 6980 
 6981 // Conditional move
 6982 instruct cmovP_regU(cmpOpU cop, rFlagsRegU cr, rRegP dst, rRegP src)
 6983 %{
 6984   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6985 
 6986   ins_cost(200); // XXX
 6987   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, ptr&quot; %}
 6988   opcode(0x0F, 0x40);
 6989   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6990   ins_pipe(pipe_cmov_reg); // XXX
 6991 %}
 6992 
 6993 instruct cmovP_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{
 6994   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 6995   ins_cost(200);
 6996   expand %{
 6997     cmovP_regU(cop, cr, dst, src);
 6998   %}
 6999 %}
 7000 
 7001 // DISABLED: Requires the ADLC to emit a bottom_type call that
 7002 // correctly meets the two pointer arguments; one is an incoming
 7003 // register but the other is a memory operand.  ALSO appears to
 7004 // be buggy with implicit null checks.
 7005 //
 7006 //// Conditional move
 7007 //instruct cmovP_mem(cmpOp cop, rFlagsReg cr, rRegP dst, memory src)
 7008 //%{
 7009 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7010 //  ins_cost(250);
 7011 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7012 //  opcode(0x0F,0x40);
 7013 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7014 //  ins_pipe( pipe_cmov_mem );
 7015 //%}
 7016 //
 7017 //// Conditional move
 7018 //instruct cmovP_memU(cmpOpU cop, rFlagsRegU cr, rRegP dst, memory src)
 7019 //%{
 7020 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7021 //  ins_cost(250);
 7022 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7023 //  opcode(0x0F,0x40);
 7024 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7025 //  ins_pipe( pipe_cmov_mem );
 7026 //%}
 7027 
 7028 instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)
 7029 %{
 7030   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7031 
 7032   ins_cost(200); // XXX
 7033   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7034   opcode(0x0F, 0x40);
 7035   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7036   ins_pipe(pipe_cmov_reg);  // XXX
 7037 %}
 7038 
 7039 instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)
 7040 %{
 7041   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7042 
 7043   ins_cost(200); // XXX
 7044   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7045   opcode(0x0F, 0x40);
 7046   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7047   ins_pipe(pipe_cmov_mem);  // XXX
 7048 %}
 7049 
 7050 instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)
 7051 %{
 7052   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7053 
 7054   ins_cost(200); // XXX
 7055   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7056   opcode(0x0F, 0x40);
 7057   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7058   ins_pipe(pipe_cmov_reg); // XXX
 7059 %}
 7060 
 7061 instruct cmovL_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{
 7062   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7063   ins_cost(200);
 7064   expand %{
 7065     cmovL_regU(cop, cr, dst, src);
 7066   %}
 7067 %}
 7068 
 7069 instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)
 7070 %{
 7071   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7072 
 7073   ins_cost(200); // XXX
 7074   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7075   opcode(0x0F, 0x40);
 7076   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7077   ins_pipe(pipe_cmov_mem); // XXX
 7078 %}
 7079 
 7080 instruct cmovL_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, memory src) %{
 7081   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7082   ins_cost(200);
 7083   expand %{
 7084     cmovL_memU(cop, cr, dst, src);
 7085   %}
 7086 %}
 7087 
 7088 instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)
 7089 %{
 7090   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7091 
 7092   ins_cost(200); // XXX
 7093   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7094             &quot;movss     $dst, $src\n&quot;
 7095     &quot;skip:&quot; %}
 7096   ins_encode %{
 7097     Label Lskip;
 7098     // Invert sense of branch from sense of CMOV
 7099     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7100     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7101     __ bind(Lskip);
 7102   %}
 7103   ins_pipe(pipe_slow);
 7104 %}
 7105 
 7106 // instruct cmovF_mem(cmpOp cop, rFlagsReg cr, regF dst, memory src)
 7107 // %{
 7108 //   match(Set dst (CMoveF (Binary cop cr) (Binary dst (LoadL src))));
 7109 
 7110 //   ins_cost(200); // XXX
 7111 //   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7112 //             &quot;movss     $dst, $src\n&quot;
 7113 //     &quot;skip:&quot; %}
 7114 //   ins_encode(enc_cmovf_mem_branch(cop, dst, src));
 7115 //   ins_pipe(pipe_slow);
 7116 // %}
 7117 
 7118 instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)
 7119 %{
 7120   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7121 
 7122   ins_cost(200); // XXX
 7123   format %{ &quot;jn$cop    skip\t# unsigned cmove float\n\t&quot;
 7124             &quot;movss     $dst, $src\n&quot;
 7125     &quot;skip:&quot; %}
 7126   ins_encode %{
 7127     Label Lskip;
 7128     // Invert sense of branch from sense of CMOV
 7129     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7130     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7131     __ bind(Lskip);
 7132   %}
 7133   ins_pipe(pipe_slow);
 7134 %}
 7135 
 7136 instruct cmovF_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regF dst, regF src) %{
 7137   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7138   ins_cost(200);
 7139   expand %{
 7140     cmovF_regU(cop, cr, dst, src);
 7141   %}
 7142 %}
 7143 
 7144 instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)
 7145 %{
 7146   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7147 
 7148   ins_cost(200); // XXX
 7149   format %{ &quot;jn$cop    skip\t# signed cmove double\n\t&quot;
 7150             &quot;movsd     $dst, $src\n&quot;
 7151     &quot;skip:&quot; %}
 7152   ins_encode %{
 7153     Label Lskip;
 7154     // Invert sense of branch from sense of CMOV
 7155     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7156     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7157     __ bind(Lskip);
 7158   %}
 7159   ins_pipe(pipe_slow);
 7160 %}
 7161 
 7162 instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)
 7163 %{
 7164   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7165 
 7166   ins_cost(200); // XXX
 7167   format %{ &quot;jn$cop    skip\t# unsigned cmove double\n\t&quot;
 7168             &quot;movsd     $dst, $src\n&quot;
 7169     &quot;skip:&quot; %}
 7170   ins_encode %{
 7171     Label Lskip;
 7172     // Invert sense of branch from sense of CMOV
 7173     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7174     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7175     __ bind(Lskip);
 7176   %}
 7177   ins_pipe(pipe_slow);
 7178 %}
 7179 
 7180 instruct cmovD_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regD dst, regD src) %{
 7181   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7182   ins_cost(200);
 7183   expand %{
 7184     cmovD_regU(cop, cr, dst, src);
 7185   %}
 7186 %}
 7187 
 7188 //----------Arithmetic Instructions--------------------------------------------
 7189 //----------Addition Instructions----------------------------------------------
 7190 
 7191 instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 7192 %{
 7193   match(Set dst (AddI dst src));
 7194   effect(KILL cr);
 7195 
 7196   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7197   opcode(0x03);
 7198   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 7199   ins_pipe(ialu_reg_reg);
 7200 %}
 7201 
 7202 instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 7203 %{
 7204   match(Set dst (AddI dst src));
 7205   effect(KILL cr);
 7206 
 7207   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7208   opcode(0x81, 0x00); /* /0 id */
 7209   ins_encode(OpcSErm(dst, src), Con8or32(src));
 7210   ins_pipe( ialu_reg );
 7211 %}
 7212 
 7213 instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 7214 %{
 7215   match(Set dst (AddI dst (LoadI src)));
 7216   effect(KILL cr);
 7217 
 7218   ins_cost(125); // XXX
 7219   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7220   opcode(0x03);
 7221   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 7222   ins_pipe(ialu_reg_mem);
 7223 %}
 7224 
 7225 instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 7226 %{
 7227   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7228   effect(KILL cr);
 7229 
 7230   ins_cost(150); // XXX
 7231   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7232   opcode(0x01); /* Opcode 01 /r */
 7233   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 7234   ins_pipe(ialu_mem_reg);
 7235 %}
 7236 
 7237 instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)
 7238 %{
 7239   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7240   effect(KILL cr);
 7241 
 7242   ins_cost(125); // XXX
 7243   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7244   opcode(0x81); /* Opcode 81 /0 id */
 7245   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7246   ins_pipe(ialu_mem_imm);
 7247 %}
 7248 
 7249 instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
 7250 %{
 7251   predicate(UseIncDec);
 7252   match(Set dst (AddI dst src));
 7253   effect(KILL cr);
 7254 
 7255   format %{ &quot;incl    $dst\t# int&quot; %}
 7256   opcode(0xFF, 0x00); // FF /0
 7257   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7258   ins_pipe(ialu_reg);
 7259 %}
 7260 
 7261 instruct incI_mem(memory dst, immI1 src, rFlagsReg cr)
 7262 %{
 7263   predicate(UseIncDec);
 7264   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7265   effect(KILL cr);
 7266 
 7267   ins_cost(125); // XXX
 7268   format %{ &quot;incl    $dst\t# int&quot; %}
 7269   opcode(0xFF); /* Opcode FF /0 */
 7270   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x00, dst));
 7271   ins_pipe(ialu_mem_imm);
 7272 %}
 7273 
 7274 // XXX why does that use AddI
 7275 instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr)
 7276 %{
 7277   predicate(UseIncDec);
 7278   match(Set dst (AddI dst src));
 7279   effect(KILL cr);
 7280 
 7281   format %{ &quot;decl    $dst\t# int&quot; %}
 7282   opcode(0xFF, 0x01); // FF /1
 7283   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7284   ins_pipe(ialu_reg);
 7285 %}
 7286 
 7287 // XXX why does that use AddI
 7288 instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)
 7289 %{
 7290   predicate(UseIncDec);
 7291   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7292   effect(KILL cr);
 7293 
 7294   ins_cost(125); // XXX
 7295   format %{ &quot;decl    $dst\t# int&quot; %}
 7296   opcode(0xFF); /* Opcode FF /1 */
 7297   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x01, dst));
 7298   ins_pipe(ialu_mem_imm);
 7299 %}
 7300 
 7301 instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)
 7302 %{
 7303   match(Set dst (AddI src0 src1));
 7304 
 7305   ins_cost(110);
 7306   format %{ &quot;addr32 leal $dst, [$src0 + $src1]\t# int&quot; %}
 7307   opcode(0x8D); /* 0x8D /r */
 7308   ins_encode(Opcode(0x67), REX_reg_reg(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7309   ins_pipe(ialu_reg_reg);
 7310 %}
 7311 
 7312 instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 7313 %{
 7314   match(Set dst (AddL dst src));
 7315   effect(KILL cr);
 7316 
 7317   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7318   opcode(0x03);
 7319   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7320   ins_pipe(ialu_reg_reg);
 7321 %}
 7322 
 7323 instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 7324 %{
 7325   match(Set dst (AddL dst src));
 7326   effect(KILL cr);
 7327 
 7328   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7329   opcode(0x81, 0x00); /* /0 id */
 7330   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7331   ins_pipe( ialu_reg );
 7332 %}
 7333 
 7334 instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 7335 %{
 7336   match(Set dst (AddL dst (LoadL src)));
 7337   effect(KILL cr);
 7338 
 7339   ins_cost(125); // XXX
 7340   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7341   opcode(0x03);
 7342   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 7343   ins_pipe(ialu_reg_mem);
 7344 %}
 7345 
 7346 instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 7347 %{
 7348   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7349   effect(KILL cr);
 7350 
 7351   ins_cost(150); // XXX
 7352   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7353   opcode(0x01); /* Opcode 01 /r */
 7354   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 7355   ins_pipe(ialu_mem_reg);
 7356 %}
 7357 
 7358 instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 7359 %{
 7360   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7361   effect(KILL cr);
 7362 
 7363   ins_cost(125); // XXX
 7364   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7365   opcode(0x81); /* Opcode 81 /0 id */
 7366   ins_encode(REX_mem_wide(dst),
 7367              OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7368   ins_pipe(ialu_mem_imm);
 7369 %}
 7370 
 7371 instruct incL_rReg(rRegI dst, immL1 src, rFlagsReg cr)
 7372 %{
 7373   predicate(UseIncDec);
 7374   match(Set dst (AddL dst src));
 7375   effect(KILL cr);
 7376 
 7377   format %{ &quot;incq    $dst\t# long&quot; %}
 7378   opcode(0xFF, 0x00); // FF /0
 7379   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7380   ins_pipe(ialu_reg);
 7381 %}
 7382 
 7383 instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)
 7384 %{
 7385   predicate(UseIncDec);
 7386   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7387   effect(KILL cr);
 7388 
 7389   ins_cost(125); // XXX
 7390   format %{ &quot;incq    $dst\t# long&quot; %}
 7391   opcode(0xFF); /* Opcode FF /0 */
 7392   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x00, dst));
 7393   ins_pipe(ialu_mem_imm);
 7394 %}
 7395 
 7396 // XXX why does that use AddL
 7397 instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr)
 7398 %{
 7399   predicate(UseIncDec);
 7400   match(Set dst (AddL dst src));
 7401   effect(KILL cr);
 7402 
 7403   format %{ &quot;decq    $dst\t# long&quot; %}
 7404   opcode(0xFF, 0x01); // FF /1
 7405   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7406   ins_pipe(ialu_reg);
 7407 %}
 7408 
 7409 // XXX why does that use AddL
 7410 instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)
 7411 %{
 7412   predicate(UseIncDec);
 7413   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7414   effect(KILL cr);
 7415 
 7416   ins_cost(125); // XXX
 7417   format %{ &quot;decq    $dst\t# long&quot; %}
 7418   opcode(0xFF); /* Opcode FF /1 */
 7419   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x01, dst));
 7420   ins_pipe(ialu_mem_imm);
 7421 %}
 7422 
 7423 instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)
 7424 %{
 7425   match(Set dst (AddL src0 src1));
 7426 
 7427   ins_cost(110);
 7428   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# long&quot; %}
 7429   opcode(0x8D); /* 0x8D /r */
 7430   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7431   ins_pipe(ialu_reg_reg);
 7432 %}
 7433 
 7434 instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)
 7435 %{
 7436   match(Set dst (AddP dst src));
 7437   effect(KILL cr);
 7438 
 7439   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7440   opcode(0x03);
 7441   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7442   ins_pipe(ialu_reg_reg);
 7443 %}
 7444 
 7445 instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)
 7446 %{
 7447   match(Set dst (AddP dst src));
 7448   effect(KILL cr);
 7449 
 7450   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7451   opcode(0x81, 0x00); /* /0 id */
 7452   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7453   ins_pipe( ialu_reg );
 7454 %}
 7455 
 7456 // XXX addP mem ops ????
 7457 
 7458 instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)
 7459 %{
 7460   match(Set dst (AddP src0 src1));
 7461 
 7462   ins_cost(110);
 7463   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# ptr&quot; %}
 7464   opcode(0x8D); /* 0x8D /r */
 7465   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1));// XXX
 7466   ins_pipe(ialu_reg_reg);
 7467 %}
 7468 
 7469 instruct checkCastPP(rRegP dst)
 7470 %{
 7471   match(Set dst (CheckCastPP dst));
 7472 
 7473   size(0);
 7474   format %{ &quot;# checkcastPP of $dst&quot; %}
 7475   ins_encode(/* empty encoding */);
 7476   ins_pipe(empty);
 7477 %}
 7478 
 7479 instruct castPP(rRegP dst)
 7480 %{
 7481   match(Set dst (CastPP dst));
 7482 
 7483   size(0);
 7484   format %{ &quot;# castPP of $dst&quot; %}
 7485   ins_encode(/* empty encoding */);
 7486   ins_pipe(empty);
 7487 %}
 7488 
 7489 instruct castII(rRegI dst)
 7490 %{
 7491   match(Set dst (CastII dst));
 7492 
 7493   size(0);
 7494   format %{ &quot;# castII of $dst&quot; %}
 7495   ins_encode(/* empty encoding */);
 7496   ins_cost(0);
 7497   ins_pipe(empty);
 7498 %}
 7499 
 7500 // LoadP-locked same as a regular LoadP when used with compare-swap
 7501 instruct loadPLocked(rRegP dst, memory mem)
 7502 %{
 7503   match(Set dst (LoadPLocked mem));
 7504 
 7505   ins_cost(125); // XXX
 7506   format %{ &quot;movq    $dst, $mem\t# ptr locked&quot; %}
 7507   opcode(0x8B);
 7508   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 7509   ins_pipe(ialu_reg_mem); // XXX
 7510 %}
 7511 
 7512 // Conditional-store of the updated heap-top.
 7513 // Used during allocation of the shared heap.
 7514 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7515 
 7516 instruct storePConditional(memory heap_top_ptr,
 7517                            rax_RegP oldval, rRegP newval,
 7518                            rFlagsReg cr)
 7519 %{
 7520   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7521   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7522 
 7523   format %{ &quot;cmpxchgq $heap_top_ptr, $newval\t# (ptr) &quot;
 7524             &quot;If rax == $heap_top_ptr then store $newval into $heap_top_ptr&quot; %}
 7525   opcode(0x0F, 0xB1);
 7526   ins_encode(lock_prefix,
 7527              REX_reg_mem_wide(newval, heap_top_ptr),
 7528              OpcP, OpcS,
 7529              reg_mem(newval, heap_top_ptr));
 7530   ins_pipe(pipe_cmpxchg);
 7531 %}
 7532 
 7533 // Conditional-store of an int value.
 7534 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7535 instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)
 7536 %{
 7537   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7538   effect(KILL oldval);
 7539 
 7540   format %{ &quot;cmpxchgl $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7541   opcode(0x0F, 0xB1);
 7542   ins_encode(lock_prefix,
 7543              REX_reg_mem(newval, mem),
 7544              OpcP, OpcS,
 7545              reg_mem(newval, mem));
 7546   ins_pipe(pipe_cmpxchg);
 7547 %}
 7548 
 7549 // Conditional-store of a long value.
 7550 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7551 instruct storeLConditional(memory mem, rax_RegL oldval, rRegL newval, rFlagsReg cr)
 7552 %{
 7553   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7554   effect(KILL oldval);
 7555 
 7556   format %{ &quot;cmpxchgq $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7557   opcode(0x0F, 0xB1);
 7558   ins_encode(lock_prefix,
 7559              REX_reg_mem_wide(newval, mem),
 7560              OpcP, OpcS,
 7561              reg_mem(newval, mem));
 7562   ins_pipe(pipe_cmpxchg);
 7563 %}
 7564 
 7565 
 7566 // XXX No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7567 instruct compareAndSwapP(rRegI res,
 7568                          memory mem_ptr,
 7569                          rax_RegP oldval, rRegP newval,
 7570                          rFlagsReg cr)
 7571 %{
 7572   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7573   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7574   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7575   effect(KILL cr, KILL oldval);
 7576 
 7577   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7578             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7579             &quot;sete    $res\n\t&quot;
 7580             &quot;movzbl  $res, $res&quot; %}
 7581   opcode(0x0F, 0xB1);
 7582   ins_encode(lock_prefix,
 7583              REX_reg_mem_wide(newval, mem_ptr),
 7584              OpcP, OpcS,
 7585              reg_mem(newval, mem_ptr),
 7586              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7587              REX_reg_breg(res, res), // movzbl
 7588              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7589   ins_pipe( pipe_cmpxchg );
 7590 %}
 7591 
 7592 instruct compareAndSwapL(rRegI res,
 7593                          memory mem_ptr,
 7594                          rax_RegL oldval, rRegL newval,
 7595                          rFlagsReg cr)
 7596 %{
 7597   predicate(VM_Version::supports_cx8());
 7598   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 7599   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 7600   effect(KILL cr, KILL oldval);
 7601 
 7602   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7603             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7604             &quot;sete    $res\n\t&quot;
 7605             &quot;movzbl  $res, $res&quot; %}
 7606   opcode(0x0F, 0xB1);
 7607   ins_encode(lock_prefix,
 7608              REX_reg_mem_wide(newval, mem_ptr),
 7609              OpcP, OpcS,
 7610              reg_mem(newval, mem_ptr),
 7611              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7612              REX_reg_breg(res, res), // movzbl
 7613              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7614   ins_pipe( pipe_cmpxchg );
 7615 %}
 7616 
 7617 instruct compareAndSwapI(rRegI res,
 7618                          memory mem_ptr,
 7619                          rax_RegI oldval, rRegI newval,
 7620                          rFlagsReg cr)
 7621 %{
 7622   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 7623   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 7624   effect(KILL cr, KILL oldval);
 7625 
 7626   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7627             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7628             &quot;sete    $res\n\t&quot;
 7629             &quot;movzbl  $res, $res&quot; %}
 7630   opcode(0x0F, 0xB1);
 7631   ins_encode(lock_prefix,
 7632              REX_reg_mem(newval, mem_ptr),
 7633              OpcP, OpcS,
 7634              reg_mem(newval, mem_ptr),
 7635              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7636              REX_reg_breg(res, res), // movzbl
 7637              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7638   ins_pipe( pipe_cmpxchg );
 7639 %}
 7640 
 7641 instruct compareAndSwapB(rRegI res,
 7642                          memory mem_ptr,
 7643                          rax_RegI oldval, rRegI newval,
 7644                          rFlagsReg cr)
 7645 %{
 7646   match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));
 7647   match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));
 7648   effect(KILL cr, KILL oldval);
 7649 
 7650   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7651             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7652             &quot;sete    $res\n\t&quot;
 7653             &quot;movzbl  $res, $res&quot; %}
 7654   opcode(0x0F, 0xB0);
 7655   ins_encode(lock_prefix,
 7656              REX_breg_mem(newval, mem_ptr),
 7657              OpcP, OpcS,
 7658              reg_mem(newval, mem_ptr),
 7659              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7660              REX_reg_breg(res, res), // movzbl
 7661              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7662   ins_pipe( pipe_cmpxchg );
 7663 %}
 7664 
 7665 instruct compareAndSwapS(rRegI res,
 7666                          memory mem_ptr,
 7667                          rax_RegI oldval, rRegI newval,
 7668                          rFlagsReg cr)
 7669 %{
 7670   match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));
 7671   match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));
 7672   effect(KILL cr, KILL oldval);
 7673 
 7674   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7675             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7676             &quot;sete    $res\n\t&quot;
 7677             &quot;movzbl  $res, $res&quot; %}
 7678   opcode(0x0F, 0xB1);
 7679   ins_encode(lock_prefix,
 7680              SizePrefix,
 7681              REX_reg_mem(newval, mem_ptr),
 7682              OpcP, OpcS,
 7683              reg_mem(newval, mem_ptr),
 7684              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7685              REX_reg_breg(res, res), // movzbl
 7686              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7687   ins_pipe( pipe_cmpxchg );
 7688 %}
 7689 
 7690 instruct compareAndSwapN(rRegI res,
 7691                           memory mem_ptr,
 7692                           rax_RegN oldval, rRegN newval,
 7693                           rFlagsReg cr) %{
 7694   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 7695   match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));
 7696   effect(KILL cr, KILL oldval);
 7697 
 7698   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7699             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7700             &quot;sete    $res\n\t&quot;
 7701             &quot;movzbl  $res, $res&quot; %}
 7702   opcode(0x0F, 0xB1);
 7703   ins_encode(lock_prefix,
 7704              REX_reg_mem(newval, mem_ptr),
 7705              OpcP, OpcS,
 7706              reg_mem(newval, mem_ptr),
 7707              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7708              REX_reg_breg(res, res), // movzbl
 7709              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7710   ins_pipe( pipe_cmpxchg );
 7711 %}
 7712 
 7713 instruct compareAndExchangeB(
 7714                          memory mem_ptr,
 7715                          rax_RegI oldval, rRegI newval,
 7716                          rFlagsReg cr)
 7717 %{
 7718   match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));
 7719   effect(KILL cr);
 7720 
 7721   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7722             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7723   opcode(0x0F, 0xB0);
 7724   ins_encode(lock_prefix,
 7725              REX_breg_mem(newval, mem_ptr),
 7726              OpcP, OpcS,
 7727              reg_mem(newval, mem_ptr) // lock cmpxchg
 7728              );
 7729   ins_pipe( pipe_cmpxchg );
 7730 %}
 7731 
 7732 instruct compareAndExchangeS(
 7733                          memory mem_ptr,
 7734                          rax_RegI oldval, rRegI newval,
 7735                          rFlagsReg cr)
 7736 %{
 7737   match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));
 7738   effect(KILL cr);
 7739 
 7740   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7741             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7742   opcode(0x0F, 0xB1);
 7743   ins_encode(lock_prefix,
 7744              SizePrefix,
 7745              REX_reg_mem(newval, mem_ptr),
 7746              OpcP, OpcS,
 7747              reg_mem(newval, mem_ptr) // lock cmpxchg
 7748              );
 7749   ins_pipe( pipe_cmpxchg );
 7750 %}
 7751 
 7752 instruct compareAndExchangeI(
 7753                          memory mem_ptr,
 7754                          rax_RegI oldval, rRegI newval,
 7755                          rFlagsReg cr)
 7756 %{
 7757   match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7758   effect(KILL cr);
 7759 
 7760   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7761             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7762   opcode(0x0F, 0xB1);
 7763   ins_encode(lock_prefix,
 7764              REX_reg_mem(newval, mem_ptr),
 7765              OpcP, OpcS,
 7766              reg_mem(newval, mem_ptr) // lock cmpxchg
 7767              );
 7768   ins_pipe( pipe_cmpxchg );
 7769 %}
 7770 
 7771 instruct compareAndExchangeL(
 7772                          memory mem_ptr,
 7773                          rax_RegL oldval, rRegL newval,
 7774                          rFlagsReg cr)
 7775 %{
 7776   predicate(VM_Version::supports_cx8());
 7777   match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7778   effect(KILL cr);
 7779 
 7780   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7781             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7782   opcode(0x0F, 0xB1);
 7783   ins_encode(lock_prefix,
 7784              REX_reg_mem_wide(newval, mem_ptr),
 7785              OpcP, OpcS,
 7786              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7787             );
 7788   ins_pipe( pipe_cmpxchg );
 7789 %}
 7790 
 7791 instruct compareAndExchangeN(
 7792                           memory mem_ptr,
 7793                           rax_RegN oldval, rRegN newval,
 7794                           rFlagsReg cr) %{
 7795   match(Set oldval (CompareAndExchangeN mem_ptr (Binary oldval newval)));
 7796   effect(KILL cr);
 7797 
 7798   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7799             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7800   opcode(0x0F, 0xB1);
 7801   ins_encode(lock_prefix,
 7802              REX_reg_mem(newval, mem_ptr),
 7803              OpcP, OpcS,
 7804              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7805           );
 7806   ins_pipe( pipe_cmpxchg );
 7807 %}
 7808 
 7809 instruct compareAndExchangeP(
 7810                          memory mem_ptr,
 7811                          rax_RegP oldval, rRegP newval,
 7812                          rFlagsReg cr)
 7813 %{
 7814   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7815   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7816   effect(KILL cr);
 7817 
 7818   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7819             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7820   opcode(0x0F, 0xB1);
 7821   ins_encode(lock_prefix,
 7822              REX_reg_mem_wide(newval, mem_ptr),
 7823              OpcP, OpcS,
 7824              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7825           );
 7826   ins_pipe( pipe_cmpxchg );
 7827 %}
 7828 
 7829 instruct xaddB_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7830   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7831   match(Set dummy (GetAndAddB mem add));
 7832   effect(KILL cr);
 7833   format %{ &quot;ADDB  [$mem],$add&quot; %}
 7834   ins_encode %{
 7835     __ lock();
 7836     __ addb($mem$$Address, $add$$constant);
 7837   %}
 7838   ins_pipe( pipe_cmpxchg );
 7839 %}
 7840 
 7841 instruct xaddB( memory mem, rRegI newval, rFlagsReg cr) %{
 7842   match(Set newval (GetAndAddB mem newval));
 7843   effect(KILL cr);
 7844   format %{ &quot;XADDB  [$mem],$newval&quot; %}
 7845   ins_encode %{
 7846     __ lock();
 7847     __ xaddb($mem$$Address, $newval$$Register);
 7848   %}
 7849   ins_pipe( pipe_cmpxchg );
 7850 %}
 7851 
 7852 instruct xaddS_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7853   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7854   match(Set dummy (GetAndAddS mem add));
 7855   effect(KILL cr);
 7856   format %{ &quot;ADDW  [$mem],$add&quot; %}
 7857   ins_encode %{
 7858     __ lock();
 7859     __ addw($mem$$Address, $add$$constant);
 7860   %}
 7861   ins_pipe( pipe_cmpxchg );
 7862 %}
 7863 
 7864 instruct xaddS( memory mem, rRegI newval, rFlagsReg cr) %{
 7865   match(Set newval (GetAndAddS mem newval));
 7866   effect(KILL cr);
 7867   format %{ &quot;XADDW  [$mem],$newval&quot; %}
 7868   ins_encode %{
 7869     __ lock();
 7870     __ xaddw($mem$$Address, $newval$$Register);
 7871   %}
 7872   ins_pipe( pipe_cmpxchg );
 7873 %}
 7874 
 7875 instruct xaddI_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7876   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7877   match(Set dummy (GetAndAddI mem add));
 7878   effect(KILL cr);
 7879   format %{ &quot;ADDL  [$mem],$add&quot; %}
 7880   ins_encode %{
 7881     __ lock();
 7882     __ addl($mem$$Address, $add$$constant);
 7883   %}
 7884   ins_pipe( pipe_cmpxchg );
 7885 %}
 7886 
 7887 instruct xaddI( memory mem, rRegI newval, rFlagsReg cr) %{
 7888   match(Set newval (GetAndAddI mem newval));
 7889   effect(KILL cr);
 7890   format %{ &quot;XADDL  [$mem],$newval&quot; %}
 7891   ins_encode %{
 7892     __ lock();
 7893     __ xaddl($mem$$Address, $newval$$Register);
 7894   %}
 7895   ins_pipe( pipe_cmpxchg );
 7896 %}
 7897 
 7898 instruct xaddL_no_res( memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{
 7899   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7900   match(Set dummy (GetAndAddL mem add));
 7901   effect(KILL cr);
 7902   format %{ &quot;ADDQ  [$mem],$add&quot; %}
 7903   ins_encode %{
 7904     __ lock();
 7905     __ addq($mem$$Address, $add$$constant);
 7906   %}
 7907   ins_pipe( pipe_cmpxchg );
 7908 %}
 7909 
 7910 instruct xaddL( memory mem, rRegL newval, rFlagsReg cr) %{
 7911   match(Set newval (GetAndAddL mem newval));
 7912   effect(KILL cr);
 7913   format %{ &quot;XADDQ  [$mem],$newval&quot; %}
 7914   ins_encode %{
 7915     __ lock();
 7916     __ xaddq($mem$$Address, $newval$$Register);
 7917   %}
 7918   ins_pipe( pipe_cmpxchg );
 7919 %}
 7920 
 7921 instruct xchgB( memory mem, rRegI newval) %{
 7922   match(Set newval (GetAndSetB mem newval));
 7923   format %{ &quot;XCHGB  $newval,[$mem]&quot; %}
 7924   ins_encode %{
 7925     __ xchgb($newval$$Register, $mem$$Address);
 7926   %}
 7927   ins_pipe( pipe_cmpxchg );
 7928 %}
 7929 
 7930 instruct xchgS( memory mem, rRegI newval) %{
 7931   match(Set newval (GetAndSetS mem newval));
 7932   format %{ &quot;XCHGW  $newval,[$mem]&quot; %}
 7933   ins_encode %{
 7934     __ xchgw($newval$$Register, $mem$$Address);
 7935   %}
 7936   ins_pipe( pipe_cmpxchg );
 7937 %}
 7938 
 7939 instruct xchgI( memory mem, rRegI newval) %{
 7940   match(Set newval (GetAndSetI mem newval));
 7941   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7942   ins_encode %{
 7943     __ xchgl($newval$$Register, $mem$$Address);
 7944   %}
 7945   ins_pipe( pipe_cmpxchg );
 7946 %}
 7947 
 7948 instruct xchgL( memory mem, rRegL newval) %{
 7949   match(Set newval (GetAndSetL mem newval));
 7950   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 7951   ins_encode %{
 7952     __ xchgq($newval$$Register, $mem$$Address);
 7953   %}
 7954   ins_pipe( pipe_cmpxchg );
 7955 %}
 7956 
 7957 instruct xchgP( memory mem, rRegP newval) %{
 7958   match(Set newval (GetAndSetP mem newval));
 7959   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7960   format %{ &quot;XCHGQ  $newval,[$mem]&quot; %}
 7961   ins_encode %{
 7962     __ xchgq($newval$$Register, $mem$$Address);
 7963   %}
 7964   ins_pipe( pipe_cmpxchg );
 7965 %}
 7966 
 7967 instruct xchgN( memory mem, rRegN newval) %{
 7968   match(Set newval (GetAndSetN mem newval));
 7969   format %{ &quot;XCHGL  $newval,$mem]&quot; %}
 7970   ins_encode %{
 7971     __ xchgl($newval$$Register, $mem$$Address);
 7972   %}
 7973   ins_pipe( pipe_cmpxchg );
 7974 %}
 7975 
 7976 //----------Abs Instructions-------------------------------------------
 7977 
 7978 // Integer Absolute Instructions
 7979 instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, rFlagsReg cr)
 7980 %{
 7981   match(Set dst (AbsI src));
 7982   effect(TEMP dst, TEMP tmp, KILL cr);
 7983   format %{ &quot;movl $tmp, $src\n\t&quot;
 7984             &quot;sarl $tmp, 31\n\t&quot;
 7985             &quot;movl $dst, $src\n\t&quot;
 7986             &quot;xorl $dst, $tmp\n\t&quot;
 7987             &quot;subl $dst, $tmp\n&quot;
 7988           %}
 7989   ins_encode %{
 7990     __ movl($tmp$$Register, $src$$Register);
 7991     __ sarl($tmp$$Register, 31);
 7992     __ movl($dst$$Register, $src$$Register);
 7993     __ xorl($dst$$Register, $tmp$$Register);
 7994     __ subl($dst$$Register, $tmp$$Register);
 7995   %}
 7996 
 7997   ins_pipe(ialu_reg_reg);
 7998 %}
 7999 
 8000 // Long Absolute Instructions
 8001 instruct absL_rReg(rRegL dst, rRegL src, rRegL tmp, rFlagsReg cr)
 8002 %{
 8003   match(Set dst (AbsL src));
 8004   effect(TEMP dst, TEMP tmp, KILL cr);
 8005   format %{ &quot;movq $tmp, $src\n\t&quot;
 8006             &quot;sarq $tmp, 63\n\t&quot;
 8007             &quot;movq $dst, $src\n\t&quot;
 8008             &quot;xorq $dst, $tmp\n\t&quot;
 8009             &quot;subq $dst, $tmp\n&quot;
 8010           %}
 8011   ins_encode %{
 8012     __ movq($tmp$$Register, $src$$Register);
 8013     __ sarq($tmp$$Register, 63);
 8014     __ movq($dst$$Register, $src$$Register);
 8015     __ xorq($dst$$Register, $tmp$$Register);
 8016     __ subq($dst$$Register, $tmp$$Register);
 8017   %}
 8018 
 8019   ins_pipe(ialu_reg_reg);
 8020 %}
 8021 
 8022 //----------Subtraction Instructions-------------------------------------------
 8023 
 8024 // Integer Subtraction Instructions
 8025 instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8026 %{
 8027   match(Set dst (SubI dst src));
 8028   effect(KILL cr);
 8029 
 8030   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8031   opcode(0x2B);
 8032   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 8033   ins_pipe(ialu_reg_reg);
 8034 %}
 8035 
 8036 instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 8037 %{
 8038   match(Set dst (SubI dst src));
 8039   effect(KILL cr);
 8040 
 8041   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8042   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8043   ins_encode(OpcSErm(dst, src), Con8or32(src));
 8044   ins_pipe(ialu_reg);
 8045 %}
 8046 
 8047 instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 8048 %{
 8049   match(Set dst (SubI dst (LoadI src)));
 8050   effect(KILL cr);
 8051 
 8052   ins_cost(125);
 8053   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8054   opcode(0x2B);
 8055   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 8056   ins_pipe(ialu_reg_mem);
 8057 %}
 8058 
 8059 instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 8060 %{
 8061   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8062   effect(KILL cr);
 8063 
 8064   ins_cost(150);
 8065   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8066   opcode(0x29); /* Opcode 29 /r */
 8067   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 8068   ins_pipe(ialu_mem_reg);
 8069 %}
 8070 
 8071 instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)
 8072 %{
 8073   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8074   effect(KILL cr);
 8075 
 8076   ins_cost(125); // XXX
 8077   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8078   opcode(0x81); /* Opcode 81 /5 id */
 8079   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8080   ins_pipe(ialu_mem_imm);
 8081 %}
 8082 
 8083 instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8084 %{
 8085   match(Set dst (SubL dst src));
 8086   effect(KILL cr);
 8087 
 8088   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8089   opcode(0x2B);
 8090   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8091   ins_pipe(ialu_reg_reg);
 8092 %}
 8093 
 8094 instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)
 8095 %{
 8096   match(Set dst (SubL dst src));
 8097   effect(KILL cr);
 8098 
 8099   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8100   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8101   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 8102   ins_pipe(ialu_reg);
 8103 %}
 8104 
 8105 instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 8106 %{
 8107   match(Set dst (SubL dst (LoadL src)));
 8108   effect(KILL cr);
 8109 
 8110   ins_cost(125);
 8111   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8112   opcode(0x2B);
 8113   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 8114   ins_pipe(ialu_reg_mem);
 8115 %}
 8116 
 8117 instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 8118 %{
 8119   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8120   effect(KILL cr);
 8121 
 8122   ins_cost(150);
 8123   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8124   opcode(0x29); /* Opcode 29 /r */
 8125   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 8126   ins_pipe(ialu_mem_reg);
 8127 %}
 8128 
 8129 instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 8130 %{
 8131   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8132   effect(KILL cr);
 8133 
 8134   ins_cost(125); // XXX
 8135   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8136   opcode(0x81); /* Opcode 81 /5 id */
 8137   ins_encode(REX_mem_wide(dst),
 8138              OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8139   ins_pipe(ialu_mem_imm);
 8140 %}
 8141 
 8142 // Subtract from a pointer
 8143 // XXX hmpf???
 8144 instruct subP_rReg(rRegP dst, rRegI src, immI0 zero, rFlagsReg cr)
 8145 %{
 8146   match(Set dst (AddP dst (SubI zero src)));
 8147   effect(KILL cr);
 8148 
 8149   format %{ &quot;subq    $dst, $src\t# ptr - int&quot; %}
 8150   opcode(0x2B);
 8151   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8152   ins_pipe(ialu_reg_reg);
 8153 %}
 8154 
 8155 instruct negI_rReg(rRegI dst, immI0 zero, rFlagsReg cr)
 8156 %{
 8157   match(Set dst (SubI zero dst));
 8158   effect(KILL cr);
 8159 
 8160   format %{ &quot;negl    $dst\t# int&quot; %}
 8161   opcode(0xF7, 0x03);  // Opcode F7 /3
 8162   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8163   ins_pipe(ialu_reg);
 8164 %}
 8165 
 8166 instruct negI_mem(memory dst, immI0 zero, rFlagsReg cr)
 8167 %{
 8168   match(Set dst (StoreI dst (SubI zero (LoadI dst))));
 8169   effect(KILL cr);
 8170 
 8171   format %{ &quot;negl    $dst\t# int&quot; %}
 8172   opcode(0xF7, 0x03);  // Opcode F7 /3
 8173   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8174   ins_pipe(ialu_reg);
 8175 %}
 8176 
 8177 instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)
 8178 %{
 8179   match(Set dst (SubL zero dst));
 8180   effect(KILL cr);
 8181 
 8182   format %{ &quot;negq    $dst\t# long&quot; %}
 8183   opcode(0xF7, 0x03);  // Opcode F7 /3
 8184   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8185   ins_pipe(ialu_reg);
 8186 %}
 8187 
 8188 instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)
 8189 %{
 8190   match(Set dst (StoreL dst (SubL zero (LoadL dst))));
 8191   effect(KILL cr);
 8192 
 8193   format %{ &quot;negq    $dst\t# long&quot; %}
 8194   opcode(0xF7, 0x03);  // Opcode F7 /3
 8195   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8196   ins_pipe(ialu_reg);
 8197 %}
 8198 
 8199 //----------Multiplication/Division Instructions-------------------------------
 8200 // Integer Multiplication Instructions
 8201 // Multiply Register
 8202 
 8203 instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8204 %{
 8205   match(Set dst (MulI dst src));
 8206   effect(KILL cr);
 8207 
 8208   ins_cost(300);
 8209   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8210   opcode(0x0F, 0xAF);
 8211   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8212   ins_pipe(ialu_reg_reg_alu0);
 8213 %}
 8214 
 8215 instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)
 8216 %{
 8217   match(Set dst (MulI src imm));
 8218   effect(KILL cr);
 8219 
 8220   ins_cost(300);
 8221   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8222   opcode(0x69); /* 69 /r id */
 8223   ins_encode(REX_reg_reg(dst, src),
 8224              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8225   ins_pipe(ialu_reg_reg_alu0);
 8226 %}
 8227 
 8228 instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)
 8229 %{
 8230   match(Set dst (MulI dst (LoadI src)));
 8231   effect(KILL cr);
 8232 
 8233   ins_cost(350);
 8234   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8235   opcode(0x0F, 0xAF);
 8236   ins_encode(REX_reg_mem(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8237   ins_pipe(ialu_reg_mem_alu0);
 8238 %}
 8239 
 8240 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)
 8241 %{
 8242   match(Set dst (MulI (LoadI src) imm));
 8243   effect(KILL cr);
 8244 
 8245   ins_cost(300);
 8246   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8247   opcode(0x69); /* 69 /r id */
 8248   ins_encode(REX_reg_mem(dst, src),
 8249              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8250   ins_pipe(ialu_reg_mem_alu0);
 8251 %}
 8252 
 8253 instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, rFlagsReg cr)
 8254 %{
 8255   match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));
 8256   effect(KILL cr, KILL src2);
 8257 
 8258   expand %{ mulI_rReg(dst, src1, cr);
 8259            mulI_rReg(src2, src3, cr);
 8260            addI_rReg(dst, src2, cr); %}
 8261 %}
 8262 
 8263 instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8264 %{
 8265   match(Set dst (MulL dst src));
 8266   effect(KILL cr);
 8267 
 8268   ins_cost(300);
 8269   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8270   opcode(0x0F, 0xAF);
 8271   ins_encode(REX_reg_reg_wide(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8272   ins_pipe(ialu_reg_reg_alu0);
 8273 %}
 8274 
 8275 instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)
 8276 %{
 8277   match(Set dst (MulL src imm));
 8278   effect(KILL cr);
 8279 
 8280   ins_cost(300);
 8281   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8282   opcode(0x69); /* 69 /r id */
 8283   ins_encode(REX_reg_reg_wide(dst, src),
 8284              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8285   ins_pipe(ialu_reg_reg_alu0);
 8286 %}
 8287 
 8288 instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)
 8289 %{
 8290   match(Set dst (MulL dst (LoadL src)));
 8291   effect(KILL cr);
 8292 
 8293   ins_cost(350);
 8294   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8295   opcode(0x0F, 0xAF);
 8296   ins_encode(REX_reg_mem_wide(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8297   ins_pipe(ialu_reg_mem_alu0);
 8298 %}
 8299 
 8300 instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)
 8301 %{
 8302   match(Set dst (MulL (LoadL src) imm));
 8303   effect(KILL cr);
 8304 
 8305   ins_cost(300);
 8306   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8307   opcode(0x69); /* 69 /r id */
 8308   ins_encode(REX_reg_mem_wide(dst, src),
 8309              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8310   ins_pipe(ialu_reg_mem_alu0);
 8311 %}
 8312 
 8313 instruct mulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8314 %{
 8315   match(Set dst (MulHiL src rax));
 8316   effect(USE_KILL rax, KILL cr);
 8317 
 8318   ins_cost(300);
 8319   format %{ &quot;imulq   RDX:RAX, RAX, $src\t# mulhi&quot; %}
 8320   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8321   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8322   ins_pipe(ialu_reg_reg_alu0);
 8323 %}
 8324 
 8325 instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8326                    rFlagsReg cr)
 8327 %{
 8328   match(Set rax (DivI rax div));
 8329   effect(KILL rdx, KILL cr);
 8330 
 8331   ins_cost(30*100+10*100); // XXX
 8332   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8333             &quot;jne,s   normal\n\t&quot;
 8334             &quot;xorl    rdx, rdx\n\t&quot;
 8335             &quot;cmpl    $div, -1\n\t&quot;
 8336             &quot;je,s    done\n&quot;
 8337     &quot;normal: cdql\n\t&quot;
 8338             &quot;idivl   $div\n&quot;
 8339     &quot;done:&quot;        %}
 8340   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8341   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8342   ins_pipe(ialu_reg_reg_alu0);
 8343 %}
 8344 
 8345 instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8346                    rFlagsReg cr)
 8347 %{
 8348   match(Set rax (DivL rax div));
 8349   effect(KILL rdx, KILL cr);
 8350 
 8351   ins_cost(30*100+10*100); // XXX
 8352   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8353             &quot;cmpq    rax, rdx\n\t&quot;
 8354             &quot;jne,s   normal\n\t&quot;
 8355             &quot;xorl    rdx, rdx\n\t&quot;
 8356             &quot;cmpq    $div, -1\n\t&quot;
 8357             &quot;je,s    done\n&quot;
 8358     &quot;normal: cdqq\n\t&quot;
 8359             &quot;idivq   $div\n&quot;
 8360     &quot;done:&quot;        %}
 8361   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8362   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8363   ins_pipe(ialu_reg_reg_alu0);
 8364 %}
 8365 
 8366 // Integer DIVMOD with Register, both quotient and mod results
 8367 instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8368                              rFlagsReg cr)
 8369 %{
 8370   match(DivModI rax div);
 8371   effect(KILL cr);
 8372 
 8373   ins_cost(30*100+10*100); // XXX
 8374   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8375             &quot;jne,s   normal\n\t&quot;
 8376             &quot;xorl    rdx, rdx\n\t&quot;
 8377             &quot;cmpl    $div, -1\n\t&quot;
 8378             &quot;je,s    done\n&quot;
 8379     &quot;normal: cdql\n\t&quot;
 8380             &quot;idivl   $div\n&quot;
 8381     &quot;done:&quot;        %}
 8382   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8383   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8384   ins_pipe(pipe_slow);
 8385 %}
 8386 
 8387 // Long DIVMOD with Register, both quotient and mod results
 8388 instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8389                              rFlagsReg cr)
 8390 %{
 8391   match(DivModL rax div);
 8392   effect(KILL cr);
 8393 
 8394   ins_cost(30*100+10*100); // XXX
 8395   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8396             &quot;cmpq    rax, rdx\n\t&quot;
 8397             &quot;jne,s   normal\n\t&quot;
 8398             &quot;xorl    rdx, rdx\n\t&quot;
 8399             &quot;cmpq    $div, -1\n\t&quot;
 8400             &quot;je,s    done\n&quot;
 8401     &quot;normal: cdqq\n\t&quot;
 8402             &quot;idivq   $div\n&quot;
 8403     &quot;done:&quot;        %}
 8404   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8405   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8406   ins_pipe(pipe_slow);
 8407 %}
 8408 
 8409 //----------- DivL-By-Constant-Expansions--------------------------------------
 8410 // DivI cases are handled by the compiler
 8411 
 8412 // Magic constant, reciprocal of 10
 8413 instruct loadConL_0x6666666666666667(rRegL dst)
 8414 %{
 8415   effect(DEF dst);
 8416 
 8417   format %{ &quot;movq    $dst, #0x666666666666667\t# Used in div-by-10&quot; %}
 8418   ins_encode(load_immL(dst, 0x6666666666666667));
 8419   ins_pipe(ialu_reg);
 8420 %}
 8421 
 8422 instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8423 %{
 8424   effect(DEF dst, USE src, USE_KILL rax, KILL cr);
 8425 
 8426   format %{ &quot;imulq   rdx:rax, rax, $src\t# Used in div-by-10&quot; %}
 8427   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8428   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8429   ins_pipe(ialu_reg_reg_alu0);
 8430 %}
 8431 
 8432 instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)
 8433 %{
 8434   effect(USE_DEF dst, KILL cr);
 8435 
 8436   format %{ &quot;sarq    $dst, #63\t# Used in div-by-10&quot; %}
 8437   opcode(0xC1, 0x7); /* C1 /7 ib */
 8438   ins_encode(reg_opc_imm_wide(dst, 0x3F));
 8439   ins_pipe(ialu_reg);
 8440 %}
 8441 
 8442 instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)
 8443 %{
 8444   effect(USE_DEF dst, KILL cr);
 8445 
 8446   format %{ &quot;sarq    $dst, #2\t# Used in div-by-10&quot; %}
 8447   opcode(0xC1, 0x7); /* C1 /7 ib */
 8448   ins_encode(reg_opc_imm_wide(dst, 0x2));
 8449   ins_pipe(ialu_reg);
 8450 %}
 8451 
 8452 instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)
 8453 %{
 8454   match(Set dst (DivL src div));
 8455 
 8456   ins_cost((5+8)*100);
 8457   expand %{
 8458     rax_RegL rax;                     // Killed temp
 8459     rFlagsReg cr;                     // Killed
 8460     loadConL_0x6666666666666667(rax); // movq  rax, 0x6666666666666667
 8461     mul_hi(dst, src, rax, cr);        // mulq  rdx:rax &lt;= rax * $src
 8462     sarL_rReg_63(src, cr);            // sarq  src, 63
 8463     sarL_rReg_2(dst, cr);             // sarq  rdx, 2
 8464     subL_rReg(dst, src, cr);          // subl  rdx, src
 8465   %}
 8466 %}
 8467 
 8468 //-----------------------------------------------------------------------------
 8469 
 8470 instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
 8471                    rFlagsReg cr)
 8472 %{
 8473   match(Set rdx (ModI rax div));
 8474   effect(KILL rax, KILL cr);
 8475 
 8476   ins_cost(300); // XXX
 8477   format %{ &quot;cmpl    rax, 0x80000000\t# irem\n\t&quot;
 8478             &quot;jne,s   normal\n\t&quot;
 8479             &quot;xorl    rdx, rdx\n\t&quot;
 8480             &quot;cmpl    $div, -1\n\t&quot;
 8481             &quot;je,s    done\n&quot;
 8482     &quot;normal: cdql\n\t&quot;
 8483             &quot;idivl   $div\n&quot;
 8484     &quot;done:&quot;        %}
 8485   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8486   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8487   ins_pipe(ialu_reg_reg_alu0);
 8488 %}
 8489 
 8490 instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
 8491                    rFlagsReg cr)
 8492 %{
 8493   match(Set rdx (ModL rax div));
 8494   effect(KILL rax, KILL cr);
 8495 
 8496   ins_cost(300); // XXX
 8497   format %{ &quot;movq    rdx, 0x8000000000000000\t# lrem\n\t&quot;
 8498             &quot;cmpq    rax, rdx\n\t&quot;
 8499             &quot;jne,s   normal\n\t&quot;
 8500             &quot;xorl    rdx, rdx\n\t&quot;
 8501             &quot;cmpq    $div, -1\n\t&quot;
 8502             &quot;je,s    done\n&quot;
 8503     &quot;normal: cdqq\n\t&quot;
 8504             &quot;idivq   $div\n&quot;
 8505     &quot;done:&quot;        %}
 8506   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8507   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8508   ins_pipe(ialu_reg_reg_alu0);
 8509 %}
 8510 
 8511 // Integer Shift Instructions
 8512 // Shift Left by one
 8513 instruct salI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8514 %{
 8515   match(Set dst (LShiftI dst shift));
 8516   effect(KILL cr);
 8517 
 8518   format %{ &quot;sall    $dst, $shift&quot; %}
 8519   opcode(0xD1, 0x4); /* D1 /4 */
 8520   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8521   ins_pipe(ialu_reg);
 8522 %}
 8523 
 8524 // Shift Left by one
 8525 instruct salI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8526 %{
 8527   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8528   effect(KILL cr);
 8529 
 8530   format %{ &quot;sall    $dst, $shift\t&quot; %}
 8531   opcode(0xD1, 0x4); /* D1 /4 */
 8532   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8533   ins_pipe(ialu_mem_imm);
 8534 %}
 8535 
 8536 // Shift Left by 8-bit immediate
 8537 instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8538 %{
 8539   match(Set dst (LShiftI dst shift));
 8540   effect(KILL cr);
 8541 
 8542   format %{ &quot;sall    $dst, $shift&quot; %}
 8543   opcode(0xC1, 0x4); /* C1 /4 ib */
 8544   ins_encode(reg_opc_imm(dst, shift));
 8545   ins_pipe(ialu_reg);
 8546 %}
 8547 
 8548 // Shift Left by 8-bit immediate
 8549 instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8550 %{
 8551   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8552   effect(KILL cr);
 8553 
 8554   format %{ &quot;sall    $dst, $shift&quot; %}
 8555   opcode(0xC1, 0x4); /* C1 /4 ib */
 8556   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8557   ins_pipe(ialu_mem_imm);
 8558 %}
 8559 
 8560 // Shift Left by variable
 8561 instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8562 %{
 8563   match(Set dst (LShiftI dst shift));
 8564   effect(KILL cr);
 8565 
 8566   format %{ &quot;sall    $dst, $shift&quot; %}
 8567   opcode(0xD3, 0x4); /* D3 /4 */
 8568   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8569   ins_pipe(ialu_reg_reg);
 8570 %}
 8571 
 8572 // Shift Left by variable
 8573 instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8574 %{
 8575   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8576   effect(KILL cr);
 8577 
 8578   format %{ &quot;sall    $dst, $shift&quot; %}
 8579   opcode(0xD3, 0x4); /* D3 /4 */
 8580   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8581   ins_pipe(ialu_mem_reg);
 8582 %}
 8583 
 8584 // Arithmetic shift right by one
 8585 instruct sarI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8586 %{
 8587   match(Set dst (RShiftI dst shift));
 8588   effect(KILL cr);
 8589 
 8590   format %{ &quot;sarl    $dst, $shift&quot; %}
 8591   opcode(0xD1, 0x7); /* D1 /7 */
 8592   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8593   ins_pipe(ialu_reg);
 8594 %}
 8595 
 8596 // Arithmetic shift right by one
 8597 instruct sarI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8598 %{
 8599   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8600   effect(KILL cr);
 8601 
 8602   format %{ &quot;sarl    $dst, $shift&quot; %}
 8603   opcode(0xD1, 0x7); /* D1 /7 */
 8604   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8605   ins_pipe(ialu_mem_imm);
 8606 %}
 8607 
 8608 // Arithmetic Shift Right by 8-bit immediate
 8609 instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8610 %{
 8611   match(Set dst (RShiftI dst shift));
 8612   effect(KILL cr);
 8613 
 8614   format %{ &quot;sarl    $dst, $shift&quot; %}
 8615   opcode(0xC1, 0x7); /* C1 /7 ib */
 8616   ins_encode(reg_opc_imm(dst, shift));
 8617   ins_pipe(ialu_mem_imm);
 8618 %}
 8619 
 8620 // Arithmetic Shift Right by 8-bit immediate
 8621 instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8622 %{
 8623   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8624   effect(KILL cr);
 8625 
 8626   format %{ &quot;sarl    $dst, $shift&quot; %}
 8627   opcode(0xC1, 0x7); /* C1 /7 ib */
 8628   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8629   ins_pipe(ialu_mem_imm);
 8630 %}
 8631 
 8632 // Arithmetic Shift Right by variable
 8633 instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8634 %{
 8635   match(Set dst (RShiftI dst shift));
 8636   effect(KILL cr);
 8637 
 8638   format %{ &quot;sarl    $dst, $shift&quot; %}
 8639   opcode(0xD3, 0x7); /* D3 /7 */
 8640   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8641   ins_pipe(ialu_reg_reg);
 8642 %}
 8643 
 8644 // Arithmetic Shift Right by variable
 8645 instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8646 %{
 8647   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8648   effect(KILL cr);
 8649 
 8650   format %{ &quot;sarl    $dst, $shift&quot; %}
 8651   opcode(0xD3, 0x7); /* D3 /7 */
 8652   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8653   ins_pipe(ialu_mem_reg);
 8654 %}
 8655 
 8656 // Logical shift right by one
 8657 instruct shrI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8658 %{
 8659   match(Set dst (URShiftI dst shift));
 8660   effect(KILL cr);
 8661 
 8662   format %{ &quot;shrl    $dst, $shift&quot; %}
 8663   opcode(0xD1, 0x5); /* D1 /5 */
 8664   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8665   ins_pipe(ialu_reg);
 8666 %}
 8667 
 8668 // Logical shift right by one
 8669 instruct shrI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8670 %{
 8671   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8672   effect(KILL cr);
 8673 
 8674   format %{ &quot;shrl    $dst, $shift&quot; %}
 8675   opcode(0xD1, 0x5); /* D1 /5 */
 8676   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8677   ins_pipe(ialu_mem_imm);
 8678 %}
 8679 
 8680 // Logical Shift Right by 8-bit immediate
 8681 instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8682 %{
 8683   match(Set dst (URShiftI dst shift));
 8684   effect(KILL cr);
 8685 
 8686   format %{ &quot;shrl    $dst, $shift&quot; %}
 8687   opcode(0xC1, 0x5); /* C1 /5 ib */
 8688   ins_encode(reg_opc_imm(dst, shift));
 8689   ins_pipe(ialu_reg);
 8690 %}
 8691 
 8692 // Logical Shift Right by 8-bit immediate
 8693 instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8694 %{
 8695   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8696   effect(KILL cr);
 8697 
 8698   format %{ &quot;shrl    $dst, $shift&quot; %}
 8699   opcode(0xC1, 0x5); /* C1 /5 ib */
 8700   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8701   ins_pipe(ialu_mem_imm);
 8702 %}
 8703 
 8704 // Logical Shift Right by variable
 8705 instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8706 %{
 8707   match(Set dst (URShiftI dst shift));
 8708   effect(KILL cr);
 8709 
 8710   format %{ &quot;shrl    $dst, $shift&quot; %}
 8711   opcode(0xD3, 0x5); /* D3 /5 */
 8712   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8713   ins_pipe(ialu_reg_reg);
 8714 %}
 8715 
 8716 // Logical Shift Right by variable
 8717 instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8718 %{
 8719   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8720   effect(KILL cr);
 8721 
 8722   format %{ &quot;shrl    $dst, $shift&quot; %}
 8723   opcode(0xD3, 0x5); /* D3 /5 */
 8724   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8725   ins_pipe(ialu_mem_reg);
 8726 %}
 8727 
 8728 // Long Shift Instructions
 8729 // Shift Left by one
 8730 instruct salL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8731 %{
 8732   match(Set dst (LShiftL dst shift));
 8733   effect(KILL cr);
 8734 
 8735   format %{ &quot;salq    $dst, $shift&quot; %}
 8736   opcode(0xD1, 0x4); /* D1 /4 */
 8737   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8738   ins_pipe(ialu_reg);
 8739 %}
 8740 
 8741 // Shift Left by one
 8742 instruct salL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8743 %{
 8744   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8745   effect(KILL cr);
 8746 
 8747   format %{ &quot;salq    $dst, $shift&quot; %}
 8748   opcode(0xD1, 0x4); /* D1 /4 */
 8749   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8750   ins_pipe(ialu_mem_imm);
 8751 %}
 8752 
 8753 // Shift Left by 8-bit immediate
 8754 instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8755 %{
 8756   match(Set dst (LShiftL dst shift));
 8757   effect(KILL cr);
 8758 
 8759   format %{ &quot;salq    $dst, $shift&quot; %}
 8760   opcode(0xC1, 0x4); /* C1 /4 ib */
 8761   ins_encode(reg_opc_imm_wide(dst, shift));
 8762   ins_pipe(ialu_reg);
 8763 %}
 8764 
 8765 // Shift Left by 8-bit immediate
 8766 instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8767 %{
 8768   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8769   effect(KILL cr);
 8770 
 8771   format %{ &quot;salq    $dst, $shift&quot; %}
 8772   opcode(0xC1, 0x4); /* C1 /4 ib */
 8773   ins_encode(REX_mem_wide(dst), OpcP,
 8774              RM_opc_mem(secondary, dst), Con8or32(shift));
 8775   ins_pipe(ialu_mem_imm);
 8776 %}
 8777 
 8778 // Shift Left by variable
 8779 instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8780 %{
 8781   match(Set dst (LShiftL dst shift));
 8782   effect(KILL cr);
 8783 
 8784   format %{ &quot;salq    $dst, $shift&quot; %}
 8785   opcode(0xD3, 0x4); /* D3 /4 */
 8786   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8787   ins_pipe(ialu_reg_reg);
 8788 %}
 8789 
 8790 // Shift Left by variable
 8791 instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8792 %{
 8793   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8794   effect(KILL cr);
 8795 
 8796   format %{ &quot;salq    $dst, $shift&quot; %}
 8797   opcode(0xD3, 0x4); /* D3 /4 */
 8798   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8799   ins_pipe(ialu_mem_reg);
 8800 %}
 8801 
 8802 // Arithmetic shift right by one
 8803 instruct sarL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8804 %{
 8805   match(Set dst (RShiftL dst shift));
 8806   effect(KILL cr);
 8807 
 8808   format %{ &quot;sarq    $dst, $shift&quot; %}
 8809   opcode(0xD1, 0x7); /* D1 /7 */
 8810   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8811   ins_pipe(ialu_reg);
 8812 %}
 8813 
 8814 // Arithmetic shift right by one
 8815 instruct sarL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8816 %{
 8817   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8818   effect(KILL cr);
 8819 
 8820   format %{ &quot;sarq    $dst, $shift&quot; %}
 8821   opcode(0xD1, 0x7); /* D1 /7 */
 8822   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8823   ins_pipe(ialu_mem_imm);
 8824 %}
 8825 
 8826 // Arithmetic Shift Right by 8-bit immediate
 8827 instruct sarL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8828 %{
 8829   match(Set dst (RShiftL dst shift));
 8830   effect(KILL cr);
 8831 
 8832   format %{ &quot;sarq    $dst, $shift&quot; %}
 8833   opcode(0xC1, 0x7); /* C1 /7 ib */
 8834   ins_encode(reg_opc_imm_wide(dst, shift));
 8835   ins_pipe(ialu_mem_imm);
 8836 %}
 8837 
 8838 // Arithmetic Shift Right by 8-bit immediate
 8839 instruct sarL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8840 %{
 8841   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8842   effect(KILL cr);
 8843 
 8844   format %{ &quot;sarq    $dst, $shift&quot; %}
 8845   opcode(0xC1, 0x7); /* C1 /7 ib */
 8846   ins_encode(REX_mem_wide(dst), OpcP,
 8847              RM_opc_mem(secondary, dst), Con8or32(shift));
 8848   ins_pipe(ialu_mem_imm);
 8849 %}
 8850 
 8851 // Arithmetic Shift Right by variable
 8852 instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8853 %{
 8854   match(Set dst (RShiftL dst shift));
 8855   effect(KILL cr);
 8856 
 8857   format %{ &quot;sarq    $dst, $shift&quot; %}
 8858   opcode(0xD3, 0x7); /* D3 /7 */
 8859   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8860   ins_pipe(ialu_reg_reg);
 8861 %}
 8862 
 8863 // Arithmetic Shift Right by variable
 8864 instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8865 %{
 8866   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8867   effect(KILL cr);
 8868 
 8869   format %{ &quot;sarq    $dst, $shift&quot; %}
 8870   opcode(0xD3, 0x7); /* D3 /7 */
 8871   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8872   ins_pipe(ialu_mem_reg);
 8873 %}
 8874 
 8875 // Logical shift right by one
 8876 instruct shrL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8877 %{
 8878   match(Set dst (URShiftL dst shift));
 8879   effect(KILL cr);
 8880 
 8881   format %{ &quot;shrq    $dst, $shift&quot; %}
 8882   opcode(0xD1, 0x5); /* D1 /5 */
 8883   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst ));
 8884   ins_pipe(ialu_reg);
 8885 %}
 8886 
 8887 // Logical shift right by one
 8888 instruct shrL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8889 %{
 8890   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8891   effect(KILL cr);
 8892 
 8893   format %{ &quot;shrq    $dst, $shift&quot; %}
 8894   opcode(0xD1, 0x5); /* D1 /5 */
 8895   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8896   ins_pipe(ialu_mem_imm);
 8897 %}
 8898 
 8899 // Logical Shift Right by 8-bit immediate
 8900 instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8901 %{
 8902   match(Set dst (URShiftL dst shift));
 8903   effect(KILL cr);
 8904 
 8905   format %{ &quot;shrq    $dst, $shift&quot; %}
 8906   opcode(0xC1, 0x5); /* C1 /5 ib */
 8907   ins_encode(reg_opc_imm_wide(dst, shift));
 8908   ins_pipe(ialu_reg);
 8909 %}
 8910 
 8911 
 8912 // Logical Shift Right by 8-bit immediate
 8913 instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8914 %{
 8915   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8916   effect(KILL cr);
 8917 
 8918   format %{ &quot;shrq    $dst, $shift&quot; %}
 8919   opcode(0xC1, 0x5); /* C1 /5 ib */
 8920   ins_encode(REX_mem_wide(dst), OpcP,
 8921              RM_opc_mem(secondary, dst), Con8or32(shift));
 8922   ins_pipe(ialu_mem_imm);
 8923 %}
 8924 
 8925 // Logical Shift Right by variable
 8926 instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8927 %{
 8928   match(Set dst (URShiftL dst shift));
 8929   effect(KILL cr);
 8930 
 8931   format %{ &quot;shrq    $dst, $shift&quot; %}
 8932   opcode(0xD3, 0x5); /* D3 /5 */
 8933   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8934   ins_pipe(ialu_reg_reg);
 8935 %}
 8936 
 8937 // Logical Shift Right by variable
 8938 instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8939 %{
 8940   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8941   effect(KILL cr);
 8942 
 8943   format %{ &quot;shrq    $dst, $shift&quot; %}
 8944   opcode(0xD3, 0x5); /* D3 /5 */
 8945   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8946   ins_pipe(ialu_mem_reg);
 8947 %}
 8948 
 8949 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
 8950 // This idiom is used by the compiler for the i2b bytecode.
 8951 instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)
 8952 %{
 8953   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
 8954 
 8955   format %{ &quot;movsbl  $dst, $src\t# i2b&quot; %}
 8956   opcode(0x0F, 0xBE);
 8957   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8958   ins_pipe(ialu_reg_reg);
 8959 %}
 8960 
 8961 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
 8962 // This idiom is used by the compiler the i2s bytecode.
 8963 instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)
 8964 %{
 8965   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
 8966 
 8967   format %{ &quot;movswl  $dst, $src\t# i2s&quot; %}
 8968   opcode(0x0F, 0xBF);
 8969   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8970   ins_pipe(ialu_reg_reg);
 8971 %}
 8972 
 8973 // ROL/ROR instructions
 8974 
 8975 // ROL expand
 8976 instruct rolI_rReg_imm1(rRegI dst, rFlagsReg cr) %{
 8977   effect(KILL cr, USE_DEF dst);
 8978 
 8979   format %{ &quot;roll    $dst&quot; %}
 8980   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 8981   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8982   ins_pipe(ialu_reg);
 8983 %}
 8984 
 8985 instruct rolI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr) %{
 8986   effect(USE_DEF dst, USE shift, KILL cr);
 8987 
 8988   format %{ &quot;roll    $dst, $shift&quot; %}
 8989   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 8990   ins_encode( reg_opc_imm(dst, shift) );
 8991   ins_pipe(ialu_reg);
 8992 %}
 8993 
 8994 instruct rolI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 8995 %{
 8996   effect(USE_DEF dst, USE shift, KILL cr);
 8997 
 8998   format %{ &quot;roll    $dst, $shift&quot; %}
 8999   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9000   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9001   ins_pipe(ialu_reg_reg);
 9002 %}
 9003 // end of ROL expand
 9004 
 9005 // Rotate Left by one
 9006 instruct rolI_rReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9007 %{
 9008   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9009 
 9010   expand %{
 9011     rolI_rReg_imm1(dst, cr);
 9012   %}
 9013 %}
 9014 
 9015 // Rotate Left by 8-bit immediate
 9016 instruct rolI_rReg_i8(rRegI dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9017 %{
 9018   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9019   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9020 
 9021   expand %{
 9022     rolI_rReg_imm8(dst, lshift, cr);
 9023   %}
 9024 %}
 9025 
 9026 // Rotate Left by variable
 9027 instruct rolI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9028 %{
 9029   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
 9030 
 9031   expand %{
 9032     rolI_rReg_CL(dst, shift, cr);
 9033   %}
 9034 %}
 9035 
 9036 // Rotate Left by variable
 9037 instruct rolI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9038 %{
 9039   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
 9040 
 9041   expand %{
 9042     rolI_rReg_CL(dst, shift, cr);
 9043   %}
 9044 %}
 9045 
 9046 // ROR expand
 9047 instruct rorI_rReg_imm1(rRegI dst, rFlagsReg cr)
 9048 %{
 9049   effect(USE_DEF dst, KILL cr);
 9050 
 9051   format %{ &quot;rorl    $dst&quot; %}
 9052   opcode(0xD1, 0x1); /* D1 /1 */
 9053   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9054   ins_pipe(ialu_reg);
 9055 %}
 9056 
 9057 instruct rorI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr)
 9058 %{
 9059   effect(USE_DEF dst, USE shift, KILL cr);
 9060 
 9061   format %{ &quot;rorl    $dst, $shift&quot; %}
 9062   opcode(0xC1, 0x1); /* C1 /1 ib */
 9063   ins_encode(reg_opc_imm(dst, shift));
 9064   ins_pipe(ialu_reg);
 9065 %}
 9066 
 9067 instruct rorI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9068 %{
 9069   effect(USE_DEF dst, USE shift, KILL cr);
 9070 
 9071   format %{ &quot;rorl    $dst, $shift&quot; %}
 9072   opcode(0xD3, 0x1); /* D3 /1 */
 9073   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9074   ins_pipe(ialu_reg_reg);
 9075 %}
 9076 // end of ROR expand
 9077 
 9078 // Rotate Right by one
 9079 instruct rorI_rReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9080 %{
 9081   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9082 
 9083   expand %{
 9084     rorI_rReg_imm1(dst, cr);
 9085   %}
 9086 %}
 9087 
 9088 // Rotate Right by 8-bit immediate
 9089 instruct rorI_rReg_i8(rRegI dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9090 %{
 9091   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9092   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9093 
 9094   expand %{
 9095     rorI_rReg_imm8(dst, rshift, cr);
 9096   %}
 9097 %}
 9098 
 9099 // Rotate Right by variable
 9100 instruct rorI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9101 %{
 9102   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
 9103 
 9104   expand %{
 9105     rorI_rReg_CL(dst, shift, cr);
 9106   %}
 9107 %}
 9108 
 9109 // Rotate Right by variable
 9110 instruct rorI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9111 %{
 9112   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
 9113 
 9114   expand %{
 9115     rorI_rReg_CL(dst, shift, cr);
 9116   %}
 9117 %}
 9118 
 9119 // for long rotate
 9120 // ROL expand
 9121 instruct rolL_rReg_imm1(rRegL dst, rFlagsReg cr) %{
 9122   effect(USE_DEF dst, KILL cr);
 9123 
 9124   format %{ &quot;rolq    $dst&quot; %}
 9125   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 9126   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9127   ins_pipe(ialu_reg);
 9128 %}
 9129 
 9130 instruct rolL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr) %{
 9131   effect(USE_DEF dst, USE shift, KILL cr);
 9132 
 9133   format %{ &quot;rolq    $dst, $shift&quot; %}
 9134   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 9135   ins_encode( reg_opc_imm_wide(dst, shift) );
 9136   ins_pipe(ialu_reg);
 9137 %}
 9138 
 9139 instruct rolL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9140 %{
 9141   effect(USE_DEF dst, USE shift, KILL cr);
 9142 
 9143   format %{ &quot;rolq    $dst, $shift&quot; %}
 9144   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9145   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9146   ins_pipe(ialu_reg_reg);
 9147 %}
 9148 // end of ROL expand
 9149 
 9150 // Rotate Left by one
 9151 instruct rolL_rReg_i1(rRegL dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9152 %{
 9153   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9154 
 9155   expand %{
 9156     rolL_rReg_imm1(dst, cr);
 9157   %}
 9158 %}
 9159 
 9160 // Rotate Left by 8-bit immediate
 9161 instruct rolL_rReg_i8(rRegL dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9162 %{
 9163   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9164   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9165 
 9166   expand %{
 9167     rolL_rReg_imm8(dst, lshift, cr);
 9168   %}
 9169 %}
 9170 
 9171 // Rotate Left by variable
 9172 instruct rolL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9173 %{
 9174   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI zero shift))));
 9175 
 9176   expand %{
 9177     rolL_rReg_CL(dst, shift, cr);
 9178   %}
 9179 %}
 9180 
 9181 // Rotate Left by variable
 9182 instruct rolL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9183 %{
 9184   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI c64 shift))));
 9185 
 9186   expand %{
 9187     rolL_rReg_CL(dst, shift, cr);
 9188   %}
 9189 %}
 9190 
 9191 // ROR expand
 9192 instruct rorL_rReg_imm1(rRegL dst, rFlagsReg cr)
 9193 %{
 9194   effect(USE_DEF dst, KILL cr);
 9195 
 9196   format %{ &quot;rorq    $dst&quot; %}
 9197   opcode(0xD1, 0x1); /* D1 /1 */
 9198   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9199   ins_pipe(ialu_reg);
 9200 %}
 9201 
 9202 instruct rorL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr)
 9203 %{
 9204   effect(USE_DEF dst, USE shift, KILL cr);
 9205 
 9206   format %{ &quot;rorq    $dst, $shift&quot; %}
 9207   opcode(0xC1, 0x1); /* C1 /1 ib */
 9208   ins_encode(reg_opc_imm_wide(dst, shift));
 9209   ins_pipe(ialu_reg);
 9210 %}
 9211 
 9212 instruct rorL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9213 %{
 9214   effect(USE_DEF dst, USE shift, KILL cr);
 9215 
 9216   format %{ &quot;rorq    $dst, $shift&quot; %}
 9217   opcode(0xD3, 0x1); /* D3 /1 */
 9218   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9219   ins_pipe(ialu_reg_reg);
 9220 %}
 9221 // end of ROR expand
 9222 
 9223 // Rotate Right by one
 9224 instruct rorL_rReg_i1(rRegL dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9225 %{
 9226   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9227 
 9228   expand %{
 9229     rorL_rReg_imm1(dst, cr);
 9230   %}
 9231 %}
 9232 
 9233 // Rotate Right by 8-bit immediate
 9234 instruct rorL_rReg_i8(rRegL dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9235 %{
 9236   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9237   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9238 
 9239   expand %{
 9240     rorL_rReg_imm8(dst, rshift, cr);
 9241   %}
 9242 %}
 9243 
 9244 // Rotate Right by variable
 9245 instruct rorL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9246 %{
 9247   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI zero shift))));
 9248 
 9249   expand %{
 9250     rorL_rReg_CL(dst, shift, cr);
 9251   %}
 9252 %}
 9253 
 9254 // Rotate Right by variable
 9255 instruct rorL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9256 %{
 9257   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI c64 shift))));
 9258 
 9259   expand %{
 9260     rorL_rReg_CL(dst, shift, cr);
 9261   %}
 9262 %}
 9263 
 9264 // Logical Instructions
 9265 
 9266 // Integer Logical Instructions
 9267 
 9268 // And Instructions
 9269 // And Register with Register
 9270 instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9271 %{
 9272   match(Set dst (AndI dst src));
 9273   effect(KILL cr);
 9274 
 9275   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9276   opcode(0x23);
 9277   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9278   ins_pipe(ialu_reg_reg);
 9279 %}
 9280 
 9281 // And Register with Immediate 255
 9282 instruct andI_rReg_imm255(rRegI dst, immI_255 src)
 9283 %{
 9284   match(Set dst (AndI dst src));
 9285 
 9286   format %{ &quot;movzbl  $dst, $dst\t# int &amp; 0xFF&quot; %}
 9287   opcode(0x0F, 0xB6);
 9288   ins_encode(REX_reg_breg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9289   ins_pipe(ialu_reg);
 9290 %}
 9291 
 9292 // And Register with Immediate 255 and promote to long
 9293 instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)
 9294 %{
 9295   match(Set dst (ConvI2L (AndI src mask)));
 9296 
 9297   format %{ &quot;movzbl  $dst, $src\t# int &amp; 0xFF -&gt; long&quot; %}
 9298   opcode(0x0F, 0xB6);
 9299   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9300   ins_pipe(ialu_reg);
 9301 %}
 9302 
 9303 // And Register with Immediate 65535
 9304 instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)
 9305 %{
 9306   match(Set dst (AndI dst src));
 9307 
 9308   format %{ &quot;movzwl  $dst, $dst\t# int &amp; 0xFFFF&quot; %}
 9309   opcode(0x0F, 0xB7);
 9310   ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9311   ins_pipe(ialu_reg);
 9312 %}
 9313 
 9314 // And Register with Immediate 65535 and promote to long
 9315 instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)
 9316 %{
 9317   match(Set dst (ConvI2L (AndI src mask)));
 9318 
 9319   format %{ &quot;movzwl  $dst, $src\t# int &amp; 0xFFFF -&gt; long&quot; %}
 9320   opcode(0x0F, 0xB7);
 9321   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9322   ins_pipe(ialu_reg);
 9323 %}
 9324 
 9325 // And Register with Immediate
 9326 instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9327 %{
 9328   match(Set dst (AndI dst src));
 9329   effect(KILL cr);
 9330 
 9331   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9332   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9333   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9334   ins_pipe(ialu_reg);
 9335 %}
 9336 
 9337 // And Register with Memory
 9338 instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9339 %{
 9340   match(Set dst (AndI dst (LoadI src)));
 9341   effect(KILL cr);
 9342 
 9343   ins_cost(125);
 9344   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9345   opcode(0x23);
 9346   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9347   ins_pipe(ialu_reg_mem);
 9348 %}
 9349 
 9350 // And Memory with Register
 9351 instruct andB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9352 %{
 9353   match(Set dst (StoreB dst (AndI (LoadB dst) src)));
 9354   effect(KILL cr);
 9355 
 9356   ins_cost(150);
 9357   format %{ &quot;andb    $dst, $src\t# byte&quot; %}
 9358   opcode(0x20);
 9359   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9360   ins_pipe(ialu_mem_reg);
 9361 %}
 9362 
 9363 instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9364 %{
 9365   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9366   effect(KILL cr);
 9367 
 9368   ins_cost(150);
 9369   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9370   opcode(0x21); /* Opcode 21 /r */
 9371   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9372   ins_pipe(ialu_mem_reg);
 9373 %}
 9374 
 9375 // And Memory with Immediate
 9376 instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9377 %{
 9378   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9379   effect(KILL cr);
 9380 
 9381   ins_cost(125);
 9382   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9383   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9384   ins_encode(REX_mem(dst), OpcSE(src),
 9385              RM_opc_mem(secondary, dst), Con8or32(src));
 9386   ins_pipe(ialu_mem_imm);
 9387 %}
 9388 
 9389 // BMI1 instructions
 9390 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, rFlagsReg cr) %{
 9391   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2)));
 9392   predicate(UseBMI1Instructions);
 9393   effect(KILL cr);
 9394 
 9395   ins_cost(125);
 9396   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9397 
 9398   ins_encode %{
 9399     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
 9400   %}
 9401   ins_pipe(ialu_reg_mem);
 9402 %}
 9403 
 9404 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, rFlagsReg cr) %{
 9405   match(Set dst (AndI (XorI src1 minus_1) src2));
 9406   predicate(UseBMI1Instructions);
 9407   effect(KILL cr);
 9408 
 9409   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9410 
 9411   ins_encode %{
 9412     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
 9413   %}
 9414   ins_pipe(ialu_reg);
 9415 %}
 9416 
 9417 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, rFlagsReg cr) %{
 9418   match(Set dst (AndI (SubI imm_zero src) src));
 9419   predicate(UseBMI1Instructions);
 9420   effect(KILL cr);
 9421 
 9422   format %{ &quot;blsil  $dst, $src&quot; %}
 9423 
 9424   ins_encode %{
 9425     __ blsil($dst$$Register, $src$$Register);
 9426   %}
 9427   ins_pipe(ialu_reg);
 9428 %}
 9429 
 9430 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, rFlagsReg cr) %{
 9431   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
 9432   predicate(UseBMI1Instructions);
 9433   effect(KILL cr);
 9434 
 9435   ins_cost(125);
 9436   format %{ &quot;blsil  $dst, $src&quot; %}
 9437 
 9438   ins_encode %{
 9439     __ blsil($dst$$Register, $src$$Address);
 9440   %}
 9441   ins_pipe(ialu_reg_mem);
 9442 %}
 9443 
 9444 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9445 %{
 9446   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9447   predicate(UseBMI1Instructions);
 9448   effect(KILL cr);
 9449 
 9450   ins_cost(125);
 9451   format %{ &quot;blsmskl $dst, $src&quot; %}
 9452 
 9453   ins_encode %{
 9454     __ blsmskl($dst$$Register, $src$$Address);
 9455   %}
 9456   ins_pipe(ialu_reg_mem);
 9457 %}
 9458 
 9459 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9460 %{
 9461   match(Set dst (XorI (AddI src minus_1) src));
 9462   predicate(UseBMI1Instructions);
 9463   effect(KILL cr);
 9464 
 9465   format %{ &quot;blsmskl $dst, $src&quot; %}
 9466 
 9467   ins_encode %{
 9468     __ blsmskl($dst$$Register, $src$$Register);
 9469   %}
 9470 
 9471   ins_pipe(ialu_reg);
 9472 %}
 9473 
 9474 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9475 %{
 9476   match(Set dst (AndI (AddI src minus_1) src) );
 9477   predicate(UseBMI1Instructions);
 9478   effect(KILL cr);
 9479 
 9480   format %{ &quot;blsrl  $dst, $src&quot; %}
 9481 
 9482   ins_encode %{
 9483     __ blsrl($dst$$Register, $src$$Register);
 9484   %}
 9485 
 9486   ins_pipe(ialu_reg_mem);
 9487 %}
 9488 
 9489 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9490 %{
 9491   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9492   predicate(UseBMI1Instructions);
 9493   effect(KILL cr);
 9494 
 9495   ins_cost(125);
 9496   format %{ &quot;blsrl  $dst, $src&quot; %}
 9497 
 9498   ins_encode %{
 9499     __ blsrl($dst$$Register, $src$$Address);
 9500   %}
 9501 
 9502   ins_pipe(ialu_reg);
 9503 %}
 9504 
 9505 // Or Instructions
 9506 // Or Register with Register
 9507 instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9508 %{
 9509   match(Set dst (OrI dst src));
 9510   effect(KILL cr);
 9511 
 9512   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9513   opcode(0x0B);
 9514   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9515   ins_pipe(ialu_reg_reg);
 9516 %}
 9517 
 9518 // Or Register with Immediate
 9519 instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9520 %{
 9521   match(Set dst (OrI dst src));
 9522   effect(KILL cr);
 9523 
 9524   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9525   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9526   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9527   ins_pipe(ialu_reg);
 9528 %}
 9529 
 9530 // Or Register with Memory
 9531 instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9532 %{
 9533   match(Set dst (OrI dst (LoadI src)));
 9534   effect(KILL cr);
 9535 
 9536   ins_cost(125);
 9537   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9538   opcode(0x0B);
 9539   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9540   ins_pipe(ialu_reg_mem);
 9541 %}
 9542 
 9543 // Or Memory with Register
 9544 instruct orB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9545 %{
 9546   match(Set dst (StoreB dst (OrI (LoadB dst) src)));
 9547   effect(KILL cr);
 9548 
 9549   ins_cost(150);
 9550   format %{ &quot;orb    $dst, $src\t# byte&quot; %}
 9551   opcode(0x08);
 9552   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9553   ins_pipe(ialu_mem_reg);
 9554 %}
 9555 
 9556 instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9557 %{
 9558   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9559   effect(KILL cr);
 9560 
 9561   ins_cost(150);
 9562   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9563   opcode(0x09); /* Opcode 09 /r */
 9564   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9565   ins_pipe(ialu_mem_reg);
 9566 %}
 9567 
 9568 // Or Memory with Immediate
 9569 instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9570 %{
 9571   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9572   effect(KILL cr);
 9573 
 9574   ins_cost(125);
 9575   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9576   opcode(0x81, 0x1); /* Opcode 81 /1 id */
 9577   ins_encode(REX_mem(dst), OpcSE(src),
 9578              RM_opc_mem(secondary, dst), Con8or32(src));
 9579   ins_pipe(ialu_mem_imm);
 9580 %}
 9581 
 9582 // Xor Instructions
 9583 // Xor Register with Register
 9584 instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9585 %{
 9586   match(Set dst (XorI dst src));
 9587   effect(KILL cr);
 9588 
 9589   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9590   opcode(0x33);
 9591   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9592   ins_pipe(ialu_reg_reg);
 9593 %}
 9594 
 9595 // Xor Register with Immediate -1
 9596 instruct xorI_rReg_im1(rRegI dst, immI_M1 imm) %{
 9597   match(Set dst (XorI dst imm));
 9598 
 9599   format %{ &quot;not    $dst&quot; %}
 9600   ins_encode %{
 9601      __ notl($dst$$Register);
 9602   %}
 9603   ins_pipe(ialu_reg);
 9604 %}
 9605 
 9606 // Xor Register with Immediate
 9607 instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9608 %{
 9609   match(Set dst (XorI dst src));
 9610   effect(KILL cr);
 9611 
 9612   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9613   opcode(0x81, 0x06); /* Opcode 81 /6 id */
 9614   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9615   ins_pipe(ialu_reg);
 9616 %}
 9617 
 9618 // Xor Register with Memory
 9619 instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9620 %{
 9621   match(Set dst (XorI dst (LoadI src)));
 9622   effect(KILL cr);
 9623 
 9624   ins_cost(125);
 9625   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9626   opcode(0x33);
 9627   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9628   ins_pipe(ialu_reg_mem);
 9629 %}
 9630 
 9631 // Xor Memory with Register
 9632 instruct xorB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9633 %{
 9634   match(Set dst (StoreB dst (XorI (LoadB dst) src)));
 9635   effect(KILL cr);
 9636 
 9637   ins_cost(150);
 9638   format %{ &quot;xorb    $dst, $src\t# byte&quot; %}
 9639   opcode(0x30);
 9640   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9641   ins_pipe(ialu_mem_reg);
 9642 %}
 9643 
 9644 instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9645 %{
 9646   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9647   effect(KILL cr);
 9648 
 9649   ins_cost(150);
 9650   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9651   opcode(0x31); /* Opcode 31 /r */
 9652   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9653   ins_pipe(ialu_mem_reg);
 9654 %}
 9655 
 9656 // Xor Memory with Immediate
 9657 instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9658 %{
 9659   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9660   effect(KILL cr);
 9661 
 9662   ins_cost(125);
 9663   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9664   opcode(0x81, 0x6); /* Opcode 81 /6 id */
 9665   ins_encode(REX_mem(dst), OpcSE(src),
 9666              RM_opc_mem(secondary, dst), Con8or32(src));
 9667   ins_pipe(ialu_mem_imm);
 9668 %}
 9669 
 9670 
 9671 // Long Logical Instructions
 9672 
 9673 // And Instructions
 9674 // And Register with Register
 9675 instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9676 %{
 9677   match(Set dst (AndL dst src));
 9678   effect(KILL cr);
 9679 
 9680   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9681   opcode(0x23);
 9682   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9683   ins_pipe(ialu_reg_reg);
 9684 %}
 9685 
 9686 // And Register with Immediate 255
 9687 instruct andL_rReg_imm255(rRegL dst, immL_255 src)
 9688 %{
 9689   match(Set dst (AndL dst src));
 9690 
 9691   format %{ &quot;movzbq  $dst, $dst\t# long &amp; 0xFF&quot; %}
 9692   opcode(0x0F, 0xB6);
 9693   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9694   ins_pipe(ialu_reg);
 9695 %}
 9696 
 9697 // And Register with Immediate 65535
 9698 instruct andL_rReg_imm65535(rRegL dst, immL_65535 src)
 9699 %{
 9700   match(Set dst (AndL dst src));
 9701 
 9702   format %{ &quot;movzwq  $dst, $dst\t# long &amp; 0xFFFF&quot; %}
 9703   opcode(0x0F, 0xB7);
 9704   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9705   ins_pipe(ialu_reg);
 9706 %}
 9707 
 9708 // And Register with Immediate
 9709 instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9710 %{
 9711   match(Set dst (AndL dst src));
 9712   effect(KILL cr);
 9713 
 9714   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9715   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9716   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9717   ins_pipe(ialu_reg);
 9718 %}
 9719 
 9720 // And Register with Memory
 9721 instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9722 %{
 9723   match(Set dst (AndL dst (LoadL src)));
 9724   effect(KILL cr);
 9725 
 9726   ins_cost(125);
 9727   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9728   opcode(0x23);
 9729   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9730   ins_pipe(ialu_reg_mem);
 9731 %}
 9732 
 9733 // And Memory with Register
 9734 instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 9735 %{
 9736   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9737   effect(KILL cr);
 9738 
 9739   ins_cost(150);
 9740   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9741   opcode(0x21); /* Opcode 21 /r */
 9742   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 9743   ins_pipe(ialu_mem_reg);
 9744 %}
 9745 
 9746 // And Memory with Immediate
 9747 instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 9748 %{
 9749   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9750   effect(KILL cr);
 9751 
 9752   ins_cost(125);
 9753   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9754   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9755   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9756              RM_opc_mem(secondary, dst), Con8or32(src));
 9757   ins_pipe(ialu_mem_imm);
 9758 %}
 9759 
 9760 instruct btrL_mem_imm(memory dst, immL_NotPow2 con, rFlagsReg cr)
 9761 %{
 9762   // con should be a pure 64-bit immediate given that not(con) is a power of 2
 9763   // because AND/OR works well enough for 8/32-bit values.
 9764   predicate(log2_long(~n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 30);
 9765 
 9766   match(Set dst (StoreL dst (AndL (LoadL dst) con)));
 9767   effect(KILL cr);
 9768 
 9769   ins_cost(125);
 9770   format %{ &quot;btrq    $dst, log2(not($con))\t# long&quot; %}
 9771   ins_encode %{
 9772     __ btrq($dst$$Address, log2_long(~$con$$constant));
 9773   %}
 9774   ins_pipe(ialu_mem_imm);
 9775 %}
 9776 
 9777 // BMI1 instructions
 9778 instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
 9779   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
 9780   predicate(UseBMI1Instructions);
 9781   effect(KILL cr);
 9782 
 9783   ins_cost(125);
 9784   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9785 
 9786   ins_encode %{
 9787     __ andnq($dst$$Register, $src1$$Register, $src2$$Address);
 9788   %}
 9789   ins_pipe(ialu_reg_mem);
 9790 %}
 9791 
 9792 instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{
 9793   match(Set dst (AndL (XorL src1 minus_1) src2));
 9794   predicate(UseBMI1Instructions);
 9795   effect(KILL cr);
 9796 
 9797   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9798 
 9799   ins_encode %{
 9800   __ andnq($dst$$Register, $src1$$Register, $src2$$Register);
 9801   %}
 9802   ins_pipe(ialu_reg_mem);
 9803 %}
 9804 
 9805 instruct blsiL_rReg_rReg(rRegL dst, rRegL src, immL0 imm_zero, rFlagsReg cr) %{
 9806   match(Set dst (AndL (SubL imm_zero src) src));
 9807   predicate(UseBMI1Instructions);
 9808   effect(KILL cr);
 9809 
 9810   format %{ &quot;blsiq  $dst, $src&quot; %}
 9811 
 9812   ins_encode %{
 9813     __ blsiq($dst$$Register, $src$$Register);
 9814   %}
 9815   ins_pipe(ialu_reg);
 9816 %}
 9817 
 9818 instruct blsiL_rReg_mem(rRegL dst, memory src, immL0 imm_zero, rFlagsReg cr) %{
 9819   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
 9820   predicate(UseBMI1Instructions);
 9821   effect(KILL cr);
 9822 
 9823   ins_cost(125);
 9824   format %{ &quot;blsiq  $dst, $src&quot; %}
 9825 
 9826   ins_encode %{
 9827     __ blsiq($dst$$Register, $src$$Address);
 9828   %}
 9829   ins_pipe(ialu_reg_mem);
 9830 %}
 9831 
 9832 instruct blsmskL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9833 %{
 9834   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ) );
 9835   predicate(UseBMI1Instructions);
 9836   effect(KILL cr);
 9837 
 9838   ins_cost(125);
 9839   format %{ &quot;blsmskq $dst, $src&quot; %}
 9840 
 9841   ins_encode %{
 9842     __ blsmskq($dst$$Register, $src$$Address);
 9843   %}
 9844   ins_pipe(ialu_reg_mem);
 9845 %}
 9846 
 9847 instruct blsmskL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9848 %{
 9849   match(Set dst (XorL (AddL src minus_1) src));
 9850   predicate(UseBMI1Instructions);
 9851   effect(KILL cr);
 9852 
 9853   format %{ &quot;blsmskq $dst, $src&quot; %}
 9854 
 9855   ins_encode %{
 9856     __ blsmskq($dst$$Register, $src$$Register);
 9857   %}
 9858 
 9859   ins_pipe(ialu_reg);
 9860 %}
 9861 
 9862 instruct blsrL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9863 %{
 9864   match(Set dst (AndL (AddL src minus_1) src) );
 9865   predicate(UseBMI1Instructions);
 9866   effect(KILL cr);
 9867 
 9868   format %{ &quot;blsrq  $dst, $src&quot; %}
 9869 
 9870   ins_encode %{
 9871     __ blsrq($dst$$Register, $src$$Register);
 9872   %}
 9873 
 9874   ins_pipe(ialu_reg);
 9875 %}
 9876 
 9877 instruct blsrL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9878 %{
 9879   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src)) );
 9880   predicate(UseBMI1Instructions);
 9881   effect(KILL cr);
 9882 
 9883   ins_cost(125);
 9884   format %{ &quot;blsrq  $dst, $src&quot; %}
 9885 
 9886   ins_encode %{
 9887     __ blsrq($dst$$Register, $src$$Address);
 9888   %}
 9889 
 9890   ins_pipe(ialu_reg);
 9891 %}
 9892 
 9893 // Or Instructions
 9894 // Or Register with Register
 9895 instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9896 %{
 9897   match(Set dst (OrL dst src));
 9898   effect(KILL cr);
 9899 
 9900   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9901   opcode(0x0B);
 9902   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9903   ins_pipe(ialu_reg_reg);
 9904 %}
 9905 
 9906 // Use any_RegP to match R15 (TLS register) without spilling.
 9907 instruct orL_rReg_castP2X(rRegL dst, any_RegP src, rFlagsReg cr) %{
 9908   match(Set dst (OrL dst (CastP2X src)));
 9909   effect(KILL cr);
 9910 
 9911   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9912   opcode(0x0B);
 9913   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9914   ins_pipe(ialu_reg_reg);
 9915 %}
 9916 
 9917 
 9918 // Or Register with Immediate
 9919 instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9920 %{
 9921   match(Set dst (OrL dst src));
 9922   effect(KILL cr);
 9923 
 9924   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9925   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9926   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9927   ins_pipe(ialu_reg);
 9928 %}
 9929 
 9930 // Or Register with Memory
 9931 instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9932 %{
 9933   match(Set dst (OrL dst (LoadL src)));
 9934   effect(KILL cr);
 9935 
 9936   ins_cost(125);
 9937   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9938   opcode(0x0B);
 9939   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9940   ins_pipe(ialu_reg_mem);
 9941 %}
 9942 
 9943 // Or Memory with Register
 9944 instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 9945 %{
 9946   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
 9947   effect(KILL cr);
 9948 
 9949   ins_cost(150);
 9950   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9951   opcode(0x09); /* Opcode 09 /r */
 9952   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 9953   ins_pipe(ialu_mem_reg);
 9954 %}
 9955 
 9956 // Or Memory with Immediate
 9957 instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 9958 %{
 9959   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
 9960   effect(KILL cr);
 9961 
 9962   ins_cost(125);
 9963   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9964   opcode(0x81, 0x1); /* Opcode 81 /1 id */
 9965   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9966              RM_opc_mem(secondary, dst), Con8or32(src));
 9967   ins_pipe(ialu_mem_imm);
 9968 %}
 9969 
 9970 instruct btsL_mem_imm(memory dst, immL_Pow2 con, rFlagsReg cr)
 9971 %{
 9972   // con should be a pure 64-bit power of 2 immediate
 9973   // because AND/OR works well enough for 8/32-bit values.
 9974   predicate(log2_long(n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 31);
 9975 
 9976   match(Set dst (StoreL dst (OrL (LoadL dst) con)));
 9977   effect(KILL cr);
 9978 
 9979   ins_cost(125);
 9980   format %{ &quot;btsq    $dst, log2($con)\t# long&quot; %}
 9981   ins_encode %{
 9982     __ btsq($dst$$Address, log2_long((julong)$con$$constant));
 9983   %}
 9984   ins_pipe(ialu_mem_imm);
 9985 %}
 9986 
 9987 // Xor Instructions
 9988 // Xor Register with Register
 9989 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9990 %{
 9991   match(Set dst (XorL dst src));
 9992   effect(KILL cr);
 9993 
 9994   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
 9995   opcode(0x33);
 9996   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9997   ins_pipe(ialu_reg_reg);
 9998 %}
 9999 
10000 // Xor Register with Immediate -1
10001 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
10002   match(Set dst (XorL dst imm));
10003 
10004   format %{ &quot;notq   $dst&quot; %}
10005   ins_encode %{
10006      __ notq($dst$$Register);
10007   %}
10008   ins_pipe(ialu_reg);
10009 %}
10010 
10011 // Xor Register with Immediate
10012 instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
10013 %{
10014   match(Set dst (XorL dst src));
10015   effect(KILL cr);
10016 
10017   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10018   opcode(0x81, 0x06); /* Opcode 81 /6 id */
10019   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
10020   ins_pipe(ialu_reg);
10021 %}
10022 
10023 // Xor Register with Memory
10024 instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
10025 %{
10026   match(Set dst (XorL dst (LoadL src)));
10027   effect(KILL cr);
10028 
10029   ins_cost(125);
10030   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10031   opcode(0x33);
10032   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
10033   ins_pipe(ialu_reg_mem);
10034 %}
10035 
10036 // Xor Memory with Register
10037 instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
10038 %{
10039   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10040   effect(KILL cr);
10041 
10042   ins_cost(150);
10043   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10044   opcode(0x31); /* Opcode 31 /r */
10045   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10046   ins_pipe(ialu_mem_reg);
10047 %}
10048 
10049 // Xor Memory with Immediate
10050 instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10051 %{
10052   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10053   effect(KILL cr);
10054 
10055   ins_cost(125);
10056   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10057   opcode(0x81, 0x6); /* Opcode 81 /6 id */
10058   ins_encode(REX_mem_wide(dst), OpcSE(src),
10059              RM_opc_mem(secondary, dst), Con8or32(src));
10060   ins_pipe(ialu_mem_imm);
10061 %}
10062 
10063 // Convert Int to Boolean
10064 instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)
10065 %{
10066   match(Set dst (Conv2B src));
10067   effect(KILL cr);
10068 
10069   format %{ &quot;testl   $src, $src\t# ci2b\n\t&quot;
10070             &quot;setnz   $dst\n\t&quot;
10071             &quot;movzbl  $dst, $dst&quot; %}
10072   ins_encode(REX_reg_reg(src, src), opc_reg_reg(0x85, src, src), // testl
10073              setNZ_reg(dst),
10074              REX_reg_breg(dst, dst), // movzbl
10075              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10076   ins_pipe(pipe_slow); // XXX
10077 %}
10078 
10079 // Convert Pointer to Boolean
10080 instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)
10081 %{
10082   match(Set dst (Conv2B src));
10083   effect(KILL cr);
10084 
10085   format %{ &quot;testq   $src, $src\t# cp2b\n\t&quot;
10086             &quot;setnz   $dst\n\t&quot;
10087             &quot;movzbl  $dst, $dst&quot; %}
10088   ins_encode(REX_reg_reg_wide(src, src), opc_reg_reg(0x85, src, src), // testq
10089              setNZ_reg(dst),
10090              REX_reg_breg(dst, dst), // movzbl
10091              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10092   ins_pipe(pipe_slow); // XXX
10093 %}
10094 
10095 instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)
10096 %{
10097   match(Set dst (CmpLTMask p q));
10098   effect(KILL cr);
10099 
10100   ins_cost(400);
10101   format %{ &quot;cmpl    $p, $q\t# cmpLTMask\n\t&quot;
10102             &quot;setlt   $dst\n\t&quot;
10103             &quot;movzbl  $dst, $dst\n\t&quot;
10104             &quot;negl    $dst&quot; %}
10105   ins_encode(REX_reg_reg(p, q), opc_reg_reg(0x3B, p, q), // cmpl
10106              setLT_reg(dst),
10107              REX_reg_breg(dst, dst), // movzbl
10108              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst),
10109              neg_reg(dst));
10110   ins_pipe(pipe_slow);
10111 %}
10112 
10113 instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
10114 %{
10115   match(Set dst (CmpLTMask dst zero));
10116   effect(KILL cr);
10117 
10118   ins_cost(100);
10119   format %{ &quot;sarl    $dst, #31\t# cmpLTMask0&quot; %}
10120   ins_encode %{
10121   __ sarl($dst$$Register, 31);
10122   %}
10123   ins_pipe(ialu_reg);
10124 %}
10125 
10126 /* Better to save a register than avoid a branch */
10127 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10128 %{
10129   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
10130   effect(KILL cr);
10131   ins_cost(300);
10132   format %{ &quot;subl    $p,$q\t# cadd_cmpLTMask\n\t&quot;
10133             &quot;jge     done\n\t&quot;
10134             &quot;addl    $p,$y\n&quot;
10135             &quot;done:   &quot; %}
10136   ins_encode %{
10137     Register Rp = $p$$Register;
10138     Register Rq = $q$$Register;
10139     Register Ry = $y$$Register;
10140     Label done;
10141     __ subl(Rp, Rq);
10142     __ jccb(Assembler::greaterEqual, done);
10143     __ addl(Rp, Ry);
10144     __ bind(done);
10145   %}
10146   ins_pipe(pipe_cmplt);
10147 %}
10148 
10149 /* Better to save a register than avoid a branch */
10150 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10151 %{
10152   match(Set y (AndI (CmpLTMask p q) y));
10153   effect(KILL cr);
10154 
10155   ins_cost(300);
10156 
10157   format %{ &quot;cmpl    $p, $q\t# and_cmpLTMask\n\t&quot;
10158             &quot;jlt     done\n\t&quot;
10159             &quot;xorl    $y, $y\n&quot;
10160             &quot;done:   &quot; %}
10161   ins_encode %{
10162     Register Rp = $p$$Register;
10163     Register Rq = $q$$Register;
10164     Register Ry = $y$$Register;
10165     Label done;
10166     __ cmpl(Rp, Rq);
10167     __ jccb(Assembler::less, done);
10168     __ xorl(Ry, Ry);
10169     __ bind(done);
10170   %}
10171   ins_pipe(pipe_cmplt);
10172 %}
10173 
10174 
10175 //---------- FP Instructions------------------------------------------------
10176 
10177 instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)
10178 %{
10179   match(Set cr (CmpF src1 src2));
10180 
10181   ins_cost(145);
10182   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10183             &quot;jnp,s   exit\n\t&quot;
10184             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10185             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10186             &quot;popfq\n&quot;
10187     &quot;exit:&quot; %}
10188   ins_encode %{
10189     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10190     emit_cmpfp_fixup(_masm);
10191   %}
10192   ins_pipe(pipe_slow);
10193 %}
10194 
10195 instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{
10196   match(Set cr (CmpF src1 src2));
10197 
10198   ins_cost(100);
10199   format %{ &quot;ucomiss $src1, $src2&quot; %}
10200   ins_encode %{
10201     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10202   %}
10203   ins_pipe(pipe_slow);
10204 %}
10205 
10206 instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2)
10207 %{
10208   match(Set cr (CmpF src1 (LoadF src2)));
10209 
10210   ins_cost(145);
10211   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10212             &quot;jnp,s   exit\n\t&quot;
10213             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10214             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10215             &quot;popfq\n&quot;
10216     &quot;exit:&quot; %}
10217   ins_encode %{
10218     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10219     emit_cmpfp_fixup(_masm);
10220   %}
10221   ins_pipe(pipe_slow);
10222 %}
10223 
10224 instruct cmpF_cc_memCF(rFlagsRegUCF cr, regF src1, memory src2) %{
10225   match(Set cr (CmpF src1 (LoadF src2)));
10226 
10227   ins_cost(100);
10228   format %{ &quot;ucomiss $src1, $src2&quot; %}
10229   ins_encode %{
10230     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10231   %}
10232   ins_pipe(pipe_slow);
10233 %}
10234 
10235 instruct cmpF_cc_imm(rFlagsRegU cr, regF src, immF con) %{
10236   match(Set cr (CmpF src con));
10237 
10238   ins_cost(145);
10239   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10240             &quot;jnp,s   exit\n\t&quot;
10241             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10242             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10243             &quot;popfq\n&quot;
10244     &quot;exit:&quot; %}
10245   ins_encode %{
10246     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10247     emit_cmpfp_fixup(_masm);
10248   %}
10249   ins_pipe(pipe_slow);
10250 %}
10251 
10252 instruct cmpF_cc_immCF(rFlagsRegUCF cr, regF src, immF con) %{
10253   match(Set cr (CmpF src con));
10254   ins_cost(100);
10255   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con&quot; %}
10256   ins_encode %{
10257     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10258   %}
10259   ins_pipe(pipe_slow);
10260 %}
10261 
10262 instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2)
10263 %{
10264   match(Set cr (CmpD src1 src2));
10265 
10266   ins_cost(145);
10267   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10268             &quot;jnp,s   exit\n\t&quot;
10269             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10270             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10271             &quot;popfq\n&quot;
10272     &quot;exit:&quot; %}
10273   ins_encode %{
10274     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10275     emit_cmpfp_fixup(_masm);
10276   %}
10277   ins_pipe(pipe_slow);
10278 %}
10279 
10280 instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{
10281   match(Set cr (CmpD src1 src2));
10282 
10283   ins_cost(100);
10284   format %{ &quot;ucomisd $src1, $src2 test&quot; %}
10285   ins_encode %{
10286     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10287   %}
10288   ins_pipe(pipe_slow);
10289 %}
10290 
10291 instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2)
10292 %{
10293   match(Set cr (CmpD src1 (LoadD src2)));
10294 
10295   ins_cost(145);
10296   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10297             &quot;jnp,s   exit\n\t&quot;
10298             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10299             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10300             &quot;popfq\n&quot;
10301     &quot;exit:&quot; %}
10302   ins_encode %{
10303     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10304     emit_cmpfp_fixup(_masm);
10305   %}
10306   ins_pipe(pipe_slow);
10307 %}
10308 
10309 instruct cmpD_cc_memCF(rFlagsRegUCF cr, regD src1, memory src2) %{
10310   match(Set cr (CmpD src1 (LoadD src2)));
10311 
10312   ins_cost(100);
10313   format %{ &quot;ucomisd $src1, $src2&quot; %}
10314   ins_encode %{
10315     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10316   %}
10317   ins_pipe(pipe_slow);
10318 %}
10319 
10320 instruct cmpD_cc_imm(rFlagsRegU cr, regD src, immD con) %{
10321   match(Set cr (CmpD src con));
10322 
10323   ins_cost(145);
10324   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10325             &quot;jnp,s   exit\n\t&quot;
10326             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10327             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10328             &quot;popfq\n&quot;
10329     &quot;exit:&quot; %}
10330   ins_encode %{
10331     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10332     emit_cmpfp_fixup(_masm);
10333   %}
10334   ins_pipe(pipe_slow);
10335 %}
10336 
10337 instruct cmpD_cc_immCF(rFlagsRegUCF cr, regD src, immD con) %{
10338   match(Set cr (CmpD src con));
10339   ins_cost(100);
10340   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con&quot; %}
10341   ins_encode %{
10342     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10343   %}
10344   ins_pipe(pipe_slow);
10345 %}
10346 
10347 // Compare into -1,0,1
10348 instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)
10349 %{
10350   match(Set dst (CmpF3 src1 src2));
10351   effect(KILL cr);
10352 
10353   ins_cost(275);
10354   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10355             &quot;movl    $dst, #-1\n\t&quot;
10356             &quot;jp,s    done\n\t&quot;
10357             &quot;jb,s    done\n\t&quot;
10358             &quot;setne   $dst\n\t&quot;
10359             &quot;movzbl  $dst, $dst\n&quot;
10360     &quot;done:&quot; %}
10361   ins_encode %{
10362     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10363     emit_cmpfp3(_masm, $dst$$Register);
10364   %}
10365   ins_pipe(pipe_slow);
10366 %}
10367 
10368 // Compare into -1,0,1
10369 instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)
10370 %{
10371   match(Set dst (CmpF3 src1 (LoadF src2)));
10372   effect(KILL cr);
10373 
10374   ins_cost(275);
10375   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10376             &quot;movl    $dst, #-1\n\t&quot;
10377             &quot;jp,s    done\n\t&quot;
10378             &quot;jb,s    done\n\t&quot;
10379             &quot;setne   $dst\n\t&quot;
10380             &quot;movzbl  $dst, $dst\n&quot;
10381     &quot;done:&quot; %}
10382   ins_encode %{
10383     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10384     emit_cmpfp3(_masm, $dst$$Register);
10385   %}
10386   ins_pipe(pipe_slow);
10387 %}
10388 
10389 // Compare into -1,0,1
10390 instruct cmpF_imm(rRegI dst, regF src, immF con, rFlagsReg cr) %{
10391   match(Set dst (CmpF3 src con));
10392   effect(KILL cr);
10393 
10394   ins_cost(275);
10395   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10396             &quot;movl    $dst, #-1\n\t&quot;
10397             &quot;jp,s    done\n\t&quot;
10398             &quot;jb,s    done\n\t&quot;
10399             &quot;setne   $dst\n\t&quot;
10400             &quot;movzbl  $dst, $dst\n&quot;
10401     &quot;done:&quot; %}
10402   ins_encode %{
10403     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10404     emit_cmpfp3(_masm, $dst$$Register);
10405   %}
10406   ins_pipe(pipe_slow);
10407 %}
10408 
10409 // Compare into -1,0,1
10410 instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)
10411 %{
10412   match(Set dst (CmpD3 src1 src2));
10413   effect(KILL cr);
10414 
10415   ins_cost(275);
10416   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10417             &quot;movl    $dst, #-1\n\t&quot;
10418             &quot;jp,s    done\n\t&quot;
10419             &quot;jb,s    done\n\t&quot;
10420             &quot;setne   $dst\n\t&quot;
10421             &quot;movzbl  $dst, $dst\n&quot;
10422     &quot;done:&quot; %}
10423   ins_encode %{
10424     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10425     emit_cmpfp3(_masm, $dst$$Register);
10426   %}
10427   ins_pipe(pipe_slow);
10428 %}
10429 
10430 // Compare into -1,0,1
10431 instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)
10432 %{
10433   match(Set dst (CmpD3 src1 (LoadD src2)));
10434   effect(KILL cr);
10435 
10436   ins_cost(275);
10437   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10438             &quot;movl    $dst, #-1\n\t&quot;
10439             &quot;jp,s    done\n\t&quot;
10440             &quot;jb,s    done\n\t&quot;
10441             &quot;setne   $dst\n\t&quot;
10442             &quot;movzbl  $dst, $dst\n&quot;
10443     &quot;done:&quot; %}
10444   ins_encode %{
10445     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10446     emit_cmpfp3(_masm, $dst$$Register);
10447   %}
10448   ins_pipe(pipe_slow);
10449 %}
10450 
10451 // Compare into -1,0,1
10452 instruct cmpD_imm(rRegI dst, regD src, immD con, rFlagsReg cr) %{
10453   match(Set dst (CmpD3 src con));
10454   effect(KILL cr);
10455 
10456   ins_cost(275);
10457   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10458             &quot;movl    $dst, #-1\n\t&quot;
10459             &quot;jp,s    done\n\t&quot;
10460             &quot;jb,s    done\n\t&quot;
10461             &quot;setne   $dst\n\t&quot;
10462             &quot;movzbl  $dst, $dst\n&quot;
10463     &quot;done:&quot; %}
10464   ins_encode %{
10465     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10466     emit_cmpfp3(_masm, $dst$$Register);
10467   %}
10468   ins_pipe(pipe_slow);
10469 %}
10470 
10471 //----------Arithmetic Conversion Instructions---------------------------------
10472 
10473 instruct convF2D_reg_reg(regD dst, regF src)
10474 %{
10475   match(Set dst (ConvF2D src));
10476 
10477   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10478   ins_encode %{
10479     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10480   %}
10481   ins_pipe(pipe_slow); // XXX
10482 %}
10483 
10484 instruct convF2D_reg_mem(regD dst, memory src)
10485 %{
10486   match(Set dst (ConvF2D (LoadF src)));
10487 
10488   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10489   ins_encode %{
10490     __ cvtss2sd ($dst$$XMMRegister, $src$$Address);
10491   %}
10492   ins_pipe(pipe_slow); // XXX
10493 %}
10494 
10495 instruct convD2F_reg_reg(regF dst, regD src)
10496 %{
10497   match(Set dst (ConvD2F src));
10498 
10499   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10500   ins_encode %{
10501     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
10502   %}
10503   ins_pipe(pipe_slow); // XXX
10504 %}
10505 
10506 instruct convD2F_reg_mem(regF dst, memory src)
10507 %{
10508   match(Set dst (ConvD2F (LoadD src)));
10509 
10510   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10511   ins_encode %{
10512     __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);
10513   %}
10514   ins_pipe(pipe_slow); // XXX
10515 %}
10516 
10517 // XXX do mem variants
10518 instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
10519 %{
10520   match(Set dst (ConvF2I src));
10521   effect(KILL cr);
10522   format %{ &quot;convert_f2i $dst,$src&quot; %}
10523   ins_encode %{
10524     __ convert_f2i($dst$$Register, $src$$XMMRegister);
10525   %}
10526   ins_pipe(pipe_slow);
10527 %}
10528 
10529 instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
10530 %{
10531   match(Set dst (ConvF2L src));
10532   effect(KILL cr);
10533   format %{ &quot;convert_f2l $dst,$src&quot;%}
10534   ins_encode %{
10535     __ convert_f2l($dst$$Register, $src$$XMMRegister);
10536   %}
10537   ins_pipe(pipe_slow);
10538 %}
10539 
10540 instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
10541 %{
10542   match(Set dst (ConvD2I src));
10543   effect(KILL cr);
10544   format %{ &quot;convert_d2i $dst,$src&quot;%}
10545   ins_encode %{
10546     __ convert_d2i($dst$$Register, $src$$XMMRegister);
10547   %}
10548   ins_pipe(pipe_slow);
10549 %}
10550 
10551 instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
10552 %{
10553   match(Set dst (ConvD2L src));
10554   effect(KILL cr);
10555   format %{ &quot;convert_d2l $dst,$src&quot;%}
10556   ins_encode %{
10557     __ convert_d2l($dst$$Register, $src$$XMMRegister);
10558   %}
10559   ins_pipe(pipe_slow);
10560 %}
10561 
10562 instruct convI2F_reg_reg(regF dst, rRegI src)
10563 %{
10564   predicate(!UseXmmI2F);
10565   match(Set dst (ConvI2F src));
10566 
10567   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10568   ins_encode %{
10569     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
10570   %}
10571   ins_pipe(pipe_slow); // XXX
10572 %}
10573 
10574 instruct convI2F_reg_mem(regF dst, memory src)
10575 %{
10576   match(Set dst (ConvI2F (LoadI src)));
10577 
10578   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10579   ins_encode %{
10580     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Address);
10581   %}
10582   ins_pipe(pipe_slow); // XXX
10583 %}
10584 
10585 instruct convI2D_reg_reg(regD dst, rRegI src)
10586 %{
10587   predicate(!UseXmmI2D);
10588   match(Set dst (ConvI2D src));
10589 
10590   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10591   ins_encode %{
10592     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
10593   %}
10594   ins_pipe(pipe_slow); // XXX
10595 %}
10596 
10597 instruct convI2D_reg_mem(regD dst, memory src)
10598 %{
10599   match(Set dst (ConvI2D (LoadI src)));
10600 
10601   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10602   ins_encode %{
10603     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Address);
10604   %}
10605   ins_pipe(pipe_slow); // XXX
10606 %}
10607 
10608 instruct convXI2F_reg(regF dst, rRegI src)
10609 %{
10610   predicate(UseXmmI2F);
10611   match(Set dst (ConvI2F src));
10612 
10613   format %{ &quot;movdl $dst, $src\n\t&quot;
10614             &quot;cvtdq2psl $dst, $dst\t# i2f&quot; %}
10615   ins_encode %{
10616     __ movdl($dst$$XMMRegister, $src$$Register);
10617     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
10618   %}
10619   ins_pipe(pipe_slow); // XXX
10620 %}
10621 
10622 instruct convXI2D_reg(regD dst, rRegI src)
10623 %{
10624   predicate(UseXmmI2D);
10625   match(Set dst (ConvI2D src));
10626 
10627   format %{ &quot;movdl $dst, $src\n\t&quot;
10628             &quot;cvtdq2pdl $dst, $dst\t# i2d&quot; %}
10629   ins_encode %{
10630     __ movdl($dst$$XMMRegister, $src$$Register);
10631     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
10632   %}
10633   ins_pipe(pipe_slow); // XXX
10634 %}
10635 
10636 instruct convL2F_reg_reg(regF dst, rRegL src)
10637 %{
10638   match(Set dst (ConvL2F src));
10639 
10640   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10641   ins_encode %{
10642     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Register);
10643   %}
10644   ins_pipe(pipe_slow); // XXX
10645 %}
10646 
10647 instruct convL2F_reg_mem(regF dst, memory src)
10648 %{
10649   match(Set dst (ConvL2F (LoadL src)));
10650 
10651   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10652   ins_encode %{
10653     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Address);
10654   %}
10655   ins_pipe(pipe_slow); // XXX
10656 %}
10657 
10658 instruct convL2D_reg_reg(regD dst, rRegL src)
10659 %{
10660   match(Set dst (ConvL2D src));
10661 
10662   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10663   ins_encode %{
10664     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Register);
10665   %}
10666   ins_pipe(pipe_slow); // XXX
10667 %}
10668 
10669 instruct convL2D_reg_mem(regD dst, memory src)
10670 %{
10671   match(Set dst (ConvL2D (LoadL src)));
10672 
10673   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10674   ins_encode %{
10675     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Address);
10676   %}
10677   ins_pipe(pipe_slow); // XXX
10678 %}
10679 
10680 instruct convI2L_reg_reg(rRegL dst, rRegI src)
10681 %{
10682   match(Set dst (ConvI2L src));
10683 
10684   ins_cost(125);
10685   format %{ &quot;movslq  $dst, $src\t# i2l&quot; %}
10686   ins_encode %{
10687     __ movslq($dst$$Register, $src$$Register);
10688   %}
10689   ins_pipe(ialu_reg_reg);
10690 %}
10691 
10692 // instruct convI2L_reg_reg_foo(rRegL dst, rRegI src)
10693 // %{
10694 //   match(Set dst (ConvI2L src));
10695 // //   predicate(_kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_lo &gt;= 0 &amp;&amp;
10696 // //             _kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_hi &gt;= 0);
10697 //   predicate(((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi ==
10698 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi &amp;&amp;
10699 //             ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo ==
10700 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo);
10701 
10702 //   format %{ &quot;movl    $dst, $src\t# unsigned i2l&quot; %}
10703 //   ins_encode(enc_copy(dst, src));
10704 // //   opcode(0x63); // needs REX.W
10705 // //   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));
10706 //   ins_pipe(ialu_reg_reg);
10707 // %}
10708 
10709 // Zero-extend convert int to long
10710 instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)
10711 %{
10712   match(Set dst (AndL (ConvI2L src) mask));
10713 
10714   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10715   ins_encode %{
10716     if ($dst$$reg != $src$$reg) {
10717       __ movl($dst$$Register, $src$$Register);
10718     }
10719   %}
10720   ins_pipe(ialu_reg_reg);
10721 %}
10722 
10723 // Zero-extend convert int to long
10724 instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)
10725 %{
10726   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
10727 
10728   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10729   ins_encode %{
10730     __ movl($dst$$Register, $src$$Address);
10731   %}
10732   ins_pipe(ialu_reg_mem);
10733 %}
10734 
10735 instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)
10736 %{
10737   match(Set dst (AndL src mask));
10738 
10739   format %{ &quot;movl    $dst, $src\t# zero-extend long&quot; %}
10740   ins_encode %{
10741     __ movl($dst$$Register, $src$$Register);
10742   %}
10743   ins_pipe(ialu_reg_reg);
10744 %}
10745 
10746 instruct convL2I_reg_reg(rRegI dst, rRegL src)
10747 %{
10748   match(Set dst (ConvL2I src));
10749 
10750   format %{ &quot;movl    $dst, $src\t# l2i&quot; %}
10751   ins_encode %{
10752     __ movl($dst$$Register, $src$$Register);
10753   %}
10754   ins_pipe(ialu_reg_reg);
10755 %}
10756 
10757 
10758 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
10759   match(Set dst (MoveF2I src));
10760   effect(DEF dst, USE src);
10761 
10762   ins_cost(125);
10763   format %{ &quot;movl    $dst, $src\t# MoveF2I_stack_reg&quot; %}
10764   ins_encode %{
10765     __ movl($dst$$Register, Address(rsp, $src$$disp));
10766   %}
10767   ins_pipe(ialu_reg_mem);
10768 %}
10769 
10770 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
10771   match(Set dst (MoveI2F src));
10772   effect(DEF dst, USE src);
10773 
10774   ins_cost(125);
10775   format %{ &quot;movss   $dst, $src\t# MoveI2F_stack_reg&quot; %}
10776   ins_encode %{
10777     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
10778   %}
10779   ins_pipe(pipe_slow);
10780 %}
10781 
10782 instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{
10783   match(Set dst (MoveD2L src));
10784   effect(DEF dst, USE src);
10785 
10786   ins_cost(125);
10787   format %{ &quot;movq    $dst, $src\t# MoveD2L_stack_reg&quot; %}
10788   ins_encode %{
10789     __ movq($dst$$Register, Address(rsp, $src$$disp));
10790   %}
10791   ins_pipe(ialu_reg_mem);
10792 %}
10793 
10794 instruct MoveL2D_stack_reg_partial(regD dst, stackSlotL src) %{
10795   predicate(!UseXmmLoadAndClearUpper);
10796   match(Set dst (MoveL2D src));
10797   effect(DEF dst, USE src);
10798 
10799   ins_cost(125);
10800   format %{ &quot;movlpd  $dst, $src\t# MoveL2D_stack_reg&quot; %}
10801   ins_encode %{
10802     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10803   %}
10804   ins_pipe(pipe_slow);
10805 %}
10806 
10807 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
10808   predicate(UseXmmLoadAndClearUpper);
10809   match(Set dst (MoveL2D src));
10810   effect(DEF dst, USE src);
10811 
10812   ins_cost(125);
10813   format %{ &quot;movsd   $dst, $src\t# MoveL2D_stack_reg&quot; %}
10814   ins_encode %{
10815     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10816   %}
10817   ins_pipe(pipe_slow);
10818 %}
10819 
10820 
10821 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
10822   match(Set dst (MoveF2I src));
10823   effect(DEF dst, USE src);
10824 
10825   ins_cost(95); // XXX
10826   format %{ &quot;movss   $dst, $src\t# MoveF2I_reg_stack&quot; %}
10827   ins_encode %{
10828     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
10829   %}
10830   ins_pipe(pipe_slow);
10831 %}
10832 
10833 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
10834   match(Set dst (MoveI2F src));
10835   effect(DEF dst, USE src);
10836 
10837   ins_cost(100);
10838   format %{ &quot;movl    $dst, $src\t# MoveI2F_reg_stack&quot; %}
10839   ins_encode %{
10840     __ movl(Address(rsp, $dst$$disp), $src$$Register);
10841   %}
10842   ins_pipe( ialu_mem_reg );
10843 %}
10844 
10845 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
10846   match(Set dst (MoveD2L src));
10847   effect(DEF dst, USE src);
10848 
10849   ins_cost(95); // XXX
10850   format %{ &quot;movsd   $dst, $src\t# MoveL2D_reg_stack&quot; %}
10851   ins_encode %{
10852     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
10853   %}
10854   ins_pipe(pipe_slow);
10855 %}
10856 
10857 instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{
10858   match(Set dst (MoveL2D src));
10859   effect(DEF dst, USE src);
10860 
10861   ins_cost(100);
10862   format %{ &quot;movq    $dst, $src\t# MoveL2D_reg_stack&quot; %}
10863   ins_encode %{
10864     __ movq(Address(rsp, $dst$$disp), $src$$Register);
10865   %}
10866   ins_pipe(ialu_mem_reg);
10867 %}
10868 
10869 instruct MoveF2I_reg_reg(rRegI dst, regF src) %{
10870   match(Set dst (MoveF2I src));
10871   effect(DEF dst, USE src);
10872   ins_cost(85);
10873   format %{ &quot;movd    $dst,$src\t# MoveF2I&quot; %}
10874   ins_encode %{
10875     __ movdl($dst$$Register, $src$$XMMRegister);
10876   %}
10877   ins_pipe( pipe_slow );
10878 %}
10879 
10880 instruct MoveD2L_reg_reg(rRegL dst, regD src) %{
10881   match(Set dst (MoveD2L src));
10882   effect(DEF dst, USE src);
10883   ins_cost(85);
10884   format %{ &quot;movd    $dst,$src\t# MoveD2L&quot; %}
10885   ins_encode %{
10886     __ movdq($dst$$Register, $src$$XMMRegister);
10887   %}
10888   ins_pipe( pipe_slow );
10889 %}
10890 
10891 instruct MoveI2F_reg_reg(regF dst, rRegI src) %{
10892   match(Set dst (MoveI2F src));
10893   effect(DEF dst, USE src);
10894   ins_cost(100);
10895   format %{ &quot;movd    $dst,$src\t# MoveI2F&quot; %}
10896   ins_encode %{
10897     __ movdl($dst$$XMMRegister, $src$$Register);
10898   %}
10899   ins_pipe( pipe_slow );
10900 %}
10901 
10902 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10903   match(Set dst (MoveL2D src));
10904   effect(DEF dst, USE src);
10905   ins_cost(100);
10906   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
10907   ins_encode %{
10908      __ movdq($dst$$XMMRegister, $src$$Register);
10909   %}
10910   ins_pipe( pipe_slow );
10911 %}
10912 
10913 
10914 // =======================================================================
10915 // fast clearing of an array
<a name="12" id="anc12"></a><span class="line-modified">10916 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,</span>
10917                   Universe dummy, rFlagsReg cr)
10918 %{
<a name="13" id="anc13"></a><span class="line-modified">10919   predicate(!((ClearArrayNode*)n)-&gt;is_large());</span>
<span class="line-modified">10920   match(Set dummy (ClearArray cnt base));</span>
<span class="line-modified">10921   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);</span>
10922 
10923   format %{ $$template
<a name="14" id="anc14"></a><span class="line-removed">10924     $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;</span>
10925     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
10926     $$emit$$&quot;jg      LARGE\n\t&quot;
10927     $$emit$$&quot;dec     rcx\n\t&quot;
10928     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
10929     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
10930     $$emit$$&quot;dec     rcx\n\t&quot;
10931     $$emit$$&quot;jge     LOOP\n\t&quot;
10932     $$emit$$&quot;jmp     DONE\n\t&quot;
10933     $$emit$$&quot;# LARGE:\n\t&quot;
10934     if (UseFastStosb) {
10935        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10936        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
10937     } else if (UseXMMForObjInit) {
<a name="15" id="anc15"></a><span class="line-modified">10938        $$emit$$&quot;mov     rdi,rax\n\t&quot;</span>
<span class="line-modified">10939        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;</span>

10940        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10941        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
<a name="16" id="anc16"></a><span class="line-modified">10942        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
<span class="line-modified">10943        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;</span>
10944        $$emit$$&quot;add     0x40,rax\n\t&quot;
10945        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
10946        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
10947        $$emit$$&quot;jge     L_loop\n\t&quot;
10948        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10949        $$emit$$&quot;jl      L_tail\n\t&quot;
<a name="17" id="anc17"></a><span class="line-modified">10950        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
10951        $$emit$$&quot;add     0x20,rax\n\t&quot;
10952        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
10953        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
10954        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10955        $$emit$$&quot;jle     L_end\n\t&quot;
10956        $$emit$$&quot;dec     rcx\n\t&quot;
10957        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
10958        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
10959        $$emit$$&quot;add     0x8,rax\n\t&quot;
10960        $$emit$$&quot;dec     rcx\n\t&quot;
10961        $$emit$$&quot;jge     L_sloop\n\t&quot;
10962        $$emit$$&quot;# L_end:\n\t&quot;
10963     } else {
10964        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
10965     }
10966     $$emit$$&quot;# DONE&quot;
10967   %}
10968   ins_encode %{
<a name="18" id="anc18"></a><span class="line-modified">10969     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,</span>
<span class="line-modified">10970                  $tmp$$XMMRegister, false);</span>
10971   %}
10972   ins_pipe(pipe_slow);
10973 %}
10974 
<a name="19" id="anc19"></a><span class="line-modified">10975 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,</span>
























































10976                         Universe dummy, rFlagsReg cr)
10977 %{
<a name="20" id="anc20"></a><span class="line-modified">10978   predicate(((ClearArrayNode*)n)-&gt;is_large());</span>
<span class="line-modified">10979   match(Set dummy (ClearArray cnt base));</span>
<span class="line-modified">10980   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);</span>
10981 
10982   format %{ $$template
10983     if (UseFastStosb) {
<a name="21" id="anc21"></a><span class="line-removed">10984        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;</span>
10985        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10986        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
10987     } else if (UseXMMForObjInit) {
<a name="22" id="anc22"></a><span class="line-modified">10988        $$emit$$&quot;mov     rdi,rax\t# ClearArray:\n\t&quot;</span>
<span class="line-modified">10989        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;</span>

10990        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10991        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
<a name="23" id="anc23"></a><span class="line-modified">10992        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
<span class="line-modified">10993        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;</span>
10994        $$emit$$&quot;add     0x40,rax\n\t&quot;
10995        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
10996        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
10997        $$emit$$&quot;jge     L_loop\n\t&quot;
10998        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10999        $$emit$$&quot;jl      L_tail\n\t&quot;
<a name="24" id="anc24"></a><span class="line-modified">11000        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
11001        $$emit$$&quot;add     0x20,rax\n\t&quot;
11002        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11003        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11004        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11005        $$emit$$&quot;jle     L_end\n\t&quot;
11006        $$emit$$&quot;dec     rcx\n\t&quot;
11007        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11008        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11009        $$emit$$&quot;add     0x8,rax\n\t&quot;
11010        $$emit$$&quot;dec     rcx\n\t&quot;
11011        $$emit$$&quot;jge     L_sloop\n\t&quot;
11012        $$emit$$&quot;# L_end:\n\t&quot;
11013     } else {
<a name="25" id="anc25"></a><span class="line-removed">11014        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;</span>
11015        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11016     }
11017   %}
11018   ins_encode %{
<a name="26" id="anc26"></a><span class="line-modified">11019     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,</span>
<span class="line-modified">11020                  $tmp$$XMMRegister, true);</span>














































11021   %}
11022   ins_pipe(pipe_slow);
11023 %}
11024 
11025 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11026                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11027 %{
11028   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11029   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11030   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11031 
11032   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11033   ins_encode %{
11034     __ string_compare($str1$$Register, $str2$$Register,
11035                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11036                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11037   %}
11038   ins_pipe( pipe_slow );
11039 %}
11040 
11041 instruct string_compareU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11042                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11043 %{
11044   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11045   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11046   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11047 
11048   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11049   ins_encode %{
11050     __ string_compare($str1$$Register, $str2$$Register,
11051                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11052                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11053   %}
11054   ins_pipe( pipe_slow );
11055 %}
11056 
11057 instruct string_compareLU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11058                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11059 %{
11060   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11061   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11062   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11063 
11064   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11065   ins_encode %{
11066     __ string_compare($str1$$Register, $str2$$Register,
11067                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11068                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11069   %}
11070   ins_pipe( pipe_slow );
11071 %}
11072 
11073 instruct string_compareUL(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,
11074                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11075 %{
11076   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11077   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11078   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11079 
11080   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11081   ins_encode %{
11082     __ string_compare($str2$$Register, $str1$$Register,
11083                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11084                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11085   %}
11086   ins_pipe( pipe_slow );
11087 %}
11088 
11089 // fast search of substring with known size.
11090 instruct string_indexof_conL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11091                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11092 %{
11093   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11094   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11095   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11096 
11097   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11098   ins_encode %{
11099     int icnt2 = (int)$int_cnt2$$constant;
11100     if (icnt2 &gt;= 16) {
11101       // IndexOf for constant substrings with size &gt;= 16 elements
11102       // which don&#39;t need to be loaded through stack.
11103       __ string_indexofC8($str1$$Register, $str2$$Register,
11104                           $cnt1$$Register, $cnt2$$Register,
11105                           icnt2, $result$$Register,
11106                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11107     } else {
11108       // Small strings are loaded through stack if they cross page boundary.
11109       __ string_indexof($str1$$Register, $str2$$Register,
11110                         $cnt1$$Register, $cnt2$$Register,
11111                         icnt2, $result$$Register,
11112                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11113     }
11114   %}
11115   ins_pipe( pipe_slow );
11116 %}
11117 
11118 // fast search of substring with known size.
11119 instruct string_indexof_conU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11120                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11121 %{
11122   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11123   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11124   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11125 
11126   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11127   ins_encode %{
11128     int icnt2 = (int)$int_cnt2$$constant;
11129     if (icnt2 &gt;= 8) {
11130       // IndexOf for constant substrings with size &gt;= 8 elements
11131       // which don&#39;t need to be loaded through stack.
11132       __ string_indexofC8($str1$$Register, $str2$$Register,
11133                           $cnt1$$Register, $cnt2$$Register,
11134                           icnt2, $result$$Register,
11135                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11136     } else {
11137       // Small strings are loaded through stack if they cross page boundary.
11138       __ string_indexof($str1$$Register, $str2$$Register,
11139                         $cnt1$$Register, $cnt2$$Register,
11140                         icnt2, $result$$Register,
11141                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11142     }
11143   %}
11144   ins_pipe( pipe_slow );
11145 %}
11146 
11147 // fast search of substring with known size.
11148 instruct string_indexof_conUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11149                               rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11150 %{
11151   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11152   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11153   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11154 
11155   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11156   ins_encode %{
11157     int icnt2 = (int)$int_cnt2$$constant;
11158     if (icnt2 &gt;= 8) {
11159       // IndexOf for constant substrings with size &gt;= 8 elements
11160       // which don&#39;t need to be loaded through stack.
11161       __ string_indexofC8($str1$$Register, $str2$$Register,
11162                           $cnt1$$Register, $cnt2$$Register,
11163                           icnt2, $result$$Register,
11164                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11165     } else {
11166       // Small strings are loaded through stack if they cross page boundary.
11167       __ string_indexof($str1$$Register, $str2$$Register,
11168                         $cnt1$$Register, $cnt2$$Register,
11169                         icnt2, $result$$Register,
11170                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11171     }
11172   %}
11173   ins_pipe( pipe_slow );
11174 %}
11175 
11176 instruct string_indexofL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11177                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11178 %{
11179   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11180   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11181   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11182 
11183   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11184   ins_encode %{
11185     __ string_indexof($str1$$Register, $str2$$Register,
11186                       $cnt1$$Register, $cnt2$$Register,
11187                       (-1), $result$$Register,
11188                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11189   %}
11190   ins_pipe( pipe_slow );
11191 %}
11192 
11193 instruct string_indexofU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11194                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11195 %{
11196   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11197   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11198   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11199 
11200   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11201   ins_encode %{
11202     __ string_indexof($str1$$Register, $str2$$Register,
11203                       $cnt1$$Register, $cnt2$$Register,
11204                       (-1), $result$$Register,
11205                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11206   %}
11207   ins_pipe( pipe_slow );
11208 %}
11209 
11210 instruct string_indexofUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11211                           rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11212 %{
11213   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11214   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11215   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11216 
11217   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11218   ins_encode %{
11219     __ string_indexof($str1$$Register, $str2$$Register,
11220                       $cnt1$$Register, $cnt2$$Register,
11221                       (-1), $result$$Register,
11222                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11223   %}
11224   ins_pipe( pipe_slow );
11225 %}
11226 
11227 instruct string_indexofU_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,
11228                               rbx_RegI result, legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, rcx_RegI tmp, rFlagsReg cr)
11229 %{
11230   predicate(UseSSE42Intrinsics);
11231   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
11232   effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
11233   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11234   ins_encode %{
11235     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
11236                            $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister, $tmp$$Register);
11237   %}
11238   ins_pipe( pipe_slow );
11239 %}
11240 
11241 // fast string equals
11242 instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
11243                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11244 %{
11245   match(Set result (StrEquals (Binary str1 str2) cnt));
11246   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11247 
11248   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11249   ins_encode %{
11250     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11251                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11252                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11253   %}
11254   ins_pipe( pipe_slow );
11255 %}
11256 
11257 // fast array equals
11258 instruct array_equalsB(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11259                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11260 %{
11261   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11262   match(Set result (AryEq ary1 ary2));
11263   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11264 
11265   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11266   ins_encode %{
11267     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11268                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11269                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11270   %}
11271   ins_pipe( pipe_slow );
11272 %}
11273 
11274 instruct array_equalsC(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11275                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11276 %{
11277   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11278   match(Set result (AryEq ary1 ary2));
11279   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11280 
11281   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11282   ins_encode %{
11283     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11284                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11285                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11286   %}
11287   ins_pipe( pipe_slow );
11288 %}
11289 
11290 instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,
11291                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11292 %{
11293   match(Set result (HasNegatives ary1 len));
11294   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11295 
11296   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11297   ins_encode %{
11298     __ has_negatives($ary1$$Register, $len$$Register,
11299                      $result$$Register, $tmp3$$Register,
11300                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11301   %}
11302   ins_pipe( pipe_slow );
11303 %}
11304 
11305 // fast char[] to byte[] compression
11306 instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11307                          rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11308   match(Set result (StrCompressedCopy src (Binary dst len)));
11309   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11310 
11311   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11312   ins_encode %{
11313     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11314                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11315                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11316   %}
11317   ins_pipe( pipe_slow );
11318 %}
11319 
11320 // fast byte[] to char[] inflation
11321 instruct string_inflate(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11322                         legRegD tmp1, rcx_RegI tmp2, rFlagsReg cr) %{
11323   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11324   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11325 
11326   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11327   ins_encode %{
11328     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11329                           $tmp1$$XMMRegister, $tmp2$$Register);
11330   %}
11331   ins_pipe( pipe_slow );
11332 %}
11333 
11334 // encode char[] to byte[] in ISO_8859_1
11335 instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11336                           legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11337                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11338   match(Set result (EncodeISOArray src (Binary dst len)));
11339   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11340 
11341   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI &quot; %}
11342   ins_encode %{
11343     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11344                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11345                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11346   %}
11347   ins_pipe( pipe_slow );
11348 %}
11349 
11350 //----------Overflow Math Instructions-----------------------------------------
11351 
11352 instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11353 %{
11354   match(Set cr (OverflowAddI op1 op2));
11355   effect(DEF cr, USE_KILL op1, USE op2);
11356 
11357   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11358 
11359   ins_encode %{
11360     __ addl($op1$$Register, $op2$$Register);
11361   %}
11362   ins_pipe(ialu_reg_reg);
11363 %}
11364 
11365 instruct overflowAddI_rReg_imm(rFlagsReg cr, rax_RegI op1, immI op2)
11366 %{
11367   match(Set cr (OverflowAddI op1 op2));
11368   effect(DEF cr, USE_KILL op1, USE op2);
11369 
11370   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11371 
11372   ins_encode %{
11373     __ addl($op1$$Register, $op2$$constant);
11374   %}
11375   ins_pipe(ialu_reg_reg);
11376 %}
11377 
11378 instruct overflowAddL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11379 %{
11380   match(Set cr (OverflowAddL op1 op2));
11381   effect(DEF cr, USE_KILL op1, USE op2);
11382 
11383   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11384   ins_encode %{
11385     __ addq($op1$$Register, $op2$$Register);
11386   %}
11387   ins_pipe(ialu_reg_reg);
11388 %}
11389 
11390 instruct overflowAddL_rReg_imm(rFlagsReg cr, rax_RegL op1, immL32 op2)
11391 %{
11392   match(Set cr (OverflowAddL op1 op2));
11393   effect(DEF cr, USE_KILL op1, USE op2);
11394 
11395   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11396   ins_encode %{
11397     __ addq($op1$$Register, $op2$$constant);
11398   %}
11399   ins_pipe(ialu_reg_reg);
11400 %}
11401 
11402 instruct overflowSubI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11403 %{
11404   match(Set cr (OverflowSubI op1 op2));
11405 
11406   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11407   ins_encode %{
11408     __ cmpl($op1$$Register, $op2$$Register);
11409   %}
11410   ins_pipe(ialu_reg_reg);
11411 %}
11412 
11413 instruct overflowSubI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11414 %{
11415   match(Set cr (OverflowSubI op1 op2));
11416 
11417   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11418   ins_encode %{
11419     __ cmpl($op1$$Register, $op2$$constant);
11420   %}
11421   ins_pipe(ialu_reg_reg);
11422 %}
11423 
11424 instruct overflowSubL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11425 %{
11426   match(Set cr (OverflowSubL op1 op2));
11427 
11428   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11429   ins_encode %{
11430     __ cmpq($op1$$Register, $op2$$Register);
11431   %}
11432   ins_pipe(ialu_reg_reg);
11433 %}
11434 
11435 instruct overflowSubL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11436 %{
11437   match(Set cr (OverflowSubL op1 op2));
11438 
11439   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11440   ins_encode %{
11441     __ cmpq($op1$$Register, $op2$$constant);
11442   %}
11443   ins_pipe(ialu_reg_reg);
11444 %}
11445 
11446 instruct overflowNegI_rReg(rFlagsReg cr, immI0 zero, rax_RegI op2)
11447 %{
11448   match(Set cr (OverflowSubI zero op2));
11449   effect(DEF cr, USE_KILL op2);
11450 
11451   format %{ &quot;negl    $op2\t# overflow check int&quot; %}
11452   ins_encode %{
11453     __ negl($op2$$Register);
11454   %}
11455   ins_pipe(ialu_reg_reg);
11456 %}
11457 
11458 instruct overflowNegL_rReg(rFlagsReg cr, immL0 zero, rax_RegL op2)
11459 %{
11460   match(Set cr (OverflowSubL zero op2));
11461   effect(DEF cr, USE_KILL op2);
11462 
11463   format %{ &quot;negq    $op2\t# overflow check long&quot; %}
11464   ins_encode %{
11465     __ negq($op2$$Register);
11466   %}
11467   ins_pipe(ialu_reg_reg);
11468 %}
11469 
11470 instruct overflowMulI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11471 %{
11472   match(Set cr (OverflowMulI op1 op2));
11473   effect(DEF cr, USE_KILL op1, USE op2);
11474 
11475   format %{ &quot;imull    $op1, $op2\t# overflow check int&quot; %}
11476   ins_encode %{
11477     __ imull($op1$$Register, $op2$$Register);
11478   %}
11479   ins_pipe(ialu_reg_reg_alu0);
11480 %}
11481 
11482 instruct overflowMulI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
11483 %{
11484   match(Set cr (OverflowMulI op1 op2));
11485   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11486 
11487   format %{ &quot;imull    $tmp, $op1, $op2\t# overflow check int&quot; %}
11488   ins_encode %{
11489     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
11490   %}
11491   ins_pipe(ialu_reg_reg_alu0);
11492 %}
11493 
11494 instruct overflowMulL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11495 %{
11496   match(Set cr (OverflowMulL op1 op2));
11497   effect(DEF cr, USE_KILL op1, USE op2);
11498 
11499   format %{ &quot;imulq    $op1, $op2\t# overflow check long&quot; %}
11500   ins_encode %{
11501     __ imulq($op1$$Register, $op2$$Register);
11502   %}
11503   ins_pipe(ialu_reg_reg_alu0);
11504 %}
11505 
11506 instruct overflowMulL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2, rRegL tmp)
11507 %{
11508   match(Set cr (OverflowMulL op1 op2));
11509   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11510 
11511   format %{ &quot;imulq    $tmp, $op1, $op2\t# overflow check long&quot; %}
11512   ins_encode %{
11513     __ imulq($tmp$$Register, $op1$$Register, $op2$$constant);
11514   %}
11515   ins_pipe(ialu_reg_reg_alu0);
11516 %}
11517 
11518 
11519 //----------Control Flow Instructions------------------------------------------
11520 // Signed compare Instructions
11521 
11522 // XXX more variants!!
11523 instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11524 %{
11525   match(Set cr (CmpI op1 op2));
11526   effect(DEF cr, USE op1, USE op2);
11527 
11528   format %{ &quot;cmpl    $op1, $op2&quot; %}
11529   opcode(0x3B);  /* Opcode 3B /r */
11530   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11531   ins_pipe(ialu_cr_reg_reg);
11532 %}
11533 
11534 instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11535 %{
11536   match(Set cr (CmpI op1 op2));
11537 
11538   format %{ &quot;cmpl    $op1, $op2&quot; %}
11539   opcode(0x81, 0x07); /* Opcode 81 /7 */
11540   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11541   ins_pipe(ialu_cr_reg_imm);
11542 %}
11543 
11544 instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)
11545 %{
11546   match(Set cr (CmpI op1 (LoadI op2)));
11547 
11548   ins_cost(500); // XXX
11549   format %{ &quot;cmpl    $op1, $op2&quot; %}
11550   opcode(0x3B); /* Opcode 3B /r */
11551   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11552   ins_pipe(ialu_cr_reg_mem);
11553 %}
11554 
11555 instruct testI_reg(rFlagsReg cr, rRegI src, immI0 zero)
11556 %{
11557   match(Set cr (CmpI src zero));
11558 
11559   format %{ &quot;testl   $src, $src&quot; %}
11560   opcode(0x85);
11561   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11562   ins_pipe(ialu_cr_reg_imm);
11563 %}
11564 
11565 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11566 %{
11567   match(Set cr (CmpI (AndI src con) zero));
11568 
11569   format %{ &quot;testl   $src, $con&quot; %}
11570   opcode(0xF7, 0x00);
11571   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11572   ins_pipe(ialu_cr_reg_imm);
11573 %}
11574 
11575 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11576 %{
11577   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11578 
11579   format %{ &quot;testl   $src, $mem&quot; %}
11580   opcode(0x85);
11581   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11582   ins_pipe(ialu_cr_reg_mem);
11583 %}
11584 
<a name="27" id="anc27"></a>










11585 // Unsigned compare Instructions; really, same as signed except they
11586 // produce an rFlagsRegU instead of rFlagsReg.
11587 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11588 %{
11589   match(Set cr (CmpU op1 op2));
11590 
11591   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11592   opcode(0x3B); /* Opcode 3B /r */
11593   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11594   ins_pipe(ialu_cr_reg_reg);
11595 %}
11596 
11597 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11598 %{
11599   match(Set cr (CmpU op1 op2));
11600 
11601   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11602   opcode(0x81,0x07); /* Opcode 81 /7 */
11603   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11604   ins_pipe(ialu_cr_reg_imm);
11605 %}
11606 
11607 instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)
11608 %{
11609   match(Set cr (CmpU op1 (LoadI op2)));
11610 
11611   ins_cost(500); // XXX
11612   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11613   opcode(0x3B); /* Opcode 3B /r */
11614   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11615   ins_pipe(ialu_cr_reg_mem);
11616 %}
11617 
11618 // // // Cisc-spilled version of cmpU_rReg
11619 // //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)
11620 // //%{
11621 // //  match(Set cr (CmpU (LoadI op1) op2));
11622 // //
11623 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11624 // //  ins_cost(500);
11625 // //  opcode(0x39);  /* Opcode 39 /r */
11626 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11627 // //%}
11628 
11629 instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
11630 %{
11631   match(Set cr (CmpU src zero));
11632 
11633   format %{ &quot;testl   $src, $src\t# unsigned&quot; %}
11634   opcode(0x85);
11635   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11636   ins_pipe(ialu_cr_reg_imm);
11637 %}
11638 
11639 instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
11640 %{
11641   match(Set cr (CmpP op1 op2));
11642 
11643   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11644   opcode(0x3B); /* Opcode 3B /r */
11645   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11646   ins_pipe(ialu_cr_reg_reg);
11647 %}
11648 
11649 instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
11650 %{
11651   match(Set cr (CmpP op1 (LoadP op2)));
11652   predicate(n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11653 
11654   ins_cost(500); // XXX
11655   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11656   opcode(0x3B); /* Opcode 3B /r */
11657   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11658   ins_pipe(ialu_cr_reg_mem);
11659 %}
11660 
11661 // // // Cisc-spilled version of cmpP_rReg
11662 // //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)
11663 // //%{
11664 // //  match(Set cr (CmpP (LoadP op1) op2));
11665 // //
11666 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11667 // //  ins_cost(500);
11668 // //  opcode(0x39);  /* Opcode 39 /r */
11669 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11670 // //%}
11671 
11672 // XXX this is generalized by compP_rReg_mem???
11673 // Compare raw pointer (used in out-of-heap check).
11674 // Only works because non-oop pointers must be raw pointers
11675 // and raw pointers have no anti-dependencies.
11676 instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
11677 %{
11678   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none &amp;&amp;
11679             n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11680   match(Set cr (CmpP op1 (LoadP op2)));
11681 
11682   format %{ &quot;cmpq    $op1, $op2\t# raw ptr&quot; %}
11683   opcode(0x3B); /* Opcode 3B /r */
11684   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11685   ins_pipe(ialu_cr_reg_mem);
11686 %}
11687 
11688 // This will generate a signed flags result. This should be OK since
11689 // any compare to a zero should be eq/neq.
11690 instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
11691 %{
11692   match(Set cr (CmpP src zero));
11693 
11694   format %{ &quot;testq   $src, $src\t# ptr&quot; %}
11695   opcode(0x85);
11696   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11697   ins_pipe(ialu_cr_reg_imm);
11698 %}
11699 
11700 // This will generate a signed flags result. This should be OK since
11701 // any compare to a zero should be eq/neq.
11702 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
11703 %{
11704   predicate((!UseCompressedOops || (CompressedOops::base() != NULL)) &amp;&amp;
11705             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11706   match(Set cr (CmpP (LoadP op) zero));
11707 
11708   ins_cost(500); // XXX
11709   format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
11710   opcode(0xF7); /* Opcode F7 /0 */
11711   ins_encode(REX_mem_wide(op),
11712              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
11713   ins_pipe(ialu_cr_reg_imm);
11714 %}
11715 
11716 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
11717 %{
11718   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp;
11719             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11720   match(Set cr (CmpP (LoadP mem) zero));
11721 
11722   format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
11723   ins_encode %{
11724     __ cmpq(r12, $mem$$Address);
11725   %}
11726   ins_pipe(ialu_cr_reg_mem);
11727 %}
11728 
11729 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
11730 %{
11731   match(Set cr (CmpN op1 op2));
11732 
11733   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11734   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
11735   ins_pipe(ialu_cr_reg_reg);
11736 %}
11737 
11738 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
11739 %{
11740   match(Set cr (CmpN src (LoadN mem)));
11741 
11742   format %{ &quot;cmpl    $src, $mem\t# compressed ptr&quot; %}
11743   ins_encode %{
11744     __ cmpl($src$$Register, $mem$$Address);
11745   %}
11746   ins_pipe(ialu_cr_reg_mem);
11747 %}
11748 
11749 instruct compN_rReg_imm(rFlagsRegU cr, rRegN op1, immN op2) %{
11750   match(Set cr (CmpN op1 op2));
11751 
11752   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11753   ins_encode %{
11754     __ cmp_narrow_oop($op1$$Register, (jobject)$op2$$constant);
11755   %}
11756   ins_pipe(ialu_cr_reg_imm);
11757 %}
11758 
11759 instruct compN_mem_imm(rFlagsRegU cr, memory mem, immN src)
11760 %{
11761   match(Set cr (CmpN src (LoadN mem)));
11762 
11763   format %{ &quot;cmpl    $mem, $src\t# compressed ptr&quot; %}
11764   ins_encode %{
11765     __ cmp_narrow_oop($mem$$Address, (jobject)$src$$constant);
11766   %}
11767   ins_pipe(ialu_cr_reg_mem);
11768 %}
11769 
11770 instruct compN_rReg_imm_klass(rFlagsRegU cr, rRegN op1, immNKlass op2) %{
11771   match(Set cr (CmpN op1 op2));
11772 
11773   format %{ &quot;cmpl    $op1, $op2\t# compressed klass ptr&quot; %}
11774   ins_encode %{
11775     __ cmp_narrow_klass($op1$$Register, (Klass*)$op2$$constant);
11776   %}
11777   ins_pipe(ialu_cr_reg_imm);
11778 %}
11779 
11780 instruct compN_mem_imm_klass(rFlagsRegU cr, memory mem, immNKlass src)
11781 %{
11782   match(Set cr (CmpN src (LoadNKlass mem)));
11783 
11784   format %{ &quot;cmpl    $mem, $src\t# compressed klass ptr&quot; %}
11785   ins_encode %{
11786     __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);
11787   %}
11788   ins_pipe(ialu_cr_reg_mem);
11789 %}
11790 
11791 instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{
11792   match(Set cr (CmpN src zero));
11793 
11794   format %{ &quot;testl   $src, $src\t# compressed ptr&quot; %}
11795   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
11796   ins_pipe(ialu_cr_reg_imm);
11797 %}
11798 
11799 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
11800 %{
11801   predicate(CompressedOops::base() != NULL);
11802   match(Set cr (CmpN (LoadN mem) zero));
11803 
11804   ins_cost(500); // XXX
11805   format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
11806   ins_encode %{
11807     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
11808   %}
11809   ins_pipe(ialu_cr_reg_mem);
11810 %}
11811 
11812 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
11813 %{
11814   predicate(CompressedOops::base() == NULL);
11815   match(Set cr (CmpN (LoadN mem) zero));
11816 
11817   format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
11818   ins_encode %{
11819     __ cmpl(r12, $mem$$Address);
11820   %}
11821   ins_pipe(ialu_cr_reg_mem);
11822 %}
11823 
11824 // Yanked all unsigned pointer compare operations.
11825 // Pointer compares are done with CmpP which is already unsigned.
11826 
11827 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11828 %{
11829   match(Set cr (CmpL op1 op2));
11830 
11831   format %{ &quot;cmpq    $op1, $op2&quot; %}
11832   opcode(0x3B);  /* Opcode 3B /r */
11833   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11834   ins_pipe(ialu_cr_reg_reg);
11835 %}
11836 
11837 instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11838 %{
11839   match(Set cr (CmpL op1 op2));
11840 
11841   format %{ &quot;cmpq    $op1, $op2&quot; %}
11842   opcode(0x81, 0x07); /* Opcode 81 /7 */
11843   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
11844   ins_pipe(ialu_cr_reg_imm);
11845 %}
11846 
11847 instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)
11848 %{
11849   match(Set cr (CmpL op1 (LoadL op2)));
11850 
11851   format %{ &quot;cmpq    $op1, $op2&quot; %}
11852   opcode(0x3B); /* Opcode 3B /r */
11853   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11854   ins_pipe(ialu_cr_reg_mem);
11855 %}
11856 
11857 instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)
11858 %{
11859   match(Set cr (CmpL src zero));
11860 
11861   format %{ &quot;testq   $src, $src&quot; %}
11862   opcode(0x85);
11863   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11864   ins_pipe(ialu_cr_reg_imm);
11865 %}
11866 
11867 instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)
11868 %{
11869   match(Set cr (CmpL (AndL src con) zero));
11870 
11871   format %{ &quot;testq   $src, $con\t# long&quot; %}
11872   opcode(0xF7, 0x00);
11873   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src), Con32(con));
11874   ins_pipe(ialu_cr_reg_imm);
11875 %}
11876 
11877 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
11878 %{
11879   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
11880 
11881   format %{ &quot;testq   $src, $mem&quot; %}
11882   opcode(0x85);
11883   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11884   ins_pipe(ialu_cr_reg_mem);
11885 %}
11886 
11887 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
11888 %{
11889   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
11890 
11891   format %{ &quot;testq   $src, $mem&quot; %}
11892   opcode(0x85);
11893   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11894   ins_pipe(ialu_cr_reg_mem);
11895 %}
11896 
<a name="28" id="anc28"></a>










11897 // Manifest a CmpL result in an integer register.  Very painful.
11898 // This is the test to avoid.
11899 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
11900 %{
11901   match(Set dst (CmpL3 src1 src2));
11902   effect(KILL flags);
11903 
11904   ins_cost(275); // XXX
11905   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
11906             &quot;movl    $dst, -1\n\t&quot;
11907             &quot;jl,s    done\n\t&quot;
11908             &quot;setne   $dst\n\t&quot;
11909             &quot;movzbl  $dst, $dst\n\t&quot;
11910     &quot;done:&quot; %}
11911   ins_encode(cmpl3_flag(src1, src2, dst));
11912   ins_pipe(pipe_slow);
11913 %}
11914 
11915 // Unsigned long compare Instructions; really, same as signed long except they
11916 // produce an rFlagsRegU instead of rFlagsReg.
11917 instruct compUL_rReg(rFlagsRegU cr, rRegL op1, rRegL op2)
11918 %{
11919   match(Set cr (CmpUL op1 op2));
11920 
11921   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
11922   opcode(0x3B);  /* Opcode 3B /r */
11923   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11924   ins_pipe(ialu_cr_reg_reg);
11925 %}
11926 
11927 instruct compUL_rReg_imm(rFlagsRegU cr, rRegL op1, immL32 op2)
11928 %{
11929   match(Set cr (CmpUL op1 op2));
11930 
11931   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
11932   opcode(0x81, 0x07); /* Opcode 81 /7 */
11933   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
11934   ins_pipe(ialu_cr_reg_imm);
11935 %}
11936 
11937 instruct compUL_rReg_mem(rFlagsRegU cr, rRegL op1, memory op2)
11938 %{
11939   match(Set cr (CmpUL op1 (LoadL op2)));
11940 
11941   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
11942   opcode(0x3B); /* Opcode 3B /r */
11943   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11944   ins_pipe(ialu_cr_reg_mem);
11945 %}
11946 
11947 instruct testUL_reg(rFlagsRegU cr, rRegL src, immL0 zero)
11948 %{
11949   match(Set cr (CmpUL src zero));
11950 
11951   format %{ &quot;testq   $src, $src\t# unsigned&quot; %}
11952   opcode(0x85);
11953   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11954   ins_pipe(ialu_cr_reg_imm);
11955 %}
11956 
11957 instruct compB_mem_imm(rFlagsReg cr, memory mem, immI8 imm)
11958 %{
11959   match(Set cr (CmpI (LoadB mem) imm));
11960 
11961   ins_cost(125);
11962   format %{ &quot;cmpb    $mem, $imm&quot; %}
11963   ins_encode %{ __ cmpb($mem$$Address, $imm$$constant); %}
11964   ins_pipe(ialu_cr_reg_mem);
11965 %}
11966 
11967 instruct testUB_mem_imm(rFlagsReg cr, memory mem, immU8 imm, immI0 zero)
11968 %{
11969   match(Set cr (CmpI (AndI (LoadUB mem) imm) zero));
11970 
11971   ins_cost(125);
11972   format %{ &quot;testb   $mem, $imm\t# ubyte&quot; %}
11973   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
11974   ins_pipe(ialu_cr_reg_mem);
11975 %}
11976 
11977 instruct testB_mem_imm(rFlagsReg cr, memory mem, immI8 imm, immI0 zero)
11978 %{
11979   match(Set cr (CmpI (AndI (LoadB mem) imm) zero));
11980 
11981   ins_cost(125);
11982   format %{ &quot;testb   $mem, $imm\t# byte&quot; %}
11983   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
11984   ins_pipe(ialu_cr_reg_mem);
11985 %}
11986 
11987 //----------Max and Min--------------------------------------------------------
11988 // Min Instructions
11989 
11990 instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr)
11991 %{
11992   effect(USE_DEF dst, USE src, USE cr);
11993 
11994   format %{ &quot;cmovlgt $dst, $src\t# min&quot; %}
11995   opcode(0x0F, 0x4F);
11996   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
11997   ins_pipe(pipe_cmov_reg);
11998 %}
11999 
12000 
12001 instruct minI_rReg(rRegI dst, rRegI src)
12002 %{
12003   match(Set dst (MinI dst src));
12004 
12005   ins_cost(200);
12006   expand %{
12007     rFlagsReg cr;
12008     compI_rReg(cr, dst, src);
12009     cmovI_reg_g(dst, src, cr);
12010   %}
12011 %}
12012 
12013 instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr)
12014 %{
12015   effect(USE_DEF dst, USE src, USE cr);
12016 
12017   format %{ &quot;cmovllt $dst, $src\t# max&quot; %}
12018   opcode(0x0F, 0x4C);
12019   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12020   ins_pipe(pipe_cmov_reg);
12021 %}
12022 
12023 
12024 instruct maxI_rReg(rRegI dst, rRegI src)
12025 %{
12026   match(Set dst (MaxI dst src));
12027 
12028   ins_cost(200);
12029   expand %{
12030     rFlagsReg cr;
12031     compI_rReg(cr, dst, src);
12032     cmovI_reg_l(dst, src, cr);
12033   %}
12034 %}
12035 
12036 // ============================================================================
12037 // Branch Instructions
12038 
12039 // Jump Direct - Label defines a relative address from JMP+1
12040 instruct jmpDir(label labl)
12041 %{
12042   match(Goto);
12043   effect(USE labl);
12044 
12045   ins_cost(300);
12046   format %{ &quot;jmp     $labl&quot; %}
12047   size(5);
12048   ins_encode %{
12049     Label* L = $labl$$label;
12050     __ jmp(*L, false); // Always long jump
12051   %}
12052   ins_pipe(pipe_jmp);
12053 %}
12054 
12055 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12056 instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)
12057 %{
12058   match(If cop cr);
12059   effect(USE labl);
12060 
12061   ins_cost(300);
12062   format %{ &quot;j$cop     $labl&quot; %}
12063   size(6);
12064   ins_encode %{
12065     Label* L = $labl$$label;
12066     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12067   %}
12068   ins_pipe(pipe_jcc);
12069 %}
12070 
12071 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12072 instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)
12073 %{
12074   predicate(!n-&gt;has_vector_mask_set());
12075   match(CountedLoopEnd cop cr);
12076   effect(USE labl);
12077 
12078   ins_cost(300);
12079   format %{ &quot;j$cop     $labl\t# loop end&quot; %}
12080   size(6);
12081   ins_encode %{
12082     Label* L = $labl$$label;
12083     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12084   %}
12085   ins_pipe(pipe_jcc);
12086 %}
12087 
12088 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12089 instruct jmpLoopEndU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12090   predicate(!n-&gt;has_vector_mask_set());
12091   match(CountedLoopEnd cop cmp);
12092   effect(USE labl);
12093 
12094   ins_cost(300);
12095   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12096   size(6);
12097   ins_encode %{
12098     Label* L = $labl$$label;
12099     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12100   %}
12101   ins_pipe(pipe_jcc);
12102 %}
12103 
12104 instruct jmpLoopEndUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12105   predicate(!n-&gt;has_vector_mask_set());
12106   match(CountedLoopEnd cop cmp);
12107   effect(USE labl);
12108 
12109   ins_cost(200);
12110   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12111   size(6);
12112   ins_encode %{
12113     Label* L = $labl$$label;
12114     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12115   %}
12116   ins_pipe(pipe_jcc);
12117 %}
12118 
12119 // mask version
12120 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12121 instruct jmpLoopEnd_and_restoreMask(cmpOp cop, rFlagsReg cr, label labl)
12122 %{
12123   predicate(n-&gt;has_vector_mask_set());
12124   match(CountedLoopEnd cop cr);
12125   effect(USE labl);
12126 
12127   ins_cost(400);
12128   format %{ &quot;j$cop     $labl\t# loop end\n\t&quot;
12129             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12130   size(10);
12131   ins_encode %{
12132     Label* L = $labl$$label;
12133     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12134     __ restorevectmask();
12135   %}
12136   ins_pipe(pipe_jcc);
12137 %}
12138 
12139 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12140 instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12141   predicate(n-&gt;has_vector_mask_set());
12142   match(CountedLoopEnd cop cmp);
12143   effect(USE labl);
12144 
12145   ins_cost(400);
12146   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12147             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12148   size(10);
12149   ins_encode %{
12150     Label* L = $labl$$label;
12151     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12152     __ restorevectmask();
12153   %}
12154   ins_pipe(pipe_jcc);
12155 %}
12156 
12157 instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12158   predicate(n-&gt;has_vector_mask_set());
12159   match(CountedLoopEnd cop cmp);
12160   effect(USE labl);
12161 
12162   ins_cost(300);
12163   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12164             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12165   size(10);
12166   ins_encode %{
12167     Label* L = $labl$$label;
12168     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12169     __ restorevectmask();
12170   %}
12171   ins_pipe(pipe_jcc);
12172 %}
12173 
12174 // Jump Direct Conditional - using unsigned comparison
12175 instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12176   match(If cop cmp);
12177   effect(USE labl);
12178 
12179   ins_cost(300);
12180   format %{ &quot;j$cop,u   $labl&quot; %}
12181   size(6);
12182   ins_encode %{
12183     Label* L = $labl$$label;
12184     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12185   %}
12186   ins_pipe(pipe_jcc);
12187 %}
12188 
12189 instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12190   match(If cop cmp);
12191   effect(USE labl);
12192 
12193   ins_cost(200);
12194   format %{ &quot;j$cop,u   $labl&quot; %}
12195   size(6);
12196   ins_encode %{
12197     Label* L = $labl$$label;
12198     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12199   %}
12200   ins_pipe(pipe_jcc);
12201 %}
12202 
12203 instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12204   match(If cop cmp);
12205   effect(USE labl);
12206 
12207   ins_cost(200);
12208   format %{ $$template
12209     if ($cop$$cmpcode == Assembler::notEqual) {
12210       $$emit$$&quot;jp,u    $labl\n\t&quot;
12211       $$emit$$&quot;j$cop,u   $labl&quot;
12212     } else {
12213       $$emit$$&quot;jp,u    done\n\t&quot;
12214       $$emit$$&quot;j$cop,u   $labl\n\t&quot;
12215       $$emit$$&quot;done:&quot;
12216     }
12217   %}
12218   ins_encode %{
12219     Label* l = $labl$$label;
12220     if ($cop$$cmpcode == Assembler::notEqual) {
12221       __ jcc(Assembler::parity, *l, false);
12222       __ jcc(Assembler::notEqual, *l, false);
12223     } else if ($cop$$cmpcode == Assembler::equal) {
12224       Label done;
12225       __ jccb(Assembler::parity, done);
12226       __ jcc(Assembler::equal, *l, false);
12227       __ bind(done);
12228     } else {
12229        ShouldNotReachHere();
12230     }
12231   %}
12232   ins_pipe(pipe_jcc);
12233 %}
12234 
12235 // ============================================================================
12236 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary
12237 // superklass array for an instance of the superklass.  Set a hidden
12238 // internal cache on a hit (cache is checked with exposed code in
12239 // gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
12240 // encoding ALSO sets flags.
12241 
12242 instruct partialSubtypeCheck(rdi_RegP result,
12243                              rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12244                              rFlagsReg cr)
12245 %{
12246   match(Set result (PartialSubtypeCheck sub super));
12247   effect(KILL rcx, KILL cr);
12248 
12249   ins_cost(1100);  // slightly larger than the next version
12250   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12251             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12252             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12253             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while rcx--\n\t&quot;
12254             &quot;jne,s   miss\t\t# Missed: rdi not-zero\n\t&quot;
12255             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12256             &quot;xorq    $result, $result\t\t Hit: rdi zero\n\t&quot;
12257     &quot;miss:\t&quot; %}
12258 
12259   opcode(0x1); // Force a XOR of RDI
12260   ins_encode(enc_PartialSubtypeCheck());
12261   ins_pipe(pipe_slow);
12262 %}
12263 
12264 instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,
12265                                      rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12266                                      immP0 zero,
12267                                      rdi_RegP result)
12268 %{
12269   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
12270   effect(KILL rcx, KILL result);
12271 
12272   ins_cost(1000);
12273   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12274             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12275             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12276             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while cx-- != 0\n\t&quot;
12277             &quot;jne,s   miss\t\t# Missed: flags nz\n\t&quot;
12278             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12279     &quot;miss:\t&quot; %}
12280 
12281   opcode(0x0); // No need to XOR RDI
12282   ins_encode(enc_PartialSubtypeCheck());
12283   ins_pipe(pipe_slow);
12284 %}
12285 
12286 // ============================================================================
12287 // Branch Instructions -- short offset versions
12288 //
12289 // These instructions are used to replace jumps of a long offset (the default
12290 // match) with jumps of a shorter offset.  These instructions are all tagged
12291 // with the ins_short_branch attribute, which causes the ADLC to suppress the
12292 // match rules in general matching.  Instead, the ADLC generates a conversion
12293 // method in the MachNode which can be used to do in-place replacement of the
12294 // long variant with the shorter variant.  The compiler will determine if a
12295 // branch can be taken by the is_short_branch_offset() predicate in the machine
12296 // specific code section of the file.
12297 
12298 // Jump Direct - Label defines a relative address from JMP+1
12299 instruct jmpDir_short(label labl) %{
12300   match(Goto);
12301   effect(USE labl);
12302 
12303   ins_cost(300);
12304   format %{ &quot;jmp,s   $labl&quot; %}
12305   size(2);
12306   ins_encode %{
12307     Label* L = $labl$$label;
12308     __ jmpb(*L);
12309   %}
12310   ins_pipe(pipe_jmp);
12311   ins_short_branch(1);
12312 %}
12313 
12314 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12315 instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) %{
12316   match(If cop cr);
12317   effect(USE labl);
12318 
12319   ins_cost(300);
12320   format %{ &quot;j$cop,s   $labl&quot; %}
12321   size(2);
12322   ins_encode %{
12323     Label* L = $labl$$label;
12324     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12325   %}
12326   ins_pipe(pipe_jcc);
12327   ins_short_branch(1);
12328 %}
12329 
12330 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12331 instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl) %{
12332   match(CountedLoopEnd cop cr);
12333   effect(USE labl);
12334 
12335   ins_cost(300);
12336   format %{ &quot;j$cop,s   $labl\t# loop end&quot; %}
12337   size(2);
12338   ins_encode %{
12339     Label* L = $labl$$label;
12340     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12341   %}
12342   ins_pipe(pipe_jcc);
12343   ins_short_branch(1);
12344 %}
12345 
12346 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12347 instruct jmpLoopEndU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12348   match(CountedLoopEnd cop cmp);
12349   effect(USE labl);
12350 
12351   ins_cost(300);
12352   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12353   size(2);
12354   ins_encode %{
12355     Label* L = $labl$$label;
12356     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12357   %}
12358   ins_pipe(pipe_jcc);
12359   ins_short_branch(1);
12360 %}
12361 
12362 instruct jmpLoopEndUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12363   match(CountedLoopEnd cop cmp);
12364   effect(USE labl);
12365 
12366   ins_cost(300);
12367   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12368   size(2);
12369   ins_encode %{
12370     Label* L = $labl$$label;
12371     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12372   %}
12373   ins_pipe(pipe_jcc);
12374   ins_short_branch(1);
12375 %}
12376 
12377 // Jump Direct Conditional - using unsigned comparison
12378 instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12379   match(If cop cmp);
12380   effect(USE labl);
12381 
12382   ins_cost(300);
12383   format %{ &quot;j$cop,us  $labl&quot; %}
12384   size(2);
12385   ins_encode %{
12386     Label* L = $labl$$label;
12387     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12388   %}
12389   ins_pipe(pipe_jcc);
12390   ins_short_branch(1);
12391 %}
12392 
12393 instruct jmpConUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12394   match(If cop cmp);
12395   effect(USE labl);
12396 
12397   ins_cost(300);
12398   format %{ &quot;j$cop,us  $labl&quot; %}
12399   size(2);
12400   ins_encode %{
12401     Label* L = $labl$$label;
12402     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12403   %}
12404   ins_pipe(pipe_jcc);
12405   ins_short_branch(1);
12406 %}
12407 
12408 instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12409   match(If cop cmp);
12410   effect(USE labl);
12411 
12412   ins_cost(300);
12413   format %{ $$template
12414     if ($cop$$cmpcode == Assembler::notEqual) {
12415       $$emit$$&quot;jp,u,s  $labl\n\t&quot;
12416       $$emit$$&quot;j$cop,u,s  $labl&quot;
12417     } else {
12418       $$emit$$&quot;jp,u,s  done\n\t&quot;
12419       $$emit$$&quot;j$cop,u,s  $labl\n\t&quot;
12420       $$emit$$&quot;done:&quot;
12421     }
12422   %}
12423   size(4);
12424   ins_encode %{
12425     Label* l = $labl$$label;
12426     if ($cop$$cmpcode == Assembler::notEqual) {
12427       __ jccb(Assembler::parity, *l);
12428       __ jccb(Assembler::notEqual, *l);
12429     } else if ($cop$$cmpcode == Assembler::equal) {
12430       Label done;
12431       __ jccb(Assembler::parity, done);
12432       __ jccb(Assembler::equal, *l);
12433       __ bind(done);
12434     } else {
12435        ShouldNotReachHere();
12436     }
12437   %}
12438   ins_pipe(pipe_jcc);
12439   ins_short_branch(1);
12440 %}
12441 
12442 // ============================================================================
12443 // inlined locking and unlocking
12444 
12445 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
12446   predicate(Compile::current()-&gt;use_rtm());
12447   match(Set cr (FastLock object box));
12448   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
12449   ins_cost(300);
12450   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
12451   ins_encode %{
12452     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12453                  $scr$$Register, $cx1$$Register, $cx2$$Register,
12454                  _counters, _rtm_counters, _stack_rtm_counters,
12455                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12456                  true, ra_-&gt;C-&gt;profile_rtm());
12457   %}
12458   ins_pipe(pipe_slow);
12459 %}
12460 
12461 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr, rRegP cx1) %{
12462   predicate(!Compile::current()-&gt;use_rtm());
12463   match(Set cr (FastLock object box));
12464   effect(TEMP tmp, TEMP scr, TEMP cx1, USE_KILL box);
12465   ins_cost(300);
12466   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr&quot; %}
12467   ins_encode %{
12468     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12469                  $scr$$Register, $cx1$$Register, noreg, _counters, NULL, NULL, NULL, false, false);
12470   %}
12471   ins_pipe(pipe_slow);
12472 %}
12473 
12474 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12475   match(Set cr (FastUnlock object box));
12476   effect(TEMP tmp, USE_KILL box);
12477   ins_cost(300);
12478   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12479   ins_encode %{
12480     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12481   %}
12482   ins_pipe(pipe_slow);
12483 %}
12484 
12485 
12486 // ============================================================================
12487 // Safepoint Instructions
12488 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12489 %{
12490   match(SafePoint poll);
12491   effect(KILL cr, USE poll);
12492 
12493   format %{ &quot;testl   rax, [$poll]\t&quot;
12494             &quot;# Safepoint: poll for GC&quot; %}
12495   ins_cost(125);
12496   size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
12497   ins_encode %{
12498     __ relocate(relocInfo::poll_type);
12499     address pre_pc = __ pc();
12500     __ testl(rax, Address($poll$$Register, 0));
12501     assert(nativeInstruction_at(pre_pc)-&gt;is_safepoint_poll(), &quot;must emit test %%eax [reg]&quot;);
12502   %}
12503   ins_pipe(ialu_reg_mem);
12504 %}
12505 
12506 // ============================================================================
12507 // Procedure Call/Return Instructions
12508 // Call Java Static Instruction
12509 // Note: If this code changes, the corresponding ret_addr_offset() and
12510 //       compute_padding() functions will have to be adjusted.
12511 instruct CallStaticJavaDirect(method meth) %{
12512   match(CallStaticJava);
12513   effect(USE meth);
12514 
12515   ins_cost(300);
12516   format %{ &quot;call,static &quot; %}
12517   opcode(0xE8); /* E8 cd */
12518   ins_encode(clear_avx, Java_Static_Call(meth), call_epilog);
12519   ins_pipe(pipe_slow);
12520   ins_alignment(4);
12521 %}
12522 
12523 // Call Java Dynamic Instruction
12524 // Note: If this code changes, the corresponding ret_addr_offset() and
12525 //       compute_padding() functions will have to be adjusted.
12526 instruct CallDynamicJavaDirect(method meth)
12527 %{
12528   match(CallDynamicJava);
12529   effect(USE meth);
12530 
12531   ins_cost(300);
12532   format %{ &quot;movq    rax, #Universe::non_oop_word()\n\t&quot;
12533             &quot;call,dynamic &quot; %}
12534   ins_encode(clear_avx, Java_Dynamic_Call(meth), call_epilog);
12535   ins_pipe(pipe_slow);
12536   ins_alignment(4);
12537 %}
12538 
12539 // Call Runtime Instruction
12540 instruct CallRuntimeDirect(method meth)
12541 %{
12542   match(CallRuntime);
12543   effect(USE meth);
12544 
12545   ins_cost(300);
12546   format %{ &quot;call,runtime &quot; %}
12547   ins_encode(clear_avx, Java_To_Runtime(meth));
12548   ins_pipe(pipe_slow);
12549 %}
12550 
12551 // Call runtime without safepoint
12552 instruct CallLeafDirect(method meth)
12553 %{
12554   match(CallLeaf);
12555   effect(USE meth);
12556 
12557   ins_cost(300);
12558   format %{ &quot;call_leaf,runtime &quot; %}
12559   ins_encode(clear_avx, Java_To_Runtime(meth));
12560   ins_pipe(pipe_slow);
12561 %}
12562 
12563 // Call runtime without safepoint
<a name="29" id="anc29"></a>














12564 instruct CallLeafNoFPDirect(method meth)
12565 %{
<a name="30" id="anc30"></a>
12566   match(CallLeafNoFP);
12567   effect(USE meth);
12568 
12569   ins_cost(300);
12570   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12571   ins_encode(clear_avx, Java_To_Runtime(meth));
12572   ins_pipe(pipe_slow);
12573 %}
12574 
12575 // Return Instruction
12576 // Remove the return address &amp; jump to it.
12577 // Notice: We always emit a nop after a ret to make sure there is room
12578 // for safepoint patching
12579 instruct Ret()
12580 %{
12581   match(Return);
12582 
12583   format %{ &quot;ret&quot; %}
12584   opcode(0xC3);
12585   ins_encode(OpcP);
12586   ins_pipe(pipe_jmp);
12587 %}
12588 
12589 // Tail Call; Jump from runtime stub to Java code.
12590 // Also known as an &#39;interprocedural jump&#39;.
12591 // Target of jump will eventually return to caller.
12592 // TailJump below removes the return address.
12593 instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_oop)
12594 %{
12595   match(TailCall jump_target method_oop);
12596 
12597   ins_cost(300);
12598   format %{ &quot;jmp     $jump_target\t# rbx holds method oop&quot; %}
12599   opcode(0xFF, 0x4); /* Opcode FF /4 */
12600   ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));
12601   ins_pipe(pipe_jmp);
12602 %}
12603 
12604 // Tail Jump; remove the return address; jump to target.
12605 // TailCall above leaves the return address around.
12606 instruct tailjmpInd(no_rbp_RegP jump_target, rax_RegP ex_oop)
12607 %{
12608   match(TailJump jump_target ex_oop);
12609 
12610   ins_cost(300);
12611   format %{ &quot;popq    rdx\t# pop return address\n\t&quot;
12612             &quot;jmp     $jump_target&quot; %}
12613   opcode(0xFF, 0x4); /* Opcode FF /4 */
12614   ins_encode(Opcode(0x5a), // popq rdx
12615              REX_reg(jump_target), OpcP, reg_opc(jump_target));
12616   ins_pipe(pipe_jmp);
12617 %}
12618 
12619 // Create exception oop: created by stack-crawling runtime code.
12620 // Created exception is now available to this handler, and is setup
12621 // just prior to jumping to this handler.  No code emitted.
12622 instruct CreateException(rax_RegP ex_oop)
12623 %{
12624   match(Set ex_oop (CreateEx));
12625 
12626   size(0);
12627   // use the following format syntax
12628   format %{ &quot;# exception oop is in rax; no code emitted&quot; %}
12629   ins_encode();
12630   ins_pipe(empty);
12631 %}
12632 
12633 // Rethrow exception:
12634 // The exception oop will come in the first argument position.
12635 // Then JUMP (not call) to the rethrow stub code.
12636 instruct RethrowException()
12637 %{
12638   match(Rethrow);
12639 
12640   // use the following format syntax
12641   format %{ &quot;jmp     rethrow_stub&quot; %}
12642   ins_encode(enc_rethrow);
12643   ins_pipe(pipe_jmp);
12644 %}
12645 
12646 // ============================================================================
12647 // This name is KNOWN by the ADLC and cannot be changed.
12648 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
12649 // for this guy.
12650 instruct tlsLoadP(r15_RegP dst) %{
12651   match(Set dst (ThreadLocal));
12652   effect(DEF dst);
12653 
12654   size(0);
12655   format %{ &quot;# TLS is in R15&quot; %}
12656   ins_encode( /*empty encoding*/ );
12657   ins_pipe(ialu_reg_reg);
12658 %}
12659 
12660 
12661 //----------PEEPHOLE RULES-----------------------------------------------------
12662 // These must follow all instruction definitions as they use the names
12663 // defined in the instructions definitions.
12664 //
12665 // peepmatch ( root_instr_name [preceding_instruction]* );
12666 //
12667 // peepconstraint %{
12668 // (instruction_number.operand_name relational_op instruction_number.operand_name
12669 //  [, ...] );
12670 // // instruction numbers are zero-based using left to right order in peepmatch
12671 //
12672 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
12673 // // provide an instruction_number.operand_name for each operand that appears
12674 // // in the replacement instruction&#39;s match rule
12675 //
12676 // ---------VM FLAGS---------------------------------------------------------
12677 //
12678 // All peephole optimizations can be turned off using -XX:-OptoPeephole
12679 //
12680 // Each peephole rule is given an identifying number starting with zero and
12681 // increasing by one in the order seen by the parser.  An individual peephole
12682 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
12683 // on the command-line.
12684 //
12685 // ---------CURRENT LIMITATIONS----------------------------------------------
12686 //
12687 // Only match adjacent instructions in same basic block
12688 // Only equality constraints
12689 // Only constraints between operands, not (0.dest_reg == RAX_enc)
12690 // Only one replacement instruction
12691 //
12692 // ---------EXAMPLE----------------------------------------------------------
12693 //
12694 // // pertinent parts of existing instructions in architecture description
12695 // instruct movI(rRegI dst, rRegI src)
12696 // %{
12697 //   match(Set dst (CopyI src));
12698 // %}
12699 //
12700 // instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
12701 // %{
12702 //   match(Set dst (AddI dst src));
12703 //   effect(KILL cr);
12704 // %}
12705 //
12706 // // Change (inc mov) to lea
12707 // peephole %{
12708 //   // increment preceeded by register-register move
12709 //   peepmatch ( incI_rReg movI );
12710 //   // require that the destination register of the increment
12711 //   // match the destination register of the move
12712 //   peepconstraint ( 0.dst == 1.dst );
12713 //   // construct a replacement instruction that sets
12714 //   // the destination to ( move&#39;s source register + one )
12715 //   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );
12716 // %}
12717 //
12718 
12719 // Implementation no longer uses movX instructions since
12720 // machine-independent system no longer uses CopyX nodes.
12721 //
12722 // peephole
12723 // %{
12724 //   peepmatch (incI_rReg movI);
12725 //   peepconstraint (0.dst == 1.dst);
12726 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12727 // %}
12728 
12729 // peephole
12730 // %{
12731 //   peepmatch (decI_rReg movI);
12732 //   peepconstraint (0.dst == 1.dst);
12733 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12734 // %}
12735 
12736 // peephole
12737 // %{
12738 //   peepmatch (addI_rReg_imm movI);
12739 //   peepconstraint (0.dst == 1.dst);
12740 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12741 // %}
12742 
12743 // peephole
12744 // %{
12745 //   peepmatch (incL_rReg movL);
12746 //   peepconstraint (0.dst == 1.dst);
12747 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12748 // %}
12749 
12750 // peephole
12751 // %{
12752 //   peepmatch (decL_rReg movL);
12753 //   peepconstraint (0.dst == 1.dst);
12754 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12755 // %}
12756 
12757 // peephole
12758 // %{
12759 //   peepmatch (addL_rReg_imm movL);
12760 //   peepconstraint (0.dst == 1.dst);
12761 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12762 // %}
12763 
12764 // peephole
12765 // %{
12766 //   peepmatch (addP_rReg_imm movP);
12767 //   peepconstraint (0.dst == 1.dst);
12768 //   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));
12769 // %}
12770 
12771 // // Change load of spilled value to only a spill
12772 // instruct storeI(memory mem, rRegI src)
12773 // %{
12774 //   match(Set mem (StoreI mem src));
12775 // %}
12776 //
12777 // instruct loadI(rRegI dst, memory mem)
12778 // %{
12779 //   match(Set dst (LoadI mem));
12780 // %}
12781 //
12782 
12783 peephole
12784 %{
12785   peepmatch (loadI storeI);
12786   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
12787   peepreplace (storeI(1.mem 1.mem 1.src));
12788 %}
12789 
12790 peephole
12791 %{
12792   peepmatch (loadL storeL);
12793   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
12794   peepreplace (storeL(1.mem 1.mem 1.src));
12795 %}
12796 
12797 //----------SMARTSPILL RULES---------------------------------------------------
12798 // These must follow all instruction definitions as they use the names
12799 // defined in the instructions definitions.
<a name="31" id="anc31"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="31" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/classfile/fieldLayoutBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoaderData.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldLayoutBuilder.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/fieldLayoutBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 29,16 ***</span>
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/array.hpp&quot;
  #include &quot;oops/fieldStreams.inline.hpp&quot;
  #include &quot;oops/instanceMirrorKlass.hpp&quot;
  #include &quot;oops/klass.inline.hpp&quot;
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  
<span class="line-removed">- </span>
  LayoutRawBlock::LayoutRawBlock(Kind kind, int size) :
    _next_block(NULL),
    _prev_block(NULL),
    _kind(kind),
    _offset(-1),
    _alignment(1),
    _size(size),
    _field_index(-1),
<span class="line-new-header">--- 29,17 ---</span>
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;oops/array.hpp&quot;
  #include &quot;oops/fieldStreams.inline.hpp&quot;
  #include &quot;oops/instanceMirrorKlass.hpp&quot;
  #include &quot;oops/klass.inline.hpp&quot;
<span class="line-added">+ #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  
  LayoutRawBlock::LayoutRawBlock(Kind kind, int size) :
    _next_block(NULL),
    _prev_block(NULL),
<span class="line-added">+   _value_klass(NULL),</span>
    _kind(kind),
    _offset(-1),
    _alignment(1),
    _size(size),
    _field_index(-1),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 50,10 ***</span>
<span class="line-new-header">--- 51,11 ---</span>
  
  
  LayoutRawBlock::LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference) :
   _next_block(NULL),
   _prev_block(NULL),
<span class="line-added">+  _value_klass(NULL),</span>
   _kind(kind),
   _offset(-1),
   _alignment(alignment),
   _size(size),
   _field_index(index),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 74,10 ***</span>
<span class="line-new-header">--- 76,11 ---</span>
  
  FieldGroup::FieldGroup(int contended_group) :
    _next(NULL),
    _primitive_fields(NULL),
    _oop_fields(NULL),
<span class="line-added">+   _flattened_fields(NULL),</span>
    _contended_group(contended_group),  // -1 means no contended group, 0 means default contended group
    _oop_count(0) {}
  
  void FieldGroup::add_primitive_field(AllFieldStream fs, BasicType type) {
    int size = type2aelembytes(type);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 96,14 ***</span>
<span class="line-new-header">--- 99,27 ---</span>
    }
    _oop_fields-&gt;append(block);
    _oop_count++;
  }
  
<span class="line-added">+ void FieldGroup::add_flattened_field(AllFieldStream fs, ValueKlass* vk) {</span>
<span class="line-added">+   // _flattened_fields list might be merged with the _primitive_fields list in the future</span>
<span class="line-added">+   LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::FLATTENED, vk-&gt;get_exact_size_in_bytes(), vk-&gt;get_alignment(), false);</span>
<span class="line-added">+   block-&gt;set_value_klass(vk);</span>
<span class="line-added">+   if (_flattened_fields == NULL) {</span>
<span class="line-added">+     _flattened_fields = new(ResourceObj::RESOURCE_AREA, mtInternal) GrowableArray&lt;LayoutRawBlock*&gt;(INITIAL_LIST_SIZE);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   _flattened_fields-&gt;append(block);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void FieldGroup::sort_by_size() {
    if (_primitive_fields != NULL) {
      _primitive_fields-&gt;sort(LayoutRawBlock::compare_size_inverted);
    }
<span class="line-added">+   if (_flattened_fields != NULL) {</span>
<span class="line-added">+     _flattened_fields-&gt;sort(LayoutRawBlock::compare_size_inverted);</span>
<span class="line-added">+   }</span>
  }
  
  FieldLayout::FieldLayout(Array&lt;u2&gt;* fields, ConstantPool* cp) :
    _fields(fields),
    _cp(cp),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 135,29 ***</span>
      insert(first_empty_block(), new LayoutRawBlock(LayoutRawBlock::RESERVED, instanceOopDesc::base_offset_in_bytes()));
    } else {
      bool has_fields = reconstruct_layout(super_klass);
      fill_holes(super_klass);
      if ((UseEmptySlotsInSupers &amp;&amp; !super_klass-&gt;has_contended_annotations()) || !has_fields) {
<span class="line-modified">!       _start = _blocks;  // start allocating fields from the first empty block</span>
      } else {
        _start = _last;    // append fields at the end of the reconstructed layout
      }
    }
  }
  
  LayoutRawBlock* FieldLayout::first_field_block() {
<span class="line-modified">!   LayoutRawBlock* block = _start;</span>
<span class="line-modified">!   while (block-&gt;kind() != LayoutRawBlock::INHERITED &amp;&amp; block-&gt;kind() != LayoutRawBlock::REGULAR</span>
<span class="line-modified">!       &amp;&amp; block-&gt;kind() != LayoutRawBlock::FLATTENED &amp;&amp; block-&gt;kind() != LayoutRawBlock::PADDING) {</span>
      block = block-&gt;next_block();
    }
    return block;
  }
  
<span class="line-modified">! </span>
<span class="line-modified">! // Insert a set of fields into a layout using a best-fit strategy.</span>
<span class="line-removed">- // For each field, search for the smallest empty slot able to fit the field</span>
  // (satisfying both size and alignment requirements), if none is found,
  // add the field at the end of the layout.
  // Fields cannot be inserted before the block specified in the &quot;start&quot; argument
  void FieldLayout::add(GrowableArray&lt;LayoutRawBlock*&gt;* list, LayoutRawBlock* start) {
    if (list == NULL) return;
<span class="line-new-header">--- 151,31 ---</span>
      insert(first_empty_block(), new LayoutRawBlock(LayoutRawBlock::RESERVED, instanceOopDesc::base_offset_in_bytes()));
    } else {
      bool has_fields = reconstruct_layout(super_klass);
      fill_holes(super_klass);
      if ((UseEmptySlotsInSupers &amp;&amp; !super_klass-&gt;has_contended_annotations()) || !has_fields) {
<span class="line-modified">!       _start = _blocks; // Setting _start to _blocks instead of _last would allow subclasses</span>
<span class="line-added">+       // to allocate fields in empty slots of their super classes</span>
      } else {
        _start = _last;    // append fields at the end of the reconstructed layout
      }
    }
  }
  
  LayoutRawBlock* FieldLayout::first_field_block() {
<span class="line-modified">!   LayoutRawBlock* block = _blocks;</span>
<span class="line-modified">!   while (block != NULL</span>
<span class="line-modified">!          &amp;&amp; block-&gt;kind() != LayoutRawBlock::INHERITED</span>
<span class="line-added">+          &amp;&amp; block-&gt;kind() != LayoutRawBlock::REGULAR</span>
<span class="line-added">+          &amp;&amp; block-&gt;kind() != LayoutRawBlock::FLATTENED) {</span>
      block = block-&gt;next_block();
    }
    return block;
  }
  
<span class="line-modified">! // Insert a set of fields into a layout.</span>
<span class="line-modified">! // For each field, search for an empty slot able to fit the field</span>
  // (satisfying both size and alignment requirements), if none is found,
  // add the field at the end of the layout.
  // Fields cannot be inserted before the block specified in the &quot;start&quot; argument
  void FieldLayout::add(GrowableArray&lt;LayoutRawBlock*&gt;* list, LayoutRawBlock* start) {
    if (list == NULL) return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 167,11 ***</span>
    int last_alignment = 0;
    for (int i = 0; i &lt; list-&gt;length(); i ++) {
      LayoutRawBlock* b = list-&gt;at(i);
      LayoutRawBlock* cursor = NULL;
      LayoutRawBlock* candidate = NULL;
<span class="line-removed">- </span>
      // if start is the last block, just append the field
      if (start == last_block()) {
        candidate = last_block();
      }
      // Before iterating over the layout to find an empty slot fitting the field&#39;s requirements,
<span class="line-new-header">--- 185,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 185,10 ***</span>
<span class="line-new-header">--- 202,11 ---</span>
        last_size = b-&gt;size();
        last_alignment = b-&gt;alignment();
        cursor = last_block()-&gt;prev_block();
        assert(cursor != NULL, &quot;Sanity check&quot;);
        last_search_success = true;
<span class="line-added">+ </span>
        while (cursor != start) {
          if (cursor-&gt;kind() == LayoutRawBlock::EMPTY &amp;&amp; cursor-&gt;fit(b-&gt;size(), b-&gt;alignment())) {
            if (candidate == NULL || cursor-&gt;size() &lt; candidate-&gt;size()) {
              candidate = cursor;
            }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 201,11 ***</span>
        }
        assert(candidate != NULL, &quot;Candidate must not be null&quot;);
        assert(candidate-&gt;kind() == LayoutRawBlock::EMPTY, &quot;Candidate must be an empty block&quot;);
        assert(candidate-&gt;fit(b-&gt;size(), b-&gt;alignment()), &quot;Candidate must be able to store the block&quot;);
      }
<span class="line-removed">- </span>
      insert_field_block(candidate, b);
    }
  }
  
  // Used for classes with hard coded field offsets, insert a field at the specified offset */
<span class="line-new-header">--- 219,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 300,24 ***</span>
      for (AllFieldStream fs(ik-&gt;fields(), ik-&gt;constants()); !fs.done(); fs.next()) {
        BasicType type = Signature::basic_type(fs.signature());
        // distinction between static and non-static fields is missing
        if (fs.access_flags().is_static()) continue;
        has_instance_fields = true;
<span class="line-modified">!       int size = type2aelembytes(type);</span>
<span class="line-modified">!       // INHERITED blocks are marked as non-reference because oop_maps are handled by their holder class</span>
<span class="line-modified">!       LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, size, size, false);</span>
        block-&gt;set_offset(fs.offset());
        all_fields-&gt;append(block);
      }
      ik = ik-&gt;super() == NULL ? NULL : InstanceKlass::cast(ik-&gt;super());
    }
<span class="line-removed">- </span>
    all_fields-&gt;sort(LayoutRawBlock::compare_offset);
    _blocks = new LayoutRawBlock(LayoutRawBlock::RESERVED, instanceOopDesc::base_offset_in_bytes());
    _blocks-&gt;set_offset(0);
    _last = _blocks;
<span class="line-removed">- </span>
    for(int i = 0; i &lt; all_fields-&gt;length(); i++) {
      LayoutRawBlock* b = all_fields-&gt;at(i);
      _last-&gt;set_next_block(b);
      b-&gt;set_prev_block(_last);
      _last = b;
<span class="line-new-header">--- 317,30 ---</span>
      for (AllFieldStream fs(ik-&gt;fields(), ik-&gt;constants()); !fs.done(); fs.next()) {
        BasicType type = Signature::basic_type(fs.signature());
        // distinction between static and non-static fields is missing
        if (fs.access_flags().is_static()) continue;
        has_instance_fields = true;
<span class="line-modified">!       LayoutRawBlock* block;</span>
<span class="line-modified">!       if (type == T_VALUETYPE) {</span>
<span class="line-modified">!         ValueKlass* vk = ValueKlass::cast(ik-&gt;get_value_field_klass(fs.index()));</span>
<span class="line-added">+         block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, vk-&gt;get_exact_size_in_bytes(),</span>
<span class="line-added">+                                    vk-&gt;get_alignment(), false);</span>
<span class="line-added">+ </span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         int size = type2aelembytes(type);</span>
<span class="line-added">+         // INHERITED blocks are marked as non-reference because oop_maps are handled by their holder class</span>
<span class="line-added">+         block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, size, size, false);</span>
<span class="line-added">+       }</span>
        block-&gt;set_offset(fs.offset());
        all_fields-&gt;append(block);
      }
      ik = ik-&gt;super() == NULL ? NULL : InstanceKlass::cast(ik-&gt;super());
    }
    all_fields-&gt;sort(LayoutRawBlock::compare_offset);
    _blocks = new LayoutRawBlock(LayoutRawBlock::RESERVED, instanceOopDesc::base_offset_in_bytes());
    _blocks-&gt;set_offset(0);
    _last = _blocks;
    for(int i = 0; i &lt; all_fields-&gt;length(); i++) {
      LayoutRawBlock* b = all_fields-&gt;at(i);
      _last-&gt;set_next_block(b);
      b-&gt;set_prev_block(_last);
      _last = b;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 349,22 ***</span>
      }
      b = b-&gt;next_block();
    }
    assert(b-&gt;next_block() == NULL, &quot;Invariant at this point&quot;);
    assert(b-&gt;kind() != LayoutRawBlock::EMPTY, &quot;Sanity check&quot;);
<span class="line-removed">- </span>
    // If the super class has @Contended annotation, a padding block is
    // inserted at the end to ensure that fields from the subclasses won&#39;t share
    // the cache line of the last field of the contended class
    if (super_klass-&gt;has_contended_annotations() &amp;&amp; ContendedPaddingWidth &gt; 0) {
      LayoutRawBlock* p = new LayoutRawBlock(LayoutRawBlock::PADDING, ContendedPaddingWidth);
      p-&gt;set_offset(b-&gt;offset() + b-&gt;size());
      b-&gt;set_next_block(p);
      p-&gt;set_prev_block(b);
      b = p;
    }
<span class="line-removed">- </span>
    if (!UseEmptySlotsInSupers) {
      // Add an empty slots to align fields of the subclass on a heapOopSize boundary
      // in order to emulate the behavior of the previous algorithm
      int align = (b-&gt;offset() + b-&gt;size()) % heapOopSize;
      if (align != 0) {
<span class="line-new-header">--- 372,20 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 374,11 ***</span>
        b-&gt;set_next_block(p);
        p-&gt;set_prev_block(b);
        b = p;
      }
    }
<span class="line-removed">- </span>
    LayoutRawBlock* last = new LayoutRawBlock(LayoutRawBlock::EMPTY, INT_MAX);
    last-&gt;set_offset(b-&gt;offset() + b-&gt;size());
    assert(last-&gt;offset() &gt; 0, &quot;Sanity check&quot;);
    b-&gt;set_next_block(last);
    last-&gt;set_prev_block(b);
<span class="line-new-header">--- 395,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 426,96 ***</span>
  void FieldLayout::print(outputStream* output, bool is_static, const InstanceKlass* super) {
    ResourceMark rm;
    LayoutRawBlock* b = _blocks;
    while(b != _last) {
      switch(b-&gt;kind()) {
<span class="line-modified">!       case LayoutRawBlock::REGULAR: {</span>
<span class="line-modified">!         FieldInfo* fi = FieldInfo::from_field_array(_fields, b-&gt;field_index());</span>
<span class="line-modified">!         output-&gt;print_cr(&quot; @%d \&quot;%s\&quot; %s %d/%d %s&quot;,</span>
<span class="line-modified">!                          b-&gt;offset(),</span>
<span class="line-modified">!                          fi-&gt;name(_cp)-&gt;as_C_string(),</span>
<span class="line-modified">!                          fi-&gt;signature(_cp)-&gt;as_C_string(),</span>
<span class="line-modified">!                          b-&gt;size(),</span>
<span class="line-modified">!                          b-&gt;alignment(),</span>
<span class="line-modified">!                          &quot;REGULAR&quot;);</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       case LayoutRawBlock::FLATTENED: {</span>
<span class="line-modified">!         FieldInfo* fi = FieldInfo::from_field_array(_fields, b-&gt;field_index());</span>
<span class="line-modified">!         output-&gt;print_cr(&quot; @%d \&quot;%s\&quot; %s %d/%d %s&quot;,</span>
<span class="line-modified">!                          b-&gt;offset(),</span>
<span class="line-modified">!                          fi-&gt;name(_cp)-&gt;as_C_string(),</span>
<span class="line-modified">!                          fi-&gt;signature(_cp)-&gt;as_C_string(),</span>
<span class="line-modified">!                          b-&gt;size(),</span>
<span class="line-modified">!                          b-&gt;alignment(),</span>
<span class="line-modified">!                          &quot;FLATTENED&quot;);</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       case LayoutRawBlock::RESERVED: {</span>
<span class="line-modified">!         output-&gt;print_cr(&quot; @%d %d/- %s&quot;,</span>
<span class="line-modified">!                          b-&gt;offset(),</span>
<span class="line-modified">!                          b-&gt;size(),</span>
<span class="line-modified">!                          &quot;RESERVED&quot;);</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       case LayoutRawBlock::INHERITED: {</span>
<span class="line-modified">!         assert(!is_static, &quot;Static fields are not inherited in layouts&quot;);</span>
<span class="line-modified">!         assert(super != NULL, &quot;super klass must be provided to retrieve inherited fields info&quot;);</span>
<span class="line-modified">!         bool found = false;</span>
<span class="line-modified">!         const InstanceKlass* ik = super;</span>
<span class="line-modified">!         while (!found &amp;&amp; ik != NULL) {</span>
<span class="line-modified">!           for (AllFieldStream fs(ik-&gt;fields(), ik-&gt;constants()); !fs.done(); fs.next()) {</span>
<span class="line-modified">!             if (fs.offset() == b-&gt;offset()) {</span>
<span class="line-modified">!               output-&gt;print_cr(&quot; @%d \&quot;%s\&quot; %s %d/%d %s&quot;,</span>
<span class="line-modified">!                   b-&gt;offset(),</span>
<span class="line-modified">!                   fs.name()-&gt;as_C_string(),</span>
<span class="line-modified">!                   fs.signature()-&gt;as_C_string(),</span>
<span class="line-modified">!                   b-&gt;size(),</span>
<span class="line-modified">!                   b-&gt;size(), // so far, alignment constraint == size, will change with Valhalla</span>
<span class="line-modified">!                   &quot;INHERITED&quot;);</span>
<span class="line-modified">!               found = true;</span>
<span class="line-modified">!               break;</span>
<span class="line-removed">-             }</span>
            }
<span class="line-modified">!           ik = ik-&gt;java_super();</span>
<span class="line-removed">-         }</span>
          ik = ik-&gt;java_super();
        }
<span class="line-modified">!       case LayoutRawBlock::EMPTY:</span>
<span class="line-modified">!         output-&gt;print_cr(&quot; @%d %d/1 %s&quot;,</span>
<span class="line-modified">!                          b-&gt;offset(),</span>
<span class="line-modified">!                          b-&gt;size(),</span>
<span class="line-modified">!                         &quot;EMPTY&quot;);</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!       case LayoutRawBlock::PADDING:</span>
<span class="line-modified">!         output-&gt;print_cr(&quot; @%d %d/1 %s&quot;,</span>
<span class="line-modified">!                          b-&gt;offset(),</span>
<span class="line-modified">!                          b-&gt;size(),</span>
<span class="line-modified">!                         &quot;PADDING&quot;);</span>
<span class="line-modified">!         break;</span>
      }
      b = b-&gt;next_block();
    }
  }
  
  FieldLayoutBuilder::FieldLayoutBuilder(const Symbol* classname, const InstanceKlass* super_klass, ConstantPool* constant_pool,
<span class="line-modified">!       Array&lt;u2&gt;* fields, bool is_contended, FieldLayoutInfo* info) :</span>
    _classname(classname),
    _super_klass(super_klass),
    _constant_pool(constant_pool),
    _fields(fields),
    _info(info),
    _root_group(NULL),
    _contended_groups(GrowableArray&lt;FieldGroup*&gt;(8)),
    _static_fields(NULL),
    _layout(NULL),
    _static_layout(NULL),
    _nonstatic_oopmap_count(0),
    _alignment(-1),
    _has_nonstatic_fields(false),
<span class="line-modified">!   _is_contended(is_contended) {}</span>
<span class="line-modified">! </span>
  
  FieldGroup* FieldLayoutBuilder::get_or_create_contended_group(int g) {
    assert(g &gt; 0, &quot;must only be called for named contended groups&quot;);
    FieldGroup* fg = NULL;
    for (int i = 0; i &lt; _contended_groups.length(); i++) {
<span class="line-new-header">--- 446,105 ---</span>
  void FieldLayout::print(outputStream* output, bool is_static, const InstanceKlass* super) {
    ResourceMark rm;
    LayoutRawBlock* b = _blocks;
    while(b != _last) {
      switch(b-&gt;kind()) {
<span class="line-modified">!     case LayoutRawBlock::REGULAR: {</span>
<span class="line-modified">!       FieldInfo* fi = FieldInfo::from_field_array(_fields, b-&gt;field_index());</span>
<span class="line-modified">!       output-&gt;print_cr(&quot; @%d \&quot;%s\&quot; %s %d/%d %s&quot;,</span>
<span class="line-modified">!                        b-&gt;offset(),</span>
<span class="line-modified">!                        fi-&gt;name(_cp)-&gt;as_C_string(),</span>
<span class="line-modified">!                        fi-&gt;signature(_cp)-&gt;as_C_string(),</span>
<span class="line-modified">!                        b-&gt;size(),</span>
<span class="line-modified">!                        b-&gt;alignment(),</span>
<span class="line-modified">!                        &quot;REGULAR&quot;);</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case LayoutRawBlock::FLATTENED: {</span>
<span class="line-modified">!       FieldInfo* fi = FieldInfo::from_field_array(_fields, b-&gt;field_index());</span>
<span class="line-modified">!       output-&gt;print_cr(&quot; @%d \&quot;%s\&quot; %s %d/%d %s&quot;,</span>
<span class="line-modified">!                        b-&gt;offset(),</span>
<span class="line-modified">!                        fi-&gt;name(_cp)-&gt;as_C_string(),</span>
<span class="line-modified">!                        fi-&gt;signature(_cp)-&gt;as_C_string(),</span>
<span class="line-modified">!                        b-&gt;size(),</span>
<span class="line-modified">!                        b-&gt;alignment(),</span>
<span class="line-modified">!                        &quot;FLATTENED&quot;);</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case LayoutRawBlock::RESERVED: {</span>
<span class="line-modified">!       output-&gt;print_cr(&quot; @%d %d/- %s&quot;,</span>
<span class="line-modified">!                        b-&gt;offset(),</span>
<span class="line-modified">!                        b-&gt;size(),</span>
<span class="line-modified">!                        &quot;RESERVED&quot;);</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case LayoutRawBlock::INHERITED: {</span>
<span class="line-modified">!       assert(!is_static, &quot;Static fields are not inherited in layouts&quot;);</span>
<span class="line-modified">!       assert(super != NULL, &quot;super klass must be provided to retrieve inherited fields info&quot;);</span>
<span class="line-modified">!       bool found = false;</span>
<span class="line-modified">!       const InstanceKlass* ik = super;</span>
<span class="line-modified">!       while (!found &amp;&amp; ik != NULL) {</span>
<span class="line-modified">!         for (AllFieldStream fs(ik-&gt;fields(), ik-&gt;constants()); !fs.done(); fs.next()) {</span>
<span class="line-modified">!           if (fs.offset() == b-&gt;offset()) {</span>
<span class="line-modified">!             output-&gt;print_cr(&quot; @%d \&quot;%s\&quot; %s %d/%d %s&quot;,</span>
<span class="line-modified">!                 b-&gt;offset(),</span>
<span class="line-modified">!                 fs.name()-&gt;as_C_string(),</span>
<span class="line-modified">!                 fs.signature()-&gt;as_C_string(),</span>
<span class="line-modified">!                 b-&gt;size(),</span>
<span class="line-modified">!                 b-&gt;size(), // so far, alignment constraint == size, will change with Valhalla</span>
<span class="line-modified">!                 &quot;INHERITED&quot;);</span>
<span class="line-modified">!             found = true;</span>
<span class="line-modified">!             break;</span>
            }
<span class="line-modified">!         }</span>
          ik = ik-&gt;java_super();
        }
<span class="line-modified">!       break;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     case LayoutRawBlock::EMPTY:</span>
<span class="line-modified">!       output-&gt;print_cr(&quot; @%d %d/1 %s&quot;,</span>
<span class="line-modified">!                        b-&gt;offset(),</span>
<span class="line-modified">!                        b-&gt;size(),</span>
<span class="line-modified">!                        &quot;EMPTY&quot;);</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">!     case LayoutRawBlock::PADDING:</span>
<span class="line-modified">!       output-&gt;print_cr(&quot; @%d %d/1 %s&quot;,</span>
<span class="line-modified">!                        b-&gt;offset(),</span>
<span class="line-modified">!                        b-&gt;size(),</span>
<span class="line-added">+                        &quot;PADDING&quot;);</span>
<span class="line-added">+       break;</span>
      }
      b = b-&gt;next_block();
    }
  }
  
  FieldLayoutBuilder::FieldLayoutBuilder(const Symbol* classname, const InstanceKlass* super_klass, ConstantPool* constant_pool,
<span class="line-modified">!                                        Array&lt;u2&gt;* fields, bool is_contended, bool is_inline_type, ClassLoaderData* class_loader_data,</span>
<span class="line-added">+                                        Handle protection_domain, FieldLayoutInfo* info) :</span>
    _classname(classname),
    _super_klass(super_klass),
    _constant_pool(constant_pool),
    _fields(fields),
    _info(info),
    _root_group(NULL),
    _contended_groups(GrowableArray&lt;FieldGroup*&gt;(8)),
    _static_fields(NULL),
    _layout(NULL),
    _static_layout(NULL),
<span class="line-added">+   _class_loader_data(class_loader_data),</span>
<span class="line-added">+   _protection_domain(protection_domain),</span>
    _nonstatic_oopmap_count(0),
    _alignment(-1),
<span class="line-added">+   _first_field_offset(-1),</span>
<span class="line-added">+   _exact_size_in_bytes(-1),</span>
    _has_nonstatic_fields(false),
<span class="line-modified">!   _is_contended(is_contended),</span>
<span class="line-modified">!   _is_inline_type(is_inline_type),</span>
<span class="line-added">+   _has_flattening_information(is_inline_type),</span>
<span class="line-added">+   _has_nonatomic_values(false),</span>
<span class="line-added">+   _atomic_field_count(0)</span>
<span class="line-added">+  {}</span>
  
  FieldGroup* FieldLayoutBuilder::get_or_create_contended_group(int g) {
    assert(g &gt; 0, &quot;must only be called for named contended groups&quot;);
    FieldGroup* fg = NULL;
    for (int i = 0; i &lt; _contended_groups.length(); i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 538,22 ***</span>
    _static_layout-&gt;initialize_static_layout();
    _static_fields = new FieldGroup();
    _root_group = new FieldGroup();
  }
  
<span class="line-modified">! // Field sorting for regular classes:</span>
  //   - fields are sorted in static and non-static fields
  //   - non-static fields are also sorted according to their contention group
  //     (support of the @Contended annotation)
  //   - @Contended annotation is ignored for static fields
  void FieldLayoutBuilder::regular_field_sorting() {
    for (AllFieldStream fs(_fields, _constant_pool); !fs.done(); fs.next()) {
      FieldGroup* group = NULL;
      if (fs.access_flags().is_static()) {
        group = _static_fields;
      } else {
        _has_nonstatic_fields = true;
        if (fs.is_contended()) {
          int g = fs.contended_group();
          if (g == 0) {
            group = new FieldGroup(true);
            _contended_groups.append(group);
<span class="line-new-header">--- 567,24 ---</span>
    _static_layout-&gt;initialize_static_layout();
    _static_fields = new FieldGroup();
    _root_group = new FieldGroup();
  }
  
<span class="line-modified">! // Field sorting for regular (non-inline) classes:</span>
  //   - fields are sorted in static and non-static fields
  //   - non-static fields are also sorted according to their contention group
  //     (support of the @Contended annotation)
  //   - @Contended annotation is ignored for static fields
<span class="line-added">+ //   - field flattening decisions are taken in this method</span>
  void FieldLayoutBuilder::regular_field_sorting() {
    for (AllFieldStream fs(_fields, _constant_pool); !fs.done(); fs.next()) {
      FieldGroup* group = NULL;
      if (fs.access_flags().is_static()) {
        group = _static_fields;
      } else {
        _has_nonstatic_fields = true;
<span class="line-added">+       _atomic_field_count++;  // we might decrement this</span>
        if (fs.is_contended()) {
          int g = fs.contended_group();
          if (g == 0) {
            group = new FieldGroup(true);
            _contended_groups.append(group);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 565,27 ***</span>
        }
      }
      assert(group != NULL, &quot;invariant&quot;);
      BasicType type = Signature::basic_type(fs.signature());
      switch(type) {
<span class="line-modified">!       case T_BYTE:</span>
<span class="line-modified">!       case T_CHAR:</span>
<span class="line-modified">!       case T_DOUBLE:</span>
<span class="line-modified">!       case T_FLOAT:</span>
<span class="line-modified">!       case T_INT:</span>
<span class="line-modified">!       case T_LONG:</span>
<span class="line-modified">!       case T_SHORT:</span>
<span class="line-modified">!       case T_BOOLEAN:</span>
<span class="line-modified">!         group-&gt;add_primitive_field(fs, type);</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!       case T_OBJECT:</span>
<span class="line-modified">!       case T_ARRAY:</span>
<span class="line-modified">!         if (group != _static_fields) _nonstatic_oopmap_count++;</span>
          group-&gt;add_oop_field(fs);
<span class="line-modified">!         break;</span>
<span class="line-modified">!       default:</span>
<span class="line-modified">!         fatal(&quot;Something wrong?&quot;);</span>
      }
    }
    _root_group-&gt;sort_by_size();
    _static_fields-&gt;sort_by_size();
    if (!_contended_groups.is_empty()) {
<span class="line-new-header">--- 596,67 ---</span>
        }
      }
      assert(group != NULL, &quot;invariant&quot;);
      BasicType type = Signature::basic_type(fs.signature());
      switch(type) {
<span class="line-modified">!     case T_BYTE:</span>
<span class="line-modified">!     case T_CHAR:</span>
<span class="line-modified">!     case T_DOUBLE:</span>
<span class="line-modified">!     case T_FLOAT:</span>
<span class="line-modified">!     case T_INT:</span>
<span class="line-modified">!     case T_LONG:</span>
<span class="line-modified">!     case T_SHORT:</span>
<span class="line-modified">!     case T_BOOLEAN:</span>
<span class="line-modified">!       group-&gt;add_primitive_field(fs, type);</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">!     case T_OBJECT:</span>
<span class="line-modified">!     case T_ARRAY:</span>
<span class="line-modified">!       if (group != _static_fields) _nonstatic_oopmap_count++;</span>
<span class="line-added">+       group-&gt;add_oop_field(fs);</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     case T_VALUETYPE:</span>
<span class="line-added">+       if (group == _static_fields) {</span>
<span class="line-added">+         // static fields are never flattened</span>
          group-&gt;add_oop_field(fs);
<span class="line-modified">!       } else {</span>
<span class="line-modified">!         _has_flattening_information = true;</span>
<span class="line-modified">!         // Flattening decision to be taken here</span>
<span class="line-added">+         // This code assumes all verification have been performed before</span>
<span class="line-added">+         // (field is a flattenable field, field&#39;s type has been loaded</span>
<span class="line-added">+         // and it is an inline klass</span>
<span class="line-added">+         Thread* THREAD = Thread::current();</span>
<span class="line-added">+         Klass* klass =</span>
<span class="line-added">+             SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,</span>
<span class="line-added">+                                                                 Handle(THREAD, _class_loader_data-&gt;class_loader()),</span>
<span class="line-added">+                                                                 _protection_domain, true, THREAD);</span>
<span class="line-added">+         assert(klass != NULL, &quot;Sanity check&quot;);</span>
<span class="line-added">+         ValueKlass* vk = ValueKlass::cast(klass);</span>
<span class="line-added">+         bool too_big_to_flatten = (InlineFieldMaxFlatSize &gt;= 0 &amp;&amp;</span>
<span class="line-added">+                                    (vk-&gt;size_helper() * HeapWordSize) &gt; InlineFieldMaxFlatSize);</span>
<span class="line-added">+         bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();</span>
<span class="line-added">+         bool too_volatile_to_flatten = fs.access_flags().is_volatile();</span>
<span class="line-added">+         if (vk-&gt;is_naturally_atomic()) {</span>
<span class="line-added">+           too_atomic_to_flatten = false;</span>
<span class="line-added">+           //too_volatile_to_flatten = false; //FIXME</span>
<span class="line-added">+           // volatile fields are currently never flattened, this could change in the future</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {</span>
<span class="line-added">+           group-&gt;add_flattened_field(fs, vk);</span>
<span class="line-added">+           _nonstatic_oopmap_count += vk-&gt;nonstatic_oop_map_count();</span>
<span class="line-added">+           fs.set_flattened(true);</span>
<span class="line-added">+           if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note</span>
<span class="line-added">+             _has_nonatomic_values = true;</span>
<span class="line-added">+             _atomic_field_count--;  // every other field is atomic but this one</span>
<span class="line-added">+           }</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           _nonstatic_oopmap_count++;</span>
<span class="line-added">+           group-&gt;add_oop_field(fs);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+       fatal(&quot;Something wrong?&quot;);</span>
      }
    }
    _root_group-&gt;sort_by_size();
    _static_fields-&gt;sort_by_size();
    if (!_contended_groups.is_empty()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 593,58 ***</span>
        _contended_groups.at(i)-&gt;sort_by_size();
      }
    }
  }
  
  void FieldLayoutBuilder::insert_contended_padding(LayoutRawBlock* slot) {
    if (ContendedPaddingWidth &gt; 0) {
      LayoutRawBlock* padding = new LayoutRawBlock(LayoutRawBlock::PADDING, ContendedPaddingWidth);
      _layout-&gt;insert(slot, padding);
    }
  }
  
<span class="line-modified">! // Computation of regular classes layout is an evolution of the previous default layout</span>
<span class="line-modified">! // (FieldAllocationStyle 1):</span>
<span class="line-modified">! //   - primitive fields are allocated first (from the biggest to the smallest)</span>
<span class="line-modified">! //   - then oop fields are allocated, either in existing gaps or at the end of</span>
<span class="line-modified">! //     the layout</span>
  void FieldLayoutBuilder::compute_regular_layout() {
    bool need_tail_padding = false;
    prologue();
    regular_field_sorting();
<span class="line-removed">- </span>
    if (_is_contended) {
      _layout-&gt;set_start(_layout-&gt;last_block());
      // insertion is currently easy because the current strategy doesn&#39;t try to fill holes
      // in super classes layouts =&gt; the _start block is by consequence the _last_block
      insert_contended_padding(_layout-&gt;start());
      need_tail_padding = true;
    }
    _layout-&gt;add(_root_group-&gt;primitive_fields());
    _layout-&gt;add(_root_group-&gt;oop_fields());
  
    if (!_contended_groups.is_empty()) {
      for (int i = 0; i &lt; _contended_groups.length(); i++) {
        FieldGroup* cg = _contended_groups.at(i);
        LayoutRawBlock* start = _layout-&gt;last_block();
        insert_contended_padding(start);
        _layout-&gt;add(cg-&gt;primitive_fields(), start);
        _layout-&gt;add(cg-&gt;oop_fields(), start);
        need_tail_padding = true;
      }
    }
  
    if (need_tail_padding) {
      insert_contended_padding(_layout-&gt;last_block());
    }
  
<span class="line-removed">-   _static_layout-&gt;add_contiguously(this-&gt;_static_fields-&gt;oop_fields());</span>
<span class="line-removed">-   _static_layout-&gt;add(this-&gt;_static_fields-&gt;primitive_fields());</span>
  
    epilogue();
  }
  
  void FieldLayoutBuilder::epilogue() {
    // Computing oopmaps
    int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
    int max_oop_map_count = super_oop_map_count + _nonstatic_oopmap_count;
  
<span class="line-new-header">--- 664,233 ---</span>
        _contended_groups.at(i)-&gt;sort_by_size();
      }
    }
  }
  
<span class="line-added">+ /* Field sorting for inline classes:</span>
<span class="line-added">+  *   - because inline classes are immutable, the @Contended annotation is ignored</span>
<span class="line-added">+  *     when computing their layout (with only read operation, there&#39;s no false</span>
<span class="line-added">+  *     sharing issue)</span>
<span class="line-added">+  *   - this method also records the alignment of the field with the most</span>
<span class="line-added">+  *     constraining alignment, this value is then used as the alignment</span>
<span class="line-added">+  *     constraint when flattening this inline type into another container</span>
<span class="line-added">+  *   - field flattening decisions are taken in this method (those decisions are</span>
<span class="line-added">+  *     currently only based in the size of the fields to be flattened, the size</span>
<span class="line-added">+  *     of the resulting instance is not considered)</span>
<span class="line-added">+  */</span>
<span class="line-added">+ void FieldLayoutBuilder::inline_class_field_sorting(TRAPS) {</span>
<span class="line-added">+   assert(_is_inline_type, &quot;Should only be used for inline classes&quot;);</span>
<span class="line-added">+   int alignment = 1;</span>
<span class="line-added">+   for (AllFieldStream fs(_fields, _constant_pool); !fs.done(); fs.next()) {</span>
<span class="line-added">+     FieldGroup* group = NULL;</span>
<span class="line-added">+     int field_alignment = 1;</span>
<span class="line-added">+     if (fs.access_flags().is_static()) {</span>
<span class="line-added">+       group = _static_fields;</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       _has_nonstatic_fields = true;</span>
<span class="line-added">+       _atomic_field_count++;  // we might decrement this</span>
<span class="line-added">+       group = _root_group;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     assert(group != NULL, &quot;invariant&quot;);</span>
<span class="line-added">+     BasicType type = Signature::basic_type(fs.signature());</span>
<span class="line-added">+     switch(type) {</span>
<span class="line-added">+     case T_BYTE:</span>
<span class="line-added">+     case T_CHAR:</span>
<span class="line-added">+     case T_DOUBLE:</span>
<span class="line-added">+     case T_FLOAT:</span>
<span class="line-added">+     case T_INT:</span>
<span class="line-added">+     case T_LONG:</span>
<span class="line-added">+     case T_SHORT:</span>
<span class="line-added">+     case T_BOOLEAN:</span>
<span class="line-added">+       if (group != _static_fields) {</span>
<span class="line-added">+         field_alignment = type2aelembytes(type); // alignment == size for primitive types</span>
<span class="line-added">+       }</span>
<span class="line-added">+       group-&gt;add_primitive_field(fs, type);</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     case T_OBJECT:</span>
<span class="line-added">+     case T_ARRAY:</span>
<span class="line-added">+       if (group != _static_fields) {</span>
<span class="line-added">+         _nonstatic_oopmap_count++;</span>
<span class="line-added">+         field_alignment = type2aelembytes(type); // alignment == size for oops</span>
<span class="line-added">+       }</span>
<span class="line-added">+       group-&gt;add_oop_field(fs);</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     case T_VALUETYPE: {</span>
<span class="line-added">+       if (group == _static_fields) {</span>
<span class="line-added">+         // static fields are never flattened</span>
<span class="line-added">+         group-&gt;add_oop_field(fs);</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         // Flattening decision to be taken here</span>
<span class="line-added">+         // This code assumes all verifications have been performed before</span>
<span class="line-added">+         // (field is a flattenable field, field&#39;s type has been loaded</span>
<span class="line-added">+         // and it is an inline klass</span>
<span class="line-added">+         Thread* THREAD = Thread::current();</span>
<span class="line-added">+         Klass* klass =</span>
<span class="line-added">+             SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,</span>
<span class="line-added">+                 Handle(THREAD, _class_loader_data-&gt;class_loader()),</span>
<span class="line-added">+                 _protection_domain, true, CHECK);</span>
<span class="line-added">+         assert(klass != NULL, &quot;Sanity check&quot;);</span>
<span class="line-added">+         ValueKlass* vk = ValueKlass::cast(klass);</span>
<span class="line-added">+         bool too_big_to_flatten = (InlineFieldMaxFlatSize &gt;= 0 &amp;&amp;</span>
<span class="line-added">+                                    (vk-&gt;size_helper() * HeapWordSize) &gt; InlineFieldMaxFlatSize);</span>
<span class="line-added">+         bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();</span>
<span class="line-added">+         bool too_volatile_to_flatten = fs.access_flags().is_volatile();</span>
<span class="line-added">+         if (vk-&gt;is_naturally_atomic()) {</span>
<span class="line-added">+           too_atomic_to_flatten = false;</span>
<span class="line-added">+           //too_volatile_to_flatten = false; //FIXME</span>
<span class="line-added">+           // volatile fields are currently never flattened, this could change in the future</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {</span>
<span class="line-added">+           group-&gt;add_flattened_field(fs, vk);</span>
<span class="line-added">+           _nonstatic_oopmap_count += vk-&gt;nonstatic_oop_map_count();</span>
<span class="line-added">+           field_alignment = vk-&gt;get_alignment();</span>
<span class="line-added">+           fs.set_flattened(true);</span>
<span class="line-added">+           if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note</span>
<span class="line-added">+             _has_nonatomic_values = true;</span>
<span class="line-added">+             _atomic_field_count--;  // every other field is atomic but this one</span>
<span class="line-added">+           }</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+           _nonstatic_oopmap_count++;</span>
<span class="line-added">+           field_alignment = type2aelembytes(T_OBJECT);</span>
<span class="line-added">+           group-&gt;add_oop_field(fs);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     default:</span>
<span class="line-added">+       fatal(&quot;Unexpected BasicType&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (!fs.access_flags().is_static() &amp;&amp; field_alignment &gt; alignment) alignment = field_alignment;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   _alignment = alignment;</span>
<span class="line-added">+   if (!_has_nonstatic_fields) {</span>
<span class="line-added">+     // There are a number of fixes required throughout the type system and JIT</span>
<span class="line-added">+     Exceptions::fthrow(THREAD_AND_LOCATION,</span>
<span class="line-added">+                        vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">+                        &quot;Value Types do not support zero instance size yet&quot;);</span>
<span class="line-added">+     return;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void FieldLayoutBuilder::insert_contended_padding(LayoutRawBlock* slot) {
    if (ContendedPaddingWidth &gt; 0) {
      LayoutRawBlock* padding = new LayoutRawBlock(LayoutRawBlock::PADDING, ContendedPaddingWidth);
      _layout-&gt;insert(slot, padding);
    }
  }
  
<span class="line-modified">! /* Computation of regular classes layout is an evolution of the previous default layout</span>
<span class="line-modified">!  * (FieldAllocationStyle 1):</span>
<span class="line-modified">!  *   - flattened fields are allocated first (because they have potentially the</span>
<span class="line-modified">!  *     least regular shapes, and are more likely to create empty slots between them,</span>
<span class="line-modified">!  *     which can then be used to allocation primitive or oop fields). Allocation is</span>
<span class="line-added">+  *     performed from the biggest to the smallest flattened field.</span>
<span class="line-added">+  *   - then primitive fields (from the biggest to the smallest)</span>
<span class="line-added">+  *   - then oop fields are allocated contiguously (to reduce the number of oopmaps</span>
<span class="line-added">+  *     and reduce the work of the GC).</span>
<span class="line-added">+  */</span>
  void FieldLayoutBuilder::compute_regular_layout() {
    bool need_tail_padding = false;
    prologue();
    regular_field_sorting();
    if (_is_contended) {
      _layout-&gt;set_start(_layout-&gt;last_block());
      // insertion is currently easy because the current strategy doesn&#39;t try to fill holes
      // in super classes layouts =&gt; the _start block is by consequence the _last_block
      insert_contended_padding(_layout-&gt;start());
      need_tail_padding = true;
    }
<span class="line-added">+   _layout-&gt;add(_root_group-&gt;flattened_fields());</span>
    _layout-&gt;add(_root_group-&gt;primitive_fields());
    _layout-&gt;add(_root_group-&gt;oop_fields());
  
    if (!_contended_groups.is_empty()) {
      for (int i = 0; i &lt; _contended_groups.length(); i++) {
        FieldGroup* cg = _contended_groups.at(i);
        LayoutRawBlock* start = _layout-&gt;last_block();
        insert_contended_padding(start);
<span class="line-added">+       _layout-&gt;add(_root_group-&gt;flattened_fields());</span>
        _layout-&gt;add(cg-&gt;primitive_fields(), start);
        _layout-&gt;add(cg-&gt;oop_fields(), start);
        need_tail_padding = true;
      }
    }
  
    if (need_tail_padding) {
      insert_contended_padding(_layout-&gt;last_block());
    }
<span class="line-added">+   _static_layout-&gt;add(_static_fields-&gt;flattened_fields());</span>
<span class="line-added">+   _static_layout-&gt;add_contiguously(_static_fields-&gt;oop_fields());</span>
<span class="line-added">+   _static_layout-&gt;add(_static_fields-&gt;primitive_fields());</span>
<span class="line-added">+ </span>
<span class="line-added">+   epilogue();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /* Computation of inline classes has a slightly different strategy than for</span>
<span class="line-added">+  * regular classes. Regular classes have their oop fields allocated at the end</span>
<span class="line-added">+  * of the layout to increase GC performances. Unfortunately, this strategy</span>
<span class="line-added">+  * increases the number of empty slots inside an instance. Because the purpose</span>
<span class="line-added">+  * of inline classes is to be embedded into other containers, it is critical</span>
<span class="line-added">+  * to keep their size as small as possible. For this reason, the allocation</span>
<span class="line-added">+  * strategy is:</span>
<span class="line-added">+  *   - flattened fields are allocated first (because they have potentially the</span>
<span class="line-added">+  *     least regular shapes, and are more likely to create empty slots between them,</span>
<span class="line-added">+  *     which can then be used to allocation primitive or oop fields). Allocation is</span>
<span class="line-added">+  *     performed from the biggest to the smallest flattened field.</span>
<span class="line-added">+  *   - then oop fields are allocated contiguously (to reduce the number of oopmaps</span>
<span class="line-added">+  *     and reduce the work of the GC)</span>
<span class="line-added">+  *   - then primitive fields (from the biggest to the smallest)</span>
<span class="line-added">+  */</span>
<span class="line-added">+ void FieldLayoutBuilder::compute_inline_class_layout(TRAPS) {</span>
<span class="line-added">+   prologue();</span>
<span class="line-added">+   inline_class_field_sorting(CHECK);</span>
<span class="line-added">+   // Inline types are not polymorphic, so they cannot inherit fields.</span>
<span class="line-added">+   // By consequence, at this stage, the layout must be composed of a RESERVED</span>
<span class="line-added">+   // block, followed by an EMPTY block.</span>
<span class="line-added">+   assert(_layout-&gt;start()-&gt;kind() == LayoutRawBlock::RESERVED, &quot;Unexpected&quot;);</span>
<span class="line-added">+   assert(_layout-&gt;start()-&gt;next_block()-&gt;kind() == LayoutRawBlock::EMPTY, &quot;Unexpected&quot;);</span>
<span class="line-added">+   LayoutRawBlock* first_empty = _layout-&gt;start()-&gt;next_block();</span>
<span class="line-added">+   if (first_empty-&gt;offset() % _alignment != 0) {</span>
<span class="line-added">+     LayoutRawBlock* padding = new LayoutRawBlock(LayoutRawBlock::PADDING, _alignment - (first_empty-&gt;offset() % _alignment));</span>
<span class="line-added">+     _layout-&gt;insert(first_empty, padding);</span>
<span class="line-added">+     _layout-&gt;set_start(padding-&gt;next_block());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   _layout-&gt;add(_root_group-&gt;flattened_fields());</span>
<span class="line-added">+   _layout-&gt;add(_root_group-&gt;oop_fields());</span>
<span class="line-added">+   _layout-&gt;add(_root_group-&gt;primitive_fields());</span>
<span class="line-added">+ </span>
<span class="line-added">+   LayoutRawBlock* first_field = _layout-&gt;first_field_block();</span>
<span class="line-added">+    if (first_field != NULL) {</span>
<span class="line-added">+      _first_field_offset = _layout-&gt;first_field_block()-&gt;offset();</span>
<span class="line-added">+      _exact_size_in_bytes = _layout-&gt;last_block()-&gt;offset() - _layout-&gt;first_field_block()-&gt;offset();</span>
<span class="line-added">+    } else {</span>
<span class="line-added">+      // special case for empty value types</span>
<span class="line-added">+      _first_field_offset = _layout-&gt;blocks()-&gt;size();</span>
<span class="line-added">+      _exact_size_in_bytes = 0;</span>
<span class="line-added">+    }</span>
<span class="line-added">+   _exact_size_in_bytes = _layout-&gt;last_block()-&gt;offset() - _layout-&gt;first_field_block()-&gt;offset();</span>
<span class="line-added">+ </span>
<span class="line-added">+   _static_layout-&gt;add(_static_fields-&gt;flattened_fields());</span>
<span class="line-added">+   _static_layout-&gt;add_contiguously(_static_fields-&gt;oop_fields());</span>
<span class="line-added">+   _static_layout-&gt;add(_static_fields-&gt;primitive_fields());</span>
  
  
    epilogue();
  }
  
<span class="line-added">+ void FieldLayoutBuilder::add_flattened_field_oopmap(OopMapBlocksBuilder* nonstatic_oop_maps,</span>
<span class="line-added">+                 ValueKlass* vklass, int offset) {</span>
<span class="line-added">+   int diff = offset - vklass-&gt;first_field_offset();</span>
<span class="line-added">+   const OopMapBlock* map = vklass-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-added">+   const OopMapBlock* last_map = map + vklass-&gt;nonstatic_oop_map_count();</span>
<span class="line-added">+   while (map &lt; last_map) {</span>
<span class="line-added">+     nonstatic_oop_maps-&gt;add(map-&gt;offset() + diff, map-&gt;count());</span>
<span class="line-added">+     map++;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void FieldLayoutBuilder::epilogue() {
    // Computing oopmaps
    int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
    int max_oop_map_count = super_oop_map_count + _nonstatic_oopmap_count;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 660,10 ***</span>
<span class="line-new-header">--- 906,22 ---</span>
        LayoutRawBlock* b = _root_group-&gt;oop_fields()-&gt;at(i);
        nonstatic_oop_maps-&gt;add(b-&gt;offset(), 1);
      }
    }
  
<span class="line-added">+   GrowableArray&lt;LayoutRawBlock*&gt;* ff = _root_group-&gt;flattened_fields();</span>
<span class="line-added">+   if (ff != NULL) {</span>
<span class="line-added">+     for (int i = 0; i &lt; ff-&gt;length(); i++) {</span>
<span class="line-added">+       LayoutRawBlock* f = ff-&gt;at(i);</span>
<span class="line-added">+       ValueKlass* vk = f-&gt;value_klass();</span>
<span class="line-added">+       assert(vk != NULL, &quot;Should have been initialized&quot;);</span>
<span class="line-added">+       if (vk-&gt;contains_oops()) {</span>
<span class="line-added">+         add_flattened_field_oopmap(nonstatic_oop_maps, vk, f-&gt;offset());</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    if (!_contended_groups.is_empty()) {
      for (int i = 0; i &lt; _contended_groups.length(); i++) {
        FieldGroup* cg = _contended_groups.at(i);
        if (cg-&gt;oop_count() &gt; 0) {
          assert(cg-&gt;oop_fields() != NULL &amp;&amp; cg-&gt;oop_fields()-&gt;at(0) != NULL, &quot;oop_count &gt; 0 but no oop fields found&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 686,20 ***</span>
    _info-&gt;_instance_size = align_object_size(instance_end / wordSize);
    _info-&gt;_static_field_size = static_fields_size;
    _info-&gt;_nonstatic_field_size = (nonstatic_field_end - instanceOopDesc::base_offset_in_bytes()) / heapOopSize;
    _info-&gt;_has_nonstatic_fields = _has_nonstatic_fields;
  
    if (PrintFieldLayout) {
      ResourceMark rm;
      tty-&gt;print_cr(&quot;Layout of class %s&quot;, _classname-&gt;as_C_string());
      tty-&gt;print_cr(&quot;Instance fields:&quot;);
      _layout-&gt;print(tty, false, _super_klass);
      tty-&gt;print_cr(&quot;Static fields:&quot;);
      _static_layout-&gt;print(tty, true, NULL);
      tty-&gt;print_cr(&quot;Instance size = %d bytes&quot;, _info-&gt;_instance_size * wordSize);
      tty-&gt;print_cr(&quot;---&quot;);
    }
  }
  
<span class="line-modified">! void FieldLayoutBuilder::build_layout() {</span>
<span class="line-modified">!   compute_regular_layout();</span>
  }
<span class="line-new-header">--- 944,42 ---</span>
    _info-&gt;_instance_size = align_object_size(instance_end / wordSize);
    _info-&gt;_static_field_size = static_fields_size;
    _info-&gt;_nonstatic_field_size = (nonstatic_field_end - instanceOopDesc::base_offset_in_bytes()) / heapOopSize;
    _info-&gt;_has_nonstatic_fields = _has_nonstatic_fields;
  
<span class="line-added">+   // An inline type is naturally atomic if it has just one field, and</span>
<span class="line-added">+   // that field is simple enough.</span>
<span class="line-added">+   _info-&gt;_is_naturally_atomic = (_is_inline_type &amp;&amp;</span>
<span class="line-added">+                                  (_atomic_field_count &lt;= 1) &amp;&amp;</span>
<span class="line-added">+                                  !_has_nonatomic_values &amp;&amp;</span>
<span class="line-added">+                                  _contended_groups.is_empty());</span>
<span class="line-added">+   // This may be too restrictive, since if all the fields fit in 64</span>
<span class="line-added">+   // bits we could make the decision to align instances of this class</span>
<span class="line-added">+   // to 64-bit boundaries, and load and store them as single words.</span>
<span class="line-added">+   // And on machines which supported larger atomics we could similarly</span>
<span class="line-added">+   // allow larger values to be atomic, if properly aligned.</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
    if (PrintFieldLayout) {
      ResourceMark rm;
      tty-&gt;print_cr(&quot;Layout of class %s&quot;, _classname-&gt;as_C_string());
      tty-&gt;print_cr(&quot;Instance fields:&quot;);
      _layout-&gt;print(tty, false, _super_klass);
      tty-&gt;print_cr(&quot;Static fields:&quot;);
      _static_layout-&gt;print(tty, true, NULL);
      tty-&gt;print_cr(&quot;Instance size = %d bytes&quot;, _info-&gt;_instance_size * wordSize);
<span class="line-added">+     if (_is_inline_type) {</span>
<span class="line-added">+       tty-&gt;print_cr(&quot;First field offset = %d&quot;, _first_field_offset);</span>
<span class="line-added">+       tty-&gt;print_cr(&quot;Alignment = %d bytes&quot;, _alignment);</span>
<span class="line-added">+       tty-&gt;print_cr(&quot;Exact size = %d bytes&quot;, _exact_size_in_bytes);</span>
<span class="line-added">+     }</span>
      tty-&gt;print_cr(&quot;---&quot;);
    }
  }
  
<span class="line-modified">! void FieldLayoutBuilder::build_layout(TRAPS) {</span>
<span class="line-modified">!   if (_is_inline_type) {</span>
<span class="line-added">+     compute_inline_class_layout(CHECK);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     compute_regular_layout();</span>
<span class="line-added">+   }</span>
  }
</pre>
<center><a href="classLoaderData.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldLayoutBuilder.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
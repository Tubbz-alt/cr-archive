<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="fieldLayoutBuilder.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
<span class="line-modified">  47 #include &quot;oops/instanceMirrorKlass.hpp&quot;</span>
  48 #include &quot;oops/klass.hpp&quot;
  49 #include &quot;oops/method.inline.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/symbol.hpp&quot;
  53 #include &quot;oops/recordComponent.hpp&quot;
  54 #include &quot;oops/typeArrayOop.inline.hpp&quot;


  55 #include &quot;prims/jvmtiExport.hpp&quot;
  56 #include &quot;prims/resolvedMethodTable.hpp&quot;
  57 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  58 #include &quot;runtime/frame.inline.hpp&quot;
  59 #include &quot;runtime/handles.inline.hpp&quot;
  60 #include &quot;runtime/init.hpp&quot;
  61 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  62 #include &quot;runtime/java.hpp&quot;
  63 #include &quot;runtime/javaCalls.hpp&quot;
  64 #include &quot;runtime/jniHandles.inline.hpp&quot;
  65 #include &quot;runtime/safepoint.hpp&quot;
  66 #include &quot;runtime/safepointVerifiers.hpp&quot;
  67 #include &quot;runtime/thread.inline.hpp&quot;
  68 #include &quot;runtime/vframe.inline.hpp&quot;
  69 #include &quot;runtime/vm_version.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/preserveException.hpp&quot;
  72 #include &quot;utilities/utf8.hpp&quot;
  73 #if INCLUDE_JVMCI
  74 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
</pre>
<hr />
<pre>
 967   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 968   k-&gt;set_modifier_flags(computed_modifiers);
 969   // Class_klass has to be loaded because it is used to allocate
 970   // the mirror.
 971   if (SystemDictionary::Class_klass_loaded()) {
 972     // Allocate mirror (java.lang.Class instance)
 973     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 974     Handle mirror(THREAD, mirror_oop);
 975     Handle comp_mirror;
 976 
 977     // Setup indirection from mirror-&gt;klass
 978     java_lang_Class::set_klass(mirror(), k);
 979 
 980     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
 981     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
 982 
 983     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
 984 
 985     // It might also have a component mirror.  This mirror must already exist.
 986     if (k-&gt;is_array_klass()) {
<span class="line-modified"> 987       if (k-&gt;is_typeArray_klass()) {</span>





 988         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
 989         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
 990       } else {
 991         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
 992         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
 993         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
 994         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
 995       }
 996       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
 997 
 998       // Two-way link between the array klass and its component mirror:
 999       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
1000       set_component_mirror(mirror(), comp_mirror());
1001       // See below for ordering dependencies between field array_klass in component mirror
1002       // and java_mirror in this klass.
1003     } else {
1004       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1005 
1006       initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);
1007       if (HAS_PENDING_EXCEPTION) {
</pre>
<hr />
<pre>
1014       }
1015     }
1016 
1017     // set the classLoader field in the java_lang_Class instance
1018     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1019     set_class_loader(mirror(), class_loader());
1020 
1021     // Setup indirection from klass-&gt;mirror
1022     // after any exceptions can happen during allocations.
1023     k-&gt;set_java_mirror(mirror);
1024 
1025     // Set the module field in the java_lang_Class instance.  This must be done
1026     // after the mirror is set.
1027     set_mirror_module_field(k, mirror, module, THREAD);
1028 
1029     if (comp_mirror() != NULL) {
1030       // Set after k-&gt;java_mirror() is published, because compiled code running
1031       // concurrently doesn&#39;t expect a k to have a null java_mirror.
1032       release_set_array_klass(comp_mirror(), k);
1033     }

















1034   } else {
1035     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1036     fixup_mirror_list()-&gt;push(k);
1037   }
1038 }
1039 
1040 #if INCLUDE_CDS_JAVA_HEAP
1041 // Clears mirror fields. Static final fields with initial values are reloaded
1042 // from constant pool. The object identity hash is in the object header and is
1043 // not affected.
1044 class ResetMirrorField: public FieldClosure {
1045  private:
1046   Handle _m;
1047 
1048  public:
1049   ResetMirrorField(Handle mirror) : _m(mirror) {}
1050 
1051   void do_field(fieldDescriptor* fd) {
1052     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1053     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
</pre>
<hr />
<pre>
1170 
1171   // No mirror
1172   oop mirror = k-&gt;java_mirror();
1173   if (mirror == NULL) {
1174     return NULL;
1175   }
1176 
1177   if (k-&gt;is_instance_klass()) {
1178     InstanceKlass *ik = InstanceKlass::cast(k);
1179     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1180 
1181     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1182           ik-&gt;is_shared_app_class())) {
1183       // Archiving mirror for classes from non-builtin loaders is not
1184       // supported. Clear the _java_mirror within the archived class.
1185       k-&gt;set_java_mirror_handle(NULL);
1186       return NULL;
1187     }
1188   }
1189 






1190   // Now start archiving the mirror object
1191   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1192   if (archived_mirror == NULL) {
1193     return NULL;
1194   }
1195 
1196   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1197   if (archived_mirror == NULL) {
1198     return NULL;
1199   }
1200 
1201   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1202 
1203   k-&gt;set_has_raw_archived_mirror();
1204 
1205   ResourceMark rm;
1206   log_trace(cds, heap, mirror)(
1207     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1208     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1209 
</pre>
<hr />
<pre>
1461 oop java_lang_Class::name(Handle java_class, TRAPS) {
1462   assert(_name_offset != 0, &quot;must be set&quot;);
1463   oop o = java_class-&gt;obj_field(_name_offset);
1464   if (o == NULL) {
1465     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1466     java_class-&gt;obj_field_put(_name_offset, o);
1467   }
1468   return o;
1469 }
1470 
1471 oop java_lang_Class::source_file(oop java_class) {
1472   assert(_source_file_offset != 0, &quot;must be set&quot;);
1473   return java_class-&gt;obj_field(_source_file_offset);
1474 }
1475 
1476 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1477   assert(_source_file_offset != 0, &quot;must be set&quot;);
1478   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1479 }
1480 




















1481 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1482   // This should be improved by adding a field at the Java level or by
1483   // introducing a new VM klass (see comment in ClassFileParser)
1484   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1485   if (type != T_VOID) {
1486     Klass* aklass = Universe::typeArrayKlassObj(type);
1487     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1488     release_set_array_klass(java_class, aklass);
1489   }
1490 #ifdef ASSERT
1491   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1492   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1493 #endif
1494   return java_class;
1495 }
1496 
1497 
1498 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1499   //%note memory_2
1500   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1501   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1502   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1503   return k;
1504 }
1505 
1506 
1507 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1508   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1509   java_class-&gt;metadata_field_put(_klass_offset, klass);
1510 }
1511 
1512 
1513 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1514   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1515   Symbol* name = NULL;
1516   bool is_instance = false;

1517   if (is_primitive(java_class)) {
1518     name = vmSymbols::type_signature(primitive_type(java_class));
1519   } else {
1520     Klass* k = as_Klass(java_class);
1521     is_instance = k-&gt;is_instance_klass();

1522     name = k-&gt;name();
1523   }
1524   if (name == NULL) {
1525     st-&gt;print(&quot;&lt;null&gt;&quot;);
1526     return;
1527   }
<span class="line-modified">1528   if (is_instance)  st-&gt;print(&quot;L&quot;);</span>






1529   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1530   if (is_instance)  st-&gt;print(&quot;;&quot;);
1531 }
1532 
1533 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1534   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1535   Symbol* name;
1536   if (is_primitive(java_class)) {
1537     name = vmSymbols::type_signature(primitive_type(java_class));
1538     // Because this can create a new symbol, the caller has to decrement
1539     // the refcount, so make adjustment here and below for symbols returned
1540     // that are not created or incremented due to a successful lookup.
1541     name-&gt;increment_refcount();
1542   } else {
1543     Klass* k = as_Klass(java_class);
1544     if (!k-&gt;is_instance_klass()) {
1545       name = k-&gt;name();
1546       name-&gt;increment_refcount();
1547     } else {
1548       ResourceMark rm;
1549       const char* sigstr = k-&gt;signature_name();
<span class="line-modified">1550       int         siglen = (int) strlen(sigstr);</span>
1551       if (!intern_if_not_found) {
1552         name = SymbolTable::probe(sigstr, siglen);
1553       } else {
1554         name = SymbolTable::new_symbol(sigstr, siglen);
1555       }
1556     }
1557   }
1558   return name;
1559 }
1560 
1561 // Returns the Java name for this Java mirror (Resource allocated)
1562 // See Klass::external_name().
1563 // For primitive type Java mirrors, its type name is returned.
1564 const char* java_lang_Class::as_external_name(oop java_class) {
1565   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1566   const char* name = NULL;
1567   if (is_primitive(java_class)) {
1568     name = type2name(primitive_type(java_class));
1569   } else {
1570     name = as_Klass(java_class)-&gt;external_name();
</pre>
<hr />
<pre>
1615   }
1616 }
1617 
1618 
1619 oop java_lang_Class::primitive_mirror(BasicType t) {
1620   oop mirror = Universe::java_mirror(t);
1621   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1622   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1623   return mirror;
1624 }
1625 
1626 bool java_lang_Class::offsets_computed = false;
1627 int  java_lang_Class::classRedefinedCount_offset = -1;
1628 
1629 #define CLASS_FIELDS_DO(macro) \
1630   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1631   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
1632   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
1633   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
1634   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \


1635   macro(_classData_offset,          k, &quot;classData&quot;,           object_signature,      false);
1636 
1637 void java_lang_Class::compute_offsets() {
1638   if (offsets_computed) {
1639     return;
1640   }
1641 
1642   offsets_computed = true;
1643 
1644   InstanceKlass* k = SystemDictionary::Class_klass();
1645   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1646 
1647   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1648   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1649   // GC treats them the same.
1650   _init_lock_offset = _component_mirror_offset;
1651 
1652   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1653 }
1654 
</pre>
<hr />
<pre>
2490 #endif
2491 
2492     // the format of the stacktrace will be:
2493     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2494     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2495     // - rest of the stack
2496 
2497     if (!skip_fillInStackTrace_check) {
2498       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2499           throwable-&gt;is_a(method-&gt;method_holder())) {
2500         continue;
2501       }
2502       else {
2503         skip_fillInStackTrace_check = true; // gone past them all
2504       }
2505     }
2506     if (!skip_throwableInit_check) {
2507       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2508 
2509       // skip &lt;init&gt; methods of the exception class and superclasses
<span class="line-modified">2510       // This is simlar to classic VM.</span>
<span class="line-modified">2511       if (method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;</span>
2512           throwable-&gt;is_a(method-&gt;method_holder())) {
2513         continue;
2514       } else {
2515         // there are none or we&#39;ve seen them all - either way stop checking
2516         skip_throwableInit_check = true;
2517       }
2518     }
2519     if (method-&gt;is_hidden()) {
2520       if (skip_hidden) {
2521         if (total_count == 0) {
2522           // The top frame will be hidden from the stack trace.
2523           bt.set_has_hidden_top_frame(CHECK);
2524         }
2525         continue;
2526       }
2527     }
2528     bt.push(method, bci, CHECK);
2529     total_count++;
2530   }
2531 
</pre>
<hr />
<pre>
3774 int java_lang_invoke_MemberName::flags(oop mname) {
3775   assert(is_instance(mname), &quot;wrong type&quot;);
3776   return mname-&gt;int_field(_flags_offset);
3777 }
3778 
3779 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
3780   assert(is_instance(mname), &quot;wrong type&quot;);
3781   mname-&gt;int_field_put(_flags_offset, flags);
3782 }
3783 
3784 
3785 // Return vmtarget from ResolvedMethodName method field through indirection
3786 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
3787   assert(is_instance(mname), &quot;wrong type&quot;);
3788   oop method = mname-&gt;obj_field(_method_offset);
3789   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
3790 }
3791 
3792 bool java_lang_invoke_MemberName::is_method(oop mname) {
3793   assert(is_instance(mname), &quot;must be MemberName&quot;);
<span class="line-modified">3794   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_CONSTRUCTOR)) &gt; 0;</span>
3795 }
3796 
3797 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
3798   assert(is_instance(mname), &quot;wrong type&quot;);
3799   mname-&gt;obj_field_put(_method_offset, resolved_method);
3800 }
3801 
3802 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
3803   assert(is_instance(mname), &quot;wrong type&quot;);
3804   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
3805 }
3806 
3807 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3808   assert(is_instance(mname), &quot;wrong type&quot;);
3809   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3810 }
3811 
3812 
3813 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3814   assert(is_instance(resolved_method), &quot;wrong type&quot;);
</pre>
<hr />
<pre>
4280       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);
4281     } else {
4282       assert(false, &quot;unexpected UnsafeConstants field&quot;);
4283     }
4284   }
4285 };
4286 
4287 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4288   UnsafeConstantsFixup fixup;
4289   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4290 }
4291 
4292 int java_lang_Class::_klass_offset;
4293 int java_lang_Class::_array_klass_offset;
4294 int java_lang_Class::_oop_size_offset;
4295 int java_lang_Class::_static_oop_field_count_offset;
4296 int java_lang_Class::_class_loader_offset;
4297 int java_lang_Class::_module_offset;
4298 int java_lang_Class::_protection_domain_offset;
4299 int java_lang_Class::_component_mirror_offset;


4300 int java_lang_Class::_init_lock_offset;
4301 int java_lang_Class::_signers_offset;
4302 int java_lang_Class::_name_offset;
4303 int java_lang_Class::_source_file_offset;
4304 int java_lang_Class::_classData_offset;
4305 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
4306 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
4307 int java_lang_Throwable::backtrace_offset;
4308 int java_lang_Throwable::detailMessage_offset;
4309 int java_lang_Throwable::stackTrace_offset;
4310 int java_lang_Throwable::depth_offset;
4311 int java_lang_Throwable::static_unassigned_stacktrace_offset;
4312 int java_lang_reflect_AccessibleObject::override_offset;
4313 int java_lang_reflect_Method::clazz_offset;
4314 int java_lang_reflect_Method::name_offset;
4315 int java_lang_reflect_Method::returnType_offset;
4316 int java_lang_reflect_Method::parameterTypes_offset;
4317 int java_lang_reflect_Method::exceptionTypes_offset;
4318 int java_lang_reflect_Method::slot_offset;
4319 int java_lang_reflect_Method::modifiers_offset;
</pre>
<hr />
<pre>
4374 int java_lang_AssertionStatusDirectives::packageEnabled_offset;
4375 int java_lang_AssertionStatusDirectives::deflt_offset;
4376 int java_nio_Buffer::_limit_offset;
4377 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
4378 int reflect_ConstantPool::_oop_offset;
4379 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
4380 int java_lang_Integer_IntegerCache::_static_cache_offset;
4381 int java_lang_Long_LongCache::_static_cache_offset;
4382 int java_lang_Character_CharacterCache::_static_cache_offset;
4383 int java_lang_Short_ShortCache::_static_cache_offset;
4384 int java_lang_Byte_ByteCache::_static_cache_offset;
4385 int java_lang_Boolean::_static_TRUE_offset;
4386 int java_lang_Boolean::_static_FALSE_offset;
4387 int java_lang_reflect_RecordComponent::clazz_offset;
4388 int java_lang_reflect_RecordComponent::name_offset;
4389 int java_lang_reflect_RecordComponent::type_offset;
4390 int java_lang_reflect_RecordComponent::accessor_offset;
4391 int java_lang_reflect_RecordComponent::signature_offset;
4392 int java_lang_reflect_RecordComponent::annotations_offset;
4393 int java_lang_reflect_RecordComponent::typeAnnotations_offset;





4394 
4395 
4396 
4397 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
4398   macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \
4399   macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \
4400   macro(moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \
4401   macro(moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \
4402   macro(declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \
4403   macro(methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \
4404   macro(fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \
4405   macro(lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)
4406 
4407 // Support for java_lang_StackTraceElement
4408 void java_lang_StackTraceElement::compute_offsets() {
4409   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4410   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4411 }
4412 
4413 #if INCLUDE_CDS
</pre>
<hr />
<pre>
4679   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4680   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4681 }
4682 
4683 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4684   oop base = ik-&gt;static_field_base_raw();
4685   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4686 }
4687 
4688 Symbol* java_lang_Byte_ByteCache::symbol() {
4689   return vmSymbols::java_lang_Byte_ByteCache();
4690 }
4691 
4692 #if INCLUDE_CDS
4693 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4694   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4695 }
4696 #endif
4697 #undef BYTE_CACHE_FIELDS_DO
4698 































































4699 jbyte java_lang_Byte::value(oop obj) {
4700    jvalue v;
4701    java_lang_boxing_object::get_value(obj, &amp;v);
4702    return v.b;
4703 }
4704 #define BOOLEAN_FIELDS_DO(macro) \
4705   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4706   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4707 
4708 
4709 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4710   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4711   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4712 }
4713 
4714 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
4715   oop base = ik-&gt;static_field_base_raw();
4716   return base-&gt;obj_field(_static_TRUE_offset);
4717 }
4718 
</pre>
</td>
<td>
<hr />
<pre>
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
<span class="line-modified">  47 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;</span>
  48 #include &quot;oops/klass.hpp&quot;
  49 #include &quot;oops/method.inline.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/symbol.hpp&quot;
  53 #include &quot;oops/recordComponent.hpp&quot;
  54 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<span class="line-added">  55 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
<span class="line-added">  56 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  57 #include &quot;prims/jvmtiExport.hpp&quot;
  58 #include &quot;prims/resolvedMethodTable.hpp&quot;
  59 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  60 #include &quot;runtime/frame.inline.hpp&quot;
  61 #include &quot;runtime/handles.inline.hpp&quot;
  62 #include &quot;runtime/init.hpp&quot;
  63 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  64 #include &quot;runtime/java.hpp&quot;
  65 #include &quot;runtime/javaCalls.hpp&quot;
  66 #include &quot;runtime/jniHandles.inline.hpp&quot;
  67 #include &quot;runtime/safepoint.hpp&quot;
  68 #include &quot;runtime/safepointVerifiers.hpp&quot;
  69 #include &quot;runtime/thread.inline.hpp&quot;
  70 #include &quot;runtime/vframe.inline.hpp&quot;
  71 #include &quot;runtime/vm_version.hpp&quot;
  72 #include &quot;utilities/align.hpp&quot;
  73 #include &quot;utilities/preserveException.hpp&quot;
  74 #include &quot;utilities/utf8.hpp&quot;
  75 #if INCLUDE_JVMCI
  76 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
</pre>
<hr />
<pre>
 969   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 970   k-&gt;set_modifier_flags(computed_modifiers);
 971   // Class_klass has to be loaded because it is used to allocate
 972   // the mirror.
 973   if (SystemDictionary::Class_klass_loaded()) {
 974     // Allocate mirror (java.lang.Class instance)
 975     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 976     Handle mirror(THREAD, mirror_oop);
 977     Handle comp_mirror;
 978 
 979     // Setup indirection from mirror-&gt;klass
 980     java_lang_Class::set_klass(mirror(), k);
 981 
 982     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
 983     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
 984 
 985     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
 986 
 987     // It might also have a component mirror.  This mirror must already exist.
 988     if (k-&gt;is_array_klass()) {
<span class="line-modified"> 989       if (k-&gt;is_valueArray_klass()) {</span>
<span class="line-added"> 990         Klass* element_klass = (Klass*) ValueArrayKlass::cast(k)-&gt;element_klass();</span>
<span class="line-added"> 991         assert(element_klass-&gt;is_value(), &quot;Must be value type component&quot;);</span>
<span class="line-added"> 992         ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(element_klass));</span>
<span class="line-added"> 993         comp_mirror = Handle(THREAD, vk-&gt;java_mirror());</span>
<span class="line-added"> 994       } else if (k-&gt;is_typeArray_klass()) {</span>
 995         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
 996         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
 997       } else {
 998         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
 999         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1000         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1001         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
1002       }
1003       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
1004 
1005       // Two-way link between the array klass and its component mirror:
1006       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
1007       set_component_mirror(mirror(), comp_mirror());
1008       // See below for ordering dependencies between field array_klass in component mirror
1009       // and java_mirror in this klass.
1010     } else {
1011       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1012 
1013       initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);
1014       if (HAS_PENDING_EXCEPTION) {
</pre>
<hr />
<pre>
1021       }
1022     }
1023 
1024     // set the classLoader field in the java_lang_Class instance
1025     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1026     set_class_loader(mirror(), class_loader());
1027 
1028     // Setup indirection from klass-&gt;mirror
1029     // after any exceptions can happen during allocations.
1030     k-&gt;set_java_mirror(mirror);
1031 
1032     // Set the module field in the java_lang_Class instance.  This must be done
1033     // after the mirror is set.
1034     set_mirror_module_field(k, mirror, module, THREAD);
1035 
1036     if (comp_mirror() != NULL) {
1037       // Set after k-&gt;java_mirror() is published, because compiled code running
1038       // concurrently doesn&#39;t expect a k to have a null java_mirror.
1039       release_set_array_klass(comp_mirror(), k);
1040     }
<span class="line-added">1041 </span>
<span class="line-added">1042     if (k-&gt;is_value()) {</span>
<span class="line-added">1043       InstanceKlass* super = k-&gt;java_super();</span>
<span class="line-added">1044       set_val_type_mirror(mirror(), mirror());</span>
<span class="line-added">1045 </span>
<span class="line-added">1046       // if the supertype is a restricted abstract class</span>
<span class="line-added">1047       if (super != SystemDictionary::Object_klass()) {</span>
<span class="line-added">1048         assert(super-&gt;access_flags().is_abstract(), &quot;must be an abstract class&quot;);</span>
<span class="line-added">1049         oop ref_type_oop = super-&gt;java_mirror();</span>
<span class="line-added">1050         // set the reference projection type</span>
<span class="line-added">1051         set_ref_type_mirror(mirror(), ref_type_oop);</span>
<span class="line-added">1052 </span>
<span class="line-added">1053         // set the value and reference projection types</span>
<span class="line-added">1054         set_val_type_mirror(ref_type_oop, mirror());</span>
<span class="line-added">1055         set_ref_type_mirror(ref_type_oop, ref_type_oop);</span>
<span class="line-added">1056       }</span>
<span class="line-added">1057     }</span>
1058   } else {
1059     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1060     fixup_mirror_list()-&gt;push(k);
1061   }
1062 }
1063 
1064 #if INCLUDE_CDS_JAVA_HEAP
1065 // Clears mirror fields. Static final fields with initial values are reloaded
1066 // from constant pool. The object identity hash is in the object header and is
1067 // not affected.
1068 class ResetMirrorField: public FieldClosure {
1069  private:
1070   Handle _m;
1071 
1072  public:
1073   ResetMirrorField(Handle mirror) : _m(mirror) {}
1074 
1075   void do_field(fieldDescriptor* fd) {
1076     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1077     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
</pre>
<hr />
<pre>
1194 
1195   // No mirror
1196   oop mirror = k-&gt;java_mirror();
1197   if (mirror == NULL) {
1198     return NULL;
1199   }
1200 
1201   if (k-&gt;is_instance_klass()) {
1202     InstanceKlass *ik = InstanceKlass::cast(k);
1203     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1204 
1205     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1206           ik-&gt;is_shared_app_class())) {
1207       // Archiving mirror for classes from non-builtin loaders is not
1208       // supported. Clear the _java_mirror within the archived class.
1209       k-&gt;set_java_mirror_handle(NULL);
1210       return NULL;
1211     }
1212   }
1213 
<span class="line-added">1214   if (k-&gt;is_value()) {</span>
<span class="line-added">1215     // Values have a val type mirror and a ref type mirror. Don&#39;t handle this for now. TODO:CDS</span>
<span class="line-added">1216     k-&gt;set_java_mirror_handle(NULL);</span>
<span class="line-added">1217     return NULL;</span>
<span class="line-added">1218   }</span>
<span class="line-added">1219 </span>
1220   // Now start archiving the mirror object
1221   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1222   if (archived_mirror == NULL) {
1223     return NULL;
1224   }
1225 
1226   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1227   if (archived_mirror == NULL) {
1228     return NULL;
1229   }
1230 
1231   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1232 
1233   k-&gt;set_has_raw_archived_mirror();
1234 
1235   ResourceMark rm;
1236   log_trace(cds, heap, mirror)(
1237     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1238     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1239 
</pre>
<hr />
<pre>
1491 oop java_lang_Class::name(Handle java_class, TRAPS) {
1492   assert(_name_offset != 0, &quot;must be set&quot;);
1493   oop o = java_class-&gt;obj_field(_name_offset);
1494   if (o == NULL) {
1495     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1496     java_class-&gt;obj_field_put(_name_offset, o);
1497   }
1498   return o;
1499 }
1500 
1501 oop java_lang_Class::source_file(oop java_class) {
1502   assert(_source_file_offset != 0, &quot;must be set&quot;);
1503   return java_class-&gt;obj_field(_source_file_offset);
1504 }
1505 
1506 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1507   assert(_source_file_offset != 0, &quot;must be set&quot;);
1508   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1509 }
1510 
<span class="line-added">1511 oop java_lang_Class::val_type_mirror(oop java_class) {</span>
<span class="line-added">1512   assert(_val_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1513   return java_class-&gt;obj_field(_val_type_mirror_offset);</span>
<span class="line-added">1514 }</span>
<span class="line-added">1515 </span>
<span class="line-added">1516 void java_lang_Class::set_val_type_mirror(oop java_class, oop mirror) {</span>
<span class="line-added">1517   assert(_val_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1518   java_class-&gt;obj_field_put(_val_type_mirror_offset, mirror);</span>
<span class="line-added">1519 }</span>
<span class="line-added">1520 </span>
<span class="line-added">1521 oop java_lang_Class::ref_type_mirror(oop java_class) {</span>
<span class="line-added">1522   assert(_ref_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1523   return java_class-&gt;obj_field(_ref_type_mirror_offset);</span>
<span class="line-added">1524 }</span>
<span class="line-added">1525 </span>
<span class="line-added">1526 void java_lang_Class::set_ref_type_mirror(oop java_class, oop mirror) {</span>
<span class="line-added">1527   assert(_ref_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1528   java_class-&gt;obj_field_put(_ref_type_mirror_offset, mirror);</span>
<span class="line-added">1529 }</span>
<span class="line-added">1530 </span>
1531 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1532   // This should be improved by adding a field at the Java level or by
1533   // introducing a new VM klass (see comment in ClassFileParser)
1534   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1535   if (type != T_VOID) {
1536     Klass* aklass = Universe::typeArrayKlassObj(type);
1537     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1538     release_set_array_klass(java_class, aklass);
1539   }
1540 #ifdef ASSERT
1541   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1542   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1543 #endif
1544   return java_class;
1545 }
1546 
1547 
1548 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1549   //%note memory_2
1550   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1551   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1552   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1553   return k;
1554 }
1555 
1556 
1557 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1558   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1559   java_class-&gt;metadata_field_put(_klass_offset, klass);
1560 }
1561 
1562 
1563 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1564   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1565   Symbol* name = NULL;
1566   bool is_instance = false;
<span class="line-added">1567   bool is_value = false;</span>
1568   if (is_primitive(java_class)) {
1569     name = vmSymbols::type_signature(primitive_type(java_class));
1570   } else {
1571     Klass* k = as_Klass(java_class);
1572     is_instance = k-&gt;is_instance_klass();
<span class="line-added">1573     is_value = k-&gt;is_value();</span>
1574     name = k-&gt;name();
1575   }
1576   if (name == NULL) {
1577     st-&gt;print(&quot;&lt;null&gt;&quot;);
1578     return;
1579   }
<span class="line-modified">1580   if (is_instance)  {</span>
<span class="line-added">1581     if (is_value) {</span>
<span class="line-added">1582       st-&gt;print(&quot;Q&quot;);</span>
<span class="line-added">1583     } else {</span>
<span class="line-added">1584       st-&gt;print(&quot;L&quot;);</span>
<span class="line-added">1585     }</span>
<span class="line-added">1586   }</span>
1587   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1588   if (is_instance)  st-&gt;print(&quot;;&quot;);
1589 }
1590 
1591 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1592   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1593   Symbol* name;
1594   if (is_primitive(java_class)) {
1595     name = vmSymbols::type_signature(primitive_type(java_class));
1596     // Because this can create a new symbol, the caller has to decrement
1597     // the refcount, so make adjustment here and below for symbols returned
1598     // that are not created or incremented due to a successful lookup.
1599     name-&gt;increment_refcount();
1600   } else {
1601     Klass* k = as_Klass(java_class);
1602     if (!k-&gt;is_instance_klass()) {
1603       name = k-&gt;name();
1604       name-&gt;increment_refcount();
1605     } else {
1606       ResourceMark rm;
1607       const char* sigstr = k-&gt;signature_name();
<span class="line-modified">1608       int siglen = (int) strlen(sigstr);</span>
1609       if (!intern_if_not_found) {
1610         name = SymbolTable::probe(sigstr, siglen);
1611       } else {
1612         name = SymbolTable::new_symbol(sigstr, siglen);
1613       }
1614     }
1615   }
1616   return name;
1617 }
1618 
1619 // Returns the Java name for this Java mirror (Resource allocated)
1620 // See Klass::external_name().
1621 // For primitive type Java mirrors, its type name is returned.
1622 const char* java_lang_Class::as_external_name(oop java_class) {
1623   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1624   const char* name = NULL;
1625   if (is_primitive(java_class)) {
1626     name = type2name(primitive_type(java_class));
1627   } else {
1628     name = as_Klass(java_class)-&gt;external_name();
</pre>
<hr />
<pre>
1673   }
1674 }
1675 
1676 
1677 oop java_lang_Class::primitive_mirror(BasicType t) {
1678   oop mirror = Universe::java_mirror(t);
1679   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1680   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1681   return mirror;
1682 }
1683 
1684 bool java_lang_Class::offsets_computed = false;
1685 int  java_lang_Class::classRedefinedCount_offset = -1;
1686 
1687 #define CLASS_FIELDS_DO(macro) \
1688   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1689   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
1690   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
1691   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
1692   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \
<span class="line-added">1693   macro(_val_type_mirror_offset,    k, &quot;valType&quot;,             class_signature,       false); \</span>
<span class="line-added">1694   macro(_ref_type_mirror_offset,    k, &quot;refType&quot;,             class_signature,       false); \</span>
1695   macro(_classData_offset,          k, &quot;classData&quot;,           object_signature,      false);
1696 
1697 void java_lang_Class::compute_offsets() {
1698   if (offsets_computed) {
1699     return;
1700   }
1701 
1702   offsets_computed = true;
1703 
1704   InstanceKlass* k = SystemDictionary::Class_klass();
1705   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1706 
1707   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1708   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1709   // GC treats them the same.
1710   _init_lock_offset = _component_mirror_offset;
1711 
1712   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1713 }
1714 
</pre>
<hr />
<pre>
2550 #endif
2551 
2552     // the format of the stacktrace will be:
2553     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2554     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2555     // - rest of the stack
2556 
2557     if (!skip_fillInStackTrace_check) {
2558       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2559           throwable-&gt;is_a(method-&gt;method_holder())) {
2560         continue;
2561       }
2562       else {
2563         skip_fillInStackTrace_check = true; // gone past them all
2564       }
2565     }
2566     if (!skip_throwableInit_check) {
2567       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2568 
2569       // skip &lt;init&gt; methods of the exception class and superclasses
<span class="line-modified">2570       // This is similar to classic VM (before HotSpot).</span>
<span class="line-modified">2571       if (method-&gt;is_object_constructor() &amp;&amp;</span>
2572           throwable-&gt;is_a(method-&gt;method_holder())) {
2573         continue;
2574       } else {
2575         // there are none or we&#39;ve seen them all - either way stop checking
2576         skip_throwableInit_check = true;
2577       }
2578     }
2579     if (method-&gt;is_hidden()) {
2580       if (skip_hidden) {
2581         if (total_count == 0) {
2582           // The top frame will be hidden from the stack trace.
2583           bt.set_has_hidden_top_frame(CHECK);
2584         }
2585         continue;
2586       }
2587     }
2588     bt.push(method, bci, CHECK);
2589     total_count++;
2590   }
2591 
</pre>
<hr />
<pre>
3834 int java_lang_invoke_MemberName::flags(oop mname) {
3835   assert(is_instance(mname), &quot;wrong type&quot;);
3836   return mname-&gt;int_field(_flags_offset);
3837 }
3838 
3839 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
3840   assert(is_instance(mname), &quot;wrong type&quot;);
3841   mname-&gt;int_field_put(_flags_offset, flags);
3842 }
3843 
3844 
3845 // Return vmtarget from ResolvedMethodName method field through indirection
3846 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
3847   assert(is_instance(mname), &quot;wrong type&quot;);
3848   oop method = mname-&gt;obj_field(_method_offset);
3849   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
3850 }
3851 
3852 bool java_lang_invoke_MemberName::is_method(oop mname) {
3853   assert(is_instance(mname), &quot;must be MemberName&quot;);
<span class="line-modified">3854   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_OBJECT_CONSTRUCTOR)) &gt; 0;</span>
3855 }
3856 
3857 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
3858   assert(is_instance(mname), &quot;wrong type&quot;);
3859   mname-&gt;obj_field_put(_method_offset, resolved_method);
3860 }
3861 
3862 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
3863   assert(is_instance(mname), &quot;wrong type&quot;);
3864   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
3865 }
3866 
3867 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3868   assert(is_instance(mname), &quot;wrong type&quot;);
3869   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3870 }
3871 
3872 
3873 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3874   assert(is_instance(resolved_method), &quot;wrong type&quot;);
</pre>
<hr />
<pre>
4340       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);
4341     } else {
4342       assert(false, &quot;unexpected UnsafeConstants field&quot;);
4343     }
4344   }
4345 };
4346 
4347 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4348   UnsafeConstantsFixup fixup;
4349   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4350 }
4351 
4352 int java_lang_Class::_klass_offset;
4353 int java_lang_Class::_array_klass_offset;
4354 int java_lang_Class::_oop_size_offset;
4355 int java_lang_Class::_static_oop_field_count_offset;
4356 int java_lang_Class::_class_loader_offset;
4357 int java_lang_Class::_module_offset;
4358 int java_lang_Class::_protection_domain_offset;
4359 int java_lang_Class::_component_mirror_offset;
<span class="line-added">4360 int java_lang_Class::_val_type_mirror_offset;</span>
<span class="line-added">4361 int java_lang_Class::_ref_type_mirror_offset;</span>
4362 int java_lang_Class::_init_lock_offset;
4363 int java_lang_Class::_signers_offset;
4364 int java_lang_Class::_name_offset;
4365 int java_lang_Class::_source_file_offset;
4366 int java_lang_Class::_classData_offset;
4367 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
4368 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
4369 int java_lang_Throwable::backtrace_offset;
4370 int java_lang_Throwable::detailMessage_offset;
4371 int java_lang_Throwable::stackTrace_offset;
4372 int java_lang_Throwable::depth_offset;
4373 int java_lang_Throwable::static_unassigned_stacktrace_offset;
4374 int java_lang_reflect_AccessibleObject::override_offset;
4375 int java_lang_reflect_Method::clazz_offset;
4376 int java_lang_reflect_Method::name_offset;
4377 int java_lang_reflect_Method::returnType_offset;
4378 int java_lang_reflect_Method::parameterTypes_offset;
4379 int java_lang_reflect_Method::exceptionTypes_offset;
4380 int java_lang_reflect_Method::slot_offset;
4381 int java_lang_reflect_Method::modifiers_offset;
</pre>
<hr />
<pre>
4436 int java_lang_AssertionStatusDirectives::packageEnabled_offset;
4437 int java_lang_AssertionStatusDirectives::deflt_offset;
4438 int java_nio_Buffer::_limit_offset;
4439 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
4440 int reflect_ConstantPool::_oop_offset;
4441 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
4442 int java_lang_Integer_IntegerCache::_static_cache_offset;
4443 int java_lang_Long_LongCache::_static_cache_offset;
4444 int java_lang_Character_CharacterCache::_static_cache_offset;
4445 int java_lang_Short_ShortCache::_static_cache_offset;
4446 int java_lang_Byte_ByteCache::_static_cache_offset;
4447 int java_lang_Boolean::_static_TRUE_offset;
4448 int java_lang_Boolean::_static_FALSE_offset;
4449 int java_lang_reflect_RecordComponent::clazz_offset;
4450 int java_lang_reflect_RecordComponent::name_offset;
4451 int java_lang_reflect_RecordComponent::type_offset;
4452 int java_lang_reflect_RecordComponent::accessor_offset;
4453 int java_lang_reflect_RecordComponent::signature_offset;
4454 int java_lang_reflect_RecordComponent::annotations_offset;
4455 int java_lang_reflect_RecordComponent::typeAnnotations_offset;
<span class="line-added">4456 int jdk_internal_vm_jni_SubElementSelector::_arrayElementType_offset;</span>
<span class="line-added">4457 int jdk_internal_vm_jni_SubElementSelector::_subElementType_offset;</span>
<span class="line-added">4458 int jdk_internal_vm_jni_SubElementSelector::_offset_offset;</span>
<span class="line-added">4459 int jdk_internal_vm_jni_SubElementSelector::_isFlattened_offset;</span>
<span class="line-added">4460 int jdk_internal_vm_jni_SubElementSelector::_isFlattenable_offset;</span>
4461 
4462 
4463 
4464 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
4465   macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \
4466   macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \
4467   macro(moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \
4468   macro(moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \
4469   macro(declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \
4470   macro(methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \
4471   macro(fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \
4472   macro(lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)
4473 
4474 // Support for java_lang_StackTraceElement
4475 void java_lang_StackTraceElement::compute_offsets() {
4476   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4477   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4478 }
4479 
4480 #if INCLUDE_CDS
</pre>
<hr />
<pre>
4746   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4747   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4748 }
4749 
4750 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4751   oop base = ik-&gt;static_field_base_raw();
4752   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4753 }
4754 
4755 Symbol* java_lang_Byte_ByteCache::symbol() {
4756   return vmSymbols::java_lang_Byte_ByteCache();
4757 }
4758 
4759 #if INCLUDE_CDS
4760 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4761   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4762 }
4763 #endif
4764 #undef BYTE_CACHE_FIELDS_DO
4765 
<span class="line-added">4766 #define SUBELEMENT_SELECTOR_FIELDS_DO(macro) \</span>
<span class="line-added">4767   macro(_arrayElementType_offset,  k, &quot;arrayElementType&quot;, class_signature, false); \</span>
<span class="line-added">4768   macro(_subElementType_offset,    k, &quot;subElementType&quot;,   class_signature, false); \</span>
<span class="line-added">4769   macro(_offset_offset,            k, &quot;offset&quot;,           int_signature,   false); \</span>
<span class="line-added">4770   macro(_isFlattened_offset,       k, &quot;isFlattened&quot;,      bool_signature,  false); \</span>
<span class="line-added">4771   macro(_isFlattenable_offset,     k, &quot;isFlattenable&quot;,    bool_signature,  false);</span>
<span class="line-added">4772 </span>
<span class="line-added">4773 void jdk_internal_vm_jni_SubElementSelector::compute_offsets() {</span>
<span class="line-added">4774   InstanceKlass* k = SystemDictionary::jdk_internal_vm_jni_SubElementSelector_klass();</span>
<span class="line-added">4775   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">4776 }</span>
<span class="line-added">4777 </span>
<span class="line-added">4778 #if INCLUDE_CDS</span>
<span class="line-added">4779 void jdk_internal_vm_jni_SubElementSelector::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">4780   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">4781 }</span>
<span class="line-added">4782 #endif</span>
<span class="line-added">4783 #undef SUBELEMENT_SELECTOR_FIELDS_DO</span>
<span class="line-added">4784 </span>
<span class="line-added">4785 Symbol* jdk_internal_vm_jni_SubElementSelector::symbol() {</span>
<span class="line-added">4786   return vmSymbols::jdk_internal_vm_jni_SubElementSelector();</span>
<span class="line-added">4787 }</span>
<span class="line-added">4788 </span>
<span class="line-added">4789 oop jdk_internal_vm_jni_SubElementSelector::getArrayElementType(oop obj) {</span>
<span class="line-added">4790   return obj-&gt;obj_field(_arrayElementType_offset);</span>
<span class="line-added">4791 }</span>
<span class="line-added">4792 </span>
<span class="line-added">4793 void jdk_internal_vm_jni_SubElementSelector::setArrayElementType(oop obj, oop type) {</span>
<span class="line-added">4794   obj-&gt;obj_field_put(_arrayElementType_offset, type);</span>
<span class="line-added">4795 }</span>
<span class="line-added">4796 </span>
<span class="line-added">4797 oop jdk_internal_vm_jni_SubElementSelector::getSubElementType(oop obj) {</span>
<span class="line-added">4798   return obj-&gt;obj_field(_subElementType_offset);</span>
<span class="line-added">4799 }</span>
<span class="line-added">4800 </span>
<span class="line-added">4801 void jdk_internal_vm_jni_SubElementSelector::setSubElementType(oop obj, oop type) {</span>
<span class="line-added">4802   obj-&gt;obj_field_put(_subElementType_offset, type);</span>
<span class="line-added">4803 }</span>
<span class="line-added">4804 </span>
<span class="line-added">4805 int jdk_internal_vm_jni_SubElementSelector::getOffset(oop obj) {</span>
<span class="line-added">4806   return obj-&gt;int_field(_offset_offset);</span>
<span class="line-added">4807 }</span>
<span class="line-added">4808 </span>
<span class="line-added">4809 void jdk_internal_vm_jni_SubElementSelector::setOffset(oop obj, int offset) {</span>
<span class="line-added">4810   obj-&gt;int_field_put(_offset_offset, offset);</span>
<span class="line-added">4811 }</span>
<span class="line-added">4812 </span>
<span class="line-added">4813 bool jdk_internal_vm_jni_SubElementSelector::getIsFlattened(oop obj) {</span>
<span class="line-added">4814   return obj-&gt;bool_field(_isFlattened_offset);</span>
<span class="line-added">4815 }</span>
<span class="line-added">4816 </span>
<span class="line-added">4817 void jdk_internal_vm_jni_SubElementSelector::setIsFlattened(oop obj, bool b) {</span>
<span class="line-added">4818   obj-&gt;bool_field_put(_isFlattened_offset, b);</span>
<span class="line-added">4819 }</span>
<span class="line-added">4820 </span>
<span class="line-added">4821 bool jdk_internal_vm_jni_SubElementSelector::getIsFlattenable(oop obj) {</span>
<span class="line-added">4822   return obj-&gt;bool_field(_isFlattenable_offset);</span>
<span class="line-added">4823 }</span>
<span class="line-added">4824 </span>
<span class="line-added">4825 void jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(oop obj, bool b) {</span>
<span class="line-added">4826   obj-&gt;bool_field_put(_isFlattenable_offset, b);</span>
<span class="line-added">4827 }</span>
<span class="line-added">4828 </span>
4829 jbyte java_lang_Byte::value(oop obj) {
4830    jvalue v;
4831    java_lang_boxing_object::get_value(obj, &amp;v);
4832    return v.b;
4833 }
4834 #define BOOLEAN_FIELDS_DO(macro) \
4835   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4836   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4837 
4838 
4839 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4840   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4841   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4842 }
4843 
4844 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
4845   oop base = ik-&gt;static_field_base_raw();
4846   return base-&gt;obj_field(_static_TRUE_offset);
4847 }
4848 
</pre>
</td>
</tr>
</table>
<center><a href="fieldLayoutBuilder.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/mulnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;memory/allocation.inline.hpp&quot;
  27 #include &quot;opto/addnode.hpp&quot;
  28 #include &quot;opto/connode.hpp&quot;
  29 #include &quot;opto/convertnode.hpp&quot;
  30 #include &quot;opto/memnode.hpp&quot;
  31 #include &quot;opto/mulnode.hpp&quot;
  32 #include &quot;opto/phaseX.hpp&quot;
  33 #include &quot;opto/subnode.hpp&quot;
  34 #include &quot;utilities/powerOfTwo.hpp&quot;
  35 
  36 // Portions of code courtesy of Clifford Click
  37 
  38 
  39 //=============================================================================
  40 //------------------------------hash-------------------------------------------
  41 // Hash function over MulNodes.  Needs to be commutative; i.e., I swap
  42 // (commute) inputs to MulNodes willy-nilly so the hash function must return
  43 // the same value in the presence of edge swapping.
  44 uint MulNode::hash() const {
  45   return (uintptr_t)in(1) + (uintptr_t)in(2) + Opcode();
  46 }
  47 
  48 //------------------------------Identity---------------------------------------
  49 // Multiplying a one preserves the other argument
  50 Node* MulNode::Identity(PhaseGVN* phase) {
  51   const Type *one = mul_id();  // The multiplicative identity
  52   if( phase-&gt;type( in(1) )-&gt;higher_equal( one ) ) return in(2);
  53   if( phase-&gt;type( in(2) )-&gt;higher_equal( one ) ) return in(1);
  54 
  55   return this;
  56 }
  57 
  58 //------------------------------Ideal------------------------------------------
  59 // We also canonicalize the Node, moving constants to the right input,
  60 // and flatten expressions (so that 1+x+2 becomes x+3).
  61 Node *MulNode::Ideal(PhaseGVN *phase, bool can_reshape) {
  62   const Type *t1 = phase-&gt;type( in(1) );
  63   const Type *t2 = phase-&gt;type( in(2) );
  64   Node *progress = NULL;        // Progress flag
  65   // We are OK if right is a constant, or right is a load and
  66   // left is a non-constant.
  67   if( !(t2-&gt;singleton() ||
  68         (in(2)-&gt;is_Load() &amp;&amp; !(t1-&gt;singleton() || in(1)-&gt;is_Load())) ) ) {
  69     if( t1-&gt;singleton() ||       // Left input is a constant?
  70         // Otherwise, sort inputs (commutativity) to help value numbering.
  71         (in(1)-&gt;_idx &gt; in(2)-&gt;_idx) ) {
  72       swap_edges(1, 2);
  73       const Type *t = t1;
  74       t1 = t2;
  75       t2 = t;
  76       progress = this;            // Made progress
  77     }
  78   }
  79 
  80   // If the right input is a constant, and the left input is a product of a
  81   // constant, flatten the expression tree.
  82   uint op = Opcode();
  83   if( t2-&gt;singleton() &amp;&amp;        // Right input is a constant?
  84       op != Op_MulF &amp;&amp;          // Float &amp; double cannot reassociate
  85       op != Op_MulD ) {
  86     if( t2 == Type::TOP ) return NULL;
  87     Node *mul1 = in(1);
  88 #ifdef ASSERT
  89     // Check for dead loop
  90     int   op1 = mul1-&gt;Opcode();
  91     if( phase-&gt;eqv( mul1, this ) || phase-&gt;eqv( in(2), this ) ||
  92         ( ( op1 == mul_opcode() || op1 == add_opcode() ) &amp;&amp;
  93           ( phase-&gt;eqv( mul1-&gt;in(1), this ) || phase-&gt;eqv( mul1-&gt;in(2), this ) ||
  94             phase-&gt;eqv( mul1-&gt;in(1), mul1 ) || phase-&gt;eqv( mul1-&gt;in(2), mul1 ) ) ) )
  95       assert(false, &quot;dead loop in MulNode::Ideal&quot;);
  96 #endif
  97 
  98     if( mul1-&gt;Opcode() == mul_opcode() ) {  // Left input is a multiply?
  99       // Mul of a constant?
 100       const Type *t12 = phase-&gt;type( mul1-&gt;in(2) );
 101       if( t12-&gt;singleton() &amp;&amp; t12 != Type::TOP) { // Left input is an add of a constant?
 102         // Compute new constant; check for overflow
 103         const Type *tcon01 = ((MulNode*)mul1)-&gt;mul_ring(t2,t12);
 104         if( tcon01-&gt;singleton() ) {
 105           // The Mul of the flattened expression
 106           set_req(1, mul1-&gt;in(1));
 107           set_req(2, phase-&gt;makecon( tcon01 ));
 108           t2 = tcon01;
 109           progress = this;      // Made progress
 110         }
 111       }
 112     }
 113     // If the right input is a constant, and the left input is an add of a
 114     // constant, flatten the tree: (X+con1)*con0 ==&gt; X*con0 + con1*con0
 115     const Node *add1 = in(1);
 116     if( add1-&gt;Opcode() == add_opcode() ) {      // Left input is an add?
 117       // Add of a constant?
 118       const Type *t12 = phase-&gt;type( add1-&gt;in(2) );
 119       if( t12-&gt;singleton() &amp;&amp; t12 != Type::TOP ) { // Left input is an add of a constant?
 120         assert( add1-&gt;in(1) != add1, &quot;dead loop in MulNode::Ideal&quot; );
 121         // Compute new constant; check for overflow
 122         const Type *tcon01 = mul_ring(t2,t12);
 123         if( tcon01-&gt;singleton() ) {
 124 
 125         // Convert (X+con1)*con0 into X*con0
 126           Node *mul = clone();    // mul = ()*con0
 127           mul-&gt;set_req(1,add1-&gt;in(1));  // mul = X*con0
 128           mul = phase-&gt;transform(mul);
 129 
 130           Node *add2 = add1-&gt;clone();
 131           add2-&gt;set_req(1, mul);        // X*con0 + con0*con1
 132           add2-&gt;set_req(2, phase-&gt;makecon(tcon01) );
 133           progress = add2;
 134         }
 135       }
 136     } // End of is left input an add
 137   } // End of is right input a Mul
 138 
 139   return progress;
 140 }
 141 
 142 //------------------------------Value-----------------------------------------
 143 const Type* MulNode::Value(PhaseGVN* phase) const {
 144   const Type *t1 = phase-&gt;type( in(1) );
 145   const Type *t2 = phase-&gt;type( in(2) );
 146   // Either input is TOP ==&gt; the result is TOP
 147   if( t1 == Type::TOP ) return Type::TOP;
 148   if( t2 == Type::TOP ) return Type::TOP;
 149 
 150   // Either input is ZERO ==&gt; the result is ZERO.
 151   // Not valid for floats or doubles since +0.0 * -0.0 --&gt; +0.0
 152   int op = Opcode();
 153   if( op == Op_MulI || op == Op_AndI || op == Op_MulL || op == Op_AndL ) {
 154     const Type *zero = add_id();        // The multiplicative zero
 155     if( t1-&gt;higher_equal( zero ) ) return zero;
 156     if( t2-&gt;higher_equal( zero ) ) return zero;
 157   }
 158 
<a name="1" id="anc1"></a><span class="line-added"> 159   // Code pattern on return from a call that returns an __Value.  Can</span>
<span class="line-added"> 160   // be optimized away if the return value turns out to be an oop.</span>
<span class="line-added"> 161   if (op == Op_AndX &amp;&amp;</span>
<span class="line-added"> 162       in(1) != NULL &amp;&amp;</span>
<span class="line-added"> 163       in(1)-&gt;Opcode() == Op_CastP2X &amp;&amp;</span>
<span class="line-added"> 164       in(1)-&gt;in(1) != NULL &amp;&amp;</span>
<span class="line-added"> 165       phase-&gt;type(in(1)-&gt;in(1))-&gt;isa_oopptr() &amp;&amp;</span>
<span class="line-added"> 166       t2-&gt;isa_intptr_t()-&gt;_lo &gt;= 0 &amp;&amp;</span>
<span class="line-added"> 167       t2-&gt;isa_intptr_t()-&gt;_hi &lt;= MinObjAlignmentInBytesMask) {</span>
<span class="line-added"> 168     return add_id();</span>
<span class="line-added"> 169   }</span>
<span class="line-added"> 170 </span>
 171   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
 172   if( t1 == Type::BOTTOM || t2 == Type::BOTTOM )
 173     return bottom_type();
 174 
 175 #if defined(IA32)
 176   // Can&#39;t trust native compilers to properly fold strict double
 177   // multiplication with round-to-zero on this platform.
 178   if (op == Op_MulD &amp;&amp; phase-&gt;C-&gt;method()-&gt;is_strict()) {
 179     return TypeD::DOUBLE;
 180   }
 181 #endif
 182 
 183   return mul_ring(t1,t2);            // Local flavor of type multiplication
 184 }
 185 
 186 //=============================================================================
 187 //------------------------------Ideal------------------------------------------
 188 // Check for power-of-2 multiply, then try the regular MulNode::Ideal
 189 Node *MulINode::Ideal(PhaseGVN *phase, bool can_reshape) {
 190   // Swap constant to right
 191   jint con;
 192   if ((con = in(1)-&gt;find_int_con(0)) != 0) {
 193     swap_edges(1, 2);
 194     // Finish rest of method to use info in &#39;con&#39;
 195   } else if ((con = in(2)-&gt;find_int_con(0)) == 0) {
 196     return MulNode::Ideal(phase, can_reshape);
 197   }
 198 
 199   // Now we have a constant Node on the right and the constant in con
 200   if (con == 0) return NULL;   // By zero is handled by Value call
 201   if (con == 1) return NULL;   // By one  is handled by Identity call
 202 
 203   // Check for negative constant; if so negate the final result
 204   bool sign_flip = false;
 205 
 206   unsigned int abs_con = uabs(con);
 207   if (abs_con != (unsigned int)con) {
 208     sign_flip = true;
 209   }
 210 
 211   // Get low bit; check for being the only bit
 212   Node *res = NULL;
 213   unsigned int bit1 = abs_con &amp; (0-abs_con);       // Extract low bit
 214   if (bit1 == abs_con) {           // Found a power of 2?
 215     res = new LShiftINode(in(1), phase-&gt;intcon(log2_uint(bit1)));
 216   } else {
 217 
 218     // Check for constant with 2 bits set
 219     unsigned int bit2 = abs_con-bit1;
 220     bit2 = bit2 &amp; (0-bit2);          // Extract 2nd bit
 221     if (bit2 + bit1 == abs_con) {    // Found all bits in con?
 222       Node *n1 = phase-&gt;transform( new LShiftINode(in(1), phase-&gt;intcon(log2_uint(bit1))));
 223       Node *n2 = phase-&gt;transform( new LShiftINode(in(1), phase-&gt;intcon(log2_uint(bit2))));
 224       res = new AddINode(n2, n1);
 225 
 226     } else if (is_power_of_2(abs_con+1)) {
 227       // Sleezy: power-of-2 -1.  Next time be generic.
 228       unsigned int temp = abs_con + 1;
 229       Node *n1 = phase-&gt;transform(new LShiftINode(in(1), phase-&gt;intcon(log2_uint(temp))));
 230       res = new SubINode(n1, in(1));
 231     } else {
 232       return MulNode::Ideal(phase, can_reshape);
 233     }
 234   }
 235 
 236   if (sign_flip) {             // Need to negate result?
 237     res = phase-&gt;transform(res);// Transform, before making the zero con
 238     res = new SubINode(phase-&gt;intcon(0),res);
 239   }
 240 
 241   return res;                   // Return final result
 242 }
 243 
 244 //------------------------------mul_ring---------------------------------------
 245 // Compute the product type of two integer ranges into this node.
 246 const Type *MulINode::mul_ring(const Type *t0, const Type *t1) const {
 247   const TypeInt *r0 = t0-&gt;is_int(); // Handy access
 248   const TypeInt *r1 = t1-&gt;is_int();
 249 
 250   // Fetch endpoints of all ranges
 251   jint lo0 = r0-&gt;_lo;
 252   double a = (double)lo0;
 253   jint hi0 = r0-&gt;_hi;
 254   double b = (double)hi0;
 255   jint lo1 = r1-&gt;_lo;
 256   double c = (double)lo1;
 257   jint hi1 = r1-&gt;_hi;
 258   double d = (double)hi1;
 259 
 260   // Compute all endpoints &amp; check for overflow
 261   int32_t A = java_multiply(lo0, lo1);
 262   if( (double)A != a*c ) return TypeInt::INT; // Overflow?
 263   int32_t B = java_multiply(lo0, hi1);
 264   if( (double)B != a*d ) return TypeInt::INT; // Overflow?
 265   int32_t C = java_multiply(hi0, lo1);
 266   if( (double)C != b*c ) return TypeInt::INT; // Overflow?
 267   int32_t D = java_multiply(hi0, hi1);
 268   if( (double)D != b*d ) return TypeInt::INT; // Overflow?
 269 
 270   if( A &lt; B ) { lo0 = A; hi0 = B; } // Sort range endpoints
 271   else { lo0 = B; hi0 = A; }
 272   if( C &lt; D ) {
 273     if( C &lt; lo0 ) lo0 = C;
 274     if( D &gt; hi0 ) hi0 = D;
 275   } else {
 276     if( D &lt; lo0 ) lo0 = D;
 277     if( C &gt; hi0 ) hi0 = C;
 278   }
 279   return TypeInt::make(lo0, hi0, MAX2(r0-&gt;_widen,r1-&gt;_widen));
 280 }
 281 
 282 
 283 //=============================================================================
 284 //------------------------------Ideal------------------------------------------
 285 // Check for power-of-2 multiply, then try the regular MulNode::Ideal
 286 Node *MulLNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 287   // Swap constant to right
 288   jlong con;
 289   if ((con = in(1)-&gt;find_long_con(0)) != 0) {
 290     swap_edges(1, 2);
 291     // Finish rest of method to use info in &#39;con&#39;
 292   } else if ((con = in(2)-&gt;find_long_con(0)) == 0) {
 293     return MulNode::Ideal(phase, can_reshape);
 294   }
 295 
 296   // Now we have a constant Node on the right and the constant in con
 297   if (con == CONST64(0)) return NULL;  // By zero is handled by Value call
 298   if (con == CONST64(1)) return NULL;  // By one  is handled by Identity call
 299 
 300   // Check for negative constant; if so negate the final result
 301   bool sign_flip = false;
 302   julong abs_con = uabs(con);
 303   if (abs_con != (julong)con) {
 304     sign_flip = true;
 305   }
 306 
 307   // Get low bit; check for being the only bit
 308   Node *res = NULL;
 309   julong bit1 = abs_con &amp; (0-abs_con);      // Extract low bit
 310   if (bit1 == abs_con) {           // Found a power of 2?
 311     res = new LShiftLNode(in(1), phase-&gt;intcon(log2_long(bit1)));
 312   } else {
 313 
 314     // Check for constant with 2 bits set
 315     julong bit2 = abs_con-bit1;
 316     bit2 = bit2 &amp; (0-bit2);          // Extract 2nd bit
 317     if (bit2 + bit1 == abs_con) {    // Found all bits in con?
 318       Node *n1 = phase-&gt;transform(new LShiftLNode(in(1), phase-&gt;intcon(log2_long(bit1))));
 319       Node *n2 = phase-&gt;transform(new LShiftLNode(in(1), phase-&gt;intcon(log2_long(bit2))));
 320       res = new AddLNode(n2, n1);
 321 
 322     } else if (is_power_of_2(abs_con+1)) {
 323       // Sleezy: power-of-2 -1.  Next time be generic.
 324       julong temp = abs_con + 1;
 325       Node *n1 = phase-&gt;transform( new LShiftLNode(in(1), phase-&gt;intcon(log2_long(temp))));
 326       res = new SubLNode(n1, in(1));
 327     } else {
 328       return MulNode::Ideal(phase, can_reshape);
 329     }
 330   }
 331 
 332   if (sign_flip) {             // Need to negate result?
 333     res = phase-&gt;transform(res);// Transform, before making the zero con
 334     res = new SubLNode(phase-&gt;longcon(0),res);
 335   }
 336 
 337   return res;                   // Return final result
 338 }
 339 
 340 //------------------------------mul_ring---------------------------------------
 341 // Compute the product type of two integer ranges into this node.
 342 const Type *MulLNode::mul_ring(const Type *t0, const Type *t1) const {
 343   const TypeLong *r0 = t0-&gt;is_long(); // Handy access
 344   const TypeLong *r1 = t1-&gt;is_long();
 345 
 346   // Fetch endpoints of all ranges
 347   jlong lo0 = r0-&gt;_lo;
 348   double a = (double)lo0;
 349   jlong hi0 = r0-&gt;_hi;
 350   double b = (double)hi0;
 351   jlong lo1 = r1-&gt;_lo;
 352   double c = (double)lo1;
 353   jlong hi1 = r1-&gt;_hi;
 354   double d = (double)hi1;
 355 
 356   // Compute all endpoints &amp; check for overflow
 357   jlong A = java_multiply(lo0, lo1);
 358   if( (double)A != a*c ) return TypeLong::LONG; // Overflow?
 359   jlong B = java_multiply(lo0, hi1);
 360   if( (double)B != a*d ) return TypeLong::LONG; // Overflow?
 361   jlong C = java_multiply(hi0, lo1);
 362   if( (double)C != b*c ) return TypeLong::LONG; // Overflow?
 363   jlong D = java_multiply(hi0, hi1);
 364   if( (double)D != b*d ) return TypeLong::LONG; // Overflow?
 365 
 366   if( A &lt; B ) { lo0 = A; hi0 = B; } // Sort range endpoints
 367   else { lo0 = B; hi0 = A; }
 368   if( C &lt; D ) {
 369     if( C &lt; lo0 ) lo0 = C;
 370     if( D &gt; hi0 ) hi0 = D;
 371   } else {
 372     if( D &lt; lo0 ) lo0 = D;
 373     if( C &gt; hi0 ) hi0 = C;
 374   }
 375   return TypeLong::make(lo0, hi0, MAX2(r0-&gt;_widen,r1-&gt;_widen));
 376 }
 377 
 378 //=============================================================================
 379 //------------------------------mul_ring---------------------------------------
 380 // Compute the product type of two double ranges into this node.
 381 const Type *MulFNode::mul_ring(const Type *t0, const Type *t1) const {
 382   if( t0 == Type::FLOAT || t1 == Type::FLOAT ) return Type::FLOAT;
 383   return TypeF::make( t0-&gt;getf() * t1-&gt;getf() );
 384 }
 385 
 386 //=============================================================================
 387 //------------------------------mul_ring---------------------------------------
 388 // Compute the product type of two double ranges into this node.
 389 const Type *MulDNode::mul_ring(const Type *t0, const Type *t1) const {
 390   if( t0 == Type::DOUBLE || t1 == Type::DOUBLE ) return Type::DOUBLE;
 391   // We must be multiplying 2 double constants.
 392   return TypeD::make( t0-&gt;getd() * t1-&gt;getd() );
 393 }
 394 
 395 //=============================================================================
 396 //------------------------------Value------------------------------------------
 397 const Type* MulHiLNode::Value(PhaseGVN* phase) const {
 398   // Either input is TOP ==&gt; the result is TOP
 399   const Type *t1 = phase-&gt;type( in(1) );
 400   const Type *t2 = phase-&gt;type( in(2) );
 401   if( t1 == Type::TOP ) return Type::TOP;
 402   if( t2 == Type::TOP ) return Type::TOP;
 403 
 404   // Either input is BOTTOM ==&gt; the result is the local BOTTOM
 405   const Type *bot = bottom_type();
 406   if( (t1 == bot) || (t2 == bot) ||
 407       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 408     return bot;
 409 
 410   // It is not worth trying to constant fold this stuff!
 411   return TypeLong::LONG;
 412 }
 413 
 414 //=============================================================================
 415 //------------------------------mul_ring---------------------------------------
 416 // Supplied function returns the product of the inputs IN THE CURRENT RING.
 417 // For the logical operations the ring&#39;s MUL is really a logical AND function.
 418 // This also type-checks the inputs for sanity.  Guaranteed never to
 419 // be passed a TOP or BOTTOM type, these are filtered out by pre-check.
 420 const Type *AndINode::mul_ring( const Type *t0, const Type *t1 ) const {
 421   const TypeInt *r0 = t0-&gt;is_int(); // Handy access
 422   const TypeInt *r1 = t1-&gt;is_int();
 423   int widen = MAX2(r0-&gt;_widen,r1-&gt;_widen);
 424 
 425   // If either input is a constant, might be able to trim cases
 426   if( !r0-&gt;is_con() &amp;&amp; !r1-&gt;is_con() )
 427     return TypeInt::INT;        // No constants to be had
 428 
 429   // Both constants?  Return bits
 430   if( r0-&gt;is_con() &amp;&amp; r1-&gt;is_con() )
 431     return TypeInt::make( r0-&gt;get_con() &amp; r1-&gt;get_con() );
 432 
 433   if( r0-&gt;is_con() &amp;&amp; r0-&gt;get_con() &gt; 0 )
 434     return TypeInt::make(0, r0-&gt;get_con(), widen);
 435 
 436   if( r1-&gt;is_con() &amp;&amp; r1-&gt;get_con() &gt; 0 )
 437     return TypeInt::make(0, r1-&gt;get_con(), widen);
 438 
 439   if( r0 == TypeInt::BOOL || r1 == TypeInt::BOOL ) {
 440     return TypeInt::BOOL;
 441   }
 442 
 443   return TypeInt::INT;          // No constants to be had
 444 }
 445 
 446 //------------------------------Identity---------------------------------------
 447 // Masking off the high bits of an unsigned load is not required
 448 Node* AndINode::Identity(PhaseGVN* phase) {
 449 
 450   // x &amp; x =&gt; x
 451   if (phase-&gt;eqv(in(1), in(2))) return in(1);
 452 
 453   Node* in1 = in(1);
 454   uint op = in1-&gt;Opcode();
 455   const TypeInt* t2 = phase-&gt;type(in(2))-&gt;isa_int();
 456   if (t2 &amp;&amp; t2-&gt;is_con()) {
 457     int con = t2-&gt;get_con();
 458     // Masking off high bits which are always zero is useless.
 459     const TypeInt* t1 = phase-&gt;type( in(1) )-&gt;isa_int();
 460     if (t1 != NULL &amp;&amp; t1-&gt;_lo &gt;= 0) {
 461       jint t1_support = right_n_bits(1 + log2_jint(t1-&gt;_hi));
 462       if ((t1_support &amp; con) == t1_support)
 463         return in1;
 464     }
 465     // Masking off the high bits of a unsigned-shift-right is not
 466     // needed either.
 467     if (op == Op_URShiftI) {
 468       const TypeInt* t12 = phase-&gt;type(in1-&gt;in(2))-&gt;isa_int();
 469       if (t12 &amp;&amp; t12-&gt;is_con()) {  // Shift is by a constant
 470         int shift = t12-&gt;get_con();
 471         shift &amp;= BitsPerJavaInteger - 1;  // semantics of Java shifts
 472         int mask = max_juint &gt;&gt; shift;
 473         if ((mask &amp; con) == mask)  // If AND is useless, skip it
 474           return in1;
 475       }
 476     }
 477   }
 478   return MulNode::Identity(phase);
 479 }
 480 
 481 //------------------------------Ideal------------------------------------------
 482 Node *AndINode::Ideal(PhaseGVN *phase, bool can_reshape) {
 483   // Special case constant AND mask
 484   const TypeInt *t2 = phase-&gt;type( in(2) )-&gt;isa_int();
 485   if( !t2 || !t2-&gt;is_con() ) return MulNode::Ideal(phase, can_reshape);
 486   const int mask = t2-&gt;get_con();
 487   Node *load = in(1);
 488   uint lop = load-&gt;Opcode();
 489 
 490   // Masking bits off of a Character?  Hi bits are already zero.
 491   if( lop == Op_LoadUS &amp;&amp;
 492       (mask &amp; 0xFFFF0000) )     // Can we make a smaller mask?
 493     return new AndINode(load,phase-&gt;intcon(mask&amp;0xFFFF));
 494 
 495   // Masking bits off of a Short?  Loading a Character does some masking
 496   if (can_reshape &amp;&amp;
 497       load-&gt;outcnt() == 1 &amp;&amp; load-&gt;unique_out() == this) {
 498     if (lop == Op_LoadS &amp;&amp; (mask &amp; 0xFFFF0000) == 0 ) {
 499       Node* ldus = load-&gt;as_Load()-&gt;convert_to_unsigned_load(*phase);
 500       ldus = phase-&gt;transform(ldus);
 501       return new AndINode(ldus, phase-&gt;intcon(mask &amp; 0xFFFF));
 502     }
 503 
 504     // Masking sign bits off of a Byte?  Do an unsigned byte load plus
 505     // an and.
 506     if (lop == Op_LoadB &amp;&amp; (mask &amp; 0xFFFFFF00) == 0) {
 507       Node* ldub = load-&gt;as_Load()-&gt;convert_to_unsigned_load(*phase);
 508       ldub = phase-&gt;transform(ldub);
 509       return new AndINode(ldub, phase-&gt;intcon(mask));
 510     }
 511   }
 512 
 513   // Masking off sign bits?  Dont make them!
 514   if( lop == Op_RShiftI ) {
 515     const TypeInt *t12 = phase-&gt;type(load-&gt;in(2))-&gt;isa_int();
 516     if( t12 &amp;&amp; t12-&gt;is_con() ) { // Shift is by a constant
 517       int shift = t12-&gt;get_con();
 518       shift &amp;= BitsPerJavaInteger-1;  // semantics of Java shifts
 519       const int sign_bits_mask = ~right_n_bits(BitsPerJavaInteger - shift);
 520       // If the AND&#39;ing of the 2 masks has no bits, then only original shifted
 521       // bits survive.  NO sign-extension bits survive the maskings.
 522       if( (sign_bits_mask &amp; mask) == 0 ) {
 523         // Use zero-fill shift instead
 524         Node *zshift = phase-&gt;transform(new URShiftINode(load-&gt;in(1),load-&gt;in(2)));
 525         return new AndINode( zshift, in(2) );
 526       }
 527     }
 528   }
 529 
 530   // Check for &#39;negate/and-1&#39;, a pattern emitted when someone asks for
 531   // &#39;mod 2&#39;.  Negate leaves the low order bit unchanged (think: complement
 532   // plus 1) and the mask is of the low order bit.  Skip the negate.
 533   if( lop == Op_SubI &amp;&amp; mask == 1 &amp;&amp; load-&gt;in(1) &amp;&amp;
 534       phase-&gt;type(load-&gt;in(1)) == TypeInt::ZERO )
 535     return new AndINode( load-&gt;in(2), in(2) );
 536 
 537   return MulNode::Ideal(phase, can_reshape);
 538 }
 539 
 540 //=============================================================================
 541 //------------------------------mul_ring---------------------------------------
 542 // Supplied function returns the product of the inputs IN THE CURRENT RING.
 543 // For the logical operations the ring&#39;s MUL is really a logical AND function.
 544 // This also type-checks the inputs for sanity.  Guaranteed never to
 545 // be passed a TOP or BOTTOM type, these are filtered out by pre-check.
 546 const Type *AndLNode::mul_ring( const Type *t0, const Type *t1 ) const {
 547   const TypeLong *r0 = t0-&gt;is_long(); // Handy access
 548   const TypeLong *r1 = t1-&gt;is_long();
 549   int widen = MAX2(r0-&gt;_widen,r1-&gt;_widen);
 550 
 551   // If either input is a constant, might be able to trim cases
 552   if( !r0-&gt;is_con() &amp;&amp; !r1-&gt;is_con() )
 553     return TypeLong::LONG;      // No constants to be had
 554 
 555   // Both constants?  Return bits
 556   if( r0-&gt;is_con() &amp;&amp; r1-&gt;is_con() )
 557     return TypeLong::make( r0-&gt;get_con() &amp; r1-&gt;get_con() );
 558 
 559   if( r0-&gt;is_con() &amp;&amp; r0-&gt;get_con() &gt; 0 )
 560     return TypeLong::make(CONST64(0), r0-&gt;get_con(), widen);
 561 
 562   if( r1-&gt;is_con() &amp;&amp; r1-&gt;get_con() &gt; 0 )
 563     return TypeLong::make(CONST64(0), r1-&gt;get_con(), widen);
 564 
 565   return TypeLong::LONG;        // No constants to be had
 566 }
 567 
 568 //------------------------------Identity---------------------------------------
 569 // Masking off the high bits of an unsigned load is not required
 570 Node* AndLNode::Identity(PhaseGVN* phase) {
 571 
 572   // x &amp; x =&gt; x
 573   if (phase-&gt;eqv(in(1), in(2))) return in(1);
 574 
 575   Node *usr = in(1);
 576   const TypeLong *t2 = phase-&gt;type( in(2) )-&gt;isa_long();
 577   if( t2 &amp;&amp; t2-&gt;is_con() ) {
 578     jlong con = t2-&gt;get_con();
 579     // Masking off high bits which are always zero is useless.
 580     const TypeLong* t1 = phase-&gt;type( in(1) )-&gt;isa_long();
 581     if (t1 != NULL &amp;&amp; t1-&gt;_lo &gt;= 0) {
 582       int bit_count = log2_long(t1-&gt;_hi) + 1;
 583       jlong t1_support = jlong(max_julong &gt;&gt; (BitsPerJavaLong - bit_count));
 584       if ((t1_support &amp; con) == t1_support)
 585         return usr;
 586     }
 587     uint lop = usr-&gt;Opcode();
 588     // Masking off the high bits of a unsigned-shift-right is not
 589     // needed either.
 590     if( lop == Op_URShiftL ) {
 591       const TypeInt *t12 = phase-&gt;type( usr-&gt;in(2) )-&gt;isa_int();
 592       if( t12 &amp;&amp; t12-&gt;is_con() ) {  // Shift is by a constant
 593         int shift = t12-&gt;get_con();
 594         shift &amp;= BitsPerJavaLong - 1;  // semantics of Java shifts
 595         jlong mask = max_julong &gt;&gt; shift;
 596         if( (mask&amp;con) == mask )  // If AND is useless, skip it
 597           return usr;
 598       }
 599     }
<a name="2" id="anc2"></a><span class="line-added"> 600 </span>
<span class="line-added"> 601     if (con == markWord::always_locked_pattern) {</span>
<span class="line-added"> 602       assert(EnableValhalla, &quot;should only be used for value types&quot;);</span>
<span class="line-added"> 603       if (in(1)-&gt;is_Load() &amp;&amp; phase-&gt;type(in(1)-&gt;in(MemNode::Address))-&gt;is_valuetypeptr()) {</span>
<span class="line-added"> 604         return in(2); // Obj is known to be a value type</span>
<span class="line-added"> 605       }</span>
<span class="line-added"> 606     }</span>
 607   }
 608   return MulNode::Identity(phase);
 609 }
 610 
 611 //------------------------------Ideal------------------------------------------
 612 Node *AndLNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 613   // Special case constant AND mask
 614   const TypeLong *t2 = phase-&gt;type( in(2) )-&gt;isa_long();
 615   if( !t2 || !t2-&gt;is_con() ) return MulNode::Ideal(phase, can_reshape);
 616   const jlong mask = t2-&gt;get_con();
 617 
 618   Node* in1 = in(1);
 619   uint op = in1-&gt;Opcode();
 620 
 621   // Are we masking a long that was converted from an int with a mask
 622   // that fits in 32-bits?  Commute them and use an AndINode.  Don&#39;t
 623   // convert masks which would cause a sign extension of the integer
 624   // value.  This check includes UI2L masks (0x00000000FFFFFFFF) which
 625   // would be optimized away later in Identity.
 626   if (op == Op_ConvI2L &amp;&amp; (mask &amp; UCONST64(0xFFFFFFFF80000000)) == 0) {
 627     Node* andi = new AndINode(in1-&gt;in(1), phase-&gt;intcon(mask));
 628     andi = phase-&gt;transform(andi);
 629     return new ConvI2LNode(andi);
 630   }
 631 
 632   // Masking off sign bits?  Dont make them!
 633   if (op == Op_RShiftL) {
 634     const TypeInt* t12 = phase-&gt;type(in1-&gt;in(2))-&gt;isa_int();
 635     if( t12 &amp;&amp; t12-&gt;is_con() ) { // Shift is by a constant
 636       int shift = t12-&gt;get_con();
 637       shift &amp;= BitsPerJavaLong - 1;  // semantics of Java shifts
 638       const jlong sign_bits_mask = ~(((jlong)CONST64(1) &lt;&lt; (jlong)(BitsPerJavaLong - shift)) -1);
 639       // If the AND&#39;ing of the 2 masks has no bits, then only original shifted
 640       // bits survive.  NO sign-extension bits survive the maskings.
 641       if( (sign_bits_mask &amp; mask) == 0 ) {
 642         // Use zero-fill shift instead
 643         Node *zshift = phase-&gt;transform(new URShiftLNode(in1-&gt;in(1), in1-&gt;in(2)));
 644         return new AndLNode(zshift, in(2));
 645       }
 646     }
 647   }
 648 
 649   return MulNode::Ideal(phase, can_reshape);
 650 }
 651 
 652 //=============================================================================
 653 
 654 static int getShiftCon(PhaseGVN *phase, Node *shiftNode, int retVal) {
 655   const Type *t = phase-&gt;type(shiftNode-&gt;in(2));
 656   if (t == Type::TOP) return retVal;       // Right input is dead.
 657   const TypeInt *t2 = t-&gt;isa_int();
 658   if (!t2 || !t2-&gt;is_con()) return retVal; // Right input is a constant.
 659 
 660   return t2-&gt;get_con();
 661 }
 662 
 663 static int maskShiftAmount(PhaseGVN *phase, Node *shiftNode, int nBits) {
 664   int       shift = getShiftCon(phase, shiftNode, 0);
 665   int maskedShift = shift &amp; (nBits - 1);
 666 
 667   if (maskedShift == 0) return 0;         // Let Identity() handle 0 shift count.
 668 
 669   if (shift != maskedShift) {
 670     shiftNode-&gt;set_req(2, phase-&gt;intcon(maskedShift)); // Replace shift count with masked value.
 671     phase-&gt;igvn_rehash_node_delayed(shiftNode);
 672   }
 673 
 674   return maskedShift;
 675 }
 676 
 677 //------------------------------Identity---------------------------------------
 678 Node* LShiftINode::Identity(PhaseGVN* phase) {
 679   return ((getShiftCon(phase, this, -1) &amp; (BitsPerJavaInteger - 1)) == 0) ? in(1) : this;
 680 }
 681 
 682 //------------------------------Ideal------------------------------------------
 683 // If the right input is a constant, and the left input is an add of a
 684 // constant, flatten the tree: (X+con1)&lt;&lt;con0 ==&gt; X&lt;&lt;con0 + con1&lt;&lt;con0
 685 Node *LShiftINode::Ideal(PhaseGVN *phase, bool can_reshape) {
 686   int con = maskShiftAmount(phase, this, BitsPerJavaInteger);
 687   if (con == 0) {
 688     return NULL;
 689   }
 690 
 691   // Left input is an add of a constant?
 692   Node *add1 = in(1);
 693   int add1_op = add1-&gt;Opcode();
 694   if( add1_op == Op_AddI ) {    // Left input is an add?
 695     assert( add1 != add1-&gt;in(1), &quot;dead loop in LShiftINode::Ideal&quot; );
 696     const TypeInt *t12 = phase-&gt;type(add1-&gt;in(2))-&gt;isa_int();
 697     if( t12 &amp;&amp; t12-&gt;is_con() ){ // Left input is an add of a con?
 698       // Transform is legal, but check for profit.  Avoid breaking &#39;i2s&#39;
 699       // and &#39;i2b&#39; patterns which typically fold into &#39;StoreC/StoreB&#39;.
 700       if( con &lt; 16 ) {
 701         // Compute X &lt;&lt; con0
 702         Node *lsh = phase-&gt;transform( new LShiftINode( add1-&gt;in(1), in(2) ) );
 703         // Compute X&lt;&lt;con0 + (con1&lt;&lt;con0)
 704         return new AddINode( lsh, phase-&gt;intcon(t12-&gt;get_con() &lt;&lt; con));
 705       }
 706     }
 707   }
 708 
 709   // Check for &quot;(x&gt;&gt;c0)&lt;&lt;c0&quot; which just masks off low bits
 710   if( (add1_op == Op_RShiftI || add1_op == Op_URShiftI ) &amp;&amp;
 711       add1-&gt;in(2) == in(2) )
 712     // Convert to &quot;(x &amp; -(1&lt;&lt;c0))&quot;
 713     return new AndINode(add1-&gt;in(1),phase-&gt;intcon( -(1&lt;&lt;con)));
 714 
 715   // Check for &quot;((x&gt;&gt;c0) &amp; Y)&lt;&lt;c0&quot; which just masks off more low bits
 716   if( add1_op == Op_AndI ) {
 717     Node *add2 = add1-&gt;in(1);
 718     int add2_op = add2-&gt;Opcode();
 719     if( (add2_op == Op_RShiftI || add2_op == Op_URShiftI ) &amp;&amp;
 720         add2-&gt;in(2) == in(2) ) {
 721       // Convert to &quot;(x &amp; (Y&lt;&lt;c0))&quot;
 722       Node *y_sh = phase-&gt;transform( new LShiftINode( add1-&gt;in(2), in(2) ) );
 723       return new AndINode( add2-&gt;in(1), y_sh );
 724     }
 725   }
 726 
 727   // Check for ((x &amp; ((1&lt;&lt;(32-c0))-1)) &lt;&lt; c0) which ANDs off high bits
 728   // before shifting them away.
 729   const jint bits_mask = right_n_bits(BitsPerJavaInteger-con);
 730   if( add1_op == Op_AndI &amp;&amp;
 731       phase-&gt;type(add1-&gt;in(2)) == TypeInt::make( bits_mask ) )
 732     return new LShiftINode( add1-&gt;in(1), in(2) );
 733 
 734   return NULL;
 735 }
 736 
 737 //------------------------------Value------------------------------------------
 738 // A LShiftINode shifts its input2 left by input1 amount.
 739 const Type* LShiftINode::Value(PhaseGVN* phase) const {
 740   const Type *t1 = phase-&gt;type( in(1) );
 741   const Type *t2 = phase-&gt;type( in(2) );
 742   // Either input is TOP ==&gt; the result is TOP
 743   if( t1 == Type::TOP ) return Type::TOP;
 744   if( t2 == Type::TOP ) return Type::TOP;
 745 
 746   // Left input is ZERO ==&gt; the result is ZERO.
 747   if( t1 == TypeInt::ZERO ) return TypeInt::ZERO;
 748   // Shift by zero does nothing
 749   if( t2 == TypeInt::ZERO ) return t1;
 750 
 751   // Either input is BOTTOM ==&gt; the result is BOTTOM
 752   if( (t1 == TypeInt::INT) || (t2 == TypeInt::INT) ||
 753       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 754     return TypeInt::INT;
 755 
 756   const TypeInt *r1 = t1-&gt;is_int(); // Handy access
 757   const TypeInt *r2 = t2-&gt;is_int(); // Handy access
 758 
 759   if (!r2-&gt;is_con())
 760     return TypeInt::INT;
 761 
 762   uint shift = r2-&gt;get_con();
 763   shift &amp;= BitsPerJavaInteger-1;  // semantics of Java shifts
 764   // Shift by a multiple of 32 does nothing:
 765   if (shift == 0)  return t1;
 766 
 767   // If the shift is a constant, shift the bounds of the type,
 768   // unless this could lead to an overflow.
 769   if (!r1-&gt;is_con()) {
 770     jint lo = r1-&gt;_lo, hi = r1-&gt;_hi;
 771     if (((lo &lt;&lt; shift) &gt;&gt; shift) == lo &amp;&amp;
 772         ((hi &lt;&lt; shift) &gt;&gt; shift) == hi) {
 773       // No overflow.  The range shifts up cleanly.
 774       return TypeInt::make((jint)lo &lt;&lt; (jint)shift,
 775                            (jint)hi &lt;&lt; (jint)shift,
 776                            MAX2(r1-&gt;_widen,r2-&gt;_widen));
 777     }
 778     return TypeInt::INT;
 779   }
 780 
 781   return TypeInt::make( (jint)r1-&gt;get_con() &lt;&lt; (jint)shift );
 782 }
 783 
 784 //=============================================================================
 785 //------------------------------Identity---------------------------------------
 786 Node* LShiftLNode::Identity(PhaseGVN* phase) {
 787   return ((getShiftCon(phase, this, -1) &amp; (BitsPerJavaLong - 1)) == 0) ? in(1) : this;
 788 }
 789 
 790 //------------------------------Ideal------------------------------------------
 791 // If the right input is a constant, and the left input is an add of a
 792 // constant, flatten the tree: (X+con1)&lt;&lt;con0 ==&gt; X&lt;&lt;con0 + con1&lt;&lt;con0
 793 Node *LShiftLNode::Ideal(PhaseGVN *phase, bool can_reshape) {
 794   int con = maskShiftAmount(phase, this, BitsPerJavaLong);
 795   if (con == 0) {
 796     return NULL;
 797   }
 798 
 799   // Left input is an add of a constant?
 800   Node *add1 = in(1);
 801   int add1_op = add1-&gt;Opcode();
 802   if( add1_op == Op_AddL ) {    // Left input is an add?
 803     // Avoid dead data cycles from dead loops
 804     assert( add1 != add1-&gt;in(1), &quot;dead loop in LShiftLNode::Ideal&quot; );
 805     const TypeLong *t12 = phase-&gt;type(add1-&gt;in(2))-&gt;isa_long();
 806     if( t12 &amp;&amp; t12-&gt;is_con() ){ // Left input is an add of a con?
 807       // Compute X &lt;&lt; con0
 808       Node *lsh = phase-&gt;transform( new LShiftLNode( add1-&gt;in(1), in(2) ) );
 809       // Compute X&lt;&lt;con0 + (con1&lt;&lt;con0)
 810       return new AddLNode( lsh, phase-&gt;longcon(t12-&gt;get_con() &lt;&lt; con));
 811     }
 812   }
 813 
 814   // Check for &quot;(x&gt;&gt;c0)&lt;&lt;c0&quot; which just masks off low bits
 815   if( (add1_op == Op_RShiftL || add1_op == Op_URShiftL ) &amp;&amp;
 816       add1-&gt;in(2) == in(2) )
 817     // Convert to &quot;(x &amp; -(1&lt;&lt;c0))&quot;
 818     return new AndLNode(add1-&gt;in(1),phase-&gt;longcon( -(CONST64(1)&lt;&lt;con)));
 819 
 820   // Check for &quot;((x&gt;&gt;c0) &amp; Y)&lt;&lt;c0&quot; which just masks off more low bits
 821   if( add1_op == Op_AndL ) {
 822     Node *add2 = add1-&gt;in(1);
 823     int add2_op = add2-&gt;Opcode();
 824     if( (add2_op == Op_RShiftL || add2_op == Op_URShiftL ) &amp;&amp;
 825         add2-&gt;in(2) == in(2) ) {
 826       // Convert to &quot;(x &amp; (Y&lt;&lt;c0))&quot;
 827       Node *y_sh = phase-&gt;transform( new LShiftLNode( add1-&gt;in(2), in(2) ) );
 828       return new AndLNode( add2-&gt;in(1), y_sh );
 829     }
 830   }
 831 
 832   // Check for ((x &amp; ((CONST64(1)&lt;&lt;(64-c0))-1)) &lt;&lt; c0) which ANDs off high bits
 833   // before shifting them away.
 834   const jlong bits_mask = jlong(max_julong &gt;&gt; con);
 835   if( add1_op == Op_AndL &amp;&amp;
 836       phase-&gt;type(add1-&gt;in(2)) == TypeLong::make( bits_mask ) )
 837     return new LShiftLNode( add1-&gt;in(1), in(2) );
 838 
 839   return NULL;
 840 }
 841 
 842 //------------------------------Value------------------------------------------
 843 // A LShiftLNode shifts its input2 left by input1 amount.
 844 const Type* LShiftLNode::Value(PhaseGVN* phase) const {
 845   const Type *t1 = phase-&gt;type( in(1) );
 846   const Type *t2 = phase-&gt;type( in(2) );
 847   // Either input is TOP ==&gt; the result is TOP
 848   if( t1 == Type::TOP ) return Type::TOP;
 849   if( t2 == Type::TOP ) return Type::TOP;
 850 
 851   // Left input is ZERO ==&gt; the result is ZERO.
 852   if( t1 == TypeLong::ZERO ) return TypeLong::ZERO;
 853   // Shift by zero does nothing
 854   if( t2 == TypeInt::ZERO ) return t1;
 855 
 856   // Either input is BOTTOM ==&gt; the result is BOTTOM
 857   if( (t1 == TypeLong::LONG) || (t2 == TypeInt::INT) ||
 858       (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )
 859     return TypeLong::LONG;
 860 
 861   const TypeLong *r1 = t1-&gt;is_long(); // Handy access
 862   const TypeInt  *r2 = t2-&gt;is_int();  // Handy access
 863 
 864   if (!r2-&gt;is_con())
 865     return TypeLong::LONG;
 866 
 867   uint shift = r2-&gt;get_con();
 868   shift &amp;= BitsPerJavaLong - 1;  // semantics of Java shifts
 869   // Shift by a multiple of 64 does nothing:
 870   if (shift == 0)  return t1;
 871 
 872   // If the shift is a constant, shift the bounds of the type,
 873   // unless this could lead to an overflow.
 874   if (!r1-&gt;is_con()) {
 875     jlong lo = r1-&gt;_lo, hi = r1-&gt;_hi;
 876     if (((lo &lt;&lt; shift) &gt;&gt; shift) == lo &amp;&amp;
 877         ((hi &lt;&lt; shift) &gt;&gt; shift) == hi) {
 878       // No overflow.  The range shifts up cleanly.
 879       return TypeLong::make((jlong)lo &lt;&lt; (jint)shift,
 880                             (jlong)hi &lt;&lt; (jint)shift,
 881                             MAX2(r1-&gt;_widen,r2-&gt;_widen));
 882     }
 883     return TypeLong::LONG;
 884   }
 885 
 886   return TypeLong::make( (jlong)r1-&gt;get_con() &lt;&lt; (jint)shift );
 887 }
 888 
 889 //=============================================================================
 890 //------------------------------Identity---------------------------------------
 891 Node* RShiftINode::Identity(PhaseGVN* phase) {
 892   int shift = getShiftCon(phase, this, -1);
 893   if (shift == -1) return this;
 894   if ((shift &amp; (BitsPerJavaInteger - 1)) == 0) return in(1);
 895 
 896   // Check for useless sign-masking
 897   if (in(1)-&gt;Opcode() == Op_LShiftI &amp;&amp;
 898       in(1)-&gt;req() == 3 &amp;&amp;
 899       in(1)-&gt;in(2) == in(2)) {
 900     shift &amp;= BitsPerJavaInteger-1; // semantics of Java shifts
 901     // Compute masks for which this shifting doesn&#39;t change
 902     int lo = (-1 &lt;&lt; (BitsPerJavaInteger - ((uint)shift)-1)); // FFFF8000
 903     int hi = ~lo;               // 00007FFF
 904     const TypeInt *t11 = phase-&gt;type(in(1)-&gt;in(1))-&gt;isa_int();
 905     if (!t11) return this;
 906     // Does actual value fit inside of mask?
 907     if (lo &lt;= t11-&gt;_lo &amp;&amp; t11-&gt;_hi &lt;= hi) {
 908       return in(1)-&gt;in(1);      // Then shifting is a nop
 909     }
 910   }
 911 
 912   return this;
 913 }
 914 
 915 //------------------------------Ideal------------------------------------------
 916 Node *RShiftINode::Ideal(PhaseGVN *phase, bool can_reshape) {
 917   // Inputs may be TOP if they are dead.
 918   const TypeInt *t1 = phase-&gt;type(in(1))-&gt;isa_int();
 919   if (!t1) return NULL;        // Left input is an integer
 920   const TypeInt *t3;  // type of in(1).in(2)
 921   int shift = maskShiftAmount(phase, this, BitsPerJavaInteger);
 922   if (shift == 0) {
 923     return NULL;
 924   }
 925 
 926   // Check for (x &amp; 0xFF000000) &gt;&gt; 24, whose mask can be made smaller.
 927   // Such expressions arise normally from shift chains like (byte)(x &gt;&gt; 24).
 928   const Node *mask = in(1);
 929   if( mask-&gt;Opcode() == Op_AndI &amp;&amp;
 930       (t3 = phase-&gt;type(mask-&gt;in(2))-&gt;isa_int()) &amp;&amp;
 931       t3-&gt;is_con() ) {
 932     Node *x = mask-&gt;in(1);
 933     jint maskbits = t3-&gt;get_con();
 934     // Convert to &quot;(x &gt;&gt; shift) &amp; (mask &gt;&gt; shift)&quot;
 935     Node *shr_nomask = phase-&gt;transform( new RShiftINode(mask-&gt;in(1), in(2)) );
 936     return new AndINode(shr_nomask, phase-&gt;intcon( maskbits &gt;&gt; shift));
 937   }
 938 
 939   // Check for &quot;(short[i] &lt;&lt;16)&gt;&gt;16&quot; which simply sign-extends
 940   const Node *shl = in(1);
 941   if( shl-&gt;Opcode() != Op_LShiftI ) return NULL;
 942 
 943   if( shift == 16 &amp;&amp;
 944       (t3 = phase-&gt;type(shl-&gt;in(2))-&gt;isa_int()) &amp;&amp;
 945       t3-&gt;is_con(16) ) {
 946     Node *ld = shl-&gt;in(1);
 947     if( ld-&gt;Opcode() == Op_LoadS ) {
 948       // Sign extension is just useless here.  Return a RShiftI of zero instead
 949       // returning &#39;ld&#39; directly.  We cannot return an old Node directly as
 950       // that is the job of &#39;Identity&#39; calls and Identity calls only work on
 951       // direct inputs (&#39;ld&#39; is an extra Node removed from &#39;this&#39;).  The
 952       // combined optimization requires Identity only return direct inputs.
 953       set_req(1, ld);
 954       set_req(2, phase-&gt;intcon(0));
 955       return this;
 956     }
 957     else if( can_reshape &amp;&amp;
 958              ld-&gt;Opcode() == Op_LoadUS &amp;&amp;
 959              ld-&gt;outcnt() == 1 &amp;&amp; ld-&gt;unique_out() == shl)
 960       // Replace zero-extension-load with sign-extension-load
 961       return ld-&gt;as_Load()-&gt;convert_to_signed_load(*phase);
 962   }
 963 
 964   // Check for &quot;(byte[i] &lt;&lt;24)&gt;&gt;24&quot; which simply sign-extends
 965   if( shift == 24 &amp;&amp;
 966       (t3 = phase-&gt;type(shl-&gt;in(2))-&gt;isa_int()) &amp;&amp;
 967       t3-&gt;is_con(24) ) {
 968     Node *ld = shl-&gt;in(1);
 969     if( ld-&gt;Opcode() == Op_LoadB ) {
 970       // Sign extension is just useless here
 971       set_req(1, ld);
 972       set_req(2, phase-&gt;intcon(0));
 973       return this;
 974     }
 975   }
 976 
 977   return NULL;
 978 }
 979 
 980 //------------------------------Value------------------------------------------
 981 // A RShiftINode shifts its input2 right by input1 amount.
 982 const Type* RShiftINode::Value(PhaseGVN* phase) const {
 983   const Type *t1 = phase-&gt;type( in(1) );
 984   const Type *t2 = phase-&gt;type( in(2) );
 985   // Either input is TOP ==&gt; the result is TOP
 986   if( t1 == Type::TOP ) return Type::TOP;
 987   if( t2 == Type::TOP ) return Type::TOP;
 988 
 989   // Left input is ZERO ==&gt; the result is ZERO.
 990   if( t1 == TypeInt::ZERO ) return TypeInt::ZERO;
 991   // Shift by zero does nothing
 992   if( t2 == TypeInt::ZERO ) return t1;
 993 
 994   // Either input is BOTTOM ==&gt; the result is BOTTOM
 995   if (t1 == Type::BOTTOM || t2 == Type::BOTTOM)
 996     return TypeInt::INT;
 997 
 998   if (t2 == TypeInt::INT)
 999     return TypeInt::INT;
1000 
1001   const TypeInt *r1 = t1-&gt;is_int(); // Handy access
1002   const TypeInt *r2 = t2-&gt;is_int(); // Handy access
1003 
1004   // If the shift is a constant, just shift the bounds of the type.
1005   // For example, if the shift is 31, we just propagate sign bits.
1006   if (r2-&gt;is_con()) {
1007     uint shift = r2-&gt;get_con();
1008     shift &amp;= BitsPerJavaInteger-1;  // semantics of Java shifts
1009     // Shift by a multiple of 32 does nothing:
1010     if (shift == 0)  return t1;
1011     // Calculate reasonably aggressive bounds for the result.
1012     // This is necessary if we are to correctly type things
1013     // like (x&lt;&lt;24&gt;&gt;24) == ((byte)x).
1014     jint lo = (jint)r1-&gt;_lo &gt;&gt; (jint)shift;
1015     jint hi = (jint)r1-&gt;_hi &gt;&gt; (jint)shift;
1016     assert(lo &lt;= hi, &quot;must have valid bounds&quot;);
1017     const TypeInt* ti = TypeInt::make(lo, hi, MAX2(r1-&gt;_widen,r2-&gt;_widen));
1018 #ifdef ASSERT
1019     // Make sure we get the sign-capture idiom correct.
1020     if (shift == BitsPerJavaInteger-1) {
1021       if (r1-&gt;_lo &gt;= 0) assert(ti == TypeInt::ZERO,    &quot;&gt;&gt;31 of + is  0&quot;);
1022       if (r1-&gt;_hi &lt;  0) assert(ti == TypeInt::MINUS_1, &quot;&gt;&gt;31 of - is -1&quot;);
1023     }
1024 #endif
1025     return ti;
1026   }
1027 
1028   if( !r1-&gt;is_con() || !r2-&gt;is_con() )
1029     return TypeInt::INT;
1030 
1031   // Signed shift right
1032   return TypeInt::make( r1-&gt;get_con() &gt;&gt; (r2-&gt;get_con()&amp;31) );
1033 }
1034 
1035 //=============================================================================
1036 //------------------------------Identity---------------------------------------
1037 Node* RShiftLNode::Identity(PhaseGVN* phase) {
1038   const TypeInt *ti = phase-&gt;type(in(2))-&gt;isa_int(); // Shift count is an int.
1039   return (ti &amp;&amp; ti-&gt;is_con() &amp;&amp; (ti-&gt;get_con() &amp; (BitsPerJavaLong - 1)) == 0) ? in(1) : this;
1040 }
1041 
1042 //------------------------------Value------------------------------------------
1043 // A RShiftLNode shifts its input2 right by input1 amount.
1044 const Type* RShiftLNode::Value(PhaseGVN* phase) const {
1045   const Type *t1 = phase-&gt;type( in(1) );
1046   const Type *t2 = phase-&gt;type( in(2) );
1047   // Either input is TOP ==&gt; the result is TOP
1048   if( t1 == Type::TOP ) return Type::TOP;
1049   if( t2 == Type::TOP ) return Type::TOP;
1050 
1051   // Left input is ZERO ==&gt; the result is ZERO.
1052   if( t1 == TypeLong::ZERO ) return TypeLong::ZERO;
1053   // Shift by zero does nothing
1054   if( t2 == TypeInt::ZERO ) return t1;
1055 
1056   // Either input is BOTTOM ==&gt; the result is BOTTOM
1057   if (t1 == Type::BOTTOM || t2 == Type::BOTTOM)
1058     return TypeLong::LONG;
1059 
1060   if (t2 == TypeInt::INT)
1061     return TypeLong::LONG;
1062 
1063   const TypeLong *r1 = t1-&gt;is_long(); // Handy access
1064   const TypeInt  *r2 = t2-&gt;is_int (); // Handy access
1065 
1066   // If the shift is a constant, just shift the bounds of the type.
1067   // For example, if the shift is 63, we just propagate sign bits.
1068   if (r2-&gt;is_con()) {
1069     uint shift = r2-&gt;get_con();
1070     shift &amp;= (2*BitsPerJavaInteger)-1;  // semantics of Java shifts
1071     // Shift by a multiple of 64 does nothing:
1072     if (shift == 0)  return t1;
1073     // Calculate reasonably aggressive bounds for the result.
1074     // This is necessary if we are to correctly type things
1075     // like (x&lt;&lt;24&gt;&gt;24) == ((byte)x).
1076     jlong lo = (jlong)r1-&gt;_lo &gt;&gt; (jlong)shift;
1077     jlong hi = (jlong)r1-&gt;_hi &gt;&gt; (jlong)shift;
1078     assert(lo &lt;= hi, &quot;must have valid bounds&quot;);
1079     const TypeLong* tl = TypeLong::make(lo, hi, MAX2(r1-&gt;_widen,r2-&gt;_widen));
1080     #ifdef ASSERT
1081     // Make sure we get the sign-capture idiom correct.
1082     if (shift == (2*BitsPerJavaInteger)-1) {
1083       if (r1-&gt;_lo &gt;= 0) assert(tl == TypeLong::ZERO,    &quot;&gt;&gt;63 of + is 0&quot;);
1084       if (r1-&gt;_hi &lt; 0)  assert(tl == TypeLong::MINUS_1, &quot;&gt;&gt;63 of - is -1&quot;);
1085     }
1086     #endif
1087     return tl;
1088   }
1089 
1090   return TypeLong::LONG;                // Give up
1091 }
1092 
1093 //=============================================================================
1094 //------------------------------Identity---------------------------------------
1095 Node* URShiftINode::Identity(PhaseGVN* phase) {
1096   int shift = getShiftCon(phase, this, -1);
1097   if ((shift &amp; (BitsPerJavaInteger - 1)) == 0) return in(1);
1098 
1099   // Check for &quot;((x &lt;&lt; LogBytesPerWord) + (wordSize-1)) &gt;&gt; LogBytesPerWord&quot; which is just &quot;x&quot;.
1100   // Happens during new-array length computation.
1101   // Safe if &#39;x&#39; is in the range [0..(max_int&gt;&gt;LogBytesPerWord)]
1102   Node *add = in(1);
1103   if (add-&gt;Opcode() == Op_AddI) {
1104     const TypeInt *t2 = phase-&gt;type(add-&gt;in(2))-&gt;isa_int();
1105     if (t2 &amp;&amp; t2-&gt;is_con(wordSize - 1) &amp;&amp;
1106         add-&gt;in(1)-&gt;Opcode() == Op_LShiftI) {
1107       // Check that shift_counts are LogBytesPerWord.
1108       Node          *lshift_count   = add-&gt;in(1)-&gt;in(2);
1109       const TypeInt *t_lshift_count = phase-&gt;type(lshift_count)-&gt;isa_int();
1110       if (t_lshift_count &amp;&amp; t_lshift_count-&gt;is_con(LogBytesPerWord) &amp;&amp;
1111           t_lshift_count == phase-&gt;type(in(2))) {
1112         Node          *x   = add-&gt;in(1)-&gt;in(1);
1113         const TypeInt *t_x = phase-&gt;type(x)-&gt;isa_int();
1114         if (t_x != NULL &amp;&amp; 0 &lt;= t_x-&gt;_lo &amp;&amp; t_x-&gt;_hi &lt;= (max_jint&gt;&gt;LogBytesPerWord)) {
1115           return x;
1116         }
1117       }
1118     }
1119   }
1120 
1121   return (phase-&gt;type(in(2))-&gt;higher_equal(TypeInt::ZERO)) ? in(1) : this;
1122 }
1123 
1124 //------------------------------Ideal------------------------------------------
1125 Node *URShiftINode::Ideal(PhaseGVN *phase, bool can_reshape) {
1126   int con = maskShiftAmount(phase, this, BitsPerJavaInteger);
1127   if (con == 0) {
1128     return NULL;
1129   }
1130 
1131   // We&#39;ll be wanting the right-shift amount as a mask of that many bits
1132   const int mask = right_n_bits(BitsPerJavaInteger - con);
1133 
1134   int in1_op = in(1)-&gt;Opcode();
1135 
1136   // Check for ((x&gt;&gt;&gt;a)&gt;&gt;&gt;b) and replace with (x&gt;&gt;&gt;(a+b)) when a+b &lt; 32
1137   if( in1_op == Op_URShiftI ) {
1138     const TypeInt *t12 = phase-&gt;type( in(1)-&gt;in(2) )-&gt;isa_int();
1139     if( t12 &amp;&amp; t12-&gt;is_con() ) { // Right input is a constant
1140       assert( in(1) != in(1)-&gt;in(1), &quot;dead loop in URShiftINode::Ideal&quot; );
1141       const int con2 = t12-&gt;get_con() &amp; 31; // Shift count is always masked
1142       const int con3 = con+con2;
1143       if( con3 &lt; 32 )           // Only merge shifts if total is &lt; 32
1144         return new URShiftINode( in(1)-&gt;in(1), phase-&gt;intcon(con3) );
1145     }
1146   }
1147 
1148   // Check for ((x &lt;&lt; z) + Y) &gt;&gt;&gt; z.  Replace with x + con&gt;&gt;&gt;z
1149   // The idiom for rounding to a power of 2 is &quot;(Q+(2^z-1)) &gt;&gt;&gt; z&quot;.
1150   // If Q is &quot;X &lt;&lt; z&quot; the rounding is useless.  Look for patterns like
1151   // ((X&lt;&lt;Z) + Y) &gt;&gt;&gt; Z  and replace with (X + Y&gt;&gt;&gt;Z) &amp; Z-mask.
1152   Node *add = in(1);
1153   const TypeInt *t2 = phase-&gt;type(in(2))-&gt;isa_int();
1154   if (in1_op == Op_AddI) {
1155     Node *lshl = add-&gt;in(1);
1156     if( lshl-&gt;Opcode() == Op_LShiftI &amp;&amp;
1157         phase-&gt;type(lshl-&gt;in(2)) == t2 ) {
1158       Node *y_z = phase-&gt;transform( new URShiftINode(add-&gt;in(2),in(2)) );
1159       Node *sum = phase-&gt;transform( new AddINode( lshl-&gt;in(1), y_z ) );
1160       return new AndINode( sum, phase-&gt;intcon(mask) );
1161     }
1162   }
1163 
1164   // Check for (x &amp; mask) &gt;&gt;&gt; z.  Replace with (x &gt;&gt;&gt; z) &amp; (mask &gt;&gt;&gt; z)
1165   // This shortens the mask.  Also, if we are extracting a high byte and
1166   // storing it to a buffer, the mask will be removed completely.
1167   Node *andi = in(1);
1168   if( in1_op == Op_AndI ) {
1169     const TypeInt *t3 = phase-&gt;type( andi-&gt;in(2) )-&gt;isa_int();
1170     if( t3 &amp;&amp; t3-&gt;is_con() ) { // Right input is a constant
1171       jint mask2 = t3-&gt;get_con();
1172       mask2 &gt;&gt;= con;  // *signed* shift downward (high-order zeroes do not help)
1173       Node *newshr = phase-&gt;transform( new URShiftINode(andi-&gt;in(1), in(2)) );
1174       return new AndINode(newshr, phase-&gt;intcon(mask2));
1175       // The negative values are easier to materialize than positive ones.
1176       // A typical case from address arithmetic is ((x &amp; ~15) &gt;&gt; 4).
1177       // It&#39;s better to change that to ((x &gt;&gt; 4) &amp; ~0) versus
1178       // ((x &gt;&gt; 4) &amp; 0x0FFFFFFF).  The difference is greatest in LP64.
1179     }
1180   }
1181 
1182   // Check for &quot;(X &lt;&lt; z ) &gt;&gt;&gt; z&quot; which simply zero-extends
1183   Node *shl = in(1);
1184   if( in1_op == Op_LShiftI &amp;&amp;
1185       phase-&gt;type(shl-&gt;in(2)) == t2 )
1186     return new AndINode( shl-&gt;in(1), phase-&gt;intcon(mask) );
1187 
1188   // Check for (x &gt;&gt; n) &gt;&gt;&gt; 31. Replace with (x &gt;&gt;&gt; 31)
1189   Node *shr = in(1);
1190   if ( in1_op == Op_RShiftI ) {
1191     Node *in11 = shr-&gt;in(1);
1192     Node *in12 = shr-&gt;in(2);
1193     const TypeInt *t11 = phase-&gt;type(in11)-&gt;isa_int();
1194     const TypeInt *t12 = phase-&gt;type(in12)-&gt;isa_int();
1195     if ( t11 &amp;&amp; t2 &amp;&amp; t2-&gt;is_con(31) &amp;&amp; t12 &amp;&amp; t12-&gt;is_con() ) {
1196       return new URShiftINode(in11, phase-&gt;intcon(31));
1197     }
1198   }
1199 
1200   return NULL;
1201 }
1202 
1203 //------------------------------Value------------------------------------------
1204 // A URShiftINode shifts its input2 right by input1 amount.
1205 const Type* URShiftINode::Value(PhaseGVN* phase) const {
1206   // (This is a near clone of RShiftINode::Value.)
1207   const Type *t1 = phase-&gt;type( in(1) );
1208   const Type *t2 = phase-&gt;type( in(2) );
1209   // Either input is TOP ==&gt; the result is TOP
1210   if( t1 == Type::TOP ) return Type::TOP;
1211   if( t2 == Type::TOP ) return Type::TOP;
1212 
1213   // Left input is ZERO ==&gt; the result is ZERO.
1214   if( t1 == TypeInt::ZERO ) return TypeInt::ZERO;
1215   // Shift by zero does nothing
1216   if( t2 == TypeInt::ZERO ) return t1;
1217 
1218   // Either input is BOTTOM ==&gt; the result is BOTTOM
1219   if (t1 == Type::BOTTOM || t2 == Type::BOTTOM)
1220     return TypeInt::INT;
1221 
1222   if (t2 == TypeInt::INT)
1223     return TypeInt::INT;
1224 
1225   const TypeInt *r1 = t1-&gt;is_int();     // Handy access
1226   const TypeInt *r2 = t2-&gt;is_int();     // Handy access
1227 
1228   if (r2-&gt;is_con()) {
1229     uint shift = r2-&gt;get_con();
1230     shift &amp;= BitsPerJavaInteger-1;  // semantics of Java shifts
1231     // Shift by a multiple of 32 does nothing:
1232     if (shift == 0)  return t1;
1233     // Calculate reasonably aggressive bounds for the result.
1234     jint lo = (juint)r1-&gt;_lo &gt;&gt; (juint)shift;
1235     jint hi = (juint)r1-&gt;_hi &gt;&gt; (juint)shift;
1236     if (r1-&gt;_hi &gt;= 0 &amp;&amp; r1-&gt;_lo &lt; 0) {
1237       // If the type has both negative and positive values,
1238       // there are two separate sub-domains to worry about:
1239       // The positive half and the negative half.
1240       jint neg_lo = lo;
1241       jint neg_hi = (juint)-1 &gt;&gt; (juint)shift;
1242       jint pos_lo = (juint) 0 &gt;&gt; (juint)shift;
1243       jint pos_hi = hi;
1244       lo = MIN2(neg_lo, pos_lo);  // == 0
1245       hi = MAX2(neg_hi, pos_hi);  // == -1 &gt;&gt;&gt; shift;
1246     }
1247     assert(lo &lt;= hi, &quot;must have valid bounds&quot;);
1248     const TypeInt* ti = TypeInt::make(lo, hi, MAX2(r1-&gt;_widen,r2-&gt;_widen));
1249     #ifdef ASSERT
1250     // Make sure we get the sign-capture idiom correct.
1251     if (shift == BitsPerJavaInteger-1) {
1252       if (r1-&gt;_lo &gt;= 0) assert(ti == TypeInt::ZERO, &quot;&gt;&gt;&gt;31 of + is 0&quot;);
1253       if (r1-&gt;_hi &lt; 0)  assert(ti == TypeInt::ONE,  &quot;&gt;&gt;&gt;31 of - is +1&quot;);
1254     }
1255     #endif
1256     return ti;
1257   }
1258 
1259   //
1260   // Do not support shifted oops in info for GC
1261   //
1262   // else if( t1-&gt;base() == Type::InstPtr ) {
1263   //
1264   //   const TypeInstPtr *o = t1-&gt;is_instptr();
1265   //   if( t1-&gt;singleton() )
1266   //     return TypeInt::make( ((uint32_t)o-&gt;const_oop() + o-&gt;_offset) &gt;&gt; shift );
1267   // }
1268   // else if( t1-&gt;base() == Type::KlassPtr ) {
1269   //   const TypeKlassPtr *o = t1-&gt;is_klassptr();
1270   //   if( t1-&gt;singleton() )
1271   //     return TypeInt::make( ((uint32_t)o-&gt;const_oop() + o-&gt;_offset) &gt;&gt; shift );
1272   // }
1273 
1274   return TypeInt::INT;
1275 }
1276 
1277 //=============================================================================
1278 //------------------------------Identity---------------------------------------
1279 Node* URShiftLNode::Identity(PhaseGVN* phase) {
1280   return ((getShiftCon(phase, this, -1) &amp; (BitsPerJavaLong - 1)) == 0) ? in(1) : this;
1281 }
1282 
1283 //------------------------------Ideal------------------------------------------
1284 Node *URShiftLNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1285   int con = maskShiftAmount(phase, this, BitsPerJavaLong);
1286   if (con == 0) {
1287     return NULL;
1288   }
1289 
1290   // We&#39;ll be wanting the right-shift amount as a mask of that many bits
1291   const jlong mask = jlong(max_julong &gt;&gt; con);
1292 
1293   // Check for ((x &lt;&lt; z) + Y) &gt;&gt;&gt; z.  Replace with x + con&gt;&gt;&gt;z
1294   // The idiom for rounding to a power of 2 is &quot;(Q+(2^z-1)) &gt;&gt;&gt; z&quot;.
1295   // If Q is &quot;X &lt;&lt; z&quot; the rounding is useless.  Look for patterns like
1296   // ((X&lt;&lt;Z) + Y) &gt;&gt;&gt; Z  and replace with (X + Y&gt;&gt;&gt;Z) &amp; Z-mask.
1297   Node *add = in(1);
1298   const TypeInt *t2 = phase-&gt;type(in(2))-&gt;isa_int();
1299   if (add-&gt;Opcode() == Op_AddL) {
1300     Node *lshl = add-&gt;in(1);
1301     if( lshl-&gt;Opcode() == Op_LShiftL &amp;&amp;
1302         phase-&gt;type(lshl-&gt;in(2)) == t2 ) {
1303       Node *y_z = phase-&gt;transform( new URShiftLNode(add-&gt;in(2),in(2)) );
1304       Node *sum = phase-&gt;transform( new AddLNode( lshl-&gt;in(1), y_z ) );
1305       return new AndLNode( sum, phase-&gt;longcon(mask) );
1306     }
1307   }
1308 
1309   // Check for (x &amp; mask) &gt;&gt;&gt; z.  Replace with (x &gt;&gt;&gt; z) &amp; (mask &gt;&gt;&gt; z)
1310   // This shortens the mask.  Also, if we are extracting a high byte and
1311   // storing it to a buffer, the mask will be removed completely.
1312   Node *andi = in(1);
1313   if( andi-&gt;Opcode() == Op_AndL ) {
1314     const TypeLong *t3 = phase-&gt;type( andi-&gt;in(2) )-&gt;isa_long();
1315     if( t3 &amp;&amp; t3-&gt;is_con() ) { // Right input is a constant
1316       jlong mask2 = t3-&gt;get_con();
1317       mask2 &gt;&gt;= con;  // *signed* shift downward (high-order zeroes do not help)
1318       Node *newshr = phase-&gt;transform( new URShiftLNode(andi-&gt;in(1), in(2)) );
1319       return new AndLNode(newshr, phase-&gt;longcon(mask2));
1320     }
1321   }
1322 
1323   // Check for &quot;(X &lt;&lt; z ) &gt;&gt;&gt; z&quot; which simply zero-extends
1324   Node *shl = in(1);
1325   if( shl-&gt;Opcode() == Op_LShiftL &amp;&amp;
1326       phase-&gt;type(shl-&gt;in(2)) == t2 )
1327     return new AndLNode( shl-&gt;in(1), phase-&gt;longcon(mask) );
1328 
1329   // Check for (x &gt;&gt; n) &gt;&gt;&gt; 63. Replace with (x &gt;&gt;&gt; 63)
1330   Node *shr = in(1);
1331   if ( shr-&gt;Opcode() == Op_RShiftL ) {
1332     Node *in11 = shr-&gt;in(1);
1333     Node *in12 = shr-&gt;in(2);
1334     const TypeLong *t11 = phase-&gt;type(in11)-&gt;isa_long();
1335     const TypeInt *t12 = phase-&gt;type(in12)-&gt;isa_int();
1336     if ( t11 &amp;&amp; t2 &amp;&amp; t2-&gt;is_con(63) &amp;&amp; t12 &amp;&amp; t12-&gt;is_con() ) {
1337       return new URShiftLNode(in11, phase-&gt;intcon(63));
1338     }
1339   }
1340   return NULL;
1341 }
1342 
1343 //------------------------------Value------------------------------------------
1344 // A URShiftINode shifts its input2 right by input1 amount.
1345 const Type* URShiftLNode::Value(PhaseGVN* phase) const {
1346   // (This is a near clone of RShiftLNode::Value.)
1347   const Type *t1 = phase-&gt;type( in(1) );
1348   const Type *t2 = phase-&gt;type( in(2) );
1349   // Either input is TOP ==&gt; the result is TOP
1350   if( t1 == Type::TOP ) return Type::TOP;
1351   if( t2 == Type::TOP ) return Type::TOP;
1352 
1353   // Left input is ZERO ==&gt; the result is ZERO.
1354   if( t1 == TypeLong::ZERO ) return TypeLong::ZERO;
1355   // Shift by zero does nothing
1356   if( t2 == TypeInt::ZERO ) return t1;
1357 
1358   // Either input is BOTTOM ==&gt; the result is BOTTOM
1359   if (t1 == Type::BOTTOM || t2 == Type::BOTTOM)
1360     return TypeLong::LONG;
1361 
1362   if (t2 == TypeInt::INT)
1363     return TypeLong::LONG;
1364 
1365   const TypeLong *r1 = t1-&gt;is_long(); // Handy access
1366   const TypeInt  *r2 = t2-&gt;is_int (); // Handy access
1367 
1368   if (r2-&gt;is_con()) {
1369     uint shift = r2-&gt;get_con();
1370     shift &amp;= BitsPerJavaLong - 1;  // semantics of Java shifts
1371     // Shift by a multiple of 64 does nothing:
1372     if (shift == 0)  return t1;
1373     // Calculate reasonably aggressive bounds for the result.
1374     jlong lo = (julong)r1-&gt;_lo &gt;&gt; (juint)shift;
1375     jlong hi = (julong)r1-&gt;_hi &gt;&gt; (juint)shift;
1376     if (r1-&gt;_hi &gt;= 0 &amp;&amp; r1-&gt;_lo &lt; 0) {
1377       // If the type has both negative and positive values,
1378       // there are two separate sub-domains to worry about:
1379       // The positive half and the negative half.
1380       jlong neg_lo = lo;
1381       jlong neg_hi = (julong)-1 &gt;&gt; (juint)shift;
1382       jlong pos_lo = (julong) 0 &gt;&gt; (juint)shift;
1383       jlong pos_hi = hi;
1384       //lo = MIN2(neg_lo, pos_lo);  // == 0
1385       lo = neg_lo &lt; pos_lo ? neg_lo : pos_lo;
1386       //hi = MAX2(neg_hi, pos_hi);  // == -1 &gt;&gt;&gt; shift;
1387       hi = neg_hi &gt; pos_hi ? neg_hi : pos_hi;
1388     }
1389     assert(lo &lt;= hi, &quot;must have valid bounds&quot;);
1390     const TypeLong* tl = TypeLong::make(lo, hi, MAX2(r1-&gt;_widen,r2-&gt;_widen));
1391     #ifdef ASSERT
1392     // Make sure we get the sign-capture idiom correct.
1393     if (shift == BitsPerJavaLong - 1) {
1394       if (r1-&gt;_lo &gt;= 0) assert(tl == TypeLong::ZERO, &quot;&gt;&gt;&gt;63 of + is 0&quot;);
1395       if (r1-&gt;_hi &lt; 0)  assert(tl == TypeLong::ONE,  &quot;&gt;&gt;&gt;63 of - is +1&quot;);
1396     }
1397     #endif
1398     return tl;
1399   }
1400 
1401   return TypeLong::LONG;                // Give up
1402 }
1403 
1404 //=============================================================================
1405 //------------------------------Value------------------------------------------
1406 const Type* FmaDNode::Value(PhaseGVN* phase) const {
1407   const Type *t1 = phase-&gt;type(in(1));
1408   if (t1 == Type::TOP) return Type::TOP;
1409   if (t1-&gt;base() != Type::DoubleCon) return Type::DOUBLE;
1410   const Type *t2 = phase-&gt;type(in(2));
1411   if (t2 == Type::TOP) return Type::TOP;
1412   if (t2-&gt;base() != Type::DoubleCon) return Type::DOUBLE;
1413   const Type *t3 = phase-&gt;type(in(3));
1414   if (t3 == Type::TOP) return Type::TOP;
1415   if (t3-&gt;base() != Type::DoubleCon) return Type::DOUBLE;
1416 #ifndef __STDC_IEC_559__
1417   return Type::DOUBLE;
1418 #else
1419   double d1 = t1-&gt;getd();
1420   double d2 = t2-&gt;getd();
1421   double d3 = t3-&gt;getd();
1422   return TypeD::make(fma(d1, d2, d3));
1423 #endif
1424 }
1425 
1426 //=============================================================================
1427 //------------------------------Value------------------------------------------
1428 const Type* FmaFNode::Value(PhaseGVN* phase) const {
1429   const Type *t1 = phase-&gt;type(in(1));
1430   if (t1 == Type::TOP) return Type::TOP;
1431   if (t1-&gt;base() != Type::FloatCon) return Type::FLOAT;
1432   const Type *t2 = phase-&gt;type(in(2));
1433   if (t2 == Type::TOP) return Type::TOP;
1434   if (t2-&gt;base() != Type::FloatCon) return Type::FLOAT;
1435   const Type *t3 = phase-&gt;type(in(3));
1436   if (t3 == Type::TOP) return Type::TOP;
1437   if (t3-&gt;base() != Type::FloatCon) return Type::FLOAT;
1438 #ifndef __STDC_IEC_559__
1439   return Type::FLOAT;
1440 #else
1441   float f1 = t1-&gt;getf();
1442   float f2 = t2-&gt;getf();
1443   float f3 = t3-&gt;getf();
1444   return TypeF::make(fma(f1, f2, f3));
1445 #endif
1446 }
1447 
1448 //=============================================================================
1449 //------------------------------hash-------------------------------------------
1450 // Hash function for MulAddS2INode.  Operation is commutative with commutative pairs.
1451 // The hash function must return the same value when edge swapping is performed.
1452 uint MulAddS2INode::hash() const {
1453   return (uintptr_t)in(1) + (uintptr_t)in(2) + (uintptr_t)in(3) + (uintptr_t)in(4) + Opcode();
1454 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
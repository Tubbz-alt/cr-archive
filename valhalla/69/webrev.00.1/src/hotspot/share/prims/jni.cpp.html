<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/prims/jni.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2012 Red Hat, Inc.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;jni.h&quot;
  28 #include &quot;jvm.h&quot;
  29 #include &quot;ci/ciReplay.hpp&quot;
  30 #include &quot;classfile/altHashing.hpp&quot;
  31 #include &quot;classfile/classFileStream.hpp&quot;
  32 #include &quot;classfile/classLoader.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/moduleEntry.hpp&quot;
  36 #include &quot;classfile/modules.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/vmSymbols.hpp&quot;
  40 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  41 #include &quot;interpreter/linkResolver.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/allocation.inline.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/access.inline.hpp&quot;
  51 #include &quot;oops/arrayOop.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.inline.hpp&quot;
  53 #include &quot;oops/instanceOop.hpp&quot;
  54 #include &quot;oops/markWord.hpp&quot;
  55 #include &quot;oops/method.hpp&quot;
  56 #include &quot;oops/objArrayKlass.hpp&quot;
  57 #include &quot;oops/objArrayOop.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/symbol.hpp&quot;
  60 #include &quot;oops/typeArrayKlass.hpp&quot;
  61 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  62 #include &quot;oops/valueArrayOop.inline.hpp&quot;
  63 #include &quot;oops/valueKlass.inline.hpp&quot;
  64 #include &quot;prims/jniCheck.hpp&quot;
  65 #include &quot;prims/jniExport.hpp&quot;
  66 #include &quot;prims/jniFastGetField.hpp&quot;
  67 #include &quot;prims/jvm_misc.hpp&quot;
  68 #include &quot;prims/jvmtiExport.hpp&quot;
  69 #include &quot;prims/jvmtiThreadState.hpp&quot;
  70 #include &quot;runtime/atomic.hpp&quot;
  71 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  72 #include &quot;runtime/handles.inline.hpp&quot;
  73 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  74 #include &quot;runtime/java.hpp&quot;
  75 #include &quot;runtime/javaCalls.hpp&quot;
  76 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  77 #include &quot;runtime/jniHandles.inline.hpp&quot;
  78 #include &quot;runtime/reflection.hpp&quot;
  79 #include &quot;runtime/safepointVerifiers.hpp&quot;
  80 #include &quot;runtime/sharedRuntime.hpp&quot;
  81 #include &quot;runtime/signature.hpp&quot;
  82 #include &quot;runtime/thread.inline.hpp&quot;
  83 #include &quot;runtime/vmOperations.hpp&quot;
  84 #include &quot;services/memTracker.hpp&quot;
  85 #include &quot;services/runtimeService.hpp&quot;
  86 #include &quot;utilities/defaultStream.hpp&quot;
  87 #include &quot;utilities/dtrace.hpp&quot;
  88 #include &quot;utilities/events.hpp&quot;
  89 #include &quot;utilities/histogram.hpp&quot;
  90 #include &quot;utilities/macros.hpp&quot;
  91 #include &quot;utilities/vmError.hpp&quot;
  92 #if INCLUDE_JVMCI
  93 #include &quot;jvmci/jvmciCompiler.hpp&quot;
  94 #endif
  95 
  96 static jint CurrentVersion = JNI_VERSION_10;
  97 
  98 #ifdef _WIN32
  99 extern LONG WINAPI topLevelExceptionFilter(_EXCEPTION_POINTERS* );
 100 #endif
 101 
 102 // The DT_RETURN_MARK macros create a scoped object to fire the dtrace
 103 // &#39;-return&#39; probe regardless of the return path is taken out of the function.
 104 // Methods that have multiple return paths use this to avoid having to
 105 // instrument each return path.  Methods that use CHECK or THROW must use this
 106 // since those macros can cause an immedate uninstrumented return.
 107 //
 108 // In order to get the return value, a reference to the variable containing
 109 // the return value must be passed to the contructor of the object, and
 110 // the return value must be set before return (since the mark object has
 111 // a reference to it).
 112 //
 113 // Example:
 114 // DT_RETURN_MARK_DECL(SomeFunc, int);
 115 // JNI_ENTRY(int, SomeFunc, ...)
 116 //   int return_value = 0;
 117 //   DT_RETURN_MARK(SomeFunc, int, (const int&amp;)return_value);
 118 //   foo(CHECK_0)
 119 //   return_value = 5;
 120 //   return return_value;
 121 // JNI_END
 122 #define DT_RETURN_MARK_DECL(name, type, probe)                             \
 123   DTRACE_ONLY(                                                             \
 124     class DTraceReturnProbeMark_##name {                                   \
 125      public:                                                               \
 126       const type&amp; _ret_ref;                                                \
 127       DTraceReturnProbeMark_##name(const type&amp; v) : _ret_ref(v) {}         \
 128       ~DTraceReturnProbeMark_##name() {                                    \
 129         probe;                                                             \
 130       }                                                                    \
 131     }                                                                      \
 132   )
 133 // Void functions are simpler since there&#39;s no return value
 134 #define DT_VOID_RETURN_MARK_DECL(name, probe)                              \
 135   DTRACE_ONLY(                                                             \
 136     class DTraceReturnProbeMark_##name {                                   \
 137      public:                                                               \
 138       ~DTraceReturnProbeMark_##name() {                                    \
 139         probe;                                                             \
 140       }                                                                    \
 141     }                                                                      \
 142   )
 143 
 144 // Place these macros in the function to mark the return.  Non-void
 145 // functions need the type and address of the return value.
 146 #define DT_RETURN_MARK(name, type, ref) \
 147   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark(ref) )
 148 #define DT_VOID_RETURN_MARK(name) \
 149   DTRACE_ONLY( DTraceReturnProbeMark_##name dtrace_return_mark )
 150 
 151 
 152 // Use these to select distinct code for floating-point vs. non-floating point
 153 // situations.  Used from within common macros where we need slightly
 154 // different behavior for Float/Double
 155 #define FP_SELECT_Boolean(intcode, fpcode) intcode
 156 #define FP_SELECT_Byte(intcode, fpcode)    intcode
 157 #define FP_SELECT_Char(intcode, fpcode)    intcode
 158 #define FP_SELECT_Short(intcode, fpcode)   intcode
 159 #define FP_SELECT_Object(intcode, fpcode)  intcode
 160 #define FP_SELECT_Int(intcode, fpcode)     intcode
 161 #define FP_SELECT_Long(intcode, fpcode)    intcode
 162 #define FP_SELECT_Float(intcode, fpcode)   fpcode
 163 #define FP_SELECT_Double(intcode, fpcode)  fpcode
 164 #define FP_SELECT(TypeName, intcode, fpcode) \
 165   FP_SELECT_##TypeName(intcode, fpcode)
 166 
 167 // Choose DT_RETURN_MARK macros  based on the type: float/double -&gt; void
 168 // (dtrace doesn&#39;t do FP yet)
 169 #define DT_RETURN_MARK_DECL_FOR(TypeName, name, type, probe)    \
 170   FP_SELECT(TypeName, \
 171     DT_RETURN_MARK_DECL(name, type, probe), DT_VOID_RETURN_MARK_DECL(name, probe) )
 172 #define DT_RETURN_MARK_FOR(TypeName, name, type, ref) \
 173   FP_SELECT(TypeName, \
 174     DT_RETURN_MARK(name, type, ref), DT_VOID_RETURN_MARK(name) )
 175 
 176 
 177 // out-of-line helpers for class jfieldIDWorkaround:
 178 
 179 bool jfieldIDWorkaround::is_valid_jfieldID(Klass* k, jfieldID id) {
 180   if (jfieldIDWorkaround::is_instance_jfieldID(k, id)) {
 181     uintptr_t as_uint = (uintptr_t) id;
 182     intptr_t offset = raw_instance_offset(id);
 183     if (is_checked_jfieldID(id)) {
 184       if (!klass_hash_ok(k, id)) {
 185         return false;
 186       }
 187     }
 188     return InstanceKlass::cast(k)-&gt;contains_field_offset(offset);
 189   } else {
 190     JNIid* result = (JNIid*) id;
 191 #ifdef ASSERT
 192     return result != NULL &amp;&amp; result-&gt;is_static_field_id();
 193 #else
 194     return result != NULL;
 195 #endif
 196   }
 197 }
 198 
 199 
 200 intptr_t jfieldIDWorkaround::encode_klass_hash(Klass* k, intptr_t offset) {
 201   if (offset &lt;= small_offset_mask) {
 202     Klass* field_klass = k;
 203     Klass* super_klass = field_klass-&gt;super();
 204     // With compressed oops the most super class with nonstatic fields would
 205     // be the owner of fields embedded in the header.
 206     while (InstanceKlass::cast(super_klass)-&gt;has_nonstatic_fields() &amp;&amp;
 207            InstanceKlass::cast(super_klass)-&gt;contains_field_offset(offset)) {
 208       field_klass = super_klass;   // super contains the field also
 209       super_klass = field_klass-&gt;super();
 210     }
 211     debug_only(NoSafepointVerifier nosafepoint;)
 212     uintptr_t klass_hash = field_klass-&gt;identity_hash();
 213     return ((klass_hash &amp; klass_mask) &lt;&lt; klass_shift) | checked_mask_in_place;
 214   } else {
 215 #if 0
 216     #ifndef PRODUCT
 217     {
 218       ResourceMark rm;
 219       warning(&quot;VerifyJNIFields: long offset %d in %s&quot;, offset, k-&gt;external_name());
 220     }
 221     #endif
 222 #endif
 223     return 0;
 224   }
 225 }
 226 
 227 bool jfieldIDWorkaround::klass_hash_ok(Klass* k, jfieldID id) {
 228   uintptr_t as_uint = (uintptr_t) id;
 229   intptr_t klass_hash = (as_uint &gt;&gt; klass_shift) &amp; klass_mask;
 230   do {
 231     debug_only(NoSafepointVerifier nosafepoint;)
 232     // Could use a non-blocking query for identity_hash here...
 233     if ((k-&gt;identity_hash() &amp; klass_mask) == klass_hash)
 234       return true;
 235     k = k-&gt;super();
 236   } while (k != NULL);
 237   return false;
 238 }
 239 
 240 void jfieldIDWorkaround::verify_instance_jfieldID(Klass* k, jfieldID id) {
 241   guarantee(jfieldIDWorkaround::is_instance_jfieldID(k, id), &quot;must be an instance field&quot; );
 242   uintptr_t as_uint = (uintptr_t) id;
 243   intptr_t offset = raw_instance_offset(id);
 244   if (VerifyJNIFields) {
 245     if (is_checked_jfieldID(id)) {
 246       guarantee(klass_hash_ok(k, id),
 247     &quot;Bug in native code: jfieldID class must match object&quot;);
 248     } else {
 249 #if 0
 250       #ifndef PRODUCT
 251       if (Verbose) {
 252   ResourceMark rm;
 253   warning(&quot;VerifyJNIFields: unverified offset %d for %s&quot;, offset, k-&gt;external_name());
 254       }
 255       #endif
 256 #endif
 257     }
 258   }
 259   guarantee(InstanceKlass::cast(k)-&gt;contains_field_offset(offset),
 260       &quot;Bug in native code: jfieldID offset must address interior of object&quot;);
 261 }
 262 
 263 // Wrapper to trace JNI functions
 264 
 265 #ifdef ASSERT
 266   Histogram* JNIHistogram;
 267   static volatile int JNIHistogram_lock = 0;
 268 
 269   class JNIHistogramElement : public HistogramElement {
 270     public:
 271      JNIHistogramElement(const char* name);
 272   };
 273 
 274   JNIHistogramElement::JNIHistogramElement(const char* elementName) {
 275     _name = elementName;
 276     uintx count = 0;
 277 
 278     while (Atomic::cmpxchg(&amp;JNIHistogram_lock, 0, 1) != 0) {
 279       while (Atomic::load_acquire(&amp;JNIHistogram_lock) != 0) {
 280         count +=1;
 281         if ( (WarnOnStalledSpinLock &gt; 0)
 282           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 283           warning(&quot;JNIHistogram_lock seems to be stalled&quot;);
 284         }
 285       }
 286      }
 287 
 288 
 289     if(JNIHistogram == NULL)
 290       JNIHistogram = new Histogram(&quot;JNI Call Counts&quot;,100);
 291 
 292     JNIHistogram-&gt;add_element(this);
 293     Atomic::dec(&amp;JNIHistogram_lock);
 294   }
 295 
 296   #define JNICountWrapper(arg)                                     \
 297      static JNIHistogramElement* e = new JNIHistogramElement(arg); \
 298       /* There is a MT-race condition in VC++. So we need to make sure that that e has been initialized */ \
 299      if (e != NULL) e-&gt;increment_count()
 300   #define JNIWrapper(arg) JNICountWrapper(arg);
 301 #else
 302   #define JNIWrapper(arg)
 303 #endif
 304 
 305 
 306 // Implementation of JNI entries
 307 
 308 DT_RETURN_MARK_DECL(DefineClass, jclass
 309                     , HOTSPOT_JNI_DEFINECLASS_RETURN(_ret_ref));
 310 
 311 JNI_ENTRY(jclass, jni_DefineClass(JNIEnv *env, const char *name, jobject loaderRef,
 312                                   const jbyte *buf, jsize bufLen))
 313   JNIWrapper(&quot;DefineClass&quot;);
 314 
 315   HOTSPOT_JNI_DEFINECLASS_ENTRY(
 316     env, (char*) name, loaderRef, (char*) buf, bufLen);
 317 
 318   jclass cls = NULL;
 319   DT_RETURN_MARK(DefineClass, jclass, (const jclass&amp;)cls);
 320 
 321   TempNewSymbol class_name = NULL;
 322   // Since exceptions can be thrown, class initialization can take place
 323   // if name is NULL no check for class name in .class stream has to be made.
 324   if (name != NULL) {
 325     const int str_len = (int)strlen(name);
 326     if (str_len &gt; Symbol::max_length()) {
 327       // It&#39;s impossible to create this class;  the name cannot fit
 328       // into the constant pool.
 329       Exceptions::fthrow(THREAD_AND_LOCATION,
 330                          vmSymbols::java_lang_NoClassDefFoundError(),
 331                          &quot;Class name exceeds maximum length of %d: %s&quot;,
 332                          Symbol::max_length(),
 333                          name);
 334       return 0;
 335     }
 336     class_name = SymbolTable::new_symbol(name);
 337   }
 338   ResourceMark rm(THREAD);
 339   ClassFileStream st((u1*)buf, bufLen, NULL, ClassFileStream::verify);
 340   Handle class_loader (THREAD, JNIHandles::resolve(loaderRef));
 341 
 342   if (UsePerfData &amp;&amp; !class_loader.is_null()) {
 343     // check whether the current caller thread holds the lock or not.
 344     // If not, increment the corresponding counter
 345     if (ObjectSynchronizer::
 346         query_lock_ownership((JavaThread*)THREAD, class_loader) !=
 347         ObjectSynchronizer::owner_self) {
 348       ClassLoader::sync_JNIDefineClassLockFreeCounter()-&gt;inc();
 349     }
 350   }
 351   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 352                                                    class_loader,
 353                                                    Handle(),
 354                                                    &amp;st,
 355                                                    CHECK_NULL);
 356 
 357   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 358     trace_class_resolution(k);
 359   }
 360 
 361   cls = (jclass)JNIHandles::make_local(
 362     env, k-&gt;java_mirror());
 363   return cls;
 364 JNI_END
 365 
 366 
 367 
 368 DT_RETURN_MARK_DECL(FindClass, jclass
 369                     , HOTSPOT_JNI_FINDCLASS_RETURN(_ret_ref));
 370 
 371 JNI_ENTRY(jclass, jni_FindClass(JNIEnv *env, const char *name))
 372   JNIWrapper(&quot;FindClass&quot;);
 373 
 374   HOTSPOT_JNI_FINDCLASS_ENTRY(env, (char *)name);
 375 
 376   jclass result = NULL;
 377   DT_RETURN_MARK(FindClass, jclass, (const jclass&amp;)result);
 378 
 379   // Sanity check the name:  it cannot be null or larger than the maximum size
 380   // name we can fit in the constant pool.
 381   if (name == NULL) {
 382     THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), &quot;No class name given&quot;);
 383   }
 384   if ((int)strlen(name) &gt; Symbol::max_length()) {
 385     Exceptions::fthrow(THREAD_AND_LOCATION,
 386                        vmSymbols::java_lang_NoClassDefFoundError(),
 387                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 388                        Symbol::max_length(),
 389                        name);
 390     return 0;
 391   }
 392 
 393   //%note jni_3
 394   Handle protection_domain;
 395   // Find calling class
 396   Klass* k = thread-&gt;security_get_caller_class(0);
 397   // default to the system loader when no context
 398   Handle loader(THREAD, SystemDictionary::java_system_loader());
 399   if (k != NULL) {
 400     // Special handling to make sure JNI_OnLoad and JNI_OnUnload are executed
 401     // in the correct class context.
 402     if (k-&gt;class_loader() == NULL &amp;&amp;
 403         k-&gt;name() == vmSymbols::jdk_internal_loader_NativeLibraries()) {
 404       JavaValue result(T_OBJECT);
 405       JavaCalls::call_static(&amp;result, k,
 406                              vmSymbols::getFromClass_name(),
 407                              vmSymbols::void_class_signature(),
 408                              CHECK_NULL);
 409       // When invoked from JNI_OnLoad, NativeLibraries::getFromClass returns
 410       // a non-NULL Class object.  When invoked from JNI_OnUnload,
 411       // it will return NULL to indicate no context.
 412       oop mirror = (oop) result.get_jobject();
 413       if (mirror != NULL) {
 414         Klass* fromClass = java_lang_Class::as_Klass(mirror);
 415         loader = Handle(THREAD, fromClass-&gt;class_loader());
 416         protection_domain = Handle(THREAD, fromClass-&gt;protection_domain());
 417       }
 418     } else {
 419       loader = Handle(THREAD, k-&gt;class_loader());
 420     }
 421   }
 422 
 423   TempNewSymbol sym = SymbolTable::new_symbol(name);
 424   result = find_class_from_class_loader(env, sym, true, loader,
 425                                         protection_domain, true, thread);
 426 
 427   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 428     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 429   }
 430 
 431   return result;
 432 JNI_END
 433 
 434 DT_RETURN_MARK_DECL(FromReflectedMethod, jmethodID
 435                     , HOTSPOT_JNI_FROMREFLECTEDMETHOD_RETURN((uintptr_t)_ret_ref));
 436 
 437 JNI_ENTRY(jmethodID, jni_FromReflectedMethod(JNIEnv *env, jobject method))
 438   JNIWrapper(&quot;FromReflectedMethod&quot;);
 439 
 440   HOTSPOT_JNI_FROMREFLECTEDMETHOD_ENTRY(env, method);
 441 
 442   jmethodID ret = NULL;
 443   DT_RETURN_MARK(FromReflectedMethod, jmethodID, (const jmethodID&amp;)ret);
 444 
 445   // method is a handle to a java.lang.reflect.Method object
 446   oop reflected  = JNIHandles::resolve_non_null(method);
 447   oop mirror     = NULL;
 448   int slot       = 0;
 449 
 450   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
 451     mirror = java_lang_reflect_Constructor::clazz(reflected);
 452     slot   = java_lang_reflect_Constructor::slot(reflected);
 453   } else {
 454     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(), &quot;wrong type&quot;);
 455     mirror = java_lang_reflect_Method::clazz(reflected);
 456     slot   = java_lang_reflect_Method::slot(reflected);
 457   }
 458   Klass* k1 = java_lang_Class::as_Klass(mirror);
 459 
 460   // Make sure class is initialized before handing id&#39;s out to methods
 461   k1-&gt;initialize(CHECK_NULL);
 462   Method* m = InstanceKlass::cast(k1)-&gt;method_with_idnum(slot);
 463   ret = m==NULL? NULL : m-&gt;jmethod_id();  // return NULL if reflected method deleted
 464   return ret;
 465 JNI_END
 466 
 467 DT_RETURN_MARK_DECL(FromReflectedField, jfieldID
 468                     , HOTSPOT_JNI_FROMREFLECTEDFIELD_RETURN((uintptr_t)_ret_ref));
 469 
 470 JNI_ENTRY(jfieldID, jni_FromReflectedField(JNIEnv *env, jobject field))
 471   JNIWrapper(&quot;FromReflectedField&quot;);
 472 
 473   HOTSPOT_JNI_FROMREFLECTEDFIELD_ENTRY(env, field);
 474 
 475   jfieldID ret = NULL;
 476   DT_RETURN_MARK(FromReflectedField, jfieldID, (const jfieldID&amp;)ret);
 477 
 478   // field is a handle to a java.lang.reflect.Field object
 479   oop reflected   = JNIHandles::resolve_non_null(field);
 480   oop mirror      = java_lang_reflect_Field::clazz(reflected);
 481   Klass* k1       = java_lang_Class::as_Klass(mirror);
 482   int slot        = java_lang_reflect_Field::slot(reflected);
 483   int modifiers   = java_lang_reflect_Field::modifiers(reflected);
 484 
 485   // Make sure class is initialized before handing id&#39;s out to fields
 486   k1-&gt;initialize(CHECK_NULL);
 487 
 488   // First check if this is a static field
 489   if (modifiers &amp; JVM_ACC_STATIC) {
 490     intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 491     JNIid* id = InstanceKlass::cast(k1)-&gt;jni_id_for(offset);
 492     assert(id != NULL, &quot;corrupt Field object&quot;);
 493     debug_only(id-&gt;set_is_static_field_id();)
 494     // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
 495     ret = jfieldIDWorkaround::to_static_jfieldID(id);
 496     return ret;
 497   }
 498 
 499   // The slot is the index of the field description in the field-array
 500   // The jfieldID is the offset of the field within the object
 501   // It may also have hash bits for k, if VerifyJNIFields is turned on.
 502   intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 503   bool is_flattened = InstanceKlass::cast(k1)-&gt;field_is_flattened(slot);
 504   assert(InstanceKlass::cast(k1)-&gt;contains_field_offset(offset), &quot;stay within object&quot;);
 505   ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset, is_flattened);
 506   return ret;
 507 JNI_END
 508 
 509 
 510 DT_RETURN_MARK_DECL(ToReflectedMethod, jobject
 511                     , HOTSPOT_JNI_TOREFLECTEDMETHOD_RETURN(_ret_ref));
 512 
 513 JNI_ENTRY(jobject, jni_ToReflectedMethod(JNIEnv *env, jclass cls, jmethodID method_id, jboolean isStatic))
 514   JNIWrapper(&quot;ToReflectedMethod&quot;);
 515 
 516   HOTSPOT_JNI_TOREFLECTEDMETHOD_ENTRY(env, cls, (uintptr_t) method_id, isStatic);
 517 
 518   jobject ret = NULL;
 519   DT_RETURN_MARK(ToReflectedMethod, jobject, (const jobject&amp;)ret);
 520 
 521   methodHandle m (THREAD, Method::resolve_jmethod_id(method_id));
 522   assert(m-&gt;is_static() == (isStatic != 0), &quot;jni_ToReflectedMethod access flags doesn&#39;t match&quot;);
 523   oop reflection_method;
 524   if (m-&gt;is_object_constructor()) {
 525     reflection_method = Reflection::new_constructor(m, CHECK_NULL);
 526   } else {
 527     reflection_method = Reflection::new_method(m, false, CHECK_NULL);
 528   }
 529   ret = JNIHandles::make_local(env, reflection_method);
 530   return ret;
 531 JNI_END
 532 
 533 DT_RETURN_MARK_DECL(GetSuperclass, jclass
 534                     , HOTSPOT_JNI_GETSUPERCLASS_RETURN(_ret_ref));
 535 
 536 JNI_ENTRY(jclass, jni_GetSuperclass(JNIEnv *env, jclass sub))
 537   JNIWrapper(&quot;GetSuperclass&quot;);
 538 
 539   HOTSPOT_JNI_GETSUPERCLASS_ENTRY(env, sub);
 540 
 541   jclass obj = NULL;
 542   DT_RETURN_MARK(GetSuperclass, jclass, (const jclass&amp;)obj);
 543 
 544   oop mirror = JNIHandles::resolve_non_null(sub);
 545   // primitive classes return NULL
 546   if (java_lang_Class::is_primitive(mirror)) return NULL;
 547 
 548   // Rules of Class.getSuperClass as implemented by KLass::java_super:
 549   // arrays return Object
 550   // interfaces return NULL
 551   // proper classes return Klass::super()
 552   Klass* k = java_lang_Class::as_Klass(mirror);
 553   if (k-&gt;is_interface()) return NULL;
 554 
 555   // return mirror for superclass
 556   Klass* super = k-&gt;java_super();
 557   // super2 is the value computed by the compiler&#39;s getSuperClass intrinsic:
 558   debug_only(Klass* super2 = ( k-&gt;is_array_klass()
 559                                  ? SystemDictionary::Object_klass()
 560                                  : k-&gt;super() ) );
 561   assert(super == super2,
 562          &quot;java_super computation depends on interface, array, other super&quot;);
 563   obj = (super == NULL) ? NULL : (jclass) JNIHandles::make_local(super-&gt;java_mirror());
 564   return obj;
 565 JNI_END
 566 
 567 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))
 568   JNIWrapper(&quot;IsSubclassOf&quot;);
 569 
 570   HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(env, sub, super);
 571 
 572   oop sub_mirror   = JNIHandles::resolve_non_null(sub);
 573   oop super_mirror = JNIHandles::resolve_non_null(super);
 574   if (java_lang_Class::is_primitive(sub_mirror) ||
 575       java_lang_Class::is_primitive(super_mirror)) {
 576     jboolean ret = (sub_mirror == super_mirror);
 577 
 578     HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 579     return ret;
 580   }
 581   Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
 582   Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
 583   assert(sub_klass != NULL &amp;&amp; super_klass != NULL, &quot;invalid arguments to jni_IsAssignableFrom&quot;);
 584   jboolean ret = sub_klass-&gt;is_subtype_of(super_klass) ?
 585                    JNI_TRUE : JNI_FALSE;
 586   HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 587   return ret;
 588 JNI_END
 589 
 590 
 591 DT_RETURN_MARK_DECL(Throw, jint
 592                     , HOTSPOT_JNI_THROW_RETURN(_ret_ref));
 593 
 594 JNI_ENTRY(jint, jni_Throw(JNIEnv *env, jthrowable obj))
 595   JNIWrapper(&quot;Throw&quot;);
 596 
 597   HOTSPOT_JNI_THROW_ENTRY(env, obj);
 598 
 599   jint ret = JNI_OK;
 600   DT_RETURN_MARK(Throw, jint, (const jint&amp;)ret);
 601 
 602   THROW_OOP_(JNIHandles::resolve(obj), JNI_OK);
 603   ShouldNotReachHere();
 604   return 0;  // Mute compiler.
 605 JNI_END
 606 
 607 
 608 DT_RETURN_MARK_DECL(ThrowNew, jint
 609                     , HOTSPOT_JNI_THROWNEW_RETURN(_ret_ref));
 610 
 611 JNI_ENTRY(jint, jni_ThrowNew(JNIEnv *env, jclass clazz, const char *message))
 612   JNIWrapper(&quot;ThrowNew&quot;);
 613 
 614   HOTSPOT_JNI_THROWNEW_ENTRY(env, clazz, (char *) message);
 615 
 616   jint ret = JNI_OK;
 617   DT_RETURN_MARK(ThrowNew, jint, (const jint&amp;)ret);
 618 
 619   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
 620   Symbol*  name = k-&gt;name();
 621   Handle class_loader (THREAD,  k-&gt;class_loader());
 622   Handle protection_domain (THREAD, k-&gt;protection_domain());
 623   THROW_MSG_LOADER_(name, (char *)message, class_loader, protection_domain, JNI_OK);
 624   ShouldNotReachHere();
 625   return 0;  // Mute compiler.
 626 JNI_END
 627 
 628 
 629 // JNI functions only transform a pending async exception to a synchronous
 630 // exception in ExceptionOccurred and ExceptionCheck calls, since
 631 // delivering an async exception in other places won&#39;t change the native
 632 // code&#39;s control flow and would be harmful when native code further calls
 633 // JNI functions with a pending exception. Async exception is also checked
 634 // during the call, so ExceptionOccurred/ExceptionCheck won&#39;t return
 635 // false but deliver the async exception at the very end during
 636 // state transition.
 637 
 638 static void jni_check_async_exceptions(JavaThread *thread) {
 639   assert(thread == Thread::current(), &quot;must be itself&quot;);
 640   thread-&gt;check_and_handle_async_exceptions();
 641 }
 642 
 643 JNI_ENTRY_NO_PRESERVE(jthrowable, jni_ExceptionOccurred(JNIEnv *env))
 644   JNIWrapper(&quot;ExceptionOccurred&quot;);
 645 
 646   HOTSPOT_JNI_EXCEPTIONOCCURRED_ENTRY(env);
 647 
 648   jni_check_async_exceptions(thread);
 649   oop exception = thread-&gt;pending_exception();
 650   jthrowable ret = (jthrowable) JNIHandles::make_local(env, exception);
 651 
 652   HOTSPOT_JNI_EXCEPTIONOCCURRED_RETURN(ret);
 653   return ret;
 654 JNI_END
 655 
 656 
 657 JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionDescribe(JNIEnv *env))
 658   JNIWrapper(&quot;ExceptionDescribe&quot;);
 659 
 660   HOTSPOT_JNI_EXCEPTIONDESCRIBE_ENTRY(env);
 661 
 662   if (thread-&gt;has_pending_exception()) {
 663     Handle ex(thread, thread-&gt;pending_exception());
 664     thread-&gt;clear_pending_exception();
 665     if (ex-&gt;is_a(SystemDictionary::ThreadDeath_klass())) {
 666       // Don&#39;t print anything if we are being killed.
 667     } else {
 668       jio_fprintf(defaultStream::error_stream(), &quot;Exception &quot;);
 669       if (thread != NULL &amp;&amp; thread-&gt;threadObj() != NULL) {
 670         ResourceMark rm(THREAD);
 671         jio_fprintf(defaultStream::error_stream(),
 672         &quot;in thread \&quot;%s\&quot; &quot;, thread-&gt;get_thread_name());
 673       }
 674       if (ex-&gt;is_a(SystemDictionary::Throwable_klass())) {
 675         JavaValue result(T_VOID);
 676         JavaCalls::call_virtual(&amp;result,
 677                                 ex,
 678                                 SystemDictionary::Throwable_klass(),
 679                                 vmSymbols::printStackTrace_name(),
 680                                 vmSymbols::void_method_signature(),
 681                                 THREAD);
 682         // If an exception is thrown in the call it gets thrown away. Not much
 683         // we can do with it. The native code that calls this, does not check
 684         // for the exception - hence, it might still be in the thread when DestroyVM gets
 685         // called, potentially causing a few asserts to trigger - since no pending exception
 686         // is expected.
 687         CLEAR_PENDING_EXCEPTION;
 688       } else {
 689         ResourceMark rm(THREAD);
 690         jio_fprintf(defaultStream::error_stream(),
 691         &quot;. Uncaught exception of type %s.&quot;,
 692         ex-&gt;klass()-&gt;external_name());
 693       }
 694     }
 695   }
 696 
 697   HOTSPOT_JNI_EXCEPTIONDESCRIBE_RETURN();
 698 JNI_END
 699 
 700 
 701 JNI_ENTRY_NO_PRESERVE(void, jni_ExceptionClear(JNIEnv *env))
 702   JNIWrapper(&quot;ExceptionClear&quot;);
 703 
 704   HOTSPOT_JNI_EXCEPTIONCLEAR_ENTRY(env);
 705 
 706   // The jni code might be using this API to clear java thrown exception.
 707   // So just mark jvmti thread exception state as exception caught.
 708   JvmtiThreadState *state = JavaThread::current()-&gt;jvmti_thread_state();
 709   if (state != NULL &amp;&amp; state-&gt;is_exception_detected()) {
 710     state-&gt;set_exception_caught();
 711   }
 712   thread-&gt;clear_pending_exception();
 713 
 714   HOTSPOT_JNI_EXCEPTIONCLEAR_RETURN();
 715 JNI_END
 716 
 717 
 718 JNI_ENTRY(void, jni_FatalError(JNIEnv *env, const char *msg))
 719   JNIWrapper(&quot;FatalError&quot;);
 720 
 721   HOTSPOT_JNI_FATALERROR_ENTRY(env, (char *) msg);
 722 
 723   tty-&gt;print_cr(&quot;FATAL ERROR in native method: %s&quot;, msg);
 724   thread-&gt;print_stack();
 725   os::abort(); // Dump core and abort
 726 JNI_END
 727 
 728 
 729 JNI_ENTRY(jint, jni_PushLocalFrame(JNIEnv *env, jint capacity))
 730   JNIWrapper(&quot;PushLocalFrame&quot;);
 731 
 732   HOTSPOT_JNI_PUSHLOCALFRAME_ENTRY(env, capacity);
 733 
 734   //%note jni_11
 735   if (capacity &lt; 0 ||
 736       ((MaxJNILocalCapacity &gt; 0) &amp;&amp; (capacity &gt; MaxJNILocalCapacity))) {
 737     HOTSPOT_JNI_PUSHLOCALFRAME_RETURN((uint32_t)JNI_ERR);
 738     return JNI_ERR;
 739   }
 740   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 741   JNIHandleBlock* new_handles = JNIHandleBlock::allocate_block(thread);
 742   assert(new_handles != NULL, &quot;should not be NULL&quot;);
 743   new_handles-&gt;set_pop_frame_link(old_handles);
 744   thread-&gt;set_active_handles(new_handles);
 745   jint ret = JNI_OK;
 746   HOTSPOT_JNI_PUSHLOCALFRAME_RETURN(ret);
 747   return ret;
 748 JNI_END
 749 
 750 
 751 JNI_ENTRY(jobject, jni_PopLocalFrame(JNIEnv *env, jobject result))
 752   JNIWrapper(&quot;PopLocalFrame&quot;);
 753 
 754   HOTSPOT_JNI_POPLOCALFRAME_ENTRY(env, result);
 755 
 756   //%note jni_11
 757   Handle result_handle(thread, JNIHandles::resolve(result));
 758   JNIHandleBlock* old_handles = thread-&gt;active_handles();
 759   JNIHandleBlock* new_handles = old_handles-&gt;pop_frame_link();
 760   if (new_handles != NULL) {
 761     // As a sanity check we only release the handle blocks if the pop_frame_link is not NULL.
 762     // This way code will still work if PopLocalFrame is called without a corresponding
 763     // PushLocalFrame call. Note that we set the pop_frame_link to NULL explicitly, otherwise
 764     // the release_block call will release the blocks.
 765     thread-&gt;set_active_handles(new_handles);
 766     old_handles-&gt;set_pop_frame_link(NULL);              // clear link we won&#39;t release new_handles below
 767     JNIHandleBlock::release_block(old_handles, thread); // may block
 768     result = JNIHandles::make_local(thread, result_handle());
 769   }
 770   HOTSPOT_JNI_POPLOCALFRAME_RETURN(result);
 771   return result;
 772 JNI_END
 773 
 774 
 775 JNI_ENTRY(jobject, jni_NewGlobalRef(JNIEnv *env, jobject ref))
 776   JNIWrapper(&quot;NewGlobalRef&quot;);
 777 
 778   HOTSPOT_JNI_NEWGLOBALREF_ENTRY(env, ref);
 779 
 780   Handle ref_handle(thread, JNIHandles::resolve(ref));
 781   jobject ret = JNIHandles::make_global(ref_handle);
 782 
 783   HOTSPOT_JNI_NEWGLOBALREF_RETURN(ret);
 784   return ret;
 785 JNI_END
 786 
 787 // Must be JNI_ENTRY (with HandleMark)
 788 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteGlobalRef(JNIEnv *env, jobject ref))
 789   JNIWrapper(&quot;DeleteGlobalRef&quot;);
 790 
 791   HOTSPOT_JNI_DELETEGLOBALREF_ENTRY(env, ref);
 792 
 793   JNIHandles::destroy_global(ref);
 794 
 795   HOTSPOT_JNI_DELETEGLOBALREF_RETURN();
 796 JNI_END
 797 
 798 JNI_ENTRY_NO_PRESERVE(void, jni_DeleteLocalRef(JNIEnv *env, jobject obj))
 799   JNIWrapper(&quot;DeleteLocalRef&quot;);
 800 
 801   HOTSPOT_JNI_DELETELOCALREF_ENTRY(env, obj);
 802 
 803   JNIHandles::destroy_local(obj);
 804 
 805   HOTSPOT_JNI_DELETELOCALREF_RETURN();
 806 JNI_END
 807 
 808 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsSameObject(JNIEnv *env, jobject r1, jobject r2))
 809   JNIWrapper(&quot;IsSameObject&quot;);
 810 
 811   HOTSPOT_JNI_ISSAMEOBJECT_ENTRY(env, r1, r2);
 812 
 813   jboolean ret = JNIHandles::is_same_object(r1, r2) ? JNI_TRUE : JNI_FALSE;
 814 
 815   HOTSPOT_JNI_ISSAMEOBJECT_RETURN(ret);
 816   return ret;
 817 JNI_END
 818 
 819 
 820 JNI_ENTRY(jobject, jni_NewLocalRef(JNIEnv *env, jobject ref))
 821   JNIWrapper(&quot;NewLocalRef&quot;);
 822 
 823   HOTSPOT_JNI_NEWLOCALREF_ENTRY(env, ref);
 824 
 825   jobject ret = JNIHandles::make_local(env, JNIHandles::resolve(ref));
 826 
 827   HOTSPOT_JNI_NEWLOCALREF_RETURN(ret);
 828   return ret;
 829 JNI_END
 830 
 831 JNI_LEAF(jint, jni_EnsureLocalCapacity(JNIEnv *env, jint capacity))
 832   JNIWrapper(&quot;EnsureLocalCapacity&quot;);
 833 
 834   HOTSPOT_JNI_ENSURELOCALCAPACITY_ENTRY(env, capacity);
 835 
 836   jint ret;
 837   if (capacity &gt;= 0 &amp;&amp;
 838       ((MaxJNILocalCapacity &lt;= 0) || (capacity &lt;= MaxJNILocalCapacity))) {
 839     ret = JNI_OK;
 840   } else {
 841     ret = JNI_ERR;
 842   }
 843 
 844   HOTSPOT_JNI_ENSURELOCALCAPACITY_RETURN(ret);
 845   return ret;
 846 JNI_END
 847 
 848 // Return the Handle Type
 849 JNI_LEAF(jobjectRefType, jni_GetObjectRefType(JNIEnv *env, jobject obj))
 850   JNIWrapper(&quot;GetObjectRefType&quot;);
 851 
 852   HOTSPOT_JNI_GETOBJECTREFTYPE_ENTRY(env, obj);
 853 
 854   jobjectRefType ret = JNIInvalidRefType;
 855   if (obj != NULL) {
 856     ret = JNIHandles::handle_type(thread, obj);
 857   }
 858 
 859   HOTSPOT_JNI_GETOBJECTREFTYPE_RETURN((void *) ret);
 860   return ret;
 861 JNI_END
 862 
 863 
 864 class JNI_ArgumentPusher : public SignatureIterator {
 865  protected:
 866   JavaCallArguments*  _arguments;
 867 
 868   void push_int(jint x)         { _arguments-&gt;push_int(x); }
 869   void push_long(jlong x)       { _arguments-&gt;push_long(x); }
 870   void push_float(jfloat x)     { _arguments-&gt;push_float(x); }
 871   void push_double(jdouble x)   { _arguments-&gt;push_double(x); }
 872   void push_object(jobject x)   { _arguments-&gt;push_jobject(x); }
 873 
 874   void push_boolean(jboolean b) {
 875     // Normalize boolean arguments from native code by converting 1-255 to JNI_TRUE and
 876     // 0 to JNI_FALSE.  Boolean return values from native are normalized the same in
 877     // TemplateInterpreterGenerator::generate_result_handler_for and
 878     // SharedRuntime::generate_native_wrapper.
 879     push_int(b == 0 ? JNI_FALSE : JNI_TRUE);
 880   }
 881 
 882   JNI_ArgumentPusher(Method* method)
 883     : SignatureIterator(method-&gt;signature(),
 884                         Fingerprinter(methodHandle(Thread::current(), method)).fingerprint())
 885   {
 886     _arguments = NULL;
 887   }
 888 
 889  public:
 890   virtual void push_arguments_on(JavaCallArguments* arguments) = 0;
 891 };
 892 
 893 
 894 class JNI_ArgumentPusherVaArg : public JNI_ArgumentPusher {
 895  protected:
 896   va_list _ap;
 897 
 898   void set_ap(va_list rap) {
 899     va_copy(_ap, rap);
 900   }
 901 
 902   friend class SignatureIterator;  // so do_parameters_on can call do_type
 903   void do_type(BasicType type) {
 904     switch (type) {
 905     // these are coerced to int when using va_arg
 906     case T_BYTE:
 907     case T_CHAR:
 908     case T_SHORT:
 909     case T_INT:         push_int(va_arg(_ap, jint)); break;
 910     case T_BOOLEAN:     push_boolean((jboolean) va_arg(_ap, jint)); break;
 911 
 912     // each of these paths is exercised by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests
 913 
 914     case T_LONG:        push_long(va_arg(_ap, jlong)); break;
 915     // float is coerced to double w/ va_arg
 916     case T_FLOAT:       push_float((jfloat) va_arg(_ap, jdouble)); break;
 917     case T_DOUBLE:      push_double(va_arg(_ap, jdouble)); break;
 918 
 919     case T_ARRAY:
 920     case T_OBJECT:
 921     case T_VALUETYPE:   push_object(va_arg(_ap, jobject)); break;
 922     default:            ShouldNotReachHere();
 923     }
 924   }
 925 
 926  public:
 927   JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
 928       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
 929     set_ap(rap);
 930   }
 931 
 932   virtual void push_arguments_on(JavaCallArguments* arguments) {
 933     _arguments = arguments;
 934     do_parameters_on(this);
 935   }
 936 };
 937 
 938 
 939 class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
 940  protected:
 941   const jvalue *_ap;
 942 
 943   inline void set_ap(const jvalue *rap) { _ap = rap; }
 944 
 945   friend class SignatureIterator;  // so do_parameters_on can call do_type
 946   void do_type(BasicType type) {
 947     switch (type) {
 948     case T_CHAR:        push_int((_ap++)-&gt;c); break;
 949     case T_SHORT:       push_int((_ap++)-&gt;s); break;
 950     case T_BYTE:        push_int((_ap++)-&gt;b); break;
 951     case T_INT:         push_int((_ap++)-&gt;i); break;
 952     case T_BOOLEAN:     push_boolean((_ap++)-&gt;z); break;
 953     case T_LONG:        push_long((_ap++)-&gt;j); break;
 954     case T_FLOAT:       push_float((_ap++)-&gt;f); break;
 955     case T_DOUBLE:      push_double((_ap++)-&gt;d); break;
 956     case T_ARRAY:
 957     case T_OBJECT:
 958     case T_VALUETYPE:   push_object((_ap++)-&gt;l); break;
 959     default:            ShouldNotReachHere();
 960     }
 961   }
 962 
 963  public:
 964   JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
 965       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
 966     set_ap(rap);
 967   }
 968 
 969   virtual void push_arguments_on(JavaCallArguments* arguments) {
 970     _arguments = arguments;
 971     do_parameters_on(this);
 972   }
 973 };
 974 
 975 
 976 enum JNICallType {
 977   JNI_STATIC,
 978   JNI_VIRTUAL,
 979   JNI_NONVIRTUAL
 980 };
 981 
 982 
 983 
 984 static void jni_invoke_static(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
 985   methodHandle method(THREAD, Method::resolve_jmethod_id(method_id));
 986 
 987   // Create object to hold arguments for the JavaCall, and associate it with
 988   // the jni parser
 989   ResourceMark rm(THREAD);
 990   int number_of_parameters = method-&gt;size_of_parameters();
 991   JavaCallArguments java_args(number_of_parameters);
 992 
 993   assert(method-&gt;is_static(), &quot;method should be static&quot;);
 994 
 995   // Fill out JavaCallArguments object
 996   args-&gt;push_arguments_on(&amp;java_args);
 997   // Initialize result type
 998   result-&gt;set_type(args-&gt;return_type());
 999 
1000   // Invoke the method. Result is returned as oop.
1001   JavaCalls::call(result, method, &amp;java_args, CHECK);
1002 
1003   // Convert result
1004   if (is_reference_type(result-&gt;get_type())) {
1005     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1006   }
1007 }
1008 
1009 
1010 static void jni_invoke_nonstatic(JNIEnv *env, JavaValue* result, jobject receiver, JNICallType call_type, jmethodID method_id, JNI_ArgumentPusher *args, TRAPS) {
1011   oop recv = JNIHandles::resolve(receiver);
1012   if (recv == NULL) {
1013     THROW(vmSymbols::java_lang_NullPointerException());
1014   }
1015   Handle h_recv(THREAD, recv);
1016 
1017   int number_of_parameters;
1018   Method* selected_method;
1019   {
1020     Method* m = Method::resolve_jmethod_id(method_id);
1021     number_of_parameters = m-&gt;size_of_parameters();
1022     Klass* holder = m-&gt;method_holder();
1023     if (call_type != JNI_VIRTUAL) {
1024         selected_method = m;
1025     } else if (!m-&gt;has_itable_index()) {
1026       // non-interface call -- for that little speed boost, don&#39;t handlize
1027       debug_only(NoSafepointVerifier nosafepoint;)
1028       // jni_GetMethodID makes sure class is linked and initialized
1029       // so m should have a valid vtable index.
1030       assert(m-&gt;valid_vtable_index(), &quot;no valid vtable index&quot;);
1031       int vtbl_index = m-&gt;vtable_index();
1032       if (vtbl_index != Method::nonvirtual_vtable_index) {
1033         selected_method = h_recv-&gt;klass()-&gt;method_at_vtable(vtbl_index);
1034       } else {
1035         // final method
1036         selected_method = m;
1037       }
1038     } else {
1039       // interface call
1040       int itbl_index = m-&gt;itable_index();
1041       Klass* k = h_recv-&gt;klass();
1042       selected_method = InstanceKlass::cast(k)-&gt;method_at_itable(holder, itbl_index, CHECK);
1043     }
1044   }
1045 
1046   methodHandle method(THREAD, selected_method);
1047 
1048   // Create object to hold arguments for the JavaCall, and associate it with
1049   // the jni parser
1050   ResourceMark rm(THREAD);
1051   JavaCallArguments java_args(number_of_parameters);
1052 
1053   // handle arguments
1054   assert(!method-&gt;is_static(), &quot;method %s should not be static&quot;, method-&gt;name_and_sig_as_C_string());
1055   java_args.push_oop(h_recv); // Push jobject handle
1056 
1057   // Fill out JavaCallArguments object
1058   args-&gt;push_arguments_on(&amp;java_args);
1059   // Initialize result type
1060   result-&gt;set_type(args-&gt;return_type());
1061 
1062   // Invoke the method. Result is returned as oop.
1063   JavaCalls::call(result, method, &amp;java_args, CHECK);
1064 
1065   // Convert result
1066   if (is_reference_type(result-&gt;get_type())) {
1067     result-&gt;set_jobject(JNIHandles::make_local(env, (oop) result-&gt;get_jobject()));
1068   }
1069 }
1070 
1071 DT_RETURN_MARK_DECL(AllocObject, jobject
1072                     , HOTSPOT_JNI_ALLOCOBJECT_RETURN(_ret_ref));
1073 
1074 JNI_ENTRY(jobject, jni_AllocObject(JNIEnv *env, jclass clazz))
1075   JNIWrapper(&quot;AllocObject&quot;);
1076 
1077   HOTSPOT_JNI_ALLOCOBJECT_ENTRY(env, clazz);
1078 
1079   jobject ret = NULL;
1080   DT_RETURN_MARK(AllocObject, jobject, (const jobject&amp;)ret);
1081 
1082   instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);
1083   ret = JNIHandles::make_local(env, i);
1084   return ret;
1085 JNI_END
1086 
1087 DT_RETURN_MARK_DECL(NewObjectA, jobject
1088                     , HOTSPOT_JNI_NEWOBJECTA_RETURN(_ret_ref));
1089 
1090 JNI_ENTRY(jobject, jni_NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args))
1091   JNIWrapper(&quot;NewObjectA&quot;);
1092 
1093   HOTSPOT_JNI_NEWOBJECTA_ENTRY(env, clazz, (uintptr_t) methodID);
1094 
1095   jobject obj = NULL;
1096   DT_RETURN_MARK(NewObjectA, jobject, (const jobject)obj);
1097 
1098   oop clazzoop = JNIHandles::resolve_non_null(clazz);
1099   Klass* k = java_lang_Class::as_Klass(clazzoop);
1100   if (k == NULL) {
1101     ResourceMark rm(THREAD);
1102     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1103   }
1104 
1105   if (!k-&gt;is_value()) {
1106     instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);
1107     obj = JNIHandles::make_local(env, i);
1108     JavaValue jvalue(T_VOID);
1109     JNI_ArgumentPusherArray ap(methodID, args);
1110     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1111   } else {
1112     JavaValue jvalue(T_VALUETYPE);
1113     JNI_ArgumentPusherArray ap(methodID, args);
1114     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);
1115     obj = jvalue.get_jobject();
1116   }
1117   return obj;
1118   JNI_END
1119 
1120 
1121 DT_RETURN_MARK_DECL(NewObjectV, jobject
1122                     , HOTSPOT_JNI_NEWOBJECTV_RETURN(_ret_ref));
1123 
1124 JNI_ENTRY(jobject, jni_NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args))
1125   JNIWrapper(&quot;NewObjectV&quot;);
1126 
1127   HOTSPOT_JNI_NEWOBJECTV_ENTRY(env, clazz, (uintptr_t) methodID);
1128 
1129   jobject obj = NULL;
1130   DT_RETURN_MARK(NewObjectV, jobject, (const jobject&amp;)obj);
1131 
1132   oop clazzoop = JNIHandles::resolve_non_null(clazz);
1133   Klass* k = java_lang_Class::as_Klass(clazzoop);
1134   if (k == NULL) {
1135     ResourceMark rm(THREAD);
1136     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1137   }
1138 
1139   if (!k-&gt;is_value()) {
1140     instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);
1141     obj = JNIHandles::make_local(env, i);
1142     JavaValue jvalue(T_VOID);
1143     JNI_ArgumentPusherVaArg ap(methodID, args);
1144     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1145   } else {
1146     JavaValue jvalue(T_VALUETYPE);
1147     JNI_ArgumentPusherVaArg ap(methodID, args);
1148     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);
1149     obj = jvalue.get_jobject();
1150   }
1151   return obj;
1152 JNI_END
1153 
1154 
1155 DT_RETURN_MARK_DECL(NewObject, jobject
1156                     , HOTSPOT_JNI_NEWOBJECT_RETURN(_ret_ref));
1157 
1158 JNI_ENTRY(jobject, jni_NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...))
1159   JNIWrapper(&quot;NewObject&quot;);
1160 
1161   HOTSPOT_JNI_NEWOBJECT_ENTRY(env, clazz, (uintptr_t) methodID);
1162 
1163   jobject obj = NULL;
1164   DT_RETURN_MARK(NewObject, jobject, (const jobject&amp;)obj);
1165 
1166   oop clazzoop = JNIHandles::resolve_non_null(clazz);
1167   Klass* k = java_lang_Class::as_Klass(clazzoop);
1168   if (k == NULL) {
1169     ResourceMark rm(THREAD);
1170     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);
1171   }
1172 
1173   if (!k-&gt;is_value()) {
1174     instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);
1175     obj = JNIHandles::make_local(env, i);
1176     va_list args;
1177     va_start(args, methodID);
1178     JavaValue jvalue(T_VOID);
1179     JNI_ArgumentPusherVaArg ap(methodID, args);
1180     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);
1181     va_end(args);
1182   } else {
1183     va_list args;
1184     va_start(args, methodID);
1185     JavaValue jvalue(T_VALUETYPE);
1186     JNI_ArgumentPusherVaArg ap(methodID, args);
1187     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);
1188     va_end(args);
1189     obj = jvalue.get_jobject();
1190   }
1191   return obj;
1192 JNI_END
1193 
1194 
1195 JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
1196   JNIWrapper(&quot;GetObjectClass&quot;);
1197 
1198   HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(env, obj);
1199 
1200   Klass* k = JNIHandles::resolve_non_null(obj)-&gt;klass();
1201   jclass ret =
1202     (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1203 
1204   HOTSPOT_JNI_GETOBJECTCLASS_RETURN(ret);
1205   return ret;
1206 JNI_END
1207 
1208 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))
1209   JNIWrapper(&quot;IsInstanceOf&quot;);
1210 
1211   HOTSPOT_JNI_ISINSTANCEOF_ENTRY(env, obj, clazz);
1212 
1213   jboolean ret = JNI_TRUE;
1214   if (obj != NULL) {
1215     ret = JNI_FALSE;
1216     Klass* k = java_lang_Class::as_Klass(
1217       JNIHandles::resolve_non_null(clazz));
1218     if (k != NULL) {
1219       ret = JNIHandles::resolve_non_null(obj)-&gt;is_a(k) ? JNI_TRUE : JNI_FALSE;
1220     }
1221   }
1222 
1223   HOTSPOT_JNI_ISINSTANCEOF_RETURN(ret);
1224   return ret;
1225 JNI_END
1226 
1227 
1228 static jmethodID get_method_id(JNIEnv *env, jclass clazz, const char *name_str,
1229                                const char *sig, bool is_static, TRAPS) {
1230   // %%%% This code should probably just call into a method in the LinkResolver
1231   //
1232   // The class should have been loaded (we have an instance of the class
1233   // passed in) so the method and signature should already be in the symbol
1234   // table.  If they&#39;re not there, the method doesn&#39;t exist.
1235   const char *name_to_probe = (name_str == NULL)
1236                         ? vmSymbols::object_initializer_name()-&gt;as_C_string()
1237                         : name_str;
1238   TempNewSymbol name = SymbolTable::probe(name_to_probe, (int)strlen(name_to_probe));
1239   TempNewSymbol signature = SymbolTable::probe(sig, (int)strlen(sig));
1240 
1241   if (name == NULL || signature == NULL) {
1242     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), name_str);
1243   }
1244 
1245   Klass* klass = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1246 
1247   // Throw a NoSuchMethodError exception if we have an instance of a
1248   // primitive java.lang.Class
1249   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(clazz))) {
1250     ResourceMark rm;
1251     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg(&quot;%s%s.%s%s&quot;, is_static ? &quot;static &quot; : &quot;&quot;, klass-&gt;signature_name(), name_str, sig));
1252   }
1253 
1254   // Make sure class is linked and initialized before handing id&#39;s out to
1255   // Method*s.
1256   klass-&gt;initialize(CHECK_NULL);
1257 
1258   Method* m;
1259   if (name == vmSymbols::object_initializer_name() ||
1260       name == vmSymbols::class_initializer_name()) {
1261     // Never search superclasses for constructors
1262     if (klass-&gt;is_instance_klass()) {
1263       m = InstanceKlass::cast(klass)-&gt;find_method(name, signature);
1264     } else {
1265       m = NULL;
1266     }
1267   } else {
1268     m = klass-&gt;lookup_method(name, signature);
1269     if (m == NULL &amp;&amp;  klass-&gt;is_instance_klass()) {
1270       m = InstanceKlass::cast(klass)-&gt;lookup_method_in_ordered_interfaces(name, signature);
1271     }
1272   }
1273   if (m == NULL || (m-&gt;is_static() != is_static)) {
1274     ResourceMark rm;
1275     THROW_MSG_0(vmSymbols::java_lang_NoSuchMethodError(), err_msg(&quot;%s%s.%s%s&quot;, is_static ? &quot;static &quot; : &quot;&quot;, klass-&gt;signature_name(), name_str, sig));
1276   }
1277   return m-&gt;jmethod_id();
1278 }
1279 
1280 
1281 JNI_ENTRY(jmethodID, jni_GetMethodID(JNIEnv *env, jclass clazz,
1282           const char *name, const char *sig))
1283   JNIWrapper(&quot;GetMethodID&quot;);
1284   HOTSPOT_JNI_GETMETHODID_ENTRY(env, clazz, (char *) name, (char *) sig);
1285   jmethodID ret = get_method_id(env, clazz, name, sig, false, thread);
1286   HOTSPOT_JNI_GETMETHODID_RETURN((uintptr_t) ret);
1287   return ret;
1288 JNI_END
1289 
1290 
1291 JNI_ENTRY(jmethodID, jni_GetStaticMethodID(JNIEnv *env, jclass clazz,
1292           const char *name, const char *sig))
1293   JNIWrapper(&quot;GetStaticMethodID&quot;);
1294   HOTSPOT_JNI_GETSTATICMETHODID_ENTRY(env, (char *) clazz, (char *) name, (char *)sig);
1295   jmethodID ret = get_method_id(env, clazz, name, sig, true, thread);
1296   HOTSPOT_JNI_GETSTATICMETHODID_RETURN((uintptr_t) ret);
1297   return ret;
1298 JNI_END
1299 
1300 
1301 
1302 //
1303 // Calling Methods
1304 //
1305 
1306 
1307 #define DEFINE_CALLMETHOD(ResultType, Result, Tag \
1308                           , EntryProbe, ReturnProbe)    \
1309 \
1310   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##Method, ResultType \
1311                           , ReturnProbe);                          \
1312 \
1313 JNI_ENTRY(ResultType, \
1314           jni_Call##Result##Method(JNIEnv *env, jobject obj, jmethodID methodID, ...)) \
1315   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;Method&quot;); \
1316 \
1317   EntryProbe; \
1318   ResultType ret = 0;\
1319   DT_RETURN_MARK_FOR(Result, Call##Result##Method, ResultType, \
1320                      (const ResultType&amp;)ret);\
1321 \
1322   va_list args; \
1323   va_start(args, methodID); \
1324   JavaValue jvalue(Tag); \
1325   JNI_ArgumentPusherVaArg ap(methodID, args); \
1326   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1327   va_end(args); \
1328   ret = jvalue.get_##ResultType(); \
1329   return ret;\
1330 JNI_END
1331 
1332 // the runtime type of subword integral basic types is integer
1333 DEFINE_CALLMETHOD(jboolean, Boolean, T_BOOLEAN
1334                   , HOTSPOT_JNI_CALLBOOLEANMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1335                   HOTSPOT_JNI_CALLBOOLEANMETHOD_RETURN(_ret_ref))
1336 DEFINE_CALLMETHOD(jbyte,    Byte,    T_BYTE
1337                   , HOTSPOT_JNI_CALLBYTEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1338                   HOTSPOT_JNI_CALLBYTEMETHOD_RETURN(_ret_ref))
1339 DEFINE_CALLMETHOD(jchar,    Char,    T_CHAR
1340                   , HOTSPOT_JNI_CALLCHARMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1341                   HOTSPOT_JNI_CALLCHARMETHOD_RETURN(_ret_ref))
1342 DEFINE_CALLMETHOD(jshort,   Short,   T_SHORT
1343                   , HOTSPOT_JNI_CALLSHORTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1344                   HOTSPOT_JNI_CALLSHORTMETHOD_RETURN(_ret_ref))
1345 
1346 DEFINE_CALLMETHOD(jobject,  Object,  T_OBJECT
1347                   , HOTSPOT_JNI_CALLOBJECTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1348                   HOTSPOT_JNI_CALLOBJECTMETHOD_RETURN(_ret_ref))
1349 DEFINE_CALLMETHOD(jint,     Int,     T_INT,
1350                   HOTSPOT_JNI_CALLINTMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1351                   HOTSPOT_JNI_CALLINTMETHOD_RETURN(_ret_ref))
1352 DEFINE_CALLMETHOD(jlong,    Long,    T_LONG
1353                   , HOTSPOT_JNI_CALLLONGMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1354                   HOTSPOT_JNI_CALLLONGMETHOD_RETURN(_ret_ref))
1355 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1356 DEFINE_CALLMETHOD(jfloat,   Float,   T_FLOAT
1357                   , HOTSPOT_JNI_CALLFLOATMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1358                   HOTSPOT_JNI_CALLFLOATMETHOD_RETURN())
1359 DEFINE_CALLMETHOD(jdouble,  Double,  T_DOUBLE
1360                   , HOTSPOT_JNI_CALLDOUBLEMETHOD_ENTRY(env, obj, (uintptr_t)methodID),
1361                   HOTSPOT_JNI_CALLDOUBLEMETHOD_RETURN())
1362 
1363 #define DEFINE_CALLMETHODV(ResultType, Result, Tag \
1364                           , EntryProbe, ReturnProbe)    \
1365 \
1366   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodV, ResultType \
1367                           , ReturnProbe);                          \
1368 \
1369 JNI_ENTRY(ResultType, \
1370           jni_Call##Result##MethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args)) \
1371   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;MethodV&quot;); \
1372 \
1373   EntryProbe;\
1374   ResultType ret = 0;\
1375   DT_RETURN_MARK_FOR(Result, Call##Result##MethodV, ResultType, \
1376                      (const ResultType&amp;)ret);\
1377 \
1378   JavaValue jvalue(Tag); \
1379   JNI_ArgumentPusherVaArg ap(methodID, args); \
1380   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1381   ret = jvalue.get_##ResultType(); \
1382   return ret;\
1383 JNI_END
1384 
1385 // the runtime type of subword integral basic types is integer
1386 DEFINE_CALLMETHODV(jboolean, Boolean, T_BOOLEAN
1387                   , HOTSPOT_JNI_CALLBOOLEANMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1388                   HOTSPOT_JNI_CALLBOOLEANMETHODV_RETURN(_ret_ref))
1389 DEFINE_CALLMETHODV(jbyte,    Byte,    T_BYTE
1390                   , HOTSPOT_JNI_CALLBYTEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1391                   HOTSPOT_JNI_CALLBYTEMETHODV_RETURN(_ret_ref))
1392 DEFINE_CALLMETHODV(jchar,    Char,    T_CHAR
1393                   , HOTSPOT_JNI_CALLCHARMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1394                   HOTSPOT_JNI_CALLCHARMETHODV_RETURN(_ret_ref))
1395 DEFINE_CALLMETHODV(jshort,   Short,   T_SHORT
1396                   , HOTSPOT_JNI_CALLSHORTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1397                   HOTSPOT_JNI_CALLSHORTMETHODV_RETURN(_ret_ref))
1398 
1399 DEFINE_CALLMETHODV(jobject,  Object,  T_OBJECT
1400                   , HOTSPOT_JNI_CALLOBJECTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1401                   HOTSPOT_JNI_CALLOBJECTMETHODV_RETURN(_ret_ref))
1402 DEFINE_CALLMETHODV(jint,     Int,     T_INT,
1403                   HOTSPOT_JNI_CALLINTMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1404                   HOTSPOT_JNI_CALLINTMETHODV_RETURN(_ret_ref))
1405 DEFINE_CALLMETHODV(jlong,    Long,    T_LONG
1406                   , HOTSPOT_JNI_CALLLONGMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1407                   HOTSPOT_JNI_CALLLONGMETHODV_RETURN(_ret_ref))
1408 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1409 DEFINE_CALLMETHODV(jfloat,   Float,   T_FLOAT
1410                   , HOTSPOT_JNI_CALLFLOATMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1411                   HOTSPOT_JNI_CALLFLOATMETHODV_RETURN())
1412 DEFINE_CALLMETHODV(jdouble,  Double,  T_DOUBLE
1413                   , HOTSPOT_JNI_CALLDOUBLEMETHODV_ENTRY(env, obj, (uintptr_t)methodID),
1414                   HOTSPOT_JNI_CALLDOUBLEMETHODV_RETURN())
1415 
1416 #define DEFINE_CALLMETHODA(ResultType, Result, Tag \
1417                           , EntryProbe, ReturnProbe)    \
1418 \
1419   DT_RETURN_MARK_DECL_FOR(Result, Call##Result##MethodA, ResultType \
1420                           , ReturnProbe);                          \
1421 \
1422 JNI_ENTRY(ResultType, \
1423           jni_Call##Result##MethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args)) \
1424   JNIWrapper(&quot;Call&quot; XSTR(Result) &quot;MethodA&quot;); \
1425   EntryProbe; \
1426   ResultType ret = 0;\
1427   DT_RETURN_MARK_FOR(Result, Call##Result##MethodA, ResultType, \
1428                      (const ResultType&amp;)ret);\
1429 \
1430   JavaValue jvalue(Tag); \
1431   JNI_ArgumentPusherArray ap(methodID, args); \
1432   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK_0); \
1433   ret = jvalue.get_##ResultType(); \
1434   return ret;\
1435 JNI_END
1436 
1437 // the runtime type of subword integral basic types is integer
1438 DEFINE_CALLMETHODA(jboolean, Boolean, T_BOOLEAN
1439                   , HOTSPOT_JNI_CALLBOOLEANMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1440                   HOTSPOT_JNI_CALLBOOLEANMETHODA_RETURN(_ret_ref))
1441 DEFINE_CALLMETHODA(jbyte,    Byte,    T_BYTE
1442                   , HOTSPOT_JNI_CALLBYTEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1443                   HOTSPOT_JNI_CALLBYTEMETHODA_RETURN(_ret_ref))
1444 DEFINE_CALLMETHODA(jchar,    Char,    T_CHAR
1445                   , HOTSPOT_JNI_CALLCHARMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1446                   HOTSPOT_JNI_CALLCHARMETHODA_RETURN(_ret_ref))
1447 DEFINE_CALLMETHODA(jshort,   Short,   T_SHORT
1448                   , HOTSPOT_JNI_CALLSHORTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1449                   HOTSPOT_JNI_CALLSHORTMETHODA_RETURN(_ret_ref))
1450 
1451 DEFINE_CALLMETHODA(jobject,  Object,  T_OBJECT
1452                   , HOTSPOT_JNI_CALLOBJECTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1453                   HOTSPOT_JNI_CALLOBJECTMETHODA_RETURN(_ret_ref))
1454 DEFINE_CALLMETHODA(jint,     Int,     T_INT,
1455                   HOTSPOT_JNI_CALLINTMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1456                   HOTSPOT_JNI_CALLINTMETHODA_RETURN(_ret_ref))
1457 DEFINE_CALLMETHODA(jlong,    Long,    T_LONG
1458                   , HOTSPOT_JNI_CALLLONGMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1459                   HOTSPOT_JNI_CALLLONGMETHODA_RETURN(_ret_ref))
1460 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1461 DEFINE_CALLMETHODA(jfloat,   Float,   T_FLOAT
1462                   , HOTSPOT_JNI_CALLFLOATMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1463                   HOTSPOT_JNI_CALLFLOATMETHODA_RETURN())
1464 DEFINE_CALLMETHODA(jdouble,  Double,  T_DOUBLE
1465                   , HOTSPOT_JNI_CALLDOUBLEMETHODA_ENTRY(env, obj, (uintptr_t)methodID),
1466                   HOTSPOT_JNI_CALLDOUBLEMETHODA_RETURN())
1467 
1468 DT_VOID_RETURN_MARK_DECL(CallVoidMethod, HOTSPOT_JNI_CALLVOIDMETHOD_RETURN());
1469 DT_VOID_RETURN_MARK_DECL(CallVoidMethodV, HOTSPOT_JNI_CALLVOIDMETHODV_RETURN());
1470 DT_VOID_RETURN_MARK_DECL(CallVoidMethodA, HOTSPOT_JNI_CALLVOIDMETHODA_RETURN());
1471 
1472 
1473 JNI_ENTRY(void, jni_CallVoidMethod(JNIEnv *env, jobject obj, jmethodID methodID, ...))
1474   JNIWrapper(&quot;CallVoidMethod&quot;);
1475   HOTSPOT_JNI_CALLVOIDMETHOD_ENTRY(env, obj, (uintptr_t) methodID);
1476   DT_VOID_RETURN_MARK(CallVoidMethod);
1477 
1478   va_list args;
1479   va_start(args, methodID);
1480   JavaValue jvalue(T_VOID);
1481   JNI_ArgumentPusherVaArg ap(methodID, args);
1482   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1483   va_end(args);
1484 JNI_END
1485 
1486 
1487 JNI_ENTRY(void, jni_CallVoidMethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args))
1488   JNIWrapper(&quot;CallVoidMethodV&quot;);
1489   HOTSPOT_JNI_CALLVOIDMETHODV_ENTRY(env, obj, (uintptr_t) methodID);
1490   DT_VOID_RETURN_MARK(CallVoidMethodV);
1491 
1492   JavaValue jvalue(T_VOID);
1493   JNI_ArgumentPusherVaArg ap(methodID, args);
1494   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1495 JNI_END
1496 
1497 
1498 JNI_ENTRY(void, jni_CallVoidMethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args))
1499   JNIWrapper(&quot;CallVoidMethodA&quot;);
1500   HOTSPOT_JNI_CALLVOIDMETHODA_ENTRY(env, obj, (uintptr_t) methodID);
1501   DT_VOID_RETURN_MARK(CallVoidMethodA);
1502 
1503   JavaValue jvalue(T_VOID);
1504   JNI_ArgumentPusherArray ap(methodID, args);
1505   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_VIRTUAL, methodID, &amp;ap, CHECK);
1506 JNI_END
1507 
1508 
1509 
1510 #define DEFINE_CALLNONVIRTUALMETHOD(ResultType, Result, Tag \
1511                                     , EntryProbe, ReturnProbe)      \
1512 \
1513   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##Method, ResultType \
1514                           , ReturnProbe);\
1515 \
1516 JNI_ENTRY(ResultType, \
1517           jni_CallNonvirtual##Result##Method(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...)) \
1518   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;Method&quot;); \
1519 \
1520   EntryProbe;\
1521   ResultType ret;\
1522   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##Method, ResultType, \
1523                      (const ResultType&amp;)ret);\
1524 \
1525   va_list args; \
1526   va_start(args, methodID); \
1527   JavaValue jvalue(Tag); \
1528   JNI_ArgumentPusherVaArg ap(methodID, args); \
1529   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1530   va_end(args); \
1531   ret = jvalue.get_##ResultType(); \
1532   return ret;\
1533 JNI_END
1534 
1535 // the runtime type of subword integral basic types is integer
1536 DEFINE_CALLNONVIRTUALMETHOD(jboolean, Boolean, T_BOOLEAN
1537                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1538                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHOD_RETURN(_ret_ref))
1539 DEFINE_CALLNONVIRTUALMETHOD(jbyte,    Byte,    T_BYTE
1540                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1541                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHOD_RETURN(_ret_ref))
1542 DEFINE_CALLNONVIRTUALMETHOD(jchar,    Char,    T_CHAR
1543                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1544                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHOD_RETURN(_ret_ref))
1545 DEFINE_CALLNONVIRTUALMETHOD(jshort,   Short,   T_SHORT
1546                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1547                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHOD_RETURN(_ret_ref))
1548 
1549 DEFINE_CALLNONVIRTUALMETHOD(jobject,  Object,  T_OBJECT
1550                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1551                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHOD_RETURN(_ret_ref))
1552 DEFINE_CALLNONVIRTUALMETHOD(jint,     Int,     T_INT
1553                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1554                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHOD_RETURN(_ret_ref))
1555 DEFINE_CALLNONVIRTUALMETHOD(jlong,    Long,    T_LONG
1556                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1557 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1558                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHOD_RETURN(_ret_ref))
1559 DEFINE_CALLNONVIRTUALMETHOD(jfloat,   Float,   T_FLOAT
1560                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1561                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHOD_RETURN())
1562 DEFINE_CALLNONVIRTUALMETHOD(jdouble,  Double,  T_DOUBLE
1563                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_ENTRY(env, obj, cls, (uintptr_t)methodID),
1564                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHOD_RETURN())
1565 
1566 #define DEFINE_CALLNONVIRTUALMETHODV(ResultType, Result, Tag \
1567                                     , EntryProbe, ReturnProbe)      \
1568 \
1569   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodV, ResultType \
1570                           , ReturnProbe);\
1571 \
1572 JNI_ENTRY(ResultType, \
1573           jni_CallNonvirtual##Result##MethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args)) \
1574   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;MethodV&quot;); \
1575 \
1576   EntryProbe;\
1577   ResultType ret;\
1578   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodV, ResultType, \
1579                      (const ResultType&amp;)ret);\
1580 \
1581   JavaValue jvalue(Tag); \
1582   JNI_ArgumentPusherVaArg ap(methodID, args); \
1583   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1584   ret = jvalue.get_##ResultType(); \
1585   return ret;\
1586 JNI_END
1587 
1588 // the runtime type of subword integral basic types is integer
1589 DEFINE_CALLNONVIRTUALMETHODV(jboolean, Boolean, T_BOOLEAN
1590                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1591                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODV_RETURN(_ret_ref))
1592 DEFINE_CALLNONVIRTUALMETHODV(jbyte,    Byte,    T_BYTE
1593                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1594                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODV_RETURN(_ret_ref))
1595 DEFINE_CALLNONVIRTUALMETHODV(jchar,    Char,    T_CHAR
1596                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1597                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODV_RETURN(_ret_ref))
1598 DEFINE_CALLNONVIRTUALMETHODV(jshort,   Short,   T_SHORT
1599                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1600                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODV_RETURN(_ret_ref))
1601 
1602 DEFINE_CALLNONVIRTUALMETHODV(jobject,  Object,  T_OBJECT
1603                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1604                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODV_RETURN(_ret_ref))
1605 DEFINE_CALLNONVIRTUALMETHODV(jint,     Int,     T_INT
1606                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1607                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODV_RETURN(_ret_ref))
1608 DEFINE_CALLNONVIRTUALMETHODV(jlong,    Long,    T_LONG
1609                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1610 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1611                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODV_RETURN(_ret_ref))
1612 DEFINE_CALLNONVIRTUALMETHODV(jfloat,   Float,   T_FLOAT
1613                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1614                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODV_RETURN())
1615 DEFINE_CALLNONVIRTUALMETHODV(jdouble,  Double,  T_DOUBLE
1616                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_ENTRY(env, obj, cls, (uintptr_t)methodID),
1617                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODV_RETURN())
1618 
1619 #define DEFINE_CALLNONVIRTUALMETHODA(ResultType, Result, Tag \
1620                                     , EntryProbe, ReturnProbe)      \
1621 \
1622   DT_RETURN_MARK_DECL_FOR(Result, CallNonvirtual##Result##MethodA, ResultType \
1623                           , ReturnProbe);\
1624 \
1625 JNI_ENTRY(ResultType, \
1626           jni_CallNonvirtual##Result##MethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args)) \
1627   JNIWrapper(&quot;CallNonvitual&quot; XSTR(Result) &quot;MethodA&quot;); \
1628 \
1629   EntryProbe;\
1630   ResultType ret;\
1631   DT_RETURN_MARK_FOR(Result, CallNonvirtual##Result##MethodA, ResultType, \
1632                      (const ResultType&amp;)ret);\
1633 \
1634   JavaValue jvalue(Tag); \
1635   JNI_ArgumentPusherArray ap(methodID, args); \
1636   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_0); \
1637   ret = jvalue.get_##ResultType(); \
1638   return ret;\
1639 JNI_END
1640 
1641 // the runtime type of subword integral basic types is integer
1642 DEFINE_CALLNONVIRTUALMETHODA(jboolean, Boolean, T_BOOLEAN
1643                             , HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1644                             HOTSPOT_JNI_CALLNONVIRTUALBOOLEANMETHODA_RETURN(_ret_ref))
1645 DEFINE_CALLNONVIRTUALMETHODA(jbyte,    Byte,    T_BYTE
1646                             , HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1647                             HOTSPOT_JNI_CALLNONVIRTUALBYTEMETHODA_RETURN(_ret_ref))
1648 DEFINE_CALLNONVIRTUALMETHODA(jchar,    Char,    T_CHAR
1649                             , HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1650                             HOTSPOT_JNI_CALLNONVIRTUALCHARMETHODA_RETURN(_ret_ref))
1651 DEFINE_CALLNONVIRTUALMETHODA(jshort,   Short,   T_SHORT
1652                             , HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1653                             HOTSPOT_JNI_CALLNONVIRTUALSHORTMETHODA_RETURN(_ret_ref))
1654 
1655 DEFINE_CALLNONVIRTUALMETHODA(jobject,  Object,  T_OBJECT
1656                             , HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1657                             HOTSPOT_JNI_CALLNONVIRTUALOBJECTMETHODA_RETURN(_ret_ref))
1658 DEFINE_CALLNONVIRTUALMETHODA(jint,     Int,     T_INT
1659                             , HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1660                             HOTSPOT_JNI_CALLNONVIRTUALINTMETHODA_RETURN(_ret_ref))
1661 DEFINE_CALLNONVIRTUALMETHODA(jlong,    Long,    T_LONG
1662                             , HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1663 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1664                             HOTSPOT_JNI_CALLNONVIRTUALLONGMETHODA_RETURN(_ret_ref))
1665 DEFINE_CALLNONVIRTUALMETHODA(jfloat,   Float,   T_FLOAT
1666                             , HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1667                             HOTSPOT_JNI_CALLNONVIRTUALFLOATMETHODA_RETURN())
1668 DEFINE_CALLNONVIRTUALMETHODA(jdouble,  Double,  T_DOUBLE
1669                             , HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_ENTRY(env, obj, cls, (uintptr_t)methodID),
1670                             HOTSPOT_JNI_CALLNONVIRTUALDOUBLEMETHODA_RETURN())
1671 
1672 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethod
1673                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_RETURN());
1674 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodV
1675                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_RETURN());
1676 DT_VOID_RETURN_MARK_DECL(CallNonvirtualVoidMethodA
1677                          , HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_RETURN());
1678 
1679 JNI_ENTRY(void, jni_CallNonvirtualVoidMethod(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, ...))
1680   JNIWrapper(&quot;CallNonvirtualVoidMethod&quot;);
1681 
1682   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHOD_ENTRY(env, obj, cls, (uintptr_t) methodID);
1683   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethod);
1684 
1685   va_list args;
1686   va_start(args, methodID);
1687   JavaValue jvalue(T_VOID);
1688   JNI_ArgumentPusherVaArg ap(methodID, args);
1689   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1690   va_end(args);
1691 JNI_END
1692 
1693 
1694 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodV(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, va_list args))
1695   JNIWrapper(&quot;CallNonvirtualVoidMethodV&quot;);
1696 
1697   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODV_ENTRY(
1698                env, obj, cls, (uintptr_t) methodID);
1699   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodV);
1700 
1701   JavaValue jvalue(T_VOID);
1702   JNI_ArgumentPusherVaArg ap(methodID, args);
1703   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1704 JNI_END
1705 
1706 
1707 JNI_ENTRY(void, jni_CallNonvirtualVoidMethodA(JNIEnv *env, jobject obj, jclass cls, jmethodID methodID, const jvalue *args))
1708   JNIWrapper(&quot;CallNonvirtualVoidMethodA&quot;);
1709   HOTSPOT_JNI_CALLNONVIRTUALVOIDMETHODA_ENTRY(
1710                 env, obj, cls, (uintptr_t) methodID);
1711   DT_VOID_RETURN_MARK(CallNonvirtualVoidMethodA);
1712   JavaValue jvalue(T_VOID);
1713   JNI_ArgumentPusherArray ap(methodID, args);
1714   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK);
1715 JNI_END
1716 
1717 
1718 
1719 #define DEFINE_CALLSTATICMETHOD(ResultType, Result, Tag \
1720                                 , EntryProbe, ResultProbe) \
1721 \
1722   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##Method, ResultType \
1723                           , ResultProbe);                               \
1724 \
1725 JNI_ENTRY(ResultType, \
1726           jni_CallStatic##Result##Method(JNIEnv *env, jclass cls, jmethodID methodID, ...)) \
1727   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;Method&quot;); \
1728 \
1729   EntryProbe; \
1730   ResultType ret = 0;\
1731   DT_RETURN_MARK_FOR(Result, CallStatic##Result##Method, ResultType, \
1732                      (const ResultType&amp;)ret);\
1733 \
1734   va_list args; \
1735   va_start(args, methodID); \
1736   JavaValue jvalue(Tag); \
1737   JNI_ArgumentPusherVaArg ap(methodID, args); \
1738   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1739   va_end(args); \
1740   ret = jvalue.get_##ResultType(); \
1741   return ret;\
1742 JNI_END
1743 
1744 // the runtime type of subword integral basic types is integer
1745 DEFINE_CALLSTATICMETHOD(jboolean, Boolean, T_BOOLEAN
1746                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1747                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHOD_RETURN(_ret_ref));
1748 DEFINE_CALLSTATICMETHOD(jbyte,    Byte,    T_BYTE
1749                         , HOTSPOT_JNI_CALLSTATICBYTEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1750                         HOTSPOT_JNI_CALLSTATICBYTEMETHOD_RETURN(_ret_ref));
1751 DEFINE_CALLSTATICMETHOD(jchar,    Char,    T_CHAR
1752                         , HOTSPOT_JNI_CALLSTATICCHARMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1753                         HOTSPOT_JNI_CALLSTATICCHARMETHOD_RETURN(_ret_ref));
1754 DEFINE_CALLSTATICMETHOD(jshort,   Short,   T_SHORT
1755                         , HOTSPOT_JNI_CALLSTATICSHORTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1756                         HOTSPOT_JNI_CALLSTATICSHORTMETHOD_RETURN(_ret_ref));
1757 
1758 DEFINE_CALLSTATICMETHOD(jobject,  Object,  T_OBJECT
1759                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1760                         HOTSPOT_JNI_CALLSTATICOBJECTMETHOD_RETURN(_ret_ref));
1761 DEFINE_CALLSTATICMETHOD(jint,     Int,     T_INT
1762                         , HOTSPOT_JNI_CALLSTATICINTMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1763                         HOTSPOT_JNI_CALLSTATICINTMETHOD_RETURN(_ret_ref));
1764 DEFINE_CALLSTATICMETHOD(jlong,    Long,    T_LONG
1765                         , HOTSPOT_JNI_CALLSTATICLONGMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1766                         HOTSPOT_JNI_CALLSTATICLONGMETHOD_RETURN(_ret_ref));
1767 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1768 DEFINE_CALLSTATICMETHOD(jfloat,   Float,   T_FLOAT
1769                         , HOTSPOT_JNI_CALLSTATICFLOATMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1770                         HOTSPOT_JNI_CALLSTATICFLOATMETHOD_RETURN());
1771 DEFINE_CALLSTATICMETHOD(jdouble,  Double,  T_DOUBLE
1772                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_ENTRY(env, cls, (uintptr_t)methodID),
1773                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHOD_RETURN());
1774 
1775 #define DEFINE_CALLSTATICMETHODV(ResultType, Result, Tag \
1776                                 , EntryProbe, ResultProbe) \
1777 \
1778   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodV, ResultType \
1779                           , ResultProbe);                               \
1780 \
1781 JNI_ENTRY(ResultType, \
1782           jni_CallStatic##Result##MethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args)) \
1783   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;MethodV&quot;); \
1784 \
1785   EntryProbe; \
1786   ResultType ret = 0;\
1787   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodV, ResultType, \
1788                      (const ResultType&amp;)ret);\
1789 \
1790   JavaValue jvalue(Tag); \
1791   JNI_ArgumentPusherVaArg ap(methodID, args); \
1792   /* Make sure class is initialized before trying to invoke its method */ \
1793   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls)); \
1794   k-&gt;initialize(CHECK_0); \
1795   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1796   va_end(args); \
1797   ret = jvalue.get_##ResultType(); \
1798   return ret;\
1799 JNI_END
1800 
1801 // the runtime type of subword integral basic types is integer
1802 DEFINE_CALLSTATICMETHODV(jboolean, Boolean, T_BOOLEAN
1803                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1804                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODV_RETURN(_ret_ref));
1805 DEFINE_CALLSTATICMETHODV(jbyte,    Byte,    T_BYTE
1806                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1807                         HOTSPOT_JNI_CALLSTATICBYTEMETHODV_RETURN(_ret_ref));
1808 DEFINE_CALLSTATICMETHODV(jchar,    Char,    T_CHAR
1809                         , HOTSPOT_JNI_CALLSTATICCHARMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1810                         HOTSPOT_JNI_CALLSTATICCHARMETHODV_RETURN(_ret_ref));
1811 DEFINE_CALLSTATICMETHODV(jshort,   Short,   T_SHORT
1812                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1813                         HOTSPOT_JNI_CALLSTATICSHORTMETHODV_RETURN(_ret_ref));
1814 
1815 DEFINE_CALLSTATICMETHODV(jobject,  Object,  T_OBJECT
1816                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1817                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODV_RETURN(_ret_ref));
1818 DEFINE_CALLSTATICMETHODV(jint,     Int,     T_INT
1819                         , HOTSPOT_JNI_CALLSTATICINTMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1820                         HOTSPOT_JNI_CALLSTATICINTMETHODV_RETURN(_ret_ref));
1821 DEFINE_CALLSTATICMETHODV(jlong,    Long,    T_LONG
1822                         , HOTSPOT_JNI_CALLSTATICLONGMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1823                         HOTSPOT_JNI_CALLSTATICLONGMETHODV_RETURN(_ret_ref));
1824 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1825 DEFINE_CALLSTATICMETHODV(jfloat,   Float,   T_FLOAT
1826                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1827                         HOTSPOT_JNI_CALLSTATICFLOATMETHODV_RETURN());
1828 DEFINE_CALLSTATICMETHODV(jdouble,  Double,  T_DOUBLE
1829                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_ENTRY(env, cls, (uintptr_t)methodID),
1830                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODV_RETURN());
1831 
1832 #define DEFINE_CALLSTATICMETHODA(ResultType, Result, Tag \
1833                                 , EntryProbe, ResultProbe) \
1834 \
1835   DT_RETURN_MARK_DECL_FOR(Result, CallStatic##Result##MethodA, ResultType \
1836                           , ResultProbe);                               \
1837 \
1838 JNI_ENTRY(ResultType, \
1839           jni_CallStatic##Result##MethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args)) \
1840   JNIWrapper(&quot;CallStatic&quot; XSTR(Result) &quot;MethodA&quot;); \
1841 \
1842   EntryProbe; \
1843   ResultType ret = 0;\
1844   DT_RETURN_MARK_FOR(Result, CallStatic##Result##MethodA, ResultType, \
1845                      (const ResultType&amp;)ret);\
1846 \
1847   JavaValue jvalue(Tag); \
1848   JNI_ArgumentPusherArray ap(methodID, args); \
1849   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_0); \
1850   ret = jvalue.get_##ResultType(); \
1851   return ret;\
1852 JNI_END
1853 
1854 // the runtime type of subword integral basic types is integer
1855 DEFINE_CALLSTATICMETHODA(jboolean, Boolean, T_BOOLEAN
1856                         , HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1857                         HOTSPOT_JNI_CALLSTATICBOOLEANMETHODA_RETURN(_ret_ref));
1858 DEFINE_CALLSTATICMETHODA(jbyte,    Byte,    T_BYTE
1859                         , HOTSPOT_JNI_CALLSTATICBYTEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1860                         HOTSPOT_JNI_CALLSTATICBYTEMETHODA_RETURN(_ret_ref));
1861 DEFINE_CALLSTATICMETHODA(jchar,    Char,    T_CHAR
1862                         , HOTSPOT_JNI_CALLSTATICCHARMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1863                         HOTSPOT_JNI_CALLSTATICCHARMETHODA_RETURN(_ret_ref));
1864 DEFINE_CALLSTATICMETHODA(jshort,   Short,   T_SHORT
1865                         , HOTSPOT_JNI_CALLSTATICSHORTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1866                         HOTSPOT_JNI_CALLSTATICSHORTMETHODA_RETURN(_ret_ref));
1867 
1868 DEFINE_CALLSTATICMETHODA(jobject,  Object,  T_OBJECT
1869                         , HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1870                         HOTSPOT_JNI_CALLSTATICOBJECTMETHODA_RETURN(_ret_ref));
1871 DEFINE_CALLSTATICMETHODA(jint,     Int,     T_INT
1872                         , HOTSPOT_JNI_CALLSTATICINTMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1873                         HOTSPOT_JNI_CALLSTATICINTMETHODA_RETURN(_ret_ref));
1874 DEFINE_CALLSTATICMETHODA(jlong,    Long,    T_LONG
1875                         , HOTSPOT_JNI_CALLSTATICLONGMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1876                         HOTSPOT_JNI_CALLSTATICLONGMETHODA_RETURN(_ret_ref));
1877 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
1878 DEFINE_CALLSTATICMETHODA(jfloat,   Float,   T_FLOAT
1879                         , HOTSPOT_JNI_CALLSTATICFLOATMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1880                         HOTSPOT_JNI_CALLSTATICFLOATMETHODA_RETURN());
1881 DEFINE_CALLSTATICMETHODA(jdouble,  Double,  T_DOUBLE
1882                         , HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_ENTRY(env, cls, (uintptr_t)methodID),
1883                         HOTSPOT_JNI_CALLSTATICDOUBLEMETHODA_RETURN());
1884 
1885 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethod
1886                          , HOTSPOT_JNI_CALLSTATICVOIDMETHOD_RETURN());
1887 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodV
1888                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODV_RETURN());
1889 DT_VOID_RETURN_MARK_DECL(CallStaticVoidMethodA
1890                          , HOTSPOT_JNI_CALLSTATICVOIDMETHODA_RETURN());
1891 
1892 JNI_ENTRY(void, jni_CallStaticVoidMethod(JNIEnv *env, jclass cls, jmethodID methodID, ...))
1893   JNIWrapper(&quot;CallStaticVoidMethod&quot;);
1894   HOTSPOT_JNI_CALLSTATICVOIDMETHOD_ENTRY(env, cls, (uintptr_t) methodID);
1895   DT_VOID_RETURN_MARK(CallStaticVoidMethod);
1896 
1897   va_list args;
1898   va_start(args, methodID);
1899   JavaValue jvalue(T_VOID);
1900   JNI_ArgumentPusherVaArg ap(methodID, args);
1901   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1902   va_end(args);
1903 JNI_END
1904 
1905 
1906 JNI_ENTRY(void, jni_CallStaticVoidMethodV(JNIEnv *env, jclass cls, jmethodID methodID, va_list args))
1907   JNIWrapper(&quot;CallStaticVoidMethodV&quot;);
1908   HOTSPOT_JNI_CALLSTATICVOIDMETHODV_ENTRY(env, cls, (uintptr_t) methodID);
1909   DT_VOID_RETURN_MARK(CallStaticVoidMethodV);
1910 
1911   JavaValue jvalue(T_VOID);
1912   JNI_ArgumentPusherVaArg ap(methodID, args);
1913   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1914 JNI_END
1915 
1916 
1917 JNI_ENTRY(void, jni_CallStaticVoidMethodA(JNIEnv *env, jclass cls, jmethodID methodID, const jvalue *args))
1918   JNIWrapper(&quot;CallStaticVoidMethodA&quot;);
1919   HOTSPOT_JNI_CALLSTATICVOIDMETHODA_ENTRY(env, cls, (uintptr_t) methodID);
1920   DT_VOID_RETURN_MARK(CallStaticVoidMethodA);
1921 
1922   JavaValue jvalue(T_VOID);
1923   JNI_ArgumentPusherArray ap(methodID, args);
1924   jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK);
1925 JNI_END
1926 
1927 
1928 //
1929 // Accessing Fields
1930 //
1931 
1932 
1933 DT_RETURN_MARK_DECL(GetFieldID, jfieldID
1934                     , HOTSPOT_JNI_GETFIELDID_RETURN((uintptr_t)_ret_ref));
1935 
1936 JNI_ENTRY(jfieldID, jni_GetFieldID(JNIEnv *env, jclass clazz,
1937           const char *name, const char *sig))
1938   JNIWrapper(&quot;GetFieldID&quot;);
1939   HOTSPOT_JNI_GETFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
1940   jfieldID ret = 0;
1941   DT_RETURN_MARK(GetFieldID, jfieldID, (const jfieldID&amp;)ret);
1942 
1943   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1944 
1945   // The class should have been loaded (we have an instance of the class
1946   // passed in) so the field and signature should already be in the symbol
1947   // table.  If they&#39;re not there, the field doesn&#39;t exist.
1948   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
1949   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
1950   if (fieldname == NULL || signame == NULL) {
1951     ResourceMark rm;
1952     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
1953   }
1954 
1955   // Make sure class is initialized before handing id&#39;s out to fields
1956   k-&gt;initialize(CHECK_NULL);
1957 
1958   fieldDescriptor fd;
1959   if (!k-&gt;is_instance_klass() ||
1960       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
1961     ResourceMark rm;
1962     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
1963   }
1964 
1965   // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
1966   // It may also have hash bits for k, if VerifyJNIFields is turned on.
1967   ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset(), fd.is_flattened());
1968   return ret;
1969 JNI_END
1970 
1971 
1972 JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
1973   JNIWrapper(&quot;GetObjectField&quot;);
1974   HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID);
1975   oop o = JNIHandles::resolve_non_null(obj);
1976   Klass* k = o-&gt;klass();
1977   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
1978   oop res = NULL;
1979   // Keep JVMTI addition small and only check enabled flag here.
1980   // jni_GetField_probe() assumes that is okay to create handles.
1981   if (JvmtiExport::should_post_field_access()) {
1982     o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
1983   }
1984   if (!jfieldIDWorkaround::is_flattened_field(fieldID)) {
1985     res = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(o, offset);
1986   } else {
1987     assert(k-&gt;is_instance_klass(), &quot;Only instance can have flattened fields&quot;);
1988     InstanceKlass* ik = InstanceKlass::cast(k);
1989     fieldDescriptor fd;
1990     ik-&gt;find_field_from_offset(offset, false, &amp;fd);  // performance bottleneck
1991     InstanceKlass* holder = fd.field_holder();
1992     ValueKlass* field_vklass = ValueKlass::cast(holder-&gt;get_value_field_klass(fd.index()));
1993     res = field_vklass-&gt;read_flattened_field(o, ik-&gt;field_offset(fd.index()), CHECK_NULL);
1994   }
1995   jobject ret = JNIHandles::make_local(env, res);
1996   HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
1997   return ret;
1998 JNI_END
1999 
2000 
2001 
2002 #define DEFINE_GETFIELD(Return,Fieldname,Result \
2003   , EntryProbe, ReturnProbe) \
2004 \
2005   DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
2006   , ReturnProbe); \
2007 \
2008 JNI_ENTRY_NO_PRESERVE(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \
2009   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;Field&quot;); \
2010 \
2011   EntryProbe; \
2012   Return ret = 0;\
2013   DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&amp;)ret);\
2014 \
2015   oop o = JNIHandles::resolve_non_null(obj); \
2016   Klass* k = o-&gt;klass(); \
2017   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2018   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2019   /* jni_GetField_probe_nh() assumes that is not okay to create handles */ \
2020   /* and creates a ResetNoHandleMark.                                   */ \
2021   if (JvmtiExport::should_post_field_access()) { \
2022     o = JvmtiExport::jni_GetField_probe_nh(thread, obj, o, k, fieldID, false); \
2023   } \
2024   ret = o-&gt;Fieldname##_field(offset); \
2025   return ret; \
2026 JNI_END
2027 
2028 DEFINE_GETFIELD(jboolean, bool,   Boolean
2029                 , HOTSPOT_JNI_GETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2030                 HOTSPOT_JNI_GETBOOLEANFIELD_RETURN(_ret_ref))
2031 DEFINE_GETFIELD(jbyte,    byte,   Byte
2032                 , HOTSPOT_JNI_GETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2033                 HOTSPOT_JNI_GETBYTEFIELD_RETURN(_ret_ref))
2034 DEFINE_GETFIELD(jchar,    char,   Char
2035                 , HOTSPOT_JNI_GETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2036                 HOTSPOT_JNI_GETCHARFIELD_RETURN(_ret_ref))
2037 DEFINE_GETFIELD(jshort,   short,  Short
2038                 , HOTSPOT_JNI_GETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2039                 HOTSPOT_JNI_GETSHORTFIELD_RETURN(_ret_ref))
2040 DEFINE_GETFIELD(jint,     int,    Int
2041                 , HOTSPOT_JNI_GETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2042                 HOTSPOT_JNI_GETINTFIELD_RETURN(_ret_ref))
2043 DEFINE_GETFIELD(jlong,    long,   Long
2044                 , HOTSPOT_JNI_GETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2045                 HOTSPOT_JNI_GETLONGFIELD_RETURN(_ret_ref))
2046 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2047 DEFINE_GETFIELD(jfloat,   float,  Float
2048                 , HOTSPOT_JNI_GETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2049                 HOTSPOT_JNI_GETFLOATFIELD_RETURN())
2050 DEFINE_GETFIELD(jdouble,  double, Double
2051                 , HOTSPOT_JNI_GETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2052                 HOTSPOT_JNI_GETDOUBLEFIELD_RETURN())
2053 
2054 address jni_GetBooleanField_addr() {
2055   return (address)jni_GetBooleanField;
2056 }
2057 address jni_GetByteField_addr() {
2058   return (address)jni_GetByteField;
2059 }
2060 address jni_GetCharField_addr() {
2061   return (address)jni_GetCharField;
2062 }
2063 address jni_GetShortField_addr() {
2064   return (address)jni_GetShortField;
2065 }
2066 address jni_GetIntField_addr() {
2067   return (address)jni_GetIntField;
2068 }
2069 address jni_GetLongField_addr() {
2070   return (address)jni_GetLongField;
2071 }
2072 address jni_GetFloatField_addr() {
2073   return (address)jni_GetFloatField;
2074 }
2075 address jni_GetDoubleField_addr() {
2076   return (address)jni_GetDoubleField;
2077 }
2078 
2079 JNI_ENTRY_NO_PRESERVE(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))
2080   JNIWrapper(&quot;SetObjectField&quot;);
2081   HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID, value);
2082   oop o = JNIHandles::resolve_non_null(obj);
2083   Klass* k = o-&gt;klass();
2084   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2085   // Keep JVMTI addition small and only check enabled flag here.
2086   // jni_SetField_probe_nh() assumes that is not okay to create handles
2087   // and creates a ResetNoHandleMark.
2088   if (JvmtiExport::should_post_field_modification()) {
2089     jvalue field_value;
2090     field_value.l = value;
2091     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);
2092   }
2093   if (!jfieldIDWorkaround::is_flattened_field(fieldID)) {
2094     HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(o, offset, JNIHandles::resolve(value));
2095   } else {
2096     assert(k-&gt;is_instance_klass(), &quot;Only instances can have flattened fields&quot;);
2097     InstanceKlass* ik = InstanceKlass::cast(k);
2098     fieldDescriptor fd;
2099     ik-&gt;find_field_from_offset(offset, false, &amp;fd);
2100     InstanceKlass* holder = fd.field_holder();
2101     ValueKlass* vklass = ValueKlass::cast(holder-&gt;get_value_field_klass(fd.index()));
2102     oop v = JNIHandles::resolve_non_null(value);
2103     vklass-&gt;write_flattened_field(o, offset, v, CHECK);
2104   }
2105   HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
2106 JNI_END
2107 
2108 
2109 #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
2110                         , EntryProbe, ReturnProbe) \
2111 \
2112 JNI_ENTRY_NO_PRESERVE(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \
2113   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;Field&quot;); \
2114 \
2115   EntryProbe; \
2116 \
2117   oop o = JNIHandles::resolve_non_null(obj); \
2118   Klass* k = o-&gt;klass(); \
2119   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2120   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2121   /* jni_SetField_probe_nh() assumes that is not okay to create handles */ \
2122   /* and creates a ResetNoHandleMark.                                   */ \
2123   if (JvmtiExport::should_post_field_modification()) { \
2124     jvalue field_value; \
2125     field_value.unionType = value; \
2126     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, SigType, (jvalue *)&amp;field_value); \
2127   } \
2128   if (SigType == JVM_SIGNATURE_BOOLEAN) { value = ((jboolean)value) &amp; 1; } \
2129   o-&gt;Fieldname##_field_put(offset, value); \
2130   ReturnProbe; \
2131 JNI_END
2132 
2133 DEFINE_SETFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z
2134                 , HOTSPOT_JNI_SETBOOLEANFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2135                 HOTSPOT_JNI_SETBOOLEANFIELD_RETURN())
2136 DEFINE_SETFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b
2137                 , HOTSPOT_JNI_SETBYTEFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2138                 HOTSPOT_JNI_SETBYTEFIELD_RETURN())
2139 DEFINE_SETFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c
2140                 , HOTSPOT_JNI_SETCHARFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2141                 HOTSPOT_JNI_SETCHARFIELD_RETURN())
2142 DEFINE_SETFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s
2143                 , HOTSPOT_JNI_SETSHORTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2144                 HOTSPOT_JNI_SETSHORTFIELD_RETURN())
2145 DEFINE_SETFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i
2146                 , HOTSPOT_JNI_SETINTFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2147                 HOTSPOT_JNI_SETINTFIELD_RETURN())
2148 DEFINE_SETFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j
2149                 , HOTSPOT_JNI_SETLONGFIELD_ENTRY(env, obj, (uintptr_t)fieldID, value),
2150                 HOTSPOT_JNI_SETLONGFIELD_RETURN())
2151 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2152 DEFINE_SETFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f
2153                 , HOTSPOT_JNI_SETFLOATFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2154                 HOTSPOT_JNI_SETFLOATFIELD_RETURN())
2155 DEFINE_SETFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d
2156                 , HOTSPOT_JNI_SETDOUBLEFIELD_ENTRY(env, obj, (uintptr_t)fieldID),
2157                 HOTSPOT_JNI_SETDOUBLEFIELD_RETURN())
2158 
2159 DT_RETURN_MARK_DECL(ToReflectedField, jobject
2160                     , HOTSPOT_JNI_TOREFLECTEDFIELD_RETURN(_ret_ref));
2161 
2162 JNI_ENTRY(jobject, jni_ToReflectedField(JNIEnv *env, jclass cls, jfieldID fieldID, jboolean isStatic))
2163   JNIWrapper(&quot;ToReflectedField&quot;);
2164   HOTSPOT_JNI_TOREFLECTEDFIELD_ENTRY(env, cls, (uintptr_t) fieldID, isStatic);
2165   jobject ret = NULL;
2166   DT_RETURN_MARK(ToReflectedField, jobject, (const jobject&amp;)ret);
2167 
2168   fieldDescriptor fd;
2169   bool found = false;
2170   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2171 
2172   assert(jfieldIDWorkaround::is_static_jfieldID(fieldID) == (isStatic != 0), &quot;invalid fieldID&quot;);
2173 
2174   if (isStatic) {
2175     // Static field. The fieldID a JNIid specifying the field holder and the offset within the Klass*.
2176     JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2177     assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2178     found = id-&gt;find_local_field(&amp;fd);
2179   } else {
2180     // Non-static field. The fieldID is really the offset of the field within the instanceOop.
2181     int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2182     found = InstanceKlass::cast(k)-&gt;find_field_from_offset(offset, false, &amp;fd);
2183   }
2184   assert(found, &quot;bad fieldID passed into jni_ToReflectedField&quot;);
2185   oop reflected = Reflection::new_field(&amp;fd, CHECK_NULL);
2186   ret = JNIHandles::make_local(env, reflected);
2187   return ret;
2188 JNI_END
2189 
2190 
2191 //
2192 // Accessing Static Fields
2193 //
2194 DT_RETURN_MARK_DECL(GetStaticFieldID, jfieldID
2195                     , HOTSPOT_JNI_GETSTATICFIELDID_RETURN((uintptr_t)_ret_ref));
2196 
2197 JNI_ENTRY(jfieldID, jni_GetStaticFieldID(JNIEnv *env, jclass clazz,
2198           const char *name, const char *sig))
2199   JNIWrapper(&quot;GetStaticFieldID&quot;);
2200   HOTSPOT_JNI_GETSTATICFIELDID_ENTRY(env, clazz, (char *) name, (char *) sig);
2201   jfieldID ret = NULL;
2202   DT_RETURN_MARK(GetStaticFieldID, jfieldID, (const jfieldID&amp;)ret);
2203 
2204   // The class should have been loaded (we have an instance of the class
2205   // passed in) so the field and signature should already be in the symbol
2206   // table.  If they&#39;re not there, the field doesn&#39;t exist.
2207   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
2208   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
2209   if (fieldname == NULL || signame == NULL) {
2210     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2211   }
2212   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2213   // Make sure class is initialized before handing id&#39;s out to static fields
2214   k-&gt;initialize(CHECK_NULL);
2215 
2216   fieldDescriptor fd;
2217   if (!k-&gt;is_instance_klass() ||
2218       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, true, &amp;fd)) {
2219     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), (char*) name);
2220   }
2221 
2222   // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
2223   JNIid* id = fd.field_holder()-&gt;jni_id_for(fd.offset());
2224   debug_only(id-&gt;set_is_static_field_id();)
2225 
2226   debug_only(id-&gt;verify(fd.field_holder()));
2227 
2228   ret = jfieldIDWorkaround::to_static_jfieldID(id);
2229   return ret;
2230 JNI_END
2231 
2232 
2233 JNI_ENTRY(jobject, jni_GetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID))
2234   JNIWrapper(&quot;GetStaticObjectField&quot;);
2235   HOTSPOT_JNI_GETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID);
2236 #if INCLUDE_JNI_CHECK
2237   DEBUG_ONLY(Klass* param_k = jniCheck::validate_class(thread, clazz);)
2238 #endif // INCLUDE_JNI_CHECK
2239   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2240   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2241   // Keep JVMTI addition small and only check enabled flag here.
2242   // jni_GetField_probe() assumes that is okay to create handles.
2243   if (JvmtiExport::should_post_field_access()) {
2244     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true);
2245   }
2246   jobject ret = JNIHandles::make_local(id-&gt;holder()-&gt;java_mirror()-&gt;obj_field(id-&gt;offset()));
2247   HOTSPOT_JNI_GETSTATICOBJECTFIELD_RETURN(ret);
2248   return ret;
2249 JNI_END
2250 
2251 
2252 #define DEFINE_GETSTATICFIELD(Return,Fieldname,Result \
2253                               , EntryProbe, ReturnProbe) \
2254 \
2255   DT_RETURN_MARK_DECL_FOR(Result, GetStatic##Result##Field, Return \
2256                           , ReturnProbe);                                          \
2257 \
2258 JNI_ENTRY(Return, jni_GetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID)) \
2259   JNIWrapper(&quot;GetStatic&quot; XSTR(Result) &quot;Field&quot;); \
2260   EntryProbe; \
2261   Return ret = 0;\
2262   DT_RETURN_MARK_FOR(Result, GetStatic##Result##Field, Return, \
2263                      (const Return&amp;)ret);\
2264   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2265   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;); \
2266   /* Keep JVMTI addition small and only check enabled flag here. */ \
2267   /* jni_GetField_probe() assumes that is okay to create handles. */ \
2268   if (JvmtiExport::should_post_field_access()) { \
2269     JvmtiExport::jni_GetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true); \
2270   } \
2271   ret = id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field (id-&gt;offset()); \
2272   return ret;\
2273 JNI_END
2274 
2275 DEFINE_GETSTATICFIELD(jboolean, bool,   Boolean
2276                       , HOTSPOT_JNI_GETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t) fieldID), HOTSPOT_JNI_GETSTATICBOOLEANFIELD_RETURN(_ret_ref))
2277 DEFINE_GETSTATICFIELD(jbyte,    byte,   Byte
2278                       , HOTSPOT_JNI_GETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICBYTEFIELD_RETURN(_ret_ref)   )
2279 DEFINE_GETSTATICFIELD(jchar,    char,   Char
2280                       , HOTSPOT_JNI_GETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICCHARFIELD_RETURN(_ret_ref)   )
2281 DEFINE_GETSTATICFIELD(jshort,   short,  Short
2282                       , HOTSPOT_JNI_GETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICSHORTFIELD_RETURN(_ret_ref)  )
2283 DEFINE_GETSTATICFIELD(jint,     int,    Int
2284                       , HOTSPOT_JNI_GETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),     HOTSPOT_JNI_GETSTATICINTFIELD_RETURN(_ret_ref)    )
2285 DEFINE_GETSTATICFIELD(jlong,    long,   Long
2286                       , HOTSPOT_JNI_GETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),    HOTSPOT_JNI_GETSTATICLONGFIELD_RETURN(_ret_ref)   )
2287 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2288 DEFINE_GETSTATICFIELD(jfloat,   float,  Float
2289                       , HOTSPOT_JNI_GETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),   HOTSPOT_JNI_GETSTATICFLOATFIELD_RETURN()          )
2290 DEFINE_GETSTATICFIELD(jdouble,  double, Double
2291                       , HOTSPOT_JNI_GETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),  HOTSPOT_JNI_GETSTATICDOUBLEFIELD_RETURN()         )
2292 
2293 JNI_ENTRY(void, jni_SetStaticObjectField(JNIEnv *env, jclass clazz, jfieldID fieldID, jobject value))
2294   JNIWrapper(&quot;SetStaticObjectField&quot;);
2295  HOTSPOT_JNI_SETSTATICOBJECTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value);
2296   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID);
2297   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;);
2298   // Keep JVMTI addition small and only check enabled flag here.
2299   // jni_SetField_probe() assumes that is okay to create handles.
2300   if (JvmtiExport::should_post_field_modification()) {
2301     jvalue field_value;
2302     field_value.l = value;
2303     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);
2304   }
2305   id-&gt;holder()-&gt;java_mirror()-&gt;obj_field_put(id-&gt;offset(), JNIHandles::resolve(value));
2306   HOTSPOT_JNI_SETSTATICOBJECTFIELD_RETURN();
2307 JNI_END
2308 
2309 
2310 
2311 #define DEFINE_SETSTATICFIELD(Argument,Fieldname,Result,SigType,unionType \
2312                               , EntryProbe, ReturnProbe) \
2313 \
2314 JNI_ENTRY(void, jni_SetStatic##Result##Field(JNIEnv *env, jclass clazz, jfieldID fieldID, Argument value)) \
2315   JNIWrapper(&quot;SetStatic&quot; XSTR(Result) &quot;Field&quot;); \
2316   EntryProbe; \
2317 \
2318   JNIid* id = jfieldIDWorkaround::from_static_jfieldID(fieldID); \
2319   assert(id-&gt;is_static_field_id(), &quot;invalid static field id&quot;); \
2320   /* Keep JVMTI addition small and only check enabled flag here. */ \
2321   /* jni_SetField_probe() assumes that is okay to create handles. */ \
2322   if (JvmtiExport::should_post_field_modification()) { \
2323     jvalue field_value; \
2324     field_value.unionType = value; \
2325     JvmtiExport::jni_SetField_probe(thread, NULL, NULL, id-&gt;holder(), fieldID, true, SigType, (jvalue *)&amp;field_value); \
2326   } \
2327   if (SigType == JVM_SIGNATURE_BOOLEAN) { value = ((jboolean)value) &amp; 1; } \
2328   id-&gt;holder()-&gt;java_mirror()-&gt; Fieldname##_field_put (id-&gt;offset(), value); \
2329   ReturnProbe;\
2330 JNI_END
2331 
2332 DEFINE_SETSTATICFIELD(jboolean, bool,   Boolean, JVM_SIGNATURE_BOOLEAN, z
2333                       , HOTSPOT_JNI_SETSTATICBOOLEANFIELD_ENTRY(env, clazz, (uintptr_t)fieldID, value),
2334                       HOTSPOT_JNI_SETSTATICBOOLEANFIELD_RETURN())
2335 DEFINE_SETSTATICFIELD(jbyte,    byte,   Byte,    JVM_SIGNATURE_BYTE, b
2336                       , HOTSPOT_JNI_SETSTATICBYTEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2337                       HOTSPOT_JNI_SETSTATICBYTEFIELD_RETURN())
2338 DEFINE_SETSTATICFIELD(jchar,    char,   Char,    JVM_SIGNATURE_CHAR, c
2339                       , HOTSPOT_JNI_SETSTATICCHARFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2340                       HOTSPOT_JNI_SETSTATICCHARFIELD_RETURN())
2341 DEFINE_SETSTATICFIELD(jshort,   short,  Short,   JVM_SIGNATURE_SHORT, s
2342                       , HOTSPOT_JNI_SETSTATICSHORTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2343                       HOTSPOT_JNI_SETSTATICSHORTFIELD_RETURN())
2344 DEFINE_SETSTATICFIELD(jint,     int,    Int,     JVM_SIGNATURE_INT, i
2345                       , HOTSPOT_JNI_SETSTATICINTFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2346                       HOTSPOT_JNI_SETSTATICINTFIELD_RETURN())
2347 DEFINE_SETSTATICFIELD(jlong,    long,   Long,    JVM_SIGNATURE_LONG, j
2348                       , HOTSPOT_JNI_SETSTATICLONGFIELD_ENTRY(env, clazz, (uintptr_t) fieldID, value),
2349                       HOTSPOT_JNI_SETSTATICLONGFIELD_RETURN())
2350 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2351 DEFINE_SETSTATICFIELD(jfloat,   float,  Float,   JVM_SIGNATURE_FLOAT, f
2352                       , HOTSPOT_JNI_SETSTATICFLOATFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2353                       HOTSPOT_JNI_SETSTATICFLOATFIELD_RETURN())
2354 DEFINE_SETSTATICFIELD(jdouble,  double, Double,  JVM_SIGNATURE_DOUBLE, d
2355                       , HOTSPOT_JNI_SETSTATICDOUBLEFIELD_ENTRY(env, clazz, (uintptr_t) fieldID),
2356                       HOTSPOT_JNI_SETSTATICDOUBLEFIELD_RETURN())
2357 
2358 //
2359 // String Operations
2360 //
2361 
2362 // Unicode Interface
2363 
2364 DT_RETURN_MARK_DECL(NewString, jstring
2365                     , HOTSPOT_JNI_NEWSTRING_RETURN(_ret_ref));
2366 
2367 JNI_ENTRY(jstring, jni_NewString(JNIEnv *env, const jchar *unicodeChars, jsize len))
2368   JNIWrapper(&quot;NewString&quot;);
2369  HOTSPOT_JNI_NEWSTRING_ENTRY(env, (uint16_t *) unicodeChars, len);
2370   jstring ret = NULL;
2371   DT_RETURN_MARK(NewString, jstring, (const jstring&amp;)ret);
2372   oop string=java_lang_String::create_oop_from_unicode((jchar*) unicodeChars, len, CHECK_NULL);
2373   ret = (jstring) JNIHandles::make_local(env, string);
2374   return ret;
2375 JNI_END
2376 
2377 
2378 JNI_ENTRY_NO_PRESERVE(jsize, jni_GetStringLength(JNIEnv *env, jstring string))
2379   JNIWrapper(&quot;GetStringLength&quot;);
2380   HOTSPOT_JNI_GETSTRINGLENGTH_ENTRY(env, string);
2381   jsize ret = 0;
2382   oop s = JNIHandles::resolve_non_null(string);
2383   ret = java_lang_String::length(s);
2384  HOTSPOT_JNI_GETSTRINGLENGTH_RETURN(ret);
2385   return ret;
2386 JNI_END
2387 
2388 
2389 JNI_ENTRY_NO_PRESERVE(const jchar*, jni_GetStringChars(
2390   JNIEnv *env, jstring string, jboolean *isCopy))
2391   JNIWrapper(&quot;GetStringChars&quot;);
2392  HOTSPOT_JNI_GETSTRINGCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2393   jchar* buf = NULL;
2394   oop s = JNIHandles::resolve_non_null(string);
2395   typeArrayOop s_value = java_lang_String::value(s);
2396   if (s_value != NULL) {
2397     int s_len = java_lang_String::length(s, s_value);
2398     bool is_latin1 = java_lang_String::is_latin1(s);
2399     buf = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
2400     /* JNI Specification states return NULL on OOM */
2401     if (buf != NULL) {
2402       if (s_len &gt; 0) {
2403         if (!is_latin1) {
2404           ArrayAccess&lt;&gt;::arraycopy_to_native(s_value, (size_t) typeArrayOopDesc::element_offset&lt;jchar&gt;(0),
2405                                              buf, s_len);
2406         } else {
2407           for (int i = 0; i &lt; s_len; i++) {
2408             buf[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
2409           }
2410         }
2411       }
2412       buf[s_len] = 0;
2413       //%note jni_5
2414       if (isCopy != NULL) {
2415         *isCopy = JNI_TRUE;
2416       }
2417     }
2418   }
2419   HOTSPOT_JNI_GETSTRINGCHARS_RETURN(buf);
2420   return buf;
2421 JNI_END
2422 
2423 
2424 JNI_ENTRY_NO_PRESERVE(void, jni_ReleaseStringChars(JNIEnv *env, jstring str, const jchar *chars))
2425   JNIWrapper(&quot;ReleaseStringChars&quot;);
2426   HOTSPOT_JNI_RELEASESTRINGCHARS_ENTRY(env, str, (uint16_t *) chars);
2427   //%note jni_6
2428   if (chars != NULL) {
2429     // Since String objects are supposed to be immutable, don&#39;t copy any
2430     // new data back.  A bad user will have to go after the char array.
2431     FreeHeap((void*) chars);
2432   }
2433   HOTSPOT_JNI_RELEASESTRINGCHARS_RETURN();
2434 JNI_END
2435 
2436 
2437 // UTF Interface
2438 
2439 DT_RETURN_MARK_DECL(NewStringUTF, jstring
2440                     , HOTSPOT_JNI_NEWSTRINGUTF_RETURN(_ret_ref));
2441 
2442 JNI_ENTRY(jstring, jni_NewStringUTF(JNIEnv *env, const char *bytes))
2443   JNIWrapper(&quot;NewStringUTF&quot;);
2444   HOTSPOT_JNI_NEWSTRINGUTF_ENTRY(env, (char *) bytes);
2445   jstring ret;
2446   DT_RETURN_MARK(NewStringUTF, jstring, (const jstring&amp;)ret);
2447 
2448   oop result = java_lang_String::create_oop_from_str((char*) bytes, CHECK_NULL);
2449   ret = (jstring) JNIHandles::make_local(env, result);
2450   return ret;
2451 JNI_END
2452 
2453 
2454 JNI_ENTRY(jsize, jni_GetStringUTFLength(JNIEnv *env, jstring string))
2455   JNIWrapper(&quot;GetStringUTFLength&quot;);
2456  HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY(env, string);
2457   oop java_string = JNIHandles::resolve_non_null(string);
2458   jsize ret = java_lang_String::utf8_length(java_string);
2459   HOTSPOT_JNI_GETSTRINGUTFLENGTH_RETURN(ret);
2460   return ret;
2461 JNI_END
2462 
2463 
2464 JNI_ENTRY(const char*, jni_GetStringUTFChars(JNIEnv *env, jstring string, jboolean *isCopy))
2465   JNIWrapper(&quot;GetStringUTFChars&quot;);
2466  HOTSPOT_JNI_GETSTRINGUTFCHARS_ENTRY(env, string, (uintptr_t *) isCopy);
2467   char* result = NULL;
2468   oop java_string = JNIHandles::resolve_non_null(string);
2469   typeArrayOop s_value = java_lang_String::value(java_string);
2470   if (s_value != NULL) {
2471     size_t length = java_lang_String::utf8_length(java_string, s_value);
2472     /* JNI Specification states return NULL on OOM */
2473     result = AllocateHeap(length + 1, mtInternal, 0, AllocFailStrategy::RETURN_NULL);
2474     if (result != NULL) {
2475       java_lang_String::as_utf8_string(java_string, s_value, result, (int) length + 1);
2476       if (isCopy != NULL) {
2477         *isCopy = JNI_TRUE;
2478       }
2479     }
2480   }
2481  HOTSPOT_JNI_GETSTRINGUTFCHARS_RETURN(result);
2482   return result;
2483 JNI_END
2484 
2485 
2486 JNI_LEAF(void, jni_ReleaseStringUTFChars(JNIEnv *env, jstring str, const char *chars))
2487   JNIWrapper(&quot;ReleaseStringUTFChars&quot;);
2488  HOTSPOT_JNI_RELEASESTRINGUTFCHARS_ENTRY(env, str, (char *) chars);
2489   if (chars != NULL) {
2490     FreeHeap((char*) chars);
2491   }
2492 HOTSPOT_JNI_RELEASESTRINGUTFCHARS_RETURN();
2493 JNI_END
2494 
2495 
2496 JNI_ENTRY_NO_PRESERVE(jsize, jni_GetArrayLength(JNIEnv *env, jarray array))
2497   JNIWrapper(&quot;GetArrayLength&quot;);
2498  HOTSPOT_JNI_GETARRAYLENGTH_ENTRY(env, array);
2499   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
2500   assert(a-&gt;is_array(), &quot;must be array&quot;);
2501   jsize ret = a-&gt;length();
2502  HOTSPOT_JNI_GETARRAYLENGTH_RETURN(ret);
2503   return ret;
2504 JNI_END
2505 
2506 
2507 //
2508 // Object Array Operations
2509 //
2510 
2511 DT_RETURN_MARK_DECL(NewObjectArray, jobjectArray
2512                     , HOTSPOT_JNI_NEWOBJECTARRAY_RETURN(_ret_ref));
2513 
2514 JNI_ENTRY(jobjectArray, jni_NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement))
2515   JNIWrapper(&quot;NewObjectArray&quot;);
2516  HOTSPOT_JNI_NEWOBJECTARRAY_ENTRY(env, length, elementClass, initialElement);
2517   jobjectArray ret = NULL;
2518   DT_RETURN_MARK(NewObjectArray, jobjectArray, (const jobjectArray&amp;)ret);
2519   Klass* ek = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(elementClass));
2520   Klass* ak = ek-&gt;array_klass(CHECK_NULL);
2521   ObjArrayKlass::cast(ak)-&gt;initialize(CHECK_NULL);
2522   objArrayOop result = ObjArrayKlass::cast(ak)-&gt;allocate(length, CHECK_NULL);
2523   oop initial_value = JNIHandles::resolve(initialElement);
2524   if (initial_value != NULL) {  // array already initialized with NULL
2525     for (int index = 0; index &lt; length; index++) {
2526       result-&gt;obj_at_put(index, initial_value);
2527     }
2528   }
2529   ret = (jobjectArray) JNIHandles::make_local(env, result);
2530   return ret;
2531 JNI_END
2532 
2533 DT_RETURN_MARK_DECL(GetObjectArrayElement, jobject
2534                     , HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN(_ret_ref));
2535 
2536 JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
2537   JNIWrapper(&quot;GetObjectArrayElement&quot;);
2538  HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
2539   jobject ret = NULL;
2540   DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&amp;)ret);
2541   oop res = NULL;
2542   arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));
2543   if (arr-&gt;is_within_bounds(index)) {
2544     if (arr-&gt;is_valueArray()) {
2545       valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));
2546       arrayHandle ah(THREAD, a);
2547       valueArrayHandle vah(thread, a);
2548       res = valueArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK_NULL);
2549       assert(res != NULL, &quot;Must be set in one of two paths above&quot;);
2550     } else {
2551       assert(arr-&gt;is_objArray(), &quot;If not a valueArray. must be an objArray&quot;);
2552       objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2553       res = a-&gt;obj_at(index);
2554     }
2555   } else {
2556     ResourceMark rm(THREAD);
2557     stringStream ss;
2558     ss.print(&quot;Index %d out of bounds for length %d&quot;, index,arr-&gt;length());
2559     THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2560   }
2561   ret = JNIHandles::make_local(env, res);
2562   return ret;
2563 JNI_END
2564 
2565 DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
2566                          , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());
2567 
2568 JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
2569   JNIWrapper(&quot;SetObjectArrayElement&quot;);
2570   HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);
2571   DT_VOID_RETURN_MARK(SetObjectArrayElement);
2572 
2573    bool oob = false;
2574    int length = -1;
2575    oop res = NULL;
2576    arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));
2577    if (arr-&gt;is_within_bounds(index)) {
2578      if (arr-&gt;is_valueArray()) {
2579        valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));
2580        oop v = JNIHandles::resolve(value);
2581        ValueArrayKlass* vaklass = ValueArrayKlass::cast(a-&gt;klass());
2582        ValueKlass* element_vklass = vaklass-&gt;element_klass();
2583        if (v != NULL &amp;&amp; v-&gt;is_a(element_vklass)) {
2584          a-&gt;value_copy_to_index(v, index);
2585        } else {
2586          ResourceMark rm(THREAD);
2587          stringStream ss;
2588          Klass *kl = ValueArrayKlass::cast(a-&gt;klass());
2589          ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,
2590              v-&gt;klass()-&gt;external_name(),
2591              kl-&gt;external_name(),
2592              index);
2593          for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {
2594            ss.print(&quot;[]&quot;);
2595          }
2596          THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
2597        }
2598      } else {
2599        assert(arr-&gt;is_objArray(), &quot;If not a valueArray. must be an objArray&quot;);
2600        objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));
2601        oop v = JNIHandles::resolve(value);
2602        if (v == NULL || v-&gt;is_a(ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass())) {
2603          a-&gt;obj_at_put(index, v);
2604        } else {
2605          ResourceMark rm(THREAD);
2606          stringStream ss;
2607          Klass *bottom_kl = ObjArrayKlass::cast(a-&gt;klass())-&gt;bottom_klass();
2608          ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,
2609              v-&gt;klass()-&gt;external_name(),
2610              bottom_kl-&gt;is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)-&gt;element_type()] : bottom_kl-&gt;external_name(),
2611                  index);
2612          for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {
2613            ss.print(&quot;[]&quot;);
2614          }
2615          THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());
2616        }
2617      }
2618    } else {
2619      ResourceMark rm(THREAD);
2620      stringStream ss;
2621      ss.print(&quot;Index %d out of bounds for length %d&quot;, index, arr-&gt;length());
2622      THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2623    }
2624 JNI_END
2625 
2626 
2627 
2628 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
2629                               ,EntryProbe,ReturnProbe)  \
2630 \
2631   DT_RETURN_MARK_DECL(New##Result##Array, Return \
2632                       , ReturnProbe); \
2633 \
2634 JNI_ENTRY(Return, \
2635           jni_New##Result##Array(JNIEnv *env, jsize len)) \
2636   JNIWrapper(&quot;New&quot; XSTR(Result) &quot;Array&quot;); \
2637   EntryProbe; \
2638   Return ret = NULL;\
2639   DT_RETURN_MARK(New##Result##Array, Return, (const Return&amp;)ret);\
2640 \
2641   oop obj= oopFactory::Allocator(len, CHECK_NULL); \
2642   ret = (Return) JNIHandles::make_local(env, obj); \
2643   return ret;\
2644 JNI_END
2645 
2646 DEFINE_NEWSCALARARRAY(jbooleanArray, new_boolArray,   Boolean,
2647                       HOTSPOT_JNI_NEWBOOLEANARRAY_ENTRY(env, len),
2648                       HOTSPOT_JNI_NEWBOOLEANARRAY_RETURN(_ret_ref))
2649 DEFINE_NEWSCALARARRAY(jbyteArray,    new_byteArray,   Byte,
2650                       HOTSPOT_JNI_NEWBYTEARRAY_ENTRY(env, len),
2651                       HOTSPOT_JNI_NEWBYTEARRAY_RETURN(_ret_ref))
2652 DEFINE_NEWSCALARARRAY(jshortArray,   new_shortArray,  Short,
2653                       HOTSPOT_JNI_NEWSHORTARRAY_ENTRY(env, len),
2654                       HOTSPOT_JNI_NEWSHORTARRAY_RETURN(_ret_ref))
2655 DEFINE_NEWSCALARARRAY(jcharArray,    new_charArray,   Char,
2656                       HOTSPOT_JNI_NEWCHARARRAY_ENTRY(env, len),
2657                       HOTSPOT_JNI_NEWCHARARRAY_RETURN(_ret_ref))
2658 DEFINE_NEWSCALARARRAY(jintArray,     new_intArray,    Int,
2659                       HOTSPOT_JNI_NEWINTARRAY_ENTRY(env, len),
2660                       HOTSPOT_JNI_NEWINTARRAY_RETURN(_ret_ref))
2661 DEFINE_NEWSCALARARRAY(jlongArray,    new_longArray,   Long,
2662                       HOTSPOT_JNI_NEWLONGARRAY_ENTRY(env, len),
2663                       HOTSPOT_JNI_NEWLONGARRAY_RETURN(_ret_ref))
2664 DEFINE_NEWSCALARARRAY(jfloatArray,   new_floatArray,  Float,
2665                       HOTSPOT_JNI_NEWFLOATARRAY_ENTRY(env, len),
2666                       HOTSPOT_JNI_NEWFLOATARRAY_RETURN(_ret_ref))
2667 DEFINE_NEWSCALARARRAY(jdoubleArray,  new_doubleArray, Double,
2668                       HOTSPOT_JNI_NEWDOUBLEARRAY_ENTRY(env, len),
2669                       HOTSPOT_JNI_NEWDOUBLEARRAY_RETURN(_ret_ref))
2670 
2671 // Return an address which will fault if the caller writes to it.
2672 
2673 static char* get_bad_address() {
2674   static char* bad_address = NULL;
2675   if (bad_address == NULL) {
2676     size_t size = os::vm_allocation_granularity();
2677     bad_address = os::reserve_memory(size);
2678     if (bad_address != NULL) {
2679       os::protect_memory(bad_address, size, os::MEM_PROT_READ,
2680                          /*is_committed*/false);
2681       MemTracker::record_virtual_memory_type((void*)bad_address, mtInternal);
2682     }
2683   }
2684   return bad_address;
2685 }
2686 
2687 
2688 
2689 #define DEFINE_GETSCALARARRAYELEMENTS(ElementTag,ElementType,Result, Tag \
2690                                       , EntryProbe, ReturnProbe) \
2691 \
2692 JNI_ENTRY_NO_PRESERVE(ElementType*, \
2693           jni_Get##Result##ArrayElements(JNIEnv *env, ElementType##Array array, jboolean *isCopy)) \
2694   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2695   EntryProbe; \
2696   /* allocate an chunk of memory in c land */ \
2697   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2698   ElementType* result; \
2699   int len = a-&gt;length(); \
2700   if (len == 0) { \
2701     if (isCopy != NULL) { \
2702       *isCopy = JNI_FALSE; \
2703     } \
2704     /* Empty array: legal but useless, can&#39;t return NULL. \
2705      * Return a pointer to something useless. \
2706      * Avoid asserts in typeArrayOop. */ \
2707     result = (ElementType*)get_bad_address(); \
2708   } else { \
2709     /* JNI Specification states return NULL on OOM */                    \
2710     result = NEW_C_HEAP_ARRAY_RETURN_NULL(ElementType, len, mtInternal); \
2711     if (result != NULL) {                                                \
2712       /* copy the array to the c chunk */                                \
2713       ArrayAccess&lt;&gt;::arraycopy_to_native(a, typeArrayOopDesc::element_offset&lt;ElementType&gt;(0), \
2714                                          result, len);                   \
2715       if (isCopy) {                                                      \
2716         *isCopy = JNI_TRUE;                                              \
2717       }                                                                  \
2718     }                                                                    \
2719   } \
2720   ReturnProbe; \
2721   return result; \
2722 JNI_END
2723 
2724 DEFINE_GETSCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2725                               , HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2726                               HOTSPOT_JNI_GETBOOLEANARRAYELEMENTS_RETURN((uintptr_t*)result))
2727 DEFINE_GETSCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2728                               , HOTSPOT_JNI_GETBYTEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2729                               HOTSPOT_JNI_GETBYTEARRAYELEMENTS_RETURN((char*)result))
2730 DEFINE_GETSCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2731                               , HOTSPOT_JNI_GETSHORTARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2732                               HOTSPOT_JNI_GETSHORTARRAYELEMENTS_RETURN((uint16_t*)result))
2733 DEFINE_GETSCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2734                               , HOTSPOT_JNI_GETCHARARRAYELEMENTS_ENTRY(env, (uint16_t*) array, (uintptr_t *) isCopy),
2735                               HOTSPOT_JNI_GETCHARARRAYELEMENTS_RETURN(result))
2736 DEFINE_GETSCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2737                               , HOTSPOT_JNI_GETINTARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2738                               HOTSPOT_JNI_GETINTARRAYELEMENTS_RETURN((uint32_t*)result))
2739 DEFINE_GETSCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2740                               , HOTSPOT_JNI_GETLONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2741                               HOTSPOT_JNI_GETLONGARRAYELEMENTS_RETURN(((uintptr_t*)result)))
2742 // Float and double probes don&#39;t return value because dtrace doesn&#39;t currently support it
2743 DEFINE_GETSCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2744                               , HOTSPOT_JNI_GETFLOATARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2745                               HOTSPOT_JNI_GETFLOATARRAYELEMENTS_RETURN(result))
2746 DEFINE_GETSCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2747                               , HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) isCopy),
2748                               HOTSPOT_JNI_GETDOUBLEARRAYELEMENTS_RETURN(result))
2749 
2750 
2751 #define DEFINE_RELEASESCALARARRAYELEMENTS(ElementTag,ElementType,Result,Tag \
2752                                           , EntryProbe, ReturnProbe);\
2753 \
2754 JNI_ENTRY_NO_PRESERVE(void, \
2755           jni_Release##Result##ArrayElements(JNIEnv *env, ElementType##Array array, \
2756                                              ElementType *buf, jint mode)) \
2757   JNIWrapper(&quot;Release&quot; XSTR(Result) &quot;ArrayElements&quot;); \
2758   EntryProbe; \
2759   typeArrayOop a = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2760   int len = a-&gt;length(); \
2761   if (len != 0) {   /* Empty array:  nothing to free or copy. */  \
2762     if ((mode == 0) || (mode == JNI_COMMIT)) { \
2763       ArrayAccess&lt;&gt;::arraycopy_from_native(buf, a, typeArrayOopDesc::element_offset&lt;ElementType&gt;(0), len); \
2764     } \
2765     if ((mode == 0) || (mode == JNI_ABORT)) { \
2766       FreeHeap(buf); \
2767     } \
2768   } \
2769   ReturnProbe; \
2770 JNI_END
2771 
2772 DEFINE_RELEASESCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool
2773                                   , HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2774                                   HOTSPOT_JNI_RELEASEBOOLEANARRAYELEMENTS_RETURN())
2775 DEFINE_RELEASESCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte
2776                                   , HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_ENTRY(env, array, (char *) buf, mode),
2777                                   HOTSPOT_JNI_RELEASEBYTEARRAYELEMENTS_RETURN())
2778 DEFINE_RELEASESCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short
2779                                   ,  HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2780                                   HOTSPOT_JNI_RELEASESHORTARRAYELEMENTS_RETURN())
2781 DEFINE_RELEASESCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char
2782                                   ,  HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_ENTRY(env, array, (uint16_t *) buf, mode),
2783                                   HOTSPOT_JNI_RELEASECHARARRAYELEMENTS_RETURN())
2784 DEFINE_RELEASESCALARARRAYELEMENTS(T_INT,     jint,     Int,     int
2785                                   , HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_ENTRY(env, array, (uint32_t *) buf, mode),
2786                                   HOTSPOT_JNI_RELEASEINTARRAYELEMENTS_RETURN())
2787 DEFINE_RELEASESCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long
2788                                   , HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_ENTRY(env, array, (uintptr_t *) buf, mode),
2789                                   HOTSPOT_JNI_RELEASELONGARRAYELEMENTS_RETURN())
2790 DEFINE_RELEASESCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float
2791                                   , HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_ENTRY(env, array, (float *) buf, mode),
2792                                   HOTSPOT_JNI_RELEASEFLOATARRAYELEMENTS_RETURN())
2793 DEFINE_RELEASESCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double
2794                                   , HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_ENTRY(env, array, (double *) buf, mode),
2795                                   HOTSPOT_JNI_RELEASEDOUBLEARRAYELEMENTS_RETURN())
2796 
2797 static void check_bounds(jsize start, jsize copy_len, jsize array_len, TRAPS) {
2798   ResourceMark rm(THREAD);
2799   if (copy_len &lt; 0) {
2800     stringStream ss;
2801     ss.print(&quot;Length %d is negative&quot;, copy_len);
2802     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2803   } else if (start &lt; 0 || (start &gt; array_len - copy_len)) {
2804     stringStream ss;
2805     ss.print(&quot;Array region %d..&quot; INT64_FORMAT &quot; out of bounds for length %d&quot;,
2806              start, (int64_t)start+(int64_t)copy_len, array_len);
2807     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2808   }
2809 }
2810 
2811 #define DEFINE_GETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2812                                     , EntryProbe, ReturnProbe); \
2813   DT_VOID_RETURN_MARK_DECL(Get##Result##ArrayRegion \
2814                            , ReturnProbe); \
2815 \
2816 JNI_ENTRY(void, \
2817 jni_Get##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2818              jsize len, ElementType *buf)) \
2819   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;ArrayRegion&quot;); \
2820   EntryProbe; \
2821   DT_VOID_RETURN_MARK(Get##Result##ArrayRegion); \
2822   typeArrayOop src = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2823   check_bounds(start, len, src-&gt;length(), CHECK); \
2824   if (len &gt; 0) {    \
2825     ArrayAccess&lt;&gt;::arraycopy_to_native(src, typeArrayOopDesc::element_offset&lt;ElementType&gt;(start), buf, len); \
2826   } \
2827 JNI_END
2828 
2829 DEFINE_GETSCALARARRAYREGION(T_BOOLEAN, jboolean,Boolean, bool
2830                             , HOTSPOT_JNI_GETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2831                             HOTSPOT_JNI_GETBOOLEANARRAYREGION_RETURN());
2832 DEFINE_GETSCALARARRAYREGION(T_BYTE,    jbyte,   Byte,    byte
2833                             ,  HOTSPOT_JNI_GETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2834                             HOTSPOT_JNI_GETBYTEARRAYREGION_RETURN());
2835 DEFINE_GETSCALARARRAYREGION(T_SHORT,   jshort,  Short,   short
2836                             , HOTSPOT_JNI_GETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2837                             HOTSPOT_JNI_GETSHORTARRAYREGION_RETURN());
2838 DEFINE_GETSCALARARRAYREGION(T_CHAR,    jchar,   Char,    char
2839                             ,  HOTSPOT_JNI_GETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t*) buf),
2840                             HOTSPOT_JNI_GETCHARARRAYREGION_RETURN());
2841 DEFINE_GETSCALARARRAYREGION(T_INT,     jint,    Int,     int
2842                             , HOTSPOT_JNI_GETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t*) buf),
2843                             HOTSPOT_JNI_GETINTARRAYREGION_RETURN());
2844 DEFINE_GETSCALARARRAYREGION(T_LONG,    jlong,   Long,    long
2845                             ,  HOTSPOT_JNI_GETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2846                             HOTSPOT_JNI_GETLONGARRAYREGION_RETURN());
2847 DEFINE_GETSCALARARRAYREGION(T_FLOAT,   jfloat,  Float,   float
2848                             , HOTSPOT_JNI_GETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2849                             HOTSPOT_JNI_GETFLOATARRAYREGION_RETURN());
2850 DEFINE_GETSCALARARRAYREGION(T_DOUBLE,  jdouble, Double,  double
2851                             , HOTSPOT_JNI_GETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2852                             HOTSPOT_JNI_GETDOUBLEARRAYREGION_RETURN());
2853 
2854 
2855 #define DEFINE_SETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \
2856                                     , EntryProbe, ReturnProbe); \
2857   DT_VOID_RETURN_MARK_DECL(Set##Result##ArrayRegion \
2858                            ,ReturnProbe);           \
2859 \
2860 JNI_ENTRY(void, \
2861 jni_Set##Result##ArrayRegion(JNIEnv *env, ElementType##Array array, jsize start, \
2862              jsize len, const ElementType *buf)) \
2863   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;ArrayRegion&quot;); \
2864   EntryProbe; \
2865   DT_VOID_RETURN_MARK(Set##Result##ArrayRegion); \
2866   typeArrayOop dst = typeArrayOop(JNIHandles::resolve_non_null(array)); \
2867   check_bounds(start, len, dst-&gt;length(), CHECK); \
2868   if (len &gt; 0) { \
2869     ArrayAccess&lt;&gt;::arraycopy_from_native(buf, dst, typeArrayOopDesc::element_offset&lt;ElementType&gt;(start), len); \
2870   } \
2871 JNI_END
2872 
2873 DEFINE_SETSCALARARRAYREGION(T_BOOLEAN, jboolean, Boolean, bool
2874                             , HOTSPOT_JNI_SETBOOLEANARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *)buf),
2875                             HOTSPOT_JNI_SETBOOLEANARRAYREGION_RETURN())
2876 DEFINE_SETSCALARARRAYREGION(T_BYTE,    jbyte,    Byte,    byte
2877                             , HOTSPOT_JNI_SETBYTEARRAYREGION_ENTRY(env, array, start, len, (char *) buf),
2878                             HOTSPOT_JNI_SETBYTEARRAYREGION_RETURN())
2879 DEFINE_SETSCALARARRAYREGION(T_SHORT,   jshort,   Short,   short
2880                             , HOTSPOT_JNI_SETSHORTARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2881                             HOTSPOT_JNI_SETSHORTARRAYREGION_RETURN())
2882 DEFINE_SETSCALARARRAYREGION(T_CHAR,    jchar,    Char,    char
2883                             , HOTSPOT_JNI_SETCHARARRAYREGION_ENTRY(env, array, start, len, (uint16_t *) buf),
2884                             HOTSPOT_JNI_SETCHARARRAYREGION_RETURN())
2885 DEFINE_SETSCALARARRAYREGION(T_INT,     jint,     Int,     int
2886                             , HOTSPOT_JNI_SETINTARRAYREGION_ENTRY(env, array, start, len, (uint32_t *) buf),
2887                             HOTSPOT_JNI_SETINTARRAYREGION_RETURN())
2888 DEFINE_SETSCALARARRAYREGION(T_LONG,    jlong,    Long,    long
2889                             , HOTSPOT_JNI_SETLONGARRAYREGION_ENTRY(env, array, start, len, (uintptr_t *) buf),
2890                             HOTSPOT_JNI_SETLONGARRAYREGION_RETURN())
2891 DEFINE_SETSCALARARRAYREGION(T_FLOAT,   jfloat,   Float,   float
2892                             , HOTSPOT_JNI_SETFLOATARRAYREGION_ENTRY(env, array, start, len, (float *) buf),
2893                             HOTSPOT_JNI_SETFLOATARRAYREGION_RETURN())
2894 DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double
2895                             , HOTSPOT_JNI_SETDOUBLEARRAYREGION_ENTRY(env, array, start, len, (double *) buf),
2896                             HOTSPOT_JNI_SETDOUBLEARRAYREGION_RETURN())
2897 
2898 
2899 DT_RETURN_MARK_DECL(RegisterNatives, jint
2900                     , HOTSPOT_JNI_REGISTERNATIVES_RETURN(_ret_ref));
2901 
2902 JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz,
2903                                     const JNINativeMethod *methods,
2904                                     jint nMethods))
2905   JNIWrapper(&quot;RegisterNatives&quot;);
2906   HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods);
2907   jint ret = 0;
2908   DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret);
2909 
2910   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2911 
2912   // There are no restrictions on native code registering native methods,
2913   // which allows agents to redefine the bindings to native methods, however
2914   // we issue a warning if any code running outside of the boot/platform
2915   // loader is rebinding any native methods in classes loaded by the
2916   // boot/platform loader that are in named modules. That will catch changes
2917   // to platform classes while excluding classes added to the bootclasspath.
2918   bool do_warning = false;
2919 
2920   // Only instanceKlasses can have native methods
2921   if (k-&gt;is_instance_klass()) {
2922     oop cl = k-&gt;class_loader();
2923     InstanceKlass* ik = InstanceKlass::cast(k);
2924     // Check for a platform class
2925     if ((cl ==  NULL || SystemDictionary::is_platform_class_loader(cl)) &amp;&amp;
2926         ik-&gt;module()-&gt;is_named()) {
2927       Klass* caller = thread-&gt;security_get_caller_class(1);
2928       // If no caller class, or caller class has a different loader, then
2929       // issue a warning below.
2930       do_warning = (caller == NULL) || caller-&gt;class_loader() != cl;
2931     }
2932   }
2933 
2934 
2935   for (int index = 0; index &lt; nMethods; index++) {
2936     const char* meth_name = methods[index].name;
2937     const char* meth_sig = methods[index].signature;
2938     int meth_name_len = (int)strlen(meth_name);
2939 
2940     // The class should have been loaded (we have an instance of the class
2941     // passed in) so the method and signature should already be in the symbol
2942     // table.  If they&#39;re not there, the method doesn&#39;t exist.
2943     TempNewSymbol  name = SymbolTable::probe(meth_name, meth_name_len);
2944     TempNewSymbol  signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig));
2945 
2946     if (name == NULL || signature == NULL) {
2947       ResourceMark rm(THREAD);
2948       stringStream st;
2949       st.print(&quot;Method %s.%s%s not found&quot;, k-&gt;external_name(), meth_name, meth_sig);
2950       // Must return negative value on failure
2951       THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1);
2952     }
2953 
2954     if (do_warning) {
2955       ResourceMark rm(THREAD);
2956       log_warning(jni, resolve)(&quot;Re-registering of platform native method: %s.%s%s &quot;
2957               &quot;from code in a different classloader&quot;, k-&gt;external_name(), meth_name, meth_sig);
2958     }
2959 
2960     bool res = Method::register_native(k, name, signature,
2961                                        (address) methods[index].fnPtr, THREAD);
2962     if (!res) {
2963       ret = -1;
2964       break;
2965     }
2966   }
2967   return ret;
2968 JNI_END
2969 
2970 
2971 JNI_ENTRY(jint, jni_UnregisterNatives(JNIEnv *env, jclass clazz))
2972   JNIWrapper(&quot;UnregisterNatives&quot;);
2973  HOTSPOT_JNI_UNREGISTERNATIVES_ENTRY(env, clazz);
2974   Klass* k   = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2975   //%note jni_2
2976   if (k-&gt;is_instance_klass()) {
2977     for (int index = 0; index &lt; InstanceKlass::cast(k)-&gt;methods()-&gt;length(); index++) {
2978       Method* m = InstanceKlass::cast(k)-&gt;methods()-&gt;at(index);
2979       if (m-&gt;is_native()) {
2980         m-&gt;clear_native_function();
2981         m-&gt;set_signature_handler(NULL);
2982       }
2983     }
2984   }
2985  HOTSPOT_JNI_UNREGISTERNATIVES_RETURN(0);
2986   return 0;
2987 JNI_END
2988 
2989 //
2990 // Monitor functions
2991 //
2992 
2993 DT_RETURN_MARK_DECL(MonitorEnter, jint
2994                     , HOTSPOT_JNI_MONITORENTER_RETURN(_ret_ref));
2995 
2996 JNI_ENTRY(jint, jni_MonitorEnter(JNIEnv *env, jobject jobj))
2997  HOTSPOT_JNI_MONITORENTER_ENTRY(env, jobj);
2998   jint ret = JNI_ERR;
2999   DT_RETURN_MARK(MonitorEnter, jint, (const jint&amp;)ret);
3000 
3001   // If the object is null, we can&#39;t do anything with it
3002   if (jobj == NULL) {
3003     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
3004   }
3005 
3006   Handle obj(thread, JNIHandles::resolve_non_null(jobj));
3007   ObjectSynchronizer::jni_enter(obj, CHECK_(JNI_ERR));
3008   ret = JNI_OK;
3009   return ret;
3010 JNI_END
3011 
3012 DT_RETURN_MARK_DECL(MonitorExit, jint
3013                     , HOTSPOT_JNI_MONITOREXIT_RETURN(_ret_ref));
3014 
3015 JNI_ENTRY(jint, jni_MonitorExit(JNIEnv *env, jobject jobj))
3016  HOTSPOT_JNI_MONITOREXIT_ENTRY(env, jobj);
3017   jint ret = JNI_ERR;
3018   DT_RETURN_MARK(MonitorExit, jint, (const jint&amp;)ret);
3019 
3020   // Don&#39;t do anything with a null object
3021   if (jobj == NULL) {
3022     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_ERR);
3023   }
3024 
3025   Handle obj(THREAD, JNIHandles::resolve_non_null(jobj));
3026   ObjectSynchronizer::jni_exit(obj(), CHECK_(JNI_ERR));
3027 
3028   ret = JNI_OK;
3029   return ret;
3030 JNI_END
3031 
3032 //
3033 // Extensions
3034 //
3035 
3036 DT_VOID_RETURN_MARK_DECL(GetStringRegion
3037                          , HOTSPOT_JNI_GETSTRINGREGION_RETURN());
3038 
3039 JNI_ENTRY(void, jni_GetStringRegion(JNIEnv *env, jstring string, jsize start, jsize len, jchar *buf))
3040   JNIWrapper(&quot;GetStringRegion&quot;);
3041  HOTSPOT_JNI_GETSTRINGREGION_ENTRY(env, string, start, len, buf);
3042   DT_VOID_RETURN_MARK(GetStringRegion);
3043   oop s = JNIHandles::resolve_non_null(string);
3044   typeArrayOop s_value = java_lang_String::value(s);
3045   int s_len = java_lang_String::length(s, s_value);
3046   if (start &lt; 0 || len &lt; 0 || start &gt; s_len - len) {
3047     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
3048   } else {
3049     if (len &gt; 0) {
3050       bool is_latin1 = java_lang_String::is_latin1(s);
3051       if (!is_latin1) {
3052         ArrayAccess&lt;&gt;::arraycopy_to_native(s_value, typeArrayOopDesc::element_offset&lt;jchar&gt;(start),
3053                                            buf, len);
3054       } else {
3055         for (int i = 0; i &lt; len; i++) {
3056           buf[i] = ((jchar) s_value-&gt;byte_at(i + start)) &amp; 0xff;
3057         }
3058       }
3059     }
3060   }
3061 JNI_END
3062 
3063 DT_VOID_RETURN_MARK_DECL(GetStringUTFRegion
3064                          , HOTSPOT_JNI_GETSTRINGUTFREGION_RETURN());
3065 
3066 JNI_ENTRY(void, jni_GetStringUTFRegion(JNIEnv *env, jstring string, jsize start, jsize len, char *buf))
3067   JNIWrapper(&quot;GetStringUTFRegion&quot;);
3068  HOTSPOT_JNI_GETSTRINGUTFREGION_ENTRY(env, string, start, len, buf);
3069   DT_VOID_RETURN_MARK(GetStringUTFRegion);
3070   oop s = JNIHandles::resolve_non_null(string);
3071   typeArrayOop s_value = java_lang_String::value(s);
3072   int s_len = java_lang_String::length(s, s_value);
3073   if (start &lt; 0 || len &lt; 0 || start &gt; s_len - len) {
3074     THROW(vmSymbols::java_lang_StringIndexOutOfBoundsException());
3075   } else {
3076     //%note jni_7
3077     if (len &gt; 0) {
3078       // Assume the buffer is large enough as the JNI spec. does not require user error checking
3079       java_lang_String::as_utf8_string(s, s_value, start, len, buf, INT_MAX);
3080       // as_utf8_string null-terminates the result string
3081     } else {
3082       // JDK null-terminates the buffer even in len is zero
3083       if (buf != NULL) {
3084         buf[0] = 0;
3085       }
3086     }
3087   }
3088 JNI_END
3089 
3090 static oop lock_gc_or_pin_object(JavaThread* thread, jobject obj) {
3091   if (Universe::heap()-&gt;supports_object_pinning()) {
3092     const oop o = JNIHandles::resolve_non_null(obj);
3093     return Universe::heap()-&gt;pin_object(thread, o);
3094   } else {
3095     GCLocker::lock_critical(thread);
3096     return JNIHandles::resolve_non_null(obj);
3097   }
3098 }
3099 
3100 static void unlock_gc_or_unpin_object(JavaThread* thread, jobject obj) {
3101   if (Universe::heap()-&gt;supports_object_pinning()) {
3102     const oop o = JNIHandles::resolve_non_null(obj);
3103     return Universe::heap()-&gt;unpin_object(thread, o);
3104   } else {
3105     GCLocker::unlock_critical(thread);
3106   }
3107 }
3108 
3109 JNI_ENTRY(void*, jni_GetPrimitiveArrayCritical(JNIEnv *env, jarray array, jboolean *isCopy))
3110   JNIWrapper(&quot;GetPrimitiveArrayCritical&quot;);
3111  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_ENTRY(env, array, (uintptr_t *) isCopy);
3112   if (isCopy != NULL) {
3113     *isCopy = JNI_FALSE;
3114   }
3115   oop a = lock_gc_or_pin_object(thread, array);
3116   assert(a-&gt;is_array(), &quot;just checking&quot;);
3117   BasicType type;
3118   if (a-&gt;is_objArray()) {
3119     type = T_OBJECT;
3120   } else {
3121     type = TypeArrayKlass::cast(a-&gt;klass())-&gt;element_type();
3122   }
3123   void* ret = arrayOop(a)-&gt;base(type);
3124  HOTSPOT_JNI_GETPRIMITIVEARRAYCRITICAL_RETURN(ret);
3125   return ret;
3126 JNI_END
3127 
3128 
3129 JNI_ENTRY(void, jni_ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void *carray, jint mode))
3130   JNIWrapper(&quot;ReleasePrimitiveArrayCritical&quot;);
3131   HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_ENTRY(env, array, carray, mode);
3132   unlock_gc_or_unpin_object(thread, array);
3133 HOTSPOT_JNI_RELEASEPRIMITIVEARRAYCRITICAL_RETURN();
3134 JNI_END
3135 
3136 
3137 JNI_ENTRY(const jchar*, jni_GetStringCritical(JNIEnv *env, jstring string, jboolean *isCopy))
3138   JNIWrapper(&quot;GetStringCritical&quot;);
3139   HOTSPOT_JNI_GETSTRINGCRITICAL_ENTRY(env, string, (uintptr_t *) isCopy);
3140   oop s = lock_gc_or_pin_object(thread, string);
3141   typeArrayOop s_value = java_lang_String::value(s);
3142   bool is_latin1 = java_lang_String::is_latin1(s);
3143   if (isCopy != NULL) {
3144     *isCopy = is_latin1 ? JNI_TRUE : JNI_FALSE;
3145   }
3146   jchar* ret;
3147   if (!is_latin1) {
3148     ret = (jchar*) s_value-&gt;base(T_CHAR);
3149   } else {
3150     // Inflate latin1 encoded string to UTF16
3151     int s_len = java_lang_String::length(s, s_value);
3152     ret = NEW_C_HEAP_ARRAY_RETURN_NULL(jchar, s_len + 1, mtInternal);  // add one for zero termination
3153     /* JNI Specification states return NULL on OOM */
3154     if (ret != NULL) {
3155       for (int i = 0; i &lt; s_len; i++) {
3156         ret[i] = ((jchar) s_value-&gt;byte_at(i)) &amp; 0xff;
3157       }
3158       ret[s_len] = 0;
3159     }
3160   }
3161  HOTSPOT_JNI_GETSTRINGCRITICAL_RETURN((uint16_t *) ret);
3162   return ret;
3163 JNI_END
3164 
3165 
3166 JNI_ENTRY(void, jni_ReleaseStringCritical(JNIEnv *env, jstring str, const jchar *chars))
3167   JNIWrapper(&quot;ReleaseStringCritical&quot;);
3168   HOTSPOT_JNI_RELEASESTRINGCRITICAL_ENTRY(env, str, (uint16_t *) chars);
3169   // The str and chars arguments are ignored for UTF16 strings
3170   oop s = JNIHandles::resolve_non_null(str);
3171   bool is_latin1 = java_lang_String::is_latin1(s);
3172   if (is_latin1) {
3173     // For latin1 string, free jchar array allocated by earlier call to GetStringCritical.
3174     // This assumes that ReleaseStringCritical bookends GetStringCritical.
3175     FREE_C_HEAP_ARRAY(jchar, chars);
3176   }
3177   unlock_gc_or_unpin_object(thread, str);
3178 HOTSPOT_JNI_RELEASESTRINGCRITICAL_RETURN();
3179 JNI_END
3180 
3181 
3182 JNI_ENTRY(jweak, jni_NewWeakGlobalRef(JNIEnv *env, jobject ref))
3183   JNIWrapper(&quot;jni_NewWeakGlobalRef&quot;);
3184  HOTSPOT_JNI_NEWWEAKGLOBALREF_ENTRY(env, ref);
3185   Handle ref_handle(thread, JNIHandles::resolve(ref));
3186   jweak ret = JNIHandles::make_weak_global(ref_handle);
3187  HOTSPOT_JNI_NEWWEAKGLOBALREF_RETURN(ret);
3188   return ret;
3189 JNI_END
3190 
3191 // Must be JNI_ENTRY (with HandleMark)
3192 JNI_ENTRY(void, jni_DeleteWeakGlobalRef(JNIEnv *env, jweak ref))
3193   JNIWrapper(&quot;jni_DeleteWeakGlobalRef&quot;);
3194   HOTSPOT_JNI_DELETEWEAKGLOBALREF_ENTRY(env, ref);
3195   JNIHandles::destroy_weak_global(ref);
3196   HOTSPOT_JNI_DELETEWEAKGLOBALREF_RETURN();
3197 JNI_END
3198 
3199 
3200 JNI_ENTRY_NO_PRESERVE(jboolean, jni_ExceptionCheck(JNIEnv *env))
3201   JNIWrapper(&quot;jni_ExceptionCheck&quot;);
3202  HOTSPOT_JNI_EXCEPTIONCHECK_ENTRY(env);
3203   jni_check_async_exceptions(thread);
3204   jboolean ret = (thread-&gt;has_pending_exception()) ? JNI_TRUE : JNI_FALSE;
3205  HOTSPOT_JNI_EXCEPTIONCHECK_RETURN(ret);
3206   return ret;
3207 JNI_END
3208 
3209 
3210 // Initialization state for three routines below relating to
3211 // java.nio.DirectBuffers
3212 static          int directBufferSupportInitializeStarted = 0;
3213 static volatile int directBufferSupportInitializeEnded   = 0;
3214 static volatile int directBufferSupportInitializeFailed  = 0;
3215 static jclass    bufferClass                 = NULL;
3216 static jclass    directBufferClass           = NULL;
3217 static jclass    directByteBufferClass       = NULL;
3218 static jmethodID directByteBufferConstructor = NULL;
3219 static jfieldID  directBufferAddressField    = NULL;
3220 static jfieldID  bufferCapacityField         = NULL;
3221 
3222 static jclass lookupOne(JNIEnv* env, const char* name, TRAPS) {
3223   Handle loader;            // null (bootstrap) loader
3224   Handle protection_domain; // null protection domain
3225 
3226   TempNewSymbol sym = SymbolTable::new_symbol(name);
3227   jclass result =  find_class_from_class_loader(env, sym, true, loader, protection_domain, true, CHECK_NULL);
3228 
3229   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
3230     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
3231   }
3232   return result;
3233 }
3234 
3235 // These lookups are done with the NULL (bootstrap) ClassLoader to
3236 // circumvent any security checks that would be done by jni_FindClass.
3237 JNI_ENTRY(bool, lookupDirectBufferClasses(JNIEnv* env))
3238 {
3239   if ((bufferClass           = lookupOne(env, &quot;java/nio/Buffer&quot;, thread))           == NULL) { return false; }
3240   if ((directBufferClass     = lookupOne(env, &quot;sun/nio/ch/DirectBuffer&quot;, thread))   == NULL) { return false; }
3241   if ((directByteBufferClass = lookupOne(env, &quot;java/nio/DirectByteBuffer&quot;, thread)) == NULL) { return false; }
3242   return true;
3243 }
3244 JNI_END
3245 
3246 
3247 static bool initializeDirectBufferSupport(JNIEnv* env, JavaThread* thread) {
3248   if (directBufferSupportInitializeFailed) {
3249     return false;
3250   }
3251 
3252   if (Atomic::cmpxchg(&amp;directBufferSupportInitializeStarted, 0, 1) == 0) {
3253     if (!lookupDirectBufferClasses(env)) {
3254       directBufferSupportInitializeFailed = 1;
3255       return false;
3256     }
3257 
3258     // Make global references for these
3259     bufferClass           = (jclass) env-&gt;NewGlobalRef(bufferClass);
3260     directBufferClass     = (jclass) env-&gt;NewGlobalRef(directBufferClass);
3261     directByteBufferClass = (jclass) env-&gt;NewGlobalRef(directByteBufferClass);
3262 
3263     // Get needed field and method IDs
3264     directByteBufferConstructor = env-&gt;GetMethodID(directByteBufferClass, &quot;&lt;init&gt;&quot;, &quot;(JI)V&quot;);
3265     if (env-&gt;ExceptionCheck()) {
3266       env-&gt;ExceptionClear();
3267       directBufferSupportInitializeFailed = 1;
3268       return false;
3269     }
3270     directBufferAddressField    = env-&gt;GetFieldID(bufferClass, &quot;address&quot;, &quot;J&quot;);
3271     if (env-&gt;ExceptionCheck()) {
3272       env-&gt;ExceptionClear();
3273       directBufferSupportInitializeFailed = 1;
3274       return false;
3275     }
3276     bufferCapacityField         = env-&gt;GetFieldID(bufferClass, &quot;capacity&quot;, &quot;I&quot;);
3277     if (env-&gt;ExceptionCheck()) {
3278       env-&gt;ExceptionClear();
3279       directBufferSupportInitializeFailed = 1;
3280       return false;
3281     }
3282 
3283     if ((directByteBufferConstructor == NULL) ||
3284         (directBufferAddressField    == NULL) ||
3285         (bufferCapacityField         == NULL)) {
3286       directBufferSupportInitializeFailed = 1;
3287       return false;
3288     }
3289 
3290     directBufferSupportInitializeEnded = 1;
3291   } else {
3292     while (!directBufferSupportInitializeEnded &amp;&amp; !directBufferSupportInitializeFailed) {
3293       os::naked_yield();
3294     }
3295   }
3296 
3297   return !directBufferSupportInitializeFailed;
3298 }
3299 
3300 extern &quot;C&quot; jobject JNICALL jni_NewDirectByteBuffer(JNIEnv *env, void* address, jlong capacity)
3301 {
3302   // thread_from_jni_environment() will block if VM is gone.
3303   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3304 
3305   JNIWrapper(&quot;jni_NewDirectByteBuffer&quot;);
3306  HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_ENTRY(env, address, capacity);
3307 
3308   if (!directBufferSupportInitializeEnded) {
3309     if (!initializeDirectBufferSupport(env, thread)) {
3310       HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(NULL);
3311       return NULL;
3312     }
3313   }
3314 
3315   // Being paranoid about accidental sign extension on address
3316   jlong addr = (jlong) ((uintptr_t) address);
3317   // NOTE that package-private DirectByteBuffer constructor currently
3318   // takes int capacity
3319   jint  cap  = (jint)  capacity;
3320   jobject ret = env-&gt;NewObject(directByteBufferClass, directByteBufferConstructor, addr, cap);
3321   HOTSPOT_JNI_NEWDIRECTBYTEBUFFER_RETURN(ret);
3322   return ret;
3323 }
3324 
3325 DT_RETURN_MARK_DECL(GetDirectBufferAddress, void*
3326                     , HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_RETURN((void*) _ret_ref));
3327 
3328 extern &quot;C&quot; void* JNICALL jni_GetDirectBufferAddress(JNIEnv *env, jobject buf)
3329 {
3330   // thread_from_jni_environment() will block if VM is gone.
3331   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3332 
3333   JNIWrapper(&quot;jni_GetDirectBufferAddress&quot;);
3334   HOTSPOT_JNI_GETDIRECTBUFFERADDRESS_ENTRY(env, buf);
3335   void* ret = NULL;
3336   DT_RETURN_MARK(GetDirectBufferAddress, void*, (const void*&amp;)ret);
3337 
3338   if (!directBufferSupportInitializeEnded) {
3339     if (!initializeDirectBufferSupport(env, thread)) {
3340       return 0;
3341     }
3342   }
3343 
3344   if ((buf != NULL) &amp;&amp; (!env-&gt;IsInstanceOf(buf, directBufferClass))) {
3345     return 0;
3346   }
3347 
3348   ret = (void*)(intptr_t)env-&gt;GetLongField(buf, directBufferAddressField);
3349   return ret;
3350 }
3351 
3352 DT_RETURN_MARK_DECL(GetDirectBufferCapacity, jlong
3353                     , HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_RETURN(_ret_ref));
3354 
3355 extern &quot;C&quot; jlong JNICALL jni_GetDirectBufferCapacity(JNIEnv *env, jobject buf)
3356 {
3357   // thread_from_jni_environment() will block if VM is gone.
3358   JavaThread* thread = JavaThread::thread_from_jni_environment(env);
3359 
3360   JNIWrapper(&quot;jni_GetDirectBufferCapacity&quot;);
3361   HOTSPOT_JNI_GETDIRECTBUFFERCAPACITY_ENTRY(env, buf);
3362   jlong ret = -1;
3363   DT_RETURN_MARK(GetDirectBufferCapacity, jlong, (const jlong&amp;)ret);
3364 
3365   if (!directBufferSupportInitializeEnded) {
3366     if (!initializeDirectBufferSupport(env, thread)) {
3367       ret = 0;
3368       return ret;
3369     }
3370   }
3371 
3372   if (buf == NULL) {
3373     return -1;
3374   }
3375 
3376   if (!env-&gt;IsInstanceOf(buf, directBufferClass)) {
3377     return -1;
3378   }
3379 
3380   // NOTE that capacity is currently an int in the implementation
3381   ret = env-&gt;GetIntField(buf, bufferCapacityField);
3382   return ret;
3383 }
3384 
3385 
3386 JNI_LEAF(jint, jni_GetVersion(JNIEnv *env))
3387   JNIWrapper(&quot;GetVersion&quot;);
3388   HOTSPOT_JNI_GETVERSION_ENTRY(env);
3389   HOTSPOT_JNI_GETVERSION_RETURN(CurrentVersion);
3390   return CurrentVersion;
3391 JNI_END
3392 
3393 extern struct JavaVM_ main_vm;
3394 
3395 JNI_LEAF(jint, jni_GetJavaVM(JNIEnv *env, JavaVM **vm))
3396   JNIWrapper(&quot;jni_GetJavaVM&quot;);
3397   HOTSPOT_JNI_GETJAVAVM_ENTRY(env, (void **) vm);
3398   *vm  = (JavaVM *)(&amp;main_vm);
3399   HOTSPOT_JNI_GETJAVAVM_RETURN(JNI_OK);
3400   return JNI_OK;
3401 JNI_END
3402 
3403 
3404 JNI_ENTRY(jobject, jni_GetModule(JNIEnv* env, jclass clazz))
3405   JNIWrapper(&quot;GetModule&quot;);
3406   return Modules::get_module(clazz, THREAD);
3407 JNI_END
3408 
3409 
3410 JNI_ENTRY(void*, jni_GetFlattenedArrayElements(JNIEnv* env, jarray array, jboolean* isCopy))
3411   JNIWrapper(&quot;jni_GetFlattenedArrayElements&quot;);
3412   if (isCopy != NULL) {
3413     *isCopy = JNI_FALSE;
3414   }
3415   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));
3416   if (!ar-&gt;is_array()) {
3417     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3418   }
3419   if (!ar-&gt;is_valueArray()) {
3420     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3421   }
3422   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());
3423   if (vak-&gt;contains_oops()) {
3424     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Flattened array contains oops&quot;);
3425   }
3426   oop a = lock_gc_or_pin_object(thread, array);
3427   valueArrayOop vap = valueArrayOop(a);
3428   void* ret = vap-&gt;value_at_addr(0, vak-&gt;layout_helper());
3429   return ret;
3430 JNI_END
3431 
3432 JNI_ENTRY(void, jni_ReleaseFlattenedArrayElements(JNIEnv* env, jarray array, void* elem, jint mode))
3433   JNIWrapper(&quot;jni_ReleaseFlattenedArrayElements&quot;);
3434   unlock_gc_or_unpin_object(thread, array);
3435 JNI_END
3436 
3437 JNI_ENTRY(jsize, jni_GetFlattenedArrayElementSize(JNIEnv* env, jarray array)) {
3438   JNIWrapper(&quot;jni_GetFlattenedElementSize&quot;);
3439   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
3440   if (!a-&gt;is_array()) {
3441     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3442   }
3443   if (!a-&gt;is_valueArray()) {
3444     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3445   }
3446   ValueArrayKlass* vak = ValueArrayKlass::cast(a-&gt;klass());
3447   jsize ret = vak-&gt;element_byte_size();
3448   return ret;
3449 }
3450 JNI_END
3451 
3452 JNI_ENTRY(jclass, jni_GetFlattenedArrayElementClass(JNIEnv* env, jarray array))
3453   JNIWrapper(&quot;jni_GetArrayElementClass&quot;);
3454   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));
3455   if (!a-&gt;is_array()) {
3456     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3457   }
3458   if (!a-&gt;is_valueArray()) {
3459     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3460   }
3461   ValueArrayKlass* vak = ValueArrayKlass::cast(a-&gt;klass());
3462   ValueKlass* vk = vak-&gt;element_klass();
3463   return (jclass) JNIHandles::make_local(vk-&gt;java_mirror());
3464 JNI_END
3465 
3466 JNI_ENTRY(jsize, jni_GetFieldOffsetInFlattenedLayout(JNIEnv* env, jclass clazz, const char *name, const char *signature, jboolean* isFlattened))
3467   JNIWrapper(&quot;jni_GetFieldOffsetInFlattenedLayout&quot;);
3468 
3469   oop mirror = JNIHandles::resolve_non_null(clazz);
3470   Klass* k = java_lang_Class::as_Klass(mirror);
3471   if (!k-&gt;is_value()) {
3472     ResourceMark rm;
3473         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;%s has not flattened layout&quot;, k-&gt;external_name()));
3474   }
3475   ValueKlass* vk = ValueKlass::cast(k);
3476 
3477   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
3478   TempNewSymbol signame = SymbolTable::probe(signature, (int)strlen(signature));
3479   if (fieldname == NULL || signame == NULL) {
3480     ResourceMark rm;
3481     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, vk-&gt;external_name(), name, signature));
3482   }
3483 
3484   assert(vk-&gt;is_initialized(), &quot;If a flattened array has been created, the element klass must have been initialized&quot;);
3485 
3486   fieldDescriptor fd;
3487   if (!vk-&gt;is_instance_klass() ||
3488       !InstanceKlass::cast(vk)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
3489     ResourceMark rm;
3490     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, vk-&gt;external_name(), name, signature));
3491   }
3492 
3493   int offset = fd.offset() - vk-&gt;first_field_offset();
3494   if (isFlattened != NULL) {
3495     *isFlattened = fd.is_flattened();
3496   }
3497   return (jsize)offset;
3498 JNI_END
3499 
3500 JNI_ENTRY(jobject, jni_CreateSubElementSelector(JNIEnv* env, jarray array))
3501   JNIWrapper(&quot;jni_CreateSubElementSelector&quot;);
3502 
3503   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));
3504   if (!ar-&gt;is_array()) {
3505     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);
3506   }
3507   if (!ar-&gt;is_valueArray()) {
3508     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);
3509   }
3510   Klass* ses_k = SystemDictionary::resolve_or_null(vmSymbols::jdk_internal_vm_jni_SubElementSelector(),
3511         Handle(THREAD, SystemDictionary::java_system_loader()), Handle(), CHECK_NULL);
3512   InstanceKlass* ses_ik = InstanceKlass::cast(ses_k);
3513   ses_ik-&gt;initialize(CHECK_NULL);
3514   Klass* elementKlass = ArrayKlass::cast(ar-&gt;klass())-&gt;element_klass();
3515   oop ses = ses_ik-&gt;allocate_instance(CHECK_NULL);
3516   Handle ses_h(THREAD, ses);
3517   jdk_internal_vm_jni_SubElementSelector::setArrayElementType(ses_h(), elementKlass-&gt;java_mirror());
3518   jdk_internal_vm_jni_SubElementSelector::setSubElementType(ses_h(), elementKlass-&gt;java_mirror());
3519   jdk_internal_vm_jni_SubElementSelector::setOffset(ses_h(), 0);
3520   jdk_internal_vm_jni_SubElementSelector::setIsFlattened(ses_h(), true);   // by definition, top element of a flattened array is flattened
3521   jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(ses_h(), true); // by definition, top element of a flattened array is flattenable
3522   return JNIHandles::make_local(ses_h());
3523 JNI_END
3524 
3525 JNI_ENTRY(jobject, jni_GetSubElementSelector(JNIEnv* env, jobject selector, jfieldID fieldID))
3526   JNIWrapper(&quot;jni_GetSubElementSelector&quot;);
3527 
3528   oop slct = JNIHandles::resolve_non_null(selector);
3529   if (slct-&gt;klass()-&gt;name() != vmSymbols::jdk_internal_vm_jni_SubElementSelector()) {
3530     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a SubElementSelector&quot;);
3531   }
3532   jboolean isflattened = jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct);
3533   if (!isflattened) {
3534     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;SubElement is not flattened&quot;);
3535   }
3536   oop semirror = jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct);
3537   Klass* k = java_lang_Class::as_Klass(semirror);
3538   if (!k-&gt;is_value()) {
3539     ResourceMark rm;
3540         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;%s is not an inline type&quot;, k-&gt;external_name()));
3541   }
3542   ValueKlass* vk = ValueKlass::cast(k);
3543   assert(vk-&gt;is_initialized(), &quot;If a flattened array has been created, the element klass must have been initialized&quot;);
3544   int field_offset = jfieldIDWorkaround::from_instance_jfieldID(vk, fieldID);
3545   fieldDescriptor fd;
3546   if (!vk-&gt;find_field_from_offset(field_offset, false, &amp;fd)) {
3547     THROW_NULL(vmSymbols::java_lang_NoSuchFieldError());
3548   }
3549   Handle arrayElementMirror(THREAD, jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct));
3550   // offset of the SubElement is offset of the original SubElement plus the offset of the field inside the element
3551   int offset = fd.offset() - vk-&gt;first_field_offset() + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3552   InstanceKlass* sesklass = InstanceKlass::cast(JNIHandles::resolve_non_null(selector)-&gt;klass());
3553   oop res = sesklass-&gt;allocate_instance(CHECK_NULL);
3554   Handle res_h(THREAD, res);
3555   jdk_internal_vm_jni_SubElementSelector::setArrayElementType(res_h(), arrayElementMirror());
3556   InstanceKlass* holder = fd.field_holder();
3557   BasicType bt = Signature::basic_type(fd.signature());
3558   if (is_java_primitive(bt)) {
3559     jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(), java_lang_Class::primitive_mirror(bt));
3560   } else {
3561     Klass* fieldKlass = SystemDictionary::resolve_or_fail(fd.signature(), Handle(THREAD, holder-&gt;class_loader()),
3562         Handle(THREAD, holder-&gt;protection_domain()), true, CHECK_NULL);
3563     jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(),fieldKlass-&gt;java_mirror());
3564   }
3565   jdk_internal_vm_jni_SubElementSelector::setOffset(res_h(), offset);
3566   jdk_internal_vm_jni_SubElementSelector::setIsFlattened(res_h(), fd.is_flattened());
3567   jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(res_h(), fd.is_flattenable());
3568   return JNIHandles::make_local(res_h());
3569 JNI_END
3570 
3571 JNI_ENTRY(jobject, jni_GetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index))
3572   JNIWrapper(&quot;jni_GetObjectSubElement&quot;);
3573 
3574   valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);
3575   oop slct = JNIHandles::resolve_non_null(selector);
3576   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());
3577   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) {
3578     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;);
3579   }
3580   oop res = NULL;
3581   if (!jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct)) {
3582     int offset = (address)ar-&gt;base() - cast_from_oop&lt;address&gt;(ar) + index * vak-&gt;element_byte_size()
3583                       + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3584     res = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(ar, offset);
3585   } else {
3586     ValueKlass* fieldKlass = ValueKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));
3587     res = fieldKlass-&gt;allocate_instance(CHECK_NULL);
3588     // The array might have been moved by the GC, refreshing the arrayOop
3589     ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);
3590     address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper())
3591               + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3592     fieldKlass-&gt;value_copy_payload_to_new_oop(addr, res);
3593   }
3594   return JNIHandles::make_local(res);
3595 JNI_END
3596 
3597 JNI_ENTRY(void, jni_SetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index, jobject value))
3598   JNIWrapper(&quot;jni_SetObjectSubElement&quot;);
3599 
3600   valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);
3601   oop slct = JNIHandles::resolve_non_null(selector);
3602   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());
3603   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) {
3604     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;);
3605   }
3606   oop val = JNIHandles::resolve(value);
3607   if (val == NULL) {
3608     if (jdk_internal_vm_jni_SubElementSelector::getIsFlattenable(slct)) {
3609       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), &quot;null cannot be stored in a flattened array&quot;);
3610     }
3611   } else {
3612     if (!val-&gt;is_a(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)))) {
3613       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), &quot;type mismatch&quot;);
3614     }
3615   }
3616   if (!jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct)) {
3617     int offset = (address)ar-&gt;base() - cast_from_oop&lt;address&gt;(ar) + index * vak-&gt;element_byte_size()
3618                   + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3619     HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(ar, offset, JNIHandles::resolve(value));
3620   } else {
3621     ValueKlass* fieldKlass = ValueKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));
3622     address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper())
3623                   + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);
3624     fieldKlass-&gt;value_copy_oop_to_payload(JNIHandles::resolve_non_null(value), addr);
3625   }
3626 JNI_END
3627 
3628 #define DEFINE_GETSUBELEMENT(ElementType,Result,ElementBasicType) \
3629 \
3630 JNI_ENTRY(ElementType, \
3631           jni_Get##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index)) \
3632   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;SubElement&quot;); \
3633   valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \
3634   oop slct = JNIHandles::resolve_non_null(selector); \
3635   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass()); \
3636   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) { \
3637     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;); \
3638   } \
3639   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \
3640     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong SubElement type&quot;); \
3641   } \
3642   address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper()) \
3643                + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \
3644   ElementType result = *(ElementType*)addr; \
3645   return result; \
3646 JNI_END
3647 
3648 DEFINE_GETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)
3649 DEFINE_GETSUBELEMENT(jbyte, Byte, T_BYTE)
3650 DEFINE_GETSUBELEMENT(jshort, Short,T_SHORT)
3651 DEFINE_GETSUBELEMENT(jchar, Char,T_CHAR)
3652 DEFINE_GETSUBELEMENT(jint, Int,T_INT)
3653 DEFINE_GETSUBELEMENT(jlong, Long,T_LONG)
3654 DEFINE_GETSUBELEMENT(jfloat, Float,T_FLOAT)
3655 DEFINE_GETSUBELEMENT(jdouble, Double,T_DOUBLE)
3656 
3657 #define DEFINE_SETSUBELEMENT(ElementType,Result,ElementBasicType) \
3658 \
3659 JNI_ENTRY(void, \
3660           jni_Set##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index, ElementType value)) \
3661   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;SubElement&quot;); \
3662   valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \
3663   oop slct = JNIHandles::resolve_non_null(selector); \
3664   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass()); \
3665   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) { \
3666     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;); \
3667   } \
3668   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \
3669     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong SubElement type&quot;); \
3670   } \
3671   address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper()) \
3672                + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \
3673   *(ElementType*)addr = value; \
3674 JNI_END
3675 
3676 DEFINE_SETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)
3677 DEFINE_SETSUBELEMENT(jbyte, Byte, T_BYTE)
3678 DEFINE_SETSUBELEMENT(jshort, Short,T_SHORT)
3679 DEFINE_SETSUBELEMENT(jchar, Char,T_CHAR)
3680 DEFINE_SETSUBELEMENT(jint, Int,T_INT)
3681 DEFINE_SETSUBELEMENT(jlong, Long,T_LONG)
3682 DEFINE_SETSUBELEMENT(jfloat, Float,T_FLOAT)
3683 DEFINE_SETSUBELEMENT(jdouble, Double,T_DOUBLE)
3684 
3685 // Structure containing all jni functions
3686 struct JNINativeInterface_ jni_NativeInterface = {
3687     NULL,
3688     NULL,
3689     NULL,
3690 
3691     NULL,
3692 
3693     jni_GetVersion,
3694 
3695     jni_DefineClass,
3696     jni_FindClass,
3697 
3698     jni_FromReflectedMethod,
3699     jni_FromReflectedField,
3700 
3701     jni_ToReflectedMethod,
3702 
3703     jni_GetSuperclass,
3704     jni_IsAssignableFrom,
3705 
3706     jni_ToReflectedField,
3707 
3708     jni_Throw,
3709     jni_ThrowNew,
3710     jni_ExceptionOccurred,
3711     jni_ExceptionDescribe,
3712     jni_ExceptionClear,
3713     jni_FatalError,
3714 
3715     jni_PushLocalFrame,
3716     jni_PopLocalFrame,
3717 
3718     jni_NewGlobalRef,
3719     jni_DeleteGlobalRef,
3720     jni_DeleteLocalRef,
3721     jni_IsSameObject,
3722 
3723     jni_NewLocalRef,
3724     jni_EnsureLocalCapacity,
3725 
3726     jni_AllocObject,
3727     jni_NewObject,
3728     jni_NewObjectV,
3729     jni_NewObjectA,
3730 
3731     jni_GetObjectClass,
3732     jni_IsInstanceOf,
3733 
3734     jni_GetMethodID,
3735 
3736     jni_CallObjectMethod,
3737     jni_CallObjectMethodV,
3738     jni_CallObjectMethodA,
3739     jni_CallBooleanMethod,
3740     jni_CallBooleanMethodV,
3741     jni_CallBooleanMethodA,
3742     jni_CallByteMethod,
3743     jni_CallByteMethodV,
3744     jni_CallByteMethodA,
3745     jni_CallCharMethod,
3746     jni_CallCharMethodV,
3747     jni_CallCharMethodA,
3748     jni_CallShortMethod,
3749     jni_CallShortMethodV,
3750     jni_CallShortMethodA,
3751     jni_CallIntMethod,
3752     jni_CallIntMethodV,
3753     jni_CallIntMethodA,
3754     jni_CallLongMethod,
3755     jni_CallLongMethodV,
3756     jni_CallLongMethodA,
3757     jni_CallFloatMethod,
3758     jni_CallFloatMethodV,
3759     jni_CallFloatMethodA,
3760     jni_CallDoubleMethod,
3761     jni_CallDoubleMethodV,
3762     jni_CallDoubleMethodA,
3763     jni_CallVoidMethod,
3764     jni_CallVoidMethodV,
3765     jni_CallVoidMethodA,
3766 
3767     jni_CallNonvirtualObjectMethod,
3768     jni_CallNonvirtualObjectMethodV,
3769     jni_CallNonvirtualObjectMethodA,
3770     jni_CallNonvirtualBooleanMethod,
3771     jni_CallNonvirtualBooleanMethodV,
3772     jni_CallNonvirtualBooleanMethodA,
3773     jni_CallNonvirtualByteMethod,
3774     jni_CallNonvirtualByteMethodV,
3775     jni_CallNonvirtualByteMethodA,
3776     jni_CallNonvirtualCharMethod,
3777     jni_CallNonvirtualCharMethodV,
3778     jni_CallNonvirtualCharMethodA,
3779     jni_CallNonvirtualShortMethod,
3780     jni_CallNonvirtualShortMethodV,
3781     jni_CallNonvirtualShortMethodA,
3782     jni_CallNonvirtualIntMethod,
3783     jni_CallNonvirtualIntMethodV,
3784     jni_CallNonvirtualIntMethodA,
3785     jni_CallNonvirtualLongMethod,
3786     jni_CallNonvirtualLongMethodV,
3787     jni_CallNonvirtualLongMethodA,
3788     jni_CallNonvirtualFloatMethod,
3789     jni_CallNonvirtualFloatMethodV,
3790     jni_CallNonvirtualFloatMethodA,
3791     jni_CallNonvirtualDoubleMethod,
3792     jni_CallNonvirtualDoubleMethodV,
3793     jni_CallNonvirtualDoubleMethodA,
3794     jni_CallNonvirtualVoidMethod,
3795     jni_CallNonvirtualVoidMethodV,
3796     jni_CallNonvirtualVoidMethodA,
3797 
3798     jni_GetFieldID,
3799 
3800     jni_GetObjectField,
3801     jni_GetBooleanField,
3802     jni_GetByteField,
3803     jni_GetCharField,
3804     jni_GetShortField,
3805     jni_GetIntField,
3806     jni_GetLongField,
3807     jni_GetFloatField,
3808     jni_GetDoubleField,
3809 
3810     jni_SetObjectField,
3811     jni_SetBooleanField,
3812     jni_SetByteField,
3813     jni_SetCharField,
3814     jni_SetShortField,
3815     jni_SetIntField,
3816     jni_SetLongField,
3817     jni_SetFloatField,
3818     jni_SetDoubleField,
3819 
3820     jni_GetStaticMethodID,
3821 
3822     jni_CallStaticObjectMethod,
3823     jni_CallStaticObjectMethodV,
3824     jni_CallStaticObjectMethodA,
3825     jni_CallStaticBooleanMethod,
3826     jni_CallStaticBooleanMethodV,
3827     jni_CallStaticBooleanMethodA,
3828     jni_CallStaticByteMethod,
3829     jni_CallStaticByteMethodV,
3830     jni_CallStaticByteMethodA,
3831     jni_CallStaticCharMethod,
3832     jni_CallStaticCharMethodV,
3833     jni_CallStaticCharMethodA,
3834     jni_CallStaticShortMethod,
3835     jni_CallStaticShortMethodV,
3836     jni_CallStaticShortMethodA,
3837     jni_CallStaticIntMethod,
3838     jni_CallStaticIntMethodV,
3839     jni_CallStaticIntMethodA,
3840     jni_CallStaticLongMethod,
3841     jni_CallStaticLongMethodV,
3842     jni_CallStaticLongMethodA,
3843     jni_CallStaticFloatMethod,
3844     jni_CallStaticFloatMethodV,
3845     jni_CallStaticFloatMethodA,
3846     jni_CallStaticDoubleMethod,
3847     jni_CallStaticDoubleMethodV,
3848     jni_CallStaticDoubleMethodA,
3849     jni_CallStaticVoidMethod,
3850     jni_CallStaticVoidMethodV,
3851     jni_CallStaticVoidMethodA,
3852 
3853     jni_GetStaticFieldID,
3854 
3855     jni_GetStaticObjectField,
3856     jni_GetStaticBooleanField,
3857     jni_GetStaticByteField,
3858     jni_GetStaticCharField,
3859     jni_GetStaticShortField,
3860     jni_GetStaticIntField,
3861     jni_GetStaticLongField,
3862     jni_GetStaticFloatField,
3863     jni_GetStaticDoubleField,
3864 
3865     jni_SetStaticObjectField,
3866     jni_SetStaticBooleanField,
3867     jni_SetStaticByteField,
3868     jni_SetStaticCharField,
3869     jni_SetStaticShortField,
3870     jni_SetStaticIntField,
3871     jni_SetStaticLongField,
3872     jni_SetStaticFloatField,
3873     jni_SetStaticDoubleField,
3874 
3875     jni_NewString,
3876     jni_GetStringLength,
3877     jni_GetStringChars,
3878     jni_ReleaseStringChars,
3879 
3880     jni_NewStringUTF,
3881     jni_GetStringUTFLength,
3882     jni_GetStringUTFChars,
3883     jni_ReleaseStringUTFChars,
3884 
3885     jni_GetArrayLength,
3886 
3887     jni_NewObjectArray,
3888     jni_GetObjectArrayElement,
3889     jni_SetObjectArrayElement,
3890 
3891     jni_NewBooleanArray,
3892     jni_NewByteArray,
3893     jni_NewCharArray,
3894     jni_NewShortArray,
3895     jni_NewIntArray,
3896     jni_NewLongArray,
3897     jni_NewFloatArray,
3898     jni_NewDoubleArray,
3899 
3900     jni_GetBooleanArrayElements,
3901     jni_GetByteArrayElements,
3902     jni_GetCharArrayElements,
3903     jni_GetShortArrayElements,
3904     jni_GetIntArrayElements,
3905     jni_GetLongArrayElements,
3906     jni_GetFloatArrayElements,
3907     jni_GetDoubleArrayElements,
3908 
3909     jni_ReleaseBooleanArrayElements,
3910     jni_ReleaseByteArrayElements,
3911     jni_ReleaseCharArrayElements,
3912     jni_ReleaseShortArrayElements,
3913     jni_ReleaseIntArrayElements,
3914     jni_ReleaseLongArrayElements,
3915     jni_ReleaseFloatArrayElements,
3916     jni_ReleaseDoubleArrayElements,
3917 
3918     jni_GetBooleanArrayRegion,
3919     jni_GetByteArrayRegion,
3920     jni_GetCharArrayRegion,
3921     jni_GetShortArrayRegion,
3922     jni_GetIntArrayRegion,
3923     jni_GetLongArrayRegion,
3924     jni_GetFloatArrayRegion,
3925     jni_GetDoubleArrayRegion,
3926 
3927     jni_SetBooleanArrayRegion,
3928     jni_SetByteArrayRegion,
3929     jni_SetCharArrayRegion,
3930     jni_SetShortArrayRegion,
3931     jni_SetIntArrayRegion,
3932     jni_SetLongArrayRegion,
3933     jni_SetFloatArrayRegion,
3934     jni_SetDoubleArrayRegion,
3935 
3936     jni_RegisterNatives,
3937     jni_UnregisterNatives,
3938 
3939     jni_MonitorEnter,
3940     jni_MonitorExit,
3941 
3942     jni_GetJavaVM,
3943 
3944     jni_GetStringRegion,
3945     jni_GetStringUTFRegion,
3946 
3947     jni_GetPrimitiveArrayCritical,
3948     jni_ReleasePrimitiveArrayCritical,
3949 
3950     jni_GetStringCritical,
3951     jni_ReleaseStringCritical,
3952 
3953     jni_NewWeakGlobalRef,
3954     jni_DeleteWeakGlobalRef,
3955 
3956     jni_ExceptionCheck,
3957 
3958     jni_NewDirectByteBuffer,
3959     jni_GetDirectBufferAddress,
3960     jni_GetDirectBufferCapacity,
3961 
3962     // New 1_6 features
3963 
3964     jni_GetObjectRefType,
3965 
3966     // Module features
3967 
3968     jni_GetModule,
3969 
3970     // Flattened arrays features
3971 
3972     jni_GetFlattenedArrayElements,
3973     jni_ReleaseFlattenedArrayElements,
3974     jni_GetFlattenedArrayElementClass,
3975     jni_GetFlattenedArrayElementSize,
3976     jni_GetFieldOffsetInFlattenedLayout,
3977 
3978     jni_CreateSubElementSelector,
3979     jni_GetSubElementSelector,
3980     jni_GetObjectSubElement,
3981     jni_SetObjectSubElement,
3982 
3983     jni_GetBooleanSubElement,
3984     jni_GetByteSubElement,
3985     jni_GetShortSubElement,
3986     jni_GetCharSubElement,
3987     jni_GetIntSubElement,
3988     jni_GetLongSubElement,
3989     jni_GetFloatSubElement,
3990     jni_GetDoubleSubElement,
3991 
3992     jni_SetBooleanSubElement,
3993     jni_SetByteSubElement,
3994     jni_SetShortSubElement,
3995     jni_SetCharSubElement,
3996     jni_SetIntSubElement,
3997     jni_SetLongSubElement,
3998     jni_SetFloatSubElement,
3999     jni_SetDoubleSubElement
4000 };
4001 
4002 
4003 // For jvmti use to modify jni function table.
4004 // Java threads in native contiues to run until it is transitioned
4005 // to VM at safepoint. Before the transition or before it is blocked
4006 // for safepoint it may access jni function table. VM could crash if
4007 // any java thread access the jni function table in the middle of memcpy.
4008 // To avoid this each function pointers are copied automically.
4009 void copy_jni_function_table(const struct JNINativeInterface_ *new_jni_NativeInterface) {
4010   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
4011   intptr_t *a = (intptr_t *) jni_functions();
4012   intptr_t *b = (intptr_t *) new_jni_NativeInterface;
4013   for (uint i=0; i &lt;  sizeof(struct JNINativeInterface_)/sizeof(void *); i++) {
4014     Atomic::store(a++, *b++);
4015   }
4016 }
4017 
4018 void quicken_jni_functions() {
4019   // Replace Get&lt;Primitive&gt;Field with fast versions
4020   if (UseFastJNIAccessors &amp;&amp; !VerifyJNIFields &amp;&amp; !CountJNICalls &amp;&amp; !CheckJNICalls) {
4021     address func;
4022     func = JNI_FastGetField::generate_fast_get_boolean_field();
4023     if (func != (address)-1) {
4024       jni_NativeInterface.GetBooleanField = (GetBooleanField_t)func;
4025     }
4026     func = JNI_FastGetField::generate_fast_get_byte_field();
4027     if (func != (address)-1) {
4028       jni_NativeInterface.GetByteField = (GetByteField_t)func;
4029     }
4030     func = JNI_FastGetField::generate_fast_get_char_field();
4031     if (func != (address)-1) {
4032       jni_NativeInterface.GetCharField = (GetCharField_t)func;
4033     }
4034     func = JNI_FastGetField::generate_fast_get_short_field();
4035     if (func != (address)-1) {
4036       jni_NativeInterface.GetShortField = (GetShortField_t)func;
4037     }
4038     func = JNI_FastGetField::generate_fast_get_int_field();
4039     if (func != (address)-1) {
4040       jni_NativeInterface.GetIntField = (GetIntField_t)func;
4041     }
4042     func = JNI_FastGetField::generate_fast_get_long_field();
4043     if (func != (address)-1) {
4044       jni_NativeInterface.GetLongField = (GetLongField_t)func;
4045     }
4046     func = JNI_FastGetField::generate_fast_get_float_field();
4047     if (func != (address)-1) {
4048       jni_NativeInterface.GetFloatField = (GetFloatField_t)func;
4049     }
4050     func = JNI_FastGetField::generate_fast_get_double_field();
4051     if (func != (address)-1) {
4052       jni_NativeInterface.GetDoubleField = (GetDoubleField_t)func;
4053     }
4054   }
4055 }
4056 
4057 // Returns the function structure
4058 struct JNINativeInterface_* jni_functions() {
4059 #if INCLUDE_JNI_CHECK
4060   if (CheckJNICalls) return jni_functions_check();
4061 #endif // INCLUDE_JNI_CHECK
4062   return &amp;jni_NativeInterface;
4063 }
4064 
4065 // Returns the function structure
4066 struct JNINativeInterface_* jni_functions_nocheck() {
4067   return &amp;jni_NativeInterface;
4068 }
4069 
4070 static void post_thread_start_event(const JavaThread* jt) {
4071   assert(jt != NULL, &quot;invariant&quot;);
4072   EventThreadStart event;
4073   if (event.should_commit()) {
4074     event.set_thread(JFR_THREAD_ID(jt));
4075     event.set_parentThread((traceid)0);
4076 #if INCLUDE_JFR
4077     if (EventThreadStart::is_stacktrace_enabled()) {
4078       jt-&gt;jfr_thread_local()-&gt;set_cached_stack_trace_id((traceid)0);
4079       event.commit();
4080       jt-&gt;jfr_thread_local()-&gt;clear_cached_stack_trace();
4081     } else
4082 #endif
4083     {
4084       event.commit();
4085     }
4086   }
4087 }
4088 
4089 // Invocation API
4090 
4091 
4092 // Forward declaration
4093 extern const struct JNIInvokeInterface_ jni_InvokeInterface;
4094 
4095 // Global invocation API vars
4096 volatile int vm_created = 0;
4097 // Indicate whether it is safe to recreate VM. Recreation is only
4098 // possible after a failed initial creation attempt in some cases.
4099 volatile int safe_to_recreate_vm = 1;
4100 struct JavaVM_ main_vm = {&amp;jni_InvokeInterface};
4101 
4102 
4103 #define JAVASTACKSIZE (400 * 1024)    /* Default size of a thread java stack */
4104 enum { VERIFY_NONE, VERIFY_REMOTE, VERIFY_ALL };
4105 
4106 DT_RETURN_MARK_DECL(GetDefaultJavaVMInitArgs, jint
4107                     , HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_RETURN(_ret_ref));
4108 
4109 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *args_) {
4110   HOTSPOT_JNI_GETDEFAULTJAVAVMINITARGS_ENTRY(args_);
4111   JDK1_1InitArgs *args = (JDK1_1InitArgs *)args_;
4112   jint ret = JNI_ERR;
4113   DT_RETURN_MARK(GetDefaultJavaVMInitArgs, jint, (const jint&amp;)ret);
4114 
4115   if (Threads::is_supported_jni_version(args-&gt;version)) {
4116     ret = JNI_OK;
4117   }
4118   // 1.1 style no longer supported in hotspot.
4119   // According the JNI spec, we should update args-&gt;version on return.
4120   // We also use the structure to communicate with launcher about default
4121   // stack size.
4122   if (args-&gt;version == JNI_VERSION_1_1) {
4123     args-&gt;version = JNI_VERSION_1_2;
4124     // javaStackSize is int in arguments structure
4125     assert(jlong(ThreadStackSize) * K &lt; INT_MAX, &quot;integer overflow&quot;);
4126     args-&gt;javaStackSize = (jint)(ThreadStackSize * K);
4127   }
4128   return ret;
4129 }
4130 
4131 DT_RETURN_MARK_DECL(CreateJavaVM, jint
4132                     , HOTSPOT_JNI_CREATEJAVAVM_RETURN(_ret_ref));
4133 
4134 static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) {
4135   HOTSPOT_JNI_CREATEJAVAVM_ENTRY((void **) vm, penv, args);
4136 
4137   jint result = JNI_ERR;
4138   DT_RETURN_MARK(CreateJavaVM, jint, (const jint&amp;)result);
4139 
4140   // We&#39;re about to use Atomic::xchg for synchronization.  Some Zero
4141   // platforms use the GCC builtin __sync_lock_test_and_set for this,
4142   // but __sync_lock_test_and_set is not guaranteed to do what we want
4143   // on all architectures.  So we check it works before relying on it.
4144 #if defined(ZERO) &amp;&amp; defined(ASSERT)
4145   {
4146     jint a = 0xcafebabe;
4147     jint b = Atomic::xchg(&amp;a, (jint) 0xdeadbeef);
4148     void *c = &amp;a;
4149     void *d = Atomic::xchg(&amp;c, &amp;b);
4150     assert(a == (jint) 0xdeadbeef &amp;&amp; b == (jint) 0xcafebabe, &quot;Atomic::xchg() works&quot;);
4151     assert(c == &amp;b &amp;&amp; d == &amp;a, &quot;Atomic::xchg() works&quot;);
4152   }
4153 #endif // ZERO &amp;&amp; ASSERT
4154 
4155   // At the moment it&#39;s only possible to have one Java VM,
4156   // since some of the runtime state is in global variables.
4157 
4158   // We cannot use our mutex locks here, since they only work on
4159   // Threads. We do an atomic compare and exchange to ensure only
4160   // one thread can call this method at a time
4161 
4162   // We use Atomic::xchg rather than Atomic::add/dec since on some platforms
4163   // the add/dec implementations are dependent on whether we are running
4164   // on a multiprocessor Atomic::xchg does not have this problem.
4165   if (Atomic::xchg(&amp;vm_created, 1) == 1) {
4166     return JNI_EEXIST;   // already created, or create attempt in progress
4167   }
4168 
4169   // If a previous creation attempt failed but can be retried safely,
4170   // then safe_to_recreate_vm will have been reset to 1 after being
4171   // cleared here. If a previous creation attempt succeeded and we then
4172   // destroyed that VM, we will be prevented from trying to recreate
4173   // the VM in the same process, as the value will still be 0.
4174   if (Atomic::xchg(&amp;safe_to_recreate_vm, 0) == 0) {
4175     return JNI_ERR;
4176   }
4177 
4178   assert(vm_created == 1, &quot;vm_created is true during the creation&quot;);
4179 
4180   /**
4181    * Certain errors during initialization are recoverable and do not
4182    * prevent this method from being called again at a later time
4183    * (perhaps with different arguments).  However, at a certain
4184    * point during initialization if an error occurs we cannot allow
4185    * this function to be called again (or it will crash).  In those
4186    * situations, the &#39;canTryAgain&#39; flag is set to false, which atomically
4187    * sets safe_to_recreate_vm to 1, such that any new call to
4188    * JNI_CreateJavaVM will immediately fail using the above logic.
4189    */
4190   bool can_try_again = true;
4191 
4192   result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again);
4193   if (result == JNI_OK) {
4194     JavaThread *thread = JavaThread::current();
4195     assert(!thread-&gt;has_pending_exception(), &quot;should have returned not OK&quot;);
4196     /* thread is thread_in_vm here */
4197     *vm = (JavaVM *)(&amp;main_vm);
4198     *(JNIEnv**)penv = thread-&gt;jni_environment();
4199 
4200 #if INCLUDE_JVMCI
4201     if (EnableJVMCI) {
4202       if (UseJVMCICompiler) {
4203         // JVMCI is initialized on a CompilerThread
4204         if (BootstrapJVMCI) {
4205           JavaThread* THREAD = thread;
4206           JVMCICompiler* compiler = JVMCICompiler::instance(true, CATCH);
4207           compiler-&gt;bootstrap(THREAD);
4208           if (HAS_PENDING_EXCEPTION) {
4209             HandleMark hm;
4210             vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
4211           }
4212         }
4213       }
4214     }
4215 #endif
4216 
4217     // Notify JVMTI
4218     if (JvmtiExport::should_post_thread_life()) {
4219        JvmtiExport::post_thread_start(thread);
4220     }
4221 
4222     post_thread_start_event(thread);
4223 
4224 #ifndef PRODUCT
4225     if (ReplayCompiles) ciReplay::replay(thread);
4226 
4227     // Some platforms (like Win*) need a wrapper around these test
4228     // functions in order to properly handle error conditions.
4229     VMError::test_error_handler();
4230 #endif
4231 
4232     // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving.
4233     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
4234   } else {
4235     // If create_vm exits because of a pending exception, exit with that
4236     // exception.  In the future when we figure out how to reclaim memory,
4237     // we may be able to exit with JNI_ERR and allow the calling application
4238     // to continue.
4239     if (Universe::is_fully_initialized()) {
4240       // otherwise no pending exception possible - VM will already have aborted
4241       JavaThread* THREAD = JavaThread::current();
4242       if (HAS_PENDING_EXCEPTION) {
4243         HandleMark hm;
4244         vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION));
4245       }
4246     }
4247 
4248     if (can_try_again) {
4249       // reset safe_to_recreate_vm to 1 so that retrial would be possible
4250       safe_to_recreate_vm = 1;
4251     }
4252 
4253     // Creation failed. We must reset vm_created
4254     *vm = 0;
4255     *(JNIEnv**)penv = 0;
4256     // reset vm_created last to avoid race condition. Use OrderAccess to
4257     // control both compiler and architectural-based reordering.
4258     Atomic::release_store(&amp;vm_created, 0);
4259   }
4260 
4261   // Flush stdout and stderr before exit.
4262   fflush(stdout);
4263   fflush(stderr);
4264 
4265   return result;
4266 
4267 }
4268 
4269 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) {
4270   jint result = JNI_ERR;
4271   // On Windows, let CreateJavaVM run with SEH protection
4272 #ifdef _WIN32
4273   __try {
4274 #endif
4275     result = JNI_CreateJavaVM_inner(vm, penv, args);
4276 #ifdef _WIN32
4277   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
4278     // Nothing to do.
4279   }
4280 #endif
4281   return result;
4282 }
4283 
4284 _JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_GetCreatedJavaVMs(JavaVM **vm_buf, jsize bufLen, jsize *numVMs) {
4285   // See bug 4367188, the wrapper can sometimes cause VM crashes
4286   // JNIWrapper(&quot;GetCreatedJavaVMs&quot;);
4287 
4288   HOTSPOT_JNI_GETCREATEDJAVAVMS_ENTRY((void **) vm_buf, bufLen, (uintptr_t *) numVMs);
4289 
4290   if (vm_created == 1) {
4291     if (numVMs != NULL) *numVMs = 1;
4292     if (bufLen &gt; 0)     *vm_buf = (JavaVM *)(&amp;main_vm);
4293   } else {
4294     if (numVMs != NULL) *numVMs = 0;
4295   }
4296   HOTSPOT_JNI_GETCREATEDJAVAVMS_RETURN(JNI_OK);
4297   return JNI_OK;
4298 }
4299 
4300 extern &quot;C&quot; {
4301 
4302 DT_RETURN_MARK_DECL(DestroyJavaVM, jint
4303                     , HOTSPOT_JNI_DESTROYJAVAVM_RETURN(_ret_ref));
4304 
4305 static jint JNICALL jni_DestroyJavaVM_inner(JavaVM *vm) {
4306   HOTSPOT_JNI_DESTROYJAVAVM_ENTRY(vm);
4307   jint res = JNI_ERR;
4308   DT_RETURN_MARK(DestroyJavaVM, jint, (const jint&amp;)res);
4309 
4310   if (vm_created == 0) {
4311     res = JNI_ERR;
4312     return res;
4313   }
4314 
4315   JNIWrapper(&quot;DestroyJavaVM&quot;);
4316   JNIEnv *env;
4317   JavaVMAttachArgs destroyargs;
4318   destroyargs.version = CurrentVersion;
4319   destroyargs.name = (char *)&quot;DestroyJavaVM&quot;;
4320   destroyargs.group = NULL;
4321   res = vm-&gt;AttachCurrentThread((void **)&amp;env, (void *)&amp;destroyargs);
4322   if (res != JNI_OK) {
4323     return res;
4324   }
4325 
4326   // Since this is not a JVM_ENTRY we have to set the thread state manually before entering.
4327   JavaThread* thread = JavaThread::current();
4328   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4329   if (Threads::destroy_vm()) {
4330     // Should not change thread state, VM is gone
4331     vm_created = 0;
4332     res = JNI_OK;
4333     return res;
4334   } else {
4335     ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
4336     res = JNI_ERR;
4337     return res;
4338   }
4339 }
4340 
4341 jint JNICALL jni_DestroyJavaVM(JavaVM *vm) {
4342   jint result = JNI_ERR;
4343   // On Windows, we need SEH protection
4344 #ifdef _WIN32
4345   __try {
4346 #endif
4347     result = jni_DestroyJavaVM_inner(vm);
4348 #ifdef _WIN32
4349   } __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) {
4350     // Nothing to do.
4351   }
4352 #endif
4353   return result;
4354 }
4355 
4356 static jint attach_current_thread(JavaVM *vm, void **penv, void *_args, bool daemon) {
4357   JavaVMAttachArgs *args = (JavaVMAttachArgs *) _args;
4358 
4359   // Check below commented out from JDK1.2fcs as well
4360   /*
4361   if (args &amp;&amp; (args-&gt;version != JNI_VERSION_1_1 || args-&gt;version != JNI_VERSION_1_2)) {
4362     return JNI_EVERSION;
4363   }
4364   */
4365 
4366   Thread* t = Thread::current_or_null();
4367   if (t != NULL) {
4368     // If executing from an atexit hook we may be in the VMThread.
4369     if (t-&gt;is_Java_thread()) {
4370       // If the thread has been attached this operation is a no-op
4371       *(JNIEnv**)penv = ((JavaThread*) t)-&gt;jni_environment();
4372       return JNI_OK;
4373     } else {
4374       return JNI_ERR;
4375     }
4376   }
4377 
4378   // Create a thread and mark it as attaching so it will be skipped by the
4379   // ThreadsListEnumerator - see CR 6404306
4380   JavaThread* thread = new JavaThread(true);
4381 
4382   // Set correct safepoint info. The thread is going to call into Java when
4383   // initializing the Java level thread object. Hence, the correct state must
4384   // be set in order for the Safepoint code to deal with it correctly.
4385   thread-&gt;set_thread_state(_thread_in_vm);
4386   thread-&gt;record_stack_base_and_size();
4387   thread-&gt;register_thread_stack_with_NMT();
4388   thread-&gt;initialize_thread_current();
4389 
4390   if (!os::create_attached_thread(thread)) {
4391     thread-&gt;smr_delete();
4392     return JNI_ERR;
4393   }
4394   // Enable stack overflow checks
4395   thread-&gt;create_stack_guard_pages();
4396 
4397   thread-&gt;initialize_tlab();
4398 
4399   thread-&gt;cache_global_variables();
4400 
4401   // This thread will not do a safepoint check, since it has
4402   // not been added to the Thread list yet.
4403   { MutexLocker ml(Threads_lock);
4404     // This must be inside this lock in order to get FullGCALot to work properly, i.e., to
4405     // avoid this thread trying to do a GC before it is added to the thread-list
4406     thread-&gt;set_active_handles(JNIHandleBlock::allocate_block());
4407     Threads::add(thread, daemon);
4408   }
4409   // Create thread group and name info from attach arguments
4410   oop group = NULL;
4411   char* thread_name = NULL;
4412   if (args != NULL &amp;&amp; Threads::is_supported_jni_version(args-&gt;version)) {
4413     group = JNIHandles::resolve(args-&gt;group);
4414     thread_name = args-&gt;name; // may be NULL
4415   }
4416   if (group == NULL) group = Universe::main_thread_group();
4417 
4418   // Create Java level thread object and attach it to this thread
4419   bool attach_failed = false;
4420   {
4421     EXCEPTION_MARK;
4422     HandleMark hm(THREAD);
4423     Handle thread_group(THREAD, group);
4424     thread-&gt;allocate_threadObj(thread_group, thread_name, daemon, THREAD);
4425     if (HAS_PENDING_EXCEPTION) {
4426       CLEAR_PENDING_EXCEPTION;
4427       // cleanup outside the handle mark.
4428       attach_failed = true;
4429     }
4430   }
4431 
4432   if (attach_failed) {
4433     // Added missing cleanup
4434     thread-&gt;cleanup_failed_attach_current_thread(daemon);
4435     return JNI_ERR;
4436   }
4437 
4438   // mark the thread as no longer attaching
4439   // this uses a fence to push the change through so we don&#39;t have
4440   // to regrab the threads_lock
4441   thread-&gt;set_done_attaching_via_jni();
4442 
4443   // Set java thread status.
4444   java_lang_Thread::set_thread_status(thread-&gt;threadObj(),
4445               java_lang_Thread::RUNNABLE);
4446 
4447   // Notify the debugger
4448   if (JvmtiExport::should_post_thread_life()) {
4449     JvmtiExport::post_thread_start(thread);
4450   }
4451 
4452   post_thread_start_event(thread);
4453 
4454   *(JNIEnv**)penv = thread-&gt;jni_environment();
4455 
4456   // Now leaving the VM, so change thread_state. This is normally automatically taken care
4457   // of in the JVM_ENTRY. But in this situation we have to do it manually. Notice, that by
4458   // using ThreadStateTransition::transition, we do a callback to the safepoint code if
4459   // needed.
4460 
4461   ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);
4462 
4463   // Perform any platform dependent FPU setup
4464   os::setup_fpu();
4465 
4466   return JNI_OK;
4467 }
4468 
4469 
4470 jint JNICALL jni_AttachCurrentThread(JavaVM *vm, void **penv, void *_args) {
4471   HOTSPOT_JNI_ATTACHCURRENTTHREAD_ENTRY(vm, penv, _args);
4472   if (vm_created == 0) {
4473     HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4474     return JNI_ERR;
4475   }
4476 
4477   JNIWrapper(&quot;AttachCurrentThread&quot;);
4478   jint ret = attach_current_thread(vm, penv, _args, false);
4479   HOTSPOT_JNI_ATTACHCURRENTTHREAD_RETURN(ret);
4480   return ret;
4481 }
4482 
4483 
4484 jint JNICALL jni_DetachCurrentThread(JavaVM *vm)  {
4485   HOTSPOT_JNI_DETACHCURRENTTHREAD_ENTRY(vm);
4486   if (vm_created == 0) {
4487     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_ERR);
4488     return JNI_ERR;
4489   }
4490 
4491   JNIWrapper(&quot;DetachCurrentThread&quot;);
4492 
4493   Thread* current = Thread::current_or_null();
4494 
4495   // If the thread has already been detached the operation is a no-op
4496   if (current == NULL) {
4497     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4498     return JNI_OK;
4499   }
4500 
4501   // If executing from an atexit hook we may be in the VMThread.
4502   if (!current-&gt;is_Java_thread()) {
4503     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4504     return JNI_ERR;
4505   }
4506 
4507   VM_Exit::block_if_vm_exited();
4508 
4509   JavaThread* thread = (JavaThread*) current;
4510   if (thread-&gt;has_last_Java_frame()) {
4511     HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN((uint32_t) JNI_ERR);
4512     // Can&#39;t detach a thread that&#39;s running java, that can&#39;t work.
4513     return JNI_ERR;
4514   }
4515 
4516   // Safepoint support. Have to do call-back to safepoint code, if in the
4517   // middle of a safepoint operation
4518   ThreadStateTransition::transition_from_native(thread, _thread_in_vm);
4519 
4520   // XXX: Note that JavaThread::exit() call below removes the guards on the
4521   // stack pages set up via enable_stack_{red,yellow}_zone() calls
4522   // above in jni_AttachCurrentThread. Unfortunately, while the setting
4523   // of the guards is visible in jni_AttachCurrentThread above,
4524   // the removal of the guards is buried below in JavaThread::exit()
4525   // here. The abstraction should be more symmetrically either exposed
4526   // or hidden (e.g. it could probably be hidden in the same
4527   // (platform-dependent) methods where we do alternate stack
4528   // maintenance work?)
4529   thread-&gt;exit(false, JavaThread::jni_detach);
4530   thread-&gt;smr_delete();
4531 
4532   HOTSPOT_JNI_DETACHCURRENTTHREAD_RETURN(JNI_OK);
4533   return JNI_OK;
4534 }
4535 
4536 DT_RETURN_MARK_DECL(GetEnv, jint
4537                     , HOTSPOT_JNI_GETENV_RETURN(_ret_ref));
4538 
4539 jint JNICALL jni_GetEnv(JavaVM *vm, void **penv, jint version) {
4540   HOTSPOT_JNI_GETENV_ENTRY(vm, penv, version);
4541   jint ret = JNI_ERR;
4542   DT_RETURN_MARK(GetEnv, jint, (const jint&amp;)ret);
4543 
4544   if (vm_created == 0) {
4545     *penv = NULL;
4546     ret = JNI_EDETACHED;
4547     return ret;
4548   }
4549 
4550   if (JniExportedInterface::GetExportedInterface(vm, penv, version, &amp;ret)) {
4551     return ret;
4552   }
4553 
4554 #ifndef JVMPI_VERSION_1
4555 // need these in order to be polite about older agents
4556 #define JVMPI_VERSION_1   ((jint)0x10000001)
4557 #define JVMPI_VERSION_1_1 ((jint)0x10000002)
4558 #define JVMPI_VERSION_1_2 ((jint)0x10000003)
4559 #endif // !JVMPI_VERSION_1
4560 
4561   Thread* thread = Thread::current_or_null();
4562   if (thread != NULL &amp;&amp; thread-&gt;is_Java_thread()) {
4563     if (Threads::is_supported_jni_version_including_1_1(version)) {
4564       *(JNIEnv**)penv = ((JavaThread*) thread)-&gt;jni_environment();
4565       ret = JNI_OK;
4566       return ret;
4567 
4568     } else if (version == JVMPI_VERSION_1 ||
4569                version == JVMPI_VERSION_1_1 ||
4570                version == JVMPI_VERSION_1_2) {
4571       tty-&gt;print_cr(&quot;ERROR: JVMPI, an experimental interface, is no longer supported.&quot;);
4572       tty-&gt;print_cr(&quot;Please use the supported interface: the JVM Tool Interface (JVM TI).&quot;);
4573       ret = JNI_EVERSION;
4574       return ret;
4575     } else if (JvmtiExport::is_jvmdi_version(version)) {
4576       tty-&gt;print_cr(&quot;FATAL ERROR: JVMDI is no longer supported.&quot;);
4577       tty-&gt;print_cr(&quot;Please use the supported interface: the JVM Tool Interface (JVM TI).&quot;);
4578       ret = JNI_EVERSION;
4579       return ret;
4580     } else {
4581       *penv = NULL;
4582       ret = JNI_EVERSION;
4583       return ret;
4584     }
4585   } else {
4586     *penv = NULL;
4587     ret = JNI_EDETACHED;
4588     return ret;
4589   }
4590 }
4591 
4592 
4593 jint JNICALL jni_AttachCurrentThreadAsDaemon(JavaVM *vm, void **penv, void *_args) {
4594   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_ENTRY(vm, penv, _args);
4595   if (vm_created == 0) {
4596   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN((uint32_t) JNI_ERR);
4597     return JNI_ERR;
4598   }
4599 
4600   JNIWrapper(&quot;AttachCurrentThreadAsDaemon&quot;);
4601   jint ret = attach_current_thread(vm, penv, _args, true);
4602   HOTSPOT_JNI_ATTACHCURRENTTHREADASDAEMON_RETURN(ret);
4603   return ret;
4604 }
4605 
4606 
4607 } // End extern &quot;C&quot;
4608 
4609 const struct JNIInvokeInterface_ jni_InvokeInterface = {
4610     NULL,
4611     NULL,
4612     NULL,
4613 
4614     jni_DestroyJavaVM,
4615     jni_AttachCurrentThread,
4616     jni_DetachCurrentThread,
4617     jni_GetEnv,
4618     jni_AttachCurrentThreadAsDaemon
4619 };
    </pre>
  </body>
</html>
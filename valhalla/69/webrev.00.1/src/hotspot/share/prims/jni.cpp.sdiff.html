<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jni.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../opto/subnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="unsafe.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jni.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/allocation.inline.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/access.inline.hpp&quot;
  51 #include &quot;oops/arrayOop.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.inline.hpp&quot;
  53 #include &quot;oops/instanceOop.hpp&quot;
  54 #include &quot;oops/markWord.hpp&quot;
  55 #include &quot;oops/method.hpp&quot;
  56 #include &quot;oops/objArrayKlass.hpp&quot;
  57 #include &quot;oops/objArrayOop.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/symbol.hpp&quot;
  60 #include &quot;oops/typeArrayKlass.hpp&quot;
  61 #include &quot;oops/typeArrayOop.inline.hpp&quot;


  62 #include &quot;prims/jniCheck.hpp&quot;
  63 #include &quot;prims/jniExport.hpp&quot;
  64 #include &quot;prims/jniFastGetField.hpp&quot;
  65 #include &quot;prims/jvm_misc.hpp&quot;
  66 #include &quot;prims/jvmtiExport.hpp&quot;
  67 #include &quot;prims/jvmtiThreadState.hpp&quot;
  68 #include &quot;runtime/atomic.hpp&quot;
  69 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  70 #include &quot;runtime/handles.inline.hpp&quot;
  71 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  72 #include &quot;runtime/java.hpp&quot;
  73 #include &quot;runtime/javaCalls.hpp&quot;
  74 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  75 #include &quot;runtime/jniHandles.inline.hpp&quot;
  76 #include &quot;runtime/reflection.hpp&quot;
  77 #include &quot;runtime/safepointVerifiers.hpp&quot;
  78 #include &quot;runtime/sharedRuntime.hpp&quot;
  79 #include &quot;runtime/signature.hpp&quot;
  80 #include &quot;runtime/thread.inline.hpp&quot;
  81 #include &quot;runtime/vmOperations.hpp&quot;
</pre>
<hr />
<pre>
 481   int modifiers   = java_lang_reflect_Field::modifiers(reflected);
 482 
 483   // Make sure class is initialized before handing id&#39;s out to fields
 484   k1-&gt;initialize(CHECK_NULL);
 485 
 486   // First check if this is a static field
 487   if (modifiers &amp; JVM_ACC_STATIC) {
 488     intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 489     JNIid* id = InstanceKlass::cast(k1)-&gt;jni_id_for(offset);
 490     assert(id != NULL, &quot;corrupt Field object&quot;);
 491     debug_only(id-&gt;set_is_static_field_id();)
 492     // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
 493     ret = jfieldIDWorkaround::to_static_jfieldID(id);
 494     return ret;
 495   }
 496 
 497   // The slot is the index of the field description in the field-array
 498   // The jfieldID is the offset of the field within the object
 499   // It may also have hash bits for k, if VerifyJNIFields is turned on.
 500   intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );

 501   assert(InstanceKlass::cast(k1)-&gt;contains_field_offset(offset), &quot;stay within object&quot;);
<span class="line-modified"> 502   ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset);</span>
 503   return ret;
 504 JNI_END
 505 
 506 
 507 DT_RETURN_MARK_DECL(ToReflectedMethod, jobject
 508                     , HOTSPOT_JNI_TOREFLECTEDMETHOD_RETURN(_ret_ref));
 509 
 510 JNI_ENTRY(jobject, jni_ToReflectedMethod(JNIEnv *env, jclass cls, jmethodID method_id, jboolean isStatic))
 511   JNIWrapper(&quot;ToReflectedMethod&quot;);
 512 
 513   HOTSPOT_JNI_TOREFLECTEDMETHOD_ENTRY(env, cls, (uintptr_t) method_id, isStatic);
 514 
 515   jobject ret = NULL;
 516   DT_RETURN_MARK(ToReflectedMethod, jobject, (const jobject&amp;)ret);
 517 
 518   methodHandle m (THREAD, Method::resolve_jmethod_id(method_id));
 519   assert(m-&gt;is_static() == (isStatic != 0), &quot;jni_ToReflectedMethod access flags doesn&#39;t match&quot;);
 520   oop reflection_method;
<span class="line-modified"> 521   if (m-&gt;is_initializer()) {</span>
 522     reflection_method = Reflection::new_constructor(m, CHECK_NULL);
 523   } else {
 524     reflection_method = Reflection::new_method(m, false, CHECK_NULL);
 525   }
 526   ret = JNIHandles::make_local(env, reflection_method);
 527   return ret;
 528 JNI_END
 529 
 530 DT_RETURN_MARK_DECL(GetSuperclass, jclass
 531                     , HOTSPOT_JNI_GETSUPERCLASS_RETURN(_ret_ref));
 532 
 533 JNI_ENTRY(jclass, jni_GetSuperclass(JNIEnv *env, jclass sub))
 534   JNIWrapper(&quot;GetSuperclass&quot;);
 535 
 536   HOTSPOT_JNI_GETSUPERCLASS_ENTRY(env, sub);
 537 
 538   jclass obj = NULL;
 539   DT_RETURN_MARK(GetSuperclass, jclass, (const jclass&amp;)obj);
 540 
 541   oop mirror = JNIHandles::resolve_non_null(sub);
</pre>
<hr />
<pre>
 563 
 564 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))
 565   JNIWrapper(&quot;IsSubclassOf&quot;);
 566 
 567   HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(env, sub, super);
 568 
 569   oop sub_mirror   = JNIHandles::resolve_non_null(sub);
 570   oop super_mirror = JNIHandles::resolve_non_null(super);
 571   if (java_lang_Class::is_primitive(sub_mirror) ||
 572       java_lang_Class::is_primitive(super_mirror)) {
 573     jboolean ret = (sub_mirror == super_mirror);
 574 
 575     HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 576     return ret;
 577   }
 578   Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
 579   Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
 580   assert(sub_klass != NULL &amp;&amp; super_klass != NULL, &quot;invalid arguments to jni_IsAssignableFrom&quot;);
 581   jboolean ret = sub_klass-&gt;is_subtype_of(super_klass) ?
 582                    JNI_TRUE : JNI_FALSE;
<span class="line-removed"> 583 </span>
 584   HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 585   return ret;
 586 JNI_END
 587 
 588 
 589 DT_RETURN_MARK_DECL(Throw, jint
 590                     , HOTSPOT_JNI_THROW_RETURN(_ret_ref));
 591 
 592 JNI_ENTRY(jint, jni_Throw(JNIEnv *env, jthrowable obj))
 593   JNIWrapper(&quot;Throw&quot;);
 594 
 595   HOTSPOT_JNI_THROW_ENTRY(env, obj);
 596 
 597   jint ret = JNI_OK;
 598   DT_RETURN_MARK(Throw, jint, (const jint&amp;)ret);
 599 
 600   THROW_OOP_(JNIHandles::resolve(obj), JNI_OK);
 601   ShouldNotReachHere();
 602   return 0;  // Mute compiler.
 603 JNI_END
</pre>
<hr />
<pre>
 898   }
 899 
 900   friend class SignatureIterator;  // so do_parameters_on can call do_type
 901   void do_type(BasicType type) {
 902     switch (type) {
 903     // these are coerced to int when using va_arg
 904     case T_BYTE:
 905     case T_CHAR:
 906     case T_SHORT:
 907     case T_INT:         push_int(va_arg(_ap, jint)); break;
 908     case T_BOOLEAN:     push_boolean((jboolean) va_arg(_ap, jint)); break;
 909 
 910     // each of these paths is exercised by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests
 911 
 912     case T_LONG:        push_long(va_arg(_ap, jlong)); break;
 913     // float is coerced to double w/ va_arg
 914     case T_FLOAT:       push_float((jfloat) va_arg(_ap, jdouble)); break;
 915     case T_DOUBLE:      push_double(va_arg(_ap, jdouble)); break;
 916 
 917     case T_ARRAY:
<span class="line-modified"> 918     case T_OBJECT:      push_object(va_arg(_ap, jobject)); break;</span>

 919     default:            ShouldNotReachHere();
 920     }
 921   }
 922 
 923  public:
 924   JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
 925       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
 926     set_ap(rap);
 927   }
 928 
 929   virtual void push_arguments_on(JavaCallArguments* arguments) {
 930     _arguments = arguments;
 931     do_parameters_on(this);
 932   }
 933 };
 934 
 935 
 936 class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
 937  protected:
 938   const jvalue *_ap;
 939 
 940   inline void set_ap(const jvalue *rap) { _ap = rap; }
 941 
 942   friend class SignatureIterator;  // so do_parameters_on can call do_type
 943   void do_type(BasicType type) {
 944     switch (type) {
 945     case T_CHAR:        push_int((_ap++)-&gt;c); break;
 946     case T_SHORT:       push_int((_ap++)-&gt;s); break;
 947     case T_BYTE:        push_int((_ap++)-&gt;b); break;
 948     case T_INT:         push_int((_ap++)-&gt;i); break;
 949     case T_BOOLEAN:     push_boolean((_ap++)-&gt;z); break;
 950     case T_LONG:        push_long((_ap++)-&gt;j); break;
 951     case T_FLOAT:       push_float((_ap++)-&gt;f); break;
 952     case T_DOUBLE:      push_double((_ap++)-&gt;d); break;
 953     case T_ARRAY:
<span class="line-modified"> 954     case T_OBJECT:      push_object((_ap++)-&gt;l); break;</span>

 955     default:            ShouldNotReachHere();
 956     }
 957   }
 958 
 959  public:
 960   JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
 961       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
 962     set_ap(rap);
 963   }
 964 
 965   virtual void push_arguments_on(JavaCallArguments* arguments) {
 966     _arguments = arguments;
 967     do_parameters_on(this);
 968   }
 969 };
 970 
 971 
 972 enum JNICallType {
 973   JNI_STATIC,
 974   JNI_VIRTUAL,
</pre>
<hr />
<pre>
1074 
1075   jobject ret = NULL;
1076   DT_RETURN_MARK(AllocObject, jobject, (const jobject&amp;)ret);
1077 
1078   instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);
1079   ret = JNIHandles::make_local(env, i);
1080   return ret;
1081 JNI_END
1082 
1083 DT_RETURN_MARK_DECL(NewObjectA, jobject
1084                     , HOTSPOT_JNI_NEWOBJECTA_RETURN(_ret_ref));
1085 
1086 JNI_ENTRY(jobject, jni_NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args))
1087   JNIWrapper(&quot;NewObjectA&quot;);
1088 
1089   HOTSPOT_JNI_NEWOBJECTA_ENTRY(env, clazz, (uintptr_t) methodID);
1090 
1091   jobject obj = NULL;
1092   DT_RETURN_MARK(NewObjectA, jobject, (const jobject)obj);
1093 
<span class="line-modified">1094   instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);</span>
<span class="line-modified">1095   obj = JNIHandles::make_local(env, i);</span>
<span class="line-modified">1096   JavaValue jvalue(T_VOID);</span>
<span class="line-modified">1097   JNI_ArgumentPusherArray ap(methodID, args);</span>
<span class="line-modified">1098   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);</span>














1099   return obj;
<span class="line-modified">1100 JNI_END</span>
1101 
1102 
1103 DT_RETURN_MARK_DECL(NewObjectV, jobject
1104                     , HOTSPOT_JNI_NEWOBJECTV_RETURN(_ret_ref));
1105 
1106 JNI_ENTRY(jobject, jni_NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args))
1107   JNIWrapper(&quot;NewObjectV&quot;);
1108 
1109   HOTSPOT_JNI_NEWOBJECTV_ENTRY(env, clazz, (uintptr_t) methodID);
1110 
1111   jobject obj = NULL;
1112   DT_RETURN_MARK(NewObjectV, jobject, (const jobject&amp;)obj);
1113 
<span class="line-modified">1114   instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);</span>
<span class="line-modified">1115   obj = JNIHandles::make_local(env, i);</span>
<span class="line-modified">1116   JavaValue jvalue(T_VOID);</span>
<span class="line-modified">1117   JNI_ArgumentPusherVaArg ap(methodID, args);</span>
<span class="line-modified">1118   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);</span>














1119   return obj;
1120 JNI_END
1121 
1122 
1123 DT_RETURN_MARK_DECL(NewObject, jobject
1124                     , HOTSPOT_JNI_NEWOBJECT_RETURN(_ret_ref));
1125 
1126 JNI_ENTRY(jobject, jni_NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...))
1127   JNIWrapper(&quot;NewObject&quot;);
1128 
1129   HOTSPOT_JNI_NEWOBJECT_ENTRY(env, clazz, (uintptr_t) methodID);
1130 
1131   jobject obj = NULL;
1132   DT_RETURN_MARK(NewObject, jobject, (const jobject&amp;)obj);
1133 
<span class="line-modified">1134   instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);</span>
<span class="line-modified">1135   obj = JNIHandles::make_local(env, i);</span>
<span class="line-modified">1136   va_list args;</span>
<span class="line-modified">1137   va_start(args, methodID);</span>
<span class="line-modified">1138   JavaValue jvalue(T_VOID);</span>
<span class="line-modified">1139   JNI_ArgumentPusherVaArg ap(methodID, args);</span>
<span class="line-modified">1140   jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);</span>
<span class="line-modified">1141   va_end(args);</span>

















1142   return obj;
1143 JNI_END
1144 
1145 
1146 JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
1147   JNIWrapper(&quot;GetObjectClass&quot;);
1148 
1149   HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(env, obj);
1150 
1151   Klass* k = JNIHandles::resolve_non_null(obj)-&gt;klass();
1152   jclass ret =
1153     (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1154 
1155   HOTSPOT_JNI_GETOBJECTCLASS_RETURN(ret);
1156   return ret;
1157 JNI_END
1158 
1159 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))
1160   JNIWrapper(&quot;IsInstanceOf&quot;);
1161 
</pre>
<hr />
<pre>
1898   // table.  If they&#39;re not there, the field doesn&#39;t exist.
1899   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
1900   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
1901   if (fieldname == NULL || signame == NULL) {
1902     ResourceMark rm;
1903     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
1904   }
1905 
1906   // Make sure class is initialized before handing id&#39;s out to fields
1907   k-&gt;initialize(CHECK_NULL);
1908 
1909   fieldDescriptor fd;
1910   if (!k-&gt;is_instance_klass() ||
1911       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
1912     ResourceMark rm;
1913     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
1914   }
1915 
1916   // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
1917   // It may also have hash bits for k, if VerifyJNIFields is turned on.
<span class="line-modified">1918   ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset());</span>
1919   return ret;
1920 JNI_END
1921 
1922 
1923 JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
1924   JNIWrapper(&quot;GetObjectField&quot;);
1925   HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID);
1926   oop o = JNIHandles::resolve_non_null(obj);
1927   Klass* k = o-&gt;klass();
1928   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);

1929   // Keep JVMTI addition small and only check enabled flag here.
1930   // jni_GetField_probe() assumes that is okay to create handles.
1931   if (JvmtiExport::should_post_field_access()) {
1932     o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
1933   }
<span class="line-modified">1934   oop loaded_obj = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(o, offset);</span>
<span class="line-modified">1935   jobject ret = JNIHandles::make_local(env, loaded_obj);</span>










1936   HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
1937   return ret;
1938 JNI_END
1939 
1940 
1941 
1942 #define DEFINE_GETFIELD(Return,Fieldname,Result \
1943   , EntryProbe, ReturnProbe) \
1944 \
1945   DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
1946   , ReturnProbe); \
1947 \
1948 JNI_ENTRY_NO_PRESERVE(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \
1949   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;Field&quot;); \
1950 \
1951   EntryProbe; \
1952   Return ret = 0;\
1953   DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&amp;)ret);\
1954 \
1955   oop o = JNIHandles::resolve_non_null(obj); \
</pre>
<hr />
<pre>
2013   return (address)jni_GetFloatField;
2014 }
2015 address jni_GetDoubleField_addr() {
2016   return (address)jni_GetDoubleField;
2017 }
2018 
2019 JNI_ENTRY_NO_PRESERVE(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))
2020   JNIWrapper(&quot;SetObjectField&quot;);
2021   HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID, value);
2022   oop o = JNIHandles::resolve_non_null(obj);
2023   Klass* k = o-&gt;klass();
2024   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2025   // Keep JVMTI addition small and only check enabled flag here.
2026   // jni_SetField_probe_nh() assumes that is not okay to create handles
2027   // and creates a ResetNoHandleMark.
2028   if (JvmtiExport::should_post_field_modification()) {
2029     jvalue field_value;
2030     field_value.l = value;
2031     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);
2032   }
<span class="line-modified">2033   HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(o, offset, JNIHandles::resolve(value));</span>











2034   HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
2035 JNI_END
2036 
2037 
2038 #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
2039                         , EntryProbe, ReturnProbe) \
2040 \
2041 JNI_ENTRY_NO_PRESERVE(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \
2042   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;Field&quot;); \
2043 \
2044   EntryProbe; \
2045 \
2046   oop o = JNIHandles::resolve_non_null(obj); \
2047   Klass* k = o-&gt;klass(); \
2048   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2049   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2050   /* jni_SetField_probe_nh() assumes that is not okay to create handles */ \
2051   /* and creates a ResetNoHandleMark.                                   */ \
2052   if (JvmtiExport::should_post_field_modification()) { \
2053     jvalue field_value; \
</pre>
<hr />
<pre>
2450   ObjArrayKlass::cast(ak)-&gt;initialize(CHECK_NULL);
2451   objArrayOop result = ObjArrayKlass::cast(ak)-&gt;allocate(length, CHECK_NULL);
2452   oop initial_value = JNIHandles::resolve(initialElement);
2453   if (initial_value != NULL) {  // array already initialized with NULL
2454     for (int index = 0; index &lt; length; index++) {
2455       result-&gt;obj_at_put(index, initial_value);
2456     }
2457   }
2458   ret = (jobjectArray) JNIHandles::make_local(env, result);
2459   return ret;
2460 JNI_END
2461 
2462 DT_RETURN_MARK_DECL(GetObjectArrayElement, jobject
2463                     , HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN(_ret_ref));
2464 
2465 JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
2466   JNIWrapper(&quot;GetObjectArrayElement&quot;);
2467  HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
2468   jobject ret = NULL;
2469   DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&amp;)ret);
<span class="line-modified">2470   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-modified">2471   if (a-&gt;is_within_bounds(index)) {</span>
<span class="line-modified">2472     ret = JNIHandles::make_local(env, a-&gt;obj_at(index));</span>
<span class="line-modified">2473     return ret;</span>










2474   } else {
2475     ResourceMark rm(THREAD);
2476     stringStream ss;
<span class="line-modified">2477     ss.print(&quot;Index %d out of bounds for length %d&quot;, index, a-&gt;length());</span>
2478     THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2479   }


2480 JNI_END
2481 
2482 DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
2483                          , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());
2484 
2485 JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
2486   JNIWrapper(&quot;SetObjectArrayElement&quot;);
<span class="line-modified">2487  HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);</span>
2488   DT_VOID_RETURN_MARK(SetObjectArrayElement);
2489 
<span class="line-modified">2490   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-modified">2491   oop v = JNIHandles::resolve(value);</span>
<span class="line-modified">2492   if (a-&gt;is_within_bounds(index)) {</span>
<span class="line-modified">2493     if (v == NULL || v-&gt;is_a(ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass())) {</span>
<span class="line-modified">2494       a-&gt;obj_at_put(index, v);</span>
<span class="line-modified">2495     } else {</span>
<span class="line-modified">2496       ResourceMark rm(THREAD);</span>
<span class="line-modified">2497       stringStream ss;</span>
<span class="line-modified">2498       Klass *bottom_kl = ObjArrayKlass::cast(a-&gt;klass())-&gt;bottom_klass();</span>
<span class="line-modified">2499       ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,</span>
<span class="line-modified">2500                v-&gt;klass()-&gt;external_name(),</span>
<span class="line-modified">2501                bottom_kl-&gt;is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)-&gt;element_type()] : bottom_kl-&gt;external_name(),</span>
<span class="line-modified">2502                index);</span>
<span class="line-modified">2503       for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {</span>
<span class="line-modified">2504         ss.print(&quot;[]&quot;);</span>
<span class="line-modified">2505       }</span>
<span class="line-modified">2506       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());</span>
<span class="line-modified">2507     }</span>
<span class="line-modified">2508   } else {</span>
<span class="line-modified">2509     ResourceMark rm(THREAD);</span>
<span class="line-modified">2510     stringStream ss;</span>
<span class="line-modified">2511     ss.print(&quot;Index %d out of bounds for length %d&quot;, index, a-&gt;length());</span>
<span class="line-modified">2512     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());</span>
<span class="line-modified">2513   }</span>



























2514 JNI_END
2515 
2516 
2517 
2518 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
2519                               ,EntryProbe,ReturnProbe)  \
2520 \
2521   DT_RETURN_MARK_DECL(New##Result##Array, Return \
2522                       , ReturnProbe); \
2523 \
2524 JNI_ENTRY(Return, \
2525           jni_New##Result##Array(JNIEnv *env, jsize len)) \
2526   JNIWrapper(&quot;New&quot; XSTR(Result) &quot;Array&quot;); \
2527   EntryProbe; \
2528   Return ret = NULL;\
2529   DT_RETURN_MARK(New##Result##Array, Return, (const Return&amp;)ret);\
2530 \
2531   oop obj= oopFactory::Allocator(len, CHECK_NULL); \
2532   ret = (Return) JNIHandles::make_local(env, obj); \
2533   return ret;\
</pre>
<hr />
<pre>
3280   return CurrentVersion;
3281 JNI_END
3282 
3283 extern struct JavaVM_ main_vm;
3284 
3285 JNI_LEAF(jint, jni_GetJavaVM(JNIEnv *env, JavaVM **vm))
3286   JNIWrapper(&quot;jni_GetJavaVM&quot;);
3287   HOTSPOT_JNI_GETJAVAVM_ENTRY(env, (void **) vm);
3288   *vm  = (JavaVM *)(&amp;main_vm);
3289   HOTSPOT_JNI_GETJAVAVM_RETURN(JNI_OK);
3290   return JNI_OK;
3291 JNI_END
3292 
3293 
3294 JNI_ENTRY(jobject, jni_GetModule(JNIEnv* env, jclass clazz))
3295   JNIWrapper(&quot;GetModule&quot;);
3296   return Modules::get_module(clazz, THREAD);
3297 JNI_END
3298 
3299 



















































































































































































































































































3300 // Structure containing all jni functions
3301 struct JNINativeInterface_ jni_NativeInterface = {
3302     NULL,
3303     NULL,
3304     NULL,
3305 
3306     NULL,
3307 
3308     jni_GetVersion,
3309 
3310     jni_DefineClass,
3311     jni_FindClass,
3312 
3313     jni_FromReflectedMethod,
3314     jni_FromReflectedField,
3315 
3316     jni_ToReflectedMethod,
3317 
3318     jni_GetSuperclass,
3319     jni_IsAssignableFrom,
</pre>
<hr />
<pre>
3563     jni_ReleasePrimitiveArrayCritical,
3564 
3565     jni_GetStringCritical,
3566     jni_ReleaseStringCritical,
3567 
3568     jni_NewWeakGlobalRef,
3569     jni_DeleteWeakGlobalRef,
3570 
3571     jni_ExceptionCheck,
3572 
3573     jni_NewDirectByteBuffer,
3574     jni_GetDirectBufferAddress,
3575     jni_GetDirectBufferCapacity,
3576 
3577     // New 1_6 features
3578 
3579     jni_GetObjectRefType,
3580 
3581     // Module features
3582 
<span class="line-modified">3583     jni_GetModule</span>































3584 };
3585 
3586 
3587 // For jvmti use to modify jni function table.
3588 // Java threads in native contiues to run until it is transitioned
3589 // to VM at safepoint. Before the transition or before it is blocked
3590 // for safepoint it may access jni function table. VM could crash if
3591 // any java thread access the jni function table in the middle of memcpy.
3592 // To avoid this each function pointers are copied automically.
3593 void copy_jni_function_table(const struct JNINativeInterface_ *new_jni_NativeInterface) {
3594   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
3595   intptr_t *a = (intptr_t *) jni_functions();
3596   intptr_t *b = (intptr_t *) new_jni_NativeInterface;
3597   for (uint i=0; i &lt;  sizeof(struct JNINativeInterface_)/sizeof(void *); i++) {
3598     Atomic::store(a++, *b++);
3599   }
3600 }
3601 
3602 void quicken_jni_functions() {
3603   // Replace Get&lt;Primitive&gt;Field with fast versions
</pre>
</td>
<td>
<hr />
<pre>
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;jfr/support/jfrThreadId.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/allocation.inline.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/access.inline.hpp&quot;
  51 #include &quot;oops/arrayOop.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.inline.hpp&quot;
  53 #include &quot;oops/instanceOop.hpp&quot;
  54 #include &quot;oops/markWord.hpp&quot;
  55 #include &quot;oops/method.hpp&quot;
  56 #include &quot;oops/objArrayKlass.hpp&quot;
  57 #include &quot;oops/objArrayOop.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/symbol.hpp&quot;
  60 #include &quot;oops/typeArrayKlass.hpp&quot;
  61 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<span class="line-added">  62 #include &quot;oops/valueArrayOop.inline.hpp&quot;</span>
<span class="line-added">  63 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  64 #include &quot;prims/jniCheck.hpp&quot;
  65 #include &quot;prims/jniExport.hpp&quot;
  66 #include &quot;prims/jniFastGetField.hpp&quot;
  67 #include &quot;prims/jvm_misc.hpp&quot;
  68 #include &quot;prims/jvmtiExport.hpp&quot;
  69 #include &quot;prims/jvmtiThreadState.hpp&quot;
  70 #include &quot;runtime/atomic.hpp&quot;
  71 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  72 #include &quot;runtime/handles.inline.hpp&quot;
  73 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  74 #include &quot;runtime/java.hpp&quot;
  75 #include &quot;runtime/javaCalls.hpp&quot;
  76 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  77 #include &quot;runtime/jniHandles.inline.hpp&quot;
  78 #include &quot;runtime/reflection.hpp&quot;
  79 #include &quot;runtime/safepointVerifiers.hpp&quot;
  80 #include &quot;runtime/sharedRuntime.hpp&quot;
  81 #include &quot;runtime/signature.hpp&quot;
  82 #include &quot;runtime/thread.inline.hpp&quot;
  83 #include &quot;runtime/vmOperations.hpp&quot;
</pre>
<hr />
<pre>
 483   int modifiers   = java_lang_reflect_Field::modifiers(reflected);
 484 
 485   // Make sure class is initialized before handing id&#39;s out to fields
 486   k1-&gt;initialize(CHECK_NULL);
 487 
 488   // First check if this is a static field
 489   if (modifiers &amp; JVM_ACC_STATIC) {
 490     intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
 491     JNIid* id = InstanceKlass::cast(k1)-&gt;jni_id_for(offset);
 492     assert(id != NULL, &quot;corrupt Field object&quot;);
 493     debug_only(id-&gt;set_is_static_field_id();)
 494     // A jfieldID for a static field is a JNIid specifying the field holder and the offset within the Klass*
 495     ret = jfieldIDWorkaround::to_static_jfieldID(id);
 496     return ret;
 497   }
 498 
 499   // The slot is the index of the field description in the field-array
 500   // The jfieldID is the offset of the field within the object
 501   // It may also have hash bits for k, if VerifyJNIFields is turned on.
 502   intptr_t offset = InstanceKlass::cast(k1)-&gt;field_offset( slot );
<span class="line-added"> 503   bool is_flattened = InstanceKlass::cast(k1)-&gt;field_is_flattened(slot);</span>
 504   assert(InstanceKlass::cast(k1)-&gt;contains_field_offset(offset), &quot;stay within object&quot;);
<span class="line-modified"> 505   ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset, is_flattened);</span>
 506   return ret;
 507 JNI_END
 508 
 509 
 510 DT_RETURN_MARK_DECL(ToReflectedMethod, jobject
 511                     , HOTSPOT_JNI_TOREFLECTEDMETHOD_RETURN(_ret_ref));
 512 
 513 JNI_ENTRY(jobject, jni_ToReflectedMethod(JNIEnv *env, jclass cls, jmethodID method_id, jboolean isStatic))
 514   JNIWrapper(&quot;ToReflectedMethod&quot;);
 515 
 516   HOTSPOT_JNI_TOREFLECTEDMETHOD_ENTRY(env, cls, (uintptr_t) method_id, isStatic);
 517 
 518   jobject ret = NULL;
 519   DT_RETURN_MARK(ToReflectedMethod, jobject, (const jobject&amp;)ret);
 520 
 521   methodHandle m (THREAD, Method::resolve_jmethod_id(method_id));
 522   assert(m-&gt;is_static() == (isStatic != 0), &quot;jni_ToReflectedMethod access flags doesn&#39;t match&quot;);
 523   oop reflection_method;
<span class="line-modified"> 524   if (m-&gt;is_object_constructor()) {</span>
 525     reflection_method = Reflection::new_constructor(m, CHECK_NULL);
 526   } else {
 527     reflection_method = Reflection::new_method(m, false, CHECK_NULL);
 528   }
 529   ret = JNIHandles::make_local(env, reflection_method);
 530   return ret;
 531 JNI_END
 532 
 533 DT_RETURN_MARK_DECL(GetSuperclass, jclass
 534                     , HOTSPOT_JNI_GETSUPERCLASS_RETURN(_ret_ref));
 535 
 536 JNI_ENTRY(jclass, jni_GetSuperclass(JNIEnv *env, jclass sub))
 537   JNIWrapper(&quot;GetSuperclass&quot;);
 538 
 539   HOTSPOT_JNI_GETSUPERCLASS_ENTRY(env, sub);
 540 
 541   jclass obj = NULL;
 542   DT_RETURN_MARK(GetSuperclass, jclass, (const jclass&amp;)obj);
 543 
 544   oop mirror = JNIHandles::resolve_non_null(sub);
</pre>
<hr />
<pre>
 566 
 567 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsAssignableFrom(JNIEnv *env, jclass sub, jclass super))
 568   JNIWrapper(&quot;IsSubclassOf&quot;);
 569 
 570   HOTSPOT_JNI_ISASSIGNABLEFROM_ENTRY(env, sub, super);
 571 
 572   oop sub_mirror   = JNIHandles::resolve_non_null(sub);
 573   oop super_mirror = JNIHandles::resolve_non_null(super);
 574   if (java_lang_Class::is_primitive(sub_mirror) ||
 575       java_lang_Class::is_primitive(super_mirror)) {
 576     jboolean ret = (sub_mirror == super_mirror);
 577 
 578     HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 579     return ret;
 580   }
 581   Klass* sub_klass   = java_lang_Class::as_Klass(sub_mirror);
 582   Klass* super_klass = java_lang_Class::as_Klass(super_mirror);
 583   assert(sub_klass != NULL &amp;&amp; super_klass != NULL, &quot;invalid arguments to jni_IsAssignableFrom&quot;);
 584   jboolean ret = sub_klass-&gt;is_subtype_of(super_klass) ?
 585                    JNI_TRUE : JNI_FALSE;

 586   HOTSPOT_JNI_ISASSIGNABLEFROM_RETURN(ret);
 587   return ret;
 588 JNI_END
 589 
 590 
 591 DT_RETURN_MARK_DECL(Throw, jint
 592                     , HOTSPOT_JNI_THROW_RETURN(_ret_ref));
 593 
 594 JNI_ENTRY(jint, jni_Throw(JNIEnv *env, jthrowable obj))
 595   JNIWrapper(&quot;Throw&quot;);
 596 
 597   HOTSPOT_JNI_THROW_ENTRY(env, obj);
 598 
 599   jint ret = JNI_OK;
 600   DT_RETURN_MARK(Throw, jint, (const jint&amp;)ret);
 601 
 602   THROW_OOP_(JNIHandles::resolve(obj), JNI_OK);
 603   ShouldNotReachHere();
 604   return 0;  // Mute compiler.
 605 JNI_END
</pre>
<hr />
<pre>
 900   }
 901 
 902   friend class SignatureIterator;  // so do_parameters_on can call do_type
 903   void do_type(BasicType type) {
 904     switch (type) {
 905     // these are coerced to int when using va_arg
 906     case T_BYTE:
 907     case T_CHAR:
 908     case T_SHORT:
 909     case T_INT:         push_int(va_arg(_ap, jint)); break;
 910     case T_BOOLEAN:     push_boolean((jboolean) va_arg(_ap, jint)); break;
 911 
 912     // each of these paths is exercised by the various jck Call[Static,Nonvirtual,][Void,Int,..]Method[A,V,] tests
 913 
 914     case T_LONG:        push_long(va_arg(_ap, jlong)); break;
 915     // float is coerced to double w/ va_arg
 916     case T_FLOAT:       push_float((jfloat) va_arg(_ap, jdouble)); break;
 917     case T_DOUBLE:      push_double(va_arg(_ap, jdouble)); break;
 918 
 919     case T_ARRAY:
<span class="line-modified"> 920     case T_OBJECT:</span>
<span class="line-added"> 921     case T_VALUETYPE:   push_object(va_arg(_ap, jobject)); break;</span>
 922     default:            ShouldNotReachHere();
 923     }
 924   }
 925 
 926  public:
 927   JNI_ArgumentPusherVaArg(jmethodID method_id, va_list rap)
 928       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
 929     set_ap(rap);
 930   }
 931 
 932   virtual void push_arguments_on(JavaCallArguments* arguments) {
 933     _arguments = arguments;
 934     do_parameters_on(this);
 935   }
 936 };
 937 
 938 
 939 class JNI_ArgumentPusherArray : public JNI_ArgumentPusher {
 940  protected:
 941   const jvalue *_ap;
 942 
 943   inline void set_ap(const jvalue *rap) { _ap = rap; }
 944 
 945   friend class SignatureIterator;  // so do_parameters_on can call do_type
 946   void do_type(BasicType type) {
 947     switch (type) {
 948     case T_CHAR:        push_int((_ap++)-&gt;c); break;
 949     case T_SHORT:       push_int((_ap++)-&gt;s); break;
 950     case T_BYTE:        push_int((_ap++)-&gt;b); break;
 951     case T_INT:         push_int((_ap++)-&gt;i); break;
 952     case T_BOOLEAN:     push_boolean((_ap++)-&gt;z); break;
 953     case T_LONG:        push_long((_ap++)-&gt;j); break;
 954     case T_FLOAT:       push_float((_ap++)-&gt;f); break;
 955     case T_DOUBLE:      push_double((_ap++)-&gt;d); break;
 956     case T_ARRAY:
<span class="line-modified"> 957     case T_OBJECT:</span>
<span class="line-added"> 958     case T_VALUETYPE:   push_object((_ap++)-&gt;l); break;</span>
 959     default:            ShouldNotReachHere();
 960     }
 961   }
 962 
 963  public:
 964   JNI_ArgumentPusherArray(jmethodID method_id, const jvalue *rap)
 965       : JNI_ArgumentPusher(Method::resolve_jmethod_id(method_id)) {
 966     set_ap(rap);
 967   }
 968 
 969   virtual void push_arguments_on(JavaCallArguments* arguments) {
 970     _arguments = arguments;
 971     do_parameters_on(this);
 972   }
 973 };
 974 
 975 
 976 enum JNICallType {
 977   JNI_STATIC,
 978   JNI_VIRTUAL,
</pre>
<hr />
<pre>
1078 
1079   jobject ret = NULL;
1080   DT_RETURN_MARK(AllocObject, jobject, (const jobject&amp;)ret);
1081 
1082   instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);
1083   ret = JNIHandles::make_local(env, i);
1084   return ret;
1085 JNI_END
1086 
1087 DT_RETURN_MARK_DECL(NewObjectA, jobject
1088                     , HOTSPOT_JNI_NEWOBJECTA_RETURN(_ret_ref));
1089 
1090 JNI_ENTRY(jobject, jni_NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args))
1091   JNIWrapper(&quot;NewObjectA&quot;);
1092 
1093   HOTSPOT_JNI_NEWOBJECTA_ENTRY(env, clazz, (uintptr_t) methodID);
1094 
1095   jobject obj = NULL;
1096   DT_RETURN_MARK(NewObjectA, jobject, (const jobject)obj);
1097 
<span class="line-modified">1098   oop clazzoop = JNIHandles::resolve_non_null(clazz);</span>
<span class="line-modified">1099   Klass* k = java_lang_Class::as_Klass(clazzoop);</span>
<span class="line-modified">1100   if (k == NULL) {</span>
<span class="line-modified">1101     ResourceMark rm(THREAD);</span>
<span class="line-modified">1102     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);</span>
<span class="line-added">1103   }</span>
<span class="line-added">1104 </span>
<span class="line-added">1105   if (!k-&gt;is_value()) {</span>
<span class="line-added">1106     instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);</span>
<span class="line-added">1107     obj = JNIHandles::make_local(env, i);</span>
<span class="line-added">1108     JavaValue jvalue(T_VOID);</span>
<span class="line-added">1109     JNI_ArgumentPusherArray ap(methodID, args);</span>
<span class="line-added">1110     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);</span>
<span class="line-added">1111   } else {</span>
<span class="line-added">1112     JavaValue jvalue(T_VALUETYPE);</span>
<span class="line-added">1113     JNI_ArgumentPusherArray ap(methodID, args);</span>
<span class="line-added">1114     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);</span>
<span class="line-added">1115     obj = jvalue.get_jobject();</span>
<span class="line-added">1116   }</span>
1117   return obj;
<span class="line-modified">1118   JNI_END</span>
1119 
1120 
1121 DT_RETURN_MARK_DECL(NewObjectV, jobject
1122                     , HOTSPOT_JNI_NEWOBJECTV_RETURN(_ret_ref));
1123 
1124 JNI_ENTRY(jobject, jni_NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args))
1125   JNIWrapper(&quot;NewObjectV&quot;);
1126 
1127   HOTSPOT_JNI_NEWOBJECTV_ENTRY(env, clazz, (uintptr_t) methodID);
1128 
1129   jobject obj = NULL;
1130   DT_RETURN_MARK(NewObjectV, jobject, (const jobject&amp;)obj);
1131 
<span class="line-modified">1132   oop clazzoop = JNIHandles::resolve_non_null(clazz);</span>
<span class="line-modified">1133   Klass* k = java_lang_Class::as_Klass(clazzoop);</span>
<span class="line-modified">1134   if (k == NULL) {</span>
<span class="line-modified">1135     ResourceMark rm(THREAD);</span>
<span class="line-modified">1136     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);</span>
<span class="line-added">1137   }</span>
<span class="line-added">1138 </span>
<span class="line-added">1139   if (!k-&gt;is_value()) {</span>
<span class="line-added">1140     instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);</span>
<span class="line-added">1141     obj = JNIHandles::make_local(env, i);</span>
<span class="line-added">1142     JavaValue jvalue(T_VOID);</span>
<span class="line-added">1143     JNI_ArgumentPusherVaArg ap(methodID, args);</span>
<span class="line-added">1144     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);</span>
<span class="line-added">1145   } else {</span>
<span class="line-added">1146     JavaValue jvalue(T_VALUETYPE);</span>
<span class="line-added">1147     JNI_ArgumentPusherVaArg ap(methodID, args);</span>
<span class="line-added">1148     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);</span>
<span class="line-added">1149     obj = jvalue.get_jobject();</span>
<span class="line-added">1150   }</span>
1151   return obj;
1152 JNI_END
1153 
1154 
1155 DT_RETURN_MARK_DECL(NewObject, jobject
1156                     , HOTSPOT_JNI_NEWOBJECT_RETURN(_ret_ref));
1157 
1158 JNI_ENTRY(jobject, jni_NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...))
1159   JNIWrapper(&quot;NewObject&quot;);
1160 
1161   HOTSPOT_JNI_NEWOBJECT_ENTRY(env, clazz, (uintptr_t) methodID);
1162 
1163   jobject obj = NULL;
1164   DT_RETURN_MARK(NewObject, jobject, (const jobject&amp;)obj);
1165 
<span class="line-modified">1166   oop clazzoop = JNIHandles::resolve_non_null(clazz);</span>
<span class="line-modified">1167   Klass* k = java_lang_Class::as_Klass(clazzoop);</span>
<span class="line-modified">1168   if (k == NULL) {</span>
<span class="line-modified">1169     ResourceMark rm(THREAD);</span>
<span class="line-modified">1170     THROW_(vmSymbols::java_lang_InstantiationException(), NULL);</span>
<span class="line-modified">1171   }</span>
<span class="line-modified">1172 </span>
<span class="line-modified">1173   if (!k-&gt;is_value()) {</span>
<span class="line-added">1174     instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);</span>
<span class="line-added">1175     obj = JNIHandles::make_local(env, i);</span>
<span class="line-added">1176     va_list args;</span>
<span class="line-added">1177     va_start(args, methodID);</span>
<span class="line-added">1178     JavaValue jvalue(T_VOID);</span>
<span class="line-added">1179     JNI_ArgumentPusherVaArg ap(methodID, args);</span>
<span class="line-added">1180     jni_invoke_nonstatic(env, &amp;jvalue, obj, JNI_NONVIRTUAL, methodID, &amp;ap, CHECK_NULL);</span>
<span class="line-added">1181     va_end(args);</span>
<span class="line-added">1182   } else {</span>
<span class="line-added">1183     va_list args;</span>
<span class="line-added">1184     va_start(args, methodID);</span>
<span class="line-added">1185     JavaValue jvalue(T_VALUETYPE);</span>
<span class="line-added">1186     JNI_ArgumentPusherVaArg ap(methodID, args);</span>
<span class="line-added">1187     jni_invoke_static(env, &amp;jvalue, NULL, JNI_STATIC, methodID, &amp;ap, CHECK_NULL);</span>
<span class="line-added">1188     va_end(args);</span>
<span class="line-added">1189     obj = jvalue.get_jobject();</span>
<span class="line-added">1190   }</span>
1191   return obj;
1192 JNI_END
1193 
1194 
1195 JNI_ENTRY(jclass, jni_GetObjectClass(JNIEnv *env, jobject obj))
1196   JNIWrapper(&quot;GetObjectClass&quot;);
1197 
1198   HOTSPOT_JNI_GETOBJECTCLASS_ENTRY(env, obj);
1199 
1200   Klass* k = JNIHandles::resolve_non_null(obj)-&gt;klass();
1201   jclass ret =
1202     (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1203 
1204   HOTSPOT_JNI_GETOBJECTCLASS_RETURN(ret);
1205   return ret;
1206 JNI_END
1207 
1208 JNI_ENTRY_NO_PRESERVE(jboolean, jni_IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz))
1209   JNIWrapper(&quot;IsInstanceOf&quot;);
1210 
</pre>
<hr />
<pre>
1947   // table.  If they&#39;re not there, the field doesn&#39;t exist.
1948   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));
1949   TempNewSymbol signame = SymbolTable::probe(sig, (int)strlen(sig));
1950   if (fieldname == NULL || signame == NULL) {
1951     ResourceMark rm;
1952     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
1953   }
1954 
1955   // Make sure class is initialized before handing id&#39;s out to fields
1956   k-&gt;initialize(CHECK_NULL);
1957 
1958   fieldDescriptor fd;
1959   if (!k-&gt;is_instance_klass() ||
1960       !InstanceKlass::cast(k)-&gt;find_field(fieldname, signame, false, &amp;fd)) {
1961     ResourceMark rm;
1962     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, k-&gt;external_name(), name, sig));
1963   }
1964 
1965   // A jfieldID for a non-static field is simply the offset of the field within the instanceOop
1966   // It may also have hash bits for k, if VerifyJNIFields is turned on.
<span class="line-modified">1967   ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset(), fd.is_flattened());</span>
1968   return ret;
1969 JNI_END
1970 
1971 
1972 JNI_ENTRY(jobject, jni_GetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID))
1973   JNIWrapper(&quot;GetObjectField&quot;);
1974   HOTSPOT_JNI_GETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID);
1975   oop o = JNIHandles::resolve_non_null(obj);
1976   Klass* k = o-&gt;klass();
1977   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
<span class="line-added">1978   oop res = NULL;</span>
1979   // Keep JVMTI addition small and only check enabled flag here.
1980   // jni_GetField_probe() assumes that is okay to create handles.
1981   if (JvmtiExport::should_post_field_access()) {
1982     o = JvmtiExport::jni_GetField_probe(thread, obj, o, k, fieldID, false);
1983   }
<span class="line-modified">1984   if (!jfieldIDWorkaround::is_flattened_field(fieldID)) {</span>
<span class="line-modified">1985     res = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(o, offset);</span>
<span class="line-added">1986   } else {</span>
<span class="line-added">1987     assert(k-&gt;is_instance_klass(), &quot;Only instance can have flattened fields&quot;);</span>
<span class="line-added">1988     InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-added">1989     fieldDescriptor fd;</span>
<span class="line-added">1990     ik-&gt;find_field_from_offset(offset, false, &amp;fd);  // performance bottleneck</span>
<span class="line-added">1991     InstanceKlass* holder = fd.field_holder();</span>
<span class="line-added">1992     ValueKlass* field_vklass = ValueKlass::cast(holder-&gt;get_value_field_klass(fd.index()));</span>
<span class="line-added">1993     res = field_vklass-&gt;read_flattened_field(o, ik-&gt;field_offset(fd.index()), CHECK_NULL);</span>
<span class="line-added">1994   }</span>
<span class="line-added">1995   jobject ret = JNIHandles::make_local(env, res);</span>
1996   HOTSPOT_JNI_GETOBJECTFIELD_RETURN(ret);
1997   return ret;
1998 JNI_END
1999 
2000 
2001 
2002 #define DEFINE_GETFIELD(Return,Fieldname,Result \
2003   , EntryProbe, ReturnProbe) \
2004 \
2005   DT_RETURN_MARK_DECL_FOR(Result, Get##Result##Field, Return \
2006   , ReturnProbe); \
2007 \
2008 JNI_ENTRY_NO_PRESERVE(Return, jni_Get##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID)) \
2009   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;Field&quot;); \
2010 \
2011   EntryProbe; \
2012   Return ret = 0;\
2013   DT_RETURN_MARK_FOR(Result, Get##Result##Field, Return, (const Return&amp;)ret);\
2014 \
2015   oop o = JNIHandles::resolve_non_null(obj); \
</pre>
<hr />
<pre>
2073   return (address)jni_GetFloatField;
2074 }
2075 address jni_GetDoubleField_addr() {
2076   return (address)jni_GetDoubleField;
2077 }
2078 
2079 JNI_ENTRY_NO_PRESERVE(void, jni_SetObjectField(JNIEnv *env, jobject obj, jfieldID fieldID, jobject value))
2080   JNIWrapper(&quot;SetObjectField&quot;);
2081   HOTSPOT_JNI_SETOBJECTFIELD_ENTRY(env, obj, (uintptr_t) fieldID, value);
2082   oop o = JNIHandles::resolve_non_null(obj);
2083   Klass* k = o-&gt;klass();
2084   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);
2085   // Keep JVMTI addition small and only check enabled flag here.
2086   // jni_SetField_probe_nh() assumes that is not okay to create handles
2087   // and creates a ResetNoHandleMark.
2088   if (JvmtiExport::should_post_field_modification()) {
2089     jvalue field_value;
2090     field_value.l = value;
2091     o = JvmtiExport::jni_SetField_probe_nh(thread, obj, o, k, fieldID, false, JVM_SIGNATURE_CLASS, (jvalue *)&amp;field_value);
2092   }
<span class="line-modified">2093   if (!jfieldIDWorkaround::is_flattened_field(fieldID)) {</span>
<span class="line-added">2094     HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(o, offset, JNIHandles::resolve(value));</span>
<span class="line-added">2095   } else {</span>
<span class="line-added">2096     assert(k-&gt;is_instance_klass(), &quot;Only instances can have flattened fields&quot;);</span>
<span class="line-added">2097     InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-added">2098     fieldDescriptor fd;</span>
<span class="line-added">2099     ik-&gt;find_field_from_offset(offset, false, &amp;fd);</span>
<span class="line-added">2100     InstanceKlass* holder = fd.field_holder();</span>
<span class="line-added">2101     ValueKlass* vklass = ValueKlass::cast(holder-&gt;get_value_field_klass(fd.index()));</span>
<span class="line-added">2102     oop v = JNIHandles::resolve_non_null(value);</span>
<span class="line-added">2103     vklass-&gt;write_flattened_field(o, offset, v, CHECK);</span>
<span class="line-added">2104   }</span>
2105   HOTSPOT_JNI_SETOBJECTFIELD_RETURN();
2106 JNI_END
2107 
2108 
2109 #define DEFINE_SETFIELD(Argument,Fieldname,Result,SigType,unionType \
2110                         , EntryProbe, ReturnProbe) \
2111 \
2112 JNI_ENTRY_NO_PRESERVE(void, jni_Set##Result##Field(JNIEnv *env, jobject obj, jfieldID fieldID, Argument value)) \
2113   JNIWrapper(&quot;Set&quot; XSTR(Result) &quot;Field&quot;); \
2114 \
2115   EntryProbe; \
2116 \
2117   oop o = JNIHandles::resolve_non_null(obj); \
2118   Klass* k = o-&gt;klass(); \
2119   int offset = jfieldIDWorkaround::from_instance_jfieldID(k, fieldID);  \
2120   /* Keep JVMTI addition small and only check enabled flag here.       */ \
2121   /* jni_SetField_probe_nh() assumes that is not okay to create handles */ \
2122   /* and creates a ResetNoHandleMark.                                   */ \
2123   if (JvmtiExport::should_post_field_modification()) { \
2124     jvalue field_value; \
</pre>
<hr />
<pre>
2521   ObjArrayKlass::cast(ak)-&gt;initialize(CHECK_NULL);
2522   objArrayOop result = ObjArrayKlass::cast(ak)-&gt;allocate(length, CHECK_NULL);
2523   oop initial_value = JNIHandles::resolve(initialElement);
2524   if (initial_value != NULL) {  // array already initialized with NULL
2525     for (int index = 0; index &lt; length; index++) {
2526       result-&gt;obj_at_put(index, initial_value);
2527     }
2528   }
2529   ret = (jobjectArray) JNIHandles::make_local(env, result);
2530   return ret;
2531 JNI_END
2532 
2533 DT_RETURN_MARK_DECL(GetObjectArrayElement, jobject
2534                     , HOTSPOT_JNI_GETOBJECTARRAYELEMENT_RETURN(_ret_ref));
2535 
2536 JNI_ENTRY(jobject, jni_GetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index))
2537   JNIWrapper(&quot;GetObjectArrayElement&quot;);
2538  HOTSPOT_JNI_GETOBJECTARRAYELEMENT_ENTRY(env, array, index);
2539   jobject ret = NULL;
2540   DT_RETURN_MARK(GetObjectArrayElement, jobject, (const jobject&amp;)ret);
<span class="line-modified">2541   oop res = NULL;</span>
<span class="line-modified">2542   arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));</span>
<span class="line-modified">2543   if (arr-&gt;is_within_bounds(index)) {</span>
<span class="line-modified">2544     if (arr-&gt;is_valueArray()) {</span>
<span class="line-added">2545       valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-added">2546       arrayHandle ah(THREAD, a);</span>
<span class="line-added">2547       valueArrayHandle vah(thread, a);</span>
<span class="line-added">2548       res = valueArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK_NULL);</span>
<span class="line-added">2549       assert(res != NULL, &quot;Must be set in one of two paths above&quot;);</span>
<span class="line-added">2550     } else {</span>
<span class="line-added">2551       assert(arr-&gt;is_objArray(), &quot;If not a valueArray. must be an objArray&quot;);</span>
<span class="line-added">2552       objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-added">2553       res = a-&gt;obj_at(index);</span>
<span class="line-added">2554     }</span>
2555   } else {
2556     ResourceMark rm(THREAD);
2557     stringStream ss;
<span class="line-modified">2558     ss.print(&quot;Index %d out of bounds for length %d&quot;, index,arr-&gt;length());</span>
2559     THROW_MSG_0(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());
2560   }
<span class="line-added">2561   ret = JNIHandles::make_local(env, res);</span>
<span class="line-added">2562   return ret;</span>
2563 JNI_END
2564 
2565 DT_VOID_RETURN_MARK_DECL(SetObjectArrayElement
2566                          , HOTSPOT_JNI_SETOBJECTARRAYELEMENT_RETURN());
2567 
2568 JNI_ENTRY(void, jni_SetObjectArrayElement(JNIEnv *env, jobjectArray array, jsize index, jobject value))
2569   JNIWrapper(&quot;SetObjectArrayElement&quot;);
<span class="line-modified">2570   HOTSPOT_JNI_SETOBJECTARRAYELEMENT_ENTRY(env, array, index, value);</span>
2571   DT_VOID_RETURN_MARK(SetObjectArrayElement);
2572 
<span class="line-modified">2573    bool oob = false;</span>
<span class="line-modified">2574    int length = -1;</span>
<span class="line-modified">2575    oop res = NULL;</span>
<span class="line-modified">2576    arrayOop arr((arrayOop)JNIHandles::resolve_non_null(array));</span>
<span class="line-modified">2577    if (arr-&gt;is_within_bounds(index)) {</span>
<span class="line-modified">2578      if (arr-&gt;is_valueArray()) {</span>
<span class="line-modified">2579        valueArrayOop a = valueArrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-modified">2580        oop v = JNIHandles::resolve(value);</span>
<span class="line-modified">2581        ValueArrayKlass* vaklass = ValueArrayKlass::cast(a-&gt;klass());</span>
<span class="line-modified">2582        ValueKlass* element_vklass = vaklass-&gt;element_klass();</span>
<span class="line-modified">2583        if (v != NULL &amp;&amp; v-&gt;is_a(element_vklass)) {</span>
<span class="line-modified">2584          a-&gt;value_copy_to_index(v, index);</span>
<span class="line-modified">2585        } else {</span>
<span class="line-modified">2586          ResourceMark rm(THREAD);</span>
<span class="line-modified">2587          stringStream ss;</span>
<span class="line-modified">2588          Klass *kl = ValueArrayKlass::cast(a-&gt;klass());</span>
<span class="line-modified">2589          ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,</span>
<span class="line-modified">2590              v-&gt;klass()-&gt;external_name(),</span>
<span class="line-modified">2591              kl-&gt;external_name(),</span>
<span class="line-modified">2592              index);</span>
<span class="line-modified">2593          for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {</span>
<span class="line-modified">2594            ss.print(&quot;[]&quot;);</span>
<span class="line-modified">2595          }</span>
<span class="line-modified">2596          THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());</span>
<span class="line-added">2597        }</span>
<span class="line-added">2598      } else {</span>
<span class="line-added">2599        assert(arr-&gt;is_objArray(), &quot;If not a valueArray. must be an objArray&quot;);</span>
<span class="line-added">2600        objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-added">2601        oop v = JNIHandles::resolve(value);</span>
<span class="line-added">2602        if (v == NULL || v-&gt;is_a(ObjArrayKlass::cast(a-&gt;klass())-&gt;element_klass())) {</span>
<span class="line-added">2603          a-&gt;obj_at_put(index, v);</span>
<span class="line-added">2604        } else {</span>
<span class="line-added">2605          ResourceMark rm(THREAD);</span>
<span class="line-added">2606          stringStream ss;</span>
<span class="line-added">2607          Klass *bottom_kl = ObjArrayKlass::cast(a-&gt;klass())-&gt;bottom_klass();</span>
<span class="line-added">2608          ss.print(&quot;type mismatch: can not store %s to %s[%d]&quot;,</span>
<span class="line-added">2609              v-&gt;klass()-&gt;external_name(),</span>
<span class="line-added">2610              bottom_kl-&gt;is_typeArray_klass() ? type2name_tab[ArrayKlass::cast(bottom_kl)-&gt;element_type()] : bottom_kl-&gt;external_name(),</span>
<span class="line-added">2611                  index);</span>
<span class="line-added">2612          for (int dims = ArrayKlass::cast(a-&gt;klass())-&gt;dimension(); dims &gt; 1; --dims) {</span>
<span class="line-added">2613            ss.print(&quot;[]&quot;);</span>
<span class="line-added">2614          }</span>
<span class="line-added">2615          THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), ss.as_string());</span>
<span class="line-added">2616        }</span>
<span class="line-added">2617      }</span>
<span class="line-added">2618    } else {</span>
<span class="line-added">2619      ResourceMark rm(THREAD);</span>
<span class="line-added">2620      stringStream ss;</span>
<span class="line-added">2621      ss.print(&quot;Index %d out of bounds for length %d&quot;, index, arr-&gt;length());</span>
<span class="line-added">2622      THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());</span>
<span class="line-added">2623    }</span>
2624 JNI_END
2625 
2626 
2627 
2628 #define DEFINE_NEWSCALARARRAY(Return,Allocator,Result \
2629                               ,EntryProbe,ReturnProbe)  \
2630 \
2631   DT_RETURN_MARK_DECL(New##Result##Array, Return \
2632                       , ReturnProbe); \
2633 \
2634 JNI_ENTRY(Return, \
2635           jni_New##Result##Array(JNIEnv *env, jsize len)) \
2636   JNIWrapper(&quot;New&quot; XSTR(Result) &quot;Array&quot;); \
2637   EntryProbe; \
2638   Return ret = NULL;\
2639   DT_RETURN_MARK(New##Result##Array, Return, (const Return&amp;)ret);\
2640 \
2641   oop obj= oopFactory::Allocator(len, CHECK_NULL); \
2642   ret = (Return) JNIHandles::make_local(env, obj); \
2643   return ret;\
</pre>
<hr />
<pre>
3390   return CurrentVersion;
3391 JNI_END
3392 
3393 extern struct JavaVM_ main_vm;
3394 
3395 JNI_LEAF(jint, jni_GetJavaVM(JNIEnv *env, JavaVM **vm))
3396   JNIWrapper(&quot;jni_GetJavaVM&quot;);
3397   HOTSPOT_JNI_GETJAVAVM_ENTRY(env, (void **) vm);
3398   *vm  = (JavaVM *)(&amp;main_vm);
3399   HOTSPOT_JNI_GETJAVAVM_RETURN(JNI_OK);
3400   return JNI_OK;
3401 JNI_END
3402 
3403 
3404 JNI_ENTRY(jobject, jni_GetModule(JNIEnv* env, jclass clazz))
3405   JNIWrapper(&quot;GetModule&quot;);
3406   return Modules::get_module(clazz, THREAD);
3407 JNI_END
3408 
3409 
<span class="line-added">3410 JNI_ENTRY(void*, jni_GetFlattenedArrayElements(JNIEnv* env, jarray array, jboolean* isCopy))</span>
<span class="line-added">3411   JNIWrapper(&quot;jni_GetFlattenedArrayElements&quot;);</span>
<span class="line-added">3412   if (isCopy != NULL) {</span>
<span class="line-added">3413     *isCopy = JNI_FALSE;</span>
<span class="line-added">3414   }</span>
<span class="line-added">3415   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-added">3416   if (!ar-&gt;is_array()) {</span>
<span class="line-added">3417     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);</span>
<span class="line-added">3418   }</span>
<span class="line-added">3419   if (!ar-&gt;is_valueArray()) {</span>
<span class="line-added">3420     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);</span>
<span class="line-added">3421   }</span>
<span class="line-added">3422   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());</span>
<span class="line-added">3423   if (vak-&gt;contains_oops()) {</span>
<span class="line-added">3424     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Flattened array contains oops&quot;);</span>
<span class="line-added">3425   }</span>
<span class="line-added">3426   oop a = lock_gc_or_pin_object(thread, array);</span>
<span class="line-added">3427   valueArrayOop vap = valueArrayOop(a);</span>
<span class="line-added">3428   void* ret = vap-&gt;value_at_addr(0, vak-&gt;layout_helper());</span>
<span class="line-added">3429   return ret;</span>
<span class="line-added">3430 JNI_END</span>
<span class="line-added">3431 </span>
<span class="line-added">3432 JNI_ENTRY(void, jni_ReleaseFlattenedArrayElements(JNIEnv* env, jarray array, void* elem, jint mode))</span>
<span class="line-added">3433   JNIWrapper(&quot;jni_ReleaseFlattenedArrayElements&quot;);</span>
<span class="line-added">3434   unlock_gc_or_unpin_object(thread, array);</span>
<span class="line-added">3435 JNI_END</span>
<span class="line-added">3436 </span>
<span class="line-added">3437 JNI_ENTRY(jsize, jni_GetFlattenedArrayElementSize(JNIEnv* env, jarray array)) {</span>
<span class="line-added">3438   JNIWrapper(&quot;jni_GetFlattenedElementSize&quot;);</span>
<span class="line-added">3439   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-added">3440   if (!a-&gt;is_array()) {</span>
<span class="line-added">3441     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);</span>
<span class="line-added">3442   }</span>
<span class="line-added">3443   if (!a-&gt;is_valueArray()) {</span>
<span class="line-added">3444     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);</span>
<span class="line-added">3445   }</span>
<span class="line-added">3446   ValueArrayKlass* vak = ValueArrayKlass::cast(a-&gt;klass());</span>
<span class="line-added">3447   jsize ret = vak-&gt;element_byte_size();</span>
<span class="line-added">3448   return ret;</span>
<span class="line-added">3449 }</span>
<span class="line-added">3450 JNI_END</span>
<span class="line-added">3451 </span>
<span class="line-added">3452 JNI_ENTRY(jclass, jni_GetFlattenedArrayElementClass(JNIEnv* env, jarray array))</span>
<span class="line-added">3453   JNIWrapper(&quot;jni_GetArrayElementClass&quot;);</span>
<span class="line-added">3454   arrayOop a = arrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-added">3455   if (!a-&gt;is_array()) {</span>
<span class="line-added">3456     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);</span>
<span class="line-added">3457   }</span>
<span class="line-added">3458   if (!a-&gt;is_valueArray()) {</span>
<span class="line-added">3459     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);</span>
<span class="line-added">3460   }</span>
<span class="line-added">3461   ValueArrayKlass* vak = ValueArrayKlass::cast(a-&gt;klass());</span>
<span class="line-added">3462   ValueKlass* vk = vak-&gt;element_klass();</span>
<span class="line-added">3463   return (jclass) JNIHandles::make_local(vk-&gt;java_mirror());</span>
<span class="line-added">3464 JNI_END</span>
<span class="line-added">3465 </span>
<span class="line-added">3466 JNI_ENTRY(jsize, jni_GetFieldOffsetInFlattenedLayout(JNIEnv* env, jclass clazz, const char *name, const char *signature, jboolean* isFlattened))</span>
<span class="line-added">3467   JNIWrapper(&quot;jni_GetFieldOffsetInFlattenedLayout&quot;);</span>
<span class="line-added">3468 </span>
<span class="line-added">3469   oop mirror = JNIHandles::resolve_non_null(clazz);</span>
<span class="line-added">3470   Klass* k = java_lang_Class::as_Klass(mirror);</span>
<span class="line-added">3471   if (!k-&gt;is_value()) {</span>
<span class="line-added">3472     ResourceMark rm;</span>
<span class="line-added">3473         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;%s has not flattened layout&quot;, k-&gt;external_name()));</span>
<span class="line-added">3474   }</span>
<span class="line-added">3475   ValueKlass* vk = ValueKlass::cast(k);</span>
<span class="line-added">3476 </span>
<span class="line-added">3477   TempNewSymbol fieldname = SymbolTable::probe(name, (int)strlen(name));</span>
<span class="line-added">3478   TempNewSymbol signame = SymbolTable::probe(signature, (int)strlen(signature));</span>
<span class="line-added">3479   if (fieldname == NULL || signame == NULL) {</span>
<span class="line-added">3480     ResourceMark rm;</span>
<span class="line-added">3481     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, vk-&gt;external_name(), name, signature));</span>
<span class="line-added">3482   }</span>
<span class="line-added">3483 </span>
<span class="line-added">3484   assert(vk-&gt;is_initialized(), &quot;If a flattened array has been created, the element klass must have been initialized&quot;);</span>
<span class="line-added">3485 </span>
<span class="line-added">3486   fieldDescriptor fd;</span>
<span class="line-added">3487   if (!vk-&gt;is_instance_klass() ||</span>
<span class="line-added">3488       !InstanceKlass::cast(vk)-&gt;find_field(fieldname, signame, false, &amp;fd)) {</span>
<span class="line-added">3489     ResourceMark rm;</span>
<span class="line-added">3490     THROW_MSG_0(vmSymbols::java_lang_NoSuchFieldError(), err_msg(&quot;%s.%s %s&quot;, vk-&gt;external_name(), name, signature));</span>
<span class="line-added">3491   }</span>
<span class="line-added">3492 </span>
<span class="line-added">3493   int offset = fd.offset() - vk-&gt;first_field_offset();</span>
<span class="line-added">3494   if (isFlattened != NULL) {</span>
<span class="line-added">3495     *isFlattened = fd.is_flattened();</span>
<span class="line-added">3496   }</span>
<span class="line-added">3497   return (jsize)offset;</span>
<span class="line-added">3498 JNI_END</span>
<span class="line-added">3499 </span>
<span class="line-added">3500 JNI_ENTRY(jobject, jni_CreateSubElementSelector(JNIEnv* env, jarray array))</span>
<span class="line-added">3501   JNIWrapper(&quot;jni_CreateSubElementSelector&quot;);</span>
<span class="line-added">3502 </span>
<span class="line-added">3503   arrayOop ar = arrayOop(JNIHandles::resolve_non_null(array));</span>
<span class="line-added">3504   if (!ar-&gt;is_array()) {</span>
<span class="line-added">3505     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not an array&quot;);</span>
<span class="line-added">3506   }</span>
<span class="line-added">3507   if (!ar-&gt;is_valueArray()) {</span>
<span class="line-added">3508     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a flattened array&quot;);</span>
<span class="line-added">3509   }</span>
<span class="line-added">3510   Klass* ses_k = SystemDictionary::resolve_or_null(vmSymbols::jdk_internal_vm_jni_SubElementSelector(),</span>
<span class="line-added">3511         Handle(THREAD, SystemDictionary::java_system_loader()), Handle(), CHECK_NULL);</span>
<span class="line-added">3512   InstanceKlass* ses_ik = InstanceKlass::cast(ses_k);</span>
<span class="line-added">3513   ses_ik-&gt;initialize(CHECK_NULL);</span>
<span class="line-added">3514   Klass* elementKlass = ArrayKlass::cast(ar-&gt;klass())-&gt;element_klass();</span>
<span class="line-added">3515   oop ses = ses_ik-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">3516   Handle ses_h(THREAD, ses);</span>
<span class="line-added">3517   jdk_internal_vm_jni_SubElementSelector::setArrayElementType(ses_h(), elementKlass-&gt;java_mirror());</span>
<span class="line-added">3518   jdk_internal_vm_jni_SubElementSelector::setSubElementType(ses_h(), elementKlass-&gt;java_mirror());</span>
<span class="line-added">3519   jdk_internal_vm_jni_SubElementSelector::setOffset(ses_h(), 0);</span>
<span class="line-added">3520   jdk_internal_vm_jni_SubElementSelector::setIsFlattened(ses_h(), true);   // by definition, top element of a flattened array is flattened</span>
<span class="line-added">3521   jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(ses_h(), true); // by definition, top element of a flattened array is flattenable</span>
<span class="line-added">3522   return JNIHandles::make_local(ses_h());</span>
<span class="line-added">3523 JNI_END</span>
<span class="line-added">3524 </span>
<span class="line-added">3525 JNI_ENTRY(jobject, jni_GetSubElementSelector(JNIEnv* env, jobject selector, jfieldID fieldID))</span>
<span class="line-added">3526   JNIWrapper(&quot;jni_GetSubElementSelector&quot;);</span>
<span class="line-added">3527 </span>
<span class="line-added">3528   oop slct = JNIHandles::resolve_non_null(selector);</span>
<span class="line-added">3529   if (slct-&gt;klass()-&gt;name() != vmSymbols::jdk_internal_vm_jni_SubElementSelector()) {</span>
<span class="line-added">3530     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Not a SubElementSelector&quot;);</span>
<span class="line-added">3531   }</span>
<span class="line-added">3532   jboolean isflattened = jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct);</span>
<span class="line-added">3533   if (!isflattened) {</span>
<span class="line-added">3534     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;SubElement is not flattened&quot;);</span>
<span class="line-added">3535   }</span>
<span class="line-added">3536   oop semirror = jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct);</span>
<span class="line-added">3537   Klass* k = java_lang_Class::as_Klass(semirror);</span>
<span class="line-added">3538   if (!k-&gt;is_value()) {</span>
<span class="line-added">3539     ResourceMark rm;</span>
<span class="line-added">3540         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), err_msg(&quot;%s is not an inline type&quot;, k-&gt;external_name()));</span>
<span class="line-added">3541   }</span>
<span class="line-added">3542   ValueKlass* vk = ValueKlass::cast(k);</span>
<span class="line-added">3543   assert(vk-&gt;is_initialized(), &quot;If a flattened array has been created, the element klass must have been initialized&quot;);</span>
<span class="line-added">3544   int field_offset = jfieldIDWorkaround::from_instance_jfieldID(vk, fieldID);</span>
<span class="line-added">3545   fieldDescriptor fd;</span>
<span class="line-added">3546   if (!vk-&gt;find_field_from_offset(field_offset, false, &amp;fd)) {</span>
<span class="line-added">3547     THROW_NULL(vmSymbols::java_lang_NoSuchFieldError());</span>
<span class="line-added">3548   }</span>
<span class="line-added">3549   Handle arrayElementMirror(THREAD, jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct));</span>
<span class="line-added">3550   // offset of the SubElement is offset of the original SubElement plus the offset of the field inside the element</span>
<span class="line-added">3551   int offset = fd.offset() - vk-&gt;first_field_offset() + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);</span>
<span class="line-added">3552   InstanceKlass* sesklass = InstanceKlass::cast(JNIHandles::resolve_non_null(selector)-&gt;klass());</span>
<span class="line-added">3553   oop res = sesklass-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">3554   Handle res_h(THREAD, res);</span>
<span class="line-added">3555   jdk_internal_vm_jni_SubElementSelector::setArrayElementType(res_h(), arrayElementMirror());</span>
<span class="line-added">3556   InstanceKlass* holder = fd.field_holder();</span>
<span class="line-added">3557   BasicType bt = Signature::basic_type(fd.signature());</span>
<span class="line-added">3558   if (is_java_primitive(bt)) {</span>
<span class="line-added">3559     jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(), java_lang_Class::primitive_mirror(bt));</span>
<span class="line-added">3560   } else {</span>
<span class="line-added">3561     Klass* fieldKlass = SystemDictionary::resolve_or_fail(fd.signature(), Handle(THREAD, holder-&gt;class_loader()),</span>
<span class="line-added">3562         Handle(THREAD, holder-&gt;protection_domain()), true, CHECK_NULL);</span>
<span class="line-added">3563     jdk_internal_vm_jni_SubElementSelector::setSubElementType(res_h(),fieldKlass-&gt;java_mirror());</span>
<span class="line-added">3564   }</span>
<span class="line-added">3565   jdk_internal_vm_jni_SubElementSelector::setOffset(res_h(), offset);</span>
<span class="line-added">3566   jdk_internal_vm_jni_SubElementSelector::setIsFlattened(res_h(), fd.is_flattened());</span>
<span class="line-added">3567   jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(res_h(), fd.is_flattenable());</span>
<span class="line-added">3568   return JNIHandles::make_local(res_h());</span>
<span class="line-added">3569 JNI_END</span>
<span class="line-added">3570 </span>
<span class="line-added">3571 JNI_ENTRY(jobject, jni_GetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index))</span>
<span class="line-added">3572   JNIWrapper(&quot;jni_GetObjectSubElement&quot;);</span>
<span class="line-added">3573 </span>
<span class="line-added">3574   valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);</span>
<span class="line-added">3575   oop slct = JNIHandles::resolve_non_null(selector);</span>
<span class="line-added">3576   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());</span>
<span class="line-added">3577   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) {</span>
<span class="line-added">3578     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;);</span>
<span class="line-added">3579   }</span>
<span class="line-added">3580   oop res = NULL;</span>
<span class="line-added">3581   if (!jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct)) {</span>
<span class="line-added">3582     int offset = (address)ar-&gt;base() - cast_from_oop&lt;address&gt;(ar) + index * vak-&gt;element_byte_size()</span>
<span class="line-added">3583                       + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);</span>
<span class="line-added">3584     res = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(ar, offset);</span>
<span class="line-added">3585   } else {</span>
<span class="line-added">3586     ValueKlass* fieldKlass = ValueKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));</span>
<span class="line-added">3587     res = fieldKlass-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">3588     // The array might have been moved by the GC, refreshing the arrayOop</span>
<span class="line-added">3589     ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);</span>
<span class="line-added">3590     address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper())</span>
<span class="line-added">3591               + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);</span>
<span class="line-added">3592     fieldKlass-&gt;value_copy_payload_to_new_oop(addr, res);</span>
<span class="line-added">3593   }</span>
<span class="line-added">3594   return JNIHandles::make_local(res);</span>
<span class="line-added">3595 JNI_END</span>
<span class="line-added">3596 </span>
<span class="line-added">3597 JNI_ENTRY(void, jni_SetObjectSubElement(JNIEnv* env, jarray array, jobject selector, int index, jobject value))</span>
<span class="line-added">3598   JNIWrapper(&quot;jni_SetObjectSubElement&quot;);</span>
<span class="line-added">3599 </span>
<span class="line-added">3600   valueArrayOop ar =  (valueArrayOop)JNIHandles::resolve_non_null(array);</span>
<span class="line-added">3601   oop slct = JNIHandles::resolve_non_null(selector);</span>
<span class="line-added">3602   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass());</span>
<span class="line-added">3603   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) {</span>
<span class="line-added">3604     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;);</span>
<span class="line-added">3605   }</span>
<span class="line-added">3606   oop val = JNIHandles::resolve(value);</span>
<span class="line-added">3607   if (val == NULL) {</span>
<span class="line-added">3608     if (jdk_internal_vm_jni_SubElementSelector::getIsFlattenable(slct)) {</span>
<span class="line-added">3609       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), &quot;null cannot be stored in a flattened array&quot;);</span>
<span class="line-added">3610     }</span>
<span class="line-added">3611   } else {</span>
<span class="line-added">3612     if (!val-&gt;is_a(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)))) {</span>
<span class="line-added">3613       THROW_MSG(vmSymbols::java_lang_ArrayStoreException(), &quot;type mismatch&quot;);</span>
<span class="line-added">3614     }</span>
<span class="line-added">3615   }</span>
<span class="line-added">3616   if (!jdk_internal_vm_jni_SubElementSelector::getIsFlattened(slct)) {</span>
<span class="line-added">3617     int offset = (address)ar-&gt;base() - cast_from_oop&lt;address&gt;(ar) + index * vak-&gt;element_byte_size()</span>
<span class="line-added">3618                   + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);</span>
<span class="line-added">3619     HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(ar, offset, JNIHandles::resolve(value));</span>
<span class="line-added">3620   } else {</span>
<span class="line-added">3621     ValueKlass* fieldKlass = ValueKlass::cast(java_lang_Class::as_Klass(jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct)));</span>
<span class="line-added">3622     address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper())</span>
<span class="line-added">3623                   + jdk_internal_vm_jni_SubElementSelector::getOffset(slct);</span>
<span class="line-added">3624     fieldKlass-&gt;value_copy_oop_to_payload(JNIHandles::resolve_non_null(value), addr);</span>
<span class="line-added">3625   }</span>
<span class="line-added">3626 JNI_END</span>
<span class="line-added">3627 </span>
<span class="line-added">3628 #define DEFINE_GETSUBELEMENT(ElementType,Result,ElementBasicType) \</span>
<span class="line-added">3629 \</span>
<span class="line-added">3630 JNI_ENTRY(ElementType, \</span>
<span class="line-added">3631           jni_Get##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index)) \</span>
<span class="line-added">3632   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;SubElement&quot;); \</span>
<span class="line-added">3633   valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \</span>
<span class="line-added">3634   oop slct = JNIHandles::resolve_non_null(selector); \</span>
<span class="line-added">3635   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass()); \</span>
<span class="line-added">3636   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) { \</span>
<span class="line-added">3637     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;); \</span>
<span class="line-added">3638   } \</span>
<span class="line-added">3639   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \</span>
<span class="line-added">3640     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong SubElement type&quot;); \</span>
<span class="line-added">3641   } \</span>
<span class="line-added">3642   address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper()) \</span>
<span class="line-added">3643                + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \</span>
<span class="line-added">3644   ElementType result = *(ElementType*)addr; \</span>
<span class="line-added">3645   return result; \</span>
<span class="line-added">3646 JNI_END</span>
<span class="line-added">3647 </span>
<span class="line-added">3648 DEFINE_GETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)</span>
<span class="line-added">3649 DEFINE_GETSUBELEMENT(jbyte, Byte, T_BYTE)</span>
<span class="line-added">3650 DEFINE_GETSUBELEMENT(jshort, Short,T_SHORT)</span>
<span class="line-added">3651 DEFINE_GETSUBELEMENT(jchar, Char,T_CHAR)</span>
<span class="line-added">3652 DEFINE_GETSUBELEMENT(jint, Int,T_INT)</span>
<span class="line-added">3653 DEFINE_GETSUBELEMENT(jlong, Long,T_LONG)</span>
<span class="line-added">3654 DEFINE_GETSUBELEMENT(jfloat, Float,T_FLOAT)</span>
<span class="line-added">3655 DEFINE_GETSUBELEMENT(jdouble, Double,T_DOUBLE)</span>
<span class="line-added">3656 </span>
<span class="line-added">3657 #define DEFINE_SETSUBELEMENT(ElementType,Result,ElementBasicType) \</span>
<span class="line-added">3658 \</span>
<span class="line-added">3659 JNI_ENTRY(void, \</span>
<span class="line-added">3660           jni_Set##Result##SubElement(JNIEnv *env, jarray array, jobject selector, int index, ElementType value)) \</span>
<span class="line-added">3661   JNIWrapper(&quot;Get&quot; XSTR(Result) &quot;SubElement&quot;); \</span>
<span class="line-added">3662   valueArrayOop ar = (valueArrayOop)JNIHandles::resolve_non_null(array); \</span>
<span class="line-added">3663   oop slct = JNIHandles::resolve_non_null(selector); \</span>
<span class="line-added">3664   ValueArrayKlass* vak = ValueArrayKlass::cast(ar-&gt;klass()); \</span>
<span class="line-added">3665   if (jdk_internal_vm_jni_SubElementSelector::getArrayElementType(slct) != vak-&gt;element_klass()-&gt;java_mirror()) { \</span>
<span class="line-added">3666     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Array/Selector mismatch&quot;); \</span>
<span class="line-added">3667   } \</span>
<span class="line-added">3668   if (jdk_internal_vm_jni_SubElementSelector::getSubElementType(slct) != java_lang_Class::primitive_mirror(ElementBasicType)) { \</span>
<span class="line-added">3669     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong SubElement type&quot;); \</span>
<span class="line-added">3670   } \</span>
<span class="line-added">3671   address addr = (address)ar-&gt;value_at_addr(index, vak-&gt;layout_helper()) \</span>
<span class="line-added">3672                + jdk_internal_vm_jni_SubElementSelector::getOffset(slct); \</span>
<span class="line-added">3673   *(ElementType*)addr = value; \</span>
<span class="line-added">3674 JNI_END</span>
<span class="line-added">3675 </span>
<span class="line-added">3676 DEFINE_SETSUBELEMENT(jboolean, Boolean,T_BOOLEAN)</span>
<span class="line-added">3677 DEFINE_SETSUBELEMENT(jbyte, Byte, T_BYTE)</span>
<span class="line-added">3678 DEFINE_SETSUBELEMENT(jshort, Short,T_SHORT)</span>
<span class="line-added">3679 DEFINE_SETSUBELEMENT(jchar, Char,T_CHAR)</span>
<span class="line-added">3680 DEFINE_SETSUBELEMENT(jint, Int,T_INT)</span>
<span class="line-added">3681 DEFINE_SETSUBELEMENT(jlong, Long,T_LONG)</span>
<span class="line-added">3682 DEFINE_SETSUBELEMENT(jfloat, Float,T_FLOAT)</span>
<span class="line-added">3683 DEFINE_SETSUBELEMENT(jdouble, Double,T_DOUBLE)</span>
<span class="line-added">3684 </span>
3685 // Structure containing all jni functions
3686 struct JNINativeInterface_ jni_NativeInterface = {
3687     NULL,
3688     NULL,
3689     NULL,
3690 
3691     NULL,
3692 
3693     jni_GetVersion,
3694 
3695     jni_DefineClass,
3696     jni_FindClass,
3697 
3698     jni_FromReflectedMethod,
3699     jni_FromReflectedField,
3700 
3701     jni_ToReflectedMethod,
3702 
3703     jni_GetSuperclass,
3704     jni_IsAssignableFrom,
</pre>
<hr />
<pre>
3948     jni_ReleasePrimitiveArrayCritical,
3949 
3950     jni_GetStringCritical,
3951     jni_ReleaseStringCritical,
3952 
3953     jni_NewWeakGlobalRef,
3954     jni_DeleteWeakGlobalRef,
3955 
3956     jni_ExceptionCheck,
3957 
3958     jni_NewDirectByteBuffer,
3959     jni_GetDirectBufferAddress,
3960     jni_GetDirectBufferCapacity,
3961 
3962     // New 1_6 features
3963 
3964     jni_GetObjectRefType,
3965 
3966     // Module features
3967 
<span class="line-modified">3968     jni_GetModule,</span>
<span class="line-added">3969 </span>
<span class="line-added">3970     // Flattened arrays features</span>
<span class="line-added">3971 </span>
<span class="line-added">3972     jni_GetFlattenedArrayElements,</span>
<span class="line-added">3973     jni_ReleaseFlattenedArrayElements,</span>
<span class="line-added">3974     jni_GetFlattenedArrayElementClass,</span>
<span class="line-added">3975     jni_GetFlattenedArrayElementSize,</span>
<span class="line-added">3976     jni_GetFieldOffsetInFlattenedLayout,</span>
<span class="line-added">3977 </span>
<span class="line-added">3978     jni_CreateSubElementSelector,</span>
<span class="line-added">3979     jni_GetSubElementSelector,</span>
<span class="line-added">3980     jni_GetObjectSubElement,</span>
<span class="line-added">3981     jni_SetObjectSubElement,</span>
<span class="line-added">3982 </span>
<span class="line-added">3983     jni_GetBooleanSubElement,</span>
<span class="line-added">3984     jni_GetByteSubElement,</span>
<span class="line-added">3985     jni_GetShortSubElement,</span>
<span class="line-added">3986     jni_GetCharSubElement,</span>
<span class="line-added">3987     jni_GetIntSubElement,</span>
<span class="line-added">3988     jni_GetLongSubElement,</span>
<span class="line-added">3989     jni_GetFloatSubElement,</span>
<span class="line-added">3990     jni_GetDoubleSubElement,</span>
<span class="line-added">3991 </span>
<span class="line-added">3992     jni_SetBooleanSubElement,</span>
<span class="line-added">3993     jni_SetByteSubElement,</span>
<span class="line-added">3994     jni_SetShortSubElement,</span>
<span class="line-added">3995     jni_SetCharSubElement,</span>
<span class="line-added">3996     jni_SetIntSubElement,</span>
<span class="line-added">3997     jni_SetLongSubElement,</span>
<span class="line-added">3998     jni_SetFloatSubElement,</span>
<span class="line-added">3999     jni_SetDoubleSubElement</span>
4000 };
4001 
4002 
4003 // For jvmti use to modify jni function table.
4004 // Java threads in native contiues to run until it is transitioned
4005 // to VM at safepoint. Before the transition or before it is blocked
4006 // for safepoint it may access jni function table. VM could crash if
4007 // any java thread access the jni function table in the middle of memcpy.
4008 // To avoid this each function pointers are copied automically.
4009 void copy_jni_function_table(const struct JNINativeInterface_ *new_jni_NativeInterface) {
4010   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
4011   intptr_t *a = (intptr_t *) jni_functions();
4012   intptr_t *b = (intptr_t *) new_jni_NativeInterface;
4013   for (uint i=0; i &lt;  sizeof(struct JNINativeInterface_)/sizeof(void *); i++) {
4014     Atomic::store(a++, *b++);
4015   }
4016 }
4017 
4018 void quicken_jni_functions() {
4019   // Replace Get&lt;Primitive&gt;Field with fast versions
</pre>
</td>
</tr>
</table>
<center><a href="../opto/subnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="unsafe.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/verificationType.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../../test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/BadValueTypes.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/verificationType.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
145                                                     from_field_is_protected, THREAD);
146     }
147   }
148   return false;
149 }
150 
151 bool VerificationType::is_valuetype_assignable_from(const VerificationType&amp; from) const {
152   // Check that &#39;from&#39; is not null, is a value type, and is the same value type.
153   assert(is_valuetype(), &quot;called with a non-valuetype type&quot;);
154   assert(!is_null(), &quot;valuetype is not null&quot;);
155   return (!from.is_null() &amp;&amp; from.is_valuetype() &amp;&amp; name() == from.name());
156 }
157 
158 bool VerificationType::is_ref_assignable_from_value_type(const VerificationType&amp; from, ClassVerifier* context, TRAPS) const {
159   assert(!from.is_null(), &quot;Value type should not be null&quot;);
160   if (!is_null() &amp;&amp; (name()-&gt;is_same_fundamental_type(from.name()) ||
161       name() == vmSymbols::java_lang_Object())) {
162     return true;
163   }
164 
<span class="line-modified">165   // Need to load &#39;this&#39; to see if it is an interface.</span>
166   InstanceKlass* klass = context-&gt;current_class();
167   {
168     HandleMark hm(THREAD);
169     Klass* this_class = SystemDictionary::resolve_or_fail(
170         name(), Handle(THREAD, klass-&gt;class_loader()),
171         Handle(THREAD, klass-&gt;protection_domain()), true, CHECK_false);
172     klass-&gt;class_loader_data()-&gt;record_dependency(this_class);
173     if (log_is_enabled(Debug, class, resolve)) {
174       Verifier::trace_class_resolution(this_class, klass);
175     }
<span class="line-modified">176     return (this_class-&gt;is_interface());</span>










177   }
178 }
179 
180 VerificationType VerificationType::get_component(ClassVerifier *context, TRAPS) const {
181   assert(is_array() &amp;&amp; name()-&gt;utf8_length() &gt;= 2, &quot;Must be a valid array&quot;);
182   SignatureStream ss(name(), false);
183   ss.skip_array_prefix(1);
184   switch (ss.type()) {
185     case T_BOOLEAN: return VerificationType(Boolean);
186     case T_BYTE:    return VerificationType(Byte);
187     case T_CHAR:    return VerificationType(Char);
188     case T_SHORT:   return VerificationType(Short);
189     case T_INT:     return VerificationType(Integer);
190     case T_LONG:    return VerificationType(Long);
191     case T_FLOAT:   return VerificationType(Float);
192     case T_DOUBLE:  return VerificationType(Double);
193     case T_ARRAY:
194     case T_OBJECT:
195     case T_VALUETYPE: {
196       guarantee(ss.is_reference(), &quot;unchecked verifier input?&quot;);
</pre>
</td>
<td>
<hr />
<pre>
145                                                     from_field_is_protected, THREAD);
146     }
147   }
148   return false;
149 }
150 
151 bool VerificationType::is_valuetype_assignable_from(const VerificationType&amp; from) const {
152   // Check that &#39;from&#39; is not null, is a value type, and is the same value type.
153   assert(is_valuetype(), &quot;called with a non-valuetype type&quot;);
154   assert(!is_null(), &quot;valuetype is not null&quot;);
155   return (!from.is_null() &amp;&amp; from.is_valuetype() &amp;&amp; name() == from.name());
156 }
157 
158 bool VerificationType::is_ref_assignable_from_value_type(const VerificationType&amp; from, ClassVerifier* context, TRAPS) const {
159   assert(!from.is_null(), &quot;Value type should not be null&quot;);
160   if (!is_null() &amp;&amp; (name()-&gt;is_same_fundamental_type(from.name()) ||
161       name() == vmSymbols::java_lang_Object())) {
162     return true;
163   }
164 
<span class="line-modified">165   // Need to load &#39;this&#39; to see if it is an interface or supertype.</span>
166   InstanceKlass* klass = context-&gt;current_class();
167   {
168     HandleMark hm(THREAD);
169     Klass* this_class = SystemDictionary::resolve_or_fail(
170         name(), Handle(THREAD, klass-&gt;class_loader()),
171         Handle(THREAD, klass-&gt;protection_domain()), true, CHECK_false);
172     klass-&gt;class_loader_data()-&gt;record_dependency(this_class);
173     if (log_is_enabled(Debug, class, resolve)) {
174       Verifier::trace_class_resolution(this_class, klass);
175     }
<span class="line-modified">176     if (this_class-&gt;is_interface()) {</span>
<span class="line-added">177       return true;</span>
<span class="line-added">178     } else {</span>
<span class="line-added">179       Klass* from_class = SystemDictionary::resolve_or_fail(</span>
<span class="line-added">180         from.name(), Handle(THREAD, klass-&gt;class_loader()),</span>
<span class="line-added">181         Handle(THREAD, klass-&gt;protection_domain()), true, CHECK_false);</span>
<span class="line-added">182       if (log_is_enabled(Debug, class, resolve)) {</span>
<span class="line-added">183         Verifier::trace_class_resolution(from_class, klass);</span>
<span class="line-added">184       }</span>
<span class="line-added">185       return from_class-&gt;is_subclass_of(this_class);</span>
<span class="line-added">186     }</span>
187   }
188 }
189 
190 VerificationType VerificationType::get_component(ClassVerifier *context, TRAPS) const {
191   assert(is_array() &amp;&amp; name()-&gt;utf8_length() &gt;= 2, &quot;Must be a valid array&quot;);
192   SignatureStream ss(name(), false);
193   ss.skip_array_prefix(1);
194   switch (ss.type()) {
195     case T_BOOLEAN: return VerificationType(Boolean);
196     case T_BYTE:    return VerificationType(Byte);
197     case T_CHAR:    return VerificationType(Char);
198     case T_SHORT:   return VerificationType(Short);
199     case T_INT:     return VerificationType(Integer);
200     case T_LONG:    return VerificationType(Long);
201     case T_FLOAT:   return VerificationType(Float);
202     case T_DOUBLE:  return VerificationType(Double);
203     case T_ARRAY:
204     case T_OBJECT:
205     case T_VALUETYPE: {
206       guarantee(ss.is_reference(), &quot;unchecked verifier input?&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../../test/hotspot/jtreg/runtime/valhalla/valuetypes/classfileparser/BadValueTypes.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
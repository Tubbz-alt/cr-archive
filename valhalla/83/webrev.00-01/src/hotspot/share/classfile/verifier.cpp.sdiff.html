<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/verifier.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="verificationType.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../interpreter/interpreterRuntime.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/verifier.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/constantPool.inline.hpp&quot;
  45 #include &quot;oops/instanceKlass.hpp&quot;
  46 #include &quot;oops/oop.inline.hpp&quot;
  47 #include &quot;oops/typeArrayOop.hpp&quot;
  48 #include &quot;runtime/fieldDescriptor.hpp&quot;
  49 #include &quot;runtime/handles.inline.hpp&quot;
  50 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  51 #include &quot;runtime/javaCalls.hpp&quot;
  52 #include &quot;runtime/jniHandles.inline.hpp&quot;
  53 #include &quot;runtime/os.hpp&quot;
  54 #include &quot;runtime/safepointVerifiers.hpp&quot;
  55 #include &quot;runtime/thread.hpp&quot;
  56 #include &quot;services/threadService.hpp&quot;
  57 #include &quot;utilities/align.hpp&quot;
  58 #include &quot;utilities/bytes.hpp&quot;
  59 
  60 #define NOFAILOVER_MAJOR_VERSION                       51
  61 #define NONZERO_PADDING_BYTES_IN_SWITCH_MAJOR_VERSION  51
  62 #define STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION       52
<span class="line-modified">  63 #define INLINETYPE_MAJOR_VERSION                       56</span>
  64 #define MAX_ARRAY_DIMENSIONS 255
  65 
  66 // Access to external entry for VerifyClassForMajorVersion - old byte code verifier
  67 
  68 extern &quot;C&quot; {
  69   typedef jboolean (*verify_byte_codes_fn_t)(JNIEnv *, jclass, char *, jint, jint);
  70 }
  71 
  72 static verify_byte_codes_fn_t volatile _verify_byte_codes_fn = NULL;
  73 
  74 static verify_byte_codes_fn_t verify_byte_codes_fn() {
  75 
  76   if (_verify_byte_codes_fn != NULL)
  77     return _verify_byte_codes_fn;
  78 
  79   MutexLocker locker(Verify_lock);
  80 
  81   if (_verify_byte_codes_fn != NULL)
  82     return _verify_byte_codes_fn;
  83 
</pre>
<hr />
<pre>
1691               current_frame.flag_this_uninit()) {
1692             verify_error(ErrorContext::bad_code(bci),
1693                          &quot;Constructor must call super() or this() &quot;
1694                          &quot;before return&quot;);
1695             return;
1696           }
1697           no_control_flow = true; break;
1698         case Bytecodes::_getstatic :
1699         case Bytecodes::_putstatic :
1700           // pass TRUE, operand can be an array type for getstatic/putstatic.
1701           verify_field_instructions(
1702             &amp;bcs, &amp;current_frame, cp, true, CHECK_VERIFY(this));
1703           no_control_flow = false; break;
1704         case Bytecodes::_getfield :
1705         case Bytecodes::_putfield :
1706           // pass FALSE, operand can&#39;t be an array type for getfield/putfield.
1707           verify_field_instructions(
1708             &amp;bcs, &amp;current_frame, cp, false, CHECK_VERIFY(this));
1709           no_control_flow = false; break;
1710         case Bytecodes::_withfield :
<span class="line-modified">1711           if (_klass-&gt;major_version() &lt; INLINETYPE_MAJOR_VERSION) {</span>
1712             class_format_error(
1713               &quot;withfield not supported by this class file version (%d.%d), class %s&quot;,
1714               _klass-&gt;major_version(), _klass-&gt;minor_version(), _klass-&gt;external_name());
1715             return;
1716           }
1717           // pass FALSE, operand can&#39;t be an array type for withfield.
1718           verify_field_instructions(
1719             &amp;bcs, &amp;current_frame, cp, false, CHECK_VERIFY(this));
1720           no_control_flow = false; break;
1721         case Bytecodes::_invokevirtual :
1722         case Bytecodes::_invokespecial :
1723         case Bytecodes::_invokestatic :
1724         case Bytecodes::_invokeinterface :
1725         case Bytecodes::_invokedynamic :
1726           verify_invoke_instructions(
1727             &amp;bcs, code_length, &amp;current_frame, (bci &gt;= ex_min &amp;&amp; bci &lt; ex_max),
1728             &amp;this_uninit, cp, &amp;stackmap_table, CHECK_VERIFY(this));
1729           no_control_flow = false; break;
1730         case Bytecodes::_new :
1731         {
1732           index = bcs.get_index_u2();
1733           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1734           VerificationType new_class_type =
1735             cp_index_to_type(index, cp, CHECK_VERIFY(this));
1736           if (!new_class_type.is_object()) {
1737             verify_error(ErrorContext::bad_type(bci,
1738                 TypeOrigin::cp(index, new_class_type)),
1739                 &quot;Illegal new instruction&quot;);
1740             return;
1741           }
1742           type = VerificationType::uninitialized_type(bci);
1743           current_frame.push_stack(type, CHECK_VERIFY(this));
1744           no_control_flow = false; break;
1745         }
1746         case Bytecodes::_defaultvalue :
1747         {
<span class="line-modified">1748           if (_klass-&gt;major_version() &lt; INLINETYPE_MAJOR_VERSION) {</span>
1749             class_format_error(
1750               &quot;defaultvalue not supported by this class file version (%d.%d), class %s&quot;,
1751               _klass-&gt;major_version(), _klass-&gt;minor_version(), _klass-&gt;external_name());
1752             return;
1753           }
1754           index = bcs.get_index_u2();
1755           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1756           VerificationType ref_type = cp_index_to_type(index, cp, CHECK_VERIFY(this));
1757           if (!ref_type.is_object()) {
1758             verify_error(ErrorContext::bad_type(bci,
1759                 TypeOrigin::cp(index, ref_type)),
1760                 &quot;Illegal defaultvalue instruction&quot;);
1761             return;
1762           }
1763           VerificationType inline_type =
1764             VerificationType::change_ref_to_inlinetype(ref_type);
1765           current_frame.push_stack(inline_type, CHECK_VERIFY(this));
1766           no_control_flow = false; break;
1767         }
1768         case Bytecodes::_newarray :
</pre>
<hr />
<pre>
3102     cp_index_to_type(index, cp, CHECK_VERIFY(this));
3103   int length;
3104   char* arr_sig_str;
3105   if (component_type.is_array()) {     // it&#39;s an array
3106     const char* component_name = component_type.name()-&gt;as_utf8();
3107     // Check for more than MAX_ARRAY_DIMENSIONS
3108     length = (int)strlen(component_name);
3109     if (length &gt; MAX_ARRAY_DIMENSIONS &amp;&amp;
3110         component_name[MAX_ARRAY_DIMENSIONS - 1] == JVM_SIGNATURE_ARRAY) {
3111       verify_error(ErrorContext::bad_code(bci),
3112         &quot;Illegal anewarray instruction, array has more than 255 dimensions&quot;);
3113     }
3114     // add one dimension to component
3115     length++;
3116     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3117     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%s&quot;,
3118                          JVM_SIGNATURE_ARRAY, component_name);
3119     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3120   } else {         // it&#39;s an object or interface
3121     const char* component_name = component_type.name()-&gt;as_utf8();
<span class="line-modified">3122     char Q_or_L = component_type.is_inlinetype() ? JVM_SIGNATURE_INLINETYPE : JVM_SIGNATURE_CLASS;</span>
3123     // add one dimension to component with &#39;L&#39; or &#39;Q&#39; prepended and &#39;;&#39; appended.
3124     length = (int)strlen(component_name) + 3;
3125     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3126     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%c%s;&quot;,
3127                          JVM_SIGNATURE_ARRAY, Q_or_L, component_name);
3128     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3129   }
3130   Symbol* arr_sig = create_temporary_symbol(arr_sig_str, length);
3131   VerificationType new_array_type = VerificationType::reference_type(arr_sig);
3132   current_frame-&gt;push_stack(new_array_type, CHECK_VERIFY(this));
3133 }
3134 
3135 void ClassVerifier::verify_iload(u2 index, StackMapFrame* current_frame, TRAPS) {
3136   current_frame-&gt;get_local(
3137     index, VerificationType::integer_type(), CHECK_VERIFY(this));
3138   current_frame-&gt;push_stack(
3139     VerificationType::integer_type(), CHECK_VERIFY(this));
3140 }
3141 
3142 void ClassVerifier::verify_lload(u2 index, StackMapFrame* current_frame, TRAPS) {
</pre>
</td>
<td>
<hr />
<pre>
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/constantPool.inline.hpp&quot;
  45 #include &quot;oops/instanceKlass.hpp&quot;
  46 #include &quot;oops/oop.inline.hpp&quot;
  47 #include &quot;oops/typeArrayOop.hpp&quot;
  48 #include &quot;runtime/fieldDescriptor.hpp&quot;
  49 #include &quot;runtime/handles.inline.hpp&quot;
  50 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  51 #include &quot;runtime/javaCalls.hpp&quot;
  52 #include &quot;runtime/jniHandles.inline.hpp&quot;
  53 #include &quot;runtime/os.hpp&quot;
  54 #include &quot;runtime/safepointVerifiers.hpp&quot;
  55 #include &quot;runtime/thread.hpp&quot;
  56 #include &quot;services/threadService.hpp&quot;
  57 #include &quot;utilities/align.hpp&quot;
  58 #include &quot;utilities/bytes.hpp&quot;
  59 
  60 #define NOFAILOVER_MAJOR_VERSION                       51
  61 #define NONZERO_PADDING_BYTES_IN_SWITCH_MAJOR_VERSION  51
  62 #define STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION       52
<span class="line-modified">  63 #define INLINE_TYPE_MAJOR_VERSION                       56</span>
  64 #define MAX_ARRAY_DIMENSIONS 255
  65 
  66 // Access to external entry for VerifyClassForMajorVersion - old byte code verifier
  67 
  68 extern &quot;C&quot; {
  69   typedef jboolean (*verify_byte_codes_fn_t)(JNIEnv *, jclass, char *, jint, jint);
  70 }
  71 
  72 static verify_byte_codes_fn_t volatile _verify_byte_codes_fn = NULL;
  73 
  74 static verify_byte_codes_fn_t verify_byte_codes_fn() {
  75 
  76   if (_verify_byte_codes_fn != NULL)
  77     return _verify_byte_codes_fn;
  78 
  79   MutexLocker locker(Verify_lock);
  80 
  81   if (_verify_byte_codes_fn != NULL)
  82     return _verify_byte_codes_fn;
  83 
</pre>
<hr />
<pre>
1691               current_frame.flag_this_uninit()) {
1692             verify_error(ErrorContext::bad_code(bci),
1693                          &quot;Constructor must call super() or this() &quot;
1694                          &quot;before return&quot;);
1695             return;
1696           }
1697           no_control_flow = true; break;
1698         case Bytecodes::_getstatic :
1699         case Bytecodes::_putstatic :
1700           // pass TRUE, operand can be an array type for getstatic/putstatic.
1701           verify_field_instructions(
1702             &amp;bcs, &amp;current_frame, cp, true, CHECK_VERIFY(this));
1703           no_control_flow = false; break;
1704         case Bytecodes::_getfield :
1705         case Bytecodes::_putfield :
1706           // pass FALSE, operand can&#39;t be an array type for getfield/putfield.
1707           verify_field_instructions(
1708             &amp;bcs, &amp;current_frame, cp, false, CHECK_VERIFY(this));
1709           no_control_flow = false; break;
1710         case Bytecodes::_withfield :
<span class="line-modified">1711           if (_klass-&gt;major_version() &lt; INLINE_TYPE_MAJOR_VERSION) {</span>
1712             class_format_error(
1713               &quot;withfield not supported by this class file version (%d.%d), class %s&quot;,
1714               _klass-&gt;major_version(), _klass-&gt;minor_version(), _klass-&gt;external_name());
1715             return;
1716           }
1717           // pass FALSE, operand can&#39;t be an array type for withfield.
1718           verify_field_instructions(
1719             &amp;bcs, &amp;current_frame, cp, false, CHECK_VERIFY(this));
1720           no_control_flow = false; break;
1721         case Bytecodes::_invokevirtual :
1722         case Bytecodes::_invokespecial :
1723         case Bytecodes::_invokestatic :
1724         case Bytecodes::_invokeinterface :
1725         case Bytecodes::_invokedynamic :
1726           verify_invoke_instructions(
1727             &amp;bcs, code_length, &amp;current_frame, (bci &gt;= ex_min &amp;&amp; bci &lt; ex_max),
1728             &amp;this_uninit, cp, &amp;stackmap_table, CHECK_VERIFY(this));
1729           no_control_flow = false; break;
1730         case Bytecodes::_new :
1731         {
1732           index = bcs.get_index_u2();
1733           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1734           VerificationType new_class_type =
1735             cp_index_to_type(index, cp, CHECK_VERIFY(this));
1736           if (!new_class_type.is_object()) {
1737             verify_error(ErrorContext::bad_type(bci,
1738                 TypeOrigin::cp(index, new_class_type)),
1739                 &quot;Illegal new instruction&quot;);
1740             return;
1741           }
1742           type = VerificationType::uninitialized_type(bci);
1743           current_frame.push_stack(type, CHECK_VERIFY(this));
1744           no_control_flow = false; break;
1745         }
1746         case Bytecodes::_defaultvalue :
1747         {
<span class="line-modified">1748           if (_klass-&gt;major_version() &lt; INLINE_TYPE_MAJOR_VERSION) {</span>
1749             class_format_error(
1750               &quot;defaultvalue not supported by this class file version (%d.%d), class %s&quot;,
1751               _klass-&gt;major_version(), _klass-&gt;minor_version(), _klass-&gt;external_name());
1752             return;
1753           }
1754           index = bcs.get_index_u2();
1755           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1756           VerificationType ref_type = cp_index_to_type(index, cp, CHECK_VERIFY(this));
1757           if (!ref_type.is_object()) {
1758             verify_error(ErrorContext::bad_type(bci,
1759                 TypeOrigin::cp(index, ref_type)),
1760                 &quot;Illegal defaultvalue instruction&quot;);
1761             return;
1762           }
1763           VerificationType inline_type =
1764             VerificationType::change_ref_to_inlinetype(ref_type);
1765           current_frame.push_stack(inline_type, CHECK_VERIFY(this));
1766           no_control_flow = false; break;
1767         }
1768         case Bytecodes::_newarray :
</pre>
<hr />
<pre>
3102     cp_index_to_type(index, cp, CHECK_VERIFY(this));
3103   int length;
3104   char* arr_sig_str;
3105   if (component_type.is_array()) {     // it&#39;s an array
3106     const char* component_name = component_type.name()-&gt;as_utf8();
3107     // Check for more than MAX_ARRAY_DIMENSIONS
3108     length = (int)strlen(component_name);
3109     if (length &gt; MAX_ARRAY_DIMENSIONS &amp;&amp;
3110         component_name[MAX_ARRAY_DIMENSIONS - 1] == JVM_SIGNATURE_ARRAY) {
3111       verify_error(ErrorContext::bad_code(bci),
3112         &quot;Illegal anewarray instruction, array has more than 255 dimensions&quot;);
3113     }
3114     // add one dimension to component
3115     length++;
3116     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3117     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%s&quot;,
3118                          JVM_SIGNATURE_ARRAY, component_name);
3119     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3120   } else {         // it&#39;s an object or interface
3121     const char* component_name = component_type.name()-&gt;as_utf8();
<span class="line-modified">3122     char Q_or_L = component_type.is_inlinetype() ? JVM_SIGNATURE_INLINE_TYPE : JVM_SIGNATURE_CLASS;</span>
3123     // add one dimension to component with &#39;L&#39; or &#39;Q&#39; prepended and &#39;;&#39; appended.
3124     length = (int)strlen(component_name) + 3;
3125     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3126     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%c%s;&quot;,
3127                          JVM_SIGNATURE_ARRAY, Q_or_L, component_name);
3128     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3129   }
3130   Symbol* arr_sig = create_temporary_symbol(arr_sig_str, length);
3131   VerificationType new_array_type = VerificationType::reference_type(arr_sig);
3132   current_frame-&gt;push_stack(new_array_type, CHECK_VERIFY(this));
3133 }
3134 
3135 void ClassVerifier::verify_iload(u2 index, StackMapFrame* current_frame, TRAPS) {
3136   current_frame-&gt;get_local(
3137     index, VerificationType::integer_type(), CHECK_VERIFY(this));
3138   current_frame-&gt;push_stack(
3139     VerificationType::integer_type(), CHECK_VERIFY(this));
3140 }
3141 
3142 void ClassVerifier::verify_lload(u2 index, StackMapFrame* current_frame, TRAPS) {
</pre>
</td>
</tr>
</table>
<center><a href="verificationType.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../interpreter/interpreterRuntime.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
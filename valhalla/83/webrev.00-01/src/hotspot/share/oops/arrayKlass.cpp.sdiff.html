<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/arrayKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../interpreter/interpreterRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/arrayKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 93     // the vtable of klass Object.
 94     set_vtable_length(Universe::base_vtable_size());
 95     set_name(name);
 96     set_super(Universe::is_bootstrapping() ? NULL : SystemDictionary::Object_klass());
 97     set_layout_helper(Klass::_lh_neutral_value);
 98     set_is_cloneable(); // All arrays are considered to be cloneable (See JLS 20.1.5)
 99     JFR_ONLY(INIT_ID(this);)
100 }
101 
102 Symbol* ArrayKlass::create_element_klass_array_name(Klass* element_klass, TRAPS) {
103   ResourceMark rm(THREAD);
104   Symbol* name = NULL;
105   bool is_qtype = element_klass-&gt;is_value();
106   char *name_str = element_klass-&gt;name()-&gt;as_C_string();
107   int len = element_klass-&gt;name()-&gt;utf8_length();
108   char *new_str = NEW_RESOURCE_ARRAY(char, len + 4);
109   int idx = 0;
110   new_str[idx++] = JVM_SIGNATURE_ARRAY;
111   if (element_klass-&gt;is_instance_klass()) { // it could be an array or simple type
112     if (is_qtype) {
<span class="line-modified">113       new_str[idx++] = JVM_SIGNATURE_INLINETYPE;</span>
114     } else {
115       new_str[idx++] = JVM_SIGNATURE_CLASS;
116     }
117   }
118   memcpy(&amp;new_str[idx], name_str, len * sizeof(char));
119   idx += len;
120   if (element_klass-&gt;is_instance_klass()) {
121     new_str[idx++] = JVM_SIGNATURE_ENDCLASS;
122   }
123   new_str[idx++] = &#39;\0&#39;;
124   return SymbolTable::new_symbol(new_str);
125 }
126 
127 // Initialization of vtables and mirror object is done separatly from base_create_array_klass,
128 // since a GC can happen. At this point all instance variables of the ArrayKlass must be setup.
129 void ArrayKlass::complete_create_array_klass(ArrayKlass* k, Klass* super_klass, ModuleEntry* module_entry, TRAPS) {
130   k-&gt;initialize_supers(super_klass, NULL, CHECK);
131   k-&gt;vtable().initialize_vtable(false, CHECK);
132 
133   // During bootstrapping, before java.base is defined, the module_entry may not be present yet.
</pre>
</td>
<td>
<hr />
<pre>
 93     // the vtable of klass Object.
 94     set_vtable_length(Universe::base_vtable_size());
 95     set_name(name);
 96     set_super(Universe::is_bootstrapping() ? NULL : SystemDictionary::Object_klass());
 97     set_layout_helper(Klass::_lh_neutral_value);
 98     set_is_cloneable(); // All arrays are considered to be cloneable (See JLS 20.1.5)
 99     JFR_ONLY(INIT_ID(this);)
100 }
101 
102 Symbol* ArrayKlass::create_element_klass_array_name(Klass* element_klass, TRAPS) {
103   ResourceMark rm(THREAD);
104   Symbol* name = NULL;
105   bool is_qtype = element_klass-&gt;is_value();
106   char *name_str = element_klass-&gt;name()-&gt;as_C_string();
107   int len = element_klass-&gt;name()-&gt;utf8_length();
108   char *new_str = NEW_RESOURCE_ARRAY(char, len + 4);
109   int idx = 0;
110   new_str[idx++] = JVM_SIGNATURE_ARRAY;
111   if (element_klass-&gt;is_instance_klass()) { // it could be an array or simple type
112     if (is_qtype) {
<span class="line-modified">113       new_str[idx++] = JVM_SIGNATURE_INLINE_TYPE;</span>
114     } else {
115       new_str[idx++] = JVM_SIGNATURE_CLASS;
116     }
117   }
118   memcpy(&amp;new_str[idx], name_str, len * sizeof(char));
119   idx += len;
120   if (element_klass-&gt;is_instance_klass()) {
121     new_str[idx++] = JVM_SIGNATURE_ENDCLASS;
122   }
123   new_str[idx++] = &#39;\0&#39;;
124   return SymbolTable::new_symbol(new_str);
125 }
126 
127 // Initialization of vtables and mirror object is done separatly from base_create_array_klass,
128 // since a GC can happen. At this point all instance variables of the ArrayKlass must be setup.
129 void ArrayKlass::complete_create_array_klass(ArrayKlass* k, Klass* super_klass, ModuleEntry* module_entry, TRAPS) {
130   k-&gt;initialize_supers(super_klass, NULL, CHECK);
131   k-&gt;vtable().initialize_vtable(false, CHECK);
132 
133   // During bootstrapping, before java.base is defined, the module_entry may not be present yet.
</pre>
</td>
</tr>
</table>
<center><a href="../interpreter/interpreterRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
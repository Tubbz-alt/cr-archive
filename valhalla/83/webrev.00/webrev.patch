diff a/src/hotspot/share/ci/ciEnv.cpp b/src/hotspot/share/ci/ciEnv.cpp
--- a/src/hotspot/share/ci/ciEnv.cpp
+++ b/src/hotspot/share/ci/ciEnv.cpp
@@ -467,11 +467,11 @@
   // to be loaded if their element klasses are loaded, except when memory
   // is exhausted.
   if (Signature::is_array(sym) &&
       (sym->char_at(1) == JVM_SIGNATURE_ARRAY ||
        sym->char_at(1) == JVM_SIGNATURE_CLASS ||
-       sym->char_at(1) == JVM_SIGNATURE_VALUETYPE )) {
+       sym->char_at(1) == JVM_SIGNATURE_INLINETYPE )) {
     // We have an unloaded array.
     // Build it on the fly if the element class exists.
     SignatureStream ss(sym, false);
     ss.skip_array_prefix(1);
     // Get element ciKlass recursively.
@@ -510,11 +510,11 @@
   // Make a CI representative for it.
   int i = 0;
   while (sym->char_at(i) == JVM_SIGNATURE_ARRAY) {
     i++;
   }
-  if (i > 0 && sym->char_at(i) == JVM_SIGNATURE_VALUETYPE) {
+  if (i > 0 && sym->char_at(i) == JVM_SIGNATURE_INLINETYPE) {
     // An unloaded array class of value types is an ObjArrayKlass, an
     // unloaded value type class is an InstanceKlass. For consistency,
     // make the signature of the unloaded array of value type use L
     // rather than Q.
     char *new_name = CURRENT_THREAD_ENV->name_buffer(sym->utf8_length()+1);
diff a/src/hotspot/share/ci/ciObjArrayKlass.cpp b/src/hotspot/share/ci/ciObjArrayKlass.cpp
--- a/src/hotspot/share/ci/ciObjArrayKlass.cpp
+++ b/src/hotspot/share/ci/ciObjArrayKlass.cpp
@@ -114,11 +114,11 @@
   int pos = 0;
   for ( ; pos < dimension; pos++) {
     name[pos] = JVM_SIGNATURE_ARRAY;
   }
   Symbol* base_name_sym = element_name->get_symbol();
-  assert(base_name_sym->char_at(0) != JVM_SIGNATURE_VALUETYPE, "unloaded array klass element should not have Q-type");
+  assert(base_name_sym->char_at(0) != JVM_SIGNATURE_INLINETYPE, "unloaded array klass element should not have Q-type");
   if (Signature::is_array(base_name_sym) ||
       Signature::has_envelope(base_name_sym)) {
     strncpy(&name[pos], (char*)element_name->base(), element_len);
     name[pos + element_len] = '\0';
   } else {
diff a/src/hotspot/share/ci/ciReplay.cpp b/src/hotspot/share/ci/ciReplay.cpp
--- a/src/hotspot/share/ci/ciReplay.cpp
+++ b/src/hotspot/share/ci/ciReplay.cpp
@@ -910,11 +910,11 @@
         } else if (field_signature[0] == JVM_SIGNATURE_ARRAY &&
                    field_signature[1] == JVM_SIGNATURE_CLASS) {
           Klass* kelem = resolve_klass(field_signature + 1, CHECK_(true));
           value = oopFactory::new_objArray(kelem, length, CHECK_(true));
         } else if (field_signature[0] == JVM_SIGNATURE_ARRAY &&
-                   field_signature[1] == JVM_SIGNATURE_VALUETYPE) {
+                   field_signature[1] == JVM_SIGNATURE_INLINETYPE) {
           Klass* kelem = resolve_klass(field_signature + 1, CHECK_(true));
           value = oopFactory::new_valueArray(kelem, length, CHECK_(true));
         } else {
           report_error("unhandled array staticfield");
         }
@@ -997,11 +997,11 @@
       java_mirror->float_field_put(fd.offset(), value);
     } else if (strcmp(field_signature, "D") == 0) {
       const char* string_value = parse_escaped_string();
       double value = atof(string_value);
       java_mirror->double_field_put(fd.offset(), value);
-    } else if (field_signature[0] == JVM_SIGNATURE_VALUETYPE) {
+    } else if (field_signature[0] == JVM_SIGNATURE_INLINETYPE) {
       Klass* kelem = resolve_klass(field_signature, CHECK);
       ValueKlass* vk = ValueKlass::cast(kelem);
       oop value = vk->allocate_instance(CHECK);
       ValueTypeFieldInitializer init_fields(value, this);
       vk->do_nonstatic_fields(&init_fields);
diff a/src/hotspot/share/ci/ciValueArrayKlass.cpp b/src/hotspot/share/ci/ciValueArrayKlass.cpp
--- a/src/hotspot/share/ci/ciValueArrayKlass.cpp
+++ b/src/hotspot/share/ci/ciValueArrayKlass.cpp
@@ -112,11 +112,11 @@
     name = CURRENT_THREAD_ENV->name_buffer(new_len);
     int pos = 0;
     for ( ; pos < dimension; pos++) {
       name[pos] = JVM_SIGNATURE_ARRAY;
     }
-    name[pos++] = JVM_SIGNATURE_VALUETYPE;
+    name[pos++] = JVM_SIGNATURE_INLINETYPE;
     strncpy(name+pos, (char*)element_name->base(), element_len);
     name[new_len-2] = JVM_SIGNATURE_ENDCLASS;
     name[new_len-1] = '\0';
   }
   return ciSymbol::make(name);
diff a/src/hotspot/share/classfile/classFileParser.cpp b/src/hotspot/share/classfile/classFileParser.cpp
--- a/src/hotspot/share/classfile/classFileParser.cpp
+++ b/src/hotspot/share/classfile/classFileParser.cpp
@@ -4521,11 +4521,11 @@
 
   const bool super_has_nonstatic_fields =
           (_super_klass != NULL && _super_klass->has_nonstatic_fields());
   const bool has_nonstatic_fields =
     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
-  const bool has_nonstatic_value_fields = nonstatic_inline_type_count > 0;
+  const bool has_nonstatic_inline_fields = nonstatic_inline_type_count > 0;
 
   if (is_inline_type() && (!has_nonstatic_fields)) {
     // There are a number of fixes required throughout the type system and JIT
     throwInlineTypeLimitation(THREAD_AND_LOCATION, "Inline Types do not support zero instance size yet");
     return;
@@ -4919,11 +4919,11 @@
   // Number of non-static oop map blocks allocated at end of klass.
   nonstatic_oop_maps->compact();
 
 #ifndef PRODUCT
   if ((PrintFieldLayout && !is_inline_type()) ||
-      (PrintInlineLayout && (is_inline_type() || has_nonstatic_value_fields))) {
+      (PrintInlineLayout && (is_inline_type() || has_nonstatic_inline_fields))) {
     print_field_layout(_class_name,
           _fields,
           cp,
           instance_size,
           nonstatic_fields_start,
@@ -5766,11 +5766,11 @@
     case JVM_SIGNATURE_INT:
     case JVM_SIGNATURE_FLOAT:
     case JVM_SIGNATURE_LONG:
     case JVM_SIGNATURE_DOUBLE:
       return signature + 1;
-    case JVM_SIGNATURE_VALUETYPE:
+    case JVM_SIGNATURE_INLINETYPE:
       // Can't enable this check until JDK upgrades the bytecode generators
       // if (_major_version < CONSTANT_CLASS_DESCRIPTORS ) {
       //   classfile_parse_error("Class name contains illegal Q-signature "
       //                                    "in descriptor in class file %s",
       //                                    CHECK_0);
@@ -7276,11 +7276,11 @@
   assert(_parsed_annotations != NULL, "invariant");
 
 
   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
     if (Signature::basic_type(fs.signature()) == T_VALUETYPE  && !fs.access_flags().is_static()) {
-      // Pre-load value class
+      // Pre-load inline class
       Klass* klass = SystemDictionary::resolve_inline_type_field_or_fail(&fs,
           Handle(THREAD, _loader_data->class_loader()),
           _protection_domain, true, CHECK);
       assert(klass != NULL, "Sanity check");
       assert(klass->access_flags().is_inline_type(), "Value type expected");
diff a/src/hotspot/share/classfile/classLoader.cpp b/src/hotspot/share/classfile/classLoader.cpp
--- a/src/hotspot/share/classfile/classLoader.cpp
+++ b/src/hotspot/share/classfile/classLoader.cpp
@@ -200,11 +200,11 @@
 
     // Fully qualified class names should not contain a 'L'.
     // Set bad_class_name to true to indicate that the package name
     // could not be obtained due to an error condition.
     // In this situation, is_same_class_package returns false.
-    if (*start == JVM_SIGNATURE_CLASS || *start == JVM_SIGNATURE_VALUETYPE) {
+    if (*start == JVM_SIGNATURE_CLASS || *start == JVM_SIGNATURE_INLINETYPE) {
       if (bad_class_name != NULL) {
         *bad_class_name = true;
       }
       return NULL;
     }
diff a/src/hotspot/share/classfile/stackMapFrame.cpp b/src/hotspot/share/classfile/stackMapFrame.cpp
--- a/src/hotspot/share/classfile/stackMapFrame.cpp
+++ b/src/hotspot/share/classfile/stackMapFrame.cpp
@@ -110,11 +110,11 @@
           verifier()->create_temporary_symbol(sig);
         assert(sig_copy == sig, "symbols don't match");
         sig = sig_copy;
       }
       if (ss.type() == T_VALUETYPE) {
-        return VerificationType::valuetype_type(sig);
+        return VerificationType::inlinetype_type(sig);
       }
       return VerificationType::reference_type(sig);
     }
     case T_INT:     return VerificationType::integer_type();
     case T_BYTE:    return VerificationType::byte_type();
diff a/src/hotspot/share/classfile/stackMapTable.cpp b/src/hotspot/share/classfile/stackMapTable.cpp
--- a/src/hotspot/share/classfile/stackMapTable.cpp
+++ b/src/hotspot/share/classfile/stackMapTable.cpp
@@ -192,11 +192,11 @@
       Symbol* fund_name = klass_name->fundamental_name(THREAD);
       if (fund_name == NULL) {
         _stream->stackmap_format_error("TBD something bad happened", THREAD);
         return VerificationType::bogus_type();
       }
-      return VerificationType::valuetype_type(fund_name);
+      return VerificationType::inlinetype_type(fund_name);
     } else {
       return VerificationType::reference_type(klass_name);
     }
   }
   if (tag == ITEM_UninitializedThis) {
diff a/src/hotspot/share/classfile/verificationType.cpp b/src/hotspot/share/classfile/verificationType.cpp
--- a/src/hotspot/share/classfile/verificationType.cpp
+++ b/src/hotspot/share/classfile/verificationType.cpp
@@ -123,15 +123,15 @@
   } else if (is_array() && from.is_array()) {
     VerificationType comp_this = get_component(context, CHECK_false);
     VerificationType comp_from = from.get_component(context, CHECK_false);
 
 /*
-    // This code implements non-covariance between value type arrays and both
+    // This code implements non-covariance between inline type arrays and both
     // arrays of objects and arrays of interface types.  If covariance is
-    // supported for value type arrays then this code should be removed.
-    if (comp_from.is_valuetype() && !comp_this.is_null() && comp_this.is_reference()) {
-      // An array of value types is not assignable to an array of java.lang.Objects.
+    // supported for inline type arrays then this code should be removed.
+    if (comp_from.is_inlinetype() && !comp_this.is_null() && comp_this.is_reference()) {
+      // An array of inline types is not assignable to an array of java.lang.Objects.
       if (comp_this.name() == vmSymbols::java_lang_Object()) {
         return false;
       }
 
       // Need to load 'comp_this' to see if it is an interface.
@@ -143,11 +143,11 @@
             Handle(THREAD, klass->protection_domain()), true, CHECK_false);
         klass->class_loader_data()->record_dependency(comp_this_class);
         if (log_is_enabled(Debug, class, resolve)) {
           Verifier::trace_class_resolution(comp_this_class, klass);
         }
-        // An array of value types is not assignable to an array of interface types.
+        // An array of inline types is not assignable to an array of interface types.
         if (comp_this_class->is_interface()) {
           return false;
         }
       }
     }
@@ -158,19 +158,19 @@
     }
   }
   return false;
 }
 
-bool VerificationType::is_valuetype_assignable_from(const VerificationType& from) const {
-  // Check that 'from' is not null, is a value type, and is the same value type.
-  assert(is_valuetype(), "called with a non-valuetype type");
-  assert(!is_null(), "valuetype is not null");
-  return (!from.is_null() && from.is_valuetype() && name() == from.name());
+bool VerificationType::is_inlinetype_assignable_from(const VerificationType& from) const {
+  // Check that 'from' is not null, is an inline type, and is the same inline type.
+  assert(is_inlinetype(), "called with a non-inlinetype type");
+  assert(!is_null(), "inlinetype is not null");
+  return (!from.is_null() && from.is_inlinetype() && name() == from.name());
 }
 
-bool VerificationType::is_ref_assignable_from_value_type(const VerificationType& from, ClassVerifier* context, TRAPS) const {
-  assert(!from.is_null(), "Value type should not be null");
+bool VerificationType::is_ref_assignable_from_inline_type(const VerificationType& from, ClassVerifier* context, TRAPS) const {
+  assert(!from.is_null(), "Inline type should not be null");
   if (!is_null() && (name()->is_same_fundamental_type(from.name()) ||
       name() == vmSymbols::java_lang_Object())) {
     return true;
   }
 
@@ -219,11 +219,11 @@
       Symbol* component = ss.as_symbol();
       // Create another symbol to save as signature stream unreferences this symbol.
       Symbol* component_copy = context->create_temporary_symbol(component);
       assert(component_copy == component, "symbols don't match");
       return (ss.type() == T_VALUETYPE) ?
-        VerificationType::valuetype_type(component_copy) :
+        VerificationType::inlinetype_type(component_copy) :
         VerificationType::reference_type(component_copy);
    }
    default:
      // Met an invalid type signature, e.g. [X
      return VerificationType::bogus_type();
@@ -246,21 +246,21 @@
     case Double:           st->print("double"); break;
     case Long_2nd:         st->print("long_2nd"); break;
     case Double_2nd:       st->print("double_2nd"); break;
     case Null:             st->print("null"); break;
     case ReferenceQuery:   st->print("reference type"); break;
-    case ValueTypeQuery:   st->print("inline type"); break;
+    case InlineTypeQuery:  st->print("inline type"); break;
     case NonScalarQuery:   st->print("reference or inline type"); break;
     case Category1Query:   st->print("category1 type"); break;
     case Category2Query:   st->print("category2 type"); break;
     case Category2_2ndQuery: st->print("category2_2nd type"); break;
     default:
       if (is_uninitialized_this()) {
         st->print("uninitializedThis");
       } else if (is_uninitialized()) {
         st->print("uninitialized %d", bci());
-      } else if (is_valuetype()) {
+      } else if (is_inlinetype()) {
         name()->print_Qvalue_on(st);
       } else {
         if (name() != NULL) {
           name()->print_value_on(st);
         } else {
diff a/src/hotspot/share/classfile/verificationType.hpp b/src/hotspot/share/classfile/verificationType.hpp
--- a/src/hotspot/share/classfile/verificationType.hpp
+++ b/src/hotspot/share/classfile/verificationType.hpp
@@ -67,28 +67,28 @@
       ITEM_Long_2nd, ITEM_Double_2nd
     };
 
     // Enum for the _data field
     enum {
-      // Bottom three bits determine if the type is a reference, value type,
+      // Bottom three bits determine if the type is a reference, inline type,
       // primitive, uninitialized or a query-type.
       TypeMask           = 0x00000007,
 
       // Topmost types encoding
       Reference          = 0x0,        // _sym contains the name of an object
       Primitive          = 0x1,        // see below for primitive list
       Uninitialized      = 0x2,        // 0x00ffff00 contains bci
       TypeQuery          = 0x3,        // Meta-types used for category testing
-      ValueType          = 0x4,        // _sym contains the name of a value type
+      InlineType         = 0x4,        // _sym contains the name of an inline type
 
       // Utility flags
       ReferenceFlag      = 0x00,       // For reference query types
       Category1Flag      = 0x01,       // One-word values
       Category2Flag      = 0x02,       // First word of a two-word value
       Category2_2ndFlag  = 0x04,       // Second word of a two-word value
-      ValueTypeFlag      = 0x08,       // For value type query types
-      NonScalarFlag      = 0x10,       // For either value type or reference queries
+      InlineTypeFlag     = 0x08,       // For inline type query types
+      NonScalarFlag      = 0x10,       // For either inline type or reference queries
 
       // special reference values
       Null               = 0x00000000, // A reference with a 0 sym is null
 
       // Primitives categories (the second byte determines the category)
@@ -117,11 +117,11 @@
       // Query values
       ReferenceQuery     = (ReferenceFlag     << 1 * BitsPerByte) | TypeQuery,
       Category1Query     = (Category1Flag     << 1 * BitsPerByte) | TypeQuery,
       Category2Query     = (Category2Flag     << 1 * BitsPerByte) | TypeQuery,
       Category2_2ndQuery = (Category2_2ndFlag << 1 * BitsPerByte) | TypeQuery,
-      ValueTypeQuery     = (ValueTypeFlag     << 1 * BitsPerByte) | TypeQuery,
+      InlineTypeQuery    = (InlineTypeFlag    << 1 * BitsPerByte) | TypeQuery,
       NonScalarQuery     = (NonScalarFlag     << 1 * BitsPerByte) | TypeQuery
     };
 
   VerificationType(uintptr_t raw_data) {
     _u._data = raw_data;
@@ -151,12 +151,12 @@
   // to anything, but the specified types are assignable to a "check".  For
   // example, any category1 primitive is assignable to category1_check and
   // any reference is assignable to reference_check.
   static VerificationType reference_check()
     { return VerificationType(ReferenceQuery); }
-  static VerificationType valuetype_check()
-    { return VerificationType(ValueTypeQuery); }
+  static VerificationType inlinetype_check()
+    { return VerificationType(InlineTypeQuery); }
   static VerificationType category1_check()
     { return VerificationType(Category1Query); }
   static VerificationType category2_check()
     { return VerificationType(Category2Query); }
   static VerificationType category2_2nd_check()
@@ -167,27 +167,27 @@
   // For reference types, store the actual Symbol
   static VerificationType reference_type(Symbol* sh) {
       assert(((uintptr_t)sh & TypeMask) == 0, "Symbols must be aligned");
       // If the above assert fails in the future because oop* isn't aligned,
       // then this type encoding system will have to change to have a tag value
-      // to descriminate between oops and primitives.
+      // to discriminate between oops and primitives.
       return VerificationType((uintptr_t)sh);
   }
   static VerificationType uninitialized_type(u2 bci)
     { return VerificationType(bci << 1 * BitsPerByte | Uninitialized); }
   static VerificationType uninitialized_this_type()
     { return uninitialized_type(BciForThis); }
 
-  // For value types, store the actual Symbol* and set the 3rd bit.
-  // Provides a way for a value type to be distinguished from a reference type.
-  static VerificationType valuetype_type(Symbol* sh) {
+  // For inline types, store the actual Symbol* and set the 3rd bit.
+  // Provides a way for an inline type to be distinguished from a reference type.
+  static VerificationType inlinetype_type(Symbol* sh) {
       assert(((uintptr_t)sh & TypeMask) == 0, "Symbols must be aligned");
-      assert((uintptr_t)sh != 0, "Null is not a valid value type");
+      assert((uintptr_t)sh != 0, "Null is not a valid inline type");
       // If the above assert fails in the future because oop* isn't aligned,
       // then this type encoding system will have to change to have a tag value
-      // to descriminate between oops and primitives.
-      return VerificationType((uintptr_t)sh | ValueType);
+      // to discriminate between oops and primitives.
+      return VerificationType((uintptr_t)sh | InlineType);
   }
 
   // Create based on u1 read from classfile
   static VerificationType from_tag(u1 tag);
 
@@ -201,15 +201,15 @@
   bool is_long() const      { return (_u._data == Long); }
   bool is_float() const     { return (_u._data == Float); }
   bool is_double() const    { return (_u._data == Double); }
   bool is_long2() const     { return (_u._data == Long_2nd); }
   bool is_double2() const   { return (_u._data == Double_2nd); }
-  bool is_reference() const { return (((_u._data & TypeMask) == Reference) && !is_valuetype_check()); }
-  bool is_valuetype() const { return ((_u._data & TypeMask) == ValueType); }
+  bool is_reference() const { return (((_u._data & TypeMask) == Reference) && !is_inlinetype_check()); }
+  bool is_inlinetype() const { return ((_u._data & TypeMask) == InlineType); }
   bool is_category1() const {
     // This should return true for all one-word types, which are category1
-    // primitives, references (including uninitialized refs) and value types.
+    // primitives, references (including uninitialized refs) and inline types.
     // Though the 'query' types should technically return 'false' here, if we
     // allow this to return true, we can perform the test using only
     // 2 operations rather than 8 (3 masks, 3 compares and 2 logical 'ands').
     // Since noone should call this on a query type anyway, this is ok.
     assert(!is_check(), "Must not be a check type (wrong value returned)");
@@ -220,11 +220,11 @@
   bool is_category2() const { return ((_u._data & Category2) == Category2); }
   bool is_category2_2nd() const {
     return ((_u._data & Category2_2nd) == Category2_2nd);
   }
   bool is_reference_check() const { return _u._data == ReferenceQuery; }
-  bool is_valuetype_check() const { return _u._data == ValueTypeQuery; }
+  bool is_inlinetype_check() const { return _u._data == InlineTypeQuery; }
   bool is_nonscalar_check() const { return _u._data == NonScalarQuery; }
   bool is_category1_check() const { return _u._data == Category1Query; }
   bool is_category2_check() const { return _u._data == Category2Query; }
   bool is_category2_2nd_check() const { return _u._data == Category2_2ndQuery; }
   bool is_check() const { return (_u._data & TypeQuery) == TypeQuery; }
@@ -240,15 +240,15 @@
   bool is_long_array() const { return is_x_array(JVM_SIGNATURE_LONG); }
   bool is_float_array() const { return is_x_array(JVM_SIGNATURE_FLOAT); }
   bool is_double_array() const { return is_x_array(JVM_SIGNATURE_DOUBLE); }
   bool is_object_array() const { return is_x_array(JVM_SIGNATURE_CLASS); }
   bool is_array_array() const { return is_x_array(JVM_SIGNATURE_ARRAY); }
-  bool is_value_array() const { return is_x_array(JVM_SIGNATURE_VALUETYPE); }
+  bool is_inline_array() const { return is_x_array(JVM_SIGNATURE_INLINETYPE); }
   bool is_reference_array() const
     { return is_object_array() || is_array_array(); }
   bool is_nonscalar_array() const
-    { return is_object_array() || is_array_array() || is_value_array(); }
+    { return is_object_array() || is_array_array() || is_inline_array(); }
   bool is_object() const
     { return (is_reference() && !is_null() && name()->utf8_length() >= 1 &&
               name()->char_at(0) != JVM_SIGNATURE_ARRAY); }
   bool is_array() const
     { return (is_reference() && !is_null() && name()->utf8_length() >= 2 &&
@@ -261,30 +261,30 @@
   VerificationType to_category2_2nd() const {
     assert(is_category2(), "Must be a double word");
     return VerificationType(is_long() ? Long_2nd : Double_2nd);
   }
 
-  static VerificationType change_ref_to_valuetype(VerificationType ref) {
+  static VerificationType change_ref_to_inlinetype(VerificationType ref) {
     assert(ref.is_reference(), "Bad arg");
     assert(!ref.is_null(), "Unexpected NULL");
-    return valuetype_type(ref.name());
+    return inlinetype_type(ref.name());
   }
 
   u2 bci() const {
     assert(is_uninitialized(), "Must be uninitialized type");
     return ((_u._data & BciMask) >> 1 * BitsPerByte);
   }
 
   Symbol* name() const {
-    assert(!is_null() && (is_reference() || is_valuetype()), "Must be a non-null reference or a value type");
-    return (is_reference() ? _u._sym : ((Symbol*)(_u._data & ~(uintptr_t)ValueType)));
+    assert(!is_null() && (is_reference() || is_inlinetype()), "Must be a non-null reference or an inline type");
+    return (is_reference() ? _u._sym : ((Symbol*)(_u._data & ~(uintptr_t)InlineType)));
   }
 
   bool equals(const VerificationType& t) const {
     return (_u._data == t._u._data ||
             (((is_reference() && t.is_reference()) ||
-             (is_valuetype() && t.is_valuetype())) &&
+             (is_inlinetype() && t.is_inlinetype())) &&
               !is_null() && !t.is_null() && name() == t.name()));
 
   }
 
   bool operator ==(const VerificationType& t) const {
@@ -313,24 +313,24 @@
           return from.is_category2_2nd();
         case ReferenceQuery:
           return from.is_reference() || from.is_uninitialized();
         case NonScalarQuery:
           return from.is_reference() || from.is_uninitialized() ||
-                 from.is_valuetype();
-        case ValueTypeQuery:
-          return from.is_valuetype();
+                 from.is_inlinetype();
+        case InlineTypeQuery:
+          return from.is_inlinetype();
         case Boolean:
         case Byte:
         case Char:
         case Short:
           // An int can be assigned to boolean, byte, char or short values.
           return from.is_integer();
         default:
-          if (is_valuetype()) {
-            return is_valuetype_assignable_from(from);
-          } else if (is_reference() && from.is_valuetype()) {
-            return is_ref_assignable_from_value_type(from, context, THREAD);
+          if (is_inlinetype()) {
+            return is_inlinetype_assignable_from(from);
+          } else if (is_reference() && from.is_inlinetype()) {
+            return is_ref_assignable_from_inline_type(from, context, THREAD);
           } else if (is_reference() && from.is_reference()) {
             return is_reference_assignable_from(from, context,
                                                 from_field_is_protected,
                                                 THREAD);
           } else {
@@ -375,13 +375,13 @@
 
   bool is_reference_assignable_from(
     const VerificationType&, ClassVerifier*, bool from_field_is_protected,
     TRAPS) const;
 
-  bool is_valuetype_assignable_from(const VerificationType& from) const;
+  bool is_inlinetype_assignable_from(const VerificationType& from) const;
 
-  bool is_ref_assignable_from_value_type(const VerificationType& from, ClassVerifier* context, TRAPS) const;
+  bool is_ref_assignable_from_inline_type(const VerificationType& from, ClassVerifier* context, TRAPS) const;
 
 
  public:
   static bool resolve_and_check_assignability(InstanceKlass* klass, Symbol* name,
                                               Symbol* from_name, bool from_field_is_protected,
diff a/src/hotspot/share/classfile/verifier.cpp b/src/hotspot/share/classfile/verifier.cpp
--- a/src/hotspot/share/classfile/verifier.cpp
+++ b/src/hotspot/share/classfile/verifier.cpp
@@ -58,11 +58,11 @@
 #include "utilities/bytes.hpp"
 
 #define NOFAILOVER_MAJOR_VERSION                       51
 #define NONZERO_PADDING_BYTES_IN_SWITCH_MAJOR_VERSION  51
 #define STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION       52
-#define VALUETYPE_MAJOR_VERSION                        56
+#define INLINETYPE_MAJOR_VERSION                       56
 #define MAX_ARRAY_DIMENSIONS 255
 
 // Access to external entry for VerifyClassForMajorVersion - old byte code verifier
 
 extern "C" {
@@ -485,11 +485,11 @@
       ss->print("Expected stackmap frame at this location.");
       break;
     case BAD_STACKMAP:
       ss->print("Invalid stackmap specification.");
       break;
-    case WRONG_VALUE_TYPE:
+    case WRONG_INLINE_TYPE:
       ss->print("Type ");
       _type.details(ss);
       ss->print(" and type ");
       _expected.details(ss);
       ss->print(" must be identical inline types.");
@@ -586,23 +586,23 @@
   }
 }
 
 // Methods in ClassVerifier
 
-VerificationType reference_or_valuetype(InstanceKlass* klass) {
+VerificationType reference_or_inlinetype(InstanceKlass* klass) {
   if (klass->is_value()) {
-    return VerificationType::valuetype_type(klass->name());
+    return VerificationType::inlinetype_type(klass->name());
   } else {
     return VerificationType::reference_type(klass->name());
   }
 }
 
 ClassVerifier::ClassVerifier(
     InstanceKlass* klass, TRAPS)
     : _thread(THREAD), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),
       _message(NULL), _method_signatures_table(NULL), _klass(klass) {
-  _this_type = reference_or_valuetype(klass);
+  _this_type = reference_or_inlinetype(klass);
 }
 
 ClassVerifier::~ClassVerifier() {
   // Decrement the reference count for any symbols created.
   if (_symbols != NULL) {
@@ -1706,11 +1706,11 @@
           // pass FALSE, operand can't be an array type for getfield/putfield.
           verify_field_instructions(
             &bcs, &current_frame, cp, false, CHECK_VERIFY(this));
           no_control_flow = false; break;
         case Bytecodes::_withfield :
-          if (_klass->major_version() < VALUETYPE_MAJOR_VERSION) {
+          if (_klass->major_version() < INLINETYPE_MAJOR_VERSION) {
             class_format_error(
               "withfield not supported by this class file version (%d.%d), class %s",
               _klass->major_version(), _klass->minor_version(), _klass->external_name());
             return;
           }
@@ -1743,11 +1743,11 @@
           current_frame.push_stack(type, CHECK_VERIFY(this));
           no_control_flow = false; break;
         }
         case Bytecodes::_defaultvalue :
         {
-          if (_klass->major_version() < VALUETYPE_MAJOR_VERSION) {
+          if (_klass->major_version() < INLINETYPE_MAJOR_VERSION) {
             class_format_error(
               "defaultvalue not supported by this class file version (%d.%d), class %s",
               _klass->major_version(), _klass->minor_version(), _klass->external_name());
             return;
           }
@@ -1758,13 +1758,13 @@
             verify_error(ErrorContext::bad_type(bci,
                 TypeOrigin::cp(index, ref_type)),
                 "Illegal defaultvalue instruction");
             return;
           }
-          VerificationType value_type =
-            VerificationType::change_ref_to_valuetype(ref_type);
-          current_frame.push_stack(value_type, CHECK_VERIFY(this));
+          VerificationType inline_type =
+            VerificationType::change_ref_to_inlinetype(ref_type);
+          current_frame.push_stack(inline_type, CHECK_VERIFY(this));
           no_control_flow = false; break;
         }
         case Bytecodes::_newarray :
           type = get_newarray_type(bcs.get_index(), bci, CHECK_VERIFY(this));
           current_frame.pop_stack(
@@ -2398,23 +2398,23 @@
     }
     case Bytecodes::_withfield: {
       for (int i = n - 1; i >= 0; i--) {
         current_frame->pop_stack(field_type[i], CHECK_VERIFY(this));
       }
-      // stack_object_type and target_class_type must be the same value type.
+      // stack_object_type and target_class_type must be the same inline type.
       stack_object_type =
-        current_frame->pop_stack(VerificationType::valuetype_check(), CHECK_VERIFY(this));
-      VerificationType target_value_type =
-        VerificationType::change_ref_to_valuetype(target_class_type);
-      if (!stack_object_type.equals(target_value_type)) {
-        verify_error(ErrorContext::bad_value_type(bci,
+        current_frame->pop_stack(VerificationType::inlinetype_check(), CHECK_VERIFY(this));
+      VerificationType target_inline_type =
+        VerificationType::change_ref_to_inlinetype(target_class_type);
+      if (!stack_object_type.equals(target_inline_type)) {
+        verify_error(ErrorContext::bad_inline_type(bci,
             current_frame->stack_top_ctx(),
             TypeOrigin::cp(index, target_class_type)),
             "Invalid type on operand stack in withfield instruction");
         return;
       }
-      current_frame->push_stack(target_value_type, CHECK_VERIFY(this));
+      current_frame->push_stack(target_inline_type, CHECK_VERIFY(this));
       break;
     }
     case Bytecodes::_getfield: {
       stack_object_type = current_frame->pop_stack(
         target_class_type, CHECK_VERIFY(this));
@@ -2931,19 +2931,19 @@
       return;
     }
   } else if (opcode == Bytecodes::_invokespecial
              && !is_same_or_direct_interface(current_class(), current_type(), ref_class_type)
              && !ref_class_type.equals(VerificationType::reference_type(
-                  current_class()->super()->name()))) { // super() can never be a value_type.
+                  current_class()->super()->name()))) { // super() can never be an inline_type.
     bool subtype = false;
     bool have_imr_indirect = cp->tag_at(index).value() == JVM_CONSTANT_InterfaceMethodref;
     if (!current_class()->is_unsafe_anonymous()) {
       subtype = ref_class_type.is_assignable_from(
                  current_type(), this, false, CHECK_VERIFY(this));
     } else {
       InstanceKlass* unsafe_host = current_class()->unsafe_anonymous_host();
-      VerificationType unsafe_anonymous_host_type = reference_or_valuetype(unsafe_host);
+      VerificationType unsafe_anonymous_host_type = reference_or_inlinetype(unsafe_host);
       subtype = ref_class_type.is_assignable_from(unsafe_anonymous_host_type, this, false, CHECK_VERIFY(this));
 
       // If invokespecial of IMR, need to recheck for same or
       // direct interface relative to the host class
       have_imr_indirect = (have_imr_indirect &&
@@ -2993,11 +2993,11 @@
           // objectref is a subtype of the unsafe_anonymous_host of the current class
           // to allow an anonymous class to reference methods in the unsafe_anonymous_host
           VerificationType top = current_frame->pop_stack(CHECK_VERIFY(this));
 
           InstanceKlass* unsafe_host = current_class()->unsafe_anonymous_host();
-          VerificationType host_type = reference_or_valuetype(unsafe_host);
+          VerificationType host_type = reference_or_inlinetype(unsafe_host);
           bool subtype = host_type.is_assignable_from(top, this, false, CHECK_VERIFY(this));
           if (!subtype) {
             verify_error( ErrorContext::bad_type(current_frame->offset(),
               current_frame->stack_top_ctx(),
               TypeOrigin::implicit(top)),
@@ -3117,11 +3117,11 @@
     int n = os::snprintf(arr_sig_str, length + 1, "%c%s",
                          JVM_SIGNATURE_ARRAY, component_name);
     assert(n == length, "Unexpected number of characters in string");
   } else {         // it's an object or interface
     const char* component_name = component_type.name()->as_utf8();
-    char Q_or_L = component_type.is_valuetype() ? JVM_SIGNATURE_VALUETYPE : JVM_SIGNATURE_CLASS;
+    char Q_or_L = component_type.is_inlinetype() ? JVM_SIGNATURE_INLINETYPE : JVM_SIGNATURE_CLASS;
     // add one dimension to component with 'L' or 'Q' prepended and ';' appended.
     length = (int)strlen(component_name) + 3;
     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
     int n = os::snprintf(arr_sig_str, length + 1, "%c%c%s;",
                          JVM_SIGNATURE_ARRAY, Q_or_L, component_name);
diff a/src/hotspot/share/classfile/verifier.hpp b/src/hotspot/share/classfile/verifier.hpp
--- a/src/hotspot/share/classfile/verifier.hpp
+++ b/src/hotspot/share/classfile/verifier.hpp
@@ -152,11 +152,11 @@
     STACK_SIZE_MISMATCH,  // Frames have different stack sizes
     STACK_OVERFLOW,       // Attempt to push onto a full expression stack
     STACK_UNDERFLOW,      // Attempt to pop and empty expression stack
     MISSING_STACKMAP,     // No stackmap for this location and there should be
     BAD_STACKMAP,         // Format error in stackmap
-    WRONG_VALUE_TYPE,     // Mismatched value type
+    WRONG_INLINE_TYPE,    // Mismatched inline type
     NO_FAULT,             // No error
     UNKNOWN
   } FaultType;
 
   int _bci;
@@ -216,12 +216,12 @@
     return ErrorContext(bci, MISSING_STACKMAP);
   }
   static ErrorContext bad_stackmap(int index, StackMapFrame* frame) {
     return ErrorContext(0, BAD_STACKMAP, TypeOrigin::frame(frame));
   }
-  static ErrorContext bad_value_type(u2 bci, TypeOrigin type, TypeOrigin exp) {
-    return ErrorContext(bci, WRONG_VALUE_TYPE, type, exp);
+  static ErrorContext bad_inline_type(u2 bci, TypeOrigin type, TypeOrigin exp) {
+    return ErrorContext(bci, WRONG_INLINE_TYPE, type, exp);
   }
 
   bool is_valid() const { return _fault != NO_FAULT; }
   int bci() const { return _bci; }
 
@@ -456,11 +456,11 @@
     Symbol* name = cp->klass_name_at(index);
     if (name->is_Q_signature()) {
       // Remove the Q and ;
       // TBD need error msg if fundamental_name() returns NULL?
       Symbol* fund_name = name->fundamental_name(CHECK_(VerificationType::bogus_type()));
-      return VerificationType::valuetype_type(fund_name);
+      return VerificationType::inlinetype_type(fund_name);
     }
     return VerificationType::reference_type(name);
   }
 
   // Keep a list of temporary symbols created during verification because
@@ -505,11 +505,11 @@
       {
         Symbol* vname = sig_type->as_symbol();
         // Create another symbol to save as signature stream unreferences this symbol.
         Symbol* vname_copy = create_temporary_symbol(vname);
         assert(vname_copy == vname, "symbols don't match");
-        *inference_type = VerificationType::valuetype_type(vname_copy);
+        *inference_type = VerificationType::inlinetype_type(vname_copy);
         return 1;
       }
     case T_LONG:
       *inference_type = VerificationType::long_type();
       *++inference_type = VerificationType::long2_type();
diff a/src/hotspot/share/interpreter/interpreterRuntime.cpp b/src/hotspot/share/interpreter/interpreterRuntime.cpp
--- a/src/hotspot/share/interpreter/interpreterRuntime.cpp
+++ b/src/hotspot/share/interpreter/interpreterRuntime.cpp
@@ -1509,11 +1509,11 @@
     default:  ShouldNotReachHere(); return;
   }
 
   // Both Q-signatures and L-signatures are mapped to atos
   if (cp_entry->flag_state() == atos && ik->field_signature(index)->is_Q_signature()) {
-    sig_type = JVM_SIGNATURE_VALUETYPE;
+    sig_type = JVM_SIGNATURE_INLINETYPE;
   }
 
   bool is_static = (obj == NULL);
   bool is_inlined = cp_entry->is_inlined();
 
diff a/src/hotspot/share/oops/arrayKlass.cpp b/src/hotspot/share/oops/arrayKlass.cpp
--- a/src/hotspot/share/oops/arrayKlass.cpp
+++ b/src/hotspot/share/oops/arrayKlass.cpp
@@ -108,11 +108,11 @@
   char *new_str = NEW_RESOURCE_ARRAY(char, len + 4);
   int idx = 0;
   new_str[idx++] = JVM_SIGNATURE_ARRAY;
   if (element_klass->is_instance_klass()) { // it could be an array or simple type
     if (is_qtype) {
-      new_str[idx++] = JVM_SIGNATURE_VALUETYPE;
+      new_str[idx++] = JVM_SIGNATURE_INLINETYPE;
     } else {
       new_str[idx++] = JVM_SIGNATURE_CLASS;
     }
   }
   memcpy(&new_str[idx], name_str, len * sizeof(char));
diff a/src/hotspot/share/oops/instanceKlass.cpp b/src/hotspot/share/oops/instanceKlass.cpp
--- a/src/hotspot/share/oops/instanceKlass.cpp
+++ b/src/hotspot/share/oops/instanceKlass.cpp
@@ -2891,11 +2891,11 @@
 
   char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
 
   // Add L or Q as type indicator
   int dest_index = 0;
-  dest[dest_index++] = is_value() ? JVM_SIGNATURE_VALUETYPE : JVM_SIGNATURE_CLASS;
+  dest[dest_index++] = is_value() ? JVM_SIGNATURE_INLINETYPE : JVM_SIGNATURE_CLASS;
 
   // Add the actual class name
   for (int src_index = 0; src_index < src_length; ) {
     dest[dest_index++] = src[src_index++];
   }
diff a/src/hotspot/share/oops/symbol.cpp b/src/hotspot/share/oops/symbol.cpp
--- a/src/hotspot/share/oops/symbol.cpp
+++ b/src/hotspot/share/oops/symbol.cpp
@@ -105,21 +105,21 @@
 }
 #endif
 
 bool Symbol::is_Q_signature() const {
   int len = utf8_length();
-  return len > 2 && char_at(0) == JVM_SIGNATURE_VALUETYPE && char_at(len - 1) == JVM_SIGNATURE_ENDCLASS;
+  return len > 2 && char_at(0) == JVM_SIGNATURE_INLINETYPE && char_at(len - 1) == JVM_SIGNATURE_ENDCLASS;
 }
 
 bool Symbol::is_Q_array_signature() const {
   int l = utf8_length();
   if (l < 2 || char_at(0) != JVM_SIGNATURE_ARRAY || char_at(l - 1) != JVM_SIGNATURE_ENDCLASS) {
     return false;
   }
   for (int i = 1; i < (l - 2); i++) {
     char c = char_at(i);
-    if (c == JVM_SIGNATURE_VALUETYPE) {
+    if (c == JVM_SIGNATURE_INLINETYPE) {
       return true;
     }
     if (c != JVM_SIGNATURE_ARRAY) {
       return false;
     }
@@ -130,26 +130,26 @@
 bool Symbol::is_Q_method_signature() const {
   assert(SignatureVerifier::is_valid_method_signature(this), "must be");
   int len = utf8_length();
   if (len > 4 && char_at(0) == JVM_SIGNATURE_FUNC) {
     for (int i=1; i<len-3; i++) { // Must end with ")Qx;", where x is at least one character or more.
-      if (char_at(i) == JVM_SIGNATURE_ENDFUNC && char_at(i+1) == JVM_SIGNATURE_VALUETYPE) {
+      if (char_at(i) == JVM_SIGNATURE_ENDFUNC && char_at(i+1) == JVM_SIGNATURE_INLINETYPE) {
         return true;
       }
     }
   }
   return false;
 }
 
 bool Symbol::is_Q_singledim_array_signature() const {
   int len = utf8_length();
-  return len > 3 && char_at(0) == JVM_SIGNATURE_ARRAY && char_at(1) == JVM_SIGNATURE_VALUETYPE &&
+  return len > 3 && char_at(0) == JVM_SIGNATURE_ARRAY && char_at(1) == JVM_SIGNATURE_INLINETYPE &&
                     char_at(len - 1) == JVM_SIGNATURE_ENDCLASS;
 }
 
 Symbol* Symbol::fundamental_name(TRAPS) {
-  if ((char_at(0) == JVM_SIGNATURE_VALUETYPE || char_at(0) == JVM_SIGNATURE_CLASS) && ends_with(JVM_SIGNATURE_ENDCLASS)) {
+  if ((char_at(0) == JVM_SIGNATURE_INLINETYPE || char_at(0) == JVM_SIGNATURE_CLASS) && ends_with(JVM_SIGNATURE_ENDCLASS)) {
     return SymbolTable::new_symbol(this, 1, utf8_length() - 1);
   } else {
     // reference count is incremented to be consistent with the behavior with
     // the SymbolTable::new_symbol() call above
     this->increment_refcount();
@@ -160,19 +160,19 @@
 bool Symbol::is_same_fundamental_type(Symbol* s) const {
   if (this == s) return true;
   if (utf8_length() < 3) return false;
   int offset1, offset2, len;
   if (ends_with(JVM_SIGNATURE_ENDCLASS)) {
-    if (char_at(0) != JVM_SIGNATURE_VALUETYPE && char_at(0) != JVM_SIGNATURE_CLASS) return false;
+    if (char_at(0) != JVM_SIGNATURE_INLINETYPE && char_at(0) != JVM_SIGNATURE_CLASS) return false;
     offset1 = 1;
     len = utf8_length() - 2;
   } else {
     offset1 = 0;
     len = utf8_length();
   }
   if (ends_with(JVM_SIGNATURE_ENDCLASS)) {
-    if (s->char_at(0) != JVM_SIGNATURE_VALUETYPE && s->char_at(0) != JVM_SIGNATURE_CLASS) return false;
+    if (s->char_at(0) != JVM_SIGNATURE_INLINETYPE && s->char_at(0) != JVM_SIGNATURE_CLASS) return false;
     offset2 = 1;
   } else {
     offset2 = 0;
   }
   if ((offset2 + len) > s->utf8_length()) return false;
diff a/src/hotspot/share/opto/callnode.cpp b/src/hotspot/share/opto/callnode.cpp
--- a/src/hotspot/share/opto/callnode.cpp
+++ b/src/hotspot/share/opto/callnode.cpp
@@ -730,11 +730,11 @@
         assert(con == TypeFunc::Parms+1, "only one return value");
         assert(range_cc->field_at(TypeFunc::Parms+1) == Type::HALF, "");
         return new MachProjNode(this,con, RegMask::Empty, (uint)OptoReg::Bad);
       }
     } else {
-      // The Call may return multiple values (value type fields): we
+      // The Call may return multiple values (inline type fields): we
       // create one projection per returned values.
       assert(con <= TypeFunc::Parms+1 || InlineTypeReturnedAsFields, "only for multi value return");
       uint ideal_reg = range_cc->field_at(con)->ideal_reg();
       return new MachProjNode(this, con, mask[con-TypeFunc::Parms], ideal_reg);
     }
diff a/src/hotspot/share/prims/jvmtiImpl.cpp b/src/hotspot/share/prims/jvmtiImpl.cpp
--- a/src/hotspot/share/prims/jvmtiImpl.cpp
+++ b/src/hotspot/share/prims/jvmtiImpl.cpp
@@ -511,11 +511,11 @@
   assert(thread != NULL, "thread must not be NULL");
   assert(klass != NULL, "klass must not be NULL");
 
   int len = (int) strlen(ty_sign);
   if ((ty_sign[0] == JVM_SIGNATURE_CLASS ||
-       ty_sign[0] == JVM_SIGNATURE_VALUETYPE) &&
+       ty_sign[0] == JVM_SIGNATURE_INLINETYPE) &&
       ty_sign[len-1] == JVM_SIGNATURE_ENDCLASS) { // Need pure class/interface name
     ty_sign++;
     len -= 2;
   }
   TempNewSymbol ty_sym = SymbolTable::new_symbol(ty_sign, len);
diff a/src/hotspot/share/runtime/arguments.cpp b/src/hotspot/share/runtime/arguments.cpp
--- a/src/hotspot/share/runtime/arguments.cpp
+++ b/src/hotspot/share/runtime/arguments.cpp
@@ -4200,11 +4200,11 @@
   if (BytecodeVerificationLocal && !BytecodeVerificationRemote) {
     log_info(verification)("Turning on remote verification because local verification is on");
     FLAG_SET_DEFAULT(BytecodeVerificationRemote, true);
   }
   if (!EnableValhalla || (is_interpreter_only() && !is_dumping_archive())) {
-    // Disable calling convention optimizations if value types are not supported
+    // Disable calling convention optimizations if inline types are not supported
     InlineTypePassFieldsAsArgs = false;
     InlineTypeReturnedAsFields = false;
   }
 
 #ifndef PRODUCT
diff a/src/hotspot/share/runtime/signature.cpp b/src/hotspot/share/runtime/signature.cpp
--- a/src/hotspot/share/runtime/signature.cpp
+++ b/src/hotspot/share/runtime/signature.cpp
@@ -296,11 +296,11 @@
   case JVM_SIGNATURE_SHORT:
   case JVM_SIGNATURE_BOOLEAN:
     // If it is an array, the type is the last character
     return (i + 1 == len);
   case JVM_SIGNATURE_CLASS:
-  case JVM_SIGNATURE_VALUETYPE:
+  case JVM_SIGNATURE_INLINETYPE:
     // If it is an object, the last character must be a ';'
     return sig->char_at(len - 1) == JVM_SIGNATURE_ENDCLASS;
   }
   return false;
 }
@@ -546,11 +546,11 @@
     case JVM_SIGNATURE_LONG:
     case JVM_SIGNATURE_SHORT:
     case JVM_SIGNATURE_BOOLEAN:
     case JVM_SIGNATURE_VOID:
       return index + 1;
-    case JVM_SIGNATURE_VALUETYPE: // fall through
+    case JVM_SIGNATURE_INLINETYPE: // fall through
     case JVM_SIGNATURE_CLASS:
       for (index = index + 1; index < limit; ++index) {
         char c = type[index];
         switch (c) {
           case JVM_SIGNATURE_ENDCLASS:
diff a/src/hotspot/share/runtime/signature.hpp b/src/hotspot/share/runtime/signature.hpp
--- a/src/hotspot/share/runtime/signature.hpp
+++ b/src/hotspot/share/runtime/signature.hpp
@@ -122,11 +122,11 @@
   }
 
   // Determine if this signature char introduces an
   // envelope, which is a class name plus ';'.
   static bool has_envelope(char signature_char) {
-    return (signature_char == JVM_SIGNATURE_CLASS) || (signature_char == JVM_SIGNATURE_VALUETYPE);
+    return (signature_char == JVM_SIGNATURE_CLASS) || (signature_char == JVM_SIGNATURE_INLINETYPE);
   }
 
   // Assuming has_envelope is true, return the symbol
   // inside the envelope, by stripping 'L' and ';'.
   // Caller is responsible for decrementing the newly created
diff a/src/hotspot/share/utilities/globalDefinitions.cpp b/src/hotspot/share/utilities/globalDefinitions.cpp
--- a/src/hotspot/share/utilities/globalDefinitions.cpp
+++ b/src/hotspot/share/utilities/globalDefinitions.cpp
@@ -204,11 +204,11 @@
   JVM_SIGNATURE_BOOLEAN, JVM_SIGNATURE_CHAR,
   JVM_SIGNATURE_FLOAT,   JVM_SIGNATURE_DOUBLE,
   JVM_SIGNATURE_BYTE,    JVM_SIGNATURE_SHORT,
   JVM_SIGNATURE_INT,     JVM_SIGNATURE_LONG,
   JVM_SIGNATURE_CLASS,   JVM_SIGNATURE_ARRAY,
-  JVM_SIGNATURE_VALUETYPE, JVM_SIGNATURE_VOID,
+  JVM_SIGNATURE_INLINETYPE, JVM_SIGNATURE_VOID,
   0, 0, 0, 0, 0
 };
 
 // Map BasicType to Java type name
 const char* type2name_tab[T_CONFLICT+1] = {
diff a/src/hotspot/share/utilities/globalDefinitions.hpp b/src/hotspot/share/utilities/globalDefinitions.hpp
--- a/src/hotspot/share/utilities/globalDefinitions.hpp
+++ b/src/hotspot/share/utilities/globalDefinitions.hpp
@@ -644,11 +644,11 @@
     F(JVM_SIGNATURE_SHORT,   T_SHORT,   N)      \
     F(JVM_SIGNATURE_INT,     T_INT,     N)      \
     F(JVM_SIGNATURE_LONG,    T_LONG,    N)      \
     F(JVM_SIGNATURE_CLASS,   T_OBJECT,  N)      \
     F(JVM_SIGNATURE_ARRAY,   T_ARRAY,   N)      \
-    F(JVM_SIGNATURE_VALUETYPE,  T_VALUETYPE, N) \
+    F(JVM_SIGNATURE_INLINETYPE, T_VALUETYPE, N) \
     F(JVM_SIGNATURE_VOID,    T_VOID,    N)      \
     /*end*/
 
 inline bool is_java_type(BasicType t) {
   return T_BOOLEAN <= t && t <= T_VOID;
diff a/src/java.base/share/native/include/classfile_constants.h.template b/src/java.base/share/native/include/classfile_constants.h.template
--- a/src/java.base/share/native/include/classfile_constants.h.template
+++ b/src/java.base/share/native/include/classfile_constants.h.template
@@ -151,11 +151,11 @@
     JVM_SIGNATURE_ENDSPECIAL    = '>',
     JVM_SIGNATURE_ARRAY         = '[',
     JVM_SIGNATURE_BYTE          = 'B',
     JVM_SIGNATURE_CHAR          = 'C',
     JVM_SIGNATURE_CLASS         = 'L',
-    JVM_SIGNATURE_VALUETYPE     = 'Q',
+    JVM_SIGNATURE_INLINETYPE    = 'Q',
     JVM_SIGNATURE_ENDCLASS      = ';',
     JVM_SIGNATURE_ENUM          = 'E',
     JVM_SIGNATURE_FLOAT         = 'F',
     JVM_SIGNATURE_DOUBLE        = 'D',
     JVM_SIGNATURE_FUNC          = '(',
diff a/src/java.base/share/native/libjava/check_classname.c b/src/java.base/share/native/libjava/check_classname.c
--- a/src/java.base/share/native/libjava/check_classname.c
+++ b/src/java.base/share/native/libjava/check_classname.c
@@ -193,11 +193,11 @@
             case JVM_SIGNATURE_LONG:
             case JVM_SIGNATURE_DOUBLE:
                 return name + 1;
 
             case JVM_SIGNATURE_CLASS:
-            case JVM_SIGNATURE_VALUETYPE: {
+            case JVM_SIGNATURE_INLINETYPE: {
                 /* Skip over the classname, if one is there. */
                 char *p =
                     skip_over_fieldname(name + 1, JNI_TRUE, --length);
                 /* The next character better be a semicolon. */
                 if (p && p - name - 1 > 0 && p[0] == ';')
diff a/src/java.base/share/native/libverify/check_code.c b/src/java.base/share/native/libverify/check_code.c
--- a/src/java.base/share/native/libverify/check_code.c
+++ b/src/java.base/share/native/libverify/check_code.c
@@ -3721,17 +3721,17 @@
           case JVM_SIGNATURE_DOUBLE:
           case JVM_SIGNATURE_LONG:
           case JVM_SIGNATURE_FUNC:  /* ignore initial (, if given */
             break;
           case JVM_SIGNATURE_CLASS:
-          case JVM_SIGNATURE_VALUETYPE:
+          case JVM_SIGNATURE_INLINETYPE:
             while (*p != JVM_SIGNATURE_ENDCLASS) p++;
             break;
           case JVM_SIGNATURE_ARRAY:
             while (*p == JVM_SIGNATURE_ARRAY) p++;
             /* If an array of classes, skip over class name, too. */
-            if (*p == JVM_SIGNATURE_CLASS || *p == JVM_SIGNATURE_VALUETYPE) {
+            if (*p == JVM_SIGNATURE_CLASS || *p == JVM_SIGNATURE_INLINETYPE) {
                 while (*p != JVM_SIGNATURE_ENDCLASS) p++;
             }
             break;
           default:
             /* Indicate an error. */
@@ -3807,11 +3807,11 @@
             case JVM_SIGNATURE_ARRAY:
                 array_depth++;
                 continue;       /* only time we ever do the loop > 1 */
 
             case JVM_SIGNATURE_CLASS:
-            case JVM_SIGNATURE_VALUETYPE: {
+            case JVM_SIGNATURE_INLINETYPE: {
                 char buffer_space[256];
                 char *buffer = buffer_space;
                 char *finish = strchr(p, JVM_SIGNATURE_ENDCLASS);
                 int length;
                 if (finish == NULL) {
@@ -4190,19 +4190,19 @@
           case JVM_SIGNATURE_INT:
           case JVM_SIGNATURE_FLOAT:
             args_size += 1;
             break;
           case JVM_SIGNATURE_CLASS:
-          case JVM_SIGNATURE_VALUETYPE:
+          case JVM_SIGNATURE_INLINETYPE:
             args_size += 1;
             while (*p != JVM_SIGNATURE_ENDCLASS) p++;
             break;
           case JVM_SIGNATURE_ARRAY:
             args_size += 1;
             while ((*p == JVM_SIGNATURE_ARRAY)) p++;
             /* If an array of classes, skip over class name, too. */
-            if (*p == JVM_SIGNATURE_CLASS || *p == JVM_SIGNATURE_VALUETYPE) {
+            if (*p == JVM_SIGNATURE_CLASS || *p == JVM_SIGNATURE_INLINETYPE) {
                 while (*p != JVM_SIGNATURE_ENDCLASS)
                   p++;
             }
             break;
           case JVM_SIGNATURE_DOUBLE:
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestArrays.java
@@ -81,13 +81,13 @@
 
     protected long hash(int x, long y) {
         return MyValue1.createWithFieldsInline(x, y).hash();
     }
 
-    // Test value type array creation and initialization
-    @Test(valid = ValueTypeArrayFlattenOn, match = { ALLOCA }, matchCount = { 1 })
-    @Test(valid = ValueTypeArrayFlattenOff, match = { ALLOCA }, matchCount = { 1 }, failOn = LOAD)
+    // Test inline type array creation and initialization
+    @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOCA }, matchCount = { 1 })
+    @Test(valid = InlineTypeArrayFlattenOff, match = { ALLOCA }, matchCount = { 1 }, failOn = LOAD)
     public MyValue1[] test1(int len) {
         MyValue1[] va = new MyValue1[len];
         for (int i = 0; i < len; ++i) {
             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
         }
@@ -101,14 +101,14 @@
         for (int i = 0; i < len; ++i) {
             Asserts.assertEQ(va[i].hash(), hash());
         }
     }
 
-    // Test creation of a value type array and element access
+    // Test creation of an inline type array and element access
     // TODO 8227588
-    @Test(valid = ValueTypeArrayFlattenOn, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
-    @Test(valid = ValueTypeArrayFlattenOff)
+    @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
+    @Test(valid = InlineTypeArrayFlattenOff)
     public long test2() {
         MyValue1[] va = new MyValue1[1];
         va[0] = MyValue1.createWithFieldsInline(rI, rL);
         return va[0].hash();
     }
@@ -683,12 +683,12 @@
         Asserts.assertEQ(result.hash(), v.hash());
     }
 
     // non escaping allocations
     // TODO 8227588: shouldn't this have the same IR matching rules as test6?
-    @Test(valid = ValueTypeArrayFlattenOn, failOn = ALLOCA + LOOP + LOAD + TRAP)
-    @Test(valid = ValueTypeArrayFlattenOff)
+    @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOCA + LOOP + LOAD + TRAP)
+    @Test(valid = InlineTypeArrayFlattenOff)
     public MyValue2 test29(MyValue2[] src) {
         MyValue2[] dst = new MyValue2[10];
         System.arraycopy(src, 0, dst, 0, 10);
         return dst[0];
     }
@@ -724,12 +724,12 @@
         Asserts.assertEQ(src[0].hash(), v.hash());
     }
 
     // non escaping allocation with memory phi
     // TODO 8227588
-    @Test(valid = ValueTypeArrayFlattenOn, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
-    @Test(valid = ValueTypeArrayFlattenOff)
+    @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
+    @Test(valid = InlineTypeArrayFlattenOff)
     public long test31(boolean b, boolean deopt) {
         MyValue2[] src = new MyValue2[1];
         if (b) {
             src[0] = MyValue2.createWithFieldsInline(rI, true);
         } else {
@@ -875,11 +875,11 @@
 
     static boolean compile_and_run_again_if_deoptimized(boolean warmup, String test) {
         if (!warmup) {
             Method m = tests.get(test);
             if (USE_COMPILER && !WHITE_BOX.isMethodCompiled(m, false)) {
-                if (!ValueTypeArrayFlatten && !XCOMP && !STRESS_CC) {
+                if (!InlineTypeArrayFlatten && !XCOMP && !STRESS_CC) {
                     throw new RuntimeException("Unexpected deoptimization");
                 }
                 enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
                 return true;
             }
@@ -1840,12 +1840,12 @@
         MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);
         Asserts.assertEQ(test78(v, 1), v.hash());
     }
 
     // Verify that casting an array element to a non-flattenable type marks the array as not-flat
-    @Test(valid = ValueTypeArrayFlattenOn, match = { ALLOC_G, LOAD_UNKNOWN_VALUE }, matchCount = { 1, 1 })
-    @Test(valid = ValueTypeArrayFlattenOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE)
+    @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOC_G, LOAD_UNKNOWN_VALUE }, matchCount = { 1, 1 })
+    @Test(valid = InlineTypeArrayFlattenOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE)
     public Object test79(Object[] array, int i) {
         Integer i1 = (Integer)array[0];
         Object o = array[1];
         return array[i];
     }
@@ -1867,12 +1867,12 @@
         private final Object o5 = null;
         private final Object o6 = null;
     }
 
     // Same as test79 but with not-flattenable inline type
-    @Test(valid = ValueTypeArrayFlattenOn, match = { ALLOC_G, LOAD_UNKNOWN_VALUE }, matchCount = { 1, 1 })
-    @Test(valid = ValueTypeArrayFlattenOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE)
+    @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOC_G, LOAD_UNKNOWN_VALUE }, matchCount = { 1, 1 })
+    @Test(valid = InlineTypeArrayFlattenOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE)
     public Object test80(Object[] array, int i) {
         NotFlattenable vt = (NotFlattenable)array[0];
         Object o = array[1];
         return array[i];
     }
@@ -1941,12 +1941,12 @@
         Asserts.assertEquals(array2[2], vt);
         Asserts.assertEquals(result, vt);
     }
 
     // Verify that casting an array element to a non-inline type type marks the array as not-null-free and not-flat
-    @Test(valid = ValueTypeArrayFlattenOn, match = { ALLOC_G, LOAD_UNKNOWN_VALUE }, matchCount = { 1, 1 }, failOn = ALLOCA_G + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)
-    @Test(valid = ValueTypeArrayFlattenOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)
+    @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOC_G, LOAD_UNKNOWN_VALUE }, matchCount = { 1, 1 }, failOn = ALLOCA_G + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)
+    @Test(valid = InlineTypeArrayFlattenOff, failOn = ALLOC_G + ALLOCA_G + LOAD_UNKNOWN_VALUE + STORE_UNKNOWN_VALUE + VALUE_ARRAY_NULL_GUARD)
     public void test83(Object[] array, Object o) {
         Integer i = (Integer)array[0];
         array[1] = o;
     }
 
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableArrays.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableArrays.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableArrays.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableArrays.java
@@ -27,11 +27,11 @@
 import java.lang.reflect.Method;
 import java.util.Arrays;
 
 /*
  * @test
- * @summary Test nullable value type arrays
+ * @summary Test nullable inline type arrays
  * @library /testlibrary /test/lib /compiler/whitebox /
  * @requires (os.simpleArch == "x64" | os.simpleArch == "aarch64")
  * @compile TestNullableArrays.java
  * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform
  * @run main/othervm/timeout=300 -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
@@ -75,13 +75,13 @@
         return MyValue1.createWithFieldsInline(x, y).hash();
     }
 
     private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);
 
-    // Test nullable value type array creation and initialization
-    @Test(valid = ValueTypeArrayFlattenOn, match = { ALLOCA }, matchCount = { 1 })
-    @Test(valid = ValueTypeArrayFlattenOff, match = { ALLOCA }, matchCount = { 1 }, failOn = LOAD)
+    // Test nullable inline type array creation and initialization
+    @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOCA }, matchCount = { 1 })
+    @Test(valid = InlineTypeArrayFlattenOff, match = { ALLOCA }, matchCount = { 1 }, failOn = LOAD)
     public MyValue1.ref[] test1(int len) {
         MyValue1.ref[] va = new MyValue1.ref[len];
         if (len > 0) {
             va[0] = null;
         }
@@ -101,11 +101,11 @@
         for (int i = 1; i < len; ++i) {
             Asserts.assertEQ(va[i].hash(), hash());
         }
     }
 
-    // Test creation of a value type array and element access
+    // Test creation of a inline type array and element access
     @Test
     // TODO 8227588
     // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
     public long test2() {
         MyValue1.ref[] va = new MyValue1.ref[1];
@@ -117,11 +117,11 @@
     public void test2_verifier(boolean warmup) {
         long result = test2();
         Asserts.assertEQ(result, hash());
     }
 
-    // Test receiving a value type array from the interpreter,
+    // Test receiving a inline type array from the interpreter,
     // updating its elements in a loop and computing a hash.
     @Test(failOn = ALLOCA)
     public long test3(MyValue1.ref[] va) {
         long result = 0;
         for (int i = 0; i < 10; ++i) {
@@ -150,11 +150,11 @@
                 Asserts.assertEQ(va[i].hash(), hash(rI + 1, rL + 1));
             }
         }
     }
 
-    // Test returning a value type array received from the interpreter
+    // Test returning an inline type array received from the interpreter
     @Test(failOn = ALLOC + ALLOCA + LOAD + STORE + LOOP + TRAP)
     public MyValue1.ref[] test4(MyValue1.ref[] va) {
         return va;
     }
 
@@ -168,11 +168,11 @@
         for (int i = 0; i < 10; ++i) {
             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
         }
     }
 
-    // Merge value type arrays created from two branches
+    // Merge inline type arrays created from two branches
     @Test
     public MyValue1.ref[] test5(boolean b) {
         MyValue1.ref[] va;
         if (b) {
             va = new MyValue1.ref[5];
@@ -212,11 +212,11 @@
             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
         }
         Asserts.assertEQ(va[9], null);
     }
 
-    // Test creation of value type array with single element
+    // Test creation of inline type array with single element
     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
     public MyValue1.ref test6() {
         MyValue1.ref[] va = new MyValue1.ref[1];
         return va[0];
     }
@@ -226,11 +226,11 @@
         MyValue1.ref[] va = new MyValue1.ref[1];
         MyValue1.ref v = test6();
         Asserts.assertEQ(v, null);
     }
 
-    // Test default initialization of value type arrays
+    // Test default initialization of inline type arrays
     @Test(failOn = LOAD)
     public MyValue1.ref[] test7(int len) {
         return new MyValue1.ref[len];
     }
 
@@ -242,11 +242,11 @@
             Asserts.assertEQ(va[i], null);
             va[i] = null;
         }
     }
 
-    // Test creation of value type array with zero length
+    // Test creation of inline type array with zero length
     @Test(failOn = ALLOC + LOAD + STORE + LOOP + TRAP)
     public MyValue1.ref[] test8() {
         return new MyValue1.ref[0];
     }
 
@@ -256,11 +256,11 @@
         Asserts.assertEQ(va.length, 0);
     }
 
     static MyValue1.ref[] test9_va;
 
-    // Test that value type array loaded from field has correct type
+    // Test that inline type array loaded from field has correct type
     @Test(failOn = LOOP)
     public long test9() {
         return test9_va[0].hash();
     }
 
@@ -544,11 +544,11 @@
         for (int i = 1; i < test19_orig.length; ++i) {
             Asserts.assertEQ(result[i].hash(), test19_orig[i].hash());
         }
     }
 
-    // arraycopy() of value type array with oop fields
+    // arraycopy() of inline type array with oop fields
     @Test
     public void test20(MyValue1.ref[] src, MyValue1.ref[] dst) {
         System.arraycopy(src, 0, dst, 0, src.length);
     }
 
@@ -588,11 +588,11 @@
             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
         }
     }
 
-    // arraycopy() of value type array with no oop field
+    // arraycopy() of inline type array with no oop field
     @Test
     public void test21(MyValue2.ref[] src, MyValue2.ref[] dst) {
         System.arraycopy(src, 0, dst, 0, src.length);
     }
 
@@ -632,11 +632,11 @@
             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
         }
     }
 
-    // arraycopy() of value type array with oop field and tightly
+    // arraycopy() of inline type array with oop field and tightly
     // coupled allocation as dest
     @Test
     public MyValue1.ref[] test22(MyValue1.ref[] src) {
         MyValue1.ref[] dst = new MyValue1.ref[src.length];
         System.arraycopy(src, 0, dst, 0, src.length);
@@ -662,11 +662,11 @@
             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
         }
     }
 
-    // arraycopy() of value type array with oop fields and tightly
+    // arraycopy() of inline type array with oop fields and tightly
     // coupled allocation as dest
     @Test
     public MyValue1.ref[] test23(MyValue1.ref[] src) {
         MyValue1.ref[] dst = new MyValue1.ref[src.length + 10];
         System.arraycopy(src, 0, dst, 5, src.length);
@@ -692,11 +692,11 @@
             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
         }
     }
 
-    // arraycopy() of value type array passed as Object
+    // arraycopy() of inline type array passed as Object
     @Test
     public void test24(MyValue1.ref[] src, Object dst) {
         System.arraycopy(src, 0, dst, 0, src.length);
     }
 
@@ -892,11 +892,11 @@
         MyValue2.ref v = test29(src);
         Asserts.assertEQ(src[0].hash(), v.hash());
     }
 
     // non escaping allocation with uncommon trap that needs
-    // eliminated value type array element as debug info
+    // eliminated inline type array element as debug info
     @Test
     @Warmup(10000)
     public MyValue2.ref test30(MyValue2.ref[] src, boolean flag) {
         MyValue2.ref[] dst = new MyValue2.ref[10];
         System.arraycopy(src, 0, dst, 0, 10);
@@ -1077,21 +1077,21 @@
 
     static boolean compile_and_run_again_if_deoptimized(boolean warmup, String test) {
         if (!warmup) {
             Method m = tests.get(test);
             if (USE_COMPILER &&  !WHITE_BOX.isMethodCompiled(m, false)) {
-                if (!ValueTypeArrayFlatten && !XCOMP && !STRESS_CC) {
+                if (!InlineTypeArrayFlatten && !XCOMP && !STRESS_CC) {
                     throw new RuntimeException("Unexpected deoptimization");
                 }
                 enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
                 return true;
             }
         }
         return false;
     }
 
-    // arraycopy() of value type array of unknown size
+    // arraycopy() of inline type array of unknown size
     @Test
     public void test35(Object src, Object dst, int len) {
         System.arraycopy(src, 0, dst, 0, len);
     }
 
@@ -1709,11 +1709,11 @@
         test63_helper(42, va, oa);
         Object[] result = test63(va, oa);
         verify(verif, result);
     }
 
-    // Test default initialization of value type arrays: small array
+    // Test default initialization of inline type arrays: small array
     @Test
     public MyValue1.ref[] test64() {
         return new MyValue1.ref[8];
     }
 
@@ -1723,11 +1723,11 @@
         for (int i = 0; i < 8; ++i) {
             Asserts.assertEQ(va[i], null);
         }
     }
 
-    // Test default initialization of value type arrays: large array
+    // Test default initialization of inline type arrays: large array
     @Test
     public MyValue1.ref[] test65() {
         return new MyValue1.ref[32];
     }
 
@@ -2056,11 +2056,11 @@
         for (int i = 1; i < 10; ++i) {
             Asserts.assertEQ(((MyValue1)va[i]).hash(), hash(rI + i, rL + i));
         }
     }
 
-    // Same as test76 but with non value type array cases
+    // Same as test76 but with non inline type array cases
     @Test
     public Object[] test78(MyValue1[] vva, MyValue1.ref[] vba, Object val, Object[] out, int n) {
         Object[] result = null;
         if (n == 0) {
             result = vva;
@@ -2241,12 +2241,12 @@
         va[0] = testValue1;
         long res = test83(va);
         Asserts.assertEquals(res, testValue1.hash());
     }
 
-    @Test(valid = ValueTypeArrayFlattenOn, failOn = ALLOC + LOOP + STORE + TRAP)
-    @Test(valid = ValueTypeArrayFlattenOff)
+    @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOC + LOOP + STORE + TRAP)
+    @Test(valid = InlineTypeArrayFlattenOff)
     public static MyValue1.ref[] test84(MyValue1 vt1, MyValue1.ref vt2) {
         MyValue1.ref[] result = new MyValue1[2];
         result[0] = vt1;
         result[1] = vt2;
         return result;
diff a/test/hotspot/jtreg/compiler/valhalla/valuetypes/ValueTypeTest.java b/test/hotspot/jtreg/compiler/valhalla/valuetypes/ValueTypeTest.java
--- a/test/hotspot/jtreg/compiler/valhalla/valuetypes/ValueTypeTest.java
+++ b/test/hotspot/jtreg/compiler/valhalla/valuetypes/ValueTypeTest.java
@@ -163,12 +163,12 @@
         "-XX:+VerifyOops", "-XX:+VerifyStack", "-XX:+VerifyLastFrame", "-XX:+VerifyBeforeGC", "-XX:+VerifyAfterGC",
         "-XX:+VerifyDuringGC", "-XX:+VerifyAdapterSharing"};
 
     protected static final int InlineTypePassFieldsAsArgsOn = 0x1;
     protected static final int InlineTypePassFieldsAsArgsOff = 0x2;
-    protected static final int ValueTypeArrayFlattenOn = 0x4;
-    protected static final int ValueTypeArrayFlattenOff = 0x8;
+    protected static final int InlineTypeArrayFlattenOn = 0x4;
+    protected static final int InlineTypeArrayFlattenOff = 0x8;
     protected static final int InlineTypeReturnedAsFieldsOn = 0x10;
     protected static final int InlineTypeReturnedAsFieldsOff = 0x20;
     protected static final int AlwaysIncrementalInlineOn = 0x40;
     protected static final int AlwaysIncrementalInlineOff = 0x80;
     protected static final int G1GCOn = 0x100;
@@ -178,11 +178,11 @@
     protected static final int ArrayLoadStoreProfileOn = 0x1000;
     protected static final int ArrayLoadStoreProfileOff = 0x2000;
     protected static final int TypeProfileOn = 0x4000;
     protected static final int TypeProfileOff = 0x8000;
     protected static final boolean InlineTypePassFieldsAsArgs = (Boolean)WHITE_BOX.getVMFlag("InlineTypePassFieldsAsArgs");
-    protected static final boolean ValueTypeArrayFlatten = (WHITE_BOX.getIntxVMFlag("InlineArrayElemMaxFlatSize") == -1); // FIXME - fix this if default of InlineArrayElemMaxFlatSize is changed
+    protected static final boolean InlineTypeArrayFlatten = (WHITE_BOX.getIntxVMFlag("InlineArrayElemMaxFlatSize") == -1); // FIXME - fix this if default of InlineArrayElemMaxFlatSize is changed
     protected static final boolean InlineTypeReturnedAsFields = (Boolean)WHITE_BOX.getVMFlag("InlineTypeReturnedAsFields");
     protected static final boolean AlwaysIncrementalInline = (Boolean)WHITE_BOX.getVMFlag("AlwaysIncrementalInline");
     protected static final boolean G1GC = (Boolean)WHITE_BOX.getVMFlag("UseG1GC");
     protected static final boolean ZGC = (Boolean)WHITE_BOX.getVMFlag("UseZGC");
     protected static final boolean VerifyOops = (Boolean)WHITE_BOX.getVMFlag("VerifyOops");
@@ -475,12 +475,12 @@
         private final BooleanSupplier predicate;
 
         private static final TestAnnotation testAnnotations[] = {
             new TestAnnotation(InlineTypePassFieldsAsArgsOn, () -> InlineTypePassFieldsAsArgs),
             new TestAnnotation(InlineTypePassFieldsAsArgsOff, () -> !InlineTypePassFieldsAsArgs),
-            new TestAnnotation(ValueTypeArrayFlattenOn, () -> ValueTypeArrayFlatten),
-            new TestAnnotation(ValueTypeArrayFlattenOff, () -> !ValueTypeArrayFlatten),
+            new TestAnnotation(InlineTypeArrayFlattenOn, () -> InlineTypeArrayFlatten),
+            new TestAnnotation(InlineTypeArrayFlattenOff, () -> !InlineTypeArrayFlatten),
             new TestAnnotation(InlineTypeReturnedAsFieldsOn, () -> InlineTypeReturnedAsFields),
             new TestAnnotation(InlineTypeReturnedAsFieldsOff, () -> !InlineTypeReturnedAsFields),
             new TestAnnotation(AlwaysIncrementalInlineOn, () -> AlwaysIncrementalInline),
             new TestAnnotation(AlwaysIncrementalInlineOff, () -> !AlwaysIncrementalInline),
             new TestAnnotation(G1GCOn, () -> G1GC),

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../ci/ciValueArrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
4506         }
4507       } else {
4508         inline_types_not_inlined++;
4509         fs.set_inlined(false);
4510       }
4511     }
4512   }
4513 
4514   // Adjusting non_static_oop_count to take into account inline types fields not inlined;
4515   nonstatic_oop_count += inline_types_not_inlined;
4516 
4517   // Total non-static fields count, including every contended field
4518   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4519                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
4520                                         fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_INLINE];
4521 
4522   const bool super_has_nonstatic_fields =
4523           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4524   const bool has_nonstatic_fields =
4525     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
<span class="line-modified">4526   const bool has_nonstatic_value_fields = nonstatic_inline_type_count &gt; 0;</span>
4527 
4528   if (is_inline_type() &amp;&amp; (!has_nonstatic_fields)) {
4529     // There are a number of fixes required throughout the type system and JIT
4530     throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support zero instance size yet&quot;);
4531     return;
4532   }
4533 
4534   // Prepare list of oops for oop map generation.
4535   //
4536   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4537   // regions. offset[i] is the start of the i-th region, which then has
4538   // count[i] oops following. Before we know how many regions are required,
4539   // we pessimistically allocate the maps to fit all the oops into the
4540   // distinct regions.
4541   //
4542   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
4543   int max_oop_map_count =
4544       super_oop_map_count +
4545       fac-&gt;count[NONSTATIC_OOP] +
4546       inline_type_oop_map_count +
</pre>
<hr />
<pre>
4904   int instance_size             = align_object_size(instance_end / wordSize);
4905 
4906   assert(instance_size == align_object_size(align_up(
4907          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)
4908          + initial_inline_type_padding, wordSize) / wordSize), &quot;consistent layout helper value&quot;);
4909 
4910 
4911   // Invariant: nonstatic_field end/start should only change if there are
4912   // nonstatic fields in the class, or if the class is contended. We compare
4913   // against the non-aligned value, so that end alignment will not fail the
4914   // assert without actually having the fields.
4915   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4916          is_contended_class ||
4917          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4918 
4919   // Number of non-static oop map blocks allocated at end of klass.
4920   nonstatic_oop_maps-&gt;compact();
4921 
4922 #ifndef PRODUCT
4923   if ((PrintFieldLayout &amp;&amp; !is_inline_type()) ||
<span class="line-modified">4924       (PrintInlineLayout &amp;&amp; (is_inline_type() || has_nonstatic_value_fields))) {</span>
4925     print_field_layout(_class_name,
4926           _fields,
4927           cp,
4928           instance_size,
4929           nonstatic_fields_start,
4930           nonstatic_fields_end,
4931           static_fields_end);
4932     nonstatic_oop_maps-&gt;print_on(tty);
4933     tty-&gt;print(&quot;\n&quot;);
4934     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);
4935     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);
4936     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);
4937     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);
4938     tty-&gt;print_cr(&quot;---&quot;);
4939   }
4940 
4941 #endif
4942   // Pass back information needed for InstanceKlass creation
4943   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4944   info-&gt;_instance_size = instance_size;
</pre>
<hr />
<pre>
5751 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5752 // Return a pointer to just past the signature.
5753 // Return NULL if no legal signature is found.
5754 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5755                                                        bool void_ok,
5756                                                        unsigned int length,
5757                                                        TRAPS) const {
5758   unsigned int array_dim = 0;
5759   while (length &gt; 0) {
5760     switch (signature[0]) {
5761     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5762     case JVM_SIGNATURE_BOOLEAN:
5763     case JVM_SIGNATURE_BYTE:
5764     case JVM_SIGNATURE_CHAR:
5765     case JVM_SIGNATURE_SHORT:
5766     case JVM_SIGNATURE_INT:
5767     case JVM_SIGNATURE_FLOAT:
5768     case JVM_SIGNATURE_LONG:
5769     case JVM_SIGNATURE_DOUBLE:
5770       return signature + 1;
<span class="line-modified">5771     case JVM_SIGNATURE_VALUETYPE:</span>
5772       // Can&#39;t enable this check until JDK upgrades the bytecode generators
5773       // if (_major_version &lt; CONSTANT_CLASS_DESCRIPTORS ) {
5774       //   classfile_parse_error(&quot;Class name contains illegal Q-signature &quot;
5775       //                                    &quot;in descriptor in class file %s&quot;,
5776       //                                    CHECK_0);
5777       // }
5778       // fall through
5779     case JVM_SIGNATURE_CLASS:
5780     {
5781       if (_major_version &lt; JAVA_1_5_VERSION) {
5782         // Skip over the class name if one is there
5783         const char* const p = skip_over_field_name(signature + 1, true, --length);
5784 
5785         // The next character better be a semicolon
5786         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5787           return p + 1;
5788         }
5789       }
5790       else {
5791         // Skip leading &#39;L&#39; or &#39;Q&#39; and ignore first appearance of &#39;;&#39;
</pre>
<hr />
<pre>
7261                                                     _all_mirandas,
7262                                                     _super_klass,
7263                                                     _methods,
7264                                                     _access_flags,
7265                                                     _major_version,
7266                                                     loader,
7267                                                     _class_name,
7268                                                     _local_interfaces,
7269                                                     CHECK);
7270 
7271   // Size of Java itable (in words)
7272   _itable_size = is_interface() ? 0 :
7273     klassItable::compute_itable_size(_transitive_interfaces);
7274 
7275   assert(_fac != NULL, &quot;invariant&quot;);
7276   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
7277 
7278 
7279   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
7280     if (Signature::basic_type(fs.signature()) == T_VALUETYPE  &amp;&amp; !fs.access_flags().is_static()) {
<span class="line-modified">7281       // Pre-load value class</span>
7282       Klass* klass = SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,
7283           Handle(THREAD, _loader_data-&gt;class_loader()),
7284           _protection_domain, true, CHECK);
7285       assert(klass != NULL, &quot;Sanity check&quot;);
7286       assert(klass-&gt;access_flags().is_inline_type(), &quot;Value type expected&quot;);
7287     }
7288   }
7289 
7290   _field_info = new FieldLayoutInfo();
7291   if (UseNewFieldLayout) {
7292     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
7293         _parsed_annotations-&gt;is_contended(), is_inline_type(),
7294         loader_data(), _protection_domain, _field_info);
7295     lb.build_layout(CHECK);
7296     if (is_inline_type()) {
7297       _alignment = lb.get_alignment();
7298       _first_field_offset = lb.get_first_field_offset();
7299       _exact_size_in_bytes = lb.get_exact_size_in_byte();
7300     }
7301   } else {
</pre>
</td>
<td>
<hr />
<pre>
4506         }
4507       } else {
4508         inline_types_not_inlined++;
4509         fs.set_inlined(false);
4510       }
4511     }
4512   }
4513 
4514   // Adjusting non_static_oop_count to take into account inline types fields not inlined;
4515   nonstatic_oop_count += inline_types_not_inlined;
4516 
4517   // Total non-static fields count, including every contended field
4518   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4519                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
4520                                         fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_INLINE];
4521 
4522   const bool super_has_nonstatic_fields =
4523           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4524   const bool has_nonstatic_fields =
4525     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
<span class="line-modified">4526   const bool has_nonstatic_inline_fields = nonstatic_inline_type_count &gt; 0;</span>
4527 
4528   if (is_inline_type() &amp;&amp; (!has_nonstatic_fields)) {
4529     // There are a number of fixes required throughout the type system and JIT
4530     throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support zero instance size yet&quot;);
4531     return;
4532   }
4533 
4534   // Prepare list of oops for oop map generation.
4535   //
4536   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4537   // regions. offset[i] is the start of the i-th region, which then has
4538   // count[i] oops following. Before we know how many regions are required,
4539   // we pessimistically allocate the maps to fit all the oops into the
4540   // distinct regions.
4541   //
4542   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
4543   int max_oop_map_count =
4544       super_oop_map_count +
4545       fac-&gt;count[NONSTATIC_OOP] +
4546       inline_type_oop_map_count +
</pre>
<hr />
<pre>
4904   int instance_size             = align_object_size(instance_end / wordSize);
4905 
4906   assert(instance_size == align_object_size(align_up(
4907          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)
4908          + initial_inline_type_padding, wordSize) / wordSize), &quot;consistent layout helper value&quot;);
4909 
4910 
4911   // Invariant: nonstatic_field end/start should only change if there are
4912   // nonstatic fields in the class, or if the class is contended. We compare
4913   // against the non-aligned value, so that end alignment will not fail the
4914   // assert without actually having the fields.
4915   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4916          is_contended_class ||
4917          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4918 
4919   // Number of non-static oop map blocks allocated at end of klass.
4920   nonstatic_oop_maps-&gt;compact();
4921 
4922 #ifndef PRODUCT
4923   if ((PrintFieldLayout &amp;&amp; !is_inline_type()) ||
<span class="line-modified">4924       (PrintInlineLayout &amp;&amp; (is_inline_type() || has_nonstatic_inline_fields))) {</span>
4925     print_field_layout(_class_name,
4926           _fields,
4927           cp,
4928           instance_size,
4929           nonstatic_fields_start,
4930           nonstatic_fields_end,
4931           static_fields_end);
4932     nonstatic_oop_maps-&gt;print_on(tty);
4933     tty-&gt;print(&quot;\n&quot;);
4934     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);
4935     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);
4936     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);
4937     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);
4938     tty-&gt;print_cr(&quot;---&quot;);
4939   }
4940 
4941 #endif
4942   // Pass back information needed for InstanceKlass creation
4943   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4944   info-&gt;_instance_size = instance_size;
</pre>
<hr />
<pre>
5751 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5752 // Return a pointer to just past the signature.
5753 // Return NULL if no legal signature is found.
5754 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5755                                                        bool void_ok,
5756                                                        unsigned int length,
5757                                                        TRAPS) const {
5758   unsigned int array_dim = 0;
5759   while (length &gt; 0) {
5760     switch (signature[0]) {
5761     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5762     case JVM_SIGNATURE_BOOLEAN:
5763     case JVM_SIGNATURE_BYTE:
5764     case JVM_SIGNATURE_CHAR:
5765     case JVM_SIGNATURE_SHORT:
5766     case JVM_SIGNATURE_INT:
5767     case JVM_SIGNATURE_FLOAT:
5768     case JVM_SIGNATURE_LONG:
5769     case JVM_SIGNATURE_DOUBLE:
5770       return signature + 1;
<span class="line-modified">5771     case JVM_SIGNATURE_INLINETYPE:</span>
5772       // Can&#39;t enable this check until JDK upgrades the bytecode generators
5773       // if (_major_version &lt; CONSTANT_CLASS_DESCRIPTORS ) {
5774       //   classfile_parse_error(&quot;Class name contains illegal Q-signature &quot;
5775       //                                    &quot;in descriptor in class file %s&quot;,
5776       //                                    CHECK_0);
5777       // }
5778       // fall through
5779     case JVM_SIGNATURE_CLASS:
5780     {
5781       if (_major_version &lt; JAVA_1_5_VERSION) {
5782         // Skip over the class name if one is there
5783         const char* const p = skip_over_field_name(signature + 1, true, --length);
5784 
5785         // The next character better be a semicolon
5786         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5787           return p + 1;
5788         }
5789       }
5790       else {
5791         // Skip leading &#39;L&#39; or &#39;Q&#39; and ignore first appearance of &#39;;&#39;
</pre>
<hr />
<pre>
7261                                                     _all_mirandas,
7262                                                     _super_klass,
7263                                                     _methods,
7264                                                     _access_flags,
7265                                                     _major_version,
7266                                                     loader,
7267                                                     _class_name,
7268                                                     _local_interfaces,
7269                                                     CHECK);
7270 
7271   // Size of Java itable (in words)
7272   _itable_size = is_interface() ? 0 :
7273     klassItable::compute_itable_size(_transitive_interfaces);
7274 
7275   assert(_fac != NULL, &quot;invariant&quot;);
7276   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
7277 
7278 
7279   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
7280     if (Signature::basic_type(fs.signature()) == T_VALUETYPE  &amp;&amp; !fs.access_flags().is_static()) {
<span class="line-modified">7281       // Pre-load inline class</span>
7282       Klass* klass = SystemDictionary::resolve_inline_type_field_or_fail(&amp;fs,
7283           Handle(THREAD, _loader_data-&gt;class_loader()),
7284           _protection_domain, true, CHECK);
7285       assert(klass != NULL, &quot;Sanity check&quot;);
7286       assert(klass-&gt;access_flags().is_inline_type(), &quot;Value type expected&quot;);
7287     }
7288   }
7289 
7290   _field_info = new FieldLayoutInfo();
7291   if (UseNewFieldLayout) {
7292     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
7293         _parsed_annotations-&gt;is_contended(), is_inline_type(),
7294         loader_data(), _protection_domain, _field_info);
7295     lb.build_layout(CHECK);
7296     if (is_inline_type()) {
7297       _alignment = lb.get_alignment();
7298       _first_field_offset = lb.get_first_field_offset();
7299       _exact_size_in_bytes = lb.get_exact_size_in_byte();
7300     }
7301   } else {
</pre>
</td>
</tr>
</table>
<center><a href="../ci/ciValueArrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/verifier.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="verificationType.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="verifier.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/verifier.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/constantPool.inline.hpp&quot;
  45 #include &quot;oops/instanceKlass.hpp&quot;
  46 #include &quot;oops/oop.inline.hpp&quot;
  47 #include &quot;oops/typeArrayOop.hpp&quot;
  48 #include &quot;runtime/fieldDescriptor.hpp&quot;
  49 #include &quot;runtime/handles.inline.hpp&quot;
  50 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  51 #include &quot;runtime/javaCalls.hpp&quot;
  52 #include &quot;runtime/jniHandles.inline.hpp&quot;
  53 #include &quot;runtime/os.hpp&quot;
  54 #include &quot;runtime/safepointVerifiers.hpp&quot;
  55 #include &quot;runtime/thread.hpp&quot;
  56 #include &quot;services/threadService.hpp&quot;
  57 #include &quot;utilities/align.hpp&quot;
  58 #include &quot;utilities/bytes.hpp&quot;
  59 
  60 #define NOFAILOVER_MAJOR_VERSION                       51
  61 #define NONZERO_PADDING_BYTES_IN_SWITCH_MAJOR_VERSION  51
  62 #define STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION       52
<span class="line-modified">  63 #define VALUETYPE_MAJOR_VERSION                        56</span>
  64 #define MAX_ARRAY_DIMENSIONS 255
  65 
  66 // Access to external entry for VerifyClassForMajorVersion - old byte code verifier
  67 
  68 extern &quot;C&quot; {
  69   typedef jboolean (*verify_byte_codes_fn_t)(JNIEnv *, jclass, char *, jint, jint);
  70 }
  71 
  72 static verify_byte_codes_fn_t volatile _verify_byte_codes_fn = NULL;
  73 
  74 static verify_byte_codes_fn_t verify_byte_codes_fn() {
  75 
  76   if (_verify_byte_codes_fn != NULL)
  77     return _verify_byte_codes_fn;
  78 
  79   MutexLocker locker(Verify_lock);
  80 
  81   if (_verify_byte_codes_fn != NULL)
  82     return _verify_byte_codes_fn;
  83 
</pre>
<hr />
<pre>
 470       ss-&gt;print(&quot;Local index %d is invalid&quot;, _type.index());
 471       break;
 472     case LOCALS_SIZE_MISMATCH:
 473       ss-&gt;print(&quot;Current frame&#39;s local size doesn&#39;t match stackmap.&quot;);
 474       break;
 475     case STACK_SIZE_MISMATCH:
 476       ss-&gt;print(&quot;Current frame&#39;s stack size doesn&#39;t match stackmap.&quot;);
 477       break;
 478     case STACK_OVERFLOW:
 479       ss-&gt;print(&quot;Exceeded max stack size.&quot;);
 480       break;
 481     case STACK_UNDERFLOW:
 482       ss-&gt;print(&quot;Attempt to pop empty stack.&quot;);
 483       break;
 484     case MISSING_STACKMAP:
 485       ss-&gt;print(&quot;Expected stackmap frame at this location.&quot;);
 486       break;
 487     case BAD_STACKMAP:
 488       ss-&gt;print(&quot;Invalid stackmap specification.&quot;);
 489       break;
<span class="line-modified"> 490     case WRONG_VALUE_TYPE:</span>
 491       ss-&gt;print(&quot;Type &quot;);
 492       _type.details(ss);
 493       ss-&gt;print(&quot; and type &quot;);
 494       _expected.details(ss);
 495       ss-&gt;print(&quot; must be identical inline types.&quot;);
 496       break;
 497     case UNKNOWN:
 498     default:
 499       ShouldNotReachHere();
 500       ss-&gt;print_cr(&quot;Unknown&quot;);
 501   }
 502   ss-&gt;cr();
 503 }
 504 
 505 void ErrorContext::location_details(outputStream* ss, const Method* method) const {
 506   if (_bci != -1 &amp;&amp; method != NULL) {
 507     streamIndentor si(ss);
 508     const char* bytecode_name = &quot;&lt;invalid&gt;&quot;;
 509     if (method-&gt;validate_bci(_bci) != -1) {
 510       Bytecodes::Code code = Bytecodes::code_or_bp_at(method-&gt;bcp_from(_bci));
</pre>
<hr />
<pre>
 571     stack_map_frame* sm_frame = sm_table-&gt;entries();
 572     streamIndentor si2(ss);
 573     int current_offset = -1;
 574     address end_of_sm_table = (address)sm_table + method-&gt;stackmap_data()-&gt;length();
 575     for (u2 i = 0; i &lt; sm_table-&gt;number_of_entries(); ++i) {
 576       ss-&gt;indent();
 577       if (!sm_frame-&gt;verify((address)sm_frame, end_of_sm_table)) {
 578         sm_frame-&gt;print_truncated(ss, current_offset);
 579         return;
 580       }
 581       sm_frame-&gt;print_on(ss, current_offset);
 582       ss-&gt;cr();
 583       current_offset += sm_frame-&gt;offset_delta();
 584       sm_frame = sm_frame-&gt;next();
 585     }
 586   }
 587 }
 588 
 589 // Methods in ClassVerifier
 590 
<span class="line-modified"> 591 VerificationType reference_or_valuetype(InstanceKlass* klass) {</span>
 592   if (klass-&gt;is_value()) {
<span class="line-modified"> 593     return VerificationType::valuetype_type(klass-&gt;name());</span>
 594   } else {
 595     return VerificationType::reference_type(klass-&gt;name());
 596   }
 597 }
 598 
 599 ClassVerifier::ClassVerifier(
 600     InstanceKlass* klass, TRAPS)
 601     : _thread(THREAD), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),
 602       _message(NULL), _method_signatures_table(NULL), _klass(klass) {
<span class="line-modified"> 603   _this_type = reference_or_valuetype(klass);</span>
 604 }
 605 
 606 ClassVerifier::~ClassVerifier() {
 607   // Decrement the reference count for any symbols created.
 608   if (_symbols != NULL) {
 609     for (int i = 0; i &lt; _symbols-&gt;length(); i++) {
 610       Symbol* s = _symbols-&gt;at(i);
 611       s-&gt;decrement_refcount();
 612     }
 613   }
 614 }
 615 
 616 VerificationType ClassVerifier::object_type() const {
 617   return VerificationType::reference_type(vmSymbols::java_lang_Object());
 618 }
 619 
 620 TypeOrigin ClassVerifier::ref_ctx(const char* sig) {
 621   VerificationType vt = VerificationType::reference_type(
 622                          create_temporary_symbol(sig, (int)strlen(sig)));
 623   return TypeOrigin::implicit(vt);
</pre>
<hr />
<pre>
1691               current_frame.flag_this_uninit()) {
1692             verify_error(ErrorContext::bad_code(bci),
1693                          &quot;Constructor must call super() or this() &quot;
1694                          &quot;before return&quot;);
1695             return;
1696           }
1697           no_control_flow = true; break;
1698         case Bytecodes::_getstatic :
1699         case Bytecodes::_putstatic :
1700           // pass TRUE, operand can be an array type for getstatic/putstatic.
1701           verify_field_instructions(
1702             &amp;bcs, &amp;current_frame, cp, true, CHECK_VERIFY(this));
1703           no_control_flow = false; break;
1704         case Bytecodes::_getfield :
1705         case Bytecodes::_putfield :
1706           // pass FALSE, operand can&#39;t be an array type for getfield/putfield.
1707           verify_field_instructions(
1708             &amp;bcs, &amp;current_frame, cp, false, CHECK_VERIFY(this));
1709           no_control_flow = false; break;
1710         case Bytecodes::_withfield :
<span class="line-modified">1711           if (_klass-&gt;major_version() &lt; VALUETYPE_MAJOR_VERSION) {</span>
1712             class_format_error(
1713               &quot;withfield not supported by this class file version (%d.%d), class %s&quot;,
1714               _klass-&gt;major_version(), _klass-&gt;minor_version(), _klass-&gt;external_name());
1715             return;
1716           }
1717           // pass FALSE, operand can&#39;t be an array type for withfield.
1718           verify_field_instructions(
1719             &amp;bcs, &amp;current_frame, cp, false, CHECK_VERIFY(this));
1720           no_control_flow = false; break;
1721         case Bytecodes::_invokevirtual :
1722         case Bytecodes::_invokespecial :
1723         case Bytecodes::_invokestatic :
1724         case Bytecodes::_invokeinterface :
1725         case Bytecodes::_invokedynamic :
1726           verify_invoke_instructions(
1727             &amp;bcs, code_length, &amp;current_frame, (bci &gt;= ex_min &amp;&amp; bci &lt; ex_max),
1728             &amp;this_uninit, cp, &amp;stackmap_table, CHECK_VERIFY(this));
1729           no_control_flow = false; break;
1730         case Bytecodes::_new :
1731         {
1732           index = bcs.get_index_u2();
1733           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1734           VerificationType new_class_type =
1735             cp_index_to_type(index, cp, CHECK_VERIFY(this));
1736           if (!new_class_type.is_object()) {
1737             verify_error(ErrorContext::bad_type(bci,
1738                 TypeOrigin::cp(index, new_class_type)),
1739                 &quot;Illegal new instruction&quot;);
1740             return;
1741           }
1742           type = VerificationType::uninitialized_type(bci);
1743           current_frame.push_stack(type, CHECK_VERIFY(this));
1744           no_control_flow = false; break;
1745         }
1746         case Bytecodes::_defaultvalue :
1747         {
<span class="line-modified">1748           if (_klass-&gt;major_version() &lt; VALUETYPE_MAJOR_VERSION) {</span>
1749             class_format_error(
1750               &quot;defaultvalue not supported by this class file version (%d.%d), class %s&quot;,
1751               _klass-&gt;major_version(), _klass-&gt;minor_version(), _klass-&gt;external_name());
1752             return;
1753           }
1754           index = bcs.get_index_u2();
1755           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1756           VerificationType ref_type = cp_index_to_type(index, cp, CHECK_VERIFY(this));
1757           if (!ref_type.is_object()) {
1758             verify_error(ErrorContext::bad_type(bci,
1759                 TypeOrigin::cp(index, ref_type)),
1760                 &quot;Illegal defaultvalue instruction&quot;);
1761             return;
1762           }
<span class="line-modified">1763           VerificationType value_type =</span>
<span class="line-modified">1764             VerificationType::change_ref_to_valuetype(ref_type);</span>
<span class="line-modified">1765           current_frame.push_stack(value_type, CHECK_VERIFY(this));</span>
1766           no_control_flow = false; break;
1767         }
1768         case Bytecodes::_newarray :
1769           type = get_newarray_type(bcs.get_index(), bci, CHECK_VERIFY(this));
1770           current_frame.pop_stack(
1771             VerificationType::integer_type(),  CHECK_VERIFY(this));
1772           current_frame.push_stack(type, CHECK_VERIFY(this));
1773           no_control_flow = false; break;
1774         case Bytecodes::_anewarray :
1775           verify_anewarray(
1776             bci, bcs.get_index_u2(), cp, &amp;current_frame, CHECK_VERIFY(this));
1777           no_control_flow = false; break;
1778         case Bytecodes::_arraylength :
1779           type = current_frame.pop_stack(
1780             VerificationType::reference_check(), CHECK_VERIFY(this));
1781           if (!(type.is_null() || type.is_array())) {
1782             verify_error(ErrorContext::bad_type(
1783                 bci, current_frame.stack_top_ctx()),
1784                 bad_type_msg, &quot;arraylength&quot;);
1785           }
</pre>
<hr />
<pre>
2383   int n = change_sig_to_verificationType(&amp;sig_stream, field_type);
2384   u2 bci = bcs-&gt;bci();
2385   bool is_assignable;
2386   switch (bcs-&gt;raw_code()) {
2387     case Bytecodes::_getstatic: {
2388       for (int i = 0; i &lt; n; i++) {
2389         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
2390       }
2391       break;
2392     }
2393     case Bytecodes::_putstatic: {
2394       for (int i = n - 1; i &gt;= 0; i--) {
2395         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2396       }
2397       break;
2398     }
2399     case Bytecodes::_withfield: {
2400       for (int i = n - 1; i &gt;= 0; i--) {
2401         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2402       }
<span class="line-modified">2403       // stack_object_type and target_class_type must be the same value type.</span>
2404       stack_object_type =
<span class="line-modified">2405         current_frame-&gt;pop_stack(VerificationType::valuetype_check(), CHECK_VERIFY(this));</span>
<span class="line-modified">2406       VerificationType target_value_type =</span>
<span class="line-modified">2407         VerificationType::change_ref_to_valuetype(target_class_type);</span>
<span class="line-modified">2408       if (!stack_object_type.equals(target_value_type)) {</span>
<span class="line-modified">2409         verify_error(ErrorContext::bad_value_type(bci,</span>
2410             current_frame-&gt;stack_top_ctx(),
2411             TypeOrigin::cp(index, target_class_type)),
2412             &quot;Invalid type on operand stack in withfield instruction&quot;);
2413         return;
2414       }
<span class="line-modified">2415       current_frame-&gt;push_stack(target_value_type, CHECK_VERIFY(this));</span>
2416       break;
2417     }
2418     case Bytecodes::_getfield: {
2419       stack_object_type = current_frame-&gt;pop_stack(
2420         target_class_type, CHECK_VERIFY(this));
2421       for (int i = 0; i &lt; n; i++) {
2422         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
2423       }
2424       goto check_protected;
2425     }
2426     case Bytecodes::_putfield: {
2427       for (int i = n - 1; i &gt;= 0; i--) {
2428         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2429       }
2430       stack_object_type = current_frame-&gt;pop_stack(CHECK_VERIFY(this));
2431 
2432       // The JVMS 2nd edition allows field initialization before the superclass
2433       // initializer, if the field is defined within the current class.
2434       fieldDescriptor fd;
2435       if (stack_object_type == VerificationType::uninitialized_this_type() &amp;&amp;
</pre>
<hr />
<pre>
2916     if (*(bcp+3) != 0 || *(bcp+4) != 0) {
2917       verify_error(ErrorContext::bad_code(bci),
2918           &quot;Third and fourth operand bytes of invokedynamic must be zero&quot;);
2919       return;
2920     }
2921   }
2922 
2923   if (method_name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
2924     // Make sure &lt;init&gt; can only be invoked by invokespecial or invokestatic.
2925     // The allowed invocation mode of &lt;init&gt; depends on its signature.
2926     if ((opcode != Bytecodes::_invokespecial &amp;&amp;
2927          opcode != Bytecodes::_invokestatic) ||
2928         method_name != vmSymbols::object_initializer_name()) {
2929       verify_error(ErrorContext::bad_code(bci),
2930           &quot;Illegal call to internal method&quot;);
2931       return;
2932     }
2933   } else if (opcode == Bytecodes::_invokespecial
2934              &amp;&amp; !is_same_or_direct_interface(current_class(), current_type(), ref_class_type)
2935              &amp;&amp; !ref_class_type.equals(VerificationType::reference_type(
<span class="line-modified">2936                   current_class()-&gt;super()-&gt;name()))) { // super() can never be a value_type.</span>
2937     bool subtype = false;
2938     bool have_imr_indirect = cp-&gt;tag_at(index).value() == JVM_CONSTANT_InterfaceMethodref;
2939     if (!current_class()-&gt;is_unsafe_anonymous()) {
2940       subtype = ref_class_type.is_assignable_from(
2941                  current_type(), this, false, CHECK_VERIFY(this));
2942     } else {
2943       InstanceKlass* unsafe_host = current_class()-&gt;unsafe_anonymous_host();
<span class="line-modified">2944       VerificationType unsafe_anonymous_host_type = reference_or_valuetype(unsafe_host);</span>
2945       subtype = ref_class_type.is_assignable_from(unsafe_anonymous_host_type, this, false, CHECK_VERIFY(this));
2946 
2947       // If invokespecial of IMR, need to recheck for same or
2948       // direct interface relative to the host class
2949       have_imr_indirect = (have_imr_indirect &amp;&amp;
2950                            !is_same_or_direct_interface(
2951                              unsafe_host,
2952                              unsafe_anonymous_host_type, ref_class_type));
2953     }
2954     if (!subtype) {
2955       verify_error(ErrorContext::bad_code(bci),
2956           &quot;Bad invokespecial instruction: &quot;
2957           &quot;current class isn&#39;t assignable to reference class.&quot;);
2958        return;
2959     } else if (have_imr_indirect) {
2960       verify_error(ErrorContext::bad_code(bci),
2961           &quot;Bad invokespecial instruction: &quot;
2962           &quot;interface method reference is in an indirect superinterface.&quot;);
2963       return;
2964     }
</pre>
<hr />
<pre>
2978   if (opcode != Bytecodes::_invokestatic &amp;&amp;
2979       opcode != Bytecodes::_invokedynamic) {
2980     if (method_name == vmSymbols::object_initializer_name()) {  // &lt;init&gt; method
2981       // (use of &lt;init&gt; as a static factory is handled under invokestatic)
2982       verify_invoke_init(bcs, index, ref_class_type, current_frame,
2983         code_length, in_try_block, this_uninit, cp, stackmap_table,
2984         CHECK_VERIFY(this));
2985       if (was_recursively_verified()) return;
2986     } else {   // other methods
2987       // Ensures that target class is assignable to method class.
2988       if (opcode == Bytecodes::_invokespecial) {
2989         if (!current_class()-&gt;is_unsafe_anonymous()) {
2990           current_frame-&gt;pop_stack(current_type(), CHECK_VERIFY(this));
2991         } else {
2992           // anonymous class invokespecial calls: check if the
2993           // objectref is a subtype of the unsafe_anonymous_host of the current class
2994           // to allow an anonymous class to reference methods in the unsafe_anonymous_host
2995           VerificationType top = current_frame-&gt;pop_stack(CHECK_VERIFY(this));
2996 
2997           InstanceKlass* unsafe_host = current_class()-&gt;unsafe_anonymous_host();
<span class="line-modified">2998           VerificationType host_type = reference_or_valuetype(unsafe_host);</span>
2999           bool subtype = host_type.is_assignable_from(top, this, false, CHECK_VERIFY(this));
3000           if (!subtype) {
3001             verify_error( ErrorContext::bad_type(current_frame-&gt;offset(),
3002               current_frame-&gt;stack_top_ctx(),
3003               TypeOrigin::implicit(top)),
3004               &quot;Bad type on operand stack&quot;);
3005             return;
3006           }
3007         }
3008       } else if (opcode == Bytecodes::_invokevirtual) {
3009         VerificationType stack_object_type =
3010           current_frame-&gt;pop_stack(ref_class_type, CHECK_VERIFY(this));
3011         if (current_type() != stack_object_type) {
3012           if (was_recursively_verified()) return;
3013           assert(cp-&gt;cache() == NULL, &quot;not rewritten yet&quot;);
3014           Symbol* ref_class_name =
3015             cp-&gt;klass_name_at(cp-&gt;klass_ref_index_at(index));
3016           // See the comments in verify_field_instructions() for
3017           // the rationale behind this.
3018           if (name_in_supers(ref_class_name, current_class())) {
</pre>
<hr />
<pre>
3102     cp_index_to_type(index, cp, CHECK_VERIFY(this));
3103   int length;
3104   char* arr_sig_str;
3105   if (component_type.is_array()) {     // it&#39;s an array
3106     const char* component_name = component_type.name()-&gt;as_utf8();
3107     // Check for more than MAX_ARRAY_DIMENSIONS
3108     length = (int)strlen(component_name);
3109     if (length &gt; MAX_ARRAY_DIMENSIONS &amp;&amp;
3110         component_name[MAX_ARRAY_DIMENSIONS - 1] == JVM_SIGNATURE_ARRAY) {
3111       verify_error(ErrorContext::bad_code(bci),
3112         &quot;Illegal anewarray instruction, array has more than 255 dimensions&quot;);
3113     }
3114     // add one dimension to component
3115     length++;
3116     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3117     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%s&quot;,
3118                          JVM_SIGNATURE_ARRAY, component_name);
3119     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3120   } else {         // it&#39;s an object or interface
3121     const char* component_name = component_type.name()-&gt;as_utf8();
<span class="line-modified">3122     char Q_or_L = component_type.is_valuetype() ? JVM_SIGNATURE_VALUETYPE : JVM_SIGNATURE_CLASS;</span>
3123     // add one dimension to component with &#39;L&#39; or &#39;Q&#39; prepended and &#39;;&#39; appended.
3124     length = (int)strlen(component_name) + 3;
3125     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3126     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%c%s;&quot;,
3127                          JVM_SIGNATURE_ARRAY, Q_or_L, component_name);
3128     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3129   }
3130   Symbol* arr_sig = create_temporary_symbol(arr_sig_str, length);
3131   VerificationType new_array_type = VerificationType::reference_type(arr_sig);
3132   current_frame-&gt;push_stack(new_array_type, CHECK_VERIFY(this));
3133 }
3134 
3135 void ClassVerifier::verify_iload(u2 index, StackMapFrame* current_frame, TRAPS) {
3136   current_frame-&gt;get_local(
3137     index, VerificationType::integer_type(), CHECK_VERIFY(this));
3138   current_frame-&gt;push_stack(
3139     VerificationType::integer_type(), CHECK_VERIFY(this));
3140 }
3141 
3142 void ClassVerifier::verify_lload(u2 index, StackMapFrame* current_frame, TRAPS) {
</pre>
</td>
<td>
<hr />
<pre>
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/constantPool.inline.hpp&quot;
  45 #include &quot;oops/instanceKlass.hpp&quot;
  46 #include &quot;oops/oop.inline.hpp&quot;
  47 #include &quot;oops/typeArrayOop.hpp&quot;
  48 #include &quot;runtime/fieldDescriptor.hpp&quot;
  49 #include &quot;runtime/handles.inline.hpp&quot;
  50 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  51 #include &quot;runtime/javaCalls.hpp&quot;
  52 #include &quot;runtime/jniHandles.inline.hpp&quot;
  53 #include &quot;runtime/os.hpp&quot;
  54 #include &quot;runtime/safepointVerifiers.hpp&quot;
  55 #include &quot;runtime/thread.hpp&quot;
  56 #include &quot;services/threadService.hpp&quot;
  57 #include &quot;utilities/align.hpp&quot;
  58 #include &quot;utilities/bytes.hpp&quot;
  59 
  60 #define NOFAILOVER_MAJOR_VERSION                       51
  61 #define NONZERO_PADDING_BYTES_IN_SWITCH_MAJOR_VERSION  51
  62 #define STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION       52
<span class="line-modified">  63 #define INLINE_TYPE_MAJOR_VERSION                       56</span>
  64 #define MAX_ARRAY_DIMENSIONS 255
  65 
  66 // Access to external entry for VerifyClassForMajorVersion - old byte code verifier
  67 
  68 extern &quot;C&quot; {
  69   typedef jboolean (*verify_byte_codes_fn_t)(JNIEnv *, jclass, char *, jint, jint);
  70 }
  71 
  72 static verify_byte_codes_fn_t volatile _verify_byte_codes_fn = NULL;
  73 
  74 static verify_byte_codes_fn_t verify_byte_codes_fn() {
  75 
  76   if (_verify_byte_codes_fn != NULL)
  77     return _verify_byte_codes_fn;
  78 
  79   MutexLocker locker(Verify_lock);
  80 
  81   if (_verify_byte_codes_fn != NULL)
  82     return _verify_byte_codes_fn;
  83 
</pre>
<hr />
<pre>
 470       ss-&gt;print(&quot;Local index %d is invalid&quot;, _type.index());
 471       break;
 472     case LOCALS_SIZE_MISMATCH:
 473       ss-&gt;print(&quot;Current frame&#39;s local size doesn&#39;t match stackmap.&quot;);
 474       break;
 475     case STACK_SIZE_MISMATCH:
 476       ss-&gt;print(&quot;Current frame&#39;s stack size doesn&#39;t match stackmap.&quot;);
 477       break;
 478     case STACK_OVERFLOW:
 479       ss-&gt;print(&quot;Exceeded max stack size.&quot;);
 480       break;
 481     case STACK_UNDERFLOW:
 482       ss-&gt;print(&quot;Attempt to pop empty stack.&quot;);
 483       break;
 484     case MISSING_STACKMAP:
 485       ss-&gt;print(&quot;Expected stackmap frame at this location.&quot;);
 486       break;
 487     case BAD_STACKMAP:
 488       ss-&gt;print(&quot;Invalid stackmap specification.&quot;);
 489       break;
<span class="line-modified"> 490     case WRONG_INLINE_TYPE:</span>
 491       ss-&gt;print(&quot;Type &quot;);
 492       _type.details(ss);
 493       ss-&gt;print(&quot; and type &quot;);
 494       _expected.details(ss);
 495       ss-&gt;print(&quot; must be identical inline types.&quot;);
 496       break;
 497     case UNKNOWN:
 498     default:
 499       ShouldNotReachHere();
 500       ss-&gt;print_cr(&quot;Unknown&quot;);
 501   }
 502   ss-&gt;cr();
 503 }
 504 
 505 void ErrorContext::location_details(outputStream* ss, const Method* method) const {
 506   if (_bci != -1 &amp;&amp; method != NULL) {
 507     streamIndentor si(ss);
 508     const char* bytecode_name = &quot;&lt;invalid&gt;&quot;;
 509     if (method-&gt;validate_bci(_bci) != -1) {
 510       Bytecodes::Code code = Bytecodes::code_or_bp_at(method-&gt;bcp_from(_bci));
</pre>
<hr />
<pre>
 571     stack_map_frame* sm_frame = sm_table-&gt;entries();
 572     streamIndentor si2(ss);
 573     int current_offset = -1;
 574     address end_of_sm_table = (address)sm_table + method-&gt;stackmap_data()-&gt;length();
 575     for (u2 i = 0; i &lt; sm_table-&gt;number_of_entries(); ++i) {
 576       ss-&gt;indent();
 577       if (!sm_frame-&gt;verify((address)sm_frame, end_of_sm_table)) {
 578         sm_frame-&gt;print_truncated(ss, current_offset);
 579         return;
 580       }
 581       sm_frame-&gt;print_on(ss, current_offset);
 582       ss-&gt;cr();
 583       current_offset += sm_frame-&gt;offset_delta();
 584       sm_frame = sm_frame-&gt;next();
 585     }
 586   }
 587 }
 588 
 589 // Methods in ClassVerifier
 590 
<span class="line-modified"> 591 VerificationType reference_or_inlinetype(InstanceKlass* klass) {</span>
 592   if (klass-&gt;is_value()) {
<span class="line-modified"> 593     return VerificationType::inlinetype_type(klass-&gt;name());</span>
 594   } else {
 595     return VerificationType::reference_type(klass-&gt;name());
 596   }
 597 }
 598 
 599 ClassVerifier::ClassVerifier(
 600     InstanceKlass* klass, TRAPS)
 601     : _thread(THREAD), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),
 602       _message(NULL), _method_signatures_table(NULL), _klass(klass) {
<span class="line-modified"> 603   _this_type = reference_or_inlinetype(klass);</span>
 604 }
 605 
 606 ClassVerifier::~ClassVerifier() {
 607   // Decrement the reference count for any symbols created.
 608   if (_symbols != NULL) {
 609     for (int i = 0; i &lt; _symbols-&gt;length(); i++) {
 610       Symbol* s = _symbols-&gt;at(i);
 611       s-&gt;decrement_refcount();
 612     }
 613   }
 614 }
 615 
 616 VerificationType ClassVerifier::object_type() const {
 617   return VerificationType::reference_type(vmSymbols::java_lang_Object());
 618 }
 619 
 620 TypeOrigin ClassVerifier::ref_ctx(const char* sig) {
 621   VerificationType vt = VerificationType::reference_type(
 622                          create_temporary_symbol(sig, (int)strlen(sig)));
 623   return TypeOrigin::implicit(vt);
</pre>
<hr />
<pre>
1691               current_frame.flag_this_uninit()) {
1692             verify_error(ErrorContext::bad_code(bci),
1693                          &quot;Constructor must call super() or this() &quot;
1694                          &quot;before return&quot;);
1695             return;
1696           }
1697           no_control_flow = true; break;
1698         case Bytecodes::_getstatic :
1699         case Bytecodes::_putstatic :
1700           // pass TRUE, operand can be an array type for getstatic/putstatic.
1701           verify_field_instructions(
1702             &amp;bcs, &amp;current_frame, cp, true, CHECK_VERIFY(this));
1703           no_control_flow = false; break;
1704         case Bytecodes::_getfield :
1705         case Bytecodes::_putfield :
1706           // pass FALSE, operand can&#39;t be an array type for getfield/putfield.
1707           verify_field_instructions(
1708             &amp;bcs, &amp;current_frame, cp, false, CHECK_VERIFY(this));
1709           no_control_flow = false; break;
1710         case Bytecodes::_withfield :
<span class="line-modified">1711           if (_klass-&gt;major_version() &lt; INLINE_TYPE_MAJOR_VERSION) {</span>
1712             class_format_error(
1713               &quot;withfield not supported by this class file version (%d.%d), class %s&quot;,
1714               _klass-&gt;major_version(), _klass-&gt;minor_version(), _klass-&gt;external_name());
1715             return;
1716           }
1717           // pass FALSE, operand can&#39;t be an array type for withfield.
1718           verify_field_instructions(
1719             &amp;bcs, &amp;current_frame, cp, false, CHECK_VERIFY(this));
1720           no_control_flow = false; break;
1721         case Bytecodes::_invokevirtual :
1722         case Bytecodes::_invokespecial :
1723         case Bytecodes::_invokestatic :
1724         case Bytecodes::_invokeinterface :
1725         case Bytecodes::_invokedynamic :
1726           verify_invoke_instructions(
1727             &amp;bcs, code_length, &amp;current_frame, (bci &gt;= ex_min &amp;&amp; bci &lt; ex_max),
1728             &amp;this_uninit, cp, &amp;stackmap_table, CHECK_VERIFY(this));
1729           no_control_flow = false; break;
1730         case Bytecodes::_new :
1731         {
1732           index = bcs.get_index_u2();
1733           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1734           VerificationType new_class_type =
1735             cp_index_to_type(index, cp, CHECK_VERIFY(this));
1736           if (!new_class_type.is_object()) {
1737             verify_error(ErrorContext::bad_type(bci,
1738                 TypeOrigin::cp(index, new_class_type)),
1739                 &quot;Illegal new instruction&quot;);
1740             return;
1741           }
1742           type = VerificationType::uninitialized_type(bci);
1743           current_frame.push_stack(type, CHECK_VERIFY(this));
1744           no_control_flow = false; break;
1745         }
1746         case Bytecodes::_defaultvalue :
1747         {
<span class="line-modified">1748           if (_klass-&gt;major_version() &lt; INLINE_TYPE_MAJOR_VERSION) {</span>
1749             class_format_error(
1750               &quot;defaultvalue not supported by this class file version (%d.%d), class %s&quot;,
1751               _klass-&gt;major_version(), _klass-&gt;minor_version(), _klass-&gt;external_name());
1752             return;
1753           }
1754           index = bcs.get_index_u2();
1755           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1756           VerificationType ref_type = cp_index_to_type(index, cp, CHECK_VERIFY(this));
1757           if (!ref_type.is_object()) {
1758             verify_error(ErrorContext::bad_type(bci,
1759                 TypeOrigin::cp(index, ref_type)),
1760                 &quot;Illegal defaultvalue instruction&quot;);
1761             return;
1762           }
<span class="line-modified">1763           VerificationType inline_type =</span>
<span class="line-modified">1764             VerificationType::change_ref_to_inlinetype(ref_type);</span>
<span class="line-modified">1765           current_frame.push_stack(inline_type, CHECK_VERIFY(this));</span>
1766           no_control_flow = false; break;
1767         }
1768         case Bytecodes::_newarray :
1769           type = get_newarray_type(bcs.get_index(), bci, CHECK_VERIFY(this));
1770           current_frame.pop_stack(
1771             VerificationType::integer_type(),  CHECK_VERIFY(this));
1772           current_frame.push_stack(type, CHECK_VERIFY(this));
1773           no_control_flow = false; break;
1774         case Bytecodes::_anewarray :
1775           verify_anewarray(
1776             bci, bcs.get_index_u2(), cp, &amp;current_frame, CHECK_VERIFY(this));
1777           no_control_flow = false; break;
1778         case Bytecodes::_arraylength :
1779           type = current_frame.pop_stack(
1780             VerificationType::reference_check(), CHECK_VERIFY(this));
1781           if (!(type.is_null() || type.is_array())) {
1782             verify_error(ErrorContext::bad_type(
1783                 bci, current_frame.stack_top_ctx()),
1784                 bad_type_msg, &quot;arraylength&quot;);
1785           }
</pre>
<hr />
<pre>
2383   int n = change_sig_to_verificationType(&amp;sig_stream, field_type);
2384   u2 bci = bcs-&gt;bci();
2385   bool is_assignable;
2386   switch (bcs-&gt;raw_code()) {
2387     case Bytecodes::_getstatic: {
2388       for (int i = 0; i &lt; n; i++) {
2389         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
2390       }
2391       break;
2392     }
2393     case Bytecodes::_putstatic: {
2394       for (int i = n - 1; i &gt;= 0; i--) {
2395         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2396       }
2397       break;
2398     }
2399     case Bytecodes::_withfield: {
2400       for (int i = n - 1; i &gt;= 0; i--) {
2401         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2402       }
<span class="line-modified">2403       // stack_object_type and target_class_type must be the same inline type.</span>
2404       stack_object_type =
<span class="line-modified">2405         current_frame-&gt;pop_stack(VerificationType::inlinetype_check(), CHECK_VERIFY(this));</span>
<span class="line-modified">2406       VerificationType target_inline_type =</span>
<span class="line-modified">2407         VerificationType::change_ref_to_inlinetype(target_class_type);</span>
<span class="line-modified">2408       if (!stack_object_type.equals(target_inline_type)) {</span>
<span class="line-modified">2409         verify_error(ErrorContext::bad_inline_type(bci,</span>
2410             current_frame-&gt;stack_top_ctx(),
2411             TypeOrigin::cp(index, target_class_type)),
2412             &quot;Invalid type on operand stack in withfield instruction&quot;);
2413         return;
2414       }
<span class="line-modified">2415       current_frame-&gt;push_stack(target_inline_type, CHECK_VERIFY(this));</span>
2416       break;
2417     }
2418     case Bytecodes::_getfield: {
2419       stack_object_type = current_frame-&gt;pop_stack(
2420         target_class_type, CHECK_VERIFY(this));
2421       for (int i = 0; i &lt; n; i++) {
2422         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
2423       }
2424       goto check_protected;
2425     }
2426     case Bytecodes::_putfield: {
2427       for (int i = n - 1; i &gt;= 0; i--) {
2428         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2429       }
2430       stack_object_type = current_frame-&gt;pop_stack(CHECK_VERIFY(this));
2431 
2432       // The JVMS 2nd edition allows field initialization before the superclass
2433       // initializer, if the field is defined within the current class.
2434       fieldDescriptor fd;
2435       if (stack_object_type == VerificationType::uninitialized_this_type() &amp;&amp;
</pre>
<hr />
<pre>
2916     if (*(bcp+3) != 0 || *(bcp+4) != 0) {
2917       verify_error(ErrorContext::bad_code(bci),
2918           &quot;Third and fourth operand bytes of invokedynamic must be zero&quot;);
2919       return;
2920     }
2921   }
2922 
2923   if (method_name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
2924     // Make sure &lt;init&gt; can only be invoked by invokespecial or invokestatic.
2925     // The allowed invocation mode of &lt;init&gt; depends on its signature.
2926     if ((opcode != Bytecodes::_invokespecial &amp;&amp;
2927          opcode != Bytecodes::_invokestatic) ||
2928         method_name != vmSymbols::object_initializer_name()) {
2929       verify_error(ErrorContext::bad_code(bci),
2930           &quot;Illegal call to internal method&quot;);
2931       return;
2932     }
2933   } else if (opcode == Bytecodes::_invokespecial
2934              &amp;&amp; !is_same_or_direct_interface(current_class(), current_type(), ref_class_type)
2935              &amp;&amp; !ref_class_type.equals(VerificationType::reference_type(
<span class="line-modified">2936                   current_class()-&gt;super()-&gt;name()))) { // super() can never be an inline_type.</span>
2937     bool subtype = false;
2938     bool have_imr_indirect = cp-&gt;tag_at(index).value() == JVM_CONSTANT_InterfaceMethodref;
2939     if (!current_class()-&gt;is_unsafe_anonymous()) {
2940       subtype = ref_class_type.is_assignable_from(
2941                  current_type(), this, false, CHECK_VERIFY(this));
2942     } else {
2943       InstanceKlass* unsafe_host = current_class()-&gt;unsafe_anonymous_host();
<span class="line-modified">2944       VerificationType unsafe_anonymous_host_type = reference_or_inlinetype(unsafe_host);</span>
2945       subtype = ref_class_type.is_assignable_from(unsafe_anonymous_host_type, this, false, CHECK_VERIFY(this));
2946 
2947       // If invokespecial of IMR, need to recheck for same or
2948       // direct interface relative to the host class
2949       have_imr_indirect = (have_imr_indirect &amp;&amp;
2950                            !is_same_or_direct_interface(
2951                              unsafe_host,
2952                              unsafe_anonymous_host_type, ref_class_type));
2953     }
2954     if (!subtype) {
2955       verify_error(ErrorContext::bad_code(bci),
2956           &quot;Bad invokespecial instruction: &quot;
2957           &quot;current class isn&#39;t assignable to reference class.&quot;);
2958        return;
2959     } else if (have_imr_indirect) {
2960       verify_error(ErrorContext::bad_code(bci),
2961           &quot;Bad invokespecial instruction: &quot;
2962           &quot;interface method reference is in an indirect superinterface.&quot;);
2963       return;
2964     }
</pre>
<hr />
<pre>
2978   if (opcode != Bytecodes::_invokestatic &amp;&amp;
2979       opcode != Bytecodes::_invokedynamic) {
2980     if (method_name == vmSymbols::object_initializer_name()) {  // &lt;init&gt; method
2981       // (use of &lt;init&gt; as a static factory is handled under invokestatic)
2982       verify_invoke_init(bcs, index, ref_class_type, current_frame,
2983         code_length, in_try_block, this_uninit, cp, stackmap_table,
2984         CHECK_VERIFY(this));
2985       if (was_recursively_verified()) return;
2986     } else {   // other methods
2987       // Ensures that target class is assignable to method class.
2988       if (opcode == Bytecodes::_invokespecial) {
2989         if (!current_class()-&gt;is_unsafe_anonymous()) {
2990           current_frame-&gt;pop_stack(current_type(), CHECK_VERIFY(this));
2991         } else {
2992           // anonymous class invokespecial calls: check if the
2993           // objectref is a subtype of the unsafe_anonymous_host of the current class
2994           // to allow an anonymous class to reference methods in the unsafe_anonymous_host
2995           VerificationType top = current_frame-&gt;pop_stack(CHECK_VERIFY(this));
2996 
2997           InstanceKlass* unsafe_host = current_class()-&gt;unsafe_anonymous_host();
<span class="line-modified">2998           VerificationType host_type = reference_or_inlinetype(unsafe_host);</span>
2999           bool subtype = host_type.is_assignable_from(top, this, false, CHECK_VERIFY(this));
3000           if (!subtype) {
3001             verify_error( ErrorContext::bad_type(current_frame-&gt;offset(),
3002               current_frame-&gt;stack_top_ctx(),
3003               TypeOrigin::implicit(top)),
3004               &quot;Bad type on operand stack&quot;);
3005             return;
3006           }
3007         }
3008       } else if (opcode == Bytecodes::_invokevirtual) {
3009         VerificationType stack_object_type =
3010           current_frame-&gt;pop_stack(ref_class_type, CHECK_VERIFY(this));
3011         if (current_type() != stack_object_type) {
3012           if (was_recursively_verified()) return;
3013           assert(cp-&gt;cache() == NULL, &quot;not rewritten yet&quot;);
3014           Symbol* ref_class_name =
3015             cp-&gt;klass_name_at(cp-&gt;klass_ref_index_at(index));
3016           // See the comments in verify_field_instructions() for
3017           // the rationale behind this.
3018           if (name_in_supers(ref_class_name, current_class())) {
</pre>
<hr />
<pre>
3102     cp_index_to_type(index, cp, CHECK_VERIFY(this));
3103   int length;
3104   char* arr_sig_str;
3105   if (component_type.is_array()) {     // it&#39;s an array
3106     const char* component_name = component_type.name()-&gt;as_utf8();
3107     // Check for more than MAX_ARRAY_DIMENSIONS
3108     length = (int)strlen(component_name);
3109     if (length &gt; MAX_ARRAY_DIMENSIONS &amp;&amp;
3110         component_name[MAX_ARRAY_DIMENSIONS - 1] == JVM_SIGNATURE_ARRAY) {
3111       verify_error(ErrorContext::bad_code(bci),
3112         &quot;Illegal anewarray instruction, array has more than 255 dimensions&quot;);
3113     }
3114     // add one dimension to component
3115     length++;
3116     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3117     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%s&quot;,
3118                          JVM_SIGNATURE_ARRAY, component_name);
3119     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3120   } else {         // it&#39;s an object or interface
3121     const char* component_name = component_type.name()-&gt;as_utf8();
<span class="line-modified">3122     char Q_or_L = component_type.is_inlinetype() ? JVM_SIGNATURE_INLINE_TYPE : JVM_SIGNATURE_CLASS;</span>
3123     // add one dimension to component with &#39;L&#39; or &#39;Q&#39; prepended and &#39;;&#39; appended.
3124     length = (int)strlen(component_name) + 3;
3125     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3126     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%c%s;&quot;,
3127                          JVM_SIGNATURE_ARRAY, Q_or_L, component_name);
3128     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3129   }
3130   Symbol* arr_sig = create_temporary_symbol(arr_sig_str, length);
3131   VerificationType new_array_type = VerificationType::reference_type(arr_sig);
3132   current_frame-&gt;push_stack(new_array_type, CHECK_VERIFY(this));
3133 }
3134 
3135 void ClassVerifier::verify_iload(u2 index, StackMapFrame* current_frame, TRAPS) {
3136   current_frame-&gt;get_local(
3137     index, VerificationType::integer_type(), CHECK_VERIFY(this));
3138   current_frame-&gt;push_stack(
3139     VerificationType::integer_type(), CHECK_VERIFY(this));
3140 }
3141 
3142 void ClassVerifier::verify_lload(u2 index, StackMapFrame* current_frame, TRAPS) {
</pre>
</td>
</tr>
</table>
<center><a href="verificationType.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="verifier.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
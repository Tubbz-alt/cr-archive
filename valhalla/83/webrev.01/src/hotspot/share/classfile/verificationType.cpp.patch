diff a/src/hotspot/share/classfile/verificationType.cpp b/src/hotspot/share/classfile/verificationType.cpp
--- a/src/hotspot/share/classfile/verificationType.cpp
+++ b/src/hotspot/share/classfile/verificationType.cpp
@@ -123,15 +123,15 @@
   } else if (is_array() && from.is_array()) {
     VerificationType comp_this = get_component(context, CHECK_false);
     VerificationType comp_from = from.get_component(context, CHECK_false);
 
 /*
-    // This code implements non-covariance between value type arrays and both
+    // This code implements non-covariance between inline type arrays and both
     // arrays of objects and arrays of interface types.  If covariance is
-    // supported for value type arrays then this code should be removed.
-    if (comp_from.is_valuetype() && !comp_this.is_null() && comp_this.is_reference()) {
-      // An array of value types is not assignable to an array of java.lang.Objects.
+    // supported for inline type arrays then this code should be removed.
+    if (comp_from.is_inlinetype() && !comp_this.is_null() && comp_this.is_reference()) {
+      // An array of inline types is not assignable to an array of java.lang.Objects.
       if (comp_this.name() == vmSymbols::java_lang_Object()) {
         return false;
       }
 
       // Need to load 'comp_this' to see if it is an interface.
@@ -143,11 +143,11 @@
             Handle(THREAD, klass->protection_domain()), true, CHECK_false);
         klass->class_loader_data()->record_dependency(comp_this_class);
         if (log_is_enabled(Debug, class, resolve)) {
           Verifier::trace_class_resolution(comp_this_class, klass);
         }
-        // An array of value types is not assignable to an array of interface types.
+        // An array of inline types is not assignable to an array of interface types.
         if (comp_this_class->is_interface()) {
           return false;
         }
       }
     }
@@ -158,19 +158,19 @@
     }
   }
   return false;
 }
 
-bool VerificationType::is_valuetype_assignable_from(const VerificationType& from) const {
-  // Check that 'from' is not null, is a value type, and is the same value type.
-  assert(is_valuetype(), "called with a non-valuetype type");
-  assert(!is_null(), "valuetype is not null");
-  return (!from.is_null() && from.is_valuetype() && name() == from.name());
+bool VerificationType::is_inlinetype_assignable_from(const VerificationType& from) const {
+  // Check that 'from' is not null, is an inline type, and is the same inline type.
+  assert(is_inlinetype(), "called with a non-inlinetype type");
+  assert(!is_null(), "inlinetype is not null");
+  return (!from.is_null() && from.is_inlinetype() && name() == from.name());
 }
 
-bool VerificationType::is_ref_assignable_from_value_type(const VerificationType& from, ClassVerifier* context, TRAPS) const {
-  assert(!from.is_null(), "Value type should not be null");
+bool VerificationType::is_ref_assignable_from_inline_type(const VerificationType& from, ClassVerifier* context, TRAPS) const {
+  assert(!from.is_null(), "Inline type should not be null");
   if (!is_null() && (name()->is_same_fundamental_type(from.name()) ||
       name() == vmSymbols::java_lang_Object())) {
     return true;
   }
 
@@ -219,11 +219,11 @@
       Symbol* component = ss.as_symbol();
       // Create another symbol to save as signature stream unreferences this symbol.
       Symbol* component_copy = context->create_temporary_symbol(component);
       assert(component_copy == component, "symbols don't match");
       return (ss.type() == T_VALUETYPE) ?
-        VerificationType::valuetype_type(component_copy) :
+        VerificationType::inlinetype_type(component_copy) :
         VerificationType::reference_type(component_copy);
    }
    default:
      // Met an invalid type signature, e.g. [X
      return VerificationType::bogus_type();
@@ -246,21 +246,21 @@
     case Double:           st->print("double"); break;
     case Long_2nd:         st->print("long_2nd"); break;
     case Double_2nd:       st->print("double_2nd"); break;
     case Null:             st->print("null"); break;
     case ReferenceQuery:   st->print("reference type"); break;
-    case ValueTypeQuery:   st->print("inline type"); break;
+    case InlineTypeQuery:  st->print("inline type"); break;
     case NonScalarQuery:   st->print("reference or inline type"); break;
     case Category1Query:   st->print("category1 type"); break;
     case Category2Query:   st->print("category2 type"); break;
     case Category2_2ndQuery: st->print("category2_2nd type"); break;
     default:
       if (is_uninitialized_this()) {
         st->print("uninitializedThis");
       } else if (is_uninitialized()) {
         st->print("uninitialized %d", bci());
-      } else if (is_valuetype()) {
+      } else if (is_inlinetype()) {
         name()->print_Qvalue_on(st);
       } else {
         if (name() != NULL) {
           name()->print_value_on(st);
         } else {

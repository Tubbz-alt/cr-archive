<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableArrays.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="TestArrays.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ValueTypeTest.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/compiler/valhalla/valuetypes/TestNullableArrays.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package compiler.valhalla.valuetypes;
  25 
  26 import jdk.test.lib.Asserts;
  27 import java.lang.reflect.Method;
  28 import java.util.Arrays;
  29 
  30 /*
  31  * @test
<span class="line-modified">  32  * @summary Test nullable value type arrays</span>
  33  * @library /testlibrary /test/lib /compiler/whitebox /
  34  * @requires (os.simpleArch == &quot;x64&quot; | os.simpleArch == &quot;aarch64&quot;)
  35  * @compile TestNullableArrays.java
  36  * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform
  37  * @run main/othervm/timeout=300 -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
  38  *                               -XX:+UnlockExperimentalVMOptions -XX:+WhiteBoxAPI
  39  *                               compiler.valhalla.valuetypes.ValueTypeTest
  40  *                               compiler.valhalla.valuetypes.TestNullableArrays
  41  */
  42 public class TestNullableArrays extends ValueTypeTest {
  43     // Unlike C2, C1 intrinsics never deoptimize System.arraycopy. Instead, we fall back to
  44     // a normal method invocation when encountering flattened arrays.
  45     private static void assertDeoptimizedByC2(Method m) {
  46         if (isCompiledByC2(m)) {
  47             throw new RuntimeException(&quot;Type check should have caused it to deoptimize&quot;);
  48         }
  49     }
  50 
  51     // Extra VM parameters for some test scenarios. See ValueTypeTest.getVMParameters()
  52     @Override
</pre>
<hr />
<pre>
  60         return null;
  61     }
  62 
  63     public static void main(String[] args) throws Throwable {
  64         TestNullableArrays test = new TestNullableArrays();
  65         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class);
  66     }
  67 
  68     // Helper methods
  69 
  70     protected long hash() {
  71         return hash(rI, rL);
  72     }
  73 
  74     protected long hash(int x, long y) {
  75         return MyValue1.createWithFieldsInline(x, y).hash();
  76     }
  77 
  78     private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);
  79 
<span class="line-modified">  80     // Test nullable value type array creation and initialization</span>
<span class="line-modified">  81     @Test(valid = ValueTypeArrayFlattenOn, match = { ALLOCA }, matchCount = { 1 })</span>
<span class="line-modified">  82     @Test(valid = ValueTypeArrayFlattenOff, match = { ALLOCA }, matchCount = { 1 }, failOn = LOAD)</span>
  83     public MyValue1.ref[] test1(int len) {
  84         MyValue1.ref[] va = new MyValue1.ref[len];
  85         if (len &gt; 0) {
  86             va[0] = null;
  87         }
  88         for (int i = 1; i &lt; len; ++i) {
  89             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
  90         }
  91         return va;
  92     }
  93 
  94     @DontCompile
  95     public void test1_verifier(boolean warmup) {
  96         int len = Math.abs(rI % 10);
  97         MyValue1.ref[] va = test1(len);
  98         if (len &gt; 0) {
  99             Asserts.assertEQ(va[0], null);
 100         }
 101         for (int i = 1; i &lt; len; ++i) {
 102             Asserts.assertEQ(va[i].hash(), hash());
 103         }
 104     }
 105 
<span class="line-modified"> 106     // Test creation of a value type array and element access</span>
 107     @Test
 108     // TODO 8227588
 109     // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 110     public long test2() {
 111         MyValue1.ref[] va = new MyValue1.ref[1];
 112         va[0] = MyValue1.createWithFieldsInline(rI, rL);
 113         return va[0].hash();
 114     }
 115 
 116     @DontCompile
 117     public void test2_verifier(boolean warmup) {
 118         long result = test2();
 119         Asserts.assertEQ(result, hash());
 120     }
 121 
<span class="line-modified"> 122     // Test receiving a value type array from the interpreter,</span>
 123     // updating its elements in a loop and computing a hash.
 124     @Test(failOn = ALLOCA)
 125     public long test3(MyValue1.ref[] va) {
 126         long result = 0;
 127         for (int i = 0; i &lt; 10; ++i) {
 128             if (va[i] != null) {
 129                 result += va[i].hash();
 130             }
 131             va[i] = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 132         }
 133         va[0] = null;
 134         return result;
 135     }
 136 
 137     @DontCompile
 138     public void test3_verifier(boolean warmup) {
 139         MyValue1.ref[] va = new MyValue1.ref[10];
 140         long expected = 0;
 141         for (int i = 1; i &lt; 10; ++i) {
 142             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
 143             expected += va[i].hash();
 144         }
 145         long result = test3(va);
 146         Asserts.assertEQ(expected, result);
 147         Asserts.assertEQ(va[0], null);
 148         for (int i = 1; i &lt; 10; ++i) {
 149             if (va[i].hash() != hash(rI + 1, rL + 1)) {
 150                 Asserts.assertEQ(va[i].hash(), hash(rI + 1, rL + 1));
 151             }
 152         }
 153     }
 154 
<span class="line-modified"> 155     // Test returning a value type array received from the interpreter</span>
 156     @Test(failOn = ALLOC + ALLOCA + LOAD + STORE + LOOP + TRAP)
 157     public MyValue1.ref[] test4(MyValue1.ref[] va) {
 158         return va;
 159     }
 160 
 161     @DontCompile
 162     public void test4_verifier(boolean warmup) {
 163         MyValue1.ref[] va = new MyValue1.ref[10];
 164         for (int i = 0; i &lt; 10; ++i) {
 165             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
 166         }
 167         va = test4(va);
 168         for (int i = 0; i &lt; 10; ++i) {
 169             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
 170         }
 171     }
 172 
<span class="line-modified"> 173     // Merge value type arrays created from two branches</span>
 174     @Test
 175     public MyValue1.ref[] test5(boolean b) {
 176         MyValue1.ref[] va;
 177         if (b) {
 178             va = new MyValue1.ref[5];
 179             for (int i = 0; i &lt; 5; ++i) {
 180                 va[i] = MyValue1.createWithFieldsInline(rI, rL);
 181             }
 182             va[4] = null;
 183         } else {
 184             va = new MyValue1.ref[10];
 185             for (int i = 0; i &lt; 10; ++i) {
 186                 va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);
 187             }
 188             va[9] = null;
 189         }
 190         long sum = va[0].hashInterpreted();
 191         if (b) {
 192             va[0] = MyValue1.createWithFieldsDontInline(rI, sum);
 193         } else {
</pre>
<hr />
<pre>
 197     }
 198 
 199     @DontCompile
 200     public void test5_verifier(boolean warmup) {
 201         MyValue1.ref[] va = test5(true);
 202         Asserts.assertEQ(va.length, 5);
 203         Asserts.assertEQ(va[0].hash(), hash(rI, hash()));
 204         for (int i = 1; i &lt; 4; ++i) {
 205             Asserts.assertEQ(va[i].hash(), hash());
 206         }
 207         Asserts.assertEQ(va[4], null);
 208         va = test5(false);
 209         Asserts.assertEQ(va.length, 10);
 210         Asserts.assertEQ(va[0].hash(), hash(rI + 1, hash(rI, rL) + 1));
 211         for (int i = 1; i &lt; 9; ++i) {
 212             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
 213         }
 214         Asserts.assertEQ(va[9], null);
 215     }
 216 
<span class="line-modified"> 217     // Test creation of value type array with single element</span>
 218     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 219     public MyValue1.ref test6() {
 220         MyValue1.ref[] va = new MyValue1.ref[1];
 221         return va[0];
 222     }
 223 
 224     @DontCompile
 225     public void test6_verifier(boolean warmup) {
 226         MyValue1.ref[] va = new MyValue1.ref[1];
 227         MyValue1.ref v = test6();
 228         Asserts.assertEQ(v, null);
 229     }
 230 
<span class="line-modified"> 231     // Test default initialization of value type arrays</span>
 232     @Test(failOn = LOAD)
 233     public MyValue1.ref[] test7(int len) {
 234         return new MyValue1.ref[len];
 235     }
 236 
 237     @DontCompile
 238     public void test7_verifier(boolean warmup) {
 239         int len = Math.abs(rI % 10);
 240         MyValue1.ref[] va = test7(len);
 241         for (int i = 0; i &lt; len; ++i) {
 242             Asserts.assertEQ(va[i], null);
 243             va[i] = null;
 244         }
 245     }
 246 
<span class="line-modified"> 247     // Test creation of value type array with zero length</span>
 248     @Test(failOn = ALLOC + LOAD + STORE + LOOP + TRAP)
 249     public MyValue1.ref[] test8() {
 250         return new MyValue1.ref[0];
 251     }
 252 
 253     @DontCompile
 254     public void test8_verifier(boolean warmup) {
 255         MyValue1.ref[] va = test8();
 256         Asserts.assertEQ(va.length, 0);
 257     }
 258 
 259     static MyValue1.ref[] test9_va;
 260 
<span class="line-modified"> 261     // Test that value type array loaded from field has correct type</span>
 262     @Test(failOn = LOOP)
 263     public long test9() {
 264         return test9_va[0].hash();
 265     }
 266 
 267     @DontCompile
 268     public void test9_verifier(boolean warmup) {
 269         test9_va = new MyValue1.ref[1];
 270         test9_va[0] = testValue1;
 271         long result = test9();
 272         Asserts.assertEQ(result, hash());
 273     }
 274 
 275     // Multi-dimensional arrays
 276     @Test
 277     public MyValue1.ref[][][] test10(int len1, int len2, int len3) {
 278         MyValue1.ref[][][] arr = new MyValue1.ref[len1][len2][len3];
 279         for (int i = 0; i &lt; len1; i++) {
 280             for (int j = 0; j &lt; len2; j++) {
 281                 for (int k = 0; k &lt; len3; k++) {
</pre>
<hr />
<pre>
 529     @Test
 530     public MyValue1.ref[] test19() {
 531         MyValue1.ref[] va = new MyValue1.ref[8];
 532         for (int i = 1; i &lt; va.length; ++i) {
 533             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 534         }
 535         test19_orig = va;
 536 
 537         return va.clone();
 538     }
 539 
 540     @DontCompile
 541     public void test19_verifier(boolean warmup) {
 542         MyValue1.ref[] result = test19();
 543         Asserts.assertEQ(result[0], null);
 544         for (int i = 1; i &lt; test19_orig.length; ++i) {
 545             Asserts.assertEQ(result[i].hash(), test19_orig[i].hash());
 546         }
 547     }
 548 
<span class="line-modified"> 549     // arraycopy() of value type array with oop fields</span>
 550     @Test
 551     public void test20(MyValue1.ref[] src, MyValue1.ref[] dst) {
 552         System.arraycopy(src, 0, dst, 0, src.length);
 553     }
 554 
 555     @DontCompile
 556     public void test20_verifier(boolean warmup) {
 557         int len = Math.abs(rI) % 10;
 558         MyValue1.ref[] src1 = new MyValue1.ref[len];
 559         MyValue1.ref[] src2 = new MyValue1.ref[len];
 560         MyValue1[]  src3 = new MyValue1[len];
 561         MyValue1[]  src4 = new MyValue1[len];
 562         MyValue1.ref[] dst1 = new MyValue1.ref[len];
 563         MyValue1[]  dst2 = new MyValue1[len];
 564         MyValue1.ref[] dst3 = new MyValue1.ref[len];
 565         MyValue1[]  dst4 = new MyValue1[len];
 566         if (len &gt; 0) {
 567             src2[0] = testValue1;
 568         }
 569         for (int i = 1; i &lt; len; ++i) {
</pre>
<hr />
<pre>
 573             src4[i] = testValue1;
 574         }
 575         test20(src1, dst1);
 576         test20(src2, dst2);
 577         test20(src3, dst3);
 578         test20(src4, dst4);
 579         if (len &gt; 0) {
 580             Asserts.assertEQ(dst1[0], null);
 581             Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 582             Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 583             Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 584         }
 585         for (int i = 1; i &lt; len; ++i) {
 586             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 587             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 588             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 589             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 590         }
 591     }
 592 
<span class="line-modified"> 593     // arraycopy() of value type array with no oop field</span>
 594     @Test
 595     public void test21(MyValue2.ref[] src, MyValue2.ref[] dst) {
 596         System.arraycopy(src, 0, dst, 0, src.length);
 597     }
 598 
 599     @DontCompile
 600     public void test21_verifier(boolean warmup) {
 601         int len = Math.abs(rI) % 10;
 602         MyValue2.ref[] src1 = new MyValue2.ref[len];
 603         MyValue2.ref[] src2 = new MyValue2.ref[len];
 604         MyValue2[]  src3 = new MyValue2[len];
 605         MyValue2[]  src4 = new MyValue2[len];
 606         MyValue2.ref[] dst1 = new MyValue2.ref[len];
 607         MyValue2[]  dst2 = new MyValue2[len];
 608         MyValue2.ref[] dst3 = new MyValue2.ref[len];
 609         MyValue2[]  dst4 = new MyValue2[len];
 610         if (len &gt; 0) {
 611             src2[0] = MyValue2.createWithFieldsInline(rI, true);
 612         }
 613         for (int i = 1; i &lt; len; ++i) {
</pre>
<hr />
<pre>
 617             src4[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 618         }
 619         test21(src1, dst1);
 620         test21(src2, dst2);
 621         test21(src3, dst3);
 622         test21(src4, dst4);
 623         if (len &gt; 0) {
 624             Asserts.assertEQ(dst1[0], null);
 625             Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 626             Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 627             Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 628         }
 629         for (int i = 1; i &lt; len; ++i) {
 630             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 631             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 632             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 633             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 634         }
 635     }
 636 
<span class="line-modified"> 637     // arraycopy() of value type array with oop field and tightly</span>
 638     // coupled allocation as dest
 639     @Test
 640     public MyValue1.ref[] test22(MyValue1.ref[] src) {
 641         MyValue1.ref[] dst = new MyValue1.ref[src.length];
 642         System.arraycopy(src, 0, dst, 0, src.length);
 643         return dst;
 644     }
 645 
 646     @DontCompile
 647     public void test22_verifier(boolean warmup) {
 648         int len = Math.abs(rI) % 10;
 649         MyValue1.ref[] src1 = new MyValue1.ref[len];
 650         MyValue1[]  src2 = new MyValue1[len];
 651         for (int i = 1; i &lt; len; ++i) {
 652             src1[i] = testValue1;
 653             src2[i] = testValue1;
 654         }
 655         MyValue1.ref[] dst1 = test22(src1);
 656         MyValue1.ref[] dst2 = test22(src2);
 657         if (len &gt; 0) {
 658             Asserts.assertEQ(dst1[0], null);
 659             Asserts.assertEQ(dst2[0].hash(), MyValue1.default.hash());
 660         }
 661         for (int i = 1; i &lt; len; ++i) {
 662             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 663             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 664         }
 665     }
 666 
<span class="line-modified"> 667     // arraycopy() of value type array with oop fields and tightly</span>
 668     // coupled allocation as dest
 669     @Test
 670     public MyValue1.ref[] test23(MyValue1.ref[] src) {
 671         MyValue1.ref[] dst = new MyValue1.ref[src.length + 10];
 672         System.arraycopy(src, 0, dst, 5, src.length);
 673         return dst;
 674     }
 675 
 676     @DontCompile
 677     public void test23_verifier(boolean warmup) {
 678         int len = Math.abs(rI) % 10;
 679         MyValue1.ref[] src1 = new MyValue1.ref[len];
 680         MyValue1[] src2 = new MyValue1[len];
 681         for (int i = 0; i &lt; len; ++i) {
 682             src1[i] = testValue1;
 683             src2[i] = testValue1;
 684         }
 685         MyValue1.ref[] dst1 = test23(src1);
 686         MyValue1.ref[] dst2 = test23(src2);
 687         for (int i = 0; i &lt; 5; ++i) {
 688             Asserts.assertEQ(dst1[i], null);
 689             Asserts.assertEQ(dst2[i], null);
 690         }
 691         for (int i = 5; i &lt; len; ++i) {
 692             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 693             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 694         }
 695     }
 696 
<span class="line-modified"> 697     // arraycopy() of value type array passed as Object</span>
 698     @Test
 699     public void test24(MyValue1.ref[] src, Object dst) {
 700         System.arraycopy(src, 0, dst, 0, src.length);
 701     }
 702 
 703     @DontCompile
 704     public void test24_verifier(boolean warmup) {
 705         int len = Math.abs(rI) % 10;
 706         MyValue1.ref[] src1 = new MyValue1.ref[len];
 707         MyValue1.ref[] src2 = new MyValue1.ref[len];
 708         MyValue1[]  src3 = new MyValue1[len];
 709         MyValue1[]  src4 = new MyValue1[len];
 710         MyValue1.ref[] dst1 = new MyValue1.ref[len];
 711         MyValue1[]  dst2 = new MyValue1[len];
 712         MyValue1.ref[] dst3 = new MyValue1.ref[len];
 713         MyValue1[]  dst4 = new MyValue1[len];
 714         if (len &gt; 0) {
 715             src2[0] = testValue1;
 716         }
 717         for (int i = 1; i &lt; len; ++i) {
</pre>
<hr />
<pre>
 877     // non escaping allocations
 878     // TODO 8227588: shouldn&#39;t this have the same IR matching rules as test6?
 879     @Test(failOn = ALLOCA + LOOP + TRAP)
 880     public MyValue2.ref test29(MyValue2.ref[] src) {
 881         MyValue2.ref[] dst = new MyValue2.ref[10];
 882         System.arraycopy(src, 0, dst, 0, 10);
 883         return dst[0];
 884     }
 885 
 886     @DontCompile
 887     public void test29_verifier(boolean warmup) {
 888         MyValue2.ref[] src = new MyValue2.ref[10];
 889         for (int i = 0; i &lt; 10; ++i) {
 890             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 891         }
 892         MyValue2.ref v = test29(src);
 893         Asserts.assertEQ(src[0].hash(), v.hash());
 894     }
 895 
 896     // non escaping allocation with uncommon trap that needs
<span class="line-modified"> 897     // eliminated value type array element as debug info</span>
 898     @Test
 899     @Warmup(10000)
 900     public MyValue2.ref test30(MyValue2.ref[] src, boolean flag) {
 901         MyValue2.ref[] dst = new MyValue2.ref[10];
 902         System.arraycopy(src, 0, dst, 0, 10);
 903         if (flag) { }
 904         return dst[0];
 905     }
 906 
 907     @DontCompile
 908     public void test30_verifier(boolean warmup) {
 909         MyValue2.ref[] src = new MyValue2.ref[10];
 910         for (int i = 0; i &lt; 10; ++i) {
 911             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 912         }
 913         MyValue2.ref v = test30(src, !warmup);
 914         Asserts.assertEQ(src[0].hash(), v.hash());
 915     }
 916 
 917     // non escaping allocation with memory phi
</pre>
<hr />
<pre>
1062             } else {
1063                 Asserts.assertEQ(dst[i], null);
1064             }
1065         }
1066     }
1067 
1068     static void verify(MyValue2.ref[] src, Object[] dst) {
1069         for (int i = 0; i &lt; src.length; ++i) {
1070             if (src[i] != null) {
1071                 Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
1072             } else {
1073                 Asserts.assertEQ(dst[i], null);
1074             }
1075         }
1076     }
1077 
1078     static boolean compile_and_run_again_if_deoptimized(boolean warmup, String test) {
1079         if (!warmup) {
1080             Method m = tests.get(test);
1081             if (USE_COMPILER &amp;&amp;  !WHITE_BOX.isMethodCompiled(m, false)) {
<span class="line-modified">1082                 if (!ValueTypeArrayFlatten &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {</span>
1083                     throw new RuntimeException(&quot;Unexpected deoptimization&quot;);
1084                 }
1085                 enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1086                 return true;
1087             }
1088         }
1089         return false;
1090     }
1091 
<span class="line-modified">1092     // arraycopy() of value type array of unknown size</span>
1093     @Test
1094     public void test35(Object src, Object dst, int len) {
1095         System.arraycopy(src, 0, dst, 0, len);
1096     }
1097 
1098     @DontCompile
1099     public void test35_verifier(boolean warmup) {
1100         int len = Math.abs(rI) % 10;
1101         MyValue1.ref[] src = new MyValue1.ref[len];
1102         MyValue1.ref[] dst = new MyValue1.ref[len];
1103         for (int i = 1; i &lt; len; ++i) {
1104             src[i] = testValue1;
1105         }
1106         test35(src, dst, src.length);
1107         verify(src, dst);
1108         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test35&quot;)) {
1109             test35(src, dst, src.length);
1110             verify(src, dst);
1111         }
1112     }
</pre>
<hr />
<pre>
1694         Object[] arr = test63_helper(i, va, oa);
1695 
1696         return Arrays.copyOf(arr, arr.length+1, arr.getClass());
1697     }
1698 
1699     @DontCompile
1700     public void test63_verifier(boolean warmup) {
1701         int len = Math.abs(rI) % 10;
1702         MyValue1.ref[] va = new MyValue1.ref[len];
1703         MyValue1.ref[] verif = new MyValue1.ref[len+1];
1704         for (int i = 1; i &lt; len; ++i) {
1705             va[i] = testValue1;
1706             verif[i] = va[i];
1707         }
1708         Integer[] oa = new Integer[len];
1709         test63_helper(42, va, oa);
1710         Object[] result = test63(va, oa);
1711         verify(verif, result);
1712     }
1713 
<span class="line-modified">1714     // Test default initialization of value type arrays: small array</span>
1715     @Test
1716     public MyValue1.ref[] test64() {
1717         return new MyValue1.ref[8];
1718     }
1719 
1720     @DontCompile
1721     public void test64_verifier(boolean warmup) {
1722         MyValue1.ref[] va = test64();
1723         for (int i = 0; i &lt; 8; ++i) {
1724             Asserts.assertEQ(va[i], null);
1725         }
1726     }
1727 
<span class="line-modified">1728     // Test default initialization of value type arrays: large array</span>
1729     @Test
1730     public MyValue1.ref[] test65() {
1731         return new MyValue1.ref[32];
1732     }
1733 
1734     @DontCompile
1735     public void test65_verifier(boolean warmup) {
1736         MyValue1.ref[] va = test65();
1737         for (int i = 0; i &lt; 32; ++i) {
1738             Asserts.assertEQ(va[i], null);
1739         }
1740     }
1741 
1742     // Check init store elimination
1743     @Test(match = { ALLOCA }, matchCount = { 1 })
1744     public MyValue1.ref[] test66(MyValue1.ref vt) {
1745         MyValue1.ref[] va = new MyValue1.ref[1];
1746         va[0] = vt;
1747         return va;
1748     }
</pre>
<hr />
<pre>
2041         }
2042         return va;
2043     }
2044 
2045     @DontCompile
2046     public void test77_verifier(boolean warmup) {
2047         Object[] va = test77(true);
2048         Asserts.assertEQ(va.length, 5);
2049         Asserts.assertEQ(((MyValue1)va[0]).hash(), hash(rI, hash()));
2050         for (int i = 1; i &lt; 5; ++i) {
2051             Asserts.assertEQ(((MyValue1)va[i]).hash(), hash());
2052         }
2053         va = test77(false);
2054         Asserts.assertEQ(va.length, 10);
2055         Asserts.assertEQ(((MyValue1)va[0]).hash(), hash(rI + 1, hash(rI, rL) + 1));
2056         for (int i = 1; i &lt; 10; ++i) {
2057             Asserts.assertEQ(((MyValue1)va[i]).hash(), hash(rI + i, rL + i));
2058         }
2059     }
2060 
<span class="line-modified">2061     // Same as test76 but with non value type array cases</span>
2062     @Test
2063     public Object[] test78(MyValue1[] vva, MyValue1.ref[] vba, Object val, Object[] out, int n) {
2064         Object[] result = null;
2065         if (n == 0) {
2066             result = vva;
2067         } else if (n == 1) {
2068             result = vba;
2069         } else if (n == 2) {
2070             result = new MyValue1[42];
2071         } else if (n == 3) {
2072             result = new MyValue1.ref[42];
2073         } else if (n == 4) {
2074             result = new Integer[42];
2075         }
2076         result[0] = val;
2077         out[0] = result[1];
2078         return result;
2079     }
2080 
2081     @DontCompile
</pre>
<hr />
<pre>
2226         Asserts.assertEquals(res, testValue1.hash());
2227         res = test82(va, va, testValue1, null, 3, true);
2228         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2229         Asserts.assertEquals(res, testValue1.hash());
2230     }
2231 
2232     @Test(failOn = ALLOC + ALLOCA + STORE)
2233     public static long test83(MyValue1[] va) {
2234         MyValue1.ref[] result = va;
2235         return result[0].hash();
2236     }
2237 
2238     @DontCompile
2239     public void test83_verifier(boolean warmup) {
2240         MyValue1[] va = new MyValue1[42];
2241         va[0] = testValue1;
2242         long res = test83(va);
2243         Asserts.assertEquals(res, testValue1.hash());
2244     }
2245 
<span class="line-modified">2246     @Test(valid = ValueTypeArrayFlattenOn, failOn = ALLOC + LOOP + STORE + TRAP)</span>
<span class="line-modified">2247     @Test(valid = ValueTypeArrayFlattenOff)</span>
2248     public static MyValue1.ref[] test84(MyValue1 vt1, MyValue1.ref vt2) {
2249         MyValue1.ref[] result = new MyValue1[2];
2250         result[0] = vt1;
2251         result[1] = vt2;
2252         return result;
2253     }
2254 
2255     @DontCompile
2256     public void test84_verifier(boolean warmup) {
2257         MyValue1.ref[] res = test84(testValue1, testValue1);
2258         Asserts.assertEquals(res[0].hash(), testValue1.hash());
2259         Asserts.assertEquals(res[1].hash(), testValue1.hash());
2260         try {
2261             test84(testValue1, null);
2262             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2263         } catch (NullPointerException npe) {
2264             // Expected
2265         }
2266     }
2267 
</pre>
</td>
<td>
<hr />
<pre>
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package compiler.valhalla.valuetypes;
  25 
  26 import jdk.test.lib.Asserts;
  27 import java.lang.reflect.Method;
  28 import java.util.Arrays;
  29 
  30 /*
  31  * @test
<span class="line-modified">  32  * @summary Test nullable inline type arrays</span>
  33  * @library /testlibrary /test/lib /compiler/whitebox /
  34  * @requires (os.simpleArch == &quot;x64&quot; | os.simpleArch == &quot;aarch64&quot;)
  35  * @compile TestNullableArrays.java
  36  * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform
  37  * @run main/othervm/timeout=300 -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
  38  *                               -XX:+UnlockExperimentalVMOptions -XX:+WhiteBoxAPI
  39  *                               compiler.valhalla.valuetypes.ValueTypeTest
  40  *                               compiler.valhalla.valuetypes.TestNullableArrays
  41  */
  42 public class TestNullableArrays extends ValueTypeTest {
  43     // Unlike C2, C1 intrinsics never deoptimize System.arraycopy. Instead, we fall back to
  44     // a normal method invocation when encountering flattened arrays.
  45     private static void assertDeoptimizedByC2(Method m) {
  46         if (isCompiledByC2(m)) {
  47             throw new RuntimeException(&quot;Type check should have caused it to deoptimize&quot;);
  48         }
  49     }
  50 
  51     // Extra VM parameters for some test scenarios. See ValueTypeTest.getVMParameters()
  52     @Override
</pre>
<hr />
<pre>
  60         return null;
  61     }
  62 
  63     public static void main(String[] args) throws Throwable {
  64         TestNullableArrays test = new TestNullableArrays();
  65         test.run(args, MyValue1.class, MyValue2.class, MyValue2Inline.class);
  66     }
  67 
  68     // Helper methods
  69 
  70     protected long hash() {
  71         return hash(rI, rL);
  72     }
  73 
  74     protected long hash(int x, long y) {
  75         return MyValue1.createWithFieldsInline(x, y).hash();
  76     }
  77 
  78     private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);
  79 
<span class="line-modified">  80     // Test nullable inline type array creation and initialization</span>
<span class="line-modified">  81     @Test(valid = InlineTypeArrayFlattenOn, match = { ALLOCA }, matchCount = { 1 })</span>
<span class="line-modified">  82     @Test(valid = InlineTypeArrayFlattenOff, match = { ALLOCA }, matchCount = { 1 }, failOn = LOAD)</span>
  83     public MyValue1.ref[] test1(int len) {
  84         MyValue1.ref[] va = new MyValue1.ref[len];
  85         if (len &gt; 0) {
  86             va[0] = null;
  87         }
  88         for (int i = 1; i &lt; len; ++i) {
  89             va[i] = MyValue1.createWithFieldsDontInline(rI, rL);
  90         }
  91         return va;
  92     }
  93 
  94     @DontCompile
  95     public void test1_verifier(boolean warmup) {
  96         int len = Math.abs(rI % 10);
  97         MyValue1.ref[] va = test1(len);
  98         if (len &gt; 0) {
  99             Asserts.assertEQ(va[0], null);
 100         }
 101         for (int i = 1; i &lt; len; ++i) {
 102             Asserts.assertEQ(va[i].hash(), hash());
 103         }
 104     }
 105 
<span class="line-modified"> 106     // Test creation of a inline type array and element access</span>
 107     @Test
 108     // TODO 8227588
 109     // @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 110     public long test2() {
 111         MyValue1.ref[] va = new MyValue1.ref[1];
 112         va[0] = MyValue1.createWithFieldsInline(rI, rL);
 113         return va[0].hash();
 114     }
 115 
 116     @DontCompile
 117     public void test2_verifier(boolean warmup) {
 118         long result = test2();
 119         Asserts.assertEQ(result, hash());
 120     }
 121 
<span class="line-modified"> 122     // Test receiving a inline type array from the interpreter,</span>
 123     // updating its elements in a loop and computing a hash.
 124     @Test(failOn = ALLOCA)
 125     public long test3(MyValue1.ref[] va) {
 126         long result = 0;
 127         for (int i = 0; i &lt; 10; ++i) {
 128             if (va[i] != null) {
 129                 result += va[i].hash();
 130             }
 131             va[i] = MyValue1.createWithFieldsInline(rI + 1, rL + 1);
 132         }
 133         va[0] = null;
 134         return result;
 135     }
 136 
 137     @DontCompile
 138     public void test3_verifier(boolean warmup) {
 139         MyValue1.ref[] va = new MyValue1.ref[10];
 140         long expected = 0;
 141         for (int i = 1; i &lt; 10; ++i) {
 142             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
 143             expected += va[i].hash();
 144         }
 145         long result = test3(va);
 146         Asserts.assertEQ(expected, result);
 147         Asserts.assertEQ(va[0], null);
 148         for (int i = 1; i &lt; 10; ++i) {
 149             if (va[i].hash() != hash(rI + 1, rL + 1)) {
 150                 Asserts.assertEQ(va[i].hash(), hash(rI + 1, rL + 1));
 151             }
 152         }
 153     }
 154 
<span class="line-modified"> 155     // Test returning an inline type array received from the interpreter</span>
 156     @Test(failOn = ALLOC + ALLOCA + LOAD + STORE + LOOP + TRAP)
 157     public MyValue1.ref[] test4(MyValue1.ref[] va) {
 158         return va;
 159     }
 160 
 161     @DontCompile
 162     public void test4_verifier(boolean warmup) {
 163         MyValue1.ref[] va = new MyValue1.ref[10];
 164         for (int i = 0; i &lt; 10; ++i) {
 165             va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);
 166         }
 167         va = test4(va);
 168         for (int i = 0; i &lt; 10; ++i) {
 169             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
 170         }
 171     }
 172 
<span class="line-modified"> 173     // Merge inline type arrays created from two branches</span>
 174     @Test
 175     public MyValue1.ref[] test5(boolean b) {
 176         MyValue1.ref[] va;
 177         if (b) {
 178             va = new MyValue1.ref[5];
 179             for (int i = 0; i &lt; 5; ++i) {
 180                 va[i] = MyValue1.createWithFieldsInline(rI, rL);
 181             }
 182             va[4] = null;
 183         } else {
 184             va = new MyValue1.ref[10];
 185             for (int i = 0; i &lt; 10; ++i) {
 186                 va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);
 187             }
 188             va[9] = null;
 189         }
 190         long sum = va[0].hashInterpreted();
 191         if (b) {
 192             va[0] = MyValue1.createWithFieldsDontInline(rI, sum);
 193         } else {
</pre>
<hr />
<pre>
 197     }
 198 
 199     @DontCompile
 200     public void test5_verifier(boolean warmup) {
 201         MyValue1.ref[] va = test5(true);
 202         Asserts.assertEQ(va.length, 5);
 203         Asserts.assertEQ(va[0].hash(), hash(rI, hash()));
 204         for (int i = 1; i &lt; 4; ++i) {
 205             Asserts.assertEQ(va[i].hash(), hash());
 206         }
 207         Asserts.assertEQ(va[4], null);
 208         va = test5(false);
 209         Asserts.assertEQ(va.length, 10);
 210         Asserts.assertEQ(va[0].hash(), hash(rI + 1, hash(rI, rL) + 1));
 211         for (int i = 1; i &lt; 9; ++i) {
 212             Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));
 213         }
 214         Asserts.assertEQ(va[9], null);
 215     }
 216 
<span class="line-modified"> 217     // Test creation of inline type array with single element</span>
 218     @Test(failOn = ALLOC + ALLOCA + LOOP + LOAD + STORE + TRAP)
 219     public MyValue1.ref test6() {
 220         MyValue1.ref[] va = new MyValue1.ref[1];
 221         return va[0];
 222     }
 223 
 224     @DontCompile
 225     public void test6_verifier(boolean warmup) {
 226         MyValue1.ref[] va = new MyValue1.ref[1];
 227         MyValue1.ref v = test6();
 228         Asserts.assertEQ(v, null);
 229     }
 230 
<span class="line-modified"> 231     // Test default initialization of inline type arrays</span>
 232     @Test(failOn = LOAD)
 233     public MyValue1.ref[] test7(int len) {
 234         return new MyValue1.ref[len];
 235     }
 236 
 237     @DontCompile
 238     public void test7_verifier(boolean warmup) {
 239         int len = Math.abs(rI % 10);
 240         MyValue1.ref[] va = test7(len);
 241         for (int i = 0; i &lt; len; ++i) {
 242             Asserts.assertEQ(va[i], null);
 243             va[i] = null;
 244         }
 245     }
 246 
<span class="line-modified"> 247     // Test creation of inline type array with zero length</span>
 248     @Test(failOn = ALLOC + LOAD + STORE + LOOP + TRAP)
 249     public MyValue1.ref[] test8() {
 250         return new MyValue1.ref[0];
 251     }
 252 
 253     @DontCompile
 254     public void test8_verifier(boolean warmup) {
 255         MyValue1.ref[] va = test8();
 256         Asserts.assertEQ(va.length, 0);
 257     }
 258 
 259     static MyValue1.ref[] test9_va;
 260 
<span class="line-modified"> 261     // Test that inline type array loaded from field has correct type</span>
 262     @Test(failOn = LOOP)
 263     public long test9() {
 264         return test9_va[0].hash();
 265     }
 266 
 267     @DontCompile
 268     public void test9_verifier(boolean warmup) {
 269         test9_va = new MyValue1.ref[1];
 270         test9_va[0] = testValue1;
 271         long result = test9();
 272         Asserts.assertEQ(result, hash());
 273     }
 274 
 275     // Multi-dimensional arrays
 276     @Test
 277     public MyValue1.ref[][][] test10(int len1, int len2, int len3) {
 278         MyValue1.ref[][][] arr = new MyValue1.ref[len1][len2][len3];
 279         for (int i = 0; i &lt; len1; i++) {
 280             for (int j = 0; j &lt; len2; j++) {
 281                 for (int k = 0; k &lt; len3; k++) {
</pre>
<hr />
<pre>
 529     @Test
 530     public MyValue1.ref[] test19() {
 531         MyValue1.ref[] va = new MyValue1.ref[8];
 532         for (int i = 1; i &lt; va.length; ++i) {
 533             va[i] = MyValue1.createWithFieldsInline(rI, rL);
 534         }
 535         test19_orig = va;
 536 
 537         return va.clone();
 538     }
 539 
 540     @DontCompile
 541     public void test19_verifier(boolean warmup) {
 542         MyValue1.ref[] result = test19();
 543         Asserts.assertEQ(result[0], null);
 544         for (int i = 1; i &lt; test19_orig.length; ++i) {
 545             Asserts.assertEQ(result[i].hash(), test19_orig[i].hash());
 546         }
 547     }
 548 
<span class="line-modified"> 549     // arraycopy() of inline type array with oop fields</span>
 550     @Test
 551     public void test20(MyValue1.ref[] src, MyValue1.ref[] dst) {
 552         System.arraycopy(src, 0, dst, 0, src.length);
 553     }
 554 
 555     @DontCompile
 556     public void test20_verifier(boolean warmup) {
 557         int len = Math.abs(rI) % 10;
 558         MyValue1.ref[] src1 = new MyValue1.ref[len];
 559         MyValue1.ref[] src2 = new MyValue1.ref[len];
 560         MyValue1[]  src3 = new MyValue1[len];
 561         MyValue1[]  src4 = new MyValue1[len];
 562         MyValue1.ref[] dst1 = new MyValue1.ref[len];
 563         MyValue1[]  dst2 = new MyValue1[len];
 564         MyValue1.ref[] dst3 = new MyValue1.ref[len];
 565         MyValue1[]  dst4 = new MyValue1[len];
 566         if (len &gt; 0) {
 567             src2[0] = testValue1;
 568         }
 569         for (int i = 1; i &lt; len; ++i) {
</pre>
<hr />
<pre>
 573             src4[i] = testValue1;
 574         }
 575         test20(src1, dst1);
 576         test20(src2, dst2);
 577         test20(src3, dst3);
 578         test20(src4, dst4);
 579         if (len &gt; 0) {
 580             Asserts.assertEQ(dst1[0], null);
 581             Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 582             Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 583             Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 584         }
 585         for (int i = 1; i &lt; len; ++i) {
 586             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 587             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 588             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 589             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 590         }
 591     }
 592 
<span class="line-modified"> 593     // arraycopy() of inline type array with no oop field</span>
 594     @Test
 595     public void test21(MyValue2.ref[] src, MyValue2.ref[] dst) {
 596         System.arraycopy(src, 0, dst, 0, src.length);
 597     }
 598 
 599     @DontCompile
 600     public void test21_verifier(boolean warmup) {
 601         int len = Math.abs(rI) % 10;
 602         MyValue2.ref[] src1 = new MyValue2.ref[len];
 603         MyValue2.ref[] src2 = new MyValue2.ref[len];
 604         MyValue2[]  src3 = new MyValue2[len];
 605         MyValue2[]  src4 = new MyValue2[len];
 606         MyValue2.ref[] dst1 = new MyValue2.ref[len];
 607         MyValue2[]  dst2 = new MyValue2[len];
 608         MyValue2.ref[] dst3 = new MyValue2.ref[len];
 609         MyValue2[]  dst4 = new MyValue2[len];
 610         if (len &gt; 0) {
 611             src2[0] = MyValue2.createWithFieldsInline(rI, true);
 612         }
 613         for (int i = 1; i &lt; len; ++i) {
</pre>
<hr />
<pre>
 617             src4[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 618         }
 619         test21(src1, dst1);
 620         test21(src2, dst2);
 621         test21(src3, dst3);
 622         test21(src4, dst4);
 623         if (len &gt; 0) {
 624             Asserts.assertEQ(dst1[0], null);
 625             Asserts.assertEQ(dst2[0].hash(), src2[0].hash());
 626             Asserts.assertEQ(dst3[0].hash(), src3[0].hash());
 627             Asserts.assertEQ(dst4[0].hash(), src4[0].hash());
 628         }
 629         for (int i = 1; i &lt; len; ++i) {
 630             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 631             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 632             Asserts.assertEQ(src3[i].hash(), dst3[i].hash());
 633             Asserts.assertEQ(src4[i].hash(), dst4[i].hash());
 634         }
 635     }
 636 
<span class="line-modified"> 637     // arraycopy() of inline type array with oop field and tightly</span>
 638     // coupled allocation as dest
 639     @Test
 640     public MyValue1.ref[] test22(MyValue1.ref[] src) {
 641         MyValue1.ref[] dst = new MyValue1.ref[src.length];
 642         System.arraycopy(src, 0, dst, 0, src.length);
 643         return dst;
 644     }
 645 
 646     @DontCompile
 647     public void test22_verifier(boolean warmup) {
 648         int len = Math.abs(rI) % 10;
 649         MyValue1.ref[] src1 = new MyValue1.ref[len];
 650         MyValue1[]  src2 = new MyValue1[len];
 651         for (int i = 1; i &lt; len; ++i) {
 652             src1[i] = testValue1;
 653             src2[i] = testValue1;
 654         }
 655         MyValue1.ref[] dst1 = test22(src1);
 656         MyValue1.ref[] dst2 = test22(src2);
 657         if (len &gt; 0) {
 658             Asserts.assertEQ(dst1[0], null);
 659             Asserts.assertEQ(dst2[0].hash(), MyValue1.default.hash());
 660         }
 661         for (int i = 1; i &lt; len; ++i) {
 662             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 663             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 664         }
 665     }
 666 
<span class="line-modified"> 667     // arraycopy() of inline type array with oop fields and tightly</span>
 668     // coupled allocation as dest
 669     @Test
 670     public MyValue1.ref[] test23(MyValue1.ref[] src) {
 671         MyValue1.ref[] dst = new MyValue1.ref[src.length + 10];
 672         System.arraycopy(src, 0, dst, 5, src.length);
 673         return dst;
 674     }
 675 
 676     @DontCompile
 677     public void test23_verifier(boolean warmup) {
 678         int len = Math.abs(rI) % 10;
 679         MyValue1.ref[] src1 = new MyValue1.ref[len];
 680         MyValue1[] src2 = new MyValue1[len];
 681         for (int i = 0; i &lt; len; ++i) {
 682             src1[i] = testValue1;
 683             src2[i] = testValue1;
 684         }
 685         MyValue1.ref[] dst1 = test23(src1);
 686         MyValue1.ref[] dst2 = test23(src2);
 687         for (int i = 0; i &lt; 5; ++i) {
 688             Asserts.assertEQ(dst1[i], null);
 689             Asserts.assertEQ(dst2[i], null);
 690         }
 691         for (int i = 5; i &lt; len; ++i) {
 692             Asserts.assertEQ(src1[i].hash(), dst1[i].hash());
 693             Asserts.assertEQ(src2[i].hash(), dst2[i].hash());
 694         }
 695     }
 696 
<span class="line-modified"> 697     // arraycopy() of inline type array passed as Object</span>
 698     @Test
 699     public void test24(MyValue1.ref[] src, Object dst) {
 700         System.arraycopy(src, 0, dst, 0, src.length);
 701     }
 702 
 703     @DontCompile
 704     public void test24_verifier(boolean warmup) {
 705         int len = Math.abs(rI) % 10;
 706         MyValue1.ref[] src1 = new MyValue1.ref[len];
 707         MyValue1.ref[] src2 = new MyValue1.ref[len];
 708         MyValue1[]  src3 = new MyValue1[len];
 709         MyValue1[]  src4 = new MyValue1[len];
 710         MyValue1.ref[] dst1 = new MyValue1.ref[len];
 711         MyValue1[]  dst2 = new MyValue1[len];
 712         MyValue1.ref[] dst3 = new MyValue1.ref[len];
 713         MyValue1[]  dst4 = new MyValue1[len];
 714         if (len &gt; 0) {
 715             src2[0] = testValue1;
 716         }
 717         for (int i = 1; i &lt; len; ++i) {
</pre>
<hr />
<pre>
 877     // non escaping allocations
 878     // TODO 8227588: shouldn&#39;t this have the same IR matching rules as test6?
 879     @Test(failOn = ALLOCA + LOOP + TRAP)
 880     public MyValue2.ref test29(MyValue2.ref[] src) {
 881         MyValue2.ref[] dst = new MyValue2.ref[10];
 882         System.arraycopy(src, 0, dst, 0, 10);
 883         return dst[0];
 884     }
 885 
 886     @DontCompile
 887     public void test29_verifier(boolean warmup) {
 888         MyValue2.ref[] src = new MyValue2.ref[10];
 889         for (int i = 0; i &lt; 10; ++i) {
 890             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 891         }
 892         MyValue2.ref v = test29(src);
 893         Asserts.assertEQ(src[0].hash(), v.hash());
 894     }
 895 
 896     // non escaping allocation with uncommon trap that needs
<span class="line-modified"> 897     // eliminated inline type array element as debug info</span>
 898     @Test
 899     @Warmup(10000)
 900     public MyValue2.ref test30(MyValue2.ref[] src, boolean flag) {
 901         MyValue2.ref[] dst = new MyValue2.ref[10];
 902         System.arraycopy(src, 0, dst, 0, 10);
 903         if (flag) { }
 904         return dst[0];
 905     }
 906 
 907     @DontCompile
 908     public void test30_verifier(boolean warmup) {
 909         MyValue2.ref[] src = new MyValue2.ref[10];
 910         for (int i = 0; i &lt; 10; ++i) {
 911             src[i] = MyValue2.createWithFieldsInline(rI, (i % 2) == 0);
 912         }
 913         MyValue2.ref v = test30(src, !warmup);
 914         Asserts.assertEQ(src[0].hash(), v.hash());
 915     }
 916 
 917     // non escaping allocation with memory phi
</pre>
<hr />
<pre>
1062             } else {
1063                 Asserts.assertEQ(dst[i], null);
1064             }
1065         }
1066     }
1067 
1068     static void verify(MyValue2.ref[] src, Object[] dst) {
1069         for (int i = 0; i &lt; src.length; ++i) {
1070             if (src[i] != null) {
1071                 Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());
1072             } else {
1073                 Asserts.assertEQ(dst[i], null);
1074             }
1075         }
1076     }
1077 
1078     static boolean compile_and_run_again_if_deoptimized(boolean warmup, String test) {
1079         if (!warmup) {
1080             Method m = tests.get(test);
1081             if (USE_COMPILER &amp;&amp;  !WHITE_BOX.isMethodCompiled(m, false)) {
<span class="line-modified">1082                 if (!InlineTypeArrayFlatten &amp;&amp; !XCOMP &amp;&amp; !STRESS_CC) {</span>
1083                     throw new RuntimeException(&quot;Unexpected deoptimization&quot;);
1084                 }
1085                 enqueueMethodForCompilation(m, COMP_LEVEL_FULL_OPTIMIZATION);
1086                 return true;
1087             }
1088         }
1089         return false;
1090     }
1091 
<span class="line-modified">1092     // arraycopy() of inline type array of unknown size</span>
1093     @Test
1094     public void test35(Object src, Object dst, int len) {
1095         System.arraycopy(src, 0, dst, 0, len);
1096     }
1097 
1098     @DontCompile
1099     public void test35_verifier(boolean warmup) {
1100         int len = Math.abs(rI) % 10;
1101         MyValue1.ref[] src = new MyValue1.ref[len];
1102         MyValue1.ref[] dst = new MyValue1.ref[len];
1103         for (int i = 1; i &lt; len; ++i) {
1104             src[i] = testValue1;
1105         }
1106         test35(src, dst, src.length);
1107         verify(src, dst);
1108         if (compile_and_run_again_if_deoptimized(warmup, &quot;TestNullableArrays::test35&quot;)) {
1109             test35(src, dst, src.length);
1110             verify(src, dst);
1111         }
1112     }
</pre>
<hr />
<pre>
1694         Object[] arr = test63_helper(i, va, oa);
1695 
1696         return Arrays.copyOf(arr, arr.length+1, arr.getClass());
1697     }
1698 
1699     @DontCompile
1700     public void test63_verifier(boolean warmup) {
1701         int len = Math.abs(rI) % 10;
1702         MyValue1.ref[] va = new MyValue1.ref[len];
1703         MyValue1.ref[] verif = new MyValue1.ref[len+1];
1704         for (int i = 1; i &lt; len; ++i) {
1705             va[i] = testValue1;
1706             verif[i] = va[i];
1707         }
1708         Integer[] oa = new Integer[len];
1709         test63_helper(42, va, oa);
1710         Object[] result = test63(va, oa);
1711         verify(verif, result);
1712     }
1713 
<span class="line-modified">1714     // Test default initialization of inline type arrays: small array</span>
1715     @Test
1716     public MyValue1.ref[] test64() {
1717         return new MyValue1.ref[8];
1718     }
1719 
1720     @DontCompile
1721     public void test64_verifier(boolean warmup) {
1722         MyValue1.ref[] va = test64();
1723         for (int i = 0; i &lt; 8; ++i) {
1724             Asserts.assertEQ(va[i], null);
1725         }
1726     }
1727 
<span class="line-modified">1728     // Test default initialization of inline type arrays: large array</span>
1729     @Test
1730     public MyValue1.ref[] test65() {
1731         return new MyValue1.ref[32];
1732     }
1733 
1734     @DontCompile
1735     public void test65_verifier(boolean warmup) {
1736         MyValue1.ref[] va = test65();
1737         for (int i = 0; i &lt; 32; ++i) {
1738             Asserts.assertEQ(va[i], null);
1739         }
1740     }
1741 
1742     // Check init store elimination
1743     @Test(match = { ALLOCA }, matchCount = { 1 })
1744     public MyValue1.ref[] test66(MyValue1.ref vt) {
1745         MyValue1.ref[] va = new MyValue1.ref[1];
1746         va[0] = vt;
1747         return va;
1748     }
</pre>
<hr />
<pre>
2041         }
2042         return va;
2043     }
2044 
2045     @DontCompile
2046     public void test77_verifier(boolean warmup) {
2047         Object[] va = test77(true);
2048         Asserts.assertEQ(va.length, 5);
2049         Asserts.assertEQ(((MyValue1)va[0]).hash(), hash(rI, hash()));
2050         for (int i = 1; i &lt; 5; ++i) {
2051             Asserts.assertEQ(((MyValue1)va[i]).hash(), hash());
2052         }
2053         va = test77(false);
2054         Asserts.assertEQ(va.length, 10);
2055         Asserts.assertEQ(((MyValue1)va[0]).hash(), hash(rI + 1, hash(rI, rL) + 1));
2056         for (int i = 1; i &lt; 10; ++i) {
2057             Asserts.assertEQ(((MyValue1)va[i]).hash(), hash(rI + i, rL + i));
2058         }
2059     }
2060 
<span class="line-modified">2061     // Same as test76 but with non inline type array cases</span>
2062     @Test
2063     public Object[] test78(MyValue1[] vva, MyValue1.ref[] vba, Object val, Object[] out, int n) {
2064         Object[] result = null;
2065         if (n == 0) {
2066             result = vva;
2067         } else if (n == 1) {
2068             result = vba;
2069         } else if (n == 2) {
2070             result = new MyValue1[42];
2071         } else if (n == 3) {
2072             result = new MyValue1.ref[42];
2073         } else if (n == 4) {
2074             result = new Integer[42];
2075         }
2076         result[0] = val;
2077         out[0] = result[1];
2078         return result;
2079     }
2080 
2081     @DontCompile
</pre>
<hr />
<pre>
2226         Asserts.assertEquals(res, testValue1.hash());
2227         res = test82(va, va, testValue1, null, 3, true);
2228         Asserts.assertEquals(va[0].hash(), testValue1.hash());
2229         Asserts.assertEquals(res, testValue1.hash());
2230     }
2231 
2232     @Test(failOn = ALLOC + ALLOCA + STORE)
2233     public static long test83(MyValue1[] va) {
2234         MyValue1.ref[] result = va;
2235         return result[0].hash();
2236     }
2237 
2238     @DontCompile
2239     public void test83_verifier(boolean warmup) {
2240         MyValue1[] va = new MyValue1[42];
2241         va[0] = testValue1;
2242         long res = test83(va);
2243         Asserts.assertEquals(res, testValue1.hash());
2244     }
2245 
<span class="line-modified">2246     @Test(valid = InlineTypeArrayFlattenOn, failOn = ALLOC + LOOP + STORE + TRAP)</span>
<span class="line-modified">2247     @Test(valid = InlineTypeArrayFlattenOff)</span>
2248     public static MyValue1.ref[] test84(MyValue1 vt1, MyValue1.ref vt2) {
2249         MyValue1.ref[] result = new MyValue1[2];
2250         result[0] = vt1;
2251         result[1] = vt2;
2252         return result;
2253     }
2254 
2255     @DontCompile
2256     public void test84_verifier(boolean warmup) {
2257         MyValue1.ref[] res = test84(testValue1, testValue1);
2258         Asserts.assertEquals(res[0].hash(), testValue1.hash());
2259         Asserts.assertEquals(res[1].hash(), testValue1.hash());
2260         try {
2261             test84(testValue1, null);
2262             throw new RuntimeException(&quot;NullPointerException expected&quot;);
2263         } catch (NullPointerException npe) {
2264             // Expected
2265         }
2266     }
2267 
</pre>
</td>
</tr>
</table>
<center><a href="TestArrays.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ValueTypeTest.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
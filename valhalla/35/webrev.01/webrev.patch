diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java
@@ -3998,10 +3998,26 @@
         final int ARRAY_BOUND = 1;
         final int CLASS_BOUND = 2;
 
         int[] kinds = new int[ts.length];
 
+        boolean haveValues = false;
+        boolean haveRefs = false;
+        for (int i = 0 ; i < ts.length ; i++) {
+            if (ts[i].isValue())
+                haveValues = true;
+            else
+                haveRefs = true;
+        }
+        if (haveRefs && haveValues) {
+            System.arraycopy(ts, 0, ts = new Type[ts.length], 0, ts.length);
+            for (int i = 0; i < ts.length; i++) {
+                if (ts[i].isValue())
+                    ts[i] = ts[i].referenceProjection();
+            }
+        }
+
         int boundkind = UNKNOWN_BOUND;
         for (int i = 0 ; i < ts.length ; i++) {
             Type t = ts[i];
             switch (t.getTag()) {
             case CLASS:
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Enter.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Enter.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Enter.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Enter.java
@@ -469,10 +469,14 @@
         // Fill out class fields.
         c.completer = Completer.NULL_COMPLETER; // do not allow the initial completer linger on.
         c.flags_field = chk.checkFlags(tree.pos(), tree.mods.flags, c, tree);
         c.sourcefile = env.toplevel.sourcefile;
         c.members_field = WriteableScope.create(c);
+        if (c.projection != null) {
+            // Do not carry around symbols from prior round.
+            c.projection.members_field = WriteableScope.create(c.projection);
+        }
         c.clearAnnotationMetadata();
 
         ClassType ct = (ClassType)c.type;
         if (owner.kind != PCK && (c.flags_field & STATIC) == 0) {
             // We are seeing a local or inner class.
@@ -490,10 +494,16 @@
         }
 
         // Enter type parameters.
         ct.typarams_field = classEnter(tree.typarams, localEnv);
         ct.allparams_field = null;
+        if (ct.isValue()) {
+            if (ct.projection != null) {
+                ct.projection.typarams_field = ct.typarams_field;
+                ct.projection.allparams_field = ct.allparams_field;
+            }
+        }
 
         // install further completer for this type.
         c.completer = typeEnter;
 
         // Add non-local class to uncompleted, to make sure it will be
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java
@@ -2947,10 +2947,17 @@
                         @Override
                         public Symbol baseSymbol() {
                             return sym;
                         }
                     };
+                    ClassSymbol refProjection = newConstr.owner.isValue() ?
+                                                     (ClassSymbol) newConstr.owner.referenceProjection() : null;
+                    if (refProjection != null) {
+                        MethodSymbol clone = newConstr.clone(refProjection);
+                        clone.projection = newConstr;
+                        newConstr.projection = clone;
+                    }
                     bestSoFar = selectBest(env, site, argtypes, typeargtypes,
                             newConstr,
                             bestSoFar,
                             allowBoxing,
                             useVarargs);
diff a/test/langtools/tools/javac/valhalla/lworld-values/InlineDiamondTest.java b/test/langtools/tools/javac/valhalla/lworld-values/InlineDiamondTest.java
--- /dev/null
+++ b/test/langtools/tools/javac/valhalla/lworld-values/InlineDiamondTest.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8244458 8244414
+ * @summary Diamond inference does not work with value classes
+ * @run main InlineDiamondTest
+ */
+
+public class InlineDiamondTest<E> {
+
+    interface I<T> {
+    }
+
+    public I<E> get() {
+        return new Y<>();
+    }
+
+    private inline class Y<U> implements I<U> {
+        int x = 42;
+    }
+
+    public static void main(String [] args) {
+        InlineDiamondTest<String> idt = new InlineDiamondTest<>();
+        I<String> is = idt.get();
+        String toString = is.toString();
+        if (!toString.equals("[InlineDiamondTest$Y x=42]"))
+            throw new AssertionError("Expected: " + toString);
+    }
+}
diff a/test/langtools/tools/javac/valhalla/lworld-values/LubWithInlines.java b/test/langtools/tools/javac/valhalla/lworld-values/LubWithInlines.java
--- /dev/null
+++ b/test/langtools/tools/javac/valhalla/lworld-values/LubWithInlines.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8244458 8244414
+ * @summary Check that javac does not crash while computing LUB involving values.
+ * @run main LubWithInlines
+ */
+
+public class LubWithInlines {
+    interface I {}
+    static class Node implements I {
+    }
+    static I foo(Node e) {
+        var ret = (e == null) ? new XNodeWrapper() : e;
+        return ret;
+    }
+    static inline class XNodeWrapper implements I {
+        int i = 42;
+    }
+    public static void main(String [] args) {
+        I i = foo(null);
+        if (!i.toString().equals("[LubWithInlines$XNodeWrapper i=42]"))
+            throw new AssertionError("Unexpected: " + i);
+    }
+}
diff a/test/micro/org/openjdk/bench/valhalla/corelibs/mapprotos/XHashMap.java b/test/micro/org/openjdk/bench/valhalla/corelibs/mapprotos/XHashMap.java
--- a/test/micro/org/openjdk/bench/valhalla/corelibs/mapprotos/XHashMap.java
+++ b/test/micro/org/openjdk/bench/valhalla/corelibs/mapprotos/XHashMap.java
@@ -307,13 +307,13 @@
      */
     static inline class XNode<K,V> implements Map.Entry<K,V> {
         final int hash;
         final K key;
         V value;
-        Node?<K,V> next;
+        Node<K,V> next;
 
-        XNode(int hash, K key, V value, Node?<K,V> next) {
+        XNode(int hash, K key, V value, Node<K,V> next) {
             this.hash = hash;
             this.key = key;
             this.value = value;
             this.next = next;
         }
diff a/test/micro/org/openjdk/bench/valhalla/lworld/acmp/IsCmpBranch1.java b/test/micro/org/openjdk/bench/valhalla/lworld/acmp/IsCmpBranch1.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/acmp/IsCmpBranch1.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/acmp/IsCmpBranch1.java
@@ -60,15 +60,15 @@
     Val1[] value1_25, value2_25;
     Val1[] value1_50, value2_50;
     Val1[] value1_75, value2_75;
     Val1[] value1_100, value2_100;
 
-    Val1?[] boxed1_00, boxed2_00;
-    Val1?[] boxed1_25, boxed2_25;
-    Val1?[] boxed1_50, boxed2_50;
-    Val1?[] boxed1_75, boxed2_75;
-    Val1?[] boxed1_100, boxed2_100;
+    Val1.ref[] boxed1_00, boxed2_00;
+    Val1.ref[] boxed1_25, boxed2_25;
+    Val1.ref[] boxed1_50, boxed2_50;
+    Val1.ref[] boxed1_75, boxed2_75;
+    Val1.ref[] boxed1_100, boxed2_100;
 
     Vector[] covariance1_00, covariance2_00;
     Vector[] covariance1_25, covariance2_25;
     Vector[] covariance1_50, covariance2_50;
     Vector[] covariance1_75, covariance2_75;
@@ -85,20 +85,20 @@
         value2_50 = populateValues2(value1_50, 50);
         value1_75 = populateValues1();
         value2_75 = populateValues2(value1_75, 75);
         value1_100 = populateValues1();
         value2_100 = populateValues2(value1_100, 100);
-        boxed1_00 = new Val1?[SIZE];
-        boxed2_00 = new Val1?[SIZE];
-        boxed1_25 = new Val1?[SIZE];
-        boxed2_25 = new Val1?[SIZE];
-        boxed1_50 = new Val1?[SIZE];
-        boxed2_50 = new Val1?[SIZE];
-        boxed1_75 = new Val1?[SIZE];
-        boxed2_75 = new Val1?[SIZE];
-        boxed1_100 = new Val1?[SIZE];
-        boxed2_100 = new Val1?[SIZE];
+        boxed1_00 = new Val1.ref[SIZE];
+        boxed2_00 = new Val1.ref[SIZE];
+        boxed1_25 = new Val1.ref[SIZE];
+        boxed2_25 = new Val1.ref[SIZE];
+        boxed1_50 = new Val1.ref[SIZE];
+        boxed2_50 = new Val1.ref[SIZE];
+        boxed1_75 = new Val1.ref[SIZE];
+        boxed2_75 = new Val1.ref[SIZE];
+        boxed1_100 = new Val1.ref[SIZE];
+        boxed2_100 = new Val1.ref[SIZE];
         for(int i = 0; i< SIZE; i++) {
             boxed1_00[i] = value1_00[i];
             boxed2_00[i] = value2_00[i];
             boxed1_25[i] = value1_25[i];
             boxed2_25[i] = value2_25[i];
@@ -199,11 +199,11 @@
     public int value100() {
         return value_comparison(value1_100, value2_100);
     }
 
     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
-    private static int boxed_comparison(Val1?[] objects1, Val1?[] objects2) {
+    private static int boxed_comparison(Val1.ref[] objects1, Val1.ref[] objects2) {
         int s = 0;
         for (int i = 0; i < SIZE; i++) {
             if (objects1[i] == objects2[i]) {
                 s += 1;
             } else {
diff a/test/micro/org/openjdk/bench/valhalla/lworld/acmp/IsCmpBranch2.java b/test/micro/org/openjdk/bench/valhalla/lworld/acmp/IsCmpBranch2.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/acmp/IsCmpBranch2.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/acmp/IsCmpBranch2.java
@@ -59,15 +59,15 @@
     Val2[] value1_25, value2_25;
     Val2[] value1_50, value2_50;
     Val2[] value1_75, value2_75;
     Val2[] value1_100, value2_100;
 
-    Val2?[] boxed1_00, boxed2_00;
-    Val2?[] boxed1_25, boxed2_25;
-    Val2?[] boxed1_50, boxed2_50;
-    Val2?[] boxed1_75, boxed2_75;
-    Val2?[] boxed1_100, boxed2_100;
+    Val2.ref[] boxed1_00, boxed2_00;
+    Val2.ref[] boxed1_25, boxed2_25;
+    Val2.ref[] boxed1_50, boxed2_50;
+    Val2.ref[] boxed1_75, boxed2_75;
+    Val2.ref[] boxed1_100, boxed2_100;
 
     Vector[] covariance1_00, covariance2_00;
     Vector[] covariance1_25, covariance2_25;
     Vector[] covariance1_50, covariance2_50;
     Vector[] covariance1_75, covariance2_75;
@@ -84,20 +84,20 @@
         value2_50 = populateValues2(value1_50, 50);
         value1_75 = populateValues1();
         value2_75 = populateValues2(value1_75, 75);
         value1_100 = populateValues1();
         value2_100 = populateValues2(value1_100, 100);
-        boxed1_00 = new Val2?[SIZE];
-        boxed2_00 = new Val2?[SIZE];
-        boxed1_25 = new Val2?[SIZE];
-        boxed2_25 = new Val2?[SIZE];
-        boxed1_50 = new Val2?[SIZE];
-        boxed2_50 = new Val2?[SIZE];
-        boxed1_75 = new Val2?[SIZE];
-        boxed2_75 = new Val2?[SIZE];
-        boxed1_100 = new Val2?[SIZE];
-        boxed2_100 = new Val2?[SIZE];
+        boxed1_00 = new Val2.ref[SIZE];
+        boxed2_00 = new Val2.ref[SIZE];
+        boxed1_25 = new Val2.ref[SIZE];
+        boxed2_25 = new Val2.ref[SIZE];
+        boxed1_50 = new Val2.ref[SIZE];
+        boxed2_50 = new Val2.ref[SIZE];
+        boxed1_75 = new Val2.ref[SIZE];
+        boxed2_75 = new Val2.ref[SIZE];
+        boxed1_100 = new Val2.ref[SIZE];
+        boxed2_100 = new Val2.ref[SIZE];
         for(int i = 0; i< SIZE; i++) {
             boxed1_00[i] = value1_00[i];
             boxed2_00[i] = value2_00[i];
             boxed1_25[i] = value1_25[i];
             boxed2_25[i] = value2_25[i];
@@ -198,11 +198,11 @@
     public int value100() {
         return value_comparison(value1_100, value2_100);
     }
 
     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
-    private static int boxed_comparison(Val2?[] objects1, Val2?[] objects2) {
+    private static int boxed_comparison(Val2.ref[] objects1, Val2.ref[] objects2) {
         int s = 0;
         for (int i = 0; i < SIZE; i++) {
             if (objects1[i] == objects2[i]) {
                 s += 1;
             } else {
diff a/test/micro/org/openjdk/bench/valhalla/lworld/acmp/IsCmpBranch8.java b/test/micro/org/openjdk/bench/valhalla/lworld/acmp/IsCmpBranch8.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/acmp/IsCmpBranch8.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/acmp/IsCmpBranch8.java
@@ -59,15 +59,15 @@
     Val8[] value1_25, value2_25;
     Val8[] value1_50, value2_50;
     Val8[] value1_75, value2_75;
     Val8[] value1_100, value2_100;
 
-    Val8?[] boxed1_00, boxed2_00;
-    Val8?[] boxed1_25, boxed2_25;
-    Val8?[] boxed1_50, boxed2_50;
-    Val8?[] boxed1_75, boxed2_75;
-    Val8?[] boxed1_100, boxed2_100;
+    Val8.ref[] boxed1_00, boxed2_00;
+    Val8.ref[] boxed1_25, boxed2_25;
+    Val8.ref[] boxed1_50, boxed2_50;
+    Val8.ref[] boxed1_75, boxed2_75;
+    Val8.ref[] boxed1_100, boxed2_100;
 
     Vector[] covariance1_00, covariance2_00;
     Vector[] covariance1_25, covariance2_25;
     Vector[] covariance1_50, covariance2_50;
     Vector[] covariance1_75, covariance2_75;
@@ -84,20 +84,20 @@
         value2_50 = populateValues2(value1_50, 50);
         value1_75 = populateValues1();
         value2_75 = populateValues2(value1_75, 75);
         value1_100 = populateValues1();
         value2_100 = populateValues2(value1_100, 100);
-        boxed1_00 = new Val8?[SIZE];
-        boxed2_00 = new Val8?[SIZE];
-        boxed1_25 = new Val8?[SIZE];
-        boxed2_25 = new Val8?[SIZE];
-        boxed1_50 = new Val8?[SIZE];
-        boxed2_50 = new Val8?[SIZE];
-        boxed1_75 = new Val8?[SIZE];
-        boxed2_75 = new Val8?[SIZE];
-        boxed1_100 = new Val8?[SIZE];
-        boxed2_100 = new Val8?[SIZE];
+        boxed1_00 = new Val8.ref[SIZE];
+        boxed2_00 = new Val8.ref[SIZE];
+        boxed1_25 = new Val8.ref[SIZE];
+        boxed2_25 = new Val8.ref[SIZE];
+        boxed1_50 = new Val8.ref[SIZE];
+        boxed2_50 = new Val8.ref[SIZE];
+        boxed1_75 = new Val8.ref[SIZE];
+        boxed2_75 = new Val8.ref[SIZE];
+        boxed1_100 = new Val8.ref[SIZE];
+        boxed2_100 = new Val8.ref[SIZE];
         for(int i = 0; i< SIZE; i++) {
             boxed1_00[i] = value1_00[i];
             boxed2_00[i] = value2_00[i];
             boxed1_25[i] = value1_25[i];
             boxed2_25[i] = value2_25[i];
@@ -198,11 +198,11 @@
     public int value100() {
         return value_comparison(value1_100, value2_100);
     }
 
     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
-    private static int boxed_comparison(Val8?[] objects1, Val8?[] objects2) {
+    private static int boxed_comparison(Val8.ref[] objects1, Val8.ref[] objects2) {
         int s = 0;
         for (int i = 0; i < SIZE; i++) {
             if (objects1[i] == objects2[i]) {
                 s += 1;
             } else {
diff a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Arraycopy1.java b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Arraycopy1.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Arraycopy1.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Arraycopy1.java
@@ -13,21 +13,21 @@
     Val1[] dstValue;
 
     Vector[] srcCovariance;
     Vector[] dstCovariance;
 
-    Val1?[] srcBoxed;
-    Val1?[] dstBoxed;
+    Val1.ref[] srcBoxed;
+    Val1.ref[] dstBoxed;
 
     @Setup
     public void setup() {
         srcValue = Utils.fillV(new Val1[size]);
         dstValue = new Val1[size];
         srcCovariance = Utils.fillV(new Val1[size]);
         dstCovariance = new Val1[size];
-        srcBoxed = Utils.fillB(new Val1?[size]);
-        dstBoxed = new Val1?[size];
+        srcBoxed = Utils.fillB(new Val1.ref[size]);
+        dstBoxed = new Val1.ref[size];
     }
 
     @Benchmark
     public void value() {
         System.arraycopy(srcValue, 0, dstValue, 0, size);
diff a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Arraycopy2.java b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Arraycopy2.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Arraycopy2.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Arraycopy2.java
@@ -13,21 +13,21 @@
     Val2[] dstValue;
 
     Vector[] srcCovariance;
     Vector[] dstCovariance;
 
-    Val2?[] srcBoxed;
-    Val2?[] dstBoxed;
+    Val2.ref[] srcBoxed;
+    Val2.ref[] dstBoxed;
 
     @Setup
     public void setup() {
         srcValue = Utils.fillV(new Val2[size]);
         dstValue = new Val2[size];
         srcCovariance = Utils.fillV(new Val2[size]);
         dstCovariance = new Val2[size];
-        srcBoxed = Utils.fillB(new Val2?[size]);
-        dstBoxed = new Val2?[size];
+        srcBoxed = Utils.fillB(new Val2.ref[size]);
+        dstBoxed = new Val2.ref[size];
     }
 
     @Benchmark
     public void value() {
         System.arraycopy(srcValue, 0, dstValue, 0, size);
diff a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Arraycopy8.java b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Arraycopy8.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Arraycopy8.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Arraycopy8.java
@@ -13,21 +13,21 @@
     Val8[] dstValue;
 
     Vector[] srcCovariance;
     Vector[] dstCovariance;
 
-    Val8?[] srcBoxed;
-    Val8?[] dstBoxed;
+    Val8.ref[] srcBoxed;
+    Val8.ref[] dstBoxed;
 
     @Setup
     public void setup() {
         srcValue = Utils.fillV(new Val8[size]);
         dstValue = new Val8[size];
         srcCovariance = Utils.fillV(new Val8[size]);
         dstCovariance = new Val8[size];
-        srcBoxed = Utils.fillB(new Val8?[size]);
-        dstBoxed = new Val8?[size];
+        srcBoxed = Utils.fillB(new Val8.ref[size]);
+        dstBoxed = new Val8.ref[size];
     }
 
     @Benchmark
     public void value() {
         System.arraycopy(srcValue, 0, dstValue, 0, size);
diff a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Copy1.java b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Copy1.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Copy1.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Copy1.java
@@ -13,23 +13,23 @@
     Val1[] dstValue;
 
     Vector[] srcCovariance;
     Vector[] dstCovariance;
 
-    Val1?[] srcBoxed;
-    Val1?[] dstBoxed;
+    Val1.ref[] srcBoxed;
+    Val1.ref[] dstBoxed;
 
 
 
     @Setup
     public void setup() {
         srcValue = Utils.fillV(new Val1[size]);
         dstValue = new Val1[size];
         srcCovariance = Utils.fillV(new Val1[size]);
         dstCovariance = new Val1[size];
-        srcBoxed = Utils.fillB(new Val1?[size]);
-        dstBoxed = new Val1?[size];
+        srcBoxed = Utils.fillB(new Val1.ref[size]);
+        dstBoxed = new Val1.ref[size];
     }
 
     @Benchmark
     public void value() {
         Val1[] s = srcValue;
@@ -48,12 +48,12 @@
         }
     }
 
     @Benchmark
     public void boxed() {
-        Val1?[] s = srcBoxed;
-        Val1?[] d = dstBoxed;
+        Val1.ref[] s = srcBoxed;
+        Val1.ref[] d = dstBoxed;
         for (int i = 0; i < size; i++) {
             d[i] = s[i];
         }
     }
 
diff a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Copy2.java b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Copy2.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Copy2.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Copy2.java
@@ -13,21 +13,21 @@
     Val2[] dstValue;
 
     Vector[] srcCovariance;
     Vector[] dstCovariance;
 
-    Val2?[] srcBoxed;
-    Val2?[] dstBoxed;
+    Val2.ref[] srcBoxed;
+    Val2.ref[] dstBoxed;
 
     @Setup
     public void setup() {
         srcValue = Utils.fillV(new Val2[size]);
         dstValue = new Val2[size];
         srcCovariance = Utils.fillV(new Val2[size]);
         dstCovariance = new Val2[size];
-        srcBoxed = Utils.fillB(new Val2?[size]);
-        dstBoxed = new Val2?[size];
+        srcBoxed = Utils.fillB(new Val2.ref[size]);
+        dstBoxed = new Val2.ref[size];
     }
 
     @Benchmark
     public void value() {
         Val2[] s = srcValue;
@@ -46,12 +46,12 @@
         }
     }
 
     @Benchmark
     public void boxed() {
-        Val2?[] s = srcBoxed;
-        Val2?[] d = dstBoxed;
+        Val2.ref[] s = srcBoxed;
+        Val2.ref[] d = dstBoxed;
         for (int i = 0; i < size; i++) {
             d[i] = s[i];
         }
     }
 }
diff a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Copy8.java b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Copy8.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Copy8.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Copy8.java
@@ -13,21 +13,21 @@
     Val8[] dstValue;
 
     Vector[] srcCovariance;
     Vector[] dstCovariance;
 
-    Val8?[] srcBoxed;
-    Val8?[] dstBoxed;
+    Val8.ref[] srcBoxed;
+    Val8.ref[] dstBoxed;
 
     @Setup
     public void setup() {
         srcValue = Utils.fillV(new Val8[size]);
         dstValue = new Val8[size];
         srcCovariance = Utils.fillV(new Val8[size]);
         dstCovariance = new Val8[size];
-        srcBoxed = Utils.fillB(new Val8?[size]);
-        dstBoxed = new Val8?[size];
+        srcBoxed = Utils.fillB(new Val8.ref[size]);
+        dstBoxed = new Val8.ref[size];
     }
 
     @Benchmark
     public void value() {
         Val8[] s = srcValue;
@@ -46,12 +46,12 @@
         }
     }
 
     @Benchmark
     public void boxed() {
-        Val8?[] s = srcBoxed;
-        Val8?[] d = dstBoxed;
+        Val8.ref[] s = srcBoxed;
+        Val8.ref[] d = dstBoxed;
         for (int i = 0; i < size; i++) {
             d[i] = s[i];
         }
     }
 
diff a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Set1.java b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Set1.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Set1.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Set1.java
@@ -7,24 +7,24 @@
 import org.openjdk.bench.valhalla.types.Vector;
 
 public class Set1 extends SizedBase {
 
     Val1[] values;
-    Val1?[] boxed;
+    Val1.ref[] boxed;
     Vector[] covariance;
 
     @Setup
     public void setup() {
         values = new Val1[size];
-        boxed = new Val1?[size];
+        boxed = new Val1.ref[size];
         covariance = new Val1[size];
     }
 
 
     @Benchmark
     public Object boxed() {
-        Val1?[] values = boxed;
+        Val1.ref[] values = boxed;
         for (int i = 0; i < size; i++) {
             values[i] = new Val1(i);
         }
         return values;
     }
@@ -50,11 +50,11 @@
     /*
      *  Hotspot successfully eliminated GC write barriers in case of assignment to a newly created array.
      */
     @Benchmark
     public Object newBoxed() {
-        Val1?[] values = new Val1?[size];
+        Val1.ref[] values = new Val1.ref[size];
         for (int i = 0; i < size; i++) {
             values[i] = new Val1(i);
         }
         return values;
     }
diff a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Set2.java b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Set2.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Set2.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Set2.java
@@ -7,24 +7,24 @@
 import org.openjdk.bench.valhalla.types.Vector;
 
 public class Set2 extends SizedBase {
 
     Val2[] values;
-    Val2?[] boxed;
+    Val2.ref[] boxed;
     Vector[] covariance;
 
     @Setup
     public void setup() {
         values = new Val2[size];
-        boxed = new Val2?[size];
+        boxed = new Val2.ref[size];
         covariance = new Val2[size];
     }
 
 
     @Benchmark
     public Object boxed() {
-        Val2?[] values = boxed;
+        Val2.ref[] values = boxed;
         for (int i = 0, k = 0; i < size; i++, k += 2) {
             values[i] = new Val2(k, k + 1);
         }
         return values;
     }
@@ -50,11 +50,11 @@
     /*
      *  Hotspot successfully eliminated GC write barriers in case of assignment to a newly created array.
      */
     @Benchmark
     public Object newBoxed() {
-        Val2?[] values = new Val2?[size];
+        Val2.ref[] values = new Val2.ref[size];
         for (int i = 0, k = 0; i < size; i++, k += 2) {
             values[i] = new Val2(k, k + 1);
         }
         return values;
     }
diff a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Set8.java b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Set8.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Set8.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Set8.java
@@ -7,24 +7,24 @@
 import org.openjdk.bench.valhalla.types.Vector;
 
 public class Set8 extends SizedBase {
 
     Val8[] values;
-    Val8?[] boxed;
+    Val8.ref[] boxed;
     Vector[] covariance;
 
     @Setup
     public void setup() {
         values = new Val8[size];
-        boxed = new Val8?[size];
+        boxed = new Val8.ref[size];
         covariance = new Val8[size];
     }
 
 
     @Benchmark
     public Object boxed() {
-        Val8?[] values = boxed;
+        Val8.ref[] values = boxed;
         for (int i = 0, k = 0; i < size; i++, k += 8) {
             values[i] = new Val8(k, k + 1, k + 2, k + 3, k + 4, k + 5, k + 6, k + 7);
         }
         return values;
     }
@@ -50,11 +50,11 @@
     /*
      *  Hotspot successfully eliminated GC write barriers in case of assignment to a newly created array.
      */
     @Benchmark
     public Object newBoxed() {
-        Val8?[] values = new Val8?[size];
+        Val8.ref[] values = new Val8.ref[size];
         for (int i = 0, k = 0; i < size; i++, k += 8) {
             values[i] = new Val8(k, k + 1, k + 2, k + 3, k + 4, k + 5, k + 6, k + 7);
         }
         return values;
     }
diff a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Sum1.java b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Sum1.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Sum1.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Sum1.java
@@ -7,16 +7,16 @@
 import org.openjdk.bench.valhalla.lworld.types.Val1;
 
 public class Sum1 extends SizedBase {
 
     Val1[] values;
-    Val1?[] boxed;
+    Val1.ref[] boxed;
 
     @Setup
     public void setup() {
         values = Utils.fillV(new Val1[size]);
-        boxed = Utils.fillB(new Val1?[size]);
+        boxed = Utils.fillB(new Val1.ref[size]);
     }
 
     @Benchmark
     public int value() {
         Val1[] v = this.values;
@@ -37,21 +37,21 @@
         return sum;
     }
 
     @Benchmark
     public int boxed() {
-        Val1?[] v = this.boxed;
-        Val1? sum = new Val1(0);
+        Val1.ref[] v = this.boxed;
+        Val1.ref sum = new Val1(0);
         for (int i = 0; i < size; i++) {
             sum = sum.add((Val1)v[i]);
         }
         return sum.reduce();
     }
 
     @Benchmark
     public int boxScalarized() {
-        Val1?[] v = this.boxed;
+        Val1.ref[] v = this.boxed;
         int sum = 0;
         for (int i = 0; i < size; i++) {
             sum += v[i].f0;
         }
         return sum;
diff a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Sum2.java b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Sum2.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Sum2.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Sum2.java
@@ -7,16 +7,16 @@
 import org.openjdk.bench.valhalla.lworld.types.Val2;
 
 public class Sum2 extends SizedBase {
 
     Val2[] values;
-    Val2?[] boxed;
+    Val2.ref[] boxed;
 
     @Setup
     public void setup() {
         values = Utils.fillV(new Val2[size]);
-        boxed = Utils.fillB(new Val2?[size]);
+        boxed = Utils.fillB(new Val2.ref[size]);
     }
 
     @Benchmark
     public int value() {
         Val2[] v = this.values;
@@ -39,21 +39,21 @@
         return f0 + f1;
     }
 
     @Benchmark
     public int boxed() {
-        Val2?[] v = this.boxed;
-        Val2? sum = new Val2(0, 0);
+        Val2.ref[] v = this.boxed;
+        Val2.ref sum = new Val2(0, 0);
         for (int i = 0; i < size; i++) {
             sum = sum.add((Val2)v[i]);
         }
         return sum.reduce();
     }
 
     @Benchmark
     public int boxScalarized() {
-        Val2?[] v = this.boxed;
+        Val2.ref[] v = this.boxed;
         int f0 = 0;
         int f1 = 0;
         for (int i = 0; i < size; i++) {
             f0 += v[i].f0;
             f1 += v[i].f1;
diff a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Sum8.java b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Sum8.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Sum8.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/arrays/Sum8.java
@@ -7,16 +7,16 @@
 import org.openjdk.bench.valhalla.lworld.types.Val8;
 
 public class Sum8 extends SizedBase {
 
     Val8[] values;
-    Val8?[] boxed;
+    Val8.ref[] boxed;
 
     @Setup
     public void setup() {
         values = Utils.fillV(new Val8[size]);
-        boxed = Utils.fillB(new Val8?[size]);
+        boxed = Utils.fillB(new Val8.ref[size]);
     }
 
     @Benchmark
     public int value() {
         Val8[] v = this.values;
@@ -51,21 +51,21 @@
         return f0 + f1 + f2 + f3 + f4 + f5 + f6 + f7;
     }
 
     @Benchmark
     public int boxed() {
-        Val8?[] v = this.boxed;
-        Val8? sum = new Val8(0,0,0,0,0,0,0,0);
+        Val8.ref[] v = this.boxed;
+        Val8.ref sum = new Val8(0,0,0,0,0,0,0,0);
         for (int i = 0; i < size; i++) {
             sum = sum.add((Val8)v[i]);
         }
         return sum.reduce();
     }
 
     @Benchmark
     public int boxScalarized() {
-        Val8?[] v = this.boxed;
+        Val8.ref[] v = this.boxed;
         int f0 = 0;
         int f1 = 0;
         int f2 = 0;
         int f3 = 0;
         int f4 = 0;
diff a/test/micro/org/openjdk/bench/valhalla/lworld/callconv/Ackermann1.java b/test/micro/org/openjdk/bench/valhalla/lworld/callconv/Ackermann1.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/callconv/Ackermann1.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/callconv/Ackermann1.java
@@ -43,11 +43,11 @@
         return ack_value(new Val1(X1), new Val1(Y1)).reduce() +
                ack_value(new Val1(X2), new Val1(Y2)).reduce() +
                ack_value(new Val1(X3), new Val1(Y3)).reduce();
     }
 
-    private static Val1? ack_boxed(Val1? x, Val1? y) {
+    private static Val1.ref ack_boxed(Val1.ref x, Val1.ref y) {
         return x.reduce() == 0 ?
                 y.inc() :
                 (y.reduce() == 0 ?
                         ack_boxed(x.dec(), new Val1(1)) :
                         ack_boxed(x.dec(), ack_boxed(x, y.dec())));
diff a/test/micro/org/openjdk/bench/valhalla/lworld/callconv/Ackermann2.java b/test/micro/org/openjdk/bench/valhalla/lworld/callconv/Ackermann2.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/callconv/Ackermann2.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/callconv/Ackermann2.java
@@ -43,11 +43,11 @@
         return ack_value(new Val2(0, X1), new Val2(0, Y1)).reduce() +
                ack_value(new Val2(0, X2), new Val2(0, Y2)).reduce() +
                ack_value(new Val2(0, X3), new Val2(0, Y3)).reduce();
     }
 
-    private static Val2? ack_boxed(Val2? x, Val2? y) {
+    private static Val2.ref ack_boxed(Val2.ref x, Val2.ref y) {
         return x.reduce() == 0 ?
                 y.inc() :
                 (y.reduce() == 0 ?
                         ack_boxed(x.dec(), new Val2(0, 1)) :
                         ack_boxed(x.dec(), ack_boxed(x, y.dec())));
diff a/test/micro/org/openjdk/bench/valhalla/lworld/callconv/Ackermann8.java b/test/micro/org/openjdk/bench/valhalla/lworld/callconv/Ackermann8.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/callconv/Ackermann8.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/callconv/Ackermann8.java
@@ -43,11 +43,11 @@
         return ack_value(new Val8(0, 0, 0, 0, 0, 0, 0, X1), new Val8(0, 0, 0, 0, 0, 0, 0, Y1)).reduce() +
                ack_value(new Val8(0, 0, 0, 0, 0, 0, 0, X2), new Val8(0, 0, 0, 0, 0, 0, 0, Y2)).reduce() +
                ack_value(new Val8(0, 0, 0, 0, 0, 0, 0, X3), new Val8(0, 0, 0, 0, 0, 0, 0, Y3)).reduce();
     }
 
-    private static Val8? ack_boxed(Val8? x, Val8? y) {
+    private static Val8.ref ack_boxed(Val8.ref x, Val8.ref y) {
         return x.reduce() == 0 ?
                 y.inc() :
                 (y.reduce() == 0 ?
                         ack_boxed(x.dec(), new Val8(0, 0, 0, 0, 0, 0, 0, 1)) :
                         ack_boxed(x.dec(), ack_boxed(x, y.dec())));
diff a/test/micro/org/openjdk/bench/valhalla/lworld/callconv/CallConv1.java b/test/micro/org/openjdk/bench/valhalla/lworld/callconv/CallConv1.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/callconv/CallConv1.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/callconv/CallConv1.java
@@ -18,14 +18,14 @@
         }
     }
 
     abstract static class InvocationLogic {
 
-        public abstract Val? computeBox(Val? v1);
-        public abstract Val? computeBox(Val? v1, Val? v2);
-        public abstract Val? computeBox(Val? v1, Val? v2, Val? v3, Val? v4);
-        public abstract Val? computeBox(Val? v1, Val? v2, Val? v3, Val? v4, Val? v5, Val? v6, Val? v7, Val? v8);
+        public abstract Val.ref computeBox(Val.ref v1);
+        public abstract Val.ref computeBox(Val.ref v1, Val.ref v2);
+        public abstract Val.ref computeBox(Val.ref v1, Val.ref v2, Val.ref v3, Val.ref v4);
+        public abstract Val.ref computeBox(Val.ref v1, Val.ref v2, Val.ref v3, Val.ref v4, Val.ref v5, Val.ref v6, Val.ref v7, Val.ref v8);
 
         public abstract Val compute(Val v1);
         public abstract Val compute(Val v1, Val v2);
         public abstract Val compute(Val v1, Val v2, Val v3, Val v4);
         public abstract Val compute(Val v1, Val v2, Val v3, Val v4, Val v5, Val v6, Val v7, Val v8);
@@ -33,26 +33,26 @@
     }
 
     static class InvokeImpl1 extends InvocationLogic {
 
         @Override
-        public Val? computeBox(Val? v1) {
+        public Val.ref computeBox(Val.ref v1) {
             return v1;
         }
 
         @Override
-        public Val? computeBox(Val? v1, Val? v2) {
+        public Val.ref computeBox(Val.ref v1, Val.ref v2) {
             return v1;
         }
 
         @Override
-        public Val? computeBox(Val? v1, Val? v2, Val? v3, Val? v4) {
+        public Val.ref computeBox(Val.ref v1, Val.ref v2, Val.ref v3, Val.ref v4) {
             return v1;
         }
 
         @Override
-        public Val? computeBox(Val? v1, Val? v2, Val? v3, Val? v4, Val? v5, Val? v6, Val? v7, Val? v8) {
+        public Val.ref computeBox(Val.ref v1, Val.ref v2, Val.ref v3, Val.ref v4, Val.ref v5, Val.ref v6, Val.ref v7, Val.ref v8) {
             return v1;
         }
 
         @Override
         public Val compute(Val v1) {
@@ -77,26 +77,26 @@
     }
 
     static class InvokeImpl2 extends InvocationLogic {
 
         @Override
-        public Val? computeBox(Val? v1) {
+        public Val.ref computeBox(Val.ref v1) {
             return v1;
         }
 
         @Override
-        public Val? computeBox(Val? v1, Val? v2) {
+        public Val.ref computeBox(Val.ref v1, Val.ref v2) {
             return v1;
         }
 
         @Override
-        public Val? computeBox(Val? v1, Val? v2, Val? v3, Val? v4) {
+        public Val.ref computeBox(Val.ref v1, Val.ref v2, Val.ref v3, Val.ref v4) {
             return v1;
         }
 
         @Override
-        public Val? computeBox(Val? v1, Val? v2, Val? v3, Val? v4, Val? v5, Val? v6, Val? v7, Val? v8) {
+        public Val.ref computeBox(Val.ref v1, Val.ref v2, Val.ref v3, Val.ref v4, Val.ref v5, Val.ref v6, Val.ref v7, Val.ref v8) {
             return v1;
         }
 
         @Override
         public Val compute(Val v1) {
@@ -121,26 +121,26 @@
     }
 
     static class InvokeImpl3 extends InvocationLogic {
 
         @Override
-        public Val? computeBox(Val? v1) {
+        public Val.ref computeBox(Val.ref v1) {
             return v1;
         }
 
         @Override
-        public Val? computeBox(Val? v1, Val? v2) {
+        public Val.ref computeBox(Val.ref v1, Val.ref v2) {
             return v1;
         }
 
         @Override
-        public Val? computeBox(Val? v1, Val? v2, Val? v3, Val? v4) {
+        public Val.ref computeBox(Val.ref v1, Val.ref v2, Val.ref v3, Val.ref v4) {
             return v1;
         }
 
         @Override
-        public Val? computeBox(Val? v1, Val? v2, Val? v3, Val? v4, Val? v5, Val? v6, Val? v7, Val? v8) {
+        public Val.ref computeBox(Val.ref v1, Val.ref v2, Val.ref v3, Val.ref v4, Val.ref v5, Val.ref v6, Val.ref v7, Val.ref v8) {
             return v1;
         }
 
         @Override
         public Val compute(Val v1) {
@@ -201,18 +201,18 @@
             }
         }
         return logic;
     }
 
-    Val? b1 = new Val(42);
-    Val? b2 = new Val(43);
-    Val? b3 = new Val(44);
-    Val? b4 = new Val(45);
-    Val? b5 = new Val(46);
-    Val? b6 = new Val(47);
-    Val? b7 = new Val(48);
-    Val? b8 = new Val(49);
+    Val.ref b1 = new Val(42);
+    Val.ref b2 = new Val(43);
+    Val.ref b3 = new Val(44);
+    Val.ref b4 = new Val(45);
+    Val.ref b5 = new Val(46);
+    Val.ref b6 = new Val(47);
+    Val.ref b7 = new Val(48);
+    Val.ref b8 = new Val(49);
 
     @CompilerControl(CompilerControl.Mode.INLINE)
     public int boxed1(InvocationLogic[] logic) {
         int r = 0;
         for(InvocationLogic t : logic) {
@@ -491,6 +491,6 @@
     @OperationsPerInvocation(SIZE)
     public int value_args8_targets3() {
         return value8(logic3);
     }
 
-}
+}
diff a/test/micro/org/openjdk/bench/valhalla/lworld/fields/NodeBox1.java b/test/micro/org/openjdk/bench/valhalla/lworld/fields/NodeBox1.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/fields/NodeBox1.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/fields/NodeBox1.java
@@ -1,11 +1,11 @@
 package org.openjdk.bench.valhalla.lworld.fields;
 
 import org.openjdk.bench.valhalla.lworld.types.Val1;
 
 public class NodeBox1 {
-    public Val1? f;
+    public Val1.ref f;
 
     public static NodeBox1[] set(NodeBox1[] a) {
         for (int i = 0; i < a.length; i++) {
             a[i] = new NodeBox1();
         }
diff a/test/micro/org/openjdk/bench/valhalla/lworld/fields/NodeBox2.java b/test/micro/org/openjdk/bench/valhalla/lworld/fields/NodeBox2.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/fields/NodeBox2.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/fields/NodeBox2.java
@@ -1,11 +1,11 @@
 package org.openjdk.bench.valhalla.lworld.fields;
 
 import org.openjdk.bench.valhalla.lworld.types.Val2;
 
 public class NodeBox2 {
-    public Val2? f;
+    public Val2.ref f;
 
     public static NodeBox2[] set(NodeBox2[] a) {
         for (int i = 0; i < a.length; i++) {
             a[i] = new NodeBox2();
         }
diff a/test/micro/org/openjdk/bench/valhalla/lworld/fields/NodeBox8.java b/test/micro/org/openjdk/bench/valhalla/lworld/fields/NodeBox8.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/fields/NodeBox8.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/fields/NodeBox8.java
@@ -1,11 +1,11 @@
 package org.openjdk.bench.valhalla.lworld.fields;
 
 import org.openjdk.bench.valhalla.lworld.types.Val8;
 
 public class NodeBox8 {
-    public Val8? f;
+    public Val8.ref f;
 
     public static NodeBox8[] set(NodeBox8[] a) {
         for (int i = 0; i < a.length; i++) {
             a[i] = new NodeBox8();
         }
diff a/test/micro/org/openjdk/bench/valhalla/lworld/fields/Sum1.java b/test/micro/org/openjdk/bench/valhalla/lworld/fields/Sum1.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/fields/Sum1.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/fields/Sum1.java
@@ -37,11 +37,11 @@
     }
 
     @Benchmark
     public int boxed() {
         NodeBox1[] v = this.boxed;
-        Val1? sum = new Val1(0);
+        Val1.ref sum = new Val1(0);
         for (int i = 0; i < size; i++) {
             sum = sum.add((Val1)v[i].f);
         }
         return sum.reduce();
     }
diff a/test/micro/org/openjdk/bench/valhalla/lworld/fields/Sum2.java b/test/micro/org/openjdk/bench/valhalla/lworld/fields/Sum2.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/fields/Sum2.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/fields/Sum2.java
@@ -40,11 +40,11 @@
     }
 
     @Benchmark
     public int boxed() {
         NodeBox2[] v = this.boxed;
-        Val2? sum = new Val2(0, 0);
+        Val2.ref sum = new Val2(0, 0);
         for (int i = 0; i < size; i++) {
             sum = sum.add((Val2)v[i].f);
         }
         return sum.reduce();
     }
diff a/test/micro/org/openjdk/bench/valhalla/lworld/fields/Sum8.java b/test/micro/org/openjdk/bench/valhalla/lworld/fields/Sum8.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/fields/Sum8.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/fields/Sum8.java
@@ -52,11 +52,11 @@
     }
 
     @Benchmark
     public int boxed() {
         NodeBox8[] v = this.boxed;
-        Val8? sum = new Val8(0,0,0,0,0,0,0,0);
+        Val8.ref sum = new Val8(0,0,0,0,0,0,0,0);
         for (int i = 0; i < size; i++) {
             sum = sum.add((Val8)v[i].f);
         }
         return sum.reduce();
     }
diff a/test/micro/org/openjdk/bench/valhalla/lworld/invoke/ObjectHashCodeExplicit.java b/test/micro/org/openjdk/bench/valhalla/lworld/invoke/ObjectHashCodeExplicit.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/invoke/ObjectHashCodeExplicit.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/invoke/ObjectHashCodeExplicit.java
@@ -43,13 +43,13 @@
 
 
     Val1[] values1;
     Val2[] values2;
     Val3[] values3;
-    Val1?[] boxed1;
-    Val2?[] boxed2;
-    Val3?[] boxed3;
+    Val1.ref[] boxed1;
+    Val2.ref[] boxed2;
+    Val3.ref[] boxed3;
 
     @Setup
     public void setup() {
         values1 = new Val1[SIZE];
         for (int i = 0; i < SIZE; i++) {
@@ -61,19 +61,19 @@
         }
         values3 = new Val3[SIZE];
         for (int i = 0; i < SIZE; i++) {
             values3[i] = new Val3(42);
         }
-        boxed1 = new Val1?[SIZE];
+        boxed1 = new Val1.ref[SIZE];
         for (int i = 0; i < SIZE; i++) {
             boxed1[i] = new Val1(42);
         }
-        boxed2 = new Val2?[SIZE];
+        boxed2 = new Val2.ref[SIZE];
         for (int i = 0; i < SIZE; i++) {
             boxed2[i] = new Val2(42);
         }
-        boxed3 = new Val3?[SIZE];
+        boxed3 = new Val3.ref[SIZE];
         for (int i = 0; i < SIZE; i++) {
             boxed3[i] = new Val3(42);
         }
     }
 
@@ -95,13 +95,13 @@
         }
         return r;
     }
 
     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
-    public int hashExactBoxed(Val1?[] arr) {
+    public int hashExactBoxed(Val1.ref[] arr) {
         int r = 0;
-        for(Val1? o : arr) {
+        for(Val1.ref o : arr) {
             r += o.hashCode();
         }
         return r;
     }
 
@@ -200,6 +200,6 @@
                 hashObject(values2) +
                 hashObject(values3) ;
     }
 
 
-}
+}
diff a/test/micro/org/openjdk/bench/valhalla/lworld/invoke/ObjectHashCodeImplicit.java b/test/micro/org/openjdk/bench/valhalla/lworld/invoke/ObjectHashCodeImplicit.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/invoke/ObjectHashCodeImplicit.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/invoke/ObjectHashCodeImplicit.java
@@ -31,13 +31,13 @@
 
 
     Val1[] values1;
     Val2[] values2;
     Val3[] values3;
-    Val1?[] boxed1;
-    Val2?[] boxed2;
-    Val3?[] boxed3;
+    Val1.ref[] boxed1;
+    Val2.ref[] boxed2;
+    Val3.ref[] boxed3;
 
     @Setup
     public void setup() {
         values1 = new Val1[SIZE];
         for (int i = 0; i < SIZE; i++) {
@@ -49,19 +49,19 @@
         }
         values3 = new Val3[SIZE];
         for (int i = 0; i < SIZE; i++) {
             values3[i] = new Val3(42);
         }
-        boxed1 = new Val1?[SIZE];
+        boxed1 = new Val1.ref[SIZE];
         for (int i = 0; i < SIZE; i++) {
             boxed1[i] = new Val1(42);
         }
-        boxed2 = new Val2?[SIZE];
+        boxed2 = new Val2.ref[SIZE];
         for (int i = 0; i < SIZE; i++) {
             boxed2[i] = new Val2(42);
         }
-        boxed3 = new Val3?[SIZE];
+        boxed3 = new Val3.ref[SIZE];
         for (int i = 0; i < SIZE; i++) {
             boxed3[i] = new Val3(42);
         }
     }
 
@@ -83,13 +83,13 @@
         }
         return r;
     }
 
     @CompilerControl(CompilerControl.Mode.DONT_INLINE)
-    public int hashExactBoxed(Val1?[] arr) {
+    public int hashExactBoxed(Val1.ref[] arr) {
         int r = 0;
-        for(Val1? o : arr) {
+        for(Val1.ref o : arr) {
             r += o.hashCode();
         }
         return r;
     }
 
@@ -188,6 +188,6 @@
                 hashObject(values2) +
                 hashObject(values3) ;
     }
 
 
-}
+}
diff a/test/micro/org/openjdk/bench/valhalla/lworld/matrix/Boxed.java b/test/micro/org/openjdk/bench/valhalla/lworld/matrix/Boxed.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/matrix/Boxed.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/matrix/Boxed.java
@@ -9,33 +9,33 @@
 import java.util.concurrent.ThreadLocalRandom;
 
 
 public class Boxed extends MatrixBase {
 
-    Complex?[][] A;
-    Complex?[][] B;
+    Complex.ref[][] A;
+    Complex.ref[][] B;
 
     @Setup
     public void setup() {
-        A = populate(new Complex?[size][size]);
-        B = populate(new Complex?[size][size]);
+        A = populate(new Complex.ref[size][size]);
+        B = populate(new Complex.ref[size][size]);
     }
 
-    private Complex?[][] populate(Complex?[][] m) {
+    private Complex.ref[][] populate(Complex.ref[][] m) {
         int size = m.length;
         for (int i = 0; i < size; i++) {
             for (int j = 0; j < size; j++) {
                 m[i][j] = new Complex(ThreadLocalRandom.current().nextDouble(), ThreadLocalRandom.current().nextDouble());
             }
         }
         return m;
     }
 
     @Benchmark
-    public Complex?[][] multiply() {
+    public Complex.ref[][] multiply() {
         int size = A.length;
-        Complex?[][] R = new Complex?[size][size];
+        Complex.ref[][] R = new Complex.ref[size][size];
         for (int i = 0; i < size; i++) {
             for (int j = 0; j < size; j++) {
                 Complex s = Complex.H.ZERO;
                 for (int k = 0; k < size; k++) {
                     s = s.add(A[i][k].mul((Complex)B[k][j]));
@@ -45,39 +45,39 @@
         }
         return R;
     }
 
     @Benchmark
-    public Complex?[][] multiplyCacheFriendly() {
+    public Complex.ref[][] multiplyCacheFriendly() {
         int size = A.length;
-        Complex?[][] R = new Complex?[size][size];
+        Complex.ref[][] R = new Complex.ref[size][size];
         for (int i = 0; i < size; i++) {
             Arrays.fill(R[i], Complex.H.ZERO);
         }
         for (int i = 0; i < size; i++) {
             for (int k = 0; k < size; k++) {
-                Complex? aik = A[i][k];
+                Complex.ref aik = A[i][k];
                 for (int j = 0; j < size; j++) {
                     R[i][j] = R[i][j].add(aik.mul((Complex)B[k][j]));
                 }
             }
         }
         return R;
     }
 
     @Benchmark
-    public Complex?[][] multiplyCacheFriendly1() {
+    public Complex.ref[][] multiplyCacheFriendly1() {
         int size = A.length;
-        Complex?[][] R = new Complex?[size][size];
+        Complex.ref[][] R = new Complex.ref[size][size];
         for (int i = 0; i < size; i++) {
             for (int j = 0; j < size; j++) {
                 R[i][j] = Complex.H.ZERO;
             }
         }
         for (int i = 0; i < size; i++) {
             for (int k = 0; k < size; k++) {
-                Complex? aik = A[i][k];
+                Complex.ref aik = A[i][k];
                 for (int j = 0; j < size; j++) {
                     R[i][j] = R[i][j].add(aik.mul((Complex)B[k][j]));
                 }
             }
         }
diff a/test/micro/org/openjdk/bench/valhalla/lworld/traversal/Boxed.java b/test/micro/org/openjdk/bench/valhalla/lworld/traversal/Boxed.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/traversal/Boxed.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/traversal/Boxed.java
@@ -7,21 +7,21 @@
 import org.openjdk.bench.valhalla.TraversalBase;
 import org.openjdk.bench.valhalla.lworld.types.Val1;
 
 public abstract class Boxed extends TraversalBase {
 
-    Val1?[] values;
+    Val1.ref[] values;
 
     public void setup(int[] a) {
-        values = new Val1?[a.length];
+        values = new Val1.ref[a.length];
         for (int i = 0; i < a.length; i++) {
             values[i] = new Val1(a[i]);
         }
     }
 
     @CompilerControl(CompilerControl.Mode.INLINE)
-    public static int walk(Val1?[] a) {
+    public static int walk(Val1.ref[] a) {
         int steps = 0;
         for(int i = a[0].reduce(); i!=0; i=a[i].reduce()) steps++;
         return steps;
     }
 
diff a/test/micro/org/openjdk/bench/valhalla/lworld/types/Utils.java b/test/micro/org/openjdk/bench/valhalla/lworld/types/Utils.java
--- a/test/micro/org/openjdk/bench/valhalla/lworld/types/Utils.java
+++ b/test/micro/org/openjdk/bench/valhalla/lworld/types/Utils.java
@@ -8,11 +8,11 @@
             a[i] = new Val1(i);
         }
         return a;
     }
 
-    public static Val1?[] fillB(Val1?[] a) {
+    public static Val1.ref[] fillB(Val1.ref[] a) {
         for (int i = 0; i < a.length; i++) {
             a[i] = new Val1(i);
         }
         return a;
     }
@@ -22,11 +22,11 @@
             a[i] = new Val2(k, k + 1);
         }
         return a;
     }
 
-    public static Val2?[] fillB(Val2?[] a) {
+    public static Val2.ref[] fillB(Val2.ref[] a) {
         for (int i = 0, k = 0; i < a.length; i++, k += 2) {
             a[i] = new Val2(k, k + 1);
         }
         return a;
     }
@@ -36,11 +36,11 @@
             a[i] = new Val8(k, k + 1, k + 2, k + 3, k + 4, k + 5, k + 6, k + 7);
         }
         return a;
     }
 
-    public static Val8?[] fillB(Val8?[] a) {
+    public static Val8.ref[] fillB(Val8.ref[] a) {
         for (int i = 0, k = 0; i < a.length; i++, k += 8) {
             a[i] = new Val8(k, k + 1, k + 2, k + 3, k + 4, k + 5, k + 6, k + 7);
         }
         return a;
     }

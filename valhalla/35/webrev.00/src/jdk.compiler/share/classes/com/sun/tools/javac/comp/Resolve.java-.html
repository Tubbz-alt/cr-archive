<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Resolve.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import com.sun.tools.javac.api.Formattable.LocalizedString;
  29 import com.sun.tools.javac.code.*;
  30 import com.sun.tools.javac.code.Scope.WriteableScope;
  31 import com.sun.tools.javac.code.Source.Feature;
  32 import com.sun.tools.javac.code.Symbol.*;
  33 import com.sun.tools.javac.code.Type.*;
  34 import com.sun.tools.javac.comp.Attr.ResultInfo;
  35 import com.sun.tools.javac.comp.Check.CheckContext;
  36 import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
  37 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
  38 import com.sun.tools.javac.comp.DeferredAttr.DeferredType;
  39 import com.sun.tools.javac.comp.Resolve.MethodResolutionContext.Candidate;
  40 import com.sun.tools.javac.comp.Resolve.MethodResolutionDiagHelper.Template;
  41 import com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind;
  42 import com.sun.tools.javac.jvm.*;
  43 import com.sun.tools.javac.main.Option;
  44 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  45 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  46 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  47 import com.sun.tools.javac.tree.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
  50 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  51 import com.sun.tools.javac.util.*;
  52 import com.sun.tools.javac.util.DefinedBy.Api;
  53 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  54 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  55 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticType;
  56 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  57 
  58 import java.util.Arrays;
  59 import java.util.Collection;
  60 import java.util.EnumSet;
  61 import java.util.HashSet;
  62 import java.util.Iterator;
  63 import java.util.LinkedHashMap;
  64 import java.util.Map;
  65 import java.util.Set;
  66 import java.util.function.BiFunction;
  67 import java.util.function.BiPredicate;
  68 import java.util.function.Consumer;
  69 import java.util.function.Function;
  70 import java.util.function.Predicate;
  71 import java.util.stream.Stream;
  72 
  73 import javax.lang.model.element.ElementVisitor;
  74 
  75 import static com.sun.tools.javac.code.Flags.*;
  76 import static com.sun.tools.javac.code.Flags.BLOCK;
  77 import static com.sun.tools.javac.code.Flags.STATIC;
  78 import static com.sun.tools.javac.code.Kinds.*;
  79 import static com.sun.tools.javac.code.Kinds.Kind.*;
  80 import static com.sun.tools.javac.code.TypeTag.*;
  81 import static com.sun.tools.javac.comp.Resolve.MethodResolutionPhase.*;
  82 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  83 import static com.sun.tools.javac.util.Iterators.createCompoundIterator;
  84 
  85 /** Helper class for name resolution, used mostly by the attribution phase.
  86  *
  87  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  88  *  If you write code that depends on this, you do so at your own risk.
  89  *  This code and its internal interfaces are subject to change or
  90  *  deletion without notice.&lt;/b&gt;
  91  */
  92 public class Resolve {
  93     protected static final Context.Key&lt;Resolve&gt; resolveKey = new Context.Key&lt;&gt;();
  94 
  95     Names names;
  96     Log log;
  97     Symtab syms;
  98     Attr attr;
  99     DeferredAttr deferredAttr;
 100     Check chk;
 101     Infer infer;
 102     ClassFinder finder;
 103     ModuleFinder moduleFinder;
 104     Types types;
 105     JCDiagnostic.Factory diags;
 106     public final boolean allowFunctionalInterfaceMostSpecific;
 107     public final boolean allowModules;
 108     public final boolean checkVarargsAccessAfterResolution;
 109     private final boolean compactMethodDiags;
 110     private final boolean allowLocalVariableTypeInference;
 111     private final boolean allowYieldStatement;
 112     final EnumSet&lt;VerboseResolutionMode&gt; verboseResolutionMode;
 113 
 114     WriteableScope polymorphicSignatureScope;
 115 
 116     protected Resolve(Context context) {
 117         context.put(resolveKey, this);
 118         syms = Symtab.instance(context);
 119 
 120         varNotFound = new SymbolNotFoundError(ABSENT_VAR);
 121         methodNotFound = new SymbolNotFoundError(ABSENT_MTH);
 122         typeNotFound = new SymbolNotFoundError(ABSENT_TYP);
 123         referenceNotFound = ReferenceLookupResult.error(methodNotFound);
 124 
 125         names = Names.instance(context);
 126         log = Log.instance(context);
 127         attr = Attr.instance(context);
 128         deferredAttr = DeferredAttr.instance(context);
 129         chk = Check.instance(context);
 130         infer = Infer.instance(context);
 131         finder = ClassFinder.instance(context);
 132         moduleFinder = ModuleFinder.instance(context);
 133         types = Types.instance(context);
 134         diags = JCDiagnostic.Factory.instance(context);
 135         Preview preview = Preview.instance(context);
 136         Source source = Source.instance(context);
 137         Options options = Options.instance(context);
 138         compactMethodDiags = options.isSet(Option.XDIAGS, &quot;compact&quot;) ||
 139                 options.isUnset(Option.XDIAGS) &amp;&amp; options.isUnset(&quot;rawDiagnostics&quot;);
 140         verboseResolutionMode = VerboseResolutionMode.getVerboseResolutionMode(options);
 141         Target target = Target.instance(context);
 142         allowFunctionalInterfaceMostSpecific = Feature.FUNCTIONAL_INTERFACE_MOST_SPECIFIC.allowedInSource(source);
 143         allowLocalVariableTypeInference = Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source);
 144         allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 145                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 146         checkVarargsAccessAfterResolution =
 147                 Feature.POST_APPLICABILITY_VARARGS_ACCESS_CHECK.allowedInSource(source);
 148         polymorphicSignatureScope = WriteableScope.create(syms.noSymbol);
 149         allowModules = Feature.MODULES.allowedInSource(source);
 150     }
 151 
 152     /** error symbols, which are returned when resolution fails
 153      */
 154     private final SymbolNotFoundError varNotFound;
 155     private final SymbolNotFoundError methodNotFound;
 156     private final SymbolNotFoundError typeNotFound;
 157 
 158     /** empty reference lookup result */
 159     private final ReferenceLookupResult referenceNotFound;
 160 
 161     public static Resolve instance(Context context) {
 162         Resolve instance = context.get(resolveKey);
 163         if (instance == null)
 164             instance = new Resolve(context);
 165         return instance;
 166     }
 167 
 168     private static Symbol bestOf(Symbol s1,
 169                                  Symbol s2) {
 170         return s1.kind.betterThan(s2.kind) ? s1 : s2;
 171     }
 172 
 173     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Verbose resolution diagnostics support&quot;&gt;
 174     enum VerboseResolutionMode {
 175         SUCCESS(&quot;success&quot;),
 176         FAILURE(&quot;failure&quot;),
 177         APPLICABLE(&quot;applicable&quot;),
 178         INAPPLICABLE(&quot;inapplicable&quot;),
 179         DEFERRED_INST(&quot;deferred-inference&quot;),
 180         PREDEF(&quot;predef&quot;),
 181         OBJECT_INIT(&quot;object-init&quot;),
 182         INTERNAL(&quot;internal&quot;);
 183 
 184         final String opt;
 185 
 186         private VerboseResolutionMode(String opt) {
 187             this.opt = opt;
 188         }
 189 
 190         static EnumSet&lt;VerboseResolutionMode&gt; getVerboseResolutionMode(Options opts) {
 191             String s = opts.get(&quot;debug.verboseResolution&quot;);
 192             EnumSet&lt;VerboseResolutionMode&gt; res = EnumSet.noneOf(VerboseResolutionMode.class);
 193             if (s == null) return res;
 194             if (s.contains(&quot;all&quot;)) {
 195                 res = EnumSet.allOf(VerboseResolutionMode.class);
 196             }
 197             Collection&lt;String&gt; args = Arrays.asList(s.split(&quot;,&quot;));
 198             for (VerboseResolutionMode mode : values()) {
 199                 if (args.contains(mode.opt)) {
 200                     res.add(mode);
 201                 } else if (args.contains(&quot;-&quot; + mode.opt)) {
 202                     res.remove(mode);
 203                 }
 204             }
 205             return res;
 206         }
 207     }
 208 
 209     void reportVerboseResolutionDiagnostic(DiagnosticPosition dpos, Name name, Type site,
 210             List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, Symbol bestSoFar) {
 211         boolean success = !bestSoFar.kind.isResolutionError();
 212 
 213         if (success &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.SUCCESS)) {
 214             return;
 215         } else if (!success &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.FAILURE)) {
 216             return;
 217         }
 218 
 219         if (bestSoFar.name == names.init &amp;&amp;
 220                 bestSoFar.owner == syms.objectType.tsym &amp;&amp;
 221                 !verboseResolutionMode.contains(VerboseResolutionMode.OBJECT_INIT)) {
 222             return; //skip diags for Object constructor resolution
 223         } else if (site == syms.predefClass.type &amp;&amp;
 224                 !verboseResolutionMode.contains(VerboseResolutionMode.PREDEF)) {
 225             return; //skip spurious diags for predef symbols (i.e. operators)
 226         } else if (currentResolutionContext.internalResolution &amp;&amp;
 227                 !verboseResolutionMode.contains(VerboseResolutionMode.INTERNAL)) {
 228             return;
 229         }
 230 
 231         int pos = 0;
 232         int mostSpecificPos = -1;
 233         ListBuffer&lt;JCDiagnostic&gt; subDiags = new ListBuffer&lt;&gt;();
 234         for (Candidate c : currentResolutionContext.candidates) {
 235             if (currentResolutionContext.step != c.step ||
 236                     (c.isApplicable() &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.APPLICABLE)) ||
 237                     (!c.isApplicable() &amp;&amp; !verboseResolutionMode.contains(VerboseResolutionMode.INAPPLICABLE))) {
 238                 continue;
 239             } else {
 240                 subDiags.append(c.isApplicable() ?
 241                         getVerboseApplicableCandidateDiag(pos, c.sym, c.mtype) :
 242                         getVerboseInapplicableCandidateDiag(pos, c.sym, c.details));
 243                 if (c.sym == bestSoFar)
 244                     mostSpecificPos = pos;
 245                 pos++;
 246             }
 247         }
 248         String key = success ? &quot;verbose.resolve.multi&quot; : &quot;verbose.resolve.multi.1&quot;;
 249         List&lt;Type&gt; argtypes2 = argtypes.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.SPECULATIVE, bestSoFar, currentResolutionContext.step));
 250         JCDiagnostic main = diags.note(log.currentSource(), dpos, key, name,
 251                 site.tsym, mostSpecificPos, currentResolutionContext.step,
 252                 methodArguments(argtypes2),
 253                 methodArguments(typeargtypes));
 254         JCDiagnostic d = new JCDiagnostic.MultilineDiagnostic(main, subDiags.toList());
 255         log.report(d);
 256     }
 257 
 258     JCDiagnostic getVerboseApplicableCandidateDiag(int pos, Symbol sym, Type inst) {
 259         JCDiagnostic subDiag = null;
 260         if (sym.type.hasTag(FORALL)) {
 261             subDiag = diags.fragment(Fragments.PartialInstSig(inst));
 262         }
 263 
 264         String key = subDiag == null ?
 265                 &quot;applicable.method.found&quot; :
 266                 &quot;applicable.method.found.1&quot;;
 267 
 268         return diags.fragment(key, pos, sym, subDiag);
 269     }
 270 
 271     JCDiagnostic getVerboseInapplicableCandidateDiag(int pos, Symbol sym, JCDiagnostic subDiag) {
 272         return diags.fragment(Fragments.NotApplicableMethodFound(pos, sym, subDiag));
 273     }
 274     // &lt;/editor-fold&gt;
 275 
 276 /* ************************************************************************
 277  * Identifier resolution
 278  *************************************************************************/
 279 
 280     /** An environment is &quot;static&quot; if its static level is greater than
 281      *  the one of its outer environment
 282      */
 283     protected static boolean isStatic(Env&lt;AttrContext&gt; env) {
 284         return env.outer != null &amp;&amp; env.info.staticLevel &gt; env.outer.info.staticLevel;
 285     }
 286 
 287     /** An environment is an &quot;initializer&quot; if it is a constructor or
 288      *  an instance initializer.
 289      */
 290     static boolean isInitializer(Env&lt;AttrContext&gt; env) {
 291         Symbol owner = env.info.scope.owner;
 292         return owner.isConstructor() ||
 293             owner.owner.kind == TYP &amp;&amp;
 294             (owner.kind == VAR ||
 295              owner.kind == MTH &amp;&amp; (owner.flags() &amp; BLOCK) != 0) &amp;&amp;
 296             (owner.flags() &amp; STATIC) == 0;
 297     }
 298 
 299     /** Is class accessible in given environment?
 300      *  @param env    The current environment.
 301      *  @param c      The class whose accessibility is checked.
 302      */
 303     public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c) {
 304         return isAccessible(env, c, false);
 305     }
 306 
 307     public boolean isAccessible(Env&lt;AttrContext&gt; env, TypeSymbol c, boolean checkInner) {
 308 
 309         /* 15.9.5.1: Note that it is possible for the signature of the anonymous constructor
 310            to refer to an inaccessible type
 311         */
 312         if (env.enclMethod != null &amp;&amp; (env.enclMethod.mods.flags &amp; ANONCONSTR) != 0)
 313             return true;
 314 
 315         if (env.info.visitingServiceImplementation &amp;&amp;
 316             env.toplevel.modle == c.packge().modle) {
 317             return true;
 318         }
 319 
 320         boolean isAccessible = false;
 321         switch ((short)(c.flags() &amp; AccessFlags)) {
 322             case PRIVATE:
 323                 isAccessible =
 324                     env.enclClass.sym.outermostClass() ==
 325                     c.owner.outermostClass();
 326                 break;
 327             case 0:
 328                 isAccessible =
 329                     env.toplevel.packge == c.owner // fast special case
 330                     ||
 331                     env.toplevel.packge == c.packge();
 332                 break;
 333             default: // error recovery
 334                 isAccessible = true;
 335                 break;
 336             case PUBLIC:
 337                 if (allowModules) {
 338                     ModuleSymbol currModule = env.toplevel.modle;
 339                     currModule.complete();
 340                     PackageSymbol p = c.packge();
 341                     isAccessible =
 342                         currModule == p.modle ||
 343                         currModule.visiblePackages.get(p.fullname) == p ||
 344                         p == syms.rootPackage ||
 345                         (p.modle == syms.unnamedModule &amp;&amp; currModule.readModules.contains(p.modle));
 346                 } else {
 347                     isAccessible = true;
 348                 }
 349                 break;
 350             case PROTECTED:
 351                 isAccessible =
 352                     env.toplevel.packge == c.owner // fast special case
 353                     ||
 354                     env.toplevel.packge == c.packge()
 355                     ||
 356                     isInnerSubClass(env.enclClass.sym, c.owner);
 357                 break;
 358         }
 359         return (checkInner == false || c.type.getEnclosingType() == Type.noType) ?
 360             isAccessible :
 361             isAccessible &amp;&amp; isAccessible(env, c.type.getEnclosingType(), checkInner);
 362     }
 363     //where
 364         /** Is given class a subclass of given base class, or an inner class
 365          *  of a subclass?
 366          *  Return null if no such class exists.
 367          *  @param c     The class which is the subclass or is contained in it.
 368          *  @param base  The base class
 369          */
 370         private boolean isInnerSubClass(ClassSymbol c, Symbol base) {
 371             while (c != null &amp;&amp; !c.isSubClass(base, types)) {
 372                 c = c.owner.enclClass();
 373             }
 374             return c != null;
 375         }
 376 
 377     boolean isAccessible(Env&lt;AttrContext&gt; env, Type t) {
 378         return isAccessible(env, t, false);
 379     }
 380 
 381     boolean isAccessible(Env&lt;AttrContext&gt; env, Type t, boolean checkInner) {
 382         return (t.hasTag(ARRAY))
 383             ? isAccessible(env, types.cvarUpperBound(types.elemtype(t)))
 384             : isAccessible(env, t.tsym, checkInner);
 385     }
 386 
 387     /** Is symbol accessible as a member of given type in given environment?
 388      *  @param env    The current environment.
 389      *  @param site   The type of which the tested symbol is regarded
 390      *                as a member.
 391      *  @param sym    The symbol.
 392      */
 393     public boolean isAccessible(Env&lt;AttrContext&gt; env, Type site, Symbol sym) {
 394         return isAccessible(env, site, sym, false);
 395     }
 396     public boolean isAccessible(Env&lt;AttrContext&gt; env, Type site, Symbol sym, boolean checkInner) {
 397         if (sym.name == names.init &amp;&amp; sym.owner != site.tsym) return false;
 398 
 399         /* 15.9.5.1: Note that it is possible for the signature of the anonymous constructor
 400            to refer to an inaccessible type
 401         */
 402         if (env.enclMethod != null &amp;&amp; (env.enclMethod.mods.flags &amp; ANONCONSTR) != 0)
 403             return true;
 404 
 405         if (env.info.visitingServiceImplementation &amp;&amp;
 406             env.toplevel.modle == sym.packge().modle) {
 407             return true;
 408         }
 409 
 410         ClassSymbol enclosingCsym = env.enclClass.sym;
 411         if (sym.kind == MTH || sym.kind == VAR) {
 412             /* If any inline types are involved, ask the same question in the reference universe,
 413                where the hierarchy is navigable
 414             */
 415             if (site.isValue())
 416                 site = site.referenceProjection();
 417             if (sym.owner.isValue())
 418                 sym = sym.referenceProjection();
 419             if (env.enclClass.sym.isValue())
 420                 env.enclClass.sym = env.enclClass.sym.referenceProjection();
 421         }
 422         try {
 423             switch ((short)(sym.flags() &amp; AccessFlags)) {
 424                 case PRIVATE:
 425                     return
 426                             (env.enclClass.sym == sym.owner // fast special case
 427                                     ||
 428                                     env.enclClass.sym.outermostClass() ==
 429                                             sym.owner.outermostClass())
 430                                     &amp;&amp;
 431                                     sym.isInheritedIn(site.tsym, types);
 432                 case 0:
 433                     return
 434                             (env.toplevel.packge == sym.owner.owner // fast special case
 435                                     ||
 436                                     env.toplevel.packge == sym.packge())
 437                                     &amp;&amp;
 438                                     isAccessible(env, site, checkInner)
 439                                     &amp;&amp;
 440                                     sym.isInheritedIn(site.tsym, types)
 441                                     &amp;&amp;
 442                                     notOverriddenIn(site, sym);
 443                 case PROTECTED:
 444                     return
 445                             (env.toplevel.packge == sym.owner.owner // fast special case
 446                                     ||
 447                                     env.toplevel.packge == sym.packge()
 448                                     ||
 449                                     isProtectedAccessible(sym, env.enclClass.sym, site)
 450                                     ||
 451                                     // OK to select instance method or field from &#39;super&#39; or type name
 452                                     // (but type names should be disallowed elsewhere!)
 453                                     env.info.selectSuper &amp;&amp; (sym.flags() &amp; STATIC) == 0 &amp;&amp; sym.kind != TYP)
 454                                     &amp;&amp;
 455                                     isAccessible(env, site, checkInner)
 456                                     &amp;&amp;
 457                                     notOverriddenIn(site, sym);
 458                 default: // this case includes erroneous combinations as well
 459                     return isAccessible(env, site, checkInner) &amp;&amp; notOverriddenIn(site, sym);
 460             }
 461         } finally {
 462             env.enclClass.sym = enclosingCsym;
 463         }
 464     }
 465     //where
 466     /* `sym&#39; is accessible only if not overridden by
 467      * another symbol which is a member of `site&#39;
 468      * (because, if it is overridden, `sym&#39; is not strictly
 469      * speaking a member of `site&#39;). A polymorphic signature method
 470      * cannot be overridden (e.g. MH.invokeExact(Object[])).
 471      */
 472     private boolean notOverriddenIn(Type site, Symbol sym) {
 473         if (sym.kind != MTH || sym.isConstructor() || sym.isStatic())
 474             return true;
 475 
 476         /* If any inline types are involved, ask the same question in the reference universe,
 477            where the hierarchy is navigable
 478         */
 479         if (site.isValue())
 480             site = site.referenceProjection();
 481         if (sym.owner.isValue())
 482             sym = sym.referenceProjection();
 483 
 484         Symbol s2 = ((MethodSymbol)sym).implementation(site.tsym, types, true);
 485         return (s2 == null || s2 == sym || sym.owner == s2.owner ||
 486                 !types.isSubSignature(types.memberType(site, s2), types.memberType(site, sym)));
 487     }
 488     //where
 489         /** Is given protected symbol accessible if it is selected from given site
 490          *  and the selection takes place in given class?
 491          *  @param sym     The symbol with protected access
 492          *  @param c       The class where the access takes place
 493          *  @site          The type of the qualifier
 494          */
 495         private
 496         boolean isProtectedAccessible(Symbol sym, ClassSymbol c, Type site) {
 497             Type newSite = site.hasTag(TYPEVAR) ? site.getUpperBound() : site;
 498             while (c != null &amp;&amp;
 499                    !(c.isSubClass(sym.owner, types) &amp;&amp;
 500                      (c.flags() &amp; INTERFACE) == 0 &amp;&amp;
 501                      // In JLS 2e 6.6.2.1, the subclass restriction applies
 502                      // only to instance fields and methods -- types are excluded
 503                      // regardless of whether they are declared &#39;static&#39; or not.
 504                      ((sym.flags() &amp; STATIC) != 0 || sym.kind == TYP || newSite.tsym.isSubClass(c, types))))
 505                 c = c.owner.enclClass();
 506             return c != null;
 507         }
 508 
 509     /**
 510      * Performs a recursive scan of a type looking for accessibility problems
 511      * from current attribution environment
 512      */
 513     void checkAccessibleType(Env&lt;AttrContext&gt; env, Type t) {
 514         accessibilityChecker.visit(t, env);
 515     }
 516 
 517     /**
 518      * Accessibility type-visitor
 519      */
 520     Types.SimpleVisitor&lt;Void, Env&lt;AttrContext&gt;&gt; accessibilityChecker =
 521             new Types.SimpleVisitor&lt;Void, Env&lt;AttrContext&gt;&gt;() {
 522 
 523         void visit(List&lt;Type&gt; ts, Env&lt;AttrContext&gt; env) {
 524             for (Type t : ts) {
 525                 visit(t, env);
 526             }
 527         }
 528 
 529         public Void visitType(Type t, Env&lt;AttrContext&gt; env) {
 530             return null;
 531         }
 532 
 533         @Override
 534         public Void visitArrayType(ArrayType t, Env&lt;AttrContext&gt; env) {
 535             visit(t.elemtype, env);
 536             return null;
 537         }
 538 
 539         @Override
 540         public Void visitClassType(ClassType t, Env&lt;AttrContext&gt; env) {
 541             visit(t.getTypeArguments(), env);
 542             if (!isAccessible(env, t, true)) {
 543                 accessBase(new AccessError(env, null, t.tsym), env.tree.pos(), env.enclClass.sym, t, t.tsym.name, true);
 544             }
 545             return null;
 546         }
 547 
 548         @Override
 549         public Void visitWildcardType(WildcardType t, Env&lt;AttrContext&gt; env) {
 550             visit(t.type, env);
 551             return null;
 552         }
 553 
 554         @Override
 555         public Void visitMethodType(MethodType t, Env&lt;AttrContext&gt; env) {
 556             visit(t.getParameterTypes(), env);
 557             visit(t.getReturnType(), env);
 558             visit(t.getThrownTypes(), env);
 559             return null;
 560         }
 561     };
 562 
 563     /** Try to instantiate the type of a method so that it fits
 564      *  given type arguments and argument types. If successful, return
 565      *  the method&#39;s instantiated type, else return null.
 566      *  The instantiation will take into account an additional leading
 567      *  formal parameter if the method is an instance method seen as a member
 568      *  of an under determined site. In this case, we treat site as an additional
 569      *  parameter and the parameters of the class containing the method as
 570      *  additional type variables that get instantiated.
 571      *
 572      *  @param env         The current environment
 573      *  @param site        The type of which the method is a member.
 574      *  @param m           The method symbol.
 575      *  @param argtypes    The invocation&#39;s given value arguments.
 576      *  @param typeargtypes    The invocation&#39;s given type arguments.
 577      *  @param allowBoxing Allow boxing conversions of arguments.
 578      *  @param useVarargs Box trailing arguments into an array for varargs.
 579      */
 580     Type rawInstantiate(Env&lt;AttrContext&gt; env,
 581                         Type site,
 582                         Symbol m,
 583                         ResultInfo resultInfo,
 584                         List&lt;Type&gt; argtypes,
 585                         List&lt;Type&gt; typeargtypes,
 586                         boolean allowBoxing,
 587                         boolean useVarargs,
 588                         Warner warn) throws Infer.InferenceException {
 589         Type mt = types.memberType(site, m);
 590         // tvars is the list of formal type variables for which type arguments
 591         // need to inferred.
 592         List&lt;Type&gt; tvars = List.nil();
 593         if (typeargtypes == null) typeargtypes = List.nil();
 594         if (!mt.hasTag(FORALL) &amp;&amp; typeargtypes.nonEmpty()) {
 595             // This is not a polymorphic method, but typeargs are supplied
 596             // which is fine, see JLS 15.12.2.1
 597         } else if (mt.hasTag(FORALL) &amp;&amp; typeargtypes.nonEmpty()) {
 598             ForAll pmt = (ForAll) mt;
 599             if (typeargtypes.length() != pmt.tvars.length())
 600                  // not enough args
 601                 throw new InapplicableMethodException(diags.fragment(Fragments.WrongNumberTypeArgs(Integer.toString(pmt.tvars.length()))));
 602             // Check type arguments are within bounds
 603             List&lt;Type&gt; formals = pmt.tvars;
 604             List&lt;Type&gt; actuals = typeargtypes;
 605             while (formals.nonEmpty() &amp;&amp; actuals.nonEmpty()) {
 606                 List&lt;Type&gt; bounds = types.subst(types.getBounds((TypeVar)formals.head),
 607                                                 pmt.tvars, typeargtypes);
 608                 for (; bounds.nonEmpty(); bounds = bounds.tail) {
 609                     if (!types.isSubtypeUnchecked(actuals.head, bounds.head, warn)) {
 610                         throw new InapplicableMethodException(diags.fragment(Fragments.ExplicitParamDoNotConformToBounds(actuals.head, bounds)));
 611                     }
 612                 }
 613                 formals = formals.tail;
 614                 actuals = actuals.tail;
 615             }
 616             mt = types.subst(pmt.qtype, pmt.tvars, typeargtypes);
 617         } else if (mt.hasTag(FORALL)) {
 618             ForAll pmt = (ForAll) mt;
 619             List&lt;Type&gt; tvars1 = types.newInstances(pmt.tvars);
 620             tvars = tvars.appendList(tvars1);
 621             mt = types.subst(pmt.qtype, pmt.tvars, tvars1);
 622         }
 623 
 624         // find out whether we need to go the slow route via infer
 625         boolean instNeeded = tvars.tail != null; /*inlined: tvars.nonEmpty()*/
 626         for (List&lt;Type&gt; l = argtypes;
 627              l.tail != null/*inlined: l.nonEmpty()*/ &amp;&amp; !instNeeded;
 628              l = l.tail) {
 629             if (l.head.hasTag(FORALL)) instNeeded = true;
 630         }
 631 
 632         if (instNeeded) {
 633             return infer.instantiateMethod(env,
 634                                     tvars,
 635                                     (MethodType)mt,
 636                                     resultInfo,
 637                                     (MethodSymbol)m,
 638                                     argtypes,
 639                                     allowBoxing,
 640                                     useVarargs,
 641                                     currentResolutionContext,
 642                                     warn);
 643         }
 644 
 645         DeferredAttr.DeferredAttrContext dc = currentResolutionContext.deferredAttrContext(m, infer.emptyContext, resultInfo, warn);
 646         currentResolutionContext.methodCheck.argumentsAcceptable(env, dc,
 647                                 argtypes, mt.getParameterTypes(), warn);
 648         dc.complete();
 649         return mt;
 650     }
 651 
 652     Type checkMethod(Env&lt;AttrContext&gt; env,
 653                      Type site,
 654                      Symbol m,
 655                      ResultInfo resultInfo,
 656                      List&lt;Type&gt; argtypes,
 657                      List&lt;Type&gt; typeargtypes,
 658                      Warner warn) {
 659         MethodResolutionContext prevContext = currentResolutionContext;
 660         try {
 661             currentResolutionContext = new MethodResolutionContext();
 662             currentResolutionContext.attrMode = (resultInfo.pt == Infer.anyPoly) ?
 663                     AttrMode.SPECULATIVE : DeferredAttr.AttrMode.CHECK;
 664             if (env.tree.hasTag(JCTree.Tag.REFERENCE)) {
 665                 //method/constructor references need special check class
 666                 //to handle inference variables in &#39;argtypes&#39; (might happen
 667                 //during an unsticking round)
 668                 currentResolutionContext.methodCheck =
 669                         new MethodReferenceCheck(resultInfo.checkContext.inferenceContext());
 670             }
 671             MethodResolutionPhase step = currentResolutionContext.step = env.info.pendingResolutionPhase;
 672             return rawInstantiate(env, site, m, resultInfo, argtypes, typeargtypes,
 673                     step.isBoxingRequired(), step.isVarargsRequired(), warn);
 674         }
 675         finally {
 676             currentResolutionContext = prevContext;
 677         }
 678     }
 679 
 680     /** Same but returns null instead throwing a NoInstanceException
 681      */
 682     Type instantiate(Env&lt;AttrContext&gt; env,
 683                      Type site,
 684                      Symbol m,
 685                      ResultInfo resultInfo,
 686                      List&lt;Type&gt; argtypes,
 687                      List&lt;Type&gt; typeargtypes,
 688                      boolean allowBoxing,
 689                      boolean useVarargs,
 690                      Warner warn) {
 691         try {
 692             return rawInstantiate(env, site, m, resultInfo, argtypes, typeargtypes,
 693                                   allowBoxing, useVarargs, warn);
 694         } catch (InapplicableMethodException ex) {
 695             return null;
 696         }
 697     }
 698 
 699     /**
 700      * This interface defines an entry point that should be used to perform a
 701      * method check. A method check usually consist in determining as to whether
 702      * a set of types (actuals) is compatible with another set of types (formals).
 703      * Since the notion of compatibility can vary depending on the circumstances,
 704      * this interfaces allows to easily add new pluggable method check routines.
 705      */
 706     interface MethodCheck {
 707         /**
 708          * Main method check routine. A method check usually consist in determining
 709          * as to whether a set of types (actuals) is compatible with another set of
 710          * types (formals). If an incompatibility is found, an unchecked exception
 711          * is assumed to be thrown.
 712          */
 713         void argumentsAcceptable(Env&lt;AttrContext&gt; env,
 714                                 DeferredAttrContext deferredAttrContext,
 715                                 List&lt;Type&gt; argtypes,
 716                                 List&lt;Type&gt; formals,
 717                                 Warner warn);
 718 
 719         /**
 720          * Retrieve the method check object that will be used during a
 721          * most specific check.
 722          */
 723         MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals);
 724     }
 725 
 726     /**
 727      * Helper enum defining all method check diagnostics (used by resolveMethodCheck).
 728      */
 729     enum MethodCheckDiag {
 730         /**
 731          * Actuals and formals differs in length.
 732          */
 733         ARITY_MISMATCH(&quot;arg.length.mismatch&quot;, &quot;infer.arg.length.mismatch&quot;),
 734         /**
 735          * An actual is incompatible with a formal.
 736          */
 737         ARG_MISMATCH(&quot;no.conforming.assignment.exists&quot;, &quot;infer.no.conforming.assignment.exists&quot;),
 738         /**
 739          * An actual is incompatible with the varargs element type.
 740          */
 741         VARARG_MISMATCH(&quot;varargs.argument.mismatch&quot;, &quot;infer.varargs.argument.mismatch&quot;),
 742         /**
 743          * The varargs element type is inaccessible.
 744          */
 745         INACCESSIBLE_VARARGS(&quot;inaccessible.varargs.type&quot;, &quot;inaccessible.varargs.type&quot;);
 746 
 747         final String basicKey;
 748         final String inferKey;
 749 
 750         MethodCheckDiag(String basicKey, String inferKey) {
 751             this.basicKey = basicKey;
 752             this.inferKey = inferKey;
 753         }
 754 
 755         String regex() {
 756             return String.format(&quot;([a-z]*\\.)*(%s|%s)&quot;, basicKey, inferKey);
 757         }
 758     }
 759 
 760     /**
 761      * Dummy method check object. All methods are deemed applicable, regardless
 762      * of their formal parameter types.
 763      */
 764     MethodCheck nilMethodCheck = new MethodCheck() {
 765         public void argumentsAcceptable(Env&lt;AttrContext&gt; env, DeferredAttrContext deferredAttrContext, List&lt;Type&gt; argtypes, List&lt;Type&gt; formals, Warner warn) {
 766             //do nothing - method always applicable regardless of actuals
 767         }
 768 
 769         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 770             return this;
 771         }
 772     };
 773 
 774     /**
 775      * Base class for &#39;real&#39; method checks. The class defines the logic for
 776      * iterating through formals and actuals and provides and entry point
 777      * that can be used by subclasses in order to define the actual check logic.
 778      */
 779     abstract class AbstractMethodCheck implements MethodCheck {
 780         @Override
 781         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
 782                                     DeferredAttrContext deferredAttrContext,
 783                                     List&lt;Type&gt; argtypes,
 784                                     List&lt;Type&gt; formals,
 785                                     Warner warn) {
 786             //should we expand formals?
 787             boolean useVarargs = deferredAttrContext.phase.isVarargsRequired();
 788             JCTree callTree = treeForDiagnostics(env);
 789             List&lt;JCExpression&gt; trees = TreeInfo.args(callTree);
 790 
 791             //inference context used during this method check
 792             InferenceContext inferenceContext = deferredAttrContext.inferenceContext;
 793 
 794             Type varargsFormal = useVarargs ? formals.last() : null;
 795 
 796             if (varargsFormal == null &amp;&amp;
 797                     argtypes.size() != formals.size()) {
 798                 reportMC(callTree, MethodCheckDiag.ARITY_MISMATCH, inferenceContext); // not enough args
 799             }
 800 
 801             while (argtypes.nonEmpty() &amp;&amp; formals.head != varargsFormal) {
 802                 DiagnosticPosition pos = trees != null ? trees.head : null;
 803                 checkArg(pos, false, argtypes.head, formals.head, deferredAttrContext, warn);
 804                 argtypes = argtypes.tail;
 805                 formals = formals.tail;
 806                 trees = trees != null ? trees.tail : trees;
 807             }
 808 
 809             if (formals.head != varargsFormal) {
 810                 reportMC(callTree, MethodCheckDiag.ARITY_MISMATCH, inferenceContext); // not enough args
 811             }
 812 
 813             if (useVarargs) {
 814                 //note: if applicability check is triggered by most specific test,
 815                 //the last argument of a varargs is _not_ an array type (see JLS 15.12.2.5)
 816                 final Type elt = types.elemtype(varargsFormal);
 817                 while (argtypes.nonEmpty()) {
 818                     DiagnosticPosition pos = trees != null ? trees.head : null;
 819                     checkArg(pos, true, argtypes.head, elt, deferredAttrContext, warn);
 820                     argtypes = argtypes.tail;
 821                     trees = trees != null ? trees.tail : trees;
 822                 }
 823             }
 824         }
 825 
 826             // where
 827             private JCTree treeForDiagnostics(Env&lt;AttrContext&gt; env) {
 828                 return env.info.preferredTreeForDiagnostics != null ? env.info.preferredTreeForDiagnostics : env.tree;
 829             }
 830 
 831         /**
 832          * Does the actual argument conforms to the corresponding formal?
 833          */
 834         abstract void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn);
 835 
 836         protected void reportMC(DiagnosticPosition pos, MethodCheckDiag diag, InferenceContext inferenceContext, Object... args) {
 837             boolean inferDiag = inferenceContext != infer.emptyContext;
 838             if (inferDiag &amp;&amp; (!diag.inferKey.equals(diag.basicKey))) {
 839                 Object[] args2 = new Object[args.length + 1];
 840                 System.arraycopy(args, 0, args2, 1, args.length);
 841                 args2[0] = inferenceContext.inferenceVars();
 842                 args = args2;
 843             }
 844             String key = inferDiag ? diag.inferKey : diag.basicKey;
 845             throw inferDiag ?
 846                 infer.error(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args)) :
 847                 methodCheckFailure.setMessage(diags.create(DiagnosticType.FRAGMENT, log.currentSource(), pos, key, args));
 848         }
 849 
 850         /**
 851          * To eliminate the overhead associated with allocating an exception object in such an
 852          * hot execution path, we use flyweight pattern - and share the same exception instance
 853          * across multiple method check failures.
 854          */
 855         class SharedInapplicableMethodException extends InapplicableMethodException {
 856             private static final long serialVersionUID = 0;
 857 
 858             SharedInapplicableMethodException() {
 859                 super(null);
 860             }
 861 
 862             SharedInapplicableMethodException setMessage(JCDiagnostic details) {
 863                 this.diagnostic = details;
 864                 return this;
 865             }
 866         }
 867 
 868         SharedInapplicableMethodException methodCheckFailure = new SharedInapplicableMethodException();
 869 
 870         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 871             return nilMethodCheck;
 872         }
 873 
 874     }
 875 
 876     /**
 877      * Arity-based method check. A method is applicable if the number of actuals
 878      * supplied conforms to the method signature.
 879      */
 880     MethodCheck arityMethodCheck = new AbstractMethodCheck() {
 881         @Override
 882         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 883             //do nothing - actual always compatible to formals
 884         }
 885 
 886         @Override
 887         public String toString() {
 888             return &quot;arityMethodCheck&quot;;
 889         }
 890     };
 891 
 892     /**
 893      * Main method applicability routine. Given a list of actual types A,
 894      * a list of formal types F, determines whether the types in A are
 895      * compatible (by method invocation conversion) with the types in F.
 896      *
 897      * Since this routine is shared between overload resolution and method
 898      * type-inference, a (possibly empty) inference context is used to convert
 899      * formal types to the corresponding &#39;undet&#39; form ahead of a compatibility
 900      * check so that constraints can be propagated and collected.
 901      *
 902      * Moreover, if one or more types in A is a deferred type, this routine uses
 903      * DeferredAttr in order to perform deferred attribution. If one or more actual
 904      * deferred types are stuck, they are placed in a queue and revisited later
 905      * after the remainder of the arguments have been seen. If this is not sufficient
 906      * to &#39;unstuck&#39; the argument, a cyclic inference error is called out.
 907      *
 908      * A method check handler (see above) is used in order to report errors.
 909      */
 910     MethodCheck resolveMethodCheck = new AbstractMethodCheck() {
 911 
 912         @Override
 913         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 914             ResultInfo mresult = methodCheckResult(varargs, formal, deferredAttrContext, warn);
 915             mresult.check(pos, actual);
 916         }
 917 
 918         @Override
 919         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
 920                                     DeferredAttrContext deferredAttrContext,
 921                                     List&lt;Type&gt; argtypes,
 922                                     List&lt;Type&gt; formals,
 923                                     Warner warn) {
 924             super.argumentsAcceptable(env, deferredAttrContext, argtypes, formals, warn);
 925             // should we check varargs element type accessibility?
 926             if (deferredAttrContext.phase.isVarargsRequired()) {
 927                 if (deferredAttrContext.mode == AttrMode.CHECK || !checkVarargsAccessAfterResolution) {
 928                     varargsAccessible(env, types.elemtype(formals.last()), deferredAttrContext.inferenceContext);
 929                 }
 930             }
 931         }
 932 
 933         /**
 934          * Test that the runtime array element type corresponding to &#39;t&#39; is accessible.  &#39;t&#39; should be the
 935          * varargs element type of either the method invocation type signature (after inference completes)
 936          * or the method declaration signature (before inference completes).
 937          */
 938         private void varargsAccessible(final Env&lt;AttrContext&gt; env, final Type t, final InferenceContext inferenceContext) {
 939             if (inferenceContext.free(t)) {
 940                 inferenceContext.addFreeTypeListener(List.of(t),
 941                         solvedContext -&gt; varargsAccessible(env, solvedContext.asInstType(t), solvedContext));
 942             } else {
 943                 if (!isAccessible(env, types.erasure(t))) {
 944                     Symbol location = env.enclClass.sym;
 945                     reportMC(env.tree, MethodCheckDiag.INACCESSIBLE_VARARGS, inferenceContext, t, Kinds.kindName(location), location);
 946                 }
 947             }
 948         }
 949 
 950         private ResultInfo methodCheckResult(final boolean varargsCheck, Type to,
 951                 final DeferredAttr.DeferredAttrContext deferredAttrContext, Warner rsWarner) {
 952             CheckContext checkContext = new MethodCheckContext(!deferredAttrContext.phase.isBoxingRequired(), deferredAttrContext, rsWarner) {
 953                 MethodCheckDiag methodDiag = varargsCheck ?
 954                                  MethodCheckDiag.VARARG_MISMATCH : MethodCheckDiag.ARG_MISMATCH;
 955 
 956                 @Override
 957                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
 958                     reportMC(pos, methodDiag, deferredAttrContext.inferenceContext, details);
 959                 }
 960             };
 961             return new MethodResultInfo(to, checkContext);
 962         }
 963 
 964         @Override
 965         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
 966             return new MostSpecificCheck(actuals);
 967         }
 968 
 969         @Override
 970         public String toString() {
 971             return &quot;resolveMethodCheck&quot;;
 972         }
 973     };
 974 
 975     /**
 976      * This class handles method reference applicability checks; since during
 977      * these checks it&#39;s sometime possible to have inference variables on
 978      * the actual argument types list, the method applicability check must be
 979      * extended so that inference variables are &#39;opened&#39; as needed.
 980      */
 981     class MethodReferenceCheck extends AbstractMethodCheck {
 982 
 983         InferenceContext pendingInferenceContext;
 984 
 985         MethodReferenceCheck(InferenceContext pendingInferenceContext) {
 986             this.pendingInferenceContext = pendingInferenceContext;
 987         }
 988 
 989         @Override
 990         void checkArg(DiagnosticPosition pos, boolean varargs, Type actual, Type formal, DeferredAttrContext deferredAttrContext, Warner warn) {
 991             ResultInfo mresult = methodCheckResult(varargs, formal, deferredAttrContext, warn);
 992             mresult.check(pos, actual);
 993         }
 994 
 995         private ResultInfo methodCheckResult(final boolean varargsCheck, Type to,
 996                 final DeferredAttr.DeferredAttrContext deferredAttrContext, Warner rsWarner) {
 997             CheckContext checkContext = new MethodCheckContext(!deferredAttrContext.phase.isBoxingRequired(), deferredAttrContext, rsWarner) {
 998                 MethodCheckDiag methodDiag = varargsCheck ?
 999                                  MethodCheckDiag.VARARG_MISMATCH : MethodCheckDiag.ARG_MISMATCH;
1000 
1001                 @Override
1002                 public boolean compatible(Type found, Type req, Warner warn) {
1003                     found = pendingInferenceContext.asUndetVar(found);
1004                     if (found.hasTag(UNDETVAR) &amp;&amp; req.isPrimitive()) {
1005                         req = types.boxedClass(req).type;
1006                     }
1007                     return super.compatible(found, req, warn);
1008                 }
1009 
1010                 @Override
1011                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
1012                     reportMC(pos, methodDiag, deferredAttrContext.inferenceContext, details);
1013                 }
1014             };
1015             return new MethodResultInfo(to, checkContext);
1016         }
1017 
1018         @Override
1019         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
1020             return new MostSpecificCheck(actuals);
1021         }
1022 
1023         @Override
1024         public String toString() {
1025             return &quot;MethodReferenceCheck&quot;;
1026         }
1027     }
1028 
1029     /**
1030      * Check context to be used during method applicability checks. A method check
1031      * context might contain inference variables.
1032      */
1033     abstract class MethodCheckContext implements CheckContext {
1034 
1035         boolean strict;
1036         DeferredAttrContext deferredAttrContext;
1037         Warner rsWarner;
1038 
1039         public MethodCheckContext(boolean strict, DeferredAttrContext deferredAttrContext, Warner rsWarner) {
1040            this.strict = strict;
1041            this.deferredAttrContext = deferredAttrContext;
1042            this.rsWarner = rsWarner;
1043         }
1044 
1045         public boolean compatible(Type found, Type req, Warner warn) {
1046             InferenceContext inferenceContext = deferredAttrContext.inferenceContext;
1047             return strict ?
1048                     types.isSubtypeUnchecked(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn) :
1049                     types.isConvertible(inferenceContext.asUndetVar(found), inferenceContext.asUndetVar(req), warn);
1050         }
1051 
1052         public void report(DiagnosticPosition pos, JCDiagnostic details) {
1053             throw new InapplicableMethodException(details);
1054         }
1055 
1056         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
1057             return rsWarner;
1058         }
1059 
1060         public InferenceContext inferenceContext() {
1061             return deferredAttrContext.inferenceContext;
1062         }
1063 
1064         public DeferredAttrContext deferredAttrContext() {
1065             return deferredAttrContext;
1066         }
1067 
1068         @Override
1069         public String toString() {
1070             return &quot;MethodCheckContext&quot;;
1071         }
1072     }
1073 
1074     /**
1075      * ResultInfo class to be used during method applicability checks. Check
1076      * for deferred types goes through special path.
1077      */
1078     class MethodResultInfo extends ResultInfo {
1079 
1080         public MethodResultInfo(Type pt, CheckContext checkContext) {
1081             attr.super(KindSelector.VAL, pt, checkContext);
1082         }
1083 
1084         @Override
1085         protected Type check(DiagnosticPosition pos, Type found) {
1086             if (found.hasTag(DEFERRED)) {
1087                 DeferredType dt = (DeferredType)found;
1088                 return dt.check(this);
1089             } else {
1090                 Type uResult = U(found);
1091                 Type capturedType = pos == null || pos.getTree() == null ?
1092                         types.capture(uResult) :
1093                         checkContext.inferenceContext()
1094                             .cachedCapture(pos.getTree(), uResult, true);
1095                 return super.check(pos, chk.checkNonVoid(pos, capturedType));
1096             }
1097         }
1098 
1099         /**
1100          * javac has a long-standing &#39;simplification&#39; (see 6391995):
1101          * given an actual argument type, the method check is performed
1102          * on its upper bound. This leads to inconsistencies when an
1103          * argument type is checked against itself. For example, given
1104          * a type-variable T, it is not true that {@code U(T) &lt;: T},
1105          * so we need to guard against that.
1106          */
1107         private Type U(Type found) {
1108             return found == pt ?
1109                     found : types.cvarUpperBound(found);
1110         }
1111 
1112         @Override
1113         protected MethodResultInfo dup(Type newPt) {
1114             return new MethodResultInfo(newPt, checkContext);
1115         }
1116 
1117         @Override
1118         protected ResultInfo dup(CheckContext newContext) {
1119             return new MethodResultInfo(pt, newContext);
1120         }
1121 
1122         @Override
1123         protected ResultInfo dup(Type newPt, CheckContext newContext) {
1124             return new MethodResultInfo(newPt, newContext);
1125         }
1126     }
1127 
1128     /**
1129      * Most specific method applicability routine. Given a list of actual types A,
1130      * a list of formal types F1, and a list of formal types F2, the routine determines
1131      * as to whether the types in F1 can be considered more specific than those in F2 w.r.t.
1132      * argument types A.
1133      */
1134     class MostSpecificCheck implements MethodCheck {
1135 
1136         List&lt;Type&gt; actuals;
1137 
1138         MostSpecificCheck(List&lt;Type&gt; actuals) {
1139             this.actuals = actuals;
1140         }
1141 
1142         @Override
1143         public void argumentsAcceptable(final Env&lt;AttrContext&gt; env,
1144                                     DeferredAttrContext deferredAttrContext,
1145                                     List&lt;Type&gt; formals1,
1146                                     List&lt;Type&gt; formals2,
1147                                     Warner warn) {
1148             formals2 = adjustArgs(formals2, deferredAttrContext.msym, formals1.length(), deferredAttrContext.phase.isVarargsRequired());
1149             while (formals2.nonEmpty()) {
1150                 ResultInfo mresult = methodCheckResult(formals2.head, deferredAttrContext, warn, actuals.head);
1151                 mresult.check(null, formals1.head);
1152                 formals1 = formals1.tail;
1153                 formals2 = formals2.tail;
1154                 actuals = actuals.isEmpty() ? actuals : actuals.tail;
1155             }
1156         }
1157 
1158        /**
1159         * Create a method check context to be used during the most specific applicability check
1160         */
1161         ResultInfo methodCheckResult(Type to, DeferredAttr.DeferredAttrContext deferredAttrContext,
1162                Warner rsWarner, Type actual) {
1163             return attr.new ResultInfo(KindSelector.VAL, to,
1164                    new MostSpecificCheckContext(deferredAttrContext, rsWarner, actual));
1165         }
1166 
1167         /**
1168          * Subclass of method check context class that implements most specific
1169          * method conversion. If the actual type under analysis is a deferred type
1170          * a full blown structural analysis is carried out.
1171          */
1172         class MostSpecificCheckContext extends MethodCheckContext {
1173 
1174             Type actual;
1175 
1176             public MostSpecificCheckContext(DeferredAttrContext deferredAttrContext, Warner rsWarner, Type actual) {
1177                 super(true, deferredAttrContext, rsWarner);
1178                 this.actual = actual;
1179             }
1180 
1181             public boolean compatible(Type found, Type req, Warner warn) {
1182                 if (allowFunctionalInterfaceMostSpecific &amp;&amp;
1183                         unrelatedFunctionalInterfaces(found, req) &amp;&amp;
1184                         (actual != null &amp;&amp; actual.getTag() == DEFERRED)) {
1185                     DeferredType dt = (DeferredType) actual;
1186                     JCTree speculativeTree = dt.speculativeTree(deferredAttrContext);
1187                     if (speculativeTree != deferredAttr.stuckTree) {
1188                         return functionalInterfaceMostSpecific(found, req, speculativeTree);
1189                     }
1190                 }
1191                 return compatibleBySubtyping(found, req);
1192             }
1193 
1194             private boolean compatibleBySubtyping(Type found, Type req) {
1195                 if (!strict &amp;&amp; found.isPrimitive() != req.isPrimitive()) {
1196                     found = found.isPrimitive() ? types.boxedClass(found).type : types.unboxedType(found);
1197                 }
1198                 return types.isSubtypeNoCapture(found, deferredAttrContext.inferenceContext.asUndetVar(req));
1199             }
1200 
1201             /** Whether {@code t} and {@code s} are unrelated functional interface types. */
1202             private boolean unrelatedFunctionalInterfaces(Type t, Type s) {
1203                 return types.isFunctionalInterface(t.tsym) &amp;&amp;
1204                        types.isFunctionalInterface(s.tsym) &amp;&amp;
1205                        unrelatedInterfaces(t, s);
1206             }
1207 
1208             /** Whether {@code t} and {@code s} are unrelated interface types; recurs on intersections. **/
1209             private boolean unrelatedInterfaces(Type t, Type s) {
1210                 if (t.isCompound()) {
1211                     for (Type ti : types.interfaces(t)) {
1212                         if (!unrelatedInterfaces(ti, s)) {
1213                             return false;
1214                         }
1215                     }
1216                     return true;
1217                 } else if (s.isCompound()) {
1218                     for (Type si : types.interfaces(s)) {
1219                         if (!unrelatedInterfaces(t, si)) {
1220                             return false;
1221                         }
1222                     }
1223                     return true;
1224                 } else {
1225                     return types.asSuper(t, s.tsym) == null &amp;&amp; types.asSuper(s, t.tsym) == null;
1226                 }
1227             }
1228 
1229             /** Parameters {@code t} and {@code s} are unrelated functional interface types. */
1230             private boolean functionalInterfaceMostSpecific(Type t, Type s, JCTree tree) {
1231                 Type tDesc = types.findDescriptorType(types.capture(t));
1232                 Type tDescNoCapture = types.findDescriptorType(t);
1233                 Type sDesc = types.findDescriptorType(s);
1234                 final List&lt;Type&gt; tTypeParams = tDesc.getTypeArguments();
1235                 final List&lt;Type&gt; tTypeParamsNoCapture = tDescNoCapture.getTypeArguments();
1236                 final List&lt;Type&gt; sTypeParams = sDesc.getTypeArguments();
1237 
1238                 // compare type parameters
1239                 if (tDesc.hasTag(FORALL) &amp;&amp; !types.hasSameBounds((ForAll) tDesc, (ForAll) tDescNoCapture)) {
1240                     return false;
1241                 }
1242                 // can&#39;t use Types.hasSameBounds on sDesc because bounds may have ivars
1243                 List&lt;Type&gt; tIter = tTypeParams;
1244                 List&lt;Type&gt; sIter = sTypeParams;
1245                 while (tIter.nonEmpty() &amp;&amp; sIter.nonEmpty()) {
1246                     Type tBound = tIter.head.getUpperBound();
1247                     Type sBound = types.subst(sIter.head.getUpperBound(), sTypeParams, tTypeParams);
1248                     if (tBound.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sBound)) {
1249                         return false;
1250                     }
1251                     if (!types.isSameType(tBound, inferenceContext().asUndetVar(sBound))) {
1252                         return false;
1253                     }
1254                     tIter = tIter.tail;
1255                     sIter = sIter.tail;
1256                 }
1257                 if (!tIter.isEmpty() || !sIter.isEmpty()) {
1258                     return false;
1259                 }
1260 
1261                 // compare parameters
1262                 List&lt;Type&gt; tParams = tDesc.getParameterTypes();
1263                 List&lt;Type&gt; tParamsNoCapture = tDescNoCapture.getParameterTypes();
1264                 List&lt;Type&gt; sParams = sDesc.getParameterTypes();
1265                 while (tParams.nonEmpty() &amp;&amp; tParamsNoCapture.nonEmpty() &amp;&amp; sParams.nonEmpty()) {
1266                     Type tParam = tParams.head;
1267                     Type tParamNoCapture = types.subst(tParamsNoCapture.head, tTypeParamsNoCapture, tTypeParams);
1268                     Type sParam = types.subst(sParams.head, sTypeParams, tTypeParams);
1269                     if (tParam.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sParam)) {
1270                         return false;
1271                     }
1272                     if (!types.isSubtype(inferenceContext().asUndetVar(sParam), tParam)) {
1273                         return false;
1274                     }
1275                     if (!types.isSameType(tParamNoCapture, inferenceContext().asUndetVar(sParam))) {
1276                         return false;
1277                     }
1278                     tParams = tParams.tail;
1279                     tParamsNoCapture = tParamsNoCapture.tail;
1280                     sParams = sParams.tail;
1281                 }
1282                 if (!tParams.isEmpty() || !tParamsNoCapture.isEmpty() || !sParams.isEmpty()) {
1283                     return false;
1284                 }
1285 
1286                 // compare returns
1287                 Type tRet = tDesc.getReturnType();
1288                 Type sRet = types.subst(sDesc.getReturnType(), sTypeParams, tTypeParams);
1289                 if (tRet.containsAny(tTypeParams) &amp;&amp; inferenceContext().free(sRet)) {
1290                     return false;
1291                 }
1292                 MostSpecificFunctionReturnChecker msc = new MostSpecificFunctionReturnChecker(tRet, sRet);
1293                 msc.scan(tree);
1294                 return msc.result;
1295             }
1296 
1297             /**
1298              * Tests whether one functional interface type can be considered more specific
1299              * than another unrelated functional interface type for the scanned expression.
1300              */
1301             class MostSpecificFunctionReturnChecker extends DeferredAttr.PolyScanner {
1302 
1303                 final Type tRet;
1304                 final Type sRet;
1305                 boolean result;
1306 
1307                 /** Parameters {@code t} and {@code s} are unrelated functional interface types. */
1308                 MostSpecificFunctionReturnChecker(Type tRet, Type sRet) {
1309                     this.tRet = tRet;
1310                     this.sRet = sRet;
1311                     result = true;
1312                 }
1313 
1314                 @Override
1315                 void skip(JCTree tree) {
1316                     result &amp;= false;
1317                 }
1318 
1319                 @Override
1320                 public void visitConditional(JCConditional tree) {
1321                     scan(asExpr(tree.truepart));
1322                     scan(asExpr(tree.falsepart));
1323                 }
1324 
1325                 @Override
1326                 public void visitReference(JCMemberReference tree) {
1327                     if (sRet.hasTag(VOID)) {
1328                         result &amp;= true;
1329                     } else if (tRet.hasTag(VOID)) {
1330                         result &amp;= false;
1331                     } else if (tRet.isPrimitive() != sRet.isPrimitive()) {
1332                         boolean retValIsPrimitive =
1333                                 tree.refPolyKind == PolyKind.STANDALONE &amp;&amp;
1334                                 tree.sym.type.getReturnType().isPrimitive();
1335                         result &amp;= (retValIsPrimitive == tRet.isPrimitive()) &amp;&amp;
1336                                   (retValIsPrimitive != sRet.isPrimitive());
1337                     } else {
1338                         result &amp;= compatibleBySubtyping(tRet, sRet);
1339                     }
1340                 }
1341 
1342                 @Override
1343                 public void visitParens(JCParens tree) {
1344                     scan(asExpr(tree.expr));
1345                 }
1346 
1347                 @Override
1348                 public void visitLambda(JCLambda tree) {
1349                     if (sRet.hasTag(VOID)) {
1350                         result &amp;= true;
1351                     } else if (tRet.hasTag(VOID)) {
1352                         result &amp;= false;
1353                     } else {
1354                         List&lt;JCExpression&gt; lambdaResults = lambdaResults(tree);
1355                         if (!lambdaResults.isEmpty() &amp;&amp; unrelatedFunctionalInterfaces(tRet, sRet)) {
1356                             for (JCExpression expr : lambdaResults) {
1357                                 result &amp;= functionalInterfaceMostSpecific(tRet, sRet, expr);
1358                             }
1359                         } else if (!lambdaResults.isEmpty() &amp;&amp; tRet.isPrimitive() != sRet.isPrimitive()) {
1360                             for (JCExpression expr : lambdaResults) {
1361                                 boolean retValIsPrimitive = expr.isStandalone() &amp;&amp; expr.type.isPrimitive();
1362                                 result &amp;= (retValIsPrimitive == tRet.isPrimitive()) &amp;&amp;
1363                                         (retValIsPrimitive != sRet.isPrimitive());
1364                             }
1365                         } else {
1366                             result &amp;= compatibleBySubtyping(tRet, sRet);
1367                         }
1368                     }
1369                 }
1370                 //where
1371 
1372                 private List&lt;JCExpression&gt; lambdaResults(JCLambda lambda) {
1373                     if (lambda.getBodyKind() == JCTree.JCLambda.BodyKind.EXPRESSION) {
1374                         return List.of(asExpr((JCExpression) lambda.body));
1375                     } else {
1376                         final ListBuffer&lt;JCExpression&gt; buffer = new ListBuffer&lt;&gt;();
1377                         DeferredAttr.LambdaReturnScanner lambdaScanner =
1378                                 new DeferredAttr.LambdaReturnScanner() {
1379                                     @Override
1380                                     public void visitReturn(JCReturn tree) {
1381                                         if (tree.expr != null) {
1382                                             buffer.append(asExpr(tree.expr));
1383                                         }
1384                                     }
1385                                 };
1386                         lambdaScanner.scan(lambda.body);
1387                         return buffer.toList();
1388                     }
1389                 }
1390 
1391                 private JCExpression asExpr(JCExpression expr) {
1392                     if (expr.type.hasTag(DEFERRED)) {
1393                         JCTree speculativeTree = ((DeferredType)expr.type).speculativeTree(deferredAttrContext);
1394                         if (speculativeTree != deferredAttr.stuckTree) {
1395                             expr = (JCExpression)speculativeTree;
1396                         }
1397                     }
1398                     return expr;
1399                 }
1400             }
1401 
1402         }
1403 
1404         public MethodCheck mostSpecificCheck(List&lt;Type&gt; actuals) {
1405             Assert.error(&quot;Cannot get here!&quot;);
1406             return null;
1407         }
1408     }
1409 
1410     public static class InapplicableMethodException extends RuntimeException {
1411         private static final long serialVersionUID = 0;
1412 
1413         transient JCDiagnostic diagnostic;
1414 
1415         InapplicableMethodException(JCDiagnostic diag) {
1416             this.diagnostic = diag;
1417         }
1418 
1419         public JCDiagnostic getDiagnostic() {
1420             return diagnostic;
1421         }
1422     }
1423 
1424 /* ***************************************************************************
1425  *  Symbol lookup
1426  *  the following naming conventions for arguments are used
1427  *
1428  *       env      is the environment where the symbol was mentioned
1429  *       site     is the type of which the symbol is a member
1430  *       name     is the symbol&#39;s name
1431  *                if no arguments are given
1432  *       argtypes are the value arguments, if we search for a method
1433  *
1434  *  If no symbol was found, a ResolveError detailing the problem is returned.
1435  ****************************************************************************/
1436 
1437     /** Find field. Synthetic fields are always skipped.
1438      *  @param env     The current environment.
1439      *  @param site    The original type from where the selection takes place.
1440      *  @param name    The name of the field.
1441      *  @param c       The class to search for the field. This is always
1442      *                 a superclass or implemented interface of site&#39;s class.
1443      */
1444     Symbol findField(Env&lt;AttrContext&gt; env,
1445                      Type site,
1446                      Name name,
1447                      TypeSymbol c) {
1448         while (c.type.hasTag(TYPEVAR))
1449             c = c.type.getUpperBound().tsym;
1450         Symbol bestSoFar = varNotFound;
1451         Symbol sym;
1452         for (Symbol s : c.members().getSymbolsByName(name)) {
1453             if (s.kind == VAR &amp;&amp; (s.flags_field &amp; SYNTHETIC) == 0) {
1454                 return isAccessible(env, site, s)
1455                     ? s : new AccessError(env, site, s);
1456             }
1457         }
1458         Type st = types.supertype(c.type);
1459         if (st != null &amp;&amp; (st.hasTag(CLASS) || st.hasTag(TYPEVAR))) {
1460             sym = findField(env, site, name, st.tsym);
1461             bestSoFar = bestOf(bestSoFar, sym);
1462         }
1463         for (List&lt;Type&gt; l = types.interfaces(c.type);
1464              bestSoFar.kind != AMBIGUOUS &amp;&amp; l.nonEmpty();
1465              l = l.tail) {
1466             sym = findField(env, site, name, l.head.tsym);
1467             if (bestSoFar.exists() &amp;&amp; sym.exists() &amp;&amp;
1468                 sym.owner != bestSoFar.owner)
1469                 bestSoFar = new AmbiguityError(bestSoFar, sym);
1470             else
1471                 bestSoFar = bestOf(bestSoFar, sym);
1472         }
1473         return bestSoFar;
1474     }
1475 
1476     /** Resolve a field identifier, throw a fatal error if not found.
1477      *  @param pos       The position to use for error reporting.
1478      *  @param env       The environment current at the method invocation.
1479      *  @param site      The type of the qualifying expression, in which
1480      *                   identifier is searched.
1481      *  @param name      The identifier&#39;s name.
1482      */
1483     public VarSymbol resolveInternalField(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
1484                                           Type site, Name name) {
1485         Symbol sym = findField(env, site, name, site.tsym);
1486         if (sym.kind == VAR) return (VarSymbol)sym;
1487         else throw new FatalError(
1488                  diags.fragment(Fragments.FatalErrCantLocateField(name)));
1489     }
1490 
1491     /** Find unqualified variable or field with given name.
1492      *  Synthetic fields always skipped.
1493      *  @param env     The current environment.
1494      *  @param name    The name of the variable or field.
1495      */
1496     Symbol findVar(Env&lt;AttrContext&gt; env, Name name) {
1497         Symbol bestSoFar = varNotFound;
1498         Env&lt;AttrContext&gt; env1 = env;
1499         boolean staticOnly = false;
1500         while (env1.outer != null) {
1501             Symbol sym = null;
1502             if (isStatic(env1)) staticOnly = true;
1503             for (Symbol s : env1.info.scope.getSymbolsByName(name)) {
1504                 if (s.kind == VAR &amp;&amp; (s.flags_field &amp; SYNTHETIC) == 0) {
1505                     sym = s;
1506                     break;
1507                 }
1508             }
1509             if (sym == null) {
1510                 sym = findField(env1, env1.enclClass.sym.type, name, env1.enclClass.sym);
1511             }
1512             if (sym.exists()) {
1513                 if (staticOnly &amp;&amp;
1514                     sym.kind == VAR &amp;&amp;
1515                         // if it is a field
1516                         (sym.owner.kind == TYP ||
1517                         // or it is a local variable but it is not declared inside of the static local type
1518                         // only records so far, then error
1519                         (sym.owner.kind == MTH) &amp;&amp;
1520                         (env.enclClass.sym.flags() &amp; STATIC) != 0 &amp;&amp;
1521                         sym.enclClass() != env.enclClass.sym) &amp;&amp;
1522                     (sym.flags() &amp; STATIC) == 0)
1523                     return new StaticError(sym);
1524                 else
1525                     return sym;
1526             } else {
1527                 bestSoFar = bestOf(bestSoFar, sym);
1528             }
1529 
1530             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
1531             env1 = env1.outer;
1532         }
1533 
1534         Symbol sym = findField(env, syms.predefClass.type, name, syms.predefClass);
1535         if (sym.exists())
1536             return sym;
1537         if (bestSoFar.exists())
1538             return bestSoFar;
1539 
1540         Symbol origin = null;
1541         for (Scope sc : new Scope[] { env.toplevel.namedImportScope, env.toplevel.starImportScope }) {
1542             for (Symbol currentSymbol : sc.getSymbolsByName(name)) {
1543                 if (currentSymbol.kind != VAR)
1544                     continue;
1545                 // invariant: sym.kind == Symbol.Kind.VAR
1546                 if (!bestSoFar.kind.isResolutionError() &amp;&amp;
1547                     currentSymbol.owner != bestSoFar.owner)
1548                     return new AmbiguityError(bestSoFar, currentSymbol);
1549                 else if (!bestSoFar.kind.betterThan(VAR)) {
1550                     origin = sc.getOrigin(currentSymbol).owner;
1551                     bestSoFar = isAccessible(env, origin.type, currentSymbol)
1552                         ? currentSymbol : new AccessError(env, origin.type, currentSymbol);
1553                 }
1554             }
1555             if (bestSoFar.exists()) break;
1556         }
1557         if (bestSoFar.kind == VAR &amp;&amp; bestSoFar.owner.type != origin.type)
1558             return bestSoFar.clone(origin);
1559         else
1560             return bestSoFar;
1561     }
1562 
1563     Warner noteWarner = new Warner();
1564 
1565     /** Select the best method for a call site among two choices.
1566      *  @param env              The current environment.
1567      *  @param site             The original type from where the
1568      *                          selection takes place.
1569      *  @param argtypes         The invocation&#39;s value arguments,
1570      *  @param typeargtypes     The invocation&#39;s type arguments,
1571      *  @param sym              Proposed new best match.
1572      *  @param bestSoFar        Previously found best match.
1573      *  @param allowBoxing Allow boxing conversions of arguments.
1574      *  @param useVarargs Box trailing arguments into an array for varargs.
1575      */
1576     @SuppressWarnings(&quot;fallthrough&quot;)
1577     Symbol selectBest(Env&lt;AttrContext&gt; env,
1578                       Type site,
1579                       List&lt;Type&gt; argtypes,
1580                       List&lt;Type&gt; typeargtypes,
1581                       Symbol sym,
1582                       Symbol bestSoFar,
1583                       boolean allowBoxing,
1584                       boolean useVarargs) {
1585         if (sym.kind == ERR ||
1586                 (site.tsym != sym.owner &amp;&amp; !sym.isInheritedIn(site.tsym, types)) ||
1587                 !notOverriddenIn(site, sym)) {
1588             return bestSoFar;
1589         } else if (useVarargs &amp;&amp; (sym.flags() &amp; VARARGS) == 0) {
1590             return bestSoFar.kind.isResolutionError() ?
1591                     new BadVarargsMethod((ResolveError)bestSoFar.baseSymbol()) :
1592                     bestSoFar;
1593         }
1594         Assert.check(!sym.kind.isResolutionError());
1595         try {
1596             types.noWarnings.clear();
1597             Type mt = rawInstantiate(env, site, sym, null, argtypes, typeargtypes,
1598                                allowBoxing, useVarargs, types.noWarnings);
1599             currentResolutionContext.addApplicableCandidate(sym, mt);
1600         } catch (InapplicableMethodException ex) {
1601             currentResolutionContext.addInapplicableCandidate(sym, ex.getDiagnostic());
1602             switch (bestSoFar.kind) {
1603                 case ABSENT_MTH:
1604                     return new InapplicableSymbolError(currentResolutionContext);
1605                 case WRONG_MTH:
1606                     bestSoFar = new InapplicableSymbolsError(currentResolutionContext);
1607                 default:
1608                     return bestSoFar;
1609             }
1610         }
1611         if (!isAccessible(env, site, sym)) {
1612             return (bestSoFar.kind == ABSENT_MTH)
1613                 ? new AccessError(env, site, sym)
1614                 : bestSoFar;
1615         }
1616         return (bestSoFar.kind.isResolutionError() &amp;&amp; bestSoFar.kind != AMBIGUOUS)
1617             ? sym
1618             : mostSpecific(argtypes, sym, bestSoFar, env, site, useVarargs);
1619     }
1620 
1621     /* Return the most specific of the two methods for a call,
1622      *  given that both are accessible and applicable.
1623      *  @param m1               A new candidate for most specific.
1624      *  @param m2               The previous most specific candidate.
1625      *  @param env              The current environment.
1626      *  @param site             The original type from where the selection
1627      *                          takes place.
1628      *  @param allowBoxing Allow boxing conversions of arguments.
1629      *  @param useVarargs Box trailing arguments into an array for varargs.
1630      */
1631     Symbol mostSpecific(List&lt;Type&gt; argtypes, Symbol m1,
1632                         Symbol m2,
1633                         Env&lt;AttrContext&gt; env,
1634                         final Type site,
1635                         boolean useVarargs) {
1636         switch (m2.kind) {
1637         case MTH:
1638             if (m1 == m2) return m1;
1639             boolean m1SignatureMoreSpecific =
1640                     signatureMoreSpecific(argtypes, env, site, m1, m2, useVarargs);
1641             boolean m2SignatureMoreSpecific =
1642                     signatureMoreSpecific(argtypes, env, site, m2, m1, useVarargs);
1643             if (m1SignatureMoreSpecific &amp;&amp; m2SignatureMoreSpecific) {
1644                 Type mt1 = types.memberType(site, m1);
1645                 Type mt2 = types.memberType(site, m2);
1646                 if (!types.overrideEquivalent(mt1, mt2))
1647                     return ambiguityError(m1, m2);
1648 
1649                 // same signature; select (a) the non-bridge method, or
1650                 // (b) the one that overrides the other, or (c) the concrete
1651                 // one, or (d) merge both abstract signatures
1652                 if ((m1.flags() &amp; BRIDGE) != (m2.flags() &amp; BRIDGE))
1653                     return ((m1.flags() &amp; BRIDGE) != 0) ? m2 : m1;
1654 
1655                 if (m1.baseSymbol() == m2.baseSymbol()) {
1656                     // this is the same imported symbol which has been cloned twice.
1657                     // Return the first one (either will do).
1658                     return m1;
1659                 }
1660 
1661                 // if one overrides or hides the other, use it
1662                 TypeSymbol m1Owner = (TypeSymbol)m1.owner;
1663                 TypeSymbol m2Owner = (TypeSymbol)m2.owner;
1664                 // the two owners can never be the same if the target methods are compiled from source,
1665                 // but we need to protect against cases where the methods are defined in some classfile
1666                 // and make sure we issue an ambiguity error accordingly (by skipping the logic below).
1667                 if (m1Owner != m2Owner) {
1668                     if (types.asSuper(m1Owner.type, m2Owner) != null &amp;&amp;
1669                         ((m1.owner.flags_field &amp; INTERFACE) == 0 ||
1670                          (m2.owner.flags_field &amp; INTERFACE) != 0) &amp;&amp;
1671                         m1.overrides(m2, m1Owner, types, false))
1672                         return m1;
1673                     if (types.asSuper(m2Owner.type, m1Owner) != null &amp;&amp;
1674                         ((m2.owner.flags_field &amp; INTERFACE) == 0 ||
1675                          (m1.owner.flags_field &amp; INTERFACE) != 0) &amp;&amp;
1676                         m2.overrides(m1, m2Owner, types, false))
1677                         return m2;
1678                 }
1679                 boolean m1Abstract = (m1.flags() &amp; ABSTRACT) != 0;
1680                 boolean m2Abstract = (m2.flags() &amp; ABSTRACT) != 0;
1681                 if (m1Abstract &amp;&amp; !m2Abstract) return m2;
1682                 if (m2Abstract &amp;&amp; !m1Abstract) return m1;
1683                 // both abstract or both concrete
1684                 return ambiguityError(m1, m2);
1685             }
1686             if (m1SignatureMoreSpecific) return m1;
1687             if (m2SignatureMoreSpecific) return m2;
1688             return ambiguityError(m1, m2);
1689         case AMBIGUOUS:
1690             //compare m1 to ambiguous methods in m2
1691             AmbiguityError e = (AmbiguityError)m2.baseSymbol();
1692             boolean m1MoreSpecificThanAnyAmbiguous = true;
1693             boolean allAmbiguousMoreSpecificThanM1 = true;
1694             for (Symbol s : e.ambiguousSyms) {
1695                 Symbol moreSpecific = mostSpecific(argtypes, m1, s, env, site, useVarargs);
1696                 m1MoreSpecificThanAnyAmbiguous &amp;= moreSpecific == m1;
1697                 allAmbiguousMoreSpecificThanM1 &amp;= moreSpecific == s;
1698             }
1699             if (m1MoreSpecificThanAnyAmbiguous)
1700                 return m1;
1701             //if m1 is more specific than some ambiguous methods, but other ambiguous methods are
1702             //more specific than m1, add it as a new ambiguous method:
1703             if (!allAmbiguousMoreSpecificThanM1)
1704                 e.addAmbiguousSymbol(m1);
1705             return e;
1706         default:
1707             throw new AssertionError();
1708         }
1709     }
1710     //where
1711     private boolean signatureMoreSpecific(List&lt;Type&gt; actuals, Env&lt;AttrContext&gt; env, Type site, Symbol m1, Symbol m2, boolean useVarargs) {
1712         noteWarner.clear();
1713         int maxLength = Math.max(
1714                             Math.max(m1.type.getParameterTypes().length(), actuals.length()),
1715                             m2.type.getParameterTypes().length());
1716         MethodResolutionContext prevResolutionContext = currentResolutionContext;
1717         try {
1718             currentResolutionContext = new MethodResolutionContext();
1719             currentResolutionContext.step = prevResolutionContext.step;
1720             currentResolutionContext.methodCheck =
1721                     prevResolutionContext.methodCheck.mostSpecificCheck(actuals);
1722             Type mst = instantiate(env, site, m2, null,
1723                     adjustArgs(types.cvarLowerBounds(types.memberType(site, m1).getParameterTypes()), m1, maxLength, useVarargs), null,
1724                     false, useVarargs, noteWarner);
1725             return mst != null &amp;&amp;
1726                     !noteWarner.hasLint(Lint.LintCategory.UNCHECKED);
1727         } finally {
1728             currentResolutionContext = prevResolutionContext;
1729         }
1730     }
1731 
1732     List&lt;Type&gt; adjustArgs(List&lt;Type&gt; args, Symbol msym, int length, boolean allowVarargs) {
1733         if ((msym.flags() &amp; VARARGS) != 0 &amp;&amp; allowVarargs) {
1734             Type varargsElem = types.elemtype(args.last());
1735             if (varargsElem == null) {
1736                 Assert.error(&quot;Bad varargs = &quot; + args.last() + &quot; &quot; + msym);
1737             }
1738             List&lt;Type&gt; newArgs = args.reverse().tail.prepend(varargsElem).reverse();
1739             while (newArgs.length() &lt; length) {
1740                 newArgs = newArgs.append(newArgs.last());
1741             }
1742             return newArgs;
1743         } else {
1744             return args;
1745         }
1746     }
1747     //where
1748     Symbol ambiguityError(Symbol m1, Symbol m2) {
1749         if (((m1.flags() | m2.flags()) &amp; CLASH) != 0) {
1750             return (m1.flags() &amp; CLASH) == 0 ? m1 : m2;
1751         } else {
1752             return new AmbiguityError(m1, m2);
1753         }
1754     }
1755 
1756     Symbol findMethodInScope(Env&lt;AttrContext&gt; env,
1757             Type site,
1758             Name name,
1759             List&lt;Type&gt; argtypes,
1760             List&lt;Type&gt; typeargtypes,
1761             Scope sc,
1762             Symbol bestSoFar,
1763             boolean allowBoxing,
1764             boolean useVarargs,
1765             boolean abstractok) {
1766         for (Symbol s : sc.getSymbolsByName(name, new LookupFilter(abstractok))) {
1767             bestSoFar = selectBest(env, site, argtypes, typeargtypes, s,
1768                     bestSoFar, allowBoxing, useVarargs);
1769         }
1770         return bestSoFar;
1771     }
1772     //where
1773         class LookupFilter implements Filter&lt;Symbol&gt; {
1774 
1775             boolean abstractOk;
1776 
1777             LookupFilter(boolean abstractOk) {
1778                 this.abstractOk = abstractOk;
1779             }
1780 
1781             public boolean accepts(Symbol s) {
1782                 long flags = s.flags();
1783                 return s.kind == MTH &amp;&amp;
1784                         (flags &amp; SYNTHETIC) == 0 &amp;&amp;
1785                         (abstractOk ||
1786                         (flags &amp; DEFAULT) != 0 ||
1787                         (flags &amp; ABSTRACT) == 0);
1788             }
1789         }
1790 
1791     /** Find best qualified method matching given name, type and value
1792      *  arguments.
1793      *  @param env       The current environment.
1794      *  @param site      The original type from where the selection
1795      *                   takes place.
1796      *  @param name      The method&#39;s name.
1797      *  @param argtypes  The method&#39;s value arguments.
1798      *  @param typeargtypes The method&#39;s type arguments
1799      *  @param allowBoxing Allow boxing conversions of arguments.
1800      *  @param useVarargs Box trailing arguments into an array for varargs.
1801      */
1802     Symbol findMethod(Env&lt;AttrContext&gt; env,
1803                       Type site,
1804                       Name name,
1805                       List&lt;Type&gt; argtypes,
1806                       List&lt;Type&gt; typeargtypes,
1807                       boolean allowBoxing,
1808                       boolean useVarargs) {
1809         Symbol bestSoFar = methodNotFound;
1810         bestSoFar = findMethod(env,
1811                           site,
1812                           name,
1813                           argtypes,
1814                           typeargtypes,
1815                           site.tsym.type,
1816                           bestSoFar,
1817                           allowBoxing,
1818                           useVarargs);
1819         return bestSoFar;
1820     }
1821     // where
1822     private Symbol findMethod(Env&lt;AttrContext&gt; env,
1823                               Type site,
1824                               Name name,
1825                               List&lt;Type&gt; argtypes,
1826                               List&lt;Type&gt; typeargtypes,
1827                               Type intype,
1828                               Symbol bestSoFar,
1829                               boolean allowBoxing,
1830                               boolean useVarargs) {
1831         @SuppressWarnings({&quot;unchecked&quot;,&quot;rawtypes&quot;})
1832         List&lt;Type&gt;[] itypes = (List&lt;Type&gt;[])new List[] { List.&lt;Type&gt;nil(), List.&lt;Type&gt;nil() };
1833 
1834         InterfaceLookupPhase iphase = InterfaceLookupPhase.ABSTRACT_OK;
1835         for (TypeSymbol s : superclasses(intype)) {
1836             bestSoFar = findMethodInScope(env, site, name, argtypes, typeargtypes,
1837                     s.members(), bestSoFar, allowBoxing, useVarargs, true);
1838             if (name == names.init) return bestSoFar;
1839             iphase = (iphase == null) ? null : iphase.update(s, this);
1840             if (iphase != null) {
1841                 for (Type itype : types.interfaces(s.type)) {
1842                     itypes[iphase.ordinal()] = types.union(types.closure(itype), itypes[iphase.ordinal()]);
1843                 }
1844             }
1845         }
1846 
1847         Symbol concrete = bestSoFar.kind.isValid() &amp;&amp;
1848                 (bestSoFar.flags() &amp; ABSTRACT) == 0 ?
1849                 bestSoFar : methodNotFound;
1850 
1851         for (InterfaceLookupPhase iphase2 : InterfaceLookupPhase.values()) {
1852             //keep searching for abstract methods
1853             for (Type itype : itypes[iphase2.ordinal()]) {
1854                 if (!itype.isInterface()) continue; //skip j.l.Object (included by Types.closure())
1855                 if (iphase2 == InterfaceLookupPhase.DEFAULT_OK &amp;&amp;
1856                         (itype.tsym.flags() &amp; DEFAULT) == 0) continue;
1857                 bestSoFar = findMethodInScope(env, site, name, argtypes, typeargtypes,
1858                         itype.tsym.members(), bestSoFar, allowBoxing, useVarargs, true);
1859                 if (concrete != bestSoFar &amp;&amp;
1860                     concrete.kind.isValid() &amp;&amp;
1861                     bestSoFar.kind.isValid() &amp;&amp;
1862                         types.isSubSignature(concrete.type, bestSoFar.type)) {
1863                     //this is an hack - as javac does not do full membership checks
1864                     //most specific ends up comparing abstract methods that might have
1865                     //been implemented by some concrete method in a subclass and,
1866                     //because of raw override, it is possible for an abstract method
1867                     //to be more specific than the concrete method - so we need
1868                     //to explicitly call that out (see CR 6178365)
1869                     bestSoFar = concrete;
1870                 }
1871             }
1872         }
1873         return bestSoFar;
1874     }
1875 
1876     enum InterfaceLookupPhase {
1877         ABSTRACT_OK() {
1878             @Override
1879             InterfaceLookupPhase update(Symbol s, Resolve rs) {
1880                 //We should not look for abstract methods if receiver is a concrete class
1881                 //(as concrete classes are expected to implement all abstracts coming
1882                 //from superinterfaces)
1883                 if ((s.flags() &amp; (ABSTRACT | INTERFACE | ENUM)) != 0) {
1884                     return this;
1885                 } else {
1886                     return DEFAULT_OK;
1887                 }
1888             }
1889         },
1890         DEFAULT_OK() {
1891             @Override
1892             InterfaceLookupPhase update(Symbol s, Resolve rs) {
1893                 return this;
1894             }
1895         };
1896 
1897         abstract InterfaceLookupPhase update(Symbol s, Resolve rs);
1898     }
1899 
1900     /**
1901      * Return an Iterable object to scan the superclasses of a given type.
1902      * It&#39;s crucial that the scan is done lazily, as we don&#39;t want to accidentally
1903      * access more supertypes than strictly needed (as this could trigger completion
1904      * errors if some of the not-needed supertypes are missing/ill-formed).
1905      */
1906     Iterable&lt;TypeSymbol&gt; superclasses(final Type intype) {
1907         return () -&gt; new Iterator&lt;TypeSymbol&gt;() {
1908 
1909             List&lt;TypeSymbol&gt; seen = List.nil();
1910             TypeSymbol currentSym = symbolFor(intype);
1911             TypeSymbol prevSym = null;
1912 
1913             public boolean hasNext() {
1914                 if (currentSym == syms.noSymbol) {
1915                     currentSym = symbolFor(types.supertype(prevSym.type));
1916                 }
1917                 return currentSym != null;
1918             }
1919 
1920             public TypeSymbol next() {
1921                 prevSym = currentSym;
1922                 currentSym = syms.noSymbol;
1923                 Assert.check(prevSym != null || prevSym != syms.noSymbol);
1924                 return prevSym;
1925             }
1926 
1927             public void remove() {
1928                 throw new UnsupportedOperationException();
1929             }
1930 
1931             TypeSymbol symbolFor(Type t) {
1932                 if (!t.hasTag(CLASS) &amp;&amp;
1933                         !t.hasTag(TYPEVAR)) {
1934                     return null;
1935                 }
1936                 t = types.skipTypeVars(t, false);
1937                 if (seen.contains(t.tsym)) {
1938                     //degenerate case in which we have a circular
1939                     //class hierarchy - because of ill-formed classfiles
1940                     return null;
1941                 }
1942                 seen = seen.prepend(t.tsym);
1943                 return t.tsym;
1944             }
1945         };
1946     }
1947 
1948     /** Find unqualified method matching given name, type and value arguments.
1949      *  @param env       The current environment.
1950      *  @param name      The method&#39;s name.
1951      *  @param argtypes  The method&#39;s value arguments.
1952      *  @param typeargtypes  The method&#39;s type arguments.
1953      *  @param allowBoxing Allow boxing conversions of arguments.
1954      *  @param useVarargs Box trailing arguments into an array for varargs.
1955      */
1956     Symbol findFun(Env&lt;AttrContext&gt; env, Name name,
1957                    List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes,
1958                    boolean allowBoxing, boolean useVarargs) {
1959         Symbol bestSoFar = methodNotFound;
1960         Env&lt;AttrContext&gt; env1 = env;
1961         boolean staticOnly = false;
1962         while (env1.outer != null) {
1963             if (isStatic(env1)) staticOnly = true;
1964             Assert.check(env1.info.preferredTreeForDiagnostics == null);
1965             env1.info.preferredTreeForDiagnostics = env.tree;
1966             try {
1967                 Symbol sym = findMethod(
1968                     env1, env1.enclClass.sym.type, name, argtypes, typeargtypes,
1969                     allowBoxing, useVarargs);
1970                 if (sym.exists()) {
1971                     if (staticOnly &amp;&amp;
1972                         sym.kind == MTH &amp;&amp;
1973                         sym.owner.kind == TYP &amp;&amp;
1974                         (sym.flags() &amp; STATIC) == 0) return new StaticError(sym);
1975                     else return sym;
1976                 } else {
1977                     bestSoFar = bestOf(bestSoFar, sym);
1978                 }
1979             } finally {
1980                 env1.info.preferredTreeForDiagnostics = null;
1981             }
1982             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
1983             env1 = env1.outer;
1984         }
1985 
1986         Symbol sym = findMethod(env, syms.predefClass.type, name, argtypes,
1987                                 typeargtypes, allowBoxing, useVarargs);
1988         if (sym.exists())
1989             return sym;
1990 
1991         for (Symbol currentSym : env.toplevel.namedImportScope.getSymbolsByName(name)) {
1992             Symbol origin = env.toplevel.namedImportScope.getOrigin(currentSym).owner;
1993             if (currentSym.kind == MTH) {
1994                 if (currentSym.owner.type != origin.type)
1995                     currentSym = currentSym.clone(origin);
1996                 if (!isAccessible(env, origin.type, currentSym))
1997                     currentSym = new AccessError(env, origin.type, currentSym);
1998                 bestSoFar = selectBest(env, origin.type,
1999                                        argtypes, typeargtypes,
2000                                        currentSym, bestSoFar,
2001                                        allowBoxing, useVarargs);
2002             }
2003         }
2004         if (bestSoFar.exists())
2005             return bestSoFar;
2006 
2007         for (Symbol currentSym : env.toplevel.starImportScope.getSymbolsByName(name)) {
2008             Symbol origin = env.toplevel.starImportScope.getOrigin(currentSym).owner;
2009             if (currentSym.kind == MTH) {
2010                 if (currentSym.owner.type != origin.type)
2011                     currentSym = currentSym.clone(origin);
2012                 if (!isAccessible(env, origin.type, currentSym))
2013                     currentSym = new AccessError(env, origin.type, currentSym);
2014                 bestSoFar = selectBest(env, origin.type,
2015                                        argtypes, typeargtypes,
2016                                        currentSym, bestSoFar,
2017                                        allowBoxing, useVarargs);
2018             }
2019         }
2020         return bestSoFar;
2021     }
2022 
2023     /** Load toplevel or member class with given fully qualified name and
2024      *  verify that it is accessible.
2025      *  @param env       The current environment.
2026      *  @param name      The fully qualified name of the class to be loaded.
2027      */
2028     Symbol loadClass(Env&lt;AttrContext&gt; env, Name name, RecoveryLoadClass recoveryLoadClass) {
2029         try {
2030             ClassSymbol c = finder.loadClass(env.toplevel.modle, name);
2031             return isAccessible(env, c) ? c : new AccessError(env, null, c);
2032         } catch (ClassFinder.BadClassFile err) {
2033             return new BadClassFileError(err);
2034         } catch (CompletionFailure ex) {
2035             Symbol candidate = recoveryLoadClass.loadClass(env, name);
2036 
2037             if (candidate != null) {
2038                 return candidate;
2039             }
2040 
2041             return typeNotFound;
2042         }
2043     }
2044 
2045     public interface RecoveryLoadClass {
2046         Symbol loadClass(Env&lt;AttrContext&gt; env, Name name);
2047     }
2048 
2049     private final RecoveryLoadClass noRecovery = (env, name) -&gt; null;
2050 
2051     private final RecoveryLoadClass doRecoveryLoadClass = new RecoveryLoadClass() {
2052         @Override public Symbol loadClass(Env&lt;AttrContext&gt; env, Name name) {
2053             List&lt;Name&gt; candidates = Convert.classCandidates(name);
2054             return lookupInvisibleSymbol(env, name,
2055                                          n -&gt; () -&gt; createCompoundIterator(candidates,
2056                                                                            c -&gt; syms.getClassesForName(c)
2057                                                                                     .iterator()),
2058                                          (ms, n) -&gt; {
2059                 for (Name candidate : candidates) {
2060                     try {
2061                         return finder.loadClass(ms, candidate);
2062                     } catch (CompletionFailure cf) {
2063                         //ignore
2064                     }
2065                 }
2066                 return null;
2067             }, sym -&gt; sym.kind == Kind.TYP, typeNotFound);
2068         }
2069     };
2070 
2071     private final RecoveryLoadClass namedImportScopeRecovery = (env, name) -&gt; {
2072         Scope importScope = env.toplevel.namedImportScope;
2073         Symbol existing = importScope.findFirst(Convert.shortName(name),
2074                                                 sym -&gt; sym.kind == TYP &amp;&amp; sym.flatName() == name);
2075 
2076         if (existing != null) {
2077             return new InvisibleSymbolError(env, true, existing);
2078         }
2079         return null;
2080     };
2081 
2082     private final RecoveryLoadClass starImportScopeRecovery = (env, name) -&gt; {
2083         Scope importScope = env.toplevel.starImportScope;
2084         Symbol existing = importScope.findFirst(Convert.shortName(name),
2085                                                 sym -&gt; sym.kind == TYP &amp;&amp; sym.flatName() == name);
2086 
2087         if (existing != null) {
2088             try {
2089                 existing = finder.loadClass(existing.packge().modle, name);
2090 
2091                 return new InvisibleSymbolError(env, true, existing);
2092             } catch (CompletionFailure cf) {
2093                 //ignore
2094             }
2095         }
2096 
2097         return null;
2098     };
2099 
2100     Symbol lookupPackage(Env&lt;AttrContext&gt; env, Name name) {
2101         PackageSymbol pack = syms.lookupPackage(env.toplevel.modle, name);
2102 
2103         if (allowModules &amp;&amp; isImportOnDemand(env, name)) {
2104             if (pack.members().isEmpty()) {
2105                 return lookupInvisibleSymbol(env, name, syms::getPackagesForName, syms::enterPackage, sym -&gt; {
2106                     sym.complete();
2107                     return !sym.members().isEmpty();
2108                 }, pack);
2109             }
2110         }
2111 
2112         return pack;
2113     }
2114 
2115     private boolean isImportOnDemand(Env&lt;AttrContext&gt; env, Name name) {
2116         if (!env.tree.hasTag(IMPORT))
2117             return false;
2118 
2119         JCTree qualid = ((JCImport) env.tree).qualid;
2120 
2121         if (!qualid.hasTag(SELECT))
2122             return false;
2123 
2124         if (TreeInfo.name(qualid) != names.asterisk)
2125             return false;
2126 
2127         return TreeInfo.fullName(((JCFieldAccess) qualid).selected) == name;
2128     }
2129 
2130     private &lt;S extends Symbol&gt; Symbol lookupInvisibleSymbol(Env&lt;AttrContext&gt; env,
2131                                                             Name name,
2132                                                             Function&lt;Name, Iterable&lt;S&gt;&gt; get,
2133                                                             BiFunction&lt;ModuleSymbol, Name, S&gt; load,
2134                                                             Predicate&lt;S&gt; validate,
2135                                                             Symbol defaultResult) {
2136         //even if a class/package cannot be found in the current module and among packages in modules
2137         //it depends on that are exported for any or this module, the class/package may exist internally
2138         //in some of these modules, or may exist in a module on which this module does not depend.
2139         //Provide better diagnostic in such cases by looking for the class in any module:
2140         Iterable&lt;? extends S&gt; candidates = get.apply(name);
2141 
2142         for (S sym : candidates) {
2143             if (validate.test(sym))
2144                 return createInvisibleSymbolError(env, sym);
2145         }
2146 
2147         Set&lt;ModuleSymbol&gt; recoverableModules = new HashSet&lt;&gt;(syms.getAllModules());
2148 
2149         recoverableModules.add(syms.unnamedModule);
2150         recoverableModules.remove(env.toplevel.modle);
2151 
2152         for (ModuleSymbol ms : recoverableModules) {
2153             //avoid overly eager completing classes from source-based modules, as those
2154             //may not be completable with the current compiler settings:
2155             if (ms.sourceLocation == null) {
2156                 if (ms.classLocation == null) {
2157                     ms = moduleFinder.findModule(ms);
2158                 }
2159 
2160                 if (ms.kind != ERR) {
2161                     S sym = load.apply(ms, name);
2162 
2163                     if (sym != null &amp;&amp; validate.test(sym)) {
2164                         return createInvisibleSymbolError(env, sym);
2165                     }
2166                 }
2167             }
2168         }
2169 
2170         return defaultResult;
2171     }
2172 
2173     private Symbol createInvisibleSymbolError(Env&lt;AttrContext&gt; env, Symbol sym) {
2174         if (symbolPackageVisible(env, sym)) {
2175             return new AccessError(env, null, sym);
2176         } else {
2177             return new InvisibleSymbolError(env, false, sym);
2178         }
2179     }
2180 
2181     private boolean symbolPackageVisible(Env&lt;AttrContext&gt; env, Symbol sym) {
2182         ModuleSymbol envMod = env.toplevel.modle;
2183         PackageSymbol symPack = sym.packge();
2184         return envMod == symPack.modle ||
2185                envMod.visiblePackages.containsKey(symPack.fullname);
2186     }
2187 
2188     /**
2189      * Find a type declared in a scope (not inherited).  Return null
2190      * if none is found.
2191      *  @param env       The current environment.
2192      *  @param site      The original type from where the selection takes
2193      *                   place.
2194      *  @param name      The type&#39;s name.
2195      *  @param c         The class to search for the member type. This is
2196      *                   always a superclass or implemented interface of
2197      *                   site&#39;s class.
2198      */
2199     Symbol findImmediateMemberType(Env&lt;AttrContext&gt; env,
2200                                    Type site,
2201                                    Name name,
2202                                    TypeSymbol c) {
2203         for (Symbol sym : c.members().getSymbolsByName(name)) {
2204             if (sym.kind == TYP) {
2205                 return isAccessible(env, site, sym)
2206                     ? sym
2207                     : new AccessError(env, site, sym);
2208             }
2209         }
2210         return typeNotFound;
2211     }
2212 
2213     /** Find a member type inherited from a superclass or interface.
2214      *  @param env       The current environment.
2215      *  @param site      The original type from where the selection takes
2216      *                   place.
2217      *  @param name      The type&#39;s name.
2218      *  @param c         The class to search for the member type. This is
2219      *                   always a superclass or implemented interface of
2220      *                   site&#39;s class.
2221      */
2222     Symbol findInheritedMemberType(Env&lt;AttrContext&gt; env,
2223                                    Type site,
2224                                    Name name,
2225                                    TypeSymbol c) {
2226         Symbol bestSoFar = typeNotFound;
2227         Symbol sym;
2228         Type st = types.supertype(c.type);
2229         if (st != null &amp;&amp; st.hasTag(CLASS)) {
2230             sym = findMemberType(env, site, name, st.tsym);
2231             bestSoFar = bestOf(bestSoFar, sym);
2232         }
2233         for (List&lt;Type&gt; l = types.interfaces(c.type);
2234              bestSoFar.kind != AMBIGUOUS &amp;&amp; l.nonEmpty();
2235              l = l.tail) {
2236             sym = findMemberType(env, site, name, l.head.tsym);
2237             if (!bestSoFar.kind.isResolutionError() &amp;&amp;
2238                 !sym.kind.isResolutionError() &amp;&amp;
2239                 sym.owner != bestSoFar.owner)
2240                 bestSoFar = new AmbiguityError(bestSoFar, sym);
2241             else
2242                 bestSoFar = bestOf(bestSoFar, sym);
2243         }
2244         return bestSoFar;
2245     }
2246 
2247     /** Find qualified member type.
2248      *  @param env       The current environment.
2249      *  @param site      The original type from where the selection takes
2250      *                   place.
2251      *  @param name      The type&#39;s name.
2252      *  @param c         The class to search for the member type. This is
2253      *                   always a superclass or implemented interface of
2254      *                   site&#39;s class.
2255      */
2256     Symbol findMemberType(Env&lt;AttrContext&gt; env,
2257                           Type site,
2258                           Name name,
2259                           TypeSymbol c) {
2260         return findMemberTypeInternal(env,site, name, c);
2261     }
2262 
2263     /** Find qualified member type.
2264      *  @param env       The current environment.
2265      *  @param site      The original type from where the selection takes
2266      *                   place.
2267      *  @param name      The type&#39;s name.
2268      *  @param c         The class to search for the member type. This is
2269      *                   always a superclass or implemented interface of
2270      *                   site&#39;s class.
2271      */
2272     Symbol findMemberTypeInternal(Env&lt;AttrContext&gt; env,
2273                           Type site,
2274                           Name name,
2275                           TypeSymbol c) {
2276         Symbol sym = findImmediateMemberType(env, site, name, c);
2277 
2278         if (sym != typeNotFound)
2279             return sym;
2280 
2281         return findInheritedMemberType(env, site, name, c);
2282 
2283     }
2284 
2285     /** Find a global type in given scope and load corresponding class.
2286      *  @param env       The current environment.
2287      *  @param scope     The scope in which to look for the type.
2288      *  @param name      The type&#39;s name.
2289      */
2290     Symbol findGlobalType(Env&lt;AttrContext&gt; env, Scope scope, Name name, RecoveryLoadClass recoveryLoadClass) {
2291         Symbol bestSoFar = typeNotFound;
2292         for (Symbol s : scope.getSymbolsByName(name)) {
2293             Symbol sym = loadClass(env, s.flatName(), recoveryLoadClass);
2294             if (bestSoFar.kind == TYP &amp;&amp; sym.kind == TYP &amp;&amp;
2295                 bestSoFar != sym)
2296                 return new AmbiguityError(bestSoFar, sym);
2297             else
2298                 bestSoFar = bestOf(bestSoFar, sym);
2299         }
2300         return bestSoFar;
2301     }
2302 
2303     Symbol findTypeVar(Env&lt;AttrContext&gt; env, Name name, boolean staticOnly) {
2304         for (Symbol sym : env.info.scope.getSymbolsByName(name)) {
2305             if (sym.kind == TYP) {
2306                 if (staticOnly &amp;&amp;
2307                     sym.type.hasTag(TYPEVAR) &amp;&amp;
2308                     sym.owner.kind == TYP)
2309                     return new StaticError(sym);
2310                 return sym;
2311             }
2312         }
2313         return typeNotFound;
2314     }
2315 
2316     /** Find an unqualified type symbol.
2317      *  @param env       The current environment.
2318      *  @param name      The type&#39;s name.
2319      */
2320     Symbol findType(Env&lt;AttrContext&gt; env, Name name) {
2321         return findTypeInternal(env, name);
2322     }
2323 
2324     /** Find an unqualified type symbol.
2325      *  @param env       The current environment.
2326      *  @param name      The type&#39;s name.
2327      */
2328     Symbol findTypeInternal(Env&lt;AttrContext&gt; env, Name name) {
2329         if (name == names.empty)
2330             return typeNotFound; // do not allow inadvertent &quot;lookup&quot; of anonymous types
2331         Symbol bestSoFar = typeNotFound;
2332         Symbol sym;
2333         boolean staticOnly = false;
2334         for (Env&lt;AttrContext&gt; env1 = env; env1.outer != null; env1 = env1.outer) {
2335             if (isStatic(env1)) staticOnly = true;
2336             // First, look for a type variable and the first member type
2337             final Symbol tyvar = findTypeVar(env1, name, staticOnly);
2338             sym = findImmediateMemberType(env1, env1.enclClass.sym.type,
2339                                           name, env1.enclClass.sym);
2340 
2341             // Return the type variable if we have it, and have no
2342             // immediate member, OR the type variable is for a method.
2343             if (tyvar != typeNotFound) {
2344                 if (env.baseClause || sym == typeNotFound ||
2345                     (tyvar.kind == TYP &amp;&amp; tyvar.exists() &amp;&amp;
2346                      tyvar.owner.kind == MTH)) {
2347                     return tyvar;
2348                 }
2349             }
2350 
2351             // If the environment is a class def, finish up,
2352             // otherwise, do the entire findMemberType
2353             if (sym == typeNotFound)
2354                 sym = findInheritedMemberType(env1, env1.enclClass.sym.type,
2355                                               name, env1.enclClass.sym);
2356 
2357             if (staticOnly &amp;&amp; sym.kind == TYP &amp;&amp;
2358                 sym.type.hasTag(CLASS) &amp;&amp;
2359                 sym.type.getEnclosingType().hasTag(CLASS) &amp;&amp;
2360                 env1.enclClass.sym.type.isParameterized() &amp;&amp;
2361                 sym.type.getEnclosingType().isParameterized())
2362                 return new StaticError(sym);
2363             else if (sym.exists()) return sym;
2364             else bestSoFar = bestOf(bestSoFar, sym);
2365 
2366             JCClassDecl encl = env1.baseClause ? (JCClassDecl)env1.tree : env1.enclClass;
2367             if ((encl.sym.flags() &amp; STATIC) != 0)
2368                 staticOnly = true;
2369         }
2370 
2371         if (!env.tree.hasTag(IMPORT)) {
2372             sym = findGlobalType(env, env.toplevel.namedImportScope, name, namedImportScopeRecovery);
2373             if (sym.exists()) return sym;
2374             else bestSoFar = bestOf(bestSoFar, sym);
2375 
2376             sym = findGlobalType(env, env.toplevel.toplevelScope, name, noRecovery);
2377             if (sym.exists()) return sym;
2378             else bestSoFar = bestOf(bestSoFar, sym);
2379 
2380             sym = findGlobalType(env, env.toplevel.packge.members(), name, noRecovery);
2381             if (sym.exists()) return sym;
2382             else bestSoFar = bestOf(bestSoFar, sym);
2383 
2384             sym = findGlobalType(env, env.toplevel.starImportScope, name, starImportScopeRecovery);
2385             if (sym.exists()) return sym;
2386             else bestSoFar = bestOf(bestSoFar, sym);
2387         }
2388 
2389         return bestSoFar;
2390     }
2391 
2392     /** Find an unqualified identifier which matches a specified kind set.
2393      *  @param pos       position on which report warnings, if any;
2394      *                   null warnings should not be reported
2395      *  @param env       The current environment.
2396      *  @param name      The identifier&#39;s name.
2397      *  @param kind      Indicates the possible symbol kinds
2398      *                   (a subset of VAL, TYP, PCK).
2399      */
2400     Symbol findIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {
2401         return checkRestrictedType(pos, findIdentInternal(env, name, kind), name);
2402     }
2403 
2404     Symbol findIdentInternal(Env&lt;AttrContext&gt; env, Name name, KindSelector kind) {
2405         Symbol bestSoFar = typeNotFound;
2406         Symbol sym;
2407 
2408         if (kind.contains(KindSelector.VAL)) {
2409             sym = findVar(env, name);
2410             if (sym.exists()) return sym;
2411             else bestSoFar = bestOf(bestSoFar, sym);
2412         }
2413 
2414         if (kind.contains(KindSelector.TYP)) {
2415             sym = findType(env, name);
2416 
2417             if (sym.exists()) return sym;
2418             else bestSoFar = bestOf(bestSoFar, sym);
2419         }
2420 
2421         if (kind.contains(KindSelector.PCK))
2422             return lookupPackage(env, name);
2423         else return bestSoFar;
2424     }
2425 
2426     /** Find an identifier in a package which matches a specified kind set.
2427      *  @param pos       position on which report warnings, if any;
2428      *                   null warnings should not be reported
2429      *  @param env       The current environment.
2430      *  @param name      The identifier&#39;s name.
2431      *  @param kind      Indicates the possible symbol kinds
2432      *                   (a nonempty subset of TYP, PCK).
2433      */
2434     Symbol findIdentInPackage(DiagnosticPosition pos,
2435                               Env&lt;AttrContext&gt; env, TypeSymbol pck,
2436                               Name name, KindSelector kind) {
2437         return checkRestrictedType(pos, findIdentInPackageInternal(env, pck, name, kind), name);
2438     }
2439 
2440     Symbol findIdentInPackageInternal(Env&lt;AttrContext&gt; env, TypeSymbol pck,
2441                               Name name, KindSelector kind) {
2442         Name fullname = TypeSymbol.formFullName(name, pck);
2443         Symbol bestSoFar = typeNotFound;
2444         if (kind.contains(KindSelector.TYP)) {
2445             RecoveryLoadClass recoveryLoadClass =
2446                     allowModules &amp;&amp; !kind.contains(KindSelector.PCK) &amp;&amp;
2447                     !pck.exists() &amp;&amp; !env.info.attributionMode.isSpeculative ?
2448                         doRecoveryLoadClass : noRecovery;
2449             Symbol sym = loadClass(env, fullname, recoveryLoadClass);
2450             if (sym.exists()) {
2451                 // don&#39;t allow programs to use flatnames
2452                 if (name == sym.name) return sym;
2453             }
2454             else bestSoFar = bestOf(bestSoFar, sym);
2455         }
2456         if (kind.contains(KindSelector.PCK)) {
2457             return lookupPackage(env, fullname);
2458         }
2459         return bestSoFar;
2460     }
2461 
2462     /** Find an identifier among the members of a given type `site&#39;.
2463      *  @param pos       position on which report warnings, if any;
2464      *                   null warnings should not be reported
2465      *  @param env       The current environment.
2466      *  @param site      The type containing the symbol to be found.
2467      *  @param name      The identifier&#39;s name.
2468      *  @param kind      Indicates the possible symbol kinds
2469      *                   (a subset of VAL, TYP).
2470      */
2471     Symbol findIdentInType(DiagnosticPosition pos,
2472                            Env&lt;AttrContext&gt; env, Type site,
2473                            Name name, KindSelector kind) {
2474         return checkRestrictedType(pos, findIdentInTypeInternal(env, site, name, kind), name);
2475     }
2476 
2477     Symbol findIdentInTypeInternal(Env&lt;AttrContext&gt; env, Type site,
2478                            Name name, KindSelector kind) {
2479         Symbol bestSoFar = typeNotFound;
2480         Symbol sym;
2481         if (kind.contains(KindSelector.VAL)) {
2482             sym = findField(env, site, name, site.tsym);
2483             if (sym.exists()) return sym;
2484             else bestSoFar = bestOf(bestSoFar, sym);
2485         }
2486 
2487         if (kind.contains(KindSelector.TYP)) {
2488             sym = findMemberType(env, site, name, site.tsym);
2489             if (sym.exists()) return sym;
2490             else bestSoFar = bestOf(bestSoFar, sym);
2491         }
2492         return bestSoFar;
2493     }
2494 
2495     private Symbol checkRestrictedType(DiagnosticPosition pos, Symbol bestSoFar, Name name) {
2496         if (bestSoFar.kind == TYP || bestSoFar.kind == ABSENT_TYP) {
2497             if (allowLocalVariableTypeInference &amp;&amp; name.equals(names.var)) {
2498                 bestSoFar = new BadRestrictedTypeError(names.var);
2499             } else if (name.equals(names.yield)) {
2500                 if (allowYieldStatement) {
2501                     bestSoFar = new BadRestrictedTypeError(names.yield);
2502                 } else if (pos != null) {
2503                     log.warning(pos, Warnings.IllegalRefToRestrictedType(names.yield));
2504                 }
2505             }
2506         }
2507         return bestSoFar;
2508     }
2509 
2510 /* ***************************************************************************
2511  *  Access checking
2512  *  The following methods convert ResolveErrors to ErrorSymbols, issuing
2513  *  an error message in the process
2514  ****************************************************************************/
2515 
2516     /** If `sym&#39; is a bad symbol: report error and return errSymbol
2517      *  else pass through unchanged,
2518      *  additional arguments duplicate what has been used in trying to find the
2519      *  symbol {@literal (--&gt; flyweight pattern)}. This improves performance since we
2520      *  expect misses to happen frequently.
2521      *
2522      *  @param sym       The symbol that was found, or a ResolveError.
2523      *  @param pos       The position to use for error reporting.
2524      *  @param location  The symbol the served as a context for this lookup
2525      *  @param site      The original type from where the selection took place.
2526      *  @param name      The symbol&#39;s name.
2527      *  @param qualified Did we get here through a qualified expression resolution?
2528      *  @param argtypes  The invocation&#39;s value arguments,
2529      *                   if we looked for a method.
2530      *  @param typeargtypes  The invocation&#39;s type arguments,
2531      *                   if we looked for a method.
2532      *  @param logResolveHelper helper class used to log resolve errors
2533      */
2534     Symbol accessInternal(Symbol sym,
2535                   DiagnosticPosition pos,
2536                   Symbol location,
2537                   Type site,
2538                   Name name,
2539                   boolean qualified,
2540                   List&lt;Type&gt; argtypes,
2541                   List&lt;Type&gt; typeargtypes,
2542                   LogResolveHelper logResolveHelper) {
2543         if (sym.kind.isResolutionError()) {
2544             ResolveError errSym = (ResolveError)sym.baseSymbol();
2545             sym = errSym.access(name, qualified ? site.tsym : syms.noSymbol);
2546             argtypes = logResolveHelper.getArgumentTypes(errSym, sym, name, argtypes);
2547             if (logResolveHelper.resolveDiagnosticNeeded(site, argtypes, typeargtypes)) {
2548                 logResolveError(errSym, pos, location, site, name, argtypes, typeargtypes);
2549             }
2550         }
2551         return sym;
2552     }
2553 
2554     /**
2555      * Variant of the generalized access routine, to be used for generating method
2556      * resolution diagnostics
2557      */
2558     Symbol accessMethod(Symbol sym,
2559                   DiagnosticPosition pos,
2560                   Symbol location,
2561                   Type site,
2562                   Name name,
2563                   boolean qualified,
2564                   List&lt;Type&gt; argtypes,
2565                   List&lt;Type&gt; typeargtypes) {
2566         return accessInternal(sym, pos, location, site, name, qualified, argtypes, typeargtypes, methodLogResolveHelper);
2567     }
2568 
2569     /** Same as original accessMethod(), but without location.
2570      */
2571     Symbol accessMethod(Symbol sym,
2572                   DiagnosticPosition pos,
2573                   Type site,
2574                   Name name,
2575                   boolean qualified,
2576                   List&lt;Type&gt; argtypes,
2577                   List&lt;Type&gt; typeargtypes) {
2578         return accessMethod(sym, pos, site.tsym, site, name, qualified, argtypes, typeargtypes);
2579     }
2580 
2581     /**
2582      * Variant of the generalized access routine, to be used for generating variable,
2583      * type resolution diagnostics
2584      */
2585     Symbol accessBase(Symbol sym,
2586                   DiagnosticPosition pos,
2587                   Symbol location,
2588                   Type site,
2589                   Name name,
2590                   boolean qualified) {
2591         return accessInternal(sym, pos, location, site, name, qualified, List.nil(), null, basicLogResolveHelper);
2592     }
2593 
2594     /** Same as original accessBase(), but without location.
2595      */
2596     Symbol accessBase(Symbol sym,
2597                   DiagnosticPosition pos,
2598                   Type site,
2599                   Name name,
2600                   boolean qualified) {
2601         return accessBase(sym, pos, site.tsym, site, name, qualified);
2602     }
2603 
2604     interface LogResolveHelper {
2605         boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes);
2606         List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes);
2607     }
2608 
2609     LogResolveHelper basicLogResolveHelper = new LogResolveHelper() {
2610         public boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2611             return !site.isErroneous();
2612         }
2613         public List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes) {
2614             return argtypes;
2615         }
2616     };
2617 
2618     LogResolveHelper methodLogResolveHelper = new LogResolveHelper() {
2619         public boolean resolveDiagnosticNeeded(Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2620             return !site.isErroneous() &amp;&amp;
2621                         !Type.isErroneous(argtypes) &amp;&amp;
2622                         (typeargtypes == null || !Type.isErroneous(typeargtypes));
2623         }
2624         public List&lt;Type&gt; getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List&lt;Type&gt; argtypes) {
2625             return argtypes.map(new ResolveDeferredRecoveryMap(AttrMode.SPECULATIVE, accessedSym, currentResolutionContext.step));
2626         }
2627     };
2628 
2629     class ResolveDeferredRecoveryMap extends DeferredAttr.RecoveryDeferredTypeMap {
2630 
2631         public ResolveDeferredRecoveryMap(AttrMode mode, Symbol msym, MethodResolutionPhase step) {
2632             deferredAttr.super(mode, msym, step);
2633         }
2634 
2635         @Override
2636         protected Type typeOf(DeferredType dt, Type pt) {
2637             Type res = super.typeOf(dt, pt);
2638             if (!res.isErroneous()) {
2639                 switch (TreeInfo.skipParens(dt.tree).getTag()) {
2640                     case LAMBDA:
2641                     case REFERENCE:
2642                         return dt;
2643                     case CONDEXPR:
2644                         return res == Type.recoveryType ?
2645                                 dt : res;
2646                 }
2647             }
2648             return res;
2649         }
2650     }
2651 
2652     /** Check that sym is not an abstract method.
2653      */
2654     void checkNonAbstract(DiagnosticPosition pos, Symbol sym) {
2655         if ((sym.flags() &amp; ABSTRACT) != 0 &amp;&amp; (sym.flags() &amp; DEFAULT) == 0)
2656             log.error(pos,
2657                       Errors.AbstractCantBeAccessedDirectly(kindName(sym),sym, sym.location()));
2658     }
2659 
2660 /* ***************************************************************************
2661  *  Name resolution
2662  *  Naming conventions are as for symbol lookup
2663  *  Unlike the find... methods these methods will report access errors
2664  ****************************************************************************/
2665 
2666     /** Resolve an unqualified (non-method) identifier.
2667      *  @param pos       The position to use for error reporting.
2668      *  @param env       The environment current at the identifier use.
2669      *  @param name      The identifier&#39;s name.
2670      *  @param kind      The set of admissible symbol kinds for the identifier.
2671      */
2672     Symbol resolveIdent(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2673                         Name name, KindSelector kind) {
2674         return accessBase(
2675             findIdent(pos, env, name, kind),
2676             pos, env.enclClass.sym.type, name, false);
2677     }
2678 
2679     /** Resolve an unqualified method identifier.
2680      *  @param pos       The position to use for error reporting.
2681      *  @param env       The environment current at the method invocation.
2682      *  @param name      The identifier&#39;s name.
2683      *  @param argtypes  The types of the invocation&#39;s value arguments.
2684      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2685      */
2686     Symbol resolveMethod(DiagnosticPosition pos,
2687                          Env&lt;AttrContext&gt; env,
2688                          Name name,
2689                          List&lt;Type&gt; argtypes,
2690                          List&lt;Type&gt; typeargtypes) {
2691         return lookupMethod(env, pos, env.enclClass.sym, resolveMethodCheck,
2692                 new BasicLookupHelper(name, env.enclClass.sym.type, argtypes, typeargtypes) {
2693                     @Override
2694                     Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2695                         return findFun(env, name, argtypes, typeargtypes,
2696                                 phase.isBoxingRequired(),
2697                                 phase.isVarargsRequired());
2698                     }});
2699     }
2700 
2701     /** Resolve a qualified method identifier
2702      *  @param pos       The position to use for error reporting.
2703      *  @param env       The environment current at the method invocation.
2704      *  @param site      The type of the qualifying expression, in which
2705      *                   identifier is searched.
2706      *  @param name      The identifier&#39;s name.
2707      *  @param argtypes  The types of the invocation&#39;s value arguments.
2708      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2709      */
2710     Symbol resolveQualifiedMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2711                                   Type site, Name name, List&lt;Type&gt; argtypes,
2712                                   List&lt;Type&gt; typeargtypes) {
2713         return resolveQualifiedMethod(pos, env, site.tsym, site, name, argtypes, typeargtypes);
2714     }
2715     Symbol resolveQualifiedMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2716                                   Symbol location, Type site, Name name, List&lt;Type&gt; argtypes,
2717                                   List&lt;Type&gt; typeargtypes) {
2718         return resolveQualifiedMethod(new MethodResolutionContext(), pos, env, location, site, name, argtypes, typeargtypes);
2719     }
2720     private Symbol resolveQualifiedMethod(MethodResolutionContext resolveContext,
2721                                   DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2722                                   Symbol location, Type site, Name name, List&lt;Type&gt; argtypes,
2723                                   List&lt;Type&gt; typeargtypes) {
2724         return lookupMethod(env, pos, location, resolveContext, new BasicLookupHelper(name, site, argtypes, typeargtypes) {
2725             @Override
2726             Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2727                 return findMethod(env, site, name, argtypes, typeargtypes,
2728                         phase.isBoxingRequired(),
2729                         phase.isVarargsRequired());
2730             }
2731             @Override
2732             Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
2733                 if (sym.kind.isResolutionError()) {
2734                     sym = super.access(env, pos, location, sym);
2735                 } else {
2736                     MethodSymbol msym = (MethodSymbol)sym;
2737                     if ((msym.flags() &amp; SIGNATURE_POLYMORPHIC) != 0) {
2738                         env.info.pendingResolutionPhase = BASIC;
2739                         return findPolymorphicSignatureInstance(env, sym, argtypes);
2740                     }
2741                 }
2742                 return sym;
2743             }
2744         });
2745     }
2746 
2747     /** Find or create an implicit method of exactly the given type (after erasure).
2748      *  Searches in a side table, not the main scope of the site.
2749      *  This emulates the lookup process required by JSR 292 in JVM.
2750      *  @param env       Attribution environment
2751      *  @param spMethod  signature polymorphic method - i.e. MH.invokeExact
2752      *  @param argtypes  The required argument types
2753      */
2754     Symbol findPolymorphicSignatureInstance(Env&lt;AttrContext&gt; env,
2755                                             final Symbol spMethod,
2756                                             List&lt;Type&gt; argtypes) {
2757         Type mtype = infer.instantiatePolymorphicSignatureInstance(env,
2758                 (MethodSymbol)spMethod, currentResolutionContext, argtypes);
2759         return findPolymorphicSignatureInstance(spMethod, mtype);
2760     }
2761 
2762     Symbol findPolymorphicSignatureInstance(final Symbol spMethod,
2763                                             Type mtype) {
2764         for (Symbol sym : polymorphicSignatureScope.getSymbolsByName(spMethod.name)) {
2765             // Check that there is already a method symbol for the method
2766             // type and owner
2767             if (types.isSameType(mtype, sym.type) &amp;&amp;
2768                 spMethod.owner == sym.owner) {
2769                 return sym;
2770             }
2771         }
2772 
2773         // Create the desired method
2774         // Retain static modifier is to support invocations to
2775         // MethodHandle.linkTo* methods
2776         long flags = ABSTRACT | HYPOTHETICAL |
2777                      spMethod.flags() &amp; (Flags.AccessFlags | Flags.STATIC);
2778         Symbol msym = new MethodSymbol(flags, spMethod.name, mtype, spMethod.owner) {
2779             @Override
2780             public Symbol baseSymbol() {
2781                 return spMethod;
2782             }
2783         };
2784         if (!mtype.isErroneous()) { // Cache only if kosher.
2785             polymorphicSignatureScope.enter(msym);
2786         }
2787         return msym;
2788     }
2789 
2790     /** Resolve a qualified method identifier, throw a fatal error if not
2791      *  found.
2792      *  @param pos       The position to use for error reporting.
2793      *  @param env       The environment current at the method invocation.
2794      *  @param site      The type of the qualifying expression, in which
2795      *                   identifier is searched.
2796      *  @param name      The identifier&#39;s name.
2797      *  @param argtypes  The types of the invocation&#39;s value arguments.
2798      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2799      */
2800     public MethodSymbol resolveInternalMethod(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2801                                         Type site, Name name,
2802                                         List&lt;Type&gt; argtypes,
2803                                         List&lt;Type&gt; typeargtypes) {
2804         MethodResolutionContext resolveContext = new MethodResolutionContext();
2805         resolveContext.internalResolution = true;
2806         Symbol sym = resolveQualifiedMethod(resolveContext, pos, env, site.tsym,
2807                 site, name, argtypes, typeargtypes);
2808         if (sym.kind == MTH) return (MethodSymbol)sym;
2809         else throw new FatalError(
2810                  diags.fragment(Fragments.FatalErrCantLocateMeth(name)));
2811     }
2812 
2813     /** Resolve constructor.
2814      *  @param pos       The position to use for error reporting.
2815      *  @param env       The environment current at the constructor invocation.
2816      *  @param site      The type of class for which a constructor is searched.
2817      *  @param argtypes  The types of the constructor invocation&#39;s value
2818      *                   arguments.
2819      *  @param typeargtypes  The types of the constructor invocation&#39;s type
2820      *                   arguments.
2821      */
2822     Symbol resolveConstructor(DiagnosticPosition pos,
2823                               Env&lt;AttrContext&gt; env,
2824                               Type site,
2825                               List&lt;Type&gt; argtypes,
2826                               List&lt;Type&gt; typeargtypes) {
2827         return resolveConstructor(new MethodResolutionContext(), pos, env, site, argtypes, typeargtypes);
2828     }
2829 
2830     private Symbol resolveConstructor(MethodResolutionContext resolveContext,
2831                               final DiagnosticPosition pos,
2832                               Env&lt;AttrContext&gt; env,
2833                               Type site,
2834                               List&lt;Type&gt; argtypes,
2835                               List&lt;Type&gt; typeargtypes) {
2836         return lookupMethod(env, pos, site.tsym, resolveContext, new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {
2837             @Override
2838             Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2839                 return findConstructor(pos, env, site, argtypes, typeargtypes,
2840                         phase.isBoxingRequired(),
2841                         phase.isVarargsRequired());
2842             }
2843         });
2844     }
2845 
2846     /** Resolve a constructor, throw a fatal error if not found.
2847      *  @param pos       The position to use for error reporting.
2848      *  @param env       The environment current at the method invocation.
2849      *  @param site      The type to be constructed.
2850      *  @param argtypes  The types of the invocation&#39;s value arguments.
2851      *  @param typeargtypes  The types of the invocation&#39;s type arguments.
2852      */
2853     public MethodSymbol resolveInternalConstructor(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2854                                         Type site,
2855                                         List&lt;Type&gt; argtypes,
2856                                         List&lt;Type&gt; typeargtypes) {
2857         MethodResolutionContext resolveContext = new MethodResolutionContext();
2858         resolveContext.internalResolution = true;
2859         Symbol sym = resolveConstructor(resolveContext, pos, env, site, argtypes, typeargtypes);
2860         if (sym.kind == MTH) return (MethodSymbol)sym;
2861         else throw new FatalError(
2862                  diags.fragment(Fragments.FatalErrCantLocateCtor(site)));
2863     }
2864 
2865     Symbol findConstructor(DiagnosticPosition pos, Env&lt;AttrContext&gt; env,
2866                               Type site, List&lt;Type&gt; argtypes,
2867                               List&lt;Type&gt; typeargtypes,
2868                               boolean allowBoxing,
2869                               boolean useVarargs) {
2870         Symbol sym = findMethod(env, site,
2871                                     names.init, argtypes,
2872                                     typeargtypes, allowBoxing,
2873                                     useVarargs);
2874         chk.checkDeprecated(pos, env.info.scope.owner, sym);
2875         chk.checkPreview(pos, sym);
2876         return sym;
2877     }
2878 
2879     /** Resolve constructor using diamond inference.
2880      *  @param pos       The position to use for error reporting.
2881      *  @param env       The environment current at the constructor invocation.
2882      *  @param site      The type of class for which a constructor is searched.
2883      *                   The scope of this class has been touched in attribution.
2884      *  @param argtypes  The types of the constructor invocation&#39;s value
2885      *                   arguments.
2886      *  @param typeargtypes  The types of the constructor invocation&#39;s type
2887      *                   arguments.
2888      */
2889     Symbol resolveDiamond(DiagnosticPosition pos,
2890                               Env&lt;AttrContext&gt; env,
2891                               Type site,
2892                               List&lt;Type&gt; argtypes,
2893                               List&lt;Type&gt; typeargtypes) {
2894         return lookupMethod(env, pos, site.tsym, resolveMethodCheck,
2895                 new BasicLookupHelper(names.init, site, argtypes, typeargtypes) {
2896                     @Override
2897                     Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
2898                         return findDiamond(env, site, argtypes, typeargtypes,
2899                                 phase.isBoxingRequired(),
2900                                 phase.isVarargsRequired());
2901                     }
2902                     @Override
2903                     Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
2904                         if (sym.kind.isResolutionError()) {
2905                             if (sym.kind != WRONG_MTH &amp;&amp;
2906                                 sym.kind != WRONG_MTHS) {
2907                                 sym = super.access(env, pos, location, sym);
2908                             } else {
2909                                 final JCDiagnostic details = sym.kind == WRONG_MTH ?
2910                                                 ((InapplicableSymbolError)sym.baseSymbol()).errCandidate().snd :
2911                                                 null;
2912                                 sym = new DiamondError(sym, currentResolutionContext);
2913                                 sym = accessMethod(sym, pos, site, names.init, true, argtypes, typeargtypes);
2914                                 env.info.pendingResolutionPhase = currentResolutionContext.step;
2915                             }
2916                         }
2917                         return sym;
2918                     }});
2919     }
2920 
2921     /** This method scans all the constructor symbol in a given class scope -
2922      *  assuming that the original scope contains a constructor of the kind:
2923      *  {@code Foo(X x, Y y)}, where X,Y are class type-variables declared in Foo,
2924      *  a method check is executed against the modified constructor type:
2925      *  {@code &lt;X,Y&gt;Foo&lt;X,Y&gt;(X x, Y y)}. This is crucial in order to enable diamond
2926      *  inference. The inferred return type of the synthetic constructor IS
2927      *  the inferred type for the diamond operator.
2928      */
2929     private Symbol findDiamond(Env&lt;AttrContext&gt; env,
2930                               Type site,
2931                               List&lt;Type&gt; argtypes,
2932                               List&lt;Type&gt; typeargtypes,
2933                               boolean allowBoxing,
2934                               boolean useVarargs) {
2935         Symbol bestSoFar = methodNotFound;
2936         TypeSymbol tsym = site.tsym.isInterface() ? syms.objectType.tsym : site.tsym;
2937         for (final Symbol sym : tsym.members().getSymbolsByName(names.init)) {
2938             //- System.out.println(&quot; e &quot; + e.sym);
2939             if (sym.kind == MTH &amp;&amp;
2940                 (sym.flags_field &amp; SYNTHETIC) == 0) {
2941                     List&lt;Type&gt; oldParams = sym.type.hasTag(FORALL) ?
2942                             ((ForAll)sym.type).tvars :
2943                             List.nil();
2944                     Type constrType = new ForAll(site.tsym.type.getTypeArguments().appendList(oldParams),
2945                                                  types.createMethodTypeWithReturn(sym.type.asMethodType(), site));
2946                     MethodSymbol newConstr = new MethodSymbol(sym.flags(), names.init, constrType, site.tsym) {
2947                         @Override
2948                         public Symbol baseSymbol() {
2949                             return sym;
2950                         }
2951                     };
2952                     bestSoFar = selectBest(env, site, argtypes, typeargtypes,
2953                             newConstr,
2954                             bestSoFar,
2955                             allowBoxing,
2956                             useVarargs);
2957             }
2958         }
2959         return bestSoFar;
2960     }
2961 
2962     Symbol getMemberReference(DiagnosticPosition pos,
2963             Env&lt;AttrContext&gt; env,
2964             JCMemberReference referenceTree,
2965             Type site,
2966             Name name) {
2967 
2968         site = types.capture(site);
2969 
2970         ReferenceLookupHelper lookupHelper = makeReferenceLookupHelper(
2971                 referenceTree, site, name, List.nil(), null, VARARITY);
2972 
2973         Env&lt;AttrContext&gt; newEnv = env.dup(env.tree, env.info.dup());
2974         Symbol sym = lookupMethod(newEnv, env.tree.pos(), site.tsym,
2975                 nilMethodCheck, lookupHelper);
2976 
2977         env.info.pendingResolutionPhase = newEnv.info.pendingResolutionPhase;
2978 
2979         return sym;
2980     }
2981 
2982     ReferenceLookupHelper makeReferenceLookupHelper(JCMemberReference referenceTree,
2983                                   Type site,
2984                                   Name name,
2985                                   List&lt;Type&gt; argtypes,
2986                                   List&lt;Type&gt; typeargtypes,
2987                                   MethodResolutionPhase maxPhase) {
2988         if (!name.equals(names.init)) {
2989             //method reference
2990             return new MethodReferenceLookupHelper(referenceTree, name, site, argtypes, typeargtypes, maxPhase);
2991         } else if (site.hasTag(ARRAY)) {
2992             //array constructor reference
2993             return new ArrayConstructorReferenceLookupHelper(referenceTree, site, argtypes, typeargtypes, maxPhase);
2994         } else {
2995             //class constructor reference
2996             return new ConstructorReferenceLookupHelper(referenceTree, site, argtypes, typeargtypes, maxPhase);
2997         }
2998     }
2999 
3000     /**
3001      * Resolution of member references is typically done as a single
3002      * overload resolution step, where the argument types A are inferred from
3003      * the target functional descriptor.
3004      *
3005      * If the member reference is a method reference with a type qualifier,
3006      * a two-step lookup process is performed. The first step uses the
3007      * expected argument list A, while the second step discards the first
3008      * type from A (which is treated as a receiver type).
3009      *
3010      * There are two cases in which inference is performed: (i) if the member
3011      * reference is a constructor reference and the qualifier type is raw - in
3012      * which case diamond inference is used to infer a parameterization for the
3013      * type qualifier; (ii) if the member reference is an unbound reference
3014      * where the type qualifier is raw - in that case, during the unbound lookup
3015      * the receiver argument type is used to infer an instantiation for the raw
3016      * qualifier type.
3017      *
3018      * When a multi-step resolution process is exploited, the process of picking
3019      * the resulting symbol is delegated to an helper class {@link com.sun.tools.javac.comp.Resolve.ReferenceChooser}.
3020      *
3021      * This routine returns a pair (T,S), where S is the member reference symbol,
3022      * and T is the type of the class in which S is defined. This is necessary as
3023      * the type T might be dynamically inferred (i.e. if constructor reference
3024      * has a raw qualifier).
3025      */
3026     Pair&lt;Symbol, ReferenceLookupHelper&gt; resolveMemberReference(Env&lt;AttrContext&gt; env,
3027                                   JCMemberReference referenceTree,
3028                                   Type site,
3029                                   Name name,
3030                                   List&lt;Type&gt; argtypes,
3031                                   List&lt;Type&gt; typeargtypes,
3032                                   Type descriptor,
3033                                   MethodCheck methodCheck,
3034                                   InferenceContext inferenceContext,
3035                                   ReferenceChooser referenceChooser) {
3036 
3037         //step 1 - bound lookup
3038         ReferenceLookupHelper boundLookupHelper = makeReferenceLookupHelper(
3039                 referenceTree, site, name, argtypes, typeargtypes, VARARITY);
3040         Env&lt;AttrContext&gt; boundEnv = env.dup(env.tree, env.info.dup());
3041         MethodResolutionContext boundSearchResolveContext = new MethodResolutionContext();
3042         boundSearchResolveContext.methodCheck = methodCheck;
3043         Symbol boundSym = lookupMethod(boundEnv, env.tree.pos(),
3044                 site.tsym, boundSearchResolveContext, boundLookupHelper);
3045         ReferenceLookupResult boundRes = new ReferenceLookupResult(boundSym, boundSearchResolveContext);
3046 
3047         //step 2 - unbound lookup
3048         Symbol unboundSym = methodNotFound;
3049         Env&lt;AttrContext&gt; unboundEnv = env.dup(env.tree, env.info.dup());
3050         ReferenceLookupHelper unboundLookupHelper = boundLookupHelper.unboundLookup(inferenceContext);
3051         ReferenceLookupResult unboundRes = referenceNotFound;
3052         if (unboundLookupHelper != null) {
3053             MethodResolutionContext unboundSearchResolveContext =
3054                     new MethodResolutionContext();
3055             unboundSearchResolveContext.methodCheck = methodCheck;
3056             unboundSym = lookupMethod(unboundEnv, env.tree.pos(),
3057                     site.tsym, unboundSearchResolveContext, unboundLookupHelper);
3058             unboundRes = new ReferenceLookupResult(unboundSym, unboundSearchResolveContext);
3059         }
3060 
3061         //merge results
3062         Pair&lt;Symbol, ReferenceLookupHelper&gt; res;
3063         ReferenceLookupResult bestRes = referenceChooser.result(boundRes, unboundRes);
3064         res = new Pair&lt;&gt;(bestRes.sym,
3065                 bestRes == unboundRes ? unboundLookupHelper : boundLookupHelper);
3066         env.info.pendingResolutionPhase = bestRes == unboundRes ?
3067                 unboundEnv.info.pendingResolutionPhase :
3068                 boundEnv.info.pendingResolutionPhase;
3069 
3070         if (!res.fst.kind.isResolutionError()) {
3071             //handle sigpoly method references
3072             MethodSymbol msym = (MethodSymbol)res.fst;
3073             if ((msym.flags() &amp; SIGNATURE_POLYMORPHIC) != 0) {
3074                 env.info.pendingResolutionPhase = BASIC;
3075                 res = new Pair&lt;&gt;(findPolymorphicSignatureInstance(msym, descriptor), res.snd);
3076             }
3077         }
3078 
3079         return res;
3080     }
3081 
3082     /**
3083      * This class is used to represent a method reference lookup result. It keeps track of two
3084      * things: (i) the symbol found during a method reference lookup and (ii) the static kind
3085      * of the lookup (see {@link com.sun.tools.javac.comp.Resolve.ReferenceLookupResult.StaticKind}).
3086      */
3087     static class ReferenceLookupResult {
3088 
3089         /**
3090          * Static kind associated with a method reference lookup. Erroneous lookups end up with
3091          * the UNDEFINED kind; successful lookups will end up with either STATIC, NON_STATIC,
3092          * depending on whether all applicable candidates are static or non-static methods,
3093          * respectively. If a successful lookup has both static and non-static applicable methods,
3094          * its kind is set to BOTH.
3095          */
3096         enum StaticKind {
3097             STATIC,
3098             NON_STATIC,
3099             BOTH,
3100             UNDEFINED;
3101 
3102             /**
3103              * Retrieve the static kind associated with a given (method) symbol.
3104              */
3105             static StaticKind from(Symbol s) {
3106                 return s.isStatic() ?
3107                         STATIC : NON_STATIC;
3108             }
3109 
3110             /**
3111              * Merge two static kinds together.
3112              */
3113             static StaticKind reduce(StaticKind sk1, StaticKind sk2) {
3114                 if (sk1 == UNDEFINED) {
3115                     return sk2;
3116                 } else if (sk2 == UNDEFINED) {
3117                     return sk1;
3118                 } else {
3119                     return sk1 == sk2 ? sk1 : BOTH;
3120                 }
3121             }
3122         }
3123 
3124         /** The static kind. */
3125         StaticKind staticKind;
3126 
3127         /** The lookup result. */
3128         Symbol sym;
3129 
3130         ReferenceLookupResult(Symbol sym, MethodResolutionContext resolutionContext) {
3131             this(sym, staticKind(sym, resolutionContext));
3132         }
3133 
3134         private ReferenceLookupResult(Symbol sym, StaticKind staticKind) {
3135             this.staticKind = staticKind;
3136             this.sym = sym;
3137         }
3138 
3139         private static StaticKind staticKind(Symbol sym, MethodResolutionContext resolutionContext) {
3140             switch (sym.kind) {
3141                 case MTH:
3142                 case AMBIGUOUS:
3143                     return resolutionContext.candidates.stream()
3144                             .filter(c -&gt; c.isApplicable() &amp;&amp; c.step == resolutionContext.step)
3145                             .map(c -&gt; StaticKind.from(c.sym))
3146                             .reduce(StaticKind::reduce)
3147                             .orElse(StaticKind.UNDEFINED);
3148                 default:
3149                     return StaticKind.UNDEFINED;
3150             }
3151         }
3152 
3153         /**
3154          * Does this result corresponds to a successful lookup (i.e. one where a method has been found?)
3155          */
3156         boolean isSuccess() {
3157             return staticKind != StaticKind.UNDEFINED;
3158         }
3159 
3160         /**
3161          * Does this result have given static kind?
3162          */
3163         boolean hasKind(StaticKind sk) {
3164             return this.staticKind == sk;
3165         }
3166 
3167         /**
3168          * Error recovery helper: can this lookup result be ignored (for the purpose of returning
3169          * some &#39;better&#39; result) ?
3170          */
3171         boolean canIgnore() {
3172             switch (sym.kind) {
3173                 case ABSENT_MTH:
3174                     return true;
3175                 case WRONG_MTH:
3176                     InapplicableSymbolError errSym =
3177                             (InapplicableSymbolError)sym.baseSymbol();
3178                     return new Template(MethodCheckDiag.ARITY_MISMATCH.regex())
3179                             .matches(errSym.errCandidate().snd);
3180                 case WRONG_MTHS:
3181                     InapplicableSymbolsError errSyms =
3182                             (InapplicableSymbolsError)sym.baseSymbol();
3183                     return errSyms.filterCandidates(errSyms.mapCandidates()).isEmpty();
3184                 default:
3185                     return false;
3186             }
3187         }
3188 
3189         static ReferenceLookupResult error(Symbol sym) {
3190             return new ReferenceLookupResult(sym, StaticKind.UNDEFINED);
3191         }
3192     }
3193 
3194     /**
3195      * This abstract class embodies the logic that converts one (bound lookup) or two (unbound lookup)
3196      * {@code ReferenceLookupResult} objects into a (@code Symbol), which is then regarded as the
3197      * result of method reference resolution.
3198      */
3199     abstract class ReferenceChooser {
3200         /**
3201          * Generate a result from a pair of lookup result objects. This method delegates to the
3202          * appropriate result generation routine.
3203          */
3204         ReferenceLookupResult result(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3205             return unboundRes != referenceNotFound ?
3206                     unboundResult(boundRes, unboundRes) :
3207                     boundResult(boundRes);
3208         }
3209 
3210         /**
3211          * Generate a symbol from a given bound lookup result.
3212          */
3213         abstract ReferenceLookupResult boundResult(ReferenceLookupResult boundRes);
3214 
3215         /**
3216          * Generate a symbol from a pair of bound/unbound lookup results.
3217          */
3218         abstract ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes);
3219     }
3220 
3221     /**
3222      * This chooser implements the selection strategy used during a full lookup; this logic
3223      * is described in JLS SE 8 (15.3.2).
3224      */
3225     ReferenceChooser basicReferenceChooser = new ReferenceChooser() {
3226 
3227         @Override
3228         ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {
3229             return !boundRes.isSuccess() || boundRes.hasKind(StaticKind.NON_STATIC) ?
3230                     boundRes : //the search produces a non-static method
3231                     ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));
3232         }
3233 
3234         @Override
3235         ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3236             if (boundRes.hasKind(StaticKind.STATIC) &amp;&amp;
3237                     (!unboundRes.isSuccess() || unboundRes.hasKind(StaticKind.STATIC))) {
3238                 //the first search produces a static method and no non-static method is applicable
3239                 //during the second search
3240                 return boundRes;
3241             } else if (unboundRes.hasKind(StaticKind.NON_STATIC) &amp;&amp;
3242                     (!boundRes.isSuccess() || boundRes.hasKind(StaticKind.NON_STATIC))) {
3243                 //the second search produces a non-static method and no static method is applicable
3244                 //during the first search
3245                 return unboundRes;
3246             } else if (boundRes.isSuccess() &amp;&amp; unboundRes.isSuccess()) {
3247                 //both searches produce some result; ambiguity (error recovery)
3248                 return ReferenceLookupResult.error(ambiguityError(boundRes.sym, unboundRes.sym));
3249             } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {
3250                 //Both searches failed to produce a result with correct staticness (i.e. first search
3251                 //produces an non-static method). Alternatively, a given search produced a result
3252                 //with the right staticness, but the other search has applicable methods with wrong
3253                 //staticness (error recovery)
3254                 return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?
3255                         boundRes.sym : unboundRes.sym, true));
3256             } else {
3257                 //both searches fail to produce a result - pick &#39;better&#39; error using heuristics (error recovery)
3258                 return (boundRes.canIgnore() &amp;&amp; !unboundRes.canIgnore()) ?
3259                         unboundRes : boundRes;
3260             }
3261         }
3262     };
3263 
3264     /**
3265      * This chooser implements the selection strategy used during an arity-based lookup; this logic
3266      * is described in JLS SE 8 (15.12.2.1).
3267      */
3268     ReferenceChooser structuralReferenceChooser = new ReferenceChooser() {
3269 
3270         @Override
3271         ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {
3272             return (!boundRes.isSuccess() || !boundRes.hasKind(StaticKind.STATIC)) ?
3273                     boundRes : //the search has at least one applicable non-static method
3274                     ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));
3275         }
3276 
3277         @Override
3278         ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {
3279             if (boundRes.isSuccess() &amp;&amp; !boundRes.hasKind(StaticKind.NON_STATIC)) {
3280                 //the first search has at least one applicable static method
3281                 return boundRes;
3282             } else if (unboundRes.isSuccess() &amp;&amp; !unboundRes.hasKind(StaticKind.STATIC)) {
3283                 //the second search has at least one applicable non-static method
3284                 return unboundRes;
3285             } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {
3286                 //either the first search produces a non-static method, or second search produces
3287                 //a non-static method (error recovery)
3288                 return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?
3289                         boundRes.sym : unboundRes.sym, true));
3290             } else {
3291                 //both searches fail to produce a result - pick &#39;better&#39; error using heuristics (error recovery)
3292                 return (boundRes.canIgnore() &amp;&amp; !unboundRes.canIgnore()) ?
3293                         unboundRes : boundRes;
3294             }
3295         }
3296     };
3297 
3298     /**
3299      * Helper for defining custom method-like lookup logic; a lookup helper
3300      * provides hooks for (i) the actual lookup logic and (ii) accessing the
3301      * lookup result (this step might result in compiler diagnostics to be generated)
3302      */
3303     abstract class LookupHelper {
3304 
3305         /** name of the symbol to lookup */
3306         Name name;
3307 
3308         /** location in which the lookup takes place */
3309         Type site;
3310 
3311         /** actual types used during the lookup */
3312         List&lt;Type&gt; argtypes;
3313 
3314         /** type arguments used during the lookup */
3315         List&lt;Type&gt; typeargtypes;
3316 
3317         /** Max overload resolution phase handled by this helper */
3318         MethodResolutionPhase maxPhase;
3319 
3320         LookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3321             this.name = name;
3322             this.site = site;
3323             this.argtypes = argtypes;
3324             this.typeargtypes = typeargtypes;
3325             this.maxPhase = maxPhase;
3326         }
3327 
3328         /**
3329          * Should lookup stop at given phase with given result
3330          */
3331         final boolean shouldStop(Symbol sym, MethodResolutionPhase phase) {
3332             return phase.ordinal() &gt; maxPhase.ordinal() ||
3333                 !sym.kind.isResolutionError() || sym.kind == AMBIGUOUS;
3334         }
3335 
3336         /**
3337          * Search for a symbol under a given overload resolution phase - this method
3338          * is usually called several times, once per each overload resolution phase
3339          */
3340         abstract Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase);
3341 
3342         /**
3343          * Dump overload resolution info
3344          */
3345         void debug(DiagnosticPosition pos, Symbol sym) {
3346             //do nothing
3347         }
3348 
3349         /**
3350          * Validate the result of the lookup
3351          */
3352         abstract Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym);
3353     }
3354 
3355     abstract class BasicLookupHelper extends LookupHelper {
3356 
3357         BasicLookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
3358             this(name, site, argtypes, typeargtypes, MethodResolutionPhase.VARARITY);
3359         }
3360 
3361         BasicLookupHelper(Name name, Type site, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3362             super(name, site, argtypes, typeargtypes, maxPhase);
3363         }
3364 
3365         @Override
3366         final Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3367             Symbol sym = doLookup(env, phase);
3368             if (sym.kind == AMBIGUOUS) {
3369                 AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();
3370                 sym = a_err.mergeAbstracts(site);
3371             }
3372             return sym;
3373         }
3374 
3375         abstract Symbol doLookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase);
3376 
3377         @Override
3378         Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
3379             if (sym.kind.isResolutionError()) {
3380                 //if nothing is found return the &#39;first&#39; error
3381                 sym = accessMethod(sym, pos, location, site, name, true, argtypes, typeargtypes);
3382             }
3383             return sym;
3384         }
3385 
3386         @Override
3387         void debug(DiagnosticPosition pos, Symbol sym) {
3388             reportVerboseResolutionDiagnostic(pos, name, site, argtypes, typeargtypes, sym);
3389         }
3390     }
3391 
3392     /**
3393      * Helper class for member reference lookup. A reference lookup helper
3394      * defines the basic logic for member reference lookup; a method gives
3395      * access to an &#39;unbound&#39; helper used to perform an unbound member
3396      * reference lookup.
3397      */
3398     abstract class ReferenceLookupHelper extends LookupHelper {
3399 
3400         /** The member reference tree */
3401         JCMemberReference referenceTree;
3402 
3403         ReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3404                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3405             super(name, site, argtypes, typeargtypes, maxPhase);
3406             this.referenceTree = referenceTree;
3407         }
3408 
3409         /**
3410          * Returns an unbound version of this lookup helper. By default, this
3411          * method returns an dummy lookup helper.
3412          */
3413         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3414             return null;
3415         }
3416 
3417         /**
3418          * Get the kind of the member reference
3419          */
3420         abstract JCMemberReference.ReferenceKind referenceKind(Symbol sym);
3421 
3422         Symbol access(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, Symbol sym) {
3423             if (sym.kind == AMBIGUOUS) {
3424                 AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();
3425                 sym = a_err.mergeAbstracts(site);
3426             }
3427             //skip error reporting
3428             return sym;
3429         }
3430     }
3431 
3432     /**
3433      * Helper class for method reference lookup. The lookup logic is based
3434      * upon Resolve.findMethod; in certain cases, this helper class has a
3435      * corresponding unbound helper class (see UnboundMethodReferenceLookupHelper).
3436      * In such cases, non-static lookup results are thrown away.
3437      */
3438     class MethodReferenceLookupHelper extends ReferenceLookupHelper {
3439 
3440         /** The original method reference lookup site. */
3441         Type originalSite;
3442 
3443         MethodReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3444                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3445             super(referenceTree, name, types.skipTypeVars(site, true), argtypes, typeargtypes, maxPhase);
3446             this.originalSite = site;
3447         }
3448 
3449         @Override
3450         final Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3451             return findMethod(env, site, name, argtypes, typeargtypes,
3452                     phase.isBoxingRequired(), phase.isVarargsRequired());
3453         }
3454 
3455         @Override
3456         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3457             if (TreeInfo.isStaticSelector(referenceTree.expr, names)) {
3458                 if (argtypes.nonEmpty() &amp;&amp;
3459                         (argtypes.head.hasTag(NONE) ||
3460                         types.isSubtypeUnchecked(inferenceContext.asUndetVar(argtypes.head), originalSite))) {
3461                     return new UnboundMethodReferenceLookupHelper(referenceTree, name,
3462                             originalSite, argtypes, typeargtypes, maxPhase);
3463                 } else {
3464                     return new ReferenceLookupHelper(referenceTree, name, site, argtypes, typeargtypes, maxPhase) {
3465                         @Override
3466                         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3467                             return this;
3468                         }
3469 
3470                         @Override
3471                         Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3472                             return methodNotFound;
3473                         }
3474 
3475                         @Override
3476                         ReferenceKind referenceKind(Symbol sym) {
3477                             Assert.error();
3478                             return null;
3479                         }
3480                     };
3481                 }
3482             } else {
3483                 return super.unboundLookup(inferenceContext);
3484             }
3485         }
3486 
3487         @Override
3488         ReferenceKind referenceKind(Symbol sym) {
3489             if (sym.isStatic()) {
3490                 return ReferenceKind.STATIC;
3491             } else {
3492                 Name selName = TreeInfo.name(referenceTree.getQualifierExpression());
3493                 return selName != null &amp;&amp; selName == names._super ?
3494                         ReferenceKind.SUPER :
3495                         ReferenceKind.BOUND;
3496             }
3497         }
3498     }
3499 
3500     /**
3501      * Helper class for unbound method reference lookup. Essentially the same
3502      * as the basic method reference lookup helper; main difference is that static
3503      * lookup results are thrown away. If qualifier type is raw, an attempt to
3504      * infer a parameterized type is made using the first actual argument (that
3505      * would otherwise be ignored during the lookup).
3506      */
3507     class UnboundMethodReferenceLookupHelper extends MethodReferenceLookupHelper {
3508 
3509         UnboundMethodReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,
3510                 List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3511             super(referenceTree, name, site, argtypes.tail, typeargtypes, maxPhase);
3512             if (site.isRaw() &amp;&amp; !argtypes.head.hasTag(NONE)) {
3513                 Type asSuperSite = types.asSuper(argtypes.head, site.tsym);
3514                 this.site = types.skipTypeVars(asSuperSite, true);
3515             }
3516         }
3517 
3518         @Override
3519         ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {
3520             return this;
3521         }
3522 
3523         @Override
3524         ReferenceKind referenceKind(Symbol sym) {
3525             return ReferenceKind.UNBOUND;
3526         }
3527     }
3528 
3529     /**
3530      * Helper class for array constructor lookup; an array constructor lookup
3531      * is simulated by looking up a method that returns the array type specified
3532      * as qualifier, and that accepts a single int parameter (size of the array).
3533      */
3534     class ArrayConstructorReferenceLookupHelper extends ReferenceLookupHelper {
3535 
3536         ArrayConstructorReferenceLookupHelper(JCMemberReference referenceTree, Type site, List&lt;Type&gt; argtypes,
3537                 List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3538             super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);
3539         }
3540 
3541         @Override
3542         protected Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3543             WriteableScope sc = WriteableScope.create(syms.arrayClass);
3544             MethodSymbol arrayConstr = new MethodSymbol(PUBLIC, name, null, site.tsym);
3545             arrayConstr.type = new MethodType(List.of(syms.intType), site, List.nil(), syms.methodClass);
3546             sc.enter(arrayConstr);
3547             return findMethodInScope(env, site, name, argtypes, typeargtypes, sc, methodNotFound, phase.isBoxingRequired(), phase.isVarargsRequired(), false);
3548         }
3549 
3550         @Override
3551         ReferenceKind referenceKind(Symbol sym) {
3552             return ReferenceKind.ARRAY_CTOR;
3553         }
3554     }
3555 
3556     /**
3557      * Helper class for constructor reference lookup. The lookup logic is based
3558      * upon either Resolve.findMethod or Resolve.findDiamond - depending on
3559      * whether the constructor reference needs diamond inference (this is the case
3560      * if the qualifier type is raw). A special erroneous symbol is returned
3561      * if the lookup returns the constructor of an inner class and there&#39;s no
3562      * enclosing instance in scope.
3563      */
3564     class ConstructorReferenceLookupHelper extends ReferenceLookupHelper {
3565 
3566         boolean needsInference;
3567 
3568         ConstructorReferenceLookupHelper(JCMemberReference referenceTree, Type site, List&lt;Type&gt; argtypes,
3569                 List&lt;Type&gt; typeargtypes, MethodResolutionPhase maxPhase) {
3570             super(referenceTree, names.init, site, argtypes, typeargtypes, maxPhase);
3571             if (site.isRaw()) {
3572                 this.site = new ClassType(site.getEnclosingType(), site.tsym.type.getTypeArguments(), site.tsym, site.getMetadata());
3573                 needsInference = true;
3574             }
3575         }
3576 
3577         @Override
3578         protected Symbol lookup(Env&lt;AttrContext&gt; env, MethodResolutionPhase phase) {
3579             Symbol sym = needsInference ?
3580                 findDiamond(env, site, argtypes, typeargtypes, phase.isBoxingRequired(), phase.isVarargsRequired()) :
3581                 findMethod(env, site, name, argtypes, typeargtypes,
3582                         phase.isBoxingRequired(), phase.isVarargsRequired());
3583             return enclosingInstanceMissing(env, site) ? new BadConstructorReferenceError(sym) : sym;
3584         }
3585 
3586         @Override
3587         ReferenceKind referenceKind(Symbol sym) {
3588             return site.getEnclosingType().hasTag(NONE) ?
3589                     ReferenceKind.TOPLEVEL : ReferenceKind.IMPLICIT_INNER;
3590         }
3591     }
3592 
3593     /**
3594      * Main overload resolution routine. On each overload resolution step, a
3595      * lookup helper class is used to perform the method/constructor lookup;
3596      * at the end of the lookup, the helper is used to validate the results
3597      * (this last step might trigger overload resolution diagnostics).
3598      */
3599     Symbol lookupMethod(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location, MethodCheck methodCheck, LookupHelper lookupHelper) {
3600         MethodResolutionContext resolveContext = new MethodResolutionContext();
3601         resolveContext.methodCheck = methodCheck;
3602         return lookupMethod(env, pos, location, resolveContext, lookupHelper);
3603     }
3604 
3605     Symbol lookupMethod(Env&lt;AttrContext&gt; env, DiagnosticPosition pos, Symbol location,
3606             MethodResolutionContext resolveContext, LookupHelper lookupHelper) {
3607         MethodResolutionContext prevResolutionContext = currentResolutionContext;
3608         try {
3609             Symbol bestSoFar = methodNotFound;
3610             currentResolutionContext = resolveContext;
3611             for (MethodResolutionPhase phase : methodResolutionSteps) {
3612                 if (lookupHelper.shouldStop(bestSoFar, phase))
3613                     break;
3614                 MethodResolutionPhase prevPhase = currentResolutionContext.step;
3615                 Symbol prevBest = bestSoFar;
3616                 currentResolutionContext.step = phase;
3617                 Symbol sym = lookupHelper.lookup(env, phase);
3618                 lookupHelper.debug(pos, sym);
3619                 bestSoFar = phase.mergeResults(bestSoFar, sym);
3620                 env.info.pendingResolutionPhase = (prevBest == bestSoFar) ? prevPhase : phase;
3621             }
3622             return lookupHelper.access(env, pos, location, bestSoFar);
3623         } finally {
3624             currentResolutionContext = prevResolutionContext;
3625         }
3626     }
3627 
3628     /**
3629      * Resolve `c.name&#39; where name == this or name == super.
3630      * @param pos           The position to use for error reporting.
3631      * @param env           The environment current at the expression.
3632      * @param c             The qualifier.
3633      * @param name          The identifier&#39;s name.
3634      */
3635     Symbol resolveSelf(DiagnosticPosition pos,
3636                        Env&lt;AttrContext&gt; env,
3637                        TypeSymbol c,
3638                        Name name) {
3639         Env&lt;AttrContext&gt; env1 = env;
3640         boolean staticOnly = false;
3641         while (env1.outer != null) {
3642             if (isStatic(env1)) staticOnly = true;
3643             if (env1.enclClass.sym == c) {
3644                 Symbol sym = env1.info.scope.findFirst(name);
3645                 if (sym != null) {
3646                     if (staticOnly) sym = new StaticError(sym);
3647                     return accessBase(sym, pos, env.enclClass.sym.type,
3648                                   name, true);
3649                 }
3650             }
3651             if ((env1.enclClass.sym.flags() &amp; STATIC) != 0) staticOnly = true;
3652             env1 = env1.outer;
3653         }
3654         if (c.isInterface() &amp;&amp;
3655             name == names._super &amp;&amp; !isStatic(env) &amp;&amp;
3656             types.isDirectSuperInterface(c, env.enclClass.sym)) {
3657             //this might be a default super call if one of the superinterfaces is &#39;c&#39;
3658             for (Type t : pruneInterfaces(env.enclClass.type)) {
3659                 if (t.tsym == c) {
3660                     env.info.defaultSuperCallSite = t;
3661                     return new VarSymbol(0, names._super,
3662                             types.asSuper(env.enclClass.type, c), env.enclClass.sym);
3663                 }
3664             }
3665             //find a direct super type that is a subtype of &#39;c&#39;
3666             for (Type i : types.directSupertypes(env.enclClass.type)) {
3667                 if (i.tsym.isSubClass(c, types) &amp;&amp; i.tsym != c) {
3668                     log.error(pos,
3669                               Errors.IllegalDefaultSuperCall(c,
3670                                                              Fragments.RedundantSupertype(c, i)));
3671                     return syms.errSymbol;
3672                 }
3673             }
3674             Assert.error();
3675         }
3676         log.error(pos, Errors.NotEnclClass(c));
3677         return syms.errSymbol;
3678     }
3679     //where
3680     private List&lt;Type&gt; pruneInterfaces(Type t) {
3681         ListBuffer&lt;Type&gt; result = new ListBuffer&lt;&gt;();
3682         for (Type t1 : types.interfaces(t)) {
3683             boolean shouldAdd = true;
3684             for (Type t2 : types.directSupertypes(t)) {
3685                 if (t1 != t2 &amp;&amp; types.isSubtypeNoCapture(t2, t1)) {
3686                     shouldAdd = false;
3687                 }
3688             }
3689             if (shouldAdd) {
3690                 result.append(t1);
3691             }
3692         }
3693         return result.toList();
3694     }
3695 
3696 
3697     /**
3698      * Resolve `c.this&#39; for an enclosing class c that contains the
3699      * named member.
3700      * @param pos           The position to use for error reporting.
3701      * @param env           The environment current at the expression.
3702      * @param member        The member that must be contained in the result.
3703      */
3704     Symbol resolveSelfContaining(DiagnosticPosition pos,
3705                                  Env&lt;AttrContext&gt; env,
3706                                  Symbol member,
3707                                  boolean isSuperCall) {
3708         Symbol sym = resolveSelfContainingInternal(env, member, isSuperCall);
3709         if (sym == null) {
3710             log.error(pos, Errors.EnclClassRequired(member));
3711             return syms.errSymbol;
3712         } else {
3713             return accessBase(sym, pos, env.enclClass.sym.type, sym.name, true);
3714         }
3715     }
3716 
3717     boolean enclosingInstanceMissing(Env&lt;AttrContext&gt; env, Type type) {
3718         if (type.hasTag(CLASS) &amp;&amp; type.getEnclosingType().hasTag(CLASS)) {
3719             Symbol encl = resolveSelfContainingInternal(env, type.tsym, false);
3720             return encl == null || encl.kind.isResolutionError();
3721         }
3722         return false;
3723     }
3724 
3725     private Symbol resolveSelfContainingInternal(Env&lt;AttrContext&gt; env,
3726                                  Symbol member,
3727                                  boolean isSuperCall) {
3728         Name name = names._this;
3729         Env&lt;AttrContext&gt; env1 = isSuperCall ? env.outer : env;
3730         boolean staticOnly = false;
3731         if (env1 != null) {
3732             while (env1 != null &amp;&amp; env1.outer != null) {
3733                 if (isStatic(env1)) staticOnly = true;
3734                 if (env1.enclClass.sym.isSubClass(member.owner.enclClass(), types)) {
3735                     Symbol sym = env1.info.scope.findFirst(name);
3736                     if (sym != null) {
3737                         if (staticOnly) sym = new StaticError(sym);
3738                         return sym;
3739                     }
3740                 }
3741                 if ((env1.enclClass.sym.flags() &amp; STATIC) != 0)
3742                     staticOnly = true;
3743                 env1 = env1.outer;
3744             }
3745         }
3746         return null;
3747     }
3748 
3749     /**
3750      * Resolve an appropriate implicit this instance for t&#39;s container.
3751      * JLS 8.8.5.1 and 15.9.2
3752      */
3753     Type resolveImplicitThis(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type t) {
3754         return resolveImplicitThis(pos, env, t, false);
3755     }
3756 
3757     Type resolveImplicitThis(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type t, boolean isSuperCall) {
3758         Type thisType = (t.tsym.owner.kind.matches(KindSelector.VAL_MTH)
3759                          ? resolveSelf(pos, env, t.getEnclosingType().tsym, names._this)
3760                          : resolveSelfContaining(pos, env, t.tsym, isSuperCall)).type;
3761         if (env.info.isSelfCall &amp;&amp; thisType.tsym == env.enclClass.sym) {
3762             log.error(pos, Errors.CantRefBeforeCtorCalled(&quot;this&quot;));
3763         }
3764         return thisType;
3765     }
3766 
3767 /* ***************************************************************************
3768  *  ResolveError classes, indicating error situations when accessing symbols
3769  ****************************************************************************/
3770 
3771     //used by TransTypes when checking target type of synthetic cast
3772     public void logAccessErrorInternal(Env&lt;AttrContext&gt; env, JCTree tree, Type type) {
3773         AccessError error = new AccessError(env, env.enclClass.type, type.tsym);
3774         logResolveError(error, tree.pos(), env.enclClass.sym, env.enclClass.type, null, null, null);
3775     }
3776     //where
3777     private void logResolveError(ResolveError error,
3778             DiagnosticPosition pos,
3779             Symbol location,
3780             Type site,
3781             Name name,
3782             List&lt;Type&gt; argtypes,
3783             List&lt;Type&gt; typeargtypes) {
3784         JCDiagnostic d = error.getDiagnostic(JCDiagnostic.DiagnosticType.ERROR,
3785                 pos, location, site, name, argtypes, typeargtypes);
3786         if (d != null) {
3787             d.setFlag(DiagnosticFlag.RESOLVE_ERROR);
3788             log.report(d);
3789         }
3790     }
3791 
3792     private final LocalizedString noArgs = new LocalizedString(&quot;compiler.misc.no.args&quot;);
3793 
3794     public Object methodArguments(List&lt;Type&gt; argtypes) {
3795         if (argtypes == null || argtypes.isEmpty()) {
3796             return noArgs;
3797         } else {
3798             ListBuffer&lt;Object&gt; diagArgs = new ListBuffer&lt;&gt;();
3799             for (Type t : argtypes) {
3800                 if (t.hasTag(DEFERRED)) {
3801                     diagArgs.append(((DeferredAttr.DeferredType)t).tree);
3802                 } else {
3803                     diagArgs.append(t);
3804                 }
3805             }
3806             return diagArgs;
3807         }
3808     }
3809 
3810     /**
3811      * Root class for resolution errors. Subclass of ResolveError
3812      * represent a different kinds of resolution error - as such they must
3813      * specify how they map into concrete compiler diagnostics.
3814      */
3815     abstract class ResolveError extends Symbol {
3816 
3817         /** The name of the kind of error, for debugging only. */
3818         final String debugName;
3819 
3820         ResolveError(Kind kind, String debugName) {
3821             super(kind, 0, null, null, null);
3822             this.debugName = debugName;
3823         }
3824 
3825         @Override @DefinedBy(Api.LANGUAGE_MODEL)
3826         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
3827             throw new AssertionError();
3828         }
3829 
3830         @Override
3831         public String toString() {
3832             return debugName;
3833         }
3834 
3835         @Override
3836         public boolean exists() {
3837             return false;
3838         }
3839 
3840         @Override
3841         public boolean isStatic() {
3842             return false;
3843         }
3844 
3845         /**
3846          * Create an external representation for this erroneous symbol to be
3847          * used during attribution - by default this returns the symbol of a
3848          * brand new error type which stores the original type found
3849          * during resolution.
3850          *
3851          * @param name     the name used during resolution
3852          * @param location the location from which the symbol is accessed
3853          */
3854         protected Symbol access(Name name, TypeSymbol location) {
3855             return types.createErrorType(name, location, syms.errSymbol.type).tsym;
3856         }
3857 
3858         /**
3859          * Create a diagnostic representing this resolution error.
3860          *
3861          * @param dkind     The kind of the diagnostic to be created (e.g error).
3862          * @param pos       The position to be used for error reporting.
3863          * @param site      The original type from where the selection took place.
3864          * @param name      The name of the symbol to be resolved.
3865          * @param argtypes  The invocation&#39;s value arguments,
3866          *                  if we looked for a method.
3867          * @param typeargtypes  The invocation&#39;s type arguments,
3868          *                      if we looked for a method.
3869          */
3870         abstract JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
3871                 DiagnosticPosition pos,
3872                 Symbol location,
3873                 Type site,
3874                 Name name,
3875                 List&lt;Type&gt; argtypes,
3876                 List&lt;Type&gt; typeargtypes);
3877     }
3878 
3879     /**
3880      * This class is the root class of all resolution errors caused by
3881      * an invalid symbol being found during resolution.
3882      */
3883     abstract class InvalidSymbolError extends ResolveError {
3884 
3885         /** The invalid symbol found during resolution */
3886         Symbol sym;
3887 
3888         InvalidSymbolError(Kind kind, Symbol sym, String debugName) {
3889             super(kind, debugName);
3890             this.sym = sym;
3891         }
3892 
3893         @Override
3894         public boolean exists() {
3895             return true;
3896         }
3897 
3898         @Override
3899         public String toString() {
3900              return super.toString() + &quot; wrongSym=&quot; + sym;
3901         }
3902 
3903         @Override
3904         public Symbol access(Name name, TypeSymbol location) {
3905             if (!sym.kind.isResolutionError() &amp;&amp; sym.kind.matches(KindSelector.TYP))
3906                 return types.createErrorType(name, location, sym.type).tsym;
3907             else
3908                 return sym;
3909         }
3910     }
3911 
3912     class BadRestrictedTypeError extends ResolveError {
3913         private final Name typeName;
3914         BadRestrictedTypeError(Name typeName) {
3915             super(Kind.BAD_RESTRICTED_TYPE, &quot;bad var use&quot;);
3916             this.typeName = typeName;
3917         }
3918 
3919         @Override
3920         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
3921             return diags.create(dkind, log.currentSource(), pos, &quot;illegal.ref.to.restricted.type&quot;, typeName);
3922         }
3923     }
3924 
3925     /**
3926      * InvalidSymbolError error class indicating that a symbol matching a
3927      * given name does not exists in a given site.
3928      */
3929     class SymbolNotFoundError extends ResolveError {
3930 
3931         SymbolNotFoundError(Kind kind) {
3932             this(kind, &quot;symbol not found error&quot;);
3933         }
3934 
3935         SymbolNotFoundError(Kind kind, String debugName) {
3936             super(kind, debugName);
3937         }
3938 
3939         @Override
3940         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
3941                 DiagnosticPosition pos,
3942                 Symbol location,
3943                 Type site,
3944                 Name name,
3945                 List&lt;Type&gt; argtypes,
3946                 List&lt;Type&gt; typeargtypes) {
3947             argtypes = argtypes == null ? List.nil() : argtypes;
3948             typeargtypes = typeargtypes == null ? List.nil() : typeargtypes;
3949             if (name == names.error)
3950                 return null;
3951 
3952             boolean hasLocation = false;
3953             if (location == null) {
3954                 location = site.tsym;
3955             }
3956             if (!location.name.isEmpty()) {
3957                 if (location.kind == PCK &amp;&amp; !site.tsym.exists()) {
3958                     return diags.create(dkind, log.currentSource(), pos,
3959                         &quot;doesnt.exist&quot;, location);
3960                 }
3961                 hasLocation = !location.name.equals(names._this) &amp;&amp;
3962                         !location.name.equals(names._super);
3963             }
3964             boolean isConstructor = name == names.init;
3965             KindName kindname = isConstructor ? KindName.CONSTRUCTOR : kind.absentKind();
3966             Name idname = isConstructor ? site.tsym.name : name;
3967             String errKey = getErrorKey(kindname, typeargtypes.nonEmpty(), hasLocation);
3968             if (hasLocation) {
3969                 return diags.create(dkind, log.currentSource(), pos,
3970                         errKey, kindname, idname, //symbol kindname, name
3971                         typeargtypes, args(argtypes), //type parameters and arguments (if any)
3972                         getLocationDiag(location, site)); //location kindname, type
3973             }
3974             else {
3975                 return diags.create(dkind, log.currentSource(), pos,
3976                         errKey, kindname, idname, //symbol kindname, name
3977                         typeargtypes, args(argtypes)); //type parameters and arguments (if any)
3978             }
3979         }
3980         //where
3981         private Object args(List&lt;Type&gt; args) {
3982             return args.isEmpty() ? args : methodArguments(args);
3983         }
3984 
3985         private String getErrorKey(KindName kindname, boolean hasTypeArgs, boolean hasLocation) {
3986             String key = &quot;cant.resolve&quot;;
3987             String suffix = hasLocation ? &quot;.location&quot; : &quot;&quot;;
3988             switch (kindname) {
3989                 case METHOD:
3990                 case CONSTRUCTOR: {
3991                     suffix += &quot;.args&quot;;
3992                     suffix += hasTypeArgs ? &quot;.params&quot; : &quot;&quot;;
3993                 }
3994             }
3995             return key + suffix;
3996         }
3997         private JCDiagnostic getLocationDiag(Symbol location, Type site) {
3998             if (location.kind == VAR) {
3999                 return diags.fragment(Fragments.Location1(kindName(location),
4000                                                           location,
4001                                                           location.type));
4002             } else {
4003                 return diags.fragment(Fragments.Location(typeKindName(site),
4004                                       site,
4005                                       null));
4006             }
4007         }
4008     }
4009 
4010     /**
4011      * InvalidSymbolError error class indicating that a given symbol
4012      * (either a method, a constructor or an operand) is not applicable
4013      * given an actual arguments/type argument list.
4014      */
4015     class InapplicableSymbolError extends ResolveError {
4016 
4017         protected MethodResolutionContext resolveContext;
4018 
4019         InapplicableSymbolError(MethodResolutionContext context) {
4020             this(WRONG_MTH, &quot;inapplicable symbol error&quot;, context);
4021         }
4022 
4023         protected InapplicableSymbolError(Kind kind, String debugName, MethodResolutionContext context) {
4024             super(kind, debugName);
4025             this.resolveContext = context;
4026         }
4027 
4028         @Override
4029         public String toString() {
4030             return super.toString();
4031         }
4032 
4033         @Override
4034         public boolean exists() {
4035             return true;
4036         }
4037 
4038         @Override
4039         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4040                 DiagnosticPosition pos,
4041                 Symbol location,
4042                 Type site,
4043                 Name name,
4044                 List&lt;Type&gt; argtypes,
4045                 List&lt;Type&gt; typeargtypes) {
4046             if (name == names.error)
4047                 return null;
4048 
4049             Pair&lt;Symbol, JCDiagnostic&gt; c = errCandidate();
4050             if (compactMethodDiags) {
4051                 JCDiagnostic simpleDiag =
4052                     MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, c.snd);
4053                 if (simpleDiag != null) {
4054                     return simpleDiag;
4055                 }
4056             }
4057             Symbol ws = c.fst.asMemberOf(site, types);
4058             return diags.create(dkind, log.currentSource(), pos,
4059                       &quot;cant.apply.symbol&quot;,
4060                       kindName(ws),
4061                       ws.name == names.init ? ws.owner.name : ws.name,
4062                       methodArguments(ws.type.getParameterTypes()),
4063                       methodArguments(argtypes),
4064                       kindName(ws.owner),
4065                       ws.owner.type,
4066                       c.snd);
4067         }
4068 
4069         @Override
4070         public Symbol access(Name name, TypeSymbol location) {
4071             Symbol sym = bestCandidate();
4072             return types.createErrorType(name, location, sym != null ? sym.type : syms.errSymbol.type).tsym;
4073         }
4074 
4075         protected Symbol bestCandidate() {
4076             return errCandidate().fst;
4077         }
4078 
4079         protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4080             Candidate bestSoFar = null;
4081             for (Candidate c : resolveContext.candidates) {
4082                 if (c.isApplicable()) continue;
4083                 bestSoFar = c;
4084             }
4085             Assert.checkNonNull(bestSoFar);
4086             return new Pair&lt;&gt;(bestSoFar.sym, bestSoFar.details);
4087         }
4088     }
4089 
4090     /**
4091      * ResolveError error class indicating that a symbol (either methods, constructors or operand)
4092      * is not applicable given an actual arguments/type argument list.
4093      */
4094     class InapplicableSymbolsError extends InapplicableSymbolError {
4095 
4096         InapplicableSymbolsError(MethodResolutionContext context) {
4097             super(WRONG_MTHS, &quot;inapplicable symbols&quot;, context);
4098         }
4099 
4100         @Override
4101         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4102                 DiagnosticPosition pos,
4103                 Symbol location,
4104                 Type site,
4105                 Name name,
4106                 List&lt;Type&gt; argtypes,
4107                 List&lt;Type&gt; typeargtypes) {
4108             Map&lt;Symbol, JCDiagnostic&gt; candidatesMap = mapCandidates();
4109             Map&lt;Symbol, JCDiagnostic&gt; filteredCandidates = compactMethodDiags ?
4110                     filterCandidates(candidatesMap) :
4111                     mapCandidates();
4112             if (filteredCandidates.isEmpty()) {
4113                 filteredCandidates = candidatesMap;
4114             }
4115             boolean truncatedDiag = candidatesMap.size() != filteredCandidates.size();
4116             if (filteredCandidates.size() &gt; 1) {
4117                 JCDiagnostic err = diags.create(dkind,
4118                         null,
4119                         truncatedDiag ?
4120                             EnumSet.of(DiagnosticFlag.COMPRESSED) :
4121                             EnumSet.noneOf(DiagnosticFlag.class),
4122                         log.currentSource(),
4123                         pos,
4124                         &quot;cant.apply.symbols&quot;,
4125                         name == names.init ? KindName.CONSTRUCTOR : kind.absentKind(),
4126                         name == names.init ? site.tsym.name : name,
4127                         methodArguments(argtypes));
4128                 return new JCDiagnostic.MultilineDiagnostic(err, candidateDetails(filteredCandidates, site));
4129             } else if (filteredCandidates.size() == 1) {
4130                 Map.Entry&lt;Symbol, JCDiagnostic&gt; _e =
4131                                 filteredCandidates.entrySet().iterator().next();
4132                 final Pair&lt;Symbol, JCDiagnostic&gt; p = new Pair&lt;&gt;(_e.getKey(), _e.getValue());
4133                 JCDiagnostic d = new InapplicableSymbolError(resolveContext) {
4134                     @Override
4135                     protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4136                         return p;
4137                     }
4138                 }.getDiagnostic(dkind, pos,
4139                     location, site, name, argtypes, typeargtypes);
4140                 if (truncatedDiag) {
4141                     d.setFlag(DiagnosticFlag.COMPRESSED);
4142                 }
4143                 return d;
4144             } else {
4145                 return new SymbolNotFoundError(ABSENT_MTH).getDiagnostic(dkind, pos,
4146                     location, site, name, argtypes, typeargtypes);
4147             }
4148         }
4149         //where
4150             private Map&lt;Symbol, JCDiagnostic&gt; mapCandidates() {
4151                 MostSpecificMap candidates = new MostSpecificMap();
4152                 for (Candidate c : resolveContext.candidates) {
4153                     if (c.isApplicable()) continue;
4154                     candidates.put(c);
4155                 }
4156                 return candidates;
4157             }
4158 
4159             @SuppressWarnings(&quot;serial&quot;)
4160             private class MostSpecificMap extends LinkedHashMap&lt;Symbol, JCDiagnostic&gt; {
4161                 private void put(Candidate c) {
4162                     ListBuffer&lt;Symbol&gt; overridden = new ListBuffer&lt;&gt;();
4163                     for (Symbol s : keySet()) {
4164                         if (s == c.sym) {
4165                             continue;
4166                         }
4167                         if (c.sym.overrides(s, (TypeSymbol)s.owner, types, false)) {
4168                             overridden.add(s);
4169                         } else if (s.overrides(c.sym, (TypeSymbol)c.sym.owner, types, false)) {
4170                             return;
4171                         }
4172                     }
4173                     for (Symbol s : overridden) {
4174                         remove(s);
4175                     }
4176                     put(c.sym, c.details);
4177                 }
4178             }
4179 
4180             Map&lt;Symbol, JCDiagnostic&gt; filterCandidates(Map&lt;Symbol, JCDiagnostic&gt; candidatesMap) {
4181                 Map&lt;Symbol, JCDiagnostic&gt; candidates = new LinkedHashMap&lt;&gt;();
4182                 for (Map.Entry&lt;Symbol, JCDiagnostic&gt; _entry : candidatesMap.entrySet()) {
4183                     JCDiagnostic d = _entry.getValue();
4184                     if (!new Template(MethodCheckDiag.ARITY_MISMATCH.regex()).matches(d)) {
4185                         candidates.put(_entry.getKey(), d);
4186                     }
4187                 }
4188                 return candidates;
4189             }
4190 
4191             private List&lt;JCDiagnostic&gt; candidateDetails(Map&lt;Symbol, JCDiagnostic&gt; candidatesMap, Type site) {
4192                 List&lt;JCDiagnostic&gt; details = List.nil();
4193                 for (Map.Entry&lt;Symbol, JCDiagnostic&gt; _entry : candidatesMap.entrySet()) {
4194                     Symbol sym = _entry.getKey();
4195                     JCDiagnostic detailDiag =
4196                             diags.fragment(Fragments.InapplicableMethod(Kinds.kindName(sym),
4197                                                                         sym.location(site, types),
4198                                                                         sym.asMemberOf(site, types),
4199                                                                         _entry.getValue()));
4200                     details = details.prepend(detailDiag);
4201                 }
4202                 //typically members are visited in reverse order (see Scope)
4203                 //so we need to reverse the candidate list so that candidates
4204                 //conform to source order
4205                 return details;
4206             }
4207 
4208         @Override
4209         protected Symbol bestCandidate() {
4210             Map&lt;Symbol, JCDiagnostic&gt; candidatesMap = mapCandidates();
4211             Map&lt;Symbol, JCDiagnostic&gt; filteredCandidates = filterCandidates(candidatesMap);
4212             if (filteredCandidates.size() == 1) {
4213                 return filteredCandidates.keySet().iterator().next();
4214             }
4215             return null;
4216         }
4217     }
4218 
4219     /**
4220      * DiamondError error class indicating that a constructor symbol is not applicable
4221      * given an actual arguments/type argument list using diamond inference.
4222      */
4223     class DiamondError extends InapplicableSymbolError {
4224 
4225         Symbol sym;
4226 
4227         public DiamondError(Symbol sym, MethodResolutionContext context) {
4228             super(sym.kind, &quot;diamondError&quot;, context);
4229             this.sym = sym;
4230         }
4231 
4232         JCDiagnostic getDetails() {
4233             return (sym.kind == WRONG_MTH) ?
4234                     ((InapplicableSymbolError)sym.baseSymbol()).errCandidate().snd :
4235                     null;
4236         }
4237 
4238         @Override
4239         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos,
4240                 Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4241             JCDiagnostic details = getDetails();
4242             if (details != null &amp;&amp; compactMethodDiags) {
4243                 JCDiagnostic simpleDiag =
4244                         MethodResolutionDiagHelper.rewrite(diags, pos, log.currentSource(), dkind, details);
4245                 if (simpleDiag != null) {
4246                     return simpleDiag;
4247                 }
4248             }
4249             String key = details == null ?
4250                 &quot;cant.apply.diamond&quot; :
4251                 &quot;cant.apply.diamond.1&quot;;
4252             return diags.create(dkind, log.currentSource(), pos, key,
4253                     Fragments.Diamond(site.tsym), details);
4254         }
4255     }
4256 
4257     /**
4258      * An InvalidSymbolError error class indicating that a symbol is not
4259      * accessible from a given site
4260      */
4261     class AccessError extends InvalidSymbolError {
4262 
4263         private Env&lt;AttrContext&gt; env;
4264         private Type site;
4265 
4266         AccessError(Env&lt;AttrContext&gt; env, Type site, Symbol sym) {
4267             super(HIDDEN, sym, &quot;access error&quot;);
4268             this.env = env;
4269             this.site = site;
4270         }
4271 
4272         @Override
4273         public boolean exists() {
4274             return false;
4275         }
4276 
4277         @Override
4278         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4279                 DiagnosticPosition pos,
4280                 Symbol location,
4281                 Type site,
4282                 Name name,
4283                 List&lt;Type&gt; argtypes,
4284                 List&lt;Type&gt; typeargtypes) {
4285             if (sym.name == names.init &amp;&amp; sym.owner != site.tsym) {
4286                 return new SymbolNotFoundError(ABSENT_MTH).getDiagnostic(dkind,
4287                         pos, location, site, name, argtypes, typeargtypes);
4288             }
4289             else if ((sym.flags() &amp; PUBLIC) != 0
4290                 || (env != null &amp;&amp; this.site != null
4291                     &amp;&amp; !isAccessible(env, this.site))) {
4292                 if (sym.owner.kind == PCK) {
4293                     return diags.create(dkind, log.currentSource(),
4294                             pos, &quot;not.def.access.package.cant.access&quot;,
4295                         sym, sym.location(), inaccessiblePackageReason(env, sym.packge()));
4296                 } else if (   sym.packge() != syms.rootPackage
4297                            &amp;&amp; !symbolPackageVisible(env, sym)) {
4298                     return diags.create(dkind, log.currentSource(),
4299                             pos, &quot;not.def.access.class.intf.cant.access.reason&quot;,
4300                             sym, sym.location(), sym.location().packge(),
4301                             inaccessiblePackageReason(env, sym.packge()));
4302                 } else {
4303                     return diags.create(dkind, log.currentSource(),
4304                             pos, &quot;not.def.access.class.intf.cant.access&quot;,
4305                         sym, sym.location());
4306                 }
4307             }
4308             else if ((sym.flags() &amp; (PRIVATE | PROTECTED)) != 0) {
4309                 return diags.create(dkind, log.currentSource(),
4310                         pos, &quot;report.access&quot;, sym,
4311                         asFlagSet(sym.flags() &amp; (PRIVATE | PROTECTED)),
4312                         sym.location());
4313             }
4314             else {
4315                 return diags.create(dkind, log.currentSource(),
4316                         pos, &quot;not.def.public.cant.access&quot;, sym, sym.location());
4317             }
4318         }
4319 
4320         private String toString(Type type) {
4321             StringBuilder sb = new StringBuilder();
4322             sb.append(type);
4323             if (type != null) {
4324                 sb.append(&quot;[tsym:&quot;).append(type.tsym);
4325                 if (type.tsym != null)
4326                     sb.append(&quot;packge:&quot;).append(type.tsym.packge());
4327                 sb.append(&quot;]&quot;);
4328             }
4329             return sb.toString();
4330         }
4331     }
4332 
4333     class InvisibleSymbolError extends InvalidSymbolError {
4334 
4335         private final Env&lt;AttrContext&gt; env;
4336         private final boolean suppressError;
4337 
4338         InvisibleSymbolError(Env&lt;AttrContext&gt; env, boolean suppressError, Symbol sym) {
4339             super(HIDDEN, sym, &quot;invisible class error&quot;);
4340             this.env = env;
4341             this.suppressError = suppressError;
4342             this.name = sym.name;
4343         }
4344 
4345         @Override
4346         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4347                 DiagnosticPosition pos,
4348                 Symbol location,
4349                 Type site,
4350                 Name name,
4351                 List&lt;Type&gt; argtypes,
4352                 List&lt;Type&gt; typeargtypes) {
4353             if (suppressError)
4354                 return null;
4355 
4356             if (sym.kind == PCK) {
4357                 JCDiagnostic details = inaccessiblePackageReason(env, sym.packge());
4358                 return diags.create(dkind, log.currentSource(),
4359                         pos, &quot;package.not.visible&quot;, sym, details);
4360             }
4361 
4362             JCDiagnostic details = inaccessiblePackageReason(env, sym.packge());
4363 
4364             if (pos.getTree() != null) {
4365                 Symbol o = sym;
4366                 JCTree tree = pos.getTree();
4367 
4368                 while (o.kind != PCK &amp;&amp; tree.hasTag(SELECT)) {
4369                     o = o.owner;
4370                     tree = ((JCFieldAccess) tree).selected;
4371                 }
4372 
4373                 if (o.kind == PCK) {
4374                     pos = tree.pos();
4375 
4376                     return diags.create(dkind, log.currentSource(),
4377                             pos, &quot;package.not.visible&quot;, o, details);
4378                 }
4379             }
4380 
4381             return diags.create(dkind, log.currentSource(),
4382                     pos, &quot;not.def.access.package.cant.access&quot;, sym, sym.packge(), details);
4383         }
4384     }
4385 
4386     JCDiagnostic inaccessiblePackageReason(Env&lt;AttrContext&gt; env, PackageSymbol sym) {
4387         //no dependency:
4388         if (!env.toplevel.modle.readModules.contains(sym.modle)) {
4389             //does not read:
4390             if (sym.modle != syms.unnamedModule) {
4391                 if (env.toplevel.modle != syms.unnamedModule) {
4392                     return diags.fragment(Fragments.NotDefAccessDoesNotRead(env.toplevel.modle,
4393                                                                             sym,
4394                                                                             sym.modle));
4395                 } else {
4396                     return diags.fragment(Fragments.NotDefAccessDoesNotReadFromUnnamed(sym,
4397                                                                                        sym.modle));
4398                 }
4399             } else {
4400                 return diags.fragment(Fragments.NotDefAccessDoesNotReadUnnamed(sym,
4401                                                                                env.toplevel.modle));
4402             }
4403         } else {
4404             if (sym.packge().modle.exports.stream().anyMatch(e -&gt; e.packge == sym)) {
4405                 //not exported to this module:
4406                 if (env.toplevel.modle != syms.unnamedModule) {
4407                     return diags.fragment(Fragments.NotDefAccessNotExportedToModule(sym,
4408                                                                                     sym.modle,
4409                                                                                     env.toplevel.modle));
4410                 } else {
4411                     return diags.fragment(Fragments.NotDefAccessNotExportedToModuleFromUnnamed(sym,
4412                                                                                                sym.modle));
4413                 }
4414             } else {
4415                 //not exported:
4416                 if (env.toplevel.modle != syms.unnamedModule) {
4417                     return diags.fragment(Fragments.NotDefAccessNotExported(sym,
4418                                                                             sym.modle));
4419                 } else {
4420                     return diags.fragment(Fragments.NotDefAccessNotExportedFromUnnamed(sym,
4421                                                                                        sym.modle));
4422                 }
4423             }
4424         }
4425     }
4426 
4427     /**
4428      * InvalidSymbolError error class indicating that an instance member
4429      * has erroneously been accessed from a static context.
4430      */
4431     class StaticError extends InvalidSymbolError {
4432 
4433         StaticError(Symbol sym) {
4434             super(STATICERR, sym, &quot;static error&quot;);
4435         }
4436 
4437         @Override
4438         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4439                 DiagnosticPosition pos,
4440                 Symbol location,
4441                 Type site,
4442                 Name name,
4443                 List&lt;Type&gt; argtypes,
4444                 List&lt;Type&gt; typeargtypes) {
4445             Symbol errSym = ((sym.kind == TYP &amp;&amp; sym.type.hasTag(CLASS))
4446                 ? types.erasure(sym.type).tsym
4447                 : sym);
4448             return diags.create(dkind, log.currentSource(), pos,
4449                     &quot;non-static.cant.be.ref&quot;, kindName(sym), errSym);
4450         }
4451     }
4452 
4453     /**
4454      * InvalidSymbolError error class indicating that a pair of symbols
4455      * (either methods, constructors or operands) are ambiguous
4456      * given an actual arguments/type argument list.
4457      */
4458     class AmbiguityError extends ResolveError {
4459 
4460         /** The other maximally specific symbol */
4461         List&lt;Symbol&gt; ambiguousSyms = List.nil();
4462 
4463         @Override
4464         public boolean exists() {
4465             return true;
4466         }
4467 
4468         AmbiguityError(Symbol sym1, Symbol sym2) {
4469             super(AMBIGUOUS, &quot;ambiguity error&quot;);
4470             ambiguousSyms = flatten(sym2).appendList(flatten(sym1));
4471         }
4472 
4473         private List&lt;Symbol&gt; flatten(Symbol sym) {
4474             if (sym.kind == AMBIGUOUS) {
4475                 return ((AmbiguityError)sym.baseSymbol()).ambiguousSyms;
4476             } else {
4477                 return List.of(sym);
4478             }
4479         }
4480 
4481         AmbiguityError addAmbiguousSymbol(Symbol s) {
4482             ambiguousSyms = ambiguousSyms.prepend(s);
4483             return this;
4484         }
4485 
4486         @Override
4487         JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
4488                 DiagnosticPosition pos,
4489                 Symbol location,
4490                 Type site,
4491                 Name name,
4492                 List&lt;Type&gt; argtypes,
4493                 List&lt;Type&gt; typeargtypes) {
4494             List&lt;Symbol&gt; diagSyms = ambiguousSyms.reverse();
4495             Symbol s1 = diagSyms.head;
4496             Symbol s2 = diagSyms.tail.head;
4497             Name sname = s1.name;
4498             if (sname == names.init) sname = s1.owner.name;
4499             return diags.create(dkind, log.currentSource(),
4500                     pos, &quot;ref.ambiguous&quot;, sname,
4501                     kindName(s1),
4502                     s1,
4503                     s1.location(site, types),
4504                     kindName(s2),
4505                     s2,
4506                     s2.location(site, types));
4507         }
4508 
4509         /**
4510          * If multiple applicable methods are found during overload and none of them
4511          * is more specific than the others, attempt to merge their signatures.
4512          */
4513         Symbol mergeAbstracts(Type site) {
4514             List&lt;Symbol&gt; ambiguousInOrder = ambiguousSyms.reverse();
4515             return types.mergeAbstracts(ambiguousInOrder, site, true).orElse(this);
4516         }
4517 
4518         @Override
4519         protected Symbol access(Name name, TypeSymbol location) {
4520             Symbol firstAmbiguity = ambiguousSyms.last();
4521             return firstAmbiguity.kind == TYP ?
4522                     types.createErrorType(name, location, firstAmbiguity.type).tsym :
4523                     firstAmbiguity;
4524         }
4525     }
4526 
4527     class BadVarargsMethod extends ResolveError {
4528 
4529         ResolveError delegatedError;
4530 
4531         BadVarargsMethod(ResolveError delegatedError) {
4532             super(delegatedError.kind, &quot;badVarargs&quot;);
4533             this.delegatedError = delegatedError;
4534         }
4535 
4536         @Override
4537         public Symbol baseSymbol() {
4538             return delegatedError.baseSymbol();
4539         }
4540 
4541         @Override
4542         protected Symbol access(Name name, TypeSymbol location) {
4543             return delegatedError.access(name, location);
4544         }
4545 
4546         @Override
4547         public boolean exists() {
4548             return true;
4549         }
4550 
4551         @Override
4552         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4553             return delegatedError.getDiagnostic(dkind, pos, location, site, name, argtypes, typeargtypes);
4554         }
4555     }
4556 
4557     /**
4558      * BadMethodReferenceError error class indicating that a method reference symbol has been found,
4559      * but with the wrong staticness.
4560      */
4561     class BadMethodReferenceError extends StaticError {
4562 
4563         boolean unboundLookup;
4564 
4565         public BadMethodReferenceError(Symbol sym, boolean unboundLookup) {
4566             super(sym);
4567             this.unboundLookup = unboundLookup;
4568         }
4569 
4570         @Override
4571         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4572             final String key;
4573             if (!unboundLookup) {
4574                 key = &quot;bad.static.method.in.bound.lookup&quot;;
4575             } else if (sym.isStatic()) {
4576                 key = &quot;bad.static.method.in.unbound.lookup&quot;;
4577             } else {
4578                 key = &quot;bad.instance.method.in.unbound.lookup&quot;;
4579             }
4580             return sym.kind.isResolutionError() ?
4581                     ((ResolveError)sym).getDiagnostic(dkind, pos, location, site, name, argtypes, typeargtypes) :
4582                     diags.create(dkind, log.currentSource(), pos, key, Kinds.kindName(sym), sym);
4583         }
4584     }
4585 
4586     /**
4587      * BadConstructorReferenceError error class indicating that a constructor reference symbol has been found,
4588      * but pointing to a class for which an enclosing instance is not available.
4589      */
4590     class BadConstructorReferenceError extends InvalidSymbolError {
4591 
4592         public BadConstructorReferenceError(Symbol sym) {
4593             super(MISSING_ENCL, sym, &quot;BadConstructorReferenceError&quot;);
4594         }
4595 
4596         @Override
4597         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4598            return diags.create(dkind, log.currentSource(), pos,
4599                 &quot;cant.access.inner.cls.constr&quot;, site.tsym.name, argtypes, site.getEnclosingType());
4600         }
4601     }
4602 
4603     class BadClassFileError extends InvalidSymbolError {
4604 
4605         private final CompletionFailure ex;
4606 
4607         public BadClassFileError(CompletionFailure ex) {
4608             super(HIDDEN, ex.sym, &quot;BadClassFileError&quot;);
4609             this.name = sym.name;
4610             this.ex = ex;
4611         }
4612 
4613         @Override
4614         JCDiagnostic getDiagnostic(DiagnosticType dkind, DiagnosticPosition pos, Symbol location, Type site, Name name, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
4615             JCDiagnostic d = diags.create(dkind, log.currentSource(), pos,
4616                 &quot;cant.access&quot;, ex.sym, ex.getDetailValue());
4617 
4618             d.setFlag(DiagnosticFlag.NON_DEFERRABLE);
4619             return d;
4620         }
4621 
4622     }
4623 
4624     /**
4625      * Helper class for method resolution diagnostic simplification.
4626      * Certain resolution diagnostic are rewritten as simpler diagnostic
4627      * where the enclosing resolution diagnostic (i.e. &#39;inapplicable method&#39;)
4628      * is stripped away, as it doesn&#39;t carry additional info. The logic
4629      * for matching a given diagnostic is given in terms of a template
4630      * hierarchy: a diagnostic template can be specified programmatically,
4631      * so that only certain diagnostics are matched. Each templete is then
4632      * associated with a rewriter object that carries out the task of rewtiting
4633      * the diagnostic to a simpler one.
4634      */
4635     static class MethodResolutionDiagHelper {
4636 
4637         /**
4638          * A diagnostic rewriter transforms a method resolution diagnostic
4639          * into a simpler one
4640          */
4641         interface DiagnosticRewriter {
4642             JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
4643                     DiagnosticPosition preferredPos, DiagnosticSource preferredSource,
4644                     DiagnosticType preferredKind, JCDiagnostic d);
4645         }
4646 
4647         /**
4648          * A diagnostic template is made up of two ingredients: (i) a regular
4649          * expression for matching a diagnostic key and (ii) a list of sub-templates
4650          * for matching diagnostic arguments.
4651          */
4652         static class Template {
4653 
4654             /** regex used to match diag key */
4655             String regex;
4656 
4657             /** templates used to match diagnostic args */
4658             Template[] subTemplates;
4659 
4660             Template(String key, Template... subTemplates) {
4661                 this.regex = key;
4662                 this.subTemplates = subTemplates;
4663             }
4664 
4665             /**
4666              * Returns true if the regex matches the diagnostic key and if
4667              * all diagnostic arguments are matches by corresponding sub-templates.
4668              */
4669             boolean matches(Object o) {
4670                 JCDiagnostic d = (JCDiagnostic)o;
4671                 Object[] args = d.getArgs();
4672                 if (!d.getCode().matches(regex) ||
4673                         subTemplates.length != d.getArgs().length) {
4674                     return false;
4675                 }
4676                 for (int i = 0; i &lt; args.length ; i++) {
4677                     if (!subTemplates[i].matches(args[i])) {
4678                         return false;
4679                     }
4680                 }
4681                 return true;
4682             }
4683         }
4684 
4685         /**
4686          * Common rewriter for all argument mismatch simplifications.
4687          */
4688         static class ArgMismatchRewriter implements DiagnosticRewriter {
4689 
4690             /** the index of the subdiagnostic to be used as primary. */
4691             int causeIndex;
4692 
4693             public ArgMismatchRewriter(int causeIndex) {
4694                 this.causeIndex = causeIndex;
4695             }
4696 
4697             @Override
4698             public JCDiagnostic rewriteDiagnostic(JCDiagnostic.Factory diags,
4699                     DiagnosticPosition preferredPos, DiagnosticSource preferredSource,
4700                     DiagnosticType preferredKind, JCDiagnostic d) {
4701                 JCDiagnostic cause = (JCDiagnostic)d.getArgs()[causeIndex];
4702                 DiagnosticPosition pos = d.getDiagnosticPosition();
4703                 if (pos == null) {
4704                     pos = preferredPos;
4705                 }
4706                 return diags.create(preferredKind, preferredSource, pos,
4707                         &quot;prob.found.req&quot;, cause);
4708             }
4709         }
4710 
4711         /** a dummy template that match any diagnostic argument */
4712         static final Template skip = new Template(&quot;&quot;) {
4713             @Override
4714             boolean matches(Object d) {
4715                 return true;
4716             }
4717         };
4718 
4719         /** template for matching inference-free arguments mismatch failures */
4720         static final Template argMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip);
4721 
4722         /** template for matching inference related arguments mismatch failures */
4723         static final Template inferArgMismatchTemplate = new Template(MethodCheckDiag.ARG_MISMATCH.regex(), skip, skip) {
4724             @Override
4725             boolean matches(Object o) {
4726                 if (!super.matches(o)) {
4727                     return false;
4728                 }
4729                 JCDiagnostic d = (JCDiagnostic)o;
4730                 @SuppressWarnings(&quot;unchecked&quot;)
4731                 List&lt;Type&gt; tvars = (List&lt;Type&gt;)d.getArgs()[0];
4732                 return !containsAny(d, tvars);
4733             }
4734 
4735             BiPredicate&lt;Object, List&lt;Type&gt;&gt; containsPredicate = (o, ts) -&gt; {
4736                 if (o instanceof Type) {
4737                     return ((Type)o).containsAny(ts);
4738                 } else if (o instanceof JCDiagnostic) {
4739                     return containsAny((JCDiagnostic)o, ts);
4740                 } else {
4741                     return false;
4742                 }
4743             };
4744 
4745             boolean containsAny(JCDiagnostic d, List&lt;Type&gt; ts) {
4746                 return Stream.of(d.getArgs())
4747                         .anyMatch(o -&gt; containsPredicate.test(o, ts));
4748             }
4749         };
4750 
4751         /** rewriter map used for method resolution simplification */
4752         static final Map&lt;Template, DiagnosticRewriter&gt; rewriters = new LinkedHashMap&lt;&gt;();
4753 
4754         static {
4755             rewriters.put(argMismatchTemplate, new ArgMismatchRewriter(0));
4756             rewriters.put(inferArgMismatchTemplate, new ArgMismatchRewriter(1));
4757         }
4758 
4759         /**
4760          * Main entry point for diagnostic rewriting - given a diagnostic, see if any templates matches it,
4761          * and rewrite it accordingly.
4762          */
4763         static JCDiagnostic rewrite(JCDiagnostic.Factory diags, DiagnosticPosition pos, DiagnosticSource source,
4764                                     DiagnosticType dkind, JCDiagnostic d) {
4765             for (Map.Entry&lt;Template, DiagnosticRewriter&gt; _entry : rewriters.entrySet()) {
4766                 if (_entry.getKey().matches(d)) {
4767                     JCDiagnostic simpleDiag =
4768                             _entry.getValue().rewriteDiagnostic(diags, pos, source, dkind, d);
4769                     simpleDiag.setFlag(DiagnosticFlag.COMPRESSED);
4770                     return simpleDiag;
4771                 }
4772             }
4773             return null;
4774         }
4775     }
4776 
4777     enum MethodResolutionPhase {
4778         BASIC(false, false),
4779         BOX(true, false),
4780         VARARITY(true, true) {
4781             @Override
4782             public Symbol mergeResults(Symbol bestSoFar, Symbol sym) {
4783                 //Check invariants (see {@code LookupHelper.shouldStop})
4784                 Assert.check(bestSoFar.kind.isResolutionError() &amp;&amp; bestSoFar.kind != AMBIGUOUS);
4785                 if (!sym.kind.isResolutionError()) {
4786                     //varargs resolution successful
4787                     return sym;
4788                 } else {
4789                     //pick best error
4790                     switch (bestSoFar.kind) {
4791                         case WRONG_MTH:
4792                         case WRONG_MTHS:
4793                             //Override previous errors if they were caused by argument mismatch.
4794                             //This generally means preferring current symbols - but we need to pay
4795                             //attention to the fact that the varargs lookup returns &#39;less&#39; candidates
4796                             //than the previous rounds, and adjust that accordingly.
4797                             switch (sym.kind) {
4798                                 case WRONG_MTH:
4799                                     //if the previous round matched more than one method, return that
4800                                     //result instead
4801                                     return bestSoFar.kind == WRONG_MTHS ?
4802                                             bestSoFar : sym;
4803                                 case ABSENT_MTH:
4804                                     //do not override erroneous symbol if the arity lookup did not
4805                                     //match any method
4806                                     return bestSoFar;
4807                                 case WRONG_MTHS:
4808                                 default:
4809                                     //safe to override
4810                                     return sym;
4811                             }
4812                         default:
4813                             //otherwise, return first error
4814                             return bestSoFar;
4815                     }
4816                 }
4817             }
4818         };
4819 
4820         final boolean isBoxingRequired;
4821         final boolean isVarargsRequired;
4822 
4823         MethodResolutionPhase(boolean isBoxingRequired, boolean isVarargsRequired) {
4824            this.isBoxingRequired = isBoxingRequired;
4825            this.isVarargsRequired = isVarargsRequired;
4826         }
4827 
4828         public boolean isBoxingRequired() {
4829             return isBoxingRequired;
4830         }
4831 
4832         public boolean isVarargsRequired() {
4833             return isVarargsRequired;
4834         }
4835 
4836         public Symbol mergeResults(Symbol prev, Symbol sym) {
4837             return sym;
4838         }
4839     }
4840 
4841     final List&lt;MethodResolutionPhase&gt; methodResolutionSteps = List.of(BASIC, BOX, VARARITY);
4842 
4843     /**
4844      * A resolution context is used to keep track of intermediate results of
4845      * overload resolution, such as list of method that are not applicable
4846      * (used to generate more precise diagnostics) and so on. Resolution contexts
4847      * can be nested - this means that when each overload resolution routine should
4848      * work within the resolution context it created.
4849      */
4850     class MethodResolutionContext {
4851 
4852         private List&lt;Candidate&gt; candidates = List.nil();
4853 
4854         MethodResolutionPhase step = null;
4855 
4856         MethodCheck methodCheck = resolveMethodCheck;
4857 
4858         private boolean internalResolution = false;
4859         private DeferredAttr.AttrMode attrMode = DeferredAttr.AttrMode.SPECULATIVE;
4860 
4861         void addInapplicableCandidate(Symbol sym, JCDiagnostic details) {
4862             Candidate c = new Candidate(currentResolutionContext.step, sym, details, null);
4863             candidates = candidates.append(c);
4864         }
4865 
4866         void addApplicableCandidate(Symbol sym, Type mtype) {
4867             Candidate c = new Candidate(currentResolutionContext.step, sym, null, mtype);
4868             candidates = candidates.append(c);
4869         }
4870 
4871         DeferredAttrContext deferredAttrContext(Symbol sym, InferenceContext inferenceContext, ResultInfo pendingResult, Warner warn) {
4872             DeferredAttrContext parent = (pendingResult == null)
4873                 ? deferredAttr.emptyDeferredAttrContext
4874                 : pendingResult.checkContext.deferredAttrContext();
4875             return deferredAttr.new DeferredAttrContext(attrMode, sym, step,
4876                     inferenceContext, parent, warn);
4877         }
4878 
4879         /**
4880          * This class represents an overload resolution candidate. There are two
4881          * kinds of candidates: applicable methods and inapplicable methods;
4882          * applicable methods have a pointer to the instantiated method type,
4883          * while inapplicable candidates contain further details about the
4884          * reason why the method has been considered inapplicable.
4885          */
4886         @SuppressWarnings(&quot;overrides&quot;)
4887         class Candidate {
4888 
4889             final MethodResolutionPhase step;
4890             final Symbol sym;
4891             final JCDiagnostic details;
4892             final Type mtype;
4893 
4894             private Candidate(MethodResolutionPhase step, Symbol sym, JCDiagnostic details, Type mtype) {
4895                 this.step = step;
4896                 this.sym = sym;
4897                 this.details = details;
4898                 this.mtype = mtype;
4899             }
4900 
4901             boolean isApplicable() {
4902                 return mtype != null;
4903             }
4904         }
4905 
4906         DeferredAttr.AttrMode attrMode() {
4907             return attrMode;
4908         }
4909 
4910         boolean internal() {
4911             return internalResolution;
4912         }
4913     }
4914 
4915     MethodResolutionContext currentResolutionContext = null;
4916 }
    </pre>
  </body>
</html>
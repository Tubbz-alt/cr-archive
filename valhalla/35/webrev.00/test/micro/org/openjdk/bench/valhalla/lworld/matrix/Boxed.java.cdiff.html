<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/micro/org/openjdk/bench/valhalla/lworld/matrix/Boxed.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../invoke/ObjectHashCodeImplicit.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../traversal/Boxed.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/micro/org/openjdk/bench/valhalla/lworld/matrix/Boxed.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 9,33 ***</span>
  import java.util.concurrent.ThreadLocalRandom;
  
  
  public class Boxed extends MatrixBase {
  
<span class="line-modified">!     Complex?[][] A;</span>
<span class="line-modified">!     Complex?[][] B;</span>
  
      @Setup
      public void setup() {
<span class="line-modified">!         A = populate(new Complex?[size][size]);</span>
<span class="line-modified">!         B = populate(new Complex?[size][size]);</span>
      }
  
<span class="line-modified">!     private Complex?[][] populate(Complex?[][] m) {</span>
          int size = m.length;
          for (int i = 0; i &lt; size; i++) {
              for (int j = 0; j &lt; size; j++) {
                  m[i][j] = new Complex(ThreadLocalRandom.current().nextDouble(), ThreadLocalRandom.current().nextDouble());
              }
          }
          return m;
      }
  
      @Benchmark
<span class="line-modified">!     public Complex?[][] multiply() {</span>
          int size = A.length;
<span class="line-modified">!         Complex?[][] R = new Complex?[size][size];</span>
          for (int i = 0; i &lt; size; i++) {
              for (int j = 0; j &lt; size; j++) {
                  Complex s = Complex.H.ZERO;
                  for (int k = 0; k &lt; size; k++) {
                      s = s.add(A[i][k].mul((Complex)B[k][j]));
<span class="line-new-header">--- 9,33 ---</span>
  import java.util.concurrent.ThreadLocalRandom;
  
  
  public class Boxed extends MatrixBase {
  
<span class="line-modified">!     Complex.ref[][] A;</span>
<span class="line-modified">!     Complex.ref[][] B;</span>
  
      @Setup
      public void setup() {
<span class="line-modified">!         A = populate(new Complex.ref[size][size]);</span>
<span class="line-modified">!         B = populate(new Complex.ref[size][size]);</span>
      }
  
<span class="line-modified">!     private Complex.ref[][] populate(Complex.ref[][] m) {</span>
          int size = m.length;
          for (int i = 0; i &lt; size; i++) {
              for (int j = 0; j &lt; size; j++) {
                  m[i][j] = new Complex(ThreadLocalRandom.current().nextDouble(), ThreadLocalRandom.current().nextDouble());
              }
          }
          return m;
      }
  
      @Benchmark
<span class="line-modified">!     public Complex.ref[][] multiply() {</span>
          int size = A.length;
<span class="line-modified">!         Complex.ref[][] R = new Complex.ref[size][size];</span>
          for (int i = 0; i &lt; size; i++) {
              for (int j = 0; j &lt; size; j++) {
                  Complex s = Complex.H.ZERO;
                  for (int k = 0; k &lt; size; k++) {
                      s = s.add(A[i][k].mul((Complex)B[k][j]));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 45,39 ***</span>
          }
          return R;
      }
  
      @Benchmark
<span class="line-modified">!     public Complex?[][] multiplyCacheFriendly() {</span>
          int size = A.length;
<span class="line-modified">!         Complex?[][] R = new Complex?[size][size];</span>
          for (int i = 0; i &lt; size; i++) {
              Arrays.fill(R[i], Complex.H.ZERO);
          }
          for (int i = 0; i &lt; size; i++) {
              for (int k = 0; k &lt; size; k++) {
<span class="line-modified">!                 Complex? aik = A[i][k];</span>
                  for (int j = 0; j &lt; size; j++) {
                      R[i][j] = R[i][j].add(aik.mul((Complex)B[k][j]));
                  }
              }
          }
          return R;
      }
  
      @Benchmark
<span class="line-modified">!     public Complex?[][] multiplyCacheFriendly1() {</span>
          int size = A.length;
<span class="line-modified">!         Complex?[][] R = new Complex?[size][size];</span>
          for (int i = 0; i &lt; size; i++) {
              for (int j = 0; j &lt; size; j++) {
                  R[i][j] = Complex.H.ZERO;
              }
          }
          for (int i = 0; i &lt; size; i++) {
              for (int k = 0; k &lt; size; k++) {
<span class="line-modified">!                 Complex? aik = A[i][k];</span>
                  for (int j = 0; j &lt; size; j++) {
                      R[i][j] = R[i][j].add(aik.mul((Complex)B[k][j]));
                  }
              }
          }
<span class="line-new-header">--- 45,39 ---</span>
          }
          return R;
      }
  
      @Benchmark
<span class="line-modified">!     public Complex.ref[][] multiplyCacheFriendly() {</span>
          int size = A.length;
<span class="line-modified">!         Complex.ref[][] R = new Complex.ref[size][size];</span>
          for (int i = 0; i &lt; size; i++) {
              Arrays.fill(R[i], Complex.H.ZERO);
          }
          for (int i = 0; i &lt; size; i++) {
              for (int k = 0; k &lt; size; k++) {
<span class="line-modified">!                 Complex.ref aik = A[i][k];</span>
                  for (int j = 0; j &lt; size; j++) {
                      R[i][j] = R[i][j].add(aik.mul((Complex)B[k][j]));
                  }
              }
          }
          return R;
      }
  
      @Benchmark
<span class="line-modified">!     public Complex.ref[][] multiplyCacheFriendly1() {</span>
          int size = A.length;
<span class="line-modified">!         Complex.ref[][] R = new Complex.ref[size][size];</span>
          for (int i = 0; i &lt; size; i++) {
              for (int j = 0; j &lt; size; j++) {
                  R[i][j] = Complex.H.ZERO;
              }
          }
          for (int i = 0; i &lt; size; i++) {
              for (int k = 0; k &lt; size; k++) {
<span class="line-modified">!                 Complex.ref aik = A[i][k];</span>
                  for (int j = 0; j &lt; size; j++) {
                      R[i][j] = R[i][j].add(aik.mul((Complex)B[k][j]));
                  }
              }
          }
</pre>
<center><a href="../invoke/ObjectHashCodeImplicit.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../traversal/Boxed.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
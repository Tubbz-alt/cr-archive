<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/interpreterRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../classfile/systemDictionary.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interpreterRuntime.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/interpreterRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 335   // Getting old value
 336   frame&amp; f = last_frame.get_frame();
 337   jint tos_idx = f.interpreter_frame_expression_stack_size() - 1;
 338   int vt_offset = type2size[field_type];
 339   oop old_value = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx - vt_offset);
 340   assert(old_value != NULL &amp;&amp; oopDesc::is_oop(old_value) &amp;&amp; old_value-&gt;is_value(),&quot;Verifying receiver&quot;);
 341   Handle old_value_h(THREAD, old_value);
 342 
 343   // Creating new value by copying the one passed in argument
 344   instanceOop new_value = vklass-&gt;allocate_instance(
 345       CHECK_((type2size[field_type]) * AbstractInterpreter::stackElementSize));
 346   Handle new_value_h = Handle(THREAD, new_value);
 347   vklass-&gt;value_copy_oop_to_new_oop(old_value_h(), new_value_h());
 348 
 349   // Updating the field specified in arguments
 350   if (field_type == T_ARRAY || field_type == T_OBJECT) {
 351     oop aoop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
 352     assert(aoop == NULL || oopDesc::is_oop(aoop),&quot;argument must be a reference type&quot;);
 353     new_value_h()-&gt;obj_field_put(field_offset, aoop);
 354   } else if (field_type == T_VALUETYPE) {
<span class="line-modified"> 355     if (cp_entry-&gt;is_flattened()) {</span>
 356       oop vt_oop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
 357       assert(vt_oop != NULL &amp;&amp; oopDesc::is_oop(vt_oop) &amp;&amp; vt_oop-&gt;is_value(),&quot;argument must be a value type&quot;);
 358       ValueKlass* field_vk = ValueKlass::cast(vklass-&gt;get_value_field_klass(field_index));
 359       assert(vt_oop != NULL &amp;&amp; field_vk == vt_oop-&gt;klass(), &quot;Must match&quot;);
<span class="line-modified"> 360       field_vk-&gt;write_flattened_field(new_value_h(), offset, vt_oop, CHECK_(return_offset));</span>
<span class="line-modified"> 361     } else { // not flattened</span>
 362       oop voop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
<span class="line-modified"> 363       if (voop == NULL &amp;&amp; cp_entry-&gt;is_flattenable()) {</span>
 364         THROW_(vmSymbols::java_lang_NullPointerException(), return_offset);
 365       }
 366       assert(voop == NULL || oopDesc::is_oop(voop),&quot;checking argument&quot;);
 367       new_value_h()-&gt;obj_field_put(field_offset, voop);
 368     }
 369   } else { // not T_OBJECT nor T_ARRAY nor T_VALUETYPE
 370     intptr_t* addr = f.interpreter_frame_expression_stack_at(tos_idx);
 371     copy_primitive_argument(addr, new_value_h, field_offset, field_type);
 372   }
 373 
 374   // returning result
 375   thread-&gt;set_vm_result(new_value_h());
 376   return return_offset;
 377 JRT_END
 378 
 379 JRT_ENTRY(void, InterpreterRuntime::uninitialized_static_value_field(JavaThread* thread, oopDesc* mirror, int index))
<span class="line-modified"> 380   // The interpreter tries to access a flattenable static field that has not been initialized.</span>
 381   // This situation can happen in different scenarios:
 382   //   1 - if the load or initialization of the field failed during step 8 of
 383   //       the initialization of the holder of the field, in this case the access to the field
 384   //       must fail
 385   //   2 - it can also happen when the initialization of the holder class triggered the initialization of
 386   //       another class which accesses this field in its static initializer, in this case the
 387   //       access must succeed to allow circularity
 388   // The code below tries to load and initialize the field&#39;s class again before returning the default value.
 389   // If the field was not initialized because of an error, a exception should be thrown.
 390   // If the class is being initialized, the default value is returned.
 391   instanceHandle mirror_h(THREAD, (instanceOop)mirror);
 392   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
 393   if (klass-&gt;is_being_initialized() &amp;&amp; klass-&gt;is_reentrant_initialization(THREAD)) {
 394     int offset = klass-&gt;field_offset(index);
 395     Klass* field_k = klass-&gt;get_value_field_klass_or_null(index);
 396     if (field_k == NULL) {
 397       field_k = SystemDictionary::resolve_or_fail(klass-&gt;field_signature(index)-&gt;fundamental_name(THREAD),
 398           Handle(THREAD, klass-&gt;class_loader()),
 399           Handle(THREAD, klass-&gt;protection_domain()),
 400           true, CHECK);
</pre>
<hr />
<pre>
 408     // otherwise the JVM should not be executing this code.
 409     mirror-&gt;obj_field_put(offset, defaultvalue);
 410     thread-&gt;set_vm_result(defaultvalue);
 411   } else {
 412     assert(klass-&gt;is_in_error_state(), &quot;If not initializing, initialization must have failed to get there&quot;);
 413     ResourceMark rm(THREAD);
 414     const char* desc = &quot;Could not initialize class &quot;;
 415     const char* className = klass-&gt;external_name();
 416     size_t msglen = strlen(desc) + strlen(className) + 1;
 417     char* message = NEW_RESOURCE_ARRAY(char, msglen);
 418     if (NULL == message) {
 419       // Out of memory: can&#39;t create detailed error message
 420       THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), className);
 421     } else {
 422       jio_snprintf(message, msglen, &quot;%s%s&quot;, desc, className);
 423       THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), message);
 424     }
 425   }
 426 JRT_END
 427 
<span class="line-modified"> 428 JRT_ENTRY(void, InterpreterRuntime::read_flattened_field(JavaThread* thread, oopDesc* obj, int index, Klass* field_holder))</span>
 429   Handle obj_h(THREAD, obj);
 430 
 431   assert(oopDesc::is_oop(obj), &quot;Sanity check&quot;);
 432 
 433   assert(field_holder-&gt;is_instance_klass(), &quot;Sanity check&quot;);
 434   InstanceKlass* klass = InstanceKlass::cast(field_holder);
 435 
<span class="line-modified"> 436   assert(klass-&gt;field_is_flattened(index), &quot;Sanity check&quot;);</span>
 437 
 438   ValueKlass* field_vklass = ValueKlass::cast(klass-&gt;get_value_field_klass(index));
 439   assert(field_vklass-&gt;is_initialized(), &quot;Must be initialized at this point&quot;);
 440 
<span class="line-modified"> 441   oop res = field_vklass-&gt;read_flattened_field(obj_h(), klass-&gt;field_offset(index), CHECK);</span>
 442   thread-&gt;set_vm_result(res);
 443 JRT_END
 444 
 445 JRT_ENTRY(void, InterpreterRuntime::newarray(JavaThread* thread, BasicType type, jint size))
 446   oop obj = oopFactory::new_typeArray(type, size, CHECK);
 447   thread-&gt;set_vm_result(obj);
 448 JRT_END
 449 
 450 
 451 JRT_ENTRY(void, InterpreterRuntime::anewarray(JavaThread* thread, ConstantPool* pool, int index, jint size))
 452   Klass*    klass = pool-&gt;klass_at(index, CHECK);
 453   bool      is_qtype_desc = pool-&gt;tag_at(index).is_Qdescriptor_klass();
 454   arrayOop obj;
 455   if ((!klass-&gt;is_array_klass()) &amp;&amp; is_qtype_desc) { // Logically creates elements, ensure klass init
 456     klass-&gt;initialize(CHECK);
 457     obj = oopFactory::new_valueArray(klass, size, CHECK);
 458   } else {
 459     obj = oopFactory::new_objArray(klass, size, CHECK);
 460   }
 461   thread-&gt;set_vm_result(obj);
</pre>
<hr />
<pre>
 974       get_code = Bytecodes::_getstatic;
 975     } else {
 976       get_code = Bytecodes::_getfield;
 977     }
 978     if (is_put &amp;&amp; is_value) {
 979         put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_withfield);
 980     } else if ((is_put &amp;&amp; !has_initialized_final_update) || !info.access_flags().is_final()) {
 981         put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_putfield);
 982     }
 983   }
 984 
 985   cp_cache_entry-&gt;set_field(
 986     get_code,
 987     put_code,
 988     info.field_holder(),
 989     info.index(),
 990     info.offset(),
 991     state,
 992     info.access_flags().is_final(),
 993     info.access_flags().is_volatile(),
<span class="line-modified"> 994     info.is_flattened(),</span>
<span class="line-modified"> 995     info.is_flattenable(),</span>
 996     pool-&gt;pool_holder()
 997   );
 998 }
 999 
1000 
1001 //------------------------------------------------------------------------------------------------------------------------
1002 // Synchronization
1003 //
1004 // The interpreter&#39;s synchronization code is factored out so that it can
1005 // be shared by method invocation and synchronized blocks.
1006 //%note synchronization_3
1007 
1008 //%note monitor_1
1009 JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))
1010 #ifdef ASSERT
1011   thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);
1012 #endif
1013   if (PrintBiasedLockingStatistics) {
1014     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
1015   }
</pre>
<hr />
<pre>
1452 
1453   if (JvmtiExport::should_post_single_step()) {
1454     // We are called during regular safepoints and when the VM is
1455     // single stepping. If any thread is marked for single stepping,
1456     // then we may have JVMTI work to do.
1457     LastFrameAccessor last_frame(thread);
1458     JvmtiExport::at_single_stepping_point(thread, last_frame.method(), last_frame.bcp());
1459   }
1460 JRT_END
1461 
1462 JRT_ENTRY(void, InterpreterRuntime::post_field_access(JavaThread *thread, oopDesc* obj,
1463 ConstantPoolCacheEntry *cp_entry))
1464 
1465   // check the access_flags for the field in the klass
1466 
1467   InstanceKlass* ik = InstanceKlass::cast(cp_entry-&gt;f1_as_klass());
1468   int index = cp_entry-&gt;field_index();
1469   if ((ik-&gt;field_access_flags(index) &amp; JVM_ACC_FIELD_ACCESS_WATCHED) == 0) return;
1470 
1471   bool is_static = (obj == NULL);
<span class="line-modified">1472   bool is_flattened = cp_entry-&gt;is_flattened();</span>
1473   HandleMark hm(thread);
1474 
1475   Handle h_obj;
1476   if (!is_static) {
1477     // non-static field accessors have an object, but we need a handle
1478     h_obj = Handle(thread, obj);
1479   }
1480   InstanceKlass* cp_entry_f1 = InstanceKlass::cast(cp_entry-&gt;f1_as_klass());
<span class="line-modified">1481   jfieldID fid = jfieldIDWorkaround::to_jfieldID(cp_entry_f1, cp_entry-&gt;f2_as_index(), is_static, is_flattened);</span>
1482   LastFrameAccessor last_frame(thread);
1483   JvmtiExport::post_field_access(thread, last_frame.method(), last_frame.bcp(), cp_entry_f1, h_obj, fid);
1484 JRT_END
1485 
1486 JRT_ENTRY(void, InterpreterRuntime::post_field_modification(JavaThread *thread,
1487   oopDesc* obj, ConstantPoolCacheEntry *cp_entry, jvalue *value))
1488 
1489   Klass* k = cp_entry-&gt;f1_as_klass();
1490 
1491   // check the access_flags for the field in the klass
1492   InstanceKlass* ik = InstanceKlass::cast(k);
1493   int index = cp_entry-&gt;field_index();
1494   // bail out if field modifications are not watched
1495   if ((ik-&gt;field_access_flags(index) &amp; JVM_ACC_FIELD_MODIFICATION_WATCHED) == 0) return;
1496 
1497   char sig_type = &#39;\0&#39;;
1498 
1499   switch(cp_entry-&gt;flag_state()) {
1500     case btos: sig_type = JVM_SIGNATURE_BYTE;    break;
1501     case ztos: sig_type = JVM_SIGNATURE_BOOLEAN; break;
1502     case ctos: sig_type = JVM_SIGNATURE_CHAR;    break;
1503     case stos: sig_type = JVM_SIGNATURE_SHORT;   break;
1504     case itos: sig_type = JVM_SIGNATURE_INT;     break;
1505     case ftos: sig_type = JVM_SIGNATURE_FLOAT;   break;
1506     case atos: sig_type = JVM_SIGNATURE_CLASS;   break;
1507     case ltos: sig_type = JVM_SIGNATURE_LONG;    break;
1508     case dtos: sig_type = JVM_SIGNATURE_DOUBLE;  break;
1509     default:  ShouldNotReachHere(); return;
1510   }
1511 
1512   // Both Q-signatures and L-signatures are mapped to atos
1513   if (cp_entry-&gt;flag_state() == atos &amp;&amp; ik-&gt;field_signature(index)-&gt;is_Q_signature()) {
1514     sig_type = JVM_SIGNATURE_VALUETYPE;
1515   }
1516 
1517   bool is_static = (obj == NULL);
<span class="line-modified">1518   bool is_flattened = cp_entry-&gt;is_flattened();</span>
1519 
1520   HandleMark hm(thread);
<span class="line-modified">1521   jfieldID fid = jfieldIDWorkaround::to_jfieldID(ik, cp_entry-&gt;f2_as_index(), is_static, is_flattened);</span>
1522   jvalue fvalue;
1523 #ifdef _LP64
1524   fvalue = *value;
1525 #else
1526   // Long/double values are stored unaligned and also noncontiguously with
1527   // tagged stacks.  We can&#39;t just do a simple assignment even in the non-
1528   // J/D cases because a C++ compiler is allowed to assume that a jvalue is
1529   // 8-byte aligned, and interpreter stack slots are only 4-byte aligned.
1530   // We assume that the two halves of longs/doubles are stored in interpreter
1531   // stack slots in platform-endian order.
1532   jlong_accessor u;
1533   jint* newval = (jint*)value;
1534   u.words[0] = newval[0];
1535   u.words[1] = newval[Interpreter::stackElementWords]; // skip if tag
1536   fvalue.j = u.long_value;
1537 #endif // _LP64
1538 
1539   Handle h_obj;
1540   if (!is_static) {
1541     // non-static field accessors have an object, but we need a handle
</pre>
</td>
<td>
<hr />
<pre>
 335   // Getting old value
 336   frame&amp; f = last_frame.get_frame();
 337   jint tos_idx = f.interpreter_frame_expression_stack_size() - 1;
 338   int vt_offset = type2size[field_type];
 339   oop old_value = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx - vt_offset);
 340   assert(old_value != NULL &amp;&amp; oopDesc::is_oop(old_value) &amp;&amp; old_value-&gt;is_value(),&quot;Verifying receiver&quot;);
 341   Handle old_value_h(THREAD, old_value);
 342 
 343   // Creating new value by copying the one passed in argument
 344   instanceOop new_value = vklass-&gt;allocate_instance(
 345       CHECK_((type2size[field_type]) * AbstractInterpreter::stackElementSize));
 346   Handle new_value_h = Handle(THREAD, new_value);
 347   vklass-&gt;value_copy_oop_to_new_oop(old_value_h(), new_value_h());
 348 
 349   // Updating the field specified in arguments
 350   if (field_type == T_ARRAY || field_type == T_OBJECT) {
 351     oop aoop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
 352     assert(aoop == NULL || oopDesc::is_oop(aoop),&quot;argument must be a reference type&quot;);
 353     new_value_h()-&gt;obj_field_put(field_offset, aoop);
 354   } else if (field_type == T_VALUETYPE) {
<span class="line-modified"> 355     if (cp_entry-&gt;is_allocated_inline()) {</span>
 356       oop vt_oop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
 357       assert(vt_oop != NULL &amp;&amp; oopDesc::is_oop(vt_oop) &amp;&amp; vt_oop-&gt;is_value(),&quot;argument must be a value type&quot;);
 358       ValueKlass* field_vk = ValueKlass::cast(vklass-&gt;get_value_field_klass(field_index));
 359       assert(vt_oop != NULL &amp;&amp; field_vk == vt_oop-&gt;klass(), &quot;Must match&quot;);
<span class="line-modified"> 360       field_vk-&gt;write_field_allocated_inline(new_value_h(), offset, vt_oop, CHECK_(return_offset));</span>
<span class="line-modified"> 361     } else { // not allocated inline</span>
 362       oop voop = *(oop*)f.interpreter_frame_expression_stack_at(tos_idx);
<span class="line-modified"> 363       if (voop == NULL &amp;&amp; cp_entry-&gt;is_inline_type()) {</span>
 364         THROW_(vmSymbols::java_lang_NullPointerException(), return_offset);
 365       }
 366       assert(voop == NULL || oopDesc::is_oop(voop),&quot;checking argument&quot;);
 367       new_value_h()-&gt;obj_field_put(field_offset, voop);
 368     }
 369   } else { // not T_OBJECT nor T_ARRAY nor T_VALUETYPE
 370     intptr_t* addr = f.interpreter_frame_expression_stack_at(tos_idx);
 371     copy_primitive_argument(addr, new_value_h, field_offset, field_type);
 372   }
 373 
 374   // returning result
 375   thread-&gt;set_vm_result(new_value_h());
 376   return return_offset;
 377 JRT_END
 378 
 379 JRT_ENTRY(void, InterpreterRuntime::uninitialized_static_value_field(JavaThread* thread, oopDesc* mirror, int index))
<span class="line-modified"> 380   // The interpreter tries to access an inline static field that has not been initialized.</span>
 381   // This situation can happen in different scenarios:
 382   //   1 - if the load or initialization of the field failed during step 8 of
 383   //       the initialization of the holder of the field, in this case the access to the field
 384   //       must fail
 385   //   2 - it can also happen when the initialization of the holder class triggered the initialization of
 386   //       another class which accesses this field in its static initializer, in this case the
 387   //       access must succeed to allow circularity
 388   // The code below tries to load and initialize the field&#39;s class again before returning the default value.
 389   // If the field was not initialized because of an error, a exception should be thrown.
 390   // If the class is being initialized, the default value is returned.
 391   instanceHandle mirror_h(THREAD, (instanceOop)mirror);
 392   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
 393   if (klass-&gt;is_being_initialized() &amp;&amp; klass-&gt;is_reentrant_initialization(THREAD)) {
 394     int offset = klass-&gt;field_offset(index);
 395     Klass* field_k = klass-&gt;get_value_field_klass_or_null(index);
 396     if (field_k == NULL) {
 397       field_k = SystemDictionary::resolve_or_fail(klass-&gt;field_signature(index)-&gt;fundamental_name(THREAD),
 398           Handle(THREAD, klass-&gt;class_loader()),
 399           Handle(THREAD, klass-&gt;protection_domain()),
 400           true, CHECK);
</pre>
<hr />
<pre>
 408     // otherwise the JVM should not be executing this code.
 409     mirror-&gt;obj_field_put(offset, defaultvalue);
 410     thread-&gt;set_vm_result(defaultvalue);
 411   } else {
 412     assert(klass-&gt;is_in_error_state(), &quot;If not initializing, initialization must have failed to get there&quot;);
 413     ResourceMark rm(THREAD);
 414     const char* desc = &quot;Could not initialize class &quot;;
 415     const char* className = klass-&gt;external_name();
 416     size_t msglen = strlen(desc) + strlen(className) + 1;
 417     char* message = NEW_RESOURCE_ARRAY(char, msglen);
 418     if (NULL == message) {
 419       // Out of memory: can&#39;t create detailed error message
 420       THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), className);
 421     } else {
 422       jio_snprintf(message, msglen, &quot;%s%s&quot;, desc, className);
 423       THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), message);
 424     }
 425   }
 426 JRT_END
 427 
<span class="line-modified"> 428 JRT_ENTRY(void, InterpreterRuntime::read_field_allocated_inline(JavaThread* thread, oopDesc* obj, int index, Klass* field_holder))</span>
 429   Handle obj_h(THREAD, obj);
 430 
 431   assert(oopDesc::is_oop(obj), &quot;Sanity check&quot;);
 432 
 433   assert(field_holder-&gt;is_instance_klass(), &quot;Sanity check&quot;);
 434   InstanceKlass* klass = InstanceKlass::cast(field_holder);
 435 
<span class="line-modified"> 436   assert(klass-&gt;field_is_allocated_inline(index), &quot;Sanity check&quot;);</span>
 437 
 438   ValueKlass* field_vklass = ValueKlass::cast(klass-&gt;get_value_field_klass(index));
 439   assert(field_vklass-&gt;is_initialized(), &quot;Must be initialized at this point&quot;);
 440 
<span class="line-modified"> 441   oop res = field_vklass-&gt;read_field_allocated_inline(obj_h(), klass-&gt;field_offset(index), CHECK);</span>
 442   thread-&gt;set_vm_result(res);
 443 JRT_END
 444 
 445 JRT_ENTRY(void, InterpreterRuntime::newarray(JavaThread* thread, BasicType type, jint size))
 446   oop obj = oopFactory::new_typeArray(type, size, CHECK);
 447   thread-&gt;set_vm_result(obj);
 448 JRT_END
 449 
 450 
 451 JRT_ENTRY(void, InterpreterRuntime::anewarray(JavaThread* thread, ConstantPool* pool, int index, jint size))
 452   Klass*    klass = pool-&gt;klass_at(index, CHECK);
 453   bool      is_qtype_desc = pool-&gt;tag_at(index).is_Qdescriptor_klass();
 454   arrayOop obj;
 455   if ((!klass-&gt;is_array_klass()) &amp;&amp; is_qtype_desc) { // Logically creates elements, ensure klass init
 456     klass-&gt;initialize(CHECK);
 457     obj = oopFactory::new_valueArray(klass, size, CHECK);
 458   } else {
 459     obj = oopFactory::new_objArray(klass, size, CHECK);
 460   }
 461   thread-&gt;set_vm_result(obj);
</pre>
<hr />
<pre>
 974       get_code = Bytecodes::_getstatic;
 975     } else {
 976       get_code = Bytecodes::_getfield;
 977     }
 978     if (is_put &amp;&amp; is_value) {
 979         put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_withfield);
 980     } else if ((is_put &amp;&amp; !has_initialized_final_update) || !info.access_flags().is_final()) {
 981         put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_putfield);
 982     }
 983   }
 984 
 985   cp_cache_entry-&gt;set_field(
 986     get_code,
 987     put_code,
 988     info.field_holder(),
 989     info.index(),
 990     info.offset(),
 991     state,
 992     info.access_flags().is_final(),
 993     info.access_flags().is_volatile(),
<span class="line-modified"> 994     info.is_allocated_inline(),</span>
<span class="line-modified"> 995     info.is_inline_type(),</span>
 996     pool-&gt;pool_holder()
 997   );
 998 }
 999 
1000 
1001 //------------------------------------------------------------------------------------------------------------------------
1002 // Synchronization
1003 //
1004 // The interpreter&#39;s synchronization code is factored out so that it can
1005 // be shared by method invocation and synchronized blocks.
1006 //%note synchronization_3
1007 
1008 //%note monitor_1
1009 JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))
1010 #ifdef ASSERT
1011   thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);
1012 #endif
1013   if (PrintBiasedLockingStatistics) {
1014     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
1015   }
</pre>
<hr />
<pre>
1452 
1453   if (JvmtiExport::should_post_single_step()) {
1454     // We are called during regular safepoints and when the VM is
1455     // single stepping. If any thread is marked for single stepping,
1456     // then we may have JVMTI work to do.
1457     LastFrameAccessor last_frame(thread);
1458     JvmtiExport::at_single_stepping_point(thread, last_frame.method(), last_frame.bcp());
1459   }
1460 JRT_END
1461 
1462 JRT_ENTRY(void, InterpreterRuntime::post_field_access(JavaThread *thread, oopDesc* obj,
1463 ConstantPoolCacheEntry *cp_entry))
1464 
1465   // check the access_flags for the field in the klass
1466 
1467   InstanceKlass* ik = InstanceKlass::cast(cp_entry-&gt;f1_as_klass());
1468   int index = cp_entry-&gt;field_index();
1469   if ((ik-&gt;field_access_flags(index) &amp; JVM_ACC_FIELD_ACCESS_WATCHED) == 0) return;
1470 
1471   bool is_static = (obj == NULL);
<span class="line-modified">1472   bool is_allocated_inline = cp_entry-&gt;is_allocated_inline();</span>
1473   HandleMark hm(thread);
1474 
1475   Handle h_obj;
1476   if (!is_static) {
1477     // non-static field accessors have an object, but we need a handle
1478     h_obj = Handle(thread, obj);
1479   }
1480   InstanceKlass* cp_entry_f1 = InstanceKlass::cast(cp_entry-&gt;f1_as_klass());
<span class="line-modified">1481   jfieldID fid = jfieldIDWorkaround::to_jfieldID(cp_entry_f1, cp_entry-&gt;f2_as_index(), is_static, is_allocated_inline);</span>
1482   LastFrameAccessor last_frame(thread);
1483   JvmtiExport::post_field_access(thread, last_frame.method(), last_frame.bcp(), cp_entry_f1, h_obj, fid);
1484 JRT_END
1485 
1486 JRT_ENTRY(void, InterpreterRuntime::post_field_modification(JavaThread *thread,
1487   oopDesc* obj, ConstantPoolCacheEntry *cp_entry, jvalue *value))
1488 
1489   Klass* k = cp_entry-&gt;f1_as_klass();
1490 
1491   // check the access_flags for the field in the klass
1492   InstanceKlass* ik = InstanceKlass::cast(k);
1493   int index = cp_entry-&gt;field_index();
1494   // bail out if field modifications are not watched
1495   if ((ik-&gt;field_access_flags(index) &amp; JVM_ACC_FIELD_MODIFICATION_WATCHED) == 0) return;
1496 
1497   char sig_type = &#39;\0&#39;;
1498 
1499   switch(cp_entry-&gt;flag_state()) {
1500     case btos: sig_type = JVM_SIGNATURE_BYTE;    break;
1501     case ztos: sig_type = JVM_SIGNATURE_BOOLEAN; break;
1502     case ctos: sig_type = JVM_SIGNATURE_CHAR;    break;
1503     case stos: sig_type = JVM_SIGNATURE_SHORT;   break;
1504     case itos: sig_type = JVM_SIGNATURE_INT;     break;
1505     case ftos: sig_type = JVM_SIGNATURE_FLOAT;   break;
1506     case atos: sig_type = JVM_SIGNATURE_CLASS;   break;
1507     case ltos: sig_type = JVM_SIGNATURE_LONG;    break;
1508     case dtos: sig_type = JVM_SIGNATURE_DOUBLE;  break;
1509     default:  ShouldNotReachHere(); return;
1510   }
1511 
1512   // Both Q-signatures and L-signatures are mapped to atos
1513   if (cp_entry-&gt;flag_state() == atos &amp;&amp; ik-&gt;field_signature(index)-&gt;is_Q_signature()) {
1514     sig_type = JVM_SIGNATURE_VALUETYPE;
1515   }
1516 
1517   bool is_static = (obj == NULL);
<span class="line-modified">1518   bool is_allocated_inline = cp_entry-&gt;is_allocated_inline();</span>
1519 
1520   HandleMark hm(thread);
<span class="line-modified">1521   jfieldID fid = jfieldIDWorkaround::to_jfieldID(ik, cp_entry-&gt;f2_as_index(), is_static, is_allocated_inline);</span>
1522   jvalue fvalue;
1523 #ifdef _LP64
1524   fvalue = *value;
1525 #else
1526   // Long/double values are stored unaligned and also noncontiguously with
1527   // tagged stacks.  We can&#39;t just do a simple assignment even in the non-
1528   // J/D cases because a C++ compiler is allowed to assume that a jvalue is
1529   // 8-byte aligned, and interpreter stack slots are only 4-byte aligned.
1530   // We assume that the two halves of longs/doubles are stored in interpreter
1531   // stack slots in platform-endian order.
1532   jlong_accessor u;
1533   jint* newval = (jint*)value;
1534   u.words[0] = newval[0];
1535   u.words[1] = newval[Interpreter::stackElementWords]; // skip if tag
1536   fvalue.j = u.long_value;
1537 #endif // _LP64
1538 
1539   Handle h_obj;
1540   if (!is_static) {
1541     // non-static field accessors have an object, but we need a handle
</pre>
</td>
</tr>
</table>
<center><a href="../classfile/systemDictionary.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interpreterRuntime.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
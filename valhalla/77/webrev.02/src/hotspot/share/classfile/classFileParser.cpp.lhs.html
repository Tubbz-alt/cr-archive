<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/defaultMethods.hpp&quot;
  33 #include &quot;classfile/dictionary.hpp&quot;
  34 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/moduleEntry.hpp&quot;
  37 #include &quot;classfile/packageEntry.hpp&quot;
  38 #include &quot;classfile/symbolTable.hpp&quot;
  39 #include &quot;classfile/systemDictionary.hpp&quot;
  40 #include &quot;classfile/verificationType.hpp&quot;
  41 #include &quot;classfile/verifier.hpp&quot;
  42 #include &quot;classfile/vmSymbols.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;logging/logStream.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/metadataFactory.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/annotations.hpp&quot;
  51 #include &quot;oops/constantPool.inline.hpp&quot;
  52 #include &quot;oops/fieldStreams.inline.hpp&quot;
  53 #include &quot;oops/instanceKlass.hpp&quot;
  54 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  55 #include &quot;oops/klass.inline.hpp&quot;
  56 #include &quot;oops/klassVtable.hpp&quot;
  57 #include &quot;oops/metadata.hpp&quot;
  58 #include &quot;oops/method.inline.hpp&quot;
  59 #include &quot;oops/oop.inline.hpp&quot;
  60 #include &quot;oops/recordComponent.hpp&quot;
  61 #include &quot;oops/symbol.hpp&quot;
  62 #include &quot;oops/valueKlass.inline.hpp&quot;
  63 #include &quot;prims/jvmtiExport.hpp&quot;
  64 #include &quot;prims/jvmtiThreadState.hpp&quot;
  65 #include &quot;runtime/arguments.hpp&quot;
  66 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  67 #include &quot;runtime/handles.inline.hpp&quot;
  68 #include &quot;runtime/javaCalls.hpp&quot;
  69 #include &quot;runtime/os.hpp&quot;
  70 #include &quot;runtime/perfData.hpp&quot;
  71 #include &quot;runtime/reflection.hpp&quot;
  72 #include &quot;runtime/safepointVerifiers.hpp&quot;
  73 #include &quot;runtime/signature.hpp&quot;
  74 #include &quot;runtime/timer.hpp&quot;
  75 #include &quot;services/classLoadingService.hpp&quot;
  76 #include &quot;services/threadService.hpp&quot;
  77 #include &quot;utilities/align.hpp&quot;
  78 #include &quot;utilities/bitMap.inline.hpp&quot;
  79 #include &quot;utilities/copy.hpp&quot;
  80 #include &quot;utilities/exceptions.hpp&quot;
  81 #include &quot;utilities/globalDefinitions.hpp&quot;
  82 #include &quot;utilities/growableArray.hpp&quot;
  83 #include &quot;utilities/macros.hpp&quot;
  84 #include &quot;utilities/ostream.hpp&quot;
  85 #include &quot;utilities/resourceHash.hpp&quot;
  86 #include &quot;utilities/stringUtils.hpp&quot;
  87 #include &quot;utilities/utf8.hpp&quot;
  88 
  89 #if INCLUDE_CDS
  90 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  91 #endif
  92 #if INCLUDE_JFR
  93 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  94 #endif
  95 
  96 // We generally try to create the oops directly when parsing, rather than
  97 // allocating temporary data structures and copying the bytes twice. A
  98 // temporary area is only needed when parsing utf8 entries in the constant
  99 // pool and when parsing line number tables.
 100 
 101 // We add assert in debug mode when class format is not checked.
 102 
 103 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 104 #define JAVA_MIN_SUPPORTED_VERSION        45
 105 #define JAVA_PREVIEW_MINOR_VERSION        65535
 106 
 107 // Used for two backward compatibility reasons:
 108 // - to check for new additions to the class file format in JDK1.5
 109 // - to check for bug fixes in the format checker in JDK1.5
 110 #define JAVA_1_5_VERSION                  49
 111 
 112 // Used for backward compatibility reasons:
 113 // - to check for javac bug fixes that happened after 1.5
 114 // - also used as the max version when running in jdk6
 115 #define JAVA_6_VERSION                    50
 116 
 117 // Used for backward compatibility reasons:
 118 // - to disallow argument and require ACC_STATIC for &lt;clinit&gt; methods
 119 #define JAVA_7_VERSION                    51
 120 
 121 // Extension method support.
 122 #define JAVA_8_VERSION                    52
 123 
 124 #define JAVA_9_VERSION                    53
 125 
 126 #define JAVA_10_VERSION                   54
 127 
 128 #define JAVA_11_VERSION                   55
 129 
 130 #define JAVA_12_VERSION                   56
 131 
 132 #define JAVA_13_VERSION                   57
 133 
 134 #define JAVA_14_VERSION                   58
 135 
 136 #define JAVA_15_VERSION                   59
 137 
 138 #define CONSTANT_CLASS_DESCRIPTORS        59
 139 
 140 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
 141   assert((bad_constant == JVM_CONSTANT_Module ||
 142           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
 143          &quot;Unexpected bad constant pool entry&quot;);
 144   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 145 }
 146 
 147 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 148                                                   ConstantPool* cp,
 149                                                   const int length,
 150                                                   TRAPS) {
 151   assert(stream != NULL, &quot;invariant&quot;);
 152   assert(cp != NULL, &quot;invariant&quot;);
 153 
 154   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 155   // this function (_current can be allocated in a register, with scalar
 156   // replacement of aggregates). The _current pointer is copied back to
 157   // stream() when this function returns. DON&#39;T call another method within
 158   // this method that uses stream().
 159   const ClassFileStream cfs1 = *stream;
 160   const ClassFileStream* const cfs = &amp;cfs1;
 161 
 162   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
 163   debug_only(const u1* const old_current = stream-&gt;current();)
 164 
 165   // Used for batching symbol allocations.
 166   const char* names[SymbolTable::symbol_alloc_batch_size];
 167   int lengths[SymbolTable::symbol_alloc_batch_size];
 168   int indices[SymbolTable::symbol_alloc_batch_size];
 169   unsigned int hashValues[SymbolTable::symbol_alloc_batch_size];
 170   int names_count = 0;
 171 
 172   // parsing  Index 0 is unused
 173   for (int index = 1; index &lt; length; index++) {
 174     // Each of the following case guarantees one more byte in the stream
 175     // for the following tag or the access_flags following constant pool,
 176     // so we don&#39;t need bounds-check for reading tag.
 177     const u1 tag = cfs-&gt;get_u1_fast();
 178     switch (tag) {
 179       case JVM_CONSTANT_Class: {
 180         cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
 181         const u2 name_index = cfs-&gt;get_u2_fast();
 182         cp-&gt;klass_index_at_put(index, name_index);
 183         break;
 184       }
 185       case JVM_CONSTANT_Fieldref: {
 186         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 187         const u2 class_index = cfs-&gt;get_u2_fast();
 188         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 189         cp-&gt;field_at_put(index, class_index, name_and_type_index);
 190         break;
 191       }
 192       case JVM_CONSTANT_Methodref: {
 193         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 194         const u2 class_index = cfs-&gt;get_u2_fast();
 195         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 196         cp-&gt;method_at_put(index, class_index, name_and_type_index);
 197         break;
 198       }
 199       case JVM_CONSTANT_InterfaceMethodref: {
 200         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 201         const u2 class_index = cfs-&gt;get_u2_fast();
 202         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 203         cp-&gt;interface_method_at_put(index, class_index, name_and_type_index);
 204         break;
 205       }
 206       case JVM_CONSTANT_String : {
 207         cfs-&gt;guarantee_more(3, CHECK);  // string_index, tag/access_flags
 208         const u2 string_index = cfs-&gt;get_u2_fast();
 209         cp-&gt;string_index_at_put(index, string_index);
 210         break;
 211       }
 212       case JVM_CONSTANT_MethodHandle :
 213       case JVM_CONSTANT_MethodType: {
 214         if (_major_version &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
 215           classfile_parse_error(
 216             &quot;Class file version does not support constant tag %u in class file %s&quot;,
 217             tag, CHECK);
 218         }
 219         if (tag == JVM_CONSTANT_MethodHandle) {
 220           cfs-&gt;guarantee_more(4, CHECK);  // ref_kind, method_index, tag/access_flags
 221           const u1 ref_kind = cfs-&gt;get_u1_fast();
 222           const u2 method_index = cfs-&gt;get_u2_fast();
 223           cp-&gt;method_handle_index_at_put(index, ref_kind, method_index);
 224         }
 225         else if (tag == JVM_CONSTANT_MethodType) {
 226           cfs-&gt;guarantee_more(3, CHECK);  // signature_index, tag/access_flags
 227           const u2 signature_index = cfs-&gt;get_u2_fast();
 228           cp-&gt;method_type_index_at_put(index, signature_index);
 229         }
 230         else {
 231           ShouldNotReachHere();
 232         }
 233         break;
 234       }
 235       case JVM_CONSTANT_Dynamic : {
 236         if (_major_version &lt; Verifier::DYNAMICCONSTANT_MAJOR_VERSION) {
 237           classfile_parse_error(
 238               &quot;Class file version does not support constant tag %u in class file %s&quot;,
 239               tag, CHECK);
 240         }
 241         cfs-&gt;guarantee_more(5, CHECK);  // bsm_index, nt, tag/access_flags
 242         const u2 bootstrap_specifier_index = cfs-&gt;get_u2_fast();
 243         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 244         if (_max_bootstrap_specifier_index &lt; (int) bootstrap_specifier_index) {
 245           _max_bootstrap_specifier_index = (int) bootstrap_specifier_index;  // collect for later
 246         }
 247         cp-&gt;dynamic_constant_at_put(index, bootstrap_specifier_index, name_and_type_index);
 248         break;
 249       }
 250       case JVM_CONSTANT_InvokeDynamic : {
 251         if (_major_version &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
 252           classfile_parse_error(
 253               &quot;Class file version does not support constant tag %u in class file %s&quot;,
 254               tag, CHECK);
 255         }
 256         cfs-&gt;guarantee_more(5, CHECK);  // bsm_index, nt, tag/access_flags
 257         const u2 bootstrap_specifier_index = cfs-&gt;get_u2_fast();
 258         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 259         if (_max_bootstrap_specifier_index &lt; (int) bootstrap_specifier_index) {
 260           _max_bootstrap_specifier_index = (int) bootstrap_specifier_index;  // collect for later
 261         }
 262         cp-&gt;invoke_dynamic_at_put(index, bootstrap_specifier_index, name_and_type_index);
 263         break;
 264       }
 265       case JVM_CONSTANT_Integer: {
 266         cfs-&gt;guarantee_more(5, CHECK);  // bytes, tag/access_flags
 267         const u4 bytes = cfs-&gt;get_u4_fast();
 268         cp-&gt;int_at_put(index, (jint)bytes);
 269         break;
 270       }
 271       case JVM_CONSTANT_Float: {
 272         cfs-&gt;guarantee_more(5, CHECK);  // bytes, tag/access_flags
 273         const u4 bytes = cfs-&gt;get_u4_fast();
 274         cp-&gt;float_at_put(index, *(jfloat*)&amp;bytes);
 275         break;
 276       }
 277       case JVM_CONSTANT_Long: {
 278         // A mangled type might cause you to overrun allocated memory
 279         guarantee_property(index + 1 &lt; length,
 280                            &quot;Invalid constant pool entry %u in class file %s&quot;,
 281                            index,
 282                            CHECK);
 283         cfs-&gt;guarantee_more(9, CHECK);  // bytes, tag/access_flags
 284         const u8 bytes = cfs-&gt;get_u8_fast();
 285         cp-&gt;long_at_put(index, bytes);
 286         index++;   // Skip entry following eigth-byte constant, see JVM book p. 98
 287         break;
 288       }
 289       case JVM_CONSTANT_Double: {
 290         // A mangled type might cause you to overrun allocated memory
 291         guarantee_property(index+1 &lt; length,
 292                            &quot;Invalid constant pool entry %u in class file %s&quot;,
 293                            index,
 294                            CHECK);
 295         cfs-&gt;guarantee_more(9, CHECK);  // bytes, tag/access_flags
 296         const u8 bytes = cfs-&gt;get_u8_fast();
 297         cp-&gt;double_at_put(index, *(jdouble*)&amp;bytes);
 298         index++;   // Skip entry following eigth-byte constant, see JVM book p. 98
 299         break;
 300       }
 301       case JVM_CONSTANT_NameAndType: {
 302         cfs-&gt;guarantee_more(5, CHECK);  // name_index, signature_index, tag/access_flags
 303         const u2 name_index = cfs-&gt;get_u2_fast();
 304         const u2 signature_index = cfs-&gt;get_u2_fast();
 305         cp-&gt;name_and_type_at_put(index, name_index, signature_index);
 306         break;
 307       }
 308       case JVM_CONSTANT_Utf8 : {
 309         cfs-&gt;guarantee_more(2, CHECK);  // utf8_length
 310         u2  utf8_length = cfs-&gt;get_u2_fast();
 311         const u1* utf8_buffer = cfs-&gt;current();
 312         assert(utf8_buffer != NULL, &quot;null utf8 buffer&quot;);
 313         // Got utf8 string, guarantee utf8_length+1 bytes, set stream position forward.
 314         cfs-&gt;guarantee_more(utf8_length+1, CHECK);  // utf8 string, tag/access_flags
 315         cfs-&gt;skip_u1_fast(utf8_length);
 316 
 317         // Before storing the symbol, make sure it&#39;s legal
 318         if (_need_verify) {
 319           verify_legal_utf8(utf8_buffer, utf8_length, CHECK);
 320         }
 321 
 322         if (has_cp_patch_at(index)) {
 323           Handle patch = clear_cp_patch_at(index);
 324           guarantee_property(java_lang_String::is_instance(patch()),
 325                              &quot;Illegal utf8 patch at %d in class file %s&quot;,
 326                              index,
 327                              CHECK);
 328           const char* const str = java_lang_String::as_utf8_string(patch());
 329           // (could use java_lang_String::as_symbol instead, but might as well batch them)
 330           utf8_buffer = (const u1*) str;
 331           utf8_length = (u2) strlen(str);
 332         }
 333 
 334         unsigned int hash;
 335         Symbol* const result = SymbolTable::lookup_only((const char*)utf8_buffer,
 336                                                         utf8_length,
 337                                                         hash);
 338         if (result == NULL) {
 339           names[names_count] = (const char*)utf8_buffer;
 340           lengths[names_count] = utf8_length;
 341           indices[names_count] = index;
 342           hashValues[names_count++] = hash;
 343           if (names_count == SymbolTable::symbol_alloc_batch_size) {
 344             SymbolTable::new_symbols(_loader_data,
 345                                      constantPoolHandle(THREAD, cp),
 346                                      names_count,
 347                                      names,
 348                                      lengths,
 349                                      indices,
 350                                      hashValues);
 351             names_count = 0;
 352           }
 353         } else {
 354           cp-&gt;symbol_at_put(index, result);
 355         }
 356         break;
 357       }
 358       case JVM_CONSTANT_Module:
 359       case JVM_CONSTANT_Package: {
 360         // Record that an error occurred in these two cases but keep parsing so
 361         // that ACC_Module can be checked for in the access_flags.  Need to
 362         // throw NoClassDefFoundError in that case.
 363         if (_major_version &gt;= JAVA_9_VERSION) {
 364           cfs-&gt;guarantee_more(3, CHECK);
 365           cfs-&gt;get_u2_fast();
 366           set_class_bad_constant_seen(tag);
 367           break;
 368         }
 369       }
 370       default: {
 371         classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;,
 372                               tag,
 373                               CHECK);
 374         break;
 375       }
 376     } // end of switch(tag)
 377   } // end of for
 378 
 379   // Allocate the remaining symbols
 380   if (names_count &gt; 0) {
 381     SymbolTable::new_symbols(_loader_data,
 382                              constantPoolHandle(THREAD, cp),
 383                              names_count,
 384                              names,
 385                              lengths,
 386                              indices,
 387                              hashValues);
 388   }
 389 
 390   // Copy _current pointer of local copy back to stream.
 391   assert(stream-&gt;current() == old_current, &quot;non-exclusive use of stream&quot;);
 392   stream-&gt;set_current(cfs1.current());
 393 
 394 }
 395 
 396 static inline bool valid_cp_range(int index, int length) {
 397   return (index &gt; 0 &amp;&amp; index &lt; length);
 398 }
 399 
 400 static inline Symbol* check_symbol_at(const ConstantPool* cp, int index) {
 401   assert(cp != NULL, &quot;invariant&quot;);
 402   if (valid_cp_range(index, cp-&gt;length()) &amp;&amp; cp-&gt;tag_at(index).is_utf8()) {
 403     return cp-&gt;symbol_at(index);
 404   }
 405   return NULL;
 406 }
 407 
 408 #ifdef ASSERT
 409 PRAGMA_DIAG_PUSH
 410 PRAGMA_FORMAT_NONLITERAL_IGNORED
 411 void ClassFileParser::report_assert_property_failure(const char* msg, TRAPS) const {
 412   ResourceMark rm(THREAD);
 413   fatal(msg, _class_name-&gt;as_C_string());
 414 }
 415 
 416 void ClassFileParser::report_assert_property_failure(const char* msg,
 417                                                      int index,
 418                                                      TRAPS) const {
 419   ResourceMark rm(THREAD);
 420   fatal(msg, index, _class_name-&gt;as_C_string());
 421 }
 422 PRAGMA_DIAG_POP
 423 #endif
 424 
 425 void ClassFileParser::parse_constant_pool(const ClassFileStream* const stream,
 426                                          ConstantPool* const cp,
 427                                          const int length,
 428                                          TRAPS) {
 429   assert(cp != NULL, &quot;invariant&quot;);
 430   assert(stream != NULL, &quot;invariant&quot;);
 431 
 432   // parsing constant pool entries
 433   parse_constant_pool_entries(stream, cp, length, CHECK);
 434   if (class_bad_constant_seen() != 0) {
 435     // a bad CP entry has been detected previously so stop parsing and just return.
 436     return;
 437   }
 438 
 439   int index = 1;  // declared outside of loops for portability
 440   int num_klasses = 0;
 441 
 442   // first verification pass - validate cross references
 443   // and fixup class and string constants
 444   for (index = 1; index &lt; length; index++) {          // Index 0 is unused
 445     const jbyte tag = cp-&gt;tag_at(index).value();
 446     switch (tag) {
 447       case JVM_CONSTANT_Class: {
 448         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 449         break;
 450       }
 451       case JVM_CONSTANT_Fieldref:
 452         // fall through
 453       case JVM_CONSTANT_Methodref:
 454         // fall through
 455       case JVM_CONSTANT_InterfaceMethodref: {
 456         if (!_need_verify) break;
 457         const int klass_ref_index = cp-&gt;klass_ref_index_at(index);
 458         const int name_and_type_ref_index = cp-&gt;name_and_type_ref_index_at(index);
 459         check_property(valid_klass_reference_at(klass_ref_index),
 460                        &quot;Invalid constant pool index %u in class file %s&quot;,
 461                        klass_ref_index, CHECK);
 462         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 463           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 464           &quot;Invalid constant pool index %u in class file %s&quot;,
 465           name_and_type_ref_index, CHECK);
 466         break;
 467       }
 468       case JVM_CONSTANT_String: {
 469         ShouldNotReachHere();     // Only JVM_CONSTANT_StringIndex should be present
 470         break;
 471       }
 472       case JVM_CONSTANT_Integer:
 473         break;
 474       case JVM_CONSTANT_Float:
 475         break;
 476       case JVM_CONSTANT_Long:
 477       case JVM_CONSTANT_Double: {
 478         index++;
 479         check_property(
 480           (index &lt; length &amp;&amp; cp-&gt;tag_at(index).is_invalid()),
 481           &quot;Improper constant pool long/double index %u in class file %s&quot;,
 482           index, CHECK);
 483         break;
 484       }
 485       case JVM_CONSTANT_NameAndType: {
 486         if (!_need_verify) break;
 487         const int name_ref_index = cp-&gt;name_ref_index_at(index);
 488         const int signature_ref_index = cp-&gt;signature_ref_index_at(index);
 489         check_property(valid_symbol_at(name_ref_index),
 490           &quot;Invalid constant pool index %u in class file %s&quot;,
 491           name_ref_index, CHECK);
 492         check_property(valid_symbol_at(signature_ref_index),
 493           &quot;Invalid constant pool index %u in class file %s&quot;,
 494           signature_ref_index, CHECK);
 495         break;
 496       }
 497       case JVM_CONSTANT_Utf8:
 498         break;
 499       case JVM_CONSTANT_UnresolvedClass:         // fall-through
 500       case JVM_CONSTANT_UnresolvedClassInError: {
 501         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 502         break;
 503       }
 504       case JVM_CONSTANT_ClassIndex: {
 505         const int class_index = cp-&gt;klass_index_at(index);
 506         check_property(valid_symbol_at(class_index),
 507           &quot;Invalid constant pool index %u in class file %s&quot;,
 508           class_index, CHECK);
 509 
 510         Symbol* const name = cp-&gt;symbol_at(class_index);
 511         const unsigned int name_len = name-&gt;utf8_length();
 512         if (name-&gt;is_Q_signature()) {
 513           cp-&gt;unresolved_qdescriptor_at_put(index, class_index, num_klasses++);
 514         } else {
 515           cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);
 516         }
 517         break;
 518       }
 519       case JVM_CONSTANT_StringIndex: {
 520         const int string_index = cp-&gt;string_index_at(index);
 521         check_property(valid_symbol_at(string_index),
 522           &quot;Invalid constant pool index %u in class file %s&quot;,
 523           string_index, CHECK);
 524         Symbol* const sym = cp-&gt;symbol_at(string_index);
 525         cp-&gt;unresolved_string_at_put(index, sym);
 526         break;
 527       }
 528       case JVM_CONSTANT_MethodHandle: {
 529         const int ref_index = cp-&gt;method_handle_index_at(index);
 530         check_property(valid_cp_range(ref_index, length),
 531           &quot;Invalid constant pool index %u in class file %s&quot;,
 532           ref_index, CHECK);
 533         const constantTag tag = cp-&gt;tag_at(ref_index);
 534         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 535 
 536         switch (ref_kind) {
 537           case JVM_REF_getField:
 538           case JVM_REF_getStatic:
 539           case JVM_REF_putField:
 540           case JVM_REF_putStatic: {
 541             check_property(
 542               tag.is_field(),
 543               &quot;Invalid constant pool index %u in class file %s (not a field)&quot;,
 544               ref_index, CHECK);
 545             break;
 546           }
 547           case JVM_REF_invokeVirtual:
 548           case JVM_REF_newInvokeSpecial: {
 549             check_property(
 550               tag.is_method(),
 551               &quot;Invalid constant pool index %u in class file %s (not a method)&quot;,
 552               ref_index, CHECK);
 553             break;
 554           }
 555           case JVM_REF_invokeStatic:
 556           case JVM_REF_invokeSpecial: {
 557             check_property(
 558               tag.is_method() ||
 559               ((_major_version &gt;= JAVA_8_VERSION) &amp;&amp; tag.is_interface_method()),
 560               &quot;Invalid constant pool index %u in class file %s (not a method)&quot;,
 561               ref_index, CHECK);
 562             break;
 563           }
 564           case JVM_REF_invokeInterface: {
 565             check_property(
 566               tag.is_interface_method(),
 567               &quot;Invalid constant pool index %u in class file %s (not an interface method)&quot;,
 568               ref_index, CHECK);
 569             break;
 570           }
 571           default: {
 572             classfile_parse_error(
 573               &quot;Bad method handle kind at constant pool index %u in class file %s&quot;,
 574               index, CHECK);
 575           }
 576         } // switch(refkind)
 577         // Keep the ref_index unchanged.  It will be indirected at link-time.
 578         break;
 579       } // case MethodHandle
 580       case JVM_CONSTANT_MethodType: {
 581         const int ref_index = cp-&gt;method_type_index_at(index);
 582         check_property(valid_symbol_at(ref_index),
 583           &quot;Invalid constant pool index %u in class file %s&quot;,
 584           ref_index, CHECK);
 585         break;
 586       }
 587       case JVM_CONSTANT_Dynamic: {
 588         const int name_and_type_ref_index =
 589           cp-&gt;bootstrap_name_and_type_ref_index_at(index);
 590 
 591         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 592           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 593           &quot;Invalid constant pool index %u in class file %s&quot;,
 594           name_and_type_ref_index, CHECK);
 595         // bootstrap specifier index must be checked later,
 596         // when BootstrapMethods attr is available
 597 
 598         // Mark the constant pool as having a CONSTANT_Dynamic_info structure
 599         cp-&gt;set_has_dynamic_constant();
 600         break;
 601       }
 602       case JVM_CONSTANT_InvokeDynamic: {
 603         const int name_and_type_ref_index =
 604           cp-&gt;bootstrap_name_and_type_ref_index_at(index);
 605 
 606         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 607           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 608           &quot;Invalid constant pool index %u in class file %s&quot;,
 609           name_and_type_ref_index, CHECK);
 610         // bootstrap specifier index must be checked later,
 611         // when BootstrapMethods attr is available
 612         break;
 613       }
 614       default: {
 615         fatal(&quot;bad constant pool tag value %u&quot;, cp-&gt;tag_at(index).value());
 616         ShouldNotReachHere();
 617         break;
 618       }
 619     } // switch(tag)
 620   } // end of for
 621 
 622   _first_patched_klass_resolved_index = num_klasses;
 623   cp-&gt;allocate_resolved_klasses(_loader_data, num_klasses + _max_num_patched_klasses, CHECK);
 624 
 625   if (_cp_patches != NULL) {
 626     // need to treat this_class specially...
 627 
 628     // Add dummy utf8 entries in the space reserved for names of patched classes. We&#39;ll use &quot;*&quot;
 629     // for now. These will be replaced with actual names of the patched classes in patch_class().
 630     Symbol* s = vmSymbols::star_name();
 631     for (int n=_orig_cp_size; n&lt;cp-&gt;length(); n++) {
 632       cp-&gt;symbol_at_put(n, s);
 633     }
 634 
 635     int this_class_index;
 636     {
 637       stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
 638       const u1* const mark = stream-&gt;current();
 639       stream-&gt;skip_u2_fast(1); // skip flags
 640       this_class_index = stream-&gt;get_u2_fast();
 641       stream-&gt;set_current(mark);  // revert to mark
 642     }
 643 
 644     for (index = 1; index &lt; length; index++) {          // Index 0 is unused
 645       if (has_cp_patch_at(index)) {
 646         guarantee_property(index != this_class_index,
 647           &quot;Illegal constant pool patch to self at %d in class file %s&quot;,
 648           index, CHECK);
 649         patch_constant_pool(cp, index, cp_patch_at(index), CHECK);
 650       }
 651     }
 652   }
 653 
 654   if (!_need_verify) {
 655     return;
 656   }
 657 
 658   // second verification pass - checks the strings are of the right format.
 659   // but not yet to the other entries
 660   for (index = 1; index &lt; length; index++) {
 661     const jbyte tag = cp-&gt;tag_at(index).value();
 662     switch (tag) {
 663       case JVM_CONSTANT_UnresolvedClass: {
 664         const Symbol* const class_name = cp-&gt;klass_name_at(index);
 665         // check the name, even if _cp_patches will overwrite it
 666         verify_legal_class_name(class_name, CHECK);
 667         break;
 668       }
 669       case JVM_CONSTANT_NameAndType: {
 670         if (_need_verify) {
 671           const int sig_index = cp-&gt;signature_ref_index_at(index);
 672           const int name_index = cp-&gt;name_ref_index_at(index);
 673           const Symbol* const name = cp-&gt;symbol_at(name_index);
 674           const Symbol* const sig = cp-&gt;symbol_at(sig_index);
 675           guarantee_property(sig-&gt;utf8_length() != 0,
 676             &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
 677             sig_index, CHECK);
 678           guarantee_property(name-&gt;utf8_length() != 0,
 679             &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
 680             name_index, CHECK);
 681 
 682           if (Signature::is_method(sig)) {
 683             // Format check method name and signature
 684             verify_legal_method_name(name, CHECK);
 685             verify_legal_method_signature(name, sig, CHECK);
 686           } else {
 687             // Format check field name and signature
 688             verify_legal_field_name(name, CHECK);
 689             verify_legal_field_signature(name, sig, CHECK);
 690           }
 691         }
 692         break;
 693       }
 694       case JVM_CONSTANT_Dynamic: {
 695         const int name_and_type_ref_index =
 696           cp-&gt;name_and_type_ref_index_at(index);
 697         // already verified to be utf8
 698         const int name_ref_index =
 699           cp-&gt;name_ref_index_at(name_and_type_ref_index);
 700         // already verified to be utf8
 701         const int signature_ref_index =
 702           cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 703         const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 704         const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 705         if (_need_verify) {
 706           // CONSTANT_Dynamic&#39;s name and signature are verified above, when iterating NameAndType_info.
 707           // Need only to be sure signature is the right type.
 708           if (Signature::is_method(signature)) {
 709             throwIllegalSignature(&quot;CONSTANT_Dynamic&quot;, name, signature, CHECK);
 710           }
 711         }
 712         break;
 713       }
 714       case JVM_CONSTANT_InvokeDynamic:
 715       case JVM_CONSTANT_Fieldref:
 716       case JVM_CONSTANT_Methodref:
 717       case JVM_CONSTANT_InterfaceMethodref: {
 718         const int name_and_type_ref_index =
 719           cp-&gt;name_and_type_ref_index_at(index);
 720         // already verified to be utf8
 721         const int name_ref_index =
 722           cp-&gt;name_ref_index_at(name_and_type_ref_index);
 723         // already verified to be utf8
 724         const int signature_ref_index =
 725           cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 726         const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 727         const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 728         if (tag == JVM_CONSTANT_Fieldref) {
 729           if (_need_verify) {
 730             // Field name and signature are verified above, when iterating NameAndType_info.
 731             // Need only to be sure signature is non-zero length and the right type.
 732             if (Signature::is_method(signature)) {
 733               throwIllegalSignature(&quot;Field&quot;, name, signature, CHECK);
 734             }
 735           }
 736         } else {
 737           if (_need_verify) {
 738             // Method name and signature are verified above, when iterating NameAndType_info.
 739             // Need only to be sure signature is non-zero length and the right type.
 740             if (!Signature::is_method(signature)) {
 741               throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK);
 742             }
 743           }
 744           // 4509014: If a class method name begins with &#39;&lt;&#39;, it must be &quot;&lt;init&gt;&quot;
 745           const unsigned int name_len = name-&gt;utf8_length();
 746           if (tag == JVM_CONSTANT_Methodref &amp;&amp;
 747               name_len != 0 &amp;&amp;
 748               name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL &amp;&amp;
 749               name != vmSymbols::object_initializer_name()) {
 750             classfile_parse_error(
 751               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 752               name_ref_index, CHECK);
 753           }
 754         }
 755         break;
 756       }
 757       case JVM_CONSTANT_MethodHandle: {
 758         const int ref_index = cp-&gt;method_handle_index_at(index);
 759         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 760         switch (ref_kind) {
 761           case JVM_REF_invokeVirtual:
 762           case JVM_REF_invokeStatic:
 763           case JVM_REF_invokeSpecial:
 764           case JVM_REF_newInvokeSpecial: {
 765             const int name_and_type_ref_index =
 766               cp-&gt;name_and_type_ref_index_at(ref_index);
 767             const int name_ref_index =
 768               cp-&gt;name_ref_index_at(name_and_type_ref_index);
 769             const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 770             if (name != vmSymbols::object_initializer_name()) {
 771               if (ref_kind == JVM_REF_newInvokeSpecial) {
 772                 classfile_parse_error(
 773                   &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
 774                     name_ref_index, CHECK);
 775               }
 776             } else {
 777               // The allowed invocation mode of &lt;init&gt; depends on its signature.
 778               // This test corresponds to verify_invoke_instructions in the verifier.
 779               const int signature_ref_index =
 780                 cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 781               const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 782               if (signature-&gt;is_void_method_signature()
 783                   &amp;&amp; ref_kind == JVM_REF_newInvokeSpecial) {
 784                 // OK, could be a constructor call
 785               } else if (!signature-&gt;is_void_method_signature()
 786                          &amp;&amp; ref_kind == JVM_REF_invokeStatic) {
 787                 // also OK, could be a static factory call
 788               } else {
 789                 classfile_parse_error(
 790                   &quot;Bad method name at constant pool index %u in class file %s&quot;,
 791                   name_ref_index, CHECK);
 792               }
 793             }
 794             break;
 795           }
 796           // Other ref_kinds are already fully checked in previous pass.
 797         } // switch(ref_kind)
 798         break;
 799       }
 800       case JVM_CONSTANT_MethodType: {
 801         const Symbol* const no_name = vmSymbols::type_name(); // place holder
 802         const Symbol* const signature = cp-&gt;method_type_signature_at(index);
 803         verify_legal_method_signature(no_name, signature, CHECK);
 804         break;
 805       }
 806       case JVM_CONSTANT_Utf8: {
 807         assert(cp-&gt;symbol_at(index)-&gt;refcount() != 0, &quot;count corrupted&quot;);
 808       }
 809     }  // switch(tag)
 810   }  // end of for
 811 }
 812 
 813 Handle ClassFileParser::clear_cp_patch_at(int index) {
 814   Handle patch = cp_patch_at(index);
 815   _cp_patches-&gt;at_put(index, Handle());
 816   assert(!has_cp_patch_at(index), &quot;&quot;);
 817   return patch;
 818 }
 819 
 820 void ClassFileParser::patch_class(ConstantPool* cp, int class_index, Klass* k, Symbol* name) {
 821   int name_index = _orig_cp_size + _num_patched_klasses;
 822   int resolved_klass_index = _first_patched_klass_resolved_index + _num_patched_klasses;
 823 
 824   cp-&gt;klass_at_put(class_index, name_index, resolved_klass_index, k, name);
 825   _num_patched_klasses ++;
 826 }
 827 
 828 void ClassFileParser::patch_constant_pool(ConstantPool* cp,
 829                                           int index,
 830                                           Handle patch,
 831                                           TRAPS) {
 832   assert(cp != NULL, &quot;invariant&quot;);
 833 
 834   BasicType patch_type = T_VOID;
 835 
 836   switch (cp-&gt;tag_at(index).value()) {
 837 
 838     case JVM_CONSTANT_UnresolvedClass: {
 839       // Patching a class means pre-resolving it.
 840       // The name in the constant pool is ignored.
 841       if (java_lang_Class::is_instance(patch())) {
 842         guarantee_property(!java_lang_Class::is_primitive(patch()),
 843                            &quot;Illegal class patch at %d in class file %s&quot;,
 844                            index, CHECK);
 845         Klass* k = java_lang_Class::as_Klass(patch());
 846         patch_class(cp, index, k, k-&gt;name());
 847       } else {
 848         guarantee_property(java_lang_String::is_instance(patch()),
 849                            &quot;Illegal class patch at %d in class file %s&quot;,
 850                            index, CHECK);
 851         Symbol* const name = java_lang_String::as_symbol(patch());
 852         patch_class(cp, index, NULL, name);
 853       }
 854       break;
 855     }
 856 
 857     case JVM_CONSTANT_String: {
 858       // skip this patch and don&#39;t clear it.  Needs the oop array for resolved
 859       // references to be created first.
 860       return;
 861     }
 862     case JVM_CONSTANT_Integer: patch_type = T_INT;    goto patch_prim;
 863     case JVM_CONSTANT_Float:   patch_type = T_FLOAT;  goto patch_prim;
 864     case JVM_CONSTANT_Long:    patch_type = T_LONG;   goto patch_prim;
 865     case JVM_CONSTANT_Double:  patch_type = T_DOUBLE; goto patch_prim;
 866     patch_prim:
 867     {
 868       jvalue value;
 869       BasicType value_type = java_lang_boxing_object::get_value(patch(), &amp;value);
 870       guarantee_property(value_type == patch_type,
 871                          &quot;Illegal primitive patch at %d in class file %s&quot;,
 872                          index, CHECK);
 873       switch (value_type) {
 874         case T_INT:    cp-&gt;int_at_put(index,   value.i); break;
 875         case T_FLOAT:  cp-&gt;float_at_put(index, value.f); break;
 876         case T_LONG:   cp-&gt;long_at_put(index,  value.j); break;
 877         case T_DOUBLE: cp-&gt;double_at_put(index, value.d); break;
 878         default:       assert(false, &quot;&quot;);
 879       }
 880     } // end patch_prim label
 881     break;
 882 
 883     default: {
 884       // %%% TODO: put method handles into CONSTANT_InterfaceMethodref, etc.
 885       guarantee_property(!has_cp_patch_at(index),
 886                          &quot;Illegal unexpected patch at %d in class file %s&quot;,
 887                          index, CHECK);
 888       return;
 889     }
 890   } // end of switch(tag)
 891 
 892   // On fall-through, mark the patch as used.
 893   clear_cp_patch_at(index);
 894 }
 895 class NameSigHash: public ResourceObj {
 896  public:
 897   const Symbol*       _name;       // name
 898   const Symbol*       _sig;        // signature
 899   NameSigHash*  _next;             // Next entry in hash table
 900 };
 901 
 902 static const int HASH_ROW_SIZE = 256;
 903 
 904 static unsigned int hash(const Symbol* name, const Symbol* sig) {
 905   unsigned int raw_hash = 0;
 906   raw_hash += ((unsigned int)(uintptr_t)name) &gt;&gt; (LogHeapWordSize + 2);
 907   raw_hash += ((unsigned int)(uintptr_t)sig) &gt;&gt; LogHeapWordSize;
 908 
 909   return (raw_hash + (unsigned int)(uintptr_t)name) % HASH_ROW_SIZE;
 910 }
 911 
 912 
 913 static void initialize_hashtable(NameSigHash** table) {
 914   memset((void*)table, 0, sizeof(NameSigHash*) * HASH_ROW_SIZE);
 915 }
 916 // Return false if the name/sig combination is found in table.
 917 // Return true if no duplicate is found. And name/sig is added as a new entry in table.
 918 // The old format checker uses heap sort to find duplicates.
 919 // NOTE: caller should guarantee that GC doesn&#39;t happen during the life cycle
 920 // of table since we don&#39;t expect Symbol*&#39;s to move.
 921 static bool put_after_lookup(const Symbol* name, const Symbol* sig, NameSigHash** table) {
 922   assert(name != NULL, &quot;name in constant pool is NULL&quot;);
 923 
 924   // First lookup for duplicates
 925   int index = hash(name, sig);
 926   NameSigHash* entry = table[index];
 927   while (entry != NULL) {
 928     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 929       return false;
 930     }
 931     entry = entry-&gt;_next;
 932   }
 933 
 934   // No duplicate is found, allocate a new entry and fill it.
 935   entry = new NameSigHash();
 936   entry-&gt;_name = name;
 937   entry-&gt;_sig = sig;
 938 
 939   // Insert into hash table
 940   entry-&gt;_next = table[index];
 941   table[index] = entry;
 942 
 943   return true;
 944 }
 945 
 946 // Side-effects: populates the _local_interfaces field
 947 void ClassFileParser::parse_interfaces(const ClassFileStream* stream,
 948                                        int itfs_len,
 949                                        ConstantPool* cp,
 950                                        bool is_inline_type,
 951                                        bool* const has_nonstatic_concrete_methods,
 952                                        // FIXME: lots of these functions
 953                                        // declare their parameters as const,
 954                                        // which adds only noise to the code.
 955                                        // Remove the spurious const modifiers.
 956                                        // Many are of the form &quot;const int x&quot;
 957                                        // or &quot;T* const x&quot;.
 958                                        bool* const is_declared_atomic,
 959                                        TRAPS) {
 960   assert(stream != NULL, &quot;invariant&quot;);
 961   assert(cp != NULL, &quot;invariant&quot;);
 962   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 963 
 964   if (itfs_len == 0) {
 965     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(0);
 966   } else {
 967     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
 968     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(itfs_len);
 969     int index = 0;
 970     for (index = 0; index &lt; itfs_len; index++) {
 971       const u2 interface_index = stream-&gt;get_u2(CHECK);
 972       Klass* interf;
 973       check_property(
 974         valid_klass_reference_at(interface_index),
 975         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 976         interface_index, CHECK);
 977       if (cp-&gt;tag_at(interface_index).is_klass()) {
 978         interf = cp-&gt;resolved_klass_at(interface_index);
 979       } else {
 980         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 981 
 982         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 983         // But need to make sure it&#39;s not an array type.
 984         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 985                            &quot;Bad interface name in class file %s&quot;, CHECK);
 986 
 987         // Call resolve_super so class circularity is checked
 988         interf = SystemDictionary::resolve_super_or_fail(
 989                                                   _class_name,
 990                                                   unresolved_klass,
 991                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 992                                                   _protection_domain,
 993                                                   false,
 994                                                   CHECK);
 995       }
 996 
 997       if (!interf-&gt;is_interface()) {
 998         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 999                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
1000                           _class_name-&gt;as_klass_external_name(),
1001                           interf-&gt;external_name(),
1002                           interf-&gt;class_in_module_of_loader()));
1003       }
1004 
1005       InstanceKlass* ik = InstanceKlass::cast(interf);
1006       if (is_inline_type &amp;&amp; ik-&gt;invalid_inline_super()) {
1007         ResourceMark rm(THREAD);
1008         Exceptions::fthrow(
1009           THREAD_AND_LOCATION,
1010           vmSymbols::java_lang_IncompatibleClassChangeError(),
1011           &quot;Inline type %s attempts to implement interface java.lang.IdentityObject&quot;,
1012           _class_name-&gt;as_klass_external_name());
1013         return;
1014       }
1015       if (ik-&gt;invalid_inline_super()) {
1016         set_invalid_inline_super();
1017       }
1018       if (ik-&gt;has_nonstatic_concrete_methods()) {
1019         *has_nonstatic_concrete_methods = true;
1020       }
1021       if (ik-&gt;is_declared_atomic()) {
1022         *is_declared_atomic = true;
1023       }
1024       if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {
1025         _implements_identityObject = true;
1026       }
1027       _temp_local_interfaces-&gt;append(ik);
1028     }
1029 
1030     if (!_need_verify || itfs_len &lt;= 1) {
1031       return;
1032     }
1033 
1034     // Check if there&#39;s any duplicates in interfaces
1035     ResourceMark rm(THREAD);
1036     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1037                                                                  NameSigHash*,
1038                                                                  HASH_ROW_SIZE);
1039     initialize_hashtable(interface_names);
1040     bool dup = false;
1041     const Symbol* name = NULL;
1042     {
1043       debug_only(NoSafepointVerifier nsv;)
1044       for (index = 0; index &lt; itfs_len; index++) {
1045         const InstanceKlass* const k = _temp_local_interfaces-&gt;at(index);
1046         name = k-&gt;name();
1047         // If no duplicates, add (name, NULL) in hashtable interface_names.
1048         if (!put_after_lookup(name, NULL, interface_names)) {
1049           dup = true;
1050           break;
1051         }
1052       }
1053     }
1054     if (dup) {
1055       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1056                              name-&gt;as_C_string(), CHECK);
1057     }
1058   }
1059 }
1060 
1061 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1062                                            int constantvalue_index,
1063                                            int signature_index,
1064                                            TRAPS) const {
1065   // Make sure the constant pool entry is of a type appropriate to this field
1066   guarantee_property(
1067     (constantvalue_index &gt; 0 &amp;&amp;
1068       constantvalue_index &lt; cp-&gt;length()),
1069     &quot;Bad initial value index %u in ConstantValue attribute in class file %s&quot;,
1070     constantvalue_index, CHECK);
1071 
1072   const constantTag value_type = cp-&gt;tag_at(constantvalue_index);
1073   switch(cp-&gt;basic_type_for_signature_at(signature_index)) {
1074     case T_LONG: {
1075       guarantee_property(value_type.is_long(),
1076                          &quot;Inconsistent constant value type in class file %s&quot;,
1077                          CHECK);
1078       break;
1079     }
1080     case T_FLOAT: {
1081       guarantee_property(value_type.is_float(),
1082                          &quot;Inconsistent constant value type in class file %s&quot;,
1083                          CHECK);
1084       break;
1085     }
1086     case T_DOUBLE: {
1087       guarantee_property(value_type.is_double(),
1088                          &quot;Inconsistent constant value type in class file %s&quot;,
1089                          CHECK);
1090       break;
1091     }
1092     case T_BYTE:
1093     case T_CHAR:
1094     case T_SHORT:
1095     case T_BOOLEAN:
1096     case T_INT: {
1097       guarantee_property(value_type.is_int(),
1098                          &quot;Inconsistent constant value type in class file %s&quot;,
1099                          CHECK);
1100       break;
1101     }
1102     case T_OBJECT: {
1103       guarantee_property((cp-&gt;symbol_at(signature_index)-&gt;equals(&quot;Ljava/lang/String;&quot;)
1104                          &amp;&amp; value_type.is_string()),
1105                          &quot;Bad string initial value in class file %s&quot;,
1106                          CHECK);
1107       break;
1108     }
1109     default: {
1110       classfile_parse_error(&quot;Unable to set initial value %u in class file %s&quot;,
1111                              constantvalue_index,
1112                              CHECK);
1113     }
1114   }
1115 }
1116 
1117 class AnnotationCollector : public ResourceObj{
1118 public:
1119   enum Location { _in_field, _in_method, _in_class };
1120   enum ID {
1121     _unknown = 0,
1122     _method_CallerSensitive,
1123     _method_ForceInline,
1124     _method_DontInline,
1125     _method_InjectedProfile,
1126     _method_LambdaForm_Compiled,
1127     _method_Hidden,
1128     _method_HotSpotIntrinsicCandidate,
1129     _jdk_internal_vm_annotation_Contended,
1130     _field_Stable,
1131     _jdk_internal_vm_annotation_ReservedStackAccess,
1132     _annotation_LIMIT
1133   };
1134   const Location _location;
1135   int _annotations_present;
1136   u2 _contended_group;
1137 
1138   AnnotationCollector(Location location)
1139     : _location(location), _annotations_present(0)
1140   {
1141     assert((int)_annotation_LIMIT &lt;= (int)sizeof(_annotations_present) * BitsPerByte, &quot;&quot;);
1142   }
1143   // If this annotation name has an ID, report it (or _none).
1144   ID annotation_index(const ClassLoaderData* loader_data, const Symbol* name, bool can_access_vm_annotations);
1145   // Set the annotation name:
1146   void set_annotation(ID id) {
1147     assert((int)id &gt;= 0 &amp;&amp; (int)id &lt; (int)_annotation_LIMIT, &quot;oob&quot;);
1148     _annotations_present |= nth_bit((int)id);
1149   }
1150 
1151   void remove_annotation(ID id) {
1152     assert((int)id &gt;= 0 &amp;&amp; (int)id &lt; (int)_annotation_LIMIT, &quot;oob&quot;);
1153     _annotations_present &amp;= ~nth_bit((int)id);
1154   }
1155 
1156   // Report if the annotation is present.
1157   bool has_any_annotations() const { return _annotations_present != 0; }
1158   bool has_annotation(ID id) const { return (nth_bit((int)id) &amp; _annotations_present) != 0; }
1159 
1160   void set_contended_group(u2 group) { _contended_group = group; }
1161   u2 contended_group() const { return _contended_group; }
1162 
1163   bool is_contended() const { return has_annotation(_jdk_internal_vm_annotation_Contended); }
1164 
1165   void set_stable(bool stable) { set_annotation(_field_Stable); }
1166   bool is_stable() const { return has_annotation(_field_Stable); }
1167 };
1168 
1169 // This class also doubles as a holder for metadata cleanup.
1170 class ClassFileParser::FieldAnnotationCollector : public AnnotationCollector {
1171 private:
1172   ClassLoaderData* _loader_data;
1173   AnnotationArray* _field_annotations;
1174   AnnotationArray* _field_type_annotations;
1175 public:
1176   FieldAnnotationCollector(ClassLoaderData* loader_data) :
1177     AnnotationCollector(_in_field),
1178     _loader_data(loader_data),
1179     _field_annotations(NULL),
1180     _field_type_annotations(NULL) {}
1181   ~FieldAnnotationCollector();
1182   void apply_to(FieldInfo* f);
1183   AnnotationArray* field_annotations()      { return _field_annotations; }
1184   AnnotationArray* field_type_annotations() { return _field_type_annotations; }
1185 
1186   void set_field_annotations(AnnotationArray* a)      { _field_annotations = a; }
1187   void set_field_type_annotations(AnnotationArray* a) { _field_type_annotations = a; }
1188 };
1189 
1190 class MethodAnnotationCollector : public AnnotationCollector{
1191 public:
1192   MethodAnnotationCollector() : AnnotationCollector(_in_method) { }
1193   void apply_to(const methodHandle&amp; m);
1194 };
1195 
1196 class ClassFileParser::ClassAnnotationCollector : public AnnotationCollector{
1197 public:
1198   ClassAnnotationCollector() : AnnotationCollector(_in_class) { }
1199   void apply_to(InstanceKlass* ik);
1200 };
1201 
1202 
1203 static int skip_annotation_value(const u1*, int, int); // fwd decl
1204 
1205 // Safely increment index by val if does not pass limit
1206 #define SAFE_ADD(index, limit, val) \
1207 if (index &gt;= limit - val) return limit; \
1208 index += val;
1209 
1210 // Skip an annotation.  Return &gt;=limit if there is any problem.
1211 static int skip_annotation(const u1* buffer, int limit, int index) {
1212   assert(buffer != NULL, &quot;invariant&quot;);
1213   // annotation := atype:u2 do(nmem:u2) {member:u2 value}
1214   // value := switch (tag:u1) { ... }
1215   SAFE_ADD(index, limit, 4); // skip atype and read nmem
1216   int nmem = Bytes::get_Java_u2((address)buffer + index - 2);
1217   while (--nmem &gt;= 0 &amp;&amp; index &lt; limit) {
1218     SAFE_ADD(index, limit, 2); // skip member
1219     index = skip_annotation_value(buffer, limit, index);
1220   }
1221   return index;
1222 }
1223 
1224 // Skip an annotation value.  Return &gt;=limit if there is any problem.
1225 static int skip_annotation_value(const u1* buffer, int limit, int index) {
1226   assert(buffer != NULL, &quot;invariant&quot;);
1227 
1228   // value := switch (tag:u1) {
1229   //   case B, C, I, S, Z, D, F, J, c: con:u2;
1230   //   case e: e_class:u2 e_name:u2;
1231   //   case s: s_con:u2;
1232   //   case [: do(nval:u2) {value};
1233   //   case @: annotation;
1234   //   case s: s_con:u2;
1235   // }
1236   SAFE_ADD(index, limit, 1); // read tag
1237   const u1 tag = buffer[index - 1];
1238   switch (tag) {
1239     case &#39;B&#39;:
1240     case &#39;C&#39;:
1241     case &#39;I&#39;:
1242     case &#39;S&#39;:
1243     case &#39;Z&#39;:
1244     case &#39;D&#39;:
1245     case &#39;F&#39;:
1246     case &#39;J&#39;:
1247     case &#39;c&#39;:
1248     case &#39;s&#39;:
1249       SAFE_ADD(index, limit, 2);  // skip con or s_con
1250       break;
1251     case &#39;e&#39;:
1252       SAFE_ADD(index, limit, 4);  // skip e_class, e_name
1253       break;
1254     case &#39;[&#39;:
1255     {
1256       SAFE_ADD(index, limit, 2); // read nval
1257       int nval = Bytes::get_Java_u2((address)buffer + index - 2);
1258       while (--nval &gt;= 0 &amp;&amp; index &lt; limit) {
1259         index = skip_annotation_value(buffer, limit, index);
1260       }
1261     }
1262     break;
1263     case &#39;@&#39;:
1264       index = skip_annotation(buffer, limit, index);
1265       break;
1266     default:
1267       return limit;  //  bad tag byte
1268   }
1269   return index;
1270 }
1271 
1272 // Sift through annotations, looking for those significant to the VM:
1273 static void parse_annotations(const ConstantPool* const cp,
1274                               const u1* buffer, int limit,
1275                               AnnotationCollector* coll,
1276                               ClassLoaderData* loader_data,
1277                               const bool can_access_vm_annotations,
1278                               TRAPS) {
1279 
1280   assert(cp != NULL, &quot;invariant&quot;);
1281   assert(buffer != NULL, &quot;invariant&quot;);
1282   assert(coll != NULL, &quot;invariant&quot;);
1283   assert(loader_data != NULL, &quot;invariant&quot;);
1284 
1285   // annotations := do(nann:u2) {annotation}
1286   int index = 2; // read nann
1287   if (index &gt;= limit)  return;
1288   int nann = Bytes::get_Java_u2((address)buffer + index - 2);
1289   enum {  // initial annotation layout
1290     atype_off = 0,      // utf8 such as &#39;Ljava/lang/annotation/Retention;&#39;
1291     count_off = 2,      // u2   such as 1 (one value)
1292     member_off = 4,     // utf8 such as &#39;value&#39;
1293     tag_off = 6,        // u1   such as &#39;c&#39; (type) or &#39;e&#39; (enum)
1294     e_tag_val = &#39;e&#39;,
1295     e_type_off = 7,   // utf8 such as &#39;Ljava/lang/annotation/RetentionPolicy;&#39;
1296     e_con_off = 9,    // utf8 payload, such as &#39;SOURCE&#39;, &#39;CLASS&#39;, &#39;RUNTIME&#39;
1297     e_size = 11,     // end of &#39;e&#39; annotation
1298     c_tag_val = &#39;c&#39;,    // payload is type
1299     c_con_off = 7,    // utf8 payload, such as &#39;I&#39;
1300     c_size = 9,       // end of &#39;c&#39; annotation
1301     s_tag_val = &#39;s&#39;,    // payload is String
1302     s_con_off = 7,    // utf8 payload, such as &#39;Ljava/lang/String;&#39;
1303     s_size = 9,
1304     min_size = 6        // smallest possible size (zero members)
1305   };
1306   // Cannot add min_size to index in case of overflow MAX_INT
1307   while ((--nann) &gt;= 0 &amp;&amp; (index - 2 &lt;= limit - min_size)) {
1308     int index0 = index;
1309     index = skip_annotation(buffer, limit, index);
1310     const u1* const abase = buffer + index0;
1311     const int atype = Bytes::get_Java_u2((address)abase + atype_off);
1312     const int count = Bytes::get_Java_u2((address)abase + count_off);
1313     const Symbol* const aname = check_symbol_at(cp, atype);
1314     if (aname == NULL)  break;  // invalid annotation name
1315     const Symbol* member = NULL;
1316     if (count &gt;= 1) {
1317       const int member_index = Bytes::get_Java_u2((address)abase + member_off);
1318       member = check_symbol_at(cp, member_index);
1319       if (member == NULL)  break;  // invalid member name
1320     }
1321 
1322     // Here is where parsing particular annotations will take place.
1323     AnnotationCollector::ID id = coll-&gt;annotation_index(loader_data, aname, can_access_vm_annotations);
1324     if (AnnotationCollector::_unknown == id)  continue;
1325     coll-&gt;set_annotation(id);
1326 
1327     if (AnnotationCollector::_jdk_internal_vm_annotation_Contended == id) {
1328       // @Contended can optionally specify the contention group.
1329       //
1330       // Contended group defines the equivalence class over the fields:
1331       // the fields within the same contended group are not treated distinct.
1332       // The only exception is default group, which does not incur the
1333       // equivalence. Naturally, contention group for classes is meaningless.
1334       //
1335       // While the contention group is specified as String, annotation
1336       // values are already interned, and we might as well use the constant
1337       // pool index as the group tag.
1338       //
1339       u2 group_index = 0; // default contended group
1340       if (count == 1
1341         &amp;&amp; s_size == (index - index0)  // match size
1342         &amp;&amp; s_tag_val == *(abase + tag_off)
1343         &amp;&amp; member == vmSymbols::value_name()) {
1344         group_index = Bytes::get_Java_u2((address)abase + s_con_off);
1345         if (cp-&gt;symbol_at(group_index)-&gt;utf8_length() == 0) {
1346           group_index = 0; // default contended group
1347         }
1348       }
1349       coll-&gt;set_contended_group(group_index);
1350     }
1351   }
1352 }
1353 
1354 
1355 // Parse attributes for a field.
1356 void ClassFileParser::parse_field_attributes(const ClassFileStream* const cfs,
1357                                              u2 attributes_count,
1358                                              bool is_static, u2 signature_index,
1359                                              u2* const constantvalue_index_addr,
1360                                              bool* const is_synthetic_addr,
1361                                              u2* const generic_signature_index_addr,
1362                                              ClassFileParser::FieldAnnotationCollector* parsed_annotations,
1363                                              TRAPS) {
1364   assert(cfs != NULL, &quot;invariant&quot;);
1365   assert(constantvalue_index_addr != NULL, &quot;invariant&quot;);
1366   assert(is_synthetic_addr != NULL, &quot;invariant&quot;);
1367   assert(generic_signature_index_addr != NULL, &quot;invariant&quot;);
1368   assert(parsed_annotations != NULL, &quot;invariant&quot;);
1369   assert(attributes_count &gt; 0, &quot;attributes_count should be greater than 0&quot;);
1370 
1371   u2 constantvalue_index = 0;
1372   u2 generic_signature_index = 0;
1373   bool is_synthetic = false;
1374   const u1* runtime_visible_annotations = NULL;
1375   int runtime_visible_annotations_length = 0;
1376   const u1* runtime_invisible_annotations = NULL;
1377   int runtime_invisible_annotations_length = 0;
1378   const u1* runtime_visible_type_annotations = NULL;
1379   int runtime_visible_type_annotations_length = 0;
1380   const u1* runtime_invisible_type_annotations = NULL;
1381   int runtime_invisible_type_annotations_length = 0;
1382   bool runtime_invisible_annotations_exists = false;
1383   bool runtime_invisible_type_annotations_exists = false;
1384   const ConstantPool* const cp = _cp;
1385 
1386   while (attributes_count--) {
1387     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
1388     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
1389     const u4 attribute_length = cfs-&gt;get_u4_fast();
1390     check_property(valid_symbol_at(attribute_name_index),
1391                    &quot;Invalid field attribute index %u in class file %s&quot;,
1392                    attribute_name_index,
1393                    CHECK);
1394 
1395     const Symbol* const attribute_name = cp-&gt;symbol_at(attribute_name_index);
1396     if (is_static &amp;&amp; attribute_name == vmSymbols::tag_constant_value()) {
1397       // ignore if non-static
1398       if (constantvalue_index != 0) {
1399         classfile_parse_error(&quot;Duplicate ConstantValue attribute in class file %s&quot;, CHECK);
1400       }
1401       check_property(
1402         attribute_length == 2,
1403         &quot;Invalid ConstantValue field attribute length %u in class file %s&quot;,
1404         attribute_length, CHECK);
1405 
1406       constantvalue_index = cfs-&gt;get_u2(CHECK);
1407       if (_need_verify) {
1408         verify_constantvalue(cp, constantvalue_index, signature_index, CHECK);
1409       }
1410     } else if (attribute_name == vmSymbols::tag_synthetic()) {
1411       if (attribute_length != 0) {
1412         classfile_parse_error(
1413           &quot;Invalid Synthetic field attribute length %u in class file %s&quot;,
1414           attribute_length, CHECK);
1415       }
1416       is_synthetic = true;
1417     } else if (attribute_name == vmSymbols::tag_deprecated()) { // 4276120
1418       if (attribute_length != 0) {
1419         classfile_parse_error(
1420           &quot;Invalid Deprecated field attribute length %u in class file %s&quot;,
1421           attribute_length, CHECK);
1422       }
1423     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
1424       if (attribute_name == vmSymbols::tag_signature()) {
1425         if (generic_signature_index != 0) {
1426           classfile_parse_error(
1427             &quot;Multiple Signature attributes for field in class file %s&quot;, CHECK);
1428         }
1429         if (attribute_length != 2) {
1430           classfile_parse_error(
1431             &quot;Wrong size %u for field&#39;s Signature attribute in class file %s&quot;,
1432             attribute_length, CHECK);
1433         }
1434         generic_signature_index = parse_generic_signature_attribute(cfs, CHECK);
1435       } else if (attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
1436         if (runtime_visible_annotations != NULL) {
1437           classfile_parse_error(
1438             &quot;Multiple RuntimeVisibleAnnotations attributes for field in class file %s&quot;, CHECK);
1439         }
1440         runtime_visible_annotations_length = attribute_length;
1441         runtime_visible_annotations = cfs-&gt;current();
1442         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
1443         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK);
1444         parse_annotations(cp,
1445                           runtime_visible_annotations,
1446                           runtime_visible_annotations_length,
1447                           parsed_annotations,
1448                           _loader_data,
1449                           _can_access_vm_annotations,
1450                           CHECK);
1451         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
1452       } else if (attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
1453         if (runtime_invisible_annotations_exists) {
1454           classfile_parse_error(
1455             &quot;Multiple RuntimeInvisibleAnnotations attributes for field in class file %s&quot;, CHECK);
1456         }
1457         runtime_invisible_annotations_exists = true;
1458         if (PreserveAllAnnotations) {
1459           runtime_invisible_annotations_length = attribute_length;
1460           runtime_invisible_annotations = cfs-&gt;current();
1461           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
1462         }
1463         cfs-&gt;skip_u1(attribute_length, CHECK);
1464       } else if (attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
1465         if (runtime_visible_type_annotations != NULL) {
1466           classfile_parse_error(
1467             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for field in class file %s&quot;, CHECK);
1468         }
1469         runtime_visible_type_annotations_length = attribute_length;
1470         runtime_visible_type_annotations = cfs-&gt;current();
1471         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
1472         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK);
1473       } else if (attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
1474         if (runtime_invisible_type_annotations_exists) {
1475           classfile_parse_error(
1476             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for field in class file %s&quot;, CHECK);
1477         } else {
1478           runtime_invisible_type_annotations_exists = true;
1479         }
1480         if (PreserveAllAnnotations) {
1481           runtime_invisible_type_annotations_length = attribute_length;
1482           runtime_invisible_type_annotations = cfs-&gt;current();
1483           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
1484         }
1485         cfs-&gt;skip_u1(attribute_length, CHECK);
1486       } else {
1487         cfs-&gt;skip_u1(attribute_length, CHECK);  // Skip unknown attributes
1488       }
1489     } else {
1490       cfs-&gt;skip_u1(attribute_length, CHECK);  // Skip unknown attributes
1491     }
1492   }
1493 
1494   *constantvalue_index_addr = constantvalue_index;
1495   *is_synthetic_addr = is_synthetic;
1496   *generic_signature_index_addr = generic_signature_index;
1497   AnnotationArray* a = assemble_annotations(runtime_visible_annotations,
1498                                             runtime_visible_annotations_length,
1499                                             runtime_invisible_annotations,
1500                                             runtime_invisible_annotations_length,
1501                                             CHECK);
1502   parsed_annotations-&gt;set_field_annotations(a);
1503   a = assemble_annotations(runtime_visible_type_annotations,
1504                            runtime_visible_type_annotations_length,
1505                            runtime_invisible_type_annotations,
1506                            runtime_invisible_type_annotations_length,
1507                            CHECK);
1508   parsed_annotations-&gt;set_field_type_annotations(a);
1509   return;
1510 }
1511 
1512 
1513 // Field allocation types. Used for computing field offsets.
1514 
1515 enum FieldAllocationType {
1516   STATIC_OOP,           // Oops
1517   STATIC_BYTE,          // Boolean, Byte, char
1518   STATIC_SHORT,         // shorts
1519   STATIC_WORD,          // ints
1520   STATIC_DOUBLE,        // aligned long or double
<a name="1" id="anc1"></a><span class="line-modified">1521   STATIC_FLATTENABLE,   // flattenable field</span>
1522   NONSTATIC_OOP,
1523   NONSTATIC_BYTE,
1524   NONSTATIC_SHORT,
1525   NONSTATIC_WORD,
1526   NONSTATIC_DOUBLE,
<a name="2" id="anc2"></a><span class="line-modified">1527   NONSTATIC_FLATTENABLE,</span>
1528   MAX_FIELD_ALLOCATION_TYPE,
1529   BAD_ALLOCATION_TYPE = -1
1530 };
1531 
1532 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1533   BAD_ALLOCATION_TYPE, // 0
1534   BAD_ALLOCATION_TYPE, // 1
1535   BAD_ALLOCATION_TYPE, // 2
1536   BAD_ALLOCATION_TYPE, // 3
1537   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1538   NONSTATIC_SHORT,     // T_CHAR        =  5,
1539   NONSTATIC_WORD,      // T_FLOAT       =  6,
1540   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1541   NONSTATIC_BYTE,      // T_BYTE        =  8,
1542   NONSTATIC_SHORT,     // T_SHORT       =  9,
1543   NONSTATIC_WORD,      // T_INT         = 10,
1544   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1545   NONSTATIC_OOP,       // T_OBJECT      = 12,
1546   NONSTATIC_OOP,       // T_ARRAY       = 13,
1547   NONSTATIC_OOP,       // T_VALUETYPE   = 14,
1548   BAD_ALLOCATION_TYPE, // T_VOID        = 15,
1549   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,
1550   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,
1551   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,
1552   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,
1553   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20,
1554   BAD_ALLOCATION_TYPE, // 0
1555   BAD_ALLOCATION_TYPE, // 1
1556   BAD_ALLOCATION_TYPE, // 2
1557   BAD_ALLOCATION_TYPE, // 3
1558   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1559   STATIC_SHORT,        // T_CHAR        =  5,
1560   STATIC_WORD,         // T_FLOAT       =  6,
1561   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1562   STATIC_BYTE,         // T_BYTE        =  8,
1563   STATIC_SHORT,        // T_SHORT       =  9,
1564   STATIC_WORD,         // T_INT         = 10,
1565   STATIC_DOUBLE,       // T_LONG        = 11,
1566   STATIC_OOP,          // T_OBJECT      = 12,
1567   STATIC_OOP,          // T_ARRAY       = 13,
1568   STATIC_OOP,          // T_VALUETYPE   = 14,
1569   BAD_ALLOCATION_TYPE, // T_VOID        = 15,
1570   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,
1571   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,
1572   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,
1573   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,
1574   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20
1575 };
1576 
<a name="3" id="anc3"></a><span class="line-modified">1577 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type, bool is_flattenable) {</span>
1578   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1579   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1580   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);
<a name="4" id="anc4"></a><span class="line-modified">1581   if (is_flattenable) {</span>
<span class="line-modified">1582     result = is_static ? STATIC_FLATTENABLE : NONSTATIC_FLATTENABLE;</span>
1583   }
1584   return result;
1585 }
1586 
1587 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1588  public:
1589   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1590 
1591   FieldAllocationCount() {
1592     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1593       count[i] = 0;
1594     }
1595   }
1596 
<a name="5" id="anc5"></a><span class="line-modified">1597   FieldAllocationType update(bool is_static, BasicType type, bool is_flattenable) {</span>
<span class="line-modified">1598     FieldAllocationType atype = basic_type_to_atype(is_static, type, is_flattenable);</span>
1599     if (atype != BAD_ALLOCATION_TYPE) {
1600       // Make sure there is no overflow with injected fields.
1601       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1602       count[atype]++;
1603     }
1604     return atype;
1605   }
1606 };
1607 
1608 // Side-effects: populates the _fields, _fields_annotations,
1609 // _fields_type_annotations fields
1610 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1611                                    bool is_interface,
1612                                    bool is_inline_type,
1613                                    FieldAllocationCount* const fac,
1614                                    ConstantPool* cp,
1615                                    const int cp_size,
1616                                    u2* const java_fields_count_ptr,
1617                                    TRAPS) {
1618 
1619   assert(cfs != NULL, &quot;invariant&quot;);
1620   assert(fac != NULL, &quot;invariant&quot;);
1621   assert(cp != NULL, &quot;invariant&quot;);
1622   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1623 
1624   assert(NULL == _fields, &quot;invariant&quot;);
1625   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1626   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1627 
1628   cfs-&gt;guarantee_more(2, CHECK);  // length
1629   const u2 length = cfs-&gt;get_u2_fast();
1630   *java_fields_count_ptr = length;
1631 
1632   int num_injected = 0;
1633   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1634                                                                   &amp;num_injected);
1635 
1636   // two more slots are required for inline classes:
1637   // one for the static field with a reference to the pre-allocated default value
1638   // one for the field the JVM injects when detecting an empty inline class
1639   const int total_fields = length + num_injected + (is_inline_type ? 2 : 0);
1640 
1641   // The field array starts with tuples of shorts
1642   // [access, name index, sig index, initial value index, byte offset].
1643   // A generic signature slot only exists for field with generic
1644   // signature attribute. And the access flag is set with
1645   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1646   // signature slots are at the end of the field array and after all
1647   // other fields data.
1648   //
1649   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1650   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1651   //       ...
1652   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1653   //       [generic signature index]
1654   //       [generic signature index]
1655   //       ...
1656   //
1657   // Allocate a temporary resource array for field data. For each field,
1658   // a slot is reserved in the temporary array for the generic signature
1659   // index. After parsing all fields, the data are copied to a permanent
1660   // array and any unused slots will be discarded.
1661   ResourceMark rm(THREAD);
1662   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1663                                               u2,
1664                                               total_fields * (FieldInfo::field_slots + 1));
1665 
1666   // The generic signature slots start after all other fields&#39; data.
1667   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1668   int num_generic_signature = 0;
1669   int instance_fields_count = 0;
1670   for (int n = 0; n &lt; length; n++) {
1671     // access_flags, name_index, descriptor_index, attributes_count
1672     cfs-&gt;guarantee_more(8, CHECK);
1673 
1674     jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;
1675 
1676     const jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;
1677     verify_legal_field_modifiers(flags, is_interface, is_inline_type, CHECK);
1678     AccessFlags access_flags;
1679     access_flags.set_flags(flags);
1680 
1681     const u2 name_index = cfs-&gt;get_u2_fast();
1682     check_property(valid_symbol_at(name_index),
1683       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1684       name_index, CHECK);
1685     const Symbol* const name = cp-&gt;symbol_at(name_index);
1686     verify_legal_field_name(name, CHECK);
1687 
1688     const u2 signature_index = cfs-&gt;get_u2_fast();
1689     check_property(valid_symbol_at(signature_index),
1690       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1691       signature_index, CHECK);
1692     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1693     verify_legal_field_signature(name, sig, CHECK);
<a name="6" id="anc6"></a><span class="line-removed">1694     assert(!access_flags.is_flattenable(), &quot;ACC_FLATTENABLE should have been filtered out&quot;);</span>
<span class="line-removed">1695     if (sig-&gt;is_Q_signature()) {</span>
<span class="line-removed">1696       // assert(_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS, &quot;Q-descriptors are only supported in recent classfiles&quot;);</span>
<span class="line-removed">1697       access_flags.set_is_flattenable();</span>
<span class="line-removed">1698     }</span>
<span class="line-removed">1699     if (access_flags.is_flattenable()) {</span>
<span class="line-removed">1700       // Array flattenability cannot be specified.  Arrays of value classes are</span>
<span class="line-removed">1701       // are always flattenable.  Arrays of other classes are not flattenable.</span>
<span class="line-removed">1702       if (sig-&gt;utf8_length() &gt; 1 &amp;&amp; sig-&gt;char_at(0) == &#39;[&#39;) {</span>
<span class="line-removed">1703         classfile_parse_error(</span>
<span class="line-removed">1704             &quot;Field \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s is invalid.&quot;</span>
<span class="line-removed">1705             &quot; ACC_FLATTENABLE cannot be specified for an array&quot;,</span>
<span class="line-removed">1706             name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);</span>
<span class="line-removed">1707       }</span>
<span class="line-removed">1708       _has_flattenable_fields = true;</span>
<span class="line-removed">1709     }</span>
1710     if (!access_flags.is_static()) instance_fields_count++;
1711 
1712     u2 constantvalue_index = 0;
1713     bool is_synthetic = false;
1714     u2 generic_signature_index = 0;
1715     const bool is_static = access_flags.is_static();
1716     FieldAnnotationCollector parsed_annotations(_loader_data);
1717 
1718     const u2 attributes_count = cfs-&gt;get_u2_fast();
1719     if (attributes_count &gt; 0) {
1720       parse_field_attributes(cfs,
1721                              attributes_count,
1722                              is_static,
1723                              signature_index,
1724                              &amp;constantvalue_index,
1725                              &amp;is_synthetic,
1726                              &amp;generic_signature_index,
1727                              &amp;parsed_annotations,
1728                              CHECK);
1729 
1730       if (parsed_annotations.field_annotations() != NULL) {
1731         if (_fields_annotations == NULL) {
1732           _fields_annotations = MetadataFactory::new_array&lt;AnnotationArray*&gt;(
1733                                              _loader_data, length, NULL,
1734                                              CHECK);
1735         }
1736         _fields_annotations-&gt;at_put(n, parsed_annotations.field_annotations());
1737         parsed_annotations.set_field_annotations(NULL);
1738       }
1739       if (parsed_annotations.field_type_annotations() != NULL) {
1740         if (_fields_type_annotations == NULL) {
1741           _fields_type_annotations =
1742             MetadataFactory::new_array&lt;AnnotationArray*&gt;(_loader_data,
1743                                                          length,
1744                                                          NULL,
1745                                                          CHECK);
1746         }
1747         _fields_type_annotations-&gt;at_put(n, parsed_annotations.field_type_annotations());
1748         parsed_annotations.set_field_type_annotations(NULL);
1749       }
1750 
1751       if (is_synthetic) {
1752         access_flags.set_is_synthetic();
1753       }
1754       if (generic_signature_index != 0) {
1755         access_flags.set_field_has_generic_signature();
1756         fa[generic_signature_slot] = generic_signature_index;
1757         generic_signature_slot ++;
1758         num_generic_signature ++;
1759       }
1760     }
1761 
1762     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1763     field-&gt;initialize(access_flags.as_short(),
1764                       name_index,
1765                       signature_index,
1766                       constantvalue_index);
1767     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1768 
1769     // Remember how many oops we encountered and compute allocation type
<a name="7" id="anc7"></a><span class="line-modified">1770     const FieldAllocationType atype = fac-&gt;update(is_static, type, access_flags.is_flattenable());</span>
1771     field-&gt;set_allocation_type(atype);
1772 
1773     // After field is initialized with type, we can augment it with aux info
1774     if (parsed_annotations.has_any_annotations()) {
1775       parsed_annotations.apply_to(field);
1776       if (field-&gt;is_contended()) {
1777         _has_contended_fields = true;
1778       }
1779     }
1780   }
1781 
1782   int index = length;
1783   if (num_injected != 0) {
1784     for (int n = 0; n &lt; num_injected; n++) {
1785       // Check for duplicates
1786       if (injected[n].may_be_java) {
1787         const Symbol* const name      = injected[n].name();
1788         const Symbol* const signature = injected[n].signature();
1789         bool duplicate = false;
1790         for (int i = 0; i &lt; length; i++) {
1791           const FieldInfo* const f = FieldInfo::from_field_array(fa, i);
1792           if (name      == cp-&gt;symbol_at(f-&gt;name_index()) &amp;&amp;
1793               signature == cp-&gt;symbol_at(f-&gt;signature_index())) {
1794             // Symbol is desclared in Java so skip this one
1795             duplicate = true;
1796             break;
1797           }
1798         }
1799         if (duplicate) {
1800           // These will be removed from the field array at the end
1801           continue;
1802         }
1803       }
1804 
1805       // Injected field
1806       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1807       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1808                         injected[n].name_index,
1809                         injected[n].signature_index,
1810                         0);
1811 
1812       const BasicType type = Signature::basic_type(injected[n].signature());
1813 
1814       // Remember how many oops we encountered and compute allocation type
1815       const FieldAllocationType atype = fac-&gt;update(false, type, false);
1816       field-&gt;set_allocation_type(atype);
1817       index++;
1818     }
1819   }
1820 
1821   if (is_inline_type) {
1822     FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1823     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,
1824                       vmSymbols::default_value_name_enum,
1825                       vmSymbols::object_signature_enum,
1826                       0);
1827     const BasicType type = Signature::basic_type(vmSymbols::object_signature());
1828     const FieldAllocationType atype = fac-&gt;update(true, type, false);
1829     field-&gt;set_allocation_type(atype);
1830     index++;
1831   }
1832 
1833   if (is_inline_type &amp;&amp; instance_fields_count == 0) {
1834     _is_empty_inline_type = true;
1835     FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1836     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1837         vmSymbols::empty_marker_name_enum,
1838         vmSymbols::byte_signature_enum,
1839         0);
1840     const BasicType type = Signature::basic_type(vmSymbols::byte_signature());
1841     const FieldAllocationType atype = fac-&gt;update(false, type, false);
1842     field-&gt;set_allocation_type(atype);
1843     index++;
1844   }
1845 
1846   if (instance_fields_count &gt; 0) {
1847     _has_nonstatic_fields = true;
1848   }
1849 
1850   assert(NULL == _fields, &quot;invariant&quot;);
1851 
1852   _fields =
1853     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1854                                    index * FieldInfo::field_slots + num_generic_signature,
1855                                    CHECK);
1856   // Sometimes injected fields already exist in the Java source so
1857   // the fields array could be too long.  In that case the
1858   // fields array is trimed. Also unused slots that were reserved
1859   // for generic signature indexes are discarded.
1860   {
1861     int i = 0;
1862     for (; i &lt; index * FieldInfo::field_slots; i++) {
1863       _fields-&gt;at_put(i, fa[i]);
1864     }
1865     for (int j = total_fields * FieldInfo::field_slots;
1866          j &lt; generic_signature_slot; j++) {
1867       _fields-&gt;at_put(i++, fa[j]);
1868     }
1869     assert(_fields-&gt;length() == i, &quot;&quot;);
1870   }
1871 
1872   if (_need_verify &amp;&amp; length &gt; 1) {
1873     // Check duplicated fields
1874     ResourceMark rm(THREAD);
1875     NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
1876       THREAD, NameSigHash*, HASH_ROW_SIZE);
1877     initialize_hashtable(names_and_sigs);
1878     bool dup = false;
1879     const Symbol* name = NULL;
1880     const Symbol* sig = NULL;
1881     {
1882       debug_only(NoSafepointVerifier nsv;)
1883       for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
1884         name = fs.name();
1885         sig = fs.signature();
1886         // If no duplicates, add name/signature in hashtable names_and_sigs.
1887         if (!put_after_lookup(name, sig, names_and_sigs)) {
1888           dup = true;
1889           break;
1890         }
1891       }
1892     }
1893     if (dup) {
1894       classfile_parse_error(&quot;Duplicate field name \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s&quot;,
1895                              name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);
1896     }
1897   }
1898 }
1899 
1900 
1901 const ClassFileParser::unsafe_u2* ClassFileParser::parse_exception_table(const ClassFileStream* const cfs,
1902                                                                          u4 code_length,
1903                                                                          u4 exception_table_length,
1904                                                                          TRAPS) {
1905   assert(cfs != NULL, &quot;invariant&quot;);
1906 
1907   const unsafe_u2* const exception_table_start = cfs-&gt;current();
1908   assert(exception_table_start != NULL, &quot;null exception table&quot;);
1909 
1910   cfs-&gt;guarantee_more(8 * exception_table_length, CHECK_NULL); // start_pc,
1911                                                                // end_pc,
1912                                                                // handler_pc,
1913                                                                // catch_type_index
1914 
1915   // Will check legal target after parsing code array in verifier.
1916   if (_need_verify) {
1917     for (unsigned int i = 0; i &lt; exception_table_length; i++) {
1918       const u2 start_pc = cfs-&gt;get_u2_fast();
1919       const u2 end_pc = cfs-&gt;get_u2_fast();
1920       const u2 handler_pc = cfs-&gt;get_u2_fast();
1921       const u2 catch_type_index = cfs-&gt;get_u2_fast();
1922       guarantee_property((start_pc &lt; end_pc) &amp;&amp; (end_pc &lt;= code_length),
1923                          &quot;Illegal exception table range in class file %s&quot;,
1924                          CHECK_NULL);
1925       guarantee_property(handler_pc &lt; code_length,
1926                          &quot;Illegal exception table handler in class file %s&quot;,
1927                          CHECK_NULL);
1928       if (catch_type_index != 0) {
1929         guarantee_property(valid_klass_reference_at(catch_type_index),
1930                            &quot;Catch type in exception table has bad constant type in class file %s&quot;, CHECK_NULL);
1931       }
1932     }
1933   } else {
1934     cfs-&gt;skip_u2_fast(exception_table_length * 4);
1935   }
1936   return exception_table_start;
1937 }
1938 
1939 void ClassFileParser::parse_linenumber_table(u4 code_attribute_length,
1940                                              u4 code_length,
1941                                              CompressedLineNumberWriteStream**const write_stream,
1942                                              TRAPS) {
1943 
1944   const ClassFileStream* const cfs = _stream;
1945   unsigned int num_entries = cfs-&gt;get_u2(CHECK);
1946 
1947   // Each entry is a u2 start_pc, and a u2 line_number
1948   const unsigned int length_in_bytes = num_entries * (sizeof(u2) * 2);
1949 
1950   // Verify line number attribute and table length
1951   check_property(
1952     code_attribute_length == sizeof(u2) + length_in_bytes,
1953     &quot;LineNumberTable attribute has wrong length in class file %s&quot;, CHECK);
1954 
1955   cfs-&gt;guarantee_more(length_in_bytes, CHECK);
1956 
1957   if ((*write_stream) == NULL) {
1958     if (length_in_bytes &gt; fixed_buffer_size) {
1959       (*write_stream) = new CompressedLineNumberWriteStream(length_in_bytes);
1960     } else {
1961       (*write_stream) = new CompressedLineNumberWriteStream(
1962         _linenumbertable_buffer, fixed_buffer_size);
1963     }
1964   }
1965 
1966   while (num_entries-- &gt; 0) {
1967     const u2 bci  = cfs-&gt;get_u2_fast(); // start_pc
1968     const u2 line = cfs-&gt;get_u2_fast(); // line_number
1969     guarantee_property(bci &lt; code_length,
1970         &quot;Invalid pc in LineNumberTable in class file %s&quot;, CHECK);
1971     (*write_stream)-&gt;write_pair(bci, line);
1972   }
1973 }
1974 
1975 
1976 class LVT_Hash : public AllStatic {
1977  public:
1978 
1979   static bool equals(LocalVariableTableElement const&amp; e0, LocalVariableTableElement const&amp; e1) {
1980   /*
1981    * 3-tuple start_bci/length/slot has to be unique key,
1982    * so the following comparison seems to be redundant:
1983    *       &amp;&amp; elem-&gt;name_cp_index == entry-&gt;_elem-&gt;name_cp_index
1984    */
1985     return (e0.start_bci     == e1.start_bci &amp;&amp;
1986             e0.length        == e1.length &amp;&amp;
1987             e0.name_cp_index == e1.name_cp_index &amp;&amp;
1988             e0.slot          == e1.slot);
1989   }
1990 
1991   static unsigned int hash(LocalVariableTableElement const&amp; e0) {
1992     unsigned int raw_hash = e0.start_bci;
1993 
1994     raw_hash = e0.length        + raw_hash * 37;
1995     raw_hash = e0.name_cp_index + raw_hash * 37;
1996     raw_hash = e0.slot          + raw_hash * 37;
1997 
1998     return raw_hash;
1999   }
2000 };
2001 
2002 
2003 // Class file LocalVariableTable elements.
2004 class Classfile_LVT_Element {
2005  public:
2006   u2 start_bci;
2007   u2 length;
2008   u2 name_cp_index;
2009   u2 descriptor_cp_index;
2010   u2 slot;
2011 };
2012 
2013 static void copy_lvt_element(const Classfile_LVT_Element* const src,
2014                              LocalVariableTableElement* const lvt) {
2015   lvt-&gt;start_bci           = Bytes::get_Java_u2((u1*) &amp;src-&gt;start_bci);
2016   lvt-&gt;length              = Bytes::get_Java_u2((u1*) &amp;src-&gt;length);
2017   lvt-&gt;name_cp_index       = Bytes::get_Java_u2((u1*) &amp;src-&gt;name_cp_index);
2018   lvt-&gt;descriptor_cp_index = Bytes::get_Java_u2((u1*) &amp;src-&gt;descriptor_cp_index);
2019   lvt-&gt;signature_cp_index  = 0;
2020   lvt-&gt;slot                = Bytes::get_Java_u2((u1*) &amp;src-&gt;slot);
2021 }
2022 
2023 // Function is used to parse both attributes:
2024 // LocalVariableTable (LVT) and LocalVariableTypeTable (LVTT)
2025 const ClassFileParser::unsafe_u2* ClassFileParser::parse_localvariable_table(const ClassFileStream* cfs,
2026                                                                              u4 code_length,
2027                                                                              u2 max_locals,
2028                                                                              u4 code_attribute_length,
2029                                                                              u2* const localvariable_table_length,
2030                                                                              bool isLVTT,
2031                                                                              TRAPS) {
2032   const char* const tbl_name = (isLVTT) ? &quot;LocalVariableTypeTable&quot; : &quot;LocalVariableTable&quot;;
2033   *localvariable_table_length = cfs-&gt;get_u2(CHECK_NULL);
2034   const unsigned int size =
2035     (*localvariable_table_length) * sizeof(Classfile_LVT_Element) / sizeof(u2);
2036 
2037   const ConstantPool* const cp = _cp;
2038 
2039   // Verify local variable table attribute has right length
2040   if (_need_verify) {
2041     guarantee_property(code_attribute_length == (sizeof(*localvariable_table_length) + size * sizeof(u2)),
2042                        &quot;%s has wrong length in class file %s&quot;, tbl_name, CHECK_NULL);
2043   }
2044 
2045   const unsafe_u2* const localvariable_table_start = cfs-&gt;current();
2046   assert(localvariable_table_start != NULL, &quot;null local variable table&quot;);
2047   if (!_need_verify) {
2048     cfs-&gt;skip_u2_fast(size);
2049   } else {
2050     cfs-&gt;guarantee_more(size * 2, CHECK_NULL);
2051     for(int i = 0; i &lt; (*localvariable_table_length); i++) {
2052       const u2 start_pc = cfs-&gt;get_u2_fast();
2053       const u2 length = cfs-&gt;get_u2_fast();
2054       const u2 name_index = cfs-&gt;get_u2_fast();
2055       const u2 descriptor_index = cfs-&gt;get_u2_fast();
2056       const u2 index = cfs-&gt;get_u2_fast();
2057       // Assign to a u4 to avoid overflow
2058       const u4 end_pc = (u4)start_pc + (u4)length;
2059 
2060       if (start_pc &gt;= code_length) {
2061         classfile_parse_error(
2062           &quot;Invalid start_pc %u in %s in class file %s&quot;,
2063           start_pc, tbl_name, CHECK_NULL);
2064       }
2065       if (end_pc &gt; code_length) {
2066         classfile_parse_error(
2067           &quot;Invalid length %u in %s in class file %s&quot;,
2068           length, tbl_name, CHECK_NULL);
2069       }
2070       const int cp_size = cp-&gt;length();
2071       guarantee_property(valid_symbol_at(name_index),
2072         &quot;Name index %u in %s has bad constant type in class file %s&quot;,
2073         name_index, tbl_name, CHECK_NULL);
2074       guarantee_property(valid_symbol_at(descriptor_index),
2075         &quot;Signature index %u in %s has bad constant type in class file %s&quot;,
2076         descriptor_index, tbl_name, CHECK_NULL);
2077 
2078       const Symbol* const name = cp-&gt;symbol_at(name_index);
2079       const Symbol* const sig = cp-&gt;symbol_at(descriptor_index);
2080       verify_legal_field_name(name, CHECK_NULL);
2081       u2 extra_slot = 0;
2082       if (!isLVTT) {
2083         verify_legal_field_signature(name, sig, CHECK_NULL);
2084 
2085         // 4894874: check special cases for double and long local variables
2086         if (sig == vmSymbols::type_signature(T_DOUBLE) ||
2087             sig == vmSymbols::type_signature(T_LONG)) {
2088           extra_slot = 1;
2089         }
2090       }
2091       guarantee_property((index + extra_slot) &lt; max_locals,
2092                           &quot;Invalid index %u in %s in class file %s&quot;,
2093                           index, tbl_name, CHECK_NULL);
2094     }
2095   }
2096   return localvariable_table_start;
2097 }
2098 
2099 static const u1* parse_stackmap_table(const ClassFileStream* const cfs,
2100                                       u4 code_attribute_length,
2101                                       bool need_verify,
2102                                       TRAPS) {
2103   assert(cfs != NULL, &quot;invariant&quot;);
2104 
2105   if (0 == code_attribute_length) {
2106     return NULL;
2107   }
2108 
2109   const u1* const stackmap_table_start = cfs-&gt;current();
2110   assert(stackmap_table_start != NULL, &quot;null stackmap table&quot;);
2111 
2112   // check code_attribute_length first
2113   cfs-&gt;skip_u1(code_attribute_length, CHECK_NULL);
2114 
2115   if (!need_verify &amp;&amp; !DumpSharedSpaces) {
2116     return NULL;
2117   }
2118   return stackmap_table_start;
2119 }
2120 
2121 const ClassFileParser::unsafe_u2* ClassFileParser::parse_checked_exceptions(const ClassFileStream* const cfs,
2122                                                                             u2* const checked_exceptions_length,
2123                                                                             u4 method_attribute_length,
2124                                                                             TRAPS) {
2125   assert(cfs != NULL, &quot;invariant&quot;);
2126   assert(checked_exceptions_length != NULL, &quot;invariant&quot;);
2127 
2128   cfs-&gt;guarantee_more(2, CHECK_NULL);  // checked_exceptions_length
2129   *checked_exceptions_length = cfs-&gt;get_u2_fast();
2130   const unsigned int size =
2131     (*checked_exceptions_length) * sizeof(CheckedExceptionElement) / sizeof(u2);
2132   const unsafe_u2* const checked_exceptions_start = cfs-&gt;current();
2133   assert(checked_exceptions_start != NULL, &quot;null checked exceptions&quot;);
2134   if (!_need_verify) {
2135     cfs-&gt;skip_u2_fast(size);
2136   } else {
2137     // Verify each value in the checked exception table
2138     u2 checked_exception;
2139     const u2 len = *checked_exceptions_length;
2140     cfs-&gt;guarantee_more(2 * len, CHECK_NULL);
2141     for (int i = 0; i &lt; len; i++) {
2142       checked_exception = cfs-&gt;get_u2_fast();
2143       check_property(
2144         valid_klass_reference_at(checked_exception),
2145         &quot;Exception name has bad type at constant pool %u in class file %s&quot;,
2146         checked_exception, CHECK_NULL);
2147     }
2148   }
2149   // check exceptions attribute length
2150   if (_need_verify) {
2151     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2152                                                    sizeof(u2) * size),
2153                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2154   }
2155   return checked_exceptions_start;
2156 }
2157 
2158 void ClassFileParser::throwIllegalSignature(const char* type,
2159                                             const Symbol* name,
2160                                             const Symbol* sig,
2161                                             TRAPS) const {
2162   assert(name != NULL, &quot;invariant&quot;);
2163   assert(sig != NULL, &quot;invariant&quot;);
2164 
2165   const char* class_note = &quot;&quot;;
2166   if (is_inline_type() &amp;&amp; name == vmSymbols::object_initializer_name()) {
2167     class_note = &quot; (an inline class)&quot;;
2168   }
2169 
2170   ResourceMark rm(THREAD);
2171   Exceptions::fthrow(THREAD_AND_LOCATION,
2172       vmSymbols::java_lang_ClassFormatError(),
2173       &quot;%s \&quot;%s\&quot; in class %s%s has illegal signature \&quot;%s\&quot;&quot;, type,
2174       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, sig-&gt;as_C_string());
2175 }
2176 
2177 AnnotationCollector::ID
2178 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2179                                       const Symbol* name,
2180                                       const bool can_access_vm_annotations) {
2181   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2182   // Privileged code can use all annotations.  Other code silently drops some.
2183   const bool privileged = loader_data-&gt;is_boot_class_loader_data() ||
2184                           loader_data-&gt;is_platform_class_loader_data() ||
2185                           can_access_vm_annotations;
2186   switch (sid) {
2187     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2188       if (_location != _in_method)  break;  // only allow for methods
2189       if (!privileged)              break;  // only allow in privileged code
2190       return _method_CallerSensitive;
2191     }
2192     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2193       if (_location != _in_method)  break;  // only allow for methods
2194       if (!privileged)              break;  // only allow in privileged code
2195       return _method_ForceInline;
2196     }
2197     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_DontInline_signature): {
2198       if (_location != _in_method)  break;  // only allow for methods
2199       if (!privileged)              break;  // only allow in privileged code
2200       return _method_DontInline;
2201     }
2202     case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_InjectedProfile_signature): {
2203       if (_location != _in_method)  break;  // only allow for methods
2204       if (!privileged)              break;  // only allow in privileged code
2205       return _method_InjectedProfile;
2206     }
2207     case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_LambdaForm_Compiled_signature): {
2208       if (_location != _in_method)  break;  // only allow for methods
2209       if (!privileged)              break;  // only allow in privileged code
2210       return _method_LambdaForm_Compiled;
2211     }
2212     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Hidden_signature): {
2213       if (_location != _in_method)  break;  // only allow for methods
2214       if (!privileged)              break;  // only allow in privileged code
2215       return _method_Hidden;
2216     }
2217     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_HotSpotIntrinsicCandidate_signature): {
2218       if (_location != _in_method)  break;  // only allow for methods
2219       if (!privileged)              break;  // only allow in privileged code
2220       return _method_HotSpotIntrinsicCandidate;
2221     }
2222     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Stable_signature): {
2223       if (_location != _in_field)   break;  // only allow for fields
2224       if (!privileged)              break;  // only allow in privileged code
2225       return _field_Stable;
2226     }
2227     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Contended_signature): {
2228       if (_location != _in_field &amp;&amp; _location != _in_class) {
2229         break;  // only allow for fields and classes
2230       }
2231       if (!EnableContended || (RestrictContended &amp;&amp; !privileged)) {
2232         break;  // honor privileges
2233       }
2234       return _jdk_internal_vm_annotation_Contended;
2235     }
2236     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ReservedStackAccess_signature): {
2237       if (_location != _in_method)  break;  // only allow for methods
2238       if (RestrictReservedStack &amp;&amp; !privileged) break; // honor privileges
2239       return _jdk_internal_vm_annotation_ReservedStackAccess;
2240     }
2241     default: {
2242       break;
2243     }
2244   }
2245   return AnnotationCollector::_unknown;
2246 }
2247 
2248 void ClassFileParser::FieldAnnotationCollector::apply_to(FieldInfo* f) {
2249   if (is_contended())
2250     f-&gt;set_contended_group(contended_group());
2251   if (is_stable())
2252     f-&gt;set_stable(true);
2253 }
2254 
2255 ClassFileParser::FieldAnnotationCollector::~FieldAnnotationCollector() {
2256   // If there&#39;s an error deallocate metadata for field annotations
2257   MetadataFactory::free_array&lt;u1&gt;(_loader_data, _field_annotations);
2258   MetadataFactory::free_array&lt;u1&gt;(_loader_data, _field_type_annotations);
2259 }
2260 
2261 void MethodAnnotationCollector::apply_to(const methodHandle&amp; m) {
2262   if (has_annotation(_method_CallerSensitive))
2263     m-&gt;set_caller_sensitive(true);
2264   if (has_annotation(_method_ForceInline))
2265     m-&gt;set_force_inline(true);
2266   if (has_annotation(_method_DontInline))
2267     m-&gt;set_dont_inline(true);
2268   if (has_annotation(_method_InjectedProfile))
2269     m-&gt;set_has_injected_profile(true);
2270   if (has_annotation(_method_LambdaForm_Compiled) &amp;&amp; m-&gt;intrinsic_id() == vmIntrinsics::_none)
2271     m-&gt;set_intrinsic_id(vmIntrinsics::_compiledLambdaForm);
2272   if (has_annotation(_method_Hidden))
2273     m-&gt;set_hidden(true);
2274   if (has_annotation(_method_HotSpotIntrinsicCandidate) &amp;&amp; !m-&gt;is_synthetic())
2275     m-&gt;set_intrinsic_candidate(true);
2276   if (has_annotation(_jdk_internal_vm_annotation_ReservedStackAccess))
2277     m-&gt;set_has_reserved_stack_access(true);
2278 }
2279 
2280 void ClassFileParser::ClassAnnotationCollector::apply_to(InstanceKlass* ik) {
2281   assert(ik != NULL, &quot;invariant&quot;);
2282   ik-&gt;set_is_contended(is_contended());
2283 }
2284 
2285 #define MAX_ARGS_SIZE 255
2286 #define MAX_CODE_SIZE 65535
2287 #define INITIAL_MAX_LVT_NUMBER 256
2288 
2289 /* Copy class file LVT&#39;s/LVTT&#39;s into the HotSpot internal LVT.
2290  *
2291  * Rules for LVT&#39;s and LVTT&#39;s are:
2292  *   - There can be any number of LVT&#39;s and LVTT&#39;s.
2293  *   - If there are n LVT&#39;s, it is the same as if there was just
2294  *     one LVT containing all the entries from the n LVT&#39;s.
2295  *   - There may be no more than one LVT entry per local variable.
2296  *     Two LVT entries are &#39;equal&#39; if these fields are the same:
2297  *        start_pc, length, name, slot
2298  *   - There may be no more than one LVTT entry per each LVT entry.
2299  *     Each LVTT entry has to match some LVT entry.
2300  *   - HotSpot internal LVT keeps natural ordering of class file LVT entries.
2301  */
2302 void ClassFileParser::copy_localvariable_table(const ConstMethod* cm,
2303                                                int lvt_cnt,
2304                                                u2* const localvariable_table_length,
2305                                                const unsafe_u2** const localvariable_table_start,
2306                                                int lvtt_cnt,
2307                                                u2* const localvariable_type_table_length,
2308                                                const unsafe_u2** const localvariable_type_table_start,
2309                                                TRAPS) {
2310 
2311   ResourceMark rm(THREAD);
2312 
2313   typedef ResourceHashtable&lt;LocalVariableTableElement, LocalVariableTableElement*,
2314                             &amp;LVT_Hash::hash, &amp;LVT_Hash::equals&gt; LVT_HashTable;
2315 
2316   LVT_HashTable* const table = new LVT_HashTable();
2317 
2318   // To fill LocalVariableTable in
2319   const Classfile_LVT_Element* cf_lvt;
2320   LocalVariableTableElement* lvt = cm-&gt;localvariable_table_start();
2321 
2322   for (int tbl_no = 0; tbl_no &lt; lvt_cnt; tbl_no++) {
2323     cf_lvt = (Classfile_LVT_Element *) localvariable_table_start[tbl_no];
2324     for (int idx = 0; idx &lt; localvariable_table_length[tbl_no]; idx++, lvt++) {
2325       copy_lvt_element(&amp;cf_lvt[idx], lvt);
2326       // If no duplicates, add LVT elem in hashtable.
2327       if (table-&gt;put(*lvt, lvt) == false
2328           &amp;&amp; _need_verify
2329           &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
2330         classfile_parse_error(&quot;Duplicated LocalVariableTable attribute &quot;
2331                               &quot;entry for &#39;%s&#39; in class file %s&quot;,
2332                                _cp-&gt;symbol_at(lvt-&gt;name_cp_index)-&gt;as_utf8(),
2333                                CHECK);
2334       }
2335     }
2336   }
2337 
2338   // To merge LocalVariableTable and LocalVariableTypeTable
2339   const Classfile_LVT_Element* cf_lvtt;
2340   LocalVariableTableElement lvtt_elem;
2341 
2342   for (int tbl_no = 0; tbl_no &lt; lvtt_cnt; tbl_no++) {
2343     cf_lvtt = (Classfile_LVT_Element *) localvariable_type_table_start[tbl_no];
2344     for (int idx = 0; idx &lt; localvariable_type_table_length[tbl_no]; idx++) {
2345       copy_lvt_element(&amp;cf_lvtt[idx], &amp;lvtt_elem);
2346       LocalVariableTableElement** entry = table-&gt;get(lvtt_elem);
2347       if (entry == NULL) {
2348         if (_need_verify) {
2349           classfile_parse_error(&quot;LVTT entry for &#39;%s&#39; in class file %s &quot;
2350                                 &quot;does not match any LVT entry&quot;,
2351                                  _cp-&gt;symbol_at(lvtt_elem.name_cp_index)-&gt;as_utf8(),
2352                                  CHECK);
2353         }
2354       } else if ((*entry)-&gt;signature_cp_index != 0 &amp;&amp; _need_verify) {
2355         classfile_parse_error(&quot;Duplicated LocalVariableTypeTable attribute &quot;
2356                               &quot;entry for &#39;%s&#39; in class file %s&quot;,
2357                                _cp-&gt;symbol_at(lvtt_elem.name_cp_index)-&gt;as_utf8(),
2358                                CHECK);
2359       } else {
2360         // to add generic signatures into LocalVariableTable
2361         (*entry)-&gt;signature_cp_index = lvtt_elem.descriptor_cp_index;
2362       }
2363     }
2364   }
2365 }
2366 
2367 
2368 void ClassFileParser::copy_method_annotations(ConstMethod* cm,
2369                                        const u1* runtime_visible_annotations,
2370                                        int runtime_visible_annotations_length,
2371                                        const u1* runtime_invisible_annotations,
2372                                        int runtime_invisible_annotations_length,
2373                                        const u1* runtime_visible_parameter_annotations,
2374                                        int runtime_visible_parameter_annotations_length,
2375                                        const u1* runtime_invisible_parameter_annotations,
2376                                        int runtime_invisible_parameter_annotations_length,
2377                                        const u1* runtime_visible_type_annotations,
2378                                        int runtime_visible_type_annotations_length,
2379                                        const u1* runtime_invisible_type_annotations,
2380                                        int runtime_invisible_type_annotations_length,
2381                                        const u1* annotation_default,
2382                                        int annotation_default_length,
2383                                        TRAPS) {
2384 
2385   AnnotationArray* a;
2386 
2387   if (runtime_visible_annotations_length +
2388       runtime_invisible_annotations_length &gt; 0) {
2389      a = assemble_annotations(runtime_visible_annotations,
2390                               runtime_visible_annotations_length,
2391                               runtime_invisible_annotations,
2392                               runtime_invisible_annotations_length,
2393                               CHECK);
2394      cm-&gt;set_method_annotations(a);
2395   }
2396 
2397   if (runtime_visible_parameter_annotations_length +
2398       runtime_invisible_parameter_annotations_length &gt; 0) {
2399     a = assemble_annotations(runtime_visible_parameter_annotations,
2400                              runtime_visible_parameter_annotations_length,
2401                              runtime_invisible_parameter_annotations,
2402                              runtime_invisible_parameter_annotations_length,
2403                              CHECK);
2404     cm-&gt;set_parameter_annotations(a);
2405   }
2406 
2407   if (annotation_default_length &gt; 0) {
2408     a = assemble_annotations(annotation_default,
2409                              annotation_default_length,
2410                              NULL,
2411                              0,
2412                              CHECK);
2413     cm-&gt;set_default_annotations(a);
2414   }
2415 
2416   if (runtime_visible_type_annotations_length +
2417       runtime_invisible_type_annotations_length &gt; 0) {
2418     a = assemble_annotations(runtime_visible_type_annotations,
2419                              runtime_visible_type_annotations_length,
2420                              runtime_invisible_type_annotations,
2421                              runtime_invisible_type_annotations_length,
2422                              CHECK);
2423     cm-&gt;set_type_annotations(a);
2424   }
2425 }
2426 
2427 
2428 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2429 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2430 // Method* to save footprint, so we only know the size of the resulting Method* when the
2431 // entire method attribute is parsed.
2432 //
2433 // The promoted_flags parameter is used to pass relevant access_flags
2434 // from the method back up to the containing klass. These flag values
2435 // are added to klass&#39;s access_flags.
2436 
2437 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2438                                       bool is_interface,
2439                                       bool is_inline_type,
2440                                       const ConstantPool* cp,
2441                                       AccessFlags* const promoted_flags,
2442                                       TRAPS) {
2443   assert(cfs != NULL, &quot;invariant&quot;);
2444   assert(cp != NULL, &quot;invariant&quot;);
2445   assert(promoted_flags != NULL, &quot;invariant&quot;);
2446 
2447   ResourceMark rm(THREAD);
2448   // Parse fixed parts:
2449   // access_flags, name_index, descriptor_index, attributes_count
2450   cfs-&gt;guarantee_more(8, CHECK_NULL);
2451 
2452   int flags = cfs-&gt;get_u2_fast();
2453   const u2 name_index = cfs-&gt;get_u2_fast();
2454   const int cp_size = cp-&gt;length();
2455   check_property(
2456     valid_symbol_at(name_index),
2457     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2458     name_index, CHECK_NULL);
2459   const Symbol* const name = cp-&gt;symbol_at(name_index);
2460   verify_legal_method_name(name, CHECK_NULL);
2461 
2462   const u2 signature_index = cfs-&gt;get_u2_fast();
2463   guarantee_property(
2464     valid_symbol_at(signature_index),
2465     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2466     signature_index, CHECK_NULL);
2467   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2468 
2469   if (name == vmSymbols::class_initializer_name()) {
2470     // We ignore the other access flags for a valid class initializer.
2471     // (JVM Spec 2nd ed., chapter 4.6)
2472     if (_major_version &lt; 51) { // backward compatibility
2473       flags = JVM_ACC_STATIC;
2474     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2475       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2476     } else {
2477       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2478     }
2479   } else {
2480     verify_legal_method_modifiers(flags, is_interface, is_inline_type, name, CHECK_NULL);
2481   }
2482 
2483   if (name == vmSymbols::object_initializer_name()) {
2484     if (is_interface) {
2485       classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);
2486     } else if (!is_inline_type &amp;&amp; signature-&gt;is_void_method_signature()) {
2487       // OK, a constructor
2488     } else if (is_inline_type &amp;&amp; !signature-&gt;is_void_method_signature()) {
2489       // also OK, a static factory, as long as the return value is good
2490       bool ok = false;
2491       SignatureStream ss((Symbol*) signature, true);
2492       while (!ss.at_return_type())  ss.next();
2493       if (ss.is_reference()) {
2494         Symbol* ret = ss.as_symbol();
2495         const Symbol* required = class_name();
2496         if (is_unsafe_anonymous()) {
2497           // The original class name in the UAC byte stream gets changed.  So
2498           // using the original name in the return type is no longer valid.
2499           required = vmSymbols::java_lang_Object();
2500         }
2501         ok = (ret == required);
2502       }
2503       if (!ok) {
2504         throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
2505       }
2506     } else {
2507       // not OK, so throw the same error as in verify_legal_method_signature.
2508       throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
2509     }
2510     // A declared &lt;init&gt; method must always be either a non-static
2511     // object constructor, with a void return, or else it must be a
2512     // static factory method, with a non-void return.  No other
2513     // definition of &lt;init&gt; is possible.
2514     //
2515     // The verifier (in verify_invoke_instructions) will inspect the
2516     // signature of any attempt to invoke &lt;init&gt;, and ensures that it
2517     // returns non-void if and only if it is being invoked by
2518     // invokestatic, and void if and only if it is being invoked by
2519     // invokespecial.
2520     //
2521     // When a symbolic reference to &lt;init&gt; is resolved for a
2522     // particular invocation mode (special or static), the mode is
2523     // matched to the JVM_ACC_STATIC modifier of the &lt;init&gt; method.
2524     // Thus, it is impossible to statically invoke a constructor, and
2525     // impossible to &quot;new + invokespecial&quot; a static factory, either
2526     // through bytecode or through reflection.
2527   }
2528 
2529   int args_size = -1;  // only used when _need_verify is true
2530   if (_need_verify) {
2531     args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
2532                  verify_legal_method_signature(name, signature, CHECK_NULL);
2533     if (args_size &gt; MAX_ARGS_SIZE) {
2534       classfile_parse_error(&quot;Too many arguments in method signature in class file %s&quot;, CHECK_NULL);
2535     }
2536   }
2537 
2538   AccessFlags access_flags(flags &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
2539 
2540   // Default values for code and exceptions attribute elements
2541   u2 max_stack = 0;
2542   u2 max_locals = 0;
2543   u4 code_length = 0;
2544   const u1* code_start = 0;
2545   u2 exception_table_length = 0;
2546   const unsafe_u2* exception_table_start = NULL; // (potentially unaligned) pointer to array of u2 elements
2547   Array&lt;int&gt;* exception_handlers = Universe::the_empty_int_array();
2548   u2 checked_exceptions_length = 0;
2549   const unsafe_u2* checked_exceptions_start = NULL; // (potentially unaligned) pointer to array of u2 elements
2550   CompressedLineNumberWriteStream* linenumber_table = NULL;
2551   int linenumber_table_length = 0;
2552   int total_lvt_length = 0;
2553   u2 lvt_cnt = 0;
2554   u2 lvtt_cnt = 0;
2555   bool lvt_allocated = false;
2556   u2 max_lvt_cnt = INITIAL_MAX_LVT_NUMBER;
2557   u2 max_lvtt_cnt = INITIAL_MAX_LVT_NUMBER;
2558   u2* localvariable_table_length = NULL;
2559   const unsafe_u2** localvariable_table_start = NULL; // (potentially unaligned) pointer to array of LVT attributes
2560   u2* localvariable_type_table_length = NULL;
2561   const unsafe_u2** localvariable_type_table_start = NULL; // (potentially unaligned) pointer to LVTT attributes
2562   int method_parameters_length = -1;
2563   const u1* method_parameters_data = NULL;
2564   bool method_parameters_seen = false;
2565   bool parsed_code_attribute = false;
2566   bool parsed_checked_exceptions_attribute = false;
2567   bool parsed_stackmap_attribute = false;
2568   // stackmap attribute - JDK1.5
2569   const u1* stackmap_data = NULL;
2570   int stackmap_data_length = 0;
2571   u2 generic_signature_index = 0;
2572   MethodAnnotationCollector parsed_annotations;
2573   const u1* runtime_visible_annotations = NULL;
2574   int runtime_visible_annotations_length = 0;
2575   const u1* runtime_invisible_annotations = NULL;
2576   int runtime_invisible_annotations_length = 0;
2577   const u1* runtime_visible_parameter_annotations = NULL;
2578   int runtime_visible_parameter_annotations_length = 0;
2579   const u1* runtime_invisible_parameter_annotations = NULL;
2580   int runtime_invisible_parameter_annotations_length = 0;
2581   const u1* runtime_visible_type_annotations = NULL;
2582   int runtime_visible_type_annotations_length = 0;
2583   const u1* runtime_invisible_type_annotations = NULL;
2584   int runtime_invisible_type_annotations_length = 0;
2585   bool runtime_invisible_annotations_exists = false;
2586   bool runtime_invisible_type_annotations_exists = false;
2587   bool runtime_invisible_parameter_annotations_exists = false;
2588   const u1* annotation_default = NULL;
2589   int annotation_default_length = 0;
2590 
2591   // Parse code and exceptions attribute
2592   u2 method_attributes_count = cfs-&gt;get_u2_fast();
2593   while (method_attributes_count--) {
2594     cfs-&gt;guarantee_more(6, CHECK_NULL);  // method_attribute_name_index, method_attribute_length
2595     const u2 method_attribute_name_index = cfs-&gt;get_u2_fast();
2596     const u4 method_attribute_length = cfs-&gt;get_u4_fast();
2597     check_property(
2598       valid_symbol_at(method_attribute_name_index),
2599       &quot;Invalid method attribute name index %u in class file %s&quot;,
2600       method_attribute_name_index, CHECK_NULL);
2601 
2602     const Symbol* const method_attribute_name = cp-&gt;symbol_at(method_attribute_name_index);
2603     if (method_attribute_name == vmSymbols::tag_code()) {
2604       // Parse Code attribute
2605       if (_need_verify) {
2606         guarantee_property(
2607             !access_flags.is_native() &amp;&amp; !access_flags.is_abstract(),
2608                         &quot;Code attribute in native or abstract methods in class file %s&quot;,
2609                          CHECK_NULL);
2610       }
2611       if (parsed_code_attribute) {
2612         classfile_parse_error(&quot;Multiple Code attributes in class file %s&quot;,
2613                               CHECK_NULL);
2614       }
2615       parsed_code_attribute = true;
2616 
2617       // Stack size, locals size, and code size
2618       cfs-&gt;guarantee_more(8, CHECK_NULL);
2619       max_stack = cfs-&gt;get_u2_fast();
2620       max_locals = cfs-&gt;get_u2_fast();
2621       code_length = cfs-&gt;get_u4_fast();
2622       if (_need_verify) {
2623         guarantee_property(args_size &lt;= max_locals,
2624                            &quot;Arguments can&#39;t fit into locals in class file %s&quot;,
2625                            CHECK_NULL);
2626         guarantee_property(code_length &gt; 0 &amp;&amp; code_length &lt;= MAX_CODE_SIZE,
2627                            &quot;Invalid method Code length %u in class file %s&quot;,
2628                            code_length, CHECK_NULL);
2629       }
2630       // Code pointer
2631       code_start = cfs-&gt;current();
2632       assert(code_start != NULL, &quot;null code start&quot;);
2633       cfs-&gt;guarantee_more(code_length, CHECK_NULL);
2634       cfs-&gt;skip_u1_fast(code_length);
2635 
2636       // Exception handler table
2637       cfs-&gt;guarantee_more(2, CHECK_NULL);  // exception_table_length
2638       exception_table_length = cfs-&gt;get_u2_fast();
2639       if (exception_table_length &gt; 0) {
2640         exception_table_start = parse_exception_table(cfs,
2641                                                       code_length,
2642                                                       exception_table_length,
2643                                                       CHECK_NULL);
2644       }
2645 
2646       // Parse additional attributes in code attribute
2647       cfs-&gt;guarantee_more(2, CHECK_NULL);  // code_attributes_count
2648       u2 code_attributes_count = cfs-&gt;get_u2_fast();
2649 
2650       unsigned int calculated_attribute_length = 0;
2651 
2652       calculated_attribute_length =
2653           sizeof(max_stack) + sizeof(max_locals) + sizeof(code_length);
2654       calculated_attribute_length +=
2655         code_length +
2656         sizeof(exception_table_length) +
2657         sizeof(code_attributes_count) +
2658         exception_table_length *
2659             ( sizeof(u2) +   // start_pc
2660               sizeof(u2) +   // end_pc
2661               sizeof(u2) +   // handler_pc
2662               sizeof(u2) );  // catch_type_index
2663 
2664       while (code_attributes_count--) {
2665         cfs-&gt;guarantee_more(6, CHECK_NULL);  // code_attribute_name_index, code_attribute_length
2666         const u2 code_attribute_name_index = cfs-&gt;get_u2_fast();
2667         const u4 code_attribute_length = cfs-&gt;get_u4_fast();
2668         calculated_attribute_length += code_attribute_length +
2669                                        sizeof(code_attribute_name_index) +
2670                                        sizeof(code_attribute_length);
2671         check_property(valid_symbol_at(code_attribute_name_index),
2672                        &quot;Invalid code attribute name index %u in class file %s&quot;,
2673                        code_attribute_name_index,
2674                        CHECK_NULL);
2675         if (LoadLineNumberTables &amp;&amp;
2676             cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_line_number_table()) {
2677           // Parse and compress line number table
2678           parse_linenumber_table(code_attribute_length,
2679                                  code_length,
2680                                  &amp;linenumber_table,
2681                                  CHECK_NULL);
2682 
2683         } else if (LoadLocalVariableTables &amp;&amp;
2684                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_local_variable_table()) {
2685           // Parse local variable table
2686           if (!lvt_allocated) {
2687             localvariable_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2688               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2689             localvariable_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2690               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2691             localvariable_type_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2692               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2693             localvariable_type_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2694               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2695             lvt_allocated = true;
2696           }
2697           if (lvt_cnt == max_lvt_cnt) {
2698             max_lvt_cnt &lt;&lt;= 1;
2699             localvariable_table_length = REALLOC_RESOURCE_ARRAY(u2, localvariable_table_length, lvt_cnt, max_lvt_cnt);
2700             localvariable_table_start  = REALLOC_RESOURCE_ARRAY(const unsafe_u2*, localvariable_table_start, lvt_cnt, max_lvt_cnt);
2701           }
2702           localvariable_table_start[lvt_cnt] =
2703             parse_localvariable_table(cfs,
2704                                       code_length,
2705                                       max_locals,
2706                                       code_attribute_length,
2707                                       &amp;localvariable_table_length[lvt_cnt],
2708                                       false,    // is not LVTT
2709                                       CHECK_NULL);
2710           total_lvt_length += localvariable_table_length[lvt_cnt];
2711           lvt_cnt++;
2712         } else if (LoadLocalVariableTypeTables &amp;&amp;
2713                    _major_version &gt;= JAVA_1_5_VERSION &amp;&amp;
2714                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_local_variable_type_table()) {
2715           if (!lvt_allocated) {
2716             localvariable_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2717               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2718             localvariable_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2719               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2720             localvariable_type_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2721               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2722             localvariable_type_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2723               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2724             lvt_allocated = true;
2725           }
2726           // Parse local variable type table
2727           if (lvtt_cnt == max_lvtt_cnt) {
2728             max_lvtt_cnt &lt;&lt;= 1;
2729             localvariable_type_table_length = REALLOC_RESOURCE_ARRAY(u2, localvariable_type_table_length, lvtt_cnt, max_lvtt_cnt);
2730             localvariable_type_table_start  = REALLOC_RESOURCE_ARRAY(const unsafe_u2*, localvariable_type_table_start, lvtt_cnt, max_lvtt_cnt);
2731           }
2732           localvariable_type_table_start[lvtt_cnt] =
2733             parse_localvariable_table(cfs,
2734                                       code_length,
2735                                       max_locals,
2736                                       code_attribute_length,
2737                                       &amp;localvariable_type_table_length[lvtt_cnt],
2738                                       true,     // is LVTT
2739                                       CHECK_NULL);
2740           lvtt_cnt++;
2741         } else if (_major_version &gt;= Verifier::STACKMAP_ATTRIBUTE_MAJOR_VERSION &amp;&amp;
2742                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_stack_map_table()) {
2743           // Stack map is only needed by the new verifier in JDK1.5.
2744           if (parsed_stackmap_attribute) {
2745             classfile_parse_error(&quot;Multiple StackMapTable attributes in class file %s&quot;, CHECK_NULL);
2746           }
2747           stackmap_data = parse_stackmap_table(cfs, code_attribute_length, _need_verify, CHECK_NULL);
2748           stackmap_data_length = code_attribute_length;
2749           parsed_stackmap_attribute = true;
2750         } else {
2751           // Skip unknown attributes
2752           cfs-&gt;skip_u1(code_attribute_length, CHECK_NULL);
2753         }
2754       }
2755       // check method attribute length
2756       if (_need_verify) {
2757         guarantee_property(method_attribute_length == calculated_attribute_length,
2758                            &quot;Code segment has wrong length in class file %s&quot;,
2759                            CHECK_NULL);
2760       }
2761     } else if (method_attribute_name == vmSymbols::tag_exceptions()) {
2762       // Parse Exceptions attribute
2763       if (parsed_checked_exceptions_attribute) {
2764         classfile_parse_error(&quot;Multiple Exceptions attributes in class file %s&quot;,
2765                               CHECK_NULL);
2766       }
2767       parsed_checked_exceptions_attribute = true;
2768       checked_exceptions_start =
2769             parse_checked_exceptions(cfs,
2770                                      &amp;checked_exceptions_length,
2771                                      method_attribute_length,
2772                                      CHECK_NULL);
2773     } else if (method_attribute_name == vmSymbols::tag_method_parameters()) {
2774       // reject multiple method parameters
2775       if (method_parameters_seen) {
2776         classfile_parse_error(&quot;Multiple MethodParameters attributes in class file %s&quot;,
2777                               CHECK_NULL);
2778       }
2779       method_parameters_seen = true;
2780       method_parameters_length = cfs-&gt;get_u1_fast();
2781       const u2 real_length = (method_parameters_length * 4u) + 1u;
2782       if (method_attribute_length != real_length) {
2783         classfile_parse_error(
2784           &quot;Invalid MethodParameters method attribute length %u in class file&quot;,
2785           method_attribute_length, CHECK_NULL);
2786       }
2787       method_parameters_data = cfs-&gt;current();
2788       cfs-&gt;skip_u2_fast(method_parameters_length);
2789       cfs-&gt;skip_u2_fast(method_parameters_length);
2790       // ignore this attribute if it cannot be reflected
2791       if (!SystemDictionary::Parameter_klass_loaded())
2792         method_parameters_length = -1;
2793     } else if (method_attribute_name == vmSymbols::tag_synthetic()) {
2794       if (method_attribute_length != 0) {
2795         classfile_parse_error(
2796           &quot;Invalid Synthetic method attribute length %u in class file %s&quot;,
2797           method_attribute_length, CHECK_NULL);
2798       }
2799       // Should we check that there hasn&#39;t already been a synthetic attribute?
2800       access_flags.set_is_synthetic();
2801     } else if (method_attribute_name == vmSymbols::tag_deprecated()) { // 4276120
2802       if (method_attribute_length != 0) {
2803         classfile_parse_error(
2804           &quot;Invalid Deprecated method attribute length %u in class file %s&quot;,
2805           method_attribute_length, CHECK_NULL);
2806       }
2807     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
2808       if (method_attribute_name == vmSymbols::tag_signature()) {
2809         if (generic_signature_index != 0) {
2810           classfile_parse_error(
2811             &quot;Multiple Signature attributes for method in class file %s&quot;,
2812             CHECK_NULL);
2813         }
2814         if (method_attribute_length != 2) {
2815           classfile_parse_error(
2816             &quot;Invalid Signature attribute length %u in class file %s&quot;,
2817             method_attribute_length, CHECK_NULL);
2818         }
2819         generic_signature_index = parse_generic_signature_attribute(cfs, CHECK_NULL);
2820       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
2821         if (runtime_visible_annotations != NULL) {
2822           classfile_parse_error(
2823             &quot;Multiple RuntimeVisibleAnnotations attributes for method in class file %s&quot;,
2824             CHECK_NULL);
2825         }
2826         runtime_visible_annotations_length = method_attribute_length;
2827         runtime_visible_annotations = cfs-&gt;current();
2828         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
2829         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK_NULL);
2830         parse_annotations(cp,
2831                           runtime_visible_annotations,
2832                           runtime_visible_annotations_length,
2833                           &amp;parsed_annotations,
2834                           _loader_data,
2835                           _can_access_vm_annotations,
2836                           CHECK_NULL);
2837         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
2838       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
2839         if (runtime_invisible_annotations_exists) {
2840           classfile_parse_error(
2841             &quot;Multiple RuntimeInvisibleAnnotations attributes for method in class file %s&quot;,
2842             CHECK_NULL);
2843         }
2844         runtime_invisible_annotations_exists = true;
2845         if (PreserveAllAnnotations) {
2846           runtime_invisible_annotations_length = method_attribute_length;
2847           runtime_invisible_annotations = cfs-&gt;current();
2848           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
2849         }
2850         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2851       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_parameter_annotations()) {
2852         if (runtime_visible_parameter_annotations != NULL) {
2853           classfile_parse_error(
2854             &quot;Multiple RuntimeVisibleParameterAnnotations attributes for method in class file %s&quot;,
2855             CHECK_NULL);
2856         }
2857         runtime_visible_parameter_annotations_length = method_attribute_length;
2858         runtime_visible_parameter_annotations = cfs-&gt;current();
2859         assert(runtime_visible_parameter_annotations != NULL, &quot;null visible parameter annotations&quot;);
2860         cfs-&gt;skip_u1(runtime_visible_parameter_annotations_length, CHECK_NULL);
2861       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_parameter_annotations()) {
2862         if (runtime_invisible_parameter_annotations_exists) {
2863           classfile_parse_error(
2864             &quot;Multiple RuntimeInvisibleParameterAnnotations attributes for method in class file %s&quot;,
2865             CHECK_NULL);
2866         }
2867         runtime_invisible_parameter_annotations_exists = true;
2868         if (PreserveAllAnnotations) {
2869           runtime_invisible_parameter_annotations_length = method_attribute_length;
2870           runtime_invisible_parameter_annotations = cfs-&gt;current();
2871           assert(runtime_invisible_parameter_annotations != NULL,
2872             &quot;null invisible parameter annotations&quot;);
2873         }
2874         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2875       } else if (method_attribute_name == vmSymbols::tag_annotation_default()) {
2876         if (annotation_default != NULL) {
2877           classfile_parse_error(
2878             &quot;Multiple AnnotationDefault attributes for method in class file %s&quot;,
2879             CHECK_NULL);
2880         }
2881         annotation_default_length = method_attribute_length;
2882         annotation_default = cfs-&gt;current();
2883         assert(annotation_default != NULL, &quot;null annotation default&quot;);
2884         cfs-&gt;skip_u1(annotation_default_length, CHECK_NULL);
2885       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
2886         if (runtime_visible_type_annotations != NULL) {
2887           classfile_parse_error(
2888             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for method in class file %s&quot;,
2889             CHECK_NULL);
2890         }
2891         runtime_visible_type_annotations_length = method_attribute_length;
2892         runtime_visible_type_annotations = cfs-&gt;current();
2893         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
2894         // No need for the VM to parse Type annotations
2895         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK_NULL);
2896       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
2897         if (runtime_invisible_type_annotations_exists) {
2898           classfile_parse_error(
2899             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for method in class file %s&quot;,
2900             CHECK_NULL);
2901         } else {
2902           runtime_invisible_type_annotations_exists = true;
2903         }
2904         if (PreserveAllAnnotations) {
2905           runtime_invisible_type_annotations_length = method_attribute_length;
2906           runtime_invisible_type_annotations = cfs-&gt;current();
2907           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
2908         }
2909         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2910       } else {
2911         // Skip unknown attributes
2912         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2913       }
2914     } else {
2915       // Skip unknown attributes
2916       cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2917     }
2918   }
2919 
2920   if (linenumber_table != NULL) {
2921     linenumber_table-&gt;write_terminator();
2922     linenumber_table_length = linenumber_table-&gt;position();
2923   }
2924 
2925   // Make sure there&#39;s at least one Code attribute in non-native/non-abstract method
2926   if (_need_verify) {
2927     guarantee_property(access_flags.is_native() ||
2928                        access_flags.is_abstract() ||
2929                        parsed_code_attribute,
2930                        &quot;Absent Code attribute in method that is not native or abstract in class file %s&quot;,
2931                        CHECK_NULL);
2932   }
2933 
2934   // All sizing information for a Method* is finally available, now create it
2935   InlineTableSizes sizes(
2936       total_lvt_length,
2937       linenumber_table_length,
2938       exception_table_length,
2939       checked_exceptions_length,
2940       method_parameters_length,
2941       generic_signature_index,
2942       runtime_visible_annotations_length +
2943            runtime_invisible_annotations_length,
2944       runtime_visible_parameter_annotations_length +
2945            runtime_invisible_parameter_annotations_length,
2946       runtime_visible_type_annotations_length +
2947            runtime_invisible_type_annotations_length,
2948       annotation_default_length,
2949       0);
2950 
2951   Method* const m = Method::allocate(_loader_data,
2952                                      code_length,
2953                                      access_flags,
2954                                      &amp;sizes,
2955                                      ConstMethod::NORMAL,
2956                                      CHECK_NULL);
2957 
2958   ClassLoadingService::add_class_method_size(m-&gt;size()*wordSize);
2959 
2960   // Fill in information from fixed part (access_flags already set)
2961   m-&gt;set_constants(_cp);
2962   m-&gt;set_name_index(name_index);
2963   m-&gt;set_signature_index(signature_index);
2964   m-&gt;compute_from_signature(cp-&gt;symbol_at(signature_index));
2965   assert(args_size &lt; 0 || args_size == m-&gt;size_of_parameters(), &quot;&quot;);
2966 
2967   // Fill in code attribute information
2968   m-&gt;set_max_stack(max_stack);
2969   m-&gt;set_max_locals(max_locals);
2970   if (stackmap_data != NULL) {
2971     m-&gt;constMethod()-&gt;copy_stackmap_data(_loader_data,
2972                                          (u1*)stackmap_data,
2973                                          stackmap_data_length,
2974                                          CHECK_NULL);
2975   }
2976 
2977   // Copy byte codes
2978   m-&gt;set_code((u1*)code_start);
2979 
2980   // Copy line number table
2981   if (linenumber_table != NULL) {
2982     memcpy(m-&gt;compressed_linenumber_table(),
2983            linenumber_table-&gt;buffer(),
2984            linenumber_table_length);
2985   }
2986 
2987   // Copy exception table
2988   if (exception_table_length &gt; 0) {
2989     Copy::conjoint_swap_if_needed&lt;Endian::JAVA&gt;(exception_table_start,
2990                                                 m-&gt;exception_table_start(),
2991                                                 exception_table_length * sizeof(ExceptionTableElement),
2992                                                 sizeof(u2));
2993   }
2994 
2995   // Copy method parameters
2996   if (method_parameters_length &gt; 0) {
2997     MethodParametersElement* elem = m-&gt;constMethod()-&gt;method_parameters_start();
2998     for (int i = 0; i &lt; method_parameters_length; i++) {
2999       elem[i].name_cp_index = Bytes::get_Java_u2((address)method_parameters_data);
3000       method_parameters_data += 2;
3001       elem[i].flags = Bytes::get_Java_u2((address)method_parameters_data);
3002       method_parameters_data += 2;
3003     }
3004   }
3005 
3006   // Copy checked exceptions
3007   if (checked_exceptions_length &gt; 0) {
3008     Copy::conjoint_swap_if_needed&lt;Endian::JAVA&gt;(checked_exceptions_start,
3009                                                 m-&gt;checked_exceptions_start(),
3010                                                 checked_exceptions_length * sizeof(CheckedExceptionElement),
3011                                                 sizeof(u2));
3012   }
3013 
3014   // Copy class file LVT&#39;s/LVTT&#39;s into the HotSpot internal LVT.
3015   if (total_lvt_length &gt; 0) {
3016     promoted_flags-&gt;set_has_localvariable_table();
3017     copy_localvariable_table(m-&gt;constMethod(),
3018                              lvt_cnt,
3019                              localvariable_table_length,
3020                              localvariable_table_start,
3021                              lvtt_cnt,
3022                              localvariable_type_table_length,
3023                              localvariable_type_table_start,
3024                              CHECK_NULL);
3025   }
3026 
3027   if (parsed_annotations.has_any_annotations())
3028     parsed_annotations.apply_to(methodHandle(THREAD, m));
3029 
3030   if (is_hidden()) { // Mark methods in hidden classes as &#39;hidden&#39;.
3031     m-&gt;set_hidden(true);
3032   }
3033 
3034   // Copy annotations
3035   copy_method_annotations(m-&gt;constMethod(),
3036                           runtime_visible_annotations,
3037                           runtime_visible_annotations_length,
3038                           runtime_invisible_annotations,
3039                           runtime_invisible_annotations_length,
3040                           runtime_visible_parameter_annotations,
3041                           runtime_visible_parameter_annotations_length,
3042                           runtime_invisible_parameter_annotations,
3043                           runtime_invisible_parameter_annotations_length,
3044                           runtime_visible_type_annotations,
3045                           runtime_visible_type_annotations_length,
3046                           runtime_invisible_type_annotations,
3047                           runtime_invisible_type_annotations_length,
3048                           annotation_default,
3049                           annotation_default_length,
3050                           CHECK_NULL);
3051 
3052   if (name == vmSymbols::finalize_method_name() &amp;&amp;
3053       signature == vmSymbols::void_method_signature()) {
3054     if (m-&gt;is_empty_method()) {
3055       _has_empty_finalizer = true;
3056     } else {
3057       _has_finalizer = true;
3058     }
3059   }
3060   if (name == vmSymbols::object_initializer_name() &amp;&amp;
3061       signature == vmSymbols::void_method_signature() &amp;&amp;
3062       m-&gt;is_vanilla_constructor()) {
3063     _has_vanilla_constructor = true;
3064   }
3065 
3066   NOT_PRODUCT(m-&gt;verify());
3067   return m;
3068 }
3069 
3070 
3071 // The promoted_flags parameter is used to pass relevant access_flags
3072 // from the methods back up to the containing klass. These flag values
3073 // are added to klass&#39;s access_flags.
3074 // Side-effects: populates the _methods field in the parser
3075 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
3076                                     bool is_interface,
3077                                     bool is_inline_type,
3078                                     AccessFlags* promoted_flags,
3079                                     bool* has_final_method,
3080                                     bool* declares_nonstatic_concrete_methods,
3081                                     TRAPS) {
3082   assert(cfs != NULL, &quot;invariant&quot;);
3083   assert(promoted_flags != NULL, &quot;invariant&quot;);
3084   assert(has_final_method != NULL, &quot;invariant&quot;);
3085   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
3086 
3087   assert(NULL == _methods, &quot;invariant&quot;);
3088 
3089   cfs-&gt;guarantee_more(2, CHECK);  // length
3090   const u2 length = cfs-&gt;get_u2_fast();
3091   if (length == 0) {
3092     _methods = Universe::the_empty_method_array();
3093   } else {
3094     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
3095                                                    length,
3096                                                    NULL,
3097                                                    CHECK);
3098 
3099     for (int index = 0; index &lt; length; index++) {
3100       Method* method = parse_method(cfs,
3101                                     is_interface,
3102                                     is_inline_type,
3103                                     _cp,
3104                                     promoted_flags,
3105                                     CHECK);
3106 
3107       if (method-&gt;is_final()) {
3108         *has_final_method = true;
3109       }
3110       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
3111       // used for interface initialization, and default method inheritance analysis
3112       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
3113         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
3114         *declares_nonstatic_concrete_methods = true;
3115       }
3116       _methods-&gt;at_put(index, method);
3117     }
3118 
3119     if (_need_verify &amp;&amp; length &gt; 1) {
3120       // Check duplicated methods
3121       ResourceMark rm(THREAD);
3122       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
3123         THREAD, NameSigHash*, HASH_ROW_SIZE);
3124       initialize_hashtable(names_and_sigs);
3125       bool dup = false;
3126       const Symbol* name = NULL;
3127       const Symbol* sig = NULL;
3128       {
3129         debug_only(NoSafepointVerifier nsv;)
3130         for (int i = 0; i &lt; length; i++) {
3131           const Method* const m = _methods-&gt;at(i);
3132           name = m-&gt;name();
3133           sig = m-&gt;signature();
3134           // If no duplicates, add name/signature in hashtable names_and_sigs.
3135           if (!put_after_lookup(name, sig, names_and_sigs)) {
3136             dup = true;
3137             break;
3138           }
3139         }
3140       }
3141       if (dup) {
3142         classfile_parse_error(&quot;Duplicate method name \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s&quot;,
3143                                name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);
3144       }
3145     }
3146   }
3147 }
3148 
3149 static const intArray* sort_methods(Array&lt;Method*&gt;* methods) {
3150   const int length = methods-&gt;length();
3151   // If JVMTI original method ordering or sharing is enabled we have to
3152   // remember the original class file ordering.
3153   // We temporarily use the vtable_index field in the Method* to store the
3154   // class file index, so we can read in after calling qsort.
3155   // Put the method ordering in the shared archive.
3156   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {
3157     for (int index = 0; index &lt; length; index++) {
3158       Method* const m = methods-&gt;at(index);
3159       assert(!m-&gt;valid_vtable_index(), &quot;vtable index should not be set&quot;);
3160       m-&gt;set_vtable_index(index);
3161     }
3162   }
3163   // Sort method array by ascending method name (for faster lookups &amp; vtable construction)
3164   // Note that the ordering is not alphabetical, see Symbol::fast_compare
3165   Method::sort_methods(methods);
3166 
3167   intArray* method_ordering = NULL;
3168   // If JVMTI original method ordering or sharing is enabled construct int
3169   // array remembering the original ordering
3170   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {
3171     method_ordering = new intArray(length, length, -1);
3172     for (int index = 0; index &lt; length; index++) {
3173       Method* const m = methods-&gt;at(index);
3174       const int old_index = m-&gt;vtable_index();
3175       assert(old_index &gt;= 0 &amp;&amp; old_index &lt; length, &quot;invalid method index&quot;);
3176       method_ordering-&gt;at_put(index, old_index);
3177       m-&gt;set_vtable_index(Method::invalid_vtable_index);
3178     }
3179   }
3180   return method_ordering;
3181 }
3182 
3183 // Parse generic_signature attribute for methods and fields
3184 u2 ClassFileParser::parse_generic_signature_attribute(const ClassFileStream* const cfs,
3185                                                       TRAPS) {
3186   assert(cfs != NULL, &quot;invariant&quot;);
3187 
3188   cfs-&gt;guarantee_more(2, CHECK_0);  // generic_signature_index
3189   const u2 generic_signature_index = cfs-&gt;get_u2_fast();
3190   check_property(
3191     valid_symbol_at(generic_signature_index),
3192     &quot;Invalid Signature attribute at constant pool index %u in class file %s&quot;,
3193     generic_signature_index, CHECK_0);
3194   return generic_signature_index;
3195 }
3196 
3197 void ClassFileParser::parse_classfile_sourcefile_attribute(const ClassFileStream* const cfs,
3198                                                            TRAPS) {
3199 
3200   assert(cfs != NULL, &quot;invariant&quot;);
3201 
3202   cfs-&gt;guarantee_more(2, CHECK);  // sourcefile_index
3203   const u2 sourcefile_index = cfs-&gt;get_u2_fast();
3204   check_property(
3205     valid_symbol_at(sourcefile_index),
3206     &quot;Invalid SourceFile attribute at constant pool index %u in class file %s&quot;,
3207     sourcefile_index, CHECK);
3208   set_class_sourcefile_index(sourcefile_index);
3209 }
3210 
3211 void ClassFileParser::parse_classfile_source_debug_extension_attribute(const ClassFileStream* const cfs,
3212                                                                        int length,
3213                                                                        TRAPS) {
3214   assert(cfs != NULL, &quot;invariant&quot;);
3215 
3216   const u1* const sde_buffer = cfs-&gt;current();
3217   assert(sde_buffer != NULL, &quot;null sde buffer&quot;);
3218 
3219   // Don&#39;t bother storing it if there is no way to retrieve it
3220   if (JvmtiExport::can_get_source_debug_extension()) {
3221     assert((length+1) &gt; length, &quot;Overflow checking&quot;);
3222     u1* const sde = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, u1, length+1);
3223     for (int i = 0; i &lt; length; i++) {
3224       sde[i] = sde_buffer[i];
3225     }
3226     sde[length] = &#39;\0&#39;;
3227     set_class_sde_buffer((const char*)sde, length);
3228   }
3229   // Got utf8 string, set stream position forward
3230   cfs-&gt;skip_u1(length, CHECK);
3231 }
3232 
3233 
3234 // Inner classes can be static, private or protected (classic VM does this)
3235 #define RECOGNIZED_INNER_CLASS_MODIFIERS ( JVM_RECOGNIZED_CLASS_MODIFIERS | \
3236                                            JVM_ACC_PRIVATE |                \
3237                                            JVM_ACC_PROTECTED |              \
3238                                            JVM_ACC_STATIC                   \
3239                                          )
3240 
3241 // Return number of classes in the inner classes attribute table
3242 u2 ClassFileParser::parse_classfile_inner_classes_attribute(const ClassFileStream* const cfs,
3243                                                             const u1* const inner_classes_attribute_start,
3244                                                             bool parsed_enclosingmethod_attribute,
3245                                                             u2 enclosing_method_class_index,
3246                                                             u2 enclosing_method_method_index,
3247                                                             TRAPS) {
3248   const u1* const current_mark = cfs-&gt;current();
3249   u2 length = 0;
3250   if (inner_classes_attribute_start != NULL) {
3251     cfs-&gt;set_current(inner_classes_attribute_start);
3252     cfs-&gt;guarantee_more(2, CHECK_0);  // length
3253     length = cfs-&gt;get_u2_fast();
3254   }
3255 
3256   // 4-tuples of shorts of inner classes data and 2 shorts of enclosing
3257   // method data:
3258   //   [inner_class_info_index,
3259   //    outer_class_info_index,
3260   //    inner_name_index,
3261   //    inner_class_access_flags,
3262   //    ...
3263   //    enclosing_method_class_index,
3264   //    enclosing_method_method_index]
3265   const int size = length * 4 + (parsed_enclosingmethod_attribute ? 2 : 0);
3266   Array&lt;u2&gt;* const inner_classes = MetadataFactory::new_array&lt;u2&gt;(_loader_data, size, CHECK_0);
3267   _inner_classes = inner_classes;
3268 
3269   int index = 0;
3270   cfs-&gt;guarantee_more(8 * length, CHECK_0);  // 4-tuples of u2
3271   for (int n = 0; n &lt; length; n++) {
3272     // Inner class index
3273     const u2 inner_class_info_index = cfs-&gt;get_u2_fast();
3274     check_property(
3275       valid_klass_reference_at(inner_class_info_index),
3276       &quot;inner_class_info_index %u has bad constant type in class file %s&quot;,
3277       inner_class_info_index, CHECK_0);
3278     // Outer class index
3279     const u2 outer_class_info_index = cfs-&gt;get_u2_fast();
3280     check_property(
3281       outer_class_info_index == 0 ||
3282         valid_klass_reference_at(outer_class_info_index),
3283       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3284       outer_class_info_index, CHECK_0);
3285     // Inner class name
3286     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3287     check_property(
3288       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3289       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3290       inner_name_index, CHECK_0);
3291     if (_need_verify) {
3292       guarantee_property(inner_class_info_index != outer_class_info_index,
3293                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3294     }
3295 
3296     jint recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;
3297     // JVM_ACC_MODULE is defined in JDK-9 and later.
3298     if (_major_version &gt;= JAVA_9_VERSION) {
3299       recognized_modifiers |= JVM_ACC_MODULE;
3300     }
3301     // JVM_ACC_VALUE is defined for class file version 55 and later
3302     if (supports_inline_types()) {
3303       recognized_modifiers |= JVM_ACC_VALUE;
3304     }
3305 
3306     // Access flags
3307     jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;
3308 
3309     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3310       // Set abstract bit for old class files for backward compatibility
3311       flags |= JVM_ACC_ABSTRACT;
3312     }
3313     verify_legal_class_modifiers(flags, CHECK_0);
3314     AccessFlags inner_access_flags(flags);
3315 
3316     inner_classes-&gt;at_put(index++, inner_class_info_index);
3317     inner_classes-&gt;at_put(index++, outer_class_info_index);
3318     inner_classes-&gt;at_put(index++, inner_name_index);
3319     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3320   }
3321 
3322   // 4347400: make sure there&#39;s no duplicate entry in the classes array
3323   if (_need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3324     for(int i = 0; i &lt; length * 4; i += 4) {
3325       for(int j = i + 4; j &lt; length * 4; j += 4) {
3326         guarantee_property((inner_classes-&gt;at(i)   != inner_classes-&gt;at(j) ||
3327                             inner_classes-&gt;at(i+1) != inner_classes-&gt;at(j+1) ||
3328                             inner_classes-&gt;at(i+2) != inner_classes-&gt;at(j+2) ||
3329                             inner_classes-&gt;at(i+3) != inner_classes-&gt;at(j+3)),
3330                             &quot;Duplicate entry in InnerClasses in class file %s&quot;,
3331                             CHECK_0);
3332       }
3333     }
3334   }
3335 
3336   // Set EnclosingMethod class and method indexes.
3337   if (parsed_enclosingmethod_attribute) {
3338     inner_classes-&gt;at_put(index++, enclosing_method_class_index);
3339     inner_classes-&gt;at_put(index++, enclosing_method_method_index);
3340   }
3341   assert(index == size, &quot;wrong size&quot;);
3342 
3343   // Restore buffer&#39;s current position.
3344   cfs-&gt;set_current(current_mark);
3345 
3346   return length;
3347 }
3348 
3349 u2 ClassFileParser::parse_classfile_nest_members_attribute(const ClassFileStream* const cfs,
3350                                                            const u1* const nest_members_attribute_start,
3351                                                            TRAPS) {
3352   const u1* const current_mark = cfs-&gt;current();
3353   u2 length = 0;
3354   if (nest_members_attribute_start != NULL) {
3355     cfs-&gt;set_current(nest_members_attribute_start);
3356     cfs-&gt;guarantee_more(2, CHECK_0);  // length
3357     length = cfs-&gt;get_u2_fast();
3358   }
3359   const int size = length;
3360   Array&lt;u2&gt;* const nest_members = MetadataFactory::new_array&lt;u2&gt;(_loader_data, size, CHECK_0);
3361   _nest_members = nest_members;
3362 
3363   int index = 0;
3364   cfs-&gt;guarantee_more(2 * length, CHECK_0);
3365   for (int n = 0; n &lt; length; n++) {
3366     const u2 class_info_index = cfs-&gt;get_u2_fast();
3367     check_property(
3368       valid_klass_reference_at(class_info_index),
3369       &quot;Nest member class_info_index %u has bad constant type in class file %s&quot;,
3370       class_info_index, CHECK_0);
3371     nest_members-&gt;at_put(index++, class_info_index);
3372   }
3373   assert(index == size, &quot;wrong size&quot;);
3374 
3375   // Restore buffer&#39;s current position.
3376   cfs-&gt;set_current(current_mark);
3377 
3378   return length;
3379 }
3380 
3381 u2 ClassFileParser::parse_classfile_permitted_subclasses_attribute(const ClassFileStream* const cfs,
3382                                                                    const u1* const permitted_subclasses_attribute_start,
3383                                                                    TRAPS) {
3384   const u1* const current_mark = cfs-&gt;current();
3385   u2 length = 0;
3386   if (permitted_subclasses_attribute_start != NULL) {
3387     cfs-&gt;set_current(permitted_subclasses_attribute_start);
3388     cfs-&gt;guarantee_more(2, CHECK_0);  // length
3389     length = cfs-&gt;get_u2_fast();
3390   }
3391   if (length &lt; 1) {
3392     classfile_parse_error(&quot;PermittedSubclasses attribute is empty in class file %s&quot;, CHECK_0);
3393   }
3394   const int size = length;
3395   Array&lt;u2&gt;* const permitted_subclasses = MetadataFactory::new_array&lt;u2&gt;(_loader_data, size, CHECK_0);
3396   _permitted_subclasses = permitted_subclasses;
3397 
3398   int index = 0;
3399   cfs-&gt;guarantee_more(2 * length, CHECK_0);
3400   for (int n = 0; n &lt; length; n++) {
3401     const u2 class_info_index = cfs-&gt;get_u2_fast();
3402     check_property(
3403       valid_klass_reference_at(class_info_index),
3404       &quot;Permitted subclass class_info_index %u has bad constant type in class file %s&quot;,
3405       class_info_index, CHECK_0);
3406     permitted_subclasses-&gt;at_put(index++, class_info_index);
3407   }
3408   assert(index == size, &quot;wrong size&quot;);
3409 
3410   // Restore buffer&#39;s current position.
3411   cfs-&gt;set_current(current_mark);
3412 
3413   return length;
3414 }
3415 
3416 //  Record {
3417 //    u2 attribute_name_index;
3418 //    u4 attribute_length;
3419 //    u2 components_count;
3420 //    component_info components[components_count];
3421 //  }
3422 //  component_info {
3423 //    u2 name_index;
3424 //    u2 descriptor_index
3425 //    u2 attributes_count;
3426 //    attribute_info_attributes[attributes_count];
3427 //  }
3428 u2 ClassFileParser::parse_classfile_record_attribute(const ClassFileStream* const cfs,
3429                                                      const ConstantPool* cp,
3430                                                      const u1* const record_attribute_start,
3431                                                      TRAPS) {
3432   const u1* const current_mark = cfs-&gt;current();
3433   int components_count = 0;
3434   unsigned int calculate_attr_size = 0;
3435   if (record_attribute_start != NULL) {
3436     cfs-&gt;set_current(record_attribute_start);
3437     cfs-&gt;guarantee_more(2, CHECK_0);  // num of components
3438     components_count = (int)cfs-&gt;get_u2_fast();
3439     calculate_attr_size = 2;
3440   }
3441 
3442   Array&lt;RecordComponent*&gt;* const record_components =
3443     MetadataFactory::new_array&lt;RecordComponent*&gt;(_loader_data, components_count, NULL, CHECK_0);
3444   _record_components = record_components;
3445 
3446   for (int x = 0; x &lt; components_count; x++) {
3447     cfs-&gt;guarantee_more(6, CHECK_0); // name_index, descriptor_index, attributes_count
3448 
3449     const u2 name_index = cfs-&gt;get_u2_fast();
3450     check_property(valid_symbol_at(name_index),
3451       &quot;Invalid constant pool index %u for name in Record attribute in class file %s&quot;,
3452       name_index, CHECK_0);
3453     const Symbol* const name = cp-&gt;symbol_at(name_index);
3454     verify_legal_field_name(name, CHECK_0);
3455 
3456     const u2 descriptor_index = cfs-&gt;get_u2_fast();
3457     check_property(valid_symbol_at(descriptor_index),
3458       &quot;Invalid constant pool index %u for descriptor in Record attribute in class file %s&quot;,
3459       descriptor_index, CHECK_0);
3460     const Symbol* const descr = cp-&gt;symbol_at(descriptor_index);
3461     verify_legal_field_signature(name, descr, CHECK_0);
3462 
3463     const u2 attributes_count = cfs-&gt;get_u2_fast();
3464     calculate_attr_size += 6;
3465     u2 generic_sig_index = 0;
3466     const u1* runtime_visible_annotations = NULL;
3467     int runtime_visible_annotations_length = 0;
3468     const u1* runtime_invisible_annotations = NULL;
3469     int runtime_invisible_annotations_length = 0;
3470     bool runtime_invisible_annotations_exists = false;
3471     const u1* runtime_visible_type_annotations = NULL;
3472     int runtime_visible_type_annotations_length = 0;
3473     const u1* runtime_invisible_type_annotations = NULL;
3474     int runtime_invisible_type_annotations_length = 0;
3475     bool runtime_invisible_type_annotations_exists = false;
3476 
3477     // Expected attributes for record components are Signature, Runtime(In)VisibleAnnotations,
3478     // and Runtime(In)VisibleTypeAnnotations.  Other attributes are ignored.
3479     for (int y = 0; y &lt; attributes_count; y++) {
3480       cfs-&gt;guarantee_more(6, CHECK_0);  // attribute_name_index, attribute_length
3481       const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3482       const u4 attribute_length = cfs-&gt;get_u4_fast();
3483       calculate_attr_size += 6;
3484       check_property(
3485         valid_symbol_at(attribute_name_index),
3486         &quot;Invalid Record attribute name index %u in class file %s&quot;,
3487         attribute_name_index, CHECK_0);
3488 
3489       const Symbol* const attribute_name = cp-&gt;symbol_at(attribute_name_index);
3490       if (attribute_name == vmSymbols::tag_signature()) {
3491         if (generic_sig_index != 0) {
3492           classfile_parse_error(
3493             &quot;Multiple Signature attributes for Record component in class file %s&quot;,
3494             CHECK_0);
3495         }
3496         if (attribute_length != 2) {
3497           classfile_parse_error(
3498             &quot;Invalid Signature attribute length %u in Record component in class file %s&quot;,
3499             attribute_length, CHECK_0);
3500         }
3501         generic_sig_index = parse_generic_signature_attribute(cfs, CHECK_0);
3502 
3503       } else if (attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
3504         if (runtime_visible_annotations != NULL) {
3505           classfile_parse_error(
3506             &quot;Multiple RuntimeVisibleAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3507         }
3508         runtime_visible_annotations_length = attribute_length;
3509         runtime_visible_annotations = cfs-&gt;current();
3510 
3511         assert(runtime_visible_annotations != NULL, &quot;null record component visible annotation&quot;);
3512         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK_0);
3513         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
3514 
3515       } else if (attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
3516         if (runtime_invisible_annotations_exists) {
3517           classfile_parse_error(
3518             &quot;Multiple RuntimeInvisibleAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3519         }
3520         runtime_invisible_annotations_exists = true;
3521         if (PreserveAllAnnotations) {
3522           runtime_invisible_annotations_length = attribute_length;
3523           runtime_invisible_annotations = cfs-&gt;current();
3524           assert(runtime_invisible_annotations != NULL, &quot;null record component invisible annotation&quot;);
3525         }
3526         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3527 
3528       } else if (attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
3529         if (runtime_visible_type_annotations != NULL) {
3530           classfile_parse_error(
3531             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3532         }
3533         runtime_visible_type_annotations_length = attribute_length;
3534         runtime_visible_type_annotations = cfs-&gt;current();
3535 
3536         assert(runtime_visible_type_annotations != NULL, &quot;null record component visible type annotation&quot;);
3537         cfs-&gt;guarantee_more(runtime_visible_type_annotations_length, CHECK_0);
3538         cfs-&gt;skip_u1_fast(runtime_visible_type_annotations_length);
3539 
3540       } else if (attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
3541         if (runtime_invisible_type_annotations_exists) {
3542           classfile_parse_error(
3543             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3544         }
3545         runtime_invisible_type_annotations_exists = true;
3546         if (PreserveAllAnnotations) {
3547           runtime_invisible_type_annotations_length = attribute_length;
3548           runtime_invisible_type_annotations = cfs-&gt;current();
3549           assert(runtime_invisible_type_annotations != NULL, &quot;null record component invisible type annotation&quot;);
3550         }
3551         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3552 
3553       } else {
3554         // Skip unknown attributes
3555         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3556       }
3557       calculate_attr_size += attribute_length;
3558     } // End of attributes For loop
3559 
3560     AnnotationArray* annotations = assemble_annotations(runtime_visible_annotations,
3561                                                         runtime_visible_annotations_length,
3562                                                         runtime_invisible_annotations,
3563                                                         runtime_invisible_annotations_length,
3564                                                         CHECK_0);
3565     AnnotationArray* type_annotations = assemble_annotations(runtime_visible_type_annotations,
3566                                                              runtime_visible_type_annotations_length,
3567                                                              runtime_invisible_type_annotations,
3568                                                              runtime_invisible_type_annotations_length,
3569                                                              CHECK_0);
3570 
3571     RecordComponent* record_component =
3572       RecordComponent::allocate(_loader_data, name_index, descriptor_index,
3573                                 attributes_count, generic_sig_index,
3574                                 annotations, type_annotations, CHECK_0);
3575     record_components-&gt;at_put(x, record_component);
3576   }  // End of component processing loop
3577 
3578   // Restore buffer&#39;s current position.
3579   cfs-&gt;set_current(current_mark);
3580   return calculate_attr_size;
3581 }
3582 
3583 void ClassFileParser::parse_classfile_synthetic_attribute(TRAPS) {
3584   set_class_synthetic_flag(true);
3585 }
3586 
3587 void ClassFileParser::parse_classfile_signature_attribute(const ClassFileStream* const cfs, TRAPS) {
3588   assert(cfs != NULL, &quot;invariant&quot;);
3589 
3590   const u2 signature_index = cfs-&gt;get_u2(CHECK);
3591   check_property(
3592     valid_symbol_at(signature_index),
3593     &quot;Invalid constant pool index %u in Signature attribute in class file %s&quot;,
3594     signature_index, CHECK);
3595   set_class_generic_signature_index(signature_index);
3596 }
3597 
3598 void ClassFileParser::parse_classfile_bootstrap_methods_attribute(const ClassFileStream* const cfs,
3599                                                                   ConstantPool* cp,
3600                                                                   u4 attribute_byte_length,
3601                                                                   TRAPS) {
3602   assert(cfs != NULL, &quot;invariant&quot;);
3603   assert(cp != NULL, &quot;invariant&quot;);
3604 
3605   const u1* const current_start = cfs-&gt;current();
3606 
3607   guarantee_property(attribute_byte_length &gt;= sizeof(u2),
3608                      &quot;Invalid BootstrapMethods attribute length %u in class file %s&quot;,
3609                      attribute_byte_length,
3610                      CHECK);
3611 
3612   cfs-&gt;guarantee_more(attribute_byte_length, CHECK);
3613 
3614   const int attribute_array_length = cfs-&gt;get_u2_fast();
3615 
3616   guarantee_property(_max_bootstrap_specifier_index &lt; attribute_array_length,
3617                      &quot;Short length on BootstrapMethods in class file %s&quot;,
3618                      CHECK);
3619 
3620 
3621   // The attribute contains a counted array of counted tuples of shorts,
3622   // represending bootstrap specifiers:
3623   //    length*{bootstrap_method_index, argument_count*{argument_index}}
3624   const int operand_count = (attribute_byte_length - sizeof(u2)) / sizeof(u2);
3625   // operand_count = number of shorts in attr, except for leading length
3626 
3627   // The attribute is copied into a short[] array.
3628   // The array begins with a series of short[2] pairs, one for each tuple.
3629   const int index_size = (attribute_array_length * 2);
3630 
3631   Array&lt;u2&gt;* const operands =
3632     MetadataFactory::new_array&lt;u2&gt;(_loader_data, index_size + operand_count, CHECK);
3633 
3634   // Eagerly assign operands so they will be deallocated with the constant
3635   // pool if there is an error.
3636   cp-&gt;set_operands(operands);
3637 
3638   int operand_fill_index = index_size;
3639   const int cp_size = cp-&gt;length();
3640 
3641   for (int n = 0; n &lt; attribute_array_length; n++) {
3642     // Store a 32-bit offset into the header of the operand array.
3643     ConstantPool::operand_offset_at_put(operands, n, operand_fill_index);
3644 
3645     // Read a bootstrap specifier.
3646     cfs-&gt;guarantee_more(sizeof(u2) * 2, CHECK);  // bsm, argc
3647     const u2 bootstrap_method_index = cfs-&gt;get_u2_fast();
3648     const u2 argument_count = cfs-&gt;get_u2_fast();
3649     check_property(
3650       valid_cp_range(bootstrap_method_index, cp_size) &amp;&amp;
3651       cp-&gt;tag_at(bootstrap_method_index).is_method_handle(),
3652       &quot;bootstrap_method_index %u has bad constant type in class file %s&quot;,
3653       bootstrap_method_index,
3654       CHECK);
3655 
3656     guarantee_property((operand_fill_index + 1 + argument_count) &lt; operands-&gt;length(),
3657       &quot;Invalid BootstrapMethods num_bootstrap_methods or num_bootstrap_arguments value in class file %s&quot;,
3658       CHECK);
3659 
3660     operands-&gt;at_put(operand_fill_index++, bootstrap_method_index);
3661     operands-&gt;at_put(operand_fill_index++, argument_count);
3662 
3663     cfs-&gt;guarantee_more(sizeof(u2) * argument_count, CHECK);  // argv[argc]
3664     for (int j = 0; j &lt; argument_count; j++) {
3665       const u2 argument_index = cfs-&gt;get_u2_fast();
3666       check_property(
3667         valid_cp_range(argument_index, cp_size) &amp;&amp;
3668         cp-&gt;tag_at(argument_index).is_loadable_constant(),
3669         &quot;argument_index %u has bad constant type in class file %s&quot;,
3670         argument_index,
3671         CHECK);
3672       operands-&gt;at_put(operand_fill_index++, argument_index);
3673     }
3674   }
3675   guarantee_property(current_start + attribute_byte_length == cfs-&gt;current(),
3676                      &quot;Bad length on BootstrapMethods in class file %s&quot;,
3677                      CHECK);
3678 }
3679 
3680 bool ClassFileParser::supports_sealed_types() {
3681   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
3682          _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
3683          Arguments::enable_preview();
3684 }
3685 
3686 bool ClassFileParser::supports_records() {
3687   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
3688          _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
3689          Arguments::enable_preview();
3690 }
3691 
3692 void ClassFileParser::parse_classfile_attributes(const ClassFileStream* const cfs,
3693                                                  ConstantPool* cp,
3694                  ClassFileParser::ClassAnnotationCollector* parsed_annotations,
3695                                                  TRAPS) {
3696   assert(cfs != NULL, &quot;invariant&quot;);
3697   assert(cp != NULL, &quot;invariant&quot;);
3698   assert(parsed_annotations != NULL, &quot;invariant&quot;);
3699 
3700   // Set inner classes attribute to default sentinel
3701   _inner_classes = Universe::the_empty_short_array();
3702   // Set nest members attribute to default sentinel
3703   _nest_members = Universe::the_empty_short_array();
3704   // Set _permitted_subclasses attribute to default sentinel
3705   _permitted_subclasses = Universe::the_empty_short_array();
3706   cfs-&gt;guarantee_more(2, CHECK);  // attributes_count
3707   u2 attributes_count = cfs-&gt;get_u2_fast();
3708   bool parsed_sourcefile_attribute = false;
3709   bool parsed_innerclasses_attribute = false;
3710   bool parsed_nest_members_attribute = false;
3711   bool parsed_permitted_subclasses_attribute = false;
3712   bool parsed_nest_host_attribute = false;
3713   bool parsed_record_attribute = false;
3714   bool parsed_enclosingmethod_attribute = false;
3715   bool parsed_bootstrap_methods_attribute = false;
3716   const u1* runtime_visible_annotations = NULL;
3717   int runtime_visible_annotations_length = 0;
3718   const u1* runtime_invisible_annotations = NULL;
3719   int runtime_invisible_annotations_length = 0;
3720   const u1* runtime_visible_type_annotations = NULL;
3721   int runtime_visible_type_annotations_length = 0;
3722   const u1* runtime_invisible_type_annotations = NULL;
3723   int runtime_invisible_type_annotations_length = 0;
3724   bool runtime_invisible_type_annotations_exists = false;
3725   bool runtime_invisible_annotations_exists = false;
3726   bool parsed_source_debug_ext_annotations_exist = false;
3727   const u1* inner_classes_attribute_start = NULL;
3728   u4  inner_classes_attribute_length = 0;
3729   u2  enclosing_method_class_index = 0;
3730   u2  enclosing_method_method_index = 0;
3731   const u1* nest_members_attribute_start = NULL;
3732   u4  nest_members_attribute_length = 0;
3733   const u1* record_attribute_start = NULL;
3734   u4  record_attribute_length = 0;
3735   const u1* permitted_subclasses_attribute_start = NULL;
3736   u4  permitted_subclasses_attribute_length = 0;
3737 
3738   // Iterate over attributes
3739   while (attributes_count--) {
3740     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
3741     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3742     const u4 attribute_length = cfs-&gt;get_u4_fast();
3743     check_property(
3744       valid_symbol_at(attribute_name_index),
3745       &quot;Attribute name has bad constant pool index %u in class file %s&quot;,
3746       attribute_name_index, CHECK);
3747     const Symbol* const tag = cp-&gt;symbol_at(attribute_name_index);
3748     if (tag == vmSymbols::tag_source_file()) {
3749       // Check for SourceFile tag
3750       if (_need_verify) {
3751         guarantee_property(attribute_length == 2, &quot;Wrong SourceFile attribute length in class file %s&quot;, CHECK);
3752       }
3753       if (parsed_sourcefile_attribute) {
3754         classfile_parse_error(&quot;Multiple SourceFile attributes in class file %s&quot;, CHECK);
3755       } else {
3756         parsed_sourcefile_attribute = true;
3757       }
3758       parse_classfile_sourcefile_attribute(cfs, CHECK);
3759     } else if (tag == vmSymbols::tag_source_debug_extension()) {
3760       // Check for SourceDebugExtension tag
3761       if (parsed_source_debug_ext_annotations_exist) {
3762           classfile_parse_error(
3763             &quot;Multiple SourceDebugExtension attributes in class file %s&quot;, CHECK);
3764       }
3765       parsed_source_debug_ext_annotations_exist = true;
3766       parse_classfile_source_debug_extension_attribute(cfs, (int)attribute_length, CHECK);
3767     } else if (tag == vmSymbols::tag_inner_classes()) {
3768       // Check for InnerClasses tag
3769       if (parsed_innerclasses_attribute) {
3770         classfile_parse_error(&quot;Multiple InnerClasses attributes in class file %s&quot;, CHECK);
3771       } else {
3772         parsed_innerclasses_attribute = true;
3773       }
3774       inner_classes_attribute_start = cfs-&gt;current();
3775       inner_classes_attribute_length = attribute_length;
3776       cfs-&gt;skip_u1(inner_classes_attribute_length, CHECK);
3777     } else if (tag == vmSymbols::tag_synthetic()) {
3778       // Check for Synthetic tag
3779       // Shouldn&#39;t we check that the synthetic flags wasn&#39;t already set? - not required in spec
3780       if (attribute_length != 0) {
3781         classfile_parse_error(
3782           &quot;Invalid Synthetic classfile attribute length %u in class file %s&quot;,
3783           attribute_length, CHECK);
3784       }
3785       parse_classfile_synthetic_attribute(CHECK);
3786     } else if (tag == vmSymbols::tag_deprecated()) {
3787       // Check for Deprecatd tag - 4276120
3788       if (attribute_length != 0) {
3789         classfile_parse_error(
3790           &quot;Invalid Deprecated classfile attribute length %u in class file %s&quot;,
3791           attribute_length, CHECK);
3792       }
3793     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
3794       if (tag == vmSymbols::tag_signature()) {
3795         if (_generic_signature_index != 0) {
3796           classfile_parse_error(
3797             &quot;Multiple Signature attributes in class file %s&quot;, CHECK);
3798         }
3799         if (attribute_length != 2) {
3800           classfile_parse_error(
3801             &quot;Wrong Signature attribute length %u in class file %s&quot;,
3802             attribute_length, CHECK);
3803         }
3804         parse_classfile_signature_attribute(cfs, CHECK);
3805       } else if (tag == vmSymbols::tag_runtime_visible_annotations()) {
3806         if (runtime_visible_annotations != NULL) {
3807           classfile_parse_error(
3808             &quot;Multiple RuntimeVisibleAnnotations attributes in class file %s&quot;, CHECK);
3809         }
3810         runtime_visible_annotations_length = attribute_length;
3811         runtime_visible_annotations = cfs-&gt;current();
3812         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
3813         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK);
3814         parse_annotations(cp,
3815                           runtime_visible_annotations,
3816                           runtime_visible_annotations_length,
3817                           parsed_annotations,
3818                           _loader_data,
3819                           _can_access_vm_annotations,
3820                           CHECK);
3821         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
3822       } else if (tag == vmSymbols::tag_runtime_invisible_annotations()) {
3823         if (runtime_invisible_annotations_exists) {
3824           classfile_parse_error(
3825             &quot;Multiple RuntimeInvisibleAnnotations attributes in class file %s&quot;, CHECK);
3826         }
3827         runtime_invisible_annotations_exists = true;
3828         if (PreserveAllAnnotations) {
3829           runtime_invisible_annotations_length = attribute_length;
3830           runtime_invisible_annotations = cfs-&gt;current();
3831           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
3832         }
3833         cfs-&gt;skip_u1(attribute_length, CHECK);
3834       } else if (tag == vmSymbols::tag_enclosing_method()) {
3835         if (parsed_enclosingmethod_attribute) {
3836           classfile_parse_error(&quot;Multiple EnclosingMethod attributes in class file %s&quot;, CHECK);
3837         } else {
3838           parsed_enclosingmethod_attribute = true;
3839         }
3840         guarantee_property(attribute_length == 4,
3841           &quot;Wrong EnclosingMethod attribute length %u in class file %s&quot;,
3842           attribute_length, CHECK);
3843         cfs-&gt;guarantee_more(4, CHECK);  // class_index, method_index
3844         enclosing_method_class_index  = cfs-&gt;get_u2_fast();
3845         enclosing_method_method_index = cfs-&gt;get_u2_fast();
3846         if (enclosing_method_class_index == 0) {
3847           classfile_parse_error(&quot;Invalid class index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3848         }
3849         // Validate the constant pool indices and types
3850         check_property(valid_klass_reference_at(enclosing_method_class_index),
3851           &quot;Invalid or out-of-bounds class index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3852         if (enclosing_method_method_index != 0 &amp;&amp;
3853             (!cp-&gt;is_within_bounds(enclosing_method_method_index) ||
3854              !cp-&gt;tag_at(enclosing_method_method_index).is_name_and_type())) {
3855           classfile_parse_error(&quot;Invalid or out-of-bounds method index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3856         }
3857       } else if (tag == vmSymbols::tag_bootstrap_methods() &amp;&amp;
3858                  _major_version &gt;= Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
3859         if (parsed_bootstrap_methods_attribute) {
3860           classfile_parse_error(&quot;Multiple BootstrapMethods attributes in class file %s&quot;, CHECK);
3861         }
3862         parsed_bootstrap_methods_attribute = true;
3863         parse_classfile_bootstrap_methods_attribute(cfs, cp, attribute_length, CHECK);
3864       } else if (tag == vmSymbols::tag_runtime_visible_type_annotations()) {
3865         if (runtime_visible_type_annotations != NULL) {
3866           classfile_parse_error(
3867             &quot;Multiple RuntimeVisibleTypeAnnotations attributes in class file %s&quot;, CHECK);
3868         }
3869         runtime_visible_type_annotations_length = attribute_length;
3870         runtime_visible_type_annotations = cfs-&gt;current();
3871         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
3872         // No need for the VM to parse Type annotations
3873         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK);
3874       } else if (tag == vmSymbols::tag_runtime_invisible_type_annotations()) {
3875         if (runtime_invisible_type_annotations_exists) {
3876           classfile_parse_error(
3877             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes in class file %s&quot;, CHECK);
3878         } else {
3879           runtime_invisible_type_annotations_exists = true;
3880         }
3881         if (PreserveAllAnnotations) {
3882           runtime_invisible_type_annotations_length = attribute_length;
3883           runtime_invisible_type_annotations = cfs-&gt;current();
3884           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
3885         }
3886         cfs-&gt;skip_u1(attribute_length, CHECK);
3887       } else if (_major_version &gt;= JAVA_11_VERSION) {
3888         if (tag == vmSymbols::tag_nest_members()) {
3889           // Check for NestMembers tag
3890           if (parsed_nest_members_attribute) {
3891             classfile_parse_error(&quot;Multiple NestMembers attributes in class file %s&quot;, CHECK);
3892           } else {
3893             parsed_nest_members_attribute = true;
3894           }
3895           if (parsed_nest_host_attribute) {
3896             classfile_parse_error(&quot;Conflicting NestHost and NestMembers attributes in class file %s&quot;, CHECK);
3897           }
3898           nest_members_attribute_start = cfs-&gt;current();
3899           nest_members_attribute_length = attribute_length;
3900           cfs-&gt;skip_u1(nest_members_attribute_length, CHECK);
3901         } else if (tag == vmSymbols::tag_nest_host()) {
3902           if (parsed_nest_host_attribute) {
3903             classfile_parse_error(&quot;Multiple NestHost attributes in class file %s&quot;, CHECK);
3904           } else {
3905             parsed_nest_host_attribute = true;
3906           }
3907           if (parsed_nest_members_attribute) {
3908             classfile_parse_error(&quot;Conflicting NestMembers and NestHost attributes in class file %s&quot;, CHECK);
3909           }
3910           if (_need_verify) {
3911             guarantee_property(attribute_length == 2, &quot;Wrong NestHost attribute length in class file %s&quot;, CHECK);
3912           }
3913           cfs-&gt;guarantee_more(2, CHECK);
3914           u2 class_info_index = cfs-&gt;get_u2_fast();
3915           check_property(
3916                          valid_klass_reference_at(class_info_index),
3917                          &quot;Nest-host class_info_index %u has bad constant type in class file %s&quot;,
3918                          class_info_index, CHECK);
3919           _nest_host = class_info_index;
3920         } else if (_major_version &gt;= JAVA_14_VERSION) {
3921           if (tag == vmSymbols::tag_record()) {
3922             // Skip over Record attribute if not supported or if super class is
3923             // not java.lang.Record.
3924             if (supports_records() &amp;&amp;
3925                 cp-&gt;klass_name_at(_super_class_index) == vmSymbols::java_lang_Record()) {
3926               if (parsed_record_attribute) {
3927                 classfile_parse_error(&quot;Multiple Record attributes in class file %s&quot;, CHECK);
3928               }
3929               // Check that class is final and not abstract.
3930               if (!_access_flags.is_final() || _access_flags.is_abstract()) {
3931                 classfile_parse_error(&quot;Record attribute in non-final or abstract class file %s&quot;, CHECK);
3932               }
3933               parsed_record_attribute = true;
3934               record_attribute_start = cfs-&gt;current();
3935               record_attribute_length = attribute_length;
3936             } else if (log_is_enabled(Info, class, record)) {
3937               // Log why the Record attribute was ignored.  Note that if the
3938               // class file version is JVM_CLASSFILE_MAJOR_VERSION.65535 and
3939               // --enable-preview wasn&#39;t specified then a java.lang.UnsupportedClassVersionError
3940               // exception would have been thrown.
3941               ResourceMark rm(THREAD);
3942               if (supports_records()) {
3943                 log_info(class, record)(
3944                   &quot;Ignoring Record attribute in class %s because super type is not java.lang.Record&quot;,
3945                   _class_name-&gt;as_C_string());
3946               } else {
3947                 log_info(class, record)(
3948                   &quot;Ignoring Record attribute in class %s because class file version is not %d.65535&quot;,
3949                    _class_name-&gt;as_C_string(), JVM_CLASSFILE_MAJOR_VERSION);
3950               }
3951             }
3952             cfs-&gt;skip_u1(attribute_length, CHECK);
3953           } else if (_major_version &gt;= JAVA_15_VERSION) {
3954             // Check for PermittedSubclasses tag
3955             if (tag == vmSymbols::tag_permitted_subclasses()) {
3956               if (supports_sealed_types()) {
3957                 if (parsed_permitted_subclasses_attribute) {
3958                   classfile_parse_error(&quot;Multiple PermittedSubclasses attributes in class file %s&quot;, CHECK);
3959                 }
3960                 // Classes marked ACC_FINAL cannot have a PermittedSubclasses attribute.
3961                 if (_access_flags.is_final()) {
3962                   classfile_parse_error(&quot;PermittedSubclasses attribute in final class file %s&quot;, CHECK);
3963                 }
3964                 parsed_permitted_subclasses_attribute = true;
3965                 permitted_subclasses_attribute_start = cfs-&gt;current();
3966                 permitted_subclasses_attribute_length = attribute_length;
3967               }
3968               cfs-&gt;skip_u1(attribute_length, CHECK);
3969             } else {
3970               // Unknown attribute
3971               cfs-&gt;skip_u1(attribute_length, CHECK);
3972             }
3973           } else {
3974             // Unknown attribute
3975             cfs-&gt;skip_u1(attribute_length, CHECK);
3976           }
3977         } else {
3978           // Unknown attribute
3979           cfs-&gt;skip_u1(attribute_length, CHECK);
3980         }
3981       } else {
3982         // Unknown attribute
3983         cfs-&gt;skip_u1(attribute_length, CHECK);
3984       }
3985     } else {
3986       // Unknown attribute
3987       cfs-&gt;skip_u1(attribute_length, CHECK);
3988     }
3989   }
3990   _class_annotations = assemble_annotations(runtime_visible_annotations,
3991                                             runtime_visible_annotations_length,
3992                                             runtime_invisible_annotations,
3993                                             runtime_invisible_annotations_length,
3994                                             CHECK);
3995   _class_type_annotations = assemble_annotations(runtime_visible_type_annotations,
3996                                                  runtime_visible_type_annotations_length,
3997                                                  runtime_invisible_type_annotations,
3998                                                  runtime_invisible_type_annotations_length,
3999                                                  CHECK);
4000 
4001   if (parsed_innerclasses_attribute || parsed_enclosingmethod_attribute) {
4002     const u2 num_of_classes = parse_classfile_inner_classes_attribute(
4003                             cfs,
4004                             inner_classes_attribute_start,
4005                             parsed_innerclasses_attribute,
4006                             enclosing_method_class_index,
4007                             enclosing_method_method_index,
4008                             CHECK);
4009     if (parsed_innerclasses_attribute &amp;&amp; _need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
4010       guarantee_property(
4011         inner_classes_attribute_length == sizeof(num_of_classes) + 4 * sizeof(u2) * num_of_classes,
4012         &quot;Wrong InnerClasses attribute length in class file %s&quot;, CHECK);
4013     }
4014   }
4015 
4016   if (parsed_nest_members_attribute) {
4017     const u2 num_of_classes = parse_classfile_nest_members_attribute(
4018                             cfs,
4019                             nest_members_attribute_start,
4020                             CHECK);
4021     if (_need_verify) {
4022       guarantee_property(
4023         nest_members_attribute_length == sizeof(num_of_classes) + sizeof(u2) * num_of_classes,
4024         &quot;Wrong NestMembers attribute length in class file %s&quot;, CHECK);
4025     }
4026   }
4027 
4028   if (parsed_record_attribute) {
4029     const unsigned int calculated_attr_length = parse_classfile_record_attribute(
4030                             cfs,
4031                             cp,
4032                             record_attribute_start,
4033                             CHECK);
4034     if (_need_verify) {
4035       guarantee_property(record_attribute_length == calculated_attr_length,
4036                          &quot;Record attribute has wrong length in class file %s&quot;,
4037                          CHECK);
4038     }
4039   }
4040 
4041   if (parsed_permitted_subclasses_attribute) {
4042     const u2 num_subclasses = parse_classfile_permitted_subclasses_attribute(
4043                             cfs,
4044                             permitted_subclasses_attribute_start,
4045                             CHECK);
4046     if (_need_verify) {
4047       guarantee_property(
4048         permitted_subclasses_attribute_length == sizeof(num_subclasses) + sizeof(u2) * num_subclasses,
4049         &quot;Wrong PermittedSubclasses attribute length in class file %s&quot;, CHECK);
4050     }
4051   }
4052 
4053   if (_max_bootstrap_specifier_index &gt;= 0) {
4054     guarantee_property(parsed_bootstrap_methods_attribute,
4055                        &quot;Missing BootstrapMethods attribute in class file %s&quot;, CHECK);
4056   }
4057 }
4058 
4059 void ClassFileParser::apply_parsed_class_attributes(InstanceKlass* k) {
4060   assert(k != NULL, &quot;invariant&quot;);
4061 
4062   if (_synthetic_flag)
4063     k-&gt;set_is_synthetic();
4064   if (_sourcefile_index != 0) {
4065     k-&gt;set_source_file_name_index(_sourcefile_index);
4066   }
4067   if (_generic_signature_index != 0) {
4068     k-&gt;set_generic_signature_index(_generic_signature_index);
4069   }
4070   if (_sde_buffer != NULL) {
4071     k-&gt;set_source_debug_extension(_sde_buffer, _sde_length);
4072   }
4073 }
4074 
4075 // Create the Annotations object that will
4076 // hold the annotations array for the Klass.
4077 void ClassFileParser::create_combined_annotations(TRAPS) {
4078     if (_class_annotations == NULL &amp;&amp;
4079         _class_type_annotations == NULL &amp;&amp;
4080         _fields_annotations == NULL &amp;&amp;
4081         _fields_type_annotations == NULL) {
4082       // Don&#39;t create the Annotations object unnecessarily.
4083       return;
4084     }
4085 
4086     Annotations* const annotations = Annotations::allocate(_loader_data, CHECK);
4087     annotations-&gt;set_class_annotations(_class_annotations);
4088     annotations-&gt;set_class_type_annotations(_class_type_annotations);
4089     annotations-&gt;set_fields_annotations(_fields_annotations);
4090     annotations-&gt;set_fields_type_annotations(_fields_type_annotations);
4091 
4092     // This is the Annotations object that will be
4093     // assigned to InstanceKlass being constructed.
4094     _combined_annotations = annotations;
4095 
4096     // The annotations arrays below has been transfered the
4097     // _combined_annotations so these fields can now be cleared.
4098     _class_annotations       = NULL;
4099     _class_type_annotations  = NULL;
4100     _fields_annotations      = NULL;
4101     _fields_type_annotations = NULL;
4102 }
4103 
4104 // Transfer ownership of metadata allocated to the InstanceKlass.
4105 void ClassFileParser::apply_parsed_class_metadata(
4106                                             InstanceKlass* this_klass,
4107                                             int java_fields_count,
4108                                             TRAPS) {
4109   assert(this_klass != NULL, &quot;invariant&quot;);
4110 
4111   _cp-&gt;set_pool_holder(this_klass);
4112   this_klass-&gt;set_constants(_cp);
4113   this_klass-&gt;set_fields(_fields, java_fields_count);
4114   this_klass-&gt;set_methods(_methods);
4115   this_klass-&gt;set_inner_classes(_inner_classes);
4116   this_klass-&gt;set_nest_members(_nest_members);
4117   this_klass-&gt;set_nest_host_index(_nest_host);
4118   this_klass-&gt;set_annotations(_combined_annotations);
4119   this_klass-&gt;set_permitted_subclasses(_permitted_subclasses);
4120   this_klass-&gt;set_record_components(_record_components);
4121   // Delay the setting of _local_interfaces and _transitive_interfaces until after
4122   // initialize_supers() in fill_instance_klass(). It is because the _local_interfaces could
4123   // be shared with _transitive_interfaces and _transitive_interfaces may be shared with
4124   // its _super. If an OOM occurs while loading the current klass, its _super field
4125   // may not have been set. When GC tries to free the klass, the _transitive_interfaces
4126   // may be deallocated mistakenly in InstanceKlass::deallocate_interfaces(). Subsequent
4127   // dereferences to the deallocated _transitive_interfaces will result in a crash.
4128 
4129   // Clear out these fields so they don&#39;t get deallocated by the destructor
4130   clear_class_metadata();
4131 }
4132 
4133 AnnotationArray* ClassFileParser::assemble_annotations(const u1* const runtime_visible_annotations,
4134                                                        int runtime_visible_annotations_length,
4135                                                        const u1* const runtime_invisible_annotations,
4136                                                        int runtime_invisible_annotations_length,
4137                                                        TRAPS) {
4138   AnnotationArray* annotations = NULL;
4139   if (runtime_visible_annotations != NULL ||
4140       runtime_invisible_annotations != NULL) {
4141     annotations = MetadataFactory::new_array&lt;u1&gt;(_loader_data,
4142                                           runtime_visible_annotations_length +
4143                                           runtime_invisible_annotations_length,
4144                                           CHECK_(annotations));
4145     if (runtime_visible_annotations != NULL) {
4146       for (int i = 0; i &lt; runtime_visible_annotations_length; i++) {
4147         annotations-&gt;at_put(i, runtime_visible_annotations[i]);
4148       }
4149     }
4150     if (runtime_invisible_annotations != NULL) {
4151       for (int i = 0; i &lt; runtime_invisible_annotations_length; i++) {
4152         int append = runtime_visible_annotations_length+i;
4153         annotations-&gt;at_put(append, runtime_invisible_annotations[i]);
4154       }
4155     }
4156   }
4157   return annotations;
4158 }
4159 
4160 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
4161                                                         const int super_class_index,
4162                                                         const bool need_verify,
4163                                                         TRAPS) {
4164   assert(cp != NULL, &quot;invariant&quot;);
4165   const InstanceKlass* super_klass = NULL;
4166 
4167   if (super_class_index == 0) {
4168     check_property(_class_name == vmSymbols::java_lang_Object()
4169                    || (_access_flags.get_flags() &amp; JVM_ACC_VALUE),
4170                    &quot;Invalid superclass index %u in class file %s&quot;,
4171                    super_class_index,
4172                    CHECK_NULL);
4173   } else {
4174     check_property(valid_klass_reference_at(super_class_index),
4175                    &quot;Invalid superclass index %u in class file %s&quot;,
4176                    super_class_index,
4177                    CHECK_NULL);
4178     // The class name should be legal because it is checked when parsing constant pool.
4179     // However, make sure it is not an array type.
4180     bool is_array = false;
4181     if (cp-&gt;tag_at(super_class_index).is_klass()) {
4182       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
4183       if (need_verify)
4184         is_array = super_klass-&gt;is_array_klass();
4185     } else if (need_verify) {
4186       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
4187     }
4188     if (need_verify) {
4189       guarantee_property(!is_array,
4190                         &quot;Bad superclass name in class file %s&quot;, CHECK_NULL);
4191     }
4192   }
4193   return super_klass;
4194 }
4195 
4196 #ifndef PRODUCT
4197 static void print_field_layout(const Symbol* name,
4198                                Array&lt;u2&gt;* fields,
4199                                ConstantPool* cp,
4200                                int instance_size,
4201                                int instance_fields_start,
4202                                int instance_fields_end,
4203                                int static_fields_end) {
4204 
4205   assert(name != NULL, &quot;invariant&quot;);
4206 
4207   tty-&gt;print(&quot;%s: field layout\n&quot;, name-&gt;as_klass_external_name());
4208   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_start, &quot;--- instance fields start ---&quot;);
4209   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
4210     if (!fs.access_flags().is_static()) {
4211       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,
4212         fs.offset(),
4213         fs.name()-&gt;as_klass_external_name(),
4214         fs.signature()-&gt;as_klass_external_name());
4215     }
4216   }
4217   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_end, &quot;--- instance fields end ---&quot;);
4218   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_size * wordSize, &quot;--- instance ends ---&quot;);
4219   tty-&gt;print(&quot;  @%3d %s\n&quot;, InstanceMirrorKlass::offset_of_static_fields(), &quot;--- static fields start ---&quot;);
4220   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
4221     if (fs.access_flags().is_static()) {
4222       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,
4223         fs.offset(),
4224         fs.name()-&gt;as_klass_external_name(),
4225         fs.signature()-&gt;as_klass_external_name());
4226     }
4227   }
4228   tty-&gt;print(&quot;  @%3d %s\n&quot;, static_fields_end, &quot;--- static fields end ---&quot;);
4229   tty-&gt;print(&quot;\n&quot;);
4230 }
4231 #endif
4232 
4233 OopMapBlocksBuilder::OopMapBlocksBuilder(unsigned int max_blocks) {
4234   _max_nonstatic_oop_maps = max_blocks;
4235   _nonstatic_oop_map_count = 0;
4236   if (max_blocks == 0) {
4237     _nonstatic_oop_maps = NULL;
4238   } else {
4239     _nonstatic_oop_maps =
4240         NEW_RESOURCE_ARRAY(OopMapBlock, _max_nonstatic_oop_maps);
4241     memset(_nonstatic_oop_maps, 0, sizeof(OopMapBlock) * max_blocks);
4242   }
4243 }
4244 
4245 OopMapBlock* OopMapBlocksBuilder::last_oop_map() const {
4246   assert(_nonstatic_oop_map_count &gt; 0, &quot;Has no oop maps&quot;);
4247   return _nonstatic_oop_maps + (_nonstatic_oop_map_count - 1);
4248 }
4249 
4250 // addition of super oop maps
4251 void OopMapBlocksBuilder::initialize_inherited_blocks(OopMapBlock* blocks, unsigned int nof_blocks) {
4252   assert(nof_blocks &amp;&amp; _nonstatic_oop_map_count == 0 &amp;&amp;
4253          nof_blocks &lt;= _max_nonstatic_oop_maps, &quot;invariant&quot;);
4254 
4255   memcpy(_nonstatic_oop_maps, blocks, sizeof(OopMapBlock) * nof_blocks);
4256   _nonstatic_oop_map_count += nof_blocks;
4257 }
4258 
4259 // collection of oops
4260 void OopMapBlocksBuilder::add(int offset, int count) {
4261   if (_nonstatic_oop_map_count == 0) {
4262     _nonstatic_oop_map_count++;
4263   }
4264   OopMapBlock* nonstatic_oop_map = last_oop_map();
4265   if (nonstatic_oop_map-&gt;count() == 0) {  // Unused map, set it up
4266     nonstatic_oop_map-&gt;set_offset(offset);
4267     nonstatic_oop_map-&gt;set_count(count);
4268   } else if (nonstatic_oop_map-&gt;is_contiguous(offset)) { // contiguous, add
4269     nonstatic_oop_map-&gt;increment_count(count);
4270   } else { // Need a new one...
4271     _nonstatic_oop_map_count++;
4272     assert(_nonstatic_oop_map_count &lt;= _max_nonstatic_oop_maps, &quot;range check&quot;);
4273     nonstatic_oop_map = last_oop_map();
4274     nonstatic_oop_map-&gt;set_offset(offset);
4275     nonstatic_oop_map-&gt;set_count(count);
4276   }
4277 }
4278 
4279 // general purpose copy, e.g. into allocated instanceKlass
4280 void OopMapBlocksBuilder::copy(OopMapBlock* dst) {
4281   if (_nonstatic_oop_map_count != 0) {
4282     memcpy(dst, _nonstatic_oop_maps, sizeof(OopMapBlock) * _nonstatic_oop_map_count);
4283   }
4284 }
4285 
4286 // Sort and compact adjacent blocks
4287 void OopMapBlocksBuilder::compact() {
4288   if (_nonstatic_oop_map_count &lt;= 1) {
4289     return;
4290   }
4291   /*
4292    * Since field layout sneeks in oops before values, we will be able to condense
4293    * blocks. There is potential to compact between super, own refs and values
4294    * containing refs.
4295    *
4296    * Currently compaction is slightly limited due to values being 8 byte aligned.
4297    * This may well change: FixMe if it doesn&#39;t, the code below is fairly general purpose
4298    * and maybe it doesn&#39;t need to be.
4299    */
4300   qsort(_nonstatic_oop_maps, _nonstatic_oop_map_count, sizeof(OopMapBlock),
4301         (_sort_Fn)OopMapBlock::compare_offset);
4302   if (_nonstatic_oop_map_count &lt; 2) {
4303     return;
4304   }
4305 
4306   // Make a temp copy, and iterate through and copy back into the original
4307   ResourceMark rm;
4308   OopMapBlock* oop_maps_copy =
4309       NEW_RESOURCE_ARRAY(OopMapBlock, _nonstatic_oop_map_count);
4310   OopMapBlock* oop_maps_copy_end = oop_maps_copy + _nonstatic_oop_map_count;
4311   copy(oop_maps_copy);
4312   OopMapBlock* nonstatic_oop_map = _nonstatic_oop_maps;
4313   unsigned int new_count = 1;
4314   oop_maps_copy++;
4315   while(oop_maps_copy &lt; oop_maps_copy_end) {
4316     assert(nonstatic_oop_map-&gt;offset() &lt; oop_maps_copy-&gt;offset(), &quot;invariant&quot;);
4317     if (nonstatic_oop_map-&gt;is_contiguous(oop_maps_copy-&gt;offset())) {
4318       nonstatic_oop_map-&gt;increment_count(oop_maps_copy-&gt;count());
4319     } else {
4320       nonstatic_oop_map++;
4321       new_count++;
4322       nonstatic_oop_map-&gt;set_offset(oop_maps_copy-&gt;offset());
4323       nonstatic_oop_map-&gt;set_count(oop_maps_copy-&gt;count());
4324     }
4325     oop_maps_copy++;
4326   }
4327   assert(new_count &lt;= _nonstatic_oop_map_count, &quot;end up with more maps after compact() ?&quot;);
4328   _nonstatic_oop_map_count = new_count;
4329 }
4330 
4331 void OopMapBlocksBuilder::print_on(outputStream* st) const {
4332   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
4333   if (_nonstatic_oop_map_count &gt; 0) {
4334     OopMapBlock* map = _nonstatic_oop_maps;
4335     OopMapBlock* last_map = last_oop_map();
4336     assert(map &lt;= last_map, &quot;Last less than first&quot;);
4337     while (map &lt;= last_map) {
4338       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),
4339                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());
4340       map++;
4341     }
4342   }
4343 }
4344 
4345 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
4346   print_on(st);
4347 }
4348 
4349 void ClassFileParser::throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,
4350                                                 const char* msg,
4351                                                 const Symbol* name,
4352                                                 const Symbol* sig) const {
4353 
4354   ResourceMark rm(THREAD);
4355   if (name == NULL || sig == NULL) {
4356     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,
4357         vmSymbols::java_lang_ClassFormatError(),
4358         &quot;class: %s - %s&quot;, _class_name-&gt;as_C_string(), msg);
4359   }
4360   else {
4361     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,
4362         vmSymbols::java_lang_ClassFormatError(),
4363         &quot;\&quot;%s\&quot; sig: \&quot;%s\&quot; class: %s - %s&quot;, name-&gt;as_C_string(), sig-&gt;as_C_string(),
4364         _class_name-&gt;as_C_string(), msg);
4365   }
4366 }
4367 
4368 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4369 void ClassFileParser::layout_fields(ConstantPool* cp,
4370                                     const FieldAllocationCount* fac,
4371                                     const ClassAnnotationCollector* parsed_annotations,
4372                                     FieldLayoutInfo* info,
4373                                     TRAPS) {
4374 
4375   assert(cp != NULL, &quot;invariant&quot;);
4376 
4377   // Field size and offset computation
4378   int nonstatic_field_size = _super_klass == NULL ? 0 :
4379                                _super_klass-&gt;nonstatic_field_size();
4380   int next_nonstatic_inline_type_offset = 0;
4381   int first_nonstatic_inline_type_offset = 0;
4382 
4383   // Fields that are inline types are handled differently depending if they are static or not:
4384   // - static fields are oops
4385   // - non-static fields are embedded
4386 
4387   // Count the contended fields by type.
4388   //
4389   // We ignore static fields, because @Contended is not supported for them.
4390   // The layout code below will also ignore the static fields.
4391   int nonstatic_contended_count = 0;
4392   FieldAllocationCount fac_contended;
4393   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4394     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4395     if (fs.is_contended()) {
4396       fac_contended.count[atype]++;
4397       if (!fs.access_flags().is_static()) {
4398         nonstatic_contended_count++;
4399       }
4400     }
4401   }
4402 
4403 
4404   // Calculate the starting byte offsets
4405   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
4406   // Inline types in static fields are not embedded, they are handled with oops
4407   int next_static_double_offset = next_static_oop_offset +
<a name="8" id="anc8"></a><span class="line-modified">4408                                   ((fac-&gt;count[STATIC_OOP] + fac-&gt;count[STATIC_FLATTENABLE]) * heapOopSize);</span>
4409   if (fac-&gt;count[STATIC_DOUBLE]) {
4410     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4411   }
4412 
4413   int next_static_word_offset   = next_static_double_offset +
4414                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4415   int next_static_short_offset  = next_static_word_offset +
4416                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4417   int next_static_byte_offset   = next_static_short_offset +
4418                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4419 
4420   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4421                                 nonstatic_field_size * heapOopSize;
4422 
4423   // First field of inline types is aligned on a long boundary in order to ease
4424   // in-lining of inline types (with header removal) in packed arrays and
<a name="9" id="anc9"></a><span class="line-modified">4425   // flatten inline types</span>
4426   int initial_inline_type_padding = 0;
4427   if (is_inline_type()) {
4428     int old = nonstatic_fields_start;
4429     nonstatic_fields_start = align_up(nonstatic_fields_start, BytesPerLong);
4430     initial_inline_type_padding = nonstatic_fields_start - old;
4431   }
4432 
4433   int next_nonstatic_field_offset = nonstatic_fields_start;
4434 
4435   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4436 
4437   // Class is contended, pad before all the fields
4438   if (is_contended_class) {
4439     next_nonstatic_field_offset += ContendedPaddingWidth;
4440   }
4441 
4442   // Temporary inline types restrictions
4443   if (is_inline_type()) {
4444     if (is_contended_class) {
4445       throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support @Contended annotation yet&quot;);
4446       return;
4447     }
4448   }
4449 
4450   // Compute the non-contended fields count.
4451   // The packing code below relies on these counts to determine if some field
4452   // can be squeezed into the alignment gap. Contended fields are obviously
4453   // exempt from that.
4454   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4455   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4456   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4457   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4458   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4459 
4460   int static_inline_type_count = 0;
4461   int nonstatic_inline_type_count = 0;
4462   int* nonstatic_inline_type_indexes = NULL;
4463   Klass** nonstatic_inline_type_klasses = NULL;
4464   unsigned int inline_type_oop_map_count = 0;
<a name="10" id="anc10"></a><span class="line-modified">4465   int not_flattened_inline_types = 0;</span>
4466   int not_atomic_inline_types = 0;
4467 
<a name="11" id="anc11"></a><span class="line-modified">4468   int max_nonstatic_inline_type = fac-&gt;count[NONSTATIC_FLATTENABLE] + 1;</span>
4469 
4470   nonstatic_inline_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,
4471                                                                max_nonstatic_inline_type);
4472   for (int i = 0; i &lt; max_nonstatic_inline_type; i++) {
4473     nonstatic_inline_type_indexes[i] = -1;
4474   }
4475   nonstatic_inline_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,
4476                                                                max_nonstatic_inline_type);
4477 
4478   for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {
<a name="12" id="anc12"></a><span class="line-modified">4479     if (fs.allocation_type() == STATIC_FLATTENABLE) {</span>
4480       ResourceMark rm;
4481       if (!fs.signature()-&gt;is_Q_signature()) {
4482         THROW(vmSymbols::java_lang_ClassFormatError());
4483       }
4484       static_inline_type_count++;
<a name="13" id="anc13"></a><span class="line-modified">4485     } else if (fs.allocation_type() == NONSTATIC_FLATTENABLE) {</span>
<span class="line-modified">4486       // Pre-resolve the flattenable field and check for inline type circularity issues.</span>
4487       ResourceMark rm;
4488       if (!fs.signature()-&gt;is_Q_signature()) {
4489         THROW(vmSymbols::java_lang_ClassFormatError());
4490       }
4491       Klass* klass =
<a name="14" id="anc14"></a><span class="line-modified">4492         SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,</span>
4493                                                             Handle(THREAD, _loader_data-&gt;class_loader()),
4494                                                             _protection_domain, true, CHECK);
4495       assert(klass != NULL, &quot;Sanity check&quot;);
4496       if (!klass-&gt;access_flags().is_inline_type()) {
4497         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
4498       }
4499       ValueKlass* vk = ValueKlass::cast(klass);
4500       // Conditions to apply flattening or not should be defined in a single place
<a name="15" id="anc15"></a><span class="line-modified">4501       bool too_big_to_flatten = (InlineFieldMaxFlatSize &gt;= 0 &amp;&amp;</span>
4502                                  (vk-&gt;size_helper() * HeapWordSize) &gt; InlineFieldMaxFlatSize);
<a name="16" id="anc16"></a><span class="line-modified">4503       bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();</span>
<span class="line-modified">4504       bool too_volatile_to_flatten = fs.access_flags().is_volatile();</span>
4505       if (vk-&gt;is_naturally_atomic()) {
<a name="17" id="anc17"></a><span class="line-modified">4506         too_atomic_to_flatten = false;</span>
<span class="line-modified">4507         //too_volatile_to_flatten = false; //FIXME</span>
<span class="line-modified">4508         // volatile fields are currently never flattened, this could change in the future</span>
4509       }
<a name="18" id="anc18"></a><span class="line-modified">4510       if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {</span>
4511         nonstatic_inline_type_indexes[nonstatic_inline_type_count] = fs.index();
4512         nonstatic_inline_type_klasses[nonstatic_inline_type_count] = klass;
4513         nonstatic_inline_type_count++;
4514 
4515         ValueKlass* vklass = ValueKlass::cast(klass);
4516         if (vklass-&gt;contains_oops()) {
4517           inline_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();
4518         }
<a name="19" id="anc19"></a><span class="line-modified">4519         fs.set_flattened(true);</span>
4520         if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note
4521           not_atomic_inline_types++;
4522         }
4523       } else {
<a name="20" id="anc20"></a><span class="line-modified">4524         not_flattened_inline_types++;</span>
<span class="line-modified">4525         fs.set_flattened(false);</span>
4526       }
4527     }
4528   }
4529 
<a name="21" id="anc21"></a><span class="line-modified">4530   // Adjusting non_static_oop_count to take into account not flattened inline types;</span>
<span class="line-modified">4531   nonstatic_oop_count += not_flattened_inline_types;</span>
4532 
4533   // Total non-static fields count, including every contended field
4534   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4535                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
<a name="22" id="anc22"></a><span class="line-modified">4536                                         fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_FLATTENABLE];</span>
4537 
4538   const bool super_has_nonstatic_fields =
4539           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4540   const bool has_nonstatic_fields =
4541     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
4542   const bool has_nonstatic_value_fields = nonstatic_inline_type_count &gt; 0;
4543 
4544   if (is_inline_type() &amp;&amp; (!has_nonstatic_fields)) {
4545     // There are a number of fixes required throughout the type system and JIT
4546     throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support zero instance size yet&quot;);
4547     return;
4548   }
4549 
4550   // Prepare list of oops for oop map generation.
4551   //
4552   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4553   // regions. offset[i] is the start of the i-th region, which then has
4554   // count[i] oops following. Before we know how many regions are required,
4555   // we pessimistically allocate the maps to fit all the oops into the
4556   // distinct regions.
4557   //
4558   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
4559   int max_oop_map_count =
4560       super_oop_map_count +
4561       fac-&gt;count[NONSTATIC_OOP] +
4562       inline_type_oop_map_count +
<a name="23" id="anc23"></a><span class="line-modified">4563       not_flattened_inline_types;</span>
4564 
4565   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
4566   if (super_oop_map_count &gt; 0) {
4567     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
4568                                                     _super_klass-&gt;nonstatic_oop_map_count());
4569   }
4570 
4571   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4572 
4573   bool compact_fields  = true;
4574   bool allocate_oops_first = false;
4575 
4576   int next_nonstatic_oop_offset = 0;
4577   int next_nonstatic_double_offset = 0;
4578 
4579   // Rearrange fields for a given allocation style
4580   if (allocate_oops_first) {
4581     // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields
4582     next_nonstatic_oop_offset    = next_nonstatic_field_offset;
4583     next_nonstatic_double_offset = next_nonstatic_oop_offset +
4584                                     (nonstatic_oop_count * heapOopSize);
4585   } else {
4586     // Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields
4587     next_nonstatic_double_offset = next_nonstatic_field_offset;
4588   }
4589 
4590   int nonstatic_oop_space_count   = 0;
4591   int nonstatic_word_space_count  = 0;
4592   int nonstatic_short_space_count = 0;
4593   int nonstatic_byte_space_count  = 0;
4594   int nonstatic_oop_space_offset = 0;
4595   int nonstatic_word_space_offset = 0;
4596   int nonstatic_short_space_offset = 0;
4597   int nonstatic_byte_space_offset = 0;
4598 
4599   // Try to squeeze some of the fields into the gaps due to
4600   // long/double alignment.
4601   if (nonstatic_double_count &gt; 0) {
4602     int offset = next_nonstatic_double_offset;
4603     next_nonstatic_double_offset = align_up(offset, BytesPerLong);
4604     if (compact_fields &amp;&amp; offset != next_nonstatic_double_offset) {
4605       // Allocate available fields into the gap before double field.
4606       int length = next_nonstatic_double_offset - offset;
4607       assert(length == BytesPerInt, &quot;&quot;);
4608       nonstatic_word_space_offset = offset;
4609       if (nonstatic_word_count &gt; 0) {
4610         nonstatic_word_count      -= 1;
4611         nonstatic_word_space_count = 1; // Only one will fit
4612         length -= BytesPerInt;
4613         offset += BytesPerInt;
4614       }
4615       nonstatic_short_space_offset = offset;
4616       while (length &gt;= BytesPerShort &amp;&amp; nonstatic_short_count &gt; 0) {
4617         nonstatic_short_count       -= 1;
4618         nonstatic_short_space_count += 1;
4619         length -= BytesPerShort;
4620         offset += BytesPerShort;
4621       }
4622       nonstatic_byte_space_offset = offset;
4623       while (length &gt; 0 &amp;&amp; nonstatic_byte_count &gt; 0) {
4624         nonstatic_byte_count       -= 1;
4625         nonstatic_byte_space_count += 1;
4626         length -= 1;
4627       }
4628       // Allocate oop field in the gap if there are no other fields for that.
4629       nonstatic_oop_space_offset = offset;
4630       if (length &gt;= heapOopSize &amp;&amp; nonstatic_oop_count &gt; 0 &amp;&amp;
4631           !allocate_oops_first) { // when oop fields not first
4632         nonstatic_oop_count      -= 1;
4633         nonstatic_oop_space_count = 1; // Only one will fit
4634         length -= heapOopSize;
4635         offset += heapOopSize;
4636       }
4637     }
4638   }
4639 
4640   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4641                                      (nonstatic_double_count * BytesPerLong);
4642   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4643                                       (nonstatic_word_count * BytesPerInt);
4644   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4645                                      (nonstatic_short_count * BytesPerShort);
4646   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4647                                        nonstatic_byte_count;
4648 
4649   // let oops jump before padding with this allocation style
4650   if (!allocate_oops_first) {
4651     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4652     if( nonstatic_oop_count &gt; 0 ) {
4653       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4654     }
4655     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4656   }
4657 
4658   // Aligning embedded inline types
4659   // bug below, the current algorithm to layout embedded inline types always put them at the
4660   // end of the layout, which doesn&#39;t match the different allocation policies the VM is
4661   // supposed to provide =&gt; FixMe
4662   // Note also that the current alignment policy is to make each inline type starting on a
4663   // 64 bits boundary. This could be optimized later. For instance, it could be nice to
4664   // align inline types according to their most constrained internal type.
4665   next_nonstatic_inline_type_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4666   int next_inline_type_index = 0;
4667 
4668   // Iterate over fields again and compute correct offsets.
4669   // The field allocation type was temporarily stored in the offset slot.
4670   // oop fields are located before non-oop fields (static and non-static).
4671   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4672 
4673     // skip already laid out fields
4674     if (fs.is_offset_set()) continue;
4675 
4676     // contended instance fields are handled below
4677     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4678 
4679     int real_offset = 0;
4680     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4681 
4682     // pack the rest of the fields
4683     switch (atype) {
4684       // Inline types in static fields are handled with oops
<a name="24" id="anc24"></a><span class="line-modified">4685       case STATIC_FLATTENABLE:   // Fallthrough</span>
4686       case STATIC_OOP:
4687         real_offset = next_static_oop_offset;
4688         next_static_oop_offset += heapOopSize;
4689         break;
4690       case STATIC_BYTE:
4691         real_offset = next_static_byte_offset;
4692         next_static_byte_offset += 1;
4693         break;
4694       case STATIC_SHORT:
4695         real_offset = next_static_short_offset;
4696         next_static_short_offset += BytesPerShort;
4697         break;
4698       case STATIC_WORD:
4699         real_offset = next_static_word_offset;
4700         next_static_word_offset += BytesPerInt;
4701         break;
4702       case STATIC_DOUBLE:
4703         real_offset = next_static_double_offset;
4704         next_static_double_offset += BytesPerLong;
4705         break;
<a name="25" id="anc25"></a><span class="line-modified">4706       case NONSTATIC_FLATTENABLE:</span>
<span class="line-modified">4707         if (fs.is_flattened()) {</span>
4708           Klass* klass = nonstatic_inline_type_klasses[next_inline_type_index];
4709           assert(klass != NULL, &quot;Klass should have been loaded and resolved earlier&quot;);
4710           assert(klass-&gt;access_flags().is_inline_type(),&quot;Must be an inline type&quot;);
4711           ValueKlass* vklass = ValueKlass::cast(klass);
4712           real_offset = next_nonstatic_inline_type_offset;
4713           next_nonstatic_inline_type_offset += (vklass-&gt;size_helper()) * wordSize - vklass-&gt;first_field_offset();
4714           // aligning next inline type on a 64 bits boundary
4715           next_nonstatic_inline_type_offset = align_up(next_nonstatic_inline_type_offset, BytesPerLong);
4716           next_inline_type_index += 1;
4717 
4718           if (vklass-&gt;contains_oops()) { // add flatten oop maps
4719             int diff = real_offset - vklass-&gt;first_field_offset();
4720             const OopMapBlock* map = vklass-&gt;start_of_nonstatic_oop_maps();
4721             const OopMapBlock* const last_map = map + vklass-&gt;nonstatic_oop_map_count();
4722             while (map &lt; last_map) {
4723               nonstatic_oop_maps-&gt;add(map-&gt;offset() + diff, map-&gt;count());
4724               map++;
4725             }
4726           }
4727           break;
4728         } else {
4729           // Fall through
4730         }
4731       case NONSTATIC_OOP:
4732         if( nonstatic_oop_space_count &gt; 0 ) {
4733           real_offset = nonstatic_oop_space_offset;
4734           nonstatic_oop_space_offset += heapOopSize;
4735           nonstatic_oop_space_count  -= 1;
4736         } else {
4737           real_offset = next_nonstatic_oop_offset;
4738           next_nonstatic_oop_offset += heapOopSize;
4739         }
4740         nonstatic_oop_maps-&gt;add(real_offset, 1);
4741         break;
4742       case NONSTATIC_BYTE:
4743         if( nonstatic_byte_space_count &gt; 0 ) {
4744           real_offset = nonstatic_byte_space_offset;
4745           nonstatic_byte_space_offset += 1;
4746           nonstatic_byte_space_count  -= 1;
4747         } else {
4748           real_offset = next_nonstatic_byte_offset;
4749           next_nonstatic_byte_offset += 1;
4750         }
4751         break;
4752       case NONSTATIC_SHORT:
4753         if( nonstatic_short_space_count &gt; 0 ) {
4754           real_offset = nonstatic_short_space_offset;
4755           nonstatic_short_space_offset += BytesPerShort;
4756           nonstatic_short_space_count  -= 1;
4757         } else {
4758           real_offset = next_nonstatic_short_offset;
4759           next_nonstatic_short_offset += BytesPerShort;
4760         }
4761         break;
4762       case NONSTATIC_WORD:
4763         if( nonstatic_word_space_count &gt; 0 ) {
4764           real_offset = nonstatic_word_space_offset;
4765           nonstatic_word_space_offset += BytesPerInt;
4766           nonstatic_word_space_count  -= 1;
4767         } else {
4768           real_offset = next_nonstatic_word_offset;
4769           next_nonstatic_word_offset += BytesPerInt;
4770         }
4771         break;
4772       case NONSTATIC_DOUBLE:
4773         real_offset = next_nonstatic_double_offset;
4774         next_nonstatic_double_offset += BytesPerLong;
4775         break;
4776       default:
4777         ShouldNotReachHere();
4778     }
4779     fs.set_offset(real_offset);
4780   }
4781 
4782 
4783   // Handle the contended cases.
4784   //
4785   // Each contended field should not intersect the cache line with another contended field.
4786   // In the absence of alignment information, we end up with pessimistically separating
4787   // the fields with full-width padding.
4788   //
4789   // Additionally, this should not break alignment for the fields, so we round the alignment up
4790   // for each field.
4791   if (nonstatic_contended_count &gt; 0) {
4792 
4793     // if there is at least one contended field, we need to have pre-padding for them
4794     next_nonstatic_padded_offset += ContendedPaddingWidth;
4795 
4796     // collect all contended groups
4797     ResourceBitMap bm(cp-&gt;size());
4798     for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4799       // skip already laid out fields
4800       if (fs.is_offset_set()) continue;
4801 
4802       if (fs.is_contended()) {
4803         bm.set_bit(fs.contended_group());
4804       }
4805     }
4806 
4807     int current_group = -1;
4808     while ((current_group = (int)bm.get_next_one_offset(current_group + 1)) != (int)bm.size()) {
4809 
4810       for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4811 
4812         // skip already laid out fields
4813         if (fs.is_offset_set()) continue;
4814 
4815         // skip non-contended fields and fields from different group
4816         if (!fs.is_contended() || (fs.contended_group() != current_group)) continue;
4817 
4818         // handle statics below
4819         if (fs.access_flags().is_static()) continue;
4820 
4821         int real_offset = 0;
4822         FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4823 
4824         switch (atype) {
4825           case NONSTATIC_BYTE:
4826             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, 1);
4827             real_offset = next_nonstatic_padded_offset;
4828             next_nonstatic_padded_offset += 1;
4829             break;
4830 
4831           case NONSTATIC_SHORT:
4832             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4833             real_offset = next_nonstatic_padded_offset;
4834             next_nonstatic_padded_offset += BytesPerShort;
4835             break;
4836 
4837           case NONSTATIC_WORD:
4838             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4839             real_offset = next_nonstatic_padded_offset;
4840             next_nonstatic_padded_offset += BytesPerInt;
4841             break;
4842 
4843           case NONSTATIC_DOUBLE:
4844             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4845             real_offset = next_nonstatic_padded_offset;
4846             next_nonstatic_padded_offset += BytesPerLong;
4847             break;
4848 
4849             // Inline types in static fields are handled with oops
<a name="26" id="anc26"></a><span class="line-modified">4850           case NONSTATIC_FLATTENABLE:</span>
4851             throwInlineTypeLimitation(THREAD_AND_LOCATION,
4852                                       &quot;@Contended annotation not supported for inline types yet&quot;, fs.name(), fs.signature());
4853             return;
4854 
4855           case NONSTATIC_OOP:
4856             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4857             real_offset = next_nonstatic_padded_offset;
4858             next_nonstatic_padded_offset += heapOopSize;
4859             nonstatic_oop_maps-&gt;add(real_offset, 1);
4860             break;
4861 
4862           default:
4863             ShouldNotReachHere();
4864         }
4865 
4866         if (fs.contended_group() == 0) {
4867           // Contended group defines the equivalence class over the fields:
4868           // the fields within the same contended group are not inter-padded.
4869           // The only exception is default group, which does not incur the
4870           // equivalence, and so requires intra-padding.
4871           next_nonstatic_padded_offset += ContendedPaddingWidth;
4872         }
4873 
4874         fs.set_offset(real_offset);
4875       } // for
4876 
4877       // Start laying out the next group.
4878       // Note that this will effectively pad the last group in the back;
4879       // this is expected to alleviate memory contention effects for
4880       // subclass fields and/or adjacent object.
4881       // If this was the default group, the padding is already in place.
4882       if (current_group != 0) {
4883         next_nonstatic_padded_offset += ContendedPaddingWidth;
4884       }
4885     }
4886 
4887     // handle static fields
4888   }
4889 
4890   // Entire class is contended, pad in the back.
4891   // This helps to alleviate memory contention effects for subclass fields
4892   // and/or adjacent object.
4893   if (is_contended_class) {
4894     assert(!is_inline_type(), &quot;@Contended not supported for inline types yet&quot;);
4895     next_nonstatic_padded_offset += ContendedPaddingWidth;
4896   }
4897 
4898   int notaligned_nonstatic_fields_end;
4899   if (nonstatic_inline_type_count != 0) {
4900     notaligned_nonstatic_fields_end = next_nonstatic_inline_type_offset;
4901   } else {
4902     notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;
4903   }
4904 
4905   int nonstatic_field_sz_align = heapOopSize;
4906   if (is_inline_type()) {
4907     if ((notaligned_nonstatic_fields_end - nonstatic_fields_start) &gt; heapOopSize) {
4908       nonstatic_field_sz_align = BytesPerLong; // value copy of fields only uses jlong copy
4909     }
4910   }
4911   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, nonstatic_field_sz_align);
4912   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
4913   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
4914 
4915   int static_field_size         = (static_fields_end -
4916                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4917   nonstatic_field_size          = nonstatic_field_size +
4918                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4919 
4920   int instance_size             = align_object_size(instance_end / wordSize);
4921 
4922   assert(instance_size == align_object_size(align_up(
4923          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)
4924          + initial_inline_type_padding, wordSize) / wordSize), &quot;consistent layout helper value&quot;);
4925 
4926 
4927   // Invariant: nonstatic_field end/start should only change if there are
4928   // nonstatic fields in the class, or if the class is contended. We compare
4929   // against the non-aligned value, so that end alignment will not fail the
4930   // assert without actually having the fields.
4931   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4932          is_contended_class ||
4933          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4934 
4935   // Number of non-static oop map blocks allocated at end of klass.
4936   nonstatic_oop_maps-&gt;compact();
4937 
4938 #ifndef PRODUCT
4939   if ((PrintFieldLayout &amp;&amp; !is_inline_type()) ||
4940       (PrintInlineLayout &amp;&amp; (is_inline_type() || has_nonstatic_value_fields))) {
4941     print_field_layout(_class_name,
4942           _fields,
4943           cp,
4944           instance_size,
4945           nonstatic_fields_start,
4946           nonstatic_fields_end,
4947           static_fields_end);
4948     nonstatic_oop_maps-&gt;print_on(tty);
4949     tty-&gt;print(&quot;\n&quot;);
4950     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);
4951     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);
4952     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);
4953     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);
4954     tty-&gt;print_cr(&quot;---&quot;);
4955   }
4956 
4957 #endif
4958   // Pass back information needed for InstanceKlass creation
4959   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4960   info-&gt;_instance_size = instance_size;
4961   info-&gt;_static_field_size = static_field_size;
4962   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4963   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;
<a name="27" id="anc27"></a>
4964 
4965   // An inline type is naturally atomic if it has just one field, and
4966   // that field is simple enough.
4967   info-&gt;_is_naturally_atomic = (is_inline_type() &amp;&amp;
4968                                 !super_has_nonstatic_fields &amp;&amp;
4969                                 (nonstatic_fields_count &lt;= 1) &amp;&amp;
4970                                 (not_atomic_inline_types == 0) &amp;&amp;
4971                                 (nonstatic_contended_count == 0));
4972   // This may be too restrictive, since if all the fields fit in 64
4973   // bits we could make the decision to align instances of this class
4974   // to 64-bit boundaries, and load and store them as single words.
4975   // And on machines which supported larger atomics we could similarly
4976   // allow larger values to be atomic, if properly aligned.
4977 }
4978 
4979 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4980   assert(ik != NULL, &quot;invariant&quot;);
4981 
4982   const Klass* const super = ik-&gt;super();
4983 
4984   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4985   // in which case we don&#39;t have to register objects as finalizable
4986   if (!_has_empty_finalizer) {
4987     if (_has_finalizer ||
4988         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4989       ik-&gt;set_has_finalizer();
4990     }
4991   }
4992 
4993 #ifdef ASSERT
4994   bool f = false;
4995   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4996                                            vmSymbols::void_method_signature());
4997   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4998       f = true;
4999   }
5000 
5001   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
5002   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
5003   // will not work as expected we shouldn&#39;t abort vm in this case
5004   if (!ik-&gt;has_redefined_this_or_super()) {
5005     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
5006   }
5007 #endif
5008 
5009   // Check if this klass supports the java.lang.Cloneable interface
5010   if (SystemDictionary::Cloneable_klass_loaded()) {
5011     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {
5012       if (ik-&gt;is_value()) {
5013         Thread *THREAD = Thread::current();
5014         throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support Cloneable&quot;);
5015         return;
5016       }
5017       ik-&gt;set_is_cloneable();
5018     }
5019   }
5020 
5021   // Check if this klass has a vanilla default constructor
5022   if (super == NULL) {
5023     // java.lang.Object has empty default constructor
5024     ik-&gt;set_has_vanilla_constructor();
5025   } else {
5026     if (super-&gt;has_vanilla_constructor() &amp;&amp;
5027         _has_vanilla_constructor) {
5028       ik-&gt;set_has_vanilla_constructor();
5029     }
5030 #ifdef ASSERT
5031     bool v = false;
5032     if (super-&gt;has_vanilla_constructor()) {
5033       const Method* const constructor =
5034         ik-&gt;find_method(vmSymbols::object_initializer_name(),
5035                        vmSymbols::void_method_signature());
5036       if (constructor != NULL &amp;&amp; constructor-&gt;is_vanilla_constructor()) {
5037         v = true;
5038       }
5039     }
5040     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
5041 #endif
5042   }
5043 
5044   // If it cannot be fast-path allocated, set a bit in the layout helper.
5045   // See documentation of InstanceKlass::can_be_fastpath_allocated().
5046   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
5047   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
5048       || ik-&gt;is_abstract() || ik-&gt;is_interface()
5049       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
5050       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
5051     // Forbid fast-path allocation.
5052     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
5053     ik-&gt;set_layout_helper(lh);
5054   }
5055 }
5056 
5057 bool ClassFileParser::supports_inline_types() const {
5058   // Inline types are only supported by class file version 55 and later
5059   return _major_version &gt;= JAVA_11_VERSION;
5060 }
5061 
5062 // utility methods for appending an array with check for duplicates
5063 
5064 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
5065                               const Array&lt;InstanceKlass*&gt;* const ifs) {
5066   // iterate over new interfaces
5067   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
5068     InstanceKlass* const e = ifs-&gt;at(i);
5069     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
5070     // add new interface
5071     result-&gt;append_if_missing(e);
5072   }
5073 }
5074 
5075 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
5076                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
5077                                                             ClassLoaderData* loader_data,
5078                                                             TRAPS) {
5079   assert(local_ifs != NULL, &quot;invariant&quot;);
5080   assert(loader_data != NULL, &quot;invariant&quot;);
5081 
5082   // Compute maximum size for transitive interfaces
5083   int max_transitive_size = 0;
5084   int super_size = 0;
5085   // Add superclass transitive interfaces size
5086   if (super != NULL) {
5087     super_size = super-&gt;transitive_interfaces()-&gt;length();
5088     max_transitive_size += super_size;
5089   }
5090   // Add local interfaces&#39; super interfaces
5091   const int local_size = local_ifs-&gt;length();
5092   for (int i = 0; i &lt; local_size; i++) {
5093     InstanceKlass* const l = local_ifs-&gt;at(i);
5094     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
5095   }
5096   // Finally add local interfaces
5097   max_transitive_size += local_size;
5098   // Construct array
5099   if (max_transitive_size == 0) {
5100     // no interfaces, use canonicalized array
5101     return Universe::the_empty_instance_klass_array();
5102   } else if (max_transitive_size == super_size) {
5103     // no new local interfaces added, share superklass&#39; transitive interface array
5104     return super-&gt;transitive_interfaces();
5105     // The three lines below are commented to work around bug JDK-8245487
5106 //  } else if (max_transitive_size == local_size) {
5107 //    // only local interfaces added, share local interface array
5108 //    return local_ifs;
5109   } else {
5110     ResourceMark rm;
5111     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
5112 
5113     // Copy down from superclass
5114     if (super != NULL) {
5115       append_interfaces(result, super-&gt;transitive_interfaces());
5116     }
5117 
5118     // Copy down from local interfaces&#39; superinterfaces
5119     for (int i = 0; i &lt; local_size; i++) {
5120       InstanceKlass* const l = local_ifs-&gt;at(i);
5121       append_interfaces(result, l-&gt;transitive_interfaces());
5122     }
5123     // Finally add local interfaces
5124     append_interfaces(result, local_ifs);
5125 
5126     // length will be less than the max_transitive_size if duplicates were removed
5127     const int length = result-&gt;length();
5128     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
5129 
5130     if (length == 1 &amp;&amp; result-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {
5131       return Universe::the_single_IdentityObject_klass_array();
5132     }
5133 
5134     Array&lt;InstanceKlass*&gt;* const new_result =
5135       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
5136     for (int i = 0; i &lt; length; i++) {
5137       InstanceKlass* const e = result-&gt;at(i);
5138       assert(e != NULL, &quot;just checking&quot;);
5139       new_result-&gt;at_put(i, e);
5140     }
5141     return new_result;
5142   }
5143 }
5144 
5145 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
5146   assert(this_klass != NULL, &quot;invariant&quot;);
5147   const Klass* const super = this_klass-&gt;super();
5148 
5149   if (super != NULL) {
5150     const InstanceKlass* super_ik = InstanceKlass::cast(super);
5151 
5152     if (super-&gt;is_final()) {
5153       ResourceMark rm(THREAD);
5154       Exceptions::fthrow(
5155         THREAD_AND_LOCATION,
5156         vmSymbols::java_lang_VerifyError(),
5157         &quot;class %s cannot inherit from final class %s&quot;,
5158         this_klass-&gt;external_name(),
5159         super_ik-&gt;external_name());
5160       return;
5161     }
5162 
5163     if (super_ik-&gt;is_sealed() &amp;&amp; !super_ik-&gt;has_as_permitted_subclass(this_klass)) {
5164       ResourceMark rm(THREAD);
5165       Exceptions::fthrow(
5166         THREAD_AND_LOCATION,
5167         vmSymbols::java_lang_IncompatibleClassChangeError(),
5168         &quot;class %s cannot inherit from sealed class %s&quot;,
5169         this_klass-&gt;external_name(),
5170         super_ik-&gt;external_name());
5171       return;
5172     }
5173 
5174     // If the loader is not the boot loader then throw an exception if its
5175     // superclass is in package jdk.internal.reflect and its loader is not a
5176     // special reflection class loader
5177     if (!this_klass-&gt;class_loader_data()-&gt;is_the_null_class_loader_data()) {
5178       PackageEntry* super_package = super-&gt;package();
5179       if (super_package != NULL &amp;&amp;
5180           super_package-&gt;name()-&gt;fast_compare(vmSymbols::jdk_internal_reflect()) == 0 &amp;&amp;
5181           !java_lang_ClassLoader::is_reflection_class_loader(this_klass-&gt;class_loader())) {
5182         ResourceMark rm(THREAD);
5183         Exceptions::fthrow(
5184           THREAD_AND_LOCATION,
5185           vmSymbols::java_lang_IllegalAccessError(),
5186           &quot;class %s loaded by %s cannot access jdk/internal/reflect superclass %s&quot;,
5187           this_klass-&gt;external_name(),
5188           this_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
5189           super-&gt;external_name());
5190         return;
5191       }
5192     }
5193 
5194     Reflection::VerifyClassAccessResults vca_result =
5195       Reflection::verify_class_access(this_klass, InstanceKlass::cast(super), false);
5196     if (vca_result != Reflection::ACCESS_OK) {
5197       ResourceMark rm(THREAD);
5198       char* msg = Reflection::verify_class_access_msg(this_klass,
5199                                                       InstanceKlass::cast(super),
5200                                                       vca_result);
5201       if (msg == NULL) {
5202         bool same_module = (this_klass-&gt;module() == super-&gt;module());
5203         Exceptions::fthrow(
5204           THREAD_AND_LOCATION,
5205           vmSymbols::java_lang_IllegalAccessError(),
5206           &quot;class %s cannot access its %ssuperclass %s (%s%s%s)&quot;,
5207           this_klass-&gt;external_name(),
5208           super-&gt;is_abstract() ? &quot;abstract &quot; : &quot;&quot;,
5209           super-&gt;external_name(),
5210           (same_module) ? this_klass-&gt;joint_in_module_of_loader(super) : this_klass-&gt;class_in_module_of_loader(),
5211           (same_module) ? &quot;&quot; : &quot;; &quot;,
5212           (same_module) ? &quot;&quot; : super-&gt;class_in_module_of_loader());
5213       } else {
5214         // Add additional message content.
5215         Exceptions::fthrow(
5216           THREAD_AND_LOCATION,
5217           vmSymbols::java_lang_IllegalAccessError(),
5218           &quot;superclass access check failed: %s&quot;,
5219           msg);
5220       }
5221     }
5222   }
5223 }
5224 
5225 
5226 static void check_super_interface_access(const InstanceKlass* this_klass, TRAPS) {
5227   assert(this_klass != NULL, &quot;invariant&quot;);
5228   const Array&lt;InstanceKlass*&gt;* const local_interfaces = this_klass-&gt;local_interfaces();
5229   const int lng = local_interfaces-&gt;length();
5230   for (int i = lng - 1; i &gt;= 0; i--) {
5231     InstanceKlass* const k = local_interfaces-&gt;at(i);
5232     assert (k != NULL &amp;&amp; k-&gt;is_interface(), &quot;invalid interface&quot;);
5233 
5234     if (k-&gt;is_sealed() &amp;&amp; !k-&gt;has_as_permitted_subclass(this_klass)) {
5235       ResourceMark rm(THREAD);
5236       Exceptions::fthrow(
5237         THREAD_AND_LOCATION,
5238         vmSymbols::java_lang_IncompatibleClassChangeError(),
5239         &quot;class %s cannot %s sealed interface %s&quot;,
5240         this_klass-&gt;external_name(),
5241         this_klass-&gt;is_interface() ? &quot;extend&quot; : &quot;implement&quot;,
5242         k-&gt;external_name());
5243       return;
5244     }
5245 
5246     Reflection::VerifyClassAccessResults vca_result =
5247       Reflection::verify_class_access(this_klass, k, false);
5248     if (vca_result != Reflection::ACCESS_OK) {
5249       ResourceMark rm(THREAD);
5250       char* msg = Reflection::verify_class_access_msg(this_klass,
5251                                                       k,
5252                                                       vca_result);
5253       if (msg == NULL) {
5254         bool same_module = (this_klass-&gt;module() == k-&gt;module());
5255         Exceptions::fthrow(
5256           THREAD_AND_LOCATION,
5257           vmSymbols::java_lang_IllegalAccessError(),
5258           &quot;class %s cannot access its superinterface %s (%s%s%s)&quot;,
5259           this_klass-&gt;external_name(),
5260           k-&gt;external_name(),
5261           (same_module) ? this_klass-&gt;joint_in_module_of_loader(k) : this_klass-&gt;class_in_module_of_loader(),
5262           (same_module) ? &quot;&quot; : &quot;; &quot;,
5263           (same_module) ? &quot;&quot; : k-&gt;class_in_module_of_loader());
5264       } else {
5265         // Add additional message content.
5266         Exceptions::fthrow(
5267           THREAD_AND_LOCATION,
5268           vmSymbols::java_lang_IllegalAccessError(),
5269           &quot;superinterface check failed: %s&quot;,
5270           msg);
5271       }
5272     }
5273   }
5274 }
5275 
5276 
5277 static void check_final_method_override(const InstanceKlass* this_klass, TRAPS) {
5278   assert(this_klass != NULL, &quot;invariant&quot;);
5279   const Array&lt;Method*&gt;* const methods = this_klass-&gt;methods();
5280   const int num_methods = methods-&gt;length();
5281 
5282   // go thru each method and check if it overrides a final method
5283   for (int index = 0; index &lt; num_methods; index++) {
5284     const Method* const m = methods-&gt;at(index);
5285 
5286     // skip private, static, and &lt;init&gt; methods
5287     if ((!m-&gt;is_private() &amp;&amp; !m-&gt;is_static()) &amp;&amp;
5288         (m-&gt;name() != vmSymbols::object_initializer_name())) {
5289 
5290       const Symbol* const name = m-&gt;name();
5291       const Symbol* const signature = m-&gt;signature();
5292       const Klass* k = this_klass-&gt;super();
5293       const Method* super_m = NULL;
5294       while (k != NULL) {
5295         // skip supers that don&#39;t have final methods.
5296         if (k-&gt;has_final_method()) {
5297           // lookup a matching method in the super class hierarchy
5298           super_m = InstanceKlass::cast(k)-&gt;lookup_method(name, signature);
5299           if (super_m == NULL) {
5300             break; // didn&#39;t find any match; get out
5301           }
5302 
5303           if (super_m-&gt;is_final() &amp;&amp; !super_m-&gt;is_static() &amp;&amp;
5304               !super_m-&gt;access_flags().is_private()) {
5305             // matching method in super is final, and not static or private
5306             bool can_access = Reflection::verify_member_access(this_klass,
5307                                                                super_m-&gt;method_holder(),
5308                                                                super_m-&gt;method_holder(),
5309                                                                super_m-&gt;access_flags(),
5310                                                               false, false, CHECK);
5311             if (can_access) {
5312               // this class can access super final method and therefore override
5313               ResourceMark rm(THREAD);
5314               Exceptions::fthrow(THREAD_AND_LOCATION,
5315                                  vmSymbols::java_lang_VerifyError(),
5316                                  &quot;class %s overrides final method %s.%s%s&quot;,
5317                                  this_klass-&gt;external_name(),
5318                                  super_m-&gt;method_holder()-&gt;external_name(),
5319                                  name-&gt;as_C_string(),
5320                                  signature-&gt;as_C_string()
5321                                  );
5322               return;
5323             }
5324           }
5325 
5326           // continue to look from super_m&#39;s holder&#39;s super.
5327           k = super_m-&gt;method_holder()-&gt;super();
5328           continue;
5329         }
5330 
5331         k = k-&gt;super();
5332       }
5333     }
5334   }
5335 }
5336 
5337 
5338 // assumes that this_klass is an interface
5339 static void check_illegal_static_method(const InstanceKlass* this_klass, TRAPS) {
5340   assert(this_klass != NULL, &quot;invariant&quot;);
5341   assert(this_klass-&gt;is_interface(), &quot;not an interface&quot;);
5342   const Array&lt;Method*&gt;* methods = this_klass-&gt;methods();
5343   const int num_methods = methods-&gt;length();
5344 
5345   for (int index = 0; index &lt; num_methods; index++) {
5346     const Method* const m = methods-&gt;at(index);
5347     // if m is static and not the init method, throw a verify error
5348     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
5349       ResourceMark rm(THREAD);
5350       Exceptions::fthrow(
5351         THREAD_AND_LOCATION,
5352         vmSymbols::java_lang_VerifyError(),
5353         &quot;Illegal static method %s in interface %s&quot;,
5354         m-&gt;name()-&gt;as_C_string(),
5355         this_klass-&gt;external_name()
5356       );
5357       return;
5358     }
5359   }
5360 }
5361 
5362 // utility methods for format checking
5363 
5364 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
5365   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
5366   const bool is_inline_type = (flags &amp; JVM_ACC_VALUE) != 0;
5367   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
5368   assert(supports_inline_types() || !is_inline_type, &quot;JVM_ACC_VALUE should not be set&quot;);
5369   if (is_module) {
5370     ResourceMark rm(THREAD);
5371     Exceptions::fthrow(
5372       THREAD_AND_LOCATION,
5373       vmSymbols::java_lang_NoClassDefFoundError(),
5374       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
5375       _class_name-&gt;as_C_string());
5376     return;
5377   }
5378 
5379   if (is_inline_type &amp;&amp; !EnableValhalla) {
5380     ResourceMark rm(THREAD);
5381     Exceptions::fthrow(
5382       THREAD_AND_LOCATION,
5383       vmSymbols::java_lang_ClassFormatError(),
5384       &quot;Class modifier ACC_VALUE in class %s requires option -XX:+EnableValhalla&quot;,
5385       _class_name-&gt;as_C_string()
5386     );
5387   }
5388 
5389   if (!_need_verify) { return; }
5390 
5391   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
5392   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
5393   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
5394   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
5395   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
5396   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
5397   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5398   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
5399 
5400   if ((is_abstract &amp;&amp; is_final) ||
5401       (is_interface &amp;&amp; !is_abstract) ||
5402       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
5403       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation) ||
5404       (is_inline_type &amp;&amp; (is_interface || is_abstract || is_enum || !is_final))) {
5405     ResourceMark rm(THREAD);
5406     const char* class_note = &quot;&quot;;
5407     if (is_inline_type)  class_note = &quot; (an inline class)&quot;;
5408     Exceptions::fthrow(
5409       THREAD_AND_LOCATION,
5410       vmSymbols::java_lang_ClassFormatError(),
5411       &quot;Illegal class modifiers in class %s%s: 0x%X&quot;,
5412       _class_name-&gt;as_C_string(), class_note, flags
5413     );
5414     return;
5415   }
5416 }
5417 
5418 static bool has_illegal_visibility(jint flags) {
5419   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5420   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5421   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5422 
5423   return ((is_public &amp;&amp; is_protected) ||
5424           (is_public &amp;&amp; is_private) ||
5425           (is_protected &amp;&amp; is_private));
5426 }
5427 
5428 // A legal major_version.minor_version must be one of the following:
5429 //
5430 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.
5431 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.
5432 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.
5433 //
5434 static void verify_class_version(u2 major, u2 minor, Symbol* class_name, TRAPS){
5435   ResourceMark rm(THREAD);
5436   const u2 max_version = JVM_CLASSFILE_MAJOR_VERSION;
5437   if (major &lt; JAVA_MIN_SUPPORTED_VERSION) {
5438     Exceptions::fthrow(
5439       THREAD_AND_LOCATION,
5440       vmSymbols::java_lang_UnsupportedClassVersionError(),
5441       &quot;%s (class file version %u.%u) was compiled with an invalid major version&quot;,
5442       class_name-&gt;as_C_string(), major, minor);
5443     return;
5444   }
5445 
5446   if (major &gt; max_version) {
5447     Exceptions::fthrow(
5448       THREAD_AND_LOCATION,
5449       vmSymbols::java_lang_UnsupportedClassVersionError(),
5450       &quot;%s has been compiled by a more recent version of the Java Runtime (class file version %u.%u), &quot;
5451       &quot;this version of the Java Runtime only recognizes class file versions up to %u.0&quot;,
5452       class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION);
5453     return;
5454   }
5455 
5456   if (major &lt; JAVA_12_VERSION || minor == 0) {
5457     return;
5458   }
5459 
5460   if (minor == JAVA_PREVIEW_MINOR_VERSION) {
5461     if (major != max_version) {
5462       Exceptions::fthrow(
5463         THREAD_AND_LOCATION,
5464         vmSymbols::java_lang_UnsupportedClassVersionError(),
5465         &quot;%s (class file version %u.%u) was compiled with preview features that are unsupported. &quot;
5466         &quot;This version of the Java Runtime only recognizes preview features for class file version %u.%u&quot;,
5467         class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION, JAVA_PREVIEW_MINOR_VERSION);
5468       return;
5469     }
5470 
5471     if (!Arguments::enable_preview()) {
5472       Exceptions::fthrow(
5473         THREAD_AND_LOCATION,
5474         vmSymbols::java_lang_UnsupportedClassVersionError(),
5475         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
5476         class_name-&gt;as_C_string(), major, minor);
5477       return;
5478     }
5479 
5480   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
5481     Exceptions::fthrow(
5482         THREAD_AND_LOCATION,
5483         vmSymbols::java_lang_UnsupportedClassVersionError(),
5484         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
5485         class_name-&gt;as_C_string(), major, minor);
5486   }
5487 }
5488 
5489 void ClassFileParser::verify_legal_field_modifiers(jint flags,
5490                                                    bool is_interface,
5491                                                    bool is_inline_type,
5492                                                    TRAPS) const {
5493   if (!_need_verify) { return; }
5494 
5495   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5496   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5497   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5498   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
5499   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
5500   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
5501   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
5502   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
5503   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5504 
5505   bool is_illegal = false;
5506 
5507   if (is_interface) {
5508     if (!is_public || !is_static || !is_final || is_private ||
5509         is_protected || is_volatile || is_transient ||
5510         (major_gte_1_5 &amp;&amp; is_enum)) {
5511       is_illegal = true;
5512     }
5513   } else { // not interface
5514     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
5515       is_illegal = true;
5516     } else {
5517       if (is_inline_type &amp;&amp; !is_static &amp;&amp; !is_final) {
5518         is_illegal = true;
5519       }
5520     }
5521   }
5522 
5523   if (is_illegal) {
5524     ResourceMark rm(THREAD);
5525     Exceptions::fthrow(
5526       THREAD_AND_LOCATION,
5527       vmSymbols::java_lang_ClassFormatError(),
5528       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5529       _class_name-&gt;as_C_string(), flags);
5530     return;
5531   }
5532 }
5533 
5534 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5535                                                     bool is_interface,
5536                                                     bool is_inline_type,
5537                                                     const Symbol* name,
5538                                                     TRAPS) const {
5539   if (!_need_verify) { return; }
5540 
5541   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5542   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5543   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5544   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5545   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5546   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5547   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5548   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5549   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5550   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
5551   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
5552   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5553   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5554 
5555   bool is_illegal = false;
5556 
5557   const char* class_note = &quot;&quot;;
5558 
5559   if (is_interface) {
5560     if (major_gte_8) {
5561       // Class file version is JAVA_8_VERSION or later Methods of
5562       // interfaces may set any of the flags except ACC_PROTECTED,
5563       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
5564       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
5565       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
5566           (is_native || is_protected || is_final || is_synchronized) ||
5567           // If a specific method of a class or interface has its
5568           // ACC_ABSTRACT flag set, it must not have any of its
5569           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
5570           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
5571           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
5572           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
5573           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
5574         is_illegal = true;
5575       }
5576     } else if (major_gte_1_5) {
5577       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5578       if (!is_public || is_private || is_protected || is_static || is_final ||
5579           is_synchronized || is_native || !is_abstract || is_strict) {
5580         is_illegal = true;
5581       }
5582     } else {
5583       // Class file version is pre-JAVA_1_5_VERSION
5584       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5585         is_illegal = true;
5586       }
5587     }
5588   } else { // not interface
5589     if (has_illegal_visibility(flags)) {
5590       is_illegal = true;
5591     } else {
5592       if (is_initializer) {
5593         if (is_final || is_synchronized || is_native ||
5594             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
5595           is_illegal = true;
5596         }
5597         if (!is_static &amp;&amp; !is_inline_type) {
5598           // OK, an object constructor in a regular class
5599         } else if (is_static &amp;&amp; is_inline_type) {
5600           // OK, a static init factory in an inline class
5601         } else {
5602           // but no other combinations are allowed
5603           is_illegal = true;
5604           class_note = (is_inline_type ? &quot; (an inline class)&quot; : &quot; (not an inline class)&quot;);
5605         }
5606       } else { // not initializer
5607         if (is_inline_type &amp;&amp; is_synchronized &amp;&amp; !is_static) {
5608           is_illegal = true;
5609           class_note = &quot; (an inline class)&quot;;
5610         } else {
5611           if (is_abstract) {
5612             if ((is_final || is_native || is_private || is_static ||
5613                 (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {
5614               is_illegal = true;
5615             }
5616           }
5617         }
5618       }
5619     }
5620   }
5621 
5622   if (is_illegal) {
5623     ResourceMark rm(THREAD);
5624     Exceptions::fthrow(
5625       THREAD_AND_LOCATION,
5626       vmSymbols::java_lang_ClassFormatError(),
5627       &quot;Method %s in class %s%s has illegal modifiers: 0x%X&quot;,
5628       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, flags);
5629     return;
5630   }
5631 }
5632 
5633 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
5634                                         int length,
5635                                         TRAPS) const {
5636   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
5637   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
5638     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
5639   }
5640 }
5641 
5642 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
5643 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
5644 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
5645 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
5646 // method.  Because these names have been checked as special cases before
5647 // calling this method in verify_legal_method_name.
5648 //
5649 // This method is also called from the modular system APIs in modules.cpp
5650 // to verify the validity of module and package names.
5651 bool ClassFileParser::verify_unqualified_name(const char* name,
5652                                               unsigned int length,
5653                                               int type) {
5654   if (length == 0) return false;  // Must have at least one char.
5655   for (const char* p = name; p != name + length; p++) {
5656     switch(*p) {
5657       case JVM_SIGNATURE_DOT:
5658       case JVM_SIGNATURE_ENDCLASS:
5659       case JVM_SIGNATURE_ARRAY:
5660         // do not permit &#39;.&#39;, &#39;;&#39;, or &#39;[&#39;
5661         return false;
5662       case JVM_SIGNATURE_SLASH:
5663         // check for &#39;//&#39; or leading or trailing &#39;/&#39; which are not legal
5664         // unqualified name must not be empty
5665         if (type == ClassFileParser::LegalClass) {
5666           if (p == name || p+1 &gt;= name+length ||
5667               *(p+1) == JVM_SIGNATURE_SLASH) {
5668             return false;
5669           }
5670         } else {
5671           return false;   // do not permit &#39;/&#39; unless it&#39;s class name
5672         }
5673         break;
5674       case JVM_SIGNATURE_SPECIAL:
5675       case JVM_SIGNATURE_ENDSPECIAL:
5676         // do not permit &#39;&lt;&#39; or &#39;&gt;&#39; in method names
5677         if (type == ClassFileParser::LegalMethod) {
5678           return false;
5679         }
5680     }
5681   }
5682   return true;
5683 }
5684 
5685 // Take pointer to a UTF8 byte string (not NUL-terminated).
5686 // Skip over the longest part of the string that could
5687 // be taken as a fieldname. Allow &#39;/&#39; if slash_ok is true.
5688 // Return a pointer to just past the fieldname.
5689 // Return NULL if no fieldname at all was found, or in the case of slash_ok
5690 // being true, we saw consecutive slashes (meaning we were looking for a
5691 // qualified path but found something that was badly-formed).
5692 static const char* skip_over_field_name(const char* const name,
5693                                         bool slash_ok,
5694                                         unsigned int length) {
5695   const char* p;
5696   jboolean last_is_slash = false;
5697   jboolean not_first_ch = false;
5698 
5699   for (p = name; p != name + length; not_first_ch = true) {
5700     const char* old_p = p;
5701     jchar ch = *p;
5702     if (ch &lt; 128) {
5703       p++;
5704       // quick check for ascii
5705       if ((ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) ||
5706         (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;) ||
5707         (ch == &#39;_&#39; || ch == &#39;$&#39;) ||
5708         (not_first_ch &amp;&amp; ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)) {
5709         last_is_slash = false;
5710         continue;
5711       }
5712       if (slash_ok &amp;&amp; ch == JVM_SIGNATURE_SLASH) {
5713         if (last_is_slash) {
5714           return NULL;  // Don&#39;t permit consecutive slashes
5715         }
5716         last_is_slash = true;
5717         continue;
5718       }
5719     }
5720     else {
5721       jint unicode_ch;
5722       char* tmp_p = UTF8::next_character(p, &amp;unicode_ch);
5723       p = tmp_p;
5724       last_is_slash = false;
5725       // Check if ch is Java identifier start or is Java identifier part
5726       // 4672820: call java.lang.Character methods directly without generating separate tables.
5727       EXCEPTION_MARK;
5728       // return value
5729       JavaValue result(T_BOOLEAN);
5730       // Set up the arguments to isJavaIdentifierStart or isJavaIdentifierPart
5731       JavaCallArguments args;
5732       args.push_int(unicode_ch);
5733 
5734       if (not_first_ch) {
5735         // public static boolean isJavaIdentifierPart(char ch);
5736         JavaCalls::call_static(&amp;result,
5737           SystemDictionary::Character_klass(),
5738           vmSymbols::isJavaIdentifierPart_name(),
5739           vmSymbols::int_bool_signature(),
5740           &amp;args,
5741           THREAD);
5742       } else {
5743         // public static boolean isJavaIdentifierStart(char ch);
5744         JavaCalls::call_static(&amp;result,
5745           SystemDictionary::Character_klass(),
5746           vmSymbols::isJavaIdentifierStart_name(),
5747           vmSymbols::int_bool_signature(),
5748           &amp;args,
5749           THREAD);
5750       }
5751       if (HAS_PENDING_EXCEPTION) {
5752         CLEAR_PENDING_EXCEPTION;
5753         return NULL;
5754       }
5755       if(result.get_jboolean()) {
5756         continue;
5757       }
5758     }
5759     return (not_first_ch) ? old_p : NULL;
5760   }
5761   return (not_first_ch) ? p : NULL;
5762 }
5763 
5764 // Take pointer to a UTF8 byte string (not NUL-terminated).
5765 // Skip over the longest part of the string that could
5766 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5767 // Return a pointer to just past the signature.
5768 // Return NULL if no legal signature is found.
5769 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5770                                                        bool void_ok,
5771                                                        unsigned int length,
5772                                                        TRAPS) const {
5773   unsigned int array_dim = 0;
5774   while (length &gt; 0) {
5775     switch (signature[0]) {
5776     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5777     case JVM_SIGNATURE_BOOLEAN:
5778     case JVM_SIGNATURE_BYTE:
5779     case JVM_SIGNATURE_CHAR:
5780     case JVM_SIGNATURE_SHORT:
5781     case JVM_SIGNATURE_INT:
5782     case JVM_SIGNATURE_FLOAT:
5783     case JVM_SIGNATURE_LONG:
5784     case JVM_SIGNATURE_DOUBLE:
5785       return signature + 1;
5786     case JVM_SIGNATURE_VALUETYPE:
5787       // Can&#39;t enable this check until JDK upgrades the bytecode generators
5788       // if (_major_version &lt; CONSTANT_CLASS_DESCRIPTORS ) {
5789       //   classfile_parse_error(&quot;Class name contains illegal Q-signature &quot;
5790       //                                    &quot;in descriptor in class file %s&quot;,
5791       //                                    CHECK_0);
5792       // }
5793       // fall through
5794     case JVM_SIGNATURE_CLASS:
5795     {
5796       if (_major_version &lt; JAVA_1_5_VERSION) {
5797         // Skip over the class name if one is there
5798         const char* const p = skip_over_field_name(signature + 1, true, --length);
5799 
5800         // The next character better be a semicolon
5801         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5802           return p + 1;
5803         }
5804       }
5805       else {
5806         // Skip leading &#39;L&#39; or &#39;Q&#39; and ignore first appearance of &#39;;&#39;
5807         signature++;
5808         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5809         // Format check signature
5810         if (c != NULL) {
5811           int newlen = c - (char*) signature;
5812           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5813           if (!legal) {
5814             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5815                                   &quot;in descriptor in class file %s&quot;,
5816                                   CHECK_NULL);
5817             return NULL;
5818           }
5819           return signature + newlen + 1;
5820         }
5821       }
5822       return NULL;
5823     }
5824     case JVM_SIGNATURE_ARRAY:
5825       array_dim++;
5826       if (array_dim &gt; 255) {
5827         // 4277370: array descriptor is valid only if it represents 255 or fewer dimensions.
5828         classfile_parse_error(&quot;Array type descriptor has more than 255 dimensions in class file %s&quot;, CHECK_NULL);
5829       }
5830       // The rest of what&#39;s there better be a legal signature
5831       signature++;
5832       length--;
5833       void_ok = false;
5834       break;
5835     default:
5836       return NULL;
5837     }
5838   }
5839   return NULL;
5840 }
5841 
5842 // Checks if name is a legal class name.
5843 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5844   if (!_need_verify || _relax_verify) { return; }
5845 
5846   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5847   char* bytes = (char*)name-&gt;bytes();
5848   unsigned int length = name-&gt;utf8_length();
5849   bool legal = false;
5850 
5851   if (length &gt; 0) {
5852     const char* p;
5853     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5854       p = skip_over_field_signature(bytes, false, length, CHECK);
5855       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5856     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5857       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5858         p = skip_over_field_name(bytes, true, length);
5859         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5860       }
5861     } else if (_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS &amp;&amp; bytes[length - 1] == &#39;;&#39; ) {
5862       // Support for L...; and Q...; descriptors
5863       legal = verify_unqualified_name(bytes + 1, length - 2, LegalClass);
5864     } else {
5865       // 4900761: relax the constraints based on JSR202 spec
5866       // Class names may be drawn from the entire Unicode character set.
5867       // Identifiers between &#39;/&#39; must be unqualified names.
5868       // The utf8 string has been verified when parsing cpool entries.
5869       legal = verify_unqualified_name(bytes, length, LegalClass);
5870     }
5871   }
5872   if (!legal) {
5873     ResourceMark rm(THREAD);
5874     assert(_class_name != NULL, &quot;invariant&quot;);
5875     Exceptions::fthrow(
5876       THREAD_AND_LOCATION,
5877       vmSymbols::java_lang_ClassFormatError(),
5878       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5879       _class_name-&gt;as_C_string()
5880     );
5881     return;
5882   }
5883 }
5884 
5885 // Checks if name is a legal field name.
5886 void ClassFileParser::verify_legal_field_name(const Symbol* name, TRAPS) const {
5887   if (!_need_verify || _relax_verify) { return; }
5888 
5889   char* bytes = (char*)name-&gt;bytes();
5890   unsigned int length = name-&gt;utf8_length();
5891   bool legal = false;
5892 
5893   if (length &gt; 0) {
5894     if (_major_version &lt; JAVA_1_5_VERSION) {
5895       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5896         const char* p = skip_over_field_name(bytes, false, length);
5897         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5898       }
5899     } else {
5900       // 4881221: relax the constraints based on JSR202 spec
5901       legal = verify_unqualified_name(bytes, length, LegalField);
5902     }
5903   }
5904 
5905   if (!legal) {
5906     ResourceMark rm(THREAD);
5907     assert(_class_name != NULL, &quot;invariant&quot;);
5908     Exceptions::fthrow(
5909       THREAD_AND_LOCATION,
5910       vmSymbols::java_lang_ClassFormatError(),
5911       &quot;Illegal field name \&quot;%.*s\&quot; in class %s&quot;, length, bytes,
5912       _class_name-&gt;as_C_string()
5913     );
5914     return;
5915   }
5916 }
5917 
5918 // Checks if name is a legal method name.
5919 void ClassFileParser::verify_legal_method_name(const Symbol* name, TRAPS) const {
5920   if (!_need_verify || _relax_verify) { return; }
5921 
5922   assert(name != NULL, &quot;method name is null&quot;);
5923   char* bytes = (char*)name-&gt;bytes();
5924   unsigned int length = name-&gt;utf8_length();
5925   bool legal = false;
5926 
5927   if (length &gt; 0) {
5928     if (bytes[0] == JVM_SIGNATURE_SPECIAL) {
5929       if (name == vmSymbols::object_initializer_name() || name == vmSymbols::class_initializer_name()) {
5930         legal = true;
5931       }
5932     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5933       const char* p;
5934       p = skip_over_field_name(bytes, false, length);
5935       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5936     } else {
5937       // 4881221: relax the constraints based on JSR202 spec
5938       legal = verify_unqualified_name(bytes, length, LegalMethod);
5939     }
5940   }
5941 
5942   if (!legal) {
5943     ResourceMark rm(THREAD);
5944     assert(_class_name != NULL, &quot;invariant&quot;);
5945     Exceptions::fthrow(
5946       THREAD_AND_LOCATION,
5947       vmSymbols::java_lang_ClassFormatError(),
5948       &quot;Illegal method name \&quot;%.*s\&quot; in class %s&quot;, length, bytes,
5949       _class_name-&gt;as_C_string()
5950     );
5951     return;
5952   }
5953 }
5954 
5955 
5956 // Checks if signature is a legal field signature.
5957 void ClassFileParser::verify_legal_field_signature(const Symbol* name,
5958                                                    const Symbol* signature,
5959                                                    TRAPS) const {
5960   if (!_need_verify) { return; }
5961 
5962   const char* const bytes = (const char* const)signature-&gt;bytes();
5963   const unsigned int length = signature-&gt;utf8_length();
5964   const char* const p = skip_over_field_signature(bytes, false, length, CHECK);
5965 
5966   if (p == NULL || (p - bytes) != (int)length) {
5967     throwIllegalSignature(&quot;Field&quot;, name, signature, CHECK);
5968   }
5969 }
5970 
5971 // Checks if signature is a legal method signature.
5972 // Returns number of parameters
5973 int ClassFileParser::verify_legal_method_signature(const Symbol* name,
5974                                                    const Symbol* signature,
5975                                                    TRAPS) const {
5976   if (!_need_verify) {
5977     // make sure caller&#39;s args_size will be less than 0 even for non-static
5978     // method so it will be recomputed in compute_size_of_parameters().
5979     return -2;
5980   }
5981 
5982   // Class initializers cannot have args for class format version &gt;= 51.
5983   if (name == vmSymbols::class_initializer_name() &amp;&amp;
5984       signature != vmSymbols::void_method_signature() &amp;&amp;
5985       _major_version &gt;= JAVA_7_VERSION) {
5986     throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5987     return 0;
5988   }
5989 
5990   unsigned int args_size = 0;
5991   const char* p = (const char*)signature-&gt;bytes();
5992   unsigned int length = signature-&gt;utf8_length();
5993   const char* nextp;
5994 
5995   // The first character must be a &#39;(&#39;
5996   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5997     length--;
5998     // Skip over legal field signatures
5999     nextp = skip_over_field_signature(p, false, length, CHECK_0);
6000     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
6001       args_size++;
6002       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
6003         args_size++;
6004       }
6005       length -= nextp - p;
6006       p = nextp;
6007       nextp = skip_over_field_signature(p, false, length, CHECK_0);
6008     }
6009     // The first non-signature thing better be a &#39;)&#39;
6010     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
6011       length--;
6012       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
6013         // All constructor methods must return void
6014         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
6015           return args_size;
6016         }
6017         // All static init methods must return the current class
6018         if ((length &gt;= 3) &amp;&amp; (p[length-1] == JVM_SIGNATURE_ENDCLASS)
6019             &amp;&amp; name == vmSymbols::object_initializer_name()) {
6020           nextp = skip_over_field_signature(p, true, length, CHECK_0);
6021           if (nextp &amp;&amp; ((int)length == (nextp - p))) {
6022             // The actual class will be checked against current class
6023             // when the method is defined (see parse_method).
6024             // A reference to a static init with a bad return type
6025             // will load and verify OK, but will fail to link.
6026             return args_size;
6027           }
6028         }
6029         // The distinction between static factory methods and
6030         // constructors depends on the JVM_ACC_STATIC modifier.
6031         // This distinction must be reflected in a void or non-void
6032         // return. For declared methods, the check is in parse_method.
6033       } else {
6034         // Now we better just have a return value
6035         nextp = skip_over_field_signature(p, true, length, CHECK_0);
6036         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
6037           return args_size;
6038         }
6039       }
6040     }
6041   }
6042   // Report error
6043   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
6044   return 0;
6045 }
6046 
6047 int ClassFileParser::static_field_size() const {
6048   assert(_field_info != NULL, &quot;invariant&quot;);
6049   return _field_info-&gt;_static_field_size;
6050 }
6051 
6052 int ClassFileParser::total_oop_map_count() const {
6053   assert(_field_info != NULL, &quot;invariant&quot;);
6054   return _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count;
6055 }
6056 
6057 jint ClassFileParser::layout_size() const {
6058   assert(_field_info != NULL, &quot;invariant&quot;);
6059   return _field_info-&gt;_instance_size;
6060 }
6061 
6062 static void check_methods_for_intrinsics(const InstanceKlass* ik,
6063                                          const Array&lt;Method*&gt;* methods) {
6064   assert(ik != NULL, &quot;invariant&quot;);
6065   assert(methods != NULL, &quot;invariant&quot;);
6066 
6067   // Set up Method*::intrinsic_id as soon as we know the names of methods.
6068   // (We used to do this lazily, but now we query it in Rewriter,
6069   // which is eagerly done for every method, so we might as well do it now,
6070   // when everything is fresh in memory.)
6071   const vmSymbols::SID klass_id = Method::klass_id_for_intrinsics(ik);
6072 
6073   if (klass_id != vmSymbols::NO_SID) {
6074     for (int j = 0; j &lt; methods-&gt;length(); ++j) {
6075       Method* method = methods-&gt;at(j);
6076       method-&gt;init_intrinsic_id();
6077 
6078       if (CheckIntrinsics) {
6079         // Check if an intrinsic is defined for method &#39;method&#39;,
6080         // but the method is not annotated with @HotSpotIntrinsicCandidate.
6081         if (method-&gt;intrinsic_id() != vmIntrinsics::_none &amp;&amp;
6082             !method-&gt;intrinsic_candidate()) {
6083               tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
6084               &quot;but the method is not annotated with @HotSpotIntrinsicCandidate.%s&quot;,
6085               method-&gt;name_and_sig_as_C_string(),
6086               NOT_DEBUG(&quot; Method will not be inlined.&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
6087             );
6088           tty-&gt;cr();
6089           DEBUG_ONLY(vm_exit(1));
6090         }
6091         // Check is the method &#39;method&#39; is annotated with @HotSpotIntrinsicCandidate,
6092         // but there is no intrinsic available for it.
6093         if (method-&gt;intrinsic_candidate() &amp;&amp;
6094           method-&gt;intrinsic_id() == vmIntrinsics::_none) {
6095             tty-&gt;print(&quot;Method [%s] is annotated with @HotSpotIntrinsicCandidate, &quot;
6096               &quot;but no compiler intrinsic is defined for the method.%s&quot;,
6097               method-&gt;name_and_sig_as_C_string(),
6098               NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
6099             );
6100           tty-&gt;cr();
6101           DEBUG_ONLY(vm_exit(1));
6102         }
6103       }
6104     } // end for
6105 
6106 #ifdef ASSERT
6107     if (CheckIntrinsics) {
6108       // Check for orphan methods in the current class. A method m
6109       // of a class C is orphan if an intrinsic is defined for method m,
6110       // but class C does not declare m.
6111       // The check is potentially expensive, therefore it is available
6112       // only in debug builds.
6113 
6114       for (int id = vmIntrinsics::FIRST_ID; id &lt; (int)vmIntrinsics::ID_LIMIT; ++id) {
6115         if (vmIntrinsics::_compiledLambdaForm == id) {
6116           // The _compiledLamdbdaForm intrinsic is a special marker for bytecode
6117           // generated for the JVM from a LambdaForm and therefore no method
6118           // is defined for it.
6119           continue;
6120         }
6121 
6122         if (vmIntrinsics::class_for(vmIntrinsics::ID_from(id)) == klass_id) {
6123           // Check if the current class contains a method with the same
6124           // name, flags, signature.
6125           bool match = false;
6126           for (int j = 0; j &lt; methods-&gt;length(); ++j) {
6127             const Method* method = methods-&gt;at(j);
6128             if (method-&gt;intrinsic_id() == id) {
6129               match = true;
6130               break;
6131             }
6132           }
6133 
6134           if (!match) {
6135             char buf[1000];
6136             tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
6137                        &quot;but the method is not available in class [%s].%s&quot;,
6138                         vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID_from(id),
6139                                                              buf, sizeof(buf)),
6140                         ik-&gt;name()-&gt;as_C_string(),
6141                         NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
6142             );
6143             tty-&gt;cr();
6144             DEBUG_ONLY(vm_exit(1));
6145           }
6146         }
6147       } // end for
6148     } // CheckIntrinsics
6149 #endif // ASSERT
6150   }
6151 }
6152 
6153 InstanceKlass* ClassFileParser::create_instance_klass(bool changed_by_loadhook,
6154                                                       const ClassInstanceInfo&amp; cl_inst_info,
6155                                                       TRAPS) {
6156   if (_klass != NULL) {
6157     return _klass;
6158   }
6159 
6160   InstanceKlass* const ik =
6161     InstanceKlass::allocate_instance_klass(*this, CHECK_NULL);
6162 
6163   if (is_hidden()) {
6164     mangle_hidden_class_name(ik);
6165   }
6166 
6167   fill_instance_klass(ik, changed_by_loadhook, cl_inst_info, CHECK_NULL);
6168 
6169   assert(_klass == ik, &quot;invariant&quot;);
6170 
6171 
6172   if (ik-&gt;should_store_fingerprint()) {
6173     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
6174   }
6175 
6176   ik-&gt;set_has_passed_fingerprint_check(false);
6177   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
6178     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
6179     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
6180     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
6181       // This class matches with a class saved in an AOT library
6182       ik-&gt;set_has_passed_fingerprint_check(true);
6183     } else {
6184       ResourceMark rm;
6185       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
6186                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
6187     }
6188   }
6189 
6190   if (ik-&gt;is_value()) {
6191     ValueKlass* vk = ValueKlass::cast(ik);
6192     oop val = ik-&gt;allocate_instance(CHECK_NULL);
6193     vk-&gt;set_default_value(val);
6194   }
6195 
6196   return ik;
6197 }
6198 
6199 // Return true if the specified class is not a valid super class for an inline type.
6200 // A valid super class for an inline type is abstract, has no instance fields,
6201 // does not implement interface java.lang.IdentityObject (checked elsewhere), has
6202 // an empty body-less no-arg constructor, and no synchronized instance methods.
6203 // This function doesn&#39;t check if the class&#39;s super types are invalid.  Those checks
6204 // are done elsewhere.  The final determination of whether or not a class is an
6205 // invalid super type for an inline class is done in fill_instance_klass().
6206 bool ClassFileParser::is_invalid_super_for_inline_type() {
6207   if (class_name() == vmSymbols::java_lang_IdentityObject()) {
6208     return true;
6209   }
6210   if (is_interface() || class_name() == vmSymbols::java_lang_Object()) {
6211     return false;
6212   }
6213   if (!access_flags().is_abstract() || _has_nonstatic_fields) {
6214     return true;
6215   } else {
6216     // Look at each method
6217     for (int x = 0; x &lt; _methods-&gt;length(); x++) {
6218       const Method* const method = _methods-&gt;at(x);
6219       if (method-&gt;is_synchronized() &amp;&amp; !method-&gt;is_static()) {
6220         return true;
6221 
6222       } else if (method-&gt;name() == vmSymbols::object_initializer_name()) {
6223         if (method-&gt;signature() != vmSymbols::void_method_signature() ||
6224             !method-&gt;is_vanilla_constructor()) {
6225           return true;
6226         }
6227       }
6228     }
6229   }
6230   return false;
6231 }
6232 
6233 void ClassFileParser::fill_instance_klass(InstanceKlass* ik,
6234                                           bool changed_by_loadhook,
6235                                           const ClassInstanceInfo&amp; cl_inst_info,
6236                                           TRAPS) {
6237   assert(ik != NULL, &quot;invariant&quot;);
6238 
6239   // Set name and CLD before adding to CLD
6240   ik-&gt;set_class_loader_data(_loader_data);
6241   ik-&gt;set_name(_class_name);
6242 
6243   // Add all classes to our internal class loader list here,
6244   // including classes in the bootstrap (NULL) class loader.
6245   const bool publicize = !is_internal();
6246 
6247   _loader_data-&gt;add_class(ik, publicize);
6248 
6249   set_klass_to_deallocate(ik);
6250 
6251   assert(_field_info != NULL, &quot;invariant&quot;);
6252   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
6253   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
6254          &quot;sanity&quot;);
6255 
6256   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
6257   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
6258 
6259   // Fill in information already parsed
6260   ik-&gt;set_should_verify_class(_need_verify);
6261 
6262   // Not yet: supers are done below to support the new subtype-checking fields
6263   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
6264   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
6265   if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_value()) {
6266     ik-&gt;set_is_naturally_atomic();
6267   }
6268   if (_is_empty_inline_type) {
6269     ik-&gt;set_is_empty_inline_type();
6270   }
6271 
6272   if (this-&gt;_invalid_inline_super) {
6273     ik-&gt;set_invalid_inline_super();
6274   }
6275 
6276   if (_has_injected_identityObject) {
6277     ik-&gt;set_has_injected_identityObject();
6278   }
6279 
6280   assert(_fac != NULL, &quot;invariant&quot;);
<a name="28" id="anc28"></a><span class="line-modified">6281   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);</span>
6282 
6283   // this transfers ownership of a lot of arrays from
6284   // the parser onto the InstanceKlass*
6285   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6286 
6287   // can only set dynamic nest-host after static nest information is set
6288   if (cl_inst_info.dynamic_nest_host() != NULL) {
6289     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
6290   }
6291 
6292   // note that is not safe to use the fields in the parser from this point on
6293   assert(NULL == _cp, &quot;invariant&quot;);
6294   assert(NULL == _fields, &quot;invariant&quot;);
6295   assert(NULL == _methods, &quot;invariant&quot;);
6296   assert(NULL == _inner_classes, &quot;invariant&quot;);
6297   assert(NULL == _nest_members, &quot;invariant&quot;);
6298   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6299   assert(NULL == _record_components, &quot;invariant&quot;);
6300   assert(NULL == _permitted_subclasses, &quot;invariant&quot;);
6301 
6302   if (_has_final_method) {
6303     ik-&gt;set_has_final_method();
6304   }
6305 
6306   ik-&gt;copy_method_ordering(_method_ordering, CHECK);
6307   // The InstanceKlass::_methods_jmethod_ids cache
6308   // is managed on the assumption that the initial cache
6309   // size is equal to the number of methods in the class. If
6310   // that changes, then InstanceKlass::idnum_can_increment()
6311   // has to be changed accordingly.
6312   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
6313 
6314   ik-&gt;set_this_class_index(_this_class_index);
6315 
6316   if (_is_hidden || is_unsafe_anonymous()) {
6317     // _this_class_index is a CONSTANT_Class entry that refers to this
6318     // hidden or anonymous class itself. If this class needs to refer to its own
6319     // methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference
6320     // _this_class_index. However, because this class is hidden or anonymous (it&#39;s
6321     // not stored in SystemDictionary), _this_class_index cannot be resolved
6322     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
6323     // Therefore, we must eagerly resolve _this_class_index now.
6324     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
6325   }
6326 
6327   ik-&gt;set_minor_version(_minor_version);
6328   ik-&gt;set_major_version(_major_version);
6329   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
6330   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);
6331   if (_is_declared_atomic) {
6332     ik-&gt;set_is_declared_atomic();
6333   }
6334 
6335   if (_unsafe_anonymous_host != NULL) {
6336     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
6337     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
6338   }
6339   if (_is_hidden) {
6340     ik-&gt;set_is_hidden();
6341   }
6342 
6343   // Set PackageEntry for this_klass
6344   oop cl = ik-&gt;class_loader();
6345   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
6346   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
6347   ik-&gt;set_package(cld, NULL, CHECK);
6348 
6349   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
6350   assert(methods != NULL, &quot;invariant&quot;);
6351   const int methods_len = methods-&gt;length();
6352 
6353   check_methods_for_intrinsics(ik, methods);
6354 
6355   // Fill in field values obtained by parse_classfile_attributes
6356   if (_parsed_annotations-&gt;has_any_annotations()) {
6357     _parsed_annotations-&gt;apply_to(ik);
6358   }
6359 
6360   apply_parsed_class_attributes(ik);
6361 
6362   // Miranda methods
6363   if ((_num_miranda_methods &gt; 0) ||
6364       // if this class introduced new miranda methods or
6365       (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_miranda_methods())
6366         // super class exists and this class inherited miranda methods
6367      ) {
6368        ik-&gt;set_has_miranda_methods(); // then set a flag
6369   }
6370 
6371   // Fill in information needed to compute superclasses.
6372   ik-&gt;initialize_supers(const_cast&lt;InstanceKlass*&gt;(_super_klass), _transitive_interfaces, CHECK);
6373   ik-&gt;set_transitive_interfaces(_transitive_interfaces);
6374   ik-&gt;set_local_interfaces(_local_interfaces);
6375   _transitive_interfaces = NULL;
6376   _local_interfaces = NULL;
6377 
6378   // Initialize itable offset tables
6379   klassItable::setup_itable_offset_table(ik);
6380 
6381   // Compute transitive closure of interfaces this class implements
6382   // Do final class setup
6383   OopMapBlocksBuilder* oop_map_blocks = _field_info-&gt;oop_map_blocks;
6384   if (oop_map_blocks-&gt;_nonstatic_oop_map_count &gt; 0) {
6385     oop_map_blocks-&gt;copy(ik-&gt;start_of_nonstatic_oop_maps());
6386   }
6387 
6388   if (_has_contended_fields || _parsed_annotations-&gt;is_contended() ||
6389       ( _super_klass != NULL &amp;&amp; _super_klass-&gt;has_contended_annotations())) {
6390     ik-&gt;set_has_contended_annotations(true);
6391   }
6392 
6393   // Fill in has_finalizer, has_vanilla_constructor, and layout_helper
6394   set_precomputed_flags(ik);
6395 
6396   // check if this class can access its super class
6397   check_super_class_access(ik, CHECK);
6398 
6399   // check if this class can access its superinterfaces
6400   check_super_interface_access(ik, CHECK);
6401 
6402   // check if this class overrides any final method
6403   check_final_method_override(ik, CHECK);
6404 
6405   // reject static interface methods prior to Java 8
6406   if (ik-&gt;is_interface() &amp;&amp; _major_version &lt; JAVA_8_VERSION) {
6407     check_illegal_static_method(ik, CHECK);
6408   }
6409 
6410   // Obtain this_klass&#39; module entry
6411   ModuleEntry* module_entry = ik-&gt;module();
6412   assert(module_entry != NULL, &quot;module_entry should always be set&quot;);
6413 
6414   // Obtain java.lang.Module
6415   Handle module_handle(THREAD, module_entry-&gt;module());
6416 
6417   // Allocate mirror and initialize static fields
6418   // The create_mirror() call will also call compute_modifiers()
6419   java_lang_Class::create_mirror(ik,
6420                                  Handle(THREAD, _loader_data-&gt;class_loader()),
6421                                  module_handle,
6422                                  _protection_domain,
6423                                  cl_inst_info.class_data(),
6424                                  CHECK);
6425 
6426   assert(_all_mirandas != NULL, &quot;invariant&quot;);
6427 
6428   // Generate any default methods - default methods are public interface methods
6429   // that have a default implementation.  This is new with Java 8.
6430   if (_has_nonstatic_concrete_methods) {
6431     DefaultMethods::generate_default_methods(ik,
6432                                              _all_mirandas,
6433                                              CHECK);
6434   }
6435 
6436   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
6437   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
6438       !module_entry-&gt;has_default_read_edges()) {
6439     if (!module_entry-&gt;set_has_default_read_edges()) {
6440       // We won a potential race
6441       JvmtiExport::add_default_read_edges(module_handle, THREAD);
6442     }
6443   }
6444 
6445   int nfields = ik-&gt;java_fields_count();
6446   if (ik-&gt;is_value()) nfields++;
6447   for (int i = 0; i &lt; nfields; i++) {
<a name="29" id="anc29"></a><span class="line-modified">6448     if (ik-&gt;field_is_flattenable(i)) {</span>
6449       Symbol* klass_name = ik-&gt;field_signature(i)-&gt;fundamental_name(CHECK);
6450       // Inline classes for instance fields must have been pre-loaded
6451       // Inline classes for static fields might not have been loaded yet
6452       Klass* klass = SystemDictionary::find(klass_name,
6453           Handle(THREAD, ik-&gt;class_loader()),
6454           Handle(THREAD, ik-&gt;protection_domain()), CHECK);
6455       if (klass != NULL) {
6456         assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);
6457         ik-&gt;set_value_field_klass(i, klass);
6458       }
6459       klass_name-&gt;decrement_refcount();
6460     } else
6461       if (is_inline_type() &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_FIELD_INTERNAL) != 0)
6462         &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) != 0)) {
6463       ValueKlass::cast(ik)-&gt;set_default_value_offset(ik-&gt;field_offset(i));
6464     }
6465   }
6466 
6467   if (is_inline_type()) {
6468     ValueKlass* vk = ValueKlass::cast(ik);
6469     if (UseNewFieldLayout) {
6470       vk-&gt;set_alignment(_alignment);
6471       vk-&gt;set_first_field_offset(_first_field_offset);
6472       vk-&gt;set_exact_size_in_bytes(_exact_size_in_bytes);
6473     } else {
6474       vk-&gt;set_first_field_offset(vk-&gt;first_field_offset_old());
6475     }
6476     ValueKlass::cast(ik)-&gt;initialize_calling_convention(CHECK);
6477   }
6478 
6479   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
6480 
6481   if (!is_internal()) {
6482     if (log_is_enabled(Info, class, load)) {
6483       ResourceMark rm;
6484       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
6485       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
6486     }
6487 
6488     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
6489         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
6490         log_is_enabled(Info, class, preview)) {
6491       ResourceMark rm;
6492       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
6493                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
6494     }
6495 
6496     if (log_is_enabled(Debug, class, resolve))  {
6497       ResourceMark rm;
6498       // print out the superclass.
6499       const char * from = ik-&gt;external_name();
6500       if (ik-&gt;java_super() != NULL) {
6501         log_debug(class, resolve)(&quot;%s %s (super)&quot;,
6502                    from,
6503                    ik-&gt;java_super()-&gt;external_name());
6504       }
6505       // print out each of the interface classes referred to by this class.
6506       const Array&lt;InstanceKlass*&gt;* const local_interfaces = ik-&gt;local_interfaces();
6507       if (local_interfaces != NULL) {
6508         const int length = local_interfaces-&gt;length();
6509         for (int i = 0; i &lt; length; i++) {
6510           const InstanceKlass* const k = local_interfaces-&gt;at(i);
6511           const char * to = k-&gt;external_name();
6512           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
6513         }
6514       }
6515     }
6516   }
6517 
6518   JFR_ONLY(INIT_ID(ik);)
6519 
6520   // If we reach here, all is well.
6521   // Now remove the InstanceKlass* from the _klass_to_deallocate field
6522   // in order for it to not be destroyed in the ClassFileParser destructor.
6523   set_klass_to_deallocate(NULL);
6524 
6525   // it&#39;s official
6526   set_klass(ik);
6527 
6528   if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {
6529     Universe::initialize_the_single_IdentityObject_klass_array(ik, CHECK);
6530   }
6531 
6532   debug_only(ik-&gt;verify();)
6533 }
6534 
6535 void ClassFileParser::update_class_name(Symbol* new_class_name) {
6536   // Decrement the refcount in the old name, since we&#39;re clobbering it.
6537   _class_name-&gt;decrement_refcount();
6538 
6539   _class_name = new_class_name;
6540   // Increment the refcount of the new name.
6541   // Now the ClassFileParser owns this name and will decrement in
6542   // the destructor.
6543   _class_name-&gt;increment_refcount();
6544 }
6545 
6546 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
6547 // package by prepending its host class&#39;s package name to its class name and setting
6548 // its _class_name field.
6549 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
6550   ResourceMark rm(THREAD);
6551   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
6552          &quot;Unsafe anonymous class should not be in a package&quot;);
6553   TempNewSymbol host_pkg_name =
6554     ClassLoader::package_from_class_name(unsafe_anonymous_host-&gt;name());
6555 
6556   if (host_pkg_name != NULL) {
6557     int host_pkg_len = host_pkg_name-&gt;utf8_length();
6558     int class_name_len = _class_name-&gt;utf8_length();
6559     int symbol_len = host_pkg_len + 1 + class_name_len;
6560     char* new_anon_name = NEW_RESOURCE_ARRAY(char, symbol_len + 1);
6561     int n = os::snprintf(new_anon_name, symbol_len + 1, &quot;%.*s/%.*s&quot;,
6562                          host_pkg_len, host_pkg_name-&gt;base(), class_name_len, _class_name-&gt;base());
6563     assert(n == symbol_len, &quot;Unexpected number of characters in string&quot;);
6564 
6565     // Decrement old _class_name to avoid leaking.
6566     _class_name-&gt;decrement_refcount();
6567 
6568     // Create a symbol and update the anonymous class name.
6569     // The new class name is created with a refcount of one. When installed into the InstanceKlass,
6570     // it&#39;ll be two and when the ClassFileParser destructor runs, it&#39;ll go back to one and get deleted
6571     // when the class is unloaded.
6572     _class_name = SymbolTable::new_symbol(new_anon_name, symbol_len);
6573   }
6574 }
6575 
6576 // If the host class and the anonymous class are in the same package then do
6577 // nothing.  If the anonymous class is in the unnamed package then move it to its
6578 // host&#39;s package.  If the classes are in different packages then throw an IAE
6579 // exception.
6580 void ClassFileParser::fix_unsafe_anonymous_class_name(TRAPS) {
6581   assert(_unsafe_anonymous_host != NULL, &quot;Expected an unsafe anonymous class&quot;);
6582 
6583   const jbyte* anon_last_slash = UTF8::strrchr((const jbyte*)_class_name-&gt;base(),
6584                                                _class_name-&gt;utf8_length(), JVM_SIGNATURE_SLASH);
6585   if (anon_last_slash == NULL) {  // Unnamed package
6586     prepend_host_package_name(_unsafe_anonymous_host, CHECK);
6587   } else {
6588     if (!_unsafe_anonymous_host-&gt;is_same_class_package(_unsafe_anonymous_host-&gt;class_loader(), _class_name)) {
6589       ResourceMark rm(THREAD);
6590       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
6591         err_msg(&quot;Host class %s and anonymous class %s are in different packages&quot;,
6592         _unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), _class_name-&gt;as_C_string()));
6593     }
6594   }
6595 }
6596 
6597 static bool relax_format_check_for(ClassLoaderData* loader_data) {
6598   bool trusted = loader_data-&gt;is_boot_class_loader_data() ||
6599                  loader_data-&gt;is_platform_class_loader_data();
6600   bool need_verify =
6601     // verifyAll
6602     (BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote) ||
6603     // verifyRemote
6604     (!BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote &amp;&amp; !trusted);
6605   return !need_verify;
6606 }
6607 
6608 ClassFileParser::ClassFileParser(ClassFileStream* stream,
6609                                  Symbol* name,
6610                                  ClassLoaderData* loader_data,
6611                                  const ClassLoadInfo* cl_info,
6612                                  Publicity pub_level,
6613                                  TRAPS) :
6614   _stream(stream),
6615   _class_name(NULL),
6616   _loader_data(loader_data),
6617   _unsafe_anonymous_host(cl_info-&gt;unsafe_anonymous_host()),
6618   _cp_patches(cl_info-&gt;cp_patches()),
6619   _is_hidden(cl_info-&gt;is_hidden()),
6620   _can_access_vm_annotations(cl_info-&gt;can_access_vm_annotations()),
6621   _num_patched_klasses(0),
6622   _max_num_patched_klasses(0),
6623   _orig_cp_size(0),
6624   _first_patched_klass_resolved_index(0),
6625   _super_klass(),
6626   _cp(NULL),
6627   _fields(NULL),
6628   _methods(NULL),
6629   _inner_classes(NULL),
6630   _nest_members(NULL),
6631   _nest_host(0),
6632   _permitted_subclasses(NULL),
6633   _record_components(NULL),
6634   _temp_local_interfaces(NULL),
6635   _local_interfaces(NULL),
6636   _transitive_interfaces(NULL),
6637   _combined_annotations(NULL),
6638   _class_annotations(NULL),
6639   _class_type_annotations(NULL),
6640   _fields_annotations(NULL),
6641   _fields_type_annotations(NULL),
6642   _klass(NULL),
6643   _klass_to_deallocate(NULL),
6644   _parsed_annotations(NULL),
6645   _fac(NULL),
6646   _field_info(NULL),
6647   _method_ordering(NULL),
6648   _all_mirandas(NULL),
6649   _vtable_size(0),
6650   _itable_size(0),
6651   _num_miranda_methods(0),
6652   _rt(REF_NONE),
6653   _protection_domain(cl_info-&gt;protection_domain()),
6654   _access_flags(),
6655   _pub_level(pub_level),
6656   _bad_constant_seen(0),
6657   _synthetic_flag(false),
6658   _sde_length(false),
6659   _sde_buffer(NULL),
6660   _sourcefile_index(0),
6661   _generic_signature_index(0),
6662   _major_version(0),
6663   _minor_version(0),
6664   _this_class_index(0),
6665   _super_class_index(0),
6666   _itfs_len(0),
6667   _java_fields_count(0),
6668   _need_verify(false),
6669   _relax_verify(false),
6670   _has_nonstatic_concrete_methods(false),
6671   _declares_nonstatic_concrete_methods(false),
6672   _has_final_method(false),
6673   _has_contended_fields(false),
<a name="30" id="anc30"></a><span class="line-modified">6674   _has_flattenable_fields(false),</span>
6675   _has_nonstatic_fields(false),
6676   _is_empty_inline_type(false),
6677   _is_naturally_atomic(false),
6678   _is_declared_atomic(false),
6679   _invalid_inline_super(false),
6680   _invalid_identity_super(false),
6681   _implements_identityObject(false),
6682   _has_injected_identityObject(false),
6683   _has_finalizer(false),
6684   _has_empty_finalizer(false),
6685   _has_vanilla_constructor(false),
6686   _max_bootstrap_specifier_index(-1) {
6687 
6688   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6689   _class_name-&gt;increment_refcount();
6690 
6691   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6692   assert(_loader_data != NULL, &quot;invariant&quot;);
6693   assert(stream != NULL, &quot;invariant&quot;);
6694   assert(_stream != NULL, &quot;invariant&quot;);
6695   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6696   assert(_class_name != NULL, &quot;invariant&quot;);
6697   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6698 
6699   // Figure out whether we can skip format checking (matching classic VM behavior)
6700   if (DumpSharedSpaces) {
6701     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6702     // Verification decision is based on BytecodeVerificationRemote flag
6703     // for those classes.
6704     _need_verify = (stream-&gt;need_verify()) ? BytecodeVerificationRemote :
6705                                               BytecodeVerificationLocal;
6706   }
6707   else {
6708     _need_verify = Verifier::should_verify_for(_loader_data-&gt;class_loader(),
6709                                                stream-&gt;need_verify());
6710   }
6711   if (_cp_patches != NULL) {
6712     int len = _cp_patches-&gt;length();
6713     for (int i=0; i&lt;len; i++) {
6714       if (has_cp_patch_at(i)) {
6715         Handle patch = cp_patch_at(i);
6716         if (java_lang_String::is_instance(patch()) || java_lang_Class::is_instance(patch())) {
6717           // We need to append the names of the patched classes to the end of the constant pool,
6718           // because a patched class may have a Utf8 name that&#39;s not already included in the
6719           // original constant pool. These class names are used when patch_constant_pool()
6720           // calls patch_class().
6721           //
6722           // Note that a String in cp_patch_at(i) may be used to patch a Utf8, a String, or a Class.
6723           // At this point, we don&#39;t know the tag for index i yet, because we haven&#39;t parsed the
6724           // constant pool. So we can only assume the worst -- every String is used to patch a Class.
6725           _max_num_patched_klasses++;
6726         }
6727       }
6728     }
6729   }
6730 
6731   // synch back verification state to stream
6732   stream-&gt;set_verify(_need_verify);
6733 
6734   // Check if verification needs to be relaxed for this class file
6735   // Do not restrict it to jdk1.0 or jdk1.1 to maintain backward compatibility (4982376)
6736   _relax_verify = relax_format_check_for(_loader_data);
6737 
6738   parse_stream(stream, CHECK);
6739 
6740   post_process_parsed_stream(stream, _cp, CHECK);
6741 }
6742 
6743 void ClassFileParser::clear_class_metadata() {
6744   // metadata created before the instance klass is created.  Must be
6745   // deallocated if classfile parsing returns an error.
6746   _cp = NULL;
6747   _fields = NULL;
6748   _methods = NULL;
6749   _inner_classes = NULL;
6750   _nest_members = NULL;
6751   _permitted_subclasses = NULL;
6752   _combined_annotations = NULL;
6753   _class_annotations = _class_type_annotations = NULL;
6754   _fields_annotations = _fields_type_annotations = NULL;
6755   _record_components = NULL;
6756 }
6757 
6758 // Destructor to clean up
6759 ClassFileParser::~ClassFileParser() {
6760   _class_name-&gt;decrement_refcount();
6761 
6762   if (_cp != NULL) {
6763     MetadataFactory::free_metadata(_loader_data, _cp);
6764   }
6765   if (_fields != NULL) {
6766     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _fields);
6767   }
6768 
6769   if (_methods != NULL) {
6770     // Free methods
6771     InstanceKlass::deallocate_methods(_loader_data, _methods);
6772   }
6773 
6774   // beware of the Universe::empty_blah_array!!
6775   if (_inner_classes != NULL &amp;&amp; _inner_classes != Universe::the_empty_short_array()) {
6776     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _inner_classes);
6777   }
6778 
6779   if (_nest_members != NULL &amp;&amp; _nest_members != Universe::the_empty_short_array()) {
6780     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _nest_members);
6781   }
6782 
6783   if (_record_components != NULL) {
6784     InstanceKlass::deallocate_record_components(_loader_data, _record_components);
6785   }
6786 
6787   if (_permitted_subclasses != NULL &amp;&amp; _permitted_subclasses != Universe::the_empty_short_array()) {
6788     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _permitted_subclasses);
6789   }
6790 
6791   // Free interfaces
6792   InstanceKlass::deallocate_interfaces(_loader_data, _super_klass,
6793                                        _local_interfaces, _transitive_interfaces);
6794 
6795   if (_combined_annotations != NULL) {
6796     // After all annotations arrays have been created, they are installed into the
6797     // Annotations object that will be assigned to the InstanceKlass being created.
6798 
6799     // Deallocate the Annotations object and the installed annotations arrays.
6800     _combined_annotations-&gt;deallocate_contents(_loader_data);
6801 
6802     // If the _combined_annotations pointer is non-NULL,
6803     // then the other annotations fields should have been cleared.
6804     assert(_class_annotations       == NULL, &quot;Should have been cleared&quot;);
6805     assert(_class_type_annotations  == NULL, &quot;Should have been cleared&quot;);
6806     assert(_fields_annotations      == NULL, &quot;Should have been cleared&quot;);
6807     assert(_fields_type_annotations == NULL, &quot;Should have been cleared&quot;);
6808   } else {
6809     // If the annotations arrays were not installed into the Annotations object,
6810     // then they have to be deallocated explicitly.
6811     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_annotations);
6812     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_type_annotations);
6813     Annotations::free_contents(_loader_data, _fields_annotations);
6814     Annotations::free_contents(_loader_data, _fields_type_annotations);
6815   }
6816 
6817   clear_class_metadata();
6818   _transitive_interfaces = NULL;
6819   _local_interfaces = NULL;
6820 
6821   // deallocate the klass if already created.  Don&#39;t directly deallocate, but add
6822   // to the deallocate list so that the klass is removed from the CLD::_klasses list
6823   // at a safepoint.
6824   if (_klass_to_deallocate != NULL) {
6825     _loader_data-&gt;add_to_deallocate_list(_klass_to_deallocate);
6826   }
6827 }
6828 
6829 void ClassFileParser::parse_stream(const ClassFileStream* const stream,
6830                                    TRAPS) {
6831 
6832   assert(stream != NULL, &quot;invariant&quot;);
6833   assert(_class_name != NULL, &quot;invariant&quot;);
6834 
6835   // BEGIN STREAM PARSING
6836   stream-&gt;guarantee_more(8, CHECK);  // magic, major, minor
6837   // Magic value
6838   const u4 magic = stream-&gt;get_u4_fast();
6839   guarantee_property(magic == JAVA_CLASSFILE_MAGIC,
6840                      &quot;Incompatible magic value %u in class file %s&quot;,
6841                      magic, CHECK);
6842 
6843   // Version numbers
6844   _minor_version = stream-&gt;get_u2_fast();
6845   _major_version = stream-&gt;get_u2_fast();
6846 
6847   if (DumpSharedSpaces &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6848     ResourceMark rm;
6849     warning(&quot;Pre JDK 6 class not supported by CDS: %u.%u %s&quot;,
6850             _major_version,  _minor_version, _class_name-&gt;as_C_string());
6851     Exceptions::fthrow(
6852       THREAD_AND_LOCATION,
6853       vmSymbols::java_lang_UnsupportedClassVersionError(),
6854       &quot;Unsupported major.minor version for dump time %u.%u&quot;,
6855       _major_version,
6856       _minor_version);
6857   }
6858 
6859   // Check version numbers - we check this even with verifier off
6860   verify_class_version(_major_version, _minor_version, _class_name, CHECK);
6861 
6862   stream-&gt;guarantee_more(3, CHECK); // length, first cp tag
6863   u2 cp_size = stream-&gt;get_u2_fast();
6864 
6865   guarantee_property(
6866     cp_size &gt;= 1, &quot;Illegal constant pool size %u in class file %s&quot;,
6867     cp_size, CHECK);
6868 
6869   _orig_cp_size = cp_size;
6870   if (is_hidden()) { // Add a slot for hidden class name.
6871     assert(_max_num_patched_klasses == 0, &quot;Sanity check&quot;);
6872     cp_size++;
6873   } else {
6874     if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {
6875       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);
6876     }
6877     cp_size += _max_num_patched_klasses;
6878   }
6879 
6880   _cp = ConstantPool::allocate(_loader_data,
6881                                cp_size,
6882                                CHECK);
6883 
6884   ConstantPool* const cp = _cp;
6885 
6886   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6887 
6888   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6889 
6890   // ACCESS FLAGS
6891   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6892 
6893   jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;
6894   // JVM_ACC_MODULE is defined in JDK-9 and later.
6895   if (_major_version &gt;= JAVA_9_VERSION) {
6896     recognized_modifiers |= JVM_ACC_MODULE;
6897   }
6898   // JVM_ACC_VALUE is defined for class file version 55 and later
6899   if (supports_inline_types()) {
6900     recognized_modifiers |= JVM_ACC_VALUE;
6901   }
6902 
6903   // Access flags
6904   jint flags = stream-&gt;get_u2_fast() &amp; recognized_modifiers;
6905 
6906   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6907     // Set abstract bit for old class files for backward compatibility
6908     flags |= JVM_ACC_ABSTRACT;
6909   }
6910 
6911   verify_legal_class_modifiers(flags, CHECK);
6912 
6913   short bad_constant = class_bad_constant_seen();
6914   if (bad_constant != 0) {
6915     // Do not throw CFE until after the access_flags are checked because if
6916     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6917     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6918   }
6919 
6920   _access_flags.set_flags(flags);
6921 
6922   // This class and superclass
6923   _this_class_index = stream-&gt;get_u2_fast();
6924   check_property(
6925     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
6926       cp-&gt;tag_at(_this_class_index).is_unresolved_klass(),
6927     &quot;Invalid this class index %u in constant pool in class file %s&quot;,
6928     _this_class_index, CHECK);
6929 
6930   Symbol* const class_name_in_cp = cp-&gt;klass_name_at(_this_class_index);
6931   assert(class_name_in_cp != NULL, &quot;class_name can&#39;t be null&quot;);
6932 
6933   // Don&#39;t need to check whether this class name is legal or not.
6934   // It has been checked when constant pool is parsed.
6935   // However, make sure it is not an array type.
6936   if (_need_verify) {
6937     guarantee_property(class_name_in_cp-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
6938                        &quot;Bad class name in class file %s&quot;,
6939                        CHECK);
6940   }
6941 
6942 #ifdef ASSERT
6943   // Basic sanity checks
6944   assert(!(_is_hidden &amp;&amp; (_unsafe_anonymous_host != NULL)), &quot;mutually exclusive variants&quot;);
6945 
6946   if (_unsafe_anonymous_host != NULL) {
6947     assert(_class_name == vmSymbols::unknown_class_name(), &quot;A named anonymous class???&quot;);
6948   }
6949   if (_is_hidden) {
6950     assert(_class_name != vmSymbols::unknown_class_name(), &quot;hidden classes should have a special name&quot;);
6951   }
6952 #endif
6953 
6954   // Update the _class_name as needed depending on whether this is a named,
6955   // un-named, hidden or unsafe-anonymous class.
6956 
6957   if (_is_hidden) {
6958     assert(_class_name != NULL, &quot;Unexpected null _class_name&quot;);
6959 #ifdef ASSERT
6960     if (_need_verify) {
6961       verify_legal_class_name(_class_name, CHECK);
6962     }
6963 #endif
6964 
6965   // NOTE: !_is_hidden does not imply &quot;findable&quot; as it could be an old-style
6966   //       &quot;hidden&quot; unsafe-anonymous class
6967 
6968   // If this is an anonymous class fix up its name if it is in the unnamed
6969   // package.  Otherwise, throw IAE if it is in a different package than
6970   // its host class.
6971   } else if (_unsafe_anonymous_host != NULL) {
6972     update_class_name(class_name_in_cp);
6973     fix_unsafe_anonymous_class_name(CHECK);
6974 
6975   } else {
6976     // Check if name in class file matches given name
6977     if (_class_name != class_name_in_cp) {
6978       if (_class_name != vmSymbols::unknown_class_name()) {
6979         ResourceMark rm(THREAD);
6980         Exceptions::fthrow(THREAD_AND_LOCATION,
6981                            vmSymbols::java_lang_NoClassDefFoundError(),
6982                            &quot;%s (wrong name: %s)&quot;,
6983                            class_name_in_cp-&gt;as_C_string(),
6984                            _class_name-&gt;as_C_string()
6985                            );
6986         return;
6987       } else {
6988         // The class name was not known by the caller so we set it from
6989         // the value in the CP.
6990         update_class_name(class_name_in_cp);
6991       }
6992       // else nothing to do: the expected class name matches what is in the CP
6993     }
6994   }
6995 
6996   // Verification prevents us from creating names with dots in them, this
6997   // asserts that that&#39;s the case.
6998   assert(is_internal_format(_class_name), &quot;external class name format used internally&quot;);
6999 
7000   if (!is_internal()) {
7001     LogTarget(Debug, class, preorder) lt;
7002     if (lt.is_enabled()){
7003       ResourceMark rm(THREAD);
7004       LogStream ls(lt);
7005       ls.print(&quot;%s&quot;, _class_name-&gt;as_klass_external_name());
7006       if (stream-&gt;source() != NULL) {
7007         ls.print(&quot; source: %s&quot;, stream-&gt;source());
7008       }
7009       ls.cr();
7010     }
7011 
7012 #if INCLUDE_CDS
7013     if (DumpLoadedClassList != NULL &amp;&amp; stream-&gt;source() != NULL &amp;&amp; classlist_file-&gt;is_open()) {
7014       if (!ClassLoader::has_jrt_entry()) {
7015         warning(&quot;DumpLoadedClassList and CDS are not supported in exploded build&quot;);
7016         DumpLoadedClassList = NULL;
7017       } else if (SystemDictionaryShared::is_sharing_possible(_loader_data) &amp;&amp;
7018                  !_is_hidden &amp;&amp;
7019                  _unsafe_anonymous_host == NULL) {
7020         // Only dump the classes that can be stored into CDS archive.
7021         // Hidden and unsafe anonymous classes such as generated LambdaForm classes are also not included.
7022         oop class_loader = _loader_data-&gt;class_loader();
7023         ResourceMark rm(THREAD);
7024         bool skip = false;
7025         if (class_loader == NULL || SystemDictionary::is_platform_class_loader(class_loader)) {
7026           // For the boot and platform class loaders, skip classes that are not found in the
7027           // java runtime image, such as those found in the --patch-module entries.
7028           // These classes can&#39;t be loaded from the archive during runtime.
7029           if (!stream-&gt;from_boot_loader_modules_image() &amp;&amp; strncmp(stream-&gt;source(), &quot;jrt:&quot;, 4) != 0) {
7030             skip = true;
7031           }
7032 
7033           if (class_loader == NULL &amp;&amp; ClassLoader::contains_append_entry(stream-&gt;source())) {
7034             // .. but don&#39;t skip the boot classes that are loaded from -Xbootclasspath/a
7035             // as they can be loaded from the archive during runtime.
7036             skip = false;
7037           }
7038         }
7039         if (skip) {
7040           tty-&gt;print_cr(&quot;skip writing class %s from source %s to classlist file&quot;,
7041             _class_name-&gt;as_C_string(), stream-&gt;source());
7042         } else {
7043           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
7044           classlist_file-&gt;flush();
7045         }
7046       }
7047     }
7048 #endif
7049   }
7050 
7051   // SUPERKLASS
7052   _super_class_index = stream-&gt;get_u2_fast();
7053   _super_klass = parse_super_class(cp,
7054                                    _super_class_index,
7055                                    _need_verify,
7056                                    CHECK);
7057 
7058   // Interfaces
7059   _itfs_len = stream-&gt;get_u2_fast();
7060   parse_interfaces(stream,
7061                    _itfs_len,
7062                    cp,
7063                    is_inline_type(),
7064                    &amp;_has_nonstatic_concrete_methods,
7065                    &amp;_is_declared_atomic,
7066                    CHECK);
7067 
7068   assert(_temp_local_interfaces != NULL, &quot;invariant&quot;);
7069 
7070   // Fields (offsets are filled in later)
7071   _fac = new FieldAllocationCount();
7072   parse_fields(stream,
7073                is_interface(),
7074                is_inline_type(),
7075                _fac,
7076                cp,
7077                cp_size,
7078                &amp;_java_fields_count,
7079                CHECK);
7080 
7081   assert(_fields != NULL, &quot;invariant&quot;);
7082 
7083   // Methods
7084   AccessFlags promoted_flags;
7085   parse_methods(stream,
7086                 is_interface(),
7087                 is_inline_type(),
7088                 &amp;promoted_flags,
7089                 &amp;_has_final_method,
7090                 &amp;_declares_nonstatic_concrete_methods,
7091                 CHECK);
7092 
7093   assert(_methods != NULL, &quot;invariant&quot;);
7094 
7095   // promote flags from parse_methods() to the klass&#39; flags
7096   _access_flags.add_promoted_flags(promoted_flags.as_int());
7097 
7098   if (_declares_nonstatic_concrete_methods) {
7099     _has_nonstatic_concrete_methods = true;
7100   }
7101 
7102   // Additional attributes/annotations
7103   _parsed_annotations = new ClassAnnotationCollector();
7104   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
7105 
7106   assert(_inner_classes != NULL, &quot;invariant&quot;);
7107 
7108   // Finalize the Annotations metadata object,
7109   // now that all annotation arrays have been created.
7110   create_combined_annotations(CHECK);
7111 
7112   // Make sure this is the end of class file stream
7113   guarantee_property(stream-&gt;at_eos(),
7114                      &quot;Extra bytes at the end of class file %s&quot;,
7115                      CHECK);
7116 
7117   // all bytes in stream read and parsed
7118 }
7119 
7120 void ClassFileParser::mangle_hidden_class_name(InstanceKlass* const ik) {
7121   ResourceMark rm;
7122   // Construct hidden name from _class_name, &quot;+&quot;, and &amp;ik. Note that we can&#39;t
7123   // use a &#39;/&#39; because that confuses finding the class&#39;s package.  Also, can&#39;t
7124   // use an illegal char such as &#39;;&#39; because that causes serialization issues
7125   // and issues with hidden classes that create their own hidden classes.
7126   char addr_buf[20];
7127   jio_snprintf(addr_buf, 20, INTPTR_FORMAT, p2i(ik));
7128   size_t new_name_len = _class_name-&gt;utf8_length() + 2 + strlen(addr_buf);
7129   char* new_name = NEW_RESOURCE_ARRAY(char, new_name_len);
7130   jio_snprintf(new_name, new_name_len, &quot;%s+%s&quot;,
7131                _class_name-&gt;as_C_string(), addr_buf);
7132   update_class_name(SymbolTable::new_symbol(new_name));
7133 
7134   // Add a Utf8 entry containing the hidden name.
7135   assert(_class_name != NULL, &quot;Unexpected null _class_name&quot;);
7136   int hidden_index = _orig_cp_size; // this is an extra slot we added
7137   _cp-&gt;symbol_at_put(hidden_index, _class_name);
7138 
7139   // Update this_class_index&#39;s slot in the constant pool with the new Utf8 entry.
7140   // We have to update the resolved_klass_index and the name_index together
7141   // so extract the existing resolved_klass_index first.
7142   CPKlassSlot cp_klass_slot = _cp-&gt;klass_slot_at(_this_class_index);
7143   int resolved_klass_index = cp_klass_slot.resolved_klass_index();
7144   _cp-&gt;unresolved_klass_at_put(_this_class_index, hidden_index, resolved_klass_index);
7145   assert(_cp-&gt;klass_slot_at(_this_class_index).name_index() == _orig_cp_size,
7146          &quot;Bad name_index&quot;);
7147 }
7148 
7149 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
7150                                                  ConstantPool* cp,
7151                                                  TRAPS) {
7152   assert(stream != NULL, &quot;invariant&quot;);
7153   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
7154   assert(cp != NULL, &quot;invariant&quot;);
7155   assert(_loader_data != NULL, &quot;invariant&quot;);
7156 
7157   if (_class_name == vmSymbols::java_lang_Object()) {
7158     check_property(_temp_local_interfaces-&gt;length() == 0,
7159         &quot;java.lang.Object cannot implement an interface in class file %s&quot;,
7160         CHECK);
7161   }
7162   // We check super class after class file is parsed and format is checked
7163   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
7164     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
7165     if (is_interface()) {
7166       // Before attempting to resolve the superclass, check for class format
7167       // errors not checked yet.
7168       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
7169         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
7170         CHECK);
7171     }
7172     Handle loader(THREAD, _loader_data-&gt;class_loader());
7173     _super_klass = (const InstanceKlass*)
7174                        SystemDictionary::resolve_super_or_fail(_class_name,
7175                                                                super_class_name,
7176                                                                loader,
7177                                                                _protection_domain,
7178                                                                true,
7179                                                                CHECK);
7180   }
7181 
7182   if (_super_klass != NULL) {
7183     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
7184       _has_nonstatic_concrete_methods = true;
7185     }
7186     if (_super_klass-&gt;is_declared_atomic()) {
7187       _is_declared_atomic = true;
7188     }
7189 
7190     if (_super_klass-&gt;is_interface()) {
7191       ResourceMark rm(THREAD);
7192       Exceptions::fthrow(
7193         THREAD_AND_LOCATION,
7194         vmSymbols::java_lang_IncompatibleClassChangeError(),
7195         &quot;class %s has interface %s as super class&quot;,
7196         _class_name-&gt;as_klass_external_name(),
7197         _super_klass-&gt;external_name()
7198       );
7199       return;
7200     }
7201 
7202     // For an inline class, only java/lang/Object or special abstract classes
7203     // are acceptable super classes.
7204     if (is_inline_type()) {
7205       const InstanceKlass* super_ik = _super_klass;
7206       if (super_ik-&gt;invalid_inline_super()) {
7207         ResourceMark rm(THREAD);
7208         Exceptions::fthrow(
7209           THREAD_AND_LOCATION,
7210           vmSymbols::java_lang_IncompatibleClassChangeError(),
7211           &quot;inline class %s has an invalid super class %s&quot;,
7212           _class_name-&gt;as_klass_external_name(),
7213           _super_klass-&gt;external_name());
7214         return;
7215       }
7216     }
7217   }
7218 
7219   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {
7220     // This is the original source of this condition.
7221     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.
7222     _is_declared_atomic = true;
7223   } else if (*ForceNonTearable != &#39;\0&#39;) {
7224     // Allow a command line switch to force the same atomicity property:
7225     const char* class_name_str = _class_name-&gt;as_C_string();
7226     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {
7227       _is_declared_atomic = true;
7228     }
7229   }
7230 
7231   // Set ik-&gt;invalid_inline_super field to TRUE if already marked as invalid,
7232   // if super is marked invalid, or if is_invalid_super_for_inline_type()
7233   // returns true
7234   if (invalid_inline_super() ||
7235       (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||
7236       is_invalid_super_for_inline_type()) {
7237     set_invalid_inline_super();
7238   }
7239 
7240   if (!is_inline_type() &amp;&amp; invalid_inline_super() &amp;&amp; (_super_klass == NULL || !_super_klass-&gt;invalid_inline_super())
7241       &amp;&amp; !_implements_identityObject &amp;&amp; class_name() != vmSymbols::java_lang_IdentityObject()) {
7242     _temp_local_interfaces-&gt;append(SystemDictionary::IdentityObject_klass());
7243     _has_injected_identityObject = true;
7244   }
7245   int itfs_len = _temp_local_interfaces-&gt;length();
7246   if (itfs_len == 0) {
7247     _local_interfaces = Universe::the_empty_instance_klass_array();
7248   } else if (itfs_len == 1 &amp;&amp; _temp_local_interfaces-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {
7249     _local_interfaces = Universe::the_single_IdentityObject_klass_array();
7250   } else {
7251     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);
7252     for (int i = 0; i &lt; itfs_len; i++) {
7253       _local_interfaces-&gt;at_put(i, _temp_local_interfaces-&gt;at(i));
7254     }
7255   }
7256   _temp_local_interfaces = NULL;
7257   assert(_local_interfaces != NULL, &quot;invariant&quot;);
7258 
7259   // Compute the transitive list of all unique interfaces implemented by this class
7260   _transitive_interfaces =
7261     compute_transitive_interfaces(_super_klass,
7262                                   _local_interfaces,
7263                                   _loader_data,
7264                                   CHECK);
7265 
7266   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
7267 
7268   // sort methods
7269   _method_ordering = sort_methods(_methods);
7270 
7271   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
7272 
7273   Handle loader(THREAD, _loader_data-&gt;class_loader());
7274   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
7275                                                     &amp;_num_miranda_methods,
7276                                                     _all_mirandas,
7277                                                     _super_klass,
7278                                                     _methods,
7279                                                     _access_flags,
7280                                                     _major_version,
7281                                                     loader,
7282                                                     _class_name,
7283                                                     _local_interfaces,
7284                                                     CHECK);
7285 
7286   // Size of Java itable (in words)
7287   _itable_size = is_interface() ? 0 :
7288     klassItable::compute_itable_size(_transitive_interfaces);
7289 
7290   assert(_fac != NULL, &quot;invariant&quot;);
7291   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
7292 
7293 
7294   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
<a name="31" id="anc31"></a><span class="line-modified">7295     if (fs.is_flattenable() &amp;&amp; !fs.access_flags().is_static()) {</span>
7296       // Pre-load value class
<a name="32" id="anc32"></a><span class="line-modified">7297       Klass* klass = SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,</span>
7298           Handle(THREAD, _loader_data-&gt;class_loader()),
7299           _protection_domain, true, CHECK);
7300       assert(klass != NULL, &quot;Sanity check&quot;);
<a name="33" id="anc33"></a><span class="line-modified">7301       assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);</span>
<span class="line-removed">7302       _has_flattenable_fields = true;</span>
7303     }
7304   }
7305 
7306   _field_info = new FieldLayoutInfo();
7307   if (UseNewFieldLayout) {
7308     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
7309         _parsed_annotations-&gt;is_contended(), is_inline_type(),
7310         loader_data(), _protection_domain, _field_info);
7311     lb.build_layout(CHECK);
7312     if (is_inline_type()) {
7313       _alignment = lb.get_alignment();
7314       _first_field_offset = lb.get_first_field_offset();
7315       _exact_size_in_bytes = lb.get_exact_size_in_byte();
7316     }
7317   } else {
7318     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
7319   }
<a name="34" id="anc34"></a>
7320 
7321   // Compute reference type
7322   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
7323 }
7324 
7325 void ClassFileParser::set_klass(InstanceKlass* klass) {
7326 
7327 #ifdef ASSERT
7328   if (klass != NULL) {
7329     assert(NULL == _klass, &quot;leaking?&quot;);
7330   }
7331 #endif
7332 
7333   _klass = klass;
7334 }
7335 
7336 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
7337 
7338 #ifdef ASSERT
7339   if (klass != NULL) {
7340     assert(NULL == _klass_to_deallocate, &quot;leaking?&quot;);
7341   }
7342 #endif
7343 
7344   _klass_to_deallocate = klass;
7345 }
7346 
7347 // Caller responsible for ResourceMark
7348 // clone stream with rewound position
7349 const ClassFileStream* ClassFileParser::clone_stream() const {
7350   assert(_stream != NULL, &quot;invariant&quot;);
7351 
7352   return _stream-&gt;clone();
7353 }
7354 
7355 // ----------------------------------------------------------------------------
7356 // debugging
7357 
7358 #ifdef ASSERT
7359 
7360 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
7361 bool ClassFileParser::is_internal_format(Symbol* class_name) {
7362   if (class_name != NULL) {
7363     ResourceMark rm;
7364     char* name = class_name-&gt;as_C_string();
7365     return strchr(name, JVM_SIGNATURE_DOT) == NULL;
7366   } else {
7367     return true;
7368   }
7369 }
7370 
7371 #endif
<a name="35" id="anc35"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="35" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../ci/ciField.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1501                                             CHECK);
1502   parsed_annotations-&gt;set_field_annotations(a);
1503   a = assemble_annotations(runtime_visible_type_annotations,
1504                            runtime_visible_type_annotations_length,
1505                            runtime_invisible_type_annotations,
1506                            runtime_invisible_type_annotations_length,
1507                            CHECK);
1508   parsed_annotations-&gt;set_field_type_annotations(a);
1509   return;
1510 }
1511 
1512 
1513 // Field allocation types. Used for computing field offsets.
1514 
1515 enum FieldAllocationType {
1516   STATIC_OOP,           // Oops
1517   STATIC_BYTE,          // Boolean, Byte, char
1518   STATIC_SHORT,         // shorts
1519   STATIC_WORD,          // ints
1520   STATIC_DOUBLE,        // aligned long or double
<span class="line-modified">1521   STATIC_FLATTENABLE,   // flattenable field</span>
1522   NONSTATIC_OOP,
1523   NONSTATIC_BYTE,
1524   NONSTATIC_SHORT,
1525   NONSTATIC_WORD,
1526   NONSTATIC_DOUBLE,
<span class="line-modified">1527   NONSTATIC_FLATTENABLE,</span>
1528   MAX_FIELD_ALLOCATION_TYPE,
1529   BAD_ALLOCATION_TYPE = -1
1530 };
1531 
1532 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1533   BAD_ALLOCATION_TYPE, // 0
1534   BAD_ALLOCATION_TYPE, // 1
1535   BAD_ALLOCATION_TYPE, // 2
1536   BAD_ALLOCATION_TYPE, // 3
1537   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1538   NONSTATIC_SHORT,     // T_CHAR        =  5,
1539   NONSTATIC_WORD,      // T_FLOAT       =  6,
1540   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1541   NONSTATIC_BYTE,      // T_BYTE        =  8,
1542   NONSTATIC_SHORT,     // T_SHORT       =  9,
1543   NONSTATIC_WORD,      // T_INT         = 10,
1544   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1545   NONSTATIC_OOP,       // T_OBJECT      = 12,
1546   NONSTATIC_OOP,       // T_ARRAY       = 13,
1547   NONSTATIC_OOP,       // T_VALUETYPE   = 14,
</pre>
<hr />
<pre>
1557   BAD_ALLOCATION_TYPE, // 3
1558   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1559   STATIC_SHORT,        // T_CHAR        =  5,
1560   STATIC_WORD,         // T_FLOAT       =  6,
1561   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1562   STATIC_BYTE,         // T_BYTE        =  8,
1563   STATIC_SHORT,        // T_SHORT       =  9,
1564   STATIC_WORD,         // T_INT         = 10,
1565   STATIC_DOUBLE,       // T_LONG        = 11,
1566   STATIC_OOP,          // T_OBJECT      = 12,
1567   STATIC_OOP,          // T_ARRAY       = 13,
1568   STATIC_OOP,          // T_VALUETYPE   = 14,
1569   BAD_ALLOCATION_TYPE, // T_VOID        = 15,
1570   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,
1571   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,
1572   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,
1573   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,
1574   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20
1575 };
1576 
<span class="line-modified">1577 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type, bool is_flattenable) {</span>
1578   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1579   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1580   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);
<span class="line-modified">1581   if (is_flattenable) {</span>
<span class="line-modified">1582     result = is_static ? STATIC_FLATTENABLE : NONSTATIC_FLATTENABLE;</span>
1583   }
1584   return result;
1585 }
1586 
1587 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1588  public:
1589   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1590 
1591   FieldAllocationCount() {
1592     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1593       count[i] = 0;
1594     }
1595   }
1596 
<span class="line-modified">1597   FieldAllocationType update(bool is_static, BasicType type, bool is_flattenable) {</span>
<span class="line-modified">1598     FieldAllocationType atype = basic_type_to_atype(is_static, type, is_flattenable);</span>
1599     if (atype != BAD_ALLOCATION_TYPE) {
1600       // Make sure there is no overflow with injected fields.
1601       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1602       count[atype]++;
1603     }
1604     return atype;
1605   }
1606 };
1607 
1608 // Side-effects: populates the _fields, _fields_annotations,
1609 // _fields_type_annotations fields
1610 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1611                                    bool is_interface,
1612                                    bool is_inline_type,
1613                                    FieldAllocationCount* const fac,
1614                                    ConstantPool* cp,
1615                                    const int cp_size,
1616                                    u2* const java_fields_count_ptr,
1617                                    TRAPS) {
1618 
</pre>
<hr />
<pre>
1674     jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;
1675 
1676     const jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;
1677     verify_legal_field_modifiers(flags, is_interface, is_inline_type, CHECK);
1678     AccessFlags access_flags;
1679     access_flags.set_flags(flags);
1680 
1681     const u2 name_index = cfs-&gt;get_u2_fast();
1682     check_property(valid_symbol_at(name_index),
1683       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1684       name_index, CHECK);
1685     const Symbol* const name = cp-&gt;symbol_at(name_index);
1686     verify_legal_field_name(name, CHECK);
1687 
1688     const u2 signature_index = cfs-&gt;get_u2_fast();
1689     check_property(valid_symbol_at(signature_index),
1690       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1691       signature_index, CHECK);
1692     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1693     verify_legal_field_signature(name, sig, CHECK);
<span class="line-removed">1694     assert(!access_flags.is_flattenable(), &quot;ACC_FLATTENABLE should have been filtered out&quot;);</span>
<span class="line-removed">1695     if (sig-&gt;is_Q_signature()) {</span>
<span class="line-removed">1696       // assert(_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS, &quot;Q-descriptors are only supported in recent classfiles&quot;);</span>
<span class="line-removed">1697       access_flags.set_is_flattenable();</span>
<span class="line-removed">1698     }</span>
<span class="line-removed">1699     if (access_flags.is_flattenable()) {</span>
<span class="line-removed">1700       // Array flattenability cannot be specified.  Arrays of value classes are</span>
<span class="line-removed">1701       // are always flattenable.  Arrays of other classes are not flattenable.</span>
<span class="line-removed">1702       if (sig-&gt;utf8_length() &gt; 1 &amp;&amp; sig-&gt;char_at(0) == &#39;[&#39;) {</span>
<span class="line-removed">1703         classfile_parse_error(</span>
<span class="line-removed">1704             &quot;Field \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s is invalid.&quot;</span>
<span class="line-removed">1705             &quot; ACC_FLATTENABLE cannot be specified for an array&quot;,</span>
<span class="line-removed">1706             name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);</span>
<span class="line-removed">1707       }</span>
<span class="line-removed">1708       _has_flattenable_fields = true;</span>
<span class="line-removed">1709     }</span>
1710     if (!access_flags.is_static()) instance_fields_count++;
1711 
1712     u2 constantvalue_index = 0;
1713     bool is_synthetic = false;
1714     u2 generic_signature_index = 0;
1715     const bool is_static = access_flags.is_static();
1716     FieldAnnotationCollector parsed_annotations(_loader_data);
1717 
1718     const u2 attributes_count = cfs-&gt;get_u2_fast();
1719     if (attributes_count &gt; 0) {
1720       parse_field_attributes(cfs,
1721                              attributes_count,
1722                              is_static,
1723                              signature_index,
1724                              &amp;constantvalue_index,
1725                              &amp;is_synthetic,
1726                              &amp;generic_signature_index,
1727                              &amp;parsed_annotations,
1728                              CHECK);
1729 
</pre>
<hr />
<pre>
1750 
1751       if (is_synthetic) {
1752         access_flags.set_is_synthetic();
1753       }
1754       if (generic_signature_index != 0) {
1755         access_flags.set_field_has_generic_signature();
1756         fa[generic_signature_slot] = generic_signature_index;
1757         generic_signature_slot ++;
1758         num_generic_signature ++;
1759       }
1760     }
1761 
1762     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1763     field-&gt;initialize(access_flags.as_short(),
1764                       name_index,
1765                       signature_index,
1766                       constantvalue_index);
1767     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1768 
1769     // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1770     const FieldAllocationType atype = fac-&gt;update(is_static, type, access_flags.is_flattenable());</span>
1771     field-&gt;set_allocation_type(atype);
1772 
1773     // After field is initialized with type, we can augment it with aux info
1774     if (parsed_annotations.has_any_annotations()) {
1775       parsed_annotations.apply_to(field);
1776       if (field-&gt;is_contended()) {
1777         _has_contended_fields = true;
1778       }
1779     }
1780   }
1781 
1782   int index = length;
1783   if (num_injected != 0) {
1784     for (int n = 0; n &lt; num_injected; n++) {
1785       // Check for duplicates
1786       if (injected[n].may_be_java) {
1787         const Symbol* const name      = injected[n].name();
1788         const Symbol* const signature = injected[n].signature();
1789         bool duplicate = false;
1790         for (int i = 0; i &lt; length; i++) {
</pre>
<hr />
<pre>
4309   //
4310   // We ignore static fields, because @Contended is not supported for them.
4311   // The layout code below will also ignore the static fields.
4312   int nonstatic_contended_count = 0;
4313   FieldAllocationCount fac_contended;
4314   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4315     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4316     if (fs.is_contended()) {
4317       fac_contended.count[atype]++;
4318       if (!fs.access_flags().is_static()) {
4319         nonstatic_contended_count++;
4320       }
4321     }
4322   }
4323 
4324 
4325   // Calculate the starting byte offsets
4326   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
4327   // Inline types in static fields are not embedded, they are handled with oops
4328   int next_static_double_offset = next_static_oop_offset +
<span class="line-modified">4329                                   ((fac-&gt;count[STATIC_OOP] + fac-&gt;count[STATIC_FLATTENABLE]) * heapOopSize);</span>
4330   if (fac-&gt;count[STATIC_DOUBLE]) {
4331     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4332   }
4333 
4334   int next_static_word_offset   = next_static_double_offset +
4335                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4336   int next_static_short_offset  = next_static_word_offset +
4337                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4338   int next_static_byte_offset   = next_static_short_offset +
4339                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4340 
4341   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4342                                 nonstatic_field_size * heapOopSize;
4343 
4344   // First field of inline types is aligned on a long boundary in order to ease
4345   // in-lining of inline types (with header removal) in packed arrays and
<span class="line-modified">4346   // flatten inline types</span>
4347   int initial_inline_type_padding = 0;
4348   if (is_inline_type()) {
4349     int old = nonstatic_fields_start;
4350     nonstatic_fields_start = align_up(nonstatic_fields_start, BytesPerLong);
4351     initial_inline_type_padding = nonstatic_fields_start - old;
4352   }
4353 
4354   int next_nonstatic_field_offset = nonstatic_fields_start;
4355 
4356   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4357 
4358   // Class is contended, pad before all the fields
4359   if (is_contended_class) {
4360     next_nonstatic_field_offset += ContendedPaddingWidth;
4361   }
4362 
4363   // Temporary inline types restrictions
4364   if (is_inline_type()) {
4365     if (is_contended_class) {
4366       throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support @Contended annotation yet&quot;);
</pre>
<hr />
<pre>
4369   }
4370 
4371   // Compute the non-contended fields count.
4372   // The packing code below relies on these counts to determine if some field
4373   // can be squeezed into the alignment gap. Contended fields are obviously
4374   // exempt from that.
4375   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4376   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4377   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4378   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4379   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4380 
4381   int static_inline_type_count = 0;
4382   int nonstatic_inline_type_count = 0;
4383   int* nonstatic_inline_type_indexes = NULL;
4384   Klass** nonstatic_inline_type_klasses = NULL;
4385   unsigned int inline_type_oop_map_count = 0;
4386   int not_flattened_inline_types = 0;
4387   int not_atomic_inline_types = 0;
4388 
<span class="line-modified">4389   int max_nonstatic_inline_type = fac-&gt;count[NONSTATIC_FLATTENABLE] + 1;</span>
4390 
4391   nonstatic_inline_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,
4392                                                                max_nonstatic_inline_type);
4393   for (int i = 0; i &lt; max_nonstatic_inline_type; i++) {
4394     nonstatic_inline_type_indexes[i] = -1;
4395   }
4396   nonstatic_inline_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,
4397                                                                max_nonstatic_inline_type);
4398 
4399   for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {
<span class="line-modified">4400     if (fs.allocation_type() == STATIC_FLATTENABLE) {</span>
4401       ResourceMark rm;
4402       if (!fs.signature()-&gt;is_Q_signature()) {
4403         THROW(vmSymbols::java_lang_ClassFormatError());
4404       }
4405       static_inline_type_count++;
<span class="line-modified">4406     } else if (fs.allocation_type() == NONSTATIC_FLATTENABLE) {</span>
<span class="line-modified">4407       // Pre-resolve the flattenable field and check for inline type circularity issues.</span>
4408       ResourceMark rm;
4409       if (!fs.signature()-&gt;is_Q_signature()) {
4410         THROW(vmSymbols::java_lang_ClassFormatError());
4411       }
4412       Klass* klass =
<span class="line-modified">4413         SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,</span>
4414                                                             Handle(THREAD, _loader_data-&gt;class_loader()),
4415                                                             _protection_domain, true, CHECK);
4416       assert(klass != NULL, &quot;Sanity check&quot;);
4417       if (!klass-&gt;access_flags().is_inline_type()) {
4418         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
4419       }
4420       ValueKlass* vk = ValueKlass::cast(klass);
4421       // Conditions to apply flattening or not should be defined in a single place
4422       bool too_big_to_flatten = (InlineFieldMaxFlatSize &gt;= 0 &amp;&amp;
4423                                  (vk-&gt;size_helper() * HeapWordSize) &gt; InlineFieldMaxFlatSize);
4424       bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();
4425       bool too_volatile_to_flatten = fs.access_flags().is_volatile();
4426       if (vk-&gt;is_naturally_atomic()) {
4427         too_atomic_to_flatten = false;
4428         //too_volatile_to_flatten = false; //FIXME
4429         // volatile fields are currently never flattened, this could change in the future
4430       }
4431       if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {
4432         nonstatic_inline_type_indexes[nonstatic_inline_type_count] = fs.index();
4433         nonstatic_inline_type_klasses[nonstatic_inline_type_count] = klass;
</pre>
<hr />
<pre>
4437         if (vklass-&gt;contains_oops()) {
4438           inline_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();
4439         }
4440         fs.set_flattened(true);
4441         if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note
4442           not_atomic_inline_types++;
4443         }
4444       } else {
4445         not_flattened_inline_types++;
4446         fs.set_flattened(false);
4447       }
4448     }
4449   }
4450 
4451   // Adjusting non_static_oop_count to take into account not flattened inline types;
4452   nonstatic_oop_count += not_flattened_inline_types;
4453 
4454   // Total non-static fields count, including every contended field
4455   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4456                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
<span class="line-modified">4457                                         fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_FLATTENABLE];</span>
4458 
4459   const bool super_has_nonstatic_fields =
4460           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4461   const bool has_nonstatic_fields =
4462     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
4463   const bool has_nonstatic_value_fields = nonstatic_inline_type_count &gt; 0;
4464 
4465   if (is_inline_type() &amp;&amp; (!has_nonstatic_fields)) {
4466     // There are a number of fixes required throughout the type system and JIT
4467     throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support zero instance size yet&quot;);
4468     return;
4469   }
4470 
4471   // Prepare list of oops for oop map generation.
4472   //
4473   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4474   // regions. offset[i] is the start of the i-th region, which then has
4475   // count[i] oops following. Before we know how many regions are required,
4476   // we pessimistically allocate the maps to fit all the oops into the
4477   // distinct regions.
</pre>
<hr />
<pre>
4586   next_nonstatic_inline_type_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4587   int next_inline_type_index = 0;
4588 
4589   // Iterate over fields again and compute correct offsets.
4590   // The field allocation type was temporarily stored in the offset slot.
4591   // oop fields are located before non-oop fields (static and non-static).
4592   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4593 
4594     // skip already laid out fields
4595     if (fs.is_offset_set()) continue;
4596 
4597     // contended instance fields are handled below
4598     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4599 
4600     int real_offset = 0;
4601     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4602 
4603     // pack the rest of the fields
4604     switch (atype) {
4605       // Inline types in static fields are handled with oops
<span class="line-modified">4606       case STATIC_FLATTENABLE:   // Fallthrough</span>
4607       case STATIC_OOP:
4608         real_offset = next_static_oop_offset;
4609         next_static_oop_offset += heapOopSize;
4610         break;
4611       case STATIC_BYTE:
4612         real_offset = next_static_byte_offset;
4613         next_static_byte_offset += 1;
4614         break;
4615       case STATIC_SHORT:
4616         real_offset = next_static_short_offset;
4617         next_static_short_offset += BytesPerShort;
4618         break;
4619       case STATIC_WORD:
4620         real_offset = next_static_word_offset;
4621         next_static_word_offset += BytesPerInt;
4622         break;
4623       case STATIC_DOUBLE:
4624         real_offset = next_static_double_offset;
4625         next_static_double_offset += BytesPerLong;
4626         break;
<span class="line-modified">4627       case NONSTATIC_FLATTENABLE:</span>
4628         if (fs.is_flattened()) {
4629           Klass* klass = nonstatic_inline_type_klasses[next_inline_type_index];
4630           assert(klass != NULL, &quot;Klass should have been loaded and resolved earlier&quot;);
4631           assert(klass-&gt;access_flags().is_inline_type(),&quot;Must be an inline type&quot;);
4632           ValueKlass* vklass = ValueKlass::cast(klass);
4633           real_offset = next_nonstatic_inline_type_offset;
4634           next_nonstatic_inline_type_offset += (vklass-&gt;size_helper()) * wordSize - vklass-&gt;first_field_offset();
4635           // aligning next inline type on a 64 bits boundary
4636           next_nonstatic_inline_type_offset = align_up(next_nonstatic_inline_type_offset, BytesPerLong);
4637           next_inline_type_index += 1;
4638 
4639           if (vklass-&gt;contains_oops()) { // add flatten oop maps
4640             int diff = real_offset - vklass-&gt;first_field_offset();
4641             const OopMapBlock* map = vklass-&gt;start_of_nonstatic_oop_maps();
4642             const OopMapBlock* const last_map = map + vklass-&gt;nonstatic_oop_map_count();
4643             while (map &lt; last_map) {
4644               nonstatic_oop_maps-&gt;add(map-&gt;offset() + diff, map-&gt;count());
4645               map++;
4646             }
4647           }
</pre>
<hr />
<pre>
4751 
4752           case NONSTATIC_SHORT:
4753             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4754             real_offset = next_nonstatic_padded_offset;
4755             next_nonstatic_padded_offset += BytesPerShort;
4756             break;
4757 
4758           case NONSTATIC_WORD:
4759             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4760             real_offset = next_nonstatic_padded_offset;
4761             next_nonstatic_padded_offset += BytesPerInt;
4762             break;
4763 
4764           case NONSTATIC_DOUBLE:
4765             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4766             real_offset = next_nonstatic_padded_offset;
4767             next_nonstatic_padded_offset += BytesPerLong;
4768             break;
4769 
4770             // Inline types in static fields are handled with oops
<span class="line-modified">4771           case NONSTATIC_FLATTENABLE:</span>
4772             throwInlineTypeLimitation(THREAD_AND_LOCATION,
4773                                       &quot;@Contended annotation not supported for inline types yet&quot;, fs.name(), fs.signature());
4774             return;
4775 
4776           case NONSTATIC_OOP:
4777             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4778             real_offset = next_nonstatic_padded_offset;
4779             next_nonstatic_padded_offset += heapOopSize;
4780             nonstatic_oop_maps-&gt;add(real_offset, 1);
4781             break;
4782 
4783           default:
4784             ShouldNotReachHere();
4785         }
4786 
4787         if (fs.contended_group() == 0) {
4788           // Contended group defines the equivalence class over the fields:
4789           // the fields within the same contended group are not inter-padded.
4790           // The only exception is default group, which does not incur the
4791           // equivalence, and so requires intra-padding.
</pre>
<hr />
<pre>
4865           instance_size,
4866           nonstatic_fields_start,
4867           nonstatic_fields_end,
4868           static_fields_end);
4869     nonstatic_oop_maps-&gt;print_on(tty);
4870     tty-&gt;print(&quot;\n&quot;);
4871     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);
4872     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);
4873     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);
4874     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);
4875     tty-&gt;print_cr(&quot;---&quot;);
4876   }
4877 
4878 #endif
4879   // Pass back information needed for InstanceKlass creation
4880   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4881   info-&gt;_instance_size = instance_size;
4882   info-&gt;_static_field_size = static_field_size;
4883   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4884   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;

4885 
4886   // An inline type is naturally atomic if it has just one field, and
4887   // that field is simple enough.
4888   info-&gt;_is_naturally_atomic = (is_inline_type() &amp;&amp;
4889                                 !super_has_nonstatic_fields &amp;&amp;
4890                                 (nonstatic_fields_count &lt;= 1) &amp;&amp;
4891                                 (not_atomic_inline_types == 0) &amp;&amp;
4892                                 (nonstatic_contended_count == 0));
4893   // This may be too restrictive, since if all the fields fit in 64
4894   // bits we could make the decision to align instances of this class
4895   // to 64-bit boundaries, and load and store them as single words.
4896   // And on machines which supported larger atomics we could similarly
4897   // allow larger values to be atomic, if properly aligned.
4898 }
4899 
4900 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4901   assert(ik != NULL, &quot;invariant&quot;);
4902 
4903   const Klass* const super = ik-&gt;super();
4904 
</pre>
<hr />
<pre>
6147 
6148   // Not yet: supers are done below to support the new subtype-checking fields
6149   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
6150   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
6151   if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_value()) {
6152     ik-&gt;set_is_naturally_atomic();
6153   }
6154   if (_is_empty_inline_type) {
6155     ik-&gt;set_is_empty_inline_type();
6156   }
6157 
6158   if (this-&gt;_invalid_inline_super) {
6159     ik-&gt;set_invalid_inline_super();
6160   }
6161 
6162   if (_has_injected_identityObject) {
6163     ik-&gt;set_has_injected_identityObject();
6164   }
6165 
6166   assert(_fac != NULL, &quot;invariant&quot;);
<span class="line-modified">6167   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);</span>
6168 
6169   // this transfers ownership of a lot of arrays from
6170   // the parser onto the InstanceKlass*
6171   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6172 
6173   // can only set dynamic nest-host after static nest information is set
6174   if (cl_inst_info.dynamic_nest_host() != NULL) {
6175     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
6176   }
6177 
6178   // note that is not safe to use the fields in the parser from this point on
6179   assert(NULL == _cp, &quot;invariant&quot;);
6180   assert(NULL == _fields, &quot;invariant&quot;);
6181   assert(NULL == _methods, &quot;invariant&quot;);
6182   assert(NULL == _inner_classes, &quot;invariant&quot;);
6183   assert(NULL == _nest_members, &quot;invariant&quot;);
6184   assert(NULL == _local_interfaces, &quot;invariant&quot;);
6185   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6186   assert(NULL == _record_components, &quot;invariant&quot;);
6187 
</pre>
<hr />
<pre>
6312   // Generate any default methods - default methods are public interface methods
6313   // that have a default implementation.  This is new with Java 8.
6314   if (_has_nonstatic_concrete_methods) {
6315     DefaultMethods::generate_default_methods(ik,
6316                                              _all_mirandas,
6317                                              CHECK);
6318   }
6319 
6320   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
6321   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
6322       !module_entry-&gt;has_default_read_edges()) {
6323     if (!module_entry-&gt;set_has_default_read_edges()) {
6324       // We won a potential race
6325       JvmtiExport::add_default_read_edges(module_handle, THREAD);
6326     }
6327   }
6328 
6329   int nfields = ik-&gt;java_fields_count();
6330   if (ik-&gt;is_value()) nfields++;
6331   for (int i = 0; i &lt; nfields; i++) {
<span class="line-modified">6332     if (ik-&gt;field_is_flattenable(i)) {</span>
6333       Symbol* klass_name = ik-&gt;field_signature(i)-&gt;fundamental_name(CHECK);
6334       // Inline classes for instance fields must have been pre-loaded
6335       // Inline classes for static fields might not have been loaded yet
6336       Klass* klass = SystemDictionary::find(klass_name,
6337           Handle(THREAD, ik-&gt;class_loader()),
6338           Handle(THREAD, ik-&gt;protection_domain()), CHECK);
6339       if (klass != NULL) {
6340         assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);
6341         ik-&gt;set_value_field_klass(i, klass);
6342       }
6343       klass_name-&gt;decrement_refcount();
6344     } else
6345       if (is_inline_type() &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_FIELD_INTERNAL) != 0)
6346         &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) != 0)) {
6347       ValueKlass::cast(ik)-&gt;set_default_value_offset(ik-&gt;field_offset(i));
6348     }
6349   }
6350 
6351   if (is_inline_type()) {
6352     ValueKlass* vk = ValueKlass::cast(ik);
</pre>
<hr />
<pre>
6537   _access_flags(),
6538   _pub_level(pub_level),
6539   _bad_constant_seen(0),
6540   _synthetic_flag(false),
6541   _sde_length(false),
6542   _sde_buffer(NULL),
6543   _sourcefile_index(0),
6544   _generic_signature_index(0),
6545   _major_version(0),
6546   _minor_version(0),
6547   _this_class_index(0),
6548   _super_class_index(0),
6549   _itfs_len(0),
6550   _java_fields_count(0),
6551   _need_verify(false),
6552   _relax_verify(false),
6553   _has_nonstatic_concrete_methods(false),
6554   _declares_nonstatic_concrete_methods(false),
6555   _has_final_method(false),
6556   _has_contended_fields(false),
<span class="line-modified">6557   _has_flattenable_fields(false),</span>
6558   _has_nonstatic_fields(false),
6559   _is_empty_inline_type(false),
6560   _is_naturally_atomic(false),
6561   _is_declared_atomic(false),
6562   _invalid_inline_super(false),
6563   _invalid_identity_super(false),
6564   _implements_identityObject(false),
6565   _has_injected_identityObject(false),
6566   _has_finalizer(false),
6567   _has_empty_finalizer(false),
6568   _has_vanilla_constructor(false),
6569   _max_bootstrap_specifier_index(-1) {
6570 
6571   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6572   _class_name-&gt;increment_refcount();
6573 
6574   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6575   assert(_loader_data != NULL, &quot;invariant&quot;);
6576   assert(stream != NULL, &quot;invariant&quot;);
6577   assert(_stream != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
7158                                                     &amp;_num_miranda_methods,
7159                                                     _all_mirandas,
7160                                                     _super_klass,
7161                                                     _methods,
7162                                                     _access_flags,
7163                                                     _major_version,
7164                                                     loader,
7165                                                     _class_name,
7166                                                     _local_interfaces,
7167                                                     CHECK);
7168 
7169   // Size of Java itable (in words)
7170   _itable_size = is_interface() ? 0 :
7171     klassItable::compute_itable_size(_transitive_interfaces);
7172 
7173   assert(_fac != NULL, &quot;invariant&quot;);
7174   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
7175 
7176 
7177   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
<span class="line-modified">7178     if (fs.is_flattenable() &amp;&amp; !fs.access_flags().is_static()) {</span>
7179       // Pre-load value class
<span class="line-modified">7180       Klass* klass = SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,</span>
7181           Handle(THREAD, _loader_data-&gt;class_loader()),
7182           _protection_domain, true, CHECK);
7183       assert(klass != NULL, &quot;Sanity check&quot;);
<span class="line-modified">7184       assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);</span>
<span class="line-removed">7185       _has_flattenable_fields = true;</span>
7186     }
7187   }
7188 
7189   _field_info = new FieldLayoutInfo();
7190   if (UseNewFieldLayout) {
7191     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
7192         _parsed_annotations-&gt;is_contended(), is_inline_type(),
7193         loader_data(), _protection_domain, _field_info);
7194     lb.build_layout(CHECK);
7195     if (is_inline_type()) {
7196       _alignment = lb.get_alignment();
7197       _first_field_offset = lb.get_first_field_offset();
7198       _exact_size_in_bytes = lb.get_exact_size_in_byte();
7199     }
7200   } else {
7201     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
7202   }

7203 
7204   // Compute reference type
7205   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
7206 }
7207 
7208 void ClassFileParser::set_klass(InstanceKlass* klass) {
7209 
7210 #ifdef ASSERT
7211   if (klass != NULL) {
7212     assert(NULL == _klass, &quot;leaking?&quot;);
7213   }
7214 #endif
7215 
7216   _klass = klass;
7217 }
7218 
7219 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
7220 
7221 #ifdef ASSERT
7222   if (klass != NULL) {
</pre>
</td>
<td>
<hr />
<pre>
1501                                             CHECK);
1502   parsed_annotations-&gt;set_field_annotations(a);
1503   a = assemble_annotations(runtime_visible_type_annotations,
1504                            runtime_visible_type_annotations_length,
1505                            runtime_invisible_type_annotations,
1506                            runtime_invisible_type_annotations_length,
1507                            CHECK);
1508   parsed_annotations-&gt;set_field_type_annotations(a);
1509   return;
1510 }
1511 
1512 
1513 // Field allocation types. Used for computing field offsets.
1514 
1515 enum FieldAllocationType {
1516   STATIC_OOP,           // Oops
1517   STATIC_BYTE,          // Boolean, Byte, char
1518   STATIC_SHORT,         // shorts
1519   STATIC_WORD,          // ints
1520   STATIC_DOUBLE,        // aligned long or double
<span class="line-modified">1521   STATIC_INLINE,        // inline field</span>
1522   NONSTATIC_OOP,
1523   NONSTATIC_BYTE,
1524   NONSTATIC_SHORT,
1525   NONSTATIC_WORD,
1526   NONSTATIC_DOUBLE,
<span class="line-modified">1527   NONSTATIC_INLINE,</span>
1528   MAX_FIELD_ALLOCATION_TYPE,
1529   BAD_ALLOCATION_TYPE = -1
1530 };
1531 
1532 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1533   BAD_ALLOCATION_TYPE, // 0
1534   BAD_ALLOCATION_TYPE, // 1
1535   BAD_ALLOCATION_TYPE, // 2
1536   BAD_ALLOCATION_TYPE, // 3
1537   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1538   NONSTATIC_SHORT,     // T_CHAR        =  5,
1539   NONSTATIC_WORD,      // T_FLOAT       =  6,
1540   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1541   NONSTATIC_BYTE,      // T_BYTE        =  8,
1542   NONSTATIC_SHORT,     // T_SHORT       =  9,
1543   NONSTATIC_WORD,      // T_INT         = 10,
1544   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1545   NONSTATIC_OOP,       // T_OBJECT      = 12,
1546   NONSTATIC_OOP,       // T_ARRAY       = 13,
1547   NONSTATIC_OOP,       // T_VALUETYPE   = 14,
</pre>
<hr />
<pre>
1557   BAD_ALLOCATION_TYPE, // 3
1558   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1559   STATIC_SHORT,        // T_CHAR        =  5,
1560   STATIC_WORD,         // T_FLOAT       =  6,
1561   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1562   STATIC_BYTE,         // T_BYTE        =  8,
1563   STATIC_SHORT,        // T_SHORT       =  9,
1564   STATIC_WORD,         // T_INT         = 10,
1565   STATIC_DOUBLE,       // T_LONG        = 11,
1566   STATIC_OOP,          // T_OBJECT      = 12,
1567   STATIC_OOP,          // T_ARRAY       = 13,
1568   STATIC_OOP,          // T_VALUETYPE   = 14,
1569   BAD_ALLOCATION_TYPE, // T_VOID        = 15,
1570   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,
1571   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,
1572   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,
1573   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,
1574   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20
1575 };
1576 
<span class="line-modified">1577 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type, bool is_inline) {</span>
1578   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1579   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1580   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);
<span class="line-modified">1581   if (is_inline) {</span>
<span class="line-modified">1582     result = is_static ? STATIC_INLINE : NONSTATIC_INLINE;</span>
1583   }
1584   return result;
1585 }
1586 
1587 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1588  public:
1589   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1590 
1591   FieldAllocationCount() {
1592     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1593       count[i] = 0;
1594     }
1595   }
1596 
<span class="line-modified">1597   FieldAllocationType update(bool is_static, BasicType type, bool is_inline) {</span>
<span class="line-modified">1598     FieldAllocationType atype = basic_type_to_atype(is_static, type, is_inline);</span>
1599     if (atype != BAD_ALLOCATION_TYPE) {
1600       // Make sure there is no overflow with injected fields.
1601       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1602       count[atype]++;
1603     }
1604     return atype;
1605   }
1606 };
1607 
1608 // Side-effects: populates the _fields, _fields_annotations,
1609 // _fields_type_annotations fields
1610 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1611                                    bool is_interface,
1612                                    bool is_inline_type,
1613                                    FieldAllocationCount* const fac,
1614                                    ConstantPool* cp,
1615                                    const int cp_size,
1616                                    u2* const java_fields_count_ptr,
1617                                    TRAPS) {
1618 
</pre>
<hr />
<pre>
1674     jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;
1675 
1676     const jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;
1677     verify_legal_field_modifiers(flags, is_interface, is_inline_type, CHECK);
1678     AccessFlags access_flags;
1679     access_flags.set_flags(flags);
1680 
1681     const u2 name_index = cfs-&gt;get_u2_fast();
1682     check_property(valid_symbol_at(name_index),
1683       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1684       name_index, CHECK);
1685     const Symbol* const name = cp-&gt;symbol_at(name_index);
1686     verify_legal_field_name(name, CHECK);
1687 
1688     const u2 signature_index = cfs-&gt;get_u2_fast();
1689     check_property(valid_symbol_at(signature_index),
1690       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1691       signature_index, CHECK);
1692     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1693     verify_legal_field_signature(name, sig, CHECK);
















1694     if (!access_flags.is_static()) instance_fields_count++;
1695 
1696     u2 constantvalue_index = 0;
1697     bool is_synthetic = false;
1698     u2 generic_signature_index = 0;
1699     const bool is_static = access_flags.is_static();
1700     FieldAnnotationCollector parsed_annotations(_loader_data);
1701 
1702     const u2 attributes_count = cfs-&gt;get_u2_fast();
1703     if (attributes_count &gt; 0) {
1704       parse_field_attributes(cfs,
1705                              attributes_count,
1706                              is_static,
1707                              signature_index,
1708                              &amp;constantvalue_index,
1709                              &amp;is_synthetic,
1710                              &amp;generic_signature_index,
1711                              &amp;parsed_annotations,
1712                              CHECK);
1713 
</pre>
<hr />
<pre>
1734 
1735       if (is_synthetic) {
1736         access_flags.set_is_synthetic();
1737       }
1738       if (generic_signature_index != 0) {
1739         access_flags.set_field_has_generic_signature();
1740         fa[generic_signature_slot] = generic_signature_index;
1741         generic_signature_slot ++;
1742         num_generic_signature ++;
1743       }
1744     }
1745 
1746     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1747     field-&gt;initialize(access_flags.as_short(),
1748                       name_index,
1749                       signature_index,
1750                       constantvalue_index);
1751     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1752 
1753     // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1754     const FieldAllocationType atype = fac-&gt;update(is_static, type, type == T_VALUETYPE);</span>
1755     field-&gt;set_allocation_type(atype);
1756 
1757     // After field is initialized with type, we can augment it with aux info
1758     if (parsed_annotations.has_any_annotations()) {
1759       parsed_annotations.apply_to(field);
1760       if (field-&gt;is_contended()) {
1761         _has_contended_fields = true;
1762       }
1763     }
1764   }
1765 
1766   int index = length;
1767   if (num_injected != 0) {
1768     for (int n = 0; n &lt; num_injected; n++) {
1769       // Check for duplicates
1770       if (injected[n].may_be_java) {
1771         const Symbol* const name      = injected[n].name();
1772         const Symbol* const signature = injected[n].signature();
1773         bool duplicate = false;
1774         for (int i = 0; i &lt; length; i++) {
</pre>
<hr />
<pre>
4293   //
4294   // We ignore static fields, because @Contended is not supported for them.
4295   // The layout code below will also ignore the static fields.
4296   int nonstatic_contended_count = 0;
4297   FieldAllocationCount fac_contended;
4298   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4299     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4300     if (fs.is_contended()) {
4301       fac_contended.count[atype]++;
4302       if (!fs.access_flags().is_static()) {
4303         nonstatic_contended_count++;
4304       }
4305     }
4306   }
4307 
4308 
4309   // Calculate the starting byte offsets
4310   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
4311   // Inline types in static fields are not embedded, they are handled with oops
4312   int next_static_double_offset = next_static_oop_offset +
<span class="line-modified">4313                                   ((fac-&gt;count[STATIC_OOP] + fac-&gt;count[STATIC_INLINE]) * heapOopSize);</span>
4314   if (fac-&gt;count[STATIC_DOUBLE]) {
4315     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4316   }
4317 
4318   int next_static_word_offset   = next_static_double_offset +
4319                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4320   int next_static_short_offset  = next_static_word_offset +
4321                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4322   int next_static_byte_offset   = next_static_short_offset +
4323                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4324 
4325   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4326                                 nonstatic_field_size * heapOopSize;
4327 
4328   // First field of inline types is aligned on a long boundary in order to ease
4329   // in-lining of inline types (with header removal) in packed arrays and
<span class="line-modified">4330   // flattened inline types</span>
4331   int initial_inline_type_padding = 0;
4332   if (is_inline_type()) {
4333     int old = nonstatic_fields_start;
4334     nonstatic_fields_start = align_up(nonstatic_fields_start, BytesPerLong);
4335     initial_inline_type_padding = nonstatic_fields_start - old;
4336   }
4337 
4338   int next_nonstatic_field_offset = nonstatic_fields_start;
4339 
4340   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4341 
4342   // Class is contended, pad before all the fields
4343   if (is_contended_class) {
4344     next_nonstatic_field_offset += ContendedPaddingWidth;
4345   }
4346 
4347   // Temporary inline types restrictions
4348   if (is_inline_type()) {
4349     if (is_contended_class) {
4350       throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support @Contended annotation yet&quot;);
</pre>
<hr />
<pre>
4353   }
4354 
4355   // Compute the non-contended fields count.
4356   // The packing code below relies on these counts to determine if some field
4357   // can be squeezed into the alignment gap. Contended fields are obviously
4358   // exempt from that.
4359   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4360   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4361   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4362   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4363   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4364 
4365   int static_inline_type_count = 0;
4366   int nonstatic_inline_type_count = 0;
4367   int* nonstatic_inline_type_indexes = NULL;
4368   Klass** nonstatic_inline_type_klasses = NULL;
4369   unsigned int inline_type_oop_map_count = 0;
4370   int not_flattened_inline_types = 0;
4371   int not_atomic_inline_types = 0;
4372 
<span class="line-modified">4373   int max_nonstatic_inline_type = fac-&gt;count[NONSTATIC_INLINE] + 1;</span>
4374 
4375   nonstatic_inline_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,
4376                                                                max_nonstatic_inline_type);
4377   for (int i = 0; i &lt; max_nonstatic_inline_type; i++) {
4378     nonstatic_inline_type_indexes[i] = -1;
4379   }
4380   nonstatic_inline_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,
4381                                                                max_nonstatic_inline_type);
4382 
4383   for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {
<span class="line-modified">4384     if (fs.allocation_type() == STATIC_INLINE) {</span>
4385       ResourceMark rm;
4386       if (!fs.signature()-&gt;is_Q_signature()) {
4387         THROW(vmSymbols::java_lang_ClassFormatError());
4388       }
4389       static_inline_type_count++;
<span class="line-modified">4390     } else if (fs.allocation_type() == NONSTATIC_INLINE) {</span>
<span class="line-modified">4391       // Pre-resolve the inline field and check for inline type circularity issues.</span>
4392       ResourceMark rm;
4393       if (!fs.signature()-&gt;is_Q_signature()) {
4394         THROW(vmSymbols::java_lang_ClassFormatError());
4395       }
4396       Klass* klass =
<span class="line-modified">4397         SystemDictionary::resolve_inline_field_or_fail(&amp;fs,</span>
4398                                                             Handle(THREAD, _loader_data-&gt;class_loader()),
4399                                                             _protection_domain, true, CHECK);
4400       assert(klass != NULL, &quot;Sanity check&quot;);
4401       if (!klass-&gt;access_flags().is_inline_type()) {
4402         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());
4403       }
4404       ValueKlass* vk = ValueKlass::cast(klass);
4405       // Conditions to apply flattening or not should be defined in a single place
4406       bool too_big_to_flatten = (InlineFieldMaxFlatSize &gt;= 0 &amp;&amp;
4407                                  (vk-&gt;size_helper() * HeapWordSize) &gt; InlineFieldMaxFlatSize);
4408       bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();
4409       bool too_volatile_to_flatten = fs.access_flags().is_volatile();
4410       if (vk-&gt;is_naturally_atomic()) {
4411         too_atomic_to_flatten = false;
4412         //too_volatile_to_flatten = false; //FIXME
4413         // volatile fields are currently never flattened, this could change in the future
4414       }
4415       if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {
4416         nonstatic_inline_type_indexes[nonstatic_inline_type_count] = fs.index();
4417         nonstatic_inline_type_klasses[nonstatic_inline_type_count] = klass;
</pre>
<hr />
<pre>
4421         if (vklass-&gt;contains_oops()) {
4422           inline_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();
4423         }
4424         fs.set_flattened(true);
4425         if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note
4426           not_atomic_inline_types++;
4427         }
4428       } else {
4429         not_flattened_inline_types++;
4430         fs.set_flattened(false);
4431       }
4432     }
4433   }
4434 
4435   // Adjusting non_static_oop_count to take into account not flattened inline types;
4436   nonstatic_oop_count += not_flattened_inline_types;
4437 
4438   // Total non-static fields count, including every contended field
4439   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4440                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
<span class="line-modified">4441                                         fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_INLINE];</span>
4442 
4443   const bool super_has_nonstatic_fields =
4444           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4445   const bool has_nonstatic_fields =
4446     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
4447   const bool has_nonstatic_value_fields = nonstatic_inline_type_count &gt; 0;
4448 
4449   if (is_inline_type() &amp;&amp; (!has_nonstatic_fields)) {
4450     // There are a number of fixes required throughout the type system and JIT
4451     throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support zero instance size yet&quot;);
4452     return;
4453   }
4454 
4455   // Prepare list of oops for oop map generation.
4456   //
4457   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4458   // regions. offset[i] is the start of the i-th region, which then has
4459   // count[i] oops following. Before we know how many regions are required,
4460   // we pessimistically allocate the maps to fit all the oops into the
4461   // distinct regions.
</pre>
<hr />
<pre>
4570   next_nonstatic_inline_type_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4571   int next_inline_type_index = 0;
4572 
4573   // Iterate over fields again and compute correct offsets.
4574   // The field allocation type was temporarily stored in the offset slot.
4575   // oop fields are located before non-oop fields (static and non-static).
4576   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4577 
4578     // skip already laid out fields
4579     if (fs.is_offset_set()) continue;
4580 
4581     // contended instance fields are handled below
4582     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4583 
4584     int real_offset = 0;
4585     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4586 
4587     // pack the rest of the fields
4588     switch (atype) {
4589       // Inline types in static fields are handled with oops
<span class="line-modified">4590       case STATIC_INLINE:   // Fallthrough</span>
4591       case STATIC_OOP:
4592         real_offset = next_static_oop_offset;
4593         next_static_oop_offset += heapOopSize;
4594         break;
4595       case STATIC_BYTE:
4596         real_offset = next_static_byte_offset;
4597         next_static_byte_offset += 1;
4598         break;
4599       case STATIC_SHORT:
4600         real_offset = next_static_short_offset;
4601         next_static_short_offset += BytesPerShort;
4602         break;
4603       case STATIC_WORD:
4604         real_offset = next_static_word_offset;
4605         next_static_word_offset += BytesPerInt;
4606         break;
4607       case STATIC_DOUBLE:
4608         real_offset = next_static_double_offset;
4609         next_static_double_offset += BytesPerLong;
4610         break;
<span class="line-modified">4611       case NONSTATIC_INLINE:</span>
4612         if (fs.is_flattened()) {
4613           Klass* klass = nonstatic_inline_type_klasses[next_inline_type_index];
4614           assert(klass != NULL, &quot;Klass should have been loaded and resolved earlier&quot;);
4615           assert(klass-&gt;access_flags().is_inline_type(),&quot;Must be an inline type&quot;);
4616           ValueKlass* vklass = ValueKlass::cast(klass);
4617           real_offset = next_nonstatic_inline_type_offset;
4618           next_nonstatic_inline_type_offset += (vklass-&gt;size_helper()) * wordSize - vklass-&gt;first_field_offset();
4619           // aligning next inline type on a 64 bits boundary
4620           next_nonstatic_inline_type_offset = align_up(next_nonstatic_inline_type_offset, BytesPerLong);
4621           next_inline_type_index += 1;
4622 
4623           if (vklass-&gt;contains_oops()) { // add flatten oop maps
4624             int diff = real_offset - vklass-&gt;first_field_offset();
4625             const OopMapBlock* map = vklass-&gt;start_of_nonstatic_oop_maps();
4626             const OopMapBlock* const last_map = map + vklass-&gt;nonstatic_oop_map_count();
4627             while (map &lt; last_map) {
4628               nonstatic_oop_maps-&gt;add(map-&gt;offset() + diff, map-&gt;count());
4629               map++;
4630             }
4631           }
</pre>
<hr />
<pre>
4735 
4736           case NONSTATIC_SHORT:
4737             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4738             real_offset = next_nonstatic_padded_offset;
4739             next_nonstatic_padded_offset += BytesPerShort;
4740             break;
4741 
4742           case NONSTATIC_WORD:
4743             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4744             real_offset = next_nonstatic_padded_offset;
4745             next_nonstatic_padded_offset += BytesPerInt;
4746             break;
4747 
4748           case NONSTATIC_DOUBLE:
4749             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4750             real_offset = next_nonstatic_padded_offset;
4751             next_nonstatic_padded_offset += BytesPerLong;
4752             break;
4753 
4754             // Inline types in static fields are handled with oops
<span class="line-modified">4755           case NONSTATIC_INLINE:</span>
4756             throwInlineTypeLimitation(THREAD_AND_LOCATION,
4757                                       &quot;@Contended annotation not supported for inline types yet&quot;, fs.name(), fs.signature());
4758             return;
4759 
4760           case NONSTATIC_OOP:
4761             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4762             real_offset = next_nonstatic_padded_offset;
4763             next_nonstatic_padded_offset += heapOopSize;
4764             nonstatic_oop_maps-&gt;add(real_offset, 1);
4765             break;
4766 
4767           default:
4768             ShouldNotReachHere();
4769         }
4770 
4771         if (fs.contended_group() == 0) {
4772           // Contended group defines the equivalence class over the fields:
4773           // the fields within the same contended group are not inter-padded.
4774           // The only exception is default group, which does not incur the
4775           // equivalence, and so requires intra-padding.
</pre>
<hr />
<pre>
4849           instance_size,
4850           nonstatic_fields_start,
4851           nonstatic_fields_end,
4852           static_fields_end);
4853     nonstatic_oop_maps-&gt;print_on(tty);
4854     tty-&gt;print(&quot;\n&quot;);
4855     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);
4856     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);
4857     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);
4858     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);
4859     tty-&gt;print_cr(&quot;---&quot;);
4860   }
4861 
4862 #endif
4863   // Pass back information needed for InstanceKlass creation
4864   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4865   info-&gt;_instance_size = instance_size;
4866   info-&gt;_static_field_size = static_field_size;
4867   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4868   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;
<span class="line-added">4869   info-&gt;_has_inline_fields = nonstatic_inline_type_count &gt; 0;</span>
4870 
4871   // An inline type is naturally atomic if it has just one field, and
4872   // that field is simple enough.
4873   info-&gt;_is_naturally_atomic = (is_inline_type() &amp;&amp;
4874                                 !super_has_nonstatic_fields &amp;&amp;
4875                                 (nonstatic_fields_count &lt;= 1) &amp;&amp;
4876                                 (not_atomic_inline_types == 0) &amp;&amp;
4877                                 (nonstatic_contended_count == 0));
4878   // This may be too restrictive, since if all the fields fit in 64
4879   // bits we could make the decision to align instances of this class
4880   // to 64-bit boundaries, and load and store them as single words.
4881   // And on machines which supported larger atomics we could similarly
4882   // allow larger values to be atomic, if properly aligned.
4883 }
4884 
4885 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4886   assert(ik != NULL, &quot;invariant&quot;);
4887 
4888   const Klass* const super = ik-&gt;super();
4889 
</pre>
<hr />
<pre>
6132 
6133   // Not yet: supers are done below to support the new subtype-checking fields
6134   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
6135   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
6136   if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_value()) {
6137     ik-&gt;set_is_naturally_atomic();
6138   }
6139   if (_is_empty_inline_type) {
6140     ik-&gt;set_is_empty_inline_type();
6141   }
6142 
6143   if (this-&gt;_invalid_inline_super) {
6144     ik-&gt;set_invalid_inline_super();
6145   }
6146 
6147   if (_has_injected_identityObject) {
6148     ik-&gt;set_has_injected_identityObject();
6149   }
6150 
6151   assert(_fac != NULL, &quot;invariant&quot;);
<span class="line-modified">6152   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_INLINE]);</span>
6153 
6154   // this transfers ownership of a lot of arrays from
6155   // the parser onto the InstanceKlass*
6156   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6157 
6158   // can only set dynamic nest-host after static nest information is set
6159   if (cl_inst_info.dynamic_nest_host() != NULL) {
6160     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
6161   }
6162 
6163   // note that is not safe to use the fields in the parser from this point on
6164   assert(NULL == _cp, &quot;invariant&quot;);
6165   assert(NULL == _fields, &quot;invariant&quot;);
6166   assert(NULL == _methods, &quot;invariant&quot;);
6167   assert(NULL == _inner_classes, &quot;invariant&quot;);
6168   assert(NULL == _nest_members, &quot;invariant&quot;);
6169   assert(NULL == _local_interfaces, &quot;invariant&quot;);
6170   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6171   assert(NULL == _record_components, &quot;invariant&quot;);
6172 
</pre>
<hr />
<pre>
6297   // Generate any default methods - default methods are public interface methods
6298   // that have a default implementation.  This is new with Java 8.
6299   if (_has_nonstatic_concrete_methods) {
6300     DefaultMethods::generate_default_methods(ik,
6301                                              _all_mirandas,
6302                                              CHECK);
6303   }
6304 
6305   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
6306   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
6307       !module_entry-&gt;has_default_read_edges()) {
6308     if (!module_entry-&gt;set_has_default_read_edges()) {
6309       // We won a potential race
6310       JvmtiExport::add_default_read_edges(module_handle, THREAD);
6311     }
6312   }
6313 
6314   int nfields = ik-&gt;java_fields_count();
6315   if (ik-&gt;is_value()) nfields++;
6316   for (int i = 0; i &lt; nfields; i++) {
<span class="line-modified">6317     if (ik-&gt;field_is_inline(i)) {</span>
6318       Symbol* klass_name = ik-&gt;field_signature(i)-&gt;fundamental_name(CHECK);
6319       // Inline classes for instance fields must have been pre-loaded
6320       // Inline classes for static fields might not have been loaded yet
6321       Klass* klass = SystemDictionary::find(klass_name,
6322           Handle(THREAD, ik-&gt;class_loader()),
6323           Handle(THREAD, ik-&gt;protection_domain()), CHECK);
6324       if (klass != NULL) {
6325         assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);
6326         ik-&gt;set_value_field_klass(i, klass);
6327       }
6328       klass_name-&gt;decrement_refcount();
6329     } else
6330       if (is_inline_type() &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_FIELD_INTERNAL) != 0)
6331         &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) != 0)) {
6332       ValueKlass::cast(ik)-&gt;set_default_value_offset(ik-&gt;field_offset(i));
6333     }
6334   }
6335 
6336   if (is_inline_type()) {
6337     ValueKlass* vk = ValueKlass::cast(ik);
</pre>
<hr />
<pre>
6522   _access_flags(),
6523   _pub_level(pub_level),
6524   _bad_constant_seen(0),
6525   _synthetic_flag(false),
6526   _sde_length(false),
6527   _sde_buffer(NULL),
6528   _sourcefile_index(0),
6529   _generic_signature_index(0),
6530   _major_version(0),
6531   _minor_version(0),
6532   _this_class_index(0),
6533   _super_class_index(0),
6534   _itfs_len(0),
6535   _java_fields_count(0),
6536   _need_verify(false),
6537   _relax_verify(false),
6538   _has_nonstatic_concrete_methods(false),
6539   _declares_nonstatic_concrete_methods(false),
6540   _has_final_method(false),
6541   _has_contended_fields(false),
<span class="line-modified">6542   _has_inline_fields(false),</span>
6543   _has_nonstatic_fields(false),
6544   _is_empty_inline_type(false),
6545   _is_naturally_atomic(false),
6546   _is_declared_atomic(false),
6547   _invalid_inline_super(false),
6548   _invalid_identity_super(false),
6549   _implements_identityObject(false),
6550   _has_injected_identityObject(false),
6551   _has_finalizer(false),
6552   _has_empty_finalizer(false),
6553   _has_vanilla_constructor(false),
6554   _max_bootstrap_specifier_index(-1) {
6555 
6556   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6557   _class_name-&gt;increment_refcount();
6558 
6559   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6560   assert(_loader_data != NULL, &quot;invariant&quot;);
6561   assert(stream != NULL, &quot;invariant&quot;);
6562   assert(_stream != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
7143                                                     &amp;_num_miranda_methods,
7144                                                     _all_mirandas,
7145                                                     _super_klass,
7146                                                     _methods,
7147                                                     _access_flags,
7148                                                     _major_version,
7149                                                     loader,
7150                                                     _class_name,
7151                                                     _local_interfaces,
7152                                                     CHECK);
7153 
7154   // Size of Java itable (in words)
7155   _itable_size = is_interface() ? 0 :
7156     klassItable::compute_itable_size(_transitive_interfaces);
7157 
7158   assert(_fac != NULL, &quot;invariant&quot;);
7159   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
7160 
7161 
7162   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
<span class="line-modified">7163     if (Signature::basic_type(fs.signature()) == T_VALUETYPE  &amp;&amp; !fs.access_flags().is_static()) {</span>
7164       // Pre-load value class
<span class="line-modified">7165       Klass* klass = SystemDictionary::resolve_inline_field_or_fail(&amp;fs,</span>
7166           Handle(THREAD, _loader_data-&gt;class_loader()),
7167           _protection_domain, true, CHECK);
7168       assert(klass != NULL, &quot;Sanity check&quot;);
<span class="line-modified">7169       assert(klass-&gt;access_flags().is_inline_type(), &quot;Value type expected&quot;);</span>

7170     }
7171   }
7172 
7173   _field_info = new FieldLayoutInfo();
7174   if (UseNewFieldLayout) {
7175     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
7176         _parsed_annotations-&gt;is_contended(), is_inline_type(),
7177         loader_data(), _protection_domain, _field_info);
7178     lb.build_layout(CHECK);
7179     if (is_inline_type()) {
7180       _alignment = lb.get_alignment();
7181       _first_field_offset = lb.get_first_field_offset();
7182       _exact_size_in_bytes = lb.get_exact_size_in_byte();
7183     }
7184   } else {
7185     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
7186   }
<span class="line-added">7187   _has_inline_fields = _field_info-&gt;_has_inline_fields;</span>
7188 
7189   // Compute reference type
7190   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
7191 }
7192 
7193 void ClassFileParser::set_klass(InstanceKlass* klass) {
7194 
7195 #ifdef ASSERT
7196   if (klass != NULL) {
7197     assert(NULL == _klass, &quot;leaking?&quot;);
7198   }
7199 #endif
7200 
7201   _klass = klass;
7202 }
7203 
7204 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
7205 
7206 #ifdef ASSERT
7207   if (klass != NULL) {
</pre>
</td>
</tr>
</table>
<center><a href="../ci/ciField.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
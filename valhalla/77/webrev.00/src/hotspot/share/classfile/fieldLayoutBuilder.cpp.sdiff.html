<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/fieldLayoutBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileParser.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldLayoutBuilder.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/fieldLayoutBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
520 FieldLayoutBuilder::FieldLayoutBuilder(const Symbol* classname, const InstanceKlass* super_klass, ConstantPool* constant_pool,
521                                        Array&lt;u2&gt;* fields, bool is_contended, bool is_inline_type, ClassLoaderData* class_loader_data,
522                                        Handle protection_domain, FieldLayoutInfo* info) :
523   _classname(classname),
524   _super_klass(super_klass),
525   _constant_pool(constant_pool),
526   _fields(fields),
527   _info(info),
528   _root_group(NULL),
529   _contended_groups(GrowableArray&lt;FieldGroup*&gt;(8)),
530   _static_fields(NULL),
531   _layout(NULL),
532   _static_layout(NULL),
533   _class_loader_data(class_loader_data),
534   _protection_domain(protection_domain),
535   _nonstatic_oopmap_count(0),
536   _alignment(-1),
537   _first_field_offset(-1),
538   _exact_size_in_bytes(-1),
539   _has_nonstatic_fields(false),

540   _is_contended(is_contended),
541   _is_inline_type(is_inline_type),
542   _has_flattening_information(is_inline_type),
543   _has_nonatomic_values(false),
544   _atomic_field_count(0)
545  {}
546 
547 FieldGroup* FieldLayoutBuilder::get_or_create_contended_group(int g) {
548   assert(g &gt; 0, &quot;must only be called for named contended groups&quot;);
549   FieldGroup* fg = NULL;
550   for (int i = 0; i &lt; _contended_groups.length(); i++) {
551     fg = _contended_groups.at(i);
552     if (fg-&gt;contended_group() == g) return fg;
553   }
554   fg = new FieldGroup(g);
555   _contended_groups.append(fg);
556   return fg;
557 }
558 
559 void FieldLayoutBuilder::prologue() {
</pre>
<hr />
<pre>
597     }
598     assert(group != NULL, &quot;invariant&quot;);
599     BasicType type = Signature::basic_type(fs.signature());
600     switch(type) {
601     case T_BYTE:
602     case T_CHAR:
603     case T_DOUBLE:
604     case T_FLOAT:
605     case T_INT:
606     case T_LONG:
607     case T_SHORT:
608     case T_BOOLEAN:
609       group-&gt;add_primitive_field(fs, type);
610       break;
611     case T_OBJECT:
612     case T_ARRAY:
613       if (group != _static_fields) _nonstatic_oopmap_count++;
614       group-&gt;add_oop_field(fs);
615       break;
616     case T_VALUETYPE:


617       if (group == _static_fields) {
618         // static fields are never flattened
619         group-&gt;add_oop_field(fs);
620       } else {
621         _has_flattening_information = true;
622         // Flattening decision to be taken here
<span class="line-modified">623         // This code assumes all verification have been performed before</span>
<span class="line-modified">624         // (field is a flattenable field, field&#39;s type has been loaded</span>
<span class="line-removed">625         // and it is an inline klass</span>
626         Thread* THREAD = Thread::current();
627         Klass* klass =
<span class="line-modified">628             SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,</span>
629                                                                 Handle(THREAD, _class_loader_data-&gt;class_loader()),
630                                                                 _protection_domain, true, THREAD);
631         assert(klass != NULL, &quot;Sanity check&quot;);
632         ValueKlass* vk = ValueKlass::cast(klass);
633         bool too_big_to_flatten = (InlineFieldMaxFlatSize &gt;= 0 &amp;&amp;
634                                    (vk-&gt;size_helper() * HeapWordSize) &gt; InlineFieldMaxFlatSize);
635         bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();
636         bool too_volatile_to_flatten = fs.access_flags().is_volatile();
637         if (vk-&gt;is_naturally_atomic()) {
638           too_atomic_to_flatten = false;
639           //too_volatile_to_flatten = false; //FIXME
640           // volatile fields are currently never flattened, this could change in the future
641         }
642         if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {
643           group-&gt;add_flattened_field(fs, vk);
644           _nonstatic_oopmap_count += vk-&gt;nonstatic_oop_map_count();
645           fs.set_flattened(true);
646           if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note
647             _has_nonatomic_values = true;
648             _atomic_field_count--;  // every other field is atomic but this one
</pre>
<hr />
<pre>
698     case T_DOUBLE:
699     case T_FLOAT:
700     case T_INT:
701     case T_LONG:
702     case T_SHORT:
703     case T_BOOLEAN:
704       if (group != _static_fields) {
705         field_alignment = type2aelembytes(type); // alignment == size for primitive types
706       }
707       group-&gt;add_primitive_field(fs, type);
708       break;
709     case T_OBJECT:
710     case T_ARRAY:
711       if (group != _static_fields) {
712         _nonstatic_oopmap_count++;
713         field_alignment = type2aelembytes(type); // alignment == size for oops
714       }
715       group-&gt;add_oop_field(fs);
716       break;
717     case T_VALUETYPE: {


718       if (group == _static_fields) {
719         // static fields are never flattened
720         group-&gt;add_oop_field(fs);
721       } else {
722         // Flattening decision to be taken here
<span class="line-modified">723         // This code assumes all verifications have been performed before</span>
<span class="line-modified">724         // (field is a flattenable field, field&#39;s type has been loaded</span>
<span class="line-removed">725         // and it is an inline klass</span>
726         Thread* THREAD = Thread::current();
727         Klass* klass =
<span class="line-modified">728             SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,</span>
729                 Handle(THREAD, _class_loader_data-&gt;class_loader()),
730                 _protection_domain, true, CHECK);
731         assert(klass != NULL, &quot;Sanity check&quot;);
732         ValueKlass* vk = ValueKlass::cast(klass);
733         bool too_big_to_flatten = (InlineFieldMaxFlatSize &gt;= 0 &amp;&amp;
734                                    (vk-&gt;size_helper() * HeapWordSize) &gt; InlineFieldMaxFlatSize);
735         bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();
736         bool too_volatile_to_flatten = fs.access_flags().is_volatile();
737         if (vk-&gt;is_naturally_atomic()) {
738           too_atomic_to_flatten = false;
739           //too_volatile_to_flatten = false; //FIXME
740           // volatile fields are currently never flattened, this could change in the future
741         }
742         if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {
743           group-&gt;add_flattened_field(fs, vk);
744           _nonstatic_oopmap_count += vk-&gt;nonstatic_oop_map_count();
745           field_alignment = vk-&gt;get_alignment();
746           fs.set_flattened(true);
747           if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note
748             _has_nonatomic_values = true;
</pre>
<hr />
<pre>
928         nonstatic_oop_maps-&gt;add(cg-&gt;oop_fields()-&gt;at(0)-&gt;offset(), cg-&gt;oop_count());
929       }
930     }
931   }
932 
933   nonstatic_oop_maps-&gt;compact();
934 
935   int instance_end = align_up(_layout-&gt;last_block()-&gt;offset(), wordSize);
936   int static_fields_end = align_up(_static_layout-&gt;last_block()-&gt;offset(), wordSize);
937   int static_fields_size = (static_fields_end -
938       InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
939   int nonstatic_field_end = align_up(_layout-&gt;last_block()-&gt;offset(), heapOopSize);
940 
941   // Pass back information needed for InstanceKlass creation
942 
943   _info-&gt;oop_map_blocks = nonstatic_oop_maps;
944   _info-&gt;_instance_size = align_object_size(instance_end / wordSize);
945   _info-&gt;_static_field_size = static_fields_size;
946   _info-&gt;_nonstatic_field_size = (nonstatic_field_end - instanceOopDesc::base_offset_in_bytes()) / heapOopSize;
947   _info-&gt;_has_nonstatic_fields = _has_nonstatic_fields;

948 
949   // An inline type is naturally atomic if it has just one field, and
950   // that field is simple enough.
951   _info-&gt;_is_naturally_atomic = (_is_inline_type &amp;&amp;
952                                  (_atomic_field_count &lt;= 1) &amp;&amp;
953                                  !_has_nonatomic_values &amp;&amp;
954                                  _contended_groups.is_empty());
955   // This may be too restrictive, since if all the fields fit in 64
956   // bits we could make the decision to align instances of this class
957   // to 64-bit boundaries, and load and store them as single words.
958   // And on machines which supported larger atomics we could similarly
959   // allow larger values to be atomic, if properly aligned.
960 
961 
962   if (PrintFieldLayout) {
963     ResourceMark rm;
964     tty-&gt;print_cr(&quot;Layout of class %s&quot;, _classname-&gt;as_C_string());
965     tty-&gt;print_cr(&quot;Instance fields:&quot;);
966     _layout-&gt;print(tty, false, _super_klass);
967     tty-&gt;print_cr(&quot;Static fields:&quot;);
</pre>
</td>
<td>
<hr />
<pre>
520 FieldLayoutBuilder::FieldLayoutBuilder(const Symbol* classname, const InstanceKlass* super_klass, ConstantPool* constant_pool,
521                                        Array&lt;u2&gt;* fields, bool is_contended, bool is_inline_type, ClassLoaderData* class_loader_data,
522                                        Handle protection_domain, FieldLayoutInfo* info) :
523   _classname(classname),
524   _super_klass(super_klass),
525   _constant_pool(constant_pool),
526   _fields(fields),
527   _info(info),
528   _root_group(NULL),
529   _contended_groups(GrowableArray&lt;FieldGroup*&gt;(8)),
530   _static_fields(NULL),
531   _layout(NULL),
532   _static_layout(NULL),
533   _class_loader_data(class_loader_data),
534   _protection_domain(protection_domain),
535   _nonstatic_oopmap_count(0),
536   _alignment(-1),
537   _first_field_offset(-1),
538   _exact_size_in_bytes(-1),
539   _has_nonstatic_fields(false),
<span class="line-added">540   _has_inline_fields(false),</span>
541   _is_contended(is_contended),
542   _is_inline_type(is_inline_type),
543   _has_flattening_information(is_inline_type),
544   _has_nonatomic_values(false),
545   _atomic_field_count(0)
546  {}
547 
548 FieldGroup* FieldLayoutBuilder::get_or_create_contended_group(int g) {
549   assert(g &gt; 0, &quot;must only be called for named contended groups&quot;);
550   FieldGroup* fg = NULL;
551   for (int i = 0; i &lt; _contended_groups.length(); i++) {
552     fg = _contended_groups.at(i);
553     if (fg-&gt;contended_group() == g) return fg;
554   }
555   fg = new FieldGroup(g);
556   _contended_groups.append(fg);
557   return fg;
558 }
559 
560 void FieldLayoutBuilder::prologue() {
</pre>
<hr />
<pre>
598     }
599     assert(group != NULL, &quot;invariant&quot;);
600     BasicType type = Signature::basic_type(fs.signature());
601     switch(type) {
602     case T_BYTE:
603     case T_CHAR:
604     case T_DOUBLE:
605     case T_FLOAT:
606     case T_INT:
607     case T_LONG:
608     case T_SHORT:
609     case T_BOOLEAN:
610       group-&gt;add_primitive_field(fs, type);
611       break;
612     case T_OBJECT:
613     case T_ARRAY:
614       if (group != _static_fields) _nonstatic_oopmap_count++;
615       group-&gt;add_oop_field(fs);
616       break;
617     case T_VALUETYPE:
<span class="line-added">618 //      fs.set_inline(true);</span>
<span class="line-added">619       _has_inline_fields = true;</span>
620       if (group == _static_fields) {
621         // static fields are never flattened
622         group-&gt;add_oop_field(fs);
623       } else {
624         _has_flattening_information = true;
625         // Flattening decision to be taken here
<span class="line-modified">626         // This code assumes all verification already have been performed</span>
<span class="line-modified">627         // (field&#39;s type has been loaded and it is an inline klass)</span>

628         Thread* THREAD = Thread::current();
629         Klass* klass =
<span class="line-modified">630             SystemDictionary::resolve_inline_field_or_fail(&amp;fs,</span>
631                                                                 Handle(THREAD, _class_loader_data-&gt;class_loader()),
632                                                                 _protection_domain, true, THREAD);
633         assert(klass != NULL, &quot;Sanity check&quot;);
634         ValueKlass* vk = ValueKlass::cast(klass);
635         bool too_big_to_flatten = (InlineFieldMaxFlatSize &gt;= 0 &amp;&amp;
636                                    (vk-&gt;size_helper() * HeapWordSize) &gt; InlineFieldMaxFlatSize);
637         bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();
638         bool too_volatile_to_flatten = fs.access_flags().is_volatile();
639         if (vk-&gt;is_naturally_atomic()) {
640           too_atomic_to_flatten = false;
641           //too_volatile_to_flatten = false; //FIXME
642           // volatile fields are currently never flattened, this could change in the future
643         }
644         if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {
645           group-&gt;add_flattened_field(fs, vk);
646           _nonstatic_oopmap_count += vk-&gt;nonstatic_oop_map_count();
647           fs.set_flattened(true);
648           if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note
649             _has_nonatomic_values = true;
650             _atomic_field_count--;  // every other field is atomic but this one
</pre>
<hr />
<pre>
700     case T_DOUBLE:
701     case T_FLOAT:
702     case T_INT:
703     case T_LONG:
704     case T_SHORT:
705     case T_BOOLEAN:
706       if (group != _static_fields) {
707         field_alignment = type2aelembytes(type); // alignment == size for primitive types
708       }
709       group-&gt;add_primitive_field(fs, type);
710       break;
711     case T_OBJECT:
712     case T_ARRAY:
713       if (group != _static_fields) {
714         _nonstatic_oopmap_count++;
715         field_alignment = type2aelembytes(type); // alignment == size for oops
716       }
717       group-&gt;add_oop_field(fs);
718       break;
719     case T_VALUETYPE: {
<span class="line-added">720 //      fs.set_inline(true);</span>
<span class="line-added">721       _has_inline_fields = true;</span>
722       if (group == _static_fields) {
723         // static fields are never flattened
724         group-&gt;add_oop_field(fs);
725       } else {
726         // Flattening decision to be taken here
<span class="line-modified">727         // This code assumes all verifications have already been performed</span>
<span class="line-modified">728         // (field&#39;s type has been loaded and it is an inline klass)</span>

729         Thread* THREAD = Thread::current();
730         Klass* klass =
<span class="line-modified">731             SystemDictionary::resolve_inline_field_or_fail(&amp;fs,</span>
732                 Handle(THREAD, _class_loader_data-&gt;class_loader()),
733                 _protection_domain, true, CHECK);
734         assert(klass != NULL, &quot;Sanity check&quot;);
735         ValueKlass* vk = ValueKlass::cast(klass);
736         bool too_big_to_flatten = (InlineFieldMaxFlatSize &gt;= 0 &amp;&amp;
737                                    (vk-&gt;size_helper() * HeapWordSize) &gt; InlineFieldMaxFlatSize);
738         bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();
739         bool too_volatile_to_flatten = fs.access_flags().is_volatile();
740         if (vk-&gt;is_naturally_atomic()) {
741           too_atomic_to_flatten = false;
742           //too_volatile_to_flatten = false; //FIXME
743           // volatile fields are currently never flattened, this could change in the future
744         }
745         if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {
746           group-&gt;add_flattened_field(fs, vk);
747           _nonstatic_oopmap_count += vk-&gt;nonstatic_oop_map_count();
748           field_alignment = vk-&gt;get_alignment();
749           fs.set_flattened(true);
750           if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note
751             _has_nonatomic_values = true;
</pre>
<hr />
<pre>
931         nonstatic_oop_maps-&gt;add(cg-&gt;oop_fields()-&gt;at(0)-&gt;offset(), cg-&gt;oop_count());
932       }
933     }
934   }
935 
936   nonstatic_oop_maps-&gt;compact();
937 
938   int instance_end = align_up(_layout-&gt;last_block()-&gt;offset(), wordSize);
939   int static_fields_end = align_up(_static_layout-&gt;last_block()-&gt;offset(), wordSize);
940   int static_fields_size = (static_fields_end -
941       InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
942   int nonstatic_field_end = align_up(_layout-&gt;last_block()-&gt;offset(), heapOopSize);
943 
944   // Pass back information needed for InstanceKlass creation
945 
946   _info-&gt;oop_map_blocks = nonstatic_oop_maps;
947   _info-&gt;_instance_size = align_object_size(instance_end / wordSize);
948   _info-&gt;_static_field_size = static_fields_size;
949   _info-&gt;_nonstatic_field_size = (nonstatic_field_end - instanceOopDesc::base_offset_in_bytes()) / heapOopSize;
950   _info-&gt;_has_nonstatic_fields = _has_nonstatic_fields;
<span class="line-added">951   _info-&gt;_has_inline_fields = _has_inline_fields;</span>
952 
953   // An inline type is naturally atomic if it has just one field, and
954   // that field is simple enough.
955   _info-&gt;_is_naturally_atomic = (_is_inline_type &amp;&amp;
956                                  (_atomic_field_count &lt;= 1) &amp;&amp;
957                                  !_has_nonatomic_values &amp;&amp;
958                                  _contended_groups.is_empty());
959   // This may be too restrictive, since if all the fields fit in 64
960   // bits we could make the decision to align instances of this class
961   // to 64-bit boundaries, and load and store them as single words.
962   // And on machines which supported larger atomics we could similarly
963   // allow larger values to be atomic, if properly aligned.
964 
965 
966   if (PrintFieldLayout) {
967     ResourceMark rm;
968     tty-&gt;print_cr(&quot;Layout of class %s&quot;, _classname-&gt;as_C_string());
969     tty-&gt;print_cr(&quot;Instance fields:&quot;);
970     _layout-&gt;print(tty, false, _super_klass);
971     tty-&gt;print_cr(&quot;Static fields:&quot;);
</pre>
</td>
</tr>
</table>
<center><a href="classFileParser.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldLayoutBuilder.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
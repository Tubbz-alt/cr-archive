<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/javaClasses.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_CLASSFILE_JAVACLASSES_HPP
  26 #define SHARE_CLASSFILE_JAVACLASSES_HPP
  27 
  28 #include &quot;classfile/systemDictionary.hpp&quot;
  29 #include &quot;jvmtifiles/jvmti.h&quot;
  30 #include &quot;oops/oop.hpp&quot;
  31 #include &quot;runtime/os.hpp&quot;
  32 
  33 class RecordComponent;
  34 
  35 // Interface for manipulating the basic Java classes.
  36 
  37 #define BASIC_JAVA_CLASSES_DO_PART1(f) \
  38   f(java_lang_Class) \
  39   f(java_lang_String) \
  40   f(java_lang_ref_Reference) \
  41   //end
  42 
  43 #define BASIC_JAVA_CLASSES_DO_PART2(f) \
  44   f(java_lang_System) \
  45   f(java_lang_ClassLoader) \
  46   f(java_lang_Throwable) \
  47   f(java_lang_Thread) \
  48   f(java_lang_ThreadGroup) \
  49   f(java_lang_AssertionStatusDirectives) \
  50   f(java_lang_ref_SoftReference) \
  51   f(java_lang_invoke_MethodHandle) \
  52   f(java_lang_invoke_DirectMethodHandle) \
  53   f(java_lang_invoke_MemberName) \
  54   f(java_lang_invoke_ResolvedMethodName) \
  55   f(java_lang_invoke_LambdaForm) \
  56   f(java_lang_invoke_MethodType) \
  57   f(java_lang_invoke_CallSite) \
  58   f(java_lang_invoke_ConstantCallSite) \
  59   f(java_lang_invoke_MethodHandleNatives_CallSiteContext) \
  60   f(java_security_AccessControlContext) \
  61   f(java_lang_reflect_AccessibleObject) \
  62   f(java_lang_reflect_Method) \
  63   f(java_lang_reflect_Constructor) \
  64   f(java_lang_reflect_Field) \
  65   f(java_lang_reflect_RecordComponent) \
  66   f(java_nio_Buffer) \
  67   f(reflect_ConstantPool) \
  68   f(reflect_UnsafeStaticFieldAccessorImpl) \
  69   f(java_lang_reflect_Parameter) \
  70   f(java_lang_Module) \
  71   f(java_lang_StackTraceElement) \
  72   f(java_lang_StackFrameInfo) \
  73   f(java_lang_LiveStackFrameInfo) \
  74   f(java_util_concurrent_locks_AbstractOwnableSynchronizer) \
  75   f(jdk_internal_misc_UnsafeConstants) \
  76   f(jdk_internal_vm_jni_SubElementSelector) \
  77   f(java_lang_boxing_object) \
  78   //end
  79 
  80 #define BASIC_JAVA_CLASSES_DO(f) \
  81         BASIC_JAVA_CLASSES_DO_PART1(f) \
  82         BASIC_JAVA_CLASSES_DO_PART2(f)
  83 
  84 // Interface to java.lang.Object objects
  85 
  86 class java_lang_Object : AllStatic {
  87  public:
  88   static void register_natives(TRAPS);
  89 };
  90 
  91 // Interface to java.lang.String objects
  92 
  93 class java_lang_String : AllStatic {
  94  private:
  95   static int value_offset;
  96   static int hash_offset;
  97   static int hashIsZero_offset;
  98   static int coder_offset;
  99 
 100   static bool initialized;
 101 
 102   static Handle basic_create(int length, bool byte_arr, TRAPS);
 103 
 104   static inline void set_coder(oop string, jbyte coder);
 105 
 106  public:
 107 
 108   // Coders
 109   enum Coder {
 110     CODER_LATIN1 =  0,
 111     CODER_UTF16  =  1
 112   };
 113 
 114   static void compute_offsets();
 115   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 116 
 117   // Instance creation
 118   static Handle create_from_unicode(const jchar* unicode, int len, TRAPS);
 119   static oop    create_oop_from_unicode(const jchar* unicode, int len, TRAPS);
 120   static Handle create_from_str(const char* utf8_str, TRAPS);
 121   static oop    create_oop_from_str(const char* utf8_str, TRAPS);
 122   static Handle create_from_symbol(Symbol* symbol, TRAPS);
 123   static Handle create_from_platform_dependent_str(const char* str, TRAPS);
 124   static Handle char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS);
 125 
 126   static void set_compact_strings(bool value);
 127 
 128   static int value_offset_in_bytes()  {
 129     assert(initialized &amp;&amp; (value_offset &gt; 0), &quot;Must be initialized&quot;);
 130     return value_offset;
 131   }
 132   static int hash_offset_in_bytes()   {
 133     assert(initialized &amp;&amp; (hash_offset &gt; 0), &quot;Must be initialized&quot;);
 134     return hash_offset;
 135   }
 136   static int hashIsZero_offset_in_bytes()   {
 137     assert(initialized &amp;&amp; (hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);
 138     return hashIsZero_offset;
 139   }
 140   static int coder_offset_in_bytes()   {
 141     assert(initialized &amp;&amp; (coder_offset &gt; 0), &quot;Must be initialized&quot;);
 142     return coder_offset;
 143   }
 144 
 145   static inline void set_value_raw(oop string, typeArrayOop buffer);
 146   static inline void set_value(oop string, typeArrayOop buffer);
 147 
 148   // Accessors
 149   static inline typeArrayOop value(oop java_string);
 150   static inline typeArrayOop value_no_keepalive(oop java_string);
 151   static inline bool hash_is_set(oop string);
 152   static inline bool is_latin1(oop java_string);
 153   static inline int length(oop java_string);
 154   static inline int length(oop java_string, typeArrayOop string_value);
 155   static int utf8_length(oop java_string);
 156   static int utf8_length(oop java_string, typeArrayOop string_value);
 157 
 158   // String converters
 159   static char*  as_utf8_string(oop java_string);
 160   static char*  as_utf8_string(oop java_string, int&amp; length);
 161   static char*  as_utf8_string_full(oop java_string, char* buf, int buflen, int&amp; length);
 162   static char*  as_utf8_string(oop java_string, char* buf, int buflen);
 163   static char*  as_utf8_string(oop java_string, int start, int len);
 164   static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen);
 165   static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen);
 166   static char*  as_platform_dependent_str(Handle java_string, TRAPS);
 167   static jchar* as_unicode_string(oop java_string, int&amp; length, TRAPS);
 168   // produce an ascii string with all other values quoted using \u####
 169   static char*  as_quoted_ascii(oop java_string);
 170 
 171   // Compute the hash value for a java.lang.String object which would
 172   // contain the characters passed in.
 173   //
 174   // As the hash value used by the String object itself, in
 175   // String.hashCode().  This value is normally calculated in Java code
 176   // in the String.hashCode method(), but is precomputed for String
 177   // objects in the shared archive file.
 178   // hash P(31) from Kernighan &amp; Ritchie
 179   //
 180   // For this reason, THIS ALGORITHM MUST MATCH String.hashCode().
 181   static unsigned int hash_code(const jchar* s, int len) {
 182     unsigned int h = 0;
 183     while (len-- &gt; 0) {
 184       h = 31*h + (unsigned int) *s;
 185       s++;
 186     }
 187     return h;
 188   }
 189 
 190   static unsigned int hash_code(const jbyte* s, int len) {
 191     unsigned int h = 0;
 192     while (len-- &gt; 0) {
 193       h = 31*h + (((unsigned int) *s) &amp; 0xFF);
 194       s++;
 195     }
 196     return h;
 197   }
 198 
 199   static unsigned int hash_code(oop java_string);
 200 
 201   static bool equals(oop java_string, const jchar* chars, int len);
 202   static bool equals(oop str1, oop str2);
 203   static inline bool value_equals(typeArrayOop str_value1, typeArrayOop str_value2);
 204 
 205   // Conversion between &#39;.&#39; and &#39;/&#39; formats
 206   static Handle externalize_classname(Handle java_string, TRAPS) {
 207     return char_converter(java_string, JVM_SIGNATURE_SLASH, JVM_SIGNATURE_DOT, THREAD);
 208   }
 209 
 210   // Conversion
 211   static Symbol* as_symbol(oop java_string);
 212   static Symbol* as_symbol_or_null(oop java_string);
 213 
 214   // Testers
 215   static bool is_instance(oop obj);
 216   static inline bool is_instance_inlined(oop obj);
 217 
 218   // Debugging
 219   static void print(oop java_string, outputStream* st);
 220   friend class JavaClasses;
 221   friend class StringTable;
 222 };
 223 
 224 
 225 // Interface to java.lang.Class objects
 226 
 227 #define CLASS_INJECTED_FIELDS(macro)                                       \
 228   macro(java_lang_Class, klass,                  intptr_signature,  false) \
 229   macro(java_lang_Class, array_klass,            intptr_signature,  false) \
 230   macro(java_lang_Class, oop_size,               int_signature,     false) \
 231   macro(java_lang_Class, static_oop_field_count, int_signature,     false) \
 232   macro(java_lang_Class, protection_domain,      object_signature,  false) \
 233   macro(java_lang_Class, signers,                object_signature,  false) \
 234   macro(java_lang_Class, source_file,            object_signature,  false) \
 235 
 236 class java_lang_Class : AllStatic {
 237   friend class VMStructs;
 238   friend class JVMCIVMStructs;
 239 
 240  private:
 241   // The fake offsets are added by the class loader when java.lang.Class is loaded
 242 
 243   static int _klass_offset;
 244   static int _array_klass_offset;
 245 
 246   static int _oop_size_offset;
 247   static int _static_oop_field_count_offset;
 248 
 249   static int _protection_domain_offset;
 250   static int _init_lock_offset;
 251   static int _signers_offset;
 252   static int _class_loader_offset;
 253   static int _module_offset;
 254   static int _component_mirror_offset;
 255   static int _name_offset;
 256   static int _source_file_offset;
 257   static int _val_type_mirror_offset;
 258   static int _ref_type_mirror_offset;
 259   static int _classData_offset;
 260 
 261   static bool offsets_computed;
 262   static int classRedefinedCount_offset;
 263 
 264   static GrowableArray&lt;Klass*&gt;* _fixup_mirror_list;
 265   static GrowableArray&lt;Klass*&gt;* _fixup_module_field_list;
 266 
 267   static void set_init_lock(oop java_class, oop init_lock);
 268   static void set_protection_domain(oop java_class, oop protection_domain);
 269   static void set_class_loader(oop java_class, oop class_loader);
 270   static void set_component_mirror(oop java_class, oop comp_mirror);
 271   static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain,
 272                                        Handle classData, TRAPS);
 273   static void set_mirror_module_field(Klass* K, Handle mirror, Handle module, TRAPS);
 274  public:
 275   static void allocate_fixup_lists();
 276   static void compute_offsets();
 277 
 278   // Instance creation
 279   static void create_mirror(Klass* k, Handle class_loader, Handle module,
 280                             Handle protection_domain, Handle classData, TRAPS);
 281   static void fixup_mirror(Klass* k, TRAPS);
 282   static oop  create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS);
 283   static void update_archived_primitive_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;
 284   static void update_archived_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;
 285 
 286   // Archiving
 287   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 288   static void archive_basic_type_mirrors(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;
 289   static oop  archive_mirror(Klass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 290   static oop  process_archived_mirror(Klass* k, oop mirror, oop archived_mirror, Thread *THREAD)
 291                                       NOT_CDS_JAVA_HEAP_RETURN_(NULL);
 292   static bool restore_archived_mirror(Klass *k, Handle class_loader, Handle module,
 293                                       Handle protection_domain,
 294                                       TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(false);
 295 
 296   static void fixup_module_field(Klass* k, Handle module);
 297 
 298   // Conversion
 299   static Klass* as_Klass(oop java_class);
 300   static Klass* as_Klass_raw(oop java_class);
 301   static void set_klass(oop java_class, Klass* klass);
 302   static BasicType as_BasicType(oop java_class, Klass** reference_klass = NULL);
 303   static Symbol* as_signature(oop java_class, bool intern_if_not_found);
 304   static void print_signature(oop java_class, outputStream *st);
 305   static const char* as_external_name(oop java_class);
 306   // Testing
 307   static bool is_instance(oop obj);
 308 
 309   static bool is_primitive(oop java_class);
 310   static BasicType primitive_type(oop java_class);
 311   static oop primitive_mirror(BasicType t);
 312   // JVM_NewArray support
 313   static Klass* array_klass_acquire(oop java_class);
 314   static void release_set_array_klass(oop java_class, Klass* klass);
 315   // compiler support for class operations
 316   static int klass_offset_in_bytes()                { return _klass_offset; }
 317   static int array_klass_offset_in_bytes()          { return _array_klass_offset; }
 318   static int component_mirror_offset_in_bytes()     { return _component_mirror_offset; }
 319   // Support for classRedefinedCount field
 320   static int classRedefinedCount(oop the_class_mirror);
 321   static void set_classRedefinedCount(oop the_class_mirror, int value);
 322 
 323   // Support for embedded per-class oops
 324   static oop  protection_domain(oop java_class);
 325   static oop  init_lock(oop java_class);
 326   static oop  component_mirror(oop java_class);
 327   static objArrayOop  signers(oop java_class);
 328   static void set_signers(oop java_class, objArrayOop signers);
 329   static oop  class_data(oop java_class);
 330   static void set_class_data(oop java_class, oop classData);
 331 
 332   static oop class_loader(oop java_class);
 333   static void set_module(oop java_class, oop module);
 334   static oop module(oop java_class);
 335 
 336   static void set_ref_type_mirror(oop java_class, oop mirror);
 337   static oop ref_type_mirror(oop java_class);
 338 
 339   static void set_val_type_mirror(oop java_class, oop mirror);
 340   static oop val_type_mirror(oop java_class);
 341 
 342   static oop name(Handle java_class, TRAPS);
 343 
 344   static oop source_file(oop java_class);
 345   static void set_source_file(oop java_class, oop source_file);
 346 
 347   static int oop_size(oop java_class);
 348   static int oop_size_raw(oop java_class);
 349   static void set_oop_size(HeapWord* java_class, int size);
 350   static int static_oop_field_count(oop java_class);
 351   static int static_oop_field_count_raw(oop java_class);
 352   static void set_static_oop_field_count(oop java_class, int size);
 353 
 354   static GrowableArray&lt;Klass*&gt;* fixup_mirror_list() {
 355     return _fixup_mirror_list;
 356   }
 357   static void set_fixup_mirror_list(GrowableArray&lt;Klass*&gt;* v) {
 358     _fixup_mirror_list = v;
 359   }
 360 
 361   static GrowableArray&lt;Klass*&gt;* fixup_module_field_list() {
 362     return _fixup_module_field_list;
 363   }
 364   static void set_fixup_module_field_list(GrowableArray&lt;Klass*&gt;* v) {
 365     _fixup_module_field_list = v;
 366   }
 367 
 368   // Debugging
 369   friend class JavaClasses;
 370   friend class InstanceKlass;   // verification code accesses offsets
 371   friend class ClassFileParser; // access to number_of_fake_fields
 372 };
 373 
 374 // Interface to java.lang.Thread objects
 375 
 376 class java_lang_Thread : AllStatic {
 377  private:
 378   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
 379   // so we compute the offsets at startup rather than hard-wiring them.
 380   static int _name_offset;
 381   static int _group_offset;
 382   static int _contextClassLoader_offset;
 383   static int _inheritedAccessControlContext_offset;
 384   static int _priority_offset;
 385   static int _eetop_offset;
 386   static int _interrupted_offset;
 387   static int _daemon_offset;
 388   static int _stillborn_offset;
 389   static int _stackSize_offset;
 390   static int _tid_offset;
 391   static int _thread_status_offset;
 392   static int _park_blocker_offset;
 393 
 394   static void compute_offsets();
 395 
 396  public:
 397   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 398 
 399   // Instance creation
 400   static oop create();
 401   // Returns the JavaThread associated with the thread obj
 402   static JavaThread* thread(oop java_thread);
 403   // Set JavaThread for instance
 404   static void set_thread(oop java_thread, JavaThread* thread);
 405   // Interrupted status
 406   static bool interrupted(oop java_thread);
 407   static void set_interrupted(oop java_thread, bool val);
 408   // Name
 409   static oop name(oop java_thread);
 410   static void set_name(oop java_thread, oop name);
 411   // Priority
 412   static ThreadPriority priority(oop java_thread);
 413   static void set_priority(oop java_thread, ThreadPriority priority);
 414   // Thread group
 415   static oop  threadGroup(oop java_thread);
 416   // Stillborn
 417   static bool is_stillborn(oop java_thread);
 418   static void set_stillborn(oop java_thread);
 419   // Alive (NOTE: this is not really a field, but provides the correct
 420   // definition without doing a Java call)
 421   static bool is_alive(oop java_thread);
 422   // Daemon
 423   static bool is_daemon(oop java_thread);
 424   static void set_daemon(oop java_thread);
 425   // Context ClassLoader
 426   static oop context_class_loader(oop java_thread);
 427   // Control context
 428   static oop inherited_access_control_context(oop java_thread);
 429   // Stack size hint
 430   static jlong stackSize(oop java_thread);
 431   // Thread ID
 432   static jlong thread_id(oop java_thread);
 433 
 434   // Blocker object responsible for thread parking
 435   static oop park_blocker(oop java_thread);
 436 
 437   // Java Thread Status for JVMTI and M&amp;M use.
 438   // This thread status info is saved in threadStatus field of
 439   // java.lang.Thread java class.
 440   enum ThreadStatus {
 441     NEW                      = 0,
 442     RUNNABLE                 = JVMTI_THREAD_STATE_ALIVE +          // runnable / running
 443                                JVMTI_THREAD_STATE_RUNNABLE,
 444     SLEEPING                 = JVMTI_THREAD_STATE_ALIVE +          // Thread.sleep()
 445                                JVMTI_THREAD_STATE_WAITING +
 446                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 447                                JVMTI_THREAD_STATE_SLEEPING,
 448     IN_OBJECT_WAIT           = JVMTI_THREAD_STATE_ALIVE +          // Object.wait()
 449                                JVMTI_THREAD_STATE_WAITING +
 450                                JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
 451                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 452     IN_OBJECT_WAIT_TIMED     = JVMTI_THREAD_STATE_ALIVE +          // Object.wait(long)
 453                                JVMTI_THREAD_STATE_WAITING +
 454                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 455                                JVMTI_THREAD_STATE_IN_OBJECT_WAIT,
 456     PARKED                   = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park()
 457                                JVMTI_THREAD_STATE_WAITING +
 458                                JVMTI_THREAD_STATE_WAITING_INDEFINITELY +
 459                                JVMTI_THREAD_STATE_PARKED,
 460     PARKED_TIMED             = JVMTI_THREAD_STATE_ALIVE +          // LockSupport.park(long)
 461                                JVMTI_THREAD_STATE_WAITING +
 462                                JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT +
 463                                JVMTI_THREAD_STATE_PARKED,
 464     BLOCKED_ON_MONITOR_ENTER = JVMTI_THREAD_STATE_ALIVE +          // (re-)entering a synchronization block
 465                                JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER,
 466     TERMINATED               = JVMTI_THREAD_STATE_TERMINATED
 467   };
 468   // Write thread status info to threadStatus field of java.lang.Thread.
 469   static void set_thread_status(oop java_thread_oop, ThreadStatus status);
 470   // Read thread status info from threadStatus field of java.lang.Thread.
 471   static ThreadStatus get_thread_status(oop java_thread_oop);
 472 
 473   static const char*  thread_status_name(oop java_thread_oop);
 474 
 475   // Debugging
 476   friend class JavaClasses;
 477 };
 478 
 479 // Interface to java.lang.ThreadGroup objects
 480 
 481 class java_lang_ThreadGroup : AllStatic {
 482  private:
 483   static int _parent_offset;
 484   static int _name_offset;
 485   static int _threads_offset;
 486   static int _groups_offset;
 487   static int _maxPriority_offset;
 488   static int _destroyed_offset;
 489   static int _daemon_offset;
 490   static int _nthreads_offset;
 491   static int _ngroups_offset;
 492 
 493   static void compute_offsets();
 494 
 495  public:
 496   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 497 
 498   // parent ThreadGroup
 499   static oop  parent(oop java_thread_group);
 500   // name
 501   static const char* name(oop java_thread_group);
 502   // (&quot;name as oop&quot; accessor is not necessary)
 503   // Number of threads in group
 504   static int nthreads(oop java_thread_group);
 505   // threads
 506   static objArrayOop threads(oop java_thread_group);
 507   // Number of threads in group
 508   static int ngroups(oop java_thread_group);
 509   // groups
 510   static objArrayOop groups(oop java_thread_group);
 511   // maxPriority in group
 512   static ThreadPriority maxPriority(oop java_thread_group);
 513   // Destroyed
 514   static bool is_destroyed(oop java_thread_group);
 515   // Daemon
 516   static bool is_daemon(oop java_thread_group);
 517   // Debugging
 518   friend class JavaClasses;
 519 };
 520 
 521 
 522 
 523 // Interface to java.lang.Throwable objects
 524 
 525 class java_lang_Throwable: AllStatic {
 526   friend class BacktraceBuilder;
 527   friend class BacktraceIterator;
 528 
 529  private:
 530   // Trace constants
 531   enum {
 532     trace_methods_offset = 0,
 533     trace_bcis_offset    = 1,
 534     trace_mirrors_offset = 2,
 535     trace_names_offset   = 3,
 536     trace_next_offset    = 4,
 537     trace_hidden_offset  = 5,
 538     trace_size           = 6,
 539     trace_chunk_size     = 32
 540   };
 541 
 542   static int backtrace_offset;
 543   static int detailMessage_offset;
 544   static int stackTrace_offset;
 545   static int depth_offset;
 546   static int static_unassigned_stacktrace_offset;
 547 
 548   // StackTrace (programmatic access, new since 1.4)
 549   static void clear_stacktrace(oop throwable);
 550   // Stacktrace (post JDK 1.7.0 to allow immutability protocol to be followed)
 551   static void set_stacktrace(oop throwable, oop st_element_array);
 552   static oop unassigned_stacktrace();
 553 
 554  public:
 555   // Backtrace
 556   static oop backtrace(oop throwable);
 557   static void set_backtrace(oop throwable, oop value);
 558   static int depth(oop throwable);
 559   static void set_depth(oop throwable, int value);
 560   // Needed by JVMTI to filter out this internal field.
 561   static int get_backtrace_offset() { return backtrace_offset;}
 562   static int get_detailMessage_offset() { return detailMessage_offset;}
 563   // Message
 564   static oop message(oop throwable);
 565   static void set_message(oop throwable, oop value);
 566   static Symbol* detail_message(oop throwable);
 567   static void print_stack_element(outputStream *st, Method* method, int bci);
 568   static void print_stack_usage(Handle stream);
 569 
 570   static void compute_offsets();
 571   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 572 
 573   // Allocate space for backtrace (created but stack trace not filled in)
 574   static void allocate_backtrace(Handle throwable, TRAPS);
 575   // Fill in current stack trace for throwable with preallocated backtrace (no GC)
 576   static void fill_in_stack_trace_of_preallocated_backtrace(Handle throwable);
 577   // Fill in current stack trace, can cause GC
 578   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method, TRAPS);
 579   static void fill_in_stack_trace(Handle throwable, const methodHandle&amp; method = methodHandle());
 580   // Programmatic access to stack trace
 581   static void get_stack_trace_elements(Handle throwable, objArrayHandle stack_trace, TRAPS);
 582   // Printing
 583   static void print(oop throwable, outputStream* st);
 584   static void print_stack_trace(Handle throwable, outputStream* st);
 585   static void java_printStackTrace(Handle throwable, TRAPS);
 586   // Debugging
 587   friend class JavaClasses;
 588   // Gets the method and bci of the top frame (TOS). Returns false if this failed.
 589   static bool get_top_method_and_bci(oop throwable, Method** method, int* bci);
 590 };
 591 
 592 
 593 // Interface to java.lang.reflect.AccessibleObject objects
 594 
 595 class java_lang_reflect_AccessibleObject: AllStatic {
 596  private:
 597   // Note that to reduce dependencies on the JDK we compute these
 598   // offsets at run-time.
 599   static int override_offset;
 600 
 601   static void compute_offsets();
 602 
 603  public:
 604   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 605 
 606   // Accessors
 607   static jboolean override(oop reflect);
 608   static void set_override(oop reflect, jboolean value);
 609 
 610   // Debugging
 611   friend class JavaClasses;
 612 };
 613 
 614 
 615 // Interface to java.lang.reflect.Method objects
 616 
 617 class java_lang_reflect_Method : public java_lang_reflect_AccessibleObject {
 618  private:
 619   // Note that to reduce dependencies on the JDK we compute these
 620   // offsets at run-time.
 621   static int clazz_offset;
 622   static int name_offset;
 623   static int returnType_offset;
 624   static int parameterTypes_offset;
 625   static int exceptionTypes_offset;
 626   static int slot_offset;
 627   static int modifiers_offset;
 628   static int signature_offset;
 629   static int annotations_offset;
 630   static int parameter_annotations_offset;
 631   static int annotation_default_offset;
 632 
 633   static void compute_offsets();
 634  public:
 635   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 636 
 637   // Allocation
 638   static Handle create(TRAPS);
 639 
 640   // Accessors
 641   static oop clazz(oop reflect);
 642   static void set_clazz(oop reflect, oop value);
 643 
 644   static void set_name(oop method, oop value);
 645 
 646   static oop return_type(oop method);
 647   static void set_return_type(oop method, oop value);
 648 
 649   static oop parameter_types(oop method);
 650   static void set_parameter_types(oop method, oop value);
 651 
 652   static int slot(oop reflect);
 653   static void set_slot(oop reflect, int value);
 654 
 655   static void set_exception_types(oop method, oop value);
 656   static void set_modifiers(oop method, int value);
 657   static void set_signature(oop method, oop value);
 658   static void set_annotations(oop method, oop value);
 659   static void set_parameter_annotations(oop method, oop value);
 660   static void set_annotation_default(oop method, oop value);
 661 
 662   // Debugging
 663   friend class JavaClasses;
 664 };
 665 
 666 
 667 // Interface to java.lang.reflect.Constructor objects
 668 
 669 class java_lang_reflect_Constructor : public java_lang_reflect_AccessibleObject {
 670  private:
 671   // Note that to reduce dependencies on the JDK we compute these
 672   // offsets at run-time.
 673   static int clazz_offset;
 674   static int parameterTypes_offset;
 675   static int exceptionTypes_offset;
 676   static int slot_offset;
 677   static int modifiers_offset;
 678   static int signature_offset;
 679   static int annotations_offset;
 680   static int parameter_annotations_offset;
 681 
 682   static void compute_offsets();
 683  public:
 684   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 685 
 686   // Allocation
 687   static Handle create(TRAPS);
 688 
 689   // Accessors
 690   static oop clazz(oop reflect);
 691   static void set_clazz(oop reflect, oop value);
 692 
 693   static oop parameter_types(oop constructor);
 694   static void set_parameter_types(oop constructor, oop value);
 695 
 696   static int slot(oop reflect);
 697   static void set_slot(oop reflect, int value);
 698 
 699   static void set_exception_types(oop constructor, oop value);
 700   static void set_modifiers(oop constructor, int value);
 701   static void set_signature(oop constructor, oop value);
 702   static void set_annotations(oop constructor, oop value);
 703   static void set_parameter_annotations(oop method, oop value);
 704 
 705   // Debugging
 706   friend class JavaClasses;
 707 };
 708 
 709 
 710 // Interface to java.lang.reflect.Field objects
 711 
 712 class java_lang_reflect_Field : public java_lang_reflect_AccessibleObject {
 713  private:
 714   // Note that to reduce dependencies on the JDK we compute these
 715   // offsets at run-time.
 716   static int clazz_offset;
 717   static int name_offset;
 718   static int type_offset;
 719   static int slot_offset;
 720   static int modifiers_offset;
 721   static int signature_offset;
 722   static int annotations_offset;
 723 
 724   static void compute_offsets();
 725 
 726  public:
 727   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 728 
 729   // Allocation
 730   static Handle create(TRAPS);
 731 
 732   // Accessors
 733   static oop clazz(oop reflect);
 734   static void set_clazz(oop reflect, oop value);
 735 
 736   static oop name(oop field);
 737   static void set_name(oop field, oop value);
 738 
 739   static oop type(oop field);
 740   static void set_type(oop field, oop value);
 741 
 742   static int slot(oop reflect);
 743   static void set_slot(oop reflect, int value);
 744 
 745   static int modifiers(oop field);
 746   static void set_modifiers(oop field, int value);
 747 
 748   static void set_signature(oop constructor, oop value);
 749   static void set_annotations(oop constructor, oop value);
 750   static void set_parameter_annotations(oop method, oop value);
 751   static void set_annotation_default(oop method, oop value);
 752 
 753   // Debugging
 754   friend class JavaClasses;
 755 };
 756 
 757 class java_lang_reflect_Parameter {
 758  private:
 759   // Note that to reduce dependencies on the JDK we compute these
 760   // offsets at run-time.
 761   static int name_offset;
 762   static int modifiers_offset;
 763   static int index_offset;
 764   static int executable_offset;
 765 
 766   static void compute_offsets();
 767 
 768  public:
 769   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 770 
 771   // Allocation
 772   static Handle create(TRAPS);
 773 
 774   // Accessors
 775   static oop name(oop field);
 776   static void set_name(oop field, oop value);
 777 
 778   static int index(oop reflect);
 779   static void set_index(oop reflect, int value);
 780 
 781   static int modifiers(oop reflect);
 782   static void set_modifiers(oop reflect, int value);
 783 
 784   static oop executable(oop constructor);
 785   static void set_executable(oop constructor, oop value);
 786 
 787   friend class JavaClasses;
 788 };
 789 
 790 #define MODULE_INJECTED_FIELDS(macro)                            \
 791   macro(java_lang_Module, module_entry, intptr_signature, false)
 792 
 793 class java_lang_Module {
 794   private:
 795     static int loader_offset;
 796     static int name_offset;
 797     static int _module_entry_offset;
 798     static void compute_offsets();
 799 
 800   public:
 801     static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 802 
 803     // Allocation
 804     static Handle create(Handle loader, Handle module_name, TRAPS);
 805 
 806     // Testers
 807     static bool is_instance(oop obj);
 808 
 809     // Accessors
 810     static oop loader(oop module);
 811     static void set_loader(oop module, oop value);
 812 
 813     static oop name(oop module);
 814     static void set_name(oop module, oop value);
 815 
 816     static ModuleEntry* module_entry(oop module);
 817     static void set_module_entry(oop module, ModuleEntry* module_entry);
 818 
 819   friend class JavaClasses;
 820 };
 821 
 822 // Interface to jdk.internal.reflect.ConstantPool objects
 823 class reflect_ConstantPool {
 824  private:
 825   // Note that to reduce dependencies on the JDK we compute these
 826   // offsets at run-time.
 827   static int _oop_offset;
 828 
 829   static void compute_offsets();
 830 
 831  public:
 832   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 833 
 834   // Allocation
 835   static Handle create(TRAPS);
 836 
 837   // Accessors
 838   static void set_cp(oop reflect, ConstantPool* value);
 839   static int oop_offset() {
 840     return _oop_offset;
 841   }
 842 
 843   static ConstantPool* get_cp(oop reflect);
 844 
 845   // Debugging
 846   friend class JavaClasses;
 847 };
 848 
 849 // Interface to jdk.internal.reflect.UnsafeStaticFieldAccessorImpl objects
 850 class reflect_UnsafeStaticFieldAccessorImpl {
 851  private:
 852   static int _base_offset;
 853   static void compute_offsets();
 854 
 855  public:
 856   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 857 
 858   static int base_offset() {
 859     return _base_offset;
 860   }
 861 
 862   // Debugging
 863   friend class JavaClasses;
 864 };
 865 
 866 // Interface to java.lang primitive type boxing objects:
 867 //  - java.lang.Boolean
 868 //  - java.lang.Character
 869 //  - java.lang.Float
 870 //  - java.lang.Double
 871 //  - java.lang.Byte
 872 //  - java.lang.Short
 873 //  - java.lang.Integer
 874 //  - java.lang.Long
 875 
 876 // This could be separated out into 8 individual classes.
 877 
 878 class java_lang_boxing_object: AllStatic {
 879  private:
 880   static int value_offset;
 881   static int long_value_offset;
 882 
 883   static oop initialize_and_allocate(BasicType type, TRAPS);
 884  public:
 885   // Allocation. Returns a boxed value, or NULL for invalid type.
 886   static oop create(BasicType type, jvalue* value, TRAPS);
 887   // Accessors. Returns the basic type being boxed, or T_ILLEGAL for invalid oop.
 888   static BasicType get_value(oop box, jvalue* value);
 889   static BasicType set_value(oop box, jvalue* value);
 890   static BasicType basic_type(oop box);
 891   static bool is_instance(oop box)                 { return basic_type(box) != T_ILLEGAL; }
 892   static bool is_instance(oop box, BasicType type) { return basic_type(box) == type; }
 893   static void print(oop box, outputStream* st)     { jvalue value;  print(get_value(box, &amp;value), &amp;value, st); }
 894   static void print(BasicType type, jvalue* value, outputStream* st);
 895 
 896   static int value_offset_in_bytes(BasicType type) {
 897     return ( type == T_LONG || type == T_DOUBLE ) ? long_value_offset :
 898                                                     value_offset;
 899   }
 900 
 901   static void compute_offsets();
 902   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 903 
 904   // Debugging
 905   friend class JavaClasses;
 906 };
 907 
 908 
 909 
 910 // Interface to java.lang.ref.Reference objects
 911 
 912 class java_lang_ref_Reference: AllStatic {
 913   static bool _offsets_initialized;
 914 
 915  public:
 916   static int referent_offset;
 917   static int queue_offset;
 918   static int next_offset;
 919   static int discovered_offset;
 920 
 921   // Accessors
 922   static inline oop referent(oop ref);
 923   static inline void set_referent(oop ref, oop value);
 924   static inline void set_referent_raw(oop ref, oop value);
 925   static inline HeapWord* referent_addr_raw(oop ref);
 926   static inline oop next(oop ref);
 927   static inline void set_next(oop ref, oop value);
 928   static inline void set_next_raw(oop ref, oop value);
 929   static inline HeapWord* next_addr_raw(oop ref);
 930   static inline oop discovered(oop ref);
 931   static inline void set_discovered(oop ref, oop value);
 932   static inline void set_discovered_raw(oop ref, oop value);
 933   static inline HeapWord* discovered_addr_raw(oop ref);
 934   static inline oop queue(oop ref);
 935   static inline void set_queue(oop ref, oop value);
 936   static bool is_referent_field(oop obj, ptrdiff_t offset);
 937   static inline bool is_final(oop ref);
 938   static inline bool is_phantom(oop ref);
 939 
 940   static void compute_offsets();
 941   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 942 };
 943 
 944 
 945 // Interface to java.lang.ref.SoftReference objects
 946 
 947 class java_lang_ref_SoftReference: public java_lang_ref_Reference {
 948  public:
 949   static int timestamp_offset;
 950   static int static_clock_offset;
 951 
 952   // Accessors
 953   static jlong timestamp(oop ref);
 954 
 955   // Accessors for statics
 956   static jlong clock();
 957   static void set_clock(jlong value);
 958 
 959   static void compute_offsets();
 960   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 961 };
 962 
 963 // Interface to java.lang.invoke.MethodHandle objects
 964 
 965 class MethodHandleEntry;
 966 
 967 class java_lang_invoke_MethodHandle: AllStatic {
 968   friend class JavaClasses;
 969 
 970  private:
 971   static int _type_offset;               // the MethodType of this MH
 972   static int _form_offset;               // the LambdaForm of this MH
 973 
 974   static void compute_offsets();
 975 
 976  public:
 977   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
 978 
 979   // Accessors
 980   static oop            type(oop mh);
 981   static void       set_type(oop mh, oop mtype);
 982 
 983   static oop            form(oop mh);
 984   static void       set_form(oop mh, oop lform);
 985 
 986   // Testers
 987   static bool is_subclass(Klass* klass) {
 988     return klass-&gt;is_subclass_of(SystemDictionary::MethodHandle_klass());
 989   }
 990   static bool is_instance(oop obj);
 991 
 992   // Accessors for code generation:
 993   static int type_offset_in_bytes()             { return _type_offset; }
 994   static int form_offset_in_bytes()             { return _form_offset; }
 995 };
 996 
 997 // Interface to java.lang.invoke.DirectMethodHandle objects
 998 
 999 class java_lang_invoke_DirectMethodHandle: AllStatic {
1000   friend class JavaClasses;
1001 
1002  private:
1003   static int _member_offset;               // the MemberName of this DMH
1004 
1005   static void compute_offsets();
1006 
1007  public:
1008   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1009 
1010   // Accessors
1011   static oop  member(oop mh);
1012 
1013   // Testers
1014   static bool is_subclass(Klass* klass) {
1015     return klass-&gt;is_subclass_of(SystemDictionary::DirectMethodHandle_klass());
1016   }
1017   static bool is_instance(oop obj);
1018 
1019   // Accessors for code generation:
1020   static int member_offset_in_bytes()           { return _member_offset; }
1021 };
1022 
1023 // Interface to java.lang.invoke.LambdaForm objects
1024 // (These are a private interface for managing adapter code generation.)
1025 
1026 class java_lang_invoke_LambdaForm: AllStatic {
1027   friend class JavaClasses;
1028 
1029  private:
1030   static int _vmentry_offset;  // type is MemberName
1031 
1032   static void compute_offsets();
1033 
1034  public:
1035   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1036 
1037   // Accessors
1038   static oop            vmentry(oop lform);
1039   static void       set_vmentry(oop lform, oop invoker);
1040 
1041   // Testers
1042   static bool is_subclass(Klass* klass) {
1043     return SystemDictionary::LambdaForm_klass() != NULL &amp;&amp;
1044       klass-&gt;is_subclass_of(SystemDictionary::LambdaForm_klass());
1045   }
1046   static bool is_instance(oop obj);
1047 
1048   // Accessors for code generation:
1049   static int vmentry_offset_in_bytes()          { return _vmentry_offset; }
1050 };
1051 
1052 
1053 // Interface to java.lang.invoke.MemberName objects
1054 // (These are a private interface for Java code to query the class hierarchy.)
1055 
1056 #define RESOLVEDMETHOD_INJECTED_FIELDS(macro)                                   \
1057   macro(java_lang_invoke_ResolvedMethodName, vmholder, object_signature, false) \
1058   macro(java_lang_invoke_ResolvedMethodName, vmtarget, intptr_signature, false)
1059 
1060 class java_lang_invoke_ResolvedMethodName : AllStatic {
1061   friend class JavaClasses;
1062 
1063   static int _vmtarget_offset;
1064   static int _vmholder_offset;
1065 
1066   static void compute_offsets();
1067  public:
1068   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1069 
1070   static int vmtarget_offset_in_bytes() { return _vmtarget_offset; }
1071 
1072   static Method* vmtarget(oop resolved_method);
1073   static void set_vmtarget(oop resolved_method, Method* method);
1074 
1075   static void set_vmholder(oop resolved_method, oop holder);
1076 
1077   // find or create resolved member name
1078   static oop find_resolved_method(const methodHandle&amp; m, TRAPS);
1079 
1080   static bool is_instance(oop resolved_method);
1081 };
1082 
1083 
1084 #define MEMBERNAME_INJECTED_FIELDS(macro)                               \
1085   macro(java_lang_invoke_MemberName, vmindex,  intptr_signature, false)
1086 
1087 
1088 class java_lang_invoke_MemberName: AllStatic {
1089   friend class JavaClasses;
1090 
1091  private:
1092   // From java.lang.invoke.MemberName:
1093   //    private Class&lt;?&gt;   clazz;       // class in which the method is defined
1094   //    private String     name;        // may be null if not yet materialized
1095   //    private Object     type;        // may be null if not yet materialized
1096   //    private int        flags;       // modifier bits; see reflect.Modifier
1097   //    private ResolvedMethodName method;    // holds VM-specific target value
1098   //    private intptr_t   vmindex;     // member index within class or interface
1099   static int _clazz_offset;
1100   static int _name_offset;
1101   static int _type_offset;
1102   static int _flags_offset;
1103   static int _method_offset;
1104   static int _vmindex_offset;
1105 
1106   static void compute_offsets();
1107 
1108  public:
1109   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1110   // Accessors
1111   static oop            clazz(oop mname);
1112   static void       set_clazz(oop mname, oop clazz);
1113 
1114   static oop            type(oop mname);
1115   static void       set_type(oop mname, oop type);
1116 
1117   static oop            name(oop mname);
1118   static void       set_name(oop mname, oop name);
1119 
1120   static int            flags(oop mname);
1121   static void       set_flags(oop mname, int flags);
1122 
1123   // Link through ResolvedMethodName field to get Method*
1124   static Method*        vmtarget(oop mname);
1125   static void       set_method(oop mname, oop method);
1126 
1127   static intptr_t       vmindex(oop mname);
1128   static void       set_vmindex(oop mname, intptr_t index);
1129 
1130   // Testers
1131   static bool is_subclass(Klass* klass) {
1132     return klass-&gt;is_subclass_of(SystemDictionary::MemberName_klass());
1133   }
1134   static bool is_instance(oop obj);
1135 
1136   static bool is_method(oop obj);
1137 
1138   // Relevant integer codes (keep these in synch. with MethodHandleNatives.Constants):
1139   enum {
1140     MN_IS_METHOD             = 0x00010000, // method (not constructor)
1141     MN_IS_OBJECT_CONSTRUCTOR = 0x00020000, // constructor
1142     MN_IS_FIELD              = 0x00040000, // field
1143     MN_IS_TYPE               = 0x00080000, // nested type
1144     MN_CALLER_SENSITIVE      = 0x00100000, // @CallerSensitive annotation detected
1145     MN_REFERENCE_KIND_SHIFT  = 24, // refKind
1146     MN_REFERENCE_KIND_MASK   = 0x0F000000 &gt;&gt; MN_REFERENCE_KIND_SHIFT,
1147     // The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:
1148     MN_SEARCH_SUPERCLASSES   = 0x00100000, // walk super classes
1149     MN_SEARCH_INTERFACES     = 0x00200000, // walk implemented interfaces
1150     MN_NESTMATE_CLASS        = 0x00000001,
1151     MN_HIDDEN_CLASS          = 0x00000002,
1152     MN_STRONG_LOADER_LINK    = 0x00000004,
1153     MN_ACCESS_VM_ANNOTATIONS = 0x00000008
1154   };
1155 
1156   // Accessors for code generation:
1157   static int clazz_offset_in_bytes()            { return _clazz_offset; }
1158   static int type_offset_in_bytes()             { return _type_offset; }
1159   static int name_offset_in_bytes()             { return _name_offset; }
1160   static int flags_offset_in_bytes()            { return _flags_offset; }
1161   static int method_offset_in_bytes()           { return _method_offset; }
1162   static int vmindex_offset_in_bytes()          { return _vmindex_offset; }
1163 };
1164 
1165 
1166 // Interface to java.lang.invoke.MethodType objects
1167 
1168 class java_lang_invoke_MethodType: AllStatic {
1169   friend class JavaClasses;
1170 
1171  private:
1172   static int _rtype_offset;
1173   static int _ptypes_offset;
1174 
1175   static void compute_offsets();
1176 
1177  public:
1178   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1179   // Accessors
1180   static oop            rtype(oop mt);
1181   static objArrayOop    ptypes(oop mt);
1182 
1183   static oop            ptype(oop mt, int index);
1184   static int            ptype_count(oop mt);
1185 
1186   static int            ptype_slot_count(oop mt);  // extra counts for long/double
1187   static int            rtype_slot_count(oop mt);  // extra counts for long/double
1188 
1189   static Symbol*        as_signature(oop mt, bool intern_if_not_found);
1190   static void           print_signature(oop mt, outputStream* st);
1191 
1192   static bool is_instance(oop obj);
1193 
1194   static bool equals(oop mt1, oop mt2);
1195 
1196   // Accessors for code generation:
1197   static int rtype_offset_in_bytes()            { return _rtype_offset; }
1198   static int ptypes_offset_in_bytes()           { return _ptypes_offset; }
1199 };
1200 
1201 
1202 // Interface to java.lang.invoke.CallSite objects
1203 
1204 class java_lang_invoke_CallSite: AllStatic {
1205   friend class JavaClasses;
1206 
1207 private:
1208   static int _target_offset;
1209   static int _context_offset;
1210 
1211   static void compute_offsets();
1212 
1213 public:
1214   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1215   // Accessors
1216   static oop              target(          oop site);
1217   static void         set_target(          oop site, oop target);
1218   static void         set_target_volatile( oop site, oop target);
1219 
1220   static oop context_no_keepalive(oop site);
1221 
1222   // Testers
1223   static bool is_subclass(Klass* klass) {
1224     return klass-&gt;is_subclass_of(SystemDictionary::CallSite_klass());
1225   }
1226   static bool is_instance(oop obj);
1227 
1228   // Accessors for code generation:
1229   static int target_offset_in_bytes()           { return _target_offset; }
1230 };
1231 
1232 // Interface to java.lang.invoke.ConstantCallSite objects
1233 
1234 class java_lang_invoke_ConstantCallSite: AllStatic {
1235   friend class JavaClasses;
1236 
1237 private:
1238   static int _is_frozen_offset;
1239 
1240   static void compute_offsets();
1241 
1242 public:
1243   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1244   // Accessors
1245   static jboolean is_frozen(oop site);
1246 
1247   // Testers
1248   static bool is_subclass(Klass* klass) {
1249     return klass-&gt;is_subclass_of(SystemDictionary::ConstantCallSite_klass());
1250   }
1251   static bool is_instance(oop obj);
1252 };
1253 
1254 // Interface to java.lang.invoke.MethodHandleNatives$CallSiteContext objects
1255 
1256 #define CALLSITECONTEXT_INJECTED_FIELDS(macro) \
1257   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, vmdependencies, intptr_signature, false) \
1258   macro(java_lang_invoke_MethodHandleNatives_CallSiteContext, last_cleanup, long_signature, false)
1259 
1260 class DependencyContext;
1261 
1262 class java_lang_invoke_MethodHandleNatives_CallSiteContext : AllStatic {
1263   friend class JavaClasses;
1264 
1265 private:
1266   static int _vmdependencies_offset;
1267   static int _last_cleanup_offset;
1268 
1269   static void compute_offsets();
1270 
1271 public:
1272   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1273   // Accessors
1274   static DependencyContext vmdependencies(oop context);
1275 
1276   // Testers
1277   static bool is_subclass(Klass* klass) {
1278     return klass-&gt;is_subclass_of(SystemDictionary::Context_klass());
1279   }
1280   static bool is_instance(oop obj);
1281 };
1282 
1283 // Interface to java.security.AccessControlContext objects
1284 
1285 class java_security_AccessControlContext: AllStatic {
1286  private:
1287   // Note that for this class the layout changed between JDK1.2 and JDK1.3,
1288   // so we compute the offsets at startup rather than hard-wiring them.
1289   static int _context_offset;
1290   static int _privilegedContext_offset;
1291   static int _isPrivileged_offset;
1292   static int _isAuthorized_offset;
1293 
1294   static void compute_offsets();
1295  public:
1296   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1297   static oop create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS);
1298 
1299   // Debugging/initialization
1300   friend class JavaClasses;
1301 };
1302 
1303 
1304 // Interface to java.lang.ClassLoader objects
1305 
1306 #define CLASSLOADER_INJECTED_FIELDS(macro)                            \
1307   macro(java_lang_ClassLoader, loader_data,  intptr_signature, false)
1308 
1309 class java_lang_ClassLoader : AllStatic {
1310  private:
1311   static int _loader_data_offset;
1312   static bool offsets_computed;
1313   static int parent_offset;
1314   static int parallelCapable_offset;
1315   static int name_offset;
1316   static int nameAndId_offset;
1317   static int unnamedModule_offset;
1318 
1319  public:
1320   static void compute_offsets();
1321   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1322 
1323   static ClassLoaderData* loader_data_acquire(oop loader);
1324   static ClassLoaderData* loader_data_raw(oop loader);
1325   static void release_set_loader_data(oop loader, ClassLoaderData* new_data);
1326 
1327   static oop parent(oop loader);
1328   static oop name(oop loader);
1329   static oop nameAndId(oop loader);
1330   static bool isAncestor(oop loader, oop cl);
1331 
1332   // Support for parallelCapable field
1333   static bool parallelCapable(oop the_class_mirror);
1334 
1335   static bool is_trusted_loader(oop loader);
1336 
1337   // Return true if this is one of the class loaders associated with
1338   // the generated bytecodes for reflection.
1339   static bool is_reflection_class_loader(oop loader);
1340 
1341   // Fix for 4474172
1342   static oop  non_reflection_class_loader(oop loader);
1343 
1344   // Testers
1345   static bool is_subclass(Klass* klass) {
1346     return klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass());
1347   }
1348   static bool is_instance(oop obj);
1349 
1350   static oop unnamedModule(oop loader);
1351 
1352   // Debugging
1353   friend class JavaClasses;
1354   friend class ClassFileParser; // access to number_of_fake_fields
1355 };
1356 
1357 
1358 // Interface to java.lang.System objects
1359 
1360 class java_lang_System : AllStatic {
1361  private:
1362   static int  static_in_offset;
1363   static int static_out_offset;
1364   static int static_err_offset;
1365   static int static_security_offset;
1366 
1367  public:
1368   static int  in_offset_in_bytes();
1369   static int out_offset_in_bytes();
1370   static int err_offset_in_bytes();
1371 
1372   static void compute_offsets();
1373   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1374 
1375   // Debugging
1376   friend class JavaClasses;
1377 };
1378 
1379 
1380 // Interface to java.lang.StackTraceElement objects
1381 
1382 class java_lang_StackTraceElement: AllStatic {
1383  private:
1384   static int declaringClassObject_offset;
1385   static int classLoaderName_offset;
1386   static int moduleName_offset;
1387   static int moduleVersion_offset;
1388   static int declaringClass_offset;
1389   static int methodName_offset;
1390   static int fileName_offset;
1391   static int lineNumber_offset;
1392 
1393   // Setters
1394   static void set_classLoaderName(oop element, oop value);
1395   static void set_moduleName(oop element, oop value);
1396   static void set_moduleVersion(oop element, oop value);
1397   static void set_declaringClass(oop element, oop value);
1398   static void set_methodName(oop element, oop value);
1399   static void set_fileName(oop element, oop value);
1400   static void set_lineNumber(oop element, int value);
1401   static void set_declaringClassObject(oop element, oop value);
1402 
1403   static void decode_file_and_line(Handle java_mirror, InstanceKlass* holder, int version,
1404                                    const methodHandle&amp; method, int bci,
1405                                    Symbol*&amp; source, oop&amp; source_file, int&amp; line_number, TRAPS);
1406 
1407  public:
1408   // Create an instance of StackTraceElement
1409   static oop create(const methodHandle&amp; method, int bci, TRAPS);
1410 
1411   static void fill_in(Handle element, InstanceKlass* holder, const methodHandle&amp; method,
1412                       int version, int bci, Symbol* name, TRAPS);
1413 
1414   static void compute_offsets();
1415   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1416 
1417 #if INCLUDE_JVMCI
1418   static void decode(const methodHandle&amp; method, int bci, Symbol*&amp; fileName, int&amp; lineNumber, TRAPS);
1419 #endif
1420 
1421   // Debugging
1422   friend class JavaClasses;
1423 };
1424 
1425 
1426 class Backtrace: AllStatic {
1427  public:
1428   // Helper backtrace functions to store bci|version together.
1429   static int merge_bci_and_version(int bci, int version);
1430   static int merge_mid_and_cpref(int mid, int cpref);
1431   static int bci_at(unsigned int merged);
1432   static int version_at(unsigned int merged);
1433   static int mid_at(unsigned int merged);
1434   static int cpref_at(unsigned int merged);
1435   static int get_line_number(Method* method, int bci);
1436   static Symbol* get_source_file_name(InstanceKlass* holder, int version);
1437 
1438   // Debugging
1439   friend class JavaClasses;
1440 };
1441 
1442 // Interface to java.lang.StackFrameInfo objects
1443 
1444 #define STACKFRAMEINFO_INJECTED_FIELDS(macro)                      \
1445   macro(java_lang_StackFrameInfo, version, short_signature, false)
1446 
1447 class java_lang_StackFrameInfo: AllStatic {
1448 private:
1449   static int _memberName_offset;
1450   static int _bci_offset;
1451   static int _version_offset;
1452 
1453   static Method* get_method(Handle stackFrame, InstanceKlass* holder, TRAPS);
1454 
1455 public:
1456   // Setters
1457   static void set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS);
1458   static void set_bci(oop info, int value);
1459 
1460   static void set_version(oop info, short value);
1461 
1462   static void compute_offsets();
1463   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1464 
1465   static void to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS);
1466 
1467   // Debugging
1468   friend class JavaClasses;
1469 };
1470 
1471 class java_lang_LiveStackFrameInfo: AllStatic {
1472  private:
1473   static int _monitors_offset;
1474   static int _locals_offset;
1475   static int _operands_offset;
1476   static int _mode_offset;
1477 
1478  public:
1479   static void set_monitors(oop info, oop value);
1480   static void set_locals(oop info, oop value);
1481   static void set_operands(oop info, oop value);
1482   static void set_mode(oop info, int value);
1483 
1484   static void compute_offsets();
1485   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1486 
1487   // Debugging
1488   friend class JavaClasses;
1489 };
1490 
1491 // Interface to java.lang.reflect.RecordComponent objects
1492 
1493 class java_lang_reflect_RecordComponent: AllStatic {
1494  private:
1495   static int clazz_offset;
1496   static int name_offset;
1497   static int type_offset;
1498   static int accessor_offset;
1499   static int signature_offset;
1500   static int annotations_offset;
1501   static int typeAnnotations_offset;
1502 
1503   // Setters
1504   static void set_clazz(oop element, oop value);
1505   static void set_name(oop element, oop value);
1506   static void set_type(oop element, oop value);
1507   static void set_accessor(oop element, oop value);
1508   static void set_signature(oop element, oop value);
1509   static void set_annotations(oop element, oop value);
1510   static void set_typeAnnotations(oop element, oop value);
1511 
1512  public:
1513   // Create an instance of RecordComponent
1514   static oop create(InstanceKlass* holder, RecordComponent* component, TRAPS);
1515 
1516   static void compute_offsets();
1517   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1518 
1519   // Debugging
1520   friend class JavaClasses;
1521 };
1522 
1523 
1524 // Interface to java.lang.AssertionStatusDirectives objects
1525 
1526 class java_lang_AssertionStatusDirectives: AllStatic {
1527  private:
1528   static int classes_offset;
1529   static int classEnabled_offset;
1530   static int packages_offset;
1531   static int packageEnabled_offset;
1532   static int deflt_offset;
1533 
1534  public:
1535   // Setters
1536   static void set_classes(oop obj, oop val);
1537   static void set_classEnabled(oop obj, oop val);
1538   static void set_packages(oop obj, oop val);
1539   static void set_packageEnabled(oop obj, oop val);
1540   static void set_deflt(oop obj, bool val);
1541 
1542   static void compute_offsets();
1543   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1544 
1545   // Debugging
1546   friend class JavaClasses;
1547 };
1548 
1549 
1550 class java_nio_Buffer: AllStatic {
1551  private:
1552   static int _limit_offset;
1553 
1554  public:
1555   static int  limit_offset();
1556   static void compute_offsets();
1557   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1558 };
1559 
1560 class java_util_concurrent_locks_AbstractOwnableSynchronizer : AllStatic {
1561  private:
1562   static int  _owner_offset;
1563  public:
1564   static void compute_offsets();
1565   static oop  get_owner_threadObj(oop obj);
1566   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1567 };
1568 
1569  // Interface to jdk.internal.misc.UnsafeConsants
1570 
1571 class jdk_internal_misc_UnsafeConstants : AllStatic {
1572  public:
1573   static void set_unsafe_constants();
1574   static void compute_offsets() { }
1575   static void serialize_offsets(SerializeClosure* f) { }
1576 };
1577 
1578 class java_lang_Integer : AllStatic {
1579 public:
1580   static jint value(oop obj);
1581 };
1582 
1583 class java_lang_Long : AllStatic {
1584 public:
1585   static jlong value(oop obj);
1586 };
1587 
1588 class java_lang_Character : AllStatic {
1589 public:
1590   static jchar value(oop obj);
1591 };
1592 
1593 class java_lang_Short : AllStatic {
1594 public:
1595   static jshort value(oop obj);
1596 };
1597 
1598 class java_lang_Byte : AllStatic {
1599 public:
1600   static jbyte value(oop obj);
1601 };
1602 
1603 class java_lang_Boolean : AllStatic {
1604  private:
1605   static int _static_TRUE_offset;
1606   static int _static_FALSE_offset;
1607  public:
1608   static Symbol* symbol();
1609   static void compute_offsets(InstanceKlass* k);
1610   static oop  get_TRUE(InstanceKlass *k);
1611   static oop  get_FALSE(InstanceKlass *k);
1612   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1613   static jboolean value(oop obj);
1614 };
1615 
1616 class java_lang_Integer_IntegerCache : AllStatic {
1617  private:
1618   static int _static_cache_offset;
1619  public:
1620   static Symbol* symbol();
1621   static void compute_offsets(InstanceKlass* k);
1622   static objArrayOop  cache(InstanceKlass *k);
1623   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1624 };
1625 
1626 class java_lang_Long_LongCache : AllStatic {
1627  private:
1628   static int _static_cache_offset;
1629  public:
1630   static Symbol* symbol();
1631   static void compute_offsets(InstanceKlass* k);
1632   static objArrayOop  cache(InstanceKlass *k);
1633   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1634 };
1635 
1636 class java_lang_Character_CharacterCache : AllStatic {
1637  private:
1638   static int _static_cache_offset;
1639  public:
1640   static Symbol* symbol();
1641   static void compute_offsets(InstanceKlass* k);
1642   static objArrayOop  cache(InstanceKlass *k);
1643   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1644 };
1645 
1646 class java_lang_Short_ShortCache : AllStatic {
1647  private:
1648   static int _static_cache_offset;
1649  public:
1650   static Symbol* symbol();
1651   static void compute_offsets(InstanceKlass* k);
1652   static objArrayOop  cache(InstanceKlass *k);
1653   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1654 };
1655 
1656 class java_lang_Byte_ByteCache : AllStatic {
1657  private:
1658   static int _static_cache_offset;
1659  public:
1660   static Symbol* symbol();
1661   static void compute_offsets(InstanceKlass* k);
1662   static objArrayOop  cache(InstanceKlass *k);
1663   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1664 };
1665 
1666 class jdk_internal_vm_jni_SubElementSelector : AllStatic {
1667  private:
1668   static int _arrayElementType_offset;
1669   static int _subElementType_offset;
1670   static int _offset_offset;
1671   static int _isFlattened_offset;
<a name="1" id="anc1"></a><span class="line-modified">1672   static int _isInline_offset;</span>
1673  public:
1674   static Symbol* symbol();
1675   static void compute_offsets();
1676   static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;
1677 
1678   static oop getArrayElementType(oop obj);
1679   static void setArrayElementType(oop obj, oop type);
1680   static oop getSubElementType(oop obj);
1681   static void setSubElementType(oop obj, oop type);
1682   static int getOffset(oop obj);
1683   static void setOffset(oop obj, int offset);
1684   static bool getIsFlattened(oop obj);
1685   static void setIsFlattened(oop obj, bool b);
<a name="2" id="anc2"></a><span class="line-modified">1686   static bool getIsInline(oop obj);</span>
<span class="line-modified">1687   static void setIsInline(oop obj, bool b);</span>
1688 };
1689 
1690 // Use to declare fields that need to be injected into Java classes
1691 // for the JVM to use.  The name_index and signature_index are
1692 // declared in vmSymbols.  The may_be_java flag is used to declare
1693 // fields that might already exist in Java but should be injected if
1694 // they don&#39;t.  Otherwise the field is unconditionally injected and
1695 // the JVM uses the injected one.  This is to ensure that name
1696 // collisions don&#39;t occur.  In general may_be_java should be false
1697 // unless there&#39;s a good reason.
1698 
1699 class InjectedField {
1700  public:
1701   const SystemDictionary::WKID klass_id;
1702   const vmSymbols::SID name_index;
1703   const vmSymbols::SID signature_index;
1704   const bool           may_be_java;
1705 
1706 
1707   Klass* klass() const    { return SystemDictionary::well_known_klass(klass_id); }
1708   Symbol* name() const      { return lookup_symbol(name_index); }
1709   Symbol* signature() const { return lookup_symbol(signature_index); }
1710 
1711   int compute_offset();
1712 
1713   // Find the Symbol for this index
1714   static Symbol* lookup_symbol(int symbol_index) {
1715     return vmSymbols::symbol_at((vmSymbols::SID)symbol_index);
1716   }
1717 };
1718 
1719 #define DECLARE_INJECTED_FIELD_ENUM(klass, name, signature, may_be_java) \
1720   klass##_##name##_enum,
1721 
1722 #define ALL_INJECTED_FIELDS(macro)          \
1723   CLASS_INJECTED_FIELDS(macro)              \
1724   CLASSLOADER_INJECTED_FIELDS(macro)        \
1725   RESOLVEDMETHOD_INJECTED_FIELDS(macro)     \
1726   MEMBERNAME_INJECTED_FIELDS(macro)         \
1727   CALLSITECONTEXT_INJECTED_FIELDS(macro)    \
1728   STACKFRAMEINFO_INJECTED_FIELDS(macro)     \
1729   MODULE_INJECTED_FIELDS(macro)
1730 
1731 // Interface to hard-coded offset checking
1732 
1733 class JavaClasses : AllStatic {
1734  private:
1735 
1736   static InjectedField _injected_fields[];
1737 
1738   static bool check_offset(const char *klass_name, int offset, const char *field_name, const char* field_sig) PRODUCT_RETURN0;
1739  public:
1740   enum InjectedFieldID {
1741     ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD_ENUM)
1742     MAX_enum
1743   };
1744 
1745   static int compute_injected_offset(InjectedFieldID id);
1746 
1747   static void compute_offsets();
1748   static void check_offsets() PRODUCT_RETURN;
1749   static void serialize_offsets(SerializeClosure* soc) NOT_CDS_RETURN;
1750   static InjectedField* get_injected(Symbol* class_name, int* field_count);
1751   static bool is_supported_for_archiving(oop obj) NOT_CDS_JAVA_HEAP_RETURN_(false);
1752 };
1753 
1754 #undef DECLARE_INJECTED_FIELD_ENUM
1755 
1756 #endif // SHARE_CLASSFILE_JAVACLASSES_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
  33 #include &quot;classfile/classLoaderExt.hpp&quot;
  34 #include &quot;classfile/dictionary.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/klassFactory.hpp&quot;
  37 #include &quot;classfile/loaderConstraints.hpp&quot;
  38 #include &quot;classfile/packageEntry.hpp&quot;
  39 #include &quot;classfile/placeholders.hpp&quot;
  40 #include &quot;classfile/protectionDomainCache.hpp&quot;
  41 #include &quot;classfile/resolutionErrors.hpp&quot;
  42 #include &quot;classfile/stringTable.hpp&quot;
  43 #include &quot;classfile/symbolTable.hpp&quot;
  44 #include &quot;classfile/systemDictionary.hpp&quot;
  45 #include &quot;classfile/vmSymbols.hpp&quot;
  46 #include &quot;code/codeCache.hpp&quot;
  47 #include &quot;compiler/compileBroker.hpp&quot;
  48 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  49 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
  50 #include &quot;gc/shared/oopStorageSet.hpp&quot;
  51 #include &quot;interpreter/bytecodeStream.hpp&quot;
  52 #include &quot;interpreter/interpreter.hpp&quot;
  53 #include &quot;jfr/jfrEvents.hpp&quot;
  54 #include &quot;logging/log.hpp&quot;
  55 #include &quot;logging/logStream.hpp&quot;
  56 #include &quot;memory/filemap.hpp&quot;
  57 #include &quot;memory/heapShared.hpp&quot;
  58 #include &quot;memory/metaspaceClosure.hpp&quot;
  59 #include &quot;memory/oopFactory.hpp&quot;
  60 #include &quot;memory/resourceArea.hpp&quot;
  61 #include &quot;memory/universe.hpp&quot;
  62 #include &quot;oops/access.inline.hpp&quot;
  63 #include &quot;oops/fieldStreams.inline.hpp&quot;
  64 #include &quot;oops/instanceKlass.hpp&quot;
  65 #include &quot;oops/instanceRefKlass.hpp&quot;
  66 #include &quot;oops/klass.inline.hpp&quot;
  67 #include &quot;oops/method.inline.hpp&quot;
  68 #include &quot;oops/methodData.hpp&quot;
  69 #include &quot;oops/objArrayKlass.hpp&quot;
  70 #include &quot;oops/objArrayOop.inline.hpp&quot;
  71 #include &quot;oops/oop.inline.hpp&quot;
  72 #include &quot;oops/symbol.hpp&quot;
  73 #include &quot;oops/typeArrayKlass.hpp&quot;
  74 #include &quot;oops/valueKlass.hpp&quot;
  75 #include &quot;prims/jvmtiExport.hpp&quot;
  76 #include &quot;prims/methodHandles.hpp&quot;
  77 #include &quot;runtime/arguments.hpp&quot;
  78 #include &quot;runtime/biasedLocking.hpp&quot;
  79 #include &quot;runtime/handles.inline.hpp&quot;
  80 #include &quot;runtime/java.hpp&quot;
  81 #include &quot;runtime/javaCalls.hpp&quot;
  82 #include &quot;runtime/mutexLocker.hpp&quot;
  83 #include &quot;runtime/os.hpp&quot;
  84 #include &quot;runtime/sharedRuntime.hpp&quot;
  85 #include &quot;runtime/signature.hpp&quot;
  86 #include &quot;services/classLoadingService.hpp&quot;
  87 #include &quot;services/diagnosticCommand.hpp&quot;
  88 #include &quot;services/threadService.hpp&quot;
  89 #include &quot;utilities/macros.hpp&quot;
  90 #include &quot;utilities/utf8.hpp&quot;
  91 #if INCLUDE_CDS
  92 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  93 #endif
  94 #if INCLUDE_JFR
  95 #include &quot;jfr/jfr.hpp&quot;
  96 #endif
  97 
  98 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  99 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
 100 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
 101 SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
 102 ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
 103 
 104 oop         SystemDictionary::_system_loader_lock_obj     =  NULL;
 105 
 106 InstanceKlass*      SystemDictionary::_well_known_klasses[SystemDictionary::WKID_LIMIT]
 107                                                           =  { NULL /*, NULL...*/ };
 108 
 109 InstanceKlass*      SystemDictionary::_box_klasses[T_VOID+1]      =  { NULL /*, NULL...*/ };
 110 
 111 oop         SystemDictionary::_java_system_loader         =  NULL;
 112 oop         SystemDictionary::_java_platform_loader       =  NULL;
 113 
 114 // Default ProtectionDomainCacheSize value
 115 
 116 const int defaultProtectionDomainCacheSize = 1009;
 117 
 118 ClassLoadInfo::ClassLoadInfo() {
 119   _protection_domain = Handle();
 120   _unsafe_anonymous_host = NULL;
 121   _cp_patches = NULL;
 122   _class_hidden_info._dynamic_nest_host = NULL;
 123   _class_hidden_info._class_data = Handle();
 124   _is_hidden = false;
 125   _is_strong_hidden = false;
 126   _can_access_vm_annotations = false;
 127 }
 128 
 129 ClassLoadInfo::ClassLoadInfo(Handle protection_domain) {
 130   _protection_domain = protection_domain;
 131   _unsafe_anonymous_host = NULL;
 132   _cp_patches = NULL;
 133   _class_hidden_info._dynamic_nest_host = NULL;
 134   _class_hidden_info._class_data = Handle();
 135   _is_hidden = false;
 136   _is_strong_hidden = false;
 137   _can_access_vm_annotations = false;
 138 }
 139 
 140 ClassLoadInfo::ClassLoadInfo(Handle protection_domain,
 141                              const InstanceKlass* unsafe_anonymous_host,
 142                              GrowableArray&lt;Handle&gt;* cp_patches,
 143                              InstanceKlass* dynamic_nest_host,
 144                              Handle class_data,
 145                              bool is_hidden,
 146                              bool is_strong_hidden,
 147                              bool can_access_vm_annotations) {
 148   _protection_domain = protection_domain;
 149   _unsafe_anonymous_host = unsafe_anonymous_host;
 150   _cp_patches = cp_patches;
 151   _class_hidden_info._dynamic_nest_host = dynamic_nest_host;
 152   _class_hidden_info._class_data = class_data;
 153   _is_hidden = is_hidden;
 154   _is_strong_hidden = is_strong_hidden;
 155   _can_access_vm_annotations = can_access_vm_annotations;
 156 }
 157 
 158 // ----------------------------------------------------------------------------
 159 // Java-level SystemLoader and PlatformLoader
 160 
 161 oop SystemDictionary::java_system_loader() {
 162   return _java_system_loader;
 163 }
 164 
 165 oop SystemDictionary::java_platform_loader() {
 166   return _java_platform_loader;
 167 }
 168 
 169 void SystemDictionary::compute_java_loaders(TRAPS) {
 170   JavaValue result(T_OBJECT);
 171   InstanceKlass* class_loader_klass = SystemDictionary::ClassLoader_klass();
 172   JavaCalls::call_static(&amp;result,
 173                          class_loader_klass,
 174                          vmSymbols::getSystemClassLoader_name(),
 175                          vmSymbols::void_classloader_signature(),
 176                          CHECK);
 177 
 178   _java_system_loader = (oop)result.get_jobject();
 179 
 180   JavaCalls::call_static(&amp;result,
 181                          class_loader_klass,
 182                          vmSymbols::getPlatformClassLoader_name(),
 183                          vmSymbols::void_classloader_signature(),
 184                          CHECK);
 185 
 186   _java_platform_loader = (oop)result.get_jobject();
 187 }
 188 
 189 ClassLoaderData* SystemDictionary::register_loader(Handle class_loader, bool create_mirror_cld) {
 190   if (create_mirror_cld) {
 191     // Add a new class loader data to the graph.
 192     return ClassLoaderDataGraph::add(class_loader, true);
 193   } else {
 194     return (class_loader() == NULL) ? ClassLoaderData::the_null_class_loader_data() :
 195                                       ClassLoaderDataGraph::find_or_create(class_loader);
 196   }
 197 }
 198 
 199 // ----------------------------------------------------------------------------
 200 // Parallel class loading check
 201 
 202 bool SystemDictionary::is_parallelCapable(Handle class_loader) {
 203   if (class_loader.is_null()) return true;
 204   if (AlwaysLockClassLoader) return false;
 205   return java_lang_ClassLoader::parallelCapable(class_loader());
 206 }
 207 // ----------------------------------------------------------------------------
 208 // ParallelDefineClass flag does not apply to bootclass loader
 209 bool SystemDictionary::is_parallelDefine(Handle class_loader) {
 210    if (class_loader.is_null()) return false;
 211    if (AllowParallelDefineClass &amp;&amp; java_lang_ClassLoader::parallelCapable(class_loader())) {
 212      return true;
 213    }
 214    return false;
 215 }
 216 
 217 // Returns true if the passed class loader is the builtin application class loader
 218 // or a custom system class loader. A customer system class loader can be
 219 // specified via -Djava.system.class.loader.
 220 bool SystemDictionary::is_system_class_loader(oop class_loader) {
 221   if (class_loader == NULL) {
 222     return false;
 223   }
 224   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass() ||
 225          class_loader == _java_system_loader);
 226 }
 227 
 228 // Returns true if the passed class loader is the platform class loader.
 229 bool SystemDictionary::is_platform_class_loader(oop class_loader) {
 230   if (class_loader == NULL) {
 231     return false;
 232   }
 233   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_PlatformClassLoader_klass());
 234 }
 235 
 236 // ----------------------------------------------------------------------------
 237 // Resolving of classes
 238 
 239 Symbol* SystemDictionary::class_name_symbol(const char* name, Symbol* exception, TRAPS) {
 240   if (name == NULL) {
 241     THROW_MSG_0(exception, &quot;No class name given&quot;);
 242   }
 243   if ((int)strlen(name) &gt; Symbol::max_length()) {
 244     // It&#39;s impossible to create this class;  the name cannot fit
 245     // into the constant pool.
 246     Exceptions::fthrow(THREAD_AND_LOCATION, exception,
 247                        &quot;Class name exceeds maximum length of %d: %s&quot;,
 248                        Symbol::max_length(),
 249                        name);
 250     return NULL;
 251   }
 252   // Callers should ensure that the name is never an illegal UTF8 string.
 253   assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false),
 254          &quot;Class name is not a valid utf8 string.&quot;);
 255 
 256   // Make a new symbol for the class name.
 257   return SymbolTable::new_symbol(name);
 258 }
 259 
 260 // Forwards to resolve_or_null
 261 
 262 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain, bool throw_error, TRAPS) {
 263   Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD);
 264   if (HAS_PENDING_EXCEPTION || klass == NULL) {
 265     // can return a null klass
 266     klass = handle_resolution_exception(class_name, throw_error, klass, THREAD);
 267   }
 268   return klass;
 269 }
 270 
 271 Klass* SystemDictionary::handle_resolution_exception(Symbol* class_name,
 272                                                      bool throw_error,
 273                                                      Klass* klass, TRAPS) {
 274   if (HAS_PENDING_EXCEPTION) {
 275     // If we have a pending exception we forward it to the caller, unless throw_error is true,
 276     // in which case we have to check whether the pending exception is a ClassNotFoundException,
 277     // and if so convert it to a NoClassDefFoundError
 278     // And chain the original ClassNotFoundException
 279     if (throw_error &amp;&amp; PENDING_EXCEPTION-&gt;is_a(SystemDictionary::ClassNotFoundException_klass())) {
 280       ResourceMark rm(THREAD);
 281       assert(klass == NULL, &quot;Should not have result with exception pending&quot;);
 282       Handle e(THREAD, PENDING_EXCEPTION);
 283       CLEAR_PENDING_EXCEPTION;
 284       THROW_MSG_CAUSE_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name-&gt;as_C_string(), e);
 285     } else {
 286       return NULL;
 287     }
 288   }
 289   // Class not found, throw appropriate error or exception depending on value of throw_error
 290   if (klass == NULL) {
 291     ResourceMark rm(THREAD);
 292     if (throw_error) {
 293       THROW_MSG_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name-&gt;as_C_string());
 294     } else {
 295       THROW_MSG_NULL(vmSymbols::java_lang_ClassNotFoundException(), class_name-&gt;as_C_string());
 296     }
 297   }
 298   return klass;
 299 }
 300 
 301 
 302 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name,
 303                                            bool throw_error, TRAPS)
 304 {
 305   return resolve_or_fail(class_name, Handle(), Handle(), throw_error, THREAD);
 306 }
 307 
 308 
 309 // Forwards to resolve_array_class_or_null or resolve_instance_class_or_null
 310 
 311 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
 312   if (Signature::is_array(class_name)) {
 313     return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);
 314   } else {
 315     return resolve_instance_class_or_null_helper(class_name, class_loader, protection_domain, THREAD);
 316   }
 317 }
 318 
 319 // name may be in the form of &quot;java/lang/Object&quot; or &quot;Ljava/lang/Object;&quot;
 320 InstanceKlass* SystemDictionary::resolve_instance_class_or_null_helper(Symbol* class_name,
 321                                                                        Handle class_loader,
 322                                                                        Handle protection_domain,
 323                                                                        TRAPS) {
 324   assert(class_name != NULL &amp;&amp; !Signature::is_array(class_name), &quot;must be&quot;);
 325   if (Signature::has_envelope(class_name)) {
 326     ResourceMark rm(THREAD);
 327     // Ignore wrapping L and ;. (and Q and ; for value types);
 328     TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1,
 329                                                  class_name-&gt;utf8_length() - 2);
 330     return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
 331   } else {
 332     return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
 333   }
 334 }
 335 
 336 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {
 337   return resolve_or_null(class_name, Handle(), Handle(), THREAD);
 338 }
 339 
 340 // Forwards to resolve_instance_class_or_null
 341 
 342 Klass* SystemDictionary::resolve_array_class_or_null(Symbol* class_name,
 343                                                      Handle class_loader,
 344                                                      Handle protection_domain,
 345                                                      TRAPS) {
 346   assert(Signature::is_array(class_name), &quot;must be array&quot;);
 347   ResourceMark rm(THREAD);
 348   SignatureStream ss(class_name, false);
 349   int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
 350   Klass* k = NULL;
 351   BasicType t = ss.type();
 352   if (ss.has_envelope()) {
 353     Symbol* obj_class = ss.as_symbol();
 354     k = SystemDictionary::resolve_instance_class_or_null(obj_class,
 355                                                          class_loader,
 356                                                          protection_domain,
 357                                                          CHECK_NULL);
 358     if (k != NULL) {
 359       k = k-&gt;array_klass(ndims, CHECK_NULL);
 360     }
 361   } else {
 362     k = Universe::typeArrayKlassObj(t);
 363     k = TypeArrayKlass::cast(k)-&gt;array_klass(ndims, CHECK_NULL);
 364   }
 365   return k;
 366 }
 367 
 368 // Must be called for any super-class or super-interface resolution
 369 // during class definition to allow class circularity checking
 370 // super-interface callers:
 371 //    parse_interfaces - for defineClass &amp; jvmtiRedefineClasses
 372 // super-class callers:
 373 //   ClassFileParser - for defineClass &amp; jvmtiRedefineClasses
 374 //   load_shared_class - while loading a class from shared archive
 375 //   resolve_instance_class_or_null:
 376 //     via: handle_parallel_super_load
 377 //      when resolving a class that has an existing placeholder with
 378 //      a saved superclass [i.e. a defineClass is currently in progress]
 379 //      if another thread is trying to resolve the class, it must do
 380 //      super-class checks on its own thread to catch class circularity
 381 // This last call is critical in class circularity checking for cases
 382 // where classloading is delegated to different threads and the
 383 // classloader lock is released.
 384 // Take the case: Base-&gt;Super-&gt;Base
 385 //   1. If thread T1 tries to do a defineClass of class Base
 386 //    resolve_super_or_fail creates placeholder: T1, Base (super Super)
 387 //   2. resolve_instance_class_or_null does not find SD or placeholder for Super
 388 //    so it tries to load Super
 389 //   3. If we load the class internally, or user classloader uses same thread
 390 //      loadClassFromxxx or defineClass via parseClassFile Super ...
 391 //      3.1 resolve_super_or_fail creates placeholder: T1, Super (super Base)
 392 //      3.3 resolve_instance_class_or_null Base, finds placeholder for Base
 393 //      3.4 calls resolve_super_or_fail Base
 394 //      3.5 finds T1,Base -&gt; throws class circularity
 395 //OR 4. If T2 tries to resolve Super via defineClass Super ...
 396 //      4.1 resolve_super_or_fail creates placeholder: T2, Super (super Base)
 397 //      4.2 resolve_instance_class_or_null Base, finds placeholder for Base (super Super)
 398 //      4.3 calls resolve_super_or_fail Super in parallel on own thread T2
 399 //      4.4 finds T2, Super -&gt; throws class circularity
 400 // Must be called, even if superclass is null, since this is
 401 // where the placeholder entry is created which claims this
 402 // thread is loading this class/classloader.
 403 // Be careful when modifying this code: once you have run
 404 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_SUPER),
 405 // you need to find_and_remove it before returning.
 406 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 407 InstanceKlass* SystemDictionary::resolve_super_or_fail(Symbol* child_name,
 408                                                        Symbol* super_name,
 409                                                        Handle class_loader,
 410                                                        Handle protection_domain,
 411                                                        bool is_superclass,
 412                                                        TRAPS) {
 413   assert(!Signature::is_array(super_name), &quot;invalid super class name&quot;);
 414 #if INCLUDE_CDS
 415   if (DumpSharedSpaces) {
 416     // Special processing for handling UNREGISTERED shared classes.
 417     InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(child_name,
 418         super_name, class_loader, protection_domain, is_superclass, CHECK_NULL);
 419     if (k) {
 420       return k;
 421     }
 422   }
 423 #endif // INCLUDE_CDS
 424 
 425   // Double-check, if child class is already loaded, just return super-class,interface
 426   // Don&#39;t add a placedholder if already loaded, i.e. already in appropriate class loader
 427   // dictionary.
 428   // Make sure there&#39;s a placeholder for the *child* before resolving.
 429   // Used as a claim that this thread is currently loading superclass/classloader
 430   // Used here for ClassCircularity checks and also for heap verification
 431   // (every InstanceKlass needs to be in its class loader dictionary or have a placeholder).
 432   // Must check ClassCircularity before checking if super class is already loaded.
 433   //
 434   // We might not already have a placeholder if this child_name was
 435   // first seen via resolve_from_stream (jni_DefineClass or JVM_DefineClass);
 436   // the name of the class might not be known until the stream is actually
 437   // parsed.
 438   // Bugs 4643874, 4715493
 439 
 440   ClassLoaderData* loader_data = class_loader_data(class_loader);
 441   Dictionary* dictionary = loader_data-&gt;dictionary();
 442   unsigned int d_hash = dictionary-&gt;compute_hash(child_name);
 443   unsigned int p_hash = placeholders()-&gt;compute_hash(child_name);
 444   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 445   // can&#39;t throw error holding a lock
 446   bool child_already_loaded = false;
 447   bool throw_circularity_error = false;
 448   {
 449     MutexLocker mu(THREAD, SystemDictionary_lock);
 450     InstanceKlass* childk = find_class(d_hash, child_name, dictionary);
 451     InstanceKlass* quicksuperk;
 452     // to support // loading: if child done loading, just return superclass
 453     // if super_name, &amp; class_loader don&#39;t match:
 454     // if initial define, SD update will give LinkageError
 455     // if redefine: compare_class_versions will give HIERARCHY_CHANGED
 456     // so we don&#39;t throw an exception here.
 457     // see: nsk redefclass014 &amp; java.lang.instrument Instrument032
 458     if ((childk != NULL ) &amp;&amp; (is_superclass) &amp;&amp;
 459         ((quicksuperk = childk-&gt;java_super()) != NULL) &amp;&amp;
 460          ((quicksuperk-&gt;name() == super_name) &amp;&amp;
 461             (quicksuperk-&gt;class_loader() == class_loader()))) {
 462            return quicksuperk;
 463     } else {
 464       PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, child_name, loader_data);
 465       if (probe &amp;&amp; probe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_SUPER)) {
 466           throw_circularity_error = true;
 467       }
 468     }
 469     if (!throw_circularity_error) {
 470       // Be careful not to exit resolve_super
 471       PlaceholderEntry* newprobe = placeholders()-&gt;find_and_add(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, super_name, THREAD);
 472     }
 473   }
 474   if (throw_circularity_error) {
 475       ResourceMark rm(THREAD);
 476       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), child_name-&gt;as_C_string());
 477   }
 478 
 479 // java.lang.Object should have been found above
 480   assert(super_name != NULL, &quot;null super class for resolving&quot;);
 481   // Resolve the super class or interface, check results on return
 482   InstanceKlass* superk =
 483     SystemDictionary::resolve_instance_class_or_null_helper(super_name,
 484                                                             class_loader,
 485                                                             protection_domain,
 486                                                             THREAD);
 487 
 488   // Clean up of placeholders moved so that each classloadAction registrar self-cleans up
 489   // It is no longer necessary to keep the placeholder table alive until update_dictionary
 490   // or error. GC used to walk the placeholder table as strong roots.
 491   // The instanceKlass is kept alive because the class loader is on the stack,
 492   // which keeps the loader_data alive, as well as all instanceKlasses in
 493   // the loader_data. parseClassFile adds the instanceKlass to loader_data.
 494   {
 495     MutexLocker mu(THREAD, SystemDictionary_lock);
 496     placeholders()-&gt;find_and_remove(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);
 497     SystemDictionary_lock-&gt;notify_all();
 498   }
 499   if (HAS_PENDING_EXCEPTION || superk == NULL) {
 500     // can null superk
 501     Klass* k = handle_resolution_exception(super_name, true, superk, THREAD);
 502     assert(k == NULL || k == superk, &quot;must be&quot;);
 503     if (k == NULL) {
 504       superk = NULL;
 505     }
 506   }
 507 
 508   return superk;
 509 }
 510 
 511 Klass* SystemDictionary::resolve_inline_field_or_fail(AllFieldStream* fs,
 512                                                            Handle class_loader,
 513                                                            Handle protection_domain,
 514                                                            bool throw_error,
 515                                                            TRAPS) {
 516   Symbol* class_name = fs-&gt;signature()-&gt;fundamental_name(THREAD);
 517   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 518   ClassLoaderData* loader_data = class_loader_data(class_loader);
 519   unsigned int p_hash = placeholders()-&gt;compute_hash(class_name);
 520   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 521   bool throw_circularity_error = false;
 522   PlaceholderEntry* oldprobe;
 523 
 524   {
 525     MutexLocker mu(THREAD, SystemDictionary_lock);
 526     oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, class_name, loader_data);
 527     if (oldprobe != NULL &amp;&amp;
 528       oldprobe-&gt;check_seen_thread(THREAD, PlaceholderTable::INLINE_FIELD)) {
 529       throw_circularity_error = true;
 530 
 531     } else {
 532       placeholders()-&gt;find_and_add(p_index, p_hash, class_name, loader_data,
 533                                    PlaceholderTable::INLINE_FIELD, NULL, THREAD);
 534     }
 535   }
 536 
 537   Klass* klass = NULL;
 538   if (!throw_circularity_error) {
 539     klass = SystemDictionary::resolve_or_fail(class_name, class_loader,
 540                                                protection_domain, true, THREAD);
 541   } else {
 542     ResourceMark rm(THREAD);
 543     THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), class_name-&gt;as_C_string());
 544   }
 545 
 546   {
 547     MutexLocker mu(THREAD, SystemDictionary_lock);
 548     placeholders()-&gt;find_and_remove(p_index, p_hash, class_name, loader_data,
 549                                     PlaceholderTable::INLINE_FIELD, THREAD);
 550   }
 551 
 552   class_name-&gt;decrement_refcount();
 553   return klass;
 554 }
 555 
 556 void SystemDictionary::validate_protection_domain(InstanceKlass* klass,
 557                                                   Handle class_loader,
 558                                                   Handle protection_domain,
 559                                                   TRAPS) {
 560   // Now we have to call back to java to check if the initating class has access
 561   JavaValue result(T_VOID);
 562   LogTarget(Debug, protectiondomain) lt;
 563   if (lt.is_enabled()) {
 564     ResourceMark rm(THREAD);
 565     // Print out trace information
 566     LogStream ls(lt);
 567     ls.print_cr(&quot;Checking package access&quot;);
 568     if (class_loader() != NULL) {
 569       ls.print(&quot;class loader: &quot;);
 570       class_loader()-&gt;print_value_on(&amp;ls);
 571     } else {
 572       ls.print_cr(&quot;class loader: NULL&quot;);
 573     }
 574     if (protection_domain() != NULL) {
 575       ls.print(&quot; protection domain: &quot;);
 576       protection_domain()-&gt;print_value_on(&amp;ls);
 577     } else {
 578       ls.print_cr(&quot; protection domain: NULL&quot;);
 579     }
 580     ls.print(&quot; loading: &quot;); klass-&gt;print_value_on(&amp;ls);
 581     ls.cr();
 582   }
 583 
 584   // This handle and the class_loader handle passed in keeps this class from
 585   // being unloaded through several GC points.
 586   // The class_loader handle passed in is the initiating loader.
 587   Handle mirror(THREAD, klass-&gt;java_mirror());
 588 
 589   InstanceKlass* system_loader = SystemDictionary::ClassLoader_klass();
 590   JavaCalls::call_special(&amp;result,
 591                          class_loader,
 592                          system_loader,
 593                          vmSymbols::checkPackageAccess_name(),
 594                          vmSymbols::class_protectiondomain_signature(),
 595                          mirror,
 596                          protection_domain,
 597                          THREAD);
 598 
 599   if (HAS_PENDING_EXCEPTION) {
 600     log_debug(protectiondomain)(&quot;DENIED !!!!!!!!!!!!!!!!!!!!!&quot;);
 601   } else {
 602    log_debug(protectiondomain)(&quot;granted&quot;);
 603   }
 604 
 605   if (HAS_PENDING_EXCEPTION) return;
 606 
 607   // If no exception has been thrown, we have validated the protection domain
 608   // Insert the protection domain of the initiating class into the set.
 609   {
 610     ClassLoaderData* loader_data = class_loader_data(class_loader);
 611     Dictionary* dictionary = loader_data-&gt;dictionary();
 612 
 613     Symbol*  kn = klass-&gt;name();
 614     unsigned int d_hash = dictionary-&gt;compute_hash(kn);
 615 
 616     MutexLocker mu(THREAD, SystemDictionary_lock);
 617     int d_index = dictionary-&gt;hash_to_index(d_hash);
 618     dictionary-&gt;add_protection_domain(d_index, d_hash, klass,
 619                                       protection_domain, THREAD);
 620   }
 621 }
 622 
 623 // We only get here if this thread finds that another thread
 624 // has already claimed the placeholder token for the current operation,
 625 // but that other thread either never owned or gave up the
 626 // object lock
 627 // Waits on SystemDictionary_lock to indicate placeholder table updated
 628 // On return, caller must recheck placeholder table state
 629 //
 630 // We only get here if
 631 //  1) custom classLoader, i.e. not bootstrap classloader
 632 //  2) custom classLoader has broken the class loader objectLock
 633 //     so another thread got here in parallel
 634 //
 635 // lockObject must be held.
 636 // Complicated dance due to lock ordering:
 637 // Must first release the classloader object lock to
 638 // allow initial definer to complete the class definition
 639 // and to avoid deadlock
 640 // Reclaim classloader lock object with same original recursion count
 641 // Must release SystemDictionary_lock after notify, since
 642 // class loader lock must be claimed before SystemDictionary_lock
 643 // to prevent deadlocks
 644 //
 645 // The notify allows applications that did an untimed wait() on
 646 // the classloader object lock to not hang.
 647 void SystemDictionary::double_lock_wait(Handle lockObject, TRAPS) {
 648   assert_lock_strong(SystemDictionary_lock);
 649 
 650   bool calledholdinglock
 651       = ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, lockObject);
 652   assert(calledholdinglock,&quot;must hold lock for notify&quot;);
 653   assert((lockObject() != _system_loader_lock_obj &amp;&amp; !is_parallelCapable(lockObject)), &quot;unexpected double_lock_wait&quot;);
 654   ObjectSynchronizer::notifyall(lockObject, THREAD);
 655   intx recursions =  ObjectSynchronizer::complete_exit(lockObject, THREAD);
 656   SystemDictionary_lock-&gt;wait();
 657   SystemDictionary_lock-&gt;unlock();
 658   ObjectSynchronizer::reenter(lockObject, recursions, THREAD);
 659   SystemDictionary_lock-&gt;lock();
 660 }
 661 
 662 // If the class in is in the placeholder table, class loading is in progress
 663 // For cases where the application changes threads to load classes, it
 664 // is critical to ClassCircularity detection that we try loading
 665 // the superclass on the same thread internally, so we do parallel
 666 // super class loading here.
 667 // This also is critical in cases where the original thread gets stalled
 668 // even in non-circularity situations.
 669 // Note: must call resolve_super_or_fail even if null super -
 670 // to force placeholder entry creation for this class for circularity detection
 671 // Caller must check for pending exception
 672 // Returns non-null Klass* if other thread has completed load
 673 // and we are done,
 674 // If return null Klass* and no pending exception, the caller must load the class
 675 InstanceKlass* SystemDictionary::handle_parallel_super_load(
 676     Symbol* name, Symbol* superclassname, Handle class_loader,
 677     Handle protection_domain, Handle lockObject, TRAPS) {
 678 
 679   ClassLoaderData* loader_data = class_loader_data(class_loader);
 680   Dictionary* dictionary = loader_data-&gt;dictionary();
 681   unsigned int d_hash = dictionary-&gt;compute_hash(name);
 682   unsigned int p_hash = placeholders()-&gt;compute_hash(name);
 683   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 684 
 685   // superk is not used, resolve_super called for circularity check only
 686   // This code is reached in two situations. One if this thread
 687   // is loading the same class twice (e.g. ClassCircularity, or
 688   // java.lang.instrument).
 689   // The second is if another thread started the resolve_super first
 690   // and has not yet finished.
 691   // In both cases the original caller will clean up the placeholder
 692   // entry on error.
 693   Klass* superk = SystemDictionary::resolve_super_or_fail(name,
 694                                                           superclassname,
 695                                                           class_loader,
 696                                                           protection_domain,
 697                                                           true,
 698                                                           CHECK_NULL);
 699 
 700   // parallelCapable class loaders do NOT wait for parallel superclass loads to complete
 701   // Serial class loaders and bootstrap classloader do wait for superclass loads
 702  if (!class_loader.is_null() &amp;&amp; is_parallelCapable(class_loader)) {
 703     MutexLocker mu(THREAD, SystemDictionary_lock);
 704     // Check if classloading completed while we were loading superclass or waiting
 705     return find_class(d_hash, name, dictionary);
 706   }
 707 
 708   // must loop to both handle other placeholder updates
 709   // and spurious notifications
 710   bool super_load_in_progress = true;
 711   PlaceholderEntry* placeholder;
 712   while (super_load_in_progress) {
 713     MutexLocker mu(THREAD, SystemDictionary_lock);
 714     // Check if classloading completed while we were loading superclass or waiting
 715     InstanceKlass* check = find_class(d_hash, name, dictionary);
 716     if (check != NULL) {
 717       // Klass is already loaded, so just return it
 718       return check;
 719     } else {
 720       placeholder = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 721       if (placeholder &amp;&amp; placeholder-&gt;super_load_in_progress() ){
 722         // We only get here if the application has released the
 723         // classloader lock when another thread was in the middle of loading a
 724         // superclass/superinterface for this class, and now
 725         // this thread is also trying to load this class.
 726         // To minimize surprises, the first thread that started to
 727         // load a class should be the one to complete the loading
 728         // with the classfile it initially expected.
 729         // This logic has the current thread wait once it has done
 730         // all the superclass/superinterface loading it can, until
 731         // the original thread completes the class loading or fails
 732         // If it completes we will use the resulting InstanceKlass
 733         // which we will find below in the systemDictionary.
 734         // We also get here for parallel bootstrap classloader
 735         if (class_loader.is_null()) {
 736           SystemDictionary_lock-&gt;wait();
 737         } else {
 738           double_lock_wait(lockObject, THREAD);
 739         }
 740       } else {
 741         // If not in SD and not in PH, other thread&#39;s load must have failed
 742         super_load_in_progress = false;
 743       }
 744     }
 745   }
 746   return NULL;
 747 }
 748 
 749 static void post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld) {
 750   assert(event != NULL, &quot;invariant&quot;);
 751   assert(k != NULL, &quot;invariant&quot;);
 752   assert(event-&gt;should_commit(), &quot;invariant&quot;);
 753   event-&gt;set_loadedClass(k);
 754   event-&gt;set_definingClassLoader(k-&gt;class_loader_data());
 755   event-&gt;set_initiatingClassLoader(init_cld);
 756   event-&gt;commit();
 757 }
 758 
 759 
 760 // Be careful when modifying this code: once you have run
 761 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_INSTANCE),
 762 // you need to find_and_remove it before returning.
 763 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 764 //
 765 // name must be in the form of &quot;java/lang/Object&quot; -- cannot be &quot;Ljava/lang/Object;&quot;
 766 InstanceKlass* SystemDictionary::resolve_instance_class_or_null(Symbol* name,
 767                                                                 Handle class_loader,
 768                                                                 Handle protection_domain,
 769                                                                 TRAPS) {
 770   assert(name != NULL &amp;&amp; !Signature::is_array(name) &amp;&amp;
 771          !Signature::has_envelope(name), &quot;invalid class name&quot;);
 772 
 773   EventClassLoad class_load_start_event;
 774 
 775   HandleMark hm(THREAD);
 776 
 777   // Fix for 4474172; see evaluation for more details
 778   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 779   ClassLoaderData* loader_data = register_loader(class_loader);
 780   Dictionary* dictionary = loader_data-&gt;dictionary();
 781   unsigned int d_hash = dictionary-&gt;compute_hash(name);
 782 
 783   // Do lookup to see if class already exist and the protection domain
 784   // has the right access
 785   // This call uses find which checks protection domain already matches
 786   // All subsequent calls use find_class, and set has_loaded_class so that
 787   // before we return a result we call out to java to check for valid protection domain
 788   // to allow returning the Klass* and add it to the pd_set if it is valid
 789   {
 790     InstanceKlass* probe = dictionary-&gt;find(d_hash, name, protection_domain);
 791     if (probe != NULL) return probe;
 792   }
 793 
 794   // Non-bootstrap class loaders will call out to class loader and
 795   // define via jvm/jni_DefineClass which will acquire the
 796   // class loader object lock to protect against multiple threads
 797   // defining the class in parallel by accident.
 798   // This lock must be acquired here so the waiter will find
 799   // any successful result in the SystemDictionary and not attempt
 800   // the define.
 801   // ParallelCapable Classloaders and the bootstrap classloader
 802   // do not acquire lock here.
 803   bool DoObjectLock = true;
 804   if (is_parallelCapable(class_loader)) {
 805     DoObjectLock = false;
 806   }
 807 
 808   unsigned int p_hash = placeholders()-&gt;compute_hash(name);
 809   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 810 
 811   // Class is not in SystemDictionary so we have to do loading.
 812   // Make sure we are synchronized on the class loader before we proceed
 813   Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
 814   check_loader_lock_contention(lockObject, THREAD);
 815   ObjectLocker ol(lockObject, THREAD, DoObjectLock);
 816 
 817   // Check again (after locking) if class already exist in SystemDictionary
 818   bool class_has_been_loaded   = false;
 819   bool super_load_in_progress  = false;
 820   bool havesupername = false;
 821   InstanceKlass* k = NULL;
 822   PlaceholderEntry* placeholder;
 823   Symbol* superclassname = NULL;
 824 
 825   assert(THREAD-&gt;can_call_java(),
 826          &quot;can not load classes with compiler thread: class=%s, classloader=%s&quot;,
 827          name-&gt;as_C_string(),
 828          class_loader.is_null() ? &quot;null&quot; : class_loader-&gt;klass()-&gt;name()-&gt;as_C_string());
 829   {
 830     MutexLocker mu(THREAD, SystemDictionary_lock);
 831     InstanceKlass* check = find_class(d_hash, name, dictionary);
 832     if (check != NULL) {
 833       // InstanceKlass is already loaded, so just return it
 834       class_has_been_loaded = true;
 835       k = check;
 836     } else {
 837       placeholder = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 838       if (placeholder &amp;&amp; placeholder-&gt;super_load_in_progress()) {
 839          super_load_in_progress = true;
 840          if (placeholder-&gt;havesupername() == true) {
 841            superclassname = placeholder-&gt;supername();
 842            havesupername = true;
 843          }
 844       }
 845     }
 846   }
 847 
 848   // If the class is in the placeholder table, class loading is in progress
 849   if (super_load_in_progress &amp;&amp; havesupername==true) {
 850     k = handle_parallel_super_load(name,
 851                                    superclassname,
 852                                    class_loader,
 853                                    protection_domain,
 854                                    lockObject, THREAD);
 855     if (HAS_PENDING_EXCEPTION) {
 856       return NULL;
 857     }
 858     if (k != NULL) {
 859       class_has_been_loaded = true;
 860     }
 861   }
 862 
 863   bool throw_circularity_error = false;
 864   if (!class_has_been_loaded) {
 865     bool load_instance_added = false;
 866 
 867     // add placeholder entry to record loading instance class
 868     // Five cases:
 869     // All cases need to prevent modifying bootclasssearchpath
 870     // in parallel with a classload of same classname
 871     // Redefineclasses uses existence of the placeholder for the duration
 872     // of the class load to prevent concurrent redefinition of not completely
 873     // defined classes.
 874     // case 1. traditional classloaders that rely on the classloader object lock
 875     //   - no other need for LOAD_INSTANCE
 876     // case 2. traditional classloaders that break the classloader object lock
 877     //    as a deadlock workaround. Detection of this case requires that
 878     //    this check is done while holding the classloader object lock,
 879     //    and that lock is still held when calling classloader&#39;s loadClass.
 880     //    For these classloaders, we ensure that the first requestor
 881     //    completes the load and other requestors wait for completion.
 882     // case 3. Bootstrap classloader - don&#39;t own objectLocker
 883     //    This classloader supports parallelism at the classloader level,
 884     //    but only allows a single load of a class/classloader pair.
 885     //    No performance benefit and no deadlock issues.
 886     // case 4. parallelCapable user level classloaders - without objectLocker
 887     //    Allow parallel classloading of a class/classloader pair
 888 
 889     {
 890       MutexLocker mu(THREAD, SystemDictionary_lock);
 891       if (class_loader.is_null() || !is_parallelCapable(class_loader)) {
 892         PlaceholderEntry* oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 893         if (oldprobe) {
 894           // only need check_seen_thread once, not on each loop
 895           // 6341374 java/lang/Instrument with -Xcomp
 896           if (oldprobe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_INSTANCE)) {
 897             throw_circularity_error = true;
 898           } else {
 899             // case 1: traditional: should never see load_in_progress.
 900             while (!class_has_been_loaded &amp;&amp; oldprobe &amp;&amp; oldprobe-&gt;instance_load_in_progress()) {
 901 
 902               // case 3: bootstrap classloader: prevent futile classloading,
 903               // wait on first requestor
 904               if (class_loader.is_null()) {
 905                 SystemDictionary_lock-&gt;wait();
 906               } else {
 907               // case 2: traditional with broken classloader lock. wait on first
 908               // requestor.
 909                 double_lock_wait(lockObject, THREAD);
 910               }
 911               // Check if classloading completed while we were waiting
 912               InstanceKlass* check = find_class(d_hash, name, dictionary);
 913               if (check != NULL) {
 914                 // Klass is already loaded, so just return it
 915                 k = check;
 916                 class_has_been_loaded = true;
 917               }
 918               // check if other thread failed to load and cleaned up
 919               oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 920             }
 921           }
 922         }
 923       }
 924       // All cases: add LOAD_INSTANCE holding SystemDictionary_lock
 925       // case 4: parallelCapable: allow competing threads to try
 926       // LOAD_INSTANCE in parallel
 927 
 928       if (!throw_circularity_error &amp;&amp; !class_has_been_loaded) {
 929         PlaceholderEntry* newprobe = placeholders()-&gt;find_and_add(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, NULL, THREAD);
 930         load_instance_added = true;
 931         // For class loaders that do not acquire the classloader object lock,
 932         // if they did not catch another thread holding LOAD_INSTANCE,
 933         // need a check analogous to the acquire ObjectLocker/find_class
 934         // i.e. now that we hold the LOAD_INSTANCE token on loading this class/CL
 935         // one final check if the load has already completed
 936         // class loaders holding the ObjectLock shouldn&#39;t find the class here
 937         InstanceKlass* check = find_class(d_hash, name, dictionary);
 938         if (check != NULL) {
 939           // Klass is already loaded, so return it after checking/adding protection domain
 940           k = check;
 941           class_has_been_loaded = true;
 942         }
 943       }
 944     }
 945 
 946     // must throw error outside of owning lock
 947     if (throw_circularity_error) {
 948       assert(!HAS_PENDING_EXCEPTION &amp;&amp; load_instance_added == false,&quot;circularity error cleanup&quot;);
 949       ResourceMark rm(THREAD);
 950       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), name-&gt;as_C_string());
 951     }
 952 
 953     if (!class_has_been_loaded) {
 954 
 955       // Do actual loading
 956       k = load_instance_class(name, class_loader, THREAD);
 957 
 958       // If everything was OK (no exceptions, no null return value), and
 959       // class_loader is NOT the defining loader, do a little more bookkeeping.
 960       if (!HAS_PENDING_EXCEPTION &amp;&amp; k != NULL &amp;&amp;
 961         k-&gt;class_loader() != class_loader()) {
 962 
 963         check_constraints(d_hash, k, class_loader, false, THREAD);
 964 
 965         // Need to check for a PENDING_EXCEPTION again; check_constraints
 966         // can throw but we may have to remove entry from the placeholder table below.
 967         if (!HAS_PENDING_EXCEPTION) {
 968           // Record dependency for non-parent delegation.
 969           // This recording keeps the defining class loader of the klass (k) found
 970           // from being unloaded while the initiating class loader is loaded
 971           // even if the reference to the defining class loader is dropped
 972           // before references to the initiating class loader.
 973           loader_data-&gt;record_dependency(k);
 974 
 975           { // Grabbing the Compile_lock prevents systemDictionary updates
 976             // during compilations.
 977             MutexLocker mu(THREAD, Compile_lock);
 978             update_dictionary(d_hash, p_index, p_hash,
 979               k, class_loader, THREAD);
 980           }
 981 
 982           if (JvmtiExport::should_post_class_load()) {
 983             Thread *thread = THREAD;
 984             assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
 985             JvmtiExport::post_class_load((JavaThread *) thread, k);
 986           }
 987         }
 988       }
 989     } // load_instance_class
 990 
 991     if (load_instance_added == true) {
 992       // clean up placeholder entries for LOAD_INSTANCE success or error
 993       // This brackets the SystemDictionary updates for both defining
 994       // and initiating loaders
 995       MutexLocker mu(THREAD, SystemDictionary_lock);
 996       placeholders()-&gt;find_and_remove(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, THREAD);
 997       SystemDictionary_lock-&gt;notify_all();
 998     }
 999   }
1000 
1001   if (HAS_PENDING_EXCEPTION || k == NULL) {
1002     return NULL;
1003   }
1004   if (class_load_start_event.should_commit()) {
1005     post_class_load_event(&amp;class_load_start_event, k, loader_data);
1006   }
1007 #ifdef ASSERT
1008   {
1009     ClassLoaderData* loader_data = k-&gt;class_loader_data();
1010     MutexLocker mu(THREAD, SystemDictionary_lock);
1011     InstanceKlass* kk = find_class(name, loader_data);
1012     assert(kk == k, &quot;should be present in dictionary&quot;);
1013   }
1014 #endif
1015 
1016   // return if the protection domain in NULL
1017   if (protection_domain() == NULL) return k;
1018 
1019   // Check the protection domain has the right access
1020   if (dictionary-&gt;is_valid_protection_domain(d_hash, name,
1021                                              protection_domain)) {
1022     return k;
1023   }
1024 
1025   // Verify protection domain. If it fails an exception is thrown
1026   validate_protection_domain(k, class_loader, protection_domain, CHECK_NULL);
1027 
1028   return k;
1029 }
1030 
1031 
1032 // This routine does not lock the system dictionary.
1033 //
1034 // Since readers don&#39;t hold a lock, we must make sure that system
1035 // dictionary entries are only removed at a safepoint (when only one
1036 // thread is running), and are added to in a safe way (all links must
1037 // be updated in an MT-safe manner).
1038 //
1039 // Callers should be aware that an entry could be added just after
1040 // _dictionary-&gt;bucket(index) is read here, so the caller will not see
1041 // the new entry.
1042 
1043 Klass* SystemDictionary::find(Symbol* class_name,
1044                               Handle class_loader,
1045                               Handle protection_domain,
1046                               TRAPS) {
1047 
1048   // The result of this call should be consistent with the result
1049   // of the call to resolve_instance_class_or_null().
1050   // See evaluation 6790209 and 4474172 for more details.
1051   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
1052   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data_or_null(class_loader());
1053 
1054   if (loader_data == NULL) {
1055     // If the ClassLoaderData has not been setup,
1056     // then the class loader has no entries in the dictionary.
1057     return NULL;
1058   }
1059 
1060   Dictionary* dictionary = loader_data-&gt;dictionary();
1061   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
1062   return dictionary-&gt;find(d_hash, class_name,
1063                           protection_domain);
1064 }
1065 
1066 
1067 // Look for a loaded instance or array klass by name.  Do not do any loading.
1068 // return NULL in case of error.
1069 Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,
1070                                                       Handle class_loader,
1071                                                       Handle protection_domain,
1072                                                       TRAPS) {
1073   Klass* k = NULL;
1074   assert(class_name != NULL, &quot;class name must be non NULL&quot;);
1075 
1076   if (Signature::is_array(class_name)) {
1077     // The name refers to an array.  Parse the name.
1078     // dimension and object_key in FieldArrayInfo are assigned as a
1079     // side-effect of this call
1080     SignatureStream ss(class_name, false);
1081     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
1082     BasicType t = ss.type();
1083     if (t != T_OBJECT &amp;&amp; t != T_VALUETYPE) {
1084       k = Universe::typeArrayKlassObj(t);
1085     } else {
1086       k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);
1087     }
1088     if (k != NULL) {
1089       k = k-&gt;array_klass_or_null(ndims);
1090     }
1091   } else {
1092     k = find(class_name, class_loader, protection_domain, THREAD);
1093   }
1094   return k;
1095 }
1096 
1097 // Note: this method is much like resolve_from_stream, but
1098 // does not publish the classes via the SystemDictionary.
1099 // Handles Lookup.defineClass hidden, unsafe_DefineAnonymousClass
1100 // and redefineclasses. RedefinedClasses do not add to the class hierarchy.
1101 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
1102                                               Handle class_loader,
1103                                               ClassFileStream* st,
1104                                               const ClassLoadInfo&amp; cl_info,
1105                                               TRAPS) {
1106 
1107   EventClassLoad class_load_start_event;
1108   ClassLoaderData* loader_data;
1109   bool is_unsafe_anon_class = cl_info.unsafe_anonymous_host() != NULL;
1110 
1111   // - for unsafe anonymous class: create a new CLD whith a class holder that uses
1112   //                               the same class loader as the unsafe_anonymous_host.
1113   // - for hidden classes that are not strong: create a new CLD that has a class holder and
1114   //                                           whose loader is the Lookup class&#39;s loader.
1115   // - for hidden class: add the class to the Lookup class&#39;s loader&#39;s CLD.
1116   if (is_unsafe_anon_class || cl_info.is_hidden()) {
1117     guarantee(!is_unsafe_anon_class || cl_info.unsafe_anonymous_host()-&gt;class_loader() == class_loader(),
1118               &quot;should be NULL or the same&quot;);
1119     bool create_mirror_cld = is_unsafe_anon_class || !cl_info.is_strong_hidden();
1120     loader_data = register_loader(class_loader, create_mirror_cld);
1121   } else {
1122     loader_data = ClassLoaderData::class_loader_data(class_loader());
1123   }
1124 
1125   assert(st != NULL, &quot;invariant&quot;);
1126   assert(st-&gt;need_verify(), &quot;invariant&quot;);
1127 
1128   // Parse stream and create a klass.
1129   // Note that we do this even though this klass might
1130   // already be present in the SystemDictionary, otherwise we would not
1131   // throw potential ClassFormatErrors.
1132 
1133   InstanceKlass* k = KlassFactory::create_from_stream(st,
1134                                                       class_name,
1135                                                       loader_data,
1136                                                       cl_info,
1137                                                       CHECK_NULL);
1138 
1139   if ((cl_info.is_hidden() || is_unsafe_anon_class) &amp;&amp; k != NULL) {
1140     // Hidden classes that are not strong and unsafe anonymous classes must update
1141     // ClassLoaderData holder so that they can be unloaded when the mirror is no
1142     // longer referenced.
1143     if (!cl_info.is_strong_hidden() || is_unsafe_anon_class) {
1144       k-&gt;class_loader_data()-&gt;initialize_holder(Handle(THREAD, k-&gt;java_mirror()));
1145     }
1146 
1147     {
1148       MutexLocker mu_r(THREAD, Compile_lock);
1149 
1150       // Add to class hierarchy, initialize vtables, and do possible
1151       // deoptimizations.
1152       add_to_hierarchy(k, CHECK_NULL); // No exception, but can block
1153       // But, do not add to dictionary.
1154     }
1155 
1156     // Rewrite and patch constant pool here.
1157     k-&gt;link_class(CHECK_NULL);
1158     if (cl_info.cp_patches() != NULL) {
1159       k-&gt;constants()-&gt;patch_resolved_references(cl_info.cp_patches());
1160     }
1161 
1162     // If it&#39;s anonymous, initialize it now, since nobody else will.
1163     if (is_unsafe_anon_class) {
1164       k-&gt;eager_initialize(CHECK_NULL);
1165     }
1166 
1167     // notify jvmti
1168     if (JvmtiExport::should_post_class_load()) {
1169         assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1170         JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1171     }
1172     if (class_load_start_event.should_commit()) {
1173       post_class_load_event(&amp;class_load_start_event, k, loader_data);
1174     }
1175   }
1176   assert(is_unsafe_anon_class || NULL == cl_info.cp_patches(),
1177          &quot;cp_patches only found with unsafe_anonymous_host&quot;);
1178 
1179   return k;
1180 }
1181 
1182 // Add a klass to the system from a stream (called by jni_DefineClass and
1183 // JVM_DefineClass).
1184 // Note: class_name can be NULL. In that case we do not know the name of
1185 // the class until we have parsed the stream.
1186 
1187 InstanceKlass* SystemDictionary::resolve_from_stream(Symbol* class_name,
1188                                                      Handle class_loader,
1189                                                      Handle protection_domain,
1190                                                      ClassFileStream* st,
1191                                                      TRAPS) {
1192 
1193   HandleMark hm(THREAD);
1194 
1195   // Classloaders that support parallelism, e.g. bootstrap classloader,
1196   // do not acquire lock here
1197   bool DoObjectLock = true;
1198   if (is_parallelCapable(class_loader)) {
1199     DoObjectLock = false;
1200   }
1201 
1202   ClassLoaderData* loader_data = register_loader(class_loader);
1203 
1204   // Make sure we are synchronized on the class loader before we proceed
1205   Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1206   check_loader_lock_contention(lockObject, THREAD);
1207   ObjectLocker ol(lockObject, THREAD, DoObjectLock);
1208 
1209   assert(st != NULL, &quot;invariant&quot;);
1210 
1211   // Parse the stream and create a klass.
1212   // Note that we do this even though this klass might
1213   // already be present in the SystemDictionary, otherwise we would not
1214   // throw potential ClassFormatErrors.
1215  InstanceKlass* k = NULL;
1216 
1217 #if INCLUDE_CDS
1218   if (!DumpSharedSpaces) {
1219     k = SystemDictionaryShared::lookup_from_stream(class_name,
1220                                                    class_loader,
1221                                                    protection_domain,
1222                                                    st,
1223                                                    CHECK_NULL);
1224   }
1225 #endif
1226 
1227   if (k == NULL) {
1228     if (st-&gt;buffer() == NULL) {
1229       return NULL;
1230     }
1231     ClassLoadInfo cl_info(protection_domain);
1232     k = KlassFactory::create_from_stream(st, class_name, loader_data, cl_info, CHECK_NULL);
1233   }
1234 
1235   assert(k != NULL, &quot;no klass created&quot;);
1236   Symbol* h_name = k-&gt;name();
1237   assert(class_name == NULL || class_name == h_name, &quot;name mismatch&quot;);
1238 
1239   // Add class just loaded
1240   // If a class loader supports parallel classloading handle parallel define requests
1241   // find_or_define_instance_class may return a different InstanceKlass
1242   if (is_parallelCapable(class_loader)) {
1243     InstanceKlass* defined_k = find_or_define_instance_class(h_name, class_loader, k, THREAD);
1244     if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1245       // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1246       assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1247       loader_data-&gt;add_to_deallocate_list(k);
1248       k = defined_k;
1249     }
1250   } else {
1251     define_instance_class(k, THREAD);
1252   }
1253 
1254   // If defining the class throws an exception register &#39;k&#39; for cleanup.
1255   if (HAS_PENDING_EXCEPTION) {
1256     assert(k != NULL, &quot;Must have an instance klass here!&quot;);
1257     loader_data-&gt;add_to_deallocate_list(k);
1258     return NULL;
1259   }
1260 
1261   // Make sure we have an entry in the SystemDictionary on success
1262   debug_only( {
1263     MutexLocker mu(THREAD, SystemDictionary_lock);
1264 
1265     Klass* check = find_class(h_name, k-&gt;class_loader_data());
1266     assert(check == k, &quot;should be present in the dictionary&quot;);
1267   } );
1268 
1269   return k;
1270 }
1271 
1272 #if INCLUDE_CDS
1273 // Load a class for boot loader from the shared spaces. This also
1274 // forces the super class and all interfaces to be loaded.
1275 InstanceKlass* SystemDictionary::load_shared_boot_class(Symbol* class_name,
1276                                                         PackageEntry* pkg_entry,
1277                                                         TRAPS) {
1278   InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);
1279   if (ik != NULL &amp;&amp; ik-&gt;is_shared_boot_class()) {
1280     return load_shared_class(ik, Handle(), Handle(), NULL, pkg_entry, THREAD);
1281   }
1282   return NULL;
1283 }
1284 
1285 // Check if a shared class can be loaded by the specific classloader:
1286 //
1287 // NULL classloader:
1288 //   - Module class from &quot;modules&quot; jimage. ModuleEntry must be defined in the classloader.
1289 //   - Class from -Xbootclasspath/a. The class has no defined PackageEntry, or must
1290 //     be defined in an unnamed module.
1291 bool SystemDictionary::is_shared_class_visible(Symbol* class_name,
1292                                                InstanceKlass* ik,
1293                                                PackageEntry* pkg_entry,
1294                                                Handle class_loader, TRAPS) {
1295   assert(!ModuleEntryTable::javabase_moduleEntry()-&gt;is_patched(),
1296          &quot;Cannot use sharing if java.base is patched&quot;);
1297   ResourceMark rm(THREAD);
1298   int path_index = ik-&gt;shared_classpath_index();
1299   ClassLoaderData* loader_data = class_loader_data(class_loader);
1300   if (path_index &lt; 0) {
1301     // path_index &lt; 0 indicates that the class is intended for a custom loader
1302     // and should not be loaded by boot/platform/app loaders
1303     if (loader_data-&gt;is_builtin_class_loader_data()) {
1304       return false;
1305     } else {
1306       return true;
1307     }
1308   }
1309   SharedClassPathEntry* ent =
1310             (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);
1311   if (!Universe::is_module_initialized()) {
1312     assert(ent != NULL &amp;&amp; ent-&gt;is_modules_image(),
1313            &quot;Loading non-bootstrap classes before the module system is initialized&quot;);
1314     assert(class_loader.is_null(), &quot;sanity&quot;);
1315     return true;
1316   }
1317   // Get the pkg_entry from the classloader
1318   ModuleEntry* mod_entry = NULL;
1319   TempNewSymbol pkg_name = pkg_entry != NULL ? pkg_entry-&gt;name() :
1320                                                ClassLoader::package_from_class_name(class_name);
1321   if (pkg_name != NULL) {
1322     if (loader_data != NULL) {
1323       if (pkg_entry != NULL) {
1324         mod_entry = pkg_entry-&gt;module();
1325         // If the archived class is from a module that has been patched at runtime,
1326         // the class cannot be loaded from the archive.
1327         if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_patched()) {
1328           return false;
1329         }
1330       }
1331     }
1332   }
1333 
1334   if (class_loader.is_null()) {
1335     assert(ent != NULL, &quot;Shared class for NULL classloader must have valid SharedClassPathEntry&quot;);
1336     // The NULL classloader can load archived class originated from the
1337     // &quot;modules&quot; jimage and the -Xbootclasspath/a. For class from the
1338     // &quot;modules&quot; jimage, the PackageEntry/ModuleEntry must be defined
1339     // by the NULL classloader.
1340     if (mod_entry != NULL) {
1341       // PackageEntry/ModuleEntry is found in the classloader. Check if the
1342       // ModuleEntry&#39;s location agrees with the archived class&#39; origination.
1343       if (ent-&gt;is_modules_image() &amp;&amp; mod_entry-&gt;location()-&gt;starts_with(&quot;jrt:&quot;)) {
1344         return true; // Module class from the &quot;module&quot; jimage
1345       }
1346     }
1347 
1348     // If the archived class is not from the &quot;module&quot; jimage, the class can be
1349     // loaded by the NULL classloader if
1350     //
1351     // 1. the class is from the unamed package
1352     // 2. or, the class is not from a module defined in the NULL classloader
1353     // 3. or, the class is from an unamed module
1354     if (!ent-&gt;is_modules_image() &amp;&amp; ik-&gt;is_shared_boot_class()) {
1355       // the class is from the -Xbootclasspath/a
1356       if (pkg_name == NULL ||
1357           pkg_entry == NULL ||
1358           pkg_entry-&gt;in_unnamed_module()) {
1359         assert(mod_entry == NULL ||
1360                mod_entry == loader_data-&gt;unnamed_module(),
1361                &quot;the unnamed module is not defined in the classloader&quot;);
1362         return true;
1363       }
1364     }
1365     return false;
1366   } else {
1367     bool res = SystemDictionaryShared::is_shared_class_visible_for_classloader(
1368               ik, class_loader, pkg_name, pkg_entry, mod_entry, CHECK_(false));
1369     return res;
1370   }
1371 }
1372 
1373 bool SystemDictionary::check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super_type,
1374                                                      Handle class_loader,  Handle protection_domain,
1375                                                      bool is_superclass, TRAPS) {
1376   assert(super_type-&gt;is_shared(), &quot;must be&quot;);
1377 
1378   Klass *found = resolve_super_or_fail(child-&gt;name(), super_type-&gt;name(),
1379                                        class_loader, protection_domain, is_superclass, CHECK_0);
1380   if (found == super_type) {
1381     return true;
1382   } else {
1383     // The dynamically resolved super type is not the same as the one we used during dump time,
1384     // so we cannot use the child class.
1385     return false;
1386   }
1387 }
1388 
1389 bool SystemDictionary::check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,
1390                                                       Handle protection_domain, TRAPS) {
1391   // Check the superclass and interfaces. They must be the same
1392   // as in dump time, because the layout of &lt;ik&gt; depends on
1393   // the specific layout of ik-&gt;super() and ik-&gt;local_interfaces().
1394   //
1395   // If unexpected superclass or interfaces are found, we cannot
1396   // load &lt;ik&gt; from the shared archive.
1397 
1398   if (ik-&gt;super() != NULL &amp;&amp;
1399       !check_shared_class_super_type(ik, InstanceKlass::cast(ik-&gt;super()),
1400                                      class_loader, protection_domain, true, THREAD)) {
1401     return false;
1402   }
1403 
1404   Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
1405   int num_interfaces = interfaces-&gt;length();
1406   for (int index = 0; index &lt; num_interfaces; index++) {
1407     if (!check_shared_class_super_type(ik, interfaces-&gt;at(index), class_loader, protection_domain, false, THREAD)) {
1408       return false;
1409     }
1410   }
1411 
1412   return true;
1413 }
1414 
1415 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1416                                                    Handle class_loader,
1417                                                    Handle protection_domain,
1418                                                    const ClassFileStream *cfs,
1419                                                    PackageEntry* pkg_entry,
1420                                                    TRAPS) {
1421   assert(ik != NULL, &quot;sanity&quot;);
1422   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);
1423   Symbol* class_name = ik-&gt;name();
1424 
1425   bool visible = is_shared_class_visible(
1426                           class_name, ik, pkg_entry, class_loader, CHECK_NULL);
1427   if (!visible) {
1428     return NULL;
1429   }
1430 
1431   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {
1432     return NULL;
1433   }
1434 
1435   InstanceKlass* new_ik = KlassFactory::check_shared_class_file_load_hook(
1436       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
1437   if (new_ik != NULL) {
1438     // The class is changed by CFLH. Return the new class. The shared class is
1439     // not used.
1440     return new_ik;
1441   }
1442 
1443   // Adjust methods to recover missing data.  They need addresses for
1444   // interpreter entry points and their default native method address
1445   // must be reset.
1446 
1447   // Updating methods must be done under a lock so multiple
1448   // threads don&#39;t update these in parallel
1449   //
1450   // Shared classes are all currently loaded by either the bootstrap or
1451   // internal parallel class loaders, so this will never cause a deadlock
1452   // on a custom class loader lock.
1453 
1454   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1455   {
1456     HandleMark hm(THREAD);
1457     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1458     check_loader_lock_contention(lockObject, THREAD);
1459     ObjectLocker ol(lockObject, THREAD, true);
1460     // prohibited package check assumes all classes loaded from archive call
1461     // restore_unshareable_info which calls ik-&gt;set_package()
1462     ik-&gt;restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK_NULL);
1463   }
1464 
1465   load_shared_class_misc(ik, loader_data, CHECK_NULL);
1466   return ik;
1467 }
1468 
1469 void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {
1470   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1471 
1472   // For boot loader, ensure that GetSystemPackage knows that a class in this
1473   // package was loaded.
1474   if (loader_data-&gt;is_the_null_class_loader_data()) {
1475     int path_index = ik-&gt;shared_classpath_index();
1476     ik-&gt;set_classpath_index(path_index, THREAD);
1477   }
1478 
1479   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1480     // Only dump the classes that can be stored into CDS archive
1481     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1482       ResourceMark rm(THREAD);
1483       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());
1484       classlist_file-&gt;flush();
1485     }
1486   }
1487 
1488   // notify a class loaded from shared object
1489   ClassLoadingService::notify_class_loaded(ik, true /* shared class */);
1490 
1491   ik-&gt;set_has_passed_fingerprint_check(false);
1492   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
1493     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
1494     uint64_t cds_fp = ik-&gt;get_stored_fingerprint();
1495     if (aot_fp != 0 &amp;&amp; aot_fp == cds_fp) {
1496       // This class matches with a class saved in an AOT library
1497       ik-&gt;set_has_passed_fingerprint_check(true);
1498     } else {
1499       if (log_is_enabled(Info, class, fingerprint)) {
1500         ResourceMark rm(THREAD);
1501         log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT, ik-&gt;external_name(), aot_fp, cds_fp);
1502       }
1503     }
1504   }
1505 }
1506 
1507 void SystemDictionary::quick_resolve(InstanceKlass* klass, ClassLoaderData* loader_data, Handle domain, TRAPS) {
1508   assert(!Universe::is_fully_initialized(), &quot;We can make short cuts only during VM initialization&quot;);
1509   assert(klass-&gt;is_shared(), &quot;Must be shared class&quot;);
1510   if (klass-&gt;class_loader_data() != NULL) {
1511     return;
1512   }
1513 
1514   // add super and interfaces first
1515   Klass* super = klass-&gt;super();
1516   if (super != NULL &amp;&amp; super-&gt;class_loader_data() == NULL) {
1517     assert(super-&gt;is_instance_klass(), &quot;Super should be instance klass&quot;);
1518     quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);
1519   }
1520 
1521   Array&lt;InstanceKlass*&gt;* ifs = klass-&gt;local_interfaces();
1522   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
1523     InstanceKlass* ik = ifs-&gt;at(i);
1524     if (ik-&gt;class_loader_data()  == NULL) {
1525       quick_resolve(ik, loader_data, domain, CHECK);
1526     }
1527   }
1528 
1529   klass-&gt;restore_unshareable_info(loader_data, domain, NULL, THREAD);
1530   load_shared_class_misc(klass, loader_data, CHECK);
1531   Dictionary* dictionary = loader_data-&gt;dictionary();
1532   unsigned int hash = dictionary-&gt;compute_hash(klass-&gt;name());
1533   dictionary-&gt;add_klass(hash, klass-&gt;name(), klass);
1534   add_to_hierarchy(klass, CHECK);
1535   assert(klass-&gt;is_loaded(), &quot;Must be in at least loaded state&quot;);
1536 }
1537 #endif // INCLUDE_CDS
1538 
1539 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1540 
1541   if (class_loader.is_null()) {
1542     ResourceMark rm(THREAD);
1543     PackageEntry* pkg_entry = NULL;
1544     bool search_only_bootloader_append = false;
1545     ClassLoaderData *loader_data = class_loader_data(class_loader);
1546 
1547     // Find the package in the boot loader&#39;s package entry table.
1548     TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
1549     if (pkg_name != NULL) {
1550       pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
1551     }
1552 
1553     // Prior to attempting to load the class, enforce the boot loader&#39;s
1554     // visibility boundaries.
1555     if (!Universe::is_module_initialized()) {
1556       // During bootstrapping, prior to module initialization, any
1557       // class attempting to be loaded must be checked against the
1558       // java.base packages in the boot loader&#39;s PackageEntryTable.
1559       // No class outside of java.base is allowed to be loaded during
1560       // this bootstrapping window.
1561       if (pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1562         // Class is either in the unnamed package or in
1563         // a named package within the unnamed module.  Either
1564         // case is outside of java.base, do not attempt to
1565         // load the class post java.base definition.  If
1566         // java.base has not been defined, let the class load
1567         // and its package will be checked later by
1568         // ModuleEntryTable::verify_javabase_packages.
1569         if (ModuleEntryTable::javabase_defined()) {
1570           return NULL;
1571         }
1572       } else {
1573         // Check that the class&#39; package is defined within java.base.
1574         ModuleEntry* mod_entry = pkg_entry-&gt;module();
1575         Symbol* mod_entry_name = mod_entry-&gt;name();
1576         if (mod_entry_name-&gt;fast_compare(vmSymbols::java_base()) != 0) {
1577           return NULL;
1578         }
1579       }
1580     } else {
1581       // After the module system has been initialized, check if the class&#39;
1582       // package is in a module defined to the boot loader.
1583       if (pkg_name == NULL || pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1584         // Class is either in the unnamed package, in a named package
1585         // within a module not defined to the boot loader or in a
1586         // a named package within the unnamed module.  In all cases,
1587         // limit visibility to search for the class only in the boot
1588         // loader&#39;s append path.
1589         if (!ClassLoader::has_bootclasspath_append()) {
1590            // If there is no bootclasspath append entry, no need to continue
1591            // searching.
1592            return NULL;
1593         }
1594         search_only_bootloader_append = true;
1595       }
1596     }
1597 
1598     // Prior to bootstrapping&#39;s module initialization, never load a class outside
1599     // of the boot loader&#39;s module path
1600     assert(Universe::is_module_initialized() ||
1601            !search_only_bootloader_append,
1602            &quot;Attempt to load a class outside of boot loader&#39;s module path&quot;);
1603 
1604     // Search for classes in the CDS archive.
1605     InstanceKlass* k = NULL;
1606     {
1607 #if INCLUDE_CDS
1608       PerfTraceTime vmtimer(ClassLoader::perf_shared_classload_time());
1609       k = load_shared_boot_class(class_name, pkg_entry, THREAD);
1610 #endif
1611     }
1612 
1613     if (k == NULL) {
1614       // Use VM class loader
1615       PerfTraceTime vmtimer(ClassLoader::perf_sys_classload_time());
1616       k = ClassLoader::load_class(class_name, search_only_bootloader_append, CHECK_NULL);
1617     }
1618 
1619     // find_or_define_instance_class may return a different InstanceKlass
1620     if (k != NULL) {
1621       InstanceKlass* defined_k =
1622         find_or_define_instance_class(class_name, class_loader, k, THREAD);
1623       if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1624         // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1625         assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1626         loader_data-&gt;add_to_deallocate_list(k);
1627         k = defined_k;
1628       } else if (HAS_PENDING_EXCEPTION) {
1629         loader_data-&gt;add_to_deallocate_list(k);
1630         return NULL;
1631       }
1632     }
1633     return k;
1634   } else {
1635     // Use user specified class loader to load class. Call loadClass operation on class_loader.
1636     ResourceMark rm(THREAD);
1637 
1638     assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
1639     JavaThread* jt = (JavaThread*) THREAD;
1640 
1641     PerfClassTraceTime vmtimer(ClassLoader::perf_app_classload_time(),
1642                                ClassLoader::perf_app_classload_selftime(),
1643                                ClassLoader::perf_app_classload_count(),
1644                                jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
1645                                jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
1646                                PerfClassTraceTime::CLASS_LOAD);
1647 
1648     Handle s = java_lang_String::create_from_symbol(class_name, CHECK_NULL);
1649     // Translate to external class name format, i.e., convert &#39;/&#39; chars to &#39;.&#39;
1650     Handle string = java_lang_String::externalize_classname(s, CHECK_NULL);
1651 
1652     JavaValue result(T_OBJECT);
1653 
1654     InstanceKlass* spec_klass = SystemDictionary::ClassLoader_klass();
1655 
1656     // Call public unsynchronized loadClass(String) directly for all class loaders.
1657     // For parallelCapable class loaders, JDK &gt;=7, loadClass(String, boolean) will
1658     // acquire a class-name based lock rather than the class loader object lock.
1659     // JDK &lt; 7 already acquire the class loader lock in loadClass(String, boolean).
1660     JavaCalls::call_virtual(&amp;result,
1661                             class_loader,
1662                             spec_klass,
1663                             vmSymbols::loadClass_name(),
1664                             vmSymbols::string_class_signature(),
1665                             string,
1666                             CHECK_NULL);
1667 
1668     assert(result.get_type() == T_OBJECT, &quot;just checking&quot;);
1669     oop obj = (oop) result.get_jobject();
1670 
1671     // Primitive classes return null since forName() can not be
1672     // used to obtain any of the Class objects representing primitives or void
1673     if ((obj != NULL) &amp;&amp; !(java_lang_Class::is_primitive(obj))) {
1674       InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(obj));
1675       // For user defined Java class loaders, check that the name returned is
1676       // the same as that requested.  This check is done for the bootstrap
1677       // loader when parsing the class file.
1678       if (class_name == k-&gt;name()) {
1679         return k;
1680       }
1681     }
1682     // Class is not found or has the wrong name, return NULL
1683     return NULL;
1684   }
1685 }
1686 
1687 static void post_class_define_event(InstanceKlass* k, const ClassLoaderData* def_cld) {
1688   EventClassDefine event;
1689   if (event.should_commit()) {
1690     event.set_definedClass(k);
1691     event.set_definingClassLoader(def_cld);
1692     event.commit();
1693   }
1694 }
1695 
1696 void SystemDictionary::define_instance_class(InstanceKlass* k, TRAPS) {
1697 
1698   HandleMark hm(THREAD);
1699   ClassLoaderData* loader_data = k-&gt;class_loader_data();
1700   Handle class_loader_h(THREAD, loader_data-&gt;class_loader());
1701 
1702  // for bootstrap and other parallel classloaders don&#39;t acquire lock,
1703  // use placeholder token
1704  // If a parallelCapable class loader calls define_instance_class instead of
1705  // find_or_define_instance_class to get here, we have a timing
1706  // hole with systemDictionary updates and check_constraints
1707  if (!class_loader_h.is_null() &amp;&amp; !is_parallelCapable(class_loader_h)) {
1708     assert(ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD,
1709          compute_loader_lock_object(class_loader_h, THREAD)),
1710          &quot;define called without lock&quot;);
1711   }
1712 
1713   // Check class-loading constraints. Throw exception if violation is detected.
1714   // Grabs and releases SystemDictionary_lock
1715   // The check_constraints/find_class call and update_dictionary sequence
1716   // must be &quot;atomic&quot; for a specific class/classloader pair so we never
1717   // define two different instanceKlasses for that class/classloader pair.
1718   // Existing classloaders will call define_instance_class with the
1719   // classloader lock held
1720   // Parallel classloaders will call find_or_define_instance_class
1721   // which will require a token to perform the define class
1722   Symbol*  name_h = k-&gt;name();
1723   Dictionary* dictionary = loader_data-&gt;dictionary();
1724   unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
1725   check_constraints(d_hash, k, class_loader_h, true, CHECK);
1726 
1727   // Register class just loaded with class loader (placed in ArrayList)
1728   // Note we do this before updating the dictionary, as this can
1729   // fail with an OutOfMemoryError (if it does, we will *not* put this
1730   // class in the dictionary and will not update the class hierarchy).
1731   // JVMTI FollowReferences needs to find the classes this way.
1732   if (k-&gt;class_loader() != NULL) {
1733     methodHandle m(THREAD, Universe::loader_addClass_method());
1734     JavaValue result(T_VOID);
1735     JavaCallArguments args(class_loader_h);
1736     args.push_oop(Handle(THREAD, k-&gt;java_mirror()));
1737     JavaCalls::call(&amp;result, m, &amp;args, CHECK);
1738   }
1739 
1740   // Add the new class. We need recompile lock during update of CHA.
1741   {
1742     unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
1743     int p_index = placeholders()-&gt;hash_to_index(p_hash);
1744 
1745     MutexLocker mu_r(THREAD, Compile_lock);
1746 
1747     // Add to class hierarchy, initialize vtables, and do possible
1748     // deoptimizations.
1749     add_to_hierarchy(k, CHECK); // No exception, but can block
1750 
1751     // Add to systemDictionary - so other classes can see it.
1752     // Grabs and releases SystemDictionary_lock
1753     update_dictionary(d_hash, p_index, p_hash,
1754                       k, class_loader_h, THREAD);
1755   }
1756   k-&gt;eager_initialize(THREAD);
1757 
1758   // notify jvmti
1759   if (JvmtiExport::should_post_class_load()) {
1760       assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1761       JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1762 
1763   }
1764   post_class_define_event(k, loader_data);
1765 }
1766 
1767 // Support parallel classloading
1768 // All parallel class loaders, including bootstrap classloader
1769 // lock a placeholder entry for this class/class_loader pair
1770 // to allow parallel defines of different classes for this class loader
1771 // With AllowParallelDefine flag==true, in case they do not synchronize around
1772 // FindLoadedClass/DefineClass, calls, we check for parallel
1773 // loading for them, wait if a defineClass is in progress
1774 // and return the initial requestor&#39;s results
1775 // This flag does not apply to the bootstrap classloader.
1776 // With AllowParallelDefine flag==false, call through to define_instance_class
1777 // which will throw LinkageError: duplicate class definition.
1778 // False is the requested default.
1779 // For better performance, the class loaders should synchronize
1780 // findClass(), i.e. FindLoadedClass/DefineClassIfAbsent or they
1781 // potentially waste time reading and parsing the bytestream.
1782 // Note: VM callers should ensure consistency of k/class_name,class_loader
1783 // Be careful when modifying this code: once you have run
1784 // placeholders()-&gt;find_and_add(PlaceholderTable::DEFINE_CLASS),
1785 // you need to find_and_remove it before returning.
1786 // So be careful to not exit with a CHECK_ macro betweeen these calls.
1787 InstanceKlass* SystemDictionary::find_or_define_instance_class(Symbol* class_name, Handle class_loader,
1788                                                                InstanceKlass* k, TRAPS) {
1789 
1790   Symbol*  name_h = k-&gt;name(); // passed in class_name may be null
1791   ClassLoaderData* loader_data = class_loader_data(class_loader);
1792   Dictionary* dictionary = loader_data-&gt;dictionary();
1793 
1794   unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
1795 
1796   // Hold SD lock around find_class and placeholder creation for DEFINE_CLASS
1797   unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
1798   int p_index = placeholders()-&gt;hash_to_index(p_hash);
1799   PlaceholderEntry* probe;
1800 
1801   {
1802     MutexLocker mu(THREAD, SystemDictionary_lock);
1803     // First check if class already defined
1804     if (is_parallelDefine(class_loader)) {
1805       InstanceKlass* check = find_class(d_hash, name_h, dictionary);
1806       if (check != NULL) {
1807         return check;
1808       }
1809     }
1810 
1811     // Acquire define token for this class/classloader
1812     probe = placeholders()-&gt;find_and_add(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, NULL, THREAD);
1813     // Wait if another thread defining in parallel
1814     // All threads wait - even those that will throw duplicate class: otherwise
1815     // caller is surprised by LinkageError: duplicate, but findLoadedClass fails
1816     // if other thread has not finished updating dictionary
1817     while (probe-&gt;definer() != NULL) {
1818       SystemDictionary_lock-&gt;wait();
1819     }
1820     // Only special cases allow parallel defines and can use other thread&#39;s results
1821     // Other cases fall through, and may run into duplicate defines
1822     // caught by finding an entry in the SystemDictionary
1823     if (is_parallelDefine(class_loader) &amp;&amp; (probe-&gt;instance_klass() != NULL)) {
1824         placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1825         SystemDictionary_lock-&gt;notify_all();
1826 #ifdef ASSERT
1827         InstanceKlass* check = find_class(d_hash, name_h, dictionary);
1828         assert(check != NULL, &quot;definer missed recording success&quot;);
1829 #endif
1830         return probe-&gt;instance_klass();
1831     } else {
1832       // This thread will define the class (even if earlier thread tried and had an error)
1833       probe-&gt;set_definer(THREAD);
1834     }
1835   }
1836 
1837   define_instance_class(k, THREAD);
1838 
1839   Handle linkage_exception = Handle(); // null handle
1840 
1841   // definer must notify any waiting threads
1842   {
1843     MutexLocker mu(THREAD, SystemDictionary_lock);
1844     PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, name_h, loader_data);
1845     assert(probe != NULL, &quot;DEFINE_CLASS placeholder lost?&quot;);
1846     if (probe != NULL) {
1847       if (HAS_PENDING_EXCEPTION) {
1848         linkage_exception = Handle(THREAD,PENDING_EXCEPTION);
1849         CLEAR_PENDING_EXCEPTION;
1850       } else {
1851         probe-&gt;set_instance_klass(k);
1852       }
1853       probe-&gt;set_definer(NULL);
1854       placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1855       SystemDictionary_lock-&gt;notify_all();
1856     }
1857   }
1858 
1859   // Can&#39;t throw exception while holding lock due to rank ordering
1860   if (linkage_exception() != NULL) {
1861     THROW_OOP_(linkage_exception(), NULL); // throws exception and returns
1862   }
1863 
1864   return k;
1865 }
1866 
1867 Handle SystemDictionary::compute_loader_lock_object(Handle class_loader, TRAPS) {
1868   // If class_loader is NULL we synchronize on _system_loader_lock_obj
1869   if (class_loader.is_null()) {
1870     return Handle(THREAD, _system_loader_lock_obj);
1871   } else {
1872     return class_loader;
1873   }
1874 }
1875 
1876 // This method is added to check how often we have to wait to grab loader
1877 // lock. The results are being recorded in the performance counters defined in
1878 // ClassLoader::_sync_systemLoaderLockContentionRate and
1879 // ClassLoader::_sync_nonSystemLoaderLockConteionRate.
1880 void SystemDictionary::check_loader_lock_contention(Handle loader_lock, TRAPS) {
1881   if (!UsePerfData) {
1882     return;
1883   }
1884 
1885   assert(!loader_lock.is_null(), &quot;NULL lock object&quot;);
1886 
1887   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader_lock)
1888       == ObjectSynchronizer::owner_other) {
1889     // contention will likely happen, so increment the corresponding
1890     // contention counter.
1891     if (loader_lock() == _system_loader_lock_obj) {
1892       ClassLoader::sync_systemLoaderLockContentionRate()-&gt;inc();
1893     } else {
1894       ClassLoader::sync_nonSystemLoaderLockContentionRate()-&gt;inc();
1895     }
1896   }
1897 }
1898 
1899 // ----------------------------------------------------------------------------
1900 // Lookup
1901 
1902 InstanceKlass* SystemDictionary::find_class(unsigned int hash,
1903                                             Symbol* class_name,
1904                                             Dictionary* dictionary) {
1905   assert_locked_or_safepoint(SystemDictionary_lock);
1906   int index = dictionary-&gt;hash_to_index(hash);
1907   return dictionary-&gt;find_class(index, hash, class_name);
1908 }
1909 
1910 
1911 // Basic find on classes in the midst of being loaded
1912 Symbol* SystemDictionary::find_placeholder(Symbol* class_name,
1913                                            ClassLoaderData* loader_data) {
1914   assert_locked_or_safepoint(SystemDictionary_lock);
1915   unsigned int p_hash = placeholders()-&gt;compute_hash(class_name);
1916   int p_index = placeholders()-&gt;hash_to_index(p_hash);
1917   return placeholders()-&gt;find_entry(p_index, p_hash, class_name, loader_data);
1918 }
1919 
1920 
1921 // Used for assertions and verification only
1922 // Precalculating the hash and index is an optimization because there are many lookups
1923 // before adding the class.
1924 InstanceKlass* SystemDictionary::find_class(Symbol* class_name, ClassLoaderData* loader_data) {
1925   assert_locked_or_safepoint(SystemDictionary_lock);
1926   #ifndef ASSERT
1927   guarantee(VerifyBeforeGC      ||
1928             VerifyDuringGC      ||
1929             VerifyBeforeExit    ||
1930             VerifyDuringStartup ||
1931             VerifyAfterGC, &quot;too expensive&quot;);
1932   #endif
1933 
1934   Dictionary* dictionary = loader_data-&gt;dictionary();
1935   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
1936   return find_class(d_hash, class_name, dictionary);
1937 }
1938 
1939 
1940 // ----------------------------------------------------------------------------
1941 // Update hierachy. This is done before the new klass has been added to the SystemDictionary. The Recompile_lock
1942 // is held, to ensure that the compiler is not using the class hierachy, and that deoptimization will kick in
1943 // before a new class is used.
1944 
1945 void SystemDictionary::add_to_hierarchy(InstanceKlass* k, TRAPS) {
1946   assert(k != NULL, &quot;just checking&quot;);
1947   if (Universe::is_fully_initialized()) {
1948     assert_locked_or_safepoint(Compile_lock);
1949   }
1950 
1951   k-&gt;set_init_state(InstanceKlass::loaded);
1952   // make sure init_state store is already done.
1953   // The compiler reads the hierarchy outside of the Compile_lock.
1954   // Access ordering is used to add to hierarchy.
1955 
1956   // Link into hierachy.
1957   k-&gt;append_to_sibling_list();                    // add to superklass/sibling list
1958   k-&gt;process_interfaces(THREAD);                  // handle all &quot;implements&quot; declarations
1959 
1960   // Now flush all code that depended on old class hierarchy.
1961   // Note: must be done *after* linking k into the hierarchy (was bug 12/9/97)
1962   if (Universe::is_fully_initialized()) {
1963     CodeCache::flush_dependents_on(k);
1964   }
1965 }
1966 
1967 // ----------------------------------------------------------------------------
1968 // GC support
1969 
1970 // Assumes classes in the SystemDictionary are only unloaded at a safepoint
1971 // Note: anonymous classes are not in the SD.
1972 bool SystemDictionary::do_unloading(GCTimer* gc_timer) {
1973 
1974   bool unloading_occurred;
1975   bool is_concurrent = !SafepointSynchronize::is_at_safepoint();
1976   {
1977     GCTraceTime(Debug, gc, phases) t(&quot;ClassLoaderData&quot;, gc_timer);
1978     assert_locked_or_safepoint(ClassLoaderDataGraph_lock);  // caller locks.
1979     // First, mark for unload all ClassLoaderData referencing a dead class loader.
1980     unloading_occurred = ClassLoaderDataGraph::do_unloading();
1981     if (unloading_occurred) {
1982       MutexLocker ml2(is_concurrent ? Module_lock : NULL);
1983       JFR_ONLY(Jfr::on_unloading_classes();)
1984 
1985       MutexLocker ml1(is_concurrent ? SystemDictionary_lock : NULL);
1986       ClassLoaderDataGraph::clean_module_and_package_info();
1987       constraints()-&gt;purge_loader_constraints();
1988       resolution_errors()-&gt;purge_resolution_errors();
1989     }
1990   }
1991 
1992   GCTraceTime(Debug, gc, phases) t(&quot;Trigger cleanups&quot;, gc_timer);
1993 
1994   if (unloading_occurred) {
1995     SymbolTable::trigger_cleanup();
1996 
1997     // Oops referenced by the protection domain cache table may get unreachable independently
1998     // of the class loader (eg. cached protection domain oops). So we need to
1999     // explicitly unlink them here.
2000     // All protection domain oops are linked to the caller class, so if nothing
2001     // unloads, this is not needed.
2002     _pd_cache_table-&gt;trigger_cleanup();
2003   }
2004 
2005   return unloading_occurred;
2006 }
2007 
2008 void SystemDictionary::oops_do(OopClosure* f, bool include_handles) {
2009   f-&gt;do_oop(&amp;_java_system_loader);
2010   f-&gt;do_oop(&amp;_java_platform_loader);
2011   f-&gt;do_oop(&amp;_system_loader_lock_obj);
2012   CDS_ONLY(SystemDictionaryShared::oops_do(f);)
2013 
2014   // Visit extra methods
2015   invoke_method_table()-&gt;oops_do(f);
2016 
2017   if (include_handles) {
2018     OopStorageSet::vm_global()-&gt;oops_do(f);
2019   }
2020 }
2021 
2022 // CDS: scan and relocate all classes referenced by _well_known_klasses[].
2023 void SystemDictionary::well_known_klasses_do(MetaspaceClosure* it) {
2024   for (int id = FIRST_WKID; id &lt; WKID_LIMIT; id++) {
2025     it-&gt;push(well_known_klass_addr((WKID)id));
2026   }
2027 }
2028 
2029 void SystemDictionary::methods_do(void f(Method*)) {
2030   // Walk methods in loaded classes
2031   MutexLocker ml(ClassLoaderDataGraph_lock);
2032   ClassLoaderDataGraph::methods_do(f);
2033   // Walk method handle intrinsics
2034   invoke_method_table()-&gt;methods_do(f);
2035 }
2036 
2037 // ----------------------------------------------------------------------------
2038 // Initialization
2039 
2040 void SystemDictionary::initialize(TRAPS) {
2041   // Allocate arrays
2042   _placeholders        = new PlaceholderTable(_placeholder_table_size);
2043   _loader_constraints  = new LoaderConstraintTable(_loader_constraint_size);
2044   _resolution_errors   = new ResolutionErrorTable(_resolution_error_size);
2045   _invoke_method_table = new SymbolPropertyTable(_invoke_method_size);
2046   _pd_cache_table = new ProtectionDomainCacheTable(defaultProtectionDomainCacheSize);
2047 
2048   // Allocate private object used as system class loader lock
2049   _system_loader_lock_obj = oopFactory::new_intArray(0, CHECK);
2050   // Initialize basic classes
2051   resolve_well_known_classes(CHECK);
2052 }
2053 
2054 // Compact table of directions on the initialization of klasses:
2055 static const short wk_init_info[] = {
2056   #define WK_KLASS_INIT_INFO(name, symbol) \
2057     ((short)vmSymbols::VM_SYMBOL_ENUM_NAME(symbol)),
2058 
2059   WK_KLASSES_DO(WK_KLASS_INIT_INFO)
2060   #undef WK_KLASS_INIT_INFO
2061   0
2062 };
2063 
2064 #ifdef ASSERT
2065 bool SystemDictionary::is_well_known_klass(Symbol* class_name) {
2066   int sid;
2067   for (int i = 0; (sid = wk_init_info[i]) != 0; i++) {
2068     Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
2069     if (class_name == symbol) {
2070       return true;
2071     }
2072   }
2073   return false;
2074 }
2075 #endif
2076 
2077 bool SystemDictionary::resolve_wk_klass(WKID id, TRAPS) {
2078   assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
2079   int sid = wk_init_info[id - FIRST_WKID];
2080   Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
2081   InstanceKlass** klassp = &amp;_well_known_klasses[id];
2082 
2083 #if INCLUDE_CDS
2084   if (UseSharedSpaces &amp;&amp; !JvmtiExport::should_post_class_prepare()) {
2085     InstanceKlass* k = *klassp;
2086     assert(k-&gt;is_shared_boot_class(), &quot;must be&quot;);
2087 
2088     ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
2089     quick_resolve(k, loader_data, Handle(), CHECK_false);
2090     return true;
2091   }
2092 #endif // INCLUDE_CDS
2093 
2094   if (!is_wk_klass_loaded(*klassp)) {
2095     Klass* k = resolve_or_fail(symbol, true, CHECK_false);
2096     (*klassp) = InstanceKlass::cast(k);
2097   }
2098   return ((*klassp) != NULL);
2099 }
2100 
2101 void SystemDictionary::resolve_wk_klasses_until(WKID limit_id, WKID &amp;start_id, TRAPS) {
2102   assert((int)start_id &lt;= (int)limit_id, &quot;IDs are out of order!&quot;);
2103   for (int id = (int)start_id; id &lt; (int)limit_id; id++) {
2104     assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
2105     resolve_wk_klass((WKID)id, CHECK);
2106   }
2107 
2108   // move the starting value forward to the limit:
2109   start_id = limit_id;
2110 }
2111 
2112 void SystemDictionary::resolve_well_known_classes(TRAPS) {
2113   assert(!Object_klass_loaded(), &quot;well-known classes should only be initialized once&quot;);
2114 
2115   // Create the ModuleEntry for java.base.  This call needs to be done here,
2116   // after vmSymbols::initialize() is called but before any classes are pre-loaded.
2117   ClassLoader::classLoader_init2(CHECK);
2118 
2119   // Preload commonly used klasses
2120   WKID scan = FIRST_WKID;
2121   // first do Object, then String, Class
2122 #if INCLUDE_CDS
2123   if (UseSharedSpaces) {
2124     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Object_klass), scan, CHECK);
2125 
2126     // It&#39;s unsafe to access the archived heap regions before they
2127     // are fixed up, so we must do the fixup as early as possible
2128     // before the archived java objects are accessed by functions
2129     // such as java_lang_Class::restore_archived_mirror and
2130     // ConstantPool::restore_unshareable_info (restores the archived
2131     // resolved_references array object).
2132     //
2133     // HeapShared::fixup_mapped_heap_regions() fills the empty
2134     // spaces in the archived heap regions and may use
2135     // SystemDictionary::Object_klass(), so we can do this only after
2136     // Object_klass is resolved. See the above resolve_wk_klasses_through()
2137     // call. No mirror objects are accessed/restored in the above call.
2138     // Mirrors are restored after java.lang.Class is loaded.
2139     HeapShared::fixup_mapped_heap_regions();
2140 
2141     // Initialize the constant pool for the Object_class
2142     assert(Object_klass()-&gt;is_shared(), &quot;must be&quot;);
2143     Object_klass()-&gt;constants()-&gt;restore_unshareable_info(CHECK);
2144     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
2145   } else
2146 #endif
2147   {
2148     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
2149   }
2150 
2151   assert(WK_KLASS(Object_klass) != NULL, &quot;well-known classes should now be initialized&quot;);
2152 
2153   java_lang_Object::register_natives(CHECK);
2154 
2155   // Calculate offsets for String and Class classes since they are loaded and
2156   // can be used after this point.
2157   java_lang_String::compute_offsets();
2158   java_lang_Class::compute_offsets();
2159 
2160   // Fixup mirrors for classes loaded before java.lang.Class.
2161   Universe::initialize_basic_type_mirrors(CHECK);
2162   Universe::fixup_mirrors(CHECK);
2163 
2164   // do a bunch more:
2165   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Reference_klass), scan, CHECK);
2166 
2167   // The offsets for jlr.Reference must be computed before
2168   // InstanceRefKlass::update_nonstatic_oop_maps is called. That function uses
2169   // the offsets to remove the referent and discovered fields from the oop maps,
2170   // as they are treated in a special way by the GC. Removing these oops from the
2171   // oop maps must be done before the usual subclasses of jlr.Reference are loaded.
2172   java_lang_ref_Reference::compute_offsets();
2173 
2174   // Preload ref klasses and set reference types
2175   WK_KLASS(Reference_klass)-&gt;set_reference_type(REF_OTHER);
2176   InstanceRefKlass::update_nonstatic_oop_maps(WK_KLASS(Reference_klass));
2177 
2178   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(PhantomReference_klass), scan, CHECK);
2179   WK_KLASS(SoftReference_klass)-&gt;set_reference_type(REF_SOFT);
2180   WK_KLASS(WeakReference_klass)-&gt;set_reference_type(REF_WEAK);
2181   WK_KLASS(FinalReference_klass)-&gt;set_reference_type(REF_FINAL);
2182   WK_KLASS(PhantomReference_klass)-&gt;set_reference_type(REF_PHANTOM);
2183 
2184   // JSR 292 classes
2185   WKID jsr292_group_start = WK_KLASS_ENUM_NAME(MethodHandle_klass);
2186   WKID jsr292_group_end   = WK_KLASS_ENUM_NAME(VolatileCallSite_klass);
2187   resolve_wk_klasses_until(jsr292_group_start, scan, CHECK);
2188   resolve_wk_klasses_through(jsr292_group_end, scan, CHECK);
2189   WKID last = WKID_LIMIT;
2190   resolve_wk_klasses_until(last, scan, CHECK);
2191 
2192   _box_klasses[T_BOOLEAN] = WK_KLASS(Boolean_klass);
2193   _box_klasses[T_CHAR]    = WK_KLASS(Character_klass);
2194   _box_klasses[T_FLOAT]   = WK_KLASS(Float_klass);
2195   _box_klasses[T_DOUBLE]  = WK_KLASS(Double_klass);
2196   _box_klasses[T_BYTE]    = WK_KLASS(Byte_klass);
2197   _box_klasses[T_SHORT]   = WK_KLASS(Short_klass);
2198   _box_klasses[T_INT]     = WK_KLASS(Integer_klass);
2199   _box_klasses[T_LONG]    = WK_KLASS(Long_klass);
2200   //_box_klasses[T_OBJECT]  = WK_KLASS(object_klass);
2201   //_box_klasses[T_ARRAY]   = WK_KLASS(object_klass);
2202 
2203 #ifdef ASSERT
2204   if (UseSharedSpaces) {
2205     JVMTI_ONLY(assert(JvmtiExport::is_early_phase(),
2206                       &quot;All well known classes must be resolved in JVMTI early phase&quot;));
2207     for (int i = FIRST_WKID; i &lt; last; i++) {
2208       InstanceKlass* k = _well_known_klasses[i];
2209       assert(k-&gt;is_shared(), &quot;must not be replaced by JVMTI class file load hook&quot;);
2210     }
2211   }
2212 #endif
2213 }
2214 
2215 // Tells if a given klass is a box (wrapper class, such as java.lang.Integer).
2216 // If so, returns the basic type it holds.  If not, returns T_OBJECT.
2217 BasicType SystemDictionary::box_klass_type(Klass* k) {
2218   assert(k != NULL, &quot;&quot;);
2219   for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
2220     if (_box_klasses[i] == k)
2221       return (BasicType)i;
2222   }
2223   return T_OBJECT;
2224 }
2225 
2226 // Constraints on class loaders. The details of the algorithm can be
2227 // found in the OOPSLA&#39;98 paper &quot;Dynamic Class Loading in the Java
2228 // Virtual Machine&quot; by Sheng Liang and Gilad Bracha.  The basic idea is
2229 // that the dictionary needs to maintain a set of contraints that
2230 // must be satisfied by all classes in the dictionary.
2231 // if defining is true, then LinkageError if already in dictionary
2232 // if initiating loader, then ok if InstanceKlass matches existing entry
2233 
2234 void SystemDictionary::check_constraints(unsigned int d_hash,
2235                                          InstanceKlass* k,
2236                                          Handle class_loader,
2237                                          bool defining,
2238                                          TRAPS) {
2239   ResourceMark rm(THREAD);
2240   stringStream ss;
2241   bool throwException = false;
2242 
2243   {
2244     Symbol *name = k-&gt;name();
2245     ClassLoaderData *loader_data = class_loader_data(class_loader);
2246 
2247     MutexLocker mu(THREAD, SystemDictionary_lock);
2248 
2249     InstanceKlass* check = find_class(d_hash, name, loader_data-&gt;dictionary());
2250     if (check != NULL) {
2251       // If different InstanceKlass - duplicate class definition,
2252       // else - ok, class loaded by a different thread in parallel.
2253       // We should only have found it if it was done loading and ok to use.
2254       // The dictionary only holds instance classes, placeholders
2255       // also hold array classes.
2256 
2257       assert(check-&gt;is_instance_klass(), &quot;noninstance in systemdictionary&quot;);
2258       if ((defining == true) || (k != check)) {
2259         throwException = true;
2260         ss.print(&quot;loader %s&quot;, loader_data-&gt;loader_name_and_id());
2261         ss.print(&quot; attempted duplicate %s definition for %s. (%s)&quot;,
2262                  k-&gt;external_kind(), k-&gt;external_name(), k-&gt;class_in_module_of_loader(false, true));
2263       } else {
2264         return;
2265       }
2266     }
2267 
2268 #ifdef ASSERT
2269     Symbol* ph_check = find_placeholder(name, loader_data);
2270     assert(ph_check == NULL || ph_check == name, &quot;invalid symbol&quot;);
2271 #endif
2272 
2273     if (throwException == false) {
2274       if (constraints()-&gt;check_or_update(k, class_loader, name) == false) {
2275         throwException = true;
2276         ss.print(&quot;loader constraint violation: loader %s&quot;, loader_data-&gt;loader_name_and_id());
2277         ss.print(&quot; wants to load %s %s.&quot;,
2278                  k-&gt;external_kind(), k-&gt;external_name());
2279         Klass *existing_klass = constraints()-&gt;find_constrained_klass(name, class_loader);
2280         if (existing_klass != NULL &amp;&amp; existing_klass-&gt;class_loader() != class_loader()) {
2281           ss.print(&quot; A different %s with the same name was previously loaded by %s. (%s)&quot;,
2282                    existing_klass-&gt;external_kind(),
2283                    existing_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
2284                    existing_klass-&gt;class_in_module_of_loader(false, true));
2285         } else {
2286           ss.print(&quot; (%s)&quot;, k-&gt;class_in_module_of_loader(false, true));
2287         }
2288       }
2289     }
2290   }
2291 
2292   // Throw error now if needed (cannot throw while holding
2293   // SystemDictionary_lock because of rank ordering)
2294   if (throwException == true) {
2295     THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
2296   }
2297 }
2298 
2299 // Update class loader data dictionary - done after check_constraint and add_to_hierachy
2300 // have been called.
2301 void SystemDictionary::update_dictionary(unsigned int d_hash,
2302                                          int p_index, unsigned int p_hash,
2303                                          InstanceKlass* k,
2304                                          Handle class_loader,
2305                                          TRAPS) {
2306   // Compile_lock prevents systemDictionary updates during compilations
2307   assert_locked_or_safepoint(Compile_lock);
2308   Symbol*  name  = k-&gt;name();
2309   ClassLoaderData *loader_data = class_loader_data(class_loader);
2310 
2311   {
2312     MutexLocker mu1(THREAD, SystemDictionary_lock);
2313 
2314     // Make a new dictionary entry.
2315     Dictionary* dictionary = loader_data-&gt;dictionary();
2316     InstanceKlass* sd_check = find_class(d_hash, name, dictionary);
2317     if (sd_check == NULL) {
2318       dictionary-&gt;add_klass(d_hash, name, k);
2319     }
2320   #ifdef ASSERT
2321     sd_check = find_class(d_hash, name, dictionary);
2322     assert (sd_check != NULL, &quot;should have entry in dictionary&quot;);
2323     // Note: there may be a placeholder entry: for circularity testing
2324     // or for parallel defines
2325   #endif
2326     SystemDictionary_lock-&gt;notify_all();
2327   }
2328 }
2329 
2330 
2331 // Try to find a class name using the loader constraints.  The
2332 // loader constraints might know about a class that isn&#39;t fully loaded
2333 // yet and these will be ignored.
2334 Klass* SystemDictionary::find_constrained_instance_or_array_klass(
2335                     Symbol* class_name, Handle class_loader, TRAPS) {
2336 
2337   // First see if it has been loaded directly.
2338   // Force the protection domain to be null.  (This removes protection checks.)
2339   Handle no_protection_domain;
2340   Klass* klass = find_instance_or_array_klass(class_name, class_loader,
2341                                               no_protection_domain, CHECK_NULL);
2342   if (klass != NULL)
2343     return klass;
2344 
2345   // Now look to see if it has been loaded elsewhere, and is subject to
2346   // a loader constraint that would require this loader to return the
2347   // klass that is already loaded.
2348   if (Signature::is_array(class_name)) {
2349     // For array classes, their Klass*s are not kept in the
2350     // constraint table. The element Klass*s are.
2351     SignatureStream ss(class_name, false);
2352     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
2353     BasicType t = ss.type();
2354     if (t != T_OBJECT &amp;&amp; t != T_VALUETYPE) {
2355       klass = Universe::typeArrayKlassObj(t);
2356     } else {
2357       MutexLocker mu(THREAD, SystemDictionary_lock);
2358       klass = constraints()-&gt;find_constrained_klass(ss.as_symbol(), class_loader);
2359     }
2360     // If element class already loaded, allocate array klass
2361     if (klass != NULL) {
2362       klass = klass-&gt;array_klass_or_null(ndims);
2363     }
2364   } else {
2365     MutexLocker mu(THREAD, SystemDictionary_lock);
2366     // Non-array classes are easy: simply check the constraint table.
2367     klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
2368   }
2369 
2370   return klass;
2371 }
2372 
2373 bool SystemDictionary::add_loader_constraint(Symbol* class_name,
2374                                              Klass* klass_being_linked,
2375                                              Handle class_loader1,
2376                                              Handle class_loader2,
2377                                              Thread* THREAD) {
2378   ClassLoaderData* loader_data1 = class_loader_data(class_loader1);
2379   ClassLoaderData* loader_data2 = class_loader_data(class_loader2);
2380 
2381   Symbol* constraint_name = NULL;
2382 
2383   if (!Signature::is_array(class_name)) {
2384     constraint_name = class_name;
2385   } else {
2386     // For array classes, their Klass*s are not kept in the
2387     // constraint table. The element classes are.
2388     SignatureStream ss(class_name, false);
2389     ss.skip_array_prefix();  // skip all &#39;[&#39;s
2390     if (!ss.has_envelope()) {
2391       return true;     // primitive types always pass
2392     }
2393     constraint_name = ss.as_symbol();
2394     // Increment refcount to keep constraint_name alive after
2395     // SignatureStream is destructed. It will be decremented below
2396     // before returning.
2397     constraint_name-&gt;increment_refcount();
2398   }
2399 
2400   Dictionary* dictionary1 = loader_data1-&gt;dictionary();
2401   unsigned int d_hash1 = dictionary1-&gt;compute_hash(constraint_name);
2402 
2403   Dictionary* dictionary2 = loader_data2-&gt;dictionary();
2404   unsigned int d_hash2 = dictionary2-&gt;compute_hash(constraint_name);
2405 
2406   {
2407     MutexLocker mu_s(THREAD, SystemDictionary_lock);
2408     InstanceKlass* klass1 = find_class(d_hash1, constraint_name, dictionary1);
2409     InstanceKlass* klass2 = find_class(d_hash2, constraint_name, dictionary2);
2410     bool result = constraints()-&gt;add_entry(constraint_name, klass1, class_loader1,
2411                                            klass2, class_loader2);
2412 #if INCLUDE_CDS
2413     if (Arguments::is_dumping_archive() &amp;&amp; klass_being_linked != NULL &amp;&amp;
2414         !klass_being_linked-&gt;is_shared()) {
2415          SystemDictionaryShared::record_linking_constraint(constraint_name,
2416                                      InstanceKlass::cast(klass_being_linked),
2417                                      class_loader1, class_loader2, THREAD);
2418     }
2419 #endif // INCLUDE_CDS
2420     if (Signature::is_array(class_name)) {
2421       constraint_name-&gt;decrement_refcount();
2422     }
2423     return result;
2424   }
2425 }
2426 
2427 // Add entry to resolution error table to record the error when the first
2428 // attempt to resolve a reference to a class has failed.
2429 void SystemDictionary::add_resolution_error(const constantPoolHandle&amp; pool, int which,
2430                                             Symbol* error, Symbol* message) {
2431   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2432   int index = resolution_errors()-&gt;hash_to_index(hash);
2433   {
2434     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2435     resolution_errors()-&gt;add_entry(index, hash, pool, which, error, message);
2436   }
2437 }
2438 
2439 // Delete a resolution error for RedefineClasses for a constant pool is going away
2440 void SystemDictionary::delete_resolution_error(ConstantPool* pool) {
2441   resolution_errors()-&gt;delete_entry(pool);
2442 }
2443 
2444 // Lookup resolution error table. Returns error if found, otherwise NULL.
2445 Symbol* SystemDictionary::find_resolution_error(const constantPoolHandle&amp; pool, int which,
2446                                                 Symbol** message) {
2447   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2448   int index = resolution_errors()-&gt;hash_to_index(hash);
2449   {
2450     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2451     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2452     if (entry != NULL) {
2453       *message = entry-&gt;message();
2454       return entry-&gt;error();
2455     } else {
2456       return NULL;
2457     }
2458   }
2459 }
2460 
2461 // Add an entry to resolution error table to record an error in resolving or
2462 // validating a nest host. This is used to construct informative error
2463 // messages when IllegalAccessError&#39;s occur. If an entry already exists it will
2464 // be updated with the nest host error message.
2465 void SystemDictionary::add_nest_host_error(const constantPoolHandle&amp; pool,
2466                                            int which,
2467                                            const char* message) {
2468   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2469   int index = resolution_errors()-&gt;hash_to_index(hash);
2470   {
2471     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2472     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2473     if (entry != NULL) {
2474       assert(entry-&gt;nest_host_error() == NULL, &quot;Nest host error message already set!&quot;);
2475       entry-&gt;set_nest_host_error(message);
2476     } else {
2477       resolution_errors()-&gt;add_entry(index, hash, pool, which, message);
2478     }
2479   }
2480 }
2481 
2482 // Lookup any nest host error
2483 const char* SystemDictionary::find_nest_host_error(const constantPoolHandle&amp; pool, int which) {
2484   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2485   int index = resolution_errors()-&gt;hash_to_index(hash);
2486   {
2487     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2488     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2489     if (entry != NULL) {
2490       return entry-&gt;nest_host_error();
2491     } else {
2492       return NULL;
2493     }
2494   }
2495 }
2496 
2497 
2498 // Signature constraints ensure that callers and callees agree about
2499 // the meaning of type names in their signatures.  This routine is the
2500 // intake for constraints.  It collects them from several places:
2501 //
2502 //  * LinkResolver::resolve_method (if check_access is true) requires
2503 //    that the resolving class (the caller) and the defining class of
2504 //    the resolved method (the callee) agree on each type in the
2505 //    method&#39;s signature.
2506 //
2507 //  * LinkResolver::resolve_interface_method performs exactly the same
2508 //    checks.
2509 //
2510 //  * LinkResolver::resolve_field requires that the constant pool
2511 //    attempting to link to a field agree with the field&#39;s defining
2512 //    class about the type of the field signature.
2513 //
2514 //  * klassVtable::initialize_vtable requires that, when a class
2515 //    overrides a vtable entry allocated by a superclass, that the
2516 //    overriding method (i.e., the callee) agree with the superclass
2517 //    on each type in the method&#39;s signature.
2518 //
2519 //  * klassItable::initialize_itable requires that, when a class fills
2520 //    in its itables, for each non-abstract method installed in an
2521 //    itable, the method (i.e., the callee) agree with the interface
2522 //    on each type in the method&#39;s signature.
2523 //
2524 // All those methods have a boolean (check_access, checkconstraints)
2525 // which turns off the checks.  This is used from specialized contexts
2526 // such as bootstrapping, dumping, and debugging.
2527 //
2528 // No direct constraint is placed between the class and its
2529 // supertypes.  Constraints are only placed along linked relations
2530 // between callers and callees.  When a method overrides or implements
2531 // an abstract method in a supertype (superclass or interface), the
2532 // constraints are placed as if the supertype were the caller to the
2533 // overriding method.  (This works well, since callers to the
2534 // supertype have already established agreement between themselves and
2535 // the supertype.)  As a result of all this, a class can disagree with
2536 // its supertype about the meaning of a type name, as long as that
2537 // class neither calls a relevant method of the supertype, nor is
2538 // called (perhaps via an override) from the supertype.
2539 //
2540 //
2541 // SystemDictionary::check_signature_loaders(sig, klass_being_linked, l1, l2)
2542 //
2543 // Make sure all class components (including arrays) in the given
2544 // signature will be resolved to the same class in both loaders.
2545 // Returns the name of the type that failed a loader constraint check, or
2546 // NULL if no constraint failed.  No exception except OOME is thrown.
2547 // Arrays are not added to the loader constraint table, their elements are.
2548 Symbol* SystemDictionary::check_signature_loaders(Symbol* signature,
2549                                                Klass* klass_being_linked,
2550                                                Handle loader1, Handle loader2,
2551                                                bool is_method, TRAPS)  {
2552   // Nothing to do if loaders are the same.
2553   if (loader1() == loader2()) {
2554     return NULL;
2555   }
2556 
2557   for (SignatureStream ss(signature, is_method); !ss.is_done(); ss.next()) {
2558     if (ss.is_reference()) {
2559       Symbol* sig = ss.as_symbol();
2560       // Note: In the future, if template-like types can take
2561       // arguments, we will want to recognize them and dig out class
2562       // names hiding inside the argument lists.
2563       if (!add_loader_constraint(sig, klass_being_linked, loader1, loader2, THREAD)) {
2564         return sig;
2565       }
2566     }
2567   }
2568   return NULL;
2569 }
2570 
2571 Method* SystemDictionary::find_method_handle_intrinsic(vmIntrinsics::ID iid,
2572                                                        Symbol* signature,
2573                                                        TRAPS) {
2574   methodHandle empty;
2575   assert(MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
2576          MethodHandles::is_signature_polymorphic_intrinsic(iid) &amp;&amp;
2577          iid != vmIntrinsics::_invokeGeneric,
2578          &quot;must be a known MH intrinsic iid=%d: %s&quot;, iid, vmIntrinsics::name_at(iid));
2579 
2580   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, iid);
2581   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2582   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2583   methodHandle m;
2584   if (spe == NULL || spe-&gt;method() == NULL) {
2585     spe = NULL;
2586     // Must create lots of stuff here, but outside of the SystemDictionary lock.
2587     m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);
2588     if (!Arguments::is_interpreter_only()) {
2589       // Generate a compiled form of the MH intrinsic.
2590       AdapterHandlerLibrary::create_native_wrapper(m);
2591       // Check if have the compiled code.
2592       if (!m-&gt;has_compiled_code()) {
2593         THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),
2594                        &quot;Out of space in CodeCache for method handle intrinsic&quot;);
2595       }
2596     }
2597     // Now grab the lock.  We might have to throw away the new method,
2598     // if a racing thread has managed to install one at the same time.
2599     {
2600       MutexLocker ml(THREAD, SystemDictionary_lock);
2601       spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2602       if (spe == NULL)
2603         spe = invoke_method_table()-&gt;add_entry(index, hash, signature, iid);
2604       if (spe-&gt;method() == NULL)
2605         spe-&gt;set_method(m());
2606     }
2607   }
2608 
2609   assert(spe != NULL &amp;&amp; spe-&gt;method() != NULL, &quot;&quot;);
2610   assert(Arguments::is_interpreter_only() || (spe-&gt;method()-&gt;has_compiled_code() &amp;&amp;
2611          spe-&gt;method()-&gt;code()-&gt;entry_point() == spe-&gt;method()-&gt;from_compiled_entry()),
2612          &quot;MH intrinsic invariant&quot;);
2613   return spe-&gt;method();
2614 }
2615 
2616 // Helper for unpacking the return value from linkMethod and linkCallSite.
2617 static Method* unpack_method_and_appendix(Handle mname,
2618                                           Klass* accessing_klass,
2619                                           objArrayHandle appendix_box,
2620                                           Handle* appendix_result,
2621                                           TRAPS) {
2622   if (mname.not_null()) {
2623     Method* m = java_lang_invoke_MemberName::vmtarget(mname());
2624     if (m != NULL) {
2625       oop appendix = appendix_box-&gt;obj_at(0);
2626       LogTarget(Info, methodhandles) lt;
2627       if (lt.develop_is_enabled()) {
2628         ResourceMark rm(THREAD);
2629         LogStream ls(lt);
2630         ls.print(&quot;Linked method=&quot; INTPTR_FORMAT &quot;: &quot;, p2i(m));
2631         m-&gt;print_on(&amp;ls);
2632         if (appendix != NULL) { ls.print(&quot;appendix = &quot;); appendix-&gt;print_on(&amp;ls); }
2633         ls.cr();
2634       }
2635 
2636       (*appendix_result) = Handle(THREAD, appendix);
2637       // the target is stored in the cpCache and if a reference to this
2638       // MemberName is dropped we need a way to make sure the
2639       // class_loader containing this method is kept alive.
2640       methodHandle mh(THREAD, m); // record_dependency can safepoint.
2641       ClassLoaderData* this_key = accessing_klass-&gt;class_loader_data();
2642       this_key-&gt;record_dependency(m-&gt;method_holder());
2643       return mh();
2644     }
2645   }
2646   THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;bad value from MethodHandleNatives&quot;);
2647 }
2648 
2649 Method* SystemDictionary::find_method_handle_invoker(Klass* klass,
2650                                                      Symbol* name,
2651                                                      Symbol* signature,
2652                                                           Klass* accessing_klass,
2653                                                           Handle *appendix_result,
2654                                                           TRAPS) {
2655   assert(THREAD-&gt;can_call_java() ,&quot;&quot;);
2656   Handle method_type =
2657     SystemDictionary::find_method_handle_type(signature, accessing_klass, CHECK_NULL);
2658 
2659   int ref_kind = JVM_REF_invokeVirtual;
2660   oop name_oop = StringTable::intern(name, CHECK_NULL);
2661   Handle name_str (THREAD, name_oop);
2662   objArrayHandle appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK_NULL);
2663   assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
2664 
2665   // This should not happen.  JDK code should take care of that.
2666   if (accessing_klass == NULL || method_type.is_null()) {
2667     THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;bad invokehandle&quot;);
2668   }
2669 
2670   // call java.lang.invoke.MethodHandleNatives::linkMethod(... String, MethodType) -&gt; MemberName
2671   JavaCallArguments args;
2672   args.push_oop(Handle(THREAD, accessing_klass-&gt;java_mirror()));
2673   args.push_int(ref_kind);
2674   args.push_oop(Handle(THREAD, klass-&gt;java_mirror()));
2675   args.push_oop(name_str);
2676   args.push_oop(method_type);
2677   args.push_oop(appendix_box);
2678   JavaValue result(T_OBJECT);
2679   JavaCalls::call_static(&amp;result,
2680                          SystemDictionary::MethodHandleNatives_klass(),
2681                          vmSymbols::linkMethod_name(),
2682                          vmSymbols::linkMethod_signature(),
2683                          &amp;args, CHECK_NULL);
2684   Handle mname(THREAD, (oop) result.get_jobject());
2685   return unpack_method_and_appendix(mname, accessing_klass, appendix_box, appendix_result, THREAD);
2686 }
2687 
2688 // Decide if we can globally cache a lookup of this class, to be returned to any client that asks.
2689 // We must ensure that all class loaders everywhere will reach this class, for any client.
2690 // This is a safe bet for public classes in java.lang, such as Object and String.
2691 // We also include public classes in java.lang.invoke, because they appear frequently in system-level method types.
2692 // Out of an abundance of caution, we do not include any other classes, not even for packages like java.util.
2693 static bool is_always_visible_class(oop mirror) {
2694   Klass* klass = java_lang_Class::as_Klass(mirror);
2695   if (klass-&gt;is_objArray_klass()) {
2696     klass = ObjArrayKlass::cast(klass)-&gt;bottom_klass(); // check element type
2697   }
2698   if (klass-&gt;is_typeArray_klass()) {
2699     return true; // primitive array
2700   }
2701   assert(klass-&gt;is_instance_klass(), &quot;%s&quot;, klass-&gt;external_name());
2702   return klass-&gt;is_public() &amp;&amp;
2703          (InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::Object_klass()) ||       // java.lang
2704           InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::MethodHandle_klass()));  // java.lang.invoke
2705 }
2706 
2707 // Find or construct the Java mirror (java.lang.Class instance) for
2708 // the given field type signature, as interpreted relative to the
2709 // given class loader.  Handles primitives, void, references, arrays,
2710 // and all other reflectable types, except method types.
2711 // N.B.  Code in reflection should use this entry point.
2712 Handle SystemDictionary::find_java_mirror_for_type(Symbol* signature,
2713                                                    Klass* accessing_klass,
2714                                                    Handle class_loader,
2715                                                    Handle protection_domain,
2716                                                    SignatureStream::FailureMode failure_mode,
2717                                                    TRAPS) {
2718   assert(accessing_klass == NULL || (class_loader.is_null() &amp;&amp; protection_domain.is_null()),
2719          &quot;one or the other, or perhaps neither&quot;);
2720 
2721   // What we have here must be a valid field descriptor,
2722   // and all valid field descriptors are supported.
2723   // Produce the same java.lang.Class that reflection reports.
2724   if (accessing_klass != NULL) {
2725     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2726     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2727   }
2728   ResolvingSignatureStream ss(signature, class_loader, protection_domain, false);
2729   oop mirror_oop = ss.as_java_mirror(failure_mode, CHECK_NH);
2730   if (mirror_oop == NULL) {
2731     return Handle();  // report failure this way
2732   }
2733   Handle mirror(THREAD, mirror_oop);
2734 
2735   if (accessing_klass != NULL) {
2736     // Check accessibility, emulating ConstantPool::verify_constant_pool_resolve.
2737     Klass* sel_klass = java_lang_Class::as_Klass(mirror());
2738     if (sel_klass != NULL) {
2739       LinkResolver::check_klass_accessibility(accessing_klass, sel_klass, CHECK_NH);
2740     }
2741   }
2742   return mirror;
2743 }
2744 
2745 
2746 // Ask Java code to find or construct a java.lang.invoke.MethodType for the given
2747 // signature, as interpreted relative to the given class loader.
2748 // Because of class loader constraints, all method handle usage must be
2749 // consistent with this loader.
2750 Handle SystemDictionary::find_method_handle_type(Symbol* signature,
2751                                                  Klass* accessing_klass,
2752                                                  TRAPS) {
2753   Handle empty;
2754   vmIntrinsics::ID null_iid = vmIntrinsics::_none;  // distinct from all method handle invoker intrinsics
2755   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, null_iid);
2756   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2757   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2758   if (spe != NULL &amp;&amp; spe-&gt;method_type() != NULL) {
2759     assert(java_lang_invoke_MethodType::is_instance(spe-&gt;method_type()), &quot;&quot;);
2760     return Handle(THREAD, spe-&gt;method_type());
2761   } else if (!THREAD-&gt;can_call_java()) {
2762     warning(&quot;SystemDictionary::find_method_handle_type called from compiler thread&quot;);  // FIXME
2763     return Handle();  // do not attempt from within compiler, unless it was cached
2764   }
2765 
2766   Handle class_loader, protection_domain;
2767   if (accessing_klass != NULL) {
2768     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2769     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2770   }
2771   bool can_be_cached = true;
2772   int npts = ArgumentCount(signature).size();
2773   objArrayHandle pts = oopFactory::new_objArray_handle(SystemDictionary::Class_klass(), npts, CHECK_(empty));
2774   int arg = 0;
2775   Handle rt; // the return type from the signature
2776   ResourceMark rm(THREAD);
2777   for (SignatureStream ss(signature); !ss.is_done(); ss.next()) {
2778     oop mirror = NULL;
2779     if (can_be_cached) {
2780       // Use neutral class loader to lookup candidate classes to be placed in the cache.
2781       mirror = ss.as_java_mirror(Handle(), Handle(),
2782                                  SignatureStream::ReturnNull, CHECK_(empty));
2783       if (mirror == NULL || (ss.is_reference() &amp;&amp; !is_always_visible_class(mirror))) {
2784         // Fall back to accessing_klass context.
2785         can_be_cached = false;
2786       }
2787     }
2788     if (!can_be_cached) {
2789       // Resolve, throwing a real error if it doesn&#39;t work.
2790       mirror = ss.as_java_mirror(class_loader, protection_domain,
2791                                  SignatureStream::NCDFError, CHECK_(empty));
2792     }
2793     assert(mirror != NULL, &quot;%s&quot;, ss.as_symbol()-&gt;as_C_string());
2794     if (ss.at_return_type())
2795       rt = Handle(THREAD, mirror);
2796     else
2797       pts-&gt;obj_at_put(arg++, mirror);
2798 
2799     // Check accessibility.
2800     if (!java_lang_Class::is_primitive(mirror) &amp;&amp; accessing_klass != NULL) {
2801       Klass* sel_klass = java_lang_Class::as_Klass(mirror);
2802       mirror = NULL;  // safety
2803       // Emulate ConstantPool::verify_constant_pool_resolve.
2804       LinkResolver::check_klass_accessibility(accessing_klass, sel_klass, CHECK_(empty));
2805     }
2806   }
2807   assert(arg == npts, &quot;&quot;);
2808 
2809   // call java.lang.invoke.MethodHandleNatives::findMethodHandleType(Class rt, Class[] pts) -&gt; MethodType
2810   JavaCallArguments args(Handle(THREAD, rt()));
2811   args.push_oop(pts);
2812   JavaValue result(T_OBJECT);
2813   JavaCalls::call_static(&amp;result,
2814                          SystemDictionary::MethodHandleNatives_klass(),
2815                          vmSymbols::findMethodHandleType_name(),
2816                          vmSymbols::findMethodHandleType_signature(),
2817                          &amp;args, CHECK_(empty));
2818   Handle method_type(THREAD, (oop) result.get_jobject());
2819 
2820   if (can_be_cached) {
2821     // We can cache this MethodType inside the JVM.
2822     MutexLocker ml(THREAD, SystemDictionary_lock);
2823     spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2824     if (spe == NULL)
2825       spe = invoke_method_table()-&gt;add_entry(index, hash, signature, null_iid);
2826     if (spe-&gt;method_type() == NULL) {
2827       spe-&gt;set_method_type(method_type());
2828     }
2829   }
2830 
2831   // report back to the caller with the MethodType
2832   return method_type;
2833 }
2834 
2835 Handle SystemDictionary::find_field_handle_type(Symbol* signature,
2836                                                 Klass* accessing_klass,
2837                                                 TRAPS) {
2838   Handle empty;
2839   ResourceMark rm(THREAD);
2840   SignatureStream ss(signature, /*is_method=*/ false);
2841   if (!ss.is_done()) {
2842     Handle class_loader, protection_domain;
2843     if (accessing_klass != NULL) {
2844       class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2845       protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2846     }
2847     oop mirror = ss.as_java_mirror(class_loader, protection_domain, SignatureStream::NCDFError, CHECK_(empty));
2848     ss.next();
2849     if (ss.is_done()) {
2850       return Handle(THREAD, mirror);
2851     }
2852   }
2853   return empty;
2854 }
2855 
2856 // Ask Java code to find or construct a method handle constant.
2857 Handle SystemDictionary::link_method_handle_constant(Klass* caller,
2858                                                      int ref_kind, //e.g., JVM_REF_invokeVirtual
2859                                                      Klass* callee,
2860                                                      Symbol* name,
2861                                                      Symbol* signature,
2862                                                      TRAPS) {
2863   Handle empty;
2864   if (caller == NULL) {
2865     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;bad MH constant&quot;, empty);
2866   }
2867   Handle name_str      = java_lang_String::create_from_symbol(name,      CHECK_(empty));
2868   Handle signature_str = java_lang_String::create_from_symbol(signature, CHECK_(empty));
2869 
2870   // Put symbolic info from the MH constant into freshly created MemberName and resolve it.
2871   Handle mname = MemberName_klass()-&gt;allocate_instance_handle(CHECK_(empty));
2872   java_lang_invoke_MemberName::set_clazz(mname(), callee-&gt;java_mirror());
2873   java_lang_invoke_MemberName::set_name (mname(), name_str());
2874   java_lang_invoke_MemberName::set_type (mname(), signature_str());
2875   java_lang_invoke_MemberName::set_flags(mname(), MethodHandles::ref_kind_to_flags(ref_kind));
2876 
2877   if (ref_kind == JVM_REF_invokeVirtual &amp;&amp;
2878       MethodHandles::is_signature_polymorphic_public_name(callee, name)) {
2879     // Skip resolution for public signature polymorphic methods such as
2880     // j.l.i.MethodHandle.invoke()/invokeExact() and those on VarHandle
2881     // They require appendix argument which MemberName resolution doesn&#39;t handle.
2882     // There&#39;s special logic on JDK side to handle them
2883     // (see MethodHandles.linkMethodHandleConstant() and MethodHandles.findVirtualForMH()).
2884   } else {
2885     MethodHandles::resolve_MemberName(mname, caller, /*speculative_resolve*/false, CHECK_(empty));
2886   }
2887 
2888   // After method/field resolution succeeded, it&#39;s safe to resolve MH signature as well.
2889   Handle type = MethodHandles::resolve_MemberName_type(mname, caller, CHECK_(empty));
2890 
2891   // call java.lang.invoke.MethodHandleNatives::linkMethodHandleConstant(Class caller, int refKind, Class callee, String name, Object type) -&gt; MethodHandle
2892   JavaCallArguments args;
2893   args.push_oop(Handle(THREAD, caller-&gt;java_mirror()));  // the referring class
2894   args.push_int(ref_kind);
2895   args.push_oop(Handle(THREAD, callee-&gt;java_mirror()));  // the target class
2896   args.push_oop(name_str);
2897   args.push_oop(type);
2898   JavaValue result(T_OBJECT);
2899   JavaCalls::call_static(&amp;result,
2900                          SystemDictionary::MethodHandleNatives_klass(),
2901                          vmSymbols::linkMethodHandleConstant_name(),
2902                          vmSymbols::linkMethodHandleConstant_signature(),
2903                          &amp;args, CHECK_(empty));
2904   return Handle(THREAD, (oop) result.get_jobject());
2905 }
2906 
2907 // Ask Java to run a bootstrap method, in order to create a dynamic call site
2908 // while linking an invokedynamic op, or compute a constant for Dynamic_info CP entry
2909 // with linkage results being stored back into the bootstrap specifier.
2910 void SystemDictionary::invoke_bootstrap_method(BootstrapInfo&amp; bootstrap_specifier, TRAPS) {
2911   // Resolve the bootstrap specifier, its name, type, and static arguments
2912   bootstrap_specifier.resolve_bsm(CHECK);
2913 
2914   // This should not happen.  JDK code should take care of that.
2915   if (bootstrap_specifier.caller() == NULL || bootstrap_specifier.type_arg().is_null()) {
2916     THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;Invalid bootstrap method invocation with no caller or type argument&quot;);
2917   }
2918 
2919   bool is_indy = bootstrap_specifier.is_method_call();
2920   objArrayHandle appendix_box;
2921   if (is_indy) {
2922     // Some method calls may require an appendix argument.  Arrange to receive it.
2923     appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK);
2924     assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
2925   }
2926 
2927   // call condy: java.lang.invoke.MethodHandleNatives::linkDynamicConstant(caller, condy_index, bsm, type, info)
2928   //       indy: java.lang.invoke.MethodHandleNatives::linkCallSite(caller, indy_index, bsm, name, mtype, info, &amp;appendix)
2929   JavaCallArguments args;
2930   args.push_oop(Handle(THREAD, bootstrap_specifier.caller_mirror()));
2931   args.push_int(bootstrap_specifier.bss_index());
2932   args.push_oop(bootstrap_specifier.bsm());
2933   args.push_oop(bootstrap_specifier.name_arg());
2934   args.push_oop(bootstrap_specifier.type_arg());
2935   args.push_oop(bootstrap_specifier.arg_values());
2936   if (is_indy) {
2937     args.push_oop(appendix_box);
2938   }
2939   JavaValue result(T_OBJECT);
2940   JavaCalls::call_static(&amp;result,
2941                          SystemDictionary::MethodHandleNatives_klass(),
2942                          is_indy ? vmSymbols::linkCallSite_name() : vmSymbols::linkDynamicConstant_name(),
2943                          is_indy ? vmSymbols::linkCallSite_signature() : vmSymbols::linkDynamicConstant_signature(),
2944                          &amp;args, CHECK);
2945 
2946   Handle value(THREAD, (oop) result.get_jobject());
2947   if (is_indy) {
2948     Handle appendix;
2949     Method* method = unpack_method_and_appendix(value,
2950                                                 bootstrap_specifier.caller(),
2951                                                 appendix_box,
2952                                                 &amp;appendix, CHECK);
2953     methodHandle mh(THREAD, method);
2954     bootstrap_specifier.set_resolved_method(mh, appendix);
2955   } else {
2956     bootstrap_specifier.set_resolved_value(value);
2957   }
2958 
2959   // sanity check
2960   assert(bootstrap_specifier.is_resolved() ||
2961          (bootstrap_specifier.is_method_call() &amp;&amp;
2962           bootstrap_specifier.resolved_method().not_null()), &quot;bootstrap method call failed&quot;);
2963 }
2964 
2965 // Protection domain cache table handling
2966 
2967 ProtectionDomainCacheEntry* SystemDictionary::cache_get(Handle protection_domain) {
2968   return _pd_cache_table-&gt;get(protection_domain);
2969 }
2970 
2971 // ----------------------------------------------------------------------------
2972 
2973 void SystemDictionary::print_on(outputStream *st) {
2974   CDS_ONLY(SystemDictionaryShared::print_on(st));
2975   GCMutexLocker mu(SystemDictionary_lock);
2976 
2977   ClassLoaderDataGraph::print_dictionary(st);
2978 
2979   // Placeholders
2980   placeholders()-&gt;print_on(st);
2981   st-&gt;cr();
2982 
2983   // loader constraints - print under SD_lock
2984   constraints()-&gt;print_on(st);
2985   st-&gt;cr();
2986 
2987   _pd_cache_table-&gt;print_on(st);
2988   st-&gt;cr();
2989 }
2990 
2991 void SystemDictionary::print() { print_on(tty); }
2992 
2993 void SystemDictionary::verify() {
2994   guarantee(constraints() != NULL,
2995             &quot;Verify of loader constraints failed&quot;);
2996   guarantee(placeholders()-&gt;number_of_entries() &gt;= 0,
2997             &quot;Verify of placeholders failed&quot;);
2998 
2999   GCMutexLocker mu(SystemDictionary_lock);
3000 
3001   // Verify dictionary
3002   ClassLoaderDataGraph::verify_dictionary();
3003 
3004   placeholders()-&gt;verify();
3005 
3006   // Verify constraint table
3007   guarantee(constraints() != NULL, &quot;Verify of loader constraints failed&quot;);
3008   constraints()-&gt;verify(placeholders());
3009 
3010   _pd_cache_table-&gt;verify();
3011 }
3012 
3013 void SystemDictionary::dump(outputStream *st, bool verbose) {
3014   assert_locked_or_safepoint(SystemDictionary_lock);
3015   if (verbose) {
3016     print_on(st);
3017   } else {
3018     CDS_ONLY(SystemDictionaryShared::print_table_statistics(st));
3019     ClassLoaderDataGraph::print_table_statistics(st);
3020     placeholders()-&gt;print_table_statistics(st, &quot;Placeholder Table&quot;);
3021     constraints()-&gt;print_table_statistics(st, &quot;LoaderConstraints Table&quot;);
3022     pd_cache_table()-&gt;print_table_statistics(st, &quot;ProtectionDomainCache Table&quot;);
3023   }
3024 }
3025 
3026 TableStatistics SystemDictionary::placeholders_statistics() {
3027   MutexLocker ml(SystemDictionary_lock);
3028   return placeholders()-&gt;statistics_calculate();
3029 }
3030 
3031 TableStatistics SystemDictionary::loader_constraints_statistics() {
3032   MutexLocker ml(SystemDictionary_lock);
3033   return constraints()-&gt;statistics_calculate();
3034 }
3035 
3036 TableStatistics SystemDictionary::protection_domain_cache_statistics() {
3037   MutexLocker ml(SystemDictionary_lock);
3038   return pd_cache_table()-&gt;statistics_calculate();
3039 }
3040 
3041 // Utility for dumping dictionaries.
3042 SystemDictionaryDCmd::SystemDictionaryDCmd(outputStream* output, bool heap) :
3043                                  DCmdWithParser(output, heap),
3044   _verbose(&quot;-verbose&quot;, &quot;Dump the content of each dictionary entry for all class loaders&quot;,
3045            &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
3046   _dcmdparser.add_dcmd_option(&amp;_verbose);
3047 }
3048 
3049 void SystemDictionaryDCmd::execute(DCmdSource source, TRAPS) {
3050   VM_DumpHashtable dumper(output(), VM_DumpHashtable::DumpSysDict,
3051                          _verbose.value());
3052   VMThread::execute(&amp;dumper);
3053 }
3054 
3055 int SystemDictionaryDCmd::num_arguments() {
3056   ResourceMark rm;
3057   SystemDictionaryDCmd* dcmd = new SystemDictionaryDCmd(NULL, false);
3058   if (dcmd != NULL) {
3059     DCmdMark mark(dcmd);
3060     return dcmd-&gt;_dcmdparser.num_arguments();
3061   } else {
3062     return 0;
3063   }
3064 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldLayoutBuilder.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 59 
 60   OopMapBlocksBuilder(unsigned int  max_blocks);
 61   OopMapBlock* last_oop_map() const;
 62   void initialize_inherited_blocks(OopMapBlock* blocks, unsigned int nof_blocks);
 63   void add(int offset, int count);
 64   void copy(OopMapBlock* dst);
 65   void compact();
 66   void print_on(outputStream* st) const;
 67   void print_value_on(outputStream* st) const;
 68 };
 69 
 70 // Values needed for oopmap and InstanceKlass creation
 71 class FieldLayoutInfo : public ResourceObj {
 72  public:
 73   OopMapBlocksBuilder* oop_map_blocks;
 74   int _instance_size;
 75   int _nonstatic_field_size;
 76   int _static_field_size;
 77   bool  _has_nonstatic_fields;
 78   bool  _is_naturally_atomic;

 79 };
 80 
 81 // Parser for for .class files
 82 //
 83 // The bytes describing the class file structure is read from a Stream object
 84 
 85 class ClassFileParser {
 86   friend class FieldLayoutBuilder;
 87   friend class FieldLayout;
 88 
 89   class ClassAnnotationCollector;
 90   class FieldAllocationCount;
 91   class FieldAnnotationCollector;
 92 
 93  public:
 94   // The ClassFileParser has an associated &quot;publicity&quot; level
 95   // It is used to control which subsystems (if any)
 96   // will observe the parsing (logging, events, tracing).
 97   // Default level is &quot;BROADCAST&quot;, which is equivalent to
 98   // a &quot;public&quot; parsing attempt.
</pre>
<hr />
<pre>
185   int _sde_length;
186   const char* _sde_buffer;
187   u2 _sourcefile_index;
188   u2 _generic_signature_index;
189 
190   u2 _major_version;
191   u2 _minor_version;
192   u2 _this_class_index;
193   u2 _super_class_index;
194   u2 _itfs_len;
195   u2 _java_fields_count;
196 
197   bool _need_verify;
198   bool _relax_verify;
199 
200   bool _has_nonstatic_concrete_methods;
201   bool _declares_nonstatic_concrete_methods;
202   bool _has_final_method;
203   bool _has_contended_fields;
204 
<span class="line-modified">205   bool _has_flattenable_fields;</span>
206   bool _has_nonstatic_fields;
207   bool _is_empty_inline_type;
208   bool _is_naturally_atomic;
209   bool _is_declared_atomic;
210   bool _invalid_inline_super;   // if true, invalid super type for an inline type.
211   bool _invalid_identity_super; // if true, invalid super type for an identity type.
212   bool _implements_identityObject;
213   bool _has_injected_identityObject;
214 
215   // precomputed flags
216   bool _has_finalizer;
217   bool _has_empty_finalizer;
218   bool _has_vanilla_constructor;
219   int _max_bootstrap_specifier_index;  // detects BSS values
220 
221   void parse_stream(const ClassFileStream* const stream, TRAPS);
222 
223   void mangle_hidden_class_name(InstanceKlass* const ik);
224 
225   void post_process_parsed_stream(const ClassFileStream* const stream,
</pre>
<hr />
<pre>
582   InstanceKlass* create_instance_klass(bool cf_changed_in_CFLH, const ClassInstanceInfo&amp; cl_inst_info, TRAPS);
583 
584   const ClassFileStream* clone_stream() const;
585 
586   void set_klass_to_deallocate(InstanceKlass* klass);
587 
588   int static_field_size() const;
589   int total_oop_map_count() const;
590   jint layout_size() const;
591 
592   int vtable_size() const { return _vtable_size; }
593   int itable_size() const { return _itable_size; }
594 
595   u2 this_class_index() const { return _this_class_index; }
596 
597   bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }
598   bool is_hidden() const { return _is_hidden; }
599   bool is_interface() const { return _access_flags.is_interface(); }
600   bool is_inline_type() const { return _access_flags.is_inline_type(); }
601   bool is_value_capable_class() const;
<span class="line-modified">602   bool has_flattenable_fields() const { return _has_flattenable_fields; }</span>
603   bool invalid_inline_super() const { return _invalid_inline_super; }
604   void set_invalid_inline_super() { _invalid_inline_super = true; }
605   bool invalid_identity_super() const { return _invalid_identity_super; }
606   void set_invalid_identity_super() { _invalid_identity_super = true; }
607   bool is_invalid_super_for_inline_type();
608 
609   u2 java_fields_count() const { return _java_fields_count; }
610 
611   const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }
612   const GrowableArray&lt;Handle&gt;* cp_patches() const { return _cp_patches; }
613   ClassLoaderData* loader_data() const { return _loader_data; }
614   const Symbol* class_name() const { return _class_name; }
615   const InstanceKlass* super_klass() const { return _super_klass; }
616 
617   ReferenceType reference_type() const { return _rt; }
618   AccessFlags access_flags() const { return _access_flags; }
619 
620   bool is_internal() const { return INTERNAL == _pub_level; }
621 
622   static bool verify_unqualified_name(const char* name, unsigned int length, int type);
</pre>
</td>
<td>
<hr />
<pre>
 59 
 60   OopMapBlocksBuilder(unsigned int  max_blocks);
 61   OopMapBlock* last_oop_map() const;
 62   void initialize_inherited_blocks(OopMapBlock* blocks, unsigned int nof_blocks);
 63   void add(int offset, int count);
 64   void copy(OopMapBlock* dst);
 65   void compact();
 66   void print_on(outputStream* st) const;
 67   void print_value_on(outputStream* st) const;
 68 };
 69 
 70 // Values needed for oopmap and InstanceKlass creation
 71 class FieldLayoutInfo : public ResourceObj {
 72  public:
 73   OopMapBlocksBuilder* oop_map_blocks;
 74   int _instance_size;
 75   int _nonstatic_field_size;
 76   int _static_field_size;
 77   bool  _has_nonstatic_fields;
 78   bool  _is_naturally_atomic;
<span class="line-added"> 79   bool _has_inline_fields;</span>
 80 };
 81 
 82 // Parser for for .class files
 83 //
 84 // The bytes describing the class file structure is read from a Stream object
 85 
 86 class ClassFileParser {
 87   friend class FieldLayoutBuilder;
 88   friend class FieldLayout;
 89 
 90   class ClassAnnotationCollector;
 91   class FieldAllocationCount;
 92   class FieldAnnotationCollector;
 93 
 94  public:
 95   // The ClassFileParser has an associated &quot;publicity&quot; level
 96   // It is used to control which subsystems (if any)
 97   // will observe the parsing (logging, events, tracing).
 98   // Default level is &quot;BROADCAST&quot;, which is equivalent to
 99   // a &quot;public&quot; parsing attempt.
</pre>
<hr />
<pre>
186   int _sde_length;
187   const char* _sde_buffer;
188   u2 _sourcefile_index;
189   u2 _generic_signature_index;
190 
191   u2 _major_version;
192   u2 _minor_version;
193   u2 _this_class_index;
194   u2 _super_class_index;
195   u2 _itfs_len;
196   u2 _java_fields_count;
197 
198   bool _need_verify;
199   bool _relax_verify;
200 
201   bool _has_nonstatic_concrete_methods;
202   bool _declares_nonstatic_concrete_methods;
203   bool _has_final_method;
204   bool _has_contended_fields;
205 
<span class="line-modified">206   bool _has_inline_fields;</span>
207   bool _has_nonstatic_fields;
208   bool _is_empty_inline_type;
209   bool _is_naturally_atomic;
210   bool _is_declared_atomic;
211   bool _invalid_inline_super;   // if true, invalid super type for an inline type.
212   bool _invalid_identity_super; // if true, invalid super type for an identity type.
213   bool _implements_identityObject;
214   bool _has_injected_identityObject;
215 
216   // precomputed flags
217   bool _has_finalizer;
218   bool _has_empty_finalizer;
219   bool _has_vanilla_constructor;
220   int _max_bootstrap_specifier_index;  // detects BSS values
221 
222   void parse_stream(const ClassFileStream* const stream, TRAPS);
223 
224   void mangle_hidden_class_name(InstanceKlass* const ik);
225 
226   void post_process_parsed_stream(const ClassFileStream* const stream,
</pre>
<hr />
<pre>
583   InstanceKlass* create_instance_klass(bool cf_changed_in_CFLH, const ClassInstanceInfo&amp; cl_inst_info, TRAPS);
584 
585   const ClassFileStream* clone_stream() const;
586 
587   void set_klass_to_deallocate(InstanceKlass* klass);
588 
589   int static_field_size() const;
590   int total_oop_map_count() const;
591   jint layout_size() const;
592 
593   int vtable_size() const { return _vtable_size; }
594   int itable_size() const { return _itable_size; }
595 
596   u2 this_class_index() const { return _this_class_index; }
597 
598   bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }
599   bool is_hidden() const { return _is_hidden; }
600   bool is_interface() const { return _access_flags.is_interface(); }
601   bool is_inline_type() const { return _access_flags.is_inline_type(); }
602   bool is_value_capable_class() const;
<span class="line-modified">603   bool has_inline_fields() const { return _has_inline_fields; }</span>
604   bool invalid_inline_super() const { return _invalid_inline_super; }
605   void set_invalid_inline_super() { _invalid_inline_super = true; }
606   bool invalid_identity_super() const { return _invalid_identity_super; }
607   void set_invalid_identity_super() { _invalid_identity_super = true; }
608   bool is_invalid_super_for_inline_type();
609 
610   u2 java_fields_count() const { return _java_fields_count; }
611 
612   const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }
613   const GrowableArray&lt;Handle&gt;* cp_patches() const { return _cp_patches; }
614   ClassLoaderData* loader_data() const { return _loader_data; }
615   const Symbol* class_name() const { return _class_name; }
616   const InstanceKlass* super_klass() const { return _super_klass; }
617 
618   ReferenceType reference_type() const { return _rt; }
619   AccessFlags access_flags() const { return _access_flags; }
620 
621   bool is_internal() const { return INTERNAL == _pub_level; }
622 
623   static bool verify_unqualified_name(const char* name, unsigned int length, int type);
</pre>
</td>
</tr>
</table>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldLayoutBuilder.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
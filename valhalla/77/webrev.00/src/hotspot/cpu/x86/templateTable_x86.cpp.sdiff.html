<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/templateTable_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/ci/ciField.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/templateTable_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
3051     // use btos rewriting, no truncating to t/f bit is needed for getfield.
3052     patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);
3053   }
3054   __ jmp(Done);
3055 
3056   __ bind(notBool);
3057   __ cmpl(flags, atos);
3058   __ jcc(Assembler::notEqual, notObj);
3059   // atos
3060   if (!EnableValhalla) {
3061     if (!is_static) pop_and_check_object(obj);
3062     do_oop_load(_masm, field, rax);
3063     __ push(atos);
3064     if (!is_static &amp;&amp; rc == may_rewrite) {
3065       patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);
3066     }
3067     __ jmp(Done);
3068   } else {
3069     if (is_static) {
3070       __ load_heap_oop(rax, field);
<span class="line-modified">3071       Label isFlattenable, uninitialized;</span>
3072       // Issue below if the static field has not been initialized yet
<span class="line-modified">3073       __ test_field_is_flattenable(flags2, rscratch1, isFlattenable);</span>
<span class="line-modified">3074         // Not flattenable case</span>
3075         __ push(atos);
3076         __ jmp(Done);
<span class="line-modified">3077       // Flattenable case, must not return null even if uninitialized</span>
<span class="line-modified">3078       __ bind(isFlattenable);</span>
3079         __ testptr(rax, rax);
3080         __ jcc(Assembler::zero, uninitialized);
3081           __ push(atos);
3082           __ jmp(Done);
3083         __ bind(uninitialized);
3084           __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);
3085 #ifdef _LP64
3086           Label slow_case, finish;
3087           __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
3088           __ jcc(Assembler::notEqual, slow_case);
3089         __ get_default_value_oop(rcx, off, rax);
3090         __ jmp(finish);
3091         __ bind(slow_case);
3092 #endif // LP64
3093           __ call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_value_field),
3094                  obj, flags2);
3095 #ifdef _LP64
3096           __ bind(finish);
3097 #endif // _LP64
3098           __ verify_oop(rax);
3099           __ push(atos);
3100           __ jmp(Done);
3101     } else {
<span class="line-modified">3102       Label isFlattened, nonnull, isFlattenable, rewriteFlattenable;</span>
<span class="line-modified">3103       __ test_field_is_flattenable(flags2, rscratch1, isFlattenable);</span>
<span class="line-modified">3104         // Non-flattenable field case, also covers the object case</span>
3105         pop_and_check_object(obj);
3106         __ load_heap_oop(rax, field);
3107         __ push(atos);
3108         if (rc == may_rewrite) {
3109           patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);
3110         }
3111         __ jmp(Done);
<span class="line-modified">3112       __ bind(isFlattenable);</span>
3113         __ test_field_is_flattened(flags2, rscratch1, isFlattened);
3114           // Non-flattened field case
3115           __ movptr(rax, rcx);  // small dance required to preserve the klass_holder somewhere
3116           pop_and_check_object(obj);
3117           __ push(rax);
3118           __ load_heap_oop(rax, field);
3119           __ pop(rcx);
3120           __ testptr(rax, rax);
3121           __ jcc(Assembler::notZero, nonnull);
3122             __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);
3123             __ get_value_field_klass(rcx, flags2, rbx);
3124             __ get_default_value_oop(rbx, rcx, rax);
3125           __ bind(nonnull);
3126           __ verify_oop(rax);
3127           __ push(atos);
<span class="line-modified">3128           __ jmp(rewriteFlattenable);</span>
3129         __ bind(isFlattened);
3130           __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);
3131           pop_and_check_object(rax);
3132           __ read_flattened_field(rcx, flags2, rbx, rax);
3133           __ verify_oop(rax);
3134           __ push(atos);
<span class="line-modified">3135       __ bind(rewriteFlattenable);</span>
3136       if (rc == may_rewrite) {
3137         patch_bytecode(Bytecodes::_fast_qgetfield, bc, rbx);
3138       }
3139       __ jmp(Done);
3140     }
3141   }
3142 
3143   __ bind(notObj);
3144 
3145   if (!is_static) pop_and_check_object(obj);
3146 
3147   __ cmpl(flags, itos);
3148   __ jcc(Assembler::notEqual, notInt);
3149   // itos
3150   __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
3151   __ push(itos);
3152   // Rewrite bytecode to be faster
3153   if (!is_static &amp;&amp; rc == may_rewrite) {
3154     patch_bytecode(Bytecodes::_fast_igetfield, bc, rbx);
3155   }
</pre>
<hr />
<pre>
3430   }
3431 
3432   __ bind(notBool);
3433   __ cmpl(flags, atos);
3434   __ jcc(Assembler::notEqual, notObj);
3435 
3436   // atos
3437   {
3438     if (!EnableValhalla) {
3439       __ pop(atos);
3440       if (!is_static) pop_and_check_object(obj);
3441       // Store into the field
3442       do_oop_store(_masm, field, rax);
3443       if (!is_static &amp;&amp; rc == may_rewrite) {
3444         patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);
3445       }
3446       __ jmp(Done);
3447     } else {
3448       __ pop(atos);
3449       if (is_static) {
<span class="line-modified">3450         Label notFlattenable, notBuffered;</span>
<span class="line-modified">3451         __ test_field_is_not_flattenable(flags2, rscratch1, notFlattenable);</span>
3452         __ null_check(rax);
<span class="line-modified">3453         __ bind(notFlattenable);</span>
3454         do_oop_store(_masm, field, rax);
3455         __ jmp(Done);
3456       } else {
<span class="line-modified">3457         Label isFlattenable, isFlattened, notBuffered, notBuffered2, rewriteNotFlattenable, rewriteFlattenable;</span>
<span class="line-modified">3458         __ test_field_is_flattenable(flags2, rscratch1, isFlattenable);</span>
<span class="line-modified">3459         // Not flattenable case, covers not flattenable values and objects</span>
3460         pop_and_check_object(obj);
3461         // Store into the field
3462         do_oop_store(_masm, field, rax);
<span class="line-modified">3463         __ bind(rewriteNotFlattenable);</span>
3464         if (rc == may_rewrite) {
3465           patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);
3466         }
3467         __ jmp(Done);
<span class="line-modified">3468         // Implementation of the flattenable semantic</span>
<span class="line-modified">3469         __ bind(isFlattenable);</span>
3470         __ null_check(rax);
3471         __ test_field_is_flattened(flags2, rscratch1, isFlattened);
3472         // Not flattened case
3473         pop_and_check_object(obj);
3474         // Store into the field
3475         do_oop_store(_masm, field, rax);
<span class="line-modified">3476         __ jmp(rewriteFlattenable);</span>
3477         __ bind(isFlattened);
3478         pop_and_check_object(obj);
3479         assert_different_registers(rax, rdx, obj, off);
3480         __ load_klass(rdx, rax, rscratch1);
3481         __ data_for_oop(rax, rax, rdx);
3482         __ addptr(obj, off);
3483         __ access_value_copy(IN_HEAP, rax, obj, rdx);
<span class="line-modified">3484         __ bind(rewriteFlattenable);</span>
3485         if (rc == may_rewrite) {
3486           patch_bytecode(Bytecodes::_fast_qputfield, bc, rbx, true, byte_no);
3487         }
3488         __ jmp(Done);
3489       }
3490     }
3491   }
3492 
3493   __ bind(notObj);
3494   __ cmpl(flags, itos);
3495   __ jcc(Assembler::notEqual, notInt);
3496 
3497   // itos
3498   {
3499     __ pop(itos);
3500     if (!is_static) pop_and_check_object(obj);
3501     __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg);
3502     if (!is_static &amp;&amp; rc == may_rewrite) {
3503       patch_bytecode(Bytecodes::_fast_iputfield, bc, rbx, true, byte_no);
3504     }
</pre>
</td>
<td>
<hr />
<pre>
3051     // use btos rewriting, no truncating to t/f bit is needed for getfield.
3052     patch_bytecode(Bytecodes::_fast_bgetfield, bc, rbx);
3053   }
3054   __ jmp(Done);
3055 
3056   __ bind(notBool);
3057   __ cmpl(flags, atos);
3058   __ jcc(Assembler::notEqual, notObj);
3059   // atos
3060   if (!EnableValhalla) {
3061     if (!is_static) pop_and_check_object(obj);
3062     do_oop_load(_masm, field, rax);
3063     __ push(atos);
3064     if (!is_static &amp;&amp; rc == may_rewrite) {
3065       patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);
3066     }
3067     __ jmp(Done);
3068   } else {
3069     if (is_static) {
3070       __ load_heap_oop(rax, field);
<span class="line-modified">3071       Label is_inline, uninitialized;</span>
3072       // Issue below if the static field has not been initialized yet
<span class="line-modified">3073       __ test_field_is_inline(flags2, rscratch1, is_inline);</span>
<span class="line-modified">3074         // Not inline case</span>
3075         __ push(atos);
3076         __ jmp(Done);
<span class="line-modified">3077       // inline case, must not return null even if uninitialized</span>
<span class="line-modified">3078       __ bind(is_inline);</span>
3079         __ testptr(rax, rax);
3080         __ jcc(Assembler::zero, uninitialized);
3081           __ push(atos);
3082           __ jmp(Done);
3083         __ bind(uninitialized);
3084           __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);
3085 #ifdef _LP64
3086           Label slow_case, finish;
3087           __ cmpb(Address(rcx, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
3088           __ jcc(Assembler::notEqual, slow_case);
3089         __ get_default_value_oop(rcx, off, rax);
3090         __ jmp(finish);
3091         __ bind(slow_case);
3092 #endif // LP64
3093           __ call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::uninitialized_static_value_field),
3094                  obj, flags2);
3095 #ifdef _LP64
3096           __ bind(finish);
3097 #endif // _LP64
3098           __ verify_oop(rax);
3099           __ push(atos);
3100           __ jmp(Done);
3101     } else {
<span class="line-modified">3102       Label isFlattened, nonnull, is_inline, rewrite_inline;</span>
<span class="line-modified">3103       __ test_field_is_inline(flags2, rscratch1, is_inline);</span>
<span class="line-modified">3104         // Non-inline field case, also covers the object case</span>
3105         pop_and_check_object(obj);
3106         __ load_heap_oop(rax, field);
3107         __ push(atos);
3108         if (rc == may_rewrite) {
3109           patch_bytecode(Bytecodes::_fast_agetfield, bc, rbx);
3110         }
3111         __ jmp(Done);
<span class="line-modified">3112       __ bind(is_inline);</span>
3113         __ test_field_is_flattened(flags2, rscratch1, isFlattened);
3114           // Non-flattened field case
3115           __ movptr(rax, rcx);  // small dance required to preserve the klass_holder somewhere
3116           pop_and_check_object(obj);
3117           __ push(rax);
3118           __ load_heap_oop(rax, field);
3119           __ pop(rcx);
3120           __ testptr(rax, rax);
3121           __ jcc(Assembler::notZero, nonnull);
3122             __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);
3123             __ get_value_field_klass(rcx, flags2, rbx);
3124             __ get_default_value_oop(rbx, rcx, rax);
3125           __ bind(nonnull);
3126           __ verify_oop(rax);
3127           __ push(atos);
<span class="line-modified">3128           __ jmp(rewrite_inline);</span>
3129         __ bind(isFlattened);
3130           __ andl(flags2, ConstantPoolCacheEntry::field_index_mask);
3131           pop_and_check_object(rax);
3132           __ read_flattened_field(rcx, flags2, rbx, rax);
3133           __ verify_oop(rax);
3134           __ push(atos);
<span class="line-modified">3135       __ bind(rewrite_inline);</span>
3136       if (rc == may_rewrite) {
3137         patch_bytecode(Bytecodes::_fast_qgetfield, bc, rbx);
3138       }
3139       __ jmp(Done);
3140     }
3141   }
3142 
3143   __ bind(notObj);
3144 
3145   if (!is_static) pop_and_check_object(obj);
3146 
3147   __ cmpl(flags, itos);
3148   __ jcc(Assembler::notEqual, notInt);
3149   // itos
3150   __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);
3151   __ push(itos);
3152   // Rewrite bytecode to be faster
3153   if (!is_static &amp;&amp; rc == may_rewrite) {
3154     patch_bytecode(Bytecodes::_fast_igetfield, bc, rbx);
3155   }
</pre>
<hr />
<pre>
3430   }
3431 
3432   __ bind(notBool);
3433   __ cmpl(flags, atos);
3434   __ jcc(Assembler::notEqual, notObj);
3435 
3436   // atos
3437   {
3438     if (!EnableValhalla) {
3439       __ pop(atos);
3440       if (!is_static) pop_and_check_object(obj);
3441       // Store into the field
3442       do_oop_store(_masm, field, rax);
3443       if (!is_static &amp;&amp; rc == may_rewrite) {
3444         patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);
3445       }
3446       __ jmp(Done);
3447     } else {
3448       __ pop(atos);
3449       if (is_static) {
<span class="line-modified">3450         Label is_inline;</span>
<span class="line-modified">3451         __ test_field_is_not_inline(flags2, rscratch1, is_inline);</span>
3452         __ null_check(rax);
<span class="line-modified">3453         __ bind(is_inline);</span>
3454         do_oop_store(_masm, field, rax);
3455         __ jmp(Done);
3456       } else {
<span class="line-modified">3457         Label is_inline, isFlattened, rewrite_not_inline, rewrite_inline;</span>
<span class="line-modified">3458         __ test_field_is_inline(flags2, rscratch1, is_inline);</span>
<span class="line-modified">3459         // Not inline case</span>
3460         pop_and_check_object(obj);
3461         // Store into the field
3462         do_oop_store(_masm, field, rax);
<span class="line-modified">3463         __ bind(rewrite_not_inline);</span>
3464         if (rc == may_rewrite) {
3465           patch_bytecode(Bytecodes::_fast_aputfield, bc, rbx, true, byte_no);
3466         }
3467         __ jmp(Done);
<span class="line-modified">3468         // Implementation of the inline semantic</span>
<span class="line-modified">3469         __ bind(is_inline);</span>
3470         __ null_check(rax);
3471         __ test_field_is_flattened(flags2, rscratch1, isFlattened);
3472         // Not flattened case
3473         pop_and_check_object(obj);
3474         // Store into the field
3475         do_oop_store(_masm, field, rax);
<span class="line-modified">3476         __ jmp(rewrite_inline);</span>
3477         __ bind(isFlattened);
3478         pop_and_check_object(obj);
3479         assert_different_registers(rax, rdx, obj, off);
3480         __ load_klass(rdx, rax, rscratch1);
3481         __ data_for_oop(rax, rax, rdx);
3482         __ addptr(obj, off);
3483         __ access_value_copy(IN_HEAP, rax, obj, rdx);
<span class="line-modified">3484         __ bind(rewrite_inline);</span>
3485         if (rc == may_rewrite) {
3486           patch_bytecode(Bytecodes::_fast_qputfield, bc, rbx, true, byte_no);
3487         }
3488         __ jmp(Done);
3489       }
3490     }
3491   }
3492 
3493   __ bind(notObj);
3494   __ cmpl(flags, itos);
3495   __ jcc(Assembler::notEqual, notInt);
3496 
3497   // itos
3498   {
3499     __ pop(itos);
3500     if (!is_static) pop_and_check_object(obj);
3501     __ access_store_at(T_INT, IN_HEAP, field, rax, noreg, noreg);
3502     if (!is_static &amp;&amp; rc == may_rewrite) {
3503       patch_bytecode(Bytecodes::_fast_iputfield, bc, rbx, true, byte_no);
3504     }
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/ci/ciField.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
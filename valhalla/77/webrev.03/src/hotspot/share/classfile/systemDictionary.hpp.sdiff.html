<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../interpreter/interpreterRuntime.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
307   static Klass* handle_resolution_exception(Symbol* class_name, bool throw_error, Klass* klass, TRAPS);
308 
309 public:
310 
311   // Returns a class with a given class name and class loader.
312   // Loads the class if needed. If not found NULL is returned.
313   static Klass* resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
314   // Version with null loader and protection domain
315   static Klass* resolve_or_null(Symbol* class_name, TRAPS);
316 
317   // Resolve a superclass or superinterface. Called from ClassFileParser,
318   // parse_interfaces, resolve_instance_class_or_null, load_shared_class
319   // &quot;child_name&quot; is the class whose super class or interface is being resolved.
320   static InstanceKlass* resolve_super_or_fail(Symbol* child_name,
321                                               Symbol* class_name,
322                                               Handle class_loader,
323                                               Handle protection_domain,
324                                               bool is_superclass,
325                                               TRAPS);
326 
<span class="line-modified">327   static Klass* resolve_flattenable_field_or_fail(AllFieldStream* fs,</span>
328                                                   Handle class_loader,
329                                                   Handle protection_domain,
330                                                   bool throw_error,
331                                                   TRAPS);
332 
333   // Parse new stream. This won&#39;t update the dictionary or class
334   // hierarchy, simply parse the stream. Used by JVMTI RedefineClasses
335   // and by Unsafe_DefineAnonymousClass and jvm_lookup_define_class.
336   static InstanceKlass* parse_stream(Symbol* class_name,
337                                      Handle class_loader,
338                                      ClassFileStream* st,
339                                      const ClassLoadInfo&amp; cl_info,
340                                      TRAPS);
341 
342   // Resolve from stream (called by jni_DefineClass and JVM_DefineClass)
343   static InstanceKlass* resolve_from_stream(Symbol* class_name,
344                                             Handle class_loader,
345                                             Handle protection_domain,
346                                             ClassFileStream* st,
347                                             TRAPS);
</pre>
</td>
<td>
<hr />
<pre>
307   static Klass* handle_resolution_exception(Symbol* class_name, bool throw_error, Klass* klass, TRAPS);
308 
309 public:
310 
311   // Returns a class with a given class name and class loader.
312   // Loads the class if needed. If not found NULL is returned.
313   static Klass* resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
314   // Version with null loader and protection domain
315   static Klass* resolve_or_null(Symbol* class_name, TRAPS);
316 
317   // Resolve a superclass or superinterface. Called from ClassFileParser,
318   // parse_interfaces, resolve_instance_class_or_null, load_shared_class
319   // &quot;child_name&quot; is the class whose super class or interface is being resolved.
320   static InstanceKlass* resolve_super_or_fail(Symbol* child_name,
321                                               Symbol* class_name,
322                                               Handle class_loader,
323                                               Handle protection_domain,
324                                               bool is_superclass,
325                                               TRAPS);
326 
<span class="line-modified">327   static Klass* resolve_inline_type_field_or_fail(AllFieldStream* fs,</span>
328                                                   Handle class_loader,
329                                                   Handle protection_domain,
330                                                   bool throw_error,
331                                                   TRAPS);
332 
333   // Parse new stream. This won&#39;t update the dictionary or class
334   // hierarchy, simply parse the stream. Used by JVMTI RedefineClasses
335   // and by Unsafe_DefineAnonymousClass and jvm_lookup_define_class.
336   static InstanceKlass* parse_stream(Symbol* class_name,
337                                      Handle class_loader,
338                                      ClassFileStream* st,
339                                      const ClassLoadInfo&amp; cl_info,
340                                      TRAPS);
341 
342   // Resolve from stream (called by jni_DefineClass and JVM_DefineClass)
343   static InstanceKlass* resolve_from_stream(Symbol* class_name,
344                                             Handle class_loader,
345                                             Handle protection_domain,
346                                             ClassFileStream* st,
347                                             TRAPS);
</pre>
</td>
</tr>
</table>
<center><a href="systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../interpreter/interpreterRuntime.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/access.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../memory/heapInspection.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cpCache.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/access.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
203     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
204     OopType new_oop_value = new_value;
205     OopType compare_oop_value = compare_value;
206     return AccessInternal::atomic_cmpxchg_at&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(base, offset, compare_oop_value, new_oop_value);
207   }
208 
209   template &lt;typename T&gt;
210   static inline T oop_atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
211     verify_heap_oop_decorators&lt;atomic_xchg_mo_decorators&gt;();
212     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
213     OopType new_oop_value = new_value;
214     return AccessInternal::atomic_xchg_at&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(base, offset, new_oop_value);
215   }
216 
217   // Clone an object from src to dst
218   static inline void clone(oop src, oop dst, size_t size) {
219     verify_decorators&lt;IN_HEAP&gt;();
220     AccessInternal::clone&lt;decorators&gt;(src, dst, size);
221   }
222 
<span class="line-modified">223   // Value type inline heap access (flattened)...</span>
224 
225   // Copy value type data from src to dst
226   static inline void value_copy(void* src, void* dst, ValueKlass* md) {
227     verify_heap_value_decorators&lt;IN_HEAP&gt;();
228     AccessInternal::value_copy&lt;decorators&gt;(src, dst, md);
229   }
230 
231   // Primitive accesses
232   template &lt;typename P&gt;
233   static inline P load(P* addr) {
234     verify_primitive_decorators&lt;load_mo_decorators&gt;();
235     return AccessInternal::load&lt;decorators, P, P&gt;(addr);
236   }
237 
238   template &lt;typename P, typename T&gt;
239   static inline void store(P* addr, T value) {
240     verify_primitive_decorators&lt;store_mo_decorators&gt;();
241     AccessInternal::store&lt;decorators&gt;(addr, value);
242   }
243 
</pre>
</td>
<td>
<hr />
<pre>
203     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
204     OopType new_oop_value = new_value;
205     OopType compare_oop_value = compare_value;
206     return AccessInternal::atomic_cmpxchg_at&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(base, offset, compare_oop_value, new_oop_value);
207   }
208 
209   template &lt;typename T&gt;
210   static inline T oop_atomic_xchg_at(oop base, ptrdiff_t offset, T new_value) {
211     verify_heap_oop_decorators&lt;atomic_xchg_mo_decorators&gt;();
212     typedef typename AccessInternal::OopOrNarrowOop&lt;T&gt;::type OopType;
213     OopType new_oop_value = new_value;
214     return AccessInternal::atomic_xchg_at&lt;decorators | INTERNAL_VALUE_IS_OOP&gt;(base, offset, new_oop_value);
215   }
216 
217   // Clone an object from src to dst
218   static inline void clone(oop src, oop dst, size_t size) {
219     verify_decorators&lt;IN_HEAP&gt;();
220     AccessInternal::clone&lt;decorators&gt;(src, dst, size);
221   }
222 
<span class="line-modified">223   // inline type heap access (when inlined)...</span>
224 
225   // Copy value type data from src to dst
226   static inline void value_copy(void* src, void* dst, ValueKlass* md) {
227     verify_heap_value_decorators&lt;IN_HEAP&gt;();
228     AccessInternal::value_copy&lt;decorators&gt;(src, dst, md);
229   }
230 
231   // Primitive accesses
232   template &lt;typename P&gt;
233   static inline P load(P* addr) {
234     verify_primitive_decorators&lt;load_mo_decorators&gt;();
235     return AccessInternal::load&lt;decorators, P, P&gt;(addr);
236   }
237 
238   template &lt;typename P, typename T&gt;
239   static inline void store(P* addr, T value) {
240     verify_primitive_decorators&lt;store_mo_decorators&gt;();
241     AccessInternal::store&lt;decorators&gt;(addr, value);
242   }
243 
</pre>
</td>
</tr>
</table>
<center><a href="../memory/heapInspection.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cpCache.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
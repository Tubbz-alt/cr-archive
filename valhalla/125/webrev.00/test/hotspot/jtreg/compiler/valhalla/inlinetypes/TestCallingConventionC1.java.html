<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/hotspot/jtreg/compiler/valhalla/inlinetypes/TestCallingConventionC1.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 package compiler.valhalla.inlinetypes;
  25 
  26 import sun.hotspot.WhiteBox;
  27 import jdk.test.lib.Asserts;
  28 
  29 /*
  30  * @test
  31  * @key randomness
  32  * @summary Test calls from {C1} to {C2, Interpreter}, and vice versa.
  33  * @library /testlibrary /test/lib /compiler/whitebox /
  34  * @requires (os.simpleArch == &quot;x64&quot; | os.simpleArch == &quot;aarch64&quot;)
  35  * @compile TestCallingConventionC1.java
  36  * @run driver ClassFileInstaller sun.hotspot.WhiteBox jdk.test.lib.Platform
  37  * @run main/othervm/timeout=300 -Xbootclasspath/a:. -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions
  38  *                               -XX:+UnlockExperimentalVMOptions -XX:+WhiteBoxAPI
  39  *                               compiler.valhalla.inlinetypes.InlineTypeTest
  40  *                               compiler.valhalla.inlinetypes.TestCallingConventionC1
  41  */
  42 public class TestCallingConventionC1 extends InlineTypeTest {
  43     public static final int C1 = COMP_LEVEL_SIMPLE;
  44     public static final int C2 = COMP_LEVEL_FULL_OPTIMIZATION;
  45 
  46     @Override
  47     public int getNumScenarios() {
  48         return 5;
  49     }
  50 
  51     @Override
  52     public String[] getVMParameters(int scenario) {
  53         switch (scenario) {
  54         case 0: return new String[] {
  55                 // Default: both C1 and C2 are enabled, tiered compilation enabled
  56                 &quot;-XX:CICompilerCount=2&quot;,
  57                 &quot;-XX:TieredStopAtLevel=4&quot;,
  58                 &quot;-XX:+TieredCompilation&quot;,
  59             };
  60         case 1: return new String[] {
  61                 // Default: both C1 and C2 are enabled, tiered compilation enabled
  62                 &quot;-XX:CICompilerCount=2&quot;,
  63                 &quot;-XX:TieredStopAtLevel=4&quot;,
  64                 &quot;-XX:+TieredCompilation&quot;,
  65                 &quot;-XX:+StressInlineTypeReturnedAsFields&quot;
  66             };
  67         case 2: return new String[] {
  68                 // Same as above, but flip all the compLevel=C1 and compLevel=C2, so we test
  69                 // the compliment of the above scenario.
  70                 &quot;-XX:CICompilerCount=2&quot;,
  71                 &quot;-XX:TieredStopAtLevel=4&quot;,
  72                 &quot;-XX:+TieredCompilation&quot;,
  73                 &quot;-DFlipC1C2=true&quot;
  74             };
  75         case 3: return new String[] {
  76                 // Only C1. Tiered compilation disabled.
  77                 &quot;-XX:TieredStopAtLevel=1&quot;,
  78                 &quot;-XX:+TieredCompilation&quot;,
  79             };
  80         case 4: return new String[] {
  81                 // Only C2.
  82                 &quot;-XX:TieredStopAtLevel=4&quot;,
  83                 &quot;-XX:-TieredCompilation&quot;,
  84             };
  85         }
  86         return null;
  87     }
  88 
  89     public static void main(String[] args) throws Throwable {
  90         System.gc(); // Resolve this call, to avoid C1 code patching in the test cases.
  91         TestCallingConventionC1 test = new TestCallingConventionC1();
  92         test.run(args,
  93                  Point.class,
  94                  Functor.class,
  95                  Functor1.class,
  96                  Functor2.class,
  97                  Functor3.class,
  98                  Functor4.class,
  99                  MyImplPojo0.class,
 100                  MyImplPojo1.class,
 101                  MyImplPojo2.class,
 102                  MyImplPojo3.class,
 103                  MyImplVal1.class,
 104                  MyImplVal2.class,
 105                  MyImplVal1X.class,
 106                  MyImplVal2X.class,
 107                  FixedPoints.class,
 108                  FloatPoint.class,
 109                  RefPoint.class,
 110                  RefPoint_Access_Impl1.class,
 111                  RefPoint_Access_Impl2.class);
 112     }
 113 
 114     static inline class Point {
 115         final int x;
 116         final int y;
 117         public Point(int x, int y) {
 118             this.x = x;
 119             this.y = y;
 120         }
 121 
 122         @DontCompile
 123         @DontInline
 124         public int func() {
 125             return x + y;
 126         }
 127 
 128         @ForceCompile(compLevel = C1)
 129         @DontInline
 130         public int func_c1(Point p) {
 131             return x + y + p.x + p.y;
 132         }
 133     }
 134 
 135     static interface FunctorInterface {
 136         public int apply_interp(Point p);
 137     }
 138 
 139     static class Functor implements FunctorInterface {
 140         @DontCompile
 141         @DontInline
 142         public int apply_interp(Point p) {
 143             return p.func() + 0;
 144         }
 145     }
 146     static class Functor1 extends Functor {
 147         @DontCompile
 148         @DontInline
 149         public int apply_interp(Point p) {
 150             return p.func() + 10000;
 151         }
 152     }
 153     static class Functor2 extends Functor {
 154         @DontCompile
 155         @DontInline
 156         public int apply_interp(Point p) {
 157             return p.func() + 20000;
 158         }
 159     }
 160     static class Functor3 extends Functor {
 161         @DontCompile
 162         @DontInline
 163         public int apply_interp(Point p) {
 164             return p.func() + 30000;
 165         }
 166     }
 167     static class Functor4 extends Functor {
 168         @DontCompile
 169         @DontInline
 170         public int apply_interp(Point p) {
 171             return p.func() + 40000;
 172         }
 173     }
 174 
 175     static Functor functors[] = {
 176         new Functor(),
 177         new Functor1(),
 178         new Functor2(),
 179         new Functor3(),
 180         new Functor4()
 181     };
 182     static int functorCounter = 0;
 183     static Functor getFunctor() {
 184         int n = (++ functorCounter) % functors.length;
 185         return functors[n];
 186     }
 187 
 188     static Point pointField  = new Point(123, 456);
 189     static Point pointField1 = new Point(1123, 1456);
 190     static Point pointField2 = new Point(2123, 2456);
 191 
 192     static interface Intf {
 193         public int func1(int a, int b);
 194         public int func2(int a, int b, Point p);
 195     }
 196 
 197     static class MyImplPojo0 implements Intf {
 198         int field = 0;
 199         @DontInline @DontCompile
 200         public int func1(int a, int b)             { return field + a + b + 1; }
 201         @DontInline @DontCompile
 202         public int func2(int a, int b, Point p)     { return field + a + b + p.x + p.y + 1; }
 203     }
 204 
 205     static class MyImplPojo1 implements Intf {
 206         int field = 1000;
 207 
 208         @DontInline @ForceCompile(compLevel = C1)
 209         public int func1(int a, int b)             { return field + a + b + 20; }
 210         @DontInline @ForceCompile(compLevel = C1)
 211         public int func2(int a, int b, Point p)    { return field + a + b + p.x + p.y + 20; }
 212     }
 213 
 214     static class MyImplPojo2 implements Intf {
 215         int field = 2000;
 216 
 217         @DontInline @ForceCompile(compLevel = C2)
 218         public int func1(int a, int b)             { return field + a + b + 20; }
 219         @DontInline @ForceCompile(compLevel = C2)
 220         public int func2(int a, int b, Point p)    { return field + a + b + p.x + p.y + 20; }
 221     }
 222 
 223     static class MyImplPojo3 implements Intf {
 224         int field = 0;
 225         @DontInline // will be compiled with counters
 226         public int func1(int a, int b)             { return field + a + b + 1; }
 227         @DontInline // will be compiled with counters
 228         public int func2(int a, int b, Point p)     { return field + a + b + p.x + p.y + 1; }
 229     }
 230 
 231     static inline class MyImplVal1 implements Intf {
 232         final int field;
 233         MyImplVal1() {
 234             field = 11000;
 235         }
 236 
 237         @DontInline @ForceCompile(compLevel = C1)
 238         public int func1(int a, int b)             { return field + a + b + 300; }
 239 
 240         @DontInline @ForceCompile(compLevel = C1)
 241         public int func2(int a, int b, Point p)    { return field + a + b + p.x + p.y + 300; }
 242     }
 243 
 244     static inline class MyImplVal2 implements Intf {
 245         final int field;
 246         MyImplVal2() {
 247             field = 12000;
 248         }
 249 
 250         @DontInline @ForceCompile(compLevel = C2)
 251         public int func1(int a, int b)             { return field + a + b + 300; }
 252 
 253         @DontInline @ForceCompile(compLevel = C2)
 254         public int func2(int a, int b, Point p)    { return field + a + b + p.x + p.y + 300; }
 255     }
 256 
 257     static inline class MyImplVal1X implements Intf {
 258         final int field;
 259         MyImplVal1X() {
 260             field = 11000;
 261         }
 262 
 263         @DontInline @DontCompile
 264         public int func1(int a, int b)             { return field + a + b + 300; }
 265 
 266         @DontInline @DontCompile
 267         public int func2(int a, int b, Point p)    { return field + a + b + p.x + p.y + 300; }
 268     }
 269 
 270     static inline class MyImplVal2X implements Intf {
 271         final int field;
 272         MyImplVal2X() {
 273             field = 12000;
 274         }
 275 
 276         @DontInline // will be compiled with counters
 277         public int func1(int a, int b)             { return field + a + b + 300; }
 278 
 279         @DontInline // will be compiled with counters
 280         public int func2(int a, int b, Point p)    { return field + a + b + p.x + p.y + 300; }
 281     }
 282 
 283     static Intf intfs[] = {
 284         new MyImplPojo0(), // methods not compiled
 285         new MyImplPojo1(), // methods compiled by C1
 286         new MyImplPojo2(), // methods compiled by C2
 287         new MyImplVal1(),  // methods compiled by C1
 288         new MyImplVal2()   // methods compiled by C2
 289     };
 290     static Intf getIntf(int i) {
 291         int n = i % intfs.length;
 292         return intfs[n];
 293     }
 294 
 295     static inline class FixedPoints {
 296         final boolean Z0 = false;
 297         final boolean Z1 = true;
 298         final byte    B  = (byte)2;
 299         final char    C  = (char)34;
 300         final short   S  = (short)456;
 301         final int     I  = 5678;
 302         final long    J  = 0x1234567800abcdefL;
 303     }
 304     static FixedPoints fixedPointsField = new FixedPoints();
 305 
 306     static inline class FloatPoint {
 307         final float x;
 308         final float y;
 309         public FloatPoint(float x, float y) {
 310             this.x = x;
 311             this.y = y;
 312         }
 313     }
 314     static inline class DoublePoint {
 315         final double x;
 316         final double y;
 317         public DoublePoint(double x, double y) {
 318             this.x = x;
 319             this.y = y;
 320         }
 321     }
 322     static FloatPoint floatPointField = new FloatPoint(123.456f, 789.012f);
 323     static DoublePoint doublePointField = new DoublePoint(123.456, 789.012);
 324 
 325     static inline class EightFloats {
 326         float f1, f2, f3, f4, f5, f6, f7, f8;
 327         public EightFloats() {
 328             f1 = 1.1f;
 329             f2 = 2.2f;
 330             f3 = 3.3f;
 331             f4 = 4.4f;
 332             f5 = 5.5f;
 333             f6 = 6.6f;
 334             f7 = 7.7f;
 335             f8 = 8.8f;
 336         }
 337     }
 338     static EightFloats eightFloatsField = new EightFloats();
 339 
 340     static class Number {
 341         int n;
 342         Number(int v) {
 343             n = v;
 344         }
 345         void set(int v) {
 346             n = v;
 347         }
 348     }
 349 
 350     static interface RefPoint_Access {
 351         public int func1(RefPoint rp2);
 352         public int func2(RefPoint rp1, RefPoint rp2, Number n1, RefPoint rp3, RefPoint rp4, Number n2);
 353     }
 354 
 355     static inline class RefPoint implements RefPoint_Access {
 356         final Number x;
 357         final Number y;
 358         public RefPoint(int x, int y) {
 359             this.x = new Number(x);
 360             this.y = new Number(y);
 361         }
 362         public RefPoint(Number x, Number y) {
 363             this.x = x;
 364             this.y = y;
 365         }
 366 
 367         @DontInline
 368         @ForceCompile(compLevel = C1)
 369         public final int final_func(RefPoint rp2) { // opt_virtual_call
 370             return this.x.n + this.y.n + rp2.x.n + rp2.y.n;
 371         }
 372 
 373         @DontInline
 374         @ForceCompile(compLevel = C1)
 375         public int func1(RefPoint rp2) {
 376             return this.x.n + this.y.n + rp2.x.n + rp2.y.n;
 377         }
 378 
 379         @DontInline
 380         @ForceCompile(compLevel = C1)
 381         public int func2(RefPoint rp1, RefPoint rp2, Number n1, RefPoint rp3, RefPoint rp4, Number n2) {
 382             return x.n + y.n +
 383                    rp1.x.n + rp1.y.n +
 384                    rp2.x.n + rp2.y.n +
 385                    n1.n +
 386                    rp3.x.n + rp3.y.n +
 387                    rp4.x.n + rp4.y.n +
 388                    n2.n;
 389         }
 390     }
 391 
 392     static class RefPoint_Access_Impl1 implements RefPoint_Access {
 393         @DontInline @DontCompile
 394         public int func1(RefPoint rp2) {
 395             return rp2.x.n + rp2.y.n + 1111111;
 396         }
 397         @DontInline
 398         @ForceCompile(compLevel = C1)
 399         public int func2(RefPoint rp1, RefPoint rp2, Number n1, RefPoint rp3, RefPoint rp4, Number n2) {
 400             return 111111 +
 401                    rp1.x.n + rp1.y.n +
 402                    rp2.x.n + rp2.y.n +
 403                    n1.n +
 404                    rp3.x.n + rp3.y.n +
 405                    rp4.x.n + rp4.y.n +
 406                    n2.n;
 407         }
 408     }
 409     static class RefPoint_Access_Impl2 implements RefPoint_Access {
 410         @DontInline @DontCompile
 411         public int func1(RefPoint rp2) {
 412             return rp2.x.n + rp2.y.n + 2222222;
 413         }
 414         @DontInline
 415         @ForceCompile(compLevel = C1)
 416         public int func2(RefPoint rp1, RefPoint rp2, Number n1, RefPoint rp3, RefPoint rp4, Number n2) {
 417             return 222222 +
 418                    rp1.x.n + rp1.y.n +
 419                    rp2.x.n + rp2.y.n +
 420                    n1.n +
 421                    rp3.x.n + rp3.y.n +
 422                    rp4.x.n + rp4.y.n +
 423                    n2.n;
 424         }
 425     }
 426 
 427     static RefPoint_Access refPoint_Access_impls[] = {
 428         new RefPoint_Access_Impl1(),
 429         new RefPoint_Access_Impl2(),
 430         new RefPoint(0x12345, 0x6789a)
 431     };
 432 
 433     static int next_RefPoint_Access = 0;
 434     static RefPoint_Access get_RefPoint_Access() {
 435         int i = next_RefPoint_Access ++;
 436         return refPoint_Access_impls[i % refPoint_Access_impls.length];
 437     }
 438 
 439     static RefPoint refPointField1 = new RefPoint(12, 34);
 440     static RefPoint refPointField2 = new RefPoint(56789, 0x12345678);
 441 
 442     // This inline class has too many fields to fit in registers on x64 for
 443     // InlineTypeReturnedAsFields.
 444     static inline class TooBigToReturnAsFields {
 445         int a0 = 0;
 446         int a1 = 1;
 447         int a2 = 2;
 448         int a3 = 3;
 449         int a4 = 4;
 450         int a5 = 5;
 451         int a6 = 6;
 452         int a7 = 7;
 453         int a8 = 8;
 454         int a9 = 9;
 455     }
 456 
 457     static TooBigToReturnAsFields tooBig = new TooBigToReturnAsFields();
 458 
 459     //**********************************************************************
 460     // PART 1 - C1 calls interpreted code
 461     //**********************************************************************
 462 
 463 
 464     //** C1 passes inline type to interpreter (static)
 465     @Test(compLevel = C1)
 466     public int test1() {
 467         return test1_helper(pointField);
 468     }
 469 
 470     @DontInline
 471     @DontCompile
 472     private static int test1_helper(Point p) {
 473         return p.func();
 474     }
 475 
 476     @DontCompile
 477     public void test1_verifier(boolean warmup) {
 478         int count = warmup ? 1 : 10;
 479         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
 480             int result = test1() + i;
 481             Asserts.assertEQ(result, pointField.func() + i);
 482         }
 483     }
 484 
 485 
 486     //** C1 passes inline type to interpreter (monomorphic)
 487     @Test(compLevel = C1)
 488     public int test2() {
 489         return test2_helper(pointField);
 490     }
 491 
 492     @DontInline
 493     @DontCompile
 494     private int test2_helper(Point p) {
 495         return p.func();
 496     }
 497 
 498     @DontCompile
 499     public void test2_verifier(boolean warmup) {
 500         int count = warmup ? 1 : 10;
 501         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
 502             int result = test2() + i;
 503             Asserts.assertEQ(result, pointField.func() + i);
 504         }
 505     }
 506 
 507     // C1 passes inline type to interpreter (megamorphic: vtable)
 508     @Test(compLevel = C1)
 509     public int test3(Functor functor) {
 510         return functor.apply_interp(pointField);
 511     }
 512 
 513     @DontCompile
 514     public void test3_verifier(boolean warmup) {
 515         int count = warmup ? 1 : 100;
 516         for (int i=0; i&lt;count; i++) {  // need a loop to test inline cache and vtable indexing
 517             Functor functor = warmup ? functors[0] : getFunctor();
 518             int result = test3(functor) + i;
 519             Asserts.assertEQ(result, functor.apply_interp(pointField) + i);
 520         }
 521     }
 522 
 523     // Same as test3, but compiled with C2. Test the hastable of VtableStubs
 524     @Test(compLevel = C2)
 525     public int test3b(Functor functor) {
 526         return functor.apply_interp(pointField);
 527     }
 528 
 529     @DontCompile
 530     public void test3b_verifier(boolean warmup) {
 531         int count = warmup ? 1 : 100;
 532         for (int i=0; i&lt;count; i++) {  // need a loop to test inline cache and vtable indexing
 533             Functor functor = warmup ? functors[0] : getFunctor();
 534             int result = test3b(functor) + i;
 535             Asserts.assertEQ(result, functor.apply_interp(pointField) + i);
 536         }
 537     }
 538 
 539     // C1 passes inline type to interpreter (megamorphic: itable)
 540     @Test(compLevel = C1)
 541     public int test4(FunctorInterface fi) {
 542         return fi.apply_interp(pointField);
 543     }
 544 
 545     @DontCompile
 546     public void test4_verifier(boolean warmup) {
 547         int count = warmup ? 1 : 100;
 548         for (int i=0; i&lt;count; i++) {  // need a loop to test inline cache and itable indexing
 549             Functor functor = warmup ? functors[0] : getFunctor();
 550             int result = test4(functor) + i;
 551             Asserts.assertEQ(result, functor.apply_interp(pointField) + i);
 552         }
 553     }
 554 
 555     //**********************************************************************
 556     // PART 2 - interpreter calls C1
 557     //**********************************************************************
 558 
 559     // Interpreter passes inline type to C1 (static)
 560     @Test(compLevel = C1)
 561     static public int test20(Point p1, long l, Point p2) {
 562         return p1.x + p2.y;
 563     }
 564 
 565     @DontCompile
 566     public void test20_verifier(boolean warmup) {
 567         int result = test20(pointField1, 0, pointField2);
 568         int n = pointField1.x + pointField2.y;
 569         Asserts.assertEQ(result, n);
 570     }
 571 
 572     // Interpreter passes inline type to C1 (instance method in inline class)
 573     @Test
 574     public int test21(Point p) {
 575         return test21_helper(p);
 576     }
 577 
 578     @DontCompile
 579     @DontInline
 580     int test21_helper(Point p) {
 581         return p.func_c1(p);
 582     }
 583 
 584     @DontCompile
 585     public void test21_verifier(boolean warmup) {
 586         int result = test21(pointField);
 587         int n = 2 * (pointField.x + pointField.y);
 588         Asserts.assertEQ(result, n);
 589     }
 590 
 591 
 592     //**********************************************************************
 593     // PART 3 - C2 calls C1
 594     //**********************************************************************
 595 
 596     // C2-&gt;C1 invokestatic, single inline arg
 597     @Test(compLevel = C2)
 598     public int test30() {
 599         return test30_helper(pointField);
 600     }
 601 
 602     @DontInline
 603     @ForceCompile(compLevel = C1)
 604     private static int test30_helper(Point p) {
 605         return p.x + p.y;
 606     }
 607 
 608     @DontCompile
 609     public void test30_verifier(boolean warmup) {
 610         int count = warmup ? 1 : 2;
 611         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
 612             int result = test30();
 613             int n = pointField.x + pointField.y;
 614             Asserts.assertEQ(result, n);
 615         }
 616     }
 617 
 618     // C2-&gt;C1 invokestatic, two single inline args
 619     @Test(compLevel = C2)
 620     public int test31() {
 621       return test31_helper(pointField1, pointField2);
 622     }
 623 
 624     @DontInline
 625     @ForceCompile(compLevel = C1)
 626     private static int test31_helper(Point p1, Point p2) {
 627         return p1.x + p2.y;
 628     }
 629 
 630     @DontCompile
 631     public void test31_verifier(boolean warmup) {
 632         int count = warmup ? 1 : 2;
 633         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
 634             int result = test31();
 635             int n = pointField1.x + pointField2.y;
 636             Asserts.assertEQ(result, n);
 637         }
 638     }
 639 
 640     // C2-&gt;C1 invokestatic, two single inline args and interleaving ints (all passed in registers on x64)
 641     @Test(compLevel = C2)
 642     public int test32() {
 643       return test32_helper(0, pointField1, 1, pointField2);
 644     }
 645 
 646     @DontInline
 647     @ForceCompile(compLevel = C1)
 648     private static int test32_helper(int x, Point p1, int y, Point p2) {
 649         return p1.x + p2.y + x + y;
 650     }
 651 
 652     @DontCompile
 653     public void test32_verifier(boolean warmup) {
 654         int count = warmup ? 1 : 2;
 655         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
 656             int result = test32();
 657             int n = pointField1.x + pointField2.y + 0 + 1;
 658             Asserts.assertEQ(result, n);
 659         }
 660     }
 661 
 662     // C2-&gt;C1 invokeinterface -- no verified_ro_entry (no inline args except for receiver)
 663     @Test(compLevel = C2)
 664     public int test33(Intf intf, int a, int b) {
 665         return intf.func1(a, b);
 666     }
 667 
 668     @DontCompile
 669     public void test33_verifier(boolean warmup) {
 670         int count = warmup ? 1 : 20;
 671         for (int i=0; i&lt;count; i++) {
 672             Intf intf = warmup ? intfs[0] : getIntf(i+1);
 673             int result = test33(intf, 123, 456) + i;
 674             Asserts.assertEQ(result, intf.func1(123, 456) + i);
 675         }
 676     }
 677 
 678     // C2-&gt;C1 invokeinterface -- use verified_ro_entry (has inline args other than receiver)
 679     @Test(compLevel = C2)
 680     public int test34(Intf intf, int a, int b) {
 681         return intf.func2(a, b, pointField);
 682     }
 683 
 684     @DontCompile
 685     public void test34_verifier(boolean warmup) {
 686         int count = warmup ? 1 : 20;
 687         for (int i=0; i&lt;count; i++) {
 688             Intf intf = warmup ? intfs[0] : getIntf(i+1);
 689             int result = test34(intf, 123, 456) + i;
 690             Asserts.assertEQ(result, intf.func2(123, 456, pointField) + i);
 691         }
 692     }
 693 
 694     // C2-&gt;C1 invokestatic, Point.y is on stack (x64)
 695     @Test(compLevel = C2)
 696     public int test35() {
 697         return test35_helper(1, 2, 3, 4, 5, pointField);
 698     }
 699 
 700     @DontInline
 701     @ForceCompile(compLevel = C1)
 702     private static int test35_helper(int a1, int a2, int a3, int a4, int a5, Point p) {
 703         return a1 + a2 + a3 + a4 + a5 + p.x + p.y;
 704     }
 705 
 706     @DontCompile
 707     public void test35_verifier(boolean warmup) {
 708         int count = warmup ? 1 : 2;
 709         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
 710             int result = test35();
 711             int n = 1 + 2 + 3  + 4 + 5 + pointField.x + pointField.y;
 712             Asserts.assertEQ(result, n);
 713         }
 714     }
 715 
 716     // C2-&gt;C1 invokestatic, shuffling arguments that are passed on stack
 717     @Test(compLevel = C2)
 718     public int test36() {
 719         return test36_helper(pointField, 1, 2, 3, 4, 5, 6, 7, 8);
 720     }
 721 
 722     @DontInline
 723     @ForceCompile(compLevel = C1)
 724     private static int test36_helper(Point p, int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8) {
 725         return a6 + a8;
 726     }
 727 
 728     @DontCompile
 729     public void test36_verifier(boolean warmup) {
 730         int count = warmup ? 1 : 2;
 731         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
 732             int result = test36();
 733             int n = 6 + 8;
 734             Asserts.assertEQ(result, n);
 735         }
 736     }
 737 
 738     // C2-&gt;C1 invokestatic, shuffling long arguments
 739     @Test(compLevel = C2)
 740     public int test37() {
 741         return test37_helper(pointField, 1, 2, 3, 4, 5, 6, 7, 8);
 742     }
 743 
 744     @DontInline
 745     @ForceCompile(compLevel = C1)
 746     private static int test37_helper(Point p, long a1, long a2, long a3, long a4, long a5, long a6, long a7, long a8) {
 747         return (int)(a6 + a8);
 748     }
 749 
 750     @DontCompile
 751     public void test37_verifier(boolean warmup) {
 752         int count = warmup ? 1 : 2;
 753         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
 754             int result = test37();
 755             int n = 6 + 8;
 756             Asserts.assertEQ(result, n);
 757         }
 758     }
 759 
 760     // C2-&gt;C1 invokestatic, shuffling boolean, byte, char, short, int, long arguments
 761     @Test(compLevel = C2)
 762     public int test38() {
 763         return test38_helper(pointField, true, (byte)1, (char)2, (short)3, 4, 5, (byte)6, (short)7, 8);
 764     }
 765 
 766     @DontInline
 767     @ForceCompile(compLevel = C1)
 768     private static int test38_helper(Point p, boolean a0, byte a1, char a2, short a3, int a4, long a5, byte a6, short a7, int a8) {
 769         if (a0) {
 770             return (int)(a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8);
 771         } else {
 772             return -1;
 773         }
 774     }
 775 
 776     @DontCompile
 777     public void test38_verifier(boolean warmup) {
 778         int count = warmup ? 1 : 2;
 779         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
 780             int result = test38();
 781             int n = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8;
 782             Asserts.assertEQ(result, n);
 783         }
 784     }
 785 
 786     // C2-&gt;C1 invokestatic, packing an inline type with all types of fixed point primitive fields.
 787     @Test(compLevel = C2)
 788     public long test39() {
 789         return test39_helper(1, fixedPointsField, 2, fixedPointsField);
 790     }
 791 
 792     @DontInline
 793     @ForceCompile(compLevel = C1)
 794     private static long test39_helper(int a1, FixedPoints f1, int a2, FixedPoints f2) {
 795         if (f1.Z0 == false &amp;&amp; f1.Z1 == true &amp;&amp; f2.Z0 == false &amp;&amp; f2.Z1 == true) {
 796             return f1.B + f2.C + f1.S + f2.I + f1.J;
 797         } else {
 798             return -1;
 799         }
 800     }
 801 
 802     @DontCompile
 803     public void test39_verifier(boolean warmup) {
 804         int count = warmup ? 1 : 2;
 805         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
 806             long result = test39();
 807             long n = test39_helper(1, fixedPointsField, 2, fixedPointsField);
 808             Asserts.assertEQ(result, n);
 809         }
 810     }
 811 
 812     // C2-&gt;C1 invokestatic, shuffling floating point args
 813     @Test(compLevel = C2)
 814     public double test40() {
 815         return test40_helper(1.1f, 1.2, floatPointField, doublePointField, 1.3f, 1.4, 1.5f, 1.7, 1.7, 1.8, 1.9, 1.10, 1.11, 1.12);
 816     }
 817 
 818     @DontInline
 819     @ForceCompile(compLevel = C1)
 820     private static double test40_helper(float a1, double a2, FloatPoint fp, DoublePoint dp, float a3, double a4, float a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12) {
 821         return a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12 + fp.x + fp.y - dp.x - dp.y;
 822     }
 823 
 824     @DontCompile
 825     public void test40_verifier(boolean warmup) {
 826         int count = warmup ? 1 : 2;
 827         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
 828             double result = test40();
 829             double n = test40_helper(1.1f, 1.2, floatPointField, doublePointField, 1.3f, 1.4, 1.5f, 1.7, 1.7, 1.8, 1.9, 1.10, 1.11, 1.12);
 830             Asserts.assertEQ(result, n);
 831         }
 832     }
 833 
 834     // C2-&gt;C1 invokestatic, mixing floats and ints
 835     @Test(compLevel = C2)
 836     public double test41() {
 837         return test41_helper(1, 1.2, pointField, floatPointField, doublePointField, 1.3f, 4, 1.5f, 1.7, 1.7, 1.8, 9, 1.10, 1.11, 1.12);
 838     }
 839 
 840     @DontInline
 841     @ForceCompile(compLevel = C1)
 842     private static double test41_helper(int a1, double a2, Point p, FloatPoint fp, DoublePoint dp, float a3, int a4, float a5, double a6, double a7, double a8, long a9, double a10, double a11, double a12) {
 843       return a1 + a2  + fp.x + fp.y - dp.x - dp.y + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12;
 844     }
 845 
 846     @DontCompile
 847     public void test41_verifier(boolean warmup) {
 848         int count = warmup ? 1 : 2;
 849         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
 850             double result = test41();
 851             double n = test41_helper(1, 1.2, pointField, floatPointField, doublePointField, 1.3f, 4, 1.5f, 1.7, 1.7, 1.8, 9, 1.10, 1.11, 1.12);
 852             Asserts.assertEQ(result, n);
 853         }
 854     }
 855 
 856     // C2-&gt;C1 invokestatic, circular dependency (between rdi and first stack slot on x64)
 857     @Test(compLevel = C2)
 858     public float test42() {
 859         return test42_helper(eightFloatsField, pointField, 3, 4, 5, floatPointField, 7);
 860     }
 861 
 862     @DontInline
 863     @ForceCompile(compLevel = C1)
 864     private static float test42_helper(EightFloats ep1, // (xmm0 ... xmm7) -&gt; rsi
 865                                        Point p2,        // (rsi, rdx) -&gt; rdx
 866                                        int i3,          // rcx -&gt; rcx
 867                                        int i4,          // r8 -&gt; r8
 868                                        int i5,          // r9 -&gt; r9
 869                                        FloatPoint fp6,  // (stk[0], stk[1]) -&gt; rdi   ** circ depend
 870                                        int i7)          // rdi -&gt; stk[0]             ** circ depend
 871     {
 872         return ep1.f1 + ep1.f2 + ep1.f3 + ep1.f4 + ep1.f5 + ep1.f6 + ep1.f7 + ep1.f8 +
 873             p2.x + p2.y + i3 + i4 + i5 + fp6.x + fp6.y + i7;
 874     }
 875 
 876     @DontCompile
 877     public void test42_verifier(boolean warmup) {
 878         int count = warmup ? 1 : 2;
 879         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
 880             float result = test42();
 881             float n = test42_helper(eightFloatsField, pointField, 3, 4, 5, floatPointField, 7);
 882             Asserts.assertEQ(result, n);
 883         }
 884     }
 885 
 886     // C2-&gt;C1 invokestatic, packing causes stack growth (1 extra stack word)
 887     @Test(compLevel = C2)
 888     public float test43() {
 889         return test43_helper(floatPointField, 1, 2, 3, 4, 5, 6);
 890     }
 891 
 892     @DontInline
 893     @ForceCompile(compLevel = C1)
 894     private static float test43_helper(FloatPoint fp, int a1, int a2, int a3, int a4, int a5, int a6) {
 895         // On x64:
 896         //    Scalarized entry -- all parameters are passed in registers
 897         //    Non-scalarized entry -- a6 is passed on stack[0]
 898         return fp.x + fp.y + a1 + a2 + a3 + a4 + a5 + a6;
 899     }
 900 
 901     @DontCompile
 902     public void test43_verifier(boolean warmup) {
 903         int count = warmup ? 1 : 2;
 904         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
 905             float result = test43();
 906             float n = test43_helper(floatPointField, 1, 2, 3, 4, 5, 6);
 907             Asserts.assertEQ(result, n);
 908         }
 909     }
 910 
 911     // C2-&gt;C1 invokestatic, packing causes stack growth (2 extra stack words)
 912     @Test(compLevel = C2)
 913     public float test44() {
 914       return test44_helper(floatPointField, floatPointField, 1, 2, 3, 4, 5, 6);
 915     }
 916 
 917     @DontInline
 918     @ForceCompile(compLevel = C1)
 919     private static float test44_helper(FloatPoint fp1, FloatPoint fp2, int a1, int a2, int a3, int a4, int a5, int a6) {
 920         // On x64:
 921         //    Scalarized entry -- all parameters are passed in registers
 922         //    Non-scalarized entry -- a5 is passed on stack[0]
 923         //    Non-scalarized entry -- a6 is passed on stack[1]
 924         return fp1.x + fp1.y +
 925                fp2.x + fp2.y +
 926                a1 + a2 + a3 + a4 + a5 + a6;
 927     }
 928 
 929     @DontCompile
 930     public void test44_verifier(boolean warmup) {
 931         int count = warmup ? 1 : 2;
 932         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
 933             float result = test44();
 934             float n = test44_helper(floatPointField, floatPointField, 1, 2, 3, 4, 5, 6);
 935             Asserts.assertEQ(result, n);
 936         }
 937     }
 938 
 939     // C2-&gt;C1 invokestatic, packing causes stack growth (5 extra stack words)
 940     @Test(compLevel = C2)
 941     public float test45() {
 942       return test45_helper(floatPointField, floatPointField, floatPointField, floatPointField, floatPointField, 1, 2, 3, 4, 5, 6, 7);
 943     }
 944 
 945     @DontInline
 946     @ForceCompile(compLevel = C1)
 947     private static float test45_helper(FloatPoint fp1, FloatPoint fp2, FloatPoint fp3, FloatPoint fp4, FloatPoint fp5, int a1, int a2, int a3, int a4, int a5, int a6, int a7) {
 948         return fp1.x + fp1.y +
 949                fp2.x + fp2.y +
 950                fp3.x + fp3.y +
 951                fp4.x + fp4.y +
 952                fp5.x + fp5.y +
 953                a1 + a2 + a3 + a4 + a5 + a6 + a7;
 954     }
 955 
 956     @DontCompile
 957     public void test45_verifier(boolean warmup) {
 958         int count = warmup ? 1 : 2;
 959         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
 960             float result = test45();
 961             float n = test45_helper(floatPointField, floatPointField, floatPointField, floatPointField, floatPointField, 1, 2, 3, 4, 5, 6, 7);
 962             Asserts.assertEQ(result, n);
 963         }
 964     }
 965 
 966     // C2-&gt;C1 invokestatic, packing causes stack growth (1 extra stack word -- mixing Point and FloatPoint)
 967     @Test(compLevel = C2)
 968     public float test46() {
 969       return test46_helper(floatPointField, floatPointField, pointField, floatPointField, floatPointField, pointField, floatPointField, 1, 2, 3, 4, 5, 6, 7);
 970     }
 971 
 972     @DontInline
 973     @ForceCompile(compLevel = C1)
 974     private static float test46_helper(FloatPoint fp1, FloatPoint fp2, Point p1, FloatPoint fp3, FloatPoint fp4, Point p2, FloatPoint fp5, int a1, int a2, int a3, int a4, int a5, int a6, int a7) {
 975         return p1.x + p1.y +
 976                p2.x + p2.y +
 977                fp1.x + fp1.y +
 978                fp2.x + fp2.y +
 979                fp3.x + fp3.y +
 980                fp4.x + fp4.y +
 981                fp5.x + fp5.y +
 982                a1 + a2 + a3 + a4 + a5 + a6 + a7;
 983     }
 984 
 985     @DontCompile
 986     public void test46_verifier(boolean warmup) {
 987         int count = warmup ? 1 : 2;
 988         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
 989             float result = test46();
 990             float n = test46_helper(floatPointField, floatPointField, pointField, floatPointField, floatPointField, pointField, floatPointField, 1, 2, 3, 4, 5, 6, 7);
 991             Asserts.assertEQ(result, n);
 992         }
 993     }
 994 
 995     static class MyRuntimeException extends RuntimeException {
 996         MyRuntimeException(String s) {
 997             super(s);
 998         }
 999     }
1000 
1001     static void checkStackTrace(Throwable t, String... methodNames) {
1002         StackTraceElement[] trace = t.getStackTrace();
1003         for (int i=0; i&lt;methodNames.length; i++) {
1004             if (!methodNames[i].equals(trace[i].getMethodName())) {
1005                 String error = &quot;Unexpected stack trace: level &quot; + i + &quot; should be &quot; + methodNames[i];
1006                 System.out.println(error);
1007                 t.printStackTrace(System.out);
1008                 throw new RuntimeException(error, t);
1009             }
1010         }
1011     }
1012     //*
1013 
1014     // C2-&gt;C1 invokestatic, make sure stack walking works (with static variable)
1015     @Test(compLevel = C2)
1016     public void test47(int n) {
1017         try {
1018             test47_helper(floatPointField, 1, 2, 3, 4, 5);
1019             test47_value = 666;
1020         } catch (MyRuntimeException e) {
1021             // expected;
1022         }
1023         test47_value = n;
1024     }
1025 
1026     @DontInline
1027     @ForceCompile(compLevel = C1)
1028     private static float test47_helper(FloatPoint fp, int a1, int a2, int a3, int a4, int a5) {
1029         test47_thrower();
1030         return 0.0f;
1031     }
1032 
1033     @DontInline @DontCompile
1034     private static void test47_thrower() {
1035         MyRuntimeException e = new MyRuntimeException(&quot;This exception should have been caught!&quot;);
1036         checkStackTrace(e, &quot;test47_thrower&quot;, &quot;test47_helper&quot;, &quot;test47&quot;, &quot;test47_verifier&quot;);
1037         throw e;
1038     }
1039 
1040     static int test47_value = 999;
1041 
1042     @DontCompile
1043     public void test47_verifier(boolean warmup) {
1044         int count = warmup ? 1 : 5;
1045         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1046             test47_value = 777 + i;
1047             test47(i);
1048             Asserts.assertEQ(test47_value, i);
1049         }
1050     }
1051 
1052     // C2-&gt;C1 invokestatic, make sure stack walking works (with returned inline type)
1053     @Test(compLevel = C2)
1054     public int test48(int n) {
1055         try {
1056             test48_helper(floatPointField, 1, 2, 3, 4, 5);
1057             return 666;
1058         } catch (MyRuntimeException e) {
1059             // expected;
1060         }
1061         return n;
1062     }
1063 
1064     @DontInline
1065     @ForceCompile(compLevel = C1)
1066     private static float test48_helper(FloatPoint fp, int a1, int a2, int a3, int a4, int a5) {
1067         test48_thrower();
1068         return 0.0f;
1069     }
1070 
1071     @DontInline @DontCompile
1072     private static void test48_thrower() {
1073         MyRuntimeException e = new MyRuntimeException(&quot;This exception should have been caught!&quot;);
1074         checkStackTrace(e, &quot;test48_thrower&quot;, &quot;test48_helper&quot;, &quot;test48&quot;, &quot;test48_verifier&quot;);
1075         throw e;
1076     }
1077 
1078     @DontCompile
1079     public void test48_verifier(boolean warmup) {
1080         int count = warmup ? 1 : 5;
1081         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1082             int n = test48(i);
1083             Asserts.assertEQ(n, i);
1084         }
1085     }
1086 
1087     // C2-&gt;interpreter invokestatic, make sure stack walking works (same as test 48, but with stack extension/repair)
1088     // (this is the baseline for test50 --
1089     // the only difference is: test49_helper is interpreted but test50_helper is compiled by C1).
1090     @Test(compLevel = C2)
1091     public int test49(int n) {
1092         try {
1093             test49_helper(floatPointField, 1, 2, 3, 4, 5, 6);
1094             return 666;
1095         } catch (MyRuntimeException e) {
1096             // expected;
1097         }
1098         return n;
1099     }
1100 
1101     @DontInline @DontCompile
1102     private static float test49_helper(FloatPoint fp, int a1, int a2, int a3, int a4, int a5, int a6) {
1103         test49_thrower();
1104         return 0.0f;
1105     }
1106 
1107     @DontInline @DontCompile
1108     private static void test49_thrower() {
1109         MyRuntimeException e = new MyRuntimeException(&quot;This exception should have been caught!&quot;);
1110         checkStackTrace(e, &quot;test49_thrower&quot;, &quot;test49_helper&quot;, &quot;test49&quot;, &quot;test49_verifier&quot;);
1111         throw e;
1112     }
1113 
1114     @DontCompile
1115     public void test49_verifier(boolean warmup) {
1116         int count = warmup ? 1 : 5;
1117         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1118             int n = test49(i);
1119             Asserts.assertEQ(n, i);
1120         }
1121     }
1122 
1123     // C2-&gt;C1 invokestatic, make sure stack walking works (same as test 48, but with stack extension/repair)
1124     @Test(compLevel = C2)
1125     public int test50(int n) {
1126         try {
1127             test50_helper(floatPointField, 1, 2, 3, 4, 5, 6);
1128             return 666;
1129         } catch (MyRuntimeException e) {
1130             // expected;
1131         }
1132         return n;
1133     }
1134 
1135     @DontInline
1136     @ForceCompile(compLevel = C1)
1137     private static float test50_helper(FloatPoint fp, int a1, int a2, int a3, int a4, int a5, int a6) {
1138         test50_thrower();
1139         return 0.0f;
1140     }
1141 
1142     @DontInline @DontCompile
1143     private static void test50_thrower() {
1144         MyRuntimeException e = new MyRuntimeException(&quot;This exception should have been caught!&quot;);
1145         checkStackTrace(e, &quot;test50_thrower&quot;, &quot;test50_helper&quot;, &quot;test50&quot;, &quot;test50_verifier&quot;);
1146         throw e;
1147     }
1148 
1149     @DontCompile
1150     public void test50_verifier(boolean warmup) {
1151         int count = warmup ? 1 : 5;
1152         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1153             int n = test50(i);
1154             Asserts.assertEQ(n, i);
1155         }
1156     }
1157 
1158 
1159     // C2-&gt;C1 invokestatic, inline class with ref fields (RefPoint)
1160     @Test(compLevel = C2)
1161     public int test51() {
1162         return test51_helper(refPointField1);
1163     }
1164 
1165     @DontInline
1166     @ForceCompile(compLevel = C1)
1167     private static int test51_helper(RefPoint rp1) {
1168         return rp1.x.n + rp1.y.n;
1169     }
1170 
1171     @DontCompile
1172     public void test51_verifier(boolean warmup) {
1173         int count = warmup ? 1 : 5;
1174         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1175             int result = test51();
1176             int n = test51_helper(refPointField1);
1177             Asserts.assertEQ(result, n);
1178         }
1179     }
1180 
1181     // C2-&gt;C1 invokestatic, inline class with ref fields (Point, RefPoint)
1182     @Test(compLevel = C2)
1183     public int test52() {
1184         return test52_helper(pointField, refPointField1);
1185     }
1186 
1187     @DontInline
1188     @ForceCompile(compLevel = C1)
1189     private static int test52_helper(Point p1, RefPoint rp1) {
1190         return p1.x + p1.y + rp1.x.n + rp1.y.n;
1191     }
1192 
1193     @DontCompile
1194     public void test52_verifier(boolean warmup) {
1195         int count = warmup ? 1 : 5;
1196         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1197             int result = test52();
1198             int n = test52_helper(pointField, refPointField1);
1199             Asserts.assertEQ(result, n);
1200         }
1201     }
1202 
1203     // C2-&gt;C1 invokestatic, inline class with ref fields (RefPoint, RefPoint, RefPoint, RefPoint)
1204     @Test(compLevel = C2)
1205     public int test53() {
1206         return test53_helper(refPointField1, refPointField2, refPointField1, refPointField2);
1207     }
1208 
1209     @DontInline
1210     @ForceCompile(compLevel = C1)
1211     private static int test53_helper(RefPoint rp1, RefPoint rp2, RefPoint rp3, RefPoint rp4) {
1212         return rp1.x.n + rp1.y.n +
1213                rp2.x.n + rp2.y.n +
1214                rp3.x.n + rp3.y.n +
1215                rp4.x.n + rp4.y.n;
1216     }
1217 
1218     @DontCompile
1219     public void test53_verifier(boolean warmup) {
1220         int count = warmup ? 1 : 5;
1221         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1222             int result = test53();
1223             int n = test53_helper(refPointField1, refPointField2, refPointField1, refPointField2);
1224             Asserts.assertEQ(result, n);
1225         }
1226     }
1227 
1228     // C2-&gt;C1 invokestatic, inline class with ref fields (RefPoint, RefPoint, float, int, RefPoint, RefPoint)
1229     @Test(compLevel = C2)
1230     public int test54() {
1231         return test54_helper(refPointField1, refPointField2, 1.0f, 2, refPointField1, refPointField2);
1232     }
1233 
1234     @DontInline
1235     @ForceCompile(compLevel = C1)
1236     private static int test54_helper(RefPoint rp1, RefPoint rp2, float f, int i, RefPoint rp3, RefPoint rp4) {
1237         return rp1.x.n + rp1.y.n +
1238                rp2.x.n + rp2.y.n +
1239                (int)(f) + i +
1240                rp3.x.n + rp3.y.n +
1241                rp4.x.n + rp4.y.n;
1242     }
1243 
1244     @DontCompile
1245     public void test54_verifier(boolean warmup) {
1246         int count = warmup ? 1 : 5;
1247         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1248             int result = test54();
1249             int n = test54_helper(refPointField1, refPointField2, 1.0f, 2, refPointField1, refPointField2);
1250             Asserts.assertEQ(result, n);
1251         }
1252     }
1253 
1254     static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();
1255     static final String ScavengeALot = &quot;ScavengeALot&quot;;
1256 
1257 
1258     /**
1259      * Each allocation with a &quot;try&quot; block like this will cause a GC
1260      *
1261      *       try (ForceGCMarker m = ForceGCMarker.mark(warmup)) {
1262      *           result = test55(p1);
1263      *       }
1264      */
1265     static class ForceGCMarker implements java.io.Closeable {
1266         static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();
1267 
1268         ForceGCMarker() {
1269             WHITE_BOX.setBooleanVMFlag(ScavengeALot, true);
1270         }
1271         public void close() {
1272             WHITE_BOX.setBooleanVMFlag(ScavengeALot, false);
1273         }
1274 
1275         static ForceGCMarker mark(boolean warmup) {
1276             return warmup ? null : new ForceGCMarker();
1277         }
1278     }
1279 
1280     // C2-&gt;C1 invokestatic, force GC for every allocation when entering a C1 VEP (Point)
1281     @Test(compLevel = C2)
1282     public int test55(Point p1) {
1283         return test55_helper(p1);
1284     }
1285 
1286     @DontInline
1287     @ForceCompile(compLevel = C1)
1288     private static int test55_helper(Point p1) {
1289         return p1.x + p1.y;
1290     }
1291 
1292     @DontCompile
1293     public void test55_verifier(boolean warmup) {
1294         int count = warmup ? 1 : 5;
1295         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1296             Point p1 = new Point(1, 2);
1297             int result;
1298             try (ForceGCMarker m = ForceGCMarker.mark(warmup)) {
1299                 result = test55(p1);
1300             }
1301             int n = test55_helper(p1);
1302             Asserts.assertEQ(result, n);
1303         }
1304     }
1305 
1306     // C2-&gt;C1 invokestatic, force GC for every allocation when entering a C1 VEP (RefPoint)
1307     @Test(compLevel = C2)
1308     public int test56(RefPoint rp1) {
1309         return test56_helper(rp1);
1310     }
1311 
1312     @DontInline
1313     @ForceCompile(compLevel = C1)
1314     private static int test56_helper(RefPoint rp1) {
1315         return rp1.x.n + rp1.y.n;
1316     }
1317 
1318     @DontCompile
1319     public void test56_verifier(boolean warmup) {
1320         int count = warmup ? 1 : 5;
1321         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1322             RefPoint rp1 = new RefPoint(1, 2);
1323             int result;
1324             try (ForceGCMarker m = ForceGCMarker.mark(warmup)) {
1325                 result = test56(rp1);
1326             }
1327             int n = test56_helper(rp1);
1328             Asserts.assertEQ(result, n);
1329         }
1330     }
1331 
1332     // C2-&gt;Interpreter (same as test56, but test c2i entry instead of C1)
1333     @Test(compLevel = C2)
1334     public int test57(RefPoint rp1) {
1335         return test57_helper(rp1);
1336     }
1337 
1338     @DontInline @DontCompile
1339     private static int test57_helper(RefPoint rp1) {
1340         return rp1.x.n + rp1.y.n;
1341     }
1342 
1343     @DontCompile
1344     public void test57_verifier(boolean warmup) {
1345         int count = warmup ? 1 : 5;
1346         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1347             RefPoint rp1 = new RefPoint(1, 2);
1348             int result;
1349             try (ForceGCMarker m = ForceGCMarker.mark(warmup)) {
1350                 result = test57(rp1);
1351             }
1352             int n = test57_helper(rp1);
1353             Asserts.assertEQ(result, n);
1354         }
1355     }
1356 
1357     // C2-&gt;C1 invokestatic, force GC for every allocation when entering a C1 VEP (a bunch of RefPoints and Numbers);
1358     @Test(compLevel = C2)
1359     public int test58(RefPoint rp1, RefPoint rp2, Number n1, RefPoint rp3, RefPoint rp4, Number n2) {
1360         return test58_helper(rp1, rp2, n1, rp3, rp4, n2);
1361     }
1362 
1363     @DontInline
1364     @ForceCompile(compLevel = C1)
1365     private static int test58_helper(RefPoint rp1, RefPoint rp2, Number n1, RefPoint rp3, RefPoint rp4, Number n2) {
1366         return rp1.x.n + rp1.y.n +
1367                rp2.x.n + rp2.y.n +
1368                n1.n +
1369                rp3.x.n + rp3.y.n +
1370                rp4.x.n + rp4.y.n +
1371                n2.n;
1372     }
1373 
1374     @DontCompile
1375     public void test58_verifier(boolean warmup) {
1376         int count = warmup ? 1 : 5;
1377         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1378             RefPoint rp1 = new RefPoint(1, 2);
1379             RefPoint rp2 = refPointField1;
1380             RefPoint rp3 = new RefPoint(222, 777);
1381             RefPoint rp4 = refPointField2;
1382             Number n1 = new Number(5878);
1383             Number n2 = new Number(1234);
1384             int result;
1385             try (ForceGCMarker m = ForceGCMarker.mark(warmup)) {
1386                 result = test58(rp1, rp2, n1, rp3, rp4, n2);
1387             }
1388             int n = test58_helper(rp1, rp2, n1, rp3, rp4, n2);
1389             Asserts.assertEQ(result, n);
1390         }
1391     }
1392 
1393     // C2-&gt;C1 invokestatic, GC inside main body of C1-compiled method (caller&#39;s args should not be GC&#39;ed).
1394     @Test(compLevel = C2)
1395     public int test59(RefPoint rp1, boolean doGC) {
1396       return test59_helper(rp1, 11, 222, 3333, 4444, doGC);
1397     }
1398 
1399     @DontInline
1400     @ForceCompile(compLevel = C1)
1401     private static int test59_helper(RefPoint rp1, int a1, int a2, int a3, int a4, boolean doGC) {
1402         if (doGC) {
1403             System.gc();
1404         }
1405         return rp1.x.n + rp1.y.n + a1 + a2 + a3 + a4;
1406     }
1407 
1408     @DontCompile
1409     public void test59_verifier(boolean warmup) {
1410         int count = warmup ? 1 : 5;
1411         boolean doGC = !warmup;
1412         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1413             RefPoint rp1 = new RefPoint(1, 2);
1414             int result = test59(rp1, doGC);
1415             int n = test59_helper(rp1, 11, 222, 3333, 4444, doGC);
1416             Asserts.assertEQ(result, n);
1417         }
1418     }
1419 
1420     // C2-&gt;C1 invokestatic, GC inside main body of C1-compiled method (caller&#39;s args should not be GC&#39;ed).
1421     // same as test59, but the incoming (scalarized) oops are passed in both registers and stack.
1422     @Test(compLevel = C2)
1423     public int test60(RefPoint rp1, RefPoint rp2, boolean doGC) {
1424         return test60_helper(555, 6666, 77777, rp1, rp2, 11, 222, 3333, 4444, doGC);
1425     }
1426 
1427     @DontInline
1428     @ForceCompile(compLevel = C1)
1429     private static int test60_helper(int x0, int x1, int x2, RefPoint rp1, RefPoint rp2,int a1, int a2, int a3, int a4, boolean doGC) {
1430         // On x64, C2 passes:   reg0=x1, reg1=x1, reg2=x2, reg3=rp1.x, reg4=rp1.y, reg5=rp2.x stack0=rp2.y ....
1431         //         C1 expects:  reg0=x1, reg1=x1, reg2=x2, reg3=rp1,   reg4=rp2,   reg5=a1    stack0=a2 ...
1432         // When GC happens, make sure it does not treat reg5 and stack0 as oops!
1433         if (doGC) {
1434             System.gc();
1435         }
1436         return x0 + x1 + x2 + rp1.x.n + rp1.y.n + rp2.x.n + rp2.y.n + a1 + a2 + a3 + a4;
1437     }
1438 
1439     @DontCompile
1440     public void test60_verifier(boolean warmup) {
1441         int count = warmup ? 1 : 5;
1442         boolean doGC = !warmup;
1443         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1444             RefPoint rp1 = new RefPoint(1, 2);
1445             RefPoint rp2 = new RefPoint(33, 44);
1446             int result = test60(rp1, rp2, doGC);
1447             int n = test60_helper(555, 6666, 77777, rp1, rp2, 11, 222, 3333, 4444, doGC);
1448             Asserts.assertEQ(result, n);
1449         }
1450     }
1451 
1452     // C2-&gt;C1 invokeinterface via VVEP(RO)
1453     @Test(compLevel = C2)
1454     public int test61(RefPoint_Access rpa, RefPoint rp2) {
1455         return rpa.func1(rp2);
1456     }
1457 
1458     @DontCompile
1459     public void test61_verifier(boolean warmup) {
1460         int count = warmup ? 1 : 20;
1461         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1462             RefPoint_Access rpa = get_RefPoint_Access();
1463             RefPoint rp2 = refPointField2;
1464             int result = test61(rpa, rp2);
1465             int n = rpa.func1(rp2);
1466             Asserts.assertEQ(result, n);
1467         }
1468     }
1469 
1470     // C2-&gt;C1 invokeinterface via VVEP(RO) -- force GC for every allocation when entering a C1 VVEP(RO) (RefPoint)
1471     @Test(compLevel = C2)
1472     public int test62(RefPoint_Access rpa, RefPoint rp2) {
1473         return rpa.func1(rp2);
1474     }
1475 
1476     @DontCompile
1477     public void test62_verifier(boolean warmup) {
1478         int count = warmup ? 1 : 20;
1479         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1480             RefPoint_Access rpa = get_RefPoint_Access();
1481             RefPoint rp2 = new RefPoint(111, 2222);
1482             int result;
1483             try (ForceGCMarker m = ForceGCMarker.mark(warmup)) {
1484                 result = test62(rpa, rp2);
1485             }
1486             int n = rpa.func1(rp2);
1487             Asserts.assertEQ(result, n);
1488         }
1489     }
1490 
1491     // C2-&gt;C1 invokeinterface via VVEP(RO) -- force GC for every allocation when entering a C1 VVEP(RO) (a bunch of RefPoints and Numbers)
1492     @Test(compLevel = C2)
1493     public int test63(RefPoint_Access rpa, RefPoint rp1, RefPoint rp2, Number n1, RefPoint rp3, RefPoint rp4, Number n2) {
1494         return rpa.func2(rp1, rp2, n1, rp3, rp4, n2);
1495     }
1496 
1497     @DontCompile
1498     public void test63_verifier(boolean warmup) {
1499         int count = warmup ? 1 : 20;
1500         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1501             RefPoint_Access rpa = get_RefPoint_Access();
1502             RefPoint rp1 = new RefPoint(1, 2);
1503             RefPoint rp2 = refPointField1;
1504             RefPoint rp3 = new RefPoint(222, 777);
1505             RefPoint rp4 = refPointField2;
1506             Number n1 = new Number(5878);
1507             Number n2 = new Number(1234);
1508             int result;
1509             try (ForceGCMarker m = ForceGCMarker.mark(warmup)) {
1510                 result = test63(rpa, rp1, rp2, n1, rp3, rp4, n2);
1511             }
1512             int n = rpa.func2(rp1, rp2, n1, rp3, rp4, n2);
1513             Asserts.assertEQ(result, n);
1514         }
1515     }
1516 
1517     // C2-&gt;C1 invokestatic (same as test63, but use invokestatic instead)
1518     @Test(compLevel = C2)
1519     public int test64(RefPoint_Access rpa, RefPoint rp1, RefPoint rp2, Number n1, RefPoint rp3, RefPoint rp4, Number n2) {
1520         return test64_helper(rpa, rp1, rp2, n1, rp3, rp4, n2);
1521     }
1522 
1523     @DontInline
1524     @ForceCompile(compLevel = C1)
1525     public static int test64_helper(RefPoint_Access rpa, RefPoint rp1, RefPoint rp2, Number n1, RefPoint rp3, RefPoint rp4, Number n2) {
1526         return rp3.y.n;
1527     }
1528 
1529     @DontCompile
1530     public void test64_verifier(boolean warmup) {
1531         int count = warmup ? 1 : 20;
1532         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1533             RefPoint_Access rpa = get_RefPoint_Access();
1534             RefPoint rp1 = new RefPoint(1, 2);
1535             RefPoint rp2 = refPointField1;
1536             RefPoint rp3 = new RefPoint(222, 777);
1537             RefPoint rp4 = refPointField2;
1538             Number n1 = new Number(5878);
1539             Number n2 = new Number(1234);
1540             int result;
1541             try (ForceGCMarker m = ForceGCMarker.mark(warmup)) {
1542                 result = test64(rpa, rp1, rp2, n1, rp3, rp4, n2);
1543             }
1544             int n = test64_helper(rpa, rp1, rp2, n1, rp3, rp4, n2);
1545             Asserts.assertEQ(result, n);
1546         }
1547     }
1548 
1549     // C2-&gt;C1 invokevirtual via VVEP(RO) (opt_virtual_call)
1550     @Test(compLevel = C2)
1551     public int test76(RefPoint rp1, RefPoint rp2) {
1552         return rp1.final_func(rp2);
1553     }
1554 
1555     @DontCompile
1556     public void test76_verifier(boolean warmup) {
1557         int count = warmup ? 1 : 5;
1558         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1559             RefPoint rp1 = refPointField1;
1560             RefPoint rp2 = refPointField2;
1561             int result = test76(rp1, rp2);
1562             int n = rp1.final_func(rp2);
1563             Asserts.assertEQ(result, n);
1564         }
1565     }
1566 
1567     // C2-&gt;C1 invokevirtual, force GC for every allocation when entering a C1 VEP (RefPoint)
1568     // Same as test56, except we call the VVEP(RO) instead of VEP.
1569     @Test(compLevel = C2)
1570     public int test77(RefPoint rp1, RefPoint rp2) {
1571         return rp1.final_func(rp2);
1572     }
1573 
1574     @DontCompile
1575     public void test77_verifier(boolean warmup) {
1576         int count = warmup ? 1 : 5;
1577         for (int i=0; i&lt;count; i++) { // need a loop to test inline cache
1578             RefPoint rp1 = new RefPoint(1, 2);
1579             RefPoint rp2 = new RefPoint(22, 33);
1580             int result;
1581             try (ForceGCMarker m = ForceGCMarker.mark(warmup)) {
1582                 result = test77(rp1, rp2);
1583             }
1584             int n = rp1.final_func(rp2);
1585             Asserts.assertEQ(result, n);
1586         }
1587     }
1588 
1589     //-------------------------------------------------------------------------------
1590     // Tests for how C1 handles InlineTypeReturnedAsFields in both calls and returns
1591     //-------------------------------------------------------------------------------
1592     // C2-&gt;C1 invokestatic with InlineTypeReturnedAsFields (Point)
1593     @Test(compLevel = C2)
1594     public int test78(Point p) {
1595         Point np = test78_helper(p);
1596         return np.x + np.y;
1597     }
1598 
1599     @DontInline
1600     @ForceCompile(compLevel = C1)
1601     private static Point test78_helper(Point p) {
1602         return p;
1603     }
1604 
1605     @DontCompile
1606     public void test78_verifier(boolean warmup) {
1607         int result = test78(pointField1);
1608         int n = pointField1.x + pointField1.y;
1609         Asserts.assertEQ(result, n);
1610     }
1611 
1612     // C2-&gt;C1 invokestatic with InlineTypeReturnedAsFields (RefPoint)
1613     @Test(compLevel = C2)
1614     public int test79(RefPoint p) {
1615         RefPoint np = test79_helper(p);
1616         return np.x.n + np.y.n;
1617     }
1618 
1619     @DontInline
1620     @ForceCompile(compLevel = C1)
1621     private static RefPoint test79_helper(RefPoint p) {
1622         return p;
1623     }
1624 
1625     @DontCompile
1626     public void test79_verifier(boolean warmup) {
1627         int result = test79(refPointField1);
1628         int n = refPointField1.x.n + refPointField1.y.n;
1629         Asserts.assertEQ(result, n);
1630     }
1631 
1632     // C1-&gt;C2 invokestatic with InlineTypeReturnedAsFields (RefPoint)
1633     @Test(compLevel = C1)
1634     public int test80(RefPoint p) {
1635         RefPoint np = test80_helper(p);
1636         return np.x.n + np.y.n;
1637     }
1638 
1639     @DontInline
1640     @ForceCompile(compLevel = C2)
1641     private static RefPoint test80_helper(RefPoint p) {
1642         return p;
1643     }
1644 
1645     @DontCompile
1646     public void test80_verifier(boolean warmup) {
1647         int result = test80(refPointField1);
1648         int n = refPointField1.x.n + refPointField1.y.n;
1649         Asserts.assertEQ(result, n);
1650     }
1651 
1652     // Interpreter-&gt;C1 invokestatic with InlineTypeReturnedAsFields (Point)
1653     @Test(compLevel = C1)
1654     public Point test81(Point p) {
1655         return p;
1656     }
1657 
1658     @DontCompile
1659     public void test81_verifier(boolean warmup) {
1660         Point p = test81(pointField1);
1661         Asserts.assertEQ(p.x, pointField1.x);
1662         Asserts.assertEQ(p.y, pointField1.y);
1663         p = test81(pointField2);
1664         Asserts.assertEQ(p.x, pointField2.x);
1665         Asserts.assertEQ(p.y, pointField2.y);
1666     }
1667 
1668     // C1-&gt;Interpreter invokestatic with InlineTypeReturnedAsFields (RefPoint)
1669     @Test(compLevel = C1)
1670     public int test82(RefPoint p) {
1671         RefPoint np = test82_helper(p);
1672         return np.x.n + np.y.n;
1673     }
1674 
1675     @DontInline @DontCompile
1676     private static RefPoint test82_helper(RefPoint p) {
1677         return p;
1678     }
1679 
1680     @DontCompile
1681     public void test82_verifier(boolean warmup) {
1682         int result = test82(refPointField1);
1683         int n = refPointField1.x.n + refPointField1.y.n;
1684         Asserts.assertEQ(result, n);
1685     }
1686 
1687     //-------------------------------------------------------------------------------
1688     // Tests for InlineTypeReturnedAsFields vs the inline class TooBigToReturnAsFields
1689     //-------------------------------------------------------------------------------
1690 
1691     // C2-&gt;C1 invokestatic with InlineTypeReturnedAsFields (TooBigToReturnAsFields)
1692     @Test(compLevel = C2)
1693     public int test83(TooBigToReturnAsFields p) {
1694         TooBigToReturnAsFields np = test83_helper(p);
1695         return p.a0 + p.a5;
1696     }
1697 
1698     @DontInline
1699     @ForceCompile(compLevel = C1)
1700     private static TooBigToReturnAsFields test83_helper(TooBigToReturnAsFields p) {
1701         return p;
1702     }
1703 
1704     @DontCompile
1705     public void test83_verifier(boolean warmup) {
1706         int result = test83(tooBig);
1707         int n = tooBig.a0 + tooBig.a5;
1708         Asserts.assertEQ(result, n);
1709     }
1710 
1711     // C1-&gt;C2 invokestatic with InlineTypeReturnedAsFields (TooBigToReturnAsFields)
1712     @Test(compLevel = C1)
1713     public int test84(TooBigToReturnAsFields p) {
1714         TooBigToReturnAsFields np = test84_helper(p);
1715         return p.a0 + p.a5;
1716     }
1717 
1718     @DontInline
1719     @ForceCompile(compLevel = C2)
1720     private static TooBigToReturnAsFields test84_helper(TooBigToReturnAsFields p) {
1721         return p;
1722     }
1723 
1724     @DontCompile
1725     public void test84_verifier(boolean warmup) {
1726         int result = test84(tooBig);
1727         int n = tooBig.a0 + tooBig.a5;
1728         Asserts.assertEQ(result, n);
1729     }
1730 
1731     // Interpreter-&gt;C1 invokestatic with InlineTypeReturnedAsFields (TooBigToReturnAsFields)
1732     @Test(compLevel = C1)
1733     public TooBigToReturnAsFields test85(TooBigToReturnAsFields p) {
1734         return p;
1735     }
1736 
1737     @DontCompile
1738     public void test85_verifier(boolean warmup) {
1739         TooBigToReturnAsFields p = test85(tooBig);
1740         Asserts.assertEQ(p.a0, tooBig.a0);
1741         Asserts.assertEQ(p.a2, tooBig.a2);
1742     }
1743 
1744     // C1-&gt;Interpreter invokestatic with InlineTypeReturnedAsFields (TooBigToReturnAsFields)
1745     @Test(compLevel = C1)
1746     public int test86(TooBigToReturnAsFields p) {
1747         TooBigToReturnAsFields np = test86_helper(p);
1748         return p.a0 + p.a5;
1749     }
1750 
1751     @DontInline @DontCompile
1752     private static TooBigToReturnAsFields test86_helper(TooBigToReturnAsFields p) {
1753         return p;
1754     }
1755 
1756     @DontCompile
1757     public void test86_verifier(boolean warmup) {
1758         int result = test86(tooBig);
1759         int n = tooBig.a0 + tooBig.a5;
1760         Asserts.assertEQ(result, n);
1761     }
1762 
1763     //-------------------------------------------------------------------------------
1764     // Tests for how C1 handles InlineTypeReturnedAsFields in both calls and returns (RefPoint?)
1765     //-------------------------------------------------------------------------------
1766 
1767     // C2-&gt;C1 invokestatic with InlineTypeReturnedAsFields (RefPoint.ref)
1768     @Test(compLevel = C2)
1769     public RefPoint.ref test87(RefPoint.ref p) {
1770         return test87_helper(p);
1771     }
1772 
1773     @DontInline
1774     @ForceCompile(compLevel = C1)
1775     private static RefPoint.ref test87_helper(RefPoint.ref p) {
1776         return p;
1777     }
1778 
1779     @DontCompile
1780     public void test87_verifier(boolean warmup) {
1781         Object result = test87(null);
1782         Asserts.assertEQ(result, null);
1783     }
1784 
1785     // C2-&gt;C1 invokestatic with InlineTypeReturnedAsFields (RefPoint.ref with constant null)
1786     @Test(compLevel = C2)
1787     public RefPoint.ref test88() {
1788         return test88_helper();
1789     }
1790 
1791     @DontInline
1792     @ForceCompile(compLevel = C1)
1793     private static RefPoint.ref test88_helper() {
1794         return null;
1795     }
1796 
1797     @DontCompile
1798     public void test88_verifier(boolean warmup) {
1799         Object result = test88();
1800         Asserts.assertEQ(result, null);
1801     }
1802 
1803     // C1-&gt;C2 invokestatic with InlineTypeReturnedAsFields (RefPoint.ref)
1804     @Test(compLevel = C1)
1805     public RefPoint.ref test89(RefPoint.ref p) {
1806         return test89_helper(p);
1807     }
1808 
1809     @DontInline
1810     @ForceCompile(compLevel = C2)
1811     private static RefPoint.ref test89_helper(RefPoint.ref p) {
1812         return p;
1813     }
1814 
1815     @DontCompile
1816     public void test89_verifier(boolean warmup) {
1817         Object result = test89(null);
1818         Asserts.assertEQ(result, null);
1819     }
1820 
1821     //----------------------------------------------------------------------------------
1822     // Tests for unverified entries: there are 6 cases:
1823     // C1 -&gt; Unverified Value Entry compiled by C1
1824     // C1 -&gt; Unverified Value Entry compiled by C2
1825     // C2 -&gt; Unverified Entry compiled by C1 (target is NOT an inline type)
1826     // C2 -&gt; Unverified Entry compiled by C2 (target is NOT an inline type)
1827     // C2 -&gt; Unverified Entry compiled by C1 (target IS an inline type, i.e., has VVEP_RO)
1828     // C2 -&gt; Unverified Entry compiled by C2 (target IS an inline type, i.e., has VVEP_RO)
1829     //----------------------------------------------------------------------------------
1830 
1831     // C1-&gt;C1 invokeinterface -- call Unverified Value Entry of MyImplPojo1.func2 (compiled by C1)
1832     @Test(compLevel = C1)
1833     public int test90(Intf intf, int a, int b) {
1834         return intf.func2(a, b, pointField);
1835     }
1836 
1837     static Intf test90_intfs[] = {
1838         new MyImplPojo1(),
1839         new MyImplPojo2(),
1840     };
1841 
1842     @DontCompile
1843     public void test90_verifier(boolean warmup) {
1844         int count = warmup ? 1 : 20;
1845         for (int i=0; i&lt;count; i++) {
1846             Intf intf = test90_intfs[i % test90_intfs.length];
1847             int result = test90(intf, 123, 456) + i;
1848             Asserts.assertEQ(result, intf.func2(123, 456, pointField) + i);
1849         }
1850     }
1851 
1852     // C1-&gt;C2 invokeinterface -- call Unverified Value Entry of MyImplPojo2.func2 (compiled by C2)
1853     @Test(compLevel = C1)
1854     public int test91(Intf intf, int a, int b) {
1855         return intf.func2(a, b, pointField);
1856     }
1857 
1858     static Intf test91_intfs[] = {
1859         new MyImplPojo2(),
1860         new MyImplPojo1(),
1861     };
1862 
1863     @DontCompile
1864     public void test91_verifier(boolean warmup) {
1865         int count = warmup ? 1 : 20;
1866         for (int i=0; i&lt;count; i++) {
1867             Intf intf = test91_intfs[i % test91_intfs.length];
1868             int result = test91(intf, 123, 456) + i;
1869             Asserts.assertEQ(result, intf.func2(123, 456, pointField) + i);
1870         }
1871     }
1872 
1873     // C2-&gt;C1 invokeinterface -- call Unverified Entry of MyImplPojo1.func2 (compiled by C1)
1874     @Test(compLevel = C2)
1875     public int test92(Intf intf, int a, int b) {
1876         return intf.func2(a, b, pointField);
1877     }
1878 
1879     static Intf test92_intfs[] = {
1880         new MyImplPojo1(),
1881         new MyImplPojo2(),
1882     };
1883 
1884     @DontCompile
1885     public void test92_verifier(boolean warmup) {
1886         int count = warmup ? 1 : 20;
1887         for (int i=0; i&lt;count; i++) {
1888             Intf intf = test92_intfs[i % test92_intfs.length];
1889             int result = test92(intf, 123, 456) + i;
1890             Asserts.assertEQ(result, intf.func2(123, 456, pointField) + i);
1891         }
1892     }
1893 
1894     // C2-&gt;C2 invokeinterface -- call Unverified Entry of MyImplPojo2.func2 (compiled by C2)
1895     @Test(compLevel = C2)
1896     public int test93(Intf intf, int a, int b) {
1897         return intf.func2(a, b, pointField);
1898     }
1899 
1900     static Intf test93_intfs[] = {
1901         new MyImplPojo2(),
1902         new MyImplPojo1(),
1903     };
1904 
1905     @DontCompile
1906     public void test93_verifier(boolean warmup) {
1907         int count = warmup ? 1 : 20;
1908         for (int i=0; i&lt;count; i++) {
1909             Intf intf = test93_intfs[i % test93_intfs.length];
1910             int result = test93(intf, 123, 456) + i;
1911             Asserts.assertEQ(result, intf.func2(123, 456, pointField) + i);
1912         }
1913     }
1914 
1915     // C2-&gt;C1 invokeinterface -- call Unverified Entry of MyImplVal1.func2 (compiled by C1 - has VVEP_RO)
1916     @Test(compLevel = C2)
1917     public int test94(Intf intf, int a, int b) {
1918         return intf.func2(a, b, pointField);
1919     }
1920 
1921     static Intf test94_intfs[] = {
1922         new MyImplVal1(),
1923         new MyImplVal2(),
1924     };
1925 
1926     @DontCompile
1927     public void test94_verifier(boolean warmup) {
1928         int count = warmup ? 1 : 20;
1929         for (int i=0; i&lt;count; i++) {
1930             Intf intf = test94_intfs[i % test94_intfs.length];
1931             int result = test94(intf, 123, 456) + i;
1932             Asserts.assertEQ(result, intf.func2(123, 456, pointField) + i);
1933         }
1934     }
1935 
1936     // C2-&gt;C2 invokeinterface -- call Unverified Entry of MyImplVal2.func2 (compiled by C2 - has VVEP_RO)
1937     @Test(compLevel = C2)
1938     public int test95(Intf intf, int a, int b) {
1939         return intf.func2(a, b, pointField);
1940     }
1941 
1942     static Intf test95_intfs[] = {
1943         new MyImplVal2(),
1944         new MyImplVal1(),
1945     };
1946 
1947     @DontCompile
1948     public void test95_verifier(boolean warmup) {
1949         int count = warmup ? 1 : 20;
1950         for (int i=0; i&lt;count; i++) {
1951             Intf intf = test95_intfs[i % test95_intfs.length];
1952             int result = test95(intf, 123, 456) + i;
1953             Asserts.assertEQ(result, intf.func2(123, 456, pointField) + i);
1954         }
1955     }
1956 
1957     // C1-&gt;C2 GC handling in StubRoutines::store_inline_type_fields_to_buf()
1958     @Test(compLevel = C1)
1959     public RefPoint test96(RefPoint rp, boolean b) {
1960         RefPoint p = test96_helper(rp);
1961         if (b) {
1962             return rp;
1963         }
1964         return p;
1965     }
1966 
1967     @DontInline @ForceCompile(compLevel = C2)
1968     public RefPoint test96_helper(RefPoint rp) {
1969         return rp;
1970     }
1971 
1972     @DontCompile
1973     public void test96_verifier(boolean warmup) {
1974         int count = warmup ? 1 : 20000; // Do enough iteration to cause GC inside StubRoutines::store_inline_type_fields_to_buf
1975         Number x = new Number(10); // old object
1976         for (int i=0; i&lt;count; i++) {
1977             Number y = new Number(i); // new object for each iteraton
1978             RefPoint rp1 = new RefPoint(x, y);
1979             RefPoint rp2 = test96(rp1, warmup);
1980 
1981             Asserts.assertEQ(rp1.x, x);
1982             Asserts.assertEQ(rp1.y, y);
1983             Asserts.assertEQ(rp1.y.n, i);
1984         }
1985     }
1986 
1987     // C1-&gt;C1  - caller is compiled first. It invokes callee(test97) a few times while the
1988     //           callee is executed by the interpreter. Then, callee is compiled
1989     //           and SharedRuntime::fixup_callers_callsite is called to fix up the
1990     //           callsite from test97_verifier-&gt;test97.
1991     @Test(compLevel = C1)
1992     public int test97(Point p1, Point p2) {
1993         return test97_helper(p1, p2);
1994     }
1995 
1996     @DontInline @DontCompile
1997     public int test97_helper(Point p1, Point p2) {
1998         return p1.x + p1.y + p2.x + p2.y;
1999     }
2000 
2001     @ForceCompile(compLevel = C1)
2002     public void test97_verifier(boolean warmup) {
2003         int count = warmup ? 1 : 20;
2004         for (int i=0; i&lt;count; i++) {
2005             int result = test97(pointField1, pointField2);
2006             int n = test97_helper(pointField1, pointField2);
2007             Asserts.assertEQ(result, n);
2008         }
2009     }
2010 
2011     // C1-&gt;C2  - same as test97, except the callee is compiled by c2.
2012     @Test(compLevel = C2)
2013     public int test98(Point p1, Point p2) {
2014         return test98_helper(p1, p2);
2015     }
2016 
2017     @DontInline @DontCompile
2018     public int test98_helper(Point p1, Point p2) {
2019         return p1.x + p1.y + p2.x + p2.y;
2020     }
2021 
2022     @ForceCompile(compLevel = C1)
2023     public void test98_verifier(boolean warmup) {
2024         int count = warmup ? 1 : 20;
2025         for (int i=0; i&lt;count; i++) {
2026             int result = test98(pointField1, pointField2);
2027             int n = test98_helper(pointField1, pointField2);
2028             Asserts.assertEQ(result, n);
2029         }
2030     }
2031 
2032     // C1-&gt;C2  - same as test97, except the callee is a static method.
2033     @Test(compLevel = C1)
2034     public static int test99(Point p1, Point p2) {
2035         return test99_helper(p1, p2);
2036     }
2037 
2038     @DontInline @DontCompile
2039     public static int test99_helper(Point p1, Point p2) {
2040         return p1.x + p1.y + p2.x + p2.y;
2041     }
2042 
2043     @ForceCompile(compLevel = C1)
2044     public void test99_verifier(boolean warmup) {
2045         int count = warmup ? 1 : 20;
2046         for (int i=0; i&lt;count; i++) {
2047             int result = test99(pointField1, pointField2);
2048             int n = test99_helper(pointField1, pointField2);
2049             Asserts.assertEQ(result, n);
2050         }
2051     }
2052 
2053 
2054     // C2-&gt;C1 invokestatic, packing causes stack growth (1 extra stack word).
2055     // Make sure stack frame is set up properly for GC.
2056     @Test(compLevel = C2)
2057     public float test100(FloatPoint fp1, FloatPoint fp2, RefPoint rp, int a1, int a2, int a3, int a4) {
2058         return test100_helper(fp1, fp2, rp, a1, a2, a3, a4);
2059     }
2060 
2061     @DontInline
2062     @ForceCompile(compLevel = C1)
2063     private static float test100_helper(FloatPoint fp1, FloatPoint fp2, RefPoint rp, int a1, int a2, int a3, int a4) {
2064         // On x64:
2065         //    Scalarized entry -- all parameters are passed in registers
2066         //          xmm0 = fp1.x
2067         //          xmm1 = fp1.y
2068         //          xmm2 = fp2.x
2069         //          xmm3 = fp2.y
2070         //          rsi  = rp.x  (oop)
2071         //          rdx  = rp.y  (oop)
2072         //          cx   = a1
2073         //          r8   = a2
2074         //          r9   = a3
2075         //          di   = a4
2076         //    Non-scalarized entry -- a6 is passed on stack[0]
2077         //          rsi  = fp1
2078         //          rdx  = fp2
2079         //          rcx  = rp
2080         //          r8   = a1
2081         //          r9   = a2
2082         //          di   = a3
2083         //    [sp + ??]  = a4
2084         return fp1.x + fp1.y + fp2.x + fp2.y + rp.x.n + rp.y.n + a1 + a2 + a3 + a4;
2085     }
2086 
2087     @DontCompile
2088     public void test100_verifier(boolean warmup) {
2089         int count = warmup ? 1 : 4;
2090         for (int i=0; i&lt;count; i++) {
2091             FloatPoint fp1 = new FloatPoint(i+0,  i+11);
2092             FloatPoint fp2 = new FloatPoint(i+222, i+3333);
2093             RefPoint rp = new RefPoint(i+44444, i+555555);
2094             float result;
2095             try (ForceGCMarker m = ForceGCMarker.mark(warmup)) {
2096                 result = test100(fp1, fp2, rp, 1, 2, 3, 4);
2097             }
2098             float n = test100_helper(fp1, fp2, rp, 1, 2, 3, 4);
2099             Asserts.assertEQ(result, n);
2100         }
2101     }
2102 
2103     // C1-&gt;C2 force GC for every allocation when storing the returned
2104     // fields back into a buffered object.
2105     @Test(compLevel = C1)
2106     public RefPoint test101(RefPoint rp) {
2107         return test101_helper(rp);
2108     }
2109 
2110     @ForceCompile(compLevel = C2) @DontInline
2111     public RefPoint test101_helper(RefPoint rp) {
2112         return rp;
2113     }
2114 
2115     @DontCompile
2116     public void test101_verifier(boolean warmup) {
2117         int count = warmup ? 1 : 5;
2118         for (int i=0; i&lt;count; i++) {
2119             RefPoint rp = new RefPoint(1, 2);
2120             Object x = rp.x;
2121             Object y = rp.y;
2122             RefPoint result = new RefPoint(3, 4);
2123             try (ForceGCMarker m = ForceGCMarker.mark(warmup)) {
2124                 result = test101(rp);
2125             }
2126             Asserts.assertEQ(rp.x, result.x);
2127             Asserts.assertEQ(rp.y, result.y);
2128             Asserts.assertEQ(x, result.x);
2129             Asserts.assertEQ(y, result.y);
2130         }
2131     }
2132 
2133     // Same as test101, except we have Interpreter-&gt;C2 instead.
2134     @Test(compLevel = C1)
2135     public RefPoint test102(RefPoint rp) {
2136         return test102_interp(rp);
2137     }
2138 
2139     @DontCompile @DontInline
2140     public RefPoint test102_interp(RefPoint rp) {
2141         return test102_helper(rp);
2142     }
2143 
2144     @ForceCompile(compLevel = C2) @DontInline
2145     public RefPoint test102_helper(RefPoint rp) {
2146         return rp;
2147     }
2148 
2149     @DontCompile
2150     public void test102_verifier(boolean warmup) {
2151         int count = warmup ? 1 : 5;
2152         for (int i=0; i&lt;count; i++) {
2153             RefPoint rp = new RefPoint(11, 22);
2154             Object x = rp.x;
2155             Object y = rp.y;
2156             RefPoint result = new RefPoint(333, 444);
2157             try (ForceGCMarker m = ForceGCMarker.mark(warmup)) {
2158                 result = test102(rp);
2159             }
2160             Asserts.assertEQ(rp.x, result.x);
2161             Asserts.assertEQ(rp.y, result.y);
2162             Asserts.assertEQ(x, result.x);
2163             Asserts.assertEQ(y, result.y);
2164         }
2165     }
2166 
2167     @Test(compLevel = C1)
2168     public void test103() {
2169         // when this method is compiled by C1, the Test103Value class is not yet loaded.
2170         test103_v = new Test103Value(); // invokestatic &quot;Test103Value.&lt;init&gt;()QTest103Value;&quot;
2171     }
2172 
2173     static inline class Test103Value {
2174         int x = rI;
2175     }
2176 
2177     static Object test103_v;
2178 
2179     @DontCompile
2180     public void test103_verifier(boolean warmup) {
2181         if (warmup) {
2182             // Make sure test103() is compiled before Test103Value is loaded
2183             return;
2184         }
2185         test103();
2186         Test103Value v = (Test103Value)test103_v;
2187         Asserts.assertEQ(v.x, rI);
2188     }
2189 
2190 
2191     // Same as test103, but with an inline class that&#39;s too big to return as fields.
2192     @Test(compLevel = C1)
2193     public void test104() {
2194         // when this method is compiled by C1, the Test104Value class is not yet loaded.
2195         test104_v = new Test104Value(); // invokestatic &quot;Test104Value.&lt;init&gt;()QTest104Value;&quot;
2196     }
2197 
2198     static inline class Test104Value {
2199         long x0 = rL;
2200         long x1 = rL;
2201         long x2 = rL;
2202         long x3 = rL;
2203         long x4 = rL;
2204         long x5 = rL;
2205         long x6 = rL;
2206         long x7 = rL;
2207         long x8 = rL;
2208         long x9 = rL;
2209         long xa = rL;
2210         long xb = rL;
2211         long xc = rL;
2212         long xd = rL;
2213         long xe = rL;
2214         long xf = rL;
2215     }
2216 
2217     static Object test104_v;
2218 
2219     @DontCompile
2220     public void test104_verifier(boolean warmup) {
2221         if (warmup) {
2222             // Make sure test104() is compiled before Test104Value is loaded
2223             return;
2224         }
2225         test104();
2226         Test104Value v = (Test104Value)test104_v;
2227         Asserts.assertEQ(v.x0, rL);
2228     }
2229 
2230     // C2-&gt;C1 invokeinterface -- call Unverified Entry of MyImplVal1.func1 (compiled by C1 - has VVEP_RO)
2231     /// (same as test94, except we are calling func1, which shares VVEP and VVEP_RO
2232     @Test(compLevel = C2)
2233     public int test105(Intf intf, int a, int b) {
2234         return intf.func1(a, b);
2235     }
2236 
2237     static Intf test105_intfs[] = {
2238         new MyImplVal1(),
2239         new MyImplVal2(),
2240     };
2241 
2242     @DontCompile
2243     public void test105_verifier(boolean warmup) {
2244         int count = warmup ? 1 : 20;
2245         for (int i=0; i&lt;count; i++) {
2246             Intf intf = test105_intfs[i % test105_intfs.length];
2247             int result = test105(intf, 123, 456) + i;
2248             Asserts.assertEQ(result, intf.func1(123, 456) + i);
2249         }
2250     }
2251 
2252     // C2-&gt;C2 invokeinterface -- call Unverified Entry of MyImplVal2.func1 (compiled by C2 - has VVEP_RO)
2253     /// (same as test95, except we are calling func1, which shares VVEP and VVEP_RO
2254     @Test(compLevel = C2)
2255     public int test106(Intf intf, int a, int b) {
2256         return intf.func1(a, b);
2257     }
2258 
2259     static Intf test106_intfs[] = {
2260         new MyImplVal2(),
2261         new MyImplVal1(),
2262     };
2263 
2264     @DontCompile
2265     public void test106_verifier(boolean warmup) {
2266         int count = warmup ? 1 : 20;
2267         for (int i=0; i&lt;count; i++) {
2268             Intf intf = test106_intfs[i % test106_intfs.length];
2269             int result = test106(intf, 123, 456) + i;
2270             Asserts.assertEQ(result, intf.func1(123, 456) + i);
2271         }
2272     }
2273 
2274     // C2-&gt;C1 invokeinterface -- C2 calls call Unverified Entry of MyImplVal2X.func1 (compiled by
2275     //                           C1, with VVEP_RO==VVEP)
2276     // This test is developed to validate JDK-8230325.
2277     @Test() @Warmup(0) @OSRCompileOnly
2278     public int test107(Intf intf, int a, int b) {
2279         return intf.func1(a, b);
2280     }
2281 
2282     @ForceCompile
2283     public void test107_verifier(boolean warmup) {
2284         Intf intf1 = new MyImplVal1X();
2285         Intf intf2 = new MyImplVal2X();
2286 
2287         for (int i=0; i&lt;1000; i++) {
2288             test107(intf1, 123, 456);
2289         }
2290         for (int i=0; i&lt;500_000; i++) {
2291             // Run enough loops so that test107 will be compiled by C2.
2292             if (i % 30 == 0) {
2293                 // This will indirectly call MyImplVal2X.func1, but the call frequency is low, so
2294                 // test107 will be compiled by C2, but MyImplVal2X.func1 will compiled by C1 only.
2295                 int result = test107(intf2, 123, 456) + i;
2296                 Asserts.assertEQ(result, intf2.func1(123, 456) + i);
2297             } else {
2298                 // Call test107 with a mix of intf1 and intf2, so C2 will use a virtual call (not an optimized call)
2299                 // for the invokeinterface bytecode in test107.
2300                 test107(intf1, 123, 456);
2301             }
2302         }
2303     }
2304 
2305     // Same as test107, except we call MyImplVal2X.func2 (compiled by C1, VVEP_RO != VVEP)
2306     @Test() @Warmup(0) @OSRCompileOnly
2307     public int test108(Intf intf, int a, int b) {
2308         return intf.func2(a, b, pointField);
2309     }
2310 
2311     @ForceCompile
2312     public void test108_verifier(boolean warmup) {
2313         Intf intf1 = new MyImplVal1X();
2314         Intf intf2 = new MyImplVal2X();
2315 
2316         for (int i=0; i&lt;1000; i++) {
2317             test108(intf1, 123, 456);
2318         }
2319         for (int i=0; i&lt;500_000; i++) {
2320             // Run enough loops so that test108 will be compiled by C2.
2321             if (i % 30 == 0) {
2322                 // This will indirectly call MyImplVal2X.func2, but the call frequency is low, so
2323                 // test108 will be compiled by C2, but MyImplVal2X.func2 will compiled by C1 only.
2324                 int result = test108(intf2, 123, 456) + i;
2325                 Asserts.assertEQ(result, intf2.func2(123, 456, pointField) + i);
2326             } else {
2327                 // Call test108 with a mix of intf1 and intf2, so C2 will use a virtual call (not an optimized call)
2328                 // for the invokeinterface bytecode in test108.
2329                 test108(intf1, 123, 456);
2330             }
2331         }
2332     }
2333 
2334     // Same as test107, except we call MyImplPojo3.func2 (compiled by C1, VVEP_RO == VEP)
2335     @Test() @Warmup(0) @OSRCompileOnly
2336     public int test109(Intf intf, int a, int b) {
2337         return intf.func2(a, b, pointField);
2338     }
2339 
2340     @ForceCompile
2341     public void test109_verifier(boolean warmup) {
2342         Intf intf1 = new MyImplPojo0();
2343         Intf intf2 = new MyImplPojo3();
2344 
2345         for (int i=0; i&lt;1000; i++) {
2346             test109(intf1, 123, 456);
2347         }
2348         for (int i=0; i&lt;500_000; i++) {
2349             // Run enough loops so that test109 will be compiled by C2.
2350             if (i % 30 == 0) {
2351                 // This will indirectly call MyImplPojo3.func2, but the call frequency is low, so
2352                 // test109 will be compiled by C2, but MyImplPojo3.func2 will compiled by C1 only.
2353                 int result = test109(intf2, 123, 456) + i;
2354                 Asserts.assertEQ(result, intf2.func2(123, 456, pointField) + i);
2355             } else {
2356                 // Call test109 with a mix of intf1 and intf2, so C2 will use a virtual call (not an optimized call)
2357                 // for the invokeinterface bytecode in test109.
2358                 test109(intf1, 123, 456);
2359             }
2360         }
2361     }
2362 }
    </pre>
  </body>
</html>
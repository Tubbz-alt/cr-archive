<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/c1_LIRGenerator_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="../x86/c1_LIRGenerator_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/c1_LIRGenerator_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1211   // in case of patching (i.e., object class is not yet loaded), we need to reexecute the instruction
1212   // and therefore provide the state before the parameters have been consumed
1213   CodeEmitInfo* patching_info = NULL;
1214   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1215     patching_info =  state_for(x, x-&gt;state_before());
1216   }
1217 
1218   CodeEmitInfo* info = state_for(x, x-&gt;state());
1219 
1220   LIR_Opr reg = result_register_for(x-&gt;type());
1221   LIR_Opr tmp1 = FrameMap::r2_oop_opr;
1222   LIR_Opr tmp2 = FrameMap::r4_oop_opr;
1223   LIR_Opr tmp3 = FrameMap::r5_oop_opr;
1224   LIR_Opr tmp4 = reg;
1225   LIR_Opr klass_reg = FrameMap::r3_metadata_opr;
1226 
1227   length.load_item_force(FrameMap::r19_opr);
1228   LIR_Opr len = length.result();
1229 
1230   ciKlass* obj = (ciKlass*) x-&gt;exact_type();
<span class="line-modified">1231   CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, x-&gt;is_never_null());</span>
1232   if (obj == ciEnv::unloaded_ciobjarrayklass()) {
1233     BAILOUT(&quot;encountered unloaded_ciobjarrayklass due to out of memory error&quot;);
1234   }
1235 
1236   klass2reg_with_patching(klass_reg, obj, patching_info);
<span class="line-modified">1237   if (x-&gt;is_never_null()) {</span>
1238     __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_INLINE_TYPE, klass_reg, slow_path);
1239   } else {
1240     __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);
1241   }
1242 
1243   LIR_Opr result = rlock_result(x);
1244   __ move(reg, result);
1245 }
1246 
1247 
1248 void LIRGenerator::do_NewMultiArray(NewMultiArray* x) {
1249   Values* dims = x-&gt;dims();
1250   int i = dims-&gt;length();
1251   LIRItemList* items = new LIRItemList(i, i, NULL);
1252   while (i-- &gt; 0) {
1253     LIRItem* size = new LIRItem(dims-&gt;at(i), this);
1254     items-&gt;at_put(i, size);
1255   }
1256 
1257   // Evaluate state_for early since it may emit code.
</pre>
<hr />
<pre>
1297 
1298 void LIRGenerator::do_BlockBegin(BlockBegin* x) {
1299   // nothing to do for now
1300 }
1301 
1302 void LIRGenerator::do_CheckCast(CheckCast* x) {
1303   LIRItem obj(x-&gt;obj(), this);
1304 
1305   CodeEmitInfo* patching_info = NULL;
1306   if (!x-&gt;klass()-&gt;is_loaded() || (PatchALot &amp;&amp; !x-&gt;is_incompatible_class_change_check() &amp;&amp; !x-&gt;is_invokespecial_receiver_check())) {
1307     // must do this before locking the destination register as an oop register,
1308     // and before the obj is loaded (the latter is for deoptimization)
1309     patching_info = state_for(x, x-&gt;state_before());
1310   }
1311   obj.load_item();
1312 
1313   // info for exceptions
1314   CodeEmitInfo* info_for_exception =
1315       (x-&gt;needs_exception_state() ? state_for(x) :
1316                                     state_for(x, x-&gt;state_before(), true /*ignore_xhandler*/));
<span class="line-modified">1317   if (x-&gt;is_never_null()) {</span>
1318     __ null_check(obj.result(), new CodeEmitInfo(info_for_exception));
1319   }
1320 
1321   CodeStub* stub;
1322   if (x-&gt;is_incompatible_class_change_check()) {
1323     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1324     stub = new SimpleExceptionStub(Runtime1::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);
1325   } else if (x-&gt;is_invokespecial_receiver_check()) {
1326     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1327     stub = new DeoptimizeStub(info_for_exception,
1328                               Deoptimization::Reason_class_check,
1329                               Deoptimization::Action_none);
1330   } else {
1331     stub = new SimpleExceptionStub(Runtime1::throw_class_cast_exception_id, obj.result(), info_for_exception);
1332   }
1333   LIR_Opr reg = rlock_result(x);
1334   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1335   if (!x-&gt;klass()-&gt;is_loaded() || UseCompressedClassPointers) {
1336     tmp3 = new_register(objectType);
1337   }
1338 
1339 
1340   __ checkcast(reg, obj.result(), x-&gt;klass(),
1341                new_register(objectType), new_register(objectType), tmp3,
1342                x-&gt;direct_compare(), info_for_exception, patching_info, stub,
<span class="line-modified">1343                x-&gt;profiled_method(), x-&gt;profiled_bci(), x-&gt;is_never_null());</span>
1344 
1345 }
1346 
1347 void LIRGenerator::do_InstanceOf(InstanceOf* x) {
1348   LIRItem obj(x-&gt;obj(), this);
1349 
1350   // result and test object may not be in same register
1351   LIR_Opr reg = rlock_result(x);
1352   CodeEmitInfo* patching_info = NULL;
1353   if ((!x-&gt;klass()-&gt;is_loaded() || PatchALot)) {
1354     // must do this before locking the destination register as an oop register
1355     patching_info = state_for(x, x-&gt;state_before());
1356   }
1357   obj.load_item();
1358   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1359   if (!x-&gt;klass()-&gt;is_loaded() || UseCompressedClassPointers) {
1360     tmp3 = new_register(objectType);
1361   }
1362   __ instanceof(reg, obj.result(), x-&gt;klass(),
1363                 new_register(objectType), new_register(objectType), tmp3,
</pre>
</td>
<td>
<hr />
<pre>
1211   // in case of patching (i.e., object class is not yet loaded), we need to reexecute the instruction
1212   // and therefore provide the state before the parameters have been consumed
1213   CodeEmitInfo* patching_info = NULL;
1214   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1215     patching_info =  state_for(x, x-&gt;state_before());
1216   }
1217 
1218   CodeEmitInfo* info = state_for(x, x-&gt;state());
1219 
1220   LIR_Opr reg = result_register_for(x-&gt;type());
1221   LIR_Opr tmp1 = FrameMap::r2_oop_opr;
1222   LIR_Opr tmp2 = FrameMap::r4_oop_opr;
1223   LIR_Opr tmp3 = FrameMap::r5_oop_opr;
1224   LIR_Opr tmp4 = reg;
1225   LIR_Opr klass_reg = FrameMap::r3_metadata_opr;
1226 
1227   length.load_item_force(FrameMap::r19_opr);
1228   LIR_Opr len = length.result();
1229 
1230   ciKlass* obj = (ciKlass*) x-&gt;exact_type();
<span class="line-modified">1231   CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, x-&gt;is_null_free());</span>
1232   if (obj == ciEnv::unloaded_ciobjarrayklass()) {
1233     BAILOUT(&quot;encountered unloaded_ciobjarrayklass due to out of memory error&quot;);
1234   }
1235 
1236   klass2reg_with_patching(klass_reg, obj, patching_info);
<span class="line-modified">1237   if (x-&gt;is_null_free()) {</span>
1238     __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_INLINE_TYPE, klass_reg, slow_path);
1239   } else {
1240     __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);
1241   }
1242 
1243   LIR_Opr result = rlock_result(x);
1244   __ move(reg, result);
1245 }
1246 
1247 
1248 void LIRGenerator::do_NewMultiArray(NewMultiArray* x) {
1249   Values* dims = x-&gt;dims();
1250   int i = dims-&gt;length();
1251   LIRItemList* items = new LIRItemList(i, i, NULL);
1252   while (i-- &gt; 0) {
1253     LIRItem* size = new LIRItem(dims-&gt;at(i), this);
1254     items-&gt;at_put(i, size);
1255   }
1256 
1257   // Evaluate state_for early since it may emit code.
</pre>
<hr />
<pre>
1297 
1298 void LIRGenerator::do_BlockBegin(BlockBegin* x) {
1299   // nothing to do for now
1300 }
1301 
1302 void LIRGenerator::do_CheckCast(CheckCast* x) {
1303   LIRItem obj(x-&gt;obj(), this);
1304 
1305   CodeEmitInfo* patching_info = NULL;
1306   if (!x-&gt;klass()-&gt;is_loaded() || (PatchALot &amp;&amp; !x-&gt;is_incompatible_class_change_check() &amp;&amp; !x-&gt;is_invokespecial_receiver_check())) {
1307     // must do this before locking the destination register as an oop register,
1308     // and before the obj is loaded (the latter is for deoptimization)
1309     patching_info = state_for(x, x-&gt;state_before());
1310   }
1311   obj.load_item();
1312 
1313   // info for exceptions
1314   CodeEmitInfo* info_for_exception =
1315       (x-&gt;needs_exception_state() ? state_for(x) :
1316                                     state_for(x, x-&gt;state_before(), true /*ignore_xhandler*/));
<span class="line-modified">1317   if (x-&gt;is_null_free()) {</span>
1318     __ null_check(obj.result(), new CodeEmitInfo(info_for_exception));
1319   }
1320 
1321   CodeStub* stub;
1322   if (x-&gt;is_incompatible_class_change_check()) {
1323     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1324     stub = new SimpleExceptionStub(Runtime1::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);
1325   } else if (x-&gt;is_invokespecial_receiver_check()) {
1326     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1327     stub = new DeoptimizeStub(info_for_exception,
1328                               Deoptimization::Reason_class_check,
1329                               Deoptimization::Action_none);
1330   } else {
1331     stub = new SimpleExceptionStub(Runtime1::throw_class_cast_exception_id, obj.result(), info_for_exception);
1332   }
1333   LIR_Opr reg = rlock_result(x);
1334   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1335   if (!x-&gt;klass()-&gt;is_loaded() || UseCompressedClassPointers) {
1336     tmp3 = new_register(objectType);
1337   }
1338 
1339 
1340   __ checkcast(reg, obj.result(), x-&gt;klass(),
1341                new_register(objectType), new_register(objectType), tmp3,
1342                x-&gt;direct_compare(), info_for_exception, patching_info, stub,
<span class="line-modified">1343                x-&gt;profiled_method(), x-&gt;profiled_bci(), x-&gt;is_null_free());</span>
1344 
1345 }
1346 
1347 void LIRGenerator::do_InstanceOf(InstanceOf* x) {
1348   LIRItem obj(x-&gt;obj(), this);
1349 
1350   // result and test object may not be in same register
1351   LIR_Opr reg = rlock_result(x);
1352   CodeEmitInfo* patching_info = NULL;
1353   if ((!x-&gt;klass()-&gt;is_loaded() || PatchALot)) {
1354     // must do this before locking the destination register as an oop register
1355     patching_info = state_for(x, x-&gt;state_before());
1356   }
1357   obj.load_item();
1358   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1359   if (!x-&gt;klass()-&gt;is_loaded() || UseCompressedClassPointers) {
1360     tmp3 = new_register(objectType);
1361   }
1362   __ instanceof(reg, obj.result(), x-&gt;klass(),
1363                 new_register(objectType), new_register(objectType), tmp3,
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="../x86/c1_LIRGenerator_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
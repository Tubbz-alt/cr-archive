<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/inlinetypenode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="graphKit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="inlinetypenode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/inlinetypenode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
348       Node* adr = kit-&gt;basic_plus_adr(base, ptr, offset);
349       BasicType bt = type2field[ft-&gt;basic_type()];
350       assert(is_java_primitive(bt) || adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop() == UseCompressedOops, &quot;inconsistent&quot;);
351       const Type* val_type = Type::get_const_type(ft);
352       const TypeAryPtr* ary_type = kit-&gt;gvn().type(base)-&gt;isa_aryptr();
353       if (ary_type != NULL) {
354         decorators |= IS_ARRAY;
355       }
356       kit-&gt;access_store_at(base, adr, adr_type, value, val_type, bt, decorators);
357     }
358   }
359 }
360 
361 InlineTypePtrNode* InlineTypeBaseNode::buffer(GraphKit* kit, bool safe_for_replace) {
362   assert(is_InlineType(), &quot;sanity&quot;);
363   // Check if inline type is already allocated
364   Node* null_ctl = kit-&gt;top();
365   Node* not_null_oop = kit-&gt;null_check_oop(get_oop(), &amp;null_ctl);
366   if (null_ctl-&gt;is_top()) {
367     // Inline type is allocated
<span class="line-modified">368     return kit-&gt;gvn().transform(new InlineTypePtrNode(this))-&gt;as_InlineTypePtr();</span>
369   }
370   assert(!is_allocated(&amp;kit-&gt;gvn()), &quot;should not be allocated&quot;);
371   RegionNode* region = new RegionNode(3);
372 
373   // Oop is non-NULL, use it
374   region-&gt;init_req(1, kit-&gt;control());
375   PhiNode* oop = PhiNode::make(region, not_null_oop, inline_ptr());
376   PhiNode* io  = PhiNode::make(region, kit-&gt;i_o(), Type::ABIO);
377   PhiNode* mem = PhiNode::make(region, kit-&gt;merged_memory(), Type::MEMORY, TypePtr::BOTTOM);
378 
379   int bci = kit-&gt;bci();
380   bool reexecute = kit-&gt;jvms()-&gt;should_reexecute();
381   {
382     // Oop is NULL, allocate and initialize buffer
383     PreserveJVMState pjvms(kit);
384     // Propagate re-execution state and bci
385     kit-&gt;set_bci(bci);
386     kit-&gt;jvms()-&gt;set_bci(bci);
387     kit-&gt;jvms()-&gt;set_should_reexecute(reexecute);
388     kit-&gt;set_control(null_ctl);
</pre>
<hr />
<pre>
407   // Update GraphKit
408   kit-&gt;set_control(kit-&gt;gvn().transform(region));
409   kit-&gt;set_i_o(kit-&gt;gvn().transform(io));
410   kit-&gt;set_all_memory(kit-&gt;gvn().transform(mem));
411   kit-&gt;record_for_igvn(region);
412   kit-&gt;record_for_igvn(oop);
413   kit-&gt;record_for_igvn(io);
414   kit-&gt;record_for_igvn(mem);
415 
416   // Use cloned InlineTypeNode to propagate oop from now on
417   Node* res_oop = kit-&gt;gvn().transform(oop);
418   InlineTypeBaseNode* vt = clone()-&gt;as_InlineTypeBase();
419   vt-&gt;set_oop(res_oop);
420   vt = kit-&gt;gvn().transform(vt)-&gt;as_InlineTypeBase();
421   if (safe_for_replace) {
422     kit-&gt;replace_in_map(this, vt);
423   }
424   // InlineTypeNode::remove_redundant_allocations piggybacks on split if.
425   // Make sure it gets a chance to remove this allocation.
426   kit-&gt;C-&gt;set_has_split_ifs(true);
<span class="line-modified">427   assert(vt-&gt;is_allocated(&amp;kit-&gt;gvn()), &quot;must be allocated&quot;);</span>
<span class="line-removed">428   return kit-&gt;gvn().transform(new InlineTypePtrNode(vt))-&gt;as_InlineTypePtr();</span>
429 }
430 
431 bool InlineTypeBaseNode::is_allocated(PhaseGVN* phase) const {
432   Node* oop = get_oop();
433   const Type* oop_type = (phase != NULL) ? phase-&gt;type(oop) : oop-&gt;bottom_type();
434   return !oop_type-&gt;maybe_null();
435 }
436 








437 // When a call returns multiple values, it has several result
438 // projections, one per field. Replacing the result of the call by a
439 // inline type node (after late inlining) requires that for each result
440 // projection, we find the corresponding inline type field.
441 void InlineTypeBaseNode::replace_call_results(GraphKit* kit, Node* call, Compile* C) {
442   ciInlineKlass* vk = inline_klass();
443   for (DUIterator_Fast imax, i = call-&gt;fast_outs(imax); i &lt; imax; i++) {
444     ProjNode* pn = call-&gt;fast_out(i)-&gt;as_Proj();
445     uint con = pn-&gt;_con;
446     if (con &gt;= TypeFunc::Parms+1) {
447       uint field_nb = con - (TypeFunc::Parms+1);
448       int extra = 0;
449       for (uint j = 0; j &lt; field_nb - extra; j++) {
450         ciField* f = vk-&gt;nonstatic_field_at(j);
451         BasicType bt = f-&gt;type()-&gt;basic_type();
452         if (bt == T_LONG || bt == T_DOUBLE) {
453           extra++;
454         }
455       }
456       ciField* f = vk-&gt;nonstatic_field_at(field_nb - extra);
</pre>
<hr />
<pre>
486 
487 InlineTypeNode* InlineTypeNode::make_uninitialized(PhaseGVN&amp; gvn, ciInlineKlass* vk) {
488   // Create a new InlineTypeNode with uninitialized values and NULL oop
489   Node* oop = vk-&gt;is_empty() ? default_oop(gvn, vk) : gvn.zerocon(T_INLINE_TYPE);
490   return new InlineTypeNode(vk, oop);
491 }
492 
493 Node* InlineTypeNode::default_oop(PhaseGVN&amp; gvn, ciInlineKlass* vk) {
494   // Returns the constant oop of the default inline type allocation
495   return gvn.makecon(TypeInstPtr::make(vk-&gt;default_instance()));
496 }
497 
498 InlineTypeNode* InlineTypeNode::make_default(PhaseGVN&amp; gvn, ciInlineKlass* vk) {
499   // Create a new InlineTypeNode with default values
500   InlineTypeNode* vt = new InlineTypeNode(vk, default_oop(gvn, vk));
501   for (uint i = 0; i &lt; vt-&gt;field_count(); ++i) {
502     ciType* field_type = vt-&gt;field_type(i);
503     Node* value = NULL;
504     if (field_type-&gt;is_inlinetype()) {
505       ciInlineKlass* field_klass = field_type-&gt;as_inline_klass();
<span class="line-modified">506       if (field_klass-&gt;is_scalarizable() || vt-&gt;field_is_flattened(i)) {</span>
507         value = InlineTypeNode::make_default(gvn, field_klass);
508       } else {
509         value = default_oop(gvn, field_klass);
510       }
511     } else {
512       value = gvn.zerocon(field_type-&gt;basic_type());
513     }
514     vt-&gt;set_field_value(i, value);
515   }
516   vt = gvn.transform(vt)-&gt;as_InlineType();
<span class="line-modified">517   assert(vt-&gt;is_default(gvn), &quot;must be the default inline type&quot;);</span>
518   return vt;
519 }
520 
<span class="line-modified">521 bool InlineTypeNode::is_default(PhaseGVN&amp; gvn) const {</span>
522   for (uint i = 0; i &lt; field_count(); ++i) {
523     Node* value = field_value(i);
<span class="line-modified">524     if (!gvn.type(value)-&gt;is_zero_type() &amp;&amp;</span>
525         !(value-&gt;is_InlineType() &amp;&amp; value-&gt;as_InlineType()-&gt;is_default(gvn)) &amp;&amp;
<span class="line-modified">526         !(field_type(i)-&gt;is_inlinetype() &amp;&amp; value == default_oop(gvn, field_type(i)-&gt;as_inline_klass()))) {</span>
527       return false;
528     }
529   }
530   return true;
531 }
532 
533 InlineTypeNode* InlineTypeNode::make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk) {
534   PhaseGVN&amp; gvn = kit-&gt;gvn();
535 
536   // Create and initialize an InlineTypeNode by loading all field
537   // values from a heap-allocated version and also save the oop.
538   InlineTypeNode* vt = new InlineTypeNode(vk, oop);
539 
540   if (oop-&gt;isa_InlineTypePtr()) {
541     // Can happen with late inlining
542     InlineTypePtrNode* vtptr = oop-&gt;as_InlineTypePtr();
543     vt-&gt;set_oop(vtptr-&gt;get_oop());
544     for (uint i = Oop+1; i &lt; vtptr-&gt;req(); ++i) {
545       vt-&gt;init_req(i, vtptr-&gt;in(i));
546     }
</pre>
<hr />
<pre>
759         // Non-flattened inline type field
760         if (type-&gt;as_inline_klass()-&gt;is_scalarizable()) {
761           parm = InlineTypeNode::make_from_oop(kit, parm, type-&gt;as_inline_klass());
762         } else {
763           parm = kit-&gt;null2default(parm, type-&gt;as_inline_klass());
764         }
765       }
766       base_input += type2size[type-&gt;basic_type()];
767       // Skip reserved arguments
768       BasicType bt = type-&gt;basic_type();
769       while (SigEntry::next_is_reserved(sig, bt)) {
770         base_input += type2size[bt];
771       }
772     }
773     assert(parm != NULL, &quot;should never be null&quot;);
774     set_field_value(idx, parm);
775     gvn.record_for_igvn(parm);
776   }
777 }
778 

















779 Node* InlineTypeNode::Ideal(PhaseGVN* phase, bool can_reshape) {
780   Node* oop = get_oop();
<span class="line-modified">781   if (is_default(*phase) &amp;&amp; (!oop-&gt;is_Con() || phase-&gt;type(oop)-&gt;is_zero_type())) {</span>
782     // Use the pre-allocated oop for default inline types
783     set_oop(default_oop(*phase, inline_klass()));

784     return this;
785   } else if (oop-&gt;isa_InlineTypePtr()) {
786     // Can happen with late inlining
787     InlineTypePtrNode* vtptr = oop-&gt;as_InlineTypePtr();
788     set_oop(vtptr-&gt;get_oop());
789     for (uint i = Oop+1; i &lt; vtptr-&gt;req(); ++i) {
790       set_req(i, vtptr-&gt;in(i));
791     }
792     return this;
793   }
794 
795   if (!is_allocated(phase)) {
796     // Save base oop if fields are loaded from memory and the inline
797     // type is not buffered (in this case we should not use the oop).
798     Node* base = is_loaded(phase);
799     if (base != NULL) {
800       set_oop(base);
801       assert(is_allocated(phase), &quot;should now be allocated&quot;);
802       return this;
803     }
804   }
805 
806   if (can_reshape) {
807     PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
808 
<span class="line-modified">809     if (is_default(*phase)) {</span>
<span class="line-modified">810       // Search for users of the default inline type</span>


811       for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
<span class="line-modified">812         Node* user = fast_out(i);</span>
<span class="line-removed">813         AllocateNode* alloc = user-&gt;isa_Allocate();</span>
814         if (alloc != NULL &amp;&amp; alloc-&gt;in(AllocateNode::InlineTypeNode) == this) {
<span class="line-modified">815           // Found an allocation of the default inline type.</span>
816           Node* res = alloc-&gt;result_cast();
<span class="line-modified">817           if (res != NULL) {</span>
<span class="line-modified">818             // If the code in StoreNode::Identity() that removes useless stores was not yet</span>
<span class="line-modified">819             // executed or ReduceFieldZeroing is disabled, there can still be initializing</span>
<span class="line-modified">820             // stores (only zero-type or default value stores, because inline types are immutable).</span>
<span class="line-modified">821             for (DUIterator_Fast jmax, j = res-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-removed">822               AddPNode* addp = res-&gt;fast_out(j)-&gt;isa_AddP();</span>
<span class="line-removed">823               if (addp != NULL) {</span>
<span class="line-removed">824                 for (DUIterator_Fast kmax, k = addp-&gt;fast_outs(kmax); k &lt; kmax; k++) {</span>
<span class="line-removed">825                   StoreNode* store = addp-&gt;fast_out(k)-&gt;isa_Store();</span>
<span class="line-removed">826                   if (store != NULL &amp;&amp; store-&gt;outcnt() != 0) {</span>
<span class="line-removed">827                     // Remove the useless store</span>
<span class="line-removed">828                     igvn-&gt;replace_in_uses(store, store-&gt;in(MemNode::Memory));</span>
<span class="line-removed">829                   }</span>
<span class="line-removed">830                 }</span>
<span class="line-removed">831               }</span>
<span class="line-removed">832             }</span>
<span class="line-removed">833             // Replace allocation by pre-allocated oop</span>
<span class="line-removed">834             igvn-&gt;replace_node(res, default_oop(*phase, inline_klass()));</span>
835           }
<span class="line-removed">836           // Unlink AllocateNode</span>
<span class="line-removed">837           igvn-&gt;replace_input_of(alloc, AllocateNode::InlineTypeNode, igvn-&gt;C-&gt;top());</span>
<span class="line-removed">838           --i; --imax;</span>
<span class="line-removed">839         } else if (user-&gt;is_InlineType()) {</span>
<span class="line-removed">840           // Add inline type user to worklist to give it a chance to get optimized as well</span>
<span class="line-removed">841           igvn-&gt;_worklist.push(user);</span>
<span class="line-removed">842         }</span>
<span class="line-removed">843       }</span>
<span class="line-removed">844     }</span>
<span class="line-removed">845 </span>
<span class="line-removed">846     if (is_allocated(igvn)) {</span>
<span class="line-removed">847       // Inline type is heap allocated, search for safepoint uses</span>
<span class="line-removed">848       for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-removed">849         Node* out = fast_out(i);</span>
<span class="line-removed">850         if (out-&gt;is_SafePoint()) {</span>
<span class="line-removed">851           // Let SafePointNode::Ideal() take care of re-wiring the</span>
<span class="line-removed">852           // safepoint to the oop input instead of the inline type node.</span>
<span class="line-removed">853           igvn-&gt;rehash_node_delayed(out);</span>
854         }
855       }
856     }
857   }
858   return NULL;
859 }
860 
861 // Search for multiple allocations of this inline type
862 // and try to replace them by dominating allocations.
863 // Then unlink the inline type node and remove it.
864 void InlineTypeNode::remove_redundant_allocations(PhaseIterGVN* igvn, PhaseIdealLoop* phase) {
865   // Search for allocations of this inline type
866   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
867     AllocateNode* alloc = fast_out(i)-&gt;isa_Allocate();
868     if (alloc != NULL &amp;&amp; alloc-&gt;in(AllocateNode::InlineTypeNode) == this) {
<span class="line-removed">869       assert(!is_default(*igvn), &quot;default inline type allocation&quot;);</span>
870       Node* res = alloc-&gt;result_cast();
871       if (res == NULL || !res-&gt;is_CheckCastPP()) {
872         break; // No unique CheckCastPP
873       }


874       Node* res_dom = res;
<span class="line-modified">875       if (is_allocated(igvn)) {</span>
<span class="line-modified">876         // The inline type is already allocated but still connected to an AllocateNode.</span>
<span class="line-modified">877         // This can happen with late inlining when we first allocate an inline type argument</span>
<span class="line-modified">878         // but later decide to inline the call with the callee code also allocating.</span>
<span class="line-modified">879         res_dom = get_oop();</span>
<span class="line-modified">880       } else {</span>
<span class="line-modified">881         // Search for a dominating allocation of the same inline type</span>
<span class="line-removed">882         for (DUIterator_Fast jmax, j = fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-removed">883           AllocateNode* alloc_other = fast_out(j)-&gt;isa_Allocate();</span>
<span class="line-removed">884           if (alloc_other != NULL &amp;&amp; alloc_other-&gt;in(AllocateNode::InlineTypeNode) == this) {</span>
<span class="line-removed">885             Node* res_other = alloc_other-&gt;result_cast();</span>
<span class="line-removed">886             if (res_other != NULL &amp;&amp; res_other-&gt;is_CheckCastPP() &amp;&amp; res_other != res_dom &amp;&amp;</span>
<span class="line-removed">887                 phase-&gt;is_dominator(res_other-&gt;in(0), res_dom-&gt;in(0))) {</span>
<span class="line-removed">888               res_dom = res_other;</span>
<span class="line-removed">889             }</span>
890           }
891         }
892       }
893       if (res_dom != res) {
<span class="line-modified">894         // Move users to dominating allocation</span>
<span class="line-modified">895         igvn-&gt;replace_node(res, res_dom);</span>
896         // The result of the dominated allocation is now unused and will be removed
897         // later in PhaseMacroExpand::eliminate_allocate_node to not confuse loop opts.
898         igvn-&gt;record_for_igvn(alloc);
899       }
900     }
901   }
902 
903   // Process users
904   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
905     Node* out = fast_out(i);
906     if (out-&gt;is_InlineType()) {
907       // Unlink and recursively process inline type users
908       igvn-&gt;hash_delete(out);
909       int nb = out-&gt;replace_edge(this, igvn-&gt;C-&gt;top());
910       out-&gt;as_InlineType()-&gt;remove_redundant_allocations(igvn, phase);
911       --i; imax -= nb;
912     } else if (out-&gt;isa_Allocate() != NULL) {
913       // Unlink AllocateNode
914       assert(out-&gt;in(AllocateNode::InlineTypeNode) == this, &quot;should be linked&quot;);
915       igvn-&gt;replace_input_of(out, AllocateNode::InlineTypeNode, igvn-&gt;C-&gt;top());
</pre>
</td>
<td>
<hr />
<pre>
348       Node* adr = kit-&gt;basic_plus_adr(base, ptr, offset);
349       BasicType bt = type2field[ft-&gt;basic_type()];
350       assert(is_java_primitive(bt) || adr-&gt;bottom_type()-&gt;is_ptr_to_narrowoop() == UseCompressedOops, &quot;inconsistent&quot;);
351       const Type* val_type = Type::get_const_type(ft);
352       const TypeAryPtr* ary_type = kit-&gt;gvn().type(base)-&gt;isa_aryptr();
353       if (ary_type != NULL) {
354         decorators |= IS_ARRAY;
355       }
356       kit-&gt;access_store_at(base, adr, adr_type, value, val_type, bt, decorators);
357     }
358   }
359 }
360 
361 InlineTypePtrNode* InlineTypeBaseNode::buffer(GraphKit* kit, bool safe_for_replace) {
362   assert(is_InlineType(), &quot;sanity&quot;);
363   // Check if inline type is already allocated
364   Node* null_ctl = kit-&gt;top();
365   Node* not_null_oop = kit-&gt;null_check_oop(get_oop(), &amp;null_ctl);
366   if (null_ctl-&gt;is_top()) {
367     // Inline type is allocated
<span class="line-modified">368     return as_ptr(&amp;kit-&gt;gvn());</span>
369   }
370   assert(!is_allocated(&amp;kit-&gt;gvn()), &quot;should not be allocated&quot;);
371   RegionNode* region = new RegionNode(3);
372 
373   // Oop is non-NULL, use it
374   region-&gt;init_req(1, kit-&gt;control());
375   PhiNode* oop = PhiNode::make(region, not_null_oop, inline_ptr());
376   PhiNode* io  = PhiNode::make(region, kit-&gt;i_o(), Type::ABIO);
377   PhiNode* mem = PhiNode::make(region, kit-&gt;merged_memory(), Type::MEMORY, TypePtr::BOTTOM);
378 
379   int bci = kit-&gt;bci();
380   bool reexecute = kit-&gt;jvms()-&gt;should_reexecute();
381   {
382     // Oop is NULL, allocate and initialize buffer
383     PreserveJVMState pjvms(kit);
384     // Propagate re-execution state and bci
385     kit-&gt;set_bci(bci);
386     kit-&gt;jvms()-&gt;set_bci(bci);
387     kit-&gt;jvms()-&gt;set_should_reexecute(reexecute);
388     kit-&gt;set_control(null_ctl);
</pre>
<hr />
<pre>
407   // Update GraphKit
408   kit-&gt;set_control(kit-&gt;gvn().transform(region));
409   kit-&gt;set_i_o(kit-&gt;gvn().transform(io));
410   kit-&gt;set_all_memory(kit-&gt;gvn().transform(mem));
411   kit-&gt;record_for_igvn(region);
412   kit-&gt;record_for_igvn(oop);
413   kit-&gt;record_for_igvn(io);
414   kit-&gt;record_for_igvn(mem);
415 
416   // Use cloned InlineTypeNode to propagate oop from now on
417   Node* res_oop = kit-&gt;gvn().transform(oop);
418   InlineTypeBaseNode* vt = clone()-&gt;as_InlineTypeBase();
419   vt-&gt;set_oop(res_oop);
420   vt = kit-&gt;gvn().transform(vt)-&gt;as_InlineTypeBase();
421   if (safe_for_replace) {
422     kit-&gt;replace_in_map(this, vt);
423   }
424   // InlineTypeNode::remove_redundant_allocations piggybacks on split if.
425   // Make sure it gets a chance to remove this allocation.
426   kit-&gt;C-&gt;set_has_split_ifs(true);
<span class="line-modified">427   return vt-&gt;as_ptr(&amp;kit-&gt;gvn());</span>

428 }
429 
430 bool InlineTypeBaseNode::is_allocated(PhaseGVN* phase) const {
431   Node* oop = get_oop();
432   const Type* oop_type = (phase != NULL) ? phase-&gt;type(oop) : oop-&gt;bottom_type();
433   return !oop_type-&gt;maybe_null();
434 }
435 
<span class="line-added">436 InlineTypePtrNode* InlineTypeBaseNode::as_ptr(PhaseGVN* phase) const {</span>
<span class="line-added">437   assert(is_allocated(phase), &quot;must be allocated&quot;);</span>
<span class="line-added">438   if (is_InlineTypePtr()) {</span>
<span class="line-added">439     return as_InlineTypePtr();</span>
<span class="line-added">440   }</span>
<span class="line-added">441   return phase-&gt;transform(new InlineTypePtrNode(this))-&gt;as_InlineTypePtr();</span>
<span class="line-added">442 }</span>
<span class="line-added">443 </span>
444 // When a call returns multiple values, it has several result
445 // projections, one per field. Replacing the result of the call by a
446 // inline type node (after late inlining) requires that for each result
447 // projection, we find the corresponding inline type field.
448 void InlineTypeBaseNode::replace_call_results(GraphKit* kit, Node* call, Compile* C) {
449   ciInlineKlass* vk = inline_klass();
450   for (DUIterator_Fast imax, i = call-&gt;fast_outs(imax); i &lt; imax; i++) {
451     ProjNode* pn = call-&gt;fast_out(i)-&gt;as_Proj();
452     uint con = pn-&gt;_con;
453     if (con &gt;= TypeFunc::Parms+1) {
454       uint field_nb = con - (TypeFunc::Parms+1);
455       int extra = 0;
456       for (uint j = 0; j &lt; field_nb - extra; j++) {
457         ciField* f = vk-&gt;nonstatic_field_at(j);
458         BasicType bt = f-&gt;type()-&gt;basic_type();
459         if (bt == T_LONG || bt == T_DOUBLE) {
460           extra++;
461         }
462       }
463       ciField* f = vk-&gt;nonstatic_field_at(field_nb - extra);
</pre>
<hr />
<pre>
493 
494 InlineTypeNode* InlineTypeNode::make_uninitialized(PhaseGVN&amp; gvn, ciInlineKlass* vk) {
495   // Create a new InlineTypeNode with uninitialized values and NULL oop
496   Node* oop = vk-&gt;is_empty() ? default_oop(gvn, vk) : gvn.zerocon(T_INLINE_TYPE);
497   return new InlineTypeNode(vk, oop);
498 }
499 
500 Node* InlineTypeNode::default_oop(PhaseGVN&amp; gvn, ciInlineKlass* vk) {
501   // Returns the constant oop of the default inline type allocation
502   return gvn.makecon(TypeInstPtr::make(vk-&gt;default_instance()));
503 }
504 
505 InlineTypeNode* InlineTypeNode::make_default(PhaseGVN&amp; gvn, ciInlineKlass* vk) {
506   // Create a new InlineTypeNode with default values
507   InlineTypeNode* vt = new InlineTypeNode(vk, default_oop(gvn, vk));
508   for (uint i = 0; i &lt; vt-&gt;field_count(); ++i) {
509     ciType* field_type = vt-&gt;field_type(i);
510     Node* value = NULL;
511     if (field_type-&gt;is_inlinetype()) {
512       ciInlineKlass* field_klass = field_type-&gt;as_inline_klass();
<span class="line-modified">513       if (field_klass-&gt;is_scalarizable()) {</span>
514         value = InlineTypeNode::make_default(gvn, field_klass);
515       } else {
516         value = default_oop(gvn, field_klass);
517       }
518     } else {
519       value = gvn.zerocon(field_type-&gt;basic_type());
520     }
521     vt-&gt;set_field_value(i, value);
522   }
523   vt = gvn.transform(vt)-&gt;as_InlineType();
<span class="line-modified">524   assert(vt-&gt;is_default(&amp;gvn), &quot;must be the default inline type&quot;);</span>
525   return vt;
526 }
527 
<span class="line-modified">528 bool InlineTypeNode::is_default(PhaseGVN* gvn) const {</span>
529   for (uint i = 0; i &lt; field_count(); ++i) {
530     Node* value = field_value(i);
<span class="line-modified">531     if (!gvn-&gt;type(value)-&gt;is_zero_type() &amp;&amp;</span>
532         !(value-&gt;is_InlineType() &amp;&amp; value-&gt;as_InlineType()-&gt;is_default(gvn)) &amp;&amp;
<span class="line-modified">533         !(field_type(i)-&gt;is_inlinetype() &amp;&amp; value == default_oop(*gvn, field_type(i)-&gt;as_inline_klass()))) {</span>
534       return false;
535     }
536   }
537   return true;
538 }
539 
540 InlineTypeNode* InlineTypeNode::make_from_oop(GraphKit* kit, Node* oop, ciInlineKlass* vk) {
541   PhaseGVN&amp; gvn = kit-&gt;gvn();
542 
543   // Create and initialize an InlineTypeNode by loading all field
544   // values from a heap-allocated version and also save the oop.
545   InlineTypeNode* vt = new InlineTypeNode(vk, oop);
546 
547   if (oop-&gt;isa_InlineTypePtr()) {
548     // Can happen with late inlining
549     InlineTypePtrNode* vtptr = oop-&gt;as_InlineTypePtr();
550     vt-&gt;set_oop(vtptr-&gt;get_oop());
551     for (uint i = Oop+1; i &lt; vtptr-&gt;req(); ++i) {
552       vt-&gt;init_req(i, vtptr-&gt;in(i));
553     }
</pre>
<hr />
<pre>
766         // Non-flattened inline type field
767         if (type-&gt;as_inline_klass()-&gt;is_scalarizable()) {
768           parm = InlineTypeNode::make_from_oop(kit, parm, type-&gt;as_inline_klass());
769         } else {
770           parm = kit-&gt;null2default(parm, type-&gt;as_inline_klass());
771         }
772       }
773       base_input += type2size[type-&gt;basic_type()];
774       // Skip reserved arguments
775       BasicType bt = type-&gt;basic_type();
776       while (SigEntry::next_is_reserved(sig, bt)) {
777         base_input += type2size[bt];
778       }
779     }
780     assert(parm != NULL, &quot;should never be null&quot;);
781     set_field_value(idx, parm);
782     gvn.record_for_igvn(parm);
783   }
784 }
785 
<span class="line-added">786 // Replace a buffer allocation by a dominating allocation</span>
<span class="line-added">787 static void replace_allocation(PhaseIterGVN* igvn, Node* res, Node* dom) {</span>
<span class="line-added">788   // Remove initializing stores</span>
<span class="line-added">789   for (DUIterator_Fast imax, i = res-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-added">790     AddPNode* addp = res-&gt;fast_out(i)-&gt;isa_AddP();</span>
<span class="line-added">791     if (addp != NULL) {</span>
<span class="line-added">792       for (DUIterator_Fast jmax, j = addp-&gt;fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-added">793         StoreNode* store = addp-&gt;fast_out(j)-&gt;isa_Store();</span>
<span class="line-added">794         if (store != NULL) {</span>
<span class="line-added">795           igvn-&gt;replace_in_uses(store, store-&gt;in(MemNode::Memory));</span>
<span class="line-added">796         }</span>
<span class="line-added">797       }</span>
<span class="line-added">798     }</span>
<span class="line-added">799   }</span>
<span class="line-added">800   igvn-&gt;replace_node(res, dom);</span>
<span class="line-added">801 }</span>
<span class="line-added">802 </span>
803 Node* InlineTypeNode::Ideal(PhaseGVN* phase, bool can_reshape) {
804   Node* oop = get_oop();
<span class="line-modified">805   if (is_default(phase) &amp;&amp; (!oop-&gt;is_Con() || phase-&gt;type(oop)-&gt;is_zero_type())) {</span>
806     // Use the pre-allocated oop for default inline types
807     set_oop(default_oop(*phase, inline_klass()));
<span class="line-added">808     assert(is_allocated(phase), &quot;should now be allocated&quot;);</span>
809     return this;
810   } else if (oop-&gt;isa_InlineTypePtr()) {
811     // Can happen with late inlining
812     InlineTypePtrNode* vtptr = oop-&gt;as_InlineTypePtr();
813     set_oop(vtptr-&gt;get_oop());
814     for (uint i = Oop+1; i &lt; vtptr-&gt;req(); ++i) {
815       set_req(i, vtptr-&gt;in(i));
816     }
817     return this;
818   }
819 
820   if (!is_allocated(phase)) {
821     // Save base oop if fields are loaded from memory and the inline
822     // type is not buffered (in this case we should not use the oop).
823     Node* base = is_loaded(phase);
824     if (base != NULL) {
825       set_oop(base);
826       assert(is_allocated(phase), &quot;should now be allocated&quot;);
827       return this;
828     }
829   }
830 
831   if (can_reshape) {
832     PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
833 
<span class="line-modified">834     if (is_allocated(phase)) {</span>
<span class="line-modified">835       // Search for and remove re-allocations of this inline type.</span>
<span class="line-added">836       // This can happen with late inlining when we first allocate an inline type argument</span>
<span class="line-added">837       // but later decide to inline the call after the callee code also triggered allocation.</span>
838       for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
<span class="line-modified">839         AllocateNode* alloc = fast_out(i)-&gt;isa_Allocate();</span>

840         if (alloc != NULL &amp;&amp; alloc-&gt;in(AllocateNode::InlineTypeNode) == this) {
<span class="line-modified">841           // Found a re-allocation</span>
842           Node* res = alloc-&gt;result_cast();
<span class="line-modified">843           if (res != NULL &amp;&amp; res-&gt;is_CheckCastPP()) {</span>
<span class="line-modified">844             // Replace allocation by oop and unlink AllocateNode</span>
<span class="line-modified">845             replace_allocation(igvn, res, get_oop());</span>
<span class="line-modified">846             igvn-&gt;replace_input_of(alloc, AllocateNode::InlineTypeNode, igvn-&gt;C-&gt;top());</span>
<span class="line-modified">847             --i; --imax;</span>













848           }


















849         }
850       }
851     }
852   }
853   return NULL;
854 }
855 
856 // Search for multiple allocations of this inline type
857 // and try to replace them by dominating allocations.
858 // Then unlink the inline type node and remove it.
859 void InlineTypeNode::remove_redundant_allocations(PhaseIterGVN* igvn, PhaseIdealLoop* phase) {
860   // Search for allocations of this inline type
861   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
862     AllocateNode* alloc = fast_out(i)-&gt;isa_Allocate();
863     if (alloc != NULL &amp;&amp; alloc-&gt;in(AllocateNode::InlineTypeNode) == this) {

864       Node* res = alloc-&gt;result_cast();
865       if (res == NULL || !res-&gt;is_CheckCastPP()) {
866         break; // No unique CheckCastPP
867       }
<span class="line-added">868       assert(!is_default(igvn) &amp;&amp; !is_allocated(igvn), &quot;re-allocation should be removed by Ideal transformation&quot;);</span>
<span class="line-added">869       // Search for a dominating allocation of the same inline type</span>
870       Node* res_dom = res;
<span class="line-modified">871       for (DUIterator_Fast jmax, j = fast_outs(jmax); j &lt; jmax; j++) {</span>
<span class="line-modified">872         AllocateNode* alloc_other = fast_out(j)-&gt;isa_Allocate();</span>
<span class="line-modified">873         if (alloc_other != NULL &amp;&amp; alloc_other-&gt;in(AllocateNode::InlineTypeNode) == this) {</span>
<span class="line-modified">874           Node* res_other = alloc_other-&gt;result_cast();</span>
<span class="line-modified">875           if (res_other != NULL &amp;&amp; res_other-&gt;is_CheckCastPP() &amp;&amp; res_other != res_dom &amp;&amp;</span>
<span class="line-modified">876               phase-&gt;is_dominator(res_other-&gt;in(0), res_dom-&gt;in(0))) {</span>
<span class="line-modified">877             res_dom = res_other;</span>








878           }
879         }
880       }
881       if (res_dom != res) {
<span class="line-modified">882         // Replace allocation by dominating one.</span>
<span class="line-modified">883         replace_allocation(igvn, res, res_dom);</span>
884         // The result of the dominated allocation is now unused and will be removed
885         // later in PhaseMacroExpand::eliminate_allocate_node to not confuse loop opts.
886         igvn-&gt;record_for_igvn(alloc);
887       }
888     }
889   }
890 
891   // Process users
892   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
893     Node* out = fast_out(i);
894     if (out-&gt;is_InlineType()) {
895       // Unlink and recursively process inline type users
896       igvn-&gt;hash_delete(out);
897       int nb = out-&gt;replace_edge(this, igvn-&gt;C-&gt;top());
898       out-&gt;as_InlineType()-&gt;remove_redundant_allocations(igvn, phase);
899       --i; imax -= nb;
900     } else if (out-&gt;isa_Allocate() != NULL) {
901       // Unlink AllocateNode
902       assert(out-&gt;in(AllocateNode::InlineTypeNode) == this, &quot;should be linked&quot;);
903       igvn-&gt;replace_input_of(out, AllocateNode::InlineTypeNode, igvn-&gt;C-&gt;top());
</pre>
</td>
</tr>
</table>
<center><a href="graphKit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="inlinetypenode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
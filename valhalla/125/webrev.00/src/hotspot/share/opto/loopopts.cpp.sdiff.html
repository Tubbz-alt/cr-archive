<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/loopopts.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="inlinetypenode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse1.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/loopopts.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1195 }
1196 
1197 // Detect if the node is the inner strip-mined loop
1198 // Return: NULL if it&#39;s not the case, or the exit of outer strip-mined loop
1199 static Node* is_inner_of_stripmined_loop(const Node* out) {
1200   Node* out_le = NULL;
1201 
1202   if (out-&gt;is_CountedLoopEnd()) {
1203       const CountedLoopNode* loop = out-&gt;as_CountedLoopEnd()-&gt;loopnode();
1204 
1205       if (loop != NULL &amp;&amp; loop-&gt;is_strip_mined()) {
1206         out_le = loop-&gt;in(LoopNode::EntryControl)-&gt;as_OuterStripMinedLoop()-&gt;outer_loop_exit();
1207       }
1208   }
1209 
1210   return out_le;
1211 }
1212 
1213 bool PhaseIdealLoop::flatten_array_element_type_check(Node *n) {
1214   // If the CmpP is a subtype check for a value that has just been
<span class="line-modified">1215   // loaded from an array, the subtype checks guarantees the value</span>
1216   // can&#39;t be stored in a flattened array and the load of the value
1217   // happens with a flattened array check then: push the type check
1218   // through the phi of the flattened array check. This needs special
1219   // logic because the subtype check&#39;s input is not a phi but a
1220   // LoadKlass that must first be cloned through the phi.
1221   if (n-&gt;Opcode() != Op_CmpP) {
1222     return false;
1223   }
1224 
1225   Node* klassptr = n-&gt;in(1);
1226   Node* klasscon = n-&gt;in(2);
1227 
1228   if (klassptr-&gt;is_DecodeNarrowPtr()) {
1229     klassptr = klassptr-&gt;in(1);
1230   }
1231 
1232   if (klassptr-&gt;Opcode() != Op_LoadKlass &amp;&amp; klassptr-&gt;Opcode() != Op_LoadNKlass) {
1233     return false;
1234   }
1235 
</pre>
<hr />
<pre>
1269       Node* cast = addr-&gt;in(AddPNode::Base);
1270       assert(cast-&gt;Opcode() == Op_CastPP &amp;&amp; cast-&gt;in(0) != NULL, &quot;inconsistent subgraph&quot;);
1271       Node* cast_clone = cast-&gt;clone();
1272       cast_clone-&gt;set_req(0, region-&gt;in(i));
1273       cast_clone-&gt;set_req(1, in);
1274       register_new_node(cast_clone, region-&gt;in(i));
1275       _igvn.set_type(cast_clone, cast_clone-&gt;Value(&amp;_igvn));
1276       in = cast_clone;
1277     }
1278     Node* addr_clone = addr-&gt;clone();
1279     addr_clone-&gt;set_req(AddPNode::Base, in);
1280     addr_clone-&gt;set_req(AddPNode::Address, in);
1281     register_new_node(addr_clone, ctrl);
1282     _igvn.set_type(addr_clone, addr_clone-&gt;Value(&amp;_igvn));
1283     Node* klassptr_clone = klassptr-&gt;clone();
1284     klassptr_clone-&gt;set_req(2, addr_clone);
1285     register_new_node(klassptr_clone, ctrl);
1286     _igvn.set_type(klassptr_clone, klassptr_clone-&gt;Value(&amp;_igvn));
1287     if (klassptr != n-&gt;in(1)) {
1288       Node* decode = n-&gt;in(1);
<span class="line-modified">1289       assert(decode-&gt;is_DecodeNarrowPtr(), &quot;inconcistent subgraph&quot;);</span>
1290       Node* decode_clone = decode-&gt;clone();
1291       decode_clone-&gt;set_req(1, klassptr_clone);
1292       register_new_node(decode_clone, ctrl);
1293       _igvn.set_type(decode_clone, decode_clone-&gt;Value(&amp;_igvn));
1294       klassptr_clone = decode_clone;
1295     }
1296     phi-&gt;set_req(i, klassptr_clone);
1297   }
1298   register_new_node(phi, region);
1299   Node* orig = n-&gt;in(1);
1300   _igvn.replace_input_of(n, 1, phi);
1301   split_if_with_blocks_post(n);
1302   if (n-&gt;outcnt() != 0) {
1303     _igvn.replace_input_of(n, 1, orig);
1304     _igvn.remove_dead_node(phi);
1305   }
1306   return true;
1307 }
1308 
1309 //------------------------------split_if_with_blocks_post----------------------
</pre>
</td>
<td>
<hr />
<pre>
1195 }
1196 
1197 // Detect if the node is the inner strip-mined loop
1198 // Return: NULL if it&#39;s not the case, or the exit of outer strip-mined loop
1199 static Node* is_inner_of_stripmined_loop(const Node* out) {
1200   Node* out_le = NULL;
1201 
1202   if (out-&gt;is_CountedLoopEnd()) {
1203       const CountedLoopNode* loop = out-&gt;as_CountedLoopEnd()-&gt;loopnode();
1204 
1205       if (loop != NULL &amp;&amp; loop-&gt;is_strip_mined()) {
1206         out_le = loop-&gt;in(LoopNode::EntryControl)-&gt;as_OuterStripMinedLoop()-&gt;outer_loop_exit();
1207       }
1208   }
1209 
1210   return out_le;
1211 }
1212 
1213 bool PhaseIdealLoop::flatten_array_element_type_check(Node *n) {
1214   // If the CmpP is a subtype check for a value that has just been
<span class="line-modified">1215   // loaded from an array, the subtype check guarantees the value</span>
1216   // can&#39;t be stored in a flattened array and the load of the value
1217   // happens with a flattened array check then: push the type check
1218   // through the phi of the flattened array check. This needs special
1219   // logic because the subtype check&#39;s input is not a phi but a
1220   // LoadKlass that must first be cloned through the phi.
1221   if (n-&gt;Opcode() != Op_CmpP) {
1222     return false;
1223   }
1224 
1225   Node* klassptr = n-&gt;in(1);
1226   Node* klasscon = n-&gt;in(2);
1227 
1228   if (klassptr-&gt;is_DecodeNarrowPtr()) {
1229     klassptr = klassptr-&gt;in(1);
1230   }
1231 
1232   if (klassptr-&gt;Opcode() != Op_LoadKlass &amp;&amp; klassptr-&gt;Opcode() != Op_LoadNKlass) {
1233     return false;
1234   }
1235 
</pre>
<hr />
<pre>
1269       Node* cast = addr-&gt;in(AddPNode::Base);
1270       assert(cast-&gt;Opcode() == Op_CastPP &amp;&amp; cast-&gt;in(0) != NULL, &quot;inconsistent subgraph&quot;);
1271       Node* cast_clone = cast-&gt;clone();
1272       cast_clone-&gt;set_req(0, region-&gt;in(i));
1273       cast_clone-&gt;set_req(1, in);
1274       register_new_node(cast_clone, region-&gt;in(i));
1275       _igvn.set_type(cast_clone, cast_clone-&gt;Value(&amp;_igvn));
1276       in = cast_clone;
1277     }
1278     Node* addr_clone = addr-&gt;clone();
1279     addr_clone-&gt;set_req(AddPNode::Base, in);
1280     addr_clone-&gt;set_req(AddPNode::Address, in);
1281     register_new_node(addr_clone, ctrl);
1282     _igvn.set_type(addr_clone, addr_clone-&gt;Value(&amp;_igvn));
1283     Node* klassptr_clone = klassptr-&gt;clone();
1284     klassptr_clone-&gt;set_req(2, addr_clone);
1285     register_new_node(klassptr_clone, ctrl);
1286     _igvn.set_type(klassptr_clone, klassptr_clone-&gt;Value(&amp;_igvn));
1287     if (klassptr != n-&gt;in(1)) {
1288       Node* decode = n-&gt;in(1);
<span class="line-modified">1289       assert(decode-&gt;is_DecodeNarrowPtr(), &quot;inconsistent subgraph&quot;);</span>
1290       Node* decode_clone = decode-&gt;clone();
1291       decode_clone-&gt;set_req(1, klassptr_clone);
1292       register_new_node(decode_clone, ctrl);
1293       _igvn.set_type(decode_clone, decode_clone-&gt;Value(&amp;_igvn));
1294       klassptr_clone = decode_clone;
1295     }
1296     phi-&gt;set_req(i, klassptr_clone);
1297   }
1298   register_new_node(phi, region);
1299   Node* orig = n-&gt;in(1);
1300   _igvn.replace_input_of(n, 1, phi);
1301   split_if_with_blocks_post(n);
1302   if (n-&gt;outcnt() != 0) {
1303     _igvn.replace_input_of(n, 1, orig);
1304     _igvn.remove_dead_node(phi);
1305   }
1306   return true;
1307 }
1308 
1309 //------------------------------split_if_with_blocks_post----------------------
</pre>
</td>
</tr>
</table>
<center><a href="inlinetypenode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="parse1.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
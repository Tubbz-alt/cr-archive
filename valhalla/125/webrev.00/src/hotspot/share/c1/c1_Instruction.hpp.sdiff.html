<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_Instruction.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_Instruction.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_Instruction.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 455   int id() const                                 { return _id; }
 456 #ifndef PRODUCT
 457   bool has_printable_bci() const                 { return _printable_bci != -99; }
 458   int printable_bci() const                      { assert(has_printable_bci(), &quot;_printable_bci should have been set&quot;); return _printable_bci; }
 459   void set_printable_bci(int bci)                { _printable_bci = bci; }
 460 #endif
 461   int dominator_depth();
 462   int use_count() const                          { return _use_count; }
 463   int pin_state() const                          { return _pin_state; }
 464   bool is_pinned() const                         { return _pin_state != 0 || PinAllInstructions; }
 465   ValueType* type() const                        { return _type; }
 466   BlockBegin *block() const                      { return _block; }
 467   Instruction* prev();                           // use carefully, expensive operation
 468   Instruction* next() const                      { return _next; }
 469   bool has_subst() const                         { return _subst != NULL; }
 470   Instruction* subst()                           { return _subst == NULL ? this : _subst-&gt;subst(); }
 471   LIR_Opr operand() const                        { return _operand; }
 472 
 473   void set_needs_null_check(bool f)              { set_flag(NeedsNullCheckFlag, f); }
 474   bool needs_null_check() const                  { return check_flag(NeedsNullCheckFlag); }
<span class="line-modified"> 475   void set_never_null(bool f)                    { set_flag(NeverNullFlag, f); }</span>
<span class="line-modified"> 476   bool is_never_null() const                     { return check_flag(NeverNullFlag); }</span>
 477   bool is_linked() const                         { return check_flag(IsLinkedInBlockFlag); }
 478   bool can_be_linked()                           { return as_Local() == NULL &amp;&amp; as_Phi() == NULL; }
 479 
 480   bool is_null_obj()                             { return as_Constant() != NULL &amp;&amp; type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object(); }
 481 
 482   bool has_uses() const                          { return use_count() &gt; 0; }
 483   ValueStack* state_before() const               { return _state_before; }
 484   ValueStack* exception_state() const            { return _exception_state; }
 485   virtual bool needs_exception_state() const     { return true; }
 486   XHandlers* exception_handlers() const          { return _exception_handlers; }
 487   ciKlass* as_loaded_klass_or_null() const;
 488 
 489   // withfield optimization
 490   virtual void set_escaped()                     { }
 491   virtual void set_local_index(int index)        { }
 492   virtual bool is_optimizable_for_withfield() const { return false; }
 493 
 494 
 495   // manipulation
 496   void pin(PinReason reason)                     { _pin_state |= reason; }
</pre>
<hr />
<pre>
 725   }
 726 
 727   bool is_illegal() const {
 728     return type()-&gt;is_illegal();
 729   }
 730 
 731   // generic
 732   virtual void input_values_do(ValueVisitor* f) {
 733   }
 734 };
 735 
 736 
 737 // A local is a placeholder for an incoming argument to a function call.
 738 LEAF(Local, Instruction)
 739  private:
 740   int      _java_index;                          // the local index within the method to which the local belongs
 741   bool     _is_receiver;                         // if local variable holds the receiver: &quot;this&quot; for non-static methods
 742   ciType*  _declared_type;
 743  public:
 744   // creation
<span class="line-modified"> 745   Local(ciType* declared, ValueType* type, int index, bool receiver, bool never_null)</span>
 746     : Instruction(type)
 747     , _java_index(index)
 748     , _is_receiver(receiver)
 749     , _declared_type(declared)
 750   {
<span class="line-modified"> 751     set_never_null(never_null);</span>
 752     NOT_PRODUCT(set_printable_bci(-1));
 753   }
 754 
 755   // accessors
 756   int java_index() const                         { return _java_index; }
 757   bool is_receiver() const                       { return _is_receiver; }
 758 
 759   virtual ciType* declared_type() const          { return _declared_type; }
 760 
 761   // generic
 762   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 763 };
 764 
 765 
 766 LEAF(Constant, Instruction)
 767  public:
 768   // creation
 769   Constant(ValueType* type):
 770       Instruction(type, NULL, /*type_is_constant*/ true)
 771   {
</pre>
<hr />
<pre>
 855   // proved the target object non-null, we can eliminate the explicit
 856   // null check and do an implicit one, simply specifying the debug
 857   // information from the NullCheck. This field should only be consulted
 858   // if needs_null_check() is true.
 859   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 860 
 861   // generic
 862   virtual bool can_trap() const                  { return needs_null_check() || needs_patching(); }
 863   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
 864 };
 865 
 866 
 867 LEAF(LoadField, AccessField)
 868  public:
 869   // creation
 870   LoadField(Value obj, int offset, ciField* field, bool is_static,
 871             ValueStack* state_before, bool needs_patching,
 872             ciInlineKlass* inline_klass = NULL, Value default_value = NULL )
 873   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 874   {
<span class="line-modified"> 875     set_never_null(field-&gt;signature()-&gt;is_Q_signature());</span>
 876   }
 877 
 878   ciType* declared_type() const;
 879 
 880   // generic; cannot be eliminated if needs patching or if volatile.
 881   HASHING3(LoadField, !needs_patching() &amp;&amp; !field()-&gt;is_volatile(), obj()-&gt;subst(), offset(), declared_type())
 882 };
 883 
 884 
 885 LEAF(StoreField, AccessField)
 886  private:
 887   Value _value;
 888 
 889  public:
 890   // creation
 891   StoreField(Value obj, int offset, ciField* field, Value value, bool is_static,
 892              ValueStack* state_before, bool needs_patching)
 893   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 894   , _value(value)
 895   {
</pre>
<hr />
<pre>
1293   void set_state(ValueStack* state)              { assert(_state == NULL, &quot;overwriting existing state&quot;); check_state(state); _state = state; }
1294 
1295   // generic
1296   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
1297   virtual void state_values_do(ValueVisitor* f);
1298 };
1299 
1300 
1301 LEAF(Invoke, StateSplit)
1302  private:
1303   Bytecodes::Code _code;
1304   Value           _recv;
1305   Values*         _args;
1306   BasicTypeList*  _signature;
1307   int             _vtable_index;
1308   ciMethod*       _target;
1309 
1310  public:
1311   // creation
1312   Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
<span class="line-modified">1313          int vtable_index, ciMethod* target, ValueStack* state_before, bool never_null);</span>
1314 
1315   // accessors
1316   Bytecodes::Code code() const                   { return _code; }
1317   Value receiver() const                         { return _recv; }
1318   bool has_receiver() const                      { return receiver() != NULL; }
1319   int number_of_arguments() const                { return _args-&gt;length(); }
1320   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1321   int vtable_index() const                       { return _vtable_index; }
1322   BasicTypeList* signature() const               { return _signature; }
1323   ciMethod* target() const                       { return _target; }
1324 
1325   ciType* declared_type() const;
1326 
1327   // Returns false if target is not loaded
1328   bool target_is_final() const                   { return check_flag(TargetIsFinalFlag); }
1329   bool target_is_loaded() const                  { return check_flag(TargetIsLoadedFlag); }
1330   // Returns false if target is not loaded
1331   bool target_is_strictfp() const                { return check_flag(TargetIsStrictfpFlag); }
1332 
1333   // JSR 292 support
</pre>
<hr />
<pre>
1375   bool _is_unresolved;
1376   ciInlineKlass* _klass;
1377   Value _depends_on;      // Link to instance on with withfield was called on
1378   bool _is_optimizable_for_withfield;
1379   int _first_local_index;
1380 public:
1381 
1382   // Default creation, always allocated for now
1383   NewInlineTypeInstance(ciInlineKlass* klass, ValueStack* state_before, bool is_unresolved, Value depends_on = NULL, bool from_default_value = false)
1384   : StateSplit(instanceType, state_before)
1385    , _is_unresolved(is_unresolved)
1386    , _klass(klass)
1387    , _is_optimizable_for_withfield(from_default_value)
1388    , _first_local_index(-1)
1389   {
1390     if (depends_on == NULL) {
1391       _depends_on = this;
1392     } else {
1393       _depends_on = depends_on;
1394     }
<span class="line-modified">1395     set_never_null(true);</span>
1396   }
1397 
1398   // accessors
1399   bool is_unresolved() const                     { return _is_unresolved; }
1400   Value depends_on();
1401 
1402   ciInlineKlass* klass() const { return _klass; }
1403 
1404   virtual bool needs_exception_state() const     { return false; }
1405 
1406   // generic
1407   virtual bool can_trap() const                  { return true; }
1408   ciType* exact_type() const;
1409   ciType* declared_type() const;
1410 
1411   // Only done in LIR Generator -&gt; map everything to object
1412   void set_to_object_type() { set_type(instanceType); }
1413 
1414   // withfield optimization
1415   virtual void set_escaped() {
</pre>
<hr />
<pre>
1460 
1461  public:
1462   // creation
1463   NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before)
1464   : NewArray(length, state_before)
1465   , _elt_type(elt_type)
1466   {}
1467 
1468   // accessors
1469   BasicType elt_type() const                     { return _elt_type; }
1470   ciType* exact_type() const;
1471 };
1472 
1473 
1474 LEAF(NewObjectArray, NewArray)
1475  private:
1476   ciKlass* _klass;
1477 
1478  public:
1479   // creation
<span class="line-modified">1480   NewObjectArray(ciKlass* klass, Value length, ValueStack* state_before, bool never_null)</span>
1481   : NewArray(length, state_before), _klass(klass) {
<span class="line-modified">1482     set_never_null(never_null);</span>
1483   }
1484 
1485   // accessors
1486   ciKlass* klass() const                         { return _klass; }
1487   ciType* exact_type() const;
1488 };
1489 
1490 
1491 LEAF(NewMultiArray, NewArray)
1492  private:
1493   ciKlass* _klass;
1494   Values*  _dims;
1495 
1496  public:
1497   // creation
1498   NewMultiArray(ciKlass* klass, Values* dims, ValueStack* state_before) : NewArray(NULL, state_before), _klass(klass), _dims(dims) {
1499     ASSERT_VALUES
1500   }
1501 
1502   // accessors
</pre>
<hr />
<pre>
1559   // manipulation
1560   void set_direct_compare(bool flag)             { set_flag(DirectCompareFlag, flag); }
1561 
1562   // generic
1563   virtual bool can_trap() const                  { return true; }
1564   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1565 
1566   // Helpers for MethodData* profiling
1567   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
1568   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
1569   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
1570   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
1571   ciMethod* profiled_method() const                  { return _profiled_method;     }
1572   int       profiled_bci() const                     { return _profiled_bci;        }
1573 };
1574 
1575 
1576 LEAF(CheckCast, TypeCheck)
1577  public:
1578   // creation
<span class="line-modified">1579   CheckCast(ciKlass* klass, Value obj, ValueStack* state_before, bool never_null = false)</span>
1580   : TypeCheck(klass, obj, objectType, state_before) {
<span class="line-modified">1581     set_never_null(never_null);</span>
1582   }
1583 
1584   void set_incompatible_class_change_check() {
1585     set_flag(ThrowIncompatibleClassChangeErrorFlag, true);
1586   }
1587   bool is_incompatible_class_change_check() const {
1588     return check_flag(ThrowIncompatibleClassChangeErrorFlag);
1589   }
1590   void set_invokespecial_receiver_check() {
1591     set_flag(InvokeSpecialReceiverCheckFlag, true);
1592   }
1593   bool is_invokespecial_receiver_check() const {
1594     return check_flag(InvokeSpecialReceiverCheckFlag);
1595   }
1596 
1597   virtual bool needs_exception_state() const {
1598     return !is_invokespecial_receiver_check();
1599   }
1600 
1601   ciType* declared_type() const;
</pre>
</td>
<td>
<hr />
<pre>
 455   int id() const                                 { return _id; }
 456 #ifndef PRODUCT
 457   bool has_printable_bci() const                 { return _printable_bci != -99; }
 458   int printable_bci() const                      { assert(has_printable_bci(), &quot;_printable_bci should have been set&quot;); return _printable_bci; }
 459   void set_printable_bci(int bci)                { _printable_bci = bci; }
 460 #endif
 461   int dominator_depth();
 462   int use_count() const                          { return _use_count; }
 463   int pin_state() const                          { return _pin_state; }
 464   bool is_pinned() const                         { return _pin_state != 0 || PinAllInstructions; }
 465   ValueType* type() const                        { return _type; }
 466   BlockBegin *block() const                      { return _block; }
 467   Instruction* prev();                           // use carefully, expensive operation
 468   Instruction* next() const                      { return _next; }
 469   bool has_subst() const                         { return _subst != NULL; }
 470   Instruction* subst()                           { return _subst == NULL ? this : _subst-&gt;subst(); }
 471   LIR_Opr operand() const                        { return _operand; }
 472 
 473   void set_needs_null_check(bool f)              { set_flag(NeedsNullCheckFlag, f); }
 474   bool needs_null_check() const                  { return check_flag(NeedsNullCheckFlag); }
<span class="line-modified"> 475   void set_null_free(bool f)                    { set_flag(NeverNullFlag, f); }</span>
<span class="line-modified"> 476   bool is_null_free() const                     { return check_flag(NeverNullFlag); }</span>
 477   bool is_linked() const                         { return check_flag(IsLinkedInBlockFlag); }
 478   bool can_be_linked()                           { return as_Local() == NULL &amp;&amp; as_Phi() == NULL; }
 479 
 480   bool is_null_obj()                             { return as_Constant() != NULL &amp;&amp; type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object(); }
 481 
 482   bool has_uses() const                          { return use_count() &gt; 0; }
 483   ValueStack* state_before() const               { return _state_before; }
 484   ValueStack* exception_state() const            { return _exception_state; }
 485   virtual bool needs_exception_state() const     { return true; }
 486   XHandlers* exception_handlers() const          { return _exception_handlers; }
 487   ciKlass* as_loaded_klass_or_null() const;
 488 
 489   // withfield optimization
 490   virtual void set_escaped()                     { }
 491   virtual void set_local_index(int index)        { }
 492   virtual bool is_optimizable_for_withfield() const { return false; }
 493 
 494 
 495   // manipulation
 496   void pin(PinReason reason)                     { _pin_state |= reason; }
</pre>
<hr />
<pre>
 725   }
 726 
 727   bool is_illegal() const {
 728     return type()-&gt;is_illegal();
 729   }
 730 
 731   // generic
 732   virtual void input_values_do(ValueVisitor* f) {
 733   }
 734 };
 735 
 736 
 737 // A local is a placeholder for an incoming argument to a function call.
 738 LEAF(Local, Instruction)
 739  private:
 740   int      _java_index;                          // the local index within the method to which the local belongs
 741   bool     _is_receiver;                         // if local variable holds the receiver: &quot;this&quot; for non-static methods
 742   ciType*  _declared_type;
 743  public:
 744   // creation
<span class="line-modified"> 745   Local(ciType* declared, ValueType* type, int index, bool receiver, bool null_free)</span>
 746     : Instruction(type)
 747     , _java_index(index)
 748     , _is_receiver(receiver)
 749     , _declared_type(declared)
 750   {
<span class="line-modified"> 751     set_null_free(null_free);</span>
 752     NOT_PRODUCT(set_printable_bci(-1));
 753   }
 754 
 755   // accessors
 756   int java_index() const                         { return _java_index; }
 757   bool is_receiver() const                       { return _is_receiver; }
 758 
 759   virtual ciType* declared_type() const          { return _declared_type; }
 760 
 761   // generic
 762   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
 763 };
 764 
 765 
 766 LEAF(Constant, Instruction)
 767  public:
 768   // creation
 769   Constant(ValueType* type):
 770       Instruction(type, NULL, /*type_is_constant*/ true)
 771   {
</pre>
<hr />
<pre>
 855   // proved the target object non-null, we can eliminate the explicit
 856   // null check and do an implicit one, simply specifying the debug
 857   // information from the NullCheck. This field should only be consulted
 858   // if needs_null_check() is true.
 859   void set_explicit_null_check(NullCheck* check) { _explicit_null_check = check; }
 860 
 861   // generic
 862   virtual bool can_trap() const                  { return needs_null_check() || needs_patching(); }
 863   virtual void input_values_do(ValueVisitor* f)   { f-&gt;visit(&amp;_obj); }
 864 };
 865 
 866 
 867 LEAF(LoadField, AccessField)
 868  public:
 869   // creation
 870   LoadField(Value obj, int offset, ciField* field, bool is_static,
 871             ValueStack* state_before, bool needs_patching,
 872             ciInlineKlass* inline_klass = NULL, Value default_value = NULL )
 873   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 874   {
<span class="line-modified"> 875     set_null_free(field-&gt;signature()-&gt;is_Q_signature());</span>
 876   }
 877 
 878   ciType* declared_type() const;
 879 
 880   // generic; cannot be eliminated if needs patching or if volatile.
 881   HASHING3(LoadField, !needs_patching() &amp;&amp; !field()-&gt;is_volatile(), obj()-&gt;subst(), offset(), declared_type())
 882 };
 883 
 884 
 885 LEAF(StoreField, AccessField)
 886  private:
 887   Value _value;
 888 
 889  public:
 890   // creation
 891   StoreField(Value obj, int offset, ciField* field, Value value, bool is_static,
 892              ValueStack* state_before, bool needs_patching)
 893   : AccessField(obj, offset, field, is_static, state_before, needs_patching)
 894   , _value(value)
 895   {
</pre>
<hr />
<pre>
1293   void set_state(ValueStack* state)              { assert(_state == NULL, &quot;overwriting existing state&quot;); check_state(state); _state = state; }
1294 
1295   // generic
1296   virtual void input_values_do(ValueVisitor* f)   { /* no values */ }
1297   virtual void state_values_do(ValueVisitor* f);
1298 };
1299 
1300 
1301 LEAF(Invoke, StateSplit)
1302  private:
1303   Bytecodes::Code _code;
1304   Value           _recv;
1305   Values*         _args;
1306   BasicTypeList*  _signature;
1307   int             _vtable_index;
1308   ciMethod*       _target;
1309 
1310  public:
1311   // creation
1312   Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
<span class="line-modified">1313          int vtable_index, ciMethod* target, ValueStack* state_before, bool null_free);</span>
1314 
1315   // accessors
1316   Bytecodes::Code code() const                   { return _code; }
1317   Value receiver() const                         { return _recv; }
1318   bool has_receiver() const                      { return receiver() != NULL; }
1319   int number_of_arguments() const                { return _args-&gt;length(); }
1320   Value argument_at(int i) const                 { return _args-&gt;at(i); }
1321   int vtable_index() const                       { return _vtable_index; }
1322   BasicTypeList* signature() const               { return _signature; }
1323   ciMethod* target() const                       { return _target; }
1324 
1325   ciType* declared_type() const;
1326 
1327   // Returns false if target is not loaded
1328   bool target_is_final() const                   { return check_flag(TargetIsFinalFlag); }
1329   bool target_is_loaded() const                  { return check_flag(TargetIsLoadedFlag); }
1330   // Returns false if target is not loaded
1331   bool target_is_strictfp() const                { return check_flag(TargetIsStrictfpFlag); }
1332 
1333   // JSR 292 support
</pre>
<hr />
<pre>
1375   bool _is_unresolved;
1376   ciInlineKlass* _klass;
1377   Value _depends_on;      // Link to instance on with withfield was called on
1378   bool _is_optimizable_for_withfield;
1379   int _first_local_index;
1380 public:
1381 
1382   // Default creation, always allocated for now
1383   NewInlineTypeInstance(ciInlineKlass* klass, ValueStack* state_before, bool is_unresolved, Value depends_on = NULL, bool from_default_value = false)
1384   : StateSplit(instanceType, state_before)
1385    , _is_unresolved(is_unresolved)
1386    , _klass(klass)
1387    , _is_optimizable_for_withfield(from_default_value)
1388    , _first_local_index(-1)
1389   {
1390     if (depends_on == NULL) {
1391       _depends_on = this;
1392     } else {
1393       _depends_on = depends_on;
1394     }
<span class="line-modified">1395     set_null_free(true);</span>
1396   }
1397 
1398   // accessors
1399   bool is_unresolved() const                     { return _is_unresolved; }
1400   Value depends_on();
1401 
1402   ciInlineKlass* klass() const { return _klass; }
1403 
1404   virtual bool needs_exception_state() const     { return false; }
1405 
1406   // generic
1407   virtual bool can_trap() const                  { return true; }
1408   ciType* exact_type() const;
1409   ciType* declared_type() const;
1410 
1411   // Only done in LIR Generator -&gt; map everything to object
1412   void set_to_object_type() { set_type(instanceType); }
1413 
1414   // withfield optimization
1415   virtual void set_escaped() {
</pre>
<hr />
<pre>
1460 
1461  public:
1462   // creation
1463   NewTypeArray(Value length, BasicType elt_type, ValueStack* state_before)
1464   : NewArray(length, state_before)
1465   , _elt_type(elt_type)
1466   {}
1467 
1468   // accessors
1469   BasicType elt_type() const                     { return _elt_type; }
1470   ciType* exact_type() const;
1471 };
1472 
1473 
1474 LEAF(NewObjectArray, NewArray)
1475  private:
1476   ciKlass* _klass;
1477 
1478  public:
1479   // creation
<span class="line-modified">1480   NewObjectArray(ciKlass* klass, Value length, ValueStack* state_before, bool null_free)</span>
1481   : NewArray(length, state_before), _klass(klass) {
<span class="line-modified">1482     set_null_free(null_free);</span>
1483   }
1484 
1485   // accessors
1486   ciKlass* klass() const                         { return _klass; }
1487   ciType* exact_type() const;
1488 };
1489 
1490 
1491 LEAF(NewMultiArray, NewArray)
1492  private:
1493   ciKlass* _klass;
1494   Values*  _dims;
1495 
1496  public:
1497   // creation
1498   NewMultiArray(ciKlass* klass, Values* dims, ValueStack* state_before) : NewArray(NULL, state_before), _klass(klass), _dims(dims) {
1499     ASSERT_VALUES
1500   }
1501 
1502   // accessors
</pre>
<hr />
<pre>
1559   // manipulation
1560   void set_direct_compare(bool flag)             { set_flag(DirectCompareFlag, flag); }
1561 
1562   // generic
1563   virtual bool can_trap() const                  { return true; }
1564   virtual void input_values_do(ValueVisitor* f)   { StateSplit::input_values_do(f); f-&gt;visit(&amp;_obj); }
1565 
1566   // Helpers for MethodData* profiling
1567   void set_should_profile(bool value)                { set_flag(ProfileMDOFlag, value); }
1568   void set_profiled_method(ciMethod* method)         { _profiled_method = method;   }
1569   void set_profiled_bci(int bci)                     { _profiled_bci = bci;         }
1570   bool      should_profile() const                   { return check_flag(ProfileMDOFlag); }
1571   ciMethod* profiled_method() const                  { return _profiled_method;     }
1572   int       profiled_bci() const                     { return _profiled_bci;        }
1573 };
1574 
1575 
1576 LEAF(CheckCast, TypeCheck)
1577  public:
1578   // creation
<span class="line-modified">1579   CheckCast(ciKlass* klass, Value obj, ValueStack* state_before, bool null_free = false)</span>
1580   : TypeCheck(klass, obj, objectType, state_before) {
<span class="line-modified">1581     set_null_free(null_free);</span>
1582   }
1583 
1584   void set_incompatible_class_change_check() {
1585     set_flag(ThrowIncompatibleClassChangeErrorFlag, true);
1586   }
1587   bool is_incompatible_class_change_check() const {
1588     return check_flag(ThrowIncompatibleClassChangeErrorFlag);
1589   }
1590   void set_invokespecial_receiver_check() {
1591     set_flag(InvokeSpecialReceiverCheckFlag, true);
1592   }
1593   bool is_invokespecial_receiver_check() const {
1594     return check_flag(InvokeSpecialReceiverCheckFlag);
1595   }
1596 
1597   virtual bool needs_exception_state() const {
1598     return !is_invokespecial_receiver_check();
1599   }
1600 
1601   ciType* declared_type() const;
</pre>
</td>
</tr>
</table>
<center><a href="c1_Instruction.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/c1/c1_Instruction.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_Instruction.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_Instruction.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 470,12 ***</span>
    Instruction* subst()                           { return _subst == NULL ? this : _subst-&gt;subst(); }
    LIR_Opr operand() const                        { return _operand; }
  
    void set_needs_null_check(bool f)              { set_flag(NeedsNullCheckFlag, f); }
    bool needs_null_check() const                  { return check_flag(NeedsNullCheckFlag); }
<span class="line-modified">!   void set_never_null(bool f)                    { set_flag(NeverNullFlag, f); }</span>
<span class="line-modified">!   bool is_never_null() const                     { return check_flag(NeverNullFlag); }</span>
    bool is_linked() const                         { return check_flag(IsLinkedInBlockFlag); }
    bool can_be_linked()                           { return as_Local() == NULL &amp;&amp; as_Phi() == NULL; }
  
    bool is_null_obj()                             { return as_Constant() != NULL &amp;&amp; type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object(); }
  
<span class="line-new-header">--- 470,12 ---</span>
    Instruction* subst()                           { return _subst == NULL ? this : _subst-&gt;subst(); }
    LIR_Opr operand() const                        { return _operand; }
  
    void set_needs_null_check(bool f)              { set_flag(NeedsNullCheckFlag, f); }
    bool needs_null_check() const                  { return check_flag(NeedsNullCheckFlag); }
<span class="line-modified">!   void set_null_free(bool f)                    { set_flag(NeverNullFlag, f); }</span>
<span class="line-modified">!   bool is_null_free() const                     { return check_flag(NeverNullFlag); }</span>
    bool is_linked() const                         { return check_flag(IsLinkedInBlockFlag); }
    bool can_be_linked()                           { return as_Local() == NULL &amp;&amp; as_Phi() == NULL; }
  
    bool is_null_obj()                             { return as_Constant() != NULL &amp;&amp; type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object(); }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 740,17 ***</span>
    int      _java_index;                          // the local index within the method to which the local belongs
    bool     _is_receiver;                         // if local variable holds the receiver: &quot;this&quot; for non-static methods
    ciType*  _declared_type;
   public:
    // creation
<span class="line-modified">!   Local(ciType* declared, ValueType* type, int index, bool receiver, bool never_null)</span>
      : Instruction(type)
      , _java_index(index)
      , _is_receiver(receiver)
      , _declared_type(declared)
    {
<span class="line-modified">!     set_never_null(never_null);</span>
      NOT_PRODUCT(set_printable_bci(-1));
    }
  
    // accessors
    int java_index() const                         { return _java_index; }
<span class="line-new-header">--- 740,17 ---</span>
    int      _java_index;                          // the local index within the method to which the local belongs
    bool     _is_receiver;                         // if local variable holds the receiver: &quot;this&quot; for non-static methods
    ciType*  _declared_type;
   public:
    // creation
<span class="line-modified">!   Local(ciType* declared, ValueType* type, int index, bool receiver, bool null_free)</span>
      : Instruction(type)
      , _java_index(index)
      , _is_receiver(receiver)
      , _declared_type(declared)
    {
<span class="line-modified">!     set_null_free(null_free);</span>
      NOT_PRODUCT(set_printable_bci(-1));
    }
  
    // accessors
    int java_index() const                         { return _java_index; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 870,11 ***</span>
    LoadField(Value obj, int offset, ciField* field, bool is_static,
              ValueStack* state_before, bool needs_patching,
              ciInlineKlass* inline_klass = NULL, Value default_value = NULL )
    : AccessField(obj, offset, field, is_static, state_before, needs_patching)
    {
<span class="line-modified">!     set_never_null(field-&gt;signature()-&gt;is_Q_signature());</span>
    }
  
    ciType* declared_type() const;
  
    // generic; cannot be eliminated if needs patching or if volatile.
<span class="line-new-header">--- 870,11 ---</span>
    LoadField(Value obj, int offset, ciField* field, bool is_static,
              ValueStack* state_before, bool needs_patching,
              ciInlineKlass* inline_klass = NULL, Value default_value = NULL )
    : AccessField(obj, offset, field, is_static, state_before, needs_patching)
    {
<span class="line-modified">!     set_null_free(field-&gt;signature()-&gt;is_Q_signature());</span>
    }
  
    ciType* declared_type() const;
  
    // generic; cannot be eliminated if needs patching or if volatile.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1308,11 ***</span>
    ciMethod*       _target;
  
   public:
    // creation
    Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
<span class="line-modified">!          int vtable_index, ciMethod* target, ValueStack* state_before, bool never_null);</span>
  
    // accessors
    Bytecodes::Code code() const                   { return _code; }
    Value receiver() const                         { return _recv; }
    bool has_receiver() const                      { return receiver() != NULL; }
<span class="line-new-header">--- 1308,11 ---</span>
    ciMethod*       _target;
  
   public:
    // creation
    Invoke(Bytecodes::Code code, ValueType* result_type, Value recv, Values* args,
<span class="line-modified">!          int vtable_index, ciMethod* target, ValueStack* state_before, bool null_free);</span>
  
    // accessors
    Bytecodes::Code code() const                   { return _code; }
    Value receiver() const                         { return _recv; }
    bool has_receiver() const                      { return receiver() != NULL; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1390,11 ***</span>
      if (depends_on == NULL) {
        _depends_on = this;
      } else {
        _depends_on = depends_on;
      }
<span class="line-modified">!     set_never_null(true);</span>
    }
  
    // accessors
    bool is_unresolved() const                     { return _is_unresolved; }
    Value depends_on();
<span class="line-new-header">--- 1390,11 ---</span>
      if (depends_on == NULL) {
        _depends_on = this;
      } else {
        _depends_on = depends_on;
      }
<span class="line-modified">!     set_null_free(true);</span>
    }
  
    // accessors
    bool is_unresolved() const                     { return _is_unresolved; }
    Value depends_on();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1475,13 ***</span>
   private:
    ciKlass* _klass;
  
   public:
    // creation
<span class="line-modified">!   NewObjectArray(ciKlass* klass, Value length, ValueStack* state_before, bool never_null)</span>
    : NewArray(length, state_before), _klass(klass) {
<span class="line-modified">!     set_never_null(never_null);</span>
    }
  
    // accessors
    ciKlass* klass() const                         { return _klass; }
    ciType* exact_type() const;
<span class="line-new-header">--- 1475,13 ---</span>
   private:
    ciKlass* _klass;
  
   public:
    // creation
<span class="line-modified">!   NewObjectArray(ciKlass* klass, Value length, ValueStack* state_before, bool null_free)</span>
    : NewArray(length, state_before), _klass(klass) {
<span class="line-modified">!     set_null_free(null_free);</span>
    }
  
    // accessors
    ciKlass* klass() const                         { return _klass; }
    ciType* exact_type() const;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1574,13 ***</span>
  
  
  LEAF(CheckCast, TypeCheck)
   public:
    // creation
<span class="line-modified">!   CheckCast(ciKlass* klass, Value obj, ValueStack* state_before, bool never_null = false)</span>
    : TypeCheck(klass, obj, objectType, state_before) {
<span class="line-modified">!     set_never_null(never_null);</span>
    }
  
    void set_incompatible_class_change_check() {
      set_flag(ThrowIncompatibleClassChangeErrorFlag, true);
    }
<span class="line-new-header">--- 1574,13 ---</span>
  
  
  LEAF(CheckCast, TypeCheck)
   public:
    // creation
<span class="line-modified">!   CheckCast(ciKlass* klass, Value obj, ValueStack* state_before, bool null_free = false)</span>
    : TypeCheck(klass, obj, objectType, state_before) {
<span class="line-modified">!     set_null_free(null_free);</span>
    }
  
    void set_incompatible_class_change_check() {
      set_flag(ThrowIncompatibleClassChangeErrorFlag, true);
    }
</pre>
<center><a href="c1_Instruction.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
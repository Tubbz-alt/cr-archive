<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_GraphBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/x86/c1_LIRGenerator_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Instruction.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_GraphBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2401 void GraphBuilder::default_value(int klass_index) {
2402   bool will_link;
2403   if (!stream()-&gt;is_unresolved_klass()) {
2404     ciInlineKlass* vk = stream()-&gt;get_klass(will_link)-&gt;as_inline_klass();
2405     apush(append(new Constant(new InstanceConstant(vk-&gt;default_instance()))));
2406   } else {
2407     ValueStack* state_before = copy_state_before();
2408     apush(append_split(new DefaultValue(state_before)));
2409   }
2410 }
2411 
2412 void GraphBuilder::new_type_array() {
2413   ValueStack* state_before = copy_state_exhandling();
2414   apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()-&gt;get_index(), state_before)));
2415 }
2416 
2417 
2418 void GraphBuilder::new_object_array() {
2419   bool will_link;
2420   ciKlass* klass = stream()-&gt;get_klass(will_link);
<span class="line-modified">2421   bool never_null = stream()-&gt;is_inline_klass();</span>
2422   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
<span class="line-modified">2423   NewArray* n = new NewObjectArray(klass, ipop(), state_before, never_null);</span>
2424   apush(append_split(n));
2425 }
2426 
2427 
2428 bool GraphBuilder::direct_compare(ciKlass* k) {
2429   if (k-&gt;is_loaded() &amp;&amp; k-&gt;is_instance_klass() &amp;&amp; !UseSlowPath) {
2430     ciInstanceKlass* ik = k-&gt;as_instance_klass();
2431     if (ik-&gt;is_final()) {
2432       return true;
2433     } else {
2434       if (DeoptC1 &amp;&amp; UseCHA &amp;&amp; !(ik-&gt;has_subklass() || ik-&gt;is_interface())) {
2435         // test class is leaf class
2436         dependency_recorder()-&gt;assert_leaf_type(ik);
2437         return true;
2438       }
2439     }
2440   }
2441   return false;
2442 }
2443 
2444 
2445 void GraphBuilder::check_cast(int klass_index) {
2446   bool will_link;
2447   ciKlass* klass = stream()-&gt;get_klass(will_link);
<span class="line-modified">2448   bool never_null = stream()-&gt;is_inline_klass();</span>
2449   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_for_exception();
<span class="line-modified">2450   CheckCast* c = new CheckCast(klass, apop(), state_before, never_null);</span>
2451   apush(append_split(c));
2452   c-&gt;set_direct_compare(direct_compare(klass));
2453 
2454   if (is_profiling()) {
2455     // Note that we&#39;d collect profile data in this method if we wanted it.
2456     compilation()-&gt;set_would_profile(true);
2457 
2458     if (profile_checkcasts()) {
2459       c-&gt;set_profiled_method(method());
2460       c-&gt;set_profiled_bci(bci());
2461       c-&gt;set_should_profile(true);
2462     }
2463   }
2464 }
2465 
2466 
2467 void GraphBuilder::instance_of(int klass_index) {
2468   bool will_link;
2469   ciKlass* klass = stream()-&gt;get_klass(will_link);
2470   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
</pre>
<hr />
<pre>
3440 
3441   assert(state-&gt;caller_state() == NULL, &quot;should be top scope&quot;);
3442   state-&gt;clear_locals();
3443   Goto* g = new Goto(target, false);
3444   append(g);
3445   _osr_entry-&gt;set_end(g);
3446   target-&gt;merge(_osr_entry-&gt;end()-&gt;state());
3447 
3448   scope_data()-&gt;set_stream(NULL);
3449 }
3450 
3451 
3452 ValueStack* GraphBuilder::state_at_entry() {
3453   ValueStack* state = new ValueStack(scope(), NULL);
3454 
3455   // Set up locals for receiver
3456   int idx = 0;
3457   if (!method()-&gt;is_static()) {
3458     // we should always see the receiver
3459     state-&gt;store_local(idx, new Local(method()-&gt;holder(), objectType, idx,
<span class="line-modified">3460              /*receiver*/ true, /*never_null*/ method()-&gt;holder()-&gt;is_flat_array_klass()));</span>
3461     idx = 1;
3462   }
3463 
3464   // Set up locals for incoming arguments
3465   ciSignature* sig = method()-&gt;signature();
3466   for (int i = 0; i &lt; sig-&gt;count(); i++) {
3467     ciType* type = sig-&gt;type_at(i);
3468     BasicType basic_type = type-&gt;basic_type();
3469     // don&#39;t allow T_ARRAY to propagate into locals types
3470     if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3471     ValueType* vt = as_ValueType(basic_type);
3472     state-&gt;store_local(idx, new Local(type, vt, idx, false, type-&gt;is_inlinetype()));
3473     idx += type-&gt;size();
3474   }
3475 
3476   // lock synchronized method
3477   if (method()-&gt;is_synchronized()) {
3478     state-&gt;lock(NULL);
3479   }
3480 
</pre>
</td>
<td>
<hr />
<pre>
2401 void GraphBuilder::default_value(int klass_index) {
2402   bool will_link;
2403   if (!stream()-&gt;is_unresolved_klass()) {
2404     ciInlineKlass* vk = stream()-&gt;get_klass(will_link)-&gt;as_inline_klass();
2405     apush(append(new Constant(new InstanceConstant(vk-&gt;default_instance()))));
2406   } else {
2407     ValueStack* state_before = copy_state_before();
2408     apush(append_split(new DefaultValue(state_before)));
2409   }
2410 }
2411 
2412 void GraphBuilder::new_type_array() {
2413   ValueStack* state_before = copy_state_exhandling();
2414   apush(append_split(new NewTypeArray(ipop(), (BasicType)stream()-&gt;get_index(), state_before)));
2415 }
2416 
2417 
2418 void GraphBuilder::new_object_array() {
2419   bool will_link;
2420   ciKlass* klass = stream()-&gt;get_klass(will_link);
<span class="line-modified">2421   bool null_free = stream()-&gt;is_inline_klass();</span>
2422   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
<span class="line-modified">2423   NewArray* n = new NewObjectArray(klass, ipop(), state_before, null_free);</span>
2424   apush(append_split(n));
2425 }
2426 
2427 
2428 bool GraphBuilder::direct_compare(ciKlass* k) {
2429   if (k-&gt;is_loaded() &amp;&amp; k-&gt;is_instance_klass() &amp;&amp; !UseSlowPath) {
2430     ciInstanceKlass* ik = k-&gt;as_instance_klass();
2431     if (ik-&gt;is_final()) {
2432       return true;
2433     } else {
2434       if (DeoptC1 &amp;&amp; UseCHA &amp;&amp; !(ik-&gt;has_subklass() || ik-&gt;is_interface())) {
2435         // test class is leaf class
2436         dependency_recorder()-&gt;assert_leaf_type(ik);
2437         return true;
2438       }
2439     }
2440   }
2441   return false;
2442 }
2443 
2444 
2445 void GraphBuilder::check_cast(int klass_index) {
2446   bool will_link;
2447   ciKlass* klass = stream()-&gt;get_klass(will_link);
<span class="line-modified">2448   bool null_free = stream()-&gt;is_inline_klass();</span>
2449   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_for_exception();
<span class="line-modified">2450   CheckCast* c = new CheckCast(klass, apop(), state_before, null_free);</span>
2451   apush(append_split(c));
2452   c-&gt;set_direct_compare(direct_compare(klass));
2453 
2454   if (is_profiling()) {
2455     // Note that we&#39;d collect profile data in this method if we wanted it.
2456     compilation()-&gt;set_would_profile(true);
2457 
2458     if (profile_checkcasts()) {
2459       c-&gt;set_profiled_method(method());
2460       c-&gt;set_profiled_bci(bci());
2461       c-&gt;set_should_profile(true);
2462     }
2463   }
2464 }
2465 
2466 
2467 void GraphBuilder::instance_of(int klass_index) {
2468   bool will_link;
2469   ciKlass* klass = stream()-&gt;get_klass(will_link);
2470   ValueStack* state_before = !klass-&gt;is_loaded() || PatchALot ? copy_state_before() : copy_state_exhandling();
</pre>
<hr />
<pre>
3440 
3441   assert(state-&gt;caller_state() == NULL, &quot;should be top scope&quot;);
3442   state-&gt;clear_locals();
3443   Goto* g = new Goto(target, false);
3444   append(g);
3445   _osr_entry-&gt;set_end(g);
3446   target-&gt;merge(_osr_entry-&gt;end()-&gt;state());
3447 
3448   scope_data()-&gt;set_stream(NULL);
3449 }
3450 
3451 
3452 ValueStack* GraphBuilder::state_at_entry() {
3453   ValueStack* state = new ValueStack(scope(), NULL);
3454 
3455   // Set up locals for receiver
3456   int idx = 0;
3457   if (!method()-&gt;is_static()) {
3458     // we should always see the receiver
3459     state-&gt;store_local(idx, new Local(method()-&gt;holder(), objectType, idx,
<span class="line-modified">3460              /*receiver*/ true, /*null_free*/ method()-&gt;holder()-&gt;is_flat_array_klass()));</span>
3461     idx = 1;
3462   }
3463 
3464   // Set up locals for incoming arguments
3465   ciSignature* sig = method()-&gt;signature();
3466   for (int i = 0; i &lt; sig-&gt;count(); i++) {
3467     ciType* type = sig-&gt;type_at(i);
3468     BasicType basic_type = type-&gt;basic_type();
3469     // don&#39;t allow T_ARRAY to propagate into locals types
3470     if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3471     ValueType* vt = as_ValueType(basic_type);
3472     state-&gt;store_local(idx, new Local(type, vt, idx, false, type-&gt;is_inlinetype()));
3473     idx += type-&gt;size();
3474   }
3475 
3476   // lock synchronized method
3477   if (method()-&gt;is_synchronized()) {
3478     state-&gt;lock(NULL);
3479   }
3480 
</pre>
</td>
</tr>
</table>
<center><a href="../../cpu/x86/c1_LIRGenerator_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_Instruction.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
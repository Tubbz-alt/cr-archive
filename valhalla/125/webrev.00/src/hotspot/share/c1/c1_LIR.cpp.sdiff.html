<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_LIR.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_Instruction.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_LIR.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1489                     lir_unlock,
1490                     hdr,
1491                     obj,
1492                     lock,
1493                     scratch,
1494                     stub,
1495                     NULL));
1496 }
1497 
1498 
1499 void check_LIR() {
1500   // cannot do the proper checking as PRODUCT and other modes return different results
1501   // guarantee(sizeof(LIR_OprDesc) == wordSize, &quot;may not have a v-table&quot;);
1502 }
1503 
1504 
1505 
1506 void LIR_List::checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
1507                           LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
1508                           CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
<span class="line-modified">1509                           ciMethod* profiled_method, int profiled_bci, bool is_never_null) {</span>
1510   // If klass is non-nullable,  LIRGenerator::do_CheckCast has already performed null-check
1511   // on the object.
<span class="line-modified">1512   bool need_null_check = !is_never_null;</span>
1513   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_checkcast, result, object, klass,
1514                                            tmp1, tmp2, tmp3, fast_check, info_for_exception, info_for_patch, stub,
1515                                            need_null_check);
1516   if (profiled_method != NULL) {
1517     c-&gt;set_profiled_method(profiled_method);
1518     c-&gt;set_profiled_bci(profiled_bci);
1519     c-&gt;set_should_profile(true);
1520   }
1521   append(c);
1522 }
1523 
1524 void LIR_List::instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci) {
1525   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_instanceof, result, object, klass, tmp1, tmp2, tmp3, fast_check, NULL, info_for_patch, NULL);
1526   if (profiled_method != NULL) {
1527     c-&gt;set_profiled_method(profiled_method);
1528     c-&gt;set_profiled_bci(profiled_bci);
1529     c-&gt;set_should_profile(true);
1530   }
1531   append(c);
1532 }
</pre>
</td>
<td>
<hr />
<pre>
1489                     lir_unlock,
1490                     hdr,
1491                     obj,
1492                     lock,
1493                     scratch,
1494                     stub,
1495                     NULL));
1496 }
1497 
1498 
1499 void check_LIR() {
1500   // cannot do the proper checking as PRODUCT and other modes return different results
1501   // guarantee(sizeof(LIR_OprDesc) == wordSize, &quot;may not have a v-table&quot;);
1502 }
1503 
1504 
1505 
1506 void LIR_List::checkcast (LIR_Opr result, LIR_Opr object, ciKlass* klass,
1507                           LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check,
1508                           CodeEmitInfo* info_for_exception, CodeEmitInfo* info_for_patch, CodeStub* stub,
<span class="line-modified">1509                           ciMethod* profiled_method, int profiled_bci, bool is_null_free) {</span>
1510   // If klass is non-nullable,  LIRGenerator::do_CheckCast has already performed null-check
1511   // on the object.
<span class="line-modified">1512   bool need_null_check = !is_null_free;</span>
1513   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_checkcast, result, object, klass,
1514                                            tmp1, tmp2, tmp3, fast_check, info_for_exception, info_for_patch, stub,
1515                                            need_null_check);
1516   if (profiled_method != NULL) {
1517     c-&gt;set_profiled_method(profiled_method);
1518     c-&gt;set_profiled_bci(profiled_bci);
1519     c-&gt;set_should_profile(true);
1520   }
1521   append(c);
1522 }
1523 
1524 void LIR_List::instanceof(LIR_Opr result, LIR_Opr object, ciKlass* klass, LIR_Opr tmp1, LIR_Opr tmp2, LIR_Opr tmp3, bool fast_check, CodeEmitInfo* info_for_patch, ciMethod* profiled_method, int profiled_bci) {
1525   LIR_OpTypeCheck* c = new LIR_OpTypeCheck(lir_instanceof, result, object, klass, tmp1, tmp2, tmp3, fast_check, NULL, info_for_patch, NULL);
1526   if (profiled_method != NULL) {
1527     c-&gt;set_profiled_method(profiled_method);
1528     c-&gt;set_profiled_bci(profiled_bci);
1529     c-&gt;set_should_profile(true);
1530   }
1531   append(c);
1532 }
</pre>
</td>
</tr>
</table>
<center><a href="c1_Instruction.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIR.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
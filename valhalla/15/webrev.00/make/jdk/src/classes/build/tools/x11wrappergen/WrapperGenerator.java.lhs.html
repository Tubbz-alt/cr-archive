<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames make/jdk/src/classes/build/tools/x11wrappergen/WrapperGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package build.tools.x11wrappergen;
  27 
  28 import java.util.*;
  29 import java.io.*;
  30 import java.nio.charset.*;
  31 import java.text.MessageFormat;
  32 import java.util.logging.Level;
  33 import java.util.logging.Logger;
  34 
  35 public class WrapperGenerator {
  36     /* XLibParser converts Xlib.h to a Java Object that encapsulates the
  37      * X11 API and data structures */
  38     // Charset and decoder for ISO-8859-15
  39     private final static Logger log = Logger.getLogger(&quot;WrapperGenerator&quot;);
  40     boolean generateLog = true;
  41     boolean wide;
  42     private static Charset charset = Charset.forName(&quot;ISO-8859-15&quot;);
  43 
  44     String package_name = &quot;sun.awt.X11&quot;;
  45     String package_path = &quot;sun/awt/X11&quot;;
  46     String sizerFileName = &quot;sizer.c&quot;;
  47     String defaultBaseClass = &quot;XWrapperBase&quot;;
  48 
  49     String compile_options = &quot;-lX11&quot;;
<a name="2" id="anc2"></a><span class="line-modified">  50     static Hashtable symbolTable = new Hashtable();</span>
<span class="line-modified">  51     static Hashtable sizeTable32bit = new Hashtable();</span>
<span class="line-modified">  52     static Hashtable sizeTable64bit = new Hashtable();</span>
<span class="line-modified">  53     static Hashtable knownSizes32 = new Hashtable();</span>
<span class="line-modified">  54     static Hashtable knownSizes64 = new Hashtable();</span>
  55     static {
  56 /*
  57         knownSizes64.put(&quot;&quot;, Integer.valueOf());
  58         knownSizes32.put(&quot;&quot;, Integer.valueOf());
  59 */
  60         knownSizes64.put(&quot;XComposeStatus&quot;, Integer.valueOf(16));
  61         knownSizes64.put(&quot;XTimeCoord&quot;, Integer.valueOf(16));
  62         knownSizes64.put(&quot;XExtData&quot;, Integer.valueOf(32));
  63         knownSizes64.put(&quot;XWindowChanges&quot;, Integer.valueOf(40));
  64         knownSizes64.put(&quot;XOMCharSetList&quot;, Integer.valueOf(16));
  65         knownSizes64.put(&quot;XModifierKeymap&quot;, Integer.valueOf(16));
  66         knownSizes32.put(&quot;XIMValuesList&quot;, Integer.valueOf(8));
  67         knownSizes32.put(&quot;XGCValues&quot;, Integer.valueOf(92));
  68 //          knownSizes32.put(&quot;XIMStringConversionCallbackStruct&quot;, Integer.valueOf(16));
  69     }
  70 
  71     private static abstract class BaseType {
  72 
  73         String real_type;
  74         String name;
  75 
  76 
  77         public String getName() {
  78             return name;
  79         }
  80         public String getRealType() {
  81             return real_type;
  82         }
  83 
  84         public String toString() {
  85             return name;
  86         }
  87     }
  88 
  89     private static class AtomicType extends BaseType {
  90 
  91         private boolean alias;
  92         private String aliasName;
  93 
  94         static final int TYPE_INT=0;
  95         static final int TYPE_CHAR=1;
  96         static final int TYPE_LONG=2;
  97         static final int TYPE_LONG_LONG=3;
  98         static final int TYPE_DOUBLE=4;
  99         static final int TYPE_FLOAT=5;
 100         static final int TYPE_PTR=6;
 101         static final int TYPE_SHORT=7;
 102         static final int TYPE_BOOL = 8;
 103         static final int TYPE_STRUCT = 9;
 104         static final int TYPE_ARRAY = 10;
 105         static final int TYPE_BYTE=11;
 106         static final int TYPE_ATOM = 12;
 107         static final int TYPE_ULONG = 13;
 108         static int getTypeForString(String str) {
 109             int type=-1;
 110             if (str.equals(&quot;int&quot;))
 111                 type = AtomicType.TYPE_INT;
 112             else if (str.equals(&quot;long&quot;))
 113                 type = AtomicType.TYPE_LONG;
 114             else if (str.equals(&quot;byte&quot;))
 115                 type = AtomicType.TYPE_BYTE;
 116             else if (str.equals(&quot;char&quot;))
 117                 type = AtomicType.TYPE_CHAR;
 118             else if (str.equals(&quot;long long&quot;))
 119                 type = AtomicType.TYPE_LONG_LONG;
 120             else if (str.equals(&quot;double&quot;))
 121                 type = AtomicType.TYPE_DOUBLE;
 122             else if (str.equals(&quot;float&quot;))
 123                 type = AtomicType.TYPE_FLOAT;
 124             else if (str.equals(&quot;pointer&quot;))
 125                 type = AtomicType.TYPE_PTR;
 126             else if (str.equals(&quot;short&quot;))
 127                 type = AtomicType.TYPE_SHORT;
 128             else if (str.equals(&quot;Bool&quot;))
 129                 type = AtomicType.TYPE_BOOL;
 130             else if (str.equals(&quot;struct&quot;))
 131                 type = AtomicType.TYPE_STRUCT;
 132             else if (str.equals(&quot;Atom&quot;))
 133                 type = AtomicType.TYPE_ATOM;
 134             else if (str.equals(&quot;array&quot;))
 135                 type = TYPE_ARRAY;
 136             else if (str.equals(&quot;ulong&quot;))
 137                 type = TYPE_ULONG;
 138             else throw new IllegalArgumentException(&quot;Uknown type string: &quot; + str);
 139 
 140             return type;
 141         }
 142         String getJavaType() {
 143             if (referencedType != null) {
 144                 if (referencedType instanceof AtomicType) {
 145                     return ((AtomicType)referencedType).getJavaType();
 146                 } else {
 147                     return referencedType.getName();
 148                 }
 149             } else {
 150                 return getJavaTypeForType(type);
 151             }
 152         }
 153         static String getJavaTypeForType(int type) {
 154             switch (type) {
 155               case TYPE_INT:
 156                   return &quot;int&quot;;
 157               case TYPE_CHAR:
 158                   return &quot;char&quot;;
 159               case TYPE_BYTE:
 160                   return &quot;byte&quot;;
 161               case TYPE_LONG:
 162               case TYPE_LONG_LONG:
 163               case TYPE_PTR:
 164               case TYPE_ULONG:
 165                   return &quot;long&quot;;
 166               case TYPE_DOUBLE:
 167                   return &quot;double&quot;;
 168               case TYPE_FLOAT:
 169                   return &quot;float&quot;;
 170               case TYPE_SHORT:
 171                   return &quot;short&quot;;
 172               case TYPE_BOOL:
 173                   return &quot;boolean&quot;;
 174               case TYPE_ATOM:
 175                   return &quot;long&quot;;
 176               default:
 177                   throw new IllegalArgumentException(&quot;Unknown type: &quot; + type);
 178             }
 179         }
 180         String getItemSize() {
 181             if (referencedType != null) {
 182                   if (referencedType instanceof StructType) {
 183                       return ((StructType)referencedType).getSize();
 184                   } else {
 185                       return ((AtomicType)referencedType).getItemSize();
 186                   }
 187             } else {
 188                 int i32 = getNativeSizeForAccess(getJavaAccess(false));
 189                 int i64 = getNativeSizeForAccess(getJavaAccess(true));
 190                 if (i32 != i64) {
 191                     return &quot;Native.get&quot; + getNativeAccess() + &quot;Size()&quot;;
 192                 } else {
 193                     return Integer.toString(i32);
 194                 }
 195             }
 196         }
 197 
 198         String getJavaResult(String offset, String base) {
 199             String res = null;
 200             switch (type) {
 201               case TYPE_STRUCT:
 202                   res = &quot;pData + &quot; + offset;
 203                   break;
 204               case TYPE_PTR:
 205                   if (referencedType == null || referencedType instanceof StructType) {
 206                       res = base + &quot;+&quot; + offset;
 207                   } else if (referencedType instanceof AtomicType) {
 208                       res = MessageFormat.format(&quot;Native.get{0}({1})&quot;,
 209                                                  new Object[] {getNativeAccessForType(((AtomicType)referencedType).type),
 210                                                                base + &quot;+&quot; + offset});
 211                   }
 212                   break;
 213               case TYPE_ARRAY:
 214                   if (referencedType instanceof StructType) {
 215                       res = &quot;pData + &quot; + offset;
 216                   }  else if (referencedType instanceof AtomicType) {
 217                       res = MessageFormat.format(&quot;Native.get{0}(pData + {1})&quot;,
 218                                                  new Object[] {getNativeAccessForType(((AtomicType)referencedType).type),
 219                                                                offset});
 220                   }
 221                   break;
 222               default:
 223                 res = MessageFormat.format(&quot;(Native.get{0}(pData+{1}))&quot;,
 224                                            new Object[] {getNativeAccess(), offset});
 225             }
 226             return getJavaResultConversion(res, base);
 227         }
 228         String getJavaResultConversion(String value, String base) {
 229             if (referencedType != null) {
 230                 if (referencedType instanceof StructType) {
 231                     if (type == TYPE_PTR) {
 232                         return MessageFormat.format(&quot;({2} != 0)?(new {0}({1})):(null)&quot;, new Object[] {referencedType.getName(),value, base});
 233                     } else {
 234                         return MessageFormat.format(&quot;new {0}({1})&quot;, new Object[] {referencedType.getName(),value});
 235                     }
 236                 } else {
 237                     return value;
 238                 }
 239             } else {
 240                 return getJavaResultConversionForType(type, value);
 241             }
 242         }
 243         static String getJavaResultConversionForType(int type, String value) {
 244             return value;
 245         }
 246         String getNativeAccess() {
 247             return getNativeAccessForType(type);
 248         }
 249         String getJavaAccess(boolean wide) {
 250             return getJavaAccessForType(type, wide);
 251         }
 252         static String getJavaAccessForType(int type, boolean wide) {
 253             switch (type) {
 254               case TYPE_INT:
 255                   return &quot;Int&quot;;
 256               case TYPE_CHAR:
 257                   return &quot;Char&quot;;
 258               case TYPE_BYTE:
 259                   return &quot;Byte&quot;;
 260               case TYPE_LONG:
 261               case TYPE_PTR:
 262               case TYPE_ARRAY:
 263               case TYPE_STRUCT:
 264               case TYPE_ATOM:
 265                   return (wide?&quot;Long&quot;:&quot;Int&quot;);
 266               case TYPE_LONG_LONG:
 267                   return &quot;Long&quot;;
 268               case TYPE_ULONG:
 269                   return (wide?&quot;ULong&quot;:&quot;UInt&quot;);
 270               case TYPE_DOUBLE:
 271                   return &quot;Double&quot;;
 272               case TYPE_FLOAT:
 273                   return &quot;Float&quot;;
 274               case TYPE_SHORT:
 275                   return &quot;Short&quot;;
 276               case TYPE_BOOL:
 277                   return &quot;Int&quot;;
 278               default:
 279                   throw new IllegalArgumentException(&quot;Unknown type: &quot; + type);
 280             }
 281         }
 282         static String getNativeAccessForType(int type) {
 283             switch (type) {
 284               case TYPE_INT:
 285                   return &quot;Int&quot;;
 286               case TYPE_CHAR:
 287                   return &quot;Char&quot;;
 288               case TYPE_BYTE:
 289                   return &quot;Byte&quot;;
 290               case TYPE_LONG:
 291               case TYPE_PTR:
 292               case TYPE_ARRAY:
 293               case TYPE_STRUCT:
 294                   return &quot;Long&quot;;
 295               case TYPE_LONG_LONG:
 296                   return &quot;Long&quot;;
 297               case TYPE_ULONG:
 298                   return &quot;ULong&quot;;
 299               case TYPE_DOUBLE:
 300                   return &quot;Double&quot;;
 301               case TYPE_FLOAT:
 302                   return &quot;Float&quot;;
 303               case TYPE_SHORT:
 304                   return &quot;Short&quot;;
 305               case TYPE_BOOL:
 306                   return &quot;Bool&quot;;
 307               case TYPE_ATOM:
 308                   return &quot;Long&quot;;
 309               default:
 310                   throw new IllegalArgumentException(&quot;Unknown type: &quot; + type);
 311             }
 312         }
 313 
 314         static int getNativeSizeForAccess(String access) {
 315             if (access.equals(&quot;Int&quot;)) return 4;
 316             else if (access.equals(&quot;Byte&quot;)) return 1;
 317             else if (access.equals(&quot;Long&quot;)) return 8;
 318             else if (access.equals(&quot;Double&quot;)) return 8;
 319             else if (access.equals(&quot;Float&quot;)) return 4;
 320             else if (access.equals(&quot;Char&quot;)) return 2;
 321             else if (access.equals(&quot;Short&quot;)) return 2;
 322             else if (access.equals(&quot;ULong&quot;)) return 8;
 323             else if (access.equals(&quot;UInt&quot;)) return 4;
 324             else throw new IllegalArgumentException(&quot;Unknow access type: &quot; + access);
 325         }
 326 
 327         String getJavaConversion(String offset, String value) {
 328             if (referencedType != null) {
 329                 if (referencedType instanceof StructType) {
 330                     return getJavaConversionForType(TYPE_PTR, offset, value + &quot;.pData&quot;);
 331                 } else {
 332                     if (type == TYPE_ARRAY) {
 333                         return getJavaConversionForType(((AtomicType)referencedType).type, offset, value);
 334                     } else { // TYPE_PTR
 335                         return getJavaConversionForType(TYPE_PTR, offset, value);
 336                     }
 337                 }
 338             } else {
 339                 return getJavaConversionForType(type, offset, value);
 340             }
 341         }
 342         static String getJavaConversionForType(int type, String offset, String value) {
 343             return MessageFormat.format(&quot;Native.put{0}({2}, {1})&quot;, new Object[] {getNativeAccessForType(type), value, offset});
 344         }
 345 
 346 
 347         int type;
 348         int offset;
 349         int direction;
 350         BaseType referencedType;
 351         int arrayLength = -1;
 352         boolean autoFree = false;
 353         public AtomicType(int _type,String _name, String _real_type) {
 354             name = _name.replaceAll(&quot;[* \t]&quot;,&quot;&quot;);
 355             if ((name.indexOf(&quot;[&quot;) != -1) || (name.indexOf(&quot;]&quot;) != -1))
 356             {
 357                 name = name.replaceAll(&quot;\\[.*\\]&quot;,&quot;&quot;);
 358             }
 359             type = _type;
 360             real_type = _real_type;
 361             if (real_type == null)
 362             {
 363                 System.out.println(&quot; real type is null&quot;);
 364 
 365             }
 366         }
 367         public boolean isIn() {
 368             return direction == 0;
 369         }
 370         public boolean isOut() {
 371             return direction == 1;
 372         }
 373         public boolean isInOut() {
 374             return direction == 2;
 375         }
 376         public boolean isAutoFree() {
 377             return autoFree;
 378         }
 379         public void setAttributes(String[] attributes) {
 380             String mod = attributes[3];
 381             if (&quot;in&quot;.equals(mod)) {
 382                 direction = 0;
 383             } else if (&quot;out&quot;.equals(mod)) {
 384                 direction = 1;
 385                 if (attributes.length &gt; 4 &amp;&amp; &quot;free&quot;.equals(attributes[4])) {
 386                     autoFree = true;
 387                 }
 388             } else if (&quot;inout&quot;.equals(mod)) {
 389                 direction = 2;
 390             } else if (&quot;alias&quot;.equals(mod)) {
 391                 alias = true;
 392                 aliasName = attributes[4];
 393             } else if (type == TYPE_ARRAY || type == TYPE_PTR || type == TYPE_STRUCT) {
<a name="3" id="anc3"></a><span class="line-modified"> 394                 referencedType = (BaseType)symbolTable.get(mod);</span>
 395                 if (referencedType == null) {
 396                     log.warning(&quot;Can&#39;t find type for name &quot; + mod);
 397                 }
 398                 if (attributes.length &gt; 4) { // array length
 399                     try {
 400                         arrayLength = Integer.parseInt(attributes[4]);
 401                     } catch (Exception e) {
 402                     }
 403                 }
 404             }
 405         }
 406         public BaseType getReferencedType() {
 407             return referencedType;
 408         }
 409         public int getArrayLength() {
 410             return arrayLength;
 411         }
 412         public void setOffset(int o)
 413         {
 414             offset = o;
 415         }
 416         public int getType() {
 417             return type;
 418         }
 419         public String getTypeUpperCase() {
 420             switch (type) {
 421               case TYPE_INT:
 422                   return &quot;Int&quot;;
 423               case TYPE_CHAR:
 424                   return &quot;Char&quot;;
 425               case TYPE_BYTE:
 426                   return &quot;Byte&quot;;
 427               case TYPE_LONG:
 428               case TYPE_LONG_LONG:
 429               case TYPE_PTR:
 430                   return &quot;Long&quot;;
 431               case TYPE_DOUBLE:
 432                   return &quot;Double&quot;;
 433               case TYPE_FLOAT:
 434                   return &quot;Float&quot;;
 435               case TYPE_SHORT:
 436                   return &quot;Short&quot;;
 437               case TYPE_BOOL:
 438                   return &quot;Int&quot;;
 439               case TYPE_ATOM:
 440                   return &quot;Long&quot;;
 441               case TYPE_ULONG:
 442                   return &quot;ULong&quot;;
 443               default: throw new IllegalArgumentException(&quot;Uknown type&quot;);
 444             }
 445         }
 446         public int getOffset()
 447         {
 448             return offset;
 449         }
 450         public boolean isAlias() {
 451             return alias;
 452         }
 453         public String getAliasName() {
 454             return aliasName;
 455         }
 456     }
 457 
 458     private static class StructType extends BaseType {
 459 
<a name="4" id="anc4"></a><span class="line-modified"> 460         Vector members;</span>
 461         String description;
 462         boolean packed;
 463         int size;
 464         String baseClass, interfaces;
 465         boolean isInterface;
 466         String javaClassName;
 467 
 468         /**
 469          * Construct new structured type.
 470          * Description is used for name and type definition and has the following format:
 471          * structName [ &#39;[&#39; base classe &#39;]&#39; ] [ &#39;{&#39; interfaces &#39;}&#39; ] [ &#39;|&#39; javaClassName ]
 472          */
 473         public StructType(String _desc)
 474         {
<a name="5" id="anc5"></a><span class="line-modified"> 475             members = new Vector();</span>
 476             parseDescription(_desc);
 477         }
 478         public int getNumFields()
 479         {
 480             return members.size();
 481         }
 482         public void setName(String _name)
 483         {
 484             _name = _name.replaceAll(&quot;[* \t]&quot;,&quot;&quot;);
 485             parseDescription(_name);
 486         }
 487 
 488         public void setSize(int i)
 489         {
 490             size = i;
 491         }
 492 
 493         public String getDescription()
 494         {
 495             return description;
 496         }
 497 
<a name="6" id="anc6"></a><span class="line-modified"> 498         public Enumeration getMembers()</span>
 499         {
 500             return members.elements();
 501         }
 502 
 503         public void addMember(BaseType tp)
 504         {
 505             members.add(tp);
 506         }
 507         public String getBaseClass() {
 508             return baseClass;
 509         }
 510         public String getInterfaces() {
 511             return interfaces;
 512         }
 513         public boolean getIsInterface() {
 514             return isInterface;
 515         }
 516         public String getJavaClassName() {
 517             return javaClassName;
 518         }
 519         void parseDescription(String _desc) {
 520             if (_desc.indexOf(&#39;[&#39;) != -1) { // Has base class
 521                 baseClass = _desc.substring(_desc.indexOf(&#39;[&#39;)+1, _desc.indexOf(&#39;]&#39;));
 522                 _desc = _desc.substring(0, _desc.indexOf(&#39;[&#39;)) + _desc.substring(_desc.indexOf(&#39;]&#39;)+1);
 523             }
 524             if (_desc.indexOf(&#39;{&#39;) != -1) { // Has base class
 525                 interfaces = _desc.substring(_desc.indexOf(&#39;{&#39;)+1, _desc.indexOf(&#39;}&#39;));
 526                 _desc = _desc.substring(0, _desc.indexOf(&#39;{&#39;)) + _desc.substring(_desc.indexOf(&#39;}&#39;)+1);
 527             }
 528             if (_desc.startsWith(&quot;-&quot;)) { // Interface
 529                 isInterface = true;
 530                 _desc = _desc.substring(1, _desc.length());
 531             }
 532             if (_desc.indexOf(&quot;|&quot;) != -1) {
 533                 javaClassName = _desc.substring(_desc.indexOf(&#39;|&#39;)+1, _desc.length());
 534                 _desc = _desc.substring(0, _desc.indexOf(&#39;|&#39;));
 535             }
 536             name = _desc;
 537             if (javaClassName == null) {
 538                 javaClassName = name;
 539             }
 540             description = _desc;
 541 //              System.out.println(&quot;Struct &quot; + name + &quot; extends &quot; + baseClass + &quot; implements &quot; + interfaces);
 542         }
 543 
 544         /**
 545          * Returns String containing Java code calculating size of the structure depending on the data model
 546          */
 547         public String getSize() {
<a name="7" id="anc7"></a><span class="line-modified"> 548             String s32 = (String) WrapperGenerator.sizeTable32bit.get(getName());</span>
<span class="line-modified"> 549             String s64 = (String) WrapperGenerator.sizeTable64bit.get(getName());</span>
 550             if (s32 == null || s64 == null) {
 551                 return (s32 == null)?(s64):(s32);
 552             }
 553             if (s32.equals(s64)) {
 554                 return s32;
 555             } else {
 556                 return MessageFormat.format(&quot;((XlibWrapper.dataModel == 32)?({0}):({1}))&quot;, new Object[] {s32, s64});
 557             }
 558         }
 559         public String getOffset(AtomicType atp) {
 560             String key = getName()+&quot;.&quot;+(atp.isAlias() ? atp.getAliasName() : atp.getName());
<a name="8" id="anc8"></a><span class="line-modified"> 561             String s64 = (String) WrapperGenerator.sizeTable64bit.get(key);</span>
<span class="line-modified"> 562             String s32 = (String) WrapperGenerator.sizeTable32bit.get(key);</span>
 563             if (s32 == null || s64 == null) {
 564                 return (s32 == null)?(s64):(s32);
 565             }
 566             if (s32.equals(s64)) {
 567                 return s32;
 568             } else {
 569                 return MessageFormat.format(&quot;((XlibWrapper.dataModel == 32)?({0}):({1}))&quot;, new Object[]{s32, s64});
 570             }
 571         }
 572     }
 573 
 574     private static class FunctionType extends BaseType {
 575 
<a name="9" id="anc9"></a><span class="line-modified"> 576         Vector args;</span>
 577         String description;
 578         boolean packed;
 579         String returnType;
 580 
 581         int alignment;
 582 
 583         public FunctionType(String _desc)
 584         {
<a name="10" id="anc10"></a><span class="line-modified"> 585             args = new Vector();</span>
 586             description = _desc;
 587             setName(_desc);
 588         }
 589         boolean isVoid() {
 590             return (returnType == null);
 591         }
 592         String getReturnType() {
 593             if (returnType == null) {
 594                 return &quot;void&quot;;
 595             } else {
 596                 return returnType;
 597             }
 598         }
 599 
 600         public int getNumArgs()
 601         {
 602             return args.size();
 603         }
 604         public void setName(String _name)
 605         {
 606             if (_name.startsWith(&quot;!&quot;)) {
 607                 _name = _name.substring(1, _name.length());
 608             }
 609             if (_name.indexOf(&quot;|&quot;) != -1) {
 610                 returnType = _name.substring(_name.indexOf(&quot;|&quot;)+1, _name.length());
 611                 _name = _name.substring(0, _name.indexOf(&quot;|&quot;));
 612             }
 613             name = _name.replaceAll(&quot;[* \t]&quot;,&quot;&quot;);
 614         }
 615 
 616         public String getDescription()
 617         {
 618             return description;
 619         }
 620 
<a name="11" id="anc11"></a><span class="line-modified"> 621         public Collection getArguments()</span>
 622         {
 623             return args;
 624         }
 625         public void addArgument(BaseType tp)
 626         {
 627             args.add(tp);
 628         }
 629     }
 630 
 631     public String makeComment(String str)
 632     {
 633         StringTokenizer st = new StringTokenizer(str,&quot;\r\n&quot;);
 634         String ret=&quot;&quot;;
 635 
 636         while (st.hasMoreTokens())
 637         {
 638             ret = ret + &quot;//&quot; + st.nextToken() + &quot;\n&quot;;
 639         }
 640 
 641         return ret;
 642     }
 643 
 644     public String getJavaTypeForSize(int size) {
 645         switch(size) {
 646           case 1: return &quot;byte&quot;;
 647           case 2: return &quot;short&quot;;
 648           case 4: return &quot;int&quot;;
 649           case 8: return &quot;long&quot;;
 650           default: throw new RuntimeException(&quot;Unsupported size: &quot; + size);
 651         }
 652     }
 653     public String getOffsets(StructType stp,AtomicType atp, boolean wide)
 654     {
 655         String key = stp.getName()+&quot;.&quot;+atp.getName();
<a name="12" id="anc12"></a><span class="line-modified"> 656         return wide == true ? (String) sizeTable64bit.get(key) : (String) sizeTable32bit.get(key);</span>
 657     }
 658 
 659     public String getStructSize(StructType stp, boolean wide)
 660     {
<a name="13" id="anc13"></a><span class="line-modified"> 661         return wide == true ? (String) sizeTable64bit.get(stp.getName()) : (String) sizeTable32bit.get(stp.getName());</span>
 662     }
 663 
 664     public int getLongSize(boolean wide)
 665     {
<a name="14" id="anc14"></a><span class="line-modified"> 666         return Integer.parseInt(wide == true ? (String)sizeTable64bit.get(&quot;long&quot;) : (String)sizeTable32bit.get(&quot;long&quot;));</span>
 667     }
 668 
 669     public int getPtrSize(boolean wide)
 670     {
<a name="15" id="anc15"></a><span class="line-modified"> 671         return Integer.parseInt(wide == true ? (String)sizeTable64bit.get(&quot;ptr&quot;) : (String)sizeTable32bit.get(&quot;ptr&quot;));</span>
 672     }
 673     public int getBoolSize(boolean wide) {
 674         return getOrdinalSize(&quot;Bool&quot;, wide);
 675     }
 676     public int getOrdinalSize(String ordinal, boolean wide) {
<a name="16" id="anc16"></a><span class="line-modified"> 677         return Integer.parseInt(wide == true ? (String)sizeTable64bit.get(ordinal) : (String)sizeTable32bit.get(ordinal));</span>
 678     }
 679 
 680     public void writeToString(StructType stp, PrintWriter pw) {
 681         int type;
 682         pw.println(&quot;\n\n\tString getName() {\n\t\treturn \&quot;&quot; + stp.getName()+ &quot;\&quot;; \n\t}&quot;);
 683         pw.println(&quot;\n\n\tString getFieldsAsString() {\n\t\tStringBuilder ret = new StringBuilder(&quot; + stp.getNumFields() * 40 + &quot;);\n&quot;);
 684 
<a name="17" id="anc17"></a><span class="line-modified"> 685         for (Enumeration e = stp.getMembers() ; e.hasMoreElements() ;) {</span>
 686             AtomicType tp = (AtomicType) e.nextElement();
 687 
 688             type = tp.getType();
 689             String name = tp.getName().replace(&#39;.&#39;, &#39;_&#39;);
 690             if ((name != null) &amp;&amp; (name.length() &gt; 0))
 691             {
 692                 if (type == AtomicType.TYPE_ATOM) {
 693                     pw.println(&quot;\t\tret.append(\&quot;&quot; + name + &quot; = \&quot; ).append( XAtom.get(get_&quot; + name + &quot;()) ).append(\&quot;, \&quot;);&quot;);
 694                 } else if (name.equals(&quot;type&quot;)) {
 695                     pw.println(&quot;\t\tret.append(\&quot;type = \&quot;).append( XlibWrapper.eventToString[get_type()] ).append(\&quot;, \&quot;);&quot;);
 696                 } else if (name.equals(&quot;window&quot;)){
 697                     pw.println(&quot;\t\tret.append(\&quot;window = \&quot; ).append( getWindow(get_window()) ).append(\&quot;, \&quot;);&quot;);
 698                 } else if (type == AtomicType.TYPE_ARRAY) {
 699                     pw.print(&quot;\t\tret.append(\&quot;{\&quot;)&quot;);
 700                     for (int i = 0; i &lt; tp.getArrayLength(); i++) {
 701                         pw.print(&quot;\n\t\t.append( get_&quot; + name + &quot;(&quot; + i + &quot;) ).append(\&quot; \&quot;)&quot;);
 702                     }
 703                     pw.println(&quot;.append( \&quot;}\&quot;);&quot;);
 704                 } else {
 705                     pw.println(&quot;\t\tret.append(\&quot;&quot; + name +&quot; = \&quot;).append( get_&quot;+ name+&quot;() ).append(\&quot;, \&quot;);&quot;);
 706                 }
 707             }
 708 
 709         }
 710         pw.println(&quot;\t\treturn ret.toString();\n\t}\n\n&quot;);
 711     }
 712 
 713     public void writeStubs(StructType stp, PrintWriter pw) {
 714         int type;
 715         String prefix = &quot;&quot;;
 716         if (!stp.getIsInterface()) {
 717             prefix = &quot;\t\tabstract &quot;;
 718         } else {
 719             prefix = &quot;\t&quot;;
 720         }
<a name="18" id="anc18"></a><span class="line-modified"> 721         for (Enumeration e = stp.getMembers() ; e.hasMoreElements() ;) {</span>
 722             AtomicType tp = (AtomicType) e.nextElement();
 723 
 724             type = tp.getType();
 725             String name = tp.getName().replace(&#39;.&#39;,&#39;_&#39;);
 726             if ((name != null) &amp;&amp; (name.length() &gt; 0))
 727             {
 728                 if (type == AtomicType.TYPE_ARRAY) {
 729                     // Returns pointer to the start of the array
 730                     pw.println(prefix + &quot;long get_&quot; +name +&quot;();&quot;);
 731 
 732                     pw.println(prefix + tp.getJavaType() + &quot; get_&quot; +name +&quot;(int index);&quot;);
 733                     pw.println(prefix + &quot;void set_&quot; +name +&quot;(int index, &quot; + tp.getJavaType() + &quot; v);&quot;);
 734                 } else {
 735                     pw.println(prefix + tp.getJavaType() + &quot; get_&quot; +name +&quot;();&quot;);
 736                     if (type != AtomicType.TYPE_STRUCT) pw.println(prefix + &quot;void set_&quot; +name +&quot;(&quot; + tp.getJavaType() + &quot; v);&quot;);
 737                 }
 738             }
 739         }
 740     }
 741 
 742     private int padSize(int size, int wordLength) {
 743         int bytesPerWord = wordLength / 8;
 744         // Make size dividable by bytesPerWord
 745         return (size + bytesPerWord / 2) / bytesPerWord * bytesPerWord;
 746     }
 747 
 748     public void writeAccessorImpls(StructType stp, PrintWriter pw) {
 749         int type;
 750         int i=0;
 751         String s_size_32 = getStructSize(stp, false);
 752         String s_size_64 = getStructSize(stp, true);
 753         int acc_size_32 = 0;
 754         int acc_size_64 = 0;
 755         String s_log = (generateLog?&quot;log.finest(\&quot;\&quot;);&quot;:&quot;&quot;);
<a name="19" id="anc19"></a><span class="line-modified"> 756         for (Enumeration e = stp.getMembers() ; e.hasMoreElements() ;) {</span>
 757             AtomicType tp = (AtomicType) e.nextElement();
 758 
 759             type = tp.getType();
 760             String name = tp.getName().replace(&#39;.&#39;,&#39;_&#39;);
 761             String pref = &quot;\tpublic &quot; ;
 762             if ((name != null) &amp;&amp; (name.length() &gt; 0))
 763             {
 764                 String jt = tp.getJavaType();
 765                 String ja_32 = tp.getJavaAccess(false);
 766                 String ja_64 = tp.getJavaAccess(true);
 767                 String ja = ja_32;
 768                 int elemSize_32 = AtomicType.getNativeSizeForAccess(ja_32);
 769                 int elemSize_64 = AtomicType.getNativeSizeForAccess(ja_64);
 770                 String elemSize = tp.getItemSize();
 771                 if (type == AtomicType.TYPE_ARRAY) {
 772                     acc_size_32 += elemSize_32 * tp.getArrayLength();
 773                     acc_size_64 += elemSize_64 * tp.getArrayLength();
 774                     pw.println(pref + tp.getJavaType() + &quot; get_&quot; +name + &quot;(int index) { &quot; +s_log+&quot;return &quot; +
 775                                tp.getJavaResult(stp.getOffset(tp) + &quot;+index*&quot; + elemSize, null) + &quot;; }&quot;);
 776                     if (tp.getReferencedType() instanceof AtomicType) { // Set for StructType is forbidden
 777                         pw.println(MessageFormat.format(pref + &quot;void set_{0}(int index, {1} v) &#39;{&#39; {3} {2}; &#39;}&#39;&quot;,
 778                                                         new Object[] {
 779                                                             name, jt,
 780                                                             tp.getJavaConversion(&quot;pData+&quot;+stp.getOffset(tp)+&quot; + index*&quot; + elemSize, &quot;v&quot;),
 781                                                             s_log}));
 782                     }
 783                     // Returns pointer to the start of the array
 784                     pw.println(pref + &quot;long get_&quot; +name+ &quot;() { &quot;+s_log+&quot;return pData+&quot;+stp.getOffset(tp)+&quot;; }&quot;);
 785                 } else if (type == AtomicType.TYPE_PTR) {
 786                     pw.println(MessageFormat.format(pref + &quot;{0} get_{1}(int index) &#39;{&#39; {3} return {2}; &#39;}&#39;&quot;,
 787                                          new Object[] {
 788                                              jt, name,
 789                                              tp.getJavaResult(&quot;index*&quot; + elemSize, &quot;Native.getLong(pData+&quot;+stp.getOffset(tp)+&quot;)&quot;),
 790                                              s_log
 791                                              }));
 792                     pw.println(pref + &quot;long get_&quot; +name+ &quot;() { &quot;+s_log+&quot;return Native.getLong(pData+&quot;+stp.getOffset(tp)+&quot;); }&quot;);
 793                     pw.println(MessageFormat.format(pref + &quot;void set_{0}({1} v) &#39;{&#39; {3} {2}; &#39;}&#39;&quot;,
 794                                                     new Object[] {name, &quot;long&quot;, &quot;Native.putLong(pData + &quot; + stp.getOffset(tp) + &quot;, v)&quot;, s_log}));
 795                     acc_size_32 += elemSize_32;
 796                     acc_size_64 += elemSize_64;
 797                 } else {
 798                     acc_size_32 += elemSize_32;
 799                     acc_size_64 += elemSize_64;
 800                     pw.println(pref + tp.getJavaType() + &quot; get_&quot; +name +
 801                                &quot;() { &quot;+s_log+&quot;return &quot; + tp.getJavaResult(stp.getOffset(tp), null) + &quot;; }&quot;);
 802                     if (type != AtomicType.TYPE_STRUCT) {
 803                         pw.println(MessageFormat.format(pref + &quot;void set_{0}({1} v) &#39;{&#39; {3} {2}; &#39;}&#39;&quot;,
 804                                                         new Object[] {name, jt, tp.getJavaConversion(&quot;pData+&quot;+stp.getOffset(tp), &quot;v&quot;), s_log}));
 805                     }
 806                 }
 807                 i++;
 808             }
 809         }
 810         if (s_size_32 != null &amp;&amp; !s_size_32.equals(Integer.toString(acc_size_32))) {
 811             if (log.isLoggable(Level.FINE)) {
 812                 log.fine(&quot;32 bits: The size of the structure &quot; + stp.getName() + &quot; &quot; + s_size_32 +
 813                         &quot; is not equal to the accumulated size &quot; +acc_size_32 + &quot; of the fields&quot;);
 814             }
 815         } else if (s_size_64 != null &amp;&amp; !s_size_64.equals(Integer.toString(acc_size_64))) {
 816             if (log.isLoggable(Level.FINE)) {
 817                 log.fine(&quot;64 bits: The size of the structure &quot; + stp.getName() + &quot; &quot; +s_size_64+
 818                         &quot; is not equal to the accumulated size &quot; +acc_size_64+&quot; of the fields&quot;);
 819             }
 820         }
 821     }
 822 
 823     public void writeWrapperSubclass(StructType stp, PrintWriter pw, boolean wide) {
 824 
 825 
 826         pw.println(&quot;class &quot; + stp.getJavaClassName() + &quot;AccessorImpl&quot;  + &quot; extends &quot; + stp.getJavaClassName() + &quot;Accessor  {&quot;);
 827         pw.println(&quot;/*\nThis class serves as a Wrapper for the following X Struct \nsThe offsets here are calculated based on actual compiler.\n\n&quot; +stp.getDescription() + &quot;\n\n */&quot;);
 828 
 829         writeAccessorImpls(stp, pw);
 830 
 831         pw.println(&quot;\n\n } \n\n&quot;);
 832     }
 833 
 834     public void writeWrapper(String outputDir, StructType stp)
 835     {
 836         if (stp.getNumFields() &gt; 0) {
 837 
 838             try {
 839                 FileOutputStream fs =  new FileOutputStream(outputDir + &quot;/&quot;+stp.getJavaClassName()+&quot;.java&quot;);
 840                 PrintWriter pw = new PrintWriter(fs);
 841                 pw.println(&quot;// This file is an automatically generated file, please do not edit this file, modify the WrapperGenerator.java file instead !\n&quot; );
 842 
 843                 pw.println(&quot;package &quot;+package_name+&quot;;\n&quot;);
 844                 pw.println(&quot;import jdk.internal.misc.Unsafe;\n&quot;);
 845                 pw.println(&quot;import sun.util.logging.PlatformLogger;&quot;);
 846                 String baseClass = stp.getBaseClass();
 847                 if (baseClass == null) {
 848                     baseClass = defaultBaseClass;
 849                 }
 850                 if (stp.getIsInterface()) {
 851                     pw.print(&quot;public interface &quot;);
 852                     pw.print(stp.getJavaClassName());
 853                 } else {
 854                     pw.print(&quot;public class &quot;);
 855                     pw.print(stp.getJavaClassName() + &quot; extends &quot; + baseClass);
 856                 }
 857                 if (stp.getInterfaces() != null) {
 858                     pw.print(&quot; implements &quot; + stp.getInterfaces());
 859                 }
 860                 pw.println(&quot; { &quot;);
 861                 if (!stp.getIsInterface()) {
 862                     pw.println(&quot;\tprivate Unsafe unsafe = XlibWrapper.unsafe; &quot;);
 863                     pw.println(&quot;\tprivate final boolean should_free_memory;&quot;);
 864                     pw.println(&quot;\tpublic static int getSize() { return &quot; + stp.getSize() + &quot;; }&quot;);
 865                     pw.println(&quot;\tpublic int getDataSize() { return getSize(); }&quot;);
 866                     pw.println(&quot;\n\tlong pData;&quot;);
 867                     pw.println(&quot;\n\tpublic long getPData() { return pData; }&quot;);
 868 
 869                     pw.println(&quot;\n\n\tpublic &quot; + stp.getJavaClassName() + &quot;(long addr) {&quot;);
 870                     if (generateLog) {
 871                         pw.println(&quot;\t\tlog.finest(\&quot;Creating\&quot;);&quot;);
 872                     }
 873                     pw.println(&quot;\t\tpData=addr;&quot;);
 874                     pw.println(&quot;\t\tshould_free_memory = false;&quot;);
 875                     pw.println(&quot;\t}&quot;);
 876                     pw.println(&quot;\n\n\tpublic &quot; + stp.getJavaClassName() + &quot;() {&quot;);
 877                     if (generateLog) {
 878                         pw.println(&quot;\t\tlog.finest(\&quot;Creating\&quot;);&quot;);
 879                     }
 880                     pw.println(&quot;\t\tpData = unsafe.allocateMemory(getSize());&quot;);
 881                     pw.println(&quot;\t\tshould_free_memory = true;&quot;);
 882                     pw.println(&quot;\t}&quot;);
 883 
 884                     pw.println(&quot;\n\n\tpublic void dispose() {&quot;);
 885                     if (generateLog) {
 886                         pw.println(&quot;\t\tlog.finest(\&quot;Disposing\&quot;);&quot;);
 887                     }
 888                     pw.println(&quot;\t\tif (should_free_memory) {&quot;);
 889                     if (generateLog) {
 890                         pw.println(&quot;\t\t\tlog.finest(\&quot;freeing memory\&quot;);&quot;);
 891                     }
 892                     pw.println(&quot;\t\t\tunsafe.freeMemory(pData); \n\t}&quot;);
 893                     pw.println(&quot;\t\t}&quot;);
 894                     writeAccessorImpls(stp, pw);
 895                     writeToString(stp,pw);
 896                 } else {
 897                     pw.println(&quot;\n\n\tvoid dispose();&quot;);
 898                     pw.println(&quot;\n\tlong getPData();&quot;);
 899                     writeStubs(stp,pw);
 900                 }
 901 
 902 
 903                 pw.println(&quot;}\n\n\n&quot;);
 904                 pw.close();
 905             }
 906             catch (Exception e)
 907             {
 908                 e.printStackTrace();
 909             }
 910         }
 911     }
 912 
 913     private boolean readSizeInfo(InputStream is, boolean wide) {
 914         String line;
 915         String splits[];
 916         BufferedReader in  = new BufferedReader(new InputStreamReader(is));
 917         try {
 918             while ((line = in.readLine()) != null)
 919             {
 920                 splits = line.split(&quot;\\p{Space}&quot;);
 921                 if (splits.length == 2)
 922                 {
 923                     if (wide) {
 924                         sizeTable64bit.put(splits[0],splits[1]);
 925                     } else {
 926                         sizeTable32bit.put(splits[0],splits[1]);
 927                     }
 928                 }
 929             }
 930             return true;
 931         } catch (Exception e) {
 932             e.printStackTrace();
 933             return false;
 934         }
 935     }
 936 
 937     public void writeFunctionCallWrapper(String outputDir, FunctionType ft) {
 938         try {
 939             FileOutputStream fs =  new FileOutputStream(outputDir + &quot;/&quot; + ft.getName()+&quot;.java&quot;);
 940             PrintWriter pw = new PrintWriter(fs);
 941             pw.println(&quot;// This file is an automatically generated file, please do not edit this file, modify the WrapperGenerator.java file instead !\n&quot; );
 942 
 943             pw.println(&quot;package &quot;+package_name+&quot;;\n&quot;);
 944             pw.println(&quot;import jdk.internal.misc.Unsafe;\n&quot;);
 945             pw.println(&quot;class &quot; + ft.getName() + &quot; {&quot;);
 946             pw.println(&quot;\tprivate static Unsafe unsafe = XlibWrapper.unsafe;&quot;);
 947             pw.println(&quot;\tprivate boolean __executed = false;&quot;);
 948             pw.println(&quot;\tprivate boolean __disposed = false;&quot;);
<a name="20" id="anc20"></a><span class="line-modified"> 949             Iterator iter = ft.getArguments().iterator();</span>
 950             while (iter.hasNext()) {
 951                 AtomicType at = (AtomicType)iter.next();
 952                 if (at.isIn()) {
 953                     pw.println(&quot;\t&quot; + at.getJavaType() + &quot; _&quot; + at.getName() + &quot;;&quot;);
 954                 } else {
 955                     pw.println(&quot;\tlong &quot; + at.getName() + &quot;_ptr = unsafe.allocateMemory(Native.get&quot; + at.getTypeUpperCase() + &quot;Size());&quot;);
 956                 }
 957             }
 958             pw.println(&quot;\tpublic &quot; + ft.getName() + &quot;(&quot;);
 959             iter = ft.getArguments().iterator();
 960             boolean first = true;
 961             while (iter.hasNext()) {
 962                 AtomicType at = (AtomicType)iter.next();
 963                 if (at.isIn() || at.isInOut()) {
 964                     if (!first) {
 965                         pw.println(&quot;,&quot;);
 966                     }
 967                     first = false;
 968                     pw.print(&quot;\t\t&quot; + at.getJavaType() + &quot; &quot; + at.getName());
 969                 }
 970             }
 971             pw.println(&quot;\t)&quot;);
 972             pw.println(&quot;\t{&quot;);
 973             iter = ft.getArguments().iterator();
 974             while (iter.hasNext()) {
 975                 AtomicType at = (AtomicType)iter.next();
 976                 if (at.isIn() || at.isInOut()) {
 977                     pw.println(&quot;\t\tset_&quot; + at.getName() + &quot;(&quot; + at.getName() + &quot;);&quot;);
 978                 }
 979             }
 980             pw.println(&quot;\t}&quot;);
 981 
 982             pw.println(&quot;\tpublic &quot; + ft.getReturnType() + &quot; execute() {&quot;);
 983             if (ft.isVoid()) {
 984                 pw.println(&quot;\t\texecute(null);&quot;);
 985             } else {
 986                 pw.println(&quot;\t\treturn execute(null);&quot;);
 987             }
 988             pw.println(&quot;\t}&quot;);
 989 
 990             pw.println(&quot;\tpublic &quot; + ft.getReturnType() + &quot; execute(XToolkit.XErrorHandler errorHandler) {&quot;);
 991             pw.println(&quot;\t\tif (__disposed) {&quot;);
 992             pw.println(&quot;\t\t    throw new IllegalStateException(\&quot;Disposed\&quot;);&quot;);
 993             pw.println(&quot;\t\t}&quot;);
 994             pw.println(&quot;\t\tXToolkit.awtLock();&quot;);
 995             pw.println(&quot;\t\ttry {&quot;);
 996             pw.println(&quot;\t\t\tif (__executed) {&quot;);
 997             pw.println(&quot;\t\t\t    throw new IllegalStateException(\&quot;Already executed\&quot;);&quot;);
 998             pw.println(&quot;\t\t\t}&quot;);
 999             pw.println(&quot;\t\t\t__executed = true;&quot;);
1000             pw.println(&quot;\t\t\tif (errorHandler != null) {&quot;);
1001             pw.println(&quot;\t\t\t    XErrorHandlerUtil.WITH_XERROR_HANDLER(errorHandler);&quot;);
1002             pw.println(&quot;\t\t\t}&quot;);
1003             iter = ft.getArguments().iterator();
1004             while (iter.hasNext()) {
1005                 AtomicType at = (AtomicType)iter.next();
1006                 if (!at.isIn() &amp;&amp; at.isAutoFree()) {
1007                     pw.println(&quot;\t\t\tNative.put&quot; + at.getTypeUpperCase() + &quot;(&quot; +at.getName() + &quot;_ptr, 0);&quot;);
1008                 }
1009             }
1010             if (!ft.isVoid()) {
1011                 pw.println(&quot;\t\t\t&quot; + ft.getReturnType() + &quot; status = &quot;);
1012             }
1013             pw.println(&quot;\t\t\tXlibWrapper.&quot; + ft.getName() + &quot;(XToolkit.getDisplay(), &quot;);
1014             iter = ft.getArguments().iterator();
1015             first = true;
1016             while (iter.hasNext()) {
1017                 AtomicType at = (AtomicType)iter.next();
1018                 if (!first) {
1019                     pw.println(&quot;,&quot;);
1020                 }
1021                 first = false;
1022                 if (at.isIn()) {
1023                     pw.print(&quot;\t\t\t\tget_&quot; + at.getName() + &quot;()&quot;);
1024                 } else {
1025                     pw.print(&quot;\t\t\t\t&quot; + at.getName() + &quot;_ptr&quot;);
1026                 }
1027             }
1028             pw.println(&quot;\t\t\t);&quot;);
1029             pw.println(&quot;\t\t\tif (errorHandler != null) {&quot;);
1030             pw.println(&quot;\t\t\t    XErrorHandlerUtil.RESTORE_XERROR_HANDLER();&quot;);
1031             pw.println(&quot;\t\t\t}&quot;);
1032             if (!ft.isVoid()) {
1033                 pw.println(&quot;\t\t\treturn status;&quot;);
1034             }
1035             pw.println(&quot;\t\t} finally {&quot;);
1036             pw.println(&quot;\t\t    XToolkit.awtUnlock();&quot;);
1037             pw.println(&quot;\t\t}&quot;);
1038             pw.println(&quot;\t}&quot;);
1039 
1040             pw.println(&quot;\tpublic boolean isExecuted() {&quot;);
1041             pw.println(&quot;\t    return __executed;&quot;);
1042             pw.println(&quot;\t}&quot;);
1043             pw.println(&quot;\t&quot;);
1044             pw.println(&quot;\tpublic boolean isDisposed() {&quot;);
1045             pw.println(&quot;\t    return __disposed;&quot;);
1046             pw.println(&quot;\t}&quot;);
1047             pw.println(&quot;\tpublic void finalize() {&quot;);
1048             pw.println(&quot;\t    dispose();&quot;);
1049             pw.println(&quot;\t}&quot;);
1050 
1051             pw.println(&quot;\tpublic void dispose() {&quot;);
1052             pw.println(&quot;\t\tXToolkit.awtLock();&quot;);
1053             pw.println(&quot;\t\ttry {&quot;);
1054             pw.println(&quot;\t\tif (__disposed || !__executed) {&quot;);
1055             pw.println(&quot;\t\t    return;&quot;);
1056             pw.println(&quot;\t\t} finally {&quot;);
1057             pw.println(&quot;\t\t    XToolkit.awtUnlock();&quot;);
1058             pw.println(&quot;\t\t}&quot;);
1059             pw.println(&quot;\t\t}&quot;);
1060 
1061             iter = ft.getArguments().iterator();
1062             while (iter.hasNext()) {
1063                 AtomicType at = (AtomicType)iter.next();
1064                 if (!at.isIn()) {
1065                     if (at.isAutoFree()) {
1066                         pw.println(&quot;\t\tif (__executed &amp;&amp; get_&quot; + at.getName() + &quot;()!= 0) {&quot;);
1067                         pw.println(&quot;\t\t\tXlibWrapper.XFree(get_&quot; + at.getName() + &quot;());&quot;);
1068                         pw.println(&quot;\t\t}&quot;);
1069                     }
1070                     pw.println(&quot;\t\tunsafe.freeMemory(&quot; + at.getName() + &quot;_ptr);&quot;);
1071                 }
1072             }
1073             pw.println(&quot;\t\t__disposed = true;&quot;);
1074             pw.println(&quot;\t\t}&quot;);
1075             pw.println(&quot;\t}&quot;);
1076 
1077             iter = ft.getArguments().iterator();
1078             while (iter.hasNext()) {
1079                 AtomicType at = (AtomicType)iter.next();
1080                 pw.println(&quot;\tpublic &quot; + at.getJavaType() + &quot; get_&quot; + at.getName() + &quot;() {&quot;);
1081 
1082                 pw.println(&quot;\t\tif (__disposed) {&quot;);
1083                 pw.println(&quot;\t\t    throw new IllegalStateException(\&quot;Disposed\&quot;);&quot;);
1084                 pw.println(&quot;\t\t}&quot;);
1085                 pw.println(&quot;\t\tif (!__executed) {&quot;);
1086                 pw.println(&quot;\t\t    throw new IllegalStateException(\&quot;Not executed\&quot;);&quot;);
1087                 pw.println(&quot;\t\t}&quot;);
1088 
1089                 if (at.isIn()) {
1090                     pw.println(&quot;\t\treturn _&quot; + at.getName() + &quot;;&quot;);
1091                 } else {
1092                     pw.println(&quot;\t\treturn Native.get&quot; + at.getTypeUpperCase() + &quot;(&quot; + at.getName() + &quot;_ptr);&quot;);
1093                 }
1094                 pw.println(&quot;\t}&quot;);
1095 
1096                 pw.println(&quot;\tpublic void set_&quot; + at.getName() + &quot;(&quot; + at.getJavaType() + &quot; data) {&quot;);
1097                 if (at.isIn()) {
1098                     pw.println(&quot;\t\t_&quot; + at.getName() + &quot; = data;&quot;);
1099                 } else {
1100                     pw.println(&quot;\t\tNative.put&quot; + at.getTypeUpperCase() + &quot;(&quot; + at.getName() + &quot;_ptr, data);&quot;);
1101                 }
1102                 pw.println(&quot;\t}&quot;);
1103             }
1104             pw.println(&quot;}&quot;);
1105             pw.close();
1106         } catch (Exception e) {
1107             e.printStackTrace();
1108         }
1109     }
1110 
1111     public void writeJavaWrapperClass(String outputDir) {
1112         try {
<a name="21" id="anc21"></a><span class="line-modified">1113             for (Enumeration e = symbolTable.elements() ; e.hasMoreElements() ;) {</span>
<span class="line-modified">1114                 BaseType tp = (BaseType) e.nextElement();</span>
1115                 if (tp instanceof StructType) {
1116                     StructType st = (StructType) tp;
1117                     writeWrapper(outputDir, st);
1118                 } else if (tp instanceof FunctionType) {
1119                     writeFunctionCallWrapper(outputDir, (FunctionType)tp);
1120                 }
1121             }
1122         }
1123         catch (Exception e) {
1124             e.printStackTrace();
1125         }
1126     }
1127 
1128     public void writeNativeSizer(String file)
1129     {
1130         int type;
1131         int i=0;
1132         int j=0;
1133         BaseType tp;
1134         StructType stp;
<a name="22" id="anc22"></a><span class="line-modified">1135         Enumeration eo;</span>
1136 
1137         try {
1138 
1139             FileOutputStream fs =  new FileOutputStream(file);
1140             PrintWriter pw = new PrintWriter(fs);
1141 
1142             pw.println(&quot;/* This file is an automatically generated file, please do not edit this file, modify the XlibParser.java file instead !*/\n&quot; );
1143             pw.println(&quot;#include &lt;X11/Xlib.h&gt;\n#include &lt;X11/Xutil.h&gt;\n#include &lt;X11/Xos.h&gt;\n#include &lt;X11/Xatom.h&gt;\n#include &lt;stdio.h&gt;\n&quot;);
1144             pw.println(&quot;#include &lt;X11/extensions/Xdbe.h&gt;&quot;);
1145             pw.println(&quot;#include &lt;X11/XKBlib.h&gt;&quot;);
1146             pw.println(&quot;#include \&quot;awt_p.h\&quot;&quot;);
1147             pw.println(&quot;#include \&quot;color.h\&quot;&quot;);
1148             pw.println(&quot;#include \&quot;colordata.h\&quot;&quot;);
1149             pw.println(&quot;\ntypedef struct\n&quot;);
1150             pw.println(&quot;{\n&quot;);
1151             pw.println(&quot;    unsigned long flags;\n&quot;);
1152             pw.println(&quot;    unsigned long functions;\n&quot;);
1153             pw.println(&quot;    unsigned long decorations;\n&quot;);
1154             pw.println(&quot;    long inputMode;\n&quot;);
1155             pw.println(&quot;    unsigned long status;\n&quot;);
1156             pw.println(&quot;} PropMwmHints;\n&quot;);
1157 
1158             pw.println(&quot;\n\nint main(){&quot;);
1159             j=0;
1160             for ( eo = symbolTable.elements() ; eo.hasMoreElements() ;) {
<a name="23" id="anc23"></a><span class="line-modified">1161                 tp = (BaseType) eo.nextElement();</span>
1162                 if (tp instanceof StructType)
1163                 {
1164                     stp = (StructType) tp;
1165                     if (!stp.getIsInterface()) {
1166                         pw.println(stp.getName()+&quot;  temp&quot;+ j + &quot;;\n&quot;);
1167                         j++;
1168                     }
1169                 }
1170             }
1171             j=0;
1172 
1173             pw.println(&quot;printf(\&quot;long\t%d\\n\&quot;,(int)sizeof(long));&quot;);
1174             pw.println(&quot;printf(\&quot;int\t%d\\n\&quot;,(int)sizeof(int));&quot;);
1175             pw.println(&quot;printf(\&quot;short\t%d\\n\&quot;,(int)sizeof(short));&quot;);
1176             pw.println(&quot;printf(\&quot;ptr\t%d\\n\&quot;,(int)sizeof(void *));&quot;);
1177             pw.println(&quot;printf(\&quot;Bool\t%d\\n\&quot;,(int)sizeof(Bool));&quot;);
1178             pw.println(&quot;printf(\&quot;Atom\t%d\\n\&quot;,(int)sizeof(Atom));&quot;);
1179             pw.println(&quot;printf(\&quot;Window\t%d\\n\&quot;,(int)sizeof(Window));&quot;);
1180 
1181             for (eo = symbolTable.elements() ; eo.hasMoreElements() ;) {
1182 
1183 
<a name="24" id="anc24"></a><span class="line-modified">1184                 tp = (BaseType) eo.nextElement();</span>
1185                 if (tp instanceof StructType)
1186                 {
1187                     stp = (StructType) tp;
1188                     if (stp.getIsInterface()) {
1189                         continue;
1190                     }
<a name="25" id="anc25"></a><span class="line-modified">1191                     for (Enumeration e = stp.getMembers() ; e.hasMoreElements() ;) {</span>
1192                         AtomicType atp = (AtomicType) e.nextElement();
1193                         if (atp.isAlias()) continue;
1194                         pw.println(&quot;printf(\&quot;&quot;+ stp.getName() + &quot;.&quot; + atp.getName() + &quot;\t%d\\n\&quot;&quot;+
1195                                    &quot;,(int)((unsigned long ) &amp;temp&quot;+j+&quot;.&quot;+atp.getName()+&quot;- (unsigned long ) &amp;temp&quot; + j + &quot;)  );&quot;);
1196 
1197                         i++;
1198 
1199 
1200                     }
1201                     pw.println(&quot;printf(\&quot;&quot;+ stp.getName() + &quot;\t%d\\n\&quot;&quot; + &quot;,(int)sizeof(temp&quot;+j+&quot;));&quot;);
1202 
1203                     j++;
1204                 }
1205 
1206             }
1207             pw.println(&quot;return 0;&quot;);
1208             pw.println(&quot;}&quot;);
1209             pw.close();
1210 
1211         }
1212         catch (Exception e)
1213         {
1214             e.printStackTrace();
1215         }
1216     }
1217 
1218     private void initTypes() {
1219         symbolTable.put(&quot;int&quot;, new AtomicType(AtomicType.TYPE_INT, &quot;&quot;, &quot;int&quot;));
1220         symbolTable.put(&quot;short&quot;, new AtomicType(AtomicType.TYPE_SHORT, &quot;&quot;, &quot;short&quot;));
1221         symbolTable.put(&quot;long&quot;, new AtomicType(AtomicType.TYPE_LONG, &quot;&quot;, &quot;long&quot;));
1222         symbolTable.put(&quot;float&quot;, new AtomicType(AtomicType.TYPE_FLOAT, &quot;&quot;, &quot;float&quot;));
1223         symbolTable.put(&quot;double&quot;, new AtomicType(AtomicType.TYPE_DOUBLE, &quot;&quot;, &quot;double&quot;));
1224         symbolTable.put(&quot;Bool&quot;, new AtomicType(AtomicType.TYPE_BOOL, &quot;&quot;, &quot;Bool&quot;));
1225         symbolTable.put(&quot;char&quot;, new AtomicType(AtomicType.TYPE_CHAR, &quot;&quot;, &quot;char&quot;));
1226         symbolTable.put(&quot;byte&quot;, new AtomicType(AtomicType.TYPE_BYTE, &quot;&quot;, &quot;byte&quot;));
1227         symbolTable.put(&quot;pointer&quot;, new AtomicType(AtomicType.TYPE_PTR, &quot;&quot;, &quot;pointer&quot;));
1228         symbolTable.put(&quot;longlong&quot;, new AtomicType(AtomicType.TYPE_LONG_LONG, &quot;&quot;, &quot;longlong&quot;));
1229         symbolTable.put(&quot;Atom&quot;, new AtomicType(AtomicType.TYPE_ATOM, &quot;&quot;, &quot;Atom&quot;));
1230         symbolTable.put(&quot;ulong&quot;, new AtomicType(AtomicType.TYPE_ULONG, &quot;&quot;, &quot;ulong&quot;));
1231     }
1232 
1233     public WrapperGenerator(String xlibFilename) {
1234         initTypes();
1235         try {
1236             BufferedReader in  = new BufferedReader(new FileReader(xlibFilename));
1237             String line;
1238             String splits[];
1239             BaseType curType = null;
1240             while ((line = in.readLine()) != null)
1241             {
1242                 int commentStart = line.indexOf(&quot;//&quot;);
1243                 if (commentStart &gt;= 0) {
1244                     // remove comment
1245                     line = line.substring(0, commentStart);
1246                 }
1247 
1248                 if (&quot;&quot;.equals(line)) {
1249                     // skip empty line
1250                     continue;
1251                 }
1252 
1253                 splits = line.split(&quot;\\p{Space}+&quot;);
1254                 if (splits.length &gt;= 2)
1255                 {
1256                     String struct_name = curType.getName();
1257                     String field_name = splits[1];
1258                     String s_type = splits[2];
1259                     BaseType bt = curType;
1260                     int type = AtomicType.getTypeForString(s_type);
1261                     AtomicType atp = null;
1262                     if (bt != null &amp;&amp; type != -1) {
1263                         atp = new AtomicType(type,field_name,s_type);
1264                         if (splits.length &gt; 3) {
1265                             atp.setAttributes(splits);
1266                         }
1267                         if (bt instanceof StructType) {
1268                             StructType  stp = (StructType) bt;
1269                             stp.addMember(atp);
1270                         } else if (bt instanceof FunctionType) {
1271                             ((FunctionType)bt).addArgument(atp);
1272                         }
1273                     }
1274                     else if (bt == null) {
1275                         System.out.println(&quot;Cannot find &quot; + struct_name);
1276                     }
1277 
1278                 }
1279                 else  if (line != null) {
<a name="26" id="anc26"></a><span class="line-modified">1280                     BaseType bt = (BaseType) symbolTable.get(line);</span>
1281                     if (bt == null) {
1282                         if (line.startsWith(&quot;!&quot;)) {
1283                             FunctionType ft = new FunctionType(line);
1284                             ft.setName(line);
1285                             symbolTable.put(ft.getName(),ft);
1286                             curType = ft;
1287                         } else {
1288                             StructType stp = new StructType(line);
1289                             stp.setName(line);
1290                             curType = stp;
1291                             symbolTable.put(stp.getName(),stp);
1292                         }
1293                     }
1294                 }
1295 
1296             }
1297             in.close();
1298         }
1299         catch (Exception e) {
1300             e.printStackTrace();
1301         }
1302     }
1303 
1304     private void makeSizer(String sizerFileName) {
1305         File fp = new File(sizerFileName);
1306         writeNativeSizer(fp.getAbsolutePath());
1307     }
1308 
1309     private boolean readFileSizeInfo(String filename, boolean wide) {
1310         try {
1311             boolean res = true;
1312             FileInputStream fis = new FileInputStream(filename);
1313             res = readSizeInfo(fis, wide);
1314             fis.close();
1315             return res;
1316         } catch (Exception e) {
1317             e.printStackTrace();
1318             return false;
1319         }
1320     }
1321 
1322     private void startGeneration(String outputDir, String filename, boolean wide) {
1323         if (readFileSizeInfo(filename, wide))
1324         {
1325             writeJavaWrapperClass(outputDir);
1326         }
1327         else {
1328             System.out.println(&quot;Error calculating offsets&quot;);
1329         }
1330     }
1331 
1332     public static void main(String[] args) {
1333         if (args.length &lt; 4) {
1334             System.out.println(&quot;Usage:\nWrapperGenerator gen_java &lt;output_dir&gt; &lt;xlibtypes.txt&gt; &lt;sizes-*.txt&gt; &lt;platform&gt;&quot;);
1335             System.out.println(&quot;      or&quot;);
1336             System.out.println(&quot;WrapperGenerator gen_c_source &lt;output_file&gt; &lt;xlibtypes.txt&gt; &lt;platform&gt;&quot;);
1337             System.out.println(&quot;Where &lt;platform&gt;: 32, 64&quot;);
1338 
1339             System.exit(1);
1340         }
1341 
1342         WrapperGenerator xparser = new WrapperGenerator(args[2]);
1343         if (args[0].equals(&quot;gen_c_source&quot;)) {
1344             xparser.wide = args[3].equals(&quot;64&quot;);
1345             xparser.makeSizer(args[1]);
1346         } else if (args[0].equals(&quot;gen_java&quot;)) {
1347             boolean wide = args[4].equals(&quot;64&quot;);
1348             xparser.startGeneration(args[1], args[3], wide);
1349         }
1350     }
1351 }
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>
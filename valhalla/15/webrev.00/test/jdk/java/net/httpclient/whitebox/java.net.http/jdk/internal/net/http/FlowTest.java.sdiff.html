<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/jdk/java/net/httpclient/whitebox/java.net.http/jdk/internal/net/http/FlowTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../examples/JavadocExamples.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../nio/channels/DatagramChannel/AdaptorMulticasting.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/jdk/java/net/httpclient/whitebox/java.net.http/jdk/internal/net/http/FlowTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 63 
 64     // This is a hack to work around an issue with SubmissionPublisher.
 65     // SubmissionPublisher will call onComplete immediately without forwarding
 66     // remaining pending data if SubmissionPublisher.close() is called when
 67     // there is no demand. In other words, it doesn&#39;t wait for the subscriber
 68     // to pull all the data before calling onComplete.
 69     // We use a CountDownLatch to figure out when it is safe to call close().
 70     // This may cause the test to hang if data are buffered.
 71     final CountDownLatch allBytesReceived = new CountDownLatch(1);
 72 
 73     private final CompletableFuture&lt;Void&gt; completion;
 74 
 75     public FlowTest() throws IOException {
 76         executor = Executors.newCachedThreadPool();
 77         srcPublisher = new SubmissionPublisher&lt;&gt;(executor, 20,
 78                                                  this::handlePublisherException);
 79         SSLContext ctx = (new SimpleSSLContext()).get();
 80         SSLEngine engineClient = ctx.createSSLEngine();
 81         SSLParameters params = ctx.getSupportedSSLParameters();
 82         params.setApplicationProtocols(new String[]{&quot;proto1&quot;, &quot;proto2&quot;}); // server will choose proto2
<span class="line-removed"> 83         params.setProtocols(new String[]{&quot;TLSv1.2&quot;}); // TODO: This is essential. Needs to be protocol impl</span>
 84         engineClient.setSSLParameters(params);
 85         engineClient.setUseClientMode(true);
 86         completion = new CompletableFuture&lt;&gt;();
 87         SSLLoopbackSubscriber looper = new SSLLoopbackSubscriber(ctx, executor, allBytesReceived);
 88         looper.start();
 89         EndSubscriber end = new EndSubscriber(TOTAL_LONGS, completion, allBytesReceived);
 90         SSLFlowDelegate sslClient = new SSLFlowDelegate(engineClient, executor, end, looper);
 91         // going to measure how long handshake takes
 92         final long start = System.currentTimeMillis();
<span class="line-modified"> 93         sslClient.alpn().whenComplete((String s, Throwable t) -&gt; {</span>

 94             if (t != null)
 95                 t.printStackTrace();
 96             long endTime = System.currentTimeMillis();
 97             alpn = s;
<span class="line-modified"> 98             System.out.println(&quot;ALPN: &quot; + alpn);</span>
 99             long period = (endTime - start);
<span class="line-modified">100             System.out.printf(&quot;Handshake took %d ms\n&quot;, period);</span>
101         });
102         Subscriber&lt;List&lt;ByteBuffer&gt;&gt; reader = sslClient.upstreamReader();
103         Subscriber&lt;List&lt;ByteBuffer&gt;&gt; writer = sslClient.upstreamWriter();
104         looper.setReturnSubscriber(reader);
105         // now connect all the pieces
106         srcPublisher.subscribe(writer);
<span class="line-modified">107         String aa = sslClient.alpn().join();</span>
<span class="line-modified">108         System.out.println(&quot;AAALPN = &quot; + aa);</span>
109     }
110 
111     private void handlePublisherException(Object o, Throwable t) {
<span class="line-modified">112         System.out.println(&quot;Src Publisher exception&quot;);</span>
113         t.printStackTrace(System.out);
114     }
115 
116     private static ByteBuffer getBuffer(long startingAt) {
117         ByteBuffer buf = ByteBuffer.allocate(LONGS_PER_BUF * 8);
118         for (int j = 0; j &lt; LONGS_PER_BUF; j++) {
119             buf.putLong(startingAt++);
120         }
121         buf.flip();
122         return buf;
123     }
124 
125     @Test
126     public void run() {
127         long count = 0;
<span class="line-modified">128         System.out.printf(&quot;Submitting %d buffer arrays\n&quot;, COUNTER);</span>
<span class="line-modified">129         System.out.printf(&quot;LoopCount should be %d\n&quot;, TOTAL_LONGS);</span>
130         for (long i = 0; i &lt; COUNTER; i++) {
131             ByteBuffer b = getBuffer(count);
132             count += LONGS_PER_BUF;
133             srcPublisher.submit(List.of(b));
134         }
<span class="line-modified">135         System.out.println(&quot;Finished submission. Waiting for loopback&quot;);</span>
136         // make sure we don&#39;t wait for allBytesReceived in case of error.
<span class="line-modified">137         completion.whenComplete((r,t) -&gt; allBytesReceived.countDown());</span>













138         try {
139             allBytesReceived.await();
140         } catch (InterruptedException e) {
141             throw new RuntimeException(e);
142         }
<span class="line-modified">143         System.out.println(&quot;All bytes received: &quot;);</span>

144         srcPublisher.close();
145         try {
<span class="line-modified">146             completion.join();</span>
147             if (!alpn.equals(&quot;proto2&quot;)) {
148                 throw new RuntimeException(&quot;wrong alpn received&quot;);
149             }
<span class="line-modified">150             System.out.println(&quot;OK&quot;);</span>
151         } finally {
152             executor.shutdownNow();
153         }
154     }
155 
156 /*
157     public static void main(String[]args) throws Exception {
158         FlowTest test = new FlowTest();
159         test.run();
160     }
161 */
162 
163     /**
164      * This Subscriber simulates an SSL loopback network. The object itself
165      * accepts outgoing SSL encrypted data which is looped back via two sockets
166      * (one of which is an SSLSocket emulating a server). The method
167      * {@link #setReturnSubscriber(java.util.concurrent.Flow.Subscriber) }
168      * is used to provide the Subscriber which feeds the incoming side
169      * of SSLFlowDelegate. Three threads are used to implement this behavior
170      * and a SubmissionPublisher drives the incoming read side.
171      * &lt;p&gt;
172      * A thread reads from the buffer, writes
173      * to the client j.n.Socket which is connected to a SSLSocket operating
174      * in server mode. A second thread loops back data read from the SSLSocket back to the
175      * client again. A third thread reads the client socket and pushes the data to
176      * a SubmissionPublisher that drives the reader side of the SSLFlowDelegate
177      */
178     static class SSLLoopbackSubscriber implements Subscriber&lt;List&lt;ByteBuffer&gt;&gt; {
179         private final BlockingQueue&lt;ByteBuffer&gt; buffer;

180         private final Socket clientSock;
181         private final SSLSocket serverSock;
182         private final Thread thread1, thread2, thread3;
183         private volatile Flow.Subscription clientSubscription;
184         private final SubmissionPublisher&lt;List&lt;ByteBuffer&gt;&gt; publisher;
185         private final CountDownLatch allBytesReceived;
186 
187         SSLLoopbackSubscriber(SSLContext ctx,
188                               ExecutorService exec,
189                               CountDownLatch allBytesReceived) throws IOException {
190             SSLServerSocketFactory fac = ctx.getServerSocketFactory();
<span class="line-modified">191             SSLServerSocket serv = (SSLServerSocket) fac.createServerSocket();</span>
192             serv.setReuseAddress(false);
193             serv.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
194             SSLParameters params = serv.getSSLParameters();
195             params.setApplicationProtocols(new String[]{&quot;proto2&quot;});
196             serv.setSSLParameters(params);
197 
198 
199             int serverPort = serv.getLocalPort();
200             clientSock = new Socket(&quot;localhost&quot;, serverPort);
201             serverSock = (SSLSocket) serv.accept();
202             this.buffer = new LinkedBlockingQueue&lt;&gt;();
203             this.allBytesReceived = allBytesReceived;
204             thread1 = new Thread(this::clientWriter, &quot;clientWriter&quot;);
205             thread2 = new Thread(this::serverLoopback, &quot;serverLoopback&quot;);
206             thread3 = new Thread(this::clientReader, &quot;clientReader&quot;);
207             publisher = new SubmissionPublisher&lt;&gt;(exec, Flow.defaultBufferSize(),
208                     this::handlePublisherException);
209             SSLFlowDelegate.Monitor.add(this::monitor);
210         }
211 
212         public void start() {
213             thread1.start();
214             thread2.start();
215             thread3.start();
216         }
217 
218         private void handlePublisherException(Object o, Throwable t) {
<span class="line-modified">219             System.out.println(&quot;Loopback Publisher exception&quot;);</span>
220             t.printStackTrace(System.out);
221         }
222 
223         private final AtomicInteger readCount = new AtomicInteger();
224 
225         // reads off the SSLSocket the data from the &quot;server&quot;
226         private void clientReader() {
227             try {
228                 InputStream is = clientSock.getInputStream();
229                 final int bufsize = FlowTest.randomRange(512, 16 * 1024);
<span class="line-modified">230                 System.out.println(&quot;clientReader: bufsize = &quot; + bufsize);</span>
231                 while (true) {
232                     byte[] buf = new byte[bufsize];
233                     int n = is.read(buf);
234                     if (n == -1) {
<span class="line-modified">235                         System.out.println(&quot;clientReader close: read &quot;</span>
236                                 + readCount.get() + &quot; bytes&quot;);
<span class="line-modified">237                         System.out.println(&quot;clientReader: got EOF. &quot;</span>
<span class="line-modified">238                                             + &quot;Waiting signal to close publisher.&quot;);</span>
239                         allBytesReceived.await();
<span class="line-modified">240                         System.out.println(&quot;clientReader: closing publisher&quot;);</span>

241                         publisher.close();
242                         sleep(2000);
<span class="line-modified">243                         Utils.close(is, clientSock);</span>
244                         return;
245                     }
246                     ByteBuffer bb = ByteBuffer.wrap(buf, 0, n);
247                     readCount.addAndGet(n);
248                     publisher.submit(List.of(bb));
249                 }
250             } catch (Throwable e) {

251                 e.printStackTrace();
252                 Utils.close(clientSock);
253             }
254         }
255 
256         // writes the encrypted data from SSLFLowDelegate to the j.n.Socket
257         // which is connected to the SSLSocket emulating a server.
258         private void clientWriter() {
259             long nbytes = 0;
260             try {
261                 OutputStream os =
262                         new BufferedOutputStream(clientSock.getOutputStream());
263 
264                 while (true) {
265                     ByteBuffer buf = buffer.take();
266                     if (buf == FlowTest.SENTINEL) {
267                         // finished
268                         //Utils.sleep(2000);
<span class="line-modified">269                         System.out.println(&quot;clientWriter close: &quot; + nbytes + &quot; written&quot;);</span>
270                         clientSock.shutdownOutput();
<span class="line-modified">271                         System.out.println(&quot;clientWriter close return&quot;);</span>
272                         return;
273                     }
274                     int len = buf.remaining();
275                     int written = writeToStream(os, buf);
276                     assert len == written;
277                     nbytes += len;
278                     assert !buf.hasRemaining()
279                             : &quot;buffer has &quot; + buf.remaining() + &quot; bytes left&quot;;
280                     clientSubscription.request(1);
281                 }
282             } catch (Throwable e) {

283                 e.printStackTrace();
284             }
285         }
286 
287         private int writeToStream(OutputStream os, ByteBuffer buf) throws IOException {
288             byte[] b = buf.array();
289             int offset = buf.arrayOffset() + buf.position();
290             int n = buf.limit() - buf.position();
291             os.write(b, offset, n);
292             buf.position(buf.limit());
293             os.flush();
294             return n;
295         }
296 
297         private final AtomicInteger loopCount = new AtomicInteger();
298 
299         public String monitor() {
300             return &quot;serverLoopback: loopcount = &quot; + loopCount.toString()
301                     + &quot; clientRead: count = &quot; + readCount.toString();
302         }
303 
304         // thread2
305         private void serverLoopback() {
306             try {
307                 InputStream is = serverSock.getInputStream();
308                 OutputStream os = serverSock.getOutputStream();
309                 final int bufsize = FlowTest.randomRange(512, 16 * 1024);
<span class="line-modified">310                 System.out.println(&quot;serverLoopback: bufsize = &quot; + bufsize);</span>
311                 byte[] bb = new byte[bufsize];
312                 while (true) {
313                     int n = is.read(bb);
314                     if (n == -1) {
315                         sleep(2000);
<span class="line-modified">316                         is.close();</span>
<span class="line-modified">317                         serverSock.close();</span>

318                         return;
319                     }
320                     os.write(bb, 0, n);
321                     os.flush();
322                     loopCount.addAndGet(n);
323                 }
324             } catch (Throwable e) {

325                 e.printStackTrace();
326             }
327         }
328 
329 
330         /**
331          * This needs to be called before the chain is subscribed. It can&#39;t be
332          * supplied in the constructor.
333          */
334         public void setReturnSubscriber(Subscriber&lt;List&lt;ByteBuffer&gt;&gt; returnSubscriber) {
335             publisher.subscribe(returnSubscriber);
336         }
337 
338         @Override
339         public void onSubscribe(Flow.Subscription subscription) {
340             clientSubscription = subscription;
341             clientSubscription.request(5);
342         }
343 
344         @Override
</pre>
<hr />
<pre>
359         }
360 
361         @Override
362         public void onComplete() {
363             try {
364                 buffer.put(FlowTest.SENTINEL);
365             } catch (InterruptedException e) {
366                 e.printStackTrace();
367                 Utils.close(clientSock);
368             }
369         }
370     }
371 
372     /**
373      * The final subscriber which receives the decrypted looped-back data.
374      * Just needs to compare the data with what was sent. The given CF is
375      * either completed exceptionally with an error or normally on success.
376      */
377     static class EndSubscriber implements Subscriber&lt;List&lt;ByteBuffer&gt;&gt; {
378 
<span class="line-modified">379         private final long nbytes;</span>
380 
381         private final AtomicLong counter;
382         private volatile Flow.Subscription subscription;
383         private final CompletableFuture&lt;Void&gt; completion;
384         private final CountDownLatch allBytesReceived;
385 
<span class="line-modified">386         EndSubscriber(long nbytes,</span>
387                       CompletableFuture&lt;Void&gt; completion,
388                       CountDownLatch allBytesReceived) {
389             counter = new AtomicLong(0);
<span class="line-modified">390             this.nbytes = nbytes;</span>
391             this.completion = completion;
392             this.allBytesReceived = allBytesReceived;
393         }
394 
395         @Override
396         public void onSubscribe(Flow.Subscription subscription) {
397             this.subscription = subscription;
398             subscription.request(5);
399         }
400 
401         public static String info(List&lt;ByteBuffer&gt; i) {
402             StringBuilder sb = new StringBuilder();
403             sb.append(&quot;size: &quot;).append(Integer.toString(i.size()));
404             int x = 0;
405             for (ByteBuffer b : i)
406                 x += b.remaining();
407             sb.append(&quot; bytes: &quot; + Integer.toString(x));
408             return sb.toString();
409         }
410 
411         @Override
412         public void onNext(List&lt;ByteBuffer&gt; buffers) {
413             long currval = counter.get();
414             //if (currval % 500 == 0) {
415             //System.out.println(&quot;End: &quot; + currval);
416             //}
417 
418             for (ByteBuffer buf : buffers) {
419                 while (buf.hasRemaining()) {




420                     long n = buf.getLong();
421                     //if (currval &gt; (FlowTest.TOTAL_LONGS - 50)) {
422                     //System.out.println(&quot;End: &quot; + currval);
423                     //}
424                     if (n != currval++) {
<span class="line-modified">425                         System.out.println(&quot;ERROR at &quot; + n + &quot; != &quot; + (currval - 1));</span>
426                         completion.completeExceptionally(new RuntimeException(&quot;ERROR&quot;));
427                         subscription.cancel();
428                         return;
429                     }
430                 }
431             }
432 
433             counter.set(currval);
434             subscription.request(1);
435             if (currval &gt;= TOTAL_LONGS) {

436                 allBytesReceived.countDown();
437             }
438         }
439 
440         @Override
441         public void onError(Throwable throwable) {
<span class="line-removed">442             allBytesReceived.countDown();</span>
443             completion.completeExceptionally(throwable);
444         }
445 
446         @Override
447         public void onComplete() {
448             long n = counter.get();
<span class="line-modified">449             if (n != nbytes) {</span>
<span class="line-modified">450                 System.out.printf(&quot;nbytes=%d n=%d\n&quot;, nbytes, n);</span>
451                 completion.completeExceptionally(new RuntimeException(&quot;ERROR AT END&quot;));
452             } else {
<span class="line-modified">453                 System.out.println(&quot;DONE OK: counter = &quot; + n);</span>
<span class="line-removed">454                 allBytesReceived.countDown();</span>
455                 completion.complete(null);
456             }
457         }
458     }
459 
460     private static void sleep(int millis) {
461         try {
462             Thread.sleep(millis);
463         } catch (Exception e) {
464             e.printStackTrace();
465         }
466     }




































467 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
</pre>
<hr />
<pre>
 63 
 64     // This is a hack to work around an issue with SubmissionPublisher.
 65     // SubmissionPublisher will call onComplete immediately without forwarding
 66     // remaining pending data if SubmissionPublisher.close() is called when
 67     // there is no demand. In other words, it doesn&#39;t wait for the subscriber
 68     // to pull all the data before calling onComplete.
 69     // We use a CountDownLatch to figure out when it is safe to call close().
 70     // This may cause the test to hang if data are buffered.
 71     final CountDownLatch allBytesReceived = new CountDownLatch(1);
 72 
 73     private final CompletableFuture&lt;Void&gt; completion;
 74 
 75     public FlowTest() throws IOException {
 76         executor = Executors.newCachedThreadPool();
 77         srcPublisher = new SubmissionPublisher&lt;&gt;(executor, 20,
 78                                                  this::handlePublisherException);
 79         SSLContext ctx = (new SimpleSSLContext()).get();
 80         SSLEngine engineClient = ctx.createSSLEngine();
 81         SSLParameters params = ctx.getSupportedSSLParameters();
 82         params.setApplicationProtocols(new String[]{&quot;proto1&quot;, &quot;proto2&quot;}); // server will choose proto2

 83         engineClient.setSSLParameters(params);
 84         engineClient.setUseClientMode(true);
 85         completion = new CompletableFuture&lt;&gt;();
 86         SSLLoopbackSubscriber looper = new SSLLoopbackSubscriber(ctx, executor, allBytesReceived);
 87         looper.start();
 88         EndSubscriber end = new EndSubscriber(TOTAL_LONGS, completion, allBytesReceived);
 89         SSLFlowDelegate sslClient = new SSLFlowDelegate(engineClient, executor, end, looper);
 90         // going to measure how long handshake takes
 91         final long start = System.currentTimeMillis();
<span class="line-modified"> 92         var alpnCF = sslClient.alpn()</span>
<span class="line-added"> 93                 .whenComplete((String s, Throwable t) -&gt; {</span>
 94             if (t != null)
 95                 t.printStackTrace();
 96             long endTime = System.currentTimeMillis();
 97             alpn = s;
<span class="line-modified"> 98             println(&quot;ALPN: &quot; + alpn);</span>
 99             long period = (endTime - start);
<span class="line-modified">100             printf(&quot;Handshake took %d ms&quot;, period);</span>
101         });
102         Subscriber&lt;List&lt;ByteBuffer&gt;&gt; reader = sslClient.upstreamReader();
103         Subscriber&lt;List&lt;ByteBuffer&gt;&gt; writer = sslClient.upstreamWriter();
104         looper.setReturnSubscriber(reader);
105         // now connect all the pieces
106         srcPublisher.subscribe(writer);
<span class="line-modified">107         String aa = alpnCF.join();</span>
<span class="line-modified">108         println(&quot;AAALPN = &quot; + aa);</span>
109     }
110 
111     private void handlePublisherException(Object o, Throwable t) {
<span class="line-modified">112         println(&quot;Src Publisher exception&quot;);</span>
113         t.printStackTrace(System.out);
114     }
115 
116     private static ByteBuffer getBuffer(long startingAt) {
117         ByteBuffer buf = ByteBuffer.allocate(LONGS_PER_BUF * 8);
118         for (int j = 0; j &lt; LONGS_PER_BUF; j++) {
119             buf.putLong(startingAt++);
120         }
121         buf.flip();
122         return buf;
123     }
124 
125     @Test
126     public void run() {
127         long count = 0;
<span class="line-modified">128         printf(&quot;Submitting %d buffer arrays&quot;, COUNTER);</span>
<span class="line-modified">129         printf(&quot;LoopCount should be %d&quot;, TOTAL_LONGS);</span>
130         for (long i = 0; i &lt; COUNTER; i++) {
131             ByteBuffer b = getBuffer(count);
132             count += LONGS_PER_BUF;
133             srcPublisher.submit(List.of(b));
134         }
<span class="line-modified">135         println(&quot;Finished submission. Waiting for loopback&quot;);</span>
136         // make sure we don&#39;t wait for allBytesReceived in case of error.
<span class="line-modified">137         var done = completion.whenComplete((r,t) -&gt; {</span>
<span class="line-added">138             try {</span>
<span class="line-added">139                 if (t != null) {</span>
<span class="line-added">140                     println(&quot;Completion with error: &quot; + t);</span>
<span class="line-added">141                     t.printStackTrace(System.out);</span>
<span class="line-added">142                 } else {</span>
<span class="line-added">143                     println(&quot;Successful completion&quot;);</span>
<span class="line-added">144                 }</span>
<span class="line-added">145             } finally {</span>
<span class="line-added">146                 println(&quot;allBytesReceived.countDown()&quot;);</span>
<span class="line-added">147                 allBytesReceived.countDown();</span>
<span class="line-added">148             }</span>
<span class="line-added">149         });</span>
<span class="line-added">150 </span>
151         try {
152             allBytesReceived.await();
153         } catch (InterruptedException e) {
154             throw new RuntimeException(e);
155         }
<span class="line-modified">156         println(&quot;All bytes received; latch count:&quot;</span>
<span class="line-added">157                 + allBytesReceived.getCount());</span>
158         srcPublisher.close();
159         try {
<span class="line-modified">160             done.join();</span>
161             if (!alpn.equals(&quot;proto2&quot;)) {
162                 throw new RuntimeException(&quot;wrong alpn received&quot;);
163             }
<span class="line-modified">164             println(&quot;OK&quot;);</span>
165         } finally {
166             executor.shutdownNow();
167         }
168     }
169 
170 /*
171     public static void main(String[]args) throws Exception {
172         FlowTest test = new FlowTest();
173         test.run();
174     }
175 */
176 
177     /**
178      * This Subscriber simulates an SSL loopback network. The object itself
179      * accepts outgoing SSL encrypted data which is looped back via two sockets
180      * (one of which is an SSLSocket emulating a server). The method
181      * {@link #setReturnSubscriber(java.util.concurrent.Flow.Subscriber) }
182      * is used to provide the Subscriber which feeds the incoming side
183      * of SSLFlowDelegate. Three threads are used to implement this behavior
184      * and a SubmissionPublisher drives the incoming read side.
185      * &lt;p&gt;
186      * A thread reads from the buffer, writes
187      * to the client j.n.Socket which is connected to a SSLSocket operating
188      * in server mode. A second thread loops back data read from the SSLSocket back to the
189      * client again. A third thread reads the client socket and pushes the data to
190      * a SubmissionPublisher that drives the reader side of the SSLFlowDelegate
191      */
192     static class SSLLoopbackSubscriber implements Subscriber&lt;List&lt;ByteBuffer&gt;&gt; {
193         private final BlockingQueue&lt;ByteBuffer&gt; buffer;
<span class="line-added">194         private final SSLServerSocket serv;</span>
195         private final Socket clientSock;
196         private final SSLSocket serverSock;
197         private final Thread thread1, thread2, thread3;
198         private volatile Flow.Subscription clientSubscription;
199         private final SubmissionPublisher&lt;List&lt;ByteBuffer&gt;&gt; publisher;
200         private final CountDownLatch allBytesReceived;
201 
202         SSLLoopbackSubscriber(SSLContext ctx,
203                               ExecutorService exec,
204                               CountDownLatch allBytesReceived) throws IOException {
205             SSLServerSocketFactory fac = ctx.getServerSocketFactory();
<span class="line-modified">206             serv = (SSLServerSocket) fac.createServerSocket();</span>
207             serv.setReuseAddress(false);
208             serv.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));
209             SSLParameters params = serv.getSSLParameters();
210             params.setApplicationProtocols(new String[]{&quot;proto2&quot;});
211             serv.setSSLParameters(params);
212 
213 
214             int serverPort = serv.getLocalPort();
215             clientSock = new Socket(&quot;localhost&quot;, serverPort);
216             serverSock = (SSLSocket) serv.accept();
217             this.buffer = new LinkedBlockingQueue&lt;&gt;();
218             this.allBytesReceived = allBytesReceived;
219             thread1 = new Thread(this::clientWriter, &quot;clientWriter&quot;);
220             thread2 = new Thread(this::serverLoopback, &quot;serverLoopback&quot;);
221             thread3 = new Thread(this::clientReader, &quot;clientReader&quot;);
222             publisher = new SubmissionPublisher&lt;&gt;(exec, Flow.defaultBufferSize(),
223                     this::handlePublisherException);
224             SSLFlowDelegate.Monitor.add(this::monitor);
225         }
226 
227         public void start() {
228             thread1.start();
229             thread2.start();
230             thread3.start();
231         }
232 
233         private void handlePublisherException(Object o, Throwable t) {
<span class="line-modified">234             println(&quot;Loopback Publisher exception&quot;);</span>
235             t.printStackTrace(System.out);
236         }
237 
238         private final AtomicInteger readCount = new AtomicInteger();
239 
240         // reads off the SSLSocket the data from the &quot;server&quot;
241         private void clientReader() {
242             try {
243                 InputStream is = clientSock.getInputStream();
244                 final int bufsize = FlowTest.randomRange(512, 16 * 1024);
<span class="line-modified">245                 println(&quot;clientReader: bufsize = &quot; + bufsize);</span>
246                 while (true) {
247                     byte[] buf = new byte[bufsize];
248                     int n = is.read(buf);
249                     if (n == -1) {
<span class="line-modified">250                         println(&quot;clientReader close: read &quot;</span>
251                                 + readCount.get() + &quot; bytes&quot;);
<span class="line-modified">252                         println(&quot;clientReader: got EOF. &quot;</span>
<span class="line-modified">253                                 + &quot;Waiting signal to close publisher.&quot;);</span>
254                         allBytesReceived.await();
<span class="line-modified">255                         println(&quot;clientReader: closing publisher; latch count: &quot;</span>
<span class="line-added">256                                 + allBytesReceived.getCount());</span>
257                         publisher.close();
258                         sleep(2000);
<span class="line-modified">259                         Utils.close(is, clientSock, serv);</span>
260                         return;
261                     }
262                     ByteBuffer bb = ByteBuffer.wrap(buf, 0, n);
263                     readCount.addAndGet(n);
264                     publisher.submit(List.of(bb));
265                 }
266             } catch (Throwable e) {
<span class="line-added">267                 println(&quot;clientReader failed: &quot; + e);</span>
268                 e.printStackTrace();
269                 Utils.close(clientSock);
270             }
271         }
272 
273         // writes the encrypted data from SSLFLowDelegate to the j.n.Socket
274         // which is connected to the SSLSocket emulating a server.
275         private void clientWriter() {
276             long nbytes = 0;
277             try {
278                 OutputStream os =
279                         new BufferedOutputStream(clientSock.getOutputStream());
280 
281                 while (true) {
282                     ByteBuffer buf = buffer.take();
283                     if (buf == FlowTest.SENTINEL) {
284                         // finished
285                         //Utils.sleep(2000);
<span class="line-modified">286                         println(&quot;clientWriter close: &quot; + nbytes + &quot; written&quot;);</span>
287                         clientSock.shutdownOutput();
<span class="line-modified">288                         println(&quot;clientWriter close return&quot;);</span>
289                         return;
290                     }
291                     int len = buf.remaining();
292                     int written = writeToStream(os, buf);
293                     assert len == written;
294                     nbytes += len;
295                     assert !buf.hasRemaining()
296                             : &quot;buffer has &quot; + buf.remaining() + &quot; bytes left&quot;;
297                     clientSubscription.request(1);
298                 }
299             } catch (Throwable e) {
<span class="line-added">300                 println(&quot;clientWriter failed: &quot; + e);</span>
301                 e.printStackTrace();
302             }
303         }
304 
305         private int writeToStream(OutputStream os, ByteBuffer buf) throws IOException {
306             byte[] b = buf.array();
307             int offset = buf.arrayOffset() + buf.position();
308             int n = buf.limit() - buf.position();
309             os.write(b, offset, n);
310             buf.position(buf.limit());
311             os.flush();
312             return n;
313         }
314 
315         private final AtomicInteger loopCount = new AtomicInteger();
316 
317         public String monitor() {
318             return &quot;serverLoopback: loopcount = &quot; + loopCount.toString()
319                     + &quot; clientRead: count = &quot; + readCount.toString();
320         }
321 
322         // thread2
323         private void serverLoopback() {
324             try {
325                 InputStream is = serverSock.getInputStream();
326                 OutputStream os = serverSock.getOutputStream();
327                 final int bufsize = FlowTest.randomRange(512, 16 * 1024);
<span class="line-modified">328                 println(&quot;serverLoopback: bufsize = &quot; + bufsize);</span>
329                 byte[] bb = new byte[bufsize];
330                 while (true) {
331                     int n = is.read(bb);
332                     if (n == -1) {
333                         sleep(2000);
<span class="line-modified">334                         println(&quot;Received EOF: closing server socket&quot;);</span>
<span class="line-modified">335                         Utils.close(is, serverSock, serv);</span>
<span class="line-added">336                         println(&quot;Server socket closed&quot;);</span>
337                         return;
338                     }
339                     os.write(bb, 0, n);
340                     os.flush();
341                     loopCount.addAndGet(n);
342                 }
343             } catch (Throwable e) {
<span class="line-added">344                 println(&quot;serverLoopback failed: &quot; + e);</span>
345                 e.printStackTrace();
346             }
347         }
348 
349 
350         /**
351          * This needs to be called before the chain is subscribed. It can&#39;t be
352          * supplied in the constructor.
353          */
354         public void setReturnSubscriber(Subscriber&lt;List&lt;ByteBuffer&gt;&gt; returnSubscriber) {
355             publisher.subscribe(returnSubscriber);
356         }
357 
358         @Override
359         public void onSubscribe(Flow.Subscription subscription) {
360             clientSubscription = subscription;
361             clientSubscription.request(5);
362         }
363 
364         @Override
</pre>
<hr />
<pre>
379         }
380 
381         @Override
382         public void onComplete() {
383             try {
384                 buffer.put(FlowTest.SENTINEL);
385             } catch (InterruptedException e) {
386                 e.printStackTrace();
387                 Utils.close(clientSock);
388             }
389         }
390     }
391 
392     /**
393      * The final subscriber which receives the decrypted looped-back data.
394      * Just needs to compare the data with what was sent. The given CF is
395      * either completed exceptionally with an error or normally on success.
396      */
397     static class EndSubscriber implements Subscriber&lt;List&lt;ByteBuffer&gt;&gt; {
398 
<span class="line-modified">399         private final long nlongs;</span>
400 
401         private final AtomicLong counter;
402         private volatile Flow.Subscription subscription;
403         private final CompletableFuture&lt;Void&gt; completion;
404         private final CountDownLatch allBytesReceived;
405 
<span class="line-modified">406         EndSubscriber(long nlongs,</span>
407                       CompletableFuture&lt;Void&gt; completion,
408                       CountDownLatch allBytesReceived) {
409             counter = new AtomicLong(0);
<span class="line-modified">410             this.nlongs = nlongs;</span>
411             this.completion = completion;
412             this.allBytesReceived = allBytesReceived;
413         }
414 
415         @Override
416         public void onSubscribe(Flow.Subscription subscription) {
417             this.subscription = subscription;
418             subscription.request(5);
419         }
420 
421         public static String info(List&lt;ByteBuffer&gt; i) {
422             StringBuilder sb = new StringBuilder();
423             sb.append(&quot;size: &quot;).append(Integer.toString(i.size()));
424             int x = 0;
425             for (ByteBuffer b : i)
426                 x += b.remaining();
427             sb.append(&quot; bytes: &quot; + Integer.toString(x));
428             return sb.toString();
429         }
430 
431         @Override
432         public void onNext(List&lt;ByteBuffer&gt; buffers) {
433             long currval = counter.get();
434             //if (currval % 500 == 0) {
435             //System.out.println(&quot;End: &quot; + currval);
436             //}
437 
438             for (ByteBuffer buf : buffers) {
439                 while (buf.hasRemaining()) {
<span class="line-added">440                     if (buf.remaining() % 8 != 0) {</span>
<span class="line-added">441                         completion.completeExceptionally(</span>
<span class="line-added">442                                 new AssertionError(&quot;Unaligned buffer: &quot; + buf.remaining()));</span>
<span class="line-added">443                     }</span>
444                     long n = buf.getLong();
445                     //if (currval &gt; (FlowTest.TOTAL_LONGS - 50)) {
446                     //System.out.println(&quot;End: &quot; + currval);
447                     //}
448                     if (n != currval++) {
<span class="line-modified">449                         println(&quot;ERROR at &quot; + n + &quot; != &quot; + (currval - 1));</span>
450                         completion.completeExceptionally(new RuntimeException(&quot;ERROR&quot;));
451                         subscription.cancel();
452                         return;
453                     }
454                 }
455             }
456 
457             counter.set(currval);
458             subscription.request(1);
459             if (currval &gt;= TOTAL_LONGS) {
<span class="line-added">460                 println(&quot;allBytesReceived.countDown(): currval=&quot; +currval);</span>
461                 allBytesReceived.countDown();
462             }
463         }
464 
465         @Override
466         public void onError(Throwable throwable) {

467             completion.completeExceptionally(throwable);
468         }
469 
470         @Override
471         public void onComplete() {
472             long n = counter.get();
<span class="line-modified">473             if (n != nlongs) {</span>
<span class="line-modified">474                 printf(&quot;Error at end: nlongs=%d n=%d&quot;, nlongs, n);</span>
475                 completion.completeExceptionally(new RuntimeException(&quot;ERROR AT END&quot;));
476             } else {
<span class="line-modified">477                 println(&quot;DONE OK: counter = &quot; + n);</span>

478                 completion.complete(null);
479             }
480         }
481     }
482 
483     private static void sleep(int millis) {
484         try {
485             Thread.sleep(millis);
486         } catch (Exception e) {
487             e.printStackTrace();
488         }
489     }
<span class="line-added">490 </span>
<span class="line-added">491     static final long START = System.nanoTime();</span>
<span class="line-added">492 </span>
<span class="line-added">493     static String now() {</span>
<span class="line-added">494         long now = System.nanoTime() - START;</span>
<span class="line-added">495         long min = now / 1000_000_000L / 60L;</span>
<span class="line-added">496         long sec = (now / 1000_000_000L) % 60L;</span>
<span class="line-added">497         long mil = (now / 1000_000L) % 1000L;</span>
<span class="line-added">498         long nan = (now % 1000_000L);</span>
<span class="line-added">499         StringBuilder str = new StringBuilder();</span>
<span class="line-added">500         if (min != 0) {</span>
<span class="line-added">501             str = str.append(min).append(&quot;m &quot;);</span>
<span class="line-added">502         }</span>
<span class="line-added">503         if (sec != 0) {</span>
<span class="line-added">504             str = str.append(sec).append(&quot;s &quot;);</span>
<span class="line-added">505         }</span>
<span class="line-added">506         if (mil != 0) {</span>
<span class="line-added">507             str.append(mil).append(&quot;ms &quot;);</span>
<span class="line-added">508         }</span>
<span class="line-added">509         if (nan != 0) {</span>
<span class="line-added">510             str.append(nan).append(&quot;ns &quot;);</span>
<span class="line-added">511         }</span>
<span class="line-added">512         assert now == min * 60L * 1000_000_000L</span>
<span class="line-added">513                 + sec * 1000_000_000L</span>
<span class="line-added">514                 + mil * 1000_000L + nan;</span>
<span class="line-added">515         return str.toString().trim();</span>
<span class="line-added">516     }</span>
<span class="line-added">517 </span>
<span class="line-added">518     static void printf(String fmt, Object... args) {</span>
<span class="line-added">519         println(String.format(fmt, args));</span>
<span class="line-added">520     }</span>
<span class="line-added">521 </span>
<span class="line-added">522     static void println(String msg) {</span>
<span class="line-added">523         System.out.println(&quot;[&quot; + Thread.currentThread() + &quot;] [&quot; + now() + &quot;] &quot; + msg);</span>
<span class="line-added">524     }</span>
<span class="line-added">525 </span>
526 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../examples/JavadocExamples.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../nio/channels/DatagramChannel/AdaptorMulticasting.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
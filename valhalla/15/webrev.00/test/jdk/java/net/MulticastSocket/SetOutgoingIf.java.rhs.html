<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/net/MulticastSocket/SetOutgoingIf.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2007, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 4742177
<a name="1" id="anc1"></a><span class="line-added"> 27  * @library /test/lib</span>
 28  * @summary Re-test IPv6 (and specifically MulticastSocket) with latest Linux &amp; USAGI code
 29  */
<a name="2" id="anc2"></a><span class="line-added"> 30 import java.io.IOException;</span>
 31 import java.net.*;
 32 import java.util.*;
<a name="3" id="anc3"></a><span class="line-added"> 33 import jdk.test.lib.NetworkConfiguration;</span>
 34 
 35 
<a name="4" id="anc4"></a><span class="line-modified"> 36 public class SetOutgoingIf implements AutoCloseable {</span>

 37     private static String osname;
<a name="5" id="anc5"></a><span class="line-added"> 38     private final MulticastSocket SOCKET;</span>
<span class="line-added"> 39     private final int PORT;</span>
<span class="line-added"> 40     private SetOutgoingIf() {</span>
<span class="line-added"> 41         try {</span>
<span class="line-added"> 42             SOCKET = new MulticastSocket();</span>
<span class="line-added"> 43             PORT = SOCKET.getLocalPort();</span>
<span class="line-added"> 44         } catch (IOException io) {</span>
<span class="line-added"> 45             throw new ExceptionInInitializerError(io);</span>
<span class="line-added"> 46         }</span>
<span class="line-added"> 47     }</span>
 48 
 49     static boolean isWindows() {
 50         if (osname == null)
 51             osname = System.getProperty(&quot;os.name&quot;);
 52         return osname.contains(&quot;Windows&quot;);
 53     }
 54 
 55     static boolean isMacOS() {
 56         return System.getProperty(&quot;os.name&quot;).contains(&quot;OS X&quot;);
 57     }
 58 
 59     private static boolean hasIPv6() throws Exception {
<a name="6" id="anc6"></a><span class="line-modified"> 60         return NetworkConfiguration.probe()</span>
<span class="line-modified"> 61                 .ip6Addresses()</span>
<span class="line-modified"> 62                 .findAny()</span>
<span class="line-modified"> 63                 .isPresent();</span>
<span class="line-modified"> 64     }</span>
<span class="line-modified"> 65 </span>
<span class="line-modified"> 66     public static void main(String[] args) throws Exception {</span>
<span class="line-modified"> 67         try (var test = new SetOutgoingIf()) {</span>
<span class="line-added"> 68             test.run();</span>
 69         }
<a name="7" id="anc7"></a><span class="line-added"> 70     }</span>
 71 
<a name="8" id="anc8"></a><span class="line-modified"> 72     @Override</span>
<span class="line-added"> 73     public void close() {</span>
<span class="line-added"> 74         SOCKET.close();</span>
 75     }
 76 
<a name="9" id="anc9"></a><span class="line-modified"> 77     public void run() throws Exception {</span>
 78         if (isWindows()) {
 79             System.out.println(&quot;The test only run on non-Windows OS. Bye.&quot;);
 80             return;
 81         }
 82 
 83         if (!hasIPv6()) {
 84             System.out.println(&quot;No IPv6 available. Bye.&quot;);
 85             return;
 86         }
 87 
 88         // We need 2 or more network interfaces to run the test
 89         //
 90         List&lt;NetIf&gt; netIfs = new ArrayList&lt;NetIf&gt;();
 91         int index = 1;
 92         for (NetworkInterface nic : Collections.list(NetworkInterface.getNetworkInterfaces())) {
 93             // we should use only network interfaces with multicast support which are in &quot;up&quot; state
 94             if (!nic.isLoopback() &amp;&amp; nic.supportsMulticast() &amp;&amp; nic.isUp() &amp;&amp; !isTestExcludedInterface(nic)) {
 95                 NetIf netIf = NetIf.create(nic);
 96 
 97                 // now determine what (if any) type of addresses are assigned to this interface
 98                 for (InetAddress addr : Collections.list(nic.getInetAddresses())) {
 99                     if (addr.isAnyLocalAddress())
100                         continue;
101 
102                     System.out.println(&quot;    addr &quot; + addr);
103                     if (addr instanceof Inet4Address) {
104                         netIf.ipv4Address(true);
105                     } else if (addr instanceof Inet6Address) {
106                         netIf.ipv6Address(true);
107                     }
108                 }
109                 if (netIf.ipv4Address() || netIf.ipv6Address()) {
110                     netIf.index(index++);
111                     netIfs.add(netIf);
112                     debug(&quot;Using: &quot; + nic);
113                 }
114             } else {
115                 System.out.println(&quot;Ignore NetworkInterface nic == &quot; + nic);
116             }
117         }
<a name="10" id="anc10"></a><span class="line-added">118         Collections.reverse(netIfs);</span>
119         if (netIfs.size() &lt;= 1) {
120             System.out.println(&quot;Need 2 or more network interfaces to run. Bye.&quot;);
121             return;
122         }
123 
<a name="11" id="anc11"></a><span class="line-added">124         System.out.println(&quot;Using PORT: &quot; + PORT);</span>
<span class="line-added">125 </span>
126         // We will send packets to one ipv4, and one ipv6
127         // multicast group using each network interface :-
128         //      224.1.1.1        --|
129         //      ff02::1:1        --|--&gt; using network interface #1
130         //      224.1.2.1        --|
131         //      ff02::1:2        --|--&gt; using network interface #2
132         // and so on.
133         //
134         for (NetIf netIf : netIfs) {
135             int NetIfIndex = netIf.index();
136             List&lt;InetAddress&gt; groups = new ArrayList&lt;InetAddress&gt;();
137 
138             if (netIf.ipv4Address()) {
139                 InetAddress groupv4 = InetAddress.getByName(&quot;224.1.&quot; + NetIfIndex + &quot;.1&quot;);
140                 groups.add(groupv4);
141             }
142             if (netIf.ipv6Address()) {
143                 InetAddress groupv6 = InetAddress.getByName(&quot;ff02::1:&quot; + NetIfIndex);
144                 groups.add(groupv6);
145             }
146 
147             debug(&quot;Adding &quot; + groups + &quot; groups for &quot; + netIf.nic().getName());
148             netIf.groups(groups);
149 
150             // use a separated thread to send to those 2 groups
151             Thread sender = new Thread(new Sender(netIf,
152                                                   groups,
153                                                   PORT));
154             sender.setDaemon(true); // we want sender to stop when main thread exits
155             sender.start();
156         }
157 
158         // try to receive on each group, then check if the packet comes
159         // from the expected network interface
160         //
161         byte[] buf = new byte[1024];
162         for (NetIf netIf : netIfs) {
163             NetworkInterface nic = netIf.nic();
164             for (InetAddress group : netIf.groups()) {
165                 MulticastSocket mcastsock = new MulticastSocket(PORT);
166                 mcastsock.setSoTimeout(5000);   // 5 second
167                 DatagramPacket packet = new DatagramPacket(buf, 0, buf.length);
168 
169                 // the interface supports the IP multicast group
170                 debug(&quot;Joining &quot; + group + &quot; on &quot; + nic.getName());
171                 mcastsock.joinGroup(new InetSocketAddress(group, PORT), nic);
172 
173                 try {
174                     mcastsock.receive(packet);
175                     debug(&quot;received packet on &quot; + packet.getAddress());
176                 } catch (Exception e) {
177                     // test failed if any exception
178                     throw new RuntimeException(e);
179                 }
180 
181                 // now check which network interface this packet comes from
182                 NetworkInterface from = NetworkInterface.getByInetAddress(packet.getAddress());
183                 NetworkInterface shouldbe = nic;
184                 if (from != null) {
185                     if (!from.equals(shouldbe)) {
186                         System.out.println(&quot;Packets on group &quot;
187                                         + group + &quot; should come from &quot;
188                                         + shouldbe.getName() + &quot;, but came from &quot;
189                                         + from.getName());
190                     }
191                 }
192 
193                 mcastsock.leaveGroup(new InetSocketAddress(group, PORT), nic);
194             }
195         }
196     }
197 
198     private static boolean isTestExcludedInterface(NetworkInterface nif) {
<a name="12" id="anc12"></a><span class="line-modified">199        return !NetworkConfiguration.isTestable(nif)</span>
<span class="line-modified">200                || isMacOS() &amp;&amp; nif.getName().startsWith(&quot;utun&quot;);</span>




201     }
202 
203     private static boolean debug = true;
204 
205     static void debug(String message) {
206         if (debug)
207             System.out.println(message);
208     }
209 }
210 
211 class Sender implements Runnable {
212     private NetIf netIf;
213     private List&lt;InetAddress&gt; groups;
214     private int port;
215 
216     public Sender(NetIf netIf,
217                   List&lt;InetAddress&gt; groups,
218                   int port) {
219         this.netIf = netIf;
220         this.groups = groups;
221         this.port = port;
222     }
223 
224     public void run() {
225         try {
226             MulticastSocket mcastsock = new MulticastSocket();
227             mcastsock.setNetworkInterface(netIf.nic());
228             List&lt;DatagramPacket&gt; packets = new LinkedList&lt;DatagramPacket&gt;();
229 
230             byte[] buf = &quot;hello world&quot;.getBytes();
231             for (InetAddress group : groups) {
232                 packets.add(new DatagramPacket(buf, buf.length, new InetSocketAddress(group, port)));
233             }
234 
235             for (;;) {
236                 for (DatagramPacket packet : packets)
237                     mcastsock.send(packet);
238 
239                 Thread.sleep(1000);   // sleep 1 second
240             }
241         } catch (Exception e) {
242             throw new RuntimeException(e);
243         }
244     }
245 }
246 
247 @SuppressWarnings(&quot;unchecked&quot;)
248 class NetIf {
249     private boolean ipv4Address; //false
250     private boolean ipv6Address; //false
251     private int index;
252     List&lt;InetAddress&gt; groups = Collections.EMPTY_LIST;
253     private final NetworkInterface nic;
254 
255     private NetIf(NetworkInterface nic) {
256         this.nic = nic;
257     }
258 
259     static NetIf create(NetworkInterface nic) {
260         return new NetIf(nic);
261     }
262 
263     NetworkInterface nic() {
264         return nic;
265     }
266 
267     boolean ipv4Address() {
268         return ipv4Address;
269     }
270 
271     void ipv4Address(boolean ipv4Address) {
272         this.ipv4Address = ipv4Address;
273     }
274 
275     boolean ipv6Address() {
276         return ipv6Address;
277     }
278 
279     void ipv6Address(boolean ipv6Address) {
280         this.ipv6Address = ipv6Address;
281     }
282 
283     int index() {
284         return index;
285     }
286 
287     void index(int index) {
288         this.index = index;
289     }
290 
291     List&lt;InetAddress&gt; groups() {
292         return groups;
293     }
294 
295     void groups(List&lt;InetAddress&gt; groups) {
296         this.groups = groups;
297     }
298 }
<a name="13" id="anc13"></a>
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
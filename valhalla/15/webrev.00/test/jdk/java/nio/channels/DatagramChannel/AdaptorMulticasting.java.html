<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/java/nio/channels/DatagramChannel/AdaptorMulticasting.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /* @test
 25  * @bug 8236925
 26  * @summary Test DatagramChannel socket adaptor as a MulticastSocket
 27  * @library /test/lib
 28  * @build jdk.test.lib.NetworkConfiguration
 29  *        jdk.test.lib.net.IPSupport
 30  * @run main AdaptorMulticasting
 31  * @run main/othervm -Djava.net.preferIPv4Stack=true AdaptorMulticasting
 32  */
 33 
 34 import java.io.IOException;
 35 import java.net.DatagramPacket;
 36 import java.net.InetAddress;
 37 import java.net.InetSocketAddress;
 38 import java.net.MulticastSocket;
 39 import java.net.NetworkInterface;
 40 import java.net.ProtocolFamily;
 41 import java.net.SocketAddress;
 42 import java.net.SocketException;
 43 import java.net.SocketTimeoutException;
 44 import java.net.SocketOption;
 45 import java.nio.channels.DatagramChannel;
 46 import java.util.Arrays;
 47 import java.util.List;
 48 import java.util.stream.Collectors;
 49 import static java.net.StandardSocketOptions.*;
 50 import static java.net.StandardProtocolFamily.*;
 51 
 52 import jdk.test.lib.NetworkConfiguration;
 53 import jdk.test.lib.net.IPSupport;
 54 
 55 public class AdaptorMulticasting {
 56     static final ProtocolFamily UNSPEC = () -&gt; &quot;UNSPEC&quot;;
 57 
 58     public static void main(String[] args) throws IOException {
 59         IPSupport.throwSkippedExceptionIfNonOperational();
 60 
 61         // IPv4 and IPv6 interfaces that support multicasting
 62         NetworkConfiguration config = NetworkConfiguration.probe();
 63         List&lt;NetworkInterface&gt; ip4MulticastInterfaces = config.ip4MulticastInterfaces()
 64                 .collect(Collectors.toList());
 65         List&lt;NetworkInterface&gt; ip6MulticastInterfaces = config.ip6MulticastInterfaces()
 66                 .collect(Collectors.toList());
 67 
 68         // multicast groups used for the test
 69         InetAddress ip4Group = InetAddress.getByName(&quot;225.4.5.6&quot;);
 70         InetAddress ip6Group = InetAddress.getByName(&quot;ff02::a&quot;);
 71 
 72         for (NetworkInterface ni : ip4MulticastInterfaces) {
 73             test(INET, ip4Group, ni);
 74             if (IPSupport.hasIPv6()) {
 75                 test(UNSPEC, ip4Group, ni);
 76                 test(INET6, ip4Group, ni);
 77             }
 78         }
 79         for (NetworkInterface ni : ip6MulticastInterfaces) {
 80             test(UNSPEC, ip6Group, ni);
 81             test(INET6, ip6Group, ni);
 82         }
 83     }
 84 
 85     static void test(ProtocolFamily family, InetAddress group, NetworkInterface ni)
 86         throws IOException
 87     {
 88         System.out.format(&quot;Test family=%s, multicast group=%s, interface=%s%n&quot;,
 89             family.name(), group, ni.getName());
 90 
 91         // test 1-arg joinGroup/leaveGroup
 92         try (MulticastSocket s = create(family)) {
 93             testJoinGroup1(family, s, group, ni);
 94         }
 95 
 96         // test 2-arg joinGroup/leaveGroup
 97         try (MulticastSocket s = create(family)) {
 98             testJoinGroup2(family, s, group, ni);
 99         }
100 
101         // test socket options
102         try (MulticastSocket s = create(family)) {
103             testNetworkInterface(s, ni);
104             testTimeToLive(s);
105             testLoopbackMode(s);
106         }
107     }
108 
109     /**
110      * Creates a MulticastSocket. The SO_REUSEADDR socket option is set and it
111      * is bound to the wildcard address.
112      */
113     static MulticastSocket create(ProtocolFamily family) throws IOException {
114         DatagramChannel dc = (family == UNSPEC)
115                 ? DatagramChannel.open()
116                 : DatagramChannel.open(family);
117         try {
118             dc.setOption(SO_REUSEADDR, true).bind(new InetSocketAddress(0));
119         } catch (IOException ioe) {
120             dc.close();
121             throw ioe;
122         }
123         return (MulticastSocket) dc.socket();
124     }
125 
126     /**
127      * Test 1-arg joinGroup/leaveGroup
128      */
129     static void testJoinGroup1(ProtocolFamily family,
130                                MulticastSocket s,
131                                InetAddress group,
132                                NetworkInterface ni) throws IOException {
133         // check network interface not set
134         assertTrue(s.getOption(IP_MULTICAST_IF) == null);
135 
136         // join
137         s.joinGroup(group);
138 
139         // join should not set the outgoing multicast interface
140         assertTrue(s.getOption(IP_MULTICAST_IF) == null);
141 
142         // already a member (exception not specified)
143         assertThrows(SocketException.class, () -&gt; s.joinGroup(group));
144 
145         // leave
146         s.leaveGroup(group);
147 
148         // not a member (exception not specified)
149         assertThrows(SocketException.class, () -&gt; s.leaveGroup(group));
150 
151         // join/leave with outgoing multicast interface set and check that
152         // multicast datagrams can be sent and received
153         s.setOption(IP_MULTICAST_IF, ni);
154         s.joinGroup(group);
155         testSendReceive(s, group);
156         s.leaveGroup(group);
157         testSendNoReceive(s, group);
158 
159         // not a multicast address
160         var localHost = InetAddress.getLocalHost();
161         assertThrows(SocketException.class, () -&gt; s.joinGroup(localHost));
162         assertThrows(SocketException.class, () -&gt; s.leaveGroup(localHost));
163 
164         // IPv4 socket cannot join IPv6 group (exception not specified)
165         if (family == INET) {
166             InetAddress ip6Group = InetAddress.getByName(&quot;ff02::a&quot;);
167             assertThrows(SocketException.class, () -&gt; s.joinGroup(ip6Group));
168             assertThrows(SocketException.class, () -&gt; s.leaveGroup(ip6Group));
169         }
170 
171         // null (exception not specified)
172         assertThrows(NullPointerException.class, () -&gt; s.joinGroup(null));
173         assertThrows(NullPointerException.class, () -&gt; s.leaveGroup(null));
174     }
175 
176     /**
177      * Test 2-arg joinGroup/leaveGroup
178      */
179     static void testJoinGroup2(ProtocolFamily family,
180                                MulticastSocket s,
181                                InetAddress group,
182                                NetworkInterface ni) throws IOException {
183         // check network interface not set
184         assertTrue(s.getOption(IP_MULTICAST_IF) == null);
185 
186         // join on default interface
187         s.joinGroup(new InetSocketAddress(group, 0), null);
188 
189         // join should not change the outgoing multicast interface
190         assertTrue(s.getOption(IP_MULTICAST_IF) == null);
191 
192         // already a member (exception not specified)
193         assertThrows(SocketException.class,
194                      () -&gt; s.joinGroup(new InetSocketAddress(group, 0), null));
195 
196         // leave
197         s.leaveGroup(new InetSocketAddress(group, 0), null);
198 
199         // not a member (exception not specified)
200         assertThrows(SocketException.class,
201                      () -&gt; s.leaveGroup(new InetSocketAddress(group, 0), null));
202 
203         // join on specified interface
204         s.joinGroup(new InetSocketAddress(group, 0), ni);
205 
206         // join should not change the outgoing multicast interface
207         assertTrue(s.getOption(IP_MULTICAST_IF) == null);
208 
209         // already a member (exception not specified)
210         assertThrows(SocketException.class,
211                      () -&gt; s.joinGroup(new InetSocketAddress(group, 0), ni));
212 
213         // leave
214         s.leaveGroup(new InetSocketAddress(group, 0), ni);
215 
216         // not a member (exception not specified)
217         assertThrows(SocketException.class,
218                      () -&gt; s.leaveGroup(new InetSocketAddress(group, 0), ni));
219 
220         // join/leave with outgoing multicast interface set and check that
221         // multicast datagrams can be sent and received
222         s.setOption(IP_MULTICAST_IF, ni);
223         s.joinGroup(new InetSocketAddress(group, 0), null);
224         testSendReceive(s, group);
225         s.leaveGroup(new InetSocketAddress(group, 0), null);
226         testSendNoReceive(s, group);
227         s.joinGroup(new InetSocketAddress(group, 0), ni);
228         testSendReceive(s, group);
229         s.leaveGroup(new InetSocketAddress(group, 0), ni);
230         testSendNoReceive(s, group);
231 
232         // not a multicast address
233         var localHost = InetAddress.getLocalHost();
234         assertThrows(SocketException.class,
235                      () -&gt; s.joinGroup(new InetSocketAddress(localHost, 0), null));
236         assertThrows(SocketException.class,
237                      () -&gt; s.leaveGroup(new InetSocketAddress(localHost, 0), null));
238         assertThrows(SocketException.class,
239                      () -&gt; s.joinGroup(new InetSocketAddress(localHost, 0), ni));
240         assertThrows(SocketException.class,
241                      () -&gt; s.leaveGroup(new InetSocketAddress(localHost, 0), ni));
242 
243         // not an InetSocketAddress
244         var customSocketAddress = new SocketAddress() { };
245         assertThrows(IllegalArgumentException.class,
246                      () -&gt; s.joinGroup(customSocketAddress, null));
247         assertThrows(IllegalArgumentException.class,
248                      () -&gt; s.leaveGroup(customSocketAddress, null));
249         assertThrows(IllegalArgumentException.class,
250                      () -&gt; s.joinGroup(customSocketAddress, ni));
251         assertThrows(IllegalArgumentException.class,
252                      () -&gt; s.leaveGroup(customSocketAddress, ni));
253 
254         // IPv4 socket cannot join IPv6 group
255         if (family == INET) {
256             InetAddress ip6Group = InetAddress.getByName(&quot;ff02::a&quot;);
257             assertThrows(IllegalArgumentException.class,
258                          () -&gt; s.joinGroup(new InetSocketAddress(ip6Group, 0), null));
259             assertThrows(IllegalArgumentException.class,
260                          () -&gt; s.joinGroup(new InetSocketAddress(ip6Group, 0), ni));
261 
262             // not a member of IPv6 group (exception not specified)
263             assertThrows(SocketException.class,
264                          () -&gt; s.leaveGroup(new InetSocketAddress(ip6Group, 0), null));
265             assertThrows(SocketException.class,
266                          () -&gt; s.leaveGroup(new InetSocketAddress(ip6Group, 0), ni));
267         }
268 
269         // null
270         assertThrows(IllegalArgumentException.class, () -&gt; s.joinGroup(null, null));
271         assertThrows(IllegalArgumentException.class, () -&gt; s.leaveGroup(null, null));
272         assertThrows(IllegalArgumentException.class, () -&gt; s.joinGroup(null, ni));
273         assertThrows(IllegalArgumentException.class, () -&gt; s.leaveGroup(null, ni));
274     }
275 
276     /**
277      * Test getNetworkInterface/setNetworkInterface/getInterface/setInterface
278      * and IP_MULTICAST_IF socket option.
279      */
280     static void testNetworkInterface(MulticastSocket s,
281                                      NetworkInterface ni) throws IOException {
282         // default value
283         NetworkInterface nif = s.getNetworkInterface();
284         assertTrue(nif.getIndex() == 0);
285         assertTrue(nif.inetAddresses().count() == 1);
286         assertTrue(nif.inetAddresses().findAny().orElseThrow().isAnyLocalAddress());
287         assertTrue(s.getOption(IP_MULTICAST_IF) == null);
288         assertTrue(s.getInterface().isAnyLocalAddress());
289 
290         // setNetworkInterface
291         s.setNetworkInterface(ni);
292         assertTrue(s.getNetworkInterface().equals(ni));
293         assertTrue(s.getOption(IP_MULTICAST_IF).equals(ni));
294         InetAddress address = s.getInterface();
295         assertTrue(ni.inetAddresses().filter(address::equals).findAny().isPresent());
296 
297         // setInterface
298         s.setInterface(address);
299         assertTrue(s.getInterface().equals(address));
300         assertTrue(s.getNetworkInterface()
301                 .inetAddresses()
302                 .filter(address::equals)
303                 .findAny()
304                 .isPresent());
305 
306         // null (exception not specified)
307         assertThrows(IllegalArgumentException.class, () -&gt; s.setNetworkInterface(null));
308         assertThrows(SocketException.class, () -&gt; s.setInterface(null));
309 
310         // setOption(IP_MULTICAST_IF)
311         s.setOption(IP_MULTICAST_IF, ni);
312         assertTrue(s.getOption(IP_MULTICAST_IF).equals(ni));
313         assertTrue(s.getNetworkInterface().equals(ni));
314 
315         // bad values for IP_MULTICAST_IF
316         assertThrows(IllegalArgumentException.class,
317                      () -&gt; s.setOption(IP_MULTICAST_IF, null));
318         assertThrows(IllegalArgumentException.class,
319                      () -&gt; s.setOption((SocketOption) IP_MULTICAST_IF, &quot;badValue&quot;));
320     }
321 
322     /**
323      * Test getTimeToLive/setTimeToLive/getTTL/getTTL and IP_MULTICAST_TTL socket
324      * option.
325      */
326     static void testTimeToLive(MulticastSocket s) throws IOException {
327         // should be 1 by default
328         assertTrue(s.getTimeToLive() == 1);
329         assertTrue(s.getTTL() == 1);
330         assertTrue(s.getOption(IP_MULTICAST_TTL) == 1);
331 
332         // setTimeToLive
333         for (int ttl = 0; ttl &lt;= 2; ttl++) {
334             s.setTimeToLive(ttl);
335             assertTrue(s.getTimeToLive() == ttl);
336             assertTrue(s.getTTL() == ttl);
337             assertTrue(s.getOption(IP_MULTICAST_TTL) == ttl);
338         }
339         assertThrows(IllegalArgumentException.class, () -&gt; s.setTimeToLive(-1));
340 
341         // setTTL
342         for (byte ttl = (byte) -2; ttl &lt;= 2; ttl++) {
343             s.setTTL(ttl);
344             assertTrue(s.getTTL() == ttl);
345             int intValue = Byte.toUnsignedInt(ttl);
346             assertTrue(s.getTimeToLive() == intValue);
347             assertTrue(s.getOption(IP_MULTICAST_TTL) == intValue);
348         }
349 
350         // setOption(IP_MULTICAST_TTL)
351         for (int ttl = 0; ttl &lt;= 2; ttl++) {
352             s.setOption(IP_MULTICAST_TTL, ttl);
353             assertTrue(s.getOption(IP_MULTICAST_TTL) == ttl);
354             assertTrue(s.getTimeToLive() == ttl);
355             assertTrue(s.getTTL() == ttl);
356         }
357 
358         // bad values for IP_MULTICAST_TTL
359         assertThrows(IllegalArgumentException.class,
360                     () -&gt; s.setOption(IP_MULTICAST_TTL, -1));
361         assertThrows(IllegalArgumentException.class,
362                     () -&gt; s.setOption(IP_MULTICAST_TTL, null));
363         assertThrows(IllegalArgumentException.class,
364                     () -&gt; s.setOption((SocketOption) IP_MULTICAST_TTL, &quot;badValue&quot;));
365     }
366 
367     /**
368      * Test getLoopbackMode/setLoopbackMode and IP_MULTICAST_LOOP socket option.
369      */
370     static void testLoopbackMode(MulticastSocket s) throws IOException {
371         // should be enabled by default
372         assertTrue(s.getLoopbackMode() == false);
373         assertTrue(s.getOption(IP_MULTICAST_LOOP) == true);
374 
375         // setLoopbackMode
376         s.setLoopbackMode(true);    // disable
377         assertTrue(s.getLoopbackMode());
378         assertTrue(s.getOption(IP_MULTICAST_LOOP) == false);
379         s.setLoopbackMode(false);   // enable
380         assertTrue(s.getLoopbackMode() == false);
381         assertTrue(s.getOption(IP_MULTICAST_LOOP) == true);
382 
383         // setOption(IP_MULTICAST_LOOP)
384         s.setOption(IP_MULTICAST_LOOP, false);   // disable
385         assertTrue(s.getOption(IP_MULTICAST_LOOP) == false);
386         assertTrue(s.getLoopbackMode() == true);
387         s.setOption(IP_MULTICAST_LOOP, true);  // enable
388         assertTrue(s.getOption(IP_MULTICAST_LOOP) == true);
389         assertTrue(s.getLoopbackMode() == false);
390 
391         // bad values for IP_MULTICAST_LOOP
392         assertThrows(IllegalArgumentException.class,
393                      () -&gt; s.setOption(IP_MULTICAST_LOOP, null));
394         assertThrows(IllegalArgumentException.class,
395                      () -&gt; s.setOption((SocketOption) IP_MULTICAST_LOOP, &quot;badValue&quot;));
396     }
397 
398     /**
399      * Send a datagram to the given multicast group and check that it is received.
400      */
401     static void testSendReceive(MulticastSocket s, InetAddress group) throws IOException {
402         // outgoing multicast interface needs to be set
403         assertTrue(s.getOption(IP_MULTICAST_IF) != null);
404 
405         SocketAddress target = new InetSocketAddress(group, s.getLocalPort());
406         byte[] message = &quot;hello&quot;.getBytes(&quot;UTF-8&quot;);
407 
408         // send message to multicast group
409         DatagramPacket p = new DatagramPacket(message, message.length);
410         p.setSocketAddress(target);
411         s.send(p, (byte) 1);
412 
413         // receive message
414         s.setSoTimeout(0);
415         p = new DatagramPacket(new byte[1024], 100);
416         s.receive(p);
417 
418         assertTrue(p.getLength() == message.length);
419         assertTrue(p.getPort() == s.getLocalPort());
420     }
421 
422     /**
423      * Send a datagram to the given multicast group and check that it is not
424      * received.
425      */
426     static void testSendNoReceive(MulticastSocket s, InetAddress group) throws IOException {
427         // outgoing multicast interface needs to be set
428         assertTrue(s.getOption(IP_MULTICAST_IF) != null);
429 
430         SocketAddress target = new InetSocketAddress(group, s.getLocalPort());
431         long nano = System.nanoTime();
432         String text = nano + &quot;: hello&quot;;
433         byte[] message = text.getBytes(&quot;UTF-8&quot;);
434 
435         // send datagram to multicast group
436         DatagramPacket p = new DatagramPacket(message, message.length);
437         p.setSocketAddress(target);
438         s.send(p, (byte) 1);
439 
440         // datagram should not be received
441         s.setSoTimeout(500);
442         p = new DatagramPacket(new byte[1024], 100);
443         while (true) {
444             try {
445                 s.receive(p);
446                 if (Arrays.equals(p.getData(), p.getOffset(), p.getLength(), message, 0, message.length)) {
447                     throw new RuntimeException(&quot;message shouldn&#39;t have been received&quot;);
448                 } else {
449                     System.out.println(&quot;Received unexpected message from &quot; + p.getSocketAddress());
450                 }
451             } catch (SocketTimeoutException expected) {
452                 break;
453             }
454         }
455     }
456 
457 
458     static void assertTrue(boolean e) {
459         if (!e) throw new RuntimeException();
460     }
461 
462     interface ThrowableRunnable {
463         void run() throws Exception;
464     }
465 
466     static void assertThrows(Class&lt;?&gt; exceptionClass, ThrowableRunnable task) {
467         try {
468             task.run();
469             throw new RuntimeException(&quot;Exception not thrown&quot;);
470         } catch (Exception e) {
471             if (!exceptionClass.isInstance(e)) {
472                 throw new RuntimeException(&quot;expected: &quot; + exceptionClass + &quot;, actual: &quot; + e);
473             }
474         }
475     }
476 }
    </pre>
  </body>
</html>
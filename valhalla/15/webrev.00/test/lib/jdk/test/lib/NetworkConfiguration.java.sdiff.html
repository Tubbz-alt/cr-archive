<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/lib/jdk/test/lib/NetworkConfiguration.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="LockFreeLogger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="Platform.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/lib/jdk/test/lib/NetworkConfiguration.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib;
 25 
 26 import java.io.IOException;
 27 import java.io.PrintStream;
 28 import java.io.UncheckedIOException;
 29 import java.net.Inet4Address;
 30 import java.net.Inet6Address;
 31 import java.net.InetAddress;
 32 import java.net.NetworkInterface;
 33 import java.util.Arrays;
<span class="line-modified"> 34 import java.util.HashMap;</span>
 35 import java.util.LinkedList;
 36 import java.util.List;
 37 import java.util.Map;

 38 import java.util.stream.Collectors;
 39 import java.util.stream.Stream;
 40 import java.security.AccessController;
 41 import java.security.PrivilegedAction;
 42 
 43 import static java.net.NetworkInterface.getNetworkInterfaces;
 44 import static java.util.Collections.list;
 45 
 46 /**
 47  * Helper class for retrieving network interfaces and local addresses
 48  * suitable for testing.
 49  */
 50 public class NetworkConfiguration {
 51 
 52     private Map&lt;NetworkInterface,List&lt;Inet4Address&gt;&gt; ip4Interfaces;
 53     private Map&lt;NetworkInterface,List&lt;Inet6Address&gt;&gt; ip6Interfaces;
 54     private final boolean isIPv6Available;
 55     private boolean has_testableipv6address = false;
 56     private boolean has_sitelocaladdress = false;
 57     private boolean has_linklocaladdress = false;
</pre>
<hr />
<pre>
 70                 // On Solaris or AIX, a configuration with only local or loopback
 71                 // addresses does not fully enable IPv6 operations.
 72                 // E.g. IPv6 multicasting does not work.
 73                 // So, don&#39;t set has_testableipv6address if we only find these.
 74                 .filter(addr -&gt; Platform.isSolaris() || Platform.isAix() ?
 75                     !(addr.isAnyLocalAddress() || addr.isLoopbackAddress()) : true)
 76                 .forEach(ia -&gt; {
 77                     has_testableipv6address = true;
 78                     if (ia.isLinkLocalAddress()) has_linklocaladdress = true;
 79                     if (ia.isSiteLocalAddress()) has_sitelocaladdress = true;
 80 
 81                     if (!ia.isLinkLocalAddress() &amp;&amp;
 82                         !ia.isSiteLocalAddress() &amp;&amp;
 83                         !ia.isLoopbackAddress()) {
 84                         has_globaladdress = true;
 85                     }
 86                 });
 87         });
 88     }
 89 
<span class="line-modified"> 90     private static boolean isNotExcludedInterface(NetworkInterface nif) {</span>
<span class="line-modified"> 91         if (Platform.isOSX() &amp;&amp; nif.getName().contains(&quot;awdl&quot;)) {</span>
<span class="line-modified"> 92             return false;</span>











 93         }
 94         if (Platform.isWindows()) {
 95             String dName = nif.getDisplayName();
 96             if (dName != null &amp;&amp; dName.contains(&quot;Teredo&quot;)) {
 97                 return false;
 98             }
 99         }
100         return true;
101     }
102 
103     private static boolean isNotLoopback(NetworkInterface nif) {
104         try {
105             return !nif.isLoopback();
106         } catch (IOException e) {
107             throw new UncheckedIOException(e);
108         }
109     }
110 
111     private boolean hasIp4Addresses(NetworkInterface nif) {
112         return ip4Interfaces.get(nif).stream().anyMatch(a -&gt; !a.isAnyLocalAddress());
</pre>
<hr />
<pre>
184      * Does any global IPv6 address exist?
185      */
186     public boolean has_globaladdress() {
187         return has_globaladdress;
188     }
189 
190     /**
191      * Returns a stream of interfaces suitable for functional tests.
192      */
193     public Stream&lt;NetworkInterface&gt; interfaces() {
194         return Stream.concat(ip4Interfaces(), ip6Interfaces())
195                      .distinct();
196     }
197 
198     /**
199      * Returns a stream of interfaces suitable for IPv4 functional tests.
200      */
201     public Stream&lt;NetworkInterface&gt; ip4Interfaces() {
202         return ip4Interfaces.keySet()
203                             .stream()
<span class="line-modified">204                             .filter(NetworkConfiguration::isNotExcludedInterface)</span>
205                             .filter(this::hasIp4Addresses);
206     }
207 
208     /**
209      * Returns a stream of interfaces suitable for IPv6 functional tests.
210      */
211     public Stream&lt;NetworkInterface&gt; ip6Interfaces() {
212         return ip6Interfaces.keySet()
213                             .stream()
<span class="line-modified">214                             .filter(NetworkConfiguration::isNotExcludedInterface)</span>
215                             .filter(this::hasIp6Addresses);
216     }
217 
218     /**
219      * Returns a stream of interfaces suitable for functional tests.
220      */
221     public Stream&lt;NetworkInterface&gt; multicastInterfaces(boolean includeLoopback) {
222         return Stream
223             .concat(ip4MulticastInterfaces(includeLoopback),
224                     ip6MulticastInterfaces(includeLoopback))
225             .distinct();
226     }
227 
228     /**
229      * Returns a stream of interfaces suitable for IPv4 multicast tests.
230      *
231      * The loopback interface will not be included.
232      */
233     public Stream&lt;NetworkInterface&gt; ip4MulticastInterfaces() {
234         return ip4MulticastInterfaces(false);
</pre>
<hr />
<pre>
292         return ip4Interfaces.get(nif).stream();
293     }
294 
295     /**
296      * Returns all IPv6 addresses for the given interface.
297      */
298     public Stream&lt;Inet6Address&gt; ip6Addresses(NetworkInterface nif) {
299         return ip6Interfaces.get(nif).stream();
300     }
301 
302     @Override
303     public String toString() {
304         return interfaces().map(NetworkConfiguration::interfaceInformation)
305                            .collect(Collectors.joining());
306     }
307 
308     /**
309      * Return a NetworkConfiguration instance.
310      */
311     public static NetworkConfiguration probe() throws IOException {
<span class="line-modified">312         Map&lt;NetworkInterface, List&lt;Inet4Address&gt;&gt; ip4Interfaces = new HashMap&lt;&gt;();</span>
<span class="line-modified">313         Map&lt;NetworkInterface, List&lt;Inet6Address&gt;&gt; ip6Interfaces = new HashMap&lt;&gt;();</span>
314 
315         List&lt;NetworkInterface&gt; nifs = list(getNetworkInterfaces());
316         for (NetworkInterface nif : nifs) {
317             // ignore interfaces that are down
318             if (!nif.isUp() || nif.isPointToPoint()) {
319                 continue;
320             }
321 
322             List&lt;Inet4Address&gt; ip4Addresses = new LinkedList&lt;&gt;();
323             List&lt;Inet6Address&gt; ip6Addresses = new LinkedList&lt;&gt;();
324             ip4Interfaces.put(nif, ip4Addresses);
325             ip6Interfaces.put(nif, ip6Addresses);
326             for (InetAddress addr : list(nif.getInetAddresses())) {
327                 if (addr instanceof Inet4Address) {
328                     ip4Addresses.add((Inet4Address) addr);
329                 } else if (addr instanceof Inet6Address) {
330                     ip6Addresses.add((Inet6Address) addr);
331                 }
332             }
333         }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib;
 25 
 26 import java.io.IOException;
 27 import java.io.PrintStream;
 28 import java.io.UncheckedIOException;
 29 import java.net.Inet4Address;
 30 import java.net.Inet6Address;
 31 import java.net.InetAddress;
 32 import java.net.NetworkInterface;
 33 import java.util.Arrays;
<span class="line-modified"> 34 import java.util.LinkedHashMap;</span>
 35 import java.util.LinkedList;
 36 import java.util.List;
 37 import java.util.Map;
<span class="line-added"> 38 import java.util.function.Predicate;</span>
 39 import java.util.stream.Collectors;
 40 import java.util.stream.Stream;
 41 import java.security.AccessController;
 42 import java.security.PrivilegedAction;
 43 
 44 import static java.net.NetworkInterface.getNetworkInterfaces;
 45 import static java.util.Collections.list;
 46 
 47 /**
 48  * Helper class for retrieving network interfaces and local addresses
 49  * suitable for testing.
 50  */
 51 public class NetworkConfiguration {
 52 
 53     private Map&lt;NetworkInterface,List&lt;Inet4Address&gt;&gt; ip4Interfaces;
 54     private Map&lt;NetworkInterface,List&lt;Inet6Address&gt;&gt; ip6Interfaces;
 55     private final boolean isIPv6Available;
 56     private boolean has_testableipv6address = false;
 57     private boolean has_sitelocaladdress = false;
 58     private boolean has_linklocaladdress = false;
</pre>
<hr />
<pre>
 71                 // On Solaris or AIX, a configuration with only local or loopback
 72                 // addresses does not fully enable IPv6 operations.
 73                 // E.g. IPv6 multicasting does not work.
 74                 // So, don&#39;t set has_testableipv6address if we only find these.
 75                 .filter(addr -&gt; Platform.isSolaris() || Platform.isAix() ?
 76                     !(addr.isAnyLocalAddress() || addr.isLoopbackAddress()) : true)
 77                 .forEach(ia -&gt; {
 78                     has_testableipv6address = true;
 79                     if (ia.isLinkLocalAddress()) has_linklocaladdress = true;
 80                     if (ia.isSiteLocalAddress()) has_sitelocaladdress = true;
 81 
 82                     if (!ia.isLinkLocalAddress() &amp;&amp;
 83                         !ia.isSiteLocalAddress() &amp;&amp;
 84                         !ia.isLoopbackAddress()) {
 85                         has_globaladdress = true;
 86                     }
 87                 });
 88         });
 89     }
 90 
<span class="line-modified"> 91     private static boolean isIPv6LinkLocal(InetAddress a) {</span>
<span class="line-modified"> 92         return Inet6Address.class.isInstance(a) &amp;&amp; a.isLinkLocalAddress();</span>
<span class="line-modified"> 93     }</span>
<span class="line-added"> 94 </span>
<span class="line-added"> 95     public static boolean isTestable(NetworkInterface nif) {</span>
<span class="line-added"> 96         if (Platform.isOSX()) {</span>
<span class="line-added"> 97             if (nif.getName().contains(&quot;awdl&quot;)) {</span>
<span class="line-added"> 98                 return false; // exclude awdl</span>
<span class="line-added"> 99             }</span>
<span class="line-added">100             // filter out interfaces that only have link-local addresses</span>
<span class="line-added">101             return nif.inetAddresses()</span>
<span class="line-added">102                     .filter(Predicate.not(NetworkConfiguration::isIPv6LinkLocal))</span>
<span class="line-added">103                     .findAny()</span>
<span class="line-added">104                     .isPresent();</span>
105         }
106         if (Platform.isWindows()) {
107             String dName = nif.getDisplayName();
108             if (dName != null &amp;&amp; dName.contains(&quot;Teredo&quot;)) {
109                 return false;
110             }
111         }
112         return true;
113     }
114 
115     private static boolean isNotLoopback(NetworkInterface nif) {
116         try {
117             return !nif.isLoopback();
118         } catch (IOException e) {
119             throw new UncheckedIOException(e);
120         }
121     }
122 
123     private boolean hasIp4Addresses(NetworkInterface nif) {
124         return ip4Interfaces.get(nif).stream().anyMatch(a -&gt; !a.isAnyLocalAddress());
</pre>
<hr />
<pre>
196      * Does any global IPv6 address exist?
197      */
198     public boolean has_globaladdress() {
199         return has_globaladdress;
200     }
201 
202     /**
203      * Returns a stream of interfaces suitable for functional tests.
204      */
205     public Stream&lt;NetworkInterface&gt; interfaces() {
206         return Stream.concat(ip4Interfaces(), ip6Interfaces())
207                      .distinct();
208     }
209 
210     /**
211      * Returns a stream of interfaces suitable for IPv4 functional tests.
212      */
213     public Stream&lt;NetworkInterface&gt; ip4Interfaces() {
214         return ip4Interfaces.keySet()
215                             .stream()
<span class="line-modified">216                             .filter(NetworkConfiguration::isTestable)</span>
217                             .filter(this::hasIp4Addresses);
218     }
219 
220     /**
221      * Returns a stream of interfaces suitable for IPv6 functional tests.
222      */
223     public Stream&lt;NetworkInterface&gt; ip6Interfaces() {
224         return ip6Interfaces.keySet()
225                             .stream()
<span class="line-modified">226                             .filter(NetworkConfiguration::isTestable)</span>
227                             .filter(this::hasIp6Addresses);
228     }
229 
230     /**
231      * Returns a stream of interfaces suitable for functional tests.
232      */
233     public Stream&lt;NetworkInterface&gt; multicastInterfaces(boolean includeLoopback) {
234         return Stream
235             .concat(ip4MulticastInterfaces(includeLoopback),
236                     ip6MulticastInterfaces(includeLoopback))
237             .distinct();
238     }
239 
240     /**
241      * Returns a stream of interfaces suitable for IPv4 multicast tests.
242      *
243      * The loopback interface will not be included.
244      */
245     public Stream&lt;NetworkInterface&gt; ip4MulticastInterfaces() {
246         return ip4MulticastInterfaces(false);
</pre>
<hr />
<pre>
304         return ip4Interfaces.get(nif).stream();
305     }
306 
307     /**
308      * Returns all IPv6 addresses for the given interface.
309      */
310     public Stream&lt;Inet6Address&gt; ip6Addresses(NetworkInterface nif) {
311         return ip6Interfaces.get(nif).stream();
312     }
313 
314     @Override
315     public String toString() {
316         return interfaces().map(NetworkConfiguration::interfaceInformation)
317                            .collect(Collectors.joining());
318     }
319 
320     /**
321      * Return a NetworkConfiguration instance.
322      */
323     public static NetworkConfiguration probe() throws IOException {
<span class="line-modified">324         Map&lt;NetworkInterface, List&lt;Inet4Address&gt;&gt; ip4Interfaces = new LinkedHashMap&lt;&gt;();</span>
<span class="line-modified">325         Map&lt;NetworkInterface, List&lt;Inet6Address&gt;&gt; ip6Interfaces = new LinkedHashMap&lt;&gt;();</span>
326 
327         List&lt;NetworkInterface&gt; nifs = list(getNetworkInterfaces());
328         for (NetworkInterface nif : nifs) {
329             // ignore interfaces that are down
330             if (!nif.isUp() || nif.isPointToPoint()) {
331                 continue;
332             }
333 
334             List&lt;Inet4Address&gt; ip4Addresses = new LinkedList&lt;&gt;();
335             List&lt;Inet6Address&gt; ip6Addresses = new LinkedList&lt;&gt;();
336             ip4Interfaces.put(nif, ip4Addresses);
337             ip6Interfaces.put(nif, ip6Addresses);
338             for (InetAddress addr : list(nif.getInetAddresses())) {
339                 if (addr instanceof Inet4Address) {
340                     ip4Addresses.add((Inet4Address) addr);
341                 } else if (addr instanceof Inet6Address) {
342                     ip6Addresses.add((Inet6Address) addr);
343                 }
344             }
345         }
</pre>
</td>
</tr>
</table>
<center><a href="LockFreeLogger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="Platform.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
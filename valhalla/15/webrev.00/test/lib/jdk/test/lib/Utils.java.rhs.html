<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/lib/jdk/test/lib/Utils.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib;
 25 
 26 import java.io.File;
 27 import java.io.IOException;
 28 import java.lang.annotation.Annotation;
 29 import java.net.InetAddress;
 30 import java.net.InetSocketAddress;
 31 import java.net.MalformedURLException;
 32 import java.net.ServerSocket;
 33 import java.net.URL;
 34 import java.net.URLClassLoader;
 35 import java.net.UnknownHostException;
 36 import java.nio.file.Files;
 37 import java.nio.file.Path;
 38 import java.nio.file.Paths;
 39 import java.nio.file.attribute.FileAttribute;
 40 import java.nio.channels.SocketChannel;
 41 import java.util.ArrayList;
 42 import java.util.Arrays;
 43 import java.util.Collection;
 44 import java.util.Collections;
 45 import java.util.Iterator;
 46 import java.util.Map;
 47 import java.util.HashMap;
 48 import java.util.List;
 49 import java.util.Objects;
 50 import java.util.Random;
 51 import java.util.function.BooleanSupplier;
 52 import java.util.concurrent.TimeUnit;
 53 import java.util.function.Consumer;
 54 import java.util.function.Function;
 55 import java.util.regex.Matcher;
 56 import java.util.regex.Pattern;
 57 
 58 import static jdk.test.lib.Asserts.assertTrue;
 59 import jdk.test.lib.process.ProcessTools;
 60 import jdk.test.lib.process.OutputAnalyzer;
 61 
 62 /**
 63  * Common library for various test helper functions.
 64  */
 65 public final class Utils {
 66 
 67     /**
 68      * Returns the value of &#39;test.class.path&#39; system property.
 69      */
 70     public static final String TEST_CLASS_PATH = System.getProperty(&quot;test.class.path&quot;, &quot;.&quot;);
 71 
 72     /**
 73      * Returns the sequence used by operating system to separate lines.
 74      */
 75     public static final String NEW_LINE = System.getProperty(&quot;line.separator&quot;);
 76 
 77     /**
 78      * Returns the value of &#39;test.vm.opts&#39; system property.
 79      */
 80     public static final String VM_OPTIONS = System.getProperty(&quot;test.vm.opts&quot;, &quot;&quot;).trim();
 81 
 82     /**
 83      * Returns the value of &#39;test.java.opts&#39; system property.
 84      */
 85     public static final String JAVA_OPTIONS = System.getProperty(&quot;test.java.opts&quot;, &quot;&quot;).trim();
 86 
 87     /**
 88      * Returns the value of &#39;test.src&#39; system property.
 89      */
 90     public static final String TEST_SRC = System.getProperty(&quot;test.src&quot;, &quot;&quot;).trim();
 91 
 92     /**
 93      * Returns the value of &#39;test.root&#39; system property.
 94      */
 95     public static final String TEST_ROOT = System.getProperty(&quot;test.root&quot;, &quot;&quot;).trim();
 96 
 97     /*
 98      * Returns the value of &#39;test.jdk&#39; system property
 99      */
100     public static final String TEST_JDK = System.getProperty(&quot;test.jdk&quot;);
101 
102     /*
103      * Returns the value of &#39;compile.jdk&#39; system property
104      */
105     public static final String COMPILE_JDK = System.getProperty(&quot;compile.jdk&quot;, TEST_JDK);
106 
107     /**
108      * Returns the value of &#39;test.classes&#39; system property
109      */
110     public static final String TEST_CLASSES = System.getProperty(&quot;test.classes&quot;, &quot;.&quot;);
111 
112     /**
113      * Defines property name for seed value.
114      */
115     public static final String SEED_PROPERTY_NAME = &quot;jdk.test.lib.random.seed&quot;;
116 
117     /* (non-javadoc)
118      * Random generator with (or without) predefined seed. Depends on
119      * &quot;jdk.test.lib.random.seed&quot; property value.
120      */
121     private static volatile Random RANDOM_GENERATOR;
122 
<a name="1" id="anc1"></a><span class="line-added">123     /**</span>
<span class="line-added">124      * Maximum number of attempts to get free socket</span>
<span class="line-added">125      */</span>
<span class="line-added">126     private static final int MAX_SOCKET_TRIES = 10;</span>
<span class="line-added">127 </span>
128     /**
129      * Contains the seed value used for {@link java.util.Random} creation.
130      */
131     public static final long SEED = Long.getLong(SEED_PROPERTY_NAME, new Random().nextLong());
132     /**
133      * Returns the value of &#39;test.timeout.factor&#39; system property
134      * converted to {@code double}.
135      */
136     public static final double TIMEOUT_FACTOR;
137     static {
138         String toFactor = System.getProperty(&quot;test.timeout.factor&quot;, &quot;1.0&quot;);
139         TIMEOUT_FACTOR = Double.parseDouble(toFactor);
140     }
141 
142     /**
143      * Returns the value of JTREG default test timeout in milliseconds
144      * converted to {@code long}.
145      */
146     public static final long DEFAULT_TEST_TIMEOUT = TimeUnit.SECONDS.toMillis(120);
147 
148     private Utils() {
149         // Private constructor to prevent class instantiation
150     }
151 
152     /**
153      * Returns the list of VM options with -J prefix.
154      *
155      * @return The list of VM options with -J prefix
156      */
157     public static List&lt;String&gt; getForwardVmOptions() {
158         String[] opts = safeSplitString(VM_OPTIONS);
159         for (int i = 0; i &lt; opts.length; i++) {
160             opts[i] = &quot;-J&quot; + opts[i];
161         }
162         return Arrays.asList(opts);
163     }
164 
165     /**
166      * Returns the default JTReg arguments for a jvm running a test.
167      * This is the combination of JTReg arguments test.vm.opts and test.java.opts.
168      * @return An array of options, or an empty array if no options.
169      */
170     public static String[] getTestJavaOpts() {
171         List&lt;String&gt; opts = new ArrayList&lt;String&gt;();
172         Collections.addAll(opts, safeSplitString(VM_OPTIONS));
173         Collections.addAll(opts, safeSplitString(JAVA_OPTIONS));
174         return opts.toArray(new String[0]);
175     }
176 
177     /**
178      * Combines given arguments with default JTReg arguments for a jvm running a test.
179      * This is the combination of JTReg arguments test.vm.opts and test.java.opts
180      * @return The combination of JTReg test java options and user args.
181      */
182     public static String[] prependTestJavaOpts(String... userArgs) {
183         List&lt;String&gt; opts = new ArrayList&lt;String&gt;();
184         Collections.addAll(opts, getTestJavaOpts());
185         Collections.addAll(opts, userArgs);
186         return opts.toArray(new String[0]);
187     }
188 
189     /**
190      * Combines given arguments with default JTReg arguments for a jvm running a test.
191      * This is the combination of JTReg arguments test.vm.opts and test.java.opts
192      * @return The combination of JTReg test java options and user args.
193      */
194     public static String[] appendTestJavaOpts(String... userArgs) {
195         List&lt;String&gt; opts = new ArrayList&lt;String&gt;();
196         Collections.addAll(opts, userArgs);
197         Collections.addAll(opts, getTestJavaOpts());
198         return opts.toArray(new String[0]);
199     }
200 
201     /**
202      * Combines given arguments with default JTReg arguments for a jvm running a test.
203      * This is the combination of JTReg arguments test.vm.opts and test.java.opts
204      * @return The combination of JTReg test java options and user args.
205      */
206     public static String[] addTestJavaOpts(String... userArgs) {
207         return prependTestJavaOpts(userArgs);
208     }
209 
210     /**
211      * Removes any options specifying which GC to use, for example &quot;-XX:+UseG1GC&quot;.
212      * Removes any options matching: -XX:(+/-)Use*GC
213      * Used when a test need to set its own GC version. Then any
214      * GC specified by the framework must first be removed.
215      * @return A copy of given opts with all GC options removed.
216      */
217     private static final Pattern useGcPattern = Pattern.compile(
218             &quot;(?:\\-XX\\:[\\+\\-]Use.+GC)&quot;);
219     public static List&lt;String&gt; removeGcOpts(List&lt;String&gt; opts) {
220         List&lt;String&gt; optsWithoutGC = new ArrayList&lt;String&gt;();
221         for (String opt : opts) {
222             if (useGcPattern.matcher(opt).matches()) {
223                 System.out.println(&quot;removeGcOpts: removed &quot; + opt);
224             } else {
225                 optsWithoutGC.add(opt);
226             }
227         }
228         return optsWithoutGC;
229     }
230 
231     /**
232      * Returns the default JTReg arguments for a jvm running a test without
233      * options that matches regular expressions in {@code filters}.
234      * This is the combination of JTReg arguments test.vm.opts and test.java.opts.
235      * @param filters Regular expressions used to filter out options.
236      * @return An array of options, or an empty array if no options.
237      */
238     public static String[] getFilteredTestJavaOpts(String... filters) {
239         String options[] = getTestJavaOpts();
240 
241         if (filters.length == 0) {
242             return options;
243         }
244 
245         List&lt;String&gt; filteredOptions = new ArrayList&lt;String&gt;(options.length);
246         Pattern patterns[] = new Pattern[filters.length];
247         for (int i = 0; i &lt; filters.length; i++) {
248             patterns[i] = Pattern.compile(filters[i]);
249         }
250 
251         for (String option : options) {
252             boolean matched = false;
253             for (int i = 0; i &lt; patterns.length &amp;&amp; !matched; i++) {
254                 Matcher matcher = patterns[i].matcher(option);
255                 matched = matcher.find();
256             }
257             if (!matched) {
258                 filteredOptions.add(option);
259             }
260         }
261 
262         return filteredOptions.toArray(new String[filteredOptions.size()]);
263     }
264 
265     /**
266      * Splits a string by white space.
267      * Works like String.split(), but returns an empty array
268      * if the string is null or empty.
269      */
270     private static String[] safeSplitString(String s) {
271         if (s == null || s.trim().isEmpty()) {
272             return new String[] {};
273         }
274         return s.trim().split(&quot;\\s+&quot;);
275     }
276 
277     /**
278      * @return The full command line for the ProcessBuilder.
279      */
280     public static String getCommandLine(ProcessBuilder pb) {
281         StringBuilder cmd = new StringBuilder();
282         for (String s : pb.command()) {
283             cmd.append(s).append(&quot; &quot;);
284         }
285         return cmd.toString();
286     }
287 
288     /**
289      * Returns the socket address of an endpoint that refuses connections. The
290      * endpoint is an InetSocketAddress where the address is the loopback address
291      * and the port is a system port (1-1023 range).
292      * This method is a better choice than getFreePort for tests that need
293      * an endpoint that refuses connections.
294      */
295     public static InetSocketAddress refusingEndpoint() {
296         InetAddress lb = InetAddress.getLoopbackAddress();
297         int port = 1;
298         while (port &lt; 1024) {
299             InetSocketAddress sa = new InetSocketAddress(lb, port);
300             try {
301                 SocketChannel.open(sa).close();
302             } catch (IOException ioe) {
303                 return sa;
304             }
305             port++;
306         }
307         throw new RuntimeException(&quot;Unable to find system port that is refusing connections&quot;);
308     }
309 
310     /**
311      * Returns the free port on the local host.
312      *
313      * @return The port number
314      * @throws IOException if an I/O error occurs when opening the socket
315      */
316     public static int getFreePort() throws IOException {
317         try (ServerSocket serverSocket =
318                 new ServerSocket(0, 5, InetAddress.getLoopbackAddress());) {
319             return serverSocket.getLocalPort();
320         }
321     }
322 
<a name="2" id="anc2"></a><span class="line-added">323     /**</span>
<span class="line-added">324      * Returns the free unreserved port on the local host.</span>
<span class="line-added">325      *</span>
<span class="line-added">326      * @param reservedPorts reserved ports</span>
<span class="line-added">327      * @return The port number or -1 if failed to find a free port</span>
<span class="line-added">328      */</span>
<span class="line-added">329     public static int findUnreservedFreePort(int... reservedPorts) {</span>
<span class="line-added">330         int numTries = 0;</span>
<span class="line-added">331         while (numTries++ &lt; MAX_SOCKET_TRIES) {</span>
<span class="line-added">332             int port = -1;</span>
<span class="line-added">333             try {</span>
<span class="line-added">334                 port = getFreePort();</span>
<span class="line-added">335             } catch (IOException e) {</span>
<span class="line-added">336                 e.printStackTrace();</span>
<span class="line-added">337             }</span>
<span class="line-added">338             if (port &gt; 0 &amp;&amp; !isReserved(port, reservedPorts)) {</span>
<span class="line-added">339                 return port;</span>
<span class="line-added">340             }</span>
<span class="line-added">341         }</span>
<span class="line-added">342         return -1;</span>
<span class="line-added">343     }</span>
<span class="line-added">344 </span>
<span class="line-added">345     private static boolean isReserved(int port, int[] reservedPorts) {</span>
<span class="line-added">346         for (int p : reservedPorts) {</span>
<span class="line-added">347             if (p == port) {</span>
<span class="line-added">348                 return true;</span>
<span class="line-added">349             }</span>
<span class="line-added">350         }</span>
<span class="line-added">351         return false;</span>
<span class="line-added">352     }</span>
<span class="line-added">353 </span>
354     /**
355      * Returns the name of the local host.
356      *
357      * @return The host name
358      * @throws UnknownHostException if IP address of a host could not be determined
359      */
360     public static String getHostname() throws UnknownHostException {
361         InetAddress inetAddress = InetAddress.getLocalHost();
362         String hostName = inetAddress.getHostName();
363 
364         assertTrue((hostName != null &amp;&amp; !hostName.isEmpty()),
365                 &quot;Cannot get hostname&quot;);
366 
367         return hostName;
368     }
369 
370     /**
371      * Uses &quot;jcmd -l&quot; to search for a jvm pid. This function will wait
372      * forever (until jtreg timeout) for the pid to be found.
373      * @param key Regular expression to search for
374      * @return The found pid.
375      */
376     public static int waitForJvmPid(String key) throws Throwable {
377         final long iterationSleepMillis = 250;
378         System.out.println(&quot;waitForJvmPid: Waiting for key &#39;&quot; + key + &quot;&#39;&quot;);
379         System.out.flush();
380         while (true) {
381             int pid = tryFindJvmPid(key);
382             if (pid &gt;= 0) {
383                 return pid;
384             }
385             Thread.sleep(iterationSleepMillis);
386         }
387     }
388 
389     /**
390      * Searches for a jvm pid in the output from &quot;jcmd -l&quot;.
391      *
392      * Example output from jcmd is:
393      * 12498 sun.tools.jcmd.JCmd -l
394      * 12254 /tmp/jdk8/tl/jdk/JTwork/classes/com/sun/tools/attach/Application.jar
395      *
396      * @param key A regular expression to search for.
397      * @return The found pid, or -1 if not found.
398      * @throws Exception If multiple matching jvms are found.
399      */
400     public static int tryFindJvmPid(String key) throws Throwable {
401         OutputAnalyzer output = null;
402         try {
403             JDKToolLauncher jcmdLauncher = JDKToolLauncher.create(&quot;jcmd&quot;);
404             jcmdLauncher.addToolArg(&quot;-l&quot;);
405             output = ProcessTools.executeProcess(jcmdLauncher.getCommand());
406             output.shouldHaveExitValue(0);
407 
408             // Search for a line starting with numbers (pid), follwed by the key.
409             Pattern pattern = Pattern.compile(&quot;([0-9]+)\\s.*(&quot; + key + &quot;).*\\r?\\n&quot;);
410             Matcher matcher = pattern.matcher(output.getStdout());
411 
412             int pid = -1;
413             if (matcher.find()) {
414                 pid = Integer.parseInt(matcher.group(1));
415                 System.out.println(&quot;findJvmPid.pid: &quot; + pid);
416                 if (matcher.find()) {
417                     throw new Exception(&quot;Found multiple JVM pids for key: &quot; + key);
418                 }
419             }
420             return pid;
421         } catch (Throwable t) {
422             System.out.println(String.format(&quot;Utils.findJvmPid(%s) failed: %s&quot;, key, t));
423             throw t;
424         }
425     }
426 
427     /**
428      * Adjusts the provided timeout value for the TIMEOUT_FACTOR
429      * @param tOut the timeout value to be adjusted
430      * @return The timeout value adjusted for the value of &quot;test.timeout.factor&quot;
431      *         system property
432      */
433     public static long adjustTimeout(long tOut) {
434         return Math.round(tOut * Utils.TIMEOUT_FACTOR);
435     }
436 
437     /**
438      * Return the contents of the named file as a single String,
439      * or null if not found.
440      * @param filename name of the file to read
441      * @return String contents of file, or null if file not found.
442      * @throws  IOException
443      *          if an I/O error occurs reading from the file or a malformed or
444      *          unmappable byte sequence is read
445      */
446     public static String fileAsString(String filename) throws IOException {
447         Path filePath = Paths.get(filename);
448         if (!Files.exists(filePath)) return null;
449         return new String(Files.readAllBytes(filePath));
450     }
451 
452     private static final char[] hexArray = new char[]{&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;};
453 
454     /**
455      * Returns hex view of byte array
456      *
457      * @param bytes byte array to process
458      * @return space separated hexadecimal string representation of bytes
459      */
460      public static String toHexString(byte[] bytes) {
461          char[] hexView = new char[bytes.length * 3 - 1];
462          for (int i = 0; i &lt; bytes.length - 1; i++) {
463              hexView[i * 3] = hexArray[(bytes[i] &gt;&gt; 4) &amp; 0x0F];
464              hexView[i * 3 + 1] = hexArray[bytes[i] &amp; 0x0F];
465              hexView[i * 3 + 2] = &#39; &#39;;
466          }
467          hexView[hexView.length - 2] = hexArray[(bytes[bytes.length - 1] &gt;&gt; 4) &amp; 0x0F];
468          hexView[hexView.length - 1] = hexArray[bytes[bytes.length - 1] &amp; 0x0F];
469          return new String(hexView);
470      }
471 
472      /**
473       * Returns byte array of hex view
474       *
475       * @param hex hexadecimal string representation
476       * @return byte array
477       */
478      public static byte[] toByteArray(String hex) {
479          int length = hex.length();
480          byte[] bytes = new byte[length / 2];
481          for (int i = 0; i &lt; length; i += 2) {
482              bytes[i / 2] = (byte) ((Character.digit(hex.charAt(i), 16) &lt;&lt; 4)
483                      + Character.digit(hex.charAt(i + 1), 16));
484          }
485          return bytes;
486      }
487 
488     /**
489      * Returns {@link java.util.Random} generator initialized with particular seed.
490      * The seed could be provided via system property {@link Utils#SEED_PROPERTY_NAME}
491      * In case no seed is provided, the method uses a random number.
492      * The used seed printed to stdout.
493      * @return {@link java.util.Random} generator with particular seed.
494      */
495     public static Random getRandomInstance() {
496         if (RANDOM_GENERATOR == null) {
497             synchronized (Utils.class) {
498                 if (RANDOM_GENERATOR == null) {
499                     RANDOM_GENERATOR = new Random(SEED);
500                     System.out.printf(&quot;For random generator using seed: %d%n&quot;, SEED);
501                     System.out.printf(&quot;To re-run test with same seed value please add \&quot;-D%s=%d\&quot; to command line.%n&quot;, SEED_PROPERTY_NAME, SEED);
502                 }
503             }
504         }
505         return RANDOM_GENERATOR;
506     }
507 
508     /**
509      * Returns random element of non empty collection
510      *
511      * @param &lt;T&gt; a type of collection element
512      * @param collection collection of elements
513      * @return random element of collection
514      * @throws IllegalArgumentException if collection is empty
515      */
516     public static &lt;T&gt; T getRandomElement(Collection&lt;T&gt; collection)
517             throws IllegalArgumentException {
518         if (collection.isEmpty()) {
519             throw new IllegalArgumentException(&quot;Empty collection&quot;);
520         }
521         Random random = getRandomInstance();
522         int elementIndex = 1 + random.nextInt(collection.size() - 1);
523         Iterator&lt;T&gt; iterator = collection.iterator();
524         while (--elementIndex != 0) {
525             iterator.next();
526         }
527         return iterator.next();
528     }
529 
530     /**
531      * Returns random element of non empty array
532      *
533      * @param &lt;T&gt; a type of array element
534      * @param array array of elements
535      * @return random element of array
536      * @throws IllegalArgumentException if array is empty
537      */
538     public static &lt;T&gt; T getRandomElement(T[] array)
539             throws IllegalArgumentException {
540         if (array == null || array.length == 0) {
541             throw new IllegalArgumentException(&quot;Empty or null array&quot;);
542         }
543         Random random = getRandomInstance();
544         return array[random.nextInt(array.length)];
545     }
546 
547     /**
548      * Wait for condition to be true
549      *
550      * @param condition, a condition to wait for
551      */
552     public static final void waitForCondition(BooleanSupplier condition) {
553         waitForCondition(condition, -1L, 100L);
554     }
555 
556     /**
557      * Wait until timeout for condition to be true
558      *
559      * @param condition, a condition to wait for
560      * @param timeout a time in milliseconds to wait for condition to be true
561      * specifying -1 will wait forever
562      * @return condition value, to determine if wait was successful
563      */
564     public static final boolean waitForCondition(BooleanSupplier condition,
565             long timeout) {
566         return waitForCondition(condition, timeout, 100L);
567     }
568 
569     /**
570      * Wait until timeout for condition to be true for specified time
571      *
572      * @param condition, a condition to wait for
573      * @param timeout a time in milliseconds to wait for condition to be true,
574      * specifying -1 will wait forever
575      * @param sleepTime a time to sleep value in milliseconds
576      * @return condition value, to determine if wait was successful
577      */
578     public static final boolean waitForCondition(BooleanSupplier condition,
579             long timeout, long sleepTime) {
580         long startTime = System.currentTimeMillis();
581         while (!(condition.getAsBoolean() || (timeout != -1L
582                 &amp;&amp; ((System.currentTimeMillis() - startTime) &gt; timeout)))) {
583             try {
584                 Thread.sleep(sleepTime);
585             } catch (InterruptedException e) {
586                 Thread.currentThread().interrupt();
587                 throw new Error(e);
588             }
589         }
590         return condition.getAsBoolean();
591     }
592 
593     /**
594      * Interface same as java.lang.Runnable but with
595      * method {@code run()} able to throw any Throwable.
596      */
597     public static interface ThrowingRunnable {
598         void run() throws Throwable;
599     }
600 
601     /**
602      * Filters out an exception that may be thrown by the given
603      * test according to the given filter.
604      *
605      * @param test - method that is invoked and checked for exception.
606      * @param filter - function that checks if the thrown exception matches
607      *                 criteria given in the filter&#39;s implementation.
608      * @return - exception that matches the filter if it has been thrown or
609      *           {@code null} otherwise.
610      * @throws Throwable - if test has thrown an exception that does not
611      *                     match the filter.
612      */
613     public static Throwable filterException(ThrowingRunnable test,
614             Function&lt;Throwable, Boolean&gt; filter) throws Throwable {
615         try {
616             test.run();
617         } catch (Throwable t) {
618             if (filter.apply(t)) {
619                 return t;
620             } else {
621                 throw t;
622             }
623         }
624         return null;
625     }
626 
627     /**
628      * Ensures a requested class is loaded
629      * @param aClass class to load
630      */
631     public static void ensureClassIsLoaded(Class&lt;?&gt; aClass) {
632         if (aClass == null) {
633             throw new Error(&quot;Requested null class&quot;);
634         }
635         try {
636             Class.forName(aClass.getName(), /* initialize = */ true,
637                     ClassLoader.getSystemClassLoader());
638         } catch (ClassNotFoundException e) {
639             throw new Error(&quot;Class not found&quot;, e);
640         }
641     }
642     /**
643      * @param parent a class loader to be the parent for the returned one
644      * @return an UrlClassLoader with urls made of the &#39;test.class.path&#39; jtreg
645      *         property and with the given parent
646      */
647     public static URLClassLoader getTestClassPathURLClassLoader(ClassLoader parent) {
648         URL[] urls = Arrays.stream(TEST_CLASS_PATH.split(File.pathSeparator))
649                 .map(Paths::get)
650                 .map(Path::toUri)
651                 .map(x -&gt; {
652                     try {
653                         return x.toURL();
654                     } catch (MalformedURLException ex) {
655                         throw new Error(&quot;Test issue. JTREG property&quot;
656                                 + &quot; &#39;test.class.path&#39;&quot;
657                                 + &quot; is not defined correctly&quot;, ex);
658                     }
659                 }).toArray(URL[]::new);
660         return new URLClassLoader(urls, parent);
661     }
662 
663     /**
664      * Runs runnable and checks that it throws expected exception. If exceptionException is null it means
665      * that we expect no exception to be thrown.
666      * @param runnable what we run
667      * @param expectedException expected exception
668      */
669     public static void runAndCheckException(ThrowingRunnable runnable, Class&lt;? extends Throwable&gt; expectedException) {
670         runAndCheckException(runnable, t -&gt; {
671             if (t == null) {
672                 if (expectedException != null) {
673                     throw new AssertionError(&quot;Didn&#39;t get expected exception &quot; + expectedException.getSimpleName());
674                 }
675             } else {
676                 String message = &quot;Got unexpected exception &quot; + t.getClass().getSimpleName();
677                 if (expectedException == null) {
678                     throw new AssertionError(message, t);
679                 } else if (!expectedException.isAssignableFrom(t.getClass())) {
680                     message += &quot; instead of &quot; + expectedException.getSimpleName();
681                     throw new AssertionError(message, t);
682                 }
683             }
684         });
685     }
686 
687     /**
688      * Runs runnable and makes some checks to ensure that it throws expected exception.
689      * @param runnable what we run
690      * @param checkException a consumer which checks that we got expected exception and raises a new exception otherwise
691      */
692     public static void runAndCheckException(ThrowingRunnable runnable, Consumer&lt;Throwable&gt; checkException) {
693         Throwable throwable = null;
694         try {
695             runnable.run();
696         } catch (Throwable t) {
697             throwable = t;
698         }
699         checkException.accept(throwable);
700     }
701 
702     /**
703      * Converts to VM type signature
704      *
705      * @param type Java type to convert
706      * @return string representation of VM type
707      */
708     public static String toJVMTypeSignature(Class&lt;?&gt; type) {
709         if (type.isPrimitive()) {
710             if (type == boolean.class) {
711                 return &quot;Z&quot;;
712             } else if (type == byte.class) {
713                 return &quot;B&quot;;
714             } else if (type == char.class) {
715                 return &quot;C&quot;;
716             } else if (type == double.class) {
717                 return &quot;D&quot;;
718             } else if (type == float.class) {
719                 return &quot;F&quot;;
720             } else if (type == int.class) {
721                 return &quot;I&quot;;
722             } else if (type == long.class) {
723                 return &quot;J&quot;;
724             } else if (type == short.class) {
725                 return &quot;S&quot;;
726             } else if (type == void.class) {
727                 return &quot;V&quot;;
728             } else {
729                 throw new Error(&quot;Unsupported type: &quot; + type);
730             }
731         }
732         String result = type.getName().replaceAll(&quot;\\.&quot;, &quot;/&quot;);
733         if (!type.isArray()) {
734             return &quot;L&quot; + result + &quot;;&quot;;
735         }
736         return result;
737     }
738 
739     public static Object[] getNullValues(Class&lt;?&gt;... types) {
740         Object[] result = new Object[types.length];
741         int i = 0;
742         for (Class&lt;?&gt; type : types) {
743             result[i++] = NULL_VALUES.get(type);
744         }
745         return result;
746     }
747     private static Map&lt;Class&lt;?&gt;, Object&gt; NULL_VALUES = new HashMap&lt;&gt;();
748     static {
749         NULL_VALUES.put(boolean.class, false);
750         NULL_VALUES.put(byte.class, (byte) 0);
751         NULL_VALUES.put(short.class, (short) 0);
752         NULL_VALUES.put(char.class, &#39;\0&#39;);
753         NULL_VALUES.put(int.class, 0);
754         NULL_VALUES.put(long.class, 0L);
755         NULL_VALUES.put(float.class, 0.0f);
756         NULL_VALUES.put(double.class, 0.0d);
757     }
758 
759     /**
760      * Returns mandatory property value
761      * @param propName is a name of property to request
762      * @return a String with requested property value
763      */
764     public static String getMandatoryProperty(String propName) {
765         Objects.requireNonNull(propName, &quot;Requested null property&quot;);
766         String prop = System.getProperty(propName);
767         Objects.requireNonNull(prop,
768                 String.format(&quot;A mandatory property &#39;%s&#39; isn&#39;t set&quot;, propName));
769         return prop;
770     }
771 
772     /*
773      * Run uname with specified arguments.
774      */
775     public static OutputAnalyzer uname(String... args) throws Throwable {
776         String[] cmds = new String[args.length + 1];
777         cmds[0] = &quot;uname&quot;;
778         System.arraycopy(args, 0, cmds, 1, args.length);
779         return ProcessTools.executeCommand(cmds);
780     }
781 
782     /*
783      * Returns the system distro.
784      */
785     public static String distro() {
786         try {
787             return uname(&quot;-v&quot;).asLines().get(0);
788         } catch (Throwable t) {
789             throw new RuntimeException(&quot;Failed to determine distro.&quot;, t);
790         }
791     }
792 
793     // This method is intended to be called from a jtreg test.
794     // It will identify the name of the test by means of stack walking.
795     // It can handle both jtreg tests and a testng tests wrapped inside jtreg tests.
796     // For jtreg tests the name of the test will be searched by stack-walking
797     // until the method main() is found; the class containing that method is the
798     // main test class and will be returned as the name of the test.
799     // Special handling is used for testng tests.
800     @SuppressWarnings(&quot;unchecked&quot;)
801     public static String getTestName() {
802         String result = null;
803         // If we are using testng, then we should be able to load the &quot;Test&quot; annotation.
804         Class&lt;? extends Annotation&gt; testClassAnnotation;
805 
806         try {
807             testClassAnnotation = (Class&lt;? extends Annotation&gt;)Class.forName(&quot;org.testng.annotations.Test&quot;);
808         } catch (ClassNotFoundException e) {
809             testClassAnnotation = null;
810         }
811 
812         StackTraceElement[] elms = (new Throwable()).getStackTrace();
813         for (StackTraceElement n: elms) {
814             String className = n.getClassName();
815 
816             // If this is a &quot;main&quot; method, then use its class name, but only
817             // if we are not using testng.
818             if (testClassAnnotation == null &amp;&amp; &quot;main&quot;.equals(n.getMethodName())) {
819                 result = className;
820                 break;
821             }
822 
823             // If this is a testng test, the test will have no &quot;main&quot; method. We can
824             // detect a testng test class by looking for the org.testng.annotations.Test
825             // annotation. If present, then use the name of this class.
826             if (testClassAnnotation != null) {
827                 try {
828                     Class&lt;?&gt; c = Class.forName(className);
829                     if (c.isAnnotationPresent(testClassAnnotation)) {
830                         result = className;
831                         break;
832                     }
833                 } catch (ClassNotFoundException e) {
834                     throw new RuntimeException(&quot;Unexpected exception: &quot; + e, e);
835                 }
836             }
837         }
838 
839         if (result == null) {
840             throw new RuntimeException(&quot;Couldn&#39;t find main test class in stack trace&quot;);
841         }
842 
843         return result;
844     }
845 
846     /**
847      * Creates an empty file in &quot;user.dir&quot; if the property set.
848      * &lt;p&gt;
849      * This method is meant as a replacement for {@code Files#createTempFile(String, String, FileAttribute...)}
850      * that doesn&#39;t leave files behind in /tmp directory of the test machine
851      * &lt;p&gt;
852      * If the property &quot;user.dir&quot; is not set, &quot;.&quot; will be used.
853      *
854      * @param prefix
855      * @param suffix
856      * @param attrs
857      * @return the path to the newly created file that did not exist before this
858      *         method was invoked
859      * @throws IOException
860      *
861      * @see {@link Files#createTempFile(String, String, FileAttribute...)}
862      */
863     public static Path createTempFile(String prefix, String suffix, FileAttribute&lt;?&gt;... attrs) throws IOException {
864         Path dir = Paths.get(System.getProperty(&quot;user.dir&quot;, &quot;.&quot;));
865         return Files.createTempFile(dir, prefix, suffix);
866     }
867 
868     /**
869      * Creates an empty directory in &quot;user.dir&quot; or &quot;.&quot;
870      * &lt;p&gt;
871      * This method is meant as a replacement for {@code Files#createTempDirectory(String, String, FileAttribute...)}
872      * that doesn&#39;t leave files behind in /tmp directory of the test machine
873      * &lt;p&gt;
874      * If the property &quot;user.dir&quot; is not set, &quot;.&quot; will be used.
875      *
876      * @param prefix
877      * @param attrs
878      * @return the path to the newly created directory
879      * @throws IOException
880      *
881      * @see {@link Files#createTempDirectory(String, String, FileAttribute...)}
882      */
883     public static Path createTempDirectory(String prefix, FileAttribute&lt;?&gt;... attrs) throws IOException {
884         Path dir = Paths.get(System.getProperty(&quot;user.dir&quot;, &quot;.&quot;));
885         return Files.createTempDirectory(dir, prefix);
886     }
887 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/lib/jdk/test/lib/NetworkConfiguration.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib;
 25 
 26 import java.io.IOException;
 27 import java.io.PrintStream;
 28 import java.io.UncheckedIOException;
 29 import java.net.Inet4Address;
 30 import java.net.Inet6Address;
 31 import java.net.InetAddress;
 32 import java.net.NetworkInterface;
 33 import java.util.Arrays;
<a name="2" id="anc2"></a><span class="line-modified"> 34 import java.util.LinkedHashMap;</span>
 35 import java.util.LinkedList;
 36 import java.util.List;
 37 import java.util.Map;
<a name="3" id="anc3"></a><span class="line-added"> 38 import java.util.function.Predicate;</span>
 39 import java.util.stream.Collectors;
 40 import java.util.stream.Stream;
 41 import java.security.AccessController;
 42 import java.security.PrivilegedAction;
 43 
 44 import static java.net.NetworkInterface.getNetworkInterfaces;
 45 import static java.util.Collections.list;
 46 
 47 /**
 48  * Helper class for retrieving network interfaces and local addresses
 49  * suitable for testing.
 50  */
 51 public class NetworkConfiguration {
 52 
 53     private Map&lt;NetworkInterface,List&lt;Inet4Address&gt;&gt; ip4Interfaces;
 54     private Map&lt;NetworkInterface,List&lt;Inet6Address&gt;&gt; ip6Interfaces;
 55     private final boolean isIPv6Available;
 56     private boolean has_testableipv6address = false;
 57     private boolean has_sitelocaladdress = false;
 58     private boolean has_linklocaladdress = false;
 59     private boolean has_globaladdress = false;
 60 
 61     private NetworkConfiguration(
 62             Map&lt;NetworkInterface,List&lt;Inet4Address&gt;&gt; ip4Interfaces,
 63             Map&lt;NetworkInterface,List&lt;Inet6Address&gt;&gt; ip6Interfaces) {
 64         this.ip4Interfaces = ip4Interfaces;
 65         this.ip6Interfaces = ip6Interfaces;
 66 
 67         // initialize properties that can be queried
 68         isIPv6Available = !ip6Interfaces().collect(Collectors.toList()).isEmpty();
 69         ip6Interfaces().forEach(nif -&gt; {
 70             ip6Addresses(nif)
 71                 // On Solaris or AIX, a configuration with only local or loopback
 72                 // addresses does not fully enable IPv6 operations.
 73                 // E.g. IPv6 multicasting does not work.
 74                 // So, don&#39;t set has_testableipv6address if we only find these.
 75                 .filter(addr -&gt; Platform.isSolaris() || Platform.isAix() ?
 76                     !(addr.isAnyLocalAddress() || addr.isLoopbackAddress()) : true)
 77                 .forEach(ia -&gt; {
 78                     has_testableipv6address = true;
 79                     if (ia.isLinkLocalAddress()) has_linklocaladdress = true;
 80                     if (ia.isSiteLocalAddress()) has_sitelocaladdress = true;
 81 
 82                     if (!ia.isLinkLocalAddress() &amp;&amp;
 83                         !ia.isSiteLocalAddress() &amp;&amp;
 84                         !ia.isLoopbackAddress()) {
 85                         has_globaladdress = true;
 86                     }
 87                 });
 88         });
 89     }
 90 
<a name="4" id="anc4"></a><span class="line-modified"> 91     private static boolean isIPv6LinkLocal(InetAddress a) {</span>
<span class="line-modified"> 92         return Inet6Address.class.isInstance(a) &amp;&amp; a.isLinkLocalAddress();</span>
<span class="line-modified"> 93     }</span>
<span class="line-added"> 94 </span>
<span class="line-added"> 95     public static boolean isTestable(NetworkInterface nif) {</span>
<span class="line-added"> 96         if (Platform.isOSX()) {</span>
<span class="line-added"> 97             if (nif.getName().contains(&quot;awdl&quot;)) {</span>
<span class="line-added"> 98                 return false; // exclude awdl</span>
<span class="line-added"> 99             }</span>
<span class="line-added">100             // filter out interfaces that only have link-local addresses</span>
<span class="line-added">101             return nif.inetAddresses()</span>
<span class="line-added">102                     .filter(Predicate.not(NetworkConfiguration::isIPv6LinkLocal))</span>
<span class="line-added">103                     .findAny()</span>
<span class="line-added">104                     .isPresent();</span>
105         }
106         if (Platform.isWindows()) {
107             String dName = nif.getDisplayName();
108             if (dName != null &amp;&amp; dName.contains(&quot;Teredo&quot;)) {
109                 return false;
110             }
111         }
112         return true;
113     }
114 
115     private static boolean isNotLoopback(NetworkInterface nif) {
116         try {
117             return !nif.isLoopback();
118         } catch (IOException e) {
119             throw new UncheckedIOException(e);
120         }
121     }
122 
123     private boolean hasIp4Addresses(NetworkInterface nif) {
124         return ip4Interfaces.get(nif).stream().anyMatch(a -&gt; !a.isAnyLocalAddress());
125     }
126 
127     private boolean hasIp6Addresses(NetworkInterface nif) {
128         return ip6Interfaces.get(nif).stream().anyMatch(a -&gt; !a.isAnyLocalAddress());
129     }
130 
131     private boolean supportsIp4Multicast(NetworkInterface nif) {
132         try {
133             if (!nif.supportsMulticast()) {
134                 return false;
135             }
136 
137             // On AIX there is a bug:
138             // When IPv6 is enabled on the system, the JDK opens sockets as AF_INET6.
139             // If there&#39;s an interface configured with IPv4 addresses only, it should
140             // be able to become the network interface for a multicast socket (that
141             // could be in both, IPv4 or IPv6 space). But both possible setsockopt
142             // calls for either IPV6_MULTICAST_IF or IP_MULTICAST_IF return
143             // EADDRNOTAVAIL. So we must skip such interfaces here.
144             if (Platform.isAix() &amp;&amp; isIPv6Available() &amp;&amp; !hasIp6Addresses(nif)) {
145                 return false;
146             }
147 
148             return hasIp4Addresses(nif);
149         } catch (IOException e) {
150             throw new UncheckedIOException(e);
151         }
152     }
153 
154     private boolean supportsIp6Multicast(NetworkInterface nif) {
155         try {
156             if (!nif.supportsMulticast()) {
157                 return false;
158             }
159 
160             return hasIp6Addresses(nif);
161         } catch (IOException e) {
162             throw new UncheckedIOException(e);
163         }
164     }
165 
166     /**
167      * Returns whether IPv6 is available at all.
168      * This should resemble the result of native ipv6_available() in net_util.c
169      */
170     public boolean isIPv6Available() {
171         return isIPv6Available;
172     }
173 
174     /**
175      * Does any (usable) IPv6 address exist in the network configuration?
176      */
177     public boolean hasTestableIPv6Address() {
178         return has_testableipv6address;
179     }
180 
181     /**
182      * Does any site local address exist?
183      */
184     public boolean hasSiteLocalAddress() {
185         return has_sitelocaladdress;
186     }
187 
188     /**
189      * Does any link local address exist?
190      */
191     public boolean hasLinkLocalAddress() {
192         return has_linklocaladdress;
193     }
194 
195     /**
196      * Does any global IPv6 address exist?
197      */
198     public boolean has_globaladdress() {
199         return has_globaladdress;
200     }
201 
202     /**
203      * Returns a stream of interfaces suitable for functional tests.
204      */
205     public Stream&lt;NetworkInterface&gt; interfaces() {
206         return Stream.concat(ip4Interfaces(), ip6Interfaces())
207                      .distinct();
208     }
209 
210     /**
211      * Returns a stream of interfaces suitable for IPv4 functional tests.
212      */
213     public Stream&lt;NetworkInterface&gt; ip4Interfaces() {
214         return ip4Interfaces.keySet()
215                             .stream()
<a name="5" id="anc5"></a><span class="line-modified">216                             .filter(NetworkConfiguration::isTestable)</span>
217                             .filter(this::hasIp4Addresses);
218     }
219 
220     /**
221      * Returns a stream of interfaces suitable for IPv6 functional tests.
222      */
223     public Stream&lt;NetworkInterface&gt; ip6Interfaces() {
224         return ip6Interfaces.keySet()
225                             .stream()
<a name="6" id="anc6"></a><span class="line-modified">226                             .filter(NetworkConfiguration::isTestable)</span>
227                             .filter(this::hasIp6Addresses);
228     }
229 
230     /**
231      * Returns a stream of interfaces suitable for functional tests.
232      */
233     public Stream&lt;NetworkInterface&gt; multicastInterfaces(boolean includeLoopback) {
234         return Stream
235             .concat(ip4MulticastInterfaces(includeLoopback),
236                     ip6MulticastInterfaces(includeLoopback))
237             .distinct();
238     }
239 
240     /**
241      * Returns a stream of interfaces suitable for IPv4 multicast tests.
242      *
243      * The loopback interface will not be included.
244      */
245     public Stream&lt;NetworkInterface&gt; ip4MulticastInterfaces() {
246         return ip4MulticastInterfaces(false);
247     }
248 
249     /**
250      * Returns a stream of interfaces suitable for IPv4 multicast tests.
251      */
252     public Stream&lt;NetworkInterface&gt; ip4MulticastInterfaces(boolean includeLoopback) {
253         return (includeLoopback) ?
254             ip4Interfaces().filter(this::supportsIp4Multicast) :
255             ip4Interfaces().filter(this::supportsIp4Multicast)
256                 .filter(NetworkConfiguration::isNotLoopback);
257     }
258 
259     /**
260      * Returns a stream of interfaces suitable for IPv6 multicast tests.
261      *
262      * The loopback interface will not be included.
263      */
264     public Stream&lt;NetworkInterface&gt; ip6MulticastInterfaces() {
265         return ip6MulticastInterfaces(false);
266     }
267 
268     /**
269      * Returns a stream of interfaces suitable for IPv6 multicast tests.
270      */
271     public Stream&lt;NetworkInterface&gt; ip6MulticastInterfaces(boolean includeLoopback) {
272         return (includeLoopback) ?
273             ip6Interfaces().filter(this::supportsIp6Multicast) :
274             ip6Interfaces().filter(this::supportsIp6Multicast)
275                 .filter(NetworkConfiguration::isNotLoopback);
276     }
277 
278     /**
279      * Returns all addresses on all &quot;functional&quot; interfaces.
280      */
281     public Stream&lt;InetAddress&gt; addresses(NetworkInterface nif) {
282         return Stream.concat(ip4Interfaces.get(nif).stream(),
283                              ip6Interfaces.get(nif).stream());
284     }
285 
286     /**
287      * Returns all IPv4 addresses on all &quot;functional&quot; interfaces.
288      */
289     public Stream&lt;Inet4Address&gt; ip4Addresses() {
290         return ip4Interfaces().flatMap(this::ip4Addresses);
291     }
292 
293     /**
294      * Returns all IPv6 addresses on all &quot;functional&quot; interfaces.
295      */
296     public Stream&lt;Inet6Address&gt; ip6Addresses() {
297         return ip6Interfaces().flatMap(this::ip6Addresses);
298     }
299 
300     /**
301      * Returns all IPv4 addresses the given interface.
302      */
303     public Stream&lt;Inet4Address&gt; ip4Addresses(NetworkInterface nif) {
304         return ip4Interfaces.get(nif).stream();
305     }
306 
307     /**
308      * Returns all IPv6 addresses for the given interface.
309      */
310     public Stream&lt;Inet6Address&gt; ip6Addresses(NetworkInterface nif) {
311         return ip6Interfaces.get(nif).stream();
312     }
313 
314     @Override
315     public String toString() {
316         return interfaces().map(NetworkConfiguration::interfaceInformation)
317                            .collect(Collectors.joining());
318     }
319 
320     /**
321      * Return a NetworkConfiguration instance.
322      */
323     public static NetworkConfiguration probe() throws IOException {
<a name="7" id="anc7"></a><span class="line-modified">324         Map&lt;NetworkInterface, List&lt;Inet4Address&gt;&gt; ip4Interfaces = new LinkedHashMap&lt;&gt;();</span>
<span class="line-modified">325         Map&lt;NetworkInterface, List&lt;Inet6Address&gt;&gt; ip6Interfaces = new LinkedHashMap&lt;&gt;();</span>
326 
327         List&lt;NetworkInterface&gt; nifs = list(getNetworkInterfaces());
328         for (NetworkInterface nif : nifs) {
329             // ignore interfaces that are down
330             if (!nif.isUp() || nif.isPointToPoint()) {
331                 continue;
332             }
333 
334             List&lt;Inet4Address&gt; ip4Addresses = new LinkedList&lt;&gt;();
335             List&lt;Inet6Address&gt; ip6Addresses = new LinkedList&lt;&gt;();
336             ip4Interfaces.put(nif, ip4Addresses);
337             ip6Interfaces.put(nif, ip6Addresses);
338             for (InetAddress addr : list(nif.getInetAddresses())) {
339                 if (addr instanceof Inet4Address) {
340                     ip4Addresses.add((Inet4Address) addr);
341                 } else if (addr instanceof Inet6Address) {
342                     ip6Addresses.add((Inet6Address) addr);
343                 }
344             }
345         }
346         return new NetworkConfiguration(ip4Interfaces, ip6Interfaces);
347     }
348 
349     /** Returns detailed information for the given interface. */
350     public static String interfaceInformation(NetworkInterface nif) {
351         StringBuilder sb = new StringBuilder();
352         try {
353             sb.append(&quot;Display name: &quot;)
354               .append(nif.getDisplayName())
355               .append(&quot;\n&quot;);
356             sb.append(&quot;Name: &quot;)
357               .append(nif.getName())
358               .append(&quot;\n&quot;);
359             for (InetAddress inetAddress : list(nif.getInetAddresses())) {
360                 sb.append(&quot;InetAddress: &quot;)
361                   .append(inetAddress)
362                   .append(&quot;\n&quot;);
363             }
364             sb.append(&quot;Up? &quot;)
365               .append(nif.isUp())
366               .append(&quot;\n&quot;);
367             sb.append(&quot;Loopback? &quot;)
368               .append(nif.isLoopback())
369               .append(&quot;\n&quot;);
370             sb.append(&quot;PointToPoint? &quot;)
371               .append(nif.isPointToPoint())
372               .append(&quot;\n&quot;);
373             sb.append(&quot;Supports multicast? &quot;)
374               .append(nif.supportsMulticast())
375               .append(&quot;\n&quot;);
376             sb.append(&quot;Virtual? &quot;)
377               .append(nif.isVirtual())
378               .append(&quot;\n&quot;);
379             sb.append(&quot;Hardware address: &quot;)
380               .append(Arrays.toString(nif.getHardwareAddress()))
381               .append(&quot;\n&quot;);
382             sb.append(&quot;MTU: &quot;)
383               .append(nif.getMTU())
384               .append(&quot;\n&quot;);
385             sb.append(&quot;Index: &quot;)
386               .append(nif.getIndex())
387               .append(&quot;\n&quot;);
388             sb.append(&quot;\n&quot;);
389             return sb.toString();
390         } catch (IOException e) {
391             throw new UncheckedIOException(e);
392         }
393     }
394 
395     /** Prints all the system interface information to the give stream. */
396     public static void printSystemConfiguration(PrintStream out) {
397         PrivilegedAction&lt;Void&gt; pa = () -&gt; {
398         try {
399             out.println(&quot;*** all system network interface configuration ***&quot;);
400             for (NetworkInterface nif : list(getNetworkInterfaces())) {
401                 out.print(interfaceInformation(nif));
402             }
403             out.println(&quot;*** end ***&quot;);
404             return null;
405         } catch (IOException e) {
406             throw new UncheckedIOException(e);
407         }};
408         AccessController.doPrivileged(pa);
409     }
410 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
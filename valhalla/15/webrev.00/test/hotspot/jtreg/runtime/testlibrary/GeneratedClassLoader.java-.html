<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/hotspot/jtreg/runtime/testlibrary/GeneratedClassLoader.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 import java.io.DataInputStream;
 25 import java.io.ByteArrayOutputStream;
 26 import java.io.File;
 27 import java.io.FileInputStream;
 28 import java.io.FileWriter;
 29 import java.io.IOException;
 30 import java.io.PrintWriter;
 31 import javax.tools.JavaCompiler;
 32 import javax.tools.ToolProvider;
 33 
 34 /**
 35  * A class loader that generates new classes.
 36  * The generated classes are made by first emitting java sources with nested
 37  * static classes, these are then compiled and the class files are read back.
 38  * Some efforts are made to make the class instances unique and of not insignificant
 39  * size.
 40  */
 41 public class GeneratedClassLoader extends ClassLoader {
 42     /**
 43      * Holds a pair of class bytecodes and class name (for use with defineClass).
 44      */
 45     private static class GeneratedClass {
 46         public byte[] bytes;
 47         public String name;
 48         public GeneratedClass(byte[] bytes, String name) {
 49             this.bytes = bytes; this.name = name;
 50         }
 51     }
 52 
 53     /**
 54      * Used to uniquely name every class generated.
 55      */
 56     private static int count = 0;
 57     /**
 58      * Used to enable/disable keeping the class files and java sources for
 59      * the generated classes.
 60      */
 61     private static boolean deleteFiles = Boolean.parseBoolean(
 62         System.getProperty(&quot;GeneratedClassLoader.deleteFiles&quot;, &quot;true&quot;));
 63 
 64     private static String bigstr =
 65         &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit. &quot;
 66         + &quot;In facilisis scelerisque vehicula. Donec congue nisi a &quot;
 67         + &quot;leo posuere placerat lobortis felis ultrices. Pellentesque &quot;
 68         + &quot;habitant morbi tristique senectus et netus et malesuada &quot;
 69         + &quot;fames ac turpis egestas. Nam tristique velit at felis &quot;
 70         + &quot;iaculis at tempor sem vestibulum. Sed adipiscing lectus &quot;
 71         + &quot;non mi molestie sagittis. Morbi eu purus urna. Nam tempor &quot;
 72         + &quot;tristique massa eget semper. Mauris cursus, nulla et ornare &quot;
 73         + &quot;vehicula, leo dolor scelerisque metus, sit amet rutrum erat &quot;
 74         + &quot;sapien quis dui. Nullam eleifend risus et velit accumsan sed &quot;
 75         + &quot;suscipit felis pulvinar. Nullam faucibus suscipit gravida. &quot;
 76         + &quot;Pellentesque habitant morbi tristique senectus et netus et &quot;
 77         + &quot;malesuada fames ac turpis egestas. Nullam ut massa augue, &quot;
 78         + &quot;nec viverra mauris.&quot;;
 79 
 80     private static int getNextCount() {
 81         return count++;
 82     }
 83 
 84     ////// end statics
 85 
 86     private JavaCompiler javac;
 87     private String nameBase;
 88 
 89     public GeneratedClassLoader() {
 90         javac = ToolProvider.getSystemJavaCompiler();
 91         nameBase = &quot;TestSimpleClass&quot;;
 92     }
 93 
 94     private long getBigValue(int which) {
 95         // &gt; 65536 is too large to encode in the bytecode
 96         // so this will force us to emit a constant pool entry for this int
 97         return (long)which + 65537;
 98     }
 99 
100     private String getBigString(int which) {
101         return bigstr + which;
102     }
103 
104     private String getClassName(int count) {
105         return nameBase + count;
106     }
107 
108     private String generateSource(int count, int sizeFactor, int numClasses) {
109         StringBuilder sb = new StringBuilder();
110         sb.append(&quot;public class &quot;).append(getClassName(count)).append(&quot;{\n&quot;);
111         for (int j = 0; j &lt; numClasses; ++j) {
112             sb.append(&quot;public static class &quot;)
113               .append(&quot;Class&quot;)
114               .append(j)
115               .append(&quot;{\n&quot;);
116             for (int i = 0; i &lt; sizeFactor; ++i) {
117                 int value = i;
118                 sb.append(&quot;private long field&quot;)
119                   .append(i).append(&quot; = &quot;)
120                   .append(getBigValue(value++))
121                   .append(&quot;;\n&quot;);
122                 sb.append(&quot;public long method&quot;)
123                   .append(i)
124                   .append(&quot;() {\n&quot;);
125                 sb.append(&quot;return &quot;)
126                   .append(getBigValue(value++))
127                   .append(&quot;;&quot;);
128                 sb.append(&quot;}\n&quot;);
129                 sb.append(&quot;private String str&quot;).append(i)
130                   .append(&quot; = \&quot;&quot;)
131                   .append(getBigString(i))
132                   .append(&quot;\&quot;;&quot;);
133             }
134             sb.append(&quot;\n}&quot;);
135         }
136         sb.append(&quot;\n}&quot;);
137         return sb.toString();
138     }
139 
140     private GeneratedClass[] getGeneratedClass(int sizeFactor, int numClasses) throws IOException {
141         int uniqueCount = getNextCount();
142         String src = generateSource(uniqueCount, sizeFactor, numClasses);
143         String className = getClassName(uniqueCount);
144         File file = new File(className + &quot;.java&quot;);
145         try (PrintWriter pw = new PrintWriter(new FileWriter(file))) {
146             pw.append(src);
147             pw.flush();
148         }
149         ByteArrayOutputStream err = new ByteArrayOutputStream();
150         int exitcode = javac.run(null, null, err, file.getCanonicalPath());
151         if (exitcode != 0) {
152             // Print Error
153             System.err.print(err);
154             if (err.toString().contains(&quot;java.lang.OutOfMemoryError: Java heap space&quot;)) {
155               throw new OutOfMemoryError(&quot;javac failed with resources exhausted&quot;);
156             } else {
157               throw new RuntimeException(&quot;javac failure when compiling: &quot; +
158                       file.getCanonicalPath());
159             }
160         } else {
161             if (deleteFiles) {
162                 file.delete();
163             }
164         }
165         GeneratedClass[] gc = new GeneratedClass[numClasses];
166         for (int i = 0; i &lt; numClasses; ++i) {
167             String name = className + &quot;$&quot; + &quot;Class&quot; + i;
168             File classFile = new File(name + &quot;.class&quot;);
169             byte[] bytes;
170             try (DataInputStream dis = new DataInputStream(new FileInputStream(classFile))) {
171                 bytes = new byte[dis.available()];
172                 dis.readFully(bytes);
173             }
174             if (deleteFiles) {
175                 classFile.delete();
176             }
177             gc[i] = new GeneratedClass(bytes, name);
178         }
179         if (deleteFiles) {
180             new File(className + &quot;.class&quot;).delete();
181         }
182         return gc;
183     }
184 
185     /**
186      * Generate a single class, compile it and load it.
187      * @param sizeFactor Fuzzy measure of how large the class should be.
188      * @return the Class instance.
189      * @throws IOException
190      */
191     public Class&lt;?&gt; generateClass(int sizeFactor) throws IOException {
192         return getGeneratedClasses(sizeFactor, 1)[0];
193     }
194 
195     /**
196      * Generate several classes, compile and load them.
197      * @param sizeFactor Fuzzy measure of how large each class should be.
198      * @param numClasses The number of classes to create
199      * @return an array of the Class instances.
200      * @throws IOException
201      */
202     public Class&lt;?&gt;[] getGeneratedClasses(int sizeFactor, int numClasses) throws IOException {
203         GeneratedClass[] gc = getGeneratedClass(sizeFactor, numClasses);
204         Class&lt;?&gt;[] classes = new Class[numClasses];
205         for (int i = 0; i &lt; numClasses; ++i) {
206             classes[i] = defineClass(gc[i].name, gc[i].bytes, 0 , gc[i].bytes.length);
207         }
208         return classes;
209     }
210 }
    </pre>
  </body>
</html>
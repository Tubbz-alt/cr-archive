<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/langtools/tools/javac/records/RecordCompilationTests.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /**
 27  * RecordCompilationTests
 28  *
 29  * @test
 30  * @summary Negative compilation tests, and positive compilation (smoke) tests for records
 31  * @library /lib/combo /tools/lib /tools/javac/lib
 32  * @modules
 33  *      jdk.compiler/com.sun.tools.javac.api
 34  *      jdk.compiler/com.sun.tools.javac.code
 35  *      jdk.compiler/com.sun.tools.javac.util
 36  *      jdk.jdeps/com.sun.tools.classfile
 37  * @build JavacTestingAbstractProcessor
 38  * @compile --enable-preview -source ${jdk.version} RecordCompilationTests.java
 39  * @run testng/othervm --enable-preview RecordCompilationTests
 40  */
 41 
 42 import java.io.File;
 43 
 44 import java.lang.annotation.ElementType;
 45 import java.util.Arrays;
 46 import java.util.EnumMap;
 47 import java.util.EnumSet;
 48 import java.util.HashSet;
 49 import java.util.List;
 50 import java.util.Map;
 51 import java.util.Set;
 52 import java.util.stream.Collectors;
 53 import java.util.stream.Stream;
 54 
 55 
 56 import com.sun.tools.javac.util.Assert;
 57 
 58 import javax.annotation.processing.RoundEnvironment;
 59 import javax.annotation.processing.SupportedAnnotationTypes;
 60 
 61 import javax.lang.model.element.AnnotationMirror;
 62 import javax.lang.model.element.AnnotationValue;
 63 import javax.lang.model.element.Element;
 64 import javax.lang.model.element.ElementKind;
 65 import javax.lang.model.element.ExecutableElement;
 66 import javax.lang.model.element.RecordComponentElement;
 67 import javax.lang.model.element.TypeElement;
 68 import javax.lang.model.element.VariableElement;
 69 
 70 import javax.lang.model.type.ArrayType;
 71 import javax.lang.model.type.TypeMirror;
 72 
 73 import com.sun.tools.classfile.Annotation;
 74 import com.sun.tools.classfile.Attribute;
 75 import com.sun.tools.classfile.Attributes;
 76 import com.sun.tools.classfile.ClassFile;
 77 import com.sun.tools.classfile.ConstantPool;
 78 import com.sun.tools.classfile.ConstantPool.CPInfo;
 79 import com.sun.tools.classfile.Field;
 80 import com.sun.tools.classfile.Method;
 81 import com.sun.tools.classfile.Record_attribute;
 82 import com.sun.tools.classfile.Record_attribute.ComponentInfo;
 83 import com.sun.tools.classfile.RuntimeAnnotations_attribute;
 84 import com.sun.tools.classfile.RuntimeTypeAnnotations_attribute;
 85 import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;
 86 import com.sun.tools.classfile.RuntimeVisibleParameterAnnotations_attribute;
 87 import com.sun.tools.classfile.RuntimeVisibleTypeAnnotations_attribute;
 88 import com.sun.tools.classfile.TypeAnnotation;
 89 
 90 import com.sun.tools.javac.api.ClientCodeWrapper.DiagnosticSourceUnwrapper;
 91 import com.sun.tools.javac.code.Attribute.TypeCompound;
 92 import com.sun.tools.javac.code.Symbol;
 93 import com.sun.tools.javac.code.Symbol.VarSymbol;
 94 import com.sun.tools.javac.util.JCDiagnostic;
 95 
 96 import org.testng.annotations.Test;
 97 import tools.javac.combo.CompilationTestCase;
 98 
 99 import static java.lang.annotation.ElementType.*;
100 import static org.testng.Assert.assertEquals;
101 
102 @Test
103 public class RecordCompilationTests extends CompilationTestCase {
104 
105     // @@@ When records become a permanent feature, we don&#39;t need these any more
106     private static String[] PREVIEW_OPTIONS = {&quot;--enable-preview&quot;, &quot;-source&quot;,
107                                                Integer.toString(Runtime.version().feature())};
108 
109     private static final List&lt;String&gt; BAD_COMPONENT_NAMES = List.of(
110             &quot;clone&quot;, &quot;finalize&quot;, &quot;getClass&quot;, &quot;hashCode&quot;,
111             &quot;notify&quot;, &quot;notifyAll&quot;, &quot;toString&quot;, &quot;wait&quot;);
112 
113     {
114         setDefaultFilename(&quot;R.java&quot;);
115         setCompileOptions(PREVIEW_OPTIONS);
116     }
117 
118     public void testMalformedDeclarations() {
119         assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R()&quot;);
120         assertFail(&quot;compiler.err.premature.eof&quot;, &quot;record R();&quot;);
121         assertFail(&quot;compiler.err.illegal.start.of.type&quot;, &quot;record R(,) { }&quot;);
122         assertFail(&quot;compiler.err.illegal.start.of.type&quot;, &quot;record R((int x)) { }&quot;);
123         assertFail(&quot;compiler.err.record.header.expected&quot;, &quot;record R { }&quot;);
124         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(foo) { }&quot;);
125         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int int) { }&quot;);
126         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;abstract record R(String foo) { }&quot;);
127         //assertFail(&quot;compiler.err.illegal.combination.of.modifiers&quot;, &quot;non-sealed record R(String foo) { }&quot;);
128         assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;public public record R(String foo) { }&quot;);
129         assertFail(&quot;compiler.err.repeated.modifier&quot;, &quot;private private record R(String foo) { }&quot;);
130         assertFail(&quot;compiler.err.already.defined&quot;, &quot;record R(int x, int x) {}&quot;);
131         for (String s : List.of(&quot;var&quot;, &quot;record&quot;))
132             assertFail(&quot;compiler.err.restricted.type.not.allowed.here&quot;, &quot;record R(# x) { }&quot;, s);
133         for (String s : List.of(&quot;public&quot;, &quot;private&quot;, &quot;volatile&quot;, &quot;final&quot;))
134             assertFail(&quot;compiler.err.record.cant.declare.field.modifiers&quot;, &quot;record R(# String foo) { }&quot;, s);
135         assertFail(&quot;compiler.err.varargs.must.be.last&quot;, &quot;record R(int... x, int... y) {}&quot;);
136         assertFail(&quot;compiler.err.instance.initializer.not.allowed.in.records&quot;, &quot;record R(int i) { {} }&quot;);
137     }
138 
139     public void testGoodDeclarations() {
140         assertOK(&quot;public record R() { }&quot;);
141         assertOK(&quot;record R() { }&quot;);
142         assertOK(&quot;record R() implements java.io.Serializable, Runnable { public void run() { } }&quot;);
143         assertOK(&quot;record R(int x) { }&quot;);
144         assertOK(&quot;record R(int x, int y) { }&quot;);
145         assertOK(&quot;record R(int... xs) { }&quot;);
146         assertOK(&quot;record R(String... ss) { }&quot;);
147         assertOK(&quot;@Deprecated record R(int x, int y) { }&quot;);
148         assertOK(&quot;record R(@Deprecated int x, int y) { }&quot;);
149         assertOK(&quot;record R&lt;T&gt;(T x, T y) { }&quot;);
150     }
151 
152     public void testGoodMemberDeclarations() {
153         String template = &quot;public record R(int x) {\n&quot;
154                 + &quot;    public R(int x) { this.x = x; }\n&quot;
155                 + &quot;    public int x() { return x; }\n&quot;
156                 + &quot;    public boolean equals(Object o) { return true; }\n&quot;
157                 + &quot;    public int hashCode() { return 0; }\n&quot;
158                 + &quot;    public String toString() { return null; }\n&quot;
159                 + &quot;}&quot;;
160         assertOK(template);
161     }
162 
163     public void testBadComponentNames() {
164         for (String s : BAD_COMPONENT_NAMES)
165             assertFail(&quot;compiler.err.illegal.record.component.name&quot;, &quot;record R(int #) { } &quot;, s);
166     }
167 
168     public void testRestrictedIdentifiers() {
169         for (String s : List.of(&quot;interface record { void m(); }&quot;,
170                 &quot;@interface record { }&quot;,
171                 &quot;class record { }&quot;,
172                 &quot;record record(int x) { }&quot;,
173                 &quot;enum record { A, B }&quot;,
174                 &quot;class R&lt;record&gt; { }&quot;)) {
175             assertFail(
176                     &quot;compiler.err.restricted.type.not.allowed&quot;,
177                     diagWrapper -&gt; {
178                         JCDiagnostic diagnostic = ((DiagnosticSourceUnwrapper)diagWrapper).d;
179                         Object[] args = diagnostic.getArgs();
180                         Assert.check(args.length == 2);
181                         Assert.check(args[1].toString().equals(&quot;JDK14&quot;));
182                     },
183                     s);
184         }
185     }
186 
187     public void testValidMembers() {
188         for (String s : List.of(&quot;record X(int j) { }&quot;,
189                 &quot;interface I { }&quot;,
190                 &quot;static { }&quot;,
191                 &quot;enum E { A, B }&quot;,
192                 &quot;class C { }&quot;
193         )) {
194             assertOK(&quot;record R(int i) { # }&quot;, s);
195         }
196     }
197 
198     public void testCyclic() {
199         // Cyclic records are OK, but cyclic inline records would not be
200         assertOK(&quot;record R(R r) { }&quot;);
201     }
202 
203     public void testBadExtends() {
204         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int x) extends Object { }&quot;);
205         assertFail(&quot;compiler.err.expected&quot;, &quot;record R(int x) {}\n&quot;
206                 + &quot;record R2(int x) extends R { }&quot;);
207         assertFail(&quot;compiler.err.cant.inherit.from.final&quot;, &quot;record R(int x) {}\n&quot;
208                 + &quot;class C extends R { }&quot;);
209     }
210 
211     public void testNoExtendRecord() {
212         assertFail(&quot;compiler.err.invalid.supertype.record&quot;,
213                    &quot;class R extends Record { public String toString() { return null; } public int hashCode() { return 0; } public boolean equals(Object o) { return false; } } }&quot;);
214     }
215 
216     public void testFieldDeclarations() {
217         // static fields are OK
218         assertOK(&quot;public record R(int x) {\n&quot; +
219                 &quot;    static int I = 1;\n&quot; +
220                 &quot;    static final String S = \&quot;Hello World!\&quot;;\n&quot; +
221                 &quot;    static private Object O = null;\n&quot; +
222                 &quot;    static protected Object O2 = null;\n&quot; +
223                 &quot;}&quot;);
224 
225         // instance fields are not
226         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
227                 &quot;public record R(int x) {\n&quot; +
228                         &quot;    private final int y = 0;&quot; +
229                         &quot;}&quot;);
230 
231         // mutable instance fields definitely not
232         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
233                 &quot;public record R(int x) {\n&quot; +
234                         &quot;    private int y = 0;&quot; +
235                         &quot;}&quot;);
236 
237         // redeclaring components also not
238         assertFail(&quot;compiler.err.record.cannot.declare.instance.fields&quot;,
239                 &quot;public record R(int x) {\n&quot; +
240                         &quot;    private final int x;&quot; +
241                         &quot;}&quot;);
242     }
243 
244     public void testAccessorRedeclaration() {
245         assertOK(&quot;public record R(int x) {\n&quot; +
246                 &quot;    public int x() { return x; };&quot; +
247                 &quot;}&quot;);
248 
249         assertOK(&quot;public record R(int x) {\n&quot; +
250                 &quot;    public final int x() { return 0; };&quot; +
251                 &quot;}&quot;);
252 
253         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
254                 &quot;public record R(int x) {\n&quot; +
255                         &quot;    final int x() { return 0; };&quot; +
256                         &quot;}&quot;);
257 
258         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
259                 &quot;public record R(int x) {\n&quot; +
260                         &quot;    int x() { return 0; };&quot; +
261                         &quot;}&quot;);
262 
263         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
264                 &quot;public record R(int x) {\n&quot; +
265                         &quot;    private int x() { return 0; };&quot; +
266                         &quot;}&quot;);
267 
268         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
269                    &quot;public record R(int x) {\n&quot; +
270                    &quot;    public int x() throws Exception { return 0; };&quot; +
271                    &quot;}&quot;);
272 
273         for (String s : List.of(&quot;List&quot;, &quot;List&lt;?&gt;&quot;, &quot;Object&quot;, &quot;ArrayList&lt;String&gt;&quot;, &quot;int&quot;))
274             assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
275                     &quot;import java.util.*;\n&quot; +
276                             &quot;public record R(List&lt;String&gt; x) {\n&quot; +
277                             &quot;    public # x() { return null; };&quot; +
278                             &quot;}&quot;, s);
279 
280         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
281                 &quot;public record R(int x) {\n&quot; +
282                         &quot;    public &lt;T&gt; int x() { return x; };&quot; +
283                         &quot;}&quot;);
284 
285         assertFail(&quot;compiler.err.invalid.accessor.method.in.record&quot;,
286                 &quot;public record R(int x) {\n&quot; +
287                         &quot;    static private final j = 0;&quot; +
288                         &quot;    static public int x() { return j; };&quot; +
289                         &quot;}&quot;);
290     }
291 
292     public void testConstructorRedeclaration() {
293         for (String goodCtor : List.of(
294                 &quot;public R(int x) { this(x, 0); }&quot;,
295                 &quot;public R(int x, int y) { this.x = x; this.y = y; }&quot;,
296                 &quot;public R { }&quot;,
297                 &quot;public R { this.x = 0; }&quot;))
298             assertOK(&quot;record R(int x, int y) { # }&quot;, goodCtor);
299 
300         assertOK(&quot;import java.util.*; record R(String x, String y) {  public R { Objects.requireNonNull(x); Objects.requireNonNull(y); } }&quot;);
301 
302         // Not OK to redeclare canonical without DA
303         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;, &quot;record R(int x, int y) { # }&quot;,
304                    &quot;public R(int x, int y) { this.x = x; }&quot;);
305 
306         // Not OK to rearrange or change names
307         for (String s : List.of(&quot;public R(int y, int x) { this.x = x; this.y = y; }&quot;,
308                                 &quot;public R(int _x, int _y) { this.x = _x; this.y = _y; }&quot;))
309             assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x, int y) { # }&quot;, s);
310 
311         // canonical ctor must be public
312         for (String s : List.of(&quot;&quot;, &quot;protected&quot;, &quot;private&quot;))
313             assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x, int y) { # }&quot;,
314                        &quot;# R(int x, int y) { this.x = x; this.y = y; }&quot;,
315                        s);
316 
317         // ctor args must match types
318         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
319                 &quot;import java.util.*;\n&quot; +
320                         &quot;record R(List&lt;String&gt; list) { # }&quot;,
321                 &quot;R(List list) { this.list = list; }&quot;);
322 
323         // canonical ctor should not throw checked exceptions
324         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
325                    &quot;record R() { # }&quot;,
326                    &quot;public R() throws Exception { }&quot;);
327 
328         // same for compact
329         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
330                 &quot;record R() { # }&quot;,
331                 &quot;public R throws Exception { }&quot;);
332 
333         // not even unchecked exceptions
334         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
335                 &quot;record R() { # }&quot;,
336                  &quot;public R() throws IllegalArgumentException { }&quot;);
337 
338         // ditto
339         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
340                 &quot;record R() { # }&quot;,
341                 &quot;public R throws IllegalArgumentException { }&quot;);
342 
343         // If types match, names must match
344         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
345                    &quot;record R(int x, int y) { public R(int y, int x) { this.x = this.y = 0; }}&quot;);
346 
347         // first invocation should be one to the canonical
348         assertFail(&quot;compiler.err.first.statement.must.be.call.to.another.constructor&quot;,
349                 &quot;record R(int x, int y) { public R(int y, int x, int z) { this.x = this.y = 0; } }&quot;);
350 
351         assertOK(&quot;record R(int x, int y) { &quot; +
352                  &quot;    public R(int x, int y, int z) { this(x, y); } &quot; +
353                  &quot;}&quot;);
354 
355         assertOK(&quot;record R(int x) { &quot; +
356                 &quot;    public R(int x, int y) { this(x, y, 0); } &quot; +
357                 &quot;    public R(int x, int y, int z) { this(x); } &quot; +
358                 &quot;}&quot;);
359 
360         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
361                 &quot;record R&lt;T&gt;(T a) { # }&quot;,
362                 &quot;public &lt;T&gt; R {}&quot;);
363 
364         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
365                 &quot;record R(int i) { # }&quot;,
366                 &quot;public &lt;T&gt; R(int i) { this.i = i; }&quot;);
367 
368         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
369                 &quot;record R&lt;T&gt;(T a) { # }&quot;,
370                 &quot;public &lt;T&gt; R(T a) { this.a = a; }&quot;);
371 
372         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;,
373                 &quot;record R(int a) { # }&quot;,
374                 &quot;public R(int a) { super(); this.a = a; }&quot;);
375     }
376 
377     public void testAnnotationCriteria() {
378         String imports = &quot;import java.lang.annotation.*;\n&quot;;
379         String template = &quot;@Target({ # }) @interface A {}\n&quot;;
380         EnumMap&lt;ElementType, String&gt; annotations = new EnumMap&lt;&gt;(ElementType.class);
381         for (ElementType e : values())
382             annotations.put(e, template.replace(&quot;#&quot;, &quot;ElementType.&quot; + e.name()));
383         EnumSet&lt;ElementType&gt; goodSet = EnumSet.of(RECORD_COMPONENT, FIELD, METHOD, PARAMETER, TYPE_USE);
384         EnumSet&lt;ElementType&gt; badSet = EnumSet.of(CONSTRUCTOR, PACKAGE, TYPE, LOCAL_VARIABLE, ANNOTATION_TYPE, TYPE_PARAMETER, MODULE);
385 
386         assertEquals(goodSet.size() + badSet.size(), values().length);
387         String A_GOOD = template.replace(&quot;#&quot;,
388                                          goodSet.stream().map(ElementType::name).map(s -&gt; &quot;ElementType.&quot; + s).collect(Collectors.joining(&quot;,&quot;)));
389         String A_BAD = template.replace(&quot;#&quot;,
390                                         badSet.stream().map(ElementType::name).map(s -&gt; &quot;ElementType.&quot; + s).collect(Collectors.joining(&quot;,&quot;)));
391         String A_ALL = template.replace(&quot;#&quot;,
392                                         Stream.of(ElementType.values()).map(ElementType::name).map(s -&gt; &quot;ElementType.&quot; + s).collect(Collectors.joining(&quot;,&quot;)));
393         String A_NONE = &quot;@interface A {}&quot;;
394 
395         for (ElementType e : goodSet)
396             assertOK(imports + annotations.get(e) + &quot;record R(@A int x) { }&quot;);
397         assertOK(imports + A_GOOD + &quot;record R(@A int x) { }&quot;);
398         assertOK(imports + A_ALL + &quot;record R(@A int x) { }&quot;);
399         assertOK(imports + A_NONE);
400 
401         for (ElementType e : badSet) {
402             assertFail(&quot;compiler.err.annotation.type.not.applicable&quot;, imports + annotations.get(e) + &quot;record R(@A int x) { }&quot;);
403         }
404 
405         assertFail(&quot;compiler.err.annotation.type.not.applicable&quot;, imports + A_BAD + &quot;record R(@A int x) { }&quot;);
406 
407         // TODO: OK to redeclare with or without same annos
408     }
409 
410     public void testNestedRecords() {
411         String template = &quot;class R { \n&quot; +
412                           &quot;    # record RR(int a) { }\n&quot; +
413                           &quot;}&quot;;
414 
415         for (String s : List.of(&quot;&quot;, &quot;static&quot;, &quot;final&quot;,
416                                 &quot;private&quot;, &quot;public&quot;, &quot;protected&quot;,
417                                 &quot;private static&quot;, &quot;public static&quot;, &quot;private static final&quot;))
418             assertOK(template, s);
419 
420         for (String s : List.of(&quot;class C { }&quot;,
421                                 &quot;static class C { }&quot;,
422                                 &quot;enum X { A; }&quot;,
423                                 &quot;interface I { }&quot;,
424                                 &quot;record RR(int y) { }&quot;))
425             assertOK(&quot;record R(int x) { # }&quot;, s);
426     }
427 
428     public void testDuplicatedMember() {
429         String template
430                 = &quot;    record R(int i) {\n&quot; +
431                   &quot;        public int i() { return i; }\n&quot; +
432                   &quot;        public int i() { return i; }\n&quot; +
433                   &quot;    }&quot;;
434         assertFail(&quot;compiler.err.already.defined&quot;, template);
435     }
436 
437     public void testLocalRecords() {
438         assertOK(&quot;class R { \n&quot; +
439                 &quot;    void m() { \n&quot; +
440                 &quot;        record RR(int x) { };\n&quot; +
441                 &quot;    }\n&quot; +
442                 &quot;}&quot;);
443 
444         // local records can also be final
445         assertOK(&quot;class R { \n&quot; +
446                 &quot;    void m() { \n&quot; +
447                 &quot;        final record RR(int x) { };\n&quot; +
448                 &quot;    }\n&quot; +
449                 &quot;}&quot;);
450 
451         // Cant capture locals
452         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
453                 &quot;class R { \n&quot; +
454                         &quot;    void m(int y) { \n&quot; +
455                         &quot;        record RR(int x) { public int x() { return y; }};\n&quot; +
456                         &quot;    }\n&quot; +
457                         &quot;}&quot;);
458 
459         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
460                 &quot;class R { \n&quot; +
461                         &quot;    void m() {\n&quot; +
462                         &quot;        int y;\n&quot; +
463                         &quot;        record RR(int x) { public int x() { return y; }};\n&quot; +
464                         &quot;    }\n&quot; +
465                         &quot;}&quot;);
466 
467         // instance fields
468         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
469                 &quot;class R { \n&quot; +
470                         &quot;    int z = 0;\n&quot; +
471                         &quot;    void m() { \n&quot; +
472                         &quot;        record RR(int x) { public int x() { return z; }};\n&quot; +
473                         &quot;    }\n&quot; +
474                         &quot;}&quot;);
475 
476         // or type variables
477         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
478                 &quot;class R&lt;T&gt; { \n&quot; +
479                         &quot;    void m() { \n&quot; +
480                         &quot;        record RR(T t) {};\n&quot; +
481                         &quot;    }\n&quot; +
482                         &quot;}&quot;);
483 
484         // but static fields are OK
485         assertOK(&quot;class R { \n&quot; +
486                 &quot;    static int z = 0;\n&quot; +
487                 &quot;    void m() { \n&quot; +
488                 &quot;        record RR(int x) { public int x() { return z; }};\n&quot; +
489                 &quot;    }\n&quot; +
490                 &quot;}&quot;);
491         // can be contained inside a lambda
492         assertOK(&quot;&quot;&quot;
493                 class Outer {
494                     Runnable run = () -&gt; {
495                         record TestRecord(int i) {}
496                     };
497                 }
498                 &quot;&quot;&quot;);
499 
500         // Can&#39;t self-shadow
501         assertFail(&quot;compiler.err.already.defined&quot;,
502                    &quot;class R { \n&quot; +
503                    &quot;    void m() { \n&quot; +
504                    &quot;        record R(int x) { };\n&quot; +
505                    &quot;    }\n&quot; +
506                    &quot;}&quot;);
507     }
508 
509     public void testCompactDADU() {
510         // trivial cases
511         assertOK(&quot;record R() { public R {} }&quot;);
512         assertOK(&quot;record R(int x) { public R {} }&quot;);
513 
514         // throwing an unchecked exception
515         assertOK(&quot;record R(int x) { public R { if (x &lt; 0) { this.x = x; throw new RuntimeException(); }} }&quot;);
516 
517         assertOK(&quot;record R(int x) { public R { if (x &lt; 0) { this.x = x; throw new RuntimeException(); }} }&quot;);
518 
519         // x is not DA nor DU in the body of the constructor hence error
520         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;, &quot;record R(int x) { # }&quot;,
521                 &quot;public R { if (x &lt; 0) { this.x = -x; } }&quot;);
522 
523         // if static fields are not DA then error
524         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;,
525                 &quot;record R() { # }&quot;, &quot;static final String x;&quot;);
526 
527         // ditto
528         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;,
529                 &quot;record R() { # }&quot;, &quot;static final String x; public R {}&quot;);
530 
531         // ditto
532         assertFail(&quot;compiler.err.var.might.not.have.been.initialized&quot;,
533                 &quot;record R(int i) { # }&quot;, &quot;static final String x; public R {}&quot;);
534     }
535 
536     public void testReturnInCanonical_Compact() {
537         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x) { # }&quot;,
538                 &quot;public R { return; }&quot;);
539         assertFail(&quot;compiler.err.invalid.canonical.constructor.in.record&quot;, &quot;record R(int x) { # }&quot;,
540                 &quot;public R { if (i &lt; 0) { return; }}&quot;);
541         assertOK(&quot;record R(int x) { public R(int x) { this.x = x; return; } }&quot;);
542         assertOK(&quot;record R(int x) { public R { Runnable r = () -&gt; { return; };} }&quot;);
543     }
544 
545     public void testArgumentsAreNotFinalInCompact() {
546         assertOK(
547                 &quot;&quot;&quot;
548                 record R(int x) {
549                     public R {
550                         x++;
551                     }
552                 }
553                 &quot;&quot;&quot;);
554     }
555 
556     public void testNoNativeMethods() {
557         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;record R(int x) { # }&quot;,
558                 &quot;public native R {}&quot;);
559         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, &quot;record R(int x) { # }&quot;,
560                 &quot;public native void m();&quot;);
561     }
562 
563     public void testRecordsInsideInner() {
564         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,
565                 &quot;class Outer {\n&quot; +
566                 &quot;    class Inner {\n&quot; +
567                 &quot;        record R(int a) {}\n&quot; +
568                 &quot;    }\n&quot; +
569                 &quot;}&quot;);
570         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,
571                 &quot;&quot;&quot;
572                 class Outer {
573                     public void test() {
574                         class Inner extends Outer {
575                             record R(int i) {}
576                         }
577                     }
578                 }
579                 &quot;&quot;&quot;);
580         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,
581                 &quot;&quot;&quot;
582                 class Outer {
583                     Runnable run = new Runnable() {
584                         record TestRecord(int i) {}
585                         public void run() {}
586                     };
587                 }
588                 &quot;&quot;&quot;);
589         assertFail(&quot;compiler.err.record.declaration.not.allowed.in.inner.classes&quot;,
590                 &quot;&quot;&quot;
591                 class Outer {
592                     void m() {
593                         record A() {
594                             record B() { }
595                         }
596                     }
597                 }
598                 &quot;&quot;&quot;);
599     }
600 
601     public void testReceiverParameter() {
602         assertFail(&quot;compiler.err.receiver.parameter.not.applicable.constructor.toplevel.class&quot;,
603                 &quot;&quot;&quot;
604                 record R(int i) {
605                     public R(R this, int i) {
606                         this.i = i;
607                     }
608                 }
609                 &quot;&quot;&quot;);
610         assertFail(&quot;compiler.err.non-static.cant.be.ref&quot;,
611                 &quot;&quot;&quot;
612                 class Outer {
613                     record R(int i) {
614                         public R(Outer Outer.this, int i) {
615                             this.i = i;
616                         }
617                     }
618                 }
619                 &quot;&quot;&quot;);
620         assertOK(
621                 &quot;&quot;&quot;
622                 record R(int i) {
623                     void m(R this) {}
624                     public int i(R this) { return i; }
625                 }
626                 &quot;&quot;&quot;);
627     }
628 
629     public void testOnlyOneFieldRef() throws Exception {
630         int numberOfFieldRefs = 0;
631         File dir = assertOK(true, &quot;record R(int recordComponent) {}&quot;);
632         for (final File fileEntry : dir.listFiles()) {
633             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
634                 ClassFile classFile = ClassFile.read(fileEntry);
635                 for (CPInfo cpInfo : classFile.constant_pool.entries()) {
636                     if (cpInfo instanceof ConstantPool.CONSTANT_Fieldref_info) {
637                         numberOfFieldRefs++;
638                         ConstantPool.CONSTANT_NameAndType_info nameAndType =
639                                 (ConstantPool.CONSTANT_NameAndType_info)classFile.constant_pool
640                                         .get(((ConstantPool.CONSTANT_Fieldref_info)cpInfo).name_and_type_index);
641                         Assert.check(nameAndType.getName().equals(&quot;recordComponent&quot;));
642                     }
643                 }
644             }
645         }
646         Assert.check(numberOfFieldRefs == 1);
647     }
648 
649     public void testAcceptRecordId() {
650         String[] testOptions = {/* no options */};
651         setCompileOptions(testOptions);
652         assertOKWithWarning(&quot;compiler.warn.restricted.type.not.allowed.preview&quot;,
653                 &quot;class R {\n&quot; +
654                 &quot;    record RR(int i) {\n&quot; +
655                 &quot;        return null;\n&quot; +
656                 &quot;    }\n&quot; +
657                 &quot;    class record {}\n&quot; +
658                 &quot;}&quot;);
659         setCompileOptions(PREVIEW_OPTIONS);
660     }
661 
662     public void testAnnos() throws Exception {
663         String srcTemplate =
664                 &quot;&quot;&quot;
665                     import java.lang.annotation.*;
666                     @Target({#TARGET})
667                     @Retention(RetentionPolicy.RUNTIME)
668                     @interface Anno { }
669 
670                     record R(@Anno String s) {}
671                 &quot;&quot;&quot;;
672 
673         // testing several combinations, adding even more combinations won&#39;t add too much value
674         List&lt;String&gt; annoApplicableTargets = List.of(
675                 &quot;ElementType.FIELD&quot;,
676                 &quot;ElementType.METHOD&quot;,
677                 &quot;ElementType.PARAMETER&quot;,
678                 &quot;ElementType.RECORD_COMPONENT&quot;,
679                 &quot;ElementType.TYPE_USE&quot;,
680                 &quot;ElementType.TYPE_USE,ElementType.FIELD&quot;,
681                 &quot;ElementType.TYPE_USE,ElementType.METHOD&quot;,
682                 &quot;ElementType.TYPE_USE,ElementType.PARAMETER&quot;,
683                 &quot;ElementType.TYPE_USE,ElementType.RECORD_COMPONENT&quot;,
684                 &quot;ElementType.TYPE_USE,ElementType.FIELD,ElementType.METHOD&quot;,
685                 &quot;ElementType.TYPE_USE,ElementType.FIELD,ElementType.PARAMETER&quot;,
686                 &quot;ElementType.TYPE_USE,ElementType.FIELD,ElementType.RECORD_COMPONENT&quot;,
687                 &quot;ElementType.FIELD,ElementType.TYPE_USE&quot;,
688                 &quot;ElementType.METHOD,ElementType.TYPE_USE&quot;,
689                 &quot;ElementType.PARAMETER,ElementType.TYPE_USE&quot;,
690                 &quot;ElementType.RECORD_COMPONENT,ElementType.TYPE_USE&quot;,
691                 &quot;ElementType.FIELD,ElementType.METHOD,ElementType.TYPE_USE&quot;,
692                 &quot;ElementType.FIELD,ElementType.PARAMETER,ElementType.TYPE_USE&quot;,
693                 &quot;ElementType.FIELD,ElementType.RECORD_COMPONENT,ElementType.TYPE_USE&quot;
694         );
695 
696         String[] generalOptions = {
697                 &quot;--enable-preview&quot;,
698                 &quot;-source&quot;, Integer.toString(Runtime.version().feature()),
699                 &quot;-processor&quot;, Processor.class.getName(),
700                 &quot;-Atargets=&quot;
701         };
702 
703         for (String target : annoApplicableTargets) {
704             String code = srcTemplate.replaceFirst(&quot;#TARGET&quot;, target);
705             String[] testOptions = generalOptions.clone();
706             testOptions[testOptions.length - 1] = testOptions[testOptions.length - 1] + target;
707             setCompileOptions(testOptions);
708 
709             File dir = assertOK(true, code);
710 
711             ClassFile classFile = ClassFile.read(findClassFileOrFail(dir, &quot;R.class&quot;));
712 
713             // field first
714             Assert.check(classFile.fields.length == 1);
715             Field field = classFile.fields[0];
716             /* if FIELD is one of the targets then there must be a declaration annotation applied to the field, apart from
717              * the type annotation
718              */
719             if (target.contains(&quot;FIELD&quot;)) {
720                 checkAnno(classFile,
721                         (RuntimeAnnotations_attribute)findAttributeOrFail(
722                                 field.attributes,
723                                 RuntimeVisibleAnnotations_attribute.class),
724                         &quot;Anno&quot;);
725             } else {
726                 assertAttributeNotPresent(field.attributes, RuntimeVisibleAnnotations_attribute.class);
727             }
728 
729             // lets check now for the type annotation
730             if (target.contains(&quot;TYPE_USE&quot;)) {
731                 checkTypeAnno(
732                         classFile,
733                         (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class),
734                         &quot;FIELD&quot;,
735                         &quot;Anno&quot;);
736             } else {
737                 assertAttributeNotPresent(field.attributes, RuntimeVisibleTypeAnnotations_attribute.class);
738             }
739 
740             // checking for the annotation on the corresponding parameter of the canonical constructor
741             Method init = findMethodOrFail(classFile, &quot;&lt;init&gt;&quot;);
742             /* if PARAMETER is one of the targets then there must be a declaration annotation applied to the parameter, apart from
743              * the type annotation
744              */
745             if (target.contains(&quot;PARAMETER&quot;)) {
746                 checkParameterAnno(classFile,
747                         (RuntimeVisibleParameterAnnotations_attribute)findAttributeOrFail(
748                                 init.attributes,
749                                 RuntimeVisibleParameterAnnotations_attribute.class),
750                         &quot;Anno&quot;);
751             } else {
752                 assertAttributeNotPresent(init.attributes, RuntimeVisibleAnnotations_attribute.class);
753             }
754             // let&#39;s check now for the type annotation
755             if (target.contains(&quot;TYPE_USE&quot;)) {
756                 checkTypeAnno(
757                         classFile,
758                         (RuntimeVisibleTypeAnnotations_attribute) findAttributeOrFail(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class),
759                         &quot;METHOD_FORMAL_PARAMETER&quot;, &quot;Anno&quot;);
760             } else {
761                 assertAttributeNotPresent(init.attributes, RuntimeVisibleTypeAnnotations_attribute.class);
762             }
763 
764             // checking for the annotation in the accessor
765             Method accessor = findMethodOrFail(classFile, &quot;s&quot;);
766             /* if METHOD is one of the targets then there must be a declaration annotation applied to the accessor, apart from
767              * the type annotation
768              */
769             if (target.contains(&quot;METHOD&quot;)) {
770                 checkAnno(classFile,
771                         (RuntimeAnnotations_attribute)findAttributeOrFail(
772                                 accessor.attributes,
773                                 RuntimeVisibleAnnotations_attribute.class),
774                         &quot;Anno&quot;);
775             } else {
776                 assertAttributeNotPresent(accessor.attributes, RuntimeVisibleAnnotations_attribute.class);
777             }
778             // let&#39;s check now for the type annotation
779             if (target.contains(&quot;TYPE_USE&quot;)) {
780                 checkTypeAnno(
781                         classFile,
782                         (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class),
783                         &quot;METHOD_RETURN&quot;, &quot;Anno&quot;);
784             } else {
785                 assertAttributeNotPresent(accessor.attributes, RuntimeVisibleTypeAnnotations_attribute.class);
786             }
787 
788             // checking for the annotation in the Record attribute
789             Record_attribute record = (Record_attribute)findAttributeOrFail(classFile.attributes, Record_attribute.class);
790             Assert.check(record.component_count == 1);
791             /* if RECORD_COMPONENT is one of the targets then there must be a declaration annotation applied to the
792              * field, apart from the type annotation
793              */
794             if (target.contains(&quot;RECORD_COMPONENT&quot;)) {
795                 checkAnno(classFile,
796                         (RuntimeAnnotations_attribute)findAttributeOrFail(
797                                 record.component_info_arr[0].attributes,
798                                 RuntimeVisibleAnnotations_attribute.class),
799                         &quot;Anno&quot;);
800             } else {
801                 assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleAnnotations_attribute.class);
802             }
803             // lets check now for the type annotation
804             if (target.contains(&quot;TYPE_USE&quot;)) {
805                 checkTypeAnno(
806                         classFile,
807                         (RuntimeVisibleTypeAnnotations_attribute)findAttributeOrFail(
808                                 record.component_info_arr[0].attributes,
809                                 RuntimeVisibleTypeAnnotations_attribute.class),
810                         &quot;FIELD&quot;, &quot;Anno&quot;);
811             } else {
812                 assertAttributeNotPresent(record.component_info_arr[0].attributes, RuntimeVisibleTypeAnnotations_attribute.class);
813             }
814         }
815 
816         // let&#39;s reset the default compiler options for other tests
817         setCompileOptions(PREVIEW_OPTIONS);
818     }
819 
820     private void checkTypeAnno(ClassFile classFile,
821                                RuntimeTypeAnnotations_attribute rtAnnos,
822                                String positionType,
823                                String annoName) throws Exception {
824         // containing only one type annotation
825         Assert.check(rtAnnos.annotations.length == 1);
826         TypeAnnotation tAnno = (TypeAnnotation)rtAnnos.annotations[0];
827         Assert.check(tAnno.position.type.toString().equals(positionType));
828         String annotationName = classFile.constant_pool.getUTF8Value(tAnno.annotation.type_index).toString().substring(1);
829         Assert.check(annotationName.startsWith(annoName));
830     }
831 
832     private void checkAnno(ClassFile classFile,
833                            RuntimeAnnotations_attribute rAnnos,
834                            String annoName) throws Exception {
835         // containing only one type annotation
836         Assert.check(rAnnos.annotations.length == 1);
837         Annotation anno = (Annotation)rAnnos.annotations[0];
838         String annotationName = classFile.constant_pool.getUTF8Value(anno.type_index).toString().substring(1);
839         Assert.check(annotationName.startsWith(annoName));
840     }
841 
842     // special case for parameter annotations
843     private void checkParameterAnno(ClassFile classFile,
844                            RuntimeVisibleParameterAnnotations_attribute rAnnos,
845                            String annoName) throws Exception {
846         // containing only one type annotation
847         Assert.check(rAnnos.parameter_annotations.length == 1);
848         Assert.check(rAnnos.parameter_annotations[0].length == 1);
849         Annotation anno = (Annotation)rAnnos.parameter_annotations[0][0];
850         String annotationName = classFile.constant_pool.getUTF8Value(anno.type_index).toString().substring(1);
851         Assert.check(annotationName.startsWith(annoName));
852     }
853 
854     private File findClassFileOrFail(File dir, String name) {
855         for (final File fileEntry : dir.listFiles()) {
856             if (fileEntry.getName().equals(&quot;R.class&quot;)) {
857                 return fileEntry;
858             }
859         }
860         throw new AssertionError(&quot;file not found&quot;);
861     }
862 
863     private Method findMethodOrFail(ClassFile classFile, String name) throws Exception {
864         for (Method method : classFile.methods) {
865             if (method.getName(classFile.constant_pool).equals(name)) {
866                 return method;
867             }
868         }
869         throw new AssertionError(&quot;method not found&quot;);
870     }
871 
872     private Attribute findAttributeOrFail(Attributes attributes, Class&lt;? extends Attribute&gt; attrClass) {
873         for (Attribute attribute : attributes) {
874             if (attribute.getClass() == attrClass) {
875                 return attribute;
876             }
877         }
878         throw new AssertionError(&quot;attribute not found&quot;);
879     }
880 
881     private void assertAttributeNotPresent(Attributes attributes, Class&lt;? extends Attribute&gt; attrClass) {
882         for (Attribute attribute : attributes) {
883             if (attribute.getClass() == attrClass) {
884                 throw new AssertionError(&quot;attribute not expected&quot;);
885             }
886         }
887     }
888 
889     @SupportedAnnotationTypes(&quot;*&quot;)
890     public static final class Processor extends JavacTestingAbstractProcessor {
891 
892         String targets;
893         int numberOfTypeAnnotations;
894 
895         @Override
896         public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {
897             targets = processingEnv.getOptions().get(&quot;targets&quot;);
898             for (TypeElement te : annotations) {
899                 if (te.toString().equals(&quot;Anno&quot;)) {
900                     checkElements(te, roundEnv, targets);
901                     if (targets.contains(&quot;TYPE_USE&quot;)) {
902                         Element element = processingEnv.getElementUtils().getTypeElement(&quot;R&quot;);
903                         numberOfTypeAnnotations = 0;
904                         checkTypeAnnotations(element);
905                         Assert.check(numberOfTypeAnnotations == 4);
906                     }
907                 }
908             }
909             return true;
910         }
911 
912         void checkElements(TypeElement te, RoundEnvironment renv, String targets) {
913             Set&lt;? extends Element&gt; annoElements = renv.getElementsAnnotatedWith(te);
914             Set&lt;String&gt; targetSet = new HashSet&lt;&gt;(Arrays.asList(targets.split(&quot;,&quot;)));
915             // we will check for type annotation in another method
916             targetSet.remove(&quot;ElementType.TYPE_USE&quot;);
917             for (Element e : annoElements) {
918                 Symbol s = (Symbol) e;
919                 switch (s.getKind()) {
920                     case FIELD:
921                         Assert.check(targetSet.contains(&quot;ElementType.FIELD&quot;));
922                         targetSet.remove(&quot;ElementType.FIELD&quot;);
923                         break;
924                     case METHOD:
925                         Assert.check(targetSet.contains(&quot;ElementType.METHOD&quot;));
926                         targetSet.remove(&quot;ElementType.METHOD&quot;);
927                         break;
928                     case PARAMETER:
929                         Assert.check(targetSet.contains(&quot;ElementType.PARAMETER&quot;));
930                         targetSet.remove(&quot;ElementType.PARAMETER&quot;);
931                         break;
932                     case RECORD_COMPONENT:
933                         Assert.check(targetSet.contains(&quot;ElementType.RECORD_COMPONENT&quot;));
934                         targetSet.remove(&quot;ElementType.RECORD_COMPONENT&quot;);
935                         break;
936                     default:
937                         throw new AssertionError(&quot;unexpected element kind&quot;);
938                 }
939             }
940             Assert.check(targetSet.isEmpty(), targetSet.toString());
941         }
942 
943         private void checkTypeAnnotations(Element rootElement) {
944             new ElementScanner&lt;Void, Void&gt;() {
945                 @Override public Void visitVariable(VariableElement e, Void p) {
946                     Symbol s = (Symbol) e;
947                     if (s.getKind() == ElementKind.FIELD ||
948                             s.getKind() == ElementKind.PARAMETER &amp;&amp;
949                             s.name.toString().equals(&quot;s&quot;)) {
950                         int currentTAs = numberOfTypeAnnotations;
951                         verifyTypeAnnotations(e.asType().getAnnotationMirrors());
952                         Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
953                     }
954                     return null;
955                 }
956                 @Override
957                 public Void visitExecutable(ExecutableElement e, Void p) {
958                     Symbol s = (Symbol) e;
959                     if (s.getKind() == ElementKind.METHOD &amp;&amp;
960                                     s.name.toString().equals(&quot;s&quot;)) {
961                         int currentTAs = numberOfTypeAnnotations;
962                         verifyTypeAnnotations(e.getReturnType().getAnnotationMirrors());
963                         Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
964                     }
965                     scan(e.getParameters(), p);
966                     return null;
967                 }
968                 @Override public Void visitRecordComponent(RecordComponentElement e, Void p) {
969                     int currentTAs = numberOfTypeAnnotations;
970                     verifyTypeAnnotations(e.asType().getAnnotationMirrors());
971                     Assert.check(currentTAs + 1 == numberOfTypeAnnotations);
972                     return null;
973                 }
974             }.scan(rootElement, null);
975         }
976 
977         private void verifyTypeAnnotations(Iterable&lt;? extends AnnotationMirror&gt; annotations) {
978             for (AnnotationMirror mirror : annotations) {
979                 Assert.check(mirror.toString().startsWith(&quot;@Anno&quot;));
980                 if (mirror instanceof TypeCompound) {
981                     numberOfTypeAnnotations++;
982                 }
983             }
984         }
985 
986     }
987 }
    </pre>
  </body>
</html>
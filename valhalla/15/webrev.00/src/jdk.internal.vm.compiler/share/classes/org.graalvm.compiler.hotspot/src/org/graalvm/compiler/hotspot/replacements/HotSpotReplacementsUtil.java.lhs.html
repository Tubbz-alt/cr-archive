<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/replacements/HotSpotReplacementsUtil.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.replacements;
 26 
 27 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_METAACCESS;
 28 import static org.graalvm.compiler.hotspot.GraalHotSpotVMConfigBase.INJECTED_VMCONFIG;
 29 import static org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProviderImpl.VERIFY_OOP;
 30 
 31 import java.lang.ref.Reference;
 32 
 33 import org.graalvm.compiler.api.replacements.Fold;
 34 import org.graalvm.compiler.api.replacements.Fold.InjectedParameter;
 35 import org.graalvm.compiler.core.common.SuppressFBWarnings;
 36 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 37 import org.graalvm.compiler.core.common.type.ObjectStamp;
 38 import org.graalvm.compiler.core.common.type.TypeReference;
 39 import org.graalvm.compiler.debug.GraalError;
 40 import org.graalvm.compiler.graph.Node.ConstantNodeParameter;
 41 import org.graalvm.compiler.graph.Node.NodeIntrinsic;
 42 import org.graalvm.compiler.graph.spi.CanonicalizerTool;
 43 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 44 import org.graalvm.compiler.hotspot.word.KlassPointer;
 45 import org.graalvm.compiler.nodes.CanonicalizableLocation;
 46 import org.graalvm.compiler.nodes.CompressionNode;
 47 import org.graalvm.compiler.nodes.ComputeObjectAddressNode;
 48 import org.graalvm.compiler.nodes.ConstantNode;
 49 import org.graalvm.compiler.nodes.NamedLocationIdentity;
 50 import org.graalvm.compiler.nodes.NodeView;
 51 import org.graalvm.compiler.nodes.ValueNode;
 52 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
 53 import org.graalvm.compiler.nodes.extended.LoadHubNode;
 54 import org.graalvm.compiler.nodes.extended.LoadHubOrNullNode;
 55 import org.graalvm.compiler.nodes.extended.RawLoadNode;
 56 import org.graalvm.compiler.nodes.extended.StoreHubNode;
 57 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
 58 import org.graalvm.compiler.nodes.memory.AddressableMemoryAccess;
 59 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 60 import org.graalvm.compiler.nodes.memory.address.OffsetAddressNode;
 61 import org.graalvm.compiler.nodes.type.StampTool;
 62 import org.graalvm.compiler.replacements.ReplacementsUtil;
 63 import org.graalvm.compiler.replacements.nodes.ReadRegisterNode;
 64 import org.graalvm.compiler.replacements.nodes.WriteRegisterNode;
 65 import org.graalvm.compiler.word.Word;
 66 import jdk.internal.vm.compiler.word.LocationIdentity;
 67 import jdk.internal.vm.compiler.word.WordFactory;
 68 
 69 import jdk.vm.ci.code.Register;
 70 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 71 import jdk.vm.ci.hotspot.HotSpotMetaspaceConstant;
 72 import jdk.vm.ci.hotspot.HotSpotResolvedObjectType;
 73 import jdk.vm.ci.meta.Assumptions;
 74 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
 75 import jdk.vm.ci.meta.JavaKind;
 76 import jdk.vm.ci.meta.MetaAccessProvider;
 77 import jdk.vm.ci.meta.ResolvedJavaField;
 78 import jdk.vm.ci.meta.ResolvedJavaType;
 79 import jdk.vm.ci.meta.UnresolvedJavaType;
 80 
 81 //JaCoCo Exclude
 82 
 83 /**
 84  * A collection of methods used in HotSpot snippets, substitutions and stubs.
 85  */
 86 public class HotSpotReplacementsUtil {
 87 
 88     abstract static class HotSpotOptimizingLocationIdentity extends NamedLocationIdentity implements CanonicalizableLocation {
 89 
 90         HotSpotOptimizingLocationIdentity(String name) {
 91             super(name, true);
 92         }
 93 
 94         @Override
 95         public abstract ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool);
 96 
 97         protected ValueNode findReadHub(ValueNode object) {
 98             ValueNode base = object;
 99             if (base instanceof CompressionNode) {
100                 base = ((CompressionNode) base).getValue();
101             }
102             if (base instanceof AddressableMemoryAccess) {
103                 AddressableMemoryAccess access = (AddressableMemoryAccess) base;
104                 if (access.getLocationIdentity().equals(HUB_LOCATION) || access.getLocationIdentity().equals(COMPRESSED_HUB_LOCATION)) {
105                     AddressNode address = access.getAddress();
106                     if (address instanceof OffsetAddressNode) {
107                         OffsetAddressNode offset = (OffsetAddressNode) address;
108                         return offset.getBase();
109                     }
110                 }
111             } else if (base instanceof LoadHubNode) {
112                 LoadHubNode loadhub = (LoadHubNode) base;
113                 return loadhub.getValue();
114             }
115             return null;
116         }
117 
118         /**
119          * Fold reads that convert from Class -&gt; Hub -&gt; Class or vice versa.
120          *
121          * @param read
122          * @param object
123          * @param otherLocation
124          * @return an earlier read or the original {@code read}
125          */
126         protected static ValueNode foldIndirection(ValueNode read, ValueNode object, LocationIdentity otherLocation) {
127             if (object instanceof AddressableMemoryAccess) {
128                 AddressableMemoryAccess access = (AddressableMemoryAccess) object;
129                 if (access.getLocationIdentity().equals(otherLocation)) {
130                     AddressNode address = access.getAddress();
131                     if (address instanceof OffsetAddressNode) {
132                         OffsetAddressNode offset = (OffsetAddressNode) address;
133                         assert offset.getBase().stamp(NodeView.DEFAULT).isCompatible(read.stamp(NodeView.DEFAULT));
134                         return offset.getBase();
135                     }
136                 }
137             }
138             return read;
139         }
140     }
141 
142     @Fold
143     public static ResolvedJavaType methodHolderClass(@InjectedParameter IntrinsicContext context) {
144         return context.getOriginalMethod().getDeclaringClass();
145     }
146 
147     @Fold
148     static ResolvedJavaType getType(@Fold.InjectedParameter IntrinsicContext context, String typeName) {
149         try {
150             UnresolvedJavaType unresolved = UnresolvedJavaType.create(typeName);
151             return unresolved.resolve(methodHolderClass(context));
152         } catch (LinkageError e) {
153             throw new GraalError(e);
154         }
155     }
156 
157     @Fold
158     public static int getFieldOffset(ResolvedJavaType type, String fieldName) {
<a name="1" id="anc1"></a>



159         for (ResolvedJavaField field : type.getInstanceFields(true)) {
160             if (field.getName().equals(fieldName)) {
<a name="2" id="anc2"></a><span class="line-modified">161                 return field.getOffset();</span>
162             }
163         }
164         throw new GraalError(&quot;missing field &quot; + fieldName + &quot; in type &quot; + type);
165     }
166 
167     public static HotSpotJVMCIRuntime runtime() {
168         return HotSpotJVMCIRuntime.runtime();
169     }
170 
171     @Fold
172     public static int getHeapWordSize(@InjectedParameter GraalHotSpotVMConfig injectedVMConfig) {
173         return injectedVMConfig.heapWordSize;
174     }
175 
176     @Fold
177     public static int klassLayoutHelperNeutralValue(@InjectedParameter GraalHotSpotVMConfig config) {
178         return config.klassLayoutHelperNeutralValue;
179     }
180 
181     @Fold
182     public static boolean useTLAB(@InjectedParameter GraalHotSpotVMConfig config) {
183         return config.useTLAB;
184     }
185 
186     @Fold
187     public static boolean useG1GC(@InjectedParameter GraalHotSpotVMConfig config) {
188         return config.useG1GC;
189     }
190 
191     @Fold
192     public static boolean verifyOops(@InjectedParameter GraalHotSpotVMConfig config) {
193         return config.verifyOops;
194     }
195 
196     /**
197      * @see GraalHotSpotVMConfig#doingUnsafeAccessOffset
198      */
199     @Fold
200     public static int doingUnsafeAccessOffset(@InjectedParameter GraalHotSpotVMConfig config) {
201         return config.doingUnsafeAccessOffset;
202     }
203 
204     public static final LocationIdentity EXCEPTION_OOP_LOCATION = NamedLocationIdentity.mutable(&quot;ExceptionOop&quot;);
205 
206     /**
207      * @see GraalHotSpotVMConfig#threadExceptionOopOffset
208      */
209     @Fold
210     public static int threadExceptionOopOffset(@InjectedParameter GraalHotSpotVMConfig config) {
211         return config.threadExceptionOopOffset;
212     }
213 
214     public static final LocationIdentity EXCEPTION_PC_LOCATION = NamedLocationIdentity.mutable(&quot;ExceptionPc&quot;);
215 
216     @Fold
217     public static int threadExceptionPcOffset(@InjectedParameter GraalHotSpotVMConfig config) {
218         return config.threadExceptionPcOffset;
219     }
220 
221     public static final LocationIdentity TLAB_TOP_LOCATION = NamedLocationIdentity.mutable(&quot;TlabTop&quot;);
222 
223     @Fold
224     public static int threadTlabTopOffset(@InjectedParameter GraalHotSpotVMConfig config) {
225         return config.threadTlabTopOffset();
226     }
227 
228     public static final LocationIdentity TLAB_END_LOCATION = NamedLocationIdentity.mutable(&quot;TlabEnd&quot;);
229 
230     @Fold
231     static int threadTlabEndOffset(@InjectedParameter GraalHotSpotVMConfig config) {
232         return config.threadTlabEndOffset();
233     }
234 
235     public static final LocationIdentity PENDING_EXCEPTION_LOCATION = NamedLocationIdentity.mutable(&quot;PendingException&quot;);
236 
237     /**
238      * @see GraalHotSpotVMConfig#pendingExceptionOffset
239      */
240     @Fold
241     static int threadPendingExceptionOffset(@InjectedParameter GraalHotSpotVMConfig config) {
242         return config.pendingExceptionOffset;
243     }
244 
245     /**
246      * @see GraalHotSpotVMConfig#threadExceptionOopOffset
247      */
248     public static Object readExceptionOop(Word thread) {
249         return thread.readObject(threadExceptionOopOffset(INJECTED_VMCONFIG), EXCEPTION_OOP_LOCATION);
250     }
251 
252     public static Word readExceptionPc(Word thread) {
253         return thread.readWord(threadExceptionPcOffset(INJECTED_VMCONFIG), EXCEPTION_PC_LOCATION);
254     }
255 
256     /**
257      * @see GraalHotSpotVMConfig#threadExceptionOopOffset
258      */
259     public static void writeExceptionOop(Word thread, Object value) {
260         thread.writeObject(threadExceptionOopOffset(INJECTED_VMCONFIG), value, EXCEPTION_OOP_LOCATION);
261     }
262 
263     public static void writeExceptionPc(Word thread, Word value) {
264         thread.writeWord(threadExceptionPcOffset(INJECTED_VMCONFIG), value, EXCEPTION_PC_LOCATION);
265     }
266 
267     public static Word readTlabTop(Word thread) {
268         return thread.readWord(threadTlabTopOffset(INJECTED_VMCONFIG), TLAB_TOP_LOCATION);
269     }
270 
271     public static Word readTlabEnd(Word thread) {
272         return thread.readWord(threadTlabEndOffset(INJECTED_VMCONFIG), TLAB_END_LOCATION);
273     }
274 
275     public static void writeTlabTop(Word thread, Word top) {
276         thread.writeWord(threadTlabTopOffset(INJECTED_VMCONFIG), top, TLAB_TOP_LOCATION);
277     }
278 
279     /**
280      * Clears the pending exception for the given thread.
281      *
282      * @return the pending exception, or null if there was none
283      */
284     @SuppressFBWarnings(value = &quot;NP_NULL_PARAM_DEREF_NONVIRTUAL&quot;, justification = &quot;foldable method parameters are injected&quot;)
285     public static Object clearPendingException(Word thread) {
286         Object result = thread.readObject(threadPendingExceptionOffset(INJECTED_VMCONFIG), PENDING_EXCEPTION_LOCATION);
287         thread.writeObject(threadPendingExceptionOffset(INJECTED_VMCONFIG), null, PENDING_EXCEPTION_LOCATION);
288         return result;
289     }
290 
291     /**
292      * Gets the pending exception for the given thread.
293      *
294      * @return the pending exception, or null if there was none
295      */
296     @SuppressFBWarnings(value = &quot;NP_NULL_PARAM_DEREF_NONVIRTUAL&quot;, justification = &quot;foldable method parameters are injected&quot;)
297     public static Object getPendingException(Word thread) {
298         return thread.readObject(threadPendingExceptionOffset(INJECTED_VMCONFIG), PENDING_EXCEPTION_LOCATION);
299     }
300 
301     /*
302      * As far as Java code is concerned this can be considered immutable: it is set just after the
303      * JavaThread is created, before it is published. After that, it is never changed.
304      */
305     public static final LocationIdentity JAVA_THREAD_THREAD_OBJECT_LOCATION = NamedLocationIdentity.immutable(&quot;JavaThread::_threadObj&quot;);
306 
307     @Fold
308     public static int threadObjectOffset(@InjectedParameter GraalHotSpotVMConfig config) {
309         return config.threadObjectOffset;
310     }
311 
312     public static final LocationIdentity JAVA_THREAD_OSTHREAD_LOCATION = NamedLocationIdentity.mutable(&quot;JavaThread::_osthread&quot;);
313 
314     @Fold
315     public static int osThreadOffset(@InjectedParameter GraalHotSpotVMConfig config) {
316         assert config.osThreadOffset != Integer.MAX_VALUE;
317         return config.osThreadOffset;
318     }
319 
320     @Fold
321     public static int osThreadInterruptedOffset(@InjectedParameter GraalHotSpotVMConfig config) {
322         assert config.osThreadInterruptedOffset != Integer.MAX_VALUE;
323         return config.osThreadInterruptedOffset;
324     }
325 
326     @Fold
327     public static JavaKind getWordKind() {
328         return runtime().getHostJVMCIBackend().getCodeCache().getTarget().wordJavaKind;
329     }
330 
331     @Fold
332     public static int wordSize() {
333         return runtime().getHostJVMCIBackend().getCodeCache().getTarget().wordSize;
334     }
335 
336     @Fold
337     public static int pageSize(@InjectedParameter GraalHotSpotVMConfig config) {
338         return config.vmPageSize;
339     }
340 
341     public static final LocationIdentity PROTOTYPE_MARK_WORD_LOCATION = NamedLocationIdentity.mutable(&quot;PrototypeMarkWord&quot;);
342 
343     @Fold
344     public static int prototypeMarkWordOffset(@InjectedParameter GraalHotSpotVMConfig config) {
345         return config.prototypeMarkWordOffset;
346     }
347 
348     public static final LocationIdentity KLASS_ACCESS_FLAGS_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_access_flags&quot;);
349 
350     @Fold
351     public static int klassAccessFlagsOffset(@InjectedParameter GraalHotSpotVMConfig config) {
352         return config.klassAccessFlagsOffset;
353     }
354 
355     @Fold
356     public static int jvmAccWrittenFlags(@InjectedParameter GraalHotSpotVMConfig config) {
357         return config.jvmAccWrittenFlags;
358     }
359 
360     public static final LocationIdentity KLASS_LAYOUT_HELPER_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Klass::_layout_helper&quot;) {
361         @Override
362         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
363             ValueNode javaObject = findReadHub(object);
364             if (javaObject != null) {
365                 if (javaObject.stamp(NodeView.DEFAULT) instanceof ObjectStamp) {
366                     ObjectStamp stamp = (ObjectStamp) javaObject.stamp(NodeView.DEFAULT);
367                     HotSpotResolvedObjectType type = (HotSpotResolvedObjectType) stamp.javaType(tool.getMetaAccess());
368                     if (type.isArray() &amp;&amp; !type.getComponentType().isPrimitive()) {
369                         int layout = type.layoutHelper();
370                         return ConstantNode.forInt(layout);
371                     }
372                 }
373             }
374             return read;
375         }
376     };
377 
378     @Fold
379     public static int allocatePrefetchStyle(@InjectedParameter GraalHotSpotVMConfig config) {
380         return config.allocatePrefetchStyle;
381     }
382 
383     @Fold
384     public static int allocatePrefetchLines(@InjectedParameter GraalHotSpotVMConfig config) {
385         return config.allocatePrefetchLines;
386     }
387 
388     @Fold
389     public static int allocatePrefetchDistance(@InjectedParameter GraalHotSpotVMConfig config) {
390         return config.allocatePrefetchDistance;
391     }
392 
393     @Fold
394     public static int allocateInstancePrefetchLines(@InjectedParameter GraalHotSpotVMConfig config) {
395         return config.allocateInstancePrefetchLines;
396     }
397 
398     @Fold
399     public static int allocatePrefetchStepSize(@InjectedParameter GraalHotSpotVMConfig config) {
400         return config.allocatePrefetchStepSize;
401     }
402 
403     @Fold
404     public static int invocationCounterIncrement(@InjectedParameter GraalHotSpotVMConfig config) {
405         return config.invocationCounterIncrement;
406     }
407 
408     @Fold
409     public static int invocationCounterOffset(@InjectedParameter GraalHotSpotVMConfig config) {
410         return config.invocationCounterOffset;
411     }
412 
413     @Fold
414     public static int backedgeCounterOffset(@InjectedParameter GraalHotSpotVMConfig config) {
415         return config.backedgeCounterOffset;
416     }
417 
418     @Fold
419     public static int invocationCounterShift(@InjectedParameter GraalHotSpotVMConfig config) {
420         return config.invocationCounterShift;
421     }
422 
423     @Fold
424     public static int stackBias(@InjectedParameter GraalHotSpotVMConfig config) {
425         return config.stackBias;
426     }
427 
428     @NodeIntrinsic(value = KlassLayoutHelperNode.class)
429     public static native int readLayoutHelper(KlassPointer object);
430 
431     /**
432      * Checks if class {@code klass} is an array.
433      *
434      * See: Klass::layout_helper_is_array
435      *
436      * @param klassNonNull the class to be checked
437      * @return true if klassNonNull is an array, false otherwise
438      */
439     public static boolean klassIsArray(KlassPointer klassNonNull) {
440         /*
441          * The less-than check only works if both values are ints. We use local variables to make
442          * sure these are still ints and haven&#39;t changed.
443          */
444         final int layoutHelper = readLayoutHelper(klassNonNull);
445         final int layoutHelperNeutralValue = klassLayoutHelperNeutralValue(INJECTED_VMCONFIG);
446         return (layoutHelper &lt; layoutHelperNeutralValue);
447     }
448 
449     public static final LocationIdentity ARRAY_KLASS_COMPONENT_MIRROR = NamedLocationIdentity.immutable(&quot;ArrayKlass::_component_mirror&quot;);
450 
451     @Fold
452     public static int arrayKlassComponentMirrorOffset(@InjectedParameter GraalHotSpotVMConfig config) {
453         return config.getFieldOffset(&quot;ArrayKlass::_component_mirror&quot;, Integer.class, &quot;oop&quot;);
454     }
455 
456     public static final LocationIdentity KLASS_SUPER_KLASS_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_super&quot;);
457 
458     @Fold
459     public static int klassSuperKlassOffset(@InjectedParameter GraalHotSpotVMConfig config) {
460         return config.klassSuperKlassOffset;
461     }
462 
463     public static final LocationIdentity MARK_WORD_LOCATION = NamedLocationIdentity.mutable(&quot;MarkWord&quot;);
464 
465     @Fold
466     public static int markOffset(@InjectedParameter GraalHotSpotVMConfig config) {
467         return config.markOffset;
468     }
469 
470     public static final LocationIdentity HUB_WRITE_LOCATION = NamedLocationIdentity.mutable(&quot;Hub:write&quot;);
471 
472     public static final LocationIdentity HUB_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Hub&quot;) {
473         @Override
474         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
475             TypeReference constantType = StampTool.typeReferenceOrNull(object);
476             if (constantType != null &amp;&amp; constantType.isExact()) {
477                 return ConstantNode.forConstant(read.stamp(NodeView.DEFAULT), tool.getConstantReflection().asObjectHub(constantType.getType()), tool.getMetaAccess());
478             }
479             return read;
480         }
481     };
482 
483     public static final LocationIdentity COMPRESSED_HUB_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;CompressedHub&quot;) {
484         @Override
485         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
486             TypeReference constantType = StampTool.typeReferenceOrNull(object);
487             if (constantType != null &amp;&amp; constantType.isExact()) {
488                 return ConstantNode.forConstant(read.stamp(NodeView.DEFAULT), ((HotSpotMetaspaceConstant) tool.getConstantReflection().asObjectHub(constantType.getType())).compress(),
489                                 tool.getMetaAccess());
490             }
491             return read;
492         }
493     };
494 
495     @Fold
496     static int hubOffset(@InjectedParameter GraalHotSpotVMConfig config) {
497         return config.hubOffset;
498     }
499 
500     public static void initializeObjectHeader(Word memory, Word markWord, KlassPointer hub) {
501         memory.writeWord(markOffset(INJECTED_VMCONFIG), markWord, MARK_WORD_LOCATION);
502         StoreHubNode.write(memory, hub);
503     }
504 
505     @Fold
506     public static int unlockedMask(@InjectedParameter GraalHotSpotVMConfig config) {
507         return config.unlockedMask;
508     }
509 
510     @Fold
511     public static int monitorMask(@InjectedParameter GraalHotSpotVMConfig config) {
512         return config.monitorMask;
513     }
514 
515     @Fold
516     public static int objectMonitorOwnerOffset(@InjectedParameter GraalHotSpotVMConfig config) {
517         return config.objectMonitorOwner;
518     }
519 
520     @Fold
521     public static int objectMonitorRecursionsOffset(@InjectedParameter GraalHotSpotVMConfig config) {
522         return config.objectMonitorRecursions;
523     }
524 
525     @Fold
526     public static int objectMonitorCxqOffset(@InjectedParameter GraalHotSpotVMConfig config) {
527         return config.objectMonitorCxq;
528     }
529 
530     @Fold
531     public static int objectMonitorEntryListOffset(@InjectedParameter GraalHotSpotVMConfig config) {
532         return config.objectMonitorEntryList;
533     }
534 
535     @Fold
536     public static int objectMonitorSuccOffset(@InjectedParameter GraalHotSpotVMConfig config) {
537         return config.objectMonitorSucc;
538     }
539 
540     /**
541      * Mask for a biasable, locked or unlocked mark word.
542      *
543      * &lt;pre&gt;
544      * +----------------------------------+-+-+
545      * |                                 1|1|1|
546      * +----------------------------------+-+-+
547      * &lt;/pre&gt;
548      *
549      */
550     @Fold
551     public static int biasedLockMaskInPlace(@InjectedParameter GraalHotSpotVMConfig config) {
552         return config.biasedLockMaskInPlace;
553     }
554 
555     @Fold
556     public static int epochMaskInPlace(@InjectedParameter GraalHotSpotVMConfig config) {
557         return config.epochMaskInPlace;
558     }
559 
560     /**
561      * Pattern for a biasable, unlocked mark word.
562      *
563      * &lt;pre&gt;
564      * +----------------------------------+-+-+
565      * |                                 1|0|1|
566      * +----------------------------------+-+-+
567      * &lt;/pre&gt;
568      *
569      */
570     @Fold
571     public static int biasedLockPattern(@InjectedParameter GraalHotSpotVMConfig config) {
572         return config.biasedLockPattern;
573     }
574 
575     @Fold
576     public static int ageMaskInPlace(@InjectedParameter GraalHotSpotVMConfig config) {
577         return config.ageMaskInPlace;
578     }
579 
580     @Fold
581     public static int metaspaceArrayLengthOffset(@InjectedParameter GraalHotSpotVMConfig config) {
582         return config.metaspaceArrayLengthOffset;
583     }
584 
585     @Fold
586     public static int metaspaceArrayBaseOffset(@InjectedParameter GraalHotSpotVMConfig config) {
587         return config.metaspaceArrayBaseOffset;
588     }
589 
590     @Fold
591     public static int arrayLengthOffset(@InjectedParameter GraalHotSpotVMConfig config) {
592         return config.arrayOopDescLengthOffset();
593     }
594 
595     public static Word arrayStart(int[] a) {
596         return WordFactory.unsigned(ComputeObjectAddressNode.get(a, ReplacementsUtil.getArrayBaseOffset(INJECTED_METAACCESS, JavaKind.Int)));
597     }
598 
599     /**
600      * Idiom for making {@link GraalHotSpotVMConfig} a constant.
601      */
602     @Fold
603     public static int objectAlignment(@InjectedParameter GraalHotSpotVMConfig config) {
604         return config.objectAlignment;
605     }
606 
607     @Fold
608     public static int instanceHeaderSize(@InjectedParameter GraalHotSpotVMConfig config) {
609         return config.useCompressedClassPointers ? (2 * wordSize()) - 4 : 2 * wordSize();
610     }
611 
612     @Fold
613     public static byte dirtyCardValue(@InjectedParameter GraalHotSpotVMConfig config) {
614         return config.dirtyCardValue;
615     }
616 
617     @Fold
618     public static byte g1YoungCardValue(@InjectedParameter GraalHotSpotVMConfig config) {
619         return config.g1YoungCardValue;
620     }
621 
622     @Fold
623     public static int cardTableShift(@InjectedParameter GraalHotSpotVMConfig config) {
624         return config.cardtableShift;
625     }
626 
627     @Fold
628     public static int g1CardQueueIndexOffset(@InjectedParameter GraalHotSpotVMConfig config) {
629         return config.g1CardQueueIndexOffset;
630     }
631 
632     @Fold
633     public static int g1CardQueueBufferOffset(@InjectedParameter GraalHotSpotVMConfig config) {
634         return config.g1CardQueueBufferOffset;
635     }
636 
637     @Fold
638     public static int g1SATBQueueMarkingOffset(@InjectedParameter GraalHotSpotVMConfig config) {
639         return config.g1SATBQueueMarkingOffset;
640     }
641 
642     @Fold
643     public static int g1SATBQueueIndexOffset(@InjectedParameter GraalHotSpotVMConfig config) {
644         return config.g1SATBQueueIndexOffset;
645     }
646 
647     @Fold
648     public static int g1SATBQueueBufferOffset(@InjectedParameter GraalHotSpotVMConfig config) {
649         return config.g1SATBQueueBufferOffset;
650     }
651 
652     public static final LocationIdentity KLASS_SUPER_CHECK_OFFSET_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_super_check_offset&quot;);
653 
654     @Fold
655     public static int superCheckOffsetOffset(@InjectedParameter GraalHotSpotVMConfig config) {
656         return config.superCheckOffsetOffset;
657     }
658 
659     public static final LocationIdentity SECONDARY_SUPER_CACHE_LOCATION = NamedLocationIdentity.mutable(&quot;SecondarySuperCache&quot;);
660 
661     @Fold
662     public static int secondarySuperCacheOffset(@InjectedParameter GraalHotSpotVMConfig config) {
663         return config.secondarySuperCacheOffset;
664     }
665 
666     public static final LocationIdentity SECONDARY_SUPERS_LOCATION = NamedLocationIdentity.immutable(&quot;SecondarySupers&quot;);
667 
668     @Fold
669     public static int secondarySupersOffset(@InjectedParameter GraalHotSpotVMConfig config) {
670         return config.secondarySupersOffset;
671     }
672 
673     public static final LocationIdentity DISPLACED_MARK_WORD_LOCATION = NamedLocationIdentity.mutable(&quot;DisplacedMarkWord&quot;);
674 
675     public static final LocationIdentity OBJECT_MONITOR_OWNER_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_owner&quot;);
676 
677     public static final LocationIdentity OBJECT_MONITOR_RECURSION_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_recursions&quot;);
678 
679     public static final LocationIdentity OBJECT_MONITOR_CXQ_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_cxq&quot;);
680 
681     public static final LocationIdentity OBJECT_MONITOR_ENTRY_LIST_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_EntryList&quot;);
682 
683     public static final LocationIdentity OBJECT_MONITOR_SUCC_LOCATION = NamedLocationIdentity.mutable(&quot;ObjectMonitor::_succ&quot;);
684 
685     @Fold
686     public static int lockDisplacedMarkOffset(@InjectedParameter GraalHotSpotVMConfig config) {
687         return config.basicLockDisplacedHeaderOffset;
688     }
689 
690     @Fold
691     public static boolean useBiasedLocking(@InjectedParameter GraalHotSpotVMConfig config) {
692         return config.useBiasedLocking;
693     }
694 
695     @Fold
696     static int uninitializedIdentityHashCodeValue(@InjectedParameter GraalHotSpotVMConfig config) {
697         return config.uninitializedIdentityHashCodeValue;
698     }
699 
700     @Fold
701     static int identityHashCodeShift(@InjectedParameter GraalHotSpotVMConfig config) {
702         return config.identityHashCodeShift;
703     }
704 
705     /**
706      * Loads the hub of an object (without null checking it first).
707      */
708     public static KlassPointer loadHub(Object object) {
709         return loadHubIntrinsic(object);
710     }
711 
712     public static Object verifyOop(Object object) {
713         if (verifyOops(INJECTED_VMCONFIG)) {
714             verifyOopStub(VERIFY_OOP, object);
715         }
716         return object;
717     }
718 
719     @NodeIntrinsic(ForeignCallNode.class)
720     private static native Object verifyOopStub(@ConstantNodeParameter ForeignCallDescriptor descriptor, Object object);
721 
722     public static Word loadWordFromObject(Object object, int offset) {
723         ReplacementsUtil.staticAssert(offset != hubOffset(INJECTED_VMCONFIG), &quot;Use loadHubIntrinsic instead of loadWordFromObject&quot;);
724         return loadWordFromObjectIntrinsic(object, offset, LocationIdentity.any(), getWordKind());
725     }
726 
727     public static Word loadWordFromObject(Object object, int offset, LocationIdentity identity) {
728         ReplacementsUtil.staticAssert(offset != hubOffset(INJECTED_VMCONFIG), &quot;Use loadHubIntrinsic instead of loadWordFromObject&quot;);
729         return loadWordFromObjectIntrinsic(object, offset, identity, getWordKind());
730     }
731 
732     public static KlassPointer loadKlassFromObject(Object object, int offset, LocationIdentity identity) {
733         ReplacementsUtil.staticAssert(offset != hubOffset(INJECTED_VMCONFIG), &quot;Use loadHubIntrinsic instead of loadKlassFromObject&quot;);
734         return loadKlassFromObjectIntrinsic(object, offset, identity, getWordKind());
735     }
736 
737     /**
738      * Reads the value of a given register.
739      *
740      * @param register a register which must not be available to the register allocator
741      * @return the value of {@code register} as a word
742      */
743     public static Word registerAsWord(@ConstantNodeParameter Register register) {
744         return registerAsWord(register, true, false);
745     }
746 
747     @NodeIntrinsic(value = ReadRegisterNode.class)
748     public static native Word registerAsWord(@ConstantNodeParameter Register register, @ConstantNodeParameter boolean directUse, @ConstantNodeParameter boolean incoming);
749 
750     @NodeIntrinsic(value = WriteRegisterNode.class)
751     public static native void writeRegisterAsWord(@ConstantNodeParameter Register register, Word value);
752 
753     @NodeIntrinsic(value = RawLoadNode.class)
754     private static native Word loadWordFromObjectIntrinsic(Object object, long offset, @ConstantNodeParameter LocationIdentity locationIdentity, @ConstantNodeParameter JavaKind wordKind);
755 
756     @NodeIntrinsic(value = RawLoadNode.class)
757     private static native KlassPointer loadKlassFromObjectIntrinsic(Object object, long offset, @ConstantNodeParameter LocationIdentity locationIdentity, @ConstantNodeParameter JavaKind wordKind);
758 
759     @NodeIntrinsic(value = LoadHubNode.class)
760     public static native KlassPointer loadHubIntrinsic(Object object);
761 
762     @NodeIntrinsic(value = LoadHubOrNullNode.class)
763     public static native KlassPointer loadHubOrNullIntrinsic(Object object);
764 
765     static final LocationIdentity CLASS_INIT_STATE_LOCATION = NamedLocationIdentity.mutable(&quot;ClassInitState&quot;);
766 
767     static final LocationIdentity CLASS_INIT_THREAD_LOCATION = NamedLocationIdentity.mutable(&quot;ClassInitThread&quot;);
768 
769     @Fold
770     static int instanceKlassInitStateOffset(@InjectedParameter GraalHotSpotVMConfig config) {
771         return config.instanceKlassInitStateOffset;
772     }
773 
774     @Fold
775     static int instanceKlassInitThreadOffset(@InjectedParameter GraalHotSpotVMConfig config) {
776         assert config.instanceKlassInitThreadOffset != -1;
777         return config.instanceKlassInitThreadOffset;
778     }
779 
780     @Fold
781     public static int instanceKlassStateFullyInitialized(@InjectedParameter GraalHotSpotVMConfig config) {
782         return config.instanceKlassStateFullyInitialized;
783     }
784 
785     @Fold
786     public static int instanceKlassStateBeingInitialized(@InjectedParameter GraalHotSpotVMConfig config) {
787         assert config.instanceKlassStateBeingInitialized != -1;
788         return config.instanceKlassStateBeingInitialized;
789     }
790 
791     /**
792      *
793      * @param hub the hub of an InstanceKlass
794      * @return true is the InstanceKlass represented by hub is fully initialized
795      */
796     public static boolean isInstanceKlassFullyInitialized(KlassPointer hub) {
797         return readInstanceKlassInitState(hub) == instanceKlassStateFullyInitialized(INJECTED_VMCONFIG);
798     }
799 
800     static byte readInstanceKlassInitState(KlassPointer hub) {
801         return hub.readByte(instanceKlassInitStateOffset(INJECTED_VMCONFIG), CLASS_INIT_STATE_LOCATION);
802     }
803 
804     static Word readInstanceKlassInitThread(KlassPointer hub) {
805         return hub.readWord(instanceKlassInitThreadOffset(INJECTED_VMCONFIG), CLASS_INIT_THREAD_LOCATION);
806     }
807 
808     public static final LocationIdentity KLASS_MODIFIER_FLAGS_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_modifier_flags&quot;);
809 
810     @Fold
811     public static int klassModifierFlagsOffset(@InjectedParameter GraalHotSpotVMConfig config) {
812         return config.klassModifierFlagsOffset;
813     }
814 
815     public static final LocationIdentity CLASS_KLASS_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Class._klass&quot;) {
816         @Override
817         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
818             return foldIndirection(read, object, CLASS_MIRROR_LOCATION);
819         }
820     };
821 
822     public static final LocationIdentity CLASS_ARRAY_KLASS_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;Class._array_klass&quot;) {
823         @Override
824         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
825             return foldIndirection(read, object, ARRAY_KLASS_COMPONENT_MIRROR);
826         }
827     };
828 
829     @Fold
830     public static int arrayKlassOffset(@InjectedParameter GraalHotSpotVMConfig config) {
831         return config.arrayKlassOffset;
832     }
833 
834     public static final LocationIdentity CLASS_MIRROR_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_java_mirror&quot;);
835 
836     public static final LocationIdentity CLASS_MIRROR_HANDLE_LOCATION = NamedLocationIdentity.immutable(&quot;Klass::_java_mirror handle&quot;);
837 
838     @Fold
839     public static int layoutHelperHeaderSizeShift(@InjectedParameter GraalHotSpotVMConfig config) {
840         return config.layoutHelperHeaderSizeShift;
841     }
842 
843     @Fold
844     public static int layoutHelperHeaderSizeMask(@InjectedParameter GraalHotSpotVMConfig config) {
845         return config.layoutHelperHeaderSizeMask;
846     }
847 
848     @Fold
849     public static int layoutHelperLog2ElementSizeShift(@InjectedParameter GraalHotSpotVMConfig config) {
850         return config.layoutHelperLog2ElementSizeShift;
851     }
852 
853     @Fold
854     public static int layoutHelperLog2ElementSizeMask(@InjectedParameter GraalHotSpotVMConfig config) {
855         return config.layoutHelperLog2ElementSizeMask;
856     }
857 
858     @NodeIntrinsic(ForeignCallNode.class)
859     public static native int identityHashCode(@ConstantNodeParameter ForeignCallDescriptor descriptor, Object object);
860 
861     @Fold
862     public static long gcTotalCollectionsAddress(@InjectedParameter GraalHotSpotVMConfig config) {
863         return config.gcTotalCollectionsAddress();
864     }
865 
866     @Fold
867     public static long referentOffset(@InjectedParameter MetaAccessProvider metaAccessProvider) {
<a name="3" id="anc3"></a><span class="line-modified">868         return getFieldOffset(metaAccessProvider.lookupJavaType(Reference.class), &quot;referent&quot;);</span>





869     }
870 
871     @Fold
872     public static ResolvedJavaType referenceType(@InjectedParameter MetaAccessProvider metaAccessProvider) {
873         return metaAccessProvider.lookupJavaType(Reference.class);
874     }
875 
876     public static final LocationIdentity OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;ObjArrayKlass::_element_klass&quot;) {
877         @Override
878         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
879             ValueNode javaObject = findReadHub(object);
880             if (javaObject != null) {
881                 ResolvedJavaType type = StampTool.typeOrNull(javaObject);
882                 if (type != null &amp;&amp; type.isArray()) {
883                     ResolvedJavaType element = type.getComponentType();
884                     if (element != null &amp;&amp; !element.isPrimitive() &amp;&amp; !element.getElementalType().isInterface()) {
885                         Assumptions assumptions = object.graph().getAssumptions();
886                         AssumptionResult&lt;ResolvedJavaType&gt; leafType = element.findLeafConcreteSubtype();
887                         if (leafType != null &amp;&amp; leafType.canRecordTo(assumptions)) {
888                             leafType.recordTo(assumptions);
889                             return ConstantNode.forConstant(read.stamp(NodeView.DEFAULT), tool.getConstantReflection().asObjectHub(leafType.getResult()), tool.getMetaAccess());
890                         }
891                     }
892                 }
893             }
894             return read;
895         }
896     };
897 
898     @Fold
899     public static int arrayClassElementOffset(@InjectedParameter GraalHotSpotVMConfig config) {
900         return config.arrayClassElementOffset;
901     }
902 
903     public static final LocationIdentity PRIMARY_SUPERS_LOCATION = NamedLocationIdentity.immutable(&quot;PrimarySupers&quot;);
904 
905     public static final LocationIdentity METASPACE_ARRAY_LENGTH_LOCATION = NamedLocationIdentity.immutable(&quot;MetaspaceArrayLength&quot;);
906 
907     public static final LocationIdentity SECONDARY_SUPERS_ELEMENT_LOCATION = NamedLocationIdentity.immutable(&quot;SecondarySupersElement&quot;);
908 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
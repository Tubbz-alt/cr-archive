diff a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/gc/G1BarrierSet.java b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/gc/G1BarrierSet.java
--- a/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/gc/G1BarrierSet.java
+++ b/src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/gc/G1BarrierSet.java
@@ -30,45 +30,50 @@
 import org.graalvm.compiler.nodes.NodeView;
 import org.graalvm.compiler.nodes.StructuredGraph;
 import org.graalvm.compiler.nodes.ValueNode;
 import org.graalvm.compiler.nodes.extended.ArrayRangeWrite;
 import org.graalvm.compiler.nodes.extended.RawLoadNode;
+import org.graalvm.compiler.nodes.extended.RawStoreNode;
 import org.graalvm.compiler.nodes.java.AbstractCompareAndSwapNode;
 import org.graalvm.compiler.nodes.java.LoweredAtomicReadAndWriteNode;
 import org.graalvm.compiler.nodes.memory.FixedAccessNode;
 import org.graalvm.compiler.nodes.memory.OnHeapMemoryAccess.BarrierType;
 import org.graalvm.compiler.nodes.memory.ReadNode;
 import org.graalvm.compiler.nodes.memory.WriteNode;
 import org.graalvm.compiler.nodes.memory.address.AddressNode;
 import org.graalvm.compiler.nodes.type.StampTool;
 
 import jdk.vm.ci.meta.JavaKind;
+import jdk.vm.ci.meta.ResolvedJavaField;
 import jdk.vm.ci.meta.ResolvedJavaType;
 
 public class G1BarrierSet implements BarrierSet {
+    private final ResolvedJavaType objectArrayType;
+    private final ResolvedJavaField referentField;
 
-    private final ResolvedJavaType referenceType;
-    private final long referentFieldOffset;
-
-    public G1BarrierSet(ResolvedJavaType referenceType, long referentFieldOffset) {
-        this.referenceType = referenceType;
-        this.referentFieldOffset = referentFieldOffset;
+    public G1BarrierSet(ResolvedJavaType objectArrayType, ResolvedJavaField referentField) {
+        this.objectArrayType = objectArrayType;
+        this.referentField = referentField;
     }
 
     @Override
     public BarrierType readBarrierType(RawLoadNode load) {
         if (load.object().getStackKind() == JavaKind.Object &&
                         load.accessKind() == JavaKind.Object &&
                         !StampTool.isPointerAlwaysNull(load.object())) {
-            if (load.offset().isJavaConstant() && referentFieldOffset != load.offset().asJavaConstant().asLong()) {
+            long referentOffset = referentField.getOffset();
+            assert referentOffset > 0;
+
+            if (load.offset().isJavaConstant() && referentOffset != load.offset().asJavaConstant().asLong()) {
                 // Reading at a constant offset which is different than the referent field.
                 return BarrierType.NONE;
             }
+            ResolvedJavaType referenceType = referentField.getDeclaringClass();
             ResolvedJavaType type = StampTool.typeOrNull(load.object());
             if (type != null && referenceType.isAssignableFrom(type)) {
                 // It's definitely a field of a Reference type
-                if (load.offset().isJavaConstant() && referentFieldOffset == load.offset().asJavaConstant().asLong()) {
+                if (load.offset().isJavaConstant() && referentOffset == load.offset().asJavaConstant().asLong()) {
                     // Exactly Reference.referent
                     return BarrierType.WEAK_FIELD;
                 }
                 // An unknown offset into Reference
                 return BarrierType.MAYBE_WEAK_FIELD;
@@ -80,10 +85,48 @@
             }
         }
         return BarrierType.NONE;
     }
 
+    @Override
+    public BarrierType storeBarrierType(RawStoreNode store) {
+        return store.needsBarrier() ? guessStoreBarrierType(store.object(), store.value()) : BarrierType.NONE;
+    }
+
+    @Override
+    public BarrierType fieldLoadBarrierType(ResolvedJavaField field, JavaKind storageKind) {
+        if (field.getJavaKind() == JavaKind.Object && field.equals(referentField)) {
+            return BarrierType.WEAK_FIELD;
+        }
+        return BarrierType.NONE;
+    }
+
+    @Override
+    public BarrierType fieldStoreBarrierType(ResolvedJavaField field, JavaKind storageKind) {
+        return storageKind == JavaKind.Object ? BarrierType.FIELD : BarrierType.NONE;
+    }
+
+    @Override
+    public BarrierType arrayStoreBarrierType(JavaKind storageKind) {
+        return storageKind == JavaKind.Object ? BarrierType.ARRAY : BarrierType.NONE;
+    }
+
+    @Override
+    public BarrierType guessStoreBarrierType(ValueNode object, ValueNode value) {
+        if (value.getStackKind() == JavaKind.Object && object.getStackKind() == JavaKind.Object) {
+            ResolvedJavaType type = StampTool.typeOrNull(object);
+            if (type != null && type.isArray()) {
+                return BarrierType.ARRAY;
+            } else if (type == null || type.isAssignableFrom(objectArrayType)) {
+                return BarrierType.UNKNOWN;
+            } else {
+                return BarrierType.FIELD;
+            }
+        }
+        return BarrierType.NONE;
+    }
+
     @Override
     public void addBarriers(FixedAccessNode n) {
         if (n instanceof ReadNode) {
             addReadNodeBarriers((ReadNode) n);
         } else if (n instanceof WriteNode) {
@@ -126,10 +169,12 @@
                         // The pre barrier does nothing if the value being read is null, so it can
                         // be explicitly skipped when this is an initializing store.
                         addG1PreWriteBarrier(node, node.getAddress(), expectedValue, doLoad, nullCheck, graph);
                     }
                     if (writeRequiresPostBarrier(node, writtenValue)) {
+                        // Use a precise barrier for everything that might be an array write. Being
+                        // too precise with the barriers does not cause any correctness issues.
                         boolean precise = barrierType != BarrierType.FIELD;
                         addG1PostWriteBarrier(node, node.getAddress(), writtenValue, precise, graph);
                     }
                 }
                 break;
@@ -137,13 +182,15 @@
                 throw new GraalError("unexpected barrier type: " + barrierType);
         }
     }
 
     @SuppressWarnings("unused")
-    protected boolean writeRequiresPostBarrier(FixedAccessNode initializingWrite, ValueNode writtenValue) {
-        // Without help from the runtime all writes require an explicit post barrier.
-        return true;
+    protected boolean writeRequiresPostBarrier(FixedAccessNode node, ValueNode writtenValue) {
+        // Without help from the runtime all writes (except null writes) require an explicit post
+        // barrier.
+        assert isObjectValue(writtenValue);
+        return !StampTool.isPointerAlwaysNull(writtenValue);
     }
 
     private static void addArrayRangeBarriers(ArrayRangeWrite write) {
         if (write.writesObjectArray()) {
             StructuredGraph graph = write.asNode().graph();

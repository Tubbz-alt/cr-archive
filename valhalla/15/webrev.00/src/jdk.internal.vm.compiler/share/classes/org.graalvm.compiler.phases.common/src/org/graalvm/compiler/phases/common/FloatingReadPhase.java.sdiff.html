<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/FloatingReadPhase.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../org.graalvm.compiler.options/src/org/graalvm/compiler/options/OptionValues.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LoweringPhase.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/FloatingReadPhase.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 48 import org.graalvm.compiler.nodes.LoopEndNode;
 49 import org.graalvm.compiler.nodes.LoopExitNode;
 50 import org.graalvm.compiler.nodes.PhiNode;
 51 import org.graalvm.compiler.nodes.ProxyNode;
 52 import org.graalvm.compiler.nodes.ReturnNode;
 53 import org.graalvm.compiler.nodes.StartNode;
 54 import org.graalvm.compiler.nodes.StructuredGraph;
 55 import org.graalvm.compiler.nodes.ValueNodeUtil;
 56 import org.graalvm.compiler.nodes.calc.FloatingNode;
 57 import org.graalvm.compiler.nodes.cfg.Block;
 58 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
 59 import org.graalvm.compiler.nodes.cfg.HIRLoop;
 60 import org.graalvm.compiler.nodes.memory.FloatableAccessNode;
 61 import org.graalvm.compiler.nodes.memory.FloatingAccessNode;
 62 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
 63 import org.graalvm.compiler.nodes.memory.MemoryAccess;
 64 import org.graalvm.compiler.nodes.memory.MemoryAnchorNode;
 65 import org.graalvm.compiler.nodes.memory.MemoryKill;
 66 import org.graalvm.compiler.nodes.memory.MemoryMap;
 67 import org.graalvm.compiler.nodes.memory.MemoryMapNode;
<span class="line-removed"> 68 import org.graalvm.compiler.nodes.memory.MemoryNode;</span>
 69 import org.graalvm.compiler.nodes.memory.MemoryPhiNode;
 70 import org.graalvm.compiler.nodes.memory.MultiMemoryKill;
 71 import org.graalvm.compiler.nodes.memory.ReadNode;
 72 import org.graalvm.compiler.nodes.memory.SingleMemoryKill;
 73 import org.graalvm.compiler.nodes.util.GraphUtil;
 74 import org.graalvm.compiler.phases.Phase;
 75 import org.graalvm.compiler.phases.common.util.EconomicSetNodeEventListener;
 76 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator;
 77 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator.LoopInfo;
 78 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator.NodeIteratorClosure;
 79 import jdk.internal.vm.compiler.word.LocationIdentity;
 80 
 81 public class FloatingReadPhase extends Phase {
 82 
 83     private boolean createFloatingReads;
 84     private boolean createMemoryMapNodes;
 85 
 86     public static class MemoryMapImpl implements MemoryMap {
 87 
<span class="line-modified"> 88         private final EconomicMap&lt;LocationIdentity, MemoryNode&gt; lastMemorySnapshot;</span>
 89 
 90         public MemoryMapImpl(MemoryMapImpl memoryMap) {
 91             lastMemorySnapshot = EconomicMap.create(Equivalence.DEFAULT, memoryMap.lastMemorySnapshot);
 92         }
 93 
 94         public MemoryMapImpl(StartNode start) {
 95             this();
 96             lastMemorySnapshot.put(any(), start);
 97         }
 98 
 99         public MemoryMapImpl() {
100             lastMemorySnapshot = EconomicMap.create(Equivalence.DEFAULT);
101         }
102 
103         @Override
<span class="line-modified">104         public MemoryNode getLastLocationAccess(LocationIdentity locationIdentity) {</span>
<span class="line-modified">105             MemoryNode lastLocationAccess;</span>
106             if (locationIdentity.isImmutable()) {
107                 return null;
108             } else {
109                 lastLocationAccess = lastMemorySnapshot.get(locationIdentity);
110                 if (lastLocationAccess == null) {
111                     lastLocationAccess = lastMemorySnapshot.get(any());
112                     assert lastLocationAccess != null;
113                 }
114                 return lastLocationAccess;
115             }
116         }
117 
118         @Override
119         public Iterable&lt;LocationIdentity&gt; getLocations() {
120             return lastMemorySnapshot.getKeys();
121         }
122 
<span class="line-modified">123         public EconomicMap&lt;LocationIdentity, MemoryNode&gt; getMap() {</span>
124             return lastMemorySnapshot;
125         }
126     }
127 
128     public FloatingReadPhase() {
129         this(true, false);
130     }
131 
132     /**
133      * @param createFloatingReads specifies whether {@link FloatableAccessNode}s like
134      *            {@link ReadNode} should be converted into floating nodes (e.g.,
135      *            {@link FloatingReadNode}s) where possible
136      * @param createMemoryMapNodes a {@link MemoryMapNode} will be created for each return if this
137      *            is true
138      */
139     public FloatingReadPhase(boolean createFloatingReads, boolean createMemoryMapNodes) {
140         this.createFloatingReads = createFloatingReads;
141         this.createMemoryMapNodes = createMemoryMapNodes;
142     }
143 
</pre>
<hr />
<pre>
236             }
237         }
238         if (createFloatingReads) {
239             assert !graph.isAfterFloatingReadPhase();
240             graph.setAfterFloatingReadPhase(true);
241         }
242     }
243 
244     public static MemoryMapImpl mergeMemoryMaps(AbstractMergeNode merge, List&lt;? extends MemoryMap&gt; states) {
245         MemoryMapImpl newState = new MemoryMapImpl();
246 
247         EconomicSet&lt;LocationIdentity&gt; keys = EconomicSet.create(Equivalence.DEFAULT);
248         for (MemoryMap other : states) {
249             keys.addAll(other.getLocations());
250         }
251         assert checkNoImmutableLocations(keys);
252 
253         for (LocationIdentity key : keys) {
254             int mergedStatesCount = 0;
255             boolean isPhi = false;
<span class="line-modified">256             MemoryNode merged = null;</span>
257             for (MemoryMap state : states) {
<span class="line-modified">258                 MemoryNode last = state.getLastLocationAccess(key);</span>
259                 if (isPhi) {
260                     // Fortify: Suppress Null Deference false positive (`isPhi == true` implies
261                     // `merged != null`)
262                     ((MemoryPhiNode) merged).addInput(ValueNodeUtil.asNode(last));
263                 } else {
264                     if (merged == last) {
265                         // nothing to do
266                     } else if (merged == null) {
267                         merged = last;
268                     } else {
269                         MemoryPhiNode phi = merge.graph().addWithoutUnique(new MemoryPhiNode(merge, key));
270                         for (int j = 0; j &lt; mergedStatesCount; j++) {
271                             phi.addInput(ValueNodeUtil.asNode(merged));
272                         }
273                         phi.addInput(ValueNodeUtil.asNode(last));
274                         merged = phi;
275                         isPhi = true;
276                     }
277                 }
278                 mergedStatesCount++;
</pre>
<hr />
<pre>
335             } else if (node instanceof MultiMemoryKill) {
336                 processCheckpoint((MultiMemoryKill) node, state);
337             }
338             assert nodeOfMemoryType(node) : node;
339 
340             if (createMemoryMapNodes &amp;&amp; node instanceof ReturnNode) {
341                 ((ReturnNode) node).setMemoryMap(node.graph().unique(new MemoryMapNode(state.getMap())));
342             }
343             return state;
344         }
345 
346         /**
347          * Improve the memory graph by re-wiring all usages of a {@link MemoryAnchorNode} to the
348          * real last access location.
349          */
350         private static void processAnchor(MemoryAnchorNode anchor, MemoryMapImpl state) {
351             for (Node node : anchor.usages().snapshot()) {
352                 if (node instanceof MemoryAccess) {
353                     MemoryAccess access = (MemoryAccess) node;
354                     if (access.getLastLocationAccess() == anchor) {
<span class="line-modified">355                         MemoryNode lastLocationAccess = state.getLastLocationAccess(access.getLocationIdentity());</span>
356                         assert lastLocationAccess != null;
357                         access.setLastLocationAccess(lastLocationAccess);
358                     }
359                 }
360             }
361 
362             if (anchor.hasNoUsages()) {
363                 anchor.graph().removeFixed(anchor);
364             }
365         }
366 
367         private static void processAccess(MemoryAccess access, MemoryMapImpl state) {
368             LocationIdentity locationIdentity = access.getLocationIdentity();
369             if (!locationIdentity.equals(LocationIdentity.any())) {
<span class="line-modified">370                 MemoryNode lastLocationAccess = state.getLastLocationAccess(locationIdentity);</span>
371                 access.setLastLocationAccess(lastLocationAccess);
372             }
373         }
374 
375         private static void processCheckpoint(SingleMemoryKill checkpoint, MemoryMapImpl state) {
376             processIdentity(checkpoint.getKilledLocationIdentity(), checkpoint, state);
377         }
378 
379         private static void processCheckpoint(MultiMemoryKill checkpoint, MemoryMapImpl state) {
380             for (LocationIdentity identity : checkpoint.getKilledLocationIdentities()) {
381                 processIdentity(identity, checkpoint, state);
382             }
383         }
384 
385         private static void processIdentity(LocationIdentity identity, MemoryKill checkpoint, MemoryMapImpl state) {
386             if (identity.isAny()) {
387                 state.getMap().clear();
388             }
389             if (identity.isMutable()) {
390                 state.getMap().put(identity, checkpoint);
391             }
392         }
393 
394         @SuppressWarnings(&quot;try&quot;)
395         private static void processFloatable(FloatableAccessNode accessNode, MemoryMapImpl state) {
396             StructuredGraph graph = accessNode.graph();
397             LocationIdentity locationIdentity = accessNode.getLocationIdentity();
398             if (accessNode.canFloat()) {
399                 assert accessNode.getNullCheck() == false;
<span class="line-modified">400                 MemoryNode lastLocationAccess = state.getLastLocationAccess(locationIdentity);</span>
401                 try (DebugCloseable position = accessNode.withNodeSourcePosition()) {
402                     FloatingAccessNode floatingNode = accessNode.asFloatingNode();
403                     assert floatingNode.getLastLocationAccess() == lastLocationAccess;
404                     graph.replaceFixedWithFloating(accessNode, floatingNode);
405                 }
406             }
407         }
408 
409         @Override
410         protected MemoryMapImpl merge(AbstractMergeNode merge, List&lt;MemoryMapImpl&gt; states) {
411             return mergeMemoryMaps(merge, states);
412         }
413 
414         @Override
415         protected MemoryMapImpl afterSplit(AbstractBeginNode node, MemoryMapImpl oldState) {
416             MemoryMapImpl result = new MemoryMapImpl(oldState);
417             if (node.predecessor() instanceof InvokeWithExceptionNode) {
418                 /*
419                  * InvokeWithException cannot be the lastLocationAccess for a FloatingReadNode.
420                  * Since it is both the invoke and a control flow split, the scheduler cannot
</pre>
</td>
<td>
<hr />
<pre>
 48 import org.graalvm.compiler.nodes.LoopEndNode;
 49 import org.graalvm.compiler.nodes.LoopExitNode;
 50 import org.graalvm.compiler.nodes.PhiNode;
 51 import org.graalvm.compiler.nodes.ProxyNode;
 52 import org.graalvm.compiler.nodes.ReturnNode;
 53 import org.graalvm.compiler.nodes.StartNode;
 54 import org.graalvm.compiler.nodes.StructuredGraph;
 55 import org.graalvm.compiler.nodes.ValueNodeUtil;
 56 import org.graalvm.compiler.nodes.calc.FloatingNode;
 57 import org.graalvm.compiler.nodes.cfg.Block;
 58 import org.graalvm.compiler.nodes.cfg.ControlFlowGraph;
 59 import org.graalvm.compiler.nodes.cfg.HIRLoop;
 60 import org.graalvm.compiler.nodes.memory.FloatableAccessNode;
 61 import org.graalvm.compiler.nodes.memory.FloatingAccessNode;
 62 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
 63 import org.graalvm.compiler.nodes.memory.MemoryAccess;
 64 import org.graalvm.compiler.nodes.memory.MemoryAnchorNode;
 65 import org.graalvm.compiler.nodes.memory.MemoryKill;
 66 import org.graalvm.compiler.nodes.memory.MemoryMap;
 67 import org.graalvm.compiler.nodes.memory.MemoryMapNode;

 68 import org.graalvm.compiler.nodes.memory.MemoryPhiNode;
 69 import org.graalvm.compiler.nodes.memory.MultiMemoryKill;
 70 import org.graalvm.compiler.nodes.memory.ReadNode;
 71 import org.graalvm.compiler.nodes.memory.SingleMemoryKill;
 72 import org.graalvm.compiler.nodes.util.GraphUtil;
 73 import org.graalvm.compiler.phases.Phase;
 74 import org.graalvm.compiler.phases.common.util.EconomicSetNodeEventListener;
 75 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator;
 76 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator.LoopInfo;
 77 import org.graalvm.compiler.phases.graph.ReentrantNodeIterator.NodeIteratorClosure;
 78 import jdk.internal.vm.compiler.word.LocationIdentity;
 79 
 80 public class FloatingReadPhase extends Phase {
 81 
 82     private boolean createFloatingReads;
 83     private boolean createMemoryMapNodes;
 84 
 85     public static class MemoryMapImpl implements MemoryMap {
 86 
<span class="line-modified"> 87         private final EconomicMap&lt;LocationIdentity, MemoryKill&gt; lastMemorySnapshot;</span>
 88 
 89         public MemoryMapImpl(MemoryMapImpl memoryMap) {
 90             lastMemorySnapshot = EconomicMap.create(Equivalence.DEFAULT, memoryMap.lastMemorySnapshot);
 91         }
 92 
 93         public MemoryMapImpl(StartNode start) {
 94             this();
 95             lastMemorySnapshot.put(any(), start);
 96         }
 97 
 98         public MemoryMapImpl() {
 99             lastMemorySnapshot = EconomicMap.create(Equivalence.DEFAULT);
100         }
101 
102         @Override
<span class="line-modified">103         public MemoryKill getLastLocationAccess(LocationIdentity locationIdentity) {</span>
<span class="line-modified">104             MemoryKill lastLocationAccess;</span>
105             if (locationIdentity.isImmutable()) {
106                 return null;
107             } else {
108                 lastLocationAccess = lastMemorySnapshot.get(locationIdentity);
109                 if (lastLocationAccess == null) {
110                     lastLocationAccess = lastMemorySnapshot.get(any());
111                     assert lastLocationAccess != null;
112                 }
113                 return lastLocationAccess;
114             }
115         }
116 
117         @Override
118         public Iterable&lt;LocationIdentity&gt; getLocations() {
119             return lastMemorySnapshot.getKeys();
120         }
121 
<span class="line-modified">122         public EconomicMap&lt;LocationIdentity, MemoryKill&gt; getMap() {</span>
123             return lastMemorySnapshot;
124         }
125     }
126 
127     public FloatingReadPhase() {
128         this(true, false);
129     }
130 
131     /**
132      * @param createFloatingReads specifies whether {@link FloatableAccessNode}s like
133      *            {@link ReadNode} should be converted into floating nodes (e.g.,
134      *            {@link FloatingReadNode}s) where possible
135      * @param createMemoryMapNodes a {@link MemoryMapNode} will be created for each return if this
136      *            is true
137      */
138     public FloatingReadPhase(boolean createFloatingReads, boolean createMemoryMapNodes) {
139         this.createFloatingReads = createFloatingReads;
140         this.createMemoryMapNodes = createMemoryMapNodes;
141     }
142 
</pre>
<hr />
<pre>
235             }
236         }
237         if (createFloatingReads) {
238             assert !graph.isAfterFloatingReadPhase();
239             graph.setAfterFloatingReadPhase(true);
240         }
241     }
242 
243     public static MemoryMapImpl mergeMemoryMaps(AbstractMergeNode merge, List&lt;? extends MemoryMap&gt; states) {
244         MemoryMapImpl newState = new MemoryMapImpl();
245 
246         EconomicSet&lt;LocationIdentity&gt; keys = EconomicSet.create(Equivalence.DEFAULT);
247         for (MemoryMap other : states) {
248             keys.addAll(other.getLocations());
249         }
250         assert checkNoImmutableLocations(keys);
251 
252         for (LocationIdentity key : keys) {
253             int mergedStatesCount = 0;
254             boolean isPhi = false;
<span class="line-modified">255             MemoryKill merged = null;</span>
256             for (MemoryMap state : states) {
<span class="line-modified">257                 MemoryKill last = state.getLastLocationAccess(key);</span>
258                 if (isPhi) {
259                     // Fortify: Suppress Null Deference false positive (`isPhi == true` implies
260                     // `merged != null`)
261                     ((MemoryPhiNode) merged).addInput(ValueNodeUtil.asNode(last));
262                 } else {
263                     if (merged == last) {
264                         // nothing to do
265                     } else if (merged == null) {
266                         merged = last;
267                     } else {
268                         MemoryPhiNode phi = merge.graph().addWithoutUnique(new MemoryPhiNode(merge, key));
269                         for (int j = 0; j &lt; mergedStatesCount; j++) {
270                             phi.addInput(ValueNodeUtil.asNode(merged));
271                         }
272                         phi.addInput(ValueNodeUtil.asNode(last));
273                         merged = phi;
274                         isPhi = true;
275                     }
276                 }
277                 mergedStatesCount++;
</pre>
<hr />
<pre>
334             } else if (node instanceof MultiMemoryKill) {
335                 processCheckpoint((MultiMemoryKill) node, state);
336             }
337             assert nodeOfMemoryType(node) : node;
338 
339             if (createMemoryMapNodes &amp;&amp; node instanceof ReturnNode) {
340                 ((ReturnNode) node).setMemoryMap(node.graph().unique(new MemoryMapNode(state.getMap())));
341             }
342             return state;
343         }
344 
345         /**
346          * Improve the memory graph by re-wiring all usages of a {@link MemoryAnchorNode} to the
347          * real last access location.
348          */
349         private static void processAnchor(MemoryAnchorNode anchor, MemoryMapImpl state) {
350             for (Node node : anchor.usages().snapshot()) {
351                 if (node instanceof MemoryAccess) {
352                     MemoryAccess access = (MemoryAccess) node;
353                     if (access.getLastLocationAccess() == anchor) {
<span class="line-modified">354                         MemoryKill lastLocationAccess = state.getLastLocationAccess(access.getLocationIdentity());</span>
355                         assert lastLocationAccess != null;
356                         access.setLastLocationAccess(lastLocationAccess);
357                     }
358                 }
359             }
360 
361             if (anchor.hasNoUsages()) {
362                 anchor.graph().removeFixed(anchor);
363             }
364         }
365 
366         private static void processAccess(MemoryAccess access, MemoryMapImpl state) {
367             LocationIdentity locationIdentity = access.getLocationIdentity();
368             if (!locationIdentity.equals(LocationIdentity.any())) {
<span class="line-modified">369                 MemoryKill lastLocationAccess = state.getLastLocationAccess(locationIdentity);</span>
370                 access.setLastLocationAccess(lastLocationAccess);
371             }
372         }
373 
374         private static void processCheckpoint(SingleMemoryKill checkpoint, MemoryMapImpl state) {
375             processIdentity(checkpoint.getKilledLocationIdentity(), checkpoint, state);
376         }
377 
378         private static void processCheckpoint(MultiMemoryKill checkpoint, MemoryMapImpl state) {
379             for (LocationIdentity identity : checkpoint.getKilledLocationIdentities()) {
380                 processIdentity(identity, checkpoint, state);
381             }
382         }
383 
384         private static void processIdentity(LocationIdentity identity, MemoryKill checkpoint, MemoryMapImpl state) {
385             if (identity.isAny()) {
386                 state.getMap().clear();
387             }
388             if (identity.isMutable()) {
389                 state.getMap().put(identity, checkpoint);
390             }
391         }
392 
393         @SuppressWarnings(&quot;try&quot;)
394         private static void processFloatable(FloatableAccessNode accessNode, MemoryMapImpl state) {
395             StructuredGraph graph = accessNode.graph();
396             LocationIdentity locationIdentity = accessNode.getLocationIdentity();
397             if (accessNode.canFloat()) {
398                 assert accessNode.getNullCheck() == false;
<span class="line-modified">399                 MemoryKill lastLocationAccess = state.getLastLocationAccess(locationIdentity);</span>
400                 try (DebugCloseable position = accessNode.withNodeSourcePosition()) {
401                     FloatingAccessNode floatingNode = accessNode.asFloatingNode();
402                     assert floatingNode.getLastLocationAccess() == lastLocationAccess;
403                     graph.replaceFixedWithFloating(accessNode, floatingNode);
404                 }
405             }
406         }
407 
408         @Override
409         protected MemoryMapImpl merge(AbstractMergeNode merge, List&lt;MemoryMapImpl&gt; states) {
410             return mergeMemoryMaps(merge, states);
411         }
412 
413         @Override
414         protected MemoryMapImpl afterSplit(AbstractBeginNode node, MemoryMapImpl oldState) {
415             MemoryMapImpl result = new MemoryMapImpl(oldState);
416             if (node.predecessor() instanceof InvokeWithExceptionNode) {
417                 /*
418                  * InvokeWithException cannot be the lastLocationAccess for a FloatingReadNode.
419                  * Since it is both the invoke and a control flow split, the scheduler cannot
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../org.graalvm.compiler.options/src/org/graalvm/compiler/options/OptionValues.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="LoweringPhase.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
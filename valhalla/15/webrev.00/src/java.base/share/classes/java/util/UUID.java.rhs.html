<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/util/UUID.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.util;
 27 
 28 import java.security.*;
 29 
 30 import jdk.internal.access.JavaLangAccess;
 31 import jdk.internal.access.SharedSecrets;
 32 
 33 /**
 34  * A class that represents an immutable universally unique identifier (UUID).
 35  * A UUID represents a 128-bit value.
 36  *
 37  * &lt;p&gt; There exist different variants of these global identifiers.  The methods
 38  * of this class are for manipulating the Leach-Salz variant, although the
 39  * constructors allow the creation of any variant of UUID (described below).
 40  *
 41  * &lt;p&gt; The layout of a variant 2 (Leach-Salz) UUID is as follows:
 42  *
 43  * The most significant long consists of the following unsigned fields:
 44  * &lt;pre&gt;
 45  * 0xFFFFFFFF00000000 time_low
 46  * 0x00000000FFFF0000 time_mid
 47  * 0x000000000000F000 version
 48  * 0x0000000000000FFF time_hi
 49  * &lt;/pre&gt;
 50  * The least significant long consists of the following unsigned fields:
 51  * &lt;pre&gt;
 52  * 0xC000000000000000 variant
 53  * 0x3FFF000000000000 clock_seq
 54  * 0x0000FFFFFFFFFFFF node
 55  * &lt;/pre&gt;
 56  *
 57  * &lt;p&gt; The variant field contains a value which identifies the layout of the
 58  * {@code UUID}.  The bit layout described above is valid only for a {@code
 59  * UUID} with a variant value of 2, which indicates the Leach-Salz variant.
 60  *
 61  * &lt;p&gt; The version field holds a value that describes the type of this {@code
 62  * UUID}.  There are four different basic types of UUIDs: time-based, DCE
 63  * security, name-based, and randomly generated UUIDs.  These types have a
 64  * version value of 1, 2, 3 and 4, respectively.
 65  *
 66  * &lt;p&gt; For more information including algorithms used to create {@code UUID}s,
 67  * see &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt; &lt;i&gt;RFC&amp;nbsp;4122: A
 68  * Universally Unique IDentifier (UUID) URN Namespace&lt;/i&gt;&lt;/a&gt;, section 4.2
 69  * &amp;quot;Algorithms for Creating a Time-Based UUID&amp;quot;.
 70  *
 71  * @since   1.5
 72  */
 73 public final class UUID implements java.io.Serializable, Comparable&lt;UUID&gt; {
 74 
 75     /**
 76      * Explicit serialVersionUID for interoperability.
 77      */
 78     @java.io.Serial
 79     private static final long serialVersionUID = -4856846361193249489L;
 80 
 81     /*
 82      * The most significant 64 bits of this UUID.
 83      *
 84      * @serial
 85      */
 86     private final long mostSigBits;
 87 
 88     /*
 89      * The least significant 64 bits of this UUID.
 90      *
 91      * @serial
 92      */
 93     private final long leastSigBits;
 94 
 95     private static final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
 96 
 97     /*
 98      * The random number generator used by this class to create random
 99      * based UUIDs. In a holder class to defer initialization until needed.
100      */
101     private static class Holder {
102         static final SecureRandom numberGenerator = new SecureRandom();
103     }
104 
105     // Constructors and Factories
106 
107     /*
108      * Private constructor which uses a byte array to construct the new UUID.
109      */
110     private UUID(byte[] data) {
111         long msb = 0;
112         long lsb = 0;
113         assert data.length == 16 : &quot;data must be 16 bytes in length&quot;;
114         for (int i=0; i&lt;8; i++)
115             msb = (msb &lt;&lt; 8) | (data[i] &amp; 0xff);
116         for (int i=8; i&lt;16; i++)
117             lsb = (lsb &lt;&lt; 8) | (data[i] &amp; 0xff);
118         this.mostSigBits = msb;
119         this.leastSigBits = lsb;
120     }
121 
122     /**
123      * Constructs a new {@code UUID} using the specified data.  {@code
124      * mostSigBits} is used for the most significant 64 bits of the {@code
125      * UUID} and {@code leastSigBits} becomes the least significant 64 bits of
126      * the {@code UUID}.
127      *
128      * @param  mostSigBits
129      *         The most significant bits of the {@code UUID}
130      *
131      * @param  leastSigBits
132      *         The least significant bits of the {@code UUID}
133      */
134     public UUID(long mostSigBits, long leastSigBits) {
135         this.mostSigBits = mostSigBits;
136         this.leastSigBits = leastSigBits;
137     }
138 
139     /**
140      * Static factory to retrieve a type 4 (pseudo randomly generated) UUID.
141      *
142      * The {@code UUID} is generated using a cryptographically strong pseudo
143      * random number generator.
144      *
145      * @return  A randomly generated {@code UUID}
146      */
147     public static UUID randomUUID() {
148         SecureRandom ng = Holder.numberGenerator;
149 
150         byte[] randomBytes = new byte[16];
151         ng.nextBytes(randomBytes);
152         randomBytes[6]  &amp;= 0x0f;  /* clear version        */
153         randomBytes[6]  |= 0x40;  /* set to version 4     */
154         randomBytes[8]  &amp;= 0x3f;  /* clear variant        */
155         randomBytes[8]  |= 0x80;  /* set to IETF variant  */
156         return new UUID(randomBytes);
157     }
158 
159     /**
160      * Static factory to retrieve a type 3 (name based) {@code UUID} based on
161      * the specified byte array.
162      *
163      * @param  name
164      *         A byte array to be used to construct a {@code UUID}
165      *
166      * @return  A {@code UUID} generated from the specified array
167      */
168     public static UUID nameUUIDFromBytes(byte[] name) {
169         MessageDigest md;
170         try {
171             md = MessageDigest.getInstance(&quot;MD5&quot;);
172         } catch (NoSuchAlgorithmException nsae) {
173             throw new InternalError(&quot;MD5 not supported&quot;, nsae);
174         }
175         byte[] md5Bytes = md.digest(name);
176         md5Bytes[6]  &amp;= 0x0f;  /* clear version        */
177         md5Bytes[6]  |= 0x30;  /* set to version 3     */
178         md5Bytes[8]  &amp;= 0x3f;  /* clear variant        */
179         md5Bytes[8]  |= 0x80;  /* set to IETF variant  */
180         return new UUID(md5Bytes);
181     }
182 
<a name="2" id="anc2"></a><span class="line-added">183     private static final byte[] NIBBLES;</span>
<span class="line-added">184     static {</span>
<span class="line-added">185         byte[] ns = new byte[256];</span>
<span class="line-added">186         Arrays.fill(ns, (byte) -1);</span>
<span class="line-added">187         ns[&#39;0&#39;] = 0;</span>
<span class="line-added">188         ns[&#39;1&#39;] = 1;</span>
<span class="line-added">189         ns[&#39;2&#39;] = 2;</span>
<span class="line-added">190         ns[&#39;3&#39;] = 3;</span>
<span class="line-added">191         ns[&#39;4&#39;] = 4;</span>
<span class="line-added">192         ns[&#39;5&#39;] = 5;</span>
<span class="line-added">193         ns[&#39;6&#39;] = 6;</span>
<span class="line-added">194         ns[&#39;7&#39;] = 7;</span>
<span class="line-added">195         ns[&#39;8&#39;] = 8;</span>
<span class="line-added">196         ns[&#39;9&#39;] = 9;</span>
<span class="line-added">197         ns[&#39;A&#39;] = 10;</span>
<span class="line-added">198         ns[&#39;B&#39;] = 11;</span>
<span class="line-added">199         ns[&#39;C&#39;] = 12;</span>
<span class="line-added">200         ns[&#39;D&#39;] = 13;</span>
<span class="line-added">201         ns[&#39;E&#39;] = 14;</span>
<span class="line-added">202         ns[&#39;F&#39;] = 15;</span>
<span class="line-added">203         ns[&#39;a&#39;] = 10;</span>
<span class="line-added">204         ns[&#39;b&#39;] = 11;</span>
<span class="line-added">205         ns[&#39;c&#39;] = 12;</span>
<span class="line-added">206         ns[&#39;d&#39;] = 13;</span>
<span class="line-added">207         ns[&#39;e&#39;] = 14;</span>
<span class="line-added">208         ns[&#39;f&#39;] = 15;</span>
<span class="line-added">209         NIBBLES = ns;</span>
<span class="line-added">210     }</span>
<span class="line-added">211 </span>
<span class="line-added">212     private static long parse4Nibbles(String name, int pos) {</span>
<span class="line-added">213         byte[] ns = NIBBLES;</span>
<span class="line-added">214         char ch1 = name.charAt(pos);</span>
<span class="line-added">215         char ch2 = name.charAt(pos + 1);</span>
<span class="line-added">216         char ch3 = name.charAt(pos + 2);</span>
<span class="line-added">217         char ch4 = name.charAt(pos + 3);</span>
<span class="line-added">218         return (ch1 | ch2 | ch3 | ch4) &gt; 0xff ?</span>
<span class="line-added">219                 -1 : ns[ch1] &lt;&lt; 12 | ns[ch2] &lt;&lt; 8 | ns[ch3] &lt;&lt; 4 | ns[ch4];</span>
<span class="line-added">220     }</span>
<span class="line-added">221 </span>
222     /**
223      * Creates a {@code UUID} from the string standard representation as
224      * described in the {@link #toString} method.
225      *
226      * @param  name
227      *         A string that specifies a {@code UUID}
228      *
229      * @return  A {@code UUID} with the specified value
230      *
231      * @throws  IllegalArgumentException
232      *          If name does not conform to the string representation as
233      *          described in {@link #toString}
234      *
235      */
236     public static UUID fromString(String name) {
<a name="3" id="anc3"></a><span class="line-added">237         if (name.length() == 36) {</span>
<span class="line-added">238             char ch1 = name.charAt(8);</span>
<span class="line-added">239             char ch2 = name.charAt(13);</span>
<span class="line-added">240             char ch3 = name.charAt(18);</span>
<span class="line-added">241             char ch4 = name.charAt(23);</span>
<span class="line-added">242             if (ch1 == &#39;-&#39; &amp;&amp; ch2 == &#39;-&#39; &amp;&amp; ch3 == &#39;-&#39; &amp;&amp; ch4 == &#39;-&#39;) {</span>
<span class="line-added">243                 long msb1 = parse4Nibbles(name, 0);</span>
<span class="line-added">244                 long msb2 = parse4Nibbles(name, 4);</span>
<span class="line-added">245                 long msb3 = parse4Nibbles(name, 9);</span>
<span class="line-added">246                 long msb4 = parse4Nibbles(name, 14);</span>
<span class="line-added">247                 long lsb1 = parse4Nibbles(name, 19);</span>
<span class="line-added">248                 long lsb2 = parse4Nibbles(name, 24);</span>
<span class="line-added">249                 long lsb3 = parse4Nibbles(name, 28);</span>
<span class="line-added">250                 long lsb4 = parse4Nibbles(name, 32);</span>
<span class="line-added">251                 if ((msb1 | msb2 | msb3 | msb4 | lsb1 | lsb2 | lsb3 | lsb4) &gt;= 0) {</span>
<span class="line-added">252                     return new UUID(</span>
<span class="line-added">253                             msb1 &lt;&lt; 48 | msb2 &lt;&lt; 32 | msb3 &lt;&lt; 16 | msb4,</span>
<span class="line-added">254                             lsb1 &lt;&lt; 48 | lsb2 &lt;&lt; 32 | lsb3 &lt;&lt; 16 | lsb4);</span>
<span class="line-added">255                 }</span>
<span class="line-added">256             }</span>
<span class="line-added">257         }</span>
<span class="line-added">258         return fromString1(name);</span>
<span class="line-added">259     }</span>
<span class="line-added">260 </span>
<span class="line-added">261     private static UUID fromString1(String name) {</span>
262         int len = name.length();
263         if (len &gt; 36) {
264             throw new IllegalArgumentException(&quot;UUID string too large&quot;);
265         }
266 
267         int dash1 = name.indexOf(&#39;-&#39;, 0);
268         int dash2 = name.indexOf(&#39;-&#39;, dash1 + 1);
269         int dash3 = name.indexOf(&#39;-&#39;, dash2 + 1);
270         int dash4 = name.indexOf(&#39;-&#39;, dash3 + 1);
271         int dash5 = name.indexOf(&#39;-&#39;, dash4 + 1);
272 
273         // For any valid input, dash1 through dash4 will be positive and dash5
274         // negative, but it&#39;s enough to check dash4 and dash5:
275         // - if dash1 is -1, dash4 will be -1
276         // - if dash1 is positive but dash2 is -1, dash4 will be -1
277         // - if dash1 and dash2 is positive, dash3 will be -1, dash4 will be
278         //   positive, but so will dash5
279         if (dash4 &lt; 0 || dash5 &gt;= 0) {
280             throw new IllegalArgumentException(&quot;Invalid UUID string: &quot; + name);
281         }
282 
283         long mostSigBits = Long.parseLong(name, 0, dash1, 16) &amp; 0xffffffffL;
284         mostSigBits &lt;&lt;= 16;
285         mostSigBits |= Long.parseLong(name, dash1 + 1, dash2, 16) &amp; 0xffffL;
286         mostSigBits &lt;&lt;= 16;
287         mostSigBits |= Long.parseLong(name, dash2 + 1, dash3, 16) &amp; 0xffffL;
288         long leastSigBits = Long.parseLong(name, dash3 + 1, dash4, 16) &amp; 0xffffL;
289         leastSigBits &lt;&lt;= 48;
290         leastSigBits |= Long.parseLong(name, dash4 + 1, len, 16) &amp; 0xffffffffffffL;
291 
292         return new UUID(mostSigBits, leastSigBits);
293     }
294 
295     // Field Accessor Methods
296 
297     /**
298      * Returns the least significant 64 bits of this UUID&#39;s 128 bit value.
299      *
300      * @return  The least significant 64 bits of this UUID&#39;s 128 bit value
301      */
302     public long getLeastSignificantBits() {
303         return leastSigBits;
304     }
305 
306     /**
307      * Returns the most significant 64 bits of this UUID&#39;s 128 bit value.
308      *
309      * @return  The most significant 64 bits of this UUID&#39;s 128 bit value
310      */
311     public long getMostSignificantBits() {
312         return mostSigBits;
313     }
314 
315     /**
316      * The version number associated with this {@code UUID}.  The version
317      * number describes how this {@code UUID} was generated.
318      *
319      * The version number has the following meaning:
320      * &lt;ul&gt;
321      * &lt;li&gt;1    Time-based UUID
322      * &lt;li&gt;2    DCE security UUID
323      * &lt;li&gt;3    Name-based UUID
324      * &lt;li&gt;4    Randomly generated UUID
325      * &lt;/ul&gt;
326      *
327      * @return  The version number of this {@code UUID}
328      */
329     public int version() {
330         // Version is bits masked by 0x000000000000F000 in MS long
331         return (int)((mostSigBits &gt;&gt; 12) &amp; 0x0f);
332     }
333 
334     /**
335      * The variant number associated with this {@code UUID}.  The variant
336      * number describes the layout of the {@code UUID}.
337      *
338      * The variant number has the following meaning:
339      * &lt;ul&gt;
340      * &lt;li&gt;0    Reserved for NCS backward compatibility
341      * &lt;li&gt;2    &lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot;&gt;IETF&amp;nbsp;RFC&amp;nbsp;4122&lt;/a&gt;
342      * (Leach-Salz), used by this class
343      * &lt;li&gt;6    Reserved, Microsoft Corporation backward compatibility
344      * &lt;li&gt;7    Reserved for future definition
345      * &lt;/ul&gt;
346      *
347      * @return  The variant number of this {@code UUID}
348      */
349     public int variant() {
350         // This field is composed of a varying number of bits.
351         // 0    -    -    Reserved for NCS backward compatibility
352         // 1    0    -    The IETF aka Leach-Salz variant (used by this class)
353         // 1    1    0    Reserved, Microsoft backward compatibility
354         // 1    1    1    Reserved for future definition.
355         return (int) ((leastSigBits &gt;&gt;&gt; (64 - (leastSigBits &gt;&gt;&gt; 62)))
356                       &amp; (leastSigBits &gt;&gt; 63));
357     }
358 
359     /**
360      * The timestamp value associated with this UUID.
361      *
362      * &lt;p&gt; The 60 bit timestamp value is constructed from the time_low,
363      * time_mid, and time_hi fields of this {@code UUID}.  The resulting
364      * timestamp is measured in 100-nanosecond units since midnight,
365      * October 15, 1582 UTC.
366      *
367      * &lt;p&gt; The timestamp value is only meaningful in a time-based UUID, which
368      * has version type 1.  If this {@code UUID} is not a time-based UUID then
369      * this method throws UnsupportedOperationException.
370      *
371      * @throws UnsupportedOperationException
372      *         If this UUID is not a version 1 UUID
373      * @return The timestamp of this {@code UUID}.
374      */
375     public long timestamp() {
376         if (version() != 1) {
377             throw new UnsupportedOperationException(&quot;Not a time-based UUID&quot;);
378         }
379 
380         return (mostSigBits &amp; 0x0FFFL) &lt;&lt; 48
381              | ((mostSigBits &gt;&gt; 16) &amp; 0x0FFFFL) &lt;&lt; 32
382              | mostSigBits &gt;&gt;&gt; 32;
383     }
384 
385     /**
386      * The clock sequence value associated with this UUID.
387      *
388      * &lt;p&gt; The 14 bit clock sequence value is constructed from the clock
389      * sequence field of this UUID.  The clock sequence field is used to
390      * guarantee temporal uniqueness in a time-based UUID.
391      *
392      * &lt;p&gt; The {@code clockSequence} value is only meaningful in a time-based
393      * UUID, which has version type 1.  If this UUID is not a time-based UUID
394      * then this method throws UnsupportedOperationException.
395      *
396      * @return  The clock sequence of this {@code UUID}
397      *
398      * @throws  UnsupportedOperationException
399      *          If this UUID is not a version 1 UUID
400      */
401     public int clockSequence() {
402         if (version() != 1) {
403             throw new UnsupportedOperationException(&quot;Not a time-based UUID&quot;);
404         }
405 
406         return (int)((leastSigBits &amp; 0x3FFF000000000000L) &gt;&gt;&gt; 48);
407     }
408 
409     /**
410      * The node value associated with this UUID.
411      *
412      * &lt;p&gt; The 48 bit node value is constructed from the node field of this
413      * UUID.  This field is intended to hold the IEEE 802 address of the machine
414      * that generated this UUID to guarantee spatial uniqueness.
415      *
416      * &lt;p&gt; The node value is only meaningful in a time-based UUID, which has
417      * version type 1.  If this UUID is not a time-based UUID then this method
418      * throws UnsupportedOperationException.
419      *
420      * @return  The node value of this {@code UUID}
421      *
422      * @throws  UnsupportedOperationException
423      *          If this UUID is not a version 1 UUID
424      */
425     public long node() {
426         if (version() != 1) {
427             throw new UnsupportedOperationException(&quot;Not a time-based UUID&quot;);
428         }
429 
430         return leastSigBits &amp; 0x0000FFFFFFFFFFFFL;
431     }
432 
433     // Object Inherited Methods
434 
435     /**
436      * Returns a {@code String} object representing this {@code UUID}.
437      *
438      * &lt;p&gt; The UUID string representation is as described by this BNF:
439      * &lt;blockquote&gt;&lt;pre&gt;
440      * {@code
441      * UUID                   = &lt;time_low&gt; &quot;-&quot; &lt;time_mid&gt; &quot;-&quot;
442      *                          &lt;time_high_and_version&gt; &quot;-&quot;
443      *                          &lt;variant_and_sequence&gt; &quot;-&quot;
444      *                          &lt;node&gt;
445      * time_low               = 4*&lt;hexOctet&gt;
446      * time_mid               = 2*&lt;hexOctet&gt;
447      * time_high_and_version  = 2*&lt;hexOctet&gt;
448      * variant_and_sequence   = 2*&lt;hexOctet&gt;
449      * node                   = 6*&lt;hexOctet&gt;
450      * hexOctet               = &lt;hexDigit&gt;&lt;hexDigit&gt;
451      * hexDigit               =
452      *       &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot;
453      *       | &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;f&quot;
454      *       | &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot;
455      * }&lt;/pre&gt;&lt;/blockquote&gt;
456      *
457      * @return  A string representation of this {@code UUID}
458      */
459     public String toString() {
460         return jla.fastUUID(leastSigBits, mostSigBits);
461     }
462 
463     /**
464      * Returns a hash code for this {@code UUID}.
465      *
466      * @return  A hash code value for this {@code UUID}
467      */
468     public int hashCode() {
469         long hilo = mostSigBits ^ leastSigBits;
470         return ((int)(hilo &gt;&gt; 32)) ^ (int) hilo;
471     }
472 
473     /**
474      * Compares this object to the specified object.  The result is {@code
475      * true} if and only if the argument is not {@code null}, is a {@code UUID}
476      * object, has the same variant, and contains the same value, bit for bit,
477      * as this {@code UUID}.
478      *
479      * @param  obj
480      *         The object to be compared
481      *
482      * @return  {@code true} if the objects are the same; {@code false}
483      *          otherwise
484      */
485     public boolean equals(Object obj) {
486         if ((null == obj) || (obj.getClass() != UUID.class))
487             return false;
488         UUID id = (UUID)obj;
489         return (mostSigBits == id.mostSigBits &amp;&amp;
490                 leastSigBits == id.leastSigBits);
491     }
492 
493     // Comparison Operations
494 
495     /**
496      * Compares this UUID with the specified UUID.
497      *
498      * &lt;p&gt; The first of two UUIDs is greater than the second if the most
499      * significant field in which the UUIDs differ is greater for the first
500      * UUID.
501      *
502      * @param  val
503      *         {@code UUID} to which this {@code UUID} is to be compared
504      *
505      * @return  -1, 0 or 1 as this {@code UUID} is less than, equal to, or
506      *          greater than {@code val}
507      *
508      */
509     public int compareTo(UUID val) {
510         // The ordering is intentionally set up so that the UUIDs
511         // can simply be numerically compared as two numbers
512         return (this.mostSigBits &lt; val.mostSigBits ? -1 :
513                 (this.mostSigBits &gt; val.mostSigBits ? 1 :
514                  (this.leastSigBits &lt; val.leastSigBits ? -1 :
515                   (this.leastSigBits &gt; val.leastSigBits ? 1 :
516                    0))));
517     }
518 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
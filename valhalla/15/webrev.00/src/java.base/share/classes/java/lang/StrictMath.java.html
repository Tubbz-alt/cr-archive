<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/lang/StrictMath.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.util.Random;
  29 import jdk.internal.math.DoubleConsts;
  30 import jdk.internal.HotSpotIntrinsicCandidate;
  31 
  32 /**
  33  * The class {@code StrictMath} contains methods for performing basic
  34  * numeric operations such as the elementary exponential, logarithm,
  35  * square root, and trigonometric functions.
  36  *
  37  * &lt;p&gt;To help ensure portability of Java programs, the definitions of
  38  * some of the numeric functions in this package require that they
  39  * produce the same results as certain published algorithms. These
  40  * algorithms are available from the well-known network library
  41  * {@code netlib} as the package &quot;Freely Distributable Math
  42  * Library,&quot; &lt;a
  43  * href=&quot;https://www.netlib.org/fdlibm/&quot;&gt;{@code fdlibm}&lt;/a&gt;. These
  44  * algorithms, which are written in the C programming language, are
  45  * then to be understood as executed with all floating-point
  46  * operations following the rules of Java floating-point arithmetic.
  47  *
  48  * &lt;p&gt;The Java math library is defined with respect to
  49  * {@code fdlibm} version 5.3. Where {@code fdlibm} provides
  50  * more than one definition for a function (such as
  51  * {@code acos}), use the &quot;IEEE 754 core function&quot; version
  52  * (residing in a file whose name begins with the letter
  53  * {@code e}).  The methods which require {@code fdlibm}
  54  * semantics are {@code sin}, {@code cos}, {@code tan},
  55  * {@code asin}, {@code acos}, {@code atan},
  56  * {@code exp}, {@code log}, {@code log10},
  57  * {@code cbrt}, {@code atan2}, {@code pow},
  58  * {@code sinh}, {@code cosh}, {@code tanh},
  59  * {@code hypot}, {@code expm1}, and {@code log1p}.
  60  *
  61  * &lt;p&gt;
  62  * The platform uses signed two&#39;s complement integer arithmetic with
  63  * int and long primitive types.  The developer should choose
  64  * the primitive type to ensure that arithmetic operations consistently
  65  * produce correct results, which in some cases means the operations
  66  * will not overflow the range of values of the computation.
  67  * The best practice is to choose the primitive type and algorithm to avoid
  68  * overflow. In cases where the size is {@code int} or {@code long} and
  69  * overflow errors need to be detected, the methods {@code addExact},
  70  * {@code subtractExact}, {@code multiplyExact}, {@code toIntExact},
  71  * {@code incrementExact}, {@code decrementExact} and {@code negateExact}
  72  * throw an {@code ArithmeticException} when the results overflow.
  73  * For the arithmetic operations divide and absolute value, overflow
  74  * occurs only with a specific minimum or maximum value and
  75  * should be checked against the minimum or maximum as appropriate.
  76  *
  77  * @author  unascribed
  78  * @author  Joseph D. Darcy
  79  * @since   1.3
  80  */
  81 
  82 public final class StrictMath {
  83 
  84     /**
  85      * Don&#39;t let anyone instantiate this class.
  86      */
  87     private StrictMath() {}
  88 
  89     /**
  90      * The {@code double} value that is closer than any other to
  91      * &lt;i&gt;e&lt;/i&gt;, the base of the natural logarithms.
  92      */
  93     public static final double E = 2.7182818284590452354;
  94 
  95     /**
  96      * The {@code double} value that is closer than any other to
  97      * &lt;i&gt;pi&lt;/i&gt;, the ratio of the circumference of a circle to its
  98      * diameter.
  99      */
 100     public static final double PI = 3.14159265358979323846;
 101 
 102     /**
 103      * Constant by which to multiply an angular value in degrees to obtain an
 104      * angular value in radians.
 105      */
 106     private static final double DEGREES_TO_RADIANS = 0.017453292519943295;
 107 
 108     /**
 109      * Constant by which to multiply an angular value in radians to obtain an
 110      * angular value in degrees.
 111      */
 112 
 113     private static final double RADIANS_TO_DEGREES = 57.29577951308232;
 114 
 115     /**
 116      * Returns the trigonometric sine of an angle. Special cases:
 117      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the
 118      * result is NaN.
 119      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 120      * same sign as the argument.&lt;/ul&gt;
 121      *
 122      * @param   a   an angle, in radians.
 123      * @return  the sine of the argument.
 124      */
 125     public static native double sin(double a);
 126 
 127     /**
 128      * Returns the trigonometric cosine of an angle. Special cases:
 129      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the
 130      * result is NaN.&lt;/ul&gt;
 131      *
 132      * @param   a   an angle, in radians.
 133      * @return  the cosine of the argument.
 134      */
 135     public static native double cos(double a);
 136 
 137     /**
 138      * Returns the trigonometric tangent of an angle. Special cases:
 139      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or an infinity, then the result
 140      * is NaN.
 141      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 142      * same sign as the argument.&lt;/ul&gt;
 143      *
 144      * @param   a   an angle, in radians.
 145      * @return  the tangent of the argument.
 146      */
 147     public static native double tan(double a);
 148 
 149     /**
 150      * Returns the arc sine of a value; the returned angle is in the
 151      * range -&lt;i&gt;pi&lt;/i&gt;/2 through &lt;i&gt;pi&lt;/i&gt;/2.  Special cases:
 152      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or its absolute value is greater
 153      * than 1, then the result is NaN.
 154      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 155      * same sign as the argument.&lt;/ul&gt;
 156      *
 157      * @param   a   the value whose arc sine is to be returned.
 158      * @return  the arc sine of the argument.
 159      */
 160     public static native double asin(double a);
 161 
 162     /**
 163      * Returns the arc cosine of a value; the returned angle is in the
 164      * range 0.0 through &lt;i&gt;pi&lt;/i&gt;.  Special case:
 165      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or its absolute value is greater
 166      * than 1, then the result is NaN.&lt;/ul&gt;
 167      *
 168      * @param   a   the value whose arc cosine is to be returned.
 169      * @return  the arc cosine of the argument.
 170      */
 171     public static native double acos(double a);
 172 
 173     /**
 174      * Returns the arc tangent of a value; the returned angle is in the
 175      * range -&lt;i&gt;pi&lt;/i&gt;/2 through &lt;i&gt;pi&lt;/i&gt;/2.  Special cases:
 176      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, then the result is NaN.
 177      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 178      * same sign as the argument.&lt;/ul&gt;
 179      *
 180      * @param   a   the value whose arc tangent is to be returned.
 181      * @return  the arc tangent of the argument.
 182      */
 183     public static native double atan(double a);
 184 
 185     /**
 186      * Converts an angle measured in degrees to an approximately
 187      * equivalent angle measured in radians.  The conversion from
 188      * degrees to radians is generally inexact.
 189      *
 190      * @param   angdeg   an angle, in degrees
 191      * @return  the measurement of the angle {@code angdeg}
 192      *          in radians.
 193      */
 194     public static strictfp double toRadians(double angdeg) {
 195         // Do not delegate to Math.toRadians(angdeg) because
 196         // this method has the strictfp modifier.
 197         return angdeg * DEGREES_TO_RADIANS;
 198     }
 199 
 200     /**
 201      * Converts an angle measured in radians to an approximately
 202      * equivalent angle measured in degrees.  The conversion from
 203      * radians to degrees is generally inexact; users should
 204      * &lt;i&gt;not&lt;/i&gt; expect {@code cos(toRadians(90.0))} to exactly
 205      * equal {@code 0.0}.
 206      *
 207      * @param   angrad   an angle, in radians
 208      * @return  the measurement of the angle {@code angrad}
 209      *          in degrees.
 210      */
 211     public static strictfp double toDegrees(double angrad) {
 212         // Do not delegate to Math.toDegrees(angrad) because
 213         // this method has the strictfp modifier.
 214         return angrad * RADIANS_TO_DEGREES;
 215     }
 216 
 217     /**
 218      * Returns Euler&#39;s number &lt;i&gt;e&lt;/i&gt; raised to the power of a
 219      * {@code double} value. Special cases:
 220      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, the result is NaN.
 221      * &lt;li&gt;If the argument is positive infinity, then the result is
 222      * positive infinity.
 223      * &lt;li&gt;If the argument is negative infinity, then the result is
 224      * positive zero.&lt;/ul&gt;
 225      *
 226      * @param   a   the exponent to raise &lt;i&gt;e&lt;/i&gt; to.
 227      * @return  the value &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code a}&lt;/sup&gt;,
 228      *          where &lt;i&gt;e&lt;/i&gt; is the base of the natural logarithms.
 229      */
 230     public static double exp(double a) {
 231         return FdLibm.Exp.compute(a);
 232     }
 233 
 234     /**
 235      * Returns the natural logarithm (base &lt;i&gt;e&lt;/i&gt;) of a {@code double}
 236      * value. Special cases:
 237      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or less than zero, then the result
 238      * is NaN.
 239      * &lt;li&gt;If the argument is positive infinity, then the result is
 240      * positive infinity.
 241      * &lt;li&gt;If the argument is positive zero or negative zero, then the
 242      * result is negative infinity.&lt;/ul&gt;
 243      *
 244      * @param   a   a value
 245      * @return  the value ln&amp;nbsp;{@code a}, the natural logarithm of
 246      *          {@code a}.
 247      */
 248     public static native double log(double a);
 249 
 250     /**
 251      * Returns the base 10 logarithm of a {@code double} value.
 252      * Special cases:
 253      *
 254      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or less than zero, then the result
 255      * is NaN.
 256      * &lt;li&gt;If the argument is positive infinity, then the result is
 257      * positive infinity.
 258      * &lt;li&gt;If the argument is positive zero or negative zero, then the
 259      * result is negative infinity.
 260      * &lt;li&gt; If the argument is equal to 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; for
 261      * integer &lt;i&gt;n&lt;/i&gt;, then the result is &lt;i&gt;n&lt;/i&gt;.
 262      * &lt;/ul&gt;
 263      *
 264      * @param   a   a value
 265      * @return  the base 10 logarithm of  {@code a}.
 266      * @since 1.5
 267      */
 268     public static native double log10(double a);
 269 
 270     /**
 271      * Returns the correctly rounded positive square root of a
 272      * {@code double} value.
 273      * Special cases:
 274      * &lt;ul&gt;&lt;li&gt;If the argument is NaN or less than zero, then the result
 275      * is NaN.
 276      * &lt;li&gt;If the argument is positive infinity, then the result is positive
 277      * infinity.
 278      * &lt;li&gt;If the argument is positive zero or negative zero, then the
 279      * result is the same as the argument.&lt;/ul&gt;
 280      * Otherwise, the result is the {@code double} value closest to
 281      * the true mathematical square root of the argument value.
 282      *
 283      * @param   a   a value.
 284      * @return  the positive square root of {@code a}.
 285      */
 286     @HotSpotIntrinsicCandidate
 287     public static native double sqrt(double a);
 288 
 289     /**
 290      * Returns the cube root of a {@code double} value.  For
 291      * positive finite {@code x}, {@code cbrt(-x) ==
 292      * -cbrt(x)}; that is, the cube root of a negative value is
 293      * the negative of the cube root of that value&#39;s magnitude.
 294      * Special cases:
 295      *
 296      * &lt;ul&gt;
 297      *
 298      * &lt;li&gt;If the argument is NaN, then the result is NaN.
 299      *
 300      * &lt;li&gt;If the argument is infinite, then the result is an infinity
 301      * with the same sign as the argument.
 302      *
 303      * &lt;li&gt;If the argument is zero, then the result is a zero with the
 304      * same sign as the argument.
 305      *
 306      * &lt;/ul&gt;
 307      *
 308      * @param   a   a value.
 309      * @return  the cube root of {@code a}.
 310      * @since 1.5
 311      */
 312     public static double cbrt(double a) {
 313         return FdLibm.Cbrt.compute(a);
 314     }
 315 
 316     /**
 317      * Computes the remainder operation on two arguments as prescribed
 318      * by the IEEE 754 standard.
 319      * The remainder value is mathematically equal to
 320      * &lt;code&gt;f1&amp;nbsp;-&amp;nbsp;f2&lt;/code&gt;&amp;nbsp;&amp;times;&amp;nbsp;&lt;i&gt;n&lt;/i&gt;,
 321      * where &lt;i&gt;n&lt;/i&gt; is the mathematical integer closest to the exact
 322      * mathematical value of the quotient {@code f1/f2}, and if two
 323      * mathematical integers are equally close to {@code f1/f2},
 324      * then &lt;i&gt;n&lt;/i&gt; is the integer that is even. If the remainder is
 325      * zero, its sign is the same as the sign of the first argument.
 326      * Special cases:
 327      * &lt;ul&gt;&lt;li&gt;If either argument is NaN, or the first argument is infinite,
 328      * or the second argument is positive zero or negative zero, then the
 329      * result is NaN.
 330      * &lt;li&gt;If the first argument is finite and the second argument is
 331      * infinite, then the result is the same as the first argument.&lt;/ul&gt;
 332      *
 333      * @param   f1   the dividend.
 334      * @param   f2   the divisor.
 335      * @return  the remainder when {@code f1} is divided by
 336      *          {@code f2}.
 337      */
 338     public static native double IEEEremainder(double f1, double f2);
 339 
 340     /**
 341      * Returns the smallest (closest to negative infinity)
 342      * {@code double} value that is greater than or equal to the
 343      * argument and is equal to a mathematical integer. Special cases:
 344      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a
 345      * mathematical integer, then the result is the same as the
 346      * argument.  &lt;li&gt;If the argument is NaN or an infinity or
 347      * positive zero or negative zero, then the result is the same as
 348      * the argument.  &lt;li&gt;If the argument value is less than zero but
 349      * greater than -1.0, then the result is negative zero.&lt;/ul&gt; Note
 350      * that the value of {@code StrictMath.ceil(x)} is exactly the
 351      * value of {@code -StrictMath.floor(-x)}.
 352      *
 353      * @param   a   a value.
 354      * @return  the smallest (closest to negative infinity)
 355      *          floating-point value that is greater than or equal to
 356      *          the argument and is equal to a mathematical integer.
 357      */
 358     public static double ceil(double a) {
 359         return floorOrCeil(a, -0.0, 1.0, 1.0);
 360     }
 361 
 362     /**
 363      * Returns the largest (closest to positive infinity)
 364      * {@code double} value that is less than or equal to the
 365      * argument and is equal to a mathematical integer. Special cases:
 366      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a
 367      * mathematical integer, then the result is the same as the
 368      * argument.  &lt;li&gt;If the argument is NaN or an infinity or
 369      * positive zero or negative zero, then the result is the same as
 370      * the argument.&lt;/ul&gt;
 371      *
 372      * @param   a   a value.
 373      * @return  the largest (closest to positive infinity)
 374      *          floating-point value that less than or equal to the argument
 375      *          and is equal to a mathematical integer.
 376      */
 377     public static double floor(double a) {
 378         return floorOrCeil(a, -1.0, 0.0, -1.0);
 379     }
 380 
 381     /**
 382      * Internal method to share logic between floor and ceil.
 383      *
 384      * @param a the value to be floored or ceiled
 385      * @param negativeBoundary result for values in (-1, 0)
 386      * @param positiveBoundary result for values in (0, 1)
 387      * @param increment value to add when the argument is non-integral
 388      */
 389     private static double floorOrCeil(double a,
 390                                       double negativeBoundary,
 391                                       double positiveBoundary,
 392                                       double sign) {
 393         int exponent = Math.getExponent(a);
 394 
 395         if (exponent &lt; 0) {
 396             /*
 397              * Absolute value of argument is less than 1.
 398              * floorOrceil(-0.0) =&gt; -0.0
 399              * floorOrceil(+0.0) =&gt; +0.0
 400              */
 401             return ((a == 0.0) ? a :
 402                     ( (a &lt; 0.0) ?  negativeBoundary : positiveBoundary) );
 403         } else if (exponent &gt;= 52) {
 404             /*
 405              * Infinity, NaN, or a value so large it must be integral.
 406              */
 407             return a;
 408         }
 409         // Else the argument is either an integral value already XOR it
 410         // has to be rounded to one.
 411         assert exponent &gt;= 0 &amp;&amp; exponent &lt;= 51;
 412 
 413         long doppel = Double.doubleToRawLongBits(a);
 414         long mask   = DoubleConsts.SIGNIF_BIT_MASK &gt;&gt; exponent;
 415 
 416         if ( (mask &amp; doppel) == 0L )
 417             return a; // integral value
 418         else {
 419             double result = Double.longBitsToDouble(doppel &amp; (~mask));
 420             if (sign*a &gt; 0.0)
 421                 result = result + sign;
 422             return result;
 423         }
 424     }
 425 
 426     /**
 427      * Returns the {@code double} value that is closest in value
 428      * to the argument and is equal to a mathematical integer. If two
 429      * {@code double} values that are mathematical integers are
 430      * equally close to the value of the argument, the result is the
 431      * integer value that is even. Special cases:
 432      * &lt;ul&gt;&lt;li&gt;If the argument value is already equal to a mathematical
 433      * integer, then the result is the same as the argument.
 434      * &lt;li&gt;If the argument is NaN or an infinity or positive zero or negative
 435      * zero, then the result is the same as the argument.&lt;/ul&gt;
 436      *
 437      * @param   a   a value.
 438      * @return  the closest floating-point value to {@code a} that is
 439      *          equal to a mathematical integer.
 440      * @author Joseph D. Darcy
 441      */
 442     public static double rint(double a) {
 443         /*
 444          * If the absolute value of a is not less than 2^52, it
 445          * is either a finite integer (the double format does not have
 446          * enough significand bits for a number that large to have any
 447          * fractional portion), an infinity, or a NaN.  In any of
 448          * these cases, rint of the argument is the argument.
 449          *
 450          * Otherwise, the sum (twoToThe52 + a ) will properly round
 451          * away any fractional portion of a since ulp(twoToThe52) ==
 452          * 1.0; subtracting out twoToThe52 from this sum will then be
 453          * exact and leave the rounded integer portion of a.
 454          *
 455          * This method does *not* need to be declared strictfp to get
 456          * fully reproducible results.  Whether or not a method is
 457          * declared strictfp can only make a difference in the
 458          * returned result if some operation would overflow or
 459          * underflow with strictfp semantics.  The operation
 460          * (twoToThe52 + a ) cannot overflow since large values of a
 461          * are screened out; the add cannot underflow since twoToThe52
 462          * is too large.  The subtraction ((twoToThe52 + a ) -
 463          * twoToThe52) will be exact as discussed above and thus
 464          * cannot overflow or meaningfully underflow.  Finally, the
 465          * last multiply in the return statement is by plus or minus
 466          * 1.0, which is exact too.
 467          */
 468         double twoToThe52 = (double)(1L &lt;&lt; 52); // 2^52
 469         double sign = Math.copySign(1.0, a); // preserve sign info
 470         a = Math.abs(a);
 471 
 472         if (a &lt; twoToThe52) { // E_min &lt;= ilogb(a) &lt;= 51
 473             a = ((twoToThe52 + a ) - twoToThe52);
 474         }
 475 
 476         return sign * a; // restore original sign
 477     }
 478 
 479     /**
 480      * Returns the angle &lt;i&gt;theta&lt;/i&gt; from the conversion of rectangular
 481      * coordinates ({@code x},&amp;nbsp;{@code y}) to polar
 482      * coordinates (r,&amp;nbsp;&lt;i&gt;theta&lt;/i&gt;).
 483      * This method computes the phase &lt;i&gt;theta&lt;/i&gt; by computing an arc tangent
 484      * of {@code y/x} in the range of -&lt;i&gt;pi&lt;/i&gt; to &lt;i&gt;pi&lt;/i&gt;. Special
 485      * cases:
 486      * &lt;ul&gt;&lt;li&gt;If either argument is NaN, then the result is NaN.
 487      * &lt;li&gt;If the first argument is positive zero and the second argument
 488      * is positive, or the first argument is positive and finite and the
 489      * second argument is positive infinity, then the result is positive
 490      * zero.
 491      * &lt;li&gt;If the first argument is negative zero and the second argument
 492      * is positive, or the first argument is negative and finite and the
 493      * second argument is positive infinity, then the result is negative zero.
 494      * &lt;li&gt;If the first argument is positive zero and the second argument
 495      * is negative, or the first argument is positive and finite and the
 496      * second argument is negative infinity, then the result is the
 497      * {@code double} value closest to &lt;i&gt;pi&lt;/i&gt;.
 498      * &lt;li&gt;If the first argument is negative zero and the second argument
 499      * is negative, or the first argument is negative and finite and the
 500      * second argument is negative infinity, then the result is the
 501      * {@code double} value closest to -&lt;i&gt;pi&lt;/i&gt;.
 502      * &lt;li&gt;If the first argument is positive and the second argument is
 503      * positive zero or negative zero, or the first argument is positive
 504      * infinity and the second argument is finite, then the result is the
 505      * {@code double} value closest to &lt;i&gt;pi&lt;/i&gt;/2.
 506      * &lt;li&gt;If the first argument is negative and the second argument is
 507      * positive zero or negative zero, or the first argument is negative
 508      * infinity and the second argument is finite, then the result is the
 509      * {@code double} value closest to -&lt;i&gt;pi&lt;/i&gt;/2.
 510      * &lt;li&gt;If both arguments are positive infinity, then the result is the
 511      * {@code double} value closest to &lt;i&gt;pi&lt;/i&gt;/4.
 512      * &lt;li&gt;If the first argument is positive infinity and the second argument
 513      * is negative infinity, then the result is the {@code double}
 514      * value closest to 3*&lt;i&gt;pi&lt;/i&gt;/4.
 515      * &lt;li&gt;If the first argument is negative infinity and the second argument
 516      * is positive infinity, then the result is the {@code double} value
 517      * closest to -&lt;i&gt;pi&lt;/i&gt;/4.
 518      * &lt;li&gt;If both arguments are negative infinity, then the result is the
 519      * {@code double} value closest to -3*&lt;i&gt;pi&lt;/i&gt;/4.&lt;/ul&gt;
 520      *
 521      * @param   y   the ordinate coordinate
 522      * @param   x   the abscissa coordinate
 523      * @return  the &lt;i&gt;theta&lt;/i&gt; component of the point
 524      *          (&lt;i&gt;r&lt;/i&gt;,&amp;nbsp;&lt;i&gt;theta&lt;/i&gt;)
 525      *          in polar coordinates that corresponds to the point
 526      *          (&lt;i&gt;x&lt;/i&gt;,&amp;nbsp;&lt;i&gt;y&lt;/i&gt;) in Cartesian coordinates.
 527      */
 528     public static native double atan2(double y, double x);
 529 
 530     /**
 531      * Returns the value of the first argument raised to the power of the
 532      * second argument. Special cases:
 533      *
 534      * &lt;ul&gt;&lt;li&gt;If the second argument is positive or negative zero, then the
 535      * result is 1.0.
 536      * &lt;li&gt;If the second argument is 1.0, then the result is the same as the
 537      * first argument.
 538      * &lt;li&gt;If the second argument is NaN, then the result is NaN.
 539      * &lt;li&gt;If the first argument is NaN and the second argument is nonzero,
 540      * then the result is NaN.
 541      *
 542      * &lt;li&gt;If
 543      * &lt;ul&gt;
 544      * &lt;li&gt;the absolute value of the first argument is greater than 1
 545      * and the second argument is positive infinity, or
 546      * &lt;li&gt;the absolute value of the first argument is less than 1 and
 547      * the second argument is negative infinity,
 548      * &lt;/ul&gt;
 549      * then the result is positive infinity.
 550      *
 551      * &lt;li&gt;If
 552      * &lt;ul&gt;
 553      * &lt;li&gt;the absolute value of the first argument is greater than 1 and
 554      * the second argument is negative infinity, or
 555      * &lt;li&gt;the absolute value of the
 556      * first argument is less than 1 and the second argument is positive
 557      * infinity,
 558      * &lt;/ul&gt;
 559      * then the result is positive zero.
 560      *
 561      * &lt;li&gt;If the absolute value of the first argument equals 1 and the
 562      * second argument is infinite, then the result is NaN.
 563      *
 564      * &lt;li&gt;If
 565      * &lt;ul&gt;
 566      * &lt;li&gt;the first argument is positive zero and the second argument
 567      * is greater than zero, or
 568      * &lt;li&gt;the first argument is positive infinity and the second
 569      * argument is less than zero,
 570      * &lt;/ul&gt;
 571      * then the result is positive zero.
 572      *
 573      * &lt;li&gt;If
 574      * &lt;ul&gt;
 575      * &lt;li&gt;the first argument is positive zero and the second argument
 576      * is less than zero, or
 577      * &lt;li&gt;the first argument is positive infinity and the second
 578      * argument is greater than zero,
 579      * &lt;/ul&gt;
 580      * then the result is positive infinity.
 581      *
 582      * &lt;li&gt;If
 583      * &lt;ul&gt;
 584      * &lt;li&gt;the first argument is negative zero and the second argument
 585      * is greater than zero but not a finite odd integer, or
 586      * &lt;li&gt;the first argument is negative infinity and the second
 587      * argument is less than zero but not a finite odd integer,
 588      * &lt;/ul&gt;
 589      * then the result is positive zero.
 590      *
 591      * &lt;li&gt;If
 592      * &lt;ul&gt;
 593      * &lt;li&gt;the first argument is negative zero and the second argument
 594      * is a positive finite odd integer, or
 595      * &lt;li&gt;the first argument is negative infinity and the second
 596      * argument is a negative finite odd integer,
 597      * &lt;/ul&gt;
 598      * then the result is negative zero.
 599      *
 600      * &lt;li&gt;If
 601      * &lt;ul&gt;
 602      * &lt;li&gt;the first argument is negative zero and the second argument
 603      * is less than zero but not a finite odd integer, or
 604      * &lt;li&gt;the first argument is negative infinity and the second
 605      * argument is greater than zero but not a finite odd integer,
 606      * &lt;/ul&gt;
 607      * then the result is positive infinity.
 608      *
 609      * &lt;li&gt;If
 610      * &lt;ul&gt;
 611      * &lt;li&gt;the first argument is negative zero and the second argument
 612      * is a negative finite odd integer, or
 613      * &lt;li&gt;the first argument is negative infinity and the second
 614      * argument is a positive finite odd integer,
 615      * &lt;/ul&gt;
 616      * then the result is negative infinity.
 617      *
 618      * &lt;li&gt;If the first argument is finite and less than zero
 619      * &lt;ul&gt;
 620      * &lt;li&gt; if the second argument is a finite even integer, the
 621      * result is equal to the result of raising the absolute value of
 622      * the first argument to the power of the second argument
 623      *
 624      * &lt;li&gt;if the second argument is a finite odd integer, the result
 625      * is equal to the negative of the result of raising the absolute
 626      * value of the first argument to the power of the second
 627      * argument
 628      *
 629      * &lt;li&gt;if the second argument is finite and not an integer, then
 630      * the result is NaN.
 631      * &lt;/ul&gt;
 632      *
 633      * &lt;li&gt;If both arguments are integers, then the result is exactly equal
 634      * to the mathematical result of raising the first argument to the power
 635      * of the second argument if that result can in fact be represented
 636      * exactly as a {@code double} value.&lt;/ul&gt;
 637      *
 638      * &lt;p&gt;(In the foregoing descriptions, a floating-point value is
 639      * considered to be an integer if and only if it is finite and a
 640      * fixed point of the method {@link #ceil ceil} or,
 641      * equivalently, a fixed point of the method {@link #floor
 642      * floor}. A value is a fixed point of a one-argument
 643      * method if and only if the result of applying the method to the
 644      * value is equal to the value.)
 645      *
 646      * @param   a   base.
 647      * @param   b   the exponent.
 648      * @return  the value {@code a}&lt;sup&gt;{@code b}&lt;/sup&gt;.
 649      */
 650     public static double pow(double a, double b) {
 651         return FdLibm.Pow.compute(a, b);
 652     }
 653 
 654     /**
 655      * Returns the closest {@code int} to the argument, with ties
 656      * rounding to positive infinity.
 657      *
 658      * &lt;p&gt;Special cases:
 659      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, the result is 0.
 660      * &lt;li&gt;If the argument is negative infinity or any value less than or
 661      * equal to the value of {@code Integer.MIN_VALUE}, the result is
 662      * equal to the value of {@code Integer.MIN_VALUE}.
 663      * &lt;li&gt;If the argument is positive infinity or any value greater than or
 664      * equal to the value of {@code Integer.MAX_VALUE}, the result is
 665      * equal to the value of {@code Integer.MAX_VALUE}.&lt;/ul&gt;
 666      *
 667      * @param   a   a floating-point value to be rounded to an integer.
 668      * @return  the value of the argument rounded to the nearest
 669      *          {@code int} value.
 670      * @see     java.lang.Integer#MAX_VALUE
 671      * @see     java.lang.Integer#MIN_VALUE
 672      */
 673     public static int round(float a) {
 674         return Math.round(a);
 675     }
 676 
 677     /**
 678      * Returns the closest {@code long} to the argument, with ties
 679      * rounding to positive infinity.
 680      *
 681      * &lt;p&gt;Special cases:
 682      * &lt;ul&gt;&lt;li&gt;If the argument is NaN, the result is 0.
 683      * &lt;li&gt;If the argument is negative infinity or any value less than or
 684      * equal to the value of {@code Long.MIN_VALUE}, the result is
 685      * equal to the value of {@code Long.MIN_VALUE}.
 686      * &lt;li&gt;If the argument is positive infinity or any value greater than or
 687      * equal to the value of {@code Long.MAX_VALUE}, the result is
 688      * equal to the value of {@code Long.MAX_VALUE}.&lt;/ul&gt;
 689      *
 690      * @param   a  a floating-point value to be rounded to a
 691      *          {@code long}.
 692      * @return  the value of the argument rounded to the nearest
 693      *          {@code long} value.
 694      * @see     java.lang.Long#MAX_VALUE
 695      * @see     java.lang.Long#MIN_VALUE
 696      */
 697     public static long round(double a) {
 698         return Math.round(a);
 699     }
 700 
 701     private static final class RandomNumberGeneratorHolder {
 702         static final Random randomNumberGenerator = new Random();
 703     }
 704 
 705     /**
 706      * Returns a {@code double} value with a positive sign, greater
 707      * than or equal to {@code 0.0} and less than {@code 1.0}.
 708      * Returned values are chosen pseudorandomly with (approximately)
 709      * uniform distribution from that range.
 710      *
 711      * &lt;p&gt;When this method is first called, it creates a single new
 712      * pseudorandom-number generator, exactly as if by the expression
 713      *
 714      * &lt;blockquote&gt;{@code new java.util.Random()}&lt;/blockquote&gt;
 715      *
 716      * This new pseudorandom-number generator is used thereafter for
 717      * all calls to this method and is used nowhere else.
 718      *
 719      * &lt;p&gt;This method is properly synchronized to allow correct use by
 720      * more than one thread. However, if many threads need to generate
 721      * pseudorandom numbers at a great rate, it may reduce contention
 722      * for each thread to have its own pseudorandom-number generator.
 723      *
 724      * @return  a pseudorandom {@code double} greater than or equal
 725      * to {@code 0.0} and less than {@code 1.0}.
 726      * @see Random#nextDouble()
 727      */
 728     public static double random() {
 729         return RandomNumberGeneratorHolder.randomNumberGenerator.nextDouble();
 730     }
 731 
 732     /**
 733      * Returns the sum of its arguments,
 734      * throwing an exception if the result overflows an {@code int}.
 735      *
 736      * @param x the first value
 737      * @param y the second value
 738      * @return the result
 739      * @throws ArithmeticException if the result overflows an int
 740      * @see Math#addExact(int,int)
 741      * @since 1.8
 742      */
 743     public static int addExact(int x, int y) {
 744         return Math.addExact(x, y);
 745     }
 746 
 747     /**
 748      * Returns the sum of its arguments,
 749      * throwing an exception if the result overflows a {@code long}.
 750      *
 751      * @param x the first value
 752      * @param y the second value
 753      * @return the result
 754      * @throws ArithmeticException if the result overflows a long
 755      * @see Math#addExact(long,long)
 756      * @since 1.8
 757      */
 758     public static long addExact(long x, long y) {
 759         return Math.addExact(x, y);
 760     }
 761 
 762     /**
 763      * Returns the difference of the arguments,
 764      * throwing an exception if the result overflows an {@code int}.
 765      *
 766      * @param x the first value
 767      * @param y the second value to subtract from the first
 768      * @return the result
 769      * @throws ArithmeticException if the result overflows an int
 770      * @see Math#subtractExact(int,int)
 771      * @since 1.8
 772      */
 773     public static int subtractExact(int x, int y) {
 774         return Math.subtractExact(x, y);
 775     }
 776 
 777     /**
 778      * Returns the difference of the arguments,
 779      * throwing an exception if the result overflows a {@code long}.
 780      *
 781      * @param x the first value
 782      * @param y the second value to subtract from the first
 783      * @return the result
 784      * @throws ArithmeticException if the result overflows a long
 785      * @see Math#subtractExact(long,long)
 786      * @since 1.8
 787      */
 788     public static long subtractExact(long x, long y) {
 789         return Math.subtractExact(x, y);
 790     }
 791 
 792     /**
 793      * Returns the product of the arguments,
 794      * throwing an exception if the result overflows an {@code int}.
 795      *
 796      * @param x the first value
 797      * @param y the second value
 798      * @return the result
 799      * @throws ArithmeticException if the result overflows an int
 800      * @see Math#multiplyExact(int,int)
 801      * @since 1.8
 802      */
 803     public static int multiplyExact(int x, int y) {
 804         return Math.multiplyExact(x, y);
 805     }
 806 
 807     /**
 808      * Returns the product of the arguments, throwing an exception if the result
 809      * overflows a {@code long}.
 810      *
 811      * @param x the first value
 812      * @param y the second value
 813      * @return the result
 814      * @throws ArithmeticException if the result overflows a long
 815      * @see Math#multiplyExact(long,int)
 816      * @since 9
 817      */
 818     public static long multiplyExact(long x, int y) {
 819         return Math.multiplyExact(x, y);
 820     }
 821 
 822     /**
 823      * Returns the product of the arguments,
 824      * throwing an exception if the result overflows a {@code long}.
 825      *
 826      * @param x the first value
 827      * @param y the second value
 828      * @return the result
 829      * @throws ArithmeticException if the result overflows a long
 830      * @see Math#multiplyExact(long,long)
 831      * @since 1.8
 832      */
 833     public static long multiplyExact(long x, long y) {
 834         return Math.multiplyExact(x, y);
 835     }
 836 
 837     /**
 838      * Returns the argument incremented by one,
 839      * throwing an exception if the result overflows an {@code int}.
 840      * The overflow only occurs for {@linkplain Integer#MAX_VALUE the maximum value}.
 841      *
 842      * @param a the value to increment
 843      * @return the result
 844      * @throws ArithmeticException if the result overflows an int
 845      * @see Math#incrementExact(int)
 846      * @since 14
 847      */
 848     public static int incrementExact(int a) {
 849         return Math.incrementExact(a);
 850     }
 851 
 852     /**
 853      * Returns the argument incremented by one,
 854      * throwing an exception if the result overflows a {@code long}.
 855      * The overflow only occurs for {@linkplain Long#MAX_VALUE the maximum value}.
 856      *
 857      * @param a the value to increment
 858      * @return the result
 859      * @throws ArithmeticException if the result overflows a long
 860      * @see Math#incrementExact(long)
 861      * @since 14
 862      */
 863     public static long incrementExact(long a) {
 864         return Math.incrementExact(a);
 865     }
 866 
 867     /**
 868      * Returns the argument decremented by one,
 869      * throwing an exception if the result overflows an {@code int}.
 870      * The overflow only occurs for {@linkplain Integer#MIN_VALUE the minimum value}.
 871      *
 872      * @param a the value to decrement
 873      * @return the result
 874      * @throws ArithmeticException if the result overflows an int
 875      * @see Math#decrementExact(int)
 876      * @since 14
 877      */
 878     public static int decrementExact(int a) {
 879         return Math.decrementExact(a);
 880     }
 881 
 882     /**
 883      * Returns the argument decremented by one,
 884      * throwing an exception if the result overflows a {@code long}.
 885      * The overflow only occurs for {@linkplain Long#MIN_VALUE the minimum value}.
 886      *
 887      * @param a the value to decrement
 888      * @return the result
 889      * @throws ArithmeticException if the result overflows a long
 890      * @see Math#decrementExact(long)
 891      * @since 14
 892      */
 893     public static long decrementExact(long a) {
 894         return Math.decrementExact(a);
 895     }
 896 
 897     /**
 898      * Returns the negation of the argument,
 899      * throwing an exception if the result overflows an {@code int}.
 900      * The overflow only occurs for {@linkplain Integer#MIN_VALUE the minimum value}.
 901      *
 902      * @param a the value to negate
 903      * @return the result
 904      * @throws ArithmeticException if the result overflows an int
 905      * @see Math#negateExact(int)
 906      * @since 14
 907      */
 908     public static int negateExact(int a) {
 909         return Math.negateExact(a);
 910     }
 911 
 912     /**
 913      * Returns the negation of the argument,
 914      * throwing an exception if the result overflows a {@code long}.
 915      * The overflow only occurs for {@linkplain Long#MIN_VALUE the minimum value}.
 916      *
 917      * @param a the value to negate
 918      * @return the result
 919      * @throws ArithmeticException if the result overflows a long
 920      * @see Math#negateExact(long)
 921      * @since 14
 922      */
 923     public static long negateExact(long a) {
 924         return Math.negateExact(a);
 925     }
 926 
 927     /**
 928      * Returns the value of the {@code long} argument, throwing an exception
 929      * if the value overflows an {@code int}.
 930      *
 931      * @param value the long value
 932      * @return the argument as an int
 933      * @throws ArithmeticException if the {@code argument} overflows an int
 934      * @see Math#toIntExact(long)
 935      * @since 1.8
 936      */
 937     public static int toIntExact(long value) {
 938         return Math.toIntExact(value);
 939     }
 940 
 941     /**
 942      * Returns the exact mathematical product of the arguments.
 943      *
 944      * @param x the first value
 945      * @param y the second value
 946      * @return the result
 947      * @see Math#multiplyFull(int,int)
 948      * @since 9
 949      */
 950     public static long multiplyFull(int x, int y) {
 951         return Math.multiplyFull(x, y);
 952     }
 953 
 954     /**
 955      * Returns as a {@code long} the most significant 64 bits of the 128-bit
 956      * product of two 64-bit factors.
 957      *
 958      * @param x the first value
 959      * @param y the second value
 960      * @return the result
 961      * @see Math#multiplyHigh(long,long)
 962      * @since 9
 963      */
 964     public static long multiplyHigh(long x, long y) {
 965         return Math.multiplyHigh(x, y);
 966     }
 967 
 968     /**
 969      * Returns the largest (closest to positive infinity)
 970      * {@code int} value that is less than or equal to the algebraic quotient.
 971      * There is one special case, if the dividend is the
 972      * {@linkplain Integer#MIN_VALUE Integer.MIN_VALUE} and the divisor is {@code -1},
 973      * then integer overflow occurs and
 974      * the result is equal to the {@code Integer.MIN_VALUE}.
 975      * &lt;p&gt;
 976      * See {@link Math#floorDiv(int, int) Math.floorDiv} for examples and
 977      * a comparison to the integer division {@code /} operator.
 978      *
 979      * @param x the dividend
 980      * @param y the divisor
 981      * @return the largest (closest to positive infinity)
 982      * {@code int} value that is less than or equal to the algebraic quotient.
 983      * @throws ArithmeticException if the divisor {@code y} is zero
 984      * @see Math#floorDiv(int, int)
 985      * @see Math#floor(double)
 986      * @since 1.8
 987      */
 988     public static int floorDiv(int x, int y) {
 989         return Math.floorDiv(x, y);
 990     }
 991 
 992     /**
 993      * Returns the largest (closest to positive infinity)
 994      * {@code long} value that is less than or equal to the algebraic quotient.
 995      * There is one special case, if the dividend is the
 996      * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},
 997      * then integer overflow occurs and
 998      * the result is equal to {@code Long.MIN_VALUE}.
 999      * &lt;p&gt;
1000      * See {@link Math#floorDiv(int, int) Math.floorDiv} for examples and
1001      * a comparison to the integer division {@code /} operator.
1002      *
1003      * @param x the dividend
1004      * @param y the divisor
1005      * @return the largest (closest to positive infinity)
1006      * {@code int} value that is less than or equal to the algebraic quotient.
1007      * @throws ArithmeticException if the divisor {@code y} is zero
1008      * @see Math#floorDiv(long, int)
1009      * @see Math#floor(double)
1010      * @since 9
1011      */
1012     public static long floorDiv(long x, int y) {
1013         return Math.floorDiv(x, y);
1014     }
1015 
1016     /**
1017      * Returns the largest (closest to positive infinity)
1018      * {@code long} value that is less than or equal to the algebraic quotient.
1019      * There is one special case, if the dividend is the
1020      * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},
1021      * then integer overflow occurs and
1022      * the result is equal to the {@code Long.MIN_VALUE}.
1023      * &lt;p&gt;
1024      * See {@link Math#floorDiv(int, int) Math.floorDiv} for examples and
1025      * a comparison to the integer division {@code /} operator.
1026      *
1027      * @param x the dividend
1028      * @param y the divisor
1029      * @return the largest (closest to positive infinity)
1030      * {@code long} value that is less than or equal to the algebraic quotient.
1031      * @throws ArithmeticException if the divisor {@code y} is zero
1032      * @see Math#floorDiv(long, long)
1033      * @see Math#floor(double)
1034      * @since 1.8
1035      */
1036     public static long floorDiv(long x, long y) {
1037         return Math.floorDiv(x, y);
1038     }
1039 
1040     /**
1041      * Returns the floor modulus of the {@code int} arguments.
1042      * &lt;p&gt;
1043      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
1044      * has the same sign as the divisor {@code y}, and
1045      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
1046      * &lt;p&gt;
1047      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
1048      * &lt;ul&gt;
1049      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
1050      * &lt;/ul&gt;
1051      * &lt;p&gt;
1052      * See {@link Math#floorMod(int, int) Math.floorMod} for examples and
1053      * a comparison to the {@code %} operator.
1054      *
1055      * @param x the dividend
1056      * @param y the divisor
1057      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
1058      * @throws ArithmeticException if the divisor {@code y} is zero
1059      * @see Math#floorMod(int, int)
1060      * @see StrictMath#floorDiv(int, int)
1061      * @since 1.8
1062      */
1063     public static int floorMod(int x, int y) {
1064         return Math.floorMod(x , y);
1065     }
1066 
1067     /**
1068      * Returns the floor modulus of the {@code long} and {@code int} arguments.
1069      * &lt;p&gt;
1070      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
1071      * has the same sign as the divisor {@code y}, and
1072      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
1073      *
1074      * &lt;p&gt;
1075      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
1076      * &lt;ul&gt;
1077      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
1078      * &lt;/ul&gt;
1079      * &lt;p&gt;
1080      * See {@link Math#floorMod(int, int) Math.floorMod} for examples and
1081      * a comparison to the {@code %} operator.
1082      *
1083      * @param x the dividend
1084      * @param y the divisor
1085      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
1086      * @throws ArithmeticException if the divisor {@code y} is zero
1087      * @see Math#floorMod(long, int)
1088      * @see StrictMath#floorDiv(long, int)
1089      * @since 9
1090      */
1091     public static int floorMod(long x, int y) {
1092         return Math.floorMod(x , y);
1093     }
1094 
1095     /**
1096      * Returns the floor modulus of the {@code long} arguments.
1097      * &lt;p&gt;
1098      * The floor modulus is {@code x - (floorDiv(x, y) * y)},
1099      * has the same sign as the divisor {@code y}, and
1100      * is in the range of {@code -abs(y) &lt; r &lt; +abs(y)}.
1101      * &lt;p&gt;
1102      * The relationship between {@code floorDiv} and {@code floorMod} is such that:
1103      * &lt;ul&gt;
1104      *   &lt;li&gt;{@code floorDiv(x, y) * y + floorMod(x, y) == x}
1105      * &lt;/ul&gt;
1106      * &lt;p&gt;
1107      * See {@link Math#floorMod(int, int) Math.floorMod} for examples and
1108      * a comparison to the {@code %} operator.
1109      *
1110      * @param x the dividend
1111      * @param y the divisor
1112      * @return the floor modulus {@code x - (floorDiv(x, y) * y)}
1113      * @throws ArithmeticException if the divisor {@code y} is zero
1114      * @see Math#floorMod(long, long)
1115      * @see StrictMath#floorDiv(long, long)
1116      * @since 1.8
1117      */
1118     public static long floorMod(long x, long y) {
1119         return Math.floorMod(x, y);
1120     }
1121 
1122     /**
1123      * Returns the absolute value of an {@code int} value.
1124      * If the argument is not negative, the argument is returned.
1125      * If the argument is negative, the negation of the argument is returned.
1126      *
1127      * &lt;p&gt;Note that if the argument is equal to the value of
1128      * {@link Integer#MIN_VALUE}, the most negative representable
1129      * {@code int} value, the result is that same value, which is
1130      * negative.
1131      *
1132      * @param   a   the  argument whose absolute value is to be determined.
1133      * @return  the absolute value of the argument.
1134      */
1135     public static int abs(int a) {
1136         return Math.abs(a);
1137     }
1138 
1139     /**
1140      * Returns the absolute value of a {@code long} value.
1141      * If the argument is not negative, the argument is returned.
1142      * If the argument is negative, the negation of the argument is returned.
1143      *
1144      * &lt;p&gt;Note that if the argument is equal to the value of
1145      * {@link Long#MIN_VALUE}, the most negative representable
1146      * {@code long} value, the result is that same value, which
1147      * is negative.
1148      *
1149      * @param   a   the  argument whose absolute value is to be determined.
1150      * @return  the absolute value of the argument.
1151      */
1152     public static long abs(long a) {
1153         return Math.abs(a);
1154     }
1155 
1156     /**
1157      * Returns the absolute value of a {@code float} value.
1158      * If the argument is not negative, the argument is returned.
1159      * If the argument is negative, the negation of the argument is returned.
1160      * Special cases:
1161      * &lt;ul&gt;&lt;li&gt;If the argument is positive zero or negative zero, the
1162      * result is positive zero.
1163      * &lt;li&gt;If the argument is infinite, the result is positive infinity.
1164      * &lt;li&gt;If the argument is NaN, the result is NaN.&lt;/ul&gt;
1165      *
1166      * @apiNote As implied by the above, one valid implementation of
1167      * this method is given by the expression below which computes a
1168      * {@code float} with the same exponent and significand as the
1169      * argument but with a guaranteed zero sign bit indicating a
1170      * positive value: &lt;br&gt;
1171      * {@code Float.intBitsToFloat(0x7fffffff &amp; Float.floatToRawIntBits(a))}
1172      *
1173      * @param   a   the argument whose absolute value is to be determined
1174      * @return  the absolute value of the argument.
1175      */
1176     public static float abs(float a) {
1177         return Math.abs(a);
1178     }
1179 
1180     /**
1181      * Returns the absolute value of a {@code double} value.
1182      * If the argument is not negative, the argument is returned.
1183      * If the argument is negative, the negation of the argument is returned.
1184      * Special cases:
1185      * &lt;ul&gt;&lt;li&gt;If the argument is positive zero or negative zero, the result
1186      * is positive zero.
1187      * &lt;li&gt;If the argument is infinite, the result is positive infinity.
1188      * &lt;li&gt;If the argument is NaN, the result is NaN.&lt;/ul&gt;
1189      *
1190      * @apiNote As implied by the above, one valid implementation of
1191      * this method is given by the expression below which computes a
1192      * {@code double} with the same exponent and significand as the
1193      * argument but with a guaranteed zero sign bit indicating a
1194      * positive value: &lt;br&gt;
1195      * {@code Double.longBitsToDouble((Double.doubleToRawLongBits(a)&lt;&lt;1)&gt;&gt;&gt;1)}
1196      *
1197      * @param   a   the argument whose absolute value is to be determined
1198      * @return  the absolute value of the argument.
1199      */
1200     public static double abs(double a) {
1201         return Math.abs(a);
1202     }
1203 
1204     /**
1205      * Returns the greater of two {@code int} values. That is, the
1206      * result is the argument closer to the value of
1207      * {@link Integer#MAX_VALUE}. If the arguments have the same value,
1208      * the result is that same value.
1209      *
1210      * @param   a   an argument.
1211      * @param   b   another argument.
1212      * @return  the larger of {@code a} and {@code b}.
1213      */
1214     @HotSpotIntrinsicCandidate
1215     public static int max(int a, int b) {
1216         return Math.max(a, b);
1217     }
1218 
1219     /**
1220      * Returns the greater of two {@code long} values. That is, the
1221      * result is the argument closer to the value of
1222      * {@link Long#MAX_VALUE}. If the arguments have the same value,
1223      * the result is that same value.
1224      *
1225      * @param   a   an argument.
1226      * @param   b   another argument.
1227      * @return  the larger of {@code a} and {@code b}.
1228      */
1229     public static long max(long a, long b) {
1230         return Math.max(a, b);
1231     }
1232 
1233     /**
1234      * Returns the greater of two {@code float} values.  That is,
1235      * the result is the argument closer to positive infinity. If the
1236      * arguments have the same value, the result is that same
1237      * value. If either value is NaN, then the result is NaN.  Unlike
1238      * the numerical comparison operators, this method considers
1239      * negative zero to be strictly smaller than positive zero. If one
1240      * argument is positive zero and the other negative zero, the
1241      * result is positive zero.
1242      *
1243      * @param   a   an argument.
1244      * @param   b   another argument.
1245      * @return  the larger of {@code a} and {@code b}.
1246      */
1247     @HotSpotIntrinsicCandidate
1248     public static float max(float a, float b) {
1249         return Math.max(a, b);
1250     }
1251 
1252     /**
1253      * Returns the greater of two {@code double} values.  That
1254      * is, the result is the argument closer to positive infinity. If
1255      * the arguments have the same value, the result is that same
1256      * value. If either value is NaN, then the result is NaN.  Unlike
1257      * the numerical comparison operators, this method considers
1258      * negative zero to be strictly smaller than positive zero. If one
1259      * argument is positive zero and the other negative zero, the
1260      * result is positive zero.
1261      *
1262      * @param   a   an argument.
1263      * @param   b   another argument.
1264      * @return  the larger of {@code a} and {@code b}.
1265      */
1266     @HotSpotIntrinsicCandidate
1267     public static double max(double a, double b) {
1268         return Math.max(a, b);
1269     }
1270 
1271     /**
1272      * Returns the smaller of two {@code int} values. That is,
1273      * the result the argument closer to the value of
1274      * {@link Integer#MIN_VALUE}.  If the arguments have the same
1275      * value, the result is that same value.
1276      *
1277      * @param   a   an argument.
1278      * @param   b   another argument.
1279      * @return  the smaller of {@code a} and {@code b}.
1280      */
1281     @HotSpotIntrinsicCandidate
1282     public static int min(int a, int b) {
1283         return Math.min(a, b);
1284     }
1285 
1286     /**
1287      * Returns the smaller of two {@code long} values. That is,
1288      * the result is the argument closer to the value of
1289      * {@link Long#MIN_VALUE}. If the arguments have the same
1290      * value, the result is that same value.
1291      *
1292      * @param   a   an argument.
1293      * @param   b   another argument.
1294      * @return  the smaller of {@code a} and {@code b}.
1295      */
1296     public static long min(long a, long b) {
1297         return Math.min(a, b);
1298     }
1299 
1300     /**
1301      * Returns the smaller of two {@code float} values.  That is,
1302      * the result is the value closer to negative infinity. If the
1303      * arguments have the same value, the result is that same
1304      * value. If either value is NaN, then the result is NaN.  Unlike
1305      * the numerical comparison operators, this method considers
1306      * negative zero to be strictly smaller than positive zero.  If
1307      * one argument is positive zero and the other is negative zero,
1308      * the result is negative zero.
1309      *
1310      * @param   a   an argument.
1311      * @param   b   another argument.
1312      * @return  the smaller of {@code a} and {@code b.}
1313      */
1314     @HotSpotIntrinsicCandidate
1315     public static float min(float a, float b) {
1316         return Math.min(a, b);
1317     }
1318 
1319     /**
1320      * Returns the smaller of two {@code double} values.  That
1321      * is, the result is the value closer to negative infinity. If the
1322      * arguments have the same value, the result is that same
1323      * value. If either value is NaN, then the result is NaN.  Unlike
1324      * the numerical comparison operators, this method considers
1325      * negative zero to be strictly smaller than positive zero. If one
1326      * argument is positive zero and the other is negative zero, the
1327      * result is negative zero.
1328      *
1329      * @param   a   an argument.
1330      * @param   b   another argument.
1331      * @return  the smaller of {@code a} and {@code b}.
1332      */
1333     @HotSpotIntrinsicCandidate
1334     public static double min(double a, double b) {
1335         return Math.min(a, b);
1336     }
1337 
1338     /**
1339      * Returns the fused multiply add of the three arguments; that is,
1340      * returns the exact product of the first two arguments summed
1341      * with the third argument and then rounded once to the nearest
1342      * {@code double}.
1343      *
1344      * The rounding is done using the {@linkplain
1345      * java.math.RoundingMode#HALF_EVEN round to nearest even
1346      * rounding mode}.
1347      *
1348      * In contrast, if {@code a * b + c} is evaluated as a regular
1349      * floating-point expression, two rounding errors are involved,
1350      * the first for the multiply operation, the second for the
1351      * addition operation.
1352      *
1353      * &lt;p&gt;Special cases:
1354      * &lt;ul&gt;
1355      * &lt;li&gt; If any argument is NaN, the result is NaN.
1356      *
1357      * &lt;li&gt; If one of the first two arguments is infinite and the
1358      * other is zero, the result is NaN.
1359      *
1360      * &lt;li&gt; If the exact product of the first two arguments is infinite
1361      * (in other words, at least one of the arguments is infinite and
1362      * the other is neither zero nor NaN) and the third argument is an
1363      * infinity of the opposite sign, the result is NaN.
1364      *
1365      * &lt;/ul&gt;
1366      *
1367      * &lt;p&gt;Note that {@code fusedMac(a, 1.0, c)} returns the same
1368      * result as ({@code a + c}).  However,
1369      * {@code fusedMac(a, b, +0.0)} does &lt;em&gt;not&lt;/em&gt; always return the
1370      * same result as ({@code a * b}) since
1371      * {@code fusedMac(-0.0, +0.0, +0.0)} is {@code +0.0} while
1372      * ({@code -0.0 * +0.0}) is {@code -0.0}; {@code fusedMac(a, b, -0.0)} is
1373      * equivalent to ({@code a * b}) however.
1374      *
1375      * @apiNote This method corresponds to the fusedMultiplyAdd
1376      * operation defined in IEEE 754-2008.
1377      *
1378      * @param a a value
1379      * @param b a value
1380      * @param c a value
1381      *
1382      * @return (&lt;i&gt;a&lt;/i&gt;&amp;nbsp;&amp;times;&amp;nbsp;&lt;i&gt;b&lt;/i&gt;&amp;nbsp;+&amp;nbsp;&lt;i&gt;c&lt;/i&gt;)
1383      * computed, as if with unlimited range and precision, and rounded
1384      * once to the nearest {@code double} value
1385      *
1386      * @since 9
1387      */
1388     public static double fma(double a, double b, double c) {
1389         return Math.fma(a, b, c);
1390     }
1391 
1392     /**
1393      * Returns the fused multiply add of the three arguments; that is,
1394      * returns the exact product of the first two arguments summed
1395      * with the third argument and then rounded once to the nearest
1396      * {@code float}.
1397      *
1398      * The rounding is done using the {@linkplain
1399      * java.math.RoundingMode#HALF_EVEN round to nearest even
1400      * rounding mode}.
1401      *
1402      * In contrast, if {@code a * b + c} is evaluated as a regular
1403      * floating-point expression, two rounding errors are involved,
1404      * the first for the multiply operation, the second for the
1405      * addition operation.
1406      *
1407      * &lt;p&gt;Special cases:
1408      * &lt;ul&gt;
1409      * &lt;li&gt; If any argument is NaN, the result is NaN.
1410      *
1411      * &lt;li&gt; If one of the first two arguments is infinite and the
1412      * other is zero, the result is NaN.
1413      *
1414      * &lt;li&gt; If the exact product of the first two arguments is infinite
1415      * (in other words, at least one of the arguments is infinite and
1416      * the other is neither zero nor NaN) and the third argument is an
1417      * infinity of the opposite sign, the result is NaN.
1418      *
1419      * &lt;/ul&gt;
1420      *
1421      * &lt;p&gt;Note that {@code fma(a, 1.0f, c)} returns the same
1422      * result as ({@code a + c}).  However,
1423      * {@code fma(a, b, +0.0f)} does &lt;em&gt;not&lt;/em&gt; always return the
1424      * same result as ({@code a * b}) since
1425      * {@code fma(-0.0f, +0.0f, +0.0f)} is {@code +0.0f} while
1426      * ({@code -0.0f * +0.0f}) is {@code -0.0f}; {@code fma(a, b, -0.0f)} is
1427      * equivalent to ({@code a * b}) however.
1428      *
1429      * @apiNote This method corresponds to the fusedMultiplyAdd
1430      * operation defined in IEEE 754-2008.
1431      *
1432      * @param a a value
1433      * @param b a value
1434      * @param c a value
1435      *
1436      * @return (&lt;i&gt;a&lt;/i&gt;&amp;nbsp;&amp;times;&amp;nbsp;&lt;i&gt;b&lt;/i&gt;&amp;nbsp;+&amp;nbsp;&lt;i&gt;c&lt;/i&gt;)
1437      * computed, as if with unlimited range and precision, and rounded
1438      * once to the nearest {@code float} value
1439      *
1440      * @since 9
1441      */
1442     public static float fma(float a, float b, float c) {
1443         return Math.fma(a, b, c);
1444     }
1445 
1446     /**
1447      * Returns the size of an ulp of the argument.  An ulp, unit in
1448      * the last place, of a {@code double} value is the positive
1449      * distance between this floating-point value and the {@code
1450      * double} value next larger in magnitude.  Note that for non-NaN
1451      * &lt;i&gt;x&lt;/i&gt;, &lt;code&gt;ulp(-&lt;i&gt;x&lt;/i&gt;) == ulp(&lt;i&gt;x&lt;/i&gt;)&lt;/code&gt;.
1452      *
1453      * &lt;p&gt;Special Cases:
1454      * &lt;ul&gt;
1455      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1456      * &lt;li&gt; If the argument is positive or negative infinity, then the
1457      * result is positive infinity.
1458      * &lt;li&gt; If the argument is positive or negative zero, then the result is
1459      * {@code Double.MIN_VALUE}.
1460      * &lt;li&gt; If the argument is &amp;plusmn;{@code Double.MAX_VALUE}, then
1461      * the result is equal to 2&lt;sup&gt;971&lt;/sup&gt;.
1462      * &lt;/ul&gt;
1463      *
1464      * @param d the floating-point value whose ulp is to be returned
1465      * @return the size of an ulp of the argument
1466      * @author Joseph D. Darcy
1467      * @since 1.5
1468      */
1469     public static double ulp(double d) {
1470         return Math.ulp(d);
1471     }
1472 
1473     /**
1474      * Returns the size of an ulp of the argument.  An ulp, unit in
1475      * the last place, of a {@code float} value is the positive
1476      * distance between this floating-point value and the {@code
1477      * float} value next larger in magnitude.  Note that for non-NaN
1478      * &lt;i&gt;x&lt;/i&gt;, &lt;code&gt;ulp(-&lt;i&gt;x&lt;/i&gt;) == ulp(&lt;i&gt;x&lt;/i&gt;)&lt;/code&gt;.
1479      *
1480      * &lt;p&gt;Special Cases:
1481      * &lt;ul&gt;
1482      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1483      * &lt;li&gt; If the argument is positive or negative infinity, then the
1484      * result is positive infinity.
1485      * &lt;li&gt; If the argument is positive or negative zero, then the result is
1486      * {@code Float.MIN_VALUE}.
1487      * &lt;li&gt; If the argument is &amp;plusmn;{@code Float.MAX_VALUE}, then
1488      * the result is equal to 2&lt;sup&gt;104&lt;/sup&gt;.
1489      * &lt;/ul&gt;
1490      *
1491      * @param f the floating-point value whose ulp is to be returned
1492      * @return the size of an ulp of the argument
1493      * @author Joseph D. Darcy
1494      * @since 1.5
1495      */
1496     public static float ulp(float f) {
1497         return Math.ulp(f);
1498     }
1499 
1500     /**
1501      * Returns the signum function of the argument; zero if the argument
1502      * is zero, 1.0 if the argument is greater than zero, -1.0 if the
1503      * argument is less than zero.
1504      *
1505      * &lt;p&gt;Special Cases:
1506      * &lt;ul&gt;
1507      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1508      * &lt;li&gt; If the argument is positive zero or negative zero, then the
1509      *      result is the same as the argument.
1510      * &lt;/ul&gt;
1511      *
1512      * @param d the floating-point value whose signum is to be returned
1513      * @return the signum function of the argument
1514      * @author Joseph D. Darcy
1515      * @since 1.5
1516      */
1517     public static double signum(double d) {
1518         return Math.signum(d);
1519     }
1520 
1521     /**
1522      * Returns the signum function of the argument; zero if the argument
1523      * is zero, 1.0f if the argument is greater than zero, -1.0f if the
1524      * argument is less than zero.
1525      *
1526      * &lt;p&gt;Special Cases:
1527      * &lt;ul&gt;
1528      * &lt;li&gt; If the argument is NaN, then the result is NaN.
1529      * &lt;li&gt; If the argument is positive zero or negative zero, then the
1530      *      result is the same as the argument.
1531      * &lt;/ul&gt;
1532      *
1533      * @param f the floating-point value whose signum is to be returned
1534      * @return the signum function of the argument
1535      * @author Joseph D. Darcy
1536      * @since 1.5
1537      */
1538     public static float signum(float f) {
1539         return Math.signum(f);
1540     }
1541 
1542     /**
1543      * Returns the hyperbolic sine of a {@code double} value.
1544      * The hyperbolic sine of &lt;i&gt;x&lt;/i&gt; is defined to be
1545      * (&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;)/2
1546      * where &lt;i&gt;e&lt;/i&gt; is {@linkplain Math#E Euler&#39;s number}.
1547      *
1548      * &lt;p&gt;Special cases:
1549      * &lt;ul&gt;
1550      *
1551      * &lt;li&gt;If the argument is NaN, then the result is NaN.
1552      *
1553      * &lt;li&gt;If the argument is infinite, then the result is an infinity
1554      * with the same sign as the argument.
1555      *
1556      * &lt;li&gt;If the argument is zero, then the result is a zero with the
1557      * same sign as the argument.
1558      *
1559      * &lt;/ul&gt;
1560      *
1561      * @param   x The number whose hyperbolic sine is to be returned.
1562      * @return  The hyperbolic sine of {@code x}.
1563      * @since 1.5
1564      */
1565     public static native double sinh(double x);
1566 
1567     /**
1568      * Returns the hyperbolic cosine of a {@code double} value.
1569      * The hyperbolic cosine of &lt;i&gt;x&lt;/i&gt; is defined to be
1570      * (&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;+&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;)/2
1571      * where &lt;i&gt;e&lt;/i&gt; is {@linkplain Math#E Euler&#39;s number}.
1572      *
1573      * &lt;p&gt;Special cases:
1574      * &lt;ul&gt;
1575      *
1576      * &lt;li&gt;If the argument is NaN, then the result is NaN.
1577      *
1578      * &lt;li&gt;If the argument is infinite, then the result is positive
1579      * infinity.
1580      *
1581      * &lt;li&gt;If the argument is zero, then the result is {@code 1.0}.
1582      *
1583      * &lt;/ul&gt;
1584      *
1585      * @param   x The number whose hyperbolic cosine is to be returned.
1586      * @return  The hyperbolic cosine of {@code x}.
1587      * @since 1.5
1588      */
1589     public static native double cosh(double x);
1590 
1591     /**
1592      * Returns the hyperbolic tangent of a {@code double} value.
1593      * The hyperbolic tangent of &lt;i&gt;x&lt;/i&gt; is defined to be
1594      * (&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;)/(&lt;i&gt;e&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;+&amp;nbsp;e&lt;sup&gt;-x&lt;/sup&gt;&lt;/i&gt;),
1595      * in other words, {@linkplain Math#sinh
1596      * sinh(&lt;i&gt;x&lt;/i&gt;)}/{@linkplain Math#cosh cosh(&lt;i&gt;x&lt;/i&gt;)}.  Note
1597      * that the absolute value of the exact tanh is always less than
1598      * 1.
1599      *
1600      * &lt;p&gt;Special cases:
1601      * &lt;ul&gt;
1602      *
1603      * &lt;li&gt;If the argument is NaN, then the result is NaN.
1604      *
1605      * &lt;li&gt;If the argument is zero, then the result is a zero with the
1606      * same sign as the argument.
1607      *
1608      * &lt;li&gt;If the argument is positive infinity, then the result is
1609      * {@code +1.0}.
1610      *
1611      * &lt;li&gt;If the argument is negative infinity, then the result is
1612      * {@code -1.0}.
1613      *
1614      * &lt;/ul&gt;
1615      *
1616      * @param   x The number whose hyperbolic tangent is to be returned.
1617      * @return  The hyperbolic tangent of {@code x}.
1618      * @since 1.5
1619      */
1620     public static native double tanh(double x);
1621 
1622     /**
1623      * Returns sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
1624      * without intermediate overflow or underflow.
1625      *
1626      * &lt;p&gt;Special cases:
1627      * &lt;ul&gt;
1628      *
1629      * &lt;li&gt; If either argument is infinite, then the result
1630      * is positive infinity.
1631      *
1632      * &lt;li&gt; If either argument is NaN and neither argument is infinite,
1633      * then the result is NaN.
1634      *
1635      * &lt;/ul&gt;
1636      *
1637      * @param x a value
1638      * @param y a value
1639      * @return sqrt(&lt;i&gt;x&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;&amp;nbsp;+&lt;i&gt;y&lt;/i&gt;&lt;sup&gt;2&lt;/sup&gt;)
1640      * without intermediate overflow or underflow
1641      * @since 1.5
1642      */
1643     public static double hypot(double x, double y) {
1644         return FdLibm.Hypot.compute(x, y);
1645     }
1646 
1647     /**
1648      * Returns &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;x&lt;/sup&gt;&amp;nbsp;-1.  Note that for values of
1649      * &lt;i&gt;x&lt;/i&gt; near 0, the exact sum of
1650      * {@code expm1(x)}&amp;nbsp;+&amp;nbsp;1 is much closer to the true
1651      * result of &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;x&lt;/sup&gt; than {@code exp(x)}.
1652      *
1653      * &lt;p&gt;Special cases:
1654      * &lt;ul&gt;
1655      * &lt;li&gt;If the argument is NaN, the result is NaN.
1656      *
1657      * &lt;li&gt;If the argument is positive infinity, then the result is
1658      * positive infinity.
1659      *
1660      * &lt;li&gt;If the argument is negative infinity, then the result is
1661      * -1.0.
1662      *
1663      * &lt;li&gt;If the argument is zero, then the result is a zero with the
1664      * same sign as the argument.
1665      *
1666      * &lt;/ul&gt;
1667      *
1668      * @param   x   the exponent to raise &lt;i&gt;e&lt;/i&gt; to in the computation of
1669      *              &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code x}&lt;/sup&gt;&amp;nbsp;-1.
1670      * @return  the value &lt;i&gt;e&lt;/i&gt;&lt;sup&gt;{@code x}&lt;/sup&gt;&amp;nbsp;-&amp;nbsp;1.
1671      * @since 1.5
1672      */
1673     public static native double expm1(double x);
1674 
1675     /**
1676      * Returns the natural logarithm of the sum of the argument and 1.
1677      * Note that for small values {@code x}, the result of
1678      * {@code log1p(x)} is much closer to the true result of ln(1
1679      * + {@code x}) than the floating-point evaluation of
1680      * {@code log(1.0+x)}.
1681      *
1682      * &lt;p&gt;Special cases:
1683      * &lt;ul&gt;
1684      *
1685      * &lt;li&gt;If the argument is NaN or less than -1, then the result is
1686      * NaN.
1687      *
1688      * &lt;li&gt;If the argument is positive infinity, then the result is
1689      * positive infinity.
1690      *
1691      * &lt;li&gt;If the argument is negative one, then the result is
1692      * negative infinity.
1693      *
1694      * &lt;li&gt;If the argument is zero, then the result is a zero with the
1695      * same sign as the argument.
1696      *
1697      * &lt;/ul&gt;
1698      *
1699      * @param   x   a value
1700      * @return the value ln({@code x}&amp;nbsp;+&amp;nbsp;1), the natural
1701      * log of {@code x}&amp;nbsp;+&amp;nbsp;1
1702      * @since 1.5
1703      */
1704     public static native double log1p(double x);
1705 
1706     /**
1707      * Returns the first floating-point argument with the sign of the
1708      * second floating-point argument.  For this method, a NaN
1709      * {@code sign} argument is always treated as if it were
1710      * positive.
1711      *
1712      * @param magnitude  the parameter providing the magnitude of the result
1713      * @param sign   the parameter providing the sign of the result
1714      * @return a value with the magnitude of {@code magnitude}
1715      * and the sign of {@code sign}.
1716      * @since 1.6
1717      */
1718     public static double copySign(double magnitude, double sign) {
1719         return Math.copySign(magnitude, (Double.isNaN(sign)?1.0d:sign));
1720     }
1721 
1722     /**
1723      * Returns the first floating-point argument with the sign of the
1724      * second floating-point argument.  For this method, a NaN
1725      * {@code sign} argument is always treated as if it were
1726      * positive.
1727      *
1728      * @param magnitude  the parameter providing the magnitude of the result
1729      * @param sign   the parameter providing the sign of the result
1730      * @return a value with the magnitude of {@code magnitude}
1731      * and the sign of {@code sign}.
1732      * @since 1.6
1733      */
1734     public static float copySign(float magnitude, float sign) {
1735         return Math.copySign(magnitude, (Float.isNaN(sign)?1.0f:sign));
1736     }
1737     /**
1738      * Returns the unbiased exponent used in the representation of a
1739      * {@code float}.  Special cases:
1740      *
1741      * &lt;ul&gt;
1742      * &lt;li&gt;If the argument is NaN or infinite, then the result is
1743      * {@link Float#MAX_EXPONENT} + 1.
1744      * &lt;li&gt;If the argument is zero or subnormal, then the result is
1745      * {@link Float#MIN_EXPONENT} -1.
1746      * &lt;/ul&gt;
1747      * @param f a {@code float} value
1748      * @return the unbiased exponent of the argument
1749      * @since 1.6
1750      */
1751     public static int getExponent(float f) {
1752         return Math.getExponent(f);
1753     }
1754 
1755     /**
1756      * Returns the unbiased exponent used in the representation of a
1757      * {@code double}.  Special cases:
1758      *
1759      * &lt;ul&gt;
1760      * &lt;li&gt;If the argument is NaN or infinite, then the result is
1761      * {@link Double#MAX_EXPONENT} + 1.
1762      * &lt;li&gt;If the argument is zero or subnormal, then the result is
1763      * {@link Double#MIN_EXPONENT} -1.
1764      * &lt;/ul&gt;
1765      * @param d a {@code double} value
1766      * @return the unbiased exponent of the argument
1767      * @since 1.6
1768      */
1769     public static int getExponent(double d) {
1770         return Math.getExponent(d);
1771     }
1772 
1773     /**
1774      * Returns the floating-point number adjacent to the first
1775      * argument in the direction of the second argument.  If both
1776      * arguments compare as equal the second argument is returned.
1777      *
1778      * &lt;p&gt;Special cases:
1779      * &lt;ul&gt;
1780      * &lt;li&gt; If either argument is a NaN, then NaN is returned.
1781      *
1782      * &lt;li&gt; If both arguments are signed zeros, {@code direction}
1783      * is returned unchanged (as implied by the requirement of
1784      * returning the second argument if the arguments compare as
1785      * equal).
1786      *
1787      * &lt;li&gt; If {@code start} is
1788      * &amp;plusmn;{@link Double#MIN_VALUE} and {@code direction}
1789      * has a value such that the result should have a smaller
1790      * magnitude, then a zero with the same sign as {@code start}
1791      * is returned.
1792      *
1793      * &lt;li&gt; If {@code start} is infinite and
1794      * {@code direction} has a value such that the result should
1795      * have a smaller magnitude, {@link Double#MAX_VALUE} with the
1796      * same sign as {@code start} is returned.
1797      *
1798      * &lt;li&gt; If {@code start} is equal to &amp;plusmn;
1799      * {@link Double#MAX_VALUE} and {@code direction} has a
1800      * value such that the result should have a larger magnitude, an
1801      * infinity with same sign as {@code start} is returned.
1802      * &lt;/ul&gt;
1803      *
1804      * @param start  starting floating-point value
1805      * @param direction value indicating which of
1806      * {@code start}&#39;s neighbors or {@code start} should
1807      * be returned
1808      * @return The floating-point number adjacent to {@code start} in the
1809      * direction of {@code direction}.
1810      * @since 1.6
1811      */
1812     public static double nextAfter(double start, double direction) {
1813         return Math.nextAfter(start, direction);
1814     }
1815 
1816     /**
1817      * Returns the floating-point number adjacent to the first
1818      * argument in the direction of the second argument.  If both
1819      * arguments compare as equal a value equivalent to the second argument
1820      * is returned.
1821      *
1822      * &lt;p&gt;Special cases:
1823      * &lt;ul&gt;
1824      * &lt;li&gt; If either argument is a NaN, then NaN is returned.
1825      *
1826      * &lt;li&gt; If both arguments are signed zeros, a value equivalent
1827      * to {@code direction} is returned.
1828      *
1829      * &lt;li&gt; If {@code start} is
1830      * &amp;plusmn;{@link Float#MIN_VALUE} and {@code direction}
1831      * has a value such that the result should have a smaller
1832      * magnitude, then a zero with the same sign as {@code start}
1833      * is returned.
1834      *
1835      * &lt;li&gt; If {@code start} is infinite and
1836      * {@code direction} has a value such that the result should
1837      * have a smaller magnitude, {@link Float#MAX_VALUE} with the
1838      * same sign as {@code start} is returned.
1839      *
1840      * &lt;li&gt; If {@code start} is equal to &amp;plusmn;
1841      * {@link Float#MAX_VALUE} and {@code direction} has a
1842      * value such that the result should have a larger magnitude, an
1843      * infinity with same sign as {@code start} is returned.
1844      * &lt;/ul&gt;
1845      *
1846      * @param start  starting floating-point value
1847      * @param direction value indicating which of
1848      * {@code start}&#39;s neighbors or {@code start} should
1849      * be returned
1850      * @return The floating-point number adjacent to {@code start} in the
1851      * direction of {@code direction}.
1852      * @since 1.6
1853      */
1854     public static float nextAfter(float start, double direction) {
1855         return Math.nextAfter(start, direction);
1856     }
1857 
1858     /**
1859      * Returns the floating-point value adjacent to {@code d} in
1860      * the direction of positive infinity.  This method is
1861      * semantically equivalent to {@code nextAfter(d,
1862      * Double.POSITIVE_INFINITY)}; however, a {@code nextUp}
1863      * implementation may run faster than its equivalent
1864      * {@code nextAfter} call.
1865      *
1866      * &lt;p&gt;Special Cases:
1867      * &lt;ul&gt;
1868      * &lt;li&gt; If the argument is NaN, the result is NaN.
1869      *
1870      * &lt;li&gt; If the argument is positive infinity, the result is
1871      * positive infinity.
1872      *
1873      * &lt;li&gt; If the argument is zero, the result is
1874      * {@link Double#MIN_VALUE}
1875      *
1876      * &lt;/ul&gt;
1877      *
1878      * @param d starting floating-point value
1879      * @return The adjacent floating-point value closer to positive
1880      * infinity.
1881      * @since 1.6
1882      */
1883     public static double nextUp(double d) {
1884         return Math.nextUp(d);
1885     }
1886 
1887     /**
1888      * Returns the floating-point value adjacent to {@code f} in
1889      * the direction of positive infinity.  This method is
1890      * semantically equivalent to {@code nextAfter(f,
1891      * Float.POSITIVE_INFINITY)}; however, a {@code nextUp}
1892      * implementation may run faster than its equivalent
1893      * {@code nextAfter} call.
1894      *
1895      * &lt;p&gt;Special Cases:
1896      * &lt;ul&gt;
1897      * &lt;li&gt; If the argument is NaN, the result is NaN.
1898      *
1899      * &lt;li&gt; If the argument is positive infinity, the result is
1900      * positive infinity.
1901      *
1902      * &lt;li&gt; If the argument is zero, the result is
1903      * {@link Float#MIN_VALUE}
1904      *
1905      * &lt;/ul&gt;
1906      *
1907      * @param f starting floating-point value
1908      * @return The adjacent floating-point value closer to positive
1909      * infinity.
1910      * @since 1.6
1911      */
1912     public static float nextUp(float f) {
1913         return Math.nextUp(f);
1914     }
1915 
1916     /**
1917      * Returns the floating-point value adjacent to {@code d} in
1918      * the direction of negative infinity.  This method is
1919      * semantically equivalent to {@code nextAfter(d,
1920      * Double.NEGATIVE_INFINITY)}; however, a
1921      * {@code nextDown} implementation may run faster than its
1922      * equivalent {@code nextAfter} call.
1923      *
1924      * &lt;p&gt;Special Cases:
1925      * &lt;ul&gt;
1926      * &lt;li&gt; If the argument is NaN, the result is NaN.
1927      *
1928      * &lt;li&gt; If the argument is negative infinity, the result is
1929      * negative infinity.
1930      *
1931      * &lt;li&gt; If the argument is zero, the result is
1932      * {@code -Double.MIN_VALUE}
1933      *
1934      * &lt;/ul&gt;
1935      *
1936      * @param d  starting floating-point value
1937      * @return The adjacent floating-point value closer to negative
1938      * infinity.
1939      * @since 1.8
1940      */
1941     public static double nextDown(double d) {
1942         return Math.nextDown(d);
1943     }
1944 
1945     /**
1946      * Returns the floating-point value adjacent to {@code f} in
1947      * the direction of negative infinity.  This method is
1948      * semantically equivalent to {@code nextAfter(f,
1949      * Float.NEGATIVE_INFINITY)}; however, a
1950      * {@code nextDown} implementation may run faster than its
1951      * equivalent {@code nextAfter} call.
1952      *
1953      * &lt;p&gt;Special Cases:
1954      * &lt;ul&gt;
1955      * &lt;li&gt; If the argument is NaN, the result is NaN.
1956      *
1957      * &lt;li&gt; If the argument is negative infinity, the result is
1958      * negative infinity.
1959      *
1960      * &lt;li&gt; If the argument is zero, the result is
1961      * {@code -Float.MIN_VALUE}
1962      *
1963      * &lt;/ul&gt;
1964      *
1965      * @param f  starting floating-point value
1966      * @return The adjacent floating-point value closer to negative
1967      * infinity.
1968      * @since 1.8
1969      */
1970     public static float nextDown(float f) {
1971         return Math.nextDown(f);
1972     }
1973 
1974     /**
1975      * Returns {@code d} &amp;times;
1976      * 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt; rounded as if performed
1977      * by a single correctly rounded floating-point multiply to a
1978      * member of the double value set.  See the Java
1979      * Language Specification for a discussion of floating-point
1980      * value sets.  If the exponent of the result is between {@link
1981      * Double#MIN_EXPONENT} and {@link Double#MAX_EXPONENT}, the
1982      * answer is calculated exactly.  If the exponent of the result
1983      * would be larger than {@code Double.MAX_EXPONENT}, an
1984      * infinity is returned.  Note that if the result is subnormal,
1985      * precision may be lost; that is, when {@code scalb(x, n)}
1986      * is subnormal, {@code scalb(scalb(x, n), -n)} may not equal
1987      * &lt;i&gt;x&lt;/i&gt;.  When the result is non-NaN, the result has the same
1988      * sign as {@code d}.
1989      *
1990      * &lt;p&gt;Special cases:
1991      * &lt;ul&gt;
1992      * &lt;li&gt; If the first argument is NaN, NaN is returned.
1993      * &lt;li&gt; If the first argument is infinite, then an infinity of the
1994      * same sign is returned.
1995      * &lt;li&gt; If the first argument is zero, then a zero of the same
1996      * sign is returned.
1997      * &lt;/ul&gt;
1998      *
1999      * @param d number to be scaled by a power of two.
2000      * @param scaleFactor power of 2 used to scale {@code d}
2001      * @return {@code d} &amp;times; 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt;
2002      * @since 1.6
2003      */
2004     public static double scalb(double d, int scaleFactor) {
2005         return Math.scalb(d, scaleFactor);
2006     }
2007 
2008     /**
2009      * Returns {@code f} &amp;times;
2010      * 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt; rounded as if performed
2011      * by a single correctly rounded floating-point multiply to a
2012      * member of the float value set.  See the Java
2013      * Language Specification for a discussion of floating-point
2014      * value sets.  If the exponent of the result is between {@link
2015      * Float#MIN_EXPONENT} and {@link Float#MAX_EXPONENT}, the
2016      * answer is calculated exactly.  If the exponent of the result
2017      * would be larger than {@code Float.MAX_EXPONENT}, an
2018      * infinity is returned.  Note that if the result is subnormal,
2019      * precision may be lost; that is, when {@code scalb(x, n)}
2020      * is subnormal, {@code scalb(scalb(x, n), -n)} may not equal
2021      * &lt;i&gt;x&lt;/i&gt;.  When the result is non-NaN, the result has the same
2022      * sign as {@code f}.
2023      *
2024      * &lt;p&gt;Special cases:
2025      * &lt;ul&gt;
2026      * &lt;li&gt; If the first argument is NaN, NaN is returned.
2027      * &lt;li&gt; If the first argument is infinite, then an infinity of the
2028      * same sign is returned.
2029      * &lt;li&gt; If the first argument is zero, then a zero of the same
2030      * sign is returned.
2031      * &lt;/ul&gt;
2032      *
2033      * @param f number to be scaled by a power of two.
2034      * @param scaleFactor power of 2 used to scale {@code f}
2035      * @return {@code f} &amp;times; 2&lt;sup&gt;{@code scaleFactor}&lt;/sup&gt;
2036      * @since 1.6
2037      */
2038     public static float scalb(float f, int scaleFactor) {
2039         return Math.scalb(f, scaleFactor);
2040     }
2041 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Character.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ClassLoader.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Class.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 120  * &lt;em&gt;nest host&lt;/em&gt;, and enumerates the other nestmates which
 121  * belong to the nest; each of them in turn records it as the nest host.
 122  * The classes and interfaces which belong to a nest, including its host, are
 123  * determined when
 124  * {@code class} files are generated, for example, a Java compiler
 125  * will typically record a top-level class as the host of a nest where the
 126  * other members are the classes and interfaces whose declarations are
 127  * enclosed within the top-level class declaration.
 128  *
 129  * &lt;p&gt; The following example uses a {@code Class} object to print the
 130  * class name of an object:
 131  *
 132  * &lt;blockquote&gt;&lt;pre&gt;
 133  *     void printClassName(Object obj) {
 134  *         System.out.println(&quot;The class of &quot; + obj +
 135  *                            &quot; is &quot; + obj.getClass().getName());
 136  *     }
 137  * &lt;/pre&gt;&lt;/blockquote&gt;
 138  *
 139  * &lt;p&gt; It is also possible to get the {@code Class} object for a named
<span class="line-modified"> 140  * type (or for void) using a class literal.  See Section 15.8.2 of</span>
<span class="line-modified"> 141  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
 142  * For example:
 143  *
 144  * &lt;blockquote&gt;
 145  *     {@code System.out.println(&quot;The name of class Foo is: &quot;+Foo.class.getName());}
 146  * &lt;/blockquote&gt;
 147  *
 148  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 149  * object.  For example, the type of {@code String.class} is {@code
 150  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 151  * unknown.
 152  *
 153  * @author  unascribed
 154  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 155  * @since   1.0
 156  */
 157 public final class Class&lt;T&gt; implements java.io.Serializable,
 158                               GenericDeclaration,
 159                               Type,
 160                               AnnotatedElement,
 161                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
</pre>
<hr />
<pre>
 363      * obtain any of the {@code Class} objects representing primitive
 364      * types or void.
 365      *
 366      * &lt;p&gt; If {@code name} denotes an array class, the component type of
 367      * the array class is loaded but not initialized.
 368      *
 369      * &lt;p&gt; For example, in an instance method the expression:
 370      *
 371      * &lt;blockquote&gt;
 372      *  {@code Class.forName(&quot;Foo&quot;)}
 373      * &lt;/blockquote&gt;
 374      *
 375      * is equivalent to:
 376      *
 377      * &lt;blockquote&gt;
 378      *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
 379      * &lt;/blockquote&gt;
 380      *
 381      * Note that this method throws errors related to loading, linking
 382      * or initializing as specified in Sections {@jls 12.2}, {@jls
<span class="line-modified"> 383      * 12.3}, and {@jls 12.4} of &lt;em&gt;The Java Language</span>
<span class="line-modified"> 384      * Specification&lt;/em&gt;.</span>
 385      * Note that this method does not check whether the requested class
 386      * is accessible to its caller.
 387      *
 388      * @param name       fully qualified name of the desired class
<span class="line-modified"> 389      * @param initialize if {@code true} the class will be initialized (which implies linking).</span>
<span class="line-modified"> 390      *                   See Section {@jls 12.4} of &lt;em&gt;The Java Language Specification&lt;/em&gt;.</span>



 391      * @param loader     class loader from which the class must be loaded
 392      * @return           class object representing the desired class
 393      *
 394      * @throws    LinkageError if the linkage fails
 395      * @throws    ExceptionInInitializerError if the initialization provoked
 396      *            by this method fails
 397      * @throws    ClassNotFoundException if the class cannot be located by
 398      *            the specified class loader
 399      * @throws    SecurityException
 400      *            if a security manager is present, and the {@code loader} is
 401      *            {@code null}, and the caller&#39;s class loader is not
 402      *            {@code null}, and the caller does not have the
 403      *            {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 404      *
 405      * @see       java.lang.Class#forName(String)
 406      * @see       java.lang.ClassLoader
 407      *
 408      * @jls 12.2 Loading of Classes and Interfaces
 409      * @jls 12.3 Linking of Classes and Interfaces
 410      * @jls 12.4 Initialization of Classes and Interfaces
</pre>
<hr />
<pre>
 735      * @since 1.1
 736      */
 737     @HotSpotIntrinsicCandidate
 738     public native boolean isInstance(Object obj);
 739 
 740 
 741     /**
 742      * Determines if the class or interface represented by this
 743      * {@code Class} object is either the same as, or is a superclass or
 744      * superinterface of, the class or interface represented by the specified
 745      * {@code Class} parameter. It returns {@code true} if so;
 746      * otherwise it returns {@code false}. If this {@code Class}
 747      * object represents a primitive type, this method returns
 748      * {@code true} if the specified {@code Class} parameter is
 749      * exactly this {@code Class} object; otherwise it returns
 750      * {@code false}.
 751      *
 752      * &lt;p&gt; Specifically, this method tests whether the type represented by the
 753      * specified {@code Class} parameter can be converted to the type
 754      * represented by this {@code Class} object via an identity conversion
<span class="line-modified"> 755      * or via a widening reference conversion. See &lt;em&gt;The Java Language</span>
<span class="line-modified"> 756      * Specification&lt;/em&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},</span>
 757      * for details.
 758      *
 759      * @param     cls the {@code Class} object to be checked
 760      * @return    the {@code boolean} value indicating whether objects of the
 761      *            type {@code cls} can be assigned to objects of this class
 762      * @throws    NullPointerException if the specified Class parameter is
 763      *            null.
 764      * @since     1.1
 765      */
 766     @HotSpotIntrinsicCandidate
 767     public native boolean isAssignableFrom(Class&lt;?&gt; cls);
 768 
 769 
 770     /**
 771      * Determines if the specified {@code Class} object represents an
 772      * interface type.
 773      *
 774      * @return  {@code true} if this object represents an interface;
 775      *          {@code false} otherwise.
 776      */
</pre>
<hr />
<pre>
 820     @HotSpotIntrinsicCandidate
 821     public native boolean isPrimitive();
 822 
 823     /**
 824      * Returns true if this {@code Class} object represents an annotation
 825      * type.  Note that if this method returns true, {@link #isInterface()}
 826      * would also return true, as all annotation types are also interfaces.
 827      *
 828      * @return {@code true} if this class object represents an annotation
 829      *      type; {@code false} otherwise
 830      * @since 1.5
 831      */
 832     public boolean isAnnotation() {
 833         return (getModifiers() &amp; ANNOTATION) != 0;
 834     }
 835 
 836     /**
 837      * Returns {@code true} if this class is a synthetic class;
 838      * returns {@code false} otherwise.
 839      * @return {@code true} if and only if this class is a synthetic class as
<span class="line-modified"> 840      *         defined by the Java Language Specification.</span>
 841      * @jls 13.1 The Form of a Binary
 842      * @since 1.5
 843      */
 844     public boolean isSynthetic() {
 845         return (getModifiers() &amp; SYNTHETIC) != 0;
 846     }
 847 
 848     /**
 849      * Returns the  name of the entity (class, interface, array class,
 850      * primitive type, or void) represented by this {@code Class} object,
 851      * as a {@code String}.
 852      *
<span class="line-modified"> 853      * &lt;p&gt; If this class object represents a reference type that is not an</span>
<span class="line-modified"> 854      * array type then the binary name of the class is returned, as specified</span>
<span class="line-modified"> 855      * by</span>
<span class="line-modified"> 856      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
 857      *
 858      * &lt;p&gt; If this class object represents a primitive type or void, then the
 859      * name returned is a {@code String} equal to the Java language
 860      * keyword corresponding to the primitive type or void.
 861      *
 862      * &lt;p&gt; If this class object represents a class of arrays, then the internal
 863      * form of the name consists of the name of the element type preceded by
 864      * one or more &#39;{@code [}&#39; characters representing the depth of the array
 865      * nesting.  The encoding of element type names is as follows:
 866      *
 867      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 868      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 869      * &lt;thead&gt;
 870      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 871      * &lt;/thead&gt;
 872      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 873      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; boolean      &lt;td style=&quot;text-align:center&quot;&gt; Z
 874      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; byte         &lt;td style=&quot;text-align:center&quot;&gt; B
 875      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; char         &lt;td style=&quot;text-align:center&quot;&gt; C
 876      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface
</pre>
<hr />
<pre>
 979 
 980     // set by VM
 981     private transient Module module;
 982 
 983     // Initialized in JVM not by private constructor
 984     // This field is filtered from reflection access, i.e. getDeclaredField
 985     // will throw NoSuchFieldException
 986     private final ClassLoader classLoader;
 987 
 988     /**
 989      * Returns an array of {@code TypeVariable} objects that represent the
 990      * type variables declared by the generic declaration represented by this
 991      * {@code GenericDeclaration} object, in declaration order.  Returns an
 992      * array of length 0 if the underlying generic declaration declares no type
 993      * variables.
 994      *
 995      * @return an array of {@code TypeVariable} objects that represent
 996      *     the type variables declared by this generic declaration
 997      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
 998      *     signature of this generic declaration does not conform to
<span class="line-modified"> 999      *     the format specified in</span>
<span class="line-modified">1000      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;</span>
1001      * @since 1.5
1002      */
1003     @SuppressWarnings(&quot;unchecked&quot;)
1004     public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
1005         ClassRepository info = getGenericInfo();
1006         if (info != null)
1007             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters();
1008         else
1009             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])new TypeVariable&lt;?&gt;[0];
1010     }
1011 
1012 
1013     /**
1014      * Returns the {@code Class} representing the direct superclass of the
1015      * entity (class, interface, primitive type or void) represented by
1016      * this {@code Class}.  If this {@code Class} represents either the
1017      * {@code Object} class, an interface, a primitive type, or void, then
1018      * null is returned.  If this object represents an array class then the
1019      * {@code Class} object representing the {@code Object} class is
1020      * returned.
</pre>
<hr />
<pre>
1028     /**
1029      * Returns the {@code Type} representing the direct superclass of
1030      * the entity (class, interface, primitive type or void) represented by
1031      * this {@code Class}.
1032      *
1033      * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
1034      * object returned must accurately reflect the actual type
1035      * arguments used in the source code. The parameterized type
1036      * representing the superclass is created if it had not been
1037      * created before. See the declaration of {@link
1038      * java.lang.reflect.ParameterizedType ParameterizedType} for the
1039      * semantics of the creation process for parameterized types.  If
1040      * this {@code Class} represents either the {@code Object}
1041      * class, an interface, a primitive type, or void, then null is
1042      * returned.  If this object represents an array class then the
1043      * {@code Class} object representing the {@code Object} class is
1044      * returned.
1045      *
1046      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
1047      *     class signature does not conform to the format specified in
<span class="line-modified">1048      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;</span>

1049      * @throws TypeNotPresentException if the generic superclass
1050      *     refers to a non-existent type declaration
1051      * @throws java.lang.reflect.MalformedParameterizedTypeException if the
1052      *     generic superclass refers to a parameterized type that cannot be
1053      *     instantiated  for any reason
1054      * @return the direct superclass of the class represented by this object
1055      * @since 1.5
1056      */
1057     public Type getGenericSuperclass() {
1058         ClassRepository info = getGenericInfo();
1059         if (info == null) {
1060             return getSuperclass();
1061         }
1062 
1063         // Historical irregularity:
1064         // Generic signature marks interfaces with superclass = Object
1065         // but this API returns null for interfaces
1066         if (isInterface()) {
1067             return null;
1068         }
</pre>
<hr />
<pre>
1225      * to the order of the interface names in the {@code implements} clause of
1226      * the declaration of the class represented by this object.
1227      *
1228      * &lt;p&gt;If this object represents an interface, the array contains objects
1229      * representing all interfaces directly extended by the interface.  The
1230      * order of the interface objects in the array corresponds to the order of
1231      * the interface names in the {@code extends} clause of the declaration of
1232      * the interface represented by this object.
1233      *
1234      * &lt;p&gt;If this object represents a class or interface that implements no
1235      * interfaces, the method returns an array of length 0.
1236      *
1237      * &lt;p&gt;If this object represents a primitive type or void, the method
1238      * returns an array of length 0.
1239      *
1240      * &lt;p&gt;If this {@code Class} object represents an array type, the
1241      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1242      * returned in that order.
1243      *
1244      * @throws java.lang.reflect.GenericSignatureFormatError
<span class="line-modified">1245      *     if the generic class signature does not conform to the format</span>
<span class="line-modified">1246      *     specified in</span>
<span class="line-modified">1247      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;</span>
1248      * @throws TypeNotPresentException if any of the generic
1249      *     superinterfaces refers to a non-existent type declaration
1250      * @throws java.lang.reflect.MalformedParameterizedTypeException
1251      *     if any of the generic superinterfaces refer to a parameterized
1252      *     type that cannot be instantiated for any reason
1253      * @return an array of interfaces directly implemented by this class
1254      * @since 1.5
1255      */
1256     public Type[] getGenericInterfaces() {
1257         ClassRepository info = getGenericInfo();
1258         return (info == null) ?  getInterfaces() : info.getSuperInterfaces();
1259     }
1260 
1261 
1262     /**
1263      * Returns the {@code Class} representing the component type of an
1264      * array.  If this class does not represent an array class this method
1265      * returns null.
1266      *
1267      * @return the {@code Class} representing the component type of this
</pre>
<hr />
<pre>
1284     /**
1285      * Returns the Java language modifiers for this class or interface, encoded
1286      * in an integer. The modifiers consist of the Java Virtual Machine&#39;s
1287      * constants for {@code public}, {@code protected},
1288      * {@code private}, {@code final}, {@code static},
1289      * {@code abstract} and {@code interface}; they should be decoded
1290      * using the methods of class {@code Modifier}.
1291      *
1292      * &lt;p&gt; If the underlying class is an array class, then its
1293      * {@code public}, {@code private} and {@code protected}
1294      * modifiers are the same as those of its component type.  If this
1295      * {@code Class} represents a primitive type or void, its
1296      * {@code public} modifier is always {@code true}, and its
1297      * {@code protected} and {@code private} modifiers are always
1298      * {@code false}. If this object represents an array class, a
1299      * primitive type or void, then its {@code final} modifier is always
1300      * {@code true} and its interface modifier is always
1301      * {@code false}. The values of its other modifiers are not determined
1302      * by this specification.
1303      *
<span class="line-modified">1304      * &lt;p&gt; The modifier encodings are defined in &lt;em&gt;The Java Virtual Machine</span>
<span class="line-modified">1305      * Specification&lt;/em&gt;, table 4.1.</span>
1306      *
1307      * @return the {@code int} representing the modifiers for this class
1308      * @see     java.lang.reflect.Modifier
1309      * @since 1.1
1310      */
1311     @HotSpotIntrinsicCandidate
1312     public native int getModifiers();
1313 
1314     /**
1315      * Gets the signers of this class.
1316      *
1317      * @return  the signers of this class, or null if there are no signers.  In
1318      *          particular, this method returns null if this object represents
1319      *          a primitive type or void.
1320      * @since   1.1
1321      */
1322     public Object[] getSigners() {
1323         return asPrimaryType().getSigners0();
1324     }
1325 
</pre>
<hr />
<pre>
1699      *
1700      * @return an informative string for the name of this type
1701      * @since 1.8
1702      */
1703     public String getTypeName() {
1704         if (isArray()) {
1705             try {
1706                 Class&lt;?&gt; cl = this;
1707                 int dimensions = 0;
1708                 do {
1709                     dimensions++;
1710                     cl = cl.getComponentType();
1711                 } while (cl.isArray());
1712                 return cl.getTypeName() + &quot;[]&quot;.repeat(dimensions);
1713             } catch (Throwable e) { /*FALLTHRU*/ }
1714         }
1715         return toTypeName();
1716     }
1717 
1718     /**
<span class="line-modified">1719      * Returns the canonical name of the underlying class as</span>
<span class="line-modified">1720      * defined by the Java Language Specification.  Returns null if</span>
<span class="line-modified">1721      * the underlying class does not have a canonical name (i.e., if</span>
<span class="line-modified">1722      * it is a local or anonymous class or an array whose component</span>
<span class="line-modified">1723      * type does not have a canonical name).</span>
1724      * @return the canonical name of the underlying class if it exists, and
1725      * {@code null} otherwise.
1726      * @since 1.5
1727      */
1728     public String getCanonicalName() {
1729         ReflectionData&lt;T&gt; rd = reflectionData();
1730         String canonicalName = rd.canonicalName;
1731         if (canonicalName == null) {
1732             rd.canonicalName = canonicalName = getCanonicalName0();
1733         }
1734         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1735     }
1736 
1737     private String getCanonicalName0() {
1738         if (isArray()) {
1739             String canonicalName = getComponentType().getCanonicalName();
1740             if (canonicalName != null)
1741                 return canonicalName + &quot;[]&quot;;
1742             else
1743                 return ReflectionData.NULL_SENTINEL;
</pre>
<hr />
<pre>
2017      * @jls 8.4 Method Declarations
2018      * @since 1.1
2019      */
2020     @CallerSensitive
2021     public Method[] getMethods() throws SecurityException {
2022         SecurityManager sm = System.getSecurityManager();
2023         if (sm != null) {
2024             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2025         }
2026         return copyMethods(privateGetPublicMethods());
2027     }
2028 
2029 
2030     /**
2031      * Returns an array containing {@code Constructor} objects reflecting
2032      * all the public constructors of the class represented by this
2033      * {@code Class} object.  An array of length 0 is returned if the
2034      * class has no public constructors, or if the class is an array class, or
2035      * if the class reflects a primitive type or void.
2036      *
<span class="line-modified">2037      * Note that while this method returns an array of {@code</span>

2038      * Constructor&lt;T&gt;} objects (that is an array of constructors from
2039      * this class), the return type of this method is {@code
2040      * Constructor&lt;?&gt;[]} and &lt;em&gt;not&lt;/em&gt; {@code Constructor&lt;T&gt;[]} as
2041      * might be expected.  This less informative return type is
2042      * necessary since after being returned from this method, the
2043      * array could be modified to hold {@code Constructor} objects for
2044      * different classes, which would violate the type guarantees of
2045      * {@code Constructor&lt;T&gt;[]}.
2046      *
2047      * @return the array of {@code Constructor} objects representing the
2048      *         public constructors of this class
2049      * @throws SecurityException
2050      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2051      *         the caller&#39;s class loader is not the same as or an
2052      *         ancestor of the class loader for the current class and
2053      *         invocation of {@link SecurityManager#checkPackageAccess
2054      *         s.checkPackageAccess()} denies access to the package
2055      *         of this class.
2056      *
2057      * @since 1.1
</pre>
<hr />
<pre>
2490     public Method[] getDeclaredMethods() throws SecurityException {
2491         SecurityManager sm = System.getSecurityManager();
2492         if (sm != null) {
2493             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2494         }
2495         return copyMethods(privateGetDeclaredMethods(false));
2496     }
2497 
2498 
2499     /**
2500      * Returns an array of {@code Constructor} objects reflecting all the
2501      * constructors declared by the class represented by this
2502      * {@code Class} object. These are public, protected, default
2503      * (package) access, and private constructors.  The elements in the array
2504      * returned are not sorted and are not in any particular order.  If the
2505      * class has a default constructor, it is included in the returned array.
2506      * This method returns an array of length 0 if this {@code Class}
2507      * object represents an interface, a primitive type, an array class, or
2508      * void.
2509      *
<span class="line-modified">2510      * &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, section {@jls 8.2}.</span>

2511      *
2512      * @return  the array of {@code Constructor} objects representing all the
2513      *          declared constructors of this class
2514      * @throws  SecurityException
2515      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2516      *          following conditions is met:
2517      *
2518      *          &lt;ul&gt;
2519      *
2520      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2521      *          class loader of this class and invocation of
2522      *          {@link SecurityManager#checkPermission
2523      *          s.checkPermission} method with
2524      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2525      *          denies access to the declared constructors within this class
2526      *
2527      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2528      *          ancestor of the class loader for the current class and
2529      *          invocation of {@link SecurityManager#checkPackageAccess
2530      *          s.checkPackageAccess()} denies access to the package
</pre>
<hr />
<pre>
3635      * is written into the stream. Future references to the class descriptor
3636      * are written as references to the initial class descriptor instance.
3637      *
3638      * @see java.io.ObjectStreamClass
3639      */
3640     @java.io.Serial
3641     private static final ObjectStreamField[] serialPersistentFields =
3642         new ObjectStreamField[0];
3643 
3644 
3645     /**
3646      * Returns the assertion status that would be assigned to this
3647      * class if it were to be initialized at the time this method is invoked.
3648      * If this class has had its assertion status set, the most recent
3649      * setting will be returned; otherwise, if any package default assertion
3650      * status pertains to this class, the most recent setting for the most
3651      * specific pertinent package default assertion status is returned;
3652      * otherwise, if this class is not a system class (i.e., it has a
3653      * class loader) its class loader&#39;s default assertion status is returned;
3654      * otherwise, the system class default assertion status is returned.
<span class="line-modified">3655      * &lt;p&gt;</span>

3656      * Few programmers will have any need for this method; it is provided
<span class="line-modified">3657      * for the benefit of the JRE itself.  (It allows a class to determine at</span>
3658      * the time that it is initialized whether assertions should be enabled.)
3659      * Note that this method is not guaranteed to return the actual
3660      * assertion status that was (or will be) associated with the specified
3661      * class when it was (or will be) initialized.
3662      *
3663      * @return the desired assertion status of the specified class.
3664      * @see    java.lang.ClassLoader#setClassAssertionStatus
3665      * @see    java.lang.ClassLoader#setPackageAssertionStatus
3666      * @see    java.lang.ClassLoader#setDefaultAssertionStatus
3667      * @since  1.4
3668      */
3669     public boolean desiredAssertionStatus() {
3670         ClassLoader loader = getClassLoader0();
3671         // If the loader is null this is a system class, so ask the VM
3672         if (loader == null)
3673             return desiredAssertionStatus0(this);
3674 
3675         // If the classloader has been initialized with the assertion
3676         // directives, ask it. Otherwise, ask the VM.
3677         synchronized(loader.assertionLock) {
</pre>
<hr />
<pre>
4127     /**
4128      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4129      * or interface represented by this {@code Class} object belongs.
4130      * Every class and interface is a member of exactly one nest.
4131      * A class or interface that is not recorded as belonging to a nest
4132      * belongs to the nest consisting only of itself, and is the nest
4133      * host.
4134      *
4135      * &lt;p&gt;Each of the {@code Class} objects representing array types,
4136      * primitive types, and {@code void} returns {@code this} to indicate
4137      * that the represented entity belongs to the nest consisting only of
4138      * itself, and is the nest host.
4139      *
4140      * &lt;p&gt;If there is a {@linkplain LinkageError linkage error} accessing
4141      * the nest host, or if this class or interface is not enumerated as
4142      * a member of the nest by the nest host, then it is considered to belong
4143      * to its own nest and {@code this} is returned as the host.
4144      *
4145      * @apiNote A {@code class} file of version 55.0 or greater may record the
4146      * host of the nest to which it belongs by using the {@code NestHost}
<span class="line-modified">4147      * attribute (JVMS 4.7.28). Alternatively, a {@code class} file of</span>
4148      * version 55.0 or greater may act as a nest host by enumerating the nest&#39;s
4149      * other members with the
<span class="line-modified">4150      * {@code NestMembers} attribute (JVMS 4.7.29).</span>
4151      * A {@code class} file of version 54.0 or lower does not use these
4152      * attributes.
4153      *
4154      * @return the nest host of this class or interface
4155      *
4156      * @throws SecurityException
4157      *         If the returned class is not the current class, and
4158      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4159      *         class loader is not the same as or an ancestor of the class
4160      *         loader for the returned class and invocation of {@link
4161      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4162      *         denies access to the package of the returned class
4163      * @since 11
4164      * @jvms 4.7.28 The {@code NestHost} Attribute
4165      * @jvms 4.7.29 The {@code NestMembers} Attribute
4166      * @jvms 5.4.4 Access Control
4167      */
4168     @CallerSensitive
4169     public Class&lt;?&gt; getNestHost() {
4170         if (isPrimitive() || isArray()) {
</pre>
</td>
<td>
<hr />
<pre>
 120  * &lt;em&gt;nest host&lt;/em&gt;, and enumerates the other nestmates which
 121  * belong to the nest; each of them in turn records it as the nest host.
 122  * The classes and interfaces which belong to a nest, including its host, are
 123  * determined when
 124  * {@code class} files are generated, for example, a Java compiler
 125  * will typically record a top-level class as the host of a nest where the
 126  * other members are the classes and interfaces whose declarations are
 127  * enclosed within the top-level class declaration.
 128  *
 129  * &lt;p&gt; The following example uses a {@code Class} object to print the
 130  * class name of an object:
 131  *
 132  * &lt;blockquote&gt;&lt;pre&gt;
 133  *     void printClassName(Object obj) {
 134  *         System.out.println(&quot;The class of &quot; + obj +
 135  *                            &quot; is &quot; + obj.getClass().getName());
 136  *     }
 137  * &lt;/pre&gt;&lt;/blockquote&gt;
 138  *
 139  * &lt;p&gt; It is also possible to get the {@code Class} object for a named
<span class="line-modified"> 140  * type (or for void) using a class literal.  See Section {@jls</span>
<span class="line-modified"> 141  * 15.8.2} of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
 142  * For example:
 143  *
 144  * &lt;blockquote&gt;
 145  *     {@code System.out.println(&quot;The name of class Foo is: &quot;+Foo.class.getName());}
 146  * &lt;/blockquote&gt;
 147  *
 148  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 149  * object.  For example, the type of {@code String.class} is {@code
 150  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 151  * unknown.
 152  *
 153  * @author  unascribed
 154  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 155  * @since   1.0
 156  */
 157 public final class Class&lt;T&gt; implements java.io.Serializable,
 158                               GenericDeclaration,
 159                               Type,
 160                               AnnotatedElement,
 161                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
</pre>
<hr />
<pre>
 363      * obtain any of the {@code Class} objects representing primitive
 364      * types or void.
 365      *
 366      * &lt;p&gt; If {@code name} denotes an array class, the component type of
 367      * the array class is loaded but not initialized.
 368      *
 369      * &lt;p&gt; For example, in an instance method the expression:
 370      *
 371      * &lt;blockquote&gt;
 372      *  {@code Class.forName(&quot;Foo&quot;)}
 373      * &lt;/blockquote&gt;
 374      *
 375      * is equivalent to:
 376      *
 377      * &lt;blockquote&gt;
 378      *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
 379      * &lt;/blockquote&gt;
 380      *
 381      * Note that this method throws errors related to loading, linking
 382      * or initializing as specified in Sections {@jls 12.2}, {@jls
<span class="line-modified"> 383      * 12.3}, and {@jls 12.4} of &lt;cite&gt;The Java&amp;trade; Language</span>
<span class="line-modified"> 384      * Specification&lt;/cite&gt;.</span>
 385      * Note that this method does not check whether the requested class
 386      * is accessible to its caller.
 387      *
 388      * @param name       fully qualified name of the desired class
<span class="line-modified"> 389 </span>
<span class="line-modified"> 390      * @param initialize if {@code true} the class will be initialized</span>
<span class="line-added"> 391      *                   (which implies linking). See Section {@jls</span>
<span class="line-added"> 392      *                   12.4} of &lt;cite&gt;The Java&amp;trade; Language</span>
<span class="line-added"> 393      *                   Specification&lt;/cite&gt;.</span>
 394      * @param loader     class loader from which the class must be loaded
 395      * @return           class object representing the desired class
 396      *
 397      * @throws    LinkageError if the linkage fails
 398      * @throws    ExceptionInInitializerError if the initialization provoked
 399      *            by this method fails
 400      * @throws    ClassNotFoundException if the class cannot be located by
 401      *            the specified class loader
 402      * @throws    SecurityException
 403      *            if a security manager is present, and the {@code loader} is
 404      *            {@code null}, and the caller&#39;s class loader is not
 405      *            {@code null}, and the caller does not have the
 406      *            {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 407      *
 408      * @see       java.lang.Class#forName(String)
 409      * @see       java.lang.ClassLoader
 410      *
 411      * @jls 12.2 Loading of Classes and Interfaces
 412      * @jls 12.3 Linking of Classes and Interfaces
 413      * @jls 12.4 Initialization of Classes and Interfaces
</pre>
<hr />
<pre>
 738      * @since 1.1
 739      */
 740     @HotSpotIntrinsicCandidate
 741     public native boolean isInstance(Object obj);
 742 
 743 
 744     /**
 745      * Determines if the class or interface represented by this
 746      * {@code Class} object is either the same as, or is a superclass or
 747      * superinterface of, the class or interface represented by the specified
 748      * {@code Class} parameter. It returns {@code true} if so;
 749      * otherwise it returns {@code false}. If this {@code Class}
 750      * object represents a primitive type, this method returns
 751      * {@code true} if the specified {@code Class} parameter is
 752      * exactly this {@code Class} object; otherwise it returns
 753      * {@code false}.
 754      *
 755      * &lt;p&gt; Specifically, this method tests whether the type represented by the
 756      * specified {@code Class} parameter can be converted to the type
 757      * represented by this {@code Class} object via an identity conversion
<span class="line-modified"> 758      * or via a widening reference conversion. See &lt;cite&gt;The Java&amp;trade; Language</span>
<span class="line-modified"> 759      * Specification&lt;/cite&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},</span>
 760      * for details.
 761      *
 762      * @param     cls the {@code Class} object to be checked
 763      * @return    the {@code boolean} value indicating whether objects of the
 764      *            type {@code cls} can be assigned to objects of this class
 765      * @throws    NullPointerException if the specified Class parameter is
 766      *            null.
 767      * @since     1.1
 768      */
 769     @HotSpotIntrinsicCandidate
 770     public native boolean isAssignableFrom(Class&lt;?&gt; cls);
 771 
 772 
 773     /**
 774      * Determines if the specified {@code Class} object represents an
 775      * interface type.
 776      *
 777      * @return  {@code true} if this object represents an interface;
 778      *          {@code false} otherwise.
 779      */
</pre>
<hr />
<pre>
 823     @HotSpotIntrinsicCandidate
 824     public native boolean isPrimitive();
 825 
 826     /**
 827      * Returns true if this {@code Class} object represents an annotation
 828      * type.  Note that if this method returns true, {@link #isInterface()}
 829      * would also return true, as all annotation types are also interfaces.
 830      *
 831      * @return {@code true} if this class object represents an annotation
 832      *      type; {@code false} otherwise
 833      * @since 1.5
 834      */
 835     public boolean isAnnotation() {
 836         return (getModifiers() &amp; ANNOTATION) != 0;
 837     }
 838 
 839     /**
 840      * Returns {@code true} if this class is a synthetic class;
 841      * returns {@code false} otherwise.
 842      * @return {@code true} if and only if this class is a synthetic class as
<span class="line-modified"> 843      *         defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
 844      * @jls 13.1 The Form of a Binary
 845      * @since 1.5
 846      */
 847     public boolean isSynthetic() {
 848         return (getModifiers() &amp; SYNTHETIC) != 0;
 849     }
 850 
 851     /**
 852      * Returns the  name of the entity (class, interface, array class,
 853      * primitive type, or void) represented by this {@code Class} object,
 854      * as a {@code String}.
 855      *
<span class="line-modified"> 856      * &lt;p&gt; If this class object represents a reference type that is</span>
<span class="line-modified"> 857      * not an array type then the binary name of the class is</span>
<span class="line-modified"> 858      * returned, as specified by &lt;cite&gt;The Java&amp;trade; Language</span>
<span class="line-modified"> 859      * Specification&lt;/cite&gt;.</span>
 860      *
 861      * &lt;p&gt; If this class object represents a primitive type or void, then the
 862      * name returned is a {@code String} equal to the Java language
 863      * keyword corresponding to the primitive type or void.
 864      *
 865      * &lt;p&gt; If this class object represents a class of arrays, then the internal
 866      * form of the name consists of the name of the element type preceded by
 867      * one or more &#39;{@code [}&#39; characters representing the depth of the array
 868      * nesting.  The encoding of element type names is as follows:
 869      *
 870      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 871      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 872      * &lt;thead&gt;
 873      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 874      * &lt;/thead&gt;
 875      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 876      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; boolean      &lt;td style=&quot;text-align:center&quot;&gt; Z
 877      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; byte         &lt;td style=&quot;text-align:center&quot;&gt; B
 878      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; char         &lt;td style=&quot;text-align:center&quot;&gt; C
 879      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface
</pre>
<hr />
<pre>
 982 
 983     // set by VM
 984     private transient Module module;
 985 
 986     // Initialized in JVM not by private constructor
 987     // This field is filtered from reflection access, i.e. getDeclaredField
 988     // will throw NoSuchFieldException
 989     private final ClassLoader classLoader;
 990 
 991     /**
 992      * Returns an array of {@code TypeVariable} objects that represent the
 993      * type variables declared by the generic declaration represented by this
 994      * {@code GenericDeclaration} object, in declaration order.  Returns an
 995      * array of length 0 if the underlying generic declaration declares no type
 996      * variables.
 997      *
 998      * @return an array of {@code TypeVariable} objects that represent
 999      *     the type variables declared by this generic declaration
1000      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
1001      *     signature of this generic declaration does not conform to
<span class="line-modified">1002      *     the format specified in section {@jvms 4.7.9} of</span>
<span class="line-modified">1003      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;,</span>
1004      * @since 1.5
1005      */
1006     @SuppressWarnings(&quot;unchecked&quot;)
1007     public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
1008         ClassRepository info = getGenericInfo();
1009         if (info != null)
1010             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters();
1011         else
1012             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])new TypeVariable&lt;?&gt;[0];
1013     }
1014 
1015 
1016     /**
1017      * Returns the {@code Class} representing the direct superclass of the
1018      * entity (class, interface, primitive type or void) represented by
1019      * this {@code Class}.  If this {@code Class} represents either the
1020      * {@code Object} class, an interface, a primitive type, or void, then
1021      * null is returned.  If this object represents an array class then the
1022      * {@code Class} object representing the {@code Object} class is
1023      * returned.
</pre>
<hr />
<pre>
1031     /**
1032      * Returns the {@code Type} representing the direct superclass of
1033      * the entity (class, interface, primitive type or void) represented by
1034      * this {@code Class}.
1035      *
1036      * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
1037      * object returned must accurately reflect the actual type
1038      * arguments used in the source code. The parameterized type
1039      * representing the superclass is created if it had not been
1040      * created before. See the declaration of {@link
1041      * java.lang.reflect.ParameterizedType ParameterizedType} for the
1042      * semantics of the creation process for parameterized types.  If
1043      * this {@code Class} represents either the {@code Object}
1044      * class, an interface, a primitive type, or void, then null is
1045      * returned.  If this object represents an array class then the
1046      * {@code Class} object representing the {@code Object} class is
1047      * returned.
1048      *
1049      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
1050      *     class signature does not conform to the format specified in
<span class="line-modified">1051      *     section {@jvms 4.7.9} of &lt;cite&gt;The Java&amp;trade; Virtual</span>
<span class="line-added">1052      *     Machine Specification&lt;/cite&gt;</span>
1053      * @throws TypeNotPresentException if the generic superclass
1054      *     refers to a non-existent type declaration
1055      * @throws java.lang.reflect.MalformedParameterizedTypeException if the
1056      *     generic superclass refers to a parameterized type that cannot be
1057      *     instantiated  for any reason
1058      * @return the direct superclass of the class represented by this object
1059      * @since 1.5
1060      */
1061     public Type getGenericSuperclass() {
1062         ClassRepository info = getGenericInfo();
1063         if (info == null) {
1064             return getSuperclass();
1065         }
1066 
1067         // Historical irregularity:
1068         // Generic signature marks interfaces with superclass = Object
1069         // but this API returns null for interfaces
1070         if (isInterface()) {
1071             return null;
1072         }
</pre>
<hr />
<pre>
1229      * to the order of the interface names in the {@code implements} clause of
1230      * the declaration of the class represented by this object.
1231      *
1232      * &lt;p&gt;If this object represents an interface, the array contains objects
1233      * representing all interfaces directly extended by the interface.  The
1234      * order of the interface objects in the array corresponds to the order of
1235      * the interface names in the {@code extends} clause of the declaration of
1236      * the interface represented by this object.
1237      *
1238      * &lt;p&gt;If this object represents a class or interface that implements no
1239      * interfaces, the method returns an array of length 0.
1240      *
1241      * &lt;p&gt;If this object represents a primitive type or void, the method
1242      * returns an array of length 0.
1243      *
1244      * &lt;p&gt;If this {@code Class} object represents an array type, the
1245      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1246      * returned in that order.
1247      *
1248      * @throws java.lang.reflect.GenericSignatureFormatError
<span class="line-modified">1249      *     if the generic class signature does not conform to the</span>
<span class="line-modified">1250      *     format specified in section {@jvms 4.7.9} of &lt;cite&gt;The</span>
<span class="line-modified">1251      *     Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;</span>
1252      * @throws TypeNotPresentException if any of the generic
1253      *     superinterfaces refers to a non-existent type declaration
1254      * @throws java.lang.reflect.MalformedParameterizedTypeException
1255      *     if any of the generic superinterfaces refer to a parameterized
1256      *     type that cannot be instantiated for any reason
1257      * @return an array of interfaces directly implemented by this class
1258      * @since 1.5
1259      */
1260     public Type[] getGenericInterfaces() {
1261         ClassRepository info = getGenericInfo();
1262         return (info == null) ?  getInterfaces() : info.getSuperInterfaces();
1263     }
1264 
1265 
1266     /**
1267      * Returns the {@code Class} representing the component type of an
1268      * array.  If this class does not represent an array class this method
1269      * returns null.
1270      *
1271      * @return the {@code Class} representing the component type of this
</pre>
<hr />
<pre>
1288     /**
1289      * Returns the Java language modifiers for this class or interface, encoded
1290      * in an integer. The modifiers consist of the Java Virtual Machine&#39;s
1291      * constants for {@code public}, {@code protected},
1292      * {@code private}, {@code final}, {@code static},
1293      * {@code abstract} and {@code interface}; they should be decoded
1294      * using the methods of class {@code Modifier}.
1295      *
1296      * &lt;p&gt; If the underlying class is an array class, then its
1297      * {@code public}, {@code private} and {@code protected}
1298      * modifiers are the same as those of its component type.  If this
1299      * {@code Class} represents a primitive type or void, its
1300      * {@code public} modifier is always {@code true}, and its
1301      * {@code protected} and {@code private} modifiers are always
1302      * {@code false}. If this object represents an array class, a
1303      * primitive type or void, then its {@code final} modifier is always
1304      * {@code true} and its interface modifier is always
1305      * {@code false}. The values of its other modifiers are not determined
1306      * by this specification.
1307      *
<span class="line-modified">1308      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}</span>
<span class="line-modified">1309      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.</span>
1310      *
1311      * @return the {@code int} representing the modifiers for this class
1312      * @see     java.lang.reflect.Modifier
1313      * @since 1.1
1314      */
1315     @HotSpotIntrinsicCandidate
1316     public native int getModifiers();
1317 
1318     /**
1319      * Gets the signers of this class.
1320      *
1321      * @return  the signers of this class, or null if there are no signers.  In
1322      *          particular, this method returns null if this object represents
1323      *          a primitive type or void.
1324      * @since   1.1
1325      */
1326     public Object[] getSigners() {
1327         return asPrimaryType().getSigners0();
1328     }
1329 
</pre>
<hr />
<pre>
1703      *
1704      * @return an informative string for the name of this type
1705      * @since 1.8
1706      */
1707     public String getTypeName() {
1708         if (isArray()) {
1709             try {
1710                 Class&lt;?&gt; cl = this;
1711                 int dimensions = 0;
1712                 do {
1713                     dimensions++;
1714                     cl = cl.getComponentType();
1715                 } while (cl.isArray());
1716                 return cl.getTypeName() + &quot;[]&quot;.repeat(dimensions);
1717             } catch (Throwable e) { /*FALLTHRU*/ }
1718         }
1719         return toTypeName();
1720     }
1721 
1722     /**
<span class="line-modified">1723      * Returns the canonical name of the underlying class as defined</span>
<span class="line-modified">1724      * by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;, section</span>
<span class="line-modified">1725      * {@jls 6.7}.  Returns null if the underlying class does not have</span>
<span class="line-modified">1726      * a canonical name (i.e., if it is a local or anonymous class or</span>
<span class="line-modified">1727      * an array whose component type does not have a canonical name).</span>
1728      * @return the canonical name of the underlying class if it exists, and
1729      * {@code null} otherwise.
1730      * @since 1.5
1731      */
1732     public String getCanonicalName() {
1733         ReflectionData&lt;T&gt; rd = reflectionData();
1734         String canonicalName = rd.canonicalName;
1735         if (canonicalName == null) {
1736             rd.canonicalName = canonicalName = getCanonicalName0();
1737         }
1738         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1739     }
1740 
1741     private String getCanonicalName0() {
1742         if (isArray()) {
1743             String canonicalName = getComponentType().getCanonicalName();
1744             if (canonicalName != null)
1745                 return canonicalName + &quot;[]&quot;;
1746             else
1747                 return ReflectionData.NULL_SENTINEL;
</pre>
<hr />
<pre>
2021      * @jls 8.4 Method Declarations
2022      * @since 1.1
2023      */
2024     @CallerSensitive
2025     public Method[] getMethods() throws SecurityException {
2026         SecurityManager sm = System.getSecurityManager();
2027         if (sm != null) {
2028             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2029         }
2030         return copyMethods(privateGetPublicMethods());
2031     }
2032 
2033 
2034     /**
2035      * Returns an array containing {@code Constructor} objects reflecting
2036      * all the public constructors of the class represented by this
2037      * {@code Class} object.  An array of length 0 is returned if the
2038      * class has no public constructors, or if the class is an array class, or
2039      * if the class reflects a primitive type or void.
2040      *
<span class="line-modified">2041      * @apiNote</span>
<span class="line-added">2042      * While this method returns an array of {@code</span>
2043      * Constructor&lt;T&gt;} objects (that is an array of constructors from
2044      * this class), the return type of this method is {@code
2045      * Constructor&lt;?&gt;[]} and &lt;em&gt;not&lt;/em&gt; {@code Constructor&lt;T&gt;[]} as
2046      * might be expected.  This less informative return type is
2047      * necessary since after being returned from this method, the
2048      * array could be modified to hold {@code Constructor} objects for
2049      * different classes, which would violate the type guarantees of
2050      * {@code Constructor&lt;T&gt;[]}.
2051      *
2052      * @return the array of {@code Constructor} objects representing the
2053      *         public constructors of this class
2054      * @throws SecurityException
2055      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2056      *         the caller&#39;s class loader is not the same as or an
2057      *         ancestor of the class loader for the current class and
2058      *         invocation of {@link SecurityManager#checkPackageAccess
2059      *         s.checkPackageAccess()} denies access to the package
2060      *         of this class.
2061      *
2062      * @since 1.1
</pre>
<hr />
<pre>
2495     public Method[] getDeclaredMethods() throws SecurityException {
2496         SecurityManager sm = System.getSecurityManager();
2497         if (sm != null) {
2498             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2499         }
2500         return copyMethods(privateGetDeclaredMethods(false));
2501     }
2502 
2503 
2504     /**
2505      * Returns an array of {@code Constructor} objects reflecting all the
2506      * constructors declared by the class represented by this
2507      * {@code Class} object. These are public, protected, default
2508      * (package) access, and private constructors.  The elements in the array
2509      * returned are not sorted and are not in any particular order.  If the
2510      * class has a default constructor, it is included in the returned array.
2511      * This method returns an array of length 0 if this {@code Class}
2512      * object represents an interface, a primitive type, an array class, or
2513      * void.
2514      *
<span class="line-modified">2515      * &lt;p&gt; See &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,</span>
<span class="line-added">2516      * section {@jls 8.2}.</span>
2517      *
2518      * @return  the array of {@code Constructor} objects representing all the
2519      *          declared constructors of this class
2520      * @throws  SecurityException
2521      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2522      *          following conditions is met:
2523      *
2524      *          &lt;ul&gt;
2525      *
2526      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2527      *          class loader of this class and invocation of
2528      *          {@link SecurityManager#checkPermission
2529      *          s.checkPermission} method with
2530      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2531      *          denies access to the declared constructors within this class
2532      *
2533      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2534      *          ancestor of the class loader for the current class and
2535      *          invocation of {@link SecurityManager#checkPackageAccess
2536      *          s.checkPackageAccess()} denies access to the package
</pre>
<hr />
<pre>
3641      * is written into the stream. Future references to the class descriptor
3642      * are written as references to the initial class descriptor instance.
3643      *
3644      * @see java.io.ObjectStreamClass
3645      */
3646     @java.io.Serial
3647     private static final ObjectStreamField[] serialPersistentFields =
3648         new ObjectStreamField[0];
3649 
3650 
3651     /**
3652      * Returns the assertion status that would be assigned to this
3653      * class if it were to be initialized at the time this method is invoked.
3654      * If this class has had its assertion status set, the most recent
3655      * setting will be returned; otherwise, if any package default assertion
3656      * status pertains to this class, the most recent setting for the most
3657      * specific pertinent package default assertion status is returned;
3658      * otherwise, if this class is not a system class (i.e., it has a
3659      * class loader) its class loader&#39;s default assertion status is returned;
3660      * otherwise, the system class default assertion status is returned.
<span class="line-modified">3661      *</span>
<span class="line-added">3662      * @apiNote</span>
3663      * Few programmers will have any need for this method; it is provided
<span class="line-modified">3664      * for the benefit of the JDK itself.  (It allows a class to determine at</span>
3665      * the time that it is initialized whether assertions should be enabled.)
3666      * Note that this method is not guaranteed to return the actual
3667      * assertion status that was (or will be) associated with the specified
3668      * class when it was (or will be) initialized.
3669      *
3670      * @return the desired assertion status of the specified class.
3671      * @see    java.lang.ClassLoader#setClassAssertionStatus
3672      * @see    java.lang.ClassLoader#setPackageAssertionStatus
3673      * @see    java.lang.ClassLoader#setDefaultAssertionStatus
3674      * @since  1.4
3675      */
3676     public boolean desiredAssertionStatus() {
3677         ClassLoader loader = getClassLoader0();
3678         // If the loader is null this is a system class, so ask the VM
3679         if (loader == null)
3680             return desiredAssertionStatus0(this);
3681 
3682         // If the classloader has been initialized with the assertion
3683         // directives, ask it. Otherwise, ask the VM.
3684         synchronized(loader.assertionLock) {
</pre>
<hr />
<pre>
4134     /**
4135      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4136      * or interface represented by this {@code Class} object belongs.
4137      * Every class and interface is a member of exactly one nest.
4138      * A class or interface that is not recorded as belonging to a nest
4139      * belongs to the nest consisting only of itself, and is the nest
4140      * host.
4141      *
4142      * &lt;p&gt;Each of the {@code Class} objects representing array types,
4143      * primitive types, and {@code void} returns {@code this} to indicate
4144      * that the represented entity belongs to the nest consisting only of
4145      * itself, and is the nest host.
4146      *
4147      * &lt;p&gt;If there is a {@linkplain LinkageError linkage error} accessing
4148      * the nest host, or if this class or interface is not enumerated as
4149      * a member of the nest by the nest host, then it is considered to belong
4150      * to its own nest and {@code this} is returned as the host.
4151      *
4152      * @apiNote A {@code class} file of version 55.0 or greater may record the
4153      * host of the nest to which it belongs by using the {@code NestHost}
<span class="line-modified">4154      * attribute (JVMS {@jvms 4.7.28}). Alternatively, a {@code class} file of</span>
4155      * version 55.0 or greater may act as a nest host by enumerating the nest&#39;s
4156      * other members with the
<span class="line-modified">4157      * {@code NestMembers} attribute (JVMS {@jvms 4.7.29}).</span>
4158      * A {@code class} file of version 54.0 or lower does not use these
4159      * attributes.
4160      *
4161      * @return the nest host of this class or interface
4162      *
4163      * @throws SecurityException
4164      *         If the returned class is not the current class, and
4165      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4166      *         class loader is not the same as or an ancestor of the class
4167      *         loader for the returned class and invocation of {@link
4168      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4169      *         denies access to the package of the returned class
4170      * @since 11
4171      * @jvms 4.7.28 The {@code NestHost} Attribute
4172      * @jvms 4.7.29 The {@code NestMembers} Attribute
4173      * @jvms 5.4.4 Access Control
4174      */
4175     @CallerSensitive
4176     public Class&lt;?&gt; getNestHost() {
4177         if (isPrimitive() || isArray()) {
</pre>
</td>
</tr>
</table>
<center><a href="Character.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ClassLoader.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
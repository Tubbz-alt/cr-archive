<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.lang.constant.ClassDesc;
  30 import java.lang.invoke.TypeDescriptor;
  31 import java.lang.module.ModuleReader;
  32 import java.lang.ref.SoftReference;
  33 import java.io.IOException;
  34 import java.io.InputStream;
  35 import java.io.ObjectStreamField;
  36 import java.lang.reflect.AnnotatedElement;
  37 import java.lang.reflect.AnnotatedType;
  38 import java.lang.reflect.Array;
  39 import java.lang.reflect.Constructor;
  40 import java.lang.reflect.Executable;
  41 import java.lang.reflect.Field;
  42 import java.lang.reflect.GenericArrayType;
  43 import java.lang.reflect.GenericDeclaration;
  44 import java.lang.reflect.InvocationTargetException;
  45 import java.lang.reflect.Member;
  46 import java.lang.reflect.Method;
  47 import java.lang.reflect.Modifier;
  48 import java.lang.reflect.Proxy;
  49 import java.lang.reflect.RecordComponent;
  50 import java.lang.reflect.Type;
  51 import java.lang.reflect.TypeVariable;
  52 import java.lang.constant.Constable;
  53 import java.net.URL;
  54 import java.security.AccessController;
  55 import java.security.PrivilegedAction;
  56 import java.util.ArrayList;
  57 import java.util.Arrays;
  58 import java.util.Collection;
  59 import java.util.HashMap;
  60 import java.util.LinkedHashMap;
  61 import java.util.LinkedHashSet;
  62 import java.util.List;
  63 import java.util.Map;
  64 import java.util.Objects;
  65 import java.util.Optional;
  66 import java.util.stream.Collectors;
  67 
  68 import jdk.internal.HotSpotIntrinsicCandidate;
  69 import jdk.internal.loader.BootLoader;
  70 import jdk.internal.loader.BuiltinClassLoader;
  71 import jdk.internal.misc.Unsafe;
  72 import jdk.internal.module.Resources;
  73 import jdk.internal.reflect.CallerSensitive;
  74 import jdk.internal.reflect.ConstantPool;
  75 import jdk.internal.reflect.Reflection;
  76 import jdk.internal.reflect.ReflectionFactory;
  77 import jdk.internal.vm.annotation.ForceInline;
  78 import sun.invoke.util.Wrapper;
  79 import sun.reflect.generics.factory.CoreReflectionFactory;
  80 import sun.reflect.generics.factory.GenericsFactory;
  81 import sun.reflect.generics.repository.ClassRepository;
  82 import sun.reflect.generics.repository.MethodRepository;
  83 import sun.reflect.generics.repository.ConstructorRepository;
  84 import sun.reflect.generics.scope.ClassScope;
  85 import sun.security.util.SecurityConstants;
  86 import sun.reflect.annotation.*;
  87 import sun.reflect.misc.ReflectUtil;
  88 
  89 /**
  90  * Instances of the class {@code Class} represent classes and
  91  * interfaces in a running Java application. An enum type and a record
  92  * type are kinds of class; an annotation type is a kind of
  93  * interface. Every array also belongs to a class that is reflected as
  94  * a {@code Class} object that is shared by all arrays with the same
  95  * element type and number of dimensions.  The primitive Java types
  96  * ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code
  97  * int}, {@code long}, {@code float}, and {@code double}), and the
  98  * keyword {@code void} are also represented as {@code Class} objects.
  99  *
 100  * &lt;p&gt; {@code Class} has no public constructor. Instead a {@code Class}
 101  * object is constructed automatically by the Java Virtual Machine
 102  * when a class loader invokes one of the
 103  * {@link ClassLoader#defineClass(String,byte[], int,int) defineClass} methods
 104  * and passes the bytes of a {@code class} file.
 105  *
 106  * &lt;p&gt; The methods of class {@code Class} expose many characteristics of a
 107  * class or interface. Most characteristics are derived from the {@code class}
 108  * file that the class loader passed to the Java Virtual Machine. A few
 109  * characteristics are determined by the class loading environment at run time,
 110  * such as the module returned by {@link #getModule() getModule()}.
 111  *
 112  * &lt;p&gt; Some methods of class {@code Class} expose whether the declaration of
 113  * a class or interface in Java source code was &lt;em&gt;enclosed&lt;/em&gt; within
 114  * another declaration. Other methods describe how a class or interface
 115  * is situated in a &lt;em&gt;nest&lt;/em&gt;. A &lt;a id=&quot;nest&quot;&gt;nest&lt;/a&gt; is a set of
 116  * classes and interfaces, in the same run-time package, that
 117  * allow mutual access to their {@code private} members.
 118  * The classes and interfaces are known as &lt;em&gt;nestmates&lt;/em&gt;.
 119  * One nestmate acts as the
 120  * &lt;em&gt;nest host&lt;/em&gt;, and enumerates the other nestmates which
 121  * belong to the nest; each of them in turn records it as the nest host.
 122  * The classes and interfaces which belong to a nest, including its host, are
 123  * determined when
 124  * {@code class} files are generated, for example, a Java compiler
 125  * will typically record a top-level class as the host of a nest where the
 126  * other members are the classes and interfaces whose declarations are
 127  * enclosed within the top-level class declaration.
 128  *
 129  * &lt;p&gt; The following example uses a {@code Class} object to print the
 130  * class name of an object:
 131  *
 132  * &lt;blockquote&gt;&lt;pre&gt;
 133  *     void printClassName(Object obj) {
 134  *         System.out.println(&quot;The class of &quot; + obj +
 135  *                            &quot; is &quot; + obj.getClass().getName());
 136  *     }
 137  * &lt;/pre&gt;&lt;/blockquote&gt;
 138  *
 139  * &lt;p&gt; It is also possible to get the {@code Class} object for a named
<a name="1" id="anc1"></a><span class="line-modified"> 140  * type (or for void) using a class literal.  See Section 15.8.2 of</span>
<span class="line-modified"> 141  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
 142  * For example:
 143  *
 144  * &lt;blockquote&gt;
 145  *     {@code System.out.println(&quot;The name of class Foo is: &quot;+Foo.class.getName());}
 146  * &lt;/blockquote&gt;
 147  *
 148  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 149  * object.  For example, the type of {@code String.class} is {@code
 150  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 151  * unknown.
 152  *
 153  * @author  unascribed
 154  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 155  * @since   1.0
 156  */
 157 public final class Class&lt;T&gt; implements java.io.Serializable,
 158                               GenericDeclaration,
 159                               Type,
 160                               AnnotatedElement,
 161                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 162                               Constable {
 163     private static final int ANNOTATION = 0x00002000;
 164     private static final int ENUM       = 0x00004000;
 165     private static final int SYNTHETIC  = 0x00001000;
 166     private static final int VALUE_TYPE = 0x00000100;
 167 
 168     private static native void registerNatives();
 169     static {
 170         registerNatives();
 171     }
 172 
 173     /*
 174      * Private constructor. Only the Java Virtual Machine creates Class objects.
 175      * This constructor is not used and prevents the default constructor being
 176      * generated.
 177      */
 178     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 179         // Initialize final field for classLoader.  The initialization value of non-null
 180         // prevents future JIT optimizations from assuming this final field is null.
 181         classLoader = loader;
 182         componentType = arrayComponentType;
 183     }
 184 
 185     /**
 186      * Converts the object to a string. The string representation is the
 187      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 188      * fully qualified name of the class in the format returned by
 189      * {@code getName}.  If this {@code Class} object represents a
 190      * primitive type, this method returns the name of the primitive type.  If
 191      * this {@code Class} object represents void this method returns
 192      * &quot;void&quot;. If this {@code Class} object represents an array type,
 193      * this method returns &quot;class &quot; followed by {@code getName}.
 194      *
 195      * @return a string representation of this class object.
 196      */
 197     public String toString() {
 198         return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)
 199                + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
 200                + getName() + (isInlineClass() &amp;&amp; isIndirectType() ? &quot;?&quot; : &quot;&quot;);
 201     }
 202 
 203     /**
 204      * Returns a string describing this {@code Class}, including
 205      * information about modifiers and type parameters.
 206      *
 207      * The string is formatted as a list of type modifiers, if any,
 208      * followed by the kind of type (empty string for primitive types
 209      * and {@code class}, {@code enum}, {@code interface},
 210      * &lt;code&gt;&amp;#64;&lt;/code&gt;{@code interface}, or {@code record} as appropriate), followed
 211      * by the type&#39;s name, followed by an angle-bracketed
 212      * comma-separated list of the type&#39;s type parameters, if any,
 213      * including informative bounds on the type parameters, if any.
 214      *
 215      * A space is used to separate modifiers from one another and to
 216      * separate any modifiers from the kind of type. The modifiers
 217      * occur in canonical order. If there are no type parameters, the
 218      * type parameter list is elided.
 219      *
 220      * For an array type, the string starts with the type name,
 221      * followed by an angle-bracketed comma-separated list of the
 222      * type&#39;s type parameters, if any, followed by a sequence of
 223      * {@code []} characters, one set of brackets per dimension of
 224      * the array.
 225      *
 226      * &lt;p&gt;Note that since information about the runtime representation
 227      * of a type is being generated, modifiers not present on the
 228      * originating source code or illegal on the originating source
 229      * code may be present.
 230      *
 231      * @return a string describing this {@code Class}, including
 232      * information about modifiers and type parameters
 233      *
 234      * @since 1.8
 235      */
 236     @SuppressWarnings(&quot;preview&quot;)
 237     public String toGenericString() {
 238         if (isPrimitive()) {
 239             return toString();
 240         } else {
 241             StringBuilder sb = new StringBuilder();
 242             Class&lt;?&gt; component = this;
 243             int arrayDepth = 0;
 244 
 245             if (isArray()) {
 246                 do {
 247                     arrayDepth++;
 248                     component = component.getComponentType();
 249                 } while (component.isArray());
 250                 sb.append(component.getName());
 251             } else {
 252                 // Class modifiers are a superset of interface modifiers
 253                 int modifiers = getModifiers() &amp; Modifier.classModifiers();
 254                 if (modifiers != 0) {
 255                     sb.append(Modifier.toString(modifiers));
 256                     sb.append(&#39; &#39;);
 257                 }
 258 
 259                 if (isAnnotation()) {
 260                     sb.append(&#39;@&#39;);
 261                 }
 262                 if (isInlineClass()) {
 263                     sb.append(&quot;inline&quot;);
 264                     sb.append(&#39; &#39;);
 265                 }
 266                 if (isInterface()) { // Note: all annotation types are interfaces
 267                     sb.append(&quot;interface&quot;);
 268                 } else {
 269                     if (isEnum())
 270                         sb.append(&quot;enum&quot;);
 271                     else if (isRecord())
 272                         sb.append(&quot;record&quot;);
 273                     else
 274                         sb.append(&quot;class&quot;);
 275                 }
 276                 sb.append(&#39; &#39;);
 277                 sb.append(getName());
 278             }
 279 
 280             TypeVariable&lt;?&gt;[] typeparms = component.getTypeParameters();
 281             if (typeparms.length &gt; 0) {
 282                 sb.append(Arrays.stream(typeparms)
 283                           .map(Class::typeVarBounds)
 284                           .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
 285             }
 286 
 287             if (arrayDepth &gt; 0) sb.append(&quot;[]&quot;.repeat(arrayDepth));
 288 
 289             return sb.toString();
 290         }
 291     }
 292 
 293     static String typeVarBounds(TypeVariable&lt;?&gt; typeVar) {
 294         Type[] bounds = typeVar.getBounds();
 295         if (bounds.length == 1 &amp;&amp; bounds[0].equals(Object.class)) {
 296             return typeVar.getName();
 297         } else {
 298             return typeVar.getName() + &quot; extends &quot; +
 299                 Arrays.stream(bounds)
 300                 .map(Type::getTypeName)
 301                 .collect(Collectors.joining(&quot; &amp; &quot;));
 302         }
 303     }
 304 
 305     /**
 306      * Returns the {@code Class} object associated with the class or
 307      * interface with the given string name.  Invoking this method is
 308      * equivalent to:
 309      *
 310      * &lt;blockquote&gt;
 311      *  {@code Class.forName(className, true, currentLoader)}
 312      * &lt;/blockquote&gt;
 313      *
 314      * where {@code currentLoader} denotes the defining class loader of
 315      * the current class.
 316      *
 317      * &lt;p&gt; For example, the following code fragment returns the
 318      * runtime {@code Class} descriptor for the class named
 319      * {@code java.lang.Thread}:
 320      *
 321      * &lt;blockquote&gt;
 322      *   {@code Class t = Class.forName(&quot;java.lang.Thread&quot;)}
 323      * &lt;/blockquote&gt;
 324      * &lt;p&gt;
 325      * A call to {@code forName(&quot;X&quot;)} causes the class named
 326      * {@code X} to be initialized.
 327      *
 328      * @param      className   the fully qualified name of the desired class.
 329      * @return     the {@code Class} object for the class with the
 330      *             specified name.
 331      * @throws    LinkageError if the linkage fails
 332      * @throws    ExceptionInInitializerError if the initialization provoked
 333      *            by this method fails
 334      * @throws    ClassNotFoundException if the class cannot be located
 335      *
 336      * @jls 12.2 Loading of Classes and Interfaces
 337      * @jls 12.3 Linking of Classes and Interfaces
 338      * @jls 12.4 Initialization of Classes and Interfaces
 339      */
 340     @CallerSensitive
 341     public static Class&lt;?&gt; forName(String className)
 342                 throws ClassNotFoundException {
 343         Class&lt;?&gt; caller = Reflection.getCallerClass();
 344         return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
 345     }
 346 
 347 
 348     /**
 349      * Returns the {@code Class} object associated with the class or
 350      * interface with the given string name, using the given class loader.
 351      * Given the fully qualified name for a class or interface (in the same
 352      * format returned by {@code getName}) this method attempts to
 353      * locate and load the class or interface.  The specified class
 354      * loader is used to load the class or interface.  If the parameter
 355      * {@code loader} is null, the class is loaded through the bootstrap
 356      * class loader.  The class is initialized only if the
 357      * {@code initialize} parameter is {@code true} and if it has
 358      * not been initialized earlier.
 359      *
 360      * &lt;p&gt; If {@code name} denotes a primitive type or void, an attempt
 361      * will be made to locate a user-defined class in the unnamed package whose
 362      * name is {@code name}. Therefore, this method cannot be used to
 363      * obtain any of the {@code Class} objects representing primitive
 364      * types or void.
 365      *
 366      * &lt;p&gt; If {@code name} denotes an array class, the component type of
 367      * the array class is loaded but not initialized.
 368      *
 369      * &lt;p&gt; For example, in an instance method the expression:
 370      *
 371      * &lt;blockquote&gt;
 372      *  {@code Class.forName(&quot;Foo&quot;)}
 373      * &lt;/blockquote&gt;
 374      *
 375      * is equivalent to:
 376      *
 377      * &lt;blockquote&gt;
 378      *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
 379      * &lt;/blockquote&gt;
 380      *
 381      * Note that this method throws errors related to loading, linking
 382      * or initializing as specified in Sections {@jls 12.2}, {@jls
<a name="2" id="anc2"></a><span class="line-modified"> 383      * 12.3}, and {@jls 12.4} of &lt;em&gt;The Java Language</span>
<span class="line-modified"> 384      * Specification&lt;/em&gt;.</span>
 385      * Note that this method does not check whether the requested class
 386      * is accessible to its caller.
 387      *
 388      * @param name       fully qualified name of the desired class
<a name="3" id="anc3"></a><span class="line-modified"> 389      * @param initialize if {@code true} the class will be initialized (which implies linking).</span>
<span class="line-modified"> 390      *                   See Section {@jls 12.4} of &lt;em&gt;The Java Language Specification&lt;/em&gt;.</span>



 391      * @param loader     class loader from which the class must be loaded
 392      * @return           class object representing the desired class
 393      *
 394      * @throws    LinkageError if the linkage fails
 395      * @throws    ExceptionInInitializerError if the initialization provoked
 396      *            by this method fails
 397      * @throws    ClassNotFoundException if the class cannot be located by
 398      *            the specified class loader
 399      * @throws    SecurityException
 400      *            if a security manager is present, and the {@code loader} is
 401      *            {@code null}, and the caller&#39;s class loader is not
 402      *            {@code null}, and the caller does not have the
 403      *            {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 404      *
 405      * @see       java.lang.Class#forName(String)
 406      * @see       java.lang.ClassLoader
 407      *
 408      * @jls 12.2 Loading of Classes and Interfaces
 409      * @jls 12.3 Linking of Classes and Interfaces
 410      * @jls 12.4 Initialization of Classes and Interfaces
 411      * @since     1.2
 412      */
 413     @CallerSensitive
 414     public static Class&lt;?&gt; forName(String name, boolean initialize,
 415                                    ClassLoader loader)
 416         throws ClassNotFoundException
 417     {
 418         Class&lt;?&gt; caller = null;
 419         SecurityManager sm = System.getSecurityManager();
 420         if (sm != null) {
 421             // Reflective call to get caller class is only needed if a security manager
 422             // is present.  Avoid the overhead of making this call otherwise.
 423             caller = Reflection.getCallerClass();
 424             if (loader == null) {
 425                 ClassLoader ccl = ClassLoader.getClassLoader(caller);
 426                 if (ccl != null) {
 427                     sm.checkPermission(
 428                         SecurityConstants.GET_CLASSLOADER_PERMISSION);
 429                 }
 430             }
 431         }
 432         return forName0(name, initialize, loader, caller);
 433     }
 434 
 435     /** Called after security check for system loader access checks have been made. */
 436     private static native Class&lt;?&gt; forName0(String name, boolean initialize,
 437                                     ClassLoader loader,
 438                                     Class&lt;?&gt; caller)
 439         throws ClassNotFoundException;
 440 
 441 
 442     /**
 443      * Returns the {@code Class} with the given &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;
 444      * binary name&lt;/a&gt; in the given module.
 445      *
 446      * &lt;p&gt; This method attempts to locate and load the class or interface.
 447      * It does not link the class, and does not run the class initializer.
 448      * If the class is not found, this method returns {@code null}. &lt;/p&gt;
 449      *
 450      * &lt;p&gt; If the class loader of the given module defines other modules and
 451      * the given name is a class defined in a different module, this method
 452      * returns {@code null} after the class is loaded. &lt;/p&gt;
 453      *
 454      * &lt;p&gt; This method does not check whether the requested class is
 455      * accessible to its caller. &lt;/p&gt;
 456      *
 457      * @apiNote
 458      * This method returns {@code null} on failure rather than
 459      * throwing a {@link ClassNotFoundException}, as is done by
 460      * the {@link #forName(String, boolean, ClassLoader)} method.
 461      * The security check is a stack-based permission check if the caller
 462      * loads a class in another module.
 463      *
 464      * @param  module   A module
 465      * @param  name     The &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
 466      *                  of the class
 467      * @return {@code Class} object of the given name defined in the given module;
 468      *         {@code null} if not found.
 469      *
 470      * @throws NullPointerException if the given module or name is {@code null}
 471      *
 472      * @throws LinkageError if the linkage fails
 473      *
 474      * @throws SecurityException
 475      *         &lt;ul&gt;
 476      *         &lt;li&gt; if the caller is not the specified module and
 477      *         {@code RuntimePermission(&quot;getClassLoader&quot;)} permission is denied; or&lt;/li&gt;
 478      *         &lt;li&gt; access to the module content is denied. For example,
 479      *         permission check will be performed when a class loader calls
 480      *         {@link ModuleReader#open(String)} to read the bytes of a class file
 481      *         in a module.&lt;/li&gt;
 482      *         &lt;/ul&gt;
 483      *
 484      * @jls 12.2 Loading of Classes and Interfaces
 485      * @jls 12.3 Linking of Classes and Interfaces
 486      * @since 9
 487      * @spec JPMS
 488      */
 489     @CallerSensitive
 490     public static Class&lt;?&gt; forName(Module module, String name) {
 491         Objects.requireNonNull(module);
 492         Objects.requireNonNull(name);
 493 
 494         ClassLoader cl;
 495         SecurityManager sm = System.getSecurityManager();
 496         if (sm != null) {
 497             Class&lt;?&gt; caller = Reflection.getCallerClass();
 498             if (caller != null &amp;&amp; caller.getModule() != module) {
 499                 // if caller is null, Class.forName is the last java frame on the stack.
 500                 // java.base has all permissions
 501                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 502             }
 503             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 504             cl = AccessController.doPrivileged(pa);
 505         } else {
 506             cl = module.getClassLoader();
 507         }
 508 
 509         if (cl != null) {
 510             return cl.loadClass(module, name);
 511         } else {
 512             return BootLoader.loadClass(module, name);
 513         }
 514     }
 515 
 516     /**
 517      * Returns {@code true} if this class is an inline class.
 518      *
 519      * @return {@code true} if this class is an inline class.
 520      */
 521     public boolean isInlineClass() {
 522         return (this.getModifiers() &amp; VALUE_TYPE) != 0;
 523     }
 524 
 525     /**
 526      * Returns a {@code Class} object representing the primary type of
 527      * this class.
 528      *
 529      * &lt;p&gt; For class {@code C}, {@code C.class} is the primary type of {@code C}.
 530      * For a primitive type, the {@code Class} instance representing
 531      * that primitive type is its primary type, for example {@code int.class}.
 532      *
 533      * @return the {@code Class} object representing the primary type of
 534      *         this class
 535      */
 536     @HotSpotIntrinsicCandidate
 537     public Class&lt;T&gt; asPrimaryType() {
 538         return isInlineClass() ? inlineType : this;
 539     }
 540 
 541     /**
 542      * Returns a {@code Class} object representing the &lt;em&gt;indirect projection&lt;/em&gt;
 543      * type if this class is an {@linkplain #isInlineClass() inline class};
 544      * otherwise, returns this class.
 545      *
 546      * &lt;p&gt; An inline class, {@code V}, has two {@code Class} representations,
 547      * {@code V.class} and its {@linkplain #asIndirectType() indirect projection
 548      * type}.  The indirect projection type is always
 549      * {@linkplain #isNullableType() nullable}.
 550      * The indirect projection type of a zero-default inline class
 551      * is also its nullable projection type.
 552      *
 553      * @return the {@code Class} object representing the indirect projection type of
 554      *         this class if this class is an inline class; otherwise, this class.
 555      */
 556     @HotSpotIntrinsicCandidate
 557     public Class&lt;T&gt; asIndirectType() {
 558         return isInlineClass() ? indirectType : this;
 559     }
 560 
 561     /**
 562      * Returns a {@code Class} object representing the &lt;em&gt;nullable projection&lt;/em&gt;
 563      * type if this class is an {@linkplain #isInlineClass() inline class};
 564      * otherwise, returns this class.
 565      *
 566      * &lt;p&gt; An inline class, {@code V}, has two {@code Class} representations,
 567      * {@code V.class} and its {@linkplain #asIndirectType() indirect projection
 568      * type}.  The indirect projection type is always
 569      * {@linkplain #isNullableType() nullable}.
 570      * The indirect projection type of a zero-default inline class
 571      * is also its nullable projection type.
 572      *
 573      * @return the {@code Class} object representing the nullable projection type of
 574      *         this class if this class is an inline class; otherwise, this class.
 575      */
 576     public Class&lt;T&gt; asNullableType() {
 577         return asIndirectType();
 578     }
 579 
 580     /**
 581      * Returns {@code true} if this class is an indirect type.
 582      * An indirect type is always {@linkplain #isNullableType() nullable}.
 583      *
 584      * @return {@code true} if this class is an indirect type.
 585      */
 586     public boolean isIndirectType() {
 587         return indirectType == null || this == indirectType;
 588     }
 589 
 590     /**
 591      * Returns {@code true} if this class is a nullable type.
 592      *
 593      * @return {@code true} if this class is a nullable type.
 594      */
 595     public boolean isNullableType() {
 596         return isIndirectType();
 597     }
 598 
 599     // set by VM if this class is an inline type
 600     // otherwise, these two fields are null
 601     private transient Class&lt;T&gt; inlineType;
 602     private transient Class&lt;T&gt; indirectType;
 603 
 604     /**
 605      * Creates a new instance of the class represented by this {@code Class}
 606      * object.  The class is instantiated as if by a {@code new}
 607      * expression with an empty argument list.  The class is initialized if it
 608      * has not already been initialized.
 609      *
 610      * @deprecated This method propagates any exception thrown by the
 611      * nullary constructor, including a checked exception.  Use of
 612      * this method effectively bypasses the compile-time exception
 613      * checking that would otherwise be performed by the compiler.
 614      * The {@link
 615      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 616      * Constructor.newInstance} method avoids this problem by wrapping
 617      * any exception thrown by the constructor in a (checked) {@link
 618      * java.lang.reflect.InvocationTargetException}.
 619      *
 620      * &lt;p&gt;The call
 621      *
 622      * &lt;pre&gt;{@code
 623      * clazz.newInstance()
 624      * }&lt;/pre&gt;
 625      *
 626      * can be replaced by
 627      *
 628      * &lt;pre&gt;{@code
 629      * clazz.getDeclaredConstructor().newInstance()
 630      * }&lt;/pre&gt;
 631      *
 632      * The latter sequence of calls is inferred to be able to throw
 633      * the additional exception types {@link
 634      * InvocationTargetException} and {@link
 635      * NoSuchMethodException}. Both of these exception types are
 636      * subclasses of {@link ReflectiveOperationException}.
 637      *
 638      * @return  a newly allocated instance of the class represented by this
 639      *          object.
 640      * @throws  IllegalAccessException  if the class or its nullary
 641      *          constructor is not accessible.
 642      * @throws  InstantiationException
 643      *          if this {@code Class} represents an abstract class,
 644      *          an interface, an array class, a primitive type, or void;
 645      *          or if the class has no nullary constructor;
 646      *          or if the instantiation fails for some other reason.
 647      * @throws  ExceptionInInitializerError if the initialization
 648      *          provoked by this method fails.
 649      * @throws  SecurityException
 650      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
 651      *          the caller&#39;s class loader is not the same as or an
 652      *          ancestor of the class loader for the current class and
 653      *          invocation of {@link SecurityManager#checkPackageAccess
 654      *          s.checkPackageAccess()} denies access to the package
 655      *          of this class.
 656      */
 657     @CallerSensitive
 658     @Deprecated(since=&quot;9&quot;)
 659     public T newInstance()
 660         throws InstantiationException, IllegalAccessException
 661     {
 662         SecurityManager sm = System.getSecurityManager();
 663         if (sm != null) {
 664             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);
 665         }
 666 
 667         // Constructor lookup
 668         Constructor&lt;T&gt; tmpConstructor = cachedConstructor;
 669         if (tmpConstructor == null) {
 670             if (this == Class.class) {
 671                 throw new IllegalAccessException(
 672                     &quot;Can not call newInstance() on the Class for java.lang.Class&quot;
 673                 );
 674             }
 675             try {
 676                 Class&lt;?&gt;[] empty = {};
 677                 final Constructor&lt;T&gt; c = getReflectionFactory().copyConstructor(
 678                     getConstructor0(empty, Member.DECLARED));
 679                 // Disable accessibility checks on the constructor
 680                 // access check is done with the true caller
 681                 java.security.AccessController.doPrivileged(
 682                     new java.security.PrivilegedAction&lt;&gt;() {
 683                         public Void run() {
 684                                 c.setAccessible(true);
 685                                 return null;
 686                             }
 687                         });
 688                 cachedConstructor = tmpConstructor = c;
 689             } catch (NoSuchMethodException e) {
 690                 throw (InstantiationException)
 691                     new InstantiationException(getName()).initCause(e);
 692             }
 693         }
 694 
 695         try {
 696             Class&lt;?&gt; caller = Reflection.getCallerClass();
 697             return getReflectionFactory().newInstance(tmpConstructor, null, caller);
 698         } catch (InvocationTargetException e) {
 699             Unsafe.getUnsafe().throwException(e.getTargetException());
 700             // Not reached
 701             return null;
 702         }
 703     }
 704 
 705     private transient volatile Constructor&lt;T&gt; cachedConstructor;
 706 
 707     /**
 708      * Determines if the specified {@code Object} is assignment-compatible
 709      * with the object represented by this {@code Class}.  This method is
 710      * the dynamic equivalent of the Java language {@code instanceof}
 711      * operator. The method returns {@code true} if the specified
 712      * {@code Object} argument is non-null and can be cast to the
 713      * reference type represented by this {@code Class} object without
 714      * raising a {@code ClassCastException.} It returns {@code false}
 715      * otherwise.
 716      *
 717      * &lt;p&gt; Specifically, if this {@code Class} object represents a
 718      * declared class, this method returns {@code true} if the specified
 719      * {@code Object} argument is an instance of the represented class (or
 720      * of any of its subclasses); it returns {@code false} otherwise. If
 721      * this {@code Class} object represents an array class, this method
 722      * returns {@code true} if the specified {@code Object} argument
 723      * can be converted to an object of the array class by an identity
 724      * conversion or by a widening reference conversion; it returns
 725      * {@code false} otherwise. If this {@code Class} object
 726      * represents an interface, this method returns {@code true} if the
 727      * class or any superclass of the specified {@code Object} argument
 728      * implements this interface; it returns {@code false} otherwise. If
 729      * this {@code Class} object represents a primitive type, this method
 730      * returns {@code false}.
 731      *
 732      * @param   obj the object to check
 733      * @return  true if {@code obj} is an instance of this class
 734      *
 735      * @since 1.1
 736      */
 737     @HotSpotIntrinsicCandidate
 738     public native boolean isInstance(Object obj);
 739 
 740 
 741     /**
 742      * Determines if the class or interface represented by this
 743      * {@code Class} object is either the same as, or is a superclass or
 744      * superinterface of, the class or interface represented by the specified
 745      * {@code Class} parameter. It returns {@code true} if so;
 746      * otherwise it returns {@code false}. If this {@code Class}
 747      * object represents a primitive type, this method returns
 748      * {@code true} if the specified {@code Class} parameter is
 749      * exactly this {@code Class} object; otherwise it returns
 750      * {@code false}.
 751      *
 752      * &lt;p&gt; Specifically, this method tests whether the type represented by the
 753      * specified {@code Class} parameter can be converted to the type
 754      * represented by this {@code Class} object via an identity conversion
<a name="4" id="anc4"></a><span class="line-modified"> 755      * or via a widening reference conversion. See &lt;em&gt;The Java Language</span>
<span class="line-modified"> 756      * Specification&lt;/em&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},</span>
 757      * for details.
 758      *
 759      * @param     cls the {@code Class} object to be checked
 760      * @return    the {@code boolean} value indicating whether objects of the
 761      *            type {@code cls} can be assigned to objects of this class
 762      * @throws    NullPointerException if the specified Class parameter is
 763      *            null.
 764      * @since     1.1
 765      */
 766     @HotSpotIntrinsicCandidate
 767     public native boolean isAssignableFrom(Class&lt;?&gt; cls);
 768 
 769 
 770     /**
 771      * Determines if the specified {@code Class} object represents an
 772      * interface type.
 773      *
 774      * @return  {@code true} if this object represents an interface;
 775      *          {@code false} otherwise.
 776      */
 777     @HotSpotIntrinsicCandidate
 778     public native boolean isInterface();
 779 
 780 
 781     /**
 782      * Determines if this {@code Class} object represents an array class.
 783      *
 784      * @return  {@code true} if this object represents an array class;
 785      *          {@code false} otherwise.
 786      * @since   1.1
 787      */
 788     @HotSpotIntrinsicCandidate
 789     public native boolean isArray();
 790 
 791 
 792     /**
 793      * Determines if the specified {@code Class} object represents a
 794      * primitive type.
 795      *
 796      * &lt;p&gt; There are nine predefined {@code Class} objects to represent
 797      * the eight primitive types and void.  These are created by the Java
 798      * Virtual Machine, and have the same names as the primitive types that
 799      * they represent, namely {@code boolean}, {@code byte},
 800      * {@code char}, {@code short}, {@code int},
 801      * {@code long}, {@code float}, and {@code double}.
 802      *
 803      * &lt;p&gt; These objects may only be accessed via the following public static
 804      * final variables, and are the only {@code Class} objects for which
 805      * this method returns {@code true}.
 806      *
 807      * @return true if and only if this class represents a primitive type
 808      *
 809      * @see     java.lang.Boolean#TYPE
 810      * @see     java.lang.Character#TYPE
 811      * @see     java.lang.Byte#TYPE
 812      * @see     java.lang.Short#TYPE
 813      * @see     java.lang.Integer#TYPE
 814      * @see     java.lang.Long#TYPE
 815      * @see     java.lang.Float#TYPE
 816      * @see     java.lang.Double#TYPE
 817      * @see     java.lang.Void#TYPE
 818      * @since 1.1
 819      */
 820     @HotSpotIntrinsicCandidate
 821     public native boolean isPrimitive();
 822 
 823     /**
 824      * Returns true if this {@code Class} object represents an annotation
 825      * type.  Note that if this method returns true, {@link #isInterface()}
 826      * would also return true, as all annotation types are also interfaces.
 827      *
 828      * @return {@code true} if this class object represents an annotation
 829      *      type; {@code false} otherwise
 830      * @since 1.5
 831      */
 832     public boolean isAnnotation() {
 833         return (getModifiers() &amp; ANNOTATION) != 0;
 834     }
 835 
 836     /**
 837      * Returns {@code true} if this class is a synthetic class;
 838      * returns {@code false} otherwise.
 839      * @return {@code true} if and only if this class is a synthetic class as
<a name="5" id="anc5"></a><span class="line-modified"> 840      *         defined by the Java Language Specification.</span>
 841      * @jls 13.1 The Form of a Binary
 842      * @since 1.5
 843      */
 844     public boolean isSynthetic() {
 845         return (getModifiers() &amp; SYNTHETIC) != 0;
 846     }
 847 
 848     /**
 849      * Returns the  name of the entity (class, interface, array class,
 850      * primitive type, or void) represented by this {@code Class} object,
 851      * as a {@code String}.
 852      *
<a name="6" id="anc6"></a><span class="line-modified"> 853      * &lt;p&gt; If this class object represents a reference type that is not an</span>
<span class="line-modified"> 854      * array type then the binary name of the class is returned, as specified</span>
<span class="line-modified"> 855      * by</span>
<span class="line-modified"> 856      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
 857      *
 858      * &lt;p&gt; If this class object represents a primitive type or void, then the
 859      * name returned is a {@code String} equal to the Java language
 860      * keyword corresponding to the primitive type or void.
 861      *
 862      * &lt;p&gt; If this class object represents a class of arrays, then the internal
 863      * form of the name consists of the name of the element type preceded by
 864      * one or more &#39;{@code [}&#39; characters representing the depth of the array
 865      * nesting.  The encoding of element type names is as follows:
 866      *
 867      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 868      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 869      * &lt;thead&gt;
 870      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 871      * &lt;/thead&gt;
 872      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 873      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; boolean      &lt;td style=&quot;text-align:center&quot;&gt; Z
 874      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; byte         &lt;td style=&quot;text-align:center&quot;&gt; B
 875      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; char         &lt;td style=&quot;text-align:center&quot;&gt; C
 876      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface
 877      *                                   &lt;td style=&quot;text-align:center&quot;&gt; L&lt;i&gt;classname&lt;/i&gt;;
 878      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; non-nullable {@linkplain #isInlineClass() inline class}
 879      *                                   &lt;td style=&quot;text-align:center&quot;&gt; Q&lt;i&gt;classname&lt;/i&gt;;
 880      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; double       &lt;td style=&quot;text-align:center&quot;&gt; D
 881      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; float        &lt;td style=&quot;text-align:center&quot;&gt; F
 882      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; int          &lt;td style=&quot;text-align:center&quot;&gt; I
 883      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; long         &lt;td style=&quot;text-align:center&quot;&gt; J
 884      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; short        &lt;td style=&quot;text-align:center&quot;&gt; S
 885      * &lt;/tbody&gt;
 886      * &lt;/table&gt;&lt;/blockquote&gt;
 887      *
 888      * &lt;p&gt; The class or interface name &lt;i&gt;classname&lt;/i&gt; is the binary name of
 889      * the class specified above.
 890      *
 891      * &lt;p&gt; Examples:
 892      * &lt;blockquote&gt;&lt;pre&gt;
 893      * String.class.getName()
 894      *     returns &quot;java.lang.String&quot;
 895      * byte.class.getName()
 896      *     returns &quot;byte&quot;
 897      * Point.class.getName()
 898      *     returns &quot;Point&quot;
 899      * (new Object[3]).getClass().getName()
 900      *     returns &quot;[Ljava.lang.Object;&quot;
 901      * (new Point[3]).getClass().getName()
 902      *     returns &quot;[QPoint;&quot;
 903      * (new Point?[3][4]).getClass().getName()
 904      *     returns &quot;[[LPoint;&quot;
 905      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 906      *     returns &quot;[[[[[[[I&quot;
 907      * &lt;/pre&gt;&lt;/blockquote&gt;
 908      *
 909      * @return  the name of the class or interface
 910      *          represented by this object.
 911      */
 912     public String getName() {
 913         String name = this.name;
 914         return name != null ? name : initClassName();
 915     }
 916 
 917     // Cache the name to reduce the number of calls into the VM.
 918     // This field would be set by VM itself during initClassName call.
 919     private transient String name;
 920     private native String initClassName();
 921 
 922     /**
 923      * Returns the class loader for the class.  Some implementations may use
 924      * null to represent the bootstrap class loader. This method will return
 925      * null in such implementations if this class was loaded by the bootstrap
 926      * class loader.
 927      *
 928      * &lt;p&gt;If this object
 929      * represents a primitive type or void, null is returned.
 930      *
 931      * @return  the class loader that loaded the class or interface
 932      *          represented by this object.
 933      * @throws  SecurityException
 934      *          if a security manager is present, and the caller&#39;s class loader
 935      *          is not {@code null} and is not the same as or an ancestor of the
 936      *          class loader for the class whose class loader is requested,
 937      *          and the caller does not have the
 938      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 939      * @see java.lang.ClassLoader
 940      * @see SecurityManager#checkPermission
 941      * @see java.lang.RuntimePermission
 942      */
 943     @CallerSensitive
 944     @ForceInline // to ensure Reflection.getCallerClass optimization
 945     public ClassLoader getClassLoader() {
 946         ClassLoader cl = getClassLoader0();
 947         if (cl == null)
 948             return null;
 949         SecurityManager sm = System.getSecurityManager();
 950         if (sm != null) {
 951             ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
 952         }
 953         return cl;
 954     }
 955 
 956     // Package-private to allow ClassLoader access
 957     ClassLoader getClassLoader0() { return classLoader; }
 958 
 959     /**
 960      * Returns the module that this class or interface is a member of.
 961      *
 962      * If this class represents an array type then this method returns the
 963      * {@code Module} for the element type. If this class represents a
 964      * primitive type or void, then the {@code Module} object for the
 965      * {@code java.base} module is returned.
 966      *
 967      * If this class is in an unnamed module then the {@linkplain
 968      * ClassLoader#getUnnamedModule() unnamed} {@code Module} of the class
 969      * loader for this class is returned.
 970      *
 971      * @return the module that this class or interface is a member of
 972      *
 973      * @since 9
 974      * @spec JPMS
 975      */
 976     public Module getModule() {
 977         return module;
 978     }
 979 
 980     // set by VM
 981     private transient Module module;
 982 
 983     // Initialized in JVM not by private constructor
 984     // This field is filtered from reflection access, i.e. getDeclaredField
 985     // will throw NoSuchFieldException
 986     private final ClassLoader classLoader;
 987 
 988     /**
 989      * Returns an array of {@code TypeVariable} objects that represent the
 990      * type variables declared by the generic declaration represented by this
 991      * {@code GenericDeclaration} object, in declaration order.  Returns an
 992      * array of length 0 if the underlying generic declaration declares no type
 993      * variables.
 994      *
 995      * @return an array of {@code TypeVariable} objects that represent
 996      *     the type variables declared by this generic declaration
 997      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
 998      *     signature of this generic declaration does not conform to
<a name="7" id="anc7"></a><span class="line-modified"> 999      *     the format specified in</span>
<span class="line-modified">1000      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;</span>
1001      * @since 1.5
1002      */
1003     @SuppressWarnings(&quot;unchecked&quot;)
1004     public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
1005         ClassRepository info = getGenericInfo();
1006         if (info != null)
1007             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters();
1008         else
1009             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])new TypeVariable&lt;?&gt;[0];
1010     }
1011 
1012 
1013     /**
1014      * Returns the {@code Class} representing the direct superclass of the
1015      * entity (class, interface, primitive type or void) represented by
1016      * this {@code Class}.  If this {@code Class} represents either the
1017      * {@code Object} class, an interface, a primitive type, or void, then
1018      * null is returned.  If this object represents an array class then the
1019      * {@code Class} object representing the {@code Object} class is
1020      * returned.
1021      *
1022      * @return the direct superclass of the class represented by this object
1023      */
1024     @HotSpotIntrinsicCandidate
1025     public native Class&lt;? super T&gt; getSuperclass();
1026 
1027 
1028     /**
1029      * Returns the {@code Type} representing the direct superclass of
1030      * the entity (class, interface, primitive type or void) represented by
1031      * this {@code Class}.
1032      *
1033      * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
1034      * object returned must accurately reflect the actual type
1035      * arguments used in the source code. The parameterized type
1036      * representing the superclass is created if it had not been
1037      * created before. See the declaration of {@link
1038      * java.lang.reflect.ParameterizedType ParameterizedType} for the
1039      * semantics of the creation process for parameterized types.  If
1040      * this {@code Class} represents either the {@code Object}
1041      * class, an interface, a primitive type, or void, then null is
1042      * returned.  If this object represents an array class then the
1043      * {@code Class} object representing the {@code Object} class is
1044      * returned.
1045      *
1046      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
1047      *     class signature does not conform to the format specified in
<a name="8" id="anc8"></a><span class="line-modified">1048      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;</span>

1049      * @throws TypeNotPresentException if the generic superclass
1050      *     refers to a non-existent type declaration
1051      * @throws java.lang.reflect.MalformedParameterizedTypeException if the
1052      *     generic superclass refers to a parameterized type that cannot be
1053      *     instantiated  for any reason
1054      * @return the direct superclass of the class represented by this object
1055      * @since 1.5
1056      */
1057     public Type getGenericSuperclass() {
1058         ClassRepository info = getGenericInfo();
1059         if (info == null) {
1060             return getSuperclass();
1061         }
1062 
1063         // Historical irregularity:
1064         // Generic signature marks interfaces with superclass = Object
1065         // but this API returns null for interfaces
1066         if (isInterface()) {
1067             return null;
1068         }
1069 
1070         return info.getSuperclass();
1071     }
1072 
1073     /**
1074      * Gets the package of this class.
1075      *
1076      * &lt;p&gt;If this class represents an array type, a primitive type or void,
1077      * this method returns {@code null}.
1078      *
1079      * @return the package of this class.
1080      * @revised 9
1081      * @spec JPMS
1082      */
1083     public Package getPackage() {
1084         if (isPrimitive() || isArray()) {
1085             return null;
1086         }
1087         ClassLoader cl = getClassLoader0();
1088         return cl != null ? cl.definePackage(this)
1089                           : BootLoader.definePackage(this);
1090     }
1091 
1092     /**
1093      * Returns the fully qualified package name.
1094      *
1095      * &lt;p&gt; If this class is a top level class, then this method returns the fully
1096      * qualified name of the package that the class is a member of, or the
1097      * empty string if the class is in an unnamed package.
1098      *
1099      * &lt;p&gt; If this class is a member class, then this method is equivalent to
1100      * invoking {@code getPackageName()} on the {@linkplain #getEnclosingClass
1101      * enclosing class}.
1102      *
1103      * &lt;p&gt; If this class is a {@linkplain #isLocalClass local class} or an {@linkplain
1104      * #isAnonymousClass() anonymous class}, then this method is equivalent to
1105      * invoking {@code getPackageName()} on the {@linkplain #getDeclaringClass
1106      * declaring class} of the {@linkplain #getEnclosingMethod enclosing method} or
1107      * {@linkplain #getEnclosingConstructor enclosing constructor}.
1108      *
1109      * &lt;p&gt; If this class represents an array type then this method returns the
1110      * package name of the element type. If this class represents a primitive
1111      * type or void then the package name &quot;{@code java.lang}&quot; is returned.
1112      *
1113      * @return the fully qualified package name
1114      *
1115      * @since 9
1116      * @spec JPMS
1117      * @jls 6.7 Fully Qualified Names
1118      */
1119     public String getPackageName() {
1120         String pn = this.packageName;
1121         if (pn == null) {
1122             Class&lt;?&gt; c = this;
1123             while (c.isArray()) {
1124                 c = c.getComponentType();
1125             }
1126             if (c.isPrimitive()) {
1127                 pn = &quot;java.lang&quot;;
1128             } else {
1129                 String cn = c.getName();
1130                 int dot = cn.lastIndexOf(&#39;.&#39;);
1131                 pn = (dot != -1) ? cn.substring(0, dot).intern() : &quot;&quot;;
1132             }
1133             this.packageName = pn;
1134         }
1135         return pn;
1136     }
1137 
1138     // cached package name
1139     private transient String packageName;
1140 
1141     /**
1142      * Returns the interfaces directly implemented by the class or interface
1143      * represented by this object.
1144      *
1145      * &lt;p&gt;If this object represents a class, the return value is an array
1146      * containing objects representing all interfaces directly implemented by
1147      * the class.  The order of the interface objects in the array corresponds
1148      * to the order of the interface names in the {@code implements} clause of
1149      * the declaration of the class represented by this object.  For example,
1150      * given the declaration:
1151      * &lt;blockquote&gt;
1152      * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
1153      * &lt;/blockquote&gt;
1154      * suppose the value of {@code s} is an instance of
1155      * {@code Shimmer}; the value of the expression:
1156      * &lt;blockquote&gt;
1157      * {@code s.getClass().getInterfaces()[0]}
1158      * &lt;/blockquote&gt;
1159      * is the {@code Class} object that represents interface
1160      * {@code FloorWax}; and the value of:
1161      * &lt;blockquote&gt;
1162      * {@code s.getClass().getInterfaces()[1]}
1163      * &lt;/blockquote&gt;
1164      * is the {@code Class} object that represents interface
1165      * {@code DessertTopping}.
1166      *
1167      * &lt;p&gt;If this object represents an interface, the array contains objects
1168      * representing all interfaces directly extended by the interface.  The
1169      * order of the interface objects in the array corresponds to the order of
1170      * the interface names in the {@code extends} clause of the declaration of
1171      * the interface represented by this object.
1172      *
1173      * &lt;p&gt;If this object represents a class or interface that implements no
1174      * interfaces, the method returns an array of length 0.
1175      *
1176      * &lt;p&gt;If this object represents a primitive type or void, the method
1177      * returns an array of length 0.
1178      *
1179      * &lt;p&gt;If this {@code Class} object represents an array type, the
1180      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1181      * returned in that order.
1182      *
1183      * @return an array of interfaces directly implemented by this class
1184      */
1185     public Class&lt;?&gt;[] getInterfaces() {
1186         // defensively copy before handing over to user code
1187         return getInterfaces(true);
1188     }
1189 
1190     private Class&lt;?&gt;[] getInterfaces(boolean cloneArray) {
1191         ReflectionData&lt;T&gt; rd = reflectionData();
1192         if (rd == null) {
1193             // no cloning required
1194             return getInterfaces0();
1195         } else {
1196             Class&lt;?&gt;[] interfaces = rd.interfaces;
1197             if (interfaces == null) {
1198                 interfaces = getInterfaces0();
1199                 rd.interfaces = interfaces;
1200             }
1201             // defensively copy if requested
1202             return cloneArray ? interfaces.clone() : interfaces;
1203         }
1204     }
1205 
1206     private native Class&lt;?&gt;[] getInterfaces0();
1207 
1208     /**
1209      * Returns the {@code Type}s representing the interfaces
1210      * directly implemented by the class or interface represented by
1211      * this object.
1212      *
1213      * &lt;p&gt;If a superinterface is a parameterized type, the
1214      * {@code Type} object returned for it must accurately reflect
1215      * the actual type arguments used in the source code. The
1216      * parameterized type representing each superinterface is created
1217      * if it had not been created before. See the declaration of
1218      * {@link java.lang.reflect.ParameterizedType ParameterizedType}
1219      * for the semantics of the creation process for parameterized
1220      * types.
1221      *
1222      * &lt;p&gt;If this object represents a class, the return value is an array
1223      * containing objects representing all interfaces directly implemented by
1224      * the class.  The order of the interface objects in the array corresponds
1225      * to the order of the interface names in the {@code implements} clause of
1226      * the declaration of the class represented by this object.
1227      *
1228      * &lt;p&gt;If this object represents an interface, the array contains objects
1229      * representing all interfaces directly extended by the interface.  The
1230      * order of the interface objects in the array corresponds to the order of
1231      * the interface names in the {@code extends} clause of the declaration of
1232      * the interface represented by this object.
1233      *
1234      * &lt;p&gt;If this object represents a class or interface that implements no
1235      * interfaces, the method returns an array of length 0.
1236      *
1237      * &lt;p&gt;If this object represents a primitive type or void, the method
1238      * returns an array of length 0.
1239      *
1240      * &lt;p&gt;If this {@code Class} object represents an array type, the
1241      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1242      * returned in that order.
1243      *
1244      * @throws java.lang.reflect.GenericSignatureFormatError
<a name="9" id="anc9"></a><span class="line-modified">1245      *     if the generic class signature does not conform to the format</span>
<span class="line-modified">1246      *     specified in</span>
<span class="line-modified">1247      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;</span>
1248      * @throws TypeNotPresentException if any of the generic
1249      *     superinterfaces refers to a non-existent type declaration
1250      * @throws java.lang.reflect.MalformedParameterizedTypeException
1251      *     if any of the generic superinterfaces refer to a parameterized
1252      *     type that cannot be instantiated for any reason
1253      * @return an array of interfaces directly implemented by this class
1254      * @since 1.5
1255      */
1256     public Type[] getGenericInterfaces() {
1257         ClassRepository info = getGenericInfo();
1258         return (info == null) ?  getInterfaces() : info.getSuperInterfaces();
1259     }
1260 
1261 
1262     /**
1263      * Returns the {@code Class} representing the component type of an
1264      * array.  If this class does not represent an array class this method
1265      * returns null.
1266      *
1267      * @return the {@code Class} representing the component type of this
1268      * class if this class is an array
1269      * @see     java.lang.reflect.Array
1270      * @since 1.1
1271      */
1272     public Class&lt;?&gt; getComponentType() {
1273         // Only return for array types. Storage may be reused for Class for instance types.
1274         if (isArray()) {
1275             return componentType;
1276         } else {
1277             return null;
1278         }
1279     }
1280 
1281     private final Class&lt;?&gt; componentType;
1282 
1283 
1284     /**
1285      * Returns the Java language modifiers for this class or interface, encoded
1286      * in an integer. The modifiers consist of the Java Virtual Machine&#39;s
1287      * constants for {@code public}, {@code protected},
1288      * {@code private}, {@code final}, {@code static},
1289      * {@code abstract} and {@code interface}; they should be decoded
1290      * using the methods of class {@code Modifier}.
1291      *
1292      * &lt;p&gt; If the underlying class is an array class, then its
1293      * {@code public}, {@code private} and {@code protected}
1294      * modifiers are the same as those of its component type.  If this
1295      * {@code Class} represents a primitive type or void, its
1296      * {@code public} modifier is always {@code true}, and its
1297      * {@code protected} and {@code private} modifiers are always
1298      * {@code false}. If this object represents an array class, a
1299      * primitive type or void, then its {@code final} modifier is always
1300      * {@code true} and its interface modifier is always
1301      * {@code false}. The values of its other modifiers are not determined
1302      * by this specification.
1303      *
<a name="10" id="anc10"></a><span class="line-modified">1304      * &lt;p&gt; The modifier encodings are defined in &lt;em&gt;The Java Virtual Machine</span>
<span class="line-modified">1305      * Specification&lt;/em&gt;, table 4.1.</span>
1306      *
1307      * @return the {@code int} representing the modifiers for this class
1308      * @see     java.lang.reflect.Modifier
1309      * @since 1.1
1310      */
1311     @HotSpotIntrinsicCandidate
1312     public native int getModifiers();
1313 
1314     /**
1315      * Gets the signers of this class.
1316      *
1317      * @return  the signers of this class, or null if there are no signers.  In
1318      *          particular, this method returns null if this object represents
1319      *          a primitive type or void.
1320      * @since   1.1
1321      */
1322     public Object[] getSigners() {
1323         return asPrimaryType().getSigners0();
1324     }
1325 
1326     private native Object[] getSigners0();
1327 
1328     /**
1329      * Set the signers of this class.
1330      */
1331     void setSigners(Object[] signers) {
1332         asPrimaryType().setSigners0(signers);
1333     }
1334 
1335     native void setSigners0(Object[] signers);
1336 
1337 
1338     /**
1339      * If this {@code Class} object represents a local or anonymous
1340      * class within a method, returns a {@link
1341      * java.lang.reflect.Method Method} object representing the
1342      * immediately enclosing method of the underlying class. Returns
1343      * {@code null} otherwise.
1344      *
1345      * In particular, this method returns {@code null} if the underlying
1346      * class is a local or anonymous class immediately enclosed by a type
1347      * declaration, instance initializer or static initializer.
1348      *
1349      * @return the immediately enclosing method of the underlying class, if
1350      *     that class is a local or anonymous class; otherwise {@code null}.
1351      *
1352      * @throws SecurityException
1353      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1354      *         following conditions is met:
1355      *
1356      *         &lt;ul&gt;
1357      *
1358      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
1359      *         class loader of the enclosing class and invocation of
1360      *         {@link SecurityManager#checkPermission
1361      *         s.checkPermission} method with
1362      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
1363      *         denies access to the methods within the enclosing class
1364      *
1365      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
1366      *         ancestor of the class loader for the enclosing class and
1367      *         invocation of {@link SecurityManager#checkPackageAccess
1368      *         s.checkPackageAccess()} denies access to the package
1369      *         of the enclosing class
1370      *
1371      *         &lt;/ul&gt;
1372      * @since 1.5
1373      */
1374     @CallerSensitive
1375     public Method getEnclosingMethod() throws SecurityException {
1376         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1377 
1378         if (enclosingInfo == null)
1379             return null;
1380         else {
1381             if (!enclosingInfo.isMethod())
1382                 return null;
1383 
1384             MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(),
1385                                                               getFactory());
1386             Class&lt;?&gt;   returnType       = toClass(typeInfo.getReturnType());
1387             Type []    parameterTypes   = typeInfo.getParameterTypes();
1388             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
1389 
1390             // Convert Types to Classes; returned types *should*
1391             // be class objects since the methodDescriptor&#39;s used
1392             // don&#39;t have generics information
1393             for(int i = 0; i &lt; parameterClasses.length; i++)
1394                 parameterClasses[i] = toClass(parameterTypes[i]);
1395 
1396             // Perform access check
1397             final Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
1398             SecurityManager sm = System.getSecurityManager();
1399             if (sm != null) {
1400                 enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,
1401                                                      Reflection.getCallerClass(), true);
1402             }
1403             Method[] candidates = enclosingCandidate.privateGetDeclaredMethods(false);
1404 
1405             /*
1406              * Loop over all declared methods; match method name,
1407              * number of and type of parameters, *and* return
1408              * type.  Matching return type is also necessary
1409              * because of covariant returns, etc.
1410              */
1411             ReflectionFactory fact = getReflectionFactory();
1412             for (Method m : candidates) {
1413                 if (m.getName().equals(enclosingInfo.getName()) &amp;&amp;
1414                     arrayContentsEq(parameterClasses,
1415                                     fact.getExecutableSharedParameterTypes(m))) {
1416                     // finally, check return type
1417                     if (m.getReturnType().equals(returnType)) {
1418                         return fact.copyMethod(m);
1419                     }
1420                 }
1421             }
1422 
1423             throw new InternalError(&quot;Enclosing method not found&quot;);
1424         }
1425     }
1426 
1427     private native Object[] getEnclosingMethod0();
1428 
1429     private EnclosingMethodInfo getEnclosingMethodInfo() {
1430         Object[] enclosingInfo = getEnclosingMethod0();
1431         if (enclosingInfo == null)
1432             return null;
1433         else {
1434             return new EnclosingMethodInfo(enclosingInfo);
1435         }
1436     }
1437 
1438     private static final class EnclosingMethodInfo {
1439         private final Class&lt;?&gt; enclosingClass;
1440         private final String name;
1441         private final String descriptor;
1442 
1443         static void validate(Object[] enclosingInfo) {
1444             if (enclosingInfo.length != 3)
1445                 throw new InternalError(&quot;Malformed enclosing method information&quot;);
1446             try {
1447                 // The array is expected to have three elements:
1448 
1449                 // the immediately enclosing class
1450                 Class&lt;?&gt; enclosingClass = (Class&lt;?&gt;)enclosingInfo[0];
1451                 assert(enclosingClass != null);
1452 
1453                 // the immediately enclosing method or constructor&#39;s
1454                 // name (can be null).
1455                 String name = (String)enclosingInfo[1];
1456 
1457                 // the immediately enclosing method or constructor&#39;s
1458                 // descriptor (null iff name is).
1459                 String descriptor = (String)enclosingInfo[2];
1460                 assert((name != null &amp;&amp; descriptor != null) || name == descriptor);
1461             } catch (ClassCastException cce) {
1462                 throw new InternalError(&quot;Invalid type in enclosing method information&quot;, cce);
1463             }
1464         }
1465 
1466         EnclosingMethodInfo(Object[] enclosingInfo) {
1467             validate(enclosingInfo);
1468             this.enclosingClass = (Class&lt;?&gt;)enclosingInfo[0];
1469             this.name = (String)enclosingInfo[1];
1470             this.descriptor = (String)enclosingInfo[2];
1471         }
1472 
1473         boolean isPartial() {
1474             return enclosingClass == null || name == null || descriptor == null;
1475         }
1476 
1477         boolean isConstructor() { return !isPartial() &amp;&amp; &quot;&lt;init&gt;&quot;.equals(name); }
1478 
1479         boolean isMethod() { return !isPartial() &amp;&amp; !isConstructor() &amp;&amp; !&quot;&lt;clinit&gt;&quot;.equals(name); }
1480 
1481         Class&lt;?&gt; getEnclosingClass() { return enclosingClass; }
1482 
1483         String getName() { return name; }
1484 
1485         String getDescriptor() { return descriptor; }
1486 
1487     }
1488 
1489     private static Class&lt;?&gt; toClass(Type o) {
1490         if (o instanceof GenericArrayType)
1491             return Array.newInstance(toClass(((GenericArrayType)o).getGenericComponentType()),
1492                                      0)
1493                 .getClass();
1494         return (Class&lt;?&gt;)o;
1495      }
1496 
1497     /**
1498      * If this {@code Class} object represents a local or anonymous
1499      * class within a constructor, returns a {@link
1500      * java.lang.reflect.Constructor Constructor} object representing
1501      * the immediately enclosing constructor of the underlying
1502      * class. Returns {@code null} otherwise.  In particular, this
1503      * method returns {@code null} if the underlying class is a local
1504      * or anonymous class immediately enclosed by a type declaration,
1505      * instance initializer or static initializer.
1506      *
1507      * @return the immediately enclosing constructor of the underlying class, if
1508      *     that class is a local or anonymous class; otherwise {@code null}.
1509      * @throws SecurityException
1510      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1511      *         following conditions is met:
1512      *
1513      *         &lt;ul&gt;
1514      *
1515      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
1516      *         class loader of the enclosing class and invocation of
1517      *         {@link SecurityManager#checkPermission
1518      *         s.checkPermission} method with
1519      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
1520      *         denies access to the constructors within the enclosing class
1521      *
1522      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
1523      *         ancestor of the class loader for the enclosing class and
1524      *         invocation of {@link SecurityManager#checkPackageAccess
1525      *         s.checkPackageAccess()} denies access to the package
1526      *         of the enclosing class
1527      *
1528      *         &lt;/ul&gt;
1529      * @since 1.5
1530      */
1531     @CallerSensitive
1532     public Constructor&lt;?&gt; getEnclosingConstructor() throws SecurityException {
1533         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1534 
1535         if (enclosingInfo == null)
1536             return null;
1537         else {
1538             if (!enclosingInfo.isConstructor())
1539                 return null;
1540 
1541             ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(),
1542                                                                         getFactory());
1543             Type []    parameterTypes   = typeInfo.getParameterTypes();
1544             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
1545 
1546             // Convert Types to Classes; returned types *should*
1547             // be class objects since the methodDescriptor&#39;s used
1548             // don&#39;t have generics information
1549             for(int i = 0; i &lt; parameterClasses.length; i++)
1550                 parameterClasses[i] = toClass(parameterTypes[i]);
1551 
1552             // Perform access check
1553             final Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
1554             SecurityManager sm = System.getSecurityManager();
1555             if (sm != null) {
1556                 enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,
1557                                                      Reflection.getCallerClass(), true);
1558             }
1559 
1560             Constructor&lt;?&gt;[] candidates = enclosingCandidate
1561                     .privateGetDeclaredConstructors(false);
1562             /*
1563              * Loop over all declared constructors; match number
1564              * of and type of parameters.
1565              */
1566             ReflectionFactory fact = getReflectionFactory();
1567             for (Constructor&lt;?&gt; c : candidates) {
1568                 if (arrayContentsEq(parameterClasses,
1569                                     fact.getExecutableSharedParameterTypes(c))) {
1570                     return fact.copyConstructor(c);
1571                 }
1572             }
1573 
1574             throw new InternalError(&quot;Enclosing constructor not found&quot;);
1575         }
1576     }
1577 
1578 
1579     /**
1580      * If the class or interface represented by this {@code Class} object
1581      * is a member of another class, returns the {@code Class} object
1582      * representing the class in which it was declared.  This method returns
1583      * null if this class or interface is not a member of any other class.  If
1584      * this {@code Class} object represents an array class, a primitive
1585      * type, or void,then this method returns null.
1586      *
1587      * @return the declaring class for this class
1588      * @throws SecurityException
1589      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1590      *         class loader is not the same as or an ancestor of the class
1591      *         loader for the declaring class and invocation of {@link
1592      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
1593      *         denies access to the package of the declaring class
1594      * @since 1.1
1595      */
1596     @CallerSensitive
1597     public Class&lt;?&gt; getDeclaringClass() throws SecurityException {
1598         final Class&lt;?&gt; candidate = getDeclaringClass0();
1599 
1600         if (candidate != null) {
1601             SecurityManager sm = System.getSecurityManager();
1602             if (sm != null) {
1603                 candidate.checkPackageAccess(sm,
1604                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1605             }
1606         }
1607         return candidate;
1608     }
1609 
1610     private native Class&lt;?&gt; getDeclaringClass0();
1611 
1612 
1613     /**
1614      * Returns the immediately enclosing class of the underlying
1615      * class.  If the underlying class is a top level class this
1616      * method returns {@code null}.
1617      * @return the immediately enclosing class of the underlying class
1618      * @throws     SecurityException
1619      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1620      *             class loader is not the same as or an ancestor of the class
1621      *             loader for the enclosing class and invocation of {@link
1622      *             SecurityManager#checkPackageAccess s.checkPackageAccess()}
1623      *             denies access to the package of the enclosing class
1624      * @since 1.5
1625      */
1626     @CallerSensitive
1627     public Class&lt;?&gt; getEnclosingClass() throws SecurityException {
1628         // There are five kinds of classes (or interfaces):
1629         // a) Top level classes
1630         // b) Nested classes (static member classes)
1631         // c) Inner classes (non-static member classes)
1632         // d) Local classes (named classes declared within a method)
1633         // e) Anonymous classes
1634 
1635 
1636         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1637         // attribute if and only if it is a local class or an
1638         // anonymous class.
1639         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1640         Class&lt;?&gt; enclosingCandidate;
1641 
1642         if (enclosingInfo == null) {
1643             // This is a top level or a nested class or an inner class (a, b, or c)
1644             enclosingCandidate = getDeclaringClass0();
1645         } else {
1646             Class&lt;?&gt; enclosingClass = enclosingInfo.getEnclosingClass();
1647             // This is a local class or an anonymous class (d or e)
1648             if (enclosingClass == this || enclosingClass == null)
1649                 throw new InternalError(&quot;Malformed enclosing method information&quot;);
1650             else
1651                 enclosingCandidate = enclosingClass;
1652         }
1653 
1654         if (enclosingCandidate != null) {
1655             SecurityManager sm = System.getSecurityManager();
1656             if (sm != null) {
1657                 enclosingCandidate.checkPackageAccess(sm,
1658                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1659             }
1660         }
1661         return enclosingCandidate;
1662     }
1663 
1664     /**
1665      * Returns the simple name of the underlying class as given in the
1666      * source code. Returns an empty string if the underlying class is
1667      * anonymous.
1668      *
1669      * &lt;p&gt;The simple name of an array is the simple name of the
1670      * component type with &quot;[]&quot; appended.  In particular the simple
1671      * name of an array whose component type is anonymous is &quot;[]&quot;.
1672      *
1673      * @return the simple name of the underlying class
1674      * @since 1.5
1675      */
1676     public String getSimpleName() {
1677         ReflectionData&lt;T&gt; rd = reflectionData();
1678         String simpleName = rd.simpleName;
1679         if (simpleName == null) {
1680             rd.simpleName = simpleName = getSimpleName0();
1681         }
1682         return simpleName;
1683     }
1684 
1685     private String getSimpleName0() {
1686         if (isArray()) {
1687             return getComponentType().getSimpleName() + &quot;[]&quot;;
1688         }
1689         String simpleName = getSimpleBinaryName();
1690         if (simpleName == null) { // top level class
1691             simpleName = getName();
1692             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1693         }
1694         return isInlineClass() &amp;&amp; isIndirectType() ? simpleName + &quot;?&quot; : simpleName;
1695     }
1696 
1697     /**
1698      * Return an informative string for the name of this type.
1699      *
1700      * @return an informative string for the name of this type
1701      * @since 1.8
1702      */
1703     public String getTypeName() {
1704         if (isArray()) {
1705             try {
1706                 Class&lt;?&gt; cl = this;
1707                 int dimensions = 0;
1708                 do {
1709                     dimensions++;
1710                     cl = cl.getComponentType();
1711                 } while (cl.isArray());
1712                 return cl.getTypeName() + &quot;[]&quot;.repeat(dimensions);
1713             } catch (Throwable e) { /*FALLTHRU*/ }
1714         }
1715         return toTypeName();
1716     }
1717 
1718     /**
<a name="11" id="anc11"></a><span class="line-modified">1719      * Returns the canonical name of the underlying class as</span>
<span class="line-modified">1720      * defined by the Java Language Specification.  Returns null if</span>
<span class="line-modified">1721      * the underlying class does not have a canonical name (i.e., if</span>
<span class="line-modified">1722      * it is a local or anonymous class or an array whose component</span>
<span class="line-modified">1723      * type does not have a canonical name).</span>
1724      * @return the canonical name of the underlying class if it exists, and
1725      * {@code null} otherwise.
1726      * @since 1.5
1727      */
1728     public String getCanonicalName() {
1729         ReflectionData&lt;T&gt; rd = reflectionData();
1730         String canonicalName = rd.canonicalName;
1731         if (canonicalName == null) {
1732             rd.canonicalName = canonicalName = getCanonicalName0();
1733         }
1734         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1735     }
1736 
1737     private String getCanonicalName0() {
1738         if (isArray()) {
1739             String canonicalName = getComponentType().getCanonicalName();
1740             if (canonicalName != null)
1741                 return canonicalName + &quot;[]&quot;;
1742             else
1743                 return ReflectionData.NULL_SENTINEL;
1744         }
1745         if (isLocalOrAnonymousClass())
1746             return ReflectionData.NULL_SENTINEL;
1747         Class&lt;?&gt; enclosingClass = getEnclosingClass();
1748         if (enclosingClass == null) { // top level class
1749             return getName();
1750         } else {
1751             String enclosingName = enclosingClass.getCanonicalName();
1752             if (enclosingName == null)
1753                 return ReflectionData.NULL_SENTINEL;
1754             return enclosingName + &quot;.&quot; + getSimpleName();
1755         }
1756     }
1757 
1758     /**
1759      * Returns {@code true} if and only if the underlying class
1760      * is an anonymous class.
1761      *
1762      * @return {@code true} if and only if this class is an anonymous class.
1763      * @since 1.5
1764      */
1765     public boolean isAnonymousClass() {
1766         return !isArray() &amp;&amp; isLocalOrAnonymousClass() &amp;&amp;
1767                 getSimpleBinaryName0() == null;
1768     }
1769 
1770     /**
1771      * Returns {@code true} if and only if the underlying class
1772      * is a local class.
1773      *
1774      * @return {@code true} if and only if this class is a local class.
1775      * @since 1.5
1776      */
1777     public boolean isLocalClass() {
1778         return isLocalOrAnonymousClass() &amp;&amp;
1779                 (isArray() || getSimpleBinaryName0() != null);
1780     }
1781 
1782     /**
1783      * Returns {@code true} if and only if the underlying class
1784      * is a member class.
1785      *
1786      * @return {@code true} if and only if this class is a member class.
1787      * @since 1.5
1788      */
1789     public boolean isMemberClass() {
1790         return !isLocalOrAnonymousClass() &amp;&amp; getDeclaringClass0() != null;
1791     }
1792 
1793     /**
1794      * Returns the &quot;simple binary name&quot; of the underlying class, i.e.,
1795      * the binary name without the leading enclosing class name.
1796      * Returns {@code null} if the underlying class is a top level
1797      * class.
1798      */
1799     private String getSimpleBinaryName() {
1800         if (isTopLevelClass())
1801             return null;
1802         String name = getSimpleBinaryName0();
1803         if (name == null) // anonymous class
1804             return &quot;&quot;;
1805         return name;
1806     }
1807 
1808     private native String getSimpleBinaryName0();
1809 
1810     /**
1811      * Returns {@code true} if this is a top level class.  Returns {@code false}
1812      * otherwise.
1813      */
1814     private boolean isTopLevelClass() {
1815         return !isLocalOrAnonymousClass() &amp;&amp; getDeclaringClass0() == null;
1816     }
1817 
1818     /**
1819      * Returns {@code true} if this is a local class or an anonymous
1820      * class.  Returns {@code false} otherwise.
1821      */
1822     private boolean isLocalOrAnonymousClass() {
1823         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1824         // attribute if and only if it is a local class or an
1825         // anonymous class.
1826         return hasEnclosingMethodInfo();
1827     }
1828 
1829     private boolean hasEnclosingMethodInfo() {
1830         Object[] enclosingInfo = getEnclosingMethod0();
1831         if (enclosingInfo != null) {
1832             EnclosingMethodInfo.validate(enclosingInfo);
1833             return true;
1834         }
1835         return false;
1836     }
1837 
1838     /**
1839      * Returns an array containing {@code Class} objects representing all
1840      * the public classes and interfaces that are members of the class
1841      * represented by this {@code Class} object.  This includes public
1842      * class and interface members inherited from superclasses and public class
1843      * and interface members declared by the class.  This method returns an
1844      * array of length 0 if this {@code Class} object has no public member
1845      * classes or interfaces.  This method also returns an array of length 0 if
1846      * this {@code Class} object represents a primitive type, an array
1847      * class, or void.
1848      *
1849      * @return the array of {@code Class} objects representing the public
1850      *         members of this class
1851      * @throws SecurityException
1852      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1853      *         the caller&#39;s class loader is not the same as or an
1854      *         ancestor of the class loader for the current class and
1855      *         invocation of {@link SecurityManager#checkPackageAccess
1856      *         s.checkPackageAccess()} denies access to the package
1857      *         of this class.
1858      *
1859      * @since 1.1
1860      */
1861     @CallerSensitive
1862     public Class&lt;?&gt;[] getClasses() {
1863         SecurityManager sm = System.getSecurityManager();
1864         if (sm != null) {
1865             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);
1866         }
1867 
1868         // Privileged so this implementation can look at DECLARED classes,
1869         // something the caller might not have privilege to do.  The code here
1870         // is allowed to look at DECLARED classes because (1) it does not hand
1871         // out anything other than public members and (2) public member access
1872         // has already been ok&#39;d by the SecurityManager.
1873 
1874         return java.security.AccessController.doPrivileged(
1875             new java.security.PrivilegedAction&lt;&gt;() {
1876                 public Class&lt;?&gt;[] run() {
1877                     List&lt;Class&lt;?&gt;&gt; list = new ArrayList&lt;&gt;();
1878                     Class&lt;?&gt; currentClass = Class.this;
1879                     while (currentClass != null) {
1880                         for (Class&lt;?&gt; m : currentClass.getDeclaredClasses()) {
1881                             if (Modifier.isPublic(m.getModifiers())) {
1882                                 list.add(m);
1883                             }
1884                         }
1885                         currentClass = currentClass.getSuperclass();
1886                     }
1887                     return list.toArray(new Class&lt;?&gt;[0]);
1888                 }
1889             });
1890     }
1891 
1892 
1893     /**
1894      * Returns an array containing {@code Field} objects reflecting all
1895      * the accessible public fields of the class or interface represented by
1896      * this {@code Class} object.
1897      *
1898      * &lt;p&gt; If this {@code Class} object represents a class or interface with
1899      * no accessible public fields, then this method returns an array of length
1900      * 0.
1901      *
1902      * &lt;p&gt; If this {@code Class} object represents a class, then this method
1903      * returns the public fields of the class and of all its superclasses and
1904      * superinterfaces.
1905      *
1906      * &lt;p&gt; If this {@code Class} object represents an interface, then this
1907      * method returns the fields of the interface and of all its
1908      * superinterfaces.
1909      *
1910      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
1911      * type, or void, then this method returns an array of length 0.
1912      *
1913      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
1914      * particular order.
1915      *
1916      * @return the array of {@code Field} objects representing the
1917      *         public fields
1918      * @throws SecurityException
1919      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1920      *         the caller&#39;s class loader is not the same as or an
1921      *         ancestor of the class loader for the current class and
1922      *         invocation of {@link SecurityManager#checkPackageAccess
1923      *         s.checkPackageAccess()} denies access to the package
1924      *         of this class.
1925      *
1926      * @since 1.1
1927      * @jls 8.2 Class Members
1928      * @jls 8.3 Field Declarations
1929      */
1930     @CallerSensitive
1931     public Field[] getFields() throws SecurityException {
1932         SecurityManager sm = System.getSecurityManager();
1933         if (sm != null) {
1934             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
1935         }
1936         return copyFields(privateGetPublicFields());
1937     }
1938 
1939 
1940     /**
1941      * Returns an array containing {@code Method} objects reflecting all the
1942      * public methods of the class or interface represented by this {@code
1943      * Class} object, including those declared by the class or interface and
1944      * those inherited from superclasses and superinterfaces.
1945      *
1946      * &lt;p&gt; If this {@code Class} object represents an array type, then the
1947      * returned array has a {@code Method} object for each of the public
1948      * methods inherited by the array type from {@code Object}. It does not
1949      * contain a {@code Method} object for {@code clone()}.
1950      *
1951      * &lt;p&gt; If this {@code Class} object represents an interface then the
1952      * returned array does not contain any implicitly declared methods from
1953      * {@code Object}. Therefore, if no methods are explicitly declared in
1954      * this interface or any of its superinterfaces then the returned array
1955      * has length 0. (Note that a {@code Class} object which represents a class
1956      * always has public methods, inherited from {@code Object}.)
1957      *
1958      * &lt;p&gt; The returned array never contains methods with names &quot;{@code &lt;init&gt;}&quot;
1959      * or &quot;{@code &lt;clinit&gt;}&quot;.
1960      *
1961      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
1962      * particular order.
1963      *
1964      * &lt;p&gt; Generally, the result is computed as with the following 4 step algorithm.
1965      * Let C be the class or interface represented by this {@code Class} object:
1966      * &lt;ol&gt;
1967      * &lt;li&gt; A union of methods is composed of:
1968      *   &lt;ol type=&quot;a&quot;&gt;
1969      *   &lt;li&gt; C&#39;s declared public instance and static methods as returned by
1970      *        {@link #getDeclaredMethods()} and filtered to include only public
1971      *        methods.&lt;/li&gt;
1972      *   &lt;li&gt; If C is a class other than {@code Object}, then include the result
1973      *        of invoking this algorithm recursively on the superclass of C.&lt;/li&gt;
1974      *   &lt;li&gt; Include the results of invoking this algorithm recursively on all
1975      *        direct superinterfaces of C, but include only instance methods.&lt;/li&gt;
1976      *   &lt;/ol&gt;&lt;/li&gt;
1977      * &lt;li&gt; Union from step 1 is partitioned into subsets of methods with same
1978      *      signature (name, parameter types) and return type.&lt;/li&gt;
1979      * &lt;li&gt; Within each such subset only the most specific methods are selected.
1980      *      Let method M be a method from a set of methods with same signature
1981      *      and return type. M is most specific if there is no such method
1982      *      N != M from the same set, such that N is more specific than M.
1983      *      N is more specific than M if:
1984      *   &lt;ol type=&quot;a&quot;&gt;
1985      *   &lt;li&gt; N is declared by a class and M is declared by an interface; or&lt;/li&gt;
1986      *   &lt;li&gt; N and M are both declared by classes or both by interfaces and
1987      *        N&#39;s declaring type is the same as or a subtype of M&#39;s declaring type
1988      *        (clearly, if M&#39;s and N&#39;s declaring types are the same type, then
1989      *        M and N are the same method).&lt;/li&gt;
1990      *   &lt;/ol&gt;&lt;/li&gt;
1991      * &lt;li&gt; The result of this algorithm is the union of all selected methods from
1992      *      step 3.&lt;/li&gt;
1993      * &lt;/ol&gt;
1994      *
1995      * @apiNote There may be more than one method with a particular name
1996      * and parameter types in a class because while the Java language forbids a
1997      * class to declare multiple methods with the same signature but different
1998      * return types, the Java virtual machine does not.  This
1999      * increased flexibility in the virtual machine can be used to
2000      * implement various language features.  For example, covariant
2001      * returns can be implemented with {@linkplain
2002      * java.lang.reflect.Method#isBridge bridge methods}; the bridge
2003      * method and the overriding method would have the same
2004      * signature but different return types.
2005      *
2006      * @return the array of {@code Method} objects representing the
2007      *         public methods of this class
2008      * @throws SecurityException
2009      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2010      *         the caller&#39;s class loader is not the same as or an
2011      *         ancestor of the class loader for the current class and
2012      *         invocation of {@link SecurityManager#checkPackageAccess
2013      *         s.checkPackageAccess()} denies access to the package
2014      *         of this class.
2015      *
2016      * @jls 8.2 Class Members
2017      * @jls 8.4 Method Declarations
2018      * @since 1.1
2019      */
2020     @CallerSensitive
2021     public Method[] getMethods() throws SecurityException {
2022         SecurityManager sm = System.getSecurityManager();
2023         if (sm != null) {
2024             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2025         }
2026         return copyMethods(privateGetPublicMethods());
2027     }
2028 
2029 
2030     /**
2031      * Returns an array containing {@code Constructor} objects reflecting
2032      * all the public constructors of the class represented by this
2033      * {@code Class} object.  An array of length 0 is returned if the
2034      * class has no public constructors, or if the class is an array class, or
2035      * if the class reflects a primitive type or void.
2036      *
<a name="12" id="anc12"></a><span class="line-modified">2037      * Note that while this method returns an array of {@code</span>

2038      * Constructor&lt;T&gt;} objects (that is an array of constructors from
2039      * this class), the return type of this method is {@code
2040      * Constructor&lt;?&gt;[]} and &lt;em&gt;not&lt;/em&gt; {@code Constructor&lt;T&gt;[]} as
2041      * might be expected.  This less informative return type is
2042      * necessary since after being returned from this method, the
2043      * array could be modified to hold {@code Constructor} objects for
2044      * different classes, which would violate the type guarantees of
2045      * {@code Constructor&lt;T&gt;[]}.
2046      *
2047      * @return the array of {@code Constructor} objects representing the
2048      *         public constructors of this class
2049      * @throws SecurityException
2050      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2051      *         the caller&#39;s class loader is not the same as or an
2052      *         ancestor of the class loader for the current class and
2053      *         invocation of {@link SecurityManager#checkPackageAccess
2054      *         s.checkPackageAccess()} denies access to the package
2055      *         of this class.
2056      *
2057      * @since 1.1
2058      */
2059     @CallerSensitive
2060     public Constructor&lt;?&gt;[] getConstructors() throws SecurityException {
2061         SecurityManager sm = System.getSecurityManager();
2062         if (sm != null) {
2063             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2064         }
2065         return copyConstructors(privateGetDeclaredConstructors(true));
2066     }
2067 
2068 
2069     /**
2070      * Returns a {@code Field} object that reflects the specified public member
2071      * field of the class or interface represented by this {@code Class}
2072      * object. The {@code name} parameter is a {@code String} specifying the
2073      * simple name of the desired field.
2074      *
2075      * &lt;p&gt; The field to be reflected is determined by the algorithm that
2076      * follows.  Let C be the class or interface represented by this object:
2077      *
2078      * &lt;OL&gt;
2079      * &lt;LI&gt; If C declares a public field with the name specified, that is the
2080      *      field to be reflected.&lt;/LI&gt;
2081      * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
2082      *      recursively to each direct superinterface of C. The direct
2083      *      superinterfaces are searched in the order they were declared.&lt;/LI&gt;
2084      * &lt;LI&gt; If no field was found in steps 1 and 2 above, and C has a
2085      *      superclass S, then this algorithm is invoked recursively upon S.
2086      *      If C has no superclass, then a {@code NoSuchFieldException}
2087      *      is thrown.&lt;/LI&gt;
2088      * &lt;/OL&gt;
2089      *
2090      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2091      * method does not find the {@code length} field of the array type.
2092      *
2093      * @param name the field name
2094      * @return the {@code Field} object of this class specified by
2095      *         {@code name}
2096      * @throws NoSuchFieldException if a field with the specified name is
2097      *         not found.
2098      * @throws NullPointerException if {@code name} is {@code null}
2099      * @throws SecurityException
2100      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2101      *         the caller&#39;s class loader is not the same as or an
2102      *         ancestor of the class loader for the current class and
2103      *         invocation of {@link SecurityManager#checkPackageAccess
2104      *         s.checkPackageAccess()} denies access to the package
2105      *         of this class.
2106      *
2107      * @since 1.1
2108      * @jls 8.2 Class Members
2109      * @jls 8.3 Field Declarations
2110      */
2111     @CallerSensitive
2112     public Field getField(String name)
2113         throws NoSuchFieldException, SecurityException {
2114         Objects.requireNonNull(name);
2115         SecurityManager sm = System.getSecurityManager();
2116         if (sm != null) {
2117             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2118         }
2119         Field field = getField0(name);
2120         if (field == null) {
2121             throw new NoSuchFieldException(name);
2122         }
2123         return getReflectionFactory().copyField(field);
2124     }
2125 
2126 
2127     /**
2128      * Returns a {@code Method} object that reflects the specified public
2129      * member method of the class or interface represented by this
2130      * {@code Class} object. The {@code name} parameter is a
2131      * {@code String} specifying the simple name of the desired method. The
2132      * {@code parameterTypes} parameter is an array of {@code Class}
2133      * objects that identify the method&#39;s formal parameter types, in declared
2134      * order. If {@code parameterTypes} is {@code null}, it is
2135      * treated as if it were an empty array.
2136      *
2137      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2138      * method finds any public method inherited by the array type from
2139      * {@code Object} except method {@code clone()}.
2140      *
2141      * &lt;p&gt; If this {@code Class} object represents an interface then this
2142      * method does not find any implicitly declared method from
2143      * {@code Object}. Therefore, if no methods are explicitly declared in
2144      * this interface or any of its superinterfaces, then this method does not
2145      * find any method.
2146      *
2147      * &lt;p&gt; This method does not find any method with name &quot;{@code &lt;init&gt;}&quot; or
2148      * &quot;{@code &lt;clinit&gt;}&quot;.
2149      *
2150      * &lt;p&gt; Generally, the method to be reflected is determined by the 4 step
2151      * algorithm that follows.
2152      * Let C be the class or interface represented by this {@code Class} object:
2153      * &lt;ol&gt;
2154      * &lt;li&gt; A union of methods is composed of:
2155      *   &lt;ol type=&quot;a&quot;&gt;
2156      *   &lt;li&gt; C&#39;s declared public instance and static methods as returned by
2157      *        {@link #getDeclaredMethods()} and filtered to include only public
2158      *        methods that match given {@code name} and {@code parameterTypes}&lt;/li&gt;
2159      *   &lt;li&gt; If C is a class other than {@code Object}, then include the result
2160      *        of invoking this algorithm recursively on the superclass of C.&lt;/li&gt;
2161      *   &lt;li&gt; Include the results of invoking this algorithm recursively on all
2162      *        direct superinterfaces of C, but include only instance methods.&lt;/li&gt;
2163      *   &lt;/ol&gt;&lt;/li&gt;
2164      * &lt;li&gt; This union is partitioned into subsets of methods with same
2165      *      return type (the selection of methods from step 1 also guarantees that
2166      *      they have the same method name and parameter types).&lt;/li&gt;
2167      * &lt;li&gt; Within each such subset only the most specific methods are selected.
2168      *      Let method M be a method from a set of methods with same VM
2169      *      signature (return type, name, parameter types).
2170      *      M is most specific if there is no such method N != M from the same
2171      *      set, such that N is more specific than M. N is more specific than M
2172      *      if:
2173      *   &lt;ol type=&quot;a&quot;&gt;
2174      *   &lt;li&gt; N is declared by a class and M is declared by an interface; or&lt;/li&gt;
2175      *   &lt;li&gt; N and M are both declared by classes or both by interfaces and
2176      *        N&#39;s declaring type is the same as or a subtype of M&#39;s declaring type
2177      *        (clearly, if M&#39;s and N&#39;s declaring types are the same type, then
2178      *        M and N are the same method).&lt;/li&gt;
2179      *   &lt;/ol&gt;&lt;/li&gt;
2180      * &lt;li&gt; The result of this algorithm is chosen arbitrarily from the methods
2181      *      with most specific return type among all selected methods from step 3.
2182      *      Let R be a return type of a method M from the set of all selected methods
2183      *      from step 3. M is a method with most specific return type if there is
2184      *      no such method N != M from the same set, having return type S != R,
2185      *      such that S is a subtype of R as determined by
2186      *      R.class.{@link #isAssignableFrom}(S.class).
2187      * &lt;/ol&gt;
2188      *
2189      * @apiNote There may be more than one method with matching name and
2190      * parameter types in a class because while the Java language forbids a
2191      * class to declare multiple methods with the same signature but different
2192      * return types, the Java virtual machine does not.  This
2193      * increased flexibility in the virtual machine can be used to
2194      * implement various language features.  For example, covariant
2195      * returns can be implemented with {@linkplain
2196      * java.lang.reflect.Method#isBridge bridge methods}; the bridge
2197      * method and the overriding method would have the same
2198      * signature but different return types. This method would return the
2199      * overriding method as it would have a more specific return type.
2200      *
2201      * @param name the name of the method
2202      * @param parameterTypes the list of parameters
2203      * @return the {@code Method} object that matches the specified
2204      *         {@code name} and {@code parameterTypes}
2205      * @throws NoSuchMethodException if a matching method is not found
2206      *         or if the name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot;.
2207      * @throws NullPointerException if {@code name} is {@code null}
2208      * @throws SecurityException
2209      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2210      *         the caller&#39;s class loader is not the same as or an
2211      *         ancestor of the class loader for the current class and
2212      *         invocation of {@link SecurityManager#checkPackageAccess
2213      *         s.checkPackageAccess()} denies access to the package
2214      *         of this class.
2215      *
2216      * @jls 8.2 Class Members
2217      * @jls 8.4 Method Declarations
2218      * @since 1.1
2219      */
2220     @CallerSensitive
2221     public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)
2222         throws NoSuchMethodException, SecurityException {
2223         Objects.requireNonNull(name);
2224         SecurityManager sm = System.getSecurityManager();
2225         if (sm != null) {
2226             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2227         }
2228         Method method = getMethod0(name, parameterTypes);
2229         if (method == null) {
2230             throw new NoSuchMethodException(methodToString(name, parameterTypes));
2231         }
2232         return getReflectionFactory().copyMethod(method);
2233     }
2234 
2235     /**
2236      * Returns a {@code Constructor} object that reflects the specified
2237      * public constructor of the class represented by this {@code Class}
2238      * object. The {@code parameterTypes} parameter is an array of
2239      * {@code Class} objects that identify the constructor&#39;s formal
2240      * parameter types, in declared order.
2241      *
2242      * If this {@code Class} object represents an inner class
2243      * declared in a non-static context, the formal parameter types
2244      * include the explicit enclosing instance as the first parameter.
2245      *
2246      * &lt;p&gt; The constructor to reflect is the public constructor of the class
2247      * represented by this {@code Class} object whose formal parameter
2248      * types match those specified by {@code parameterTypes}.
2249      *
2250      * @param parameterTypes the parameter array
2251      * @return the {@code Constructor} object of the public constructor that
2252      *         matches the specified {@code parameterTypes}
2253      * @throws NoSuchMethodException if a matching method is not found.
2254      * @throws SecurityException
2255      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2256      *         the caller&#39;s class loader is not the same as or an
2257      *         ancestor of the class loader for the current class and
2258      *         invocation of {@link SecurityManager#checkPackageAccess
2259      *         s.checkPackageAccess()} denies access to the package
2260      *         of this class.
2261      *
2262      * @since 1.1
2263      */
2264     @CallerSensitive
2265     public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)
2266         throws NoSuchMethodException, SecurityException
2267     {
2268         SecurityManager sm = System.getSecurityManager();
2269         if (sm != null) {
2270             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2271         }
2272         return getReflectionFactory().copyConstructor(
2273             getConstructor0(parameterTypes, Member.PUBLIC));
2274     }
2275 
2276 
2277     /**
2278      * Returns an array of {@code Class} objects reflecting all the
2279      * classes and interfaces declared as members of the class represented by
2280      * this {@code Class} object. This includes public, protected, default
2281      * (package) access, and private classes and interfaces declared by the
2282      * class, but excludes inherited classes and interfaces.  This method
2283      * returns an array of length 0 if the class declares no classes or
2284      * interfaces as members, or if this {@code Class} object represents a
2285      * primitive type, an array class, or void.
2286      *
2287      * @return the array of {@code Class} objects representing all the
2288      *         declared members of this class
2289      * @throws SecurityException
2290      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2291      *         following conditions is met:
2292      *
2293      *         &lt;ul&gt;
2294      *
2295      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
2296      *         class loader of this class and invocation of
2297      *         {@link SecurityManager#checkPermission
2298      *         s.checkPermission} method with
2299      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2300      *         denies access to the declared classes within this class
2301      *
2302      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
2303      *         ancestor of the class loader for the current class and
2304      *         invocation of {@link SecurityManager#checkPackageAccess
2305      *         s.checkPackageAccess()} denies access to the package
2306      *         of this class
2307      *
2308      *         &lt;/ul&gt;
2309      *
2310      * @since 1.1
2311      */
2312     @CallerSensitive
2313     public Class&lt;?&gt;[] getDeclaredClasses() throws SecurityException {
2314         SecurityManager sm = System.getSecurityManager();
2315         if (sm != null) {
2316             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), false);
2317         }
2318         return getDeclaredClasses0();
2319     }
2320 
2321 
2322     /**
2323      * Returns an array of {@code Field} objects reflecting all the fields
2324      * declared by the class or interface represented by this
2325      * {@code Class} object. This includes public, protected, default
2326      * (package) access, and private fields, but excludes inherited fields.
2327      *
2328      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2329      * declared fields, then this method returns an array of length 0.
2330      *
2331      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2332      * type, or void, then this method returns an array of length 0.
2333      *
2334      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2335      * particular order.
2336      *
2337      * @return  the array of {@code Field} objects representing all the
2338      *          declared fields of this class
2339      * @throws  SecurityException
2340      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2341      *          following conditions is met:
2342      *
2343      *          &lt;ul&gt;
2344      *
2345      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2346      *          class loader of this class and invocation of
2347      *          {@link SecurityManager#checkPermission
2348      *          s.checkPermission} method with
2349      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2350      *          denies access to the declared fields within this class
2351      *
2352      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2353      *          ancestor of the class loader for the current class and
2354      *          invocation of {@link SecurityManager#checkPackageAccess
2355      *          s.checkPackageAccess()} denies access to the package
2356      *          of this class
2357      *
2358      *          &lt;/ul&gt;
2359      *
2360      * @since 1.1
2361      * @jls 8.2 Class Members
2362      * @jls 8.3 Field Declarations
2363      */
2364     @CallerSensitive
2365     public Field[] getDeclaredFields() throws SecurityException {
2366         SecurityManager sm = System.getSecurityManager();
2367         if (sm != null) {
2368             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2369         }
2370         return copyFields(privateGetDeclaredFields(false));
2371     }
2372 
2373     /**
2374      * {@preview Associated with records, a preview feature of the Java language.
2375      *
2376      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview
2377      *           feature of the Java language. Preview features
2378      *           may be removed in a future release, or upgraded to permanent
2379      *           features of the Java language.}
2380      *
2381      * Returns an array of {@code RecordComponent} objects representing all the
2382      * record components of this record class, or {@code null} if this class is
2383      * not a record class.
2384      *
2385      * &lt;p&gt; The components are returned in the same order that they are declared
2386      * in the record header. The array is empty if this record class has no
2387      * components. If the class is not a record class, that is {@link
2388      * #isRecord()} returns {@code false}, then this method returns {@code null}.
2389      * Conversely, if {@link #isRecord()} returns {@code true}, then this method
2390      * returns a non-null value.
2391      *
2392      * @return  An array of {@code RecordComponent} objects representing all the
2393      *          record components of this record class, or {@code null} if this
2394      *          class is not a record class
2395      * @throws  SecurityException
2396      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2397      *          following conditions is met:
2398      *
2399      *          &lt;ul&gt;
2400      *
2401      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2402      *          class loader of this class and invocation of
2403      *          {@link SecurityManager#checkPermission
2404      *          s.checkPermission} method with
2405      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2406      *          denies access to the declared methods within this class
2407      *
2408      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2409      *          ancestor of the class loader for the current class and
2410      *          invocation of {@link SecurityManager#checkPackageAccess
2411      *          s.checkPackageAccess()} denies access to the package
2412      *          of this class
2413      *
2414      *          &lt;/ul&gt;
2415      *
2416      * @jls 8.10 Record Types
2417      * @since 14
2418      */
2419     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
2420                                  essentialAPI=false)
2421     @SuppressWarnings(&quot;preview&quot;)
2422     @CallerSensitive
2423     public RecordComponent[] getRecordComponents() {
2424         SecurityManager sm = System.getSecurityManager();
2425         if (sm != null) {
2426             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2427         }
2428         if (!isRecord()) {
2429             return null;
2430         }
2431         RecordComponent[] recordComponents = getRecordComponents0();
2432         if (recordComponents == null) {
2433             return new RecordComponent[0];
2434         }
2435         return recordComponents;
2436     }
2437 
2438     /**
2439      * Returns an array containing {@code Method} objects reflecting all the
2440      * declared methods of the class or interface represented by this {@code
2441      * Class} object, including public, protected, default (package)
2442      * access, and private methods, but excluding inherited methods.
2443      *
2444      * &lt;p&gt; If this {@code Class} object represents a type that has multiple
2445      * declared methods with the same name and parameter types, but different
2446      * return types, then the returned array has a {@code Method} object for
2447      * each such method.
2448      *
2449      * &lt;p&gt; If this {@code Class} object represents a type that has a class
2450      * initialization method {@code &lt;clinit&gt;}, then the returned array does
2451      * &lt;em&gt;not&lt;/em&gt; have a corresponding {@code Method} object.
2452      *
2453      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2454      * declared methods, then the returned array has length 0.
2455      *
2456      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2457      * type, or void, then the returned array has length 0.
2458      *
2459      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2460      * particular order.
2461      *
2462      * @return  the array of {@code Method} objects representing all the
2463      *          declared methods of this class
2464      * @throws  SecurityException
2465      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2466      *          following conditions is met:
2467      *
2468      *          &lt;ul&gt;
2469      *
2470      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2471      *          class loader of this class and invocation of
2472      *          {@link SecurityManager#checkPermission
2473      *          s.checkPermission} method with
2474      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2475      *          denies access to the declared methods within this class
2476      *
2477      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2478      *          ancestor of the class loader for the current class and
2479      *          invocation of {@link SecurityManager#checkPackageAccess
2480      *          s.checkPackageAccess()} denies access to the package
2481      *          of this class
2482      *
2483      *          &lt;/ul&gt;
2484      *
2485      * @jls 8.2 Class Members
2486      * @jls 8.4 Method Declarations
2487      * @since 1.1
2488      */
2489     @CallerSensitive
2490     public Method[] getDeclaredMethods() throws SecurityException {
2491         SecurityManager sm = System.getSecurityManager();
2492         if (sm != null) {
2493             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2494         }
2495         return copyMethods(privateGetDeclaredMethods(false));
2496     }
2497 
2498 
2499     /**
2500      * Returns an array of {@code Constructor} objects reflecting all the
2501      * constructors declared by the class represented by this
2502      * {@code Class} object. These are public, protected, default
2503      * (package) access, and private constructors.  The elements in the array
2504      * returned are not sorted and are not in any particular order.  If the
2505      * class has a default constructor, it is included in the returned array.
2506      * This method returns an array of length 0 if this {@code Class}
2507      * object represents an interface, a primitive type, an array class, or
2508      * void.
2509      *
<a name="13" id="anc13"></a><span class="line-modified">2510      * &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, section {@jls 8.2}.</span>

2511      *
2512      * @return  the array of {@code Constructor} objects representing all the
2513      *          declared constructors of this class
2514      * @throws  SecurityException
2515      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2516      *          following conditions is met:
2517      *
2518      *          &lt;ul&gt;
2519      *
2520      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2521      *          class loader of this class and invocation of
2522      *          {@link SecurityManager#checkPermission
2523      *          s.checkPermission} method with
2524      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2525      *          denies access to the declared constructors within this class
2526      *
2527      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2528      *          ancestor of the class loader for the current class and
2529      *          invocation of {@link SecurityManager#checkPackageAccess
2530      *          s.checkPackageAccess()} denies access to the package
2531      *          of this class
2532      *
2533      *          &lt;/ul&gt;
2534      *
2535      * @since 1.1
2536      */
2537     @CallerSensitive
2538     public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException {
2539         SecurityManager sm = System.getSecurityManager();
2540         if (sm != null) {
2541             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2542         }
2543         return copyConstructors(privateGetDeclaredConstructors(false));
2544     }
2545 
2546 
2547     /**
2548      * Returns a {@code Field} object that reflects the specified declared
2549      * field of the class or interface represented by this {@code Class}
2550      * object. The {@code name} parameter is a {@code String} that specifies
2551      * the simple name of the desired field.
2552      *
2553      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2554      * method does not find the {@code length} field of the array type.
2555      *
2556      * @param name the name of the field
2557      * @return  the {@code Field} object for the specified field in this
2558      *          class
2559      * @throws  NoSuchFieldException if a field with the specified name is
2560      *          not found.
2561      * @throws  NullPointerException if {@code name} is {@code null}
2562      * @throws  SecurityException
2563      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2564      *          following conditions is met:
2565      *
2566      *          &lt;ul&gt;
2567      *
2568      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2569      *          class loader of this class and invocation of
2570      *          {@link SecurityManager#checkPermission
2571      *          s.checkPermission} method with
2572      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2573      *          denies access to the declared field
2574      *
2575      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2576      *          ancestor of the class loader for the current class and
2577      *          invocation of {@link SecurityManager#checkPackageAccess
2578      *          s.checkPackageAccess()} denies access to the package
2579      *          of this class
2580      *
2581      *          &lt;/ul&gt;
2582      *
2583      * @since 1.1
2584      * @jls 8.2 Class Members
2585      * @jls 8.3 Field Declarations
2586      */
2587     @CallerSensitive
2588     public Field getDeclaredField(String name)
2589         throws NoSuchFieldException, SecurityException {
2590         Objects.requireNonNull(name);
2591         SecurityManager sm = System.getSecurityManager();
2592         if (sm != null) {
2593             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2594         }
2595         Field field = searchFields(privateGetDeclaredFields(false), name);
2596         if (field == null) {
2597             throw new NoSuchFieldException(name);
2598         }
2599         return getReflectionFactory().copyField(field);
2600     }
2601 
2602 
2603     /**
2604      * Returns a {@code Method} object that reflects the specified
2605      * declared method of the class or interface represented by this
2606      * {@code Class} object. The {@code name} parameter is a
2607      * {@code String} that specifies the simple name of the desired
2608      * method, and the {@code parameterTypes} parameter is an array of
2609      * {@code Class} objects that identify the method&#39;s formal parameter
2610      * types, in declared order.  If more than one method with the same
2611      * parameter types is declared in a class, and one of these methods has a
2612      * return type that is more specific than any of the others, that method is
2613      * returned; otherwise one of the methods is chosen arbitrarily.  If the
2614      * name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot; a {@code NoSuchMethodException}
2615      * is raised.
2616      *
2617      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2618      * method does not find the {@code clone()} method.
2619      *
2620      * @param name the name of the method
2621      * @param parameterTypes the parameter array
2622      * @return  the {@code Method} object for the method of this class
2623      *          matching the specified name and parameters
2624      * @throws  NoSuchMethodException if a matching method is not found.
2625      * @throws  NullPointerException if {@code name} is {@code null}
2626      * @throws  SecurityException
2627      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2628      *          following conditions is met:
2629      *
2630      *          &lt;ul&gt;
2631      *
2632      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2633      *          class loader of this class and invocation of
2634      *          {@link SecurityManager#checkPermission
2635      *          s.checkPermission} method with
2636      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2637      *          denies access to the declared method
2638      *
2639      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2640      *          ancestor of the class loader for the current class and
2641      *          invocation of {@link SecurityManager#checkPackageAccess
2642      *          s.checkPackageAccess()} denies access to the package
2643      *          of this class
2644      *
2645      *          &lt;/ul&gt;
2646      *
2647      * @jls 8.2 Class Members
2648      * @jls 8.4 Method Declarations
2649      * @since 1.1
2650      */
2651     @CallerSensitive
2652     public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)
2653         throws NoSuchMethodException, SecurityException {
2654         Objects.requireNonNull(name);
2655         SecurityManager sm = System.getSecurityManager();
2656         if (sm != null) {
2657             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2658         }
2659         Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);
2660         if (method == null) {
2661             throw new NoSuchMethodException(methodToString(name, parameterTypes));
2662         }
2663         return getReflectionFactory().copyMethod(method);
2664     }
2665 
2666     /**
2667      * Returns the list of {@code Method} objects for the declared public
2668      * methods of this class or interface that have the specified method name
2669      * and parameter types.
2670      *
2671      * @param name the name of the method
2672      * @param parameterTypes the parameter array
2673      * @return the list of {@code Method} objects for the public methods of
2674      *         this class matching the specified name and parameters
2675      */
2676     List&lt;Method&gt; getDeclaredPublicMethods(String name, Class&lt;?&gt;... parameterTypes) {
2677         Method[] methods = privateGetDeclaredMethods(/* publicOnly */ true);
2678         ReflectionFactory factory = getReflectionFactory();
2679         List&lt;Method&gt; result = new ArrayList&lt;&gt;();
2680         for (Method method : methods) {
2681             if (method.getName().equals(name)
2682                 &amp;&amp; Arrays.equals(
2683                     factory.getExecutableSharedParameterTypes(method),
2684                     parameterTypes)) {
2685                 result.add(factory.copyMethod(method));
2686             }
2687         }
2688         return result;
2689     }
2690 
2691     /**
2692      * Returns a {@code Constructor} object that reflects the specified
2693      * constructor of the class or interface represented by this
2694      * {@code Class} object.  The {@code parameterTypes} parameter is
2695      * an array of {@code Class} objects that identify the constructor&#39;s
2696      * formal parameter types, in declared order.
2697      *
2698      * If this {@code Class} object represents an inner class
2699      * declared in a non-static context, the formal parameter types
2700      * include the explicit enclosing instance as the first parameter.
2701      *
2702      * @param parameterTypes the parameter array
2703      * @return  The {@code Constructor} object for the constructor with the
2704      *          specified parameter list
2705      * @throws  NoSuchMethodException if a matching method is not found.
2706      * @throws  SecurityException
2707      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2708      *          following conditions is met:
2709      *
2710      *          &lt;ul&gt;
2711      *
2712      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2713      *          class loader of this class and invocation of
2714      *          {@link SecurityManager#checkPermission
2715      *          s.checkPermission} method with
2716      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2717      *          denies access to the declared constructor
2718      *
2719      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2720      *          ancestor of the class loader for the current class and
2721      *          invocation of {@link SecurityManager#checkPackageAccess
2722      *          s.checkPackageAccess()} denies access to the package
2723      *          of this class
2724      *
2725      *          &lt;/ul&gt;
2726      *
2727      * @since 1.1
2728      */
2729     @CallerSensitive
2730     public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)
2731         throws NoSuchMethodException, SecurityException
2732     {
2733         SecurityManager sm = System.getSecurityManager();
2734         if (sm != null) {
2735             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2736         }
2737 
2738         return getReflectionFactory().copyConstructor(
2739             getConstructor0(parameterTypes, Member.DECLARED));
2740     }
2741 
2742     /**
2743      * Finds a resource with a given name.
2744      *
2745      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2746      * will attempt to find the resource in the module. This is done by
2747      * delegating to the module&#39;s class loader {@link
2748      * ClassLoader#findResource(String,String) findResource(String,String)}
2749      * method, invoking it with the module name and the absolute name of the
2750      * resource. Resources in named modules are subject to the rules for
2751      * encapsulation specified in the {@code Module} {@link
2752      * Module#getResourceAsStream getResourceAsStream} method and so this
2753      * method returns {@code null} when the resource is a
2754      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2755      * caller&#39;s module.
2756      *
2757      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2758      * searching resources associated with a given class are implemented by the
2759      * defining {@linkplain ClassLoader class loader} of the class.  This method
2760      * delegates to this object&#39;s class loader.  If this object was loaded by
2761      * the bootstrap class loader, the method delegates to {@link
2762      * ClassLoader#getSystemResourceAsStream}.
2763      *
2764      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2765      * given resource name using this algorithm:
2766      *
2767      * &lt;ul&gt;
2768      *
2769      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2770      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2771      * portion of the {@code name} following the {@code &#39;/&#39;}.
2772      *
2773      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2774      *
2775      * &lt;blockquote&gt;
2776      *   {@code modified_package_name/name}
2777      * &lt;/blockquote&gt;
2778      *
2779      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2780      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2781      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2782      *
2783      * &lt;/ul&gt;
2784      *
2785      * @param  name name of the desired resource
2786      * @return  A {@link java.io.InputStream} object; {@code null} if no
2787      *          resource with this name is found, the resource is in a package
2788      *          that is not {@linkplain Module#isOpen(String, Module) open} to at
2789      *          least the caller module, or access to the resource is denied
2790      *          by the security manager.
2791      * @throws  NullPointerException If {@code name} is {@code null}
2792      *
2793      * @see Module#getResourceAsStream(String)
2794      * @since  1.1
2795      * @revised 9
2796      * @spec JPMS
2797      */
2798     @CallerSensitive
2799     public InputStream getResourceAsStream(String name) {
2800         name = resolveName(name);
2801 
2802         Module thisModule = getModule();
2803         if (thisModule.isNamed()) {
2804             // check if resource can be located by caller
2805             if (Resources.canEncapsulate(name)
2806                 &amp;&amp; !isOpenToCaller(name, Reflection.getCallerClass())) {
2807                 return null;
2808             }
2809 
2810             // resource not encapsulated or in package open to caller
2811             String mn = thisModule.getName();
2812             ClassLoader cl = getClassLoader0();
2813             try {
2814 
2815                 // special-case built-in class loaders to avoid the
2816                 // need for a URL connection
2817                 if (cl == null) {
2818                     return BootLoader.findResourceAsStream(mn, name);
2819                 } else if (cl instanceof BuiltinClassLoader) {
2820                     return ((BuiltinClassLoader) cl).findResourceAsStream(mn, name);
2821                 } else {
2822                     URL url = cl.findResource(mn, name);
2823                     return (url != null) ? url.openStream() : null;
2824                 }
2825 
2826             } catch (IOException | SecurityException e) {
2827                 return null;
2828             }
2829         }
2830 
2831         // unnamed module
2832         ClassLoader cl = getClassLoader0();
2833         if (cl == null) {
2834             return ClassLoader.getSystemResourceAsStream(name);
2835         } else {
2836             return cl.getResourceAsStream(name);
2837         }
2838     }
2839 
2840     /**
2841      * Finds a resource with a given name.
2842      *
2843      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2844      * will attempt to find the resource in the module. This is done by
2845      * delegating to the module&#39;s class loader {@link
2846      * ClassLoader#findResource(String,String) findResource(String,String)}
2847      * method, invoking it with the module name and the absolute name of the
2848      * resource. Resources in named modules are subject to the rules for
2849      * encapsulation specified in the {@code Module} {@link
2850      * Module#getResourceAsStream getResourceAsStream} method and so this
2851      * method returns {@code null} when the resource is a
2852      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2853      * caller&#39;s module.
2854      *
2855      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2856      * searching resources associated with a given class are implemented by the
2857      * defining {@linkplain ClassLoader class loader} of the class.  This method
2858      * delegates to this object&#39;s class loader. If this object was loaded by
2859      * the bootstrap class loader, the method delegates to {@link
2860      * ClassLoader#getSystemResource}.
2861      *
2862      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2863      * given resource name using this algorithm:
2864      *
2865      * &lt;ul&gt;
2866      *
2867      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2868      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2869      * portion of the {@code name} following the {@code &#39;/&#39;}.
2870      *
2871      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2872      *
2873      * &lt;blockquote&gt;
2874      *   {@code modified_package_name/name}
2875      * &lt;/blockquote&gt;
2876      *
2877      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2878      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2879      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2880      *
2881      * &lt;/ul&gt;
2882      *
2883      * @param  name name of the desired resource
2884      * @return A {@link java.net.URL} object; {@code null} if no resource with
2885      *         this name is found, the resource cannot be located by a URL, the
2886      *         resource is in a package that is not
2887      *         {@linkplain Module#isOpen(String, Module) open} to at least the caller
2888      *         module, or access to the resource is denied by the security
2889      *         manager.
2890      * @throws NullPointerException If {@code name} is {@code null}
2891      * @since  1.1
2892      * @revised 9
2893      * @spec JPMS
2894      */
2895     @CallerSensitive
2896     public URL getResource(String name) {
2897         name = resolveName(name);
2898 
2899         Module thisModule = getModule();
2900         if (thisModule.isNamed()) {
2901             // check if resource can be located by caller
2902             if (Resources.canEncapsulate(name)
2903                 &amp;&amp; !isOpenToCaller(name, Reflection.getCallerClass())) {
2904                 return null;
2905             }
2906 
2907             // resource not encapsulated or in package open to caller
2908             String mn = thisModule.getName();
2909             ClassLoader cl = getClassLoader0();
2910             try {
2911                 if (cl == null) {
2912                     return BootLoader.findResource(mn, name);
2913                 } else {
2914                     return cl.findResource(mn, name);
2915                 }
2916             } catch (IOException ioe) {
2917                 return null;
2918             }
2919         }
2920 
2921         // unnamed module
2922         ClassLoader cl = getClassLoader0();
2923         if (cl == null) {
2924             return ClassLoader.getSystemResource(name);
2925         } else {
2926             return cl.getResource(name);
2927         }
2928     }
2929 
2930     /**
2931      * Returns true if a resource with the given name can be located by the
2932      * given caller. All resources in a module can be located by code in
2933      * the module. For other callers, then the package needs to be open to
2934      * the caller.
2935      */
2936     private boolean isOpenToCaller(String name, Class&lt;?&gt; caller) {
2937         // assert getModule().isNamed();
2938         Module thisModule = getModule();
2939         Module callerModule = (caller != null) ? caller.getModule() : null;
2940         if (callerModule != thisModule) {
2941             String pn = Resources.toPackageName(name);
2942             if (thisModule.getDescriptor().packages().contains(pn)) {
2943                 if (callerModule == null &amp;&amp; !thisModule.isOpen(pn)) {
2944                     // no caller, package not open
2945                     return false;
2946                 }
2947                 if (!thisModule.isOpen(pn, callerModule)) {
2948                     // package not open to caller
2949                     return false;
2950                 }
2951             }
2952         }
2953         return true;
2954     }
2955 
2956 
2957     /** protection domain returned when the internal domain is null */
2958     private static java.security.ProtectionDomain allPermDomain;
2959 
2960     /**
2961      * Returns the {@code ProtectionDomain} of this class.  If there is a
2962      * security manager installed, this method first calls the security
2963      * manager&#39;s {@code checkPermission} method with a
2964      * {@code RuntimePermission(&quot;getProtectionDomain&quot;)} permission to
2965      * ensure it&#39;s ok to get the
2966      * {@code ProtectionDomain}.
2967      *
2968      * @return the ProtectionDomain of this class
2969      *
2970      * @throws SecurityException
2971      *        if a security manager exists and its
2972      *        {@code checkPermission} method doesn&#39;t allow
2973      *        getting the ProtectionDomain.
2974      *
2975      * @see java.security.ProtectionDomain
2976      * @see SecurityManager#checkPermission
2977      * @see java.lang.RuntimePermission
2978      * @since 1.2
2979      */
2980     public java.security.ProtectionDomain getProtectionDomain() {
2981         SecurityManager sm = System.getSecurityManager();
2982         if (sm != null) {
2983             sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);
2984         }
2985         java.security.ProtectionDomain pd = getProtectionDomain0();
2986         if (pd == null) {
2987             if (allPermDomain == null) {
2988                 java.security.Permissions perms =
2989                     new java.security.Permissions();
2990                 perms.add(SecurityConstants.ALL_PERMISSION);
2991                 allPermDomain =
2992                     new java.security.ProtectionDomain(null, perms);
2993             }
2994             pd = allPermDomain;
2995         }
2996         return pd;
2997     }
2998 
2999 
3000     /**
3001      * Returns the ProtectionDomain of this class.
3002      */
3003     private native java.security.ProtectionDomain getProtectionDomain0();
3004 
3005     /*
3006      * Return the Virtual Machine&#39;s Class object for the named
3007      * primitive type.
3008      */
3009     static native Class&lt;?&gt; getPrimitiveClass(String name);
3010 
3011     /*
3012      * Check if client is allowed to access members.  If access is denied,
3013      * throw a SecurityException.
3014      *
3015      * This method also enforces package access.
3016      *
3017      * &lt;p&gt; Default policy: allow all clients access with normal Java access
3018      * control.
3019      *
3020      * &lt;p&gt; NOTE: should only be called if a SecurityManager is installed
3021      */
3022     private void checkMemberAccess(SecurityManager sm, int which,
3023                                    Class&lt;?&gt; caller, boolean checkProxyInterfaces) {
3024         /* Default policy allows access to all {@link Member#PUBLIC} members,
3025          * as well as access to classes that have the same class loader as the caller.
3026          * In all other cases, it requires RuntimePermission(&quot;accessDeclaredMembers&quot;)
3027          * permission.
3028          */
3029         final ClassLoader ccl = ClassLoader.getClassLoader(caller);
3030         if (which != Member.PUBLIC) {
3031             final ClassLoader cl = getClassLoader0();
3032             if (ccl != cl) {
3033                 sm.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3034             }
3035         }
3036         this.checkPackageAccess(sm, ccl, checkProxyInterfaces);
3037     }
3038 
3039     /*
3040      * Checks if a client loaded in ClassLoader ccl is allowed to access this
3041      * class under the current package access policy. If access is denied,
3042      * throw a SecurityException.
3043      *
3044      * NOTE: this method should only be called if a SecurityManager is active
3045      */
3046     private void checkPackageAccess(SecurityManager sm, final ClassLoader ccl,
3047                                     boolean checkProxyInterfaces) {
3048         final ClassLoader cl = getClassLoader0();
3049 
3050         if (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {
3051             String pkg = this.getPackageName();
3052             if (pkg != null &amp;&amp; !pkg.isEmpty()) {
3053                 // skip the package access check on a proxy class in default proxy package
3054                 if (!Proxy.isProxyClass(this) || ReflectUtil.isNonPublicProxyClass(this)) {
3055                     sm.checkPackageAccess(pkg);
3056                 }
3057             }
3058         }
3059         // check package access on the proxy interfaces
3060         if (checkProxyInterfaces &amp;&amp; Proxy.isProxyClass(this)) {
3061             ReflectUtil.checkProxyPackageAccess(ccl, this.getInterfaces());
3062         }
3063     }
3064 
3065     /**
3066      * Add a package name prefix if the name is not absolute Remove leading &quot;/&quot;
3067      * if name is absolute
3068      */
3069     private String resolveName(String name) {
3070         if (!name.startsWith(&quot;/&quot;)) {
3071             Class&lt;?&gt; c = this;
3072             while (c.isArray()) {
3073                 c = c.getComponentType();
3074             }
3075             String baseName = c.getPackageName();
3076             if (baseName != null &amp;&amp; !baseName.isEmpty()) {
3077                 name = baseName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; + name;
3078             }
3079         } else {
3080             name = name.substring(1);
3081         }
3082         return name;
3083     }
3084 
3085     /**
3086      * Atomic operations support.
3087      */
3088     private static class Atomic {
3089         // initialize Unsafe machinery here, since we need to call Class.class instance method
3090         // and have to avoid calling it in the static initializer of the Class class...
3091         private static final Unsafe unsafe = Unsafe.getUnsafe();
3092         // offset of Class.reflectionData instance field
3093         private static final long reflectionDataOffset
3094                 = unsafe.objectFieldOffset(Class.class, &quot;reflectionData&quot;);
3095         // offset of Class.annotationType instance field
3096         private static final long annotationTypeOffset
3097                 = unsafe.objectFieldOffset(Class.class, &quot;annotationType&quot;);
3098         // offset of Class.annotationData instance field
3099         private static final long annotationDataOffset
3100                 = unsafe.objectFieldOffset(Class.class, &quot;annotationData&quot;);
3101 
3102         static &lt;T&gt; boolean casReflectionData(Class&lt;?&gt; clazz,
3103                                              SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldData,
3104                                              SoftReference&lt;ReflectionData&lt;T&gt;&gt; newData) {
3105             return unsafe.compareAndSetReference(clazz, reflectionDataOffset, oldData, newData);
3106         }
3107 
3108         static &lt;T&gt; boolean casAnnotationType(Class&lt;?&gt; clazz,
3109                                              AnnotationType oldType,
3110                                              AnnotationType newType) {
3111             return unsafe.compareAndSetReference(clazz, annotationTypeOffset, oldType, newType);
3112         }
3113 
3114         static &lt;T&gt; boolean casAnnotationData(Class&lt;?&gt; clazz,
3115                                              AnnotationData oldData,
3116                                              AnnotationData newData) {
3117             return unsafe.compareAndSetReference(clazz, annotationDataOffset, oldData, newData);
3118         }
3119     }
3120 
3121     /**
3122      * Reflection support.
3123      */
3124 
3125     // Reflection data caches various derived names and reflective members. Cached
3126     // values may be invalidated when JVM TI RedefineClasses() is called
3127     private static class ReflectionData&lt;T&gt; {
3128         volatile Field[] declaredFields;
3129         volatile Field[] publicFields;
3130         volatile Method[] declaredMethods;
3131         volatile Method[] publicMethods;
3132         volatile Constructor&lt;T&gt;[] declaredConstructors;
3133         volatile Constructor&lt;T&gt;[] publicConstructors;
3134         // Intermediate results for getFields and getMethods
3135         volatile Field[] declaredPublicFields;
3136         volatile Method[] declaredPublicMethods;
3137         volatile Class&lt;?&gt;[] interfaces;
3138 
3139         // Cached names
3140         String simpleName;
3141         String canonicalName;
3142         static final String NULL_SENTINEL = new String();
3143 
3144         // Value of classRedefinedCount when we created this ReflectionData instance
3145         final int redefinedCount;
3146 
3147         ReflectionData(int redefinedCount) {
3148             this.redefinedCount = redefinedCount;
3149         }
3150     }
3151 
3152     private transient volatile SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData;
3153 
3154     // Incremented by the VM on each call to JVM TI RedefineClasses()
3155     // that redefines this class or a superclass.
3156     private transient volatile int classRedefinedCount;
3157 
3158     // Lazily create and cache ReflectionData
3159     private ReflectionData&lt;T&gt; reflectionData() {
3160         SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = this.reflectionData;
3161         int classRedefinedCount = this.classRedefinedCount;
3162         ReflectionData&lt;T&gt; rd;
3163         if (reflectionData != null &amp;&amp;
3164             (rd = reflectionData.get()) != null &amp;&amp;
3165             rd.redefinedCount == classRedefinedCount) {
3166             return rd;
3167         }
3168         // else no SoftReference or cleared SoftReference or stale ReflectionData
3169         // -&gt; create and replace new instance
3170         return newReflectionData(reflectionData, classRedefinedCount);
3171     }
3172 
3173     private ReflectionData&lt;T&gt; newReflectionData(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,
3174                                                 int classRedefinedCount) {
3175         while (true) {
3176             ReflectionData&lt;T&gt; rd = new ReflectionData&lt;&gt;(classRedefinedCount);
3177             // try to CAS it...
3178             if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference&lt;&gt;(rd))) {
3179                 return rd;
3180             }
3181             // else retry
3182             oldReflectionData = this.reflectionData;
3183             classRedefinedCount = this.classRedefinedCount;
3184             if (oldReflectionData != null &amp;&amp;
3185                 (rd = oldReflectionData.get()) != null &amp;&amp;
3186                 rd.redefinedCount == classRedefinedCount) {
3187                 return rd;
3188             }
3189         }
3190     }
3191 
3192     // Generic signature handling
3193     private native String getGenericSignature0();
3194 
3195     // Generic info repository; lazily initialized
3196     private transient volatile ClassRepository genericInfo;
3197 
3198     // accessor for factory
3199     private GenericsFactory getFactory() {
3200         // create scope and factory
3201         return CoreReflectionFactory.make(this, ClassScope.make(this));
3202     }
3203 
3204     // accessor for generic info repository;
3205     // generic info is lazily initialized
3206     private ClassRepository getGenericInfo() {
3207         ClassRepository genericInfo = this.genericInfo;
3208         if (genericInfo == null) {
3209             String signature = getGenericSignature0();
3210             if (signature == null) {
3211                 genericInfo = ClassRepository.NONE;
3212             } else {
3213                 genericInfo = ClassRepository.make(signature, getFactory());
3214             }
3215             this.genericInfo = genericInfo;
3216         }
3217         return (genericInfo != ClassRepository.NONE) ? genericInfo : null;
3218     }
3219 
3220     // Annotations handling
3221     native byte[] getRawAnnotations();
3222     // Since 1.8
3223     native byte[] getRawTypeAnnotations();
3224     static byte[] getExecutableTypeAnnotationBytes(Executable ex) {
3225         return getReflectionFactory().getExecutableTypeAnnotationBytes(ex);
3226     }
3227 
3228     native ConstantPool getConstantPool();
3229 
3230     //
3231     //
3232     // java.lang.reflect.Field handling
3233     //
3234     //
3235 
3236     // Returns an array of &quot;root&quot; fields. These Field objects must NOT
3237     // be propagated to the outside world, but must instead be copied
3238     // via ReflectionFactory.copyField.
3239     private Field[] privateGetDeclaredFields(boolean publicOnly) {
3240         Field[] res;
3241         ReflectionData&lt;T&gt; rd = reflectionData();
3242         if (rd != null) {
3243             res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;
3244             if (res != null) return res;
3245         }
3246         // No cached value available; request value from VM
3247         res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));
3248         if (rd != null) {
3249             if (publicOnly) {
3250                 rd.declaredPublicFields = res;
3251             } else {
3252                 rd.declaredFields = res;
3253             }
3254         }
3255         return res;
3256     }
3257 
3258     // Returns an array of &quot;root&quot; fields. These Field objects must NOT
3259     // be propagated to the outside world, but must instead be copied
3260     // via ReflectionFactory.copyField.
3261     private Field[] privateGetPublicFields() {
3262         Field[] res;
3263         ReflectionData&lt;T&gt; rd = reflectionData();
3264         if (rd != null) {
3265             res = rd.publicFields;
3266             if (res != null) return res;
3267         }
3268 
3269         // Use a linked hash set to ensure order is preserved and
3270         // fields from common super interfaces are not duplicated
3271         LinkedHashSet&lt;Field&gt; fields = new LinkedHashSet&lt;&gt;();
3272 
3273         // Local fields
3274         addAll(fields, privateGetDeclaredFields(true));
3275 
3276         // Direct superinterfaces, recursively
3277         for (Class&lt;?&gt; si : getInterfaces()) {
3278             addAll(fields, si.privateGetPublicFields());
3279         }
3280 
3281         // Direct superclass, recursively
3282         Class&lt;?&gt; sc = getSuperclass();
3283         if (sc != null) {
3284             addAll(fields, sc.privateGetPublicFields());
3285         }
3286 
3287         res = fields.toArray(new Field[0]);
3288         if (rd != null) {
3289             rd.publicFields = res;
3290         }
3291         return res;
3292     }
3293 
3294     private static void addAll(Collection&lt;Field&gt; c, Field[] o) {
3295         for (Field f : o) {
3296             c.add(f);
3297         }
3298     }
3299 
3300 
3301     //
3302     //
3303     // java.lang.reflect.Constructor handling
3304     //
3305     //
3306 
3307     // Returns an array of &quot;root&quot; constructors. These Constructor
3308     // objects must NOT be propagated to the outside world, but must
3309     // instead be copied via ReflectionFactory.copyConstructor.
3310     private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) {
3311         Constructor&lt;T&gt;[] res;
3312         ReflectionData&lt;T&gt; rd = reflectionData();
3313         if (rd != null) {
3314             res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;
3315             if (res != null) return res;
3316         }
3317         // No cached value available; request value from VM
3318         if (isInterface()) {
3319             @SuppressWarnings(&quot;unchecked&quot;)
3320             Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0];
3321             res = temporaryRes;
3322         } else {
3323             res = getDeclaredConstructors0(publicOnly);
3324         }
3325         if (rd != null) {
3326             if (publicOnly) {
3327                 rd.publicConstructors = res;
3328             } else {
3329                 rd.declaredConstructors = res;
3330             }
3331         }
3332         return res;
3333     }
3334 
3335     //
3336     //
3337     // java.lang.reflect.Method handling
3338     //
3339     //
3340 
3341     // Returns an array of &quot;root&quot; methods. These Method objects must NOT
3342     // be propagated to the outside world, but must instead be copied
3343     // via ReflectionFactory.copyMethod.
3344     private Method[] privateGetDeclaredMethods(boolean publicOnly) {
3345         Method[] res;
3346         ReflectionData&lt;T&gt; rd = reflectionData();
3347         if (rd != null) {
3348             res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;
3349             if (res != null) return res;
3350         }
3351         // No cached value available; request value from VM
3352         res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));
3353         if (rd != null) {
3354             if (publicOnly) {
3355                 rd.declaredPublicMethods = res;
3356             } else {
3357                 rd.declaredMethods = res;
3358             }
3359         }
3360         return res;
3361     }
3362 
3363     // Returns an array of &quot;root&quot; methods. These Method objects must NOT
3364     // be propagated to the outside world, but must instead be copied
3365     // via ReflectionFactory.copyMethod.
3366     private Method[] privateGetPublicMethods() {
3367         Method[] res;
3368         ReflectionData&lt;T&gt; rd = reflectionData();
3369         if (rd != null) {
3370             res = rd.publicMethods;
3371             if (res != null) return res;
3372         }
3373 
3374         // No cached value available; compute value recursively.
3375         // Start by fetching public declared methods...
3376         PublicMethods pms = new PublicMethods();
3377         for (Method m : privateGetDeclaredMethods(/* publicOnly */ true)) {
3378             pms.merge(m);
3379         }
3380         // ...then recur over superclass methods...
3381         Class&lt;?&gt; sc = getSuperclass();
3382         if (sc != null) {
3383             for (Method m : sc.privateGetPublicMethods()) {
3384                 pms.merge(m);
3385             }
3386         }
3387         // ...and finally over direct superinterfaces.
3388         for (Class&lt;?&gt; intf : getInterfaces(/* cloneArray */ false)) {
3389             for (Method m : intf.privateGetPublicMethods()) {
3390                 // static interface methods are not inherited
3391                 if (!Modifier.isStatic(m.getModifiers())) {
3392                     pms.merge(m);
3393                 }
3394             }
3395         }
3396 
3397         res = pms.toArray();
3398         if (rd != null) {
3399             rd.publicMethods = res;
3400         }
3401         return res;
3402     }
3403 
3404 
3405     //
3406     // Helpers for fetchers of one field, method, or constructor
3407     //
3408 
3409     // This method does not copy the returned Field object!
3410     private static Field searchFields(Field[] fields, String name) {
3411         for (Field field : fields) {
3412             if (field.getName().equals(name)) {
3413                 return field;
3414             }
3415         }
3416         return null;
3417     }
3418 
3419     // Returns a &quot;root&quot; Field object. This Field object must NOT
3420     // be propagated to the outside world, but must instead be copied
3421     // via ReflectionFactory.copyField.
3422     private Field getField0(String name) {
3423         // Note: the intent is that the search algorithm this routine
3424         // uses be equivalent to the ordering imposed by
3425         // privateGetPublicFields(). It fetches only the declared
3426         // public fields for each class, however, to reduce the number
3427         // of Field objects which have to be created for the common
3428         // case where the field being requested is declared in the
3429         // class which is being queried.
3430         Field res;
3431         // Search declared public fields
3432         if ((res = searchFields(privateGetDeclaredFields(true), name)) != null) {
3433             return res;
3434         }
3435         // Direct superinterfaces, recursively
3436         Class&lt;?&gt;[] interfaces = getInterfaces(/* cloneArray */ false);
3437         for (Class&lt;?&gt; c : interfaces) {
3438             if ((res = c.getField0(name)) != null) {
3439                 return res;
3440             }
3441         }
3442         // Direct superclass, recursively
3443         if (!isInterface()) {
3444             Class&lt;?&gt; c = getSuperclass();
3445             if (c != null) {
3446                 if ((res = c.getField0(name)) != null) {
3447                     return res;
3448                 }
3449             }
3450         }
3451         return null;
3452     }
3453 
3454     // This method does not copy the returned Method object!
3455     private static Method searchMethods(Method[] methods,
3456                                         String name,
3457                                         Class&lt;?&gt;[] parameterTypes)
3458     {
3459         ReflectionFactory fact = getReflectionFactory();
3460         Method res = null;
3461         for (Method m : methods) {
3462             if (m.getName().equals(name)
3463                 &amp;&amp; arrayContentsEq(parameterTypes,
3464                                    fact.getExecutableSharedParameterTypes(m))
3465                 &amp;&amp; (res == null
3466                     || (res.getReturnType() != m.getReturnType()
3467                         &amp;&amp; res.getReturnType().isAssignableFrom(m.getReturnType()))))
3468                 res = m;
3469         }
3470         return res;
3471     }
3472 
3473     private static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class&lt;?&gt;[0];
3474 
3475     // Returns a &quot;root&quot; Method object. This Method object must NOT
3476     // be propagated to the outside world, but must instead be copied
3477     // via ReflectionFactory.copyMethod.
3478     private Method getMethod0(String name, Class&lt;?&gt;[] parameterTypes) {
3479         PublicMethods.MethodList res = getMethodsRecursive(
3480             name,
3481             parameterTypes == null ? EMPTY_CLASS_ARRAY : parameterTypes,
3482             /* includeStatic */ true);
3483         return res == null ? null : res.getMostSpecific();
3484     }
3485 
3486     // Returns a list of &quot;root&quot; Method objects. These Method objects must NOT
3487     // be propagated to the outside world, but must instead be copied
3488     // via ReflectionFactory.copyMethod.
3489     private PublicMethods.MethodList getMethodsRecursive(String name,
3490                                                          Class&lt;?&gt;[] parameterTypes,
3491                                                          boolean includeStatic) {
3492         // 1st check declared public methods
3493         Method[] methods = privateGetDeclaredMethods(/* publicOnly */ true);
3494         PublicMethods.MethodList res = PublicMethods.MethodList
3495             .filter(methods, name, parameterTypes, includeStatic);
3496         // if there is at least one match among declared methods, we need not
3497         // search any further as such match surely overrides matching methods
3498         // declared in superclass(es) or interface(s).
3499         if (res != null) {
3500             return res;
3501         }
3502 
3503         // if there was no match among declared methods,
3504         // we must consult the superclass (if any) recursively...
3505         Class&lt;?&gt; sc = getSuperclass();
3506         if (sc != null) {
3507             res = sc.getMethodsRecursive(name, parameterTypes, includeStatic);
3508         }
3509 
3510         // ...and coalesce the superclass methods with methods obtained
3511         // from directly implemented interfaces excluding static methods...
3512         for (Class&lt;?&gt; intf : getInterfaces(/* cloneArray */ false)) {
3513             res = PublicMethods.MethodList.merge(
3514                 res, intf.getMethodsRecursive(name, parameterTypes,
3515                                               /* includeStatic */ false));
3516         }
3517 
3518         return res;
3519     }
3520 
3521     // Returns a &quot;root&quot; Constructor object. This Constructor object must NOT
3522     // be propagated to the outside world, but must instead be copied
3523     // via ReflectionFactory.copyConstructor.
3524     private Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes,
3525                                         int which) throws NoSuchMethodException
3526     {
3527         ReflectionFactory fact = getReflectionFactory();
3528         Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));
3529         for (Constructor&lt;T&gt; constructor : constructors) {
3530             if (arrayContentsEq(parameterTypes,
3531                                 fact.getExecutableSharedParameterTypes(constructor))) {
3532                 return constructor;
3533             }
3534         }
3535         throw new NoSuchMethodException(methodToString(&quot;&lt;init&gt;&quot;, parameterTypes));
3536     }
3537 
3538     //
3539     // Other helpers and base implementation
3540     //
3541 
3542     private static boolean arrayContentsEq(Object[] a1, Object[] a2) {
3543         if (a1 == null) {
3544             return a2 == null || a2.length == 0;
3545         }
3546 
3547         if (a2 == null) {
3548             return a1.length == 0;
3549         }
3550 
3551         if (a1.length != a2.length) {
3552             return false;
3553         }
3554 
3555         for (int i = 0; i &lt; a1.length; i++) {
3556             if (a1[i] != a2[i]) {
3557                 return false;
3558             }
3559         }
3560 
3561         return true;
3562     }
3563 
3564     private static Field[] copyFields(Field[] arg) {
3565         Field[] out = new Field[arg.length];
3566         ReflectionFactory fact = getReflectionFactory();
3567         for (int i = 0; i &lt; arg.length; i++) {
3568             out[i] = fact.copyField(arg[i]);
3569         }
3570         return out;
3571     }
3572 
3573     private static Method[] copyMethods(Method[] arg) {
3574         Method[] out = new Method[arg.length];
3575         ReflectionFactory fact = getReflectionFactory();
3576         for (int i = 0; i &lt; arg.length; i++) {
3577             out[i] = fact.copyMethod(arg[i]);
3578         }
3579         return out;
3580     }
3581 
3582     private static &lt;U&gt; Constructor&lt;U&gt;[] copyConstructors(Constructor&lt;U&gt;[] arg) {
3583         Constructor&lt;U&gt;[] out = arg.clone();
3584         ReflectionFactory fact = getReflectionFactory();
3585         for (int i = 0; i &lt; out.length; i++) {
3586             out[i] = fact.copyConstructor(out[i]);
3587         }
3588         return out;
3589     }
3590 
3591     private native Field[]       getDeclaredFields0(boolean publicOnly);
3592     private native Method[]      getDeclaredMethods0(boolean publicOnly);
3593     private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
3594     private native Class&lt;?&gt;[]   getDeclaredClasses0();
3595     @SuppressWarnings(&quot;preview&quot;)
3596     private native RecordComponent[] getRecordComponents0();
3597     private native boolean      isRecord0();
3598 
3599     /**
3600      * Helper method to get the method name from arguments.
3601      */
3602     private String methodToString(String name, Class&lt;?&gt;[] argTypes) {
3603         return getName() + &#39;.&#39; + name +
3604                 ((argTypes == null || argTypes.length == 0) ?
3605                 &quot;()&quot; :
3606                 Arrays.stream(argTypes)
3607                         .map(c -&gt; c == null ? &quot;null&quot; : c.toTypeName())
3608                         .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)));
3609     }
3610 
3611     /*
3612      * Returns the class name appended with &quot;?&quot; if it is the nullable projection
3613      * of an inline class.
3614      */
3615     private String toTypeName() {
3616         return isInlineClass() &amp;&amp; isIndirectType() ? getName() + &quot;?&quot; : getName();
3617     }
3618 
3619     /** use serialVersionUID from JDK 1.1 for interoperability */
3620     @java.io.Serial
3621     private static final long serialVersionUID = 3206093459760846163L;
3622 
3623 
3624     /**
3625      * Class Class is special cased within the Serialization Stream Protocol.
3626      *
3627      * A Class instance is written initially into an ObjectOutputStream in the
3628      * following format:
3629      * &lt;pre&gt;
3630      *      {@code TC_CLASS} ClassDescriptor
3631      *      A ClassDescriptor is a special cased serialization of
3632      *      a {@code java.io.ObjectStreamClass} instance.
3633      * &lt;/pre&gt;
3634      * A new handle is generated for the initial time the class descriptor
3635      * is written into the stream. Future references to the class descriptor
3636      * are written as references to the initial class descriptor instance.
3637      *
3638      * @see java.io.ObjectStreamClass
3639      */
3640     @java.io.Serial
3641     private static final ObjectStreamField[] serialPersistentFields =
3642         new ObjectStreamField[0];
3643 
3644 
3645     /**
3646      * Returns the assertion status that would be assigned to this
3647      * class if it were to be initialized at the time this method is invoked.
3648      * If this class has had its assertion status set, the most recent
3649      * setting will be returned; otherwise, if any package default assertion
3650      * status pertains to this class, the most recent setting for the most
3651      * specific pertinent package default assertion status is returned;
3652      * otherwise, if this class is not a system class (i.e., it has a
3653      * class loader) its class loader&#39;s default assertion status is returned;
3654      * otherwise, the system class default assertion status is returned.
<a name="14" id="anc14"></a><span class="line-modified">3655      * &lt;p&gt;</span>

3656      * Few programmers will have any need for this method; it is provided
<a name="15" id="anc15"></a><span class="line-modified">3657      * for the benefit of the JRE itself.  (It allows a class to determine at</span>
3658      * the time that it is initialized whether assertions should be enabled.)
3659      * Note that this method is not guaranteed to return the actual
3660      * assertion status that was (or will be) associated with the specified
3661      * class when it was (or will be) initialized.
3662      *
3663      * @return the desired assertion status of the specified class.
3664      * @see    java.lang.ClassLoader#setClassAssertionStatus
3665      * @see    java.lang.ClassLoader#setPackageAssertionStatus
3666      * @see    java.lang.ClassLoader#setDefaultAssertionStatus
3667      * @since  1.4
3668      */
3669     public boolean desiredAssertionStatus() {
3670         ClassLoader loader = getClassLoader0();
3671         // If the loader is null this is a system class, so ask the VM
3672         if (loader == null)
3673             return desiredAssertionStatus0(this);
3674 
3675         // If the classloader has been initialized with the assertion
3676         // directives, ask it. Otherwise, ask the VM.
3677         synchronized(loader.assertionLock) {
3678             if (loader.classAssertionStatus != null) {
3679                 return loader.desiredAssertionStatus(getName());
3680             }
3681         }
3682         return desiredAssertionStatus0(this);
3683     }
3684 
3685     // Retrieves the desired assertion status of this class from the VM
3686     private static native boolean desiredAssertionStatus0(Class&lt;?&gt; clazz);
3687 
3688     /**
3689      * Returns true if and only if this class was declared as an enum in the
3690      * source code.
3691      *
3692      * Note that {@link java.lang.Enum} is not itself an enum type.
3693      *
3694      * Also note that if an enum constant is declared with a class body,
3695      * the class of that enum constant object is an anonymous class
3696      * and &lt;em&gt;not&lt;/em&gt; the class of the declaring enum type. The
3697      * {@link Enum#getDeclaringClass} method of an enum constant can
3698      * be used to get the class of the enum type declaring the
3699      * constant.
3700      *
3701      * @return true if and only if this class was declared as an enum in the
3702      *     source code
3703      * @since 1.5
3704      * @jls 8.9.1 Enum Constants
3705      */
3706     public boolean isEnum() {
3707         // An enum must both directly extend java.lang.Enum and have
3708         // the ENUM bit set; classes for specialized enum constants
3709         // don&#39;t do the former.
3710         return (this.getModifiers() &amp; ENUM) != 0 &amp;&amp;
3711         this.getSuperclass() == java.lang.Enum.class;
3712     }
3713 
3714     /** java.lang.Record.class */
3715     private static final Class&lt;?&gt; JAVA_LANG_RECORD_CLASS = javaLangRecordClass();
3716     private static Class&lt;?&gt; javaLangRecordClass() {
3717         try {
3718             return Class.forName0(&quot;java.lang.Record&quot;, false, null, null);
3719         } catch (ClassNotFoundException e) {
3720             throw new InternalError(&quot;should not reach here&quot;, e);
3721         }
3722     }
3723 
3724     /**
3725      * {@preview Associated with records, a preview feature of the Java language.
3726      *
3727      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview
3728      *           feature of the Java language. Preview features
3729      *           may be removed in a future release, or upgraded to permanent
3730      *           features of the Java language.}
3731      *
3732      * Returns {@code true} if and only if this class is a record class.
3733      *
3734      * &lt;p&gt; The {@linkplain #getSuperclass() direct superclass} of a record
3735      * class is {@code java.lang.Record}. A record class has (possibly zero)
3736      * record components, that is, {@link #getRecordComponents()} returns a
3737      * non-null value.
3738      *
3739      * &lt;p&gt; Note that class {@link Record} is not a record type and thus invoking
3740      * this method on class {@code Record} returns {@code false}.
3741      *
3742      * @return true if and only if this class is a record class, otherwise false
3743      * @jls 8.10 Record Types
3744      * @since 14
3745      */
3746     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
3747                                  essentialAPI=false)
3748     public boolean isRecord() {
3749         return getSuperclass() == JAVA_LANG_RECORD_CLASS &amp;&amp; isRecord0();
3750     }
3751 
3752     // Fetches the factory for reflective objects
3753     private static ReflectionFactory getReflectionFactory() {
3754         if (reflectionFactory == null) {
3755             reflectionFactory =
3756                 java.security.AccessController.doPrivileged
3757                     (new ReflectionFactory.GetReflectionFactoryAction());
3758         }
3759         return reflectionFactory;
3760     }
3761     private static ReflectionFactory reflectionFactory;
3762 
3763     /**
3764      * Returns the elements of this enum class or null if this
3765      * Class object does not represent an enum type.
3766      *
3767      * @return an array containing the values comprising the enum class
3768      *     represented by this Class object in the order they&#39;re
3769      *     declared, or null if this Class object does not
3770      *     represent an enum type
3771      * @since 1.5
3772      */
3773     public T[] getEnumConstants() {
3774         T[] values = getEnumConstantsShared();
3775         return (values != null) ? values.clone() : null;
3776     }
3777 
3778     /**
3779      * Returns the elements of this enum class or null if this
3780      * Class object does not represent an enum type;
3781      * identical to getEnumConstants except that the result is
3782      * uncloned, cached, and shared by all callers.
3783      */
3784     T[] getEnumConstantsShared() {
3785         T[] constants = enumConstants;
3786         if (constants == null) {
3787             if (!isEnum()) return null;
3788             try {
3789                 final Method values = getMethod(&quot;values&quot;);
3790                 java.security.AccessController.doPrivileged(
3791                     new java.security.PrivilegedAction&lt;&gt;() {
3792                         public Void run() {
3793                                 values.setAccessible(true);
3794                                 return null;
3795                             }
3796                         });
3797                 @SuppressWarnings(&quot;unchecked&quot;)
3798                 T[] temporaryConstants = (T[])values.invoke(null);
3799                 enumConstants = constants = temporaryConstants;
3800             }
3801             // These can happen when users concoct enum-like classes
3802             // that don&#39;t comply with the enum spec.
3803             catch (InvocationTargetException | NoSuchMethodException |
3804                    IllegalAccessException ex) { return null; }
3805         }
3806         return constants;
3807     }
3808     private transient volatile T[] enumConstants;
3809 
3810     /**
3811      * Returns a map from simple name to enum constant.  This package-private
3812      * method is used internally by Enum to implement
3813      * {@code public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt;, String)}
3814      * efficiently.  Note that the map is returned by this method is
3815      * created lazily on first use.  Typically it won&#39;t ever get created.
3816      */
3817     Map&lt;String, T&gt; enumConstantDirectory() {
3818         Map&lt;String, T&gt; directory = enumConstantDirectory;
3819         if (directory == null) {
3820             T[] universe = getEnumConstantsShared();
3821             if (universe == null)
3822                 throw new IllegalArgumentException(
3823                     getName() + &quot; is not an enum type&quot;);
3824             directory = new HashMap&lt;&gt;((int)(universe.length / 0.75f) + 1);
3825             for (T constant : universe) {
3826                 directory.put(((Enum&lt;?&gt;)constant).name(), constant);
3827             }
3828             enumConstantDirectory = directory;
3829         }
3830         return directory;
3831     }
3832     private transient volatile Map&lt;String, T&gt; enumConstantDirectory;
3833 
3834     /**
3835      * Casts an object to the class or interface represented
3836      * by this {@code Class} object.
3837      *
3838      * @param obj the object to be cast
3839      * @return the object after casting, or null if obj is null
3840      *
3841      * @throws ClassCastException if the object is not
3842      * {@code null} and is not assignable to the type T.
3843      * @throws NullPointerException if this is not a {@linkplain #isNullableType()
3844      * nullable type} and the object is {@code null}
3845      *
3846      * @since 1.5
3847      */
3848     @SuppressWarnings(&quot;unchecked&quot;)
3849     @HotSpotIntrinsicCandidate
3850     public T cast(Object obj) {
3851         if (!isNullableType() &amp;&amp; obj == null)
3852             throw new NullPointerException(getName() + &quot; is an inline class&quot;);
3853 
3854         if (obj != null &amp;&amp; !isInstance(obj))
3855             throw new ClassCastException(cannotCastMsg(obj));
3856         return (T) obj;
3857     }
3858 
3859     private String cannotCastMsg(Object obj) {
3860         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3861     }
3862 
3863     /**
3864      * Casts this {@code Class} object to represent a subclass of the class
3865      * represented by the specified class object.  Checks that the cast
3866      * is valid, and throws a {@code ClassCastException} if it is not.  If
3867      * this method succeeds, it always returns a reference to this class object.
3868      *
3869      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3870      * a {@code Class} object to pass it to an API that restricts the
3871      * {@code Class} objects that it is willing to accept.  A cast would
3872      * generate a compile-time warning, as the correctness of the cast
3873      * could not be checked at runtime (because generic types are implemented
3874      * by erasure).
3875      *
3876      * @param &lt;U&gt; the type to cast this class object to
3877      * @param clazz the class of the type to cast this class object to
3878      * @return this {@code Class} object, cast to represent a subclass of
3879      *    the specified class object.
3880      * @throws ClassCastException if this {@code Class} object does not
3881      *    represent a subclass of the specified class (here &quot;subclass&quot; includes
3882      *    the class itself).
3883      * @since 1.5
3884      */
3885     @SuppressWarnings(&quot;unchecked&quot;)
3886     public &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) {
3887         if (clazz.isAssignableFrom(this))
3888             return (Class&lt;? extends U&gt;) this;
3889         else
3890             throw new ClassCastException(this.toString());
3891     }
3892 
3893     /**
3894      * @throws NullPointerException {@inheritDoc}
3895      * @since 1.5
3896      */
3897     @SuppressWarnings(&quot;unchecked&quot;)
3898     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {
3899         Objects.requireNonNull(annotationClass);
3900 
3901         return (A) annotationData().annotations.get(annotationClass);
3902     }
3903 
3904     /**
3905      * {@inheritDoc}
3906      * @throws NullPointerException {@inheritDoc}
3907      * @since 1.5
3908      */
3909     @Override
3910     public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {
3911         return GenericDeclaration.super.isAnnotationPresent(annotationClass);
3912     }
3913 
3914     /**
3915      * @throws NullPointerException {@inheritDoc}
3916      * @since 1.8
3917      */
3918     @Override
3919     public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationClass) {
3920         Objects.requireNonNull(annotationClass);
3921 
3922         AnnotationData annotationData = annotationData();
3923         return AnnotationSupport.getAssociatedAnnotations(annotationData.declaredAnnotations,
3924                                                           this,
3925                                                           annotationClass);
3926     }
3927 
3928     /**
3929      * @since 1.5
3930      */
3931     public Annotation[] getAnnotations() {
3932         return AnnotationParser.toArray(annotationData().annotations);
3933     }
3934 
3935     /**
3936      * @throws NullPointerException {@inheritDoc}
3937      * @since 1.8
3938      */
3939     @Override
3940     @SuppressWarnings(&quot;unchecked&quot;)
3941     public &lt;A extends Annotation&gt; A getDeclaredAnnotation(Class&lt;A&gt; annotationClass) {
3942         Objects.requireNonNull(annotationClass);
3943 
3944         return (A) annotationData().declaredAnnotations.get(annotationClass);
3945     }
3946 
3947     /**
3948      * @throws NullPointerException {@inheritDoc}
3949      * @since 1.8
3950      */
3951     @Override
3952     public &lt;A extends Annotation&gt; A[] getDeclaredAnnotationsByType(Class&lt;A&gt; annotationClass) {
3953         Objects.requireNonNull(annotationClass);
3954 
3955         return AnnotationSupport.getDirectlyAndIndirectlyPresent(annotationData().declaredAnnotations,
3956                                                                  annotationClass);
3957     }
3958 
3959     /**
3960      * @since 1.5
3961      */
3962     public Annotation[] getDeclaredAnnotations()  {
3963         return AnnotationParser.toArray(annotationData().declaredAnnotations);
3964     }
3965 
3966     // annotation data that might get invalidated when JVM TI RedefineClasses() is called
3967     private static class AnnotationData {
3968         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;
3969         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;
3970 
3971         // Value of classRedefinedCount when we created this AnnotationData instance
3972         final int redefinedCount;
3973 
3974         AnnotationData(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations,
3975                        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations,
3976                        int redefinedCount) {
3977             this.annotations = annotations;
3978             this.declaredAnnotations = declaredAnnotations;
3979             this.redefinedCount = redefinedCount;
3980         }
3981     }
3982 
3983     // Annotations cache
3984     @SuppressWarnings(&quot;UnusedDeclaration&quot;)
3985     private transient volatile AnnotationData annotationData;
3986 
3987     private AnnotationData annotationData() {
3988         while (true) { // retry loop
3989             AnnotationData annotationData = this.annotationData;
3990             int classRedefinedCount = this.classRedefinedCount;
3991             if (annotationData != null &amp;&amp;
3992                 annotationData.redefinedCount == classRedefinedCount) {
3993                 return annotationData;
3994             }
3995             // null or stale annotationData -&gt; optimistically create new instance
3996             AnnotationData newAnnotationData = createAnnotationData(classRedefinedCount);
3997             // try to install it
3998             if (Atomic.casAnnotationData(this, annotationData, newAnnotationData)) {
3999                 // successfully installed new AnnotationData
4000                 return newAnnotationData;
4001             }
4002         }
4003     }
4004 
4005     private AnnotationData createAnnotationData(int classRedefinedCount) {
4006         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations =
4007             AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), this);
4008         Class&lt;?&gt; superClass = getSuperclass();
4009         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations = null;
4010         if (superClass != null) {
4011             Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; superAnnotations =
4012                 superClass.annotationData().annotations;
4013             for (Map.Entry&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; e : superAnnotations.entrySet()) {
4014                 Class&lt;? extends Annotation&gt; annotationClass = e.getKey();
4015                 if (AnnotationType.getInstance(annotationClass).isInherited()) {
4016                     if (annotations == null) { // lazy construction
4017                         annotations = new LinkedHashMap&lt;&gt;((Math.max(
4018                                 declaredAnnotations.size(),
4019                                 Math.min(12, declaredAnnotations.size() + superAnnotations.size())
4020                             ) * 4 + 2) / 3
4021                         );
4022                     }
4023                     annotations.put(annotationClass, e.getValue());
4024                 }
4025             }
4026         }
4027         if (annotations == null) {
4028             // no inherited annotations -&gt; share the Map with declaredAnnotations
4029             annotations = declaredAnnotations;
4030         } else {
4031             // at least one inherited annotation -&gt; declared may override inherited
4032             annotations.putAll(declaredAnnotations);
4033         }
4034         return new AnnotationData(annotations, declaredAnnotations, classRedefinedCount);
4035     }
4036 
4037     // Annotation types cache their internal (AnnotationType) form
4038 
4039     @SuppressWarnings(&quot;UnusedDeclaration&quot;)
4040     private transient volatile AnnotationType annotationType;
4041 
4042     boolean casAnnotationType(AnnotationType oldType, AnnotationType newType) {
4043         return Atomic.casAnnotationType(this, oldType, newType);
4044     }
4045 
4046     AnnotationType getAnnotationType() {
4047         return annotationType;
4048     }
4049 
4050     Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap() {
4051         return annotationData().declaredAnnotations;
4052     }
4053 
4054     /* Backing store of user-defined values pertaining to this class.
4055      * Maintained by the ClassValue class.
4056      */
4057     transient ClassValue.ClassValueMap classValueMap;
4058 
4059     /**
4060      * Returns an {@code AnnotatedType} object that represents the use of a
4061      * type to specify the superclass of the entity represented by this {@code
4062      * Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify the superclass
4063      * in &#39;...  extends Foo&#39; is distinct from the &lt;em&gt;declaration&lt;/em&gt; of type
4064      * Foo.)
4065      *
4066      * &lt;p&gt; If this {@code Class} object represents a type whose declaration
4067      * does not explicitly indicate an annotated superclass, then the return
4068      * value is an {@code AnnotatedType} object representing an element with no
4069      * annotations.
4070      *
4071      * &lt;p&gt; If this {@code Class} represents either the {@code Object} class, an
4072      * interface type, an array type, a primitive type, or void, the return
4073      * value is {@code null}.
4074      *
4075      * @return an object representing the superclass
4076      * @since 1.8
4077      */
4078     public AnnotatedType getAnnotatedSuperclass() {
4079         if (this == Object.class ||
4080                 isInterface() ||
4081                 isArray() ||
4082                 isPrimitive() ||
4083                 this == Void.TYPE) {
4084             return null;
4085         }
4086 
4087         return TypeAnnotationParser.buildAnnotatedSuperclass(getRawTypeAnnotations(), getConstantPool(), this);
4088     }
4089 
4090     /**
4091      * Returns an array of {@code AnnotatedType} objects that represent the use
4092      * of types to specify superinterfaces of the entity represented by this
4093      * {@code Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify a
4094      * superinterface in &#39;... implements Foo&#39; is distinct from the
4095      * &lt;em&gt;declaration&lt;/em&gt; of type Foo.)
4096      *
4097      * &lt;p&gt; If this {@code Class} object represents a class, the return value is
4098      * an array containing objects representing the uses of interface types to
4099      * specify interfaces implemented by the class. The order of the objects in
4100      * the array corresponds to the order of the interface types used in the
4101      * &#39;implements&#39; clause of the declaration of this {@code Class} object.
4102      *
4103      * &lt;p&gt; If this {@code Class} object represents an interface, the return
4104      * value is an array containing objects representing the uses of interface
4105      * types to specify interfaces directly extended by the interface. The
4106      * order of the objects in the array corresponds to the order of the
4107      * interface types used in the &#39;extends&#39; clause of the declaration of this
4108      * {@code Class} object.
4109      *
4110      * &lt;p&gt; If this {@code Class} object represents a class or interface whose
4111      * declaration does not explicitly indicate any annotated superinterfaces,
4112      * the return value is an array of length 0.
4113      *
4114      * &lt;p&gt; If this {@code Class} object represents either the {@code Object}
4115      * class, an array type, a primitive type, or void, the return value is an
4116      * array of length 0.
4117      *
4118      * @return an array representing the superinterfaces
4119      * @since 1.8
4120      */
4121     public AnnotatedType[] getAnnotatedInterfaces() {
4122         return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);
4123     }
4124 
4125     private native Class&lt;?&gt; getNestHost0();
4126 
4127     /**
4128      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4129      * or interface represented by this {@code Class} object belongs.
4130      * Every class and interface is a member of exactly one nest.
4131      * A class or interface that is not recorded as belonging to a nest
4132      * belongs to the nest consisting only of itself, and is the nest
4133      * host.
4134      *
4135      * &lt;p&gt;Each of the {@code Class} objects representing array types,
4136      * primitive types, and {@code void} returns {@code this} to indicate
4137      * that the represented entity belongs to the nest consisting only of
4138      * itself, and is the nest host.
4139      *
4140      * &lt;p&gt;If there is a {@linkplain LinkageError linkage error} accessing
4141      * the nest host, or if this class or interface is not enumerated as
4142      * a member of the nest by the nest host, then it is considered to belong
4143      * to its own nest and {@code this} is returned as the host.
4144      *
4145      * @apiNote A {@code class} file of version 55.0 or greater may record the
4146      * host of the nest to which it belongs by using the {@code NestHost}
<a name="16" id="anc16"></a><span class="line-modified">4147      * attribute (JVMS 4.7.28). Alternatively, a {@code class} file of</span>
4148      * version 55.0 or greater may act as a nest host by enumerating the nest&#39;s
4149      * other members with the
<a name="17" id="anc17"></a><span class="line-modified">4150      * {@code NestMembers} attribute (JVMS 4.7.29).</span>
4151      * A {@code class} file of version 54.0 or lower does not use these
4152      * attributes.
4153      *
4154      * @return the nest host of this class or interface
4155      *
4156      * @throws SecurityException
4157      *         If the returned class is not the current class, and
4158      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4159      *         class loader is not the same as or an ancestor of the class
4160      *         loader for the returned class and invocation of {@link
4161      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4162      *         denies access to the package of the returned class
4163      * @since 11
4164      * @jvms 4.7.28 The {@code NestHost} Attribute
4165      * @jvms 4.7.29 The {@code NestMembers} Attribute
4166      * @jvms 5.4.4 Access Control
4167      */
4168     @CallerSensitive
4169     public Class&lt;?&gt; getNestHost() {
4170         if (isPrimitive() || isArray()) {
4171             return this;
4172         }
4173         Class&lt;?&gt; host;
4174         try {
4175             host = getNestHost0();
4176         } catch (LinkageError e) {
4177             // if we couldn&#39;t load our nest-host then we
4178             // act as-if we have no nest-host attribute
4179             return this;
4180         }
4181         // if null then nest membership validation failed, so we
4182         // act as-if we have no nest-host attribute
4183         if (host == null || host == this) {
4184             return this;
4185         }
4186         // returning a different class requires a security check
4187         SecurityManager sm = System.getSecurityManager();
4188         if (sm != null) {
4189             checkPackageAccess(sm,
4190                                ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4191         }
4192         return host;
4193     }
4194 
4195     /**
4196      * Determines if the given {@code Class} is a nestmate of the
4197      * class or interface represented by this {@code Class} object.
4198      * Two classes or interfaces are nestmates
4199      * if they have the same {@linkplain #getNestHost() nest host}.
4200      *
4201      * @param c the class to check
4202      * @return {@code true} if this class and {@code c} are members of
4203      * the same nest; and {@code false} otherwise.
4204      *
4205      * @since 11
4206      */
4207     public boolean isNestmateOf(Class&lt;?&gt; c) {
4208         if (this == c) {
4209             return true;
4210         }
4211         if (isPrimitive() || isArray() ||
4212             c.isPrimitive() || c.isArray()) {
4213             return false;
4214         }
4215         try {
4216             return getNestHost0() == c.getNestHost0();
4217         } catch (LinkageError e) {
4218             return false;
4219         }
4220     }
4221 
4222     private native Class&lt;?&gt;[] getNestMembers0();
4223 
4224     /**
4225      * Returns an array containing {@code Class} objects representing all the
4226      * classes and interfaces that are members of the nest to which the class
4227      * or interface represented by this {@code Class} object belongs.
4228      * The {@linkplain #getNestHost() nest host} of that nest is the zeroth
4229      * element of the array. Subsequent elements represent any classes or
4230      * interfaces that are recorded by the nest host as being members of
4231      * the nest; the order of such elements is unspecified. Duplicates are
4232      * permitted.
4233      * If the nest host of that nest does not enumerate any members, then the
4234      * array has a single element containing {@code this}.
4235      *
4236      * &lt;p&gt;Each of the {@code Class} objects representing array types,
4237      * primitive types, and {@code void} returns an array containing only
4238      * {@code this}.
4239      *
4240      * &lt;p&gt;This method validates that, for each class or interface which is
4241      * recorded as a member of the nest by the nest host, that class or
4242      * interface records itself as a member of that same nest. Any exceptions
4243      * that occur during this validation are rethrown by this method.
4244      *
4245      * @return an array of all classes and interfaces in the same nest as
4246      * this class
4247      *
4248      * @throws LinkageError
4249      *         If there is any problem loading or validating a nest member or
4250      *         its nest host
4251      * @throws SecurityException
4252      *         If any returned class is not the current class, and
4253      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4254      *         class loader is not the same as or an ancestor of the class
4255      *         loader for that returned class and invocation of {@link
4256      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4257      *         denies access to the package of that returned class
4258      *
4259      * @since 11
4260      * @see #getNestHost()
4261      */
4262     @CallerSensitive
4263     public Class&lt;?&gt;[] getNestMembers() {
4264         if (isPrimitive() || isArray()) {
4265             return new Class&lt;?&gt;[] { this };
4266         }
4267         Class&lt;?&gt;[] members = getNestMembers0();
4268         // Can&#39;t actually enable this due to bootstrapping issues
4269         // assert(members.length != 1 || members[0] == this); // expected invariant from VM
4270 
4271         if (members.length &gt; 1) {
4272             // If we return anything other than the current class we need
4273             // a security check
4274             SecurityManager sm = System.getSecurityManager();
4275             if (sm != null) {
4276                 checkPackageAccess(sm,
4277                                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4278             }
4279         }
4280         return members;
4281     }
4282 
4283     /**
4284      * Returns the type descriptor string for this class.
4285      * &lt;p&gt;
4286      * Note that this is not a strict inverse of {@link #forName};
4287      * distinct classes which share a common name but have different class loaders
4288      * will have identical descriptor strings.
4289      *
4290      * @return the type descriptor representation
4291      * @jvms 4.3.2 Field Descriptors
4292      * @since 12
4293      */
4294     @Override
4295     public String descriptorString() {
4296         if (isPrimitive())
4297             return Wrapper.forPrimitiveType(this).basicTypeString();
4298         else if (isArray()) {
4299             return &quot;[&quot; + componentType.descriptorString();
4300         }
4301         else {
4302             return &quot;L&quot; + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;
4303         }
4304     }
4305 
4306     /**
4307      * Returns the component type of this {@code Class}, if it describes
4308      * an array type, or {@code null} otherwise.
4309      *
4310      * @implSpec
4311      * Equivalent to {@link Class#getComponentType()}.
4312      *
4313      * @return a {@code Class} describing the component type, or {@code null}
4314      * if this {@code Class} does not describe an array type
4315      * @since 12
4316      */
4317     @Override
4318     public Class&lt;?&gt; componentType() {
4319         return isArray() ? componentType : null;
4320     }
4321 
4322     /**
4323      * Returns a {@code Class} for an array type whose component type
4324      * is described by this {@linkplain Class}.
4325      *
4326      * @return a {@code Class} describing the array type
4327      * @since 12
4328      */
4329     @Override
4330     public Class&lt;?&gt; arrayType() {
4331         return Array.newInstance(this, 0).getClass();
4332     }
4333 
4334     /**
4335      * Returns a nominal descriptor for this instance, if one can be
4336      * constructed, or an empty {@link Optional} if one cannot be.
4337      *
4338      * @return An {@link Optional} containing the resulting nominal descriptor,
4339      * or an empty {@link Optional} if one cannot be constructed.
4340      * @since 12
4341      */
4342     @Override
4343     public Optional&lt;ClassDesc&gt; describeConstable() {
4344         return Optional.of(ClassDesc.ofDescriptor(descriptorString()));
4345     }
4346 }
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
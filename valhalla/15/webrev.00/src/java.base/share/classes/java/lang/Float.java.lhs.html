<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/Float.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.invoke.MethodHandles;
  29 import java.lang.constant.Constable;
  30 import java.lang.constant.ConstantDesc;
  31 import java.util.Optional;
  32 
  33 import jdk.internal.math.FloatingDecimal;
  34 import jdk.internal.HotSpotIntrinsicCandidate;
  35 
  36 /**
  37  * The {@code Float} class wraps a value of primitive type
  38  * {@code float} in an object. An object of type
  39  * {@code Float} contains a single field whose type is
  40  * {@code float}.
  41  *
  42  * &lt;p&gt;In addition, this class provides several methods for converting a
  43  * {@code float} to a {@code String} and a
  44  * {@code String} to a {@code float}, as well as other
  45  * constants and methods useful when dealing with a
  46  * {@code float}.
  47  *
  48  * @author  Lee Boynton
  49  * @author  Arthur van Hoff
  50  * @author  Joseph D. Darcy
  51  * @since 1.0
  52  */
  53 public final class Float extends Number
  54         implements Comparable&lt;Float&gt;, Constable, ConstantDesc {
  55     /**
  56      * A constant holding the positive infinity of type
  57      * {@code float}. It is equal to the value returned by
  58      * {@code Float.intBitsToFloat(0x7f800000)}.
  59      */
  60     public static final float POSITIVE_INFINITY = 1.0f / 0.0f;
  61 
  62     /**
  63      * A constant holding the negative infinity of type
  64      * {@code float}. It is equal to the value returned by
  65      * {@code Float.intBitsToFloat(0xff800000)}.
  66      */
  67     public static final float NEGATIVE_INFINITY = -1.0f / 0.0f;
  68 
  69     /**
  70      * A constant holding a Not-a-Number (NaN) value of type
  71      * {@code float}.  It is equivalent to the value returned by
  72      * {@code Float.intBitsToFloat(0x7fc00000)}.
  73      */
  74     public static final float NaN = 0.0f / 0.0f;
  75 
  76     /**
  77      * A constant holding the largest positive finite value of type
  78      * {@code float}, (2-2&lt;sup&gt;-23&lt;/sup&gt;)&amp;middot;2&lt;sup&gt;127&lt;/sup&gt;.
  79      * It is equal to the hexadecimal floating-point literal
  80      * {@code 0x1.fffffeP+127f} and also equal to
  81      * {@code Float.intBitsToFloat(0x7f7fffff)}.
  82      */
  83     public static final float MAX_VALUE = 0x1.fffffeP+127f; // 3.4028235e+38f
  84 
  85     /**
  86      * A constant holding the smallest positive normal value of type
  87      * {@code float}, 2&lt;sup&gt;-126&lt;/sup&gt;.  It is equal to the
  88      * hexadecimal floating-point literal {@code 0x1.0p-126f} and also
  89      * equal to {@code Float.intBitsToFloat(0x00800000)}.
  90      *
  91      * @since 1.6
  92      */
  93     public static final float MIN_NORMAL = 0x1.0p-126f; // 1.17549435E-38f
  94 
  95     /**
  96      * A constant holding the smallest positive nonzero value of type
  97      * {@code float}, 2&lt;sup&gt;-149&lt;/sup&gt;. It is equal to the
  98      * hexadecimal floating-point literal {@code 0x0.000002P-126f}
  99      * and also equal to {@code Float.intBitsToFloat(0x1)}.
 100      */
 101     public static final float MIN_VALUE = 0x0.000002P-126f; // 1.4e-45f
 102 
 103     /**
 104      * Maximum exponent a finite {@code float} variable may have.  It
 105      * is equal to the value returned by {@code
 106      * Math.getExponent(Float.MAX_VALUE)}.
 107      *
 108      * @since 1.6
 109      */
 110     public static final int MAX_EXPONENT = 127;
 111 
 112     /**
 113      * Minimum exponent a normalized {@code float} variable may have.
 114      * It is equal to the value returned by {@code
 115      * Math.getExponent(Float.MIN_NORMAL)}.
 116      *
 117      * @since 1.6
 118      */
 119     public static final int MIN_EXPONENT = -126;
 120 
 121     /**
 122      * The number of bits used to represent a {@code float} value.
 123      *
 124      * @since 1.5
 125      */
 126     public static final int SIZE = 32;
 127 
 128     /**
 129      * The number of bytes used to represent a {@code float} value.
 130      *
 131      * @since 1.8
 132      */
 133     public static final int BYTES = SIZE / Byte.SIZE;
 134 
 135     /**
 136      * The {@code Class} instance representing the primitive type
 137      * {@code float}.
 138      *
 139      * @since 1.1
 140      */
 141     @SuppressWarnings(&quot;unchecked&quot;)
 142     public static final Class&lt;Float&gt; TYPE = (Class&lt;Float&gt;) Class.getPrimitiveClass(&quot;float&quot;);
 143 
 144     /**
 145      * Returns a string representation of the {@code float}
 146      * argument. All characters mentioned below are ASCII characters.
 147      * &lt;ul&gt;
 148      * &lt;li&gt;If the argument is NaN, the result is the string
 149      * &quot;{@code NaN}&quot;.
 150      * &lt;li&gt;Otherwise, the result is a string that represents the sign and
 151      *     magnitude (absolute value) of the argument. If the sign is
 152      *     negative, the first character of the result is
 153      *     &#39;{@code -}&#39; ({@code &#39;\u005Cu002D&#39;}); if the sign is
 154      *     positive, no sign character appears in the result. As for
 155      *     the magnitude &lt;i&gt;m&lt;/i&gt;:
 156      * &lt;ul&gt;
 157      * &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is infinity, it is represented by the characters
 158      *     {@code &quot;Infinity&quot;}; thus, positive infinity produces
 159      *     the result {@code &quot;Infinity&quot;} and negative infinity
 160      *     produces the result {@code &quot;-Infinity&quot;}.
 161      * &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is zero, it is represented by the characters
 162      *     {@code &quot;0.0&quot;}; thus, negative zero produces the result
 163      *     {@code &quot;-0.0&quot;} and positive zero produces the result
 164      *     {@code &quot;0.0&quot;}.
 165      * &lt;li&gt; If &lt;i&gt;m&lt;/i&gt; is greater than or equal to 10&lt;sup&gt;-3&lt;/sup&gt; but
 166      *      less than 10&lt;sup&gt;7&lt;/sup&gt;, then it is represented as the
 167      *      integer part of &lt;i&gt;m&lt;/i&gt;, in decimal form with no leading
 168      *      zeroes, followed by &#39;{@code .}&#39;
 169      *      ({@code &#39;\u005Cu002E&#39;}), followed by one or more
 170      *      decimal digits representing the fractional part of
 171      *      &lt;i&gt;m&lt;/i&gt;.
 172      * &lt;li&gt; If &lt;i&gt;m&lt;/i&gt; is less than 10&lt;sup&gt;-3&lt;/sup&gt; or greater than or
 173      *      equal to 10&lt;sup&gt;7&lt;/sup&gt;, then it is represented in
 174      *      so-called &quot;computerized scientific notation.&quot; Let &lt;i&gt;n&lt;/i&gt;
 175      *      be the unique integer such that 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt; &lt;/sup&gt;&amp;le;
 176      *      &lt;i&gt;m&lt;/i&gt; {@literal &lt;} 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;+1&lt;/sup&gt;; then let &lt;i&gt;a&lt;/i&gt;
 177      *      be the mathematically exact quotient of &lt;i&gt;m&lt;/i&gt; and
 178      *      10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;&lt;/sup&gt; so that 1 &amp;le; &lt;i&gt;a&lt;/i&gt; {@literal &lt;} 10.
 179      *      The magnitude is then represented as the integer part of
 180      *      &lt;i&gt;a&lt;/i&gt;, as a single decimal digit, followed by
 181      *      &#39;{@code .}&#39; ({@code &#39;\u005Cu002E&#39;}), followed by
 182      *      decimal digits representing the fractional part of
 183      *      &lt;i&gt;a&lt;/i&gt;, followed by the letter &#39;{@code E}&#39;
 184      *      ({@code &#39;\u005Cu0045&#39;}), followed by a representation
 185      *      of &lt;i&gt;n&lt;/i&gt; as a decimal integer, as produced by the
 186      *      method {@link java.lang.Integer#toString(int)}.
 187      *
 188      * &lt;/ul&gt;
 189      * &lt;/ul&gt;
 190      * How many digits must be printed for the fractional part of
 191      * &lt;i&gt;m&lt;/i&gt; or &lt;i&gt;a&lt;/i&gt;? There must be at least one digit
 192      * to represent the fractional part, and beyond that as many, but
 193      * only as many, more digits as are needed to uniquely distinguish
 194      * the argument value from adjacent values of type
 195      * {@code float}. That is, suppose that &lt;i&gt;x&lt;/i&gt; is the
 196      * exact mathematical value represented by the decimal
 197      * representation produced by this method for a finite nonzero
 198      * argument &lt;i&gt;f&lt;/i&gt;. Then &lt;i&gt;f&lt;/i&gt; must be the {@code float}
 199      * value nearest to &lt;i&gt;x&lt;/i&gt;; or, if two {@code float} values are
 200      * equally close to &lt;i&gt;x&lt;/i&gt;, then &lt;i&gt;f&lt;/i&gt; must be one of
 201      * them and the least significant bit of the significand of
 202      * &lt;i&gt;f&lt;/i&gt; must be {@code 0}.
 203      *
 204      * &lt;p&gt;To create localized string representations of a floating-point
 205      * value, use subclasses of {@link java.text.NumberFormat}.
 206      *
 207      * @param   f   the float to be converted.
 208      * @return a string representation of the argument.
 209      */
 210     public static String toString(float f) {
 211         return FloatingDecimal.toJavaFormatString(f);
 212     }
 213 
 214     /**
 215      * Returns a hexadecimal string representation of the
 216      * {@code float} argument. All characters mentioned below are
 217      * ASCII characters.
 218      *
 219      * &lt;ul&gt;
 220      * &lt;li&gt;If the argument is NaN, the result is the string
 221      *     &quot;{@code NaN}&quot;.
 222      * &lt;li&gt;Otherwise, the result is a string that represents the sign and
 223      * magnitude (absolute value) of the argument. If the sign is negative,
 224      * the first character of the result is &#39;{@code -}&#39;
 225      * ({@code &#39;\u005Cu002D&#39;}); if the sign is positive, no sign character
 226      * appears in the result. As for the magnitude &lt;i&gt;m&lt;/i&gt;:
 227      *
 228      * &lt;ul&gt;
 229      * &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is infinity, it is represented by the string
 230      * {@code &quot;Infinity&quot;}; thus, positive infinity produces the
 231      * result {@code &quot;Infinity&quot;} and negative infinity produces
 232      * the result {@code &quot;-Infinity&quot;}.
 233      *
 234      * &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is zero, it is represented by the string
 235      * {@code &quot;0x0.0p0&quot;}; thus, negative zero produces the result
 236      * {@code &quot;-0x0.0p0&quot;} and positive zero produces the result
 237      * {@code &quot;0x0.0p0&quot;}.
 238      *
 239      * &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is a {@code float} value with a
 240      * normalized representation, substrings are used to represent the
 241      * significand and exponent fields.  The significand is
 242      * represented by the characters {@code &quot;0x1.&quot;}
 243      * followed by a lowercase hexadecimal representation of the rest
 244      * of the significand as a fraction.  Trailing zeros in the
 245      * hexadecimal representation are removed unless all the digits
 246      * are zero, in which case a single zero is used. Next, the
 247      * exponent is represented by {@code &quot;p&quot;} followed
 248      * by a decimal string of the unbiased exponent as if produced by
 249      * a call to {@link Integer#toString(int) Integer.toString} on the
 250      * exponent value.
 251      *
 252      * &lt;li&gt;If &lt;i&gt;m&lt;/i&gt; is a {@code float} value with a subnormal
 253      * representation, the significand is represented by the
 254      * characters {@code &quot;0x0.&quot;} followed by a
 255      * hexadecimal representation of the rest of the significand as a
 256      * fraction.  Trailing zeros in the hexadecimal representation are
 257      * removed. Next, the exponent is represented by
 258      * {@code &quot;p-126&quot;}.  Note that there must be at
 259      * least one nonzero digit in a subnormal significand.
 260      *
 261      * &lt;/ul&gt;
 262      *
 263      * &lt;/ul&gt;
 264      *
 265      * &lt;table class=&quot;striped&quot;&gt;
 266      * &lt;caption&gt;Examples&lt;/caption&gt;
 267      * &lt;thead&gt;
 268      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Floating-point Value&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Hexadecimal String&lt;/th&gt;
 269      * &lt;/thead&gt;
 270      * &lt;tbody&gt;
 271      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code 1.0}&lt;/th&gt; &lt;td&gt;{@code 0x1.0p0}&lt;/td&gt;
 272      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code -1.0}&lt;/th&gt;        &lt;td&gt;{@code -0x1.0p0}&lt;/td&gt;
 273      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code 2.0}&lt;/th&gt; &lt;td&gt;{@code 0x1.0p1}&lt;/td&gt;
 274      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code 3.0}&lt;/th&gt; &lt;td&gt;{@code 0x1.8p1}&lt;/td&gt;
 275      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code 0.5}&lt;/th&gt; &lt;td&gt;{@code 0x1.0p-1}&lt;/td&gt;
 276      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code 0.25}&lt;/th&gt;        &lt;td&gt;{@code 0x1.0p-2}&lt;/td&gt;
 277      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Float.MAX_VALUE}&lt;/th&gt;
 278      *     &lt;td&gt;{@code 0x1.fffffep127}&lt;/td&gt;
 279      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Minimum Normal Value}&lt;/th&gt;
 280      *     &lt;td&gt;{@code 0x1.0p-126}&lt;/td&gt;
 281      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Maximum Subnormal Value}&lt;/th&gt;
 282      *     &lt;td&gt;{@code 0x0.fffffep-126}&lt;/td&gt;
 283      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;{@code Float.MIN_VALUE}&lt;/th&gt;
 284      *     &lt;td&gt;{@code 0x0.000002p-126}&lt;/td&gt;
 285      * &lt;/tbody&gt;
 286      * &lt;/table&gt;
 287      * @param   f   the {@code float} to be converted.
 288      * @return a hex string representation of the argument.
 289      * @since 1.5
 290      * @author Joseph D. Darcy
 291      */
 292     public static String toHexString(float f) {
 293         if (Math.abs(f) &lt; Float.MIN_NORMAL
 294             &amp;&amp;  f != 0.0f ) {// float subnormal
 295             // Adjust exponent to create subnormal double, then
 296             // replace subnormal double exponent with subnormal float
 297             // exponent
 298             String s = Double.toHexString(Math.scalb((double)f,
 299                                                      /* -1022+126 */
 300                                                      Double.MIN_EXPONENT-
 301                                                      Float.MIN_EXPONENT));
 302             return s.replaceFirst(&quot;p-1022$&quot;, &quot;p-126&quot;);
 303         }
 304         else // double string will be the same as float string
 305             return Double.toHexString(f);
 306     }
 307 
 308     /**
 309      * Returns a {@code Float} object holding the
 310      * {@code float} value represented by the argument string
 311      * {@code s}.
 312      *
 313      * &lt;p&gt;If {@code s} is {@code null}, then a
 314      * {@code NullPointerException} is thrown.
 315      *
 316      * &lt;p&gt;Leading and trailing whitespace characters in {@code s}
 317      * are ignored.  Whitespace is removed as if by the {@link
 318      * String#trim} method; that is, both ASCII space and control
 319      * characters are removed. The rest of {@code s} should
 320      * constitute a &lt;i&gt;FloatValue&lt;/i&gt; as described by the lexical
 321      * syntax rules:
 322      *
 323      * &lt;blockquote&gt;
 324      * &lt;dl&gt;
 325      * &lt;dt&gt;&lt;i&gt;FloatValue:&lt;/i&gt;
 326      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; {@code NaN}
 327      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt; {@code Infinity}
 328      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt; FloatingPointLiteral&lt;/i&gt;
 329      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt; HexFloatingPointLiteral&lt;/i&gt;
 330      * &lt;dd&gt;&lt;i&gt;SignedInteger&lt;/i&gt;
 331      * &lt;/dl&gt;
 332      *
 333      * &lt;dl&gt;
 334      * &lt;dt&gt;&lt;i&gt;HexFloatingPointLiteral&lt;/i&gt;:
 335      * &lt;dd&gt; &lt;i&gt;HexSignificand BinaryExponent FloatTypeSuffix&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 336      * &lt;/dl&gt;
 337      *
 338      * &lt;dl&gt;
 339      * &lt;dt&gt;&lt;i&gt;HexSignificand:&lt;/i&gt;
 340      * &lt;dd&gt;&lt;i&gt;HexNumeral&lt;/i&gt;
 341      * &lt;dd&gt;&lt;i&gt;HexNumeral&lt;/i&gt; {@code .}
 342      * &lt;dd&gt;{@code 0x} &lt;i&gt;HexDigits&lt;sub&gt;opt&lt;/sub&gt;
 343      *     &lt;/i&gt;{@code .}&lt;i&gt; HexDigits&lt;/i&gt;
 344      * &lt;dd&gt;{@code 0X}&lt;i&gt; HexDigits&lt;sub&gt;opt&lt;/sub&gt;
 345      *     &lt;/i&gt;{@code .} &lt;i&gt;HexDigits&lt;/i&gt;
 346      * &lt;/dl&gt;
 347      *
 348      * &lt;dl&gt;
 349      * &lt;dt&gt;&lt;i&gt;BinaryExponent:&lt;/i&gt;
 350      * &lt;dd&gt;&lt;i&gt;BinaryExponentIndicator SignedInteger&lt;/i&gt;
 351      * &lt;/dl&gt;
 352      *
 353      * &lt;dl&gt;
 354      * &lt;dt&gt;&lt;i&gt;BinaryExponentIndicator:&lt;/i&gt;
 355      * &lt;dd&gt;{@code p}
 356      * &lt;dd&gt;{@code P}
 357      * &lt;/dl&gt;
 358      *
 359      * &lt;/blockquote&gt;
 360      *
 361      * where &lt;i&gt;Sign&lt;/i&gt;, &lt;i&gt;FloatingPointLiteral&lt;/i&gt;,
 362      * &lt;i&gt;HexNumeral&lt;/i&gt;, &lt;i&gt;HexDigits&lt;/i&gt;, &lt;i&gt;SignedInteger&lt;/i&gt; and
 363      * &lt;i&gt;FloatTypeSuffix&lt;/i&gt; are as defined in the lexical structure
 364      * sections of
 365      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
 366      * except that underscores are not accepted between digits.
 367      * If {@code s} does not have the form of
 368      * a &lt;i&gt;FloatValue&lt;/i&gt;, then a {@code NumberFormatException}
 369      * is thrown. Otherwise, {@code s} is regarded as
 370      * representing an exact decimal value in the usual
 371      * &quot;computerized scientific notation&quot; or as an exact
 372      * hexadecimal value; this exact numerical value is then
 373      * conceptually converted to an &quot;infinitely precise&quot;
 374      * binary value that is then rounded to type {@code float}
 375      * by the usual round-to-nearest rule of IEEE 754 floating-point
 376      * arithmetic, which includes preserving the sign of a zero
 377      * value.
 378      *
 379      * Note that the round-to-nearest rule also implies overflow and
 380      * underflow behaviour; if the exact value of {@code s} is large
 381      * enough in magnitude (greater than or equal to ({@link
 382      * #MAX_VALUE} + {@link Math#ulp(float) ulp(MAX_VALUE)}/2),
 383      * rounding to {@code float} will result in an infinity and if the
 384      * exact value of {@code s} is small enough in magnitude (less
 385      * than or equal to {@link #MIN_VALUE}/2), rounding to float will
 386      * result in a zero.
 387      *
 388      * Finally, after rounding a {@code Float} object representing
 389      * this {@code float} value is returned.
 390      *
 391      * &lt;p&gt;To interpret localized string representations of a
 392      * floating-point value, use subclasses of {@link
 393      * java.text.NumberFormat}.
 394      *
 395      * &lt;p&gt;Note that trailing format specifiers, specifiers that
 396      * determine the type of a floating-point literal
 397      * ({@code 1.0f} is a {@code float} value;
 398      * {@code 1.0d} is a {@code double} value), do
 399      * &lt;em&gt;not&lt;/em&gt; influence the results of this method.  In other
 400      * words, the numerical value of the input string is converted
 401      * directly to the target floating-point type.  In general, the
 402      * two-step sequence of conversions, string to {@code double}
 403      * followed by {@code double} to {@code float}, is
 404      * &lt;em&gt;not&lt;/em&gt; equivalent to converting a string directly to
 405      * {@code float}.  For example, if first converted to an
 406      * intermediate {@code double} and then to
 407      * {@code float}, the string&lt;br&gt;
 408      * {@code &quot;1.00000017881393421514957253748434595763683319091796875001d&quot;}&lt;br&gt;
 409      * results in the {@code float} value
 410      * {@code 1.0000002f}; if the string is converted directly to
 411      * {@code float}, &lt;code&gt;1.000000&lt;b&gt;1&lt;/b&gt;f&lt;/code&gt; results.
 412      *
 413      * &lt;p&gt;To avoid calling this method on an invalid string and having
 414      * a {@code NumberFormatException} be thrown, the documentation
 415      * for {@link Double#valueOf Double.valueOf} lists a regular
 416      * expression which can be used to screen the input.
 417      *
 418      * @param   s   the string to be parsed.
 419      * @return  a {@code Float} object holding the value
 420      *          represented by the {@code String} argument.
 421      * @throws  NumberFormatException  if the string does not contain a
 422      *          parsable number.
 423      */
 424     public static Float valueOf(String s) throws NumberFormatException {
 425         return new Float(parseFloat(s));
 426     }
 427 
 428     /**
 429      * Returns a {@code Float} instance representing the specified
 430      * {@code float} value.
 431      * If a new {@code Float} instance is not required, this method
 432      * should generally be used in preference to the constructor
 433      * {@link #Float(float)}, as this method is likely to yield
 434      * significantly better space and time performance by caching
 435      * frequently requested values.
 436      *
 437      * @param  f a float value.
 438      * @return a {@code Float} instance representing {@code f}.
 439      * @since  1.5
 440      */
 441     @HotSpotIntrinsicCandidate
 442     public static Float valueOf(float f) {
 443         return new Float(f);
 444     }
 445 
 446     /**
 447      * Returns a new {@code float} initialized to the value
 448      * represented by the specified {@code String}, as performed
 449      * by the {@code valueOf} method of class {@code Float}.
 450      *
 451      * @param  s the string to be parsed.
 452      * @return the {@code float} value represented by the string
 453      *         argument.
 454      * @throws NullPointerException  if the string is null
 455      * @throws NumberFormatException if the string does not contain a
 456      *               parsable {@code float}.
 457      * @see    java.lang.Float#valueOf(String)
 458      * @since 1.2
 459      */
 460     public static float parseFloat(String s) throws NumberFormatException {
 461         return FloatingDecimal.parseFloat(s);
 462     }
 463 
 464     /**
 465      * Returns {@code true} if the specified number is a
 466      * Not-a-Number (NaN) value, {@code false} otherwise.
 467      *
 468      * @param   v   the value to be tested.
 469      * @return  {@code true} if the argument is NaN;
 470      *          {@code false} otherwise.
 471      */
 472     public static boolean isNaN(float v) {
 473         return (v != v);
 474     }
 475 
 476     /**
 477      * Returns {@code true} if the specified number is infinitely
 478      * large in magnitude, {@code false} otherwise.
 479      *
 480      * @param   v   the value to be tested.
 481      * @return  {@code true} if the argument is positive infinity or
 482      *          negative infinity; {@code false} otherwise.
 483      */
 484     public static boolean isInfinite(float v) {
 485         return (v == POSITIVE_INFINITY) || (v == NEGATIVE_INFINITY);
 486     }
 487 
 488 
 489     /**
 490      * Returns {@code true} if the argument is a finite floating-point
 491      * value; returns {@code false} otherwise (for NaN and infinity
 492      * arguments).
 493      *
 494      * @param f the {@code float} value to be tested
 495      * @return {@code true} if the argument is a finite
 496      * floating-point value, {@code false} otherwise.
 497      * @since 1.8
 498      */
 499      public static boolean isFinite(float f) {
 500         return Math.abs(f) &lt;= Float.MAX_VALUE;
 501     }
 502 
 503     /**
 504      * The value of the Float.
 505      *
 506      * @serial
 507      */
 508     private final float value;
 509 
 510     /**
 511      * Constructs a newly allocated {@code Float} object that
 512      * represents the primitive {@code float} argument.
 513      *
 514      * @param   value   the value to be represented by the {@code Float}.
 515      *
 516      * @deprecated
 517      * It is rarely appropriate to use this constructor. The static factory
 518      * {@link #valueOf(float)} is generally a better choice, as it is
 519      * likely to yield significantly better space and time performance.
 520      */
 521     @Deprecated(since=&quot;9&quot;)
 522     public Float(float value) {
 523         this.value = value;
 524     }
 525 
 526     /**
 527      * Constructs a newly allocated {@code Float} object that
 528      * represents the argument converted to type {@code float}.
 529      *
 530      * @param   value   the value to be represented by the {@code Float}.
 531      *
 532      * @deprecated
 533      * It is rarely appropriate to use this constructor. Instead, use the
 534      * static factory method {@link #valueOf(float)} method as follows:
 535      * {@code Float.valueOf((float)value)}.
 536      */
 537     @Deprecated(since=&quot;9&quot;)
 538     public Float(double value) {
 539         this.value = (float)value;
 540     }
 541 
 542     /**
 543      * Constructs a newly allocated {@code Float} object that
 544      * represents the floating-point value of type {@code float}
 545      * represented by the string. The string is converted to a
 546      * {@code float} value as if by the {@code valueOf} method.
 547      *
 548      * @param   s   a string to be converted to a {@code Float}.
 549      * @throws      NumberFormatException if the string does not contain a
 550      *              parsable number.
 551      *
 552      * @deprecated
 553      * It is rarely appropriate to use this constructor.
 554      * Use {@link #parseFloat(String)} to convert a string to a
 555      * {@code float} primitive, or use {@link #valueOf(String)}
 556      * to convert a string to a {@code Float} object.
 557      */
 558     @Deprecated(since=&quot;9&quot;)
 559     public Float(String s) throws NumberFormatException {
 560         value = parseFloat(s);
 561     }
 562 
 563     /**
 564      * Returns {@code true} if this {@code Float} value is a
 565      * Not-a-Number (NaN), {@code false} otherwise.
 566      *
 567      * @return  {@code true} if the value represented by this object is
 568      *          NaN; {@code false} otherwise.
 569      */
 570     public boolean isNaN() {
 571         return isNaN(value);
 572     }
 573 
 574     /**
 575      * Returns {@code true} if this {@code Float} value is
 576      * infinitely large in magnitude, {@code false} otherwise.
 577      *
 578      * @return  {@code true} if the value represented by this object is
 579      *          positive infinity or negative infinity;
 580      *          {@code false} otherwise.
 581      */
 582     public boolean isInfinite() {
 583         return isInfinite(value);
 584     }
 585 
 586     /**
 587      * Returns a string representation of this {@code Float} object.
 588      * The primitive {@code float} value represented by this object
 589      * is converted to a {@code String} exactly as if by the method
 590      * {@code toString} of one argument.
 591      *
 592      * @return  a {@code String} representation of this object.
 593      * @see java.lang.Float#toString(float)
 594      */
 595     public String toString() {
 596         return Float.toString(value);
 597     }
 598 
 599     /**
 600      * Returns the value of this {@code Float} as a {@code byte} after
 601      * a narrowing primitive conversion.
 602      *
 603      * @return  the {@code float} value represented by this object
 604      *          converted to type {@code byte}
 605      * @jls 5.1.3 Narrowing Primitive Conversion
 606      */
 607     public byte byteValue() {
 608         return (byte)value;
 609     }
 610 
 611     /**
 612      * Returns the value of this {@code Float} as a {@code short}
 613      * after a narrowing primitive conversion.
 614      *
 615      * @return  the {@code float} value represented by this object
 616      *          converted to type {@code short}
 617      * @jls 5.1.3 Narrowing Primitive Conversion
 618      * @since 1.1
 619      */
 620     public short shortValue() {
 621         return (short)value;
 622     }
 623 
 624     /**
 625      * Returns the value of this {@code Float} as an {@code int} after
 626      * a narrowing primitive conversion.
 627      *
 628      * @return  the {@code float} value represented by this object
 629      *          converted to type {@code int}
 630      * @jls 5.1.3 Narrowing Primitive Conversion
 631      */
 632     public int intValue() {
 633         return (int)value;
 634     }
 635 
 636     /**
 637      * Returns value of this {@code Float} as a {@code long} after a
 638      * narrowing primitive conversion.
 639      *
 640      * @return  the {@code float} value represented by this object
 641      *          converted to type {@code long}
 642      * @jls 5.1.3 Narrowing Primitive Conversion
 643      */
 644     public long longValue() {
 645         return (long)value;
 646     }
 647 
 648     /**
 649      * Returns the {@code float} value of this {@code Float} object.
 650      *
 651      * @return the {@code float} value represented by this object
 652      */
 653     @HotSpotIntrinsicCandidate
 654     public float floatValue() {
 655         return value;
 656     }
 657 
 658     /**
 659      * Returns the value of this {@code Float} as a {@code double}
 660      * after a widening primitive conversion.
 661      *
 662      * @return the {@code float} value represented by this
 663      *         object converted to type {@code double}
 664      * @jls 5.1.2 Widening Primitive Conversion
 665      */
 666     public double doubleValue() {
 667         return (double)value;
 668     }
 669 
 670     /**
 671      * Returns a hash code for this {@code Float} object. The
 672      * result is the integer bit representation, exactly as produced
 673      * by the method {@link #floatToIntBits(float)}, of the primitive
 674      * {@code float} value represented by this {@code Float}
 675      * object.
 676      *
 677      * @return a hash code value for this object.
 678      */
 679     @Override
 680     public int hashCode() {
 681         return Float.hashCode(value);
 682     }
 683 
 684     /**
 685      * Returns a hash code for a {@code float} value; compatible with
 686      * {@code Float.hashCode()}.
 687      *
 688      * @param value the value to hash
 689      * @return a hash code value for a {@code float} value.
 690      * @since 1.8
 691      */
 692     public static int hashCode(float value) {
 693         return floatToIntBits(value);
 694     }
 695 
 696     /**
<a name="2" id="anc2"></a><span class="line-removed"> 697 </span>
 698      * Compares this object against the specified object.  The result
 699      * is {@code true} if and only if the argument is not
 700      * {@code null} and is a {@code Float} object that
 701      * represents a {@code float} with the same value as the
 702      * {@code float} represented by this object. For this
 703      * purpose, two {@code float} values are considered to be the
 704      * same if and only if the method {@link #floatToIntBits(float)}
 705      * returns the identical {@code int} value when applied to
 706      * each.
 707      *
 708      * &lt;p&gt;Note that in most cases, for two instances of class
 709      * {@code Float}, {@code f1} and {@code f2}, the value
 710      * of {@code f1.equals(f2)} is {@code true} if and only if
 711      *
 712      * &lt;blockquote&gt;&lt;pre&gt;
 713      *   f1.floatValue() == f2.floatValue()
 714      * &lt;/pre&gt;&lt;/blockquote&gt;
 715      *
 716      * &lt;p&gt;also has the value {@code true}. However, there are two exceptions:
 717      * &lt;ul&gt;
 718      * &lt;li&gt;If {@code f1} and {@code f2} both represent
 719      *     {@code Float.NaN}, then the {@code equals} method returns
 720      *     {@code true}, even though {@code Float.NaN==Float.NaN}
 721      *     has the value {@code false}.
 722      * &lt;li&gt;If {@code f1} represents {@code +0.0f} while
 723      *     {@code f2} represents {@code -0.0f}, or vice
 724      *     versa, the {@code equal} test has the value
 725      *     {@code false}, even though {@code 0.0f==-0.0f}
 726      *     has the value {@code true}.
 727      * &lt;/ul&gt;
 728      *
 729      * This definition allows hash tables to operate properly.
 730      *
 731      * @param obj the object to be compared
 732      * @return  {@code true} if the objects are the same;
 733      *          {@code false} otherwise.
 734      * @see java.lang.Float#floatToIntBits(float)
 735      */
 736     public boolean equals(Object obj) {
 737         return (obj instanceof Float)
 738                &amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value));
 739     }
 740 
 741     /**
 742      * Returns a representation of the specified floating-point value
 743      * according to the IEEE 754 floating-point &quot;single format&quot; bit
 744      * layout.
 745      *
 746      * &lt;p&gt;Bit 31 (the bit that is selected by the mask
 747      * {@code 0x80000000}) represents the sign of the floating-point
 748      * number.
 749      * Bits 30-23 (the bits that are selected by the mask
 750      * {@code 0x7f800000}) represent the exponent.
 751      * Bits 22-0 (the bits that are selected by the mask
 752      * {@code 0x007fffff}) represent the significand (sometimes called
 753      * the mantissa) of the floating-point number.
 754      *
 755      * &lt;p&gt;If the argument is positive infinity, the result is
 756      * {@code 0x7f800000}.
 757      *
 758      * &lt;p&gt;If the argument is negative infinity, the result is
 759      * {@code 0xff800000}.
 760      *
 761      * &lt;p&gt;If the argument is NaN, the result is {@code 0x7fc00000}.
 762      *
 763      * &lt;p&gt;In all cases, the result is an integer that, when given to the
 764      * {@link #intBitsToFloat(int)} method, will produce a floating-point
 765      * value the same as the argument to {@code floatToIntBits}
 766      * (except all NaN values are collapsed to a single
 767      * &quot;canonical&quot; NaN value).
 768      *
 769      * @param   value   a floating-point number.
 770      * @return the bits that represent the floating-point number.
 771      */
 772     @HotSpotIntrinsicCandidate
 773     public static int floatToIntBits(float value) {
 774         if (!isNaN(value)) {
 775             return floatToRawIntBits(value);
 776         }
 777         return 0x7fc00000;
 778     }
 779 
 780     /**
 781      * Returns a representation of the specified floating-point value
 782      * according to the IEEE 754 floating-point &quot;single format&quot; bit
 783      * layout, preserving Not-a-Number (NaN) values.
 784      *
 785      * &lt;p&gt;Bit 31 (the bit that is selected by the mask
 786      * {@code 0x80000000}) represents the sign of the floating-point
 787      * number.
 788      * Bits 30-23 (the bits that are selected by the mask
 789      * {@code 0x7f800000}) represent the exponent.
 790      * Bits 22-0 (the bits that are selected by the mask
 791      * {@code 0x007fffff}) represent the significand (sometimes called
 792      * the mantissa) of the floating-point number.
 793      *
 794      * &lt;p&gt;If the argument is positive infinity, the result is
 795      * {@code 0x7f800000}.
 796      *
 797      * &lt;p&gt;If the argument is negative infinity, the result is
 798      * {@code 0xff800000}.
 799      *
 800      * &lt;p&gt;If the argument is NaN, the result is the integer representing
 801      * the actual NaN value.  Unlike the {@code floatToIntBits}
 802      * method, {@code floatToRawIntBits} does not collapse all the
 803      * bit patterns encoding a NaN to a single &quot;canonical&quot;
 804      * NaN value.
 805      *
 806      * &lt;p&gt;In all cases, the result is an integer that, when given to the
 807      * {@link #intBitsToFloat(int)} method, will produce a
 808      * floating-point value the same as the argument to
 809      * {@code floatToRawIntBits}.
 810      *
 811      * @param   value   a floating-point number.
 812      * @return the bits that represent the floating-point number.
 813      * @since 1.3
 814      */
 815     @HotSpotIntrinsicCandidate
 816     public static native int floatToRawIntBits(float value);
 817 
 818     /**
 819      * Returns the {@code float} value corresponding to a given
 820      * bit representation.
 821      * The argument is considered to be a representation of a
 822      * floating-point value according to the IEEE 754 floating-point
 823      * &quot;single format&quot; bit layout.
 824      *
 825      * &lt;p&gt;If the argument is {@code 0x7f800000}, the result is positive
 826      * infinity.
 827      *
 828      * &lt;p&gt;If the argument is {@code 0xff800000}, the result is negative
 829      * infinity.
 830      *
 831      * &lt;p&gt;If the argument is any value in the range
 832      * {@code 0x7f800001} through {@code 0x7fffffff} or in
 833      * the range {@code 0xff800001} through
 834      * {@code 0xffffffff}, the result is a NaN.  No IEEE 754
 835      * floating-point operation provided by Java can distinguish
 836      * between two NaN values of the same type with different bit
 837      * patterns.  Distinct values of NaN are only distinguishable by
 838      * use of the {@code Float.floatToRawIntBits} method.
 839      *
 840      * &lt;p&gt;In all other cases, let &lt;i&gt;s&lt;/i&gt;, &lt;i&gt;e&lt;/i&gt;, and &lt;i&gt;m&lt;/i&gt; be three
 841      * values that can be computed from the argument:
 842      *
 843      * &lt;blockquote&gt;&lt;pre&gt;{@code
 844      * int s = ((bits &gt;&gt; 31) == 0) ? 1 : -1;
 845      * int e = ((bits &gt;&gt; 23) &amp; 0xff);
 846      * int m = (e == 0) ?
 847      *                 (bits &amp; 0x7fffff) &lt;&lt; 1 :
 848      *                 (bits &amp; 0x7fffff) | 0x800000;
 849      * }&lt;/pre&gt;&lt;/blockquote&gt;
 850      *
 851      * Then the floating-point result equals the value of the mathematical
 852      * expression &lt;i&gt;s&lt;/i&gt;&amp;middot;&lt;i&gt;m&lt;/i&gt;&amp;middot;2&lt;sup&gt;&lt;i&gt;e&lt;/i&gt;-150&lt;/sup&gt;.
 853      *
 854      * &lt;p&gt;Note that this method may not be able to return a
 855      * {@code float} NaN with exactly same bit pattern as the
 856      * {@code int} argument.  IEEE 754 distinguishes between two
 857      * kinds of NaNs, quiet NaNs and &lt;i&gt;signaling NaNs&lt;/i&gt;.  The
 858      * differences between the two kinds of NaN are generally not
 859      * visible in Java.  Arithmetic operations on signaling NaNs turn
 860      * them into quiet NaNs with a different, but often similar, bit
 861      * pattern.  However, on some processors merely copying a
 862      * signaling NaN also performs that conversion.  In particular,
 863      * copying a signaling NaN to return it to the calling method may
 864      * perform this conversion.  So {@code intBitsToFloat} may
 865      * not be able to return a {@code float} with a signaling NaN
 866      * bit pattern.  Consequently, for some {@code int} values,
 867      * {@code floatToRawIntBits(intBitsToFloat(start))} may
 868      * &lt;i&gt;not&lt;/i&gt; equal {@code start}.  Moreover, which
 869      * particular bit patterns represent signaling NaNs is platform
 870      * dependent; although all NaN bit patterns, quiet or signaling,
 871      * must be in the NaN range identified above.
 872      *
 873      * @param   bits   an integer.
 874      * @return  the {@code float} floating-point value with the same bit
 875      *          pattern.
 876      */
 877     @HotSpotIntrinsicCandidate
 878     public static native float intBitsToFloat(int bits);
 879 
 880     /**
 881      * Compares two {@code Float} objects numerically.  There are
 882      * two ways in which comparisons performed by this method differ
 883      * from those performed by the Java language numerical comparison
 884      * operators ({@code &lt;, &lt;=, ==, &gt;=, &gt;}) when
 885      * applied to primitive {@code float} values:
 886      *
 887      * &lt;ul&gt;&lt;li&gt;
 888      *          {@code Float.NaN} is considered by this method to
 889      *          be equal to itself and greater than all other
 890      *          {@code float} values
 891      *          (including {@code Float.POSITIVE_INFINITY}).
 892      * &lt;li&gt;
 893      *          {@code 0.0f} is considered by this method to be greater
 894      *          than {@code -0.0f}.
 895      * &lt;/ul&gt;
 896      *
 897      * This ensures that the &lt;i&gt;natural ordering&lt;/i&gt; of {@code Float}
 898      * objects imposed by this method is &lt;i&gt;consistent with equals&lt;/i&gt;.
 899      *
 900      * @param   anotherFloat   the {@code Float} to be compared.
 901      * @return  the value {@code 0} if {@code anotherFloat} is
 902      *          numerically equal to this {@code Float}; a value
 903      *          less than {@code 0} if this {@code Float}
 904      *          is numerically less than {@code anotherFloat};
 905      *          and a value greater than {@code 0} if this
 906      *          {@code Float} is numerically greater than
 907      *          {@code anotherFloat}.
 908      *
 909      * @since   1.2
 910      * @see Comparable#compareTo(Object)
 911      */
 912     public int compareTo(Float anotherFloat) {
 913         return Float.compare(value, anotherFloat.value);
 914     }
 915 
 916     /**
 917      * Compares the two specified {@code float} values. The sign
 918      * of the integer value returned is the same as that of the
 919      * integer that would be returned by the call:
 920      * &lt;pre&gt;
 921      *    new Float(f1).compareTo(new Float(f2))
 922      * &lt;/pre&gt;
 923      *
 924      * @param   f1        the first {@code float} to compare.
 925      * @param   f2        the second {@code float} to compare.
 926      * @return  the value {@code 0} if {@code f1} is
 927      *          numerically equal to {@code f2}; a value less than
 928      *          {@code 0} if {@code f1} is numerically less than
 929      *          {@code f2}; and a value greater than {@code 0}
 930      *          if {@code f1} is numerically greater than
 931      *          {@code f2}.
 932      * @since 1.4
 933      */
 934     public static int compare(float f1, float f2) {
 935         if (f1 &lt; f2)
 936             return -1;           // Neither val is NaN, thisVal is smaller
 937         if (f1 &gt; f2)
 938             return 1;            // Neither val is NaN, thisVal is larger
 939 
 940         // Cannot use floatToRawIntBits because of possibility of NaNs.
 941         int thisBits    = Float.floatToIntBits(f1);
 942         int anotherBits = Float.floatToIntBits(f2);
 943 
 944         return (thisBits == anotherBits ?  0 : // Values are equal
 945                 (thisBits &lt; anotherBits ? -1 : // (-0.0, 0.0) or (!NaN, NaN)
 946                  1));                          // (0.0, -0.0) or (NaN, !NaN)
 947     }
 948 
 949     /**
 950      * Adds two {@code float} values together as per the + operator.
 951      *
 952      * @param a the first operand
 953      * @param b the second operand
 954      * @return the sum of {@code a} and {@code b}
 955      * @jls 4.2.4 Floating-Point Operations
 956      * @see java.util.function.BinaryOperator
 957      * @since 1.8
 958      */
 959     public static float sum(float a, float b) {
 960         return a + b;
 961     }
 962 
 963     /**
 964      * Returns the greater of two {@code float} values
 965      * as if by calling {@link Math#max(float, float) Math.max}.
 966      *
 967      * @param a the first operand
 968      * @param b the second operand
 969      * @return the greater of {@code a} and {@code b}
 970      * @see java.util.function.BinaryOperator
 971      * @since 1.8
 972      */
 973     public static float max(float a, float b) {
 974         return Math.max(a, b);
 975     }
 976 
 977     /**
 978      * Returns the smaller of two {@code float} values
 979      * as if by calling {@link Math#min(float, float) Math.min}.
 980      *
 981      * @param a the first operand
 982      * @param b the second operand
 983      * @return the smaller of {@code a} and {@code b}
 984      * @see java.util.function.BinaryOperator
 985      * @since 1.8
 986      */
 987     public static float min(float a, float b) {
 988         return Math.min(a, b);
 989     }
 990 
 991     /**
 992      * Returns an {@link Optional} containing the nominal descriptor for this
 993      * instance, which is the instance itself.
 994      *
 995      * @return an {@link Optional} describing the {@linkplain Float} instance
 996      * @since 12
 997      */
 998     @Override
 999     public Optional&lt;Float&gt; describeConstable() {
1000         return Optional.of(this);
1001     }
1002 
1003     /**
1004      * Resolves this instance as a {@link ConstantDesc}, the result of which is
1005      * the instance itself.
1006      *
1007      * @param lookup ignored
1008      * @return the {@linkplain Float} instance
1009      * @since 12
1010      */
1011     @Override
1012     public Float resolveConstantDesc(MethodHandles.Lookup lookup) {
1013         return this;
1014     }
1015 
1016     /** use serialVersionUID from JDK 1.0.2 for interoperability */
1017     @java.io.Serial
1018     private static final long serialVersionUID = -2671257302660747028L;
1019 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/String.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="StrictMath.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="System.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/String.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 445 
 446     /**
 447      * Constructs a new {@code String} by decoding the specified subarray of
 448      * bytes using the specified charset.  The length of the new {@code String}
 449      * is a function of the charset, and hence may not be equal to the length
 450      * of the subarray.
 451      *
 452      * &lt;p&gt; The behavior of this constructor when the given bytes are not valid
 453      * in the given charset is unspecified.  The {@link
 454      * java.nio.charset.CharsetDecoder} class should be used when more control
 455      * over the decoding process is required.
 456      *
 457      * @param  bytes
 458      *         The bytes to be decoded into characters
 459      *
 460      * @param  offset
 461      *         The index of the first byte to decode
 462      *
 463      * @param  length
 464      *         The number of bytes to decode
<span class="line-modified"> 465 </span>
 466      * @param  charsetName
 467      *         The name of a supported {@linkplain java.nio.charset.Charset
 468      *         charset}
 469      *
 470      * @throws  UnsupportedEncodingException
 471      *          If the named charset is not supported
 472      *
 473      * @throws  IndexOutOfBoundsException
 474      *          If {@code offset} is negative, {@code length} is negative, or
 475      *          {@code offset} is greater than {@code bytes.length - length}
 476      *
 477      * @since  1.1
 478      */
 479     public String(byte bytes[], int offset, int length, String charsetName)
 480             throws UnsupportedEncodingException {
 481         if (charsetName == null)
 482             throw new NullPointerException(&quot;charsetName&quot;);
 483         checkBoundsOffCount(offset, length, bytes.length);
 484         StringCoding.Result ret =
 485             StringCoding.decode(charsetName, bytes, offset, length);
</pre>
<hr />
<pre>
1366      * this {@code String} object to be compared begins at index
1367      * {@code toffset} and has length {@code len}. The substring of
1368      * {@code other} to be compared begins at index {@code ooffset} and
1369      * has length {@code len}. The result is {@code false} if and only if
1370      * at least one of the following is true:
1371      * &lt;ul&gt;&lt;li&gt;{@code toffset} is negative.
1372      * &lt;li&gt;{@code ooffset} is negative.
1373      * &lt;li&gt;{@code toffset+len} is greater than the length of this
1374      * {@code String} object.
1375      * &lt;li&gt;{@code ooffset+len} is greater than the length of the other
1376      * argument.
1377      * &lt;li&gt;{@code ignoreCase} is {@code false} and there is some nonnegative
1378      * integer &lt;i&gt;k&lt;/i&gt; less than {@code len} such that:
1379      * &lt;blockquote&gt;&lt;pre&gt;
1380      * this.charAt(toffset+k) != other.charAt(ooffset+k)
1381      * &lt;/pre&gt;&lt;/blockquote&gt;
1382      * &lt;li&gt;{@code ignoreCase} is {@code true} and there is some nonnegative
1383      * integer &lt;i&gt;k&lt;/i&gt; less than {@code len} such that:
1384      * &lt;blockquote&gt;&lt;pre&gt;
1385      * Character.toLowerCase(Character.toUpperCase(this.charAt(toffset+k))) !=
<span class="line-modified">1386      Character.toLowerCase(Character.toUpperCase(other.charAt(ooffset+k)))</span>
1387      * &lt;/pre&gt;&lt;/blockquote&gt;
1388      * &lt;/ul&gt;
1389      *
1390      * &lt;p&gt;Note that this method does &lt;em&gt;not&lt;/em&gt; take locale into account,
1391      * and will result in unsatisfactory results for certain locales when
1392      * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class
1393      * provides locale-sensitive comparison.
1394      *
1395      * @param   ignoreCase   if {@code true}, ignore case when comparing
1396      *                       characters.
1397      * @param   toffset      the starting offset of the subregion in this
1398      *                       string.
1399      * @param   other        the string argument.
1400      * @param   ooffset      the starting offset of the subregion in the string
1401      *                       argument.
1402      * @param   len          the number of characters to compare.
1403      * @return  {@code true} if the specified subregion of this string
1404      *          matches the specified subregion of the string argument;
1405      *          {@code false} otherwise. Whether the matching is exact
1406      *          or case insensitive depends on the {@code ignoreCase}
</pre>
<hr />
<pre>
2283      *
2284      * @param  regex
2285      *         the delimiting regular expression
2286      *
2287      * @param  limit
2288      *         the result threshold, as described above
2289      *
2290      * @return  the array of strings computed by splitting this string
2291      *          around matches of the given regular expression
2292      *
2293      * @throws  PatternSyntaxException
2294      *          if the regular expression&#39;s syntax is invalid
2295      *
2296      * @see java.util.regex.Pattern
2297      *
2298      * @since 1.4
2299      * @spec JSR-51
2300      */
2301     public String[] split(String regex, int limit) {
2302         /* fastpath if the regex is a
<span class="line-modified">2303          (1)one-char String and this character is not one of the</span>
<span class="line-modified">2304             RegEx&#39;s meta characters &quot;.$|()[{^?*+\\&quot;, or</span>
<span class="line-modified">2305          (2)two-char String and the first char is the backslash and</span>
<span class="line-modified">2306             the second is not the ascii digit or ascii letter.</span>
2307          */
2308         char ch = 0;
2309         if (((regex.length() == 1 &amp;&amp;
2310              &quot;.$|()[{^?*+\\&quot;.indexOf(ch = regex.charAt(0)) == -1) ||
2311              (regex.length() == 2 &amp;&amp;
2312               regex.charAt(0) == &#39;\\&#39; &amp;&amp;
2313               (((ch = regex.charAt(1))-&#39;0&#39;)|(&#39;9&#39;-ch)) &lt; 0 &amp;&amp;
2314               ((ch-&#39;a&#39;)|(&#39;z&#39;-ch)) &lt; 0 &amp;&amp;
2315               ((ch-&#39;A&#39;)|(&#39;Z&#39;-ch)) &lt; 0)) &amp;&amp;
2316             (ch &lt; Character.MIN_HIGH_SURROGATE ||
2317              ch &gt; Character.MAX_LOW_SURROGATE))
2318         {
2319             int off = 0;
2320             int next = 0;
2321             boolean limited = limit &gt; 0;
2322             ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
2323             while ((next = indexOf(ch, off)) != -1) {
2324                 if (!limited || list.size() &lt; limit - 1) {
2325                     list.add(substring(off, next));
2326                     off = next + 1;
</pre>
<hr />
<pre>
2428     public static String join(CharSequence delimiter, CharSequence... elements) {
2429         Objects.requireNonNull(delimiter);
2430         Objects.requireNonNull(elements);
2431         // Number of elements not likely worth Arrays.stream overhead.
2432         StringJoiner joiner = new StringJoiner(delimiter);
2433         for (CharSequence cs: elements) {
2434             joiner.add(cs);
2435         }
2436         return joiner.toString();
2437     }
2438 
2439     /**
2440      * Returns a new {@code String} composed of copies of the
2441      * {@code CharSequence elements} joined together with a copy of the
2442      * specified {@code delimiter}.
2443      *
2444      * &lt;blockquote&gt;For example,
2445      * &lt;pre&gt;{@code
2446      *     List&lt;String&gt; strings = List.of(&quot;Java&quot;, &quot;is&quot;, &quot;cool&quot;);
2447      *     String message = String.join(&quot; &quot;, strings);
<span class="line-modified">2448      *     //message returned is: &quot;Java is cool&quot;</span>
2449      *
2450      *     Set&lt;String&gt; strings =
2451      *         new LinkedHashSet&lt;&gt;(List.of(&quot;Java&quot;, &quot;is&quot;, &quot;very&quot;, &quot;cool&quot;));
2452      *     String message = String.join(&quot;-&quot;, strings);
<span class="line-modified">2453      *     //message returned is: &quot;Java-is-very-cool&quot;</span>
2454      * }&lt;/pre&gt;&lt;/blockquote&gt;
2455      *
2456      * Note that if an individual element is {@code null}, then {@code &quot;null&quot;} is added.
2457      *
2458      * @param  delimiter a sequence of characters that is used to separate each
2459      *         of the {@code elements} in the resulting {@code String}
2460      * @param  elements an {@code Iterable} that will have its {@code elements}
2461      *         joined together.
2462      *
2463      * @return a new {@code String} that is composed from the {@code elements}
2464      *         argument
2465      *
2466      * @throws NullPointerException If {@code delimiter} or {@code elements}
2467      *         is {@code null}
2468      *
2469      * @see    #join(CharSequence,CharSequence...)
2470      * @see    java.util.StringJoiner
2471      * @since 1.8
2472      */
2473     public static String join(CharSequence delimiter,
</pre>
</td>
<td>
<hr />
<pre>
 445 
 446     /**
 447      * Constructs a new {@code String} by decoding the specified subarray of
 448      * bytes using the specified charset.  The length of the new {@code String}
 449      * is a function of the charset, and hence may not be equal to the length
 450      * of the subarray.
 451      *
 452      * &lt;p&gt; The behavior of this constructor when the given bytes are not valid
 453      * in the given charset is unspecified.  The {@link
 454      * java.nio.charset.CharsetDecoder} class should be used when more control
 455      * over the decoding process is required.
 456      *
 457      * @param  bytes
 458      *         The bytes to be decoded into characters
 459      *
 460      * @param  offset
 461      *         The index of the first byte to decode
 462      *
 463      * @param  length
 464      *         The number of bytes to decode
<span class="line-modified"> 465      *</span>
 466      * @param  charsetName
 467      *         The name of a supported {@linkplain java.nio.charset.Charset
 468      *         charset}
 469      *
 470      * @throws  UnsupportedEncodingException
 471      *          If the named charset is not supported
 472      *
 473      * @throws  IndexOutOfBoundsException
 474      *          If {@code offset} is negative, {@code length} is negative, or
 475      *          {@code offset} is greater than {@code bytes.length - length}
 476      *
 477      * @since  1.1
 478      */
 479     public String(byte bytes[], int offset, int length, String charsetName)
 480             throws UnsupportedEncodingException {
 481         if (charsetName == null)
 482             throw new NullPointerException(&quot;charsetName&quot;);
 483         checkBoundsOffCount(offset, length, bytes.length);
 484         StringCoding.Result ret =
 485             StringCoding.decode(charsetName, bytes, offset, length);
</pre>
<hr />
<pre>
1366      * this {@code String} object to be compared begins at index
1367      * {@code toffset} and has length {@code len}. The substring of
1368      * {@code other} to be compared begins at index {@code ooffset} and
1369      * has length {@code len}. The result is {@code false} if and only if
1370      * at least one of the following is true:
1371      * &lt;ul&gt;&lt;li&gt;{@code toffset} is negative.
1372      * &lt;li&gt;{@code ooffset} is negative.
1373      * &lt;li&gt;{@code toffset+len} is greater than the length of this
1374      * {@code String} object.
1375      * &lt;li&gt;{@code ooffset+len} is greater than the length of the other
1376      * argument.
1377      * &lt;li&gt;{@code ignoreCase} is {@code false} and there is some nonnegative
1378      * integer &lt;i&gt;k&lt;/i&gt; less than {@code len} such that:
1379      * &lt;blockquote&gt;&lt;pre&gt;
1380      * this.charAt(toffset+k) != other.charAt(ooffset+k)
1381      * &lt;/pre&gt;&lt;/blockquote&gt;
1382      * &lt;li&gt;{@code ignoreCase} is {@code true} and there is some nonnegative
1383      * integer &lt;i&gt;k&lt;/i&gt; less than {@code len} such that:
1384      * &lt;blockquote&gt;&lt;pre&gt;
1385      * Character.toLowerCase(Character.toUpperCase(this.charAt(toffset+k))) !=
<span class="line-modified">1386      * Character.toLowerCase(Character.toUpperCase(other.charAt(ooffset+k)))</span>
1387      * &lt;/pre&gt;&lt;/blockquote&gt;
1388      * &lt;/ul&gt;
1389      *
1390      * &lt;p&gt;Note that this method does &lt;em&gt;not&lt;/em&gt; take locale into account,
1391      * and will result in unsatisfactory results for certain locales when
1392      * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class
1393      * provides locale-sensitive comparison.
1394      *
1395      * @param   ignoreCase   if {@code true}, ignore case when comparing
1396      *                       characters.
1397      * @param   toffset      the starting offset of the subregion in this
1398      *                       string.
1399      * @param   other        the string argument.
1400      * @param   ooffset      the starting offset of the subregion in the string
1401      *                       argument.
1402      * @param   len          the number of characters to compare.
1403      * @return  {@code true} if the specified subregion of this string
1404      *          matches the specified subregion of the string argument;
1405      *          {@code false} otherwise. Whether the matching is exact
1406      *          or case insensitive depends on the {@code ignoreCase}
</pre>
<hr />
<pre>
2283      *
2284      * @param  regex
2285      *         the delimiting regular expression
2286      *
2287      * @param  limit
2288      *         the result threshold, as described above
2289      *
2290      * @return  the array of strings computed by splitting this string
2291      *          around matches of the given regular expression
2292      *
2293      * @throws  PatternSyntaxException
2294      *          if the regular expression&#39;s syntax is invalid
2295      *
2296      * @see java.util.regex.Pattern
2297      *
2298      * @since 1.4
2299      * @spec JSR-51
2300      */
2301     public String[] split(String regex, int limit) {
2302         /* fastpath if the regex is a
<span class="line-modified">2303          * (1) one-char String and this character is not one of the</span>
<span class="line-modified">2304          *     RegEx&#39;s meta characters &quot;.$|()[{^?*+\\&quot;, or</span>
<span class="line-modified">2305          * (2) two-char String and the first char is the backslash and</span>
<span class="line-modified">2306          *     the second is not the ascii digit or ascii letter.</span>
2307          */
2308         char ch = 0;
2309         if (((regex.length() == 1 &amp;&amp;
2310              &quot;.$|()[{^?*+\\&quot;.indexOf(ch = regex.charAt(0)) == -1) ||
2311              (regex.length() == 2 &amp;&amp;
2312               regex.charAt(0) == &#39;\\&#39; &amp;&amp;
2313               (((ch = regex.charAt(1))-&#39;0&#39;)|(&#39;9&#39;-ch)) &lt; 0 &amp;&amp;
2314               ((ch-&#39;a&#39;)|(&#39;z&#39;-ch)) &lt; 0 &amp;&amp;
2315               ((ch-&#39;A&#39;)|(&#39;Z&#39;-ch)) &lt; 0)) &amp;&amp;
2316             (ch &lt; Character.MIN_HIGH_SURROGATE ||
2317              ch &gt; Character.MAX_LOW_SURROGATE))
2318         {
2319             int off = 0;
2320             int next = 0;
2321             boolean limited = limit &gt; 0;
2322             ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
2323             while ((next = indexOf(ch, off)) != -1) {
2324                 if (!limited || list.size() &lt; limit - 1) {
2325                     list.add(substring(off, next));
2326                     off = next + 1;
</pre>
<hr />
<pre>
2428     public static String join(CharSequence delimiter, CharSequence... elements) {
2429         Objects.requireNonNull(delimiter);
2430         Objects.requireNonNull(elements);
2431         // Number of elements not likely worth Arrays.stream overhead.
2432         StringJoiner joiner = new StringJoiner(delimiter);
2433         for (CharSequence cs: elements) {
2434             joiner.add(cs);
2435         }
2436         return joiner.toString();
2437     }
2438 
2439     /**
2440      * Returns a new {@code String} composed of copies of the
2441      * {@code CharSequence elements} joined together with a copy of the
2442      * specified {@code delimiter}.
2443      *
2444      * &lt;blockquote&gt;For example,
2445      * &lt;pre&gt;{@code
2446      *     List&lt;String&gt; strings = List.of(&quot;Java&quot;, &quot;is&quot;, &quot;cool&quot;);
2447      *     String message = String.join(&quot; &quot;, strings);
<span class="line-modified">2448      *     // message returned is: &quot;Java is cool&quot;</span>
2449      *
2450      *     Set&lt;String&gt; strings =
2451      *         new LinkedHashSet&lt;&gt;(List.of(&quot;Java&quot;, &quot;is&quot;, &quot;very&quot;, &quot;cool&quot;));
2452      *     String message = String.join(&quot;-&quot;, strings);
<span class="line-modified">2453      *     // message returned is: &quot;Java-is-very-cool&quot;</span>
2454      * }&lt;/pre&gt;&lt;/blockquote&gt;
2455      *
2456      * Note that if an individual element is {@code null}, then {@code &quot;null&quot;} is added.
2457      *
2458      * @param  delimiter a sequence of characters that is used to separate each
2459      *         of the {@code elements} in the resulting {@code String}
2460      * @param  elements an {@code Iterable} that will have its {@code elements}
2461      *         joined together.
2462      *
2463      * @return a new {@code String} that is composed from the {@code elements}
2464      *         argument
2465      *
2466      * @throws NullPointerException If {@code delimiter} or {@code elements}
2467      *         is {@code null}
2468      *
2469      * @see    #join(CharSequence,CharSequence...)
2470      * @see    java.util.StringJoiner
2471      * @since 1.8
2472      */
2473     public static String join(CharSequence delimiter,
</pre>
</td>
</tr>
</table>
<center><a href="StrictMath.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="System.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
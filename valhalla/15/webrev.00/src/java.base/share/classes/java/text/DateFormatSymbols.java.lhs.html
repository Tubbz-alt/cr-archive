<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/text/DateFormatSymbols.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  * (C) Copyright Taligent, Inc. 1996 - All Rights Reserved
 28  * (C) Copyright IBM Corp. 1996 - All Rights Reserved
 29  *
 30  *   The original version of this source code and documentation is copyrighted
 31  * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
 32  * materials are provided under terms of a License Agreement between Taligent
 33  * and Sun. This technology is protected by multiple US and International
 34  * patents. This notice and attribution to Taligent may not be removed.
 35  *   Taligent is a registered trademark of Taligent, Inc.
 36  *
 37  */
 38 
 39 package java.text;
 40 
 41 import java.io.IOException;
 42 import java.io.ObjectOutputStream;
 43 import java.io.Serializable;
 44 import java.lang.ref.SoftReference;
 45 import java.text.spi.DateFormatSymbolsProvider;
 46 import java.util.Arrays;
 47 import java.util.Locale;
 48 import java.util.Objects;
 49 import java.util.ResourceBundle;
 50 import java.util.concurrent.ConcurrentHashMap;
 51 import java.util.concurrent.ConcurrentMap;
 52 import sun.util.locale.provider.CalendarDataUtility;
 53 import sun.util.locale.provider.LocaleProviderAdapter;
 54 import sun.util.locale.provider.LocaleServiceProviderPool;
 55 import sun.util.locale.provider.ResourceBundleBasedAdapter;
 56 import sun.util.locale.provider.TimeZoneNameUtility;
 57 
 58 /**
 59  * {@code DateFormatSymbols} is a public class for encapsulating
 60  * localizable date-time formatting data, such as the names of the
 61  * months, the names of the days of the week, and the time zone data.
 62  * {@code SimpleDateFormat} uses
 63  * {@code DateFormatSymbols} to encapsulate this information.
 64  *
 65  * &lt;p&gt;
 66  * Typically you shouldn&#39;t use {@code DateFormatSymbols} directly.
 67  * Rather, you are encouraged to create a date-time formatter with the
 68  * {@code DateFormat} class&#39;s factory methods: {@code getTimeInstance},
 69  * {@code getDateInstance}, or {@code getDateTimeInstance}.
 70  * These methods automatically create a {@code DateFormatSymbols} for
 71  * the formatter so that you don&#39;t have to. After the
 72  * formatter is created, you may modify its format pattern using the
 73  * {@code setPattern} method. For more information about
 74  * creating formatters using {@code DateFormat}&#39;s factory methods,
 75  * see {@link DateFormat}.
 76  *
 77  * &lt;p&gt;
 78  * If you decide to create a date-time formatter with a specific
 79  * format pattern for a specific locale, you can do so with:
 80  * &lt;blockquote&gt;
 81  * &lt;pre&gt;
 82  * new SimpleDateFormat(aPattern, DateFormatSymbols.getInstance(aLocale)).
 83  * &lt;/pre&gt;
 84  * &lt;/blockquote&gt;
 85  *
 86  * &lt;p&gt;If the locale contains &quot;rg&quot; (region override)
 87  * &lt;a href=&quot;../util/Locale.html#def_locale_extension&quot;&gt;Unicode extension&lt;/a&gt;,
 88  * the symbols are overridden for the designated region.
 89  *
 90  * &lt;p&gt;
 91  * {@code DateFormatSymbols} objects are cloneable. When you obtain
 92  * a {@code DateFormatSymbols} object, feel free to modify the
 93  * date-time formatting data. For instance, you can replace the localized
 94  * date-time format pattern characters with the ones that you feel easy
 95  * to remember. Or you can change the representative cities
 96  * to your favorite ones.
 97  *
 98  * &lt;p&gt;
 99  * New {@code DateFormatSymbols} subclasses may be added to support
100  * {@code SimpleDateFormat} for date-time formatting for additional locales.
<a name="2" id="anc2"></a><span class="line-modified">101 </span>
102  * @see          DateFormat
103  * @see          SimpleDateFormat
104  * @see          java.util.SimpleTimeZone
105  * @author       Chen-Lieh Huang
106  * @since 1.1
107  */
108 public class DateFormatSymbols implements Serializable, Cloneable {
109 
110     /**
111      * Construct a DateFormatSymbols object by loading format data from
112      * resources for the default {@link java.util.Locale.Category#FORMAT FORMAT}
113      * locale. This constructor can only
114      * construct instances for the locales supported by the Java
115      * runtime environment, not for those supported by installed
116      * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
117      * implementations. For full locale coverage, use the
118      * {@link #getInstance(Locale) getInstance} method.
119      * &lt;p&gt;This is equivalent to calling
120      * {@link #DateFormatSymbols(Locale)
121      *     DateFormatSymbols(Locale.getDefault(Locale.Category.FORMAT))}.
122      * @see #getInstance()
123      * @see java.util.Locale#getDefault(java.util.Locale.Category)
124      * @see java.util.Locale.Category#FORMAT
125      * @throws     java.util.MissingResourceException
126      *             if the resources for the default locale cannot be
127      *             found or cannot be loaded.
128      */
129     public DateFormatSymbols()
130     {
131         initializeData(Locale.getDefault(Locale.Category.FORMAT));
132     }
133 
134     /**
135      * Construct a DateFormatSymbols object by loading format data from
136      * resources for the given locale. This constructor can only
137      * construct instances for the locales supported by the Java
138      * runtime environment, not for those supported by installed
139      * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
140      * implementations. For full locale coverage, use the
141      * {@link #getInstance(Locale) getInstance} method.
142      *
143      * @param locale the desired locale
144      * @see #getInstance(Locale)
145      * @throws     java.util.MissingResourceException
146      *             if the resources for the specified locale cannot be
147      *             found or cannot be loaded.
148      */
149     public DateFormatSymbols(Locale locale)
150     {
151         initializeData(locale);
152     }
153 
154     /**
155      * Constructs an uninitialized DateFormatSymbols.
156      */
157     private DateFormatSymbols(boolean flag) {
158     }
159 
160     /**
161      * Era strings. For example: &quot;AD&quot; and &quot;BC&quot;.  An array of 2 strings,
162      * indexed by {@code Calendar.BC} and {@code Calendar.AD}.
163      * @serial
164      */
165     String eras[] = null;
166 
167     /**
168      * Month strings. For example: &quot;January&quot;, &quot;February&quot;, etc.  An array
169      * of 13 strings (some calendars have 13 months), indexed by
170      * {@code Calendar.JANUARY}, {@code Calendar.FEBRUARY}, etc.
171      * @serial
172      */
173     String months[] = null;
174 
175     /**
176      * Short month strings. For example: &quot;Jan&quot;, &quot;Feb&quot;, etc.  An array of
177      * 13 strings (some calendars have 13 months), indexed by
178      * {@code Calendar.JANUARY}, {@code Calendar.FEBRUARY}, etc.
<a name="3" id="anc3"></a><span class="line-removed">179 </span>
180      * @serial
181      */
182     String shortMonths[] = null;
183 
184     /**
185      * Weekday strings. For example: &quot;Sunday&quot;, &quot;Monday&quot;, etc.  An array
186      * of 8 strings, indexed by {@code Calendar.SUNDAY},
187      * {@code Calendar.MONDAY}, etc.
188      * The element {@code weekdays[0]} is ignored.
189      * @serial
190      */
191     String weekdays[] = null;
192 
193     /**
194      * Short weekday strings. For example: &quot;Sun&quot;, &quot;Mon&quot;, etc.  An array
195      * of 8 strings, indexed by {@code Calendar.SUNDAY},
196      * {@code Calendar.MONDAY}, etc.
197      * The element {@code shortWeekdays[0]} is ignored.
198      * @serial
199      */
200     String shortWeekdays[] = null;
201 
202     /**
203      * AM and PM strings. For example: &quot;AM&quot; and &quot;PM&quot;.  An array of
204      * 2 strings, indexed by {@code Calendar.AM} and
205      * {@code Calendar.PM}.
206      * @serial
207      */
208     String ampms[] = null;
209 
210     /**
211      * Localized names of time zones in this locale.  This is a
212      * two-dimensional array of strings of size &lt;em&gt;n&lt;/em&gt; by &lt;em&gt;m&lt;/em&gt;,
213      * where &lt;em&gt;m&lt;/em&gt; is at least 5.  Each of the &lt;em&gt;n&lt;/em&gt; rows is an
214      * entry containing the localized names for a single {@code TimeZone}.
215      * Each such row contains (with {@code i} ranging from
216      * 0..&lt;em&gt;n&lt;/em&gt;-1):
217      * &lt;ul&gt;
218      * &lt;li&gt;{@code zoneStrings[i][0]} - time zone ID&lt;/li&gt;
219      * &lt;li&gt;{@code zoneStrings[i][1]} - long name of zone in standard
220      * time&lt;/li&gt;
221      * &lt;li&gt;{@code zoneStrings[i][2]} - short name of zone in
222      * standard time&lt;/li&gt;
223      * &lt;li&gt;{@code zoneStrings[i][3]} - long name of zone in daylight
224      * saving time&lt;/li&gt;
225      * &lt;li&gt;{@code zoneStrings[i][4]} - short name of zone in daylight
226      * saving time&lt;/li&gt;
227      * &lt;/ul&gt;
228      * The zone ID is &lt;em&gt;not&lt;/em&gt; localized; it&#39;s one of the valid IDs of
229      * the {@link java.util.TimeZone TimeZone} class that are not
230      * &lt;a href=&quot;../util/TimeZone.html#CustomID&quot;&gt;custom IDs&lt;/a&gt;.
231      * All other entries are localized names.
232      * @see java.util.TimeZone
233      * @serial
234      */
235     String zoneStrings[][] = null;
236 
237     /**
238      * Indicates that zoneStrings is set externally with setZoneStrings() method.
239      */
240     transient boolean isZoneStringsSet = false;
241 
242     /**
243      * Unlocalized date-time pattern characters. For example: &#39;y&#39;, &#39;d&#39;, etc.
244      * All locales use the same these unlocalized pattern characters.
245      */
246     static final String  patternChars = &quot;GyMdkHmsSEDFwWahKzZYuXL&quot;;
247 
248     static final int PATTERN_ERA                  =  0; // G
249     static final int PATTERN_YEAR                 =  1; // y
250     static final int PATTERN_MONTH                =  2; // M
251     static final int PATTERN_DAY_OF_MONTH         =  3; // d
252     static final int PATTERN_HOUR_OF_DAY1         =  4; // k
253     static final int PATTERN_HOUR_OF_DAY0         =  5; // H
254     static final int PATTERN_MINUTE               =  6; // m
255     static final int PATTERN_SECOND               =  7; // s
256     static final int PATTERN_MILLISECOND          =  8; // S
257     static final int PATTERN_DAY_OF_WEEK          =  9; // E
258     static final int PATTERN_DAY_OF_YEAR          = 10; // D
259     static final int PATTERN_DAY_OF_WEEK_IN_MONTH = 11; // F
260     static final int PATTERN_WEEK_OF_YEAR         = 12; // w
261     static final int PATTERN_WEEK_OF_MONTH        = 13; // W
262     static final int PATTERN_AM_PM                = 14; // a
263     static final int PATTERN_HOUR1                = 15; // h
264     static final int PATTERN_HOUR0                = 16; // K
265     static final int PATTERN_ZONE_NAME            = 17; // z
266     static final int PATTERN_ZONE_VALUE           = 18; // Z
267     static final int PATTERN_WEEK_YEAR            = 19; // Y
268     static final int PATTERN_ISO_DAY_OF_WEEK      = 20; // u
269     static final int PATTERN_ISO_ZONE             = 21; // X
270     static final int PATTERN_MONTH_STANDALONE     = 22; // L
271 
272     /**
273      * Localized date-time pattern characters. For example, a locale may
274      * wish to use &#39;u&#39; rather than &#39;y&#39; to represent years in its date format
275      * pattern strings.
276      * This string must be exactly 18 characters long, with the index of
277      * the characters described by {@code DateFormat.ERA_FIELD},
278      * {@code DateFormat.YEAR_FIELD}, etc.  Thus, if the string were
279      * &quot;Xz...&quot;, then localized patterns would use &#39;X&#39; for era and &#39;z&#39; for year.
280      * @serial
281      */
282     String  localPatternChars = null;
283 
284     /**
285      * The locale which is used for initializing this DateFormatSymbols object.
286      *
287      * @since 1.6
288      * @serial
289      */
290     Locale locale = null;
291 
292     /* use serialVersionUID from JDK 1.1.4 for interoperability */
293     @java.io.Serial
294     static final long serialVersionUID = -5987973545549424702L;
295 
296     /**
297      * Returns an array of all locales for which the
298      * {@code getInstance} methods of this class can return
299      * localized instances.
300      * The returned array represents the union of locales supported by the
301      * Java runtime and by installed
302      * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
303      * implementations.  It must contain at least a {@code Locale}
304      * instance equal to {@link java.util.Locale#US Locale.US}.
305      *
306      * @return An array of locales for which localized
307      *         {@code DateFormatSymbols} instances are available.
308      * @since 1.6
309      */
310     public static Locale[] getAvailableLocales() {
311         LocaleServiceProviderPool pool=
312             LocaleServiceProviderPool.getPool(DateFormatSymbolsProvider.class);
313         return pool.getAvailableLocales();
314     }
315 
316     /**
317      * Gets the {@code DateFormatSymbols} instance for the default
318      * locale.  This method provides access to {@code DateFormatSymbols}
319      * instances for locales supported by the Java runtime itself as well
320      * as for those supported by installed
321      * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
322      * implementations.
323      * &lt;p&gt;This is equivalent to calling {@link #getInstance(Locale)
324      *     getInstance(Locale.getDefault(Locale.Category.FORMAT))}.
325      * @see java.util.Locale#getDefault(java.util.Locale.Category)
326      * @see java.util.Locale.Category#FORMAT
327      * @return a {@code DateFormatSymbols} instance.
328      * @since 1.6
329      */
330     public static final DateFormatSymbols getInstance() {
331         return getInstance(Locale.getDefault(Locale.Category.FORMAT));
332     }
333 
334     /**
335      * Gets the {@code DateFormatSymbols} instance for the specified
336      * locale.  This method provides access to {@code DateFormatSymbols}
337      * instances for locales supported by the Java runtime itself as well
338      * as for those supported by installed
339      * {@link java.text.spi.DateFormatSymbolsProvider DateFormatSymbolsProvider}
340      * implementations.
341      * @param locale the given locale.
342      * @return a {@code DateFormatSymbols} instance.
343      * @throws    NullPointerException if {@code locale} is null
344      * @since 1.6
345      */
346     public static final DateFormatSymbols getInstance(Locale locale) {
347         DateFormatSymbols dfs = getProviderInstance(locale);
348         if (dfs != null) {
349             return dfs;
350         }
351         throw new RuntimeException(&quot;DateFormatSymbols instance creation failed.&quot;);
352     }
353 
354     /**
355      * Returns a DateFormatSymbols provided by a provider or found in
356      * the cache. Note that this method returns a cached instance,
357      * not its clone. Therefore, the instance should never be given to
358      * an application.
359      */
360     static final DateFormatSymbols getInstanceRef(Locale locale) {
361         DateFormatSymbols dfs = getProviderInstance(locale);
362         if (dfs != null) {
363             return dfs;
364         }
365         throw new RuntimeException(&quot;DateFormatSymbols instance creation failed.&quot;);
366     }
367 
368     private static DateFormatSymbols getProviderInstance(Locale locale) {
369         LocaleProviderAdapter adapter = LocaleProviderAdapter.getAdapter(DateFormatSymbolsProvider.class, locale);
370         DateFormatSymbolsProvider provider = adapter.getDateFormatSymbolsProvider();
371         DateFormatSymbols dfsyms = provider.getInstance(locale);
372         if (dfsyms == null) {
373             provider = LocaleProviderAdapter.forJRE().getDateFormatSymbolsProvider();
374             dfsyms = provider.getInstance(locale);
375         }
376         return dfsyms;
377     }
378 
379     /**
380      * Gets era strings. For example: &quot;AD&quot; and &quot;BC&quot;.
381      * @return the era strings.
382      */
383     public String[] getEras() {
384         return Arrays.copyOf(eras, eras.length);
385     }
386 
387     /**
388      * Sets era strings. For example: &quot;AD&quot; and &quot;BC&quot;.
389      * @param newEras the new era strings.
390      */
391     public void setEras(String[] newEras) {
392         eras = Arrays.copyOf(newEras, newEras.length);
393         cachedHashCode = 0;
394     }
395 
396     /**
397      * Gets month strings. For example: &quot;January&quot;, &quot;February&quot;, etc.
398      * An array with either 12 or 13 elements will be returned depending
399      * on whether or not {@link java.util.Calendar#UNDECIMBER Calendar.UNDECIMBER}
400      * is supported. Use
401      * {@link java.util.Calendar#JANUARY Calendar.JANUARY},
402      * {@link java.util.Calendar#FEBRUARY Calendar.FEBRUARY},
403      * etc. to index the result array.
404      *
405      * &lt;p&gt;If the language requires different forms for formatting and
406      * stand-alone usages, this method returns month names in the
407      * formatting form. For example, the preferred month name for
408      * January in the Czech language is &lt;em&gt;ledna&lt;/em&gt; in the
409      * formatting form, while it is &lt;em&gt;leden&lt;/em&gt; in the stand-alone
410      * form. This method returns {@code &quot;ledna&quot;} in this case. Refer
411      * to the &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;
412      * Calendar Elements in the Unicode Locale Data Markup Language
413      * (LDML) specification&lt;/a&gt; for more details.
414      *
415      * @implSpec This method returns 13 elements since
416      * {@link java.util.Calendar#UNDECIMBER Calendar.UNDECIMBER} is supported.
417      * @return the month strings.
418      */
419     public String[] getMonths() {
420         return Arrays.copyOf(months, months.length);
421     }
422 
423     /**
424      * Sets month strings. For example: &quot;January&quot;, &quot;February&quot;, etc.
425      * @param newMonths the new month strings. The array should
426      * be indexed by {@link java.util.Calendar#JANUARY Calendar.JANUARY},
427      * {@link java.util.Calendar#FEBRUARY Calendar.FEBRUARY}, etc.
428      */
429     public void setMonths(String[] newMonths) {
430         months = Arrays.copyOf(newMonths, newMonths.length);
431         cachedHashCode = 0;
432     }
433 
434     /**
435      * Gets short month strings. For example: &quot;Jan&quot;, &quot;Feb&quot;, etc.
436      * An array with either 12 or 13 elements will be returned depending
437      * on whether or not {@link java.util.Calendar#UNDECIMBER Calendar.UNDECIMBER}
438      * is supported. Use
439      * {@link java.util.Calendar#JANUARY Calendar.JANUARY},
440      * {@link java.util.Calendar#FEBRUARY Calendar.FEBRUARY},
441      * etc. to index the result array.
442      *
443      * &lt;p&gt;If the language requires different forms for formatting and
444      * stand-alone usages, this method returns short month names in
445      * the formatting form. For example, the preferred abbreviation
446      * for January in the Catalan language is &lt;em&gt;de gen.&lt;/em&gt; in the
447      * formatting form, while it is &lt;em&gt;gen.&lt;/em&gt; in the stand-alone
448      * form. This method returns {@code &quot;de gen.&quot;} in this case. Refer
449      * to the &lt;a href=&quot;http://unicode.org/reports/tr35/#Calendar_Elements&quot;&gt;
450      * Calendar Elements in the Unicode Locale Data Markup Language
451      * (LDML) specification&lt;/a&gt; for more details.
452      *
453      * @implSpec This method returns 13 elements since
454      * {@link java.util.Calendar#UNDECIMBER Calendar.UNDECIMBER} is supported.
455      * @return the short month strings.
456      */
457     public String[] getShortMonths() {
458         return Arrays.copyOf(shortMonths, shortMonths.length);
459     }
460 
461     /**
462      * Sets short month strings. For example: &quot;Jan&quot;, &quot;Feb&quot;, etc.
463      * @param newShortMonths the new short month strings. The array should
464      * be indexed by {@link java.util.Calendar#JANUARY Calendar.JANUARY},
465      * {@link java.util.Calendar#FEBRUARY Calendar.FEBRUARY}, etc.
466      */
467     public void setShortMonths(String[] newShortMonths) {
468         shortMonths = Arrays.copyOf(newShortMonths, newShortMonths.length);
469         cachedHashCode = 0;
470     }
471 
472     /**
473      * Gets weekday strings. For example: &quot;Sunday&quot;, &quot;Monday&quot;, etc.
474      * @return the weekday strings. Use
475      * {@link java.util.Calendar#SUNDAY Calendar.SUNDAY},
476      * {@link java.util.Calendar#MONDAY Calendar.MONDAY}, etc. to index
477      * the result array.
478      */
479     public String[] getWeekdays() {
480         return Arrays.copyOf(weekdays, weekdays.length);
481     }
482 
483     /**
484      * Sets weekday strings. For example: &quot;Sunday&quot;, &quot;Monday&quot;, etc.
485      * @param newWeekdays the new weekday strings. The array should
486      * be indexed by {@link java.util.Calendar#SUNDAY Calendar.SUNDAY},
487      * {@link java.util.Calendar#MONDAY Calendar.MONDAY}, etc.
488      */
489     public void setWeekdays(String[] newWeekdays) {
490         weekdays = Arrays.copyOf(newWeekdays, newWeekdays.length);
491         cachedHashCode = 0;
492     }
493 
494     /**
495      * Gets short weekday strings. For example: &quot;Sun&quot;, &quot;Mon&quot;, etc.
496      * @return the short weekday strings. Use
497      * {@link java.util.Calendar#SUNDAY Calendar.SUNDAY},
498      * {@link java.util.Calendar#MONDAY Calendar.MONDAY}, etc. to index
499      * the result array.
500      */
501     public String[] getShortWeekdays() {
502         return Arrays.copyOf(shortWeekdays, shortWeekdays.length);
503     }
504 
505     /**
506      * Sets short weekday strings. For example: &quot;Sun&quot;, &quot;Mon&quot;, etc.
507      * @param newShortWeekdays the new short weekday strings. The array should
508      * be indexed by {@link java.util.Calendar#SUNDAY Calendar.SUNDAY},
509      * {@link java.util.Calendar#MONDAY Calendar.MONDAY}, etc.
510      */
511     public void setShortWeekdays(String[] newShortWeekdays) {
512         shortWeekdays = Arrays.copyOf(newShortWeekdays, newShortWeekdays.length);
513         cachedHashCode = 0;
514     }
515 
516     /**
517      * Gets ampm strings. For example: &quot;AM&quot; and &quot;PM&quot;.
518      * @return the ampm strings.
519      */
520     public String[] getAmPmStrings() {
521         return Arrays.copyOf(ampms, ampms.length);
522     }
523 
524     /**
525      * Sets ampm strings. For example: &quot;AM&quot; and &quot;PM&quot;.
526      * @param newAmpms the new ampm strings.
527      */
528     public void setAmPmStrings(String[] newAmpms) {
529         ampms = Arrays.copyOf(newAmpms, newAmpms.length);
530         cachedHashCode = 0;
531     }
532 
533     /**
534      * Gets time zone strings.  Use of this method is discouraged; use
535      * {@link java.util.TimeZone#getDisplayName() TimeZone.getDisplayName()}
536      * instead.
537      * &lt;p&gt;
538      * The value returned is a
539      * two-dimensional array of strings of size &lt;em&gt;n&lt;/em&gt; by &lt;em&gt;m&lt;/em&gt;,
540      * where &lt;em&gt;m&lt;/em&gt; is at least 5.  Each of the &lt;em&gt;n&lt;/em&gt; rows is an
541      * entry containing the localized names for a single {@code TimeZone}.
542      * Each such row contains (with {@code i} ranging from
543      * 0..&lt;em&gt;n&lt;/em&gt;-1):
544      * &lt;ul&gt;
545      * &lt;li&gt;{@code zoneStrings[i][0]} - time zone ID&lt;/li&gt;
546      * &lt;li&gt;{@code zoneStrings[i][1]} - long name of zone in standard
547      * time&lt;/li&gt;
548      * &lt;li&gt;{@code zoneStrings[i][2]} - short name of zone in
549      * standard time&lt;/li&gt;
550      * &lt;li&gt;{@code zoneStrings[i][3]} - long name of zone in daylight
551      * saving time&lt;/li&gt;
552      * &lt;li&gt;{@code zoneStrings[i][4]} - short name of zone in daylight
553      * saving time&lt;/li&gt;
554      * &lt;/ul&gt;
555      * The zone ID is &lt;em&gt;not&lt;/em&gt; localized; it&#39;s one of the valid IDs of
556      * the {@link java.util.TimeZone TimeZone} class that are not
557      * &lt;a href=&quot;../util/TimeZone.html#CustomID&quot;&gt;custom IDs&lt;/a&gt;.
558      * All other entries are localized names.  If a zone does not implement
559      * daylight saving time, the daylight saving time names should not be used.
560      * &lt;p&gt;
561      * If {@link #setZoneStrings(String[][]) setZoneStrings} has been called
562      * on this {@code DateFormatSymbols} instance, then the strings
563      * provided by that call are returned. Otherwise, the returned array
564      * contains names provided by the Java runtime and by installed
565      * {@link java.util.spi.TimeZoneNameProvider TimeZoneNameProvider}
566      * implementations.
567      *
568      * @return the time zone strings.
569      * @see #setZoneStrings(String[][])
570      */
571     public String[][] getZoneStrings() {
572         return getZoneStringsImpl(true);
573     }
574 
575     /**
576      * Sets time zone strings.  The argument must be a
577      * two-dimensional array of strings of size &lt;em&gt;n&lt;/em&gt; by &lt;em&gt;m&lt;/em&gt;,
578      * where &lt;em&gt;m&lt;/em&gt; is at least 5.  Each of the &lt;em&gt;n&lt;/em&gt; rows is an
579      * entry containing the localized names for a single {@code TimeZone}.
580      * Each such row contains (with {@code i} ranging from
581      * 0..&lt;em&gt;n&lt;/em&gt;-1):
582      * &lt;ul&gt;
583      * &lt;li&gt;{@code zoneStrings[i][0]} - time zone ID&lt;/li&gt;
584      * &lt;li&gt;{@code zoneStrings[i][1]} - long name of zone in standard
585      * time&lt;/li&gt;
586      * &lt;li&gt;{@code zoneStrings[i][2]} - short name of zone in
587      * standard time&lt;/li&gt;
588      * &lt;li&gt;{@code zoneStrings[i][3]} - long name of zone in daylight
589      * saving time&lt;/li&gt;
590      * &lt;li&gt;{@code zoneStrings[i][4]} - short name of zone in daylight
591      * saving time&lt;/li&gt;
592      * &lt;/ul&gt;
593      * The zone ID is &lt;em&gt;not&lt;/em&gt; localized; it&#39;s one of the valid IDs of
594      * the {@link java.util.TimeZone TimeZone} class that are not
595      * &lt;a href=&quot;../util/TimeZone.html#CustomID&quot;&gt;custom IDs&lt;/a&gt;.
596      * All other entries are localized names.
597      *
598      * @param newZoneStrings the new time zone strings.
599      * @throws    IllegalArgumentException if the length of any row in
600      *    {@code newZoneStrings} is less than 5
601      * @throws    NullPointerException if {@code newZoneStrings} is null
602      * @see #getZoneStrings()
603      */
604     public void setZoneStrings(String[][] newZoneStrings) {
605         String[][] aCopy = new String[newZoneStrings.length][];
606         for (int i = 0; i &lt; newZoneStrings.length; ++i) {
607             int len = newZoneStrings[i].length;
608             if (len &lt; 5) {
609                 throw new IllegalArgumentException();
610             }
611             aCopy[i] = Arrays.copyOf(newZoneStrings[i], len);
612         }
613         zoneStrings = aCopy;
614         isZoneStringsSet = true;
615         cachedHashCode = 0;
616     }
617 
618     /**
619      * Gets localized date-time pattern characters. For example: &#39;u&#39;, &#39;t&#39;, etc.
620      * @return the localized date-time pattern characters.
621      */
622     public String getLocalPatternChars() {
623         return localPatternChars;
624     }
625 
626     /**
627      * Sets localized date-time pattern characters. For example: &#39;u&#39;, &#39;t&#39;, etc.
628      * @param newLocalPatternChars the new localized date-time
629      * pattern characters.
630      */
631     public void setLocalPatternChars(String newLocalPatternChars) {
632         // Call toString() to throw an NPE in case the argument is null
633         localPatternChars = newLocalPatternChars.toString();
634         cachedHashCode = 0;
635     }
636 
637     /**
638      * Overrides Cloneable
639      */
640     public Object clone()
641     {
642         try
643         {
644             DateFormatSymbols other = (DateFormatSymbols)super.clone();
645             copyMembers(this, other);
646             return other;
647         } catch (CloneNotSupportedException e) {
648             throw new InternalError(e);
649         }
650     }
651 
652     /**
653      * Override hashCode.
654      * Generates a hash code for the DateFormatSymbols object.
655      */
656     @Override
657     public int hashCode() {
658         int hashCode = cachedHashCode;
659         if (hashCode == 0) {
660             hashCode = 5;
661             hashCode = 11 * hashCode + Arrays.hashCode(eras);
662             hashCode = 11 * hashCode + Arrays.hashCode(months);
663             hashCode = 11 * hashCode + Arrays.hashCode(shortMonths);
664             hashCode = 11 * hashCode + Arrays.hashCode(weekdays);
665             hashCode = 11 * hashCode + Arrays.hashCode(shortWeekdays);
666             hashCode = 11 * hashCode + Arrays.hashCode(ampms);
667             hashCode = 11 * hashCode + Arrays.deepHashCode(getZoneStringsWrapper());
668             hashCode = 11 * hashCode + Objects.hashCode(localPatternChars);
669             if (hashCode != 0) {
670                 cachedHashCode = hashCode;
671             }
672         }
673 
674         return hashCode;
675     }
676 
677     /**
678      * Override equals
679      */
680     public boolean equals(Object obj)
681     {
682         if (this == obj) return true;
683         if (obj == null || getClass() != obj.getClass()) return false;
684         DateFormatSymbols that = (DateFormatSymbols) obj;
685         return (Arrays.equals(eras, that.eras)
686                 &amp;&amp; Arrays.equals(months, that.months)
687                 &amp;&amp; Arrays.equals(shortMonths, that.shortMonths)
688                 &amp;&amp; Arrays.equals(weekdays, that.weekdays)
689                 &amp;&amp; Arrays.equals(shortWeekdays, that.shortWeekdays)
690                 &amp;&amp; Arrays.equals(ampms, that.ampms)
691                 &amp;&amp; Arrays.deepEquals(getZoneStringsWrapper(), that.getZoneStringsWrapper())
692                 &amp;&amp; ((localPatternChars != null
693                   &amp;&amp; localPatternChars.equals(that.localPatternChars))
694                  || (localPatternChars == null
695                   &amp;&amp; that.localPatternChars == null)));
696     }
697 
698     // =======================privates===============================
699 
700     /**
701      * Useful constant for defining time zone offsets.
702      */
703     static final int millisPerHour = 60*60*1000;
704 
705     /**
706      * Cache to hold DateFormatSymbols instances per Locale.
707      */
708     private static final ConcurrentMap&lt;Locale, SoftReference&lt;DateFormatSymbols&gt;&gt; cachedInstances
709         = new ConcurrentHashMap&lt;&gt;(3);
710 
711     private transient int lastZoneIndex;
712 
713     /**
714      * Cached hash code
715      */
716     transient volatile int cachedHashCode;
717 
718     /**
719      * Initializes this DateFormatSymbols with the locale data. This method uses
720      * a cached DateFormatSymbols instance for the given locale if available. If
721      * there&#39;s no cached one, this method creates an uninitialized instance and
722      * populates its fields from the resource bundle for the locale, and caches
723      * the instance. Note: zoneStrings isn&#39;t initialized in this method.
724      */
725     private void initializeData(Locale locale) {
726         SoftReference&lt;DateFormatSymbols&gt; ref = cachedInstances.get(locale);
727         DateFormatSymbols dfs;
728         if (ref == null || (dfs = ref.get()) == null) {
729             if (ref != null) {
730                 // Remove the empty SoftReference
731                 cachedInstances.remove(locale, ref);
732             }
733             dfs = new DateFormatSymbols(false);
734 
735             // check for region override
736             Locale override = CalendarDataUtility.findRegionOverride(locale);
737 
738             // Initialize the fields from the ResourceBundle for locale.
739             LocaleProviderAdapter adapter
740                 = LocaleProviderAdapter.getAdapter(DateFormatSymbolsProvider.class, override);
741             // Avoid any potential recursions
742             if (!(adapter instanceof ResourceBundleBasedAdapter)) {
743                 adapter = LocaleProviderAdapter.getResourceBundleBased();
744             }
745             ResourceBundle resource
746                 = ((ResourceBundleBasedAdapter)adapter).getLocaleData().getDateFormatData(override);
747 
748             dfs.locale = locale;
749             // JRE and CLDR use different keys
750             // JRE: Eras, short.Eras and narrow.Eras
751             // CLDR: long.Eras, Eras and narrow.Eras
752             if (resource.containsKey(&quot;Eras&quot;)) {
753                 dfs.eras = resource.getStringArray(&quot;Eras&quot;);
754             } else if (resource.containsKey(&quot;long.Eras&quot;)) {
755                 dfs.eras = resource.getStringArray(&quot;long.Eras&quot;);
756             } else if (resource.containsKey(&quot;short.Eras&quot;)) {
757                 dfs.eras = resource.getStringArray(&quot;short.Eras&quot;);
758             }
759             dfs.months = resource.getStringArray(&quot;MonthNames&quot;);
760             dfs.shortMonths = resource.getStringArray(&quot;MonthAbbreviations&quot;);
761             dfs.ampms = resource.getStringArray(&quot;AmPmMarkers&quot;);
762             dfs.localPatternChars = resource.getString(&quot;DateTimePatternChars&quot;);
763 
764             // Day of week names are stored in a 1-based array.
765             dfs.weekdays = toOneBasedArray(resource.getStringArray(&quot;DayNames&quot;));
766             dfs.shortWeekdays = toOneBasedArray(resource.getStringArray(&quot;DayAbbreviations&quot;));
767 
768             // Put dfs in the cache
769             ref = new SoftReference&lt;&gt;(dfs);
770             SoftReference&lt;DateFormatSymbols&gt; x = cachedInstances.putIfAbsent(locale, ref);
771             if (x != null) {
772                 DateFormatSymbols y = x.get();
773                 if (y == null) {
774                     // Replace the empty SoftReference with ref.
775                     cachedInstances.replace(locale, x, ref);
776                 } else {
777                     ref = x;
778                     dfs = y;
779                 }
780             }
781         }
782 
783         // Copy the field values from dfs to this instance.
784         copyMembers(dfs, this);
785     }
786 
787     private static String[] toOneBasedArray(String[] src) {
788         int len = src.length;
789         String[] dst = new String[len + 1];
790         dst[0] = &quot;&quot;;
791         for (int i = 0; i &lt; len; i++) {
792             dst[i + 1] = src[i];
793         }
794         return dst;
795     }
796 
797     /**
798      * Package private: used by SimpleDateFormat
799      * Gets the index for the given time zone ID to obtain the time zone
800      * strings for formatting. The time zone ID is just for programmatic
801      * lookup. NOT LOCALIZED!!!
802      * @param ID the given time zone ID.
803      * @return the index of the given time zone ID.  Returns -1 if
804      * the given time zone ID can&#39;t be located in the DateFormatSymbols object.
805      * @see java.util.SimpleTimeZone
806      */
807     final int getZoneIndex(String ID) {
808         String[][] zoneStrings = getZoneStringsWrapper();
809 
810         /*
811          * getZoneIndex has been re-written for performance reasons. instead of
812          * traversing the zoneStrings array every time, we cache the last used zone
813          * index
814          */
815         if (lastZoneIndex &lt; zoneStrings.length &amp;&amp; ID.equals(zoneStrings[lastZoneIndex][0])) {
816             return lastZoneIndex;
817         }
818 
819         /* slow path, search entire list */
820         for (int index = 0; index &lt; zoneStrings.length; index++) {
821             if (ID.equals(zoneStrings[index][0])) {
822                 lastZoneIndex = index;
823                 return index;
824             }
825         }
826 
827         return -1;
828     }
829 
830     /**
831      * Wrapper method to the getZoneStrings(), which is called from inside
832      * the java.text package and not to mutate the returned arrays, so that
833      * it does not need to create a defensive copy.
834      */
835     final String[][] getZoneStringsWrapper() {
836         if (isSubclassObject()) {
837             return getZoneStrings();
838         } else {
839             return getZoneStringsImpl(false);
840         }
841     }
842 
843     private String[][] getZoneStringsImpl(boolean needsCopy) {
844         if (zoneStrings == null) {
845             zoneStrings = TimeZoneNameUtility.getZoneStrings(locale);
846         }
847 
848         if (!needsCopy) {
849             return zoneStrings;
850         }
851 
852         int len = zoneStrings.length;
853         String[][] aCopy = new String[len][];
854         for (int i = 0; i &lt; len; i++) {
855             aCopy[i] = Arrays.copyOf(zoneStrings[i], zoneStrings[i].length);
856         }
857         return aCopy;
858     }
859 
860     private boolean isSubclassObject() {
861         return !getClass().getName().equals(&quot;java.text.DateFormatSymbols&quot;);
862     }
863 
864     /**
865      * Clones all the data members from the source DateFormatSymbols to
866      * the target DateFormatSymbols.
867      *
868      * @param src the source DateFormatSymbols.
869      * @param dst the target DateFormatSymbols.
870      */
871     private void copyMembers(DateFormatSymbols src, DateFormatSymbols dst)
872     {
873         dst.locale = src.locale;
874         dst.eras = Arrays.copyOf(src.eras, src.eras.length);
875         dst.months = Arrays.copyOf(src.months, src.months.length);
876         dst.shortMonths = Arrays.copyOf(src.shortMonths, src.shortMonths.length);
877         dst.weekdays = Arrays.copyOf(src.weekdays, src.weekdays.length);
878         dst.shortWeekdays = Arrays.copyOf(src.shortWeekdays, src.shortWeekdays.length);
879         dst.ampms = Arrays.copyOf(src.ampms, src.ampms.length);
880         if (src.zoneStrings != null) {
881             dst.zoneStrings = src.getZoneStringsImpl(true);
882         } else {
883             dst.zoneStrings = null;
884         }
885         dst.localPatternChars = src.localPatternChars;
886         dst.cachedHashCode = 0;
887     }
888 
889     /**
890      * Write out the default serializable data, after ensuring the
891      * {@code zoneStrings} field is initialized in order to make
892      * sure the backward compatibility.
893      *
894      * @since 1.6
895      */
896     @java.io.Serial
897     private void writeObject(ObjectOutputStream stream) throws IOException {
898         if (zoneStrings == null) {
899             zoneStrings = TimeZoneNameUtility.getZoneStrings(locale);
900         }
901         stream.defaultWriteObject();
902     }
903 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
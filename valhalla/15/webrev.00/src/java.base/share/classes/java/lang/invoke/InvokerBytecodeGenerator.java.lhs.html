<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.org.objectweb.asm.ClassWriter;
  29 import jdk.internal.org.objectweb.asm.Label;
  30 import jdk.internal.org.objectweb.asm.MethodVisitor;
  31 import jdk.internal.org.objectweb.asm.Opcodes;
  32 import jdk.internal.org.objectweb.asm.Type;
  33 import sun.invoke.util.VerifyAccess;
  34 import sun.invoke.util.VerifyType;
  35 import sun.invoke.util.Wrapper;
  36 import sun.reflect.misc.ReflectUtil;
  37 
  38 import java.io.File;
  39 import java.io.FileOutputStream;
  40 import java.io.IOException;
  41 import java.lang.reflect.Modifier;
  42 import java.util.ArrayList;
  43 import java.util.Arrays;
  44 import java.util.HashMap;
  45 import java.util.stream.Stream;
  46 
  47 import static java.lang.invoke.LambdaForm.BasicType;
  48 import static java.lang.invoke.LambdaForm.BasicType.*;
  49 import static java.lang.invoke.LambdaForm.*;
  50 import static java.lang.invoke.MethodHandleNatives.Constants.*;
  51 import static java.lang.invoke.MethodHandleStatics.*;
  52 
  53 /**
  54  * Code generation backend for LambdaForm.
  55  * &lt;p&gt;
  56  * @author John Rose, JSR 292 EG
  57  */
  58 class InvokerBytecodeGenerator {
  59     /** Define class names for convenience. */
  60     private static final String MH      = &quot;java/lang/invoke/MethodHandle&quot;;
  61     private static final String MHI     = &quot;java/lang/invoke/MethodHandleImpl&quot;;
  62     private static final String LF      = &quot;java/lang/invoke/LambdaForm&quot;;
  63     private static final String LFN     = &quot;java/lang/invoke/LambdaForm$Name&quot;;
  64     private static final String CLS     = &quot;java/lang/Class&quot;;
  65     private static final String OBJ     = &quot;java/lang/Object&quot;;
  66     private static final String OBJARY  = &quot;[Ljava/lang/Object;&quot;;
  67 
  68     private static final String LOOP_CLAUSES = MHI + &quot;$LoopClauses&quot;;
  69     private static final String MHARY2       = &quot;[[L&quot; + MH + &quot;;&quot;;
  70 
  71     private static final String LF_SIG  = &quot;L&quot; + LF + &quot;;&quot;;
  72     private static final String LFN_SIG = &quot;L&quot; + LFN + &quot;;&quot;;
  73     private static final String LL_SIG  = &quot;(L&quot; + OBJ + &quot;;)L&quot; + OBJ + &quot;;&quot;;
  74     private static final String LLV_SIG = &quot;(L&quot; + OBJ + &quot;;L&quot; + OBJ + &quot;;)V&quot;;
  75     private static final String CLASS_PREFIX = LF + &quot;$&quot;;
  76     private static final String SOURCE_PREFIX = &quot;LambdaForm$&quot;;
  77 
  78     /** Name of its super class*/
  79     static final String INVOKER_SUPER_NAME = OBJ;
  80 
  81     /** Name of new class */
  82     private final String className;
  83 
  84     private final LambdaForm lambdaForm;
  85     private final String     invokerName;
  86     private final MethodType invokerType;
  87 
  88     /** Info about local variables in compiled lambda form */
  89     private int[]       localsMap;    // index
  90     private Class&lt;?&gt;[]  localClasses; // type
  91 
  92     /** ASM bytecode generation. */
  93     private ClassWriter cw;
  94     private MethodVisitor mv;
  95 
  96     /** Single element internal class name lookup cache. */
  97     private Class&lt;?&gt; lastClass;
  98     private String lastInternalName;
  99 
 100     private static final MemberName.Factory MEMBERNAME_FACTORY = MemberName.getFactory();
 101     private static final Class&lt;?&gt; HOST_CLASS = LambdaForm.class;
 102 
 103     /** Main constructor; other constructors delegate to this one. */
 104     private InvokerBytecodeGenerator(LambdaForm lambdaForm, int localsMapSize,
 105                                      String className, String invokerName, MethodType invokerType) {
 106         int p = invokerName.indexOf(&#39;.&#39;);
 107         if (p &gt; -1) {
 108             className = invokerName.substring(0, p);
 109             invokerName = invokerName.substring(p + 1);
 110         }
 111         if (DUMP_CLASS_FILES) {
 112             className = makeDumpableClassName(className);
 113         }
 114         this.className  = className;
 115         this.lambdaForm = lambdaForm;
 116         this.invokerName = invokerName;
 117         this.invokerType = invokerType;
 118         this.localsMap = new int[localsMapSize+1]; // last entry of localsMap is count of allocated local slots
 119         this.localClasses = new Class&lt;?&gt;[localsMapSize+1];
 120     }
 121 
 122     /** For generating LambdaForm interpreter entry points. */
 123     private InvokerBytecodeGenerator(String className, String invokerName, MethodType invokerType) {
 124         this(null, invokerType.parameterCount(),
 125              className, invokerName, invokerType);
 126         MethodType mt = invokerType.erase();
 127         // Create an array to map name indexes to locals indexes.
 128         localsMap[0] = 0; // localsMap has at least one element
 129         for (int i = 1, index = 0; i &lt; localsMap.length; i++) {
 130             Wrapper w = Wrapper.forBasicType(mt.parameterType(i - 1));
 131             index += w.stackSlots();
 132             localsMap[i] = index;
 133         }
 134     }
 135 
 136     /** For generating customized code for a single LambdaForm. */
 137     private InvokerBytecodeGenerator(String className, LambdaForm form, MethodType invokerType) {
 138         this(className, form.lambdaName(), form, invokerType);
 139     }
 140 
 141     /** For generating customized code for a single LambdaForm. */
 142     InvokerBytecodeGenerator(String className, String invokerName,
 143             LambdaForm form, MethodType invokerType) {
 144         this(form, form.names.length,
 145              className, invokerName, invokerType);
 146         // Create an array to map name indexes to locals indexes.
 147         Name[] names = form.names;
 148         for (int i = 0, index = 0; i &lt; localsMap.length; i++) {
 149             localsMap[i] = index;
 150             if (i &lt; names.length) {
 151                 BasicType type = names[i].type();
 152                 index += type.basicTypeSlots();
 153             }
 154         }
 155     }
 156 
 157     /** instance counters for dumped classes */
 158     private static final HashMap&lt;String,Integer&gt; DUMP_CLASS_FILES_COUNTERS;
 159     /** debugging flag for saving generated class files */
 160     private static final File DUMP_CLASS_FILES_DIR;
 161 
 162     static {
 163         if (DUMP_CLASS_FILES) {
 164             DUMP_CLASS_FILES_COUNTERS = new HashMap&lt;&gt;();
 165             try {
 166                 File dumpDir = new File(&quot;DUMP_CLASS_FILES&quot;);
 167                 if (!dumpDir.exists()) {
 168                     dumpDir.mkdirs();
 169                 }
 170                 DUMP_CLASS_FILES_DIR = dumpDir;
 171                 System.out.println(&quot;Dumping class files to &quot;+DUMP_CLASS_FILES_DIR+&quot;/...&quot;);
 172             } catch (Exception e) {
 173                 throw newInternalError(e);
 174             }
 175         } else {
 176             DUMP_CLASS_FILES_COUNTERS = null;
 177             DUMP_CLASS_FILES_DIR = null;
 178         }
 179     }
 180 
 181     private void maybeDump(final byte[] classFile) {
 182         if (DUMP_CLASS_FILES) {
 183             maybeDump(CLASS_PREFIX + className, classFile);
 184         }
 185     }
 186 
 187     // Also used from BoundMethodHandle
 188     static void maybeDump(final String className, final byte[] classFile) {
 189         if (DUMP_CLASS_FILES) {
 190             java.security.AccessController.doPrivileged(
 191             new java.security.PrivilegedAction&lt;&gt;() {
 192                 public Void run() {
 193                     try {
 194                         String dumpName = className.replace(&#39;.&#39;,&#39;/&#39;);
 195                         File dumpFile = new File(DUMP_CLASS_FILES_DIR, dumpName+&quot;.class&quot;);
 196                         System.out.println(&quot;dump: &quot; + dumpFile);
 197                         dumpFile.getParentFile().mkdirs();
 198                         FileOutputStream file = new FileOutputStream(dumpFile);
 199                         file.write(classFile);
 200                         file.close();
 201                         return null;
 202                     } catch (IOException ex) {
 203                         throw newInternalError(ex);
 204                     }
 205                 }
 206             });
 207         }
 208     }
 209 
 210     private static String makeDumpableClassName(String className) {
 211         Integer ctr;
 212         synchronized (DUMP_CLASS_FILES_COUNTERS) {
 213             ctr = DUMP_CLASS_FILES_COUNTERS.get(className);
 214             if (ctr == null)  ctr = 0;
 215             DUMP_CLASS_FILES_COUNTERS.put(className, ctr+1);
 216         }
 217         String sfx = ctr.toString();
 218         while (sfx.length() &lt; 3)
 219             sfx = &quot;0&quot;+sfx;
 220         className += sfx;
 221         return className;
 222     }
 223 
 224     class CpPatch {
 225         final int index;
 226         final Object value;
 227         CpPatch(int index, Object value) {
 228             this.index = index;
 229             this.value = value;
 230         }
 231         public String toString() {
 232             return &quot;CpPatch/index=&quot;+index+&quot;,value=&quot;+value;
 233         }
 234     }
 235 
 236     private final ArrayList&lt;CpPatch&gt; cpPatches = new ArrayList&lt;&gt;();
 237 
 238     private int cph = 0;  // for counting constant placeholders
 239 
 240     String constantPlaceholder(Object arg) {
 241         String cpPlaceholder = &quot;CONSTANT_PLACEHOLDER_&quot; + cph++;
 242         if (DUMP_CLASS_FILES) cpPlaceholder += &quot; &lt;&lt;&quot; + debugString(arg) + &quot;&gt;&gt;&quot;;
 243         // TODO check if arg is already in the constant pool
 244         // insert placeholder in CP and remember the patch
 245         int index = cw.newConst((Object) cpPlaceholder);
 246         cpPatches.add(new CpPatch(index, arg));
 247         return cpPlaceholder;
 248     }
 249 
 250     Object[] cpPatches(byte[] classFile) {
 251         int size = getConstantPoolSize(classFile);
 252         Object[] res = new Object[size];
 253         for (CpPatch p : cpPatches) {
 254             if (p.index &gt;= size)
 255                 throw new InternalError(&quot;in cpool[&quot;+size+&quot;]: &quot;+p+&quot;\n&quot;+Arrays.toString(Arrays.copyOf(classFile, 20)));
 256             res[p.index] = p.value;
 257         }
 258         return res;
 259     }
 260 
 261     private static String debugString(Object arg) {
 262         if (arg instanceof MethodHandle) {
 263             MethodHandle mh = (MethodHandle) arg;
 264             MemberName member = mh.internalMemberName();
 265             if (member != null)
 266                 return member.toString();
 267             return mh.debugString();
 268         }
 269         return arg.toString();
 270     }
 271 
 272     /**
 273      * Extract the number of constant pool entries from a given class file.
 274      *
 275      * @param classFile the bytes of the class file in question.
 276      * @return the number of entries in the constant pool.
 277      */
 278     private static int getConstantPoolSize(byte[] classFile) {
 279         // The first few bytes:
 280         // u4 magic;
 281         // u2 minor_version;
 282         // u2 major_version;
 283         // u2 constant_pool_count;
 284         return ((classFile[8] &amp; 0xFF) &lt;&lt; 8) | (classFile[9] &amp; 0xFF);
 285     }
 286 
 287     /**
 288      * Extract the MemberName of a newly-defined method.
 289      */
 290     private MemberName loadMethod(byte[] classFile) {
 291         Class&lt;?&gt; invokerClass = loadAndInitializeInvokerClass(classFile, cpPatches(classFile));
 292         return resolveInvokerMember(invokerClass, invokerName, invokerType);
 293     }
 294 
 295     /**
 296      * Define a given class as anonymous class in the runtime system.
 297      */
 298     private static Class&lt;?&gt; loadAndInitializeInvokerClass(byte[] classBytes, Object[] patches) {
 299         Class&lt;?&gt; invokerClass = UNSAFE.defineAnonymousClass(HOST_CLASS, classBytes, patches);
 300         UNSAFE.ensureClassInitialized(invokerClass);  // Make sure the class is initialized; VM might complain.
 301         return invokerClass;
 302     }
 303 
 304     static MemberName resolveInvokerMember(Class&lt;?&gt; invokerClass, String name, MethodType type) {
 305         MemberName member = new MemberName(invokerClass, name, type, REF_invokeStatic);
 306         try {
 307             member = MEMBERNAME_FACTORY.resolveOrFail(REF_invokeStatic, member, HOST_CLASS, ReflectiveOperationException.class);
 308         } catch (ReflectiveOperationException e) {
 309             throw newInternalError(e);
 310         }
 311         return member;
 312     }
 313 
 314     /**
 315      * Set up class file generation.
 316      */
 317     private ClassWriter classFilePrologue() {
 318         final int NOT_ACC_PUBLIC = 0;  // not ACC_PUBLIC
 319         cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
 320         cw.visit(Opcodes.V1_8, NOT_ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,
 321                 CLASS_PREFIX + className, null, INVOKER_SUPER_NAME, null);
 322         cw.visitSource(SOURCE_PREFIX + className, null);
 323         return cw;
 324     }
 325 
 326     private void methodPrologue() {
 327         String invokerDesc = invokerType.toMethodDescriptorString();
 328         mv = cw.visitMethod(Opcodes.ACC_STATIC, invokerName, invokerDesc, null, null);
 329     }
 330 
 331     /**
 332      * Tear down class file generation.
 333      */
 334     private void methodEpilogue() {
 335         mv.visitMaxs(0, 0);
 336         mv.visitEnd();
 337     }
 338 
 339     /*
 340      * Low-level emit helpers.
 341      */
 342     private void emitConst(Object con) {
 343         if (con == null) {
 344             mv.visitInsn(Opcodes.ACONST_NULL);
 345             return;
 346         }
 347         if (con instanceof Integer) {
 348             emitIconstInsn((int) con);
 349             return;
 350         }
 351         if (con instanceof Byte) {
 352             emitIconstInsn((byte)con);
 353             return;
 354         }
 355         if (con instanceof Short) {
 356             emitIconstInsn((short)con);
 357             return;
 358         }
 359         if (con instanceof Character) {
 360             emitIconstInsn((char)con);
 361             return;
 362         }
 363         if (con instanceof Long) {
 364             long x = (long) con;
 365             short sx = (short)x;
 366             if (x == sx) {
 367                 if (sx &gt;= 0 &amp;&amp; sx &lt;= 1) {
 368                     mv.visitInsn(Opcodes.LCONST_0 + (int) sx);
 369                 } else {
 370                     emitIconstInsn((int) x);
 371                     mv.visitInsn(Opcodes.I2L);
 372                 }
 373                 return;
 374             }
 375         }
 376         if (con instanceof Float) {
 377             float x = (float) con;
 378             short sx = (short)x;
 379             if (x == sx) {
 380                 if (sx &gt;= 0 &amp;&amp; sx &lt;= 2) {
 381                     mv.visitInsn(Opcodes.FCONST_0 + (int) sx);
 382                 } else {
 383                     emitIconstInsn((int) x);
 384                     mv.visitInsn(Opcodes.I2F);
 385                 }
 386                 return;
 387             }
 388         }
 389         if (con instanceof Double) {
 390             double x = (double) con;
 391             short sx = (short)x;
 392             if (x == sx) {
 393                 if (sx &gt;= 0 &amp;&amp; sx &lt;= 1) {
 394                     mv.visitInsn(Opcodes.DCONST_0 + (int) sx);
 395                 } else {
 396                     emitIconstInsn((int) x);
 397                     mv.visitInsn(Opcodes.I2D);
 398                 }
 399                 return;
 400             }
 401         }
 402         if (con instanceof Boolean) {
 403             emitIconstInsn((boolean) con ? 1 : 0);
 404             return;
 405         }
 406         // fall through:
 407         mv.visitLdcInsn(con);
 408     }
 409 
 410     private void emitIconstInsn(final int cst) {
 411         if (cst &gt;= -1 &amp;&amp; cst &lt;= 5) {
 412             mv.visitInsn(Opcodes.ICONST_0 + cst);
 413         } else if (cst &gt;= Byte.MIN_VALUE &amp;&amp; cst &lt;= Byte.MAX_VALUE) {
 414             mv.visitIntInsn(Opcodes.BIPUSH, cst);
 415         } else if (cst &gt;= Short.MIN_VALUE &amp;&amp; cst &lt;= Short.MAX_VALUE) {
 416             mv.visitIntInsn(Opcodes.SIPUSH, cst);
 417         } else {
 418             mv.visitLdcInsn(cst);
 419         }
 420     }
 421 
 422     /*
 423      * NOTE: These load/store methods use the localsMap to find the correct index!
 424      */
 425     private void emitLoadInsn(BasicType type, int index) {
 426         int opcode = loadInsnOpcode(type);
 427         mv.visitVarInsn(opcode, localsMap[index]);
 428     }
 429 
 430     private int loadInsnOpcode(BasicType type) throws InternalError {
 431         switch (type) {
 432             case I_TYPE: return Opcodes.ILOAD;
 433             case J_TYPE: return Opcodes.LLOAD;
 434             case F_TYPE: return Opcodes.FLOAD;
 435             case D_TYPE: return Opcodes.DLOAD;
 436             case L_TYPE: return Opcodes.ALOAD;
 437             default:
 438                 throw new InternalError(&quot;unknown type: &quot; + type);
 439         }
 440     }
 441     private void emitAloadInsn(int index) {
 442         emitLoadInsn(L_TYPE, index);
 443     }
 444 
 445     private void emitStoreInsn(BasicType type, int index) {
 446         int opcode = storeInsnOpcode(type);
 447         mv.visitVarInsn(opcode, localsMap[index]);
 448     }
 449 
 450     private int storeInsnOpcode(BasicType type) throws InternalError {
 451         switch (type) {
 452             case I_TYPE: return Opcodes.ISTORE;
 453             case J_TYPE: return Opcodes.LSTORE;
 454             case F_TYPE: return Opcodes.FSTORE;
 455             case D_TYPE: return Opcodes.DSTORE;
 456             case L_TYPE: return Opcodes.ASTORE;
 457             default:
 458                 throw new InternalError(&quot;unknown type: &quot; + type);
 459         }
 460     }
 461     private void emitAstoreInsn(int index) {
 462         emitStoreInsn(L_TYPE, index);
 463     }
 464 
 465     private byte arrayTypeCode(Wrapper elementType) {
 466         switch (elementType) {
 467             case BOOLEAN: return Opcodes.T_BOOLEAN;
 468             case BYTE:    return Opcodes.T_BYTE;
 469             case CHAR:    return Opcodes.T_CHAR;
 470             case SHORT:   return Opcodes.T_SHORT;
 471             case INT:     return Opcodes.T_INT;
 472             case LONG:    return Opcodes.T_LONG;
 473             case FLOAT:   return Opcodes.T_FLOAT;
 474             case DOUBLE:  return Opcodes.T_DOUBLE;
 475             case OBJECT:  return 0; // in place of Opcodes.T_OBJECT
 476             default:      throw new InternalError();
 477         }
 478     }
 479 
 480     private int arrayInsnOpcode(byte tcode, int aaop) throws InternalError {
 481         assert(aaop == Opcodes.AASTORE || aaop == Opcodes.AALOAD);
 482         int xas;
 483         switch (tcode) {
 484             case Opcodes.T_BOOLEAN: xas = Opcodes.BASTORE; break;
 485             case Opcodes.T_BYTE:    xas = Opcodes.BASTORE; break;
 486             case Opcodes.T_CHAR:    xas = Opcodes.CASTORE; break;
 487             case Opcodes.T_SHORT:   xas = Opcodes.SASTORE; break;
 488             case Opcodes.T_INT:     xas = Opcodes.IASTORE; break;
 489             case Opcodes.T_LONG:    xas = Opcodes.LASTORE; break;
 490             case Opcodes.T_FLOAT:   xas = Opcodes.FASTORE; break;
 491             case Opcodes.T_DOUBLE:  xas = Opcodes.DASTORE; break;
 492             case 0:                 xas = Opcodes.AASTORE; break;
 493             default:      throw new InternalError();
 494         }
 495         return xas - Opcodes.AASTORE + aaop;
 496     }
 497 
 498     /**
 499      * Emit a boxing call.
 500      *
 501      * @param wrapper primitive type class to box.
 502      */
 503     private void emitBoxing(Wrapper wrapper) {
 504         String owner = &quot;java/lang/&quot; + wrapper.wrapperType().getSimpleName();
 505         String name  = &quot;valueOf&quot;;
 506         String desc  = &quot;(&quot; + wrapper.basicTypeChar() + &quot;)L&quot; + owner + &quot;;&quot;;
 507         mv.visitMethodInsn(Opcodes.INVOKESTATIC, owner, name, desc, false);
 508     }
 509 
 510     /**
 511      * Emit an unboxing call (plus preceding checkcast).
 512      *
 513      * @param wrapper wrapper type class to unbox.
 514      */
 515     private void emitUnboxing(Wrapper wrapper) {
 516         String owner = &quot;java/lang/&quot; + wrapper.wrapperType().getSimpleName();
 517         String name  = wrapper.primitiveSimpleName() + &quot;Value&quot;;
 518         String desc  = &quot;()&quot; + wrapper.basicTypeChar();
 519         emitReferenceCast(wrapper.wrapperType(), null);
 520         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, owner, name, desc, false);
 521     }
 522 
 523     /**
 524      * Emit an implicit conversion for an argument which must be of the given pclass.
 525      * This is usually a no-op, except when pclass is a subword type or a reference other than Object or an interface.
 526      *
 527      * @param ptype type of value present on stack
 528      * @param pclass type of value required on stack
 529      * @param arg compile-time representation of value on stack (Node, constant) or null if none
 530      */
 531     private void emitImplicitConversion(BasicType ptype, Class&lt;?&gt; pclass, Object arg) {
 532         assert(basicType(pclass) == ptype);  // boxing/unboxing handled by caller
 533         if (pclass == ptype.basicTypeClass() &amp;&amp; ptype != L_TYPE)
 534             return;   // nothing to do
 535         switch (ptype) {
 536             case L_TYPE:
 537                 if (VerifyType.isNullConversion(Object.class, pclass, false)) {
 538                     if (PROFILE_LEVEL &gt; 0)
 539                         emitReferenceCast(Object.class, arg);
 540                     return;
 541                 }
 542                 emitReferenceCast(pclass, arg);
 543                 return;
 544             case I_TYPE:
 545                 if (!VerifyType.isNullConversion(int.class, pclass, false))
 546                     emitPrimCast(ptype.basicTypeWrapper(), Wrapper.forPrimitiveType(pclass));
 547                 return;
 548         }
 549         throw newInternalError(&quot;bad implicit conversion: tc=&quot;+ptype+&quot;: &quot;+pclass);
 550     }
 551 
 552     /** Update localClasses type map.  Return true if the information is already present. */
 553     private boolean assertStaticType(Class&lt;?&gt; cls, Name n) {
 554         int local = n.index();
 555         Class&lt;?&gt; aclass = localClasses[local];
 556         if (aclass != null &amp;&amp; (aclass == cls || cls.isAssignableFrom(aclass))) {
 557             return true;  // type info is already present
 558         } else if (aclass == null || aclass.isAssignableFrom(cls)) {
 559             localClasses[local] = cls;  // type info can be improved
 560         }
 561         return false;
 562     }
 563 
 564     private void emitReferenceCast(Class&lt;?&gt; cls, Object arg) {
 565         Name writeBack = null;  // local to write back result
 566         if (arg instanceof Name) {
 567             Name n = (Name) arg;
 568             if (lambdaForm.useCount(n) &gt; 1) {
 569                 // This guy gets used more than once.
 570                 writeBack = n;
 571                 if (assertStaticType(cls, n)) {
 572                     return; // this cast was already performed
 573                 }
 574             }
 575         }
 576         if (isStaticallyNameable(cls)) {
 577             String sig = getInternalName(cls);
 578             mv.visitTypeInsn(Opcodes.CHECKCAST, sig);
 579         } else {
 580             mv.visitLdcInsn(constantPlaceholder(cls));
 581             mv.visitTypeInsn(Opcodes.CHECKCAST, CLS);
 582             mv.visitInsn(Opcodes.SWAP);
 583             mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, CLS, &quot;cast&quot;, LL_SIG, false);
 584             if (Object[].class.isAssignableFrom(cls))
 585                 mv.visitTypeInsn(Opcodes.CHECKCAST, OBJARY);
 586             else if (PROFILE_LEVEL &gt; 0)
 587                 mv.visitTypeInsn(Opcodes.CHECKCAST, OBJ);
 588         }
 589         if (writeBack != null) {
 590             mv.visitInsn(Opcodes.DUP);
 591             emitAstoreInsn(writeBack.index());
 592         }
 593     }
 594 
 595     /**
 596      * Emits an actual return instruction conforming to the given return type.
 597      */
 598     private void emitReturnInsn(BasicType type) {
 599         int opcode;
 600         switch (type) {
 601         case I_TYPE:  opcode = Opcodes.IRETURN;  break;
 602         case J_TYPE:  opcode = Opcodes.LRETURN;  break;
 603         case F_TYPE:  opcode = Opcodes.FRETURN;  break;
 604         case D_TYPE:  opcode = Opcodes.DRETURN;  break;
 605         case L_TYPE:  opcode = Opcodes.ARETURN;  break;
 606         case V_TYPE:  opcode = Opcodes.RETURN;   break;
 607         default:
 608             throw new InternalError(&quot;unknown return type: &quot; + type);
 609         }
 610         mv.visitInsn(opcode);
 611     }
 612 
 613     private String getInternalName(Class&lt;?&gt; c) {
 614         if (c == Object.class)             return OBJ;
 615         else if (c == Object[].class)      return OBJARY;
 616         else if (c == Class.class)         return CLS;
 617         else if (c == MethodHandle.class)  return MH;
 618         assert(VerifyAccess.isTypeVisible(c, Object.class)) : c.getName();
 619 
 620         if (c == lastClass) {
 621             return lastInternalName;
 622         }
 623         lastClass = c;
 624         return lastInternalName = c.getName().replace(&#39;.&#39;, &#39;/&#39;);
 625     }
 626 
 627     private static MemberName resolveFrom(String name, MethodType type, Class&lt;?&gt; holder) {
 628         MemberName member = new MemberName(holder, name, type, REF_invokeStatic);
 629         MemberName resolvedMember = MemberName.getFactory().resolveOrNull(REF_invokeStatic, member, holder);
 630         if (TRACE_RESOLVE) {
 631             System.out.println(&quot;[LF_RESOLVE] &quot; + holder.getName() + &quot; &quot; + name + &quot; &quot; +
 632                     shortenSignature(basicTypeSignature(type)) + (resolvedMember != null ? &quot; (success)&quot; : &quot; (fail)&quot;) );
 633         }
 634         return resolvedMember;
 635     }
 636 
 637     private static MemberName lookupPregenerated(LambdaForm form, MethodType invokerType) {
 638         if (form.customized != null) {
 639             // No pre-generated version for customized LF
 640             return null;
 641         }
 642         String name = form.kind.methodName;
 643         switch (form.kind) {
 644             case BOUND_REINVOKER: {
 645                 name = name + &quot;_&quot; + BoundMethodHandle.speciesDataFor(form).key();
 646                 return resolveFrom(name, invokerType, DelegatingMethodHandle.Holder.class);
 647             }
 648             case DELEGATE:                  return resolveFrom(name, invokerType, DelegatingMethodHandle.Holder.class);
 649             case ZERO:                      // fall-through
 650             case IDENTITY: {
 651                 name = name + &quot;_&quot; + form.returnType().basicTypeChar();
 652                 return resolveFrom(name, invokerType, LambdaForm.Holder.class);
 653             }
 654             case EXACT_INVOKER:             // fall-through
 655             case EXACT_LINKER:              // fall-through
 656             case LINK_TO_CALL_SITE:         // fall-through
 657             case LINK_TO_TARGET_METHOD:     // fall-through
 658             case GENERIC_INVOKER:           // fall-through
 659             case GENERIC_LINKER:            return resolveFrom(name, invokerType.basicType(), Invokers.Holder.class);
 660             case GET_REFERENCE:             // fall-through
 661             case GET_BOOLEAN:               // fall-through
 662             case GET_BYTE:                  // fall-through
 663             case GET_CHAR:                  // fall-through
 664             case GET_SHORT:                 // fall-through
 665             case GET_INT:                   // fall-through
 666             case GET_LONG:                  // fall-through
 667             case GET_FLOAT:                 // fall-through
 668             case GET_DOUBLE:                // fall-through
 669             case PUT_REFERENCE:             // fall-through
 670             case PUT_BOOLEAN:               // fall-through
 671             case PUT_BYTE:                  // fall-through
 672             case PUT_CHAR:                  // fall-through
 673             case PUT_SHORT:                 // fall-through
 674             case PUT_INT:                   // fall-through
 675             case PUT_LONG:                  // fall-through
 676             case PUT_FLOAT:                 // fall-through
 677             case PUT_DOUBLE:                // fall-through
 678             case DIRECT_NEW_INVOKE_SPECIAL: // fall-through
 679             case DIRECT_INVOKE_INTERFACE:   // fall-through
 680             case DIRECT_INVOKE_SPECIAL:     // fall-through
 681             case DIRECT_INVOKE_SPECIAL_IFC: // fall-through
 682             case DIRECT_INVOKE_STATIC:      // fall-through
 683             case DIRECT_INVOKE_STATIC_INIT: // fall-through
 684             case DIRECT_INVOKE_VIRTUAL:     return resolveFrom(name, invokerType, DirectMethodHandle.Holder.class);
 685         }
 686         return null;
 687     }
 688 
 689     /**
 690      * Generate customized bytecode for a given LambdaForm.
 691      */
 692     static MemberName generateCustomizedCode(LambdaForm form, MethodType invokerType) {
 693         MemberName pregenerated = lookupPregenerated(form, invokerType);
 694         if (pregenerated != null)  return pregenerated; // pre-generated bytecode
 695 
 696         InvokerBytecodeGenerator g = new InvokerBytecodeGenerator(&quot;MH&quot;, form, invokerType);
 697         return g.loadMethod(g.generateCustomizedCodeBytes());
 698     }
 699 
 700     /** Generates code to check that actual receiver and LambdaForm matches */
 701     private boolean checkActualReceiver() {
 702         // Expects MethodHandle on the stack and actual receiver MethodHandle in slot #0
 703         mv.visitInsn(Opcodes.DUP);
 704         mv.visitVarInsn(Opcodes.ALOAD, localsMap[0]);
 705         mv.visitMethodInsn(Opcodes.INVOKESTATIC, MHI, &quot;assertSame&quot;, LLV_SIG, false);
 706         return true;
 707     }
 708 
 709     static String className(String cn) {
 710         assert checkClassName(cn): &quot;Class not found: &quot; + cn;
 711         return cn;
 712     }
 713 
 714     static boolean checkClassName(String cn) {
 715         Type tp = Type.getType(cn);
 716         // additional sanity so only valid &quot;L;&quot; descriptors work
 717         if (tp.getSort() != Type.OBJECT) {
 718             return false;
 719         }
 720         try {
 721             Class&lt;?&gt; c = Class.forName(tp.getClassName(), false, null);
 722             return true;
 723         } catch (ClassNotFoundException e) {
 724             return false;
 725         }
 726     }
 727 
 728     static final String      DONTINLINE_SIG = className(&quot;Ljdk/internal/vm/annotation/DontInline;&quot;);
 729     static final String     FORCEINLINE_SIG = className(&quot;Ljdk/internal/vm/annotation/ForceInline;&quot;);
 730     static final String          HIDDEN_SIG = className(&quot;Ljdk/internal/vm/annotation/Hidden;&quot;);
 731     static final String INJECTEDPROFILE_SIG = className(&quot;Ljava/lang/invoke/InjectedProfile;&quot;);
 732     static final String     LF_COMPILED_SIG = className(&quot;Ljava/lang/invoke/LambdaForm$Compiled;&quot;);
 733 
 734     /**
 735      * Generate an invoker method for the passed {@link LambdaForm}.
 736      */
 737     private byte[] generateCustomizedCodeBytes() {
 738         classFilePrologue();
 739         addMethod();
 740         bogusMethod(lambdaForm);
 741 
 742         final byte[] classFile = toByteArray();
 743         maybeDump(classFile);
 744         return classFile;
 745     }
 746 
 747     void setClassWriter(ClassWriter cw) {
 748         this.cw = cw;
 749     }
 750 
 751     void addMethod() {
 752         methodPrologue();
 753 
 754         // Suppress this method in backtraces displayed to the user.
 755         mv.visitAnnotation(HIDDEN_SIG, true);
 756 
 757         // Mark this method as a compiled LambdaForm
 758         mv.visitAnnotation(LF_COMPILED_SIG, true);
 759 
 760         if (lambdaForm.forceInline) {
 761             // Force inlining of this invoker method.
 762             mv.visitAnnotation(FORCEINLINE_SIG, true);
 763         } else {
 764             mv.visitAnnotation(DONTINLINE_SIG, true);
 765         }
 766 
 767         constantPlaceholder(lambdaForm); // keep LambdaForm instance &amp; its compiled form lifetime tightly coupled.
 768 
 769         if (lambdaForm.customized != null) {
 770             // Since LambdaForm is customized for a particular MethodHandle, it&#39;s safe to substitute
 771             // receiver MethodHandle (at slot #0) with an embedded constant and use it instead.
 772             // It enables more efficient code generation in some situations, since embedded constants
 773             // are compile-time constants for JIT compiler.
 774             mv.visitLdcInsn(constantPlaceholder(lambdaForm.customized));
 775             mv.visitTypeInsn(Opcodes.CHECKCAST, MH);
 776             assert(checkActualReceiver()); // expects MethodHandle on top of the stack
 777             mv.visitVarInsn(Opcodes.ASTORE, localsMap[0]);
 778         }
 779 
 780         // iterate over the form&#39;s names, generating bytecode instructions for each
 781         // start iterating at the first name following the arguments
 782         Name onStack = null;
 783         for (int i = lambdaForm.arity; i &lt; lambdaForm.names.length; i++) {
 784             Name name = lambdaForm.names[i];
 785 
 786             emitStoreResult(onStack);
 787             onStack = name;  // unless otherwise modified below
 788             MethodHandleImpl.Intrinsic intr = name.function.intrinsicName();
 789             switch (intr) {
 790                 case SELECT_ALTERNATIVE:
 791                     assert lambdaForm.isSelectAlternative(i);
 792                     if (PROFILE_GWT) {
 793                         assert(name.arguments[0] instanceof Name &amp;&amp;
 794                                 ((Name)name.arguments[0]).refersTo(MethodHandleImpl.class, &quot;profileBoolean&quot;));
 795                         mv.visitAnnotation(INJECTEDPROFILE_SIG, true);
 796                     }
 797                     onStack = emitSelectAlternative(name, lambdaForm.names[i+1]);
 798                     i++;  // skip MH.invokeBasic of the selectAlternative result
 799                     continue;
 800                 case GUARD_WITH_CATCH:
 801                     assert lambdaForm.isGuardWithCatch(i);
 802                     onStack = emitGuardWithCatch(i);
 803                     i += 2; // jump to the end of GWC idiom
 804                     continue;
 805                 case TRY_FINALLY:
 806                     assert lambdaForm.isTryFinally(i);
 807                     onStack = emitTryFinally(i);
 808                     i += 2; // jump to the end of the TF idiom
 809                     continue;
 810                 case LOOP:
 811                     assert lambdaForm.isLoop(i);
 812                     onStack = emitLoop(i);
 813                     i += 2; // jump to the end of the LOOP idiom
 814                     continue;
 815                 case NEW_ARRAY:
 816                     Class&lt;?&gt; rtype = name.function.methodType().returnType();
 817                     if (isStaticallyNameable(rtype)) {
 818                         emitNewArray(name);
 819                         continue;
 820                     }
 821                     break;
 822                 case ARRAY_LOAD:
 823                     emitArrayLoad(name);
 824                     continue;
 825                 case ARRAY_STORE:
 826                     emitArrayStore(name);
 827                     continue;
 828                 case ARRAY_LENGTH:
 829                     emitArrayLength(name);
 830                     continue;
 831                 case IDENTITY:
 832                     assert(name.arguments.length == 1);
 833                     emitPushArguments(name, 0);
 834                     continue;
 835                 case ZERO:
 836                     assert(name.arguments.length == 0);
 837                     emitConst(name.type.basicTypeWrapper().zero());
 838                     continue;
 839                 case NONE:
 840                     // no intrinsic associated
 841                     break;
 842                 default:
 843                     throw newInternalError(&quot;Unknown intrinsic: &quot;+intr);
 844             }
 845 
 846             MemberName member = name.function.member();
 847             if (isStaticallyInvocable(member)) {
 848                 emitStaticInvoke(member, name);
 849             } else {
 850                 emitInvoke(name);
 851             }
 852         }
 853 
 854         // return statement
 855         emitReturn(onStack);
 856 
 857         methodEpilogue();
 858     }
 859 
 860     /*
 861      * @throws BytecodeGenerationException if something goes wrong when
 862      *         generating the byte code
 863      */
 864     private byte[] toByteArray() {
 865         try {
 866             return cw.toByteArray();
 867         } catch (RuntimeException e) {
 868             throw new BytecodeGenerationException(e);
 869         }
 870     }
 871 
 872     @SuppressWarnings(&quot;serial&quot;)
 873     static final class BytecodeGenerationException extends RuntimeException {
 874         BytecodeGenerationException(Exception cause) {
 875             super(cause);
 876         }
 877     }
 878 
 879     void emitArrayLoad(Name name)   { emitArrayOp(name, Opcodes.AALOAD);      }
 880     void emitArrayStore(Name name)  { emitArrayOp(name, Opcodes.AASTORE);     }
 881     void emitArrayLength(Name name) { emitArrayOp(name, Opcodes.ARRAYLENGTH); }
 882 
 883     void emitArrayOp(Name name, int arrayOpcode) {
 884         assert arrayOpcode == Opcodes.AALOAD || arrayOpcode == Opcodes.AASTORE || arrayOpcode == Opcodes.ARRAYLENGTH;
 885         Class&lt;?&gt; elementType = name.function.methodType().parameterType(0).getComponentType();
 886         assert elementType != null;
 887         emitPushArguments(name, 0);
 888         if (arrayOpcode != Opcodes.ARRAYLENGTH &amp;&amp; elementType.isPrimitive()) {
 889             Wrapper w = Wrapper.forPrimitiveType(elementType);
 890             arrayOpcode = arrayInsnOpcode(arrayTypeCode(w), arrayOpcode);
 891         }
 892         mv.visitInsn(arrayOpcode);
 893     }
 894 
 895     /**
 896      * Emit an invoke for the given name.
 897      */
 898     void emitInvoke(Name name) {
 899         assert(!name.isLinkerMethodInvoke());  // should use the static path for these
 900         if (true) {
 901             // push receiver
 902             MethodHandle target = name.function.resolvedHandle();
 903             assert(target != null) : name.exprString();
 904             mv.visitLdcInsn(constantPlaceholder(target));
 905             emitReferenceCast(MethodHandle.class, target);
 906         } else {
 907             // load receiver
 908             emitAloadInsn(0);
 909             emitReferenceCast(MethodHandle.class, null);
 910             mv.visitFieldInsn(Opcodes.GETFIELD, MH, &quot;form&quot;, LF_SIG);
 911             mv.visitFieldInsn(Opcodes.GETFIELD, LF, &quot;names&quot;, LFN_SIG);
 912             // TODO more to come
 913         }
 914 
 915         // push arguments
 916         emitPushArguments(name, 0);
 917 
 918         // invocation
 919         MethodType type = name.function.methodType();
 920         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, type.basicType().toMethodDescriptorString(), false);
 921     }
 922 
 923     private static Class&lt;?&gt;[] STATICALLY_INVOCABLE_PACKAGES = {
 924         // Sample classes from each package we are willing to bind to statically:
 925         java.lang.Object.class,
 926         java.util.Arrays.class,
 927         jdk.internal.misc.Unsafe.class
 928         //MethodHandle.class already covered
 929     };
 930 
 931     static boolean isStaticallyInvocable(NamedFunction ... functions) {
 932         for (NamedFunction nf : functions) {
 933             if (!isStaticallyInvocable(nf.member())) {
 934                 return false;
 935             }
 936         }
 937         return true;
 938     }
 939 
 940     static boolean isStaticallyInvocable(Name name) {
 941         return isStaticallyInvocable(name.function.member());
 942     }
 943 
 944     static boolean isStaticallyInvocable(MemberName member) {
 945         if (member == null)  return false;
 946         if (member.isObjectConstructorOrStaticInitMethod())  return false;
 947 
 948         Class&lt;?&gt; cls = member.getDeclaringClass();
 949         // Fast-path non-private members declared by MethodHandles, which is a common
 950         // case
 951         if (MethodHandle.class.isAssignableFrom(cls) &amp;&amp; !member.isPrivate()) {
 952             assert(isStaticallyInvocableType(member.getMethodOrFieldType()));
 953             return true;
 954         }
 955         if (cls.isArray() || cls.isPrimitive())
 956             return false;  // FIXME
 957         if (cls.isAnonymousClass() || cls.isLocalClass())
 958             return false;  // inner class of some sort
 959         if (cls.getClassLoader() != MethodHandle.class.getClassLoader())
 960             return false;  // not on BCP
 961         if (ReflectUtil.isVMAnonymousClass(cls)) // FIXME: switch to supported API once it is added
 962             return false;
 963         if (!isStaticallyInvocableType(member.getMethodOrFieldType()))
 964             return false;
 965         if (!member.isPrivate() &amp;&amp; VerifyAccess.isSamePackage(MethodHandle.class, cls))
 966             return true;   // in java.lang.invoke package
 967         if (member.isPublic() &amp;&amp; isStaticallyNameable(cls))
 968             return true;
 969         return false;
 970     }
 971 
 972     private static boolean isStaticallyInvocableType(MethodType mtype) {
 973         if (!isStaticallyNameable(mtype.returnType()))
 974             return false;
 975         for (Class&lt;?&gt; ptype : mtype.parameterArray())
 976             if (!isStaticallyNameable(ptype))
 977                 return false;
 978         return true;
 979     }
 980 
 981     static boolean isStaticallyNameable(Class&lt;?&gt; cls) {
 982         if (cls == Object.class)
 983             return true;
 984         if (MethodHandle.class.isAssignableFrom(cls)) {
 985             assert(!ReflectUtil.isVMAnonymousClass(cls));
 986             return true;
 987         }
 988         while (cls.isArray())
 989             cls = cls.getComponentType();
 990         if (cls.isPrimitive())
 991             return true;  // int[].class, for example
 992         if (ReflectUtil.isVMAnonymousClass(cls)) // FIXME: switch to supported API once it is added
 993             return false;
 994         // could use VerifyAccess.isClassAccessible but the following is a safe approximation
 995         if (cls.getClassLoader() != Object.class.getClassLoader())
 996             return false;
 997         if (VerifyAccess.isSamePackage(MethodHandle.class, cls))
 998             return true;
 999         if (!Modifier.isPublic(cls.getModifiers()))
1000             return false;
1001         for (Class&lt;?&gt; pkgcls : STATICALLY_INVOCABLE_PACKAGES) {
1002             if (VerifyAccess.isSamePackage(pkgcls, cls))
1003                 return true;
1004         }
1005         return false;
1006     }
1007 
1008     void emitStaticInvoke(Name name) {
1009         emitStaticInvoke(name.function.member(), name);
1010     }
1011 
1012     /**
1013      * Emit an invoke for the given name, using the MemberName directly.
1014      */
1015     void emitStaticInvoke(MemberName member, Name name) {
1016         assert(member.equals(name.function.member()));
1017         Class&lt;?&gt; defc = member.getDeclaringClass();
1018         String cname = getInternalName(defc);
1019         String mname = member.getName();
1020         String mtype;
1021         byte refKind = member.getReferenceKind();
1022         if (refKind == REF_invokeSpecial) {
1023             // in order to pass the verifier, we need to convert this to invokevirtual in all cases
1024             assert(member.canBeStaticallyBound()) : member;
1025             refKind = REF_invokeVirtual;
1026         }
1027 
1028         assert(!(member.getDeclaringClass().isInterface() &amp;&amp; refKind == REF_invokeVirtual));
1029 
1030         // push arguments
1031         emitPushArguments(name, 0);
1032 
1033         // invocation
1034         if (member.isMethod()) {
1035             mtype = member.getMethodType().toMethodDescriptorString();
1036             mv.visitMethodInsn(refKindOpcode(refKind), cname, mname, mtype,
1037                                member.getDeclaringClass().isInterface());
1038         } else {
1039             mtype = MethodType.toFieldDescriptorString(member.getFieldType());
1040             mv.visitFieldInsn(refKindOpcode(refKind), cname, mname, mtype);
1041         }
1042         // Issue a type assertion for the result, so we can avoid casts later.
1043         if (name.type == L_TYPE) {
1044             Class&lt;?&gt; rtype = member.getInvocationType().returnType();
1045             assert(!rtype.isPrimitive());
1046             if (rtype != Object.class &amp;&amp; !rtype.isInterface()) {
1047                 assertStaticType(rtype, name);
1048             }
1049         }
1050     }
1051 
1052     void emitNewArray(Name name) throws InternalError {
1053         Class&lt;?&gt; rtype = name.function.methodType().returnType();
1054         if (name.arguments.length == 0) {
1055             // The array will be a constant.
1056             Object emptyArray;
1057             try {
1058                 emptyArray = name.function.resolvedHandle().invoke();
1059             } catch (Throwable ex) {
1060                 throw uncaughtException(ex);
1061             }
1062             assert(java.lang.reflect.Array.getLength(emptyArray) == 0);
1063             assert(emptyArray.getClass() == rtype);  // exact typing
1064             mv.visitLdcInsn(constantPlaceholder(emptyArray));
1065             emitReferenceCast(rtype, emptyArray);
1066             return;
1067         }
1068         Class&lt;?&gt; arrayElementType = rtype.getComponentType();
1069         assert(arrayElementType != null);
1070         emitIconstInsn(name.arguments.length);
1071         int xas = Opcodes.AASTORE;
1072         if (!arrayElementType.isPrimitive()) {
1073             mv.visitTypeInsn(Opcodes.ANEWARRAY, getInternalName(arrayElementType));
1074         } else {
1075             byte tc = arrayTypeCode(Wrapper.forPrimitiveType(arrayElementType));
1076             xas = arrayInsnOpcode(tc, xas);
1077             mv.visitIntInsn(Opcodes.NEWARRAY, tc);
1078         }
1079         // store arguments
1080         for (int i = 0; i &lt; name.arguments.length; i++) {
1081             mv.visitInsn(Opcodes.DUP);
1082             emitIconstInsn(i);
1083             emitPushArgument(name, i);
1084             mv.visitInsn(xas);
1085         }
1086         // the array is left on the stack
1087         assertStaticType(rtype, name);
1088     }
1089     int refKindOpcode(byte refKind) {
1090         switch (refKind) {
1091         case REF_invokeVirtual:      return Opcodes.INVOKEVIRTUAL;
1092         case REF_invokeStatic:       return Opcodes.INVOKESTATIC;
1093         case REF_invokeSpecial:      return Opcodes.INVOKESPECIAL;
1094         case REF_invokeInterface:    return Opcodes.INVOKEINTERFACE;
1095         case REF_getField:           return Opcodes.GETFIELD;
1096         case REF_putField:           return Opcodes.PUTFIELD;
1097         case REF_getStatic:          return Opcodes.GETSTATIC;
1098         case REF_putStatic:          return Opcodes.PUTSTATIC;
1099         }
1100         throw new InternalError(&quot;refKind=&quot;+refKind);
1101     }
1102 
1103     /**
1104      * Emit bytecode for the selectAlternative idiom.
1105      *
1106      * The pattern looks like (Cf. MethodHandleImpl.makeGuardWithTest):
1107      * &lt;blockquote&gt;&lt;pre&gt;{@code
1108      *   Lambda(a0:L,a1:I)=&gt;{
1109      *     t2:I=foo.test(a1:I);
1110      *     t3:L=MethodHandleImpl.selectAlternative(t2:I,(MethodHandle(int)int),(MethodHandle(int)int));
1111      *     t4:I=MethodHandle.invokeBasic(t3:L,a1:I);t4:I}
1112      * }&lt;/pre&gt;&lt;/blockquote&gt;
1113      */
1114     private Name emitSelectAlternative(Name selectAlternativeName, Name invokeBasicName) {
1115         assert isStaticallyInvocable(invokeBasicName);
1116 
1117         Name receiver = (Name) invokeBasicName.arguments[0];
1118 
1119         Label L_fallback = new Label();
1120         Label L_done     = new Label();
1121 
1122         // load test result
1123         emitPushArgument(selectAlternativeName, 0);
1124 
1125         // if_icmpne L_fallback
1126         mv.visitJumpInsn(Opcodes.IFEQ, L_fallback);
1127 
1128         // invoke selectAlternativeName.arguments[1]
1129         Class&lt;?&gt;[] preForkClasses = localClasses.clone();
1130         emitPushArgument(selectAlternativeName, 1);  // get 2nd argument of selectAlternative
1131         emitAstoreInsn(receiver.index());  // store the MH in the receiver slot
1132         emitStaticInvoke(invokeBasicName);
1133 
1134         // goto L_done
1135         mv.visitJumpInsn(Opcodes.GOTO, L_done);
1136 
1137         // L_fallback:
1138         mv.visitLabel(L_fallback);
1139 
1140         // invoke selectAlternativeName.arguments[2]
1141         System.arraycopy(preForkClasses, 0, localClasses, 0, preForkClasses.length);
1142         emitPushArgument(selectAlternativeName, 2);  // get 3rd argument of selectAlternative
1143         emitAstoreInsn(receiver.index());  // store the MH in the receiver slot
1144         emitStaticInvoke(invokeBasicName);
1145 
1146         // L_done:
1147         mv.visitLabel(L_done);
1148         // for now do not bother to merge typestate; just reset to the dominator state
1149         System.arraycopy(preForkClasses, 0, localClasses, 0, preForkClasses.length);
1150 
1151         return invokeBasicName;  // return what&#39;s on stack
1152     }
1153 
1154     /**
<a name="2" id="anc2"></a><span class="line-modified">1155       * Emit bytecode for the guardWithCatch idiom.</span>
<span class="line-modified">1156       *</span>
<span class="line-modified">1157       * The pattern looks like (Cf. MethodHandleImpl.makeGuardWithCatch):</span>
<span class="line-modified">1158       * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-modified">1159       *  guardWithCatch=Lambda(a0:L,a1:L,a2:L,a3:L,a4:L,a5:L,a6:L,a7:L)=&gt;{</span>
<span class="line-modified">1160       *    t8:L=MethodHandle.invokeBasic(a4:L,a6:L,a7:L);</span>
<span class="line-modified">1161       *    t9:L=MethodHandleImpl.guardWithCatch(a1:L,a2:L,a3:L,t8:L);</span>
<span class="line-modified">1162       *   t10:I=MethodHandle.invokeBasic(a5:L,t9:L);t10:I}</span>
<span class="line-modified">1163       * }&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-modified">1164       *</span>
<span class="line-modified">1165       * It is compiled into bytecode equivalent of the following code:</span>
<span class="line-modified">1166       * &lt;blockquote&gt;&lt;pre&gt;{@code</span>
<span class="line-modified">1167       *  try {</span>
<span class="line-modified">1168       *      return a1.invokeBasic(a6, a7);</span>
<span class="line-modified">1169       *  } catch (Throwable e) {</span>
<span class="line-modified">1170       *      if (!a2.isInstance(e)) throw e;</span>
<span class="line-modified">1171       *      return a3.invokeBasic(ex, a6, a7);</span>
<span class="line-modified">1172       *  }}&lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-modified">1173       */</span>
1174     private Name emitGuardWithCatch(int pos) {
1175         Name args    = lambdaForm.names[pos];
1176         Name invoker = lambdaForm.names[pos+1];
1177         Name result  = lambdaForm.names[pos+2];
1178 
1179         Label L_startBlock = new Label();
1180         Label L_endBlock = new Label();
1181         Label L_handler = new Label();
1182         Label L_done = new Label();
1183 
1184         Class&lt;?&gt; returnType = result.function.resolvedHandle().type().returnType();
1185         MethodType type = args.function.resolvedHandle().type()
1186                               .dropParameterTypes(0,1)
1187                               .changeReturnType(returnType);
1188 
1189         mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_handler, &quot;java/lang/Throwable&quot;);
1190 
1191         // Normal case
1192         mv.visitLabel(L_startBlock);
1193         // load target
1194         emitPushArgument(invoker, 0);
1195         emitPushArguments(args, 1); // skip 1st argument: method handle
1196         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, type.basicType().toMethodDescriptorString(), false);
1197         mv.visitLabel(L_endBlock);
1198         mv.visitJumpInsn(Opcodes.GOTO, L_done);
1199 
1200         // Exceptional case
1201         mv.visitLabel(L_handler);
1202 
1203         // Check exception&#39;s type
1204         mv.visitInsn(Opcodes.DUP);
1205         // load exception class
1206         emitPushArgument(invoker, 1);
1207         mv.visitInsn(Opcodes.SWAP);
1208         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/Class&quot;, &quot;isInstance&quot;, &quot;(Ljava/lang/Object;)Z&quot;, false);
1209         Label L_rethrow = new Label();
1210         mv.visitJumpInsn(Opcodes.IFEQ, L_rethrow);
1211 
1212         // Invoke catcher
1213         // load catcher
1214         emitPushArgument(invoker, 2);
1215         mv.visitInsn(Opcodes.SWAP);
1216         emitPushArguments(args, 1); // skip 1st argument: method handle
1217         MethodType catcherType = type.insertParameterTypes(0, Throwable.class);
1218         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, catcherType.basicType().toMethodDescriptorString(), false);
1219         mv.visitJumpInsn(Opcodes.GOTO, L_done);
1220 
1221         mv.visitLabel(L_rethrow);
1222         mv.visitInsn(Opcodes.ATHROW);
1223 
1224         mv.visitLabel(L_done);
1225 
1226         return result;
1227     }
1228 
1229     /**
1230      * Emit bytecode for the tryFinally idiom.
1231      * &lt;p&gt;
1232      * The pattern looks like (Cf. MethodHandleImpl.makeTryFinally):
1233      * &lt;blockquote&gt;&lt;pre&gt;{@code
1234      * // a0: BMH
1235      * // a1: target, a2: cleanup
1236      * // a3: box, a4: unbox
1237      * // a5 (and following): arguments
1238      * tryFinally=Lambda(a0:L,a1:L,a2:L,a3:L,a4:L,a5:L)=&gt;{
1239      *   t6:L=MethodHandle.invokeBasic(a3:L,a5:L);         // box the arguments into an Object[]
1240      *   t7:L=MethodHandleImpl.tryFinally(a1:L,a2:L,t6:L); // call the tryFinally executor
1241      *   t8:L=MethodHandle.invokeBasic(a4:L,t7:L);t8:L}    // unbox the result; return the result
1242      * }&lt;/pre&gt;&lt;/blockquote&gt;
1243      * &lt;p&gt;
1244      * It is compiled into bytecode equivalent to the following code:
1245      * &lt;blockquote&gt;&lt;pre&gt;{@code
1246      * Throwable t;
1247      * Object r;
1248      * try {
1249      *     r = a1.invokeBasic(a5);
1250      * } catch (Throwable thrown) {
1251      *     t = thrown;
1252      *     throw t;
1253      * } finally {
1254      *     r = a2.invokeBasic(t, r, a5);
1255      * }
1256      * return r;
1257      * }&lt;/pre&gt;&lt;/blockquote&gt;
1258      * &lt;p&gt;
1259      * Specifically, the bytecode will have the following form (the stack effects are given for the beginnings of
1260      * blocks, and for the situations after executing the given instruction - the code will have a slightly different
1261      * shape if the return type is {@code void}):
1262      * &lt;blockquote&gt;&lt;pre&gt;{@code
1263      * TRY:                 (--)
1264      *                      load target                             (-- target)
1265      *                      load args                               (-- args... target)
1266      *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (depends)
1267      * FINALLY_NORMAL:      (-- r_2nd* r)
1268      *                      store returned value                    (--)
1269      *                      load cleanup                            (-- cleanup)
1270      *                      ACONST_NULL                             (-- t cleanup)
1271      *                      load returned value                     (-- r_2nd* r t cleanup)
1272      *                      load args                               (-- args... r_2nd* r t cleanup)
1273      *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (-- r_2nd* r)
1274      *                      GOTO DONE
1275      * CATCH:               (-- t)
1276      *                      DUP                                     (-- t t)
1277      * FINALLY_EXCEPTIONAL: (-- t t)
1278      *                      load cleanup                            (-- cleanup t t)
1279      *                      SWAP                                    (-- t cleanup t)
1280      *                      load default for r                      (-- r_2nd* r t cleanup t)
1281      *                      load args                               (-- args... r_2nd* r t cleanup t)
1282      *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (-- r_2nd* r t)
1283      *                      POP/POP2*                               (-- t)
1284      *                      ATHROW
1285      * DONE:                (-- r)
1286      * }&lt;/pre&gt;&lt;/blockquote&gt;
1287      * * = depends on whether the return type takes up 2 stack slots.
1288      */
1289     private Name emitTryFinally(int pos) {
1290         Name args    = lambdaForm.names[pos];
1291         Name invoker = lambdaForm.names[pos+1];
1292         Name result  = lambdaForm.names[pos+2];
1293 
1294         Label lFrom = new Label();
1295         Label lTo = new Label();
1296         Label lCatch = new Label();
1297         Label lDone = new Label();
1298 
1299         Class&lt;?&gt; returnType = result.function.resolvedHandle().type().returnType();
1300         BasicType basicReturnType = BasicType.basicType(returnType);
1301         boolean isNonVoid = returnType != void.class;
1302 
1303         MethodType type = args.function.resolvedHandle().type()
1304                 .dropParameterTypes(0,1)
1305                 .changeReturnType(returnType);
1306         MethodType cleanupType = type.insertParameterTypes(0, Throwable.class);
1307         if (isNonVoid) {
1308             cleanupType = cleanupType.insertParameterTypes(1, returnType);
1309         }
1310         String cleanupDesc = cleanupType.basicType().toMethodDescriptorString();
1311 
1312         // exception handler table
1313         mv.visitTryCatchBlock(lFrom, lTo, lCatch, &quot;java/lang/Throwable&quot;);
1314 
1315         // TRY:
1316         mv.visitLabel(lFrom);
1317         emitPushArgument(invoker, 0); // load target
1318         emitPushArguments(args, 1); // load args (skip 0: method handle)
1319         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, type.basicType().toMethodDescriptorString(), false);
1320         mv.visitLabel(lTo);
1321 
1322         // FINALLY_NORMAL:
1323         int index = extendLocalsMap(new Class&lt;?&gt;[]{ returnType });
1324         if (isNonVoid) {
1325             emitStoreInsn(basicReturnType, index);
1326         }
1327         emitPushArgument(invoker, 1); // load cleanup
1328         mv.visitInsn(Opcodes.ACONST_NULL);
1329         if (isNonVoid) {
1330             emitLoadInsn(basicReturnType, index);
1331         }
1332         emitPushArguments(args, 1); // load args (skip 0: method handle)
1333         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, cleanupDesc, false);
1334         mv.visitJumpInsn(Opcodes.GOTO, lDone);
1335 
1336         // CATCH:
1337         mv.visitLabel(lCatch);
1338         mv.visitInsn(Opcodes.DUP);
1339 
1340         // FINALLY_EXCEPTIONAL:
1341         emitPushArgument(invoker, 1); // load cleanup
1342         mv.visitInsn(Opcodes.SWAP);
1343         if (isNonVoid) {
1344             emitZero(BasicType.basicType(returnType)); // load default for result
1345         }
1346         emitPushArguments(args, 1); // load args (skip 0: method handle)
1347         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, cleanupDesc, false);
1348         if (isNonVoid) {
1349             emitPopInsn(basicReturnType);
1350         }
1351         mv.visitInsn(Opcodes.ATHROW);
1352 
1353         // DONE:
1354         mv.visitLabel(lDone);
1355 
1356         return result;
1357     }
1358 
1359     private void emitPopInsn(BasicType type) {
1360         mv.visitInsn(popInsnOpcode(type));
1361     }
1362 
1363     private static int popInsnOpcode(BasicType type) {
1364         switch (type) {
1365             case I_TYPE:
1366             case F_TYPE:
1367             case L_TYPE:
1368                 return Opcodes.POP;
1369             case J_TYPE:
1370             case D_TYPE:
1371                 return Opcodes.POP2;
1372             default:
1373                 throw new InternalError(&quot;unknown type: &quot; + type);
1374         }
1375     }
1376 
1377     /**
1378      * Emit bytecode for the loop idiom.
1379      * &lt;p&gt;
1380      * The pattern looks like (Cf. MethodHandleImpl.loop):
1381      * &lt;blockquote&gt;&lt;pre&gt;{@code
1382      * // a0: BMH
1383      * // a1: LoopClauses (containing an array of arrays: inits, steps, preds, finis)
1384      * // a2: box, a3: unbox
1385      * // a4 (and following): arguments
1386      * loop=Lambda(a0:L,a1:L,a2:L,a3:L,a4:L)=&gt;{
1387      *   t5:L=MethodHandle.invokeBasic(a2:L,a4:L);          // box the arguments into an Object[]
1388      *   t6:L=MethodHandleImpl.loop(bt:L,a1:L,t5:L);        // call the loop executor (with supplied types in bt)
1389      *   t7:L=MethodHandle.invokeBasic(a3:L,t6:L);t7:L}     // unbox the result; return the result
1390      * }&lt;/pre&gt;&lt;/blockquote&gt;
1391      * &lt;p&gt;
1392      * It is compiled into bytecode equivalent to the code seen in {@link MethodHandleImpl#loop(BasicType[],
1393      * MethodHandleImpl.LoopClauses, Object...)}, with the difference that no arrays
1394      * will be used for local state storage. Instead, the local state will be mapped to actual stack slots.
1395      * &lt;p&gt;
1396      * Bytecode generation applies an unrolling scheme to enable better bytecode generation regarding local state type
1397      * handling. The generated bytecode will have the following form ({@code void} types are ignored for convenience).
1398      * Assume there are {@code C} clauses in the loop.
1399      * &lt;blockquote&gt;&lt;pre&gt;{@code
1400      * PREINIT: ALOAD_1
1401      *          CHECKCAST LoopClauses
1402      *          GETFIELD LoopClauses.clauses
1403      *          ASTORE clauseDataIndex          // place the clauses 2-dimensional array on the stack
1404      * INIT:    (INIT_SEQ for clause 1)
1405      *          ...
1406      *          (INIT_SEQ for clause C)
1407      * LOOP:    (LOOP_SEQ for clause 1)
1408      *          ...
1409      *          (LOOP_SEQ for clause C)
1410      *          GOTO LOOP
1411      * DONE:    ...
1412      * }&lt;/pre&gt;&lt;/blockquote&gt;
1413      * &lt;p&gt;
1414      * The {@code INIT_SEQ_x} sequence for clause {@code x} (with {@code x} ranging from {@code 0} to {@code C-1}) has
1415      * the following shape. Assume slot {@code vx} is used to hold the state for clause {@code x}.
1416      * &lt;blockquote&gt;&lt;pre&gt;{@code
1417      * INIT_SEQ_x:  ALOAD clauseDataIndex
1418      *              ICONST_0
1419      *              AALOAD      // load the inits array
1420      *              ICONST x
1421      *              AALOAD      // load the init handle for clause x
1422      *              load args
1423      *              INVOKEVIRTUAL MethodHandle.invokeBasic
1424      *              store vx
1425      * }&lt;/pre&gt;&lt;/blockquote&gt;
1426      * &lt;p&gt;
1427      * The {@code LOOP_SEQ_x} sequence for clause {@code x} (with {@code x} ranging from {@code 0} to {@code C-1}) has
1428      * the following shape. Again, assume slot {@code vx} is used to hold the state for clause {@code x}.
1429      * &lt;blockquote&gt;&lt;pre&gt;{@code
1430      * LOOP_SEQ_x:  ALOAD clauseDataIndex
1431      *              ICONST_1
1432      *              AALOAD              // load the steps array
1433      *              ICONST x
1434      *              AALOAD              // load the step handle for clause x
1435      *              load locals
1436      *              load args
1437      *              INVOKEVIRTUAL MethodHandle.invokeBasic
1438      *              store vx
1439      *              ALOAD clauseDataIndex
1440      *              ICONST_2
1441      *              AALOAD              // load the preds array
1442      *              ICONST x
1443      *              AALOAD              // load the pred handle for clause x
1444      *              load locals
1445      *              load args
1446      *              INVOKEVIRTUAL MethodHandle.invokeBasic
1447      *              IFNE LOOP_SEQ_x+1   // predicate returned false -&gt; jump to next clause
1448      *              ALOAD clauseDataIndex
1449      *              ICONST_3
1450      *              AALOAD              // load the finis array
1451      *              ICONST x
1452      *              AALOAD              // load the fini handle for clause x
1453      *              load locals
1454      *              load args
1455      *              INVOKEVIRTUAL MethodHandle.invokeBasic
1456      *              GOTO DONE           // jump beyond end of clauses to return from loop
1457      * }&lt;/pre&gt;&lt;/blockquote&gt;
1458      */
1459     private Name emitLoop(int pos) {
1460         Name args    = lambdaForm.names[pos];
1461         Name invoker = lambdaForm.names[pos+1];
1462         Name result  = lambdaForm.names[pos+2];
1463 
1464         // extract clause and loop-local state types
1465         // find the type info in the loop invocation
1466         BasicType[] loopClauseTypes = (BasicType[]) invoker.arguments[0];
1467         Class&lt;?&gt;[] loopLocalStateTypes = Stream.of(loopClauseTypes).
1468                 filter(bt -&gt; bt != BasicType.V_TYPE).map(BasicType::basicTypeClass).toArray(Class&lt;?&gt;[]::new);
1469         Class&lt;?&gt;[] localTypes = new Class&lt;?&gt;[loopLocalStateTypes.length + 1];
1470         localTypes[0] = MethodHandleImpl.LoopClauses.class;
1471         System.arraycopy(loopLocalStateTypes, 0, localTypes, 1, loopLocalStateTypes.length);
1472 
1473         final int clauseDataIndex = extendLocalsMap(localTypes);
1474         final int firstLoopStateIndex = clauseDataIndex + 1;
1475 
1476         Class&lt;?&gt; returnType = result.function.resolvedHandle().type().returnType();
1477         MethodType loopType = args.function.resolvedHandle().type()
1478                 .dropParameterTypes(0,1)
1479                 .changeReturnType(returnType);
1480         MethodType loopHandleType = loopType.insertParameterTypes(0, loopLocalStateTypes);
1481         MethodType predType = loopHandleType.changeReturnType(boolean.class);
1482         MethodType finiType = loopHandleType;
1483 
1484         final int nClauses = loopClauseTypes.length;
1485 
1486         // indices to invoker arguments to load method handle arrays
1487         final int inits = 1;
1488         final int steps = 2;
1489         final int preds = 3;
1490         final int finis = 4;
1491 
1492         Label lLoop = new Label();
1493         Label lDone = new Label();
1494         Label lNext;
1495 
1496         // PREINIT:
1497         emitPushArgument(MethodHandleImpl.LoopClauses.class, invoker.arguments[1]);
1498         mv.visitFieldInsn(Opcodes.GETFIELD, LOOP_CLAUSES, &quot;clauses&quot;, MHARY2);
1499         emitAstoreInsn(clauseDataIndex);
1500 
1501         // INIT:
1502         for (int c = 0, state = 0; c &lt; nClauses; ++c) {
1503             MethodType cInitType = loopType.changeReturnType(loopClauseTypes[c].basicTypeClass());
1504             emitLoopHandleInvoke(invoker, inits, c, args, false, cInitType, loopLocalStateTypes, clauseDataIndex,
1505                     firstLoopStateIndex);
1506             if (cInitType.returnType() != void.class) {
1507                 emitStoreInsn(BasicType.basicType(cInitType.returnType()), firstLoopStateIndex + state);
1508                 ++state;
1509             }
1510         }
1511 
1512         // LOOP:
1513         mv.visitLabel(lLoop);
1514 
1515         for (int c = 0, state = 0; c &lt; nClauses; ++c) {
1516             lNext = new Label();
1517 
1518             MethodType stepType = loopHandleType.changeReturnType(loopClauseTypes[c].basicTypeClass());
1519             boolean isVoid = stepType.returnType() == void.class;
1520 
1521             // invoke loop step
1522             emitLoopHandleInvoke(invoker, steps, c, args, true, stepType, loopLocalStateTypes, clauseDataIndex,
1523                     firstLoopStateIndex);
1524             if (!isVoid) {
1525                 emitStoreInsn(BasicType.basicType(stepType.returnType()), firstLoopStateIndex + state);
1526                 ++state;
1527             }
1528 
1529             // invoke loop predicate
1530             emitLoopHandleInvoke(invoker, preds, c, args, true, predType, loopLocalStateTypes, clauseDataIndex,
1531                     firstLoopStateIndex);
1532             mv.visitJumpInsn(Opcodes.IFNE, lNext);
1533 
1534             // invoke fini
1535             emitLoopHandleInvoke(invoker, finis, c, args, true, finiType, loopLocalStateTypes, clauseDataIndex,
1536                     firstLoopStateIndex);
1537             mv.visitJumpInsn(Opcodes.GOTO, lDone);
1538 
1539             // this is the beginning of the next loop clause
1540             mv.visitLabel(lNext);
1541         }
1542 
1543         mv.visitJumpInsn(Opcodes.GOTO, lLoop);
1544 
1545         // DONE:
1546         mv.visitLabel(lDone);
1547 
1548         return result;
1549     }
1550 
1551     private int extendLocalsMap(Class&lt;?&gt;[] types) {
1552         int firstSlot = localsMap.length - 1;
1553         localsMap = Arrays.copyOf(localsMap, localsMap.length + types.length);
1554         localClasses = Arrays.copyOf(localClasses, localClasses.length + types.length);
1555         System.arraycopy(types, 0, localClasses, firstSlot, types.length);
1556         int index = localsMap[firstSlot - 1] + 1;
1557         int lastSlots = 0;
1558         for (int i = 0; i &lt; types.length; ++i) {
1559             localsMap[firstSlot + i] = index;
1560             lastSlots = BasicType.basicType(localClasses[firstSlot + i]).basicTypeSlots();
1561             index += lastSlots;
1562         }
1563         localsMap[localsMap.length - 1] = index - lastSlots;
1564         return firstSlot;
1565     }
1566 
1567     private void emitLoopHandleInvoke(Name holder, int handles, int clause, Name args, boolean pushLocalState,
1568                                       MethodType type, Class&lt;?&gt;[] loopLocalStateTypes, int clauseDataSlot,
1569                                       int firstLoopStateSlot) {
1570         // load handle for clause
1571         emitPushClauseArray(clauseDataSlot, handles);
1572         emitIconstInsn(clause);
1573         mv.visitInsn(Opcodes.AALOAD);
1574         // load loop state (preceding the other arguments)
1575         if (pushLocalState) {
1576             for (int s = 0; s &lt; loopLocalStateTypes.length; ++s) {
1577                 emitLoadInsn(BasicType.basicType(loopLocalStateTypes[s]), firstLoopStateSlot + s);
1578             }
1579         }
1580         // load loop args (skip 0: method handle)
1581         emitPushArguments(args, 1);
1582         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, type.toMethodDescriptorString(), false);
1583     }
1584 
1585     private void emitPushClauseArray(int clauseDataSlot, int which) {
1586         emitAloadInsn(clauseDataSlot);
1587         emitIconstInsn(which - 1);
1588         mv.visitInsn(Opcodes.AALOAD);
1589     }
1590 
1591     private void emitZero(BasicType type) {
1592         switch (type) {
1593             case I_TYPE: mv.visitInsn(Opcodes.ICONST_0); break;
1594             case J_TYPE: mv.visitInsn(Opcodes.LCONST_0); break;
1595             case F_TYPE: mv.visitInsn(Opcodes.FCONST_0); break;
1596             case D_TYPE: mv.visitInsn(Opcodes.DCONST_0); break;
1597             case L_TYPE: mv.visitInsn(Opcodes.ACONST_NULL); break;
1598             default: throw new InternalError(&quot;unknown type: &quot; + type);
1599         }
1600     }
1601 
1602     private void emitPushArguments(Name args, int start) {
1603         MethodType type = args.function.methodType();
1604         for (int i = start; i &lt; args.arguments.length; i++) {
1605             emitPushArgument(type.parameterType(i), args.arguments[i]);
1606         }
1607     }
1608 
1609     private void emitPushArgument(Name name, int paramIndex) {
1610         Object arg = name.arguments[paramIndex];
1611         Class&lt;?&gt; ptype = name.function.methodType().parameterType(paramIndex);
1612         emitPushArgument(ptype, arg);
1613     }
1614 
1615     private void emitPushArgument(Class&lt;?&gt; ptype, Object arg) {
1616         BasicType bptype = basicType(ptype);
1617         if (arg instanceof Name) {
1618             Name n = (Name) arg;
1619             emitLoadInsn(n.type, n.index());
1620             emitImplicitConversion(n.type, ptype, n);
1621         } else if ((arg == null || arg instanceof String) &amp;&amp; bptype == L_TYPE) {
1622             emitConst(arg);
1623         } else {
1624             if (Wrapper.isWrapperType(arg.getClass()) &amp;&amp; bptype != L_TYPE) {
1625                 emitConst(arg);
1626             } else {
1627                 mv.visitLdcInsn(constantPlaceholder(arg));
1628                 emitImplicitConversion(L_TYPE, ptype, arg);
1629             }
1630         }
1631     }
1632 
1633     /**
1634      * Store the name to its local, if necessary.
1635      */
1636     private void emitStoreResult(Name name) {
1637         if (name != null &amp;&amp; name.type != V_TYPE) {
1638             // non-void: actually assign
1639             emitStoreInsn(name.type, name.index());
1640         }
1641     }
1642 
1643     /**
1644      * Emits a return statement from a LF invoker. If required, the result type is cast to the correct return type.
1645      */
1646     private void emitReturn(Name onStack) {
1647         // return statement
1648         Class&lt;?&gt; rclass = invokerType.returnType();
1649         BasicType rtype = lambdaForm.returnType();
1650         assert(rtype == basicType(rclass));  // must agree
1651         if (rtype == V_TYPE) {
1652             // void
1653             mv.visitInsn(Opcodes.RETURN);
1654             // it doesn&#39;t matter what rclass is; the JVM will discard any value
1655         } else {
1656             LambdaForm.Name rn = lambdaForm.names[lambdaForm.result];
1657 
1658             // put return value on the stack if it is not already there
1659             if (rn != onStack) {
1660                 emitLoadInsn(rtype, lambdaForm.result);
1661             }
1662 
1663             emitImplicitConversion(rtype, rclass, rn);
1664 
1665             // generate actual return statement
1666             emitReturnInsn(rtype);
1667         }
1668     }
1669 
1670     /**
1671      * Emit a type conversion bytecode casting from &quot;from&quot; to &quot;to&quot;.
1672      */
1673     private void emitPrimCast(Wrapper from, Wrapper to) {
1674         // Here&#39;s how.
1675         // -   indicates forbidden
1676         // &lt;-&gt; indicates implicit
1677         //      to ----&gt; boolean  byte     short    char     int      long     float    double
1678         // from boolean    &lt;-&gt;        -        -        -        -        -        -        -
1679         //      byte        -       &lt;-&gt;       i2s      i2c      &lt;-&gt;      i2l      i2f      i2d
1680         //      short       -       i2b       &lt;-&gt;      i2c      &lt;-&gt;      i2l      i2f      i2d
1681         //      char        -       i2b       i2s      &lt;-&gt;      &lt;-&gt;      i2l      i2f      i2d
1682         //      int         -       i2b       i2s      i2c      &lt;-&gt;      i2l      i2f      i2d
1683         //      long        -     l2i,i2b   l2i,i2s  l2i,i2c    l2i      &lt;-&gt;      l2f      l2d
1684         //      float       -     f2i,i2b   f2i,i2s  f2i,i2c    f2i      f2l      &lt;-&gt;      f2d
1685         //      double      -     d2i,i2b   d2i,i2s  d2i,i2c    d2i      d2l      d2f      &lt;-&gt;
1686         if (from == to) {
1687             // no cast required, should be dead code anyway
1688             return;
1689         }
1690         if (from.isSubwordOrInt()) {
1691             // cast from {byte,short,char,int} to anything
1692             emitI2X(to);
1693         } else {
1694             // cast from {long,float,double} to anything
1695             if (to.isSubwordOrInt()) {
1696                 // cast to {byte,short,char,int}
1697                 emitX2I(from);
1698                 if (to.bitWidth() &lt; 32) {
1699                     // targets other than int require another conversion
1700                     emitI2X(to);
1701                 }
1702             } else {
1703                 // cast to {long,float,double} - this is verbose
1704                 boolean error = false;
1705                 switch (from) {
1706                 case LONG:
1707                     switch (to) {
1708                     case FLOAT:   mv.visitInsn(Opcodes.L2F);  break;
1709                     case DOUBLE:  mv.visitInsn(Opcodes.L2D);  break;
1710                     default:      error = true;               break;
1711                     }
1712                     break;
1713                 case FLOAT:
1714                     switch (to) {
1715                     case LONG :   mv.visitInsn(Opcodes.F2L);  break;
1716                     case DOUBLE:  mv.visitInsn(Opcodes.F2D);  break;
1717                     default:      error = true;               break;
1718                     }
1719                     break;
1720                 case DOUBLE:
1721                     switch (to) {
1722                     case LONG :   mv.visitInsn(Opcodes.D2L);  break;
1723                     case FLOAT:   mv.visitInsn(Opcodes.D2F);  break;
1724                     default:      error = true;               break;
1725                     }
1726                     break;
1727                 default:
1728                     error = true;
1729                     break;
1730                 }
1731                 if (error) {
1732                     throw new IllegalStateException(&quot;unhandled prim cast: &quot; + from + &quot;2&quot; + to);
1733                 }
1734             }
1735         }
1736     }
1737 
1738     private void emitI2X(Wrapper type) {
1739         switch (type) {
1740         case BYTE:    mv.visitInsn(Opcodes.I2B);  break;
1741         case SHORT:   mv.visitInsn(Opcodes.I2S);  break;
1742         case CHAR:    mv.visitInsn(Opcodes.I2C);  break;
1743         case INT:     /* naught */                break;
1744         case LONG:    mv.visitInsn(Opcodes.I2L);  break;
1745         case FLOAT:   mv.visitInsn(Opcodes.I2F);  break;
1746         case DOUBLE:  mv.visitInsn(Opcodes.I2D);  break;
1747         case BOOLEAN:
1748             // For compatibility with ValueConversions and explicitCastArguments:
1749             mv.visitInsn(Opcodes.ICONST_1);
1750             mv.visitInsn(Opcodes.IAND);
1751             break;
1752         default:   throw new InternalError(&quot;unknown type: &quot; + type);
1753         }
1754     }
1755 
1756     private void emitX2I(Wrapper type) {
1757         switch (type) {
1758         case LONG:    mv.visitInsn(Opcodes.L2I);  break;
1759         case FLOAT:   mv.visitInsn(Opcodes.F2I);  break;
1760         case DOUBLE:  mv.visitInsn(Opcodes.D2I);  break;
1761         default:      throw new InternalError(&quot;unknown type: &quot; + type);
1762         }
1763     }
1764 
1765     /**
1766      * Generate bytecode for a LambdaForm.vmentry which calls interpretWithArguments.
1767      */
1768     static MemberName generateLambdaFormInterpreterEntryPoint(MethodType mt) {
1769         assert(isValidSignature(basicTypeSignature(mt)));
1770         String name = &quot;interpret_&quot;+basicTypeChar(mt.returnType());
1771         MethodType type = mt;  // includes leading argument
1772         type = type.changeParameterType(0, MethodHandle.class);
1773         InvokerBytecodeGenerator g = new InvokerBytecodeGenerator(&quot;LFI&quot;, name, type);
1774         return g.loadMethod(g.generateLambdaFormInterpreterEntryPointBytes());
1775     }
1776 
1777     private byte[] generateLambdaFormInterpreterEntryPointBytes() {
1778         classFilePrologue();
1779         methodPrologue();
1780 
1781         // Suppress this method in backtraces displayed to the user.
1782         mv.visitAnnotation(HIDDEN_SIG, true);
1783 
1784         // Don&#39;t inline the interpreter entry.
1785         mv.visitAnnotation(DONTINLINE_SIG, true);
1786 
1787         // create parameter array
1788         emitIconstInsn(invokerType.parameterCount());
1789         mv.visitTypeInsn(Opcodes.ANEWARRAY, &quot;java/lang/Object&quot;);
1790 
1791         // fill parameter array
1792         for (int i = 0; i &lt; invokerType.parameterCount(); i++) {
1793             Class&lt;?&gt; ptype = invokerType.parameterType(i);
1794             mv.visitInsn(Opcodes.DUP);
1795             emitIconstInsn(i);
1796             emitLoadInsn(basicType(ptype), i);
1797             // box if primitive type
1798             if (ptype.isPrimitive()) {
1799                 emitBoxing(Wrapper.forPrimitiveType(ptype));
1800             }
1801             mv.visitInsn(Opcodes.AASTORE);
1802         }
1803         // invoke
1804         emitAloadInsn(0);
1805         mv.visitFieldInsn(Opcodes.GETFIELD, MH, &quot;form&quot;, &quot;Ljava/lang/invoke/LambdaForm;&quot;);
1806         mv.visitInsn(Opcodes.SWAP);  // swap form and array; avoid local variable
1807         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, LF, &quot;interpretWithArguments&quot;, &quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;, false);
1808 
1809         // maybe unbox
1810         Class&lt;?&gt; rtype = invokerType.returnType();
1811         if (rtype.isPrimitive() &amp;&amp; rtype != void.class) {
1812             emitUnboxing(Wrapper.forPrimitiveType(rtype));
1813         }
1814 
1815         // return statement
1816         emitReturnInsn(basicType(rtype));
1817 
1818         methodEpilogue();
1819         bogusMethod(invokerType);
1820 
1821         final byte[] classFile = cw.toByteArray();
1822         maybeDump(classFile);
1823         return classFile;
1824     }
1825 
1826     /**
1827      * Generate bytecode for a NamedFunction invoker.
1828      */
1829     static MemberName generateNamedFunctionInvoker(MethodTypeForm typeForm) {
1830         MethodType invokerType = NamedFunction.INVOKER_METHOD_TYPE;
1831         String invokerName = &quot;invoke_&quot; + shortenSignature(basicTypeSignature(typeForm.erasedType()));
1832         InvokerBytecodeGenerator g = new InvokerBytecodeGenerator(&quot;NFI&quot;, invokerName, invokerType);
1833         return g.loadMethod(g.generateNamedFunctionInvokerImpl(typeForm));
1834     }
1835 
1836     private byte[] generateNamedFunctionInvokerImpl(MethodTypeForm typeForm) {
1837         MethodType dstType = typeForm.erasedType();
1838         classFilePrologue();
1839         methodPrologue();
1840 
1841         // Suppress this method in backtraces displayed to the user.
1842         mv.visitAnnotation(HIDDEN_SIG, true);
1843 
1844         // Force inlining of this invoker method.
1845         mv.visitAnnotation(FORCEINLINE_SIG, true);
1846 
1847         // Load receiver
1848         emitAloadInsn(0);
1849 
1850         // Load arguments from array
1851         for (int i = 0; i &lt; dstType.parameterCount(); i++) {
1852             emitAloadInsn(1);
1853             emitIconstInsn(i);
1854             mv.visitInsn(Opcodes.AALOAD);
1855 
1856             // Maybe unbox
1857             Class&lt;?&gt; dptype = dstType.parameterType(i);
1858             if (dptype.isPrimitive()) {
1859                 Wrapper dstWrapper = Wrapper.forBasicType(dptype);
1860                 Wrapper srcWrapper = dstWrapper.isSubwordOrInt() ? Wrapper.INT : dstWrapper;  // narrow subword from int
1861                 emitUnboxing(srcWrapper);
1862                 emitPrimCast(srcWrapper, dstWrapper);
1863             }
1864         }
1865 
1866         // Invoke
1867         String targetDesc = dstType.basicType().toMethodDescriptorString();
1868         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, targetDesc, false);
1869 
1870         // Box primitive types
1871         Class&lt;?&gt; rtype = dstType.returnType();
1872         if (rtype != void.class &amp;&amp; rtype.isPrimitive()) {
1873             Wrapper srcWrapper = Wrapper.forBasicType(rtype);
1874             Wrapper dstWrapper = srcWrapper.isSubwordOrInt() ? Wrapper.INT : srcWrapper;  // widen subword to int
1875             // boolean casts not allowed
1876             emitPrimCast(srcWrapper, dstWrapper);
1877             emitBoxing(dstWrapper);
1878         }
1879 
1880         // If the return type is void we return a null reference.
1881         if (rtype == void.class) {
1882             mv.visitInsn(Opcodes.ACONST_NULL);
1883         }
1884         emitReturnInsn(L_TYPE);  // NOTE: NamedFunction invokers always return a reference value.
1885 
1886         methodEpilogue();
1887         bogusMethod(dstType);
1888 
1889         final byte[] classFile = cw.toByteArray();
1890         maybeDump(classFile);
1891         return classFile;
1892     }
1893 
1894     /**
1895      * Emit a bogus method that just loads some string constants. This is to get the constants into the constant pool
1896      * for debugging purposes.
1897      */
1898     private void bogusMethod(Object os) {
1899         if (DUMP_CLASS_FILES) {
1900             mv = cw.visitMethod(Opcodes.ACC_STATIC, &quot;dummy&quot;, &quot;()V&quot;, null, null);
1901             mv.visitLdcInsn(os.toString());
1902             mv.visitInsn(Opcodes.POP);
1903             mv.visitInsn(Opcodes.RETURN);
1904             mv.visitMaxs(0, 0);
1905             mv.visitEnd();
1906         }
1907     }
1908 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/System.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="String.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Thread.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/System.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1602          * @return an instance of {@link Logger Logger}  which will use the
1603          * provided resource bundle for message localization.
1604          *
1605          * @throws NullPointerException if {@code name} is {@code null} or
1606          *         {@code module} is {@code null}.
1607          * @throws SecurityException if a security manager is present and its
1608          *         {@code checkPermission} method doesn&#39;t allow the
1609          *         {@code RuntimePermission(&quot;loggerFinder&quot;)}.
1610          */
1611         public Logger getLocalizedLogger(String name, ResourceBundle bundle,
1612                                          Module module) {
1613             return new LocalizedLoggerWrapper&lt;&gt;(getLogger(name, module), bundle);
1614         }
1615 
1616         /**
1617          * Returns the {@code LoggerFinder} instance. There is one
1618          * single system-wide {@code LoggerFinder} instance in
1619          * the Java Runtime.  See the class specification of how the
1620          * {@link LoggerFinder LoggerFinder} implementation is located and
1621          * loaded.
<span class="line-modified">1622 </span>
1623          * @return the {@link LoggerFinder LoggerFinder} instance.
1624          * @throws SecurityException if a security manager is present and its
1625          *         {@code checkPermission} method doesn&#39;t allow the
1626          *         {@code RuntimePermission(&quot;loggerFinder&quot;)}.
1627          */
1628         public static LoggerFinder getLoggerFinder() {
1629             final SecurityManager sm = System.getSecurityManager();
1630             if (sm != null) {
1631                 sm.checkPermission(LOGGERFINDER_PERMISSION);
1632             }
1633             return accessProvider();
1634         }
1635 
1636 
1637         private static volatile LoggerFinder service;
1638         static LoggerFinder accessProvider() {
1639             // We do not need to synchronize: LoggerFinderLoader will
1640             // always return the same instance, so if we don&#39;t have it,
1641             // just fetch it again.
1642             if (service == null) {
</pre>
<hr />
<pre>
2259             }
2260 
2261             public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {
2262                 return StringCoding.newStringNoRepl(bytes, cs);
2263             }
2264 
2265             public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {
2266                 return StringCoding.getBytesNoRepl(s, cs);
2267             }
2268 
2269             public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {
2270                 return StringCoding.newStringUTF8NoRepl(bytes, off, len);
2271             }
2272 
2273             public byte[] getBytesUTF8NoRepl(String s) {
2274                 return StringCoding.getBytesUTF8NoRepl(s);
2275             }
2276             public void setCause(Throwable t, Throwable cause) {
2277                 t.setCause(cause);
2278             }
<span class="line-removed">2279 </span>
<span class="line-removed">2280             public void loadLibrary(Class&lt;?&gt; caller, String library) {</span>
<span class="line-removed">2281                 assert library.indexOf(java.io.File.separatorChar) &lt; 0;</span>
<span class="line-removed">2282                 ClassLoader.loadLibrary(caller, library, false);</span>
<span class="line-removed">2283             }</span>
2284         });
2285     }
2286 }
</pre>
</td>
<td>
<hr />
<pre>
1602          * @return an instance of {@link Logger Logger}  which will use the
1603          * provided resource bundle for message localization.
1604          *
1605          * @throws NullPointerException if {@code name} is {@code null} or
1606          *         {@code module} is {@code null}.
1607          * @throws SecurityException if a security manager is present and its
1608          *         {@code checkPermission} method doesn&#39;t allow the
1609          *         {@code RuntimePermission(&quot;loggerFinder&quot;)}.
1610          */
1611         public Logger getLocalizedLogger(String name, ResourceBundle bundle,
1612                                          Module module) {
1613             return new LocalizedLoggerWrapper&lt;&gt;(getLogger(name, module), bundle);
1614         }
1615 
1616         /**
1617          * Returns the {@code LoggerFinder} instance. There is one
1618          * single system-wide {@code LoggerFinder} instance in
1619          * the Java Runtime.  See the class specification of how the
1620          * {@link LoggerFinder LoggerFinder} implementation is located and
1621          * loaded.
<span class="line-modified">1622          *</span>
1623          * @return the {@link LoggerFinder LoggerFinder} instance.
1624          * @throws SecurityException if a security manager is present and its
1625          *         {@code checkPermission} method doesn&#39;t allow the
1626          *         {@code RuntimePermission(&quot;loggerFinder&quot;)}.
1627          */
1628         public static LoggerFinder getLoggerFinder() {
1629             final SecurityManager sm = System.getSecurityManager();
1630             if (sm != null) {
1631                 sm.checkPermission(LOGGERFINDER_PERMISSION);
1632             }
1633             return accessProvider();
1634         }
1635 
1636 
1637         private static volatile LoggerFinder service;
1638         static LoggerFinder accessProvider() {
1639             // We do not need to synchronize: LoggerFinderLoader will
1640             // always return the same instance, so if we don&#39;t have it,
1641             // just fetch it again.
1642             if (service == null) {
</pre>
<hr />
<pre>
2259             }
2260 
2261             public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {
2262                 return StringCoding.newStringNoRepl(bytes, cs);
2263             }
2264 
2265             public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {
2266                 return StringCoding.getBytesNoRepl(s, cs);
2267             }
2268 
2269             public String newStringUTF8NoRepl(byte[] bytes, int off, int len) {
2270                 return StringCoding.newStringUTF8NoRepl(bytes, off, len);
2271             }
2272 
2273             public byte[] getBytesUTF8NoRepl(String s) {
2274                 return StringCoding.getBytesUTF8NoRepl(s);
2275             }
2276             public void setCause(Throwable t, Throwable cause) {
2277                 t.setCause(cause);
2278             }





2279         });
2280     }
2281 }
</pre>
</td>
</tr>
</table>
<center><a href="String.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Thread.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/jdk/internal/misc/Unsafe.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.misc;
  27 
  28 import jdk.internal.HotSpotIntrinsicCandidate;
  29 import jdk.internal.ref.Cleaner;
  30 import jdk.internal.vm.annotation.ForceInline;
  31 import sun.nio.ch.DirectBuffer;
  32 
  33 import java.lang.reflect.Field;
  34 import java.security.ProtectionDomain;
  35 
  36 import static jdk.internal.misc.UnsafeConstants.*;
  37 
  38 /**
  39  * A collection of methods for performing low-level, unsafe operations.
  40  * Although the class and all methods are public, use of this class is
  41  * limited because only trusted code can obtain instances of it.
  42  *
  43  * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make sure
  44  * arguments are checked before methods of this class are
  45  * called. While some rudimentary checks are performed on the input,
  46  * the checks are best effort and when performance is an overriding
  47  * priority, as when methods of this class are optimized by the
  48  * runtime compiler, some or all checks (if any) may be elided. Hence,
  49  * the caller must not rely on the checks and corresponding
  50  * exceptions!
  51  *
  52  * @author John R. Rose
  53  * @see #getUnsafe
  54  */
  55 
  56 public final class Unsafe {
  57 
  58     private static native void registerNatives();
  59     static {
  60         registerNatives();
  61     }
  62 
  63     private Unsafe() {}
  64 
  65     private static final Unsafe theUnsafe = new Unsafe();
  66 
  67     /**
  68      * Provides the caller with the capability of performing unsafe
  69      * operations.
  70      *
  71      * &lt;p&gt;The returned {@code Unsafe} object should be carefully guarded
  72      * by the caller, since it can be used to read and write data at arbitrary
  73      * memory addresses.  It must never be passed to untrusted code.
  74      *
  75      * &lt;p&gt;Most methods in this class are very low-level, and correspond to a
  76      * small number of hardware instructions (on typical machines).  Compilers
  77      * are encouraged to optimize these methods accordingly.
  78      *
  79      * &lt;p&gt;Here is a suggested idiom for using unsafe operations:
  80      *
  81      * &lt;pre&gt; {@code
  82      * class MyTrustedClass {
  83      *   private static final Unsafe unsafe = Unsafe.getUnsafe();
  84      *   ...
  85      *   private long myCountAddress = ...;
  86      *   public int getCount() { return unsafe.getByte(myCountAddress); }
  87      * }}&lt;/pre&gt;
  88      *
  89      * (It may assist compilers to make the local variable {@code final}.)
  90      */
  91     public static Unsafe getUnsafe() {
  92         return theUnsafe;
  93     }
  94 
  95     /// peek and poke operations
  96     /// (compilers should optimize these to memory ops)
  97 
  98     // These work on object fields in the Java heap.
  99     // They will not work on elements of packed arrays.
 100 
 101     /**
 102      * Fetches a value from a given Java variable.
 103      * More specifically, fetches a field or array element within the given
 104      * object {@code o} at the given offset, or (if {@code o} is null)
 105      * from the memory address whose numerical value is the given offset.
 106      * &lt;p&gt;
 107      * The results are undefined unless one of the following cases is true:
 108      * &lt;ul&gt;
 109      * &lt;li&gt;The offset was obtained from {@link #objectFieldOffset} on
 110      * the {@link java.lang.reflect.Field} of some Java field and the object
 111      * referred to by {@code o} is of a class compatible with that
 112      * field&#39;s class.
 113      *
 114      * &lt;li&gt;The offset and object reference {@code o} (either null or
 115      * non-null) were both obtained via {@link #staticFieldOffset}
 116      * and {@link #staticFieldBase} (respectively) from the
 117      * reflective {@link Field} representation of some Java field.
 118      *
 119      * &lt;li&gt;The object referred to by {@code o} is an array, and the offset
 120      * is an integer of the form {@code B+N*S}, where {@code N} is
 121      * a valid index into the array, and {@code B} and {@code S} are
 122      * the values obtained by {@link #arrayBaseOffset} and {@link
 123      * #arrayIndexScale} (respectively) from the array&#39;s class.  The value
 124      * referred to is the {@code N}&lt;em&gt;th&lt;/em&gt; element of the array.
 125      *
 126      * &lt;/ul&gt;
 127      * &lt;p&gt;
 128      * If one of the above cases is true, the call references a specific Java
 129      * variable (field or array element).  However, the results are undefined
 130      * if that variable is not in fact of the type returned by this method.
 131      * &lt;p&gt;
 132      * This method refers to a variable by means of two parameters, and so
 133      * it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode
 134      * for Java variables.  When the object reference is null, this method
 135      * uses its offset as an absolute address.  This is similar in operation
 136      * to methods such as {@link #getInt(long)}, which provide (in effect) a
 137      * &lt;em&gt;single-register&lt;/em&gt; addressing mode for non-Java variables.
 138      * However, because Java variables may have a different layout in memory
 139      * from non-Java variables, programmers should not assume that these
 140      * two addressing modes are ever equivalent.  Also, programmers should
 141      * remember that offsets from the double-register addressing mode cannot
 142      * be portably confused with longs used in the single-register addressing
 143      * mode.
 144      *
 145      * @param o Java heap object in which the variable resides, if any, else
 146      *        null
 147      * @param offset indication of where the variable resides in a Java heap
 148      *        object, if any, else a memory address locating the variable
 149      *        statically
 150      * @return the value fetched from the indicated Java variable
 151      * @throws RuntimeException No defined exceptions are thrown, not even
 152      *         {@link NullPointerException}
 153      */
 154     @HotSpotIntrinsicCandidate
 155     public native int getInt(Object o, long offset);
 156 
 157     /**
 158      * Stores a value into a given Java variable.
 159      * &lt;p&gt;
 160      * The first two parameters are interpreted exactly as with
 161      * {@link #getInt(Object, long)} to refer to a specific
 162      * Java variable (field or array element).  The given value
 163      * is stored into that variable.
 164      * &lt;p&gt;
 165      * The variable must be of the same type as the method
 166      * parameter {@code x}.
 167      *
 168      * @param o Java heap object in which the variable resides, if any, else
 169      *        null
 170      * @param offset indication of where the variable resides in a Java heap
 171      *        object, if any, else a memory address locating the variable
 172      *        statically
 173      * @param x the value to store into the indicated Java variable
 174      * @throws RuntimeException No defined exceptions are thrown, not even
 175      *         {@link NullPointerException}
 176      */
 177     @HotSpotIntrinsicCandidate
 178     public native void putInt(Object o, long offset, int x);
 179 
 180     private static final int JVM_ACC_FLATTENED = 0x00008000; // HotSpot-specific bit
 181 
 182     /**
 183      * Returns true if the given field is flattened.
 184      */
 185     public boolean isFlattened(Field f) {
 186         return (f.getModifiers() &amp; JVM_ACC_FLATTENED) == JVM_ACC_FLATTENED;
 187     }
 188 
 189     /**
 190      * Returns true if the given class is a flattened array.
 191      */
 192     public native boolean isFlattenedArray(Class&lt;?&gt; arrayClass);
 193 
 194     /**
 195      * Fetches a reference value from a given Java variable.
 196      * This method can return a reference to either an object or value
 197      * or a null reference.
 198      *
 199      * @see #getInt(Object, long)
 200      */
 201     @HotSpotIntrinsicCandidate
 202     public native Object getReference(Object o, long offset);
 203 
 204     /**
 205      * Stores a reference value into a given Java variable.
 206      * This method can store a reference to either an object or value
 207      * or a null reference.
 208      * &lt;p&gt;
 209      * Unless the reference {@code x} being stored is either null
 210      * or matches the field type, the results are undefined.
 211      * If the reference {@code o} is non-null, card marks or
 212      * other store barriers for that object (if the VM requires them)
 213      * are updated.
 214      * @see #putInt(Object, long, int)
 215      */
 216     @HotSpotIntrinsicCandidate
 217     public native void putReference(Object o, long offset, Object x);
 218 
 219     /**
 220      * Fetches a value of type {@code &lt;V&gt;} from a given Java variable.
 221      * More specifically, fetches a field or array element within the given
 222      * {@code o} object at the given offset, or (if {@code o} is null)
 223      * from the memory address whose numerical value is the given offset.
 224      *
 225      * @param o Java heap object in which the variable resides, if any, else
 226      *        null
 227      * @param offset indication of where the variable resides in a Java heap
 228      *        object, if any, else a memory address locating the variable
 229      *        statically
 230      * @param vc inline class
 231      * @param &lt;V&gt; the type of a value
 232      * @return the value fetched from the indicated Java variable
 233      * @throws RuntimeException No defined exceptions are thrown, not even
 234      *         {@link NullPointerException}
 235      */
 236     @HotSpotIntrinsicCandidate
 237     public native &lt;V&gt; V getValue(Object o, long offset, Class&lt;?&gt; vc);
 238 
 239     /**
 240      * Stores the given value into a given Java variable.
 241      *
 242      * Unless the reference {@code o} being stored is either null
 243      * or matches the field type, the results are undefined.
 244      *
 245      * @param o Java heap object in which the variable resides, if any, else
 246      *        null
 247      * @param offset indication of where the variable resides in a Java heap
 248      *        object, if any, else a memory address locating the variable
 249      *        statically
 250      * @param vc inline class
 251      * @param v the value to store into the indicated Java variable
 252      * @param &lt;V&gt; the type of a value
 253      * @throws RuntimeException No defined exceptions are thrown, not even
 254      *         {@link NullPointerException}
 255      */
 256     @HotSpotIntrinsicCandidate
 257     public native &lt;V&gt; void putValue(Object o, long offset, Class&lt;?&gt; vc, V v);
 258 
 259     /**
 260      * Fetches a reference value of type {@code vc} from a given Java variable.
 261      * This method can return a reference to a value or a null reference
 262      * for a nullable-projection of an inline type.
 263      *
 264      * @param vc inline class
 265      */
 266     public Object getReference(Object o, long offset, Class&lt;?&gt; vc) {
 267         Object ref = getReference(o, offset);
 268         if (ref == null &amp;&amp; vc.isInlineClass() &amp;&amp; !vc.isIndirectType()) {
 269             // If the type of the returned reference is a regular inline type
 270             // return an uninitialized default value if null
 271             ref = uninitializedDefaultValue(vc);
 272         }
 273         return ref;
 274     }
 275 
 276     public Object getReferenceVolatile(Object o, long offset, Class&lt;?&gt; vc) {
 277         Object ref = getReferenceVolatile(o, offset);
 278         if (ref == null &amp;&amp; vc.isInlineClass() &amp;&amp; !vc.isIndirectType()) {
 279             // If the type of the returned reference is a regular inline type
 280             // return an uninitialized default value if null
 281             ref = uninitializedDefaultValue(vc);
 282         }
 283         return ref;
 284     }
 285 
 286     /**
 287      * Returns an uninitialized default value of the given inline class.
 288      */
 289     public native &lt;V&gt; V uninitializedDefaultValue(Class&lt;?&gt; vc);
 290 
 291     /**
 292      * Returns an object instance with a private buffered value whose layout
 293      * and contents is exactly the given value instance.  The return object
 294      * is in the larval state that can be updated using the unsafe put operation.
 295      *
 296      * @param value a value instance
 297      * @param &lt;V&gt; the type of the given value instance
 298      */
 299     @HotSpotIntrinsicCandidate
 300     public native &lt;V&gt; V makePrivateBuffer(V value);
 301 
 302     /**
 303      * Exits the larval state and returns a value instance.
 304      *
 305      * @param value a value instance
 306      * @param &lt;V&gt; the type of the given value instance
 307      */
 308     @HotSpotIntrinsicCandidate
 309     public native &lt;V&gt; V finishPrivateBuffer(V value);
 310 
 311     /**
 312      * Returns the header size of the given inline class
 313      *
 314      * @param vc inline class
 315      * @param &lt;V&gt; value clas
 316      * @return the header size of the inline class
 317      */
 318     public native &lt;V&gt; long valueHeaderSize(Class&lt;V&gt; vc);
 319 
 320     /** @see #getInt(Object, long) */
 321     @HotSpotIntrinsicCandidate
 322     public native boolean getBoolean(Object o, long offset);
 323 
 324     /** @see #putInt(Object, long, int) */
 325     @HotSpotIntrinsicCandidate
 326     public native void    putBoolean(Object o, long offset, boolean x);
 327 
 328     /** @see #getInt(Object, long) */
 329     @HotSpotIntrinsicCandidate
 330     public native byte    getByte(Object o, long offset);
 331 
 332     /** @see #putInt(Object, long, int) */
 333     @HotSpotIntrinsicCandidate
 334     public native void    putByte(Object o, long offset, byte x);
 335 
 336     /** @see #getInt(Object, long) */
 337     @HotSpotIntrinsicCandidate
 338     public native short   getShort(Object o, long offset);
 339 
 340     /** @see #putInt(Object, long, int) */
 341     @HotSpotIntrinsicCandidate
 342     public native void    putShort(Object o, long offset, short x);
 343 
 344     /** @see #getInt(Object, long) */
 345     @HotSpotIntrinsicCandidate
 346     public native char    getChar(Object o, long offset);
 347 
 348     /** @see #putInt(Object, long, int) */
 349     @HotSpotIntrinsicCandidate
 350     public native void    putChar(Object o, long offset, char x);
 351 
 352     /** @see #getInt(Object, long) */
 353     @HotSpotIntrinsicCandidate
 354     public native long    getLong(Object o, long offset);
 355 
 356     /** @see #putInt(Object, long, int) */
 357     @HotSpotIntrinsicCandidate
 358     public native void    putLong(Object o, long offset, long x);
 359 
 360     /** @see #getInt(Object, long) */
 361     @HotSpotIntrinsicCandidate
 362     public native float   getFloat(Object o, long offset);
 363 
 364     /** @see #putInt(Object, long, int) */
 365     @HotSpotIntrinsicCandidate
 366     public native void    putFloat(Object o, long offset, float x);
 367 
 368     /** @see #getInt(Object, long) */
 369     @HotSpotIntrinsicCandidate
 370     public native double  getDouble(Object o, long offset);
 371 
 372     /** @see #putInt(Object, long, int) */
 373     @HotSpotIntrinsicCandidate
 374     public native void    putDouble(Object o, long offset, double x);
 375 
 376     /**
 377      * Fetches a native pointer from a given memory address.  If the address is
 378      * zero, or does not point into a block obtained from {@link
 379      * #allocateMemory}, the results are undefined.
 380      *
 381      * &lt;p&gt;If the native pointer is less than 64 bits wide, it is extended as
 382      * an unsigned number to a Java long.  The pointer may be indexed by any
 383      * given byte offset, simply by adding that offset (as a simple integer) to
 384      * the long representing the pointer.  The number of bytes actually read
 385      * from the target address may be determined by consulting {@link
 386      * #addressSize}.
 387      *
 388      * @see #allocateMemory
 389      * @see #getInt(Object, long)
 390      */
 391     @ForceInline
 392     public long getAddress(Object o, long offset) {
 393         if (ADDRESS_SIZE == 4) {
 394             return Integer.toUnsignedLong(getInt(o, offset));
 395         } else {
 396             return getLong(o, offset);
 397         }
 398     }
 399 
 400     /**
 401      * Stores a native pointer into a given memory address.  If the address is
 402      * zero, or does not point into a block obtained from {@link
 403      * #allocateMemory}, the results are undefined.
 404      *
 405      * &lt;p&gt;The number of bytes actually written at the target address may be
 406      * determined by consulting {@link #addressSize}.
 407      *
 408      * @see #allocateMemory
 409      * @see #putInt(Object, long, int)
 410      */
 411     @ForceInline
 412     public void putAddress(Object o, long offset, long x) {
 413         if (ADDRESS_SIZE == 4) {
 414             putInt(o, offset, (int)x);
 415         } else {
 416             putLong(o, offset, x);
 417         }
 418     }
 419 
 420     // These read VM internal data.
 421 
 422     /**
 423      * Fetches an uncompressed reference value from a given native variable
 424      * ignoring the VM&#39;s compressed references mode.
 425      *
 426      * @param address a memory address locating the variable
 427      * @return the value fetched from the indicated native variable
 428      */
 429     public native Object getUncompressedObject(long address);
 430 
 431     // These work on values in the C heap.
 432 
 433     /**
 434      * Fetches a value from a given memory address.  If the address is zero, or
 435      * does not point into a block obtained from {@link #allocateMemory}, the
 436      * results are undefined.
 437      *
 438      * @see #allocateMemory
 439      */
 440     @ForceInline
 441     public byte getByte(long address) {
 442         return getByte(null, address);
 443     }
 444 
 445     /**
 446      * Stores a value into a given memory address.  If the address is zero, or
 447      * does not point into a block obtained from {@link #allocateMemory}, the
 448      * results are undefined.
 449      *
 450      * @see #getByte(long)
 451      */
 452     @ForceInline
 453     public void putByte(long address, byte x) {
 454         putByte(null, address, x);
 455     }
 456 
 457     /** @see #getByte(long) */
 458     @ForceInline
 459     public short getShort(long address) {
 460         return getShort(null, address);
 461     }
 462 
 463     /** @see #putByte(long, byte) */
 464     @ForceInline
 465     public void putShort(long address, short x) {
 466         putShort(null, address, x);
 467     }
 468 
 469     /** @see #getByte(long) */
 470     @ForceInline
 471     public char getChar(long address) {
 472         return getChar(null, address);
 473     }
 474 
 475     /** @see #putByte(long, byte) */
 476     @ForceInline
 477     public void putChar(long address, char x) {
 478         putChar(null, address, x);
 479     }
 480 
 481     /** @see #getByte(long) */
 482     @ForceInline
 483     public int getInt(long address) {
 484         return getInt(null, address);
 485     }
 486 
 487     /** @see #putByte(long, byte) */
 488     @ForceInline
 489     public void putInt(long address, int x) {
 490         putInt(null, address, x);
 491     }
 492 
 493     /** @see #getByte(long) */
 494     @ForceInline
 495     public long getLong(long address) {
 496         return getLong(null, address);
 497     }
 498 
 499     /** @see #putByte(long, byte) */
 500     @ForceInline
 501     public void putLong(long address, long x) {
 502         putLong(null, address, x);
 503     }
 504 
 505     /** @see #getByte(long) */
 506     @ForceInline
 507     public float getFloat(long address) {
 508         return getFloat(null, address);
 509     }
 510 
 511     /** @see #putByte(long, byte) */
 512     @ForceInline
 513     public void putFloat(long address, float x) {
 514         putFloat(null, address, x);
 515     }
 516 
 517     /** @see #getByte(long) */
 518     @ForceInline
 519     public double getDouble(long address) {
 520         return getDouble(null, address);
 521     }
 522 
 523     /** @see #putByte(long, byte) */
 524     @ForceInline
 525     public void putDouble(long address, double x) {
 526         putDouble(null, address, x);
 527     }
 528 
 529     /** @see #getAddress(Object, long) */
 530     @ForceInline
 531     public long getAddress(long address) {
 532         return getAddress(null, address);
 533     }
 534 
 535     /** @see #putAddress(Object, long, long) */
 536     @ForceInline
 537     public void putAddress(long address, long x) {
 538         putAddress(null, address, x);
 539     }
 540 
 541 
 542 
 543     /// helper methods for validating various types of objects/values
 544 
 545     /**
 546      * Create an exception reflecting that some of the input was invalid
 547      *
 548      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
 549      * sure arguments are checked before the methods are called. While
 550      * some rudimentary checks are performed on the input, the checks
 551      * are best effort and when performance is an overriding priority,
 552      * as when methods of this class are optimized by the runtime
 553      * compiler, some or all checks (if any) may be elided. Hence, the
 554      * caller must not rely on the checks and corresponding
 555      * exceptions!
 556      *
 557      * @return an exception object
 558      */
 559     private RuntimeException invalidInput() {
 560         return new IllegalArgumentException();
 561     }
 562 
 563     /**
 564      * Check if a value is 32-bit clean (32 MSB are all zero)
 565      *
 566      * @param value the 64-bit value to check
 567      *
 568      * @return true if the value is 32-bit clean
 569      */
 570     private boolean is32BitClean(long value) {
 571         return value &gt;&gt;&gt; 32 == 0;
 572     }
 573 
 574     /**
 575      * Check the validity of a size (the equivalent of a size_t)
 576      *
 577      * @throws RuntimeException if the size is invalid
 578      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 579      *         go undetected, which will lead to unpredictable
 580      *         behavior)
 581      */
 582     private void checkSize(long size) {
 583         if (ADDRESS_SIZE == 4) {
 584             // Note: this will also check for negative sizes
 585             if (!is32BitClean(size)) {
 586                 throw invalidInput();
 587             }
 588         } else if (size &lt; 0) {
 589             throw invalidInput();
 590         }
 591     }
 592 
 593     /**
 594      * Check the validity of a native address (the equivalent of void*)
 595      *
 596      * @throws RuntimeException if the address is invalid
 597      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 598      *         go undetected, which will lead to unpredictable
 599      *         behavior)
 600      */
 601     private void checkNativeAddress(long address) {
 602         if (ADDRESS_SIZE == 4) {
 603             // Accept both zero and sign extended pointers. A valid
 604             // pointer will, after the +1 below, either have produced
 605             // the value 0x0 or 0x1. Masking off the low bit allows
 606             // for testing against 0.
 607             if ((((address &gt;&gt; 32) + 1) &amp; ~1) != 0) {
 608                 throw invalidInput();
 609             }
 610         }
 611     }
 612 
 613     /**
 614      * Check the validity of an offset, relative to a base object
 615      *
 616      * @param o the base object
 617      * @param offset the offset to check
 618      *
 619      * @throws RuntimeException if the size is invalid
 620      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 621      *         go undetected, which will lead to unpredictable
 622      *         behavior)
 623      */
 624     private void checkOffset(Object o, long offset) {
 625         if (ADDRESS_SIZE == 4) {
 626             // Note: this will also check for negative offsets
 627             if (!is32BitClean(offset)) {
 628                 throw invalidInput();
 629             }
 630         } else if (offset &lt; 0) {
 631             throw invalidInput();
 632         }
 633     }
 634 
 635     /**
 636      * Check the validity of a double-register pointer
 637      *
 638      * Note: This code deliberately does *not* check for NPE for (at
 639      * least) three reasons:
 640      *
 641      * 1) NPE is not just NULL/0 - there is a range of values all
 642      * resulting in an NPE, which is not trivial to check for
 643      *
 644      * 2) It is the responsibility of the callers of Unsafe methods
 645      * to verify the input, so throwing an exception here is not really
 646      * useful - passing in a NULL pointer is a critical error and the
 647      * must not expect an exception to be thrown anyway.
 648      *
 649      * 3) the actual operations will detect NULL pointers anyway by
 650      * means of traps and signals (like SIGSEGV).
 651      *
 652      * @param o Java heap object, or null
 653      * @param offset indication of where the variable resides in a Java heap
 654      *        object, if any, else a memory address locating the variable
 655      *        statically
 656      *
 657      * @throws RuntimeException if the pointer is invalid
 658      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 659      *         go undetected, which will lead to unpredictable
 660      *         behavior)
 661      */
 662     private void checkPointer(Object o, long offset) {
 663         if (o == null) {
 664             checkNativeAddress(offset);
 665         } else {
 666             checkOffset(o, offset);
 667         }
 668     }
 669 
 670     /**
 671      * Check if a type is a primitive array type
 672      *
 673      * @param c the type to check
 674      *
 675      * @return true if the type is a primitive array type
 676      */
 677     private void checkPrimitiveArray(Class&lt;?&gt; c) {
 678         Class&lt;?&gt; componentType = c.getComponentType();
 679         if (componentType == null || !componentType.isPrimitive()) {
 680             throw invalidInput();
 681         }
 682     }
 683 
 684     /**
 685      * Check that a pointer is a valid primitive array type pointer
 686      *
 687      * Note: pointers off-heap are considered to be primitive arrays
 688      *
 689      * @throws RuntimeException if the pointer is invalid
 690      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 691      *         go undetected, which will lead to unpredictable
 692      *         behavior)
 693      */
 694     private void checkPrimitivePointer(Object o, long offset) {
 695         checkPointer(o, offset);
 696 
 697         if (o != null) {
 698             // If on heap, it must be a primitive array
 699             checkPrimitiveArray(o.getClass());
 700         }
 701     }
 702 
 703 
 704     /// wrappers for malloc, realloc, free:
 705 
 706     /**
 707      * Round up allocation size to a multiple of HeapWordSize.
 708      */
 709     private long alignToHeapWordSize(long bytes) {
 710         if (bytes &gt;= 0) {
 711             return (bytes + ADDRESS_SIZE - 1) &amp; ~(ADDRESS_SIZE - 1);
 712         } else {
 713             throw invalidInput();
 714         }
 715     }
 716 
 717     /**
 718      * Allocates a new block of native memory, of the given size in bytes.  The
 719      * contents of the memory are uninitialized; they will generally be
 720      * garbage.  The resulting native pointer will never be zero, and will be
 721      * aligned for all value types.  Dispose of this memory by calling {@link
 722      * #freeMemory}, or resize it with {@link #reallocateMemory}.
 723      *
 724      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
 725      * sure arguments are checked before the methods are called. While
 726      * some rudimentary checks are performed on the input, the checks
 727      * are best effort and when performance is an overriding priority,
 728      * as when methods of this class are optimized by the runtime
 729      * compiler, some or all checks (if any) may be elided. Hence, the
 730      * caller must not rely on the checks and corresponding
 731      * exceptions!
 732      *
 733      * @throws RuntimeException if the size is negative or too large
 734      *         for the native size_t type
 735      *
 736      * @throws OutOfMemoryError if the allocation is refused by the system
 737      *
 738      * @see #getByte(long)
 739      * @see #putByte(long, byte)
 740      */
 741     public long allocateMemory(long bytes) {
 742         bytes = alignToHeapWordSize(bytes);
 743 
 744         allocateMemoryChecks(bytes);
 745 
 746         if (bytes == 0) {
 747             return 0;
 748         }
 749 
 750         long p = allocateMemory0(bytes);
 751         if (p == 0) {
 752             throw new OutOfMemoryError();
 753         }
 754 
 755         return p;
 756     }
 757 
 758     /**
 759      * Validate the arguments to allocateMemory
 760      *
 761      * @throws RuntimeException if the arguments are invalid
 762      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 763      *         go undetected, which will lead to unpredictable
 764      *         behavior)
 765      */
 766     private void allocateMemoryChecks(long bytes) {
 767         checkSize(bytes);
 768     }
 769 
 770     /**
 771      * Resizes a new block of native memory, to the given size in bytes.  The
 772      * contents of the new block past the size of the old block are
 773      * uninitialized; they will generally be garbage.  The resulting native
 774      * pointer will be zero if and only if the requested size is zero.  The
 775      * resulting native pointer will be aligned for all value types.  Dispose
 776      * of this memory by calling {@link #freeMemory}, or resize it with {@link
 777      * #reallocateMemory}.  The address passed to this method may be null, in
 778      * which case an allocation will be performed.
 779      *
 780      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
 781      * sure arguments are checked before the methods are called. While
 782      * some rudimentary checks are performed on the input, the checks
 783      * are best effort and when performance is an overriding priority,
 784      * as when methods of this class are optimized by the runtime
 785      * compiler, some or all checks (if any) may be elided. Hence, the
 786      * caller must not rely on the checks and corresponding
 787      * exceptions!
 788      *
 789      * @throws RuntimeException if the size is negative or too large
 790      *         for the native size_t type
 791      *
 792      * @throws OutOfMemoryError if the allocation is refused by the system
 793      *
 794      * @see #allocateMemory
 795      */
 796     public long reallocateMemory(long address, long bytes) {
 797         bytes = alignToHeapWordSize(bytes);
 798 
 799         reallocateMemoryChecks(address, bytes);
 800 
 801         if (bytes == 0) {
 802             freeMemory(address);
 803             return 0;
 804         }
 805 
 806         long p = (address == 0) ? allocateMemory0(bytes) : reallocateMemory0(address, bytes);
 807         if (p == 0) {
 808             throw new OutOfMemoryError();
 809         }
 810 
 811         return p;
 812     }
 813 
 814     /**
 815      * Validate the arguments to reallocateMemory
 816      *
 817      * @throws RuntimeException if the arguments are invalid
 818      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 819      *         go undetected, which will lead to unpredictable
 820      *         behavior)
 821      */
 822     private void reallocateMemoryChecks(long address, long bytes) {
 823         checkPointer(null, address);
 824         checkSize(bytes);
 825     }
 826 
 827     /**
 828      * Sets all bytes in a given block of memory to a fixed value
 829      * (usually zero).
 830      *
 831      * &lt;p&gt;This method determines a block&#39;s base address by means of two parameters,
 832      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 833      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 834      * the offset supplies an absolute base address.
 835      *
 836      * &lt;p&gt;The stores are in coherent (atomic) units of a size determined
 837      * by the address and length parameters.  If the effective address and
 838      * length are all even modulo 8, the stores take place in &#39;long&#39; units.
 839      * If the effective address and length are (resp.) even modulo 4 or 2,
 840      * the stores take place in units of &#39;int&#39; or &#39;short&#39;.
 841      *
 842      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
 843      * sure arguments are checked before the methods are called. While
 844      * some rudimentary checks are performed on the input, the checks
 845      * are best effort and when performance is an overriding priority,
 846      * as when methods of this class are optimized by the runtime
 847      * compiler, some or all checks (if any) may be elided. Hence, the
 848      * caller must not rely on the checks and corresponding
 849      * exceptions!
 850      *
 851      * @throws RuntimeException if any of the arguments is invalid
 852      *
 853      * @since 1.7
 854      */
 855     public void setMemory(Object o, long offset, long bytes, byte value) {
 856         setMemoryChecks(o, offset, bytes, value);
 857 
 858         if (bytes == 0) {
 859             return;
 860         }
 861 
 862         setMemory0(o, offset, bytes, value);
 863     }
 864 
 865     /**
 866      * Sets all bytes in a given block of memory to a fixed value
 867      * (usually zero).  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
 868      * as discussed in {@link #getInt(Object,long)}.
 869      *
 870      * &lt;p&gt;Equivalent to {@code setMemory(null, address, bytes, value)}.
 871      */
 872     public void setMemory(long address, long bytes, byte value) {
 873         setMemory(null, address, bytes, value);
 874     }
 875 
 876     /**
 877      * Validate the arguments to setMemory
 878      *
 879      * @throws RuntimeException if the arguments are invalid
 880      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 881      *         go undetected, which will lead to unpredictable
 882      *         behavior)
 883      */
 884     private void setMemoryChecks(Object o, long offset, long bytes, byte value) {
 885         checkPrimitivePointer(o, offset);
 886         checkSize(bytes);
 887     }
 888 
 889     /**
 890      * Sets all bytes in a given block of memory to a copy of another
 891      * block.
 892      *
 893      * &lt;p&gt;This method determines each block&#39;s base address by means of two parameters,
 894      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 895      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 896      * the offset supplies an absolute base address.
 897      *
 898      * &lt;p&gt;The transfers are in coherent (atomic) units of a size determined
 899      * by the address and length parameters.  If the effective addresses and
 900      * length are all even modulo 8, the transfer takes place in &#39;long&#39; units.
 901      * If the effective addresses and length are (resp.) even modulo 4 or 2,
 902      * the transfer takes place in units of &#39;int&#39; or &#39;short&#39;.
 903      *
 904      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
 905      * sure arguments are checked before the methods are called. While
 906      * some rudimentary checks are performed on the input, the checks
 907      * are best effort and when performance is an overriding priority,
 908      * as when methods of this class are optimized by the runtime
 909      * compiler, some or all checks (if any) may be elided. Hence, the
 910      * caller must not rely on the checks and corresponding
 911      * exceptions!
 912      *
 913      * @throws RuntimeException if any of the arguments is invalid
 914      *
 915      * @since 1.7
 916      */
 917     public void copyMemory(Object srcBase, long srcOffset,
 918                            Object destBase, long destOffset,
 919                            long bytes) {
 920         copyMemoryChecks(srcBase, srcOffset, destBase, destOffset, bytes);
 921 
 922         if (bytes == 0) {
 923             return;
 924         }
 925 
 926         copyMemory0(srcBase, srcOffset, destBase, destOffset, bytes);
 927     }
 928 
 929     /**
 930      * Sets all bytes in a given block of memory to a copy of another
 931      * block.  This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode,
 932      * as discussed in {@link #getInt(Object,long)}.
 933      *
 934      * Equivalent to {@code copyMemory(null, srcAddress, null, destAddress, bytes)}.
 935      */
 936     public void copyMemory(long srcAddress, long destAddress, long bytes) {
 937         copyMemory(null, srcAddress, null, destAddress, bytes);
 938     }
 939 
 940     /**
 941      * Validate the arguments to copyMemory
 942      *
 943      * @throws RuntimeException if any of the arguments is invalid
 944      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
 945      *         go undetected, which will lead to unpredictable
 946      *         behavior)
 947      */
 948     private void copyMemoryChecks(Object srcBase, long srcOffset,
 949                                   Object destBase, long destOffset,
 950                                   long bytes) {
 951         checkSize(bytes);
 952         checkPrimitivePointer(srcBase, srcOffset);
 953         checkPrimitivePointer(destBase, destOffset);
 954     }
 955 
 956     /**
 957      * Copies all elements from one block of memory to another block,
 958      * *unconditionally* byte swapping the elements on the fly.
 959      *
 960      * &lt;p&gt;This method determines each block&#39;s base address by means of two parameters,
 961      * and so it provides (in effect) a &lt;em&gt;double-register&lt;/em&gt; addressing mode,
 962      * as discussed in {@link #getInt(Object,long)}.  When the object reference is null,
 963      * the offset supplies an absolute base address.
 964      *
 965      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
 966      * sure arguments are checked before the methods are called. While
 967      * some rudimentary checks are performed on the input, the checks
 968      * are best effort and when performance is an overriding priority,
 969      * as when methods of this class are optimized by the runtime
 970      * compiler, some or all checks (if any) may be elided. Hence, the
 971      * caller must not rely on the checks and corresponding
 972      * exceptions!
 973      *
 974      * @throws RuntimeException if any of the arguments is invalid
 975      *
 976      * @since 9
 977      */
 978     public void copySwapMemory(Object srcBase, long srcOffset,
 979                                Object destBase, long destOffset,
 980                                long bytes, long elemSize) {
 981         copySwapMemoryChecks(srcBase, srcOffset, destBase, destOffset, bytes, elemSize);
 982 
 983         if (bytes == 0) {
 984             return;
 985         }
 986 
 987         copySwapMemory0(srcBase, srcOffset, destBase, destOffset, bytes, elemSize);
 988     }
 989 
 990     private void copySwapMemoryChecks(Object srcBase, long srcOffset,
 991                                       Object destBase, long destOffset,
 992                                       long bytes, long elemSize) {
 993         checkSize(bytes);
 994 
 995         if (elemSize != 2 &amp;&amp; elemSize != 4 &amp;&amp; elemSize != 8) {
 996             throw invalidInput();
 997         }
 998         if (bytes % elemSize != 0) {
 999             throw invalidInput();
1000         }
1001 
1002         checkPrimitivePointer(srcBase, srcOffset);
1003         checkPrimitivePointer(destBase, destOffset);
1004     }
1005 
1006    /**
1007      * Copies all elements from one block of memory to another block, byte swapping the
1008      * elements on the fly.
1009      *
1010      * This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode, as
1011      * discussed in {@link #getInt(Object,long)}.
1012      *
1013      * Equivalent to {@code copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize)}.
1014      */
1015     public void copySwapMemory(long srcAddress, long destAddress, long bytes, long elemSize) {
1016         copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize);
1017     }
1018 
1019     /**
1020      * Disposes of a block of native memory, as obtained from {@link
1021      * #allocateMemory} or {@link #reallocateMemory}.  The address passed to
1022      * this method may be null, in which case no action is taken.
1023      *
1024      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
1025      * sure arguments are checked before the methods are called. While
1026      * some rudimentary checks are performed on the input, the checks
1027      * are best effort and when performance is an overriding priority,
1028      * as when methods of this class are optimized by the runtime
1029      * compiler, some or all checks (if any) may be elided. Hence, the
1030      * caller must not rely on the checks and corresponding
1031      * exceptions!
1032      *
1033      * @throws RuntimeException if any of the arguments is invalid
1034      *
1035      * @see #allocateMemory
1036      */
1037     public void freeMemory(long address) {
1038         freeMemoryChecks(address);
1039 
1040         if (address == 0) {
1041             return;
1042         }
1043 
1044         freeMemory0(address);
1045     }
1046 
1047     /**
1048      * Validate the arguments to freeMemory
1049      *
1050      * @throws RuntimeException if the arguments are invalid
1051      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
1052      *         go undetected, which will lead to unpredictable
1053      *         behavior)
1054      */
1055     private void freeMemoryChecks(long address) {
1056         checkPointer(null, address);
1057     }
1058 
1059     /**
1060      * Ensure writeback of a specified virtual memory address range
1061      * from cache to physical memory. All bytes in the address range
1062      * are guaranteed to have been written back to physical memory on
1063      * return from this call i.e. subsequently executed store
1064      * instructions are guaranteed not to be visible before the
1065      * writeback is completed.
1066      *
1067      * @param address
1068      *        the lowest byte address that must be guaranteed written
1069      *        back to memory. bytes at lower addresses may also be
1070      *        written back.
1071      *
1072      * @param length
1073      *        the length in bytes of the region starting at address
1074      *        that must be guaranteed written back to memory.
1075      *
1076      * @throws RuntimeException if memory writeback is not supported
1077      *         on the current hardware of if the arguments are invalid.
1078      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
1079      *         go undetected, which will lead to unpredictable
1080      *         behavior)
1081      *
1082      * @since 14
1083      */
1084 
1085     public void writebackMemory(long address, long length) {
1086         checkWritebackEnabled();
1087         checkWritebackMemory(address, length);
1088 
1089         // perform any required pre-writeback barrier
1090         writebackPreSync0();
1091 
1092         // write back one cache line at a time
1093         long line = dataCacheLineAlignDown(address);
1094         long end = address + length;
1095         while (line &lt; end) {
1096             writeback0(line);
1097             line += dataCacheLineFlushSize();
1098         }
1099 
1100         // perform any required post-writeback barrier
1101         writebackPostSync0();
1102     }
1103 
1104     /**
1105      * Validate the arguments to writebackMemory
1106      *
1107      * @throws RuntimeException if the arguments are invalid
1108      *         (&lt;em&gt;Note:&lt;/em&gt; after optimization, invalid inputs may
1109      *         go undetected, which will lead to unpredictable
1110      *         behavior)
1111      */
1112     private void checkWritebackMemory(long address, long length) {
1113         checkNativeAddress(address);
1114         checkSize(length);
1115     }
1116 
1117     /**
1118      * Validate that the current hardware supports memory writeback.
1119      * (&lt;em&gt;Note:&lt;/em&gt; this is a belt and braces check.  Clients are
1120      * expected to test whether writeback is enabled by calling
1121      * ({@link isWritebackEnabled #isWritebackEnabled} and avoid
1122      * calling method {@link writeback #writeback} if it is disabled).
1123      *
1124      *
1125      * @throws RuntimeException if memory writeback is not supported
1126      */
1127     private void checkWritebackEnabled() {
1128         if (!isWritebackEnabled()) {
1129             throw new RuntimeException(&quot;writebackMemory not enabled!&quot;);
1130         }
1131     }
1132 
1133     /**
1134      * force writeback of an individual cache line.
1135      *
1136      * @param address
1137      *        the start address of the cache line to be written back
1138      */
1139     @HotSpotIntrinsicCandidate
1140     private native void writeback0(long address);
1141 
1142      /**
1143       * Serialize writeback operations relative to preceding memory writes.
1144       */
1145     @HotSpotIntrinsicCandidate
1146     private native void writebackPreSync0();
1147 
1148      /**
1149       * Serialize writeback operations relative to following memory writes.
1150       */
1151     @HotSpotIntrinsicCandidate
1152     private native void writebackPostSync0();
1153 
1154     /// random queries
1155 
1156     /**
1157      * This constant differs from all results that will ever be returned from
1158      * {@link #staticFieldOffset}, {@link #objectFieldOffset},
1159      * or {@link #arrayBaseOffset}.
1160      */
1161     public static final int INVALID_FIELD_OFFSET = -1;
1162 
1163     /**
1164      * Reports the location of a given field in the storage allocation of its
1165      * class.  Do not expect to perform any sort of arithmetic on this offset;
1166      * it is just a cookie which is passed to the unsafe heap memory accessors.
1167      *
1168      * &lt;p&gt;Any given field will always have the same offset and base, and no
1169      * two distinct fields of the same class will ever have the same offset
1170      * and base.
1171      *
1172      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
1173      * although the Sun JVM does not use the most significant 32 bits.
1174      * However, JVM implementations which store static fields at absolute
1175      * addresses can use long offsets and null base pointers to express
1176      * the field locations in a form usable by {@link #getInt(Object,long)}.
1177      * Therefore, code which will be ported to such JVMs on 64-bit platforms
1178      * must preserve all bits of static field offsets.
1179      * @see #getInt(Object, long)
1180      */
1181     public long objectFieldOffset(Field f) {
1182         if (f == null) {
1183             throw new NullPointerException();
1184         }
1185 
1186         return objectFieldOffset0(f);
1187     }
1188 
1189     /**
1190      * Reports the location of the field with a given name in the storage
1191      * allocation of its class.
1192      *
1193      * @throws NullPointerException if any parameter is {@code null}.
1194      * @throws InternalError if there is no field named {@code name} declared
1195      *         in class {@code c}, i.e., if {@code c.getDeclaredField(name)}
1196      *         would throw {@code java.lang.NoSuchFieldException}.
1197      *
1198      * @see #objectFieldOffset(Field)
1199      */
1200     public long objectFieldOffset(Class&lt;?&gt; c, String name) {
1201         if (c == null || name == null) {
1202             throw new NullPointerException();
1203         }
1204 
1205         return objectFieldOffset1(c, name);
1206     }
1207 
1208     /**
1209      * Reports the location of a given static field, in conjunction with {@link
1210      * #staticFieldBase}.
1211      * &lt;p&gt;Do not expect to perform any sort of arithmetic on this offset;
1212      * it is just a cookie which is passed to the unsafe heap memory accessors.
1213      *
1214      * &lt;p&gt;Any given field will always have the same offset, and no two distinct
1215      * fields of the same class will ever have the same offset.
1216      *
1217      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
1218      * although the Sun JVM does not use the most significant 32 bits.
1219      * It is hard to imagine a JVM technology which needs more than
1220      * a few bits to encode an offset within a non-array object,
1221      * However, for consistency with other methods in this class,
1222      * this method reports its result as a long value.
1223      * @see #getInt(Object, long)
1224      */
1225     public long staticFieldOffset(Field f) {
1226         if (f == null) {
1227             throw new NullPointerException();
1228         }
1229 
1230         return staticFieldOffset0(f);
1231     }
1232 
1233     /**
1234      * Reports the location of a given static field, in conjunction with {@link
1235      * #staticFieldOffset}.
1236      * &lt;p&gt;Fetch the base &quot;Object&quot;, if any, with which static fields of the
1237      * given class can be accessed via methods like {@link #getInt(Object,
1238      * long)}.  This value may be null.  This value may refer to an object
1239      * which is a &quot;cookie&quot;, not guaranteed to be a real Object, and it should
1240      * not be used in any way except as argument to the get and put routines in
1241      * this class.
1242      */
1243     public Object staticFieldBase(Field f) {
1244         if (f == null) {
1245             throw new NullPointerException();
1246         }
1247 
1248         return staticFieldBase0(f);
1249     }
1250 
1251     /**
1252      * Detects if the given class may need to be initialized. This is often
1253      * needed in conjunction with obtaining the static field base of a
1254      * class.
1255      * @return false only if a call to {@code ensureClassInitialized} would have no effect
1256      */
1257     public boolean shouldBeInitialized(Class&lt;?&gt; c) {
1258         if (c == null) {
1259             throw new NullPointerException();
1260         }
1261 
1262         return shouldBeInitialized0(c);
1263     }
1264 
1265     /**
1266      * Ensures the given class has been initialized. This is often
1267      * needed in conjunction with obtaining the static field base of a
1268      * class.
1269      */
1270     public void ensureClassInitialized(Class&lt;?&gt; c) {
1271         if (c == null) {
1272             throw new NullPointerException();
1273         }
1274 
1275         ensureClassInitialized0(c);
1276     }
1277 
1278     /**
1279      * Reports the offset of the first element in the storage allocation of a
1280      * given array class.  If {@link #arrayIndexScale} returns a non-zero value
1281      * for the same class, you may use that scale factor, together with this
1282      * base offset, to form new offsets to access elements of arrays of the
1283      * given class.
1284      *
1285      * @see #getInt(Object, long)
1286      * @see #putInt(Object, long, int)
1287      */
1288     public int arrayBaseOffset(Class&lt;?&gt; arrayClass) {
1289         if (arrayClass == null) {
1290             throw new NullPointerException();
1291         }
1292 
1293         return arrayBaseOffset0(arrayClass);
1294     }
1295 
1296 
1297     /** The value of {@code arrayBaseOffset(boolean[].class)} */
1298     public static final int ARRAY_BOOLEAN_BASE_OFFSET
1299             = theUnsafe.arrayBaseOffset(boolean[].class);
1300 
1301     /** The value of {@code arrayBaseOffset(byte[].class)} */
1302     public static final int ARRAY_BYTE_BASE_OFFSET
1303             = theUnsafe.arrayBaseOffset(byte[].class);
1304 
1305     /** The value of {@code arrayBaseOffset(short[].class)} */
1306     public static final int ARRAY_SHORT_BASE_OFFSET
1307             = theUnsafe.arrayBaseOffset(short[].class);
1308 
1309     /** The value of {@code arrayBaseOffset(char[].class)} */
1310     public static final int ARRAY_CHAR_BASE_OFFSET
1311             = theUnsafe.arrayBaseOffset(char[].class);
1312 
1313     /** The value of {@code arrayBaseOffset(int[].class)} */
1314     public static final int ARRAY_INT_BASE_OFFSET
1315             = theUnsafe.arrayBaseOffset(int[].class);
1316 
1317     /** The value of {@code arrayBaseOffset(long[].class)} */
1318     public static final int ARRAY_LONG_BASE_OFFSET
1319             = theUnsafe.arrayBaseOffset(long[].class);
1320 
1321     /** The value of {@code arrayBaseOffset(float[].class)} */
1322     public static final int ARRAY_FLOAT_BASE_OFFSET
1323             = theUnsafe.arrayBaseOffset(float[].class);
1324 
1325     /** The value of {@code arrayBaseOffset(double[].class)} */
1326     public static final int ARRAY_DOUBLE_BASE_OFFSET
1327             = theUnsafe.arrayBaseOffset(double[].class);
1328 
1329     /** The value of {@code arrayBaseOffset(Object[].class)} */
1330     public static final int ARRAY_OBJECT_BASE_OFFSET
1331             = theUnsafe.arrayBaseOffset(Object[].class);
1332 
1333     /**
1334      * Reports the scale factor for addressing elements in the storage
1335      * allocation of a given array class.  However, arrays of &quot;narrow&quot; types
1336      * will generally not work properly with accessors like {@link
1337      * #getByte(Object, long)}, so the scale factor for such classes is reported
1338      * as zero.
1339      *
1340      * @see #arrayBaseOffset
1341      * @see #getInt(Object, long)
1342      * @see #putInt(Object, long, int)
1343      */
1344     public int arrayIndexScale(Class&lt;?&gt; arrayClass) {
1345         if (arrayClass == null) {
1346             throw new NullPointerException();
1347         }
1348 
1349         return arrayIndexScale0(arrayClass);
1350     }
1351 
1352     /**
1353      * Return the size of the object in the heap.
1354      * @param o an object
1355      * @return the objects&#39;s size
1356      * @since Valhalla
1357      */
1358     public long getObjectSize(Object o) {
1359         if (o == null)
1360             throw new NullPointerException();
1361         return getObjectSize0(o);
1362     }
1363 
1364     /** The value of {@code arrayIndexScale(boolean[].class)} */
1365     public static final int ARRAY_BOOLEAN_INDEX_SCALE
1366             = theUnsafe.arrayIndexScale(boolean[].class);
1367 
1368     /** The value of {@code arrayIndexScale(byte[].class)} */
1369     public static final int ARRAY_BYTE_INDEX_SCALE
1370             = theUnsafe.arrayIndexScale(byte[].class);
1371 
1372     /** The value of {@code arrayIndexScale(short[].class)} */
1373     public static final int ARRAY_SHORT_INDEX_SCALE
1374             = theUnsafe.arrayIndexScale(short[].class);
1375 
1376     /** The value of {@code arrayIndexScale(char[].class)} */
1377     public static final int ARRAY_CHAR_INDEX_SCALE
1378             = theUnsafe.arrayIndexScale(char[].class);
1379 
1380     /** The value of {@code arrayIndexScale(int[].class)} */
1381     public static final int ARRAY_INT_INDEX_SCALE
1382             = theUnsafe.arrayIndexScale(int[].class);
1383 
1384     /** The value of {@code arrayIndexScale(long[].class)} */
1385     public static final int ARRAY_LONG_INDEX_SCALE
1386             = theUnsafe.arrayIndexScale(long[].class);
1387 
1388     /** The value of {@code arrayIndexScale(float[].class)} */
1389     public static final int ARRAY_FLOAT_INDEX_SCALE
1390             = theUnsafe.arrayIndexScale(float[].class);
1391 
1392     /** The value of {@code arrayIndexScale(double[].class)} */
1393     public static final int ARRAY_DOUBLE_INDEX_SCALE
1394             = theUnsafe.arrayIndexScale(double[].class);
1395 
1396     /** The value of {@code arrayIndexScale(Object[].class)} */
1397     public static final int ARRAY_OBJECT_INDEX_SCALE
1398             = theUnsafe.arrayIndexScale(Object[].class);
1399 
1400     /**
1401      * Reports the size in bytes of a native pointer, as stored via {@link
1402      * #putAddress}.  This value will be either 4 or 8.  Note that the sizes of
1403      * other primitive types (as stored in native memory blocks) is determined
1404      * fully by their information content.
1405      */
1406     public int addressSize() {
1407         return ADDRESS_SIZE;
1408     }
1409 
1410     /** The value of {@code addressSize()} */
1411     public static final int ADDRESS_SIZE = ADDRESS_SIZE0;
1412 
1413     /**
1414      * Reports the size in bytes of a native memory page (whatever that is).
1415      * This value will always be a power of two.
1416      */
1417     public int pageSize() { return PAGE_SIZE; }
1418 
1419     /**
1420      * Reports the size in bytes of a data cache line written back by
1421      * the hardware cache line flush operation available to the JVM or
1422      * 0 if data cache line flushing is not enabled.
1423      */
1424     public int dataCacheLineFlushSize() { return DATA_CACHE_LINE_FLUSH_SIZE; }
1425 
1426     /**
1427      * Rounds down address to a data cache line boundary as
1428      * determined by {@link #dataCacheLineFlushSize}
1429      * @return the rounded down address
1430      */
1431     public long dataCacheLineAlignDown(long address) {
1432         return (address &amp; ~(DATA_CACHE_LINE_FLUSH_SIZE - 1));
1433     }
1434 
1435     /**
1436      * Returns true if data cache line writeback
1437      */
1438     public static boolean isWritebackEnabled() { return DATA_CACHE_LINE_FLUSH_SIZE != 0; }
1439 
1440     /// random trusted operations from JNI:
1441 
1442     /**
1443      * Tells the VM to define a class, without security checks.  By default, the
1444      * class loader and protection domain come from the caller&#39;s class.
1445      */
1446     public Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len,
1447                                 ClassLoader loader,
1448                                 ProtectionDomain protectionDomain) {
1449         if (b == null) {
1450             throw new NullPointerException();
1451         }
1452         if (len &lt; 0) {
1453             throw new ArrayIndexOutOfBoundsException();
1454         }
1455 
1456         return defineClass0(name, b, off, len, loader, protectionDomain);
1457     }
1458 
1459     public native Class&lt;?&gt; defineClass0(String name, byte[] b, int off, int len,
1460                                         ClassLoader loader,
1461                                         ProtectionDomain protectionDomain);
1462 
1463     /**
1464      * Defines a class but does not make it known to the class loader or system dictionary.
1465      * &lt;p&gt;
1466      * For each CP entry, the corresponding CP patch must either be null or have
1467      * the a format that matches its tag:
1468      * &lt;ul&gt;
1469      * &lt;li&gt;Integer, Long, Float, Double: the corresponding wrapper object type from java.lang
1470      * &lt;li&gt;Utf8: a string (must have suitable syntax if used as signature or name)
1471      * &lt;li&gt;Class: any java.lang.Class object
1472      * &lt;li&gt;String: any object (not just a java.lang.String)
1473      * &lt;li&gt;InterfaceMethodRef: (NYI) a method handle to invoke on that call site&#39;s arguments
1474      * &lt;/ul&gt;
1475      * @param hostClass context for linkage, access control, protection domain, and class loader
1476      * @param data      bytes of a class file
1477      * @param cpPatches where non-null entries exist, they replace corresponding CP entries in data
1478      */
1479     public Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches) {
1480         if (hostClass == null || data == null) {
1481             throw new NullPointerException();
1482         }
1483         if (hostClass.isArray() || hostClass.isPrimitive()) {
1484             throw new IllegalArgumentException();
1485         }
1486 
1487         return defineAnonymousClass0(hostClass, data, cpPatches);
1488     }
1489 
1490     /**
1491      * Allocates an instance but does not run any constructor.
1492      * Initializes the class if it has not yet been.
1493      */
1494     @HotSpotIntrinsicCandidate
1495     public native Object allocateInstance(Class&lt;?&gt; cls)
1496         throws InstantiationException;
1497 
1498     /**
1499      * Allocates an array of a given type, but does not do zeroing.
1500      * &lt;p&gt;
1501      * This method should only be used in the very rare cases where a high-performance code
1502      * overwrites the destination array completely, and compilers cannot assist in zeroing elimination.
1503      * In an overwhelming majority of cases, a normal Java allocation should be used instead.
1504      * &lt;p&gt;
1505      * Users of this method are &lt;b&gt;required&lt;/b&gt; to overwrite the initial (garbage) array contents
1506      * before allowing untrusted code, or code in other threads, to observe the reference
1507      * to the newly allocated array. In addition, the publication of the array reference must be
1508      * safe according to the Java Memory Model requirements.
1509      * &lt;p&gt;
1510      * The safest approach to deal with an uninitialized array is to keep the reference to it in local
1511      * variable at least until the initialization is complete, and then publish it &lt;b&gt;once&lt;/b&gt;, either
1512      * by writing it to a &lt;em&gt;volatile&lt;/em&gt; field, or storing it into a &lt;em&gt;final&lt;/em&gt; field in constructor,
1513      * or issuing a {@link #storeFence} before publishing the reference.
1514      * &lt;p&gt;
1515      * @implnote This method can only allocate primitive arrays, to avoid garbage reference
1516      * elements that could break heap integrity.
1517      *
1518      * @param componentType array component type to allocate
1519      * @param length array size to allocate
1520      * @throws IllegalArgumentException if component type is null, or not a primitive class;
1521      *                                  or the length is negative
1522      */
1523     public Object allocateUninitializedArray(Class&lt;?&gt; componentType, int length) {
1524        if (componentType == null) {
1525            throw new IllegalArgumentException(&quot;Component type is null&quot;);
1526        }
1527        if (!componentType.isPrimitive()) {
1528            throw new IllegalArgumentException(&quot;Component type is not primitive&quot;);
1529        }
1530        if (length &lt; 0) {
1531            throw new IllegalArgumentException(&quot;Negative length&quot;);
1532        }
1533        return allocateUninitializedArray0(componentType, length);
1534     }
1535 
1536     @HotSpotIntrinsicCandidate
1537     private Object allocateUninitializedArray0(Class&lt;?&gt; componentType, int length) {
1538        // These fallbacks provide zeroed arrays, but intrinsic is not required to
1539        // return the zeroed arrays.
1540        if (componentType == byte.class)    return new byte[length];
1541        if (componentType == boolean.class) return new boolean[length];
1542        if (componentType == short.class)   return new short[length];
1543        if (componentType == char.class)    return new char[length];
1544        if (componentType == int.class)     return new int[length];
1545        if (componentType == float.class)   return new float[length];
1546        if (componentType == long.class)    return new long[length];
1547        if (componentType == double.class)  return new double[length];
1548        return null;
1549     }
1550 
1551     /** Throws the exception without telling the verifier. */
1552     public native void throwException(Throwable ee);
1553 
1554     /**
1555      * Atomically updates Java variable to {@code x} if it is currently
1556      * holding {@code expected}.
1557      *
1558      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1559      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1560      *
1561      * @return {@code true} if successful
1562      */
1563     @HotSpotIntrinsicCandidate
1564     public final native boolean compareAndSetReference(Object o, long offset,
1565                                                        Object expected,
1566                                                        Object x);
1567 
1568     private final boolean isInlineType(Object o) {
1569         return o != null &amp;&amp; o.getClass().isInlineClass();
1570     }
1571 
1572     /*
1573      * For inline type, CAS should do substitutability test as opposed
1574      * to two pointers comparison.
1575      *
1576      * Perhaps we can keep the xxxObject methods for compatibility and
1577      * change the JDK 13 xxxReference method signature freely.
1578      */
1579     public final &lt;V&gt; boolean compareAndSetReference(Object o, long offset,
1580                                                     Class&lt;?&gt; valueType,
1581                                                     V expected,
1582                                                     V x) {
1583         if (valueType.isInlineClass() || isInlineType(expected)) {
1584             synchronized (valueLock) {
1585                 Object witness = getReference(o, offset);
1586                 if (witness == expected) {
1587                     putReference(o, offset, x);
1588                     return true;
1589                 } else {
1590                     return false;
1591                 }
1592             }
1593         } else {
1594             return compareAndSetReference(o, offset, expected, x);
1595         }
1596     }
1597 
1598     @ForceInline
1599     public final &lt;V&gt; boolean compareAndSetValue(Object o, long offset,
1600                                                 Class&lt;?&gt; valueType,
1601                                                 V expected,
1602                                                 V x) {
1603         synchronized (valueLock) {
1604             Object witness = getValue(o, offset, valueType);
1605             if (witness == expected) {
1606                 putValue(o, offset, valueType, x);
1607                 return true;
1608             }
1609             else {
1610                 return false;
1611             }
1612         }
1613     }
1614 
1615     @HotSpotIntrinsicCandidate
1616     public final native Object compareAndExchangeReference(Object o, long offset,
1617                                                            Object expected,
1618                                                            Object x);
1619 
1620     public final &lt;V&gt; Object compareAndExchangeReference(Object o, long offset,
1621                                                         Class&lt;?&gt; valueType,
1622                                                         V expected,
1623                                                         V x) {
1624         if (valueType.isInlineClass() || isInlineType(expected)) {
1625             synchronized (valueLock) {
1626                 Object witness = getReference(o, offset);
1627                 if (witness == expected) {
1628                     putReference(o, offset, x);
1629                 }
1630                 return witness;
1631             }
1632         } else {
1633             return compareAndExchangeReference(o, offset, expected, x);
1634         }
1635     }
1636 
1637     @ForceInline
1638     public final &lt;V&gt; Object compareAndExchangeValue(Object o, long offset,
1639                                                     Class&lt;?&gt; valueType,
1640                                                     V expected,
1641                                                     V x) {
1642         synchronized (valueLock) {
1643             Object witness = getValue(o, offset, valueType);
1644             if (witness == expected) {
1645                 putValue(o, offset, valueType, x);
1646             }
1647             return witness;
1648         }
1649     }
1650 
1651     @HotSpotIntrinsicCandidate
1652     public final Object compareAndExchangeReferenceAcquire(Object o, long offset,
1653                                                            Object expected,
1654                                                            Object x) {
1655         return compareAndExchangeReference(o, offset, expected, x);
1656     }
1657 
1658     public final &lt;V&gt; Object compareAndExchangeReferenceAcquire(Object o, long offset,
1659                                                                Class&lt;?&gt; valueType,
1660                                                                V expected,
1661                                                                V x) {
1662         return compareAndExchangeReference(o, offset, valueType, expected, x);
1663     }
1664 
1665     @ForceInline
1666     public final &lt;V&gt; Object compareAndExchangeValueAcquire(Object o, long offset,
1667                                                            Class&lt;?&gt; valueType,
1668                                                            V expected,
1669                                                            V x) {
1670         return compareAndExchangeValue(o, offset, valueType, expected, x);
1671     }
1672 
1673     @HotSpotIntrinsicCandidate
1674     public final Object compareAndExchangeReferenceRelease(Object o, long offset,
1675                                                            Object expected,
1676                                                            Object x) {
1677         return compareAndExchangeReference(o, offset, expected, x);
1678     }
1679 
1680     public final &lt;V&gt; Object compareAndExchangeReferenceRelease(Object o, long offset,
1681                                                                Class&lt;?&gt; valueType,
1682                                                                V expected,
1683                                                                V x) {
1684         return compareAndExchangeReference(o, offset, valueType, expected, x);
1685     }
1686 
1687     @ForceInline
1688     public final &lt;V&gt; Object compareAndExchangeValueRelease(Object o, long offset,
1689                                                            Class&lt;?&gt; valueType,
1690                                                            V expected,
1691                                                            V x) {
1692         return compareAndExchangeValue(o, offset, valueType, expected, x);
1693     }
1694 
1695     @HotSpotIntrinsicCandidate
1696     public final boolean weakCompareAndSetReferencePlain(Object o, long offset,
1697                                                          Object expected,
1698                                                          Object x) {
1699         return compareAndSetReference(o, offset, expected, x);
1700     }
1701 
1702     public final &lt;V&gt; boolean weakCompareAndSetReferencePlain(Object o, long offset,
1703                                                              Class&lt;?&gt; valueType,
1704                                                              V expected,
1705                                                              V x) {
1706         if (valueType.isInlineClass() || isInlineType(expected)) {
1707             return compareAndSetReference(o, offset, valueType, expected, x);
1708         } else {
1709             return weakCompareAndSetReferencePlain(o, offset, expected, x);
1710         }
1711     }
1712 
1713     @ForceInline
1714     public final &lt;V&gt; boolean weakCompareAndSetValuePlain(Object o, long offset,
1715                                                          Class&lt;?&gt; valueType,
1716                                                          V expected,
1717                                                          V x) {
1718         return compareAndSetValue(o, offset, valueType, expected, x);
1719     }
1720 
1721     @HotSpotIntrinsicCandidate
1722     public final boolean weakCompareAndSetReferenceAcquire(Object o, long offset,
1723                                                            Object expected,
1724                                                            Object x) {
1725         return compareAndSetReference(o, offset, expected, x);
1726     }
1727 
1728     public final &lt;V&gt; boolean weakCompareAndSetReferenceAcquire(Object o, long offset,
1729                                                                Class&lt;?&gt; valueType,
1730                                                                V expected,
1731                                                                V x) {
1732         if (valueType.isInlineClass() || isInlineType(expected)) {
1733             return compareAndSetReference(o, offset, valueType, expected, x);
1734         } else {
1735             return weakCompareAndSetReferencePlain(o, offset, expected, x);
1736         }
1737     }
1738 
1739     @ForceInline
1740     public final &lt;V&gt; boolean weakCompareAndSetValueAcquire(Object o, long offset,
1741                                                            Class&lt;?&gt; valueType,
1742                                                            V expected,
1743                                                            V x) {
1744         return compareAndSetValue(o, offset, valueType, expected, x);
1745     }
1746 
1747     @HotSpotIntrinsicCandidate
1748     public final boolean weakCompareAndSetReferenceRelease(Object o, long offset,
1749                                                            Object expected,
1750                                                            Object x) {
1751         return compareAndSetReference(o, offset, expected, x);
1752     }
1753 
1754     public final &lt;V&gt; boolean weakCompareAndSetReferenceRelease(Object o, long offset,
1755                                                                Class&lt;?&gt; valueType,
1756                                                                V expected,
1757                                                                V x) {
1758         if (valueType.isInlineClass() || isInlineType(expected)) {
1759             return compareAndSetReference(o, offset, valueType, expected, x);
1760         } else {
1761             return weakCompareAndSetReferencePlain(o, offset, expected, x);
1762         }
1763     }
1764 
1765     @ForceInline
1766     public final &lt;V&gt; boolean weakCompareAndSetValueRelease(Object o, long offset,
1767                                                            Class&lt;?&gt; valueType,
1768                                                            V expected,
1769                                                            V x) {
1770         return compareAndSetValue(o, offset, valueType, expected, x);
1771     }
1772 
1773     @HotSpotIntrinsicCandidate
1774     public final boolean weakCompareAndSetReference(Object o, long offset,
1775                                                     Object expected,
1776                                                     Object x) {
1777         return compareAndSetReference(o, offset, expected, x);
1778     }
1779 
1780     public final &lt;V&gt; boolean weakCompareAndSetReference(Object o, long offset,
1781                                                         Class&lt;?&gt; valueType,
1782                                                         V expected,
1783                                                         V x) {
1784         if (valueType.isInlineClass() || isInlineType(expected)) {
1785             return compareAndSetReference(o, offset, valueType, expected, x);
1786         } else {
1787             return weakCompareAndSetReferencePlain(o, offset, expected, x);
1788         }
1789     }
1790 
1791     @ForceInline
1792     public final &lt;V&gt; boolean weakCompareAndSetValue(Object o, long offset,
1793                                                     Class&lt;?&gt; valueType,
1794                                                     V expected,
1795                                                     V x) {
1796         return compareAndSetValue(o, offset, valueType, expected, x);
1797     }
1798 
1799     /**
1800      * Atomically updates Java variable to {@code x} if it is currently
1801      * holding {@code expected}.
1802      *
1803      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
1804      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
1805      *
1806      * @return {@code true} if successful
1807      */
1808     @HotSpotIntrinsicCandidate
1809     public final native boolean compareAndSetInt(Object o, long offset,
1810                                                  int expected,
1811                                                  int x);
1812 
1813     @HotSpotIntrinsicCandidate
1814     public final native int compareAndExchangeInt(Object o, long offset,
1815                                                   int expected,
1816                                                   int x);
1817 
1818     @HotSpotIntrinsicCandidate
1819     public final int compareAndExchangeIntAcquire(Object o, long offset,
1820                                                          int expected,
1821                                                          int x) {
1822         return compareAndExchangeInt(o, offset, expected, x);
1823     }
1824 
1825     @HotSpotIntrinsicCandidate
1826     public final int compareAndExchangeIntRelease(Object o, long offset,
1827                                                          int expected,
1828                                                          int x) {
1829         return compareAndExchangeInt(o, offset, expected, x);
1830     }
1831 
1832     @HotSpotIntrinsicCandidate
1833     public final boolean weakCompareAndSetIntPlain(Object o, long offset,
1834                                                    int expected,
1835                                                    int x) {
1836         return compareAndSetInt(o, offset, expected, x);
1837     }
1838 
1839     @HotSpotIntrinsicCandidate
1840     public final boolean weakCompareAndSetIntAcquire(Object o, long offset,
1841                                                      int expected,
1842                                                      int x) {
1843         return compareAndSetInt(o, offset, expected, x);
1844     }
1845 
1846     @HotSpotIntrinsicCandidate
1847     public final boolean weakCompareAndSetIntRelease(Object o, long offset,
1848                                                      int expected,
1849                                                      int x) {
1850         return compareAndSetInt(o, offset, expected, x);
1851     }
1852 
1853     @HotSpotIntrinsicCandidate
1854     public final boolean weakCompareAndSetInt(Object o, long offset,
1855                                               int expected,
1856                                               int x) {
1857         return compareAndSetInt(o, offset, expected, x);
1858     }
1859 
1860     @HotSpotIntrinsicCandidate
1861     public final byte compareAndExchangeByte(Object o, long offset,
1862                                              byte expected,
1863                                              byte x) {
1864         long wordOffset = offset &amp; ~3;
1865         int shift = (int) (offset &amp; 3) &lt;&lt; 3;
1866         if (BIG_ENDIAN) {
1867             shift = 24 - shift;
1868         }
1869         int mask           = 0xFF &lt;&lt; shift;
1870         int maskedExpected = (expected &amp; 0xFF) &lt;&lt; shift;
1871         int maskedX        = (x &amp; 0xFF) &lt;&lt; shift;
1872         int fullWord;
1873         do {
1874             fullWord = getIntVolatile(o, wordOffset);
1875             if ((fullWord &amp; mask) != maskedExpected)
1876                 return (byte) ((fullWord &amp; mask) &gt;&gt; shift);
1877         } while (!weakCompareAndSetInt(o, wordOffset,
1878                                                 fullWord, (fullWord &amp; ~mask) | maskedX));
1879         return expected;
1880     }
1881 
1882     @HotSpotIntrinsicCandidate
1883     public final boolean compareAndSetByte(Object o, long offset,
1884                                            byte expected,
1885                                            byte x) {
1886         return compareAndExchangeByte(o, offset, expected, x) == expected;
1887     }
1888 
1889     @HotSpotIntrinsicCandidate
1890     public final boolean weakCompareAndSetByte(Object o, long offset,
1891                                                byte expected,
1892                                                byte x) {
1893         return compareAndSetByte(o, offset, expected, x);
1894     }
1895 
1896     @HotSpotIntrinsicCandidate
1897     public final boolean weakCompareAndSetByteAcquire(Object o, long offset,
1898                                                       byte expected,
1899                                                       byte x) {
1900         return weakCompareAndSetByte(o, offset, expected, x);
1901     }
1902 
1903     @HotSpotIntrinsicCandidate
1904     public final boolean weakCompareAndSetByteRelease(Object o, long offset,
1905                                                       byte expected,
1906                                                       byte x) {
1907         return weakCompareAndSetByte(o, offset, expected, x);
1908     }
1909 
1910     @HotSpotIntrinsicCandidate
1911     public final boolean weakCompareAndSetBytePlain(Object o, long offset,
1912                                                     byte expected,
1913                                                     byte x) {
1914         return weakCompareAndSetByte(o, offset, expected, x);
1915     }
1916 
1917     @HotSpotIntrinsicCandidate
1918     public final byte compareAndExchangeByteAcquire(Object o, long offset,
1919                                                     byte expected,
1920                                                     byte x) {
1921         return compareAndExchangeByte(o, offset, expected, x);
1922     }
1923 
1924     @HotSpotIntrinsicCandidate
1925     public final byte compareAndExchangeByteRelease(Object o, long offset,
1926                                                     byte expected,
1927                                                     byte x) {
1928         return compareAndExchangeByte(o, offset, expected, x);
1929     }
1930 
1931     @HotSpotIntrinsicCandidate
1932     public final short compareAndExchangeShort(Object o, long offset,
1933                                                short expected,
1934                                                short x) {
1935         if ((offset &amp; 3) == 3) {
1936             throw new IllegalArgumentException(&quot;Update spans the word, not supported&quot;);
1937         }
1938         long wordOffset = offset &amp; ~3;
1939         int shift = (int) (offset &amp; 3) &lt;&lt; 3;
1940         if (BIG_ENDIAN) {
1941             shift = 16 - shift;
1942         }
1943         int mask           = 0xFFFF &lt;&lt; shift;
1944         int maskedExpected = (expected &amp; 0xFFFF) &lt;&lt; shift;
1945         int maskedX        = (x &amp; 0xFFFF) &lt;&lt; shift;
1946         int fullWord;
1947         do {
1948             fullWord = getIntVolatile(o, wordOffset);
1949             if ((fullWord &amp; mask) != maskedExpected) {
1950                 return (short) ((fullWord &amp; mask) &gt;&gt; shift);
1951             }
1952         } while (!weakCompareAndSetInt(o, wordOffset,
1953                                                 fullWord, (fullWord &amp; ~mask) | maskedX));
1954         return expected;
1955     }
1956 
1957     @HotSpotIntrinsicCandidate
1958     public final boolean compareAndSetShort(Object o, long offset,
1959                                             short expected,
1960                                             short x) {
1961         return compareAndExchangeShort(o, offset, expected, x) == expected;
1962     }
1963 
1964     @HotSpotIntrinsicCandidate
1965     public final boolean weakCompareAndSetShort(Object o, long offset,
1966                                                 short expected,
1967                                                 short x) {
1968         return compareAndSetShort(o, offset, expected, x);
1969     }
1970 
1971     @HotSpotIntrinsicCandidate
1972     public final boolean weakCompareAndSetShortAcquire(Object o, long offset,
1973                                                        short expected,
1974                                                        short x) {
1975         return weakCompareAndSetShort(o, offset, expected, x);
1976     }
1977 
1978     @HotSpotIntrinsicCandidate
1979     public final boolean weakCompareAndSetShortRelease(Object o, long offset,
1980                                                        short expected,
1981                                                        short x) {
1982         return weakCompareAndSetShort(o, offset, expected, x);
1983     }
1984 
1985     @HotSpotIntrinsicCandidate
1986     public final boolean weakCompareAndSetShortPlain(Object o, long offset,
1987                                                      short expected,
1988                                                      short x) {
1989         return weakCompareAndSetShort(o, offset, expected, x);
1990     }
1991 
1992 
1993     @HotSpotIntrinsicCandidate
1994     public final short compareAndExchangeShortAcquire(Object o, long offset,
1995                                                      short expected,
1996                                                      short x) {
1997         return compareAndExchangeShort(o, offset, expected, x);
1998     }
1999 
2000     @HotSpotIntrinsicCandidate
2001     public final short compareAndExchangeShortRelease(Object o, long offset,
2002                                                     short expected,
2003                                                     short x) {
2004         return compareAndExchangeShort(o, offset, expected, x);
2005     }
2006 
2007     @ForceInline
2008     private char s2c(short s) {
2009         return (char) s;
2010     }
2011 
2012     @ForceInline
2013     private short c2s(char s) {
2014         return (short) s;
2015     }
2016 
2017     @ForceInline
2018     public final boolean compareAndSetChar(Object o, long offset,
2019                                            char expected,
2020                                            char x) {
2021         return compareAndSetShort(o, offset, c2s(expected), c2s(x));
2022     }
2023 
2024     @ForceInline
2025     public final char compareAndExchangeChar(Object o, long offset,
2026                                              char expected,
2027                                              char x) {
2028         return s2c(compareAndExchangeShort(o, offset, c2s(expected), c2s(x)));
2029     }
2030 
2031     @ForceInline
2032     public final char compareAndExchangeCharAcquire(Object o, long offset,
2033                                             char expected,
2034                                             char x) {
2035         return s2c(compareAndExchangeShortAcquire(o, offset, c2s(expected), c2s(x)));
2036     }
2037 
2038     @ForceInline
2039     public final char compareAndExchangeCharRelease(Object o, long offset,
2040                                             char expected,
2041                                             char x) {
2042         return s2c(compareAndExchangeShortRelease(o, offset, c2s(expected), c2s(x)));
2043     }
2044 
2045     @ForceInline
2046     public final boolean weakCompareAndSetChar(Object o, long offset,
2047                                                char expected,
2048                                                char x) {
2049         return weakCompareAndSetShort(o, offset, c2s(expected), c2s(x));
2050     }
2051 
2052     @ForceInline
2053     public final boolean weakCompareAndSetCharAcquire(Object o, long offset,
2054                                                       char expected,
2055                                                       char x) {
2056         return weakCompareAndSetShortAcquire(o, offset, c2s(expected), c2s(x));
2057     }
2058 
2059     @ForceInline
2060     public final boolean weakCompareAndSetCharRelease(Object o, long offset,
2061                                                       char expected,
2062                                                       char x) {
2063         return weakCompareAndSetShortRelease(o, offset, c2s(expected), c2s(x));
2064     }
2065 
2066     @ForceInline
2067     public final boolean weakCompareAndSetCharPlain(Object o, long offset,
2068                                                     char expected,
2069                                                     char x) {
2070         return weakCompareAndSetShortPlain(o, offset, c2s(expected), c2s(x));
2071     }
2072 
2073     /**
2074      * The JVM converts integral values to boolean values using two
2075      * different conventions, byte testing against zero and truncation
2076      * to least-significant bit.
2077      *
2078      * &lt;p&gt;The JNI documents specify that, at least for returning
2079      * values from native methods, a Java boolean value is converted
2080      * to the value-set 0..1 by first truncating to a byte (0..255 or
2081      * maybe -128..127) and then testing against zero. Thus, Java
2082      * booleans in non-Java data structures are by convention
2083      * represented as 8-bit containers containing either zero (for
2084      * false) or any non-zero value (for true).
2085      *
2086      * &lt;p&gt;Java booleans in the heap are also stored in bytes, but are
2087      * strongly normalized to the value-set 0..1 (i.e., they are
2088      * truncated to the least-significant bit).
2089      *
2090      * &lt;p&gt;The main reason for having different conventions for
2091      * conversion is performance: Truncation to the least-significant
2092      * bit can be usually implemented with fewer (machine)
2093      * instructions than byte testing against zero.
2094      *
2095      * &lt;p&gt;A number of Unsafe methods load boolean values from the heap
2096      * as bytes. Unsafe converts those values according to the JNI
2097      * rules (i.e, using the &quot;testing against zero&quot; convention). The
2098      * method {@code byte2bool} implements that conversion.
2099      *
2100      * @param b the byte to be converted to boolean
2101      * @return the result of the conversion
2102      */
2103     @ForceInline
2104     private boolean byte2bool(byte b) {
2105         return b != 0;
2106     }
2107 
2108     /**
2109      * Convert a boolean value to a byte. The return value is strongly
2110      * normalized to the value-set 0..1 (i.e., the value is truncated
2111      * to the least-significant bit). See {@link #byte2bool(byte)} for
2112      * more details on conversion conventions.
2113      *
2114      * @param b the boolean to be converted to byte (and then normalized)
2115      * @return the result of the conversion
2116      */
2117     @ForceInline
2118     private byte bool2byte(boolean b) {
2119         return b ? (byte)1 : (byte)0;
2120     }
2121 
2122     @ForceInline
2123     public final boolean compareAndSetBoolean(Object o, long offset,
2124                                               boolean expected,
2125                                               boolean x) {
2126         return compareAndSetByte(o, offset, bool2byte(expected), bool2byte(x));
2127     }
2128 
2129     @ForceInline
2130     public final boolean compareAndExchangeBoolean(Object o, long offset,
2131                                                    boolean expected,
2132                                                    boolean x) {
2133         return byte2bool(compareAndExchangeByte(o, offset, bool2byte(expected), bool2byte(x)));
2134     }
2135 
2136     @ForceInline
2137     public final boolean compareAndExchangeBooleanAcquire(Object o, long offset,
2138                                                     boolean expected,
2139                                                     boolean x) {
2140         return byte2bool(compareAndExchangeByteAcquire(o, offset, bool2byte(expected), bool2byte(x)));
2141     }
2142 
2143     @ForceInline
2144     public final boolean compareAndExchangeBooleanRelease(Object o, long offset,
2145                                                        boolean expected,
2146                                                        boolean x) {
2147         return byte2bool(compareAndExchangeByteRelease(o, offset, bool2byte(expected), bool2byte(x)));
2148     }
2149 
2150     @ForceInline
2151     public final boolean weakCompareAndSetBoolean(Object o, long offset,
2152                                                   boolean expected,
2153                                                   boolean x) {
2154         return weakCompareAndSetByte(o, offset, bool2byte(expected), bool2byte(x));
2155     }
2156 
2157     @ForceInline
2158     public final boolean weakCompareAndSetBooleanAcquire(Object o, long offset,
2159                                                          boolean expected,
2160                                                          boolean x) {
2161         return weakCompareAndSetByteAcquire(o, offset, bool2byte(expected), bool2byte(x));
2162     }
2163 
2164     @ForceInline
2165     public final boolean weakCompareAndSetBooleanRelease(Object o, long offset,
2166                                                          boolean expected,
2167                                                          boolean x) {
2168         return weakCompareAndSetByteRelease(o, offset, bool2byte(expected), bool2byte(x));
2169     }
2170 
2171     @ForceInline
2172     public final boolean weakCompareAndSetBooleanPlain(Object o, long offset,
2173                                                        boolean expected,
2174                                                        boolean x) {
2175         return weakCompareAndSetBytePlain(o, offset, bool2byte(expected), bool2byte(x));
2176     }
2177 
2178     /**
2179      * Atomically updates Java variable to {@code x} if it is currently
2180      * holding {@code expected}.
2181      *
2182      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
2183      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
2184      *
2185      * @return {@code true} if successful
2186      */
2187     @ForceInline
2188     public final boolean compareAndSetFloat(Object o, long offset,
2189                                             float expected,
2190                                             float x) {
2191         return compareAndSetInt(o, offset,
2192                                  Float.floatToRawIntBits(expected),
2193                                  Float.floatToRawIntBits(x));
2194     }
2195 
2196     @ForceInline
2197     public final float compareAndExchangeFloat(Object o, long offset,
2198                                                float expected,
2199                                                float x) {
2200         int w = compareAndExchangeInt(o, offset,
2201                                       Float.floatToRawIntBits(expected),
2202                                       Float.floatToRawIntBits(x));
2203         return Float.intBitsToFloat(w);
2204     }
2205 
2206     @ForceInline
2207     public final float compareAndExchangeFloatAcquire(Object o, long offset,
2208                                                   float expected,
2209                                                   float x) {
2210         int w = compareAndExchangeIntAcquire(o, offset,
2211                                              Float.floatToRawIntBits(expected),
2212                                              Float.floatToRawIntBits(x));
2213         return Float.intBitsToFloat(w);
2214     }
2215 
2216     @ForceInline
2217     public final float compareAndExchangeFloatRelease(Object o, long offset,
2218                                                   float expected,
2219                                                   float x) {
2220         int w = compareAndExchangeIntRelease(o, offset,
2221                                              Float.floatToRawIntBits(expected),
2222                                              Float.floatToRawIntBits(x));
2223         return Float.intBitsToFloat(w);
2224     }
2225 
2226     @ForceInline
2227     public final boolean weakCompareAndSetFloatPlain(Object o, long offset,
2228                                                      float expected,
2229                                                      float x) {
2230         return weakCompareAndSetIntPlain(o, offset,
2231                                      Float.floatToRawIntBits(expected),
2232                                      Float.floatToRawIntBits(x));
2233     }
2234 
2235     @ForceInline
2236     public final boolean weakCompareAndSetFloatAcquire(Object o, long offset,
2237                                                        float expected,
2238                                                        float x) {
2239         return weakCompareAndSetIntAcquire(o, offset,
2240                                             Float.floatToRawIntBits(expected),
2241                                             Float.floatToRawIntBits(x));
2242     }
2243 
2244     @ForceInline
2245     public final boolean weakCompareAndSetFloatRelease(Object o, long offset,
2246                                                        float expected,
2247                                                        float x) {
2248         return weakCompareAndSetIntRelease(o, offset,
2249                                             Float.floatToRawIntBits(expected),
2250                                             Float.floatToRawIntBits(x));
2251     }
2252 
2253     @ForceInline
2254     public final boolean weakCompareAndSetFloat(Object o, long offset,
2255                                                 float expected,
2256                                                 float x) {
2257         return weakCompareAndSetInt(o, offset,
2258                                              Float.floatToRawIntBits(expected),
2259                                              Float.floatToRawIntBits(x));
2260     }
2261 
2262     /**
2263      * Atomically updates Java variable to {@code x} if it is currently
2264      * holding {@code expected}.
2265      *
2266      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
2267      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
2268      *
2269      * @return {@code true} if successful
2270      */
2271     @ForceInline
2272     public final boolean compareAndSetDouble(Object o, long offset,
2273                                              double expected,
2274                                              double x) {
2275         return compareAndSetLong(o, offset,
2276                                  Double.doubleToRawLongBits(expected),
2277                                  Double.doubleToRawLongBits(x));
2278     }
2279 
2280     @ForceInline
2281     public final double compareAndExchangeDouble(Object o, long offset,
2282                                                  double expected,
2283                                                  double x) {
2284         long w = compareAndExchangeLong(o, offset,
2285                                         Double.doubleToRawLongBits(expected),
2286                                         Double.doubleToRawLongBits(x));
2287         return Double.longBitsToDouble(w);
2288     }
2289 
2290     @ForceInline
2291     public final double compareAndExchangeDoubleAcquire(Object o, long offset,
2292                                                         double expected,
2293                                                         double x) {
2294         long w = compareAndExchangeLongAcquire(o, offset,
2295                                                Double.doubleToRawLongBits(expected),
2296                                                Double.doubleToRawLongBits(x));
2297         return Double.longBitsToDouble(w);
2298     }
2299 
2300     @ForceInline
2301     public final double compareAndExchangeDoubleRelease(Object o, long offset,
2302                                                         double expected,
2303                                                         double x) {
2304         long w = compareAndExchangeLongRelease(o, offset,
2305                                                Double.doubleToRawLongBits(expected),
2306                                                Double.doubleToRawLongBits(x));
2307         return Double.longBitsToDouble(w);
2308     }
2309 
2310     @ForceInline
2311     public final boolean weakCompareAndSetDoublePlain(Object o, long offset,
2312                                                       double expected,
2313                                                       double x) {
2314         return weakCompareAndSetLongPlain(o, offset,
2315                                      Double.doubleToRawLongBits(expected),
2316                                      Double.doubleToRawLongBits(x));
2317     }
2318 
2319     @ForceInline
2320     public final boolean weakCompareAndSetDoubleAcquire(Object o, long offset,
2321                                                         double expected,
2322                                                         double x) {
2323         return weakCompareAndSetLongAcquire(o, offset,
2324                                              Double.doubleToRawLongBits(expected),
2325                                              Double.doubleToRawLongBits(x));
2326     }
2327 
2328     @ForceInline
2329     public final boolean weakCompareAndSetDoubleRelease(Object o, long offset,
2330                                                         double expected,
2331                                                         double x) {
2332         return weakCompareAndSetLongRelease(o, offset,
2333                                              Double.doubleToRawLongBits(expected),
2334                                              Double.doubleToRawLongBits(x));
2335     }
2336 
2337     @ForceInline
2338     public final boolean weakCompareAndSetDouble(Object o, long offset,
2339                                                  double expected,
2340                                                  double x) {
2341         return weakCompareAndSetLong(o, offset,
2342                                               Double.doubleToRawLongBits(expected),
2343                                               Double.doubleToRawLongBits(x));
2344     }
2345 
2346     /**
2347      * Atomically updates Java variable to {@code x} if it is currently
2348      * holding {@code expected}.
2349      *
2350      * &lt;p&gt;This operation has memory semantics of a {@code volatile} read
2351      * and write.  Corresponds to C11 atomic_compare_exchange_strong.
2352      *
2353      * @return {@code true} if successful
2354      */
2355     @HotSpotIntrinsicCandidate
2356     public final native boolean compareAndSetLong(Object o, long offset,
2357                                                   long expected,
2358                                                   long x);
2359 
2360     @HotSpotIntrinsicCandidate
2361     public final native long compareAndExchangeLong(Object o, long offset,
2362                                                     long expected,
2363                                                     long x);
2364 
2365     @HotSpotIntrinsicCandidate
2366     public final long compareAndExchangeLongAcquire(Object o, long offset,
2367                                                            long expected,
2368                                                            long x) {
2369         return compareAndExchangeLong(o, offset, expected, x);
2370     }
2371 
2372     @HotSpotIntrinsicCandidate
2373     public final long compareAndExchangeLongRelease(Object o, long offset,
2374                                                            long expected,
2375                                                            long x) {
2376         return compareAndExchangeLong(o, offset, expected, x);
2377     }
2378 
2379     @HotSpotIntrinsicCandidate
2380     public final boolean weakCompareAndSetLongPlain(Object o, long offset,
2381                                                     long expected,
2382                                                     long x) {
2383         return compareAndSetLong(o, offset, expected, x);
2384     }
2385 
2386     @HotSpotIntrinsicCandidate
2387     public final boolean weakCompareAndSetLongAcquire(Object o, long offset,
2388                                                       long expected,
2389                                                       long x) {
2390         return compareAndSetLong(o, offset, expected, x);
2391     }
2392 
2393     @HotSpotIntrinsicCandidate
2394     public final boolean weakCompareAndSetLongRelease(Object o, long offset,
2395                                                       long expected,
2396                                                       long x) {
2397         return compareAndSetLong(o, offset, expected, x);
2398     }
2399 
2400     @HotSpotIntrinsicCandidate
2401     public final boolean weakCompareAndSetLong(Object o, long offset,
2402                                                long expected,
2403                                                long x) {
2404         return compareAndSetLong(o, offset, expected, x);
2405     }
2406 
2407     /**
2408      * Fetches a reference value from a given Java variable, with volatile
2409      * load semantics. Otherwise identical to {@link #getReference(Object, long)}
2410      */
2411     @HotSpotIntrinsicCandidate
2412     public native Object getReferenceVolatile(Object o, long offset);
2413 
2414     /**
2415      * Global lock for atomic and volatile strength access to any value of
2416      * an inline type.  This is a temporary workaround until better localized
2417      * atomic access mechanisms are supported for inline types.
2418      */
2419     private static final Object valueLock = new Object();
2420 
2421     public final &lt;V&gt; Object getValueVolatile(Object base, long offset, Class&lt;?&gt; valueType) {
2422         synchronized (valueLock) {
2423             return getValue(base, offset, valueType);
2424         }
2425     }
2426 
2427     /**
2428      * Stores a reference value into a given Java variable, with
2429      * volatile store semantics. Otherwise identical to {@link #putReference(Object, long, Object)}
2430      */
2431     @HotSpotIntrinsicCandidate
2432     public native void putReferenceVolatile(Object o, long offset, Object x);
2433 
2434     public final &lt;V&gt; void putValueVolatile(Object o, long offset, Class&lt;?&gt; valueType, V x) {
2435         synchronized (valueLock) {
2436             putValue(o, offset, valueType, x);
2437         }
2438     }
2439 
2440     /** Volatile version of {@link #getInt(Object, long)}  */
2441     @HotSpotIntrinsicCandidate
2442     public native int     getIntVolatile(Object o, long offset);
2443 
2444     /** Volatile version of {@link #putInt(Object, long, int)}  */
2445     @HotSpotIntrinsicCandidate
2446     public native void    putIntVolatile(Object o, long offset, int x);
2447 
2448     /** Volatile version of {@link #getBoolean(Object, long)}  */
2449     @HotSpotIntrinsicCandidate
2450     public native boolean getBooleanVolatile(Object o, long offset);
2451 
2452     /** Volatile version of {@link #putBoolean(Object, long, boolean)}  */
2453     @HotSpotIntrinsicCandidate
2454     public native void    putBooleanVolatile(Object o, long offset, boolean x);
2455 
2456     /** Volatile version of {@link #getByte(Object, long)}  */
2457     @HotSpotIntrinsicCandidate
2458     public native byte    getByteVolatile(Object o, long offset);
2459 
2460     /** Volatile version of {@link #putByte(Object, long, byte)}  */
2461     @HotSpotIntrinsicCandidate
2462     public native void    putByteVolatile(Object o, long offset, byte x);
2463 
2464     /** Volatile version of {@link #getShort(Object, long)}  */
2465     @HotSpotIntrinsicCandidate
2466     public native short   getShortVolatile(Object o, long offset);
2467 
2468     /** Volatile version of {@link #putShort(Object, long, short)}  */
2469     @HotSpotIntrinsicCandidate
2470     public native void    putShortVolatile(Object o, long offset, short x);
2471 
2472     /** Volatile version of {@link #getChar(Object, long)}  */
2473     @HotSpotIntrinsicCandidate
2474     public native char    getCharVolatile(Object o, long offset);
2475 
2476     /** Volatile version of {@link #putChar(Object, long, char)}  */
2477     @HotSpotIntrinsicCandidate
2478     public native void    putCharVolatile(Object o, long offset, char x);
2479 
2480     /** Volatile version of {@link #getLong(Object, long)}  */
2481     @HotSpotIntrinsicCandidate
2482     public native long    getLongVolatile(Object o, long offset);
2483 
2484     /** Volatile version of {@link #putLong(Object, long, long)}  */
2485     @HotSpotIntrinsicCandidate
2486     public native void    putLongVolatile(Object o, long offset, long x);
2487 
2488     /** Volatile version of {@link #getFloat(Object, long)}  */
2489     @HotSpotIntrinsicCandidate
2490     public native float   getFloatVolatile(Object o, long offset);
2491 
2492     /** Volatile version of {@link #putFloat(Object, long, float)}  */
2493     @HotSpotIntrinsicCandidate
2494     public native void    putFloatVolatile(Object o, long offset, float x);
2495 
2496     /** Volatile version of {@link #getDouble(Object, long)}  */
2497     @HotSpotIntrinsicCandidate
2498     public native double  getDoubleVolatile(Object o, long offset);
2499 
2500     /** Volatile version of {@link #putDouble(Object, long, double)}  */
2501     @HotSpotIntrinsicCandidate
2502     public native void    putDoubleVolatile(Object o, long offset, double x);
2503 
2504 
2505 
2506     /** Acquire version of {@link #getReferenceVolatile(Object, long)} */
2507     @HotSpotIntrinsicCandidate
2508     public final Object getReferenceAcquire(Object o, long offset) {
2509         return getReferenceVolatile(o, offset);
2510     }
2511 
2512     public final &lt;V&gt; Object getValueAcquire(Object base, long offset, Class&lt;?&gt; valueType) {
2513         return getValueVolatile(base, offset, valueType);
2514     }
2515 
2516     /** Acquire version of {@link #getBooleanVolatile(Object, long)} */
2517     @HotSpotIntrinsicCandidate
2518     public final boolean getBooleanAcquire(Object o, long offset) {
2519         return getBooleanVolatile(o, offset);
2520     }
2521 
2522     /** Acquire version of {@link #getByteVolatile(Object, long)} */
2523     @HotSpotIntrinsicCandidate
2524     public final byte getByteAcquire(Object o, long offset) {
2525         return getByteVolatile(o, offset);
2526     }
2527 
2528     /** Acquire version of {@link #getShortVolatile(Object, long)} */
2529     @HotSpotIntrinsicCandidate
2530     public final short getShortAcquire(Object o, long offset) {
2531         return getShortVolatile(o, offset);
2532     }
2533 
2534     /** Acquire version of {@link #getCharVolatile(Object, long)} */
2535     @HotSpotIntrinsicCandidate
2536     public final char getCharAcquire(Object o, long offset) {
2537         return getCharVolatile(o, offset);
2538     }
2539 
2540     /** Acquire version of {@link #getIntVolatile(Object, long)} */
2541     @HotSpotIntrinsicCandidate
2542     public final int getIntAcquire(Object o, long offset) {
2543         return getIntVolatile(o, offset);
2544     }
2545 
2546     /** Acquire version of {@link #getFloatVolatile(Object, long)} */
2547     @HotSpotIntrinsicCandidate
2548     public final float getFloatAcquire(Object o, long offset) {
2549         return getFloatVolatile(o, offset);
2550     }
2551 
2552     /** Acquire version of {@link #getLongVolatile(Object, long)} */
2553     @HotSpotIntrinsicCandidate
2554     public final long getLongAcquire(Object o, long offset) {
2555         return getLongVolatile(o, offset);
2556     }
2557 
2558     /** Acquire version of {@link #getDoubleVolatile(Object, long)} */
2559     @HotSpotIntrinsicCandidate
2560     public final double getDoubleAcquire(Object o, long offset) {
2561         return getDoubleVolatile(o, offset);
2562     }
2563 
2564     /*
2565       * Versions of {@link #putReferenceVolatile(Object, long, Object)}
2566       * that do not guarantee immediate visibility of the store to
2567       * other threads. This method is generally only useful if the
2568       * underlying field is a Java volatile (or if an array cell, one
2569       * that is otherwise only accessed using volatile accesses).
2570       *
2571       * Corresponds to C11 atomic_store_explicit(..., memory_order_release).
2572       */
2573 
2574     /** Release version of {@link #putReferenceVolatile(Object, long, Object)} */
2575     @HotSpotIntrinsicCandidate
2576     public final void putReferenceRelease(Object o, long offset, Object x) {
2577         putReferenceVolatile(o, offset, x);
2578     }
2579 
2580     public final &lt;V&gt; void putValueRelease(Object o, long offset, Class&lt;?&gt; valueType, V x) {
2581         putValueVolatile(o, offset, valueType, x);
2582     }
2583 
2584     /** Release version of {@link #putBooleanVolatile(Object, long, boolean)} */
2585     @HotSpotIntrinsicCandidate
2586     public final void putBooleanRelease(Object o, long offset, boolean x) {
2587         putBooleanVolatile(o, offset, x);
2588     }
2589 
2590     /** Release version of {@link #putByteVolatile(Object, long, byte)} */
2591     @HotSpotIntrinsicCandidate
2592     public final void putByteRelease(Object o, long offset, byte x) {
2593         putByteVolatile(o, offset, x);
2594     }
2595 
2596     /** Release version of {@link #putShortVolatile(Object, long, short)} */
2597     @HotSpotIntrinsicCandidate
2598     public final void putShortRelease(Object o, long offset, short x) {
2599         putShortVolatile(o, offset, x);
2600     }
2601 
2602     /** Release version of {@link #putCharVolatile(Object, long, char)} */
2603     @HotSpotIntrinsicCandidate
2604     public final void putCharRelease(Object o, long offset, char x) {
2605         putCharVolatile(o, offset, x);
2606     }
2607 
2608     /** Release version of {@link #putIntVolatile(Object, long, int)} */
2609     @HotSpotIntrinsicCandidate
2610     public final void putIntRelease(Object o, long offset, int x) {
2611         putIntVolatile(o, offset, x);
2612     }
2613 
2614     /** Release version of {@link #putFloatVolatile(Object, long, float)} */
2615     @HotSpotIntrinsicCandidate
2616     public final void putFloatRelease(Object o, long offset, float x) {
2617         putFloatVolatile(o, offset, x);
2618     }
2619 
2620     /** Release version of {@link #putLongVolatile(Object, long, long)} */
2621     @HotSpotIntrinsicCandidate
2622     public final void putLongRelease(Object o, long offset, long x) {
2623         putLongVolatile(o, offset, x);
2624     }
2625 
2626     /** Release version of {@link #putDoubleVolatile(Object, long, double)} */
2627     @HotSpotIntrinsicCandidate
2628     public final void putDoubleRelease(Object o, long offset, double x) {
2629         putDoubleVolatile(o, offset, x);
2630     }
2631 
2632     // ------------------------------ Opaque --------------------------------------
2633 
2634     /** Opaque version of {@link #getReferenceVolatile(Object, long)} */
2635     @HotSpotIntrinsicCandidate
2636     public final Object getReferenceOpaque(Object o, long offset) {
2637         return getReferenceVolatile(o, offset);
2638     }
2639 
2640     public final &lt;V&gt; Object getValueOpaque(Object base, long offset, Class&lt;?&gt; valueType) {
2641         return getValueVolatile(base, offset, valueType);
2642     }
2643 
2644     /** Opaque version of {@link #getBooleanVolatile(Object, long)} */
2645     @HotSpotIntrinsicCandidate
2646     public final boolean getBooleanOpaque(Object o, long offset) {
2647         return getBooleanVolatile(o, offset);
2648     }
2649 
2650     /** Opaque version of {@link #getByteVolatile(Object, long)} */
2651     @HotSpotIntrinsicCandidate
2652     public final byte getByteOpaque(Object o, long offset) {
2653         return getByteVolatile(o, offset);
2654     }
2655 
2656     /** Opaque version of {@link #getShortVolatile(Object, long)} */
2657     @HotSpotIntrinsicCandidate
2658     public final short getShortOpaque(Object o, long offset) {
2659         return getShortVolatile(o, offset);
2660     }
2661 
2662     /** Opaque version of {@link #getCharVolatile(Object, long)} */
2663     @HotSpotIntrinsicCandidate
2664     public final char getCharOpaque(Object o, long offset) {
2665         return getCharVolatile(o, offset);
2666     }
2667 
2668     /** Opaque version of {@link #getIntVolatile(Object, long)} */
2669     @HotSpotIntrinsicCandidate
2670     public final int getIntOpaque(Object o, long offset) {
2671         return getIntVolatile(o, offset);
2672     }
2673 
2674     /** Opaque version of {@link #getFloatVolatile(Object, long)} */
2675     @HotSpotIntrinsicCandidate
2676     public final float getFloatOpaque(Object o, long offset) {
2677         return getFloatVolatile(o, offset);
2678     }
2679 
2680     /** Opaque version of {@link #getLongVolatile(Object, long)} */
2681     @HotSpotIntrinsicCandidate
2682     public final long getLongOpaque(Object o, long offset) {
2683         return getLongVolatile(o, offset);
2684     }
2685 
2686     /** Opaque version of {@link #getDoubleVolatile(Object, long)} */
2687     @HotSpotIntrinsicCandidate
2688     public final double getDoubleOpaque(Object o, long offset) {
2689         return getDoubleVolatile(o, offset);
2690     }
2691 
2692     /** Opaque version of {@link #putReferenceVolatile(Object, long, Object)} */
2693     @HotSpotIntrinsicCandidate
2694     public final void putReferenceOpaque(Object o, long offset, Object x) {
2695         putReferenceVolatile(o, offset, x);
2696     }
2697 
2698     public final &lt;V&gt; void putValueOpaque(Object o, long offset, Class&lt;?&gt; valueType, V x) {
2699         putValueVolatile(o, offset, valueType, x);
2700     }
2701 
2702     /** Opaque version of {@link #putBooleanVolatile(Object, long, boolean)} */
2703     @HotSpotIntrinsicCandidate
2704     public final void putBooleanOpaque(Object o, long offset, boolean x) {
2705         putBooleanVolatile(o, offset, x);
2706     }
2707 
2708     /** Opaque version of {@link #putByteVolatile(Object, long, byte)} */
2709     @HotSpotIntrinsicCandidate
2710     public final void putByteOpaque(Object o, long offset, byte x) {
2711         putByteVolatile(o, offset, x);
2712     }
2713 
2714     /** Opaque version of {@link #putShortVolatile(Object, long, short)} */
2715     @HotSpotIntrinsicCandidate
2716     public final void putShortOpaque(Object o, long offset, short x) {
2717         putShortVolatile(o, offset, x);
2718     }
2719 
2720     /** Opaque version of {@link #putCharVolatile(Object, long, char)} */
2721     @HotSpotIntrinsicCandidate
2722     public final void putCharOpaque(Object o, long offset, char x) {
2723         putCharVolatile(o, offset, x);
2724     }
2725 
2726     /** Opaque version of {@link #putIntVolatile(Object, long, int)} */
2727     @HotSpotIntrinsicCandidate
2728     public final void putIntOpaque(Object o, long offset, int x) {
2729         putIntVolatile(o, offset, x);
2730     }
2731 
2732     /** Opaque version of {@link #putFloatVolatile(Object, long, float)} */
2733     @HotSpotIntrinsicCandidate
2734     public final void putFloatOpaque(Object o, long offset, float x) {
2735         putFloatVolatile(o, offset, x);
2736     }
2737 
2738     /** Opaque version of {@link #putLongVolatile(Object, long, long)} */
2739     @HotSpotIntrinsicCandidate
2740     public final void putLongOpaque(Object o, long offset, long x) {
2741         putLongVolatile(o, offset, x);
2742     }
2743 
2744     /** Opaque version of {@link #putDoubleVolatile(Object, long, double)} */
2745     @HotSpotIntrinsicCandidate
2746     public final void putDoubleOpaque(Object o, long offset, double x) {
2747         putDoubleVolatile(o, offset, x);
2748     }
2749 
2750     /**
2751      * Unblocks the given thread blocked on {@code park}, or, if it is
2752      * not blocked, causes the subsequent call to {@code park} not to
2753      * block.  Note: this operation is &quot;unsafe&quot; solely because the
2754      * caller must somehow ensure that the thread has not been
2755      * destroyed. Nothing special is usually required to ensure this
2756      * when called from Java (in which there will ordinarily be a live
2757      * reference to the thread) but this is not nearly-automatically
2758      * so when calling from native code.
2759      *
2760      * @param thread the thread to unpark.
2761      */
2762     @HotSpotIntrinsicCandidate
2763     public native void unpark(Object thread);
2764 
2765     /**
2766      * Blocks current thread, returning when a balancing
2767      * {@code unpark} occurs, or a balancing {@code unpark} has
2768      * already occurred, or the thread is interrupted, or, if not
2769      * absolute and time is not zero, the given time nanoseconds have
2770      * elapsed, or if absolute, the given deadline in milliseconds
2771      * since Epoch has passed, or spuriously (i.e., returning for no
2772      * &quot;reason&quot;). Note: This operation is in the Unsafe class only
2773      * because {@code unpark} is, so it would be strange to place it
2774      * elsewhere.
2775      */
2776     @HotSpotIntrinsicCandidate
2777     public native void park(boolean isAbsolute, long time);
2778 
2779     /**
2780      * Gets the load average in the system run queue assigned
2781      * to the available processors averaged over various periods of time.
2782      * This method retrieves the given {@code nelem} samples and
2783      * assigns to the elements of the given {@code loadavg} array.
2784      * The system imposes a maximum of 3 samples, representing
2785      * averages over the last 1,  5,  and  15 minutes, respectively.
2786      *
2787      * @param loadavg an array of double of size nelems
2788      * @param nelems the number of samples to be retrieved and
2789      *        must be 1 to 3.
2790      *
2791      * @return the number of samples actually retrieved; or -1
2792      *         if the load average is unobtainable.
2793      */
2794     public int getLoadAverage(double[] loadavg, int nelems) {
2795         if (nelems &lt; 0 || nelems &gt; 3 || nelems &gt; loadavg.length) {
2796             throw new ArrayIndexOutOfBoundsException();
2797         }
2798 
2799         return getLoadAverage0(loadavg, nelems);
2800     }
2801 
2802     // The following contain CAS-based Java implementations used on
2803     // platforms not supporting native instructions
2804 
2805     /**
2806      * Atomically adds the given value to the current value of a field
2807      * or array element within the given object {@code o}
2808      * at the given {@code offset}.
2809      *
2810      * @param o object/array to update the field/element in
2811      * @param offset field/element offset
2812      * @param delta the value to add
2813      * @return the previous value
2814      * @since 1.8
2815      */
2816     @HotSpotIntrinsicCandidate
2817     public final int getAndAddInt(Object o, long offset, int delta) {
2818         int v;
2819         do {
2820             v = getIntVolatile(o, offset);
2821         } while (!weakCompareAndSetInt(o, offset, v, v + delta));
2822         return v;
2823     }
2824 
2825     @ForceInline
2826     public final int getAndAddIntRelease(Object o, long offset, int delta) {
2827         int v;
2828         do {
2829             v = getInt(o, offset);
2830         } while (!weakCompareAndSetIntRelease(o, offset, v, v + delta));
2831         return v;
2832     }
2833 
2834     @ForceInline
2835     public final int getAndAddIntAcquire(Object o, long offset, int delta) {
2836         int v;
2837         do {
2838             v = getIntAcquire(o, offset);
2839         } while (!weakCompareAndSetIntAcquire(o, offset, v, v + delta));
2840         return v;
2841     }
2842 
2843     /**
2844      * Atomically adds the given value to the current value of a field
2845      * or array element within the given object {@code o}
2846      * at the given {@code offset}.
2847      *
2848      * @param o object/array to update the field/element in
2849      * @param offset field/element offset
2850      * @param delta the value to add
2851      * @return the previous value
2852      * @since 1.8
2853      */
2854     @HotSpotIntrinsicCandidate
2855     public final long getAndAddLong(Object o, long offset, long delta) {
2856         long v;
2857         do {
2858             v = getLongVolatile(o, offset);
2859         } while (!weakCompareAndSetLong(o, offset, v, v + delta));
2860         return v;
2861     }
2862 
2863     @ForceInline
2864     public final long getAndAddLongRelease(Object o, long offset, long delta) {
2865         long v;
2866         do {
2867             v = getLong(o, offset);
2868         } while (!weakCompareAndSetLongRelease(o, offset, v, v + delta));
2869         return v;
2870     }
2871 
2872     @ForceInline
2873     public final long getAndAddLongAcquire(Object o, long offset, long delta) {
2874         long v;
2875         do {
2876             v = getLongAcquire(o, offset);
2877         } while (!weakCompareAndSetLongAcquire(o, offset, v, v + delta));
2878         return v;
2879     }
2880 
2881     @HotSpotIntrinsicCandidate
2882     public final byte getAndAddByte(Object o, long offset, byte delta) {
2883         byte v;
2884         do {
2885             v = getByteVolatile(o, offset);
2886         } while (!weakCompareAndSetByte(o, offset, v, (byte) (v + delta)));
2887         return v;
2888     }
2889 
2890     @ForceInline
2891     public final byte getAndAddByteRelease(Object o, long offset, byte delta) {
2892         byte v;
2893         do {
2894             v = getByte(o, offset);
2895         } while (!weakCompareAndSetByteRelease(o, offset, v, (byte) (v + delta)));
2896         return v;
2897     }
2898 
2899     @ForceInline
2900     public final byte getAndAddByteAcquire(Object o, long offset, byte delta) {
2901         byte v;
2902         do {
2903             v = getByteAcquire(o, offset);
2904         } while (!weakCompareAndSetByteAcquire(o, offset, v, (byte) (v + delta)));
2905         return v;
2906     }
2907 
2908     @HotSpotIntrinsicCandidate
2909     public final short getAndAddShort(Object o, long offset, short delta) {
2910         short v;
2911         do {
2912             v = getShortVolatile(o, offset);
2913         } while (!weakCompareAndSetShort(o, offset, v, (short) (v + delta)));
2914         return v;
2915     }
2916 
2917     @ForceInline
2918     public final short getAndAddShortRelease(Object o, long offset, short delta) {
2919         short v;
2920         do {
2921             v = getShort(o, offset);
2922         } while (!weakCompareAndSetShortRelease(o, offset, v, (short) (v + delta)));
2923         return v;
2924     }
2925 
2926     @ForceInline
2927     public final short getAndAddShortAcquire(Object o, long offset, short delta) {
2928         short v;
2929         do {
2930             v = getShortAcquire(o, offset);
2931         } while (!weakCompareAndSetShortAcquire(o, offset, v, (short) (v + delta)));
2932         return v;
2933     }
2934 
2935     @ForceInline
2936     public final char getAndAddChar(Object o, long offset, char delta) {
2937         return (char) getAndAddShort(o, offset, (short) delta);
2938     }
2939 
2940     @ForceInline
2941     public final char getAndAddCharRelease(Object o, long offset, char delta) {
2942         return (char) getAndAddShortRelease(o, offset, (short) delta);
2943     }
2944 
2945     @ForceInline
2946     public final char getAndAddCharAcquire(Object o, long offset, char delta) {
2947         return (char) getAndAddShortAcquire(o, offset, (short) delta);
2948     }
2949 
2950     @ForceInline
2951     public final float getAndAddFloat(Object o, long offset, float delta) {
2952         int expectedBits;
2953         float v;
2954         do {
2955             // Load and CAS with the raw bits to avoid issues with NaNs and
2956             // possible bit conversion from signaling NaNs to quiet NaNs that
2957             // may result in the loop not terminating.
2958             expectedBits = getIntVolatile(o, offset);
2959             v = Float.intBitsToFloat(expectedBits);
2960         } while (!weakCompareAndSetInt(o, offset,
2961                                                 expectedBits, Float.floatToRawIntBits(v + delta)));
2962         return v;
2963     }
2964 
2965     @ForceInline
2966     public final float getAndAddFloatRelease(Object o, long offset, float delta) {
2967         int expectedBits;
2968         float v;
2969         do {
2970             // Load and CAS with the raw bits to avoid issues with NaNs and
2971             // possible bit conversion from signaling NaNs to quiet NaNs that
2972             // may result in the loop not terminating.
2973             expectedBits = getInt(o, offset);
2974             v = Float.intBitsToFloat(expectedBits);
2975         } while (!weakCompareAndSetIntRelease(o, offset,
2976                                                expectedBits, Float.floatToRawIntBits(v + delta)));
2977         return v;
2978     }
2979 
2980     @ForceInline
2981     public final float getAndAddFloatAcquire(Object o, long offset, float delta) {
2982         int expectedBits;
2983         float v;
2984         do {
2985             // Load and CAS with the raw bits to avoid issues with NaNs and
2986             // possible bit conversion from signaling NaNs to quiet NaNs that
2987             // may result in the loop not terminating.
2988             expectedBits = getIntAcquire(o, offset);
2989             v = Float.intBitsToFloat(expectedBits);
2990         } while (!weakCompareAndSetIntAcquire(o, offset,
2991                                                expectedBits, Float.floatToRawIntBits(v + delta)));
2992         return v;
2993     }
2994 
2995     @ForceInline
2996     public final double getAndAddDouble(Object o, long offset, double delta) {
2997         long expectedBits;
2998         double v;
2999         do {
3000             // Load and CAS with the raw bits to avoid issues with NaNs and
3001             // possible bit conversion from signaling NaNs to quiet NaNs that
3002             // may result in the loop not terminating.
3003             expectedBits = getLongVolatile(o, offset);
3004             v = Double.longBitsToDouble(expectedBits);
3005         } while (!weakCompareAndSetLong(o, offset,
3006                                                  expectedBits, Double.doubleToRawLongBits(v + delta)));
3007         return v;
3008     }
3009 
3010     @ForceInline
3011     public final double getAndAddDoubleRelease(Object o, long offset, double delta) {
3012         long expectedBits;
3013         double v;
3014         do {
3015             // Load and CAS with the raw bits to avoid issues with NaNs and
3016             // possible bit conversion from signaling NaNs to quiet NaNs that
3017             // may result in the loop not terminating.
3018             expectedBits = getLong(o, offset);
3019             v = Double.longBitsToDouble(expectedBits);
3020         } while (!weakCompareAndSetLongRelease(o, offset,
3021                                                 expectedBits, Double.doubleToRawLongBits(v + delta)));
3022         return v;
3023     }
3024 
3025     @ForceInline
3026     public final double getAndAddDoubleAcquire(Object o, long offset, double delta) {
3027         long expectedBits;
3028         double v;
3029         do {
3030             // Load and CAS with the raw bits to avoid issues with NaNs and
3031             // possible bit conversion from signaling NaNs to quiet NaNs that
3032             // may result in the loop not terminating.
3033             expectedBits = getLongAcquire(o, offset);
3034             v = Double.longBitsToDouble(expectedBits);
3035         } while (!weakCompareAndSetLongAcquire(o, offset,
3036                                                 expectedBits, Double.doubleToRawLongBits(v + delta)));
3037         return v;
3038     }
3039 
3040     /**
3041      * Atomically exchanges the given value with the current value of
3042      * a field or array element within the given object {@code o}
3043      * at the given {@code offset}.
3044      *
3045      * @param o object/array to update the field/element in
3046      * @param offset field/element offset
3047      * @param newValue new value
3048      * @return the previous value
3049      * @since 1.8
3050      */
3051     @HotSpotIntrinsicCandidate
3052     public final int getAndSetInt(Object o, long offset, int newValue) {
3053         int v;
3054         do {
3055             v = getIntVolatile(o, offset);
3056         } while (!weakCompareAndSetInt(o, offset, v, newValue));
3057         return v;
3058     }
3059 
3060     @ForceInline
3061     public final int getAndSetIntRelease(Object o, long offset, int newValue) {
3062         int v;
3063         do {
3064             v = getInt(o, offset);
3065         } while (!weakCompareAndSetIntRelease(o, offset, v, newValue));
3066         return v;
3067     }
3068 
3069     @ForceInline
3070     public final int getAndSetIntAcquire(Object o, long offset, int newValue) {
3071         int v;
3072         do {
3073             v = getIntAcquire(o, offset);
3074         } while (!weakCompareAndSetIntAcquire(o, offset, v, newValue));
3075         return v;
3076     }
3077 
3078     /**
3079      * Atomically exchanges the given value with the current value of
3080      * a field or array element within the given object {@code o}
3081      * at the given {@code offset}.
3082      *
3083      * @param o object/array to update the field/element in
3084      * @param offset field/element offset
3085      * @param newValue new value
3086      * @return the previous value
3087      * @since 1.8
3088      */
3089     @HotSpotIntrinsicCandidate
3090     public final long getAndSetLong(Object o, long offset, long newValue) {
3091         long v;
3092         do {
3093             v = getLongVolatile(o, offset);
3094         } while (!weakCompareAndSetLong(o, offset, v, newValue));
3095         return v;
3096     }
3097 
3098     @ForceInline
3099     public final long getAndSetLongRelease(Object o, long offset, long newValue) {
3100         long v;
3101         do {
3102             v = getLong(o, offset);
3103         } while (!weakCompareAndSetLongRelease(o, offset, v, newValue));
3104         return v;
3105     }
3106 
3107     @ForceInline
3108     public final long getAndSetLongAcquire(Object o, long offset, long newValue) {
3109         long v;
3110         do {
3111             v = getLongAcquire(o, offset);
3112         } while (!weakCompareAndSetLongAcquire(o, offset, v, newValue));
3113         return v;
3114     }
3115 
3116     /**
3117      * Atomically exchanges the given reference value with the current
3118      * reference value of a field or array element within the given
3119      * object {@code o} at the given {@code offset}.
3120      *
3121      * @param o object/array to update the field/element in
3122      * @param offset field/element offset
3123      * @param newValue new value
3124      * @return the previous value
3125      * @since 1.8
3126      */
3127     @HotSpotIntrinsicCandidate
3128     public final Object getAndSetReference(Object o, long offset, Object newValue) {
3129         Object v;
3130         do {
3131             v = getReferenceVolatile(o, offset);
3132         } while (!weakCompareAndSetReference(o, offset, v, newValue));
3133         return v;
3134     }
3135 
3136     @SuppressWarnings(&quot;unchecked&quot;)
3137     public final &lt;V&gt; Object getAndSetValue(Object o, long offset, Class&lt;?&gt; valueType, V newValue) {
3138         synchronized (valueLock) {
3139             Object oldValue = getValue(o, offset, valueType);
3140             putValue(o, offset, valueType, newValue);
3141             return oldValue;
3142         }
3143     }
3144 
3145     @ForceInline
3146     public final Object getAndSetReferenceRelease(Object o, long offset, Object newValue) {
3147         Object v;
3148         do {
3149             v = getReference(o, offset);
3150         } while (!weakCompareAndSetReferenceRelease(o, offset, v, newValue));
3151         return v;
3152     }
3153 
3154     @ForceInline
3155     public final &lt;V&gt; Object getAndSetValueRelease(Object o, long offset, Class&lt;?&gt; valueType, V newValue) {
3156         return getAndSetValue(o, offset, valueType, newValue);
3157     }
3158 
3159     @ForceInline
3160     public final Object getAndSetReferenceAcquire(Object o, long offset, Object newValue) {
3161         Object v;
3162         do {
3163             v = getReferenceAcquire(o, offset);
3164         } while (!weakCompareAndSetReferenceAcquire(o, offset, v, newValue));
3165         return v;
3166     }
3167 
3168     @ForceInline
3169     public final &lt;V&gt; Object getAndSetValueAcquire(Object o, long offset, Class&lt;?&gt; valueType, V newValue) {
3170         return getAndSetValue(o, offset, valueType, newValue);
3171     }
3172 
3173     @HotSpotIntrinsicCandidate
3174     public final byte getAndSetByte(Object o, long offset, byte newValue) {
3175         byte v;
3176         do {
3177             v = getByteVolatile(o, offset);
3178         } while (!weakCompareAndSetByte(o, offset, v, newValue));
3179         return v;
3180     }
3181 
3182     @ForceInline
3183     public final byte getAndSetByteRelease(Object o, long offset, byte newValue) {
3184         byte v;
3185         do {
3186             v = getByte(o, offset);
3187         } while (!weakCompareAndSetByteRelease(o, offset, v, newValue));
3188         return v;
3189     }
3190 
3191     @ForceInline
3192     public final byte getAndSetByteAcquire(Object o, long offset, byte newValue) {
3193         byte v;
3194         do {
3195             v = getByteAcquire(o, offset);
3196         } while (!weakCompareAndSetByteAcquire(o, offset, v, newValue));
3197         return v;
3198     }
3199 
3200     @ForceInline
3201     public final boolean getAndSetBoolean(Object o, long offset, boolean newValue) {
3202         return byte2bool(getAndSetByte(o, offset, bool2byte(newValue)));
3203     }
3204 
3205     @ForceInline
3206     public final boolean getAndSetBooleanRelease(Object o, long offset, boolean newValue) {
3207         return byte2bool(getAndSetByteRelease(o, offset, bool2byte(newValue)));
3208     }
3209 
3210     @ForceInline
3211     public final boolean getAndSetBooleanAcquire(Object o, long offset, boolean newValue) {
3212         return byte2bool(getAndSetByteAcquire(o, offset, bool2byte(newValue)));
3213     }
3214 
3215     @HotSpotIntrinsicCandidate
3216     public final short getAndSetShort(Object o, long offset, short newValue) {
3217         short v;
3218         do {
3219             v = getShortVolatile(o, offset);
3220         } while (!weakCompareAndSetShort(o, offset, v, newValue));
3221         return v;
3222     }
3223 
3224     @ForceInline
3225     public final short getAndSetShortRelease(Object o, long offset, short newValue) {
3226         short v;
3227         do {
3228             v = getShort(o, offset);
3229         } while (!weakCompareAndSetShortRelease(o, offset, v, newValue));
3230         return v;
3231     }
3232 
3233     @ForceInline
3234     public final short getAndSetShortAcquire(Object o, long offset, short newValue) {
3235         short v;
3236         do {
3237             v = getShortAcquire(o, offset);
3238         } while (!weakCompareAndSetShortAcquire(o, offset, v, newValue));
3239         return v;
3240     }
3241 
3242     @ForceInline
3243     public final char getAndSetChar(Object o, long offset, char newValue) {
3244         return s2c(getAndSetShort(o, offset, c2s(newValue)));
3245     }
3246 
3247     @ForceInline
3248     public final char getAndSetCharRelease(Object o, long offset, char newValue) {
3249         return s2c(getAndSetShortRelease(o, offset, c2s(newValue)));
3250     }
3251 
3252     @ForceInline
3253     public final char getAndSetCharAcquire(Object o, long offset, char newValue) {
3254         return s2c(getAndSetShortAcquire(o, offset, c2s(newValue)));
3255     }
3256 
3257     @ForceInline
3258     public final float getAndSetFloat(Object o, long offset, float newValue) {
3259         int v = getAndSetInt(o, offset, Float.floatToRawIntBits(newValue));
3260         return Float.intBitsToFloat(v);
3261     }
3262 
3263     @ForceInline
3264     public final float getAndSetFloatRelease(Object o, long offset, float newValue) {
3265         int v = getAndSetIntRelease(o, offset, Float.floatToRawIntBits(newValue));
3266         return Float.intBitsToFloat(v);
3267     }
3268 
3269     @ForceInline
3270     public final float getAndSetFloatAcquire(Object o, long offset, float newValue) {
3271         int v = getAndSetIntAcquire(o, offset, Float.floatToRawIntBits(newValue));
3272         return Float.intBitsToFloat(v);
3273     }
3274 
3275     @ForceInline
3276     public final double getAndSetDouble(Object o, long offset, double newValue) {
3277         long v = getAndSetLong(o, offset, Double.doubleToRawLongBits(newValue));
3278         return Double.longBitsToDouble(v);
3279     }
3280 
3281     @ForceInline
3282     public final double getAndSetDoubleRelease(Object o, long offset, double newValue) {
3283         long v = getAndSetLongRelease(o, offset, Double.doubleToRawLongBits(newValue));
3284         return Double.longBitsToDouble(v);
3285     }
3286 
3287     @ForceInline
3288     public final double getAndSetDoubleAcquire(Object o, long offset, double newValue) {
3289         long v = getAndSetLongAcquire(o, offset, Double.doubleToRawLongBits(newValue));
3290         return Double.longBitsToDouble(v);
3291     }
3292 
3293 
3294     // The following contain CAS-based Java implementations used on
3295     // platforms not supporting native instructions
3296 
3297     @ForceInline
3298     public final boolean getAndBitwiseOrBoolean(Object o, long offset, boolean mask) {
3299         return byte2bool(getAndBitwiseOrByte(o, offset, bool2byte(mask)));
3300     }
3301 
3302     @ForceInline
3303     public final boolean getAndBitwiseOrBooleanRelease(Object o, long offset, boolean mask) {
3304         return byte2bool(getAndBitwiseOrByteRelease(o, offset, bool2byte(mask)));
3305     }
3306 
3307     @ForceInline
3308     public final boolean getAndBitwiseOrBooleanAcquire(Object o, long offset, boolean mask) {
3309         return byte2bool(getAndBitwiseOrByteAcquire(o, offset, bool2byte(mask)));
3310     }
3311 
3312     @ForceInline
3313     public final boolean getAndBitwiseAndBoolean(Object o, long offset, boolean mask) {
3314         return byte2bool(getAndBitwiseAndByte(o, offset, bool2byte(mask)));
3315     }
3316 
3317     @ForceInline
3318     public final boolean getAndBitwiseAndBooleanRelease(Object o, long offset, boolean mask) {
3319         return byte2bool(getAndBitwiseAndByteRelease(o, offset, bool2byte(mask)));
3320     }
3321 
3322     @ForceInline
3323     public final boolean getAndBitwiseAndBooleanAcquire(Object o, long offset, boolean mask) {
3324         return byte2bool(getAndBitwiseAndByteAcquire(o, offset, bool2byte(mask)));
3325     }
3326 
3327     @ForceInline
3328     public final boolean getAndBitwiseXorBoolean(Object o, long offset, boolean mask) {
3329         return byte2bool(getAndBitwiseXorByte(o, offset, bool2byte(mask)));
3330     }
3331 
3332     @ForceInline
3333     public final boolean getAndBitwiseXorBooleanRelease(Object o, long offset, boolean mask) {
3334         return byte2bool(getAndBitwiseXorByteRelease(o, offset, bool2byte(mask)));
3335     }
3336 
3337     @ForceInline
3338     public final boolean getAndBitwiseXorBooleanAcquire(Object o, long offset, boolean mask) {
3339         return byte2bool(getAndBitwiseXorByteAcquire(o, offset, bool2byte(mask)));
3340     }
3341 
3342 
3343     @ForceInline
3344     public final byte getAndBitwiseOrByte(Object o, long offset, byte mask) {
3345         byte current;
3346         do {
3347             current = getByteVolatile(o, offset);
3348         } while (!weakCompareAndSetByte(o, offset,
3349                                                   current, (byte) (current | mask)));
3350         return current;
3351     }
3352 
3353     @ForceInline
3354     public final byte getAndBitwiseOrByteRelease(Object o, long offset, byte mask) {
3355         byte current;
3356         do {
3357             current = getByte(o, offset);
3358         } while (!weakCompareAndSetByteRelease(o, offset,
3359                                                  current, (byte) (current | mask)));
3360         return current;
3361     }
3362 
3363     @ForceInline
3364     public final byte getAndBitwiseOrByteAcquire(Object o, long offset, byte mask) {
3365         byte current;
3366         do {
3367             // Plain read, the value is a hint, the acquire CAS does the work
3368             current = getByte(o, offset);
3369         } while (!weakCompareAndSetByteAcquire(o, offset,
3370                                                  current, (byte) (current | mask)));
3371         return current;
3372     }
3373 
3374     @ForceInline
3375     public final byte getAndBitwiseAndByte(Object o, long offset, byte mask) {
3376         byte current;
3377         do {
3378             current = getByteVolatile(o, offset);
3379         } while (!weakCompareAndSetByte(o, offset,
3380                                                   current, (byte) (current &amp; mask)));
3381         return current;
3382     }
3383 
3384     @ForceInline
3385     public final byte getAndBitwiseAndByteRelease(Object o, long offset, byte mask) {
3386         byte current;
3387         do {
3388             current = getByte(o, offset);
3389         } while (!weakCompareAndSetByteRelease(o, offset,
3390                                                  current, (byte) (current &amp; mask)));
3391         return current;
3392     }
3393 
3394     @ForceInline
3395     public final byte getAndBitwiseAndByteAcquire(Object o, long offset, byte mask) {
3396         byte current;
3397         do {
3398             // Plain read, the value is a hint, the acquire CAS does the work
3399             current = getByte(o, offset);
3400         } while (!weakCompareAndSetByteAcquire(o, offset,
3401                                                  current, (byte) (current &amp; mask)));
3402         return current;
3403     }
3404 
3405     @ForceInline
3406     public final byte getAndBitwiseXorByte(Object o, long offset, byte mask) {
3407         byte current;
3408         do {
3409             current = getByteVolatile(o, offset);
3410         } while (!weakCompareAndSetByte(o, offset,
3411                                                   current, (byte) (current ^ mask)));
3412         return current;
3413     }
3414 
3415     @ForceInline
3416     public final byte getAndBitwiseXorByteRelease(Object o, long offset, byte mask) {
3417         byte current;
3418         do {
3419             current = getByte(o, offset);
3420         } while (!weakCompareAndSetByteRelease(o, offset,
3421                                                  current, (byte) (current ^ mask)));
3422         return current;
3423     }
3424 
3425     @ForceInline
3426     public final byte getAndBitwiseXorByteAcquire(Object o, long offset, byte mask) {
3427         byte current;
3428         do {
3429             // Plain read, the value is a hint, the acquire CAS does the work
3430             current = getByte(o, offset);
3431         } while (!weakCompareAndSetByteAcquire(o, offset,
3432                                                  current, (byte) (current ^ mask)));
3433         return current;
3434     }
3435 
3436 
3437     @ForceInline
3438     public final char getAndBitwiseOrChar(Object o, long offset, char mask) {
3439         return s2c(getAndBitwiseOrShort(o, offset, c2s(mask)));
3440     }
3441 
3442     @ForceInline
3443     public final char getAndBitwiseOrCharRelease(Object o, long offset, char mask) {
3444         return s2c(getAndBitwiseOrShortRelease(o, offset, c2s(mask)));
3445     }
3446 
3447     @ForceInline
3448     public final char getAndBitwiseOrCharAcquire(Object o, long offset, char mask) {
3449         return s2c(getAndBitwiseOrShortAcquire(o, offset, c2s(mask)));
3450     }
3451 
3452     @ForceInline
3453     public final char getAndBitwiseAndChar(Object o, long offset, char mask) {
3454         return s2c(getAndBitwiseAndShort(o, offset, c2s(mask)));
3455     }
3456 
3457     @ForceInline
3458     public final char getAndBitwiseAndCharRelease(Object o, long offset, char mask) {
3459         return s2c(getAndBitwiseAndShortRelease(o, offset, c2s(mask)));
3460     }
3461 
3462     @ForceInline
3463     public final char getAndBitwiseAndCharAcquire(Object o, long offset, char mask) {
3464         return s2c(getAndBitwiseAndShortAcquire(o, offset, c2s(mask)));
3465     }
3466 
3467     @ForceInline
3468     public final char getAndBitwiseXorChar(Object o, long offset, char mask) {
3469         return s2c(getAndBitwiseXorShort(o, offset, c2s(mask)));
3470     }
3471 
3472     @ForceInline
3473     public final char getAndBitwiseXorCharRelease(Object o, long offset, char mask) {
3474         return s2c(getAndBitwiseXorShortRelease(o, offset, c2s(mask)));
3475     }
3476 
3477     @ForceInline
3478     public final char getAndBitwiseXorCharAcquire(Object o, long offset, char mask) {
3479         return s2c(getAndBitwiseXorShortAcquire(o, offset, c2s(mask)));
3480     }
3481 
3482 
3483     @ForceInline
3484     public final short getAndBitwiseOrShort(Object o, long offset, short mask) {
3485         short current;
3486         do {
3487             current = getShortVolatile(o, offset);
3488         } while (!weakCompareAndSetShort(o, offset,
3489                                                 current, (short) (current | mask)));
3490         return current;
3491     }
3492 
3493     @ForceInline
3494     public final short getAndBitwiseOrShortRelease(Object o, long offset, short mask) {
3495         short current;
3496         do {
3497             current = getShort(o, offset);
3498         } while (!weakCompareAndSetShortRelease(o, offset,
3499                                                current, (short) (current | mask)));
3500         return current;
3501     }
3502 
3503     @ForceInline
3504     public final short getAndBitwiseOrShortAcquire(Object o, long offset, short mask) {
3505         short current;
3506         do {
3507             // Plain read, the value is a hint, the acquire CAS does the work
3508             current = getShort(o, offset);
3509         } while (!weakCompareAndSetShortAcquire(o, offset,
3510                                                current, (short) (current | mask)));
3511         return current;
3512     }
3513 
3514     @ForceInline
3515     public final short getAndBitwiseAndShort(Object o, long offset, short mask) {
3516         short current;
3517         do {
3518             current = getShortVolatile(o, offset);
3519         } while (!weakCompareAndSetShort(o, offset,
3520                                                 current, (short) (current &amp; mask)));
3521         return current;
3522     }
3523 
3524     @ForceInline
3525     public final short getAndBitwiseAndShortRelease(Object o, long offset, short mask) {
3526         short current;
3527         do {
3528             current = getShort(o, offset);
3529         } while (!weakCompareAndSetShortRelease(o, offset,
3530                                                current, (short) (current &amp; mask)));
3531         return current;
3532     }
3533 
3534     @ForceInline
3535     public final short getAndBitwiseAndShortAcquire(Object o, long offset, short mask) {
3536         short current;
3537         do {
3538             // Plain read, the value is a hint, the acquire CAS does the work
3539             current = getShort(o, offset);
3540         } while (!weakCompareAndSetShortAcquire(o, offset,
3541                                                current, (short) (current &amp; mask)));
3542         return current;
3543     }
3544 
3545     @ForceInline
3546     public final short getAndBitwiseXorShort(Object o, long offset, short mask) {
3547         short current;
3548         do {
3549             current = getShortVolatile(o, offset);
3550         } while (!weakCompareAndSetShort(o, offset,
3551                                                 current, (short) (current ^ mask)));
3552         return current;
3553     }
3554 
3555     @ForceInline
3556     public final short getAndBitwiseXorShortRelease(Object o, long offset, short mask) {
3557         short current;
3558         do {
3559             current = getShort(o, offset);
3560         } while (!weakCompareAndSetShortRelease(o, offset,
3561                                                current, (short) (current ^ mask)));
3562         return current;
3563     }
3564 
3565     @ForceInline
3566     public final short getAndBitwiseXorShortAcquire(Object o, long offset, short mask) {
3567         short current;
3568         do {
3569             // Plain read, the value is a hint, the acquire CAS does the work
3570             current = getShort(o, offset);
3571         } while (!weakCompareAndSetShortAcquire(o, offset,
3572                                                current, (short) (current ^ mask)));
3573         return current;
3574     }
3575 
3576 
3577     @ForceInline
3578     public final int getAndBitwiseOrInt(Object o, long offset, int mask) {
3579         int current;
3580         do {
3581             current = getIntVolatile(o, offset);
3582         } while (!weakCompareAndSetInt(o, offset,
3583                                                 current, current | mask));
3584         return current;
3585     }
3586 
3587     @ForceInline
3588     public final int getAndBitwiseOrIntRelease(Object o, long offset, int mask) {
3589         int current;
3590         do {
3591             current = getInt(o, offset);
3592         } while (!weakCompareAndSetIntRelease(o, offset,
3593                                                current, current | mask));
3594         return current;
3595     }
3596 
3597     @ForceInline
3598     public final int getAndBitwiseOrIntAcquire(Object o, long offset, int mask) {
3599         int current;
3600         do {
3601             // Plain read, the value is a hint, the acquire CAS does the work
3602             current = getInt(o, offset);
3603         } while (!weakCompareAndSetIntAcquire(o, offset,
3604                                                current, current | mask));
3605         return current;
3606     }
3607 
3608     /**
3609      * Atomically replaces the current value of a field or array element within
3610      * the given object with the result of bitwise AND between the current value
3611      * and mask.
3612      *
3613      * @param o object/array to update the field/element in
3614      * @param offset field/element offset
3615      * @param mask the mask value
3616      * @return the previous value
3617      * @since 9
3618      */
3619     @ForceInline
3620     public final int getAndBitwiseAndInt(Object o, long offset, int mask) {
3621         int current;
3622         do {
3623             current = getIntVolatile(o, offset);
3624         } while (!weakCompareAndSetInt(o, offset,
3625                                                 current, current &amp; mask));
3626         return current;
3627     }
3628 
3629     @ForceInline
3630     public final int getAndBitwiseAndIntRelease(Object o, long offset, int mask) {
3631         int current;
3632         do {
3633             current = getInt(o, offset);
3634         } while (!weakCompareAndSetIntRelease(o, offset,
3635                                                current, current &amp; mask));
3636         return current;
3637     }
3638 
3639     @ForceInline
3640     public final int getAndBitwiseAndIntAcquire(Object o, long offset, int mask) {
3641         int current;
3642         do {
3643             // Plain read, the value is a hint, the acquire CAS does the work
3644             current = getInt(o, offset);
3645         } while (!weakCompareAndSetIntAcquire(o, offset,
3646                                                current, current &amp; mask));
3647         return current;
3648     }
3649 
3650     @ForceInline
3651     public final int getAndBitwiseXorInt(Object o, long offset, int mask) {
3652         int current;
3653         do {
3654             current = getIntVolatile(o, offset);
3655         } while (!weakCompareAndSetInt(o, offset,
3656                                                 current, current ^ mask));
3657         return current;
3658     }
3659 
3660     @ForceInline
3661     public final int getAndBitwiseXorIntRelease(Object o, long offset, int mask) {
3662         int current;
3663         do {
3664             current = getInt(o, offset);
3665         } while (!weakCompareAndSetIntRelease(o, offset,
3666                                                current, current ^ mask));
3667         return current;
3668     }
3669 
3670     @ForceInline
3671     public final int getAndBitwiseXorIntAcquire(Object o, long offset, int mask) {
3672         int current;
3673         do {
3674             // Plain read, the value is a hint, the acquire CAS does the work
3675             current = getInt(o, offset);
3676         } while (!weakCompareAndSetIntAcquire(o, offset,
3677                                                current, current ^ mask));
3678         return current;
3679     }
3680 
3681 
3682     @ForceInline
3683     public final long getAndBitwiseOrLong(Object o, long offset, long mask) {
3684         long current;
3685         do {
3686             current = getLongVolatile(o, offset);
3687         } while (!weakCompareAndSetLong(o, offset,
3688                                                 current, current | mask));
3689         return current;
3690     }
3691 
3692     @ForceInline
3693     public final long getAndBitwiseOrLongRelease(Object o, long offset, long mask) {
3694         long current;
3695         do {
3696             current = getLong(o, offset);
3697         } while (!weakCompareAndSetLongRelease(o, offset,
3698                                                current, current | mask));
3699         return current;
3700     }
3701 
3702     @ForceInline
3703     public final long getAndBitwiseOrLongAcquire(Object o, long offset, long mask) {
3704         long current;
3705         do {
3706             // Plain read, the value is a hint, the acquire CAS does the work
3707             current = getLong(o, offset);
3708         } while (!weakCompareAndSetLongAcquire(o, offset,
3709                                                current, current | mask));
3710         return current;
3711     }
3712 
3713     @ForceInline
3714     public final long getAndBitwiseAndLong(Object o, long offset, long mask) {
3715         long current;
3716         do {
3717             current = getLongVolatile(o, offset);
3718         } while (!weakCompareAndSetLong(o, offset,
3719                                                 current, current &amp; mask));
3720         return current;
3721     }
3722 
3723     @ForceInline
3724     public final long getAndBitwiseAndLongRelease(Object o, long offset, long mask) {
3725         long current;
3726         do {
3727             current = getLong(o, offset);
3728         } while (!weakCompareAndSetLongRelease(o, offset,
3729                                                current, current &amp; mask));
3730         return current;
3731     }
3732 
3733     @ForceInline
3734     public final long getAndBitwiseAndLongAcquire(Object o, long offset, long mask) {
3735         long current;
3736         do {
3737             // Plain read, the value is a hint, the acquire CAS does the work
3738             current = getLong(o, offset);
3739         } while (!weakCompareAndSetLongAcquire(o, offset,
3740                                                current, current &amp; mask));
3741         return current;
3742     }
3743 
3744     @ForceInline
3745     public final long getAndBitwiseXorLong(Object o, long offset, long mask) {
3746         long current;
3747         do {
3748             current = getLongVolatile(o, offset);
3749         } while (!weakCompareAndSetLong(o, offset,
3750                                                 current, current ^ mask));
3751         return current;
3752     }
3753 
3754     @ForceInline
3755     public final long getAndBitwiseXorLongRelease(Object o, long offset, long mask) {
3756         long current;
3757         do {
3758             current = getLong(o, offset);
3759         } while (!weakCompareAndSetLongRelease(o, offset,
3760                                                current, current ^ mask));
3761         return current;
3762     }
3763 
3764     @ForceInline
3765     public final long getAndBitwiseXorLongAcquire(Object o, long offset, long mask) {
3766         long current;
3767         do {
3768             // Plain read, the value is a hint, the acquire CAS does the work
3769             current = getLong(o, offset);
3770         } while (!weakCompareAndSetLongAcquire(o, offset,
3771                                                current, current ^ mask));
3772         return current;
3773     }
3774 
3775 
3776 
3777     /**
3778      * Ensures that loads before the fence will not be reordered with loads and
3779      * stores after the fence; a &quot;LoadLoad plus LoadStore barrier&quot;.
3780      *
3781      * Corresponds to C11 atomic_thread_fence(memory_order_acquire)
3782      * (an &quot;acquire fence&quot;).
3783      *
3784      * A pure LoadLoad fence is not provided, since the addition of LoadStore
3785      * is almost always desired, and most current hardware instructions that
3786      * provide a LoadLoad barrier also provide a LoadStore barrier for free.
3787      * @since 1.8
3788      */
3789     @HotSpotIntrinsicCandidate
3790     public native void loadFence();
3791 
3792     /**
3793      * Ensures that loads and stores before the fence will not be reordered with
3794      * stores after the fence; a &quot;StoreStore plus LoadStore barrier&quot;.
3795      *
3796      * Corresponds to C11 atomic_thread_fence(memory_order_release)
3797      * (a &quot;release fence&quot;).
3798      *
3799      * A pure StoreStore fence is not provided, since the addition of LoadStore
3800      * is almost always desired, and most current hardware instructions that
3801      * provide a StoreStore barrier also provide a LoadStore barrier for free.
3802      * @since 1.8
3803      */
3804     @HotSpotIntrinsicCandidate
3805     public native void storeFence();
3806 
3807     /**
3808      * Ensures that loads and stores before the fence will not be reordered
3809      * with loads and stores after the fence.  Implies the effects of both
3810      * loadFence() and storeFence(), and in addition, the effect of a StoreLoad
3811      * barrier.
3812      *
3813      * Corresponds to C11 atomic_thread_fence(memory_order_seq_cst).
3814      * @since 1.8
3815      */
3816     @HotSpotIntrinsicCandidate
3817     public native void fullFence();
3818 
3819     /**
3820      * Ensures that loads before the fence will not be reordered with
3821      * loads after the fence.
3822      */
3823     public final void loadLoadFence() {
3824         loadFence();
3825     }
3826 
3827     /**
3828      * Ensures that stores before the fence will not be reordered with
3829      * stores after the fence.
3830      */
3831     public final void storeStoreFence() {
3832         storeFence();
3833     }
3834 
3835 
3836     /**
3837      * Throws IllegalAccessError; for use by the VM for access control
3838      * error support.
3839      * @since 1.8
3840      */
3841     private static void throwIllegalAccessError() {
3842         throw new IllegalAccessError();
3843     }
3844 
3845     /**
3846      * Throws NoSuchMethodError; for use by the VM for redefinition support.
3847      * @since 13
3848      */
3849     private static void throwNoSuchMethodError() {
3850         throw new NoSuchMethodError();
3851     }
3852 
3853     /**
3854      * @return Returns true if the native byte ordering of this
3855      * platform is big-endian, false if it is little-endian.
3856      */
3857     public final boolean isBigEndian() { return BIG_ENDIAN; }
3858 
3859     /**
3860      * @return Returns true if this platform is capable of performing
3861      * accesses at addresses which are not aligned for the type of the
3862      * primitive type being accessed, false otherwise.
3863      */
3864     public final boolean unalignedAccess() { return UNALIGNED_ACCESS; }
3865 
3866     /**
3867      * Fetches a value at some byte offset into a given Java object.
3868      * More specifically, fetches a value within the given object
3869      * &lt;code&gt;o&lt;/code&gt; at the given offset, or (if &lt;code&gt;o&lt;/code&gt; is
3870      * null) from the memory address whose numerical value is the
3871      * given offset.  &lt;p&gt;
3872      *
3873      * The specification of this method is the same as {@link
3874      * #getLong(Object, long)} except that the offset does not need to
3875      * have been obtained from {@link #objectFieldOffset} on the
3876      * {@link java.lang.reflect.Field} of some Java field.  The value
3877      * in memory is raw data, and need not correspond to any Java
3878      * variable.  Unless &lt;code&gt;o&lt;/code&gt; is null, the value accessed
3879      * must be entirely within the allocated object.  The endianness
3880      * of the value in memory is the endianness of the native platform.
3881      *
3882      * &lt;p&gt; The read will be atomic with respect to the largest power
3883      * of two that divides the GCD of the offset and the storage size.
3884      * For example, getLongUnaligned will make atomic reads of 2-, 4-,
3885      * or 8-byte storage units if the offset is zero mod 2, 4, or 8,
3886      * respectively.  There are no other guarantees of atomicity.
3887      * &lt;p&gt;
3888      * 8-byte atomicity is only guaranteed on platforms on which
3889      * support atomic accesses to longs.
3890      *
3891      * @param o Java heap object in which the value resides, if any, else
3892      *        null
3893      * @param offset The offset in bytes from the start of the object
3894      * @return the value fetched from the indicated object
3895      * @throws RuntimeException No defined exceptions are thrown, not even
3896      *         {@link NullPointerException}
3897      * @since 9
3898      */
3899     @HotSpotIntrinsicCandidate
3900     public final long getLongUnaligned(Object o, long offset) {
3901         if ((offset &amp; 7) == 0) {
3902             return getLong(o, offset);
3903         } else if ((offset &amp; 3) == 0) {
3904             return makeLong(getInt(o, offset),
3905                             getInt(o, offset + 4));
3906         } else if ((offset &amp; 1) == 0) {
3907             return makeLong(getShort(o, offset),
3908                             getShort(o, offset + 2),
3909                             getShort(o, offset + 4),
3910                             getShort(o, offset + 6));
3911         } else {
3912             return makeLong(getByte(o, offset),
3913                             getByte(o, offset + 1),
3914                             getByte(o, offset + 2),
3915                             getByte(o, offset + 3),
3916                             getByte(o, offset + 4),
3917                             getByte(o, offset + 5),
3918                             getByte(o, offset + 6),
3919                             getByte(o, offset + 7));
3920         }
3921     }
3922     /**
3923      * As {@link #getLongUnaligned(Object, long)} but with an
3924      * additional argument which specifies the endianness of the value
3925      * as stored in memory.
3926      *
3927      * @param o Java heap object in which the variable resides
3928      * @param offset The offset in bytes from the start of the object
3929      * @param bigEndian The endianness of the value
3930      * @return the value fetched from the indicated object
3931      * @since 9
3932      */
3933     public final long getLongUnaligned(Object o, long offset, boolean bigEndian) {
3934         return convEndian(bigEndian, getLongUnaligned(o, offset));
3935     }
3936 
3937     /** @see #getLongUnaligned(Object, long) */
3938     @HotSpotIntrinsicCandidate
3939     public final int getIntUnaligned(Object o, long offset) {
3940         if ((offset &amp; 3) == 0) {
3941             return getInt(o, offset);
3942         } else if ((offset &amp; 1) == 0) {
3943             return makeInt(getShort(o, offset),
3944                            getShort(o, offset + 2));
3945         } else {
3946             return makeInt(getByte(o, offset),
3947                            getByte(o, offset + 1),
3948                            getByte(o, offset + 2),
3949                            getByte(o, offset + 3));
3950         }
3951     }
3952     /** @see #getLongUnaligned(Object, long, boolean) */
3953     public final int getIntUnaligned(Object o, long offset, boolean bigEndian) {
3954         return convEndian(bigEndian, getIntUnaligned(o, offset));
3955     }
3956 
3957     /** @see #getLongUnaligned(Object, long) */
3958     @HotSpotIntrinsicCandidate
3959     public final short getShortUnaligned(Object o, long offset) {
3960         if ((offset &amp; 1) == 0) {
3961             return getShort(o, offset);
3962         } else {
3963             return makeShort(getByte(o, offset),
3964                              getByte(o, offset + 1));
3965         }
3966     }
3967     /** @see #getLongUnaligned(Object, long, boolean) */
3968     public final short getShortUnaligned(Object o, long offset, boolean bigEndian) {
3969         return convEndian(bigEndian, getShortUnaligned(o, offset));
3970     }
3971 
3972     /** @see #getLongUnaligned(Object, long) */
3973     @HotSpotIntrinsicCandidate
3974     public final char getCharUnaligned(Object o, long offset) {
3975         if ((offset &amp; 1) == 0) {
3976             return getChar(o, offset);
3977         } else {
3978             return (char)makeShort(getByte(o, offset),
3979                                    getByte(o, offset + 1));
3980         }
3981     }
3982 
3983     /** @see #getLongUnaligned(Object, long, boolean) */
3984     public final char getCharUnaligned(Object o, long offset, boolean bigEndian) {
3985         return convEndian(bigEndian, getCharUnaligned(o, offset));
3986     }
3987 
3988     /**
3989      * Stores a value at some byte offset into a given Java object.
3990      * &lt;p&gt;
3991      * The specification of this method is the same as {@link
3992      * #getLong(Object, long)} except that the offset does not need to
3993      * have been obtained from {@link #objectFieldOffset} on the
3994      * {@link java.lang.reflect.Field} of some Java field.  The value
3995      * in memory is raw data, and need not correspond to any Java
3996      * variable.  The endianness of the value in memory is the
3997      * endianness of the native platform.
3998      * &lt;p&gt;
3999      * The write will be atomic with respect to the largest power of
4000      * two that divides the GCD of the offset and the storage size.
4001      * For example, putLongUnaligned will make atomic writes of 2-, 4-,
4002      * or 8-byte storage units if the offset is zero mod 2, 4, or 8,
4003      * respectively.  There are no other guarantees of atomicity.
4004      * &lt;p&gt;
4005      * 8-byte atomicity is only guaranteed on platforms on which
4006      * support atomic accesses to longs.
4007      *
4008      * @param o Java heap object in which the value resides, if any, else
4009      *        null
4010      * @param offset The offset in bytes from the start of the object
4011      * @param x the value to store
4012      * @throws RuntimeException No defined exceptions are thrown, not even
4013      *         {@link NullPointerException}
4014      * @since 9
4015      */
4016     @HotSpotIntrinsicCandidate
4017     public final void putLongUnaligned(Object o, long offset, long x) {
4018         if ((offset &amp; 7) == 0) {
4019             putLong(o, offset, x);
4020         } else if ((offset &amp; 3) == 0) {
4021             putLongParts(o, offset,
4022                          (int)(x &gt;&gt; 0),
4023                          (int)(x &gt;&gt;&gt; 32));
4024         } else if ((offset &amp; 1) == 0) {
4025             putLongParts(o, offset,
4026                          (short)(x &gt;&gt;&gt; 0),
4027                          (short)(x &gt;&gt;&gt; 16),
4028                          (short)(x &gt;&gt;&gt; 32),
4029                          (short)(x &gt;&gt;&gt; 48));
4030         } else {
4031             putLongParts(o, offset,
4032                          (byte)(x &gt;&gt;&gt; 0),
4033                          (byte)(x &gt;&gt;&gt; 8),
4034                          (byte)(x &gt;&gt;&gt; 16),
4035                          (byte)(x &gt;&gt;&gt; 24),
4036                          (byte)(x &gt;&gt;&gt; 32),
4037                          (byte)(x &gt;&gt;&gt; 40),
4038                          (byte)(x &gt;&gt;&gt; 48),
4039                          (byte)(x &gt;&gt;&gt; 56));
4040         }
4041     }
4042 
4043     /**
4044      * As {@link #putLongUnaligned(Object, long, long)} but with an additional
4045      * argument which specifies the endianness of the value as stored in memory.
4046      * @param o Java heap object in which the value resides
4047      * @param offset The offset in bytes from the start of the object
4048      * @param x the value to store
4049      * @param bigEndian The endianness of the value
4050      * @throws RuntimeException No defined exceptions are thrown, not even
4051      *         {@link NullPointerException}
4052      * @since 9
4053      */
4054     public final void putLongUnaligned(Object o, long offset, long x, boolean bigEndian) {
4055         putLongUnaligned(o, offset, convEndian(bigEndian, x));
4056     }
4057 
4058     /** @see #putLongUnaligned(Object, long, long) */
4059     @HotSpotIntrinsicCandidate
4060     public final void putIntUnaligned(Object o, long offset, int x) {
4061         if ((offset &amp; 3) == 0) {
4062             putInt(o, offset, x);
4063         } else if ((offset &amp; 1) == 0) {
4064             putIntParts(o, offset,
4065                         (short)(x &gt;&gt; 0),
4066                         (short)(x &gt;&gt;&gt; 16));
4067         } else {
4068             putIntParts(o, offset,
4069                         (byte)(x &gt;&gt;&gt; 0),
4070                         (byte)(x &gt;&gt;&gt; 8),
4071                         (byte)(x &gt;&gt;&gt; 16),
4072                         (byte)(x &gt;&gt;&gt; 24));
4073         }
4074     }
4075     /** @see #putLongUnaligned(Object, long, long, boolean) */
4076     public final void putIntUnaligned(Object o, long offset, int x, boolean bigEndian) {
4077         putIntUnaligned(o, offset, convEndian(bigEndian, x));
4078     }
4079 
4080     /** @see #putLongUnaligned(Object, long, long) */
4081     @HotSpotIntrinsicCandidate
4082     public final void putShortUnaligned(Object o, long offset, short x) {
4083         if ((offset &amp; 1) == 0) {
4084             putShort(o, offset, x);
4085         } else {
4086             putShortParts(o, offset,
4087                           (byte)(x &gt;&gt;&gt; 0),
4088                           (byte)(x &gt;&gt;&gt; 8));
4089         }
4090     }
4091     /** @see #putLongUnaligned(Object, long, long, boolean) */
4092     public final void putShortUnaligned(Object o, long offset, short x, boolean bigEndian) {
4093         putShortUnaligned(o, offset, convEndian(bigEndian, x));
4094     }
4095 
4096     /** @see #putLongUnaligned(Object, long, long) */
4097     @HotSpotIntrinsicCandidate
4098     public final void putCharUnaligned(Object o, long offset, char x) {
4099         putShortUnaligned(o, offset, (short)x);
4100     }
4101     /** @see #putLongUnaligned(Object, long, long, boolean) */
4102     public final void putCharUnaligned(Object o, long offset, char x, boolean bigEndian) {
4103         putCharUnaligned(o, offset, convEndian(bigEndian, x));
4104     }
4105 
4106     private static int pickPos(int top, int pos) { return BIG_ENDIAN ? top - pos : pos; }
4107 
4108     // These methods construct integers from bytes.  The byte ordering
4109     // is the native endianness of this platform.
4110     private static long makeLong(byte i0, byte i1, byte i2, byte i3, byte i4, byte i5, byte i6, byte i7) {
4111         return ((toUnsignedLong(i0) &lt;&lt; pickPos(56, 0))
4112               | (toUnsignedLong(i1) &lt;&lt; pickPos(56, 8))
4113               | (toUnsignedLong(i2) &lt;&lt; pickPos(56, 16))
4114               | (toUnsignedLong(i3) &lt;&lt; pickPos(56, 24))
4115               | (toUnsignedLong(i4) &lt;&lt; pickPos(56, 32))
4116               | (toUnsignedLong(i5) &lt;&lt; pickPos(56, 40))
4117               | (toUnsignedLong(i6) &lt;&lt; pickPos(56, 48))
4118               | (toUnsignedLong(i7) &lt;&lt; pickPos(56, 56)));
4119     }
4120     private static long makeLong(short i0, short i1, short i2, short i3) {
4121         return ((toUnsignedLong(i0) &lt;&lt; pickPos(48, 0))
4122               | (toUnsignedLong(i1) &lt;&lt; pickPos(48, 16))
4123               | (toUnsignedLong(i2) &lt;&lt; pickPos(48, 32))
4124               | (toUnsignedLong(i3) &lt;&lt; pickPos(48, 48)));
4125     }
4126     private static long makeLong(int i0, int i1) {
4127         return (toUnsignedLong(i0) &lt;&lt; pickPos(32, 0))
4128              | (toUnsignedLong(i1) &lt;&lt; pickPos(32, 32));
4129     }
4130     private static int makeInt(short i0, short i1) {
4131         return (toUnsignedInt(i0) &lt;&lt; pickPos(16, 0))
4132              | (toUnsignedInt(i1) &lt;&lt; pickPos(16, 16));
4133     }
4134     private static int makeInt(byte i0, byte i1, byte i2, byte i3) {
4135         return ((toUnsignedInt(i0) &lt;&lt; pickPos(24, 0))
4136               | (toUnsignedInt(i1) &lt;&lt; pickPos(24, 8))
4137               | (toUnsignedInt(i2) &lt;&lt; pickPos(24, 16))
4138               | (toUnsignedInt(i3) &lt;&lt; pickPos(24, 24)));
4139     }
4140     private static short makeShort(byte i0, byte i1) {
4141         return (short)((toUnsignedInt(i0) &lt;&lt; pickPos(8, 0))
4142                      | (toUnsignedInt(i1) &lt;&lt; pickPos(8, 8)));
4143     }
4144 
4145     private static byte  pick(byte  le, byte  be) { return BIG_ENDIAN ? be : le; }
4146     private static short pick(short le, short be) { return BIG_ENDIAN ? be : le; }
4147     private static int   pick(int   le, int   be) { return BIG_ENDIAN ? be : le; }
4148 
4149     // These methods write integers to memory from smaller parts
4150     // provided by their caller.  The ordering in which these parts
4151     // are written is the native endianness of this platform.
4152     private void putLongParts(Object o, long offset, byte i0, byte i1, byte i2, byte i3, byte i4, byte i5, byte i6, byte i7) {
4153         putByte(o, offset + 0, pick(i0, i7));
4154         putByte(o, offset + 1, pick(i1, i6));
4155         putByte(o, offset + 2, pick(i2, i5));
4156         putByte(o, offset + 3, pick(i3, i4));
4157         putByte(o, offset + 4, pick(i4, i3));
4158         putByte(o, offset + 5, pick(i5, i2));
4159         putByte(o, offset + 6, pick(i6, i1));
4160         putByte(o, offset + 7, pick(i7, i0));
4161     }
4162     private void putLongParts(Object o, long offset, short i0, short i1, short i2, short i3) {
4163         putShort(o, offset + 0, pick(i0, i3));
4164         putShort(o, offset + 2, pick(i1, i2));
4165         putShort(o, offset + 4, pick(i2, i1));
4166         putShort(o, offset + 6, pick(i3, i0));
4167     }
4168     private void putLongParts(Object o, long offset, int i0, int i1) {
4169         putInt(o, offset + 0, pick(i0, i1));
4170         putInt(o, offset + 4, pick(i1, i0));
4171     }
4172     private void putIntParts(Object o, long offset, short i0, short i1) {
4173         putShort(o, offset + 0, pick(i0, i1));
4174         putShort(o, offset + 2, pick(i1, i0));
4175     }
4176     private void putIntParts(Object o, long offset, byte i0, byte i1, byte i2, byte i3) {
4177         putByte(o, offset + 0, pick(i0, i3));
4178         putByte(o, offset + 1, pick(i1, i2));
4179         putByte(o, offset + 2, pick(i2, i1));
4180         putByte(o, offset + 3, pick(i3, i0));
4181     }
4182     private void putShortParts(Object o, long offset, byte i0, byte i1) {
4183         putByte(o, offset + 0, pick(i0, i1));
4184         putByte(o, offset + 1, pick(i1, i0));
4185     }
4186 
4187     // Zero-extend an integer
4188     private static int toUnsignedInt(byte n)    { return n &amp; 0xff; }
4189     private static int toUnsignedInt(short n)   { return n &amp; 0xffff; }
4190     private static long toUnsignedLong(byte n)  { return n &amp; 0xffl; }
4191     private static long toUnsignedLong(short n) { return n &amp; 0xffffl; }
4192     private static long toUnsignedLong(int n)   { return n &amp; 0xffffffffl; }
4193 
4194     // Maybe byte-reverse an integer
4195     private static char convEndian(boolean big, char n)   { return big == BIG_ENDIAN ? n : Character.reverseBytes(n); }
4196     private static short convEndian(boolean big, short n) { return big == BIG_ENDIAN ? n : Short.reverseBytes(n)    ; }
4197     private static int convEndian(boolean big, int n)     { return big == BIG_ENDIAN ? n : Integer.reverseBytes(n)  ; }
4198     private static long convEndian(boolean big, long n)   { return big == BIG_ENDIAN ? n : Long.reverseBytes(n)     ; }
4199 
4200 
4201 
4202     private native long allocateMemory0(long bytes);
4203     private native long reallocateMemory0(long address, long bytes);
4204     private native void freeMemory0(long address);
4205     private native void setMemory0(Object o, long offset, long bytes, byte value);
4206     @HotSpotIntrinsicCandidate
4207     private native void copyMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);
4208     private native void copySwapMemory0(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes, long elemSize);
4209     private native long objectFieldOffset0(Field f);
4210     private native long objectFieldOffset1(Class&lt;?&gt; c, String name);
4211     private native long staticFieldOffset0(Field f);
4212     private native Object staticFieldBase0(Field f);
4213     private native boolean shouldBeInitialized0(Class&lt;?&gt; c);
4214     private native void ensureClassInitialized0(Class&lt;?&gt; c);
4215     private native int arrayBaseOffset0(Class&lt;?&gt; arrayClass);
4216     private native int arrayIndexScale0(Class&lt;?&gt; arrayClass);
4217     private native long getObjectSize0(Object o);
4218     private native Class&lt;?&gt; defineAnonymousClass0(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches);
4219     private native int getLoadAverage0(double[] loadavg, int nelems);
4220 
4221 
4222     /**
4223      * Invokes the given direct byte buffer&#39;s cleaner, if any.
4224      *
4225      * @param directBuffer a direct byte buffer
4226      * @throws NullPointerException     if {@code directBuffer} is null
4227      * @throws IllegalArgumentException if {@code directBuffer} is non-direct,
4228      *                                  or is a {@link java.nio.Buffer#slice slice}, or is a
4229      *                                  {@link java.nio.Buffer#duplicate duplicate}
4230      */
4231     public void invokeCleaner(java.nio.ByteBuffer directBuffer) {
4232         if (!directBuffer.isDirect())
4233             throw new IllegalArgumentException(&quot;buffer is non-direct&quot;);
4234 
4235         DirectBuffer db = (DirectBuffer) directBuffer;
4236         if (db.attachment() != null)
4237             throw new IllegalArgumentException(&quot;duplicate or slice&quot;);
4238 
4239         Cleaner cleaner = db.cleaner();
4240         if (cleaner != null) {
4241             cleaner.clean();
4242         }
4243     }
4244 
4245     // The following deprecated methods are used by JSR 166.
4246 
4247     @Deprecated(since=&quot;12&quot;, forRemoval=true)
4248     public final Object getObject(Object o, long offset) {
4249         return getReference(o, offset);
4250     }
4251     @Deprecated(since=&quot;12&quot;, forRemoval=true)
4252     public final Object getObjectVolatile(Object o, long offset) {
4253         return getReferenceVolatile(o, offset);
4254     }
4255     @Deprecated(since=&quot;12&quot;, forRemoval=true)
4256     public final Object getObjectAcquire(Object o, long offset) {
4257         return getReferenceAcquire(o, offset);
4258     }
4259     @Deprecated(since=&quot;12&quot;, forRemoval=true)
4260     public final Object getObjectOpaque(Object o, long offset) {
4261         return getReferenceOpaque(o, offset);
4262     }
4263 
4264 
4265     @Deprecated(since=&quot;12&quot;, forRemoval=true)
4266     public final void putObject(Object o, long offset, Object x) {
4267         putReference(o, offset, x);
4268     }
4269     @Deprecated(since=&quot;12&quot;, forRemoval=true)
4270     public final void putObjectVolatile(Object o, long offset, Object x) {
4271         putReferenceVolatile(o, offset, x);
4272     }
4273     @Deprecated(since=&quot;12&quot;, forRemoval=true)
4274     public final void putObjectOpaque(Object o, long offset, Object x) {
4275         putReferenceOpaque(o, offset, x);
4276     }
4277     @Deprecated(since=&quot;12&quot;, forRemoval=true)
4278     public final void putObjectRelease(Object o, long offset, Object x) {
4279         putReferenceRelease(o, offset, x);
4280     }
4281 
4282 
4283     @Deprecated(since=&quot;12&quot;, forRemoval=true)
4284     public final Object getAndSetObject(Object o, long offset, Object newValue) {
4285         return getAndSetReference(o, offset, newValue);
4286     }
4287     @Deprecated(since=&quot;12&quot;, forRemoval=true)
4288     public final Object getAndSetObjectAcquire(Object o, long offset, Object newValue) {
4289         return getAndSetReferenceAcquire(o, offset, newValue);
4290     }
4291     @Deprecated(since=&quot;12&quot;, forRemoval=true)
4292     public final Object getAndSetObjectRelease(Object o, long offset, Object newValue) {
4293         return getAndSetReferenceRelease(o, offset, newValue);
4294     }
4295 
4296 
4297     @Deprecated(since=&quot;12&quot;, forRemoval=true)
4298     public final boolean compareAndSetObject(Object o, long offset, Object expected, Object x) {
4299         return compareAndSetReference(o, offset, expected, x);
4300     }
4301     @Deprecated(since=&quot;12&quot;, forRemoval=true)
4302     public final Object compareAndExchangeObject(Object o, long offset, Object expected, Object x) {
4303         return compareAndExchangeReference(o, offset, expected, x);
4304     }
4305     @Deprecated(since=&quot;12&quot;, forRemoval=true)
4306     public final Object compareAndExchangeObjectAcquire(Object o, long offset, Object expected, Object x) {
4307         return compareAndExchangeReferenceAcquire(o, offset, expected, x);
4308     }
4309     @Deprecated(since=&quot;12&quot;, forRemoval=true)
4310     public final Object compareAndExchangeObjectRelease(Object o, long offset, Object expected, Object x) {
4311         return compareAndExchangeReferenceRelease(o, offset, expected, x);
4312     }
4313 
4314 
4315     @Deprecated(since=&quot;12&quot;, forRemoval=true)
4316     public final boolean weakCompareAndSetObject(Object o, long offset, Object expected, Object x) {
4317         return weakCompareAndSetReference(o, offset, expected, x);
4318     }
4319     @Deprecated(since=&quot;12&quot;, forRemoval=true)
4320     public final boolean weakCompareAndSetObjectAcquire(Object o, long offset, Object expected, Object x) {
4321         return weakCompareAndSetReferenceAcquire(o, offset, expected, x);
4322     }
4323     @Deprecated(since=&quot;12&quot;, forRemoval=true)
4324     public final boolean weakCompareAndSetObjectPlain(Object o, long offset, Object expected, Object x) {
4325         return weakCompareAndSetReferencePlain(o, offset, expected, x);
4326     }
4327     @Deprecated(since=&quot;12&quot;, forRemoval=true)
4328     public final boolean weakCompareAndSetObjectRelease(Object o, long offset, Object expected, Object x) {
4329         return weakCompareAndSetReferenceRelease(o, offset, expected, x);
4330     }
4331 }
    </pre>
  </body>
</html>
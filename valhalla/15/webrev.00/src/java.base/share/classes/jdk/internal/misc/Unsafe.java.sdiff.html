<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/misc/Unsafe.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../logger/LoggerWrapper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../module/ModuleHashes.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/misc/Unsafe.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 986 
 987         copySwapMemory0(srcBase, srcOffset, destBase, destOffset, bytes, elemSize);
 988     }
 989 
 990     private void copySwapMemoryChecks(Object srcBase, long srcOffset,
 991                                       Object destBase, long destOffset,
 992                                       long bytes, long elemSize) {
 993         checkSize(bytes);
 994 
 995         if (elemSize != 2 &amp;&amp; elemSize != 4 &amp;&amp; elemSize != 8) {
 996             throw invalidInput();
 997         }
 998         if (bytes % elemSize != 0) {
 999             throw invalidInput();
1000         }
1001 
1002         checkPrimitivePointer(srcBase, srcOffset);
1003         checkPrimitivePointer(destBase, destOffset);
1004     }
1005 
<span class="line-modified">1006    /**</span>
1007      * Copies all elements from one block of memory to another block, byte swapping the
1008      * elements on the fly.
1009      *
1010      * This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode, as
1011      * discussed in {@link #getInt(Object,long)}.
1012      *
1013      * Equivalent to {@code copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize)}.
1014      */
1015     public void copySwapMemory(long srcAddress, long destAddress, long bytes, long elemSize) {
1016         copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize);
1017     }
1018 
1019     /**
1020      * Disposes of a block of native memory, as obtained from {@link
1021      * #allocateMemory} or {@link #reallocateMemory}.  The address passed to
1022      * this method may be null, in which case no action is taken.
1023      *
1024      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
1025      * sure arguments are checked before the methods are called. While
1026      * some rudimentary checks are performed on the input, the checks
</pre>
<hr />
<pre>
2545 
2546     /** Acquire version of {@link #getFloatVolatile(Object, long)} */
2547     @HotSpotIntrinsicCandidate
2548     public final float getFloatAcquire(Object o, long offset) {
2549         return getFloatVolatile(o, offset);
2550     }
2551 
2552     /** Acquire version of {@link #getLongVolatile(Object, long)} */
2553     @HotSpotIntrinsicCandidate
2554     public final long getLongAcquire(Object o, long offset) {
2555         return getLongVolatile(o, offset);
2556     }
2557 
2558     /** Acquire version of {@link #getDoubleVolatile(Object, long)} */
2559     @HotSpotIntrinsicCandidate
2560     public final double getDoubleAcquire(Object o, long offset) {
2561         return getDoubleVolatile(o, offset);
2562     }
2563 
2564     /*
<span class="line-modified">2565       * Versions of {@link #putReferenceVolatile(Object, long, Object)}</span>
<span class="line-modified">2566       * that do not guarantee immediate visibility of the store to</span>
<span class="line-modified">2567       * other threads. This method is generally only useful if the</span>
<span class="line-modified">2568       * underlying field is a Java volatile (or if an array cell, one</span>
<span class="line-modified">2569       * that is otherwise only accessed using volatile accesses).</span>
<span class="line-modified">2570       *</span>
<span class="line-modified">2571       * Corresponds to C11 atomic_store_explicit(..., memory_order_release).</span>
<span class="line-modified">2572       */</span>
2573 
2574     /** Release version of {@link #putReferenceVolatile(Object, long, Object)} */
2575     @HotSpotIntrinsicCandidate
2576     public final void putReferenceRelease(Object o, long offset, Object x) {
2577         putReferenceVolatile(o, offset, x);
2578     }
2579 
2580     public final &lt;V&gt; void putValueRelease(Object o, long offset, Class&lt;?&gt; valueType, V x) {
2581         putValueVolatile(o, offset, valueType, x);
2582     }
2583 
2584     /** Release version of {@link #putBooleanVolatile(Object, long, boolean)} */
2585     @HotSpotIntrinsicCandidate
2586     public final void putBooleanRelease(Object o, long offset, boolean x) {
2587         putBooleanVolatile(o, offset, x);
2588     }
2589 
2590     /** Release version of {@link #putByteVolatile(Object, long, byte)} */
2591     @HotSpotIntrinsicCandidate
2592     public final void putByteRelease(Object o, long offset, byte x) {
</pre>
</td>
<td>
<hr />
<pre>
 986 
 987         copySwapMemory0(srcBase, srcOffset, destBase, destOffset, bytes, elemSize);
 988     }
 989 
 990     private void copySwapMemoryChecks(Object srcBase, long srcOffset,
 991                                       Object destBase, long destOffset,
 992                                       long bytes, long elemSize) {
 993         checkSize(bytes);
 994 
 995         if (elemSize != 2 &amp;&amp; elemSize != 4 &amp;&amp; elemSize != 8) {
 996             throw invalidInput();
 997         }
 998         if (bytes % elemSize != 0) {
 999             throw invalidInput();
1000         }
1001 
1002         checkPrimitivePointer(srcBase, srcOffset);
1003         checkPrimitivePointer(destBase, destOffset);
1004     }
1005 
<span class="line-modified">1006     /**</span>
1007      * Copies all elements from one block of memory to another block, byte swapping the
1008      * elements on the fly.
1009      *
1010      * This provides a &lt;em&gt;single-register&lt;/em&gt; addressing mode, as
1011      * discussed in {@link #getInt(Object,long)}.
1012      *
1013      * Equivalent to {@code copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize)}.
1014      */
1015     public void copySwapMemory(long srcAddress, long destAddress, long bytes, long elemSize) {
1016         copySwapMemory(null, srcAddress, null, destAddress, bytes, elemSize);
1017     }
1018 
1019     /**
1020      * Disposes of a block of native memory, as obtained from {@link
1021      * #allocateMemory} or {@link #reallocateMemory}.  The address passed to
1022      * this method may be null, in which case no action is taken.
1023      *
1024      * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make
1025      * sure arguments are checked before the methods are called. While
1026      * some rudimentary checks are performed on the input, the checks
</pre>
<hr />
<pre>
2545 
2546     /** Acquire version of {@link #getFloatVolatile(Object, long)} */
2547     @HotSpotIntrinsicCandidate
2548     public final float getFloatAcquire(Object o, long offset) {
2549         return getFloatVolatile(o, offset);
2550     }
2551 
2552     /** Acquire version of {@link #getLongVolatile(Object, long)} */
2553     @HotSpotIntrinsicCandidate
2554     public final long getLongAcquire(Object o, long offset) {
2555         return getLongVolatile(o, offset);
2556     }
2557 
2558     /** Acquire version of {@link #getDoubleVolatile(Object, long)} */
2559     @HotSpotIntrinsicCandidate
2560     public final double getDoubleAcquire(Object o, long offset) {
2561         return getDoubleVolatile(o, offset);
2562     }
2563 
2564     /*
<span class="line-modified">2565      * Versions of {@link #putReferenceVolatile(Object, long, Object)}</span>
<span class="line-modified">2566      * that do not guarantee immediate visibility of the store to</span>
<span class="line-modified">2567      * other threads. This method is generally only useful if the</span>
<span class="line-modified">2568      * underlying field is a Java volatile (or if an array cell, one</span>
<span class="line-modified">2569      * that is otherwise only accessed using volatile accesses).</span>
<span class="line-modified">2570      *</span>
<span class="line-modified">2571      * Corresponds to C11 atomic_store_explicit(..., memory_order_release).</span>
<span class="line-modified">2572      */</span>
2573 
2574     /** Release version of {@link #putReferenceVolatile(Object, long, Object)} */
2575     @HotSpotIntrinsicCandidate
2576     public final void putReferenceRelease(Object o, long offset, Object x) {
2577         putReferenceVolatile(o, offset, x);
2578     }
2579 
2580     public final &lt;V&gt; void putValueRelease(Object o, long offset, Class&lt;?&gt; valueType, V x) {
2581         putValueVolatile(o, offset, valueType, x);
2582     }
2583 
2584     /** Release version of {@link #putBooleanVolatile(Object, long, boolean)} */
2585     @HotSpotIntrinsicCandidate
2586     public final void putBooleanRelease(Object o, long offset, boolean x) {
2587         putBooleanVolatile(o, offset, x);
2588     }
2589 
2590     /** Release version of {@link #putByteVolatile(Object, long, byte)} */
2591     @HotSpotIntrinsicCandidate
2592     public final void putByteRelease(Object o, long offset, byte x) {
</pre>
</td>
</tr>
</table>
<center><a href="../logger/LoggerWrapper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../module/ModuleHashes.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
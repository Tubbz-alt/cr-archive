<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/SupportedGroupsExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
 30 import java.security.AlgorithmConstraints;
 31 import java.text.MessageFormat;
 32 import java.util.ArrayList;
 33 import java.util.Collections;
 34 import java.util.LinkedList;
 35 import java.util.List;
 36 import java.util.Locale;
 37 import javax.net.ssl.SSLProtocolException;
 38 import sun.security.action.GetPropertyAction;
 39 import sun.security.ssl.NamedGroup.NamedGroupSpec;
 40 import static sun.security.ssl.SSLExtension.CH_SUPPORTED_GROUPS;
 41 import static sun.security.ssl.SSLExtension.EE_SUPPORTED_GROUPS;
 42 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 43 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 44 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 45 
 46 
 47 /**
 48  * Pack of the &quot;supported_groups&quot; extensions [RFC 4492/7919].
 49  */
 50 final class SupportedGroupsExtension {
 51     static final HandshakeProducer chNetworkProducer =
 52             new CHSupportedGroupsProducer();
 53     static final ExtensionConsumer chOnLoadConsumer =
 54             new CHSupportedGroupsConsumer();
 55     static final SSLStringizer sgsStringizer =
 56             new SupportedGroupsStringizer();
 57 
 58     static final HandshakeProducer eeNetworkProducer =
 59             new EESupportedGroupsProducer();
 60     static final ExtensionConsumer eeOnLoadConsumer =
 61             new EESupportedGroupsConsumer();
 62 
 63     /**
 64      * The &quot;supported_groups&quot; extension.
 65      */
 66     static final class SupportedGroupsSpec implements SSLExtensionSpec {
 67         final int[] namedGroupsIds;
 68 
 69         private SupportedGroupsSpec(int[] namedGroupsIds) {
 70             this.namedGroupsIds = namedGroupsIds;
 71         }
 72 
 73         private SupportedGroupsSpec(List&lt;NamedGroup&gt; namedGroups) {
 74             this.namedGroupsIds = new int[namedGroups.size()];
 75             int i = 0;
 76             for (NamedGroup ng : namedGroups) {
 77                 namedGroupsIds[i++] = ng.id;
 78             }
 79         }
 80 
<a name="2" id="anc2"></a><span class="line-modified"> 81         private SupportedGroupsSpec(HandshakeContext hc,</span>
<span class="line-added"> 82                 ByteBuffer m) throws IOException  {</span>
 83             if (m.remaining() &lt; 2) {      // 2: the length of the list
<a name="3" id="anc3"></a><span class="line-modified"> 84                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified"> 85                         new SSLProtocolException(</span>
<span class="line-added"> 86                     &quot;Invalid supported_groups extension: insufficient data&quot;));</span>
 87             }
 88 
 89             byte[] ngs = Record.getBytes16(m);
 90             if (m.hasRemaining()) {
<a name="4" id="anc4"></a><span class="line-modified"> 91                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified"> 92                         new SSLProtocolException(</span>
<span class="line-added"> 93                     &quot;Invalid supported_groups extension: unknown extra data&quot;));</span>
 94             }
 95 
 96             if ((ngs == null) || (ngs.length == 0) || (ngs.length % 2 != 0)) {
<a name="5" id="anc5"></a><span class="line-modified"> 97                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified"> 98                         new SSLProtocolException(</span>
<span class="line-added"> 99                     &quot;Invalid supported_groups extension: incomplete data&quot;));</span>
100             }
101 
102             int[] ids = new int[ngs.length / 2];
103             for (int i = 0, j = 0; i &lt; ngs.length;) {
104                 ids[j++] = ((ngs[i++] &amp; 0xFF) &lt;&lt; 8) | (ngs[i++] &amp; 0xFF);
105             }
106 
107             this.namedGroupsIds = ids;
108         }
109 
110         @Override
111         public String toString() {
112             MessageFormat messageFormat = new MessageFormat(
113                 &quot;\&quot;versions\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
114 
115             if (namedGroupsIds == null || namedGroupsIds.length == 0) {
116                 Object[] messageFields = {
117                         &quot;&lt;no supported named group specified&gt;&quot;
118                     };
119                 return messageFormat.format(messageFields);
120             } else {
121                 StringBuilder builder = new StringBuilder(512);
122                 boolean isFirst = true;
123                 for (int ngid : namedGroupsIds) {
124                     if (isFirst) {
125                         isFirst = false;
126                     } else {
127                         builder.append(&quot;, &quot;);
128                     }
129 
130                     builder.append(NamedGroup.nameOf(ngid));
131                 }
132 
133                 Object[] messageFields = {
134                         builder.toString()
135                     };
136 
137                 return messageFormat.format(messageFields);
138             }
139         }
140     }
141 
142     private static final
143             class SupportedGroupsStringizer implements SSLStringizer {
144         @Override
<a name="6" id="anc6"></a><span class="line-modified">145         public String toString(HandshakeContext hc, ByteBuffer buffer) {</span>
146             try {
<a name="7" id="anc7"></a><span class="line-modified">147                 return (new SupportedGroupsSpec(hc, buffer)).toString();</span>
148             } catch (IOException ioe) {
149                 // For debug logging only, so please swallow exceptions.
150                 return ioe.getMessage();
151             }
152         }
153     }
154 
155     static class SupportedGroups {
156         // To switch off the supported_groups extension for DHE cipher suite.
157         static final boolean enableFFDHE =
158                 Utilities.getBooleanProperty(&quot;jsse.enableFFDHE&quot;, true);
159 
160         // the supported named groups
161         static final NamedGroup[] supportedNamedGroups;
162 
163         static {
164             // The value of the System Property defines a list of enabled named
165             // groups in preference order, separated with comma.  For example:
166             //
167             //      jdk.tls.namedGroups=&quot;secp521r1, secp256r1, ffdhe2048&quot;
168             //
169             // If the System Property is not defined or the value is empty, the
170             // default groups and preferences will be used.
171             String property = GetPropertyAction
172                     .privilegedGetProperty(&quot;jdk.tls.namedGroups&quot;);
173             if (property != null &amp;&amp; !property.isEmpty()) {
174                 // remove double quote marks from beginning/end of the property
175                 if (property.length() &gt; 1 &amp;&amp; property.charAt(0) == &#39;&quot;&#39; &amp;&amp;
176                         property.charAt(property.length() - 1) == &#39;&quot;&#39;) {
177                     property = property.substring(1, property.length() - 1);
178                 }
179             }
180 
181             ArrayList&lt;NamedGroup&gt; groupList;
182             if (property != null &amp;&amp; !property.isEmpty()) {
183                 String[] groups = property.split(&quot;,&quot;);
184                 groupList = new ArrayList&lt;&gt;(groups.length);
185                 for (String group : groups) {
186                     group = group.trim();
187                     if (!group.isEmpty()) {
188                         NamedGroup namedGroup = NamedGroup.nameOf(group);
189                         if (namedGroup != null) {
190                             if (namedGroup.isAvailable) {
191                                 groupList.add(namedGroup);
192                             }
193                         }   // ignore unknown groups
194                     }
195                 }
196 
197                 if (groupList.isEmpty()) {
198                     throw new IllegalArgumentException(
199                             &quot;System property jdk.tls.namedGroups(&quot; +
200                             property + &quot;) contains no supported named groups&quot;);
201                 }
202             } else {        // default groups
203                 NamedGroup[] groups = new NamedGroup[] {
204 
205                         // Primary XDH (RFC 7748) curves
206                         NamedGroup.X25519,
207 
208                         // Primary NIST Suite B curves
209                         NamedGroup.SECP256_R1,
210                         NamedGroup.SECP384_R1,
211                         NamedGroup.SECP521_R1,
212 
213                         // Secondary XDH curves
214                         NamedGroup.X448,
215 
216                         // FFDHE (RFC 7919)
217                         NamedGroup.FFDHE_2048,
218                         NamedGroup.FFDHE_3072,
219                         NamedGroup.FFDHE_4096,
220                         NamedGroup.FFDHE_6144,
221                         NamedGroup.FFDHE_8192,
222                     };
223 
224                 groupList = new ArrayList&lt;&gt;(groups.length);
225                 for (NamedGroup group : groups) {
226                     if (group.isAvailable) {
227                         groupList.add(group);
228                     }
229                 }
230 
231                 if (groupList.isEmpty() &amp;&amp;
232                         SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl&quot;)) {
233                     SSLLogger.warning(&quot;No default named groups&quot;);
234                 }
235             }
236 
237             supportedNamedGroups = new NamedGroup[groupList.size()];
238             int i = 0;
239             for (NamedGroup namedGroup : groupList) {
240                 supportedNamedGroups[i++] = namedGroup;
241             }
242         }
243 
244         // Is there any supported group permitted by the constraints?
245         static boolean isActivatable(
246                 AlgorithmConstraints constraints, NamedGroupSpec type) {
247 
248             boolean hasFFDHEGroups = false;
249             for (NamedGroup namedGroup : supportedNamedGroups) {
250                 if (namedGroup.isAvailable &amp;&amp; namedGroup.spec == type) {
251                     if (namedGroup.isPermitted(constraints)) {
252                         return true;
253                     }
254 
255                     if (!hasFFDHEGroups &amp;&amp;
256                             (type == NamedGroupSpec.NAMED_GROUP_FFDHE)) {
257                         hasFFDHEGroups = true;
258                     }
259                 }
260             }
261 
262             // For compatibility, if no FFDHE groups are defined, the non-FFDHE
263             // compatible mode (using DHE cipher suite without FFDHE extension)
264             // is allowed.
265             //
266             // Note that the constraints checking on DHE parameters will be
267             // performed during key exchanging in a handshake.
268             return !hasFFDHEGroups &amp;&amp; type == NamedGroupSpec.NAMED_GROUP_FFDHE;
269         }
270 
271         // Is the named group permitted by the constraints?
272         static boolean isActivatable(
273                 AlgorithmConstraints constraints, NamedGroup namedGroup) {
274             if (!namedGroup.isAvailable || !isSupported(namedGroup)) {
275                 return false;
276             }
277 
278             return namedGroup.isPermitted(constraints);
279         }
280 
281         // Is the named group supported?
282         static boolean isSupported(NamedGroup namedGroup) {
283             for (NamedGroup group : supportedNamedGroups) {
284                 if (namedGroup.id == group.id) {
285                     return true;
286                 }
287             }
288 
289             return false;
290         }
291 
292         static NamedGroup getPreferredGroup(
293                 ProtocolVersion negotiatedProtocol,
294                 AlgorithmConstraints constraints, NamedGroupSpec[] types,
295                 List&lt;NamedGroup&gt; requestedNamedGroups) {
296             for (NamedGroup namedGroup : requestedNamedGroups) {
297                 if ((NamedGroupSpec.arrayContains(types, namedGroup.spec)) &amp;&amp;
298                         namedGroup.isAvailable(negotiatedProtocol) &amp;&amp;
299                         isSupported(namedGroup) &amp;&amp;
300                         namedGroup.isPermitted(constraints)) {
301                     return namedGroup;
302                 }
303             }
304 
305             return null;
306         }
307 
308         static NamedGroup getPreferredGroup(
309                 ProtocolVersion negotiatedProtocol,
310                 AlgorithmConstraints constraints, NamedGroupSpec[] types) {
311             for (NamedGroup namedGroup : supportedNamedGroups) {
312                 if ((NamedGroupSpec.arrayContains(types, namedGroup.spec)) &amp;&amp;
313                         namedGroup.isAvailable(negotiatedProtocol) &amp;&amp;
314                         namedGroup.isPermitted(constraints)) {
315                     return namedGroup;
316                 }
317             }
318 
319             return null;
320         }
321     }
322 
323     /**
324      * Network data producer of a &quot;supported_groups&quot; extension in
325      * the ClientHello handshake message.
326      */
327     private static final class CHSupportedGroupsProducer
328             extends SupportedGroups implements HandshakeProducer {
329         // Prevent instantiation of this class.
330         private CHSupportedGroupsProducer() {
331             // blank
332         }
333 
334         @Override
335         public byte[] produce(ConnectionContext context,
336                 HandshakeMessage message) throws IOException {
337             // The producing happens in client side only.
338             ClientHandshakeContext chc = (ClientHandshakeContext)context;
339 
340             // Is it a supported and enabled extension?
341             if (!chc.sslConfig.isAvailable(CH_SUPPORTED_GROUPS)) {
342                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
343                     SSLLogger.fine(
344                         &quot;Ignore unavailable supported_groups extension&quot;);
345                 }
346                 return null;
347             }
348 
349             // Produce the extension.
350             ArrayList&lt;NamedGroup&gt; namedGroups =
351                 new ArrayList&lt;&gt;(SupportedGroups.supportedNamedGroups.length);
352             for (NamedGroup ng : SupportedGroups.supportedNamedGroups) {
353                 if ((!SupportedGroups.enableFFDHE) &amp;&amp;
354                     (ng.spec == NamedGroupSpec.NAMED_GROUP_FFDHE)) {
355                     continue;
356                 }
357 
358                 if (ng.isAvailable(chc.activeProtocols) &amp;&amp;
359                         ng.isSupported(chc.activeCipherSuites) &amp;&amp;
360                         ng.isPermitted(chc.algorithmConstraints)) {
361                     namedGroups.add(ng);
362                 } else if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
363                     SSLLogger.fine(
364                         &quot;Ignore inactive or disabled named group: &quot; + ng.name);
365                 }
366             }
367 
368             if (namedGroups.isEmpty()) {
369                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
370                     SSLLogger.warning(&quot;no available named group&quot;);
371                 }
372 
373                 return null;
374             }
375 
376             int vectorLen = namedGroups.size() &lt;&lt; 1;
377             byte[] extData = new byte[vectorLen + 2];
378             ByteBuffer m = ByteBuffer.wrap(extData);
379             Record.putInt16(m, vectorLen);
380             for (NamedGroup namedGroup : namedGroups) {
381                     Record.putInt16(m, namedGroup.id);
382             }
383 
384             // Update the context.
385             chc.clientRequestedNamedGroups =
386                     Collections.&lt;NamedGroup&gt;unmodifiableList(namedGroups);
387             chc.handshakeExtensions.put(CH_SUPPORTED_GROUPS,
388                     new SupportedGroupsSpec(namedGroups));
389 
390             return extData;
391         }
392     }
393 
394     /**
395      * Network data producer of a &quot;supported_groups&quot; extension in
396      * the ClientHello handshake message.
397      */
398     private static final
399             class CHSupportedGroupsConsumer implements ExtensionConsumer {
400         // Prevent instantiation of this class.
401         private CHSupportedGroupsConsumer() {
402             // blank
403         }
404 
405         @Override
406         public void consume(ConnectionContext context,
407             HandshakeMessage message, ByteBuffer buffer) throws IOException {
408             // The consuming happens in server side only.
409             ServerHandshakeContext shc = (ServerHandshakeContext)context;
410 
411             // Is it a supported and enabled extension?
412             if (!shc.sslConfig.isAvailable(CH_SUPPORTED_GROUPS)) {
413                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
414                     SSLLogger.fine(
415                         &quot;Ignore unavailable supported_groups extension&quot;);
416                 }
417                 return;     // ignore the extension
418             }
419 
420             // Parse the extension.
<a name="8" id="anc8"></a><span class="line-modified">421             SupportedGroupsSpec spec = new SupportedGroupsSpec(shc, buffer);</span>





422 
423             // Update the context.
424             List&lt;NamedGroup&gt; knownNamedGroups = new LinkedList&lt;&gt;();
425             for (int id : spec.namedGroupsIds) {
426                 NamedGroup ng = NamedGroup.valueOf(id);
427                 if (ng != null) {
428                     knownNamedGroups.add(ng);
429                 }
430             }
431 
432             shc.clientRequestedNamedGroups = knownNamedGroups;
433             shc.handshakeExtensions.put(CH_SUPPORTED_GROUPS, spec);
434 
435             // No impact on session resumption.
436         }
437     }
438 
439     /**
440      * Network data producer of a &quot;supported_groups&quot; extension in
441      * the EncryptedExtensions handshake message.
442      */
443     private static final class EESupportedGroupsProducer
444             extends SupportedGroups implements HandshakeProducer {
445 
446         // Prevent instantiation of this class.
447         private EESupportedGroupsProducer() {
448             // blank
449         }
450 
451         @Override
452         public byte[] produce(ConnectionContext context,
453                 HandshakeMessage message) throws IOException {
454             // The producing happens in server side only.
455             ServerHandshakeContext shc = (ServerHandshakeContext)context;
456 
457             // Is it a supported and enabled extension?
458             if (!shc.sslConfig.isAvailable(EE_SUPPORTED_GROUPS)) {
459                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
460                     SSLLogger.fine(
461                         &quot;Ignore unavailable supported_groups extension&quot;);
462                 }
463                 return null;
464             }
465 
466             // Produce the extension.
467             //
468             // Contains all groups the server supports, regardless of whether
469             // they are currently supported by the client.
470             ArrayList&lt;NamedGroup&gt; namedGroups = new ArrayList&lt;&gt;(
471                     SupportedGroups.supportedNamedGroups.length);
472             for (NamedGroup ng : SupportedGroups.supportedNamedGroups) {
473                 if ((!SupportedGroups.enableFFDHE) &amp;&amp;
474                     (ng.spec == NamedGroupSpec.NAMED_GROUP_FFDHE)) {
475                     continue;
476                 }
477 
478                 if (ng.isAvailable(shc.activeProtocols) &amp;&amp;
479                         ng.isSupported(shc.activeCipherSuites) &amp;&amp;
480                         ng.isPermitted(shc.algorithmConstraints)) {
481                     namedGroups.add(ng);
482                 } else if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
483                     SSLLogger.fine(
484                         &quot;Ignore inactive or disabled named group: &quot; + ng.name);
485                 }
486             }
487 
488             if (namedGroups.isEmpty()) {
489                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
490                     SSLLogger.warning(&quot;no available named group&quot;);
491                 }
492 
493                 return null;
494             }
495 
496             int vectorLen = namedGroups.size() &lt;&lt; 1;
497             byte[] extData = new byte[vectorLen + 2];
498             ByteBuffer m = ByteBuffer.wrap(extData);
499             Record.putInt16(m, vectorLen);
500             for (NamedGroup namedGroup : namedGroups) {
501                     Record.putInt16(m, namedGroup.id);
502             }
503 
504             // Update the context.
505             shc.conContext.serverRequestedNamedGroups =
506                     Collections.&lt;NamedGroup&gt;unmodifiableList(namedGroups);
507             SupportedGroupsSpec spec = new SupportedGroupsSpec(namedGroups);
508             shc.handshakeExtensions.put(EE_SUPPORTED_GROUPS, spec);
509 
510             return extData;
511         }
512     }
513 
514     private static final
515             class EESupportedGroupsConsumer implements ExtensionConsumer {
516         // Prevent instantiation of this class.
517         private EESupportedGroupsConsumer() {
518             // blank
519         }
520 
521         @Override
522         public void consume(ConnectionContext context,
523             HandshakeMessage message, ByteBuffer buffer) throws IOException {
524             // The consuming happens in client side only.
525             ClientHandshakeContext chc = (ClientHandshakeContext)context;
526 
527             // Is it a supported and enabled extension?
528             if (!chc.sslConfig.isAvailable(EE_SUPPORTED_GROUPS)) {
529                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
530                     SSLLogger.fine(
531                         &quot;Ignore unavailable supported_groups extension&quot;);
532                 }
533                 return;     // ignore the extension
534             }
535 
536             // Parse the extension.
<a name="9" id="anc9"></a><span class="line-modified">537             SupportedGroupsSpec spec = new SupportedGroupsSpec(chc, buffer);</span>





538 
539             // Update the context.
540             List&lt;NamedGroup&gt; knownNamedGroups =
541                     new ArrayList&lt;&gt;(spec.namedGroupsIds.length);
542             for (int id : spec.namedGroupsIds) {
543                 NamedGroup ng = NamedGroup.valueOf(id);
544                 if (ng != null) {
545                     knownNamedGroups.add(ng);
546                 }
547             }
548 
549             chc.conContext.serverRequestedNamedGroups = knownNamedGroups;
550             chc.handshakeExtensions.put(EE_SUPPORTED_GROUPS, spec);
551 
552             // No impact on session resumption.
553         }
554     }
555 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
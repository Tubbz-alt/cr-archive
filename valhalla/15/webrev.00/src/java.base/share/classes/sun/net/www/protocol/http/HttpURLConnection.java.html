<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/net/www/protocol/http/HttpURLConnection.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.net.www.protocol.http;
  27 
  28 import java.security.PrivilegedAction;
  29 import java.util.Arrays;
  30 import java.net.URL;
  31 import java.net.URLConnection;
  32 import java.net.ProtocolException;
  33 import java.net.HttpRetryException;
  34 import java.net.PasswordAuthentication;
  35 import java.net.Authenticator;
  36 import java.net.HttpCookie;
  37 import java.net.InetAddress;
  38 import java.net.UnknownHostException;
  39 import java.net.SocketTimeoutException;
  40 import java.net.SocketPermission;
  41 import java.net.Proxy;
  42 import java.net.ProxySelector;
  43 import java.net.URI;
  44 import java.net.InetSocketAddress;
  45 import java.net.CookieHandler;
  46 import java.net.ResponseCache;
  47 import java.net.CacheResponse;
  48 import java.net.SecureCacheResponse;
  49 import java.net.CacheRequest;
  50 import java.net.URLPermission;
  51 import java.net.Authenticator.RequestorType;
  52 import java.security.AccessController;
  53 import java.security.PrivilegedExceptionAction;
  54 import java.security.PrivilegedActionException;
  55 import java.io.*;
  56 import java.util.ArrayList;
  57 import java.util.Collections;
  58 import java.util.Date;
  59 import java.util.Map;
  60 import java.util.List;
  61 import java.util.Locale;
  62 import java.util.StringTokenizer;
  63 import java.util.Iterator;
  64 import java.util.HashSet;
  65 import java.util.HashMap;
  66 import java.util.Set;
  67 import java.util.StringJoiner;
  68 import jdk.internal.access.JavaNetHttpCookieAccess;
  69 import jdk.internal.access.SharedSecrets;
  70 import sun.net.*;
  71 import sun.net.util.IPAddressUtil;
  72 import sun.net.www.*;
  73 import sun.net.www.http.HttpClient;
  74 import sun.net.www.http.PosterOutputStream;
  75 import sun.net.www.http.ChunkedInputStream;
  76 import sun.net.www.http.ChunkedOutputStream;
  77 import sun.util.logging.PlatformLogger;
  78 import java.text.SimpleDateFormat;
  79 import java.util.TimeZone;
  80 import java.net.MalformedURLException;
  81 import java.nio.ByteBuffer;
  82 import java.util.Objects;
  83 import java.util.Properties;
  84 import static sun.net.www.protocol.http.AuthScheme.BASIC;
  85 import static sun.net.www.protocol.http.AuthScheme.DIGEST;
  86 import static sun.net.www.protocol.http.AuthScheme.NTLM;
  87 import static sun.net.www.protocol.http.AuthScheme.NEGOTIATE;
  88 import static sun.net.www.protocol.http.AuthScheme.KERBEROS;
  89 import static sun.net.www.protocol.http.AuthScheme.UNKNOWN;
  90 import sun.security.action.GetIntegerAction;
  91 import sun.security.action.GetPropertyAction;
  92 
  93 /**
  94  * A class to represent an HTTP connection to a remote object.
  95  */
  96 
  97 
  98 public class HttpURLConnection extends java.net.HttpURLConnection {
  99 
 100     static String HTTP_CONNECT = &quot;CONNECT&quot;;
 101 
 102     static final String version;
 103     public static final String userAgent;
 104 
 105     /* max # of allowed re-directs */
 106     static final int defaultmaxRedirects = 20;
 107     static final int maxRedirects;
 108 
 109     /* Not all servers support the (Proxy)-Authentication-Info headers.
 110      * By default, we don&#39;t require them to be sent
 111      */
 112     static final boolean validateProxy;
 113     static final boolean validateServer;
 114 
 115     /** A, possibly empty, set of authentication schemes that are disabled
 116      *  when proxying plain HTTP ( not HTTPS ). */
 117     static final Set&lt;String&gt; disabledProxyingSchemes;
 118 
 119     /** A, possibly empty, set of authentication schemes that are disabled
 120      *  when setting up a tunnel for HTTPS ( HTTP CONNECT ). */
 121     static final Set&lt;String&gt; disabledTunnelingSchemes;
 122 
 123     private StreamingOutputStream strOutputStream;
 124     private static final String RETRY_MSG1 =
 125         &quot;cannot retry due to proxy authentication, in streaming mode&quot;;
 126     private static final String RETRY_MSG2 =
 127         &quot;cannot retry due to server authentication, in streaming mode&quot;;
 128     private static final String RETRY_MSG3 =
 129         &quot;cannot retry due to redirection, in streaming mode&quot;;
 130 
 131     /*
 132      * System properties related to error stream handling:
 133      *
 134      * sun.net.http.errorstream.enableBuffering = &lt;boolean&gt;
 135      *
 136      * With the above system property set to true (default is false),
 137      * when the response code is &gt;=400, the HTTP handler will try to
 138      * buffer the response body (up to a certain amount and within a
 139      * time limit). Thus freeing up the underlying socket connection
 140      * for reuse. The rationale behind this is that usually when the
 141      * server responds with a &gt;=400 error (client error or server
 142      * error, such as 404 file not found), the server will send a
 143      * small response body to explain who to contact and what to do to
 144      * recover. With this property set to true, even if the
 145      * application doesn&#39;t call getErrorStream(), read the response
 146      * body, and then call close(), the underlying socket connection
 147      * can still be kept-alive and reused. The following two system
 148      * properties provide further control to the error stream
 149      * buffering behaviour.
 150      *
 151      * sun.net.http.errorstream.timeout = &lt;int&gt;
 152      *     the timeout (in millisec) waiting the error stream
 153      *     to be buffered; default is 300 ms
 154      *
 155      * sun.net.http.errorstream.bufferSize = &lt;int&gt;
 156      *     the size (in bytes) to use for the buffering the error stream;
 157      *     default is 4k
 158      */
 159 
 160 
 161     /* Should we enable buffering of error streams? */
 162     private static boolean enableESBuffer = false;
 163 
 164     /* timeout waiting for read for buffered error stream;
 165      */
 166     private static int timeout4ESBuffer = 0;
 167 
 168     /* buffer size for buffered error stream;
 169     */
 170     private static int bufSize4ES = 0;
 171 
 172     /*
 173      * Restrict setting of request headers through the public api
 174      * consistent with JavaScript XMLHttpRequest2 with a few
 175      * exceptions. Disallowed headers are silently ignored for
 176      * backwards compatibility reasons rather than throwing a
 177      * SecurityException. For example, some applets set the
 178      * Host header since old JREs did not implement HTTP 1.1.
 179      * Additionally, any header starting with Sec- is
 180      * disallowed.
 181      *
 182      * The following headers are allowed for historical reasons:
 183      *
 184      * Accept-Charset, Accept-Encoding, Cookie, Cookie2, Date,
 185      * Referer, TE, User-Agent, headers beginning with Proxy-.
 186      *
 187      * The following headers are allowed in a limited form:
 188      *
 189      * Connection: close
 190      *
 191      * See http://www.w3.org/TR/XMLHttpRequest2.
 192      */
 193     private static final boolean allowRestrictedHeaders;
 194     private static final Set&lt;String&gt; restrictedHeaderSet;
 195     private static final String[] restrictedHeaders = {
 196         /* Restricted by XMLHttpRequest2 */
 197         //&quot;Accept-Charset&quot;,
 198         //&quot;Accept-Encoding&quot;,
 199         &quot;Access-Control-Request-Headers&quot;,
 200         &quot;Access-Control-Request-Method&quot;,
 201         &quot;Connection&quot;, /* close is allowed */
 202         &quot;Content-Length&quot;,
 203         //&quot;Cookie&quot;,
 204         //&quot;Cookie2&quot;,
 205         &quot;Content-Transfer-Encoding&quot;,
 206         //&quot;Date&quot;,
 207         //&quot;Expect&quot;,
 208         &quot;Host&quot;,
 209         &quot;Keep-Alive&quot;,
 210         &quot;Origin&quot;,
 211         // &quot;Referer&quot;,
 212         // &quot;TE&quot;,
 213         &quot;Trailer&quot;,
 214         &quot;Transfer-Encoding&quot;,
 215         &quot;Upgrade&quot;,
 216         //&quot;User-Agent&quot;,
 217         &quot;Via&quot;
 218     };
 219 
 220     private static String getNetProperty(String name) {
 221         PrivilegedAction&lt;String&gt; pa = () -&gt; NetProperties.get(name);
 222         return AccessController.doPrivileged(pa);
 223     }
 224 
 225     private static Set&lt;String&gt; schemesListToSet(String list) {
 226         if (list == null || list.isEmpty())
 227             return Collections.emptySet();
 228 
 229         Set&lt;String&gt; s = new HashSet&lt;&gt;();
 230         String[] parts = list.split(&quot;\\s*,\\s*&quot;);
 231         for (String part : parts)
 232             s.add(part.toLowerCase(Locale.ROOT));
 233         return s;
 234     }
 235 
 236     static {
 237         Properties props = GetPropertyAction.privilegedGetProperties();
 238         maxRedirects = GetIntegerAction.privilegedGetProperty(
 239                 &quot;http.maxRedirects&quot;, defaultmaxRedirects);
 240         version = props.getProperty(&quot;java.version&quot;);
 241         String agent = props.getProperty(&quot;http.agent&quot;);
 242         if (agent == null) {
 243             agent = &quot;Java/&quot;+version;
 244         } else {
 245             agent = agent + &quot; Java/&quot;+version;
 246         }
 247         userAgent = agent;
 248 
 249         // A set of net properties to control the use of authentication schemes
 250         // when proxying/tunneling.
 251         String p = getNetProperty(&quot;jdk.http.auth.tunneling.disabledSchemes&quot;);
 252         disabledTunnelingSchemes = schemesListToSet(p);
 253         p = getNetProperty(&quot;jdk.http.auth.proxying.disabledSchemes&quot;);
 254         disabledProxyingSchemes = schemesListToSet(p);
 255 
 256         validateProxy = Boolean.parseBoolean(
 257                 props.getProperty(&quot;http.auth.digest.validateProxy&quot;));
 258         validateServer = Boolean.parseBoolean(
 259                 props.getProperty(&quot;http.auth.digest.validateServer&quot;));
 260 
 261         enableESBuffer = Boolean.parseBoolean(
 262                 props.getProperty(&quot;sun.net.http.errorstream.enableBuffering&quot;));
 263         timeout4ESBuffer = GetIntegerAction.privilegedGetProperty(
 264                 &quot;sun.net.http.errorstream.timeout&quot;, 300);
 265         if (timeout4ESBuffer &lt;= 0) {
 266             timeout4ESBuffer = 300; // use the default
 267         }
 268 
 269         bufSize4ES = GetIntegerAction.privilegedGetProperty(
 270                 &quot;sun.net.http.errorstream.bufferSize&quot;, 4096);
 271         if (bufSize4ES &lt;= 0) {
 272             bufSize4ES = 4096; // use the default
 273         }
 274 
 275         allowRestrictedHeaders = Boolean.parseBoolean(
 276                 props.getProperty(&quot;sun.net.http.allowRestrictedHeaders&quot;));
 277         if (!allowRestrictedHeaders) {
 278             restrictedHeaderSet = new HashSet&lt;&gt;(restrictedHeaders.length);
 279             for (int i=0; i &lt; restrictedHeaders.length; i++) {
 280                 restrictedHeaderSet.add(restrictedHeaders[i].toLowerCase());
 281             }
 282         } else {
 283             restrictedHeaderSet = null;
 284         }
 285     }
 286 
 287     static final String httpVersion = &quot;HTTP/1.1&quot;;
 288     static final String acceptString =
 289         &quot;text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2&quot;;
 290 
 291     // the following http request headers should NOT have their values
 292     // returned for security reasons.
 293     private static final String[] EXCLUDE_HEADERS = {
 294             &quot;Proxy-Authorization&quot;,
 295             &quot;Authorization&quot;
 296     };
 297 
 298     // also exclude system cookies when any might be set
 299     private static final String[] EXCLUDE_HEADERS2= {
 300             &quot;Proxy-Authorization&quot;,
 301             &quot;Authorization&quot;,
 302             &quot;Cookie&quot;,
 303             &quot;Cookie2&quot;
 304     };
 305 
 306     protected HttpClient http;
 307     protected Handler handler;
 308     protected Proxy instProxy;
 309     protected volatile Authenticator authenticator;
 310     protected volatile String authenticatorKey;
 311 
 312     private CookieHandler cookieHandler;
 313     private final ResponseCache cacheHandler;
 314 
 315     private volatile boolean usingProxy;
 316 
 317     // the cached response, and cached response headers and body
 318     protected CacheResponse cachedResponse;
 319     private MessageHeader cachedHeaders;
 320     private InputStream cachedInputStream;
 321 
 322     /* output stream to server */
 323     protected PrintStream ps = null;
 324 
 325     /* buffered error stream */
 326     private InputStream errorStream = null;
 327 
 328     /* User set Cookies */
 329     private boolean setUserCookies = true;
 330     private String userCookies = null;
 331     private String userCookies2 = null;
 332 
 333     /* We only have a single static authenticator for now.
 334      * REMIND:  backwards compatibility with JDK 1.1.  Should be
 335      * eliminated for JDK 2.0.
 336      */
 337     @Deprecated
 338     private static HttpAuthenticator defaultAuth;
 339 
 340     /* all the headers we send
 341      * NOTE: do *NOT* dump out the content of &#39;requests&#39; in the
 342      * output or stacktrace since it may contain security-sensitive
 343      * headers such as those defined in EXCLUDE_HEADERS.
 344      */
 345     private MessageHeader requests;
 346 
 347     /* The headers actually set by the user are recorded here also
 348      */
 349     private MessageHeader userHeaders;
 350 
 351     /* Headers and request method cannot be changed
 352      * once this flag is set in :-
 353      *     - getOutputStream()
 354      *     - getInputStream())
 355      *     - connect()
 356      * Access synchronized on this.
 357      */
 358     private boolean connecting = false;
 359 
 360     /* The following two fields are only used with Digest Authentication */
 361     String domain;      /* The list of authentication domains */
 362     DigestAuthentication.Parameters digestparams;
 363 
 364     /* Current credentials in use */
 365     AuthenticationInfo  currentProxyCredentials = null;
 366     AuthenticationInfo  currentServerCredentials = null;
 367     boolean             needToCheck = true;
 368     private boolean doingNTLM2ndStage = false; /* doing the 2nd stage of an NTLM server authentication */
 369     private boolean doingNTLMp2ndStage = false; /* doing the 2nd stage of an NTLM proxy authentication */
 370 
 371     /* try auth without calling Authenticator. Used for transparent NTLM authentication */
 372     private boolean tryTransparentNTLMServer = true;
 373     private boolean tryTransparentNTLMProxy = true;
 374     private boolean useProxyResponseCode = false;
 375 
 376     /* Used by Windows specific code */
 377     private Object authObj;
 378 
 379     /* Set if the user is manually setting the Authorization or Proxy-Authorization headers */
 380     boolean isUserServerAuth;
 381     boolean isUserProxyAuth;
 382 
 383     String serverAuthKey, proxyAuthKey;
 384 
 385     /* Progress source */
 386     protected ProgressSource pi;
 387 
 388     /* all the response headers we get back */
 389     private MessageHeader responses;
 390     /* the stream _from_ the server */
 391     private InputStream inputStream = null;
 392     /* post stream _to_ the server, if any */
 393     private PosterOutputStream poster = null;
 394 
 395     /* Indicates if the std. request headers have been set in requests. */
 396     private boolean setRequests=false;
 397 
 398     /* Indicates whether a request has already failed or not */
 399     private boolean failedOnce=false;
 400 
 401     /* Remembered Exception, we will throw it again if somebody
 402        calls getInputStream after disconnect */
 403     private Exception rememberedException = null;
 404 
 405     /* If we decide we want to reuse a client, we put it here */
 406     private HttpClient reuseClient = null;
 407 
 408     /* Tunnel states */
 409     public enum TunnelState {
 410         /* No tunnel */
 411         NONE,
 412 
 413         /* Setting up a tunnel */
 414         SETUP,
 415 
 416         /* Tunnel has been successfully setup */
 417         TUNNELING
 418     }
 419 
 420     private TunnelState tunnelState = TunnelState.NONE;
 421 
 422     /* Redefine timeouts from java.net.URLConnection as we need -1 to mean
 423      * not set. This is to ensure backward compatibility.
 424      */
 425     private int connectTimeout = NetworkClient.DEFAULT_CONNECT_TIMEOUT;
 426     private int readTimeout = NetworkClient.DEFAULT_READ_TIMEOUT;
 427 
 428     /* A permission converted from a URLPermission */
 429     private SocketPermission socketPermission;
 430 
 431     /* Logging support */
 432     private static final PlatformLogger logger =
 433             PlatformLogger.getLogger(&quot;sun.net.www.protocol.http.HttpURLConnection&quot;);
 434 
 435     /*
 436      * privileged request password authentication
 437      *
 438      */
 439     private static PasswordAuthentication
 440     privilegedRequestPasswordAuthentication(
 441                             final Authenticator authenticator,
 442                             final String host,
 443                             final InetAddress addr,
 444                             final int port,
 445                             final String protocol,
 446                             final String prompt,
 447                             final String scheme,
 448                             final URL url,
 449                             final RequestorType authType) {
 450         return java.security.AccessController.doPrivileged(
 451             new java.security.PrivilegedAction&lt;&gt;() {
 452                 public PasswordAuthentication run() {
 453                     if (logger.isLoggable(PlatformLogger.Level.FINEST)) {
 454                         logger.finest(&quot;Requesting Authentication: host =&quot; + host + &quot; url = &quot; + url);
 455                     }
 456                     PasswordAuthentication pass = Authenticator.requestPasswordAuthentication(
 457                         authenticator, host, addr, port, protocol,
 458                         prompt, scheme, url, authType);
 459                     if (logger.isLoggable(PlatformLogger.Level.FINEST)) {
 460                         logger.finest(&quot;Authentication returned: &quot; + (pass != null ? pass.toString() : &quot;null&quot;));
 461                     }
 462                     return pass;
 463                 }
 464             });
 465     }
 466 
 467     private boolean isRestrictedHeader(String key, String value) {
 468         if (allowRestrictedHeaders) {
 469             return false;
 470         }
 471 
 472         key = key.toLowerCase();
 473         if (restrictedHeaderSet.contains(key)) {
 474             /*
 475              * Exceptions to restricted headers:
 476              *
 477              * Allow &quot;Connection: close&quot;.
 478              */
 479             if (key.equals(&quot;connection&quot;) &amp;&amp; value.equalsIgnoreCase(&quot;close&quot;)) {
 480                 return false;
 481             }
 482             return true;
 483         } else if (key.startsWith(&quot;sec-&quot;)) {
 484             return true;
 485         }
 486         return false;
 487     }
 488 
 489     /*
 490      * Checks the validity of http message header and whether the header
 491      * is restricted and throws IllegalArgumentException if invalid or
 492      * restricted.
 493      */
 494     private boolean isExternalMessageHeaderAllowed(String key, String value) {
 495         checkMessageHeader(key, value);
 496         if (!isRestrictedHeader(key, value)) {
 497             return true;
 498         }
 499         return false;
 500     }
 501 
 502     /* Logging support */
 503     public static PlatformLogger getHttpLogger() {
 504         return logger;
 505     }
 506 
 507     /* Used for Windows NTLM implementation */
 508     public Object authObj() {
 509         return authObj;
 510     }
 511 
 512     public void authObj(Object authObj) {
 513         this.authObj = authObj;
 514     }
 515 
 516     @Override
 517     public synchronized void setAuthenticator(Authenticator auth) {
 518         if (connecting || connected) {
 519             throw new IllegalStateException(
 520                   &quot;Authenticator must be set before connecting&quot;);
 521         }
 522         authenticator = Objects.requireNonNull(auth);
 523         authenticatorKey = AuthenticatorKeys.getKey(authenticator);
 524     }
 525 
 526     public String getAuthenticatorKey() {
 527         String k = authenticatorKey;
 528         if (k == null) return AuthenticatorKeys.getKey(authenticator);
 529         return k;
 530     }
 531 
 532     /*
 533      * checks the validity of http message header and throws
 534      * IllegalArgumentException if invalid.
 535      */
 536     private void checkMessageHeader(String key, String value) {
 537         char LF = &#39;\n&#39;;
 538         int index = key.indexOf(LF);
 539         int index1 = key.indexOf(&#39;:&#39;);
 540         if (index != -1 || index1 != -1) {
 541             throw new IllegalArgumentException(
 542                 &quot;Illegal character(s) in message header field: &quot; + key);
 543         }
 544         else {
 545             if (value == null) {
 546                 return;
 547             }
 548 
 549             index = value.indexOf(LF);
 550             while (index != -1) {
 551                 index++;
 552                 if (index &lt; value.length()) {
 553                     char c = value.charAt(index);
 554                     if ((c==&#39; &#39;) || (c==&#39;\t&#39;)) {
 555                         // ok, check the next occurrence
 556                         index = value.indexOf(LF, index);
 557                         continue;
 558                     }
 559                 }
 560                 throw new IllegalArgumentException(
 561                     &quot;Illegal character(s) in message header value: &quot; + value);
 562             }
 563         }
 564     }
 565 
 566     public synchronized void setRequestMethod(String method)
 567                         throws ProtocolException {
 568         if (connecting) {
 569             throw new IllegalStateException(&quot;connect in progress&quot;);
 570         }
 571         super.setRequestMethod(method);
 572     }
 573 
 574     /* adds the standard key/val pairs to reqests if necessary &amp; write to
 575      * given PrintStream
 576      */
 577     private void writeRequests() throws IOException {
 578         /* print all message headers in the MessageHeader
 579          * onto the wire - all the ones we&#39;ve set and any
 580          * others that have been set
 581          */
 582         // send any pre-emptive authentication
 583         if (http.usingProxy &amp;&amp; tunnelState() != TunnelState.TUNNELING) {
 584             setPreemptiveProxyAuthentication(requests);
 585         }
 586         if (!setRequests) {
 587 
 588             /* We&#39;re very particular about the order in which we
 589              * set the request headers here.  The order should not
 590              * matter, but some careless CGI programs have been
 591              * written to expect a very particular order of the
 592              * standard headers.  To name names, the order in which
 593              * Navigator3.0 sends them.  In particular, we make *sure*
 594              * to send Content-type: &lt;&gt; and Content-length:&lt;&gt; second
 595              * to last and last, respectively, in the case of a POST
 596              * request.
 597              */
 598             if (!failedOnce) {
 599                 checkURLFile();
 600                 requests.prepend(method + &quot; &quot; + getRequestURI()+&quot; &quot;  +
 601                                  httpVersion, null);
 602             }
 603             if (!getUseCaches()) {
 604                 requests.setIfNotSet (&quot;Cache-Control&quot;, &quot;no-cache&quot;);
 605                 requests.setIfNotSet (&quot;Pragma&quot;, &quot;no-cache&quot;);
 606             }
 607             requests.setIfNotSet(&quot;User-Agent&quot;, userAgent);
 608             int port = url.getPort();
 609             String host = stripIPv6ZoneId(url.getHost());
 610             if (port != -1 &amp;&amp; port != url.getDefaultPort()) {
 611                 host += &quot;:&quot; + String.valueOf(port);
 612             }
 613             String reqHost = requests.findValue(&quot;Host&quot;);
 614             if (reqHost == null ||
 615                 (!reqHost.equalsIgnoreCase(host) &amp;&amp; !checkSetHost()))
 616             {
 617                 requests.set(&quot;Host&quot;, host);
 618             }
 619             requests.setIfNotSet(&quot;Accept&quot;, acceptString);
 620 
 621             /*
 622              * For HTTP/1.1 the default behavior is to keep connections alive.
 623              * However, we may be talking to a 1.0 server so we should set
 624              * keep-alive just in case, except if we have encountered an error
 625              * or if keep alive is disabled via a system property
 626              */
 627 
 628             // Try keep-alive only on first attempt
 629             if (!failedOnce &amp;&amp; http.getHttpKeepAliveSet()) {
 630                 if (http.usingProxy &amp;&amp; tunnelState() != TunnelState.TUNNELING) {
 631                     requests.setIfNotSet(&quot;Proxy-Connection&quot;, &quot;keep-alive&quot;);
 632                 } else {
 633                     requests.setIfNotSet(&quot;Connection&quot;, &quot;keep-alive&quot;);
 634                 }
 635             } else {
 636                 /*
 637                  * RFC 2616 HTTP/1.1 section 14.10 says:
 638                  * HTTP/1.1 applications that do not support persistent
 639                  * connections MUST include the &quot;close&quot; connection option
 640                  * in every message
 641                  */
 642                 requests.setIfNotSet(&quot;Connection&quot;, &quot;close&quot;);
 643             }
 644             // Set modified since if necessary
 645             long modTime = getIfModifiedSince();
 646             if (modTime != 0 ) {
 647                 Date date = new Date(modTime);
 648                 //use the preferred date format according to RFC 2068(HTTP1.1),
 649                 // RFC 822 and RFC 1123
 650                 SimpleDateFormat fo =
 651                   new SimpleDateFormat (&quot;EEE, dd MMM yyyy HH:mm:ss &#39;GMT&#39;&quot;, Locale.US);
 652                 fo.setTimeZone(TimeZone.getTimeZone(&quot;GMT&quot;));
 653                 requests.setIfNotSet(&quot;If-Modified-Since&quot;, fo.format(date));
 654             }
 655             // check for preemptive authorization
 656             AuthenticationInfo sauth = AuthenticationInfo.getServerAuth(url,
 657                                              getAuthenticatorKey());
 658             if (sauth != null &amp;&amp; sauth.supportsPreemptiveAuthorization() ) {
 659                 // Sets &quot;Authorization&quot;
 660                 requests.setIfNotSet(sauth.getHeaderName(), sauth.getHeaderValue(url,method));
 661                 currentServerCredentials = sauth;
 662             }
 663 
 664             if (!method.equals(&quot;PUT&quot;) &amp;&amp; (poster != null || streaming())) {
 665                 requests.setIfNotSet (&quot;Content-type&quot;,
 666                         &quot;application/x-www-form-urlencoded&quot;);
 667             }
 668 
 669             boolean chunked = false;
 670 
 671             if (streaming()) {
 672                 if (chunkLength != -1) {
 673                     requests.set (&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);
 674                     chunked = true;
 675                 } else { /* fixed content length */
 676                     if (fixedContentLengthLong != -1) {
 677                         requests.set (&quot;Content-Length&quot;,
 678                                       String.valueOf(fixedContentLengthLong));
 679                     } else if (fixedContentLength != -1) {
 680                         requests.set (&quot;Content-Length&quot;,
 681                                       String.valueOf(fixedContentLength));
 682                     }
 683                 }
 684             } else if (poster != null) {
 685                 /* add Content-Length &amp; POST/PUT data */
 686                 synchronized (poster) {
 687                     /* close it, so no more data can be added */
 688                     poster.close();
 689                     requests.set(&quot;Content-Length&quot;,
 690                                  String.valueOf(poster.size()));
 691                 }
 692             }
 693 
 694             if (!chunked) {
 695                 if (requests.findValue(&quot;Transfer-Encoding&quot;) != null) {
 696                     requests.remove(&quot;Transfer-Encoding&quot;);
 697                     if (logger.isLoggable(PlatformLogger.Level.WARNING)) {
 698                         logger.warning(
 699                             &quot;use streaming mode for chunked encoding&quot;);
 700                     }
 701                 }
 702             }
 703 
 704             // get applicable cookies based on the uri and request headers
 705             // add them to the existing request headers
 706             setCookieHeader();
 707 
 708             setRequests=true;
 709         }
 710         if (logger.isLoggable(PlatformLogger.Level.FINE)) {
 711             logger.fine(requests.toString());
 712         }
 713         http.writeRequests(requests, poster, streaming());
 714         if (ps.checkError()) {
 715             String proxyHost = http.getProxyHostUsed();
 716             int proxyPort = http.getProxyPortUsed();
 717             disconnectInternal();
 718             if (failedOnce) {
 719                 throw new IOException(&quot;Error writing to server&quot;);
 720             } else { // try once more
 721                 failedOnce=true;
 722                 if (proxyHost != null) {
 723                     setProxiedClient(url, proxyHost, proxyPort);
 724                 } else {
 725                     setNewClient (url);
 726                 }
 727                 ps = (PrintStream) http.getOutputStream();
 728                 connected=true;
 729                 responses = new MessageHeader();
 730                 setRequests=false;
 731                 writeRequests();
 732             }
 733         }
 734     }
 735 
 736     private boolean checkSetHost() {
 737         SecurityManager s = System.getSecurityManager();
 738         if (s != null) {
 739             String name = s.getClass().getName();
 740             if (name.equals(&quot;sun.plugin2.applet.AWTAppletSecurityManager&quot;) ||
 741                 name.equals(&quot;sun.plugin2.applet.FXAppletSecurityManager&quot;) ||
 742                 name.equals(&quot;com.sun.javaws.security.JavaWebStartSecurity&quot;) ||
 743                 name.equals(&quot;sun.plugin.security.ActivatorSecurityManager&quot;))
 744             {
 745                 int CHECK_SET_HOST = -2;
 746                 try {
 747                     s.checkConnect(url.toExternalForm(), CHECK_SET_HOST);
 748                 } catch (SecurityException ex) {
 749                     return false;
 750                 }
 751             }
 752         }
 753         return true;
 754     }
 755 
 756     private void checkURLFile() {
 757         SecurityManager s = System.getSecurityManager();
 758         if (s != null) {
 759             String name = s.getClass().getName();
 760             if (name.equals(&quot;sun.plugin2.applet.AWTAppletSecurityManager&quot;) ||
 761                 name.equals(&quot;sun.plugin2.applet.FXAppletSecurityManager&quot;) ||
 762                 name.equals(&quot;com.sun.javaws.security.JavaWebStartSecurity&quot;) ||
 763                 name.equals(&quot;sun.plugin.security.ActivatorSecurityManager&quot;))
 764             {
 765                 int CHECK_SUBPATH = -3;
 766                 try {
 767                     s.checkConnect(url.toExternalForm(), CHECK_SUBPATH);
 768                 } catch (SecurityException ex) {
 769                     throw new SecurityException(&quot;denied access outside a permitted URL subpath&quot;, ex);
 770                 }
 771             }
 772         }
 773     }
 774 
 775     /**
 776      * Create a new HttpClient object, bypassing the cache of
 777      * HTTP client objects/connections.
 778      *
 779      * @param url       the URL being accessed
 780      */
 781     protected void setNewClient (URL url)
 782     throws IOException {
 783         setNewClient(url, false);
 784     }
 785 
 786     /**
 787      * Obtain a HttpsClient object. Use the cached copy if specified.
 788      *
 789      * @param url       the URL being accessed
 790      * @param useCache  whether the cached connection should be used
 791      *        if present
 792      */
 793     protected void setNewClient (URL url, boolean useCache)
 794         throws IOException {
 795         http = HttpClient.New(url, null, -1, useCache, connectTimeout, this);
 796         http.setReadTimeout(readTimeout);
 797     }
 798 
 799 
 800     /**
 801      * Create a new HttpClient object, set up so that it uses
 802      * per-instance proxying to the given HTTP proxy.  This
 803      * bypasses the cache of HTTP client objects/connections.
 804      *
 805      * @param url       the URL being accessed
 806      * @param proxyHost the proxy host to use
 807      * @param proxyPort the proxy port to use
 808      */
 809     protected void setProxiedClient (URL url, String proxyHost, int proxyPort)
 810     throws IOException {
 811         setProxiedClient(url, proxyHost, proxyPort, false);
 812     }
 813 
 814     /**
 815      * Obtain a HttpClient object, set up so that it uses per-instance
 816      * proxying to the given HTTP proxy. Use the cached copy of HTTP
 817      * client objects/connections if specified.
 818      *
 819      * @param url       the URL being accessed
 820      * @param proxyHost the proxy host to use
 821      * @param proxyPort the proxy port to use
 822      * @param useCache  whether the cached connection should be used
 823      *        if present
 824      */
 825     protected void setProxiedClient (URL url,
 826                                      String proxyHost, int proxyPort,
 827                                      boolean useCache)
 828         throws IOException {
 829         proxiedConnect(url, proxyHost, proxyPort, useCache);
 830     }
 831 
 832     protected void proxiedConnect(URL url,
 833                                   String proxyHost, int proxyPort,
 834                                   boolean useCache)
 835         throws IOException {
 836         http = HttpClient.New (url, proxyHost, proxyPort, useCache,
 837             connectTimeout, this);
 838         http.setReadTimeout(readTimeout);
 839     }
 840 
 841     protected HttpURLConnection(URL u, Handler handler)
 842     throws IOException {
 843         // we set proxy == null to distinguish this case with the case
 844         // when per connection proxy is set
 845         this(u, null, handler);
 846     }
 847 
 848     private static String checkHost(String h) throws IOException {
 849         if (h != null) {
 850             if (h.indexOf(&#39;\n&#39;) &gt; -1) {
 851                 throw new MalformedURLException(&quot;Illegal character in host&quot;);
 852             }
 853         }
 854         return h;
 855     }
 856     public HttpURLConnection(URL u, String host, int port) throws IOException {
 857         this(u, new Proxy(Proxy.Type.HTTP,
 858                 InetSocketAddress.createUnresolved(checkHost(host), port)));
 859     }
 860 
 861     /** this constructor is used by other protocol handlers such as ftp
 862         that want to use http to fetch urls on their behalf.*/
 863     public HttpURLConnection(URL u, Proxy p) throws IOException {
 864         this(u, p, new Handler());
 865     }
 866 
 867     private static URL checkURL(URL u) throws IOException {
 868         if (u != null) {
 869             if (u.toExternalForm().indexOf(&#39;\n&#39;) &gt; -1) {
 870                 throw new MalformedURLException(&quot;Illegal character in URL&quot;);
 871             }
 872         }
 873         String s = IPAddressUtil.checkAuthority(u);
 874         if (s != null) {
 875             throw new MalformedURLException(s);
 876         }
 877         return u;
 878     }
 879 
 880     protected HttpURLConnection(URL u, Proxy p, Handler handler)
 881             throws IOException {
 882         super(checkURL(u));
 883         requests = new MessageHeader();
 884         responses = new MessageHeader();
 885         userHeaders = new MessageHeader();
 886         this.handler = handler;
 887         instProxy = p;
 888         if (instProxy instanceof sun.net.ApplicationProxy) {
 889             /* Application set Proxies should not have access to cookies
 890              * in a secure environment unless explicitly allowed. */
 891             try {
 892                 cookieHandler = CookieHandler.getDefault();
 893             } catch (SecurityException se) { /* swallow exception */ }
 894         } else {
 895             cookieHandler = java.security.AccessController.doPrivileged(
 896                 new java.security.PrivilegedAction&lt;&gt;() {
 897                 public CookieHandler run() {
 898                     return CookieHandler.getDefault();
 899                 }
 900             });
 901         }
 902         cacheHandler = java.security.AccessController.doPrivileged(
 903             new java.security.PrivilegedAction&lt;&gt;() {
 904                 public ResponseCache run() {
 905                 return ResponseCache.getDefault();
 906             }
 907         });
 908     }
 909 
 910     /**
 911      * @deprecated.  Use java.net.Authenticator.setDefault() instead.
 912      */
 913     @Deprecated
 914     public static void setDefaultAuthenticator(HttpAuthenticator a) {
 915         defaultAuth = a;
 916     }
 917 
 918     /**
 919      * opens a stream allowing redirects only to the same host.
 920      */
 921     public static InputStream openConnectionCheckRedirects(URLConnection c)
 922         throws IOException
 923     {
 924         boolean redir;
 925         int redirects = 0;
 926         InputStream in;
 927         Authenticator a = null;
 928 
 929         do {
 930             if (c instanceof HttpURLConnection) {
 931                 ((HttpURLConnection) c).setInstanceFollowRedirects(false);
 932                 if (a == null) {
 933                     a = ((HttpURLConnection) c).authenticator;
 934                 }
 935             }
 936 
 937             // We want to open the input stream before
 938             // getting headers, because getHeaderField()
 939             // et al swallow IOExceptions.
 940             in = c.getInputStream();
 941             redir = false;
 942 
 943             if (c instanceof HttpURLConnection) {
 944                 HttpURLConnection http = (HttpURLConnection) c;
 945                 int stat = http.getResponseCode();
 946                 if (stat &gt;= 300 &amp;&amp; stat &lt;= 307 &amp;&amp; stat != 306 &amp;&amp;
 947                         stat != HttpURLConnection.HTTP_NOT_MODIFIED) {
 948                     URL base = http.getURL();
 949                     String loc = http.getHeaderField(&quot;Location&quot;);
 950                     URL target = null;
 951                     if (loc != null) {
 952                         target = new URL(base, loc);
 953                     }
 954                     http.disconnect();
 955                     if (target == null
 956                         || !base.getProtocol().equals(target.getProtocol())
 957                         || base.getPort() != target.getPort()
 958                         || !hostsEqual(base, target)
 959                         || redirects &gt;= 5)
 960                     {
 961                         throw new SecurityException(&quot;illegal URL redirect&quot;);
 962                     }
 963                     redir = true;
 964                     c = target.openConnection();
 965                     if (a != null &amp;&amp; c instanceof HttpURLConnection) {
 966                         ((HttpURLConnection)c).setAuthenticator(a);
 967                     }
 968                     redirects++;
 969                 }
 970             }
 971         } while (redir);
 972         return in;
 973     }
 974 
 975 
 976     //
 977     // Same as java.net.URL.hostsEqual
 978     //
 979     private static boolean hostsEqual(URL u1, URL u2) {
 980         final String h1 = u1.getHost();
 981         final String h2 = u2.getHost();
 982 
 983         if (h1 == null) {
 984             return h2 == null;
 985         } else if (h2 == null) {
 986             return false;
 987         } else if (h1.equalsIgnoreCase(h2)) {
 988             return true;
 989         }
 990         // Have to resolve addresses before comparing, otherwise
 991         // names like tachyon and tachyon.eng would compare different
 992         final boolean result[] = {false};
 993 
 994         java.security.AccessController.doPrivileged(
 995             new java.security.PrivilegedAction&lt;&gt;() {
 996                 public Void run() {
 997                 try {
 998                     InetAddress a1 = InetAddress.getByName(h1);
 999                     InetAddress a2 = InetAddress.getByName(h2);
1000                     result[0] = a1.equals(a2);
1001                 } catch(UnknownHostException | SecurityException e) {
1002                 }
1003                 return null;
1004             }
1005         });
1006 
1007         return result[0];
1008     }
1009 
1010     // overridden in HTTPS subclass
1011 
1012     public void connect() throws IOException {
1013         synchronized (this) {
1014             connecting = true;
1015         }
1016         plainConnect();
1017     }
1018 
1019     private boolean checkReuseConnection () {
1020         if (connected) {
1021             return true;
1022         }
1023         if (reuseClient != null) {
1024             http = reuseClient;
1025             http.setReadTimeout(getReadTimeout());
1026             http.reuse = false;
1027             reuseClient = null;
1028             connected = true;
1029             return true;
1030         }
1031         return false;
1032     }
1033 
1034     private String getHostAndPort(URL url) {
1035         String host = url.getHost();
1036         final String hostarg = host;
1037         try {
1038             // lookup hostname and use IP address if available
1039             host = AccessController.doPrivileged(
1040                 new PrivilegedExceptionAction&lt;&gt;() {
1041                     public String run() throws IOException {
1042                             InetAddress addr = InetAddress.getByName(hostarg);
1043                             return addr.getHostAddress();
1044                     }
1045                 }
1046             );
1047         } catch (PrivilegedActionException e) {}
1048         int port = url.getPort();
1049         if (port == -1) {
1050             String scheme = url.getProtocol();
1051             if (&quot;http&quot;.equals(scheme)) {
1052                 return host + &quot;:80&quot;;
1053             } else { // scheme must be https
1054                 return host + &quot;:443&quot;;
1055             }
1056         }
1057         return host + &quot;:&quot; + Integer.toString(port);
1058     }
1059 
1060     protected void plainConnect()  throws IOException {
1061         synchronized (this) {
1062             if (connected) {
1063                 return;
1064             }
1065         }
1066         SocketPermission p = URLtoSocketPermission(this.url);
1067         if (p != null) {
1068             try {
1069                 AccessController.doPrivilegedWithCombiner(
1070                     new PrivilegedExceptionAction&lt;&gt;() {
1071                         public Void run() throws IOException {
1072                             plainConnect0();
1073                             return null;
1074                         }
1075                     }, null, p
1076                 );
1077             } catch (PrivilegedActionException e) {
1078                     throw (IOException) e.getException();
1079             }
1080         } else {
1081             // run without additional permission
1082             plainConnect0();
1083         }
1084     }
1085 
1086     /**
1087      *  if the caller has a URLPermission for connecting to the
1088      *  given URL, then return a SocketPermission which permits
1089      *  access to that destination. Return null otherwise. The permission
1090      *  is cached in a field (which can only be changed by redirects)
1091      */
1092     SocketPermission URLtoSocketPermission(URL url) throws IOException {
1093 
1094         if (socketPermission != null) {
1095             return socketPermission;
1096         }
1097 
1098         SecurityManager sm = System.getSecurityManager();
1099 
1100         if (sm == null) {
1101             return null;
1102         }
1103 
1104         // the permission, which we might grant
1105 
1106         SocketPermission newPerm = new SocketPermission(
1107             getHostAndPort(url), &quot;connect&quot;
1108         );
1109 
1110         String actions = getRequestMethod()+&quot;:&quot; +
1111                 getUserSetHeaders().getHeaderNamesInList();
1112 
1113         String urlstring = url.getProtocol() + &quot;://&quot; + url.getAuthority()
1114                 + url.getPath();
1115 
1116         URLPermission p = new URLPermission(urlstring, actions);
1117         try {
1118             sm.checkPermission(p);
1119             socketPermission = newPerm;
1120             return socketPermission;
1121         } catch (SecurityException e) {
1122             // fall thru
1123         }
1124         return null;
1125     }
1126 
1127     protected void plainConnect0()  throws IOException {
1128         // try to see if request can be served from local cache
1129         if (cacheHandler != null &amp;&amp; getUseCaches()) {
1130             try {
1131                 URI uri = ParseUtil.toURI(url);
1132                 if (uri != null) {
1133                     cachedResponse = cacheHandler.get(uri, getRequestMethod(), getUserSetHeaders().getHeaders());
1134                     if (&quot;https&quot;.equalsIgnoreCase(uri.getScheme())
1135                         &amp;&amp; !(cachedResponse instanceof SecureCacheResponse)) {
1136                         cachedResponse = null;
1137                     }
1138                     if (logger.isLoggable(PlatformLogger.Level.FINEST)) {
1139                         logger.finest(&quot;Cache Request for &quot; + uri + &quot; / &quot; + getRequestMethod());
1140                         logger.finest(&quot;From cache: &quot; + (cachedResponse != null ? cachedResponse.toString() : &quot;null&quot;));
1141                     }
1142                     if (cachedResponse != null) {
1143                         cachedHeaders = mapToMessageHeader(cachedResponse.getHeaders());
1144                         cachedInputStream = cachedResponse.getBody();
1145                     }
1146                 }
1147             } catch (IOException ioex) {
1148                 // ignore and commence normal connection
1149             }
1150             if (cachedHeaders != null &amp;&amp; cachedInputStream != null) {
1151                 connected = true;
1152                 return;
1153             } else {
1154                 cachedResponse = null;
1155             }
1156         }
1157         try {
1158             /* Try to open connections using the following scheme,
1159              * return on the first one that&#39;s successful:
1160              * 1) if (instProxy != null)
1161              *        connect to instProxy; raise exception if failed
1162              * 2) else use system default ProxySelector
1163              * 3) else make a direct connection if ProxySelector is not present
1164              */
1165 
1166             if (instProxy == null) { // no instance Proxy is set
1167                 /**
1168                  * Do we have to use a proxy?
1169                  */
1170                 ProxySelector sel =
1171                     java.security.AccessController.doPrivileged(
1172                         new java.security.PrivilegedAction&lt;&gt;() {
1173                             public ProxySelector run() {
1174                                      return ProxySelector.getDefault();
1175                                  }
1176                              });
1177                 if (sel != null) {
1178                     URI uri = sun.net.www.ParseUtil.toURI(url);
1179                     if (logger.isLoggable(PlatformLogger.Level.FINEST)) {
1180                         logger.finest(&quot;ProxySelector Request for &quot; + uri);
1181                     }
1182                     final List&lt;Proxy&gt; proxies;
1183                     try {
1184                         proxies = sel.select(uri);
1185                     } catch (IllegalArgumentException iae) {
1186                         throw new IOException(&quot;Failed to select a proxy&quot;, iae);
1187                     }
1188                     final Iterator&lt;Proxy&gt; it = proxies.iterator();
1189                     Proxy p;
1190                     while (it.hasNext()) {
1191                         p = it.next();
1192                         try {
1193                             if (!failedOnce) {
1194                                 http = getNewHttpClient(url, p, connectTimeout);
1195                                 http.setReadTimeout(readTimeout);
1196                             } else {
1197                                 // make sure to construct new connection if first
1198                                 // attempt failed
1199                                 http = getNewHttpClient(url, p, connectTimeout, false);
1200                                 http.setReadTimeout(readTimeout);
1201                             }
1202                             if (logger.isLoggable(PlatformLogger.Level.FINEST)) {
1203                                 if (p != null) {
1204                                     logger.finest(&quot;Proxy used: &quot; + p.toString());
1205                                 }
1206                             }
1207                             break;
1208                         } catch (IOException ioex) {
1209                             if (p != Proxy.NO_PROXY) {
1210                                 sel.connectFailed(uri, p.address(), ioex);
1211                                 if (!it.hasNext()) {
1212                                     if (logger.isLoggable(PlatformLogger.Level.FINEST)) {
1213                                         logger.finest(&quot;Retrying with proxy: &quot; + p.toString());
1214                                     }
1215                                     http = getNewHttpClient(url, p, connectTimeout, false);
1216                                     http.setReadTimeout(readTimeout);
1217                                     break;
1218                                 }
1219                             } else {
1220                                 throw ioex;
1221                             }
1222                             continue;
1223                         }
1224                     }
1225                 } else {
1226                     // No proxy selector, create http client with no proxy
1227                     if (!failedOnce) {
1228                         http = getNewHttpClient(url, null, connectTimeout);
1229                         http.setReadTimeout(readTimeout);
1230                     } else {
1231                         // make sure to construct new connection if first
1232                         // attempt failed
1233                         http = getNewHttpClient(url, null, connectTimeout, false);
1234                         http.setReadTimeout(readTimeout);
1235                     }
1236                 }
1237             } else {
1238                 if (!failedOnce) {
1239                     http = getNewHttpClient(url, instProxy, connectTimeout);
1240                     http.setReadTimeout(readTimeout);
1241                 } else {
1242                     // make sure to construct new connection if first
1243                     // attempt failed
1244                     http = getNewHttpClient(url, instProxy, connectTimeout, false);
1245                     http.setReadTimeout(readTimeout);
1246                 }
1247             }
1248 
1249             usingProxy = usingProxy || usingProxyInternal();
1250             ps = (PrintStream)http.getOutputStream();
1251         } catch (IOException e) {
1252             throw e;
1253         }
1254         // constructor to HTTP client calls openserver
1255         connected = true;
1256     }
1257 
1258     // subclass HttpsClient will overwrite &amp; return an instance of HttpsClient
1259     protected HttpClient getNewHttpClient(URL url, Proxy p, int connectTimeout)
1260         throws IOException {
1261         return HttpClient.New(url, p, connectTimeout, this);
1262     }
1263 
1264     // subclass HttpsClient will overwrite &amp; return an instance of HttpsClient
1265     protected HttpClient getNewHttpClient(URL url, Proxy p,
1266                                           int connectTimeout, boolean useCache)
1267         throws IOException {
1268         return HttpClient.New(url, p, connectTimeout, useCache, this);
1269     }
1270 
1271     private void expect100Continue() throws IOException {
1272             // Expect: 100-Continue was set, so check the return code for
1273             // Acceptance
1274             int oldTimeout = http.getReadTimeout();
1275             boolean enforceTimeOut = false;
1276             boolean timedOut = false;
1277             if (oldTimeout &lt;= 0) {
1278                 // 5s read timeout in case the server doesn&#39;t understand
1279                 // Expect: 100-Continue
1280                 http.setReadTimeout(5000);
1281                 enforceTimeOut = true;
1282             }
1283 
1284             try {
1285                 http.parseHTTP(responses, pi, this);
1286             } catch (SocketTimeoutException se) {
1287                 if (!enforceTimeOut) {
1288                     throw se;
1289                 }
1290                 timedOut = true;
1291                 http.setIgnoreContinue(true);
1292             }
1293             if (!timedOut) {
1294                 // Can&#39;t use getResponseCode() yet
1295                 String resp = responses.getValue(0);
1296                 // Parse the response which is of the form:
1297                 // HTTP/1.1 417 Expectation Failed
1298                 // HTTP/1.1 100 Continue
1299                 if (resp != null &amp;&amp; resp.startsWith(&quot;HTTP/&quot;)) {
1300                     String[] sa = resp.split(&quot;\\s+&quot;);
1301                     responseCode = -1;
1302                     try {
1303                         // Response code is 2nd token on the line
1304                         if (sa.length &gt; 1)
1305                             responseCode = Integer.parseInt(sa[1]);
1306                     } catch (NumberFormatException numberFormatException) {
1307                     }
1308                 }
1309                 if (responseCode != 100) {
1310                     throw new ProtocolException(&quot;Server rejected operation&quot;);
1311                 }
1312             }
1313 
1314             http.setReadTimeout(oldTimeout);
1315 
1316             responseCode = -1;
1317             responses.reset();
1318             // Proceed
1319     }
1320 
1321     /*
1322      * Allowable input/output sequences:
1323      * [interpreted as request entity]
1324      * - get output, [write output,] get input, [read input]
1325      * - get output, [write output]
1326      * [interpreted as GET]
1327      * - get input, [read input]
1328      * Disallowed:
1329      * - get input, [read input,] get output, [write output]
1330      */
1331 
1332     @Override
1333     public synchronized OutputStream getOutputStream() throws IOException {
1334         connecting = true;
1335         SocketPermission p = URLtoSocketPermission(this.url);
1336 
1337         if (p != null) {
1338             try {
1339                 return AccessController.doPrivilegedWithCombiner(
1340                     new PrivilegedExceptionAction&lt;&gt;() {
1341                         public OutputStream run() throws IOException {
1342                             return getOutputStream0();
1343                         }
1344                     }, null, p
1345                 );
1346             } catch (PrivilegedActionException e) {
1347                 throw (IOException) e.getException();
1348             }
1349         } else {
1350             return getOutputStream0();
1351         }
1352     }
1353 
1354     private synchronized OutputStream getOutputStream0() throws IOException {
1355         try {
1356             if (!doOutput) {
1357                 throw new ProtocolException(&quot;cannot write to a URLConnection&quot;
1358                                + &quot; if doOutput=false - call setDoOutput(true)&quot;);
1359             }
1360 
1361             if (method.equals(&quot;GET&quot;)) {
1362                 method = &quot;POST&quot;; // Backward compatibility
1363             }
1364             if (&quot;TRACE&quot;.equals(method) &amp;&amp; &quot;http&quot;.equals(url.getProtocol())) {
1365                 throw new ProtocolException(&quot;HTTP method TRACE&quot; +
1366                                             &quot; doesn&#39;t support output&quot;);
1367             }
1368 
1369             // if there&#39;s already an input stream open, throw an exception
1370             if (inputStream != null) {
1371                 throw new ProtocolException(&quot;Cannot write output after reading input.&quot;);
1372             }
1373 
1374             if (!checkReuseConnection())
1375                 connect();
1376 
1377             boolean expectContinue = false;
1378             String expects = requests.findValue(&quot;Expect&quot;);
1379             if (&quot;100-Continue&quot;.equalsIgnoreCase(expects) &amp;&amp; streaming()) {
1380                 http.setIgnoreContinue(false);
1381                 expectContinue = true;
1382             }
1383 
1384             if (streaming() &amp;&amp; strOutputStream == null) {
1385                 writeRequests();
1386             }
1387 
1388             if (expectContinue) {
1389                 expect100Continue();
1390             }
1391             ps = (PrintStream)http.getOutputStream();
1392             if (streaming()) {
1393                 if (strOutputStream == null) {
1394                     if (chunkLength != -1) { /* chunked */
1395                          strOutputStream = new StreamingOutputStream(
1396                                new ChunkedOutputStream(ps, chunkLength), -1L);
1397                     } else { /* must be fixed content length */
1398                         long length = 0L;
1399                         if (fixedContentLengthLong != -1) {
1400                             length = fixedContentLengthLong;
1401                         } else if (fixedContentLength != -1) {
1402                             length = fixedContentLength;
1403                         }
1404                         strOutputStream = new StreamingOutputStream(ps, length);
1405                     }
1406                 }
1407                 return strOutputStream;
1408             } else {
1409                 if (poster == null) {
1410                     poster = new PosterOutputStream();
1411                 }
1412                 return poster;
1413             }
1414         } catch (RuntimeException e) {
1415             disconnectInternal();
1416             throw e;
1417         } catch (ProtocolException e) {
1418             // Save the response code which may have been set while enforcing
1419             // the 100-continue. disconnectInternal() forces it to -1
1420             int i = responseCode;
1421             disconnectInternal();
1422             responseCode = i;
1423             throw e;
1424         } catch (IOException e) {
1425             disconnectInternal();
1426             throw e;
1427         }
1428     }
1429 
1430     public boolean streaming () {
1431         return (fixedContentLength != -1) || (fixedContentLengthLong != -1) ||
1432                (chunkLength != -1);
1433     }
1434 
1435     /*
1436      * get applicable cookies based on the uri and request headers
1437      * add them to the existing request headers
1438      */
1439     private void setCookieHeader() throws IOException {
1440         if (cookieHandler != null) {
1441             // we only want to capture the user defined Cookies once, as
1442             // they cannot be changed by user code after we are connected,
1443             // only internally.
1444             synchronized (this) {
1445                 if (setUserCookies) {
1446                     int k = requests.getKey(&quot;Cookie&quot;);
1447                     if (k != -1)
1448                         userCookies = requests.getValue(k);
1449                     k = requests.getKey(&quot;Cookie2&quot;);
1450                     if (k != -1)
1451                         userCookies2 = requests.getValue(k);
1452                     setUserCookies = false;
1453                 }
1454             }
1455 
1456             // remove old Cookie header before setting new one.
1457             requests.remove(&quot;Cookie&quot;);
1458             requests.remove(&quot;Cookie2&quot;);
1459 
1460             URI uri = ParseUtil.toURI(url);
1461             if (uri != null) {
1462                 if (logger.isLoggable(PlatformLogger.Level.FINEST)) {
1463                     logger.finest(&quot;CookieHandler request for &quot; + uri);
1464                 }
1465                 Map&lt;String, List&lt;String&gt;&gt; cookies
1466                     = cookieHandler.get(
1467                         uri, requests.getHeaders(EXCLUDE_HEADERS));
1468                 if (!cookies.isEmpty()) {
1469                     if (logger.isLoggable(PlatformLogger.Level.FINEST)) {
1470                         logger.finest(&quot;Cookies retrieved: &quot; + cookies.toString());
1471                     }
1472                     for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry :
1473                              cookies.entrySet()) {
1474                         String key = entry.getKey();
1475                         // ignore all entries that don&#39;t have &quot;Cookie&quot;
1476                         // or &quot;Cookie2&quot; as keys
1477                         if (!&quot;Cookie&quot;.equalsIgnoreCase(key) &amp;&amp;
1478                             !&quot;Cookie2&quot;.equalsIgnoreCase(key)) {
1479                             continue;
1480                         }
1481                         List&lt;String&gt; l = entry.getValue();
1482                         if (l != null &amp;&amp; !l.isEmpty()) {
1483                             StringJoiner cookieValue = new StringJoiner(&quot;; &quot;);
1484                             for (String value : l) {
1485                                 cookieValue.add(value);
1486                             }
1487                             requests.add(key, cookieValue.toString());
1488                         }
1489                     }
1490                 }
1491             }
1492             if (userCookies != null) {
1493                 int k;
1494                 if ((k = requests.getKey(&quot;Cookie&quot;)) != -1)
1495                     requests.set(&quot;Cookie&quot;, requests.getValue(k) + &quot;;&quot; + userCookies);
1496                 else
1497                     requests.set(&quot;Cookie&quot;, userCookies);
1498             }
1499             if (userCookies2 != null) {
1500                 int k;
1501                 if ((k = requests.getKey(&quot;Cookie2&quot;)) != -1)
1502                     requests.set(&quot;Cookie2&quot;, requests.getValue(k) + &quot;;&quot; + userCookies2);
1503                 else
1504                     requests.set(&quot;Cookie2&quot;, userCookies2);
1505             }
1506 
1507         } // end of getting cookies
1508     }
1509 
1510     @Override
1511     public synchronized InputStream getInputStream() throws IOException {
1512         connecting = true;
1513         SocketPermission p = URLtoSocketPermission(this.url);
1514 
1515         if (p != null) {
1516             try {
1517                 return AccessController.doPrivilegedWithCombiner(
1518                     new PrivilegedExceptionAction&lt;&gt;() {
1519                         public InputStream run() throws IOException {
1520                             return getInputStream0();
1521                         }
1522                     }, null, p
1523                 );
1524             } catch (PrivilegedActionException e) {
1525                 throw (IOException) e.getException();
1526             }
1527         } else {
1528             return getInputStream0();
1529         }
1530     }
1531 
1532     @SuppressWarnings(&quot;empty-statement&quot;)
1533     private synchronized InputStream getInputStream0() throws IOException {
1534 
1535         if (!doInput) {
1536             throw new ProtocolException(&quot;Cannot read from URLConnection&quot;
1537                    + &quot; if doInput=false (call setDoInput(true))&quot;);
1538         }
1539 
1540         if (rememberedException != null) {
1541             if (rememberedException instanceof RuntimeException)
1542                 throw new RuntimeException(rememberedException);
1543             else {
1544                 throw getChainedException((IOException)rememberedException);
1545             }
1546         }
1547 
1548         if (inputStream != null) {
1549             return inputStream;
1550         }
1551 
1552         if (streaming() ) {
1553             if (strOutputStream == null) {
1554                 getOutputStream();
1555             }
1556             /* make sure stream is closed */
1557             strOutputStream.close ();
1558             if (!strOutputStream.writtenOK()) {
1559                 throw new IOException (&quot;Incomplete output stream&quot;);
1560             }
1561         }
1562 
1563         int redirects = 0;
1564         int respCode = 0;
1565         long cl = -1;
1566         AuthenticationInfo serverAuthentication = null;
1567         AuthenticationInfo proxyAuthentication = null;
1568         AuthenticationHeader srvHdr = null;
1569 
1570         /**
1571          * Failed Negotiate
1572          *
1573          * In some cases, the Negotiate auth is supported for the
1574          * remote host but the negotiate process still fails (For
1575          * example, if the web page is located on a backend server
1576          * and delegation is needed but fails). The authentication
1577          * process will start again, and we need to detect this
1578          * kind of failure and do proper fallback (say, to NTLM).
1579          *
1580          * In order to achieve this, the inNegotiate flag is set
1581          * when the first negotiate challenge is met (and reset
1582          * if authentication is finished). If a fresh new negotiate
1583          * challenge (no parameter) is found while inNegotiate is
1584          * set, we know there&#39;s a failed auth attempt recently.
1585          * Here we&#39;ll ignore the header line so that fallback
1586          * can be practiced.
1587          *
1588          * inNegotiateProxy is for proxy authentication.
1589          */
1590         boolean inNegotiate = false;
1591         boolean inNegotiateProxy = false;
1592 
1593         // If the user has set either of these headers then do not remove them
1594         isUserServerAuth = requests.getKey(&quot;Authorization&quot;) != -1;
1595         isUserProxyAuth = requests.getKey(&quot;Proxy-Authorization&quot;) != -1;
1596 
1597         try {
1598             do {
1599                 if (!checkReuseConnection())
1600                     connect();
1601 
1602                 if (cachedInputStream != null) {
1603                     return cachedInputStream;
1604                 }
1605 
1606                 // Check if URL should be metered
1607                 boolean meteredInput = ProgressMonitor.getDefault().shouldMeterInput(url, method);
1608 
1609                 if (meteredInput)   {
1610                     pi = new ProgressSource(url, method);
1611                     pi.beginTracking();
1612                 }
1613 
1614                 /* REMIND: This exists to fix the HttpsURLConnection subclass.
1615                  * Hotjava needs to run on JDK1.1FCS.  Do proper fix once a
1616                  * proper solution for SSL can be found.
1617                  */
1618                 ps = (PrintStream)http.getOutputStream();
1619 
1620                 if (!streaming()) {
1621                     writeRequests();
1622                 }
1623                 http.parseHTTP(responses, pi, this);
1624                 if (logger.isLoggable(PlatformLogger.Level.FINE)) {
1625                     logger.fine(responses.toString());
1626                 }
1627 
1628                 boolean b1 = responses.filterNTLMResponses(&quot;WWW-Authenticate&quot;);
1629                 boolean b2 = responses.filterNTLMResponses(&quot;Proxy-Authenticate&quot;);
1630                 if (b1 || b2) {
1631                     if (logger.isLoggable(PlatformLogger.Level.FINE)) {
1632                         logger.fine(&quot;&gt;&gt;&gt;&gt; Headers are filtered&quot;);
1633                         logger.fine(responses.toString());
1634                     }
1635                 }
1636 
1637                 inputStream = http.getInputStream();
1638 
1639                 respCode = getResponseCode();
1640                 if (respCode == -1) {
1641                     disconnectInternal();
1642                     throw new IOException (&quot;Invalid Http response&quot;);
1643                 }
1644                 if (respCode == HTTP_PROXY_AUTH) {
1645                     if (streaming()) {
1646                         disconnectInternal();
1647                         throw new HttpRetryException (
1648                             RETRY_MSG1, HTTP_PROXY_AUTH);
1649                     }
1650 
1651                     // Read comments labeled &quot;Failed Negotiate&quot; for details.
1652                     boolean dontUseNegotiate = false;
1653                     Iterator&lt;String&gt; iter = responses.multiValueIterator(&quot;Proxy-Authenticate&quot;);
1654                     while (iter.hasNext()) {
1655                         String value = iter.next().trim();
1656                         if (value.equalsIgnoreCase(&quot;Negotiate&quot;) ||
1657                                 value.equalsIgnoreCase(&quot;Kerberos&quot;)) {
1658                             if (!inNegotiateProxy) {
1659                                 inNegotiateProxy = true;
1660                             } else {
1661                                 dontUseNegotiate = true;
1662                                 doingNTLMp2ndStage = false;
1663                                 proxyAuthentication = null;
1664                             }
1665                             break;
1666                         }
1667                     }
1668 
1669                     // changes: add a 3rd parameter to the constructor of
1670                     // AuthenticationHeader, so that NegotiateAuthentication.
1671                     // isSupported can be tested.
1672                     // The other 2 appearances of &quot;new AuthenticationHeader&quot; is
1673                     // altered in similar ways.
1674 
1675                     AuthenticationHeader authhdr = new AuthenticationHeader (
1676                             &quot;Proxy-Authenticate&quot;,
1677                             responses,
1678                             new HttpCallerInfo(url,
1679                                                http.getProxyHostUsed(),
1680                                                http.getProxyPortUsed(),
1681                                                authenticator),
1682                             dontUseNegotiate,
1683                             disabledProxyingSchemes
1684                     );
1685 
1686                     if (!doingNTLMp2ndStage) {
1687                         proxyAuthentication =
1688                             resetProxyAuthentication(proxyAuthentication, authhdr);
1689                         if (proxyAuthentication != null) {
1690                             redirects++;
1691                             disconnectInternal();
1692                             continue;
1693                         }
1694                     } else {
1695                         /* in this case, only one header field will be present */
1696                         String raw = responses.findValue (&quot;Proxy-Authenticate&quot;);
1697                         reset ();
1698                         if (!proxyAuthentication.setHeaders(this,
1699                                                         authhdr.headerParser(), raw)) {
1700                             disconnectInternal();
1701                             throw new IOException (&quot;Authentication failure&quot;);
1702                         }
1703                         if (serverAuthentication != null &amp;&amp; srvHdr != null &amp;&amp;
1704                                 !serverAuthentication.setHeaders(this,
1705                                                         srvHdr.headerParser(), raw)) {
1706                             disconnectInternal ();
1707                             throw new IOException (&quot;Authentication failure&quot;);
1708                         }
1709                         authObj = null;
1710                         doingNTLMp2ndStage = false;
1711                         continue;
1712                     }
1713                 } else {
1714                     inNegotiateProxy = false;
1715                     doingNTLMp2ndStage = false;
1716                     if (!isUserProxyAuth)
1717                         requests.remove(&quot;Proxy-Authorization&quot;);
1718                 }
1719 
1720                 // cache proxy authentication info
1721                 if (proxyAuthentication != null) {
1722                     // cache auth info on success, domain header not relevant.
1723                     proxyAuthentication.addToCache();
1724                 }
1725 
1726                 if (respCode == HTTP_UNAUTHORIZED) {
1727                     if (streaming()) {
1728                         disconnectInternal();
1729                         throw new HttpRetryException (
1730                             RETRY_MSG2, HTTP_UNAUTHORIZED);
1731                     }
1732 
1733                     // Read comments labeled &quot;Failed Negotiate&quot; for details.
1734                     boolean dontUseNegotiate = false;
1735                     Iterator&lt;String&gt; iter = responses.multiValueIterator(&quot;WWW-Authenticate&quot;);
1736                     while (iter.hasNext()) {
1737                         String value = iter.next().trim();
1738                         if (value.equalsIgnoreCase(&quot;Negotiate&quot;) ||
1739                                 value.equalsIgnoreCase(&quot;Kerberos&quot;)) {
1740                             if (!inNegotiate) {
1741                                 inNegotiate = true;
1742                             } else {
1743                                 dontUseNegotiate = true;
1744                                 doingNTLM2ndStage = false;
1745                                 serverAuthentication = null;
1746                             }
1747                             break;
1748                         }
1749                     }
1750 
1751                     srvHdr = new AuthenticationHeader (
1752                             &quot;WWW-Authenticate&quot;, responses,
1753                             new HttpCallerInfo(url, authenticator),
1754                             dontUseNegotiate
1755                     );
1756 
1757                     String raw = srvHdr.raw();
1758                     if (!doingNTLM2ndStage) {
1759                         if ((serverAuthentication != null)&amp;&amp;
1760                             serverAuthentication.getAuthScheme() != NTLM) {
1761                             if (serverAuthentication.isAuthorizationStale (raw)) {
1762                                 /* we can retry with the current credentials */
1763                                 disconnectWeb();
1764                                 redirects++;
1765                                 requests.set(serverAuthentication.getHeaderName(),
1766                                             serverAuthentication.getHeaderValue(url, method));
1767                                 currentServerCredentials = serverAuthentication;
1768                                 setCookieHeader();
1769                                 continue;
1770                             } else {
1771                                 serverAuthentication.removeFromCache();
1772                             }
1773                         }
1774                         serverAuthentication = getServerAuthentication(srvHdr);
1775                         currentServerCredentials = serverAuthentication;
1776 
1777                         if (serverAuthentication != null) {
1778                             disconnectWeb();
1779                             redirects++; // don&#39;t let things loop ad nauseum
1780                             setCookieHeader();
1781                             continue;
1782                         }
1783                     } else {
1784                         reset ();
1785                         /* header not used for ntlm */
1786                         if (!serverAuthentication.setHeaders(this, null, raw)) {
1787                             disconnectWeb();
1788                             throw new IOException (&quot;Authentication failure&quot;);
1789                         }
1790                         doingNTLM2ndStage = false;
1791                         authObj = null;
1792                         setCookieHeader();
1793                         continue;
1794                     }
1795                 }
1796                 // cache server authentication info
1797                 if (serverAuthentication != null) {
1798                     // cache auth info on success
1799                     if (!(serverAuthentication instanceof DigestAuthentication) ||
1800                         (domain == null)) {
1801                         if (serverAuthentication instanceof BasicAuthentication) {
1802                             // check if the path is shorter than the existing entry
1803                             String npath = AuthenticationInfo.reducePath (url.getPath());
1804                             String opath = serverAuthentication.path;
1805                             if (!opath.startsWith (npath) || npath.length() &gt;= opath.length()) {
1806                                 /* npath is longer, there must be a common root */
1807                                 npath = BasicAuthentication.getRootPath (opath, npath);
1808                             }
1809                             // remove the entry and create a new one
1810                             BasicAuthentication a =
1811                                 (BasicAuthentication) serverAuthentication.clone();
1812                             serverAuthentication.removeFromCache();
1813                             a.path = npath;
1814                             serverAuthentication = a;
1815                         }
1816                         serverAuthentication.addToCache();
1817                     } else {
1818                         // what we cache is based on the domain list in the request
1819                         DigestAuthentication srv = (DigestAuthentication)
1820                             serverAuthentication;
1821                         StringTokenizer tok = new StringTokenizer (domain,&quot; &quot;);
1822                         String realm = srv.realm;
1823                         PasswordAuthentication pw = srv.pw;
1824                         digestparams = srv.params;
1825                         while (tok.hasMoreTokens()) {
1826                             String path = tok.nextToken();
1827                             try {
1828                                 /* path could be an abs_path or a complete URI */
1829                                 URL u = new URL (url, path);
1830                                 DigestAuthentication d = new DigestAuthentication (
1831                                                    false, u, realm, &quot;Digest&quot;, pw,
1832                                                    digestparams, srv.authenticatorKey);
1833                                 d.addToCache ();
1834                             } catch (Exception e) {}
1835                         }
1836                     }
1837                 }
1838 
1839                 // some flags should be reset to its initialized form so that
1840                 // even after a redirect the necessary checks can still be
1841                 // preformed.
1842                 inNegotiate = false;
1843                 inNegotiateProxy = false;
1844 
1845                 //serverAuthentication = null;
1846                 doingNTLMp2ndStage = false;
1847                 doingNTLM2ndStage = false;
1848                 if (!isUserServerAuth)
1849                     requests.remove(&quot;Authorization&quot;);
1850                 if (!isUserProxyAuth)
1851                     requests.remove(&quot;Proxy-Authorization&quot;);
1852 
1853                 if (respCode == HTTP_OK) {
1854                     checkResponseCredentials (false);
1855                 } else {
1856                     needToCheck = false;
1857                 }
1858 
1859                 // a flag need to clean
1860                 needToCheck = true;
1861 
1862                 if (followRedirect()) {
1863                     /* if we should follow a redirect, then the followRedirects()
1864                      * method will disconnect() and re-connect us to the new
1865                      * location
1866                      */
1867                     redirects++;
1868 
1869                     // redirecting HTTP response may have set cookie, so
1870                     // need to re-generate request header
1871                     setCookieHeader();
1872 
1873                     continue;
1874                 }
1875 
1876                 try {
1877                     cl = Long.parseLong(responses.findValue(&quot;content-length&quot;));
1878                 } catch (Exception exc) { };
1879 
1880                 if (method.equals(&quot;HEAD&quot;) || cl == 0 ||
1881                     respCode == HTTP_NOT_MODIFIED ||
1882                     respCode == HTTP_NO_CONTENT) {
1883 
1884                     if (pi != null) {
1885                         pi.finishTracking();
1886                         pi = null;
1887                     }
1888                     http.finished();
1889                     http = null;
1890                     inputStream = new EmptyInputStream();
1891                     connected = false;
1892                 }
1893 
1894                 if (respCode == 200 || respCode == 203 || respCode == 206 ||
1895                     respCode == 300 || respCode == 301 || respCode == 410) {
1896                     if (cacheHandler != null &amp;&amp; getUseCaches()) {
1897                         // give cache a chance to save response in cache
1898                         URI uri = ParseUtil.toURI(url);
1899                         if (uri != null) {
1900                             URLConnection uconn = this;
1901                             if (&quot;https&quot;.equalsIgnoreCase(uri.getScheme())) {
1902                                 try {
1903                                 // use reflection to get to the public
1904                                 // HttpsURLConnection instance saved in
1905                                 // DelegateHttpsURLConnection
1906                                 uconn = (URLConnection)this.getClass().getField(&quot;httpsURLConnection&quot;).get(this);
1907                                 } catch (IllegalAccessException |
1908                                          NoSuchFieldException e) {
1909                                     // ignored; use &#39;this&#39;
1910                                 }
1911                             }
1912                             CacheRequest cacheRequest =
1913                                 cacheHandler.put(uri, uconn);
1914                             if (cacheRequest != null &amp;&amp; http != null) {
1915                                 http.setCacheRequest(cacheRequest);
1916                                 inputStream = new HttpInputStream(inputStream, cacheRequest);
1917                             }
1918                         }
1919                     }
1920                 }
1921 
1922                 if (!(inputStream instanceof HttpInputStream)) {
1923                     inputStream = new HttpInputStream(inputStream);
1924                 }
1925 
1926                 if (respCode &gt;= 400) {
1927                     if (respCode == 404 || respCode == 410) {
1928                         throw new FileNotFoundException(url.toString());
1929                     } else {
1930                         throw new java.io.IOException(&quot;Server returned HTTP&quot; +
1931                               &quot; response code: &quot; + respCode + &quot; for URL: &quot; +
1932                               url.toString());
1933                     }
1934                 }
1935                 poster = null;
1936                 strOutputStream = null;
1937                 return inputStream;
1938             } while (redirects &lt; maxRedirects);
1939 
1940             throw new ProtocolException(&quot;Server redirected too many &quot; +
1941                                         &quot; times (&quot;+ redirects + &quot;)&quot;);
1942         } catch (RuntimeException e) {
1943             disconnectInternal();
1944             rememberedException = e;
1945             throw e;
1946         } catch (IOException e) {
1947             rememberedException = e;
1948 
1949             // buffer the error stream if bytes &lt; 4k
1950             // and it can be buffered within 1 second
1951             String te = responses.findValue(&quot;Transfer-Encoding&quot;);
1952             if (http != null &amp;&amp; http.isKeepingAlive() &amp;&amp; enableESBuffer &amp;&amp;
1953                 (cl &gt; 0 || (te != null &amp;&amp; te.equalsIgnoreCase(&quot;chunked&quot;)))) {
1954                 errorStream = ErrorStream.getErrorStream(inputStream, cl, http);
1955             }
1956             throw e;
1957         } finally {
1958             if (proxyAuthKey != null) {
1959                 AuthenticationInfo.endAuthRequest(proxyAuthKey);
1960             }
1961             if (serverAuthKey != null) {
1962                 AuthenticationInfo.endAuthRequest(serverAuthKey);
1963             }
1964         }
1965     }
1966 
1967     /*
1968      * Creates a chained exception that has the same type as
1969      * original exception and with the same message. Right now,
1970      * there is no convenient APIs for doing so.
1971      */
1972     private IOException getChainedException(final IOException rememberedException) {
1973         try {
1974             final Object[] args = { rememberedException.getMessage() };
1975             IOException chainedException =
1976                 java.security.AccessController.doPrivileged(
1977                     new java.security.PrivilegedExceptionAction&lt;&gt;() {
1978                         public IOException run() throws Exception {
1979                             return (IOException)
1980                                 rememberedException.getClass()
1981                                 .getConstructor(new Class&lt;?&gt;[] { String.class })
1982                                 .newInstance(args);
1983                         }
1984                     });
1985             chainedException.initCause(rememberedException);
1986             return chainedException;
1987         } catch (Exception ignored) {
1988             return rememberedException;
1989         }
1990     }
1991 
1992     @Override
1993     public InputStream getErrorStream() {
1994         if (connected &amp;&amp; responseCode &gt;= 400) {
1995             // Client Error 4xx and Server Error 5xx
1996             if (errorStream != null) {
1997                 return errorStream;
1998             } else if (inputStream != null) {
1999                 return inputStream;
2000             }
2001         }
2002         return null;
2003     }
2004 
2005     /**
2006      * set or reset proxy authentication info in request headers
2007      * after receiving a 407 error. In the case of NTLM however,
2008      * receiving a 407 is normal and we just skip the stale check
2009      * because ntlm does not support this feature.
2010      */
2011     private AuthenticationInfo
2012         resetProxyAuthentication(AuthenticationInfo proxyAuthentication, AuthenticationHeader auth) throws IOException {
2013         if ((proxyAuthentication != null )&amp;&amp;
2014              proxyAuthentication.getAuthScheme() != NTLM) {
2015             String raw = auth.raw();
2016             if (proxyAuthentication.isAuthorizationStale (raw)) {
2017                 /* we can retry with the current credentials */
2018                 String value;
2019                 if (proxyAuthentication instanceof DigestAuthentication) {
2020                     DigestAuthentication digestProxy = (DigestAuthentication)
2021                         proxyAuthentication;
2022                     if (tunnelState() == TunnelState.SETUP) {
2023                         value = digestProxy.getHeaderValue(connectRequestURI(url), HTTP_CONNECT);
2024                     } else {
2025                         value = digestProxy.getHeaderValue(getRequestURI(), method);
2026                     }
2027                 } else {
2028                     value = proxyAuthentication.getHeaderValue(url, method);
2029                 }
2030                 requests.set(proxyAuthentication.getHeaderName(), value);
2031                 currentProxyCredentials = proxyAuthentication;
2032                 return proxyAuthentication;
2033             } else {
2034                 proxyAuthentication.removeFromCache();
2035             }
2036         }
2037         proxyAuthentication = getHttpProxyAuthentication(auth);
2038         currentProxyCredentials = proxyAuthentication;
2039         return  proxyAuthentication;
2040     }
2041 
2042     /**
2043      * Returns the tunnel state.
2044      *
2045      * @return  the state
2046      */
2047     TunnelState tunnelState() {
2048         return tunnelState;
2049     }
2050 
2051     /**
2052      * Set the tunneling status.
2053      *
2054      * @param tunnelState the state
2055      */
2056     public void setTunnelState(TunnelState tunnelState) {
2057         this.tunnelState = tunnelState;
2058     }
2059 
2060     /**
2061      * establish a tunnel through proxy server
2062      */
2063     public synchronized void doTunneling() throws IOException {
2064         int retryTunnel = 0;
2065         String statusLine = &quot;&quot;;
2066         int respCode = 0;
2067         AuthenticationInfo proxyAuthentication = null;
2068         String proxyHost = null;
2069         int proxyPort = -1;
2070 
2071         // save current requests so that they can be restored after tunnel is setup.
2072         MessageHeader savedRequests = requests;
2073         requests = new MessageHeader();
2074 
2075         // Read comments labeled &quot;Failed Negotiate&quot; for details.
2076         boolean inNegotiateProxy = false;
2077 
2078         try {
2079             /* Actively setting up a tunnel */
2080             setTunnelState(TunnelState.SETUP);
2081 
2082             do {
2083                 if (!checkReuseConnection()) {
2084                     proxiedConnect(url, proxyHost, proxyPort, false);
2085                 }
2086                 // send the &quot;CONNECT&quot; request to establish a tunnel
2087                 // through proxy server
2088                 sendCONNECTRequest();
2089                 responses.reset();
2090 
2091                 // There is no need to track progress in HTTP Tunneling,
2092                 // so ProgressSource is null.
2093                 http.parseHTTP(responses, null, this);
2094 
2095                 /* Log the response to the CONNECT */
2096                 if (logger.isLoggable(PlatformLogger.Level.FINE)) {
2097                     logger.fine(responses.toString());
2098                 }
2099 
2100                 if (responses.filterNTLMResponses(&quot;Proxy-Authenticate&quot;)) {
2101                     if (logger.isLoggable(PlatformLogger.Level.FINE)) {
2102                         logger.fine(&quot;&gt;&gt;&gt;&gt; Headers are filtered&quot;);
2103                         logger.fine(responses.toString());
2104                     }
2105                 }
2106 
2107                 statusLine = responses.getValue(0);
2108                 StringTokenizer st = new StringTokenizer(statusLine);
2109                 st.nextToken();
2110                 respCode = Integer.parseInt(st.nextToken().trim());
2111                 if (respCode == HTTP_PROXY_AUTH) {
2112                     // Read comments labeled &quot;Failed Negotiate&quot; for details.
2113                     boolean dontUseNegotiate = false;
2114                     Iterator&lt;String&gt; iter = responses.multiValueIterator(&quot;Proxy-Authenticate&quot;);
2115                     while (iter.hasNext()) {
2116                         String value = iter.next().trim();
2117                         if (value.equalsIgnoreCase(&quot;Negotiate&quot;) ||
2118                                 value.equalsIgnoreCase(&quot;Kerberos&quot;)) {
2119                             if (!inNegotiateProxy) {
2120                                 inNegotiateProxy = true;
2121                             } else {
2122                                 dontUseNegotiate = true;
2123                                 doingNTLMp2ndStage = false;
2124                                 proxyAuthentication = null;
2125                             }
2126                             break;
2127                         }
2128                     }
2129 
2130                     AuthenticationHeader authhdr = new AuthenticationHeader(
2131                             &quot;Proxy-Authenticate&quot;,
2132                             responses,
2133                             new HttpCallerInfo(url,
2134                                                http.getProxyHostUsed(),
2135                                                http.getProxyPortUsed(),
2136                                                authenticator),
2137                             dontUseNegotiate,
2138                             disabledTunnelingSchemes
2139                     );
2140                     if (!doingNTLMp2ndStage) {
2141                         proxyAuthentication =
2142                             resetProxyAuthentication(proxyAuthentication, authhdr);
2143                         if (proxyAuthentication != null) {
2144                             proxyHost = http.getProxyHostUsed();
2145                             proxyPort = http.getProxyPortUsed();
2146                             disconnectInternal();
2147                             retryTunnel++;
2148                             continue;
2149                         }
2150                     } else {
2151                         String raw = responses.findValue (&quot;Proxy-Authenticate&quot;);
2152                         reset ();
2153                         if (!proxyAuthentication.setHeaders(this,
2154                                                 authhdr.headerParser(), raw)) {
2155                             disconnectInternal();
2156                             throw new IOException (&quot;Authentication failure&quot;);
2157                         }
2158                         authObj = null;
2159                         doingNTLMp2ndStage = false;
2160                         continue;
2161                     }
2162                 }
2163                 // cache proxy authentication info
2164                 if (proxyAuthentication != null) {
2165                     // cache auth info on success, domain header not relevant.
2166                     proxyAuthentication.addToCache();
2167                 }
2168 
2169                 if (respCode == HTTP_OK) {
2170                     setTunnelState(TunnelState.TUNNELING);
2171                     break;
2172                 }
2173                 // we don&#39;t know how to deal with other response code
2174                 // so disconnect and report error
2175                 disconnectInternal();
2176                 setTunnelState(TunnelState.NONE);
2177                 break;
2178             } while (retryTunnel &lt; maxRedirects);
2179 
2180             if (retryTunnel &gt;= maxRedirects || (respCode != HTTP_OK)) {
2181                 if (respCode != HTTP_PROXY_AUTH) {
2182                     // remove all but authenticate responses
2183                     responses.reset();
2184                 }
2185                 throw new IOException(&quot;Unable to tunnel through proxy.&quot;+
2186                                       &quot; Proxy returns \&quot;&quot; +
2187                                       statusLine + &quot;\&quot;&quot;);
2188             }
2189         } finally  {
2190             if (proxyAuthKey != null) {
2191                 AuthenticationInfo.endAuthRequest(proxyAuthKey);
2192             }
2193         }
2194 
2195         // restore original request headers
2196         requests = savedRequests;
2197 
2198         // reset responses
2199         responses.reset();
2200     }
2201 
2202     static String connectRequestURI(URL url) {
2203         String host = url.getHost();
2204         int port = url.getPort();
2205         port = port != -1 ? port : url.getDefaultPort();
2206 
2207         return host + &quot;:&quot; + port;
2208     }
2209 
2210     /**
2211      * send a CONNECT request for establishing a tunnel to proxy server
2212      */
2213     private void sendCONNECTRequest() throws IOException {
2214         int port = url.getPort();
2215 
2216         requests.set(0, HTTP_CONNECT + &quot; &quot; + connectRequestURI(url)
2217                          + &quot; &quot; + httpVersion, null);
2218         requests.setIfNotSet(&quot;User-Agent&quot;, userAgent);
2219 
2220         String host = url.getHost();
2221         if (port != -1 &amp;&amp; port != url.getDefaultPort()) {
2222             host += &quot;:&quot; + String.valueOf(port);
2223         }
2224         requests.setIfNotSet(&quot;Host&quot;, host);
2225 
2226         // Not really necessary for a tunnel, but can&#39;t hurt
2227         requests.setIfNotSet(&quot;Accept&quot;, acceptString);
2228 
2229         if (http.getHttpKeepAliveSet()) {
2230             requests.setIfNotSet(&quot;Proxy-Connection&quot;, &quot;keep-alive&quot;);
2231         }
2232 
2233         setPreemptiveProxyAuthentication(requests);
2234 
2235          /* Log the CONNECT request */
2236         if (logger.isLoggable(PlatformLogger.Level.FINE)) {
2237             logger.fine(requests.toString());
2238         }
2239 
2240         http.writeRequests(requests, null);
2241     }
2242 
2243     /**
2244      * Sets pre-emptive proxy authentication in header
2245      */
2246     private void setPreemptiveProxyAuthentication(MessageHeader requests) throws IOException {
2247         AuthenticationInfo pauth
2248             = AuthenticationInfo.getProxyAuth(http.getProxyHostUsed(),
2249                                               http.getProxyPortUsed(),
2250                                               getAuthenticatorKey());
2251         if (pauth != null &amp;&amp; pauth.supportsPreemptiveAuthorization()) {
2252             String value;
2253             if (pauth instanceof DigestAuthentication) {
2254                 DigestAuthentication digestProxy = (DigestAuthentication) pauth;
2255                 if (tunnelState() == TunnelState.SETUP) {
2256                     value = digestProxy
2257                         .getHeaderValue(connectRequestURI(url), HTTP_CONNECT);
2258                 } else {
2259                     value = digestProxy.getHeaderValue(getRequestURI(), method);
2260                 }
2261             } else {
2262                 value = pauth.getHeaderValue(url, method);
2263             }
2264 
2265             // Sets &quot;Proxy-authorization&quot;
2266             requests.set(pauth.getHeaderName(), value);
2267             currentProxyCredentials = pauth;
2268         }
2269     }
2270 
2271     /**
2272      * Gets the authentication for an HTTP proxy, and applies it to
2273      * the connection.
2274      */
2275     @SuppressWarnings(&quot;fallthrough&quot;)
2276     private AuthenticationInfo getHttpProxyAuthentication (AuthenticationHeader authhdr) {
2277         /* get authorization from authenticator */
2278         AuthenticationInfo ret = null;
2279         String raw = authhdr.raw();
2280         String host = http.getProxyHostUsed();
2281         int port = http.getProxyPortUsed();
2282         if (host != null &amp;&amp; authhdr.isPresent()) {
2283             HeaderParser p = authhdr.headerParser();
2284             String realm = p.findValue(&quot;realm&quot;);
2285             String charset = p.findValue(&quot;charset&quot;);
2286             boolean isUTF8 = (charset != null &amp;&amp; charset.equalsIgnoreCase(&quot;UTF-8&quot;));
2287             String scheme = authhdr.scheme();
2288             AuthScheme authScheme = UNKNOWN;
2289             if (&quot;basic&quot;.equalsIgnoreCase(scheme)) {
2290                 authScheme = BASIC;
2291             } else if (&quot;digest&quot;.equalsIgnoreCase(scheme)) {
2292                 authScheme = DIGEST;
2293             } else if (&quot;ntlm&quot;.equalsIgnoreCase(scheme)) {
2294                 authScheme = NTLM;
2295                 doingNTLMp2ndStage = true;
2296             } else if (&quot;Kerberos&quot;.equalsIgnoreCase(scheme)) {
2297                 authScheme = KERBEROS;
2298                 doingNTLMp2ndStage = true;
2299             } else if (&quot;Negotiate&quot;.equalsIgnoreCase(scheme)) {
2300                 authScheme = NEGOTIATE;
2301                 doingNTLMp2ndStage = true;
2302             }
2303 
2304             if (realm == null)
2305                 realm = &quot;&quot;;
2306             proxyAuthKey = AuthenticationInfo.getProxyAuthKey(host, port, realm,
2307                                 authScheme, getAuthenticatorKey());
2308             ret = AuthenticationInfo.getProxyAuth(proxyAuthKey);
2309             if (ret == null) {
2310                 switch (authScheme) {
2311                 case BASIC:
2312                     InetAddress addr = null;
2313                     try {
2314                         final String finalHost = host;
2315                         addr = java.security.AccessController.doPrivileged(
2316                             new java.security.PrivilegedExceptionAction&lt;&gt;() {
2317                                 public InetAddress run()
2318                                     throws java.net.UnknownHostException {
2319                                     return InetAddress.getByName(finalHost);
2320                                 }
2321                             });
2322                     } catch (java.security.PrivilegedActionException ignored) {
2323                         // User will have an unknown host.
2324                     }
2325                     PasswordAuthentication a =
2326                         privilegedRequestPasswordAuthentication(
2327                                     authenticator,
2328                                     host, addr, port, &quot;http&quot;,
2329                                     realm, scheme, url, RequestorType.PROXY);
2330                     if (a != null) {
2331                         ret = new BasicAuthentication(true, host, port, realm, a,
2332                                              isUTF8, getAuthenticatorKey());
2333                     }
2334                     break;
2335                 case DIGEST:
2336                     a = privilegedRequestPasswordAuthentication(
2337                                     authenticator,
2338                                     host, null, port, url.getProtocol(),
2339                                     realm, scheme, url, RequestorType.PROXY);
2340                     if (a != null) {
2341                         DigestAuthentication.Parameters params =
2342                             new DigestAuthentication.Parameters();
2343                         ret = new DigestAuthentication(true, host, port, realm,
2344                                              scheme, a, params,
2345                                              getAuthenticatorKey());
2346                     }
2347                     break;
2348                 case NTLM:
2349                     if (NTLMAuthenticationProxy.supported) {
2350                         /* tryTransparentNTLMProxy will always be true the first
2351                          * time around, but verify that the platform supports it
2352                          * otherwise don&#39;t try. */
2353                         if (tryTransparentNTLMProxy) {
2354                             tryTransparentNTLMProxy =
2355                                     NTLMAuthenticationProxy.supportsTransparentAuth;
2356                             /* If the platform supports transparent authentication
2357                              * then normally it&#39;s ok to do transparent auth to a proxy
2358                                          * because we generally trust proxies (chosen by the user)
2359                                          * But not in the case of 305 response where the server
2360                              * chose it. */
2361                             if (tryTransparentNTLMProxy &amp;&amp; useProxyResponseCode) {
2362                                 tryTransparentNTLMProxy = false;
2363                             }
2364 
2365                         }
2366                         a = null;
2367                         if (tryTransparentNTLMProxy) {
2368                             logger.finest(&quot;Trying Transparent NTLM authentication&quot;);
2369                         } else {
2370                             a = privilegedRequestPasswordAuthentication(
2371                                                 authenticator,
2372                                                 host, null, port, url.getProtocol(),
2373                                                 &quot;&quot;, scheme, url, RequestorType.PROXY);
2374                         }
2375                         /* If we are not trying transparent authentication then
2376                          * we need to have a PasswordAuthentication instance. For
2377                          * transparent authentication (Windows only) the username
2378                          * and password will be picked up from the current logged
2379                          * on users credentials.
2380                         */
2381                         if (tryTransparentNTLMProxy ||
2382                               (!tryTransparentNTLMProxy &amp;&amp; a != null)) {
2383                             ret = NTLMAuthenticationProxy.proxy.create(true, host,
2384                                     port, a, getAuthenticatorKey());
2385                         }
2386 
2387                         /* set to false so that we do not try again */
2388                         tryTransparentNTLMProxy = false;
2389                     }
2390                     break;
2391                 case NEGOTIATE:
2392                     ret = new NegotiateAuthentication(new HttpCallerInfo(authhdr.getHttpCallerInfo(), &quot;Negotiate&quot;));
2393                     break;
2394                 case KERBEROS:
2395                     ret = new NegotiateAuthentication(new HttpCallerInfo(authhdr.getHttpCallerInfo(), &quot;Kerberos&quot;));
2396                     break;
2397                 case UNKNOWN:
2398                     if (logger.isLoggable(PlatformLogger.Level.FINEST)) {
2399                         logger.finest(&quot;Unknown/Unsupported authentication scheme: &quot; + scheme);
2400                     }
2401                 /*fall through*/
2402                 default:
2403                     throw new AssertionError(&quot;should not reach here&quot;);
2404                 }
2405             }
2406             // For backwards compatibility, we also try defaultAuth
2407             // REMIND:  Get rid of this for JDK2.0.
2408 
2409             if (ret == null &amp;&amp; defaultAuth != null
2410                 &amp;&amp; defaultAuth.schemeSupported(scheme)) {
2411                 try {
2412                     URL u = new URL(&quot;http&quot;, host, port, &quot;/&quot;);
2413                     String a = defaultAuth.authString(u, scheme, realm);
2414                     if (a != null) {
2415                         ret = new BasicAuthentication (true, host, port, realm, a,
2416                                   getAuthenticatorKey());
2417                         // not in cache by default - cache on success
2418                     }
2419                 } catch (java.net.MalformedURLException ignored) {
2420                 }
2421             }
2422             if (ret != null) {
2423                 if (!ret.setHeaders(this, p, raw)) {
2424                     ret = null;
2425                 }
2426             }
2427         }
2428         if (logger.isLoggable(PlatformLogger.Level.FINER)) {
2429             logger.finer(&quot;Proxy Authentication for &quot; + authhdr.toString() +&quot; returned &quot; + (ret != null ? ret.toString() : &quot;null&quot;));
2430         }
2431         return ret;
2432     }
2433 
2434     /**
2435      * Gets the authentication for an HTTP server, and applies it to
2436      * the connection.
2437      * @param authHdr the AuthenticationHeader which tells what auth scheme is
2438      * preferred.
2439      */
2440     @SuppressWarnings(&quot;fallthrough&quot;)
2441     private AuthenticationInfo getServerAuthentication (AuthenticationHeader authhdr) {
2442         /* get authorization from authenticator */
2443         AuthenticationInfo ret = null;
2444         String raw = authhdr.raw();
2445         /* When we get an NTLM auth from cache, don&#39;t set any special headers */
2446         if (authhdr.isPresent()) {
2447             HeaderParser p = authhdr.headerParser();
2448             String realm = p.findValue(&quot;realm&quot;);
2449             String scheme = authhdr.scheme();
2450             String charset = p.findValue(&quot;charset&quot;);
2451             boolean isUTF8 = (charset != null &amp;&amp; charset.equalsIgnoreCase(&quot;UTF-8&quot;));
2452             AuthScheme authScheme = UNKNOWN;
2453             if (&quot;basic&quot;.equalsIgnoreCase(scheme)) {
2454                 authScheme = BASIC;
2455             } else if (&quot;digest&quot;.equalsIgnoreCase(scheme)) {
2456                 authScheme = DIGEST;
2457             } else if (&quot;ntlm&quot;.equalsIgnoreCase(scheme)) {
2458                 authScheme = NTLM;
2459                 doingNTLM2ndStage = true;
2460             } else if (&quot;Kerberos&quot;.equalsIgnoreCase(scheme)) {
2461                 authScheme = KERBEROS;
2462                 doingNTLM2ndStage = true;
2463             } else if (&quot;Negotiate&quot;.equalsIgnoreCase(scheme)) {
2464                 authScheme = NEGOTIATE;
2465                 doingNTLM2ndStage = true;
2466             }
2467 
2468             domain = p.findValue (&quot;domain&quot;);
2469             if (realm == null)
2470                 realm = &quot;&quot;;
2471             serverAuthKey = AuthenticationInfo.getServerAuthKey(url, realm, authScheme,
2472                                                getAuthenticatorKey());
2473             ret = AuthenticationInfo.getServerAuth(serverAuthKey);
2474             InetAddress addr = null;
2475             if (ret == null) {
2476                 try {
2477                     addr = InetAddress.getByName(url.getHost());
2478                 } catch (java.net.UnknownHostException ignored) {
2479                     // User will have addr = null
2480                 }
2481             }
2482             // replacing -1 with default port for a protocol
2483             int port = url.getPort();
2484             if (port == -1) {
2485                 port = url.getDefaultPort();
2486             }
2487             if (ret == null) {
2488                 switch(authScheme) {
2489                 case KERBEROS:
2490                     ret = new NegotiateAuthentication(new HttpCallerInfo(authhdr.getHttpCallerInfo(), &quot;Kerberos&quot;));
2491                     break;
2492                 case NEGOTIATE:
2493                     ret = new NegotiateAuthentication(new HttpCallerInfo(authhdr.getHttpCallerInfo(), &quot;Negotiate&quot;));
2494                     break;
2495                 case BASIC:
2496                     PasswordAuthentication a =
2497                         privilegedRequestPasswordAuthentication(
2498                             authenticator,
2499                             url.getHost(), addr, port, url.getProtocol(),
2500                             realm, scheme, url, RequestorType.SERVER);
2501                     if (a != null) {
2502                         ret = new BasicAuthentication(false, url, realm, a,
2503                                     isUTF8, getAuthenticatorKey());
2504                     }
2505                     break;
2506                 case DIGEST:
2507                     a = privilegedRequestPasswordAuthentication(
2508                             authenticator,
2509                             url.getHost(), addr, port, url.getProtocol(),
2510                             realm, scheme, url, RequestorType.SERVER);
2511                     if (a != null) {
2512                         digestparams = new DigestAuthentication.Parameters();
2513                         ret = new DigestAuthentication(false, url, realm, scheme,
2514                                     a, digestparams,
2515                                     getAuthenticatorKey());
2516                     }
2517                     break;
2518                 case NTLM:
2519                     if (NTLMAuthenticationProxy.supported) {
2520                         URL url1;
2521                         try {
2522                             url1 = new URL (url, &quot;/&quot;); /* truncate the path */
2523                         } catch (Exception e) {
2524                             url1 = url;
2525                         }
2526 
2527                         /* tryTransparentNTLMServer will always be true the first
2528                          * time around, but verify that the platform supports it
2529                          * otherwise don&#39;t try. */
2530                         if (tryTransparentNTLMServer) {
2531                             tryTransparentNTLMServer =
2532                                     NTLMAuthenticationProxy.supportsTransparentAuth;
2533                             /* If the platform supports transparent authentication
2534                              * then check if we are in a secure environment
2535                              * whether, or not, we should try transparent authentication.*/
2536                             if (tryTransparentNTLMServer) {
2537                                 tryTransparentNTLMServer =
2538                                         NTLMAuthenticationProxy.isTrustedSite(url);
2539                             }
2540                         }
2541                         a = null;
2542                         if (tryTransparentNTLMServer) {
2543                             logger.finest(&quot;Trying Transparent NTLM authentication&quot;);
2544                         } else {
2545                             a = privilegedRequestPasswordAuthentication(
2546                                 authenticator,
2547                                 url.getHost(), addr, port, url.getProtocol(),
2548                                 &quot;&quot;, scheme, url, RequestorType.SERVER);
2549                         }
2550 
2551                         /* If we are not trying transparent authentication then
2552                          * we need to have a PasswordAuthentication instance. For
2553                          * transparent authentication (Windows only) the username
2554                          * and password will be picked up from the current logged
2555                          * on users credentials.
2556                          */
2557                         if (tryTransparentNTLMServer ||
2558                               (!tryTransparentNTLMServer &amp;&amp; a != null)) {
2559                             ret = NTLMAuthenticationProxy.proxy.create(false,
2560                                      url1, a, getAuthenticatorKey());
2561                         }
2562 
2563                         /* set to false so that we do not try again */
2564                         tryTransparentNTLMServer = false;
2565                     }
2566                     break;
2567                 case UNKNOWN:
2568                     if (logger.isLoggable(PlatformLogger.Level.FINEST)) {
2569                         logger.finest(&quot;Unknown/Unsupported authentication scheme: &quot; + scheme);
2570                     }
2571                 /*fall through*/
2572                 default:
2573                     throw new AssertionError(&quot;should not reach here&quot;);
2574                 }
2575             }
2576 
2577             // For backwards compatibility, we also try defaultAuth
2578             // REMIND:  Get rid of this for JDK2.0.
2579 
2580             if (ret == null &amp;&amp; defaultAuth != null
2581                 &amp;&amp; defaultAuth.schemeSupported(scheme)) {
2582                 String a = defaultAuth.authString(url, scheme, realm);
2583                 if (a != null) {
2584                     ret = new BasicAuthentication (false, url, realm, a,
2585                                     getAuthenticatorKey());
2586                     // not in cache by default - cache on success
2587                 }
2588             }
2589 
2590             if (ret != null ) {
2591                 if (!ret.setHeaders(this, p, raw)) {
2592                     ret = null;
2593                 }
2594             }
2595         }
2596         if (logger.isLoggable(PlatformLogger.Level.FINER)) {
2597             logger.finer(&quot;Server Authentication for &quot; + authhdr.toString() +&quot; returned &quot; + (ret != null ? ret.toString() : &quot;null&quot;));
2598         }
2599         return ret;
2600     }
2601 
2602     /* inclose will be true if called from close(), in which case we
2603      * force the call to check because this is the last chance to do so.
2604      * If not in close(), then the authentication info could arrive in a trailer
2605      * field, which we have not read yet.
2606      */
2607     private void checkResponseCredentials (boolean inClose) throws IOException {
2608         try {
2609             if (!needToCheck)
2610                 return;
2611             if ((validateProxy &amp;&amp; currentProxyCredentials != null) &amp;&amp;
2612                 (currentProxyCredentials instanceof DigestAuthentication)) {
2613                 String raw = responses.findValue (&quot;Proxy-Authentication-Info&quot;);
2614                 if (inClose || (raw != null)) {
2615                     DigestAuthentication da = (DigestAuthentication)
2616                         currentProxyCredentials;
2617                     da.checkResponse (raw, method, getRequestURI());
2618                     currentProxyCredentials = null;
2619                 }
2620             }
2621             if ((validateServer &amp;&amp; currentServerCredentials != null) &amp;&amp;
2622                 (currentServerCredentials instanceof DigestAuthentication)) {
2623                 String raw = responses.findValue (&quot;Authentication-Info&quot;);
2624                 if (inClose || (raw != null)) {
2625                     DigestAuthentication da = (DigestAuthentication)
2626                         currentServerCredentials;
2627                     da.checkResponse (raw, method, url);
2628                     currentServerCredentials = null;
2629                 }
2630             }
2631             if ((currentServerCredentials==null) &amp;&amp; (currentProxyCredentials == null)) {
2632                 needToCheck = false;
2633             }
2634         } catch (IOException e) {
2635             disconnectInternal();
2636             connected = false;
2637             throw e;
2638         }
2639     }
2640 
2641    /* The request URI used in the request line for this request.
2642     * Also, needed for digest authentication
2643     */
2644 
2645     String requestURI = null;
2646 
2647     String getRequestURI() throws IOException {
2648         if (requestURI == null) {
2649             requestURI = http.getURLFile();
2650         }
2651         return requestURI;
2652     }
2653 
2654     /* Tells us whether to follow a redirect.  If so, it
2655      * closes the connection (break any keep-alive) and
2656      * resets the url, re-connects, and resets the request
2657      * property.
2658      */
2659     private boolean followRedirect() throws IOException {
2660         if (!getInstanceFollowRedirects()) {
2661             return false;
2662         }
2663 
2664         final int stat = getResponseCode();
2665         if (stat &lt; 300 || stat &gt; 307 || stat == 306
2666                                 || stat == HTTP_NOT_MODIFIED) {
2667             return false;
2668         }
2669         final String loc = getHeaderField(&quot;Location&quot;);
2670         if (loc == null) {
2671             /* this should be present - if not, we have no choice
2672              * but to go forward w/ the response we got
2673              */
2674             return false;
2675         }
2676 
2677         URL locUrl;
2678         try {
2679             locUrl = new URL(loc);
2680             if (!url.getProtocol().equalsIgnoreCase(locUrl.getProtocol())) {
2681                 return false;
2682             }
2683 
2684         } catch (MalformedURLException mue) {
2685           // treat loc as a relative URI to conform to popular browsers
2686           locUrl = new URL(url, loc);
2687         }
2688 
2689         final URL locUrl0 = locUrl;
2690         socketPermission = null; // force recalculation
2691         SocketPermission p = URLtoSocketPermission(locUrl);
2692 
2693         if (p != null) {
2694             try {
2695                 return AccessController.doPrivilegedWithCombiner(
2696                     new PrivilegedExceptionAction&lt;&gt;() {
2697                         public Boolean run() throws IOException {
2698                             return followRedirect0(loc, stat, locUrl0);
2699                         }
2700                     }, null, p
2701                 );
2702             } catch (PrivilegedActionException e) {
2703                 throw (IOException) e.getException();
2704             }
2705         } else {
2706             // run without additional permission
2707             return followRedirect0(loc, stat, locUrl);
2708         }
2709     }
2710 
2711     /* Tells us whether to follow a redirect.  If so, it
2712      * closes the connection (break any keep-alive) and
2713      * resets the url, re-connects, and resets the request
2714      * property.
2715      */
2716     private boolean followRedirect0(String loc, int stat, URL locUrl)
2717         throws IOException
2718     {
2719         disconnectInternal();
2720         if (streaming()) {
2721             throw new HttpRetryException (RETRY_MSG3, stat, loc);
2722         }
2723         if (logger.isLoggable(PlatformLogger.Level.FINE)) {
2724             logger.fine(&quot;Redirected from &quot; + url + &quot; to &quot; + locUrl);
2725         }
2726 
2727         // clear out old response headers!!!!
2728         responses = new MessageHeader();
2729         if (stat == HTTP_USE_PROXY) {
2730             /* This means we must re-request the resource through the
2731              * proxy denoted in the &quot;Location:&quot; field of the response.
2732              * Judging by the spec, the string in the Location header
2733              * _should_ denote a URL - let&#39;s hope for &quot;http://my.proxy.org&quot;
2734              * Make a new HttpClient to the proxy, using HttpClient&#39;s
2735              * Instance-specific proxy fields, but note we&#39;re still fetching
2736              * the same URL.
2737              */
2738             String proxyHost = locUrl.getHost();
2739             int proxyPort = locUrl.getPort();
2740 
2741             SecurityManager security = System.getSecurityManager();
2742             if (security != null) {
2743                 security.checkConnect(proxyHost, proxyPort);
2744             }
2745 
2746             setProxiedClient (url, proxyHost, proxyPort);
2747             requests.set(0, method + &quot; &quot; + getRequestURI()+&quot; &quot;  +
2748                              httpVersion, null);
2749             connected = true;
2750             // need to remember this in case NTLM proxy authentication gets
2751             // used. We can&#39;t use transparent authentication when user
2752             // doesn&#39;t know about proxy.
2753             useProxyResponseCode = true;
2754         } else {
2755             final URL prevURL = url;
2756 
2757             // maintain previous headers, just change the name
2758             // of the file we&#39;re getting
2759             url = locUrl;
2760             requestURI = null; // force it to be recalculated
2761             if (method.equals(&quot;POST&quot;) &amp;&amp; !Boolean.getBoolean(&quot;http.strictPostRedirect&quot;) &amp;&amp; (stat!=307)) {
2762                 /* The HTTP/1.1 spec says that a redirect from a POST
2763                  * *should not* be immediately turned into a GET, and
2764                  * that some HTTP/1.0 clients incorrectly did this.
2765                  * Correct behavior redirects a POST to another POST.
2766                  * Unfortunately, since most browsers have this incorrect
2767                  * behavior, the web works this way now.  Typical usage
2768                  * seems to be:
2769                  *   POST a login code or passwd to a web page.
2770                  *   after validation, the server redirects to another
2771                  *     (welcome) page
2772                  *   The second request is (erroneously) expected to be GET
2773                  *
2774                  * We will do the incorrect thing (POST--&gt;GET) by default.
2775                  * We will provide the capability to do the &quot;right&quot; thing
2776                  * (POST--&gt;POST) by a system property, &quot;http.strictPostRedirect=true&quot;
2777                  */
2778 
2779                 requests = new MessageHeader();
2780                 setRequests = false;
2781                 super.setRequestMethod(&quot;GET&quot;); // avoid the connecting check
2782                 poster = null;
2783                 if (!checkReuseConnection())
2784                     connect();
2785 
2786                 if (!sameDestination(prevURL, url)) {
2787                     // Ensures pre-redirect user-set cookie will not be reset.
2788                     // CookieHandler, if any, will be queried to determine
2789                     // cookies for redirected URL, if any.
2790                     userCookies = null;
2791                     userCookies2 = null;
2792                 }
2793             } else {
2794                 if (!checkReuseConnection())
2795                     connect();
2796                 /* Even after a connect() call, http variable still can be
2797                  * null, if a ResponseCache has been installed and it returns
2798                  * a non-null CacheResponse instance. So check nullity before using it.
2799                  *
2800                  * And further, if http is null, there&#39;s no need to do anything
2801                  * about request headers because successive http session will use
2802                  * cachedInputStream/cachedHeaders anyway, which is returned by
2803                  * CacheResponse.
2804                  */
2805                 if (http != null) {
2806                     requests.set(0, method + &quot; &quot; + getRequestURI()+&quot; &quot;  +
2807                                  httpVersion, null);
2808                     int port = url.getPort();
2809                     String host = stripIPv6ZoneId(url.getHost());
2810                     if (port != -1 &amp;&amp; port != url.getDefaultPort()) {
2811                         host += &quot;:&quot; + String.valueOf(port);
2812                     }
2813                     requests.set(&quot;Host&quot;, host);
2814                 }
2815 
2816                 if (!sameDestination(prevURL, url)) {
2817                     // Redirecting to a different destination will drop any
2818                     // security-sensitive headers, regardless of whether
2819                     // they are user-set or not. CookieHandler, if any, will be
2820                     // queried to determine cookies for redirected URL, if any.
2821                     userCookies = null;
2822                     userCookies2 = null;
2823                     requests.remove(&quot;Cookie&quot;);
2824                     requests.remove(&quot;Cookie2&quot;);
2825                     requests.remove(&quot;Authorization&quot;);
2826 
2827                     // check for preemptive authorization
2828                     AuthenticationInfo sauth =
2829                             AuthenticationInfo.getServerAuth(url, getAuthenticatorKey());
2830                     if (sauth != null &amp;&amp; sauth.supportsPreemptiveAuthorization() ) {
2831                         // Sets &quot;Authorization&quot;
2832                         requests.setIfNotSet(sauth.getHeaderName(), sauth.getHeaderValue(url,method));
2833                         currentServerCredentials = sauth;
2834                     }
2835                 }
2836             }
2837         }
2838         return true;
2839     }
2840 
2841     /* Returns true iff the given URLs have the same host and effective port. */
2842     private static boolean sameDestination(URL firstURL, URL secondURL) {
2843         assert firstURL.getProtocol().equalsIgnoreCase(secondURL.getProtocol()):
2844                &quot;protocols not equal: &quot; + firstURL +  &quot; - &quot; + secondURL;
2845 
2846         if (!firstURL.getHost().equalsIgnoreCase(secondURL.getHost()))
2847             return false;
2848 
2849         int firstPort = firstURL.getPort();
2850         if (firstPort == -1)
2851             firstPort = firstURL.getDefaultPort();
2852         int secondPort = secondURL.getPort();
2853         if (secondPort == -1)
2854             secondPort = secondURL.getDefaultPort();
2855         if (firstPort != secondPort)
2856             return false;
2857 
2858         return true;
2859     }
2860 
2861     /* dummy byte buffer for reading off socket prior to closing */
2862     byte[] cdata = new byte [128];
2863 
2864     /**
2865      * Reset (without disconnecting the TCP conn) in order to do another transaction with this instance
2866      */
2867     private void reset() throws IOException {
2868         http.reuse = true;
2869         /* must save before calling close */
2870         reuseClient = http;
2871         InputStream is = http.getInputStream();
2872         if (!method.equals(&quot;HEAD&quot;)) {
2873             try {
2874                 /* we want to read the rest of the response without using the
2875                  * hurry mechanism, because that would close the connection
2876                  * if everything is not available immediately
2877                  */
2878                 if ((is instanceof ChunkedInputStream) ||
2879                     (is instanceof MeteredStream)) {
2880                     /* reading until eof will not block */
2881                     while (is.read (cdata) &gt; 0) {}
2882                 } else {
2883                     /* raw stream, which will block on read, so only read
2884                      * the expected number of bytes, probably 0
2885                      */
2886                     long cl = 0;
2887                     int n = 0;
2888                     String cls = responses.findValue (&quot;Content-Length&quot;);
2889                     if (cls != null) {
2890                         try {
2891                             cl = Long.parseLong (cls);
2892                         } catch (NumberFormatException e) {
2893                             cl = 0;
2894                         }
2895                     }
2896                     for (long i=0; i&lt;cl; ) {
2897                         if ((n = is.read (cdata)) == -1) {
2898                             break;
2899                         } else {
2900                             i+= n;
2901                         }
2902                     }
2903                 }
2904             } catch (IOException e) {
2905                 http.reuse = false;
2906                 reuseClient = null;
2907                 disconnectInternal();
2908                 return;
2909             }
2910             try {
2911                 if (is instanceof MeteredStream) {
2912                     is.close();
2913                 }
2914             } catch (IOException e) { }
2915         }
2916         responseCode = -1;
2917         responses = new MessageHeader();
2918         connected = false;
2919     }
2920 
2921     /**
2922      * Disconnect from the web server at the first 401 error. Do not
2923      * disconnect when using a proxy, a good proxy should have already
2924      * closed the connection to the web server.
2925      */
2926     private void disconnectWeb() throws IOException {
2927         if (usingProxyInternal() &amp;&amp; http.isKeepingAlive()) {
2928             responseCode = -1;
2929             // clean up, particularly, skip the content part
2930             // of a 401 error response
2931             reset();
2932         } else {
2933             disconnectInternal();
2934         }
2935     }
2936 
2937     /**
2938      * Disconnect from the server (for internal use)
2939      */
2940     private void disconnectInternal() {
2941         responseCode = -1;
2942         inputStream = null;
2943         if (pi != null) {
2944             pi.finishTracking();
2945             pi = null;
2946         }
2947         if (http != null) {
2948             http.closeServer();
2949             http = null;
2950             connected = false;
2951         }
2952     }
2953 
2954     /**
2955      * Disconnect from the server (public API)
2956      */
2957     public void disconnect() {
2958 
2959         responseCode = -1;
2960         if (pi != null) {
2961             pi.finishTracking();
2962             pi = null;
2963         }
2964 
2965         if (http != null) {
2966             /*
2967              * If we have an input stream this means we received a response
2968              * from the server. That stream may have been read to EOF and
2969              * depending on the stream type may already be closed or
2970              * the http client may be returned to the keep-alive cache.
2971              * If the http client has been returned to the keep-alive cache
2972              * it may be closed (idle timeout) or may be allocated to
2973              * another request.
2974              *
2975              * In other to avoid timing issues we close the input stream
2976              * which will either close the underlying connection or return
2977              * the client to the cache. If there&#39;s a possibility that the
2978              * client has been returned to the cache (ie: stream is a keep
2979              * alive stream or a chunked input stream) then we remove an
2980              * idle connection to the server. Note that this approach
2981              * can be considered an approximation in that we may close a
2982              * different idle connection to that used by the request.
2983              * Additionally it&#39;s possible that we close two connections
2984              * - the first becuase it wasn&#39;t an EOF (and couldn&#39;t be
2985              * hurried) - the second, another idle connection to the
2986              * same server. The is okay because &quot;disconnect&quot; is an
2987              * indication that the application doesn&#39;t intend to access
2988              * this http server for a while.
2989              */
2990 
2991             if (inputStream != null) {
2992                 HttpClient hc = http;
2993 
2994                 // un-synchronized
2995                 boolean ka = hc.isKeepingAlive();
2996 
2997                 try {
2998                     inputStream.close();
2999                 } catch (IOException ioe) { }
3000 
3001                 // if the connection is persistent it may have been closed
3002                 // or returned to the keep-alive cache. If it&#39;s been returned
3003                 // to the keep-alive cache then we would like to close it
3004                 // but it may have been allocated
3005 
3006                 if (ka) {
3007                     hc.closeIdleConnection();
3008                 }
3009 
3010 
3011             } else {
3012                 // We are deliberatly being disconnected so HttpClient
3013                 // should not try to resend the request no matter what stage
3014                 // of the connection we are in.
3015                 http.setDoNotRetry(true);
3016 
3017                 http.closeServer();
3018             }
3019 
3020             //      poster = null;
3021             http = null;
3022             connected = false;
3023         }
3024         cachedInputStream = null;
3025         if (cachedHeaders != null) {
3026             cachedHeaders.reset();
3027         }
3028     }
3029 
3030     /**
3031      * Returns true only if the established connection is using a proxy
3032      */
3033     boolean usingProxyInternal() {
3034         if (http != null) {
3035             return (http.getProxyHostUsed() != null);
3036         }
3037         return false;
3038     }
3039 
3040     /**
3041      * Returns true if the established connection is using a proxy
3042      * or if a proxy is specified for the inactive connection
3043      */
3044     @Override
3045     public boolean usingProxy() {
3046         if (usingProxy || usingProxyInternal())
3047             return true;
3048 
3049         if (instProxy != null)
3050             return instProxy.type().equals(Proxy.Type.HTTP);
3051 
3052         return false;
3053     }
3054 
3055     // constant strings represent set-cookie header names
3056     private static final String SET_COOKIE = &quot;set-cookie&quot;;
3057     private static final String SET_COOKIE2 = &quot;set-cookie2&quot;;
3058 
3059     /**
3060      * Returns a filtered version of the given headers value.
3061      *
3062      * Note: The implementation currently only filters out HttpOnly cookies
3063      *       from Set-Cookie and Set-Cookie2 headers.
3064      */
3065     private String filterHeaderField(String name, String value) {
3066         if (value == null)
3067             return null;
3068 
3069         if (SET_COOKIE.equalsIgnoreCase(name) ||
3070             SET_COOKIE2.equalsIgnoreCase(name)) {
3071 
3072             // Filtering only if there is a cookie handler. [Assumption: the
3073             // cookie handler will store/retrieve the HttpOnly cookies]
3074             if (cookieHandler == null || value.isEmpty())
3075                 return value;
3076 
3077             JavaNetHttpCookieAccess access =
3078                     SharedSecrets.getJavaNetHttpCookieAccess();
3079             StringJoiner retValue = new StringJoiner(&quot;,&quot;);  // RFC 2965, comma separated
3080             List&lt;HttpCookie&gt; cookies = access.parse(value);
3081             for (HttpCookie cookie : cookies) {
3082                 // skip HttpOnly cookies
3083                 if (!cookie.isHttpOnly())
3084                     retValue.add(access.header(cookie));
3085             }
3086             return retValue.toString();
3087         }
3088 
3089         return value;
3090     }
3091 
3092     // Cache the filtered response headers so that they don&#39;t need
3093     // to be generated for every getHeaderFields() call.
3094     private Map&lt;String, List&lt;String&gt;&gt; filteredHeaders;  // null
3095 
3096     private Map&lt;String, List&lt;String&gt;&gt; getFilteredHeaderFields() {
3097         if (filteredHeaders != null)
3098             return filteredHeaders;
3099 
3100         Map&lt;String, List&lt;String&gt;&gt; headers, tmpMap = new HashMap&lt;&gt;();
3101 
3102         if (cachedHeaders != null)
3103             headers = cachedHeaders.getHeaders();
3104         else
3105             headers = responses.getHeaders();
3106 
3107         for (Map.Entry&lt;String, List&lt;String&gt;&gt; e: headers.entrySet()) {
3108             String key = e.getKey();
3109             List&lt;String&gt; values = e.getValue(), filteredVals = new ArrayList&lt;&gt;();
3110             for (String value : values) {
3111                 String fVal = filterHeaderField(key, value);
3112                 if (fVal != null)
3113                     filteredVals.add(fVal);
3114             }
3115             if (!filteredVals.isEmpty())
3116                 tmpMap.put(key, Collections.unmodifiableList(filteredVals));
3117         }
3118 
3119         return filteredHeaders = Collections.unmodifiableMap(tmpMap);
3120     }
3121 
3122     /**
3123      * Gets a header field by name. Returns null if not known.
3124      * @param name the name of the header field
3125      */
3126     @Override
3127     public String getHeaderField(String name) {
3128         try {
3129             getInputStream();
3130         } catch (IOException e) {}
3131 
3132         if (cachedHeaders != null) {
3133             return filterHeaderField(name, cachedHeaders.findValue(name));
3134         }
3135 
3136         return filterHeaderField(name, responses.findValue(name));
3137     }
3138 
3139     /**
3140      * Returns an unmodifiable Map of the header fields.
3141      * The Map keys are Strings that represent the
3142      * response-header field names. Each Map value is an
3143      * unmodifiable List of Strings that represents
3144      * the corresponding field values.
3145      *
3146      * @return a Map of header fields
3147      * @since 1.4
3148      */
3149     @Override
3150     public Map&lt;String, List&lt;String&gt;&gt; getHeaderFields() {
3151         try {
3152             getInputStream();
3153         } catch (IOException e) {}
3154 
3155         return getFilteredHeaderFields();
3156     }
3157 
3158     /**
3159      * Gets a header field by index. Returns null if not known.
3160      * @param n the index of the header field
3161      */
3162     @Override
3163     public String getHeaderField(int n) {
3164         try {
3165             getInputStream();
3166         } catch (IOException e) {}
3167 
3168         if (cachedHeaders != null) {
3169            return filterHeaderField(cachedHeaders.getKey(n),
3170                                     cachedHeaders.getValue(n));
3171         }
3172         return filterHeaderField(responses.getKey(n), responses.getValue(n));
3173     }
3174 
3175     /**
3176      * Gets a header field by index. Returns null if not known.
3177      * @param n the index of the header field
3178      */
3179     @Override
3180     public String getHeaderFieldKey(int n) {
3181         try {
3182             getInputStream();
3183         } catch (IOException e) {}
3184 
3185         if (cachedHeaders != null) {
3186             return cachedHeaders.getKey(n);
3187         }
3188 
3189         return responses.getKey(n);
3190     }
3191 
3192     /**
3193      * Sets request property. If a property with the key already
3194      * exists, overwrite its value with the new value.
3195      * @param value the value to be set
3196      */
3197     @Override
3198     public synchronized void setRequestProperty(String key, String value) {
3199         if (connected || connecting)
3200             throw new IllegalStateException(&quot;Already connected&quot;);
3201         if (key == null)
3202             throw new NullPointerException (&quot;key is null&quot;);
3203 
3204         if (isExternalMessageHeaderAllowed(key, value)) {
3205             requests.set(key, value);
3206             if (!key.equalsIgnoreCase(&quot;Content-Type&quot;)) {
3207                 userHeaders.set(key, value);
3208             }
3209         }
3210     }
3211 
3212     MessageHeader getUserSetHeaders() {
3213         return userHeaders;
3214     }
3215 
3216     /**
3217      * Adds a general request property specified by a
3218      * key-value pair.  This method will not overwrite
3219      * existing values associated with the same key.
3220      *
3221      * @param   key     the keyword by which the request is known
3222      *                  (e.g., &quot;&lt;code&gt;accept&lt;/code&gt;&quot;).
3223      * @param   value  the value associated with it.
3224      * @see #getRequestProperties(java.lang.String)
3225      * @since 1.4
3226      */
3227     @Override
3228     public synchronized void addRequestProperty(String key, String value) {
3229         if (connected || connecting)
3230             throw new IllegalStateException(&quot;Already connected&quot;);
3231         if (key == null)
3232             throw new NullPointerException (&quot;key is null&quot;);
3233 
3234         if (isExternalMessageHeaderAllowed(key, value)) {
3235             requests.add(key, value);
3236             if (!key.equalsIgnoreCase(&quot;Content-Type&quot;)) {
3237                     userHeaders.add(key, value);
3238             }
3239         }
3240     }
3241 
3242     //
3243     // Set a property for authentication.  This can safely disregard
3244     // the connected test.
3245     //
3246     public void setAuthenticationProperty(String key, String value) {
3247         checkMessageHeader(key, value);
3248         requests.set(key, value);
3249     }
3250 
3251     @Override
3252     public synchronized String getRequestProperty (String key) {
3253         if (key == null) {
3254             return null;
3255         }
3256 
3257         // don&#39;t return headers containing security sensitive information
3258         for (int i=0; i &lt; EXCLUDE_HEADERS.length; i++) {
3259             if (key.equalsIgnoreCase(EXCLUDE_HEADERS[i])) {
3260                 return null;
3261             }
3262         }
3263         if (!setUserCookies) {
3264             if (key.equalsIgnoreCase(&quot;Cookie&quot;)) {
3265                 return userCookies;
3266             }
3267             if (key.equalsIgnoreCase(&quot;Cookie2&quot;)) {
3268                 return userCookies2;
3269             }
3270         }
3271         return requests.findValue(key);
3272     }
3273 
3274     /**
3275      * Returns an unmodifiable Map of general request
3276      * properties for this connection. The Map keys
3277      * are Strings that represent the request-header
3278      * field names. Each Map value is a unmodifiable List
3279      * of Strings that represents the corresponding
3280      * field values.
3281      *
3282      * @return  a Map of the general request properties for this connection.
3283      * @throws IllegalStateException if already connected
3284      * @since 1.4
3285      */
3286     @Override
3287     public synchronized Map&lt;String, List&lt;String&gt;&gt; getRequestProperties() {
3288         if (connected)
3289             throw new IllegalStateException(&quot;Already connected&quot;);
3290 
3291         // exclude headers containing security-sensitive info
3292         if (setUserCookies) {
3293             return requests.getHeaders(EXCLUDE_HEADERS);
3294         }
3295         /*
3296          * The cookies in the requests message headers may have
3297          * been modified. Use the saved user cookies instead.
3298          */
3299         Map&lt;String, List&lt;String&gt;&gt; userCookiesMap = null;
3300         if (userCookies != null || userCookies2 != null) {
3301             userCookiesMap = new HashMap&lt;&gt;();
3302             if (userCookies != null) {
3303                 userCookiesMap.put(&quot;Cookie&quot;, Arrays.asList(userCookies));
3304             }
3305             if (userCookies2 != null) {
3306                 userCookiesMap.put(&quot;Cookie2&quot;, Arrays.asList(userCookies2));
3307             }
3308         }
3309         return requests.filterAndAddHeaders(EXCLUDE_HEADERS2, userCookiesMap);
3310     }
3311 
3312     @Override
3313     public void setConnectTimeout(int timeout) {
3314         if (timeout &lt; 0)
3315             throw new IllegalArgumentException(&quot;timeouts can&#39;t be negative&quot;);
3316         connectTimeout = timeout;
3317     }
3318 
3319 
3320     /**
3321      * Returns setting for connect timeout.
3322      * &lt;p&gt;
3323      * 0 return implies that the option is disabled
3324      * (i.e., timeout of infinity).
3325      *
3326      * @return an &lt;code&gt;int&lt;/code&gt; that indicates the connect timeout
3327      *         value in milliseconds
3328      * @see java.net.URLConnection#setConnectTimeout(int)
3329      * @see java.net.URLConnection#connect()
3330      * @since 1.5
3331      */
3332     @Override
3333     public int getConnectTimeout() {
3334         return (connectTimeout &lt; 0 ? 0 : connectTimeout);
3335     }
3336 
3337     /**
3338      * Sets the read timeout to a specified timeout, in
3339      * milliseconds. A non-zero value specifies the timeout when
3340      * reading from Input stream when a connection is established to a
3341      * resource. If the timeout expires before there is data available
3342      * for read, a java.net.SocketTimeoutException is raised. A
3343      * timeout of zero is interpreted as an infinite timeout.
3344      *
3345      * &lt;p&gt; Some non-standard implementation of this method ignores the
3346      * specified timeout. To see the read timeout set, please call
3347      * getReadTimeout().
3348      *
3349      * @param timeout an &lt;code&gt;int&lt;/code&gt; that specifies the timeout
3350      * value to be used in milliseconds
3351      * @throws IllegalArgumentException if the timeout parameter is negative
3352      *
3353      * @see java.net.URLConnectiongetReadTimeout()
3354      * @see java.io.InputStream#read()
3355      * @since 1.5
3356      */
3357     @Override
3358     public void setReadTimeout(int timeout) {
3359         if (timeout &lt; 0)
3360             throw new IllegalArgumentException(&quot;timeouts can&#39;t be negative&quot;);
3361         readTimeout = timeout;
3362     }
3363 
3364     /**
3365      * Returns setting for read timeout. 0 return implies that the
3366      * option is disabled (i.e., timeout of infinity).
3367      *
3368      * @return an &lt;code&gt;int&lt;/code&gt; that indicates the read timeout
3369      *         value in milliseconds
3370      *
3371      * @see java.net.URLConnection#setReadTimeout(int)
3372      * @see java.io.InputStream#read()
3373      * @since 1.5
3374      */
3375     @Override
3376     public int getReadTimeout() {
3377         return readTimeout &lt; 0 ? 0 : readTimeout;
3378     }
3379 
3380     public CookieHandler getCookieHandler() {
3381         return cookieHandler;
3382     }
3383 
3384     String getMethod() {
3385         return method;
3386     }
3387 
3388     private MessageHeader mapToMessageHeader(Map&lt;String, List&lt;String&gt;&gt; map) {
3389         MessageHeader headers = new MessageHeader();
3390         if (map == null || map.isEmpty()) {
3391             return headers;
3392         }
3393         for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : map.entrySet()) {
3394             String key = entry.getKey();
3395             List&lt;String&gt; values = entry.getValue();
3396             for (String value : values) {
3397                 if (key == null) {
3398                     headers.prepend(key, value);
3399                 } else {
3400                     headers.add(key, value);
3401                 }
3402             }
3403         }
3404         return headers;
3405     }
3406 
3407     /**
3408      * Returns the given host, without the IPv6 Zone Id, if present.
3409      * (e.g. [fe80::a00:27ff:aaaa:aaaa%eth0] -&gt; [fe80::a00:27ff:aaaa:aaaa])
3410      *
3411      * @param host host address (not null, not empty)
3412      * @return host address without Zone Id
3413      */
3414     static String stripIPv6ZoneId(String host) {
3415         if (host.charAt(0) != &#39;[&#39;) { // not an IPv6-literal
3416             return host;
3417         }
3418         int i = host.lastIndexOf(&#39;%&#39;);
3419         if (i == -1) { // doesn&#39;t contain zone_id
3420             return host;
3421         }
3422         return host.substring(0, i) + &quot;]&quot;;
3423     }
3424 
3425     /* The purpose of this wrapper is just to capture the close() call
3426      * so we can check authentication information that may have
3427      * arrived in a Trailer field
3428      */
3429     class HttpInputStream extends FilterInputStream {
3430         private CacheRequest cacheRequest;
3431         private OutputStream outputStream;
3432         private boolean marked = false;
3433         private int inCache = 0;
3434         private int markCount = 0;
3435         private boolean closed;  // false
3436 
3437         public HttpInputStream (InputStream is) {
3438             super (is);
3439             this.cacheRequest = null;
3440             this.outputStream = null;
3441         }
3442 
3443         public HttpInputStream (InputStream is, CacheRequest cacheRequest) {
3444             super (is);
3445             this.cacheRequest = cacheRequest;
3446             try {
3447                 this.outputStream = cacheRequest.getBody();
3448             } catch (IOException ioex) {
3449                 this.cacheRequest.abort();
3450                 this.cacheRequest = null;
3451                 this.outputStream = null;
3452             }
3453         }
3454 
3455         /**
3456          * Marks the current position in this input stream. A subsequent
3457          * call to the &lt;code&gt;reset&lt;/code&gt; method repositions this stream at
3458          * the last marked position so that subsequent reads re-read the same
3459          * bytes.
3460          * &lt;p&gt;
3461          * The &lt;code&gt;readlimit&lt;/code&gt; argument tells this input stream to
3462          * allow that many bytes to be read before the mark position gets
3463          * invalidated.
3464          * &lt;p&gt;
3465          * This method simply performs &lt;code&gt;in.mark(readlimit)&lt;/code&gt;.
3466          *
3467          * @param   readlimit   the maximum limit of bytes that can be read before
3468          *                      the mark position becomes invalid.
3469          * @see     java.io.FilterInputStream#in
3470          * @see     java.io.FilterInputStream#reset()
3471          */
3472         @Override
3473         public synchronized void mark(int readlimit) {
3474             super.mark(readlimit);
3475             if (cacheRequest != null) {
3476                 marked = true;
3477                 markCount = 0;
3478             }
3479         }
3480 
3481         /**
3482          * Repositions this stream to the position at the time the
3483          * &lt;code&gt;mark&lt;/code&gt; method was last called on this input stream.
3484          * &lt;p&gt;
3485          * This method
3486          * simply performs &lt;code&gt;in.reset()&lt;/code&gt;.
3487          * &lt;p&gt;
3488          * Stream marks are intended to be used in
3489          * situations where you need to read ahead a little to see what&#39;s in
3490          * the stream. Often this is most easily done by invoking some
3491          * general parser. If the stream is of the type handled by the
3492          * parse, it just chugs along happily. If the stream is not of
3493          * that type, the parser should toss an exception when it fails.
3494          * If this happens within readlimit bytes, it allows the outer
3495          * code to reset the stream and try another parser.
3496          *
3497          * @exception  IOException  if the stream has not been marked or if the
3498          *               mark has been invalidated.
3499          * @see        java.io.FilterInputStream#in
3500          * @see        java.io.FilterInputStream#mark(int)
3501          */
3502         @Override
3503         public synchronized void reset() throws IOException {
3504             super.reset();
3505             if (cacheRequest != null) {
3506                 marked = false;
3507                 inCache += markCount;
3508             }
3509         }
3510 
3511         private void ensureOpen() throws IOException {
3512             if (closed)
3513                 throw new IOException(&quot;stream is closed&quot;);
3514         }
3515 
3516         @Override
3517         public int read() throws IOException {
3518             ensureOpen();
3519             try {
3520                 byte[] b = new byte[1];
3521                 int ret = read(b);
3522                 return (ret == -1? ret : (b[0] &amp; 0x00FF));
3523             } catch (IOException ioex) {
3524                 if (cacheRequest != null) {
3525                     cacheRequest.abort();
3526                 }
3527                 throw ioex;
3528             }
3529         }
3530 
3531         @Override
3532         public int read(byte[] b) throws IOException {
3533             return read(b, 0, b.length);
3534         }
3535 
3536         @Override
3537         public int read(byte[] b, int off, int len) throws IOException {
3538             ensureOpen();
3539             try {
3540                 int newLen = super.read(b, off, len);
3541                 int nWrite;
3542                 // write to cache
3543                 if (inCache &gt; 0) {
3544                     if (inCache &gt;= newLen) {
3545                         inCache -= newLen;
3546                         nWrite = 0;
3547                     } else {
3548                         nWrite = newLen - inCache;
3549                         inCache = 0;
3550                     }
3551                 } else {
3552                     nWrite = newLen;
3553                 }
3554                 if (nWrite &gt; 0 &amp;&amp; outputStream != null)
3555                     outputStream.write(b, off + (newLen-nWrite), nWrite);
3556                 if (marked) {
3557                     markCount += newLen;
3558                 }
3559                 return newLen;
3560             } catch (IOException ioex) {
3561                 if (cacheRequest != null) {
3562                     cacheRequest.abort();
3563                 }
3564                 throw ioex;
3565             }
3566         }
3567 
3568         /* skip() calls read() in order to ensure that entire response gets
3569          * cached. same implementation as InputStream.skip */
3570 
3571         private byte[] skipBuffer;
3572         private static final int SKIP_BUFFER_SIZE = 8096;
3573 
3574         @Override
3575         public long skip (long n) throws IOException {
3576             ensureOpen();
3577             long remaining = n;
3578             int nr;
3579             if (skipBuffer == null)
3580                 skipBuffer = new byte[SKIP_BUFFER_SIZE];
3581 
3582             byte[] localSkipBuffer = skipBuffer;
3583 
3584             if (n &lt;= 0) {
3585                 return 0;
3586             }
3587 
3588             while (remaining &gt; 0) {
3589                 nr = read(localSkipBuffer, 0,
3590                           (int) Math.min(SKIP_BUFFER_SIZE, remaining));
3591                 if (nr &lt; 0) {
3592                     break;
3593                 }
3594                 remaining -= nr;
3595             }
3596 
3597             return n - remaining;
3598         }
3599 
3600         @Override
3601         public void close () throws IOException {
3602             if (closed)
3603                 return;
3604 
3605             try {
3606                 if (outputStream != null) {
3607                     if (read() != -1) {
3608                         cacheRequest.abort();
3609                     } else {
3610                         outputStream.close();
3611                     }
3612                 }
3613                 super.close ();
3614             } catch (IOException ioex) {
3615                 if (cacheRequest != null) {
3616                     cacheRequest.abort();
3617                 }
3618                 throw ioex;
3619             } finally {
3620                 closed = true;
3621                 HttpURLConnection.this.http = null;
3622                 checkResponseCredentials (true);
3623             }
3624         }
3625     }
3626 
3627     class StreamingOutputStream extends FilterOutputStream {
3628 
3629         long expected;
3630         long written;
3631         boolean closed;
3632         boolean error;
3633         IOException errorExcp;
3634 
3635         /**
3636          * expectedLength == -1 if the stream is chunked
3637          * expectedLength &gt; 0 if the stream is fixed content-length
3638          *    In the 2nd case, we make sure the expected number
3639          *    of bytes are actually written
3640          */
3641         StreamingOutputStream (OutputStream os, long expectedLength) {
3642             super (os);
3643             expected = expectedLength;
3644             written = 0L;
3645             closed = false;
3646             error = false;
3647         }
3648 
3649         @Override
3650         public void write (int b) throws IOException {
3651             checkError();
3652             written ++;
3653             if (expected != -1L &amp;&amp; written &gt; expected) {
3654                 throw new IOException (&quot;too many bytes written&quot;);
3655             }
3656             out.write (b);
3657         }
3658 
3659         @Override
3660         public void write (byte[] b) throws IOException {
3661             write (b, 0, b.length);
3662         }
3663 
3664         @Override
3665         public void write (byte[] b, int off, int len) throws IOException {
3666             checkError();
3667             written += len;
3668             if (expected != -1L &amp;&amp; written &gt; expected) {
3669                 out.close ();
3670                 throw new IOException (&quot;too many bytes written&quot;);
3671             }
3672             out.write (b, off, len);
3673         }
3674 
3675         void checkError () throws IOException {
3676             if (closed) {
3677                 throw new IOException (&quot;Stream is closed&quot;);
3678             }
3679             if (error) {
3680                 throw errorExcp;
3681             }
3682             if (((PrintStream)out).checkError()) {
3683                 throw new IOException(&quot;Error writing request body to server&quot;);
3684             }
3685         }
3686 
3687         /* this is called to check that all the bytes
3688          * that were supposed to be written were written
3689          * and that the stream is now closed().
3690          */
3691         boolean writtenOK () {
3692             return closed &amp;&amp; ! error;
3693         }
3694 
3695         @Override
3696         public void close () throws IOException {
3697             if (closed) {
3698                 return;
3699             }
3700             closed = true;
3701             if (expected != -1L) {
3702                 /* not chunked */
3703                 if (written != expected) {
3704                     error = true;
3705                     errorExcp = new IOException (&quot;insufficient data written&quot;);
3706                     out.close ();
3707                     throw errorExcp;
3708                 }
3709                 super.flush(); /* can&#39;t close the socket */
3710             } else {
3711                 /* chunked */
3712                 super.close (); /* force final chunk to be written */
3713                 /* trailing \r\n */
3714                 OutputStream o = http.getOutputStream();
3715                 o.write (&#39;\r&#39;);
3716                 o.write (&#39;\n&#39;);
3717                 o.flush();
3718             }
3719         }
3720     }
3721 
3722 
3723     static class ErrorStream extends InputStream {
3724         ByteBuffer buffer;
3725         InputStream is;
3726 
3727         private ErrorStream(ByteBuffer buf) {
3728             buffer = buf;
3729             is = null;
3730         }
3731 
3732         private ErrorStream(ByteBuffer buf, InputStream is) {
3733             buffer = buf;
3734             this.is = is;
3735         }
3736 
3737         // when this method is called, it&#39;s either the case that cl &gt; 0, or
3738         // if chunk-encoded, cl = -1; in other words, cl can&#39;t be 0
3739         public static InputStream getErrorStream(InputStream is, long cl, HttpClient http) {
3740 
3741             // cl can&#39;t be 0; this following is here for extra precaution
3742             if (cl == 0) {
3743                 return null;
3744             }
3745 
3746             try {
3747                 // set SO_TIMEOUT to 1/5th of the total timeout
3748                 // remember the old timeout value so that we can restore it
3749                 int oldTimeout = http.getReadTimeout();
3750                 http.setReadTimeout(timeout4ESBuffer/5);
3751 
3752                 long expected = 0;
3753                 boolean isChunked = false;
3754                 // the chunked case
3755                 if (cl &lt; 0) {
3756                     expected = bufSize4ES;
3757                     isChunked = true;
3758                 } else {
3759                     expected = cl;
3760                 }
3761                 if (expected &lt;= bufSize4ES) {
3762                     int exp = (int) expected;
3763                     byte[] buffer = new byte[exp];
3764                     int count = 0, time = 0, len = 0;
3765                     do {
3766                         try {
3767                             len = is.read(buffer, count,
3768                                              buffer.length - count);
3769                             if (len &lt; 0) {
3770                                 if (isChunked) {
3771                                     // chunked ended
3772                                     // if chunked ended prematurely,
3773                                     // an IOException would be thrown
3774                                     break;
3775                                 }
3776                                 // the server sends less than cl bytes of data
3777                                 throw new IOException(&quot;the server closes&quot;+
3778                                                       &quot; before sending &quot;+cl+
3779                                                       &quot; bytes of data&quot;);
3780                             }
3781                             count += len;
3782                         } catch (SocketTimeoutException ex) {
3783                             time += timeout4ESBuffer/5;
3784                         }
3785                     } while (count &lt; exp &amp;&amp; time &lt; timeout4ESBuffer);
3786 
3787                     // reset SO_TIMEOUT to old value
3788                     http.setReadTimeout(oldTimeout);
3789 
3790                     // if count &lt; cl at this point, we will not try to reuse
3791                     // the connection
3792                     if (count == 0) {
3793                         // since we haven&#39;t read anything,
3794                         // we will return the underlying
3795                         // inputstream back to the application
3796                         return null;
3797                     }  else if ((count == expected &amp;&amp; !(isChunked)) || (isChunked &amp;&amp; len &lt;0)) {
3798                         // put the connection into keep-alive cache
3799                         // the inputstream will try to do the right thing
3800                         is.close();
3801                         return new ErrorStream(ByteBuffer.wrap(buffer, 0, count));
3802                     } else {
3803                         // we read part of the response body
3804                         return new ErrorStream(
3805                                       ByteBuffer.wrap(buffer, 0, count), is);
3806                     }
3807                 }
3808                 return null;
3809             } catch (IOException ioex) {
3810                 // ioex.printStackTrace();
3811                 return null;
3812             }
3813         }
3814 
3815         @Override
3816         public int available() throws IOException {
3817             if (is == null) {
3818                 return buffer.remaining();
3819             } else {
3820                 return buffer.remaining()+is.available();
3821             }
3822         }
3823 
3824         public int read() throws IOException {
3825             byte[] b = new byte[1];
3826             int ret = read(b);
3827             return (ret == -1? ret : (b[0] &amp; 0x00FF));
3828         }
3829 
3830         @Override
3831         public int read(byte[] b) throws IOException {
3832             return read(b, 0, b.length);
3833         }
3834 
3835         @Override
3836         public int read(byte[] b, int off, int len) throws IOException {
3837             int rem = buffer.remaining();
3838             if (rem &gt; 0) {
3839                 int ret = rem &lt; len? rem : len;
3840                 buffer.get(b, off, ret);
3841                 return ret;
3842             } else {
3843                 if (is == null) {
3844                     return -1;
3845                 } else {
3846                     return is.read(b, off, len);
3847                 }
3848             }
3849         }
3850 
3851         @Override
3852         public void close() throws IOException {
3853             buffer = null;
3854             if (is != null) {
3855                 is.close();
3856             }
3857         }
3858     }
3859 }
3860 
3861 /** An input stream that just returns EOF.  This is for
3862  * HTTP URLConnections that are KeepAlive &amp;&amp; use the
3863  * HEAD method - i.e., stream not dead, but nothing to be read.
3864  */
3865 
3866 class EmptyInputStream extends InputStream {
3867 
3868     @Override
3869     public int available() {
3870         return 0;
3871     }
3872 
3873     public int read() {
3874         return -1;
3875     }
3876 }
    </pre>
  </body>
</html>
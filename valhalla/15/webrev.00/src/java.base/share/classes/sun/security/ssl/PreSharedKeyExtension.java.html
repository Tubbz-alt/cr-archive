<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/PreSharedKeyExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.security.ssl;
 26 
 27 import java.io.IOException;
 28 import java.nio.ByteBuffer;
 29 import java.security.*;
 30 import java.text.MessageFormat;
 31 import java.util.List;
 32 import java.util.ArrayList;
 33 import java.util.Locale;
 34 import java.util.Arrays;
 35 import java.util.Collection;
 36 import javax.crypto.Mac;
 37 import javax.crypto.SecretKey;
 38 import javax.net.ssl.SSLPeerUnverifiedException;
 39 import javax.net.ssl.SSLProtocolException;
 40 import static sun.security.ssl.ClientAuthType.CLIENT_AUTH_REQUIRED;
 41 import sun.security.ssl.ClientHello.ClientHelloMessage;
 42 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 43 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 44 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 45 import sun.security.ssl.SessionTicketExtension.SessionTicketSpec;
 46 import sun.security.util.HexDumpEncoder;
 47 
 48 import static sun.security.ssl.SSLExtension.*;
 49 
 50 /**
 51  * Pack of the &quot;pre_shared_key&quot; extension.
 52  */
 53 final class PreSharedKeyExtension {
 54     static final HandshakeProducer chNetworkProducer =
 55             new CHPreSharedKeyProducer();
 56     static final ExtensionConsumer chOnLoadConsumer =
 57             new CHPreSharedKeyConsumer();
 58     static final HandshakeAbsence chOnLoadAbsence =
 59             new CHPreSharedKeyAbsence();
 60     static final HandshakeConsumer chOnTradeConsumer =
 61             new CHPreSharedKeyUpdate();
 62     static final SSLStringizer chStringizer =
 63             new CHPreSharedKeyStringizer();
 64 
 65     static final HandshakeProducer shNetworkProducer =
 66             new SHPreSharedKeyProducer();
 67     static final ExtensionConsumer shOnLoadConsumer =
 68             new SHPreSharedKeyConsumer();
 69     static final HandshakeAbsence shOnLoadAbsence =
 70             new SHPreSharedKeyAbsence();
 71     static final SSLStringizer shStringizer =
 72             new SHPreSharedKeyStringizer();
 73 
 74     private static final class PskIdentity {
 75         final byte[] identity;
 76         final int obfuscatedAge;
 77 
 78         PskIdentity(byte[] identity, int obfuscatedAge) {
 79             this.identity = identity;
 80             this.obfuscatedAge = obfuscatedAge;
 81         }
 82 
 83         int getEncodedLength() {
 84             return 2 + identity.length + 4;
 85         }
 86 
 87         void writeEncoded(ByteBuffer m) throws IOException {
 88             Record.putBytes16(m, identity);
 89             Record.putInt32(m, obfuscatedAge);
 90         }
 91 
 92         @Override
 93         public String toString() {
 94             return &quot;{&quot; + Utilities.toHexString(identity) + &quot;, &quot; +
 95                 obfuscatedAge + &quot;}&quot;;
 96         }
 97     }
 98 
 99     private static final
100             class CHPreSharedKeySpec implements SSLExtensionSpec {
101         final List&lt;PskIdentity&gt; identities;
102         final List&lt;byte[]&gt; binders;
103 
104         CHPreSharedKeySpec(List&lt;PskIdentity&gt; identities, List&lt;byte[]&gt; binders) {
105             this.identities = identities;
106             this.binders = binders;
107         }
108 
109         CHPreSharedKeySpec(HandshakeContext hc,
110                 ByteBuffer m) throws IOException {
111             // struct {
112             //     PskIdentity identities&lt;7..2^16-1&gt;;
113             //     PskBinderEntry binders&lt;33..2^16-1&gt;;
114             // } OfferedPsks;
115             if (m.remaining() &lt; 44) {
116                 throw hc.conContext.fatal(Alert.DECODE_ERROR,
117                         new SSLProtocolException(
118                     &quot;Invalid pre_shared_key extension: &quot; +
119                     &quot;insufficient data (length=&quot; + m.remaining() + &quot;)&quot;));
120             }
121 
122             int idEncodedLength = Record.getInt16(m);
123             if (idEncodedLength &lt; 7) {
124                 throw hc.conContext.fatal(Alert.DECODE_ERROR,
125                         new SSLProtocolException(
126                     &quot;Invalid pre_shared_key extension: &quot; +
127                     &quot;insufficient identities (length=&quot; + idEncodedLength + &quot;)&quot;));
128             }
129 
130             identities = new ArrayList&lt;&gt;();
131             int idReadLength = 0;
132             while (idReadLength &lt; idEncodedLength) {
133                 byte[] id = Record.getBytes16(m);
134                 if (id.length &lt; 1) {
135                     throw hc.conContext.fatal(Alert.DECODE_ERROR,
136                             new SSLProtocolException(
137                         &quot;Invalid pre_shared_key extension: &quot; +
138                         &quot;insufficient identity (length=&quot; + id.length + &quot;)&quot;));
139                 }
140                 int obfuscatedTicketAge = Record.getInt32(m);
141 
142                 PskIdentity pskId = new PskIdentity(id, obfuscatedTicketAge);
143                 identities.add(pskId);
144                 idReadLength += pskId.getEncodedLength();
145             }
146 
147             if (m.remaining() &lt; 35) {
148                 throw hc.conContext.fatal(Alert.DECODE_ERROR,
149                         new SSLProtocolException(
150                     &quot;Invalid pre_shared_key extension: &quot; +
151                     &quot;insufficient binders data (length=&quot; +
152                     m.remaining() + &quot;)&quot;));
153             }
154 
155             int bindersEncodedLen = Record.getInt16(m);
156             if (bindersEncodedLen &lt; 33) {
157                 throw hc.conContext.fatal(Alert.DECODE_ERROR,
158                         new SSLProtocolException(
159                     &quot;Invalid pre_shared_key extension: &quot; +
160                     &quot;insufficient binders (length=&quot; +
161                     bindersEncodedLen + &quot;)&quot;));
162             }
163 
164             binders = new ArrayList&lt;&gt;();
165             int bindersReadLength = 0;
166             while (bindersReadLength &lt; bindersEncodedLen) {
167                 byte[] binder = Record.getBytes8(m);
168                 if (binder.length &lt; 32) {
169                     throw hc.conContext.fatal(Alert.DECODE_ERROR,
170                             new SSLProtocolException(
171                         &quot;Invalid pre_shared_key extension: &quot; +
172                         &quot;insufficient binder entry (length=&quot; +
173                         binder.length + &quot;)&quot;));
174                 }
175                 binders.add(binder);
176                 bindersReadLength += 1 + binder.length;
177             }
178         }
179 
180         int getIdsEncodedLength() {
181             int idEncodedLength = 0;
182             for (PskIdentity curId : identities) {
183                 idEncodedLength += curId.getEncodedLength();
184             }
185 
186             return idEncodedLength;
187         }
188 
189         int getBindersEncodedLength() {
190             int binderEncodedLength = 0;
191             for (byte[] curBinder : binders) {
192                 binderEncodedLength += 1 + curBinder.length;
193             }
194 
195             return binderEncodedLength;
196         }
197 
198         byte[] getEncoded() throws IOException {
199             int idsEncodedLength = getIdsEncodedLength();
200             int bindersEncodedLength = getBindersEncodedLength();
201             int encodedLength = 4 + idsEncodedLength + bindersEncodedLength;
202             byte[] buffer = new byte[encodedLength];
203             ByteBuffer m = ByteBuffer.wrap(buffer);
204             Record.putInt16(m, idsEncodedLength);
205             for (PskIdentity curId : identities) {
206                 curId.writeEncoded(m);
207             }
208             Record.putInt16(m, bindersEncodedLength);
209             for (byte[] curBinder : binders) {
210                 Record.putBytes8(m, curBinder);
211             }
212 
213             return buffer;
214         }
215 
216         @Override
217         public String toString() {
218             MessageFormat messageFormat = new MessageFormat(
219                 &quot;\&quot;PreSharedKey\&quot;: &#39;{&#39;\n&quot; +
220                 &quot;  \&quot;identities\&quot;: &#39;{&#39;\n&quot; +
221                 &quot;{0}\n&quot; +
222                 &quot;  &#39;}&#39;&quot; +
223                 &quot;  \&quot;binders\&quot;: \&quot;{1}\&quot;,\n&quot; +
224                 &quot;&#39;}&#39;&quot;,
225                 Locale.ENGLISH);
226 
227             Object[] messageFields = {
228                 Utilities.indent(identitiesString()),
229                 Utilities.indent(bindersString())
230             };
231 
232             return messageFormat.format(messageFields);
233         }
234 
235         String identitiesString() {
236             HexDumpEncoder hexEncoder = new HexDumpEncoder();
237 
238             StringBuilder result = new StringBuilder();
239             for (PskIdentity curId : identities) {
240                 result.append(&quot;  {\n&quot;+ Utilities.indent(
241                         hexEncoder.encode(curId.identity), &quot;    &quot;) +
242                         &quot;\n  }\n&quot;);
243             }
244 
245             return result.toString();
246         }
247 
248         String bindersString() {
249             StringBuilder result = new StringBuilder();
250             for (byte[] curBinder : binders) {
251                 result.append(&quot;{&quot; + Utilities.toHexString(curBinder) + &quot;}\n&quot;);
252             }
253 
254             return result.toString();
255         }
256     }
257 
258     private static final
259             class CHPreSharedKeyStringizer implements SSLStringizer {
260         @Override
261         public String toString(HandshakeContext hc, ByteBuffer buffer) {
262             try {
263                 return (new CHPreSharedKeySpec(hc, buffer)).toString();
264             } catch (Exception ex) {
265                 // For debug logging only, so please swallow exceptions.
266                 return ex.getMessage();
267             }
268         }
269     }
270 
271     private static final
272             class SHPreSharedKeySpec implements SSLExtensionSpec {
273         final int selectedIdentity;
274 
275         SHPreSharedKeySpec(int selectedIdentity) {
276             this.selectedIdentity = selectedIdentity;
277         }
278 
279         SHPreSharedKeySpec(HandshakeContext hc,
280                 ByteBuffer m) throws IOException {
281             if (m.remaining() &lt; 2) {
282                 throw hc.conContext.fatal(Alert.DECODE_ERROR,
283                         new SSLProtocolException(
284                     &quot;Invalid pre_shared_key extension: &quot; +
285                     &quot;insufficient selected_identity (length=&quot; +
286                     m.remaining() + &quot;)&quot;));
287             }
288             this.selectedIdentity = Record.getInt16(m);
289         }
290 
291         byte[] getEncoded() {
292             return new byte[] {
293                 (byte)((selectedIdentity &gt;&gt; 8) &amp; 0xFF),
294                 (byte)(selectedIdentity &amp; 0xFF)
295             };
296         }
297 
298         @Override
299         public String toString() {
300             MessageFormat messageFormat = new MessageFormat(
301                 &quot;\&quot;PreSharedKey\&quot;: &#39;{&#39;\n&quot; +
302                 &quot;  \&quot;selected_identity\&quot;      : \&quot;{0}\&quot;,\n&quot; +
303                 &quot;&#39;}&#39;&quot;,
304                 Locale.ENGLISH);
305 
306             Object[] messageFields = {
307                 Utilities.byte16HexString(selectedIdentity)
308             };
309 
310             return messageFormat.format(messageFields);
311         }
312     }
313 
314     private static final
315             class SHPreSharedKeyStringizer implements SSLStringizer {
316         @Override
317         public String toString(HandshakeContext hc, ByteBuffer buffer) {
318             try {
319                 return (new SHPreSharedKeySpec(hc, buffer)).toString();
320             } catch (Exception ex) {
321                 // For debug logging only, so please swallow exceptions.
322                 return ex.getMessage();
323             }
324         }
325     }
326 
327     private static final
328             class CHPreSharedKeyConsumer implements ExtensionConsumer {
329         // Prevent instantiation of this class.
330         private CHPreSharedKeyConsumer() {
331             // blank
332         }
333 
334         @Override
335         public void consume(ConnectionContext context,
336                             HandshakeMessage message,
337                             ByteBuffer buffer) throws IOException {
338             ClientHelloMessage clientHello = (ClientHelloMessage) message;
339             ServerHandshakeContext shc = (ServerHandshakeContext)context;
340             // Is it a supported and enabled extension?
341             if (!shc.sslConfig.isAvailable(SSLExtension.CH_PRE_SHARED_KEY)) {
342                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
343                     SSLLogger.fine(
344                             &quot;Ignore unavailable pre_shared_key extension&quot;);
345                 }
346                 return;     // ignore the extension
347             }
348 
349             // Parse the extension.
350             CHPreSharedKeySpec pskSpec = new CHPreSharedKeySpec(shc, buffer);
351 
352             // The &quot;psk_key_exchange_modes&quot; extension should have been loaded.
353             if (!shc.handshakeExtensions.containsKey(
354                     SSLExtension.PSK_KEY_EXCHANGE_MODES)) {
355                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
356                         &quot;Client sent PSK but not PSK modes, or the PSK &quot; +
357                         &quot;extension is not the last extension&quot;);
358             }
359 
360             // error if id and binder lists are not the same length
361             if (pskSpec.identities.size() != pskSpec.binders.size()) {
362                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
363                         &quot;PSK extension has incorrect number of binders&quot;);
364             }
365 
366             if (shc.isResumption) {     // resumingSession may not be set
367                 SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
368                         shc.sslContext.engineGetServerSessionContext();
369                 int idIndex = 0;
370                 SSLSessionImpl s = null;
371 
372                 for (PskIdentity requestedId : pskSpec.identities) {
373                     // If we are keeping state, see if the identity is in the cache
374                     if (requestedId.identity.length == SessionId.MAX_LENGTH) {
375                         s = sessionCache.get(requestedId.identity);
376                     }
377                     // See if the identity is a stateless ticket
378                     if (s == null &amp;&amp;
379                             requestedId.identity.length &gt; SessionId.MAX_LENGTH &amp;&amp;
380                             sessionCache.statelessEnabled()) {
381                         ByteBuffer b =
382                             new SessionTicketSpec(shc, requestedId.identity).
383                                         decrypt(shc);
384                         if (b != null) {
385                             try {
386                                 s = new SSLSessionImpl(shc, b);
387                             } catch (IOException | RuntimeException e) {
388                                 s = null;
389                             }
390                         }
391                         if (b == null || s == null) {
392                             if (SSLLogger.isOn &amp;&amp;
393                                     SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
394                                 SSLLogger.fine(
395                                         &quot;Stateless session ticket invalid&quot;);
396                             }
397                         }
398                     }
399 
400                     if (s != null &amp;&amp; canRejoin(clientHello, shc, s)) {
401                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
402                             SSLLogger.fine(&quot;Resuming session: &quot;, s);
403                         }
404 
405                         // binder will be checked later
406                         shc.resumingSession = s;
407                         shc.handshakeExtensions.put(SH_PRE_SHARED_KEY,
408                             new SHPreSharedKeySpec(idIndex));   // for the index
409                         break;
410                     }
411 
412                     ++idIndex;
413                 }
414 
415                 if (idIndex == pskSpec.identities.size()) {
416                     // no resumable session
417                     shc.isResumption = false;
418                     shc.resumingSession = null;
419                 }
420             }
421             // update the context
422             shc.handshakeExtensions.put(
423                 SSLExtension.CH_PRE_SHARED_KEY, pskSpec);
424         }
425     }
426 
427     private static boolean canRejoin(ClientHelloMessage clientHello,
428         ServerHandshakeContext shc, SSLSessionImpl s) {
429 
430         boolean result = s.isRejoinable() &amp;&amp; (s.getPreSharedKey() != null);
431 
432         // Check protocol version
433         if (result &amp;&amp; s.getProtocolVersion() != shc.negotiatedProtocol) {
434             if (SSLLogger.isOn &amp;&amp;
435                 SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
436 
437                 SSLLogger.finest(&quot;Can&#39;t resume, incorrect protocol version&quot;);
438             }
439             result = false;
440         }
441 
442         // Make sure that the server handshake context&#39;s localSupportedSignAlgs
443         // field is populated.  This is particularly important when
444         // client authentication was used in an initial session and it is
445         // now being resumed.
446         if (shc.localSupportedSignAlgs == null) {
447             shc.localSupportedSignAlgs =
448                     SignatureScheme.getSupportedAlgorithms(
449                             shc.algorithmConstraints, shc.activeProtocols);
450         }
451 
452         // Validate the required client authentication.
453         if (result &amp;&amp;
454             (shc.sslConfig.clientAuthType == CLIENT_AUTH_REQUIRED)) {
455             try {
456                 s.getPeerPrincipal();
457             } catch (SSLPeerUnverifiedException e) {
458                 if (SSLLogger.isOn &amp;&amp;
459                         SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
460                     SSLLogger.finest(
461                         &quot;Can&#39;t resume, &quot; +
462                         &quot;client authentication is required&quot;);
463                 }
464                 result = false;
465             }
466 
467             // Make sure the list of supported signature algorithms matches
468             Collection&lt;SignatureScheme&gt; sessionSigAlgs =
469                 s.getLocalSupportedSignatureSchemes();
470             if (result &amp;&amp;
471                 !shc.localSupportedSignAlgs.containsAll(sessionSigAlgs)) {
472 
473                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
474                     SSLLogger.fine(&quot;Can&#39;t resume. Session uses different &quot; +
475                         &quot;signature algorithms&quot;);
476                 }
477                 result = false;
478             }
479         }
480 
481         // ensure that the endpoint identification algorithm matches the
482         // one in the session
483         String identityAlg = shc.sslConfig.identificationProtocol;
484         if (result &amp;&amp; identityAlg != null) {
485             String sessionIdentityAlg = s.getIdentificationProtocol();
486             if (!identityAlg.equalsIgnoreCase(sessionIdentityAlg)) {
487                 if (SSLLogger.isOn &amp;&amp;
488                     SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
489 
490                     SSLLogger.finest(&quot;Can&#39;t resume, endpoint id&quot; +
491                         &quot; algorithm does not match, requested: &quot; +
492                         identityAlg + &quot;, cached: &quot; + sessionIdentityAlg);
493                 }
494                 result = false;
495             }
496         }
497 
498         // Ensure cipher suite can be negotiated
499         if (result &amp;&amp; (!shc.isNegotiable(s.getSuite()) ||
500             !clientHello.cipherSuites.contains(s.getSuite()))) {
501             if (SSLLogger.isOn &amp;&amp;
502                     SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
503                 SSLLogger.finest(
504                     &quot;Can&#39;t resume, unavailable session cipher suite&quot;);
505             }
506             result = false;
507         }
508 
509         return result;
510     }
511 
512     private static final
513             class CHPreSharedKeyUpdate implements HandshakeConsumer {
514         // Prevent instantiation of this class.
515         private CHPreSharedKeyUpdate() {
516             // blank
517         }
518 
519         @Override
520         public void consume(ConnectionContext context,
521                 HandshakeMessage message) throws IOException {
522             ServerHandshakeContext shc = (ServerHandshakeContext)context;
523             if (!shc.isResumption || shc.resumingSession == null) {
524                 // not resuming---nothing to do
525                 return;
526             }
527 
528             CHPreSharedKeySpec chPsk = (CHPreSharedKeySpec)
529                     shc.handshakeExtensions.get(SSLExtension.CH_PRE_SHARED_KEY);
530             SHPreSharedKeySpec shPsk = (SHPreSharedKeySpec)
531                     shc.handshakeExtensions.get(SSLExtension.SH_PRE_SHARED_KEY);
532             if (chPsk == null || shPsk == null) {
533                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
534                         &quot;Required extensions are unavailable&quot;);
535             }
536 
537             byte[] binder = chPsk.binders.get(shPsk.selectedIdentity);
538 
539             // set up PSK binder hash
540             HandshakeHash pskBinderHash = shc.handshakeHash.copy();
541             byte[] lastMessage = pskBinderHash.removeLastReceived();
542             ByteBuffer messageBuf = ByteBuffer.wrap(lastMessage);
543             // skip the type and length
544             messageBuf.position(4);
545             // read to find the beginning of the binders
546             ClientHelloMessage.readPartial(shc.conContext, messageBuf);
547             int length = messageBuf.position();
548             messageBuf.position(0);
549             pskBinderHash.receive(messageBuf, length);
550 
551             checkBinder(shc, shc.resumingSession, pskBinderHash, binder);
552         }
553     }
554 
555     private static void checkBinder(ServerHandshakeContext shc,
556             SSLSessionImpl session,
557             HandshakeHash pskBinderHash, byte[] binder) throws IOException {
558         SecretKey psk = session.getPreSharedKey();
559         if (psk == null) {
560             throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
561                     &quot;Session has no PSK&quot;);
562         }
563 
564         SecretKey binderKey = deriveBinderKey(shc, psk, session);
565         byte[] computedBinder =
566                 computeBinder(shc, binderKey, session, pskBinderHash);
567         if (!Arrays.equals(binder, computedBinder)) {
568             throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
569                     &quot;Incorect PSK binder value&quot;);
570         }
571     }
572 
573     // Class that produces partial messages used to compute binder hash
574     static final class PartialClientHelloMessage extends HandshakeMessage {
575 
576         private final ClientHello.ClientHelloMessage msg;
577         private final CHPreSharedKeySpec psk;
578 
579         PartialClientHelloMessage(HandshakeContext ctx,
580                                   ClientHello.ClientHelloMessage msg,
581                                   CHPreSharedKeySpec psk) {
582             super(ctx);
583 
584             this.msg = msg;
585             this.psk = psk;
586         }
587 
588         @Override
589         SSLHandshake handshakeType() {
590             return msg.handshakeType();
591         }
592 
593         private int pskTotalLength() {
594             return psk.getIdsEncodedLength() +
595                 psk.getBindersEncodedLength() + 8;
596         }
597 
598         @Override
599         int messageLength() {
600 
601             if (msg.extensions.get(SSLExtension.CH_PRE_SHARED_KEY) != null) {
602                 return msg.messageLength();
603             } else {
604                 return msg.messageLength() + pskTotalLength();
605             }
606         }
607 
608         @Override
609         void send(HandshakeOutStream hos) throws IOException {
610             msg.sendCore(hos);
611 
612             // complete extensions
613             int extsLen = msg.extensions.length();
614             if (msg.extensions.get(SSLExtension.CH_PRE_SHARED_KEY) == null) {
615                 extsLen += pskTotalLength();
616             }
617             hos.putInt16(extsLen - 2);
618             // write the complete extensions
619             for (SSLExtension ext : SSLExtension.values()) {
620                 byte[] extData = msg.extensions.get(ext);
621                 if (extData == null) {
622                     continue;
623                 }
624                 // the PSK could be there from an earlier round
625                 if (ext == SSLExtension.CH_PRE_SHARED_KEY) {
626                     continue;
627                 }
628                 int extID = ext.id;
629                 hos.putInt16(extID);
630                 hos.putBytes16(extData);
631             }
632 
633             // partial PSK extension
634             int extID = SSLExtension.CH_PRE_SHARED_KEY.id;
635             hos.putInt16(extID);
636             byte[] encodedPsk = psk.getEncoded();
637             hos.putInt16(encodedPsk.length);
638             hos.write(encodedPsk, 0, psk.getIdsEncodedLength() + 2);
639         }
640     }
641 
642     private static final
643             class CHPreSharedKeyProducer implements HandshakeProducer {
644         // Prevent instantiation of this class.
645         private CHPreSharedKeyProducer() {
646             // blank
647         }
648 
649         @Override
650         public byte[] produce(ConnectionContext context,
651                 HandshakeMessage message) throws IOException {
652 
653             // The producing happens in client side only.
654             ClientHandshakeContext chc = (ClientHandshakeContext)context;
655             if (!chc.isResumption || chc.resumingSession == null) {
656                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
657                     SSLLogger.fine(&quot;No session to resume.&quot;);
658                 }
659                 return null;
660             }
661 
662             // Make sure the list of supported signature algorithms matches
663             Collection&lt;SignatureScheme&gt; sessionSigAlgs =
664                 chc.resumingSession.getLocalSupportedSignatureSchemes();
665             if (!chc.localSupportedSignAlgs.containsAll(sessionSigAlgs)) {
666                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
667                     SSLLogger.fine(&quot;Existing session uses different &quot; +
668                         &quot;signature algorithms&quot;);
669                 }
670                 return null;
671             }
672 
673             // The session must have a pre-shared key
674             SecretKey psk = chc.resumingSession.getPreSharedKey();
675             if (psk == null) {
676                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
677                     SSLLogger.fine(&quot;Existing session has no PSK.&quot;);
678                 }
679                 return null;
680             }
681 
682             // The PSK ID can only be used in one connections, but this method
683             // may be called twice in a connection if the server sends HRR.
684             // ID is saved in the context so it can be used in the second call.
685             if (chc.pskIdentity == null) {
686                 chc.pskIdentity = chc.resumingSession.consumePskIdentity();
687             }
688 
689             if (chc.pskIdentity == null) {
690                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
691                     SSLLogger.fine(
692                         &quot;PSK has no identity, or identity was already used&quot;);
693                 }
694                 return null;
695             }
696 
697             //The session cannot be used again. Remove it from the cache.
698             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
699                 chc.sslContext.engineGetClientSessionContext();
700             sessionCache.remove(chc.resumingSession.getSessionId());
701 
702             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
703                 SSLLogger.fine(
704                     &quot;Found resumable session. Preparing PSK message.&quot;);
705             }
706 
707             List&lt;PskIdentity&gt; identities = new ArrayList&lt;&gt;();
708             int ageMillis = (int)(System.currentTimeMillis() -
709                     chc.resumingSession.getTicketCreationTime());
710             int obfuscatedAge =
711                     ageMillis + chc.resumingSession.getTicketAgeAdd();
712             identities.add(new PskIdentity(chc.pskIdentity, obfuscatedAge));
713 
714             SecretKey binderKey =
715                     deriveBinderKey(chc, psk, chc.resumingSession);
716             ClientHelloMessage clientHello = (ClientHelloMessage)message;
717             CHPreSharedKeySpec pskPrototype = createPskPrototype(
718                 chc.resumingSession.getSuite().hashAlg.hashLength, identities);
719             HandshakeHash pskBinderHash = chc.handshakeHash.copy();
720 
721             byte[] binder = computeBinder(chc, binderKey, pskBinderHash,
722                     chc.resumingSession, chc, clientHello, pskPrototype);
723 
724             List&lt;byte[]&gt; binders = new ArrayList&lt;&gt;();
725             binders.add(binder);
726 
727             CHPreSharedKeySpec pskMessage =
728                     new CHPreSharedKeySpec(identities, binders);
729             chc.handshakeExtensions.put(CH_PRE_SHARED_KEY, pskMessage);
730             return pskMessage.getEncoded();
731         }
732 
733         private CHPreSharedKeySpec createPskPrototype(
734                 int hashLength, List&lt;PskIdentity&gt; identities) {
735             List&lt;byte[]&gt; binders = new ArrayList&lt;&gt;();
736             byte[] binderProto = new byte[hashLength];
737             int i = identities.size();
738             while (i-- &gt; 0) {
739                 binders.add(binderProto);
740             }
741 
742             return new CHPreSharedKeySpec(identities, binders);
743         }
744     }
745 
746     private static byte[] computeBinder(
747             HandshakeContext context, SecretKey binderKey,
748             SSLSessionImpl session,
749             HandshakeHash pskBinderHash) throws IOException {
750 
751         pskBinderHash.determine(
752                 session.getProtocolVersion(), session.getSuite());
753         pskBinderHash.update();
754         byte[] digest = pskBinderHash.digest();
755 
756         return computeBinder(context, binderKey, session, digest);
757     }
758 
759     private static byte[] computeBinder(
760             HandshakeContext context, SecretKey binderKey,
761             HandshakeHash hash, SSLSessionImpl session,
762             HandshakeContext ctx, ClientHello.ClientHelloMessage hello,
763             CHPreSharedKeySpec pskPrototype) throws IOException {
764 
765         PartialClientHelloMessage partialMsg =
766                 new PartialClientHelloMessage(ctx, hello, pskPrototype);
767 
768         SSLEngineOutputRecord record = new SSLEngineOutputRecord(hash);
769         HandshakeOutStream hos = new HandshakeOutStream(record);
770         partialMsg.write(hos);
771 
772         hash.determine(session.getProtocolVersion(), session.getSuite());
773         hash.update();
774         byte[] digest = hash.digest();
775 
776         return computeBinder(context, binderKey, session, digest);
777     }
778 
779     private static byte[] computeBinder(HandshakeContext context,
780             SecretKey binderKey,
781             SSLSessionImpl session, byte[] digest) throws IOException {
782         try {
783             CipherSuite.HashAlg hashAlg = session.getSuite().hashAlg;
784             HKDF hkdf = new HKDF(hashAlg.name);
785             byte[] label = (&quot;tls13 finished&quot;).getBytes();
786             byte[] hkdfInfo = SSLSecretDerivation.createHkdfInfo(
787                     label, new byte[0], hashAlg.hashLength);
788             SecretKey finishedKey = hkdf.expand(
789                     binderKey, hkdfInfo, hashAlg.hashLength, &quot;TlsBinderKey&quot;);
790 
791             String hmacAlg =
792                 &quot;Hmac&quot; + hashAlg.name.replace(&quot;-&quot;, &quot;&quot;);
793             try {
794                 Mac hmac = Mac.getInstance(hmacAlg);
795                 hmac.init(finishedKey);
796                 return hmac.doFinal(digest);
797             } catch (NoSuchAlgorithmException | InvalidKeyException ex) {
798                 throw context.conContext.fatal(Alert.INTERNAL_ERROR, ex);
799             }
800         } catch (GeneralSecurityException ex) {
801             throw context.conContext.fatal(Alert.INTERNAL_ERROR, ex);
802         }
803     }
804 
805     private static SecretKey deriveBinderKey(HandshakeContext context,
806             SecretKey psk, SSLSessionImpl session) throws IOException {
807         try {
808             CipherSuite.HashAlg hashAlg = session.getSuite().hashAlg;
809             HKDF hkdf = new HKDF(hashAlg.name);
810             byte[] zeros = new byte[hashAlg.hashLength];
811             SecretKey earlySecret = hkdf.extract(zeros, psk, &quot;TlsEarlySecret&quot;);
812 
813             byte[] label = (&quot;tls13 res binder&quot;).getBytes();
814             MessageDigest md = MessageDigest.getInstance(hashAlg.name);
815             byte[] hkdfInfo = SSLSecretDerivation.createHkdfInfo(
816                     label, md.digest(new byte[0]), hashAlg.hashLength);
817             return hkdf.expand(earlySecret,
818                     hkdfInfo, hashAlg.hashLength, &quot;TlsBinderKey&quot;);
819         } catch (GeneralSecurityException ex) {
820             throw context.conContext.fatal(Alert.INTERNAL_ERROR, ex);
821         }
822     }
823 
824     private static final
825             class CHPreSharedKeyAbsence implements HandshakeAbsence {
826         @Override
827         public void absent(ConnectionContext context,
828                            HandshakeMessage message) throws IOException {
829 
830             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
831                 SSLLogger.fine(
832                 &quot;Handling pre_shared_key absence.&quot;);
833             }
834 
835             ServerHandshakeContext shc = (ServerHandshakeContext)context;
836 
837             // Resumption is only determined by PSK, when enabled
838             shc.resumingSession = null;
839             shc.isResumption = false;
840         }
841     }
842 
843     private static final
844             class SHPreSharedKeyConsumer implements ExtensionConsumer {
845         // Prevent instantiation of this class.
846         private SHPreSharedKeyConsumer() {
847             // blank
848         }
849 
850         @Override
851         public void consume(ConnectionContext context,
852             HandshakeMessage message, ByteBuffer buffer) throws IOException {
853             // The consuming happens in client side only.
854             ClientHandshakeContext chc = (ClientHandshakeContext)context;
855 
856             // Is it a response of the specific request?
857             if (!chc.handshakeExtensions.containsKey(
858                     SSLExtension.CH_PRE_SHARED_KEY)) {
859                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
860                     &quot;Server sent unexpected pre_shared_key extension&quot;);
861             }
862 
863             SHPreSharedKeySpec shPsk = new SHPreSharedKeySpec(chc, buffer);
864             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
865                 SSLLogger.fine(
866                     &quot;Received pre_shared_key extension: &quot;, shPsk);
867             }
868 
869             if (shPsk.selectedIdentity != 0) {
870                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
871                     &quot;Selected identity index is not in correct range.&quot;);
872             }
873 
874             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
875                 SSLLogger.fine(
876                         &quot;Resuming session: &quot;, chc.resumingSession);
877             }
878         }
879     }
880 
881     private static final
882             class SHPreSharedKeyAbsence implements HandshakeAbsence {
883         @Override
884         public void absent(ConnectionContext context,
885                 HandshakeMessage message) throws IOException {
886             ClientHandshakeContext chc = (ClientHandshakeContext)context;
887 
888             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
889                 SSLLogger.fine(&quot;Handling pre_shared_key absence.&quot;);
890             }
891 
892             // The server refused to resume, or the client did not
893             // request 1.3 resumption.
894             chc.resumingSession = null;
895             chc.isResumption = false;
896         }
897     }
898 
899     private static final
900             class SHPreSharedKeyProducer implements HandshakeProducer {
901         // Prevent instantiation of this class.
902         private SHPreSharedKeyProducer() {
903             // blank
904         }
905 
906         @Override
907         public byte[] produce(ConnectionContext context,
908                 HandshakeMessage message) throws IOException {
909             ServerHandshakeContext shc = (ServerHandshakeContext)context;
910             SHPreSharedKeySpec psk = (SHPreSharedKeySpec)
911                     shc.handshakeExtensions.get(SH_PRE_SHARED_KEY);
912             if (psk == null) {
913                 return null;
914             }
915 
916             return psk.getEncoded();
917         }
918     }
919 }
    </pre>
  </body>
</html>
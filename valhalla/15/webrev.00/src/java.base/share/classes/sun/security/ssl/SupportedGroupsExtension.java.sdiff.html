<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SupportedGroupsExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SignatureAlgorithmsExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SupportedVersionsExtension.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SupportedGroupsExtension.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 61             new EESupportedGroupsConsumer();
 62 
 63     /**
 64      * The &quot;supported_groups&quot; extension.
 65      */
 66     static final class SupportedGroupsSpec implements SSLExtensionSpec {
 67         final int[] namedGroupsIds;
 68 
 69         private SupportedGroupsSpec(int[] namedGroupsIds) {
 70             this.namedGroupsIds = namedGroupsIds;
 71         }
 72 
 73         private SupportedGroupsSpec(List&lt;NamedGroup&gt; namedGroups) {
 74             this.namedGroupsIds = new int[namedGroups.size()];
 75             int i = 0;
 76             for (NamedGroup ng : namedGroups) {
 77                 namedGroupsIds[i++] = ng.id;
 78             }
 79         }
 80 
<span class="line-modified"> 81         private SupportedGroupsSpec(ByteBuffer m) throws IOException  {</span>

 82             if (m.remaining() &lt; 2) {      // 2: the length of the list
<span class="line-modified"> 83                 throw new SSLProtocolException(</span>
<span class="line-modified"> 84                     &quot;Invalid supported_groups extension: insufficient data&quot;);</span>

 85             }
 86 
 87             byte[] ngs = Record.getBytes16(m);
 88             if (m.hasRemaining()) {
<span class="line-modified"> 89                 throw new SSLProtocolException(</span>
<span class="line-modified"> 90                     &quot;Invalid supported_groups extension: unknown extra data&quot;);</span>

 91             }
 92 
 93             if ((ngs == null) || (ngs.length == 0) || (ngs.length % 2 != 0)) {
<span class="line-modified"> 94                 throw new SSLProtocolException(</span>
<span class="line-modified"> 95                     &quot;Invalid supported_groups extension: incomplete data&quot;);</span>

 96             }
 97 
 98             int[] ids = new int[ngs.length / 2];
 99             for (int i = 0, j = 0; i &lt; ngs.length;) {
100                 ids[j++] = ((ngs[i++] &amp; 0xFF) &lt;&lt; 8) | (ngs[i++] &amp; 0xFF);
101             }
102 
103             this.namedGroupsIds = ids;
104         }
105 
106         @Override
107         public String toString() {
108             MessageFormat messageFormat = new MessageFormat(
109                 &quot;\&quot;versions\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
110 
111             if (namedGroupsIds == null || namedGroupsIds.length == 0) {
112                 Object[] messageFields = {
113                         &quot;&lt;no supported named group specified&gt;&quot;
114                     };
115                 return messageFormat.format(messageFields);
</pre>
<hr />
<pre>
121                         isFirst = false;
122                     } else {
123                         builder.append(&quot;, &quot;);
124                     }
125 
126                     builder.append(NamedGroup.nameOf(ngid));
127                 }
128 
129                 Object[] messageFields = {
130                         builder.toString()
131                     };
132 
133                 return messageFormat.format(messageFields);
134             }
135         }
136     }
137 
138     private static final
139             class SupportedGroupsStringizer implements SSLStringizer {
140         @Override
<span class="line-modified">141         public String toString(ByteBuffer buffer) {</span>
142             try {
<span class="line-modified">143                 return (new SupportedGroupsSpec(buffer)).toString();</span>
144             } catch (IOException ioe) {
145                 // For debug logging only, so please swallow exceptions.
146                 return ioe.getMessage();
147             }
148         }
149     }
150 
151     static class SupportedGroups {
152         // To switch off the supported_groups extension for DHE cipher suite.
153         static final boolean enableFFDHE =
154                 Utilities.getBooleanProperty(&quot;jsse.enableFFDHE&quot;, true);
155 
156         // the supported named groups
157         static final NamedGroup[] supportedNamedGroups;
158 
159         static {
160             // The value of the System Property defines a list of enabled named
161             // groups in preference order, separated with comma.  For example:
162             //
163             //      jdk.tls.namedGroups=&quot;secp521r1, secp256r1, ffdhe2048&quot;
</pre>
<hr />
<pre>
397         private CHSupportedGroupsConsumer() {
398             // blank
399         }
400 
401         @Override
402         public void consume(ConnectionContext context,
403             HandshakeMessage message, ByteBuffer buffer) throws IOException {
404             // The consuming happens in server side only.
405             ServerHandshakeContext shc = (ServerHandshakeContext)context;
406 
407             // Is it a supported and enabled extension?
408             if (!shc.sslConfig.isAvailable(CH_SUPPORTED_GROUPS)) {
409                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
410                     SSLLogger.fine(
411                         &quot;Ignore unavailable supported_groups extension&quot;);
412                 }
413                 return;     // ignore the extension
414             }
415 
416             // Parse the extension.
<span class="line-modified">417             SupportedGroupsSpec spec;</span>
<span class="line-removed">418             try {</span>
<span class="line-removed">419                 spec = new SupportedGroupsSpec(buffer);</span>
<span class="line-removed">420             } catch (IOException ioe) {</span>
<span class="line-removed">421                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed">422             }</span>
423 
424             // Update the context.
425             List&lt;NamedGroup&gt; knownNamedGroups = new LinkedList&lt;&gt;();
426             for (int id : spec.namedGroupsIds) {
427                 NamedGroup ng = NamedGroup.valueOf(id);
428                 if (ng != null) {
429                     knownNamedGroups.add(ng);
430                 }
431             }
432 
433             shc.clientRequestedNamedGroups = knownNamedGroups;
434             shc.handshakeExtensions.put(CH_SUPPORTED_GROUPS, spec);
435 
436             // No impact on session resumption.
437         }
438     }
439 
440     /**
441      * Network data producer of a &quot;supported_groups&quot; extension in
442      * the EncryptedExtensions handshake message.
</pre>
<hr />
<pre>
518         private EESupportedGroupsConsumer() {
519             // blank
520         }
521 
522         @Override
523         public void consume(ConnectionContext context,
524             HandshakeMessage message, ByteBuffer buffer) throws IOException {
525             // The consuming happens in client side only.
526             ClientHandshakeContext chc = (ClientHandshakeContext)context;
527 
528             // Is it a supported and enabled extension?
529             if (!chc.sslConfig.isAvailable(EE_SUPPORTED_GROUPS)) {
530                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
531                     SSLLogger.fine(
532                         &quot;Ignore unavailable supported_groups extension&quot;);
533                 }
534                 return;     // ignore the extension
535             }
536 
537             // Parse the extension.
<span class="line-modified">538             SupportedGroupsSpec spec;</span>
<span class="line-removed">539             try {</span>
<span class="line-removed">540                 spec = new SupportedGroupsSpec(buffer);</span>
<span class="line-removed">541             } catch (IOException ioe) {</span>
<span class="line-removed">542                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed">543             }</span>
544 
545             // Update the context.
546             List&lt;NamedGroup&gt; knownNamedGroups =
547                     new ArrayList&lt;&gt;(spec.namedGroupsIds.length);
548             for (int id : spec.namedGroupsIds) {
549                 NamedGroup ng = NamedGroup.valueOf(id);
550                 if (ng != null) {
551                     knownNamedGroups.add(ng);
552                 }
553             }
554 
555             chc.conContext.serverRequestedNamedGroups = knownNamedGroups;
556             chc.handshakeExtensions.put(EE_SUPPORTED_GROUPS, spec);
557 
558             // No impact on session resumption.
559         }
560     }
561 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 61             new EESupportedGroupsConsumer();
 62 
 63     /**
 64      * The &quot;supported_groups&quot; extension.
 65      */
 66     static final class SupportedGroupsSpec implements SSLExtensionSpec {
 67         final int[] namedGroupsIds;
 68 
 69         private SupportedGroupsSpec(int[] namedGroupsIds) {
 70             this.namedGroupsIds = namedGroupsIds;
 71         }
 72 
 73         private SupportedGroupsSpec(List&lt;NamedGroup&gt; namedGroups) {
 74             this.namedGroupsIds = new int[namedGroups.size()];
 75             int i = 0;
 76             for (NamedGroup ng : namedGroups) {
 77                 namedGroupsIds[i++] = ng.id;
 78             }
 79         }
 80 
<span class="line-modified"> 81         private SupportedGroupsSpec(HandshakeContext hc,</span>
<span class="line-added"> 82                 ByteBuffer m) throws IOException  {</span>
 83             if (m.remaining() &lt; 2) {      // 2: the length of the list
<span class="line-modified"> 84                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified"> 85                         new SSLProtocolException(</span>
<span class="line-added"> 86                     &quot;Invalid supported_groups extension: insufficient data&quot;));</span>
 87             }
 88 
 89             byte[] ngs = Record.getBytes16(m);
 90             if (m.hasRemaining()) {
<span class="line-modified"> 91                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified"> 92                         new SSLProtocolException(</span>
<span class="line-added"> 93                     &quot;Invalid supported_groups extension: unknown extra data&quot;));</span>
 94             }
 95 
 96             if ((ngs == null) || (ngs.length == 0) || (ngs.length % 2 != 0)) {
<span class="line-modified"> 97                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified"> 98                         new SSLProtocolException(</span>
<span class="line-added"> 99                     &quot;Invalid supported_groups extension: incomplete data&quot;));</span>
100             }
101 
102             int[] ids = new int[ngs.length / 2];
103             for (int i = 0, j = 0; i &lt; ngs.length;) {
104                 ids[j++] = ((ngs[i++] &amp; 0xFF) &lt;&lt; 8) | (ngs[i++] &amp; 0xFF);
105             }
106 
107             this.namedGroupsIds = ids;
108         }
109 
110         @Override
111         public String toString() {
112             MessageFormat messageFormat = new MessageFormat(
113                 &quot;\&quot;versions\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
114 
115             if (namedGroupsIds == null || namedGroupsIds.length == 0) {
116                 Object[] messageFields = {
117                         &quot;&lt;no supported named group specified&gt;&quot;
118                     };
119                 return messageFormat.format(messageFields);
</pre>
<hr />
<pre>
125                         isFirst = false;
126                     } else {
127                         builder.append(&quot;, &quot;);
128                     }
129 
130                     builder.append(NamedGroup.nameOf(ngid));
131                 }
132 
133                 Object[] messageFields = {
134                         builder.toString()
135                     };
136 
137                 return messageFormat.format(messageFields);
138             }
139         }
140     }
141 
142     private static final
143             class SupportedGroupsStringizer implements SSLStringizer {
144         @Override
<span class="line-modified">145         public String toString(HandshakeContext hc, ByteBuffer buffer) {</span>
146             try {
<span class="line-modified">147                 return (new SupportedGroupsSpec(hc, buffer)).toString();</span>
148             } catch (IOException ioe) {
149                 // For debug logging only, so please swallow exceptions.
150                 return ioe.getMessage();
151             }
152         }
153     }
154 
155     static class SupportedGroups {
156         // To switch off the supported_groups extension for DHE cipher suite.
157         static final boolean enableFFDHE =
158                 Utilities.getBooleanProperty(&quot;jsse.enableFFDHE&quot;, true);
159 
160         // the supported named groups
161         static final NamedGroup[] supportedNamedGroups;
162 
163         static {
164             // The value of the System Property defines a list of enabled named
165             // groups in preference order, separated with comma.  For example:
166             //
167             //      jdk.tls.namedGroups=&quot;secp521r1, secp256r1, ffdhe2048&quot;
</pre>
<hr />
<pre>
401         private CHSupportedGroupsConsumer() {
402             // blank
403         }
404 
405         @Override
406         public void consume(ConnectionContext context,
407             HandshakeMessage message, ByteBuffer buffer) throws IOException {
408             // The consuming happens in server side only.
409             ServerHandshakeContext shc = (ServerHandshakeContext)context;
410 
411             // Is it a supported and enabled extension?
412             if (!shc.sslConfig.isAvailable(CH_SUPPORTED_GROUPS)) {
413                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
414                     SSLLogger.fine(
415                         &quot;Ignore unavailable supported_groups extension&quot;);
416                 }
417                 return;     // ignore the extension
418             }
419 
420             // Parse the extension.
<span class="line-modified">421             SupportedGroupsSpec spec = new SupportedGroupsSpec(shc, buffer);</span>





422 
423             // Update the context.
424             List&lt;NamedGroup&gt; knownNamedGroups = new LinkedList&lt;&gt;();
425             for (int id : spec.namedGroupsIds) {
426                 NamedGroup ng = NamedGroup.valueOf(id);
427                 if (ng != null) {
428                     knownNamedGroups.add(ng);
429                 }
430             }
431 
432             shc.clientRequestedNamedGroups = knownNamedGroups;
433             shc.handshakeExtensions.put(CH_SUPPORTED_GROUPS, spec);
434 
435             // No impact on session resumption.
436         }
437     }
438 
439     /**
440      * Network data producer of a &quot;supported_groups&quot; extension in
441      * the EncryptedExtensions handshake message.
</pre>
<hr />
<pre>
517         private EESupportedGroupsConsumer() {
518             // blank
519         }
520 
521         @Override
522         public void consume(ConnectionContext context,
523             HandshakeMessage message, ByteBuffer buffer) throws IOException {
524             // The consuming happens in client side only.
525             ClientHandshakeContext chc = (ClientHandshakeContext)context;
526 
527             // Is it a supported and enabled extension?
528             if (!chc.sslConfig.isAvailable(EE_SUPPORTED_GROUPS)) {
529                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
530                     SSLLogger.fine(
531                         &quot;Ignore unavailable supported_groups extension&quot;);
532                 }
533                 return;     // ignore the extension
534             }
535 
536             // Parse the extension.
<span class="line-modified">537             SupportedGroupsSpec spec = new SupportedGroupsSpec(chc, buffer);</span>





538 
539             // Update the context.
540             List&lt;NamedGroup&gt; knownNamedGroups =
541                     new ArrayList&lt;&gt;(spec.namedGroupsIds.length);
542             for (int id : spec.namedGroupsIds) {
543                 NamedGroup ng = NamedGroup.valueOf(id);
544                 if (ng != null) {
545                     knownNamedGroups.add(ng);
546                 }
547             }
548 
549             chc.conContext.serverRequestedNamedGroups = knownNamedGroups;
550             chc.handshakeExtensions.put(EE_SUPPORTED_GROUPS, spec);
551 
552             // No impact on session resumption.
553         }
554     }
555 }
</pre>
</td>
</tr>
</table>
<center><a href="SignatureAlgorithmsExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SupportedVersionsExtension.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
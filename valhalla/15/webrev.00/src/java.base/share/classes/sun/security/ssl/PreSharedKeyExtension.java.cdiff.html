<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/sun/security/ssl/PreSharedKeyExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="PostHandshakeContext.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PskKeyExchangeModesExtension.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/PreSharedKeyExtension.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 34,10 ***</span>
<span class="line-new-header">--- 34,11 ---</span>
  import java.util.Arrays;
  import java.util.Collection;
  import javax.crypto.Mac;
  import javax.crypto.SecretKey;
  import javax.net.ssl.SSLPeerUnverifiedException;
<span class="line-added">+ import javax.net.ssl.SSLProtocolException;</span>
  import static sun.security.ssl.ClientAuthType.CLIENT_AUTH_REQUIRED;
  import sun.security.ssl.ClientHello.ClientHelloMessage;
  import sun.security.ssl.SSLExtension.ExtensionConsumer;
  import sun.security.ssl.SSLExtension.SSLExtensionSpec;
  import sun.security.ssl.SSLHandshake.HandshakeMessage;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 103,69 ***</span>
          CHPreSharedKeySpec(List&lt;PskIdentity&gt; identities, List&lt;byte[]&gt; binders) {
              this.identities = identities;
              this.binders = binders;
          }
  
<span class="line-modified">!         CHPreSharedKeySpec(HandshakeContext context,</span>
                  ByteBuffer m) throws IOException {
              // struct {
              //     PskIdentity identities&lt;7..2^16-1&gt;;
              //     PskBinderEntry binders&lt;33..2^16-1&gt;;
              // } OfferedPsks;
              if (m.remaining() &lt; 44) {
<span class="line-modified">!                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
                      &quot;Invalid pre_shared_key extension: &quot; +
<span class="line-modified">!                     &quot;insufficient data (length=&quot; + m.remaining() + &quot;)&quot;);</span>
              }
  
              int idEncodedLength = Record.getInt16(m);
              if (idEncodedLength &lt; 7) {
<span class="line-modified">!                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
                      &quot;Invalid pre_shared_key extension: &quot; +
<span class="line-modified">!                     &quot;insufficient identities (length=&quot; + idEncodedLength + &quot;)&quot;);</span>
              }
  
              identities = new ArrayList&lt;&gt;();
              int idReadLength = 0;
              while (idReadLength &lt; idEncodedLength) {
                  byte[] id = Record.getBytes16(m);
                  if (id.length &lt; 1) {
<span class="line-modified">!                     throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
                          &quot;Invalid pre_shared_key extension: &quot; +
<span class="line-modified">!                         &quot;insufficient identity (length=&quot; + id.length + &quot;)&quot;);</span>
                  }
                  int obfuscatedTicketAge = Record.getInt32(m);
  
                  PskIdentity pskId = new PskIdentity(id, obfuscatedTicketAge);
                  identities.add(pskId);
                  idReadLength += pskId.getEncodedLength();
              }
  
              if (m.remaining() &lt; 35) {
<span class="line-modified">!                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-modified">!                         &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">!                         &quot;insufficient binders data (length=&quot; +</span>
<span class="line-modified">!                         m.remaining() + &quot;)&quot;);</span>
              }
  
              int bindersEncodedLen = Record.getInt16(m);
              if (bindersEncodedLen &lt; 33) {
<span class="line-modified">!                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-modified">!                         &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">!                         &quot;insufficient binders (length=&quot; +</span>
<span class="line-modified">!                         bindersEncodedLen + &quot;)&quot;);</span>
              }
  
              binders = new ArrayList&lt;&gt;();
              int bindersReadLength = 0;
              while (bindersReadLength &lt; bindersEncodedLen) {
                  byte[] binder = Record.getBytes8(m);
                  if (binder.length &lt; 32) {
<span class="line-modified">!                     throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-modified">!                             &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">!                             &quot;insufficient binder entry (length=&quot; +</span>
<span class="line-modified">!                             binder.length + &quot;)&quot;);</span>
                  }
                  binders.add(binder);
                  bindersReadLength += 1 + binder.length;
              }
          }
<span class="line-new-header">--- 104,75 ---</span>
          CHPreSharedKeySpec(List&lt;PskIdentity&gt; identities, List&lt;byte[]&gt; binders) {
              this.identities = identities;
              this.binders = binders;
          }
  
<span class="line-modified">!         CHPreSharedKeySpec(HandshakeContext hc,</span>
                  ByteBuffer m) throws IOException {
              // struct {
              //     PskIdentity identities&lt;7..2^16-1&gt;;
              //     PskBinderEntry binders&lt;33..2^16-1&gt;;
              // } OfferedPsks;
              if (m.remaining() &lt; 44) {
<span class="line-modified">!                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-added">+                         new SSLProtocolException(</span>
                      &quot;Invalid pre_shared_key extension: &quot; +
<span class="line-modified">!                     &quot;insufficient data (length=&quot; + m.remaining() + &quot;)&quot;));</span>
              }
  
              int idEncodedLength = Record.getInt16(m);
              if (idEncodedLength &lt; 7) {
<span class="line-modified">!                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-added">+                         new SSLProtocolException(</span>
                      &quot;Invalid pre_shared_key extension: &quot; +
<span class="line-modified">!                     &quot;insufficient identities (length=&quot; + idEncodedLength + &quot;)&quot;));</span>
              }
  
              identities = new ArrayList&lt;&gt;();
              int idReadLength = 0;
              while (idReadLength &lt; idEncodedLength) {
                  byte[] id = Record.getBytes16(m);
                  if (id.length &lt; 1) {
<span class="line-modified">!                     throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-added">+                             new SSLProtocolException(</span>
                          &quot;Invalid pre_shared_key extension: &quot; +
<span class="line-modified">!                         &quot;insufficient identity (length=&quot; + id.length + &quot;)&quot;));</span>
                  }
                  int obfuscatedTicketAge = Record.getInt32(m);
  
                  PskIdentity pskId = new PskIdentity(id, obfuscatedTicketAge);
                  identities.add(pskId);
                  idReadLength += pskId.getEncodedLength();
              }
  
              if (m.remaining() &lt; 35) {
<span class="line-modified">!                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">!                         new SSLProtocolException(</span>
<span class="line-modified">!                     &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">!                     &quot;insufficient binders data (length=&quot; +</span>
<span class="line-added">+                     m.remaining() + &quot;)&quot;));</span>
              }
  
              int bindersEncodedLen = Record.getInt16(m);
              if (bindersEncodedLen &lt; 33) {
<span class="line-modified">!                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">!                         new SSLProtocolException(</span>
<span class="line-modified">!                     &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">!                     &quot;insufficient binders (length=&quot; +</span>
<span class="line-added">+                     bindersEncodedLen + &quot;)&quot;));</span>
              }
  
              binders = new ArrayList&lt;&gt;();
              int bindersReadLength = 0;
              while (bindersReadLength &lt; bindersEncodedLen) {
                  byte[] binder = Record.getBytes8(m);
                  if (binder.length &lt; 32) {
<span class="line-modified">!                     throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">!                             new SSLProtocolException(</span>
<span class="line-modified">!                         &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">!                         &quot;insufficient binder entry (length=&quot; +</span>
<span class="line-added">+                         binder.length + &quot;)&quot;));</span>
                  }
                  binders.add(binder);
                  bindersReadLength += 1 + binder.length;
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 249,19 ***</span>
      }
  
      private static final
              class CHPreSharedKeyStringizer implements SSLStringizer {
          @Override
<span class="line-modified">!         public String toString(ByteBuffer buffer) {</span>
              try {
<span class="line-modified">!                 // As the HandshakeContext parameter of CHPreSharedKeySpec</span>
<span class="line-removed">-                 // constructor is used for fatal alert only, we can use</span>
<span class="line-removed">-                 // null HandshakeContext here as we don&#39;t care about exception.</span>
<span class="line-removed">-                 //</span>
<span class="line-removed">-                 // Please take care of this code if the CHPreSharedKeySpec</span>
<span class="line-removed">-                 // constructor is updated in the future.</span>
<span class="line-removed">-                 return (new CHPreSharedKeySpec(null, buffer)).toString();</span>
              } catch (Exception ex) {
                  // For debug logging only, so please swallow exceptions.
                  return ex.getMessage();
              }
          }
<span class="line-new-header">--- 256,13 ---</span>
      }
  
      private static final
              class CHPreSharedKeyStringizer implements SSLStringizer {
          @Override
<span class="line-modified">!         public String toString(HandshakeContext hc, ByteBuffer buffer) {</span>
              try {
<span class="line-modified">!                 return (new CHPreSharedKeySpec(hc, buffer)).toString();</span>
              } catch (Exception ex) {
                  // For debug logging only, so please swallow exceptions.
                  return ex.getMessage();
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 273,17 ***</span>
  
          SHPreSharedKeySpec(int selectedIdentity) {
              this.selectedIdentity = selectedIdentity;
          }
  
<span class="line-modified">!         SHPreSharedKeySpec(HandshakeContext context,</span>
                  ByteBuffer m) throws IOException {
              if (m.remaining() &lt; 2) {
<span class="line-modified">!                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-modified">!                         &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">!                         &quot;insufficient selected_identity (length=&quot; +</span>
<span class="line-modified">!                         m.remaining() + &quot;)&quot;);</span>
              }
              this.selectedIdentity = Record.getInt16(m);
          }
  
          byte[] getEncoded() {
<span class="line-new-header">--- 274,18 ---</span>
  
          SHPreSharedKeySpec(int selectedIdentity) {
              this.selectedIdentity = selectedIdentity;
          }
  
<span class="line-modified">!         SHPreSharedKeySpec(HandshakeContext hc,</span>
                  ByteBuffer m) throws IOException {
              if (m.remaining() &lt; 2) {
<span class="line-modified">!                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">!                         new SSLProtocolException(</span>
<span class="line-modified">!                     &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">!                     &quot;insufficient selected_identity (length=&quot; +</span>
<span class="line-added">+                     m.remaining() + &quot;)&quot;));</span>
              }
              this.selectedIdentity = Record.getInt16(m);
          }
  
          byte[] getEncoded() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 310,19 ***</span>
      }
  
      private static final
              class SHPreSharedKeyStringizer implements SSLStringizer {
          @Override
<span class="line-modified">!         public String toString(ByteBuffer buffer) {</span>
              try {
<span class="line-modified">!                 // As the HandshakeContext parameter of SHPreSharedKeySpec</span>
<span class="line-removed">-                 // constructor is used for fatal alert only, we can use</span>
<span class="line-removed">-                 // null HandshakeContext here as we don&#39;t care about exception.</span>
<span class="line-removed">-                 //</span>
<span class="line-removed">-                 // Please take care of this code if the SHPreSharedKeySpec</span>
<span class="line-removed">-                 // constructor is updated in the future.</span>
<span class="line-removed">-                 return (new SHPreSharedKeySpec(null, buffer)).toString();</span>
              } catch (Exception ex) {
                  // For debug logging only, so please swallow exceptions.
                  return ex.getMessage();
              }
          }
<span class="line-new-header">--- 312,13 ---</span>
      }
  
      private static final
              class SHPreSharedKeyStringizer implements SSLStringizer {
          @Override
<span class="line-modified">!         public String toString(HandshakeContext hc, ByteBuffer buffer) {</span>
              try {
<span class="line-modified">!                 return (new SHPreSharedKeySpec(hc, buffer)).toString();</span>
              } catch (Exception ex) {
                  // For debug logging only, so please swallow exceptions.
                  return ex.getMessage();
              }
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 349,16 ***</span>
                  }
                  return;     // ignore the extension
              }
  
              // Parse the extension.
<span class="line-modified">!             CHPreSharedKeySpec pskSpec = null;</span>
<span class="line-removed">-             try {</span>
<span class="line-removed">-                 pskSpec = new CHPreSharedKeySpec(shc, buffer);</span>
<span class="line-removed">-             } catch (IOException ioe) {</span>
<span class="line-removed">-                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed">-             }</span>
  
              // The &quot;psk_key_exchange_modes&quot; extension should have been loaded.
              if (!shc.handshakeExtensions.containsKey(
                      SSLExtension.PSK_KEY_EXCHANGE_MODES)) {
                  throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
<span class="line-new-header">--- 345,11 ---</span>
                  }
                  return;     // ignore the extension
              }
  
              // Parse the extension.
<span class="line-modified">!             CHPreSharedKeySpec pskSpec = new CHPreSharedKeySpec(shc, buffer);</span>
  
              // The &quot;psk_key_exchange_modes&quot; extension should have been loaded.
              if (!shc.handshakeExtensions.containsKey(
                      SSLExtension.PSK_KEY_EXCHANGE_MODES)) {
                  throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 386,11 ***</span>
                      // See if the identity is a stateless ticket
                      if (s == null &amp;&amp;
                              requestedId.identity.length &gt; SessionId.MAX_LENGTH &amp;&amp;
                              sessionCache.statelessEnabled()) {
                          ByteBuffer b =
<span class="line-modified">!                                 new SessionTicketSpec(requestedId.identity).</span>
                                          decrypt(shc);
                          if (b != null) {
                              try {
                                  s = new SSLSessionImpl(shc, b);
                              } catch (IOException | RuntimeException e) {
<span class="line-new-header">--- 377,11 ---</span>
                      // See if the identity is a stateless ticket
                      if (s == null &amp;&amp;
                              requestedId.identity.length &gt; SessionId.MAX_LENGTH &amp;&amp;
                              sessionCache.statelessEnabled()) {
                          ByteBuffer b =
<span class="line-modified">!                             new SessionTicketSpec(shc, requestedId.identity).</span>
                                          decrypt(shc);
                          if (b != null) {
                              try {
                                  s = new SSLSessionImpl(shc, b);
                              } catch (IOException | RuntimeException e) {
</pre>
<center><a href="PostHandshakeContext.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PskKeyExchangeModesExtension.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
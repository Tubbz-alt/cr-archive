<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/KeyShareExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="Finished.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MaxFragExtension.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/KeyShareExtension.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
120             HexDumpEncoder hexEncoder = new HexDumpEncoder();
121             Object[] messageFields = {
122                 NamedGroup.nameOf(namedGroupId),
123                 Utilities.indent(hexEncoder.encode(keyExchange), &quot;    &quot;)
124             };
125 
126             return messageFormat.format(messageFields);
127         }
128     }
129 
130     /**
131      * The &quot;key_share&quot; extension in a ClientHello handshake message.
132      */
133     static final class CHKeyShareSpec implements SSLExtensionSpec {
134         final List&lt;KeyShareEntry&gt; clientShares;
135 
136         private CHKeyShareSpec(List&lt;KeyShareEntry&gt; clientShares) {
137             this.clientShares = clientShares;
138         }
139 
<span class="line-modified">140         private CHKeyShareSpec(ByteBuffer buffer) throws IOException {</span>

141             // struct {
142             //      KeyShareEntry client_shares&lt;0..2^16-1&gt;;
143             // } KeyShareClientHello;
144             if (buffer.remaining() &lt; 2) {
<span class="line-modified">145                 throw new SSLProtocolException(</span>

146                     &quot;Invalid key_share extension: &quot; +
<span class="line-modified">147                     &quot;insufficient data (length=&quot; + buffer.remaining() + &quot;)&quot;);</span>
148             }
149 
150             int listLen = Record.getInt16(buffer);
151             if (listLen != buffer.remaining()) {
<span class="line-modified">152                 throw new SSLProtocolException(</span>

153                     &quot;Invalid key_share extension: &quot; +
<span class="line-modified">154                     &quot;incorrect list length (length=&quot; + listLen + &quot;)&quot;);</span>
155             }
156 
157             List&lt;KeyShareEntry&gt; keyShares = new LinkedList&lt;&gt;();
158             while (buffer.hasRemaining()) {
159                 int namedGroupId = Record.getInt16(buffer);
160                 byte[] keyExchange = Record.getBytes16(buffer);
161                 if (keyExchange.length == 0) {
<span class="line-modified">162                     throw new SSLProtocolException(</span>
<span class="line-modified">163                         &quot;Invalid key_share extension: empty key_exchange&quot;);</span>

164                 }
165 
166                 keyShares.add(new KeyShareEntry(namedGroupId, keyExchange));
167             }
168 
169             this.clientShares = Collections.unmodifiableList(keyShares);
170         }
171 
172         @Override
173         public String toString() {
174             MessageFormat messageFormat = new MessageFormat(
175                 &quot;\&quot;client_shares\&quot;: &#39;[&#39;{0}\n&#39;]&#39;&quot;, Locale.ENGLISH);
176 
177             StringBuilder builder = new StringBuilder(512);
178             for (KeyShareEntry entry : clientShares) {
179                 builder.append(entry.toString());
180             }
181 
182             Object[] messageFields = {
183                 Utilities.indent(builder.toString())
184             };
185 
186             return messageFormat.format(messageFields);
187         }
188     }
189 
190     private static final class CHKeyShareStringizer implements SSLStringizer {
191         @Override
<span class="line-modified">192         public String toString(ByteBuffer buffer) {</span>

193             try {
<span class="line-modified">194                 return (new CHKeyShareSpec(buffer)).toString();</span>
195             } catch (IOException ioe) {
196                 // For debug logging only, so please swallow exceptions.
197                 return ioe.getMessage();
198             }
199         }
200     }
201 
202     /**
203      * Network data producer of the extension in a ClientHello
204      * handshake message.
205      */
206     private static final
207             class CHKeyShareProducer implements HandshakeProducer {
208         // Prevent instantiation of this class.
209         private CHKeyShareProducer() {
210             // blank
211         }
212 
213         @Override
214         public byte[] produce(ConnectionContext context,
</pre>
<hr />
<pre>
307             ServerHandshakeContext shc = (ServerHandshakeContext)context;
308 
309             if (shc.handshakeExtensions.containsKey(SSLExtension.CH_KEY_SHARE)) {
310                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
311                     SSLLogger.fine(
312                             &quot;The key_share extension has been loaded&quot;);
313                 }
314                 return;
315             }
316 
317             // Is it a supported and enabled extension?
318             if (!shc.sslConfig.isAvailable(SSLExtension.CH_KEY_SHARE)) {
319                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
320                     SSLLogger.fine(
321                             &quot;Ignore unavailable key_share extension&quot;);
322                 }
323                 return;     // ignore the extension
324             }
325 
326             // Parse the extension
<span class="line-modified">327             CHKeyShareSpec spec;</span>
<span class="line-removed">328             try {</span>
<span class="line-removed">329                 spec = new CHKeyShareSpec(buffer);</span>
<span class="line-removed">330             } catch (IOException ioe) {</span>
<span class="line-removed">331                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed">332             }</span>
<span class="line-removed">333 </span>
334             List&lt;SSLCredentials&gt; credentials = new LinkedList&lt;&gt;();
335             for (KeyShareEntry entry : spec.clientShares) {
336                 NamedGroup ng = NamedGroup.valueOf(entry.namedGroupId);
337                 if (ng == null || !SupportedGroups.isActivatable(
338                         shc.sslConfig.algorithmConstraints, ng)) {
339                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
340                         SSLLogger.fine(
341                                 &quot;Ignore unsupported named group: &quot; +
342                                 NamedGroup.nameOf(entry.namedGroupId));
343                     }
344                     continue;
345                 }
346 
347                 try {
348                     SSLCredentials kaCred =
349                         ng.decodeCredentials(entry.keyExchange,
350                         shc.algorithmConstraints,
351                         s -&gt; SSLLogger.warning(s));
352                     if (kaCred != null) {
353                         credentials.add(kaCred);
</pre>
<hr />
<pre>
366                 shc.handshakeProducers.put(
367                         SSLHandshake.HELLO_RETRY_REQUEST.id,
368                         SSLHandshake.HELLO_RETRY_REQUEST);
369             }
370 
371             // update the context
372             shc.handshakeExtensions.put(SSLExtension.CH_KEY_SHARE, spec);
373         }
374     }
375 
376     /**
377      * The key share entry used in ServerHello &quot;key_share&quot; extensions.
378      */
379     static final class SHKeyShareSpec implements SSLExtensionSpec {
380         final KeyShareEntry serverShare;
381 
382         SHKeyShareSpec(KeyShareEntry serverShare) {
383             this.serverShare = serverShare;
384         }
385 
<span class="line-modified">386         private SHKeyShareSpec(ByteBuffer buffer) throws IOException {</span>

387             // struct {
388             //      KeyShareEntry server_share;
389             // } KeyShareServerHello;
390             if (buffer.remaining() &lt; 5) {       // 5: minimal server_share
<span class="line-modified">391                 throw new SSLProtocolException(</span>

392                     &quot;Invalid key_share extension: &quot; +
<span class="line-modified">393                     &quot;insufficient data (length=&quot; + buffer.remaining() + &quot;)&quot;);</span>
394             }
395 
396             int namedGroupId = Record.getInt16(buffer);
397             byte[] keyExchange = Record.getBytes16(buffer);
398 
399             if (buffer.hasRemaining()) {
<span class="line-modified">400                 throw new SSLProtocolException(</span>
<span class="line-modified">401                     &quot;Invalid key_share extension: unknown extra data&quot;);</span>

402             }
403 
404             this.serverShare = new KeyShareEntry(namedGroupId, keyExchange);
405         }
406 
407         @Override
408         public String toString() {
409             MessageFormat messageFormat = new MessageFormat(
410                 &quot;\&quot;server_share\&quot;: &#39;{&#39;\n&quot; +
411                 &quot;  \&quot;named group\&quot;: {0}\n&quot; +
412                 &quot;  \&quot;key_exchange\&quot;: &#39;{&#39;\n&quot; +
413                 &quot;{1}\n&quot; +
414                 &quot;  &#39;}&#39;\n&quot; +
415                 &quot;&#39;}&#39;,&quot;, Locale.ENGLISH);
416 
417             HexDumpEncoder hexEncoder = new HexDumpEncoder();
418             Object[] messageFields = {
419                 NamedGroup.nameOf(serverShare.namedGroupId),
420                 Utilities.indent(
421                         hexEncoder.encode(serverShare.keyExchange), &quot;    &quot;)
422             };
423 
424             return messageFormat.format(messageFields);
425         }
426     }
427 
428     private static final class SHKeyShareStringizer implements SSLStringizer {
429         @Override
<span class="line-modified">430         public String toString(ByteBuffer buffer) {</span>

431             try {
<span class="line-modified">432                 return (new SHKeyShareSpec(buffer)).toString();</span>
433             } catch (IOException ioe) {
434                 // For debug logging only, so please swallow exceptions.
435                 return ioe.getMessage();
436             }
437         }
438     }
439 
440     /**
441      * Network data producer of the extension in a ServerHello
442      * handshake message.
443      */
444     private static final class SHKeyShareProducer implements HandshakeProducer {
445         // Prevent instantiation of this class.
446         private SHKeyShareProducer() {
447             // blank
448         }
449 
450         @Override
451         public byte[] produce(ConnectionContext context,
452                 HandshakeMessage message) throws IOException {
</pre>
<hr />
<pre>
564 
565         @Override
566         public void consume(ConnectionContext context,
567             HandshakeMessage message, ByteBuffer buffer) throws IOException {
568             // Happens in client side only.
569             ClientHandshakeContext chc = (ClientHandshakeContext)context;
570             if (chc.clientRequestedNamedGroups == null ||
571                     chc.clientRequestedNamedGroups.isEmpty()) {
572                 // No supported groups.
573                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
574                         &quot;Unexpected key_share extension in ServerHello&quot;);
575             }
576 
577             // Is it a supported and enabled extension?
578             if (!chc.sslConfig.isAvailable(SSLExtension.SH_KEY_SHARE)) {
579                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
580                         &quot;Unsupported key_share extension in ServerHello&quot;);
581             }
582 
583             // Parse the extension
<span class="line-modified">584             SHKeyShareSpec spec;</span>
<span class="line-removed">585             try {</span>
<span class="line-removed">586                 spec = new SHKeyShareSpec(buffer);</span>
<span class="line-removed">587             } catch (IOException ioe) {</span>
<span class="line-removed">588                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed">589             }</span>
<span class="line-removed">590 </span>
591             KeyShareEntry keyShare = spec.serverShare;
592             NamedGroup ng = NamedGroup.valueOf(keyShare.namedGroupId);
593             if (ng == null || !SupportedGroups.isActivatable(
594                     chc.sslConfig.algorithmConstraints, ng)) {
595                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
596                         &quot;Unsupported named group: &quot; +
597                         NamedGroup.nameOf(keyShare.namedGroupId));
598             }
599 
600             SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
601             if (ke == null) {
602                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
603                         &quot;No key exchange for named group &quot; + ng.name);
604             }
605 
606             SSLCredentials credentials = null;
607             try {
608                 SSLCredentials kaCred = ng.decodeCredentials(
609                     keyShare.keyExchange, chc.algorithmConstraints,
610                     s -&gt; chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, s));
</pre>
<hr />
<pre>
643             // Cannot use the previous requested key shares any more.
644             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
645                 SSLLogger.fine(
646                         &quot;No key_share extension in ServerHello, &quot; +
647                         &quot;cleanup the key shares if necessary&quot;);
648             }
649             chc.handshakePossessions.clear();
650         }
651     }
652 
653     /**
654      * The key share entry used in HelloRetryRequest &quot;key_share&quot; extensions.
655      */
656     static final class HRRKeyShareSpec implements SSLExtensionSpec {
657         final int selectedGroup;
658 
659         HRRKeyShareSpec(NamedGroup serverGroup) {
660             this.selectedGroup = serverGroup.id;
661         }
662 
<span class="line-modified">663         private HRRKeyShareSpec(ByteBuffer buffer) throws IOException {</span>

664             // struct {
665             //     NamedGroup selected_group;
666             // } KeyShareHelloRetryRequest;
667             if (buffer.remaining() != 2) {
<span class="line-modified">668                 throw new SSLProtocolException(</span>

669                     &quot;Invalid key_share extension: &quot; +
<span class="line-modified">670                     &quot;improper data (length=&quot; + buffer.remaining() + &quot;)&quot;);</span>
671             }
672 
673             this.selectedGroup = Record.getInt16(buffer);
674         }
675 
676         @Override
677         public String toString() {
678             MessageFormat messageFormat = new MessageFormat(
679                 &quot;\&quot;selected group\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
680 
681             Object[] messageFields = {
682                     NamedGroup.nameOf(selectedGroup)
683                 };
684             return messageFormat.format(messageFields);
685         }
686     }
687 
688     private static final class HRRKeyShareStringizer implements SSLStringizer {
689         @Override
<span class="line-modified">690         public String toString(ByteBuffer buffer) {</span>

691             try {
<span class="line-modified">692                 return (new HRRKeyShareSpec(buffer)).toString();</span>
693             } catch (IOException ioe) {
694                 // For debug logging only, so please swallow exceptions.
695                 return ioe.getMessage();
696             }
697         }
698     }
699 
700     /**
701      * Network data producer of the extension in a HelloRetryRequest
702      * handshake message.
703      */
704     private static final
705             class HRRKeyShareProducer implements HandshakeProducer {
706         // Prevent instantiation of this class.
707         private HRRKeyShareProducer() {
708             // blank
709         }
710 
711         @Override
712         public byte[] produce(ConnectionContext context,
</pre>
<hr />
<pre>
816         @Override
817         public void consume(ConnectionContext context,
818             HandshakeMessage message, ByteBuffer buffer) throws IOException {
819             // The producing happens in client side only.
820             ClientHandshakeContext chc = (ClientHandshakeContext)context;
821 
822             // Is it a supported and enabled extension?
823             if (!chc.sslConfig.isAvailable(SSLExtension.HRR_KEY_SHARE)) {
824                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
825                         &quot;Unsupported key_share extension in HelloRetryRequest&quot;);
826             }
827 
828             if (chc.clientRequestedNamedGroups == null ||
829                     chc.clientRequestedNamedGroups.isEmpty()) {
830                 // No supported groups.
831                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
832                         &quot;Unexpected key_share extension in HelloRetryRequest&quot;);
833             }
834 
835             // Parse the extension
<span class="line-modified">836             HRRKeyShareSpec spec;</span>
<span class="line-removed">837             try {</span>
<span class="line-removed">838                 spec = new HRRKeyShareSpec(buffer);</span>
<span class="line-removed">839             } catch (IOException ioe) {</span>
<span class="line-removed">840                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed">841             }</span>
<span class="line-removed">842 </span>
843             NamedGroup serverGroup = NamedGroup.valueOf(spec.selectedGroup);
844             if (serverGroup == null) {
<span class="line-modified">845                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
846                         &quot;Unsupported HelloRetryRequest selected group: &quot; +
847                                 NamedGroup.nameOf(spec.selectedGroup));
848             }
849 
850             if (!chc.clientRequestedNamedGroups.contains(serverGroup)) {
<span class="line-modified">851                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
852                         &quot;Unexpected HelloRetryRequest selected group: &quot; +
853                                 serverGroup.name);
854             }
855 
856             // update the context
857 
858             // When sending the new ClientHello, the client MUST replace the
859             // original &quot;key_share&quot; extension with one containing only a new
860             // KeyShareEntry for the group indicated in the selected_group
861             // field of the triggering HelloRetryRequest.
862             //
863             chc.serverSelectedNamedGroup = serverGroup;
864             chc.handshakeExtensions.put(SSLExtension.HRR_KEY_SHARE, spec);
865         }
866     }
867 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
120             HexDumpEncoder hexEncoder = new HexDumpEncoder();
121             Object[] messageFields = {
122                 NamedGroup.nameOf(namedGroupId),
123                 Utilities.indent(hexEncoder.encode(keyExchange), &quot;    &quot;)
124             };
125 
126             return messageFormat.format(messageFields);
127         }
128     }
129 
130     /**
131      * The &quot;key_share&quot; extension in a ClientHello handshake message.
132      */
133     static final class CHKeyShareSpec implements SSLExtensionSpec {
134         final List&lt;KeyShareEntry&gt; clientShares;
135 
136         private CHKeyShareSpec(List&lt;KeyShareEntry&gt; clientShares) {
137             this.clientShares = clientShares;
138         }
139 
<span class="line-modified">140         private CHKeyShareSpec(HandshakeContext handshakeContext,</span>
<span class="line-added">141                 ByteBuffer buffer) throws IOException {</span>
142             // struct {
143             //      KeyShareEntry client_shares&lt;0..2^16-1&gt;;
144             // } KeyShareClientHello;
145             if (buffer.remaining() &lt; 2) {
<span class="line-modified">146                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-added">147                         new SSLProtocolException(</span>
148                     &quot;Invalid key_share extension: &quot; +
<span class="line-modified">149                     &quot;insufficient data (length=&quot; + buffer.remaining() + &quot;)&quot;));</span>
150             }
151 
152             int listLen = Record.getInt16(buffer);
153             if (listLen != buffer.remaining()) {
<span class="line-modified">154                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-added">155                         new SSLProtocolException(</span>
156                     &quot;Invalid key_share extension: &quot; +
<span class="line-modified">157                     &quot;incorrect list length (length=&quot; + listLen + &quot;)&quot;));</span>
158             }
159 
160             List&lt;KeyShareEntry&gt; keyShares = new LinkedList&lt;&gt;();
161             while (buffer.hasRemaining()) {
162                 int namedGroupId = Record.getInt16(buffer);
163                 byte[] keyExchange = Record.getBytes16(buffer);
164                 if (keyExchange.length == 0) {
<span class="line-modified">165                     throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">166                             new SSLProtocolException(</span>
<span class="line-added">167                         &quot;Invalid key_share extension: empty key_exchange&quot;));</span>
168                 }
169 
170                 keyShares.add(new KeyShareEntry(namedGroupId, keyExchange));
171             }
172 
173             this.clientShares = Collections.unmodifiableList(keyShares);
174         }
175 
176         @Override
177         public String toString() {
178             MessageFormat messageFormat = new MessageFormat(
179                 &quot;\&quot;client_shares\&quot;: &#39;[&#39;{0}\n&#39;]&#39;&quot;, Locale.ENGLISH);
180 
181             StringBuilder builder = new StringBuilder(512);
182             for (KeyShareEntry entry : clientShares) {
183                 builder.append(entry.toString());
184             }
185 
186             Object[] messageFields = {
187                 Utilities.indent(builder.toString())
188             };
189 
190             return messageFormat.format(messageFields);
191         }
192     }
193 
194     private static final class CHKeyShareStringizer implements SSLStringizer {
195         @Override
<span class="line-modified">196         public String toString(</span>
<span class="line-added">197                 HandshakeContext handshakeContext, ByteBuffer buffer) {</span>
198             try {
<span class="line-modified">199                 return (new CHKeyShareSpec(handshakeContext, buffer)).toString();</span>
200             } catch (IOException ioe) {
201                 // For debug logging only, so please swallow exceptions.
202                 return ioe.getMessage();
203             }
204         }
205     }
206 
207     /**
208      * Network data producer of the extension in a ClientHello
209      * handshake message.
210      */
211     private static final
212             class CHKeyShareProducer implements HandshakeProducer {
213         // Prevent instantiation of this class.
214         private CHKeyShareProducer() {
215             // blank
216         }
217 
218         @Override
219         public byte[] produce(ConnectionContext context,
</pre>
<hr />
<pre>
312             ServerHandshakeContext shc = (ServerHandshakeContext)context;
313 
314             if (shc.handshakeExtensions.containsKey(SSLExtension.CH_KEY_SHARE)) {
315                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
316                     SSLLogger.fine(
317                             &quot;The key_share extension has been loaded&quot;);
318                 }
319                 return;
320             }
321 
322             // Is it a supported and enabled extension?
323             if (!shc.sslConfig.isAvailable(SSLExtension.CH_KEY_SHARE)) {
324                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
325                     SSLLogger.fine(
326                             &quot;Ignore unavailable key_share extension&quot;);
327                 }
328                 return;     // ignore the extension
329             }
330 
331             // Parse the extension
<span class="line-modified">332             CHKeyShareSpec spec = new CHKeyShareSpec(shc, buffer);</span>






333             List&lt;SSLCredentials&gt; credentials = new LinkedList&lt;&gt;();
334             for (KeyShareEntry entry : spec.clientShares) {
335                 NamedGroup ng = NamedGroup.valueOf(entry.namedGroupId);
336                 if (ng == null || !SupportedGroups.isActivatable(
337                         shc.sslConfig.algorithmConstraints, ng)) {
338                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
339                         SSLLogger.fine(
340                                 &quot;Ignore unsupported named group: &quot; +
341                                 NamedGroup.nameOf(entry.namedGroupId));
342                     }
343                     continue;
344                 }
345 
346                 try {
347                     SSLCredentials kaCred =
348                         ng.decodeCredentials(entry.keyExchange,
349                         shc.algorithmConstraints,
350                         s -&gt; SSLLogger.warning(s));
351                     if (kaCred != null) {
352                         credentials.add(kaCred);
</pre>
<hr />
<pre>
365                 shc.handshakeProducers.put(
366                         SSLHandshake.HELLO_RETRY_REQUEST.id,
367                         SSLHandshake.HELLO_RETRY_REQUEST);
368             }
369 
370             // update the context
371             shc.handshakeExtensions.put(SSLExtension.CH_KEY_SHARE, spec);
372         }
373     }
374 
375     /**
376      * The key share entry used in ServerHello &quot;key_share&quot; extensions.
377      */
378     static final class SHKeyShareSpec implements SSLExtensionSpec {
379         final KeyShareEntry serverShare;
380 
381         SHKeyShareSpec(KeyShareEntry serverShare) {
382             this.serverShare = serverShare;
383         }
384 
<span class="line-modified">385         private SHKeyShareSpec(HandshakeContext handshakeContext,</span>
<span class="line-added">386                 ByteBuffer buffer) throws IOException {</span>
387             // struct {
388             //      KeyShareEntry server_share;
389             // } KeyShareServerHello;
390             if (buffer.remaining() &lt; 5) {       // 5: minimal server_share
<span class="line-modified">391                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-added">392                         new SSLProtocolException(</span>
393                     &quot;Invalid key_share extension: &quot; +
<span class="line-modified">394                     &quot;insufficient data (length=&quot; + buffer.remaining() + &quot;)&quot;));</span>
395             }
396 
397             int namedGroupId = Record.getInt16(buffer);
398             byte[] keyExchange = Record.getBytes16(buffer);
399 
400             if (buffer.hasRemaining()) {
<span class="line-modified">401                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">402                         new SSLProtocolException(</span>
<span class="line-added">403                     &quot;Invalid key_share extension: unknown extra data&quot;));</span>
404             }
405 
406             this.serverShare = new KeyShareEntry(namedGroupId, keyExchange);
407         }
408 
409         @Override
410         public String toString() {
411             MessageFormat messageFormat = new MessageFormat(
412                 &quot;\&quot;server_share\&quot;: &#39;{&#39;\n&quot; +
413                 &quot;  \&quot;named group\&quot;: {0}\n&quot; +
414                 &quot;  \&quot;key_exchange\&quot;: &#39;{&#39;\n&quot; +
415                 &quot;{1}\n&quot; +
416                 &quot;  &#39;}&#39;\n&quot; +
417                 &quot;&#39;}&#39;,&quot;, Locale.ENGLISH);
418 
419             HexDumpEncoder hexEncoder = new HexDumpEncoder();
420             Object[] messageFields = {
421                 NamedGroup.nameOf(serverShare.namedGroupId),
422                 Utilities.indent(
423                         hexEncoder.encode(serverShare.keyExchange), &quot;    &quot;)
424             };
425 
426             return messageFormat.format(messageFields);
427         }
428     }
429 
430     private static final class SHKeyShareStringizer implements SSLStringizer {
431         @Override
<span class="line-modified">432         public String toString(HandshakeContext handshakeContext,</span>
<span class="line-added">433                 ByteBuffer buffer) {</span>
434             try {
<span class="line-modified">435                 return (new SHKeyShareSpec(handshakeContext, buffer)).toString();</span>
436             } catch (IOException ioe) {
437                 // For debug logging only, so please swallow exceptions.
438                 return ioe.getMessage();
439             }
440         }
441     }
442 
443     /**
444      * Network data producer of the extension in a ServerHello
445      * handshake message.
446      */
447     private static final class SHKeyShareProducer implements HandshakeProducer {
448         // Prevent instantiation of this class.
449         private SHKeyShareProducer() {
450             // blank
451         }
452 
453         @Override
454         public byte[] produce(ConnectionContext context,
455                 HandshakeMessage message) throws IOException {
</pre>
<hr />
<pre>
567 
568         @Override
569         public void consume(ConnectionContext context,
570             HandshakeMessage message, ByteBuffer buffer) throws IOException {
571             // Happens in client side only.
572             ClientHandshakeContext chc = (ClientHandshakeContext)context;
573             if (chc.clientRequestedNamedGroups == null ||
574                     chc.clientRequestedNamedGroups.isEmpty()) {
575                 // No supported groups.
576                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
577                         &quot;Unexpected key_share extension in ServerHello&quot;);
578             }
579 
580             // Is it a supported and enabled extension?
581             if (!chc.sslConfig.isAvailable(SSLExtension.SH_KEY_SHARE)) {
582                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
583                         &quot;Unsupported key_share extension in ServerHello&quot;);
584             }
585 
586             // Parse the extension
<span class="line-modified">587             SHKeyShareSpec spec = new SHKeyShareSpec(chc, buffer);</span>






588             KeyShareEntry keyShare = spec.serverShare;
589             NamedGroup ng = NamedGroup.valueOf(keyShare.namedGroupId);
590             if (ng == null || !SupportedGroups.isActivatable(
591                     chc.sslConfig.algorithmConstraints, ng)) {
592                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
593                         &quot;Unsupported named group: &quot; +
594                         NamedGroup.nameOf(keyShare.namedGroupId));
595             }
596 
597             SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
598             if (ke == null) {
599                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
600                         &quot;No key exchange for named group &quot; + ng.name);
601             }
602 
603             SSLCredentials credentials = null;
604             try {
605                 SSLCredentials kaCred = ng.decodeCredentials(
606                     keyShare.keyExchange, chc.algorithmConstraints,
607                     s -&gt; chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, s));
</pre>
<hr />
<pre>
640             // Cannot use the previous requested key shares any more.
641             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
642                 SSLLogger.fine(
643                         &quot;No key_share extension in ServerHello, &quot; +
644                         &quot;cleanup the key shares if necessary&quot;);
645             }
646             chc.handshakePossessions.clear();
647         }
648     }
649 
650     /**
651      * The key share entry used in HelloRetryRequest &quot;key_share&quot; extensions.
652      */
653     static final class HRRKeyShareSpec implements SSLExtensionSpec {
654         final int selectedGroup;
655 
656         HRRKeyShareSpec(NamedGroup serverGroup) {
657             this.selectedGroup = serverGroup.id;
658         }
659 
<span class="line-modified">660         private HRRKeyShareSpec(HandshakeContext handshakeContext,</span>
<span class="line-added">661                 ByteBuffer buffer) throws IOException {</span>
662             // struct {
663             //     NamedGroup selected_group;
664             // } KeyShareHelloRetryRequest;
665             if (buffer.remaining() != 2) {
<span class="line-modified">666                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-added">667                         new SSLProtocolException(</span>
668                     &quot;Invalid key_share extension: &quot; +
<span class="line-modified">669                     &quot;improper data (length=&quot; + buffer.remaining() + &quot;)&quot;));</span>
670             }
671 
672             this.selectedGroup = Record.getInt16(buffer);
673         }
674 
675         @Override
676         public String toString() {
677             MessageFormat messageFormat = new MessageFormat(
678                 &quot;\&quot;selected group\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
679 
680             Object[] messageFields = {
681                     NamedGroup.nameOf(selectedGroup)
682                 };
683             return messageFormat.format(messageFields);
684         }
685     }
686 
687     private static final class HRRKeyShareStringizer implements SSLStringizer {
688         @Override
<span class="line-modified">689         public String toString(HandshakeContext handshakeContext,</span>
<span class="line-added">690                 ByteBuffer buffer) {</span>
691             try {
<span class="line-modified">692                 return (new HRRKeyShareSpec(handshakeContext, buffer)).toString();</span>
693             } catch (IOException ioe) {
694                 // For debug logging only, so please swallow exceptions.
695                 return ioe.getMessage();
696             }
697         }
698     }
699 
700     /**
701      * Network data producer of the extension in a HelloRetryRequest
702      * handshake message.
703      */
704     private static final
705             class HRRKeyShareProducer implements HandshakeProducer {
706         // Prevent instantiation of this class.
707         private HRRKeyShareProducer() {
708             // blank
709         }
710 
711         @Override
712         public byte[] produce(ConnectionContext context,
</pre>
<hr />
<pre>
816         @Override
817         public void consume(ConnectionContext context,
818             HandshakeMessage message, ByteBuffer buffer) throws IOException {
819             // The producing happens in client side only.
820             ClientHandshakeContext chc = (ClientHandshakeContext)context;
821 
822             // Is it a supported and enabled extension?
823             if (!chc.sslConfig.isAvailable(SSLExtension.HRR_KEY_SHARE)) {
824                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
825                         &quot;Unsupported key_share extension in HelloRetryRequest&quot;);
826             }
827 
828             if (chc.clientRequestedNamedGroups == null ||
829                     chc.clientRequestedNamedGroups.isEmpty()) {
830                 // No supported groups.
831                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
832                         &quot;Unexpected key_share extension in HelloRetryRequest&quot;);
833             }
834 
835             // Parse the extension
<span class="line-modified">836             HRRKeyShareSpec spec = new HRRKeyShareSpec(chc, buffer);</span>






837             NamedGroup serverGroup = NamedGroup.valueOf(spec.selectedGroup);
838             if (serverGroup == null) {
<span class="line-modified">839                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
840                         &quot;Unsupported HelloRetryRequest selected group: &quot; +
841                                 NamedGroup.nameOf(spec.selectedGroup));
842             }
843 
844             if (!chc.clientRequestedNamedGroups.contains(serverGroup)) {
<span class="line-modified">845                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
846                         &quot;Unexpected HelloRetryRequest selected group: &quot; +
847                                 serverGroup.name);
848             }
849 
850             // update the context
851 
852             // When sending the new ClientHello, the client MUST replace the
853             // original &quot;key_share&quot; extension with one containing only a new
854             // KeyShareEntry for the group indicated in the selected_group
855             // field of the triggering HelloRetryRequest.
856             //
857             chc.serverSelectedNamedGroup = serverGroup;
858             chc.handshakeExtensions.put(SSLExtension.HRR_KEY_SHARE, spec);
859         }
860     }
861 }
</pre>
</td>
</tr>
</table>
<center><a href="Finished.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MaxFragExtension.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/KeyShareExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.security.ssl;
 27 
 28 import java.io.IOException;
 29 import java.nio.ByteBuffer;
 30 import java.security.GeneralSecurityException;
 31 import java.text.MessageFormat;
 32 import java.util.Arrays;
 33 import java.util.Collections;
 34 import java.util.LinkedList;
 35 import java.util.List;
 36 import java.util.Locale;
 37 import java.util.Map;
 38 import javax.net.ssl.SSLProtocolException;
 39 import sun.security.ssl.KeyShareExtension.CHKeyShareSpec;
 40 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 41 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 42 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 43 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 44 import sun.security.util.HexDumpEncoder;
 45 
 46 /**
 47  * Pack of the &quot;key_share&quot; extensions.
 48  */
 49 final class KeyShareExtension {
 50     static final HandshakeProducer chNetworkProducer =
 51             new CHKeyShareProducer();
 52     static final ExtensionConsumer chOnLoadConsumer =
 53             new CHKeyShareConsumer();
 54     static final SSLStringizer chStringizer =
 55             new CHKeyShareStringizer();
 56 
 57     static final HandshakeProducer shNetworkProducer =
 58             new SHKeyShareProducer();
 59     static final ExtensionConsumer shOnLoadConsumer =
 60             new SHKeyShareConsumer();
 61     static final HandshakeAbsence shOnLoadAbsence =
 62             new SHKeyShareAbsence();
 63     static final SSLStringizer shStringizer =
 64             new SHKeyShareStringizer();
 65 
 66     static final HandshakeProducer hrrNetworkProducer =
 67             new HRRKeyShareProducer();
 68     static final ExtensionConsumer hrrOnLoadConsumer =
 69             new HRRKeyShareConsumer();
 70     static final HandshakeProducer hrrNetworkReproducer =
 71             new HRRKeyShareReproducer();
 72     static final SSLStringizer hrrStringizer =
 73             new HRRKeyShareStringizer();
 74 
 75     /**
 76      * The key share entry used in &quot;key_share&quot; extensions.
 77      */
 78     private static final class KeyShareEntry {
 79         final int namedGroupId;
 80         final byte[] keyExchange;
 81 
 82         private KeyShareEntry(int namedGroupId, byte[] keyExchange) {
 83             this.namedGroupId = namedGroupId;
 84             this.keyExchange = keyExchange;
 85         }
 86 
 87         private byte[] getEncoded() {
 88             byte[] buffer = new byte[keyExchange.length + 4];
 89                                             //  2: named group id
 90                                             // +2: key exchange length
 91             ByteBuffer m = ByteBuffer.wrap(buffer);
 92             try {
 93                 Record.putInt16(m, namedGroupId);
 94                 Record.putBytes16(m, keyExchange);
 95             } catch (IOException ioe) {
 96                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 97                     SSLLogger.warning(
 98                         &quot;Unlikely IOException&quot;, ioe);
 99                 }
100             }
101 
102             return buffer;
103         }
104 
105         private int getEncodedSize() {
106             return keyExchange.length + 4;  //  2: named group id
107                                             // +2: key exchange length
108         }
109 
110         @Override
111         public String toString() {
112             MessageFormat messageFormat = new MessageFormat(
113                 &quot;\n&#39;{&#39;\n&quot; +
114                 &quot;  \&quot;named group\&quot;: {0}\n&quot; +
115                 &quot;  \&quot;key_exchange\&quot;: &#39;{&#39;\n&quot; +
116                 &quot;{1}\n&quot; +
117                 &quot;  &#39;}&#39;\n&quot; +
118                 &quot;&#39;}&#39;,&quot;, Locale.ENGLISH);
119 
120             HexDumpEncoder hexEncoder = new HexDumpEncoder();
121             Object[] messageFields = {
122                 NamedGroup.nameOf(namedGroupId),
123                 Utilities.indent(hexEncoder.encode(keyExchange), &quot;    &quot;)
124             };
125 
126             return messageFormat.format(messageFields);
127         }
128     }
129 
130     /**
131      * The &quot;key_share&quot; extension in a ClientHello handshake message.
132      */
133     static final class CHKeyShareSpec implements SSLExtensionSpec {
134         final List&lt;KeyShareEntry&gt; clientShares;
135 
136         private CHKeyShareSpec(List&lt;KeyShareEntry&gt; clientShares) {
137             this.clientShares = clientShares;
138         }
139 
140         private CHKeyShareSpec(HandshakeContext handshakeContext,
141                 ByteBuffer buffer) throws IOException {
142             // struct {
143             //      KeyShareEntry client_shares&lt;0..2^16-1&gt;;
144             // } KeyShareClientHello;
145             if (buffer.remaining() &lt; 2) {
146                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
147                         new SSLProtocolException(
148                     &quot;Invalid key_share extension: &quot; +
149                     &quot;insufficient data (length=&quot; + buffer.remaining() + &quot;)&quot;));
150             }
151 
152             int listLen = Record.getInt16(buffer);
153             if (listLen != buffer.remaining()) {
154                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
155                         new SSLProtocolException(
156                     &quot;Invalid key_share extension: &quot; +
157                     &quot;incorrect list length (length=&quot; + listLen + &quot;)&quot;));
158             }
159 
160             List&lt;KeyShareEntry&gt; keyShares = new LinkedList&lt;&gt;();
161             while (buffer.hasRemaining()) {
162                 int namedGroupId = Record.getInt16(buffer);
163                 byte[] keyExchange = Record.getBytes16(buffer);
164                 if (keyExchange.length == 0) {
165                     throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
166                             new SSLProtocolException(
167                         &quot;Invalid key_share extension: empty key_exchange&quot;));
168                 }
169 
170                 keyShares.add(new KeyShareEntry(namedGroupId, keyExchange));
171             }
172 
173             this.clientShares = Collections.unmodifiableList(keyShares);
174         }
175 
176         @Override
177         public String toString() {
178             MessageFormat messageFormat = new MessageFormat(
179                 &quot;\&quot;client_shares\&quot;: &#39;[&#39;{0}\n&#39;]&#39;&quot;, Locale.ENGLISH);
180 
181             StringBuilder builder = new StringBuilder(512);
182             for (KeyShareEntry entry : clientShares) {
183                 builder.append(entry.toString());
184             }
185 
186             Object[] messageFields = {
187                 Utilities.indent(builder.toString())
188             };
189 
190             return messageFormat.format(messageFields);
191         }
192     }
193 
194     private static final class CHKeyShareStringizer implements SSLStringizer {
195         @Override
196         public String toString(
197                 HandshakeContext handshakeContext, ByteBuffer buffer) {
198             try {
199                 return (new CHKeyShareSpec(handshakeContext, buffer)).toString();
200             } catch (IOException ioe) {
201                 // For debug logging only, so please swallow exceptions.
202                 return ioe.getMessage();
203             }
204         }
205     }
206 
207     /**
208      * Network data producer of the extension in a ClientHello
209      * handshake message.
210      */
211     private static final
212             class CHKeyShareProducer implements HandshakeProducer {
213         // Prevent instantiation of this class.
214         private CHKeyShareProducer() {
215             // blank
216         }
217 
218         @Override
219         public byte[] produce(ConnectionContext context,
220                 HandshakeMessage message) throws IOException {
221             // The producing happens in client side only.
222             ClientHandshakeContext chc = (ClientHandshakeContext)context;
223 
224             // Is it a supported and enabled extension?
225             if (!chc.sslConfig.isAvailable(SSLExtension.CH_KEY_SHARE)) {
226                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
227                     SSLLogger.fine(
228                         &quot;Ignore unavailable key_share extension&quot;);
229                 }
230                 return null;
231             }
232 
233             List&lt;NamedGroup&gt; namedGroups;
234             if (chc.serverSelectedNamedGroup != null) {
235                 // Response to HelloRetryRequest
236                 namedGroups = Arrays.asList(chc.serverSelectedNamedGroup);
237             } else {
238                 namedGroups = chc.clientRequestedNamedGroups;
239                 if (namedGroups == null || namedGroups.isEmpty()) {
240                     // No supported groups.
241                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
242                         SSLLogger.warning(
243                             &quot;Ignore key_share extension, no supported groups&quot;);
244                     }
245                     return null;
246                 }
247             }
248 
249             List&lt;KeyShareEntry&gt; keyShares = new LinkedList&lt;&gt;();
250             for (NamedGroup ng : namedGroups) {
251                 SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
252                 if (ke == null) {
253                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
254                         SSLLogger.warning(
255                             &quot;No key exchange for named group &quot; + ng.name);
256                     }
257                     continue;
258                 }
259 
260                 SSLPossession[] poses = ke.createPossessions(chc);
261                 for (SSLPossession pos : poses) {
262                     // update the context
263                     chc.handshakePossessions.add(pos);
264                     if (!(pos instanceof NamedGroupPossession)) {
265                         // May need more possesion types in the future.
266                         continue;
267                     }
268 
269                     keyShares.add(new KeyShareEntry(ng.id, pos.encode()));
270                 }
271 
272                 // One key share entry only.  Too much key share entries makes
273                 // the ClientHello handshake message really big.
274                 if (!keyShares.isEmpty()) {
275                     break;
276                 }
277             }
278 
279             int listLen = 0;
280             for (KeyShareEntry entry : keyShares) {
281                 listLen += entry.getEncodedSize();
282             }
283             byte[] extData = new byte[listLen + 2];     //  2: list length
284             ByteBuffer m = ByteBuffer.wrap(extData);
285             Record.putInt16(m, listLen);
286             for (KeyShareEntry entry : keyShares) {
287                 m.put(entry.getEncoded());
288             }
289 
290             // update the context
291             chc.handshakeExtensions.put(SSLExtension.CH_KEY_SHARE,
292                     new CHKeyShareSpec(keyShares));
293 
294             return extData;
295         }
296     }
297 
298     /**
299      * Network data consumer of the extension in a ClientHello
300      * handshake message.
301      */
302     private static final class CHKeyShareConsumer implements ExtensionConsumer {
303         // Prevent instantiation of this class.
304         private CHKeyShareConsumer() {
305             // blank
306         }
307 
308         @Override
309         public void consume(ConnectionContext context,
310             HandshakeMessage message, ByteBuffer buffer) throws IOException {
311             // The consuming happens in server side only.
312             ServerHandshakeContext shc = (ServerHandshakeContext)context;
313 
314             if (shc.handshakeExtensions.containsKey(SSLExtension.CH_KEY_SHARE)) {
315                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
316                     SSLLogger.fine(
317                             &quot;The key_share extension has been loaded&quot;);
318                 }
319                 return;
320             }
321 
322             // Is it a supported and enabled extension?
323             if (!shc.sslConfig.isAvailable(SSLExtension.CH_KEY_SHARE)) {
324                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
325                     SSLLogger.fine(
326                             &quot;Ignore unavailable key_share extension&quot;);
327                 }
328                 return;     // ignore the extension
329             }
330 
331             // Parse the extension
332             CHKeyShareSpec spec = new CHKeyShareSpec(shc, buffer);
333             List&lt;SSLCredentials&gt; credentials = new LinkedList&lt;&gt;();
334             for (KeyShareEntry entry : spec.clientShares) {
335                 NamedGroup ng = NamedGroup.valueOf(entry.namedGroupId);
336                 if (ng == null || !SupportedGroups.isActivatable(
337                         shc.sslConfig.algorithmConstraints, ng)) {
338                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
339                         SSLLogger.fine(
340                                 &quot;Ignore unsupported named group: &quot; +
341                                 NamedGroup.nameOf(entry.namedGroupId));
342                     }
343                     continue;
344                 }
345 
346                 try {
347                     SSLCredentials kaCred =
348                         ng.decodeCredentials(entry.keyExchange,
349                         shc.algorithmConstraints,
350                         s -&gt; SSLLogger.warning(s));
351                     if (kaCred != null) {
352                         credentials.add(kaCred);
353                     }
354                 } catch (GeneralSecurityException ex) {
355                     SSLLogger.warning(
356                         &quot;Cannot decode named group: &quot; +
357                         NamedGroup.nameOf(entry.namedGroupId));
358                 }
359             }
360 
361             if (!credentials.isEmpty()) {
362                 shc.handshakeCredentials.addAll(credentials);
363             } else {
364                 // New handshake credentials are required from the client side.
365                 shc.handshakeProducers.put(
366                         SSLHandshake.HELLO_RETRY_REQUEST.id,
367                         SSLHandshake.HELLO_RETRY_REQUEST);
368             }
369 
370             // update the context
371             shc.handshakeExtensions.put(SSLExtension.CH_KEY_SHARE, spec);
372         }
373     }
374 
375     /**
376      * The key share entry used in ServerHello &quot;key_share&quot; extensions.
377      */
378     static final class SHKeyShareSpec implements SSLExtensionSpec {
379         final KeyShareEntry serverShare;
380 
381         SHKeyShareSpec(KeyShareEntry serverShare) {
382             this.serverShare = serverShare;
383         }
384 
385         private SHKeyShareSpec(HandshakeContext handshakeContext,
386                 ByteBuffer buffer) throws IOException {
387             // struct {
388             //      KeyShareEntry server_share;
389             // } KeyShareServerHello;
390             if (buffer.remaining() &lt; 5) {       // 5: minimal server_share
391                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
392                         new SSLProtocolException(
393                     &quot;Invalid key_share extension: &quot; +
394                     &quot;insufficient data (length=&quot; + buffer.remaining() + &quot;)&quot;));
395             }
396 
397             int namedGroupId = Record.getInt16(buffer);
398             byte[] keyExchange = Record.getBytes16(buffer);
399 
400             if (buffer.hasRemaining()) {
401                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
402                         new SSLProtocolException(
403                     &quot;Invalid key_share extension: unknown extra data&quot;));
404             }
405 
406             this.serverShare = new KeyShareEntry(namedGroupId, keyExchange);
407         }
408 
409         @Override
410         public String toString() {
411             MessageFormat messageFormat = new MessageFormat(
412                 &quot;\&quot;server_share\&quot;: &#39;{&#39;\n&quot; +
413                 &quot;  \&quot;named group\&quot;: {0}\n&quot; +
414                 &quot;  \&quot;key_exchange\&quot;: &#39;{&#39;\n&quot; +
415                 &quot;{1}\n&quot; +
416                 &quot;  &#39;}&#39;\n&quot; +
417                 &quot;&#39;}&#39;,&quot;, Locale.ENGLISH);
418 
419             HexDumpEncoder hexEncoder = new HexDumpEncoder();
420             Object[] messageFields = {
421                 NamedGroup.nameOf(serverShare.namedGroupId),
422                 Utilities.indent(
423                         hexEncoder.encode(serverShare.keyExchange), &quot;    &quot;)
424             };
425 
426             return messageFormat.format(messageFields);
427         }
428     }
429 
430     private static final class SHKeyShareStringizer implements SSLStringizer {
431         @Override
432         public String toString(HandshakeContext handshakeContext,
433                 ByteBuffer buffer) {
434             try {
435                 return (new SHKeyShareSpec(handshakeContext, buffer)).toString();
436             } catch (IOException ioe) {
437                 // For debug logging only, so please swallow exceptions.
438                 return ioe.getMessage();
439             }
440         }
441     }
442 
443     /**
444      * Network data producer of the extension in a ServerHello
445      * handshake message.
446      */
447     private static final class SHKeyShareProducer implements HandshakeProducer {
448         // Prevent instantiation of this class.
449         private SHKeyShareProducer() {
450             // blank
451         }
452 
453         @Override
454         public byte[] produce(ConnectionContext context,
455                 HandshakeMessage message) throws IOException {
456             // The producing happens in client side only.
457             ServerHandshakeContext shc = (ServerHandshakeContext)context;
458 
459             // In response to key_share request only
460             CHKeyShareSpec kss =
461                     (CHKeyShareSpec)shc.handshakeExtensions.get(
462                             SSLExtension.CH_KEY_SHARE);
463             if (kss == null) {
464                 // Unlikely, no key_share extension requested.
465                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
466                     SSLLogger.warning(
467                             &quot;Ignore, no client key_share extension&quot;);
468                 }
469                 return null;
470             }
471 
472             // Is it a supported and enabled extension?
473             if (!shc.sslConfig.isAvailable(SSLExtension.SH_KEY_SHARE)) {
474                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
475                     SSLLogger.warning(
476                             &quot;Ignore, no available server key_share extension&quot;);
477                 }
478                 return null;
479             }
480 
481             // use requested key share entries
482             if ((shc.handshakeCredentials == null) ||
483                     shc.handshakeCredentials.isEmpty()) {
484                 // Unlikely, HelloRetryRequest should be used ealier.
485                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
486                     SSLLogger.warning(
487                             &quot;No available client key share entries&quot;);
488                 }
489                 return null;
490             }
491 
492             KeyShareEntry keyShare = null;
493             for (SSLCredentials cd : shc.handshakeCredentials) {
494                 NamedGroup ng = null;
495                 if (cd instanceof NamedGroupCredentials) {
496                     NamedGroupCredentials creds = (NamedGroupCredentials)cd;
497                     ng = creds.getNamedGroup();
498                 }
499 
500                 if (ng == null) {
501                     continue;
502                 }
503 
504                 SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
505                 if (ke == null) {
506                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
507                         SSLLogger.warning(
508                             &quot;No key exchange for named group &quot; + ng.name);
509                     }
510                     continue;
511                 }
512 
513                 SSLPossession[] poses = ke.createPossessions(shc);
514                 for (SSLPossession pos : poses) {
515                     if (!(pos instanceof NamedGroupPossession)) {
516                         // May need more possesion types in the future.
517                         continue;
518                     }
519 
520                     // update the context
521                     shc.handshakeKeyExchange = ke;
522                     shc.handshakePossessions.add(pos);
523                     keyShare = new KeyShareEntry(ng.id, pos.encode());
524                     break;
525                 }
526 
527                 if (keyShare != null) {
528                     for (Map.Entry&lt;Byte, HandshakeProducer&gt; me :
529                             ke.getHandshakeProducers(shc)) {
530                         shc.handshakeProducers.put(
531                                 me.getKey(), me.getValue());
532                     }
533 
534                     // We have got one! Don&#39;t forget to break.
535                     break;
536                 }
537             }
538 
539             if (keyShare == null) {
540                 // Unlikely, HelloRetryRequest should be used instead ealier.
541                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
542                     SSLLogger.warning(
543                             &quot;No available server key_share extension&quot;);
544                 }
545                 return null;
546             }
547 
548             byte[] extData = keyShare.getEncoded();
549 
550             // update the context
551             SHKeyShareSpec spec = new SHKeyShareSpec(keyShare);
552             shc.handshakeExtensions.put(SSLExtension.SH_KEY_SHARE, spec);
553 
554             return extData;
555         }
556     }
557 
558     /**
559      * Network data consumer of the extension in a ServerHello
560      * handshake message.
561      */
562     private static final class SHKeyShareConsumer implements ExtensionConsumer {
563         // Prevent instantiation of this class.
564         private SHKeyShareConsumer() {
565             // blank
566         }
567 
568         @Override
569         public void consume(ConnectionContext context,
570             HandshakeMessage message, ByteBuffer buffer) throws IOException {
571             // Happens in client side only.
572             ClientHandshakeContext chc = (ClientHandshakeContext)context;
573             if (chc.clientRequestedNamedGroups == null ||
574                     chc.clientRequestedNamedGroups.isEmpty()) {
575                 // No supported groups.
576                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
577                         &quot;Unexpected key_share extension in ServerHello&quot;);
578             }
579 
580             // Is it a supported and enabled extension?
581             if (!chc.sslConfig.isAvailable(SSLExtension.SH_KEY_SHARE)) {
582                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
583                         &quot;Unsupported key_share extension in ServerHello&quot;);
584             }
585 
586             // Parse the extension
587             SHKeyShareSpec spec = new SHKeyShareSpec(chc, buffer);
588             KeyShareEntry keyShare = spec.serverShare;
589             NamedGroup ng = NamedGroup.valueOf(keyShare.namedGroupId);
590             if (ng == null || !SupportedGroups.isActivatable(
591                     chc.sslConfig.algorithmConstraints, ng)) {
592                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
593                         &quot;Unsupported named group: &quot; +
594                         NamedGroup.nameOf(keyShare.namedGroupId));
595             }
596 
597             SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
598             if (ke == null) {
599                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
600                         &quot;No key exchange for named group &quot; + ng.name);
601             }
602 
603             SSLCredentials credentials = null;
604             try {
605                 SSLCredentials kaCred = ng.decodeCredentials(
606                     keyShare.keyExchange, chc.algorithmConstraints,
607                     s -&gt; chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, s));
608                 if (kaCred != null) {
609                     credentials = kaCred;
610                 }
611             } catch (GeneralSecurityException ex) {
612                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
613                         &quot;Cannot decode named group: &quot; +
614                         NamedGroup.nameOf(keyShare.namedGroupId));
615             }
616 
617             if (credentials == null) {
618                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
619                         &quot;Unsupported named group: &quot; + ng.name);
620             }
621 
622             // update the context
623             chc.handshakeKeyExchange = ke;
624             chc.handshakeCredentials.add(credentials);
625             chc.handshakeExtensions.put(SSLExtension.SH_KEY_SHARE, spec);
626         }
627     }
628 
629     /**
630      * The absence processing if the extension is not present in
631      * the ServerHello handshake message.
632      */
633     private static final class SHKeyShareAbsence implements HandshakeAbsence {
634         @Override
635         public void absent(ConnectionContext context,
636                 HandshakeMessage message) throws IOException {
637             // The producing happens in client side only.
638             ClientHandshakeContext chc = (ClientHandshakeContext)context;
639 
640             // Cannot use the previous requested key shares any more.
641             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
642                 SSLLogger.fine(
643                         &quot;No key_share extension in ServerHello, &quot; +
644                         &quot;cleanup the key shares if necessary&quot;);
645             }
646             chc.handshakePossessions.clear();
647         }
648     }
649 
650     /**
651      * The key share entry used in HelloRetryRequest &quot;key_share&quot; extensions.
652      */
653     static final class HRRKeyShareSpec implements SSLExtensionSpec {
654         final int selectedGroup;
655 
656         HRRKeyShareSpec(NamedGroup serverGroup) {
657             this.selectedGroup = serverGroup.id;
658         }
659 
660         private HRRKeyShareSpec(HandshakeContext handshakeContext,
661                 ByteBuffer buffer) throws IOException {
662             // struct {
663             //     NamedGroup selected_group;
664             // } KeyShareHelloRetryRequest;
665             if (buffer.remaining() != 2) {
666                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
667                         new SSLProtocolException(
668                     &quot;Invalid key_share extension: &quot; +
669                     &quot;improper data (length=&quot; + buffer.remaining() + &quot;)&quot;));
670             }
671 
672             this.selectedGroup = Record.getInt16(buffer);
673         }
674 
675         @Override
676         public String toString() {
677             MessageFormat messageFormat = new MessageFormat(
678                 &quot;\&quot;selected group\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
679 
680             Object[] messageFields = {
681                     NamedGroup.nameOf(selectedGroup)
682                 };
683             return messageFormat.format(messageFields);
684         }
685     }
686 
687     private static final class HRRKeyShareStringizer implements SSLStringizer {
688         @Override
689         public String toString(HandshakeContext handshakeContext,
690                 ByteBuffer buffer) {
691             try {
692                 return (new HRRKeyShareSpec(handshakeContext, buffer)).toString();
693             } catch (IOException ioe) {
694                 // For debug logging only, so please swallow exceptions.
695                 return ioe.getMessage();
696             }
697         }
698     }
699 
700     /**
701      * Network data producer of the extension in a HelloRetryRequest
702      * handshake message.
703      */
704     private static final
705             class HRRKeyShareProducer implements HandshakeProducer {
706         // Prevent instantiation of this class.
707         private HRRKeyShareProducer() {
708             // blank
709         }
710 
711         @Override
712         public byte[] produce(ConnectionContext context,
713                 HandshakeMessage message) throws IOException {
714             // The producing happens in server side only.
715             ServerHandshakeContext shc = (ServerHandshakeContext) context;
716 
717             // Is it a supported and enabled extension?
718             if (!shc.sslConfig.isAvailable(SSLExtension.HRR_KEY_SHARE)) {
719                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
720                         &quot;Unsupported key_share extension in HelloRetryRequest&quot;);
721             }
722 
723             if (shc.clientRequestedNamedGroups == null ||
724                     shc.clientRequestedNamedGroups.isEmpty()) {
725                 // No supported groups.
726                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
727                         &quot;Unexpected key_share extension in HelloRetryRequest&quot;);
728             }
729 
730             NamedGroup selectedGroup = null;
731             for (NamedGroup ng : shc.clientRequestedNamedGroups) {
732                 if (SupportedGroups.isActivatable(
733                         shc.sslConfig.algorithmConstraints, ng)) {
734                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
735                         SSLLogger.fine(
736                                 &quot;HelloRetryRequest selected named group: &quot; +
737                                 ng.name);
738                     }
739 
740                     selectedGroup = ng;
741                     break;
742                 }
743             }
744 
745             if (selectedGroup == null) {
746                 throw shc.conContext.fatal(
747                         Alert.UNEXPECTED_MESSAGE, &quot;No common named group&quot;);
748             }
749 
750             byte[] extdata = new byte[] {
751                     (byte)((selectedGroup.id &gt;&gt; 8) &amp; 0xFF),
752                     (byte)(selectedGroup.id &amp; 0xFF)
753                 };
754 
755             // update the context
756             shc.serverSelectedNamedGroup = selectedGroup;
757             shc.handshakeExtensions.put(SSLExtension.HRR_KEY_SHARE,
758                     new HRRKeyShareSpec(selectedGroup));
759 
760             return extdata;
761         }
762     }
763 
764     /**
765      * Network data producer of the extension for stateless
766      * HelloRetryRequest reconstruction.
767      */
768     private static final
769             class HRRKeyShareReproducer implements HandshakeProducer {
770         // Prevent instantiation of this class.
771         private HRRKeyShareReproducer() {
772             // blank
773         }
774 
775         @Override
776         public byte[] produce(ConnectionContext context,
777                 HandshakeMessage message) throws IOException {
778             // The producing happens in server side only.
779             ServerHandshakeContext shc = (ServerHandshakeContext) context;
780 
781             // Is it a supported and enabled extension?
782             if (!shc.sslConfig.isAvailable(SSLExtension.HRR_KEY_SHARE)) {
783                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
784                         &quot;Unsupported key_share extension in HelloRetryRequest&quot;);
785             }
786 
787             CHKeyShareSpec spec = (CHKeyShareSpec)shc.handshakeExtensions.get(
788                     SSLExtension.CH_KEY_SHARE);
789             if (spec != null &amp;&amp; spec.clientShares != null &amp;&amp;
790                     spec.clientShares.size() == 1) {
791                 int namedGroupId = spec.clientShares.get(0).namedGroupId;
792 
793                 byte[] extdata = new byte[] {
794                         (byte)((namedGroupId &gt;&gt; 8) &amp; 0xFF),
795                         (byte)(namedGroupId &amp; 0xFF)
796                     };
797 
798                 return extdata;
799             }
800 
801             return null;
802         }
803     }
804 
805     /**
806      * Network data consumer of the extension in a HelloRetryRequest
807      * handshake message.
808      */
809     private static final
810             class HRRKeyShareConsumer implements ExtensionConsumer {
811         // Prevent instantiation of this class.
812         private HRRKeyShareConsumer() {
813             // blank
814         }
815 
816         @Override
817         public void consume(ConnectionContext context,
818             HandshakeMessage message, ByteBuffer buffer) throws IOException {
819             // The producing happens in client side only.
820             ClientHandshakeContext chc = (ClientHandshakeContext)context;
821 
822             // Is it a supported and enabled extension?
823             if (!chc.sslConfig.isAvailable(SSLExtension.HRR_KEY_SHARE)) {
824                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
825                         &quot;Unsupported key_share extension in HelloRetryRequest&quot;);
826             }
827 
828             if (chc.clientRequestedNamedGroups == null ||
829                     chc.clientRequestedNamedGroups.isEmpty()) {
830                 // No supported groups.
831                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
832                         &quot;Unexpected key_share extension in HelloRetryRequest&quot;);
833             }
834 
835             // Parse the extension
836             HRRKeyShareSpec spec = new HRRKeyShareSpec(chc, buffer);
837             NamedGroup serverGroup = NamedGroup.valueOf(spec.selectedGroup);
838             if (serverGroup == null) {
839                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
840                         &quot;Unsupported HelloRetryRequest selected group: &quot; +
841                                 NamedGroup.nameOf(spec.selectedGroup));
842             }
843 
844             if (!chc.clientRequestedNamedGroups.contains(serverGroup)) {
845                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
846                         &quot;Unexpected HelloRetryRequest selected group: &quot; +
847                                 serverGroup.name);
848             }
849 
850             // update the context
851 
852             // When sending the new ClientHello, the client MUST replace the
853             // original &quot;key_share&quot; extension with one containing only a new
854             // KeyShareEntry for the group indicated in the selected_group
855             // field of the triggering HelloRetryRequest.
856             //
857             chc.serverSelectedNamedGroup = serverGroup;
858             chc.handshakeExtensions.put(SSLExtension.HRR_KEY_SHARE, spec);
859         }
860     }
861 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/CertStatusExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.io.ByteArrayInputStream;
  30 import java.nio.ByteBuffer;
  31 import java.security.cert.Extension;
  32 import java.security.cert.CertificateFactory;
  33 import java.security.cert.CertificateException;
  34 import java.security.cert.X509Certificate;
  35 import java.text.MessageFormat;
  36 import java.util.ArrayList;
  37 import java.util.List;
  38 import java.util.Locale;
  39 import javax.net.ssl.SSLProtocolException;
  40 import sun.security.provider.certpath.OCSPResponse;
  41 import sun.security.provider.certpath.ResponderId;
  42 import sun.security.ssl.SSLExtension.ExtensionConsumer;
  43 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
  44 import sun.security.ssl.SSLHandshake.HandshakeMessage;
  45 import sun.security.util.DerInputStream;
  46 import sun.security.util.DerValue;
  47 import sun.security.util.HexDumpEncoder;
  48 
  49 /**
  50  * Pack of &quot;status_request&quot; and &quot;status_request_v2&quot; extensions.
  51  */
  52 final class CertStatusExtension {
  53     static final HandshakeProducer chNetworkProducer =
  54             new CHCertStatusReqProducer();
  55     static final ExtensionConsumer chOnLoadConsumer =
  56             new CHCertStatusReqConsumer();
  57 
  58     static final HandshakeProducer shNetworkProducer =
  59             new SHCertStatusReqProducer();
  60     static final ExtensionConsumer shOnLoadConsumer =
  61             new SHCertStatusReqConsumer();
  62 
  63     static final HandshakeProducer ctNetworkProducer =
  64             new CTCertStatusResponseProducer();
  65     static final ExtensionConsumer ctOnLoadConsumer =
  66             new CTCertStatusResponseConsumer();
  67 
  68     static final SSLStringizer certStatusReqStringizer =
  69             new CertStatusRequestStringizer();
  70 
  71     static final HandshakeProducer chV2NetworkProducer =
  72             new CHCertStatusReqV2Producer();
  73     static final ExtensionConsumer chV2OnLoadConsumer =
  74             new CHCertStatusReqV2Consumer();
  75 
  76     static final HandshakeProducer shV2NetworkProducer =
  77             new SHCertStatusReqV2Producer();
  78     static final ExtensionConsumer shV2OnLoadConsumer =
  79             new SHCertStatusReqV2Consumer();
  80 
  81     static final SSLStringizer certStatusReqV2Stringizer =
  82             new CertStatusRequestsStringizer();
  83 
  84     static final SSLStringizer certStatusRespStringizer =
  85             new CertStatusRespStringizer();
  86 
  87     /**
  88      * The &quot;status_request&quot; extension.
  89      *
  90      * RFC6066 defines the TLS extension,&quot;status_request&quot; (type 0x5),
  91      * which allows the client to request that the server perform OCSP
  92      * on the client&#39;s behalf.
  93      *
  94      * The &quot;extension data&quot; field of this extension contains a
  95      * &quot;CertificateStatusRequest&quot; structure:
  96      *
  97      *      struct {
  98      *          CertificateStatusType status_type;
  99      *          select (status_type) {
 100      *              case ocsp: OCSPStatusRequest;
 101      *          } request;
 102      *      } CertificateStatusRequest;
 103      *
 104      *      enum { ocsp(1), (255) } CertificateStatusType;
 105      *
 106      *      struct {
 107      *          ResponderID responder_id_list&lt;0..2^16-1&gt;;
 108      *          Extensions  request_extensions;
 109      *      } OCSPStatusRequest;
 110      *
 111      *      opaque ResponderID&lt;1..2^16-1&gt;;
 112      *      opaque Extensions&lt;0..2^16-1&gt;;
 113      */
 114     static final class CertStatusRequestSpec implements SSLExtensionSpec {
 115         static final CertStatusRequestSpec DEFAULT =
 116                 new CertStatusRequestSpec(OCSPStatusRequest.EMPTY_OCSP);
 117 
 118         final CertStatusRequest statusRequest;
 119 
 120         private CertStatusRequestSpec(CertStatusRequest statusRequest) {
 121             this.statusRequest = statusRequest;
 122         }
 123 
 124         private CertStatusRequestSpec(HandshakeContext hc,
 125                 ByteBuffer buffer) throws IOException {
 126             // Is it a empty extension_data?
 127             if (buffer.remaining() == 0) {
 128                 // server response
 129                 this.statusRequest = null;
 130                 return;
 131             }
 132 
 133             if (buffer.remaining() &lt; 1) {
 134                 throw hc.conContext.fatal(Alert.DECODE_ERROR,
 135                         new SSLProtocolException(
 136                     &quot;Invalid status_request extension: insufficient data&quot;));
 137             }
 138 
 139             byte statusType = (byte)Record.getInt8(buffer);
 140             byte[] encoded = new byte[buffer.remaining()];
 141             if (encoded.length != 0) {
 142                 buffer.get(encoded);
 143             }
 144             if (statusType == CertStatusRequestType.OCSP.id) {
 145                 this.statusRequest = new OCSPStatusRequest(statusType, encoded);
 146             } else {
 147                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 148                     SSLLogger.info(
 149                         &quot;Unknown certificate status request &quot; +
 150                         &quot;(status type: &quot; + statusType + &quot;)&quot;);
 151                 }
 152 
 153                 this.statusRequest = new CertStatusRequest(statusType, encoded);
 154             }
 155         }
 156 
 157         @Override
 158         public String toString() {
 159             return statusRequest == null ?
 160                         &quot;&lt;empty&gt;&quot; : statusRequest.toString();
 161         }
 162     }
 163 
 164     /**
 165      * Defines the CertificateStatus response structure as outlined in
 166      * RFC 6066.  This will contain a status response type, plus a single,
 167      * non-empty OCSP response in DER-encoded form.
 168      *
 169      * struct {
 170      *     CertificateStatusType status_type;
 171      *     select (status_type) {
 172      *         case ocsp: OCSPResponse;
 173      *     } response;
 174      * } CertificateStatus;
 175      */
 176     static final class CertStatusResponseSpec implements SSLExtensionSpec {
 177         final CertStatusResponse statusResponse;
 178 
 179         private CertStatusResponseSpec(CertStatusResponse resp) {
 180             this.statusResponse = resp;
 181         }
 182 
 183         private CertStatusResponseSpec(HandshakeContext hc,
 184                 ByteBuffer buffer) throws IOException {
 185             if (buffer.remaining() &lt; 2) {
 186                 throw hc.conContext.fatal(Alert.DECODE_ERROR,
 187                         new SSLProtocolException(
 188                     &quot;Invalid status_request extension: insufficient data&quot;));
 189             }
 190 
 191             // Get the status type (1 byte) and response data (vector)
 192             byte type = (byte)Record.getInt8(buffer);
 193             byte[] respData = Record.getBytes24(buffer);
 194 
 195             // Create the CertStatusResponse based on the type
 196             if (type == CertStatusRequestType.OCSP.id) {
 197                 this.statusResponse = new OCSPStatusResponse(type, respData);
 198             } else {
 199                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 200                     SSLLogger.info(
 201                         &quot;Unknown certificate status response &quot; +
 202                         &quot;(status type: &quot; + type + &quot;)&quot;);
 203                 }
 204 
 205                 this.statusResponse = new CertStatusResponse(type, respData);
 206             }
 207         }
 208 
 209         @Override
 210         public String toString() {
 211             return statusResponse == null ?
 212                         &quot;&lt;empty&gt;&quot; : statusResponse.toString();
 213         }
 214     }
 215 
 216     private static final
 217             class CertStatusRequestStringizer implements SSLStringizer {
 218         @Override
 219         public String toString(HandshakeContext hc, ByteBuffer buffer) {
 220             try {
 221                 return (new CertStatusRequestSpec(hc, buffer)).toString();
 222             } catch (IOException ioe) {
 223                 // For debug logging only, so please swallow exceptions.
 224                 return ioe.getMessage();
 225             }
 226         }
 227     }
 228 
 229     private static final
 230             class CertStatusRespStringizer implements SSLStringizer {
 231         @Override
 232         public String toString(HandshakeContext hc, ByteBuffer buffer) {
 233             try {
 234                 return (new CertStatusResponseSpec(hc, buffer)).toString();
 235             } catch (IOException ioe) {
 236                  // For debug logging only, so please swallow exceptions.
 237                 return ioe.getMessage();
 238             }
 239         }
 240     }
 241 
 242     static enum CertStatusRequestType {
 243         OCSP        ((byte)0x01,    &quot;ocsp&quot;),        // RFC 6066/6961
 244         OCSP_MULTI  ((byte)0x02,    &quot;ocsp_multi&quot;);  // RFC 6961
 245 
 246         final byte id;
 247         final String name;
 248 
 249         private CertStatusRequestType(byte id, String name) {
 250             this.id = id;
 251             this.name = name;
 252         }
 253 
 254         /**
 255          * Returns the enum constant of the specified id (see RFC 6066).
 256          */
 257         static CertStatusRequestType valueOf(byte id) {
 258             for (CertStatusRequestType srt : CertStatusRequestType.values()) {
 259                 if (srt.id == id) {
 260                     return srt;
 261                 }
 262             }
 263 
 264             return null;
 265         }
 266 
 267         static String nameOf(byte id) {
 268             for (CertStatusRequestType srt : CertStatusRequestType.values()) {
 269                 if (srt.id == id) {
 270                     return srt.name;
 271                 }
 272             }
 273 
 274             return &quot;UNDEFINED-CERT-STATUS-TYPE(&quot; + id + &quot;)&quot;;
 275         }
 276     }
 277 
 278     static class CertStatusRequest {
 279         final byte statusType;
 280         final byte[] encodedRequest;
 281 
 282         protected CertStatusRequest(byte statusType, byte[] encodedRequest) {
 283             this.statusType = statusType;
 284             this.encodedRequest = encodedRequest;
 285         }
 286 
 287         @Override
 288         public String toString() {
 289             MessageFormat messageFormat = new MessageFormat(
 290                 &quot;\&quot;certificate status type\&quot;: {0}\n&quot; +
 291                 &quot;\&quot;encoded certificate status\&quot;: &#39;{&#39;\n&quot; +
 292                 &quot;{1}\n&quot; +
 293                 &quot;&#39;}&#39;&quot;,
 294                 Locale.ENGLISH);
 295 
 296             HexDumpEncoder hexEncoder = new HexDumpEncoder();
 297             String encoded = hexEncoder.encodeBuffer(encodedRequest);
 298 
 299             Object[] messageFields = {
 300                 CertStatusRequestType.nameOf(statusType),
 301                 Utilities.indent(encoded)
 302             };
 303 
 304             return messageFormat.format(messageFields);
 305         }
 306     }
 307 
 308     /*
 309      * RFC6066 defines the TLS extension,&quot;status_request&quot; (type 0x5),
 310      * which allows the client to request that the server perform OCSP
 311      * on the client&#39;s behalf.
 312      *
 313      * The RFC defines an OCSPStatusRequest structure:
 314      *
 315      *      struct {
 316      *          ResponderID responder_id_list&lt;0..2^16-1&gt;;
 317      *          Extensions  request_extensions;
 318      *      } OCSPStatusRequest;
 319      */
 320     static final class OCSPStatusRequest extends CertStatusRequest {
 321         static final OCSPStatusRequest EMPTY_OCSP;
 322         static final OCSPStatusRequest EMPTY_OCSP_MULTI;
 323 
 324         final List&lt;ResponderId&gt; responderIds;
 325         final List&lt;Extension&gt; extensions;
 326         private final int ridListLen;
 327         private final int extListLen;
 328 
 329         static {
 330             OCSPStatusRequest ocspReq = null;
 331             OCSPStatusRequest multiReq = null;
 332 
 333             try {
 334                 ocspReq = new OCSPStatusRequest(
 335                         CertStatusRequestType.OCSP.id,
 336                         new byte[] {0x00, 0x00, 0x00, 0x00});
 337                 multiReq = new OCSPStatusRequest(
 338                     CertStatusRequestType.OCSP_MULTI.id,
 339                     new byte[] {0x00, 0x00, 0x00, 0x00});
 340             } catch (IOException ioe) {
 341                 // unlikely
 342             }
 343 
 344             EMPTY_OCSP = ocspReq;
 345             EMPTY_OCSP_MULTI = multiReq;
 346         }
 347 
 348         private OCSPStatusRequest(byte statusType,
 349                 byte[] encoded) throws IOException {
 350             super(statusType, encoded);
 351 
 352             if (encoded == null || encoded.length &lt; 4) {
 353                                         //  2: length of responder_id_list
 354                                         // +2: length of request_extensions
 355                 throw new SSLProtocolException(
 356                         &quot;Invalid OCSP status request: insufficient data&quot;);
 357             }
 358 
 359             List&lt;ResponderId&gt; rids = new ArrayList&lt;&gt;();
 360             List&lt;Extension&gt; exts = new ArrayList&lt;&gt;();
 361             ByteBuffer m = ByteBuffer.wrap(encoded);
 362 
 363             this.ridListLen = Record.getInt16(m);
 364             if (m.remaining() &lt; (ridListLen + 2)) {
 365                 throw new SSLProtocolException(
 366                         &quot;Invalid OCSP status request: insufficient data&quot;);
 367             }
 368 
 369             int ridListBytesRemaining = ridListLen;
 370             while (ridListBytesRemaining &gt;= 2) {    // 2: length of responder_id
 371                 byte[] ridBytes = Record.getBytes16(m);
 372                 try {
 373                     rids.add(new ResponderId(ridBytes));
 374                 } catch (IOException ioe) {
 375                     throw new SSLProtocolException(
 376                         &quot;Invalid OCSP status request: invalid responder ID&quot;);
 377                 }
 378                 ridListBytesRemaining -= ridBytes.length + 2;
 379             }
 380 
 381             if (ridListBytesRemaining != 0) {
 382                     throw new SSLProtocolException(
 383                         &quot;Invalid OCSP status request: incomplete data&quot;);
 384             }
 385 
 386             byte[] extListBytes = Record.getBytes16(m);
 387             this.extListLen = extListBytes.length;
 388             if (extListLen &gt; 0) {
 389                 try {
 390                     DerInputStream dis = new DerInputStream(extListBytes);
 391                     DerValue[] extSeqContents =
 392                             dis.getSequence(extListBytes.length);
 393                     for (DerValue extDerVal : extSeqContents) {
 394                         exts.add(new sun.security.x509.Extension(extDerVal));
 395                     }
 396                 } catch (IOException ioe) {
 397                     throw new SSLProtocolException(
 398                         &quot;Invalid OCSP status request: invalid extension&quot;);
 399                 }
 400             }
 401 
 402             this.responderIds = rids;
 403             this.extensions = exts;
 404         }
 405 
 406         @Override
 407         public String toString() {
 408             MessageFormat messageFormat = new MessageFormat(
 409                 &quot;\&quot;certificate status type\&quot;: {0}\n&quot; +
 410                 &quot;\&quot;OCSP status request\&quot;: &#39;{&#39;\n&quot; +
 411                 &quot;{1}\n&quot; +
 412                 &quot;&#39;}&#39;&quot;,
 413                 Locale.ENGLISH);
 414 
 415             MessageFormat requestFormat = new MessageFormat(
 416                 &quot;\&quot;responder_id\&quot;: {0}\n&quot; +
 417                 &quot;\&quot;request extensions\&quot;: &#39;{&#39;\n&quot; +
 418                 &quot;{1}\n&quot; +
 419                 &quot;&#39;}&#39;&quot;,
 420                 Locale.ENGLISH);
 421 
 422             String ridStr = &quot;&lt;empty&gt;&quot;;
 423             if (!responderIds.isEmpty()) {
 424                 ridStr = responderIds.toString();
 425             }
 426 
 427             String extsStr = &quot;&lt;empty&gt;&quot;;
 428             if (!extensions.isEmpty()) {
 429                 StringBuilder extBuilder = new StringBuilder(512);
 430                 boolean isFirst = true;
 431                 for (Extension ext : this.extensions) {
 432                     if (isFirst) {
 433                         isFirst = false;
 434                     } else {
 435                         extBuilder.append(&quot;,\n&quot;);
 436                     }
 437                     extBuilder.append(&quot;{\n&quot;).
 438                             append(Utilities.indent(ext.toString())).
 439                             append(&quot;}&quot;);
 440                 }
 441 
 442                 extsStr = extBuilder.toString();
 443             }
 444 
 445             Object[] requestFields = {
 446                     ridStr,
 447                     Utilities.indent(extsStr)
 448                 };
 449             String ocspStatusRequest = requestFormat.format(requestFields);
 450 
 451             Object[] messageFields = {
 452                     CertStatusRequestType.nameOf(statusType),
 453                     Utilities.indent(ocspStatusRequest)
 454                 };
 455 
 456             return messageFormat.format(messageFields);
 457         }
 458     }
 459 
 460     static class CertStatusResponse {
 461         final byte statusType;
 462         final byte[] encodedResponse;
 463 
 464         protected CertStatusResponse(byte statusType, byte[] respDer) {
 465             this.statusType = statusType;
 466             this.encodedResponse = respDer;
 467         }
 468 
 469         byte[] toByteArray() throws IOException {
 470             // Create a byte array large enough to handle the status_type
 471             // field (1) + OCSP length (3) + OCSP data (variable)
 472             byte[] outData = new byte[encodedResponse.length + 4];
 473             ByteBuffer buf = ByteBuffer.wrap(outData);
 474             Record.putInt8(buf, statusType);
 475             Record.putBytes24(buf, encodedResponse);
 476             return buf.array();
 477         }
 478 
 479         @Override
 480         public String toString() {
 481             MessageFormat messageFormat = new MessageFormat(
 482                 &quot;\&quot;certificate status response type\&quot;: {0}\n&quot; +
 483                 &quot;\&quot;encoded certificate status\&quot;: &#39;{&#39;\n&quot; +
 484                 &quot;{1}\n&quot; +
 485                 &quot;&#39;}&#39;&quot;,
 486                 Locale.ENGLISH);
 487 
 488             HexDumpEncoder hexEncoder = new HexDumpEncoder();
 489             String encoded = hexEncoder.encodeBuffer(encodedResponse);
 490 
 491             Object[] messageFields = {
 492                 CertStatusRequestType.nameOf(statusType),
 493                 Utilities.indent(encoded)
 494             };
 495 
 496             return messageFormat.format(messageFields);
 497         }
 498     }
 499 
 500     static final class OCSPStatusResponse extends CertStatusResponse {
 501         final OCSPResponse ocspResponse;
 502 
 503         private OCSPStatusResponse(byte statusType,
 504                 byte[] encoded) throws IOException {
 505             super(statusType, encoded);
 506 
 507             // The DER-encoded OCSP response must not be zero length
 508             if (encoded == null || encoded.length &lt; 1) {
 509                 throw new SSLProtocolException(
 510                         &quot;Invalid OCSP status response: insufficient data&quot;);
 511             }
 512 
 513             // Otherwise, make an OCSPResponse object from the data
 514             ocspResponse = new OCSPResponse(encoded);
 515         }
 516 
 517         @Override
 518         public String toString() {
 519             MessageFormat messageFormat = new MessageFormat(
 520                 &quot;\&quot;certificate status response type\&quot;: {0}\n&quot; +
 521                 &quot;\&quot;OCSP status response\&quot;: &#39;{&#39;\n&quot; +
 522                 &quot;{1}\n&quot; +
 523                 &quot;&#39;}&#39;&quot;,
 524                 Locale.ENGLISH);
 525 
 526             Object[] messageFields = {
 527                 CertStatusRequestType.nameOf(statusType),
 528                 Utilities.indent(ocspResponse.toString())
 529             };
 530 
 531             return messageFormat.format(messageFields);
 532         }
 533     }
 534 
 535     /**
 536      * Network data producer of a &quot;status_request&quot; extension in the
 537      * ClientHello handshake message.
 538      */
 539     private static final
 540             class CHCertStatusReqProducer implements HandshakeProducer {
 541         // Prevent instantiation of this class.
 542         private CHCertStatusReqProducer() {
 543             // blank
 544         }
 545 
 546         @Override
 547         public byte[] produce(ConnectionContext context,
 548                 HandshakeMessage message) throws IOException {
 549             // The producing happens in client side only.
 550             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 551 
 552             if (!chc.sslContext.isStaplingEnabled(true)) {
 553                 return null;
 554             }
 555 
 556             if (!chc.sslConfig.isAvailable(SSLExtension.CH_STATUS_REQUEST)) {
 557                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 558                     SSLLogger.fine(
 559                         &quot;Ignore unavailable extension: &quot; +
 560                         SSLExtension.CH_STATUS_REQUEST.name);
 561                 }
 562                 return null;
 563             }
 564 
 565             // Produce the extension.
 566             //
 567             // We are using empty OCSPStatusRequest at present. May extend to
 568             // support specific responder or extensions later.
 569             byte[] extData = new byte[] {0x01, 0x00, 0x00, 0x00, 0x00};
 570 
 571             // Update the context.
 572             chc.handshakeExtensions.put(SSLExtension.CH_STATUS_REQUEST,
 573                     CertStatusRequestSpec.DEFAULT);
 574 
 575             return extData;
 576         }
 577     }
 578 
 579     /**
 580      * Network data consumer of a &quot;status_request&quot; extension in the
 581      * ClientHello handshake message.
 582      */
 583     private static final
 584             class CHCertStatusReqConsumer implements ExtensionConsumer {
 585         // Prevent instantiation of this class.
 586         private CHCertStatusReqConsumer() {
 587             // blank
 588         }
 589 
 590         @Override
 591         public void consume(ConnectionContext context,
 592             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 593 
 594             // The consuming happens in server side only.
 595             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 596 
 597             if (!shc.sslConfig.isAvailable(SSLExtension.CH_STATUS_REQUEST)) {
 598                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 599                     SSLLogger.fine(&quot;Ignore unavailable extension: &quot; +
 600                         SSLExtension.CH_STATUS_REQUEST.name);
 601                 }
 602                 return;     // ignore the extension
 603             }
 604 
 605             // Parse the extension.
 606             CertStatusRequestSpec spec = new CertStatusRequestSpec(shc, buffer);
 607 
 608             // Update the context.
 609             shc.handshakeExtensions.put(SSLExtension.CH_STATUS_REQUEST, spec);
 610             if (!shc.isResumption &amp;&amp;
 611                     !shc.negotiatedProtocol.useTLS13PlusSpec()) {
 612                 shc.handshakeProducers.put(SSLHandshake.CERTIFICATE_STATUS.id,
 613                     SSLHandshake.CERTIFICATE_STATUS);
 614             }   // Otherwise, the certificate status presents in server cert.
 615 
 616             // No impact on session resumption.
 617         }
 618     }
 619 
 620     /**
 621      * Network data producer of a &quot;status_request&quot; extension in the
 622      * ServerHello handshake message.
 623      */
 624     private static final
 625             class SHCertStatusReqProducer implements HandshakeProducer {
 626         // Prevent instantiation of this class.
 627         private SHCertStatusReqProducer() {
 628             // blank
 629         }
 630 
 631         @Override
 632         public byte[] produce(ConnectionContext context,
 633                 HandshakeMessage message) throws IOException {
 634             // The producing happens in client side only.
 635             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 636 
 637             // The StaplingParameters in the ServerHandshakeContext will
 638             // contain the info about what kind of stapling (if any) to
 639             // perform and whether this status_request extension should be
 640             // produced or the status_request_v2 (found in a different producer)
 641             // No explicit check is required for isStaplingEnabled here.  If
 642             // it is false then stapleParams will be null.  If it is true
 643             // then stapleParams may or may not be false and the check below
 644             // is sufficient.
 645             if ((shc.stapleParams == null) ||
 646                     (shc.stapleParams.statusRespExt !=
 647                     SSLExtension.CH_STATUS_REQUEST)) {
 648                 return null;    // Do not produce status_request in ServerHello
 649             }
 650 
 651             // In response to &quot;status_request&quot; extension request only.
 652             CertStatusRequestSpec spec = (CertStatusRequestSpec)
 653                     shc.handshakeExtensions.get(SSLExtension.CH_STATUS_REQUEST);
 654             if (spec == null) {
 655                 // Ignore, no status_request extension requested.
 656                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 657                     SSLLogger.finest(&quot;Ignore unavailable extension: &quot; +
 658                         SSLExtension.CH_STATUS_REQUEST.name);
 659                 }
 660 
 661                 return null;        // ignore the extension
 662             }
 663 
 664             // Is it a session resuming?
 665             if (shc.isResumption) {
 666                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 667                     SSLLogger.finest(
 668                         &quot;No status_request response for session resuming&quot;);
 669                 }
 670 
 671                 return null;        // ignore the extension
 672             }
 673 
 674             // The &quot;extension_data&quot; in the extended ServerHello handshake
 675             // message MUST be empty.
 676             byte[] extData = new byte[0];
 677 
 678             // Update the context.
 679             shc.handshakeExtensions.put(SSLExtension.SH_STATUS_REQUEST,
 680                     CertStatusRequestSpec.DEFAULT);
 681 
 682             return extData;
 683         }
 684     }
 685 
 686     /**
 687      * Network data consumer of a &quot;status_request&quot; extension in the
 688      * ServerHello handshake message.
 689      */
 690     private static final
 691             class SHCertStatusReqConsumer implements ExtensionConsumer {
 692         // Prevent instantiation of this class.
 693         private SHCertStatusReqConsumer() {
 694             // blank
 695         }
 696 
 697         @Override
 698         public void consume(ConnectionContext context,
 699             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 700 
 701             // The producing happens in client side only.
 702             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 703 
 704             // In response to &quot;status_request&quot; extension request only.
 705             CertStatusRequestSpec requestedCsr = (CertStatusRequestSpec)
 706                     chc.handshakeExtensions.get(SSLExtension.CH_STATUS_REQUEST);
 707             if (requestedCsr == null) {
 708                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 709                     &quot;Unexpected status_request extension in ServerHello&quot;);
 710             }
 711 
 712             // Parse the extension.
 713             if (buffer.hasRemaining()) {
 714                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 715                   &quot;Invalid status_request extension in ServerHello message: &quot; +
 716                   &quot;the extension data must be empty&quot;);
 717             }
 718 
 719             // Update the context.
 720             chc.handshakeExtensions.put(SSLExtension.SH_STATUS_REQUEST,
 721                     CertStatusRequestSpec.DEFAULT);
 722 
 723             // Since we&#39;ve received a legitimate status_request in the
 724             // ServerHello, stapling is active if it&#39;s been enabled.
 725             chc.staplingActive = chc.sslContext.isStaplingEnabled(true);
 726             if (chc.staplingActive) {
 727                 chc.handshakeConsumers.put(SSLHandshake.CERTIFICATE_STATUS.id,
 728                     SSLHandshake.CERTIFICATE_STATUS);
 729             }
 730 
 731             // No impact on session resumption.
 732         }
 733     }
 734 
 735     /**
 736      * The &quot;status_request_v2&quot; extension.
 737      *
 738      * RFC6961 defines the TLS extension,&quot;status_request_v2&quot; (type 0x5),
 739      * which allows the client to request that the server perform OCSP
 740      * on the client&#39;s behalf.
 741      *
 742      * The RFC defines an CertStatusReqItemV2 structure:
 743      *
 744      *      struct {
 745      *          CertificateStatusType status_type;
 746      *          uint16 request_length;
 747      *          select (status_type) {
 748      *              case ocsp: OCSPStatusRequest;
 749      *              case ocsp_multi: OCSPStatusRequest;
 750      *          } request;
 751      *      } CertificateStatusRequestItemV2;
 752      *
 753      *      enum { ocsp(1), ocsp_multi(2), (255) } CertificateStatusType;
 754      *      struct {
 755      *        ResponderID responder_id_list&lt;0..2^16-1&gt;;
 756      *        Extensions request_extensions;
 757      *      } OCSPStatusRequest;
 758      *
 759      *      opaque ResponderID&lt;1..2^16-1&gt;;
 760      *      opaque Extensions&lt;0..2^16-1&gt;;
 761      *
 762      *      struct {
 763      *        CertificateStatusRequestItemV2
 764      *                         certificate_status_req_list&lt;1..2^16-1&gt;;
 765      *      } CertificateStatusRequestListV2;
 766      */
 767     static final class CertStatusRequestV2Spec implements SSLExtensionSpec {
 768         static final CertStatusRequestV2Spec DEFAULT =
 769                 new CertStatusRequestV2Spec(new CertStatusRequest[] {
 770                         OCSPStatusRequest.EMPTY_OCSP_MULTI});
 771 
 772         final CertStatusRequest[] certStatusRequests;
 773 
 774         private CertStatusRequestV2Spec(CertStatusRequest[] certStatusRequests) {
 775             this.certStatusRequests = certStatusRequests;
 776         }
 777 
 778         private CertStatusRequestV2Spec(HandshakeContext hc,
 779                 ByteBuffer message) throws IOException {
 780             // Is it a empty extension_data?
 781             if (message.remaining() == 0) {
 782                 // server response
 783                 this.certStatusRequests = new CertStatusRequest[0];
 784                 return;
 785             }
 786 
 787             if (message.remaining() &lt; 5) {  //  2: certificate_status_req_list
 788                                             // +1: status_type
 789                                             // +2: request_length
 790                 throw hc.conContext.fatal(Alert.DECODE_ERROR,
 791                         new SSLProtocolException(
 792                     &quot;Invalid status_request_v2 extension: insufficient data&quot;));
 793             }
 794 
 795             int listLen = Record.getInt16(message);
 796             if (listLen &lt;= 0) {
 797                 throw hc.conContext.fatal(Alert.DECODE_ERROR,
 798                         new SSLProtocolException(
 799                     &quot;certificate_status_req_list length must be positive &quot; +
 800                     &quot;(received length: &quot; + listLen + &quot;)&quot;));
 801             }
 802 
 803             int remaining = listLen;
 804             List&lt;CertStatusRequest&gt; statusRequests = new ArrayList&lt;&gt;();
 805             while (remaining &gt; 0) {
 806                 byte statusType = (byte)Record.getInt8(message);
 807                 int requestLen = Record.getInt16(message);
 808 
 809                 if (message.remaining() &lt; requestLen) {
 810                         throw hc.conContext.fatal(
 811                                 Alert.DECODE_ERROR,
 812                                 new SSLProtocolException(
 813                             &quot;Invalid status_request_v2 extension: &quot; +
 814                             &quot;insufficient data (request_length=&quot; + requestLen +
 815                             &quot;, remining=&quot; + message.remaining() + &quot;)&quot;));
 816                 }
 817 
 818                 byte[] encoded = new byte[requestLen];
 819                 if (encoded.length != 0) {
 820                     message.get(encoded);
 821                 }
 822                 remaining -= 3;     // 1(status type) + 2(request_length) bytes
 823                 remaining -= requestLen;
 824 
 825                 if (statusType == CertStatusRequestType.OCSP.id ||
 826                         statusType == CertStatusRequestType.OCSP_MULTI.id) {
 827                     if (encoded.length &lt; 4) {
 828                                         //  2: length of responder_id_list
 829                                         // +2: length of request_extensions
 830                         throw hc.conContext.fatal(
 831                                 Alert.DECODE_ERROR,
 832                                 new SSLProtocolException(
 833                             &quot;Invalid status_request_v2 extension: &quot; +
 834                             &quot;insufficient data&quot;));
 835                     }
 836                     statusRequests.add(
 837                             new OCSPStatusRequest(statusType, encoded));
 838                 } else {
 839                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 840                         SSLLogger.info(
 841                                 &quot;Unknown certificate status request &quot; +
 842                                 &quot;(status type: &quot; + statusType + &quot;)&quot;);
 843                     }
 844                     statusRequests.add(
 845                             new CertStatusRequest(statusType, encoded));
 846                 }
 847             }
 848 
 849             certStatusRequests =
 850                     statusRequests.toArray(new CertStatusRequest[0]);
 851         }
 852 
 853         @Override
 854         public String toString() {
 855             if (certStatusRequests == null || certStatusRequests.length == 0) {
 856                 return &quot;&lt;empty&gt;&quot;;
 857             } else {
 858                 MessageFormat messageFormat = new MessageFormat(
 859                     &quot;\&quot;cert status request\&quot;: &#39;{&#39;\n{0}\n&#39;}&#39;&quot;, Locale.ENGLISH);
 860 
 861                 StringBuilder builder = new StringBuilder(512);
 862                 boolean isFirst = true;
 863                 for (CertStatusRequest csr : certStatusRequests) {
 864                     if (isFirst) {
 865                         isFirst = false;
 866                     } else {
 867                         builder.append(&quot;, &quot;);
 868                     }
 869                     Object[] messageFields = {
 870                             Utilities.indent(csr.toString())
 871                         };
 872                     builder.append(messageFormat.format(messageFields));
 873                 }
 874 
 875                 return builder.toString();
 876             }
 877         }
 878     }
 879 
 880     private static final
 881             class CertStatusRequestsStringizer implements SSLStringizer {
 882         @Override
 883         public String toString(HandshakeContext hc, ByteBuffer buffer) {
 884             try {
 885                 return (new CertStatusRequestV2Spec(hc, buffer)).toString();
 886             } catch (IOException ioe) {
 887                 // For debug logging only, so please swallow exceptions.
 888                 return ioe.getMessage();
 889             }
 890         }
 891     }
 892 
 893     /**
 894      * Network data producer of a &quot;status_request_v2&quot; extension in the
 895      * ClientHello handshake message.
 896      */
 897     private static final
 898             class CHCertStatusReqV2Producer implements HandshakeProducer {
 899         // Prevent instantiation of this class.
 900         private CHCertStatusReqV2Producer() {
 901             // blank
 902         }
 903 
 904         @Override
 905         public byte[] produce(ConnectionContext context,
 906                 HandshakeMessage message) throws IOException {
 907             // The producing happens in client side only.
 908             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 909 
 910             if (!chc.sslContext.isStaplingEnabled(true)) {
 911                 return null;
 912             }
 913 
 914             if (!chc.sslConfig.isAvailable(SSLExtension.CH_STATUS_REQUEST_V2)) {
 915                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 916                     SSLLogger.finest(
 917                         &quot;Ignore unavailable status_request_v2 extension&quot;);
 918                 }
 919 
 920                 return null;
 921             }
 922 
 923             // Produce the extension.
 924             //
 925             // We are using empty OCSPStatusRequest at present. May extend to
 926             // support specific responder or extensions later.
 927             byte[] extData = new byte[] {
 928                 0x00, 0x07, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00};
 929 
 930             // Update the context.
 931             chc.handshakeExtensions.put(SSLExtension.CH_STATUS_REQUEST_V2,
 932                     CertStatusRequestV2Spec.DEFAULT);
 933 
 934             return extData;
 935         }
 936     }
 937 
 938     /**
 939      * Network data consumer of a &quot;status_request_v2&quot; extension in the
 940      * ClientHello handshake message.
 941      */
 942     private static final
 943             class CHCertStatusReqV2Consumer implements ExtensionConsumer {
 944         // Prevent instantiation of this class.
 945         private CHCertStatusReqV2Consumer() {
 946             // blank
 947         }
 948 
 949         @Override
 950         public void consume(ConnectionContext context,
 951             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 952 
 953             // The consuming happens in server side only.
 954             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 955 
 956             if (!shc.sslConfig.isAvailable(SSLExtension.CH_STATUS_REQUEST_V2)) {
 957                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 958                     SSLLogger.finest(
 959                         &quot;Ignore unavailable status_request_v2 extension&quot;);
 960                 }
 961 
 962                 return;     // ignore the extension
 963             }
 964 
 965             // Parse the extension.
 966             CertStatusRequestV2Spec spec = new CertStatusRequestV2Spec(shc, buffer);
 967 
 968             // Update the context.
 969             shc.handshakeExtensions.put(SSLExtension.CH_STATUS_REQUEST_V2,
 970                     spec);
 971             if (!shc.isResumption) {
 972                 shc.handshakeProducers.putIfAbsent(
 973                         SSLHandshake.CERTIFICATE_STATUS.id,
 974                         SSLHandshake.CERTIFICATE_STATUS);
 975             }
 976 
 977             // No impact on session resumption.
 978         }
 979     }
 980 
 981     /**
 982      * Network data producer of a &quot;status_request_v2&quot; extension in the
 983      * ServerHello handshake message.
 984      */
 985     private static final
 986             class SHCertStatusReqV2Producer implements HandshakeProducer {
 987         // Prevent instantiation of this class.
 988         private SHCertStatusReqV2Producer() {
 989             // blank
 990         }
 991 
 992         @Override
 993         public byte[] produce(ConnectionContext context,
 994                 HandshakeMessage message) throws IOException {
 995             // The producing happens in client side only.
 996 
 997             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 998             // The StaplingParameters in the ServerHandshakeContext will
 999             // contain the info about what kind of stapling (if any) to
1000             // perform and whether this status_request extension should be
1001             // produced or the status_request_v2 (found in a different producer)
1002             // No explicit check is required for isStaplingEnabled here.  If
1003             // it is false then stapleParams will be null.  If it is true
1004             // then stapleParams may or may not be false and the check below
1005             // is sufficient.
1006             if ((shc.stapleParams == null) ||
1007                     (shc.stapleParams.statusRespExt !=
1008                     SSLExtension.CH_STATUS_REQUEST_V2)) {
1009                 return null;    // Do not produce status_request_v2 in SH
1010             }
1011 
1012             // In response to &quot;status_request_v2&quot; extension request only
1013             CertStatusRequestV2Spec spec = (CertStatusRequestV2Spec)
1014                 shc.handshakeExtensions.get(SSLExtension.CH_STATUS_REQUEST_V2);
1015             if (spec == null) {
1016                 // Ignore, no status_request_v2 extension requested.
1017                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1018                     SSLLogger.finest(
1019                         &quot;Ignore unavailable status_request_v2 extension&quot;);
1020                 }
1021 
1022                 return null;        // ignore the extension
1023             }
1024 
1025             // Is it a session resuming?
1026             if (shc.isResumption) {
1027                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1028                     SSLLogger.finest(
1029                         &quot;No status_request_v2 response for session resumption&quot;);
1030                 }
1031                 return null;        // ignore the extension
1032             }
1033 
1034             // The &quot;extension_data&quot; in the extended ServerHello handshake
1035             // message MUST be empty.
1036             byte[] extData = new byte[0];
1037 
1038             // Update the context.
1039             shc.handshakeExtensions.put(SSLExtension.SH_STATUS_REQUEST_V2,
1040                     CertStatusRequestV2Spec.DEFAULT);
1041 
1042             return extData;
1043         }
1044     }
1045 
1046     /**
1047      * Network data consumer of a &quot;status_request_v2&quot; extension in the
1048      * ServerHello handshake message.
1049      */
1050     private static final
1051             class SHCertStatusReqV2Consumer implements ExtensionConsumer {
1052         // Prevent instantiation of this class.
1053         private SHCertStatusReqV2Consumer() {
1054             // blank
1055         }
1056 
1057         @Override
1058         public void consume(ConnectionContext context,
1059             HandshakeMessage message, ByteBuffer buffer) throws IOException {
1060 
1061             // The consumption happens in client side only.
1062             ClientHandshakeContext chc = (ClientHandshakeContext)context;
1063 
1064             // In response to &quot;status_request&quot; extension request only
1065             CertStatusRequestV2Spec requestedCsr = (CertStatusRequestV2Spec)
1066                 chc.handshakeExtensions.get(SSLExtension.CH_STATUS_REQUEST_V2);
1067             if (requestedCsr == null) {
1068                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
1069                     &quot;Unexpected status_request_v2 extension in ServerHello&quot;);
1070             }
1071 
1072             // Parse the extension.
1073             if (buffer.hasRemaining()) {
1074                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
1075                   &quot;Invalid status_request_v2 extension in ServerHello: &quot; +
1076                   &quot;the extension data must be empty&quot;);
1077             }
1078 
1079             // Update the context.
1080             chc.handshakeExtensions.put(SSLExtension.SH_STATUS_REQUEST_V2,
1081                     CertStatusRequestV2Spec.DEFAULT);
1082 
1083             // Since we&#39;ve received a legitimate status_request in the
1084             // ServerHello, stapling is active if it&#39;s been enabled.  If it
1085             // is active, make sure we add the CertificateStatus message
1086             // consumer.
1087             chc.staplingActive = chc.sslContext.isStaplingEnabled(true);
1088             if (chc.staplingActive) {
1089                 chc.handshakeConsumers.put(SSLHandshake.CERTIFICATE_STATUS.id,
1090                     SSLHandshake.CERTIFICATE_STATUS);
1091             }
1092 
1093             // No impact on session resumption.
1094         }
1095     }
1096 
1097     private static final
1098             class CTCertStatusResponseProducer implements HandshakeProducer {
1099         // Prevent instantiation of this class.
1100         private CTCertStatusResponseProducer() {
1101             // blank
1102         }
1103 
1104         @Override
1105         public byte[] produce(ConnectionContext context,
1106                 HandshakeMessage message) throws IOException {
1107             ServerHandshakeContext shc = (ServerHandshakeContext)context;
1108             byte[] producedData = null;
1109 
1110             // Stapling needs to be active and have valid data to proceed
1111             if (shc.stapleParams == null) {
1112                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1113                     SSLLogger.finest(
1114                         &quot;Stapling is disabled for this connection&quot;);
1115                 }
1116                 return null;
1117             }
1118 
1119             // There needs to be a non-null CertificateEntry to proceed
1120             if (shc.currentCertEntry == null) {
1121                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1122                     SSLLogger.finest(&quot;Found null CertificateEntry in context&quot;);
1123                 }
1124                 return null;
1125             }
1126 
1127             // Pull the certificate from the CertificateEntry and find
1128             // a response from the response map.  If one exists we will
1129             // staple it.
1130             try {
1131                 CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);
1132                 X509Certificate x509Cert =
1133                         (X509Certificate)cf.generateCertificate(
1134                                 new ByteArrayInputStream(
1135                                         shc.currentCertEntry.encoded));
1136                 byte[] respBytes = shc.stapleParams.responseMap.get(x509Cert);
1137                 if (respBytes == null) {
1138                     // We&#39;re done with this entry.  Clear it from the context
1139                     if (SSLLogger.isOn &amp;&amp;
1140                             SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
1141                         SSLLogger.finest(&quot;No status response found for &quot; +
1142                                 x509Cert.getSubjectX500Principal());
1143                     }
1144                     shc.currentCertEntry = null;
1145                     return null;
1146                 }
1147 
1148                 // Build a proper response buffer from the stapling information
1149                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
1150                     SSLLogger.finest(&quot;Found status response for &quot; +
1151                             x509Cert.getSubjectX500Principal() +
1152                             &quot;, response length: &quot; + respBytes.length);
1153                 }
1154                 CertStatusResponse certResp = (shc.stapleParams.statReqType ==
1155                         CertStatusRequestType.OCSP) ?
1156                         new OCSPStatusResponse(shc.stapleParams.statReqType.id,
1157                                 respBytes) :
1158                         new CertStatusResponse(shc.stapleParams.statReqType.id,
1159                                 respBytes);
1160                 producedData = certResp.toByteArray();
1161             } catch (CertificateException ce) {
1162                 throw shc.conContext.fatal(Alert.BAD_CERTIFICATE,
1163                         &quot;Failed to parse server certificates&quot;, ce);
1164             } catch (IOException ioe) {
1165                 throw shc.conContext.fatal(Alert.BAD_CERT_STATUS_RESPONSE,
1166                         &quot;Failed to parse certificate status response&quot;, ioe);
1167             }
1168 
1169             // Clear the pinned CertificateEntry from the context
1170             shc.currentCertEntry = null;
1171             return producedData;
1172         }
1173     }
1174 
1175     private static final
1176         class CTCertStatusResponseConsumer implements ExtensionConsumer {
1177         // Prevent instantiation of this class.
1178         private CTCertStatusResponseConsumer() {
1179             // blank
1180         }
1181 
1182         @Override
1183         public void consume(ConnectionContext context,
1184                 HandshakeMessage message, ByteBuffer buffer) throws IOException {
1185             // The consumption happens in client side only.
1186             ClientHandshakeContext chc = (ClientHandshakeContext)context;
1187 
1188             // Parse the extension.
1189             CertStatusResponseSpec spec = new CertStatusResponseSpec(chc, buffer);
1190 
1191             if (chc.sslContext.isStaplingEnabled(true)) {
1192                 // Activate stapling
1193                 chc.staplingActive = true;
1194             } else {
1195                 // Do no further processing of stapled responses
1196                 return;
1197             }
1198 
1199             // Get response list from the session.  This is unmodifiable
1200             // so we need to create a new list.  Then add this new response
1201             // to the end and submit it back to the session object.
1202             if ((chc.handshakeSession != null) &amp;&amp; (!chc.isResumption)) {
1203                 List&lt;byte[]&gt; respList = new ArrayList&lt;&gt;(
1204                         chc.handshakeSession.getStatusResponses());
1205                 respList.add(spec.statusResponse.encodedResponse);
1206                 chc.handshakeSession.setStatusResponses(respList);
1207             } else {
1208                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
1209                     SSLLogger.finest(
1210                             &quot;Ignoring stapled data on resumed session&quot;);
1211                 }
1212             }
1213         }
1214     }
1215 }
    </pre>
  </body>
</html>
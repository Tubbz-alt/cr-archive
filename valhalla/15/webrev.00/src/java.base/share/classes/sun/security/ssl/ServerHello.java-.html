<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/sun/security/ssl/ServerHello.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.security.AlgorithmConstraints;
  31 import java.security.CryptoPrimitive;
  32 import java.security.GeneralSecurityException;
  33 import java.text.MessageFormat;
  34 import java.util.Arrays;
  35 import java.util.EnumSet;
  36 import java.util.LinkedList;
  37 import java.util.List;
  38 import java.util.Locale;
  39 import java.util.Map;
  40 import javax.crypto.SecretKey;
  41 import javax.crypto.spec.IvParameterSpec;
  42 import javax.net.ssl.SSLException;
  43 import javax.net.ssl.SSLHandshakeException;
  44 import javax.net.ssl.SSLProtocolException;
  45 import sun.security.ssl.CipherSuite.KeyExchange;
  46 import sun.security.ssl.ClientHello.ClientHelloMessage;
  47 import sun.security.ssl.SSLCipher.SSLReadCipher;
  48 import sun.security.ssl.SSLCipher.SSLWriteCipher;
  49 import sun.security.ssl.SSLHandshake.HandshakeMessage;
  50 import sun.security.ssl.SupportedVersionsExtension.SHSupportedVersionsSpec;
  51 
  52 import static sun.security.ssl.SSLExtension.SH_SESSION_TICKET;
  53 
  54 /**
  55  * Pack of the ServerHello/HelloRetryRequest handshake message.
  56  */
  57 final class ServerHello {
  58     static final SSLConsumer handshakeConsumer =
  59         new ServerHelloConsumer();
  60     static final HandshakeProducer t12HandshakeProducer =
  61         new T12ServerHelloProducer();
  62     static final HandshakeProducer t13HandshakeProducer =
  63         new T13ServerHelloProducer();
  64     static final HandshakeProducer hrrHandshakeProducer =
  65         new T13HelloRetryRequestProducer();
  66 
  67     static final HandshakeProducer hrrReproducer =
  68         new T13HelloRetryRequestReproducer();
  69 
  70     private static final HandshakeConsumer t12HandshakeConsumer =
  71         new T12ServerHelloConsumer();
  72     private static final HandshakeConsumer t13HandshakeConsumer =
  73         new T13ServerHelloConsumer();
  74 
  75     private static final HandshakeConsumer d12HandshakeConsumer =
  76         new T12ServerHelloConsumer();
  77     private static final HandshakeConsumer d13HandshakeConsumer =
  78         new T13ServerHelloConsumer();
  79 
  80     private static final HandshakeConsumer t13HrrHandshakeConsumer =
  81         new T13HelloRetryRequestConsumer();
  82     private static final HandshakeConsumer d13HrrHandshakeConsumer =
  83         new T13HelloRetryRequestConsumer();
  84 
  85     /**
  86      * The ServerHello handshake message.
  87      */
  88     static final class ServerHelloMessage extends HandshakeMessage {
  89         final ProtocolVersion           serverVersion;      // TLS 1.3 legacy
  90         final RandomCookie              serverRandom;
  91         final SessionId                 sessionId;          // TLS 1.3 legacy
  92         final CipherSuite               cipherSuite;
  93         final byte                      compressionMethod;  // TLS 1.3 legacy
  94         final SSLExtensions             extensions;
  95 
  96         // The HelloRetryRequest producer needs to use the ClientHello message
  97         // for cookie generation.  Please don&#39;t use this field for other
  98         // purpose unless it is really necessary.
  99         final ClientHelloMessage        clientHello;
 100 
 101         // Reserved for HelloRetryRequest consumer.  Please don&#39;t use this
 102         // field for other purpose unless it is really necessary.
 103         final ByteBuffer                handshakeRecord;
 104 
 105         ServerHelloMessage(HandshakeContext context,
 106                 ProtocolVersion serverVersion, SessionId sessionId,
 107                 CipherSuite cipherSuite, RandomCookie serverRandom,
 108                 ClientHelloMessage clientHello) {
 109             super(context);
 110 
 111             this.serverVersion = serverVersion;
 112             this.serverRandom = serverRandom;
 113             this.sessionId = sessionId;
 114             this.cipherSuite = cipherSuite;
 115             this.compressionMethod = 0x00;      // Don&#39;t support compression.
 116             this.extensions = new SSLExtensions(this);
 117 
 118             // Reserve the ClientHello message for cookie generation.
 119             this.clientHello = clientHello;
 120 
 121             // The handshakeRecord field is used for HelloRetryRequest consumer
 122             // only.  It&#39;s fine to set it to null for generating side of the
 123             // ServerHello/HelloRetryRequest message.
 124             this.handshakeRecord = null;
 125         }
 126 
 127         ServerHelloMessage(HandshakeContext context,
 128                 ByteBuffer m) throws IOException {
 129             super(context);
 130 
 131             // Reserve for HelloRetryRequest consumer if needed.
 132             this.handshakeRecord = m.duplicate();
 133 
 134             byte major = m.get();
 135             byte minor = m.get();
 136             this.serverVersion = ProtocolVersion.valueOf(major, minor);
 137             if (this.serverVersion == null) {
 138                 // The client should only request for known protocol versions.
 139                 throw context.conContext.fatal(Alert.PROTOCOL_VERSION,
 140                     &quot;Unsupported protocol version: &quot; +
 141                     ProtocolVersion.nameOf(major, minor));
 142             }
 143 
 144             this.serverRandom = new RandomCookie(m);
 145             this.sessionId = new SessionId(Record.getBytes8(m));
 146             try {
 147                 sessionId.checkLength(serverVersion.id);
 148             } catch (SSLProtocolException ex) {
 149                 throw handshakeContext.conContext.fatal(
 150                         Alert.ILLEGAL_PARAMETER, ex);
 151             }
 152 
 153             int cipherSuiteId = Record.getInt16(m);
 154             this.cipherSuite = CipherSuite.valueOf(cipherSuiteId);
 155             if (cipherSuite == null || !context.isNegotiable(cipherSuite)) {
 156                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 157                     &quot;Server selected improper ciphersuite &quot; +
 158                     CipherSuite.nameOf(cipherSuiteId));
 159             }
 160 
 161             this.compressionMethod = m.get();
 162             if (compressionMethod != 0) {
 163                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 164                     &quot;compression type not supported, &quot; + compressionMethod);
 165             }
 166 
 167             SSLExtension[] supportedExtensions;
 168             if (serverRandom.isHelloRetryRequest()) {
 169                 supportedExtensions = context.sslConfig.getEnabledExtensions(
 170                             SSLHandshake.HELLO_RETRY_REQUEST);
 171             } else {
 172                 supportedExtensions = context.sslConfig.getEnabledExtensions(
 173                             SSLHandshake.SERVER_HELLO);
 174             }
 175 
 176             if (m.hasRemaining()) {
 177                 this.extensions =
 178                     new SSLExtensions(this, m, supportedExtensions);
 179             } else {
 180                 this.extensions = new SSLExtensions(this);
 181             }
 182 
 183             // The clientHello field is used for HelloRetryRequest producer
 184             // only.  It&#39;s fine to set it to null for receiving side of
 185             // ServerHello/HelloRetryRequest message.
 186             this.clientHello = null;        // not used, let it be null;
 187         }
 188 
 189         @Override
 190         public SSLHandshake handshakeType() {
 191             return serverRandom.isHelloRetryRequest() ?
 192                 SSLHandshake.HELLO_RETRY_REQUEST : SSLHandshake.SERVER_HELLO;
 193         }
 194 
 195         @Override
 196         public int messageLength() {
 197             // almost fixed header size, except session ID and extensions:
 198             //      major + minor = 2
 199             //      random = 32
 200             //      session ID len field = 1
 201             //      cipher suite = 2
 202             //      compression = 1
 203             //      extensions: if present, 2 + length of extensions
 204             // In TLS 1.3, use of certain extensions is mandatory.
 205             return 38 + sessionId.length() + extensions.length();
 206         }
 207 
 208         @Override
 209         public void send(HandshakeOutStream hos) throws IOException {
 210             hos.putInt8(serverVersion.major);
 211             hos.putInt8(serverVersion.minor);
 212             hos.write(serverRandom.randomBytes);
 213             hos.putBytes8(sessionId.getId());
 214             hos.putInt8((cipherSuite.id &gt;&gt; 8) &amp; 0xFF);
 215             hos.putInt8(cipherSuite.id &amp; 0xff);
 216             hos.putInt8(compressionMethod);
 217 
 218             extensions.send(hos);           // In TLS 1.3, use of certain
 219                                             // extensions is mandatory.
 220         }
 221 
 222         @Override
 223         public String toString() {
 224             MessageFormat messageFormat = new MessageFormat(
 225                 &quot;\&quot;{0}\&quot;: &#39;{&#39;\n&quot; +
 226                 &quot;  \&quot;server version\&quot;      : \&quot;{1}\&quot;,\n&quot; +
 227                 &quot;  \&quot;random\&quot;              : \&quot;{2}\&quot;,\n&quot; +
 228                 &quot;  \&quot;session id\&quot;          : \&quot;{3}\&quot;,\n&quot; +
 229                 &quot;  \&quot;cipher suite\&quot;        : \&quot;{4}\&quot;,\n&quot; +
 230                 &quot;  \&quot;compression methods\&quot; : \&quot;{5}\&quot;,\n&quot; +
 231                 &quot;  \&quot;extensions\&quot;          : [\n&quot; +
 232                 &quot;{6}\n&quot; +
 233                 &quot;  ]\n&quot; +
 234                 &quot;&#39;}&#39;&quot;,
 235                 Locale.ENGLISH);
 236             Object[] messageFields = {
 237                 serverRandom.isHelloRetryRequest() ?
 238                     &quot;HelloRetryRequest&quot; : &quot;ServerHello&quot;,
 239                 serverVersion.name,
 240                 Utilities.toHexString(serverRandom.randomBytes),
 241                 sessionId.toString(),
 242                 cipherSuite.name + &quot;(&quot; +
 243                         Utilities.byte16HexString(cipherSuite.id) + &quot;)&quot;,
 244                 Utilities.toHexString(compressionMethod),
 245                 Utilities.indent(extensions.toString(), &quot;    &quot;)
 246             };
 247 
 248             return messageFormat.format(messageFields);
 249         }
 250     }
 251 
 252     /**
 253      * The &quot;ServerHello&quot; handshake message producer.
 254      */
 255     private static final class T12ServerHelloProducer
 256             implements HandshakeProducer {
 257 
 258         // Prevent instantiation of this class.
 259         private T12ServerHelloProducer() {
 260             // blank
 261         }
 262 
 263         @Override
 264         public byte[] produce(ConnectionContext context,
 265                 HandshakeMessage message) throws IOException {
 266             // The producing happens in server side only.
 267             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 268             ClientHelloMessage clientHello = (ClientHelloMessage)message;
 269 
 270             // If client hasn&#39;t specified a session we can resume, start a
 271             // new one and choose its cipher suite and compression options,
 272             // unless new session creation is disabled for this connection!
 273             if (!shc.isResumption || shc.resumingSession == null) {
 274                 if (!shc.sslConfig.enableSessionCreation) {
 275                     throw new SSLException(
 276                         &quot;Not resumption, and no new session is allowed&quot;);
 277                 }
 278 
 279                 if (shc.localSupportedSignAlgs == null) {
 280                     shc.localSupportedSignAlgs =
 281                         SignatureScheme.getSupportedAlgorithms(
 282                                 shc.algorithmConstraints, shc.activeProtocols);
 283                 }
 284 
 285                 SSLSessionImpl session =
 286                         new SSLSessionImpl(shc, CipherSuite.C_NULL);
 287                 session.setMaximumPacketSize(shc.sslConfig.maximumPacketSize);
 288                 shc.handshakeSession = session;
 289 
 290                 // consider the handshake extension impact
 291                 SSLExtension[] enabledExtensions =
 292                         shc.sslConfig.getEnabledExtensions(
 293                             SSLHandshake.CLIENT_HELLO, shc.negotiatedProtocol);
 294                 clientHello.extensions.consumeOnTrade(shc, enabledExtensions);
 295 
 296                 // negotiate the cipher suite.
 297                 KeyExchangeProperties credentials =
 298                         chooseCipherSuite(shc, clientHello);
 299                 if (credentials == null) {
 300                     throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 301                             &quot;no cipher suites in common&quot;);
 302                 }
 303                 shc.negotiatedCipherSuite = credentials.cipherSuite;
 304                 shc.handshakeKeyExchange = credentials.keyExchange;
 305                 shc.handshakeSession.setSuite(credentials.cipherSuite);
 306                 shc.handshakePossessions.addAll(
 307                         Arrays.asList(credentials.possessions));
 308                 shc.handshakeHash.determine(
 309                         shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 310 
 311                 // Check the incoming OCSP stapling extensions and attempt
 312                 // to get responses.  If the resulting stapleParams is non
 313                 // null, it implies that stapling is enabled on the server side.
 314                 shc.stapleParams = StatusResponseManager.processStapling(shc);
 315                 shc.staplingActive = (shc.stapleParams != null);
 316 
 317                 // update the responders
 318                 SSLKeyExchange ke = credentials.keyExchange;
 319                 if (ke != null) {
 320                     for (Map.Entry&lt;Byte, HandshakeProducer&gt; me :
 321                             ke.getHandshakeProducers(shc)) {
 322                         shc.handshakeProducers.put(
 323                                 me.getKey(), me.getValue());
 324                     }
 325                 }
 326 
 327                 if ((ke != null) &amp;&amp;
 328                         (shc.sslConfig.clientAuthType !=
 329                                 ClientAuthType.CLIENT_AUTH_NONE) &amp;&amp;
 330                         !shc.negotiatedCipherSuite.isAnonymous()) {
 331                     for (SSLHandshake hs :
 332                             ke.getRelatedHandshakers(shc)) {
 333                         if (hs == SSLHandshake.CERTIFICATE) {
 334                             shc.handshakeProducers.put(
 335                                     SSLHandshake.CERTIFICATE_REQUEST.id,
 336                                     SSLHandshake.CERTIFICATE_REQUEST);
 337                             break;
 338                         }
 339                     }
 340                 }
 341                 shc.handshakeProducers.put(SSLHandshake.SERVER_HELLO_DONE.id,
 342                         SSLHandshake.SERVER_HELLO_DONE);
 343             } else {
 344                 // stateless and use the client session id (RFC 5077 3.4)
 345                 if (shc.statelessResumption) {
 346                     shc.resumingSession = new SSLSessionImpl(shc.resumingSession,
 347                             (clientHello.sessionId.length() == 0) ?
 348                                     new SessionId(true,
 349                                             shc.sslContext.getSecureRandom()) :
 350                                     new SessionId(clientHello.sessionId.getId())
 351                     );
 352                 }
 353                 shc.handshakeSession = shc.resumingSession;
 354                 shc.negotiatedProtocol =
 355                         shc.resumingSession.getProtocolVersion();
 356                 shc.negotiatedCipherSuite = shc.resumingSession.getSuite();
 357                 shc.handshakeHash.determine(
 358                         shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 359             }
 360 
 361             // Generate the ServerHello handshake message.
 362             ServerHelloMessage shm = new ServerHelloMessage(shc,
 363                     shc.negotiatedProtocol,
 364                     shc.handshakeSession.getSessionId(),
 365                     shc.negotiatedCipherSuite,
 366                     new RandomCookie(shc),
 367                     clientHello);
 368             shc.serverHelloRandom = shm.serverRandom;
 369 
 370             // Produce extensions for ServerHello handshake message.
 371             SSLExtension[] serverHelloExtensions =
 372                 shc.sslConfig.getEnabledExtensions(
 373                         SSLHandshake.SERVER_HELLO, shc.negotiatedProtocol);
 374             shm.extensions.produce(shc, serverHelloExtensions);
 375             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 376                 SSLLogger.fine(&quot;Produced ServerHello handshake message&quot;, shm);
 377             }
 378 
 379             // Output the handshake message.
 380             shm.write(shc.handshakeOutput);
 381             shc.handshakeOutput.flush();
 382 
 383             if (shc.isResumption &amp;&amp; shc.resumingSession != null) {
 384                 SSLTrafficKeyDerivation kdg =
 385                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
 386                 if (kdg == null) {
 387                     // unlikely
 388                     throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 389                             &quot;Not supported key derivation: &quot; +
 390                             shc.negotiatedProtocol);
 391                 } else {
 392                     shc.handshakeKeyDerivation = kdg.createKeyDerivation(
 393                             shc, shc.resumingSession.getMasterSecret());
 394                 }
 395 
 396                 // update the responders
 397                 shc.handshakeProducers.put(SSLHandshake.FINISHED.id,
 398                         SSLHandshake.FINISHED);
 399             }
 400 
 401             // The handshake message has been delivered.
 402             return null;
 403         }
 404 
 405         private static KeyExchangeProperties chooseCipherSuite(
 406                 ServerHandshakeContext shc,
 407                 ClientHelloMessage clientHello) throws IOException {
 408             List&lt;CipherSuite&gt; preferred;
 409             List&lt;CipherSuite&gt; proposed;
 410             if (shc.sslConfig.preferLocalCipherSuites) {
 411                 preferred = shc.activeCipherSuites;
 412                 proposed = clientHello.cipherSuites;
 413             } else {
 414                 preferred = clientHello.cipherSuites;
 415                 proposed = shc.activeCipherSuites;
 416             }
 417 
 418             List&lt;CipherSuite&gt; legacySuites = new LinkedList&lt;&gt;();
 419             for (CipherSuite cs : preferred) {
 420                 if (!HandshakeContext.isNegotiable(
 421                         proposed, shc.negotiatedProtocol, cs)) {
 422                     continue;
 423                 }
 424 
 425                 if (shc.sslConfig.clientAuthType ==
 426                         ClientAuthType.CLIENT_AUTH_REQUIRED) {
 427                     if ((cs.keyExchange == KeyExchange.K_DH_ANON) ||
 428                         (cs.keyExchange == KeyExchange.K_ECDH_ANON)) {
 429                         continue;
 430                     }
 431                 }
 432 
 433                 SSLKeyExchange ke = SSLKeyExchange.valueOf(
 434                         cs.keyExchange, shc.negotiatedProtocol);
 435                 if (ke == null) {
 436                     continue;
 437                 }
 438                 if (!ServerHandshakeContext.legacyAlgorithmConstraints.permits(
 439                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT), cs.name, null)) {
 440                     legacySuites.add(cs);
 441                     continue;
 442                 }
 443 
 444                 SSLPossession[] hcds = ke.createPossessions(shc);
 445                 if ((hcds == null) || (hcds.length == 0)) {
 446                     continue;
 447                 }
 448 
 449                 // The cipher suite has been negotiated.
 450                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 451                     SSLLogger.fine(&quot;use cipher suite &quot; + cs.name);
 452                 }
 453 
 454                 return new KeyExchangeProperties(cs, ke, hcds);
 455             }
 456 
 457             for (CipherSuite cs : legacySuites) {
 458                 SSLKeyExchange ke = SSLKeyExchange.valueOf(
 459                         cs.keyExchange,  shc.negotiatedProtocol);
 460                 if (ke != null) {
 461                     SSLPossession[] hcds = ke.createPossessions(shc);
 462                     if ((hcds != null) &amp;&amp; (hcds.length != 0)) {
 463                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 464                             SSLLogger.warning(
 465                                 &quot;use legacy cipher suite &quot; + cs.name);
 466                         }
 467                         return new KeyExchangeProperties(cs, ke, hcds);
 468                     }
 469                 }
 470             }
 471 
 472             throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 473                     &quot;no cipher suites in common&quot;);
 474         }
 475 
 476         private static final class KeyExchangeProperties {
 477             final CipherSuite cipherSuite;
 478             final SSLKeyExchange keyExchange;
 479             final SSLPossession[] possessions;
 480 
 481             private KeyExchangeProperties(CipherSuite cipherSuite,
 482                     SSLKeyExchange keyExchange, SSLPossession[] possessions) {
 483                 this.cipherSuite = cipherSuite;
 484                 this.keyExchange = keyExchange;
 485                 this.possessions = possessions;
 486             }
 487         }
 488     }
 489 
 490     /**
 491      * The &quot;ServerHello&quot; handshake message producer.
 492      */
 493     private static final
 494             class T13ServerHelloProducer implements HandshakeProducer {
 495         // Prevent instantiation of this class.
 496         private T13ServerHelloProducer() {
 497             // blank
 498         }
 499 
 500         @Override
 501         public byte[] produce(ConnectionContext context,
 502                 HandshakeMessage message) throws IOException {
 503             // The producing happens in server side only.
 504             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 505             ClientHelloMessage clientHello = (ClientHelloMessage)message;
 506 
 507             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
 508                     shc.sslContext.engineGetServerSessionContext();
 509 
 510             // If client hasn&#39;t specified a session we can resume, start a
 511             // new one and choose its cipher suite and compression options,
 512             // unless new session creation is disabled for this connection!
 513             if (!shc.isResumption || shc.resumingSession == null) {
 514                 if (!shc.sslConfig.enableSessionCreation) {
 515                     throw new SSLException(
 516                         &quot;Not resumption, and no new session is allowed&quot;);
 517                 }
 518 
 519                 if (shc.localSupportedSignAlgs == null) {
 520                     shc.localSupportedSignAlgs =
 521                         SignatureScheme.getSupportedAlgorithms(
 522                                 shc.algorithmConstraints, shc.activeProtocols);
 523                 }
 524 
 525                 SSLSessionImpl session =
 526                         new SSLSessionImpl(shc, CipherSuite.C_NULL);
 527                 session.setMaximumPacketSize(shc.sslConfig.maximumPacketSize);
 528                 shc.handshakeSession = session;
 529 
 530                 // consider the handshake extension impact
 531                 SSLExtension[] enabledExtensions =
 532                         shc.sslConfig.getEnabledExtensions(
 533                             SSLHandshake.CLIENT_HELLO, shc.negotiatedProtocol);
 534                 clientHello.extensions.consumeOnTrade(shc, enabledExtensions);
 535 
 536                 // negotiate the cipher suite.
 537                 CipherSuite cipherSuite = chooseCipherSuite(shc, clientHello);
 538                 if (cipherSuite == null) {
 539                     throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 540                             &quot;no cipher suites in common&quot;);
 541                 }
 542                 shc.negotiatedCipherSuite = cipherSuite;
 543                 shc.handshakeSession.setSuite(cipherSuite);
 544                 shc.handshakeHash.determine(
 545                         shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 546             } else {
 547                 shc.handshakeSession = shc.resumingSession;
 548 
 549                 // consider the handshake extension impact
 550                 SSLExtension[] enabledExtensions =
 551                 shc.sslConfig.getEnabledExtensions(
 552                 SSLHandshake.CLIENT_HELLO, shc.negotiatedProtocol);
 553                 clientHello.extensions.consumeOnTrade(shc, enabledExtensions);
 554 
 555                 shc.negotiatedProtocol =
 556                         shc.resumingSession.getProtocolVersion();
 557                 shc.negotiatedCipherSuite = shc.resumingSession.getSuite();
 558                 shc.handshakeHash.determine(
 559                         shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 560 
 561                 setUpPskKD(shc,
 562                         shc.resumingSession.consumePreSharedKey());
 563 
 564                 // The session can&#39;t be resumed again---remove it from cache
 565                 sessionCache.remove(shc.resumingSession.getSessionId());
 566             }
 567 
 568             // update the responders
 569             shc.handshakeProducers.put(SSLHandshake.ENCRYPTED_EXTENSIONS.id,
 570                     SSLHandshake.ENCRYPTED_EXTENSIONS);
 571             shc.handshakeProducers.put(SSLHandshake.FINISHED.id,
 572                     SSLHandshake.FINISHED);
 573 
 574             // Generate the ServerHello handshake message.
 575             ServerHelloMessage shm = new ServerHelloMessage(shc,
 576                     ProtocolVersion.TLS12,      // use legacy version
 577                     clientHello.sessionId,      // echo back
 578                     shc.negotiatedCipherSuite,
 579                     new RandomCookie(shc),
 580                     clientHello);
 581             shc.serverHelloRandom = shm.serverRandom;
 582 
 583             // Produce extensions for ServerHello handshake message.
 584             SSLExtension[] serverHelloExtensions =
 585                     shc.sslConfig.getEnabledExtensions(
 586                         SSLHandshake.SERVER_HELLO, shc.negotiatedProtocol);
 587             shm.extensions.produce(shc, serverHelloExtensions);
 588             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 589                 SSLLogger.fine(&quot;Produced ServerHello handshake message&quot;, shm);
 590             }
 591 
 592             // Output the handshake message.
 593             shm.write(shc.handshakeOutput);
 594             shc.handshakeOutput.flush();
 595 
 596             // Change client/server handshake traffic secrets.
 597             // Refresh handshake hash
 598             shc.handshakeHash.update();
 599 
 600             // Change client/server handshake traffic secrets.
 601             SSLKeyExchange ke = shc.handshakeKeyExchange;
 602             if (ke == null) {
 603                 // unlikely
 604                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 605                         &quot;Not negotiated key shares&quot;);
 606             }
 607 
 608             SSLKeyDerivation handshakeKD = ke.createKeyDerivation(shc);
 609             SecretKey handshakeSecret = handshakeKD.deriveKey(
 610                     &quot;TlsHandshakeSecret&quot;, null);
 611 
 612             SSLTrafficKeyDerivation kdg =
 613                 SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
 614             if (kdg == null) {
 615                 // unlikely
 616                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 617                         &quot;Not supported key derivation: &quot; +
 618                         shc.negotiatedProtocol);
 619             }
 620 
 621             SSLKeyDerivation kd =
 622                     new SSLSecretDerivation(shc, handshakeSecret);
 623 
 624             // update the handshake traffic read keys.
 625             SecretKey readSecret = kd.deriveKey(
 626                     &quot;TlsClientHandshakeTrafficSecret&quot;, null);
 627             SSLKeyDerivation readKD =
 628                     kdg.createKeyDerivation(shc, readSecret);
 629             SecretKey readKey = readKD.deriveKey(
 630                     &quot;TlsKey&quot;, null);
 631             SecretKey readIvSecret = readKD.deriveKey(
 632                     &quot;TlsIv&quot;, null);
 633             IvParameterSpec readIv =
 634                     new IvParameterSpec(readIvSecret.getEncoded());
 635             SSLReadCipher readCipher;
 636             try {
 637                 readCipher =
 638                     shc.negotiatedCipherSuite.bulkCipher.createReadCipher(
 639                         Authenticator.valueOf(shc.negotiatedProtocol),
 640                         shc.negotiatedProtocol, readKey, readIv,
 641                         shc.sslContext.getSecureRandom());
 642             } catch (GeneralSecurityException gse) {
 643                 // unlikely
 644                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 645                         &quot;Missing cipher algorithm&quot;, gse);
 646             }
 647 
 648             if (readCipher == null) {
 649                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 650                     &quot;Illegal cipher suite (&quot; + shc.negotiatedCipherSuite +
 651                     &quot;) and protocol version (&quot; + shc.negotiatedProtocol +
 652                     &quot;)&quot;);
 653             }
 654 
 655             shc.baseReadSecret = readSecret;
 656             shc.conContext.inputRecord.changeReadCiphers(readCipher);
 657 
 658             // update the handshake traffic write secret.
 659             SecretKey writeSecret = kd.deriveKey(
 660                     &quot;TlsServerHandshakeTrafficSecret&quot;, null);
 661             SSLKeyDerivation writeKD =
 662                     kdg.createKeyDerivation(shc, writeSecret);
 663             SecretKey writeKey = writeKD.deriveKey(
 664                     &quot;TlsKey&quot;, null);
 665             SecretKey writeIvSecret = writeKD.deriveKey(
 666                     &quot;TlsIv&quot;, null);
 667             IvParameterSpec writeIv =
 668                     new IvParameterSpec(writeIvSecret.getEncoded());
 669             SSLWriteCipher writeCipher;
 670             try {
 671                 writeCipher =
 672                     shc.negotiatedCipherSuite.bulkCipher.createWriteCipher(
 673                         Authenticator.valueOf(shc.negotiatedProtocol),
 674                         shc.negotiatedProtocol, writeKey, writeIv,
 675                         shc.sslContext.getSecureRandom());
 676             } catch (GeneralSecurityException gse) {
 677                 // unlikely
 678                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 679                         &quot;Missing cipher algorithm&quot;, gse);
 680             }
 681 
 682             if (writeCipher == null) {
 683                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 684                     &quot;Illegal cipher suite (&quot; + shc.negotiatedCipherSuite +
 685                     &quot;) and protocol version (&quot; + shc.negotiatedProtocol +
 686                     &quot;)&quot;);
 687             }
 688 
 689             shc.baseWriteSecret = writeSecret;
 690             shc.conContext.outputRecord.changeWriteCiphers(
 691                     writeCipher, (clientHello.sessionId.length() != 0));
 692 
 693             // Update the context for master key derivation.
 694             shc.handshakeKeyDerivation = kd;
 695 
 696             // Check if the server supports stateless resumption
 697             if (sessionCache.statelessEnabled()) {
 698                 shc.statelessResumption = true;
 699             }
 700 
 701             // The handshake message has been delivered.
 702             return null;
 703         }
 704 
 705         private static CipherSuite chooseCipherSuite(
 706                 ServerHandshakeContext shc,
 707                 ClientHelloMessage clientHello) throws IOException {
 708             List&lt;CipherSuite&gt; preferred;
 709             List&lt;CipherSuite&gt; proposed;
 710             if (shc.sslConfig.preferLocalCipherSuites) {
 711                 preferred = shc.activeCipherSuites;
 712                 proposed = clientHello.cipherSuites;
 713             } else {
 714                 preferred = clientHello.cipherSuites;
 715                 proposed = shc.activeCipherSuites;
 716             }
 717 
 718             CipherSuite legacySuite = null;
 719             AlgorithmConstraints legacyConstraints =
 720                     ServerHandshakeContext.legacyAlgorithmConstraints;
 721             for (CipherSuite cs : preferred) {
 722                 if (!HandshakeContext.isNegotiable(
 723                         proposed, shc.negotiatedProtocol, cs)) {
 724                     continue;
 725                 }
 726 
 727                 if ((legacySuite == null) &amp;&amp;
 728                         !legacyConstraints.permits(
 729                                 EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
 730                                 cs.name, null)) {
 731                     legacySuite = cs;
 732                     continue;
 733                 }
 734 
 735                 // The cipher suite has been negotiated.
 736                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 737                     SSLLogger.fine(&quot;use cipher suite &quot; + cs.name);
 738                 }
 739                 return cs;
 740             }
 741 
 742             if (legacySuite != null) {
 743                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 744                     SSLLogger.warning(
 745                             &quot;use legacy cipher suite &quot; + legacySuite.name);
 746                 }
 747                 return legacySuite;
 748             }
 749 
 750             // no cipher suites in common
 751             return null;
 752         }
 753     }
 754 
 755     /**
 756      * The &quot;HelloRetryRequest&quot; handshake message producer.
 757      */
 758     private static final
 759             class T13HelloRetryRequestProducer implements HandshakeProducer {
 760         // Prevent instantiation of this class.
 761         private T13HelloRetryRequestProducer() {
 762             // blank
 763         }
 764 
 765         @Override
 766         public byte[] produce(ConnectionContext context,
 767                 HandshakeMessage message) throws IOException {
 768             ServerHandshakeContext shc = (ServerHandshakeContext) context;
 769             ClientHelloMessage clientHello = (ClientHelloMessage) message;
 770 
 771             // negotiate the cipher suite.
 772             CipherSuite cipherSuite =
 773                     T13ServerHelloProducer.chooseCipherSuite(shc, clientHello);
 774             if (cipherSuite == null) {
 775                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 776                         &quot;no cipher suites in common for hello retry request&quot;);
 777             }
 778 
 779             ServerHelloMessage hhrm = new ServerHelloMessage(shc,
 780                     ProtocolVersion.TLS12,      // use legacy version
 781                     clientHello.sessionId,      //  echo back
 782                     cipherSuite,
 783                     RandomCookie.hrrRandom,
 784                     clientHello
 785             );
 786 
 787             shc.negotiatedCipherSuite = cipherSuite;
 788             shc.handshakeHash.determine(
 789                     shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 790 
 791             // Produce extensions for HelloRetryRequest handshake message.
 792             SSLExtension[] serverHelloExtensions =
 793                 shc.sslConfig.getEnabledExtensions(
 794                     SSLHandshake.HELLO_RETRY_REQUEST, shc.negotiatedProtocol);
 795             hhrm.extensions.produce(shc, serverHelloExtensions);
 796             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 797                 SSLLogger.fine(
 798                         &quot;Produced HelloRetryRequest handshake message&quot;, hhrm);
 799             }
 800 
 801             // Output the handshake message.
 802             hhrm.write(shc.handshakeOutput);
 803             shc.handshakeOutput.flush();
 804 
 805             // Stateless, shall we clean up the handshake context as well?
 806             shc.handshakeHash.finish();     // forgot about the handshake hash
 807             shc.handshakeExtensions.clear();
 808 
 809             // What&#39;s the expected response?
 810             shc.handshakeConsumers.put(
 811                     SSLHandshake.CLIENT_HELLO.id, SSLHandshake.CLIENT_HELLO);
 812 
 813             // The handshake message has been delivered.
 814             return null;
 815         }
 816     }
 817 
 818     /**
 819      * The &quot;HelloRetryRequest&quot; handshake message reproducer.
 820      */
 821     private static final
 822             class T13HelloRetryRequestReproducer implements HandshakeProducer {
 823         // Prevent instantiation of this class.
 824         private T13HelloRetryRequestReproducer() {
 825             // blank
 826         }
 827 
 828         @Override
 829         public byte[] produce(ConnectionContext context,
 830                 HandshakeMessage message) throws IOException {
 831             ServerHandshakeContext shc = (ServerHandshakeContext) context;
 832             ClientHelloMessage clientHello = (ClientHelloMessage) message;
 833 
 834             // negotiate the cipher suite.
 835             CipherSuite cipherSuite = shc.negotiatedCipherSuite;
 836             ServerHelloMessage hhrm = new ServerHelloMessage(shc,
 837                     ProtocolVersion.TLS12,      // use legacy version
 838                     clientHello.sessionId,      //  echo back
 839                     cipherSuite,
 840                     RandomCookie.hrrRandom,
 841                     clientHello
 842             );
 843 
 844             // Produce extensions for HelloRetryRequest handshake message.
 845             SSLExtension[] serverHelloExtensions =
 846                 shc.sslConfig.getEnabledExtensions(
 847                     SSLHandshake.MESSAGE_HASH, shc.negotiatedProtocol);
 848             hhrm.extensions.produce(shc, serverHelloExtensions);
 849             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 850                 SSLLogger.fine(
 851                         &quot;Reproduced HelloRetryRequest handshake message&quot;, hhrm);
 852             }
 853 
 854             HandshakeOutStream hos = new HandshakeOutStream(null);
 855             hhrm.write(hos);
 856 
 857             return hos.toByteArray();
 858         }
 859     }
 860 
 861     /**
 862      * The &quot;ServerHello&quot; handshake message consumer.
 863      */
 864     private static final
 865             class ServerHelloConsumer implements SSLConsumer {
 866         // Prevent instantiation of this class.
 867         private ServerHelloConsumer() {
 868             // blank
 869         }
 870 
 871         @Override
 872         public void consume(ConnectionContext context,
 873                 ByteBuffer message) throws IOException {
 874             // The consuming happens in client side only.
 875             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 876 
 877             // clean up this consumer
 878             chc.handshakeConsumers.remove(SSLHandshake.SERVER_HELLO.id);
 879             if (!chc.handshakeConsumers.isEmpty()) {
 880                 // DTLS 1.0/1.2
 881                 chc.handshakeConsumers.remove(
 882                         SSLHandshake.HELLO_VERIFY_REQUEST.id);
 883             }
 884             if (!chc.handshakeConsumers.isEmpty()) {
 885                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 886                     &quot;No more message expected before ServerHello is processed&quot;);
 887             }
 888 
 889             ServerHelloMessage shm = new ServerHelloMessage(chc, message);
 890             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 891                 SSLLogger.fine(&quot;Consuming ServerHello handshake message&quot;, shm);
 892             }
 893 
 894             if (shm.serverRandom.isHelloRetryRequest()) {
 895                 onHelloRetryRequest(chc, shm);
 896             } else {
 897                 onServerHello(chc, shm);
 898             }
 899         }
 900 
 901         private void onHelloRetryRequest(ClientHandshakeContext chc,
 902                 ServerHelloMessage helloRetryRequest) throws IOException {
 903             // Negotiate protocol version.
 904             //
 905             // Check and launch SupportedVersions.
 906             SSLExtension[] extTypes = new SSLExtension[] {
 907                     SSLExtension.HRR_SUPPORTED_VERSIONS
 908                 };
 909             helloRetryRequest.extensions.consumeOnLoad(chc, extTypes);
 910 
 911             ProtocolVersion serverVersion;
 912             SHSupportedVersionsSpec svs =
 913                     (SHSupportedVersionsSpec)chc.handshakeExtensions.get(
 914                             SSLExtension.HRR_SUPPORTED_VERSIONS);
 915             if (svs != null) {
 916                 serverVersion =            // could be null
 917                         ProtocolVersion.valueOf(svs.selectedVersion);
 918             } else {
 919                 serverVersion = helloRetryRequest.serverVersion;
 920             }
 921 
 922             if (!chc.activeProtocols.contains(serverVersion)) {
 923                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
 924                     &quot;The server selected protocol version &quot; + serverVersion +
 925                     &quot; is not accepted by client preferences &quot; +
 926                     chc.activeProtocols);
 927             }
 928 
 929             if (!serverVersion.useTLS13PlusSpec()) {
 930                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
 931                     &quot;Unexpected HelloRetryRequest for &quot; + serverVersion.name);
 932             }
 933 
 934             chc.negotiatedProtocol = serverVersion;
 935             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 936                 SSLLogger.fine(
 937                     &quot;Negotiated protocol version: &quot; + serverVersion.name);
 938             }
 939 
 940             // TLS 1.3 key share extension may have produced client
 941             // possessions for TLS 1.3 key exchanges.
 942             //
 943             // Clean up before producing new client key share possessions.
 944             chc.handshakePossessions.clear();
 945 
 946             if (serverVersion.isDTLS) {
 947                 d13HrrHandshakeConsumer.consume(chc, helloRetryRequest);
 948             } else {
 949                 t13HrrHandshakeConsumer.consume(chc, helloRetryRequest);
 950             }
 951         }
 952 
 953         private void onServerHello(ClientHandshakeContext chc,
 954                 ServerHelloMessage serverHello) throws IOException {
 955             // Negotiate protocol version.
 956             //
 957             // Check and launch SupportedVersions.
 958             SSLExtension[] extTypes = new SSLExtension[] {
 959                     SSLExtension.SH_SUPPORTED_VERSIONS
 960                 };
 961             serverHello.extensions.consumeOnLoad(chc, extTypes);
 962 
 963             ProtocolVersion serverVersion;
 964             SHSupportedVersionsSpec svs =
 965                     (SHSupportedVersionsSpec)chc.handshakeExtensions.get(
 966                             SSLExtension.SH_SUPPORTED_VERSIONS);
 967             if (svs != null) {
 968                 serverVersion =            // could be null
 969                         ProtocolVersion.valueOf(svs.selectedVersion);
 970             } else {
 971                 serverVersion = serverHello.serverVersion;
 972             }
 973 
 974             if (!chc.activeProtocols.contains(serverVersion)) {
 975                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
 976                     &quot;The server selected protocol version &quot; + serverVersion +
 977                     &quot; is not accepted by client preferences &quot; +
 978                     chc.activeProtocols);
 979             }
 980 
 981             chc.negotiatedProtocol = serverVersion;
 982             if (!chc.conContext.isNegotiated) {
 983                 chc.conContext.protocolVersion = chc.negotiatedProtocol;
 984                 chc.conContext.outputRecord.setVersion(chc.negotiatedProtocol);
 985             }
 986             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 987                 SSLLogger.fine(
 988                     &quot;Negotiated protocol version: &quot; + serverVersion.name);
 989             }
 990 
 991             if (serverHello.serverRandom.isVersionDowngrade(chc)) {
 992                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 993                     &quot;A potential protocol version downgrade attack&quot;);
 994             }
 995 
 996             // Consume the handshake message for the specific protocol version.
 997             if (serverVersion.isDTLS) {
 998                 if (serverVersion.useTLS13PlusSpec()) {
 999                     d13HandshakeConsumer.consume(chc, serverHello);
1000                 } else {
1001                     // TLS 1.3 key share extension may have produced client
1002                     // possessions for TLS 1.3 key exchanges.
1003                     chc.handshakePossessions.clear();
1004 
1005                     d12HandshakeConsumer.consume(chc, serverHello);
1006                 }
1007             } else {
1008                 if (serverVersion.useTLS13PlusSpec()) {
1009                     t13HandshakeConsumer.consume(chc, serverHello);
1010                 } else {
1011                     // TLS 1.3 key share extension may have produced client
1012                     // possessions for TLS 1.3 key exchanges.
1013                     chc.handshakePossessions.clear();
1014 
1015                     t12HandshakeConsumer.consume(chc, serverHello);
1016                 }
1017             }
1018         }
1019     }
1020 
1021     private static final
1022             class T12ServerHelloConsumer implements HandshakeConsumer {
1023         // Prevent instantiation of this class.
1024         private T12ServerHelloConsumer() {
1025             // blank
1026         }
1027 
1028         @Override
1029         public void consume(ConnectionContext context,
1030                 HandshakeMessage message) throws IOException {
1031             // The consuming happens in client side only.
1032             ClientHandshakeContext chc = (ClientHandshakeContext)context;
1033             ServerHelloMessage serverHello = (ServerHelloMessage)message;
1034             if (!chc.isNegotiable(serverHello.serverVersion)) {
1035                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1036                     &quot;Server chose &quot; + serverHello.serverVersion +
1037                     &quot;, but that protocol version is not enabled or &quot; +
1038                     &quot;not supported by the client.&quot;);
1039             }
1040 
1041             // chc.negotiatedProtocol = serverHello.serverVersion;
1042             chc.negotiatedCipherSuite = serverHello.cipherSuite;
1043             chc.handshakeHash.determine(
1044                     chc.negotiatedProtocol, chc.negotiatedCipherSuite);
1045             chc.serverHelloRandom = serverHello.serverRandom;
1046             if (chc.negotiatedCipherSuite.keyExchange == null) {
1047                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1048                     &quot;TLS 1.2 or prior version does not support the &quot; +
1049                     &quot;server cipher suite: &quot; + chc.negotiatedCipherSuite.name);
1050             }
1051 
1052             //
1053             // validate
1054             //
1055 
1056             // Check and launch the &quot;renegotiation_info&quot; extension.
1057             SSLExtension[] extTypes = new SSLExtension[] {
1058                     SSLExtension.SH_RENEGOTIATION_INFO
1059                 };
1060             serverHello.extensions.consumeOnLoad(chc, extTypes);
1061 
1062             // Is it session resuming?
1063             if (chc.resumingSession != null) {
1064                 // we tried to resume, let&#39;s see what the server decided
1065                 if (serverHello.sessionId.equals(
1066                         chc.resumingSession.getSessionId())) {
1067                     // server resumed the session, let&#39;s make sure everything
1068                     // checks out
1069 
1070                     // Verify that the session ciphers are unchanged.
1071                     CipherSuite sessionSuite = chc.resumingSession.getSuite();
1072                     if (chc.negotiatedCipherSuite != sessionSuite) {
1073                         throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1074                             &quot;Server returned wrong cipher suite for session&quot;);
1075                     }
1076 
1077                     // verify protocol version match
1078                     ProtocolVersion sessionVersion =
1079                             chc.resumingSession.getProtocolVersion();
1080                     if (chc.negotiatedProtocol != sessionVersion) {
1081                         throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1082                             &quot;Server resumed with wrong protocol version&quot;);
1083                     }
1084 
1085                     // looks fine;  resume it.
1086                     chc.isResumption = true;
1087                     chc.resumingSession.setAsSessionResumption(true);
1088                     chc.handshakeSession = chc.resumingSession;
1089                 } else {
1090                     // we wanted to resume, but the server refused
1091                     //
1092                     // Invalidate the session for initial handshake in case
1093                     // of reusing next time.
1094                     if (chc.resumingSession != null) {
1095                         chc.resumingSession.invalidate();
1096                         chc.resumingSession = null;
1097                     }
1098                     chc.isResumption = false;
1099                     if (!chc.sslConfig.enableSessionCreation) {
1100                         throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1101                             &quot;New session creation is disabled&quot;);
1102                     }
1103                 }
1104             }
1105 
1106             // Check and launch ClientHello extensions.
1107             extTypes = chc.sslConfig.getEnabledExtensions(
1108                     SSLHandshake.SERVER_HELLO);
1109             serverHello.extensions.consumeOnLoad(chc, extTypes);
1110 
1111             if (!chc.isResumption) {
1112                 if (chc.resumingSession != null) {
1113                     // in case the resumption happens next time.
1114                     chc.resumingSession.invalidate();
1115                     chc.resumingSession = null;
1116                 }
1117 
1118                 if (!chc.sslConfig.enableSessionCreation) {
1119                     throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1120                         &quot;New session creation is disabled&quot;);
1121                 }
1122 
1123                 if (serverHello.sessionId.length() == 0 &amp;&amp;
1124                         chc.statelessResumption) {
1125                     SessionId newId = new SessionId(true,
1126                             chc.sslContext.getSecureRandom());
1127                     chc.handshakeSession = new SSLSessionImpl(chc,
1128                             chc.negotiatedCipherSuite, newId);
1129 
1130                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1131                         SSLLogger.fine(&quot;Locally assigned Session Id: &quot; +
1132                                 newId.toString());
1133                     }
1134                 } else {
1135                     chc.handshakeSession = new SSLSessionImpl(chc,
1136                             chc.negotiatedCipherSuite,
1137                             serverHello.sessionId);
1138                 }
1139                 chc.handshakeSession.setMaximumPacketSize(
1140                         chc.sslConfig.maximumPacketSize);
1141             }
1142 
1143             //
1144             // update
1145             //
1146             serverHello.extensions.consumeOnTrade(chc, extTypes);
1147 
1148             // update the consumers and producers
1149             if (chc.isResumption) {
1150                 SSLTrafficKeyDerivation kdg =
1151                         SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
1152                 if (kdg == null) {
1153                     // unlikely
1154                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1155                             &quot;Not supported key derivation: &quot; +
1156                             chc.negotiatedProtocol);
1157                 } else {
1158                     chc.handshakeKeyDerivation = kdg.createKeyDerivation(
1159                             chc, chc.resumingSession.getMasterSecret());
1160                 }
1161 
1162                 if (chc.statelessResumption) {
1163                     chc.handshakeConsumers.putIfAbsent(
1164                             SSLHandshake.NEW_SESSION_TICKET.id,
1165                             SSLHandshake.NEW_SESSION_TICKET);
1166                 }
1167                 chc.conContext.consumers.putIfAbsent(
1168                         ContentType.CHANGE_CIPHER_SPEC.id,
1169                         ChangeCipherSpec.t10Consumer);
1170                 chc.handshakeConsumers.put(
1171                         SSLHandshake.FINISHED.id,
1172                         SSLHandshake.FINISHED);
1173             } else {
1174                 SSLKeyExchange ke = SSLKeyExchange.valueOf(
1175                         chc.negotiatedCipherSuite.keyExchange,
1176                         chc.negotiatedProtocol);
1177                 chc.handshakeKeyExchange = ke;
1178                 if (ke != null) {
1179                     for (SSLHandshake handshake :
1180                             ke.getRelatedHandshakers(chc)) {
1181                         chc.handshakeConsumers.put(handshake.id, handshake);
1182                     }
1183                 }
1184 
1185                 chc.handshakeConsumers.put(SSLHandshake.SERVER_HELLO_DONE.id,
1186                         SSLHandshake.SERVER_HELLO_DONE);
1187             }
1188 
1189             //
1190             // produce
1191             //
1192             // Need no new handshake message producers here.
1193         }
1194     }
1195 
1196     private static void setUpPskKD(HandshakeContext hc,
1197             SecretKey psk) throws SSLHandshakeException {
1198 
1199         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1200             SSLLogger.fine(&quot;Using PSK to derive early secret&quot;);
1201         }
1202 
1203         try {
1204             CipherSuite.HashAlg hashAlg = hc.negotiatedCipherSuite.hashAlg;
1205             HKDF hkdf = new HKDF(hashAlg.name);
1206             byte[] zeros = new byte[hashAlg.hashLength];
1207             SecretKey earlySecret = hkdf.extract(zeros, psk, &quot;TlsEarlySecret&quot;);
1208             hc.handshakeKeyDerivation =
1209                     new SSLSecretDerivation(hc, earlySecret);
1210         } catch  (GeneralSecurityException gse) {
1211             throw (SSLHandshakeException) new SSLHandshakeException(
1212                 &quot;Could not generate secret&quot;).initCause(gse);
1213         }
1214     }
1215 
1216     private static final
1217             class T13ServerHelloConsumer implements HandshakeConsumer {
1218         // Prevent instantiation of this class.
1219         private T13ServerHelloConsumer() {
1220             // blank
1221         }
1222 
1223         @Override
1224         public void consume(ConnectionContext context,
1225                 HandshakeMessage message) throws IOException {
1226             // The consuming happens in client side only.
1227             ClientHandshakeContext chc = (ClientHandshakeContext)context;
1228             ServerHelloMessage serverHello = (ServerHelloMessage)message;
1229             if (serverHello.serverVersion != ProtocolVersion.TLS12) {
1230                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1231                     &quot;The ServerHello.legacy_version field is not TLS 1.2&quot;);
1232             }
1233 
1234             chc.negotiatedCipherSuite = serverHello.cipherSuite;
1235             chc.handshakeHash.determine(
1236                     chc.negotiatedProtocol, chc.negotiatedCipherSuite);
1237             chc.serverHelloRandom = serverHello.serverRandom;
1238 
1239             //
1240             // validate
1241             //
1242 
1243             // Check and launch ServerHello extensions.
1244             SSLExtension[] extTypes = chc.sslConfig.getEnabledExtensions(
1245                     SSLHandshake.SERVER_HELLO);
1246             serverHello.extensions.consumeOnLoad(chc, extTypes);
1247             if (!chc.isResumption) {
1248                 if (chc.resumingSession != null) {
1249                     // in case the resumption happens next time.
1250                     chc.resumingSession.invalidate();
1251                     chc.resumingSession = null;
1252                 }
1253 
1254                 if (!chc.sslConfig.enableSessionCreation) {
1255                     throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1256                         &quot;New session creation is disabled&quot;);
1257                 }
1258                 chc.handshakeSession = new SSLSessionImpl(chc,
1259                         chc.negotiatedCipherSuite,
1260                         serverHello.sessionId);
1261                 chc.handshakeSession.setMaximumPacketSize(
1262                         chc.sslConfig.maximumPacketSize);
1263             } else {
1264                 // The PSK is consumed to allow it to be deleted
1265                 SecretKey psk =
1266                         chc.resumingSession.consumePreSharedKey();
1267                 if(psk == null) {
1268                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1269                     &quot;No PSK available. Unable to resume.&quot;);
1270                 }
1271 
1272                 chc.handshakeSession = chc.resumingSession;
1273 
1274                 setUpPskKD(chc, psk);
1275             }
1276 
1277             //
1278             // update
1279             //
1280             serverHello.extensions.consumeOnTrade(chc, extTypes);
1281 
1282             // Change client/server handshake traffic secrets.
1283             // Refresh handshake hash
1284             chc.handshakeHash.update();
1285 
1286             SSLKeyExchange ke = chc.handshakeKeyExchange;
1287             if (ke == null) {
1288                 // unlikely
1289                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1290                         &quot;Not negotiated key shares&quot;);
1291             }
1292 
1293             SSLKeyDerivation handshakeKD = ke.createKeyDerivation(chc);
1294             SecretKey handshakeSecret = handshakeKD.deriveKey(
1295                     &quot;TlsHandshakeSecret&quot;, null);
1296             SSLTrafficKeyDerivation kdg =
1297                 SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
1298             if (kdg == null) {
1299                 // unlikely
1300                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1301                         &quot;Not supported key derivation: &quot; +
1302                         chc.negotiatedProtocol);
1303             }
1304 
1305             SSLKeyDerivation secretKD =
1306                     new SSLSecretDerivation(chc, handshakeSecret);
1307 
1308             // update the handshake traffic read keys.
1309             SecretKey readSecret = secretKD.deriveKey(
1310                     &quot;TlsServerHandshakeTrafficSecret&quot;, null);
1311 
1312             SSLKeyDerivation readKD =
1313                     kdg.createKeyDerivation(chc, readSecret);
1314             SecretKey readKey = readKD.deriveKey(
1315                     &quot;TlsKey&quot;, null);
1316             SecretKey readIvSecret = readKD.deriveKey(
1317                     &quot;TlsIv&quot;, null);
1318             IvParameterSpec readIv =
1319                     new IvParameterSpec(readIvSecret.getEncoded());
1320             SSLReadCipher readCipher;
1321             try {
1322                 readCipher =
1323                     chc.negotiatedCipherSuite.bulkCipher.createReadCipher(
1324                         Authenticator.valueOf(chc.negotiatedProtocol),
1325                         chc.negotiatedProtocol, readKey, readIv,
1326                         chc.sslContext.getSecureRandom());
1327             } catch (GeneralSecurityException gse) {
1328                 // unlikely
1329                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
1330                         &quot;Missing cipher algorithm&quot;, gse);
1331             }
1332 
1333             if (readCipher == null) {
1334                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
1335                     &quot;Illegal cipher suite (&quot; + chc.negotiatedCipherSuite +
1336                     &quot;) and protocol version (&quot; + chc.negotiatedProtocol +
1337                     &quot;)&quot;);
1338             }
1339 
1340             chc.baseReadSecret = readSecret;
1341             chc.conContext.inputRecord.changeReadCiphers(readCipher);
1342 
1343             // update the handshake traffic write keys.
1344             SecretKey writeSecret = secretKD.deriveKey(
1345                     &quot;TlsClientHandshakeTrafficSecret&quot;, null);
1346             SSLKeyDerivation writeKD =
1347                     kdg.createKeyDerivation(chc, writeSecret);
1348             SecretKey writeKey = writeKD.deriveKey(
1349                     &quot;TlsKey&quot;, null);
1350             SecretKey writeIvSecret = writeKD.deriveKey(
1351                     &quot;TlsIv&quot;, null);
1352             IvParameterSpec writeIv =
1353                     new IvParameterSpec(writeIvSecret.getEncoded());
1354             SSLWriteCipher writeCipher;
1355             try {
1356                 writeCipher =
1357                     chc.negotiatedCipherSuite.bulkCipher.createWriteCipher(
1358                         Authenticator.valueOf(chc.negotiatedProtocol),
1359                         chc.negotiatedProtocol, writeKey, writeIv,
1360                         chc.sslContext.getSecureRandom());
1361             } catch (GeneralSecurityException gse) {
1362                 // unlikely
1363                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
1364                         &quot;Missing cipher algorithm&quot;, gse);
1365             }
1366 
1367             if (writeCipher == null) {
1368                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
1369                     &quot;Illegal cipher suite (&quot; + chc.negotiatedCipherSuite +
1370                     &quot;) and protocol version (&quot; + chc.negotiatedProtocol +
1371                     &quot;)&quot;);
1372             }
1373 
1374             chc.baseWriteSecret = writeSecret;
1375             chc.conContext.outputRecord.changeWriteCiphers(
1376                     writeCipher, (serverHello.sessionId.length() != 0));
1377 
1378             // Should use resumption_master_secret for TLS 1.3.
1379             // chc.handshakeSession.setMasterSecret(masterSecret);
1380 
1381             // Update the context for master key derivation.
1382             chc.handshakeKeyDerivation = secretKD;
1383 
1384             // update the consumers and producers
1385             //
1386             // The server sends a dummy change_cipher_spec record immediately
1387             // after its first handshake message.  This may either be after a
1388             // ServerHello or a HelloRetryRequest.
1389             chc.conContext.consumers.putIfAbsent(
1390                     ContentType.CHANGE_CIPHER_SPEC.id,
1391                     ChangeCipherSpec.t13Consumer);
1392 
1393             chc.handshakeConsumers.put(
1394                     SSLHandshake.ENCRYPTED_EXTENSIONS.id,
1395                     SSLHandshake.ENCRYPTED_EXTENSIONS);
1396 
1397             // Support cert authentication only, when not PSK.
1398             chc.handshakeConsumers.put(
1399                     SSLHandshake.CERTIFICATE_REQUEST.id,
1400                     SSLHandshake.CERTIFICATE_REQUEST);
1401             chc.handshakeConsumers.put(
1402                     SSLHandshake.CERTIFICATE.id,
1403                     SSLHandshake.CERTIFICATE);
1404             chc.handshakeConsumers.put(
1405                     SSLHandshake.CERTIFICATE_VERIFY.id,
1406                     SSLHandshake.CERTIFICATE_VERIFY);
1407 
1408             chc.handshakeConsumers.put(
1409                     SSLHandshake.FINISHED.id,
1410                     SSLHandshake.FINISHED);
1411 
1412             //
1413             // produce
1414             //
1415             // Need no new handshake message producers here.
1416         }
1417     }
1418 
1419     private static final
1420             class T13HelloRetryRequestConsumer implements HandshakeConsumer {
1421         // Prevent instantiation of this class.
1422         private T13HelloRetryRequestConsumer() {
1423             // blank
1424         }
1425 
1426         @Override
1427         public void consume(ConnectionContext context,
1428                 HandshakeMessage message) throws IOException {
1429             // The consuming happens in client side only.
1430             ClientHandshakeContext chc = (ClientHandshakeContext)context;
1431             ServerHelloMessage helloRetryRequest = (ServerHelloMessage)message;
1432             if (helloRetryRequest.serverVersion != ProtocolVersion.TLS12) {
1433                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1434                     &quot;The HelloRetryRequest.legacy_version is not TLS 1.2&quot;);
1435             }
1436 
1437             chc.negotiatedCipherSuite = helloRetryRequest.cipherSuite;
1438 
1439             //
1440             // validate
1441             //
1442 
1443             // Check and launch ClientHello extensions.
1444             SSLExtension[] extTypes = chc.sslConfig.getEnabledExtensions(
1445                     SSLHandshake.HELLO_RETRY_REQUEST);
1446             helloRetryRequest.extensions.consumeOnLoad(chc, extTypes);
1447 
1448             //
1449             // update
1450             //
1451             helloRetryRequest.extensions.consumeOnTrade(chc, extTypes);
1452 
1453             // Change client/server handshake traffic secrets.
1454             // Refresh handshake hash
1455             chc.handshakeHash.finish();     // reset the handshake hash
1456 
1457             // calculate the transcript hash of the 1st ClientHello message
1458             HandshakeOutStream hos = new HandshakeOutStream(null);
1459             try {
1460                 chc.initialClientHelloMsg.write(hos);
1461             } catch (IOException ioe) {
1462                 // unlikely
1463                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
1464                     &quot;Failed to construct message hash&quot;, ioe);
1465             }
1466             chc.handshakeHash.deliver(hos.toByteArray());
1467             chc.handshakeHash.determine(
1468                     chc.negotiatedProtocol, chc.negotiatedCipherSuite);
1469             byte[] clientHelloHash = chc.handshakeHash.digest();
1470 
1471             // calculate the message_hash
1472             //
1473             // Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) =
1474             //   Hash(message_hash ||    /* Handshake type */
1475             //     00 00 Hash.length ||  /* Handshake message length (bytes) */
1476             //     Hash(ClientHello1) || /* Hash of ClientHello1 */
1477             //     HelloRetryRequest || ... || Mn)
1478             int hashLen = chc.negotiatedCipherSuite.hashAlg.hashLength;
1479             byte[] hashedClientHello = new byte[4 + hashLen];
1480             hashedClientHello[0] = SSLHandshake.MESSAGE_HASH.id;
1481             hashedClientHello[1] = (byte)0x00;
1482             hashedClientHello[2] = (byte)0x00;
1483             hashedClientHello[3] = (byte)(hashLen &amp; 0xFF);
1484             System.arraycopy(clientHelloHash, 0,
1485                     hashedClientHello, 4, hashLen);
1486 
1487             chc.handshakeHash.finish();     // reset the handshake hash
1488             chc.handshakeHash.deliver(hashedClientHello);
1489 
1490             int hrrBodyLen = helloRetryRequest.handshakeRecord.remaining();
1491             byte[] hrrMessage = new byte[4 + hrrBodyLen];
1492             hrrMessage[0] = SSLHandshake.HELLO_RETRY_REQUEST.id;
1493             hrrMessage[1] = (byte)((hrrBodyLen &gt;&gt; 16) &amp; 0xFF);
1494             hrrMessage[2] = (byte)((hrrBodyLen &gt;&gt; 8) &amp; 0xFF);
1495             hrrMessage[3] = (byte)(hrrBodyLen &amp; 0xFF);
1496 
1497             ByteBuffer hrrBody = helloRetryRequest.handshakeRecord.duplicate();
1498             hrrBody.get(hrrMessage, 4, hrrBodyLen);
1499 
1500             chc.handshakeHash.receive(hrrMessage);
1501 
1502             // Update the initial ClientHello handshake message.
1503             chc.initialClientHelloMsg.extensions.reproduce(chc,
1504                     new SSLExtension[] {
1505                         SSLExtension.CH_COOKIE,
1506                         SSLExtension.CH_KEY_SHARE,
1507                         SSLExtension.CH_PRE_SHARED_KEY
1508                     });
1509 
1510             //
1511             // produce response handshake message
1512             //
1513             SSLHandshake.CLIENT_HELLO.produce(context, helloRetryRequest);
1514         }
1515     }
1516 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/PreSharedKeyExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="PostHandshakeContext.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PskKeyExchangeModesExtension.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/PreSharedKeyExtension.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.security.ssl;
 26 
 27 import java.io.IOException;
 28 import java.nio.ByteBuffer;
 29 import java.security.*;
 30 import java.text.MessageFormat;
 31 import java.util.List;
 32 import java.util.ArrayList;
 33 import java.util.Locale;
 34 import java.util.Arrays;
 35 import java.util.Collection;
 36 import javax.crypto.Mac;
 37 import javax.crypto.SecretKey;
 38 import javax.net.ssl.SSLPeerUnverifiedException;

 39 import static sun.security.ssl.ClientAuthType.CLIENT_AUTH_REQUIRED;
 40 import sun.security.ssl.ClientHello.ClientHelloMessage;
 41 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 42 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 43 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 44 import sun.security.ssl.SessionTicketExtension.SessionTicketSpec;
 45 import sun.security.util.HexDumpEncoder;
 46 
 47 import static sun.security.ssl.SSLExtension.*;
 48 
 49 /**
 50  * Pack of the &quot;pre_shared_key&quot; extension.
 51  */
 52 final class PreSharedKeyExtension {
 53     static final HandshakeProducer chNetworkProducer =
 54             new CHPreSharedKeyProducer();
 55     static final ExtensionConsumer chOnLoadConsumer =
 56             new CHPreSharedKeyConsumer();
 57     static final HandshakeAbsence chOnLoadAbsence =
 58             new CHPreSharedKeyAbsence();
</pre>
<hr />
<pre>
 88             Record.putInt32(m, obfuscatedAge);
 89         }
 90 
 91         @Override
 92         public String toString() {
 93             return &quot;{&quot; + Utilities.toHexString(identity) + &quot;, &quot; +
 94                 obfuscatedAge + &quot;}&quot;;
 95         }
 96     }
 97 
 98     private static final
 99             class CHPreSharedKeySpec implements SSLExtensionSpec {
100         final List&lt;PskIdentity&gt; identities;
101         final List&lt;byte[]&gt; binders;
102 
103         CHPreSharedKeySpec(List&lt;PskIdentity&gt; identities, List&lt;byte[]&gt; binders) {
104             this.identities = identities;
105             this.binders = binders;
106         }
107 
<span class="line-modified">108         CHPreSharedKeySpec(HandshakeContext context,</span>
109                 ByteBuffer m) throws IOException {
110             // struct {
111             //     PskIdentity identities&lt;7..2^16-1&gt;;
112             //     PskBinderEntry binders&lt;33..2^16-1&gt;;
113             // } OfferedPsks;
114             if (m.remaining() &lt; 44) {
<span class="line-modified">115                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>

116                     &quot;Invalid pre_shared_key extension: &quot; +
<span class="line-modified">117                     &quot;insufficient data (length=&quot; + m.remaining() + &quot;)&quot;);</span>
118             }
119 
120             int idEncodedLength = Record.getInt16(m);
121             if (idEncodedLength &lt; 7) {
<span class="line-modified">122                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>

123                     &quot;Invalid pre_shared_key extension: &quot; +
<span class="line-modified">124                     &quot;insufficient identities (length=&quot; + idEncodedLength + &quot;)&quot;);</span>
125             }
126 
127             identities = new ArrayList&lt;&gt;();
128             int idReadLength = 0;
129             while (idReadLength &lt; idEncodedLength) {
130                 byte[] id = Record.getBytes16(m);
131                 if (id.length &lt; 1) {
<span class="line-modified">132                     throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>

133                         &quot;Invalid pre_shared_key extension: &quot; +
<span class="line-modified">134                         &quot;insufficient identity (length=&quot; + id.length + &quot;)&quot;);</span>
135                 }
136                 int obfuscatedTicketAge = Record.getInt32(m);
137 
138                 PskIdentity pskId = new PskIdentity(id, obfuscatedTicketAge);
139                 identities.add(pskId);
140                 idReadLength += pskId.getEncodedLength();
141             }
142 
143             if (m.remaining() &lt; 35) {
<span class="line-modified">144                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-modified">145                         &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">146                         &quot;insufficient binders data (length=&quot; +</span>
<span class="line-modified">147                         m.remaining() + &quot;)&quot;);</span>

148             }
149 
150             int bindersEncodedLen = Record.getInt16(m);
151             if (bindersEncodedLen &lt; 33) {
<span class="line-modified">152                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-modified">153                         &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">154                         &quot;insufficient binders (length=&quot; +</span>
<span class="line-modified">155                         bindersEncodedLen + &quot;)&quot;);</span>

156             }
157 
158             binders = new ArrayList&lt;&gt;();
159             int bindersReadLength = 0;
160             while (bindersReadLength &lt; bindersEncodedLen) {
161                 byte[] binder = Record.getBytes8(m);
162                 if (binder.length &lt; 32) {
<span class="line-modified">163                     throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-modified">164                             &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">165                             &quot;insufficient binder entry (length=&quot; +</span>
<span class="line-modified">166                             binder.length + &quot;)&quot;);</span>

167                 }
168                 binders.add(binder);
169                 bindersReadLength += 1 + binder.length;
170             }
171         }
172 
173         int getIdsEncodedLength() {
174             int idEncodedLength = 0;
175             for (PskIdentity curId : identities) {
176                 idEncodedLength += curId.getEncodedLength();
177             }
178 
179             return idEncodedLength;
180         }
181 
182         int getBindersEncodedLength() {
183             int binderEncodedLength = 0;
184             for (byte[] curBinder : binders) {
185                 binderEncodedLength += 1 + curBinder.length;
186             }
</pre>
<hr />
<pre>
234                         hexEncoder.encode(curId.identity), &quot;    &quot;) +
235                         &quot;\n  }\n&quot;);
236             }
237 
238             return result.toString();
239         }
240 
241         String bindersString() {
242             StringBuilder result = new StringBuilder();
243             for (byte[] curBinder : binders) {
244                 result.append(&quot;{&quot; + Utilities.toHexString(curBinder) + &quot;}\n&quot;);
245             }
246 
247             return result.toString();
248         }
249     }
250 
251     private static final
252             class CHPreSharedKeyStringizer implements SSLStringizer {
253         @Override
<span class="line-modified">254         public String toString(ByteBuffer buffer) {</span>
255             try {
<span class="line-modified">256                 // As the HandshakeContext parameter of CHPreSharedKeySpec</span>
<span class="line-removed">257                 // constructor is used for fatal alert only, we can use</span>
<span class="line-removed">258                 // null HandshakeContext here as we don&#39;t care about exception.</span>
<span class="line-removed">259                 //</span>
<span class="line-removed">260                 // Please take care of this code if the CHPreSharedKeySpec</span>
<span class="line-removed">261                 // constructor is updated in the future.</span>
<span class="line-removed">262                 return (new CHPreSharedKeySpec(null, buffer)).toString();</span>
263             } catch (Exception ex) {
264                 // For debug logging only, so please swallow exceptions.
265                 return ex.getMessage();
266             }
267         }
268     }
269 
270     private static final
271             class SHPreSharedKeySpec implements SSLExtensionSpec {
272         final int selectedIdentity;
273 
274         SHPreSharedKeySpec(int selectedIdentity) {
275             this.selectedIdentity = selectedIdentity;
276         }
277 
<span class="line-modified">278         SHPreSharedKeySpec(HandshakeContext context,</span>
279                 ByteBuffer m) throws IOException {
280             if (m.remaining() &lt; 2) {
<span class="line-modified">281                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-modified">282                         &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">283                         &quot;insufficient selected_identity (length=&quot; +</span>
<span class="line-modified">284                         m.remaining() + &quot;)&quot;);</span>

285             }
286             this.selectedIdentity = Record.getInt16(m);
287         }
288 
289         byte[] getEncoded() {
290             return new byte[] {
291                 (byte)((selectedIdentity &gt;&gt; 8) &amp; 0xFF),
292                 (byte)(selectedIdentity &amp; 0xFF)
293             };
294         }
295 
296         @Override
297         public String toString() {
298             MessageFormat messageFormat = new MessageFormat(
299                 &quot;\&quot;PreSharedKey\&quot;: &#39;{&#39;\n&quot; +
300                 &quot;  \&quot;selected_identity\&quot;      : \&quot;{0}\&quot;,\n&quot; +
301                 &quot;&#39;}&#39;&quot;,
302                 Locale.ENGLISH);
303 
304             Object[] messageFields = {
305                 Utilities.byte16HexString(selectedIdentity)
306             };
307 
308             return messageFormat.format(messageFields);
309         }
310     }
311 
312     private static final
313             class SHPreSharedKeyStringizer implements SSLStringizer {
314         @Override
<span class="line-modified">315         public String toString(ByteBuffer buffer) {</span>
316             try {
<span class="line-modified">317                 // As the HandshakeContext parameter of SHPreSharedKeySpec</span>
<span class="line-removed">318                 // constructor is used for fatal alert only, we can use</span>
<span class="line-removed">319                 // null HandshakeContext here as we don&#39;t care about exception.</span>
<span class="line-removed">320                 //</span>
<span class="line-removed">321                 // Please take care of this code if the SHPreSharedKeySpec</span>
<span class="line-removed">322                 // constructor is updated in the future.</span>
<span class="line-removed">323                 return (new SHPreSharedKeySpec(null, buffer)).toString();</span>
324             } catch (Exception ex) {
325                 // For debug logging only, so please swallow exceptions.
326                 return ex.getMessage();
327             }
328         }
329     }
330 
331     private static final
332             class CHPreSharedKeyConsumer implements ExtensionConsumer {
333         // Prevent instantiation of this class.
334         private CHPreSharedKeyConsumer() {
335             // blank
336         }
337 
338         @Override
339         public void consume(ConnectionContext context,
340                             HandshakeMessage message,
341                             ByteBuffer buffer) throws IOException {
342             ClientHelloMessage clientHello = (ClientHelloMessage) message;
343             ServerHandshakeContext shc = (ServerHandshakeContext)context;
344             // Is it a supported and enabled extension?
345             if (!shc.sslConfig.isAvailable(SSLExtension.CH_PRE_SHARED_KEY)) {
346                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
347                     SSLLogger.fine(
348                             &quot;Ignore unavailable pre_shared_key extension&quot;);
349                 }
350                 return;     // ignore the extension
351             }
352 
353             // Parse the extension.
<span class="line-modified">354             CHPreSharedKeySpec pskSpec = null;</span>
<span class="line-removed">355             try {</span>
<span class="line-removed">356                 pskSpec = new CHPreSharedKeySpec(shc, buffer);</span>
<span class="line-removed">357             } catch (IOException ioe) {</span>
<span class="line-removed">358                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed">359             }</span>
360 
361             // The &quot;psk_key_exchange_modes&quot; extension should have been loaded.
362             if (!shc.handshakeExtensions.containsKey(
363                     SSLExtension.PSK_KEY_EXCHANGE_MODES)) {
364                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
365                         &quot;Client sent PSK but not PSK modes, or the PSK &quot; +
366                         &quot;extension is not the last extension&quot;);
367             }
368 
369             // error if id and binder lists are not the same length
370             if (pskSpec.identities.size() != pskSpec.binders.size()) {
371                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
372                         &quot;PSK extension has incorrect number of binders&quot;);
373             }
374 
375             if (shc.isResumption) {     // resumingSession may not be set
376                 SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
377                         shc.sslContext.engineGetServerSessionContext();
378                 int idIndex = 0;
379                 SSLSessionImpl s = null;
380 
381                 for (PskIdentity requestedId : pskSpec.identities) {
382                     // If we are keeping state, see if the identity is in the cache
383                     if (requestedId.identity.length == SessionId.MAX_LENGTH) {
384                         s = sessionCache.get(requestedId.identity);
385                     }
386                     // See if the identity is a stateless ticket
387                     if (s == null &amp;&amp;
388                             requestedId.identity.length &gt; SessionId.MAX_LENGTH &amp;&amp;
389                             sessionCache.statelessEnabled()) {
390                         ByteBuffer b =
<span class="line-modified">391                                 new SessionTicketSpec(requestedId.identity).</span>
392                                         decrypt(shc);
393                         if (b != null) {
394                             try {
395                                 s = new SSLSessionImpl(shc, b);
396                             } catch (IOException | RuntimeException e) {
397                                 s = null;
398                             }
399                         }
400                         if (b == null || s == null) {
401                             if (SSLLogger.isOn &amp;&amp;
402                                     SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
403                                 SSLLogger.fine(
404                                         &quot;Stateless session ticket invalid&quot;);
405                             }
406                         }
407                     }
408 
409                     if (s != null &amp;&amp; canRejoin(clientHello, shc, s)) {
410                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
411                             SSLLogger.fine(&quot;Resuming session: &quot;, s);
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.security.ssl;
 26 
 27 import java.io.IOException;
 28 import java.nio.ByteBuffer;
 29 import java.security.*;
 30 import java.text.MessageFormat;
 31 import java.util.List;
 32 import java.util.ArrayList;
 33 import java.util.Locale;
 34 import java.util.Arrays;
 35 import java.util.Collection;
 36 import javax.crypto.Mac;
 37 import javax.crypto.SecretKey;
 38 import javax.net.ssl.SSLPeerUnverifiedException;
<span class="line-added"> 39 import javax.net.ssl.SSLProtocolException;</span>
 40 import static sun.security.ssl.ClientAuthType.CLIENT_AUTH_REQUIRED;
 41 import sun.security.ssl.ClientHello.ClientHelloMessage;
 42 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 43 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 44 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 45 import sun.security.ssl.SessionTicketExtension.SessionTicketSpec;
 46 import sun.security.util.HexDumpEncoder;
 47 
 48 import static sun.security.ssl.SSLExtension.*;
 49 
 50 /**
 51  * Pack of the &quot;pre_shared_key&quot; extension.
 52  */
 53 final class PreSharedKeyExtension {
 54     static final HandshakeProducer chNetworkProducer =
 55             new CHPreSharedKeyProducer();
 56     static final ExtensionConsumer chOnLoadConsumer =
 57             new CHPreSharedKeyConsumer();
 58     static final HandshakeAbsence chOnLoadAbsence =
 59             new CHPreSharedKeyAbsence();
</pre>
<hr />
<pre>
 89             Record.putInt32(m, obfuscatedAge);
 90         }
 91 
 92         @Override
 93         public String toString() {
 94             return &quot;{&quot; + Utilities.toHexString(identity) + &quot;, &quot; +
 95                 obfuscatedAge + &quot;}&quot;;
 96         }
 97     }
 98 
 99     private static final
100             class CHPreSharedKeySpec implements SSLExtensionSpec {
101         final List&lt;PskIdentity&gt; identities;
102         final List&lt;byte[]&gt; binders;
103 
104         CHPreSharedKeySpec(List&lt;PskIdentity&gt; identities, List&lt;byte[]&gt; binders) {
105             this.identities = identities;
106             this.binders = binders;
107         }
108 
<span class="line-modified">109         CHPreSharedKeySpec(HandshakeContext hc,</span>
110                 ByteBuffer m) throws IOException {
111             // struct {
112             //     PskIdentity identities&lt;7..2^16-1&gt;;
113             //     PskBinderEntry binders&lt;33..2^16-1&gt;;
114             // } OfferedPsks;
115             if (m.remaining() &lt; 44) {
<span class="line-modified">116                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-added">117                         new SSLProtocolException(</span>
118                     &quot;Invalid pre_shared_key extension: &quot; +
<span class="line-modified">119                     &quot;insufficient data (length=&quot; + m.remaining() + &quot;)&quot;));</span>
120             }
121 
122             int idEncodedLength = Record.getInt16(m);
123             if (idEncodedLength &lt; 7) {
<span class="line-modified">124                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-added">125                         new SSLProtocolException(</span>
126                     &quot;Invalid pre_shared_key extension: &quot; +
<span class="line-modified">127                     &quot;insufficient identities (length=&quot; + idEncodedLength + &quot;)&quot;));</span>
128             }
129 
130             identities = new ArrayList&lt;&gt;();
131             int idReadLength = 0;
132             while (idReadLength &lt; idEncodedLength) {
133                 byte[] id = Record.getBytes16(m);
134                 if (id.length &lt; 1) {
<span class="line-modified">135                     throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-added">136                             new SSLProtocolException(</span>
137                         &quot;Invalid pre_shared_key extension: &quot; +
<span class="line-modified">138                         &quot;insufficient identity (length=&quot; + id.length + &quot;)&quot;));</span>
139                 }
140                 int obfuscatedTicketAge = Record.getInt32(m);
141 
142                 PskIdentity pskId = new PskIdentity(id, obfuscatedTicketAge);
143                 identities.add(pskId);
144                 idReadLength += pskId.getEncodedLength();
145             }
146 
147             if (m.remaining() &lt; 35) {
<span class="line-modified">148                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">149                         new SSLProtocolException(</span>
<span class="line-modified">150                     &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">151                     &quot;insufficient binders data (length=&quot; +</span>
<span class="line-added">152                     m.remaining() + &quot;)&quot;));</span>
153             }
154 
155             int bindersEncodedLen = Record.getInt16(m);
156             if (bindersEncodedLen &lt; 33) {
<span class="line-modified">157                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">158                         new SSLProtocolException(</span>
<span class="line-modified">159                     &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">160                     &quot;insufficient binders (length=&quot; +</span>
<span class="line-added">161                     bindersEncodedLen + &quot;)&quot;));</span>
162             }
163 
164             binders = new ArrayList&lt;&gt;();
165             int bindersReadLength = 0;
166             while (bindersReadLength &lt; bindersEncodedLen) {
167                 byte[] binder = Record.getBytes8(m);
168                 if (binder.length &lt; 32) {
<span class="line-modified">169                     throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">170                             new SSLProtocolException(</span>
<span class="line-modified">171                         &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">172                         &quot;insufficient binder entry (length=&quot; +</span>
<span class="line-added">173                         binder.length + &quot;)&quot;));</span>
174                 }
175                 binders.add(binder);
176                 bindersReadLength += 1 + binder.length;
177             }
178         }
179 
180         int getIdsEncodedLength() {
181             int idEncodedLength = 0;
182             for (PskIdentity curId : identities) {
183                 idEncodedLength += curId.getEncodedLength();
184             }
185 
186             return idEncodedLength;
187         }
188 
189         int getBindersEncodedLength() {
190             int binderEncodedLength = 0;
191             for (byte[] curBinder : binders) {
192                 binderEncodedLength += 1 + curBinder.length;
193             }
</pre>
<hr />
<pre>
241                         hexEncoder.encode(curId.identity), &quot;    &quot;) +
242                         &quot;\n  }\n&quot;);
243             }
244 
245             return result.toString();
246         }
247 
248         String bindersString() {
249             StringBuilder result = new StringBuilder();
250             for (byte[] curBinder : binders) {
251                 result.append(&quot;{&quot; + Utilities.toHexString(curBinder) + &quot;}\n&quot;);
252             }
253 
254             return result.toString();
255         }
256     }
257 
258     private static final
259             class CHPreSharedKeyStringizer implements SSLStringizer {
260         @Override
<span class="line-modified">261         public String toString(HandshakeContext hc, ByteBuffer buffer) {</span>
262             try {
<span class="line-modified">263                 return (new CHPreSharedKeySpec(hc, buffer)).toString();</span>






264             } catch (Exception ex) {
265                 // For debug logging only, so please swallow exceptions.
266                 return ex.getMessage();
267             }
268         }
269     }
270 
271     private static final
272             class SHPreSharedKeySpec implements SSLExtensionSpec {
273         final int selectedIdentity;
274 
275         SHPreSharedKeySpec(int selectedIdentity) {
276             this.selectedIdentity = selectedIdentity;
277         }
278 
<span class="line-modified">279         SHPreSharedKeySpec(HandshakeContext hc,</span>
280                 ByteBuffer m) throws IOException {
281             if (m.remaining() &lt; 2) {
<span class="line-modified">282                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">283                         new SSLProtocolException(</span>
<span class="line-modified">284                     &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">285                     &quot;insufficient selected_identity (length=&quot; +</span>
<span class="line-added">286                     m.remaining() + &quot;)&quot;));</span>
287             }
288             this.selectedIdentity = Record.getInt16(m);
289         }
290 
291         byte[] getEncoded() {
292             return new byte[] {
293                 (byte)((selectedIdentity &gt;&gt; 8) &amp; 0xFF),
294                 (byte)(selectedIdentity &amp; 0xFF)
295             };
296         }
297 
298         @Override
299         public String toString() {
300             MessageFormat messageFormat = new MessageFormat(
301                 &quot;\&quot;PreSharedKey\&quot;: &#39;{&#39;\n&quot; +
302                 &quot;  \&quot;selected_identity\&quot;      : \&quot;{0}\&quot;,\n&quot; +
303                 &quot;&#39;}&#39;&quot;,
304                 Locale.ENGLISH);
305 
306             Object[] messageFields = {
307                 Utilities.byte16HexString(selectedIdentity)
308             };
309 
310             return messageFormat.format(messageFields);
311         }
312     }
313 
314     private static final
315             class SHPreSharedKeyStringizer implements SSLStringizer {
316         @Override
<span class="line-modified">317         public String toString(HandshakeContext hc, ByteBuffer buffer) {</span>
318             try {
<span class="line-modified">319                 return (new SHPreSharedKeySpec(hc, buffer)).toString();</span>






320             } catch (Exception ex) {
321                 // For debug logging only, so please swallow exceptions.
322                 return ex.getMessage();
323             }
324         }
325     }
326 
327     private static final
328             class CHPreSharedKeyConsumer implements ExtensionConsumer {
329         // Prevent instantiation of this class.
330         private CHPreSharedKeyConsumer() {
331             // blank
332         }
333 
334         @Override
335         public void consume(ConnectionContext context,
336                             HandshakeMessage message,
337                             ByteBuffer buffer) throws IOException {
338             ClientHelloMessage clientHello = (ClientHelloMessage) message;
339             ServerHandshakeContext shc = (ServerHandshakeContext)context;
340             // Is it a supported and enabled extension?
341             if (!shc.sslConfig.isAvailable(SSLExtension.CH_PRE_SHARED_KEY)) {
342                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
343                     SSLLogger.fine(
344                             &quot;Ignore unavailable pre_shared_key extension&quot;);
345                 }
346                 return;     // ignore the extension
347             }
348 
349             // Parse the extension.
<span class="line-modified">350             CHPreSharedKeySpec pskSpec = new CHPreSharedKeySpec(shc, buffer);</span>





351 
352             // The &quot;psk_key_exchange_modes&quot; extension should have been loaded.
353             if (!shc.handshakeExtensions.containsKey(
354                     SSLExtension.PSK_KEY_EXCHANGE_MODES)) {
355                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
356                         &quot;Client sent PSK but not PSK modes, or the PSK &quot; +
357                         &quot;extension is not the last extension&quot;);
358             }
359 
360             // error if id and binder lists are not the same length
361             if (pskSpec.identities.size() != pskSpec.binders.size()) {
362                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
363                         &quot;PSK extension has incorrect number of binders&quot;);
364             }
365 
366             if (shc.isResumption) {     // resumingSession may not be set
367                 SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
368                         shc.sslContext.engineGetServerSessionContext();
369                 int idIndex = 0;
370                 SSLSessionImpl s = null;
371 
372                 for (PskIdentity requestedId : pskSpec.identities) {
373                     // If we are keeping state, see if the identity is in the cache
374                     if (requestedId.identity.length == SessionId.MAX_LENGTH) {
375                         s = sessionCache.get(requestedId.identity);
376                     }
377                     // See if the identity is a stateless ticket
378                     if (s == null &amp;&amp;
379                             requestedId.identity.length &gt; SessionId.MAX_LENGTH &amp;&amp;
380                             sessionCache.statelessEnabled()) {
381                         ByteBuffer b =
<span class="line-modified">382                             new SessionTicketSpec(shc, requestedId.identity).</span>
383                                         decrypt(shc);
384                         if (b != null) {
385                             try {
386                                 s = new SSLSessionImpl(shc, b);
387                             } catch (IOException | RuntimeException e) {
388                                 s = null;
389                             }
390                         }
391                         if (b == null || s == null) {
392                             if (SSLLogger.isOn &amp;&amp;
393                                     SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
394                                 SSLLogger.fine(
395                                         &quot;Stateless session ticket invalid&quot;);
396                             }
397                         }
398                     }
399 
400                     if (s != null &amp;&amp; canRejoin(clientHello, shc, s)) {
401                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
402                             SSLLogger.fine(&quot;Resuming session: &quot;, s);
</pre>
</td>
</tr>
</table>
<center><a href="PostHandshakeContext.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PskKeyExchangeModesExtension.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
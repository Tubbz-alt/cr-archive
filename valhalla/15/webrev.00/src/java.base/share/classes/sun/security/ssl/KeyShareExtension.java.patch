diff a/src/java.base/share/classes/sun/security/ssl/KeyShareExtension.java b/src/java.base/share/classes/sun/security/ssl/KeyShareExtension.java
--- a/src/java.base/share/classes/sun/security/ssl/KeyShareExtension.java
+++ b/src/java.base/share/classes/sun/security/ssl/KeyShareExtension.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -135,34 +135,38 @@
 
         private CHKeyShareSpec(List<KeyShareEntry> clientShares) {
             this.clientShares = clientShares;
         }
 
-        private CHKeyShareSpec(ByteBuffer buffer) throws IOException {
+        private CHKeyShareSpec(HandshakeContext handshakeContext,
+                ByteBuffer buffer) throws IOException {
             // struct {
             //      KeyShareEntry client_shares<0..2^16-1>;
             // } KeyShareClientHello;
             if (buffer.remaining() < 2) {
-                throw new SSLProtocolException(
+                throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
+                        new SSLProtocolException(
                     "Invalid key_share extension: " +
-                    "insufficient data (length=" + buffer.remaining() + ")");
+                    "insufficient data (length=" + buffer.remaining() + ")"));
             }
 
             int listLen = Record.getInt16(buffer);
             if (listLen != buffer.remaining()) {
-                throw new SSLProtocolException(
+                throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
+                        new SSLProtocolException(
                     "Invalid key_share extension: " +
-                    "incorrect list length (length=" + listLen + ")");
+                    "incorrect list length (length=" + listLen + ")"));
             }
 
             List<KeyShareEntry> keyShares = new LinkedList<>();
             while (buffer.hasRemaining()) {
                 int namedGroupId = Record.getInt16(buffer);
                 byte[] keyExchange = Record.getBytes16(buffer);
                 if (keyExchange.length == 0) {
-                    throw new SSLProtocolException(
-                        "Invalid key_share extension: empty key_exchange");
+                    throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
+                            new SSLProtocolException(
+                        "Invalid key_share extension: empty key_exchange"));
                 }
 
                 keyShares.add(new KeyShareEntry(namedGroupId, keyExchange));
             }
 
@@ -187,13 +191,14 @@
         }
     }
 
     private static final class CHKeyShareStringizer implements SSLStringizer {
         @Override
-        public String toString(ByteBuffer buffer) {
+        public String toString(
+                HandshakeContext handshakeContext, ByteBuffer buffer) {
             try {
-                return (new CHKeyShareSpec(buffer)).toString();
+                return (new CHKeyShareSpec(handshakeContext, buffer)).toString();
             } catch (IOException ioe) {
                 // For debug logging only, so please swallow exceptions.
                 return ioe.getMessage();
             }
         }
@@ -322,17 +327,11 @@
                 }
                 return;     // ignore the extension
             }
 
             // Parse the extension
-            CHKeyShareSpec spec;
-            try {
-                spec = new CHKeyShareSpec(buffer);
-            } catch (IOException ioe) {
-                throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
-            }
-
+            CHKeyShareSpec spec = new CHKeyShareSpec(shc, buffer);
             List<SSLCredentials> credentials = new LinkedList<>();
             for (KeyShareEntry entry : spec.clientShares) {
                 NamedGroup ng = NamedGroup.valueOf(entry.namedGroupId);
                 if (ng == null || !SupportedGroups.isActivatable(
                         shc.sslConfig.algorithmConstraints, ng)) {
@@ -381,26 +380,29 @@
 
         SHKeyShareSpec(KeyShareEntry serverShare) {
             this.serverShare = serverShare;
         }
 
-        private SHKeyShareSpec(ByteBuffer buffer) throws IOException {
+        private SHKeyShareSpec(HandshakeContext handshakeContext,
+                ByteBuffer buffer) throws IOException {
             // struct {
             //      KeyShareEntry server_share;
             // } KeyShareServerHello;
             if (buffer.remaining() < 5) {       // 5: minimal server_share
-                throw new SSLProtocolException(
+                throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
+                        new SSLProtocolException(
                     "Invalid key_share extension: " +
-                    "insufficient data (length=" + buffer.remaining() + ")");
+                    "insufficient data (length=" + buffer.remaining() + ")"));
             }
 
             int namedGroupId = Record.getInt16(buffer);
             byte[] keyExchange = Record.getBytes16(buffer);
 
             if (buffer.hasRemaining()) {
-                throw new SSLProtocolException(
-                    "Invalid key_share extension: unknown extra data");
+                throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
+                        new SSLProtocolException(
+                    "Invalid key_share extension: unknown extra data"));
             }
 
             this.serverShare = new KeyShareEntry(namedGroupId, keyExchange);
         }
 
@@ -425,13 +427,14 @@
         }
     }
 
     private static final class SHKeyShareStringizer implements SSLStringizer {
         @Override
-        public String toString(ByteBuffer buffer) {
+        public String toString(HandshakeContext handshakeContext,
+                ByteBuffer buffer) {
             try {
-                return (new SHKeyShareSpec(buffer)).toString();
+                return (new SHKeyShareSpec(handshakeContext, buffer)).toString();
             } catch (IOException ioe) {
                 // For debug logging only, so please swallow exceptions.
                 return ioe.getMessage();
             }
         }
@@ -579,17 +582,11 @@
                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
                         "Unsupported key_share extension in ServerHello");
             }
 
             // Parse the extension
-            SHKeyShareSpec spec;
-            try {
-                spec = new SHKeyShareSpec(buffer);
-            } catch (IOException ioe) {
-                throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
-            }
-
+            SHKeyShareSpec spec = new SHKeyShareSpec(chc, buffer);
             KeyShareEntry keyShare = spec.serverShare;
             NamedGroup ng = NamedGroup.valueOf(keyShare.namedGroupId);
             if (ng == null || !SupportedGroups.isActivatable(
                     chc.sslConfig.algorithmConstraints, ng)) {
                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
@@ -658,18 +655,20 @@
 
         HRRKeyShareSpec(NamedGroup serverGroup) {
             this.selectedGroup = serverGroup.id;
         }
 
-        private HRRKeyShareSpec(ByteBuffer buffer) throws IOException {
+        private HRRKeyShareSpec(HandshakeContext handshakeContext,
+                ByteBuffer buffer) throws IOException {
             // struct {
             //     NamedGroup selected_group;
             // } KeyShareHelloRetryRequest;
             if (buffer.remaining() != 2) {
-                throw new SSLProtocolException(
+                throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,
+                        new SSLProtocolException(
                     "Invalid key_share extension: " +
-                    "improper data (length=" + buffer.remaining() + ")");
+                    "improper data (length=" + buffer.remaining() + ")"));
             }
 
             this.selectedGroup = Record.getInt16(buffer);
         }
 
@@ -685,13 +684,14 @@
         }
     }
 
     private static final class HRRKeyShareStringizer implements SSLStringizer {
         @Override
-        public String toString(ByteBuffer buffer) {
+        public String toString(HandshakeContext handshakeContext,
+                ByteBuffer buffer) {
             try {
-                return (new HRRKeyShareSpec(buffer)).toString();
+                return (new HRRKeyShareSpec(handshakeContext, buffer)).toString();
             } catch (IOException ioe) {
                 // For debug logging only, so please swallow exceptions.
                 return ioe.getMessage();
             }
         }
@@ -831,26 +831,20 @@
                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
                         "Unexpected key_share extension in HelloRetryRequest");
             }
 
             // Parse the extension
-            HRRKeyShareSpec spec;
-            try {
-                spec = new HRRKeyShareSpec(buffer);
-            } catch (IOException ioe) {
-                throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
-            }
-
+            HRRKeyShareSpec spec = new HRRKeyShareSpec(chc, buffer);
             NamedGroup serverGroup = NamedGroup.valueOf(spec.selectedGroup);
             if (serverGroup == null) {
-                throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
+                throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
                         "Unsupported HelloRetryRequest selected group: " +
                                 NamedGroup.nameOf(spec.selectedGroup));
             }
 
             if (!chc.clientRequestedNamedGroups.contains(serverGroup)) {
-                throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
+                throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
                         "Unexpected HelloRetryRequest selected group: " +
                                 serverGroup.name);
             }
 
             // update the context

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/ServerNameExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ServerHello.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SessionTicketExtension.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/ServerNameExtension.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 76      * See RFC 4366/6066 for the specification of the extension.
 77      */
 78     static final class CHServerNamesSpec implements SSLExtensionSpec {
 79         // For backward compatibility, all future data structures associated
 80         // with new NameTypes MUST begin with a 16-bit length field.
 81         static final int NAME_HEADER_LENGTH = 3;    //  1: NameType
 82                                                     // +2: Name length
 83         final List&lt;SNIServerName&gt; serverNames;
 84 
 85         /*
 86          * Note: For the unmodifiable collection we are creating new
 87          * collections as inputs to avoid potential deep nesting of
 88          * unmodifiable collections that can cause StackOverflowErrors
 89          * (see JDK-6323374).
 90          */
 91         private CHServerNamesSpec(List&lt;SNIServerName&gt; serverNames) {
 92             this.serverNames = Collections.&lt;SNIServerName&gt;unmodifiableList(
 93                     new ArrayList&lt;&gt;(serverNames));
 94         }
 95 
<span class="line-modified"> 96         private CHServerNamesSpec(ByteBuffer buffer) throws IOException {</span>

 97             if (buffer.remaining() &lt; 2) {
<span class="line-modified"> 98                 throw new SSLProtocolException(</span>
<span class="line-modified"> 99                     &quot;Invalid server_name extension: insufficient data&quot;);</span>

100             }
101 
102             int sniLen = Record.getInt16(buffer);
103             if ((sniLen == 0) || sniLen != buffer.remaining()) {
<span class="line-modified">104                 throw new SSLProtocolException(</span>
<span class="line-modified">105                     &quot;Invalid server_name extension: incomplete data&quot;);</span>

106             }
107 
108             Map&lt;Integer, SNIServerName&gt; sniMap = new LinkedHashMap&lt;&gt;();
109             while (buffer.hasRemaining()) {
110                 int nameType = Record.getInt8(buffer);
111                 SNIServerName serverName;
112 
113                 // HostName (length read in getBytes16);
114                 //
115                 // [RFC 6066] The data structure associated with the host_name
116                 // NameType is a variable-length vector that begins with a
117                 // 16-bit length.  For backward compatibility, all future data
118                 // structures associated with new NameTypes MUST begin with a
119                 // 16-bit length field.  TLS MAY treat provided server names as
120                 // opaque data and pass the names and types to the application.
121                 byte[] encoded = Record.getBytes16(buffer);
122                 if (nameType == StandardConstants.SNI_HOST_NAME) {
123                     if (encoded.length == 0) {
<span class="line-modified">124                         throw new SSLProtocolException(</span>
<span class="line-modified">125                             &quot;Empty HostName in server_name extension&quot;);</span>

126                     }
127 
128                     try {
129                         serverName = new SNIHostName(encoded);
130                     } catch (IllegalArgumentException iae) {
131                         SSLProtocolException spe = new SSLProtocolException(
132                             &quot;Illegal server name, type=host_name(&quot; +
133                             nameType + &quot;), name=&quot; +
134                             (new String(encoded, StandardCharsets.UTF_8)) +
135                             &quot;, value={&quot; +
136                             Utilities.toHexString(encoded) + &quot;}&quot;);
<span class="line-modified">137                         throw (SSLProtocolException)spe.initCause(iae);</span>

138                     }
139                 } else {
140                     try {
141                         serverName = new UnknownServerName(nameType, encoded);
142                     } catch (IllegalArgumentException iae) {
143                         SSLProtocolException spe = new SSLProtocolException(
144                             &quot;Illegal server name, type=(&quot; + nameType +
145                             &quot;), value={&quot; +
146                             Utilities.toHexString(encoded) + &quot;}&quot;);
<span class="line-modified">147                         throw (SSLProtocolException)spe.initCause(iae);</span>

148                     }
149                 }
150 
151                 // check for duplicated server name type
152                 if (sniMap.put(serverName.getType(), serverName) != null) {
<span class="line-modified">153                     throw new SSLProtocolException(</span>

154                             &quot;Duplicated server name of type &quot; +
<span class="line-modified">155                             serverName.getType());</span>
156                 }
157             }
158 
159             this.serverNames = new ArrayList&lt;&gt;(sniMap.values());
160         }
161 
162         @Override
163         public String toString() {
164             if (serverNames == null || serverNames.isEmpty()) {
165                 return &quot;&lt;no server name indicator specified&gt;&quot;;
166             } else {
167                 StringBuilder builder = new StringBuilder(512);
168                 for (SNIServerName sn : serverNames) {
169                     builder.append(sn.toString());
170                     builder.append(&quot;\n&quot;);
171                 }
172 
173                 return builder.toString();
174             }
175         }
176 
177         private static class UnknownServerName extends SNIServerName {
178             UnknownServerName(int code, byte[] encoded) {
179                 super(code, encoded);
180             }
181         }
182     }
183 
184     private static final class CHServerNamesStringizer implements SSLStringizer {
185         @Override
<span class="line-modified">186         public String toString(ByteBuffer buffer) {</span>
187             try {
<span class="line-modified">188                 return (new CHServerNamesSpec(buffer)).toString();</span>
189             } catch (IOException ioe) {
190                 // For debug logging only, so please swallow exceptions.
191                 return ioe.getMessage();
192             }
193         }
194     }
195 
196     /**
197      * Network data producer of a &quot;server_name&quot; extension in the
198      * ClientHello handshake message.
199      */
200     private static final
201             class CHServerNameProducer implements HandshakeProducer {
202         // Prevent instantiation of this class.
203         private CHServerNameProducer() {
204             // blank
205         }
206 
207         @Override
208         public byte[] produce(ConnectionContext context,
</pre>
<hr />
<pre>
274         private CHServerNameConsumer() {
275             // blank
276         }
277 
278         @Override
279         public void consume(ConnectionContext context,
280             HandshakeMessage message, ByteBuffer buffer) throws IOException {
281             // The consuming happens in server side only.
282             ServerHandshakeContext shc = (ServerHandshakeContext)context;
283 
284             // Is it a supported and enabled extension?
285             if (!shc.sslConfig.isAvailable(CH_SERVER_NAME)) {
286                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
287                     SSLLogger.fine(
288                         &quot;Ignore unavailable extension: &quot; + CH_SERVER_NAME.name);
289                 }
290                 return;     // ignore the extension
291             }
292 
293             // Parse the extension.
<span class="line-modified">294             CHServerNamesSpec spec;</span>
<span class="line-removed">295             try {</span>
<span class="line-removed">296                 spec = new CHServerNamesSpec(buffer);</span>
<span class="line-removed">297             } catch (IOException ioe) {</span>
<span class="line-removed">298                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed">299             }</span>
300 
301             // Update the context.
302             shc.handshakeExtensions.put(CH_SERVER_NAME, spec);
303 
304             // Does the server match the server name request?
305             SNIServerName sni = null;
306             if (!shc.sslConfig.sniMatchers.isEmpty()) {
307                 sni = chooseSni(shc.sslConfig.sniMatchers, spec.serverNames);
308                 if (sni != null) {
309                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
310                         SSLLogger.fine(
311                                 &quot;server name indication (&quot; +
312                                 sni + &quot;) is accepted&quot;);
313                     }
314                 } else {
315                     // We do not reject client without SNI extension currently.
316                     throw shc.conContext.fatal(Alert.UNRECOGNIZED_NAME,
317                             &quot;Unrecognized server name indication&quot;);
318                 }
319             } else {
</pre>
<hr />
<pre>
373                     }
374                 }
375             }
376 
377             return null;
378         }
379     }
380 
381     /**
382      * The &quot;server_name&quot; extension in the ServerHello handshake message.
383      *
384      * The &quot;extension_data&quot; field of this extension shall be empty.
385      */
386     static final class SHServerNamesSpec implements SSLExtensionSpec {
387         static final SHServerNamesSpec DEFAULT = new SHServerNamesSpec();
388 
389         private SHServerNamesSpec() {
390             // blank
391         }
392 
<span class="line-modified">393         private SHServerNamesSpec(ByteBuffer buffer) throws IOException {</span>

394             if (buffer.remaining() != 0) {
<span class="line-modified">395                 throw new SSLProtocolException(</span>
<span class="line-modified">396                     &quot;Invalid ServerHello server_name extension: not empty&quot;);</span>

397             }
398         }
399 
400         @Override
401         public String toString() {
402             return &quot;&lt;empty extension_data field&gt;&quot;;
403         }
404     }
405 
406     private static final class SHServerNamesStringizer implements SSLStringizer {
407         @Override
<span class="line-modified">408         public String toString(ByteBuffer buffer) {</span>
409             try {
<span class="line-modified">410                 return (new SHServerNamesSpec(buffer)).toString();</span>
411             } catch (IOException ioe) {
412                 // For debug logging only, so please swallow exceptions.
413                 return ioe.getMessage();
414             }
415         }
416     }
417 
418     /**
419      * Network data producer of a &quot;server_name&quot; extension in the
420      * ServerHello handshake message.
421      */
422     private static final
423             class SHServerNameProducer implements HandshakeProducer {
424         // Prevent instantiation of this class.
425         private SHServerNameProducer() {
426             // blank
427         }
428 
429         @Override
430         public byte[] produce(ConnectionContext context,
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 76      * See RFC 4366/6066 for the specification of the extension.
 77      */
 78     static final class CHServerNamesSpec implements SSLExtensionSpec {
 79         // For backward compatibility, all future data structures associated
 80         // with new NameTypes MUST begin with a 16-bit length field.
 81         static final int NAME_HEADER_LENGTH = 3;    //  1: NameType
 82                                                     // +2: Name length
 83         final List&lt;SNIServerName&gt; serverNames;
 84 
 85         /*
 86          * Note: For the unmodifiable collection we are creating new
 87          * collections as inputs to avoid potential deep nesting of
 88          * unmodifiable collections that can cause StackOverflowErrors
 89          * (see JDK-6323374).
 90          */
 91         private CHServerNamesSpec(List&lt;SNIServerName&gt; serverNames) {
 92             this.serverNames = Collections.&lt;SNIServerName&gt;unmodifiableList(
 93                     new ArrayList&lt;&gt;(serverNames));
 94         }
 95 
<span class="line-modified"> 96         private CHServerNamesSpec(HandshakeContext hc,</span>
<span class="line-added"> 97                 ByteBuffer buffer) throws IOException {</span>
 98             if (buffer.remaining() &lt; 2) {
<span class="line-modified"> 99                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">100                         new SSLProtocolException(</span>
<span class="line-added">101                     &quot;Invalid server_name extension: insufficient data&quot;));</span>
102             }
103 
104             int sniLen = Record.getInt16(buffer);
105             if ((sniLen == 0) || sniLen != buffer.remaining()) {
<span class="line-modified">106                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">107                         new SSLProtocolException(</span>
<span class="line-added">108                     &quot;Invalid server_name extension: incomplete data&quot;));</span>
109             }
110 
111             Map&lt;Integer, SNIServerName&gt; sniMap = new LinkedHashMap&lt;&gt;();
112             while (buffer.hasRemaining()) {
113                 int nameType = Record.getInt8(buffer);
114                 SNIServerName serverName;
115 
116                 // HostName (length read in getBytes16);
117                 //
118                 // [RFC 6066] The data structure associated with the host_name
119                 // NameType is a variable-length vector that begins with a
120                 // 16-bit length.  For backward compatibility, all future data
121                 // structures associated with new NameTypes MUST begin with a
122                 // 16-bit length field.  TLS MAY treat provided server names as
123                 // opaque data and pass the names and types to the application.
124                 byte[] encoded = Record.getBytes16(buffer);
125                 if (nameType == StandardConstants.SNI_HOST_NAME) {
126                     if (encoded.length == 0) {
<span class="line-modified">127                         throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">128                                 new SSLProtocolException(</span>
<span class="line-added">129                             &quot;Empty HostName in server_name extension&quot;));</span>
130                     }
131 
132                     try {
133                         serverName = new SNIHostName(encoded);
134                     } catch (IllegalArgumentException iae) {
135                         SSLProtocolException spe = new SSLProtocolException(
136                             &quot;Illegal server name, type=host_name(&quot; +
137                             nameType + &quot;), name=&quot; +
138                             (new String(encoded, StandardCharsets.UTF_8)) +
139                             &quot;, value={&quot; +
140                             Utilities.toHexString(encoded) + &quot;}&quot;);
<span class="line-modified">141                         throw hc.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-added">142                                 (SSLProtocolException)spe.initCause(iae));</span>
143                     }
144                 } else {
145                     try {
146                         serverName = new UnknownServerName(nameType, encoded);
147                     } catch (IllegalArgumentException iae) {
148                         SSLProtocolException spe = new SSLProtocolException(
149                             &quot;Illegal server name, type=(&quot; + nameType +
150                             &quot;), value={&quot; +
151                             Utilities.toHexString(encoded) + &quot;}&quot;);
<span class="line-modified">152                         throw hc.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-added">153                                 (SSLProtocolException)spe.initCause(iae));</span>
154                     }
155                 }
156 
157                 // check for duplicated server name type
158                 if (sniMap.put(serverName.getType(), serverName) != null) {
<span class="line-modified">159                         throw hc.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-added">160                                 new SSLProtocolException(</span>
161                             &quot;Duplicated server name of type &quot; +
<span class="line-modified">162                             serverName.getType()));</span>
163                 }
164             }
165 
166             this.serverNames = new ArrayList&lt;&gt;(sniMap.values());
167         }
168 
169         @Override
170         public String toString() {
171             if (serverNames == null || serverNames.isEmpty()) {
172                 return &quot;&lt;no server name indicator specified&gt;&quot;;
173             } else {
174                 StringBuilder builder = new StringBuilder(512);
175                 for (SNIServerName sn : serverNames) {
176                     builder.append(sn.toString());
177                     builder.append(&quot;\n&quot;);
178                 }
179 
180                 return builder.toString();
181             }
182         }
183 
184         private static class UnknownServerName extends SNIServerName {
185             UnknownServerName(int code, byte[] encoded) {
186                 super(code, encoded);
187             }
188         }
189     }
190 
191     private static final class CHServerNamesStringizer implements SSLStringizer {
192         @Override
<span class="line-modified">193         public String toString(HandshakeContext hc, ByteBuffer buffer) {</span>
194             try {
<span class="line-modified">195                 return (new CHServerNamesSpec(hc, buffer)).toString();</span>
196             } catch (IOException ioe) {
197                 // For debug logging only, so please swallow exceptions.
198                 return ioe.getMessage();
199             }
200         }
201     }
202 
203     /**
204      * Network data producer of a &quot;server_name&quot; extension in the
205      * ClientHello handshake message.
206      */
207     private static final
208             class CHServerNameProducer implements HandshakeProducer {
209         // Prevent instantiation of this class.
210         private CHServerNameProducer() {
211             // blank
212         }
213 
214         @Override
215         public byte[] produce(ConnectionContext context,
</pre>
<hr />
<pre>
281         private CHServerNameConsumer() {
282             // blank
283         }
284 
285         @Override
286         public void consume(ConnectionContext context,
287             HandshakeMessage message, ByteBuffer buffer) throws IOException {
288             // The consuming happens in server side only.
289             ServerHandshakeContext shc = (ServerHandshakeContext)context;
290 
291             // Is it a supported and enabled extension?
292             if (!shc.sslConfig.isAvailable(CH_SERVER_NAME)) {
293                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
294                     SSLLogger.fine(
295                         &quot;Ignore unavailable extension: &quot; + CH_SERVER_NAME.name);
296                 }
297                 return;     // ignore the extension
298             }
299 
300             // Parse the extension.
<span class="line-modified">301             CHServerNamesSpec spec = new CHServerNamesSpec(shc, buffer);</span>





302 
303             // Update the context.
304             shc.handshakeExtensions.put(CH_SERVER_NAME, spec);
305 
306             // Does the server match the server name request?
307             SNIServerName sni = null;
308             if (!shc.sslConfig.sniMatchers.isEmpty()) {
309                 sni = chooseSni(shc.sslConfig.sniMatchers, spec.serverNames);
310                 if (sni != null) {
311                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
312                         SSLLogger.fine(
313                                 &quot;server name indication (&quot; +
314                                 sni + &quot;) is accepted&quot;);
315                     }
316                 } else {
317                     // We do not reject client without SNI extension currently.
318                     throw shc.conContext.fatal(Alert.UNRECOGNIZED_NAME,
319                             &quot;Unrecognized server name indication&quot;);
320                 }
321             } else {
</pre>
<hr />
<pre>
375                     }
376                 }
377             }
378 
379             return null;
380         }
381     }
382 
383     /**
384      * The &quot;server_name&quot; extension in the ServerHello handshake message.
385      *
386      * The &quot;extension_data&quot; field of this extension shall be empty.
387      */
388     static final class SHServerNamesSpec implements SSLExtensionSpec {
389         static final SHServerNamesSpec DEFAULT = new SHServerNamesSpec();
390 
391         private SHServerNamesSpec() {
392             // blank
393         }
394 
<span class="line-modified">395         private SHServerNamesSpec(HandshakeContext hc,</span>
<span class="line-added">396                 ByteBuffer buffer) throws IOException {</span>
397             if (buffer.remaining() != 0) {
<span class="line-modified">398                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">399                         new SSLProtocolException(</span>
<span class="line-added">400                     &quot;Invalid ServerHello server_name extension: not empty&quot;));</span>
401             }
402         }
403 
404         @Override
405         public String toString() {
406             return &quot;&lt;empty extension_data field&gt;&quot;;
407         }
408     }
409 
410     private static final class SHServerNamesStringizer implements SSLStringizer {
411         @Override
<span class="line-modified">412         public String toString(HandshakeContext hc, ByteBuffer buffer) {</span>
413             try {
<span class="line-modified">414                 return (new SHServerNamesSpec(hc, buffer)).toString();</span>
415             } catch (IOException ioe) {
416                 // For debug logging only, so please swallow exceptions.
417                 return ioe.getMessage();
418             }
419         }
420     }
421 
422     /**
423      * Network data producer of a &quot;server_name&quot; extension in the
424      * ServerHello handshake message.
425      */
426     private static final
427             class SHServerNameProducer implements HandshakeProducer {
428         // Prevent instantiation of this class.
429         private SHServerNameProducer() {
430             // blank
431         }
432 
433         @Override
434         public byte[] produce(ConnectionContext context,
</pre>
</td>
</tr>
</table>
<center><a href="ServerHello.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SessionTicketExtension.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
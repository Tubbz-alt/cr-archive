<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.zipfs/share/classes/jdk/nio/zipfs/ZipFileSystem.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../jdk.jshell/share/classes/jdk/jshell/SourceCodeAnalysisImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/failure_handler/src/share/conf/linux.properties.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.zipfs/share/classes/jdk/nio/zipfs/ZipFileSystem.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1701                     is.transferTo(os);
1702                 }
1703             }
1704             Files.delete(e.file);
1705             tmppaths.remove(e.file);
1706         }
1707     }
1708 
1709     // sync the zip file system, if there is any update
1710     private void sync() throws IOException {
1711         if (!hasUpdate)
1712             return;
1713         PosixFileAttributes attrs = getPosixAttributes(zfpath);
1714         Path tmpFile = createTempFileInSameDirectoryAs(zfpath);
1715         try (OutputStream os = new BufferedOutputStream(Files.newOutputStream(tmpFile, WRITE))) {
1716             ArrayList&lt;Entry&gt; elist = new ArrayList&lt;&gt;(inodes.size());
1717             long written = 0;
1718             byte[] buf = null;
1719             Entry e;
1720 





1721             // write loc
<span class="line-modified">1722             for (IndexNode inode : inodes.values()) {</span>




















1723                 if (inode instanceof Entry) {    // an updated inode
1724                     e = (Entry)inode;
1725                     try {
1726                         if (e.type == Entry.COPY) {
1727                             // entry copy: the only thing changed is the &quot;name&quot;
1728                             // and &quot;nlen&quot; in LOC header, so we update/rewrite the
1729                             // LOC in new file and simply copy the rest (data and
1730                             // ext) without enflating/deflating from the old zip
1731                             // file LOC entry.
1732                             if (buf == null)
1733                                 buf = new byte[8192];
1734                             written += copyLOCEntry(e, true, os, written, buf);
1735                         } else {                          // NEW, FILECH or CEN
1736                             e.locoff = written;
1737                             written += e.writeLOC(os);    // write loc header
1738                             written += writeEntry(e, os);
1739                         }
1740                         elist.add(e);
1741                     } catch (IOException x) {
1742                         x.printStackTrace();    // skip any in-accurate entry
</pre>
</td>
<td>
<hr />
<pre>
1701                     is.transferTo(os);
1702                 }
1703             }
1704             Files.delete(e.file);
1705             tmppaths.remove(e.file);
1706         }
1707     }
1708 
1709     // sync the zip file system, if there is any update
1710     private void sync() throws IOException {
1711         if (!hasUpdate)
1712             return;
1713         PosixFileAttributes attrs = getPosixAttributes(zfpath);
1714         Path tmpFile = createTempFileInSameDirectoryAs(zfpath);
1715         try (OutputStream os = new BufferedOutputStream(Files.newOutputStream(tmpFile, WRITE))) {
1716             ArrayList&lt;Entry&gt; elist = new ArrayList&lt;&gt;(inodes.size());
1717             long written = 0;
1718             byte[] buf = null;
1719             Entry e;
1720 
<span class="line-added">1721             final IndexNode manifestInode = inodes.get(</span>
<span class="line-added">1722                     IndexNode.keyOf(getBytes(&quot;/META-INF/MANIFEST.MF&quot;)));</span>
<span class="line-added">1723             final Iterator&lt;IndexNode&gt; inodeIterator = inodes.values().iterator();</span>
<span class="line-added">1724             boolean manifestProcessed = false;</span>
<span class="line-added">1725 </span>
1726             // write loc
<span class="line-modified">1727             while (inodeIterator.hasNext()) {</span>
<span class="line-added">1728                 final IndexNode inode;</span>
<span class="line-added">1729 </span>
<span class="line-added">1730                 // write the manifest inode (if any) first so that</span>
<span class="line-added">1731                 // java.util.jar.JarInputStream can find it</span>
<span class="line-added">1732                 if (manifestInode == null) {</span>
<span class="line-added">1733                     inode = inodeIterator.next();</span>
<span class="line-added">1734                 } else {</span>
<span class="line-added">1735                     if (manifestProcessed) {</span>
<span class="line-added">1736                         // advance to next node, filtering out the manifest</span>
<span class="line-added">1737                         // which was already written</span>
<span class="line-added">1738                         inode = inodeIterator.next();</span>
<span class="line-added">1739                         if (inode == manifestInode) {</span>
<span class="line-added">1740                             continue;</span>
<span class="line-added">1741                         }</span>
<span class="line-added">1742                     } else {</span>
<span class="line-added">1743                         inode = manifestInode;</span>
<span class="line-added">1744                         manifestProcessed = true;</span>
<span class="line-added">1745                     }</span>
<span class="line-added">1746                 }</span>
<span class="line-added">1747 </span>
1748                 if (inode instanceof Entry) {    // an updated inode
1749                     e = (Entry)inode;
1750                     try {
1751                         if (e.type == Entry.COPY) {
1752                             // entry copy: the only thing changed is the &quot;name&quot;
1753                             // and &quot;nlen&quot; in LOC header, so we update/rewrite the
1754                             // LOC in new file and simply copy the rest (data and
1755                             // ext) without enflating/deflating from the old zip
1756                             // file LOC entry.
1757                             if (buf == null)
1758                                 buf = new byte[8192];
1759                             written += copyLOCEntry(e, true, os, written, buf);
1760                         } else {                          // NEW, FILECH or CEN
1761                             e.locoff = written;
1762                             written += e.writeLOC(os);    // write loc header
1763                             written += writeEntry(e, os);
1764                         }
1765                         elist.add(e);
1766                     } catch (IOException x) {
1767                         x.printStackTrace();    // skip any in-accurate entry
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../jdk.jshell/share/classes/jdk/jshell/SourceCodeAnalysisImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../test/failure_handler/src/share/conf/linux.properties.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
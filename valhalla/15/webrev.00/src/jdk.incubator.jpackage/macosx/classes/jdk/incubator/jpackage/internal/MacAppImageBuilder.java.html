<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacAppImageBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.incubator.jpackage.internal;
 27 
 28 import java.io.File;
 29 import java.io.FileInputStream;
 30 import java.io.IOException;
 31 import java.io.InputStream;
 32 import java.io.Writer;
 33 import java.math.BigInteger;
 34 import java.nio.file.Files;
 35 import java.nio.file.Path;
 36 import java.nio.file.StandardCopyOption;
 37 import java.nio.file.attribute.PosixFilePermission;
 38 import java.text.MessageFormat;
 39 import java.util.ArrayList;
 40 import java.util.Arrays;
 41 import java.util.EnumSet;
 42 import java.util.HashMap;
 43 import java.util.List;
 44 import java.util.Map;
 45 import java.util.Objects;
 46 import java.util.Optional;
 47 import java.util.ResourceBundle;
 48 import java.util.Set;
 49 import java.util.concurrent.atomic.AtomicReference;
 50 import java.util.function.Consumer;
 51 import java.util.stream.Stream;
 52 import javax.xml.parsers.DocumentBuilder;
 53 import javax.xml.parsers.DocumentBuilderFactory;
 54 import javax.xml.xpath.XPath;
 55 import javax.xml.xpath.XPathConstants;
 56 import javax.xml.xpath.XPathFactory;
 57 
 58 import static jdk.incubator.jpackage.internal.StandardBundlerParam.*;
 59 import static jdk.incubator.jpackage.internal.MacBaseInstallerBundler.*;
 60 import static jdk.incubator.jpackage.internal.MacAppBundler.*;
 61 import static jdk.incubator.jpackage.internal.OverridableResource.createResource;
 62 
 63 public class MacAppImageBuilder extends AbstractAppImageBuilder {
 64 
 65     private static final ResourceBundle I18N = ResourceBundle.getBundle(
 66             &quot;jdk.incubator.jpackage.internal.resources.MacResources&quot;);
 67 
 68     private static final String LIBRARY_NAME = &quot;libapplauncher.dylib&quot;;
 69     private static final String TEMPLATE_BUNDLE_ICON = &quot;java.icns&quot;;
 70     private static final String OS_TYPE_CODE = &quot;APPL&quot;;
 71     private static final String TEMPLATE_INFO_PLIST_LITE =
 72             &quot;Info-lite.plist.template&quot;;
 73     private static final String TEMPLATE_RUNTIME_INFO_PLIST =
 74             &quot;Runtime-Info.plist.template&quot;;
 75 
 76     private final Path root;
 77     private final Path contentsDir;
 78     private final Path appDir;
 79     private final Path javaModsDir;
 80     private final Path resourcesDir;
 81     private final Path macOSDir;
 82     private final Path runtimeDir;
 83     private final Path runtimeRoot;
 84     private final Path mdir;
 85 
 86     private static List&lt;String&gt; keyChains;
 87 
 88     public static final BundlerParamInfo&lt;Boolean&gt;
 89             MAC_CONFIGURE_LAUNCHER_IN_PLIST = new StandardBundlerParam&lt;&gt;(
 90                     &quot;mac.configure-launcher-in-plist&quot;,
 91                     Boolean.class,
 92                     params -&gt; Boolean.FALSE,
 93                     (s, p) -&gt; Boolean.valueOf(s));
 94 
 95     public static final BundlerParamInfo&lt;String&gt; MAC_CF_BUNDLE_NAME =
 96             new StandardBundlerParam&lt;&gt;(
 97                     Arguments.CLIOptions.MAC_BUNDLE_NAME.getId(),
 98                     String.class,
 99                     params -&gt; null,
100                     (s, p) -&gt; s);
101 
102     public static final BundlerParamInfo&lt;String&gt; MAC_CF_BUNDLE_IDENTIFIER =
103             new StandardBundlerParam&lt;&gt;(
104                     Arguments.CLIOptions.MAC_BUNDLE_IDENTIFIER.getId(),
105                     String.class,
106                     params -&gt; {
107                         // Get identifier from app image if user provided
108                         // app image and did not provide the identifier via CLI.
109                         String identifier = extractBundleIdentifier(params);
110                         if (identifier != null) {
111                             return identifier;
112                         }
113 
114                         identifier = IDENTIFIER.fetchFrom(params);
115                         if (identifier != null) {
116                             return identifier;
117                         }
118                         // the IDENTIFIER (above) will default to derive from
119                         // the main-class, in case there is no main-class
120                         // (such as runtime installer) revert to the name.
121                         // any of these could be invalid, so check later.
122                         return APP_NAME.fetchFrom(params);
123                     },
124                     (s, p) -&gt; s);
125 
126     public static final BundlerParamInfo&lt;String&gt; MAC_CF_BUNDLE_VERSION =
127             new StandardBundlerParam&lt;&gt;(
128                     &quot;mac.CFBundleVersion&quot;,
129                     String.class,
130                     p -&gt; {
131                         String s = VERSION.fetchFrom(p);
132                         if (validCFBundleVersion(s)) {
133                             return s;
134                         } else {
135                             return &quot;100&quot;;
136                         }
137                     },
138                     (s, p) -&gt; s);
139 
140     public static final BundlerParamInfo&lt;File&gt; ICON_ICNS =
141             new StandardBundlerParam&lt;&gt;(
142             &quot;icon.icns&quot;,
143             File.class,
144             params -&gt; {
145                 File f = ICON.fetchFrom(params);
146                 if (f != null &amp;&amp; !f.getName().toLowerCase().endsWith(&quot;.icns&quot;)) {
147                     Log.error(MessageFormat.format(
148                             I18N.getString(&quot;message.icon-not-icns&quot;), f));
149                     return null;
150                 }
151                 return f;
152             },
153             (s, p) -&gt; new File(s));
154 
155     public static final StandardBundlerParam&lt;Boolean&gt; SIGN_BUNDLE  =
156             new StandardBundlerParam&lt;&gt;(
157             Arguments.CLIOptions.MAC_SIGN.getId(),
158             Boolean.class,
159             params -&gt; false,
160             // valueOf(null) is false, we actually do want null in some cases
161             (s, p) -&gt; (s == null || &quot;null&quot;.equalsIgnoreCase(s)) ?
162                     null : Boolean.valueOf(s)
163         );
164 
165     public MacAppImageBuilder(Map&lt;String, Object&gt; params, Path imageOutDir)
166             throws IOException {
167         super(params, imageOutDir.resolve(APP_NAME.fetchFrom(params)
168                 + &quot;.app/Contents/runtime/Contents/Home&quot;));
169 
170         Objects.requireNonNull(imageOutDir);
171 
172         this.root = imageOutDir.resolve(APP_NAME.fetchFrom(params) + &quot;.app&quot;);
173         this.contentsDir = root.resolve(&quot;Contents&quot;);
174         this.appDir = contentsDir.resolve(&quot;app&quot;);
175         this.javaModsDir = appDir.resolve(&quot;mods&quot;);
176         this.resourcesDir = contentsDir.resolve(&quot;Resources&quot;);
177         this.macOSDir = contentsDir.resolve(&quot;MacOS&quot;);
178         this.runtimeDir = contentsDir.resolve(&quot;runtime&quot;);
179         this.runtimeRoot = runtimeDir.resolve(&quot;Contents/Home&quot;);
180         this.mdir = runtimeRoot.resolve(&quot;lib&quot;);
181         Files.createDirectories(appDir);
182         Files.createDirectories(resourcesDir);
183         Files.createDirectories(macOSDir);
184         Files.createDirectories(runtimeDir);
185     }
186 
187     private void writeEntry(InputStream in, Path dstFile) throws IOException {
188         Files.createDirectories(dstFile.getParent());
189         Files.copy(in, dstFile);
190     }
191 
192     public static boolean validCFBundleVersion(String v) {
193         // CFBundleVersion (String - iOS, OS X) specifies the build version
194         // number of the bundle, which identifies an iteration (released or
195         // unreleased) of the bundle. The build version number should be a
196         // string comprised of three non-negative, period-separated integers
197         // with the first integer being greater than zero. The string should
198         // only contain numeric (0-9) and period (.) characters. Leading zeros
199         // are truncated from each integer and will be ignored (that is,
200         // 1.02.3 is equivalent to 1.2.3). This key is not localizable.
201 
202         if (v == null) {
203             return false;
204         }
205 
206         String p[] = v.split(&quot;\\.&quot;);
207         if (p.length &gt; 3 || p.length &lt; 1) {
208             Log.verbose(I18N.getString(
209                     &quot;message.version-string-too-many-components&quot;));
210             return false;
211         }
212 
213         try {
214             BigInteger n = new BigInteger(p[0]);
215             if (BigInteger.ONE.compareTo(n) &gt; 0) {
216                 Log.verbose(I18N.getString(
217                         &quot;message.version-string-first-number-not-zero&quot;));
218                 return false;
219             }
220             if (p.length &gt; 1) {
221                 n = new BigInteger(p[1]);
222                 if (BigInteger.ZERO.compareTo(n) &gt; 0) {
223                     Log.verbose(I18N.getString(
224                             &quot;message.version-string-no-negative-numbers&quot;));
225                     return false;
226                 }
227             }
228             if (p.length &gt; 2) {
229                 n = new BigInteger(p[2]);
230                 if (BigInteger.ZERO.compareTo(n) &gt; 0) {
231                     Log.verbose(I18N.getString(
232                             &quot;message.version-string-no-negative-numbers&quot;));
233                     return false;
234                 }
235             }
236         } catch (NumberFormatException ne) {
237             Log.verbose(I18N.getString(&quot;message.version-string-numbers-only&quot;));
238             Log.verbose(ne);
239             return false;
240         }
241 
242         return true;
243     }
244 
245     @Override
246     public Path getAppDir() {
247         return appDir;
248     }
249 
250     @Override
251     public Path getAppModsDir() {
252         return javaModsDir;
253     }
254 
255     @Override
256     public void prepareApplicationFiles(Map&lt;String, ? super Object&gt; params)
257             throws IOException {
258         Map&lt;String, ? super Object&gt; originalParams = new HashMap&lt;&gt;(params);
259         // Generate PkgInfo
260         File pkgInfoFile = new File(contentsDir.toFile(), &quot;PkgInfo&quot;);
261         pkgInfoFile.createNewFile();
262         writePkgInfo(pkgInfoFile);
263 
264         Path executable = macOSDir.resolve(getLauncherName(params));
265 
266         // create the main app launcher
267         try (InputStream is_launcher =
268                 getResourceAsStream(&quot;jpackageapplauncher&quot;);
269             InputStream is_lib = getResourceAsStream(LIBRARY_NAME)) {
270             // Copy executable and library to MacOS folder
271             writeEntry(is_launcher, executable);
272             writeEntry(is_lib, macOSDir.resolve(LIBRARY_NAME));
273         }
274         executable.toFile().setExecutable(true, false);
275         // generate main app launcher config file
276         File cfg = new File(root.toFile(), getLauncherCfgName(params));
277         writeCfgFile(params, cfg);
278 
279         // create additional app launcher(s) and config file(s)
280         List&lt;Map&lt;String, ? super Object&gt;&gt; entryPoints =
281                 StandardBundlerParam.ADD_LAUNCHERS.fetchFrom(params);
282         for (Map&lt;String, ? super Object&gt; entryPoint : entryPoints) {
283             Map&lt;String, ? super Object&gt; tmp =
284                     AddLauncherArguments.merge(originalParams, entryPoint);
285 
286             // add executable for add launcher
287             Path addExecutable = macOSDir.resolve(getLauncherName(tmp));
288             try (InputStream is = getResourceAsStream(&quot;jpackageapplauncher&quot;);) {
289                 writeEntry(is, addExecutable);
290             }
291             addExecutable.toFile().setExecutable(true, false);
292 
293             // add config file for add launcher
294             cfg = new File(root.toFile(), getLauncherCfgName(tmp));
295             writeCfgFile(tmp, cfg);
296         }
297 
298         // Copy class path entries to Java folder
299         copyClassPathEntries(appDir, params);
300 
301         /*********** Take care of &quot;config&quot; files *******/
302 
303         createResource(TEMPLATE_BUNDLE_ICON, params)
304                 .setCategory(&quot;icon&quot;)
305                 .setExternal(ICON_ICNS.fetchFrom(params))
306                 .saveToFile(resourcesDir.resolve(APP_NAME.fetchFrom(params)
307                         + &quot;.icns&quot;));
308 
309         // copy file association icons
310         for (Map&lt;String, ?
311                 super Object&gt; fa : FILE_ASSOCIATIONS.fetchFrom(params)) {
312             File f = FA_ICON.fetchFrom(fa);
313             if (f != null &amp;&amp; f.exists()) {
314                 try (InputStream in2 = new FileInputStream(f)) {
315                     Files.copy(in2, resourcesDir.resolve(f.getName()));
316                 }
317 
318             }
319         }
320 
321         copyRuntimeFiles(params);
322         sign(params);
323     }
324 
325     @Override
326     public void prepareJreFiles(Map&lt;String, ? super Object&gt; params)
327             throws IOException {
328         copyRuntimeFiles(params);
329         sign(params);
330     }
331 
332     @Override
333     File getRuntimeImageDir(File runtimeImageTop) {
334         File home = new File(runtimeImageTop, &quot;Contents/Home&quot;);
335         return (home.exists() ? home : runtimeImageTop);
336     }
337 
338     private void copyRuntimeFiles(Map&lt;String, ? super Object&gt; params)
339             throws IOException {
340         // Generate Info.plist
341         writeInfoPlist(contentsDir.resolve(&quot;Info.plist&quot;).toFile(), params);
342 
343         // generate java runtime info.plist
344         writeRuntimeInfoPlist(
345                 runtimeDir.resolve(&quot;Contents/Info.plist&quot;).toFile(), params);
346 
347         // copy library
348         Path runtimeMacOSDir = Files.createDirectories(
349                 runtimeDir.resolve(&quot;Contents/MacOS&quot;));
350 
351         // JDK 9, 10, and 11 have extra &#39;/jli/&#39; subdir
352         Path jli = runtimeRoot.resolve(&quot;lib/libjli.dylib&quot;);
353         if (!Files.exists(jli)) {
354             jli = runtimeRoot.resolve(&quot;lib/jli/libjli.dylib&quot;);
355         }
356 
357         Files.copy(jli, runtimeMacOSDir.resolve(&quot;libjli.dylib&quot;));
358     }
359 
360     private void sign(Map&lt;String, ? super Object&gt; params) throws IOException {
361         if (Optional.ofNullable(
362                 SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.TRUE)) {
363             try {
364                 addNewKeychain(params);
365             } catch (InterruptedException e) {
366                 Log.error(e.getMessage());
367             }
368             String signingIdentity =
369                     DEVELOPER_ID_APP_SIGNING_KEY.fetchFrom(params);
370             if (signingIdentity != null) {
371                 signAppBundle(params, root, signingIdentity,
372                         BUNDLE_ID_SIGNING_PREFIX.fetchFrom(params), null, null);
373             }
374             restoreKeychainList(params);
375         }
376     }
377 
378     private String getLauncherName(Map&lt;String, ? super Object&gt; params) {
379         if (APP_NAME.fetchFrom(params) != null) {
380             return APP_NAME.fetchFrom(params);
381         } else {
382             return MAIN_CLASS.fetchFrom(params);
383         }
384     }
385 
386     public static String getLauncherCfgName(
387             Map&lt;String, ? super Object&gt; params) {
388         return &quot;Contents/app/&quot; + APP_NAME.fetchFrom(params) + &quot;.cfg&quot;;
389     }
390 
391     private void copyClassPathEntries(Path javaDirectory,
392             Map&lt;String, ? super Object&gt; params) throws IOException {
393         List&lt;RelativeFileSet&gt; resourcesList =
394                 APP_RESOURCES_LIST.fetchFrom(params);
395         if (resourcesList == null) {
396             throw new RuntimeException(
397                     I18N.getString(&quot;message.null-classpath&quot;));
398         }
399 
400         for (RelativeFileSet classPath : resourcesList) {
401             File srcdir = classPath.getBaseDirectory();
402             for (String fname : classPath.getIncludedFiles()) {
403                 copyEntry(javaDirectory, srcdir, fname);
404             }
405         }
406     }
407 
408     private String getBundleName(Map&lt;String, ? super Object&gt; params) {
409         if (MAC_CF_BUNDLE_NAME.fetchFrom(params) != null) {
410             String bn = MAC_CF_BUNDLE_NAME.fetchFrom(params);
411             if (bn.length() &gt; 16) {
412                 Log.error(MessageFormat.format(I18N.getString(
413                         &quot;message.bundle-name-too-long-warning&quot;),
414                         MAC_CF_BUNDLE_NAME.getID(), bn));
415             }
416             return MAC_CF_BUNDLE_NAME.fetchFrom(params);
417         } else if (APP_NAME.fetchFrom(params) != null) {
418             return APP_NAME.fetchFrom(params);
419         } else {
420             String nm = MAIN_CLASS.fetchFrom(params);
421             if (nm.length() &gt; 16) {
422                 nm = nm.substring(0, 16);
423             }
424             return nm;
425         }
426     }
427 
428     private void writeRuntimeInfoPlist(File file,
429             Map&lt;String, ? super Object&gt; params) throws IOException {
430         Map&lt;String, String&gt; data = new HashMap&lt;&gt;();
431         String identifier = StandardBundlerParam.isRuntimeInstaller(params) ?
432                 MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params) :
433                 &quot;com.oracle.java.&quot; + MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params);
434         data.put(&quot;CF_BUNDLE_IDENTIFIER&quot;, identifier);
435         String name = StandardBundlerParam.isRuntimeInstaller(params) ?
436                 getBundleName(params): &quot;Java Runtime Image&quot;;
437         data.put(&quot;CF_BUNDLE_NAME&quot;, name);
438         data.put(&quot;CF_BUNDLE_VERSION&quot;, VERSION.fetchFrom(params));
439         data.put(&quot;CF_BUNDLE_SHORT_VERSION_STRING&quot;, VERSION.fetchFrom(params));
440 
441         createResource(TEMPLATE_RUNTIME_INFO_PLIST, params)
442                 .setPublicName(&quot;Runtime-Info.plist&quot;)
443                 .setCategory(I18N.getString(&quot;resource.runtime-info-plist&quot;))
444                 .setSubstitutionData(data)
445                 .saveToFile(file);
446     }
447 
448     private void writeInfoPlist(File file, Map&lt;String, ? super Object&gt; params)
449             throws IOException {
450         Log.verbose(MessageFormat.format(I18N.getString(
451                 &quot;message.preparing-info-plist&quot;), file.getAbsolutePath()));
452 
453         //prepare config for exe
454         //Note: do not need CFBundleDisplayName if we don&#39;t support localization
455         Map&lt;String, String&gt; data = new HashMap&lt;&gt;();
456         data.put(&quot;DEPLOY_ICON_FILE&quot;, APP_NAME.fetchFrom(params) + &quot;.icns&quot;);
457         data.put(&quot;DEPLOY_BUNDLE_IDENTIFIER&quot;,
458                 MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params));
459         data.put(&quot;DEPLOY_BUNDLE_NAME&quot;,
460                 getBundleName(params));
461         data.put(&quot;DEPLOY_BUNDLE_COPYRIGHT&quot;,
462                 COPYRIGHT.fetchFrom(params) != null ?
463                 COPYRIGHT.fetchFrom(params) : &quot;Unknown&quot;);
464         data.put(&quot;DEPLOY_LAUNCHER_NAME&quot;, getLauncherName(params));
465         data.put(&quot;DEPLOY_BUNDLE_SHORT_VERSION&quot;,
466                 VERSION.fetchFrom(params) != null ?
467                 VERSION.fetchFrom(params) : &quot;1.0.0&quot;);
468         data.put(&quot;DEPLOY_BUNDLE_CFBUNDLE_VERSION&quot;,
469                 MAC_CF_BUNDLE_VERSION.fetchFrom(params) != null ?
470                 MAC_CF_BUNDLE_VERSION.fetchFrom(params) : &quot;100&quot;);
471 
472         boolean hasMainJar = MAIN_JAR.fetchFrom(params) != null;
473         boolean hasMainModule =
474                 StandardBundlerParam.MODULE.fetchFrom(params) != null;
475 
476         if (hasMainJar) {
477             data.put(&quot;DEPLOY_MAIN_JAR_NAME&quot;, MAIN_JAR.fetchFrom(params).
478                     getIncludedFiles().iterator().next());
479         }
480         else if (hasMainModule) {
481             data.put(&quot;DEPLOY_MODULE_NAME&quot;,
482                     StandardBundlerParam.MODULE.fetchFrom(params));
483         }
484 
485         StringBuilder sb = new StringBuilder();
486         List&lt;String&gt; jvmOptions = JAVA_OPTIONS.fetchFrom(params);
487 
488         String newline = &quot;&quot;; //So we don&#39;t add extra line after last append
489         for (String o : jvmOptions) {
490             sb.append(newline).append(
491                     &quot;    &lt;string&gt;&quot;).append(o).append(&quot;&lt;/string&gt;&quot;);
492             newline = &quot;\n&quot;;
493         }
494 
495         data.put(&quot;DEPLOY_JAVA_OPTIONS&quot;, sb.toString());
496 
497         sb = new StringBuilder();
498         List&lt;String&gt; args = ARGUMENTS.fetchFrom(params);
499         newline = &quot;&quot;;
500         // So we don&#39;t add unneccessary extra line after last append
501 
502         for (String o : args) {
503             sb.append(newline).append(&quot;    &lt;string&gt;&quot;).append(o).append(
504                     &quot;&lt;/string&gt;&quot;);
505             newline = &quot;\n&quot;;
506         }
507         data.put(&quot;DEPLOY_ARGUMENTS&quot;, sb.toString());
508 
509         newline = &quot;&quot;;
510 
511         data.put(&quot;DEPLOY_LAUNCHER_CLASS&quot;, MAIN_CLASS.fetchFrom(params));
512 
513         data.put(&quot;DEPLOY_APP_CLASSPATH&quot;,
514                   getCfgClassPath(CLASSPATH.fetchFrom(params)));
515 
516         StringBuilder bundleDocumentTypes = new StringBuilder();
517         StringBuilder exportedTypes = new StringBuilder();
518         for (Map&lt;String, ? super Object&gt;
519                 fileAssociation : FILE_ASSOCIATIONS.fetchFrom(params)) {
520 
521             List&lt;String&gt; extensions = FA_EXTENSIONS.fetchFrom(fileAssociation);
522 
523             if (extensions == null) {
524                 Log.verbose(I18N.getString(
525                         &quot;message.creating-association-with-null-extension&quot;));
526             }
527 
528             List&lt;String&gt; mimeTypes = FA_CONTENT_TYPE.fetchFrom(fileAssociation);
529             String itemContentType = MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params)
530                     + &quot;.&quot; + ((extensions == null || extensions.isEmpty())
531                     ? &quot;mime&quot; : extensions.get(0));
532             String description = FA_DESCRIPTION.fetchFrom(fileAssociation);
533             File icon = FA_ICON.fetchFrom(fileAssociation);
534 
535             bundleDocumentTypes.append(&quot;    &lt;dict&gt;\n&quot;)
536                     .append(&quot;      &lt;key&gt;LSItemContentTypes&lt;/key&gt;\n&quot;)
537                     .append(&quot;      &lt;array&gt;\n&quot;)
538                     .append(&quot;        &lt;string&gt;&quot;)
539                     .append(itemContentType)
540                     .append(&quot;&lt;/string&gt;\n&quot;)
541                     .append(&quot;      &lt;/array&gt;\n&quot;)
542                     .append(&quot;\n&quot;)
543                     .append(&quot;      &lt;key&gt;CFBundleTypeName&lt;/key&gt;\n&quot;)
544                     .append(&quot;      &lt;string&gt;&quot;)
545                     .append(description)
546                     .append(&quot;&lt;/string&gt;\n&quot;)
547                     .append(&quot;\n&quot;)
548                     .append(&quot;      &lt;key&gt;LSHandlerRank&lt;/key&gt;\n&quot;)
549                     .append(&quot;      &lt;string&gt;Owner&lt;/string&gt;\n&quot;)
550                             // TODO make a bundler arg
551                     .append(&quot;\n&quot;)
552                     .append(&quot;      &lt;key&gt;CFBundleTypeRole&lt;/key&gt;\n&quot;)
553                     .append(&quot;      &lt;string&gt;Editor&lt;/string&gt;\n&quot;)
554                             // TODO make a bundler arg
555                     .append(&quot;\n&quot;)
556                     .append(&quot;      &lt;key&gt;LSIsAppleDefaultForType&lt;/key&gt;\n&quot;)
557                     .append(&quot;      &lt;true/&gt;\n&quot;)
558                             // TODO make a bundler arg
559                     .append(&quot;\n&quot;);
560 
561             if (icon != null &amp;&amp; icon.exists()) {
562                 bundleDocumentTypes
563                         .append(&quot;      &lt;key&gt;CFBundleTypeIconFile&lt;/key&gt;\n&quot;)
564                         .append(&quot;      &lt;string&gt;&quot;)
565                         .append(icon.getName())
566                         .append(&quot;&lt;/string&gt;\n&quot;);
567             }
568             bundleDocumentTypes.append(&quot;    &lt;/dict&gt;\n&quot;);
569 
570             exportedTypes.append(&quot;    &lt;dict&gt;\n&quot;)
571                     .append(&quot;      &lt;key&gt;UTTypeIdentifier&lt;/key&gt;\n&quot;)
572                     .append(&quot;      &lt;string&gt;&quot;)
573                     .append(itemContentType)
574                     .append(&quot;&lt;/string&gt;\n&quot;)
575                     .append(&quot;\n&quot;)
576                     .append(&quot;      &lt;key&gt;UTTypeDescription&lt;/key&gt;\n&quot;)
577                     .append(&quot;      &lt;string&gt;&quot;)
578                     .append(description)
579                     .append(&quot;&lt;/string&gt;\n&quot;)
580                     .append(&quot;      &lt;key&gt;UTTypeConformsTo&lt;/key&gt;\n&quot;)
581                     .append(&quot;      &lt;array&gt;\n&quot;)
582                     .append(&quot;          &lt;string&gt;public.data&lt;/string&gt;\n&quot;)
583                             //TODO expose this?
584                     .append(&quot;      &lt;/array&gt;\n&quot;)
585                     .append(&quot;\n&quot;);
586 
587             if (icon != null &amp;&amp; icon.exists()) {
588                 exportedTypes.append(&quot;      &lt;key&gt;UTTypeIconFile&lt;/key&gt;\n&quot;)
589                         .append(&quot;      &lt;string&gt;&quot;)
590                         .append(icon.getName())
591                         .append(&quot;&lt;/string&gt;\n&quot;)
592                         .append(&quot;\n&quot;);
593             }
594 
595             exportedTypes.append(&quot;\n&quot;)
596                     .append(&quot;      &lt;key&gt;UTTypeTagSpecification&lt;/key&gt;\n&quot;)
597                     .append(&quot;      &lt;dict&gt;\n&quot;)
598                             // TODO expose via param? .append(
599                             // &quot;        &lt;key&gt;com.apple.ostype&lt;/key&gt;\n&quot;);
600                             // TODO expose via param? .append(
601                             // &quot;        &lt;string&gt;ABCD&lt;/string&gt;\n&quot;)
602                     .append(&quot;\n&quot;);
603 
604             if (extensions != null &amp;&amp; !extensions.isEmpty()) {
605                 exportedTypes.append(
606                         &quot;        &lt;key&gt;public.filename-extension&lt;/key&gt;\n&quot;)
607                         .append(&quot;        &lt;array&gt;\n&quot;);
608 
609                 for (String ext : extensions) {
610                     exportedTypes.append(&quot;          &lt;string&gt;&quot;)
611                             .append(ext)
612                             .append(&quot;&lt;/string&gt;\n&quot;);
613                 }
614                 exportedTypes.append(&quot;        &lt;/array&gt;\n&quot;);
615             }
616             if (mimeTypes != null &amp;&amp; !mimeTypes.isEmpty()) {
617                 exportedTypes.append(&quot;        &lt;key&gt;public.mime-type&lt;/key&gt;\n&quot;)
618                         .append(&quot;        &lt;array&gt;\n&quot;);
619 
620                 for (String mime : mimeTypes) {
621                     exportedTypes.append(&quot;          &lt;string&gt;&quot;)
622                             .append(mime)
623                             .append(&quot;&lt;/string&gt;\n&quot;);
624                 }
625                 exportedTypes.append(&quot;        &lt;/array&gt;\n&quot;);
626             }
627             exportedTypes.append(&quot;      &lt;/dict&gt;\n&quot;)
628                     .append(&quot;    &lt;/dict&gt;\n&quot;);
629         }
630         String associationData;
631         if (bundleDocumentTypes.length() &gt; 0) {
632             associationData =
633                     &quot;\n  &lt;key&gt;CFBundleDocumentTypes&lt;/key&gt;\n  &lt;array&gt;\n&quot;
634                     + bundleDocumentTypes.toString()
635                     + &quot;  &lt;/array&gt;\n\n&quot;
636                     + &quot;  &lt;key&gt;UTExportedTypeDeclarations&lt;/key&gt;\n  &lt;array&gt;\n&quot;
637                     + exportedTypes.toString()
638                     + &quot;  &lt;/array&gt;\n&quot;;
639         } else {
640             associationData = &quot;&quot;;
641         }
642         data.put(&quot;DEPLOY_FILE_ASSOCIATIONS&quot;, associationData);
643 
644         createResource(TEMPLATE_INFO_PLIST_LITE, params)
645                 .setCategory(I18N.getString(&quot;resource.app-info-plist&quot;))
646                 .setSubstitutionData(data)
647                 .setPublicName(&quot;Info.plist&quot;)
648                 .saveToFile(file);
649     }
650 
651     private void writePkgInfo(File file) throws IOException {
652         //hardcoded as it does not seem we need to change it ever
653         String signature = &quot;????&quot;;
654 
655         try (Writer out = Files.newBufferedWriter(file.toPath())) {
656             out.write(OS_TYPE_CODE + signature);
657             out.flush();
658         }
659     }
660 
661     public static void addNewKeychain(Map&lt;String, ? super Object&gt; params)
662                                     throws IOException, InterruptedException {
663         if (Platform.getMajorVersion() &lt; 10 ||
664                 (Platform.getMajorVersion() == 10 &amp;&amp;
665                 Platform.getMinorVersion() &lt; 12)) {
666             // we need this for OS X 10.12+
667             return;
668         }
669 
670         String keyChain = SIGNING_KEYCHAIN.fetchFrom(params);
671         if (keyChain == null || keyChain.isEmpty()) {
672             return;
673         }
674 
675         // get current keychain list
676         String keyChainPath = new File (keyChain).getAbsolutePath().toString();
677         List&lt;String&gt; keychainList = new ArrayList&lt;&gt;();
678         int ret = IOUtils.getProcessOutput(
679                 keychainList, &quot;security&quot;, &quot;list-keychains&quot;);
680         if (ret != 0) {
681             Log.error(I18N.getString(&quot;message.keychain.error&quot;));
682             return;
683         }
684 
685         boolean contains = keychainList.stream().anyMatch(
686                     str -&gt; str.trim().equals(&quot;\&quot;&quot;+keyChainPath.trim()+&quot;\&quot;&quot;));
687         if (contains) {
688             // keychain is already added in the search list
689             return;
690         }
691 
692         keyChains = new ArrayList&lt;&gt;();
693         // remove &quot;
694         keychainList.forEach((String s) -&gt; {
695             String path = s.trim();
696             if (path.startsWith(&quot;\&quot;&quot;) &amp;&amp; path.endsWith(&quot;\&quot;&quot;)) {
697                 path = path.substring(1, path.length()-1);
698             }
699             keyChains.add(path);
700         });
701 
702         List&lt;String&gt; args = new ArrayList&lt;&gt;();
703         args.add(&quot;security&quot;);
704         args.add(&quot;list-keychains&quot;);
705         args.add(&quot;-s&quot;);
706 
707         args.addAll(keyChains);
708         args.add(keyChain);
709 
710         ProcessBuilder  pb = new ProcessBuilder(args);
711         IOUtils.exec(pb);
712     }
713 
714     public static void restoreKeychainList(Map&lt;String, ? super Object&gt; params)
715             throws IOException{
716         if (Platform.getMajorVersion() &lt; 10 ||
717                 (Platform.getMajorVersion() == 10 &amp;&amp;
718                 Platform.getMinorVersion() &lt; 12)) {
719             // we need this for OS X 10.12+
720             return;
721         }
722 
723         if (keyChains == null || keyChains.isEmpty()) {
724             return;
725         }
726 
727         List&lt;String&gt; args = new ArrayList&lt;&gt;();
728         args.add(&quot;security&quot;);
729         args.add(&quot;list-keychains&quot;);
730         args.add(&quot;-s&quot;);
731 
732         args.addAll(keyChains);
733 
734         ProcessBuilder  pb = new ProcessBuilder(args);
735         IOUtils.exec(pb);
736     }
737 
738     public static void signAppBundle(
739             Map&lt;String, ? super Object&gt; params, Path appLocation,
740             String signingIdentity, String identifierPrefix,
741             String entitlementsFile, String inheritedEntitlements)
742             throws IOException {
743         AtomicReference&lt;IOException&gt; toThrow = new AtomicReference&lt;&gt;();
744         String appExecutable = &quot;/Contents/MacOS/&quot; + APP_NAME.fetchFrom(params);
745         String keyChain = SIGNING_KEYCHAIN.fetchFrom(params);
746 
747         // sign all dylibs and jars
748         try (Stream&lt;Path&gt; stream = Files.walk(appLocation)) {
749             stream.peek(path -&gt; { // fix permissions
750                 try {
751                     Set&lt;PosixFilePermission&gt; pfp =
752                             Files.getPosixFilePermissions(path);
753                     if (!pfp.contains(PosixFilePermission.OWNER_WRITE)) {
754                         pfp = EnumSet.copyOf(pfp);
755                         pfp.add(PosixFilePermission.OWNER_WRITE);
756                         Files.setPosixFilePermissions(path, pfp);
757                     }
758                 } catch (IOException e) {
759                     Log.verbose(e);
760                 }
761             }).filter(p -&gt; Files.isRegularFile(p)
762                       &amp;&amp; !(p.toString().contains(&quot;/Contents/MacOS/libjli.dylib&quot;)
763                       || p.toString().endsWith(appExecutable)
764                       || p.toString().contains(&quot;/Contents/runtime&quot;)
765                       || p.toString().contains(&quot;/Contents/Frameworks&quot;))).forEach(p -&gt; {
766                 //noinspection ThrowableResultOfMethodCallIgnored
767                 if (toThrow.get() != null) return;
768 
769                 // If p is a symlink then skip the signing process.
770                 if (Files.isSymbolicLink(p)) {
771                     if (VERBOSE.fetchFrom(params)) {
772                         Log.verbose(MessageFormat.format(I18N.getString(
773                                 &quot;message.ignoring.symlink&quot;), p.toString()));
774                     }
775                 } else {
776                     if (p.toString().endsWith(LIBRARY_NAME)) {
777                         if (isFileSigned(p)) {
778                             return;
779                         }
780                     }
781 
782                     List&lt;String&gt; args = new ArrayList&lt;&gt;();
783                     args.addAll(Arrays.asList(&quot;codesign&quot;,
784                             &quot;-s&quot;, signingIdentity, // sign with this key
785                             &quot;--prefix&quot;, identifierPrefix,
786                             // use the identifier as a prefix
787                             &quot;-vvvv&quot;));
788                     if (entitlementsFile != null &amp;&amp;
789                             (p.toString().endsWith(&quot;.jar&quot;)
790                             || p.toString().endsWith(&quot;.dylib&quot;))) {
791                         args.add(&quot;--entitlements&quot;);
792                         args.add(entitlementsFile); // entitlements
793                     } else if (inheritedEntitlements != null &amp;&amp;
794                             Files.isExecutable(p)) {
795                         args.add(&quot;--entitlements&quot;);
796                         args.add(inheritedEntitlements);
797                         // inherited entitlements for executable processes
798                     }
799                     if (keyChain != null &amp;&amp; !keyChain.isEmpty()) {
800                         args.add(&quot;--keychain&quot;);
801                         args.add(keyChain);
802                     }
803                     args.add(p.toString());
804 
805                     try {
806                         Set&lt;PosixFilePermission&gt; oldPermissions =
807                                 Files.getPosixFilePermissions(p);
808                         File f = p.toFile();
809                         f.setWritable(true, true);
810 
811                         ProcessBuilder pb = new ProcessBuilder(args);
812                         IOUtils.exec(pb);
813 
814                         Files.setPosixFilePermissions(p, oldPermissions);
815                     } catch (IOException ioe) {
816                         toThrow.set(ioe);
817                     }
818                 }
819             });
820         }
821         IOException ioe = toThrow.get();
822         if (ioe != null) {
823             throw ioe;
824         }
825 
826         // sign all runtime and frameworks
827         Consumer&lt;? super Path&gt; signIdentifiedByPList = path -&gt; {
828             //noinspection ThrowableResultOfMethodCallIgnored
829             if (toThrow.get() != null) return;
830 
831             try {
832                 List&lt;String&gt; args = new ArrayList&lt;&gt;();
833                 args.addAll(Arrays.asList(&quot;codesign&quot;,
834                         &quot;-f&quot;,
835                         &quot;-s&quot;, signingIdentity, // sign with this key
836                         &quot;--prefix&quot;, identifierPrefix,
837                         // use the identifier as a prefix
838                         &quot;-vvvv&quot;));
839                 if (keyChain != null &amp;&amp; !keyChain.isEmpty()) {
840                     args.add(&quot;--keychain&quot;);
841                     args.add(keyChain);
842                 }
843                 args.add(path.toString());
844                 ProcessBuilder pb = new ProcessBuilder(args);
845                 IOUtils.exec(pb);
846 
847                 args = new ArrayList&lt;&gt;();
848                 args.addAll(Arrays.asList(&quot;codesign&quot;,
849                         &quot;-s&quot;, signingIdentity, // sign with this key
850                         &quot;--prefix&quot;, identifierPrefix,
851                         // use the identifier as a prefix
852                         &quot;-vvvv&quot;));
853                 if (keyChain != null &amp;&amp; !keyChain.isEmpty()) {
854                     args.add(&quot;--keychain&quot;);
855                     args.add(keyChain);
856                 }
857                 args.add(path.toString()
858                         + &quot;/Contents/_CodeSignature/CodeResources&quot;);
859                 pb = new ProcessBuilder(args);
860                 IOUtils.exec(pb);
861             } catch (IOException e) {
862                 toThrow.set(e);
863             }
864         };
865 
866         Path javaPath = appLocation.resolve(&quot;Contents/runtime&quot;);
867         if (Files.isDirectory(javaPath)) {
868             signIdentifiedByPList.accept(javaPath);
869 
870             ioe = toThrow.get();
871             if (ioe != null) {
872                 throw ioe;
873             }
874         }
875         Path frameworkPath = appLocation.resolve(&quot;Contents/Frameworks&quot;);
876         if (Files.isDirectory(frameworkPath)) {
877             Files.list(frameworkPath)
878                     .forEach(signIdentifiedByPList);
879 
880             ioe = toThrow.get();
881             if (ioe != null) {
882                 throw ioe;
883             }
884         }
885 
886         // sign the app itself
887         List&lt;String&gt; args = new ArrayList&lt;&gt;();
888         args.addAll(Arrays.asList(&quot;codesign&quot;,
889                 &quot;-s&quot;, signingIdentity, // sign with this key
890                 &quot;-vvvv&quot;)); // super verbose output
891         if (entitlementsFile != null) {
892             args.add(&quot;--entitlements&quot;);
893             args.add(entitlementsFile); // entitlements
894         }
895         if (keyChain != null &amp;&amp; !keyChain.isEmpty()) {
896             args.add(&quot;--keychain&quot;);
897             args.add(keyChain);
898         }
899         args.add(appLocation.toString());
900 
901         ProcessBuilder pb =
902                 new ProcessBuilder(args.toArray(new String[args.size()]));
903         IOUtils.exec(pb);
904     }
905 
906     private static boolean isFileSigned(Path file) {
907         ProcessBuilder pb =
908                 new ProcessBuilder(&quot;codesign&quot;, &quot;--verify&quot;, file.toString());
909 
910         try {
911             IOUtils.exec(pb);
912         } catch (IOException ex) {
913             return false;
914         }
915 
916         return true;
917     }
918 
919     private static String extractBundleIdentifier(Map&lt;String, Object&gt; params) {
920         if (PREDEFINED_APP_IMAGE.fetchFrom(params) == null) {
921             return null;
922         }
923 
924         try {
925             File infoPList = new File(PREDEFINED_APP_IMAGE.fetchFrom(params) +
926                                       File.separator + &quot;Contents&quot; +
927                                       File.separator + &quot;Info.plist&quot;);
928 
929             DocumentBuilderFactory dbf
930                     = DocumentBuilderFactory.newDefaultInstance();
931             dbf.setFeature(&quot;http://apache.org/xml/features/&quot; +
932                            &quot;nonvalidating/load-external-dtd&quot;, false);
933             DocumentBuilder b = dbf.newDocumentBuilder();
934             org.w3c.dom.Document doc = b.parse(new FileInputStream(
935                     infoPList.getAbsolutePath()));
936 
937             XPath xPath = XPathFactory.newInstance().newXPath();
938             // Query for the value of &lt;string&gt; element preceding &lt;key&gt;
939             // element with value equal to CFBundleIdentifier
940             String v = (String) xPath.evaluate(
941                     &quot;//string[preceding-sibling::key = \&quot;CFBundleIdentifier\&quot;][1]&quot;,
942                     doc, XPathConstants.STRING);
943 
944             if (v != null &amp;&amp; !v.isEmpty()) {
945                 return v;
946             }
947         } catch (Exception ex) {
948             Log.verbose(ex);
949         }
950 
951         return null;
952     }
953 
954 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../code/Symbol.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TypeEnter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 143         syntheticNameChar = target.syntheticNameChar();
 144 
 145         profile = Profile.instance(context);
 146         preview = Preview.instance(context);
 147 
 148         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 149         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 150         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 151         boolean enforceMandatoryWarnings = true;
 152 
 153         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 154                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 155         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 156                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 157         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 158                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 159         sunApiHandler = new MandatoryWarningHandler(log, false,
 160                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 161 
 162         deferredLintHandler = DeferredLintHandler.instance(context);



 163     }
 164 
 165     /** Character for synthetic names
 166      */
 167     char syntheticNameChar;
 168 
 169     /** A table mapping flat names of all compiled classes for each module in this run
 170      *  to their symbols; maintained from outside.
 171      */
 172     private Map&lt;Pair&lt;ModuleSymbol, Name&gt;,ClassSymbol&gt; compiled = new HashMap&lt;&gt;();
 173 
 174     /** A handler for messages about deprecated usage.
 175      */
 176     private MandatoryWarningHandler deprecationHandler;
 177 
 178     /** A handler for messages about deprecated-for-removal usage.
 179      */
 180     private MandatoryWarningHandler removalHandler;
 181 
 182     /** A handler for messages about unchecked or unsafe usage.
 183      */
 184     private MandatoryWarningHandler uncheckedHandler;
 185 
 186     /** A handler for messages about using proprietary API.
 187      */
 188     private MandatoryWarningHandler sunApiHandler;
 189 
 190     /** A handler for deferred lint warnings.
 191      */
 192     private DeferredLintHandler deferredLintHandler;
 193 




 194 /* *************************************************************************
 195  * Errors and Warnings
 196  **************************************************************************/
 197 
 198     Lint setLint(Lint newLint) {
 199         Lint prev = lint;
 200         lint = newLint;
 201         return prev;
 202     }
 203 
 204     MethodSymbol setMethod(MethodSymbol newMethod) {
 205         MethodSymbol prev = method;
 206         method = newMethod;
 207         return prev;
 208     }
 209 
 210     /** Warn about deprecated symbol.
 211      *  @param pos        Position to be used for error reporting.
 212      *  @param sym        The deprecated symbol.
 213      */
</pre>
<hr />
<pre>
3332                 if (!(app instanceof Attribute.Enum)) {
3333                     continue; // recovery
3334                 }
3335                 Attribute.Enum e = (Attribute.Enum)app;
3336                 containedTargets.add(e.value.name);
3337             }
3338         }
3339 
3340         if (!isTargetSubsetOf(containerTargets, containedTargets)) {
3341             log.error(pos, Errors.InvalidRepeatableAnnotationIncompatibleTarget(container, contained));
3342         }
3343     }
3344 
3345     /* get a set of names for the default target */
3346     private Set&lt;Name&gt; getDefaultTargetSet() {
3347         if (defaultTargets == null) {
3348             Set&lt;Name&gt; targets = new HashSet&lt;&gt;();
3349             targets.add(names.ANNOTATION_TYPE);
3350             targets.add(names.CONSTRUCTOR);
3351             targets.add(names.FIELD);
<span class="line-modified">3352             targets.add(names.RECORD_COMPONENT);</span>


3353             targets.add(names.LOCAL_VARIABLE);
3354             targets.add(names.METHOD);
3355             targets.add(names.PACKAGE);
3356             targets.add(names.PARAMETER);
3357             targets.add(names.TYPE);
3358 
3359             defaultTargets = java.util.Collections.unmodifiableSet(targets);
3360         }
3361 
3362         return defaultTargets;
3363     }
3364     private Set&lt;Name&gt; defaultTargets;
3365 
3366 
3367     /** Checks that s is a subset of t, with respect to ElementType
3368      * semantics, specifically {ANNOTATION_TYPE} is a subset of {TYPE},
3369      * and {TYPE_USE} covers the set {ANNOTATION_TYPE, TYPE, TYPE_USE,
3370      * TYPE_PARAMETER}.
3371      */
3372     private boolean isTargetSubsetOf(Set&lt;Name&gt; s, Set&lt;Name&gt; t) {
</pre>
</td>
<td>
<hr />
<pre>
 143         syntheticNameChar = target.syntheticNameChar();
 144 
 145         profile = Profile.instance(context);
 146         preview = Preview.instance(context);
 147 
 148         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 149         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 150         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 151         boolean enforceMandatoryWarnings = true;
 152 
 153         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 154                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 155         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 156                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 157         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 158                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 159         sunApiHandler = new MandatoryWarningHandler(log, false,
 160                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 161 
 162         deferredLintHandler = DeferredLintHandler.instance(context);
<span class="line-added"> 163 </span>
<span class="line-added"> 164         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;</span>
<span class="line-added"> 165                 Feature.RECORDS.allowedInSource(source);</span>
 166     }
 167 
 168     /** Character for synthetic names
 169      */
 170     char syntheticNameChar;
 171 
 172     /** A table mapping flat names of all compiled classes for each module in this run
 173      *  to their symbols; maintained from outside.
 174      */
 175     private Map&lt;Pair&lt;ModuleSymbol, Name&gt;,ClassSymbol&gt; compiled = new HashMap&lt;&gt;();
 176 
 177     /** A handler for messages about deprecated usage.
 178      */
 179     private MandatoryWarningHandler deprecationHandler;
 180 
 181     /** A handler for messages about deprecated-for-removal usage.
 182      */
 183     private MandatoryWarningHandler removalHandler;
 184 
 185     /** A handler for messages about unchecked or unsafe usage.
 186      */
 187     private MandatoryWarningHandler uncheckedHandler;
 188 
 189     /** A handler for messages about using proprietary API.
 190      */
 191     private MandatoryWarningHandler sunApiHandler;
 192 
 193     /** A handler for deferred lint warnings.
 194      */
 195     private DeferredLintHandler deferredLintHandler;
 196 
<span class="line-added"> 197     /** Are records allowed</span>
<span class="line-added"> 198      */</span>
<span class="line-added"> 199     private final boolean allowRecords;</span>
<span class="line-added"> 200 </span>
 201 /* *************************************************************************
 202  * Errors and Warnings
 203  **************************************************************************/
 204 
 205     Lint setLint(Lint newLint) {
 206         Lint prev = lint;
 207         lint = newLint;
 208         return prev;
 209     }
 210 
 211     MethodSymbol setMethod(MethodSymbol newMethod) {
 212         MethodSymbol prev = method;
 213         method = newMethod;
 214         return prev;
 215     }
 216 
 217     /** Warn about deprecated symbol.
 218      *  @param pos        Position to be used for error reporting.
 219      *  @param sym        The deprecated symbol.
 220      */
</pre>
<hr />
<pre>
3339                 if (!(app instanceof Attribute.Enum)) {
3340                     continue; // recovery
3341                 }
3342                 Attribute.Enum e = (Attribute.Enum)app;
3343                 containedTargets.add(e.value.name);
3344             }
3345         }
3346 
3347         if (!isTargetSubsetOf(containerTargets, containedTargets)) {
3348             log.error(pos, Errors.InvalidRepeatableAnnotationIncompatibleTarget(container, contained));
3349         }
3350     }
3351 
3352     /* get a set of names for the default target */
3353     private Set&lt;Name&gt; getDefaultTargetSet() {
3354         if (defaultTargets == null) {
3355             Set&lt;Name&gt; targets = new HashSet&lt;&gt;();
3356             targets.add(names.ANNOTATION_TYPE);
3357             targets.add(names.CONSTRUCTOR);
3358             targets.add(names.FIELD);
<span class="line-modified">3359             if (allowRecords) {</span>
<span class="line-added">3360                 targets.add(names.RECORD_COMPONENT);</span>
<span class="line-added">3361             }</span>
3362             targets.add(names.LOCAL_VARIABLE);
3363             targets.add(names.METHOD);
3364             targets.add(names.PACKAGE);
3365             targets.add(names.PARAMETER);
3366             targets.add(names.TYPE);
3367 
3368             defaultTargets = java.util.Collections.unmodifiableSet(targets);
3369         }
3370 
3371         return defaultTargets;
3372     }
3373     private Set&lt;Name&gt; defaultTargets;
3374 
3375 
3376     /** Checks that s is a subset of t, with respect to ElementType
3377      * semantics, specifically {ANNOTATION_TYPE} is a subset of {TYPE},
3378      * and {TYPE_USE} covers the set {ANNOTATION_TYPE, TYPE, TYPE_USE,
3379      * TYPE_PARAMETER}.
3380      */
3381     private boolean isTargetSubsetOf(Set&lt;Name&gt; s, Set&lt;Name&gt; t) {
</pre>
</td>
</tr>
</table>
<center><a href="../code/Symbol.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TypeEnter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../comp/TypeEnter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../processing/JavacProcessingEnvironment.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 852         mode = prevmode;
 853         return t;
 854     }
 855 
 856     /**
 857      *  {@literal
 858      *  Expression = Expression1 [ExpressionRest]
 859      *  ExpressionRest = [AssignmentOperator Expression1]
 860      *  AssignmentOperator = &quot;=&quot; | &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;/=&quot; |
 861      *                       &quot;&amp;=&quot; | &quot;|=&quot; | &quot;^=&quot; |
 862      *                       &quot;%=&quot; | &quot;&lt;&lt;=&quot; | &quot;&gt;&gt;=&quot; | &quot;&gt;&gt;&gt;=&quot;
 863      *  Type = Type1
 864      *  TypeNoParams = TypeNoParams1
 865      *  StatementExpression = Expression
 866      *  ConstantExpression = Expression
 867      *  }
 868      */
 869     JCExpression term() {
 870         JCExpression t = term1();
 871         if ((mode &amp; EXPR) != 0 &amp;&amp;
<span class="line-modified"> 872             token.kind == EQ || PLUSEQ.compareTo(token.kind) &lt;= 0 &amp;&amp; token.kind.compareTo(GTGTGTEQ) &lt;= 0)</span>
 873             return termRest(t);
 874         else
 875             return t;
 876     }
 877 
 878     JCExpression termRest(JCExpression t) {
 879         switch (token.kind) {
 880         case EQ: {
 881             int pos = token.pos;
 882             nextToken();
 883             selectExprMode();
 884             JCExpression t1 = term();
 885             return toP(F.at(pos).Assign(t, t1));
 886         }
 887         case PLUSEQ:
 888         case SUBEQ:
 889         case STAREQ:
 890         case SLASHEQ:
 891         case PERCENTEQ:
 892         case AMPEQ:
</pre>
<hr />
<pre>
2683         }
2684         case ABSTRACT: case STRICTFP: {
2685             dc = token.comment(CommentStyle.JAVADOC);
2686             JCModifiers mods = modifiersOpt();
2687             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2688         }
2689         case INTERFACE:
2690         case CLASS:
2691             dc = token.comment(CommentStyle.JAVADOC);
2692             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2693         case ENUM:
2694             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
2695             dc = token.comment(CommentStyle.JAVADOC);
2696             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2697         case IDENTIFIER:
2698             if (token.name() == names.yield &amp;&amp; allowYieldStatement) {
2699                 Token next = S.token(1);
2700                 boolean isYieldStatement;
2701                 switch (next.kind) {
2702                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:
<span class="line-modified">2703                     case INTLITERAL: case FLOATLITERAL: case DOUBLELITERAL:</span>
2704                     case NULL: case IDENTIFIER: case TRUE: case FALSE:
2705                     case NEW: case SWITCH: case THIS: case SUPER:
2706                         isYieldStatement = true;
2707                         break;
2708                     case PLUSPLUS: case SUBSUB:
2709                         isYieldStatement = S.token(2).kind != SEMI;
2710                         break;
2711                     case LPAREN:
2712                         int lookahead = 2;
2713                         int balance = 1;
2714                         boolean hasComma = false;
2715                         Token l;
2716                         while ((l = S.token(lookahead)).kind != EOF &amp;&amp; balance != 0) {
2717                             switch (l.kind) {
2718                                 case LPAREN: balance++; break;
2719                                 case RPAREN: balance--; break;
2720                                 case COMMA: if (balance == 1) hasComma = true; break;
2721                             }
2722                             lookahead++;
2723                         }
</pre>
<hr />
<pre>
3378 
3379     /** VariableDeclaratorRest = BracketsOpt [&quot;=&quot; VariableInitializer]
3380      *  ConstantDeclaratorRest = BracketsOpt &quot;=&quot; VariableInitializer
3381      *
3382      *  @param reqInit  Is an initializer always required?
3383      *  @param dc       The documentation comment for the variable declarations, or null.
3384      */
3385     JCVariableDecl variableDeclaratorRest(int pos, JCModifiers mods, JCExpression type, Name name,
3386                                   boolean reqInit, Comment dc, boolean localDecl, boolean compound) {
3387         type = bracketsOpt(type);
3388         JCExpression init = null;
3389         if (token.kind == EQ) {
3390             nextToken();
3391             init = variableInitializer();
3392         }
3393         else if (reqInit) syntaxError(token.pos, Errors.Expected(EQ));
3394         JCTree elemType = TreeInfo.innermostType(type, true);
3395         int startPos = Position.NOPOS;
3396         if (elemType.hasTag(IDENT)) {
3397             Name typeName = ((JCIdent)elemType).name;
<span class="line-modified">3398             if (isRestrictedTypeName(typeName, pos, !compound &amp;&amp; localDecl)) {</span>
3399                 if (type.hasTag(TYPEARRAY) &amp;&amp; !compound) {
3400                     //error - &#39;var&#39; and arrays
3401                     reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));
3402                 } else {
3403                     if(compound)
3404                         //error - &#39;var&#39; in compound local var decl
3405                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));
3406                     startPos = TreeInfo.getStartPos(mods);
3407                     if (startPos == Position.NOPOS)
3408                         startPos = TreeInfo.getStartPos(type);
3409                     //implicit type
3410                     type = null;
3411                 }
3412             }
3413         }
3414         JCVariableDecl result =
3415             toP(F.at(pos).VarDef(mods, name, type, init));
3416         attach(result, dc);
3417         result.startPos = startPos;
3418         return result;
</pre>
<hr />
<pre>
3440                          t == SHORT ||
3441                          t == CHAR ||
3442                          t == INT ||
3443                          t == LONG ||
3444                          t == FLOAT ||
3445                          t == DOUBLE ||
3446                          t == BOOLEAN ||
3447                          t == CLASS ||
3448                          t == INTERFACE ||
3449                          t == ENUM ||
3450                          t == IDENTIFIER)) { // new value Comparable() {}
3451             checkSourceLevel(Feature.INLINE_TYPES);
3452             return new Token(VALUE, token.pos, token.endPos, token.comments);
3453         }
3454         return token;
3455     }
3456 
3457     Name restrictedTypeName(JCExpression e, boolean shouldWarn) {
3458         switch (e.getTag()) {
3459             case IDENT:
<span class="line-modified">3460                 return isRestrictedTypeName(((JCIdent)e).name, e.pos, shouldWarn) ? ((JCIdent)e).name : null;</span>
3461             case TYPEARRAY:
3462                 return restrictedTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);
3463             default:
3464                 return null;
3465         }
3466     }
3467 
<span class="line-modified">3468     boolean isRestrictedTypeName(Name name, int pos, boolean shouldWarn) {</span>
3469         if (name == names.var) {
3470             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
<span class="line-modified">3471                 return true;</span>
3472             } else if (shouldWarn) {
3473                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3474             }
3475         }
3476         if (name == names.yield) {
3477             if (allowYieldStatement) {
<span class="line-modified">3478                 return true;</span>
3479             } else if (shouldWarn) {
3480                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK14));
3481             }
3482         }
3483         if (name == names.record) {
3484             if (allowRecords) {
<span class="line-modified">3485                 return true;</span>
3486             } else if (shouldWarn) {
3487                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));
3488             }
3489         }
<span class="line-modified">3490         return false;</span>
3491     }
3492 
3493     /** VariableDeclaratorId = Ident BracketsOpt
3494      */
3495     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
3496         return variableDeclaratorId(mods, type, false);
3497     }
3498     //where
3499     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {
3500         int pos = token.pos;
3501         Name name;
3502         if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {
3503             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3504             name = token.name();
3505             nextToken();
3506         } else {
3507             if (allowThisIdent ||
3508                 !lambdaParameter ||
3509                 LAX_IDENTIFIER.accepts(token.kind) ||
3510                 mods.flags != Flags.PARAMETER ||
</pre>
<hr />
<pre>
3918                                 // we will get flags plus annotations from the record component
3919                                 .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags &amp; Flags.VARARGS, param.mods.annotations),
3920                                 param.name, param.vartype, null));
3921                     }
3922                     methDef.params = tmpParams.toList();
3923                 }
3924             }
3925         }
3926         for (int i = fields.size() - 1; i &gt;= 0; i--) {
3927             JCVariableDecl field = fields.get(i);
3928             defs = defs.prepend(field);
3929         }
3930         JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams, null, implementing, defs));
3931         attach(result, dc);
3932         return result;
3933     }
3934 
3935     Name typeName() {
3936         int pos = token.pos;
3937         Name name = ident();
<span class="line-modified">3938         if (isRestrictedTypeName(name, pos, true)) {</span>
<span class="line-modified">3939             reportSyntaxError(pos, Errors.RestrictedTypeNotAllowed(name, name == names.var ? Source.JDK10 : Source.JDK13));</span>

3940         }
3941         return name;
3942     }
3943 
3944     /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
3945      *                         [EXTENDS TypeList] InterfaceBody
3946      *  @param mods    The modifiers starting the interface declaration
3947      *  @param dc       The documentation comment for the interface, or null.
3948      */
3949     protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {
3950         int pos = token.pos;
3951         accept(INTERFACE);
3952 
3953         Name name = typeName();
3954 
3955         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3956 
3957         List&lt;JCExpression&gt; extending = List.nil();
3958         if (token.kind == EXTENDS) {
3959             nextToken();
</pre>
</td>
<td>
<hr />
<pre>
 852         mode = prevmode;
 853         return t;
 854     }
 855 
 856     /**
 857      *  {@literal
 858      *  Expression = Expression1 [ExpressionRest]
 859      *  ExpressionRest = [AssignmentOperator Expression1]
 860      *  AssignmentOperator = &quot;=&quot; | &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;/=&quot; |
 861      *                       &quot;&amp;=&quot; | &quot;|=&quot; | &quot;^=&quot; |
 862      *                       &quot;%=&quot; | &quot;&lt;&lt;=&quot; | &quot;&gt;&gt;=&quot; | &quot;&gt;&gt;&gt;=&quot;
 863      *  Type = Type1
 864      *  TypeNoParams = TypeNoParams1
 865      *  StatementExpression = Expression
 866      *  ConstantExpression = Expression
 867      *  }
 868      */
 869     JCExpression term() {
 870         JCExpression t = term1();
 871         if ((mode &amp; EXPR) != 0 &amp;&amp;
<span class="line-modified"> 872             (token.kind == EQ || PLUSEQ.compareTo(token.kind) &lt;= 0 &amp;&amp; token.kind.compareTo(GTGTGTEQ) &lt;= 0))</span>
 873             return termRest(t);
 874         else
 875             return t;
 876     }
 877 
 878     JCExpression termRest(JCExpression t) {
 879         switch (token.kind) {
 880         case EQ: {
 881             int pos = token.pos;
 882             nextToken();
 883             selectExprMode();
 884             JCExpression t1 = term();
 885             return toP(F.at(pos).Assign(t, t1));
 886         }
 887         case PLUSEQ:
 888         case SUBEQ:
 889         case STAREQ:
 890         case SLASHEQ:
 891         case PERCENTEQ:
 892         case AMPEQ:
</pre>
<hr />
<pre>
2683         }
2684         case ABSTRACT: case STRICTFP: {
2685             dc = token.comment(CommentStyle.JAVADOC);
2686             JCModifiers mods = modifiersOpt();
2687             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2688         }
2689         case INTERFACE:
2690         case CLASS:
2691             dc = token.comment(CommentStyle.JAVADOC);
2692             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2693         case ENUM:
2694             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
2695             dc = token.comment(CommentStyle.JAVADOC);
2696             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2697         case IDENTIFIER:
2698             if (token.name() == names.yield &amp;&amp; allowYieldStatement) {
2699                 Token next = S.token(1);
2700                 boolean isYieldStatement;
2701                 switch (next.kind) {
2702                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:
<span class="line-modified">2703                     case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:</span>
2704                     case NULL: case IDENTIFIER: case TRUE: case FALSE:
2705                     case NEW: case SWITCH: case THIS: case SUPER:
2706                         isYieldStatement = true;
2707                         break;
2708                     case PLUSPLUS: case SUBSUB:
2709                         isYieldStatement = S.token(2).kind != SEMI;
2710                         break;
2711                     case LPAREN:
2712                         int lookahead = 2;
2713                         int balance = 1;
2714                         boolean hasComma = false;
2715                         Token l;
2716                         while ((l = S.token(lookahead)).kind != EOF &amp;&amp; balance != 0) {
2717                             switch (l.kind) {
2718                                 case LPAREN: balance++; break;
2719                                 case RPAREN: balance--; break;
2720                                 case COMMA: if (balance == 1) hasComma = true; break;
2721                             }
2722                             lookahead++;
2723                         }
</pre>
<hr />
<pre>
3378 
3379     /** VariableDeclaratorRest = BracketsOpt [&quot;=&quot; VariableInitializer]
3380      *  ConstantDeclaratorRest = BracketsOpt &quot;=&quot; VariableInitializer
3381      *
3382      *  @param reqInit  Is an initializer always required?
3383      *  @param dc       The documentation comment for the variable declarations, or null.
3384      */
3385     JCVariableDecl variableDeclaratorRest(int pos, JCModifiers mods, JCExpression type, Name name,
3386                                   boolean reqInit, Comment dc, boolean localDecl, boolean compound) {
3387         type = bracketsOpt(type);
3388         JCExpression init = null;
3389         if (token.kind == EQ) {
3390             nextToken();
3391             init = variableInitializer();
3392         }
3393         else if (reqInit) syntaxError(token.pos, Errors.Expected(EQ));
3394         JCTree elemType = TreeInfo.innermostType(type, true);
3395         int startPos = Position.NOPOS;
3396         if (elemType.hasTag(IDENT)) {
3397             Name typeName = ((JCIdent)elemType).name;
<span class="line-modified">3398             if (restrictedTypeNameStartingAtSource(typeName, pos, !compound &amp;&amp; localDecl) != null) {</span>
3399                 if (type.hasTag(TYPEARRAY) &amp;&amp; !compound) {
3400                     //error - &#39;var&#39; and arrays
3401                     reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));
3402                 } else {
3403                     if(compound)
3404                         //error - &#39;var&#39; in compound local var decl
3405                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));
3406                     startPos = TreeInfo.getStartPos(mods);
3407                     if (startPos == Position.NOPOS)
3408                         startPos = TreeInfo.getStartPos(type);
3409                     //implicit type
3410                     type = null;
3411                 }
3412             }
3413         }
3414         JCVariableDecl result =
3415             toP(F.at(pos).VarDef(mods, name, type, init));
3416         attach(result, dc);
3417         result.startPos = startPos;
3418         return result;
</pre>
<hr />
<pre>
3440                          t == SHORT ||
3441                          t == CHAR ||
3442                          t == INT ||
3443                          t == LONG ||
3444                          t == FLOAT ||
3445                          t == DOUBLE ||
3446                          t == BOOLEAN ||
3447                          t == CLASS ||
3448                          t == INTERFACE ||
3449                          t == ENUM ||
3450                          t == IDENTIFIER)) { // new value Comparable() {}
3451             checkSourceLevel(Feature.INLINE_TYPES);
3452             return new Token(VALUE, token.pos, token.endPos, token.comments);
3453         }
3454         return token;
3455     }
3456 
3457     Name restrictedTypeName(JCExpression e, boolean shouldWarn) {
3458         switch (e.getTag()) {
3459             case IDENT:
<span class="line-modified">3460                 return restrictedTypeNameStartingAtSource(((JCIdent)e).name, e.pos, shouldWarn) != null ? ((JCIdent)e).name : null;</span>
3461             case TYPEARRAY:
3462                 return restrictedTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);
3463             default:
3464                 return null;
3465         }
3466     }
3467 
<span class="line-modified">3468     Source restrictedTypeNameStartingAtSource(Name name, int pos, boolean shouldWarn) {</span>
3469         if (name == names.var) {
3470             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
<span class="line-modified">3471                 return Source.JDK10;</span>
3472             } else if (shouldWarn) {
3473                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3474             }
3475         }
3476         if (name == names.yield) {
3477             if (allowYieldStatement) {
<span class="line-modified">3478                 return Source.JDK14;</span>
3479             } else if (shouldWarn) {
3480                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK14));
3481             }
3482         }
3483         if (name == names.record) {
3484             if (allowRecords) {
<span class="line-modified">3485                 return Source.JDK14;</span>
3486             } else if (shouldWarn) {
3487                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));
3488             }
3489         }
<span class="line-modified">3490         return null;</span>
3491     }
3492 
3493     /** VariableDeclaratorId = Ident BracketsOpt
3494      */
3495     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
3496         return variableDeclaratorId(mods, type, false);
3497     }
3498     //where
3499     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {
3500         int pos = token.pos;
3501         Name name;
3502         if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {
3503             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3504             name = token.name();
3505             nextToken();
3506         } else {
3507             if (allowThisIdent ||
3508                 !lambdaParameter ||
3509                 LAX_IDENTIFIER.accepts(token.kind) ||
3510                 mods.flags != Flags.PARAMETER ||
</pre>
<hr />
<pre>
3918                                 // we will get flags plus annotations from the record component
3919                                 .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags &amp; Flags.VARARGS, param.mods.annotations),
3920                                 param.name, param.vartype, null));
3921                     }
3922                     methDef.params = tmpParams.toList();
3923                 }
3924             }
3925         }
3926         for (int i = fields.size() - 1; i &gt;= 0; i--) {
3927             JCVariableDecl field = fields.get(i);
3928             defs = defs.prepend(field);
3929         }
3930         JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams, null, implementing, defs));
3931         attach(result, dc);
3932         return result;
3933     }
3934 
3935     Name typeName() {
3936         int pos = token.pos;
3937         Name name = ident();
<span class="line-modified">3938         Source source = restrictedTypeNameStartingAtSource(name, pos, true);</span>
<span class="line-modified">3939         if (source != null) {</span>
<span class="line-added">3940             reportSyntaxError(pos, Errors.RestrictedTypeNotAllowed(name, source));</span>
3941         }
3942         return name;
3943     }
3944 
3945     /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
3946      *                         [EXTENDS TypeList] InterfaceBody
3947      *  @param mods    The modifiers starting the interface declaration
3948      *  @param dc       The documentation comment for the interface, or null.
3949      */
3950     protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {
3951         int pos = token.pos;
3952         accept(INTERFACE);
3953 
3954         Name name = typeName();
3955 
3956         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3957 
3958         List&lt;JCExpression&gt; extending = List.nil();
3959         if (token.kind == EXTENDS) {
3960             nextToken();
</pre>
</td>
</tr>
</table>
<center><a href="../comp/TypeEnter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../processing/JavacProcessingEnvironment.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
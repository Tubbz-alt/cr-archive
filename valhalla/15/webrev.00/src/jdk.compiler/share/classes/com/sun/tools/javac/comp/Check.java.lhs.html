<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.Supplier;
  30 
  31 import javax.lang.model.element.ElementKind;
  32 import javax.tools.JavaFileManager;
  33 
  34 import com.sun.tools.javac.code.*;
  35 import com.sun.tools.javac.code.Attribute.Compound;
  36 import com.sun.tools.javac.code.Directive.ExportsDirective;
  37 import com.sun.tools.javac.code.Directive.RequiresDirective;
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  40 import com.sun.tools.javac.jvm.*;
  41 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  42 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  43 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  44 import com.sun.tools.javac.tree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  47 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  48 import com.sun.tools.javac.util.JCDiagnostic.Error;
  49 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  50 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  51 import com.sun.tools.javac.util.List;
  52 
  53 import com.sun.tools.javac.code.Lint;
  54 import com.sun.tools.javac.code.Lint.LintCategory;
  55 import com.sun.tools.javac.code.Scope.WriteableScope;
  56 import com.sun.tools.javac.code.Type.*;
  57 import com.sun.tools.javac.code.Symbol.*;
  58 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
  59 import com.sun.tools.javac.tree.JCTree.*;
  60 
  61 import static com.sun.tools.javac.code.Flags.*;
  62 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  63 import static com.sun.tools.javac.code.Flags.SYNCHRONIZED;
  64 import static com.sun.tools.javac.code.Kinds.*;
  65 import static com.sun.tools.javac.code.Kinds.Kind.*;
  66 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  67 import static com.sun.tools.javac.code.TypeTag.*;
  68 import static com.sun.tools.javac.code.TypeTag.WILDCARD;
  69 
  70 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  71 
  72 /** Type checking helper class for the attribution phase.
  73  *
  74  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  75  *  If you write code that depends on this, you do so at your own risk.
  76  *  This code and its internal interfaces are subject to change or
  77  *  deletion without notice.&lt;/b&gt;
  78  */
  79 public class Check {
  80     protected static final Context.Key&lt;Check&gt; checkKey = new Context.Key&lt;&gt;();
  81 
  82     private final Names names;
  83     private final Log log;
  84     private final Resolve rs;
  85     private final Symtab syms;
  86     private final Enter enter;
  87     private final DeferredAttr deferredAttr;
  88     private final Infer infer;
  89     private final Types types;
  90     private final TypeAnnotations typeAnnotations;
  91     private final JCDiagnostic.Factory diags;
  92     private final JavaFileManager fileManager;
  93     private final Source source;
  94     private final Target target;
  95     private final Profile profile;
  96     private final Preview preview;
  97     private final boolean warnOnAnyAccessToMembers;
  98     private final boolean allowGenericsOverValues;
  99     private final boolean allowValueBasedClasses;
 100 
 101     // The set of lint options currently in effect. It is initialized
 102     // from the context, and then is set/reset as needed by Attr as it
 103     // visits all the various parts of the trees during attribution.
 104     private Lint lint;
 105 
 106     // The method being analyzed in Attr - it is set/reset as needed by
 107     // Attr as it visits new method declarations.
 108     private MethodSymbol method;
 109 
 110     public static Check instance(Context context) {
 111         Check instance = context.get(checkKey);
 112         if (instance == null)
 113             instance = new Check(context);
 114         return instance;
 115     }
 116 
 117     protected Check(Context context) {
 118         context.put(checkKey, this);
 119 
 120         names = Names.instance(context);
 121         dfltTargetMeta = new Name[] { names.PACKAGE, names.TYPE,
 122             names.FIELD, names.RECORD_COMPONENT, names.METHOD, names.CONSTRUCTOR,
 123             names.ANNOTATION_TYPE, names.LOCAL_VARIABLE, names.PARAMETER};
 124         log = Log.instance(context);
 125         rs = Resolve.instance(context);
 126         syms = Symtab.instance(context);
 127         enter = Enter.instance(context);
 128         deferredAttr = DeferredAttr.instance(context);
 129         infer = Infer.instance(context);
 130         types = Types.instance(context);
 131         typeAnnotations = TypeAnnotations.instance(context);
 132         diags = JCDiagnostic.Factory.instance(context);
 133         Options options = Options.instance(context);
 134         lint = Lint.instance(context);
 135         fileManager = context.get(JavaFileManager.class);
 136 
 137         source = Source.instance(context);
 138         target = Target.instance(context);
 139         warnOnAnyAccessToMembers = options.isSet(&quot;warnOnAccessToMembers&quot;);
 140         allowGenericsOverValues = options.isSet(&quot;allowGenericsOverValues&quot;);
 141         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);
 142         Target target = Target.instance(context);
 143         syntheticNameChar = target.syntheticNameChar();
 144 
 145         profile = Profile.instance(context);
 146         preview = Preview.instance(context);
 147 
 148         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 149         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 150         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 151         boolean enforceMandatoryWarnings = true;
 152 
 153         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 154                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 155         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 156                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 157         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 158                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 159         sunApiHandler = new MandatoryWarningHandler(log, false,
 160                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 161 
 162         deferredLintHandler = DeferredLintHandler.instance(context);
<a name="1" id="anc1"></a>


 163     }
 164 
 165     /** Character for synthetic names
 166      */
 167     char syntheticNameChar;
 168 
 169     /** A table mapping flat names of all compiled classes for each module in this run
 170      *  to their symbols; maintained from outside.
 171      */
 172     private Map&lt;Pair&lt;ModuleSymbol, Name&gt;,ClassSymbol&gt; compiled = new HashMap&lt;&gt;();
 173 
 174     /** A handler for messages about deprecated usage.
 175      */
 176     private MandatoryWarningHandler deprecationHandler;
 177 
 178     /** A handler for messages about deprecated-for-removal usage.
 179      */
 180     private MandatoryWarningHandler removalHandler;
 181 
 182     /** A handler for messages about unchecked or unsafe usage.
 183      */
 184     private MandatoryWarningHandler uncheckedHandler;
 185 
 186     /** A handler for messages about using proprietary API.
 187      */
 188     private MandatoryWarningHandler sunApiHandler;
 189 
 190     /** A handler for deferred lint warnings.
 191      */
 192     private DeferredLintHandler deferredLintHandler;
 193 
<a name="2" id="anc2"></a>



 194 /* *************************************************************************
 195  * Errors and Warnings
 196  **************************************************************************/
 197 
 198     Lint setLint(Lint newLint) {
 199         Lint prev = lint;
 200         lint = newLint;
 201         return prev;
 202     }
 203 
 204     MethodSymbol setMethod(MethodSymbol newMethod) {
 205         MethodSymbol prev = method;
 206         method = newMethod;
 207         return prev;
 208     }
 209 
 210     /** Warn about deprecated symbol.
 211      *  @param pos        Position to be used for error reporting.
 212      *  @param sym        The deprecated symbol.
 213      */
 214     void warnDeprecated(DiagnosticPosition pos, Symbol sym) {
 215         if (sym.isDeprecatedForRemoval()) {
 216             if (!lint.isSuppressed(LintCategory.REMOVAL)) {
 217                 if (sym.kind == MDL) {
 218                     removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemovalModule(sym));
 219                 } else {
 220                     removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemoval(sym, sym.location()));
 221                 }
 222             }
 223         } else if (!lint.isSuppressed(LintCategory.DEPRECATION)) {
 224             if (sym.kind == MDL) {
 225                 deprecationHandler.report(pos, Warnings.HasBeenDeprecatedModule(sym));
 226             } else {
 227                 deprecationHandler.report(pos, Warnings.HasBeenDeprecated(sym, sym.location()));
 228             }
 229         }
 230     }
 231 
 232     /** Warn about deprecated symbol.
 233      *  @param pos        Position to be used for error reporting.
 234      *  @param sym        The deprecated symbol.
 235      */
 236     void warnPreview(DiagnosticPosition pos, Symbol sym) {
 237         warnPreview(pos, Warnings.IsPreview(sym));
 238     }
 239 
 240     /** Log a preview warning.
 241      *  @param pos        Position to be used for error reporting.
 242      *  @param msg        A Warning describing the problem.
 243      */
 244     public void warnPreview(DiagnosticPosition pos, Warning warnKey) {
 245         if (!lint.isSuppressed(LintCategory.PREVIEW))
 246             preview.reportPreviewWarning(pos, warnKey);
 247     }
 248 
 249     /** Warn about unchecked operation.
 250      *  @param pos        Position to be used for error reporting.
 251      *  @param msg        A string describing the problem.
 252      */
 253     public void warnUnchecked(DiagnosticPosition pos, Warning warnKey) {
 254         if (!lint.isSuppressed(LintCategory.UNCHECKED))
 255             uncheckedHandler.report(pos, warnKey);
 256     }
 257 
 258     /** Warn about unsafe vararg method decl.
 259      *  @param pos        Position to be used for error reporting.
 260      */
 261     void warnUnsafeVararg(DiagnosticPosition pos, Warning warnKey) {
 262         if (lint.isEnabled(LintCategory.VARARGS))
 263             log.warning(LintCategory.VARARGS, pos, warnKey);
 264     }
 265 
 266     public void warnStatic(DiagnosticPosition pos, Warning warnKey) {
 267         if (lint.isEnabled(LintCategory.STATIC))
 268             log.warning(LintCategory.STATIC, pos, warnKey);
 269     }
 270 
 271     /** Warn about division by integer constant zero.
 272      *  @param pos        Position to be used for error reporting.
 273      */
 274     void warnDivZero(DiagnosticPosition pos) {
 275         if (lint.isEnabled(LintCategory.DIVZERO))
 276             log.warning(LintCategory.DIVZERO, pos, Warnings.DivZero);
 277     }
 278 
 279     /**
 280      * Report any deferred diagnostics.
 281      */
 282     public void reportDeferredDiagnostics() {
 283         deprecationHandler.reportDeferredDiagnostic();
 284         removalHandler.reportDeferredDiagnostic();
 285         uncheckedHandler.reportDeferredDiagnostic();
 286         sunApiHandler.reportDeferredDiagnostic();
 287     }
 288 
 289 
 290     /** Report a failure to complete a class.
 291      *  @param pos        Position to be used for error reporting.
 292      *  @param ex         The failure to report.
 293      */
 294     public Type completionError(DiagnosticPosition pos, CompletionFailure ex) {
 295         log.error(JCDiagnostic.DiagnosticFlag.NON_DEFERRABLE, pos, Errors.CantAccess(ex.sym, ex.getDetailValue()));
 296         return syms.errType;
 297     }
 298 
 299     /** Report an error that wrong type tag was found.
 300      *  @param pos        Position to be used for error reporting.
 301      *  @param required   An internationalized string describing the type tag
 302      *                    required.
 303      *  @param found      The type that was found.
 304      */
 305     Type typeTagError(DiagnosticPosition pos, JCDiagnostic required, Object found) {
 306         // this error used to be raised by the parser,
 307         // but has been delayed to this point:
 308         if (found instanceof Type &amp;&amp; ((Type)found).hasTag(VOID)) {
 309             log.error(pos, Errors.IllegalStartOfType);
 310             return syms.errType;
 311         }
 312         log.error(pos, Errors.TypeFoundReq(found, required));
 313         return types.createErrorType(found instanceof Type ? (Type)found : syms.errType);
 314     }
 315 
 316     /** Report an error that symbol cannot be referenced before super
 317      *  has been called.
 318      *  @param pos        Position to be used for error reporting.
 319      *  @param sym        The referenced symbol.
 320      */
 321     void earlyRefError(DiagnosticPosition pos, Symbol sym) {
 322         log.error(pos, Errors.CantRefBeforeCtorCalled(sym));
 323     }
 324 
 325     /** Report duplicate declaration error.
 326      */
 327     void duplicateError(DiagnosticPosition pos, Symbol sym) {
 328         if (!sym.type.isErroneous()) {
 329             Symbol location = sym.location();
 330             if (location.kind == MTH &amp;&amp;
 331                     ((MethodSymbol)location).isStaticOrInstanceInit()) {
 332                 log.error(pos,
 333                           Errors.AlreadyDefinedInClinit(kindName(sym),
 334                                                         sym,
 335                                                         kindName(sym.location()),
 336                                                         kindName(sym.location().enclClass()),
 337                                                         sym.location().enclClass()));
 338             } else {
 339                 /* dont error if this is a duplicated parameter of a generated canonical constructor
 340                  * as we should have issued an error for the duplicated fields
 341                  */
 342                 if (location.kind != MTH ||
 343                         ((sym.owner.flags_field &amp; GENERATEDCONSTR) == 0) ||
 344                         ((sym.owner.flags_field &amp; RECORD) == 0)) {
 345                     log.error(pos,
 346                             Errors.AlreadyDefined(kindName(sym),
 347                                     sym,
 348                                     kindName(sym.location()),
 349                                     sym.location()));
 350                 }
 351             }
 352         }
 353     }
 354 
 355     /** Report array/varargs duplicate declaration
 356      */
 357     void varargsDuplicateError(DiagnosticPosition pos, Symbol sym1, Symbol sym2) {
 358         if (!sym1.type.isErroneous() &amp;&amp; !sym2.type.isErroneous()) {
 359             log.error(pos, Errors.ArrayAndVarargs(sym1, sym2, sym2.location()));
 360         }
 361     }
 362 
 363 /* ************************************************************************
 364  * duplicate declaration checking
 365  *************************************************************************/
 366 
 367     /** Check that variable does not hide variable with same name in
 368      *  immediately enclosing local scope.
 369      *  @param pos           Position for error reporting.
 370      *  @param v             The symbol.
 371      *  @param s             The scope.
 372      */
 373     void checkTransparentVar(DiagnosticPosition pos, VarSymbol v, Scope s) {
 374         for (Symbol sym : s.getSymbolsByName(v.name)) {
 375             if (sym.owner != v.owner) break;
 376             if (sym.kind == VAR &amp;&amp;
 377                 sym.owner.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
 378                 v.name != names.error) {
 379                 duplicateError(pos, sym);
 380                 return;
 381             }
 382         }
 383     }
 384 
 385     /** Check that a class or interface does not hide a class or
 386      *  interface with same name in immediately enclosing local scope.
 387      *  @param pos           Position for error reporting.
 388      *  @param c             The symbol.
 389      *  @param s             The scope.
 390      */
 391     void checkTransparentClass(DiagnosticPosition pos, ClassSymbol c, Scope s) {
 392         for (Symbol sym : s.getSymbolsByName(c.name)) {
 393             if (sym.owner != c.owner) break;
 394             if (sym.kind == TYP &amp;&amp; !sym.type.hasTag(TYPEVAR) &amp;&amp;
 395                 sym.owner.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
 396                 c.name != names.error) {
 397                 duplicateError(pos, sym);
 398                 return;
 399             }
 400         }
 401     }
 402 
 403     /** Check that class does not have the same name as one of
 404      *  its enclosing classes, or as a class defined in its enclosing scope.
 405      *  return true if class is unique in its enclosing scope.
 406      *  @param pos           Position for error reporting.
 407      *  @param name          The class name.
 408      *  @param s             The enclosing scope.
 409      */
 410     boolean checkUniqueClassName(DiagnosticPosition pos, Name name, Scope s) {
 411         for (Symbol sym : s.getSymbolsByName(name, NON_RECURSIVE)) {
 412             if (sym.kind == TYP &amp;&amp; sym.name != names.error) {
 413                 duplicateError(pos, sym);
 414                 return false;
 415             }
 416         }
 417         for (Symbol sym = s.owner; sym != null; sym = sym.owner) {
 418             if (sym.kind == TYP &amp;&amp; sym.name == name &amp;&amp; sym.name != names.error) {
 419                 duplicateError(pos, sym);
 420                 return true;
 421             }
 422         }
 423         return true;
 424     }
 425 
 426 /* *************************************************************************
 427  * Class name generation
 428  **************************************************************************/
 429 
 430 
 431     private Map&lt;Pair&lt;Name, Name&gt;, Integer&gt; localClassNameIndexes = new HashMap&lt;&gt;();
 432 
 433     /** Return name of local class.
 434      *  This is of the form   {@code &lt;enclClass&gt; $ n &lt;classname&gt; }
 435      *  where
 436      *    enclClass is the flat name of the enclosing class,
 437      *    classname is the simple name of the local class
 438      */
 439     public Name localClassName(ClassSymbol c) {
 440         Name enclFlatname = c.owner.enclClass().flatname;
 441         String enclFlatnameStr = enclFlatname.toString();
 442         Pair&lt;Name, Name&gt; key = new Pair&lt;&gt;(enclFlatname, c.name);
 443         Integer index = localClassNameIndexes.get(key);
 444         for (int i = (index == null) ? 1 : index; ; i++) {
 445             Name flatname = names.fromString(enclFlatnameStr
 446                     + syntheticNameChar + i + c.name);
 447             if (getCompiled(c.packge().modle, flatname) == null) {
 448                 localClassNameIndexes.put(key, i + 1);
 449                 return flatname;
 450             }
 451         }
 452     }
 453 
 454     public void clearLocalClassNameIndexes(ClassSymbol c) {
 455         if (c.owner != null &amp;&amp; c.owner.kind != NIL) {
 456             localClassNameIndexes.remove(new Pair&lt;&gt;(
 457                     c.owner.enclClass().flatname, c.name));
 458         }
 459     }
 460 
 461     public void newRound() {
 462         compiled.clear();
 463         localClassNameIndexes.clear();
 464     }
 465 
 466     public void clear() {
 467         deprecationHandler.clear();
 468         removalHandler.clear();
 469         uncheckedHandler.clear();
 470         sunApiHandler.clear();
 471     }
 472 
 473     public void putCompiled(ClassSymbol csym) {
 474         compiled.put(Pair.of(csym.packge().modle, csym.flatname), csym);
 475     }
 476 
 477     public ClassSymbol getCompiled(ClassSymbol csym) {
 478         return compiled.get(Pair.of(csym.packge().modle, csym.flatname));
 479     }
 480 
 481     public ClassSymbol getCompiled(ModuleSymbol msym, Name flatname) {
 482         return compiled.get(Pair.of(msym, flatname));
 483     }
 484 
 485     public void removeCompiled(ClassSymbol csym) {
 486         compiled.remove(Pair.of(csym.packge().modle, csym.flatname));
 487     }
 488 
 489     /* *************************************************************************
 490  * Type Checking
 491  **************************************************************************/
 492 
 493     /**
 494      * A check context is an object that can be used to perform compatibility
 495      * checks - depending on the check context, meaning of &#39;compatibility&#39; might
 496      * vary significantly.
 497      */
 498     public interface CheckContext {
 499         /**
 500          * Is type &#39;found&#39; compatible with type &#39;req&#39; in given context
 501          */
 502         boolean compatible(Type found, Type req, Warner warn);
 503         /**
 504          * Report a check error
 505          */
 506         void report(DiagnosticPosition pos, JCDiagnostic details);
 507         /**
 508          * Obtain a warner for this check context
 509          */
 510         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req);
 511 
 512         public InferenceContext inferenceContext();
 513 
 514         public DeferredAttr.DeferredAttrContext deferredAttrContext();
 515     }
 516 
 517     /**
 518      * This class represent a check context that is nested within another check
 519      * context - useful to check sub-expressions. The default behavior simply
 520      * redirects all method calls to the enclosing check context leveraging
 521      * the forwarding pattern.
 522      */
 523     static class NestedCheckContext implements CheckContext {
 524         CheckContext enclosingContext;
 525 
 526         NestedCheckContext(CheckContext enclosingContext) {
 527             this.enclosingContext = enclosingContext;
 528         }
 529 
 530         public boolean compatible(Type found, Type req, Warner warn) {
 531             return enclosingContext.compatible(found, req, warn);
 532         }
 533 
 534         public void report(DiagnosticPosition pos, JCDiagnostic details) {
 535             enclosingContext.report(pos, details);
 536         }
 537 
 538         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
 539             return enclosingContext.checkWarner(pos, found, req);
 540         }
 541 
 542         public InferenceContext inferenceContext() {
 543             return enclosingContext.inferenceContext();
 544         }
 545 
 546         public DeferredAttrContext deferredAttrContext() {
 547             return enclosingContext.deferredAttrContext();
 548         }
 549     }
 550 
 551     /**
 552      * Check context to be used when evaluating assignment/return statements
 553      */
 554     CheckContext basicHandler = new CheckContext() {
 555         public void report(DiagnosticPosition pos, JCDiagnostic details) {
 556             log.error(pos, Errors.ProbFoundReq(details));
 557         }
 558         public boolean compatible(Type found, Type req, Warner warn) {
 559             return types.isAssignable(found, req, warn);
 560         }
 561 
 562         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
 563             return convertWarner(pos, found, req);
 564         }
 565 
 566         public InferenceContext inferenceContext() {
 567             return infer.emptyContext;
 568         }
 569 
 570         public DeferredAttrContext deferredAttrContext() {
 571             return deferredAttr.emptyDeferredAttrContext;
 572         }
 573 
 574         @Override
 575         public String toString() {
 576             return &quot;CheckContext: basicHandler&quot;;
 577         }
 578     };
 579 
 580     /** Check that a given type is assignable to a given proto-type.
 581      *  If it is, return the type, otherwise return errType.
 582      *  @param pos        Position to be used for error reporting.
 583      *  @param found      The type that was found.
 584      *  @param req        The type that was required.
 585      */
 586     public Type checkType(DiagnosticPosition pos, Type found, Type req) {
 587         return checkType(pos, found, req, basicHandler);
 588     }
 589 
 590     Type checkType(final DiagnosticPosition pos, final Type found, final Type req, final CheckContext checkContext) {
 591         final InferenceContext inferenceContext = checkContext.inferenceContext();
 592         if (inferenceContext.free(req) || inferenceContext.free(found)) {
 593             inferenceContext.addFreeTypeListener(List.of(req, found),
 594                     solvedContext -&gt; checkType(pos, solvedContext.asInstType(found), solvedContext.asInstType(req), checkContext));
 595         } else {
 596             if (found.hasTag(CLASS)) {
 597                 checkParameterizationWithValues(pos, found);
 598             }
 599         }
 600         if (req.hasTag(ERROR))
 601             return req;
 602         if (req.hasTag(NONE))
 603             return found;
 604         if (checkContext.compatible(found, req, checkContext.checkWarner(pos, found, req))) {
 605             if (found.hasTag(BOT) &amp;&amp; types.isValueBased(req)) {
 606                 log.warning(pos, Warnings.SuspiciousMixOfNullWithValueBasedClass(req));
 607             }
 608             return found;
 609         } else {
 610             if (found.isNumeric() &amp;&amp; req.isNumeric()) {
 611                 checkContext.report(pos, diags.fragment(Fragments.PossibleLossOfPrecision(found, req)));
 612                 return types.createErrorType(found);
 613             }
 614             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 615             return types.createErrorType(found);
 616         }
 617     }
 618 
 619     /** Check that a given type can be cast to a given target type.
 620      *  Return the result of the cast.
 621      *  @param pos        Position to be used for error reporting.
 622      *  @param found      The type that is being cast.
 623      *  @param req        The target type of the cast.
 624      */
 625     Type checkCastable(DiagnosticPosition pos, Type found, Type req) {
 626         return checkCastable(pos, found, req, basicHandler);
 627     }
 628     Type checkCastable(DiagnosticPosition pos, Type found, Type req, CheckContext checkContext) {
 629         if (types.isCastable(found, req, castWarner(pos, found, req))) {
 630             if (types.isValueBased(req)) {
 631                 if (found.hasTag(BOT)) {
 632                     log.warning(pos, Warnings.SuspiciousMixOfNullWithValueBasedClass(req));
 633                 } else if (!types.isValueBased(found)) {
 634                     log.warning(pos, Warnings.PotentialNullPollution(found));
 635                 }
 636             }
 637             return req;
 638         } else {
 639             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 640             return types.createErrorType(found);
 641         }
 642     }
 643 
 644     /** Check for redundant casts (i.e. where source type is a subtype of target type)
 645      * The problem should only be reported for non-292 cast
 646      */
 647     public void checkRedundantCast(Env&lt;AttrContext&gt; env, final JCTypeCast tree) {
 648         if (!tree.type.isErroneous()
 649                 &amp;&amp; types.isSameType(tree.expr.type, tree.clazz.type)
 650                 &amp;&amp; !(ignoreAnnotatedCasts &amp;&amp; TreeInfo.containsTypeAnnotation(tree.clazz))
 651                 &amp;&amp; !is292targetTypeCast(tree)) {
 652             deferredLintHandler.report(() -&gt; {
 653                 if (lint.isEnabled(LintCategory.CAST))
 654                     log.warning(LintCategory.CAST,
 655                             tree.pos(), Warnings.RedundantCast(tree.clazz.type));
 656             });
 657         }
 658     }
 659     //where
 660         private boolean is292targetTypeCast(JCTypeCast tree) {
 661             boolean is292targetTypeCast = false;
 662             JCExpression expr = TreeInfo.skipParens(tree.expr);
 663             if (expr.hasTag(APPLY)) {
 664                 JCMethodInvocation apply = (JCMethodInvocation)expr;
 665                 Symbol sym = TreeInfo.symbol(apply.meth);
 666                 is292targetTypeCast = sym != null &amp;&amp;
 667                     sym.kind == MTH &amp;&amp;
 668                     (sym.flags() &amp; HYPOTHETICAL) != 0;
 669             }
 670             return is292targetTypeCast;
 671         }
 672 
 673         private static final boolean ignoreAnnotatedCasts = true;
 674 
 675     /** Check that a type is within some bounds.
 676      *
 677      *  Used in TypeApply to verify that, e.g., X in {@code V&lt;X&gt;} is a valid
 678      *  type argument.
 679      *  @param a             The type that should be bounded by bs.
 680      *  @param bound         The bound.
 681      */
 682     private boolean checkExtends(Type a, Type bound) {
 683          if (a.isUnbound()) {
 684              return true;
 685          } else if (!a.hasTag(WILDCARD)) {
 686              a = types.cvarUpperBound(a);
 687              return types.isSubtype(a, bound);
 688          } else if (a.isExtendsBound()) {
 689              return types.isCastable(bound, types.wildUpperBound(a), types.noWarnings);
 690          } else if (a.isSuperBound()) {
 691              return !types.notSoftSubtype(types.wildLowerBound(a), bound);
 692          }
 693          return true;
 694      }
 695 
 696     /** Check that type is different from &#39;void&#39;.
 697      *  @param pos           Position to be used for error reporting.
 698      *  @param t             The type to be checked.
 699      */
 700     Type checkNonVoid(DiagnosticPosition pos, Type t) {
 701         if (t.hasTag(VOID)) {
 702             log.error(pos, Errors.VoidNotAllowedHere);
 703             return types.createErrorType(t);
 704         } else {
 705             return t;
 706         }
 707     }
 708 
 709     Type checkClassOrArrayType(DiagnosticPosition pos, Type t) {
 710         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ARRAY) &amp;&amp; !t.hasTag(ERROR)) {
 711             return typeTagError(pos,
 712                                 diags.fragment(Fragments.TypeReqClassArray),
 713                                 asTypeParam(t));
 714         } else {
 715             return t;
 716         }
 717     }
 718 
 719     /** Check that type is a class or interface type.
 720      *  @param pos           Position to be used for error reporting.
 721      *  @param t             The type to be checked.
 722      */
 723     Type checkClassType(DiagnosticPosition pos, Type t) {
 724         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ERROR)) {
 725             return typeTagError(pos,
 726                                 diags.fragment(Fragments.TypeReqClass),
 727                                 asTypeParam(t));
 728         } else {
 729             return t;
 730         }
 731     }
 732     //where
 733         private Object asTypeParam(Type t) {
 734             return (t.hasTag(TYPEVAR))
 735                                     ? diags.fragment(Fragments.TypeParameter(t))
 736                                     : t;
 737         }
 738 
 739     /** Check that type is a valid qualifier for a constructor reference expression
 740      */
 741     Type checkConstructorRefType(DiagnosticPosition pos, Type t) {
 742         t = checkClassOrArrayType(pos, t);
 743         if (t.hasTag(CLASS)) {
 744             if ((t.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
 745                 log.error(pos, Errors.AbstractCantBeInstantiated(t.tsym));
 746                 t = types.createErrorType(t);
 747             } else if ((t.tsym.flags() &amp; ENUM) != 0) {
 748                 log.error(pos, Errors.EnumCantBeInstantiated);
 749                 t = types.createErrorType(t);
 750             } else {
 751                 t = checkClassType(pos, t, true);
 752             }
 753         } else if (t.hasTag(ARRAY)) {
 754             if (!types.isReifiable(((ArrayType)t).elemtype)) {
 755                 log.error(pos, Errors.GenericArrayCreation);
 756                 t = types.createErrorType(t);
 757             }
 758         }
 759         return t;
 760     }
 761 
 762     /** Check that type is a class or interface type.
 763      *  @param pos           Position to be used for error reporting.
 764      *  @param t             The type to be checked.
 765      *  @param noBounds    True if type bounds are illegal here.
 766      */
 767     Type checkClassType(DiagnosticPosition pos, Type t, boolean noBounds) {
 768         t = checkClassType(pos, t);
 769         if (noBounds &amp;&amp; t.isParameterized()) {
 770             List&lt;Type&gt; args = t.getTypeArguments();
 771             while (args.nonEmpty()) {
 772                 if (args.head.hasTag(WILDCARD))
 773                     return typeTagError(pos,
 774                                         diags.fragment(Fragments.TypeReqExact),
 775                                         args.head);
 776                 args = args.tail;
 777             }
 778         }
 779         return t;
 780     }
 781 
 782     /** Check that type is a reference type, i.e. a class, interface or array type
 783      *  or a type variable.
 784      *  @param pos           Position to be used for error reporting.
 785      *  @param t             The type to be checked.
 786      *  @param valueOK       If false, a value class does not qualify
 787      */
 788     Type checkRefType(DiagnosticPosition pos, Type t, boolean valueOK) {
 789         if (t.isReference() &amp;&amp; (valueOK || !types.isValue(t)))
 790             return t;
 791         else
 792             return typeTagError(pos,
 793                                 diags.fragment(Fragments.TypeReqRef),
 794                                 t);
 795     }
 796 
 797     /** Check that type is a reference type, i.e. a class, interface or array type
 798      *  or a type variable.
 799      *  @param pos           Position to be used for error reporting.
 800      *  @param t             The type to be checked.
 801      */
 802     Type checkRefType(DiagnosticPosition pos, Type t) {
 803         return checkRefType(pos, t, true);
 804     }
 805 
 806     /** Check that each type is a reference type, i.e. a class, interface or array type
 807      *  or a type variable.
 808      *  @param trees         Original trees, used for error reporting.
 809      *  @param types         The types to be checked.
 810      */
 811     List&lt;Type&gt; checkRefTypes(List&lt;JCExpression&gt; trees, List&lt;Type&gt; types) {
 812         List&lt;JCExpression&gt; tl = trees;
 813         for (List&lt;Type&gt; l = types; l.nonEmpty(); l = l.tail) {
 814             l.head = checkRefType(tl.head.pos(), l.head, allowGenericsOverValues);
 815             tl = tl.tail;
 816         }
 817         return types;
 818     }
 819 
 820     /** Check that type is a null or reference type.
 821      *  @param pos           Position to be used for error reporting.
 822      *  @param t             The type to be checked.
 823      */
 824     Type checkNullOrRefType(DiagnosticPosition pos, Type t) {
 825         if (t.isReference() || t.hasTag(BOT))
 826             return t;
 827         else
 828             return typeTagError(pos,
 829                                 diags.fragment(Fragments.TypeReqRef),
 830                                 t);
 831     }
 832 
 833     /** Check that flag set does not contain elements of two conflicting sets. s
 834      *  Return true if it doesn&#39;t.
 835      *  @param pos           Position to be used for error reporting.
 836      *  @param flags         The set of flags to be checked.
 837      *  @param set1          Conflicting flags set #1.
 838      *  @param set2          Conflicting flags set #2.
 839      */
 840     boolean checkDisjoint(DiagnosticPosition pos, long flags, long set1, long set2) {
 841         if ((flags &amp; set1) != 0 &amp;&amp; (flags &amp; set2) != 0) {
 842             log.error(pos,
 843                       Errors.IllegalCombinationOfModifiers(asFlagSet(TreeInfo.firstFlag(flags &amp; set1)),
 844                                                            asFlagSet(TreeInfo.firstFlag(flags &amp; set2))));
 845             return false;
 846         } else
 847             return true;
 848     }
 849 
 850     void checkParameterizationWithValues(DiagnosticPosition pos, Type t) {
 851         if (!allowGenericsOverValues &amp;&amp; t.tsym != syms.classType.tsym) { // tolerate Value.class for now.
 852             valueParameterizationChecker.visit(t, pos);
 853         }
 854     }
 855 
 856     /** valueParameterizationChecker: A type visitor that descends down the given type looking for instances of value types
 857      *  being used as type arguments and issues error against those usages.
 858      */
 859     private final Types.SimpleVisitor&lt;Void, DiagnosticPosition&gt; valueParameterizationChecker = new Types.SimpleVisitor&lt;Void, DiagnosticPosition&gt;() {
 860 
 861         @Override
 862         public Void visitType(Type t, DiagnosticPosition pos) {
 863             return null;
 864         }
 865 
 866         @Override
 867         public Void visitClassType(ClassType t, DiagnosticPosition pos) {
 868             for (Type targ : t.allparams()) {
 869                 if (types.isValue(targ) &amp;&amp; !allowGenericsOverValues) {
 870                     log.error(pos, Errors.GenericParameterizationWithValueType(t));
 871                 }
 872                 visit(targ, pos);
 873             }
 874             return null;
 875         }
 876 
 877         @Override
 878         public Void visitTypeVar(TypeVar t, DiagnosticPosition pos) {
 879              return null;
 880         }
 881 
 882         @Override
 883         public Void visitCapturedType(CapturedType t, DiagnosticPosition pos) {
 884             return null;
 885         }
 886 
 887         @Override
 888         public Void visitArrayType(ArrayType t, DiagnosticPosition pos) {
 889             return visit(t.elemtype, pos);
 890         }
 891 
 892         @Override
 893         public Void visitWildcardType(WildcardType t, DiagnosticPosition pos) {
 894             return visit(t.type, pos);
 895         }
 896     };
 897 
 898 
 899 
 900     /** Check that usage of diamond operator is correct (i.e. diamond should not
 901      * be used with non-generic classes or in anonymous class creation expressions)
 902      */
 903     Type checkDiamond(JCNewClass tree, Type t) {
 904         if (!TreeInfo.isDiamond(tree) ||
 905                 t.isErroneous()) {
 906             return checkClassType(tree.clazz.pos(), t, true);
 907         } else {
 908             if (tree.def != null &amp;&amp; !Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.allowedInSource(source)) {
 909                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.clazz.pos(),
 910                         Errors.CantApplyDiamond1(t, Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.fragment(source.name)));
 911             }
 912             if (t.tsym.type.getTypeArguments().isEmpty()) {
 913                 log.error(tree.clazz.pos(),
 914                           Errors.CantApplyDiamond1(t,
 915                                                    Fragments.DiamondNonGeneric(t)));
 916                 return types.createErrorType(t);
 917             } else if (tree.typeargs != null &amp;&amp;
 918                     tree.typeargs.nonEmpty()) {
 919                 log.error(tree.clazz.pos(),
 920                           Errors.CantApplyDiamond1(t,
 921                                                    Fragments.DiamondAndExplicitParams(t)));
 922                 return types.createErrorType(t);
 923             } else {
 924                 return t;
 925             }
 926         }
 927     }
 928 
 929     /** Check that the type inferred using the diamond operator does not contain
 930      *  non-denotable types such as captured types or intersection types.
 931      *  @param t the type inferred using the diamond operator
 932      *  @return  the (possibly empty) list of non-denotable types.
 933      */
 934     List&lt;Type&gt; checkDiamondDenotable(ClassType t) {
 935         ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
 936         for (Type arg : t.allparams()) {
 937             if (!checkDenotable(arg)) {
 938                 buf.append(arg);
 939             }
 940         }
 941         return buf.toList();
 942     }
 943 
 944     public boolean checkDenotable(Type t) {
 945         return denotableChecker.visit(t, null);
 946     }
 947         // where
 948 
 949         /** diamondTypeChecker: A type visitor that descends down the given type looking for non-denotable
 950          *  types. The visit methods return false as soon as a non-denotable type is encountered and true
 951          *  otherwise.
 952          */
 953         private static final Types.SimpleVisitor&lt;Boolean, Void&gt; denotableChecker = new Types.SimpleVisitor&lt;Boolean, Void&gt;() {
 954             @Override
 955             public Boolean visitType(Type t, Void s) {
 956                 return true;
 957             }
 958             @Override
 959             public Boolean visitClassType(ClassType t, Void s) {
 960                 if (t.isUnion() || t.isIntersection()) {
 961                     return false;
 962                 }
 963                 for (Type targ : t.allparams()) {
 964                     if (!visit(targ, s)) {
 965                         return false;
 966                     }
 967                 }
 968                 return true;
 969             }
 970 
 971             @Override
 972             public Boolean visitTypeVar(TypeVar t, Void s) {
 973                 /* Any type variable mentioned in the inferred type must have been declared as a type parameter
 974                   (i.e cannot have been produced by inference (18.4))
 975                 */
 976                 return (t.tsym.flags() &amp; SYNTHETIC) == 0;
 977             }
 978 
 979             @Override
 980             public Boolean visitCapturedType(CapturedType t, Void s) {
 981                 /* Any type variable mentioned in the inferred type must have been declared as a type parameter
 982                   (i.e cannot have been produced by capture conversion (5.1.10))
 983                 */
 984                 return false;
 985             }
 986 
 987             @Override
 988             public Boolean visitArrayType(ArrayType t, Void s) {
 989                 return visit(t.elemtype, s);
 990             }
 991 
 992             @Override
 993             public Boolean visitWildcardType(WildcardType t, Void s) {
 994                 return visit(t.type, s);
 995             }
 996         };
 997 
 998     void checkVarargsMethodDecl(Env&lt;AttrContext&gt; env, JCMethodDecl tree) {
 999         MethodSymbol m = tree.sym;
1000         boolean hasTrustMeAnno = m.attribute(syms.trustMeType.tsym) != null;
1001         Type varargElemType = null;
1002         if (m.isVarArgs()) {
1003             varargElemType = types.elemtype(tree.params.last().type);
1004         }
1005         if (hasTrustMeAnno &amp;&amp; !isTrustMeAllowedOnMethod(m)) {
1006             if (varargElemType != null) {
1007                 JCDiagnostic msg = Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ?
1008                         diags.fragment(Fragments.VarargsTrustmeOnVirtualVarargs(m)) :
1009                         diags.fragment(Fragments.VarargsTrustmeOnVirtualVarargsFinalOnly(m));
1010                 log.error(tree,
1011                           Errors.VarargsInvalidTrustmeAnno(syms.trustMeType.tsym,
1012                                                            msg));
1013             } else {
1014                 log.error(tree,
1015                           Errors.VarargsInvalidTrustmeAnno(syms.trustMeType.tsym,
1016                                                            Fragments.VarargsTrustmeOnNonVarargsMeth(m)));
1017             }
1018         } else if (hasTrustMeAnno &amp;&amp; varargElemType != null &amp;&amp;
1019                             types.isReifiable(varargElemType)) {
1020             warnUnsafeVararg(tree, Warnings.VarargsRedundantTrustmeAnno(
1021                                 syms.trustMeType.tsym,
1022                                 diags.fragment(Fragments.VarargsTrustmeOnReifiableVarargs(varargElemType))));
1023         }
1024         else if (!hasTrustMeAnno &amp;&amp; varargElemType != null &amp;&amp;
1025                 !types.isReifiable(varargElemType)) {
1026             warnUnchecked(tree.params.head.pos(), Warnings.UncheckedVarargsNonReifiableType(varargElemType));
1027         }
1028     }
1029     //where
1030         private boolean isTrustMeAllowedOnMethod(Symbol s) {
1031             return (s.flags() &amp; VARARGS) != 0 &amp;&amp;
1032                 (s.isConstructor() ||
1033                     (s.flags() &amp; (STATIC | FINAL |
1034                                   (Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ? PRIVATE : 0) )) != 0);
1035         }
1036 
1037     Type checkLocalVarType(DiagnosticPosition pos, Type t, Name name) {
1038         //check that resulting type is not the null type
1039         if (t.hasTag(BOT)) {
1040             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferNull));
1041             return types.createErrorType(t);
1042         } else if (t.hasTag(VOID)) {
1043             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferVoid));
1044             return types.createErrorType(t);
1045         }
1046 
1047         //upward project the initializer type
1048         Type varType = types.upward(t, types.captures(t));
1049         if (varType.hasTag(CLASS)) {
1050             checkParameterizationWithValues(pos, varType);
1051         }
1052         return varType;
1053     }
1054 
1055     public void checkForSuspectClassLiteralComparison(
1056             final JCBinary tree,
1057             final Type leftType,
1058             final Type rightType) {
1059 
1060         if (lint.isEnabled(LintCategory.MIGRATION)) {
1061             if (isInvocationOfGetClass(tree.lhs) &amp;&amp; isClassOfSomeInterface(rightType) ||
1062                     isInvocationOfGetClass(tree.rhs) &amp;&amp; isClassOfSomeInterface(leftType)) {
1063                 log.warning(LintCategory.MIGRATION, tree.pos(), Warnings.GetClassComparedWithInterface);
1064             }
1065         }
1066     }
1067     //where
1068     private boolean isClassOfSomeInterface(Type someClass) {
1069         if (someClass.tsym.flatName() == names.java_lang_Class) {
1070             List&lt;Type&gt; arguments = someClass.getTypeArguments();
1071             if (arguments.length() == 1) {
1072                 return arguments.head.isInterface();
1073             }
1074         }
1075         return false;
1076     }
1077     //where
1078     private boolean isInvocationOfGetClass(JCExpression tree) {
1079         tree = TreeInfo.skipParens(tree);
1080         if (tree.hasTag(APPLY)) {
1081             JCMethodInvocation apply = (JCMethodInvocation)tree;
1082             MethodSymbol msym = (MethodSymbol)TreeInfo.symbol(apply.meth);
1083             return msym.name == names.getClass &amp;&amp; msym.implementedIn(syms.objectType.tsym, types) != null;
1084         }
1085         return false;
1086     }
1087 
1088     Type checkMethod(final Type mtype,
1089             final Symbol sym,
1090             final Env&lt;AttrContext&gt; env,
1091             final List&lt;JCExpression&gt; argtrees,
1092             final List&lt;Type&gt; argtypes,
1093             final boolean useVarargs,
1094             InferenceContext inferenceContext) {
1095         // System.out.println(&quot;call   : &quot; + env.tree);
1096         // System.out.println(&quot;method : &quot; + owntype);
1097         // System.out.println(&quot;actuals: &quot; + argtypes);
1098         if (inferenceContext.free(mtype)) {
1099             inferenceContext.addFreeTypeListener(List.of(mtype),
1100                     solvedContext -&gt; checkMethod(solvedContext.asInstType(mtype), sym, env, argtrees, argtypes, useVarargs, solvedContext));
1101             return mtype;
1102         }
1103         Type owntype = mtype;
1104         List&lt;Type&gt; formals = owntype.getParameterTypes();
1105         List&lt;Type&gt; nonInferred = sym.type.getParameterTypes();
1106         if (nonInferred.length() != formals.length()) nonInferred = formals;
1107         Type last = useVarargs ? formals.last() : null;
1108         if (sym.name == names.init &amp;&amp; sym.owner == syms.enumSym) {
1109             formals = formals.tail.tail;
1110             nonInferred = nonInferred.tail.tail;
1111         }
1112         if ((sym.flags() &amp; ANONCONSTR_BASED) != 0) {
1113             formals = formals.tail;
1114             nonInferred = nonInferred.tail;
1115         }
1116         List&lt;JCExpression&gt; args = argtrees;
1117         if (args != null) {
1118             //this is null when type-checking a method reference
1119             while (formals.head != last) {
1120                 JCTree arg = args.head;
1121                 Warner warn = convertWarner(arg.pos(), arg.type, nonInferred.head);
1122                 assertConvertible(arg, arg.type, formals.head, warn);
1123                 args = args.tail;
1124                 formals = formals.tail;
1125                 nonInferred = nonInferred.tail;
1126             }
1127             if (useVarargs) {
1128                 Type varArg = types.elemtype(last);
1129                 while (args.tail != null) {
1130                     JCTree arg = args.head;
1131                     Warner warn = convertWarner(arg.pos(), arg.type, varArg);
1132                     assertConvertible(arg, arg.type, varArg, warn);
1133                     args = args.tail;
1134                 }
1135             } else if ((sym.flags() &amp; (VARARGS | SIGNATURE_POLYMORPHIC)) == VARARGS) {
1136                 // non-varargs call to varargs method
1137                 Type varParam = owntype.getParameterTypes().last();
1138                 Type lastArg = argtypes.last();
1139                 if (types.isSubtypeUnchecked(lastArg, types.elemtype(varParam)) &amp;&amp;
1140                     !types.isSameType(types.erasure(varParam), types.erasure(lastArg)))
1141                     log.warning(argtrees.last().pos(),
1142                                 Warnings.InexactNonVarargsCall(types.elemtype(varParam),varParam));
1143             }
1144         }
1145         if (useVarargs) {
1146             Type argtype = owntype.getParameterTypes().last();
1147             if (!types.isReifiable(argtype) &amp;&amp;
1148                 (sym.baseSymbol().attribute(syms.trustMeType.tsym) == null ||
1149                  !isTrustMeAllowedOnMethod(sym))) {
1150                 warnUnchecked(env.tree.pos(), Warnings.UncheckedGenericArrayCreation(argtype));
1151             }
1152             TreeInfo.setVarargsElement(env.tree, types.elemtype(argtype));
1153          }
1154          return owntype;
1155     }
1156     //where
1157     private void assertConvertible(JCTree tree, Type actual, Type formal, Warner warn) {
1158         if (types.isConvertible(actual, formal, warn))
1159             return;
1160 
1161         if (formal.isCompound()
1162             &amp;&amp; types.isSubtype(actual, types.supertype(formal))
1163             &amp;&amp; types.isSubtypeUnchecked(actual, types.interfaces(formal), warn))
1164             return;
1165     }
1166 
1167     /**
1168      * Check that type &#39;t&#39; is a valid instantiation of a generic class
1169      * (see JLS 4.5)
1170      *
1171      * @param t class type to be checked
1172      * @return true if &#39;t&#39; is well-formed
1173      */
1174     public boolean checkValidGenericType(Type t) {
1175         return firstIncompatibleTypeArg(t) == null;
1176     }
1177     //WHERE
1178         private Type firstIncompatibleTypeArg(Type type) {
1179             List&lt;Type&gt; formals = type.tsym.type.allparams();
1180             List&lt;Type&gt; actuals = type.allparams();
1181             List&lt;Type&gt; args = type.getTypeArguments();
1182             List&lt;Type&gt; forms = type.tsym.type.getTypeArguments();
1183             ListBuffer&lt;Type&gt; bounds_buf = new ListBuffer&lt;&gt;();
1184 
1185             // For matching pairs of actual argument types `a&#39; and
1186             // formal type parameters with declared bound `b&#39; ...
1187             while (args.nonEmpty() &amp;&amp; forms.nonEmpty()) {
1188                 // exact type arguments needs to know their
1189                 // bounds (for upper and lower bound
1190                 // calculations).  So we create new bounds where
1191                 // type-parameters are replaced with actuals argument types.
1192                 bounds_buf.append(types.subst(forms.head.getUpperBound(), formals, actuals));
1193                 args = args.tail;
1194                 forms = forms.tail;
1195             }
1196 
1197             args = type.getTypeArguments();
1198             List&lt;Type&gt; tvars_cap = types.substBounds(formals,
1199                                       formals,
1200                                       types.capture(type).allparams());
1201             while (args.nonEmpty() &amp;&amp; tvars_cap.nonEmpty()) {
1202                 // Let the actual arguments know their bound
1203                 args.head.withTypeVar((TypeVar)tvars_cap.head);
1204                 args = args.tail;
1205                 tvars_cap = tvars_cap.tail;
1206             }
1207 
1208             args = type.getTypeArguments();
1209             List&lt;Type&gt; bounds = bounds_buf.toList();
1210 
1211             while (args.nonEmpty() &amp;&amp; bounds.nonEmpty()) {
1212                 Type actual = args.head;
1213                 if (!isTypeArgErroneous(actual) &amp;&amp;
1214                         !bounds.head.isErroneous() &amp;&amp;
1215                         !checkExtends(actual, bounds.head)) {
1216                     return args.head;
1217                 }
1218                 args = args.tail;
1219                 bounds = bounds.tail;
1220             }
1221 
1222             args = type.getTypeArguments();
1223             bounds = bounds_buf.toList();
1224 
1225             for (Type arg : types.capture(type).getTypeArguments()) {
1226                 if (arg.hasTag(TYPEVAR) &amp;&amp;
1227                         arg.getUpperBound().isErroneous() &amp;&amp;
1228                         !bounds.head.isErroneous() &amp;&amp;
1229                         !isTypeArgErroneous(args.head)) {
1230                     return args.head;
1231                 }
1232                 bounds = bounds.tail;
1233                 args = args.tail;
1234             }
1235 
1236             return null;
1237         }
1238         //where
1239         boolean isTypeArgErroneous(Type t) {
1240             return isTypeArgErroneous.visit(t);
1241         }
1242 
1243         Types.UnaryVisitor&lt;Boolean&gt; isTypeArgErroneous = new Types.UnaryVisitor&lt;Boolean&gt;() {
1244             public Boolean visitType(Type t, Void s) {
1245                 return t.isErroneous();
1246             }
1247             @Override
1248             public Boolean visitTypeVar(TypeVar t, Void s) {
1249                 return visit(t.getUpperBound());
1250             }
1251             @Override
1252             public Boolean visitCapturedType(CapturedType t, Void s) {
1253                 return visit(t.getUpperBound()) ||
1254                         visit(t.getLowerBound());
1255             }
1256             @Override
1257             public Boolean visitWildcardType(WildcardType t, Void s) {
1258                 return visit(t.type);
1259             }
1260         };
1261 
1262     /** Check that given modifiers are legal for given symbol and
1263      *  return modifiers together with any implicit modifiers for that symbol.
1264      *  Warning: we can&#39;t use flags() here since this method
1265      *  is called during class enter, when flags() would cause a premature
1266      *  completion.
1267      *  @param pos           Position to be used for error reporting.
1268      *  @param flags         The set of modifiers given in a definition.
1269      *  @param sym           The defined symbol.
1270      */
1271     long checkFlags(DiagnosticPosition pos, long flags, Symbol sym, JCTree tree) {
1272         long mask;
1273         long implicit = 0;
1274 
1275         switch (sym.kind) {
1276         case VAR:
1277             if (TreeInfo.isReceiverParam(tree))
1278                 mask = ReceiverParamFlags;
1279             else if (sym.owner.kind != TYP)
1280                 mask = LocalVarFlags;
1281             else if ((sym.owner.flags_field &amp; INTERFACE) != 0)
1282                 mask = implicit = InterfaceVarFlags;
1283             else {
1284                 mask = VarFlags;
1285                 if (types.isValue(sym.owner.type) &amp;&amp; (flags &amp; STATIC) == 0) {
1286                     implicit |= FINAL;
1287                 }
1288             }
1289             break;
1290         case MTH:
1291             if (sym.name == names.init) {
1292                 if ((sym.owner.flags_field &amp; ENUM) != 0) {
1293                     // enum constructors cannot be declared public or
1294                     // protected and must be implicitly or explicitly
1295                     // private
1296                     implicit = PRIVATE;
1297                     mask = PRIVATE;
1298                 } else
1299                     mask = ConstructorFlags;
1300             }  else if ((sym.owner.flags_field &amp; INTERFACE) != 0) {
1301                 if ((sym.owner.flags_field &amp; ANNOTATION) != 0) {
1302                     mask = AnnotationTypeElementMask;
1303                     implicit = PUBLIC | ABSTRACT;
1304                 } else if ((flags &amp; (DEFAULT | STATIC | PRIVATE)) != 0) {
1305                     mask = InterfaceMethodMask;
1306                     implicit = (flags &amp; PRIVATE) != 0 ? 0 : PUBLIC;
1307                     if ((flags &amp; DEFAULT) != 0) {
1308                         implicit |= ABSTRACT;
1309                     }
1310                 } else {
1311                     mask = implicit = InterfaceMethodFlags;
1312                 }
1313             } else if ((sym.owner.flags_field &amp; RECORD) != 0) {
1314                 mask = RecordMethodFlags;
1315             } else {
1316                 // instance methods of value types do not have a monitor associated with their `this&#39;
1317                 mask = ((sym.owner.flags_field &amp; VALUE) != 0 &amp;&amp; (flags &amp; Flags.STATIC) == 0) ?
1318                         MethodFlags &amp; ~SYNCHRONIZED : MethodFlags;
1319             }
1320             // Imply STRICTFP if owner has STRICTFP set.
1321             if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
1322                 ((flags) &amp; Flags.DEFAULT) != 0)
1323                 implicit |= sym.owner.flags_field &amp; STRICTFP;
1324             break;
1325         case TYP:
1326             if (sym.isLocal()) {
1327                 mask = (flags &amp; RECORD) != 0 ? LocalRecordFlags : LocalClassFlags;
1328                 if ((flags &amp; RECORD) != 0) {
1329                     implicit = STATIC;
1330                     if (sym.owner.kind == TYP) {
1331                         log.error(pos, Errors.RecordDeclarationNotAllowedInInnerClasses);
1332                     }
1333                 }
1334                 if ((sym.owner.flags_field &amp; STATIC) == 0 &amp;&amp;
1335                     (flags &amp; ENUM) != 0) {
1336                     log.error(pos, Errors.EnumsMustBeStatic);
1337                 }
1338             } else if (sym.owner.kind == TYP) {
1339                 mask = (flags &amp; RECORD) != 0 ? MemberRecordFlags : MemberClassFlags;
1340                 if (sym.owner.owner.kind == PCK ||
1341                     (sym.owner.flags_field &amp; STATIC) != 0)
1342                     mask |= STATIC;
1343                 else if ((flags &amp; ENUM) != 0) {
1344                     log.error(pos, Errors.EnumsMustBeStatic);
1345                 } else if ((flags &amp; RECORD) != 0) {
1346                     log.error(pos, Errors.RecordDeclarationNotAllowedInInnerClasses);
1347                 }
1348                 // Nested interfaces and enums are always STATIC (Spec ???)
1349                 if ((flags &amp; (INTERFACE | ENUM | RECORD)) != 0 ) implicit = STATIC;
1350             } else {
1351                 mask = ClassFlags;
1352             }
1353             // Interfaces are always ABSTRACT
1354             if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
1355 
1356             if ((flags &amp; ENUM) != 0) {
1357                 // enums can&#39;t be declared abstract or final or value type
1358                 mask &amp;= ~(ABSTRACT | FINAL | VALUE);
1359                 implicit |= implicitEnumFinalFlag(tree);
1360             }
1361             if ((flags &amp; RECORD) != 0) {
1362                 // records can&#39;t be declared abstract
1363                 mask &amp;= ~ABSTRACT;
1364                 implicit |= FINAL;
1365             }
1366             // Imply STRICTFP if owner has STRICTFP set.
1367             implicit |= sym.owner.flags_field &amp; STRICTFP;
1368             break;
1369         default:
1370             throw new AssertionError();
1371         }
1372         long illegal = flags &amp; ExtendedStandardFlags &amp; ~mask;
1373         if (illegal != 0) {
1374             if ((illegal &amp; INTERFACE) != 0) {
1375                 log.error(pos, ((flags &amp; ANNOTATION) != 0) ? Errors.AnnotationDeclNotAllowedHere : Errors.IntfNotAllowedHere);
1376                 mask |= INTERFACE;
1377             }
1378             else {
1379                 log.error(pos,
1380                           Errors.ModNotAllowedHere(asFlagSet(illegal)));
1381             }
1382         }
1383         else if ((sym.kind == TYP ||
1384                   // ISSUE: Disallowing abstract&amp;private is no longer appropriate
1385                   // in the presence of inner classes. Should it be deleted here?
1386                   checkDisjoint(pos, flags,
1387                                 ABSTRACT,
1388                                 PRIVATE | STATIC | DEFAULT))
1389                  &amp;&amp;
1390                  checkDisjoint(pos, flags,
1391                                 STATIC | PRIVATE,
1392                                 DEFAULT)
1393                  &amp;&amp;
1394                  checkDisjoint(pos, flags,
1395                                ABSTRACT | INTERFACE,
1396                                FINAL | NATIVE | SYNCHRONIZED | VALUE)
1397                  &amp;&amp;
1398                  checkDisjoint(pos, flags,
1399                                PUBLIC,
1400                                PRIVATE | PROTECTED)
1401                  &amp;&amp;
1402                  checkDisjoint(pos, flags,
1403                                PRIVATE,
1404                                PUBLIC | PROTECTED)
1405                  &amp;&amp;
1406                  checkDisjoint(pos, flags,
1407                                FINAL,
1408                                VOLATILE)
1409                  &amp;&amp;
1410                  (sym.kind == TYP ||
1411                   checkDisjoint(pos, flags,
1412                                 ABSTRACT | NATIVE,
1413                                 STRICTFP))) {
1414             // skip
1415         }
1416         return flags &amp; (mask | ~ExtendedStandardFlags) | implicit;
1417     }
1418 
1419 
1420     /** Determine if this enum should be implicitly final.
1421      *
1422      *  If the enum has no specialized enum constants, it is final.
1423      *
1424      *  If the enum does have specialized enum constants, it is
1425      *  &lt;i&gt;not&lt;/i&gt; final.
1426      */
1427     private long implicitEnumFinalFlag(JCTree tree) {
1428         if (!tree.hasTag(CLASSDEF)) return 0;
1429         class SpecialTreeVisitor extends JCTree.Visitor {
1430             boolean specialized;
1431             SpecialTreeVisitor() {
1432                 this.specialized = false;
1433             }
1434 
1435             @Override
1436             public void visitTree(JCTree tree) { /* no-op */ }
1437 
1438             @Override
1439             public void visitVarDef(JCVariableDecl tree) {
1440                 if ((tree.mods.flags &amp; ENUM) != 0) {
1441                     if (tree.init instanceof JCNewClass &amp;&amp;
1442                         ((JCNewClass) tree.init).def != null) {
1443                         specialized = true;
1444                     }
1445                 }
1446             }
1447         }
1448 
1449         SpecialTreeVisitor sts = new SpecialTreeVisitor();
1450         JCClassDecl cdef = (JCClassDecl) tree;
1451         for (JCTree defs: cdef.defs) {
1452             defs.accept(sts);
1453             if (sts.specialized) return 0;
1454         }
1455         return FINAL;
1456     }
1457 
1458 /* *************************************************************************
1459  * Type Validation
1460  **************************************************************************/
1461 
1462     /** Validate a type expression. That is,
1463      *  check that all type arguments of a parametric type are within
1464      *  their bounds. This must be done in a second phase after type attribution
1465      *  since a class might have a subclass as type parameter bound. E.g:
1466      *
1467      *  &lt;pre&gt;{@code
1468      *  class B&lt;A extends C&gt; { ... }
1469      *  class C extends B&lt;C&gt; { ... }
1470      *  }&lt;/pre&gt;
1471      *
1472      *  and we can&#39;t make sure that the bound is already attributed because
1473      *  of possible cycles.
1474      *
1475      * Visitor method: Validate a type expression, if it is not null, catching
1476      *  and reporting any completion failures.
1477      */
1478     void validate(JCTree tree, Env&lt;AttrContext&gt; env) {
1479         validate(tree, env, true);
1480     }
1481     void validate(JCTree tree, Env&lt;AttrContext&gt; env, boolean checkRaw) {
1482         new Validator(env).validateTree(tree, checkRaw, true);
1483     }
1484 
1485     /** Visitor method: Validate a list of type expressions.
1486      */
1487     void validate(List&lt;? extends JCTree&gt; trees, Env&lt;AttrContext&gt; env) {
1488         for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
1489             validate(l.head, env);
1490     }
1491 
1492     /** A visitor class for type validation.
1493      */
1494     class Validator extends JCTree.Visitor {
1495 
1496         boolean checkRaw;
1497         boolean isOuter;
1498         Env&lt;AttrContext&gt; env;
1499 
1500         Validator(Env&lt;AttrContext&gt; env) {
1501             this.env = env;
1502         }
1503 
1504         @Override
1505         public void visitTypeArray(JCArrayTypeTree tree) {
1506             validateTree(tree.elemtype, checkRaw, isOuter);
1507         }
1508 
1509         @Override
1510         public void visitTypeApply(JCTypeApply tree) {
1511             if (tree.type.hasTag(CLASS)) {
1512                 List&lt;JCExpression&gt; args = tree.arguments;
1513                 List&lt;Type&gt; forms = tree.type.tsym.type.getTypeArguments();
1514 
1515                 Type incompatibleArg = firstIncompatibleTypeArg(tree.type);
1516                 if (incompatibleArg != null) {
1517                     for (JCTree arg : tree.arguments) {
1518                         if (arg.type == incompatibleArg) {
1519                             log.error(arg, Errors.NotWithinBounds(incompatibleArg, forms.head));
1520                         }
1521                         forms = forms.tail;
1522                      }
1523                  }
1524 
1525                 forms = tree.type.tsym.type.getTypeArguments();
1526 
1527                 boolean is_java_lang_Class = tree.type.tsym.flatName() == names.java_lang_Class;
1528 
1529                 // For matching pairs of actual argument types `a&#39; and
1530                 // formal type parameters with declared bound `b&#39; ...
1531                 while (args.nonEmpty() &amp;&amp; forms.nonEmpty()) {
1532                     validateTree(args.head,
1533                             !(isOuter &amp;&amp; is_java_lang_Class),
1534                             false);
1535                     args = args.tail;
1536                     forms = forms.tail;
1537                 }
1538 
1539                 // Check that this type is either fully parameterized, or
1540                 // not parameterized at all.
1541                 if (tree.type.getEnclosingType().isRaw())
1542                     log.error(tree.pos(), Errors.ImproperlyFormedTypeInnerRawParam);
1543                 if (tree.clazz.hasTag(SELECT))
1544                     visitSelectInternal((JCFieldAccess)tree.clazz);
1545             }
1546         }
1547 
1548         @Override
1549         public void visitTypeParameter(JCTypeParameter tree) {
1550             validateTrees(tree.bounds, true, isOuter);
1551             checkClassBounds(tree.pos(), tree.type);
1552         }
1553 
1554         @Override
1555         public void visitWildcard(JCWildcard tree) {
1556             if (tree.inner != null)
1557                 validateTree(tree.inner, true, isOuter);
1558         }
1559 
1560         @Override
1561         public void visitSelect(JCFieldAccess tree) {
1562             if (tree.type.hasTag(CLASS)) {
1563                 visitSelectInternal(tree);
1564 
1565                 // Check that this type is either fully parameterized, or
1566                 // not parameterized at all.
1567                 if (tree.selected.type.isParameterized() &amp;&amp; tree.type.tsym.type.getTypeArguments().nonEmpty())
1568                     log.error(tree.pos(), Errors.ImproperlyFormedTypeParamMissing);
1569             }
1570         }
1571 
1572         public void visitSelectInternal(JCFieldAccess tree) {
1573             if (tree.type.tsym.isStatic() &amp;&amp;
1574                 tree.selected.type.isParameterized()) {
1575                 // The enclosing type is not a class, so we are
1576                 // looking at a static member type.  However, the
1577                 // qualifying expression is parameterized.
1578                 log.error(tree.pos(), Errors.CantSelectStaticClassFromParamType);
1579             } else {
1580                 // otherwise validate the rest of the expression
1581                 tree.selected.accept(this);
1582             }
1583         }
1584 
1585         @Override
1586         public void visitAnnotatedType(JCAnnotatedType tree) {
1587             tree.underlyingType.accept(this);
1588         }
1589 
1590         @Override
1591         public void visitTypeIdent(JCPrimitiveTypeTree that) {
1592             if (that.type.hasTag(TypeTag.VOID)) {
1593                 log.error(that.pos(), Errors.VoidNotAllowedHere);
1594             }
1595             super.visitTypeIdent(that);
1596         }
1597 
1598         /** Default visitor method: do nothing.
1599          */
1600         @Override
1601         public void visitTree(JCTree tree) {
1602         }
1603 
1604         public void validateTree(JCTree tree, boolean checkRaw, boolean isOuter) {
1605             if (tree != null) {
1606                 boolean prevCheckRaw = this.checkRaw;
1607                 this.checkRaw = checkRaw;
1608                 this.isOuter = isOuter;
1609 
1610                 try {
1611                     tree.accept(this);
1612                     if (checkRaw)
1613                         checkRaw(tree, env);
1614                 } catch (CompletionFailure ex) {
1615                     completionError(tree.pos(), ex);
1616                 } finally {
1617                     this.checkRaw = prevCheckRaw;
1618                 }
1619             }
1620         }
1621 
1622         public void validateTrees(List&lt;? extends JCTree&gt; trees, boolean checkRaw, boolean isOuter) {
1623             for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
1624                 validateTree(l.head, checkRaw, isOuter);
1625         }
1626     }
1627 
1628     void checkRaw(JCTree tree, Env&lt;AttrContext&gt; env) {
1629         if (lint.isEnabled(LintCategory.RAW) &amp;&amp;
1630             tree.type.hasTag(CLASS) &amp;&amp;
1631             !TreeInfo.isDiamond(tree) &amp;&amp;
1632             !withinAnonConstr(env) &amp;&amp;
1633             tree.type.isRaw()) {
1634             log.warning(LintCategory.RAW,
1635                     tree.pos(), Warnings.RawClassUse(tree.type, tree.type.tsym.type));
1636         }
1637     }
1638     //where
1639         private boolean withinAnonConstr(Env&lt;AttrContext&gt; env) {
1640             return env.enclClass.name.isEmpty() &amp;&amp;
1641                     env.enclMethod != null &amp;&amp; env.enclMethod.name == names.init;
1642         }
1643 
1644 /* *************************************************************************
1645  * Exception checking
1646  **************************************************************************/
1647 
1648     /* The following methods treat classes as sets that contain
1649      * the class itself and all their subclasses
1650      */
1651 
1652     /** Is given type a subtype of some of the types in given list?
1653      */
1654     boolean subset(Type t, List&lt;Type&gt; ts) {
1655         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1656             if (types.isSubtype(t, l.head)) return true;
1657         return false;
1658     }
1659 
1660     /** Is given type a subtype or supertype of
1661      *  some of the types in given list?
1662      */
1663     boolean intersects(Type t, List&lt;Type&gt; ts) {
1664         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1665             if (types.isSubtype(t, l.head) || types.isSubtype(l.head, t)) return true;
1666         return false;
1667     }
1668 
1669     /** Add type set to given type list, unless it is a subclass of some class
1670      *  in the list.
1671      */
1672     List&lt;Type&gt; incl(Type t, List&lt;Type&gt; ts) {
1673         return subset(t, ts) ? ts : excl(t, ts).prepend(t);
1674     }
1675 
1676     /** Remove type set from type set list.
1677      */
1678     List&lt;Type&gt; excl(Type t, List&lt;Type&gt; ts) {
1679         if (ts.isEmpty()) {
1680             return ts;
1681         } else {
1682             List&lt;Type&gt; ts1 = excl(t, ts.tail);
1683             if (types.isSubtype(ts.head, t)) return ts1;
1684             else if (ts1 == ts.tail) return ts;
1685             else return ts1.prepend(ts.head);
1686         }
1687     }
1688 
1689     /** Form the union of two type set lists.
1690      */
1691     List&lt;Type&gt; union(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1692         List&lt;Type&gt; ts = ts1;
1693         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1694             ts = incl(l.head, ts);
1695         return ts;
1696     }
1697 
1698     /** Form the difference of two type lists.
1699      */
1700     List&lt;Type&gt; diff(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1701         List&lt;Type&gt; ts = ts1;
1702         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1703             ts = excl(l.head, ts);
1704         return ts;
1705     }
1706 
1707     /** Form the intersection of two type lists.
1708      */
1709     public List&lt;Type&gt; intersect(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1710         List&lt;Type&gt; ts = List.nil();
1711         for (List&lt;Type&gt; l = ts1; l.nonEmpty(); l = l.tail)
1712             if (subset(l.head, ts2)) ts = incl(l.head, ts);
1713         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1714             if (subset(l.head, ts1)) ts = incl(l.head, ts);
1715         return ts;
1716     }
1717 
1718     /** Is exc an exception symbol that need not be declared?
1719      */
1720     boolean isUnchecked(ClassSymbol exc) {
1721         return
1722             exc.kind == ERR ||
1723             exc.isSubClass(syms.errorType.tsym, types) ||
1724             exc.isSubClass(syms.runtimeExceptionType.tsym, types);
1725     }
1726 
1727     /** Is exc an exception type that need not be declared?
1728      */
1729     boolean isUnchecked(Type exc) {
1730         return
1731             (exc.hasTag(TYPEVAR)) ? isUnchecked(types.supertype(exc)) :
1732             (exc.hasTag(CLASS)) ? isUnchecked((ClassSymbol)exc.tsym) :
1733             exc.hasTag(BOT);
1734     }
1735 
1736     boolean isChecked(Type exc) {
1737         return !isUnchecked(exc);
1738     }
1739 
1740     /** Same, but handling completion failures.
1741      */
1742     boolean isUnchecked(DiagnosticPosition pos, Type exc) {
1743         try {
1744             return isUnchecked(exc);
1745         } catch (CompletionFailure ex) {
1746             completionError(pos, ex);
1747             return true;
1748         }
1749     }
1750 
1751     /** Is exc handled by given exception list?
1752      */
1753     boolean isHandled(Type exc, List&lt;Type&gt; handled) {
1754         return isUnchecked(exc) || subset(exc, handled);
1755     }
1756 
1757     /** Return all exceptions in thrown list that are not in handled list.
1758      *  @param thrown     The list of thrown exceptions.
1759      *  @param handled    The list of handled exceptions.
1760      */
1761     List&lt;Type&gt; unhandled(List&lt;Type&gt; thrown, List&lt;Type&gt; handled) {
1762         List&lt;Type&gt; unhandled = List.nil();
1763         for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
1764             if (!isHandled(l.head, handled)) unhandled = unhandled.prepend(l.head);
1765         return unhandled;
1766     }
1767 
1768 /* *************************************************************************
1769  * Overriding/Implementation checking
1770  **************************************************************************/
1771 
1772     /** The level of access protection given by a flag set,
1773      *  where PRIVATE is highest and PUBLIC is lowest.
1774      */
1775     static int protection(long flags) {
1776         switch ((short)(flags &amp; AccessFlags)) {
1777         case PRIVATE: return 3;
1778         case PROTECTED: return 1;
1779         default:
1780         case PUBLIC: return 0;
1781         case 0: return 2;
1782         }
1783     }
1784 
1785     /** A customized &quot;cannot override&quot; error message.
1786      *  @param m      The overriding method.
1787      *  @param other  The overridden method.
1788      *  @return       An internationalized string.
1789      */
1790     Fragment cannotOverride(MethodSymbol m, MethodSymbol other) {
1791         Symbol mloc = m.location();
1792         Symbol oloc = other.location();
1793 
1794         if ((other.owner.flags() &amp; INTERFACE) == 0)
1795             return Fragments.CantOverride(m, mloc, other, oloc);
1796         else if ((m.owner.flags() &amp; INTERFACE) == 0)
1797             return Fragments.CantImplement(m, mloc, other, oloc);
1798         else
1799             return Fragments.ClashesWith(m, mloc, other, oloc);
1800     }
1801 
1802     /** A customized &quot;override&quot; warning message.
1803      *  @param m      The overriding method.
1804      *  @param other  The overridden method.
1805      *  @return       An internationalized string.
1806      */
1807     Fragment uncheckedOverrides(MethodSymbol m, MethodSymbol other) {
1808         Symbol mloc = m.location();
1809         Symbol oloc = other.location();
1810 
1811         if ((other.owner.flags() &amp; INTERFACE) == 0)
1812             return Fragments.UncheckedOverride(m, mloc, other, oloc);
1813         else if ((m.owner.flags() &amp; INTERFACE) == 0)
1814             return Fragments.UncheckedImplement(m, mloc, other, oloc);
1815         else
1816             return Fragments.UncheckedClashWith(m, mloc, other, oloc);
1817     }
1818 
1819     /** A customized &quot;override&quot; warning message.
1820      *  @param m      The overriding method.
1821      *  @param other  The overridden method.
1822      *  @return       An internationalized string.
1823      */
1824     Fragment varargsOverrides(MethodSymbol m, MethodSymbol other) {
1825         Symbol mloc = m.location();
1826         Symbol oloc = other.location();
1827 
1828         if ((other.owner.flags() &amp; INTERFACE) == 0)
1829             return Fragments.VarargsOverride(m, mloc, other, oloc);
1830         else  if ((m.owner.flags() &amp; INTERFACE) == 0)
1831             return Fragments.VarargsImplement(m, mloc, other, oloc);
1832         else
1833             return Fragments.VarargsClashWith(m, mloc, other, oloc);
1834     }
1835 
1836     /** Check that this method conforms with overridden method &#39;other&#39;.
1837      *  where `origin&#39; is the class where checking started.
1838      *  Complications:
1839      *  (1) Do not check overriding of synthetic methods
1840      *      (reason: they might be final).
1841      *      todo: check whether this is still necessary.
1842      *  (2) Admit the case where an interface proxy throws fewer exceptions
1843      *      than the method it implements. Augment the proxy methods with the
1844      *      undeclared exceptions in this case.
1845      *  (3) When generics are enabled, admit the case where an interface proxy
1846      *      has a result type
1847      *      extended by the result type of the method it implements.
1848      *      Change the proxies result type to the smaller type in this case.
1849      *
1850      *  @param tree         The tree from which positions
1851      *                      are extracted for errors.
1852      *  @param m            The overriding method.
1853      *  @param other        The overridden method.
1854      *  @param origin       The class of which the overriding method
1855      *                      is a member.
1856      */
1857     void checkOverride(JCTree tree,
1858                        MethodSymbol m,
1859                        MethodSymbol other,
1860                        ClassSymbol origin) {
1861         // Don&#39;t check overriding of synthetic methods or by bridge methods.
1862         if ((m.flags() &amp; (SYNTHETIC|BRIDGE)) != 0 || (other.flags() &amp; SYNTHETIC) != 0) {
1863             return;
1864         }
1865 
1866         // Error if static method overrides instance method (JLS 8.4.6.2).
1867         if ((m.flags() &amp; STATIC) != 0 &amp;&amp;
1868                    (other.flags() &amp; STATIC) == 0) {
1869             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1870                       Errors.OverrideStatic(cannotOverride(m, other)));
1871             m.flags_field |= BAD_OVERRIDE;
1872             return;
1873         }
1874 
1875         // Error if instance method overrides static or final
1876         // method (JLS 8.4.6.1).
1877         if ((other.flags() &amp; FINAL) != 0 ||
1878                  (m.flags() &amp; STATIC) == 0 &amp;&amp;
1879                  (other.flags() &amp; STATIC) != 0) {
1880             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1881                       Errors.OverrideMeth(cannotOverride(m, other),
1882                                           asFlagSet(other.flags() &amp; (FINAL | STATIC))));
1883             m.flags_field |= BAD_OVERRIDE;
1884             return;
1885         }
1886 
1887         if ((m.owner.flags() &amp; ANNOTATION) != 0) {
1888             // handled in validateAnnotationMethod
1889             return;
1890         }
1891 
1892         // Error if overriding method has weaker access (JLS 8.4.6.3).
1893         if (protection(m.flags()) &gt; protection(other.flags())) {
1894             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1895                       (other.flags() &amp; AccessFlags) == 0 ?
1896                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1897                                                           &quot;package&quot;) :
1898                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1899                                                           asFlagSet(other.flags() &amp; AccessFlags)));
1900             m.flags_field |= BAD_OVERRIDE;
1901             return;
1902         }
1903 
1904         if (origin.isValue() &amp;&amp; other.owner == syms.objectType.tsym &amp;&amp; m.type.getParameterTypes().size() == 0) {
1905             if (m.name == names.clone || m.name == names.finalize) {
1906                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1907                         Errors.InlineClassMayNotOverride(m.name));
1908                 m.flags_field |= BAD_OVERRIDE;
1909                 return;
1910             }
1911         }
1912 
1913         Type mt = types.memberType(origin.type, m);
1914         Type ot = types.memberType(origin.type, other);
1915         // Error if overriding result type is different
1916         // (or, in the case of generics mode, not a subtype) of
1917         // overridden result type. We have to rename any type parameters
1918         // before comparing types.
1919         List&lt;Type&gt; mtvars = mt.getTypeArguments();
1920         List&lt;Type&gt; otvars = ot.getTypeArguments();
1921         Type mtres = mt.getReturnType();
1922         Type otres = types.subst(ot.getReturnType(), otvars, mtvars);
1923 
1924         overrideWarner.clear();
1925         boolean resultTypesOK =
1926             types.returnTypeSubstitutable(mt, ot, otres, overrideWarner);
1927         if (!resultTypesOK) {
1928             if ((m.flags() &amp; STATIC) != 0 &amp;&amp; (other.flags() &amp; STATIC) != 0) {
1929                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1930                           Errors.OverrideIncompatibleRet(Fragments.CantHide(m, m.location(), other,
1931                                         other.location()), mtres, otres));
1932                 m.flags_field |= BAD_OVERRIDE;
1933             } else {
1934                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1935                           Errors.OverrideIncompatibleRet(cannotOverride(m, other), mtres, otres));
1936                 m.flags_field |= BAD_OVERRIDE;
1937             }
1938             return;
1939         } else if (overrideWarner.hasNonSilentLint(LintCategory.UNCHECKED)) {
1940             warnUnchecked(TreeInfo.diagnosticPositionFor(m, tree),
1941                     Warnings.OverrideUncheckedRet(uncheckedOverrides(m, other), mtres, otres));
1942         }
1943 
1944         // Error if overriding method throws an exception not reported
1945         // by overridden method.
1946         List&lt;Type&gt; otthrown = types.subst(ot.getThrownTypes(), otvars, mtvars);
1947         List&lt;Type&gt; unhandledErased = unhandled(mt.getThrownTypes(), types.erasure(otthrown));
1948         List&lt;Type&gt; unhandledUnerased = unhandled(mt.getThrownTypes(), otthrown);
1949         if (unhandledErased.nonEmpty()) {
1950             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1951                       Errors.OverrideMethDoesntThrow(cannotOverride(m, other), unhandledUnerased.head));
1952             m.flags_field |= BAD_OVERRIDE;
1953             return;
1954         }
1955         else if (unhandledUnerased.nonEmpty()) {
1956             warnUnchecked(TreeInfo.diagnosticPositionFor(m, tree),
1957                           Warnings.OverrideUncheckedThrown(cannotOverride(m, other), unhandledUnerased.head));
1958             return;
1959         }
1960 
1961         // Optional warning if varargs don&#39;t agree
1962         if ((((m.flags() ^ other.flags()) &amp; Flags.VARARGS) != 0)
1963             &amp;&amp; lint.isEnabled(LintCategory.OVERRIDES)) {
1964             log.warning(TreeInfo.diagnosticPositionFor(m, tree),
1965                         ((m.flags() &amp; Flags.VARARGS) != 0)
1966                         ? Warnings.OverrideVarargsMissing(varargsOverrides(m, other))
1967                         : Warnings.OverrideVarargsExtra(varargsOverrides(m, other)));
1968         }
1969 
1970         // Warn if instance method overrides bridge method (compiler spec ??)
1971         if ((other.flags() &amp; BRIDGE) != 0) {
1972             log.warning(TreeInfo.diagnosticPositionFor(m, tree),
1973                         Warnings.OverrideBridge(uncheckedOverrides(m, other)));
1974         }
1975 
1976         // Warn if a deprecated method overridden by a non-deprecated one.
1977         if (!isDeprecatedOverrideIgnorable(other, origin)) {
1978             Lint prevLint = setLint(lint.augment(m));
1979             try {
1980                 checkDeprecated(() -&gt; TreeInfo.diagnosticPositionFor(m, tree), m, other);
1981             } finally {
1982                 setLint(prevLint);
1983             }
1984         }
1985     }
1986     // where
1987         private boolean isDeprecatedOverrideIgnorable(MethodSymbol m, ClassSymbol origin) {
1988             // If the method, m, is defined in an interface, then ignore the issue if the method
1989             // is only inherited via a supertype and also implemented in the supertype,
1990             // because in that case, we will rediscover the issue when examining the method
1991             // in the supertype.
1992             // If the method, m, is not defined in an interface, then the only time we need to
1993             // address the issue is when the method is the supertype implementation: any other
1994             // case, we will have dealt with when examining the supertype classes
1995             ClassSymbol mc = m.enclClass();
1996             Type st = types.supertype(origin.type);
1997             if (!st.hasTag(CLASS))
1998                 return true;
1999             MethodSymbol stimpl = m.implementation((ClassSymbol)st.tsym, types, false);
2000 
2001             if (mc != null &amp;&amp; ((mc.flags() &amp; INTERFACE) != 0)) {
2002                 List&lt;Type&gt; intfs = types.interfaces(origin.type);
2003                 return (intfs.contains(mc.type) ? false : (stimpl != null));
2004             }
2005             else
2006                 return (stimpl != m);
2007         }
2008 
2009 
2010     // used to check if there were any unchecked conversions
2011     Warner overrideWarner = new Warner();
2012 
2013     /** Check that a class does not inherit two concrete methods
2014      *  with the same signature.
2015      *  @param pos          Position to be used for error reporting.
2016      *  @param site         The class type to be checked.
2017      */
2018     public void checkCompatibleConcretes(DiagnosticPosition pos, Type site) {
2019         Type sup = types.supertype(site);
2020         if (!sup.hasTag(CLASS)) return;
2021 
2022         for (Type t1 = sup;
2023              t1.hasTag(CLASS) &amp;&amp; t1.tsym.type.isParameterized();
2024              t1 = types.supertype(t1)) {
2025             for (Symbol s1 : t1.tsym.members().getSymbols(NON_RECURSIVE)) {
2026                 if (s1.kind != MTH ||
2027                     (s1.flags() &amp; (STATIC|SYNTHETIC|BRIDGE)) != 0 ||
2028                     !s1.isInheritedIn(site.tsym, types) ||
2029                     ((MethodSymbol)s1).implementation(site.tsym,
2030                                                       types,
2031                                                       true) != s1)
2032                     continue;
2033                 Type st1 = types.memberType(t1, s1);
2034                 int s1ArgsLength = st1.getParameterTypes().length();
2035                 if (st1 == s1.type) continue;
2036 
2037                 for (Type t2 = sup;
2038                      t2.hasTag(CLASS);
2039                      t2 = types.supertype(t2)) {
2040                     for (Symbol s2 : t2.tsym.members().getSymbolsByName(s1.name)) {
2041                         if (s2 == s1 ||
2042                             s2.kind != MTH ||
2043                             (s2.flags() &amp; (STATIC|SYNTHETIC|BRIDGE)) != 0 ||
2044                             s2.type.getParameterTypes().length() != s1ArgsLength ||
2045                             !s2.isInheritedIn(site.tsym, types) ||
2046                             ((MethodSymbol)s2).implementation(site.tsym,
2047                                                               types,
2048                                                               true) != s2)
2049                             continue;
2050                         Type st2 = types.memberType(t2, s2);
2051                         if (types.overrideEquivalent(st1, st2))
2052                             log.error(pos,
2053                                       Errors.ConcreteInheritanceConflict(s1, t1, s2, t2, sup));
2054                     }
2055                 }
2056             }
2057         }
2058     }
2059 
2060     /** Check that classes (or interfaces) do not each define an abstract
2061      *  method with same name and arguments but incompatible return types.
2062      *  @param pos          Position to be used for error reporting.
2063      *  @param t1           The first argument type.
2064      *  @param t2           The second argument type.
2065      */
2066     public boolean checkCompatibleAbstracts(DiagnosticPosition pos,
2067                                             Type t1,
2068                                             Type t2,
2069                                             Type site) {
2070         if ((site.tsym.flags() &amp; COMPOUND) != 0) {
2071             // special case for intersections: need to eliminate wildcards in supertypes
2072             t1 = types.capture(t1);
2073             t2 = types.capture(t2);
2074         }
2075         return firstIncompatibility(pos, t1, t2, site) == null;
2076     }
2077 
2078     /** Return the first method which is defined with same args
2079      *  but different return types in two given interfaces, or null if none
2080      *  exists.
2081      *  @param t1     The first type.
2082      *  @param t2     The second type.
2083      *  @param site   The most derived type.
2084      *  @return symbol from t2 that conflicts with one in t1.
2085      */
2086     private Symbol firstIncompatibility(DiagnosticPosition pos, Type t1, Type t2, Type site) {
2087         Map&lt;TypeSymbol,Type&gt; interfaces1 = new HashMap&lt;&gt;();
2088         closure(t1, interfaces1);
2089         Map&lt;TypeSymbol,Type&gt; interfaces2;
2090         if (t1 == t2)
2091             interfaces2 = interfaces1;
2092         else
2093             closure(t2, interfaces1, interfaces2 = new HashMap&lt;&gt;());
2094 
2095         for (Type t3 : interfaces1.values()) {
2096             for (Type t4 : interfaces2.values()) {
2097                 Symbol s = firstDirectIncompatibility(pos, t3, t4, site);
2098                 if (s != null) return s;
2099             }
2100         }
2101         return null;
2102     }
2103 
2104     /** Compute all the supertypes of t, indexed by type symbol. */
2105     private void closure(Type t, Map&lt;TypeSymbol,Type&gt; typeMap) {
2106         if (!t.hasTag(CLASS)) return;
2107         if (typeMap.put(t.tsym, t) == null) {
2108             closure(types.supertype(t), typeMap);
2109             for (Type i : types.interfaces(t))
2110                 closure(i, typeMap);
2111         }
2112     }
2113 
2114     /** Compute all the supertypes of t, indexed by type symbol (except those in typesSkip). */
2115     private void closure(Type t, Map&lt;TypeSymbol,Type&gt; typesSkip, Map&lt;TypeSymbol,Type&gt; typeMap) {
2116         if (!t.hasTag(CLASS)) return;
2117         if (typesSkip.get(t.tsym) != null) return;
2118         if (typeMap.put(t.tsym, t) == null) {
2119             closure(types.supertype(t), typesSkip, typeMap);
2120             for (Type i : types.interfaces(t))
2121                 closure(i, typesSkip, typeMap);
2122         }
2123     }
2124 
2125     /** Return the first method in t2 that conflicts with a method from t1. */
2126     private Symbol firstDirectIncompatibility(DiagnosticPosition pos, Type t1, Type t2, Type site) {
2127         for (Symbol s1 : t1.tsym.members().getSymbols(NON_RECURSIVE)) {
2128             Type st1 = null;
2129             if (s1.kind != MTH || !s1.isInheritedIn(site.tsym, types) ||
2130                     (s1.flags() &amp; SYNTHETIC) != 0) continue;
2131             Symbol impl = ((MethodSymbol)s1).implementation(site.tsym, types, false);
2132             if (impl != null &amp;&amp; (impl.flags() &amp; ABSTRACT) == 0) continue;
2133             for (Symbol s2 : t2.tsym.members().getSymbolsByName(s1.name)) {
2134                 if (s1 == s2) continue;
2135                 if (s2.kind != MTH || !s2.isInheritedIn(site.tsym, types) ||
2136                         (s2.flags() &amp; SYNTHETIC) != 0) continue;
2137                 if (st1 == null) st1 = types.memberType(t1, s1);
2138                 Type st2 = types.memberType(t2, s2);
2139                 if (types.overrideEquivalent(st1, st2)) {
2140                     List&lt;Type&gt; tvars1 = st1.getTypeArguments();
2141                     List&lt;Type&gt; tvars2 = st2.getTypeArguments();
2142                     Type rt1 = st1.getReturnType();
2143                     Type rt2 = types.subst(st2.getReturnType(), tvars2, tvars1);
2144                     boolean compat =
2145                         types.isSameType(rt1, rt2) ||
2146                         !rt1.isPrimitiveOrVoid() &amp;&amp;
2147                         !rt2.isPrimitiveOrVoid() &amp;&amp;
2148                         (types.covariantReturnType(rt1, rt2, types.noWarnings) ||
2149                          types.covariantReturnType(rt2, rt1, types.noWarnings)) ||
2150                          checkCommonOverriderIn(s1,s2,site);
2151                     if (!compat) {
2152                         log.error(pos, Errors.TypesIncompatible(t1, t2,
2153                                 Fragments.IncompatibleDiffRet(s2.name, types.memberType(t2, s2).getParameterTypes())));
2154                         return s2;
2155                     }
2156                 } else if (checkNameClash((ClassSymbol)site.tsym, s1, s2) &amp;&amp;
2157                         !checkCommonOverriderIn(s1, s2, site)) {
2158                     log.error(pos, Errors.NameClashSameErasureNoOverride(
2159                             s1.name, types.memberType(site, s1).asMethodType().getParameterTypes(), s1.location(),
2160                             s2.name, types.memberType(site, s2).asMethodType().getParameterTypes(), s2.location()));
2161                     return s2;
2162                 }
2163             }
2164         }
2165         return null;
2166     }
2167     //WHERE
2168     boolean checkCommonOverriderIn(Symbol s1, Symbol s2, Type site) {
2169         Map&lt;TypeSymbol,Type&gt; supertypes = new HashMap&lt;&gt;();
2170         Type st1 = types.memberType(site, s1);
2171         Type st2 = types.memberType(site, s2);
2172         closure(site, supertypes);
2173         for (Type t : supertypes.values()) {
2174             for (Symbol s3 : t.tsym.members().getSymbolsByName(s1.name)) {
2175                 if (s3 == s1 || s3 == s2 || s3.kind != MTH || (s3.flags() &amp; (BRIDGE|SYNTHETIC)) != 0) continue;
2176                 Type st3 = types.memberType(site,s3);
2177                 if (types.overrideEquivalent(st3, st1) &amp;&amp;
2178                         types.overrideEquivalent(st3, st2) &amp;&amp;
2179                         types.returnTypeSubstitutable(st3, st1) &amp;&amp;
2180                         types.returnTypeSubstitutable(st3, st2)) {
2181                     return true;
2182                 }
2183             }
2184         }
2185         return false;
2186     }
2187 
2188     /** Check that a given method conforms with any method it overrides.
2189      *  @param tree         The tree from which positions are extracted
2190      *                      for errors.
2191      *  @param m            The overriding method.
2192      */
2193     void checkOverride(Env&lt;AttrContext&gt; env, JCMethodDecl tree, MethodSymbol m) {
2194         ClassSymbol origin = (ClassSymbol)m.owner;
2195         if ((origin.flags() &amp; ENUM) != 0 &amp;&amp; names.finalize.equals(m.name))
2196             if (m.overrides(syms.enumFinalFinalize, origin, types, false)) {
2197                 log.error(tree.pos(), Errors.EnumNoFinalize);
2198                 return;
2199             }
2200         for (Type t = origin.type; t.hasTag(CLASS);
2201              t = types.supertype(t)) {
2202             if (t != origin.type) {
2203                 checkOverride(tree, t, origin, m);
2204             }
2205             for (Type t2 : types.interfaces(t)) {
2206                 checkOverride(tree, t2, origin, m);
2207             }
2208         }
2209 
2210         final boolean explicitOverride = m.attribute(syms.overrideType.tsym) != null;
2211         // Check if this method must override a super method due to being annotated with @Override
2212         // or by virtue of being a member of a diamond inferred anonymous class. Latter case is to
2213         // be treated &quot;as if as they were annotated&quot; with @Override.
2214         boolean mustOverride = explicitOverride ||
2215                 (env.info.isAnonymousDiamond &amp;&amp; !m.isConstructor() &amp;&amp; !m.isPrivate() &amp;&amp;
2216                         (!m.owner.isValue() || (tree.body.flags &amp; SYNTHETIC) == 0));
2217         if (mustOverride &amp;&amp; !isOverrider(m)) {
2218             DiagnosticPosition pos = tree.pos();
2219             for (JCAnnotation a : tree.getModifiers().annotations) {
2220                 if (a.annotationType.type.tsym == syms.overrideType.tsym) {
2221                     pos = a.pos();
2222                     break;
2223                 }
2224             }
2225             log.error(pos,
2226                       explicitOverride ? (m.isStatic() ? Errors.StaticMethodsCannotBeAnnotatedWithOverride : Errors.MethodDoesNotOverrideSuperclass) :
2227                                 Errors.AnonymousDiamondMethodDoesNotOverrideSuperclass(Fragments.DiamondAnonymousMethodsImplicitlyOverride));
2228         }
2229     }
2230 
2231     void checkOverride(JCTree tree, Type site, ClassSymbol origin, MethodSymbol m) {
2232         TypeSymbol c = site.tsym;
2233         for (Symbol sym : c.members().getSymbolsByName(m.name)) {
2234             if (m.overrides(sym, origin, types, false)) {
2235                 if ((sym.flags() &amp; ABSTRACT) == 0) {
2236                     checkOverride(tree, m, (MethodSymbol)sym, origin);
2237                 }
2238             }
2239         }
2240     }
2241 
2242     private Filter&lt;Symbol&gt; equalsHasCodeFilter = s -&gt; MethodSymbol.implementation_filter.accepts(s) &amp;&amp;
2243             (s.flags() &amp; BAD_OVERRIDE) == 0;
2244 
2245     public void checkClassOverrideEqualsAndHashIfNeeded(DiagnosticPosition pos,
2246             ClassSymbol someClass) {
2247         /* At present, annotations cannot possibly have a method that is override
2248          * equivalent with Object.equals(Object) but in any case the condition is
2249          * fine for completeness.
2250          */
2251         if (someClass == (ClassSymbol)syms.objectType.tsym ||
2252             someClass.isInterface() || someClass.isEnum() ||
2253             (someClass.flags() &amp; ANNOTATION) != 0 ||
2254             (someClass.flags() &amp; ABSTRACT) != 0) return;
2255         //anonymous inner classes implementing interfaces need especial treatment
2256         if (someClass.isAnonymous()) {
2257             List&lt;Type&gt; interfaces =  types.interfaces(someClass.type);
2258             if (interfaces != null &amp;&amp; !interfaces.isEmpty() &amp;&amp;
2259                 interfaces.head.tsym == syms.comparatorType.tsym) return;
2260         }
2261         checkClassOverrideEqualsAndHash(pos, someClass);
2262     }
2263 
2264     private void checkClassOverrideEqualsAndHash(DiagnosticPosition pos,
2265             ClassSymbol someClass) {
2266         if (lint.isEnabled(LintCategory.OVERRIDES)) {
2267             MethodSymbol equalsAtObject = (MethodSymbol)syms.objectType
2268                     .tsym.members().findFirst(names.equals);
2269             MethodSymbol hashCodeAtObject = (MethodSymbol)syms.objectType
2270                     .tsym.members().findFirst(names.hashCode);
2271             boolean overridesEquals = types.implementation(equalsAtObject,
2272                 someClass, false, equalsHasCodeFilter).owner == someClass;
2273             boolean overridesHashCode = types.implementation(hashCodeAtObject,
2274                 someClass, false, equalsHasCodeFilter) != hashCodeAtObject;
2275 
2276             if (overridesEquals &amp;&amp; !overridesHashCode) {
2277                 log.warning(LintCategory.OVERRIDES, pos,
2278                             Warnings.OverrideEqualsButNotHashcode(someClass));
2279             }
2280         }
2281     }
2282 
2283     public void checkModuleName (JCModuleDecl tree) {
2284         Name moduleName = tree.sym.name;
2285         Assert.checkNonNull(moduleName);
2286         if (lint.isEnabled(LintCategory.MODULE)) {
2287             JCExpression qualId = tree.qualId;
2288             while (qualId != null) {
2289                 Name componentName;
2290                 DiagnosticPosition pos;
2291                 switch (qualId.getTag()) {
2292                     case SELECT:
2293                         JCFieldAccess selectNode = ((JCFieldAccess) qualId);
2294                         componentName = selectNode.name;
2295                         pos = selectNode.pos();
2296                         qualId = selectNode.selected;
2297                         break;
2298                     case IDENT:
2299                         componentName = ((JCIdent) qualId).name;
2300                         pos = qualId.pos();
2301                         qualId = null;
2302                         break;
2303                     default:
2304                         throw new AssertionError(&quot;Unexpected qualified identifier: &quot; + qualId.toString());
2305                 }
2306                 if (componentName != null) {
2307                     String moduleNameComponentString = componentName.toString();
2308                     int nameLength = moduleNameComponentString.length();
2309                     if (nameLength &gt; 0 &amp;&amp; Character.isDigit(moduleNameComponentString.charAt(nameLength - 1))) {
2310                         log.warning(Lint.LintCategory.MODULE, pos, Warnings.PoorChoiceForModuleName(componentName));
2311                     }
2312                 }
2313             }
2314         }
2315     }
2316 
2317     private boolean checkNameClash(ClassSymbol origin, Symbol s1, Symbol s2) {
2318         ClashFilter cf = new ClashFilter(origin.type);
2319         return (cf.accepts(s1) &amp;&amp;
2320                 cf.accepts(s2) &amp;&amp;
2321                 types.hasSameArgs(s1.erasure(types), s2.erasure(types)));
2322     }
2323 
2324 
2325     /** Check that all abstract members of given class have definitions.
2326      *  @param pos          Position to be used for error reporting.
2327      *  @param c            The class.
2328      */
2329     void checkAllDefined(DiagnosticPosition pos, ClassSymbol c) {
2330         MethodSymbol undef = types.firstUnimplementedAbstract(c);
2331         if (undef != null) {
2332             MethodSymbol undef1 =
2333                 new MethodSymbol(undef.flags(), undef.name,
2334                                  types.memberType(c.type, undef), undef.owner);
2335             log.error(pos,
2336                       Errors.DoesNotOverrideAbstract(c, undef1, undef1.location()));
2337         }
2338     }
2339 
2340     // A value class cannot contain a field of its own type either or indirectly.
2341     void checkNonCyclicMembership(JCClassDecl tree) {
2342         Assert.check((tree.sym.flags_field &amp; LOCKED) == 0);
2343         try {
2344             tree.sym.flags_field |= LOCKED;
2345             for (List&lt;? extends JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2346                 if (l.head.hasTag(VARDEF)) {
2347                     JCVariableDecl field = (JCVariableDecl) l.head;
2348                     if (cyclePossible(field.sym)) {
2349                         Type fieldType = field.sym.type;
2350                         checkNonCyclicMembership((ClassSymbol) fieldType.tsym, field.pos());
2351                     }
2352                 }
2353             }
2354         } finally {
2355             tree.sym.flags_field &amp;= ~LOCKED;
2356         }
2357 
2358     }
2359     // where
2360     private void checkNonCyclicMembership(ClassSymbol c, DiagnosticPosition pos) {
2361         if ((c.flags_field &amp; LOCKED) != 0) {
2362             log.error(pos, Errors.CyclicValueTypeMembership(c));
2363             return;
2364         }
2365         try {
2366             c.flags_field |= LOCKED;
2367             for (Symbol fld : c.members().getSymbols(s -&gt; s.kind == VAR &amp;&amp; cyclePossible((VarSymbol) s), NON_RECURSIVE)) {
2368                 checkNonCyclicMembership((ClassSymbol) fld.type.tsym, pos);
2369             }
2370         } finally {
2371             c.flags_field &amp;= ~LOCKED;
2372         }
2373     }
2374         // where
2375         private boolean cyclePossible(VarSymbol symbol) {
2376             return (symbol.flags() &amp; STATIC) == 0 &amp;&amp; types.isValue(symbol.type);
2377         }
2378 
2379     void checkNonCyclicDecl(JCClassDecl tree) {
2380         CycleChecker cc = new CycleChecker();
2381         cc.scan(tree);
2382         if (!cc.errorFound &amp;&amp; !cc.partialCheck) {
2383             tree.sym.flags_field |= ACYCLIC;
2384         }
2385     }
2386 
2387     class CycleChecker extends TreeScanner {
2388 
2389         List&lt;Symbol&gt; seenClasses = List.nil();
2390         boolean errorFound = false;
2391         boolean partialCheck = false;
2392 
2393         private void checkSymbol(DiagnosticPosition pos, Symbol sym) {
2394             if (sym != null &amp;&amp; sym.kind == TYP) {
2395                 Env&lt;AttrContext&gt; classEnv = enter.getEnv((TypeSymbol)sym);
2396                 if (classEnv != null) {
2397                     DiagnosticSource prevSource = log.currentSource();
2398                     try {
2399                         log.useSource(classEnv.toplevel.sourcefile);
2400                         scan(classEnv.tree);
2401                     }
2402                     finally {
2403                         log.useSource(prevSource.getFile());
2404                     }
2405                 } else if (sym.kind == TYP) {
2406                     checkClass(pos, sym, List.nil());
2407                 }
2408             } else {
2409                 //not completed yet
2410                 partialCheck = true;
2411             }
2412         }
2413 
2414         @Override
2415         public void visitSelect(JCFieldAccess tree) {
2416             super.visitSelect(tree);
2417             checkSymbol(tree.pos(), tree.sym);
2418         }
2419 
2420         @Override
2421         public void visitIdent(JCIdent tree) {
2422             checkSymbol(tree.pos(), tree.sym);
2423         }
2424 
2425         @Override
2426         public void visitTypeApply(JCTypeApply tree) {
2427             scan(tree.clazz);
2428         }
2429 
2430         @Override
2431         public void visitTypeArray(JCArrayTypeTree tree) {
2432             scan(tree.elemtype);
2433         }
2434 
2435         @Override
2436         public void visitClassDef(JCClassDecl tree) {
2437             List&lt;JCTree&gt; supertypes = List.nil();
2438             if (tree.getExtendsClause() != null) {
2439                 supertypes = supertypes.prepend(tree.getExtendsClause());
2440             }
2441             if (tree.getImplementsClause() != null) {
2442                 for (JCTree intf : tree.getImplementsClause()) {
2443                     supertypes = supertypes.prepend(intf);
2444                 }
2445             }
2446             checkClass(tree.pos(), tree.sym, supertypes);
2447         }
2448 
2449         void checkClass(DiagnosticPosition pos, Symbol c, List&lt;JCTree&gt; supertypes) {
2450             if ((c.flags_field &amp; ACYCLIC) != 0)
2451                 return;
2452             if (seenClasses.contains(c)) {
2453                 errorFound = true;
2454                 noteCyclic(pos, (ClassSymbol)c);
2455             } else if (!c.type.isErroneous()) {
2456                 try {
2457                     seenClasses = seenClasses.prepend(c);
2458                     if (c.type.hasTag(CLASS)) {
2459                         if (supertypes.nonEmpty()) {
2460                             scan(supertypes);
2461                         }
2462                         else {
2463                             ClassType ct = (ClassType)c.type;
2464                             if (ct.supertype_field == null ||
2465                                     ct.interfaces_field == null) {
2466                                 //not completed yet
2467                                 partialCheck = true;
2468                                 return;
2469                             }
2470                             checkSymbol(pos, ct.supertype_field.tsym);
2471                             for (Type intf : ct.interfaces_field) {
2472                                 checkSymbol(pos, intf.tsym);
2473                             }
2474                         }
2475                         if (c.owner.kind == TYP) {
2476                             checkSymbol(pos, c.owner);
2477                         }
2478                     }
2479                 } finally {
2480                     seenClasses = seenClasses.tail;
2481                 }
2482             }
2483         }
2484     }
2485 
2486     /** Check for cyclic references. Issue an error if the
2487      *  symbol of the type referred to has a LOCKED flag set.
2488      *
2489      *  @param pos      Position to be used for error reporting.
2490      *  @param t        The type referred to.
2491      */
2492     void checkNonCyclic(DiagnosticPosition pos, Type t) {
2493         checkNonCyclicInternal(pos, t);
2494     }
2495 
2496 
2497     void checkNonCyclic(DiagnosticPosition pos, TypeVar t) {
2498         checkNonCyclic1(pos, t, List.nil());
2499     }
2500 
2501     private void checkNonCyclic1(DiagnosticPosition pos, Type t, List&lt;TypeVar&gt; seen) {
2502         final TypeVar tv;
2503         if  (t.hasTag(TYPEVAR) &amp;&amp; (t.tsym.flags() &amp; UNATTRIBUTED) != 0)
2504             return;
2505         if (seen.contains(t)) {
2506             tv = (TypeVar)t;
2507             tv.setUpperBound(types.createErrorType(t));
2508             log.error(pos, Errors.CyclicInheritance(t));
2509         } else if (t.hasTag(TYPEVAR)) {
2510             tv = (TypeVar)t;
2511             seen = seen.prepend(tv);
2512             for (Type b : types.getBounds(tv))
2513                 checkNonCyclic1(pos, b, seen);
2514         }
2515     }
2516 
2517     /** Check for cyclic references. Issue an error if the
2518      *  symbol of the type referred to has a LOCKED flag set.
2519      *
2520      *  @param pos      Position to be used for error reporting.
2521      *  @param t        The type referred to.
2522      *  @returns        True if the check completed on all attributed classes
2523      */
2524     private boolean checkNonCyclicInternal(DiagnosticPosition pos, Type t) {
2525         boolean complete = true; // was the check complete?
2526         //- System.err.println(&quot;checkNonCyclicInternal(&quot;+t+&quot;);&quot;);//DEBUG
2527         Symbol c = t.tsym;
2528         if ((c.flags_field &amp; ACYCLIC) != 0) return true;
2529 
2530         if ((c.flags_field &amp; LOCKED) != 0) {
2531             noteCyclic(pos, (ClassSymbol)c);
2532         } else if (!c.type.isErroneous()) {
2533             try {
2534                 c.flags_field |= LOCKED;
2535                 if (c.type.hasTag(CLASS)) {
2536                     ClassType clazz = (ClassType)c.type;
2537                     if (clazz.interfaces_field != null)
2538                         for (List&lt;Type&gt; l=clazz.interfaces_field; l.nonEmpty(); l=l.tail)
2539                             complete &amp;= checkNonCyclicInternal(pos, l.head);
2540                     if (clazz.supertype_field != null) {
2541                         Type st = clazz.supertype_field;
2542                         if (st != null &amp;&amp; st.hasTag(CLASS))
2543                             complete &amp;= checkNonCyclicInternal(pos, st);
2544                     }
2545                     if (c.owner.kind == TYP)
2546                         complete &amp;= checkNonCyclicInternal(pos, c.owner.type);
2547                 }
2548             } finally {
2549                 c.flags_field &amp;= ~LOCKED;
2550             }
2551         }
2552         if (complete)
2553             complete = ((c.flags_field &amp; UNATTRIBUTED) == 0) &amp;&amp; c.isCompleted();
2554         if (complete) c.flags_field |= ACYCLIC;
2555         return complete;
2556     }
2557 
2558     /** Note that we found an inheritance cycle. */
2559     private void noteCyclic(DiagnosticPosition pos, ClassSymbol c) {
2560         log.error(pos, Errors.CyclicInheritance(c));
2561         for (List&lt;Type&gt; l=types.interfaces(c.type); l.nonEmpty(); l=l.tail)
2562             l.head = types.createErrorType((ClassSymbol)l.head.tsym, Type.noType);
2563         Type st = types.supertype(c.type);
2564         if (st.hasTag(CLASS))
2565             ((ClassType)c.type).supertype_field = types.createErrorType((ClassSymbol)st.tsym, Type.noType);
2566         c.type = types.createErrorType(c, c.type);
2567         c.flags_field |= ACYCLIC;
2568     }
2569 
2570     /** Check that all methods which implement some
2571      *  method conform to the method they implement.
2572      *  @param tree         The class definition whose members are checked.
2573      */
2574     void checkImplementations(JCClassDecl tree) {
2575         checkImplementations(tree, tree.sym, tree.sym);
2576     }
2577     //where
2578         /** Check that all methods which implement some
2579          *  method in `ic&#39; conform to the method they implement.
2580          */
2581         void checkImplementations(JCTree tree, ClassSymbol origin, ClassSymbol ic) {
2582             for (List&lt;Type&gt; l = types.closure(ic.type); l.nonEmpty(); l = l.tail) {
2583                 ClassSymbol lc = (ClassSymbol)l.head.tsym;
2584                 if ((lc.flags() &amp; ABSTRACT) != 0) {
2585                     for (Symbol sym : lc.members().getSymbols(NON_RECURSIVE)) {
2586                         if (sym.kind == MTH &amp;&amp;
2587                             (sym.flags() &amp; (STATIC|ABSTRACT)) == ABSTRACT) {
2588                             MethodSymbol absmeth = (MethodSymbol)sym;
2589                             MethodSymbol implmeth = absmeth.implementation(origin, types, false);
2590                             if (implmeth != null &amp;&amp; implmeth != absmeth &amp;&amp;
2591                                 (implmeth.owner.flags() &amp; INTERFACE) ==
2592                                 (origin.flags() &amp; INTERFACE)) {
2593                                 // don&#39;t check if implmeth is in a class, yet
2594                                 // origin is an interface. This case arises only
2595                                 // if implmeth is declared in Object. The reason is
2596                                 // that interfaces really don&#39;t inherit from
2597                                 // Object it&#39;s just that the compiler represents
2598                                 // things that way.
2599                                 checkOverride(tree, implmeth, absmeth, origin);
2600                             }
2601                         }
2602                     }
2603                 }
2604             }
2605         }
2606 
2607     /** Check that all abstract methods implemented by a class are
2608      *  mutually compatible.
2609      *  @param pos          Position to be used for error reporting.
2610      *  @param c            The class whose interfaces are checked.
2611      */
2612     void checkCompatibleSupertypes(DiagnosticPosition pos, Type c) {
2613         List&lt;Type&gt; supertypes = types.interfaces(c);
2614         Type supertype = types.supertype(c);
2615         if (supertype.hasTag(CLASS) &amp;&amp;
2616             (supertype.tsym.flags() &amp; ABSTRACT) != 0)
2617             supertypes = supertypes.prepend(supertype);
2618         for (List&lt;Type&gt; l = supertypes; l.nonEmpty(); l = l.tail) {
2619             if (!l.head.getTypeArguments().isEmpty() &amp;&amp;
2620                 !checkCompatibleAbstracts(pos, l.head, l.head, c))
2621                 return;
2622             for (List&lt;Type&gt; m = supertypes; m != l; m = m.tail)
2623                 if (!checkCompatibleAbstracts(pos, l.head, m.head, c))
2624                     return;
2625         }
2626         checkCompatibleConcretes(pos, c);
2627         boolean isIdentityObject = types.asSuper(c, syms.identityObjectType.tsym) != null;
2628         boolean isInlineObject = types.asSuper(c, syms.inlineObjectType.tsym) != null;
2629         if (types.isValue(c) &amp;&amp; isIdentityObject) {
2630             log.error(pos, Errors.InlineTypeMustNotImplementIdentityObject(c));
2631         } else if (!c.isInterface() &amp;&amp; !types.isValue(c) &amp;&amp; isInlineObject) {
2632             log.error(pos, Errors.IdentityTypeMustNotImplementInlineObject(c));
2633         } else if (isIdentityObject &amp;&amp; isInlineObject) {
2634             log.error(pos, Errors.MutuallyIncompatibleInterfaces(c));
2635         }
2636     }
2637 
2638     /** Check that all non-override equivalent methods accessible from &#39;site&#39;
2639      *  are mutually compatible (JLS 8.4.8/9.4.1).
2640      *
2641      *  @param pos  Position to be used for error reporting.
2642      *  @param site The class whose methods are checked.
2643      *  @param sym  The method symbol to be checked.
2644      */
2645     void checkOverrideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2646          ClashFilter cf = new ClashFilter(site);
2647         //for each method m1 that is overridden (directly or indirectly)
2648         //by method &#39;sym&#39; in &#39;site&#39;...
2649 
2650         List&lt;MethodSymbol&gt; potentiallyAmbiguousList = List.nil();
2651         boolean overridesAny = false;
2652         ArrayList&lt;Symbol&gt; symbolsByName = new ArrayList&lt;&gt;();
2653         types.membersClosure(site, false).getSymbolsByName(sym.name, cf).forEach(symbolsByName::add);
2654         for (Symbol m1 : symbolsByName) {
2655             if (!sym.overrides(m1, site.tsym, types, false)) {
2656                 if (m1 == sym) {
2657                     continue;
2658                 }
2659 
2660                 if (!overridesAny) {
2661                     potentiallyAmbiguousList = potentiallyAmbiguousList.prepend((MethodSymbol)m1);
2662                 }
2663                 continue;
2664             }
2665 
2666             if (m1 != sym) {
2667                 overridesAny = true;
2668                 potentiallyAmbiguousList = List.nil();
2669             }
2670 
2671             //...check each method m2 that is a member of &#39;site&#39;
2672             for (Symbol m2 : symbolsByName) {
2673                 if (m2 == m1) continue;
2674                 //if (i) the signature of &#39;sym&#39; is not a subsignature of m1 (seen as
2675                 //a member of &#39;site&#39;) and (ii) m1 has the same erasure as m2, issue an error
2676                 if (!types.isSubSignature(sym.type, types.memberType(site, m2), Feature.STRICT_METHOD_CLASH_CHECK.allowedInSource(source)) &amp;&amp;
2677                         types.hasSameArgs(m2.erasure(types), m1.erasure(types))) {
2678                     sym.flags_field |= CLASH;
2679                     if (m1 == sym) {
2680                         log.error(pos, Errors.NameClashSameErasureNoOverride(
2681                             m1.name, types.memberType(site, m1).asMethodType().getParameterTypes(), m1.location(),
2682                             m2.name, types.memberType(site, m2).asMethodType().getParameterTypes(), m2.location()));
2683                     } else {
2684                         ClassType ct = (ClassType)site;
2685                         String kind = ct.isInterface() ? &quot;interface&quot; : &quot;class&quot;;
2686                         log.error(pos, Errors.NameClashSameErasureNoOverride1(
2687                             kind,
2688                             ct.tsym.name,
2689                             m1.name,
2690                             types.memberType(site, m1).asMethodType().getParameterTypes(),
2691                             m1.location(),
2692                             m2.name,
2693                             types.memberType(site, m2).asMethodType().getParameterTypes(),
2694                             m2.location()));
2695                     }
2696                     return;
2697                 }
2698             }
2699         }
2700 
2701         if (!overridesAny) {
2702             for (MethodSymbol m: potentiallyAmbiguousList) {
2703                 checkPotentiallyAmbiguousOverloads(pos, site, sym, m);
2704             }
2705         }
2706     }
2707 
2708     /** Check that all static methods accessible from &#39;site&#39; are
2709      *  mutually compatible (JLS 8.4.8).
2710      *
2711      *  @param pos  Position to be used for error reporting.
2712      *  @param site The class whose methods are checked.
2713      *  @param sym  The method symbol to be checked.
2714      */
2715     void checkHideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2716         ClashFilter cf = new ClashFilter(site);
2717         //for each method m1 that is a member of &#39;site&#39;...
2718         for (Symbol s : types.membersClosure(site, true).getSymbolsByName(sym.name, cf)) {
2719             //if (i) the signature of &#39;sym&#39; is not a subsignature of m1 (seen as
2720             //a member of &#39;site&#39;) and (ii) &#39;sym&#39; has the same erasure as m1, issue an error
2721             if (!types.isSubSignature(sym.type, types.memberType(site, s), Feature.STRICT_METHOD_CLASH_CHECK.allowedInSource(source))) {
2722                 if (types.hasSameArgs(s.erasure(types), sym.erasure(types))) {
2723                     log.error(pos,
2724                               Errors.NameClashSameErasureNoHide(sym, sym.location(), s, s.location()));
2725                     return;
2726                 } else {
2727                     checkPotentiallyAmbiguousOverloads(pos, site, sym, (MethodSymbol)s);
2728                 }
2729             }
2730          }
2731      }
2732 
2733      //where
2734      private class ClashFilter implements Filter&lt;Symbol&gt; {
2735 
2736          Type site;
2737 
2738          ClashFilter(Type site) {
2739              this.site = site;
2740          }
2741 
2742          boolean shouldSkip(Symbol s) {
2743              return (s.flags() &amp; CLASH) != 0 &amp;&amp;
2744                 s.owner == site.tsym;
2745          }
2746 
2747          public boolean accepts(Symbol s) {
2748              return s.kind == MTH &amp;&amp;
2749                      (s.flags() &amp; SYNTHETIC) == 0 &amp;&amp;
2750                      !shouldSkip(s) &amp;&amp;
2751                      s.isInheritedIn(site.tsym, types) &amp;&amp;
2752                      !s.isConstructor();
2753          }
2754      }
2755 
2756     void checkDefaultMethodClashes(DiagnosticPosition pos, Type site) {
2757         DefaultMethodClashFilter dcf = new DefaultMethodClashFilter(site);
2758         for (Symbol m : types.membersClosure(site, false).getSymbols(dcf)) {
2759             Assert.check(m.kind == MTH);
2760             List&lt;MethodSymbol&gt; prov = types.interfaceCandidates(site, (MethodSymbol)m);
2761             if (prov.size() &gt; 1) {
2762                 ListBuffer&lt;Symbol&gt; abstracts = new ListBuffer&lt;&gt;();
2763                 ListBuffer&lt;Symbol&gt; defaults = new ListBuffer&lt;&gt;();
2764                 for (MethodSymbol provSym : prov) {
2765                     if ((provSym.flags() &amp; DEFAULT) != 0) {
2766                         defaults = defaults.append(provSym);
2767                     } else if ((provSym.flags() &amp; ABSTRACT) != 0) {
2768                         abstracts = abstracts.append(provSym);
2769                     }
2770                     if (defaults.nonEmpty() &amp;&amp; defaults.size() + abstracts.size() &gt;= 2) {
2771                         //strong semantics - issue an error if two sibling interfaces
2772                         //have two override-equivalent defaults - or if one is abstract
2773                         //and the other is default
2774                         Fragment diagKey;
2775                         Symbol s1 = defaults.first();
2776                         Symbol s2;
2777                         if (defaults.size() &gt; 1) {
2778                             s2 = defaults.toList().tail.head;
2779                             diagKey = Fragments.IncompatibleUnrelatedDefaults(Kinds.kindName(site.tsym), site,
2780                                     m.name, types.memberType(site, m).getParameterTypes(),
2781                                     s1.location(), s2.location());
2782 
2783                         } else {
2784                             s2 = abstracts.first();
2785                             diagKey = Fragments.IncompatibleAbstractDefault(Kinds.kindName(site.tsym), site,
2786                                     m.name, types.memberType(site, m).getParameterTypes(),
2787                                     s1.location(), s2.location());
2788                         }
2789                         log.error(pos, Errors.TypesIncompatible(s1.location().type, s2.location().type, diagKey));
2790                         break;
2791                     }
2792                 }
2793             }
2794         }
2795     }
2796 
2797     //where
2798      private class DefaultMethodClashFilter implements Filter&lt;Symbol&gt; {
2799 
2800          Type site;
2801 
2802          DefaultMethodClashFilter(Type site) {
2803              this.site = site;
2804          }
2805 
2806          public boolean accepts(Symbol s) {
2807              return s.kind == MTH &amp;&amp;
2808                      (s.flags() &amp; DEFAULT) != 0 &amp;&amp;
2809                      s.isInheritedIn(site.tsym, types) &amp;&amp;
2810                      !s.isConstructor();
2811          }
2812      }
2813 
2814     /**
2815       * Report warnings for potentially ambiguous method declarations. Two declarations
2816       * are potentially ambiguous if they feature two unrelated functional interface
2817       * in same argument position (in which case, a call site passing an implicit
2818       * lambda would be ambiguous).
2819       */
2820     void checkPotentiallyAmbiguousOverloads(DiagnosticPosition pos, Type site,
2821             MethodSymbol msym1, MethodSymbol msym2) {
2822         if (msym1 != msym2 &amp;&amp;
2823                 Feature.DEFAULT_METHODS.allowedInSource(source) &amp;&amp;
2824                 lint.isEnabled(LintCategory.OVERLOADS) &amp;&amp;
2825                 (msym1.flags() &amp; POTENTIALLY_AMBIGUOUS) == 0 &amp;&amp;
2826                 (msym2.flags() &amp; POTENTIALLY_AMBIGUOUS) == 0) {
2827             Type mt1 = types.memberType(site, msym1);
2828             Type mt2 = types.memberType(site, msym2);
2829             //if both generic methods, adjust type variables
2830             if (mt1.hasTag(FORALL) &amp;&amp; mt2.hasTag(FORALL) &amp;&amp;
2831                     types.hasSameBounds((ForAll)mt1, (ForAll)mt2)) {
2832                 mt2 = types.subst(mt2, ((ForAll)mt2).tvars, ((ForAll)mt1).tvars);
2833             }
2834             //expand varargs methods if needed
2835             int maxLength = Math.max(mt1.getParameterTypes().length(), mt2.getParameterTypes().length());
2836             List&lt;Type&gt; args1 = rs.adjustArgs(mt1.getParameterTypes(), msym1, maxLength, true);
2837             List&lt;Type&gt; args2 = rs.adjustArgs(mt2.getParameterTypes(), msym2, maxLength, true);
2838             //if arities don&#39;t match, exit
2839             if (args1.length() != args2.length()) return;
2840             boolean potentiallyAmbiguous = false;
2841             while (args1.nonEmpty() &amp;&amp; args2.nonEmpty()) {
2842                 Type s = args1.head;
2843                 Type t = args2.head;
2844                 if (!types.isSubtype(t, s) &amp;&amp; !types.isSubtype(s, t)) {
2845                     if (types.isFunctionalInterface(s) &amp;&amp; types.isFunctionalInterface(t) &amp;&amp;
2846                             types.findDescriptorType(s).getParameterTypes().length() &gt; 0 &amp;&amp;
2847                             types.findDescriptorType(s).getParameterTypes().length() ==
2848                             types.findDescriptorType(t).getParameterTypes().length()) {
2849                         potentiallyAmbiguous = true;
2850                     } else {
2851                         break;
2852                     }
2853                 }
2854                 args1 = args1.tail;
2855                 args2 = args2.tail;
2856             }
2857             if (potentiallyAmbiguous) {
2858                 //we found two incompatible functional interfaces with same arity
2859                 //this means a call site passing an implicit lambda would be ambiguous
2860                 msym1.flags_field |= POTENTIALLY_AMBIGUOUS;
2861                 msym2.flags_field |= POTENTIALLY_AMBIGUOUS;
2862                 log.warning(LintCategory.OVERLOADS, pos,
2863                             Warnings.PotentiallyAmbiguousOverload(msym1, msym1.location(),
2864                                                                   msym2, msym2.location()));
2865                 return;
2866             }
2867         }
2868     }
2869 
2870     void checkAccessFromSerializableElement(final JCTree tree, boolean isLambda) {
2871         if (warnOnAnyAccessToMembers ||
2872             (lint.isEnabled(LintCategory.SERIAL) &amp;&amp;
2873             !lint.isSuppressed(LintCategory.SERIAL) &amp;&amp;
2874             isLambda)) {
2875             Symbol sym = TreeInfo.symbol(tree);
2876             if (!sym.kind.matches(KindSelector.VAL_MTH)) {
2877                 return;
2878             }
2879 
2880             if (sym.kind == VAR) {
2881                 if ((sym.flags() &amp; PARAMETER) != 0 ||
2882                     sym.isLocal() ||
2883                     sym.name == names._this ||
2884                     sym.name == names._super) {
2885                     return;
2886                 }
2887             }
2888 
2889             if (!types.isSubtype(sym.owner.type, syms.serializableType) &amp;&amp;
2890                 isEffectivelyNonPublic(sym)) {
2891                 if (isLambda) {
2892                     if (belongsToRestrictedPackage(sym)) {
2893                         log.warning(LintCategory.SERIAL, tree.pos(),
2894                                     Warnings.AccessToMemberFromSerializableLambda(sym));
2895                     }
2896                 } else {
2897                     log.warning(tree.pos(),
2898                                 Warnings.AccessToMemberFromSerializableElement(sym));
2899                 }
2900             }
2901         }
2902     }
2903 
2904     private boolean isEffectivelyNonPublic(Symbol sym) {
2905         if (sym.packge() == syms.rootPackage) {
2906             return false;
2907         }
2908 
2909         while (sym.kind != PCK) {
2910             if ((sym.flags() &amp; PUBLIC) == 0) {
2911                 return true;
2912             }
2913             sym = sym.owner;
2914         }
2915         return false;
2916     }
2917 
2918     private boolean belongsToRestrictedPackage(Symbol sym) {
2919         String fullName = sym.packge().fullname.toString();
2920         return fullName.startsWith(&quot;java.&quot;) ||
2921                 fullName.startsWith(&quot;javax.&quot;) ||
2922                 fullName.startsWith(&quot;sun.&quot;) ||
2923                 fullName.contains(&quot;.internal.&quot;);
2924     }
2925 
2926     /** Check that class c does not implement directly or indirectly
2927      *  the same parameterized interface with two different argument lists.
2928      *  @param pos          Position to be used for error reporting.
2929      *  @param type         The type whose interfaces are checked.
2930      */
2931     void checkClassBounds(DiagnosticPosition pos, Type type) {
2932         checkClassBounds(pos, new HashMap&lt;TypeSymbol,Type&gt;(), type);
2933     }
2934 //where
2935         /** Enter all interfaces of type `type&#39; into the hash table `seensofar&#39;
2936          *  with their class symbol as key and their type as value. Make
2937          *  sure no class is entered with two different types.
2938          */
2939         void checkClassBounds(DiagnosticPosition pos,
2940                               Map&lt;TypeSymbol,Type&gt; seensofar,
2941                               Type type) {
2942             if (type.isErroneous()) return;
2943             for (List&lt;Type&gt; l = types.interfaces(type); l.nonEmpty(); l = l.tail) {
2944                 Type it = l.head;
2945                 if (type.hasTag(CLASS) &amp;&amp; !it.hasTag(CLASS)) continue; // JLS 8.1.5
2946 
2947                 Type oldit = seensofar.put(it.tsym, it);
2948                 if (oldit != null) {
2949                     List&lt;Type&gt; oldparams = oldit.allparams();
2950                     List&lt;Type&gt; newparams = it.allparams();
2951                     if (!types.containsTypeEquivalent(oldparams, newparams))
2952                         log.error(pos,
2953                                   Errors.CantInheritDiffArg(it.tsym,
2954                                                             Type.toString(oldparams),
2955                                                             Type.toString(newparams)));
2956                 }
2957                 checkClassBounds(pos, seensofar, it);
2958             }
2959             Type st = types.supertype(type);
2960             if (type.hasTag(CLASS) &amp;&amp; !st.hasTag(CLASS)) return; // JLS 8.1.4
2961             if (st != Type.noType) checkClassBounds(pos, seensofar, st);
2962         }
2963 
2964     /** Enter interface into into set.
2965      *  If it existed already, issue a &quot;repeated interface&quot; error.
2966      */
2967     void checkNotRepeated(DiagnosticPosition pos, Type it, Set&lt;Type&gt; its) {
2968         if (its.contains(it))
2969             log.error(pos, Errors.RepeatedInterface);
2970         else {
2971             its.add(it);
2972         }
2973     }
2974 
2975 /* *************************************************************************
2976  * Check annotations
2977  **************************************************************************/
2978 
2979     /**
2980      * Recursively validate annotations values
2981      */
2982     void validateAnnotationTree(JCTree tree) {
2983         class AnnotationValidator extends TreeScanner {
2984             @Override
2985             public void visitAnnotation(JCAnnotation tree) {
2986                 if (!tree.type.isErroneous() &amp;&amp; tree.type.tsym.isAnnotationType()) {
2987                     super.visitAnnotation(tree);
2988                     validateAnnotation(tree);
2989                 }
2990             }
2991         }
2992         tree.accept(new AnnotationValidator());
2993     }
2994 
2995     /**
2996      *  {@literal
2997      *  Annotation types are restricted to primitives, String, an
2998      *  enum, an annotation, Class, Class&lt;?&gt;, Class&lt;? extends
2999      *  Anything&gt;, arrays of the preceding.
3000      *  }
3001      */
3002     void validateAnnotationType(JCTree restype) {
3003         // restype may be null if an error occurred, so don&#39;t bother validating it
3004         if (restype != null) {
3005             validateAnnotationType(restype.pos(), restype.type);
3006         }
3007     }
3008 
3009     void validateAnnotationType(DiagnosticPosition pos, Type type) {
3010         if (type.isPrimitive()) return;
3011         if (types.isSameType(type, syms.stringType)) return;
3012         if ((type.tsym.flags() &amp; Flags.ENUM) != 0) return;
3013         if ((type.tsym.flags() &amp; Flags.ANNOTATION) != 0) return;
3014         if (types.cvarLowerBound(type).tsym == syms.classType.tsym) return;
3015         if (types.isArray(type) &amp;&amp; !types.isArray(types.elemtype(type))) {
3016             validateAnnotationType(pos, types.elemtype(type));
3017             return;
3018         }
3019         log.error(pos, Errors.InvalidAnnotationMemberType);
3020     }
3021 
3022     /**
3023      * &quot;It is also a compile-time error if any method declared in an
3024      * annotation type has a signature that is override-equivalent to
3025      * that of any public or protected method declared in class Object
3026      * or in the interface annotation.Annotation.&quot;
3027      *
3028      * @jls 9.6 Annotation Types
3029      */
3030     void validateAnnotationMethod(DiagnosticPosition pos, MethodSymbol m) {
3031         for (Type sup = syms.annotationType; sup.hasTag(CLASS); sup = types.supertype(sup)) {
3032             Scope s = sup.tsym.members();
3033             for (Symbol sym : s.getSymbolsByName(m.name)) {
3034                 if (sym.kind == MTH &amp;&amp;
3035                     (sym.flags() &amp; (PUBLIC | PROTECTED)) != 0 &amp;&amp;
3036                     types.overrideEquivalent(m.type, sym.type))
3037                     log.error(pos, Errors.IntfAnnotationMemberClash(sym, sup));
3038             }
3039         }
3040     }
3041 
3042     /** Check the annotations of a symbol.
3043      */
3044     public void validateAnnotations(List&lt;JCAnnotation&gt; annotations, JCTree declarationTree, Symbol s) {
3045         for (JCAnnotation a : annotations)
3046             validateAnnotation(a, declarationTree, s);
3047     }
3048 
3049     /** Check the type annotations.
3050      */
3051     public void validateTypeAnnotations(List&lt;JCAnnotation&gt; annotations, boolean isTypeParameter) {
3052         for (JCAnnotation a : annotations)
3053             validateTypeAnnotation(a, isTypeParameter);
3054     }
3055 
3056     /** Check an annotation of a symbol.
3057      */
3058     private void validateAnnotation(JCAnnotation a, JCTree declarationTree, Symbol s) {
3059         validateAnnotationTree(a);
3060         boolean isRecordMember = (s.flags_field &amp; RECORD) != 0 || s.enclClass() != null &amp;&amp; s.enclClass().isRecord();
3061 
3062         boolean isRecordField = isRecordMember &amp;&amp;
3063                 (s.flags_field &amp; (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &amp;&amp;
3064                 declarationTree.hasTag(VARDEF) &amp;&amp;
3065                 s.owner.kind == TYP;
3066 
3067         if (isRecordField) {
3068             // first we need to check if the annotation is applicable to records
3069             Name[] targets = getTargetNames(a);
3070             boolean appliesToRecords = false;
3071             for (Name target : targets) {
3072                 appliesToRecords =
3073                                 target == names.FIELD ||
3074                                 target == names.PARAMETER ||
3075                                 target == names.METHOD ||
3076                                 target == names.TYPE_USE ||
3077                                 target == names.RECORD_COMPONENT;
3078                 if (appliesToRecords) {
3079                     break;
3080                 }
3081             }
3082             if (!appliesToRecords) {
3083                 log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
3084             } else {
3085                 /* lets now find the annotations in the field that are targeted to record components and append them to
3086                  * the corresponding record component
3087                  */
3088                 ClassSymbol recordClass = (ClassSymbol) s.owner;
3089                 RecordComponent rc = recordClass.getRecordComponent((VarSymbol)s);
3090                 SymbolMetadata metadata = rc.getMetadata();
3091                 if (metadata == null || metadata.isEmpty()) {
3092                     /* if not is empty then we have already been here, which is the case if multiple annotations are applied
3093                      * to the record component declaration
3094                      */
3095                     rc.appendAttributes(s.getRawAttributes().stream().filter(anno -&gt;
3096                             Arrays.stream(getTargetNames(anno.type.tsym)).anyMatch(name -&gt; name == names.RECORD_COMPONENT)
3097                     ).collect(List.collector()));
3098                     rc.setTypeAttributes(s.getRawTypeAttributes());
3099                     // to get all the type annotations applied to the type
3100                     rc.type = s.type;
3101                 }
3102             }
3103         }
3104 
3105         /* the section below is tricky. Annotations applied to record components are propagated to the corresponding
3106          * record member so if an annotation has target: FIELD, it is propagated to the corresponding FIELD, if it has
3107          * target METHOD, it is propagated to the accessor and so on. But at the moment when method members are generated
3108          * there is no enough information to propagate only the right annotations. So all the annotations are propagated
3109          * to all the possible locations.
3110          *
3111          * At this point we need to remove all the annotations that are not in place before going on with the annotation
3112          * party. On top of the above there is the issue that there is no AST representing record components, just symbols
3113          * so the corresponding field has been holding all the annotations and it&#39;s metadata has been modified as if it
3114          * was both a field and a record component.
3115          *
3116          * So there are two places where we need to trim annotations from: the metadata of the symbol and / or the modifiers
3117          * in the AST. Whatever is in the metadata will be written to the class file, whatever is in the modifiers could
3118          * be see by annotation processors.
3119          *
3120          * The metadata contains both type annotations and declaration annotations. At this point of the game we don&#39;t
3121          * need to care about type annotations, they are all in the right place. But we could need to remove declaration
3122          * annotations. So for declaration annotations if they are not applicable to the record member, excluding type
3123          * annotations which are already correct, then we will remove it. For the AST modifiers if the annotation is not
3124          * applicable either as type annotation and or declaration annotation, only in that case it will be removed.
3125          *
3126          * So it could be that annotation is removed as a declaration annotation but it is kept in the AST modifier for
3127          * further inspection by annotation processors.
3128          *
3129          * For example:
3130          *
3131          *     import java.lang.annotation.*;
3132          *
3133          *     @Target({ElementType.TYPE_USE, ElementType.RECORD_COMPONENT})
3134          *     @Retention(RetentionPolicy.RUNTIME)
3135          *     @interface Anno { }
3136          *
3137          *     record R(@Anno String s) {}
3138          *
3139          * at this point we will have for the case of the generated field:
3140          *   - @Anno in the modifier
3141          *   - @Anno as a type annotation
3142          *   - @Anno as a declaration annotation
3143          *
3144          * the last one should be removed because the annotation has not FIELD as target but it was applied as a
3145          * declaration annotation because the field was being treated both as a field and as a record component
3146          * as we have already copied the annotations to the record component, now the field doesn&#39;t need to hold
3147          * annotations that are not intended for it anymore. Still @Anno has to be kept in the AST&#39;s modifiers as it
3148          * is applicable as a type annotation to the type of the field.
3149          */
3150 
3151         if (a.type.tsym.isAnnotationType()) {
3152             Optional&lt;Set&lt;Name&gt;&gt; applicableTargetsOp = getApplicableTargets(a, s);
3153             if (!applicableTargetsOp.isEmpty()) {
3154                 Set&lt;Name&gt; applicableTargets = applicableTargetsOp.get();
3155                 boolean notApplicableOrIsTypeUseOnly = applicableTargets.isEmpty() ||
3156                         applicableTargets.size() == 1 &amp;&amp; applicableTargets.contains(names.TYPE_USE);
3157                 boolean isRecordMemberWithNonApplicableDeclAnno =
3158                         isRecordMember &amp;&amp; (s.flags_field &amp; Flags.GENERATED_MEMBER) != 0 &amp;&amp; notApplicableOrIsTypeUseOnly;
3159 
3160                 if (applicableTargets.isEmpty() || isRecordMemberWithNonApplicableDeclAnno) {
3161                     if (isRecordMemberWithNonApplicableDeclAnno) {
3162                             /* so we have found an annotation that is not applicable to a record member that was generated by the
3163                              * compiler. This was intentionally done at TypeEnter, now is the moment strip away the annotations
3164                              * that are not applicable to the given record member
3165                              */
3166                         JCModifiers modifiers = TreeInfo.getModifiers(declarationTree);
3167                             /* lets first remove the annotation from the modifier if it is not applicable, we have to check again as
3168                              * it could be a type annotation
3169                              */
3170                         if (modifiers != null &amp;&amp; applicableTargets.isEmpty()) {
3171                             ListBuffer&lt;JCAnnotation&gt; newAnnotations = new ListBuffer&lt;&gt;();
3172                             for (JCAnnotation anno : modifiers.annotations) {
3173                                 if (anno != a) {
3174                                     newAnnotations.add(anno);
3175                                 }
3176                             }
3177                             modifiers.annotations = newAnnotations.toList();
3178                         }
3179                         // now lets remove it from the symbol
3180                         s.getMetadata().removeDeclarationMetadata(a.attribute);
3181                     } else {
3182                         log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
3183                     }
3184                 }
3185             }
3186         }
3187 
3188         if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
3189             if (s.kind != TYP) {
3190                 log.error(a.pos(), Errors.BadFunctionalIntfAnno);
3191             } else if (!s.isInterface() || (s.flags() &amp; ANNOTATION) != 0) {
3192                 log.error(a.pos(), Errors.BadFunctionalIntfAnno1(Fragments.NotAFunctionalIntf(s)));
3193             }
3194         }
3195         if (a.annotationType.type.tsym == syms.valueBasedType.tsym) {
3196             if (s.isInterface() || s.isEnum()) {
3197                 log.error(a.pos(), Errors.BadValueBasedAnno);
3198             } else if (allowValueBasedClasses) {
3199                 s.flags_field |= VALUEBASED;
3200             }
3201         }
3202     }
3203 
3204     public void validateTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3205         Assert.checkNonNull(a.type);
3206         validateAnnotationTree(a);
3207 
3208         if (a.hasTag(TYPE_ANNOTATION) &amp;&amp;
3209                 !a.annotationType.type.isErroneous() &amp;&amp;
3210                 !isTypeAnnotation(a, isTypeParameter)) {
3211             log.error(a.pos(), Errors.AnnotationTypeNotApplicableToType(a.type));
3212         }
3213     }
3214 
3215     /**
3216      * Validate the proposed container &#39;repeatable&#39; on the
3217      * annotation type symbol &#39;s&#39;. Report errors at position
3218      * &#39;pos&#39;.
3219      *
3220      * @param s The (annotation)type declaration annotated with a @Repeatable
3221      * @param repeatable the @Repeatable on &#39;s&#39;
3222      * @param pos where to report errors
3223      */
3224     public void validateRepeatable(TypeSymbol s, Attribute.Compound repeatable, DiagnosticPosition pos) {
3225         Assert.check(types.isSameType(repeatable.type, syms.repeatableType));
3226 
3227         Type t = null;
3228         List&lt;Pair&lt;MethodSymbol,Attribute&gt;&gt; l = repeatable.values;
3229         if (!l.isEmpty()) {
3230             Assert.check(l.head.fst.name == names.value);
3231             t = ((Attribute.Class)l.head.snd).getValue();
3232         }
3233 
3234         if (t == null) {
3235             // errors should already have been reported during Annotate
3236             return;
3237         }
3238 
3239         validateValue(t.tsym, s, pos);
3240         validateRetention(t.tsym, s, pos);
3241         validateDocumented(t.tsym, s, pos);
3242         validateInherited(t.tsym, s, pos);
3243         validateTarget(t.tsym, s, pos);
3244         validateDefault(t.tsym, pos);
3245     }
3246 
3247     private void validateValue(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3248         Symbol sym = container.members().findFirst(names.value);
3249         if (sym != null &amp;&amp; sym.kind == MTH) {
3250             MethodSymbol m = (MethodSymbol) sym;
3251             Type ret = m.getReturnType();
3252             if (!(ret.hasTag(ARRAY) &amp;&amp; types.isSameType(((ArrayType)ret).elemtype, contained.type))) {
3253                 log.error(pos,
3254                           Errors.InvalidRepeatableAnnotationValueReturn(container,
3255                                                                         ret,
3256                                                                         types.makeArrayType(contained.type)));
3257             }
3258         } else {
3259             log.error(pos, Errors.InvalidRepeatableAnnotationNoValue(container));
3260         }
3261     }
3262 
3263     private void validateRetention(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3264         Attribute.RetentionPolicy containerRetention = types.getRetention(container);
3265         Attribute.RetentionPolicy containedRetention = types.getRetention(contained);
3266 
3267         boolean error = false;
3268         switch (containedRetention) {
3269         case RUNTIME:
3270             if (containerRetention != Attribute.RetentionPolicy.RUNTIME) {
3271                 error = true;
3272             }
3273             break;
3274         case CLASS:
3275             if (containerRetention == Attribute.RetentionPolicy.SOURCE)  {
3276                 error = true;
3277             }
3278         }
3279         if (error ) {
3280             log.error(pos,
3281                       Errors.InvalidRepeatableAnnotationRetention(container,
3282                                                                   containerRetention.name(),
3283                                                                   contained,
3284                                                                   containedRetention.name()));
3285         }
3286     }
3287 
3288     private void validateDocumented(Symbol container, Symbol contained, DiagnosticPosition pos) {
3289         if (contained.attribute(syms.documentedType.tsym) != null) {
3290             if (container.attribute(syms.documentedType.tsym) == null) {
3291                 log.error(pos, Errors.InvalidRepeatableAnnotationNotDocumented(container, contained));
3292             }
3293         }
3294     }
3295 
3296     private void validateInherited(Symbol container, Symbol contained, DiagnosticPosition pos) {
3297         if (contained.attribute(syms.inheritedType.tsym) != null) {
3298             if (container.attribute(syms.inheritedType.tsym) == null) {
3299                 log.error(pos, Errors.InvalidRepeatableAnnotationNotInherited(container, contained));
3300             }
3301         }
3302     }
3303 
3304     private void validateTarget(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3305         // The set of targets the container is applicable to must be a subset
3306         // (with respect to annotation target semantics) of the set of targets
3307         // the contained is applicable to. The target sets may be implicit or
3308         // explicit.
3309 
3310         Set&lt;Name&gt; containerTargets;
3311         Attribute.Array containerTarget = getAttributeTargetAttribute(container);
3312         if (containerTarget == null) {
3313             containerTargets = getDefaultTargetSet();
3314         } else {
3315             containerTargets = new HashSet&lt;&gt;();
3316             for (Attribute app : containerTarget.values) {
3317                 if (!(app instanceof Attribute.Enum)) {
3318                     continue; // recovery
3319                 }
3320                 Attribute.Enum e = (Attribute.Enum)app;
3321                 containerTargets.add(e.value.name);
3322             }
3323         }
3324 
3325         Set&lt;Name&gt; containedTargets;
3326         Attribute.Array containedTarget = getAttributeTargetAttribute(contained);
3327         if (containedTarget == null) {
3328             containedTargets = getDefaultTargetSet();
3329         } else {
3330             containedTargets = new HashSet&lt;&gt;();
3331             for (Attribute app : containedTarget.values) {
3332                 if (!(app instanceof Attribute.Enum)) {
3333                     continue; // recovery
3334                 }
3335                 Attribute.Enum e = (Attribute.Enum)app;
3336                 containedTargets.add(e.value.name);
3337             }
3338         }
3339 
3340         if (!isTargetSubsetOf(containerTargets, containedTargets)) {
3341             log.error(pos, Errors.InvalidRepeatableAnnotationIncompatibleTarget(container, contained));
3342         }
3343     }
3344 
3345     /* get a set of names for the default target */
3346     private Set&lt;Name&gt; getDefaultTargetSet() {
3347         if (defaultTargets == null) {
3348             Set&lt;Name&gt; targets = new HashSet&lt;&gt;();
3349             targets.add(names.ANNOTATION_TYPE);
3350             targets.add(names.CONSTRUCTOR);
3351             targets.add(names.FIELD);
<a name="3" id="anc3"></a><span class="line-modified">3352             targets.add(names.RECORD_COMPONENT);</span>


3353             targets.add(names.LOCAL_VARIABLE);
3354             targets.add(names.METHOD);
3355             targets.add(names.PACKAGE);
3356             targets.add(names.PARAMETER);
3357             targets.add(names.TYPE);
3358 
3359             defaultTargets = java.util.Collections.unmodifiableSet(targets);
3360         }
3361 
3362         return defaultTargets;
3363     }
3364     private Set&lt;Name&gt; defaultTargets;
3365 
3366 
3367     /** Checks that s is a subset of t, with respect to ElementType
3368      * semantics, specifically {ANNOTATION_TYPE} is a subset of {TYPE},
3369      * and {TYPE_USE} covers the set {ANNOTATION_TYPE, TYPE, TYPE_USE,
3370      * TYPE_PARAMETER}.
3371      */
3372     private boolean isTargetSubsetOf(Set&lt;Name&gt; s, Set&lt;Name&gt; t) {
3373         // Check that all elements in s are present in t
3374         for (Name n2 : s) {
3375             boolean currentElementOk = false;
3376             for (Name n1 : t) {
3377                 if (n1 == n2) {
3378                     currentElementOk = true;
3379                     break;
3380                 } else if (n1 == names.TYPE &amp;&amp; n2 == names.ANNOTATION_TYPE) {
3381                     currentElementOk = true;
3382                     break;
3383                 } else if (n1 == names.TYPE_USE &amp;&amp;
3384                         (n2 == names.TYPE ||
3385                          n2 == names.ANNOTATION_TYPE ||
3386                          n2 == names.TYPE_PARAMETER)) {
3387                     currentElementOk = true;
3388                     break;
3389                 }
3390             }
3391             if (!currentElementOk)
3392                 return false;
3393         }
3394         return true;
3395     }
3396 
3397     private void validateDefault(Symbol container, DiagnosticPosition pos) {
3398         // validate that all other elements of containing type has defaults
3399         Scope scope = container.members();
3400         for(Symbol elm : scope.getSymbols()) {
3401             if (elm.name != names.value &amp;&amp;
3402                 elm.kind == MTH &amp;&amp;
3403                 ((MethodSymbol)elm).defaultValue == null) {
3404                 log.error(pos,
3405                           Errors.InvalidRepeatableAnnotationElemNondefault(container, elm));
3406             }
3407         }
3408     }
3409 
3410     /** Is s a method symbol that overrides a method in a superclass? */
3411     boolean isOverrider(Symbol s) {
3412         if (s.kind != MTH || s.isStatic())
3413             return false;
3414         MethodSymbol m = (MethodSymbol)s;
3415         TypeSymbol owner = (TypeSymbol)m.owner;
3416         for (Type sup : types.closure(owner.type)) {
3417             if (sup == owner.type)
3418                 continue; // skip &quot;this&quot;
3419             Scope scope = sup.tsym.members();
3420             for (Symbol sym : scope.getSymbolsByName(m.name)) {
3421                 if (!sym.isStatic() &amp;&amp; m.overrides(sym, owner, types, true))
3422                     return true;
3423             }
3424         }
3425         return false;
3426     }
3427 
3428     /** Is the annotation applicable to types? */
3429     protected boolean isTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3430         List&lt;Attribute&gt; targets = typeAnnotations.annotationTargets(a.annotationType.type.tsym);
3431         return (targets == null) ?
3432                 false :
3433                 targets.stream()
3434                         .anyMatch(attr -&gt; isTypeAnnotation(attr, isTypeParameter));
3435     }
3436     //where
3437         boolean isTypeAnnotation(Attribute a, boolean isTypeParameter) {
3438             Attribute.Enum e = (Attribute.Enum)a;
3439             return (e.value.name == names.TYPE_USE ||
3440                     (isTypeParameter &amp;&amp; e.value.name == names.TYPE_PARAMETER));
3441         }
3442 
3443     /** Is the annotation applicable to the symbol? */
3444     Name[] getTargetNames(JCAnnotation a) {
3445         return getTargetNames(a.annotationType.type.tsym);
3446     }
3447 
3448     public Name[] getTargetNames(TypeSymbol annoSym) {
3449         Attribute.Array arr = getAttributeTargetAttribute(annoSym);
3450         Name[] targets;
3451         if (arr == null) {
3452             targets = defaultTargetMetaInfo();
3453         } else {
3454             // TODO: can we optimize this?
3455             targets = new Name[arr.values.length];
3456             for (int i=0; i&lt;arr.values.length; ++i) {
3457                 Attribute app = arr.values[i];
3458                 if (!(app instanceof Attribute.Enum)) {
3459                     return new Name[0];
3460                 }
3461                 Attribute.Enum e = (Attribute.Enum) app;
3462                 targets[i] = e.value.name;
3463             }
3464         }
3465         return targets;
3466     }
3467 
3468     boolean annotationApplicable(JCAnnotation a, Symbol s) {
3469         Optional&lt;Set&lt;Name&gt;&gt; targets = getApplicableTargets(a, s);
3470         /* the optional could be emtpy if the annotation is unknown in that case
3471          * we return that it is applicable and if it is erroneous that should imply
3472          * an error at the declaration site
3473          */
3474         return targets.isEmpty() || targets.isPresent() &amp;&amp; !targets.get().isEmpty();
3475     }
3476 
3477     @SuppressWarnings(&quot;preview&quot;)
3478     Optional&lt;Set&lt;Name&gt;&gt; getApplicableTargets(JCAnnotation a, Symbol s) {
3479         Attribute.Array arr = getAttributeTargetAttribute(a.annotationType.type.tsym);
3480         Name[] targets;
3481         Set&lt;Name&gt; applicableTargets = new HashSet&lt;&gt;();
3482 
3483         if (arr == null) {
3484             targets = defaultTargetMetaInfo();
3485         } else {
3486             // TODO: can we optimize this?
3487             targets = new Name[arr.values.length];
3488             for (int i=0; i&lt;arr.values.length; ++i) {
3489                 Attribute app = arr.values[i];
3490                 if (!(app instanceof Attribute.Enum)) {
3491                     // recovery
3492                     return Optional.empty();
3493                 }
3494                 Attribute.Enum e = (Attribute.Enum) app;
3495                 targets[i] = e.value.name;
3496             }
3497         }
3498         for (Name target : targets) {
3499             if (target == names.TYPE) {
3500                 if (s.kind == TYP)
3501                     applicableTargets.add(names.TYPE);
3502             } else if (target == names.FIELD) {
3503                 if (s.kind == VAR &amp;&amp; s.owner.kind != MTH)
3504                     applicableTargets.add(names.FIELD);
3505             } else if (target == names.RECORD_COMPONENT) {
3506                 if (s.getKind() == ElementKind.RECORD_COMPONENT) {
3507                     applicableTargets.add(names.RECORD_COMPONENT);
3508                 }
3509             } else if (target == names.METHOD) {
3510                 if (s.kind == MTH &amp;&amp; !s.isConstructor())
3511                     applicableTargets.add(names.METHOD);
3512             } else if (target == names.PARAMETER) {
3513                 if (s.kind == VAR &amp;&amp;
3514                     (s.owner.kind == MTH &amp;&amp; (s.flags() &amp; PARAMETER) != 0)) {
3515                     applicableTargets.add(names.PARAMETER);
3516                 }
3517             } else if (target == names.CONSTRUCTOR) {
3518                 if (s.kind == MTH &amp;&amp; s.isConstructor())
3519                     applicableTargets.add(names.CONSTRUCTOR);
3520             } else if (target == names.LOCAL_VARIABLE) {
3521                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp;
3522                       (s.flags() &amp; PARAMETER) == 0) {
3523                     applicableTargets.add(names.LOCAL_VARIABLE);
3524                 }
3525             } else if (target == names.ANNOTATION_TYPE) {
3526                 if (s.kind == TYP &amp;&amp; (s.flags() &amp; ANNOTATION) != 0) {
3527                     applicableTargets.add(names.ANNOTATION_TYPE);
3528                 }
3529             } else if (target == names.PACKAGE) {
3530                 if (s.kind == PCK)
3531                     applicableTargets.add(names.PACKAGE);
3532             } else if (target == names.TYPE_USE) {
3533                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp; s.type.hasTag(NONE)) {
3534                     //cannot type annotate implicitly typed locals
3535                     continue;
3536                 } else if (s.kind == TYP || s.kind == VAR ||
3537                         (s.kind == MTH &amp;&amp; !s.isConstructor() &amp;&amp;
3538                                 !s.type.getReturnType().hasTag(VOID)) ||
3539                         (s.kind == MTH &amp;&amp; s.isConstructor())) {
3540                     applicableTargets.add(names.TYPE_USE);
3541                 }
3542             } else if (target == names.TYPE_PARAMETER) {
3543                 if (s.kind == TYP &amp;&amp; s.type.hasTag(TYPEVAR))
3544                     applicableTargets.add(names.TYPE_PARAMETER);
3545             } else
3546                 return Optional.empty(); // Unknown ElementType. This should be an error at declaration site,
3547                                          // assume applicable.
3548         }
3549         return Optional.of(applicableTargets);
3550     }
3551 
3552     Attribute.Array getAttributeTargetAttribute(TypeSymbol s) {
3553         Attribute.Compound atTarget = s.getAnnotationTypeMetadata().getTarget();
3554         if (atTarget == null) return null; // ok, is applicable
3555         Attribute atValue = atTarget.member(names.value);
3556         if (!(atValue instanceof Attribute.Array)) return null; // error recovery
3557         return (Attribute.Array) atValue;
3558     }
3559 
3560     public final Name[] dfltTargetMeta;
3561     private Name[] defaultTargetMetaInfo() {
3562         return dfltTargetMeta;
3563     }
3564 
3565     /** Check an annotation value.
3566      *
3567      * @param a The annotation tree to check
3568      * @return true if this annotation tree is valid, otherwise false
3569      */
3570     public boolean validateAnnotationDeferErrors(JCAnnotation a) {
3571         boolean res = false;
3572         final Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
3573         try {
3574             res = validateAnnotation(a);
3575         } finally {
3576             log.popDiagnosticHandler(diagHandler);
3577         }
3578         return res;
3579     }
3580 
3581     private boolean validateAnnotation(JCAnnotation a) {
3582         boolean isValid = true;
3583         AnnotationTypeMetadata metadata = a.annotationType.type.tsym.getAnnotationTypeMetadata();
3584 
3585         // collect an inventory of the annotation elements
3586         Set&lt;MethodSymbol&gt; elements = metadata.getAnnotationElements();
3587 
3588         // remove the ones that are assigned values
3589         for (JCTree arg : a.args) {
3590             if (!arg.hasTag(ASSIGN)) continue; // recovery
3591             JCAssign assign = (JCAssign)arg;
3592             Symbol m = TreeInfo.symbol(assign.lhs);
3593             if (m == null || m.type.isErroneous()) continue;
3594             if (!elements.remove(m)) {
3595                 isValid = false;
3596                 log.error(assign.lhs.pos(),
3597                           Errors.DuplicateAnnotationMemberValue(m.name, a.type));
3598             }
3599         }
3600 
3601         // all the remaining ones better have default values
3602         List&lt;Name&gt; missingDefaults = List.nil();
3603         Set&lt;MethodSymbol&gt; membersWithDefault = metadata.getAnnotationElementsWithDefault();
3604         for (MethodSymbol m : elements) {
3605             if (m.type.isErroneous())
3606                 continue;
3607 
3608             if (!membersWithDefault.contains(m))
3609                 missingDefaults = missingDefaults.append(m.name);
3610         }
3611         missingDefaults = missingDefaults.reverse();
3612         if (missingDefaults.nonEmpty()) {
3613             isValid = false;
3614             Error errorKey = (missingDefaults.size() &gt; 1)
3615                     ? Errors.AnnotationMissingDefaultValue1(a.type, missingDefaults)
3616                     : Errors.AnnotationMissingDefaultValue(a.type, missingDefaults);
3617             log.error(a.pos(), errorKey);
3618         }
3619 
3620         return isValid &amp;&amp; validateTargetAnnotationValue(a);
3621     }
3622 
3623     /* Validate the special java.lang.annotation.Target annotation */
3624     boolean validateTargetAnnotationValue(JCAnnotation a) {
3625         // special case: java.lang.annotation.Target must not have
3626         // repeated values in its value member
3627         if (a.annotationType.type.tsym != syms.annotationTargetType.tsym ||
3628                 a.args.tail == null)
3629             return true;
3630 
3631         boolean isValid = true;
3632         if (!a.args.head.hasTag(ASSIGN)) return false; // error recovery
3633         JCAssign assign = (JCAssign) a.args.head;
3634         Symbol m = TreeInfo.symbol(assign.lhs);
3635         if (m.name != names.value) return false;
3636         JCTree rhs = assign.rhs;
3637         if (!rhs.hasTag(NEWARRAY)) return false;
3638         JCNewArray na = (JCNewArray) rhs;
3639         Set&lt;Symbol&gt; targets = new HashSet&lt;&gt;();
3640         for (JCTree elem : na.elems) {
3641             if (!targets.add(TreeInfo.symbol(elem))) {
3642                 isValid = false;
3643                 log.error(elem.pos(), Errors.RepeatedAnnotationTarget);
3644             }
3645         }
3646         return isValid;
3647     }
3648 
3649     void checkDeprecatedAnnotation(DiagnosticPosition pos, Symbol s) {
3650         if (lint.isEnabled(LintCategory.DEP_ANN) &amp;&amp; s.isDeprecatableViaAnnotation() &amp;&amp;
3651             (s.flags() &amp; DEPRECATED) != 0 &amp;&amp;
3652             !syms.deprecatedType.isErroneous() &amp;&amp;
3653             s.attribute(syms.deprecatedType.tsym) == null) {
3654             log.warning(LintCategory.DEP_ANN,
3655                     pos, Warnings.MissingDeprecatedAnnotation);
3656         }
3657         // Note: @Deprecated has no effect on local variables, parameters and package decls.
3658         if (lint.isEnabled(LintCategory.DEPRECATION) &amp;&amp; !s.isDeprecatableViaAnnotation()) {
3659             if (!syms.deprecatedType.isErroneous() &amp;&amp; s.attribute(syms.deprecatedType.tsym) != null) {
3660                 log.warning(LintCategory.DEPRECATION, pos,
3661                             Warnings.DeprecatedAnnotationHasNoEffect(Kinds.kindName(s)));
3662             }
3663         }
3664     }
3665 
3666     void checkDeprecated(final DiagnosticPosition pos, final Symbol other, final Symbol s) {
3667         checkDeprecated(() -&gt; pos, other, s);
3668     }
3669 
3670     void checkDeprecated(Supplier&lt;DiagnosticPosition&gt; pos, final Symbol other, final Symbol s) {
3671         if ( (s.isDeprecatedForRemoval()
3672                 || s.isDeprecated() &amp;&amp; !other.isDeprecated())
3673                 &amp;&amp; (s.outermostClass() != other.outermostClass() || s.outermostClass() == null)) {
3674             deferredLintHandler.report(() -&gt; warnDeprecated(pos.get(), s));
3675         }
3676     }
3677 
3678     void checkSunAPI(final DiagnosticPosition pos, final Symbol s) {
3679         if ((s.flags() &amp; PROPRIETARY) != 0) {
3680             deferredLintHandler.report(() -&gt; {
3681                 log.mandatoryWarning(pos, Warnings.SunProprietary(s));
3682             });
3683         }
3684     }
3685 
3686     void checkProfile(final DiagnosticPosition pos, final Symbol s) {
3687         if (profile != Profile.DEFAULT &amp;&amp; (s.flags() &amp; NOT_IN_PROFILE) != 0) {
3688             log.error(pos, Errors.NotInProfile(s, profile));
3689         }
3690     }
3691 
3692     void checkPreview(DiagnosticPosition pos, Symbol s) {
3693         if ((s.flags() &amp; PREVIEW_API) != 0) {
3694             if ((s.flags() &amp; PREVIEW_ESSENTIAL_API) != 0 &amp;&amp; !preview.isEnabled()) {
3695                 log.error(pos, Errors.IsPreview(s));
3696             } else {
3697                 deferredLintHandler.report(() -&gt; warnPreview(pos, s));
3698             }
3699         }
3700     }
3701 
3702 /* *************************************************************************
3703  * Check for recursive annotation elements.
3704  **************************************************************************/
3705 
3706     /** Check for cycles in the graph of annotation elements.
3707      */
3708     void checkNonCyclicElements(JCClassDecl tree) {
3709         if ((tree.sym.flags_field &amp; ANNOTATION) == 0) return;
3710         Assert.check((tree.sym.flags_field &amp; LOCKED) == 0);
3711         try {
3712             tree.sym.flags_field |= LOCKED;
3713             for (JCTree def : tree.defs) {
3714                 if (!def.hasTag(METHODDEF)) continue;
3715                 JCMethodDecl meth = (JCMethodDecl)def;
3716                 checkAnnotationResType(meth.pos(), meth.restype.type);
3717             }
3718         } finally {
3719             tree.sym.flags_field &amp;= ~LOCKED;
3720             tree.sym.flags_field |= ACYCLIC_ANN;
3721         }
3722     }
3723 
3724     void checkNonCyclicElementsInternal(DiagnosticPosition pos, TypeSymbol tsym) {
3725         if ((tsym.flags_field &amp; ACYCLIC_ANN) != 0)
3726             return;
3727         if ((tsym.flags_field &amp; LOCKED) != 0) {
3728             log.error(pos, Errors.CyclicAnnotationElement(tsym));
3729             return;
3730         }
3731         try {
3732             tsym.flags_field |= LOCKED;
3733             for (Symbol s : tsym.members().getSymbols(NON_RECURSIVE)) {
3734                 if (s.kind != MTH)
3735                     continue;
3736                 checkAnnotationResType(pos, ((MethodSymbol)s).type.getReturnType());
3737             }
3738         } finally {
3739             tsym.flags_field &amp;= ~LOCKED;
3740             tsym.flags_field |= ACYCLIC_ANN;
3741         }
3742     }
3743 
3744     void checkAnnotationResType(DiagnosticPosition pos, Type type) {
3745         switch (type.getTag()) {
3746         case CLASS:
3747             if ((type.tsym.flags() &amp; ANNOTATION) != 0)
3748                 checkNonCyclicElementsInternal(pos, type.tsym);
3749             break;
3750         case ARRAY:
3751             checkAnnotationResType(pos, types.elemtype(type));
3752             break;
3753         default:
3754             break; // int etc
3755         }
3756     }
3757 
3758 /* *************************************************************************
3759  * Check for cycles in the constructor call graph.
3760  **************************************************************************/
3761 
3762     /** Check for cycles in the graph of constructors calling other
3763      *  constructors.
3764      */
3765     void checkCyclicConstructors(JCClassDecl tree) {
3766         Map&lt;Symbol,Symbol&gt; callMap = new HashMap&lt;&gt;();
3767 
3768         // enter each constructor this-call into the map
3769         for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
3770             JCMethodInvocation app = TreeInfo.firstConstructorCall(l.head);
3771             if (app == null) continue;
3772             JCMethodDecl meth = (JCMethodDecl) l.head;
3773             if (TreeInfo.name(app.meth) == names._this) {
3774                 callMap.put(meth.sym, TreeInfo.symbol(app.meth));
3775             } else {
3776                 meth.sym.flags_field |= ACYCLIC;
3777             }
3778         }
3779 
3780         // Check for cycles in the map
3781         Symbol[] ctors = new Symbol[0];
3782         ctors = callMap.keySet().toArray(ctors);
3783         for (Symbol caller : ctors) {
3784             checkCyclicConstructor(tree, caller, callMap);
3785         }
3786     }
3787 
3788     /** Look in the map to see if the given constructor is part of a
3789      *  call cycle.
3790      */
3791     private void checkCyclicConstructor(JCClassDecl tree, Symbol ctor,
3792                                         Map&lt;Symbol,Symbol&gt; callMap) {
3793         if (ctor != null &amp;&amp; (ctor.flags_field &amp; ACYCLIC) == 0) {
3794             if ((ctor.flags_field &amp; LOCKED) != 0) {
3795                 log.error(TreeInfo.diagnosticPositionFor(ctor, tree),
3796                           Errors.RecursiveCtorInvocation);
3797             } else {
3798                 ctor.flags_field |= LOCKED;
3799                 checkCyclicConstructor(tree, callMap.remove(ctor), callMap);
3800                 ctor.flags_field &amp;= ~LOCKED;
3801             }
3802             ctor.flags_field |= ACYCLIC;
3803         }
3804     }
3805 
3806 /* *************************************************************************
3807  * Miscellaneous
3808  **************************************************************************/
3809 
3810     /**
3811      *  Check for division by integer constant zero
3812      *  @param pos           Position for error reporting.
3813      *  @param operator      The operator for the expression
3814      *  @param operand       The right hand operand for the expression
3815      */
3816     void checkDivZero(final DiagnosticPosition pos, Symbol operator, Type operand) {
3817         if (operand.constValue() != null
3818             &amp;&amp; operand.getTag().isSubRangeOf(LONG)
3819             &amp;&amp; ((Number) (operand.constValue())).longValue() == 0) {
3820             int opc = ((OperatorSymbol)operator).opcode;
3821             if (opc == ByteCodes.idiv || opc == ByteCodes.imod
3822                 || opc == ByteCodes.ldiv || opc == ByteCodes.lmod) {
3823                 deferredLintHandler.report(() -&gt; warnDivZero(pos));
3824             }
3825         }
3826     }
3827 
3828     /**
3829      * Check for empty statements after if
3830      */
3831     void checkEmptyIf(JCIf tree) {
3832         if (tree.thenpart.hasTag(SKIP) &amp;&amp; tree.elsepart == null &amp;&amp;
3833                 lint.isEnabled(LintCategory.EMPTY))
3834             log.warning(LintCategory.EMPTY, tree.thenpart.pos(), Warnings.EmptyIf);
3835     }
3836 
3837     /** Check that symbol is unique in given scope.
3838      *  @param pos           Position for error reporting.
3839      *  @param sym           The symbol.
3840      *  @param s             The scope.
3841      */
3842     boolean checkUnique(DiagnosticPosition pos, Symbol sym, Scope s) {
3843         if (sym.type.isErroneous())
3844             return true;
3845         if (sym.owner.name == names.any) return false;
3846         for (Symbol byName : s.getSymbolsByName(sym.name, NON_RECURSIVE)) {
3847             if (sym != byName &amp;&amp;
3848                     (byName.flags() &amp; CLASH) == 0 &amp;&amp;
3849                     sym.kind == byName.kind &amp;&amp;
3850                     sym.name != names.error &amp;&amp;
3851                     (sym.kind != MTH ||
3852                      types.hasSameArgs(sym.type, byName.type) ||
3853                      types.hasSameArgs(types.erasure(sym.type), types.erasure(byName.type)))) {
3854                 if ((sym.flags() &amp; VARARGS) != (byName.flags() &amp; VARARGS)) {
3855                     sym.flags_field |= CLASH;
3856                     varargsDuplicateError(pos, sym, byName);
3857                     return true;
3858                 } else if (sym.kind == MTH &amp;&amp; !types.hasSameArgs(sym.type, byName.type, false)) {
3859                     duplicateErasureError(pos, sym, byName);
3860                     sym.flags_field |= CLASH;
3861                     return true;
3862                 } else if ((sym.flags() &amp; MATCH_BINDING) != 0 &amp;&amp;
3863                            (byName.flags() &amp; MATCH_BINDING) != 0 &amp;&amp;
3864                            (byName.flags() &amp; MATCH_BINDING_TO_OUTER) == 0) {
3865                     if (!sym.type.isErroneous()) {
3866                         log.error(pos, Errors.MatchBindingExists);
3867                         sym.flags_field |= CLASH;
3868                     }
3869                     return false;
3870                 } else {
3871                     duplicateError(pos, byName);
3872                     return false;
3873                 }
3874             }
3875         }
3876         return true;
3877     }
3878 
3879     /** Report duplicate declaration error.
3880      */
3881     void duplicateErasureError(DiagnosticPosition pos, Symbol sym1, Symbol sym2) {
3882         if (!sym1.type.isErroneous() &amp;&amp; !sym2.type.isErroneous()) {
3883             log.error(pos, Errors.NameClashSameErasure(sym1, sym2));
3884         }
3885     }
3886 
3887     /**Check that types imported through the ordinary imports don&#39;t clash with types imported
3888      * by other (static or ordinary) imports. Note that two static imports may import two clashing
3889      * types without an error on the imports.
3890      * @param toplevel       The toplevel tree for which the test should be performed.
3891      */
3892     void checkImportsUnique(JCCompilationUnit toplevel) {
3893         WriteableScope ordinallyImportedSoFar = WriteableScope.create(toplevel.packge);
3894         WriteableScope staticallyImportedSoFar = WriteableScope.create(toplevel.packge);
3895         WriteableScope topLevelScope = toplevel.toplevelScope;
3896 
3897         for (JCTree def : toplevel.defs) {
3898             if (!def.hasTag(IMPORT))
3899                 continue;
3900 
3901             JCImport imp = (JCImport) def;
3902 
3903             if (imp.importScope == null)
3904                 continue;
3905 
3906             for (Symbol sym : imp.importScope.getSymbols(sym -&gt; sym.kind == TYP)) {
3907                 if (imp.isStatic()) {
3908                     checkUniqueImport(imp.pos(), ordinallyImportedSoFar, staticallyImportedSoFar, topLevelScope, sym, true);
3909                     staticallyImportedSoFar.enter(sym);
3910                 } else {
3911                     checkUniqueImport(imp.pos(), ordinallyImportedSoFar, staticallyImportedSoFar, topLevelScope, sym, false);
3912                     ordinallyImportedSoFar.enter(sym);
3913                 }
3914             }
3915 
3916             imp.importScope = null;
3917         }
3918     }
3919 
3920     /** Check that single-type import is not already imported or top-level defined,
3921      *  but make an exception for two single-type imports which denote the same type.
3922      *  @param pos                     Position for error reporting.
3923      *  @param ordinallyImportedSoFar  A Scope containing types imported so far through
3924      *                                 ordinary imports.
3925      *  @param staticallyImportedSoFar A Scope containing types imported so far through
3926      *                                 static imports.
3927      *  @param topLevelScope           The current file&#39;s top-level Scope
3928      *  @param sym                     The symbol.
3929      *  @param staticImport            Whether or not this was a static import
3930      */
3931     private boolean checkUniqueImport(DiagnosticPosition pos, Scope ordinallyImportedSoFar,
3932                                       Scope staticallyImportedSoFar, Scope topLevelScope,
3933                                       Symbol sym, boolean staticImport) {
3934         Filter&lt;Symbol&gt; duplicates = candidate -&gt; candidate != sym &amp;&amp; !candidate.type.isErroneous();
3935         Symbol ordinaryClashing = ordinallyImportedSoFar.findFirst(sym.name, duplicates);
3936         Symbol staticClashing = null;
3937         if (ordinaryClashing == null &amp;&amp; !staticImport) {
3938             staticClashing = staticallyImportedSoFar.findFirst(sym.name, duplicates);
3939         }
3940         if (ordinaryClashing != null || staticClashing != null) {
3941             if (ordinaryClashing != null)
3942                 log.error(pos, Errors.AlreadyDefinedSingleImport(ordinaryClashing));
3943             else
3944                 log.error(pos, Errors.AlreadyDefinedStaticSingleImport(staticClashing));
3945             return false;
3946         }
3947         Symbol clashing = topLevelScope.findFirst(sym.name, duplicates);
3948         if (clashing != null) {
3949             log.error(pos, Errors.AlreadyDefinedThisUnit(clashing));
3950             return false;
3951         }
3952         return true;
3953     }
3954 
3955     /** Check that a qualified name is in canonical form (for import decls).
3956      */
3957     public void checkCanonical(JCTree tree) {
3958         if (!isCanonical(tree))
3959             log.error(tree.pos(),
3960                       Errors.ImportRequiresCanonical(TreeInfo.symbol(tree)));
3961     }
3962         // where
3963         private boolean isCanonical(JCTree tree) {
3964             while (tree.hasTag(SELECT)) {
3965                 JCFieldAccess s = (JCFieldAccess) tree;
3966                 if (s.sym.owner.getQualifiedName() != TreeInfo.symbol(s.selected).getQualifiedName())
3967                     return false;
3968                 tree = s.selected;
3969             }
3970             return true;
3971         }
3972 
3973     /** Check that an auxiliary class is not accessed from any other file than its own.
3974      */
3975     void checkForBadAuxiliaryClassAccess(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, ClassSymbol c) {
3976         if (lint.isEnabled(Lint.LintCategory.AUXILIARYCLASS) &amp;&amp;
3977             (c.flags() &amp; AUXILIARY) != 0 &amp;&amp;
3978             rs.isAccessible(env, c) &amp;&amp;
3979             !fileManager.isSameFile(c.sourcefile, env.toplevel.sourcefile))
3980         {
3981             log.warning(pos,
3982                         Warnings.AuxiliaryClassAccessedFromOutsideOfItsSourceFile(c, c.sourcefile));
3983         }
3984     }
3985 
3986     private class ConversionWarner extends Warner {
3987         final String uncheckedKey;
3988         final Type found;
3989         final Type expected;
3990         public ConversionWarner(DiagnosticPosition pos, String uncheckedKey, Type found, Type expected) {
3991             super(pos);
3992             this.uncheckedKey = uncheckedKey;
3993             this.found = found;
3994             this.expected = expected;
3995         }
3996 
3997         @Override
3998         public void warn(LintCategory lint) {
3999             boolean warned = this.warned;
4000             super.warn(lint);
4001             if (warned) return; // suppress redundant diagnostics
4002             switch (lint) {
4003                 case UNCHECKED:
4004                     Check.this.warnUnchecked(pos(), Warnings.ProbFoundReq(diags.fragment(uncheckedKey), found, expected));
4005                     break;
4006                 case VARARGS:
4007                     if (method != null &amp;&amp;
4008                             method.attribute(syms.trustMeType.tsym) != null &amp;&amp;
4009                             isTrustMeAllowedOnMethod(method) &amp;&amp;
4010                             !types.isReifiable(method.type.getParameterTypes().last())) {
4011                         Check.this.warnUnsafeVararg(pos(), Warnings.VarargsUnsafeUseVarargsParam(method.params.last()));
4012                     }
4013                     break;
4014                 default:
4015                     throw new AssertionError(&quot;Unexpected lint: &quot; + lint);
4016             }
4017         }
4018     }
4019 
4020     public Warner castWarner(DiagnosticPosition pos, Type found, Type expected) {
4021         return new ConversionWarner(pos, &quot;unchecked.cast.to.type&quot;, found, expected);
4022     }
4023 
4024     public Warner convertWarner(DiagnosticPosition pos, Type found, Type expected) {
4025         return new ConversionWarner(pos, &quot;unchecked.assign&quot;, found, expected);
4026     }
4027 
4028     public void checkFunctionalInterface(JCClassDecl tree, ClassSymbol cs) {
4029         Compound functionalType = cs.attribute(syms.functionalInterfaceType.tsym);
4030 
4031         if (functionalType != null) {
4032             try {
4033                 types.findDescriptorSymbol((TypeSymbol)cs);
4034             } catch (Types.FunctionDescriptorLookupError ex) {
4035                 DiagnosticPosition pos = tree.pos();
4036                 for (JCAnnotation a : tree.getModifiers().annotations) {
4037                     if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
4038                         pos = a.pos();
4039                         break;
4040                     }
4041                 }
4042                 log.error(pos, Errors.BadFunctionalIntfAnno1(ex.getDiagnostic()));
4043             }
4044         }
4045     }
4046 
4047     public void checkImportsResolvable(final JCCompilationUnit toplevel) {
4048         for (final JCImport imp : toplevel.getImports()) {
4049             if (!imp.staticImport || !imp.qualid.hasTag(SELECT))
4050                 continue;
4051             final JCFieldAccess select = (JCFieldAccess) imp.qualid;
4052             final Symbol origin;
4053             if (select.name == names.asterisk || (origin = TreeInfo.symbol(select.selected)) == null || origin.kind != TYP)
4054                 continue;
4055 
4056             TypeSymbol site = (TypeSymbol) TreeInfo.symbol(select.selected);
4057             if (!checkTypeContainsImportableElement(site, site, toplevel.packge, select.name, new HashSet&lt;Symbol&gt;())) {
4058                 log.error(imp.pos(),
4059                           Errors.CantResolveLocation(KindName.STATIC,
4060                                                      select.name,
4061                                                      null,
4062                                                      null,
4063                                                      Fragments.Location(kindName(site),
4064                                                                         site,
4065                                                                         null)));
4066             }
4067         }
4068     }
4069 
4070     // Check that packages imported are in scope (JLS 7.4.3, 6.3, 6.5.3.1, 6.5.3.2)
4071     public void checkImportedPackagesObservable(final JCCompilationUnit toplevel) {
4072         OUTER: for (JCImport imp : toplevel.getImports()) {
4073             if (!imp.staticImport &amp;&amp; TreeInfo.name(imp.qualid) == names.asterisk) {
4074                 TypeSymbol tsym = ((JCFieldAccess)imp.qualid).selected.type.tsym;
4075                 if (tsym.kind == PCK &amp;&amp; tsym.members().isEmpty() &amp;&amp;
4076                     !(Feature.IMPORT_ON_DEMAND_OBSERVABLE_PACKAGES.allowedInSource(source) &amp;&amp; tsym.exists())) {
4077                     log.error(DiagnosticFlag.RESOLVE_ERROR, imp.pos, Errors.DoesntExist(tsym));
4078                 }
4079             }
4080         }
4081     }
4082 
4083     private boolean checkTypeContainsImportableElement(TypeSymbol tsym, TypeSymbol origin, PackageSymbol packge, Name name, Set&lt;Symbol&gt; processed) {
4084         if (tsym == null || !processed.add(tsym))
4085             return false;
4086 
4087             // also search through inherited names
4088         if (checkTypeContainsImportableElement(types.supertype(tsym.type).tsym, origin, packge, name, processed))
4089             return true;
4090 
4091         for (Type t : types.interfaces(tsym.type))
4092             if (checkTypeContainsImportableElement(t.tsym, origin, packge, name, processed))
4093                 return true;
4094 
4095         for (Symbol sym : tsym.members().getSymbolsByName(name)) {
4096             if (sym.isStatic() &amp;&amp;
4097                 importAccessible(sym, packge) &amp;&amp;
4098                 sym.isMemberOf(origin, types)) {
4099                 return true;
4100             }
4101         }
4102 
4103         return false;
4104     }
4105 
4106     // is the sym accessible everywhere in packge?
4107     public boolean importAccessible(Symbol sym, PackageSymbol packge) {
4108         try {
4109             int flags = (int)(sym.flags() &amp; AccessFlags);
4110             switch (flags) {
4111             default:
4112             case PUBLIC:
4113                 return true;
4114             case PRIVATE:
4115                 return false;
4116             case 0:
4117             case PROTECTED:
4118                 return sym.packge() == packge;
4119             }
4120         } catch (ClassFinder.BadClassFile err) {
4121             throw err;
4122         } catch (CompletionFailure ex) {
4123             return false;
4124         }
4125     }
4126 
4127     public void checkLeaksNotAccessible(Env&lt;AttrContext&gt; env, JCClassDecl check) {
4128         JCCompilationUnit toplevel = env.toplevel;
4129 
4130         if (   toplevel.modle == syms.unnamedModule
4131             || toplevel.modle == syms.noModule
4132             || (check.sym.flags() &amp; COMPOUND) != 0) {
4133             return ;
4134         }
4135 
4136         ExportsDirective currentExport = findExport(toplevel.packge);
4137 
4138         if (   currentExport == null //not exported
4139             || currentExport.modules != null) //don&#39;t check classes in qualified export
4140             return ;
4141 
4142         new TreeScanner() {
4143             Lint lint = env.info.lint;
4144             boolean inSuperType;
4145 
4146             @Override
4147             public void visitBlock(JCBlock tree) {
4148             }
4149             @Override
4150             public void visitMethodDef(JCMethodDecl tree) {
4151                 if (!isAPISymbol(tree.sym))
4152                     return;
4153                 Lint prevLint = lint;
4154                 try {
4155                     lint = lint.augment(tree.sym);
4156                     if (lint.isEnabled(LintCategory.EXPORTS)) {
4157                         super.visitMethodDef(tree);
4158                     }
4159                 } finally {
4160                     lint = prevLint;
4161                 }
4162             }
4163             @Override
4164             public void visitVarDef(JCVariableDecl tree) {
4165                 if (!isAPISymbol(tree.sym) &amp;&amp; tree.sym.owner.kind != MTH)
4166                     return;
4167                 Lint prevLint = lint;
4168                 try {
4169                     lint = lint.augment(tree.sym);
4170                     if (lint.isEnabled(LintCategory.EXPORTS)) {
4171                         scan(tree.mods);
4172                         scan(tree.vartype);
4173                     }
4174                 } finally {
4175                     lint = prevLint;
4176                 }
4177             }
4178             @Override
4179             public void visitClassDef(JCClassDecl tree) {
4180                 if (tree != check)
4181                     return ;
4182 
4183                 if (!isAPISymbol(tree.sym))
4184                     return ;
4185 
4186                 Lint prevLint = lint;
4187                 try {
4188                     lint = lint.augment(tree.sym);
4189                     if (lint.isEnabled(LintCategory.EXPORTS)) {
4190                         scan(tree.mods);
4191                         scan(tree.typarams);
4192                         try {
4193                             inSuperType = true;
4194                             scan(tree.extending);
4195                             scan(tree.implementing);
4196                         } finally {
4197                             inSuperType = false;
4198                         }
4199                         scan(tree.defs);
4200                     }
4201                 } finally {
4202                     lint = prevLint;
4203                 }
4204             }
4205             @Override
4206             public void visitTypeApply(JCTypeApply tree) {
4207                 scan(tree.clazz);
4208                 boolean oldInSuperType = inSuperType;
4209                 try {
4210                     inSuperType = false;
4211                     scan(tree.arguments);
4212                 } finally {
4213                     inSuperType = oldInSuperType;
4214                 }
4215             }
4216             @Override
4217             public void visitIdent(JCIdent tree) {
4218                 Symbol sym = TreeInfo.symbol(tree);
4219                 if (sym.kind == TYP &amp;&amp; !sym.type.hasTag(TYPEVAR)) {
4220                     checkVisible(tree.pos(), sym, toplevel.packge, inSuperType);
4221                 }
4222             }
4223 
4224             @Override
4225             public void visitSelect(JCFieldAccess tree) {
4226                 Symbol sym = TreeInfo.symbol(tree);
4227                 Symbol sitesym = TreeInfo.symbol(tree.selected);
4228                 if (sym.kind == TYP &amp;&amp; sitesym.kind == PCK) {
4229                     checkVisible(tree.pos(), sym, toplevel.packge, inSuperType);
4230                 } else {
4231                     super.visitSelect(tree);
4232                 }
4233             }
4234 
4235             @Override
4236             public void visitAnnotation(JCAnnotation tree) {
4237                 if (tree.attribute.type.tsym.getAnnotation(java.lang.annotation.Documented.class) != null)
4238                     super.visitAnnotation(tree);
4239             }
4240 
4241         }.scan(check);
4242     }
4243         //where:
4244         private ExportsDirective findExport(PackageSymbol pack) {
4245             for (ExportsDirective d : pack.modle.exports) {
4246                 if (d.packge == pack)
4247                     return d;
4248             }
4249 
4250             return null;
4251         }
4252         private boolean isAPISymbol(Symbol sym) {
4253             while (sym.kind != PCK) {
4254                 if ((sym.flags() &amp; Flags.PUBLIC) == 0 &amp;&amp; (sym.flags() &amp; Flags.PROTECTED) == 0) {
4255                     return false;
4256                 }
4257                 sym = sym.owner;
4258             }
4259             return true;
4260         }
4261         private void checkVisible(DiagnosticPosition pos, Symbol what, PackageSymbol inPackage, boolean inSuperType) {
4262             if (!isAPISymbol(what) &amp;&amp; !inSuperType) { //package private/private element
4263                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessible(kindName(what), what, what.packge().modle));
4264                 return ;
4265             }
4266 
4267             PackageSymbol whatPackage = what.packge();
4268             ExportsDirective whatExport = findExport(whatPackage);
4269             ExportsDirective inExport = findExport(inPackage);
4270 
4271             if (whatExport == null) { //package not exported:
4272                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleUnexported(kindName(what), what, what.packge().modle));
4273                 return ;
4274             }
4275 
4276             if (whatExport.modules != null) {
4277                 if (inExport.modules == null || !whatExport.modules.containsAll(inExport.modules)) {
4278                     log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleUnexportedQualified(kindName(what), what, what.packge().modle));
4279                 }
4280             }
4281 
4282             if (whatPackage.modle != inPackage.modle &amp;&amp; whatPackage.modle != syms.java_base) {
4283                 //check that relativeTo.modle requires transitive what.modle, somehow:
4284                 List&lt;ModuleSymbol&gt; todo = List.of(inPackage.modle);
4285 
4286                 while (todo.nonEmpty()) {
4287                     ModuleSymbol current = todo.head;
4288                     todo = todo.tail;
4289                     if (current == whatPackage.modle)
4290                         return ; //OK
4291                     if ((current.flags() &amp; Flags.AUTOMATIC_MODULE) != 0)
4292                         continue; //for automatic modules, don&#39;t look into their dependencies
4293                     for (RequiresDirective req : current.requires) {
4294                         if (req.isTransitive()) {
4295                             todo = todo.prepend(req.module);
4296                         }
4297                     }
4298                 }
4299 
4300                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleNotRequiredTransitive(kindName(what), what, what.packge().modle));
4301             }
4302         }
4303 
4304     void checkModuleExists(final DiagnosticPosition pos, ModuleSymbol msym) {
4305         if (msym.kind != MDL) {
4306             deferredLintHandler.report(() -&gt; {
4307                 if (lint.isEnabled(LintCategory.MODULE))
4308                     log.warning(LintCategory.MODULE, pos, Warnings.ModuleNotFound(msym));
4309             });
4310         }
4311     }
4312 
4313     void checkPackageExistsForOpens(final DiagnosticPosition pos, PackageSymbol packge) {
4314         if (packge.members().isEmpty() &amp;&amp;
4315             ((packge.flags() &amp; Flags.HAS_RESOURCE) == 0)) {
4316             deferredLintHandler.report(() -&gt; {
4317                 if (lint.isEnabled(LintCategory.OPENS))
4318                     log.warning(pos, Warnings.PackageEmptyOrNotFound(packge));
4319             });
4320         }
4321     }
4322 
4323     void checkModuleRequires(final DiagnosticPosition pos, final RequiresDirective rd) {
4324         if ((rd.module.flags() &amp; Flags.AUTOMATIC_MODULE) != 0) {
4325             deferredLintHandler.report(() -&gt; {
4326                 if (rd.isTransitive() &amp;&amp; lint.isEnabled(LintCategory.REQUIRES_TRANSITIVE_AUTOMATIC)) {
4327                     log.warning(pos, Warnings.RequiresTransitiveAutomatic);
4328                 } else if (lint.isEnabled(LintCategory.REQUIRES_AUTOMATIC)) {
4329                     log.warning(pos, Warnings.RequiresAutomatic);
4330                 }
4331             });
4332         }
4333     }
4334 
4335 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
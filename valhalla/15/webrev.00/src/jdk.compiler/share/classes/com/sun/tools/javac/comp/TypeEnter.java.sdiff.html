<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Check.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../parser/JavacParser.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 929                 superSym.pos = Position.FIRSTPOS;
 930                 env.info.scope.enter(superSym);
 931             }
 932         }
 933     }
 934 
 935     private final class RecordPhase extends AbstractMembersPhase {
 936 
 937         public RecordPhase() {
 938             super(CompletionCause.RECORD_PHASE, new MembersPhase());
 939         }
 940 
 941         @Override
 942         protected void runPhase(Env&lt;AttrContext&gt; env) {
 943             JCClassDecl tree = env.enclClass;
 944             ClassSymbol sym = tree.sym;
 945             if ((sym.flags_field &amp; RECORD) != 0) {
 946                 List&lt;JCVariableDecl&gt; fields = TreeInfo.recordFields(tree);
 947                 memberEnter.memberEnter(fields, env);
 948                 for (JCVariableDecl field : fields) {
<span class="line-modified"> 949                     sym.getRecordComponent(field, true);</span>



 950                 }
 951 
 952                 enterThisAndSuper(sym, env);
 953 
 954                 // lets enter all constructors
 955                 for (JCTree def : tree.defs) {
 956                     if (TreeInfo.isConstructor(def)) {
 957                         memberEnter.memberEnter(def, env);
 958                     }
 959                 }
 960             }
 961         }
 962     }
 963 
 964     /** Enter member fields and methods of a class
 965      */
 966     private final class MembersPhase extends AbstractMembersPhase {
 967 
 968         public MembersPhase() {
 969             super(CompletionCause.MEMBERS_PHASE, null);
</pre>
<hr />
<pre>
1054             if (isRecord) {
1055                 addRecordMembersIfNeeded(tree, env);
1056             }
1057             if ((tree.mods.flags &amp; (Flags.VALUE | Flags.INTERFACE)) == Flags.VALUE &amp;&amp; !tree.sym.type.hasTag(ERROR)) {
1058                 addValueMembers(tree, env);
1059             }
1060             if (tree.sym.isAnnotationType()) {
1061                 Assert.check(tree.sym.isCompleted());
1062                 tree.sym.setAnnotationTypeMetadata(new AnnotationTypeMetadata(tree.sym, annotate.annotationTypeSourceCompleter()));
1063             }
1064         }
1065 
1066         private void addAccessor(JCVariableDecl tree, Env&lt;AttrContext&gt; env) {
1067             MethodSymbol implSym = lookupMethod(env.enclClass.sym, tree.sym.name, List.nil());
1068             RecordComponent rec = ((ClassSymbol) tree.sym.owner).getRecordComponent(tree.sym);
1069             if (implSym == null || (implSym.flags_field &amp; GENERATED_MEMBER) != 0) {
1070                 /* here we are pushing the annotations present in the corresponding field down to the accessor
1071                  * it could be that some of those annotations are not applicable to the accessor, they will be striped
1072                  * away later at Check::validateAnnotation
1073                  */
<span class="line-modified">1074                 List&lt;JCAnnotation&gt; originalAnnos = rec.getOriginalAnnos();</span>


1075                 JCMethodDecl getter = make.at(tree.pos).
1076                         MethodDef(
1077                                 make.Modifiers(Flags.PUBLIC | Flags.GENERATED_MEMBER, originalAnnos),
1078                           tree.sym.name,
1079                           /* we need to special case for the case when the user declared the type as an ident
1080                            * if we don&#39;t do that then we can have issues if type annotations are applied to the
1081                            * return type: javac issues an error if a type annotation is applied to java.lang.String
1082                            * but applying a type annotation to String is kosher
1083                            */
1084                           tree.vartype.hasTag(IDENT) ? make.Ident(tree.vartype.type.tsym) : make.Type(tree.sym.type),
1085                           List.nil(),
1086                           List.nil(),
1087                           List.nil(), // thrown
1088                           null,
1089                           null);
1090                 memberEnter.memberEnter(getter, env);
1091                 rec.accessor = getter.sym;
1092                 rec.accessorMeth = getter;
1093             } else if (implSym != null) {
1094                 rec.accessor = implSym;
</pre>
<hr />
<pre>
1453              * to trigger field initialization later on
1454              */
1455             csym.flags_field |= Flags.COMPACT_RECORD_CONSTRUCTOR | GENERATEDCONSTR;
1456             ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
1457             for (VarSymbol p : recordFieldSymbols) {
1458                 params.add(new VarSymbol(GENERATED_MEMBER | PARAMETER | RECORD | ((p.flags_field &amp; Flags.VARARGS) != 0 ? Flags.VARARGS : 0), p.name, p.type, csym));
1459             }
1460             csym.params = params.toList();
1461             csym.flags_field |= RECORD | PUBLIC;
1462             return csym;
1463         }
1464 
1465         @Override
1466         public JCMethodDecl finalAdjustment(JCMethodDecl md) {
1467             List&lt;JCVariableDecl&gt; tmpRecordFieldDecls = recordFieldDecls;
1468             for (JCVariableDecl arg : md.params) {
1469                 /* at this point we are passing all the annotations in the field to the corresponding
1470                  * parameter in the constructor.
1471                  */
1472                 RecordComponent rc = ((ClassSymbol) owner).getRecordComponent(arg.sym);
<span class="line-modified">1473                 arg.mods.annotations = rc.getOriginalAnnos();</span>


1474                 arg.vartype = tmpRecordFieldDecls.head.vartype;
1475                 tmpRecordFieldDecls = tmpRecordFieldDecls.tail;
1476             }
1477             return md;
1478         }
1479     }
1480 
1481     JCTree defaultConstructor(TreeMaker make, DefaultConstructorHelper helper) {
1482         Type initType = helper.constructorType();
1483         MethodSymbol initSym = helper.constructorSymbol();
1484         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
1485         if (helper.owner().type != syms.objectType) {
1486             JCExpression meth;
1487             if (!helper.enclosingType().hasTag(NONE)) {
1488                 meth = make.Select(make.Ident(initSym.params.head), names._super);
1489             } else {
1490                 meth = make.Ident(names._super);
1491             }
1492             List&lt;JCExpression&gt; typeargs = initType.getTypeArguments().nonEmpty() ?
1493                     make.Types(initType.getTypeArguments()) : null;
</pre>
</td>
<td>
<hr />
<pre>
 929                 superSym.pos = Position.FIRSTPOS;
 930                 env.info.scope.enter(superSym);
 931             }
 932         }
 933     }
 934 
 935     private final class RecordPhase extends AbstractMembersPhase {
 936 
 937         public RecordPhase() {
 938             super(CompletionCause.RECORD_PHASE, new MembersPhase());
 939         }
 940 
 941         @Override
 942         protected void runPhase(Env&lt;AttrContext&gt; env) {
 943             JCClassDecl tree = env.enclClass;
 944             ClassSymbol sym = tree.sym;
 945             if ((sym.flags_field &amp; RECORD) != 0) {
 946                 List&lt;JCVariableDecl&gt; fields = TreeInfo.recordFields(tree);
 947                 memberEnter.memberEnter(fields, env);
 948                 for (JCVariableDecl field : fields) {
<span class="line-modified"> 949                     sym.getRecordComponent(field, true,</span>
<span class="line-added"> 950                             field.mods.annotations.isEmpty() ?</span>
<span class="line-added"> 951                                     List.nil() :</span>
<span class="line-added"> 952                                     new TreeCopier&lt;JCTree&gt;(make.at(field.pos)).copy(field.mods.annotations));</span>
 953                 }
 954 
 955                 enterThisAndSuper(sym, env);
 956 
 957                 // lets enter all constructors
 958                 for (JCTree def : tree.defs) {
 959                     if (TreeInfo.isConstructor(def)) {
 960                         memberEnter.memberEnter(def, env);
 961                     }
 962                 }
 963             }
 964         }
 965     }
 966 
 967     /** Enter member fields and methods of a class
 968      */
 969     private final class MembersPhase extends AbstractMembersPhase {
 970 
 971         public MembersPhase() {
 972             super(CompletionCause.MEMBERS_PHASE, null);
</pre>
<hr />
<pre>
1057             if (isRecord) {
1058                 addRecordMembersIfNeeded(tree, env);
1059             }
1060             if ((tree.mods.flags &amp; (Flags.VALUE | Flags.INTERFACE)) == Flags.VALUE &amp;&amp; !tree.sym.type.hasTag(ERROR)) {
1061                 addValueMembers(tree, env);
1062             }
1063             if (tree.sym.isAnnotationType()) {
1064                 Assert.check(tree.sym.isCompleted());
1065                 tree.sym.setAnnotationTypeMetadata(new AnnotationTypeMetadata(tree.sym, annotate.annotationTypeSourceCompleter()));
1066             }
1067         }
1068 
1069         private void addAccessor(JCVariableDecl tree, Env&lt;AttrContext&gt; env) {
1070             MethodSymbol implSym = lookupMethod(env.enclClass.sym, tree.sym.name, List.nil());
1071             RecordComponent rec = ((ClassSymbol) tree.sym.owner).getRecordComponent(tree.sym);
1072             if (implSym == null || (implSym.flags_field &amp; GENERATED_MEMBER) != 0) {
1073                 /* here we are pushing the annotations present in the corresponding field down to the accessor
1074                  * it could be that some of those annotations are not applicable to the accessor, they will be striped
1075                  * away later at Check::validateAnnotation
1076                  */
<span class="line-modified">1077                 List&lt;JCAnnotation&gt; originalAnnos = rec.getOriginalAnnos().isEmpty() ?</span>
<span class="line-added">1078                         rec.getOriginalAnnos() :</span>
<span class="line-added">1079                         new TreeCopier&lt;JCTree&gt;(make.at(tree.pos)).copy(rec.getOriginalAnnos());</span>
1080                 JCMethodDecl getter = make.at(tree.pos).
1081                         MethodDef(
1082                                 make.Modifiers(Flags.PUBLIC | Flags.GENERATED_MEMBER, originalAnnos),
1083                           tree.sym.name,
1084                           /* we need to special case for the case when the user declared the type as an ident
1085                            * if we don&#39;t do that then we can have issues if type annotations are applied to the
1086                            * return type: javac issues an error if a type annotation is applied to java.lang.String
1087                            * but applying a type annotation to String is kosher
1088                            */
1089                           tree.vartype.hasTag(IDENT) ? make.Ident(tree.vartype.type.tsym) : make.Type(tree.sym.type),
1090                           List.nil(),
1091                           List.nil(),
1092                           List.nil(), // thrown
1093                           null,
1094                           null);
1095                 memberEnter.memberEnter(getter, env);
1096                 rec.accessor = getter.sym;
1097                 rec.accessorMeth = getter;
1098             } else if (implSym != null) {
1099                 rec.accessor = implSym;
</pre>
<hr />
<pre>
1458              * to trigger field initialization later on
1459              */
1460             csym.flags_field |= Flags.COMPACT_RECORD_CONSTRUCTOR | GENERATEDCONSTR;
1461             ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
1462             for (VarSymbol p : recordFieldSymbols) {
1463                 params.add(new VarSymbol(GENERATED_MEMBER | PARAMETER | RECORD | ((p.flags_field &amp; Flags.VARARGS) != 0 ? Flags.VARARGS : 0), p.name, p.type, csym));
1464             }
1465             csym.params = params.toList();
1466             csym.flags_field |= RECORD | PUBLIC;
1467             return csym;
1468         }
1469 
1470         @Override
1471         public JCMethodDecl finalAdjustment(JCMethodDecl md) {
1472             List&lt;JCVariableDecl&gt; tmpRecordFieldDecls = recordFieldDecls;
1473             for (JCVariableDecl arg : md.params) {
1474                 /* at this point we are passing all the annotations in the field to the corresponding
1475                  * parameter in the constructor.
1476                  */
1477                 RecordComponent rc = ((ClassSymbol) owner).getRecordComponent(arg.sym);
<span class="line-modified">1478                 arg.mods.annotations = rc.getOriginalAnnos().isEmpty() ?</span>
<span class="line-added">1479                         List.nil() :</span>
<span class="line-added">1480                         new TreeCopier&lt;JCTree&gt;(make.at(arg.pos)).copy(rc.getOriginalAnnos());</span>
1481                 arg.vartype = tmpRecordFieldDecls.head.vartype;
1482                 tmpRecordFieldDecls = tmpRecordFieldDecls.tail;
1483             }
1484             return md;
1485         }
1486     }
1487 
1488     JCTree defaultConstructor(TreeMaker make, DefaultConstructorHelper helper) {
1489         Type initType = helper.constructorType();
1490         MethodSymbol initSym = helper.constructorSymbol();
1491         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
1492         if (helper.owner().type != syms.objectType) {
1493             JCExpression meth;
1494             if (!helper.enclosingType().hasTag(NONE)) {
1495                 meth = make.Select(make.Ident(initSym.params.head), names._super);
1496             } else {
1497                 meth = make.Ident(names._super);
1498             }
1499             List&lt;JCExpression&gt; typeargs = initType.getTypeArguments().nonEmpty() ?
1500                     make.Types(initType.getTypeArguments()) : null;
</pre>
</td>
</tr>
</table>
<center><a href="Check.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../parser/JavacParser.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
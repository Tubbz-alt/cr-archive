<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/windows/classes/sun/awt/windows/WWindowPeer.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="WToolkit.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../native/libawt/windows/WPrinterJob.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/windows/classes/sun/awt/windows/WWindowPeer.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
385                 }
386             }
387         }
388     }
389 
390     synchronized void addWindowListener(WindowListener l) {
391         windowListener = AWTEventMulticaster.add(windowListener, l);
392     }
393 
394     synchronized void removeWindowListener(WindowListener l) {
395         windowListener = AWTEventMulticaster.remove(windowListener, l);
396     }
397 
398     @Override
399     public void updateMinimumSize() {
400         Dimension minimumSize = null;
401         if (((Component)target).isMinimumSizeSet()) {
402             minimumSize = ((Component)target).getMinimumSize();
403         }
404         if (minimumSize != null) {
<span class="line-modified">405             int msw = getSysMinWidth();</span>
<span class="line-modified">406             int msh = getSysMinHeight();</span>
<span class="line-removed">407             int w = (minimumSize.width &gt;= msw) ? minimumSize.width : msw;</span>
<span class="line-removed">408             int h = (minimumSize.height &gt;= msh) ? minimumSize.height : msh;</span>
409             setMinSize(w, h);
410         } else {
411             setMinSize(0, 0);
412         }
413     }
414 
415     @Override
416     public void updateIconImages() {
417         java.util.List&lt;Image&gt; imageList = ((Window)target).getIconImages();
418         if (imageList == null || imageList.size() == 0) {
419             setIconImagesData(null, 0, 0, null, 0, 0);
420         } else {
421             int w = getSysIconWidth();
422             int h = getSysIconHeight();
423             int smw = getSysSmIconWidth();
424             int smh = getSysSmIconHeight();
425             AffineTransform tx = getGraphicsConfiguration().getDefaultTransform();
426             w = Region.clipScale(w, tx.getScaleX());
427             h = Region.clipScale(h, tx.getScaleY());
428             smw = Region.clipScale(smw, tx.getScaleX());
</pre>
<hr />
<pre>
670      }
671 
672     private void initScales() {
673 
674         if (scaleX &gt;= 1 &amp;&amp; scaleY &gt;= 1) {
675             return;
676         }
677 
678         GraphicsConfiguration gc = getGraphicsConfiguration();
679         if (gc instanceof Win32GraphicsConfig) {
680             Win32GraphicsDevice gd = ((Win32GraphicsConfig) gc).getDevice();
681             scaleX = gd.getDefaultScaleX();
682             scaleY = gd.getDefaultScaleY();
683         } else {
684             AffineTransform tx = gc.getDefaultTransform();
685             scaleX = (float) tx.getScaleX();
686             scaleY = (float) tx.getScaleY();
687         }
688     }
689 
















690     @Override
691     public void print(Graphics g) {
692         // We assume we print the whole frame,
693         // so we expect no clip was set previously
694         Shape shape = ((Window)target).getShape();
695         if (shape != null) {
696             g.setClip(shape);
697         }
698         super.print(g);
699     }
700 
701     private void replaceSurfaceDataRecursively(Component c) {
702         if (c instanceof Container) {
703             for (Component child : ((Container)c).getComponents()) {
704                 replaceSurfaceDataRecursively(child);
705             }
706         }
707         final Object cp = AWTAccessor.getComponentAccessor().getPeer(c);
708         if (cp instanceof WComponentPeer) {
709             ((WComponentPeer)cp).replaceSurfaceDataLater();
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
385                 }
386             }
387         }
388     }
389 
390     synchronized void addWindowListener(WindowListener l) {
391         windowListener = AWTEventMulticaster.add(windowListener, l);
392     }
393 
394     synchronized void removeWindowListener(WindowListener l) {
395         windowListener = AWTEventMulticaster.remove(windowListener, l);
396     }
397 
398     @Override
399     public void updateMinimumSize() {
400         Dimension minimumSize = null;
401         if (((Component)target).isMinimumSizeSet()) {
402             minimumSize = ((Component)target).getMinimumSize();
403         }
404         if (minimumSize != null) {
<span class="line-modified">405             int w = Math.max(minimumSize.width, scaleDownX(getSysMinWidth()));</span>
<span class="line-modified">406             int h = Math.max(minimumSize.height, scaleDownY(getSysMinHeight()));</span>


407             setMinSize(w, h);
408         } else {
409             setMinSize(0, 0);
410         }
411     }
412 
413     @Override
414     public void updateIconImages() {
415         java.util.List&lt;Image&gt; imageList = ((Window)target).getIconImages();
416         if (imageList == null || imageList.size() == 0) {
417             setIconImagesData(null, 0, 0, null, 0, 0);
418         } else {
419             int w = getSysIconWidth();
420             int h = getSysIconHeight();
421             int smw = getSysSmIconWidth();
422             int smh = getSysSmIconHeight();
423             AffineTransform tx = getGraphicsConfiguration().getDefaultTransform();
424             w = Region.clipScale(w, tx.getScaleX());
425             h = Region.clipScale(h, tx.getScaleY());
426             smw = Region.clipScale(smw, tx.getScaleX());
</pre>
<hr />
<pre>
668      }
669 
670     private void initScales() {
671 
672         if (scaleX &gt;= 1 &amp;&amp; scaleY &gt;= 1) {
673             return;
674         }
675 
676         GraphicsConfiguration gc = getGraphicsConfiguration();
677         if (gc instanceof Win32GraphicsConfig) {
678             Win32GraphicsDevice gd = ((Win32GraphicsConfig) gc).getDevice();
679             scaleX = gd.getDefaultScaleX();
680             scaleY = gd.getDefaultScaleY();
681         } else {
682             AffineTransform tx = gc.getDefaultTransform();
683             scaleX = (float) tx.getScaleX();
684             scaleY = (float) tx.getScaleY();
685         }
686     }
687 
<span class="line-added">688     final int scaleUpX(int x) {</span>
<span class="line-added">689         return Region.clipRound(x * scaleX);</span>
<span class="line-added">690     }</span>
<span class="line-added">691 </span>
<span class="line-added">692     final int scaleUpY(int y) {</span>
<span class="line-added">693         return Region.clipRound(y * scaleY);</span>
<span class="line-added">694     }</span>
<span class="line-added">695 </span>
<span class="line-added">696     final int scaleDownX(int x) {</span>
<span class="line-added">697         return Region.clipRound(x / scaleX);</span>
<span class="line-added">698     }</span>
<span class="line-added">699 </span>
<span class="line-added">700     final int scaleDownY(int y) {</span>
<span class="line-added">701         return Region.clipRound(y / scaleY);</span>
<span class="line-added">702     }</span>
<span class="line-added">703 </span>
704     @Override
705     public void print(Graphics g) {
706         // We assume we print the whole frame,
707         // so we expect no clip was set previously
708         Shape shape = ((Window)target).getShape();
709         if (shape != null) {
710             g.setClip(shape);
711         }
712         super.print(g);
713     }
714 
715     private void replaceSurfaceDataRecursively(Component c) {
716         if (c instanceof Container) {
717             for (Component child : ((Container)c).getComponents()) {
718                 replaceSurfaceDataRecursively(child);
719             }
720         }
721         final Object cp = AWTAccessor.getComponentAccessor().getPeer(c);
722         if (cp instanceof WComponentPeer) {
723             ((WComponentPeer)cp).replaceSurfaceDataLater();
</pre>
</td>
</tr>
</table>
<center><a href="WToolkit.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../native/libawt/windows/WPrinterJob.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
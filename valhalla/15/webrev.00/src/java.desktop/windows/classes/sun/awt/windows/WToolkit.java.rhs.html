<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/windows/classes/sun/awt/windows/WToolkit.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.awt.windows;
  27 
  28 import java.awt.AWTEvent;
  29 import java.awt.AWTException;
  30 import java.awt.Button;
  31 import java.awt.Canvas;
  32 import java.awt.Checkbox;
  33 import java.awt.CheckboxMenuItem;
  34 import java.awt.Choice;
  35 import java.awt.Component;
  36 import java.awt.Cursor;
  37 import java.awt.Desktop;
  38 import java.awt.Dialog;
  39 import java.awt.Dimension;
  40 import java.awt.EventQueue;
  41 import java.awt.FileDialog;
  42 import java.awt.Font;
  43 import java.awt.FontMetrics;
  44 import java.awt.Frame;
  45 import java.awt.GraphicsConfiguration;
  46 import java.awt.GraphicsDevice;
  47 import java.awt.GraphicsEnvironment;
  48 import java.awt.HeadlessException;
  49 import java.awt.Image;
  50 import java.awt.Insets;
  51 import java.awt.JobAttributes;
  52 import java.awt.Label;
  53 import java.awt.List;
  54 import java.awt.Menu;
  55 import java.awt.MenuBar;
  56 import java.awt.MenuItem;
  57 import java.awt.PageAttributes;
  58 import java.awt.Panel;
  59 import java.awt.Point;
  60 import java.awt.PopupMenu;
  61 import java.awt.PrintJob;
  62 import java.awt.RenderingHints;
<a name="1" id="anc1"></a>
  63 import java.awt.ScrollPane;
  64 import java.awt.Scrollbar;
  65 import java.awt.SystemTray;
  66 import java.awt.Taskbar;
  67 import java.awt.TextArea;
  68 import java.awt.TextComponent;
  69 import java.awt.TextField;
  70 import java.awt.Toolkit;
  71 import java.awt.TrayIcon;
  72 import java.awt.Window;
  73 import java.awt.datatransfer.Clipboard;
  74 import java.awt.dnd.DragGestureEvent;
  75 import java.awt.dnd.DragGestureListener;
  76 import java.awt.dnd.DragGestureRecognizer;
  77 import java.awt.dnd.DragSource;
  78 import java.awt.dnd.InvalidDnDOperationException;
  79 import java.awt.dnd.MouseDragGestureRecognizer;
  80 import java.awt.dnd.peer.DragSourceContextPeer;
  81 import java.awt.event.FocusEvent;
  82 import java.awt.event.KeyEvent;
  83 import java.awt.event.MouseEvent;
  84 import java.awt.im.InputMethodHighlight;
  85 import java.awt.im.spi.InputMethodDescriptor;
  86 import java.awt.image.ColorModel;
  87 import java.awt.peer.ButtonPeer;
  88 import java.awt.peer.CanvasPeer;
  89 import java.awt.peer.CheckboxMenuItemPeer;
  90 import java.awt.peer.CheckboxPeer;
  91 import java.awt.peer.ChoicePeer;
  92 import java.awt.peer.DesktopPeer;
  93 import java.awt.peer.DialogPeer;
  94 import java.awt.peer.FileDialogPeer;
  95 import java.awt.peer.FontPeer;
  96 import java.awt.peer.FramePeer;
  97 import java.awt.peer.KeyboardFocusManagerPeer;
  98 import java.awt.peer.LabelPeer;
  99 import java.awt.peer.ListPeer;
 100 import java.awt.peer.MenuBarPeer;
 101 import java.awt.peer.MenuItemPeer;
 102 import java.awt.peer.MenuPeer;
 103 import java.awt.peer.MouseInfoPeer;
 104 import java.awt.peer.PanelPeer;
 105 import java.awt.peer.PopupMenuPeer;
 106 import java.awt.peer.RobotPeer;
 107 import java.awt.peer.ScrollPanePeer;
 108 import java.awt.peer.ScrollbarPeer;
 109 import java.awt.peer.SystemTrayPeer;
 110 import java.awt.peer.TaskbarPeer;
 111 import java.awt.peer.TextAreaPeer;
 112 import java.awt.peer.TextFieldPeer;
 113 import java.awt.peer.TrayIconPeer;
 114 import java.awt.peer.WindowPeer;
 115 import java.beans.PropertyChangeListener;
 116 import java.lang.ref.WeakReference;
 117 import java.security.AccessController;
 118 import java.security.PrivilegedAction;
 119 import java.util.Hashtable;
 120 import java.util.Locale;
 121 import java.util.Map;
 122 import java.util.Properties;
 123 import java.util.concurrent.ExecutorService;
 124 import java.util.concurrent.Executors;
 125 
 126 import javax.swing.text.JTextComponent;
 127 
 128 import sun.awt.AWTAccessor;
 129 import sun.awt.AWTAutoShutdown;
 130 import sun.awt.AWTPermissions;
 131 import sun.awt.AppContext;
 132 import sun.awt.DisplayChangedListener;
 133 import sun.awt.LightweightFrame;
 134 import sun.awt.SunToolkit;
 135 import sun.awt.Win32GraphicsDevice;
 136 import sun.awt.Win32GraphicsEnvironment;
 137 import sun.awt.datatransfer.DataTransferer;
 138 import sun.awt.util.PerformanceLogger;
 139 import sun.awt.util.ThreadGroupUtils;
 140 import sun.font.FontManager;
 141 import sun.font.FontManagerFactory;
 142 import sun.font.SunFontManager;
 143 import sun.java2d.d3d.D3DRenderQueue;
 144 import sun.java2d.opengl.OGLRenderQueue;
 145 import sun.print.PrintJob2D;
 146 import sun.util.logging.PlatformLogger;
 147 
 148 public final class WToolkit extends SunToolkit implements Runnable {
 149 
 150     private static final PlatformLogger log = PlatformLogger.getLogger(&quot;sun.awt.windows.WToolkit&quot;);
 151 
 152     // Desktop property which specifies whether XP visual styles are in effect
 153     public static final String XPSTYLE_THEME_ACTIVE = &quot;win.xpstyle.themeActive&quot;;
 154 
 155     // System clipboard.
 156     WClipboard clipboard;
 157 
 158     // cache of font peers
 159     private Hashtable&lt;String,FontPeer&gt; cacheFontPeer;
 160 
 161     // Windows properties
 162     private WDesktopProperties  wprops;
 163 
 164     // Dynamic Layout Resize client code setting
 165     protected boolean dynamicLayoutSetting = false;
 166 
 167     //Is it allowed to generate events assigned to extra mouse buttons.
 168     //Set to true by default.
 169     private static boolean areExtraMouseButtonsEnabled = true;
 170 
 171     /**
 172      * Initialize JNI field and method IDs
 173      */
 174     private static native void initIDs();
 175     private static boolean loaded = false;
 176     public static void loadLibraries() {
 177         if (!loaded) {
 178             java.security.AccessController.doPrivileged(
 179                 new java.security.PrivilegedAction&lt;Void&gt;() {
 180                     @Override
 181                     public Void run() {
 182                         System.loadLibrary(&quot;awt&quot;);
 183                         return null;
 184                     }
 185                 });
 186             loaded = true;
 187         }
 188     }
 189 
 190     private static native String getWindowsVersion();
 191 
 192     static {
 193         loadLibraries();
 194         initIDs();
 195 
 196         // Print out which version of Windows is running
 197         if (log.isLoggable(PlatformLogger.Level.FINE)) {
 198             log.fine(&quot;Win version: &quot; + getWindowsVersion());
 199         }
 200     }
 201 
 202     /*
 203      * NOTE: The following embedded*() methods are non-public API intended
 204      * for internal use only.  The methods are unsupported and could go
 205      * away in future releases.
 206      *
 207      * New hook functions for using the AWT as an embedded service. These
 208      * functions replace the global C function AwtInit() which was previously
 209      * exported by awt.dll.
 210      *
 211      * When used as an embedded service, the AWT does NOT have its own
 212      * message pump. It instead relies on the parent application to provide
 213      * this functionality. embeddedInit() assumes that the thread on which it
 214      * is called is the message pumping thread. Violating this assumption
 215      * will lead to undefined behavior.
 216      *
 217      * embeddedInit must be called before the WToolkit() constructor.
 218      * embeddedDispose should be called before the applicaton terminates the
 219      * Java VM. It is currently unsafe to reinitialize the toolkit again
 220      * after it has been disposed. Instead, awt.dll must be reloaded and the
 221      * class loader which loaded WToolkit must be finalized before it is
 222      * safe to reuse AWT. Dynamic reusability may be added to the toolkit in
 223      * the future.
 224      */
 225 
 226     /**
 227      * Initializes the Toolkit for use in an embedded environment.
 228      *
 229      * @return true if the initialization succeeded; false if it failed.
 230      *         The function will fail if the Toolkit was already initialized.
 231      * @since 1.3
 232      */
 233     public static native boolean embeddedInit();
 234 
 235     /**
 236      * Disposes the Toolkit in an embedded environment. This method should
 237      * not be called on exit unless the Toolkit was constructed with
 238      * embeddedInit.
 239      *
 240      * @return true if the disposal succeeded; false if it failed. The
 241      *         function will fail if the calling thread is not the same
 242      *         thread which called embeddedInit(), or if the Toolkit was
 243      *         already disposed.
 244      * @since 1.3
 245      */
 246     public static native boolean embeddedDispose();
 247 
 248     /**
 249      * To be called after processing the event queue by users of the above
 250      * embeddedInit() function.  The reason for this additional call is that
 251      * there are some operations performed during idle time in the AwtToolkit
 252      * event loop which should also be performed during idle time in any
 253      * other native event loop.  Failure to do so could result in
 254      * deadlocks.
 255      *
 256      * This method was added at the last minute of the jdk1.4 release
 257      * to work around a specific customer problem.  As with the above
 258      * embedded*() class, this method is non-public and should not be
 259      * used by external applications.
 260      *
 261      * See bug #4526587 for more information.
 262      */
 263     public native void embeddedEventLoopIdleProcessing();
 264 
 265     static class ToolkitDisposer implements sun.java2d.DisposerRecord {
 266         @Override
 267         public void dispose() {
 268             WToolkit.postDispose();
 269         }
 270     }
 271 
 272     private final Object anchor = new Object();
 273 
 274     private static native void postDispose();
 275 
 276     private static native boolean startToolkitThread(Runnable thread, ThreadGroup rootThreadGroup);
 277 
 278     public WToolkit() {
 279         // Startup toolkit threads
 280         if (PerformanceLogger.loggingEnabled()) {
 281             PerformanceLogger.setTime(&quot;WToolkit construction&quot;);
 282         }
 283 
 284         sun.java2d.Disposer.addRecord(anchor, new ToolkitDisposer());
 285 
 286         /*
 287          * Fix for 4701990.
 288          * AWTAutoShutdown state must be changed before the toolkit thread
 289          * starts to avoid race condition.
 290          */
 291         AWTAutoShutdown.notifyToolkitThreadBusy();
 292 
 293         // Find a root TG and attach toolkit thread to it
 294         ThreadGroup rootTG = AccessController.doPrivileged(
 295                 (PrivilegedAction&lt;ThreadGroup&gt;) ThreadGroupUtils::getRootThreadGroup);
 296         if (!startToolkitThread(this, rootTG)) {
 297             final String name = &quot;AWT-Windows&quot;;
 298             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 299                 Thread toolkitThread = new Thread(rootTG, this, name, 0, false);
 300                 toolkitThread.setDaemon(true);
 301                 toolkitThread.start();
 302                 return null;
 303             });
 304         }
 305 
 306         try {
 307             synchronized(this) {
 308                 while(!inited) {
 309                     wait();
 310                 }
 311             }
 312         } catch (InterruptedException x) {
 313             // swallow the exception
 314         }
 315 
 316         // Enabled &quot;live resizing&quot; by default.  It remains controlled
 317         // by the native system though.
 318         setDynamicLayout(true);
 319         final String extraButtons = &quot;sun.awt.enableExtraMouseButtons&quot;;
 320         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 321             areExtraMouseButtonsEnabled =
 322                  Boolean.parseBoolean(System.getProperty(extraButtons, &quot;true&quot;));
 323             //set system property if not yet assigned
 324             System.setProperty(extraButtons, &quot;&quot;+areExtraMouseButtonsEnabled);
 325             return null;
 326         });
 327         setExtraMouseButtonsEnabledNative(areExtraMouseButtonsEnabled);
 328     }
 329 
 330     private void registerShutdownHook() {
 331         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 332             Thread shutdown = new Thread(
 333                     ThreadGroupUtils.getRootThreadGroup(), this::shutdown,
 334                     &quot;ToolkitShutdown&quot;, 0, false);
 335             shutdown.setContextClassLoader(null);
 336             Runtime.getRuntime().addShutdownHook(shutdown);
 337             return null;
 338         });
 339      }
 340 
 341     @Override
 342     public void run() {
 343         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 344             Thread.currentThread().setContextClassLoader(null);
 345             Thread.currentThread().setPriority(Thread.NORM_PRIORITY + 1);
 346             return null;
 347         });
 348 
 349         boolean startPump = init();
 350 
 351         if (startPump) {
 352             registerShutdownHook();
 353         }
 354 
 355         synchronized(this) {
 356             inited = true;
 357             notifyAll();
 358         }
 359 
 360         if (startPump) {
 361             eventLoop(); // will Dispose Toolkit when shutdown hook executes
 362         }
 363     }
 364 
 365     /*
 366      * eventLoop() begins the native message pump which retrieves and processes
 367      * native events.
 368      *
 369      * When shutdown() is called by the ShutdownHook added in run(), a
 370      * WM_QUIT message is posted to the Toolkit thread indicating that
 371      * eventLoop() should Dispose the toolkit and exit.
 372      */
 373     private native boolean init();
 374     private boolean inited = false;
 375 
 376     private native void eventLoop();
 377     private native void shutdown();
 378 
 379     /*
 380      * Instead of blocking the &quot;AWT-Windows&quot; thread uselessly on a semaphore,
 381      * use these functions. startSecondaryEventLoop() corresponds to wait()
 382      * and quitSecondaryEventLoop() corresponds to notify.
 383      *
 384      * These functions simulate blocking while allowing the AWT to continue
 385      * processing native events, eliminating a potential deadlock situation
 386      * with SendMessage.
 387      *
 388      * WARNING: startSecondaryEventLoop must only be called from the &quot;AWT-
 389      * Windows&quot; thread.
 390      */
 391     static native void startSecondaryEventLoop();
 392     static native void quitSecondaryEventLoop();
 393 
 394     /*
 395      * Create peer objects.
 396      */
 397 
 398     @Override
 399     public ButtonPeer createButton(Button target) {
 400         ButtonPeer peer = new WButtonPeer(target);
 401         targetCreatedPeer(target, peer);
 402         return peer;
 403     }
 404 
 405     @Override
 406     public TextFieldPeer createTextField(TextField target) {
 407         TextFieldPeer peer = new WTextFieldPeer(target);
 408         targetCreatedPeer(target, peer);
 409         return peer;
 410     }
 411 
 412     @Override
 413     public LabelPeer createLabel(Label target) {
 414         LabelPeer peer = new WLabelPeer(target);
 415         targetCreatedPeer(target, peer);
 416         return peer;
 417     }
 418 
 419     @Override
 420     public ListPeer createList(List target) {
 421         ListPeer peer = new WListPeer(target);
 422         targetCreatedPeer(target, peer);
 423         return peer;
 424     }
 425 
 426     @Override
 427     public CheckboxPeer createCheckbox(Checkbox target) {
 428         CheckboxPeer peer = new WCheckboxPeer(target);
 429         targetCreatedPeer(target, peer);
 430         return peer;
 431     }
 432 
 433     @Override
 434     public ScrollbarPeer createScrollbar(Scrollbar target) {
 435         ScrollbarPeer peer = new WScrollbarPeer(target);
 436         targetCreatedPeer(target, peer);
 437         return peer;
 438     }
 439 
 440     @Override
 441     public ScrollPanePeer createScrollPane(ScrollPane target) {
 442         ScrollPanePeer peer = new WScrollPanePeer(target);
 443         targetCreatedPeer(target, peer);
 444         return peer;
 445     }
 446 
 447     @Override
 448     public TextAreaPeer createTextArea(TextArea target) {
 449         TextAreaPeer peer = new WTextAreaPeer(target);
 450         targetCreatedPeer(target, peer);
 451         return peer;
 452     }
 453 
 454     @Override
 455     public ChoicePeer createChoice(Choice target) {
 456         ChoicePeer peer = new WChoicePeer(target);
 457         targetCreatedPeer(target, peer);
 458         return peer;
 459     }
 460 
 461     @Override
 462     public FramePeer  createFrame(Frame target) {
 463         FramePeer peer = new WFramePeer(target);
 464         targetCreatedPeer(target, peer);
 465         return peer;
 466     }
 467 
 468     @Override
 469     public FramePeer createLightweightFrame(LightweightFrame target) {
 470         FramePeer peer = new WLightweightFramePeer(target);
 471         targetCreatedPeer(target, peer);
 472         return peer;
 473     }
 474 
 475     @Override
 476     public CanvasPeer createCanvas(Canvas target) {
 477         CanvasPeer peer = new WCanvasPeer(target);
 478         targetCreatedPeer(target, peer);
 479         return peer;
 480     }
 481 
 482     @Override
 483     public void disableBackgroundErase(Canvas canvas) {
 484         WCanvasPeer peer = AWTAccessor.getComponentAccessor().getPeer(canvas);
 485         if (peer == null) {
 486             throw new IllegalStateException(&quot;Canvas must have a valid peer&quot;);
 487         }
 488         peer.disableBackgroundErase();
 489     }
 490 
 491     @Override
 492     public PanelPeer createPanel(Panel target) {
 493         PanelPeer peer = new WPanelPeer(target);
 494         targetCreatedPeer(target, peer);
 495         return peer;
 496     }
 497 
 498     @Override
 499     public WindowPeer createWindow(Window target) {
 500         WindowPeer peer = new WWindowPeer(target);
 501         targetCreatedPeer(target, peer);
 502         return peer;
 503     }
 504 
 505     @Override
 506     public DialogPeer createDialog(Dialog target) {
 507         DialogPeer peer = new WDialogPeer(target);
 508         targetCreatedPeer(target, peer);
 509         return peer;
 510     }
 511 
 512     @Override
 513     public FileDialogPeer createFileDialog(FileDialog target) {
 514         FileDialogPeer peer = new WFileDialogPeer(target);
 515         targetCreatedPeer(target, peer);
 516         return peer;
 517     }
 518 
 519     @Override
 520     public MenuBarPeer createMenuBar(MenuBar target) {
 521         MenuBarPeer peer = new WMenuBarPeer(target);
 522         targetCreatedPeer(target, peer);
 523         return peer;
 524     }
 525 
 526     @Override
 527     public MenuPeer createMenu(Menu target) {
 528         MenuPeer peer = new WMenuPeer(target);
 529         targetCreatedPeer(target, peer);
 530         return peer;
 531     }
 532 
 533     @Override
 534     public PopupMenuPeer createPopupMenu(PopupMenu target) {
 535         PopupMenuPeer peer = new WPopupMenuPeer(target);
 536         targetCreatedPeer(target, peer);
 537         return peer;
 538     }
 539 
 540     @Override
 541     public MenuItemPeer createMenuItem(MenuItem target) {
 542         MenuItemPeer peer = new WMenuItemPeer(target);
 543         targetCreatedPeer(target, peer);
 544         return peer;
 545     }
 546 
 547     @Override
 548     public CheckboxMenuItemPeer createCheckboxMenuItem(CheckboxMenuItem target) {
 549         CheckboxMenuItemPeer peer = new WCheckboxMenuItemPeer(target);
 550         targetCreatedPeer(target, peer);
 551         return peer;
 552     }
 553 
 554     @Override
<a name="2" id="anc2"></a><span class="line-modified"> 555     public RobotPeer createRobot(GraphicsDevice screen) throws AWTException {</span>
<span class="line-modified"> 556         if (screen instanceof Win32GraphicsDevice) {</span>
<span class="line-modified"> 557             return new WRobotPeer();</span>
<span class="line-modified"> 558         }</span>
<span class="line-modified"> 559         return super.createRobot(screen);</span>
 560     }
 561 
 562     public WEmbeddedFramePeer createEmbeddedFrame(WEmbeddedFrame target) {
 563         WEmbeddedFramePeer peer = new WEmbeddedFramePeer(target);
 564         targetCreatedPeer(target, peer);
 565         return peer;
 566     }
 567 
 568     WPrintDialogPeer createWPrintDialog(WPrintDialog target) {
 569         WPrintDialogPeer peer = new WPrintDialogPeer(target);
 570         targetCreatedPeer(target, peer);
 571         return peer;
 572     }
 573 
 574     WPageDialogPeer createWPageDialog(WPageDialog target) {
 575         WPageDialogPeer peer = new WPageDialogPeer(target);
 576         targetCreatedPeer(target, peer);
 577         return peer;
 578     }
 579 
 580     @Override
 581     public TrayIconPeer createTrayIcon(TrayIcon target) {
 582         WTrayIconPeer peer = new WTrayIconPeer(target);
 583         targetCreatedPeer(target, peer);
 584         return peer;
 585     }
 586 
 587     @Override
 588     public SystemTrayPeer createSystemTray(SystemTray target) {
 589         return new WSystemTrayPeer(target);
 590     }
 591 
 592     @Override
 593     public boolean isTraySupported() {
 594         return true;
 595     }
 596 
 597     @Override
 598     public DataTransferer getDataTransferer() {
 599         return WDataTransferer.getInstanceImpl();
 600     }
 601 
 602     @Override
 603     public KeyboardFocusManagerPeer getKeyboardFocusManagerPeer()
 604       throws HeadlessException
 605     {
 606         return WKeyboardFocusManagerPeer.getInstance();
 607     }
 608 
 609     private static WMouseInfoPeer wPeer = null;
 610 
 611     @Override
 612     public synchronized MouseInfoPeer getMouseInfoPeer() {
 613         if (wPeer == null) {
 614             wPeer = new WMouseInfoPeer();
 615         }
 616         return wPeer;
 617     }
 618 
 619     private native void setDynamicLayoutNative(boolean b);
 620 
 621     @Override
 622     public void setDynamicLayout(boolean b) {
 623         if (b == dynamicLayoutSetting) {
 624             return;
 625         }
 626 
 627         dynamicLayoutSetting = b;
 628         setDynamicLayoutNative(b);
 629     }
 630 
 631     @Override
 632     protected boolean isDynamicLayoutSet() {
 633         return dynamicLayoutSetting;
 634     }
 635 
 636     /*
 637      * Called from lazilyLoadDynamicLayoutSupportedProperty because
 638      * Windows doesn&#39;t always send WM_SETTINGCHANGE when it should.
 639      */
 640     private native boolean isDynamicLayoutSupportedNative();
 641 
 642     @Override
 643     public boolean isDynamicLayoutActive() {
 644         return (isDynamicLayoutSet() &amp;&amp; isDynamicLayoutSupported());
 645     }
 646 
 647     /**
 648      * Returns {@code true} if this frame state is supported.
 649      */
 650     @Override
 651     public boolean isFrameStateSupported(int state) {
 652         switch (state) {
 653           case Frame.NORMAL:
 654           case Frame.ICONIFIED:
 655           case Frame.MAXIMIZED_BOTH:
 656               return true;
 657           default:
 658               return false;
 659         }
 660     }
 661 
 662     static native ColorModel makeColorModel();
 663     static ColorModel screenmodel;
 664 
 665     @Override
<a name="3" id="anc3"></a><span class="line-modified"> 666     public Insets getScreenInsets(final GraphicsConfiguration gc) {</span>
<span class="line-modified"> 667         GraphicsDevice gd = gc.getDevice();</span>
<span class="line-modified"> 668         if (!(gd instanceof Win32GraphicsDevice)) {</span>
<span class="line-added"> 669             return super.getScreenInsets(gc);</span>
<span class="line-added"> 670         }</span>
<span class="line-added"> 671         return getScreenInsets(((Win32GraphicsDevice) gd).getScreen());</span>
 672     }
 673 
 674     @Override
 675     public int getScreenResolution() {
 676         Win32GraphicsEnvironment ge = (Win32GraphicsEnvironment)
 677             GraphicsEnvironment.getLocalGraphicsEnvironment();
 678         return ge.getXResolution();
 679     }
 680 
 681     private native Insets getScreenInsets(int screen);
 682 
 683 
 684     @Override
 685     public FontMetrics getFontMetrics(Font font) {
 686         // This is an unsupported hack, but left in for a customer.
 687         // Do not remove.
 688         FontManager fm = FontManagerFactory.getInstance();
 689         if (fm instanceof SunFontManager
 690             &amp;&amp; ((SunFontManager) fm).usePlatformFontMetrics()) {
 691             return WFontMetrics.getFontMetrics(font);
 692         }
 693         return super.getFontMetrics(font);
 694     }
 695 
 696     @Override
 697     public FontPeer getFontPeer(String name, int style) {
 698         FontPeer retval = null;
 699         String lcName = name.toLowerCase();
 700         if (null != cacheFontPeer) {
 701             retval = cacheFontPeer.get(lcName + style);
 702             if (null != retval) {
 703                 return retval;
 704             }
 705         }
 706         retval = new WFontPeer(name, style);
 707         if (retval != null) {
 708             if (null == cacheFontPeer) {
 709                 cacheFontPeer = new Hashtable&lt;&gt;(5, 0.9f);
 710             }
 711             if (null != cacheFontPeer) {
 712                 cacheFontPeer.put(lcName + style, retval);
 713             }
 714         }
 715         return retval;
 716     }
 717 
 718     private native void nativeSync();
 719 
 720     @Override
 721     public void sync() {
 722         // flush the GDI/DD buffers
 723         nativeSync();
 724         // now flush the OGL pipeline (this is a no-op if OGL is not enabled)
 725         OGLRenderQueue.sync();
 726         // now flush the D3D pipeline (this is a no-op if D3D is not enabled)
 727         D3DRenderQueue.sync();
 728     }
 729 
 730     @Override
 731     public PrintJob getPrintJob(Frame frame, String doctitle,
 732                                 Properties props) {
 733         return getPrintJob(frame, doctitle, null, null);
 734     }
 735 
 736     @Override
 737     public PrintJob getPrintJob(Frame frame, String doctitle,
 738                                 JobAttributes jobAttributes,
 739                                 PageAttributes pageAttributes)
 740     {
 741         if (frame == null) {
 742             throw new NullPointerException(&quot;frame must not be null&quot;);
 743         }
 744 
 745         PrintJob2D printJob = new PrintJob2D(frame, doctitle,
 746                                              jobAttributes, pageAttributes);
 747 
 748         if (printJob.printDialog() == false) {
 749             printJob = null;
 750         }
 751 
 752         return printJob;
 753     }
 754 
 755     @Override
 756     public native void beep();
 757 
 758     @Override
 759     public boolean getLockingKeyState(int key) {
 760         if (! (key == KeyEvent.VK_CAPS_LOCK || key == KeyEvent.VK_NUM_LOCK ||
 761                key == KeyEvent.VK_SCROLL_LOCK || key == KeyEvent.VK_KANA_LOCK)) {
 762             throw new IllegalArgumentException(&quot;invalid key for Toolkit.getLockingKeyState&quot;);
 763         }
 764         return getLockingKeyStateNative(key);
 765     }
 766 
 767     private native boolean getLockingKeyStateNative(int key);
 768 
 769     @Override
 770     public void setLockingKeyState(int key, boolean on) {
 771         if (! (key == KeyEvent.VK_CAPS_LOCK || key == KeyEvent.VK_NUM_LOCK ||
 772                key == KeyEvent.VK_SCROLL_LOCK || key == KeyEvent.VK_KANA_LOCK)) {
 773             throw new IllegalArgumentException(&quot;invalid key for Toolkit.setLockingKeyState&quot;);
 774         }
 775         setLockingKeyStateNative(key, on);
 776     }
 777 
 778     private native void setLockingKeyStateNative(int key, boolean on);
 779 
 780     @Override
 781     public Clipboard getSystemClipboard() {
 782         SecurityManager security = System.getSecurityManager();
 783         if (security != null) {
 784             security.checkPermission(AWTPermissions.ACCESS_CLIPBOARD_PERMISSION);
 785         }
 786         synchronized (this) {
 787             if (clipboard == null) {
 788                 clipboard = new WClipboard();
 789             }
 790         }
 791         return clipboard;
 792     }
 793 
 794     @Override
 795     protected native void loadSystemColors(int[] systemColors);
 796 
 797     public static Object targetToPeer(Object target) {
 798         return SunToolkit.targetToPeer(target);
 799     }
 800 
 801     public static void targetDisposedPeer(Object target, Object peer) {
 802         SunToolkit.targetDisposedPeer(target, peer);
 803     }
 804 
 805     /**
 806      * Returns a new input method adapter descriptor for native input methods.
 807      */
 808     @Override
 809     public InputMethodDescriptor getInputMethodAdapterDescriptor() {
 810         return new WInputMethodDescriptor();
 811     }
 812 
 813     /**
 814      * Returns a style map for the input method highlight.
 815      */
 816     @Override
 817     public Map&lt;java.awt.font.TextAttribute,?&gt; mapInputMethodHighlight(
 818         InputMethodHighlight highlight)
 819     {
 820         return WInputMethod.mapInputMethodHighlight(highlight);
 821     }
 822 
 823     /**
 824      * Returns whether enableInputMethods should be set to true for peered
 825      * TextComponent instances on this platform.
 826      */
 827     @Override
 828     public boolean enableInputMethodsForTextComponent() {
 829         return true;
 830     }
 831 
 832     /**
 833      * Returns the default keyboard locale of the underlying operating system
 834      */
 835     @Override
 836     public Locale getDefaultKeyboardLocale() {
 837         Locale locale = WInputMethod.getNativeLocale();
 838 
 839         if (locale == null) {
 840             return super.getDefaultKeyboardLocale();
 841         } else {
 842             return locale;
 843         }
 844     }
 845 
 846     /**
 847      * Returns a new custom cursor.
 848      */
 849     @Override
 850     public Cursor createCustomCursor(Image cursor, Point hotSpot, String name)
 851         throws IndexOutOfBoundsException {
 852         return new WCustomCursor(cursor, hotSpot, name);
 853     }
 854 
 855     /**
 856      * Returns the supported cursor size (Win32 only has one).
 857      */
 858     @Override
 859     public Dimension getBestCursorSize(int preferredWidth, int preferredHeight) {
 860         return new Dimension(WCustomCursor.getCursorWidth(),
 861                              WCustomCursor.getCursorHeight());
 862     }
 863 
 864     @Override
 865     public native int getMaximumCursorColors();
 866 
 867     static void paletteChanged() {
 868         Object lge = GraphicsEnvironment.getLocalGraphicsEnvironment();
 869         if (lge instanceof DisplayChangedListener) {
 870             ((DisplayChangedListener) lge).paletteChanged();
 871         }
 872     }
 873 
 874     private static ExecutorService displayChangeExecutor;
 875 
 876     /*
 877      * Called from Toolkit native code when a WM_DISPLAYCHANGE occurs.
 878      * Have Win32GraphicsEnvironment execute the display change code on the
 879      * Event thread.
 880      */
 881     public static void displayChanged() {
 882         final Runnable runnable = () -&gt; {
 883             Object lge = GraphicsEnvironment.getLocalGraphicsEnvironment();
 884             if (lge instanceof DisplayChangedListener) {
 885                 ((DisplayChangedListener) lge).displayChanged();
 886             }
 887         };
 888         if (AppContext.getAppContext() != null) {
 889             // Common case, standalone application
 890             EventQueue.invokeLater(runnable);
 891         } else {
 892             if (displayChangeExecutor == null) {
 893                 // No synchronization, called on the Toolkit thread only
 894                 displayChangeExecutor = Executors.newFixedThreadPool(1, r -&gt; {
 895                     Thread t = Executors.defaultThreadFactory().newThread(r);
 896                     t.setDaemon(true);
 897                     return t;
 898                 });
 899             }
 900             displayChangeExecutor.submit(runnable);
 901         }
 902     }
 903 
 904     /**
 905      * create the peer for a DragSourceContext
 906      */
 907 
 908     @Override
 909     public DragSourceContextPeer createDragSourceContextPeer(DragGestureEvent dge) throws InvalidDnDOperationException {
 910         final LightweightFrame f = SunToolkit.getLightweightFrame(dge.getComponent());
 911         if (f != null) {
 912             return f.createDragSourceContextPeer(dge);
 913         }
 914 
 915         return WDragSourceContextPeer.createDragSourceContextPeer(dge);
 916     }
 917 
 918     @Override
 919     @SuppressWarnings(&quot;unchecked&quot;)
 920     public &lt;T extends DragGestureRecognizer&gt; T
 921         createDragGestureRecognizer(Class&lt;T&gt; abstractRecognizerClass,
 922                                     DragSource ds, Component c, int srcActions,
 923                                     DragGestureListener dgl)
 924     {
 925         final LightweightFrame f = SunToolkit.getLightweightFrame(c);
 926         if (f != null) {
 927             return f.createDragGestureRecognizer(abstractRecognizerClass, ds, c, srcActions, dgl);
 928         }
 929 
 930         if (MouseDragGestureRecognizer.class.equals(abstractRecognizerClass))
 931             return (T)new WMouseDragGestureRecognizer(ds, c, srcActions, dgl);
 932         else
 933             return null;
 934     }
 935 
 936     /**
 937      *
 938      */
 939 
 940     private static final String prefix  = &quot;DnD.Cursor.&quot;;
 941     private static final String postfix = &quot;.32x32&quot;;
 942     private static final String awtPrefix  = &quot;awt.&quot;;
 943     private static final String dndPrefix  = &quot;DnD.&quot;;
 944 
 945     @Override
 946     protected Object lazilyLoadDesktopProperty(String name) {
 947         if (name.startsWith(prefix)) {
 948             String cursorName = name.substring(prefix.length(), name.length()) + postfix;
 949 
 950             try {
 951                 return Cursor.getSystemCustomCursor(cursorName);
 952             } catch (AWTException awte) {
 953                 throw new RuntimeException(&quot;cannot load system cursor: &quot; + cursorName, awte);
 954             }
 955         }
 956 
 957         if (name.equals(&quot;awt.dynamicLayoutSupported&quot;)) {
 958             return  Boolean.valueOf(isDynamicLayoutSupported());
 959         }
 960 
 961         if (WDesktopProperties.isWindowsProperty(name) ||
 962             name.startsWith(awtPrefix) || name.startsWith(dndPrefix))
 963         {
 964             synchronized(this) {
 965                 lazilyInitWProps();
 966                 return desktopProperties.get(name);
 967             }
 968         }
 969 
 970         return super.lazilyLoadDesktopProperty(name);
 971     }
 972 
 973     private synchronized void lazilyInitWProps() {
 974         if (wprops == null) {
 975             wprops = new WDesktopProperties(this);
 976             updateProperties(wprops.getProperties());
 977         }
 978     }
 979 
 980     /*
 981      * Called from lazilyLoadDesktopProperty because Windows doesn&#39;t
 982      * always send WM_SETTINGCHANGE when it should.
 983      */
 984     private synchronized boolean isDynamicLayoutSupported() {
 985         boolean nativeDynamic = isDynamicLayoutSupportedNative();
 986         lazilyInitWProps();
 987         Boolean prop = (Boolean) desktopProperties.get(&quot;awt.dynamicLayoutSupported&quot;);
 988 
 989         if (log.isLoggable(PlatformLogger.Level.FINER)) {
 990             log.finer(&quot;In WTK.isDynamicLayoutSupported()&quot; +
 991                       &quot;   nativeDynamic == &quot; + nativeDynamic +
 992                       &quot;   wprops.dynamic == &quot; + prop);
 993         }
 994 
 995         if ((prop == null) || (nativeDynamic != prop.booleanValue())) {
 996             // We missed the WM_SETTINGCHANGE, so we pretend
 997             // we just got one - fire the propertyChange, etc.
 998             windowsSettingChange();
 999             return nativeDynamic;
1000         }
1001 
1002         return prop.booleanValue();
1003     }
1004 
1005     /*
1006      * Called from native toolkit code when WM_SETTINGCHANGE message received
1007      * Also called from lazilyLoadDynamicLayoutSupportedProperty because
1008      * Windows doesn&#39;t always send WM_SETTINGCHANGE when it should.
1009      */
1010     private void windowsSettingChange() {
1011         // JDK-8039383: Have to update the value of XPSTYLE_THEME_ACTIVE property
1012         // as soon as possible to prevent NPE and other errors because theme data
1013         // has become unavailable.
1014         final Map&lt;String, Object&gt; props = getWProps();
1015         if (props == null) {
1016             // props has not been initialized, so we have nothing to update
1017             return;
1018         }
1019 
1020         updateXPStyleEnabled(props.get(XPSTYLE_THEME_ACTIVE));
1021 
1022         if (AppContext.getAppContext() == null) {
1023             // We cannot post the update to any EventQueue. Listeners will
1024             // be called on EDTs by DesktopPropertyChangeSupport
1025             updateProperties(props);
1026         } else {
1027             // Cannot update on Toolkit thread.
1028             // DesktopPropertyChangeSupport will call listeners on Toolkit
1029             // thread if it has AppContext (standalone mode)
1030             EventQueue.invokeLater(() -&gt; updateProperties(props));
1031         }
1032     }
1033 
1034     private synchronized void updateProperties(final Map&lt;String, Object&gt; props) {
1035         if (null == props) {
1036             return;
1037         }
1038 
1039         updateXPStyleEnabled(props.get(XPSTYLE_THEME_ACTIVE));
1040 
1041         for (String propName : props.keySet()) {
1042             Object val = props.get(propName);
1043             if (log.isLoggable(PlatformLogger.Level.FINER)) {
1044                 log.finer(&quot;changed &quot; + propName + &quot; to &quot; + val);
1045             }
1046             setDesktopProperty(propName, val);
1047         }
1048     }
1049 
1050     private synchronized Map&lt;String, Object&gt; getWProps() {
1051         return (wprops != null) ? wprops.getProperties() : null;
1052     }
1053 
1054     private void updateXPStyleEnabled(final Object dskProp) {
1055         ThemeReader.xpStyleEnabled = Boolean.TRUE.equals(dskProp);
1056     }
1057 
1058     @Override
1059     public synchronized void addPropertyChangeListener(String name, PropertyChangeListener pcl) {
1060         if (name == null) {
1061             // See JavaDoc for the Toolkit.addPropertyChangeListener() method
1062             return;
1063         }
1064         if ( WDesktopProperties.isWindowsProperty(name)
1065              || name.startsWith(awtPrefix)
1066              || name.startsWith(dndPrefix))
1067         {
1068             // someone is interested in Windows-specific desktop properties
1069             // we should initialize wprops
1070             lazilyInitWProps();
1071         }
1072         super.addPropertyChangeListener(name, pcl);
1073     }
1074 
1075     /*
1076      * initialize only static props here and do not try to initialize props which depends on wprops,
1077      * this should be done in lazilyLoadDesktopProperty() only.
1078      */
1079     @Override
1080     protected synchronized void initializeDesktopProperties() {
1081         desktopProperties.put(&quot;DnD.Autoscroll.initialDelay&quot;,
1082                               Integer.valueOf(50));
1083         desktopProperties.put(&quot;DnD.Autoscroll.interval&quot;,
1084                               Integer.valueOf(50));
1085         desktopProperties.put(&quot;DnD.isDragImageSupported&quot;,
1086                               Boolean.TRUE);
1087         desktopProperties.put(&quot;Shell.shellFolderManager&quot;,
1088                               &quot;sun.awt.shell.Win32ShellFolderManager2&quot;);
1089     }
1090 
1091     /*
1092      * This returns the value for the desktop property &quot;awt.font.desktophints&quot;
1093      * This requires that the Windows properties have already been gathered.
1094      */
1095     @Override
1096     protected synchronized RenderingHints getDesktopAAHints() {
1097         if (wprops == null) {
1098             return null;
1099         } else {
1100             return wprops.getDesktopAAHints();
1101         }
1102     }
1103 
1104     @Override
1105     public boolean isModalityTypeSupported(Dialog.ModalityType modalityType) {
1106         return (modalityType == null) ||
1107                (modalityType == Dialog.ModalityType.MODELESS) ||
1108                (modalityType == Dialog.ModalityType.DOCUMENT_MODAL) ||
1109                (modalityType == Dialog.ModalityType.APPLICATION_MODAL) ||
1110                (modalityType == Dialog.ModalityType.TOOLKIT_MODAL);
1111     }
1112 
1113     @Override
1114     public boolean isModalExclusionTypeSupported(Dialog.ModalExclusionType exclusionType) {
1115         return (exclusionType == null) ||
1116                (exclusionType == Dialog.ModalExclusionType.NO_EXCLUDE) ||
1117                (exclusionType == Dialog.ModalExclusionType.APPLICATION_EXCLUDE) ||
1118                (exclusionType == Dialog.ModalExclusionType.TOOLKIT_EXCLUDE);
1119     }
1120 
1121     public static WToolkit getWToolkit() {
1122         WToolkit toolkit = (WToolkit)Toolkit.getDefaultToolkit();
1123         return toolkit;
1124     }
1125 
1126     /**
1127      * There are two reasons why we don&#39;t use buffer per window when
1128      * Vista&#39;s DWM (aka Aero) is enabled:
1129      * - since with DWM all windows are already double-buffered, the application
1130      *   doesn&#39;t get expose events so we don&#39;t get to use our true back-buffer,
1131      *   wasting memory and performance (this is valid for both d3d and gdi
1132      *   pipelines)
1133      * - in some cases with buffer per window enabled it is possible for the
1134      *   paint manager to redirect rendering to the screen for some operations
1135      *   (like copyArea), and since bpw uses its own BufferStrategy the
1136      *   d3d onscreen rendering support is disabled and rendering goes through
1137      *   GDI. This doesn&#39;t work well with Vista&#39;s DWM since one
1138      *   can not perform GDI and D3D operations on the same surface
1139      *   (see 6630702 for more info)
1140      *
1141      * Note: even though DWM composition state can change during the lifetime
1142      * of the application it is a rare event, and it is more often that it
1143      * is temporarily disabled (because of some app) than it is getting
1144      * permanently enabled so we can live with this approach without the
1145      * complexity of dwm state listeners and such. This can be revisited if
1146      * proved otherwise.
1147      */
1148     @Override
1149     public boolean useBufferPerWindow() {
1150         return !Win32GraphicsEnvironment.isDWMCompositionEnabled();
1151     }
1152 
1153     @Override
1154     public void grab(Window w) {
1155         final Object peer = AWTAccessor.getComponentAccessor().getPeer(w);
1156         if (peer != null) {
1157             ((WWindowPeer) peer).grab();
1158         }
1159     }
1160 
1161     @Override
1162     public void ungrab(Window w) {
1163         final Object peer = AWTAccessor.getComponentAccessor().getPeer(w);
1164         if (peer != null) {
1165             ((WWindowPeer) peer).ungrab();
1166         }
1167     }
1168 
1169     ///////////////////////////////////////////////////////////////////////////
1170     // The following code is used for support of automatic showing of the touch
1171     // keyboard for text components and is accessed only from EDT.
1172     ///////////////////////////////////////////////////////////////////////////
1173     private static final WeakReference&lt;Component&gt; NULL_COMPONENT_WR =
1174         new WeakReference&lt;&gt;(null);
1175     private volatile WeakReference&lt;Component&gt; compOnTouchDownEvent =
1176         NULL_COMPONENT_WR;
1177     private volatile WeakReference&lt;Component&gt; compOnMousePressedEvent =
1178         NULL_COMPONENT_WR;
1179 
1180     private boolean isComponentValidForTouchKeyboard(Component comp) {
1181         if ((comp != null) &amp;&amp; comp.isEnabled() &amp;&amp; comp.isFocusable() &amp;&amp;
1182             (((comp instanceof TextComponent) &amp;&amp;
1183                     ((TextComponent) comp).isEditable()) ||
1184                 ((comp instanceof JTextComponent) &amp;&amp;
1185                     ((JTextComponent) comp).isEditable()))) {
1186             return true;
1187         }
1188         return false;
1189     }
1190 
1191     @Override
1192     public void showOrHideTouchKeyboard(Component comp, AWTEvent e) {
1193         if (!(comp instanceof TextComponent) &amp;&amp;
1194             !(comp instanceof JTextComponent)) {
1195             return;
1196         }
1197 
1198         if ((e instanceof MouseEvent) &amp;&amp; isComponentValidForTouchKeyboard(comp)) {
1199             MouseEvent me = (MouseEvent) e;
1200             if (me.getID() == MouseEvent.MOUSE_PRESSED) {
1201                 if (AWTAccessor.getMouseEventAccessor().isCausedByTouchEvent(me)) {
1202                     compOnTouchDownEvent = new WeakReference&lt;&gt;(comp);
1203                 } else {
1204                     compOnMousePressedEvent = new WeakReference&lt;&gt;(comp);
1205                 }
1206             } else if (me.getID() == MouseEvent.MOUSE_RELEASED) {
1207                 if (AWTAccessor.getMouseEventAccessor().isCausedByTouchEvent(me)) {
1208                     if (compOnTouchDownEvent.get() == comp) {
1209                         showTouchKeyboard(true);
1210                     }
1211                     compOnTouchDownEvent = NULL_COMPONENT_WR;
1212                 } else {
1213                     if (compOnMousePressedEvent.get() == comp) {
1214                         showTouchKeyboard(false);
1215                     }
1216                     compOnMousePressedEvent = NULL_COMPONENT_WR;
1217                 }
1218             }
1219         } else if (e instanceof FocusEvent) {
1220             FocusEvent fe = (FocusEvent) e;
1221             if (fe.getID() == FocusEvent.FOCUS_LOST) {
1222                 // Hide the touch keyboard, if not a text component gains focus.
1223                 if (!isComponentValidForTouchKeyboard(fe.getOppositeComponent())) {
1224                     hideTouchKeyboard();
1225                 }
1226             }
1227         }
1228     }
1229 
1230     private native void showTouchKeyboard(boolean causedByTouchEvent);
1231     private native void hideTouchKeyboard();
1232     ///////////////////////////////////////////////////////////////////////////
1233     // End of the touch keyboard related code.
1234     ///////////////////////////////////////////////////////////////////////////
1235 
1236     @Override
1237     public native boolean syncNativeQueue(final long timeout);
1238 
1239     @Override
1240     public boolean isDesktopSupported() {
1241         return true;
1242     }
1243 
1244     @Override
1245     public DesktopPeer createDesktopPeer(Desktop target) {
1246         return new WDesktopPeer();
1247     }
1248 
1249     @Override
1250     public boolean isTaskbarSupported() {
1251         return WTaskbarPeer.isTaskbarSupported();
1252     }
1253 
1254     @Override
1255     public TaskbarPeer createTaskbarPeer(Taskbar target) {
1256         return new WTaskbarPeer();
1257     }
1258 
1259     private static native void setExtraMouseButtonsEnabledNative(boolean enable);
1260 
1261     @Override
1262     public boolean areExtraMouseButtonsEnabled() throws HeadlessException {
1263         return areExtraMouseButtonsEnabled;
1264     }
1265 
1266     private synchronized native int getNumberOfButtonsImpl();
1267 
1268     @Override
1269     public int getNumberOfButtons(){
1270         if (numberOfButtons == 0) {
1271             numberOfButtons = getNumberOfButtonsImpl();
1272         }
1273         return (numberOfButtons &gt; MAX_BUTTONS_SUPPORTED)? MAX_BUTTONS_SUPPORTED : numberOfButtons;
1274     }
1275 
1276     @Override
1277     public boolean isWindowOpacitySupported() {
1278         // supported in Win2K and later
1279         return true;
1280     }
1281 
1282     @Override
1283     public boolean isWindowShapingSupported() {
1284         return true;
1285     }
1286 
1287     @Override
1288     public boolean isWindowTranslucencySupported() {
1289         // supported in Win2K and later
1290         return true;
1291     }
1292 
1293     @Override
1294     public boolean isTranslucencyCapable(GraphicsConfiguration gc) {
1295         //XXX: worth checking if 8-bit? Anyway, it doesn&#39;t hurt.
1296         return true;
1297     }
1298 
1299     // On MS Windows one must use the peer.updateWindow() to implement
1300     // non-opaque windows.
1301     @Override
1302     public boolean needUpdateWindow() {
1303         return true;
1304     }
1305 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
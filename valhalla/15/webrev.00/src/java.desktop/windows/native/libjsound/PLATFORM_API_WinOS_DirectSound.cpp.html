<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/windows/native/libjsound/PLATFORM_API_WinOS_DirectSound.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #define USE_ERROR
  27 #define USE_TRACE
  28 
  29 /* define this for the silencing/servicing code. Requires USE_TRACE */
  30 //#define USE_DEBUG_SILENCING
  31 
  32 #ifndef WIN32_EXTRA_LEAN
  33 #define WIN32_EXTRA_LEAN
  34 #endif
  35 #ifndef WIN32_LEAN_AND_MEAN
  36 #define WIN32_LEAN_AND_MEAN
  37 #endif
  38 
  39 #include &lt;windows.h&gt;
  40 #include &lt;mmsystem.h&gt;
  41 #include &lt;string.h&gt;
  42 
  43 /* include DirectSound headers */
  44 #include &lt;dsound.h&gt;
  45 
  46 /* include Java Sound specific headers as C code */
  47 #ifdef __cplusplus
  48 extern &quot;C&quot; {
  49 #endif
  50  #include &quot;DirectAudio.h&quot;
  51 #ifdef __cplusplus
  52 }
  53 #endif
  54 
  55 /* include to prevent charset problem */
  56 #include &quot;PLATFORM_API_WinOS_Charset_Util.h&quot;
  57 
  58 #ifdef USE_DEBUG_SILENCING
  59 #define DEBUG_SILENCING0(p) TRACE0(p)
  60 #define DEBUG_SILENCING1(p1,p2) TRACE1(p1,p2)
  61 #define DEBUG_SILENCING2(p1,p2,p3) TRACE2(p1,p2,p3)
  62 #else
  63 #define DEBUG_SILENCING0(p)
  64 #define DEBUG_SILENCING1(p1,p2)
  65 #define DEBUG_SILENCING2(p1,p2,p3)
  66 #endif
  67 
  68 
  69 #if USE_DAUDIO == TRUE
  70 
  71 /* 3 seconds to wait before device list is re-read */
  72 #define WAIT_BETWEEN_CACHE_REFRESH_MILLIS 3000
  73 
  74 /* maximum number of supported devices, playback+capture */
  75 #define MAX_DS_DEVICES 60
  76 
  77 typedef struct {
  78     INT32 mixerIndex;
  79     BOOL isSource;
  80     /* either LPDIRECTSOUND or LPDIRECTSOUNDCAPTURE */
  81     void* dev;
  82     /* how many instances use the dev */
  83     INT32 refCount;
  84     GUID guid;
  85 } DS_AudioDeviceCache;
  86 
  87 static DS_AudioDeviceCache g_audioDeviceCache[MAX_DS_DEVICES];
  88 static INT32 g_cacheCount = 0;
  89 static UINT64 g_lastCacheRefreshTime = 0;
  90 static INT32 g_mixerCount = 0;
  91 
  92 BOOL DS_lockCache() {
  93     /* dummy implementation for now, Java does locking */
  94     return TRUE;
  95 }
  96 
  97 void DS_unlockCache() {
  98     /* dummy implementation for now */
  99 }
 100 
 101 static GUID CLSID_DAUDIO_Zero = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
 102 
 103 BOOL isEqualGUID(LPGUID lpGuid1, LPGUID lpGuid2) {
 104     if (lpGuid1 == NULL || lpGuid2 == NULL) {
 105         if (lpGuid1 == lpGuid2) {
 106             return TRUE;
 107         }
 108         if (lpGuid1 == NULL) {
 109             lpGuid1 = (LPGUID) (&amp;CLSID_DAUDIO_Zero);
 110         } else {
 111             lpGuid2 = (LPGUID) (&amp;CLSID_DAUDIO_Zero);
 112         }
 113     }
 114     return memcmp(lpGuid1, lpGuid2, sizeof(GUID)) == 0;
 115 }
 116 
 117 INT32 findCacheItemByGUID(LPGUID lpGuid, BOOL isSource) {
 118     int i;
 119     for (i = 0; i &lt; g_cacheCount; i++) {
 120         if (isSource == g_audioDeviceCache[i].isSource
 121             &amp;&amp; isEqualGUID(lpGuid, &amp;(g_audioDeviceCache[i].guid))) {
 122             return i;
 123         }
 124     }
 125     return -1;
 126 }
 127 
 128 INT32 findCacheItemByMixerIndex(INT32 mixerIndex) {
 129     int i;
 130     for (i = 0; i &lt; g_cacheCount; i++) {
 131         if (g_audioDeviceCache[i].mixerIndex == mixerIndex) {
 132             return i;
 133         }
 134     }
 135     return -1;
 136 }
 137 
 138 typedef struct {
 139     INT32 currMixerIndex;
 140     BOOL isSource;
 141 } DS_RefreshCacheStruct;
 142 
 143 
 144 BOOL CALLBACK DS_RefreshCacheEnum(LPGUID lpGuid,
 145                                   LPCSTR lpstrDescription,
 146                                   LPCSTR lpstrModule,
 147                                   DS_RefreshCacheStruct* rs) {
 148     INT32 cacheIndex = findCacheItemByGUID(lpGuid, rs-&gt;isSource);
 149     /*TRACE3(&quot;Enumerating %d: %s (%s)\n&quot;, cacheIndex, lpstrDescription, lpstrModule);*/
 150     if (cacheIndex == -1) {
 151         /* add this device */
 152         if (g_cacheCount &lt; MAX_DS_DEVICES-1) {
 153             g_audioDeviceCache[g_cacheCount].mixerIndex = rs-&gt;currMixerIndex;
 154             g_audioDeviceCache[g_cacheCount].isSource = rs-&gt;isSource;
 155             g_audioDeviceCache[g_cacheCount].dev = NULL;
 156             g_audioDeviceCache[g_cacheCount].refCount = 0;
 157             if (lpGuid == NULL) {
 158                 memset(&amp;(g_audioDeviceCache[g_cacheCount].guid), 0, sizeof(GUID));
 159             } else {
 160                 memcpy(&amp;(g_audioDeviceCache[g_cacheCount].guid), lpGuid, sizeof(GUID));
 161             }
 162             g_cacheCount++;
 163             rs-&gt;currMixerIndex++;
 164         } else {
 165             /* failure case: more than MAX_DS_DEVICES available... */
 166         }
 167     } else {
 168         /* device already exists in cache... update mixer number */
 169         g_audioDeviceCache[cacheIndex].mixerIndex = rs-&gt;currMixerIndex;
 170         rs-&gt;currMixerIndex++;
 171     }
 172     /* continue enumeration */
 173     return TRUE;
 174 }
 175 
 176 ///// implemented functions of DirectAudio.h
 177 
 178 INT32 DAUDIO_GetDirectAudioDeviceCount() {
 179     DS_RefreshCacheStruct rs;
 180     INT32 oldCount;
 181     INT32 cacheIndex;
 182 
 183     if (!DS_lockCache()) {
 184         return 0;
 185     }
 186 
 187     if (g_lastCacheRefreshTime == 0
 188         || (UINT64) timeGetTime() &gt; (UINT64) (g_lastCacheRefreshTime + WAIT_BETWEEN_CACHE_REFRESH_MILLIS)) {
 189         /* first, initialize any old cache items */
 190         for (cacheIndex = 0; cacheIndex &lt; g_cacheCount; cacheIndex++) {
 191             g_audioDeviceCache[cacheIndex].mixerIndex = -1;
 192         }
 193 
 194         /* enumerate all devices and either add them to the device cache,
 195          * or refresh the mixer number
 196          */
 197         rs.currMixerIndex = 0;
 198         rs.isSource = TRUE;
 199         DirectSoundEnumerate((LPDSENUMCALLBACK) DS_RefreshCacheEnum, &amp;rs);
 200         /* if we only got the Primary Sound Driver (GUID=NULL),
 201          * then there aren&#39;t any playback devices installed */
 202         if (rs.currMixerIndex == 1) {
 203             cacheIndex = findCacheItemByGUID(NULL, TRUE);
 204             if (cacheIndex == 0) {
 205                 rs.currMixerIndex = 0;
 206                 g_audioDeviceCache[0].mixerIndex = -1;
 207                 TRACE0(&quot;Removing stale Primary Sound Driver from list.\n&quot;);
 208             }
 209         }
 210         oldCount = rs.currMixerIndex;
 211         rs.isSource = FALSE;
 212         DirectSoundCaptureEnumerate((LPDSENUMCALLBACK) DS_RefreshCacheEnum, &amp;rs);
 213         /* if we only got the Primary Sound Capture Driver (GUID=NULL),
 214          * then there aren&#39;t any capture devices installed */
 215         if ((rs.currMixerIndex - oldCount) == 1) {
 216             cacheIndex = findCacheItemByGUID(NULL, FALSE);
 217             if (cacheIndex != -1) {
 218                 rs.currMixerIndex = oldCount;
 219                 g_audioDeviceCache[cacheIndex].mixerIndex = -1;
 220                 TRACE0(&quot;Removing stale Primary Sound Capture Driver from list.\n&quot;);
 221             }
 222         }
 223         g_mixerCount = rs.currMixerIndex;
 224 
 225         g_lastCacheRefreshTime = (UINT64) timeGetTime();
 226     }
 227     DS_unlockCache();
 228     /*TRACE1(&quot;DirectSound: %d installed devices\n&quot;, g_mixerCount);*/
 229     return g_mixerCount;
 230 }
 231 
 232 BOOL CALLBACK DS_GetDescEnum(LPGUID lpGuid,
 233                              LPCWSTR lpstrDescription,
 234                              LPCWSTR lpstrModule,
 235                              DirectAudioDeviceDescription* desc) {
 236 
 237     INT32 cacheIndex = findCacheItemByGUID(lpGuid, g_audioDeviceCache[desc-&gt;deviceID].isSource);
 238     if (cacheIndex == desc-&gt;deviceID) {
 239         UnicodeToUTF8AndCopy(desc-&gt;name, lpstrDescription, DAUDIO_STRING_LENGTH);
 240         //strncpy(desc-&gt;description, lpstrModule, DAUDIO_STRING_LENGTH);
 241         desc-&gt;maxSimulLines = -1;
 242         /* do not continue enumeration */
 243         return FALSE;
 244     }
 245     return TRUE;
 246 }
 247 
 248 
 249 INT32 DAUDIO_GetDirectAudioDeviceDescription(INT32 mixerIndex, DirectAudioDeviceDescription* desc) {
 250 
 251     if (!DS_lockCache()) {
 252         return FALSE;
 253     }
 254 
 255     /* set the deviceID field to the cache index */
 256     desc-&gt;deviceID = findCacheItemByMixerIndex(mixerIndex);
 257     if (desc-&gt;deviceID &lt; 0) {
 258         DS_unlockCache();
 259         return FALSE;
 260     }
 261     desc-&gt;maxSimulLines = 0;
 262     if (g_audioDeviceCache[desc-&gt;deviceID].isSource) {
 263         DirectSoundEnumerateW((LPDSENUMCALLBACKW) DS_GetDescEnum, desc);
 264         strncpy(desc-&gt;description, &quot;DirectSound Playback&quot;, DAUDIO_STRING_LENGTH);
 265     } else {
 266         DirectSoundCaptureEnumerateW((LPDSENUMCALLBACKW) DS_GetDescEnum, desc);
 267         strncpy(desc-&gt;description, &quot;DirectSound Capture&quot;, DAUDIO_STRING_LENGTH);
 268     }
 269 
 270     /*desc-&gt;vendor;
 271     desc-&gt;version;*/
 272 
 273     DS_unlockCache();
 274     return (desc-&gt;maxSimulLines == -1)?TRUE:FALSE;
 275 }
 276 
 277 /* multi-channel info: http://www.microsoft.com/whdc/hwdev/tech/audio/multichaud.mspx */
 278 
 279 //static UINT32 sampleRateArray[] = { 8000, 11025, 16000, 22050, 32000, 44100, 48000, 56000, 88000, 96000, 172000, 192000 };
 280 static INT32 sampleRateArray[] = { -1 };
 281 static INT32 channelsArray[] = { 1, 2};
 282 static INT32 bitsArray[] = { 8, 16};
 283 
 284 #define SAMPLERATE_COUNT sizeof(sampleRateArray)/sizeof(INT32)
 285 #define CHANNELS_COUNT sizeof(channelsArray)/sizeof(INT32)
 286 #define BITS_COUNT sizeof(bitsArray)/sizeof(INT32)
 287 
 288 void DAUDIO_GetFormats(INT32 mixerIndex, INT32 deviceID, int isSource, void* creator) {
 289 
 290     int rateIndex, channelIndex, bitIndex;
 291 
 292     /* no need to lock, since deviceID identifies the device sufficiently */
 293 
 294     /* sanity */
 295     if (deviceID &gt;= g_cacheCount) {
 296         return;
 297     }
 298     if ((g_audioDeviceCache[deviceID].isSource &amp;&amp; !isSource)
 299         || (!g_audioDeviceCache[deviceID].isSource &amp;&amp; isSource)) {
 300         /* only support Playback or Capture */
 301         return;
 302     }
 303 
 304     for (rateIndex = 0; rateIndex &lt; SAMPLERATE_COUNT; rateIndex++) {
 305         for (channelIndex = 0; channelIndex &lt; CHANNELS_COUNT; channelIndex++) {
 306             for (bitIndex = 0; bitIndex &lt; BITS_COUNT; bitIndex++) {
 307                 DAUDIO_AddAudioFormat(creator, bitsArray[bitIndex],
 308                                       ((bitsArray[bitIndex] + 7) / 8) * channelsArray[channelIndex],
 309                                       channelsArray[channelIndex],
 310                                       (float) sampleRateArray[rateIndex],
 311                                       DAUDIO_PCM,
 312                                       (bitsArray[bitIndex]==8)?FALSE:TRUE,  /* signed */
 313                                       (bitsArray[bitIndex]==8)?FALSE:
 314 #ifndef _LITTLE_ENDIAN
 315                                       TRUE /* big endian */
 316 #else
 317                                       FALSE /* little endian */
 318 #endif
 319                                       );
 320             }
 321         }
 322     }
 323 }
 324 
 325 typedef struct {
 326     int deviceID;
 327     /* for convenience */
 328     BOOL isSource;
 329     /* the secondary buffer (Playback) */
 330     LPDIRECTSOUNDBUFFER playBuffer;
 331     /* the secondary buffer (Capture) */
 332     LPDIRECTSOUNDCAPTUREBUFFER captureBuffer;
 333 
 334     /* size of the directsound buffer, usually 2 seconds */
 335     int dsBufferSizeInBytes;
 336 
 337     /* size of the read/write-ahead, as specified by Java */
 338     int bufferSizeInBytes;
 339     int bitsPerSample;
 340     int frameSize; // storage size in Bytes
 341 
 342     UINT64 framePos;
 343     /* where to write into the buffer.
 344      * -1 if at current position (Playback)
 345      * For Capture, this is the read position
 346      */
 347     int writePos;
 348 
 349     /* if start() had been called */
 350     BOOL started;
 351 
 352     /* how many bytes there is silence from current write position */
 353     int silencedBytes;
 354 
 355     BOOL underrun;
 356 
 357 } DS_Info;
 358 
 359 
 360 LPCSTR TranslateDSError(HRESULT hr) {
 361     switch(hr) {
 362         case DSERR_ALLOCATED:
 363             return &quot;DSERR_ALLOCATED&quot;;
 364 
 365         case DSERR_CONTROLUNAVAIL:
 366             return &quot;DSERR_CONTROLUNAVAIL&quot;;
 367 
 368         case DSERR_INVALIDPARAM:
 369             return &quot;DSERR_INVALIDPARAM&quot;;
 370 
 371         case DSERR_INVALIDCALL:
 372             return &quot;DSERR_INVALIDCALL&quot;;
 373 
 374         case DSERR_GENERIC:
 375             return &quot;DSERR_GENERIC&quot;;
 376 
 377         case DSERR_PRIOLEVELNEEDED:
 378             return &quot;DSERR_PRIOLEVELNEEDED&quot;;
 379 
 380         case DSERR_OUTOFMEMORY:
 381             return &quot;DSERR_OUTOFMEMORY&quot;;
 382 
 383         case DSERR_BADFORMAT:
 384             return &quot;DSERR_BADFORMAT&quot;;
 385 
 386         case DSERR_UNSUPPORTED:
 387             return &quot;DSERR_UNSUPPORTED&quot;;
 388 
 389         case DSERR_NODRIVER:
 390             return &quot;DSERR_NODRIVER&quot;;
 391 
 392         case DSERR_ALREADYINITIALIZED:
 393             return &quot;DSERR_ALREADYINITIALIZED&quot;;
 394 
 395         case DSERR_NOAGGREGATION:
 396             return &quot;DSERR_NOAGGREGATION&quot;;
 397 
 398         case DSERR_BUFFERLOST:
 399             return &quot;DSERR_BUFFERLOST&quot;;
 400 
 401         case DSERR_OTHERAPPHASPRIO:
 402             return &quot;DSERR_OTHERAPPHASPRIO&quot;;
 403 
 404         case DSERR_UNINITIALIZED:
 405             return &quot;DSERR_UNINITIALIZED&quot;;
 406 
 407         default:
 408             return &quot;Unknown HRESULT&quot;;
 409         }
 410 }
 411 
 412 /*
 413 ** data/routines for starting DS buffers by separate thread
 414 ** (joint into DS_StartBufferHelper class)
 415 ** see cr6372428: playback fails after exiting from thread that has started it
 416 ** due IDirectSoundBuffer8::Play() description:
 417 ** http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/directx9_c
 418 **       /directx/htm/idirectsoundbuffer8play.asp
 419 ** (remark section): If the application is multithreaded, the thread that plays
 420 ** the buffer must continue to exist as long as the buffer is playing.
 421 ** Buffers created on WDM drivers stop playing when the thread is terminated.
 422 ** IDirectSoundCaptureBuffer8::Start() has the same remark:
 423 ** http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/directx9_c
 424 **       /directx/htm/idirectsoundcapturebuffer8start.asp
 425 */
 426 class DS_StartBufferHelper {
 427 public:
 428     /* starts DirectSound buffer (playback or capture) */
 429     static HRESULT StartBuffer(DS_Info* info);
 430     /* checks for initialization success */
 431     static inline BOOL isInitialized() { return data.threadHandle != NULL; }
 432 protected:
 433     DS_StartBufferHelper() {}  // no need to create an instance
 434 
 435     /* data class */
 436     class Data {
 437     public:
 438         Data();
 439         ~Data();
 440         // public data to access from parent class
 441         CRITICAL_SECTION crit_sect;
 442         volatile HANDLE threadHandle;
 443         volatile HANDLE startEvent;
 444         volatile HANDLE startedEvent;
 445         volatile DS_Info* line2Start;
 446         volatile HRESULT startResult;
 447     } static data;
 448 
 449     /* StartThread function */
 450     static DWORD WINAPI __stdcall ThreadProc(void *param);
 451 };
 452 
 453 /* StartBufferHelper class implementation
 454 */
 455 DS_StartBufferHelper::Data DS_StartBufferHelper::data;
 456 
 457 DS_StartBufferHelper::Data::Data() {
 458     threadHandle = NULL;
 459     ::InitializeCriticalSection(&amp;crit_sect);
 460     startEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
 461     startedEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
 462     if (startEvent != NULL &amp;&amp; startedEvent != NULL)
 463         threadHandle = ::CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);
 464 }
 465 
 466 DS_StartBufferHelper::Data::~Data() {
 467     ::EnterCriticalSection(&amp;crit_sect);
 468     if (threadHandle != NULL) {
 469         // terminate thread
 470         line2Start = NULL;
 471         ::SetEvent(startEvent);
 472         ::CloseHandle(threadHandle);
 473         threadHandle = NULL;
 474     }
 475     ::LeaveCriticalSection(&amp;crit_sect);
 476     // won&#39;t delete startEvent/startedEvent/crit_sect
 477     // - Windows will do during process shutdown
 478 }
 479 
 480 DWORD WINAPI __stdcall DS_StartBufferHelper::ThreadProc(void *param)
 481 {
 482     ::CoInitialize(NULL);
 483     while (1) {
 484         // wait for something to do
 485         ::WaitForSingleObject(data.startEvent, INFINITE);
 486         if (data.line2Start == NULL) {
 487             // (data.line2Start == NULL) is a signal to terminate thread
 488             break;
 489         }
 490         if (data.line2Start-&gt;isSource) {
 491             data.startResult =
 492                 data.line2Start-&gt;playBuffer-&gt;Play(0, 0, DSBPLAY_LOOPING);
 493         } else {
 494             data.startResult =
 495                 data.line2Start-&gt;captureBuffer-&gt;Start(DSCBSTART_LOOPING);
 496         }
 497         ::SetEvent(data.startedEvent);
 498     }
 499     ::CoUninitialize();
 500     return 0;
 501 }
 502 
 503 HRESULT DS_StartBufferHelper::StartBuffer(DS_Info* info) {
 504     HRESULT hr;
 505     ::EnterCriticalSection(&amp;data.crit_sect);
 506     if (!isInitialized()) {
 507         ::LeaveCriticalSection(&amp;data.crit_sect);
 508         return E_FAIL;
 509     }
 510     data.line2Start = info;
 511     ::SetEvent(data.startEvent);
 512     ::WaitForSingleObject(data.startedEvent, INFINITE);
 513     hr = data.startResult;
 514     ::LeaveCriticalSection(&amp;data.crit_sect);
 515     return hr;
 516 }
 517 
 518 
 519 /* helper routines for DS buffer positions */
 520 /* returns distance from pos1 to pos2
 521  */
 522 inline int DS_getDistance(DS_Info* info, int pos1, int pos2) {
 523     int distance = pos2 - pos1;
 524     while (distance &lt; 0)
 525         distance += info-&gt;dsBufferSizeInBytes;
 526     return distance;
 527 }
 528 
 529 /* adds 2 positions
 530  */
 531 inline int DS_addPos(DS_Info* info, int pos1, int pos2) {
 532     int result = pos1 + pos2;
 533     while (result &gt;= info-&gt;dsBufferSizeInBytes)
 534         result -= info-&gt;dsBufferSizeInBytes;
 535     return result;
 536 }
 537 
 538 
 539 BOOL DS_addDeviceRef(INT32 deviceID) {
 540     HWND ownerWindow;
 541     HRESULT res = DS_OK;
 542     LPDIRECTSOUND devPlay;
 543     LPDIRECTSOUNDCAPTURE devCapture;
 544     LPGUID lpGuid = NULL;
 545 
 546 
 547     if (g_audioDeviceCache[deviceID].dev == NULL) {
 548         /* Create DirectSound */
 549         TRACE1(&quot;Creating DirectSound object for device %d\n&quot;, deviceID);
 550         lpGuid = &amp;(g_audioDeviceCache[deviceID].guid);
 551         if (isEqualGUID(lpGuid, NULL)) {
 552             lpGuid = NULL;
 553         }
 554         if (g_audioDeviceCache[deviceID].isSource) {
 555             res = DirectSoundCreate(lpGuid, &amp;devPlay, NULL);
 556             g_audioDeviceCache[deviceID].dev = (void*) devPlay;
 557         } else {
 558             res = DirectSoundCaptureCreate(lpGuid, &amp;devCapture, NULL);
 559             g_audioDeviceCache[deviceID].dev = (void*) devCapture;
 560         }
 561         g_audioDeviceCache[deviceID].refCount = 0;
 562         if (FAILED(res)) {
 563             ERROR1(&quot;DAUDIO_Open: ERROR: Failed to create DirectSound: %s&quot;, TranslateDSError(res));
 564             g_audioDeviceCache[deviceID].dev = NULL;
 565             return FALSE;
 566         }
 567         if (g_audioDeviceCache[deviceID].isSource) {
 568             ownerWindow = GetForegroundWindow();
 569             if (ownerWindow == NULL) {
 570                 ownerWindow = GetDesktopWindow();
 571             }
 572             TRACE0(&quot;DAUDIO_Open: Setting cooperative level\n&quot;);
 573             res = devPlay-&gt;SetCooperativeLevel(ownerWindow, DSSCL_NORMAL);
 574             if (FAILED(res)) {
 575                 ERROR1(&quot;DAUDIO_Open: ERROR: Failed to set cooperative level: %s&quot;, TranslateDSError(res));
 576                 return FALSE;
 577             }
 578         }
 579     }
 580     g_audioDeviceCache[deviceID].refCount++;
 581     return TRUE;
 582 }
 583 
 584 #define DEV_PLAY(devID)    ((LPDIRECTSOUND) g_audioDeviceCache[devID].dev)
 585 #define DEV_CAPTURE(devID) ((LPDIRECTSOUNDCAPTURE) g_audioDeviceCache[devID].dev)
 586 
 587 void DS_removeDeviceRef(INT32 deviceID) {
 588 
 589     if (g_audioDeviceCache[deviceID].refCount) {
 590         g_audioDeviceCache[deviceID].refCount--;
 591     }
 592     if (g_audioDeviceCache[deviceID].refCount == 0) {
 593         if (g_audioDeviceCache[deviceID].dev != NULL) {
 594             if (g_audioDeviceCache[deviceID].isSource) {
 595                 DEV_PLAY(deviceID)-&gt;Release();
 596             } else {
 597                 DEV_CAPTURE(deviceID)-&gt;Release();
 598             }
 599             g_audioDeviceCache[deviceID].dev = NULL;
 600         }
 601     }
 602 }
 603 
 604 #ifndef _WAVEFORMATEXTENSIBLE_
 605 #define _WAVEFORMATEXTENSIBLE_
 606 typedef struct {
 607     WAVEFORMATEX    Format;
 608     union {
 609         WORD wValidBitsPerSample;       /* bits of precision  */
 610         WORD wSamplesPerBlock;          /* valid if wBitsPerSample==0 */
 611         WORD wReserved;                 /* If neither applies, set to zero. */
 612     } Samples;
 613     DWORD           dwChannelMask;      /* which channels are */
 614                                         /* present in stream  */
 615     GUID            SubFormat;
 616 } WAVEFORMATEXTENSIBLE, *PWAVEFORMATEXTENSIBLE;
 617 #endif // !_WAVEFORMATEXTENSIBLE_
 618 
 619 #if !defined(WAVE_FORMAT_EXTENSIBLE)
 620 #define  WAVE_FORMAT_EXTENSIBLE                 0xFFFE
 621 #endif // !defined(WAVE_FORMAT_EXTENSIBLE)
 622 
 623 #if !defined(DEFINE_WAVEFORMATEX_GUID)
 624 #define DEFINE_WAVEFORMATEX_GUID(x) (USHORT)(x), 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
 625 #endif
 626 #ifndef STATIC_KSDATAFORMAT_SUBTYPE_PCM
 627 #define STATIC_KSDATAFORMAT_SUBTYPE_PCM\
 628     DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_PCM)
 629 #endif
 630 
 631 
 632 void createWaveFormat(WAVEFORMATEXTENSIBLE* format,
 633                       int sampleRate,
 634                       int channels,
 635                       int bits,
 636                       int significantBits) {
 637     GUID subtypePCM = {STATIC_KSDATAFORMAT_SUBTYPE_PCM};
 638     format-&gt;Format.nSamplesPerSec = (DWORD)sampleRate;
 639     format-&gt;Format.nChannels = (WORD) channels;
 640     /* do not support useless padding, like 24-bit samples stored in 32-bit containers */
 641     format-&gt;Format.wBitsPerSample = (WORD) ((bits + 7) &amp; 0xFFF8);
 642 
 643     if (channels &lt;= 2 &amp;&amp; bits &lt;= 16) {
 644         format-&gt;Format.wFormatTag = WAVE_FORMAT_PCM;
 645         format-&gt;Format.cbSize = 0;
 646     } else {
 647         format-&gt;Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
 648         format-&gt;Format.cbSize = 22;
 649         format-&gt;Samples.wValidBitsPerSample = bits;
 650         /* no way to specify speaker locations */
 651         format-&gt;dwChannelMask = 0xFFFFFFFF;
 652         format-&gt;SubFormat = subtypePCM;
 653     }
 654     format-&gt;Format.nBlockAlign = (WORD)((format-&gt;Format.wBitsPerSample * format-&gt;Format.nChannels) / 8);
 655     format-&gt;Format.nAvgBytesPerSec = format-&gt;Format.nSamplesPerSec * format-&gt;Format.nBlockAlign;
 656 }
 657 
 658 /* fill buffer with silence
 659  */
 660 void DS_clearBuffer(DS_Info* info, BOOL fromWritePos) {
 661     UBYTE* pb1=NULL, *pb2=NULL;
 662     DWORD  cb1=0, cb2=0;
 663     DWORD flags = 0;
 664     int start, count;
 665     TRACE1(&quot;&gt; DS_clearBuffer for device %d\n&quot;, info-&gt;deviceID);
 666     if (info-&gt;isSource)  {
 667         if (fromWritePos) {
 668                 DWORD playCursor, writeCursor;
 669                 int end;
 670                 if (FAILED(info-&gt;playBuffer-&gt;GetCurrentPosition(&amp;playCursor, &amp;writeCursor))) {
 671                     ERROR0(&quot;  DS_clearBuffer: ERROR: Failed to get current position.&quot;);
 672                     TRACE0(&quot;&lt; DS_clearbuffer\n&quot;);
 673                     return;
 674                 }
 675                 DEBUG_SILENCING2(&quot;  DS_clearBuffer: DS playPos=%d  myWritePos=%d&quot;, (int) playCursor, (int) info-&gt;writePos);
 676                 if (info-&gt;writePos &gt;= 0) {
 677                     start = info-&gt;writePos + info-&gt;silencedBytes;
 678                 } else {
 679                     start = writeCursor + info-&gt;silencedBytes;
 680                     //flags |= DSBLOCK_FROMWRITECURSOR;
 681                 }
 682                 while (start &gt;= info-&gt;dsBufferSizeInBytes) {
 683                     start -= info-&gt;dsBufferSizeInBytes;
 684                 }
 685 
 686                 // fix for bug 6251460 (REGRESSION: short sounds do not play)
 687                 // for unknown reason with hardware DS buffer playCursor sometimes
 688                 // jumps back for little interval (mostly 2-8 bytes) (writeCursor moves forward as usual)
 689                 // The issue happens right after start playing and for short sounds only (less then DS buffer,
 690                 // when whole sound written into the buffer and remaining space filled by silence)
 691                 // the case doesn&#39;t produce any audible aftifacts so just catch it to prevent filling
 692                 // whole buffer by silence.
 693                 if (((int)playCursor &lt;= start &amp;&amp; start &lt; (int)writeCursor)
 694                     || (writeCursor &lt; playCursor    // buffer bound is between playCursor &amp; writeCursor
 695                         &amp;&amp; (start &lt; (int)writeCursor || (int)playCursor &lt;= start))) {
 696                     return;
 697                 }
 698 
 699                 count = info-&gt;dsBufferSizeInBytes - info-&gt;silencedBytes;
 700                 // why / 4?
 701                 //if (count &gt; info-&gt;dsBufferSizeInBytes / 4) {
 702                 //    count = info-&gt;dsBufferSizeInBytes / 4;
 703                 //}
 704                 end = start + count;
 705                 if ((int) playCursor &lt; start) {
 706                     playCursor += (DWORD) info-&gt;dsBufferSizeInBytes;
 707                 }
 708                 if (start &lt;= (int) playCursor &amp;&amp; end &gt; (int) playCursor) {
 709                     /* at maximum, silence until play cursor */
 710                     count = (int) playCursor - start;
 711 #ifdef USE_TRACE
 712                     if ((int) playCursor &gt;= info-&gt;dsBufferSizeInBytes) playCursor -= (DWORD) info-&gt;dsBufferSizeInBytes;
 713                     TRACE3(&quot;\n  DS_clearBuffer: Start Writing from %d, &quot;
 714                            &quot;would overwrite playCursor=%d, so reduce count to %d\n&quot;,
 715                            start, playCursor, count);
 716 #endif
 717                 }
 718                 DEBUG_SILENCING2(&quot;  clearing buffer from %d, count=%d. &quot;, (int)start, (int) count);
 719                 if (count &lt;= 0) {
 720                     DEBUG_SILENCING0(&quot;\n&quot;);
 721                     TRACE1(&quot;&lt; DS_clearBuffer: no need to clear, silencedBytes=%d\n&quot;, info-&gt;silencedBytes);
 722                     return;
 723                 }
 724         } else {
 725                 start = 0;
 726                 count = info-&gt;dsBufferSizeInBytes;
 727                 flags |= DSBLOCK_ENTIREBUFFER;
 728         }
 729         if (FAILED(info-&gt;playBuffer-&gt;Lock(start,
 730                                           count,
 731                                           (LPVOID*) &amp;pb1, &amp;cb1,
 732                                           (LPVOID*) &amp;pb2, &amp;cb2, flags))) {
 733             ERROR0(&quot;\n  DS_clearBuffer: ERROR: Failed to lock sound buffer.\n&quot;);
 734             TRACE0(&quot;&lt; DS_clearbuffer\n&quot;);
 735             return;
 736         }
 737     } else {
 738         if (FAILED(info-&gt;captureBuffer-&gt;Lock(0,
 739                                              info-&gt;dsBufferSizeInBytes,
 740                                              (LPVOID*) &amp;pb1, &amp;cb1,
 741                                              (LPVOID*) &amp;pb2, &amp;cb2, DSCBLOCK_ENTIREBUFFER))) {
 742             ERROR0(&quot;  DS_clearBuffer: ERROR: Failed to lock sound buffer.\n&quot;);
 743             TRACE0(&quot;&lt; DS_clearbuffer\n&quot;);
 744             return;
 745         }
 746     }
 747     if (pb1!=NULL) {
 748         memset(pb1, (info-&gt;bitsPerSample == 8)?128:0, cb1);
 749     }
 750     if (pb2!=NULL) {
 751         memset(pb2, (info-&gt;bitsPerSample == 8)?128:0, cb2);
 752     }
 753     if (info-&gt;isSource)  {
 754         info-&gt;playBuffer-&gt;Unlock( pb1, cb1, pb2, cb2 );
 755         if (!fromWritePos) {
 756             /* doesn&#39;t matter where to start writing next time */
 757             info-&gt;writePos = -1;
 758             info-&gt;silencedBytes = info-&gt;dsBufferSizeInBytes;
 759         } else {
 760             info-&gt;silencedBytes += (cb1+cb2);
 761             if (info-&gt;silencedBytes &gt; info-&gt;dsBufferSizeInBytes) {
 762                 ERROR1(&quot;  DS_clearbuffer: ERROR: silencedBytes=%d exceeds buffer size!\n&quot;,
 763                        info-&gt;silencedBytes);
 764                 info-&gt;silencedBytes = info-&gt;dsBufferSizeInBytes;
 765             }
 766         }
 767         DEBUG_SILENCING2(&quot;  silencedBytes=%d, my writePos=%d\n&quot;, (int)info-&gt;silencedBytes, (int)info-&gt;writePos);
 768     } else {
 769         info-&gt;captureBuffer-&gt;Unlock( pb1, cb1, pb2, cb2 );
 770     }
 771     TRACE0(&quot;&lt; DS_clearbuffer\n&quot;);
 772 }
 773 
 774 /* returns pointer to buffer */
 775 void* DS_createSoundBuffer(DS_Info* info,
 776                           float sampleRate,
 777                           int sampleSizeInBits,
 778                           int channels,
 779                           int bufferSizeInBytes) {
 780     DSBUFFERDESC dsbdesc;
 781     DSCBUFFERDESC dscbdesc;
 782     HRESULT res;
 783     WAVEFORMATEXTENSIBLE format;
 784     void* buffer;
 785 
 786     TRACE1(&quot;Creating secondary buffer for device %d\n&quot;, info-&gt;deviceID);
 787     createWaveFormat(&amp;format,
 788                      (int) sampleRate,
 789                      channels,
 790                      info-&gt;frameSize / channels * 8,
 791                      sampleSizeInBits);
 792 
 793     /* 2 second secondary buffer */
 794     info-&gt;dsBufferSizeInBytes = 2 * ((int) sampleRate) * info-&gt;frameSize;
 795 
 796     if (bufferSizeInBytes &gt; info-&gt;dsBufferSizeInBytes / 2) {
 797         bufferSizeInBytes = info-&gt;dsBufferSizeInBytes / 2;
 798     }
 799     bufferSizeInBytes = (bufferSizeInBytes / info-&gt;frameSize) * info-&gt;frameSize;
 800     info-&gt;bufferSizeInBytes = bufferSizeInBytes;
 801 
 802     if (info-&gt;isSource) {
 803         memset(&amp;dsbdesc, 0, sizeof(DSBUFFERDESC));
 804         dsbdesc.dwSize = sizeof(DSBUFFERDESC);
 805         dsbdesc.dwFlags = DSBCAPS_GETCURRENTPOSITION2
 806                     | DSBCAPS_GLOBALFOCUS;
 807 
 808         dsbdesc.dwBufferBytes = info-&gt;dsBufferSizeInBytes;
 809         dsbdesc.lpwfxFormat = (WAVEFORMATEX*) &amp;format;
 810         res = DEV_PLAY(info-&gt;deviceID)-&gt;CreateSoundBuffer
 811             (&amp;dsbdesc, (LPDIRECTSOUNDBUFFER*) &amp;buffer, NULL);
 812     } else {
 813         memset(&amp;dscbdesc, 0, sizeof(DSCBUFFERDESC));
 814         dscbdesc.dwSize = sizeof(DSCBUFFERDESC);
 815         dscbdesc.dwFlags = 0;
 816         dscbdesc.dwBufferBytes = info-&gt;dsBufferSizeInBytes;
 817         dscbdesc.lpwfxFormat = (WAVEFORMATEX*) &amp;format;
 818         res = DEV_CAPTURE(info-&gt;deviceID)-&gt;CreateCaptureBuffer
 819             (&amp;dscbdesc, (LPDIRECTSOUNDCAPTUREBUFFER*) &amp;buffer, NULL);
 820     }
 821     if (FAILED(res)) {
 822         ERROR1(&quot;DS_createSoundBuffer: ERROR: Failed to create sound buffer: %s&quot;, TranslateDSError(res));
 823         return NULL;
 824     }
 825     return buffer;
 826 }
 827 
 828 void DS_destroySoundBuffer(DS_Info* info) {
 829     if (info-&gt;playBuffer != NULL) {
 830         info-&gt;playBuffer-&gt;Release();
 831         info-&gt;playBuffer = NULL;
 832     }
 833     if (info-&gt;captureBuffer != NULL) {
 834         info-&gt;captureBuffer-&gt;Release();
 835         info-&gt;captureBuffer = NULL;
 836     }
 837 }
 838 
 839 
 840 void* DAUDIO_Open(INT32 mixerIndex, INT32 deviceID, int isSource,
 841                   int encoding, float sampleRate, int sampleSizeInBits,
 842                   int frameSize, int channels,
 843                   int isSigned, int isBigEndian, int bufferSizeInBytes) {
 844 
 845     DS_Info* info;
 846     void* buffer;
 847 
 848     TRACE0(&quot;&gt; DAUDIO_Open\n&quot;);
 849 
 850     /* some sanity checks */
 851     if (deviceID &gt;= g_cacheCount) {
 852         ERROR1(&quot;DAUDIO_Open: ERROR: cannot open the device with deviceID=%d!\n&quot;, deviceID);
 853         return NULL;
 854     }
 855     if ((g_audioDeviceCache[deviceID].isSource &amp;&amp; !isSource)
 856         || (!g_audioDeviceCache[deviceID].isSource &amp;&amp; isSource)) {
 857         /* only support Playback or Capture */
 858         ERROR0(&quot;DAUDIO_Open: ERROR: Cache is corrupt: cannot open the device in specified isSource mode!\n&quot;);
 859         return NULL;
 860     }
 861     if (encoding != DAUDIO_PCM) {
 862         ERROR1(&quot;DAUDIO_Open: ERROR: cannot open the device with encoding=%d!\n&quot;, encoding);
 863         return NULL;
 864     }
 865     if (channels &lt;= 0) {
 866         ERROR1(&quot;DAUDIO_Open: ERROR: Invalid number of channels=%d!\n&quot;, channels);
 867         return NULL;
 868     }
 869     if (sampleSizeInBits &gt; 8 &amp;&amp;
 870 #ifdef _LITTLE_ENDIAN
 871         isBigEndian
 872 #else
 873         !isBigEndian
 874 #endif
 875         ) {
 876         ERROR1(&quot;DAUDIO_Open: ERROR: wrong endianness: isBigEndian==%d!\n&quot;, isBigEndian);
 877         return NULL;
 878     }
 879     if (sampleSizeInBits == 8 &amp;&amp; isSigned) {
 880         ERROR0(&quot;DAUDIO_Open: ERROR: wrong signed&#39;ness: with 8 bits, data must be unsigned!\n&quot;);
 881         return NULL;
 882     }
 883     if (!DS_StartBufferHelper::isInitialized()) {
 884         ERROR0(&quot;DAUDIO_Open: ERROR: StartBufferHelper initialization was failed!\n&quot;);
 885         return NULL;
 886     }
 887 
 888     info = (DS_Info*) malloc(sizeof(DS_Info));
 889     if (!info) {
 890         ERROR0(&quot;DAUDIO_Open: ERROR: Out of memory\n&quot;);
 891         return NULL;
 892     }
 893     memset(info, 0, sizeof(DS_Info));
 894 
 895     info-&gt;deviceID = deviceID;
 896     info-&gt;isSource = isSource;
 897     info-&gt;bitsPerSample = sampleSizeInBits;
 898     info-&gt;frameSize = frameSize;
 899     info-&gt;framePos = 0;
 900     info-&gt;started = FALSE;
 901     info-&gt;underrun = FALSE;
 902 
 903     if (!DS_addDeviceRef(deviceID)) {
 904         DS_removeDeviceRef(deviceID);
 905         free(info);
 906         return NULL;
 907     }
 908 
 909     buffer = DS_createSoundBuffer(info,
 910                                   sampleRate,
 911                                   sampleSizeInBits,
 912                                   channels,
 913                                   bufferSizeInBytes);
 914     if (!buffer) {
 915         DS_removeDeviceRef(deviceID);
 916         free(info);
 917         return NULL;
 918     }
 919 
 920     if (info-&gt;isSource) {
 921         info-&gt;playBuffer = (LPDIRECTSOUNDBUFFER) buffer;
 922     } else {
 923         info-&gt;captureBuffer = (LPDIRECTSOUNDCAPTUREBUFFER) buffer;
 924     }
 925     DS_clearBuffer(info, FALSE /* entire buffer */);
 926 
 927     /* use writepos of device */
 928     if (info-&gt;isSource) {
 929         info-&gt;writePos = -1;
 930     } else {
 931         info-&gt;writePos = 0;
 932     }
 933 
 934     TRACE0(&quot;&lt; DAUDIO_Open: Opened device successfully.\n&quot;);
 935     return (void*) info;
 936 }
 937 
 938 int DAUDIO_Start(void* id, int isSource) {
 939     DS_Info* info = (DS_Info*) id;
 940     HRESULT res = DS_OK;
 941     DWORD status;
 942 
 943     TRACE0(&quot;&gt; DAUDIO_Start\n&quot;);
 944 
 945     if (info-&gt;isSource)  {
 946         res = info-&gt;playBuffer-&gt;GetStatus(&amp;status);
 947         if (res == DS_OK) {
 948             if (status &amp; DSBSTATUS_LOOPING) {
 949                 ERROR0(&quot;DAUDIO_Start: ERROR: Already started!&quot;);
 950                 return TRUE;
 951             }
 952 
 953             /* only start buffer if already something written to it */
 954             if (info-&gt;writePos &gt;= 0) {
 955                 res = DS_StartBufferHelper::StartBuffer(info);
 956                 if (res == DSERR_BUFFERLOST) {
 957                     res = info-&gt;playBuffer-&gt;Restore();
 958                     if (res == DS_OK) {
 959                         DS_clearBuffer(info, FALSE /* entire buffer */);
 960                         /* write() will trigger actual device start */
 961                     }
 962                 } else {
 963                     /* make sure that we will have silence after
 964                        the currently valid audio data */
 965                     DS_clearBuffer(info, TRUE /* from write position */);
 966                 }
 967             }
 968         }
 969     } else {
 970         if (info-&gt;captureBuffer-&gt;GetStatus(&amp;status) == DS_OK) {
 971             if (status &amp; DSCBSTATUS_LOOPING) {
 972                 ERROR0(&quot;DAUDIO_Start: ERROR: Already started!&quot;);
 973                 return TRUE;
 974             }
 975         }
 976         res = DS_StartBufferHelper::StartBuffer(info);
 977     }
 978     if (FAILED(res)) {
 979         ERROR1(&quot;DAUDIO_Start: ERROR: Failed to start: %s&quot;, TranslateDSError(res));
 980         return FALSE;
 981     }
 982     info-&gt;started = TRUE;
 983     return TRUE;
 984 }
 985 
 986 int DAUDIO_Stop(void* id, int isSource) {
 987     DS_Info* info = (DS_Info*) id;
 988 
 989     TRACE0(&quot;&gt; DAUDIO_Stop\n&quot;);
 990 
 991     info-&gt;started = FALSE;
 992     if (info-&gt;isSource)  {
 993         info-&gt;playBuffer-&gt;Stop();
 994     } else {
 995         info-&gt;captureBuffer-&gt;Stop();
 996     }
 997 
 998     TRACE0(&quot;&lt; DAUDIO_Stop\n&quot;);
 999     return TRUE;
1000 }
1001 
1002 
1003 void DAUDIO_Close(void* id, int isSource) {
1004     DS_Info* info = (DS_Info*) id;
1005 
1006     TRACE0(&quot;DAUDIO_Close\n&quot;);
1007 
1008     if (info != NULL) {
1009         DS_destroySoundBuffer(info);
1010         DS_removeDeviceRef(info-&gt;deviceID);
1011         free(info);
1012     }
1013 }
1014 
1015 /* Check buffer for underrun
1016  * This method is only meaningful for Output devices (write devices).
1017  */
1018 void DS_CheckUnderrun(DS_Info* info, DWORD playCursor, DWORD writeCursor) {
1019     TRACE5(&quot;DS_CheckUnderrun: playCursor=%d, writeCursor=%d, &quot;
1020            &quot;info-&gt;writePos=%d  silencedBytes=%d  dsBufferSizeInBytes=%d\n&quot;,
1021            (int) playCursor, (int) writeCursor, (int) info-&gt;writePos,
1022            (int) info-&gt;silencedBytes, (int) info-&gt;dsBufferSizeInBytes);
1023     if (info-&gt;underrun || info-&gt;writePos &lt; 0) return;
1024     int writeAhead = DS_getDistance(info, writeCursor, info-&gt;writePos);
1025     if (writeAhead &gt; info-&gt;bufferSizeInBytes) {
1026         // this may occur after Stop(), when writeCursor decreases (real valid data size &gt; bufferSizeInBytes)
1027         // But the case can occur only when we have more then info-&gt;bufferSizeInBytes valid bytes
1028         // (and less then (info-&gt;dsBufferSizeInBytes - info-&gt;bufferSizeInBytes) silenced bytes)
1029         // If we already have a lot of silencedBytes after valid data (written by
1030         // DAUDIO_StillDraining() or DAUDIO_Service()) then it&#39;s underrun
1031         if (info-&gt;silencedBytes &gt;= info-&gt;dsBufferSizeInBytes - info-&gt;bufferSizeInBytes) {
1032             // underrun!
1033             ERROR0(&quot;DS_CheckUnderrun: ERROR: underrun detected!\n&quot;);
1034             info-&gt;underrun = TRUE;
1035         }
1036     }
1037 }
1038 
1039 /* For source (playback) line:
1040  *   (a) if (fromPlayCursor == FALSE), returns number of bytes available
1041  *     for writing: bufferSize - (info-&gt;writePos - writeCursor);
1042  *   (b) if (fromPlayCursor == TRUE), playCursor is used instead writeCursor
1043  *     and returned value can be used for play position calculation (see also
1044  *     note about bufferSize)
1045  * For destination (capture) line:
1046  *   (c) if (fromPlayCursor == FALSE), returns number of bytes available
1047  *     for reading from the buffer: readCursor - info-&gt;writePos;
1048  *   (d) if (fromPlayCursor == TRUE), captureCursor is used instead readCursor
1049  *     and returned value can be used for capture position calculation (see
1050  *     note about bufferSize)
1051  * bufferSize parameter are filled by &quot;actual&quot; buffer size:
1052  *   if (fromPlayCursor == FALSE), bufferSize = info-&gt;bufferSizeInBytes
1053  *   otherwise it increase by number of bytes currently processed by DirectSound
1054  *     (writeCursor - playCursor) or (captureCursor - readCursor)
1055  */
1056 int DS_GetAvailable(DS_Info* info,
1057                     DWORD* playCursor, DWORD* writeCursor,
1058                     int* bufferSize, BOOL fromPlayCursor) {
1059     int available;
1060     int newReadPos;
1061 
1062     TRACE2(&quot;DS_GetAvailable: fromPlayCursor=%d,  deviceID=%d\n&quot;, fromPlayCursor, info-&gt;deviceID);
1063     if (!info-&gt;playBuffer &amp;&amp; !info-&gt;captureBuffer) {
1064         ERROR0(&quot;DS_GetAvailable: ERROR: buffer not yet created&quot;);
1065         return 0;
1066     }
1067 
1068     if (info-&gt;isSource)  {
1069         if (FAILED(info-&gt;playBuffer-&gt;GetCurrentPosition(playCursor, writeCursor))) {
1070             ERROR0(&quot;DS_GetAvailable: ERROR: Failed to get current position.\n&quot;);
1071             return 0;
1072         }
1073         int processing = DS_getDistance(info, (int)*playCursor, (int)*writeCursor);
1074         // workaround: sometimes DirectSound report writeCursor is less (for several bytes) then playCursor
1075         if (processing &gt; info-&gt;dsBufferSizeInBytes / 2) {
1076             *writeCursor = *playCursor;
1077             processing = 0;
1078         }
1079         TRACE3(&quot;   playCursor=%d, writeCursor=%d, info-&gt;writePos=%d\n&quot;,
1080                *playCursor, *writeCursor, info-&gt;writePos);
1081         *bufferSize = info-&gt;bufferSizeInBytes;
1082         if (fromPlayCursor) {
1083             *bufferSize += processing;
1084         }
1085         DS_CheckUnderrun(info, *playCursor, *writeCursor);
1086         if (info-&gt;writePos == -1 || (info-&gt;underrun &amp;&amp; !fromPlayCursor)) {
1087                 /* always full buffer if at beginning */
1088                 available = *bufferSize;
1089         } else {
1090             int currWriteAhead = DS_getDistance(info, fromPlayCursor ? (int)*playCursor : (int)*writeCursor, info-&gt;writePos);
1091             if (currWriteAhead &gt; *bufferSize) {
1092                 if (info-&gt;underrun) {
1093                     // playCursor surpassed writePos - no valid data, whole buffer available
1094                     available = *bufferSize;
1095                 } else {
1096                     // the case may occur after stop(), when writeCursor jumps back to playCursor
1097                     // so &quot;actual&quot; buffer size has grown
1098                     *bufferSize = currWriteAhead;
1099                     available = 0;
1100                 }
1101             } else {
1102                 available = *bufferSize - currWriteAhead;
1103             }
1104         }
1105     } else {
1106         if (FAILED(info-&gt;captureBuffer-&gt;GetCurrentPosition(playCursor, writeCursor))) {
1107             ERROR0(&quot;DS_GetAvailable: ERROR: Failed to get current position.\n&quot;);
1108             return 0;
1109         }
1110         *bufferSize = info-&gt;bufferSizeInBytes;
1111         if (fromPlayCursor) {
1112             *bufferSize += DS_getDistance(info, (int)*playCursor, (int)*writeCursor);
1113         }
1114         TRACE4(&quot;   captureCursor=%d, readCursor=%d, info-&gt;readPos=%d  refBufferSize=%d\n&quot;,
1115                *playCursor, *writeCursor, info-&gt;writePos, *bufferSize);
1116         if (info-&gt;writePos == -1) {
1117             /* always empty buffer if at beginning */
1118             info-&gt;writePos = (int) (*writeCursor);
1119         }
1120         if (fromPlayCursor) {
1121             available = ((int) (*playCursor) - info-&gt;writePos);
1122         } else {
1123             available = ((int) (*writeCursor) - info-&gt;writePos);
1124         }
1125         if (available &lt; 0) {
1126             available += info-&gt;dsBufferSizeInBytes;
1127         }
1128         if (!fromPlayCursor &amp;&amp; available &gt; info-&gt;bufferSizeInBytes) {
1129             /* overflow */
1130             ERROR2(&quot;DS_GetAvailable: ERROR: overflow detected: &quot;
1131                    &quot;DirectSoundBufferSize=%d, bufferSize=%d, &quot;,
1132                    info-&gt;dsBufferSizeInBytes, info-&gt;bufferSizeInBytes);
1133             ERROR3(&quot;captureCursor=%d, readCursor=%d, info-&gt;readPos=%d\n&quot;,
1134                    *playCursor, *writeCursor, info-&gt;writePos);
1135             /* advance read position, to allow exactly one buffer worth of data */
1136             newReadPos = (int) (*writeCursor) - info-&gt;bufferSizeInBytes;
1137             if (newReadPos &lt; 0) {
1138                 newReadPos += info-&gt;dsBufferSizeInBytes;
1139             }
1140             info-&gt;writePos = newReadPos;
1141             available = info-&gt;bufferSizeInBytes;
1142         }
1143     }
1144     available = (available / info-&gt;frameSize) * info-&gt;frameSize;
1145 
1146     TRACE1(&quot;DS_available: Returning %d available bytes\n&quot;, (int) available);
1147     return available;
1148 }
1149 
1150 // returns -1 on error, otherwise bytes written
1151 int DAUDIO_Write(void* id, char* data, int byteSize) {
1152     DS_Info* info = (DS_Info*) id;
1153     int available;
1154     int thisWritePos;
1155     DWORD playCursor, writeCursor;
1156     HRESULT res;
1157     void* buffer1, *buffer2;
1158     DWORD buffer1len, buffer2len;
1159     BOOL needRestart = FALSE;
1160     int bufferLostTrials = 2;
1161     int bufferSize;
1162 
1163     TRACE1(&quot;&gt; DAUDIO_Write %d bytes\n&quot;, byteSize);
1164 
1165     while (--bufferLostTrials &gt; 0) {
1166         available = DS_GetAvailable(info, &amp;playCursor, &amp;writeCursor, &amp;bufferSize, FALSE /* fromPlayCursor */);
1167         if (byteSize &gt; available) byteSize = available;
1168         if (byteSize == 0) break;
1169         thisWritePos = info-&gt;writePos;
1170         if (thisWritePos == -1 || info-&gt;underrun) {
1171             // play from current write cursor after flush, etc.
1172             needRestart = TRUE;
1173             thisWritePos = writeCursor;
1174             info-&gt;underrun = FALSE;
1175         }
1176         DEBUG_SILENCING2(&quot;DAUDIO_Write: writing from %d, count=%d\n&quot;, (int) thisWritePos, (int) byteSize);
1177         res = info-&gt;playBuffer-&gt;Lock(thisWritePos, byteSize,
1178                                      (LPVOID *) &amp;buffer1, &amp;buffer1len,
1179                                      (LPVOID *) &amp;buffer2, &amp;buffer2len,
1180                                      0);
1181         if (res != DS_OK) {
1182             /* some DS failure */
1183             if (res == DSERR_BUFFERLOST) {
1184                 ERROR0(&quot;DAUDIO_write: ERROR: Restoring lost Buffer.&quot;);
1185                 if (info-&gt;playBuffer-&gt;Restore() == DS_OK) {
1186                     DS_clearBuffer(info, FALSE /* entire buffer */);
1187                     info-&gt;writePos = -1;
1188                     /* try again */
1189                     continue;
1190                 }
1191             }
1192             /* can&#39;t recover from error */
1193             byteSize = 0;
1194             break;
1195         }
1196         /* buffer could be locked successfully */
1197         /* first fill first buffer */
1198         if (buffer1) {
1199             memcpy(buffer1, data, buffer1len);
1200             data = (char*) (((UINT_PTR) data) + buffer1len);
1201         } else buffer1len = 0;
1202         if (buffer2) {
1203             memcpy(buffer2, data, buffer2len);
1204         } else buffer2len = 0;
1205         byteSize = buffer1len + buffer2len;
1206 
1207         /* update next write pos */
1208         thisWritePos += byteSize;
1209         while (thisWritePos &gt;= info-&gt;dsBufferSizeInBytes) {
1210             thisWritePos -= info-&gt;dsBufferSizeInBytes;
1211         }
1212         /* commit data to directsound */
1213         info-&gt;playBuffer-&gt;Unlock(buffer1, buffer1len, buffer2, buffer2len);
1214 
1215         info-&gt;writePos = thisWritePos;
1216 
1217         /* update position
1218          * must be AFTER updating writePos,
1219          * so that getSvailable doesn&#39;t return too little,
1220          * so that getFramePos doesn&#39;t jump
1221          */
1222         info-&gt;framePos += (byteSize / info-&gt;frameSize);
1223 
1224         /* decrease silenced bytes */
1225         if (info-&gt;silencedBytes &gt; byteSize) {
1226             info-&gt;silencedBytes -= byteSize;
1227         } else {
1228             info-&gt;silencedBytes = 0;
1229         }
1230         break;
1231     } /* while */
1232 
1233     /* start the device, if necessary */
1234     if (info-&gt;started &amp;&amp; needRestart &amp;&amp; (info-&gt;writePos &gt;= 0)) {
1235         DS_StartBufferHelper::StartBuffer(info);
1236     }
1237 
1238     TRACE1(&quot;&lt; DAUDIO_Write: returning %d bytes.\n&quot;, byteSize);
1239     return byteSize;
1240 }
1241 
1242 // returns -1 on error
1243 int DAUDIO_Read(void* id, char* data, int byteSize) {
1244     DS_Info* info = (DS_Info*) id;
1245     int available;
1246     int thisReadPos;
1247     DWORD captureCursor, readCursor;
1248     HRESULT res;
1249     void* buffer1, *buffer2;
1250     DWORD buffer1len, buffer2len;
1251     int bufferSize;
1252 
1253     TRACE1(&quot;&gt; DAUDIO_Read %d bytes\n&quot;, byteSize);
1254 
1255     available = DS_GetAvailable(info, &amp;captureCursor, &amp;readCursor, &amp;bufferSize, FALSE /* fromCaptureCursor? */);
1256     if (byteSize &gt; available) byteSize = available;
1257     if (byteSize &gt; 0) {
1258         thisReadPos = info-&gt;writePos;
1259         if (thisReadPos == -1) {
1260             /* from beginning */
1261             thisReadPos = 0;
1262         }
1263         res = info-&gt;captureBuffer-&gt;Lock(thisReadPos, byteSize,
1264                                         (LPVOID *) &amp;buffer1, &amp;buffer1len,
1265                                         (LPVOID *) &amp;buffer2, &amp;buffer2len,
1266                                         0);
1267         if (res != DS_OK) {
1268             /* can&#39;t recover from error */
1269             byteSize = 0;
1270         } else {
1271             /* buffer could be locked successfully */
1272             /* first fill first buffer */
1273             if (buffer1) {
1274                 memcpy(data, buffer1, buffer1len);
1275                 data = (char*) (((UINT_PTR) data) + buffer1len);
1276             } else buffer1len = 0;
1277             if (buffer2) {
1278                 memcpy(data, buffer2, buffer2len);
1279             } else buffer2len = 0;
1280             byteSize = buffer1len + buffer2len;
1281 
1282             /* update next read pos */
1283             thisReadPos = DS_addPos(info, thisReadPos, byteSize);
1284             /* commit data to directsound */
1285             info-&gt;captureBuffer-&gt;Unlock(buffer1, buffer1len, buffer2, buffer2len);
1286 
1287             /* update position
1288              * must be BEFORE updating readPos,
1289              * so that getAvailable doesn&#39;t return too much,
1290              * so that getFramePos doesn&#39;t jump
1291              */
1292             info-&gt;framePos += (byteSize / info-&gt;frameSize);
1293 
1294             info-&gt;writePos = thisReadPos;
1295         }
1296     }
1297 
1298     TRACE1(&quot;&lt; DAUDIO_Read: returning %d bytes.\n&quot;, byteSize);
1299     return byteSize;
1300 }
1301 
1302 
1303 int DAUDIO_GetBufferSize(void* id, int isSource) {
1304     DS_Info* info = (DS_Info*) id;
1305     return info-&gt;bufferSizeInBytes;
1306 }
1307 
1308 int DAUDIO_StillDraining(void* id, int isSource) {
1309     DS_Info* info = (DS_Info*) id;
1310     BOOL draining = FALSE;
1311     int available, bufferSize;
1312     DWORD playCursor, writeCursor;
1313 
1314     DS_clearBuffer(info, TRUE /* from write position */);
1315     available = DS_GetAvailable(info, &amp;playCursor, &amp;writeCursor, &amp;bufferSize, TRUE /* fromPlayCursor */);
1316     draining = (available &lt; bufferSize);
1317 
1318     TRACE3(&quot;DAUDIO_StillDraining: available=%d  silencedBytes=%d  Still draining: %s\n&quot;,
1319            available, info-&gt;silencedBytes, draining?&quot;TRUE&quot;:&quot;FALSE&quot;);
1320     return draining;
1321 }
1322 
1323 
1324 int DAUDIO_Flush(void* id, int isSource) {
1325     DS_Info* info = (DS_Info*) id;
1326 
1327     TRACE0(&quot;DAUDIO_Flush\n&quot;);
1328 
1329     if (info-&gt;isSource)  {
1330         info-&gt;playBuffer-&gt;Stop();
1331         DS_clearBuffer(info, FALSE /* entire buffer */);
1332     } else {
1333         DWORD captureCursor, readCursor;
1334         /* set the read pointer to the current read position */
1335         if (FAILED(info-&gt;captureBuffer-&gt;GetCurrentPosition(&amp;captureCursor, &amp;readCursor))) {
1336             ERROR0(&quot;DAUDIO_Flush: ERROR: Failed to get current position.&quot;);
1337             return FALSE;
1338         }
1339         DS_clearBuffer(info, FALSE /* entire buffer */);
1340         /* SHOULD set to *captureCursor*,
1341          * but that would be detected as overflow
1342          * in a subsequent GetAvailable() call.
1343          */
1344         info-&gt;writePos = (int) readCursor;
1345     }
1346     return TRUE;
1347 }
1348 
1349 int DAUDIO_GetAvailable(void* id, int isSource) {
1350     DS_Info* info = (DS_Info*) id;
1351     DWORD playCursor, writeCursor;
1352     int ret, bufferSize;
1353 
1354     ret = DS_GetAvailable(info, &amp;playCursor, &amp;writeCursor, &amp;bufferSize, /*fromPlayCursor?*/ FALSE);
1355 
1356     TRACE1(&quot;DAUDIO_GetAvailable returns %d bytes\n&quot;, ret);
1357     return ret;
1358 }
1359 
1360 INT64 estimatePositionFromAvail(DS_Info* info, INT64 javaBytePos, int bufferSize, int availInBytes) {
1361     // estimate the current position with the buffer size and
1362     // the available bytes to read or write in the buffer.
1363     // not an elegant solution - bytePos will stop on xruns,
1364     // and in race conditions it may jump backwards
1365     // Advantage is that it is indeed based on the samples that go through
1366     // the system (rather than time-based methods)
1367     if (info-&gt;isSource) {
1368         // javaBytePos is the position that is reached when the current
1369         // buffer is played completely
1370         return (INT64) (javaBytePos - bufferSize + availInBytes);
1371     } else {
1372         // javaBytePos is the position that was when the current buffer was empty
1373         return (INT64) (javaBytePos + availInBytes);
1374     }
1375 }
1376 
1377 INT64 DAUDIO_GetBytePosition(void* id, int isSource, INT64 javaBytePos) {
1378     DS_Info* info = (DS_Info*) id;
1379     int available, bufferSize;
1380     DWORD playCursor, writeCursor;
1381     INT64 result = javaBytePos;
1382 
1383     available = DS_GetAvailable(info, &amp;playCursor, &amp;writeCursor, &amp;bufferSize, /*fromPlayCursor?*/ TRUE);
1384     result = estimatePositionFromAvail(info, javaBytePos, bufferSize, available);
1385     return result;
1386 }
1387 
1388 
1389 void DAUDIO_SetBytePosition(void* id, int isSource, INT64 javaBytePos) {
1390     /* save to ignore, since GetBytePosition
1391      * takes the javaBytePos param into account
1392      */
1393 }
1394 
1395 int DAUDIO_RequiresServicing(void* id, int isSource) {
1396     // need servicing on for SourceDataLines
1397     return isSource?TRUE:FALSE;
1398 }
1399 
1400 void DAUDIO_Service(void* id, int isSource) {
1401     DS_Info* info = (DS_Info*) id;
1402     if (isSource) {
1403         if (info-&gt;silencedBytes &lt; info-&gt;dsBufferSizeInBytes) {
1404             // clear buffer
1405             TRACE0(&quot;DAUDIO_Service\n&quot;);
1406             DS_clearBuffer(info, TRUE /* from write position */);
1407         }
1408         if (info-&gt;writePos &gt;= 0
1409             &amp;&amp; info-&gt;started
1410             &amp;&amp; !info-&gt;underrun
1411             &amp;&amp; info-&gt;silencedBytes &gt;= info-&gt;dsBufferSizeInBytes) {
1412             // if we&#39;re currently playing, and the entire buffer is silenced...
1413             // then we are underrunning!
1414             info-&gt;underrun = TRUE;
1415             ERROR0(&quot;DAUDIO_Service: ERROR: DirectSound: underrun detected!\n&quot;);
1416         }
1417     }
1418 }
1419 
1420 
1421 #endif // USE_DAUDIO
    </pre>
  </body>
</html>
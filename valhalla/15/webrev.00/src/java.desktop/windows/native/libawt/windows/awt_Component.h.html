<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/windows/native/libawt/windows/awt_Component.h</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef AWT_COMPONENT_H
 27 #define AWT_COMPONENT_H
 28 
 29 #include &quot;awtmsg.h&quot;
 30 #include &quot;awt_Object.h&quot;
 31 #include &quot;awt_Font.h&quot;
 32 #include &quot;awt_Brush.h&quot;
 33 #include &quot;awt_Pen.h&quot;
 34 #include &quot;awt_Win32GraphicsDevice.h&quot;
 35 #include &quot;GDIWindowSurfaceData.h&quot;
 36 
 37 #include &quot;java_awt_Component.h&quot;
 38 #include &quot;sun_awt_windows_WComponentPeer.h&quot;
 39 #include &quot;java_awt_event_KeyEvent.h&quot;
 40 #include &quot;java_awt_event_MouseEvent.h&quot;
 41 #include &quot;java_awt_event_WindowEvent.h&quot;
 42 #include &quot;java_awt_Dimension.h&quot;
 43 
 44 extern LPCTSTR szAwtComponentClassName;
 45 
 46 static LPCTSTR DrawingStateProp = TEXT(&quot;SunAwtDrawingStateProp&quot;);
 47 
 48 const UINT IGNORE_KEY = (UINT)-1;
 49 const UINT MAX_ACP_STR_LEN = 7; // ANSI CP identifiers are no longer than this
 50 
 51 #define LEFT_BUTTON 1
 52 #define MIDDLE_BUTTON 2
 53 #define RIGHT_BUTTON 4
 54 #define DBL_CLICK 8
 55 #define X1_BUTTON 16
 56 #define X2_BUTTON 32
 57 
 58 #ifndef MK_XBUTTON1
 59 #define MK_XBUTTON1         0x0020
 60 #endif
 61 
 62 #ifndef MK_XBUTTON2
 63 #define MK_XBUTTON2         0x0040
 64 #endif
 65 
 66 // combination of standard mouse button flags
 67 const int ALL_MK_BUTTONS = MK_LBUTTON|MK_MBUTTON|MK_RBUTTON;
 68 const int X_BUTTONS = MK_XBUTTON1|MK_XBUTTON2;
 69 
 70 // The allowable difference between coordinates of the WM_TOUCH event and the
 71 // corresponding WM_LBUTTONDOWN/WM_LBUTTONUP event letting to associate these
 72 // events, when their coordinates are slightly different.
 73 const int TOUCH_MOUSE_COORDS_DELTA = 10;
 74 
 75 // Whether to check for embedded frame and adjust location
 76 #define CHECK_EMBEDDED 0
 77 #define DONT_CHECK_EMBEDDED 1
 78 
 79 class AwtPopupMenu;
 80 
 81 class AwtDropTarget;
 82 
 83 /*
 84  * Message routing codes
 85  */
 86 enum MsgRouting {
 87     mrPassAlong,    /* pass along to next in chain */
 88     mrDoDefault,    /* skip right to underlying default behavior */
 89     mrConsume,      /* consume msg &amp; terminate routing immediatly,
 90                      * don&#39;t pass anywhere
 91                      */
 92 };
 93 
 94 /************************************************************************
 95  * AwtComponent class
 96  */
 97 
 98 class AwtComponent : public AwtObject {
 99 public:
100     /* java.awt.Component fields and method IDs */
101     static jfieldID peerID;
102     static jfieldID xID;
103     static jfieldID yID;
104     static jfieldID widthID;
105     static jfieldID heightID;
106     static jfieldID visibleID;
107     static jfieldID backgroundID;
108     static jfieldID foregroundID;
109     static jfieldID enabledID;
110     static jfieldID parentID;
111     static jfieldID cursorID;
112     static jfieldID graphicsConfigID;
113     static jfieldID peerGCID;
114     static jfieldID focusableID;
115     static jfieldID appContextID;
116     static jfieldID hwndID;
117 
118     static jmethodID getFontMID;
119     static jmethodID getToolkitMID;
120     static jmethodID isEnabledMID;
121     static jmethodID getLocationOnScreenMID;
122     static jmethodID replaceSurfaceDataMID;
123     static jmethodID replaceSurfaceDataLaterMID;
124     static jmethodID disposeLaterMID;
125 
126     static const UINT WmAwtIsComponent;
127     static jint * masks; //InputEvent mask array
128     AwtComponent();
129     virtual ~AwtComponent();
130 
131     /*
132      * Dynamic class registration &amp; creation
133      */
134     virtual LPCTSTR GetClassName() = 0;
135     /*
136      * Fix for 4964237: Win XP: Changing theme changes java dialogs title icon
137      * WNDCLASS structure has been superseded by the WNDCLASSEX in Win32
138      */
139     virtual void FillClassInfo(WNDCLASSEX *lpwc);
140     virtual void RegisterClass();
141     virtual void UnregisterClass();
142 
143     virtual void CreateHWnd(JNIEnv *env, LPCWSTR title,
144                     DWORD windowStyle, DWORD windowExStyle,
145                     int x, int y, int w, int h,
146                     HWND hWndParent, HMENU hMenu,
147                     COLORREF colorForeground, COLORREF colorBackground,
148                     jobject peer);
149     virtual void DestroyHWnd();
150     void InitPeerGraphicsConfig(JNIEnv *env, jobject peer);
151 
152     virtual void Dispose();
153 
154     void UpdateBackground(JNIEnv *env, jobject target);
155 
156     virtual void SubclassHWND();
157     virtual void UnsubclassHWND();
158 
159     static LRESULT CALLBACK WndProc(HWND hWnd, UINT message,
160         WPARAM wParam, LPARAM lParam);
161 
162     /*
163      * Access to the various objects of this aggregate component
164      */
165     INLINE HWND GetHWnd() { return m_hwnd; }
166     INLINE void SetHWnd(HWND hwnd) { m_hwnd = hwnd; }
167 
168     static AwtComponent* GetComponent(HWND hWnd);
169 
170     /*
171      * Access to the properties of the component
172      */
173     INLINE COLORREF GetColor() { return m_colorForeground; }
174     virtual void SetColor(COLORREF c);
175     HPEN GetForegroundPen();
176 
177     COLORREF GetBackgroundColor();
178     virtual void SetBackgroundColor(COLORREF c);
179     HBRUSH GetBackgroundBrush();
180     INLINE BOOL IsBackgroundColorSet() { return m_backgroundColorSet; }
181 
182     virtual void SetFont(AwtFont *pFont);
183 
184     INLINE void SetText(LPCTSTR text) { ::SetWindowText(GetHWnd(), text); }
185     INLINE int GetText(LPTSTR buffer, int size) {
186         return ::GetWindowText(GetHWnd(), buffer, size);
187     }
188     INLINE int GetTextLength() { return ::GetWindowTextLength(GetHWnd()); }
189 
190     virtual void GetInsets(RECT* rect) {
191         VERIFY(::SetRectEmpty(rect));
192     }
193 
194     BOOL IsVisible() { return m_visible;};
195 
196     HDC GetDCFromComponent();
197 
198     /*
199      * Enable/disable component
200      */
201     virtual void Enable(BOOL bEnable);
202 
203     /*
204      * Validate and call handleExpose on rects of UpdateRgn
205      */
206     void PaintUpdateRgn(const RECT *insets);
207 
208     static HWND GetTopLevelParentForWindow(HWND hwndDescendant);
209 
210     static jobject FindHeavyweightUnderCursor(BOOL useCache);
211 
212     /*
213      * Returns the parent component.  If no parent window, or the
214      * parent window isn&#39;t an AwtComponent, returns NULL.
215      */
216     AwtComponent* GetParent();
217 
218     /* Get the component&#39;s immediate container. Note: may return NULL while
219        the component is being reparented in full-screen mode by Direct3D */
220     class AwtWindow* GetContainer();
221 
222     /* Is a component a container? Used by above method */
223     virtual BOOL IsContainer() { return FALSE;} // Plain components can&#39;t
224 
225     /**
226      * Returns TRUE if this message will trigger native focus change, FALSE otherwise.
227      */
228     virtual BOOL IsFocusingKeyMessage(MSG *pMsg);
229     virtual BOOL IsFocusingMouseMessage(MSG *pMsg);
230 
231     BOOL IsFocusable();
232 
233     /*
234      * Returns an increasing unsigned value used for child control IDs.
235      * There is no attempt to reclaim command ID&#39;s.
236      */
237     INLINE UINT CreateControlID() { return m_nextControlID++; }
238 
239     // returns the current keyboard layout
240     INLINE static HKL GetKeyboardLayout() {
241         return m_hkl;
242     }
243 
244     // returns the current code page that should be used in
245     // all MultiByteToWideChar and WideCharToMultiByte calls.
246     // This code page should also be use in IsDBCSLeadByteEx.
247     INLINE static UINT GetCodePage()
248     {
249         return m_CodePage;
250     }
251 
252 // Added by waleed for BIDI Support
253     // returns the right to left status
254     INLINE static BOOL GetRTLReadingOrder() {
255         return sm_rtlReadingOrder;
256     }
257     // returns the right to left status
258     INLINE static BOOL GetRTL() {
259         return sm_rtl;
260     }
261     // returns the current sub language
262     INLINE static LANGID GetSubLanguage() {
263         return SUBLANGID(m_idLang);
264     }
265 // end waleed
266 
267     // returns the current input language
268     INLINE static LANGID GetInputLanguage()
269     {
270         return m_idLang;
271     }
272     // Convert Language ID to CodePage
273     static UINT LangToCodePage(LANGID idLang);
274 
275     /*
276      * methods on this component
277      */
278     virtual void Show();
279     virtual void Hide();
280     virtual void Reshape(int x, int y, int w, int h);
281     void ReshapeNoScale(int x, int y, int w, int h);
282 
283     /*
284      * Fix for 4046446.
285      * Component size/position helper, for the values above the short int limit.
286      */
287     static BOOL SetWindowPos(HWND wnd, HWND after,
288                              int x, int y, int w, int h, UINT flags);
289 
290     /*
291      * Sets the scrollbar values.  &#39;bar&#39; can be either SB_VERT or
292      * SB_HORZ.  &#39;min&#39;, &#39;value&#39;, and &#39;max&#39; can have the value INT_MAX
293      * which means that the value should not be changed.
294      */
295     void SetScrollValues(UINT bar, int min, int value, int max);
296 
297     INLINE LRESULT SendMessage(UINT msg, WPARAM wParam=0, LPARAM lParam=0) {
298         DASSERT(GetHWnd());
299         return ::SendMessage(GetHWnd(), msg, wParam, lParam);
300     }
301 
302     void PostUngrabEvent();
303 
304     INLINE virtual LONG GetStyle() {
305         DASSERT(GetHWnd());
306         return ::GetWindowLong(GetHWnd(), GWL_STYLE);
307     }
308     INLINE virtual void SetStyle(LONG style) {
309         DASSERT(GetHWnd());
310         // SetWindowLong() error handling as recommended by Win32 API doc.
311         ::SetLastError(0);
312         DWORD ret = ::SetWindowLong(GetHWnd(), GWL_STYLE, style);
313         DASSERT(ret != 0 || ::GetLastError() == 0);
314     }
315     INLINE virtual LONG GetStyleEx() {
316         DASSERT(GetHWnd());
317         return ::GetWindowLong(GetHWnd(), GWL_EXSTYLE);
318     }
319     INLINE virtual void SetStyleEx(LONG style) {
320         DASSERT(GetHWnd());
321         // SetWindowLong() error handling as recommended by Win32 API doc.
322         ::SetLastError(0);
323         DWORD ret = ::SetWindowLong(GetHWnd(), GWL_EXSTYLE, style);
324         DASSERT(ret != 0 || ::GetLastError() == 0);
325     }
326 
327     virtual BOOL NeedDblClick() { return FALSE; }
328 
329     /* for multifont component */
330     static void DrawWindowText(HDC hDC, jobject font, jstring text,
331                                int x, int y);
332     static void DrawGrayText(HDC hDC, jobject font, jstring text,
333                              int x, int y);
334 
335     void DrawListItem(JNIEnv *env, DRAWITEMSTRUCT &amp;drawInfo);
336 
337     void MeasureListItem(JNIEnv *env, MEASUREITEMSTRUCT &amp;measureInfo);
338 
339     jstring GetItemString(JNIEnv *env, jobject target, jint index);
340 
341     jint GetFontHeight(JNIEnv *env);
342 
343     virtual jobject PreferredItemSize(JNIEnv *env) {DASSERT(FALSE); return NULL; }
344 
345     INLINE BOOL isEnabled() {
346         JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
347         if (env-&gt;EnsureLocalCapacity(2) &lt; 0) {
348             return NULL;
349         }
350         jobject self = GetPeer(env);
351         jobject target = env-&gt;GetObjectField(self, AwtObject::targetID);
352         BOOL e = env-&gt;CallBooleanMethod(target, AwtComponent::isEnabledMID);
353         DASSERT(!safe_ExceptionOccurred(env));
354 
355         env-&gt;DeleteLocalRef(target);
356 
357         return e;
358     }
359 
360     INLINE BOOL isRecursivelyEnabled() {
361         AwtComponent* p = this;
362         do {
363             if (!p-&gt;isEnabled()) {
364                 return FALSE;
365             }
366         } while (!p-&gt;IsTopLevel() &amp;&amp;
367             (p = p-&gt;GetParent()) != NULL);
368         return TRUE;
369     }
370 
371     void SendKeyEventToFocusOwner(jint id, jlong when, jint raw, jint cooked,
372                                   jint modifiers, jint keyLocation, jlong nativeCode,
373                                   MSG *msg = NULL);
374     /*
375      * Allocate and initialize a new java.awt.event.KeyEvent, and
376      * post it to the peer&#39;s target object.  No response is expected
377      * from the target.
378      */
379     void SendKeyEvent(jint id, jlong when, jint raw, jint cooked,
380                       jint modifiers, jint keyLocation, jlong nativeCode,
381                       MSG *msg = NULL);
382 
383     /*
384      * Allocate and initialize a new java.awt.event.MouseEvent, and
385      * post it to the peer&#39;s target object.  No response is expected
386      * from the target.
387      */
388     void SendMouseEvent(jint id, jlong when, jint x, jint y,
389                         jint modifiers, jint clickCount,
390                         jboolean popupTrigger, jint button = 0,
391                         MSG *msg = NULL, BOOL causedByTouchEvent = FALSE);
392 
393     /*
394      * Allocate and initialize a new java.awt.event.MouseWheelEvent, and
395      * post it to the peer&#39;s target object.  No response is expected
396      * from the target.
397      */
398     void SendMouseWheelEvent(jint id, jlong when, jint x, jint y,
399                              jint modifiers, jint clickCount,
400                              jboolean popupTrigger, jint scrollType,
401                              jint scrollAmount, jint wheelRotation,
402                              jdouble preciseWheelRotation, MSG *msg = NULL);
403 
404     /*
405      * Allocate and initialize a new java.awt.event.FocusEvent, and
406      * post it to the peer&#39;s target object.  No response is expected
407      * from the target.
408      */
409     void SendFocusEvent(jint id, HWND opposite);
410 
411     /* Forward a filtered event directly to the subclassed window.
412        synthetic should be TRUE iff the message was generated because
413        of a synthetic Java event, rather than a native event. */
414     virtual MsgRouting HandleEvent(MSG *msg, BOOL synthetic);
415 
416     /* Post a WM_AWT_HANDLE_EVENT message which invokes HandleEvent
417        on the toolkit thread. This method may pre-filter the messages. */
418     virtual BOOL PostHandleEventMessage(MSG *msg, BOOL synthetic);
419 
420     /* Event-&gt;message synthesizer methods. */
421     void SynthesizeKeyMessage(JNIEnv *env, jobject keyEvent);
422     void SynthesizeMouseMessage(JNIEnv *env, jobject mouseEvent);
423 
424     /* Components which inherit native mouse wheel behavior will
425      * return TRUE.  These are TextArea, Choice, FileDialog, and
426      * List.  All other Components return FALSE.
427      */
428     virtual BOOL InheritsNativeMouseWheelBehavior();
429 
430     /* Determines whether the component is obscured by another window */
431     // Called on Toolkit thread
432     static jboolean _IsObscured(void *param);
433 
434     /* Invalidate the specified rectangle. */
435     virtual void Invalidate(RECT* r);
436 
437     /* Begin and end deferred window positioning. */
438     virtual void BeginValidate();
439     virtual void EndValidate();
440 
441     /* Keyboard conversion routines. */
442     static void InitDynamicKeyMapTable();
443     static void BuildDynamicKeyMapTable();
444     static jint GetJavaModifiers();
445     static jint GetActionModifiers();
446     static jint GetButton(int mouseButton);
447     static UINT GetButtonMK(int mouseButton);
448     static UINT WindowsKeyToJavaKey(UINT windowsKey, UINT modifiers, UINT character, BOOL isDeadKey);
449     static void JavaKeyToWindowsKey(UINT javaKey, UINT *windowsKey, UINT *modifiers, UINT originalWindowsKey);
450     static void UpdateDynPrimaryKeymap(UINT wkey, UINT jkeyLegacy, jint keyLocation, UINT modifiers);
451 
452     INLINE static void JavaKeyToWindowsKey(UINT javaKey,
453                                        UINT *windowsKey, UINT *modifiers)
454     {
455         JavaKeyToWindowsKey(javaKey, windowsKey, modifiers, IGNORE_KEY);
456     }
457 
458     enum TransOps {NONE, LOAD, SAVE};
459 
460     UINT WindowsKeyToJavaChar(UINT wkey, UINT modifiers, TransOps ops, BOOL &amp;isDeadKey);
461 
462     /* routines used for input method support */
463     void SetInputMethod(jobject im, BOOL useNativeCompWindow);
464     void SendInputMethodEvent(jint id, jstring text, int cClause,
465                               int *rgClauseBoundary, jstring *rgClauseReading,
466                               int cAttrBlock, int *rgAttrBoundary,
467                               BYTE *rgAttrValue, int commitedTextLength,
468                               int caretPos, int visiblePos);
469     void InquireCandidatePosition();
470     INLINE LPARAM GetCandidateType() { return m_bitsCandType; }
471     HWND ImmGetHWnd();
472     HIMC ImmAssociateContext(HIMC himc);
473     HWND GetProxyFocusOwner();
474 
475     INLINE HWND GetProxyToplevelContainer() {
476         HWND proxyHWnd = GetProxyFocusOwner();
477         return ::GetAncestor(proxyHWnd, GA_ROOT); // a browser in case of EmbeddedFrame
478     }
479 
480     void CallProxyDefWindowProc(UINT message,
481                                 WPARAM wParam,
482                                 LPARAM lParam,
483                                 LRESULT &amp;retVal,
484                                 MsgRouting &amp;mr);
485 
486     /*
487      * Windows message handler functions
488      */
489     virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
490     virtual LRESULT DefWindowProc(UINT msg, WPARAM wParam, LPARAM lParam);
491 
492     /* return true if msg is processed */
493     virtual MsgRouting PreProcessMsg(MSG&amp; msg);
494 
495     virtual MsgRouting WmCreate() {return mrDoDefault;}
496     virtual MsgRouting WmClose() {return mrDoDefault;}
497     virtual MsgRouting WmDestroy();
498     virtual MsgRouting WmNcDestroy();
499 
500     virtual MsgRouting WmActivate(UINT nState, BOOL fMinimized, HWND opposite)
501     {
502         return mrDoDefault;
503     }
504 
505     virtual MsgRouting WmEraseBkgnd(HDC hDC, BOOL&amp; didErase)
506     {
507         return mrDoDefault;
508     }
509 
510     virtual MsgRouting WmPaint(HDC hDC);
511     virtual MsgRouting WmGetMinMaxInfo(LPMINMAXINFO lpmmi);
512     virtual MsgRouting WmMove(int x, int y);
513     virtual MsgRouting WmSize(UINT type, int w, int h);
514     virtual MsgRouting WmSizing();
515     virtual MsgRouting WmShowWindow(BOOL show, UINT status);
516     virtual MsgRouting WmSetFocus(HWND hWndLost);
517     virtual MsgRouting WmKillFocus(HWND hWndGot);
518     virtual MsgRouting WmCtlColor(HDC hDC, HWND hCtrl,
519                                   UINT ctlColor, HBRUSH&amp; retBrush);
520     virtual MsgRouting WmHScroll(UINT scrollCode, UINT pos, HWND hScrollBar);
521     virtual MsgRouting WmVScroll(UINT scrollCode, UINT pos, HWND hScrollBar);
522 
523     virtual MsgRouting WmMouseEnter(UINT flags, int x, int y);
524     virtual MsgRouting WmMouseDown(UINT flags, int x, int y, int button);
525     virtual MsgRouting WmMouseUp(UINT flags, int x, int y, int button);
526     virtual MsgRouting WmMouseMove(UINT flags, int x, int y);
527     virtual MsgRouting WmMouseExit(UINT flags, int x, int y);
528     virtual MsgRouting WmMouseWheel(UINT flags, int x, int y,
529                                     int wheelRotation, BOOL isHorizontal);
530     virtual MsgRouting WmNcMouseDown(WPARAM hitTest, int x, int y, int button);
531     virtual MsgRouting WmNcMouseUp(WPARAM hitTest, int x, int y, int button);
532     virtual MsgRouting WmWindowPosChanging(LPARAM windowPos);
533     virtual MsgRouting WmWindowPosChanged(LPARAM windowPos);
534     virtual void WmTouch(WPARAM wParam, LPARAM lParam);
535 
536     // NB: 64-bit: vkey is wParam of the message, but other API&#39;s take
537     // vkey parameters of type UINT, so we do the cast before dispatching.
538     virtual MsgRouting WmKeyDown(UINT vkey, UINT repCnt, UINT flags, BOOL system);
539     virtual MsgRouting WmKeyUp(UINT vkey, UINT repCnt, UINT flags, BOOL system);
540 
541     virtual MsgRouting WmChar(UINT character, UINT repCnt, UINT flags, BOOL system);
542     virtual MsgRouting WmIMEChar(UINT character, UINT repCnt, UINT flags, BOOL system);
543     virtual MsgRouting WmInputLangChange(UINT charset, HKL hKeyBoardLayout);
544     virtual MsgRouting WmForwardChar(WCHAR character, LPARAM lParam,
545                                      BOOL synthethic);
546     virtual MsgRouting WmPaste();
547 
548     virtual void SetCompositionWindow(RECT &amp;r);
549     virtual void OpenCandidateWindow(int x, int y);
550     virtual void SetCandidateWindow(int iCandType, int x, int y);
551     virtual MsgRouting WmImeSetContext(BOOL fSet, LPARAM *lplParam);
552     virtual MsgRouting WmImeNotify(WPARAM subMsg, LPARAM bitsCandType);
553     virtual MsgRouting WmImeStartComposition();
554     virtual MsgRouting WmImeEndComposition();
555     virtual MsgRouting WmImeComposition(WORD wChar, LPARAM flags);
556 
557     virtual MsgRouting WmTimer(UINT_PTR timerID) {return mrDoDefault;}
558 
559     virtual MsgRouting WmCommand(UINT id, HWND hWndCtrl, UINT notifyCode);
560 
561     /* reflected WmCommand from parent */
562     virtual MsgRouting WmNotify(UINT notifyCode);
563 
564     virtual MsgRouting WmCompareItem(UINT /*ctrlId*/,
565                                      COMPAREITEMSTRUCT &amp;compareInfo,
566                                      LRESULT &amp;result);
567     virtual MsgRouting WmDeleteItem(UINT /*ctrlId*/,
568                                     DELETEITEMSTRUCT &amp;deleteInfo);
569     virtual MsgRouting WmDrawItem(UINT ctrlId,
570                                   DRAWITEMSTRUCT &amp;drawInfo);
571     virtual MsgRouting WmMeasureItem(UINT ctrlId,
572                                      MEASUREITEMSTRUCT &amp;measureInfo);
573     /* Fix 4181790 &amp; 4223341 : These functions get overridden in owner-drawn
574      * components instead of the Wm... versions.
575      */
576     virtual MsgRouting OwnerDrawItem(UINT ctrlId,
577                                      DRAWITEMSTRUCT &amp;drawInfo);
578     virtual MsgRouting OwnerMeasureItem(UINT ctrlId,
579                                         MEASUREITEMSTRUCT &amp;measureInfo);
580 
581     virtual MsgRouting WmPrint(HDC hDC, LPARAM flags);
582     virtual MsgRouting WmPrintClient(HDC hDC, LPARAM flags);
583 
584     virtual MsgRouting WmNcCalcSize(BOOL fCalcValidRects,
585                                     LPNCCALCSIZE_PARAMS lpncsp,
586                                     LRESULT &amp;retVal);
587     virtual MsgRouting WmNcPaint(HRGN hrgn);
588     virtual MsgRouting WmNcHitTest(UINT x, UINT y, LRESULT &amp;retVal);
589     virtual MsgRouting WmSysCommand(UINT uCmdType, int xPos, int yPos);
590     virtual MsgRouting WmEnterSizeMove();
591     virtual MsgRouting WmExitSizeMove();
592     virtual MsgRouting WmEnterMenuLoop(BOOL isTrackPopupMenu);
593     virtual MsgRouting WmExitMenuLoop(BOOL isTrackPopupMenu);
594 
595     virtual MsgRouting WmQueryNewPalette(LRESULT &amp;retVal);
596     virtual MsgRouting WmPaletteChanged(HWND hwndPalChg);
597     virtual MsgRouting WmPaletteIsChanging(HWND hwndPalChg);
598     virtual MsgRouting WmStyleChanged(int wStyleType, LPSTYLESTRUCT lpss);
599     virtual MsgRouting WmSettingChange(UINT wFlag, LPCTSTR pszSection);
600 
601     virtual MsgRouting WmContextMenu(HWND hCtrl, UINT xPos, UINT yPos) {
602         return mrDoDefault;
603     }
604 
605     void UpdateColorModel();
606 
607     jintArray CreatePrintedPixels(SIZE &amp;loc, SIZE &amp;size, int alpha);
608 
609     /*
610      * HWND, AwtComponent and Java Peer interaction
611      *
612      * Link the C++, Java peer, and HWNDs together.
613      */
614     void LinkObjects(JNIEnv *env, jobject peer);
615 
616     void UnlinkObjects();
617 
618     static BOOL QueryNewPaletteCalled() { return m_QueryNewPaletteCalled; }
619 
620 #ifdef DEBUG
621     virtual void VerifyState(); /* verify component and peer are in sync. */
622 #else
623     void VerifyState() {}       /* no-op */
624 #endif
625 
626     virtual AwtDropTarget* CreateDropTarget(JNIEnv* env);
627     virtual void DestroyDropTarget();
628 
629     INLINE virtual HWND GetDBCSEditHandle() { return NULL; }
630     // State for native drawing API
631     INLINE jint GetDrawState() { return GetDrawState(m_hwnd); }
632     INLINE void SetDrawState(jint state) { SetDrawState(m_hwnd, state); }    // State for native drawing API
633 
634     INLINE virtual BOOL IsTopLevel() { return FALSE; }
635     INLINE virtual BOOL IsEmbeddedFrame() { return FALSE; }
636     INLINE virtual BOOL IsScrollbar() { return FALSE; }
637 
638     static INLINE BOOL IsTopLevelHWnd(HWND hwnd) {
639         AwtComponent *comp = AwtComponent::GetComponent(hwnd);
640         return (comp != NULL &amp;&amp; comp-&gt;IsTopLevel());
641     }
642     static INLINE BOOL IsEmbeddedFrameHWnd(HWND hwnd) {
643         AwtComponent *comp = AwtComponent::GetComponent(hwnd);
644         return (comp != NULL &amp;&amp; comp-&gt;IsEmbeddedFrame());
645     }
646 
647     static jint GetDrawState(HWND hwnd);
648     static void SetDrawState(HWND hwnd, jint state);
649 
650     static HWND GetHWnd(JNIEnv* env, jobject target);
651 
652     static MSG* CreateMessage(UINT message, WPARAM wParam, LPARAM lParam, int x, int y);
653     static void InitMessage(MSG* msg, UINT message, WPARAM wParam, LPARAM lParam, int x, int y);
654 
655     // Some methods to be called on Toolkit thread via Toolkit.InvokeFunction()
656     static void _Show(void *param);
657     static void _Hide(void *param);
658     static void _Enable(void *param);
659     static void _Disable(void *param);
660     static jobject _GetLocationOnScreen(void *param);
661     static void _Reshape(void *param);
662     static void _ReshapeNoCheck(void *param);
663     static void _NativeHandleEvent(void *param);
664     static void _SetForeground(void *param);
665     static void _SetBackground(void *param);
666     static void _SetFont(void *param);
667     static void _Start(void *param);
668     static void _BeginValidate(void *param);
669     static void _EndValidate(void *param);
670     static void _UpdateWindow(void *param);
671     static jlong _AddNativeDropTarget(void *param);
672     static void _RemoveNativeDropTarget(void *param);
673     static jintArray _CreatePrintedPixels(void *param);
674     static jboolean _NativeHandlesWheelScrolling(void *param);
675     static void _SetParent(void * param);
676     static void _SetRectangularShape(void *param);
677     static void _SetZOrder(void *param);
678 
679     static HWND sm_focusOwner;
680 
681 private:
682     static HWND sm_focusedWindow;
683 
684 public:
685     static inline HWND GetFocusedWindow() { return sm_focusedWindow; }
686     static void SetFocusedWindow(HWND window);
687 
688     static void _SetFocus(void *param);
689 
690     static void *SetNativeFocusOwner(void *self);
691     static void *GetNativeFocusedWindow();
692     static void *GetNativeFocusOwner();
693 
694     static BOOL sm_inSynthesizeFocus;
695 
696     // Execute on Toolkit only.
697     INLINE static LRESULT SynthesizeWmSetFocus(HWND targetHWnd, HWND oppositeHWnd) {
698         sm_inSynthesizeFocus = TRUE;
699         LRESULT res = ::SendMessage(targetHWnd, WM_SETFOCUS, (WPARAM)oppositeHWnd, 0);
700         sm_inSynthesizeFocus = FALSE;
701         return res;
702     }
703     // Execute on Toolkit only.
704     INLINE static LRESULT SynthesizeWmKillFocus(HWND targetHWnd, HWND oppositeHWnd) {
705         sm_inSynthesizeFocus = TRUE;
706         LRESULT res = ::SendMessage(targetHWnd, WM_KILLFOCUS, (WPARAM)oppositeHWnd, 0);
707         sm_inSynthesizeFocus = FALSE;
708         return res;
709     }
710 
711     static BOOL sm_bMenuLoop;
712     static INLINE BOOL isMenuLoopActive() {
713         return sm_bMenuLoop;
714     }
715 
716     // when this component is being destroyed, this method is called
717     // to find out if there are any messages being processed, and if
718     // there are some then disposal of this component is postponed
719     virtual BOOL CanBeDeleted() {
720         return m_MessagesProcessing == 0;
721     }
722 
723     BOOL IsDestroyPaused() const {
724         return m_bPauseDestroy;
725     }
726 
727 protected:
728     static AwtComponent* GetComponentImpl(HWND hWnd);
729 
730     static int GetClickCount();
731 
732     HWND     m_hwnd;
733     UINT     m_myControlID;     /* its own ID from the view point of parent */
734     BOOL     m_backgroundColorSet;
735     BOOL     m_visible;         /* copy of Component.visible */
736 
737     static BOOL sm_suppressFocusAndActivation;
738     static BOOL sm_restoreFocusAndActivation;
739 
740     /*
741      * The function sets the focus-restore flag ON/OFF.
742      * When the flag is ON, focus is restored immidiately after the proxy loses it.
743      * All focus messages are suppressed. It&#39;s also assumed that sm_focusedWindow and
744      * sm_focusOwner don&#39;t change after the flag is set ON and before it&#39;s set OFF.
745      */
746     static INLINE void SetRestoreFocus(BOOL doSet) {
747         sm_suppressFocusAndActivation = doSet;
748         sm_restoreFocusAndActivation = doSet;
749     }
750 
751     virtual void SetDragCapture(UINT flags);
752     virtual void ReleaseDragCapture(UINT flags);
753 
754     virtual void FillBackground(HDC hMemoryDC, SIZE &amp;size);
755     virtual void FillAlpha(void *bitmapBits, SIZE &amp;size, BYTE alpha);
756 
757     int ScaleUpX(int x);
758     int ScaleUpY(int y);
759     int ScaleDownX(int x);
760     int ScaleDownY(int y);
761 
762 private:
763     /* A bitmask keeps the button&#39;s numbers as MK_LBUTTON, MK_MBUTTON, MK_RBUTTON
764      * which are allowed to
765      * generate the CLICK event after the RELEASE has happened.
766      * There are conditions that must be true for that sending CLICK event:
767      * 1) button was initially PRESSED
768      * 2) no movement or drag has happened until RELEASE
769     */
770     UINT m_mouseButtonClickAllowed;
771 
772     BOOL m_touchDownOccurred;
773     BOOL m_touchUpOccurred;
774     POINT m_touchDownPoint;
775     POINT m_touchUpPoint;
776 
777     BOOL m_bSubclassed;
778     BOOL m_bPauseDestroy;
779 
780     COLORREF m_colorForeground;
781     COLORREF m_colorBackground;
782 
783     AwtPen*  m_penForeground;
784     AwtBrush* m_brushBackground;
785 
786     WNDPROC  m_DefWindowProc;
787     // counter for messages being processed by this component
788     UINT     m_MessagesProcessing;
789 
790     // provides a unique ID for child controls
791     UINT     m_nextControlID;
792 
793     // DeferWindowPos handle for batched-up window positioning
794     HDWP     m_hdwp;
795     // Counter to handle nested calls to Begin/EndValidate
796     UINT     m_validationNestCount;
797 
798     AwtDropTarget* m_dropTarget; // associated DropTarget object
799 
800     // When we process WM_INPUTLANGCHANGE we remember the keyboard
801     // layout handle and associated input language and codepage.
802     // We also invalidate VK translation table for VK_OEM_* codes
803     static HKL    m_hkl;
804     static UINT   m_CodePage;
805     static LANGID m_idLang;
806 
807     static BOOL sm_rtl;
808     static BOOL sm_rtlReadingOrder;
809 
810     static BOOL sm_PrimaryDynamicTableBuilt;
811 
812     jobject m_InputMethod;
813     BOOL    m_useNativeCompWindow;
814     LPARAM  m_bitsCandType;
815     UINT    m_PendingLeadByte;
816 
817     void SetComponentInHWND();
818 
819     // Determines whether a given virtual key is on the numpad
820     static BOOL IsNumPadKey(UINT vkey, BOOL extended);
821 
822     // Determines the keyLocation of a given key
823     static jint GetKeyLocation(UINT wkey, UINT flags);
824     static jint GetShiftKeyLocation(UINT wkey, UINT flags);
825 
826     // Cache for FindComponent
827     static HWND sm_cursorOn;
828 
829     static BOOL m_QueryNewPaletteCalled;
830 
831     static AwtComponent* sm_getComponentCache; // a cache for the GetComponent(..) method.
832 
833     int windowMoveLockPosX;
834     int windowMoveLockPosY;
835     int windowMoveLockPosCX;
836     int windowMoveLockPosCY;
837 
838     // 6524352: support finer-resolution
839     int m_wheelRotationAmountX;
840     int m_wheelRotationAmountY;
841 
842     BOOL deadKeyActive;
843 
844     /*
845      * The association list of children&#39;s IDs and corresponding components.
846      * Some components like Choice or List are required their sizes while
847      * the creations of themselfs are in progress.
848      */
849     class ChildListItem {
850     public:
851         ChildListItem(UINT id, AwtComponent* component) {
852             m_ID = id;
853             m_Component = component;
854             m_next = NULL;
855         }
856         ~ChildListItem() {
857             if (m_next != NULL)
858                 delete m_next;
859         }
860 
861         UINT m_ID;
862         AwtComponent* m_Component;
863         ChildListItem* m_next;
864     };
865 
866 public:
867     INLINE void PushChild(UINT id, AwtComponent* component) {
868         ChildListItem* child = new ChildListItem(id, component);
869         child-&gt;m_next = m_childList;
870         m_childList = child;
871     }
872 
873     static void SetParent(void * param);
874 private:
875     AwtComponent* SearchChild(UINT id);
876     void RemoveChild(UINT id) ;
877     static BOOL IsNavigationKey(UINT wkey);
878     static void BuildPrimaryDynamicTable();
879 
880     ChildListItem* m_childList;
881 
882     HCURSOR m_hCursorCache; // the latest cursor which has been active within the heavyweight component
883 public:
884     inline void setCursorCache(HCURSOR hCursor) {
885         m_hCursorCache = hCursor;
886     }
887     inline HCURSOR getCursorCache() {
888         return m_hCursorCache;
889     }
890 };
891 
892 class CounterHelper {
893 private:
894     UINT *m_counter;
895 public:
896     explicit CounterHelper(UINT *counter) {
897         m_counter = counter;
898         (*m_counter)++;
899     }
900     ~CounterHelper() {
901         (*m_counter)--;
902         m_counter = NULL;
903     }
904 };
905 
906 // DC management objects; these classes are used to track the list of
907 // DC&#39;s associated with a given Component.  Then DC&#39;s can be released
908 // appropriately on demand or on window destruction to avoid resource
909 // leakage.
910 class DCItem {
911 public:
912     HDC             hDC;
913     HWND            hWnd;
914     DCItem          *next;
915 };
916 class DCList {
917     DCItem          *head;
918     CriticalSection listLock;
919 public:
920     DCList() { head = NULL; }
921 
922     void            AddDC(HDC hDC, HWND hWnd);
923     void            AddDCItem(DCItem *newItem);
924     DCItem          *RemoveDC(HDC hDC, HWND hWnd);
925     DCItem          *RemoveAllDCs(HWND hWnd);
926     DCItem          *RemoveAllDCs();
927     void            RealizePalettes(int screen);
928 };
929 
930 void ReleaseDCList(HWND hwnd, DCList &amp;list);
931 void ReleaseDCList(DCList &amp;list);
932 void MoveDCToPassiveList(HDC hDC, HWND hWnd);
933 
934 #include &quot;ObjectList.h&quot;
935 
936 #endif /* AWT_COMPONENT_H */
    </pre>
  </body>
</html>
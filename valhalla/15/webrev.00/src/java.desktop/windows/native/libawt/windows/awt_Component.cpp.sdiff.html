<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/windows/native/libawt/windows/awt_Component.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="WPrinterJob.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="awt_Component.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/windows/native/libawt/windows/awt_Component.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
1357     AwtToolkit::GetInstance().eventNumber++;
1358 
1359     static BOOL ignoreNextLBTNUP = FALSE; //Ignore next LBUTTONUP msg?
1360 
1361     lastMessage = message;
1362 
1363     if (message == WmAwtIsComponent) {
1364     // special message to identify AWT HWND&#39;s without using
1365     // resource hogging ::SetProp
1366         return (LRESULT)TRUE;
1367     }
1368 
1369     DWORD curPos = 0;
1370 
1371     UINT switchMessage = message;
1372     switch (switchMessage) {
1373       case WM_AWT_GETDC:
1374       {
1375             HDC hDC;
1376             // First, release the DCs scheduled for deletion
<span class="line-modified">1377             ReleaseDCList(GetHWnd(), passiveDCList);</span>
1378 
1379             GetDCReturnStruct *returnStruct = new GetDCReturnStruct;
1380             returnStruct-&gt;gdiLimitReached = FALSE;
1381             if (AwtGDIObject::IncrementIfAvailable()) {
1382                 hDC = ::GetDCEx(GetHWnd(), NULL,
1383                                 DCX_CACHE | DCX_CLIPCHILDREN |
1384                                 DCX_CLIPSIBLINGS);
1385                 if (hDC != NULL) {
1386                     // Add new DC to list of DC&#39;s associated with this Component
1387                     activeDCList.AddDC(hDC, GetHWnd());
1388                 } else {
1389                     // Creation failed; decrement counter in AwtGDIObject
1390                     AwtGDIObject::Decrement();
1391                 }
1392             } else {
1393                 hDC = NULL;
1394                 returnStruct-&gt;gdiLimitReached = TRUE;
1395             }
1396             returnStruct-&gt;hDC = hDC;
1397             retValue = (LRESULT)returnStruct;
1398             mr = mrConsume;
1399             break;
1400       }
1401       case WM_AWT_RELEASEDC:
1402       {
1403             HDC hDC = (HDC)wParam;
1404             MoveDCToPassiveList(hDC, GetHWnd());
<span class="line-modified">1405             ReleaseDCList(GetHWnd(), passiveDCList);</span>
1406             mr = mrConsume;
1407             break;
1408       }
1409       case WM_AWT_RELEASE_ALL_DCS:
1410       {
1411             // Called during Component destruction.  Gets current list of
1412             // DC&#39;s associated with Component and releases each DC.
1413             ReleaseDCList(GetHWnd(), activeDCList);
<span class="line-modified">1414             ReleaseDCList(GetHWnd(), passiveDCList);</span>
1415             mr = mrConsume;
1416             break;
1417       }
1418       case WM_AWT_SHOWCURSOR:
1419           ::ShowCursor(TRUE);
1420           break;
1421       case WM_AWT_HIDECURSOR:
1422           ::ShowCursor(FALSE);
1423           break;
1424       case WM_CREATE: mr = WmCreate(); break;
1425       case WM_CLOSE:      mr = WmClose(); break;
1426       case WM_DESTROY:    mr = WmDestroy(); break;
1427       case WM_NCDESTROY:  mr = WmNcDestroy(); break;
1428 
1429       case WM_ERASEBKGND:
1430           mr = WmEraseBkgnd((HDC)wParam, *(BOOL*)&amp;retValue); break;
1431       case WM_PAINT:
1432           CheckFontSmoothingSettings(GetHWnd());
1433           /* Set draw state */
1434           SetDrawState(GetDrawState() | JAWT_LOCK_CLIP_CHANGED);
</pre>
<hr />
<pre>
7419     listLock.Enter();
7420     DCItem **prevPtrPtr = &amp;head;
7421     DCItem *listPtr = head;
7422     DCItem *newListPtr = NULL;
7423     BOOL ret = FALSE;
7424     while (listPtr) {
7425         DCItem *nextPtr = listPtr-&gt;next;
7426         if (listPtr-&gt;hWnd == hWnd) {
7427             *prevPtrPtr = nextPtr;
7428             listPtr-&gt;next = newListPtr;
7429             newListPtr = listPtr;
7430         } else {
7431             prevPtrPtr = &amp;listPtr-&gt;next;
7432         }
7433         listPtr = nextPtr;
7434     }
7435     listLock.Leave();
7436     return newListPtr;
7437 }
7438 













7439 
7440 /**
7441  * Realize palettes of all existing HDC objects
7442  */
7443 void DCList::RealizePalettes(int screen)
7444 {
7445     listLock.Enter();
7446     DCItem *listPtr = head;
7447     while (listPtr) {
7448         AwtWin32GraphicsDevice::RealizePalette(listPtr-&gt;hDC, screen);
7449         listPtr = listPtr-&gt;next;
7450     }
7451     listLock.Leave();
7452 }
7453 
7454 void MoveDCToPassiveList(HDC hDC, HWND hWnd) {
7455     DCItem *removedDC;
7456     if ((removedDC = activeDCList.RemoveDC(hDC, hWnd)) != NULL) {
7457         passiveDCList.AddDCItem(removedDC);
7458     }
7459 }
7460 
<span class="line-modified">7461 void ReleaseDCList(HWND hwnd, DCList &amp;list) {</span>
<span class="line-removed">7462     DCItem *removedDCs = list.RemoveAllDCs(hwnd);</span>
7463     while (removedDCs) {
7464         DCItem *tmpDCList = removedDCs;
7465         DASSERT(::GetObjectType(tmpDCList-&gt;hDC) == OBJ_DC);
7466         int retValue = ::ReleaseDC(tmpDCList-&gt;hWnd, tmpDCList-&gt;hDC);
7467         VERIFY(retValue != 0);
7468         if (retValue != 0) {
7469             // Valid ReleaseDC call; need to decrement GDI object counter
7470             AwtGDIObject::Decrement();
7471         }
7472         removedDCs = removedDCs-&gt;next;
7473         delete tmpDCList;
7474     }
7475 }








</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
1357     AwtToolkit::GetInstance().eventNumber++;
1358 
1359     static BOOL ignoreNextLBTNUP = FALSE; //Ignore next LBUTTONUP msg?
1360 
1361     lastMessage = message;
1362 
1363     if (message == WmAwtIsComponent) {
1364     // special message to identify AWT HWND&#39;s without using
1365     // resource hogging ::SetProp
1366         return (LRESULT)TRUE;
1367     }
1368 
1369     DWORD curPos = 0;
1370 
1371     UINT switchMessage = message;
1372     switch (switchMessage) {
1373       case WM_AWT_GETDC:
1374       {
1375             HDC hDC;
1376             // First, release the DCs scheduled for deletion
<span class="line-modified">1377             ReleaseDCList(passiveDCList);</span>
1378 
1379             GetDCReturnStruct *returnStruct = new GetDCReturnStruct;
1380             returnStruct-&gt;gdiLimitReached = FALSE;
1381             if (AwtGDIObject::IncrementIfAvailable()) {
1382                 hDC = ::GetDCEx(GetHWnd(), NULL,
1383                                 DCX_CACHE | DCX_CLIPCHILDREN |
1384                                 DCX_CLIPSIBLINGS);
1385                 if (hDC != NULL) {
1386                     // Add new DC to list of DC&#39;s associated with this Component
1387                     activeDCList.AddDC(hDC, GetHWnd());
1388                 } else {
1389                     // Creation failed; decrement counter in AwtGDIObject
1390                     AwtGDIObject::Decrement();
1391                 }
1392             } else {
1393                 hDC = NULL;
1394                 returnStruct-&gt;gdiLimitReached = TRUE;
1395             }
1396             returnStruct-&gt;hDC = hDC;
1397             retValue = (LRESULT)returnStruct;
1398             mr = mrConsume;
1399             break;
1400       }
1401       case WM_AWT_RELEASEDC:
1402       {
1403             HDC hDC = (HDC)wParam;
1404             MoveDCToPassiveList(hDC, GetHWnd());
<span class="line-modified">1405             ReleaseDCList(passiveDCList);</span>
1406             mr = mrConsume;
1407             break;
1408       }
1409       case WM_AWT_RELEASE_ALL_DCS:
1410       {
1411             // Called during Component destruction.  Gets current list of
1412             // DC&#39;s associated with Component and releases each DC.
1413             ReleaseDCList(GetHWnd(), activeDCList);
<span class="line-modified">1414             ReleaseDCList(passiveDCList);</span>
1415             mr = mrConsume;
1416             break;
1417       }
1418       case WM_AWT_SHOWCURSOR:
1419           ::ShowCursor(TRUE);
1420           break;
1421       case WM_AWT_HIDECURSOR:
1422           ::ShowCursor(FALSE);
1423           break;
1424       case WM_CREATE: mr = WmCreate(); break;
1425       case WM_CLOSE:      mr = WmClose(); break;
1426       case WM_DESTROY:    mr = WmDestroy(); break;
1427       case WM_NCDESTROY:  mr = WmNcDestroy(); break;
1428 
1429       case WM_ERASEBKGND:
1430           mr = WmEraseBkgnd((HDC)wParam, *(BOOL*)&amp;retValue); break;
1431       case WM_PAINT:
1432           CheckFontSmoothingSettings(GetHWnd());
1433           /* Set draw state */
1434           SetDrawState(GetDrawState() | JAWT_LOCK_CLIP_CHANGED);
</pre>
<hr />
<pre>
7419     listLock.Enter();
7420     DCItem **prevPtrPtr = &amp;head;
7421     DCItem *listPtr = head;
7422     DCItem *newListPtr = NULL;
7423     BOOL ret = FALSE;
7424     while (listPtr) {
7425         DCItem *nextPtr = listPtr-&gt;next;
7426         if (listPtr-&gt;hWnd == hWnd) {
7427             *prevPtrPtr = nextPtr;
7428             listPtr-&gt;next = newListPtr;
7429             newListPtr = listPtr;
7430         } else {
7431             prevPtrPtr = &amp;listPtr-&gt;next;
7432         }
7433         listPtr = nextPtr;
7434     }
7435     listLock.Leave();
7436     return newListPtr;
7437 }
7438 
<span class="line-added">7439 /**</span>
<span class="line-added">7440  * Remove all DCs from the DC list.  Return the list of those</span>
<span class="line-added">7441  * DC&#39;s to the caller (which will then probably want to</span>
<span class="line-added">7442  * call ReleaseDC() for the returned DCs).</span>
<span class="line-added">7443  */</span>
<span class="line-added">7444 DCItem *DCList::RemoveAllDCs()</span>
<span class="line-added">7445 {</span>
<span class="line-added">7446     listLock.Enter();</span>
<span class="line-added">7447     DCItem *newListPtr = head;</span>
<span class="line-added">7448     head = NULL;</span>
<span class="line-added">7449     listLock.Leave();</span>
<span class="line-added">7450     return newListPtr;</span>
<span class="line-added">7451 }</span>
7452 
7453 /**
7454  * Realize palettes of all existing HDC objects
7455  */
7456 void DCList::RealizePalettes(int screen)
7457 {
7458     listLock.Enter();
7459     DCItem *listPtr = head;
7460     while (listPtr) {
7461         AwtWin32GraphicsDevice::RealizePalette(listPtr-&gt;hDC, screen);
7462         listPtr = listPtr-&gt;next;
7463     }
7464     listLock.Leave();
7465 }
7466 
7467 void MoveDCToPassiveList(HDC hDC, HWND hWnd) {
7468     DCItem *removedDC;
7469     if ((removedDC = activeDCList.RemoveDC(hDC, hWnd)) != NULL) {
7470         passiveDCList.AddDCItem(removedDC);
7471     }
7472 }
7473 
<span class="line-modified">7474 static void ReleaseDCList(DCItem *removedDCs) {</span>

7475     while (removedDCs) {
7476         DCItem *tmpDCList = removedDCs;
7477         DASSERT(::GetObjectType(tmpDCList-&gt;hDC) == OBJ_DC);
7478         int retValue = ::ReleaseDC(tmpDCList-&gt;hWnd, tmpDCList-&gt;hDC);
7479         VERIFY(retValue != 0);
7480         if (retValue != 0) {
7481             // Valid ReleaseDC call; need to decrement GDI object counter
7482             AwtGDIObject::Decrement();
7483         }
7484         removedDCs = removedDCs-&gt;next;
7485         delete tmpDCList;
7486     }
7487 }
<span class="line-added">7488 </span>
<span class="line-added">7489 void ReleaseDCList(HWND hwnd, DCList &amp;list) {</span>
<span class="line-added">7490     ReleaseDCList(list.RemoveAllDCs(hwnd));</span>
<span class="line-added">7491 }</span>
<span class="line-added">7492 </span>
<span class="line-added">7493 void ReleaseDCList(DCList &amp;list) {</span>
<span class="line-added">7494     ReleaseDCList(list.RemoveAllDCs());</span>
<span class="line-added">7495 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="WPrinterJob.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="awt_Component.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
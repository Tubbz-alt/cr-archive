diff a/src/java.desktop/windows/native/libawt/windows/awt_Component.cpp b/src/java.desktop/windows/native/libawt/windows/awt_Component.cpp
--- a/src/java.desktop/windows/native/libawt/windows/awt_Component.cpp
+++ b/src/java.desktop/windows/native/libawt/windows/awt_Component.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -1372,11 +1372,11 @@
     switch (switchMessage) {
       case WM_AWT_GETDC:
       {
             HDC hDC;
             // First, release the DCs scheduled for deletion
-            ReleaseDCList(GetHWnd(), passiveDCList);
+            ReleaseDCList(passiveDCList);
 
             GetDCReturnStruct *returnStruct = new GetDCReturnStruct;
             returnStruct->gdiLimitReached = FALSE;
             if (AwtGDIObject::IncrementIfAvailable()) {
                 hDC = ::GetDCEx(GetHWnd(), NULL,
@@ -1400,20 +1400,20 @@
       }
       case WM_AWT_RELEASEDC:
       {
             HDC hDC = (HDC)wParam;
             MoveDCToPassiveList(hDC, GetHWnd());
-            ReleaseDCList(GetHWnd(), passiveDCList);
+            ReleaseDCList(passiveDCList);
             mr = mrConsume;
             break;
       }
       case WM_AWT_RELEASE_ALL_DCS:
       {
             // Called during Component destruction.  Gets current list of
             // DC's associated with Component and releases each DC.
             ReleaseDCList(GetHWnd(), activeDCList);
-            ReleaseDCList(GetHWnd(), passiveDCList);
+            ReleaseDCList(passiveDCList);
             mr = mrConsume;
             break;
       }
       case WM_AWT_SHOWCURSOR:
           ::ShowCursor(TRUE);
@@ -7434,10 +7434,23 @@
     }
     listLock.Leave();
     return newListPtr;
 }
 
+/**
+ * Remove all DCs from the DC list.  Return the list of those
+ * DC's to the caller (which will then probably want to
+ * call ReleaseDC() for the returned DCs).
+ */
+DCItem *DCList::RemoveAllDCs()
+{
+    listLock.Enter();
+    DCItem *newListPtr = head;
+    head = NULL;
+    listLock.Leave();
+    return newListPtr;
+}
 
 /**
  * Realize palettes of all existing HDC objects
  */
 void DCList::RealizePalettes(int screen)
@@ -7456,12 +7469,11 @@
     if ((removedDC = activeDCList.RemoveDC(hDC, hWnd)) != NULL) {
         passiveDCList.AddDCItem(removedDC);
     }
 }
 
-void ReleaseDCList(HWND hwnd, DCList &list) {
-    DCItem *removedDCs = list.RemoveAllDCs(hwnd);
+static void ReleaseDCList(DCItem *removedDCs) {
     while (removedDCs) {
         DCItem *tmpDCList = removedDCs;
         DASSERT(::GetObjectType(tmpDCList->hDC) == OBJ_DC);
         int retValue = ::ReleaseDC(tmpDCList->hWnd, tmpDCList->hDC);
         VERIFY(retValue != 0);
@@ -7471,5 +7483,13 @@
         }
         removedDCs = removedDCs->next;
         delete tmpDCList;
     }
 }
+
+void ReleaseDCList(HWND hwnd, DCList &list) {
+    ReleaseDCList(list.RemoveAllDCs(hwnd));
+}
+
+void ReleaseDCList(DCList &list) {
+    ReleaseDCList(list.RemoveAllDCs());
+}

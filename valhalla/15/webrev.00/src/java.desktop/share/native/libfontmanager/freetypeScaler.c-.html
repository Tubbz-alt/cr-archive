<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/freetypeScaler.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &quot;jni.h&quot;
  27 #include &quot;jni_util.h&quot;
  28 #include &quot;jlong.h&quot;
  29 #include &quot;sunfontids.h&quot;
  30 #include &quot;sun_font_FreetypeFontScaler.h&quot;
  31 
  32 #include &lt;stdlib.h&gt;
  33 #if !defined(_WIN32) &amp;&amp; !defined(__APPLE_)
  34 #include &lt;dlfcn.h&gt;
  35 #endif
  36 #include &lt;math.h&gt;
  37 #include &quot;ft2build.h&quot;
  38 #include FT_FREETYPE_H
  39 #include FT_GLYPH_H
  40 #include FT_BBOX_H
  41 #include FT_SIZES_H
  42 #include FT_OUTLINE_H
  43 #include FT_SYNTHESIS_H
  44 #include FT_LCD_FILTER_H
  45 #include FT_MODULE_H
  46 
  47 #include &quot;fontscaler.h&quot;
  48 
  49 #define  ftFixed1  (FT_Fixed) (1 &lt;&lt; 16)
  50 #define  FloatToFTFixed(f) (FT_Fixed)((f) * (float)(ftFixed1))
  51 #define  FTFixedToFloat(x) ((x) / (float)(ftFixed1))
  52 #define  FT26Dot6ToFloat(x)  ((x) / ((float) (1&lt;&lt;6)))
  53 #define  FT26Dot6ToInt(x) (((int)(x)) &gt;&gt; 6)
  54 
  55 typedef struct {
  56     /* Important note:
  57          JNI forbids sharing same env between different threads.
  58          We are safe, because pointer is overwritten every time we get into
  59          JNI call (see setupFTContext).
  60 
  61          Pointer is used by font data reading callbacks
  62          such as ReadTTFontFileFunc.
  63 
  64          NB: We may consider switching to JNI_GetEnv. */
  65     JNIEnv* env;
  66     FT_Library library;
  67     FT_Face face;
  68     FT_Stream faceStream;
  69     jobject font2D;
  70     jobject directBuffer;
  71 
  72     unsigned char* fontData;
  73     unsigned fontDataOffset;
  74     unsigned fontDataLength;
  75     unsigned fileSize;
  76 } FTScalerInfo;
  77 
  78 typedef struct FTScalerContext {
  79     FT_Matrix  transform;     /* glyph transform, including device transform */
  80     jboolean   useSbits;      /* sbit usage enabled? */
  81     jint       aaType;        /* antialiasing mode (off/on/grey/lcd) */
  82     jint       fmType;        /* fractional metrics - on/off */
  83     jboolean   doBold;        /* perform algorithmic bolding? */
  84     jboolean   doItalize;     /* perform algorithmic italicizing? */
  85     int        renderFlags;   /* configuration specific to particular engine */
  86     int        pathType;
  87     int        ptsz;          /* size in points */
  88 } FTScalerContext;
  89 
  90 #ifdef DEBUG
  91 /* These are referenced in the freetype sources if DEBUG macro is defined.
  92    To simplify work with debuging version of freetype we define
  93    them here. */
  94 int z_verbose;
  95 void z_error(char *s) {}
  96 #endif
  97 
  98 /**************** Error handling utilities *****************/
  99 
 100 static jmethodID invalidateScalerMID;
 101 
 102 JNIEXPORT void JNICALL
 103 Java_sun_font_FreetypeFontScaler_initIDs(
 104         JNIEnv *env, jobject scaler, jclass FFSClass) {
 105     invalidateScalerMID =
 106         (*env)-&gt;GetMethodID(env, FFSClass, &quot;invalidateScaler&quot;, &quot;()V&quot;);
 107 }
 108 
 109 static void freeNativeResources(JNIEnv *env, FTScalerInfo* scalerInfo) {
 110 
 111     if (scalerInfo == NULL)
 112         return;
 113 
 114     // FT_Done_Face always closes the stream, but only frees the memory
 115     // of the data structure if it was internally allocated by FT.
 116     // We hold on to a pointer to the stream structure if we provide it
 117     // ourselves, so that we can free it here.
 118     FT_Done_Face(scalerInfo-&gt;face);
 119     FT_Done_FreeType(scalerInfo-&gt;library);
 120 
 121     if (scalerInfo-&gt;directBuffer != NULL) {
 122         (*env)-&gt;DeleteGlobalRef(env, scalerInfo-&gt;directBuffer);
 123     }
 124 
 125     if (scalerInfo-&gt;fontData != NULL) {
 126         free(scalerInfo-&gt;fontData);
 127     }
 128 
 129     if (scalerInfo-&gt;faceStream != NULL) {
 130         free(scalerInfo-&gt;faceStream);
 131     }
 132     free(scalerInfo);
 133 }
 134 
 135 /* invalidates state of java scaler object */
 136 static void invalidateJavaScaler(JNIEnv *env,
 137                                  jobject scaler,
 138                                  FTScalerInfo* scalerInfo) {
 139     freeNativeResources(env, scalerInfo);
 140     (*env)-&gt;CallVoidMethod(env, scaler, invalidateScalerMID);
 141 }
 142 
 143 /******************* I/O handlers ***************************/
 144 
 145 #define FILEDATACACHESIZE 1024
 146 
 147 static unsigned long ReadTTFontFileFunc(FT_Stream stream,
 148                                         unsigned long offset,
 149                                         unsigned char* destBuffer,
 150                                         unsigned long numBytes)
 151 {
 152     FTScalerInfo *scalerInfo = (FTScalerInfo *) stream-&gt;pathname.pointer;
 153     JNIEnv* env = scalerInfo-&gt;env;
 154     jobject bBuffer;
 155     int bread = 0;
 156 
 157     /* A call with numBytes == 0 is a seek. It should return 0 if the
 158      * seek position is within the file and non-zero otherwise.
 159      * For all other cases, ie numBytes !=0, return the number of bytes
 160      * actually read. This applies to truncated reads and also failed reads.
 161      */
 162 
 163     if (numBytes == 0) {
 164         if (offset &gt; scalerInfo-&gt;fileSize) {
 165             return -1;
 166         } else {
 167             return 0;
 168        }
 169     }
 170 
 171     if (offset + numBytes &lt; offset) {
 172         return 0; // ft should not do this, but just in case.
 173     }
 174 
 175     if (offset &gt;= scalerInfo-&gt;fileSize) {
 176         return 0;
 177     }
 178 
 179     if (offset + numBytes &gt; scalerInfo-&gt;fileSize) {
 180         numBytes = scalerInfo-&gt;fileSize - offset;
 181     }
 182 
 183     /* Large reads will bypass the cache and data copying */
 184     if (numBytes &gt; FILEDATACACHESIZE) {
 185         bBuffer = (*env)-&gt;NewDirectByteBuffer(env, destBuffer, numBytes);
 186         if (bBuffer != NULL) {
 187             bread = (*env)-&gt;CallIntMethod(env,
 188                                           scalerInfo-&gt;font2D,
 189                                           sunFontIDs.ttReadBlockMID,
 190                                           bBuffer, offset, numBytes);
 191             if (bread &lt; 0) {
 192                 return 0;
 193             } else {
 194                return bread;
 195             }
 196         } else {
 197             /* We probably hit bug 4845371. For reasons that
 198              * are currently unclear, the call stacks after the initial
 199              * createScaler call that read large amounts of data seem to
 200              * be OK and can create the byte buffer above, but this code
 201              * is here just in case.
 202              * 4845371 is fixed now so I don&#39;t expect this code path to
 203              * ever get called but its harmless to leave it here on the
 204              * small chance its needed.
 205              */
 206             jbyteArray byteArray = (jbyteArray)
 207             (*env)-&gt;CallObjectMethod(env, scalerInfo-&gt;font2D,
 208                                      sunFontIDs.ttReadBytesMID,
 209                                      offset, numBytes);
 210             /* If there&#39;s an OutofMemoryError then byteArray will be null */
 211             if (byteArray == NULL) {
 212                 return 0;
 213             } else {
 214                 jsize len = (*env)-&gt;GetArrayLength(env, byteArray);
 215                 if (len &lt; numBytes) {
 216                     numBytes = len; // don&#39;t get more bytes than there are ..
 217                 }
 218                 (*env)-&gt;GetByteArrayRegion(env, byteArray,
 219                                            0, numBytes, (jbyte*)destBuffer);
 220                 return numBytes;
 221             }
 222         }
 223     } /* Do we have a cache hit? */
 224       else if (scalerInfo-&gt;fontDataOffset &lt;= offset &amp;&amp;
 225         scalerInfo-&gt;fontDataOffset + scalerInfo-&gt;fontDataLength &gt;=
 226                                                          offset + numBytes)
 227     {
 228         unsigned cacheOffset = offset - scalerInfo-&gt;fontDataOffset;
 229 
 230         memcpy(destBuffer, scalerInfo-&gt;fontData+(size_t)cacheOffset, numBytes);
 231         return numBytes;
 232     } else {
 233         /* Must fill the cache */
 234         scalerInfo-&gt;fontDataOffset = offset;
 235         scalerInfo-&gt;fontDataLength =
 236                  (offset + FILEDATACACHESIZE &gt; scalerInfo-&gt;fileSize) ?
 237                  scalerInfo-&gt;fileSize - offset : FILEDATACACHESIZE;
 238         bBuffer = scalerInfo-&gt;directBuffer;
 239         bread = (*env)-&gt;CallIntMethod(env, scalerInfo-&gt;font2D,
 240                                       sunFontIDs.ttReadBlockMID,
 241                                       bBuffer, offset,
 242                                       scalerInfo-&gt;fontDataLength);
 243         if (bread &lt;= 0) {
 244             return 0;
 245         } else if (bread &lt; numBytes) {
 246            numBytes = bread;
 247         }
 248         memcpy(destBuffer, scalerInfo-&gt;fontData, numBytes);
 249         return numBytes;
 250     }
 251 }
 252 
 253 typedef FT_Error (*FT_Prop_Set_Func)(FT_Library library,
 254                                      const FT_String*  module_name,
 255                                      const FT_String*  property_name,
 256                                      const void*       value );
 257 
 258 /**
 259  * Prefer the older v35 freetype byte code interpreter.
 260  */
 261 static void setInterpreterVersion(FT_Library library) {
 262 
 263     char* props = getenv(&quot;FREETYPE_PROPERTIES&quot;);
 264     int version = 35;
 265     const char* module = &quot;truetype&quot;;
 266     const char* property = &quot;interpreter-version&quot;;
 267 
 268     /* If some one is setting this, don&#39;t override it */
 269     if (props != NULL &amp;&amp; strstr(property, props)) {
 270         return;
 271     }
 272     /*
 273      * FT_Property_Set was introduced in 2.4.11.
 274      * Some older supported Linux OSes may not include it so look
 275      * this up dynamically.
 276      * And if its not available it doesn&#39;t matter, since the reason
 277      * we need it dates from 2.7.
 278      * On Windows &amp; Mac the library is always bundled so it is safe
 279      * to use directly in those cases.
 280      */
 281 #if defined(_WIN32) || defined(__APPLE__)
 282     FT_Property_Set(library, module, property, (void*)(&amp;version));
 283 #else
 284     void *lib = dlopen(&quot;libfreetype.so&quot;, RTLD_LOCAL|RTLD_LAZY);
 285     if (lib == NULL) {
 286         lib = dlopen(&quot;libfreetype.so.6&quot;, RTLD_LOCAL|RTLD_LAZY);
 287         if (lib == NULL) {
 288             return;
 289         }
 290     }
 291     FT_Prop_Set_Func func = (FT_Prop_Set_Func)dlsym(lib, &quot;FT_Property_Set&quot;);
 292     if (func != NULL) {
 293         func(library, module, property, (void*)(&amp;version));
 294     }
 295     dlclose(lib);
 296 #endif
 297 }
 298 
 299 /*
 300  * Class:     sun_font_FreetypeFontScaler
 301  * Method:    initNativeScaler
 302  * Signature: (Lsun/font/Font2D;IIZI)J
 303  */
 304 JNIEXPORT jlong JNICALL
 305 Java_sun_font_FreetypeFontScaler_initNativeScaler(
 306         JNIEnv *env, jobject scaler, jobject font2D, jint type,
 307         jint indexInCollection, jboolean supportsCJK, jint filesize) {
 308     FTScalerInfo* scalerInfo = NULL;
 309     FT_Open_Args ft_open_args;
 310     int error;
 311     jobject bBuffer;
 312     scalerInfo = (FTScalerInfo*) calloc(1, sizeof(FTScalerInfo));
 313 
 314     if (scalerInfo == NULL)
 315         return 0;
 316 
 317     scalerInfo-&gt;env = env;
 318     scalerInfo-&gt;font2D = font2D;
 319     scalerInfo-&gt;fontDataOffset = 0;
 320     scalerInfo-&gt;fontDataLength = 0;
 321     scalerInfo-&gt;fileSize = filesize;
 322 
 323     /*
 324        We can consider sharing freetype library between different
 325        scalers. However, Freetype docs suggest to use different libraries
 326        for different threads. Also, our architecture implies that single
 327        FontScaler object is shared for different sizes/transforms/styles
 328        of the same font.
 329 
 330        On other hand these methods can not be concurrently executed
 331        becaused they are &quot;synchronized&quot; in java.
 332     */
 333     error = FT_Init_FreeType(&amp;scalerInfo-&gt;library);
 334     if (error) {
 335         free(scalerInfo);
 336         return 0;
 337     }
 338     setInterpreterVersion(scalerInfo-&gt;library);
 339 
 340 #define TYPE1_FROM_JAVA        2
 341 
 342     error = 1; /* triggers memory freeing unless we clear it */
 343     if (type == TYPE1_FROM_JAVA) { /* TYPE1 */
 344         scalerInfo-&gt;fontData = (unsigned char*) malloc(filesize);
 345         scalerInfo-&gt;directBuffer = NULL;
 346         scalerInfo-&gt;fontDataLength = filesize;
 347 
 348         if (scalerInfo-&gt;fontData != NULL) {
 349             bBuffer = (*env)-&gt;NewDirectByteBuffer(env,
 350                                               scalerInfo-&gt;fontData,
 351                                               scalerInfo-&gt;fontDataLength);
 352             if (bBuffer != NULL) {
 353                 (*env)-&gt;CallVoidMethod(env, font2D,
 354                                    sunFontIDs.readFileMID, bBuffer);
 355 
 356                 error = FT_New_Memory_Face(scalerInfo-&gt;library,
 357                                    scalerInfo-&gt;fontData,
 358                                    scalerInfo-&gt;fontDataLength,
 359                                    indexInCollection,
 360                                    &amp;scalerInfo-&gt;face);
 361             }
 362         }
 363     } else { /* Truetype */
 364         scalerInfo-&gt;fontData = (unsigned char*) malloc(FILEDATACACHESIZE);
 365 
 366         if (scalerInfo-&gt;fontData != NULL) {
 367             FT_Stream ftstream = (FT_Stream) calloc(1, sizeof(FT_StreamRec));
 368             if (ftstream != NULL) {
 369                 scalerInfo-&gt;directBuffer = (*env)-&gt;NewDirectByteBuffer(env,
 370                                            scalerInfo-&gt;fontData,
 371                                            FILEDATACACHESIZE);
 372                 if (scalerInfo-&gt;directBuffer != NULL) {
 373                     scalerInfo-&gt;directBuffer = (*env)-&gt;NewGlobalRef(env,
 374                                                scalerInfo-&gt;directBuffer);
 375                     ftstream-&gt;base = NULL;
 376                     ftstream-&gt;size = filesize;
 377                     ftstream-&gt;pos = 0;
 378                     ftstream-&gt;read = (FT_Stream_IoFunc) ReadTTFontFileFunc;
 379                     ftstream-&gt;close = NULL;
 380                     ftstream-&gt;pathname.pointer = (void *) scalerInfo;
 381 
 382                     memset(&amp;ft_open_args, 0, sizeof(FT_Open_Args));
 383                     ft_open_args.flags = FT_OPEN_STREAM;
 384                     ft_open_args.stream = ftstream;
 385 
 386                     error = FT_Open_Face(scalerInfo-&gt;library,
 387                                          &amp;ft_open_args,
 388                                          indexInCollection,
 389                                          &amp;scalerInfo-&gt;face);
 390                     if (!error) {
 391                         scalerInfo-&gt;faceStream = ftstream;
 392                     }
 393                 }
 394                 if (error || scalerInfo-&gt;directBuffer == NULL) {
 395                     free(ftstream);
 396                 }
 397             }
 398         }
 399     }
 400 
 401     if (error) {
 402         FT_Done_FreeType(scalerInfo-&gt;library);
 403         if (scalerInfo-&gt;directBuffer != NULL) {
 404             (*env)-&gt;DeleteGlobalRef(env, scalerInfo-&gt;directBuffer);
 405         }
 406         if (scalerInfo-&gt;fontData != NULL)
 407             free(scalerInfo-&gt;fontData);
 408         free(scalerInfo);
 409         return 0;
 410     }
 411 
 412     return ptr_to_jlong(scalerInfo);
 413 }
 414 
 415 static double euclidianDistance(double a, double b) {
 416     if (a &lt; 0) a=-a;
 417     if (b &lt; 0) b=-b;
 418 
 419     if (a == 0) return b;
 420     if (b == 0) return a;
 421 
 422     return sqrt(a*a+b*b);
 423 }
 424 
 425 JNIEXPORT jlong JNICALL
 426 Java_sun_font_FreetypeFontScaler_createScalerContextNative(
 427         JNIEnv *env, jobject scaler, jlong pScaler, jdoubleArray matrix,
 428         jint aa, jint fm, jfloat boldness, jfloat italic) {
 429     double dmat[4], ptsz;
 430     FTScalerContext *context =
 431             (FTScalerContext*) calloc(1, sizeof(FTScalerContext));
 432     FTScalerInfo *scalerInfo =
 433              (FTScalerInfo*) jlong_to_ptr(pScaler);
 434 
 435     if (context == NULL) {
 436         invalidateJavaScaler(env, scaler, NULL);
 437         return (jlong) 0;
 438     }
 439     (*env)-&gt;GetDoubleArrayRegion(env, matrix, 0, 4, dmat);
 440     ptsz = euclidianDistance(dmat[2], dmat[3]); //i.e. y-size
 441     if (ptsz &lt; 1.0) {
 442         //text can not be smaller than 1 point
 443         ptsz = 1.0;
 444     }
 445     context-&gt;ptsz = (int)(ptsz * 64);
 446     context-&gt;transform.xx =  FloatToFTFixed((float)dmat[0]/ptsz);
 447     context-&gt;transform.yx = -FloatToFTFixed((float)dmat[1]/ptsz);
 448     context-&gt;transform.xy = -FloatToFTFixed((float)dmat[2]/ptsz);
 449     context-&gt;transform.yy =  FloatToFTFixed((float)dmat[3]/ptsz);
 450     context-&gt;aaType = aa;
 451     context-&gt;fmType = fm;
 452 
 453     /* If using algorithmic styling, the base values are
 454      * boldness = 1.0, italic = 0.0.
 455      */
 456     context-&gt;doBold = (boldness != 1.0);
 457     context-&gt;doItalize = (italic != 0);
 458 
 459     /* freetype is very keen to use embedded bitmaps, even if it knows
 460      * there is a rotation or you asked for antialiasing.
 461      * In the rendering path we will check useSBits and disable
 462      * bitmaps unless it is set. And here we set it only if none
 463      * of the conditions invalidate using it.
 464      * Note that we allow embedded bitmaps for the LCD case.
 465      */
 466     if ((aa != TEXT_AA_ON) &amp;&amp; (fm != TEXT_FM_ON) &amp;&amp;
 467         !context-&gt;doBold &amp;&amp; !context-&gt;doItalize &amp;&amp;
 468         (context-&gt;transform.yx == 0) &amp;&amp; (context-&gt;transform.xy == 0))
 469     {
 470         context-&gt;useSbits = 1;
 471     }
 472     return ptr_to_jlong(context);
 473 }
 474 
 475 // values used by FreeType (as of version 2.10.1) for italics transformation matrix in FT_GlyphSlot_Oblique
 476 #define FT_MATRIX_ONE 0x10000
 477 #define FT_MATRIX_OBLIQUE_XY 0x0366A
 478 
 479 static void setupTransform(FT_Matrix* target, FTScalerContext *context) {
 480     FT_Matrix* transform = &amp;context-&gt;transform;
 481     if (context-&gt;doItalize) {
 482         // we cannot use FT_GlyphSlot_Oblique as it doesn&#39;t work well with arbitrary transforms,
 483         // so we add corresponding shear transform to the requested glyph transformation
 484         target-&gt;xx = FT_MATRIX_ONE;
 485         target-&gt;xy = FT_MATRIX_OBLIQUE_XY;
 486         target-&gt;yx = 0;
 487         target-&gt;yy = FT_MATRIX_ONE;
 488         FT_Matrix_Multiply(transform, target);
 489     } else {
 490         target-&gt;xx = transform-&gt;xx;
 491         target-&gt;xy = transform-&gt;xy;
 492         target-&gt;yx = transform-&gt;yx;
 493         target-&gt;yy = transform-&gt;yy;
 494     }
 495 }
 496 
 497 static int setupFTContext(JNIEnv *env,
 498                           jobject font2D,
 499                           FTScalerInfo *scalerInfo,
 500                           FTScalerContext *context) {
 501     FT_Matrix matrix;
 502     int errCode = 0;
 503 
 504     scalerInfo-&gt;env = env;
 505     scalerInfo-&gt;font2D = font2D;
 506 
 507     if (context != NULL) {
 508         setupTransform(&amp;matrix, context);
 509         FT_Set_Transform(scalerInfo-&gt;face, &amp;matrix, NULL);
 510 
 511         errCode = FT_Set_Char_Size(scalerInfo-&gt;face, 0, context-&gt;ptsz, 72, 72);
 512 
 513         if (errCode == 0) {
 514             errCode = FT_Activate_Size(scalerInfo-&gt;face-&gt;size);
 515         }
 516 
 517         FT_Library_SetLcdFilter(scalerInfo-&gt;library, FT_LCD_FILTER_DEFAULT);
 518     }
 519 
 520     return errCode;
 521 }
 522 
 523 // using same values as for the transformation matrix
 524 #define OBLIQUE_MODIFIER(y)  (context-&gt;doItalize ? ((y)*FT_MATRIX_OBLIQUE_XY/FT_MATRIX_ONE) : 0)
 525 
 526 /* FT_GlyphSlot_Embolden (ftsynth.c) uses FT_MulFix(units_per_EM, y_scale) / 24
 527  * strength value when glyph format is FT_GLYPH_FORMAT_OUTLINE. This value has
 528  * been taken from libfreetype version 2.6 and remain valid at least up to
 529  * 2.9.1. */
 530 #define BOLD_MODIFIER(units_per_EM, y_scale) \
 531     (context-&gt;doBold ? FT_MulFix(units_per_EM, y_scale) / 24 : 0)
 532 
 533 /*
 534  * Class:     sun_font_FreetypeFontScaler
 535  * Method:    getFontMetricsNative
 536  * Signature: (Lsun/font/Font2D;J)Lsun/font/StrikeMetrics;
 537  */
 538 JNIEXPORT jobject JNICALL
 539 Java_sun_font_FreetypeFontScaler_getFontMetricsNative(
 540         JNIEnv *env, jobject scaler, jobject font2D,
 541         jlong pScalerContext, jlong pScaler) {
 542 
 543     jobject metrics;
 544     jfloat ax, ay, dx, dy, bx, by, lx, ly, mx, my;
 545     jfloat f0 = 0.0;
 546     FTScalerContext *context =
 547         (FTScalerContext*) jlong_to_ptr(pScalerContext);
 548     FTScalerInfo *scalerInfo =
 549              (FTScalerInfo*) jlong_to_ptr(pScaler);
 550 
 551     int errCode;
 552 
 553     if (isNullScalerContext(context) || scalerInfo == NULL) {
 554         return (*env)-&gt;NewObject(env,
 555                                  sunFontIDs.strikeMetricsClass,
 556                                  sunFontIDs.strikeMetricsCtr,
 557                                  f0, f0, f0, f0, f0, f0, f0, f0, f0, f0);
 558     }
 559 
 560     errCode = setupFTContext(env, font2D, scalerInfo, context);
 561 
 562     if (errCode) {
 563         metrics = (*env)-&gt;NewObject(env,
 564                                  sunFontIDs.strikeMetricsClass,
 565                                  sunFontIDs.strikeMetricsCtr,
 566                                  f0, f0, f0, f0, f0, f0, f0, f0, f0, f0);
 567         invalidateJavaScaler(env, scaler, scalerInfo);
 568         return metrics;
 569     }
 570 
 571     /* This is ugly and has to be reworked.
 572        Freetype provide means to add style to glyph but
 573        it seems there is no way to adjust metrics accordingly.
 574 
 575        So, we have to do adust them explicitly and stay consistent with what
 576        freetype does to outlines. */
 577 
 578 
 579     /**** Note: only some metrics are affected by styling ***/
 580 
 581     /* See https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=657854 */
 582 #define FT_MulFixFloatShift6(a, b) (((float) (a)) * ((float) (b)) / 65536.0 / 64.0)
 583 
 584 #define contextAwareMetricsX(x, y) \
 585     (FTFixedToFloat(context-&gt;transform.xx) * (x) - \
 586      FTFixedToFloat(context-&gt;transform.xy) * (y))
 587 
 588 #define contextAwareMetricsY(x, y) \
 589     (-FTFixedToFloat(context-&gt;transform.yx) * (x) + \
 590      FTFixedToFloat(context-&gt;transform.yy) * (y))
 591 
 592     /*
 593      * See FreeType source code: src/base/ftobjs.c ft_recompute_scaled_metrics()
 594      * http://icedtea.classpath.org/bugzilla/show_bug.cgi?id=1659
 595      */
 596     /* ascent */
 597     ax = 0;
 598     ay = -(jfloat) (FT_MulFixFloatShift6(
 599                        ((jlong) scalerInfo-&gt;face-&gt;ascender),
 600                        (jlong) scalerInfo-&gt;face-&gt;size-&gt;metrics.y_scale));
 601     /* descent */
 602     dx = 0;
 603     dy = -(jfloat) (FT_MulFixFloatShift6(
 604                        ((jlong) scalerInfo-&gt;face-&gt;descender),
 605                        (jlong) scalerInfo-&gt;face-&gt;size-&gt;metrics.y_scale));
 606     /* baseline */
 607     bx = by = 0;
 608 
 609     /* leading */
 610     lx = 0;
 611     ly = (jfloat) (FT_MulFixFloatShift6(
 612                       (jlong) scalerInfo-&gt;face-&gt;height,
 613                       (jlong) scalerInfo-&gt;face-&gt;size-&gt;metrics.y_scale))
 614                   + ay - dy;
 615     /* max advance */
 616     mx = (jfloat) FT26Dot6ToFloat(
 617                      scalerInfo-&gt;face-&gt;size-&gt;metrics.max_advance +
 618                      OBLIQUE_MODIFIER(scalerInfo-&gt;face-&gt;size-&gt;metrics.height) +
 619                      BOLD_MODIFIER(scalerInfo-&gt;face-&gt;units_per_EM,
 620                              scalerInfo-&gt;face-&gt;size-&gt;metrics.y_scale));
 621     my = 0;
 622 
 623     metrics = (*env)-&gt;NewObject(env,
 624         sunFontIDs.strikeMetricsClass,
 625         sunFontIDs.strikeMetricsCtr,
 626         contextAwareMetricsX(ax, ay), contextAwareMetricsY(ax, ay),
 627         contextAwareMetricsX(dx, dy), contextAwareMetricsY(dx, dy),
 628         bx, by,
 629         contextAwareMetricsX(lx, ly), contextAwareMetricsY(lx, ly),
 630         contextAwareMetricsX(mx, my), contextAwareMetricsY(mx, my));
 631 
 632     return metrics;
 633 }
 634 
 635 static jlong
 636     getGlyphImageNativeInternal(
 637         JNIEnv *env, jobject scaler, jobject font2D,
 638         jlong pScalerContext, jlong pScaler, jint glyphCode,
 639         jboolean renderImage);
 640 
 641 /*
 642  * Class:     sun_font_FreetypeFontScaler
 643  * Method:    getGlyphAdvanceNative
 644  * Signature: (Lsun/font/Font2D;JI)F
 645  */
 646 JNIEXPORT jfloat JNICALL
 647 Java_sun_font_FreetypeFontScaler_getGlyphAdvanceNative(
 648         JNIEnv *env, jobject scaler, jobject font2D,
 649         jlong pScalerContext, jlong pScaler, jint glyphCode) {
 650 
 651    /* This method is rarely used because requests for metrics are usually
 652     * coupled with a request for the bitmap and to a large extent the
 653     * work can be reused (to find out metrics we may need to hint the glyph).
 654     * So, we typically go through the getGlyphImage code path.
 655     * When we do get here, we need to pass a parameter which indicates
 656     * that we don&#39;t need freetype to render the bitmap, and consequently
 657     * don&#39;t need to allocate our own storage either.
 658     * This is also important when enter here requesting metrics for sizes
 659     * of text which a large size would be rejected for a bitmap but we
 660     * still need the metrics.
 661     */
 662 
 663     GlyphInfo *info;
 664     jfloat advance = 0.0f;
 665     jlong image;
 666 
 667     image = getGlyphImageNativeInternal(
 668           env, scaler, font2D, pScalerContext, pScaler, glyphCode, JNI_FALSE);
 669     info = (GlyphInfo*) jlong_to_ptr(image);
 670 
 671     if (info != NULL) {
 672         advance = info-&gt;advanceX;
 673         free(info);
 674     }
 675 
 676     return advance;
 677 }
 678 
 679 /*
 680  * Class:     sun_font_FreetypeFontScaler
 681  * Method:    getGlyphMetricsNative
 682  * Signature: (Lsun/font/Font2D;JILjava/awt/geom/Point2D/Float;)V
 683  */
 684 JNIEXPORT void JNICALL
 685 Java_sun_font_FreetypeFontScaler_getGlyphMetricsNative(
 686         JNIEnv *env, jobject scaler, jobject font2D, jlong pScalerContext,
 687         jlong pScaler, jint glyphCode, jobject metrics) {
 688 
 689      /* See the comments in getGlyphMetricsNative. They apply here too. */
 690      GlyphInfo *info;
 691 
 692      jlong image = getGlyphImageNativeInternal(
 693                                  env, scaler, font2D,
 694                                  pScalerContext, pScaler, glyphCode, JNI_FALSE);
 695      info = (GlyphInfo*) jlong_to_ptr(image);
 696 
 697      if (info != NULL) {
 698          (*env)-&gt;SetFloatField(env, metrics, sunFontIDs.xFID, info-&gt;advanceX);
 699          (*env)-&gt;SetFloatField(env, metrics, sunFontIDs.yFID, info-&gt;advanceY);
 700          free(info);
 701      } else {
 702          (*env)-&gt;SetFloatField(env, metrics, sunFontIDs.xFID, 0.0f);
 703          (*env)-&gt;SetFloatField(env, metrics, sunFontIDs.yFID, 0.0f);
 704      }
 705 }
 706 
 707 
 708 static GlyphInfo* getNullGlyphImage() {
 709     GlyphInfo *glyphInfo =  (GlyphInfo*) calloc(1, sizeof(GlyphInfo));
 710     return glyphInfo;
 711 }
 712 
 713 static void CopyBW2Grey8(const void* srcImage, int srcRowBytes,
 714                          void* dstImage, int dstRowBytes,
 715                          int width, int height) {
 716     const UInt8* srcRow = (UInt8*)srcImage;
 717     UInt8* dstRow = (UInt8*)dstImage;
 718     int wholeByteCount = width &gt;&gt; 3;
 719     int remainingBitsCount = width &amp; 7;
 720     int i, j;
 721 
 722     while (height--) {
 723         const UInt8* src8 = srcRow;
 724         UInt8* dstByte = dstRow;
 725         unsigned srcValue;
 726 
 727         srcRow += srcRowBytes;
 728         dstRow += dstRowBytes;
 729 
 730         for (i = 0; i &lt; wholeByteCount; i++) {
 731             srcValue = *src8++;
 732             for (j = 0; j &lt; 8; j++) {
 733                 *dstByte++ = (srcValue &amp; 0x80) ? 0xFF : 0;
 734                 srcValue &lt;&lt;= 1;
 735             }
 736         }
 737         if (remainingBitsCount) {
 738             srcValue = *src8;
 739             for (j = 0; j &lt; remainingBitsCount; j++) {
 740                 *dstByte++ = (srcValue &amp; 0x80) ? 0xFF : 0;
 741                 srcValue &lt;&lt;= 1;
 742             }
 743         }
 744     }
 745 }
 746 
 747 #define Grey4ToAlpha255(value) (((value) &lt;&lt; 4) + ((value) &gt;&gt; 3))
 748 
 749 static void CopyGrey4ToGrey8(const void* srcImage, int srcRowBytes,
 750                 void* dstImage, int dstRowBytes, int width, int height) {
 751      const UInt8* srcRow = (UInt8*) srcImage;
 752      UInt8* dstRow = (UInt8*) dstImage;
 753      int i;
 754 
 755      while (height--) {
 756          const UInt8* src8 = srcRow;
 757          UInt8* dstByte = dstRow;
 758          unsigned srcValue;
 759 
 760          srcRow += srcRowBytes;
 761          dstRow += dstRowBytes;
 762 
 763          for (i = 0; i &lt; width; i++) {
 764              srcValue = *src8++;
 765              *dstByte++ = Grey4ToAlpha255(srcValue &amp; 0x0f);
 766              *dstByte++ = Grey4ToAlpha255(srcValue &gt;&gt; 4);
 767          }
 768      }
 769 }
 770 
 771 /* We need it because FT rows are often padded to 4 byte boundaries
 772     and our internal format is not padded */
 773 static void CopyFTSubpixelToSubpixel(const void* srcImage, int srcRowBytes,
 774                                      void* dstImage, int dstRowBytes,
 775                                      int width, int height) {
 776     unsigned char *srcRow = (unsigned char *) srcImage;
 777     unsigned char *dstRow = (unsigned char *) dstImage;
 778 
 779     while (height--) {
 780         memcpy(dstRow, srcRow, width);
 781         srcRow += srcRowBytes;
 782         dstRow += dstRowBytes;
 783     }
 784 }
 785 
 786 /* We need it because FT rows are often padded to 4 byte boundaries
 787    and our internal format is not padded */
 788 static void CopyFTSubpixelVToSubpixel(const void* srcImage, int srcRowBytes,
 789                                       void* dstImage, int dstRowBytes,
 790                                       int width, int height) {
 791     unsigned char *srcRow = (unsigned char *) srcImage, *srcByte;
 792     unsigned char *dstRow = (unsigned char *) dstImage, *dstByte;
 793     int i;
 794 
 795     while (height &gt; 0) {
 796         srcByte = srcRow;
 797         dstByte = dstRow;
 798         for (i = 0; i &lt; width; i++) {
 799             *dstByte++ = *srcByte;
 800             *dstByte++ = *(srcByte + srcRowBytes);
 801             *dstByte++ = *(srcByte + 2*srcRowBytes);
 802             srcByte++;
 803         }
 804         srcRow += 3*srcRowBytes;
 805         dstRow += dstRowBytes;
 806         height -= 3;
 807     }
 808 }
 809 
 810 
 811 /* JDK does not use glyph images for fonts with a
 812  * pixel size &gt; 100 (see THRESHOLD in OutlineTextRenderer.java)
 813  * so if the glyph bitmap image dimension is &gt; 1024 pixels,
 814  * something is up.
 815  */
 816 #define MAX_GLYPH_DIM 1024
 817 
 818 /*
 819  * Class:     sun_font_FreetypeFontScaler
 820  * Method:    getGlyphImageNative
 821  * Signature: (Lsun/font/Font2D;JI)J
 822  */
 823 JNIEXPORT jlong JNICALL
 824 Java_sun_font_FreetypeFontScaler_getGlyphImageNative(
 825         JNIEnv *env, jobject scaler, jobject font2D,
 826         jlong pScalerContext, jlong pScaler, jint glyphCode) {
 827 
 828     return getGlyphImageNativeInternal(
 829         env, scaler, font2D,
 830         pScalerContext, pScaler, glyphCode, JNI_TRUE);
 831 }
 832 
 833 static jlong
 834      getGlyphImageNativeInternal(
 835         JNIEnv *env, jobject scaler, jobject font2D,
 836         jlong pScalerContext, jlong pScaler, jint glyphCode,
 837         jboolean renderImage) {
 838 
 839     int error, imageSize;
 840     UInt16 width, height;
 841     GlyphInfo *glyphInfo;
 842     int renderFlags = FT_LOAD_DEFAULT, target;
 843     FT_GlyphSlot ftglyph;
 844 
 845     FTScalerContext* context =
 846         (FTScalerContext*) jlong_to_ptr(pScalerContext);
 847     FTScalerInfo *scalerInfo =
 848              (FTScalerInfo*) jlong_to_ptr(pScaler);
 849 
 850     if (isNullScalerContext(context) || scalerInfo == NULL) {
 851         return ptr_to_jlong(getNullGlyphImage());
 852     }
 853 
 854     error = setupFTContext(env, font2D, scalerInfo, context);
 855     if (error) {
 856         invalidateJavaScaler(env, scaler, scalerInfo);
 857         return ptr_to_jlong(getNullGlyphImage());
 858     }
 859 
 860     /*
 861      * When using Fractional metrics (linearly scaling advances) and
 862      * greyscale antialiasing, disable hinting so that the glyph shapes
 863      * are constant as size increases. This is good for animation as well
 864      * as being compatible with what happened in earlier JDK versions
 865      * which did not use freetype.
 866      */
 867     if (context-&gt;aaType == TEXT_AA_ON &amp;&amp; context-&gt;fmType == TEXT_FM_ON) {
 868          renderFlags |= FT_LOAD_NO_HINTING;
 869      }
 870 
 871     if (!context-&gt;useSbits) {
 872         renderFlags |= FT_LOAD_NO_BITMAP;
 873     }
 874 
 875     /* NB: in case of non identity transform
 876      we might also prefer to disable transform before hinting,
 877      and apply it explicitly after hinting is performed.
 878      Or we can disable hinting. */
 879 
 880     /* select appropriate hinting mode */
 881     if (context-&gt;aaType == TEXT_AA_OFF) {
 882         target = FT_LOAD_TARGET_MONO;
 883     } else if (context-&gt;aaType == TEXT_AA_ON) {
 884         target = FT_LOAD_TARGET_NORMAL;
 885     } else if (context-&gt;aaType == TEXT_AA_LCD_HRGB ||
 886                context-&gt;aaType == TEXT_AA_LCD_HBGR) {
 887         target = FT_LOAD_TARGET_LCD;
 888     } else {
 889         target = FT_LOAD_TARGET_LCD_V;
 890     }
 891     renderFlags |= target;
 892 
 893     error = FT_Load_Glyph(scalerInfo-&gt;face, glyphCode, renderFlags);
 894     if (error) {
 895         //do not destroy scaler yet.
 896         //this can be problem of particular context (e.g. with bad transform)
 897         return ptr_to_jlong(getNullGlyphImage());
 898     }
 899 
 900     ftglyph = scalerInfo-&gt;face-&gt;glyph;
 901 
 902     /* apply styles */
 903     if (context-&gt;doBold) { /* if bold style */
 904         FT_GlyphSlot_Embolden(ftglyph);
 905     }
 906 
 907     /* generate bitmap if it is not done yet
 908      e.g. if algorithmic styling is performed and style was added to outline */
 909     if (renderImage &amp;&amp; (ftglyph-&gt;format == FT_GLYPH_FORMAT_OUTLINE)) {
 910         FT_BBox bbox;
 911         FT_Outline_Get_CBox(&amp;(ftglyph-&gt;outline), &amp;bbox);
 912         int w = (int)((bbox.xMax&gt;&gt;6)-(bbox.xMin&gt;&gt;6));
 913         int h = (int)((bbox.yMax&gt;&gt;6)-(bbox.yMin&gt;&gt;6));
 914         if (w &gt; MAX_GLYPH_DIM || h &gt; MAX_GLYPH_DIM) {
 915             glyphInfo = getNullGlyphImage();
 916             return ptr_to_jlong(glyphInfo);
 917         }
 918         error = FT_Render_Glyph(ftglyph, FT_LOAD_TARGET_MODE(target));
 919         if (error != 0) {
 920             return ptr_to_jlong(getNullGlyphImage());
 921         }
 922     }
 923 
 924     if (renderImage) {
 925         width  = (UInt16) ftglyph-&gt;bitmap.width;
 926         height = (UInt16) ftglyph-&gt;bitmap.rows;
 927             if (width &gt; MAX_GLYPH_DIM || height &gt; MAX_GLYPH_DIM) {
 928               glyphInfo = getNullGlyphImage();
 929               return ptr_to_jlong(glyphInfo);
 930             }
 931      } else {
 932         width = 0;
 933         height = 0;
 934      }
 935 
 936 
 937     imageSize = width*height;
 938     glyphInfo = (GlyphInfo*) malloc(sizeof(GlyphInfo) + imageSize);
 939     if (glyphInfo == NULL) {
 940         glyphInfo = getNullGlyphImage();
 941         return ptr_to_jlong(glyphInfo);
 942     }
 943     glyphInfo-&gt;cellInfo  = NULL;
 944     glyphInfo-&gt;managed   = UNMANAGED_GLYPH;
 945     glyphInfo-&gt;rowBytes  = width;
 946     glyphInfo-&gt;width     = width;
 947     glyphInfo-&gt;height    = height;
 948 
 949     if (renderImage) {
 950         glyphInfo-&gt;topLeftX  = (float)  ftglyph-&gt;bitmap_left;
 951         glyphInfo-&gt;topLeftY  = (float) -ftglyph-&gt;bitmap_top;
 952 
 953         if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD) {
 954             glyphInfo-&gt;width = width/3;
 955         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {
 956             glyphInfo-&gt;height = glyphInfo-&gt;height/3;
 957         }
 958     }
 959 
 960     if (context-&gt;fmType == TEXT_FM_ON) {
 961         float advh = FTFixedToFloat(ftglyph-&gt;linearHoriAdvance);
 962         glyphInfo-&gt;advanceX =
 963             (float) (advh * FTFixedToFloat(context-&gt;transform.xx));
 964         glyphInfo-&gt;advanceY =
 965             (float) - (advh * FTFixedToFloat(context-&gt;transform.yx));
 966     } else {
 967         if (!ftglyph-&gt;advance.y) {
 968             glyphInfo-&gt;advanceX =
 969                 (float) FT26Dot6ToInt(ftglyph-&gt;advance.x);
 970             glyphInfo-&gt;advanceY = 0;
 971         } else if (!ftglyph-&gt;advance.x) {
 972             glyphInfo-&gt;advanceX = 0;
 973             glyphInfo-&gt;advanceY =
 974                 (float) FT26Dot6ToInt(-ftglyph-&gt;advance.y);
 975         } else {
 976             glyphInfo-&gt;advanceX = FT26Dot6ToFloat(ftglyph-&gt;advance.x);
 977             glyphInfo-&gt;advanceY = FT26Dot6ToFloat(-ftglyph-&gt;advance.y);
 978         }
 979     }
 980 
 981     if (imageSize == 0) {
 982         glyphInfo-&gt;image = NULL;
 983     } else {
 984         glyphInfo-&gt;image = (unsigned char*) glyphInfo + sizeof(GlyphInfo);
 985         //convert result to output format
 986         //output format is either 3 bytes per pixel (for subpixel modes)
 987         // or 1 byte per pixel for AA and B&amp;W
 988         if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_MONO) {
 989             /* convert from 8 pixels per byte to 1 byte per pixel */
 990             CopyBW2Grey8(ftglyph-&gt;bitmap.buffer,
 991                          ftglyph-&gt;bitmap.pitch,
 992                          (void *) glyphInfo-&gt;image,
 993                          width,
 994                          width,
 995                          height);
 996         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY) {
 997             /* byte per pixel to byte per pixel =&gt; just copy */
 998             memcpy(glyphInfo-&gt;image, ftglyph-&gt;bitmap.buffer, imageSize);
 999         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY4) {
1000             /* 4 bits per pixel to byte per pixel */
1001             CopyGrey4ToGrey8(ftglyph-&gt;bitmap.buffer,
1002                              ftglyph-&gt;bitmap.pitch,
1003                              (void *) glyphInfo-&gt;image,
1004                              width,
1005                              width,
1006                              height);
1007         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD) {
1008             /* 3 bytes per pixel to 3 bytes per pixel */
1009             CopyFTSubpixelToSubpixel(ftglyph-&gt;bitmap.buffer,
1010                                      ftglyph-&gt;bitmap.pitch,
1011                                      (void *) glyphInfo-&gt;image,
1012                                      width,
1013                                      width,
1014                                      height);
1015         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {
1016             /* 3 bytes per pixel to 3 bytes per pixel */
1017             CopyFTSubpixelVToSubpixel(ftglyph-&gt;bitmap.buffer,
1018                                       ftglyph-&gt;bitmap.pitch,
1019                                       (void *) glyphInfo-&gt;image,
1020                                       width*3,
1021                                       width,
1022                                       height);
1023             glyphInfo-&gt;rowBytes *=3;
1024         } else {
1025             free(glyphInfo);
1026             glyphInfo = getNullGlyphImage();
1027         }
1028     }
1029 
1030     return ptr_to_jlong(glyphInfo);
1031 }
1032 
1033 /*
1034  * Class:     sun_font_FreetypeFontScaler
1035  * Method:    disposeNativeScaler
1036  * Signature: (J)V
1037  */
1038 JNIEXPORT void JNICALL
1039 Java_sun_font_FreetypeFontScaler_disposeNativeScaler(
1040         JNIEnv *env, jobject scaler, jobject font2D, jlong pScaler) {
1041     FTScalerInfo* scalerInfo = (FTScalerInfo *) jlong_to_ptr(pScaler);
1042 
1043     /* Freetype functions *may* cause callback to java
1044        that can use cached values. Make sure our cache is up to date.
1045        NB: scaler context is not important at this point, can use NULL. */
1046     int errCode = setupFTContext(env, font2D, scalerInfo, NULL);
1047     if (errCode) {
1048         return;
1049     }
1050 
1051     freeNativeResources(env, scalerInfo);
1052 }
1053 
1054 /*
1055  * Class:     sun_font_FreetypeFontScaler
1056  * Method:    getNumGlyphsNative
1057  * Signature: ()I
1058  */
1059 JNIEXPORT jint JNICALL
1060 Java_sun_font_FreetypeFontScaler_getNumGlyphsNative(
1061         JNIEnv *env, jobject scaler, jlong pScaler) {
1062     FTScalerInfo* scalerInfo = (FTScalerInfo *) jlong_to_ptr(pScaler);
1063 
1064     if (scalerInfo == NULL || scalerInfo-&gt;face == NULL) { /* bad/null scaler */
1065         /* null scaler can render 1 glyph - &quot;missing glyph&quot; with code 0
1066            (all glyph codes requested by user are mapped to code 0 at
1067            validation step) */
1068         invalidateJavaScaler(env, scaler, scalerInfo);
1069         return (jint) 1;
1070     }
1071 
1072     return (jint) scalerInfo-&gt;face-&gt;num_glyphs;
1073 }
1074 
1075 /*
1076  * Class:     sun_font_FreetypeFontScaler
1077  * Method:    getMissingGlyphCodeNative
1078  * Signature: ()I
1079  */
1080 JNIEXPORT jint JNICALL
1081 Java_sun_font_FreetypeFontScaler_getMissingGlyphCodeNative(
1082         JNIEnv *env, jobject scaler, jlong pScaler) {
1083 
1084     /* Is it always 0 for freetype? */
1085     return 0;
1086 }
1087 
1088 /*
1089  * Class:     sun_font_FreetypeFontScaler
1090  * Method:    getGlyphCodeNative
1091  * Signature: (C)I
1092  */
1093 JNIEXPORT jint JNICALL
1094 Java_sun_font_FreetypeFontScaler_getGlyphCodeNative(
1095         JNIEnv *env, jobject scaler,
1096         jobject font2D, jlong pScaler, jchar charCode) {
1097 
1098     FTScalerInfo* scalerInfo = (FTScalerInfo *) jlong_to_ptr(pScaler);
1099     int errCode;
1100 
1101     if (scaler == NULL || scalerInfo-&gt;face == NULL) { /* bad/null scaler */
1102         invalidateJavaScaler(env, scaler, scalerInfo);
1103         return 0;
1104     }
1105 
1106     /* Freetype functions *may* cause callback to java
1107        that can use cached values. Make sure our cache is up to date.
1108        Scaler context is not important here, can use NULL. */
1109     errCode = setupFTContext(env, font2D, scalerInfo, NULL);
1110     if (errCode) {
1111         return 0;
1112     }
1113 
1114     return FT_Get_Char_Index(scalerInfo-&gt;face, charCode);
1115 }
1116 
1117 
1118 #define FloatToF26Dot6(x) ((unsigned int) ((x)*64))
1119 
1120 static FT_Outline* getFTOutline(JNIEnv* env, jobject font2D,
1121         FTScalerContext *context, FTScalerInfo* scalerInfo,
1122         jint glyphCode, jfloat xpos, jfloat ypos) {
1123     int renderFlags;
1124     FT_Error error;
1125     FT_GlyphSlot ftglyph;
1126 
1127     if (glyphCode &gt;= INVISIBLE_GLYPHS ||
1128             isNullScalerContext(context) || scalerInfo == NULL) {
1129         return NULL;
1130     }
1131 
1132     error = setupFTContext(env, font2D, scalerInfo, context);
1133     if (error) {
1134         return NULL;
1135     }
1136 
1137     renderFlags = FT_LOAD_NO_HINTING | FT_LOAD_NO_BITMAP;
1138 
1139     error = FT_Load_Glyph(scalerInfo-&gt;face, glyphCode, renderFlags);
1140     if (error) {
1141         return NULL;
1142     }
1143 
1144     ftglyph = scalerInfo-&gt;face-&gt;glyph;
1145 
1146     /* apply styles */
1147     if (context-&gt;doBold) { /* if bold style */
1148         FT_GlyphSlot_Embolden(ftglyph);
1149     }
1150 
1151     FT_Outline_Translate(&amp;ftglyph-&gt;outline,
1152                          FloatToF26Dot6(xpos),
1153                          -FloatToF26Dot6(ypos));
1154 
1155     return &amp;ftglyph-&gt;outline;
1156 }
1157 
1158 #define F26Dot6ToFloat(n) (((float)(n))/((float) 64))
1159 
1160 /* Types of GeneralPath segments.
1161    TODO: pull constants from other place? */
1162 
1163 #define SEG_UNKNOWN -1
1164 #define SEG_MOVETO   0
1165 #define SEG_LINETO   1
1166 #define SEG_QUADTO   2
1167 #define SEG_CUBICTO  3
1168 #define SEG_CLOSE    4
1169 
1170 #define WIND_NON_ZERO 0
1171 #define WIND_EVEN_ODD 1
1172 
1173 /* Placeholder to accumulate GeneralPath data */
1174 typedef struct {
1175     jint numTypes;
1176     jint numCoords;
1177     jint lenTypes;
1178     jint lenCoords;
1179     jint wr;
1180     jbyte* pointTypes;
1181     jfloat* pointCoords;
1182 } GPData;
1183 
1184 /* returns 0 on failure */
1185 static int allocateSpaceForGP(GPData* gpdata, int npoints, int ncontours) {
1186     int maxTypes, maxCoords;
1187 
1188     /* we may have up to N intermediate points per contour
1189        (and for each point can actually cause new curve to be generated)
1190        In addition we can also have 2 extra point per outline.
1191      */
1192     maxTypes  = 2*npoints  + 2*ncontours;
1193     maxCoords = 4*(npoints + 2*ncontours); //we may need to insert
1194                                            //up to n-1 intermediate points
1195 
1196     /* first usage - allocate space and intialize all fields */
1197     if (gpdata-&gt;pointTypes == NULL || gpdata-&gt;pointCoords == NULL) {
1198         gpdata-&gt;lenTypes  = maxTypes;
1199         gpdata-&gt;lenCoords = maxCoords;
1200         gpdata-&gt;pointTypes  = (jbyte*)
1201              malloc(gpdata-&gt;lenTypes*sizeof(jbyte));
1202         gpdata-&gt;pointCoords = (jfloat*)
1203              malloc(gpdata-&gt;lenCoords*sizeof(jfloat));
1204         gpdata-&gt;numTypes = 0;
1205         gpdata-&gt;numCoords = 0;
1206         gpdata-&gt;wr = WIND_NON_ZERO; /* By default, outlines are filled
1207                                        using the non-zero winding rule. */
1208     } else {
1209         /* do we have enough space? */
1210         if (gpdata-&gt;lenTypes - gpdata-&gt;numTypes &lt; maxTypes) {
1211             gpdata-&gt;lenTypes  += maxTypes;
1212             gpdata-&gt;pointTypes  = (jbyte*)
1213               realloc(gpdata-&gt;pointTypes, gpdata-&gt;lenTypes*sizeof(jbyte));
1214         }
1215 
1216         if (gpdata-&gt;lenCoords - gpdata-&gt;numCoords &lt; maxCoords) {
1217             gpdata-&gt;lenCoords += maxCoords;
1218             gpdata-&gt;pointCoords = (jfloat*)
1219               realloc(gpdata-&gt;pointCoords, gpdata-&gt;lenCoords*sizeof(jfloat));
1220         }
1221     }
1222 
1223     /* failure if any of mallocs failed */
1224     if (gpdata-&gt;pointTypes == NULL ||  gpdata-&gt;pointCoords == NULL)
1225         return 0;
1226     else
1227         return 1;
1228 }
1229 
1230 static void addSeg(GPData *gp, jbyte type) {
1231     gp-&gt;pointTypes[gp-&gt;numTypes++] = type;
1232 }
1233 
1234 static void addCoords(GPData *gp, FT_Vector *p) {
1235     gp-&gt;pointCoords[gp-&gt;numCoords++] =  F26Dot6ToFloat(p-&gt;x);
1236     gp-&gt;pointCoords[gp-&gt;numCoords++] = -F26Dot6ToFloat(p-&gt;y);
1237 }
1238 
1239 static int moveTo(FT_Vector *to, GPData *gp) {
1240     if (gp-&gt;numCoords)
1241         addSeg(gp, SEG_CLOSE);
1242     addCoords(gp, to);
1243     addSeg(gp, SEG_MOVETO);
1244     return FT_Err_Ok;
1245 }
1246 
1247 static int lineTo(FT_Vector *to, GPData *gp) {
1248     addCoords(gp, to);
1249     addSeg(gp, SEG_LINETO);
1250     return FT_Err_Ok;
1251 }
1252 
1253 static int conicTo(FT_Vector *control, FT_Vector *to, GPData *gp) {
1254     addCoords(gp, control);
1255     addCoords(gp, to);
1256     addSeg(gp, SEG_QUADTO);
1257     return FT_Err_Ok;
1258 }
1259 
1260 static int cubicTo(FT_Vector *control1,
1261                    FT_Vector *control2,
1262                    FT_Vector *to,
1263                    GPData    *gp) {
1264     addCoords(gp, control1);
1265     addCoords(gp, control2);
1266     addCoords(gp, to);
1267     addSeg(gp, SEG_CUBICTO);
1268     return FT_Err_Ok;
1269 }
1270 
1271 static void addToGP(GPData* gpdata, FT_Outline*outline) {
1272     static const FT_Outline_Funcs outline_funcs = {
1273         (FT_Outline_MoveToFunc) moveTo,
1274         (FT_Outline_LineToFunc) lineTo,
1275         (FT_Outline_ConicToFunc) conicTo,
1276         (FT_Outline_CubicToFunc) cubicTo,
1277         0, /* shift */
1278         0, /* delta */
1279     };
1280 
1281     FT_Outline_Decompose(outline, &amp;outline_funcs, gpdata);
1282     if (gpdata-&gt;numCoords)
1283         addSeg(gpdata, SEG_CLOSE);
1284 
1285     /* If set to 1, the outline will be filled using the even-odd fill rule */
1286     if (outline-&gt;flags &amp; FT_OUTLINE_EVEN_ODD_FILL) {
1287         gpdata-&gt;wr = WIND_EVEN_ODD;
1288     }
1289 }
1290 
1291 static void freeGP(GPData* gpdata) {
1292     if (gpdata-&gt;pointCoords != NULL) {
1293         free(gpdata-&gt;pointCoords);
1294         gpdata-&gt;pointCoords = NULL;
1295         gpdata-&gt;numCoords = 0;
1296         gpdata-&gt;lenCoords = 0;
1297     }
1298     if (gpdata-&gt;pointTypes != NULL) {
1299         free(gpdata-&gt;pointTypes);
1300         gpdata-&gt;pointTypes = NULL;
1301         gpdata-&gt;numTypes = 0;
1302         gpdata-&gt;lenTypes = 0;
1303     }
1304 }
1305 
1306 static jobject getGlyphGeneralPath(JNIEnv* env, jobject font2D,
1307         FTScalerContext *context, FTScalerInfo *scalerInfo,
1308         jint glyphCode, jfloat xpos, jfloat ypos) {
1309 
1310     FT_Outline* outline;
1311     jobject gp = NULL;
1312     jbyteArray types;
1313     jfloatArray coords;
1314     GPData gpdata;
1315 
1316     outline = getFTOutline(env, font2D, context, scalerInfo,
1317                            glyphCode, xpos, ypos);
1318 
1319     if (outline == NULL || outline-&gt;n_points == 0) {
1320         return gp;
1321     }
1322 
1323     gpdata.pointTypes  = NULL;
1324     gpdata.pointCoords = NULL;
1325     if (!allocateSpaceForGP(&amp;gpdata, outline-&gt;n_points, outline-&gt;n_contours)) {
1326         return gp;
1327     }
1328 
1329     addToGP(&amp;gpdata, outline);
1330 
1331     types  = (*env)-&gt;NewByteArray(env, gpdata.numTypes);
1332     coords = (*env)-&gt;NewFloatArray(env, gpdata.numCoords);
1333 
1334     if (types &amp;&amp; coords) {
1335         (*env)-&gt;SetByteArrayRegion(env, types, 0,
1336                                    gpdata.numTypes,
1337                                    gpdata.pointTypes);
1338         (*env)-&gt;SetFloatArrayRegion(env, coords, 0,
1339                                     gpdata.numCoords,
1340                                     gpdata.pointCoords);
1341         gp = (*env)-&gt;NewObject(env,
1342                                sunFontIDs.gpClass,
1343                                sunFontIDs.gpCtr,
1344                                gpdata.wr,
1345                                types,
1346                                gpdata.numTypes,
1347                                coords,
1348                                gpdata.numCoords);
1349     }
1350 
1351     freeGP(&amp;gpdata);
1352 
1353     return gp;
1354 }
1355 
1356 /*
1357  * Class:     sun_font_FreetypeFontScaler
1358  * Method:    getGlyphOutlineNative
1359  * Signature: (Lsun/font/Font2D;JIFF)Ljava/awt/geom/GeneralPath;
1360  */
1361 JNIEXPORT jobject JNICALL
1362 Java_sun_font_FreetypeFontScaler_getGlyphOutlineNative(
1363       JNIEnv *env, jobject scaler, jobject font2D, jlong pScalerContext,
1364       jlong pScaler, jint glyphCode, jfloat xpos, jfloat ypos) {
1365 
1366     FTScalerContext *context =
1367          (FTScalerContext*) jlong_to_ptr(pScalerContext);
1368     FTScalerInfo* scalerInfo = (FTScalerInfo *) jlong_to_ptr(pScaler);
1369 
1370     jobject gp = getGlyphGeneralPath(env,
1371                                font2D,
1372                                context,
1373                                scalerInfo,
1374                                glyphCode,
1375                                xpos,
1376                                ypos);
1377     if (gp == NULL) { /* can be legal */
1378         gp = (*env)-&gt;NewObject(env,
1379                                sunFontIDs.gpClass,
1380                                sunFontIDs.gpCtrEmpty);
1381     }
1382     return gp;
1383 }
1384 
1385 /*
1386  * Class:     sun_font_FreetypeFontScaler
1387  * Method:    getGlyphOutlineBoundsNative
1388  * Signature: (Lsun/font/Font2D;JI)Ljava/awt/geom/Rectangle2D/Float;
1389  */
1390 JNIEXPORT jobject JNICALL
1391 Java_sun_font_FreetypeFontScaler_getGlyphOutlineBoundsNative(
1392         JNIEnv *env, jobject scaler, jobject font2D,
1393         jlong pScalerContext, jlong pScaler, jint glyphCode) {
1394 
1395     FT_Outline *outline;
1396     FT_BBox bbox;
1397     int error;
1398     jobject bounds;
1399 
1400     FTScalerContext *context =
1401          (FTScalerContext*) jlong_to_ptr(pScalerContext);
1402     FTScalerInfo* scalerInfo = (FTScalerInfo *) jlong_to_ptr(pScaler);
1403 
1404     outline = getFTOutline(env, font2D, context, scalerInfo, glyphCode, 0, 0);
1405     if (outline == NULL || outline-&gt;n_points == 0) {
1406         /* it is legal case, e.g. invisible glyph */
1407         bounds = (*env)-&gt;NewObject(env,
1408                                  sunFontIDs.rect2DFloatClass,
1409                                  sunFontIDs.rect2DFloatCtr);
1410         return bounds;
1411     }
1412 
1413     error = FT_Outline_Get_BBox(outline, &amp;bbox);
1414 
1415     //convert bbox
1416     if (error || bbox.xMin &gt;= bbox.xMax || bbox.yMin &gt;= bbox.yMax) {
1417         bounds = (*env)-&gt;NewObject(env,
1418                                    sunFontIDs.rect2DFloatClass,
1419                                    sunFontIDs.rect2DFloatCtr);
1420     } else {
1421         bounds = (*env)-&gt;NewObject(env,
1422                                    sunFontIDs.rect2DFloatClass,
1423                                    sunFontIDs.rect2DFloatCtr4,
1424                                    F26Dot6ToFloat(bbox.xMin),
1425                                    F26Dot6ToFloat(-bbox.yMax),
1426                                    F26Dot6ToFloat(bbox.xMax-bbox.xMin),
1427                                    F26Dot6ToFloat(bbox.yMax-bbox.yMin));
1428     }
1429 
1430     return bounds;
1431 }
1432 
1433 /*
1434  * Class:     sun_font_FreetypeFontScaler
1435  * Method:    getGlyphVectorOutlineNative
1436  * Signature: (Lsun/font/Font2D;J[IIFF)Ljava/awt/geom/GeneralPath;
1437  */
1438 JNIEXPORT jobject
1439 JNICALL
1440 Java_sun_font_FreetypeFontScaler_getGlyphVectorOutlineNative(
1441         JNIEnv *env, jobject scaler, jobject font2D,
1442         jlong pScalerContext, jlong pScaler,
1443         jintArray glyphArray, jint numGlyphs, jfloat xpos, jfloat ypos) {
1444 
1445     FT_Outline* outline;
1446     jobject gp = NULL;
1447     jbyteArray types;
1448     jfloatArray coords;
1449     GPData gpdata;
1450     int i;
1451     jint *glyphs;
1452 
1453     FTScalerContext *context =
1454          (FTScalerContext*) jlong_to_ptr(pScalerContext);
1455     FTScalerInfo *scalerInfo =
1456              (FTScalerInfo*) jlong_to_ptr(pScaler);
1457 
1458     glyphs = NULL;
1459     if (numGlyphs &gt; 0 &amp;&amp; 0xffffffffu / sizeof(jint) &gt;= numGlyphs) {
1460         glyphs = (jint*) malloc(numGlyphs*sizeof(jint));
1461     }
1462     if (glyphs == NULL) {
1463         // We reach here if:
1464         // 1. numGlyphs &lt;= 0,
1465         // 2. overflow check failed, or
1466         // 3. malloc failed.
1467         gp = (*env)-&gt;NewObject(env, sunFontIDs.gpClass, sunFontIDs.gpCtrEmpty);
1468         return gp;
1469     }
1470 
1471     (*env)-&gt;GetIntArrayRegion(env, glyphArray, 0, numGlyphs, glyphs);
1472 
1473     gpdata.numCoords = 0;
1474     for (i=0; i&lt;numGlyphs;i++) {
1475         if (glyphs[i] &gt;= INVISIBLE_GLYPHS) {
1476             continue;
1477         }
1478         outline = getFTOutline(env,
1479                                font2D,
1480                                context,
1481                                scalerInfo,
1482                                glyphs[i],
1483                                xpos, ypos);
1484 
1485         if (outline == NULL || outline-&gt;n_points == 0) {
1486             continue;
1487         }
1488 
1489         gpdata.pointTypes  = NULL;
1490         gpdata.pointCoords = NULL;
1491         if (!allocateSpaceForGP(&amp;gpdata, outline-&gt;n_points,
1492                                 outline-&gt;n_contours)) {
1493             break;
1494         }
1495 
1496         addToGP(&amp;gpdata, outline);
1497     }
1498     free(glyphs);
1499 
1500     if (gpdata.numCoords != 0) {
1501       types = (*env)-&gt;NewByteArray(env, gpdata.numTypes);
1502       coords = (*env)-&gt;NewFloatArray(env, gpdata.numCoords);
1503 
1504       if (types &amp;&amp; coords) {
1505         (*env)-&gt;SetByteArrayRegion(env, types, 0,
1506                                    gpdata.numTypes, gpdata.pointTypes);
1507         (*env)-&gt;SetFloatArrayRegion(env, coords, 0,
1508                                     gpdata.numCoords, gpdata.pointCoords);
1509 
1510         gp=(*env)-&gt;NewObject(env,
1511                              sunFontIDs.gpClass,
1512                              sunFontIDs.gpCtr,
1513                              gpdata.wr,
1514                              types,
1515                              gpdata.numTypes,
1516                              coords,
1517                              gpdata.numCoords);
1518         return gp;
1519       }
1520     }
1521     return (*env)-&gt;NewObject(env, sunFontIDs.gpClass, sunFontIDs.gpCtrEmpty);
1522 }
1523 
1524 JNIEXPORT jlong JNICALL
1525 Java_sun_font_FreetypeFontScaler_getUnitsPerEMNative(
1526         JNIEnv *env, jobject scaler, jlong pScaler) {
1527 
1528     FTScalerInfo *s = (FTScalerInfo* ) jlong_to_ptr(pScaler);
1529 
1530     /* Freetype doc says:
1531      The number of font units per EM square for this face.
1532      This is typically 2048 for TrueType fonts, and 1000 for Type 1 fonts.
1533      Only relevant for scalable formats.
1534      However, layout engine might be not tested with anything but 2048.
1535 
1536      NB: test it! */
1537     if (s != NULL) {
1538         return s-&gt;face-&gt;units_per_EM;
1539     }
1540     return 2048;
1541 }
1542 
1543 /* This native method is called by the OpenType layout engine. */
1544 JNIEXPORT jobject JNICALL
1545 Java_sun_font_FreetypeFontScaler_getGlyphPointNative(
1546         JNIEnv *env, jobject scaler, jobject font2D, jlong pScalerContext,
1547         jlong pScaler, jint glyphCode, jint pointNumber) {
1548 
1549     FT_Outline* outline;
1550     jobject point = NULL;
1551     jfloat x=0, y=0;
1552     FTScalerContext *context =
1553          (FTScalerContext*) jlong_to_ptr(pScalerContext);
1554     FTScalerInfo *scalerInfo = (FTScalerInfo*) jlong_to_ptr(pScaler);
1555 
1556     outline = getFTOutline(env, font2D, context, scalerInfo, glyphCode, 0, 0);
1557 
1558     if (outline != NULL &amp;&amp; outline-&gt;n_points &gt; pointNumber) {
1559         x =  F26Dot6ToFloat(outline-&gt;points[pointNumber].x);
1560         y = -F26Dot6ToFloat(outline-&gt;points[pointNumber].y);
1561     }
1562 
1563     return (*env)-&gt;NewObject(env, sunFontIDs.pt2DFloatClass,
1564                              sunFontIDs.pt2DFloatCtr, x, y);
1565 }
    </pre>
  </body>
</html>
diff a/src/java.desktop/share/native/libfontmanager/freetypeScaler.c b/src/java.desktop/share/native/libfontmanager/freetypeScaler.c
--- a/src/java.desktop/share/native/libfontmanager/freetypeScaler.c
+++ b/src/java.desktop/share/native/libfontmanager/freetypeScaler.c
@@ -264,11 +264,11 @@
     int version = 35;
     const char* module = "truetype";
     const char* property = "interpreter-version";
 
     /* If some one is setting this, don't override it */
-    if (props != NULL && strstr(property, props)) {
+    if (props != NULL && strstr(props, property)) {
         return;
     }
     /*
      * FT_Property_Set was introduced in 2.4.11.
      * Some older supported Linux OSes may not include it so look
@@ -834,12 +834,13 @@
      getGlyphImageNativeInternal(
         JNIEnv *env, jobject scaler, jobject font2D,
         jlong pScalerContext, jlong pScaler, jint glyphCode,
         jboolean renderImage) {
 
+    static int PADBYTES = 3;
     int error, imageSize;
-    UInt16 width, height;
+    UInt16 width, height, rowBytes;
     GlyphInfo *glyphInfo;
     int renderFlags = FT_LOAD_DEFAULT, target;
     FT_GlyphSlot ftglyph;
 
     FTScalerContext* context =
@@ -921,39 +922,46 @@
         }
     }
 
     if (renderImage) {
         width  = (UInt16) ftglyph->bitmap.width;
+        rowBytes = width;
+        if (ftglyph->bitmap.pixel_mode == FT_PIXEL_MODE_LCD) {
+           rowBytes = PADBYTES + width + PADBYTES;
+        }
         height = (UInt16) ftglyph->bitmap.rows;
             if (width > MAX_GLYPH_DIM || height > MAX_GLYPH_DIM) {
               glyphInfo = getNullGlyphImage();
               return ptr_to_jlong(glyphInfo);
             }
      } else {
         width = 0;
+        rowBytes = 0;
         height = 0;
      }
 
 
-    imageSize = width*height;
-    glyphInfo = (GlyphInfo*) malloc(sizeof(GlyphInfo) + imageSize);
+    imageSize = rowBytes*height;
+    glyphInfo = (GlyphInfo*) calloc(sizeof(GlyphInfo) + imageSize, 1);
     if (glyphInfo == NULL) {
         glyphInfo = getNullGlyphImage();
         return ptr_to_jlong(glyphInfo);
     }
     glyphInfo->cellInfo  = NULL;
     glyphInfo->managed   = UNMANAGED_GLYPH;
-    glyphInfo->rowBytes  = width;
+    glyphInfo->rowBytes  = rowBytes;
     glyphInfo->width     = width;
     glyphInfo->height    = height;
 
     if (renderImage) {
         glyphInfo->topLeftX  = (float)  ftglyph->bitmap_left;
         glyphInfo->topLeftY  = (float) -ftglyph->bitmap_top;
 
-        if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD) {
+        if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD && width > 0) {
             glyphInfo->width = width/3;
+            glyphInfo->topLeftX -= 1;
+            glyphInfo->width += 1;
         } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {
             glyphInfo->height = glyphInfo->height/3;
         }
     }
 
@@ -1006,12 +1014,12 @@
                              height);
         } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD) {
             /* 3 bytes per pixel to 3 bytes per pixel */
             CopyFTSubpixelToSubpixel(ftglyph->bitmap.buffer,
                                      ftglyph->bitmap.pitch,
-                                     (void *) glyphInfo->image,
-                                     width,
+                                     (void *) (glyphInfo->image+PADBYTES),
+                                     rowBytes,
                                      width,
                                      height);
         } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {
             /* 3 bytes per pixel to 3 bytes per pixel */
             CopyFTSubpixelVToSubpixel(ftglyph->bitmap.buffer,

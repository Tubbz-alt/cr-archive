<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/freetypeScaler.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../classes/sun/font/TrueTypeFont.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../unix/classes/sun/awt/X11/XRobotPeer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/freetypeScaler.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 249         return numBytes;
 250     }
 251 }
 252 
 253 typedef FT_Error (*FT_Prop_Set_Func)(FT_Library library,
 254                                      const FT_String*  module_name,
 255                                      const FT_String*  property_name,
 256                                      const void*       value );
 257 
 258 /**
 259  * Prefer the older v35 freetype byte code interpreter.
 260  */
 261 static void setInterpreterVersion(FT_Library library) {
 262 
 263     char* props = getenv(&quot;FREETYPE_PROPERTIES&quot;);
 264     int version = 35;
 265     const char* module = &quot;truetype&quot;;
 266     const char* property = &quot;interpreter-version&quot;;
 267 
 268     /* If some one is setting this, don&#39;t override it */
<span class="line-modified"> 269     if (props != NULL &amp;&amp; strstr(property, props)) {</span>
 270         return;
 271     }
 272     /*
 273      * FT_Property_Set was introduced in 2.4.11.
 274      * Some older supported Linux OSes may not include it so look
 275      * this up dynamically.
 276      * And if its not available it doesn&#39;t matter, since the reason
 277      * we need it dates from 2.7.
 278      * On Windows &amp; Mac the library is always bundled so it is safe
 279      * to use directly in those cases.
 280      */
 281 #if defined(_WIN32) || defined(__APPLE__)
 282     FT_Property_Set(library, module, property, (void*)(&amp;version));
 283 #else
 284     void *lib = dlopen(&quot;libfreetype.so&quot;, RTLD_LOCAL|RTLD_LAZY);
 285     if (lib == NULL) {
 286         lib = dlopen(&quot;libfreetype.so.6&quot;, RTLD_LOCAL|RTLD_LAZY);
 287         if (lib == NULL) {
 288             return;
 289         }
</pre>
<hr />
<pre>
 819  * Class:     sun_font_FreetypeFontScaler
 820  * Method:    getGlyphImageNative
 821  * Signature: (Lsun/font/Font2D;JI)J
 822  */
 823 JNIEXPORT jlong JNICALL
 824 Java_sun_font_FreetypeFontScaler_getGlyphImageNative(
 825         JNIEnv *env, jobject scaler, jobject font2D,
 826         jlong pScalerContext, jlong pScaler, jint glyphCode) {
 827 
 828     return getGlyphImageNativeInternal(
 829         env, scaler, font2D,
 830         pScalerContext, pScaler, glyphCode, JNI_TRUE);
 831 }
 832 
 833 static jlong
 834      getGlyphImageNativeInternal(
 835         JNIEnv *env, jobject scaler, jobject font2D,
 836         jlong pScalerContext, jlong pScaler, jint glyphCode,
 837         jboolean renderImage) {
 838 

 839     int error, imageSize;
<span class="line-modified"> 840     UInt16 width, height;</span>
 841     GlyphInfo *glyphInfo;
 842     int renderFlags = FT_LOAD_DEFAULT, target;
 843     FT_GlyphSlot ftglyph;
 844 
 845     FTScalerContext* context =
 846         (FTScalerContext*) jlong_to_ptr(pScalerContext);
 847     FTScalerInfo *scalerInfo =
 848              (FTScalerInfo*) jlong_to_ptr(pScaler);
 849 
 850     if (isNullScalerContext(context) || scalerInfo == NULL) {
 851         return ptr_to_jlong(getNullGlyphImage());
 852     }
 853 
 854     error = setupFTContext(env, font2D, scalerInfo, context);
 855     if (error) {
 856         invalidateJavaScaler(env, scaler, scalerInfo);
 857         return ptr_to_jlong(getNullGlyphImage());
 858     }
 859 
 860     /*
</pre>
<hr />
<pre>
 906 
 907     /* generate bitmap if it is not done yet
 908      e.g. if algorithmic styling is performed and style was added to outline */
 909     if (renderImage &amp;&amp; (ftglyph-&gt;format == FT_GLYPH_FORMAT_OUTLINE)) {
 910         FT_BBox bbox;
 911         FT_Outline_Get_CBox(&amp;(ftglyph-&gt;outline), &amp;bbox);
 912         int w = (int)((bbox.xMax&gt;&gt;6)-(bbox.xMin&gt;&gt;6));
 913         int h = (int)((bbox.yMax&gt;&gt;6)-(bbox.yMin&gt;&gt;6));
 914         if (w &gt; MAX_GLYPH_DIM || h &gt; MAX_GLYPH_DIM) {
 915             glyphInfo = getNullGlyphImage();
 916             return ptr_to_jlong(glyphInfo);
 917         }
 918         error = FT_Render_Glyph(ftglyph, FT_LOAD_TARGET_MODE(target));
 919         if (error != 0) {
 920             return ptr_to_jlong(getNullGlyphImage());
 921         }
 922     }
 923 
 924     if (renderImage) {
 925         width  = (UInt16) ftglyph-&gt;bitmap.width;




 926         height = (UInt16) ftglyph-&gt;bitmap.rows;
 927             if (width &gt; MAX_GLYPH_DIM || height &gt; MAX_GLYPH_DIM) {
 928               glyphInfo = getNullGlyphImage();
 929               return ptr_to_jlong(glyphInfo);
 930             }
 931      } else {
 932         width = 0;

 933         height = 0;
 934      }
 935 
 936 
<span class="line-modified"> 937     imageSize = width*height;</span>
<span class="line-modified"> 938     glyphInfo = (GlyphInfo*) malloc(sizeof(GlyphInfo) + imageSize);</span>
 939     if (glyphInfo == NULL) {
 940         glyphInfo = getNullGlyphImage();
 941         return ptr_to_jlong(glyphInfo);
 942     }
 943     glyphInfo-&gt;cellInfo  = NULL;
 944     glyphInfo-&gt;managed   = UNMANAGED_GLYPH;
<span class="line-modified"> 945     glyphInfo-&gt;rowBytes  = width;</span>
 946     glyphInfo-&gt;width     = width;
 947     glyphInfo-&gt;height    = height;
 948 
 949     if (renderImage) {
 950         glyphInfo-&gt;topLeftX  = (float)  ftglyph-&gt;bitmap_left;
 951         glyphInfo-&gt;topLeftY  = (float) -ftglyph-&gt;bitmap_top;
 952 
<span class="line-modified"> 953         if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD) {</span>
 954             glyphInfo-&gt;width = width/3;


 955         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {
 956             glyphInfo-&gt;height = glyphInfo-&gt;height/3;
 957         }
 958     }
 959 
 960     if (context-&gt;fmType == TEXT_FM_ON) {
 961         float advh = FTFixedToFloat(ftglyph-&gt;linearHoriAdvance);
 962         glyphInfo-&gt;advanceX =
 963             (float) (advh * FTFixedToFloat(context-&gt;transform.xx));
 964         glyphInfo-&gt;advanceY =
 965             (float) - (advh * FTFixedToFloat(context-&gt;transform.yx));
 966     } else {
 967         if (!ftglyph-&gt;advance.y) {
 968             glyphInfo-&gt;advanceX =
 969                 (float) FT26Dot6ToInt(ftglyph-&gt;advance.x);
 970             glyphInfo-&gt;advanceY = 0;
 971         } else if (!ftglyph-&gt;advance.x) {
 972             glyphInfo-&gt;advanceX = 0;
 973             glyphInfo-&gt;advanceY =
 974                 (float) FT26Dot6ToInt(-ftglyph-&gt;advance.y);
</pre>
<hr />
<pre>
 991                          ftglyph-&gt;bitmap.pitch,
 992                          (void *) glyphInfo-&gt;image,
 993                          width,
 994                          width,
 995                          height);
 996         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY) {
 997             /* byte per pixel to byte per pixel =&gt; just copy */
 998             memcpy(glyphInfo-&gt;image, ftglyph-&gt;bitmap.buffer, imageSize);
 999         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY4) {
1000             /* 4 bits per pixel to byte per pixel */
1001             CopyGrey4ToGrey8(ftglyph-&gt;bitmap.buffer,
1002                              ftglyph-&gt;bitmap.pitch,
1003                              (void *) glyphInfo-&gt;image,
1004                              width,
1005                              width,
1006                              height);
1007         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD) {
1008             /* 3 bytes per pixel to 3 bytes per pixel */
1009             CopyFTSubpixelToSubpixel(ftglyph-&gt;bitmap.buffer,
1010                                      ftglyph-&gt;bitmap.pitch,
<span class="line-modified">1011                                      (void *) glyphInfo-&gt;image,</span>
<span class="line-modified">1012                                      width,</span>
1013                                      width,
1014                                      height);
1015         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {
1016             /* 3 bytes per pixel to 3 bytes per pixel */
1017             CopyFTSubpixelVToSubpixel(ftglyph-&gt;bitmap.buffer,
1018                                       ftglyph-&gt;bitmap.pitch,
1019                                       (void *) glyphInfo-&gt;image,
1020                                       width*3,
1021                                       width,
1022                                       height);
1023             glyphInfo-&gt;rowBytes *=3;
1024         } else {
1025             free(glyphInfo);
1026             glyphInfo = getNullGlyphImage();
1027         }
1028     }
1029 
1030     return ptr_to_jlong(glyphInfo);
1031 }
1032 
</pre>
</td>
<td>
<hr />
<pre>
 249         return numBytes;
 250     }
 251 }
 252 
 253 typedef FT_Error (*FT_Prop_Set_Func)(FT_Library library,
 254                                      const FT_String*  module_name,
 255                                      const FT_String*  property_name,
 256                                      const void*       value );
 257 
 258 /**
 259  * Prefer the older v35 freetype byte code interpreter.
 260  */
 261 static void setInterpreterVersion(FT_Library library) {
 262 
 263     char* props = getenv(&quot;FREETYPE_PROPERTIES&quot;);
 264     int version = 35;
 265     const char* module = &quot;truetype&quot;;
 266     const char* property = &quot;interpreter-version&quot;;
 267 
 268     /* If some one is setting this, don&#39;t override it */
<span class="line-modified"> 269     if (props != NULL &amp;&amp; strstr(props, property)) {</span>
 270         return;
 271     }
 272     /*
 273      * FT_Property_Set was introduced in 2.4.11.
 274      * Some older supported Linux OSes may not include it so look
 275      * this up dynamically.
 276      * And if its not available it doesn&#39;t matter, since the reason
 277      * we need it dates from 2.7.
 278      * On Windows &amp; Mac the library is always bundled so it is safe
 279      * to use directly in those cases.
 280      */
 281 #if defined(_WIN32) || defined(__APPLE__)
 282     FT_Property_Set(library, module, property, (void*)(&amp;version));
 283 #else
 284     void *lib = dlopen(&quot;libfreetype.so&quot;, RTLD_LOCAL|RTLD_LAZY);
 285     if (lib == NULL) {
 286         lib = dlopen(&quot;libfreetype.so.6&quot;, RTLD_LOCAL|RTLD_LAZY);
 287         if (lib == NULL) {
 288             return;
 289         }
</pre>
<hr />
<pre>
 819  * Class:     sun_font_FreetypeFontScaler
 820  * Method:    getGlyphImageNative
 821  * Signature: (Lsun/font/Font2D;JI)J
 822  */
 823 JNIEXPORT jlong JNICALL
 824 Java_sun_font_FreetypeFontScaler_getGlyphImageNative(
 825         JNIEnv *env, jobject scaler, jobject font2D,
 826         jlong pScalerContext, jlong pScaler, jint glyphCode) {
 827 
 828     return getGlyphImageNativeInternal(
 829         env, scaler, font2D,
 830         pScalerContext, pScaler, glyphCode, JNI_TRUE);
 831 }
 832 
 833 static jlong
 834      getGlyphImageNativeInternal(
 835         JNIEnv *env, jobject scaler, jobject font2D,
 836         jlong pScalerContext, jlong pScaler, jint glyphCode,
 837         jboolean renderImage) {
 838 
<span class="line-added"> 839     static int PADBYTES = 3;</span>
 840     int error, imageSize;
<span class="line-modified"> 841     UInt16 width, height, rowBytes;</span>
 842     GlyphInfo *glyphInfo;
 843     int renderFlags = FT_LOAD_DEFAULT, target;
 844     FT_GlyphSlot ftglyph;
 845 
 846     FTScalerContext* context =
 847         (FTScalerContext*) jlong_to_ptr(pScalerContext);
 848     FTScalerInfo *scalerInfo =
 849              (FTScalerInfo*) jlong_to_ptr(pScaler);
 850 
 851     if (isNullScalerContext(context) || scalerInfo == NULL) {
 852         return ptr_to_jlong(getNullGlyphImage());
 853     }
 854 
 855     error = setupFTContext(env, font2D, scalerInfo, context);
 856     if (error) {
 857         invalidateJavaScaler(env, scaler, scalerInfo);
 858         return ptr_to_jlong(getNullGlyphImage());
 859     }
 860 
 861     /*
</pre>
<hr />
<pre>
 907 
 908     /* generate bitmap if it is not done yet
 909      e.g. if algorithmic styling is performed and style was added to outline */
 910     if (renderImage &amp;&amp; (ftglyph-&gt;format == FT_GLYPH_FORMAT_OUTLINE)) {
 911         FT_BBox bbox;
 912         FT_Outline_Get_CBox(&amp;(ftglyph-&gt;outline), &amp;bbox);
 913         int w = (int)((bbox.xMax&gt;&gt;6)-(bbox.xMin&gt;&gt;6));
 914         int h = (int)((bbox.yMax&gt;&gt;6)-(bbox.yMin&gt;&gt;6));
 915         if (w &gt; MAX_GLYPH_DIM || h &gt; MAX_GLYPH_DIM) {
 916             glyphInfo = getNullGlyphImage();
 917             return ptr_to_jlong(glyphInfo);
 918         }
 919         error = FT_Render_Glyph(ftglyph, FT_LOAD_TARGET_MODE(target));
 920         if (error != 0) {
 921             return ptr_to_jlong(getNullGlyphImage());
 922         }
 923     }
 924 
 925     if (renderImage) {
 926         width  = (UInt16) ftglyph-&gt;bitmap.width;
<span class="line-added"> 927         rowBytes = width;</span>
<span class="line-added"> 928         if (ftglyph-&gt;bitmap.pixel_mode == FT_PIXEL_MODE_LCD) {</span>
<span class="line-added"> 929            rowBytes = PADBYTES + width + PADBYTES;</span>
<span class="line-added"> 930         }</span>
 931         height = (UInt16) ftglyph-&gt;bitmap.rows;
 932             if (width &gt; MAX_GLYPH_DIM || height &gt; MAX_GLYPH_DIM) {
 933               glyphInfo = getNullGlyphImage();
 934               return ptr_to_jlong(glyphInfo);
 935             }
 936      } else {
 937         width = 0;
<span class="line-added"> 938         rowBytes = 0;</span>
 939         height = 0;
 940      }
 941 
 942 
<span class="line-modified"> 943     imageSize = rowBytes*height;</span>
<span class="line-modified"> 944     glyphInfo = (GlyphInfo*) calloc(sizeof(GlyphInfo) + imageSize, 1);</span>
 945     if (glyphInfo == NULL) {
 946         glyphInfo = getNullGlyphImage();
 947         return ptr_to_jlong(glyphInfo);
 948     }
 949     glyphInfo-&gt;cellInfo  = NULL;
 950     glyphInfo-&gt;managed   = UNMANAGED_GLYPH;
<span class="line-modified"> 951     glyphInfo-&gt;rowBytes  = rowBytes;</span>
 952     glyphInfo-&gt;width     = width;
 953     glyphInfo-&gt;height    = height;
 954 
 955     if (renderImage) {
 956         glyphInfo-&gt;topLeftX  = (float)  ftglyph-&gt;bitmap_left;
 957         glyphInfo-&gt;topLeftY  = (float) -ftglyph-&gt;bitmap_top;
 958 
<span class="line-modified"> 959         if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD &amp;&amp; width &gt; 0) {</span>
 960             glyphInfo-&gt;width = width/3;
<span class="line-added"> 961             glyphInfo-&gt;topLeftX -= 1;</span>
<span class="line-added"> 962             glyphInfo-&gt;width += 1;</span>
 963         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {
 964             glyphInfo-&gt;height = glyphInfo-&gt;height/3;
 965         }
 966     }
 967 
 968     if (context-&gt;fmType == TEXT_FM_ON) {
 969         float advh = FTFixedToFloat(ftglyph-&gt;linearHoriAdvance);
 970         glyphInfo-&gt;advanceX =
 971             (float) (advh * FTFixedToFloat(context-&gt;transform.xx));
 972         glyphInfo-&gt;advanceY =
 973             (float) - (advh * FTFixedToFloat(context-&gt;transform.yx));
 974     } else {
 975         if (!ftglyph-&gt;advance.y) {
 976             glyphInfo-&gt;advanceX =
 977                 (float) FT26Dot6ToInt(ftglyph-&gt;advance.x);
 978             glyphInfo-&gt;advanceY = 0;
 979         } else if (!ftglyph-&gt;advance.x) {
 980             glyphInfo-&gt;advanceX = 0;
 981             glyphInfo-&gt;advanceY =
 982                 (float) FT26Dot6ToInt(-ftglyph-&gt;advance.y);
</pre>
<hr />
<pre>
 999                          ftglyph-&gt;bitmap.pitch,
1000                          (void *) glyphInfo-&gt;image,
1001                          width,
1002                          width,
1003                          height);
1004         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY) {
1005             /* byte per pixel to byte per pixel =&gt; just copy */
1006             memcpy(glyphInfo-&gt;image, ftglyph-&gt;bitmap.buffer, imageSize);
1007         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY4) {
1008             /* 4 bits per pixel to byte per pixel */
1009             CopyGrey4ToGrey8(ftglyph-&gt;bitmap.buffer,
1010                              ftglyph-&gt;bitmap.pitch,
1011                              (void *) glyphInfo-&gt;image,
1012                              width,
1013                              width,
1014                              height);
1015         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD) {
1016             /* 3 bytes per pixel to 3 bytes per pixel */
1017             CopyFTSubpixelToSubpixel(ftglyph-&gt;bitmap.buffer,
1018                                      ftglyph-&gt;bitmap.pitch,
<span class="line-modified">1019                                      (void *) (glyphInfo-&gt;image+PADBYTES),</span>
<span class="line-modified">1020                                      rowBytes,</span>
1021                                      width,
1022                                      height);
1023         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {
1024             /* 3 bytes per pixel to 3 bytes per pixel */
1025             CopyFTSubpixelVToSubpixel(ftglyph-&gt;bitmap.buffer,
1026                                       ftglyph-&gt;bitmap.pitch,
1027                                       (void *) glyphInfo-&gt;image,
1028                                       width*3,
1029                                       width,
1030                                       height);
1031             glyphInfo-&gt;rowBytes *=3;
1032         } else {
1033             free(glyphInfo);
1034             glyphInfo = getNullGlyphImage();
1035         }
1036     }
1037 
1038     return ptr_to_jlong(glyphInfo);
1039 }
1040 
</pre>
</td>
</tr>
</table>
<center><a href="../../classes/sun/font/TrueTypeFont.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../unix/classes/sun/awt/X11/XRobotPeer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
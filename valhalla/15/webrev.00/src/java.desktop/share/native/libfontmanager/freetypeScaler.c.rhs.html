<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/freetypeScaler.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &quot;jni.h&quot;
  27 #include &quot;jni_util.h&quot;
  28 #include &quot;jlong.h&quot;
  29 #include &quot;sunfontids.h&quot;
  30 #include &quot;sun_font_FreetypeFontScaler.h&quot;
  31 
  32 #include &lt;stdlib.h&gt;
  33 #if !defined(_WIN32) &amp;&amp; !defined(__APPLE_)
  34 #include &lt;dlfcn.h&gt;
  35 #endif
  36 #include &lt;math.h&gt;
  37 #include &quot;ft2build.h&quot;
  38 #include FT_FREETYPE_H
  39 #include FT_GLYPH_H
  40 #include FT_BBOX_H
  41 #include FT_SIZES_H
  42 #include FT_OUTLINE_H
  43 #include FT_SYNTHESIS_H
  44 #include FT_LCD_FILTER_H
  45 #include FT_MODULE_H
  46 
  47 #include &quot;fontscaler.h&quot;
  48 
  49 #define  ftFixed1  (FT_Fixed) (1 &lt;&lt; 16)
  50 #define  FloatToFTFixed(f) (FT_Fixed)((f) * (float)(ftFixed1))
  51 #define  FTFixedToFloat(x) ((x) / (float)(ftFixed1))
  52 #define  FT26Dot6ToFloat(x)  ((x) / ((float) (1&lt;&lt;6)))
  53 #define  FT26Dot6ToInt(x) (((int)(x)) &gt;&gt; 6)
  54 
  55 typedef struct {
  56     /* Important note:
  57          JNI forbids sharing same env between different threads.
  58          We are safe, because pointer is overwritten every time we get into
  59          JNI call (see setupFTContext).
  60 
  61          Pointer is used by font data reading callbacks
  62          such as ReadTTFontFileFunc.
  63 
  64          NB: We may consider switching to JNI_GetEnv. */
  65     JNIEnv* env;
  66     FT_Library library;
  67     FT_Face face;
  68     FT_Stream faceStream;
  69     jobject font2D;
  70     jobject directBuffer;
  71 
  72     unsigned char* fontData;
  73     unsigned fontDataOffset;
  74     unsigned fontDataLength;
  75     unsigned fileSize;
  76 } FTScalerInfo;
  77 
  78 typedef struct FTScalerContext {
  79     FT_Matrix  transform;     /* glyph transform, including device transform */
  80     jboolean   useSbits;      /* sbit usage enabled? */
  81     jint       aaType;        /* antialiasing mode (off/on/grey/lcd) */
  82     jint       fmType;        /* fractional metrics - on/off */
  83     jboolean   doBold;        /* perform algorithmic bolding? */
  84     jboolean   doItalize;     /* perform algorithmic italicizing? */
  85     int        renderFlags;   /* configuration specific to particular engine */
  86     int        pathType;
  87     int        ptsz;          /* size in points */
  88 } FTScalerContext;
  89 
  90 #ifdef DEBUG
  91 /* These are referenced in the freetype sources if DEBUG macro is defined.
  92    To simplify work with debuging version of freetype we define
  93    them here. */
  94 int z_verbose;
  95 void z_error(char *s) {}
  96 #endif
  97 
  98 /**************** Error handling utilities *****************/
  99 
 100 static jmethodID invalidateScalerMID;
 101 
 102 JNIEXPORT void JNICALL
 103 Java_sun_font_FreetypeFontScaler_initIDs(
 104         JNIEnv *env, jobject scaler, jclass FFSClass) {
 105     invalidateScalerMID =
 106         (*env)-&gt;GetMethodID(env, FFSClass, &quot;invalidateScaler&quot;, &quot;()V&quot;);
 107 }
 108 
 109 static void freeNativeResources(JNIEnv *env, FTScalerInfo* scalerInfo) {
 110 
 111     if (scalerInfo == NULL)
 112         return;
 113 
 114     // FT_Done_Face always closes the stream, but only frees the memory
 115     // of the data structure if it was internally allocated by FT.
 116     // We hold on to a pointer to the stream structure if we provide it
 117     // ourselves, so that we can free it here.
 118     FT_Done_Face(scalerInfo-&gt;face);
 119     FT_Done_FreeType(scalerInfo-&gt;library);
 120 
 121     if (scalerInfo-&gt;directBuffer != NULL) {
 122         (*env)-&gt;DeleteGlobalRef(env, scalerInfo-&gt;directBuffer);
 123     }
 124 
 125     if (scalerInfo-&gt;fontData != NULL) {
 126         free(scalerInfo-&gt;fontData);
 127     }
 128 
 129     if (scalerInfo-&gt;faceStream != NULL) {
 130         free(scalerInfo-&gt;faceStream);
 131     }
 132     free(scalerInfo);
 133 }
 134 
 135 /* invalidates state of java scaler object */
 136 static void invalidateJavaScaler(JNIEnv *env,
 137                                  jobject scaler,
 138                                  FTScalerInfo* scalerInfo) {
 139     freeNativeResources(env, scalerInfo);
 140     (*env)-&gt;CallVoidMethod(env, scaler, invalidateScalerMID);
 141 }
 142 
 143 /******************* I/O handlers ***************************/
 144 
 145 #define FILEDATACACHESIZE 1024
 146 
 147 static unsigned long ReadTTFontFileFunc(FT_Stream stream,
 148                                         unsigned long offset,
 149                                         unsigned char* destBuffer,
 150                                         unsigned long numBytes)
 151 {
 152     FTScalerInfo *scalerInfo = (FTScalerInfo *) stream-&gt;pathname.pointer;
 153     JNIEnv* env = scalerInfo-&gt;env;
 154     jobject bBuffer;
 155     int bread = 0;
 156 
 157     /* A call with numBytes == 0 is a seek. It should return 0 if the
 158      * seek position is within the file and non-zero otherwise.
 159      * For all other cases, ie numBytes !=0, return the number of bytes
 160      * actually read. This applies to truncated reads and also failed reads.
 161      */
 162 
 163     if (numBytes == 0) {
 164         if (offset &gt; scalerInfo-&gt;fileSize) {
 165             return -1;
 166         } else {
 167             return 0;
 168        }
 169     }
 170 
 171     if (offset + numBytes &lt; offset) {
 172         return 0; // ft should not do this, but just in case.
 173     }
 174 
 175     if (offset &gt;= scalerInfo-&gt;fileSize) {
 176         return 0;
 177     }
 178 
 179     if (offset + numBytes &gt; scalerInfo-&gt;fileSize) {
 180         numBytes = scalerInfo-&gt;fileSize - offset;
 181     }
 182 
 183     /* Large reads will bypass the cache and data copying */
 184     if (numBytes &gt; FILEDATACACHESIZE) {
 185         bBuffer = (*env)-&gt;NewDirectByteBuffer(env, destBuffer, numBytes);
 186         if (bBuffer != NULL) {
 187             bread = (*env)-&gt;CallIntMethod(env,
 188                                           scalerInfo-&gt;font2D,
 189                                           sunFontIDs.ttReadBlockMID,
 190                                           bBuffer, offset, numBytes);
 191             if (bread &lt; 0) {
 192                 return 0;
 193             } else {
 194                return bread;
 195             }
 196         } else {
 197             /* We probably hit bug 4845371. For reasons that
 198              * are currently unclear, the call stacks after the initial
 199              * createScaler call that read large amounts of data seem to
 200              * be OK and can create the byte buffer above, but this code
 201              * is here just in case.
 202              * 4845371 is fixed now so I don&#39;t expect this code path to
 203              * ever get called but its harmless to leave it here on the
 204              * small chance its needed.
 205              */
 206             jbyteArray byteArray = (jbyteArray)
 207             (*env)-&gt;CallObjectMethod(env, scalerInfo-&gt;font2D,
 208                                      sunFontIDs.ttReadBytesMID,
 209                                      offset, numBytes);
 210             /* If there&#39;s an OutofMemoryError then byteArray will be null */
 211             if (byteArray == NULL) {
 212                 return 0;
 213             } else {
 214                 jsize len = (*env)-&gt;GetArrayLength(env, byteArray);
 215                 if (len &lt; numBytes) {
 216                     numBytes = len; // don&#39;t get more bytes than there are ..
 217                 }
 218                 (*env)-&gt;GetByteArrayRegion(env, byteArray,
 219                                            0, numBytes, (jbyte*)destBuffer);
 220                 return numBytes;
 221             }
 222         }
 223     } /* Do we have a cache hit? */
 224       else if (scalerInfo-&gt;fontDataOffset &lt;= offset &amp;&amp;
 225         scalerInfo-&gt;fontDataOffset + scalerInfo-&gt;fontDataLength &gt;=
 226                                                          offset + numBytes)
 227     {
 228         unsigned cacheOffset = offset - scalerInfo-&gt;fontDataOffset;
 229 
 230         memcpy(destBuffer, scalerInfo-&gt;fontData+(size_t)cacheOffset, numBytes);
 231         return numBytes;
 232     } else {
 233         /* Must fill the cache */
 234         scalerInfo-&gt;fontDataOffset = offset;
 235         scalerInfo-&gt;fontDataLength =
 236                  (offset + FILEDATACACHESIZE &gt; scalerInfo-&gt;fileSize) ?
 237                  scalerInfo-&gt;fileSize - offset : FILEDATACACHESIZE;
 238         bBuffer = scalerInfo-&gt;directBuffer;
 239         bread = (*env)-&gt;CallIntMethod(env, scalerInfo-&gt;font2D,
 240                                       sunFontIDs.ttReadBlockMID,
 241                                       bBuffer, offset,
 242                                       scalerInfo-&gt;fontDataLength);
 243         if (bread &lt;= 0) {
 244             return 0;
 245         } else if (bread &lt; numBytes) {
 246            numBytes = bread;
 247         }
 248         memcpy(destBuffer, scalerInfo-&gt;fontData, numBytes);
 249         return numBytes;
 250     }
 251 }
 252 
 253 typedef FT_Error (*FT_Prop_Set_Func)(FT_Library library,
 254                                      const FT_String*  module_name,
 255                                      const FT_String*  property_name,
 256                                      const void*       value );
 257 
 258 /**
 259  * Prefer the older v35 freetype byte code interpreter.
 260  */
 261 static void setInterpreterVersion(FT_Library library) {
 262 
 263     char* props = getenv(&quot;FREETYPE_PROPERTIES&quot;);
 264     int version = 35;
 265     const char* module = &quot;truetype&quot;;
 266     const char* property = &quot;interpreter-version&quot;;
 267 
 268     /* If some one is setting this, don&#39;t override it */
<a name="1" id="anc1"></a><span class="line-modified"> 269     if (props != NULL &amp;&amp; strstr(props, property)) {</span>
 270         return;
 271     }
 272     /*
 273      * FT_Property_Set was introduced in 2.4.11.
 274      * Some older supported Linux OSes may not include it so look
 275      * this up dynamically.
 276      * And if its not available it doesn&#39;t matter, since the reason
 277      * we need it dates from 2.7.
 278      * On Windows &amp; Mac the library is always bundled so it is safe
 279      * to use directly in those cases.
 280      */
 281 #if defined(_WIN32) || defined(__APPLE__)
 282     FT_Property_Set(library, module, property, (void*)(&amp;version));
 283 #else
 284     void *lib = dlopen(&quot;libfreetype.so&quot;, RTLD_LOCAL|RTLD_LAZY);
 285     if (lib == NULL) {
 286         lib = dlopen(&quot;libfreetype.so.6&quot;, RTLD_LOCAL|RTLD_LAZY);
 287         if (lib == NULL) {
 288             return;
 289         }
 290     }
 291     FT_Prop_Set_Func func = (FT_Prop_Set_Func)dlsym(lib, &quot;FT_Property_Set&quot;);
 292     if (func != NULL) {
 293         func(library, module, property, (void*)(&amp;version));
 294     }
 295     dlclose(lib);
 296 #endif
 297 }
 298 
 299 /*
 300  * Class:     sun_font_FreetypeFontScaler
 301  * Method:    initNativeScaler
 302  * Signature: (Lsun/font/Font2D;IIZI)J
 303  */
 304 JNIEXPORT jlong JNICALL
 305 Java_sun_font_FreetypeFontScaler_initNativeScaler(
 306         JNIEnv *env, jobject scaler, jobject font2D, jint type,
 307         jint indexInCollection, jboolean supportsCJK, jint filesize) {
 308     FTScalerInfo* scalerInfo = NULL;
 309     FT_Open_Args ft_open_args;
 310     int error;
 311     jobject bBuffer;
 312     scalerInfo = (FTScalerInfo*) calloc(1, sizeof(FTScalerInfo));
 313 
 314     if (scalerInfo == NULL)
 315         return 0;
 316 
 317     scalerInfo-&gt;env = env;
 318     scalerInfo-&gt;font2D = font2D;
 319     scalerInfo-&gt;fontDataOffset = 0;
 320     scalerInfo-&gt;fontDataLength = 0;
 321     scalerInfo-&gt;fileSize = filesize;
 322 
 323     /*
 324        We can consider sharing freetype library between different
 325        scalers. However, Freetype docs suggest to use different libraries
 326        for different threads. Also, our architecture implies that single
 327        FontScaler object is shared for different sizes/transforms/styles
 328        of the same font.
 329 
 330        On other hand these methods can not be concurrently executed
 331        becaused they are &quot;synchronized&quot; in java.
 332     */
 333     error = FT_Init_FreeType(&amp;scalerInfo-&gt;library);
 334     if (error) {
 335         free(scalerInfo);
 336         return 0;
 337     }
 338     setInterpreterVersion(scalerInfo-&gt;library);
 339 
 340 #define TYPE1_FROM_JAVA        2
 341 
 342     error = 1; /* triggers memory freeing unless we clear it */
 343     if (type == TYPE1_FROM_JAVA) { /* TYPE1 */
 344         scalerInfo-&gt;fontData = (unsigned char*) malloc(filesize);
 345         scalerInfo-&gt;directBuffer = NULL;
 346         scalerInfo-&gt;fontDataLength = filesize;
 347 
 348         if (scalerInfo-&gt;fontData != NULL) {
 349             bBuffer = (*env)-&gt;NewDirectByteBuffer(env,
 350                                               scalerInfo-&gt;fontData,
 351                                               scalerInfo-&gt;fontDataLength);
 352             if (bBuffer != NULL) {
 353                 (*env)-&gt;CallVoidMethod(env, font2D,
 354                                    sunFontIDs.readFileMID, bBuffer);
 355 
 356                 error = FT_New_Memory_Face(scalerInfo-&gt;library,
 357                                    scalerInfo-&gt;fontData,
 358                                    scalerInfo-&gt;fontDataLength,
 359                                    indexInCollection,
 360                                    &amp;scalerInfo-&gt;face);
 361             }
 362         }
 363     } else { /* Truetype */
 364         scalerInfo-&gt;fontData = (unsigned char*) malloc(FILEDATACACHESIZE);
 365 
 366         if (scalerInfo-&gt;fontData != NULL) {
 367             FT_Stream ftstream = (FT_Stream) calloc(1, sizeof(FT_StreamRec));
 368             if (ftstream != NULL) {
 369                 scalerInfo-&gt;directBuffer = (*env)-&gt;NewDirectByteBuffer(env,
 370                                            scalerInfo-&gt;fontData,
 371                                            FILEDATACACHESIZE);
 372                 if (scalerInfo-&gt;directBuffer != NULL) {
 373                     scalerInfo-&gt;directBuffer = (*env)-&gt;NewGlobalRef(env,
 374                                                scalerInfo-&gt;directBuffer);
 375                     ftstream-&gt;base = NULL;
 376                     ftstream-&gt;size = filesize;
 377                     ftstream-&gt;pos = 0;
 378                     ftstream-&gt;read = (FT_Stream_IoFunc) ReadTTFontFileFunc;
 379                     ftstream-&gt;close = NULL;
 380                     ftstream-&gt;pathname.pointer = (void *) scalerInfo;
 381 
 382                     memset(&amp;ft_open_args, 0, sizeof(FT_Open_Args));
 383                     ft_open_args.flags = FT_OPEN_STREAM;
 384                     ft_open_args.stream = ftstream;
 385 
 386                     error = FT_Open_Face(scalerInfo-&gt;library,
 387                                          &amp;ft_open_args,
 388                                          indexInCollection,
 389                                          &amp;scalerInfo-&gt;face);
 390                     if (!error) {
 391                         scalerInfo-&gt;faceStream = ftstream;
 392                     }
 393                 }
 394                 if (error || scalerInfo-&gt;directBuffer == NULL) {
 395                     free(ftstream);
 396                 }
 397             }
 398         }
 399     }
 400 
 401     if (error) {
 402         FT_Done_FreeType(scalerInfo-&gt;library);
 403         if (scalerInfo-&gt;directBuffer != NULL) {
 404             (*env)-&gt;DeleteGlobalRef(env, scalerInfo-&gt;directBuffer);
 405         }
 406         if (scalerInfo-&gt;fontData != NULL)
 407             free(scalerInfo-&gt;fontData);
 408         free(scalerInfo);
 409         return 0;
 410     }
 411 
 412     return ptr_to_jlong(scalerInfo);
 413 }
 414 
 415 static double euclidianDistance(double a, double b) {
 416     if (a &lt; 0) a=-a;
 417     if (b &lt; 0) b=-b;
 418 
 419     if (a == 0) return b;
 420     if (b == 0) return a;
 421 
 422     return sqrt(a*a+b*b);
 423 }
 424 
 425 JNIEXPORT jlong JNICALL
 426 Java_sun_font_FreetypeFontScaler_createScalerContextNative(
 427         JNIEnv *env, jobject scaler, jlong pScaler, jdoubleArray matrix,
 428         jint aa, jint fm, jfloat boldness, jfloat italic) {
 429     double dmat[4], ptsz;
 430     FTScalerContext *context =
 431             (FTScalerContext*) calloc(1, sizeof(FTScalerContext));
 432     FTScalerInfo *scalerInfo =
 433              (FTScalerInfo*) jlong_to_ptr(pScaler);
 434 
 435     if (context == NULL) {
 436         invalidateJavaScaler(env, scaler, NULL);
 437         return (jlong) 0;
 438     }
 439     (*env)-&gt;GetDoubleArrayRegion(env, matrix, 0, 4, dmat);
 440     ptsz = euclidianDistance(dmat[2], dmat[3]); //i.e. y-size
 441     if (ptsz &lt; 1.0) {
 442         //text can not be smaller than 1 point
 443         ptsz = 1.0;
 444     }
 445     context-&gt;ptsz = (int)(ptsz * 64);
 446     context-&gt;transform.xx =  FloatToFTFixed((float)dmat[0]/ptsz);
 447     context-&gt;transform.yx = -FloatToFTFixed((float)dmat[1]/ptsz);
 448     context-&gt;transform.xy = -FloatToFTFixed((float)dmat[2]/ptsz);
 449     context-&gt;transform.yy =  FloatToFTFixed((float)dmat[3]/ptsz);
 450     context-&gt;aaType = aa;
 451     context-&gt;fmType = fm;
 452 
 453     /* If using algorithmic styling, the base values are
 454      * boldness = 1.0, italic = 0.0.
 455      */
 456     context-&gt;doBold = (boldness != 1.0);
 457     context-&gt;doItalize = (italic != 0);
 458 
 459     /* freetype is very keen to use embedded bitmaps, even if it knows
 460      * there is a rotation or you asked for antialiasing.
 461      * In the rendering path we will check useSBits and disable
 462      * bitmaps unless it is set. And here we set it only if none
 463      * of the conditions invalidate using it.
 464      * Note that we allow embedded bitmaps for the LCD case.
 465      */
 466     if ((aa != TEXT_AA_ON) &amp;&amp; (fm != TEXT_FM_ON) &amp;&amp;
 467         !context-&gt;doBold &amp;&amp; !context-&gt;doItalize &amp;&amp;
 468         (context-&gt;transform.yx == 0) &amp;&amp; (context-&gt;transform.xy == 0))
 469     {
 470         context-&gt;useSbits = 1;
 471     }
 472     return ptr_to_jlong(context);
 473 }
 474 
 475 // values used by FreeType (as of version 2.10.1) for italics transformation matrix in FT_GlyphSlot_Oblique
 476 #define FT_MATRIX_ONE 0x10000
 477 #define FT_MATRIX_OBLIQUE_XY 0x0366A
 478 
 479 static void setupTransform(FT_Matrix* target, FTScalerContext *context) {
 480     FT_Matrix* transform = &amp;context-&gt;transform;
 481     if (context-&gt;doItalize) {
 482         // we cannot use FT_GlyphSlot_Oblique as it doesn&#39;t work well with arbitrary transforms,
 483         // so we add corresponding shear transform to the requested glyph transformation
 484         target-&gt;xx = FT_MATRIX_ONE;
 485         target-&gt;xy = FT_MATRIX_OBLIQUE_XY;
 486         target-&gt;yx = 0;
 487         target-&gt;yy = FT_MATRIX_ONE;
 488         FT_Matrix_Multiply(transform, target);
 489     } else {
 490         target-&gt;xx = transform-&gt;xx;
 491         target-&gt;xy = transform-&gt;xy;
 492         target-&gt;yx = transform-&gt;yx;
 493         target-&gt;yy = transform-&gt;yy;
 494     }
 495 }
 496 
 497 static int setupFTContext(JNIEnv *env,
 498                           jobject font2D,
 499                           FTScalerInfo *scalerInfo,
 500                           FTScalerContext *context) {
 501     FT_Matrix matrix;
 502     int errCode = 0;
 503 
 504     scalerInfo-&gt;env = env;
 505     scalerInfo-&gt;font2D = font2D;
 506 
 507     if (context != NULL) {
 508         setupTransform(&amp;matrix, context);
 509         FT_Set_Transform(scalerInfo-&gt;face, &amp;matrix, NULL);
 510 
 511         errCode = FT_Set_Char_Size(scalerInfo-&gt;face, 0, context-&gt;ptsz, 72, 72);
 512 
 513         if (errCode == 0) {
 514             errCode = FT_Activate_Size(scalerInfo-&gt;face-&gt;size);
 515         }
 516 
 517         FT_Library_SetLcdFilter(scalerInfo-&gt;library, FT_LCD_FILTER_DEFAULT);
 518     }
 519 
 520     return errCode;
 521 }
 522 
 523 // using same values as for the transformation matrix
 524 #define OBLIQUE_MODIFIER(y)  (context-&gt;doItalize ? ((y)*FT_MATRIX_OBLIQUE_XY/FT_MATRIX_ONE) : 0)
 525 
 526 /* FT_GlyphSlot_Embolden (ftsynth.c) uses FT_MulFix(units_per_EM, y_scale) / 24
 527  * strength value when glyph format is FT_GLYPH_FORMAT_OUTLINE. This value has
 528  * been taken from libfreetype version 2.6 and remain valid at least up to
 529  * 2.9.1. */
 530 #define BOLD_MODIFIER(units_per_EM, y_scale) \
 531     (context-&gt;doBold ? FT_MulFix(units_per_EM, y_scale) / 24 : 0)
 532 
 533 /*
 534  * Class:     sun_font_FreetypeFontScaler
 535  * Method:    getFontMetricsNative
 536  * Signature: (Lsun/font/Font2D;J)Lsun/font/StrikeMetrics;
 537  */
 538 JNIEXPORT jobject JNICALL
 539 Java_sun_font_FreetypeFontScaler_getFontMetricsNative(
 540         JNIEnv *env, jobject scaler, jobject font2D,
 541         jlong pScalerContext, jlong pScaler) {
 542 
 543     jobject metrics;
 544     jfloat ax, ay, dx, dy, bx, by, lx, ly, mx, my;
 545     jfloat f0 = 0.0;
 546     FTScalerContext *context =
 547         (FTScalerContext*) jlong_to_ptr(pScalerContext);
 548     FTScalerInfo *scalerInfo =
 549              (FTScalerInfo*) jlong_to_ptr(pScaler);
 550 
 551     int errCode;
 552 
 553     if (isNullScalerContext(context) || scalerInfo == NULL) {
 554         return (*env)-&gt;NewObject(env,
 555                                  sunFontIDs.strikeMetricsClass,
 556                                  sunFontIDs.strikeMetricsCtr,
 557                                  f0, f0, f0, f0, f0, f0, f0, f0, f0, f0);
 558     }
 559 
 560     errCode = setupFTContext(env, font2D, scalerInfo, context);
 561 
 562     if (errCode) {
 563         metrics = (*env)-&gt;NewObject(env,
 564                                  sunFontIDs.strikeMetricsClass,
 565                                  sunFontIDs.strikeMetricsCtr,
 566                                  f0, f0, f0, f0, f0, f0, f0, f0, f0, f0);
 567         invalidateJavaScaler(env, scaler, scalerInfo);
 568         return metrics;
 569     }
 570 
 571     /* This is ugly and has to be reworked.
 572        Freetype provide means to add style to glyph but
 573        it seems there is no way to adjust metrics accordingly.
 574 
 575        So, we have to do adust them explicitly and stay consistent with what
 576        freetype does to outlines. */
 577 
 578 
 579     /**** Note: only some metrics are affected by styling ***/
 580 
 581     /* See https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=657854 */
 582 #define FT_MulFixFloatShift6(a, b) (((float) (a)) * ((float) (b)) / 65536.0 / 64.0)
 583 
 584 #define contextAwareMetricsX(x, y) \
 585     (FTFixedToFloat(context-&gt;transform.xx) * (x) - \
 586      FTFixedToFloat(context-&gt;transform.xy) * (y))
 587 
 588 #define contextAwareMetricsY(x, y) \
 589     (-FTFixedToFloat(context-&gt;transform.yx) * (x) + \
 590      FTFixedToFloat(context-&gt;transform.yy) * (y))
 591 
 592     /*
 593      * See FreeType source code: src/base/ftobjs.c ft_recompute_scaled_metrics()
 594      * http://icedtea.classpath.org/bugzilla/show_bug.cgi?id=1659
 595      */
 596     /* ascent */
 597     ax = 0;
 598     ay = -(jfloat) (FT_MulFixFloatShift6(
 599                        ((jlong) scalerInfo-&gt;face-&gt;ascender),
 600                        (jlong) scalerInfo-&gt;face-&gt;size-&gt;metrics.y_scale));
 601     /* descent */
 602     dx = 0;
 603     dy = -(jfloat) (FT_MulFixFloatShift6(
 604                        ((jlong) scalerInfo-&gt;face-&gt;descender),
 605                        (jlong) scalerInfo-&gt;face-&gt;size-&gt;metrics.y_scale));
 606     /* baseline */
 607     bx = by = 0;
 608 
 609     /* leading */
 610     lx = 0;
 611     ly = (jfloat) (FT_MulFixFloatShift6(
 612                       (jlong) scalerInfo-&gt;face-&gt;height,
 613                       (jlong) scalerInfo-&gt;face-&gt;size-&gt;metrics.y_scale))
 614                   + ay - dy;
 615     /* max advance */
 616     mx = (jfloat) FT26Dot6ToFloat(
 617                      scalerInfo-&gt;face-&gt;size-&gt;metrics.max_advance +
 618                      OBLIQUE_MODIFIER(scalerInfo-&gt;face-&gt;size-&gt;metrics.height) +
 619                      BOLD_MODIFIER(scalerInfo-&gt;face-&gt;units_per_EM,
 620                              scalerInfo-&gt;face-&gt;size-&gt;metrics.y_scale));
 621     my = 0;
 622 
 623     metrics = (*env)-&gt;NewObject(env,
 624         sunFontIDs.strikeMetricsClass,
 625         sunFontIDs.strikeMetricsCtr,
 626         contextAwareMetricsX(ax, ay), contextAwareMetricsY(ax, ay),
 627         contextAwareMetricsX(dx, dy), contextAwareMetricsY(dx, dy),
 628         bx, by,
 629         contextAwareMetricsX(lx, ly), contextAwareMetricsY(lx, ly),
 630         contextAwareMetricsX(mx, my), contextAwareMetricsY(mx, my));
 631 
 632     return metrics;
 633 }
 634 
 635 static jlong
 636     getGlyphImageNativeInternal(
 637         JNIEnv *env, jobject scaler, jobject font2D,
 638         jlong pScalerContext, jlong pScaler, jint glyphCode,
 639         jboolean renderImage);
 640 
 641 /*
 642  * Class:     sun_font_FreetypeFontScaler
 643  * Method:    getGlyphAdvanceNative
 644  * Signature: (Lsun/font/Font2D;JI)F
 645  */
 646 JNIEXPORT jfloat JNICALL
 647 Java_sun_font_FreetypeFontScaler_getGlyphAdvanceNative(
 648         JNIEnv *env, jobject scaler, jobject font2D,
 649         jlong pScalerContext, jlong pScaler, jint glyphCode) {
 650 
 651    /* This method is rarely used because requests for metrics are usually
 652     * coupled with a request for the bitmap and to a large extent the
 653     * work can be reused (to find out metrics we may need to hint the glyph).
 654     * So, we typically go through the getGlyphImage code path.
 655     * When we do get here, we need to pass a parameter which indicates
 656     * that we don&#39;t need freetype to render the bitmap, and consequently
 657     * don&#39;t need to allocate our own storage either.
 658     * This is also important when enter here requesting metrics for sizes
 659     * of text which a large size would be rejected for a bitmap but we
 660     * still need the metrics.
 661     */
 662 
 663     GlyphInfo *info;
 664     jfloat advance = 0.0f;
 665     jlong image;
 666 
 667     image = getGlyphImageNativeInternal(
 668           env, scaler, font2D, pScalerContext, pScaler, glyphCode, JNI_FALSE);
 669     info = (GlyphInfo*) jlong_to_ptr(image);
 670 
 671     if (info != NULL) {
 672         advance = info-&gt;advanceX;
 673         free(info);
 674     }
 675 
 676     return advance;
 677 }
 678 
 679 /*
 680  * Class:     sun_font_FreetypeFontScaler
 681  * Method:    getGlyphMetricsNative
 682  * Signature: (Lsun/font/Font2D;JILjava/awt/geom/Point2D/Float;)V
 683  */
 684 JNIEXPORT void JNICALL
 685 Java_sun_font_FreetypeFontScaler_getGlyphMetricsNative(
 686         JNIEnv *env, jobject scaler, jobject font2D, jlong pScalerContext,
 687         jlong pScaler, jint glyphCode, jobject metrics) {
 688 
 689      /* See the comments in getGlyphMetricsNative. They apply here too. */
 690      GlyphInfo *info;
 691 
 692      jlong image = getGlyphImageNativeInternal(
 693                                  env, scaler, font2D,
 694                                  pScalerContext, pScaler, glyphCode, JNI_FALSE);
 695      info = (GlyphInfo*) jlong_to_ptr(image);
 696 
 697      if (info != NULL) {
 698          (*env)-&gt;SetFloatField(env, metrics, sunFontIDs.xFID, info-&gt;advanceX);
 699          (*env)-&gt;SetFloatField(env, metrics, sunFontIDs.yFID, info-&gt;advanceY);
 700          free(info);
 701      } else {
 702          (*env)-&gt;SetFloatField(env, metrics, sunFontIDs.xFID, 0.0f);
 703          (*env)-&gt;SetFloatField(env, metrics, sunFontIDs.yFID, 0.0f);
 704      }
 705 }
 706 
 707 
 708 static GlyphInfo* getNullGlyphImage() {
 709     GlyphInfo *glyphInfo =  (GlyphInfo*) calloc(1, sizeof(GlyphInfo));
 710     return glyphInfo;
 711 }
 712 
 713 static void CopyBW2Grey8(const void* srcImage, int srcRowBytes,
 714                          void* dstImage, int dstRowBytes,
 715                          int width, int height) {
 716     const UInt8* srcRow = (UInt8*)srcImage;
 717     UInt8* dstRow = (UInt8*)dstImage;
 718     int wholeByteCount = width &gt;&gt; 3;
 719     int remainingBitsCount = width &amp; 7;
 720     int i, j;
 721 
 722     while (height--) {
 723         const UInt8* src8 = srcRow;
 724         UInt8* dstByte = dstRow;
 725         unsigned srcValue;
 726 
 727         srcRow += srcRowBytes;
 728         dstRow += dstRowBytes;
 729 
 730         for (i = 0; i &lt; wholeByteCount; i++) {
 731             srcValue = *src8++;
 732             for (j = 0; j &lt; 8; j++) {
 733                 *dstByte++ = (srcValue &amp; 0x80) ? 0xFF : 0;
 734                 srcValue &lt;&lt;= 1;
 735             }
 736         }
 737         if (remainingBitsCount) {
 738             srcValue = *src8;
 739             for (j = 0; j &lt; remainingBitsCount; j++) {
 740                 *dstByte++ = (srcValue &amp; 0x80) ? 0xFF : 0;
 741                 srcValue &lt;&lt;= 1;
 742             }
 743         }
 744     }
 745 }
 746 
 747 #define Grey4ToAlpha255(value) (((value) &lt;&lt; 4) + ((value) &gt;&gt; 3))
 748 
 749 static void CopyGrey4ToGrey8(const void* srcImage, int srcRowBytes,
 750                 void* dstImage, int dstRowBytes, int width, int height) {
 751      const UInt8* srcRow = (UInt8*) srcImage;
 752      UInt8* dstRow = (UInt8*) dstImage;
 753      int i;
 754 
 755      while (height--) {
 756          const UInt8* src8 = srcRow;
 757          UInt8* dstByte = dstRow;
 758          unsigned srcValue;
 759 
 760          srcRow += srcRowBytes;
 761          dstRow += dstRowBytes;
 762 
 763          for (i = 0; i &lt; width; i++) {
 764              srcValue = *src8++;
 765              *dstByte++ = Grey4ToAlpha255(srcValue &amp; 0x0f);
 766              *dstByte++ = Grey4ToAlpha255(srcValue &gt;&gt; 4);
 767          }
 768      }
 769 }
 770 
 771 /* We need it because FT rows are often padded to 4 byte boundaries
 772     and our internal format is not padded */
 773 static void CopyFTSubpixelToSubpixel(const void* srcImage, int srcRowBytes,
 774                                      void* dstImage, int dstRowBytes,
 775                                      int width, int height) {
 776     unsigned char *srcRow = (unsigned char *) srcImage;
 777     unsigned char *dstRow = (unsigned char *) dstImage;
 778 
 779     while (height--) {
 780         memcpy(dstRow, srcRow, width);
 781         srcRow += srcRowBytes;
 782         dstRow += dstRowBytes;
 783     }
 784 }
 785 
 786 /* We need it because FT rows are often padded to 4 byte boundaries
 787    and our internal format is not padded */
 788 static void CopyFTSubpixelVToSubpixel(const void* srcImage, int srcRowBytes,
 789                                       void* dstImage, int dstRowBytes,
 790                                       int width, int height) {
 791     unsigned char *srcRow = (unsigned char *) srcImage, *srcByte;
 792     unsigned char *dstRow = (unsigned char *) dstImage, *dstByte;
 793     int i;
 794 
 795     while (height &gt; 0) {
 796         srcByte = srcRow;
 797         dstByte = dstRow;
 798         for (i = 0; i &lt; width; i++) {
 799             *dstByte++ = *srcByte;
 800             *dstByte++ = *(srcByte + srcRowBytes);
 801             *dstByte++ = *(srcByte + 2*srcRowBytes);
 802             srcByte++;
 803         }
 804         srcRow += 3*srcRowBytes;
 805         dstRow += dstRowBytes;
 806         height -= 3;
 807     }
 808 }
 809 
 810 
 811 /* JDK does not use glyph images for fonts with a
 812  * pixel size &gt; 100 (see THRESHOLD in OutlineTextRenderer.java)
 813  * so if the glyph bitmap image dimension is &gt; 1024 pixels,
 814  * something is up.
 815  */
 816 #define MAX_GLYPH_DIM 1024
 817 
 818 /*
 819  * Class:     sun_font_FreetypeFontScaler
 820  * Method:    getGlyphImageNative
 821  * Signature: (Lsun/font/Font2D;JI)J
 822  */
 823 JNIEXPORT jlong JNICALL
 824 Java_sun_font_FreetypeFontScaler_getGlyphImageNative(
 825         JNIEnv *env, jobject scaler, jobject font2D,
 826         jlong pScalerContext, jlong pScaler, jint glyphCode) {
 827 
 828     return getGlyphImageNativeInternal(
 829         env, scaler, font2D,
 830         pScalerContext, pScaler, glyphCode, JNI_TRUE);
 831 }
 832 
 833 static jlong
 834      getGlyphImageNativeInternal(
 835         JNIEnv *env, jobject scaler, jobject font2D,
 836         jlong pScalerContext, jlong pScaler, jint glyphCode,
 837         jboolean renderImage) {
 838 
<a name="2" id="anc2"></a><span class="line-added"> 839     static int PADBYTES = 3;</span>
 840     int error, imageSize;
<a name="3" id="anc3"></a><span class="line-modified"> 841     UInt16 width, height, rowBytes;</span>
 842     GlyphInfo *glyphInfo;
 843     int renderFlags = FT_LOAD_DEFAULT, target;
 844     FT_GlyphSlot ftglyph;
 845 
 846     FTScalerContext* context =
 847         (FTScalerContext*) jlong_to_ptr(pScalerContext);
 848     FTScalerInfo *scalerInfo =
 849              (FTScalerInfo*) jlong_to_ptr(pScaler);
 850 
 851     if (isNullScalerContext(context) || scalerInfo == NULL) {
 852         return ptr_to_jlong(getNullGlyphImage());
 853     }
 854 
 855     error = setupFTContext(env, font2D, scalerInfo, context);
 856     if (error) {
 857         invalidateJavaScaler(env, scaler, scalerInfo);
 858         return ptr_to_jlong(getNullGlyphImage());
 859     }
 860 
 861     /*
 862      * When using Fractional metrics (linearly scaling advances) and
 863      * greyscale antialiasing, disable hinting so that the glyph shapes
 864      * are constant as size increases. This is good for animation as well
 865      * as being compatible with what happened in earlier JDK versions
 866      * which did not use freetype.
 867      */
 868     if (context-&gt;aaType == TEXT_AA_ON &amp;&amp; context-&gt;fmType == TEXT_FM_ON) {
 869          renderFlags |= FT_LOAD_NO_HINTING;
 870      }
 871 
 872     if (!context-&gt;useSbits) {
 873         renderFlags |= FT_LOAD_NO_BITMAP;
 874     }
 875 
 876     /* NB: in case of non identity transform
 877      we might also prefer to disable transform before hinting,
 878      and apply it explicitly after hinting is performed.
 879      Or we can disable hinting. */
 880 
 881     /* select appropriate hinting mode */
 882     if (context-&gt;aaType == TEXT_AA_OFF) {
 883         target = FT_LOAD_TARGET_MONO;
 884     } else if (context-&gt;aaType == TEXT_AA_ON) {
 885         target = FT_LOAD_TARGET_NORMAL;
 886     } else if (context-&gt;aaType == TEXT_AA_LCD_HRGB ||
 887                context-&gt;aaType == TEXT_AA_LCD_HBGR) {
 888         target = FT_LOAD_TARGET_LCD;
 889     } else {
 890         target = FT_LOAD_TARGET_LCD_V;
 891     }
 892     renderFlags |= target;
 893 
 894     error = FT_Load_Glyph(scalerInfo-&gt;face, glyphCode, renderFlags);
 895     if (error) {
 896         //do not destroy scaler yet.
 897         //this can be problem of particular context (e.g. with bad transform)
 898         return ptr_to_jlong(getNullGlyphImage());
 899     }
 900 
 901     ftglyph = scalerInfo-&gt;face-&gt;glyph;
 902 
 903     /* apply styles */
 904     if (context-&gt;doBold) { /* if bold style */
 905         FT_GlyphSlot_Embolden(ftglyph);
 906     }
 907 
 908     /* generate bitmap if it is not done yet
 909      e.g. if algorithmic styling is performed and style was added to outline */
 910     if (renderImage &amp;&amp; (ftglyph-&gt;format == FT_GLYPH_FORMAT_OUTLINE)) {
 911         FT_BBox bbox;
 912         FT_Outline_Get_CBox(&amp;(ftglyph-&gt;outline), &amp;bbox);
 913         int w = (int)((bbox.xMax&gt;&gt;6)-(bbox.xMin&gt;&gt;6));
 914         int h = (int)((bbox.yMax&gt;&gt;6)-(bbox.yMin&gt;&gt;6));
 915         if (w &gt; MAX_GLYPH_DIM || h &gt; MAX_GLYPH_DIM) {
 916             glyphInfo = getNullGlyphImage();
 917             return ptr_to_jlong(glyphInfo);
 918         }
 919         error = FT_Render_Glyph(ftglyph, FT_LOAD_TARGET_MODE(target));
 920         if (error != 0) {
 921             return ptr_to_jlong(getNullGlyphImage());
 922         }
 923     }
 924 
 925     if (renderImage) {
 926         width  = (UInt16) ftglyph-&gt;bitmap.width;
<a name="4" id="anc4"></a><span class="line-added"> 927         rowBytes = width;</span>
<span class="line-added"> 928         if (ftglyph-&gt;bitmap.pixel_mode == FT_PIXEL_MODE_LCD) {</span>
<span class="line-added"> 929            rowBytes = PADBYTES + width + PADBYTES;</span>
<span class="line-added"> 930         }</span>
 931         height = (UInt16) ftglyph-&gt;bitmap.rows;
 932             if (width &gt; MAX_GLYPH_DIM || height &gt; MAX_GLYPH_DIM) {
 933               glyphInfo = getNullGlyphImage();
 934               return ptr_to_jlong(glyphInfo);
 935             }
 936      } else {
 937         width = 0;
<a name="5" id="anc5"></a><span class="line-added"> 938         rowBytes = 0;</span>
 939         height = 0;
 940      }
 941 
 942 
<a name="6" id="anc6"></a><span class="line-modified"> 943     imageSize = rowBytes*height;</span>
<span class="line-modified"> 944     glyphInfo = (GlyphInfo*) calloc(sizeof(GlyphInfo) + imageSize, 1);</span>
 945     if (glyphInfo == NULL) {
 946         glyphInfo = getNullGlyphImage();
 947         return ptr_to_jlong(glyphInfo);
 948     }
 949     glyphInfo-&gt;cellInfo  = NULL;
 950     glyphInfo-&gt;managed   = UNMANAGED_GLYPH;
<a name="7" id="anc7"></a><span class="line-modified"> 951     glyphInfo-&gt;rowBytes  = rowBytes;</span>
 952     glyphInfo-&gt;width     = width;
 953     glyphInfo-&gt;height    = height;
 954 
 955     if (renderImage) {
 956         glyphInfo-&gt;topLeftX  = (float)  ftglyph-&gt;bitmap_left;
 957         glyphInfo-&gt;topLeftY  = (float) -ftglyph-&gt;bitmap_top;
 958 
<a name="8" id="anc8"></a><span class="line-modified"> 959         if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD &amp;&amp; width &gt; 0) {</span>
 960             glyphInfo-&gt;width = width/3;
<a name="9" id="anc9"></a><span class="line-added"> 961             glyphInfo-&gt;topLeftX -= 1;</span>
<span class="line-added"> 962             glyphInfo-&gt;width += 1;</span>
 963         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {
 964             glyphInfo-&gt;height = glyphInfo-&gt;height/3;
 965         }
 966     }
 967 
 968     if (context-&gt;fmType == TEXT_FM_ON) {
 969         float advh = FTFixedToFloat(ftglyph-&gt;linearHoriAdvance);
 970         glyphInfo-&gt;advanceX =
 971             (float) (advh * FTFixedToFloat(context-&gt;transform.xx));
 972         glyphInfo-&gt;advanceY =
 973             (float) - (advh * FTFixedToFloat(context-&gt;transform.yx));
 974     } else {
 975         if (!ftglyph-&gt;advance.y) {
 976             glyphInfo-&gt;advanceX =
 977                 (float) FT26Dot6ToInt(ftglyph-&gt;advance.x);
 978             glyphInfo-&gt;advanceY = 0;
 979         } else if (!ftglyph-&gt;advance.x) {
 980             glyphInfo-&gt;advanceX = 0;
 981             glyphInfo-&gt;advanceY =
 982                 (float) FT26Dot6ToInt(-ftglyph-&gt;advance.y);
 983         } else {
 984             glyphInfo-&gt;advanceX = FT26Dot6ToFloat(ftglyph-&gt;advance.x);
 985             glyphInfo-&gt;advanceY = FT26Dot6ToFloat(-ftglyph-&gt;advance.y);
 986         }
 987     }
 988 
 989     if (imageSize == 0) {
 990         glyphInfo-&gt;image = NULL;
 991     } else {
 992         glyphInfo-&gt;image = (unsigned char*) glyphInfo + sizeof(GlyphInfo);
 993         //convert result to output format
 994         //output format is either 3 bytes per pixel (for subpixel modes)
 995         // or 1 byte per pixel for AA and B&amp;W
 996         if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_MONO) {
 997             /* convert from 8 pixels per byte to 1 byte per pixel */
 998             CopyBW2Grey8(ftglyph-&gt;bitmap.buffer,
 999                          ftglyph-&gt;bitmap.pitch,
1000                          (void *) glyphInfo-&gt;image,
1001                          width,
1002                          width,
1003                          height);
1004         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY) {
1005             /* byte per pixel to byte per pixel =&gt; just copy */
1006             memcpy(glyphInfo-&gt;image, ftglyph-&gt;bitmap.buffer, imageSize);
1007         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY4) {
1008             /* 4 bits per pixel to byte per pixel */
1009             CopyGrey4ToGrey8(ftglyph-&gt;bitmap.buffer,
1010                              ftglyph-&gt;bitmap.pitch,
1011                              (void *) glyphInfo-&gt;image,
1012                              width,
1013                              width,
1014                              height);
1015         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD) {
1016             /* 3 bytes per pixel to 3 bytes per pixel */
1017             CopyFTSubpixelToSubpixel(ftglyph-&gt;bitmap.buffer,
1018                                      ftglyph-&gt;bitmap.pitch,
<a name="10" id="anc10"></a><span class="line-modified">1019                                      (void *) (glyphInfo-&gt;image+PADBYTES),</span>
<span class="line-modified">1020                                      rowBytes,</span>
1021                                      width,
1022                                      height);
1023         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {
1024             /* 3 bytes per pixel to 3 bytes per pixel */
1025             CopyFTSubpixelVToSubpixel(ftglyph-&gt;bitmap.buffer,
1026                                       ftglyph-&gt;bitmap.pitch,
1027                                       (void *) glyphInfo-&gt;image,
1028                                       width*3,
1029                                       width,
1030                                       height);
1031             glyphInfo-&gt;rowBytes *=3;
1032         } else {
1033             free(glyphInfo);
1034             glyphInfo = getNullGlyphImage();
1035         }
1036     }
1037 
1038     return ptr_to_jlong(glyphInfo);
1039 }
1040 
1041 /*
1042  * Class:     sun_font_FreetypeFontScaler
1043  * Method:    disposeNativeScaler
1044  * Signature: (J)V
1045  */
1046 JNIEXPORT void JNICALL
1047 Java_sun_font_FreetypeFontScaler_disposeNativeScaler(
1048         JNIEnv *env, jobject scaler, jobject font2D, jlong pScaler) {
1049     FTScalerInfo* scalerInfo = (FTScalerInfo *) jlong_to_ptr(pScaler);
1050 
1051     /* Freetype functions *may* cause callback to java
1052        that can use cached values. Make sure our cache is up to date.
1053        NB: scaler context is not important at this point, can use NULL. */
1054     int errCode = setupFTContext(env, font2D, scalerInfo, NULL);
1055     if (errCode) {
1056         return;
1057     }
1058 
1059     freeNativeResources(env, scalerInfo);
1060 }
1061 
1062 /*
1063  * Class:     sun_font_FreetypeFontScaler
1064  * Method:    getNumGlyphsNative
1065  * Signature: ()I
1066  */
1067 JNIEXPORT jint JNICALL
1068 Java_sun_font_FreetypeFontScaler_getNumGlyphsNative(
1069         JNIEnv *env, jobject scaler, jlong pScaler) {
1070     FTScalerInfo* scalerInfo = (FTScalerInfo *) jlong_to_ptr(pScaler);
1071 
1072     if (scalerInfo == NULL || scalerInfo-&gt;face == NULL) { /* bad/null scaler */
1073         /* null scaler can render 1 glyph - &quot;missing glyph&quot; with code 0
1074            (all glyph codes requested by user are mapped to code 0 at
1075            validation step) */
1076         invalidateJavaScaler(env, scaler, scalerInfo);
1077         return (jint) 1;
1078     }
1079 
1080     return (jint) scalerInfo-&gt;face-&gt;num_glyphs;
1081 }
1082 
1083 /*
1084  * Class:     sun_font_FreetypeFontScaler
1085  * Method:    getMissingGlyphCodeNative
1086  * Signature: ()I
1087  */
1088 JNIEXPORT jint JNICALL
1089 Java_sun_font_FreetypeFontScaler_getMissingGlyphCodeNative(
1090         JNIEnv *env, jobject scaler, jlong pScaler) {
1091 
1092     /* Is it always 0 for freetype? */
1093     return 0;
1094 }
1095 
1096 /*
1097  * Class:     sun_font_FreetypeFontScaler
1098  * Method:    getGlyphCodeNative
1099  * Signature: (C)I
1100  */
1101 JNIEXPORT jint JNICALL
1102 Java_sun_font_FreetypeFontScaler_getGlyphCodeNative(
1103         JNIEnv *env, jobject scaler,
1104         jobject font2D, jlong pScaler, jchar charCode) {
1105 
1106     FTScalerInfo* scalerInfo = (FTScalerInfo *) jlong_to_ptr(pScaler);
1107     int errCode;
1108 
1109     if (scaler == NULL || scalerInfo-&gt;face == NULL) { /* bad/null scaler */
1110         invalidateJavaScaler(env, scaler, scalerInfo);
1111         return 0;
1112     }
1113 
1114     /* Freetype functions *may* cause callback to java
1115        that can use cached values. Make sure our cache is up to date.
1116        Scaler context is not important here, can use NULL. */
1117     errCode = setupFTContext(env, font2D, scalerInfo, NULL);
1118     if (errCode) {
1119         return 0;
1120     }
1121 
1122     return FT_Get_Char_Index(scalerInfo-&gt;face, charCode);
1123 }
1124 
1125 
1126 #define FloatToF26Dot6(x) ((unsigned int) ((x)*64))
1127 
1128 static FT_Outline* getFTOutline(JNIEnv* env, jobject font2D,
1129         FTScalerContext *context, FTScalerInfo* scalerInfo,
1130         jint glyphCode, jfloat xpos, jfloat ypos) {
1131     int renderFlags;
1132     FT_Error error;
1133     FT_GlyphSlot ftglyph;
1134 
1135     if (glyphCode &gt;= INVISIBLE_GLYPHS ||
1136             isNullScalerContext(context) || scalerInfo == NULL) {
1137         return NULL;
1138     }
1139 
1140     error = setupFTContext(env, font2D, scalerInfo, context);
1141     if (error) {
1142         return NULL;
1143     }
1144 
1145     renderFlags = FT_LOAD_NO_HINTING | FT_LOAD_NO_BITMAP;
1146 
1147     error = FT_Load_Glyph(scalerInfo-&gt;face, glyphCode, renderFlags);
1148     if (error) {
1149         return NULL;
1150     }
1151 
1152     ftglyph = scalerInfo-&gt;face-&gt;glyph;
1153 
1154     /* apply styles */
1155     if (context-&gt;doBold) { /* if bold style */
1156         FT_GlyphSlot_Embolden(ftglyph);
1157     }
1158 
1159     FT_Outline_Translate(&amp;ftglyph-&gt;outline,
1160                          FloatToF26Dot6(xpos),
1161                          -FloatToF26Dot6(ypos));
1162 
1163     return &amp;ftglyph-&gt;outline;
1164 }
1165 
1166 #define F26Dot6ToFloat(n) (((float)(n))/((float) 64))
1167 
1168 /* Types of GeneralPath segments.
1169    TODO: pull constants from other place? */
1170 
1171 #define SEG_UNKNOWN -1
1172 #define SEG_MOVETO   0
1173 #define SEG_LINETO   1
1174 #define SEG_QUADTO   2
1175 #define SEG_CUBICTO  3
1176 #define SEG_CLOSE    4
1177 
1178 #define WIND_NON_ZERO 0
1179 #define WIND_EVEN_ODD 1
1180 
1181 /* Placeholder to accumulate GeneralPath data */
1182 typedef struct {
1183     jint numTypes;
1184     jint numCoords;
1185     jint lenTypes;
1186     jint lenCoords;
1187     jint wr;
1188     jbyte* pointTypes;
1189     jfloat* pointCoords;
1190 } GPData;
1191 
1192 /* returns 0 on failure */
1193 static int allocateSpaceForGP(GPData* gpdata, int npoints, int ncontours) {
1194     int maxTypes, maxCoords;
1195 
1196     /* we may have up to N intermediate points per contour
1197        (and for each point can actually cause new curve to be generated)
1198        In addition we can also have 2 extra point per outline.
1199      */
1200     maxTypes  = 2*npoints  + 2*ncontours;
1201     maxCoords = 4*(npoints + 2*ncontours); //we may need to insert
1202                                            //up to n-1 intermediate points
1203 
1204     /* first usage - allocate space and intialize all fields */
1205     if (gpdata-&gt;pointTypes == NULL || gpdata-&gt;pointCoords == NULL) {
1206         gpdata-&gt;lenTypes  = maxTypes;
1207         gpdata-&gt;lenCoords = maxCoords;
1208         gpdata-&gt;pointTypes  = (jbyte*)
1209              malloc(gpdata-&gt;lenTypes*sizeof(jbyte));
1210         gpdata-&gt;pointCoords = (jfloat*)
1211              malloc(gpdata-&gt;lenCoords*sizeof(jfloat));
1212         gpdata-&gt;numTypes = 0;
1213         gpdata-&gt;numCoords = 0;
1214         gpdata-&gt;wr = WIND_NON_ZERO; /* By default, outlines are filled
1215                                        using the non-zero winding rule. */
1216     } else {
1217         /* do we have enough space? */
1218         if (gpdata-&gt;lenTypes - gpdata-&gt;numTypes &lt; maxTypes) {
1219             gpdata-&gt;lenTypes  += maxTypes;
1220             gpdata-&gt;pointTypes  = (jbyte*)
1221               realloc(gpdata-&gt;pointTypes, gpdata-&gt;lenTypes*sizeof(jbyte));
1222         }
1223 
1224         if (gpdata-&gt;lenCoords - gpdata-&gt;numCoords &lt; maxCoords) {
1225             gpdata-&gt;lenCoords += maxCoords;
1226             gpdata-&gt;pointCoords = (jfloat*)
1227               realloc(gpdata-&gt;pointCoords, gpdata-&gt;lenCoords*sizeof(jfloat));
1228         }
1229     }
1230 
1231     /* failure if any of mallocs failed */
1232     if (gpdata-&gt;pointTypes == NULL ||  gpdata-&gt;pointCoords == NULL)
1233         return 0;
1234     else
1235         return 1;
1236 }
1237 
1238 static void addSeg(GPData *gp, jbyte type) {
1239     gp-&gt;pointTypes[gp-&gt;numTypes++] = type;
1240 }
1241 
1242 static void addCoords(GPData *gp, FT_Vector *p) {
1243     gp-&gt;pointCoords[gp-&gt;numCoords++] =  F26Dot6ToFloat(p-&gt;x);
1244     gp-&gt;pointCoords[gp-&gt;numCoords++] = -F26Dot6ToFloat(p-&gt;y);
1245 }
1246 
1247 static int moveTo(FT_Vector *to, GPData *gp) {
1248     if (gp-&gt;numCoords)
1249         addSeg(gp, SEG_CLOSE);
1250     addCoords(gp, to);
1251     addSeg(gp, SEG_MOVETO);
1252     return FT_Err_Ok;
1253 }
1254 
1255 static int lineTo(FT_Vector *to, GPData *gp) {
1256     addCoords(gp, to);
1257     addSeg(gp, SEG_LINETO);
1258     return FT_Err_Ok;
1259 }
1260 
1261 static int conicTo(FT_Vector *control, FT_Vector *to, GPData *gp) {
1262     addCoords(gp, control);
1263     addCoords(gp, to);
1264     addSeg(gp, SEG_QUADTO);
1265     return FT_Err_Ok;
1266 }
1267 
1268 static int cubicTo(FT_Vector *control1,
1269                    FT_Vector *control2,
1270                    FT_Vector *to,
1271                    GPData    *gp) {
1272     addCoords(gp, control1);
1273     addCoords(gp, control2);
1274     addCoords(gp, to);
1275     addSeg(gp, SEG_CUBICTO);
1276     return FT_Err_Ok;
1277 }
1278 
1279 static void addToGP(GPData* gpdata, FT_Outline*outline) {
1280     static const FT_Outline_Funcs outline_funcs = {
1281         (FT_Outline_MoveToFunc) moveTo,
1282         (FT_Outline_LineToFunc) lineTo,
1283         (FT_Outline_ConicToFunc) conicTo,
1284         (FT_Outline_CubicToFunc) cubicTo,
1285         0, /* shift */
1286         0, /* delta */
1287     };
1288 
1289     FT_Outline_Decompose(outline, &amp;outline_funcs, gpdata);
1290     if (gpdata-&gt;numCoords)
1291         addSeg(gpdata, SEG_CLOSE);
1292 
1293     /* If set to 1, the outline will be filled using the even-odd fill rule */
1294     if (outline-&gt;flags &amp; FT_OUTLINE_EVEN_ODD_FILL) {
1295         gpdata-&gt;wr = WIND_EVEN_ODD;
1296     }
1297 }
1298 
1299 static void freeGP(GPData* gpdata) {
1300     if (gpdata-&gt;pointCoords != NULL) {
1301         free(gpdata-&gt;pointCoords);
1302         gpdata-&gt;pointCoords = NULL;
1303         gpdata-&gt;numCoords = 0;
1304         gpdata-&gt;lenCoords = 0;
1305     }
1306     if (gpdata-&gt;pointTypes != NULL) {
1307         free(gpdata-&gt;pointTypes);
1308         gpdata-&gt;pointTypes = NULL;
1309         gpdata-&gt;numTypes = 0;
1310         gpdata-&gt;lenTypes = 0;
1311     }
1312 }
1313 
1314 static jobject getGlyphGeneralPath(JNIEnv* env, jobject font2D,
1315         FTScalerContext *context, FTScalerInfo *scalerInfo,
1316         jint glyphCode, jfloat xpos, jfloat ypos) {
1317 
1318     FT_Outline* outline;
1319     jobject gp = NULL;
1320     jbyteArray types;
1321     jfloatArray coords;
1322     GPData gpdata;
1323 
1324     outline = getFTOutline(env, font2D, context, scalerInfo,
1325                            glyphCode, xpos, ypos);
1326 
1327     if (outline == NULL || outline-&gt;n_points == 0) {
1328         return gp;
1329     }
1330 
1331     gpdata.pointTypes  = NULL;
1332     gpdata.pointCoords = NULL;
1333     if (!allocateSpaceForGP(&amp;gpdata, outline-&gt;n_points, outline-&gt;n_contours)) {
1334         return gp;
1335     }
1336 
1337     addToGP(&amp;gpdata, outline);
1338 
1339     types  = (*env)-&gt;NewByteArray(env, gpdata.numTypes);
1340     coords = (*env)-&gt;NewFloatArray(env, gpdata.numCoords);
1341 
1342     if (types &amp;&amp; coords) {
1343         (*env)-&gt;SetByteArrayRegion(env, types, 0,
1344                                    gpdata.numTypes,
1345                                    gpdata.pointTypes);
1346         (*env)-&gt;SetFloatArrayRegion(env, coords, 0,
1347                                     gpdata.numCoords,
1348                                     gpdata.pointCoords);
1349         gp = (*env)-&gt;NewObject(env,
1350                                sunFontIDs.gpClass,
1351                                sunFontIDs.gpCtr,
1352                                gpdata.wr,
1353                                types,
1354                                gpdata.numTypes,
1355                                coords,
1356                                gpdata.numCoords);
1357     }
1358 
1359     freeGP(&amp;gpdata);
1360 
1361     return gp;
1362 }
1363 
1364 /*
1365  * Class:     sun_font_FreetypeFontScaler
1366  * Method:    getGlyphOutlineNative
1367  * Signature: (Lsun/font/Font2D;JIFF)Ljava/awt/geom/GeneralPath;
1368  */
1369 JNIEXPORT jobject JNICALL
1370 Java_sun_font_FreetypeFontScaler_getGlyphOutlineNative(
1371       JNIEnv *env, jobject scaler, jobject font2D, jlong pScalerContext,
1372       jlong pScaler, jint glyphCode, jfloat xpos, jfloat ypos) {
1373 
1374     FTScalerContext *context =
1375          (FTScalerContext*) jlong_to_ptr(pScalerContext);
1376     FTScalerInfo* scalerInfo = (FTScalerInfo *) jlong_to_ptr(pScaler);
1377 
1378     jobject gp = getGlyphGeneralPath(env,
1379                                font2D,
1380                                context,
1381                                scalerInfo,
1382                                glyphCode,
1383                                xpos,
1384                                ypos);
1385     if (gp == NULL) { /* can be legal */
1386         gp = (*env)-&gt;NewObject(env,
1387                                sunFontIDs.gpClass,
1388                                sunFontIDs.gpCtrEmpty);
1389     }
1390     return gp;
1391 }
1392 
1393 /*
1394  * Class:     sun_font_FreetypeFontScaler
1395  * Method:    getGlyphOutlineBoundsNative
1396  * Signature: (Lsun/font/Font2D;JI)Ljava/awt/geom/Rectangle2D/Float;
1397  */
1398 JNIEXPORT jobject JNICALL
1399 Java_sun_font_FreetypeFontScaler_getGlyphOutlineBoundsNative(
1400         JNIEnv *env, jobject scaler, jobject font2D,
1401         jlong pScalerContext, jlong pScaler, jint glyphCode) {
1402 
1403     FT_Outline *outline;
1404     FT_BBox bbox;
1405     int error;
1406     jobject bounds;
1407 
1408     FTScalerContext *context =
1409          (FTScalerContext*) jlong_to_ptr(pScalerContext);
1410     FTScalerInfo* scalerInfo = (FTScalerInfo *) jlong_to_ptr(pScaler);
1411 
1412     outline = getFTOutline(env, font2D, context, scalerInfo, glyphCode, 0, 0);
1413     if (outline == NULL || outline-&gt;n_points == 0) {
1414         /* it is legal case, e.g. invisible glyph */
1415         bounds = (*env)-&gt;NewObject(env,
1416                                  sunFontIDs.rect2DFloatClass,
1417                                  sunFontIDs.rect2DFloatCtr);
1418         return bounds;
1419     }
1420 
1421     error = FT_Outline_Get_BBox(outline, &amp;bbox);
1422 
1423     //convert bbox
1424     if (error || bbox.xMin &gt;= bbox.xMax || bbox.yMin &gt;= bbox.yMax) {
1425         bounds = (*env)-&gt;NewObject(env,
1426                                    sunFontIDs.rect2DFloatClass,
1427                                    sunFontIDs.rect2DFloatCtr);
1428     } else {
1429         bounds = (*env)-&gt;NewObject(env,
1430                                    sunFontIDs.rect2DFloatClass,
1431                                    sunFontIDs.rect2DFloatCtr4,
1432                                    F26Dot6ToFloat(bbox.xMin),
1433                                    F26Dot6ToFloat(-bbox.yMax),
1434                                    F26Dot6ToFloat(bbox.xMax-bbox.xMin),
1435                                    F26Dot6ToFloat(bbox.yMax-bbox.yMin));
1436     }
1437 
1438     return bounds;
1439 }
1440 
1441 /*
1442  * Class:     sun_font_FreetypeFontScaler
1443  * Method:    getGlyphVectorOutlineNative
1444  * Signature: (Lsun/font/Font2D;J[IIFF)Ljava/awt/geom/GeneralPath;
1445  */
1446 JNIEXPORT jobject
1447 JNICALL
1448 Java_sun_font_FreetypeFontScaler_getGlyphVectorOutlineNative(
1449         JNIEnv *env, jobject scaler, jobject font2D,
1450         jlong pScalerContext, jlong pScaler,
1451         jintArray glyphArray, jint numGlyphs, jfloat xpos, jfloat ypos) {
1452 
1453     FT_Outline* outline;
1454     jobject gp = NULL;
1455     jbyteArray types;
1456     jfloatArray coords;
1457     GPData gpdata;
1458     int i;
1459     jint *glyphs;
1460 
1461     FTScalerContext *context =
1462          (FTScalerContext*) jlong_to_ptr(pScalerContext);
1463     FTScalerInfo *scalerInfo =
1464              (FTScalerInfo*) jlong_to_ptr(pScaler);
1465 
1466     glyphs = NULL;
1467     if (numGlyphs &gt; 0 &amp;&amp; 0xffffffffu / sizeof(jint) &gt;= numGlyphs) {
1468         glyphs = (jint*) malloc(numGlyphs*sizeof(jint));
1469     }
1470     if (glyphs == NULL) {
1471         // We reach here if:
1472         // 1. numGlyphs &lt;= 0,
1473         // 2. overflow check failed, or
1474         // 3. malloc failed.
1475         gp = (*env)-&gt;NewObject(env, sunFontIDs.gpClass, sunFontIDs.gpCtrEmpty);
1476         return gp;
1477     }
1478 
1479     (*env)-&gt;GetIntArrayRegion(env, glyphArray, 0, numGlyphs, glyphs);
1480 
1481     gpdata.numCoords = 0;
1482     for (i=0; i&lt;numGlyphs;i++) {
1483         if (glyphs[i] &gt;= INVISIBLE_GLYPHS) {
1484             continue;
1485         }
1486         outline = getFTOutline(env,
1487                                font2D,
1488                                context,
1489                                scalerInfo,
1490                                glyphs[i],
1491                                xpos, ypos);
1492 
1493         if (outline == NULL || outline-&gt;n_points == 0) {
1494             continue;
1495         }
1496 
1497         gpdata.pointTypes  = NULL;
1498         gpdata.pointCoords = NULL;
1499         if (!allocateSpaceForGP(&amp;gpdata, outline-&gt;n_points,
1500                                 outline-&gt;n_contours)) {
1501             break;
1502         }
1503 
1504         addToGP(&amp;gpdata, outline);
1505     }
1506     free(glyphs);
1507 
1508     if (gpdata.numCoords != 0) {
1509       types = (*env)-&gt;NewByteArray(env, gpdata.numTypes);
1510       coords = (*env)-&gt;NewFloatArray(env, gpdata.numCoords);
1511 
1512       if (types &amp;&amp; coords) {
1513         (*env)-&gt;SetByteArrayRegion(env, types, 0,
1514                                    gpdata.numTypes, gpdata.pointTypes);
1515         (*env)-&gt;SetFloatArrayRegion(env, coords, 0,
1516                                     gpdata.numCoords, gpdata.pointCoords);
1517 
1518         gp=(*env)-&gt;NewObject(env,
1519                              sunFontIDs.gpClass,
1520                              sunFontIDs.gpCtr,
1521                              gpdata.wr,
1522                              types,
1523                              gpdata.numTypes,
1524                              coords,
1525                              gpdata.numCoords);
1526         return gp;
1527       }
1528     }
1529     return (*env)-&gt;NewObject(env, sunFontIDs.gpClass, sunFontIDs.gpCtrEmpty);
1530 }
1531 
1532 JNIEXPORT jlong JNICALL
1533 Java_sun_font_FreetypeFontScaler_getUnitsPerEMNative(
1534         JNIEnv *env, jobject scaler, jlong pScaler) {
1535 
1536     FTScalerInfo *s = (FTScalerInfo* ) jlong_to_ptr(pScaler);
1537 
1538     /* Freetype doc says:
1539      The number of font units per EM square for this face.
1540      This is typically 2048 for TrueType fonts, and 1000 for Type 1 fonts.
1541      Only relevant for scalable formats.
1542      However, layout engine might be not tested with anything but 2048.
1543 
1544      NB: test it! */
1545     if (s != NULL) {
1546         return s-&gt;face-&gt;units_per_EM;
1547     }
1548     return 2048;
1549 }
1550 
1551 /* This native method is called by the OpenType layout engine. */
1552 JNIEXPORT jobject JNICALL
1553 Java_sun_font_FreetypeFontScaler_getGlyphPointNative(
1554         JNIEnv *env, jobject scaler, jobject font2D, jlong pScalerContext,
1555         jlong pScaler, jint glyphCode, jint pointNumber) {
1556 
1557     FT_Outline* outline;
1558     jobject point = NULL;
1559     jfloat x=0, y=0;
1560     FTScalerContext *context =
1561          (FTScalerContext*) jlong_to_ptr(pScalerContext);
1562     FTScalerInfo *scalerInfo = (FTScalerInfo*) jlong_to_ptr(pScaler);
1563 
1564     outline = getFTOutline(env, font2D, context, scalerInfo, glyphCode, 0, 0);
1565 
1566     if (outline != NULL &amp;&amp; outline-&gt;n_points &gt; pointNumber) {
1567         x =  F26Dot6ToFloat(outline-&gt;points[pointNumber].x);
1568         y = -F26Dot6ToFloat(outline-&gt;points[pointNumber].y);
1569     }
1570 
1571     return (*env)-&gt;NewObject(env, sunFontIDs.pt2DFloatClass,
1572                              sunFontIDs.pt2DFloatCtr, x, y);
1573 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
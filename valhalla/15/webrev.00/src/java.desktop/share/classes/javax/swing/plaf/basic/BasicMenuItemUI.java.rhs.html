<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/classes/javax/swing/plaf/basic/BasicMenuItemUI.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javax.swing.plaf.basic;
  27 
  28 import java.awt.*;
  29 import java.awt.event.*;
  30 import java.beans.PropertyChangeEvent;
  31 import java.beans.PropertyChangeListener;
  32 
  33 import javax.swing.*;
  34 import javax.swing.event.*;
  35 import javax.swing.plaf.*;
  36 import javax.swing.text.View;
  37 
  38 import sun.swing.*;
  39 
  40 /**
  41  * BasicMenuItem implementation
  42  *
  43  * @author Georges Saab
  44  * @author David Karlton
  45  * @author Arnaud Weber
  46  * @author Fredrik Lagerblad
  47  */
  48 public class BasicMenuItemUI extends MenuItemUI
  49 {
  50     /**
  51      * The instance of {@code JMenuItem}.
  52      */
  53     protected JMenuItem menuItem = null;
  54     /**
  55      * The color of the selection background.
  56      */
  57     protected Color selectionBackground;
  58     /**
  59      * The color of the selection foreground.
  60      */
  61     protected Color selectionForeground;
  62     /**
  63      * The color of the disabled foreground.
  64      */
  65     protected Color disabledForeground;
  66     /**
  67      * The color of the accelerator foreground.
  68      */
  69     protected Color acceleratorForeground;
  70     /**
  71      * The color of the accelerator selection.
  72      */
  73     protected Color acceleratorSelectionForeground;
  74 
  75     /**
  76      * Accelerator delimiter string, such as {@code &#39;+&#39;} in {@code &#39;Ctrl+C&#39;}.
  77      * @since 1.7
  78      */
  79     protected String acceleratorDelimiter;
  80 
  81     /**
  82      * The gap between the text and the icon.
  83      */
  84     protected int defaultTextIconGap;
  85     /**
  86      * The accelerator font.
  87      */
  88     protected Font acceleratorFont;
  89 
  90     /**
  91      * The instance of {@code MouseInputListener}.
  92      */
  93     protected MouseInputListener mouseInputListener;
  94     /**
  95      * The instance of {@code MenuDragMouseListener}.
  96      */
  97     protected MenuDragMouseListener menuDragMouseListener;
  98     /**
  99      * The instance of {@code MenuKeyListener}.
 100      */
 101     protected MenuKeyListener menuKeyListener;
 102     /**
 103      * {@code PropertyChangeListener} returned from
 104      * {@code createPropertyChangeListener}. You should not
 105      * need to access this field, rather if you want to customize the
 106      * {@code PropertyChangeListener} override
 107      * {@code createPropertyChangeListener}.
 108      *
 109      * @since 1.6
 110      * @see #createPropertyChangeListener
 111      */
 112     protected PropertyChangeListener propertyChangeListener;
 113     // BasicMenuUI also uses this.
 114     Handler handler;
 115     /**
 116      * The arrow icon.
 117      */
 118     protected Icon arrowIcon = null;
 119     /**
 120      * The check icon.
 121      */
 122     protected Icon checkIcon = null;
 123     /**
 124      * The value represents if the old border is painted.
 125      */
 126     protected boolean oldBorderPainted;
 127 
 128     /* diagnostic aids -- should be false for production builds. */
 129     private static final boolean TRACE =   false; // trace creates and disposes
 130 
 131     private static final boolean VERBOSE = false; // show reuse hits/misses
 132     private static final boolean DEBUG =   false;  // show bad params, misc.
 133 
 134     static void loadActionMap(LazyActionMap map) {
 135         // NOTE: BasicMenuUI also calls into this method.
 136         map.put(new Actions(Actions.CLICK));
 137         BasicLookAndFeel.installAudioActionMap(map);
 138     }
 139 
 140     /**
 141      * Returns a new instance of {@code BasicMenuItemUI}.
 142      *
 143      * @param c a component
 144      * @return a new instance of {@code BasicMenuItemUI}
 145      */
 146     public static ComponentUI createUI(JComponent c) {
 147         return new BasicMenuItemUI();
 148     }
 149 
 150     public void installUI(JComponent c) {
 151         menuItem = (JMenuItem) c;
 152 
 153         installDefaults();
 154         installComponents(menuItem);
 155         installListeners();
 156         installKeyboardActions();
 157     }
 158 
 159     /**
 160      * Installs default properties.
 161      */
 162     protected void installDefaults() {
 163         String prefix = getPropertyPrefix();
 164 
 165         acceleratorFont = UIManager.getFont(&quot;MenuItem.acceleratorFont&quot;);
 166         // use default if missing so that BasicMenuItemUI can be used in other
 167         // LAFs like Nimbus
 168         if (acceleratorFont == null) {
 169             acceleratorFont = UIManager.getFont(&quot;MenuItem.font&quot;);
 170         }
 171 
 172         Object opaque = UIManager.get(getPropertyPrefix() + &quot;.opaque&quot;);
 173         if (opaque != null) {
 174             LookAndFeel.installProperty(menuItem, &quot;opaque&quot;, opaque);
 175         }
 176         else {
 177             LookAndFeel.installProperty(menuItem, &quot;opaque&quot;, Boolean.TRUE);
 178         }
 179         if(menuItem.getMargin() == null ||
 180            (menuItem.getMargin() instanceof UIResource)) {
 181             menuItem.setMargin(UIManager.getInsets(prefix + &quot;.margin&quot;));
 182         }
 183 
 184         LookAndFeel.installProperty(menuItem, &quot;iconTextGap&quot;, Integer.valueOf(4));
 185         defaultTextIconGap = menuItem.getIconTextGap();
 186 
 187         LookAndFeel.installBorder(menuItem, prefix + &quot;.border&quot;);
 188         oldBorderPainted = menuItem.isBorderPainted();
 189         LookAndFeel.installProperty(menuItem, &quot;borderPainted&quot;,
 190                                     UIManager.getBoolean(prefix + &quot;.borderPainted&quot;));
 191         LookAndFeel.installColorsAndFont(menuItem,
 192                                          prefix + &quot;.background&quot;,
 193                                          prefix + &quot;.foreground&quot;,
 194                                          prefix + &quot;.font&quot;);
 195 
 196         // MenuItem specific defaults
 197         if (selectionBackground == null ||
 198             selectionBackground instanceof UIResource) {
 199             selectionBackground =
 200                 UIManager.getColor(prefix + &quot;.selectionBackground&quot;);
 201         }
 202         if (selectionForeground == null ||
 203             selectionForeground instanceof UIResource) {
 204             selectionForeground =
 205                 UIManager.getColor(prefix + &quot;.selectionForeground&quot;);
 206         }
 207         if (disabledForeground == null ||
 208             disabledForeground instanceof UIResource) {
 209             disabledForeground =
 210                 UIManager.getColor(prefix + &quot;.disabledForeground&quot;);
 211         }
 212         if (acceleratorForeground == null ||
 213             acceleratorForeground instanceof UIResource) {
 214             acceleratorForeground =
 215                 UIManager.getColor(prefix + &quot;.acceleratorForeground&quot;);
 216         }
 217         if (acceleratorSelectionForeground == null ||
 218             acceleratorSelectionForeground instanceof UIResource) {
 219             acceleratorSelectionForeground =
 220                 UIManager.getColor(prefix + &quot;.acceleratorSelectionForeground&quot;);
 221         }
 222         // Get accelerator delimiter
 223         acceleratorDelimiter =
 224             UIManager.getString(&quot;MenuItem.acceleratorDelimiter&quot;);
 225         if (acceleratorDelimiter == null) { acceleratorDelimiter = &quot;+&quot;; }
 226         // Icons
 227         if (arrowIcon == null ||
 228             arrowIcon instanceof UIResource) {
 229             arrowIcon = UIManager.getIcon(prefix + &quot;.arrowIcon&quot;);
 230         }
<a name="1" id="anc1"></a>







 231 
 232         if (checkIcon == null ||
 233             checkIcon instanceof UIResource) {
 234             checkIcon = UIManager.getIcon(prefix + &quot;.checkIcon&quot;);
 235             //In case of column layout, .checkIconFactory is defined for this UI,
 236             //the icon is compatible with it and useCheckAndArrow() is true,
 237             //then the icon is handled by the checkIcon.
 238             boolean isColumnLayout = MenuItemLayoutHelper.isColumnLayout(
 239                     BasicGraphicsUtils.isLeftToRight(menuItem), menuItem);
 240             if (isColumnLayout) {
 241                 MenuItemCheckIconFactory iconFactory =
 242                         (MenuItemCheckIconFactory) UIManager.get(prefix
 243                                 + &quot;.checkIconFactory&quot;);
 244                 if (iconFactory != null
 245                         &amp;&amp; MenuItemLayoutHelper.useCheckAndArrow(menuItem)
 246                         &amp;&amp; iconFactory.isCompatible(checkIcon, prefix)) {
 247                     checkIcon = iconFactory.getIcon(menuItem);
 248                 }
 249             }
 250         }
 251     }
 252 
 253     /**
 254      *
 255      * @param menuItem a menu item
 256      * @since 1.3
 257      */
 258     protected void installComponents(JMenuItem menuItem){
 259         BasicHTML.updateRenderer(menuItem, menuItem.getText());
 260     }
 261 
 262     /**
 263      * Returns a property prefix.
 264      *
 265      * @return a property prefix
 266      */
 267     protected String getPropertyPrefix() {
 268         return &quot;MenuItem&quot;;
 269     }
 270 
 271     /**
 272      * Registers listeners.
 273      */
 274     protected void installListeners() {
 275         if ((mouseInputListener = createMouseInputListener(menuItem)) != null) {
 276             menuItem.addMouseListener(mouseInputListener);
 277             menuItem.addMouseMotionListener(mouseInputListener);
 278         }
 279         if ((menuDragMouseListener = createMenuDragMouseListener(menuItem)) != null) {
 280             menuItem.addMenuDragMouseListener(menuDragMouseListener);
 281         }
 282         if ((menuKeyListener = createMenuKeyListener(menuItem)) != null) {
 283             menuItem.addMenuKeyListener(menuKeyListener);
 284         }
 285         if ((propertyChangeListener = createPropertyChangeListener(menuItem)) != null) {
 286             menuItem.addPropertyChangeListener(propertyChangeListener);
 287         }
 288     }
 289 
 290     /**
 291      * Registers keyboard action.
 292      */
 293     protected void installKeyboardActions() {
 294         installLazyActionMap();
 295         updateAcceleratorBinding();
 296     }
 297 
 298     void installLazyActionMap() {
 299         LazyActionMap.installLazyActionMap(menuItem, BasicMenuItemUI.class,
 300                                            getPropertyPrefix() + &quot;.actionMap&quot;);
 301     }
 302 
 303     public void uninstallUI(JComponent c) {
 304         menuItem = (JMenuItem)c;
 305         uninstallDefaults();
 306         uninstallComponents(menuItem);
 307         uninstallListeners();
 308         uninstallKeyboardActions();
 309         MenuItemLayoutHelper.clearUsedParentClientProperties(menuItem);
 310         menuItem = null;
 311     }
 312 
 313     /**
 314      * Uninstalls default properties.
 315      */
 316     protected void uninstallDefaults() {
 317         LookAndFeel.uninstallBorder(menuItem);
 318         LookAndFeel.installProperty(menuItem, &quot;borderPainted&quot;, oldBorderPainted);
 319         if (menuItem.getMargin() instanceof UIResource)
 320             menuItem.setMargin(null);
 321         if (arrowIcon instanceof UIResource)
 322             arrowIcon = null;
 323         if (checkIcon instanceof UIResource)
 324             checkIcon = null;
 325     }
 326 
 327     /**
 328      * Unregisters components.
 329      *
 330      * @param menuItem a menu item
 331      * @since 1.3
 332      */
 333     protected void uninstallComponents(JMenuItem menuItem){
 334         BasicHTML.updateRenderer(menuItem, &quot;&quot;);
 335     }
 336 
 337     /**
 338      * Unregisters listeners.
 339      */
 340     protected void uninstallListeners() {
 341         if (mouseInputListener != null) {
 342             menuItem.removeMouseListener(mouseInputListener);
 343             menuItem.removeMouseMotionListener(mouseInputListener);
 344         }
 345         if (menuDragMouseListener != null) {
 346             menuItem.removeMenuDragMouseListener(menuDragMouseListener);
 347         }
 348         if (menuKeyListener != null) {
 349             menuItem.removeMenuKeyListener(menuKeyListener);
 350         }
 351         if (propertyChangeListener != null) {
 352             menuItem.removePropertyChangeListener(propertyChangeListener);
 353         }
 354 
 355         mouseInputListener = null;
 356         menuDragMouseListener = null;
 357         menuKeyListener = null;
 358         propertyChangeListener = null;
 359         handler = null;
 360     }
 361 
 362     /**
 363      * Unregisters keyboard actions.
 364      */
 365     protected void uninstallKeyboardActions() {
 366         SwingUtilities.replaceUIActionMap(menuItem, null);
 367         SwingUtilities.replaceUIInputMap(menuItem, JComponent.
 368                                          WHEN_IN_FOCUSED_WINDOW, null);
 369     }
 370 
 371     /**
 372      * Returns an instance of {@code MouseInputListener}.
 373      *
 374      * @param c a component
 375      * @return an instance of {@code MouseInputListener}
 376      */
 377     protected MouseInputListener createMouseInputListener(JComponent c) {
 378         return getHandler();
 379     }
 380 
 381     /**
 382      * Returns an instance of {@code MenuDragMouseListener}.
 383      *
 384      * @param c a component
 385      * @return an instance of {@code MenuDragMouseListener}
 386      */
 387     protected MenuDragMouseListener createMenuDragMouseListener(JComponent c) {
 388         return getHandler();
 389     }
 390 
 391     /**
 392      * Returns an instance of {@code MenuKeyListener}.
 393      *
 394      * @param c a component
 395      * @return an instance of {@code MenuKeyListener}
 396      */
 397     protected MenuKeyListener createMenuKeyListener(JComponent c) {
 398         return null;
 399     }
 400 
 401     /**
 402      * Creates a {@code PropertyChangeListener} which will be added to
 403      * the menu item.
 404      * If this method returns null then it will not be added to the menu item.
 405      *
 406      * @param c a component
 407      * @return an instance of a {@code PropertyChangeListener} or null
 408      * @since 1.6
 409      */
 410     protected PropertyChangeListener
 411                                   createPropertyChangeListener(JComponent c) {
 412         return getHandler();
 413     }
 414 
 415     Handler getHandler() {
 416         if (handler == null) {
 417             handler = new Handler();
 418         }
 419         return handler;
 420     }
 421 
 422     InputMap createInputMap(int condition) {
 423         if (condition == JComponent.WHEN_IN_FOCUSED_WINDOW) {
 424             return new ComponentInputMapUIResource(menuItem);
 425         }
 426         return null;
 427     }
 428 
 429     @SuppressWarnings(&quot;deprecation&quot;)
 430     void updateAcceleratorBinding() {
 431         KeyStroke accelerator = menuItem.getAccelerator();
 432         InputMap windowInputMap = SwingUtilities.getUIInputMap(
 433                        menuItem, JComponent.WHEN_IN_FOCUSED_WINDOW);
 434 
 435         if (windowInputMap != null) {
 436             windowInputMap.clear();
 437         }
 438         if (accelerator != null) {
 439             if (windowInputMap == null) {
 440                 windowInputMap = createInputMap(JComponent.
 441                                                 WHEN_IN_FOCUSED_WINDOW);
 442                 SwingUtilities.replaceUIInputMap(menuItem,
 443                            JComponent.WHEN_IN_FOCUSED_WINDOW, windowInputMap);
 444             }
 445             windowInputMap.put(accelerator, &quot;doClick&quot;);
 446 
 447             int modifiers = accelerator.getModifiers();
 448             if (((modifiers &amp; InputEvent.ALT_DOWN_MASK) != 0) &amp;&amp;
 449                     ((modifiers &amp; InputEvent.ALT_GRAPH_DOWN_MASK) != 0)) {
 450                 //When both ALT and ALT_GRAPH are set, add the ALT only
 451                 // modifier keystroke which is used for left ALT key.
 452                 // Unsetting the ALT_GRAPH will do that as ALT is already set
 453                 modifiers &amp;= ~InputEvent.ALT_GRAPH_DOWN_MASK;
 454                 modifiers &amp;= ~InputEvent.ALT_GRAPH_MASK;
 455                 KeyStroke keyStroke = KeyStroke.getKeyStroke(accelerator.getKeyCode(),
 456                         modifiers, accelerator.isOnKeyRelease());
 457                 windowInputMap.put(keyStroke, &quot;doClick&quot;);
 458             } else if (((modifiers &amp; InputEvent.ALT_DOWN_MASK) != 0) &amp;&amp; (
 459                     (modifiers &amp; InputEvent.ALT_GRAPH_DOWN_MASK) == 0)) {
 460                 //When only ALT modifier is set, add the ALT + ALT_GRAPH
 461                 // modifier keystroke which is used for right ALT key
 462                 modifiers |= InputEvent.ALT_GRAPH_DOWN_MASK;
 463                 KeyStroke keyStroke = KeyStroke.getKeyStroke(accelerator.getKeyCode(),
 464                         modifiers, accelerator.isOnKeyRelease());
 465                 windowInputMap.put(keyStroke, &quot;doClick&quot;);
 466             } else if ((modifiers &amp; InputEvent.ALT_GRAPH_DOWN_MASK) != 0) {
 467                 //When only ALT_GRAPH is set, remove the ALT_GRAPH only
 468                 // modifier and add the ALT and ALT+ALT_GRAPH modifiers
 469                 // keystroke which are used for left ALT key and right ALT
 470                 // respectively
 471                 modifiers &amp;= ~InputEvent.ALT_GRAPH_DOWN_MASK;
 472                 modifiers &amp;= ~InputEvent.ALT_GRAPH_MASK;
 473 
 474                 modifiers |= InputEvent.ALT_DOWN_MASK;
 475                 KeyStroke keyStroke = KeyStroke.getKeyStroke(accelerator.getKeyCode(),
 476                         modifiers, accelerator.isOnKeyRelease());
 477                 windowInputMap.put(keyStroke, &quot;doClick&quot;);
 478 
 479                 //Add ALT+ALT_GRAPH modifier which is used for right ALT key
 480                 modifiers |= InputEvent.ALT_GRAPH_DOWN_MASK;
 481                 keyStroke = KeyStroke.getKeyStroke(accelerator.getKeyCode(),
 482                         modifiers, accelerator.isOnKeyRelease());
 483                 windowInputMap.put(keyStroke, &quot;doClick&quot;);
 484             }
 485         }
 486     }
 487 
 488     public Dimension getMinimumSize(JComponent c) {
 489         Dimension d = null;
 490         View v = (View) c.getClientProperty(BasicHTML.propertyKey);
 491         if (v != null) {
 492             d = getPreferredSize(c);
 493             d.width -= v.getPreferredSpan(View.X_AXIS) - v.getMinimumSpan(View.X_AXIS);
 494         }
 495         return d;
 496     }
 497 
 498     public Dimension getPreferredSize(JComponent c) {
 499         return getPreferredMenuItemSize(c,
 500                                         checkIcon,
 501                                         arrowIcon,
 502                                         defaultTextIconGap);
 503     }
 504 
 505     public Dimension getMaximumSize(JComponent c) {
 506         Dimension d = null;
 507         View v = (View) c.getClientProperty(BasicHTML.propertyKey);
 508         if (v != null) {
 509             d = getPreferredSize(c);
 510             d.width += v.getMaximumSpan(View.X_AXIS) - v.getPreferredSpan(View.X_AXIS);
 511         }
 512         return d;
 513     }
 514 
 515     /**
 516      * Returns the preferred size of a menu item.
 517      *
 518      * @param c a component
 519      * @param checkIcon a check icon
 520      * @param arrowIcon an arrow icon
 521      * @param defaultTextIconGap a gap between a text and an icon
 522      * @return the preferred size of a menu item
 523      */
 524     protected Dimension getPreferredMenuItemSize(JComponent c,
 525                                                  Icon checkIcon,
 526                                                  Icon arrowIcon,
 527                                                  int defaultTextIconGap) {
 528 
 529         // The method also determines the preferred width of the
 530         // parent popup menu (through DefaultMenuLayout class).
 531         // The menu width equals to the maximal width
 532         // among child menu items.
 533 
 534         // Menu item width will be a sum of the widest check icon, label,
 535         // arrow icon and accelerator text among neighbor menu items.
 536         // For the latest menu item we will know the maximal widths exactly.
 537         // It will be the widest menu item and it will determine
 538         // the width of the parent popup menu.
 539 
 540         // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 541         // There is a conceptual problem: if user sets preferred size manually
 542         // for a menu item, this method won&#39;t be called for it
 543         // (see JComponent.getPreferredSize()),
 544         // maximal widths won&#39;t be calculated, other menu items won&#39;t be able
 545         // to take them into account and will be layouted in such a way,
 546         // as there is no the item with manual preferred size.
 547         // But after the first paint() method call, all maximal widths
 548         // will be correctly calculated and layout of some menu items
 549         // can be changed. For example, it can cause a shift of
 550         // the icon and text when user points a menu item by mouse.
 551 
 552         JMenuItem mi = (JMenuItem) c;
 553         MenuItemLayoutHelper lh = new MenuItemLayoutHelper(mi, checkIcon,
 554                 arrowIcon, MenuItemLayoutHelper.createMaxRect(), defaultTextIconGap,
 555                 acceleratorDelimiter, BasicGraphicsUtils.isLeftToRight(mi),
 556                 mi.getFont(), acceleratorFont,
 557                 MenuItemLayoutHelper.useCheckAndArrow(menuItem),
 558                 getPropertyPrefix());
 559 
 560         Dimension result = new Dimension();
 561 
 562         // Calculate the result width
 563         result.width = lh.getLeadingGap();
 564         MenuItemLayoutHelper.addMaxWidth(lh.getCheckSize(),
 565                 lh.getAfterCheckIconGap(), result);
 566         // Take into account mimimal text offset.
 567         if ((!lh.isTopLevelMenu())
 568                 &amp;&amp; (lh.getMinTextOffset() &gt; 0)
 569                 &amp;&amp; (result.width &lt; lh.getMinTextOffset())) {
 570             result.width = lh.getMinTextOffset();
 571         }
 572         MenuItemLayoutHelper.addMaxWidth(lh.getLabelSize(), lh.getGap(), result);
 573         MenuItemLayoutHelper.addMaxWidth(lh.getAccSize(), lh.getGap(), result);
 574         MenuItemLayoutHelper.addMaxWidth(lh.getArrowSize(), lh.getGap(), result);
 575 
 576         // Calculate the result height
 577         result.height = MenuItemLayoutHelper.max(lh.getCheckSize().getHeight(),
 578                 lh.getLabelSize().getHeight(), lh.getAccSize().getHeight(),
 579                 lh.getArrowSize().getHeight());
 580 
 581         // Take into account menu item insets
 582         Insets insets = lh.getMenuItem().getInsets();
 583         if(insets != null) {
 584             result.width += insets.left + insets.right;
 585             result.height += insets.top + insets.bottom;
 586         }
 587 
 588         // if the width is even, bump it up one. This is critical
 589         // for the focus dash line to draw properly
 590         if(result.width%2 == 0) {
 591             result.width++;
 592         }
 593 
 594         // if the height is even, bump it up one. This is critical
 595         // for the text to center properly
 596         if(result.height%2 == 0
 597                 &amp;&amp; Boolean.TRUE !=
 598                     UIManager.get(getPropertyPrefix() + &quot;.evenHeight&quot;)) {
 599             result.height++;
 600         }
 601 
 602         return result;
 603     }
 604 
 605     /**
 606      * We draw the background in paintMenuItem()
 607      * so override update (which fills the background of opaque
 608      * components by default) to just call paint().
 609      *
 610      */
 611     public void update(Graphics g, JComponent c) {
 612         paint(g, c);
 613     }
 614 
 615     public void paint(Graphics g, JComponent c) {
 616         paintMenuItem(g, c, checkIcon, arrowIcon,
 617                       selectionBackground, selectionForeground,
 618                       defaultTextIconGap);
 619     }
 620 
 621     /**
 622      * Paints a menu item.
 623      *
 624      * @param g an instance of {@code Graphics}
 625      * @param c a component
 626      * @param checkIcon a check icon
 627      * @param arrowIcon an arrow icon
 628      * @param background a background color
 629      * @param foreground a foreground color
 630      * @param defaultTextIconGap a gap between a text and an icon
 631      */
 632     protected void paintMenuItem(Graphics g, JComponent c,
 633                                      Icon checkIcon, Icon arrowIcon,
 634                                      Color background, Color foreground,
 635                                      int defaultTextIconGap) {
 636         // Save original graphics font and color
 637         Font holdf = g.getFont();
 638         Color holdc = g.getColor();
 639 
 640         JMenuItem mi = (JMenuItem) c;
 641         g.setFont(mi.getFont());
 642 
 643         Rectangle viewRect = new Rectangle(0, 0, mi.getWidth(), mi.getHeight());
 644         applyInsets(viewRect, mi.getInsets());
 645 
 646         MenuItemLayoutHelper lh = new MenuItemLayoutHelper(mi, checkIcon,
 647                 arrowIcon, viewRect, defaultTextIconGap, acceleratorDelimiter,
 648                 BasicGraphicsUtils.isLeftToRight(mi), mi.getFont(),
 649                 acceleratorFont, MenuItemLayoutHelper.useCheckAndArrow(menuItem),
 650                 getPropertyPrefix());
 651         MenuItemLayoutHelper.LayoutResult lr = lh.layoutMenuItem();
 652 
 653         paintBackground(g, mi, background);
 654         paintCheckIcon(g, lh, lr, holdc, foreground);
 655         paintIcon(g, lh, lr, holdc);
 656         paintText(g, lh, lr);
 657         paintAccText(g, lh, lr);
 658         paintArrowIcon(g, lh, lr, foreground);
 659 
 660         // Restore original graphics font and color
 661         g.setColor(holdc);
 662         g.setFont(holdf);
 663     }
 664 
 665     private void paintIcon(Graphics g, MenuItemLayoutHelper lh,
 666                            MenuItemLayoutHelper.LayoutResult lr, Color holdc) {
 667         if (lh.getIcon() != null) {
 668             Icon icon;
 669             ButtonModel model = lh.getMenuItem().getModel();
 670             if (!model.isEnabled()) {
 671                 icon = lh.getMenuItem().getDisabledIcon();
 672             } else if (model.isPressed() &amp;&amp; model.isArmed()) {
 673                 icon = lh.getMenuItem().getPressedIcon();
 674                 if (icon == null) {
 675                     // Use default icon
 676                     icon = lh.getMenuItem().getIcon();
 677                 }
 678             } else {
 679                 icon = lh.getMenuItem().getIcon();
 680             }
 681 
 682             if (icon != null) {
 683                 icon.paintIcon(lh.getMenuItem(), g, lr.getIconRect().x,
 684                         lr.getIconRect().y);
 685                 g.setColor(holdc);
 686             }
 687         }
 688     }
 689 
 690     private void paintCheckIcon(Graphics g, MenuItemLayoutHelper lh,
 691                                 MenuItemLayoutHelper.LayoutResult lr,
 692                                 Color holdc, Color foreground) {
 693         if (lh.getCheckIcon() != null) {
 694             ButtonModel model = lh.getMenuItem().getModel();
 695             if (model.isArmed() || (lh.getMenuItem() instanceof JMenu
 696                     &amp;&amp; model.isSelected())) {
 697                 g.setColor(foreground);
 698             } else {
 699                 g.setColor(holdc);
 700             }
 701             if (lh.useCheckAndArrow()) {
 702                 lh.getCheckIcon().paintIcon(lh.getMenuItem(), g,
 703                         lr.getCheckRect().x, lr.getCheckRect().y);
 704             }
 705             g.setColor(holdc);
 706         }
 707     }
 708 
 709     private void paintAccText(Graphics g, MenuItemLayoutHelper lh,
 710                               MenuItemLayoutHelper.LayoutResult lr) {
 711         if (!lh.getAccText().isEmpty()) {
 712             ButtonModel model = lh.getMenuItem().getModel();
 713             g.setFont(lh.getAccFontMetrics().getFont());
 714             if (!model.isEnabled()) {
 715                 // *** paint the accText disabled
 716                 if (disabledForeground != null) {
 717                     g.setColor(disabledForeground);
 718                     SwingUtilities2.drawString(lh.getMenuItem(), g,
 719                         lh.getAccText(), lr.getAccRect().x,
 720                         lr.getAccRect().y + lh.getAccFontMetrics().getAscent());
 721                 } else {
 722                     g.setColor(lh.getMenuItem().getBackground().brighter());
 723                     SwingUtilities2.drawString(lh.getMenuItem(), g,
 724                         lh.getAccText(), lr.getAccRect().x,
 725                         lr.getAccRect().y + lh.getAccFontMetrics().getAscent());
 726                     g.setColor(lh.getMenuItem().getBackground().darker());
 727                     SwingUtilities2.drawString(lh.getMenuItem(), g,
 728                         lh.getAccText(), lr.getAccRect().x - 1,
 729                         lr.getAccRect().y + lh.getFontMetrics().getAscent() - 1);
 730                 }
 731             } else {
 732                 // *** paint the accText normally
 733                 if (model.isArmed()
 734                         || (lh.getMenuItem() instanceof JMenu
 735                         &amp;&amp; model.isSelected())) {
 736                     g.setColor(acceleratorSelectionForeground);
 737                 } else {
 738                     g.setColor(acceleratorForeground);
 739                 }
 740                 SwingUtilities2.drawString(lh.getMenuItem(), g, lh.getAccText(),
 741                         lr.getAccRect().x, lr.getAccRect().y +
 742                         lh.getAccFontMetrics().getAscent());
 743             }
 744         }
 745     }
 746 
 747     private void paintText(Graphics g, MenuItemLayoutHelper lh,
 748                            MenuItemLayoutHelper.LayoutResult lr) {
 749         if (!lh.getText().isEmpty()) {
 750             if (lh.getHtmlView() != null) {
 751                 // Text is HTML
 752                 lh.getHtmlView().paint(g, lr.getTextRect());
 753             } else {
 754                 // Text isn&#39;t HTML
 755                 paintText(g, lh.getMenuItem(), lr.getTextRect(), lh.getText());
 756             }
 757         }
 758     }
 759 
 760     private void paintArrowIcon(Graphics g, MenuItemLayoutHelper lh,
 761                                 MenuItemLayoutHelper.LayoutResult lr,
 762                                 Color foreground) {
 763         if (lh.getArrowIcon() != null) {
 764             ButtonModel model = lh.getMenuItem().getModel();
 765             if (model.isArmed() || (lh.getMenuItem() instanceof JMenu
 766                                 &amp;&amp; model.isSelected())) {
 767                 g.setColor(foreground);
 768             }
 769             if (lh.useCheckAndArrow()) {
 770                 lh.getArrowIcon().paintIcon(lh.getMenuItem(), g,
 771                         lr.getArrowRect().x, lr.getArrowRect().y);
 772             }
 773         }
 774     }
 775 
 776     private void applyInsets(Rectangle rect, Insets insets) {
 777         if(insets != null) {
 778             rect.x += insets.left;
 779             rect.y += insets.top;
 780             rect.width -= (insets.right + rect.x);
 781             rect.height -= (insets.bottom + rect.y);
 782         }
 783     }
 784 
 785     /**
 786      * Draws the background of the menu item.
 787      *
 788      * @param g the paint graphics
 789      * @param menuItem menu item to be painted
 790      * @param bgColor selection background color
 791      * @since 1.4
 792      */
 793     protected void paintBackground(Graphics g, JMenuItem menuItem, Color bgColor) {
 794         ButtonModel model = menuItem.getModel();
 795         Color oldColor = g.getColor();
 796         int menuWidth = menuItem.getWidth();
 797         int menuHeight = menuItem.getHeight();
 798 
 799         if(menuItem.isOpaque()) {
 800             if (model.isArmed()|| (menuItem instanceof JMenu &amp;&amp; model.isSelected())) {
 801                 g.setColor(bgColor);
 802                 g.fillRect(0,0, menuWidth, menuHeight);
 803             } else {
 804                 g.setColor(menuItem.getBackground());
 805                 g.fillRect(0,0, menuWidth, menuHeight);
 806             }
 807             g.setColor(oldColor);
 808         }
 809         else if (model.isArmed() || (menuItem instanceof JMenu &amp;&amp;
 810                                      model.isSelected())) {
 811             g.setColor(bgColor);
 812             g.fillRect(0,0, menuWidth, menuHeight);
 813             g.setColor(oldColor);
 814         }
 815     }
 816 
 817     /**
 818      * Renders the text of the current menu item.
 819      *
 820      * @param g graphics context
 821      * @param menuItem menu item to render
 822      * @param textRect bounding rectangle for rendering the text
 823      * @param text string to render
 824      * @since 1.4
 825      */
 826     protected void paintText(Graphics g, JMenuItem menuItem, Rectangle textRect, String text) {
 827         ButtonModel model = menuItem.getModel();
 828         FontMetrics fm = SwingUtilities2.getFontMetrics(menuItem, g);
 829         int mnemIndex = menuItem.getDisplayedMnemonicIndex();
 830 
 831         if(!model.isEnabled()) {
 832             // *** paint the text disabled
 833             if ( UIManager.get(&quot;MenuItem.disabledForeground&quot;) instanceof Color ) {
 834                 g.setColor( UIManager.getColor(&quot;MenuItem.disabledForeground&quot;) );
 835                 SwingUtilities2.drawStringUnderlineCharAt(menuItem, g,text,
 836                           mnemIndex, textRect.x,  textRect.y + fm.getAscent());
 837             } else {
 838                 g.setColor(menuItem.getBackground().brighter());
 839                 SwingUtilities2.drawStringUnderlineCharAt(menuItem, g, text,
 840                            mnemIndex, textRect.x, textRect.y + fm.getAscent());
 841                 g.setColor(menuItem.getBackground().darker());
 842                 SwingUtilities2.drawStringUnderlineCharAt(menuItem, g,text,
 843                            mnemIndex,  textRect.x - 1, textRect.y +
 844                            fm.getAscent() - 1);
 845             }
 846         } else {
 847             // *** paint the text normally
 848             if (model.isArmed()|| (menuItem instanceof JMenu &amp;&amp; model.isSelected())) {
 849                 g.setColor(selectionForeground); // Uses protected field.
 850             }
 851             SwingUtilities2.drawStringUnderlineCharAt(menuItem, g,text,
 852                            mnemIndex, textRect.x, textRect.y + fm.getAscent());
 853         }
 854     }
 855 
 856     /**
 857      * Returns a menu element path.
 858      *
 859      * @return a menu element path
 860      */
 861     public MenuElement[] getPath() {
 862         MenuSelectionManager m = MenuSelectionManager.defaultManager();
 863         MenuElement[] oldPath = m.getSelectedPath();
 864         MenuElement[] newPath;
 865         int i = oldPath.length;
 866         if (i == 0)
 867             return new MenuElement[0];
 868         Component parent = menuItem.getParent();
 869         if (oldPath[i-1].getComponent() == parent) {
 870             // The parent popup menu is the last so far
 871             newPath = new MenuElement[i+1];
 872             System.arraycopy(oldPath, 0, newPath, 0, i);
 873             newPath[i] = menuItem;
 874         } else {
 875             // A sibling menuitem is the current selection
 876             //
 877             //  This probably needs to handle &#39;exit submenu into
 878             // a menu item.  Search backwards along the current
 879             // selection until you find the parent popup menu,
 880             // then copy up to that and add yourself...
 881             int j;
 882             for (j = oldPath.length-1; j &gt;= 0; j--) {
 883                 if (oldPath[j].getComponent() == parent)
 884                     break;
 885             }
 886             newPath = new MenuElement[j+2];
 887             System.arraycopy(oldPath, 0, newPath, 0, j+1);
 888             newPath[j+1] = menuItem;
 889             /*
 890             System.out.println(&quot;Sibling condition -- &quot;);
 891             System.out.println(&quot;Old array : &quot;);
 892             printMenuElementArray(oldPath, false);
 893             System.out.println(&quot;New array : &quot;);
 894             printMenuElementArray(newPath, false);
 895             */
 896         }
 897         return newPath;
 898     }
 899 
 900     void printMenuElementArray(MenuElement[] path, boolean dumpStack) {
 901         System.out.println(&quot;Path is(&quot;);
 902         int i, j;
 903         for(i=0,j=path.length; i&lt;j ;i++){
 904             for (int k=0; k&lt;=i; k++)
 905                 System.out.print(&quot;  &quot;);
 906             MenuElement me = path[i];
 907             if(me instanceof JMenuItem)
 908                 System.out.println(((JMenuItem)me).getText() + &quot;, &quot;);
 909             else if (me == null)
 910                 System.out.println(&quot;NULL , &quot;);
 911             else
 912                 System.out.println(&quot;&quot; + me + &quot;, &quot;);
 913         }
 914         System.out.println(&quot;)&quot;);
 915 
 916         if (dumpStack == true)
 917             Thread.dumpStack();
 918     }
 919     /** Mouse input handler */
 920     protected class MouseInputHandler implements MouseInputListener {
 921         // NOTE: This class exists only for backward compatibility. All
 922         // its functionality has been moved into Handler. If you need to add
 923         // new functionality add it to the Handler, but make sure this
 924         // class calls into the Handler.
 925 
 926         /** {@inheritDoc} */
 927         public void mouseClicked(MouseEvent e) {
 928             getHandler().mouseClicked(e);
 929         }
 930         /** {@inheritDoc} */
 931         public void mousePressed(MouseEvent e) {
 932             getHandler().mousePressed(e);
 933         }
 934         /** {@inheritDoc} */
 935         public void mouseReleased(MouseEvent e) {
 936             getHandler().mouseReleased(e);
 937         }
 938         /** {@inheritDoc} */
 939         public void mouseEntered(MouseEvent e) {
 940             getHandler().mouseEntered(e);
 941         }
 942         /** {@inheritDoc} */
 943         public void mouseExited(MouseEvent e) {
 944             getHandler().mouseExited(e);
 945         }
 946         /** {@inheritDoc} */
 947         public void mouseDragged(MouseEvent e) {
 948             getHandler().mouseDragged(e);
 949         }
 950         /** {@inheritDoc} */
 951         public void mouseMoved(MouseEvent e) {
 952             getHandler().mouseMoved(e);
 953         }
 954     }
 955 
 956 
 957     private static class Actions extends UIAction {
 958         private static final String CLICK = &quot;doClick&quot;;
 959 
 960         Actions(String key) {
 961             super(key);
 962         }
 963 
 964         public void actionPerformed(ActionEvent e) {
 965             JMenuItem mi = (JMenuItem)e.getSource();
 966             MenuSelectionManager.defaultManager().clearSelectedPath();
 967             mi.doClick();
 968         }
 969     }
 970 
 971     boolean doNotCloseOnMouseClick() {
 972         if (menuItem instanceof JCheckBoxMenuItem) {
 973             String property = &quot;CheckBoxMenuItem.doNotCloseOnMouseClick&quot;;
 974             return SwingUtilities2.getBoolean(menuItem, property);
 975         } else if (menuItem instanceof JRadioButtonMenuItem) {
 976             String property = &quot;RadioButtonMenuItem.doNotCloseOnMouseClick&quot;;
 977             return SwingUtilities2.getBoolean(menuItem, property);
 978         }
 979         return false;
 980     }
 981 
 982     /**
 983      * Call this method when a menu item is to be activated.
 984      * This method handles some of the details of menu item activation
 985      * such as clearing the selected path and messaging the
 986      * JMenuItem&#39;s doClick() method.
 987      *
 988      * @param msm  A MenuSelectionManager. The visual feedback and
 989      *             internal bookkeeping tasks are delegated to
 990      *             this MenuSelectionManager. If &lt;code&gt;null&lt;/code&gt; is
 991      *             passed as this argument, the
 992      *             &lt;code&gt;MenuSelectionManager.defaultManager&lt;/code&gt; is
 993      *             used.
 994      * @see MenuSelectionManager
 995      * @see JMenuItem#doClick(int)
 996      * @since 1.4
 997      */
 998     protected void doClick(MenuSelectionManager msm) {
 999         // Auditory cue
1000         if (! isInternalFrameSystemMenu()) {
1001             BasicLookAndFeel.playSound(menuItem, getPropertyPrefix() +
1002                                        &quot;.commandSound&quot;);
1003         }
1004         if (!doNotCloseOnMouseClick()) {
1005             // Visual feedback
1006             if (msm == null) {
1007                 msm = MenuSelectionManager.defaultManager();
1008             }
1009 
1010             msm.clearSelectedPath();
1011         }
1012         menuItem.doClick(0);
1013     }
1014 
1015     /**
1016      * This is to see if the menu item in question is part of the
1017      * system menu on an internal frame.
1018      * The Strings that are being checked can be found in
1019      * MetalInternalFrameTitlePaneUI.java,
1020      * WindowsInternalFrameTitlePaneUI.java, and
1021      * MotifInternalFrameTitlePaneUI.java.
1022      *
1023      * @since 1.4
1024      */
1025     private boolean isInternalFrameSystemMenu() {
1026         String actionCommand = menuItem.getActionCommand();
1027         if ((actionCommand == &quot;Close&quot;) ||
1028             (actionCommand == &quot;Minimize&quot;) ||
1029             (actionCommand == &quot;Restore&quot;) ||
1030             (actionCommand == &quot;Maximize&quot;)) {
1031           return true;
1032         } else {
1033           return false;
1034         }
1035     }
1036 
1037 
1038     // BasicMenuUI subclasses this.
1039     class Handler implements MenuDragMouseListener,
1040                           MouseInputListener, PropertyChangeListener {
1041         //
1042         // MouseInputListener
1043         //
1044         public void mouseClicked(MouseEvent e) {}
1045         public void mousePressed(MouseEvent e) {
1046         }
1047         public void mouseReleased(MouseEvent e) {
1048             if (!menuItem.isEnabled()) {
1049                 return;
1050             }
1051             MenuSelectionManager manager =
1052                 MenuSelectionManager.defaultManager();
1053             Point p = e.getPoint();
1054             if(p.x &gt;= 0 &amp;&amp; p.x &lt; menuItem.getWidth() &amp;&amp;
1055                p.y &gt;= 0 &amp;&amp; p.y &lt; menuItem.getHeight()) {
1056                 doClick(manager);
1057             } else {
1058                 manager.processMouseEvent(e);
1059             }
1060         }
1061         @SuppressWarnings(&quot;deprecation&quot;)
1062         public void mouseEntered(MouseEvent e) {
1063             MenuSelectionManager manager = MenuSelectionManager.defaultManager();
1064             int modifiers = e.getModifiers();
1065             // 4188027: drag enter/exit added in JDK 1.1.7A, JDK1.2
1066             if ((modifiers &amp; (InputEvent.BUTTON1_MASK |
1067                               InputEvent.BUTTON2_MASK | InputEvent.BUTTON3_MASK)) !=0 ) {
1068                 MenuSelectionManager.defaultManager().processMouseEvent(e);
1069             } else {
1070             manager.setSelectedPath(getPath());
1071              }
1072         }
1073         @SuppressWarnings(&quot;deprecation&quot;)
1074         public void mouseExited(MouseEvent e) {
1075             MenuSelectionManager manager = MenuSelectionManager.defaultManager();
1076 
1077             int modifiers = e.getModifiers();
1078             // 4188027: drag enter/exit added in JDK 1.1.7A, JDK1.2
1079             if ((modifiers &amp; (InputEvent.BUTTON1_MASK |
1080                               InputEvent.BUTTON2_MASK | InputEvent.BUTTON3_MASK)) !=0 ) {
1081                 MenuSelectionManager.defaultManager().processMouseEvent(e);
1082             } else {
1083 
1084                 MenuElement[] path = manager.getSelectedPath();
1085                 if (path.length &gt; 1 &amp;&amp; path[path.length-1] == menuItem) {
1086                     MenuElement[] newPath = new MenuElement[path.length-1];
1087                     int i,c;
1088                     for(i=0,c=path.length-1;i&lt;c;i++)
1089                         newPath[i] = path[i];
1090                     manager.setSelectedPath(newPath);
1091                 }
1092                 }
1093         }
1094 
1095         public void mouseDragged(MouseEvent e) {
1096             MenuSelectionManager.defaultManager().processMouseEvent(e);
1097         }
1098         public void mouseMoved(MouseEvent e) {
1099         }
1100 
1101         //
1102         // MenuDragListener
1103         //
1104         public void menuDragMouseEntered(MenuDragMouseEvent e) {
1105             MenuSelectionManager manager = e.getMenuSelectionManager();
1106             MenuElement[] path = e.getPath();
1107             manager.setSelectedPath(path);
1108         }
1109         public void menuDragMouseDragged(MenuDragMouseEvent e) {
1110             MenuSelectionManager manager = e.getMenuSelectionManager();
1111             MenuElement[] path = e.getPath();
1112             manager.setSelectedPath(path);
1113         }
1114         public void menuDragMouseExited(MenuDragMouseEvent e) {}
1115         public void menuDragMouseReleased(MenuDragMouseEvent e) {
1116             if (!menuItem.isEnabled()) {
1117                 return;
1118             }
1119             MenuSelectionManager manager = e.getMenuSelectionManager();
1120             MenuElement[] path = e.getPath();
1121             Point p = e.getPoint();
1122             if (p.x &gt;= 0 &amp;&amp; p.x &lt; menuItem.getWidth() &amp;&amp;
1123                     p.y &gt;= 0 &amp;&amp; p.y &lt; menuItem.getHeight()) {
1124                 doClick(manager);
1125             } else {
1126                 manager.clearSelectedPath();
1127             }
1128         }
1129 
1130 
1131         //
1132         // PropertyChangeListener
1133         //
1134         public void propertyChange(PropertyChangeEvent e) {
1135             String name = e.getPropertyName();
1136 
1137             if (name == &quot;labelFor&quot; || name == &quot;displayedMnemonic&quot; ||
1138                 name == &quot;accelerator&quot;) {
1139                 updateAcceleratorBinding();
1140             } else if (name == &quot;text&quot; || &quot;font&quot; == name || &quot;foreground&quot; == name
1141                     || SwingUtilities2.isScaleChanged(e)) {
1142                 // remove the old html view client property if one
1143                 // existed, and install a new one if the text installed
1144                 // into the JLabel is html source.
1145                 JMenuItem lbl = ((JMenuItem) e.getSource());
1146                 String text = lbl.getText();
1147                 BasicHTML.updateRenderer(lbl, text);
1148             } else if (name  == &quot;iconTextGap&quot;) {
1149                 defaultTextIconGap = ((Number)e.getNewValue()).intValue();
<a name="2" id="anc2"></a>

1150             }
1151         }
1152     }
1153 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
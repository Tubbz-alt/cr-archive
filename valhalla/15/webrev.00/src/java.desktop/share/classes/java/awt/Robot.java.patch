diff a/src/java.desktop/share/classes/java/awt/Robot.java b/src/java.desktop/share/classes/java/awt/Robot.java
--- a/src/java.desktop/share/classes/java/awt/Robot.java
+++ b/src/java.desktop/share/classes/java/awt/Robot.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -88,13 +88,11 @@
      * @see     java.awt.GraphicsEnvironment#isHeadless
      * @see     SecurityManager#checkPermission
      * @see     AWTPermission
      */
     public Robot() throws AWTException {
-        if (GraphicsEnvironment.isHeadless()) {
-            throw new AWTException("headless environment");
-        }
+        checkHeadless();
         init(GraphicsEnvironment.getLocalGraphicsEnvironment()
             .getDefaultScreenDevice());
     }
 
     /**
@@ -123,19 +121,20 @@
      * @see     GraphicsDevice
      * @see     SecurityManager#checkPermission
      * @see     AWTPermission
      */
     public Robot(GraphicsDevice screen) throws AWTException {
+        checkHeadless();
         checkIsScreenDevice(screen);
         init(screen);
     }
 
     private void init(GraphicsDevice screen) throws AWTException {
         checkRobotAllowed();
         Toolkit toolkit = Toolkit.getDefaultToolkit();
         if (toolkit instanceof ComponentFactory) {
-            peer = ((ComponentFactory)toolkit).createRobot(this, screen);
+            peer = ((ComponentFactory)toolkit).createRobot(screen);
         }
         initLegalButtonMask();
     }
 
     @SuppressWarnings("deprecation")
@@ -159,19 +158,28 @@
             InputEvent.BUTTON3_DOWN_MASK;
         LEGAL_BUTTON_MASK = tmpMask;
     }
 
     /* determine if the security policy allows Robot's to be created */
-    private void checkRobotAllowed() {
+    private static void checkRobotAllowed() {
         SecurityManager security = System.getSecurityManager();
         if (security != null) {
             security.checkPermission(AWTPermissions.CREATE_ROBOT_PERMISSION);
         }
     }
 
+    /**
+     * Check for headless state and throw {@code AWTException} if headless.
+     */
+    private static void checkHeadless() throws AWTException {
+        if (GraphicsEnvironment.isHeadless()) {
+            throw new AWTException("headless environment");
+        }
+    }
+
     /* check if the given device is a screen device */
-    private void checkIsScreenDevice(GraphicsDevice device) {
+    private static void checkIsScreenDevice(GraphicsDevice device) {
         if (device == null || device.getType() != GraphicsDevice.TYPE_RASTER_SCREEN) {
             throw new IllegalArgumentException("not a valid screen device");
         }
     }
 
@@ -298,11 +306,11 @@
         checkButtonsArgument(buttons);
         peer.mouseRelease(buttons);
         afterEvent();
     }
 
-    private void checkButtonsArgument(int buttons) {
+    private static void checkButtonsArgument(int buttons) {
         if ( (buttons|LEGAL_BUTTON_MASK) != LEGAL_BUTTON_MASK ) {
             throw new IllegalArgumentException("Invalid combination of button flags");
         }
     }
 
@@ -357,11 +365,11 @@
         checkKeycodeArgument(keycode);
         peer.keyRelease(keycode);
         afterEvent();
     }
 
-    private void checkKeycodeArgument(int keycode) {
+    private static void checkKeycodeArgument(int keycode) {
         // rather than build a big table or switch statement here, we'll
         // just check that the key isn't VK_UNDEFINED and assume that the
         // peer implementations will throw an exception for other bogus
         // values e.g. -1, 999999
         if (keycode == KeyEvent.VK_UNDEFINED) {
@@ -662,11 +670,11 @@
                 thread.interrupt(); // Preserve interrupt status
             }
         }
     }
 
-    private void checkDelayArgument(int ms) {
+    private static void checkDelayArgument(int ms) {
         if (ms < 0 || ms > MAX_DELAY) {
             throw new IllegalArgumentException("Delay must be to 0 to 60,000ms");
         }
     }
 
@@ -678,11 +686,11 @@
         checkNotDispatchThread();
         SunToolkit.flushPendingEvents();
         ((SunToolkit) Toolkit.getDefaultToolkit()).realSync();
     }
 
-    private void checkNotDispatchThread() {
+    private static void checkNotDispatchThread() {
         if (EventQueue.isDispatchThread()) {
             throw new IllegalThreadStateException("Cannot call method from the event dispatcher thread");
         }
     }
 

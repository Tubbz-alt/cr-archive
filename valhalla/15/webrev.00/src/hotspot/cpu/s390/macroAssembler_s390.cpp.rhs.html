<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/s390/macroAssembler_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2016, 2019, SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/codeBuffer.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  32 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
  36 #include &quot;memory/universe.hpp&quot;
  37 #include &quot;oops/accessDecorators.hpp&quot;
  38 #include &quot;oops/compressedOops.inline.hpp&quot;
  39 #include &quot;oops/klass.inline.hpp&quot;
<a name="1" id="anc1"></a>




  40 #include &quot;prims/methodHandles.hpp&quot;
  41 #include &quot;registerSaver_s390.hpp&quot;
  42 #include &quot;runtime/biasedLocking.hpp&quot;
  43 #include &quot;runtime/icache.hpp&quot;
  44 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  45 #include &quot;runtime/objectMonitor.hpp&quot;
  46 #include &quot;runtime/os.hpp&quot;
  47 #include &quot;runtime/safepoint.hpp&quot;
  48 #include &quot;runtime/safepointMechanism.hpp&quot;
  49 #include &quot;runtime/sharedRuntime.hpp&quot;
  50 #include &quot;runtime/stubRoutines.hpp&quot;
  51 #include &quot;utilities/events.hpp&quot;
  52 #include &quot;utilities/macros.hpp&quot;
  53 #include &quot;utilities/powerOfTwo.hpp&quot;
  54 
  55 #include &lt;ucontext.h&gt;
  56 
  57 #define BLOCK_COMMENT(str) block_comment(str)
  58 #define BIND(label)        bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  59 
  60 // Move 32-bit register if destination and source are different.
  61 void MacroAssembler::lr_if_needed(Register rd, Register rs) {
  62   if (rs != rd) { z_lr(rd, rs); }
  63 }
  64 
  65 // Move register if destination and source are different.
  66 void MacroAssembler::lgr_if_needed(Register rd, Register rs) {
  67   if (rs != rd) { z_lgr(rd, rs); }
  68 }
  69 
  70 // Zero-extend 32-bit register into 64-bit register if destination and source are different.
  71 void MacroAssembler::llgfr_if_needed(Register rd, Register rs) {
  72   if (rs != rd) { z_llgfr(rd, rs); }
  73 }
  74 
  75 // Move float register if destination and source are different.
  76 void MacroAssembler::ldr_if_needed(FloatRegister rd, FloatRegister rs) {
  77   if (rs != rd) { z_ldr(rd, rs); }
  78 }
  79 
  80 // Move integer register if destination and source are different.
  81 // It is assumed that shorter-than-int types are already
  82 // appropriately sign-extended.
  83 void MacroAssembler::move_reg_if_needed(Register dst, BasicType dst_type, Register src,
  84                                         BasicType src_type) {
  85   assert((dst_type != T_FLOAT) &amp;&amp; (dst_type != T_DOUBLE), &quot;use move_freg for float types&quot;);
  86   assert((src_type != T_FLOAT) &amp;&amp; (src_type != T_DOUBLE), &quot;use move_freg for float types&quot;);
  87 
  88   if (dst_type == src_type) {
  89     lgr_if_needed(dst, src); // Just move all 64 bits.
  90     return;
  91   }
  92 
  93   switch (dst_type) {
  94     // Do not support these types for now.
  95     //  case T_BOOLEAN:
  96     case T_BYTE:  // signed byte
  97       switch (src_type) {
  98         case T_INT:
  99           z_lgbr(dst, src);
 100           break;
 101         default:
 102           ShouldNotReachHere();
 103       }
 104       return;
 105 
 106     case T_CHAR:
 107     case T_SHORT:
 108       switch (src_type) {
 109         case T_INT:
 110           if (dst_type == T_CHAR) {
 111             z_llghr(dst, src);
 112           } else {
 113             z_lghr(dst, src);
 114           }
 115           break;
 116         default:
 117           ShouldNotReachHere();
 118       }
 119       return;
 120 
 121     case T_INT:
 122       switch (src_type) {
 123         case T_BOOLEAN:
 124         case T_BYTE:
 125         case T_CHAR:
 126         case T_SHORT:
 127         case T_INT:
 128         case T_LONG:
 129         case T_OBJECT:
 130         case T_ARRAY:
 131         case T_VOID:
 132         case T_ADDRESS:
 133           lr_if_needed(dst, src);
 134           // llgfr_if_needed(dst, src);  // zero-extend (in case we need to find a bug).
 135           return;
 136 
 137         default:
 138           assert(false, &quot;non-integer src type&quot;);
 139           return;
 140       }
 141     case T_LONG:
 142       switch (src_type) {
 143         case T_BOOLEAN:
 144         case T_BYTE:
 145         case T_CHAR:
 146         case T_SHORT:
 147         case T_INT:
 148           z_lgfr(dst, src); // sign extension
 149           return;
 150 
 151         case T_LONG:
 152         case T_OBJECT:
 153         case T_ARRAY:
 154         case T_VOID:
 155         case T_ADDRESS:
 156           lgr_if_needed(dst, src);
 157           return;
 158 
 159         default:
 160           assert(false, &quot;non-integer src type&quot;);
 161           return;
 162       }
 163       return;
 164     case T_OBJECT:
 165     case T_ARRAY:
 166     case T_VOID:
 167     case T_ADDRESS:
 168       switch (src_type) {
 169         // These types don&#39;t make sense to be converted to pointers:
 170         //      case T_BOOLEAN:
 171         //      case T_BYTE:
 172         //      case T_CHAR:
 173         //      case T_SHORT:
 174 
 175         case T_INT:
 176           z_llgfr(dst, src); // zero extension
 177           return;
 178 
 179         case T_LONG:
 180         case T_OBJECT:
 181         case T_ARRAY:
 182         case T_VOID:
 183         case T_ADDRESS:
 184           lgr_if_needed(dst, src);
 185           return;
 186 
 187         default:
 188           assert(false, &quot;non-integer src type&quot;);
 189           return;
 190       }
 191       return;
 192     default:
 193       assert(false, &quot;non-integer dst type&quot;);
 194       return;
 195   }
 196 }
 197 
 198 // Move float register if destination and source are different.
 199 void MacroAssembler::move_freg_if_needed(FloatRegister dst, BasicType dst_type,
 200                                          FloatRegister src, BasicType src_type) {
 201   assert((dst_type == T_FLOAT) || (dst_type == T_DOUBLE), &quot;use move_reg for int types&quot;);
 202   assert((src_type == T_FLOAT) || (src_type == T_DOUBLE), &quot;use move_reg for int types&quot;);
 203   if (dst_type == src_type) {
 204     ldr_if_needed(dst, src); // Just move all 64 bits.
 205   } else {
 206     switch (dst_type) {
 207       case T_FLOAT:
 208         assert(src_type == T_DOUBLE, &quot;invalid float type combination&quot;);
 209         z_ledbr(dst, src);
 210         return;
 211       case T_DOUBLE:
 212         assert(src_type == T_FLOAT, &quot;invalid float type combination&quot;);
 213         z_ldebr(dst, src);
 214         return;
 215       default:
 216         assert(false, &quot;non-float dst type&quot;);
 217         return;
 218     }
 219   }
 220 }
 221 
 222 // Optimized emitter for reg to mem operations.
 223 // Uses modern instructions if running on modern hardware, classic instructions
 224 // otherwise. Prefers (usually shorter) classic instructions if applicable.
 225 // Data register (reg) cannot be used as work register.
 226 //
 227 // Don&#39;t rely on register locking, instead pass a scratch register (Z_R0 by default).
 228 // CAUTION! Passing registers &gt;= Z_R2 may produce bad results on old CPUs!
 229 void MacroAssembler::freg2mem_opt(FloatRegister reg,
 230                                   int64_t       disp,
 231                                   Register      index,
 232                                   Register      base,
 233                                   void (MacroAssembler::*modern) (FloatRegister, int64_t, Register, Register),
 234                                   void (MacroAssembler::*classic)(FloatRegister, int64_t, Register, Register),
 235                                   Register      scratch) {
 236   index = (index == noreg) ? Z_R0 : index;
 237   if (Displacement::is_shortDisp(disp)) {
 238     (this-&gt;*classic)(reg, disp, index, base);
 239   } else {
 240     if (Displacement::is_validDisp(disp)) {
 241       (this-&gt;*modern)(reg, disp, index, base);
 242     } else {
 243       if (scratch != Z_R0 &amp;&amp; scratch != Z_R1) {
 244         (this-&gt;*modern)(reg, disp, index, base);      // Will fail with disp out of range.
 245       } else {
 246         if (scratch != Z_R0) {   // scratch == Z_R1
 247           if ((scratch == index) || (index == base)) {
 248             (this-&gt;*modern)(reg, disp, index, base);  // Will fail with disp out of range.
 249           } else {
 250             add2reg(scratch, disp, base);
 251             (this-&gt;*classic)(reg, 0, index, scratch);
 252             if (base == scratch) {
 253               add2reg(base, -disp);  // Restore base.
 254             }
 255           }
 256         } else {   // scratch == Z_R0
 257           z_lgr(scratch, base);
 258           add2reg(base, disp);
 259           (this-&gt;*classic)(reg, 0, index, base);
 260           z_lgr(base, scratch);      // Restore base.
 261         }
 262       }
 263     }
 264   }
 265 }
 266 
 267 void MacroAssembler::freg2mem_opt(FloatRegister reg, const Address &amp;a, bool is_double) {
 268   if (is_double) {
 269     freg2mem_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_FFUN(z_stdy), CLASSIC_FFUN(z_std));
 270   } else {
 271     freg2mem_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_FFUN(z_stey), CLASSIC_FFUN(z_ste));
 272   }
 273 }
 274 
 275 // Optimized emitter for mem to reg operations.
 276 // Uses modern instructions if running on modern hardware, classic instructions
 277 // otherwise. Prefers (usually shorter) classic instructions if applicable.
 278 // data register (reg) cannot be used as work register.
 279 //
 280 // Don&#39;t rely on register locking, instead pass a scratch register (Z_R0 by default).
 281 // CAUTION! Passing registers &gt;= Z_R2 may produce bad results on old CPUs!
 282 void MacroAssembler::mem2freg_opt(FloatRegister reg,
 283                                   int64_t       disp,
 284                                   Register      index,
 285                                   Register      base,
 286                                   void (MacroAssembler::*modern) (FloatRegister, int64_t, Register, Register),
 287                                   void (MacroAssembler::*classic)(FloatRegister, int64_t, Register, Register),
 288                                   Register      scratch) {
 289   index = (index == noreg) ? Z_R0 : index;
 290   if (Displacement::is_shortDisp(disp)) {
 291     (this-&gt;*classic)(reg, disp, index, base);
 292   } else {
 293     if (Displacement::is_validDisp(disp)) {
 294       (this-&gt;*modern)(reg, disp, index, base);
 295     } else {
 296       if (scratch != Z_R0 &amp;&amp; scratch != Z_R1) {
 297         (this-&gt;*modern)(reg, disp, index, base);      // Will fail with disp out of range.
 298       } else {
 299         if (scratch != Z_R0) {   // scratch == Z_R1
 300           if ((scratch == index) || (index == base)) {
 301             (this-&gt;*modern)(reg, disp, index, base);  // Will fail with disp out of range.
 302           } else {
 303             add2reg(scratch, disp, base);
 304             (this-&gt;*classic)(reg, 0, index, scratch);
 305             if (base == scratch) {
 306               add2reg(base, -disp);  // Restore base.
 307             }
 308           }
 309         } else {   // scratch == Z_R0
 310           z_lgr(scratch, base);
 311           add2reg(base, disp);
 312           (this-&gt;*classic)(reg, 0, index, base);
 313           z_lgr(base, scratch);      // Restore base.
 314         }
 315       }
 316     }
 317   }
 318 }
 319 
 320 void MacroAssembler::mem2freg_opt(FloatRegister reg, const Address &amp;a, bool is_double) {
 321   if (is_double) {
 322     mem2freg_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_FFUN(z_ldy), CLASSIC_FFUN(z_ld));
 323   } else {
 324     mem2freg_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_FFUN(z_ley), CLASSIC_FFUN(z_le));
 325   }
 326 }
 327 
 328 // Optimized emitter for reg to mem operations.
 329 // Uses modern instructions if running on modern hardware, classic instructions
 330 // otherwise. Prefers (usually shorter) classic instructions if applicable.
 331 // Data register (reg) cannot be used as work register.
 332 //
 333 // Don&#39;t rely on register locking, instead pass a scratch register
 334 // (Z_R0 by default)
 335 // CAUTION! passing registers &gt;= Z_R2 may produce bad results on old CPUs!
 336 void MacroAssembler::reg2mem_opt(Register reg,
 337                                  int64_t  disp,
 338                                  Register index,
 339                                  Register base,
 340                                  void (MacroAssembler::*modern) (Register, int64_t, Register, Register),
 341                                  void (MacroAssembler::*classic)(Register, int64_t, Register, Register),
 342                                  Register scratch) {
 343   index = (index == noreg) ? Z_R0 : index;
 344   if (Displacement::is_shortDisp(disp)) {
 345     (this-&gt;*classic)(reg, disp, index, base);
 346   } else {
 347     if (Displacement::is_validDisp(disp)) {
 348       (this-&gt;*modern)(reg, disp, index, base);
 349     } else {
 350       if (scratch != Z_R0 &amp;&amp; scratch != Z_R1) {
 351         (this-&gt;*modern)(reg, disp, index, base);      // Will fail with disp out of range.
 352       } else {
 353         if (scratch != Z_R0) {   // scratch == Z_R1
 354           if ((scratch == index) || (index == base)) {
 355             (this-&gt;*modern)(reg, disp, index, base);  // Will fail with disp out of range.
 356           } else {
 357             add2reg(scratch, disp, base);
 358             (this-&gt;*classic)(reg, 0, index, scratch);
 359             if (base == scratch) {
 360               add2reg(base, -disp);  // Restore base.
 361             }
 362           }
 363         } else {   // scratch == Z_R0
 364           if ((scratch == reg) || (scratch == base) || (reg == base)) {
 365             (this-&gt;*modern)(reg, disp, index, base);  // Will fail with disp out of range.
 366           } else {
 367             z_lgr(scratch, base);
 368             add2reg(base, disp);
 369             (this-&gt;*classic)(reg, 0, index, base);
 370             z_lgr(base, scratch);    // Restore base.
 371           }
 372         }
 373       }
 374     }
 375   }
 376 }
 377 
 378 int MacroAssembler::reg2mem_opt(Register reg, const Address &amp;a, bool is_double) {
 379   int store_offset = offset();
 380   if (is_double) {
 381     reg2mem_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_IFUN(z_stg), CLASSIC_IFUN(z_stg));
 382   } else {
 383     reg2mem_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_IFUN(z_sty), CLASSIC_IFUN(z_st));
 384   }
 385   return store_offset;
 386 }
 387 
 388 // Optimized emitter for mem to reg operations.
 389 // Uses modern instructions if running on modern hardware, classic instructions
 390 // otherwise. Prefers (usually shorter) classic instructions if applicable.
 391 // Data register (reg) will be used as work register where possible.
 392 void MacroAssembler::mem2reg_opt(Register reg,
 393                                  int64_t  disp,
 394                                  Register index,
 395                                  Register base,
 396                                  void (MacroAssembler::*modern) (Register, int64_t, Register, Register),
 397                                  void (MacroAssembler::*classic)(Register, int64_t, Register, Register)) {
 398   index = (index == noreg) ? Z_R0 : index;
 399   if (Displacement::is_shortDisp(disp)) {
 400     (this-&gt;*classic)(reg, disp, index, base);
 401   } else {
 402     if (Displacement::is_validDisp(disp)) {
 403       (this-&gt;*modern)(reg, disp, index, base);
 404     } else {
 405       if ((reg == index) &amp;&amp; (reg == base)) {
 406         z_sllg(reg, reg, 1);
 407         add2reg(reg, disp);
 408         (this-&gt;*classic)(reg, 0, noreg, reg);
 409       } else if ((reg == index) &amp;&amp; (reg != Z_R0)) {
 410         add2reg(reg, disp);
 411         (this-&gt;*classic)(reg, 0, reg, base);
 412       } else if (reg == base) {
 413         add2reg(reg, disp);
 414         (this-&gt;*classic)(reg, 0, index, reg);
 415       } else if (reg != Z_R0) {
 416         add2reg(reg, disp, base);
 417         (this-&gt;*classic)(reg, 0, index, reg);
 418       } else { // reg == Z_R0 &amp;&amp; reg != base here
 419         add2reg(base, disp);
 420         (this-&gt;*classic)(reg, 0, index, base);
 421         add2reg(base, -disp);
 422       }
 423     }
 424   }
 425 }
 426 
 427 void MacroAssembler::mem2reg_opt(Register reg, const Address &amp;a, bool is_double) {
 428   if (is_double) {
 429     z_lg(reg, a);
 430   } else {
 431     mem2reg_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_IFUN(z_ly), CLASSIC_IFUN(z_l));
 432   }
 433 }
 434 
 435 void MacroAssembler::mem2reg_signed_opt(Register reg, const Address &amp;a) {
 436   mem2reg_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_IFUN(z_lgf), CLASSIC_IFUN(z_lgf));
 437 }
 438 
 439 void MacroAssembler::and_imm(Register r, long mask,
 440                              Register tmp /* = Z_R0 */,
 441                              bool wide    /* = false */) {
 442   assert(wide || Immediate::is_simm32(mask), &quot;mask value too large&quot;);
 443 
 444   if (!wide) {
 445     z_nilf(r, mask);
 446     return;
 447   }
 448 
 449   assert(r != tmp, &quot; need a different temporary register !&quot;);
 450   load_const_optimized(tmp, mask);
 451   z_ngr(r, tmp);
 452 }
 453 
 454 // Calculate the 1&#39;s complement.
 455 // Note: The condition code is neither preserved nor correctly set by this code!!!
 456 // Note: (wide == false) does not protect the high order half of the target register
 457 //       from alteration. It only serves as optimization hint for 32-bit results.
 458 void MacroAssembler::not_(Register r1, Register r2, bool wide) {
 459 
 460   if ((r2 == noreg) || (r2 == r1)) { // Calc 1&#39;s complement in place.
 461     z_xilf(r1, -1);
 462     if (wide) {
 463       z_xihf(r1, -1);
 464     }
 465   } else { // Distinct src and dst registers.
 466     load_const_optimized(r1, -1);
 467     z_xgr(r1, r2);
 468   }
 469 }
 470 
 471 unsigned long MacroAssembler::create_mask(int lBitPos, int rBitPos) {
 472   assert(lBitPos &gt;=  0,      &quot;zero is  leftmost bit position&quot;);
 473   assert(rBitPos &lt;= 63,      &quot;63   is rightmost bit position&quot;);
 474   assert(lBitPos &lt;= rBitPos, &quot;inverted selection interval&quot;);
 475   return (lBitPos == 0 ? (unsigned long)(-1L) : ((1UL&lt;&lt;(63-lBitPos+1))-1)) &amp; (~((1UL&lt;&lt;(63-rBitPos))-1));
 476 }
 477 
 478 // Helper function for the &quot;Rotate_then_&lt;logicalOP&gt;&quot; emitters.
 479 // Rotate src, then mask register contents such that only bits in range survive.
 480 // For oneBits == false, all bits not in range are set to 0. Useful for deleting all bits outside range.
 481 // For oneBits == true,  all bits not in range are set to 1. Useful for preserving all bits outside range.
 482 // The caller must ensure that the selected range only contains bits with defined value.
 483 void MacroAssembler::rotate_then_mask(Register dst, Register src, int lBitPos, int rBitPos,
 484                                       int nRotate, bool src32bit, bool dst32bit, bool oneBits) {
 485   assert(!(dst32bit &amp;&amp; lBitPos &lt; 32), &quot;selection interval out of range for int destination&quot;);
 486   bool sll4rll = (nRotate &gt;= 0) &amp;&amp; (nRotate &lt;= (63-rBitPos)); // Substitute SLL(G) for RLL(G).
 487   bool srl4rll = (nRotate &lt;  0) &amp;&amp; (-nRotate &lt;= lBitPos);     // Substitute SRL(G) for RLL(G).
 488   //  Pre-determine which parts of dst will be zero after shift/rotate.
 489   bool llZero  =  sll4rll &amp;&amp; (nRotate &gt;= 16);
 490   bool lhZero  = (sll4rll &amp;&amp; (nRotate &gt;= 32)) || (srl4rll &amp;&amp; (nRotate &lt;= -48));
 491   bool lfZero  = llZero &amp;&amp; lhZero;
 492   bool hlZero  = (sll4rll &amp;&amp; (nRotate &gt;= 48)) || (srl4rll &amp;&amp; (nRotate &lt;= -32));
 493   bool hhZero  =                                 (srl4rll &amp;&amp; (nRotate &lt;= -16));
 494   bool hfZero  = hlZero &amp;&amp; hhZero;
 495 
 496   // rotate then mask src operand.
 497   // if oneBits == true,  all bits outside selected range are 1s.
 498   // if oneBits == false, all bits outside selected range are 0s.
 499   if (src32bit) {   // There might be garbage in the upper 32 bits which will get masked away.
 500     if (dst32bit) {
 501       z_rll(dst, src, nRotate);   // Copy and rotate, upper half of reg remains undisturbed.
 502     } else {
 503       if      (sll4rll) { z_sllg(dst, src,  nRotate); }
 504       else if (srl4rll) { z_srlg(dst, src, -nRotate); }
 505       else              { z_rllg(dst, src,  nRotate); }
 506     }
 507   } else {
 508     if      (sll4rll) { z_sllg(dst, src,  nRotate); }
 509     else if (srl4rll) { z_srlg(dst, src, -nRotate); }
 510     else              { z_rllg(dst, src,  nRotate); }
 511   }
 512 
 513   unsigned long  range_mask    = create_mask(lBitPos, rBitPos);
 514   unsigned int   range_mask_h  = (unsigned int)(range_mask &gt;&gt; 32);
 515   unsigned int   range_mask_l  = (unsigned int)range_mask;
 516   unsigned short range_mask_hh = (unsigned short)(range_mask &gt;&gt; 48);
 517   unsigned short range_mask_hl = (unsigned short)(range_mask &gt;&gt; 32);
 518   unsigned short range_mask_lh = (unsigned short)(range_mask &gt;&gt; 16);
 519   unsigned short range_mask_ll = (unsigned short)range_mask;
 520   // Works for z9 and newer H/W.
 521   if (oneBits) {
 522     if ((~range_mask_l) != 0)                { z_oilf(dst, ~range_mask_l); } // All bits outside range become 1s.
 523     if (((~range_mask_h) != 0) &amp;&amp; !dst32bit) { z_oihf(dst, ~range_mask_h); }
 524   } else {
 525     // All bits outside range become 0s
 526     if (((~range_mask_l) != 0) &amp;&amp;              !lfZero) {
 527       z_nilf(dst, range_mask_l);
 528     }
 529     if (((~range_mask_h) != 0) &amp;&amp; !dst32bit &amp;&amp; !hfZero) {
 530       z_nihf(dst, range_mask_h);
 531     }
 532   }
 533 }
 534 
 535 // Rotate src, then insert selected range from rotated src into dst.
 536 // Clear dst before, if requested.
 537 void MacroAssembler::rotate_then_insert(Register dst, Register src, int lBitPos, int rBitPos,
 538                                         int nRotate, bool clear_dst) {
 539   // This version does not depend on src being zero-extended int2long.
 540   nRotate &amp;= 0x003f;                                       // For risbg, pretend it&#39;s an unsigned value.
 541   z_risbg(dst, src, lBitPos, rBitPos, nRotate, clear_dst); // Rotate, then insert selected, clear the rest.
 542 }
 543 
 544 // Rotate src, then and selected range from rotated src into dst.
 545 // Set condition code only if so requested. Otherwise it is unpredictable.
 546 // See performance note in macroAssembler_s390.hpp for important information.
 547 void MacroAssembler::rotate_then_and(Register dst, Register src, int lBitPos, int rBitPos,
 548                                      int nRotate, bool test_only) {
 549   guarantee(!test_only, &quot;Emitter not fit for test_only instruction variant.&quot;);
 550   // This version does not depend on src being zero-extended int2long.
 551   nRotate &amp;= 0x003f;                                       // For risbg, pretend it&#39;s an unsigned value.
 552   z_rxsbg(dst, src, lBitPos, rBitPos, nRotate, test_only); // Rotate, then xor selected.
 553 }
 554 
 555 // Rotate src, then or selected range from rotated src into dst.
 556 // Set condition code only if so requested. Otherwise it is unpredictable.
 557 // See performance note in macroAssembler_s390.hpp for important information.
 558 void MacroAssembler::rotate_then_or(Register dst, Register src,  int  lBitPos,  int  rBitPos,
 559                                     int nRotate, bool test_only) {
 560   guarantee(!test_only, &quot;Emitter not fit for test_only instruction variant.&quot;);
 561   // This version does not depend on src being zero-extended int2long.
 562   nRotate &amp;= 0x003f;                                       // For risbg, pretend it&#39;s an unsigned value.
 563   z_rosbg(dst, src, lBitPos, rBitPos, nRotate, test_only); // Rotate, then xor selected.
 564 }
 565 
 566 // Rotate src, then xor selected range from rotated src into dst.
 567 // Set condition code only if so requested. Otherwise it is unpredictable.
 568 // See performance note in macroAssembler_s390.hpp for important information.
 569 void MacroAssembler::rotate_then_xor(Register dst, Register src,  int  lBitPos,  int  rBitPos,
 570                                      int nRotate, bool test_only) {
 571   guarantee(!test_only, &quot;Emitter not fit for test_only instruction variant.&quot;);
 572     // This version does not depend on src being zero-extended int2long.
 573   nRotate &amp;= 0x003f;                                       // For risbg, pretend it&#39;s an unsigned value.
 574   z_rxsbg(dst, src, lBitPos, rBitPos, nRotate, test_only); // Rotate, then xor selected.
 575 }
 576 
 577 void MacroAssembler::add64(Register r1, RegisterOrConstant inc) {
 578   if (inc.is_register()) {
 579     z_agr(r1, inc.as_register());
 580   } else { // constant
 581     intptr_t imm = inc.as_constant();
 582     add2reg(r1, imm);
 583   }
 584 }
 585 // Helper function to multiply the 64bit contents of a register by a 16bit constant.
 586 // The optimization tries to avoid the mghi instruction, since it uses the FPU for
 587 // calculation and is thus rather slow.
 588 //
 589 // There is no handling for special cases, e.g. cval==0 or cval==1.
 590 //
 591 // Returns len of generated code block.
 592 unsigned int MacroAssembler::mul_reg64_const16(Register rval, Register work, int cval) {
 593   int block_start = offset();
 594 
 595   bool sign_flip = cval &lt; 0;
 596   cval = sign_flip ? -cval : cval;
 597 
 598   BLOCK_COMMENT(&quot;Reg64*Con16 {&quot;);
 599 
 600   int bit1 = cval &amp; -cval;
 601   if (bit1 == cval) {
 602     z_sllg(rval, rval, exact_log2(bit1));
 603     if (sign_flip) { z_lcgr(rval, rval); }
 604   } else {
 605     int bit2 = (cval-bit1) &amp; -(cval-bit1);
 606     if ((bit1+bit2) == cval) {
 607       z_sllg(work, rval, exact_log2(bit1));
 608       z_sllg(rval, rval, exact_log2(bit2));
 609       z_agr(rval, work);
 610       if (sign_flip) { z_lcgr(rval, rval); }
 611     } else {
 612       if (sign_flip) { z_mghi(rval, -cval); }
 613       else           { z_mghi(rval,  cval); }
 614     }
 615   }
 616   BLOCK_COMMENT(&quot;} Reg64*Con16&quot;);
 617 
 618   int block_end = offset();
 619   return block_end - block_start;
 620 }
 621 
 622 // Generic operation r1 := r2 + imm.
 623 //
 624 // Should produce the best code for each supported CPU version.
 625 // r2 == noreg yields r1 := r1 + imm
 626 // imm == 0 emits either no instruction or r1 := r2 !
 627 // NOTES: 1) Don&#39;t use this function where fixed sized
 628 //           instruction sequences are required!!!
 629 //        2) Don&#39;t use this function if condition code
 630 //           setting is required!
 631 //        3) Despite being declared as int64_t, the parameter imm
 632 //           must be a simm_32 value (= signed 32-bit integer).
 633 void MacroAssembler::add2reg(Register r1, int64_t imm, Register r2) {
 634   assert(Immediate::is_simm32(imm), &quot;probably an implicit conversion went wrong&quot;);
 635 
 636   if (r2 == noreg) { r2 = r1; }
 637 
 638   // Handle special case imm == 0.
 639   if (imm == 0) {
 640     lgr_if_needed(r1, r2);
 641     // Nothing else to do.
 642     return;
 643   }
 644 
 645   if (!PreferLAoverADD || (r2 == Z_R0)) {
 646     bool distinctOpnds = VM_Version::has_DistinctOpnds();
 647 
 648     // Can we encode imm in 16 bits signed?
 649     if (Immediate::is_simm16(imm)) {
 650       if (r1 == r2) {
 651         z_aghi(r1, imm);
 652         return;
 653       }
 654       if (distinctOpnds) {
 655         z_aghik(r1, r2, imm);
 656         return;
 657       }
 658       z_lgr(r1, r2);
 659       z_aghi(r1, imm);
 660       return;
 661     }
 662   } else {
 663     // Can we encode imm in 12 bits unsigned?
 664     if (Displacement::is_shortDisp(imm)) {
 665       z_la(r1, imm, r2);
 666       return;
 667     }
 668     // Can we encode imm in 20 bits signed?
 669     if (Displacement::is_validDisp(imm)) {
 670       // Always use LAY instruction, so we don&#39;t need the tmp register.
 671       z_lay(r1, imm, r2);
 672       return;
 673     }
 674 
 675   }
 676 
 677   // Can handle it (all possible values) with long immediates.
 678   lgr_if_needed(r1, r2);
 679   z_agfi(r1, imm);
 680 }
 681 
 682 // Generic operation r := b + x + d
 683 //
 684 // Addition of several operands with address generation semantics - sort of:
 685 //  - no restriction on the registers. Any register will do for any operand.
 686 //  - x == noreg: operand will be disregarded.
 687 //  - b == noreg: will use (contents of) result reg as operand (r := r + d).
 688 //  - x == Z_R0:  just disregard
 689 //  - b == Z_R0:  use as operand. This is not address generation semantics!!!
 690 //
 691 // The same restrictions as on add2reg() are valid!!!
 692 void MacroAssembler::add2reg_with_index(Register r, int64_t d, Register x, Register b) {
 693   assert(Immediate::is_simm32(d), &quot;probably an implicit conversion went wrong&quot;);
 694 
 695   if (x == noreg) { x = Z_R0; }
 696   if (b == noreg) { b = r; }
 697 
 698   // Handle special case x == R0.
 699   if (x == Z_R0) {
 700     // Can simply add the immediate value to the base register.
 701     add2reg(r, d, b);
 702     return;
 703   }
 704 
 705   if (!PreferLAoverADD || (b == Z_R0)) {
 706     bool distinctOpnds = VM_Version::has_DistinctOpnds();
 707     // Handle special case d == 0.
 708     if (d == 0) {
 709       if (b == x)        { z_sllg(r, b, 1); return; }
 710       if (r == x)        { z_agr(r, b);     return; }
 711       if (r == b)        { z_agr(r, x);     return; }
 712       if (distinctOpnds) { z_agrk(r, x, b); return; }
 713       z_lgr(r, b);
 714       z_agr(r, x);
 715     } else {
 716       if (x == b)             { z_sllg(r, x, 1); }
 717       else if (r == x)        { z_agr(r, b); }
 718       else if (r == b)        { z_agr(r, x); }
 719       else if (distinctOpnds) { z_agrk(r, x, b); }
 720       else {
 721         z_lgr(r, b);
 722         z_agr(r, x);
 723       }
 724       add2reg(r, d);
 725     }
 726   } else {
 727     // Can we encode imm in 12 bits unsigned?
 728     if (Displacement::is_shortDisp(d)) {
 729       z_la(r, d, x, b);
 730       return;
 731     }
 732     // Can we encode imm in 20 bits signed?
 733     if (Displacement::is_validDisp(d)) {
 734       z_lay(r, d, x, b);
 735       return;
 736     }
 737     z_la(r, 0, x, b);
 738     add2reg(r, d);
 739   }
 740 }
 741 
 742 // Generic emitter (32bit) for direct memory increment.
 743 // For optimal code, do not specify Z_R0 as temp register.
 744 void MacroAssembler::add2mem_32(const Address &amp;a, int64_t imm, Register tmp) {
 745   if (VM_Version::has_MemWithImmALUOps() &amp;&amp; Immediate::is_simm8(imm)) {
 746     z_asi(a, imm);
 747   } else {
 748     z_lgf(tmp, a);
 749     add2reg(tmp, imm);
 750     z_st(tmp, a);
 751   }
 752 }
 753 
 754 void MacroAssembler::add2mem_64(const Address &amp;a, int64_t imm, Register tmp) {
 755   if (VM_Version::has_MemWithImmALUOps() &amp;&amp; Immediate::is_simm8(imm)) {
 756     z_agsi(a, imm);
 757   } else {
 758     z_lg(tmp, a);
 759     add2reg(tmp, imm);
 760     z_stg(tmp, a);
 761   }
 762 }
 763 
 764 void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed) {
 765   switch (size_in_bytes) {
 766     case  8: z_lg(dst, src); break;
 767     case  4: is_signed ? z_lgf(dst, src) : z_llgf(dst, src); break;
 768     case  2: is_signed ? z_lgh(dst, src) : z_llgh(dst, src); break;
 769     case  1: is_signed ? z_lgb(dst, src) : z_llgc(dst, src); break;
 770     default: ShouldNotReachHere();
 771   }
 772 }
 773 
 774 void MacroAssembler::store_sized_value(Register src, Address dst, size_t size_in_bytes) {
 775   switch (size_in_bytes) {
 776     case  8: z_stg(src, dst); break;
 777     case  4: z_st(src, dst); break;
 778     case  2: z_sth(src, dst); break;
 779     case  1: z_stc(src, dst); break;
 780     default: ShouldNotReachHere();
 781   }
 782 }
 783 
 784 // Split a si20 offset (20bit, signed) into an ui12 offset (12bit, unsigned) and
 785 // a high-order summand in register tmp.
 786 //
 787 // return value: &lt;  0: No split required, si20 actually has property uimm12.
 788 //               &gt;= 0: Split performed. Use return value as uimm12 displacement and
 789 //                     tmp as index register.
 790 int MacroAssembler::split_largeoffset(int64_t si20_offset, Register tmp, bool fixed_codelen, bool accumulate) {
 791   assert(Immediate::is_simm20(si20_offset), &quot;sanity&quot;);
 792   int lg_off = (int)si20_offset &amp;  0x0fff; // Punch out low-order 12 bits, always positive.
 793   int ll_off = (int)si20_offset &amp; ~0x0fff; // Force low-order 12 bits to zero.
 794   assert((Displacement::is_shortDisp(si20_offset) &amp;&amp; (ll_off == 0)) ||
 795          !Displacement::is_shortDisp(si20_offset), &quot;unexpected offset values&quot;);
 796   assert((lg_off+ll_off) == si20_offset, &quot;offset splitup error&quot;);
 797 
 798   Register work = accumulate? Z_R0 : tmp;
 799 
 800   if (fixed_codelen) {          // Len of code = 10 = 4 + 6.
 801     z_lghi(work, ll_off&gt;&gt;12);   // Implicit sign extension.
 802     z_slag(work, work, 12);
 803   } else {                      // Len of code = 0..10.
 804     if (ll_off == 0) { return -1; }
 805     // ll_off has 8 significant bits (at most) plus sign.
 806     if ((ll_off &amp; 0x0000f000) == 0) {    // Non-zero bits only in upper halfbyte.
 807       z_llilh(work, ll_off &gt;&gt; 16);
 808       if (ll_off &lt; 0) {                  // Sign-extension required.
 809         z_lgfr(work, work);
 810       }
 811     } else {
 812       if ((ll_off &amp; 0x000f0000) == 0) {  // Non-zero bits only in lower halfbyte.
 813         z_llill(work, ll_off);
 814       } else {                           // Non-zero bits in both halfbytes.
 815         z_lghi(work, ll_off&gt;&gt;12);        // Implicit sign extension.
 816         z_slag(work, work, 12);
 817       }
 818     }
 819   }
 820   if (accumulate) { z_algr(tmp, work); } // len of code += 4
 821   return lg_off;
 822 }
 823 
 824 void MacroAssembler::load_float_largeoffset(FloatRegister t, int64_t si20, Register a, Register tmp) {
 825   if (Displacement::is_validDisp(si20)) {
 826     z_ley(t, si20, a);
 827   } else {
 828     // Fixed_codelen = true is a simple way to ensure that the size of load_float_largeoffset
 829     // does not depend on si20 (scratch buffer emit size == code buffer emit size for constant
 830     // pool loads).
 831     bool accumulate    = true;
 832     bool fixed_codelen = true;
 833     Register work;
 834 
 835     if (fixed_codelen) {
 836       z_lgr(tmp, a);  // Lgr_if_needed not applicable due to fixed_codelen.
 837     } else {
 838       accumulate = (a == tmp);
 839     }
 840     work = tmp;
 841 
 842     int disp12 = split_largeoffset(si20, work, fixed_codelen, accumulate);
 843     if (disp12 &lt; 0) {
 844       z_le(t, si20, work);
 845     } else {
 846       if (accumulate) {
 847         z_le(t, disp12, work);
 848       } else {
 849         z_le(t, disp12, work, a);
 850       }
 851     }
 852   }
 853 }
 854 
 855 void MacroAssembler::load_double_largeoffset(FloatRegister t, int64_t si20, Register a, Register tmp) {
 856   if (Displacement::is_validDisp(si20)) {
 857     z_ldy(t, si20, a);
 858   } else {
 859     // Fixed_codelen = true is a simple way to ensure that the size of load_double_largeoffset
 860     // does not depend on si20 (scratch buffer emit size == code buffer emit size for constant
 861     // pool loads).
 862     bool accumulate    = true;
 863     bool fixed_codelen = true;
 864     Register work;
 865 
 866     if (fixed_codelen) {
 867       z_lgr(tmp, a);  // Lgr_if_needed not applicable due to fixed_codelen.
 868     } else {
 869       accumulate = (a == tmp);
 870     }
 871     work = tmp;
 872 
 873     int disp12 = split_largeoffset(si20, work, fixed_codelen, accumulate);
 874     if (disp12 &lt; 0) {
 875       z_ld(t, si20, work);
 876     } else {
 877       if (accumulate) {
 878         z_ld(t, disp12, work);
 879       } else {
 880         z_ld(t, disp12, work, a);
 881       }
 882     }
 883   }
 884 }
 885 
 886 // PCrelative TOC access.
 887 // Returns distance (in bytes) from current position to start of consts section.
 888 // Returns 0 (zero) if no consts section exists or if it has size zero.
 889 long MacroAssembler::toc_distance() {
 890   CodeSection* cs = code()-&gt;consts();
 891   return (long)((cs != NULL) ? cs-&gt;start()-pc() : 0);
 892 }
 893 
 894 // Implementation on x86/sparc assumes that constant and instruction section are
 895 // adjacent, but this doesn&#39;t hold. Two special situations may occur, that we must
 896 // be able to handle:
 897 //   1. const section may be located apart from the inst section.
 898 //   2. const section may be empty
 899 // In both cases, we use the const section&#39;s start address to compute the &quot;TOC&quot;,
 900 // this seems to occur only temporarily; in the final step we always seem to end up
 901 // with the pc-relatice variant.
 902 //
 903 // PC-relative offset could be +/-2**32 -&gt; use long for disp
 904 // Furthermore: makes no sense to have special code for
 905 // adjacent const and inst sections.
 906 void MacroAssembler::load_toc(Register Rtoc) {
 907   // Simply use distance from start of const section (should be patched in the end).
 908   long disp = toc_distance();
 909 
 910   RelocationHolder rspec = internal_word_Relocation::spec(pc() + disp);
 911   relocate(rspec);
 912   z_larl(Rtoc, RelAddr::pcrel_off32(disp));  // Offset is in halfwords.
 913 }
 914 
 915 // PCrelative TOC access.
 916 // Load from anywhere pcrelative (with relocation of load instr)
 917 void MacroAssembler::load_long_pcrelative(Register Rdst, address dataLocation) {
 918   address          pc             = this-&gt;pc();
 919   ptrdiff_t        total_distance = dataLocation - pc;
 920   RelocationHolder rspec          = internal_word_Relocation::spec(dataLocation);
 921 
 922   assert((total_distance &amp; 0x01L) == 0, &quot;halfword alignment is mandatory&quot;);
 923   assert(total_distance != 0, &quot;sanity&quot;);
 924 
 925   // Some extra safety net.
 926   if (!RelAddr::is_in_range_of_RelAddr32(total_distance)) {
 927     guarantee(RelAddr::is_in_range_of_RelAddr32(total_distance), &quot;load_long_pcrelative can&#39;t handle distance &quot; INTPTR_FORMAT, total_distance);
 928   }
 929 
 930   (this)-&gt;relocate(rspec, relocInfo::pcrel_addr_format);
 931   z_lgrl(Rdst, RelAddr::pcrel_off32(total_distance));
 932 }
 933 
 934 
 935 // PCrelative TOC access.
 936 // Load from anywhere pcrelative (with relocation of load instr)
 937 // loaded addr has to be relocated when added to constant pool.
 938 void MacroAssembler::load_addr_pcrelative(Register Rdst, address addrLocation) {
 939   address          pc             = this-&gt;pc();
 940   ptrdiff_t        total_distance = addrLocation - pc;
 941   RelocationHolder rspec          = internal_word_Relocation::spec(addrLocation);
 942 
 943   assert((total_distance &amp; 0x01L) == 0, &quot;halfword alignment is mandatory&quot;);
 944 
 945   // Some extra safety net.
 946   if (!RelAddr::is_in_range_of_RelAddr32(total_distance)) {
 947     guarantee(RelAddr::is_in_range_of_RelAddr32(total_distance), &quot;load_long_pcrelative can&#39;t handle distance &quot; INTPTR_FORMAT, total_distance);
 948   }
 949 
 950   (this)-&gt;relocate(rspec, relocInfo::pcrel_addr_format);
 951   z_lgrl(Rdst, RelAddr::pcrel_off32(total_distance));
 952 }
 953 
 954 // Generic operation: load a value from memory and test.
 955 // CondCode indicates the sign (&lt;0, ==0, &gt;0) of the loaded value.
 956 void MacroAssembler::load_and_test_byte(Register dst, const Address &amp;a) {
 957   z_lb(dst, a);
 958   z_ltr(dst, dst);
 959 }
 960 
 961 void MacroAssembler::load_and_test_short(Register dst, const Address &amp;a) {
 962   int64_t disp = a.disp20();
 963   if (Displacement::is_shortDisp(disp)) {
 964     z_lh(dst, a);
 965   } else if (Displacement::is_longDisp(disp)) {
 966     z_lhy(dst, a);
 967   } else {
 968     guarantee(false, &quot;displacement out of range&quot;);
 969   }
 970   z_ltr(dst, dst);
 971 }
 972 
 973 void MacroAssembler::load_and_test_int(Register dst, const Address &amp;a) {
 974   z_lt(dst, a);
 975 }
 976 
 977 void MacroAssembler::load_and_test_int2long(Register dst, const Address &amp;a) {
 978   z_ltgf(dst, a);
 979 }
 980 
 981 void MacroAssembler::load_and_test_long(Register dst, const Address &amp;a) {
 982   z_ltg(dst, a);
 983 }
 984 
 985 // Test a bit in memory.
 986 void MacroAssembler::testbit(const Address &amp;a, unsigned int bit) {
 987   assert(a.index() == noreg, &quot;no index reg allowed in testbit&quot;);
 988   if (bit &lt;= 7) {
 989     z_tm(a.disp() + 3, a.base(), 1 &lt;&lt; bit);
 990   } else if (bit &lt;= 15) {
 991     z_tm(a.disp() + 2, a.base(), 1 &lt;&lt; (bit - 8));
 992   } else if (bit &lt;= 23) {
 993     z_tm(a.disp() + 1, a.base(), 1 &lt;&lt; (bit - 16));
 994   } else if (bit &lt;= 31) {
 995     z_tm(a.disp() + 0, a.base(), 1 &lt;&lt; (bit - 24));
 996   } else {
 997     ShouldNotReachHere();
 998   }
 999 }
1000 
1001 // Test a bit in a register. Result is reflected in CC.
1002 void MacroAssembler::testbit(Register r, unsigned int bitPos) {
1003   if (bitPos &lt; 16) {
1004     z_tmll(r, 1U&lt;&lt;bitPos);
1005   } else if (bitPos &lt; 32) {
1006     z_tmlh(r, 1U&lt;&lt;(bitPos-16));
1007   } else if (bitPos &lt; 48) {
1008     z_tmhl(r, 1U&lt;&lt;(bitPos-32));
1009   } else if (bitPos &lt; 64) {
1010     z_tmhh(r, 1U&lt;&lt;(bitPos-48));
1011   } else {
1012     ShouldNotReachHere();
1013   }
1014 }
1015 
1016 void MacroAssembler::prefetch_read(Address a) {
1017   z_pfd(1, a.disp20(), a.indexOrR0(), a.base());
1018 }
1019 void MacroAssembler::prefetch_update(Address a) {
1020   z_pfd(2, a.disp20(), a.indexOrR0(), a.base());
1021 }
1022 
1023 // Clear a register, i.e. load const zero into reg.
1024 // Return len (in bytes) of generated instruction(s).
1025 // whole_reg: Clear 64 bits if true, 32 bits otherwise.
1026 // set_cc:    Use instruction that sets the condition code, if true.
1027 int MacroAssembler::clear_reg(Register r, bool whole_reg, bool set_cc) {
1028   unsigned int start_off = offset();
1029   if (whole_reg) {
1030     set_cc ? z_xgr(r, r) : z_laz(r, 0, Z_R0);
1031   } else {  // Only 32bit register.
1032     set_cc ? z_xr(r, r) : z_lhi(r, 0);
1033   }
1034   return offset() - start_off;
1035 }
1036 
1037 #ifdef ASSERT
1038 int MacroAssembler::preset_reg(Register r, unsigned long pattern, int pattern_len) {
1039   switch (pattern_len) {
1040     case 1:
1041       pattern = (pattern &amp; 0x000000ff)  | ((pattern &amp; 0x000000ff)&lt;&lt;8);
1042     case 2:
1043       pattern = (pattern &amp; 0x0000ffff)  | ((pattern &amp; 0x0000ffff)&lt;&lt;16);
1044     case 4:
1045       pattern = (pattern &amp; 0xffffffffL) | ((pattern &amp; 0xffffffffL)&lt;&lt;32);
1046     case 8:
1047       return load_const_optimized_rtn_len(r, pattern, true);
1048       break;
1049     default:
1050       guarantee(false, &quot;preset_reg: bad len&quot;);
1051   }
1052   return 0;
1053 }
1054 #endif
1055 
1056 // addr: Address descriptor of memory to clear index register will not be used !
1057 // size: Number of bytes to clear.
1058 //    !!! DO NOT USE THEM FOR ATOMIC MEMORY CLEARING !!!
1059 //    !!! Use store_const() instead                  !!!
1060 void MacroAssembler::clear_mem(const Address&amp; addr, unsigned size) {
1061   guarantee(size &lt;= 256, &quot;MacroAssembler::clear_mem: size too large&quot;);
1062 
1063   if (size == 1) {
1064     z_mvi(addr, 0);
1065     return;
1066   }
1067 
1068   switch (size) {
1069     case 2: z_mvhhi(addr, 0);
1070       return;
1071     case 4: z_mvhi(addr, 0);
1072       return;
1073     case 8: z_mvghi(addr, 0);
1074       return;
1075     default: ; // Fallthru to xc.
1076   }
1077 
1078   z_xc(addr, size, addr);
1079 }
1080 
1081 void MacroAssembler::align(int modulus) {
1082   while (offset() % modulus != 0) z_nop();
1083 }
1084 
1085 // Special version for non-relocateable code if required alignment
1086 // is larger than CodeEntryAlignment.
1087 void MacroAssembler::align_address(int modulus) {
1088   while ((uintptr_t)pc() % modulus != 0) z_nop();
1089 }
1090 
1091 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
1092                                          Register temp_reg,
1093                                          int64_t extra_slot_offset) {
1094   // On Z, we can have index and disp in an Address. So don&#39;t call argument_offset,
1095   // which issues an unnecessary add instruction.
1096   int stackElementSize = Interpreter::stackElementSize;
1097   int64_t offset = extra_slot_offset * stackElementSize;
1098   const Register argbase = Z_esp;
1099   if (arg_slot.is_constant()) {
1100     offset += arg_slot.as_constant() * stackElementSize;
1101     return Address(argbase, offset);
1102   }
1103   // else
1104   assert(temp_reg != noreg, &quot;must specify&quot;);
1105   assert(temp_reg != Z_ARG1, &quot;base and index are conflicting&quot;);
1106   z_sllg(temp_reg, arg_slot.as_register(), exact_log2(stackElementSize)); // tempreg = arg_slot &lt;&lt; 3
1107   return Address(argbase, temp_reg, offset);
1108 }
1109 
1110 
1111 //===================================================================
1112 //===   START   C O N S T A N T S   I N   C O D E   S T R E A M   ===
1113 //===================================================================
1114 //===            P A T CH A B L E   C O N S T A N T S             ===
1115 //===================================================================
1116 
1117 
1118 //---------------------------------------------------
1119 //  Load (patchable) constant into register
1120 //---------------------------------------------------
1121 
1122 
1123 // Load absolute address (and try to optimize).
1124 //   Note: This method is usable only for position-fixed code,
1125 //         referring to a position-fixed target location.
1126 //         If not so, relocations and patching must be used.
1127 void MacroAssembler::load_absolute_address(Register d, address addr) {
1128   assert(addr != NULL, &quot;should not happen&quot;);
1129   BLOCK_COMMENT(&quot;load_absolute_address:&quot;);
1130   if (addr == NULL) {
1131     z_larl(d, pc()); // Dummy emit for size calc.
1132     return;
1133   }
1134 
1135   if (RelAddr::is_in_range_of_RelAddr32(addr, pc())) {
1136     z_larl(d, addr);
1137     return;
1138   }
1139 
1140   load_const_optimized(d, (long)addr);
1141 }
1142 
1143 // Load a 64bit constant.
1144 // Patchable code sequence, but not atomically patchable.
1145 // Make sure to keep code size constant -&gt; no value-dependent optimizations.
1146 // Do not kill condition code.
1147 void MacroAssembler::load_const(Register t, long x) {
1148   // Note: Right shift is only cleanly defined for unsigned types
1149   //       or for signed types with nonnegative values.
1150   Assembler::z_iihf(t, (long)((unsigned long)x &gt;&gt; 32));
1151   Assembler::z_iilf(t, (long)((unsigned long)x &amp; 0xffffffffUL));
1152 }
1153 
1154 // Load a 32bit constant into a 64bit register, sign-extend or zero-extend.
1155 // Patchable code sequence, but not atomically patchable.
1156 // Make sure to keep code size constant -&gt; no value-dependent optimizations.
1157 // Do not kill condition code.
1158 void MacroAssembler::load_const_32to64(Register t, int64_t x, bool sign_extend) {
1159   if (sign_extend) { Assembler::z_lgfi(t, x); }
1160   else             { Assembler::z_llilf(t, x); }
1161 }
1162 
1163 // Load narrow oop constant, no decompression.
1164 void MacroAssembler::load_narrow_oop(Register t, narrowOop a) {
1165   assert(UseCompressedOops, &quot;must be on to call this method&quot;);
1166   load_const_32to64(t, a, false /*sign_extend*/);
1167 }
1168 
1169 // Load narrow klass constant, compression required.
1170 void MacroAssembler::load_narrow_klass(Register t, Klass* k) {
1171   assert(UseCompressedClassPointers, &quot;must be on to call this method&quot;);
1172   narrowKlass encoded_k = CompressedKlassPointers::encode(k);
1173   load_const_32to64(t, encoded_k, false /*sign_extend*/);
1174 }
1175 
1176 //------------------------------------------------------
1177 //  Compare (patchable) constant with register.
1178 //------------------------------------------------------
1179 
1180 // Compare narrow oop in reg with narrow oop constant, no decompression.
1181 void MacroAssembler::compare_immediate_narrow_oop(Register oop1, narrowOop oop2) {
1182   assert(UseCompressedOops, &quot;must be on to call this method&quot;);
1183 
1184   Assembler::z_clfi(oop1, oop2);
1185 }
1186 
1187 // Compare narrow oop in reg with narrow oop constant, no decompression.
1188 void MacroAssembler::compare_immediate_narrow_klass(Register klass1, Klass* klass2) {
1189   assert(UseCompressedClassPointers, &quot;must be on to call this method&quot;);
1190   narrowKlass encoded_k = CompressedKlassPointers::encode(klass2);
1191 
1192   Assembler::z_clfi(klass1, encoded_k);
1193 }
1194 
1195 //----------------------------------------------------------
1196 //  Check which kind of load_constant we have here.
1197 //----------------------------------------------------------
1198 
1199 // Detection of CPU version dependent load_const sequence.
1200 // The detection is valid only for code sequences generated by load_const,
1201 // not load_const_optimized.
1202 bool MacroAssembler::is_load_const(address a) {
1203   unsigned long inst1, inst2;
1204   unsigned int  len1,  len2;
1205 
1206   len1 = get_instruction(a, &amp;inst1);
1207   len2 = get_instruction(a + len1, &amp;inst2);
1208 
1209   return is_z_iihf(inst1) &amp;&amp; is_z_iilf(inst2);
1210 }
1211 
1212 // Detection of CPU version dependent load_const_32to64 sequence.
1213 // Mostly used for narrow oops and narrow Klass pointers.
1214 // The detection is valid only for code sequences generated by load_const_32to64.
1215 bool MacroAssembler::is_load_const_32to64(address pos) {
1216   unsigned long inst1, inst2;
1217   unsigned int len1;
1218 
1219   len1 = get_instruction(pos, &amp;inst1);
1220   return is_z_llilf(inst1);
1221 }
1222 
1223 // Detection of compare_immediate_narrow sequence.
1224 // The detection is valid only for code sequences generated by compare_immediate_narrow_oop.
1225 bool MacroAssembler::is_compare_immediate32(address pos) {
1226   return is_equal(pos, CLFI_ZOPC, RIL_MASK);
1227 }
1228 
1229 // Detection of compare_immediate_narrow sequence.
1230 // The detection is valid only for code sequences generated by compare_immediate_narrow_oop.
1231 bool MacroAssembler::is_compare_immediate_narrow_oop(address pos) {
1232   return is_compare_immediate32(pos);
1233   }
1234 
1235 // Detection of compare_immediate_narrow sequence.
1236 // The detection is valid only for code sequences generated by compare_immediate_narrow_klass.
1237 bool MacroAssembler::is_compare_immediate_narrow_klass(address pos) {
1238   return is_compare_immediate32(pos);
1239 }
1240 
1241 //-----------------------------------
1242 //  patch the load_constant
1243 //-----------------------------------
1244 
1245 // CPU-version dependend patching of load_const.
1246 void MacroAssembler::patch_const(address a, long x) {
1247   assert(is_load_const(a), &quot;not a load of a constant&quot;);
1248   // Note: Right shift is only cleanly defined for unsigned types
1249   //       or for signed types with nonnegative values.
1250   set_imm32((address)a, (long)((unsigned long)x &gt;&gt; 32));
1251   set_imm32((address)(a + 6), (long)((unsigned long)x &amp; 0xffffffffUL));
1252 }
1253 
1254 // Patching the value of CPU version dependent load_const_32to64 sequence.
1255 // The passed ptr MUST be in compressed format!
1256 int MacroAssembler::patch_load_const_32to64(address pos, int64_t np) {
1257   assert(is_load_const_32to64(pos), &quot;not a load of a narrow ptr (oop or klass)&quot;);
1258 
1259   set_imm32(pos, np);
1260   return 6;
1261 }
1262 
1263 // Patching the value of CPU version dependent compare_immediate_narrow sequence.
1264 // The passed ptr MUST be in compressed format!
1265 int MacroAssembler::patch_compare_immediate_32(address pos, int64_t np) {
1266   assert(is_compare_immediate32(pos), &quot;not a compressed ptr compare&quot;);
1267 
1268   set_imm32(pos, np);
1269   return 6;
1270 }
1271 
1272 // Patching the immediate value of CPU version dependent load_narrow_oop sequence.
1273 // The passed ptr must NOT be in compressed format!
1274 int MacroAssembler::patch_load_narrow_oop(address pos, oop o) {
1275   assert(UseCompressedOops, &quot;Can only patch compressed oops&quot;);
1276 
1277   narrowOop no = CompressedOops::encode(o);
1278   return patch_load_const_32to64(pos, no);
1279 }
1280 
1281 // Patching the immediate value of CPU version dependent load_narrow_klass sequence.
1282 // The passed ptr must NOT be in compressed format!
1283 int MacroAssembler::patch_load_narrow_klass(address pos, Klass* k) {
1284   assert(UseCompressedClassPointers, &quot;Can only patch compressed klass pointers&quot;);
1285 
1286   narrowKlass nk = CompressedKlassPointers::encode(k);
1287   return patch_load_const_32to64(pos, nk);
1288 }
1289 
1290 // Patching the immediate value of CPU version dependent compare_immediate_narrow_oop sequence.
1291 // The passed ptr must NOT be in compressed format!
1292 int MacroAssembler::patch_compare_immediate_narrow_oop(address pos, oop o) {
1293   assert(UseCompressedOops, &quot;Can only patch compressed oops&quot;);
1294 
1295   narrowOop no = CompressedOops::encode(o);
1296   return patch_compare_immediate_32(pos, no);
1297 }
1298 
1299 // Patching the immediate value of CPU version dependent compare_immediate_narrow_klass sequence.
1300 // The passed ptr must NOT be in compressed format!
1301 int MacroAssembler::patch_compare_immediate_narrow_klass(address pos, Klass* k) {
1302   assert(UseCompressedClassPointers, &quot;Can only patch compressed klass pointers&quot;);
1303 
1304   narrowKlass nk = CompressedKlassPointers::encode(k);
1305   return patch_compare_immediate_32(pos, nk);
1306 }
1307 
1308 //------------------------------------------------------------------------
1309 //  Extract the constant from a load_constant instruction stream.
1310 //------------------------------------------------------------------------
1311 
1312 // Get constant from a load_const sequence.
1313 long MacroAssembler::get_const(address a) {
1314   assert(is_load_const(a), &quot;not a load of a constant&quot;);
1315   unsigned long x;
1316   x =  (((unsigned long) (get_imm32(a,0) &amp; 0xffffffff)) &lt;&lt; 32);
1317   x |= (((unsigned long) (get_imm32(a,1) &amp; 0xffffffff)));
1318   return (long) x;
1319 }
1320 
1321 //--------------------------------------
1322 //  Store a constant in memory.
1323 //--------------------------------------
1324 
1325 // General emitter to move a constant to memory.
1326 // The store is atomic.
1327 //  o Address must be given in RS format (no index register)
1328 //  o Displacement should be 12bit unsigned for efficiency. 20bit signed also supported.
1329 //  o Constant can be 1, 2, 4, or 8 bytes, signed or unsigned.
1330 //  o Memory slot can be 1, 2, 4, or 8 bytes, signed or unsigned.
1331 //  o Memory slot must be at least as wide as constant, will assert otherwise.
1332 //  o Signed constants will sign-extend, unsigned constants will zero-extend to slot width.
1333 int MacroAssembler::store_const(const Address &amp;dest, long imm,
1334                                 unsigned int lm, unsigned int lc,
1335                                 Register scratch) {
1336   int64_t  disp = dest.disp();
1337   Register base = dest.base();
1338   assert(!dest.has_index(), &quot;not supported&quot;);
1339   assert((lm==1)||(lm==2)||(lm==4)||(lm==8), &quot;memory   length not supported&quot;);
1340   assert((lc==1)||(lc==2)||(lc==4)||(lc==8), &quot;constant length not supported&quot;);
1341   assert(lm&gt;=lc, &quot;memory slot too small&quot;);
1342   assert(lc==8 || Immediate::is_simm(imm, lc*8), &quot;const out of range&quot;);
1343   assert(Displacement::is_validDisp(disp), &quot;displacement out of range&quot;);
1344 
1345   bool is_shortDisp = Displacement::is_shortDisp(disp);
1346   int store_offset = -1;
1347 
1348   // For target len == 1 it&#39;s easy.
1349   if (lm == 1) {
1350     store_offset = offset();
1351     if (is_shortDisp) {
1352       z_mvi(disp, base, imm);
1353       return store_offset;
1354     } else {
1355       z_mviy(disp, base, imm);
1356       return store_offset;
1357     }
1358   }
1359 
1360   // All the &quot;good stuff&quot; takes an unsigned displacement.
1361   if (is_shortDisp) {
1362     // NOTE: Cannot use clear_mem for imm==0, because it is not atomic.
1363 
1364     store_offset = offset();
1365     switch (lm) {
1366       case 2:  // Lc == 1 handled correctly here, even for unsigned. Instruction does no widening.
1367         z_mvhhi(disp, base, imm);
1368         return store_offset;
1369       case 4:
1370         if (Immediate::is_simm16(imm)) {
1371           z_mvhi(disp, base, imm);
1372           return store_offset;
1373         }
1374         break;
1375       case 8:
1376         if (Immediate::is_simm16(imm)) {
1377           z_mvghi(disp, base, imm);
1378           return store_offset;
1379         }
1380         break;
1381       default:
1382         ShouldNotReachHere();
1383         break;
1384     }
1385   }
1386 
1387   //  Can&#39;t optimize, so load value and store it.
1388   guarantee(scratch != noreg, &quot; need a scratch register here !&quot;);
1389   if (imm != 0) {
1390     load_const_optimized(scratch, imm);  // Preserves CC anyway.
1391   } else {
1392     // Leave CC alone!!
1393     (void) clear_reg(scratch, true, false); // Indicate unused result.
1394   }
1395 
1396   store_offset = offset();
1397   if (is_shortDisp) {
1398     switch (lm) {
1399       case 2:
1400         z_sth(scratch, disp, Z_R0, base);
1401         return store_offset;
1402       case 4:
1403         z_st(scratch, disp, Z_R0, base);
1404         return store_offset;
1405       case 8:
1406         z_stg(scratch, disp, Z_R0, base);
1407         return store_offset;
1408       default:
1409         ShouldNotReachHere();
1410         break;
1411     }
1412   } else {
1413     switch (lm) {
1414       case 2:
1415         z_sthy(scratch, disp, Z_R0, base);
1416         return store_offset;
1417       case 4:
1418         z_sty(scratch, disp, Z_R0, base);
1419         return store_offset;
1420       case 8:
1421         z_stg(scratch, disp, Z_R0, base);
1422         return store_offset;
1423       default:
1424         ShouldNotReachHere();
1425         break;
1426     }
1427   }
1428   return -1; // should not reach here
1429 }
1430 
1431 //===================================================================
1432 //===       N O T   P A T CH A B L E   C O N S T A N T S          ===
1433 //===================================================================
1434 
1435 // Load constant x into register t with a fast instrcution sequence
1436 // depending on the bits in x. Preserves CC under all circumstances.
1437 int MacroAssembler::load_const_optimized_rtn_len(Register t, long x, bool emit) {
1438   if (x == 0) {
1439     int len;
1440     if (emit) {
1441       len = clear_reg(t, true, false);
1442     } else {
1443       len = 4;
1444     }
1445     return len;
1446   }
1447 
1448   if (Immediate::is_simm16(x)) {
1449     if (emit) { z_lghi(t, x); }
1450     return 4;
1451   }
1452 
1453   // 64 bit value: | part1 | part2 | part3 | part4 |
1454   // At least one part is not zero!
1455   // Note: Right shift is only cleanly defined for unsigned types
1456   //       or for signed types with nonnegative values.
1457   int part1 = (int)((unsigned long)x &gt;&gt; 48) &amp; 0x0000ffff;
1458   int part2 = (int)((unsigned long)x &gt;&gt; 32) &amp; 0x0000ffff;
1459   int part3 = (int)((unsigned long)x &gt;&gt; 16) &amp; 0x0000ffff;
1460   int part4 = (int)x &amp; 0x0000ffff;
1461   int part12 = (int)((unsigned long)x &gt;&gt; 32);
1462   int part34 = (int)x;
1463 
1464   // Lower word only (unsigned).
1465   if (part12 == 0) {
1466     if (part3 == 0) {
1467       if (emit) z_llill(t, part4);
1468       return 4;
1469     }
1470     if (part4 == 0) {
1471       if (emit) z_llilh(t, part3);
1472       return 4;
1473     }
1474     if (emit) z_llilf(t, part34);
1475     return 6;
1476   }
1477 
1478   // Upper word only.
1479   if (part34 == 0) {
1480     if (part1 == 0) {
1481       if (emit) z_llihl(t, part2);
1482       return 4;
1483     }
1484     if (part2 == 0) {
1485       if (emit) z_llihh(t, part1);
1486       return 4;
1487     }
1488     if (emit) z_llihf(t, part12);
1489     return 6;
1490   }
1491 
1492   // Lower word only (signed).
1493   if ((part1 == 0x0000ffff) &amp;&amp; (part2 == 0x0000ffff) &amp;&amp; ((part3 &amp; 0x00008000) != 0)) {
1494     if (emit) z_lgfi(t, part34);
1495     return 6;
1496   }
1497 
1498   int len = 0;
1499 
1500   if ((part1 == 0) || (part2 == 0)) {
1501     if (part1 == 0) {
1502       if (emit) z_llihl(t, part2);
1503       len += 4;
1504     } else {
1505       if (emit) z_llihh(t, part1);
1506       len += 4;
1507     }
1508   } else {
1509     if (emit) z_llihf(t, part12);
1510     len += 6;
1511   }
1512 
1513   if ((part3 == 0) || (part4 == 0)) {
1514     if (part3 == 0) {
1515       if (emit) z_iill(t, part4);
1516       len += 4;
1517     } else {
1518       if (emit) z_iilh(t, part3);
1519       len += 4;
1520     }
1521   } else {
1522     if (emit) z_iilf(t, part34);
1523     len += 6;
1524   }
1525   return len;
1526 }
1527 
1528 //=====================================================================
1529 //===     H I G H E R   L E V E L   B R A N C H   E M I T T E R S   ===
1530 //=====================================================================
1531 
1532 // Note: In the worst case, one of the scratch registers is destroyed!!!
1533 void MacroAssembler::compare32_and_branch(Register r1, RegisterOrConstant x2, branch_condition cond, Label&amp; lbl) {
1534   // Right operand is constant.
1535   if (x2.is_constant()) {
1536     jlong value = x2.as_constant();
1537     compare_and_branch_optimized(r1, value, cond, lbl, /*len64=*/false, /*has_sign=*/true);
1538     return;
1539   }
1540 
1541   // Right operand is in register.
1542   compare_and_branch_optimized(r1, x2.as_register(), cond, lbl, /*len64=*/false, /*has_sign=*/true);
1543 }
1544 
1545 // Note: In the worst case, one of the scratch registers is destroyed!!!
1546 void MacroAssembler::compareU32_and_branch(Register r1, RegisterOrConstant x2, branch_condition cond, Label&amp; lbl) {
1547   // Right operand is constant.
1548   if (x2.is_constant()) {
1549     jlong value = x2.as_constant();
1550     compare_and_branch_optimized(r1, value, cond, lbl, /*len64=*/false, /*has_sign=*/false);
1551     return;
1552   }
1553 
1554   // Right operand is in register.
1555   compare_and_branch_optimized(r1, x2.as_register(), cond, lbl, /*len64=*/false, /*has_sign=*/false);
1556 }
1557 
1558 // Note: In the worst case, one of the scratch registers is destroyed!!!
1559 void MacroAssembler::compare64_and_branch(Register r1, RegisterOrConstant x2, branch_condition cond, Label&amp; lbl) {
1560   // Right operand is constant.
1561   if (x2.is_constant()) {
1562     jlong value = x2.as_constant();
1563     compare_and_branch_optimized(r1, value, cond, lbl, /*len64=*/true, /*has_sign=*/true);
1564     return;
1565   }
1566 
1567   // Right operand is in register.
1568   compare_and_branch_optimized(r1, x2.as_register(), cond, lbl, /*len64=*/true, /*has_sign=*/true);
1569 }
1570 
1571 void MacroAssembler::compareU64_and_branch(Register r1, RegisterOrConstant x2, branch_condition cond, Label&amp; lbl) {
1572   // Right operand is constant.
1573   if (x2.is_constant()) {
1574     jlong value = x2.as_constant();
1575     compare_and_branch_optimized(r1, value, cond, lbl, /*len64=*/true, /*has_sign=*/false);
1576     return;
1577   }
1578 
1579   // Right operand is in register.
1580   compare_and_branch_optimized(r1, x2.as_register(), cond, lbl, /*len64=*/true, /*has_sign=*/false);
1581 }
1582 
1583 // Generate an optimal branch to the branch target.
1584 // Optimal means that a relative branch (brc or brcl) is used if the
1585 // branch distance is short enough. Loading the target address into a
1586 // register and branching via reg is used as fallback only.
1587 //
1588 // Used registers:
1589 //   Z_R1 - work reg. Holds branch target address.
1590 //          Used in fallback case only.
1591 //
1592 // This version of branch_optimized is good for cases where the target address is known
1593 // and constant, i.e. is never changed (no relocation, no patching).
1594 void MacroAssembler::branch_optimized(Assembler::branch_condition cond, address branch_addr) {
1595   address branch_origin = pc();
1596 
1597   if (RelAddr::is_in_range_of_RelAddr16(branch_addr, branch_origin)) {
1598     z_brc(cond, branch_addr);
1599   } else if (RelAddr::is_in_range_of_RelAddr32(branch_addr, branch_origin)) {
1600     z_brcl(cond, branch_addr);
1601   } else {
1602     load_const_optimized(Z_R1, branch_addr);  // CC must not get killed by load_const_optimized.
1603     z_bcr(cond, Z_R1);
1604   }
1605 }
1606 
1607 // This version of branch_optimized is good for cases where the target address
1608 // is potentially not yet known at the time the code is emitted.
1609 //
1610 // One very common case is a branch to an unbound label which is handled here.
1611 // The caller might know (or hope) that the branch distance is short enough
1612 // to be encoded in a 16bit relative address. In this case he will pass a
1613 // NearLabel branch_target.
1614 // Care must be taken with unbound labels. Each call to target(label) creates
1615 // an entry in the patch queue for that label to patch all references of the label
1616 // once it gets bound. Those recorded patch locations must be patchable. Otherwise,
1617 // an assertion fires at patch time.
1618 void MacroAssembler::branch_optimized(Assembler::branch_condition cond, Label&amp; branch_target) {
1619   if (branch_target.is_bound()) {
1620     address branch_addr = target(branch_target);
1621     branch_optimized(cond, branch_addr);
1622   } else if (branch_target.is_near()) {
1623     z_brc(cond, branch_target);  // Caller assures that the target will be in range for z_brc.
1624   } else {
1625     z_brcl(cond, branch_target); // Let&#39;s hope target is in range. Otherwise, we will abort at patch time.
1626   }
1627 }
1628 
1629 // Generate an optimal compare and branch to the branch target.
1630 // Optimal means that a relative branch (clgrj, brc or brcl) is used if the
1631 // branch distance is short enough. Loading the target address into a
1632 // register and branching via reg is used as fallback only.
1633 //
1634 // Input:
1635 //   r1 - left compare operand
1636 //   r2 - right compare operand
1637 void MacroAssembler::compare_and_branch_optimized(Register r1,
1638                                                   Register r2,
1639                                                   Assembler::branch_condition cond,
1640                                                   address  branch_addr,
1641                                                   bool     len64,
1642                                                   bool     has_sign) {
1643   unsigned int casenum = (len64?2:0)+(has_sign?0:1);
1644 
1645   address branch_origin = pc();
1646   if (VM_Version::has_CompareBranch() &amp;&amp; RelAddr::is_in_range_of_RelAddr16(branch_addr, branch_origin)) {
1647     switch (casenum) {
1648       case 0: z_crj( r1, r2, cond, branch_addr); break;
1649       case 1: z_clrj (r1, r2, cond, branch_addr); break;
1650       case 2: z_cgrj(r1, r2, cond, branch_addr); break;
1651       case 3: z_clgrj(r1, r2, cond, branch_addr); break;
1652       default: ShouldNotReachHere(); break;
1653     }
1654   } else {
1655     switch (casenum) {
1656       case 0: z_cr( r1, r2); break;
1657       case 1: z_clr(r1, r2); break;
1658       case 2: z_cgr(r1, r2); break;
1659       case 3: z_clgr(r1, r2); break;
1660       default: ShouldNotReachHere(); break;
1661     }
1662     branch_optimized(cond, branch_addr);
1663   }
1664 }
1665 
1666 // Generate an optimal compare and branch to the branch target.
1667 // Optimal means that a relative branch (clgij, brc or brcl) is used if the
1668 // branch distance is short enough. Loading the target address into a
1669 // register and branching via reg is used as fallback only.
1670 //
1671 // Input:
1672 //   r1 - left compare operand (in register)
1673 //   x2 - right compare operand (immediate)
1674 void MacroAssembler::compare_and_branch_optimized(Register r1,
1675                                                   jlong    x2,
1676                                                   Assembler::branch_condition cond,
1677                                                   Label&amp;   branch_target,
1678                                                   bool     len64,
1679                                                   bool     has_sign) {
1680   address      branch_origin = pc();
1681   bool         x2_imm8       = (has_sign &amp;&amp; Immediate::is_simm8(x2)) || (!has_sign &amp;&amp; Immediate::is_uimm8(x2));
1682   bool         is_RelAddr16  = branch_target.is_near() ||
1683                                (branch_target.is_bound() &amp;&amp;
1684                                 RelAddr::is_in_range_of_RelAddr16(target(branch_target), branch_origin));
1685   unsigned int casenum       = (len64?2:0)+(has_sign?0:1);
1686 
1687   if (VM_Version::has_CompareBranch() &amp;&amp; is_RelAddr16 &amp;&amp; x2_imm8) {
1688     switch (casenum) {
1689       case 0: z_cij( r1, x2, cond, branch_target); break;
1690       case 1: z_clij(r1, x2, cond, branch_target); break;
1691       case 2: z_cgij(r1, x2, cond, branch_target); break;
1692       case 3: z_clgij(r1, x2, cond, branch_target); break;
1693       default: ShouldNotReachHere(); break;
1694     }
1695     return;
1696   }
1697 
1698   if (x2 == 0) {
1699     switch (casenum) {
1700       case 0: z_ltr(r1, r1); break;
1701       case 1: z_ltr(r1, r1); break; // Caution: unsigned test only provides zero/notZero indication!
1702       case 2: z_ltgr(r1, r1); break;
1703       case 3: z_ltgr(r1, r1); break; // Caution: unsigned test only provides zero/notZero indication!
1704       default: ShouldNotReachHere(); break;
1705     }
1706   } else {
1707     if ((has_sign &amp;&amp; Immediate::is_simm16(x2)) || (!has_sign &amp;&amp; Immediate::is_uimm(x2, 15))) {
1708       switch (casenum) {
1709         case 0: z_chi(r1, x2); break;
1710         case 1: z_chi(r1, x2); break; // positive immediate &lt; 2**15
1711         case 2: z_cghi(r1, x2); break;
1712         case 3: z_cghi(r1, x2); break; // positive immediate &lt; 2**15
1713         default: break;
1714       }
1715     } else if ( (has_sign &amp;&amp; Immediate::is_simm32(x2)) || (!has_sign &amp;&amp; Immediate::is_uimm32(x2)) ) {
1716       switch (casenum) {
1717         case 0: z_cfi( r1, x2); break;
1718         case 1: z_clfi(r1, x2); break;
1719         case 2: z_cgfi(r1, x2); break;
1720         case 3: z_clgfi(r1, x2); break;
1721         default: ShouldNotReachHere(); break;
1722       }
1723     } else {
1724       // No instruction with immediate operand possible, so load into register.
1725       Register scratch = (r1 != Z_R0) ? Z_R0 : Z_R1;
1726       load_const_optimized(scratch, x2);
1727       switch (casenum) {
1728         case 0: z_cr( r1, scratch); break;
1729         case 1: z_clr(r1, scratch); break;
1730         case 2: z_cgr(r1, scratch); break;
1731         case 3: z_clgr(r1, scratch); break;
1732         default: ShouldNotReachHere(); break;
1733       }
1734     }
1735   }
1736   branch_optimized(cond, branch_target);
1737 }
1738 
1739 // Generate an optimal compare and branch to the branch target.
1740 // Optimal means that a relative branch (clgrj, brc or brcl) is used if the
1741 // branch distance is short enough. Loading the target address into a
1742 // register and branching via reg is used as fallback only.
1743 //
1744 // Input:
1745 //   r1 - left compare operand
1746 //   r2 - right compare operand
1747 void MacroAssembler::compare_and_branch_optimized(Register r1,
1748                                                   Register r2,
1749                                                   Assembler::branch_condition cond,
1750                                                   Label&amp;   branch_target,
1751                                                   bool     len64,
1752                                                   bool     has_sign) {
1753   unsigned int casenum = (len64 ? 2 : 0) + (has_sign ? 0 : 1);
1754 
1755   if (branch_target.is_bound()) {
1756     address branch_addr = target(branch_target);
1757     compare_and_branch_optimized(r1, r2, cond, branch_addr, len64, has_sign);
1758   } else {
1759     if (VM_Version::has_CompareBranch() &amp;&amp; branch_target.is_near()) {
1760       switch (casenum) {
1761         case 0: z_crj(  r1, r2, cond, branch_target); break;
1762         case 1: z_clrj( r1, r2, cond, branch_target); break;
1763         case 2: z_cgrj( r1, r2, cond, branch_target); break;
1764         case 3: z_clgrj(r1, r2, cond, branch_target); break;
1765         default: ShouldNotReachHere(); break;
1766       }
1767     } else {
1768       switch (casenum) {
1769         case 0: z_cr( r1, r2); break;
1770         case 1: z_clr(r1, r2); break;
1771         case 2: z_cgr(r1, r2); break;
1772         case 3: z_clgr(r1, r2); break;
1773         default: ShouldNotReachHere(); break;
1774       }
1775       branch_optimized(cond, branch_target);
1776     }
1777   }
1778 }
1779 
1780 //===========================================================================
1781 //===   END     H I G H E R   L E V E L   B R A N C H   E M I T T E R S   ===
1782 //===========================================================================
1783 
1784 AddressLiteral MacroAssembler::allocate_metadata_address(Metadata* obj) {
1785   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1786   int index = oop_recorder()-&gt;allocate_metadata_index(obj);
1787   RelocationHolder rspec = metadata_Relocation::spec(index);
1788   return AddressLiteral((address)obj, rspec);
1789 }
1790 
1791 AddressLiteral MacroAssembler::constant_metadata_address(Metadata* obj) {
1792   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1793   int index = oop_recorder()-&gt;find_index(obj);
1794   RelocationHolder rspec = metadata_Relocation::spec(index);
1795   return AddressLiteral((address)obj, rspec);
1796 }
1797 
1798 AddressLiteral MacroAssembler::allocate_oop_address(jobject obj) {
1799   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1800   int oop_index = oop_recorder()-&gt;allocate_oop_index(obj);
1801   return AddressLiteral(address(obj), oop_Relocation::spec(oop_index));
1802 }
1803 
1804 AddressLiteral MacroAssembler::constant_oop_address(jobject obj) {
1805   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1806   int oop_index = oop_recorder()-&gt;find_index(obj);
1807   return AddressLiteral(address(obj), oop_Relocation::spec(oop_index));
1808 }
1809 
1810 // NOTE: destroys r
1811 void MacroAssembler::c2bool(Register r, Register t) {
1812   z_lcr(t, r);   // t = -r
1813   z_or(r, t);    // r = -r OR r
1814   z_srl(r, 31);  // Yields 0 if r was 0, 1 otherwise.
1815 }
1816 
1817 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
1818                                                       Register tmp,
1819                                                       int offset) {
1820   intptr_t value = *delayed_value_addr;
1821   if (value != 0) {
1822     return RegisterOrConstant(value + offset);
1823   }
1824 
1825   BLOCK_COMMENT(&quot;delayed_value {&quot;);
1826   // Load indirectly to solve generation ordering problem.
1827   load_absolute_address(tmp, (address) delayed_value_addr); // tmp = a;
1828   z_lg(tmp, 0, tmp);                   // tmp = *tmp;
1829 
1830 #ifdef ASSERT
1831   NearLabel L;
1832   compare64_and_branch(tmp, (intptr_t)0L, Assembler::bcondNotEqual, L);
1833   z_illtrap();
1834   bind(L);
1835 #endif
1836 
1837   if (offset != 0) {
1838     z_agfi(tmp, offset);               // tmp = tmp + offset;
1839   }
1840 
1841   BLOCK_COMMENT(&quot;} delayed_value&quot;);
1842   return RegisterOrConstant(tmp);
1843 }
1844 
1845 // Patch instruction `inst&#39; at offset `inst_pos&#39; to refer to `dest_pos&#39;
1846 // and return the resulting instruction.
1847 // Dest_pos and inst_pos are 32 bit only. These parms can only designate
1848 // relative positions.
1849 // Use correct argument types. Do not pre-calculate distance.
1850 unsigned long MacroAssembler::patched_branch(address dest_pos, unsigned long inst, address inst_pos) {
1851   int c = 0;
1852   unsigned long patched_inst = 0;
1853   if (is_call_pcrelative_short(inst) ||
1854       is_branch_pcrelative_short(inst) ||
1855       is_branchoncount_pcrelative_short(inst) ||
1856       is_branchonindex32_pcrelative_short(inst)) {
1857     c = 1;
1858     int m = fmask(15, 0);    // simm16(-1, 16, 32);
1859     int v = simm16(RelAddr::pcrel_off16(dest_pos, inst_pos), 16, 32);
1860     patched_inst = (inst &amp; ~m) | v;
1861   } else if (is_compareandbranch_pcrelative_short(inst)) {
1862     c = 2;
1863     long m = fmask(31, 16);  // simm16(-1, 16, 48);
1864     long v = simm16(RelAddr::pcrel_off16(dest_pos, inst_pos), 16, 48);
1865     patched_inst = (inst &amp; ~m) | v;
1866   } else if (is_branchonindex64_pcrelative_short(inst)) {
1867     c = 3;
1868     long m = fmask(31, 16);  // simm16(-1, 16, 48);
1869     long v = simm16(RelAddr::pcrel_off16(dest_pos, inst_pos), 16, 48);
1870     patched_inst = (inst &amp; ~m) | v;
1871   } else if (is_call_pcrelative_long(inst) || is_branch_pcrelative_long(inst)) {
1872     c = 4;
1873     long m = fmask(31, 0);  // simm32(-1, 16, 48);
1874     long v = simm32(RelAddr::pcrel_off32(dest_pos, inst_pos), 16, 48);
1875     patched_inst = (inst &amp; ~m) | v;
1876   } else if (is_pcrelative_long(inst)) { // These are the non-branch pc-relative instructions.
1877     c = 5;
1878     long m = fmask(31, 0);  // simm32(-1, 16, 48);
1879     long v = simm32(RelAddr::pcrel_off32(dest_pos, inst_pos), 16, 48);
1880     patched_inst = (inst &amp; ~m) | v;
1881   } else {
1882     print_dbg_msg(tty, inst, &quot;not a relative branch&quot;, 0);
1883     dump_code_range(tty, inst_pos, 32, &quot;not a pcrelative branch&quot;);
1884     ShouldNotReachHere();
1885   }
1886 
1887   long new_off = get_pcrel_offset(patched_inst);
1888   if (new_off != (dest_pos-inst_pos)) {
1889     tty-&gt;print_cr(&quot;case %d: dest_pos = %p, inst_pos = %p, disp = %ld(%12.12lx)&quot;, c, dest_pos, inst_pos, new_off, new_off);
1890     print_dbg_msg(tty, inst,         &quot;&lt;- original instruction: branch patching error&quot;, 0);
1891     print_dbg_msg(tty, patched_inst, &quot;&lt;- patched  instruction: branch patching error&quot;, 0);
1892 #ifdef LUCY_DBG
1893     VM_Version::z_SIGSEGV();
1894 #endif
1895     ShouldNotReachHere();
1896   }
1897   return patched_inst;
1898 }
1899 
1900 // Only called when binding labels (share/vm/asm/assembler.cpp)
1901 // Pass arguments as intended. Do not pre-calculate distance.
1902 void MacroAssembler::pd_patch_instruction(address branch, address target, const char* file, int line) {
1903   unsigned long stub_inst;
1904   int           inst_len = get_instruction(branch, &amp;stub_inst);
1905 
1906   set_instruction(branch, patched_branch(target, stub_inst, branch), inst_len);
1907 }
1908 
1909 
1910 // Extract relative address (aka offset).
1911 // inv_simm16 works for 4-byte instructions only.
1912 // compare and branch instructions are 6-byte and have a 16bit offset &quot;in the middle&quot;.
1913 long MacroAssembler::get_pcrel_offset(unsigned long inst) {
1914 
1915   if (MacroAssembler::is_pcrelative_short(inst)) {
1916     if (((inst&amp;0xFFFFffff00000000UL) == 0) &amp;&amp; ((inst&amp;0x00000000FFFF0000UL) != 0)) {
1917       return RelAddr::inv_pcrel_off16(inv_simm16(inst));
1918     } else {
1919       return RelAddr::inv_pcrel_off16(inv_simm16_48(inst));
1920     }
1921   }
1922 
1923   if (MacroAssembler::is_pcrelative_long(inst)) {
1924     return RelAddr::inv_pcrel_off32(inv_simm32(inst));
1925   }
1926 
1927   print_dbg_msg(tty, inst, &quot;not a pcrelative instruction&quot;, 6);
1928 #ifdef LUCY_DBG
1929   VM_Version::z_SIGSEGV();
1930 #else
1931   ShouldNotReachHere();
1932 #endif
1933   return -1;
1934 }
1935 
1936 long MacroAssembler::get_pcrel_offset(address pc) {
1937   unsigned long inst;
1938   unsigned int  len = get_instruction(pc, &amp;inst);
1939 
1940 #ifdef ASSERT
1941   long offset;
1942   if (MacroAssembler::is_pcrelative_short(inst) || MacroAssembler::is_pcrelative_long(inst)) {
1943     offset = get_pcrel_offset(inst);
1944   } else {
1945     offset = -1;
1946   }
1947 
1948   if (offset == -1) {
1949     dump_code_range(tty, pc, 32, &quot;not a pcrelative instruction&quot;);
1950 #ifdef LUCY_DBG
1951     VM_Version::z_SIGSEGV();
1952 #else
1953     ShouldNotReachHere();
1954 #endif
1955   }
1956   return offset;
1957 #else
1958   return get_pcrel_offset(inst);
1959 #endif // ASSERT
1960 }
1961 
1962 // Get target address from pc-relative instructions.
1963 address MacroAssembler::get_target_addr_pcrel(address pc) {
1964   assert(is_pcrelative_long(pc), &quot;not a pcrelative instruction&quot;);
1965   return pc + get_pcrel_offset(pc);
1966 }
1967 
1968 // Patch pc relative load address.
1969 void MacroAssembler::patch_target_addr_pcrel(address pc, address con) {
1970   unsigned long inst;
1971   // Offset is +/- 2**32 -&gt; use long.
1972   ptrdiff_t distance = con - pc;
1973 
1974   get_instruction(pc, &amp;inst);
1975 
1976   if (is_pcrelative_short(inst)) {
1977     *(short *)(pc+2) = RelAddr::pcrel_off16(con, pc);  // Instructions are at least 2-byte aligned, no test required.
1978 
1979     // Some extra safety net.
1980     if (!RelAddr::is_in_range_of_RelAddr16(distance)) {
1981       print_dbg_msg(tty, inst, &quot;distance out of range (16bit)&quot;, 4);
1982       dump_code_range(tty, pc, 32, &quot;distance out of range (16bit)&quot;);
1983       guarantee(RelAddr::is_in_range_of_RelAddr16(distance), &quot;too far away (more than +/- 2**16&quot;);
1984     }
1985     return;
1986   }
1987 
1988   if (is_pcrelative_long(inst)) {
1989     *(int *)(pc+2)   = RelAddr::pcrel_off32(con, pc);
1990 
1991     // Some Extra safety net.
1992     if (!RelAddr::is_in_range_of_RelAddr32(distance)) {
1993       print_dbg_msg(tty, inst, &quot;distance out of range (32bit)&quot;, 6);
1994       dump_code_range(tty, pc, 32, &quot;distance out of range (32bit)&quot;);
1995       guarantee(RelAddr::is_in_range_of_RelAddr32(distance), &quot;too far away (more than +/- 2**32&quot;);
1996     }
1997     return;
1998   }
1999 
2000   guarantee(false, &quot;not a pcrelative instruction to patch!&quot;);
2001 }
2002 
2003 // &quot;Current PC&quot; here means the address just behind the basr instruction.
2004 address MacroAssembler::get_PC(Register result) {
2005   z_basr(result, Z_R0); // Don&#39;t branch, just save next instruction address in result.
2006   return pc();
2007 }
2008 
2009 // Get current PC + offset.
2010 // Offset given in bytes, must be even!
2011 // &quot;Current PC&quot; here means the address of the larl instruction plus the given offset.
2012 address MacroAssembler::get_PC(Register result, int64_t offset) {
2013   address here = pc();
2014   z_larl(result, offset/2); // Save target instruction address in result.
2015   return here + offset;
2016 }
2017 
2018 void MacroAssembler::instr_size(Register size, Register pc) {
2019   // Extract 2 most significant bits of current instruction.
2020   z_llgc(size, Address(pc));
2021   z_srl(size, 6);
2022   // Compute (x+3)&amp;6 which translates 0-&gt;2, 1-&gt;4, 2-&gt;4, 3-&gt;6.
2023   z_ahi(size, 3);
2024   z_nill(size, 6);
2025 }
2026 
2027 // Resize_frame with SP(new) = SP(old) - [offset].
2028 void MacroAssembler::resize_frame_sub(Register offset, Register fp, bool load_fp)
2029 {
2030   assert_different_registers(offset, fp, Z_SP);
2031   if (load_fp) { z_lg(fp, _z_abi(callers_sp), Z_SP); }
2032 
2033   z_sgr(Z_SP, offset);
2034   z_stg(fp, _z_abi(callers_sp), Z_SP);
2035 }
2036 
2037 // Resize_frame with SP(new) = [newSP] + offset.
2038 //   This emitter is useful if we already have calculated a pointer
2039 //   into the to-be-allocated stack space, e.g. with special alignment properties,
2040 //   but need some additional space, e.g. for spilling.
2041 //   newSP    is the pre-calculated pointer. It must not be modified.
2042 //   fp       holds, or is filled with, the frame pointer.
2043 //   offset   is the additional increment which is added to addr to form the new SP.
2044 //            Note: specify a negative value to reserve more space!
2045 //   load_fp == true  only indicates that fp is not pre-filled with the frame pointer.
2046 //                    It does not guarantee that fp contains the frame pointer at the end.
2047 void MacroAssembler::resize_frame_abs_with_offset(Register newSP, Register fp, int offset, bool load_fp) {
2048   assert_different_registers(newSP, fp, Z_SP);
2049 
2050   if (load_fp) {
2051     z_lg(fp, _z_abi(callers_sp), Z_SP);
2052   }
2053 
2054   add2reg(Z_SP, offset, newSP);
2055   z_stg(fp, _z_abi(callers_sp), Z_SP);
2056 }
2057 
2058 // Resize_frame with SP(new) = [newSP].
2059 //   load_fp == true  only indicates that fp is not pre-filled with the frame pointer.
2060 //                    It does not guarantee that fp contains the frame pointer at the end.
2061 void MacroAssembler::resize_frame_absolute(Register newSP, Register fp, bool load_fp) {
2062   assert_different_registers(newSP, fp, Z_SP);
2063 
2064   if (load_fp) {
2065     z_lg(fp, _z_abi(callers_sp), Z_SP); // need to use load/store.
2066   }
2067 
2068   z_lgr(Z_SP, newSP);
2069   if (newSP != Z_R0) { // make sure we generate correct code, no matter what register newSP uses.
2070     z_stg(fp, _z_abi(callers_sp), newSP);
2071   } else {
2072     z_stg(fp, _z_abi(callers_sp), Z_SP);
2073   }
2074 }
2075 
2076 // Resize_frame with SP(new) = SP(old) + offset.
2077 void MacroAssembler::resize_frame(RegisterOrConstant offset, Register fp, bool load_fp) {
2078   assert_different_registers(fp, Z_SP);
2079 
2080   if (load_fp) {
2081     z_lg(fp, _z_abi(callers_sp), Z_SP);
2082   }
2083   add64(Z_SP, offset);
2084   z_stg(fp, _z_abi(callers_sp), Z_SP);
2085 }
2086 
2087 void MacroAssembler::push_frame(Register bytes, Register old_sp, bool copy_sp, bool bytes_with_inverted_sign) {
2088 #ifdef ASSERT
2089   assert_different_registers(bytes, old_sp, Z_SP);
2090   if (!copy_sp) {
2091     z_cgr(old_sp, Z_SP);
2092     asm_assert_eq(&quot;[old_sp]!=[Z_SP]&quot;, 0x211);
2093   }
2094 #endif
2095   if (copy_sp) { z_lgr(old_sp, Z_SP); }
2096   if (bytes_with_inverted_sign) {
2097     z_agr(Z_SP, bytes);
2098   } else {
2099     z_sgr(Z_SP, bytes); // Z_sgfr sufficient, but probably not faster.
2100   }
2101   z_stg(old_sp, _z_abi(callers_sp), Z_SP);
2102 }
2103 
2104 unsigned int MacroAssembler::push_frame(unsigned int bytes, Register scratch) {
2105   long offset = Assembler::align(bytes, frame::alignment_in_bytes);
2106   assert(offset &gt; 0, &quot;should push a frame with positive size, size = %ld.&quot;, offset);
2107   assert(Displacement::is_validDisp(-offset), &quot;frame size out of range, size = %ld&quot;, offset);
2108 
2109   // We must not write outside the current stack bounds (given by Z_SP).
2110   // Thus, we have to first update Z_SP and then store the previous SP as stack linkage.
2111   // We rely on Z_R0 by default to be available as scratch.
2112   z_lgr(scratch, Z_SP);
2113   add2reg(Z_SP, -offset);
2114   z_stg(scratch, _z_abi(callers_sp), Z_SP);
2115 #ifdef ASSERT
2116   // Just make sure nobody uses the value in the default scratch register.
2117   // When another register is used, the caller might rely on it containing the frame pointer.
2118   if (scratch == Z_R0) {
2119     z_iihf(scratch, 0xbaadbabe);
2120     z_iilf(scratch, 0xdeadbeef);
2121   }
2122 #endif
2123   return offset;
2124 }
2125 
2126 // Push a frame of size `bytes&#39; plus abi160 on top.
2127 unsigned int MacroAssembler::push_frame_abi160(unsigned int bytes) {
2128   BLOCK_COMMENT(&quot;push_frame_abi160 {&quot;);
2129   unsigned int res = push_frame(bytes + frame::z_abi_160_size);
2130   BLOCK_COMMENT(&quot;} push_frame_abi160&quot;);
2131   return res;
2132 }
2133 
2134 // Pop current C frame.
2135 void MacroAssembler::pop_frame() {
2136   BLOCK_COMMENT(&quot;pop_frame:&quot;);
2137   Assembler::z_lg(Z_SP, _z_abi(callers_sp), Z_SP);
2138 }
2139 
2140 // Pop current C frame and restore return PC register (Z_R14).
2141 void MacroAssembler::pop_frame_restore_retPC(int frame_size_in_bytes) {
2142   BLOCK_COMMENT(&quot;pop_frame_restore_retPC:&quot;);
2143   int retPC_offset = _z_abi16(return_pc) + frame_size_in_bytes;
2144   // If possible, pop frame by add instead of load (a penny saved is a penny got :-).
2145   if (Displacement::is_validDisp(retPC_offset)) {
2146     z_lg(Z_R14, retPC_offset, Z_SP);
2147     add2reg(Z_SP, frame_size_in_bytes);
2148   } else {
2149     add2reg(Z_SP, frame_size_in_bytes);
2150     restore_return_pc();
2151   }
2152 }
2153 
2154 void MacroAssembler::call_VM_leaf_base(address entry_point, bool allow_relocation) {
2155   if (allow_relocation) {
2156     call_c(entry_point);
2157   } else {
2158     call_c_static(entry_point);
2159   }
2160 }
2161 
2162 void MacroAssembler::call_VM_leaf_base(address entry_point) {
2163   bool allow_relocation = true;
2164   call_VM_leaf_base(entry_point, allow_relocation);
2165 }
2166 
2167 void MacroAssembler::call_VM_base(Register oop_result,
2168                                   Register last_java_sp,
2169                                   address  entry_point,
2170                                   bool     allow_relocation,
2171                                   bool     check_exceptions) { // Defaults to true.
2172   // Allow_relocation indicates, if true, that the generated code shall
2173   // be fit for code relocation or referenced data relocation. In other
2174   // words: all addresses must be considered variable. PC-relative addressing
2175   // is not possible then.
2176   // On the other hand, if (allow_relocation == false), addresses and offsets
2177   // may be considered stable, enabling us to take advantage of some PC-relative
2178   // addressing tweaks. These might improve performance and reduce code size.
2179 
2180   // Determine last_java_sp register.
2181   if (!last_java_sp-&gt;is_valid()) {
2182     last_java_sp = Z_SP;  // Load Z_SP as SP.
2183   }
2184 
2185   set_top_ijava_frame_at_SP_as_last_Java_frame(last_java_sp, Z_R1, allow_relocation);
2186 
2187   // ARG1 must hold thread address.
2188   z_lgr(Z_ARG1, Z_thread);
2189 
2190   address return_pc = NULL;
2191   if (allow_relocation) {
2192     return_pc = call_c(entry_point);
2193   } else {
2194     return_pc = call_c_static(entry_point);
2195   }
2196 
2197   reset_last_Java_frame(allow_relocation);
2198 
2199   // C++ interp handles this in the interpreter.
2200   check_and_handle_popframe(Z_thread);
2201   check_and_handle_earlyret(Z_thread);
2202 
2203   // Check for pending exceptions.
2204   if (check_exceptions) {
2205     // Check for pending exceptions (java_thread is set upon return).
2206     load_and_test_long(Z_R0_scratch, Address(Z_thread, Thread::pending_exception_offset()));
2207 
2208     // This used to conditionally jump to forward_exception however it is
2209     // possible if we relocate that the branch will not reach. So we must jump
2210     // around so we can always reach.
2211 
2212     Label ok;
2213     z_bre(ok); // Bcondequal is the same as bcondZero.
2214     call_stub(StubRoutines::forward_exception_entry());
2215     bind(ok);
2216   }
2217 
2218   // Get oop result if there is one and reset the value in the thread.
2219   if (oop_result-&gt;is_valid()) {
2220     get_vm_result(oop_result);
2221   }
2222 
2223   _last_calls_return_pc = return_pc;  // Wipe out other (error handling) calls.
2224 }
2225 
2226 void MacroAssembler::call_VM_base(Register oop_result,
2227                                   Register last_java_sp,
2228                                   address  entry_point,
2229                                   bool     check_exceptions) { // Defaults to true.
2230   bool allow_relocation = true;
2231   call_VM_base(oop_result, last_java_sp, entry_point, allow_relocation, check_exceptions);
2232 }
2233 
2234 // VM calls without explicit last_java_sp.
2235 
2236 void MacroAssembler::call_VM(Register oop_result, address entry_point, bool check_exceptions) {
2237   // Call takes possible detour via InterpreterMacroAssembler.
2238   call_VM_base(oop_result, noreg, entry_point, true, check_exceptions);
2239 }
2240 
2241 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, bool check_exceptions) {
2242   // Z_ARG1 is reserved for the thread.
2243   lgr_if_needed(Z_ARG2, arg_1);
2244   call_VM(oop_result, entry_point, check_exceptions);
2245 }
2246 
2247 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, Register arg_2, bool check_exceptions) {
2248   // Z_ARG1 is reserved for the thread.
2249   lgr_if_needed(Z_ARG2, arg_1);
2250   assert(arg_2 != Z_ARG2, &quot;smashed argument&quot;);
2251   lgr_if_needed(Z_ARG3, arg_2);
2252   call_VM(oop_result, entry_point, check_exceptions);
2253 }
2254 
2255 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, Register arg_2,
2256                              Register arg_3, bool check_exceptions) {
2257   // Z_ARG1 is reserved for the thread.
2258   lgr_if_needed(Z_ARG2, arg_1);
2259   assert(arg_2 != Z_ARG2, &quot;smashed argument&quot;);
2260   lgr_if_needed(Z_ARG3, arg_2);
2261   assert(arg_3 != Z_ARG2 &amp;&amp; arg_3 != Z_ARG3, &quot;smashed argument&quot;);
2262   lgr_if_needed(Z_ARG4, arg_3);
2263   call_VM(oop_result, entry_point, check_exceptions);
2264 }
2265 
2266 // VM static calls without explicit last_java_sp.
2267 
2268 void MacroAssembler::call_VM_static(Register oop_result, address entry_point, bool check_exceptions) {
2269   // Call takes possible detour via InterpreterMacroAssembler.
2270   call_VM_base(oop_result, noreg, entry_point, false, check_exceptions);
2271 }
2272 
2273 void MacroAssembler::call_VM_static(Register oop_result, address entry_point, Register arg_1, Register arg_2,
2274                                     Register arg_3, bool check_exceptions) {
2275   // Z_ARG1 is reserved for the thread.
2276   lgr_if_needed(Z_ARG2, arg_1);
2277   assert(arg_2 != Z_ARG2, &quot;smashed argument&quot;);
2278   lgr_if_needed(Z_ARG3, arg_2);
2279   assert(arg_3 != Z_ARG2 &amp;&amp; arg_3 != Z_ARG3, &quot;smashed argument&quot;);
2280   lgr_if_needed(Z_ARG4, arg_3);
2281   call_VM_static(oop_result, entry_point, check_exceptions);
2282 }
2283 
2284 // VM calls with explicit last_java_sp.
2285 
2286 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, bool check_exceptions) {
2287   // Call takes possible detour via InterpreterMacroAssembler.
2288   call_VM_base(oop_result, last_java_sp, entry_point, true, check_exceptions);
2289 }
2290 
2291 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions) {
2292    // Z_ARG1 is reserved for the thread.
2293    lgr_if_needed(Z_ARG2, arg_1);
2294    call_VM(oop_result, last_java_sp, entry_point, check_exceptions);
2295 }
2296 
2297 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1,
2298                              Register arg_2, bool check_exceptions) {
2299    // Z_ARG1 is reserved for the thread.
2300    lgr_if_needed(Z_ARG2, arg_1);
2301    assert(arg_2 != Z_ARG2, &quot;smashed argument&quot;);
2302    lgr_if_needed(Z_ARG3, arg_2);
2303    call_VM(oop_result, last_java_sp, entry_point, check_exceptions);
2304 }
2305 
2306 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1,
2307                              Register arg_2, Register arg_3, bool check_exceptions) {
2308   // Z_ARG1 is reserved for the thread.
2309   lgr_if_needed(Z_ARG2, arg_1);
2310   assert(arg_2 != Z_ARG2, &quot;smashed argument&quot;);
2311   lgr_if_needed(Z_ARG3, arg_2);
2312   assert(arg_3 != Z_ARG2 &amp;&amp; arg_3 != Z_ARG3, &quot;smashed argument&quot;);
2313   lgr_if_needed(Z_ARG4, arg_3);
2314   call_VM(oop_result, last_java_sp, entry_point, check_exceptions);
2315 }
2316 
2317 // VM leaf calls.
2318 
2319 void MacroAssembler::call_VM_leaf(address entry_point) {
2320   // Call takes possible detour via InterpreterMacroAssembler.
2321   call_VM_leaf_base(entry_point, true);
2322 }
2323 
2324 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_1) {
2325   if (arg_1 != noreg) lgr_if_needed(Z_ARG1, arg_1);
2326   call_VM_leaf(entry_point);
2327 }
2328 
2329 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_1, Register arg_2) {
2330   if (arg_1 != noreg) lgr_if_needed(Z_ARG1, arg_1);
2331   assert(arg_2 != Z_ARG1, &quot;smashed argument&quot;);
2332   if (arg_2 != noreg) lgr_if_needed(Z_ARG2, arg_2);
2333   call_VM_leaf(entry_point);
2334 }
2335 
2336 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3) {
2337   if (arg_1 != noreg) lgr_if_needed(Z_ARG1, arg_1);
2338   assert(arg_2 != Z_ARG1, &quot;smashed argument&quot;);
2339   if (arg_2 != noreg) lgr_if_needed(Z_ARG2, arg_2);
2340   assert(arg_3 != Z_ARG1 &amp;&amp; arg_3 != Z_ARG2, &quot;smashed argument&quot;);
2341   if (arg_3 != noreg) lgr_if_needed(Z_ARG3, arg_3);
2342   call_VM_leaf(entry_point);
2343 }
2344 
2345 // Static VM leaf calls.
2346 // Really static VM leaf calls are never patched.
2347 
2348 void MacroAssembler::call_VM_leaf_static(address entry_point) {
2349   // Call takes possible detour via InterpreterMacroAssembler.
2350   call_VM_leaf_base(entry_point, false);
2351 }
2352 
2353 void MacroAssembler::call_VM_leaf_static(address entry_point, Register arg_1) {
2354   if (arg_1 != noreg) lgr_if_needed(Z_ARG1, arg_1);
2355   call_VM_leaf_static(entry_point);
2356 }
2357 
2358 void MacroAssembler::call_VM_leaf_static(address entry_point, Register arg_1, Register arg_2) {
2359   if (arg_1 != noreg) lgr_if_needed(Z_ARG1, arg_1);
2360   assert(arg_2 != Z_ARG1, &quot;smashed argument&quot;);
2361   if (arg_2 != noreg) lgr_if_needed(Z_ARG2, arg_2);
2362   call_VM_leaf_static(entry_point);
2363 }
2364 
2365 void MacroAssembler::call_VM_leaf_static(address entry_point, Register arg_1, Register arg_2, Register arg_3) {
2366   if (arg_1 != noreg) lgr_if_needed(Z_ARG1, arg_1);
2367   assert(arg_2 != Z_ARG1, &quot;smashed argument&quot;);
2368   if (arg_2 != noreg) lgr_if_needed(Z_ARG2, arg_2);
2369   assert(arg_3 != Z_ARG1 &amp;&amp; arg_3 != Z_ARG2, &quot;smashed argument&quot;);
2370   if (arg_3 != noreg) lgr_if_needed(Z_ARG3, arg_3);
2371   call_VM_leaf_static(entry_point);
2372 }
2373 
2374 // Don&#39;t use detour via call_c(reg).
2375 address MacroAssembler::call_c(address function_entry) {
2376   load_const(Z_R1, function_entry);
2377   return call(Z_R1);
2378 }
2379 
2380 // Variant for really static (non-relocatable) calls which are never patched.
2381 address MacroAssembler::call_c_static(address function_entry) {
2382   load_absolute_address(Z_R1, function_entry);
2383 #if 0 // def ASSERT
2384   // Verify that call site did not move.
2385   load_const_optimized(Z_R0, function_entry);
2386   z_cgr(Z_R1, Z_R0);
2387   z_brc(bcondEqual, 3);
2388   z_illtrap(0xba);
2389 #endif
2390   return call(Z_R1);
2391 }
2392 
2393 address MacroAssembler::call_c_opt(address function_entry) {
2394   bool success = call_far_patchable(function_entry, -2 /* emit relocation + constant */);
2395   _last_calls_return_pc = success ? pc() : NULL;
2396   return _last_calls_return_pc;
2397 }
2398 
2399 // Identify a call_far_patchable instruction: LARL + LG + BASR
2400 //
2401 //    nop                   ; optionally, if required for alignment
2402 //    lgrl rx,A(TOC entry)  ; PC-relative access into constant pool
2403 //    basr Z_R14,rx         ; end of this instruction must be aligned to a word boundary
2404 //
2405 // Code pattern will eventually get patched into variant2 (see below for detection code).
2406 //
2407 bool MacroAssembler::is_call_far_patchable_variant0_at(address instruction_addr) {
2408   address iaddr = instruction_addr;
2409 
2410   // Check for the actual load instruction.
2411   if (!is_load_const_from_toc(iaddr)) { return false; }
2412   iaddr += load_const_from_toc_size();
2413 
2414   // Check for the call (BASR) instruction, finally.
2415   assert(iaddr-instruction_addr+call_byregister_size() == call_far_patchable_size(), &quot;size mismatch&quot;);
2416   return is_call_byregister(iaddr);
2417 }
2418 
2419 // Identify a call_far_patchable instruction: BRASL
2420 //
2421 // Code pattern to suits atomic patching:
2422 //    nop                       ; Optionally, if required for alignment.
2423 //    nop    ...                ; Multiple filler nops to compensate for size difference (variant0 is longer).
2424 //    nop                       ; For code pattern detection: Prepend each BRASL with a nop.
2425 //    brasl  Z_R14,&lt;reladdr&gt;    ; End of code must be 4-byte aligned !
2426 bool MacroAssembler::is_call_far_patchable_variant2_at(address instruction_addr) {
2427   const address call_addr = (address)((intptr_t)instruction_addr + call_far_patchable_size() - call_far_pcrelative_size());
2428 
2429   // Check for correct number of leading nops.
2430   address iaddr;
2431   for (iaddr = instruction_addr; iaddr &lt; call_addr; iaddr += nop_size()) {
2432     if (!is_z_nop(iaddr)) { return false; }
2433   }
2434   assert(iaddr == call_addr, &quot;sanity&quot;);
2435 
2436   // --&gt; Check for call instruction.
2437   if (is_call_far_pcrelative(call_addr)) {
2438     assert(call_addr-instruction_addr+call_far_pcrelative_size() == call_far_patchable_size(), &quot;size mismatch&quot;);
2439     return true;
2440   }
2441 
2442   return false;
2443 }
2444 
2445 // Emit a NOT mt-safely patchable 64 bit absolute call.
2446 // If toc_offset == -2, then the destination of the call (= target) is emitted
2447 //                      to the constant pool and a runtime_call relocation is added
2448 //                      to the code buffer.
2449 // If toc_offset != -2, target must already be in the constant pool at
2450 //                      _ctableStart+toc_offset (a caller can retrieve toc_offset
2451 //                      from the runtime_call relocation).
2452 // Special handling of emitting to scratch buffer when there is no constant pool.
2453 // Slightly changed code pattern. We emit an additional nop if we would
2454 // not end emitting at a word aligned address. This is to ensure
2455 // an atomically patchable displacement in brasl instructions.
2456 //
2457 // A call_far_patchable comes in different flavors:
2458 //  - LARL(CP) / LG(CP) / BR (address in constant pool, access via CP register)
2459 //  - LGRL(CP) / BR          (address in constant pool, pc-relative accesss)
2460 //  - BRASL                  (relative address of call target coded in instruction)
2461 // All flavors occupy the same amount of space. Length differences are compensated
2462 // by leading nops, such that the instruction sequence always ends at the same
2463 // byte offset. This is required to keep the return offset constant.
2464 // Furthermore, the return address (the end of the instruction sequence) is forced
2465 // to be on a 4-byte boundary. This is required for atomic patching, should we ever
2466 // need to patch the call target of the BRASL flavor.
2467 // RETURN value: false, if no constant pool entry could be allocated, true otherwise.
2468 bool MacroAssembler::call_far_patchable(address target, int64_t tocOffset) {
2469   // Get current pc and ensure word alignment for end of instr sequence.
2470   const address start_pc = pc();
2471   const intptr_t       start_off = offset();
2472   assert(!call_far_patchable_requires_alignment_nop(start_pc), &quot;call_far_patchable requires aligned address&quot;);
2473   const ptrdiff_t      dist      = (ptrdiff_t)(target - (start_pc + 2)); // Prepend each BRASL with a nop.
2474   const bool emit_target_to_pool = (tocOffset == -2) &amp;&amp; !code_section()-&gt;scratch_emit();
2475   const bool emit_relative_call  = !emit_target_to_pool &amp;&amp;
2476                                    RelAddr::is_in_range_of_RelAddr32(dist) &amp;&amp;
2477                                    ReoptimizeCallSequences &amp;&amp;
2478                                    !code_section()-&gt;scratch_emit();
2479 
2480   if (emit_relative_call) {
2481     // Add padding to get the same size as below.
2482     const unsigned int padding = call_far_patchable_size() - call_far_pcrelative_size();
2483     unsigned int current_padding;
2484     for (current_padding = 0; current_padding &lt; padding; current_padding += nop_size()) { z_nop(); }
2485     assert(current_padding == padding, &quot;sanity&quot;);
2486 
2487     // relative call: len = 2(nop) + 6 (brasl)
2488     // CodeBlob resize cannot occur in this case because
2489     // this call is emitted into pre-existing space.
2490     z_nop(); // Prepend each BRASL with a nop.
2491     z_brasl(Z_R14, target);
2492   } else {
2493     // absolute call: Get address from TOC.
2494     // len = (load TOC){6|0} + (load from TOC){6} + (basr){2} = {14|8}
2495     if (emit_target_to_pool) {
2496       // When emitting the call for the first time, we do not need to use
2497       // the pc-relative version. It will be patched anyway, when the code
2498       // buffer is copied.
2499       // Relocation is not needed when !ReoptimizeCallSequences.
2500       relocInfo::relocType rt = ReoptimizeCallSequences ? relocInfo::runtime_call_w_cp_type : relocInfo::none;
2501       AddressLiteral dest(target, rt);
2502       // Store_oop_in_toc() adds dest to the constant table. As side effect, this kills
2503       // inst_mark(). Reset if possible.
2504       bool reset_mark = (inst_mark() == pc());
2505       tocOffset = store_oop_in_toc(dest);
2506       if (reset_mark) { set_inst_mark(); }
2507       if (tocOffset == -1) {
2508         return false; // Couldn&#39;t create constant pool entry.
2509       }
2510     }
2511     assert(offset() == start_off, &quot;emit no code before this point!&quot;);
2512 
2513     address tocPos = pc() + tocOffset;
2514     if (emit_target_to_pool) {
2515       tocPos = code()-&gt;consts()-&gt;start() + tocOffset;
2516     }
2517     load_long_pcrelative(Z_R14, tocPos);
2518     z_basr(Z_R14, Z_R14);
2519   }
2520 
2521 #ifdef ASSERT
2522   // Assert that we can identify the emitted call.
2523   assert(is_call_far_patchable_at(addr_at(start_off)), &quot;can&#39;t identify emitted call&quot;);
2524   assert(offset() == start_off+call_far_patchable_size(), &quot;wrong size&quot;);
2525 
2526   if (emit_target_to_pool) {
2527     assert(get_dest_of_call_far_patchable_at(addr_at(start_off), code()-&gt;consts()-&gt;start()) == target,
2528            &quot;wrong encoding of dest address&quot;);
2529   }
2530 #endif
2531   return true; // success
2532 }
2533 
2534 // Identify a call_far_patchable instruction.
2535 // For more detailed information see header comment of call_far_patchable.
2536 bool MacroAssembler::is_call_far_patchable_at(address instruction_addr) {
2537   return is_call_far_patchable_variant2_at(instruction_addr)  || // short version: BRASL
2538          is_call_far_patchable_variant0_at(instruction_addr);    // long version LARL + LG + BASR
2539 }
2540 
2541 // Does the call_far_patchable instruction use a pc-relative encoding
2542 // of the call destination?
2543 bool MacroAssembler::is_call_far_patchable_pcrelative_at(address instruction_addr) {
2544   // Variant 2 is pc-relative.
2545   return is_call_far_patchable_variant2_at(instruction_addr);
2546 }
2547 
2548 bool MacroAssembler::is_call_far_pcrelative(address instruction_addr) {
2549   // Prepend each BRASL with a nop.
2550   return is_z_nop(instruction_addr) &amp;&amp; is_z_brasl(instruction_addr + nop_size());  // Match at position after one nop required.
2551 }
2552 
2553 // Set destination address of a call_far_patchable instruction.
2554 void MacroAssembler::set_dest_of_call_far_patchable_at(address instruction_addr, address dest, int64_t tocOffset) {
2555   ResourceMark rm;
2556 
2557   // Now that CP entry is verified, patch call to a pc-relative call (if circumstances permit).
2558   int code_size = MacroAssembler::call_far_patchable_size();
2559   CodeBuffer buf(instruction_addr, code_size);
2560   MacroAssembler masm(&amp;buf);
2561   masm.call_far_patchable(dest, tocOffset);
2562   ICache::invalidate_range(instruction_addr, code_size); // Empty on z.
2563 }
2564 
2565 // Get dest address of a call_far_patchable instruction.
2566 address MacroAssembler::get_dest_of_call_far_patchable_at(address instruction_addr, address ctable) {
2567   // Dynamic TOC: absolute address in constant pool.
2568   // Check variant2 first, it is more frequent.
2569 
2570   // Relative address encoded in call instruction.
2571   if (is_call_far_patchable_variant2_at(instruction_addr)) {
2572     return MacroAssembler::get_target_addr_pcrel(instruction_addr + nop_size()); // Prepend each BRASL with a nop.
2573 
2574   // Absolute address in constant pool.
2575   } else if (is_call_far_patchable_variant0_at(instruction_addr)) {
2576     address iaddr = instruction_addr;
2577 
2578     long    tocOffset = get_load_const_from_toc_offset(iaddr);
2579     address tocLoc    = iaddr + tocOffset;
2580     return *(address *)(tocLoc);
2581   } else {
2582     fprintf(stderr, &quot;MacroAssembler::get_dest_of_call_far_patchable_at has a problem at %p:\n&quot;, instruction_addr);
2583     fprintf(stderr, &quot;not a call_far_patchable: %16.16lx %16.16lx, len = %d\n&quot;,
2584             *(unsigned long*)instruction_addr,
2585             *(unsigned long*)(instruction_addr+8),
2586             call_far_patchable_size());
2587     Disassembler::decode(instruction_addr, instruction_addr+call_far_patchable_size());
2588     ShouldNotReachHere();
2589     return NULL;
2590   }
2591 }
2592 
2593 void MacroAssembler::align_call_far_patchable(address pc) {
2594   if (call_far_patchable_requires_alignment_nop(pc)) { z_nop(); }
2595 }
2596 
2597 void MacroAssembler::check_and_handle_earlyret(Register java_thread) {
2598 }
2599 
2600 void MacroAssembler::check_and_handle_popframe(Register java_thread) {
2601 }
2602 
2603 // Read from the polling page.
2604 // Use TM or TMY instruction, depending on read offset.
2605 //   offset = 0: Use TM, safepoint polling.
2606 //   offset &lt; 0: Use TMY, profiling safepoint polling.
2607 void MacroAssembler::load_from_polling_page(Register polling_page_address, int64_t offset) {
2608   if (Immediate::is_uimm12(offset)) {
2609     z_tm(offset, polling_page_address, mask_safepoint);
2610   } else {
2611     z_tmy(offset, polling_page_address, mask_profiling);
2612   }
2613 }
2614 
2615 // Check whether z_instruction is a read access to the polling page
2616 // which was emitted by load_from_polling_page(..).
2617 bool MacroAssembler::is_load_from_polling_page(address instr_loc) {
2618   unsigned long z_instruction;
2619   unsigned int  ilen = get_instruction(instr_loc, &amp;z_instruction);
2620 
2621   if (ilen == 2) { return false; } // It&#39;s none of the allowed instructions.
2622 
2623   if (ilen == 4) {
2624     if (!is_z_tm(z_instruction)) { return false; } // It&#39;s len=4, but not a z_tm. fail.
2625 
2626     int ms = inv_mask(z_instruction,8,32);  // mask
2627     int ra = inv_reg(z_instruction,16,32);  // base register
2628     int ds = inv_uimm12(z_instruction);     // displacement
2629 
2630     if (!(ds == 0 &amp;&amp; ra != 0 &amp;&amp; ms == mask_safepoint)) {
2631       return false; // It&#39;s not a z_tm(0, ra, mask_safepoint). Fail.
2632     }
2633 
2634   } else { /* if (ilen == 6) */
2635 
2636     assert(!is_z_lg(z_instruction), &quot;old form (LG) polling page access. Please fix and use TM(Y).&quot;);
2637 
2638     if (!is_z_tmy(z_instruction)) { return false; } // It&#39;s len=6, but not a z_tmy. fail.
2639 
2640     int ms = inv_mask(z_instruction,8,48);  // mask
2641     int ra = inv_reg(z_instruction,16,48);  // base register
2642     int ds = inv_simm20(z_instruction);     // displacement
2643   }
2644 
2645   return true;
2646 }
2647 
2648 // Extract poll address from instruction and ucontext.
2649 address MacroAssembler::get_poll_address(address instr_loc, void* ucontext) {
2650   assert(ucontext != NULL, &quot;must have ucontext&quot;);
2651   ucontext_t* uc = (ucontext_t*) ucontext;
2652   unsigned long z_instruction;
2653   unsigned int ilen = get_instruction(instr_loc, &amp;z_instruction);
2654 
2655   if (ilen == 4 &amp;&amp; is_z_tm(z_instruction)) {
2656     int ra = inv_reg(z_instruction, 16, 32);  // base register
2657     int ds = inv_uimm12(z_instruction);       // displacement
2658     address addr = (address)uc-&gt;uc_mcontext.gregs[ra];
2659     return addr + ds;
2660   } else if (ilen == 6 &amp;&amp; is_z_tmy(z_instruction)) {
2661     int ra = inv_reg(z_instruction, 16, 48);  // base register
2662     int ds = inv_simm20(z_instruction);       // displacement
2663     address addr = (address)uc-&gt;uc_mcontext.gregs[ra];
2664     return addr + ds;
2665   }
2666 
2667   ShouldNotReachHere();
2668   return NULL;
2669 }
2670 
2671 // Extract poll register from instruction.
2672 uint MacroAssembler::get_poll_register(address instr_loc) {
2673   unsigned long z_instruction;
2674   unsigned int ilen = get_instruction(instr_loc, &amp;z_instruction);
2675 
2676   if (ilen == 4 &amp;&amp; is_z_tm(z_instruction)) {
2677     return (uint)inv_reg(z_instruction, 16, 32);  // base register
2678   } else if (ilen == 6 &amp;&amp; is_z_tmy(z_instruction)) {
2679     return (uint)inv_reg(z_instruction, 16, 48);  // base register
2680   }
2681 
2682   ShouldNotReachHere();
2683   return 0;
2684 }
2685 
2686 void MacroAssembler::safepoint_poll(Label&amp; slow_path, Register temp_reg) {
2687   if (SafepointMechanism::uses_thread_local_poll()) {
2688     const Address poll_byte_addr(Z_thread, in_bytes(Thread::polling_page_offset()) + 7 /* Big Endian */);
2689     // Armed page has poll_bit set.
2690     z_tm(poll_byte_addr, SafepointMechanism::poll_bit());
2691     z_brnaz(slow_path);
2692   } else {
2693     load_const_optimized(temp_reg, SafepointSynchronize::address_of_state());
2694     z_cli(/*SafepointSynchronize::sz_state()*/4-1, temp_reg, SafepointSynchronize::_not_synchronized);
2695     z_brne(slow_path);
2696   }
2697 }
2698 
2699 // Don&#39;t rely on register locking, always use Z_R1 as scratch register instead.
2700 void MacroAssembler::bang_stack_with_offset(int offset) {
2701   // Stack grows down, caller passes positive offset.
2702   assert(offset &gt; 0, &quot;must bang with positive offset&quot;);
2703   if (Displacement::is_validDisp(-offset)) {
2704     z_tmy(-offset, Z_SP, mask_stackbang);
2705   } else {
2706     add2reg(Z_R1, -offset, Z_SP);    // Do not destroy Z_SP!!!
2707     z_tm(0, Z_R1, mask_stackbang);  // Just banging.
2708   }
2709 }
2710 
2711 void MacroAssembler::reserved_stack_check(Register return_pc) {
2712   // Test if reserved zone needs to be enabled.
2713   Label no_reserved_zone_enabling;
2714   assert(return_pc == Z_R14, &quot;Return pc must be in R14 before z_br() to StackOverflow stub.&quot;);
2715   BLOCK_COMMENT(&quot;reserved_stack_check {&quot;);
2716 
2717   z_clg(Z_SP, Address(Z_thread, JavaThread::reserved_stack_activation_offset()));
2718   z_brl(no_reserved_zone_enabling);
2719 
2720   // Enable reserved zone again, throw stack overflow exception.
2721   save_return_pc();
2722   push_frame_abi160(0);
2723   call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), Z_thread);
2724   pop_frame();
2725   restore_return_pc();
2726 
2727   load_const_optimized(Z_R1, StubRoutines::throw_delayed_StackOverflowError_entry());
2728   // Don&#39;t use call() or z_basr(), they will invalidate Z_R14 which contains the return pc.
2729   z_br(Z_R1);
2730 
2731   should_not_reach_here();
2732 
2733   bind(no_reserved_zone_enabling);
2734   BLOCK_COMMENT(&quot;} reserved_stack_check&quot;);
2735 }
2736 
2737 // Defines obj, preserves var_size_in_bytes, okay for t2 == var_size_in_bytes.
2738 void MacroAssembler::tlab_allocate(Register obj,
2739                                    Register var_size_in_bytes,
2740                                    int con_size_in_bytes,
2741                                    Register t1,
2742                                    Label&amp; slow_case) {
2743   assert_different_registers(obj, var_size_in_bytes, t1);
2744   Register end = t1;
2745   Register thread = Z_thread;
2746 
2747   z_lg(obj, Address(thread, JavaThread::tlab_top_offset()));
2748   if (var_size_in_bytes == noreg) {
2749     z_lay(end, Address(obj, con_size_in_bytes));
2750   } else {
2751     z_lay(end, Address(obj, var_size_in_bytes));
2752   }
2753   z_cg(end, Address(thread, JavaThread::tlab_end_offset()));
2754   branch_optimized(bcondHigh, slow_case);
2755 
2756   // Update the tlab top pointer.
2757   z_stg(end, Address(thread, JavaThread::tlab_top_offset()));
2758 
2759   // Recover var_size_in_bytes if necessary.
2760   if (var_size_in_bytes == end) {
2761     z_sgr(var_size_in_bytes, obj);
2762   }
2763 }
2764 
2765 // Emitter for interface method lookup.
2766 //   input: recv_klass, intf_klass, itable_index
2767 //   output: method_result
2768 //   kills: itable_index, temp1_reg, Z_R0, Z_R1
2769 // TODO: Temp2_reg is unused. we may use this emitter also in the itable stubs.
2770 // If the register is still not needed then, remove it.
2771 void MacroAssembler::lookup_interface_method(Register           recv_klass,
2772                                              Register           intf_klass,
2773                                              RegisterOrConstant itable_index,
2774                                              Register           method_result,
2775                                              Register           temp1_reg,
2776                                              Label&amp;             no_such_interface,
2777                                              bool               return_method) {
2778 
2779   const Register vtable_len = temp1_reg;    // Used to compute itable_entry_addr.
2780   const Register itable_entry_addr = Z_R1_scratch;
2781   const Register itable_interface = Z_R0_scratch;
2782 
2783   BLOCK_COMMENT(&quot;lookup_interface_method {&quot;);
2784 
2785   // Load start of itable entries into itable_entry_addr.
2786   z_llgf(vtable_len, Address(recv_klass, Klass::vtable_length_offset()));
2787   z_sllg(vtable_len, vtable_len, exact_log2(vtableEntry::size_in_bytes()));
2788 
2789   // Loop over all itable entries until desired interfaceOop(Rinterface) found.
2790   const int vtable_base_offset = in_bytes(Klass::vtable_start_offset());
2791 
2792   add2reg_with_index(itable_entry_addr,
2793                      vtable_base_offset + itableOffsetEntry::interface_offset_in_bytes(),
2794                      recv_klass, vtable_len);
2795 
2796   const int itable_offset_search_inc = itableOffsetEntry::size() * wordSize;
2797   Label     search;
2798 
2799   bind(search);
2800 
2801   // Handle IncompatibleClassChangeError.
2802   // If the entry is NULL then we&#39;ve reached the end of the table
2803   // without finding the expected interface, so throw an exception.
2804   load_and_test_long(itable_interface, Address(itable_entry_addr));
2805   z_bre(no_such_interface);
2806 
2807   add2reg(itable_entry_addr, itable_offset_search_inc);
2808   z_cgr(itable_interface, intf_klass);
2809   z_brne(search);
2810 
2811   // Entry found and itable_entry_addr points to it, get offset of vtable for interface.
2812   if (return_method) {
2813     const int vtable_offset_offset = (itableOffsetEntry::offset_offset_in_bytes() -
2814                                       itableOffsetEntry::interface_offset_in_bytes()) -
2815                                      itable_offset_search_inc;
2816 
2817     // Compute itableMethodEntry and get method and entry point
2818     // we use addressing with index and displacement, since the formula
2819     // for computing the entry&#39;s offset has a fixed and a dynamic part,
2820     // the latter depending on the matched interface entry and on the case,
2821     // that the itable index has been passed as a register, not a constant value.
2822     int method_offset = itableMethodEntry::method_offset_in_bytes();
2823                              // Fixed part (displacement), common operand.
2824     Register itable_offset = method_result;  // Dynamic part (index register).
2825 
2826     if (itable_index.is_register()) {
2827        // Compute the method&#39;s offset in that register, for the formula, see the
2828        // else-clause below.
2829        z_sllg(itable_offset, itable_index.as_register(), exact_log2(itableMethodEntry::size() * wordSize));
2830        z_agf(itable_offset, vtable_offset_offset, itable_entry_addr);
2831     } else {
2832       // Displacement increases.
2833       method_offset += itableMethodEntry::size() * wordSize * itable_index.as_constant();
2834 
2835       // Load index from itable.
2836       z_llgf(itable_offset, vtable_offset_offset, itable_entry_addr);
2837     }
2838 
2839     // Finally load the method&#39;s oop.
2840     z_lg(method_result, method_offset, itable_offset, recv_klass);
2841   }
2842   BLOCK_COMMENT(&quot;} lookup_interface_method&quot;);
2843 }
2844 
2845 // Lookup for virtual method invocation.
2846 void MacroAssembler::lookup_virtual_method(Register           recv_klass,
2847                                            RegisterOrConstant vtable_index,
2848                                            Register           method_result) {
2849   assert_different_registers(recv_klass, vtable_index.register_or_noreg());
2850   assert(vtableEntry::size() * wordSize == wordSize,
2851          &quot;else adjust the scaling in the code below&quot;);
2852 
2853   BLOCK_COMMENT(&quot;lookup_virtual_method {&quot;);
2854 
2855   const int base = in_bytes(Klass::vtable_start_offset());
2856 
2857   if (vtable_index.is_constant()) {
2858     // Load with base + disp.
2859     Address vtable_entry_addr(recv_klass,
2860                               vtable_index.as_constant() * wordSize +
2861                               base +
2862                               vtableEntry::method_offset_in_bytes());
2863 
2864     z_lg(method_result, vtable_entry_addr);
2865   } else {
2866     // Shift index properly and load with base + index + disp.
2867     Register vindex = vtable_index.as_register();
2868     Address  vtable_entry_addr(recv_klass, vindex,
2869                                base + vtableEntry::method_offset_in_bytes());
2870 
2871     z_sllg(vindex, vindex, exact_log2(wordSize));
2872     z_lg(method_result, vtable_entry_addr);
2873   }
2874   BLOCK_COMMENT(&quot;} lookup_virtual_method&quot;);
2875 }
2876 
2877 // Factor out code to call ic_miss_handler.
2878 // Generate code to call the inline cache miss handler.
2879 //
2880 // In most cases, this code will be generated out-of-line.
2881 // The method parameters are intended to provide some variability.
2882 //   ICM          - Label which has to be bound to the start of useful code (past any traps).
2883 //   trapMarker   - Marking byte for the generated illtrap instructions (if any).
2884 //                  Any value except 0x00 is supported.
2885 //                  = 0x00 - do not generate illtrap instructions.
2886 //                         use nops to fill ununsed space.
2887 //   requiredSize - required size of the generated code. If the actually
2888 //                  generated code is smaller, use padding instructions to fill up.
2889 //                  = 0 - no size requirement, no padding.
2890 //   scratch      - scratch register to hold branch target address.
2891 //
2892 //  The method returns the code offset of the bound label.
2893 unsigned int MacroAssembler::call_ic_miss_handler(Label&amp; ICM, int trapMarker, int requiredSize, Register scratch) {
2894   intptr_t startOffset = offset();
2895 
2896   // Prevent entry at content_begin().
2897   if (trapMarker != 0) {
2898     z_illtrap(trapMarker);
2899   }
2900 
2901   // Load address of inline cache miss code into scratch register
2902   // and branch to cache miss handler.
2903   BLOCK_COMMENT(&quot;IC miss handler {&quot;);
2904   BIND(ICM);
2905   unsigned int   labelOffset = offset();
2906   AddressLiteral icmiss(SharedRuntime::get_ic_miss_stub());
2907 
2908   load_const_optimized(scratch, icmiss);
2909   z_br(scratch);
2910 
2911   // Fill unused space.
2912   if (requiredSize &gt; 0) {
2913     while ((offset() - startOffset) &lt; requiredSize) {
2914       if (trapMarker == 0) {
2915         z_nop();
2916       } else {
2917         z_illtrap(trapMarker);
2918       }
2919     }
2920   }
2921   BLOCK_COMMENT(&quot;} IC miss handler&quot;);
2922   return labelOffset;
2923 }
2924 
2925 void MacroAssembler::nmethod_UEP(Label&amp; ic_miss) {
2926   Register ic_reg       = Z_inline_cache;
2927   int      klass_offset = oopDesc::klass_offset_in_bytes();
2928   if (!ImplicitNullChecks || MacroAssembler::needs_explicit_null_check(klass_offset)) {
2929     if (VM_Version::has_CompareBranch()) {
2930       z_cgij(Z_ARG1, 0, Assembler::bcondEqual, ic_miss);
2931     } else {
2932       z_ltgr(Z_ARG1, Z_ARG1);
2933       z_bre(ic_miss);
2934     }
2935   }
2936   // Compare cached class against klass from receiver.
2937   compare_klass_ptr(ic_reg, klass_offset, Z_ARG1, false);
2938   z_brne(ic_miss);
2939 }
2940 
2941 void MacroAssembler::check_klass_subtype_fast_path(Register   sub_klass,
2942                                                    Register   super_klass,
2943                                                    Register   temp1_reg,
2944                                                    Label*     L_success,
2945                                                    Label*     L_failure,
2946                                                    Label*     L_slow_path,
2947                                                    RegisterOrConstant super_check_offset) {
2948 
2949   const int sc_offset  = in_bytes(Klass::secondary_super_cache_offset());
2950   const int sco_offset = in_bytes(Klass::super_check_offset_offset());
2951 
2952   bool must_load_sco = (super_check_offset.constant_or_zero() == -1);
2953   bool need_slow_path = (must_load_sco ||
2954                          super_check_offset.constant_or_zero() == sc_offset);
2955 
2956   // Input registers must not overlap.
2957   assert_different_registers(sub_klass, super_klass, temp1_reg);
2958   if (super_check_offset.is_register()) {
2959     assert_different_registers(sub_klass, super_klass,
2960                                super_check_offset.as_register());
2961   } else if (must_load_sco) {
2962     assert(temp1_reg != noreg, &quot;supply either a temp or a register offset&quot;);
2963   }
2964 
2965   const Register Rsuper_check_offset = temp1_reg;
2966 
2967   NearLabel L_fallthrough;
2968   int label_nulls = 0;
2969   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
2970   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
2971   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
2972   assert(label_nulls &lt;= 1 ||
2973          (L_slow_path == &amp;L_fallthrough &amp;&amp; label_nulls &lt;= 2 &amp;&amp; !need_slow_path),
2974          &quot;at most one NULL in the batch, usually&quot;);
2975 
2976   BLOCK_COMMENT(&quot;check_klass_subtype_fast_path {&quot;);
2977   // If the pointers are equal, we are done (e.g., String[] elements).
2978   // This self-check enables sharing of secondary supertype arrays among
2979   // non-primary types such as array-of-interface. Otherwise, each such
2980   // type would need its own customized SSA.
2981   // We move this check to the front of the fast path because many
2982   // type checks are in fact trivially successful in this manner,
2983   // so we get a nicely predicted branch right at the start of the check.
2984   compare64_and_branch(sub_klass, super_klass, bcondEqual, *L_success);
2985 
2986   // Check the supertype display, which is uint.
2987   if (must_load_sco) {
2988     z_llgf(Rsuper_check_offset, sco_offset, super_klass);
2989     super_check_offset = RegisterOrConstant(Rsuper_check_offset);
2990   }
2991   Address super_check_addr(sub_klass, super_check_offset, 0);
2992   z_cg(super_klass, super_check_addr); // compare w/ displayed supertype
2993 
2994   // This check has worked decisively for primary supers.
2995   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
2996   // (Secondary supers are interfaces and very deeply nested subtypes.)
2997   // This works in the same check above because of a tricky aliasing
2998   // between the super_cache and the primary super display elements.
2999   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
3000   // Note that the cache is updated below if it does not help us find
3001   // what we need immediately.
3002   // So if it was a primary super, we can just fail immediately.
3003   // Otherwise, it&#39;s the slow path for us (no success at this point).
3004 
3005   // Hacked jmp, which may only be used just before L_fallthrough.
3006 #define final_jmp(label)                                                \
3007   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
3008   else                            { branch_optimized(Assembler::bcondAlways, label); } /*omit semicolon*/
3009 
3010   if (super_check_offset.is_register()) {
3011     branch_optimized(Assembler::bcondEqual, *L_success);
3012     z_cfi(super_check_offset.as_register(), sc_offset);
3013     if (L_failure == &amp;L_fallthrough) {
3014       branch_optimized(Assembler::bcondEqual, *L_slow_path);
3015     } else {
3016       branch_optimized(Assembler::bcondNotEqual, *L_failure);
3017       final_jmp(*L_slow_path);
3018     }
3019   } else if (super_check_offset.as_constant() == sc_offset) {
3020     // Need a slow path; fast failure is impossible.
3021     if (L_slow_path == &amp;L_fallthrough) {
3022       branch_optimized(Assembler::bcondEqual, *L_success);
3023     } else {
3024       branch_optimized(Assembler::bcondNotEqual, *L_slow_path);
3025       final_jmp(*L_success);
3026     }
3027   } else {
3028     // No slow path; it&#39;s a fast decision.
3029     if (L_failure == &amp;L_fallthrough) {
3030       branch_optimized(Assembler::bcondEqual, *L_success);
3031     } else {
3032       branch_optimized(Assembler::bcondNotEqual, *L_failure);
3033       final_jmp(*L_success);
3034     }
3035   }
3036 
3037   bind(L_fallthrough);
3038 #undef local_brc
3039 #undef final_jmp
3040   BLOCK_COMMENT(&quot;} check_klass_subtype_fast_path&quot;);
3041   // fallthru (to slow path)
3042 }
3043 
3044 void MacroAssembler::check_klass_subtype_slow_path(Register Rsubklass,
3045                                                    Register Rsuperklass,
3046                                                    Register Rarray_ptr,  // tmp
3047                                                    Register Rlength,     // tmp
3048                                                    Label* L_success,
3049                                                    Label* L_failure) {
3050   // Input registers must not overlap.
3051   // Also check for R1 which is explicitely used here.
3052   assert_different_registers(Z_R1, Rsubklass, Rsuperklass, Rarray_ptr, Rlength);
3053   NearLabel L_fallthrough;
3054   int label_nulls = 0;
3055   if (L_success == NULL) { L_success = &amp;L_fallthrough; label_nulls++; }
3056   if (L_failure == NULL) { L_failure = &amp;L_fallthrough; label_nulls++; }
3057   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
3058 
3059   const int ss_offset = in_bytes(Klass::secondary_supers_offset());
3060   const int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
3061 
3062   const int length_offset = Array&lt;Klass*&gt;::length_offset_in_bytes();
3063   const int base_offset   = Array&lt;Klass*&gt;::base_offset_in_bytes();
3064 
3065   // Hacked jmp, which may only be used just before L_fallthrough.
3066 #define final_jmp(label)                                                \
3067   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
3068   else                            branch_optimized(Assembler::bcondAlways, label) /*omit semicolon*/
3069 
3070   NearLabel loop_iterate, loop_count, match;
3071 
3072   BLOCK_COMMENT(&quot;check_klass_subtype_slow_path {&quot;);
3073   z_lg(Rarray_ptr, ss_offset, Rsubklass);
3074 
3075   load_and_test_int(Rlength, Address(Rarray_ptr, length_offset));
3076   branch_optimized(Assembler::bcondZero, *L_failure);
3077 
3078   // Oops in table are NO MORE compressed.
3079   z_cg(Rsuperklass, base_offset, Rarray_ptr); // Check array element for match.
3080   z_bre(match);                               // Shortcut for array length = 1.
3081 
3082   // No match yet, so we must walk the array&#39;s elements.
3083   z_lngfr(Rlength, Rlength);
3084   z_sllg(Rlength, Rlength, LogBytesPerWord); // -#bytes of cache array
3085   z_llill(Z_R1, BytesPerWord);               // Set increment/end index.
3086   add2reg(Rlength, 2 * BytesPerWord);        // start index  = -(n-2)*BytesPerWord
3087   z_slgr(Rarray_ptr, Rlength);               // start addr: +=  (n-2)*BytesPerWord
3088   z_bru(loop_count);
3089 
3090   BIND(loop_iterate);
3091   z_cg(Rsuperklass, base_offset, Rlength, Rarray_ptr); // Check array element for match.
3092   z_bre(match);
3093   BIND(loop_count);
3094   z_brxlg(Rlength, Z_R1, loop_iterate);
3095 
3096   // Rsuperklass not found among secondary super classes -&gt; failure.
3097   branch_optimized(Assembler::bcondAlways, *L_failure);
3098 
3099   // Got a hit. Return success (zero result). Set cache.
3100   // Cache load doesn&#39;t happen here. For speed it is directly emitted by the compiler.
3101 
3102   BIND(match);
3103 
3104   z_stg(Rsuperklass, sc_offset, Rsubklass); // Save result to cache.
3105 
3106   final_jmp(*L_success);
3107 
3108   // Exit to the surrounding code.
3109   BIND(L_fallthrough);
3110 #undef local_brc
3111 #undef final_jmp
3112   BLOCK_COMMENT(&quot;} check_klass_subtype_slow_path&quot;);
3113 }
3114 
3115 // Emitter for combining fast and slow path.
3116 void MacroAssembler::check_klass_subtype(Register sub_klass,
3117                                          Register super_klass,
3118                                          Register temp1_reg,
3119                                          Register temp2_reg,
3120                                          Label&amp;   L_success) {
3121   NearLabel failure;
3122   BLOCK_COMMENT(err_msg(&quot;check_klass_subtype(%s subclass of %s) {&quot;, sub_klass-&gt;name(), super_klass-&gt;name()));
3123   check_klass_subtype_fast_path(sub_klass, super_klass, temp1_reg,
3124                                 &amp;L_success, &amp;failure, NULL);
3125   check_klass_subtype_slow_path(sub_klass, super_klass,
3126                                 temp1_reg, temp2_reg, &amp;L_success, NULL);
3127   BIND(failure);
3128   BLOCK_COMMENT(&quot;} check_klass_subtype&quot;);
3129 }
3130 
3131 void MacroAssembler::clinit_barrier(Register klass, Register thread, Label* L_fast_path, Label* L_slow_path) {
3132   assert(L_fast_path != NULL || L_slow_path != NULL, &quot;at least one is required&quot;);
3133 
3134   Label L_fallthrough;
3135   if (L_fast_path == NULL) {
3136     L_fast_path = &amp;L_fallthrough;
3137   } else if (L_slow_path == NULL) {
3138     L_slow_path = &amp;L_fallthrough;
3139   }
3140 
3141   // Fast path check: class is fully initialized
3142   z_cli(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
3143   z_bre(*L_fast_path);
3144 
3145   // Fast path check: current thread is initializer thread
3146   z_cg(thread, Address(klass, InstanceKlass::init_thread_offset()));
3147   if (L_slow_path == &amp;L_fallthrough) {
3148     z_bre(*L_fast_path);
3149   } else if (L_fast_path == &amp;L_fallthrough) {
3150     z_brne(*L_slow_path);
3151   } else {
3152     Unimplemented();
3153   }
3154 
3155   bind(L_fallthrough);
3156 }
3157 
3158 // Increment a counter at counter_address when the eq condition code is
3159 // set. Kills registers tmp1_reg and tmp2_reg and preserves the condition code.
3160 void MacroAssembler::increment_counter_eq(address counter_address, Register tmp1_reg, Register tmp2_reg) {
3161   Label l;
3162   z_brne(l);
3163   load_const(tmp1_reg, counter_address);
3164   add2mem_32(Address(tmp1_reg), 1, tmp2_reg);
3165   z_cr(tmp1_reg, tmp1_reg); // Set cc to eq.
3166   bind(l);
3167 }
3168 
3169 // Semantics are dependent on the slow_case label:
3170 //   If the slow_case label is not NULL, failure to biased-lock the object
3171 //   transfers control to the location of the slow_case label. If the
3172 //   object could be biased-locked, control is transferred to the done label.
3173 //   The condition code is unpredictable.
3174 //
3175 //   If the slow_case label is NULL, failure to biased-lock the object results
3176 //   in a transfer of control to the done label with a condition code of not_equal.
3177 //   If the biased-lock could be successfully obtained, control is transfered to
3178 //   the done label with a condition code of equal.
3179 //   It is mandatory to react on the condition code At the done label.
3180 //
3181 void MacroAssembler::biased_locking_enter(Register  obj_reg,
3182                                           Register  mark_reg,
3183                                           Register  temp_reg,
3184                                           Register  temp2_reg,    // May be Z_RO!
3185                                           Label    &amp;done,
3186                                           Label    *slow_case) {
3187   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
3188   assert_different_registers(obj_reg, mark_reg, temp_reg, temp2_reg);
3189 
3190   Label cas_label; // Try, if implemented, CAS locking. Fall thru to slow path otherwise.
3191 
3192   BLOCK_COMMENT(&quot;biased_locking_enter {&quot;);
3193 
3194   // Biased locking
3195   // See whether the lock is currently biased toward our thread and
3196   // whether the epoch is still valid.
3197   // Note that the runtime guarantees sufficient alignment of JavaThread
3198   // pointers to allow age to be placed into low bits.
3199   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits,
3200          &quot;biased locking makes assumptions about bit layout&quot;);
3201   z_lr(temp_reg, mark_reg);
3202   z_nilf(temp_reg, markWord::biased_lock_mask_in_place);
3203   z_chi(temp_reg, markWord::biased_lock_pattern);
3204   z_brne(cas_label);  // Try cas if object is not biased, i.e. cannot be biased locked.
3205 
3206   load_prototype_header(temp_reg, obj_reg);
3207   load_const_optimized(temp2_reg, ~((int) markWord::age_mask_in_place));
3208 
3209   z_ogr(temp_reg, Z_thread);
3210   z_xgr(temp_reg, mark_reg);
3211   z_ngr(temp_reg, temp2_reg);
3212   if (PrintBiasedLockingStatistics) {
3213     increment_counter_eq((address) BiasedLocking::biased_lock_entry_count_addr(), mark_reg, temp2_reg);
3214     // Restore mark_reg.
3215     z_lg(mark_reg, oopDesc::mark_offset_in_bytes(), obj_reg);
3216   }
3217   branch_optimized(Assembler::bcondEqual, done);  // Biased lock obtained, return success.
3218 
3219   Label try_revoke_bias;
3220   Label try_rebias;
3221   Address mark_addr = Address(obj_reg, oopDesc::mark_offset_in_bytes());
3222 
3223   //----------------------------------------------------------------------------
3224   // At this point we know that the header has the bias pattern and
3225   // that we are not the bias owner in the current epoch. We need to
3226   // figure out more details about the state of the header in order to
3227   // know what operations can be legally performed on the object&#39;s
3228   // header.
3229 
3230   // If the low three bits in the xor result aren&#39;t clear, that means
3231   // the prototype header is no longer biased and we have to revoke
3232   // the bias on this object.
3233   z_tmll(temp_reg, markWord::biased_lock_mask_in_place);
3234   z_brnaz(try_revoke_bias);
3235 
3236   // Biasing is still enabled for this data type. See whether the
3237   // epoch of the current bias is still valid, meaning that the epoch
3238   // bits of the mark word are equal to the epoch bits of the
3239   // prototype header. (Note that the prototype header&#39;s epoch bits
3240   // only change at a safepoint.) If not, attempt to rebias the object
3241   // toward the current thread. Note that we must be absolutely sure
3242   // that the current epoch is invalid in order to do this because
3243   // otherwise the manipulations it performs on the mark word are
3244   // illegal.
3245   z_tmll(temp_reg, markWord::epoch_mask_in_place);
3246   z_brnaz(try_rebias);
3247 
3248   //----------------------------------------------------------------------------
3249   // The epoch of the current bias is still valid but we know nothing
3250   // about the owner; it might be set or it might be clear. Try to
3251   // acquire the bias of the object using an atomic operation. If this
3252   // fails we will go in to the runtime to revoke the object&#39;s bias.
3253   // Note that we first construct the presumed unbiased header so we
3254   // don&#39;t accidentally blow away another thread&#39;s valid bias.
3255   z_nilf(mark_reg, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place |
3256          markWord::epoch_mask_in_place);
3257   z_lgr(temp_reg, Z_thread);
3258   z_llgfr(mark_reg, mark_reg);
3259   z_ogr(temp_reg, mark_reg);
3260 
3261   assert(oopDesc::mark_offset_in_bytes() == 0, &quot;offset of _mark is not 0&quot;);
3262 
3263   z_csg(mark_reg, temp_reg, 0, obj_reg);
3264 
3265   // If the biasing toward our thread failed, this means that
3266   // another thread succeeded in biasing it toward itself and we
3267   // need to revoke that bias. The revocation will occur in the
3268   // interpreter runtime in the slow case.
3269 
3270   if (PrintBiasedLockingStatistics) {
3271     increment_counter_eq((address) BiasedLocking::anonymously_biased_lock_entry_count_addr(),
3272                          temp_reg, temp2_reg);
3273   }
3274   if (slow_case != NULL) {
3275     branch_optimized(Assembler::bcondNotEqual, *slow_case); // Biased lock not obtained, need to go the long way.
3276   }
3277   branch_optimized(Assembler::bcondAlways, done);           // Biased lock status given in condition code.
3278 
3279   //----------------------------------------------------------------------------
3280   bind(try_rebias);
3281   // At this point we know the epoch has expired, meaning that the
3282   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
3283   // circumstances _only_, we are allowed to use the current header&#39;s
3284   // value as the comparison value when doing the cas to acquire the
3285   // bias in the current epoch. In other words, we allow transfer of
3286   // the bias from one thread to another directly in this situation.
3287 
3288   z_nilf(mark_reg, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);
3289   load_prototype_header(temp_reg, obj_reg);
3290   z_llgfr(mark_reg, mark_reg);
3291 
3292   z_ogr(temp_reg, Z_thread);
3293 
3294   assert(oopDesc::mark_offset_in_bytes() == 0, &quot;offset of _mark is not 0&quot;);
3295 
3296   z_csg(mark_reg, temp_reg, 0, obj_reg);
3297 
3298   // If the biasing toward our thread failed, this means that
3299   // another thread succeeded in biasing it toward itself and we
3300   // need to revoke that bias. The revocation will occur in the
3301   // interpreter runtime in the slow case.
3302 
3303   if (PrintBiasedLockingStatistics) {
3304     increment_counter_eq((address) BiasedLocking::rebiased_lock_entry_count_addr(), temp_reg, temp2_reg);
3305   }
3306   if (slow_case != NULL) {
3307     branch_optimized(Assembler::bcondNotEqual, *slow_case);  // Biased lock not obtained, need to go the long way.
3308   }
3309   z_bru(done);           // Biased lock status given in condition code.
3310 
3311   //----------------------------------------------------------------------------
3312   bind(try_revoke_bias);
3313   // The prototype mark in the klass doesn&#39;t have the bias bit set any
3314   // more, indicating that objects of this data type are not supposed
3315   // to be biased any more. We are going to try to reset the mark of
3316   // this object to the prototype value and fall through to the
3317   // CAS-based locking scheme. Note that if our CAS fails, it means
3318   // that another thread raced us for the privilege of revoking the
3319   // bias of this particular object, so it&#39;s okay to continue in the
3320   // normal locking code.
3321   load_prototype_header(temp_reg, obj_reg);
3322 
3323   assert(oopDesc::mark_offset_in_bytes() == 0, &quot;offset of _mark is not 0&quot;);
3324 
3325   z_csg(mark_reg, temp_reg, 0, obj_reg);
3326 
3327   // Fall through to the normal CAS-based lock, because no matter what
3328   // the result of the above CAS, some thread must have succeeded in
3329   // removing the bias bit from the object&#39;s header.
3330   if (PrintBiasedLockingStatistics) {
3331     // z_cgr(mark_reg, temp2_reg);
3332     increment_counter_eq((address) BiasedLocking::revoked_lock_entry_count_addr(), temp_reg, temp2_reg);
3333   }
3334 
3335   bind(cas_label);
3336   BLOCK_COMMENT(&quot;} biased_locking_enter&quot;);
3337 }
3338 
3339 void MacroAssembler::biased_locking_exit(Register mark_addr, Register temp_reg, Label&amp; done) {
3340   // Check for biased locking unlock case, which is a no-op
3341   // Note: we do not have to check the thread ID for two reasons.
3342   // First, the interpreter checks for IllegalMonitorStateException at
3343   // a higher level. Second, if the bias was revoked while we held the
3344   // lock, the object could not be rebiased toward another thread, so
3345   // the bias bit would be clear.
3346   BLOCK_COMMENT(&quot;biased_locking_exit {&quot;);
3347 
3348   z_lg(temp_reg, 0, mark_addr);
3349   z_nilf(temp_reg, markWord::biased_lock_mask_in_place);
3350 
3351   z_chi(temp_reg, markWord::biased_lock_pattern);
3352   z_bre(done);
3353   BLOCK_COMMENT(&quot;} biased_locking_exit&quot;);
3354 }
3355 
3356 void MacroAssembler::compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias) {
3357   Register displacedHeader = temp1;
3358   Register currentHeader = temp1;
3359   Register temp = temp2;
3360   NearLabel done, object_has_monitor;
3361 
3362   BLOCK_COMMENT(&quot;compiler_fast_lock_object {&quot;);
3363 
3364   // Load markWord from oop into mark.
3365   z_lg(displacedHeader, 0, oop);
3366 
3367   if (try_bias) {
3368     biased_locking_enter(oop, displacedHeader, temp, Z_R0, done);
3369   }
3370 
3371   // Handle existing monitor.
3372   // The object has an existing monitor iff (mark &amp; monitor_value) != 0.
3373   guarantee(Immediate::is_uimm16(markWord::monitor_value), &quot;must be half-word&quot;);
3374   z_lr(temp, displacedHeader);
3375   z_nill(temp, markWord::monitor_value);
3376   z_brne(object_has_monitor);
3377 
3378   // Set mark to markWord | markWord::unlocked_value.
3379   z_oill(displacedHeader, markWord::unlocked_value);
3380 
3381   // Load Compare Value application register.
3382 
3383   // Initialize the box (must happen before we update the object mark).
3384   z_stg(displacedHeader, BasicLock::displaced_header_offset_in_bytes(), box);
3385 
3386   // Memory Fence (in cmpxchgd)
3387   // Compare object markWord with mark and if equal exchange scratch1 with object markWord.
3388 
3389   // If the compare-and-swap succeeded, then we found an unlocked object and we
3390   // have now locked it.
3391   z_csg(displacedHeader, box, 0, oop);
3392   assert(currentHeader==displacedHeader, &quot;must be same register&quot;); // Identified two registers from z/Architecture.
3393   z_bre(done);
3394 
3395   // We did not see an unlocked object so try the fast recursive case.
3396 
3397   z_sgr(currentHeader, Z_SP);
3398   load_const_optimized(temp, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));
3399 
3400   z_ngr(currentHeader, temp);
3401   //   z_brne(done);
3402   //   z_release();
3403   z_stg(currentHeader/*==0 or not 0*/, BasicLock::displaced_header_offset_in_bytes(), box);
3404 
3405   z_bru(done);
3406 
3407   Register zero = temp;
3408   Register monitor_tagged = displacedHeader; // Tagged with markWord::monitor_value.
3409   bind(object_has_monitor);
3410   // The object&#39;s monitor m is unlocked iff m-&gt;owner == NULL,
3411   // otherwise m-&gt;owner may contain a thread or a stack address.
3412   //
3413   // Try to CAS m-&gt;owner from NULL to current thread.
3414   z_lghi(zero, 0);
3415   // If m-&gt;owner is null, then csg succeeds and sets m-&gt;owner=THREAD and CR=EQ.
3416   z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor_tagged);
3417   // Store a non-null value into the box.
3418   z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);
3419 #ifdef ASSERT
3420   z_brne(done);
3421   // We&#39;ve acquired the monitor, check some invariants.
3422   // Invariant 1: _recursions should be 0.
3423   asm_assert_mem8_is_zero(OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions), monitor_tagged,
3424                           &quot;monitor-&gt;_recursions should be 0&quot;, -1);
3425   z_ltgr(zero, zero); // Set CR=EQ.
3426 #endif
3427   bind(done);
3428 
3429   BLOCK_COMMENT(&quot;} compiler_fast_lock_object&quot;);
3430   // If locking was successful, CR should indicate &#39;EQ&#39;.
3431   // The compiler or the native wrapper generates a branch to the runtime call
3432   // _complete_monitor_locking_Java.
3433 }
3434 
3435 void MacroAssembler::compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias) {
3436   Register displacedHeader = temp1;
3437   Register currentHeader = temp2;
3438   Register temp = temp1;
3439   Register monitor = temp2;
3440 
3441   Label done, object_has_monitor;
3442 
3443   BLOCK_COMMENT(&quot;compiler_fast_unlock_object {&quot;);
3444 
3445   if (try_bias) {
3446     biased_locking_exit(oop, currentHeader, done);
3447   }
3448 
3449   // Find the lock address and load the displaced header from the stack.
3450   // if the displaced header is zero, we have a recursive unlock.
3451   load_and_test_long(displacedHeader, Address(box, BasicLock::displaced_header_offset_in_bytes()));
3452   z_bre(done);
3453 
3454   // Handle existing monitor.
3455   // The object has an existing monitor iff (mark &amp; monitor_value) != 0.
3456   z_lg(currentHeader, oopDesc::mark_offset_in_bytes(), oop);
3457   guarantee(Immediate::is_uimm16(markWord::monitor_value), &quot;must be half-word&quot;);
3458   z_nill(currentHeader, markWord::monitor_value);
3459   z_brne(object_has_monitor);
3460 
3461   // Check if it is still a light weight lock, this is true if we see
3462   // the stack address of the basicLock in the markWord of the object
3463   // copy box to currentHeader such that csg does not kill it.
3464   z_lgr(currentHeader, box);
3465   z_csg(currentHeader, displacedHeader, 0, oop);
3466   z_bru(done); // Csg sets CR as desired.
3467 
3468   // Handle existing monitor.
3469   bind(object_has_monitor);
3470   z_lg(currentHeader, oopDesc::mark_offset_in_bytes(), oop);    // CurrentHeader is tagged with monitor_value set.
3471   load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));
3472   z_brne(done);
3473   load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));
3474   z_brne(done);
3475   load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));
3476   z_brne(done);
3477   load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));
3478   z_brne(done);
3479   z_release();
3480   z_stg(temp/*=0*/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), currentHeader);
3481 
3482   bind(done);
3483 
3484   BLOCK_COMMENT(&quot;} compiler_fast_unlock_object&quot;);
3485   // flag == EQ indicates success
3486   // flag == NE indicates failure
3487 }
3488 
3489 void MacroAssembler::resolve_jobject(Register value, Register tmp1, Register tmp2) {
3490   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3491   bs-&gt;resolve_jobject(this, value, tmp1, tmp2);
3492 }
3493 
3494 // Last_Java_sp must comply to the rules in frame_s390.hpp.
3495 void MacroAssembler::set_last_Java_frame(Register last_Java_sp, Register last_Java_pc, bool allow_relocation) {
3496   BLOCK_COMMENT(&quot;set_last_Java_frame {&quot;);
3497 
3498   // Always set last_Java_pc and flags first because once last_Java_sp
3499   // is visible has_last_Java_frame is true and users will look at the
3500   // rest of the fields. (Note: flags should always be zero before we
3501   // get here so doesn&#39;t need to be set.)
3502 
3503   // Verify that last_Java_pc was zeroed on return to Java.
3504   if (allow_relocation) {
3505     asm_assert_mem8_is_zero(in_bytes(JavaThread::last_Java_pc_offset()),
3506                             Z_thread,
3507                             &quot;last_Java_pc not zeroed before leaving Java&quot;,
3508                             0x200);
3509   } else {
3510     asm_assert_mem8_is_zero_static(in_bytes(JavaThread::last_Java_pc_offset()),
3511                                    Z_thread,
3512                                    &quot;last_Java_pc not zeroed before leaving Java&quot;,
3513                                    0x200);
3514   }
3515 
3516   // When returning from calling out from Java mode the frame anchor&#39;s
3517   // last_Java_pc will always be set to NULL. It is set here so that
3518   // if we are doing a call to native (not VM) that we capture the
3519   // known pc and don&#39;t have to rely on the native call having a
3520   // standard frame linkage where we can find the pc.
3521   if (last_Java_pc!=noreg) {
3522     z_stg(last_Java_pc, Address(Z_thread, JavaThread::last_Java_pc_offset()));
3523   }
3524 
3525   // This membar release is not required on z/Architecture, since the sequence of stores
3526   // in maintained. Nevertheless, we leave it in to document the required ordering.
3527   // The implementation of z_release() should be empty.
3528   // z_release();
3529 
3530   z_stg(last_Java_sp, Address(Z_thread, JavaThread::last_Java_sp_offset()));
3531   BLOCK_COMMENT(&quot;} set_last_Java_frame&quot;);
3532 }
3533 
3534 void MacroAssembler::reset_last_Java_frame(bool allow_relocation) {
3535   BLOCK_COMMENT(&quot;reset_last_Java_frame {&quot;);
3536 
3537   if (allow_relocation) {
3538     asm_assert_mem8_isnot_zero(in_bytes(JavaThread::last_Java_sp_offset()),
3539                                Z_thread,
3540                                &quot;SP was not set, still zero&quot;,
3541                                0x202);
3542   } else {
3543     asm_assert_mem8_isnot_zero_static(in_bytes(JavaThread::last_Java_sp_offset()),
3544                                       Z_thread,
3545                                       &quot;SP was not set, still zero&quot;,
3546                                       0x202);
3547   }
3548 
3549   // _last_Java_sp = 0
3550   // Clearing storage must be atomic here, so don&#39;t use clear_mem()!
3551   store_const(Address(Z_thread, JavaThread::last_Java_sp_offset()), 0);
3552 
3553   // _last_Java_pc = 0
3554   store_const(Address(Z_thread, JavaThread::last_Java_pc_offset()), 0);
3555 
3556   BLOCK_COMMENT(&quot;} reset_last_Java_frame&quot;);
3557   return;
3558 }
3559 
3560 void MacroAssembler::set_top_ijava_frame_at_SP_as_last_Java_frame(Register sp, Register tmp1, bool allow_relocation) {
3561   assert_different_registers(sp, tmp1);
3562 
3563   // We cannot trust that code generated by the C++ compiler saves R14
3564   // to z_abi_160.return_pc, because sometimes it spills R14 using stmg at
3565   // z_abi_160.gpr14 (e.g. InterpreterRuntime::_new()).
3566   // Therefore we load the PC into tmp1 and let set_last_Java_frame() save
3567   // it into the frame anchor.
3568   get_PC(tmp1);
3569   set_last_Java_frame(/*sp=*/sp, /*pc=*/tmp1, allow_relocation);
3570 }
3571 
3572 void MacroAssembler::set_thread_state(JavaThreadState new_state) {
3573   z_release();
3574 
3575   assert(Immediate::is_uimm16(_thread_max_state), &quot;enum value out of range for instruction&quot;);
3576   assert(sizeof(JavaThreadState) == sizeof(int), &quot;enum value must have base type int&quot;);
3577   store_const(Address(Z_thread, JavaThread::thread_state_offset()), new_state, Z_R0, false);
3578 }
3579 
3580 void MacroAssembler::get_vm_result(Register oop_result) {
3581   verify_thread();
3582 
3583   z_lg(oop_result, Address(Z_thread, JavaThread::vm_result_offset()));
3584   clear_mem(Address(Z_thread, JavaThread::vm_result_offset()), sizeof(void*));
3585 
3586   verify_oop(oop_result, FILE_AND_LINE);
3587 }
3588 
3589 void MacroAssembler::get_vm_result_2(Register result) {
3590   verify_thread();
3591 
3592   z_lg(result, Address(Z_thread, JavaThread::vm_result_2_offset()));
3593   clear_mem(Address(Z_thread, JavaThread::vm_result_2_offset()), sizeof(void*));
3594 }
3595 
3596 // We require that C code which does not return a value in vm_result will
3597 // leave it undisturbed.
3598 void MacroAssembler::set_vm_result(Register oop_result) {
3599   z_stg(oop_result, Address(Z_thread, JavaThread::vm_result_offset()));
3600 }
3601 
3602 // Explicit null checks (used for method handle code).
3603 void MacroAssembler::null_check(Register reg, Register tmp, int64_t offset) {
3604   if (!ImplicitNullChecks) {
3605     NearLabel ok;
3606 
3607     compare64_and_branch(reg, (intptr_t) 0, Assembler::bcondNotEqual, ok);
3608 
3609     // We just put the address into reg if it was 0 (tmp==Z_R0 is allowed so we can&#39;t use it for the address).
3610     address exception_entry = Interpreter::throw_NullPointerException_entry();
3611     load_absolute_address(reg, exception_entry);
3612     z_br(reg);
3613 
3614     bind(ok);
3615   } else {
3616     if (needs_explicit_null_check((intptr_t)offset)) {
3617       // Provoke OS NULL exception if reg = NULL by
3618       // accessing M[reg] w/o changing any registers.
3619       z_lg(tmp, 0, reg);
3620     }
3621     // else
3622       // Nothing to do, (later) access of M[reg + offset]
3623       // will provoke OS NULL exception if reg = NULL.
3624   }
3625 }
3626 
3627 //-------------------------------------
3628 //  Compressed Klass Pointers
3629 //-------------------------------------
3630 
3631 // Klass oop manipulations if compressed.
3632 void MacroAssembler::encode_klass_not_null(Register dst, Register src) {
3633   Register current = (src != noreg) ? src : dst; // Klass is in dst if no src provided. (dst == src) also possible.
3634   address  base    = CompressedKlassPointers::base();
3635   int      shift   = CompressedKlassPointers::shift();
3636   assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
3637 
3638   BLOCK_COMMENT(&quot;cKlass encoder {&quot;);
3639 
3640 #ifdef ASSERT
3641   Label ok;
3642   z_tmll(current, KlassAlignmentInBytes-1); // Check alignment.
3643   z_brc(Assembler::bcondAllZero, ok);
3644   // The plain disassembler does not recognize illtrap. It instead displays
3645   // a 32-bit value. Issueing two illtraps assures the disassembler finds
3646   // the proper beginning of the next instruction.
3647   z_illtrap(0xee);
3648   z_illtrap(0xee);
3649   bind(ok);
3650 #endif
3651 
3652   if (base != NULL) {
3653     unsigned int base_h = ((unsigned long)base)&gt;&gt;32;
3654     unsigned int base_l = (unsigned int)((unsigned long)base);
3655     if ((base_h != 0) &amp;&amp; (base_l == 0) &amp;&amp; VM_Version::has_HighWordInstr()) {
3656       lgr_if_needed(dst, current);
3657       z_aih(dst, -((int)base_h));     // Base has no set bits in lower half.
3658     } else if ((base_h == 0) &amp;&amp; (base_l != 0)) {
3659       lgr_if_needed(dst, current);
3660       z_agfi(dst, -(int)base_l);
3661     } else {
3662       load_const(Z_R0, base);
3663       lgr_if_needed(dst, current);
3664       z_sgr(dst, Z_R0);
3665     }
3666     current = dst;
3667   }
3668   if (shift != 0) {
3669     assert (LogKlassAlignmentInBytes == shift, &quot;decode alg wrong&quot;);
3670     z_srlg(dst, current, shift);
3671     current = dst;
3672   }
3673   lgr_if_needed(dst, current); // Move may be required (if neither base nor shift != 0).
3674 
3675   BLOCK_COMMENT(&quot;} cKlass encoder&quot;);
3676 }
3677 
3678 // This function calculates the size of the code generated by
3679 //   decode_klass_not_null(register dst, Register src)
3680 // when (Universe::heap() != NULL). Hence, if the instructions
3681 // it generates change, then this method needs to be updated.
3682 int MacroAssembler::instr_size_for_decode_klass_not_null() {
3683   address  base    = CompressedKlassPointers::base();
3684   int shift_size   = CompressedKlassPointers::shift() == 0 ? 0 : 6; /* sllg */
3685   int addbase_size = 0;
3686   assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
3687 
3688   if (base != NULL) {
3689     unsigned int base_h = ((unsigned long)base)&gt;&gt;32;
3690     unsigned int base_l = (unsigned int)((unsigned long)base);
3691     if ((base_h != 0) &amp;&amp; (base_l == 0) &amp;&amp; VM_Version::has_HighWordInstr()) {
3692       addbase_size += 6; /* aih */
3693     } else if ((base_h == 0) &amp;&amp; (base_l != 0)) {
3694       addbase_size += 6; /* algfi */
3695     } else {
3696       addbase_size += load_const_size();
3697       addbase_size += 4; /* algr */
3698     }
3699   }
3700 #ifdef ASSERT
3701   addbase_size += 10;
3702   addbase_size += 2; // Extra sigill.
3703 #endif
3704   return addbase_size + shift_size;
3705 }
3706 
3707 // !!! If the instructions that get generated here change
3708 //     then function instr_size_for_decode_klass_not_null()
3709 //     needs to get updated.
3710 // This variant of decode_klass_not_null() must generate predictable code!
3711 // The code must only depend on globally known parameters.
3712 void MacroAssembler::decode_klass_not_null(Register dst) {
3713   address  base    = CompressedKlassPointers::base();
3714   int      shift   = CompressedKlassPointers::shift();
3715   int      beg_off = offset();
3716   assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
3717 
3718   BLOCK_COMMENT(&quot;cKlass decoder (const size) {&quot;);
3719 
3720   if (shift != 0) { // Shift required?
3721     z_sllg(dst, dst, shift);
3722   }
3723   if (base != NULL) {
3724     unsigned int base_h = ((unsigned long)base)&gt;&gt;32;
3725     unsigned int base_l = (unsigned int)((unsigned long)base);
3726     if ((base_h != 0) &amp;&amp; (base_l == 0) &amp;&amp; VM_Version::has_HighWordInstr()) {
3727       z_aih(dst, base_h);     // Base has no set bits in lower half.
3728     } else if ((base_h == 0) &amp;&amp; (base_l != 0)) {
3729       z_algfi(dst, base_l);   // Base has no set bits in upper half.
3730     } else {
3731       load_const(Z_R0, base); // Base has set bits everywhere.
3732       z_algr(dst, Z_R0);
3733     }
3734   }
3735 
3736 #ifdef ASSERT
3737   Label ok;
3738   z_tmll(dst, KlassAlignmentInBytes-1); // Check alignment.
3739   z_brc(Assembler::bcondAllZero, ok);
3740   // The plain disassembler does not recognize illtrap. It instead displays
3741   // a 32-bit value. Issueing two illtraps assures the disassembler finds
3742   // the proper beginning of the next instruction.
3743   z_illtrap(0xd1);
3744   z_illtrap(0xd1);
3745   bind(ok);
3746 #endif
3747   assert(offset() == beg_off + instr_size_for_decode_klass_not_null(), &quot;Code gen mismatch.&quot;);
3748 
3749   BLOCK_COMMENT(&quot;} cKlass decoder (const size)&quot;);
3750 }
3751 
3752 // This variant of decode_klass_not_null() is for cases where
3753 //  1) the size of the generated instructions may vary
3754 //  2) the result is (potentially) stored in a register different from the source.
3755 void MacroAssembler::decode_klass_not_null(Register dst, Register src) {
3756   address base  = CompressedKlassPointers::base();
3757   int     shift = CompressedKlassPointers::shift();
3758   assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
3759 
3760   BLOCK_COMMENT(&quot;cKlass decoder {&quot;);
3761 
3762   if (src == noreg) src = dst;
3763 
3764   if (shift != 0) { // Shift or at least move required?
3765     z_sllg(dst, src, shift);
3766   } else {
3767     lgr_if_needed(dst, src);
3768   }
3769 
3770   if (base != NULL) {
3771     unsigned int base_h = ((unsigned long)base)&gt;&gt;32;
3772     unsigned int base_l = (unsigned int)((unsigned long)base);
3773     if ((base_h != 0) &amp;&amp; (base_l == 0) &amp;&amp; VM_Version::has_HighWordInstr()) {
3774       z_aih(dst, base_h);     // Base has not set bits in lower half.
3775     } else if ((base_h == 0) &amp;&amp; (base_l != 0)) {
3776       z_algfi(dst, base_l);   // Base has no set bits in upper half.
3777     } else {
3778       load_const_optimized(Z_R0, base); // Base has set bits everywhere.
3779       z_algr(dst, Z_R0);
3780     }
3781   }
3782 
3783 #ifdef ASSERT
3784   Label ok;
3785   z_tmll(dst, KlassAlignmentInBytes-1); // Check alignment.
3786   z_brc(Assembler::bcondAllZero, ok);
3787   // The plain disassembler does not recognize illtrap. It instead displays
3788   // a 32-bit value. Issueing two illtraps assures the disassembler finds
3789   // the proper beginning of the next instruction.
3790   z_illtrap(0xd2);
3791   z_illtrap(0xd2);
3792   bind(ok);
3793 #endif
3794   BLOCK_COMMENT(&quot;} cKlass decoder&quot;);
3795 }
3796 
3797 void MacroAssembler::load_klass(Register klass, Address mem) {
3798   if (UseCompressedClassPointers) {
3799     z_llgf(klass, mem);
3800     // Attention: no null check here!
3801     decode_klass_not_null(klass);
3802   } else {
3803     z_lg(klass, mem);
3804   }
3805 }
3806 
3807 void MacroAssembler::load_klass(Register klass, Register src_oop) {
3808   if (UseCompressedClassPointers) {
3809     z_llgf(klass, oopDesc::klass_offset_in_bytes(), src_oop);
3810     // Attention: no null check here!
3811     decode_klass_not_null(klass);
3812   } else {
3813     z_lg(klass, oopDesc::klass_offset_in_bytes(), src_oop);
3814   }
3815 }
3816 
3817 void MacroAssembler::load_prototype_header(Register Rheader, Register Rsrc_oop) {
3818   assert_different_registers(Rheader, Rsrc_oop);
3819   load_klass(Rheader, Rsrc_oop);
3820   z_lg(Rheader, Address(Rheader, Klass::prototype_header_offset()));
3821 }
3822 
3823 void MacroAssembler::store_klass(Register klass, Register dst_oop, Register ck) {
3824   if (UseCompressedClassPointers) {
3825     assert_different_registers(dst_oop, klass, Z_R0);
3826     if (ck == noreg) ck = klass;
3827     encode_klass_not_null(ck, klass);
3828     z_st(ck, Address(dst_oop, oopDesc::klass_offset_in_bytes()));
3829   } else {
3830     z_stg(klass, Address(dst_oop, oopDesc::klass_offset_in_bytes()));
3831   }
3832 }
3833 
3834 void MacroAssembler::store_klass_gap(Register s, Register d) {
3835   if (UseCompressedClassPointers) {
3836     assert(s != d, &quot;not enough registers&quot;);
3837     // Support s = noreg.
3838     if (s != noreg) {
3839       z_st(s, Address(d, oopDesc::klass_gap_offset_in_bytes()));
3840     } else {
3841       z_mvhi(Address(d, oopDesc::klass_gap_offset_in_bytes()), 0);
3842     }
3843   }
3844 }
3845 
3846 // Compare klass ptr in memory against klass ptr in register.
3847 //
3848 // Rop1            - klass in register, always uncompressed.
3849 // disp            - Offset of klass in memory, compressed/uncompressed, depending on runtime flag.
3850 // Rbase           - Base address of cKlass in memory.
3851 // maybeNULL       - True if Rop1 possibly is a NULL.
3852 void MacroAssembler::compare_klass_ptr(Register Rop1, int64_t disp, Register Rbase, bool maybeNULL) {
3853 
3854   BLOCK_COMMENT(&quot;compare klass ptr {&quot;);
3855 
3856   if (UseCompressedClassPointers) {
3857     const int shift = CompressedKlassPointers::shift();
3858     address   base  = CompressedKlassPointers::base();
3859 
3860     assert((shift == 0) || (shift == LogKlassAlignmentInBytes), &quot;cKlass encoder detected bad shift&quot;);
3861     assert_different_registers(Rop1, Z_R0);
3862     assert_different_registers(Rop1, Rbase, Z_R1);
3863 
3864     // First encode register oop and then compare with cOop in memory.
3865     // This sequence saves an unnecessary cOop load and decode.
3866     if (base == NULL) {
3867       if (shift == 0) {
3868         z_cl(Rop1, disp, Rbase);     // Unscaled
3869       } else {
3870         z_srlg(Z_R0, Rop1, shift);   // ZeroBased
3871         z_cl(Z_R0, disp, Rbase);
3872       }
3873     } else {                         // HeapBased
3874 #ifdef ASSERT
3875       bool     used_R0 = true;
3876       bool     used_R1 = true;
3877 #endif
3878       Register current = Rop1;
3879       Label    done;
3880 
3881       if (maybeNULL) {       // NULL ptr must be preserved!
3882         z_ltgr(Z_R0, current);
3883         z_bre(done);
3884         current = Z_R0;
3885       }
3886 
3887       unsigned int base_h = ((unsigned long)base)&gt;&gt;32;
3888       unsigned int base_l = (unsigned int)((unsigned long)base);
3889       if ((base_h != 0) &amp;&amp; (base_l == 0) &amp;&amp; VM_Version::has_HighWordInstr()) {
3890         lgr_if_needed(Z_R0, current);
3891         z_aih(Z_R0, -((int)base_h));     // Base has no set bits in lower half.
3892       } else if ((base_h == 0) &amp;&amp; (base_l != 0)) {
3893         lgr_if_needed(Z_R0, current);
3894         z_agfi(Z_R0, -(int)base_l);
3895       } else {
3896         int pow2_offset = get_oop_base_complement(Z_R1, ((uint64_t)(intptr_t)base));
3897         add2reg_with_index(Z_R0, pow2_offset, Z_R1, Rop1); // Subtract base by adding complement.
3898       }
3899 
3900       if (shift != 0) {
3901         z_srlg(Z_R0, Z_R0, shift);
3902       }
3903       bind(done);
3904       z_cl(Z_R0, disp, Rbase);
3905 #ifdef ASSERT
3906       if (used_R0) preset_reg(Z_R0, 0xb05bUL, 2);
3907       if (used_R1) preset_reg(Z_R1, 0xb06bUL, 2);
3908 #endif
3909     }
3910   } else {
3911     z_clg(Rop1, disp, Z_R0, Rbase);
3912   }
3913   BLOCK_COMMENT(&quot;} compare klass ptr&quot;);
3914 }
3915 
3916 //---------------------------
3917 //  Compressed oops
3918 //---------------------------
3919 
3920 void MacroAssembler::encode_heap_oop(Register oop) {
3921   oop_encoder(oop, oop, true /*maybe null*/);
3922 }
3923 
3924 void MacroAssembler::encode_heap_oop_not_null(Register oop) {
3925   oop_encoder(oop, oop, false /*not null*/);
3926 }
3927 
3928 // Called with something derived from the oop base. e.g. oop_base&gt;&gt;3.
3929 int MacroAssembler::get_oop_base_pow2_offset(uint64_t oop_base) {
3930   unsigned int oop_base_ll = ((unsigned int)(oop_base &gt;&gt;  0)) &amp; 0xffff;
3931   unsigned int oop_base_lh = ((unsigned int)(oop_base &gt;&gt; 16)) &amp; 0xffff;
3932   unsigned int oop_base_hl = ((unsigned int)(oop_base &gt;&gt; 32)) &amp; 0xffff;
3933   unsigned int oop_base_hh = ((unsigned int)(oop_base &gt;&gt; 48)) &amp; 0xffff;
3934   unsigned int n_notzero_parts = (oop_base_ll == 0 ? 0:1)
3935                                + (oop_base_lh == 0 ? 0:1)
3936                                + (oop_base_hl == 0 ? 0:1)
3937                                + (oop_base_hh == 0 ? 0:1);
3938 
3939   assert(oop_base != 0, &quot;This is for HeapBased cOops only&quot;);
3940 
3941   if (n_notzero_parts != 1) { //  Check if oop_base is just a few pages shy of a power of 2.
3942     uint64_t pow2_offset = 0x10000 - oop_base_ll;
3943     if (pow2_offset &lt; 0x8000) {  // This might not be necessary.
3944       uint64_t oop_base2 = oop_base + pow2_offset;
3945 
3946       oop_base_ll = ((unsigned int)(oop_base2 &gt;&gt;  0)) &amp; 0xffff;
3947       oop_base_lh = ((unsigned int)(oop_base2 &gt;&gt; 16)) &amp; 0xffff;
3948       oop_base_hl = ((unsigned int)(oop_base2 &gt;&gt; 32)) &amp; 0xffff;
3949       oop_base_hh = ((unsigned int)(oop_base2 &gt;&gt; 48)) &amp; 0xffff;
3950       n_notzero_parts = (oop_base_ll == 0 ? 0:1) +
3951                         (oop_base_lh == 0 ? 0:1) +
3952                         (oop_base_hl == 0 ? 0:1) +
3953                         (oop_base_hh == 0 ? 0:1);
3954       if (n_notzero_parts == 1) {
3955         assert(-(int64_t)pow2_offset != (int64_t)-1, &quot;We use -1 to signal uninitialized base register&quot;);
3956         return -pow2_offset;
3957       }
3958     }
3959   }
3960   return 0;
3961 }
3962 
3963 // If base address is offset from a straight power of two by just a few pages,
3964 // return this offset to the caller for a possible later composite add.
3965 // TODO/FIX: will only work correctly for 4k pages.
3966 int MacroAssembler::get_oop_base(Register Rbase, uint64_t oop_base) {
3967   int pow2_offset = get_oop_base_pow2_offset(oop_base);
3968 
3969   load_const_optimized(Rbase, oop_base - pow2_offset); // Best job possible.
3970 
3971   return pow2_offset;
3972 }
3973 
3974 int MacroAssembler::get_oop_base_complement(Register Rbase, uint64_t oop_base) {
3975   int offset = get_oop_base(Rbase, oop_base);
3976   z_lcgr(Rbase, Rbase);
3977   return -offset;
3978 }
3979 
3980 // Compare compressed oop in memory against oop in register.
3981 // Rop1            - Oop in register.
3982 // disp            - Offset of cOop in memory.
3983 // Rbase           - Base address of cOop in memory.
3984 // maybeNULL       - True if Rop1 possibly is a NULL.
3985 // maybeNULLtarget - Branch target for Rop1 == NULL, if flow control shall NOT continue with compare instruction.
3986 void MacroAssembler::compare_heap_oop(Register Rop1, Address mem, bool maybeNULL) {
3987   Register Rbase  = mem.baseOrR0();
3988   Register Rindex = mem.indexOrR0();
3989   int64_t  disp   = mem.disp();
3990 
3991   const int shift = CompressedOops::shift();
3992   address   base  = CompressedOops::base();
3993 
3994   assert(UseCompressedOops, &quot;must be on to call this method&quot;);
3995   assert(Universe::heap() != NULL, &quot;java heap must be initialized to call this method&quot;);
3996   assert((shift == 0) || (shift == LogMinObjAlignmentInBytes), &quot;cOop encoder detected bad shift&quot;);
3997   assert_different_registers(Rop1, Z_R0);
3998   assert_different_registers(Rop1, Rbase, Z_R1);
3999   assert_different_registers(Rop1, Rindex, Z_R1);
4000 
4001   BLOCK_COMMENT(&quot;compare heap oop {&quot;);
4002 
4003   // First encode register oop and then compare with cOop in memory.
4004   // This sequence saves an unnecessary cOop load and decode.
4005   if (base == NULL) {
4006     if (shift == 0) {
4007       z_cl(Rop1, disp, Rindex, Rbase);  // Unscaled
4008     } else {
4009       z_srlg(Z_R0, Rop1, shift);        // ZeroBased
4010       z_cl(Z_R0, disp, Rindex, Rbase);
4011     }
4012   } else {                              // HeapBased
4013 #ifdef ASSERT
4014     bool  used_R0 = true;
4015     bool  used_R1 = true;
4016 #endif
4017     Label done;
4018     int   pow2_offset = get_oop_base_complement(Z_R1, ((uint64_t)(intptr_t)base));
4019 
4020     if (maybeNULL) {       // NULL ptr must be preserved!
4021       z_ltgr(Z_R0, Rop1);
4022       z_bre(done);
4023     }
4024 
4025     add2reg_with_index(Z_R0, pow2_offset, Z_R1, Rop1);
4026     z_srlg(Z_R0, Z_R0, shift);
4027 
4028     bind(done);
4029     z_cl(Z_R0, disp, Rindex, Rbase);
4030 #ifdef ASSERT
4031     if (used_R0) preset_reg(Z_R0, 0xb05bUL, 2);
4032     if (used_R1) preset_reg(Z_R1, 0xb06bUL, 2);
4033 #endif
4034   }
4035   BLOCK_COMMENT(&quot;} compare heap oop&quot;);
4036 }
4037 
4038 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators,
4039                                      const Address&amp; addr, Register val,
4040                                      Register tmp1, Register tmp2, Register tmp3) {
4041   assert((decorators &amp; ~(AS_RAW | IN_HEAP | IN_NATIVE | IS_ARRAY | IS_NOT_NULL |
4042                          ON_UNKNOWN_OOP_REF)) == 0, &quot;unsupported decorator&quot;);
4043   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4044   decorators = AccessInternal::decorator_fixup(decorators);
4045   bool as_raw = (decorators &amp; AS_RAW) != 0;
4046   if (as_raw) {
4047     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type,
4048                                       addr, val,
4049                                       tmp1, tmp2, tmp3);
4050   } else {
4051     bs-&gt;store_at(this, decorators, type,
4052                  addr, val,
4053                  tmp1, tmp2, tmp3);
4054   }
4055 }
4056 
4057 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators,
4058                                     const Address&amp; addr, Register dst,
4059                                     Register tmp1, Register tmp2, Label *is_null) {
4060   assert((decorators &amp; ~(AS_RAW | IN_HEAP | IN_NATIVE | IS_ARRAY | IS_NOT_NULL |
4061                          ON_PHANTOM_OOP_REF | ON_WEAK_OOP_REF)) == 0, &quot;unsupported decorator&quot;);
4062   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4063   decorators = AccessInternal::decorator_fixup(decorators);
4064   bool as_raw = (decorators &amp; AS_RAW) != 0;
4065   if (as_raw) {
4066     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type,
4067                                      addr, dst,
4068                                      tmp1, tmp2, is_null);
4069   } else {
4070     bs-&gt;load_at(this, decorators, type,
4071                 addr, dst,
4072                 tmp1, tmp2, is_null);
4073   }
4074 }
4075 
4076 void MacroAssembler::load_heap_oop(Register dest, const Address &amp;a,
4077                                    Register tmp1, Register tmp2,
4078                                    DecoratorSet decorators, Label *is_null) {
4079   access_load_at(T_OBJECT, IN_HEAP | decorators, a, dest, tmp1, tmp2, is_null);
4080 }
4081 
4082 void MacroAssembler::store_heap_oop(Register Roop, const Address &amp;a,
4083                                     Register tmp1, Register tmp2, Register tmp3,
4084                                     DecoratorSet decorators) {
4085   access_store_at(T_OBJECT, IN_HEAP | decorators, a, Roop, tmp1, tmp2, tmp3);
4086 }
4087 
4088 //-------------------------------------------------
4089 // Encode compressed oop. Generally usable encoder.
4090 //-------------------------------------------------
4091 // Rsrc - contains regular oop on entry. It remains unchanged.
4092 // Rdst - contains compressed oop on exit.
4093 // Rdst and Rsrc may indicate same register, in which case Rsrc does not remain unchanged.
4094 //
4095 // Rdst must not indicate scratch register Z_R1 (Z_R1_scratch) for functionality.
4096 // Rdst should not indicate scratch register Z_R0 (Z_R0_scratch) for performance.
4097 //
4098 // only32bitValid is set, if later code only uses the lower 32 bits. In this
4099 // case we must not fix the upper 32 bits.
4100 void MacroAssembler::oop_encoder(Register Rdst, Register Rsrc, bool maybeNULL,
4101                                  Register Rbase, int pow2_offset, bool only32bitValid) {
4102 
4103   const address oop_base  = CompressedOops::base();
4104   const int     oop_shift = CompressedOops::shift();
4105   const bool    disjoint  = CompressedOops::base_disjoint();
4106 
4107   assert(UseCompressedOops, &quot;must be on to call this method&quot;);
4108   assert(Universe::heap() != NULL, &quot;java heap must be initialized to call this encoder&quot;);
4109   assert((oop_shift == 0) || (oop_shift == LogMinObjAlignmentInBytes), &quot;cOop encoder detected bad shift&quot;);
4110 
4111   if (disjoint || (oop_base == NULL)) {
4112     BLOCK_COMMENT(&quot;cOop encoder zeroBase {&quot;);
4113     if (oop_shift == 0) {
4114       if (oop_base != NULL &amp;&amp; !only32bitValid) {
4115         z_llgfr(Rdst, Rsrc); // Clear upper bits in case the register will be decoded again.
4116       } else {
4117         lgr_if_needed(Rdst, Rsrc);
4118       }
4119     } else {
4120       z_srlg(Rdst, Rsrc, oop_shift);
4121       if (oop_base != NULL &amp;&amp; !only32bitValid) {
4122         z_llgfr(Rdst, Rdst); // Clear upper bits in case the register will be decoded again.
4123       }
4124     }
4125     BLOCK_COMMENT(&quot;} cOop encoder zeroBase&quot;);
4126     return;
4127   }
4128 
4129   bool used_R0 = false;
4130   bool used_R1 = false;
4131 
4132   BLOCK_COMMENT(&quot;cOop encoder general {&quot;);
4133   assert_different_registers(Rdst, Z_R1);
4134   assert_different_registers(Rsrc, Rbase);
4135   if (maybeNULL) {
4136     Label done;
4137     // We reorder shifting and subtracting, so that we can compare
4138     // and shift in parallel:
4139     //
4140     // cycle 0:  potential LoadN, base = &lt;const&gt;
4141     // cycle 1:  base = !base     dst = src &gt;&gt; 3,    cmp cr = (src != 0)
4142     // cycle 2:  if (cr) br,      dst = dst + base + offset
4143 
4144     // Get oop_base components.
4145     if (pow2_offset == -1) {
4146       if (Rdst == Rbase) {
4147         if (Rdst == Z_R1 || Rsrc == Z_R1) {
4148           Rbase = Z_R0;
4149           used_R0 = true;
4150         } else {
4151           Rdst = Z_R1;
4152           used_R1 = true;
4153         }
4154       }
4155       if (Rbase == Z_R1) {
4156         used_R1 = true;
4157       }
4158       pow2_offset = get_oop_base_complement(Rbase, ((uint64_t)(intptr_t)oop_base) &gt;&gt; oop_shift);
4159     }
4160     assert_different_registers(Rdst, Rbase);
4161 
4162     // Check for NULL oop (must be left alone) and shift.
4163     if (oop_shift != 0) {  // Shift out alignment bits
4164       if (((intptr_t)oop_base&amp;0xc000000000000000L) == 0L) { // We are sure: no single address will have the leftmost bit set.
4165         z_srag(Rdst, Rsrc, oop_shift);  // Arithmetic shift sets the condition code.
4166       } else {
4167         z_srlg(Rdst, Rsrc, oop_shift);
4168         z_ltgr(Rsrc, Rsrc);  // This is the recommended way of testing for zero.
4169         // This probably is faster, as it does not write a register. No!
4170         // z_cghi(Rsrc, 0);
4171       }
4172     } else {
4173       z_ltgr(Rdst, Rsrc);   // Move NULL to result register.
4174     }
4175     z_bre(done);
4176 
4177     // Subtract oop_base components.
4178     if ((Rdst == Z_R0) || (Rbase == Z_R0)) {
4179       z_algr(Rdst, Rbase);
4180       if (pow2_offset != 0) { add2reg(Rdst, pow2_offset); }
4181     } else {
4182       add2reg_with_index(Rdst, pow2_offset, Rbase, Rdst);
4183     }
4184     if (!only32bitValid) {
4185       z_llgfr(Rdst, Rdst); // Clear upper bits in case the register will be decoded again.
4186     }
4187     bind(done);
4188 
4189   } else {  // not null
4190     // Get oop_base components.
4191     if (pow2_offset == -1) {
4192       pow2_offset = get_oop_base_complement(Rbase, (uint64_t)(intptr_t)oop_base);
4193     }
4194 
4195     // Subtract oop_base components and shift.
4196     if (Rdst == Z_R0 || Rsrc == Z_R0 || Rbase == Z_R0) {
4197       // Don&#39;t use lay instruction.
4198       if (Rdst == Rsrc) {
4199         z_algr(Rdst, Rbase);
4200       } else {
4201         lgr_if_needed(Rdst, Rbase);
4202         z_algr(Rdst, Rsrc);
4203       }
4204       if (pow2_offset != 0) add2reg(Rdst, pow2_offset);
4205     } else {
4206       add2reg_with_index(Rdst, pow2_offset, Rbase, Rsrc);
4207     }
4208     if (oop_shift != 0) {   // Shift out alignment bits.
4209       z_srlg(Rdst, Rdst, oop_shift);
4210     }
4211     if (!only32bitValid) {
4212       z_llgfr(Rdst, Rdst); // Clear upper bits in case the register will be decoded again.
4213     }
4214   }
4215 #ifdef ASSERT
4216   if (used_R0 &amp;&amp; Rdst != Z_R0 &amp;&amp; Rsrc != Z_R0) { preset_reg(Z_R0, 0xb01bUL, 2); }
4217   if (used_R1 &amp;&amp; Rdst != Z_R1 &amp;&amp; Rsrc != Z_R1) { preset_reg(Z_R1, 0xb02bUL, 2); }
4218 #endif
4219   BLOCK_COMMENT(&quot;} cOop encoder general&quot;);
4220 }
4221 
4222 //-------------------------------------------------
4223 // decode compressed oop. Generally usable decoder.
4224 //-------------------------------------------------
4225 // Rsrc - contains compressed oop on entry.
4226 // Rdst - contains regular oop on exit.
4227 // Rdst and Rsrc may indicate same register.
4228 // Rdst must not be the same register as Rbase, if Rbase was preloaded (before call).
4229 // Rdst can be the same register as Rbase. Then, either Z_R0 or Z_R1 must be available as scratch.
4230 // Rbase - register to use for the base
4231 // pow2_offset - offset of base to nice value. If -1, base must be loaded.
4232 // For performance, it is good to
4233 //  - avoid Z_R0 for any of the argument registers.
4234 //  - keep Rdst and Rsrc distinct from Rbase. Rdst == Rsrc is ok for performance.
4235 //  - avoid Z_R1 for Rdst if Rdst == Rbase.
4236 void MacroAssembler::oop_decoder(Register Rdst, Register Rsrc, bool maybeNULL, Register Rbase, int pow2_offset) {
4237 
4238   const address oop_base  = CompressedOops::base();
4239   const int     oop_shift = CompressedOops::shift();
4240   const bool    disjoint  = CompressedOops::base_disjoint();
4241 
4242   assert(UseCompressedOops, &quot;must be on to call this method&quot;);
4243   assert(Universe::heap() != NULL, &quot;java heap must be initialized to call this decoder&quot;);
4244   assert((oop_shift == 0) || (oop_shift == LogMinObjAlignmentInBytes),
4245          &quot;cOop encoder detected bad shift&quot;);
4246 
4247   // cOops are always loaded zero-extended from memory. No explicit zero-extension necessary.
4248 
4249   if (oop_base != NULL) {
4250     unsigned int oop_base_hl = ((unsigned int)((uint64_t)(intptr_t)oop_base &gt;&gt; 32)) &amp; 0xffff;
4251     unsigned int oop_base_hh = ((unsigned int)((uint64_t)(intptr_t)oop_base &gt;&gt; 48)) &amp; 0xffff;
4252     unsigned int oop_base_hf = ((unsigned int)((uint64_t)(intptr_t)oop_base &gt;&gt; 32)) &amp; 0xFFFFffff;
4253     if (disjoint &amp;&amp; (oop_base_hl == 0 || oop_base_hh == 0)) {
4254       BLOCK_COMMENT(&quot;cOop decoder disjointBase {&quot;);
4255       // We do not need to load the base. Instead, we can install the upper bits
4256       // with an OR instead of an ADD.
4257       Label done;
4258 
4259       // Rsrc contains a narrow oop. Thus we are sure the leftmost &lt;oop_shift&gt; bits will never be set.
4260       if (maybeNULL) {  // NULL ptr must be preserved!
4261         z_slag(Rdst, Rsrc, oop_shift);  // Arithmetic shift sets the condition code.
4262         z_bre(done);
4263       } else {
4264         z_sllg(Rdst, Rsrc, oop_shift);  // Logical shift leaves condition code alone.
4265       }
4266       if ((oop_base_hl != 0) &amp;&amp; (oop_base_hh != 0)) {
4267         z_oihf(Rdst, oop_base_hf);
4268       } else if (oop_base_hl != 0) {
4269         z_oihl(Rdst, oop_base_hl);
4270       } else {
4271         assert(oop_base_hh != 0, &quot;not heapbased mode&quot;);
4272         z_oihh(Rdst, oop_base_hh);
4273       }
4274       bind(done);
4275       BLOCK_COMMENT(&quot;} cOop decoder disjointBase&quot;);
4276     } else {
4277       BLOCK_COMMENT(&quot;cOop decoder general {&quot;);
4278       // There are three decode steps:
4279       //   scale oop offset (shift left)
4280       //   get base (in reg) and pow2_offset (constant)
4281       //   add base, pow2_offset, and oop offset
4282       // The following register overlap situations may exist:
4283       // Rdst == Rsrc,  Rbase any other
4284       //   not a problem. Scaling in-place leaves Rbase undisturbed.
4285       //   Loading Rbase does not impact the scaled offset.
4286       // Rdst == Rbase, Rsrc  any other
4287       //   scaling would destroy a possibly preloaded Rbase. Loading Rbase
4288       //   would destroy the scaled offset.
4289       //   Remedy: use Rdst_tmp if Rbase has been preloaded.
4290       //           use Rbase_tmp if base has to be loaded.
4291       // Rsrc == Rbase, Rdst  any other
4292       //   Only possible without preloaded Rbase.
4293       //   Loading Rbase does not destroy compressed oop because it was scaled into Rdst before.
4294       // Rsrc == Rbase, Rdst == Rbase
4295       //   Only possible without preloaded Rbase.
4296       //   Loading Rbase would destroy compressed oop. Scaling in-place is ok.
4297       //   Remedy: use Rbase_tmp.
4298       //
4299       Label    done;
4300       Register Rdst_tmp       = Rdst;
4301       Register Rbase_tmp      = Rbase;
4302       bool     used_R0        = false;
4303       bool     used_R1        = false;
4304       bool     base_preloaded = pow2_offset &gt;= 0;
4305       guarantee(!(base_preloaded &amp;&amp; (Rsrc == Rbase)), &quot;Register clash, check caller&quot;);
4306       assert(oop_shift != 0, &quot;room for optimization&quot;);
4307 
4308       // Check if we need to use scratch registers.
4309       if (Rdst == Rbase) {
4310         assert(!(((Rdst == Z_R0) &amp;&amp; (Rsrc == Z_R1)) || ((Rdst == Z_R1) &amp;&amp; (Rsrc == Z_R0))), &quot;need a scratch reg&quot;);
4311         if (Rdst != Rsrc) {
4312           if (base_preloaded) { Rdst_tmp  = (Rdst == Z_R1) ? Z_R0 : Z_R1; }
4313           else                { Rbase_tmp = (Rdst == Z_R1) ? Z_R0 : Z_R1; }
4314         } else {
4315           Rbase_tmp = (Rdst == Z_R1) ? Z_R0 : Z_R1;
4316         }
4317       }
4318       if (base_preloaded) lgr_if_needed(Rbase_tmp, Rbase);
4319 
4320       // Scale oop and check for NULL.
4321       // Rsrc contains a narrow oop. Thus we are sure the leftmost &lt;oop_shift&gt; bits will never be set.
4322       if (maybeNULL) {  // NULL ptr must be preserved!
4323         z_slag(Rdst_tmp, Rsrc, oop_shift);  // Arithmetic shift sets the condition code.
4324         z_bre(done);
4325       } else {
4326         z_sllg(Rdst_tmp, Rsrc, oop_shift);  // Logical shift leaves condition code alone.
4327       }
4328 
4329       // Get oop_base components.
4330       if (!base_preloaded) {
4331         pow2_offset = get_oop_base(Rbase_tmp, (uint64_t)(intptr_t)oop_base);
4332       }
4333 
4334       // Add up all components.
4335       if ((Rbase_tmp == Z_R0) || (Rdst_tmp == Z_R0)) {
4336         z_algr(Rdst_tmp, Rbase_tmp);
4337         if (pow2_offset != 0) { add2reg(Rdst_tmp, pow2_offset); }
4338       } else {
4339         add2reg_with_index(Rdst_tmp, pow2_offset, Rbase_tmp, Rdst_tmp);
4340       }
4341 
4342       bind(done);
4343       lgr_if_needed(Rdst, Rdst_tmp);
4344 #ifdef ASSERT
4345       if (used_R0 &amp;&amp; Rdst != Z_R0 &amp;&amp; Rsrc != Z_R0) { preset_reg(Z_R0, 0xb03bUL, 2); }
4346       if (used_R1 &amp;&amp; Rdst != Z_R1 &amp;&amp; Rsrc != Z_R1) { preset_reg(Z_R1, 0xb04bUL, 2); }
4347 #endif
4348       BLOCK_COMMENT(&quot;} cOop decoder general&quot;);
4349     }
4350   } else {
4351     BLOCK_COMMENT(&quot;cOop decoder zeroBase {&quot;);
4352     if (oop_shift == 0) {
4353       lgr_if_needed(Rdst, Rsrc);
4354     } else {
4355       z_sllg(Rdst, Rsrc, oop_shift);
4356     }
4357     BLOCK_COMMENT(&quot;} cOop decoder zeroBase&quot;);
4358   }
4359 }
4360 
4361 // ((OopHandle)result).resolve();
4362 void MacroAssembler::resolve_oop_handle(Register result) {
4363   // OopHandle::resolve is an indirection.
4364   z_lg(result, 0, result);
4365 }
4366 
4367 void MacroAssembler::load_mirror_from_const_method(Register mirror, Register const_method) {
4368   mem2reg_opt(mirror, Address(const_method, ConstMethod::constants_offset()));
4369   mem2reg_opt(mirror, Address(mirror, ConstantPool::pool_holder_offset_in_bytes()));
4370   mem2reg_opt(mirror, Address(mirror, Klass::java_mirror_offset()));
4371   resolve_oop_handle(mirror);
4372 }
4373 
4374 void MacroAssembler::load_method_holder(Register holder, Register method) {
4375   mem2reg_opt(holder, Address(method, Method::const_offset()));
4376   mem2reg_opt(holder, Address(holder, ConstMethod::constants_offset()));
4377   mem2reg_opt(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes()));
4378 }
4379 
4380 //---------------------------------------------------------------
4381 //---  Operations on arrays.
4382 //---------------------------------------------------------------
4383 
4384 // Compiler ensures base is doubleword aligned and cnt is #doublewords.
4385 // Emitter does not KILL cnt and base arguments, since they need to be copied to
4386 // work registers anyway.
4387 // Actually, only r0, r1, and r5 are killed.
4388 unsigned int MacroAssembler::Clear_Array(Register cnt_arg, Register base_pointer_arg, Register odd_tmp_reg) {
4389 
4390   int      block_start = offset();
4391   Register dst_len  = Z_R1;    // Holds dst len  for MVCLE.
4392   Register dst_addr = Z_R0;    // Holds dst addr for MVCLE.
4393 
4394   Label doXC, doMVCLE, done;
4395 
4396   BLOCK_COMMENT(&quot;Clear_Array {&quot;);
4397 
4398   // Check for zero len and convert to long.
4399   z_ltgfr(odd_tmp_reg, cnt_arg);
4400   z_bre(done);                    // Nothing to do if len == 0.
4401 
4402   // Prefetch data to be cleared.
4403   if (VM_Version::has_Prefetch()) {
4404     z_pfd(0x02,   0, Z_R0, base_pointer_arg);
4405     z_pfd(0x02, 256, Z_R0, base_pointer_arg);
4406   }
4407 
4408   z_sllg(dst_len, odd_tmp_reg, 3); // #bytes to clear.
4409   z_cghi(odd_tmp_reg, 32);         // Check for len &lt;= 256 bytes (&lt;=32 DW).
4410   z_brnh(doXC);                    // If so, use executed XC to clear.
4411 
4412   // MVCLE: initialize long arrays (general case).
4413   bind(doMVCLE);
4414   z_lgr(dst_addr, base_pointer_arg);
4415   // Pass 0 as source length to MVCLE: destination will be filled with padding byte 0.
4416   // The even register of the register pair is not killed.
4417   clear_reg(odd_tmp_reg, true, false);
4418   MacroAssembler::move_long_ext(dst_addr, as_Register(odd_tmp_reg-&gt;encoding()-1), 0);
4419   z_bru(done);
4420 
4421   // XC: initialize short arrays.
4422   Label XC_template; // Instr template, never exec directly!
4423     bind(XC_template);
4424     z_xc(0,0,base_pointer_arg,0,base_pointer_arg);
4425 
4426   bind(doXC);
4427     add2reg(dst_len, -1);               // Get #bytes-1 for EXECUTE.
4428     if (VM_Version::has_ExecuteExtensions()) {
4429       z_exrl(dst_len, XC_template);     // Execute XC with var. len.
4430     } else {
4431       z_larl(odd_tmp_reg, XC_template);
4432       z_ex(dst_len,0,Z_R0,odd_tmp_reg); // Execute XC with var. len.
4433     }
4434     // z_bru(done);      // fallthru
4435 
4436   bind(done);
4437 
4438   BLOCK_COMMENT(&quot;} Clear_Array&quot;);
4439 
4440   int block_end = offset();
4441   return block_end - block_start;
4442 }
4443 
4444 // Compiler ensures base is doubleword aligned and cnt is count of doublewords.
4445 // Emitter does not KILL any arguments nor work registers.
4446 // Emitter generates up to 16 XC instructions, depending on the array length.
4447 unsigned int MacroAssembler::Clear_Array_Const(long cnt, Register base) {
4448   int  block_start    = offset();
4449   int  off;
4450   int  lineSize_Bytes = AllocatePrefetchStepSize;
4451   int  lineSize_DW    = AllocatePrefetchStepSize&gt;&gt;LogBytesPerWord;
4452   bool doPrefetch     = VM_Version::has_Prefetch();
4453   int  XC_maxlen      = 256;
4454   int  numXCInstr     = cnt &gt; 0 ? (cnt*BytesPerWord-1)/XC_maxlen+1 : 0;
4455 
4456   BLOCK_COMMENT(&quot;Clear_Array_Const {&quot;);
4457   assert(cnt*BytesPerWord &lt;= 4096, &quot;ClearArrayConst can handle 4k only&quot;);
4458 
4459   // Do less prefetching for very short arrays.
4460   if (numXCInstr &gt; 0) {
4461     // Prefetch only some cache lines, then begin clearing.
4462     if (doPrefetch) {
4463       if (cnt*BytesPerWord &lt;= lineSize_Bytes/4) {  // If less than 1/4 of a cache line to clear,
4464         z_pfd(0x02, 0, Z_R0, base);                // prefetch just the first cache line.
4465       } else {
4466         assert(XC_maxlen == lineSize_Bytes, &quot;ClearArrayConst needs 256B cache lines&quot;);
4467         for (off = 0; (off &lt; AllocatePrefetchLines) &amp;&amp; (off &lt;= numXCInstr); off ++) {
4468           z_pfd(0x02, off*lineSize_Bytes, Z_R0, base);
4469         }
4470       }
4471     }
4472 
4473     for (off=0; off&lt;(numXCInstr-1); off++) {
4474       z_xc(off*XC_maxlen, XC_maxlen-1, base, off*XC_maxlen, base);
4475 
4476       // Prefetch some cache lines in advance.
4477       if (doPrefetch &amp;&amp; (off &lt;= numXCInstr-AllocatePrefetchLines)) {
4478         z_pfd(0x02, (off+AllocatePrefetchLines)*lineSize_Bytes, Z_R0, base);
4479       }
4480     }
4481     if (off*XC_maxlen &lt; cnt*BytesPerWord) {
4482       z_xc(off*XC_maxlen, (cnt*BytesPerWord-off*XC_maxlen)-1, base, off*XC_maxlen, base);
4483     }
4484   }
4485   BLOCK_COMMENT(&quot;} Clear_Array_Const&quot;);
4486 
4487   int block_end = offset();
4488   return block_end - block_start;
4489 }
4490 
4491 // Compiler ensures base is doubleword aligned and cnt is #doublewords.
4492 // Emitter does not KILL cnt and base arguments, since they need to be copied to
4493 // work registers anyway.
4494 // Actually, only r0, r1, (which are work registers) and odd_tmp_reg are killed.
4495 //
4496 // For very large arrays, exploit MVCLE H/W support.
4497 // MVCLE instruction automatically exploits H/W-optimized page mover.
4498 // - Bytes up to next page boundary are cleared with a series of XC to self.
4499 // - All full pages are cleared with the page mover H/W assist.
4500 // - Remaining bytes are again cleared by a series of XC to self.
4501 //
4502 unsigned int MacroAssembler::Clear_Array_Const_Big(long cnt, Register base_pointer_arg, Register odd_tmp_reg) {
4503 
4504   int      block_start = offset();
4505   Register dst_len  = Z_R1;      // Holds dst len  for MVCLE.
4506   Register dst_addr = Z_R0;      // Holds dst addr for MVCLE.
4507 
4508   BLOCK_COMMENT(&quot;Clear_Array_Const_Big {&quot;);
4509 
4510   // Get len to clear.
4511   load_const_optimized(dst_len, (long)cnt*8L);  // in Bytes = #DW*8
4512 
4513   // Prepare other args to MVCLE.
4514   z_lgr(dst_addr, base_pointer_arg);
4515   // Pass 0 as source length to MVCLE: destination will be filled with padding byte 0.
4516   // The even register of the register pair is not killed.
4517   (void) clear_reg(odd_tmp_reg, true, false);  // Src len of MVCLE is zero.
4518   MacroAssembler::move_long_ext(dst_addr, as_Register(odd_tmp_reg-&gt;encoding() - 1), 0);
4519   BLOCK_COMMENT(&quot;} Clear_Array_Const_Big&quot;);
4520 
4521   int block_end = offset();
4522   return block_end - block_start;
4523 }
4524 
4525 // Allocator.
4526 unsigned int MacroAssembler::CopyRawMemory_AlignedDisjoint(Register src_reg, Register dst_reg,
4527                                                            Register cnt_reg,
4528                                                            Register tmp1_reg, Register tmp2_reg) {
4529   // Tmp1 is oddReg.
4530   // Tmp2 is evenReg.
4531 
4532   int block_start = offset();
4533   Label doMVC, doMVCLE, done, MVC_template;
4534 
4535   BLOCK_COMMENT(&quot;CopyRawMemory_AlignedDisjoint {&quot;);
4536 
4537   // Check for zero len and convert to long.
4538   z_ltgfr(cnt_reg, cnt_reg);      // Remember casted value for doSTG case.
4539   z_bre(done);                    // Nothing to do if len == 0.
4540 
4541   z_sllg(Z_R1, cnt_reg, 3);       // Dst len in bytes. calc early to have the result ready.
4542 
4543   z_cghi(cnt_reg, 32);            // Check for len &lt;= 256 bytes (&lt;=32 DW).
4544   z_brnh(doMVC);                  // If so, use executed MVC to clear.
4545 
4546   bind(doMVCLE);                  // A lot of data (more than 256 bytes).
4547   // Prep dest reg pair.
4548   z_lgr(Z_R0, dst_reg);           // dst addr
4549   // Dst len already in Z_R1.
4550   // Prep src reg pair.
4551   z_lgr(tmp2_reg, src_reg);       // src addr
4552   z_lgr(tmp1_reg, Z_R1);          // Src len same as dst len.
4553 
4554   // Do the copy.
4555   move_long_ext(Z_R0, tmp2_reg, 0xb0); // Bypass cache.
4556   z_bru(done);                         // All done.
4557 
4558   bind(MVC_template);             // Just some data (not more than 256 bytes).
4559   z_mvc(0, 0, dst_reg, 0, src_reg);
4560 
4561   bind(doMVC);
4562 
4563   if (VM_Version::has_ExecuteExtensions()) {
4564     add2reg(Z_R1, -1);
4565   } else {
4566     add2reg(tmp1_reg, -1, Z_R1);
4567     z_larl(Z_R1, MVC_template);
4568   }
4569 
4570   if (VM_Version::has_Prefetch()) {
4571     z_pfd(1,  0,Z_R0,src_reg);
4572     z_pfd(2,  0,Z_R0,dst_reg);
4573     //    z_pfd(1,256,Z_R0,src_reg);    // Assume very short copy.
4574     //    z_pfd(2,256,Z_R0,dst_reg);
4575   }
4576 
4577   if (VM_Version::has_ExecuteExtensions()) {
4578     z_exrl(Z_R1, MVC_template);
4579   } else {
4580     z_ex(tmp1_reg, 0, Z_R0, Z_R1);
4581   }
4582 
4583   bind(done);
4584 
4585   BLOCK_COMMENT(&quot;} CopyRawMemory_AlignedDisjoint&quot;);
4586 
4587   int block_end = offset();
4588   return block_end - block_start;
4589 }
4590 
<a name="2" id="anc2"></a>

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































4591 //-------------------------------------------------
4592 //   Constants (scalar and oop) in constant pool
4593 //-------------------------------------------------
4594 
4595 // Add a non-relocated constant to the CP.
4596 int MacroAssembler::store_const_in_toc(AddressLiteral&amp; val) {
4597   long    value  = val.value();
4598   address tocPos = long_constant(value);
4599 
4600   if (tocPos != NULL) {
4601     int tocOffset = (int)(tocPos - code()-&gt;consts()-&gt;start());
4602     return tocOffset;
4603   }
4604   // Address_constant returned NULL, so no constant entry has been created.
4605   // In that case, we return a &quot;fatal&quot; offset, just in case that subsequently
4606   // generated access code is executed.
4607   return -1;
4608 }
4609 
4610 // Returns the TOC offset where the address is stored.
4611 // Add a relocated constant to the CP.
4612 int MacroAssembler::store_oop_in_toc(AddressLiteral&amp; oop) {
4613   // Use RelocationHolder::none for the constant pool entry.
4614   // Otherwise we will end up with a failing NativeCall::verify(x),
4615   // where x is the address of the constant pool entry.
4616   address tocPos = address_constant((address)oop.value(), RelocationHolder::none);
4617 
4618   if (tocPos != NULL) {
4619     int              tocOffset = (int)(tocPos - code()-&gt;consts()-&gt;start());
4620     RelocationHolder rsp = oop.rspec();
4621     Relocation      *rel = rsp.reloc();
4622 
4623     // Store toc_offset in relocation, used by call_far_patchable.
4624     if ((relocInfo::relocType)rel-&gt;type() == relocInfo::runtime_call_w_cp_type) {
4625       ((runtime_call_w_cp_Relocation *)(rel))-&gt;set_constant_pool_offset(tocOffset);
4626     }
4627     // Relocate at the load&#39;s pc.
4628     relocate(rsp);
4629 
4630     return tocOffset;
4631   }
4632   // Address_constant returned NULL, so no constant entry has been created
4633   // in that case, we return a &quot;fatal&quot; offset, just in case that subsequently
4634   // generated access code is executed.
4635   return -1;
4636 }
4637 
4638 bool MacroAssembler::load_const_from_toc(Register dst, AddressLiteral&amp; a, Register Rtoc) {
4639   int     tocOffset = store_const_in_toc(a);
4640   if (tocOffset == -1) return false;
4641   address tocPos    = tocOffset + code()-&gt;consts()-&gt;start();
4642   assert((address)code()-&gt;consts()-&gt;start() != NULL, &quot;Please add CP address&quot;);
4643   relocate(a.rspec());
4644   load_long_pcrelative(dst, tocPos);
4645   return true;
4646 }
4647 
4648 bool MacroAssembler::load_oop_from_toc(Register dst, AddressLiteral&amp; a, Register Rtoc) {
4649   int     tocOffset = store_oop_in_toc(a);
4650   if (tocOffset == -1) return false;
4651   address tocPos    = tocOffset + code()-&gt;consts()-&gt;start();
4652   assert((address)code()-&gt;consts()-&gt;start() != NULL, &quot;Please add CP address&quot;);
4653 
4654   load_addr_pcrelative(dst, tocPos);
4655   return true;
4656 }
4657 
4658 // If the instruction sequence at the given pc is a load_const_from_toc
4659 // sequence, return the value currently stored at the referenced position
4660 // in the TOC.
4661 intptr_t MacroAssembler::get_const_from_toc(address pc) {
4662 
4663   assert(is_load_const_from_toc(pc), &quot;must be load_const_from_pool&quot;);
4664 
4665   long    offset  = get_load_const_from_toc_offset(pc);
4666   address dataLoc = NULL;
4667   if (is_load_const_from_toc_pcrelative(pc)) {
4668     dataLoc = pc + offset;
4669   } else {
4670     CodeBlob* cb = CodeCache::find_blob_unsafe(pc);   // Else we get assertion if nmethod is zombie.
4671     assert(cb &amp;&amp; cb-&gt;is_nmethod(), &quot;sanity&quot;);
4672     nmethod* nm = (nmethod*)cb;
4673     dataLoc = nm-&gt;ctable_begin() + offset;
4674   }
4675   return *(intptr_t *)dataLoc;
4676 }
4677 
4678 // If the instruction sequence at the given pc is a load_const_from_toc
4679 // sequence, copy the passed-in new_data value into the referenced
4680 // position in the TOC.
4681 void MacroAssembler::set_const_in_toc(address pc, unsigned long new_data, CodeBlob *cb) {
4682   assert(is_load_const_from_toc(pc), &quot;must be load_const_from_pool&quot;);
4683 
4684   long    offset = MacroAssembler::get_load_const_from_toc_offset(pc);
4685   address dataLoc = NULL;
4686   if (is_load_const_from_toc_pcrelative(pc)) {
4687     dataLoc = pc+offset;
4688   } else {
4689     nmethod* nm = CodeCache::find_nmethod(pc);
4690     assert((cb == NULL) || (nm == (nmethod*)cb), &quot;instruction address should be in CodeBlob&quot;);
4691     dataLoc = nm-&gt;ctable_begin() + offset;
4692   }
4693   if (*(unsigned long *)dataLoc != new_data) { // Prevent cache invalidation: update only if necessary.
4694     *(unsigned long *)dataLoc = new_data;
4695   }
4696 }
4697 
4698 // Dynamic TOC. Getter must only be called if &quot;a&quot; is a load_const_from_toc
4699 // site. Verify by calling is_load_const_from_toc() before!!
4700 // Offset is +/- 2**32 -&gt; use long.
4701 long MacroAssembler::get_load_const_from_toc_offset(address a) {
4702   assert(is_load_const_from_toc_pcrelative(a), &quot;expected pc relative load&quot;);
4703   //  expected code sequence:
4704   //    z_lgrl(t, simm32);    len = 6
4705   unsigned long inst;
4706   unsigned int  len = get_instruction(a, &amp;inst);
4707   return get_pcrel_offset(inst);
4708 }
4709 
4710 //**********************************************************************************
4711 //  inspection of generated instruction sequences for a particular pattern
4712 //**********************************************************************************
4713 
4714 bool MacroAssembler::is_load_const_from_toc_pcrelative(address a) {
4715 #ifdef ASSERT
4716   unsigned long inst;
4717   unsigned int  len = get_instruction(a+2, &amp;inst);
4718   if ((len == 6) &amp;&amp; is_load_pcrelative_long(a) &amp;&amp; is_call_pcrelative_long(inst)) {
4719     const int range = 128;
4720     Assembler::dump_code_range(tty, a, range, &quot;instr(a) == z_lgrl &amp;&amp; instr(a+2) == z_brasl&quot;);
4721     VM_Version::z_SIGSEGV();
4722   }
4723 #endif
4724   // expected code sequence:
4725   //   z_lgrl(t, relAddr32);    len = 6
4726   //TODO: verify accessed data is in CP, if possible.
4727   return is_load_pcrelative_long(a);  // TODO: might be too general. Currently, only lgrl is used.
4728 }
4729 
4730 bool MacroAssembler::is_load_const_from_toc_call(address a) {
4731   return is_load_const_from_toc(a) &amp;&amp; is_call_byregister(a + load_const_from_toc_size());
4732 }
4733 
4734 bool MacroAssembler::is_load_const_call(address a) {
4735   return is_load_const(a) &amp;&amp; is_call_byregister(a + load_const_size());
4736 }
4737 
4738 //-------------------------------------------------
4739 //   Emitters for some really CICS instructions
4740 //-------------------------------------------------
4741 
4742 void MacroAssembler::move_long_ext(Register dst, Register src, unsigned int pad) {
4743   assert(dst-&gt;encoding()%2==0, &quot;must be an even/odd register pair&quot;);
4744   assert(src-&gt;encoding()%2==0, &quot;must be an even/odd register pair&quot;);
4745   assert(pad&lt;256, &quot;must be a padding BYTE&quot;);
4746 
4747   Label retry;
4748   bind(retry);
4749   Assembler::z_mvcle(dst, src, pad);
4750   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
4751 }
4752 
4753 void MacroAssembler::compare_long_ext(Register left, Register right, unsigned int pad) {
4754   assert(left-&gt;encoding() % 2 == 0, &quot;must be an even/odd register pair&quot;);
4755   assert(right-&gt;encoding() % 2 == 0, &quot;must be an even/odd register pair&quot;);
4756   assert(pad&lt;256, &quot;must be a padding BYTE&quot;);
4757 
4758   Label retry;
4759   bind(retry);
4760   Assembler::z_clcle(left, right, pad, Z_R0);
4761   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
4762 }
4763 
4764 void MacroAssembler::compare_long_uni(Register left, Register right, unsigned int pad) {
4765   assert(left-&gt;encoding() % 2 == 0, &quot;must be an even/odd register pair&quot;);
4766   assert(right-&gt;encoding() % 2 == 0, &quot;must be an even/odd register pair&quot;);
4767   assert(pad&lt;=0xfff, &quot;must be a padding HALFWORD&quot;);
4768   assert(VM_Version::has_ETF2(), &quot;instruction must be available&quot;);
4769 
4770   Label retry;
4771   bind(retry);
4772   Assembler::z_clclu(left, right, pad, Z_R0);
4773   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
4774 }
4775 
4776 void MacroAssembler::search_string(Register end, Register start) {
4777   assert(end-&gt;encoding() != 0, &quot;end address must not be in R0&quot;);
4778   assert(start-&gt;encoding() != 0, &quot;start address must not be in R0&quot;);
4779 
4780   Label retry;
4781   bind(retry);
4782   Assembler::z_srst(end, start);
4783   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
4784 }
4785 
4786 void MacroAssembler::search_string_uni(Register end, Register start) {
4787   assert(end-&gt;encoding() != 0, &quot;end address must not be in R0&quot;);
4788   assert(start-&gt;encoding() != 0, &quot;start address must not be in R0&quot;);
4789   assert(VM_Version::has_ETF3(), &quot;instruction must be available&quot;);
4790 
4791   Label retry;
4792   bind(retry);
4793   Assembler::z_srstu(end, start);
4794   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
4795 }
4796 
4797 void MacroAssembler::kmac(Register srcBuff) {
4798   assert(srcBuff-&gt;encoding()     != 0, &quot;src buffer address can&#39;t be in Z_R0&quot;);
4799   assert(srcBuff-&gt;encoding() % 2 == 0, &quot;src buffer/len must be an even/odd register pair&quot;);
4800 
4801   Label retry;
4802   bind(retry);
4803   Assembler::z_kmac(Z_R0, srcBuff);
4804   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
4805 }
4806 
4807 void MacroAssembler::kimd(Register srcBuff) {
4808   assert(srcBuff-&gt;encoding()     != 0, &quot;src buffer address can&#39;t be in Z_R0&quot;);
4809   assert(srcBuff-&gt;encoding() % 2 == 0, &quot;src buffer/len must be an even/odd register pair&quot;);
4810 
4811   Label retry;
4812   bind(retry);
4813   Assembler::z_kimd(Z_R0, srcBuff);
4814   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
4815 }
4816 
4817 void MacroAssembler::klmd(Register srcBuff) {
4818   assert(srcBuff-&gt;encoding()     != 0, &quot;src buffer address can&#39;t be in Z_R0&quot;);
4819   assert(srcBuff-&gt;encoding() % 2 == 0, &quot;src buffer/len must be an even/odd register pair&quot;);
4820 
4821   Label retry;
4822   bind(retry);
4823   Assembler::z_klmd(Z_R0, srcBuff);
4824   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
4825 }
4826 
4827 void MacroAssembler::km(Register dstBuff, Register srcBuff) {
4828   // DstBuff and srcBuff are allowed to be the same register (encryption in-place).
4829   // DstBuff and srcBuff storage must not overlap destructively, and neither must overlap the parameter block.
4830   assert(srcBuff-&gt;encoding()     != 0, &quot;src buffer address can&#39;t be in Z_R0&quot;);
4831   assert(dstBuff-&gt;encoding() % 2 == 0, &quot;dst buffer addr must be an even register&quot;);
4832   assert(srcBuff-&gt;encoding() % 2 == 0, &quot;src buffer addr/len must be an even/odd register pair&quot;);
4833 
4834   Label retry;
4835   bind(retry);
4836   Assembler::z_km(dstBuff, srcBuff);
4837   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
4838 }
4839 
4840 void MacroAssembler::kmc(Register dstBuff, Register srcBuff) {
4841   // DstBuff and srcBuff are allowed to be the same register (encryption in-place).
4842   // DstBuff and srcBuff storage must not overlap destructively, and neither must overlap the parameter block.
4843   assert(srcBuff-&gt;encoding()     != 0, &quot;src buffer address can&#39;t be in Z_R0&quot;);
4844   assert(dstBuff-&gt;encoding() % 2 == 0, &quot;dst buffer addr must be an even register&quot;);
4845   assert(srcBuff-&gt;encoding() % 2 == 0, &quot;src buffer addr/len must be an even/odd register pair&quot;);
4846 
4847   Label retry;
4848   bind(retry);
4849   Assembler::z_kmc(dstBuff, srcBuff);
4850   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
4851 }
4852 
4853 void MacroAssembler::cksm(Register crcBuff, Register srcBuff) {
4854   assert(srcBuff-&gt;encoding() % 2 == 0, &quot;src buffer addr/len must be an even/odd register pair&quot;);
4855 
4856   Label retry;
4857   bind(retry);
4858   Assembler::z_cksm(crcBuff, srcBuff);
4859   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
4860 }
4861 
4862 void MacroAssembler::translate_oo(Register r1, Register r2, uint m3) {
4863   assert(r1-&gt;encoding() % 2 == 0, &quot;dst addr/src len must be an even/odd register pair&quot;);
4864   assert((m3 &amp; 0b1110) == 0, &quot;Unused mask bits must be zero&quot;);
4865 
4866   Label retry;
4867   bind(retry);
4868   Assembler::z_troo(r1, r2, m3);
4869   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
4870 }
4871 
4872 void MacroAssembler::translate_ot(Register r1, Register r2, uint m3) {
4873   assert(r1-&gt;encoding() % 2 == 0, &quot;dst addr/src len must be an even/odd register pair&quot;);
4874   assert((m3 &amp; 0b1110) == 0, &quot;Unused mask bits must be zero&quot;);
4875 
4876   Label retry;
4877   bind(retry);
4878   Assembler::z_trot(r1, r2, m3);
4879   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
4880 }
4881 
4882 void MacroAssembler::translate_to(Register r1, Register r2, uint m3) {
4883   assert(r1-&gt;encoding() % 2 == 0, &quot;dst addr/src len must be an even/odd register pair&quot;);
4884   assert((m3 &amp; 0b1110) == 0, &quot;Unused mask bits must be zero&quot;);
4885 
4886   Label retry;
4887   bind(retry);
4888   Assembler::z_trto(r1, r2, m3);
4889   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
4890 }
4891 
4892 void MacroAssembler::translate_tt(Register r1, Register r2, uint m3) {
4893   assert(r1-&gt;encoding() % 2 == 0, &quot;dst addr/src len must be an even/odd register pair&quot;);
4894   assert((m3 &amp; 0b1110) == 0, &quot;Unused mask bits must be zero&quot;);
4895 
4896   Label retry;
4897   bind(retry);
4898   Assembler::z_trtt(r1, r2, m3);
4899   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
4900 }
4901 
4902 //---------------------------------------
4903 // Helpers for Intrinsic Emitters
4904 //---------------------------------------
4905 
4906 /**
4907  * uint32_t crc;
4908  * timesXtoThe32[crc &amp; 0xFF] ^ (crc &gt;&gt; 8);
4909  */
4910 void MacroAssembler::fold_byte_crc32(Register crc, Register val, Register table, Register tmp) {
4911   assert_different_registers(crc, table, tmp);
4912   assert_different_registers(val, table);
4913   if (crc == val) {      // Must rotate first to use the unmodified value.
4914     rotate_then_insert(tmp, val, 56-2, 63-2, 2, true);  // Insert byte 7 of val, shifted left by 2, into byte 6..7 of tmp, clear the rest.
4915     z_srl(crc, 8);       // Unsigned shift, clear leftmost 8 bits.
4916   } else {
4917     z_srl(crc, 8);       // Unsigned shift, clear leftmost 8 bits.
4918     rotate_then_insert(tmp, val, 56-2, 63-2, 2, true);  // Insert byte 7 of val, shifted left by 2, into byte 6..7 of tmp, clear the rest.
4919   }
4920   z_x(crc, Address(table, tmp, 0));
4921 }
4922 
4923 /**
4924  * uint32_t crc;
4925  * timesXtoThe32[crc &amp; 0xFF] ^ (crc &gt;&gt; 8);
4926  */
4927 void MacroAssembler::fold_8bit_crc32(Register crc, Register table, Register tmp) {
4928   fold_byte_crc32(crc, crc, table, tmp);
4929 }
4930 
4931 /**
4932  * Emits code to update CRC-32 with a byte value according to constants in table.
4933  *
4934  * @param [in,out]crc Register containing the crc.
4935  * @param [in]val     Register containing the byte to fold into the CRC.
4936  * @param [in]table   Register containing the table of crc constants.
4937  *
4938  * uint32_t crc;
4939  * val = crc_table[(val ^ crc) &amp; 0xFF];
4940  * crc = val ^ (crc &gt;&gt; 8);
4941  */
4942 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
4943   z_xr(val, crc);
4944   fold_byte_crc32(crc, val, table, val);
4945 }
4946 
4947 
4948 /**
4949  * @param crc   register containing existing CRC (32-bit)
4950  * @param buf   register pointing to input byte buffer (byte*)
4951  * @param len   register containing number of bytes
4952  * @param table register pointing to CRC table
4953  */
4954 void MacroAssembler::update_byteLoop_crc32(Register crc, Register buf, Register len, Register table, Register data) {
4955   assert_different_registers(crc, buf, len, table, data);
4956 
4957   Label L_mainLoop, L_done;
4958   const int mainLoop_stepping = 1;
4959 
4960   // Process all bytes in a single-byte loop.
4961   z_ltr(len, len);
4962   z_brnh(L_done);
4963 
4964   bind(L_mainLoop);
4965     z_llgc(data, Address(buf, (intptr_t)0));// Current byte of input buffer (zero extended). Avoids garbage in upper half of register.
4966     add2reg(buf, mainLoop_stepping);        // Advance buffer position.
4967     update_byte_crc32(crc, data, table);
4968     z_brct(len, L_mainLoop);                // Iterate.
4969 
4970   bind(L_done);
4971 }
4972 
4973 /**
4974  * Emits code to update CRC-32 with a 4-byte value according to constants in table.
4975  * Implementation according to jdk/src/share/native/java/util/zip/zlib-1.2.8/crc32.c.
4976  *
4977  */
4978 void MacroAssembler::update_1word_crc32(Register crc, Register buf, Register table, int bufDisp, int bufInc,
4979                                         Register t0,  Register t1,  Register t2,    Register t3) {
4980   // This is what we implement (the DOBIG4 part):
4981   //
4982   // #define DOBIG4 c ^= *++buf4; \
4983   //         c = crc_table[4][c &amp; 0xff] ^ crc_table[5][(c &gt;&gt; 8) &amp; 0xff] ^ \
4984   //             crc_table[6][(c &gt;&gt; 16) &amp; 0xff] ^ crc_table[7][c &gt;&gt; 24]
4985   // #define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4
4986   // Pre-calculate (constant) column offsets, use columns 4..7 for big-endian.
4987   const int ix0 = 4*(4*CRC32_COLUMN_SIZE);
4988   const int ix1 = 5*(4*CRC32_COLUMN_SIZE);
4989   const int ix2 = 6*(4*CRC32_COLUMN_SIZE);
4990   const int ix3 = 7*(4*CRC32_COLUMN_SIZE);
4991 
4992   // XOR crc with next four bytes of buffer.
4993   lgr_if_needed(t0, crc);
4994   z_x(t0, Address(buf, bufDisp));
4995   if (bufInc != 0) {
4996     add2reg(buf, bufInc);
4997   }
4998 
4999   // Chop crc into 4 single-byte pieces, shifted left 2 bits, to form the table indices.
5000   rotate_then_insert(t3, t0, 56-2, 63-2, 2,    true);  // ((c &gt;&gt;  0) &amp; 0xff) &lt;&lt; 2
5001   rotate_then_insert(t2, t0, 56-2, 63-2, 2-8,  true);  // ((c &gt;&gt;  8) &amp; 0xff) &lt;&lt; 2
5002   rotate_then_insert(t1, t0, 56-2, 63-2, 2-16, true);  // ((c &gt;&gt; 16) &amp; 0xff) &lt;&lt; 2
5003   rotate_then_insert(t0, t0, 56-2, 63-2, 2-24, true);  // ((c &gt;&gt; 24) &amp; 0xff) &lt;&lt; 2
5004 
5005   // XOR indexed table values to calculate updated crc.
5006   z_ly(t2, Address(table, t2, (intptr_t)ix1));
5007   z_ly(t0, Address(table, t0, (intptr_t)ix3));
5008   z_xy(t2, Address(table, t3, (intptr_t)ix0));
5009   z_xy(t0, Address(table, t1, (intptr_t)ix2));
5010   z_xr(t0, t2);           // Now t0 contains the updated CRC value.
5011   lgr_if_needed(crc, t0);
5012 }
5013 
5014 /**
5015  * @param crc   register containing existing CRC (32-bit)
5016  * @param buf   register pointing to input byte buffer (byte*)
5017  * @param len   register containing number of bytes
5018  * @param table register pointing to CRC table
5019  *
5020  * uses Z_R10..Z_R13 as work register. Must be saved/restored by caller!
5021  */
5022 void MacroAssembler::kernel_crc32_1word(Register crc, Register buf, Register len, Register table,
5023                                         Register t0,  Register t1,  Register t2,  Register t3,
5024                                         bool invertCRC) {
5025   assert_different_registers(crc, buf, len, table);
5026 
5027   Label L_mainLoop, L_tail;
5028   Register  data = t0;
5029   Register  ctr  = Z_R0;
5030   const int mainLoop_stepping = 4;
5031   const int log_stepping      = exact_log2(mainLoop_stepping);
5032 
5033   // Don&#39;t test for len &lt;= 0 here. This pathological case should not occur anyway.
5034   // Optimizing for it by adding a test and a branch seems to be a waste of CPU cycles.
5035   // The situation itself is detected and handled correctly by the conditional branches
5036   // following aghi(len, -stepping) and aghi(len, +stepping).
5037 
5038   if (invertCRC) {
5039     not_(crc, noreg, false);           // 1s complement of crc
5040   }
5041 
5042   // Check for short (&lt;4 bytes) buffer.
5043   z_srag(ctr, len, log_stepping);
5044   z_brnh(L_tail);
5045 
5046   z_lrvr(crc, crc);          // Revert byte order because we are dealing with big-endian data.
5047   rotate_then_insert(len, len, 64-log_stepping, 63, 0, true); // #bytes for tailLoop
5048 
5049   BIND(L_mainLoop);
5050     update_1word_crc32(crc, buf, table, 0, mainLoop_stepping, crc, t1, t2, t3);
5051     z_brct(ctr, L_mainLoop); // Iterate.
5052 
5053   z_lrvr(crc, crc);          // Revert byte order back to original.
5054 
5055   // Process last few (&lt;8) bytes of buffer.
5056   BIND(L_tail);
5057   update_byteLoop_crc32(crc, buf, len, table, data);
5058 
5059   if (invertCRC) {
5060     not_(crc, noreg, false);           // 1s complement of crc
5061   }
5062 }
5063 
5064 /**
5065  * @param crc   register containing existing CRC (32-bit)
5066  * @param buf   register pointing to input byte buffer (byte*)
5067  * @param len   register containing number of bytes
5068  * @param table register pointing to CRC table
5069  */
5070 void MacroAssembler::kernel_crc32_1byte(Register crc, Register buf, Register len, Register table,
5071                                         Register t0,  Register t1,  Register t2,  Register t3,
5072                                         bool invertCRC) {
5073   assert_different_registers(crc, buf, len, table);
5074   Register data = t0;
5075 
5076   if (invertCRC) {
5077     not_(crc, noreg, false);           // 1s complement of crc
5078   }
5079 
5080   update_byteLoop_crc32(crc, buf, len, table, data);
5081 
5082   if (invertCRC) {
5083     not_(crc, noreg, false);           // 1s complement of crc
5084   }
5085 }
5086 
5087 void MacroAssembler::kernel_crc32_singleByte(Register crc, Register buf, Register len, Register table, Register tmp,
5088                                              bool invertCRC) {
5089   assert_different_registers(crc, buf, len, table, tmp);
5090 
5091   if (invertCRC) {
5092     not_(crc, noreg, false);           // 1s complement of crc
5093   }
5094 
5095   z_llgc(tmp, Address(buf, (intptr_t)0));  // Current byte of input buffer (zero extended). Avoids garbage in upper half of register.
5096   update_byte_crc32(crc, tmp, table);
5097 
5098   if (invertCRC) {
5099     not_(crc, noreg, false);           // 1s complement of crc
5100   }
5101 }
5102 
5103 void MacroAssembler::kernel_crc32_singleByteReg(Register crc, Register val, Register table,
5104                                                 bool invertCRC) {
5105   assert_different_registers(crc, val, table);
5106 
5107   if (invertCRC) {
5108     not_(crc, noreg, false);           // 1s complement of crc
5109   }
5110 
5111   update_byte_crc32(crc, val, table);
5112 
5113   if (invertCRC) {
5114     not_(crc, noreg, false);           // 1s complement of crc
5115   }
5116 }
5117 
5118 //
5119 // Code for BigInteger::multiplyToLen() intrinsic.
5120 //
5121 
5122 // dest_lo += src1 + src2
5123 // dest_hi += carry1 + carry2
5124 // Z_R7 is destroyed !
5125 void MacroAssembler::add2_with_carry(Register dest_hi, Register dest_lo,
5126                                      Register src1, Register src2) {
5127   clear_reg(Z_R7);
5128   z_algr(dest_lo, src1);
5129   z_alcgr(dest_hi, Z_R7);
5130   z_algr(dest_lo, src2);
5131   z_alcgr(dest_hi, Z_R7);
5132 }
5133 
5134 // Multiply 64 bit by 64 bit first loop.
5135 void MacroAssembler::multiply_64_x_64_loop(Register x, Register xstart,
5136                                            Register x_xstart,
5137                                            Register y, Register y_idx,
5138                                            Register z,
5139                                            Register carry,
5140                                            Register product,
5141                                            Register idx, Register kdx) {
5142   // jlong carry, x[], y[], z[];
5143   // for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx--, kdx--) {
5144   //   huge_128 product = y[idx] * x[xstart] + carry;
5145   //   z[kdx] = (jlong)product;
5146   //   carry  = (jlong)(product &gt;&gt;&gt; 64);
5147   // }
5148   // z[xstart] = carry;
5149 
5150   Label L_first_loop, L_first_loop_exit;
5151   Label L_one_x, L_one_y, L_multiply;
5152 
5153   z_aghi(xstart, -1);
5154   z_brl(L_one_x);   // Special case: length of x is 1.
5155 
5156   // Load next two integers of x.
5157   z_sllg(Z_R1_scratch, xstart, LogBytesPerInt);
5158   mem2reg_opt(x_xstart, Address(x, Z_R1_scratch, 0));
5159 
5160 
5161   bind(L_first_loop);
5162 
5163   z_aghi(idx, -1);
5164   z_brl(L_first_loop_exit);
5165   z_aghi(idx, -1);
5166   z_brl(L_one_y);
5167 
5168   // Load next two integers of y.
5169   z_sllg(Z_R1_scratch, idx, LogBytesPerInt);
5170   mem2reg_opt(y_idx, Address(y, Z_R1_scratch, 0));
5171 
5172 
5173   bind(L_multiply);
5174 
5175   Register multiplicand = product-&gt;successor();
5176   Register product_low = multiplicand;
5177 
5178   lgr_if_needed(multiplicand, x_xstart);
5179   z_mlgr(product, y_idx);     // multiplicand * y_idx -&gt; product::multiplicand
5180   clear_reg(Z_R7);
5181   z_algr(product_low, carry); // Add carry to result.
5182   z_alcgr(product, Z_R7);     // Add carry of the last addition.
5183   add2reg(kdx, -2);
5184 
5185   // Store result.
5186   z_sllg(Z_R7, kdx, LogBytesPerInt);
5187   reg2mem_opt(product_low, Address(z, Z_R7, 0));
5188   lgr_if_needed(carry, product);
5189   z_bru(L_first_loop);
5190 
5191 
5192   bind(L_one_y); // Load one 32 bit portion of y as (0,value).
5193 
5194   clear_reg(y_idx);
5195   mem2reg_opt(y_idx, Address(y, (intptr_t) 0), false);
5196   z_bru(L_multiply);
5197 
5198 
5199   bind(L_one_x); // Load one 32 bit portion of x as (0,value).
5200 
5201   clear_reg(x_xstart);
5202   mem2reg_opt(x_xstart, Address(x, (intptr_t) 0), false);
5203   z_bru(L_first_loop);
5204 
5205   bind(L_first_loop_exit);
5206 }
5207 
5208 // Multiply 64 bit by 64 bit and add 128 bit.
5209 void MacroAssembler::multiply_add_128_x_128(Register x_xstart, Register y,
5210                                             Register z,
5211                                             Register yz_idx, Register idx,
5212                                             Register carry, Register product,
5213                                             int offset) {
5214   // huge_128 product = (y[idx] * x_xstart) + z[kdx] + carry;
5215   // z[kdx] = (jlong)product;
5216 
5217   Register multiplicand = product-&gt;successor();
5218   Register product_low = multiplicand;
5219 
5220   z_sllg(Z_R7, idx, LogBytesPerInt);
5221   mem2reg_opt(yz_idx, Address(y, Z_R7, offset));
5222 
5223   lgr_if_needed(multiplicand, x_xstart);
5224   z_mlgr(product, yz_idx); // multiplicand * yz_idx -&gt; product::multiplicand
5225   mem2reg_opt(yz_idx, Address(z, Z_R7, offset));
5226 
5227   add2_with_carry(product, product_low, carry, yz_idx);
5228 
5229   z_sllg(Z_R7, idx, LogBytesPerInt);
5230   reg2mem_opt(product_low, Address(z, Z_R7, offset));
5231 
5232 }
5233 
5234 // Multiply 128 bit by 128 bit. Unrolled inner loop.
5235 void MacroAssembler::multiply_128_x_128_loop(Register x_xstart,
5236                                              Register y, Register z,
5237                                              Register yz_idx, Register idx,
5238                                              Register jdx,
5239                                              Register carry, Register product,
5240                                              Register carry2) {
5241   // jlong carry, x[], y[], z[];
5242   // int kdx = ystart+1;
5243   // for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
5244   //   huge_128 product = (y[idx+1] * x_xstart) + z[kdx+idx+1] + carry;
5245   //   z[kdx+idx+1] = (jlong)product;
5246   //   jlong carry2 = (jlong)(product &gt;&gt;&gt; 64);
5247   //   product = (y[idx] * x_xstart) + z[kdx+idx] + carry2;
5248   //   z[kdx+idx] = (jlong)product;
5249   //   carry = (jlong)(product &gt;&gt;&gt; 64);
5250   // }
5251   // idx += 2;
5252   // if (idx &gt; 0) {
5253   //   product = (y[idx] * x_xstart) + z[kdx+idx] + carry;
5254   //   z[kdx+idx] = (jlong)product;
5255   //   carry = (jlong)(product &gt;&gt;&gt; 64);
5256   // }
5257 
5258   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
5259 
5260   // scale the index
5261   lgr_if_needed(jdx, idx);
5262   and_imm(jdx, 0xfffffffffffffffcL);
5263   rshift(jdx, 2);
5264 
5265 
5266   bind(L_third_loop);
5267 
5268   z_aghi(jdx, -1);
5269   z_brl(L_third_loop_exit);
5270   add2reg(idx, -4);
5271 
5272   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 8);
5273   lgr_if_needed(carry2, product);
5274 
5275   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry2, product, 0);
5276   lgr_if_needed(carry, product);
5277   z_bru(L_third_loop);
5278 
5279 
5280   bind(L_third_loop_exit);  // Handle any left-over operand parts.
5281 
5282   and_imm(idx, 0x3);
5283   z_brz(L_post_third_loop_done);
5284 
5285   Label L_check_1;
5286 
5287   z_aghi(idx, -2);
5288   z_brl(L_check_1);
5289 
5290   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 0);
5291   lgr_if_needed(carry, product);
5292 
5293 
5294   bind(L_check_1);
5295 
5296   add2reg(idx, 0x2);
5297   and_imm(idx, 0x1);
5298   z_aghi(idx, -1);
5299   z_brl(L_post_third_loop_done);
5300 
5301   Register   multiplicand = product-&gt;successor();
5302   Register   product_low = multiplicand;
5303 
5304   z_sllg(Z_R7, idx, LogBytesPerInt);
5305   clear_reg(yz_idx);
5306   mem2reg_opt(yz_idx, Address(y, Z_R7, 0), false);
5307   lgr_if_needed(multiplicand, x_xstart);
5308   z_mlgr(product, yz_idx); // multiplicand * yz_idx -&gt; product::multiplicand
5309   clear_reg(yz_idx);
5310   mem2reg_opt(yz_idx, Address(z, Z_R7, 0), false);
5311 
5312   add2_with_carry(product, product_low, yz_idx, carry);
5313 
5314   z_sllg(Z_R7, idx, LogBytesPerInt);
5315   reg2mem_opt(product_low, Address(z, Z_R7, 0), false);
5316   rshift(product_low, 32);
5317 
5318   lshift(product, 32);
5319   z_ogr(product_low, product);
5320   lgr_if_needed(carry, product_low);
5321 
5322   bind(L_post_third_loop_done);
5323 }
5324 
5325 void MacroAssembler::multiply_to_len(Register x, Register xlen,
5326                                      Register y, Register ylen,
5327                                      Register z,
5328                                      Register tmp1, Register tmp2,
5329                                      Register tmp3, Register tmp4,
5330                                      Register tmp5) {
5331   ShortBranchVerifier sbv(this);
5332 
5333   assert_different_registers(x, xlen, y, ylen, z,
5334                              tmp1, tmp2, tmp3, tmp4, tmp5, Z_R1_scratch, Z_R7);
5335   assert_different_registers(x, xlen, y, ylen, z,
5336                              tmp1, tmp2, tmp3, tmp4, tmp5, Z_R8);
5337 
5338   z_stmg(Z_R7, Z_R13, _z_abi(gpr7), Z_SP);
5339 
5340   // In openJdk, we store the argument as 32-bit value to slot.
5341   Address zlen(Z_SP, _z_abi(remaining_cargs));  // Int in long on big endian.
5342 
5343   const Register idx = tmp1;
5344   const Register kdx = tmp2;
5345   const Register xstart = tmp3;
5346 
5347   const Register y_idx = tmp4;
5348   const Register carry = tmp5;
5349   const Register product  = Z_R0_scratch;
5350   const Register x_xstart = Z_R8;
5351 
5352   // First Loop.
5353   //
5354   //   final static long LONG_MASK = 0xffffffffL;
5355   //   int xstart = xlen - 1;
5356   //   int ystart = ylen - 1;
5357   //   long carry = 0;
5358   //   for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
5359   //     long product = (y[idx] &amp; LONG_MASK) * (x[xstart] &amp; LONG_MASK) + carry;
5360   //     z[kdx] = (int)product;
5361   //     carry = product &gt;&gt;&gt; 32;
5362   //   }
5363   //   z[xstart] = (int)carry;
5364   //
5365 
5366   lgr_if_needed(idx, ylen);  // idx = ylen
5367   z_llgf(kdx, zlen);         // C2 does not respect int to long conversion for stub calls, thus load zero-extended.
5368   clear_reg(carry);          // carry = 0
5369 
5370   Label L_done;
5371 
5372   lgr_if_needed(xstart, xlen);
5373   z_aghi(xstart, -1);
5374   z_brl(L_done);
5375 
5376   multiply_64_x_64_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);
5377 
5378   NearLabel L_second_loop;
5379   compare64_and_branch(kdx, RegisterOrConstant((intptr_t) 0), bcondEqual, L_second_loop);
5380 
5381   NearLabel L_carry;
5382   z_aghi(kdx, -1);
5383   z_brz(L_carry);
5384 
5385   // Store lower 32 bits of carry.
5386   z_sllg(Z_R1_scratch, kdx, LogBytesPerInt);
5387   reg2mem_opt(carry, Address(z, Z_R1_scratch, 0), false);
5388   rshift(carry, 32);
5389   z_aghi(kdx, -1);
5390 
5391 
5392   bind(L_carry);
5393 
5394   // Store upper 32 bits of carry.
5395   z_sllg(Z_R1_scratch, kdx, LogBytesPerInt);
5396   reg2mem_opt(carry, Address(z, Z_R1_scratch, 0), false);
5397 
5398   // Second and third (nested) loops.
5399   //
5400   // for (int i = xstart-1; i &gt;= 0; i--) { // Second loop
5401   //   carry = 0;
5402   //   for (int jdx=ystart, k=ystart+1+i; jdx &gt;= 0; jdx--, k--) { // Third loop
5403   //     long product = (y[jdx] &amp; LONG_MASK) * (x[i] &amp; LONG_MASK) +
5404   //                    (z[k] &amp; LONG_MASK) + carry;
5405   //     z[k] = (int)product;
5406   //     carry = product &gt;&gt;&gt; 32;
5407   //   }
5408   //   z[i] = (int)carry;
5409   // }
5410   //
5411   // i = xlen, j = tmp1, k = tmp2, carry = tmp5, x[i] = rdx
5412 
5413   const Register jdx = tmp1;
5414 
5415   bind(L_second_loop);
5416 
5417   clear_reg(carry);           // carry = 0;
5418   lgr_if_needed(jdx, ylen);   // j = ystart+1
5419 
5420   z_aghi(xstart, -1);         // i = xstart-1;
5421   z_brl(L_done);
5422 
5423   // Use free slots in the current stackframe instead of push/pop.
5424   Address zsave(Z_SP, _z_abi(carg_1));
5425   reg2mem_opt(z, zsave);
5426 
5427 
5428   Label L_last_x;
5429 
5430   z_sllg(Z_R1_scratch, xstart, LogBytesPerInt);
5431   load_address(z, Address(z, Z_R1_scratch, 4)); // z = z + k - j
5432   z_aghi(xstart, -1);                           // i = xstart-1;
5433   z_brl(L_last_x);
5434 
5435   z_sllg(Z_R1_scratch, xstart, LogBytesPerInt);
5436   mem2reg_opt(x_xstart, Address(x, Z_R1_scratch, 0));
5437 
5438 
5439   Label L_third_loop_prologue;
5440 
5441   bind(L_third_loop_prologue);
5442 
5443   Address xsave(Z_SP, _z_abi(carg_2));
5444   Address xlensave(Z_SP, _z_abi(carg_3));
5445   Address ylensave(Z_SP, _z_abi(carg_4));
5446 
5447   reg2mem_opt(x, xsave);
5448   reg2mem_opt(xstart, xlensave);
5449   reg2mem_opt(ylen, ylensave);
5450 
5451 
5452   multiply_128_x_128_loop(x_xstart, y, z, y_idx, jdx, ylen, carry, product, x);
5453 
5454   mem2reg_opt(z, zsave);
5455   mem2reg_opt(x, xsave);
5456   mem2reg_opt(xlen, xlensave);   // This is the decrement of the loop counter!
5457   mem2reg_opt(ylen, ylensave);
5458 
5459   add2reg(tmp3, 1, xlen);
5460   z_sllg(Z_R1_scratch, tmp3, LogBytesPerInt);
5461   reg2mem_opt(carry, Address(z, Z_R1_scratch, 0), false);
5462   z_aghi(tmp3, -1);
5463   z_brl(L_done);
5464 
5465   rshift(carry, 32);
5466   z_sllg(Z_R1_scratch, tmp3, LogBytesPerInt);
5467   reg2mem_opt(carry, Address(z, Z_R1_scratch, 0), false);
5468   z_bru(L_second_loop);
5469 
5470   // Next infrequent code is moved outside loops.
5471   bind(L_last_x);
5472 
5473   clear_reg(x_xstart);
5474   mem2reg_opt(x_xstart, Address(x, (intptr_t) 0), false);
5475   z_bru(L_third_loop_prologue);
5476 
5477   bind(L_done);
5478 
5479   z_lmg(Z_R7, Z_R13, _z_abi(gpr7), Z_SP);
5480 }
5481 
5482 #ifndef PRODUCT
5483 // Assert if CC indicates &quot;not equal&quot; (check_equal==true) or &quot;equal&quot; (check_equal==false).
5484 void MacroAssembler::asm_assert(bool check_equal, const char *msg, int id) {
5485   Label ok;
5486   if (check_equal) {
5487     z_bre(ok);
5488   } else {
5489     z_brne(ok);
5490   }
5491   stop(msg, id);
5492   bind(ok);
5493 }
5494 
5495 // Assert if CC indicates &quot;low&quot;.
5496 void MacroAssembler::asm_assert_low(const char *msg, int id) {
5497   Label ok;
5498   z_brnl(ok);
5499   stop(msg, id);
5500   bind(ok);
5501 }
5502 
5503 // Assert if CC indicates &quot;high&quot;.
5504 void MacroAssembler::asm_assert_high(const char *msg, int id) {
5505   Label ok;
5506   z_brnh(ok);
5507   stop(msg, id);
5508   bind(ok);
5509 }
5510 
5511 // Assert if CC indicates &quot;not equal&quot; (check_equal==true) or &quot;equal&quot; (check_equal==false)
5512 // generate non-relocatable code.
5513 void MacroAssembler::asm_assert_static(bool check_equal, const char *msg, int id) {
5514   Label ok;
5515   if (check_equal) { z_bre(ok); }
5516   else             { z_brne(ok); }
5517   stop_static(msg, id);
5518   bind(ok);
5519 }
5520 
5521 void MacroAssembler::asm_assert_mems_zero(bool check_equal, bool allow_relocation, int size, int64_t mem_offset,
5522                                           Register mem_base, const char* msg, int id) {
5523   switch (size) {
5524     case 4:
5525       load_and_test_int(Z_R0, Address(mem_base, mem_offset));
5526       break;
5527     case 8:
5528       load_and_test_long(Z_R0,  Address(mem_base, mem_offset));
5529       break;
5530     default:
5531       ShouldNotReachHere();
5532   }
5533   if (allow_relocation) { asm_assert(check_equal, msg, id); }
5534   else                  { asm_assert_static(check_equal, msg, id); }
5535 }
5536 
5537 // Check the condition
5538 //   expected_size == FP - SP
5539 // after transformation:
5540 //   expected_size - FP + SP == 0
5541 // Destroys Register expected_size if no tmp register is passed.
5542 void MacroAssembler::asm_assert_frame_size(Register expected_size, Register tmp, const char* msg, int id) {
5543   if (tmp == noreg) {
5544     tmp = expected_size;
5545   } else {
5546     if (tmp != expected_size) {
5547       z_lgr(tmp, expected_size);
5548     }
5549     z_algr(tmp, Z_SP);
5550     z_slg(tmp, 0, Z_R0, Z_SP);
5551     asm_assert_eq(msg, id);
5552   }
5553 }
5554 #endif // !PRODUCT
5555 
5556 void MacroAssembler::verify_thread() {
5557   if (VerifyThread) {
5558     unimplemented(&quot;&quot;, 117);
5559   }
5560 }
5561 
5562 // Save and restore functions: Exclude Z_R0.
5563 void MacroAssembler::save_volatile_regs(Register dst, int offset, bool include_fp, bool include_flags) {
5564   z_stmg(Z_R1, Z_R5, offset, dst); offset += 5 * BytesPerWord;
5565   if (include_fp) {
5566     z_std(Z_F0, Address(dst, offset)); offset += BytesPerWord;
5567     z_std(Z_F1, Address(dst, offset)); offset += BytesPerWord;
5568     z_std(Z_F2, Address(dst, offset)); offset += BytesPerWord;
5569     z_std(Z_F3, Address(dst, offset)); offset += BytesPerWord;
5570     z_std(Z_F4, Address(dst, offset)); offset += BytesPerWord;
5571     z_std(Z_F5, Address(dst, offset)); offset += BytesPerWord;
5572     z_std(Z_F6, Address(dst, offset)); offset += BytesPerWord;
5573     z_std(Z_F7, Address(dst, offset)); offset += BytesPerWord;
5574   }
5575   if (include_flags) {
5576     Label done;
5577     z_mvi(Address(dst, offset), 2); // encoding: equal
5578     z_bre(done);
5579     z_mvi(Address(dst, offset), 4); // encoding: higher
5580     z_brh(done);
5581     z_mvi(Address(dst, offset), 1); // encoding: lower
5582     bind(done);
5583   }
5584 }
5585 void MacroAssembler::restore_volatile_regs(Register src, int offset, bool include_fp, bool include_flags) {
5586   z_lmg(Z_R1, Z_R5, offset, src); offset += 5 * BytesPerWord;
5587   if (include_fp) {
5588     z_ld(Z_F0, Address(src, offset)); offset += BytesPerWord;
5589     z_ld(Z_F1, Address(src, offset)); offset += BytesPerWord;
5590     z_ld(Z_F2, Address(src, offset)); offset += BytesPerWord;
5591     z_ld(Z_F3, Address(src, offset)); offset += BytesPerWord;
5592     z_ld(Z_F4, Address(src, offset)); offset += BytesPerWord;
5593     z_ld(Z_F5, Address(src, offset)); offset += BytesPerWord;
5594     z_ld(Z_F6, Address(src, offset)); offset += BytesPerWord;
5595     z_ld(Z_F7, Address(src, offset)); offset += BytesPerWord;
5596   }
5597   if (include_flags) {
5598     z_cli(Address(src, offset), 2); // see encoding above
5599   }
5600 }
5601 
5602 // Plausibility check for oops.
5603 void MacroAssembler::verify_oop(Register oop, const char* msg) {
5604   if (!VerifyOops) return;
5605 
5606   BLOCK_COMMENT(&quot;verify_oop {&quot;);
5607   unsigned int nbytes_save = (5 + 8 + 1) * BytesPerWord;
5608   address entry_addr = StubRoutines::verify_oop_subroutine_entry_address();
5609 
5610   save_return_pc();
5611 
5612   // Push frame, but preserve flags
5613   z_lgr(Z_R0, Z_SP);
5614   z_lay(Z_SP, -((int64_t)nbytes_save + frame::z_abi_160_size), Z_SP);
5615   z_stg(Z_R0, _z_abi(callers_sp), Z_SP);
5616 
5617   save_volatile_regs(Z_SP, frame::z_abi_160_size, true, true);
5618 
5619   lgr_if_needed(Z_ARG2, oop);
5620   load_const_optimized(Z_ARG1, (address)msg);
5621   load_const_optimized(Z_R1, entry_addr);
5622   z_lg(Z_R1, 0, Z_R1);
5623   call_c(Z_R1);
5624 
5625   restore_volatile_regs(Z_SP, frame::z_abi_160_size, true, true);
5626   pop_frame();
5627   restore_return_pc();
5628 
5629   BLOCK_COMMENT(&quot;} verify_oop &quot;);
5630 }
5631 
5632 void MacroAssembler::verify_oop_addr(Address addr, const char* msg) {
5633   if (!VerifyOops) return;
5634 
5635   BLOCK_COMMENT(&quot;verify_oop {&quot;);
5636   unsigned int nbytes_save = (5 + 8) * BytesPerWord;
5637   address entry_addr = StubRoutines::verify_oop_subroutine_entry_address();
5638 
5639   save_return_pc();
5640   unsigned int frame_size = push_frame_abi160(nbytes_save); // kills Z_R0
5641   save_volatile_regs(Z_SP, frame::z_abi_160_size, true, false);
5642 
5643   z_lg(Z_ARG2, addr.plus_disp(frame_size));
5644   load_const_optimized(Z_ARG1, (address)msg);
5645   load_const_optimized(Z_R1, entry_addr);
5646   z_lg(Z_R1, 0, Z_R1);
5647   call_c(Z_R1);
5648 
5649   restore_volatile_regs(Z_SP, frame::z_abi_160_size, true, false);
5650   pop_frame();
5651   restore_return_pc();
5652 
5653   BLOCK_COMMENT(&quot;} verify_oop &quot;);
5654 }
5655 
5656 const char* MacroAssembler::stop_types[] = {
5657   &quot;stop&quot;,
5658   &quot;untested&quot;,
5659   &quot;unimplemented&quot;,
5660   &quot;shouldnotreachhere&quot;
5661 };
5662 
5663 static void stop_on_request(const char* tp, const char* msg) {
5664   tty-&gt;print(&quot;Z assembly code requires stop: (%s) %s\n&quot;, tp, msg);
5665   guarantee(false, &quot;Z assembly code requires stop: %s&quot;, msg);
5666 }
5667 
5668 void MacroAssembler::stop(int type, const char* msg, int id) {
5669   BLOCK_COMMENT(err_msg(&quot;stop: %s {&quot;, msg));
5670 
5671   // Setup arguments.
5672   load_const(Z_ARG1, (void*) stop_types[type%stop_end]);
5673   load_const(Z_ARG2, (void*) msg);
5674   get_PC(Z_R14);     // Following code pushes a frame without entering a new function. Use current pc as return address.
5675   save_return_pc();  // Saves return pc Z_R14.
5676   push_frame_abi160(0);
5677   call_VM_leaf(CAST_FROM_FN_PTR(address, stop_on_request), Z_ARG1, Z_ARG2);
5678   // The plain disassembler does not recognize illtrap. It instead displays
5679   // a 32-bit value. Issueing two illtraps assures the disassembler finds
5680   // the proper beginning of the next instruction.
5681   z_illtrap(); // Illegal instruction.
5682   z_illtrap(); // Illegal instruction.
5683 
5684   BLOCK_COMMENT(&quot; } stop&quot;);
5685 }
5686 
5687 // Special version of stop() for code size reduction.
5688 // Reuses the previously generated call sequence, if any.
5689 // Generates the call sequence on its own, if necessary.
5690 // Note: This code will work only in non-relocatable code!
5691 //       The relative address of the data elements (arg1, arg2) must not change.
5692 //       The reentry point must not move relative to it&#39;s users. This prerequisite
5693 //       should be given for &quot;hand-written&quot; code, if all chain calls are in the same code blob.
5694 //       Generated code must not undergo any transformation, e.g. ShortenBranches, to be safe.
5695 address MacroAssembler::stop_chain(address reentry, int type, const char* msg, int id, bool allow_relocation) {
5696   BLOCK_COMMENT(err_msg(&quot;stop_chain(%s,%s): %s {&quot;, reentry==NULL?&quot;init&quot;:&quot;cont&quot;, allow_relocation?&quot;reloc &quot;:&quot;static&quot;, msg));
5697 
5698   // Setup arguments.
5699   if (allow_relocation) {
5700     // Relocatable version (for comparison purposes). Remove after some time.
5701     load_const(Z_ARG1, (void*) stop_types[type%stop_end]);
5702     load_const(Z_ARG2, (void*) msg);
5703   } else {
5704     load_absolute_address(Z_ARG1, (address)stop_types[type%stop_end]);
5705     load_absolute_address(Z_ARG2, (address)msg);
5706   }
5707   if ((reentry != NULL) &amp;&amp; RelAddr::is_in_range_of_RelAddr16(reentry, pc())) {
5708     BLOCK_COMMENT(&quot;branch to reentry point:&quot;);
5709     z_brc(bcondAlways, reentry);
5710   } else {
5711     BLOCK_COMMENT(&quot;reentry point:&quot;);
5712     reentry = pc();      // Re-entry point for subsequent stop calls.
5713     save_return_pc();    // Saves return pc Z_R14.
5714     push_frame_abi160(0);
5715     if (allow_relocation) {
5716       reentry = NULL;    // Prevent reentry if code relocation is allowed.
5717       call_VM_leaf(CAST_FROM_FN_PTR(address, stop_on_request), Z_ARG1, Z_ARG2);
5718     } else {
5719       call_VM_leaf_static(CAST_FROM_FN_PTR(address, stop_on_request), Z_ARG1, Z_ARG2);
5720     }
5721     z_illtrap(); // Illegal instruction as emergency stop, should the above call return.
5722   }
5723   BLOCK_COMMENT(&quot; } stop_chain&quot;);
5724 
5725   return reentry;
5726 }
5727 
5728 // Special version of stop() for code size reduction.
5729 // Assumes constant relative addresses for data and runtime call.
5730 void MacroAssembler::stop_static(int type, const char* msg, int id) {
5731   stop_chain(NULL, type, msg, id, false);
5732 }
5733 
5734 void MacroAssembler::stop_subroutine() {
5735   unimplemented(&quot;stop_subroutine&quot;, 710);
5736 }
5737 
5738 // Prints msg to stdout from within generated code..
5739 void MacroAssembler::warn(const char* msg) {
5740   RegisterSaver::save_live_registers(this, RegisterSaver::all_registers, Z_R14);
5741   load_absolute_address(Z_R1, (address) warning);
5742   load_absolute_address(Z_ARG1, (address) msg);
5743   (void) call(Z_R1);
5744   RegisterSaver::restore_live_registers(this, RegisterSaver::all_registers);
5745 }
5746 
5747 #ifndef PRODUCT
5748 
5749 // Write pattern 0x0101010101010101 in region [low-before, high+after].
5750 void MacroAssembler::zap_from_to(Register low, Register high, Register val, Register addr, int before, int after) {
5751   if (!ZapEmptyStackFields) return;
5752   BLOCK_COMMENT(&quot;zap memory region {&quot;);
5753   load_const_optimized(val, 0x0101010101010101);
5754   int size = before + after;
5755   if (low == high &amp;&amp; size &lt; 5 &amp;&amp; size &gt; 0) {
5756     int offset = -before*BytesPerWord;
5757     for (int i = 0; i &lt; size; ++i) {
5758       z_stg(val, Address(low, offset));
5759       offset +=(1*BytesPerWord);
5760     }
5761   } else {
5762     add2reg(addr, -before*BytesPerWord, low);
5763     if (after) {
5764 #ifdef ASSERT
5765       jlong check = after * BytesPerWord;
5766       assert(Immediate::is_simm32(check) &amp;&amp; Immediate::is_simm32(-check), &quot;value not encodable !&quot;);
5767 #endif
5768       add2reg(high, after * BytesPerWord);
5769     }
5770     NearLabel loop;
5771     bind(loop);
5772     z_stg(val, Address(addr));
5773     add2reg(addr, 8);
5774     compare64_and_branch(addr, high, bcondNotHigh, loop);
5775     if (after) {
5776       add2reg(high, -after * BytesPerWord);
5777     }
5778   }
5779   BLOCK_COMMENT(&quot;} zap memory region&quot;);
5780 }
5781 #endif // !PRODUCT
5782 
5783 SkipIfEqual::SkipIfEqual(MacroAssembler* masm, const bool* flag_addr, bool value, Register _rscratch) {
5784   _masm = masm;
5785   _masm-&gt;load_absolute_address(_rscratch, (address)flag_addr);
5786   _masm-&gt;load_and_test_int(_rscratch, Address(_rscratch));
5787   if (value) {
5788     _masm-&gt;z_brne(_label); // Skip if true, i.e. != 0.
5789   } else {
5790     _masm-&gt;z_bre(_label);  // Skip if false, i.e. == 0.
5791   }
5792 }
5793 
5794 SkipIfEqual::~SkipIfEqual() {
5795   _masm-&gt;bind(_label);
5796 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/s390/macroAssembler_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2016, 2019, SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/codeBuffer.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  32 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
  36 #include &quot;memory/universe.hpp&quot;
  37 #include &quot;oops/accessDecorators.hpp&quot;
  38 #include &quot;oops/compressedOops.inline.hpp&quot;
  39 #include &quot;oops/klass.inline.hpp&quot;
<a name="1" id="anc1"></a><span class="line-removed">  40 #ifdef COMPILER2</span>
<span class="line-removed">  41 #include &quot;opto/compile.hpp&quot;</span>
<span class="line-removed">  42 #include &quot;opto/intrinsicnode.hpp&quot;</span>
<span class="line-removed">  43 #include &quot;opto/matcher.hpp&quot;</span>
<span class="line-removed">  44 #endif</span>
  45 #include &quot;prims/methodHandles.hpp&quot;
  46 #include &quot;registerSaver_s390.hpp&quot;
  47 #include &quot;runtime/biasedLocking.hpp&quot;
  48 #include &quot;runtime/icache.hpp&quot;
  49 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  50 #include &quot;runtime/objectMonitor.hpp&quot;
  51 #include &quot;runtime/os.hpp&quot;
  52 #include &quot;runtime/safepoint.hpp&quot;
  53 #include &quot;runtime/safepointMechanism.hpp&quot;
  54 #include &quot;runtime/sharedRuntime.hpp&quot;
  55 #include &quot;runtime/stubRoutines.hpp&quot;
  56 #include &quot;utilities/events.hpp&quot;
  57 #include &quot;utilities/macros.hpp&quot;
  58 #include &quot;utilities/powerOfTwo.hpp&quot;
  59 
  60 #include &lt;ucontext.h&gt;
  61 
  62 #define BLOCK_COMMENT(str) block_comment(str)
  63 #define BIND(label)        bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  64 
  65 // Move 32-bit register if destination and source are different.
  66 void MacroAssembler::lr_if_needed(Register rd, Register rs) {
  67   if (rs != rd) { z_lr(rd, rs); }
  68 }
  69 
  70 // Move register if destination and source are different.
  71 void MacroAssembler::lgr_if_needed(Register rd, Register rs) {
  72   if (rs != rd) { z_lgr(rd, rs); }
  73 }
  74 
  75 // Zero-extend 32-bit register into 64-bit register if destination and source are different.
  76 void MacroAssembler::llgfr_if_needed(Register rd, Register rs) {
  77   if (rs != rd) { z_llgfr(rd, rs); }
  78 }
  79 
  80 // Move float register if destination and source are different.
  81 void MacroAssembler::ldr_if_needed(FloatRegister rd, FloatRegister rs) {
  82   if (rs != rd) { z_ldr(rd, rs); }
  83 }
  84 
  85 // Move integer register if destination and source are different.
  86 // It is assumed that shorter-than-int types are already
  87 // appropriately sign-extended.
  88 void MacroAssembler::move_reg_if_needed(Register dst, BasicType dst_type, Register src,
  89                                         BasicType src_type) {
  90   assert((dst_type != T_FLOAT) &amp;&amp; (dst_type != T_DOUBLE), &quot;use move_freg for float types&quot;);
  91   assert((src_type != T_FLOAT) &amp;&amp; (src_type != T_DOUBLE), &quot;use move_freg for float types&quot;);
  92 
  93   if (dst_type == src_type) {
  94     lgr_if_needed(dst, src); // Just move all 64 bits.
  95     return;
  96   }
  97 
  98   switch (dst_type) {
  99     // Do not support these types for now.
 100     //  case T_BOOLEAN:
 101     case T_BYTE:  // signed byte
 102       switch (src_type) {
 103         case T_INT:
 104           z_lgbr(dst, src);
 105           break;
 106         default:
 107           ShouldNotReachHere();
 108       }
 109       return;
 110 
 111     case T_CHAR:
 112     case T_SHORT:
 113       switch (src_type) {
 114         case T_INT:
 115           if (dst_type == T_CHAR) {
 116             z_llghr(dst, src);
 117           } else {
 118             z_lghr(dst, src);
 119           }
 120           break;
 121         default:
 122           ShouldNotReachHere();
 123       }
 124       return;
 125 
 126     case T_INT:
 127       switch (src_type) {
 128         case T_BOOLEAN:
 129         case T_BYTE:
 130         case T_CHAR:
 131         case T_SHORT:
 132         case T_INT:
 133         case T_LONG:
 134         case T_OBJECT:
 135         case T_ARRAY:
 136         case T_VOID:
 137         case T_ADDRESS:
 138           lr_if_needed(dst, src);
 139           // llgfr_if_needed(dst, src);  // zero-extend (in case we need to find a bug).
 140           return;
 141 
 142         default:
 143           assert(false, &quot;non-integer src type&quot;);
 144           return;
 145       }
 146     case T_LONG:
 147       switch (src_type) {
 148         case T_BOOLEAN:
 149         case T_BYTE:
 150         case T_CHAR:
 151         case T_SHORT:
 152         case T_INT:
 153           z_lgfr(dst, src); // sign extension
 154           return;
 155 
 156         case T_LONG:
 157         case T_OBJECT:
 158         case T_ARRAY:
 159         case T_VOID:
 160         case T_ADDRESS:
 161           lgr_if_needed(dst, src);
 162           return;
 163 
 164         default:
 165           assert(false, &quot;non-integer src type&quot;);
 166           return;
 167       }
 168       return;
 169     case T_OBJECT:
 170     case T_ARRAY:
 171     case T_VOID:
 172     case T_ADDRESS:
 173       switch (src_type) {
 174         // These types don&#39;t make sense to be converted to pointers:
 175         //      case T_BOOLEAN:
 176         //      case T_BYTE:
 177         //      case T_CHAR:
 178         //      case T_SHORT:
 179 
 180         case T_INT:
 181           z_llgfr(dst, src); // zero extension
 182           return;
 183 
 184         case T_LONG:
 185         case T_OBJECT:
 186         case T_ARRAY:
 187         case T_VOID:
 188         case T_ADDRESS:
 189           lgr_if_needed(dst, src);
 190           return;
 191 
 192         default:
 193           assert(false, &quot;non-integer src type&quot;);
 194           return;
 195       }
 196       return;
 197     default:
 198       assert(false, &quot;non-integer dst type&quot;);
 199       return;
 200   }
 201 }
 202 
 203 // Move float register if destination and source are different.
 204 void MacroAssembler::move_freg_if_needed(FloatRegister dst, BasicType dst_type,
 205                                          FloatRegister src, BasicType src_type) {
 206   assert((dst_type == T_FLOAT) || (dst_type == T_DOUBLE), &quot;use move_reg for int types&quot;);
 207   assert((src_type == T_FLOAT) || (src_type == T_DOUBLE), &quot;use move_reg for int types&quot;);
 208   if (dst_type == src_type) {
 209     ldr_if_needed(dst, src); // Just move all 64 bits.
 210   } else {
 211     switch (dst_type) {
 212       case T_FLOAT:
 213         assert(src_type == T_DOUBLE, &quot;invalid float type combination&quot;);
 214         z_ledbr(dst, src);
 215         return;
 216       case T_DOUBLE:
 217         assert(src_type == T_FLOAT, &quot;invalid float type combination&quot;);
 218         z_ldebr(dst, src);
 219         return;
 220       default:
 221         assert(false, &quot;non-float dst type&quot;);
 222         return;
 223     }
 224   }
 225 }
 226 
 227 // Optimized emitter for reg to mem operations.
 228 // Uses modern instructions if running on modern hardware, classic instructions
 229 // otherwise. Prefers (usually shorter) classic instructions if applicable.
 230 // Data register (reg) cannot be used as work register.
 231 //
 232 // Don&#39;t rely on register locking, instead pass a scratch register (Z_R0 by default).
 233 // CAUTION! Passing registers &gt;= Z_R2 may produce bad results on old CPUs!
 234 void MacroAssembler::freg2mem_opt(FloatRegister reg,
 235                                   int64_t       disp,
 236                                   Register      index,
 237                                   Register      base,
 238                                   void (MacroAssembler::*modern) (FloatRegister, int64_t, Register, Register),
 239                                   void (MacroAssembler::*classic)(FloatRegister, int64_t, Register, Register),
 240                                   Register      scratch) {
 241   index = (index == noreg) ? Z_R0 : index;
 242   if (Displacement::is_shortDisp(disp)) {
 243     (this-&gt;*classic)(reg, disp, index, base);
 244   } else {
 245     if (Displacement::is_validDisp(disp)) {
 246       (this-&gt;*modern)(reg, disp, index, base);
 247     } else {
 248       if (scratch != Z_R0 &amp;&amp; scratch != Z_R1) {
 249         (this-&gt;*modern)(reg, disp, index, base);      // Will fail with disp out of range.
 250       } else {
 251         if (scratch != Z_R0) {   // scratch == Z_R1
 252           if ((scratch == index) || (index == base)) {
 253             (this-&gt;*modern)(reg, disp, index, base);  // Will fail with disp out of range.
 254           } else {
 255             add2reg(scratch, disp, base);
 256             (this-&gt;*classic)(reg, 0, index, scratch);
 257             if (base == scratch) {
 258               add2reg(base, -disp);  // Restore base.
 259             }
 260           }
 261         } else {   // scratch == Z_R0
 262           z_lgr(scratch, base);
 263           add2reg(base, disp);
 264           (this-&gt;*classic)(reg, 0, index, base);
 265           z_lgr(base, scratch);      // Restore base.
 266         }
 267       }
 268     }
 269   }
 270 }
 271 
 272 void MacroAssembler::freg2mem_opt(FloatRegister reg, const Address &amp;a, bool is_double) {
 273   if (is_double) {
 274     freg2mem_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_FFUN(z_stdy), CLASSIC_FFUN(z_std));
 275   } else {
 276     freg2mem_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_FFUN(z_stey), CLASSIC_FFUN(z_ste));
 277   }
 278 }
 279 
 280 // Optimized emitter for mem to reg operations.
 281 // Uses modern instructions if running on modern hardware, classic instructions
 282 // otherwise. Prefers (usually shorter) classic instructions if applicable.
 283 // data register (reg) cannot be used as work register.
 284 //
 285 // Don&#39;t rely on register locking, instead pass a scratch register (Z_R0 by default).
 286 // CAUTION! Passing registers &gt;= Z_R2 may produce bad results on old CPUs!
 287 void MacroAssembler::mem2freg_opt(FloatRegister reg,
 288                                   int64_t       disp,
 289                                   Register      index,
 290                                   Register      base,
 291                                   void (MacroAssembler::*modern) (FloatRegister, int64_t, Register, Register),
 292                                   void (MacroAssembler::*classic)(FloatRegister, int64_t, Register, Register),
 293                                   Register      scratch) {
 294   index = (index == noreg) ? Z_R0 : index;
 295   if (Displacement::is_shortDisp(disp)) {
 296     (this-&gt;*classic)(reg, disp, index, base);
 297   } else {
 298     if (Displacement::is_validDisp(disp)) {
 299       (this-&gt;*modern)(reg, disp, index, base);
 300     } else {
 301       if (scratch != Z_R0 &amp;&amp; scratch != Z_R1) {
 302         (this-&gt;*modern)(reg, disp, index, base);      // Will fail with disp out of range.
 303       } else {
 304         if (scratch != Z_R0) {   // scratch == Z_R1
 305           if ((scratch == index) || (index == base)) {
 306             (this-&gt;*modern)(reg, disp, index, base);  // Will fail with disp out of range.
 307           } else {
 308             add2reg(scratch, disp, base);
 309             (this-&gt;*classic)(reg, 0, index, scratch);
 310             if (base == scratch) {
 311               add2reg(base, -disp);  // Restore base.
 312             }
 313           }
 314         } else {   // scratch == Z_R0
 315           z_lgr(scratch, base);
 316           add2reg(base, disp);
 317           (this-&gt;*classic)(reg, 0, index, base);
 318           z_lgr(base, scratch);      // Restore base.
 319         }
 320       }
 321     }
 322   }
 323 }
 324 
 325 void MacroAssembler::mem2freg_opt(FloatRegister reg, const Address &amp;a, bool is_double) {
 326   if (is_double) {
 327     mem2freg_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_FFUN(z_ldy), CLASSIC_FFUN(z_ld));
 328   } else {
 329     mem2freg_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_FFUN(z_ley), CLASSIC_FFUN(z_le));
 330   }
 331 }
 332 
 333 // Optimized emitter for reg to mem operations.
 334 // Uses modern instructions if running on modern hardware, classic instructions
 335 // otherwise. Prefers (usually shorter) classic instructions if applicable.
 336 // Data register (reg) cannot be used as work register.
 337 //
 338 // Don&#39;t rely on register locking, instead pass a scratch register
 339 // (Z_R0 by default)
 340 // CAUTION! passing registers &gt;= Z_R2 may produce bad results on old CPUs!
 341 void MacroAssembler::reg2mem_opt(Register reg,
 342                                  int64_t  disp,
 343                                  Register index,
 344                                  Register base,
 345                                  void (MacroAssembler::*modern) (Register, int64_t, Register, Register),
 346                                  void (MacroAssembler::*classic)(Register, int64_t, Register, Register),
 347                                  Register scratch) {
 348   index = (index == noreg) ? Z_R0 : index;
 349   if (Displacement::is_shortDisp(disp)) {
 350     (this-&gt;*classic)(reg, disp, index, base);
 351   } else {
 352     if (Displacement::is_validDisp(disp)) {
 353       (this-&gt;*modern)(reg, disp, index, base);
 354     } else {
 355       if (scratch != Z_R0 &amp;&amp; scratch != Z_R1) {
 356         (this-&gt;*modern)(reg, disp, index, base);      // Will fail with disp out of range.
 357       } else {
 358         if (scratch != Z_R0) {   // scratch == Z_R1
 359           if ((scratch == index) || (index == base)) {
 360             (this-&gt;*modern)(reg, disp, index, base);  // Will fail with disp out of range.
 361           } else {
 362             add2reg(scratch, disp, base);
 363             (this-&gt;*classic)(reg, 0, index, scratch);
 364             if (base == scratch) {
 365               add2reg(base, -disp);  // Restore base.
 366             }
 367           }
 368         } else {   // scratch == Z_R0
 369           if ((scratch == reg) || (scratch == base) || (reg == base)) {
 370             (this-&gt;*modern)(reg, disp, index, base);  // Will fail with disp out of range.
 371           } else {
 372             z_lgr(scratch, base);
 373             add2reg(base, disp);
 374             (this-&gt;*classic)(reg, 0, index, base);
 375             z_lgr(base, scratch);    // Restore base.
 376           }
 377         }
 378       }
 379     }
 380   }
 381 }
 382 
 383 int MacroAssembler::reg2mem_opt(Register reg, const Address &amp;a, bool is_double) {
 384   int store_offset = offset();
 385   if (is_double) {
 386     reg2mem_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_IFUN(z_stg), CLASSIC_IFUN(z_stg));
 387   } else {
 388     reg2mem_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_IFUN(z_sty), CLASSIC_IFUN(z_st));
 389   }
 390   return store_offset;
 391 }
 392 
 393 // Optimized emitter for mem to reg operations.
 394 // Uses modern instructions if running on modern hardware, classic instructions
 395 // otherwise. Prefers (usually shorter) classic instructions if applicable.
 396 // Data register (reg) will be used as work register where possible.
 397 void MacroAssembler::mem2reg_opt(Register reg,
 398                                  int64_t  disp,
 399                                  Register index,
 400                                  Register base,
 401                                  void (MacroAssembler::*modern) (Register, int64_t, Register, Register),
 402                                  void (MacroAssembler::*classic)(Register, int64_t, Register, Register)) {
 403   index = (index == noreg) ? Z_R0 : index;
 404   if (Displacement::is_shortDisp(disp)) {
 405     (this-&gt;*classic)(reg, disp, index, base);
 406   } else {
 407     if (Displacement::is_validDisp(disp)) {
 408       (this-&gt;*modern)(reg, disp, index, base);
 409     } else {
 410       if ((reg == index) &amp;&amp; (reg == base)) {
 411         z_sllg(reg, reg, 1);
 412         add2reg(reg, disp);
 413         (this-&gt;*classic)(reg, 0, noreg, reg);
 414       } else if ((reg == index) &amp;&amp; (reg != Z_R0)) {
 415         add2reg(reg, disp);
 416         (this-&gt;*classic)(reg, 0, reg, base);
 417       } else if (reg == base) {
 418         add2reg(reg, disp);
 419         (this-&gt;*classic)(reg, 0, index, reg);
 420       } else if (reg != Z_R0) {
 421         add2reg(reg, disp, base);
 422         (this-&gt;*classic)(reg, 0, index, reg);
 423       } else { // reg == Z_R0 &amp;&amp; reg != base here
 424         add2reg(base, disp);
 425         (this-&gt;*classic)(reg, 0, index, base);
 426         add2reg(base, -disp);
 427       }
 428     }
 429   }
 430 }
 431 
 432 void MacroAssembler::mem2reg_opt(Register reg, const Address &amp;a, bool is_double) {
 433   if (is_double) {
 434     z_lg(reg, a);
 435   } else {
 436     mem2reg_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_IFUN(z_ly), CLASSIC_IFUN(z_l));
 437   }
 438 }
 439 
 440 void MacroAssembler::mem2reg_signed_opt(Register reg, const Address &amp;a) {
 441   mem2reg_opt(reg, a.disp20(), a.indexOrR0(), a.baseOrR0(), MODERN_IFUN(z_lgf), CLASSIC_IFUN(z_lgf));
 442 }
 443 
 444 void MacroAssembler::and_imm(Register r, long mask,
 445                              Register tmp /* = Z_R0 */,
 446                              bool wide    /* = false */) {
 447   assert(wide || Immediate::is_simm32(mask), &quot;mask value too large&quot;);
 448 
 449   if (!wide) {
 450     z_nilf(r, mask);
 451     return;
 452   }
 453 
 454   assert(r != tmp, &quot; need a different temporary register !&quot;);
 455   load_const_optimized(tmp, mask);
 456   z_ngr(r, tmp);
 457 }
 458 
 459 // Calculate the 1&#39;s complement.
 460 // Note: The condition code is neither preserved nor correctly set by this code!!!
 461 // Note: (wide == false) does not protect the high order half of the target register
 462 //       from alteration. It only serves as optimization hint for 32-bit results.
 463 void MacroAssembler::not_(Register r1, Register r2, bool wide) {
 464 
 465   if ((r2 == noreg) || (r2 == r1)) { // Calc 1&#39;s complement in place.
 466     z_xilf(r1, -1);
 467     if (wide) {
 468       z_xihf(r1, -1);
 469     }
 470   } else { // Distinct src and dst registers.
 471     load_const_optimized(r1, -1);
 472     z_xgr(r1, r2);
 473   }
 474 }
 475 
 476 unsigned long MacroAssembler::create_mask(int lBitPos, int rBitPos) {
 477   assert(lBitPos &gt;=  0,      &quot;zero is  leftmost bit position&quot;);
 478   assert(rBitPos &lt;= 63,      &quot;63   is rightmost bit position&quot;);
 479   assert(lBitPos &lt;= rBitPos, &quot;inverted selection interval&quot;);
 480   return (lBitPos == 0 ? (unsigned long)(-1L) : ((1UL&lt;&lt;(63-lBitPos+1))-1)) &amp; (~((1UL&lt;&lt;(63-rBitPos))-1));
 481 }
 482 
 483 // Helper function for the &quot;Rotate_then_&lt;logicalOP&gt;&quot; emitters.
 484 // Rotate src, then mask register contents such that only bits in range survive.
 485 // For oneBits == false, all bits not in range are set to 0. Useful for deleting all bits outside range.
 486 // For oneBits == true,  all bits not in range are set to 1. Useful for preserving all bits outside range.
 487 // The caller must ensure that the selected range only contains bits with defined value.
 488 void MacroAssembler::rotate_then_mask(Register dst, Register src, int lBitPos, int rBitPos,
 489                                       int nRotate, bool src32bit, bool dst32bit, bool oneBits) {
 490   assert(!(dst32bit &amp;&amp; lBitPos &lt; 32), &quot;selection interval out of range for int destination&quot;);
 491   bool sll4rll = (nRotate &gt;= 0) &amp;&amp; (nRotate &lt;= (63-rBitPos)); // Substitute SLL(G) for RLL(G).
 492   bool srl4rll = (nRotate &lt;  0) &amp;&amp; (-nRotate &lt;= lBitPos);     // Substitute SRL(G) for RLL(G).
 493   //  Pre-determine which parts of dst will be zero after shift/rotate.
 494   bool llZero  =  sll4rll &amp;&amp; (nRotate &gt;= 16);
 495   bool lhZero  = (sll4rll &amp;&amp; (nRotate &gt;= 32)) || (srl4rll &amp;&amp; (nRotate &lt;= -48));
 496   bool lfZero  = llZero &amp;&amp; lhZero;
 497   bool hlZero  = (sll4rll &amp;&amp; (nRotate &gt;= 48)) || (srl4rll &amp;&amp; (nRotate &lt;= -32));
 498   bool hhZero  =                                 (srl4rll &amp;&amp; (nRotate &lt;= -16));
 499   bool hfZero  = hlZero &amp;&amp; hhZero;
 500 
 501   // rotate then mask src operand.
 502   // if oneBits == true,  all bits outside selected range are 1s.
 503   // if oneBits == false, all bits outside selected range are 0s.
 504   if (src32bit) {   // There might be garbage in the upper 32 bits which will get masked away.
 505     if (dst32bit) {
 506       z_rll(dst, src, nRotate);   // Copy and rotate, upper half of reg remains undisturbed.
 507     } else {
 508       if      (sll4rll) { z_sllg(dst, src,  nRotate); }
 509       else if (srl4rll) { z_srlg(dst, src, -nRotate); }
 510       else              { z_rllg(dst, src,  nRotate); }
 511     }
 512   } else {
 513     if      (sll4rll) { z_sllg(dst, src,  nRotate); }
 514     else if (srl4rll) { z_srlg(dst, src, -nRotate); }
 515     else              { z_rllg(dst, src,  nRotate); }
 516   }
 517 
 518   unsigned long  range_mask    = create_mask(lBitPos, rBitPos);
 519   unsigned int   range_mask_h  = (unsigned int)(range_mask &gt;&gt; 32);
 520   unsigned int   range_mask_l  = (unsigned int)range_mask;
 521   unsigned short range_mask_hh = (unsigned short)(range_mask &gt;&gt; 48);
 522   unsigned short range_mask_hl = (unsigned short)(range_mask &gt;&gt; 32);
 523   unsigned short range_mask_lh = (unsigned short)(range_mask &gt;&gt; 16);
 524   unsigned short range_mask_ll = (unsigned short)range_mask;
 525   // Works for z9 and newer H/W.
 526   if (oneBits) {
 527     if ((~range_mask_l) != 0)                { z_oilf(dst, ~range_mask_l); } // All bits outside range become 1s.
 528     if (((~range_mask_h) != 0) &amp;&amp; !dst32bit) { z_oihf(dst, ~range_mask_h); }
 529   } else {
 530     // All bits outside range become 0s
 531     if (((~range_mask_l) != 0) &amp;&amp;              !lfZero) {
 532       z_nilf(dst, range_mask_l);
 533     }
 534     if (((~range_mask_h) != 0) &amp;&amp; !dst32bit &amp;&amp; !hfZero) {
 535       z_nihf(dst, range_mask_h);
 536     }
 537   }
 538 }
 539 
 540 // Rotate src, then insert selected range from rotated src into dst.
 541 // Clear dst before, if requested.
 542 void MacroAssembler::rotate_then_insert(Register dst, Register src, int lBitPos, int rBitPos,
 543                                         int nRotate, bool clear_dst) {
 544   // This version does not depend on src being zero-extended int2long.
 545   nRotate &amp;= 0x003f;                                       // For risbg, pretend it&#39;s an unsigned value.
 546   z_risbg(dst, src, lBitPos, rBitPos, nRotate, clear_dst); // Rotate, then insert selected, clear the rest.
 547 }
 548 
 549 // Rotate src, then and selected range from rotated src into dst.
 550 // Set condition code only if so requested. Otherwise it is unpredictable.
 551 // See performance note in macroAssembler_s390.hpp for important information.
 552 void MacroAssembler::rotate_then_and(Register dst, Register src, int lBitPos, int rBitPos,
 553                                      int nRotate, bool test_only) {
 554   guarantee(!test_only, &quot;Emitter not fit for test_only instruction variant.&quot;);
 555   // This version does not depend on src being zero-extended int2long.
 556   nRotate &amp;= 0x003f;                                       // For risbg, pretend it&#39;s an unsigned value.
 557   z_rxsbg(dst, src, lBitPos, rBitPos, nRotate, test_only); // Rotate, then xor selected.
 558 }
 559 
 560 // Rotate src, then or selected range from rotated src into dst.
 561 // Set condition code only if so requested. Otherwise it is unpredictable.
 562 // See performance note in macroAssembler_s390.hpp for important information.
 563 void MacroAssembler::rotate_then_or(Register dst, Register src,  int  lBitPos,  int  rBitPos,
 564                                     int nRotate, bool test_only) {
 565   guarantee(!test_only, &quot;Emitter not fit for test_only instruction variant.&quot;);
 566   // This version does not depend on src being zero-extended int2long.
 567   nRotate &amp;= 0x003f;                                       // For risbg, pretend it&#39;s an unsigned value.
 568   z_rosbg(dst, src, lBitPos, rBitPos, nRotate, test_only); // Rotate, then xor selected.
 569 }
 570 
 571 // Rotate src, then xor selected range from rotated src into dst.
 572 // Set condition code only if so requested. Otherwise it is unpredictable.
 573 // See performance note in macroAssembler_s390.hpp for important information.
 574 void MacroAssembler::rotate_then_xor(Register dst, Register src,  int  lBitPos,  int  rBitPos,
 575                                      int nRotate, bool test_only) {
 576   guarantee(!test_only, &quot;Emitter not fit for test_only instruction variant.&quot;);
 577     // This version does not depend on src being zero-extended int2long.
 578   nRotate &amp;= 0x003f;                                       // For risbg, pretend it&#39;s an unsigned value.
 579   z_rxsbg(dst, src, lBitPos, rBitPos, nRotate, test_only); // Rotate, then xor selected.
 580 }
 581 
 582 void MacroAssembler::add64(Register r1, RegisterOrConstant inc) {
 583   if (inc.is_register()) {
 584     z_agr(r1, inc.as_register());
 585   } else { // constant
 586     intptr_t imm = inc.as_constant();
 587     add2reg(r1, imm);
 588   }
 589 }
 590 // Helper function to multiply the 64bit contents of a register by a 16bit constant.
 591 // The optimization tries to avoid the mghi instruction, since it uses the FPU for
 592 // calculation and is thus rather slow.
 593 //
 594 // There is no handling for special cases, e.g. cval==0 or cval==1.
 595 //
 596 // Returns len of generated code block.
 597 unsigned int MacroAssembler::mul_reg64_const16(Register rval, Register work, int cval) {
 598   int block_start = offset();
 599 
 600   bool sign_flip = cval &lt; 0;
 601   cval = sign_flip ? -cval : cval;
 602 
 603   BLOCK_COMMENT(&quot;Reg64*Con16 {&quot;);
 604 
 605   int bit1 = cval &amp; -cval;
 606   if (bit1 == cval) {
 607     z_sllg(rval, rval, exact_log2(bit1));
 608     if (sign_flip) { z_lcgr(rval, rval); }
 609   } else {
 610     int bit2 = (cval-bit1) &amp; -(cval-bit1);
 611     if ((bit1+bit2) == cval) {
 612       z_sllg(work, rval, exact_log2(bit1));
 613       z_sllg(rval, rval, exact_log2(bit2));
 614       z_agr(rval, work);
 615       if (sign_flip) { z_lcgr(rval, rval); }
 616     } else {
 617       if (sign_flip) { z_mghi(rval, -cval); }
 618       else           { z_mghi(rval,  cval); }
 619     }
 620   }
 621   BLOCK_COMMENT(&quot;} Reg64*Con16&quot;);
 622 
 623   int block_end = offset();
 624   return block_end - block_start;
 625 }
 626 
 627 // Generic operation r1 := r2 + imm.
 628 //
 629 // Should produce the best code for each supported CPU version.
 630 // r2 == noreg yields r1 := r1 + imm
 631 // imm == 0 emits either no instruction or r1 := r2 !
 632 // NOTES: 1) Don&#39;t use this function where fixed sized
 633 //           instruction sequences are required!!!
 634 //        2) Don&#39;t use this function if condition code
 635 //           setting is required!
 636 //        3) Despite being declared as int64_t, the parameter imm
 637 //           must be a simm_32 value (= signed 32-bit integer).
 638 void MacroAssembler::add2reg(Register r1, int64_t imm, Register r2) {
 639   assert(Immediate::is_simm32(imm), &quot;probably an implicit conversion went wrong&quot;);
 640 
 641   if (r2 == noreg) { r2 = r1; }
 642 
 643   // Handle special case imm == 0.
 644   if (imm == 0) {
 645     lgr_if_needed(r1, r2);
 646     // Nothing else to do.
 647     return;
 648   }
 649 
 650   if (!PreferLAoverADD || (r2 == Z_R0)) {
 651     bool distinctOpnds = VM_Version::has_DistinctOpnds();
 652 
 653     // Can we encode imm in 16 bits signed?
 654     if (Immediate::is_simm16(imm)) {
 655       if (r1 == r2) {
 656         z_aghi(r1, imm);
 657         return;
 658       }
 659       if (distinctOpnds) {
 660         z_aghik(r1, r2, imm);
 661         return;
 662       }
 663       z_lgr(r1, r2);
 664       z_aghi(r1, imm);
 665       return;
 666     }
 667   } else {
 668     // Can we encode imm in 12 bits unsigned?
 669     if (Displacement::is_shortDisp(imm)) {
 670       z_la(r1, imm, r2);
 671       return;
 672     }
 673     // Can we encode imm in 20 bits signed?
 674     if (Displacement::is_validDisp(imm)) {
 675       // Always use LAY instruction, so we don&#39;t need the tmp register.
 676       z_lay(r1, imm, r2);
 677       return;
 678     }
 679 
 680   }
 681 
 682   // Can handle it (all possible values) with long immediates.
 683   lgr_if_needed(r1, r2);
 684   z_agfi(r1, imm);
 685 }
 686 
 687 // Generic operation r := b + x + d
 688 //
 689 // Addition of several operands with address generation semantics - sort of:
 690 //  - no restriction on the registers. Any register will do for any operand.
 691 //  - x == noreg: operand will be disregarded.
 692 //  - b == noreg: will use (contents of) result reg as operand (r := r + d).
 693 //  - x == Z_R0:  just disregard
 694 //  - b == Z_R0:  use as operand. This is not address generation semantics!!!
 695 //
 696 // The same restrictions as on add2reg() are valid!!!
 697 void MacroAssembler::add2reg_with_index(Register r, int64_t d, Register x, Register b) {
 698   assert(Immediate::is_simm32(d), &quot;probably an implicit conversion went wrong&quot;);
 699 
 700   if (x == noreg) { x = Z_R0; }
 701   if (b == noreg) { b = r; }
 702 
 703   // Handle special case x == R0.
 704   if (x == Z_R0) {
 705     // Can simply add the immediate value to the base register.
 706     add2reg(r, d, b);
 707     return;
 708   }
 709 
 710   if (!PreferLAoverADD || (b == Z_R0)) {
 711     bool distinctOpnds = VM_Version::has_DistinctOpnds();
 712     // Handle special case d == 0.
 713     if (d == 0) {
 714       if (b == x)        { z_sllg(r, b, 1); return; }
 715       if (r == x)        { z_agr(r, b);     return; }
 716       if (r == b)        { z_agr(r, x);     return; }
 717       if (distinctOpnds) { z_agrk(r, x, b); return; }
 718       z_lgr(r, b);
 719       z_agr(r, x);
 720     } else {
 721       if (x == b)             { z_sllg(r, x, 1); }
 722       else if (r == x)        { z_agr(r, b); }
 723       else if (r == b)        { z_agr(r, x); }
 724       else if (distinctOpnds) { z_agrk(r, x, b); }
 725       else {
 726         z_lgr(r, b);
 727         z_agr(r, x);
 728       }
 729       add2reg(r, d);
 730     }
 731   } else {
 732     // Can we encode imm in 12 bits unsigned?
 733     if (Displacement::is_shortDisp(d)) {
 734       z_la(r, d, x, b);
 735       return;
 736     }
 737     // Can we encode imm in 20 bits signed?
 738     if (Displacement::is_validDisp(d)) {
 739       z_lay(r, d, x, b);
 740       return;
 741     }
 742     z_la(r, 0, x, b);
 743     add2reg(r, d);
 744   }
 745 }
 746 
 747 // Generic emitter (32bit) for direct memory increment.
 748 // For optimal code, do not specify Z_R0 as temp register.
 749 void MacroAssembler::add2mem_32(const Address &amp;a, int64_t imm, Register tmp) {
 750   if (VM_Version::has_MemWithImmALUOps() &amp;&amp; Immediate::is_simm8(imm)) {
 751     z_asi(a, imm);
 752   } else {
 753     z_lgf(tmp, a);
 754     add2reg(tmp, imm);
 755     z_st(tmp, a);
 756   }
 757 }
 758 
 759 void MacroAssembler::add2mem_64(const Address &amp;a, int64_t imm, Register tmp) {
 760   if (VM_Version::has_MemWithImmALUOps() &amp;&amp; Immediate::is_simm8(imm)) {
 761     z_agsi(a, imm);
 762   } else {
 763     z_lg(tmp, a);
 764     add2reg(tmp, imm);
 765     z_stg(tmp, a);
 766   }
 767 }
 768 
 769 void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed) {
 770   switch (size_in_bytes) {
 771     case  8: z_lg(dst, src); break;
 772     case  4: is_signed ? z_lgf(dst, src) : z_llgf(dst, src); break;
 773     case  2: is_signed ? z_lgh(dst, src) : z_llgh(dst, src); break;
 774     case  1: is_signed ? z_lgb(dst, src) : z_llgc(dst, src); break;
 775     default: ShouldNotReachHere();
 776   }
 777 }
 778 
 779 void MacroAssembler::store_sized_value(Register src, Address dst, size_t size_in_bytes) {
 780   switch (size_in_bytes) {
 781     case  8: z_stg(src, dst); break;
 782     case  4: z_st(src, dst); break;
 783     case  2: z_sth(src, dst); break;
 784     case  1: z_stc(src, dst); break;
 785     default: ShouldNotReachHere();
 786   }
 787 }
 788 
 789 // Split a si20 offset (20bit, signed) into an ui12 offset (12bit, unsigned) and
 790 // a high-order summand in register tmp.
 791 //
 792 // return value: &lt;  0: No split required, si20 actually has property uimm12.
 793 //               &gt;= 0: Split performed. Use return value as uimm12 displacement and
 794 //                     tmp as index register.
 795 int MacroAssembler::split_largeoffset(int64_t si20_offset, Register tmp, bool fixed_codelen, bool accumulate) {
 796   assert(Immediate::is_simm20(si20_offset), &quot;sanity&quot;);
 797   int lg_off = (int)si20_offset &amp;  0x0fff; // Punch out low-order 12 bits, always positive.
 798   int ll_off = (int)si20_offset &amp; ~0x0fff; // Force low-order 12 bits to zero.
 799   assert((Displacement::is_shortDisp(si20_offset) &amp;&amp; (ll_off == 0)) ||
 800          !Displacement::is_shortDisp(si20_offset), &quot;unexpected offset values&quot;);
 801   assert((lg_off+ll_off) == si20_offset, &quot;offset splitup error&quot;);
 802 
 803   Register work = accumulate? Z_R0 : tmp;
 804 
 805   if (fixed_codelen) {          // Len of code = 10 = 4 + 6.
 806     z_lghi(work, ll_off&gt;&gt;12);   // Implicit sign extension.
 807     z_slag(work, work, 12);
 808   } else {                      // Len of code = 0..10.
 809     if (ll_off == 0) { return -1; }
 810     // ll_off has 8 significant bits (at most) plus sign.
 811     if ((ll_off &amp; 0x0000f000) == 0) {    // Non-zero bits only in upper halfbyte.
 812       z_llilh(work, ll_off &gt;&gt; 16);
 813       if (ll_off &lt; 0) {                  // Sign-extension required.
 814         z_lgfr(work, work);
 815       }
 816     } else {
 817       if ((ll_off &amp; 0x000f0000) == 0) {  // Non-zero bits only in lower halfbyte.
 818         z_llill(work, ll_off);
 819       } else {                           // Non-zero bits in both halfbytes.
 820         z_lghi(work, ll_off&gt;&gt;12);        // Implicit sign extension.
 821         z_slag(work, work, 12);
 822       }
 823     }
 824   }
 825   if (accumulate) { z_algr(tmp, work); } // len of code += 4
 826   return lg_off;
 827 }
 828 
 829 void MacroAssembler::load_float_largeoffset(FloatRegister t, int64_t si20, Register a, Register tmp) {
 830   if (Displacement::is_validDisp(si20)) {
 831     z_ley(t, si20, a);
 832   } else {
 833     // Fixed_codelen = true is a simple way to ensure that the size of load_float_largeoffset
 834     // does not depend on si20 (scratch buffer emit size == code buffer emit size for constant
 835     // pool loads).
 836     bool accumulate    = true;
 837     bool fixed_codelen = true;
 838     Register work;
 839 
 840     if (fixed_codelen) {
 841       z_lgr(tmp, a);  // Lgr_if_needed not applicable due to fixed_codelen.
 842     } else {
 843       accumulate = (a == tmp);
 844     }
 845     work = tmp;
 846 
 847     int disp12 = split_largeoffset(si20, work, fixed_codelen, accumulate);
 848     if (disp12 &lt; 0) {
 849       z_le(t, si20, work);
 850     } else {
 851       if (accumulate) {
 852         z_le(t, disp12, work);
 853       } else {
 854         z_le(t, disp12, work, a);
 855       }
 856     }
 857   }
 858 }
 859 
 860 void MacroAssembler::load_double_largeoffset(FloatRegister t, int64_t si20, Register a, Register tmp) {
 861   if (Displacement::is_validDisp(si20)) {
 862     z_ldy(t, si20, a);
 863   } else {
 864     // Fixed_codelen = true is a simple way to ensure that the size of load_double_largeoffset
 865     // does not depend on si20 (scratch buffer emit size == code buffer emit size for constant
 866     // pool loads).
 867     bool accumulate    = true;
 868     bool fixed_codelen = true;
 869     Register work;
 870 
 871     if (fixed_codelen) {
 872       z_lgr(tmp, a);  // Lgr_if_needed not applicable due to fixed_codelen.
 873     } else {
 874       accumulate = (a == tmp);
 875     }
 876     work = tmp;
 877 
 878     int disp12 = split_largeoffset(si20, work, fixed_codelen, accumulate);
 879     if (disp12 &lt; 0) {
 880       z_ld(t, si20, work);
 881     } else {
 882       if (accumulate) {
 883         z_ld(t, disp12, work);
 884       } else {
 885         z_ld(t, disp12, work, a);
 886       }
 887     }
 888   }
 889 }
 890 
 891 // PCrelative TOC access.
 892 // Returns distance (in bytes) from current position to start of consts section.
 893 // Returns 0 (zero) if no consts section exists or if it has size zero.
 894 long MacroAssembler::toc_distance() {
 895   CodeSection* cs = code()-&gt;consts();
 896   return (long)((cs != NULL) ? cs-&gt;start()-pc() : 0);
 897 }
 898 
 899 // Implementation on x86/sparc assumes that constant and instruction section are
 900 // adjacent, but this doesn&#39;t hold. Two special situations may occur, that we must
 901 // be able to handle:
 902 //   1. const section may be located apart from the inst section.
 903 //   2. const section may be empty
 904 // In both cases, we use the const section&#39;s start address to compute the &quot;TOC&quot;,
 905 // this seems to occur only temporarily; in the final step we always seem to end up
 906 // with the pc-relatice variant.
 907 //
 908 // PC-relative offset could be +/-2**32 -&gt; use long for disp
 909 // Furthermore: makes no sense to have special code for
 910 // adjacent const and inst sections.
 911 void MacroAssembler::load_toc(Register Rtoc) {
 912   // Simply use distance from start of const section (should be patched in the end).
 913   long disp = toc_distance();
 914 
 915   RelocationHolder rspec = internal_word_Relocation::spec(pc() + disp);
 916   relocate(rspec);
 917   z_larl(Rtoc, RelAddr::pcrel_off32(disp));  // Offset is in halfwords.
 918 }
 919 
 920 // PCrelative TOC access.
 921 // Load from anywhere pcrelative (with relocation of load instr)
 922 void MacroAssembler::load_long_pcrelative(Register Rdst, address dataLocation) {
 923   address          pc             = this-&gt;pc();
 924   ptrdiff_t        total_distance = dataLocation - pc;
 925   RelocationHolder rspec          = internal_word_Relocation::spec(dataLocation);
 926 
 927   assert((total_distance &amp; 0x01L) == 0, &quot;halfword alignment is mandatory&quot;);
 928   assert(total_distance != 0, &quot;sanity&quot;);
 929 
 930   // Some extra safety net.
 931   if (!RelAddr::is_in_range_of_RelAddr32(total_distance)) {
 932     guarantee(RelAddr::is_in_range_of_RelAddr32(total_distance), &quot;load_long_pcrelative can&#39;t handle distance &quot; INTPTR_FORMAT, total_distance);
 933   }
 934 
 935   (this)-&gt;relocate(rspec, relocInfo::pcrel_addr_format);
 936   z_lgrl(Rdst, RelAddr::pcrel_off32(total_distance));
 937 }
 938 
 939 
 940 // PCrelative TOC access.
 941 // Load from anywhere pcrelative (with relocation of load instr)
 942 // loaded addr has to be relocated when added to constant pool.
 943 void MacroAssembler::load_addr_pcrelative(Register Rdst, address addrLocation) {
 944   address          pc             = this-&gt;pc();
 945   ptrdiff_t        total_distance = addrLocation - pc;
 946   RelocationHolder rspec          = internal_word_Relocation::spec(addrLocation);
 947 
 948   assert((total_distance &amp; 0x01L) == 0, &quot;halfword alignment is mandatory&quot;);
 949 
 950   // Some extra safety net.
 951   if (!RelAddr::is_in_range_of_RelAddr32(total_distance)) {
 952     guarantee(RelAddr::is_in_range_of_RelAddr32(total_distance), &quot;load_long_pcrelative can&#39;t handle distance &quot; INTPTR_FORMAT, total_distance);
 953   }
 954 
 955   (this)-&gt;relocate(rspec, relocInfo::pcrel_addr_format);
 956   z_lgrl(Rdst, RelAddr::pcrel_off32(total_distance));
 957 }
 958 
 959 // Generic operation: load a value from memory and test.
 960 // CondCode indicates the sign (&lt;0, ==0, &gt;0) of the loaded value.
 961 void MacroAssembler::load_and_test_byte(Register dst, const Address &amp;a) {
 962   z_lb(dst, a);
 963   z_ltr(dst, dst);
 964 }
 965 
 966 void MacroAssembler::load_and_test_short(Register dst, const Address &amp;a) {
 967   int64_t disp = a.disp20();
 968   if (Displacement::is_shortDisp(disp)) {
 969     z_lh(dst, a);
 970   } else if (Displacement::is_longDisp(disp)) {
 971     z_lhy(dst, a);
 972   } else {
 973     guarantee(false, &quot;displacement out of range&quot;);
 974   }
 975   z_ltr(dst, dst);
 976 }
 977 
 978 void MacroAssembler::load_and_test_int(Register dst, const Address &amp;a) {
 979   z_lt(dst, a);
 980 }
 981 
 982 void MacroAssembler::load_and_test_int2long(Register dst, const Address &amp;a) {
 983   z_ltgf(dst, a);
 984 }
 985 
 986 void MacroAssembler::load_and_test_long(Register dst, const Address &amp;a) {
 987   z_ltg(dst, a);
 988 }
 989 
 990 // Test a bit in memory.
 991 void MacroAssembler::testbit(const Address &amp;a, unsigned int bit) {
 992   assert(a.index() == noreg, &quot;no index reg allowed in testbit&quot;);
 993   if (bit &lt;= 7) {
 994     z_tm(a.disp() + 3, a.base(), 1 &lt;&lt; bit);
 995   } else if (bit &lt;= 15) {
 996     z_tm(a.disp() + 2, a.base(), 1 &lt;&lt; (bit - 8));
 997   } else if (bit &lt;= 23) {
 998     z_tm(a.disp() + 1, a.base(), 1 &lt;&lt; (bit - 16));
 999   } else if (bit &lt;= 31) {
1000     z_tm(a.disp() + 0, a.base(), 1 &lt;&lt; (bit - 24));
1001   } else {
1002     ShouldNotReachHere();
1003   }
1004 }
1005 
1006 // Test a bit in a register. Result is reflected in CC.
1007 void MacroAssembler::testbit(Register r, unsigned int bitPos) {
1008   if (bitPos &lt; 16) {
1009     z_tmll(r, 1U&lt;&lt;bitPos);
1010   } else if (bitPos &lt; 32) {
1011     z_tmlh(r, 1U&lt;&lt;(bitPos-16));
1012   } else if (bitPos &lt; 48) {
1013     z_tmhl(r, 1U&lt;&lt;(bitPos-32));
1014   } else if (bitPos &lt; 64) {
1015     z_tmhh(r, 1U&lt;&lt;(bitPos-48));
1016   } else {
1017     ShouldNotReachHere();
1018   }
1019 }
1020 
1021 void MacroAssembler::prefetch_read(Address a) {
1022   z_pfd(1, a.disp20(), a.indexOrR0(), a.base());
1023 }
1024 void MacroAssembler::prefetch_update(Address a) {
1025   z_pfd(2, a.disp20(), a.indexOrR0(), a.base());
1026 }
1027 
1028 // Clear a register, i.e. load const zero into reg.
1029 // Return len (in bytes) of generated instruction(s).
1030 // whole_reg: Clear 64 bits if true, 32 bits otherwise.
1031 // set_cc:    Use instruction that sets the condition code, if true.
1032 int MacroAssembler::clear_reg(Register r, bool whole_reg, bool set_cc) {
1033   unsigned int start_off = offset();
1034   if (whole_reg) {
1035     set_cc ? z_xgr(r, r) : z_laz(r, 0, Z_R0);
1036   } else {  // Only 32bit register.
1037     set_cc ? z_xr(r, r) : z_lhi(r, 0);
1038   }
1039   return offset() - start_off;
1040 }
1041 
1042 #ifdef ASSERT
1043 int MacroAssembler::preset_reg(Register r, unsigned long pattern, int pattern_len) {
1044   switch (pattern_len) {
1045     case 1:
1046       pattern = (pattern &amp; 0x000000ff)  | ((pattern &amp; 0x000000ff)&lt;&lt;8);
1047     case 2:
1048       pattern = (pattern &amp; 0x0000ffff)  | ((pattern &amp; 0x0000ffff)&lt;&lt;16);
1049     case 4:
1050       pattern = (pattern &amp; 0xffffffffL) | ((pattern &amp; 0xffffffffL)&lt;&lt;32);
1051     case 8:
1052       return load_const_optimized_rtn_len(r, pattern, true);
1053       break;
1054     default:
1055       guarantee(false, &quot;preset_reg: bad len&quot;);
1056   }
1057   return 0;
1058 }
1059 #endif
1060 
1061 // addr: Address descriptor of memory to clear index register will not be used !
1062 // size: Number of bytes to clear.
1063 //    !!! DO NOT USE THEM FOR ATOMIC MEMORY CLEARING !!!
1064 //    !!! Use store_const() instead                  !!!
1065 void MacroAssembler::clear_mem(const Address&amp; addr, unsigned size) {
1066   guarantee(size &lt;= 256, &quot;MacroAssembler::clear_mem: size too large&quot;);
1067 
1068   if (size == 1) {
1069     z_mvi(addr, 0);
1070     return;
1071   }
1072 
1073   switch (size) {
1074     case 2: z_mvhhi(addr, 0);
1075       return;
1076     case 4: z_mvhi(addr, 0);
1077       return;
1078     case 8: z_mvghi(addr, 0);
1079       return;
1080     default: ; // Fallthru to xc.
1081   }
1082 
1083   z_xc(addr, size, addr);
1084 }
1085 
1086 void MacroAssembler::align(int modulus) {
1087   while (offset() % modulus != 0) z_nop();
1088 }
1089 
1090 // Special version for non-relocateable code if required alignment
1091 // is larger than CodeEntryAlignment.
1092 void MacroAssembler::align_address(int modulus) {
1093   while ((uintptr_t)pc() % modulus != 0) z_nop();
1094 }
1095 
1096 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
1097                                          Register temp_reg,
1098                                          int64_t extra_slot_offset) {
1099   // On Z, we can have index and disp in an Address. So don&#39;t call argument_offset,
1100   // which issues an unnecessary add instruction.
1101   int stackElementSize = Interpreter::stackElementSize;
1102   int64_t offset = extra_slot_offset * stackElementSize;
1103   const Register argbase = Z_esp;
1104   if (arg_slot.is_constant()) {
1105     offset += arg_slot.as_constant() * stackElementSize;
1106     return Address(argbase, offset);
1107   }
1108   // else
1109   assert(temp_reg != noreg, &quot;must specify&quot;);
1110   assert(temp_reg != Z_ARG1, &quot;base and index are conflicting&quot;);
1111   z_sllg(temp_reg, arg_slot.as_register(), exact_log2(stackElementSize)); // tempreg = arg_slot &lt;&lt; 3
1112   return Address(argbase, temp_reg, offset);
1113 }
1114 
1115 
1116 //===================================================================
1117 //===   START   C O N S T A N T S   I N   C O D E   S T R E A M   ===
1118 //===================================================================
1119 //===            P A T CH A B L E   C O N S T A N T S             ===
1120 //===================================================================
1121 
1122 
1123 //---------------------------------------------------
1124 //  Load (patchable) constant into register
1125 //---------------------------------------------------
1126 
1127 
1128 // Load absolute address (and try to optimize).
1129 //   Note: This method is usable only for position-fixed code,
1130 //         referring to a position-fixed target location.
1131 //         If not so, relocations and patching must be used.
1132 void MacroAssembler::load_absolute_address(Register d, address addr) {
1133   assert(addr != NULL, &quot;should not happen&quot;);
1134   BLOCK_COMMENT(&quot;load_absolute_address:&quot;);
1135   if (addr == NULL) {
1136     z_larl(d, pc()); // Dummy emit for size calc.
1137     return;
1138   }
1139 
1140   if (RelAddr::is_in_range_of_RelAddr32(addr, pc())) {
1141     z_larl(d, addr);
1142     return;
1143   }
1144 
1145   load_const_optimized(d, (long)addr);
1146 }
1147 
1148 // Load a 64bit constant.
1149 // Patchable code sequence, but not atomically patchable.
1150 // Make sure to keep code size constant -&gt; no value-dependent optimizations.
1151 // Do not kill condition code.
1152 void MacroAssembler::load_const(Register t, long x) {
1153   // Note: Right shift is only cleanly defined for unsigned types
1154   //       or for signed types with nonnegative values.
1155   Assembler::z_iihf(t, (long)((unsigned long)x &gt;&gt; 32));
1156   Assembler::z_iilf(t, (long)((unsigned long)x &amp; 0xffffffffUL));
1157 }
1158 
1159 // Load a 32bit constant into a 64bit register, sign-extend or zero-extend.
1160 // Patchable code sequence, but not atomically patchable.
1161 // Make sure to keep code size constant -&gt; no value-dependent optimizations.
1162 // Do not kill condition code.
1163 void MacroAssembler::load_const_32to64(Register t, int64_t x, bool sign_extend) {
1164   if (sign_extend) { Assembler::z_lgfi(t, x); }
1165   else             { Assembler::z_llilf(t, x); }
1166 }
1167 
1168 // Load narrow oop constant, no decompression.
1169 void MacroAssembler::load_narrow_oop(Register t, narrowOop a) {
1170   assert(UseCompressedOops, &quot;must be on to call this method&quot;);
1171   load_const_32to64(t, a, false /*sign_extend*/);
1172 }
1173 
1174 // Load narrow klass constant, compression required.
1175 void MacroAssembler::load_narrow_klass(Register t, Klass* k) {
1176   assert(UseCompressedClassPointers, &quot;must be on to call this method&quot;);
1177   narrowKlass encoded_k = CompressedKlassPointers::encode(k);
1178   load_const_32to64(t, encoded_k, false /*sign_extend*/);
1179 }
1180 
1181 //------------------------------------------------------
1182 //  Compare (patchable) constant with register.
1183 //------------------------------------------------------
1184 
1185 // Compare narrow oop in reg with narrow oop constant, no decompression.
1186 void MacroAssembler::compare_immediate_narrow_oop(Register oop1, narrowOop oop2) {
1187   assert(UseCompressedOops, &quot;must be on to call this method&quot;);
1188 
1189   Assembler::z_clfi(oop1, oop2);
1190 }
1191 
1192 // Compare narrow oop in reg with narrow oop constant, no decompression.
1193 void MacroAssembler::compare_immediate_narrow_klass(Register klass1, Klass* klass2) {
1194   assert(UseCompressedClassPointers, &quot;must be on to call this method&quot;);
1195   narrowKlass encoded_k = CompressedKlassPointers::encode(klass2);
1196 
1197   Assembler::z_clfi(klass1, encoded_k);
1198 }
1199 
1200 //----------------------------------------------------------
1201 //  Check which kind of load_constant we have here.
1202 //----------------------------------------------------------
1203 
1204 // Detection of CPU version dependent load_const sequence.
1205 // The detection is valid only for code sequences generated by load_const,
1206 // not load_const_optimized.
1207 bool MacroAssembler::is_load_const(address a) {
1208   unsigned long inst1, inst2;
1209   unsigned int  len1,  len2;
1210 
1211   len1 = get_instruction(a, &amp;inst1);
1212   len2 = get_instruction(a + len1, &amp;inst2);
1213 
1214   return is_z_iihf(inst1) &amp;&amp; is_z_iilf(inst2);
1215 }
1216 
1217 // Detection of CPU version dependent load_const_32to64 sequence.
1218 // Mostly used for narrow oops and narrow Klass pointers.
1219 // The detection is valid only for code sequences generated by load_const_32to64.
1220 bool MacroAssembler::is_load_const_32to64(address pos) {
1221   unsigned long inst1, inst2;
1222   unsigned int len1;
1223 
1224   len1 = get_instruction(pos, &amp;inst1);
1225   return is_z_llilf(inst1);
1226 }
1227 
1228 // Detection of compare_immediate_narrow sequence.
1229 // The detection is valid only for code sequences generated by compare_immediate_narrow_oop.
1230 bool MacroAssembler::is_compare_immediate32(address pos) {
1231   return is_equal(pos, CLFI_ZOPC, RIL_MASK);
1232 }
1233 
1234 // Detection of compare_immediate_narrow sequence.
1235 // The detection is valid only for code sequences generated by compare_immediate_narrow_oop.
1236 bool MacroAssembler::is_compare_immediate_narrow_oop(address pos) {
1237   return is_compare_immediate32(pos);
1238   }
1239 
1240 // Detection of compare_immediate_narrow sequence.
1241 // The detection is valid only for code sequences generated by compare_immediate_narrow_klass.
1242 bool MacroAssembler::is_compare_immediate_narrow_klass(address pos) {
1243   return is_compare_immediate32(pos);
1244 }
1245 
1246 //-----------------------------------
1247 //  patch the load_constant
1248 //-----------------------------------
1249 
1250 // CPU-version dependend patching of load_const.
1251 void MacroAssembler::patch_const(address a, long x) {
1252   assert(is_load_const(a), &quot;not a load of a constant&quot;);
1253   // Note: Right shift is only cleanly defined for unsigned types
1254   //       or for signed types with nonnegative values.
1255   set_imm32((address)a, (long)((unsigned long)x &gt;&gt; 32));
1256   set_imm32((address)(a + 6), (long)((unsigned long)x &amp; 0xffffffffUL));
1257 }
1258 
1259 // Patching the value of CPU version dependent load_const_32to64 sequence.
1260 // The passed ptr MUST be in compressed format!
1261 int MacroAssembler::patch_load_const_32to64(address pos, int64_t np) {
1262   assert(is_load_const_32to64(pos), &quot;not a load of a narrow ptr (oop or klass)&quot;);
1263 
1264   set_imm32(pos, np);
1265   return 6;
1266 }
1267 
1268 // Patching the value of CPU version dependent compare_immediate_narrow sequence.
1269 // The passed ptr MUST be in compressed format!
1270 int MacroAssembler::patch_compare_immediate_32(address pos, int64_t np) {
1271   assert(is_compare_immediate32(pos), &quot;not a compressed ptr compare&quot;);
1272 
1273   set_imm32(pos, np);
1274   return 6;
1275 }
1276 
1277 // Patching the immediate value of CPU version dependent load_narrow_oop sequence.
1278 // The passed ptr must NOT be in compressed format!
1279 int MacroAssembler::patch_load_narrow_oop(address pos, oop o) {
1280   assert(UseCompressedOops, &quot;Can only patch compressed oops&quot;);
1281 
1282   narrowOop no = CompressedOops::encode(o);
1283   return patch_load_const_32to64(pos, no);
1284 }
1285 
1286 // Patching the immediate value of CPU version dependent load_narrow_klass sequence.
1287 // The passed ptr must NOT be in compressed format!
1288 int MacroAssembler::patch_load_narrow_klass(address pos, Klass* k) {
1289   assert(UseCompressedClassPointers, &quot;Can only patch compressed klass pointers&quot;);
1290 
1291   narrowKlass nk = CompressedKlassPointers::encode(k);
1292   return patch_load_const_32to64(pos, nk);
1293 }
1294 
1295 // Patching the immediate value of CPU version dependent compare_immediate_narrow_oop sequence.
1296 // The passed ptr must NOT be in compressed format!
1297 int MacroAssembler::patch_compare_immediate_narrow_oop(address pos, oop o) {
1298   assert(UseCompressedOops, &quot;Can only patch compressed oops&quot;);
1299 
1300   narrowOop no = CompressedOops::encode(o);
1301   return patch_compare_immediate_32(pos, no);
1302 }
1303 
1304 // Patching the immediate value of CPU version dependent compare_immediate_narrow_klass sequence.
1305 // The passed ptr must NOT be in compressed format!
1306 int MacroAssembler::patch_compare_immediate_narrow_klass(address pos, Klass* k) {
1307   assert(UseCompressedClassPointers, &quot;Can only patch compressed klass pointers&quot;);
1308 
1309   narrowKlass nk = CompressedKlassPointers::encode(k);
1310   return patch_compare_immediate_32(pos, nk);
1311 }
1312 
1313 //------------------------------------------------------------------------
1314 //  Extract the constant from a load_constant instruction stream.
1315 //------------------------------------------------------------------------
1316 
1317 // Get constant from a load_const sequence.
1318 long MacroAssembler::get_const(address a) {
1319   assert(is_load_const(a), &quot;not a load of a constant&quot;);
1320   unsigned long x;
1321   x =  (((unsigned long) (get_imm32(a,0) &amp; 0xffffffff)) &lt;&lt; 32);
1322   x |= (((unsigned long) (get_imm32(a,1) &amp; 0xffffffff)));
1323   return (long) x;
1324 }
1325 
1326 //--------------------------------------
1327 //  Store a constant in memory.
1328 //--------------------------------------
1329 
1330 // General emitter to move a constant to memory.
1331 // The store is atomic.
1332 //  o Address must be given in RS format (no index register)
1333 //  o Displacement should be 12bit unsigned for efficiency. 20bit signed also supported.
1334 //  o Constant can be 1, 2, 4, or 8 bytes, signed or unsigned.
1335 //  o Memory slot can be 1, 2, 4, or 8 bytes, signed or unsigned.
1336 //  o Memory slot must be at least as wide as constant, will assert otherwise.
1337 //  o Signed constants will sign-extend, unsigned constants will zero-extend to slot width.
1338 int MacroAssembler::store_const(const Address &amp;dest, long imm,
1339                                 unsigned int lm, unsigned int lc,
1340                                 Register scratch) {
1341   int64_t  disp = dest.disp();
1342   Register base = dest.base();
1343   assert(!dest.has_index(), &quot;not supported&quot;);
1344   assert((lm==1)||(lm==2)||(lm==4)||(lm==8), &quot;memory   length not supported&quot;);
1345   assert((lc==1)||(lc==2)||(lc==4)||(lc==8), &quot;constant length not supported&quot;);
1346   assert(lm&gt;=lc, &quot;memory slot too small&quot;);
1347   assert(lc==8 || Immediate::is_simm(imm, lc*8), &quot;const out of range&quot;);
1348   assert(Displacement::is_validDisp(disp), &quot;displacement out of range&quot;);
1349 
1350   bool is_shortDisp = Displacement::is_shortDisp(disp);
1351   int store_offset = -1;
1352 
1353   // For target len == 1 it&#39;s easy.
1354   if (lm == 1) {
1355     store_offset = offset();
1356     if (is_shortDisp) {
1357       z_mvi(disp, base, imm);
1358       return store_offset;
1359     } else {
1360       z_mviy(disp, base, imm);
1361       return store_offset;
1362     }
1363   }
1364 
1365   // All the &quot;good stuff&quot; takes an unsigned displacement.
1366   if (is_shortDisp) {
1367     // NOTE: Cannot use clear_mem for imm==0, because it is not atomic.
1368 
1369     store_offset = offset();
1370     switch (lm) {
1371       case 2:  // Lc == 1 handled correctly here, even for unsigned. Instruction does no widening.
1372         z_mvhhi(disp, base, imm);
1373         return store_offset;
1374       case 4:
1375         if (Immediate::is_simm16(imm)) {
1376           z_mvhi(disp, base, imm);
1377           return store_offset;
1378         }
1379         break;
1380       case 8:
1381         if (Immediate::is_simm16(imm)) {
1382           z_mvghi(disp, base, imm);
1383           return store_offset;
1384         }
1385         break;
1386       default:
1387         ShouldNotReachHere();
1388         break;
1389     }
1390   }
1391 
1392   //  Can&#39;t optimize, so load value and store it.
1393   guarantee(scratch != noreg, &quot; need a scratch register here !&quot;);
1394   if (imm != 0) {
1395     load_const_optimized(scratch, imm);  // Preserves CC anyway.
1396   } else {
1397     // Leave CC alone!!
1398     (void) clear_reg(scratch, true, false); // Indicate unused result.
1399   }
1400 
1401   store_offset = offset();
1402   if (is_shortDisp) {
1403     switch (lm) {
1404       case 2:
1405         z_sth(scratch, disp, Z_R0, base);
1406         return store_offset;
1407       case 4:
1408         z_st(scratch, disp, Z_R0, base);
1409         return store_offset;
1410       case 8:
1411         z_stg(scratch, disp, Z_R0, base);
1412         return store_offset;
1413       default:
1414         ShouldNotReachHere();
1415         break;
1416     }
1417   } else {
1418     switch (lm) {
1419       case 2:
1420         z_sthy(scratch, disp, Z_R0, base);
1421         return store_offset;
1422       case 4:
1423         z_sty(scratch, disp, Z_R0, base);
1424         return store_offset;
1425       case 8:
1426         z_stg(scratch, disp, Z_R0, base);
1427         return store_offset;
1428       default:
1429         ShouldNotReachHere();
1430         break;
1431     }
1432   }
1433   return -1; // should not reach here
1434 }
1435 
1436 //===================================================================
1437 //===       N O T   P A T CH A B L E   C O N S T A N T S          ===
1438 //===================================================================
1439 
1440 // Load constant x into register t with a fast instrcution sequence
1441 // depending on the bits in x. Preserves CC under all circumstances.
1442 int MacroAssembler::load_const_optimized_rtn_len(Register t, long x, bool emit) {
1443   if (x == 0) {
1444     int len;
1445     if (emit) {
1446       len = clear_reg(t, true, false);
1447     } else {
1448       len = 4;
1449     }
1450     return len;
1451   }
1452 
1453   if (Immediate::is_simm16(x)) {
1454     if (emit) { z_lghi(t, x); }
1455     return 4;
1456   }
1457 
1458   // 64 bit value: | part1 | part2 | part3 | part4 |
1459   // At least one part is not zero!
1460   // Note: Right shift is only cleanly defined for unsigned types
1461   //       or for signed types with nonnegative values.
1462   int part1 = (int)((unsigned long)x &gt;&gt; 48) &amp; 0x0000ffff;
1463   int part2 = (int)((unsigned long)x &gt;&gt; 32) &amp; 0x0000ffff;
1464   int part3 = (int)((unsigned long)x &gt;&gt; 16) &amp; 0x0000ffff;
1465   int part4 = (int)x &amp; 0x0000ffff;
1466   int part12 = (int)((unsigned long)x &gt;&gt; 32);
1467   int part34 = (int)x;
1468 
1469   // Lower word only (unsigned).
1470   if (part12 == 0) {
1471     if (part3 == 0) {
1472       if (emit) z_llill(t, part4);
1473       return 4;
1474     }
1475     if (part4 == 0) {
1476       if (emit) z_llilh(t, part3);
1477       return 4;
1478     }
1479     if (emit) z_llilf(t, part34);
1480     return 6;
1481   }
1482 
1483   // Upper word only.
1484   if (part34 == 0) {
1485     if (part1 == 0) {
1486       if (emit) z_llihl(t, part2);
1487       return 4;
1488     }
1489     if (part2 == 0) {
1490       if (emit) z_llihh(t, part1);
1491       return 4;
1492     }
1493     if (emit) z_llihf(t, part12);
1494     return 6;
1495   }
1496 
1497   // Lower word only (signed).
1498   if ((part1 == 0x0000ffff) &amp;&amp; (part2 == 0x0000ffff) &amp;&amp; ((part3 &amp; 0x00008000) != 0)) {
1499     if (emit) z_lgfi(t, part34);
1500     return 6;
1501   }
1502 
1503   int len = 0;
1504 
1505   if ((part1 == 0) || (part2 == 0)) {
1506     if (part1 == 0) {
1507       if (emit) z_llihl(t, part2);
1508       len += 4;
1509     } else {
1510       if (emit) z_llihh(t, part1);
1511       len += 4;
1512     }
1513   } else {
1514     if (emit) z_llihf(t, part12);
1515     len += 6;
1516   }
1517 
1518   if ((part3 == 0) || (part4 == 0)) {
1519     if (part3 == 0) {
1520       if (emit) z_iill(t, part4);
1521       len += 4;
1522     } else {
1523       if (emit) z_iilh(t, part3);
1524       len += 4;
1525     }
1526   } else {
1527     if (emit) z_iilf(t, part34);
1528     len += 6;
1529   }
1530   return len;
1531 }
1532 
1533 //=====================================================================
1534 //===     H I G H E R   L E V E L   B R A N C H   E M I T T E R S   ===
1535 //=====================================================================
1536 
1537 // Note: In the worst case, one of the scratch registers is destroyed!!!
1538 void MacroAssembler::compare32_and_branch(Register r1, RegisterOrConstant x2, branch_condition cond, Label&amp; lbl) {
1539   // Right operand is constant.
1540   if (x2.is_constant()) {
1541     jlong value = x2.as_constant();
1542     compare_and_branch_optimized(r1, value, cond, lbl, /*len64=*/false, /*has_sign=*/true);
1543     return;
1544   }
1545 
1546   // Right operand is in register.
1547   compare_and_branch_optimized(r1, x2.as_register(), cond, lbl, /*len64=*/false, /*has_sign=*/true);
1548 }
1549 
1550 // Note: In the worst case, one of the scratch registers is destroyed!!!
1551 void MacroAssembler::compareU32_and_branch(Register r1, RegisterOrConstant x2, branch_condition cond, Label&amp; lbl) {
1552   // Right operand is constant.
1553   if (x2.is_constant()) {
1554     jlong value = x2.as_constant();
1555     compare_and_branch_optimized(r1, value, cond, lbl, /*len64=*/false, /*has_sign=*/false);
1556     return;
1557   }
1558 
1559   // Right operand is in register.
1560   compare_and_branch_optimized(r1, x2.as_register(), cond, lbl, /*len64=*/false, /*has_sign=*/false);
1561 }
1562 
1563 // Note: In the worst case, one of the scratch registers is destroyed!!!
1564 void MacroAssembler::compare64_and_branch(Register r1, RegisterOrConstant x2, branch_condition cond, Label&amp; lbl) {
1565   // Right operand is constant.
1566   if (x2.is_constant()) {
1567     jlong value = x2.as_constant();
1568     compare_and_branch_optimized(r1, value, cond, lbl, /*len64=*/true, /*has_sign=*/true);
1569     return;
1570   }
1571 
1572   // Right operand is in register.
1573   compare_and_branch_optimized(r1, x2.as_register(), cond, lbl, /*len64=*/true, /*has_sign=*/true);
1574 }
1575 
1576 void MacroAssembler::compareU64_and_branch(Register r1, RegisterOrConstant x2, branch_condition cond, Label&amp; lbl) {
1577   // Right operand is constant.
1578   if (x2.is_constant()) {
1579     jlong value = x2.as_constant();
1580     compare_and_branch_optimized(r1, value, cond, lbl, /*len64=*/true, /*has_sign=*/false);
1581     return;
1582   }
1583 
1584   // Right operand is in register.
1585   compare_and_branch_optimized(r1, x2.as_register(), cond, lbl, /*len64=*/true, /*has_sign=*/false);
1586 }
1587 
1588 // Generate an optimal branch to the branch target.
1589 // Optimal means that a relative branch (brc or brcl) is used if the
1590 // branch distance is short enough. Loading the target address into a
1591 // register and branching via reg is used as fallback only.
1592 //
1593 // Used registers:
1594 //   Z_R1 - work reg. Holds branch target address.
1595 //          Used in fallback case only.
1596 //
1597 // This version of branch_optimized is good for cases where the target address is known
1598 // and constant, i.e. is never changed (no relocation, no patching).
1599 void MacroAssembler::branch_optimized(Assembler::branch_condition cond, address branch_addr) {
1600   address branch_origin = pc();
1601 
1602   if (RelAddr::is_in_range_of_RelAddr16(branch_addr, branch_origin)) {
1603     z_brc(cond, branch_addr);
1604   } else if (RelAddr::is_in_range_of_RelAddr32(branch_addr, branch_origin)) {
1605     z_brcl(cond, branch_addr);
1606   } else {
1607     load_const_optimized(Z_R1, branch_addr);  // CC must not get killed by load_const_optimized.
1608     z_bcr(cond, Z_R1);
1609   }
1610 }
1611 
1612 // This version of branch_optimized is good for cases where the target address
1613 // is potentially not yet known at the time the code is emitted.
1614 //
1615 // One very common case is a branch to an unbound label which is handled here.
1616 // The caller might know (or hope) that the branch distance is short enough
1617 // to be encoded in a 16bit relative address. In this case he will pass a
1618 // NearLabel branch_target.
1619 // Care must be taken with unbound labels. Each call to target(label) creates
1620 // an entry in the patch queue for that label to patch all references of the label
1621 // once it gets bound. Those recorded patch locations must be patchable. Otherwise,
1622 // an assertion fires at patch time.
1623 void MacroAssembler::branch_optimized(Assembler::branch_condition cond, Label&amp; branch_target) {
1624   if (branch_target.is_bound()) {
1625     address branch_addr = target(branch_target);
1626     branch_optimized(cond, branch_addr);
1627   } else if (branch_target.is_near()) {
1628     z_brc(cond, branch_target);  // Caller assures that the target will be in range for z_brc.
1629   } else {
1630     z_brcl(cond, branch_target); // Let&#39;s hope target is in range. Otherwise, we will abort at patch time.
1631   }
1632 }
1633 
1634 // Generate an optimal compare and branch to the branch target.
1635 // Optimal means that a relative branch (clgrj, brc or brcl) is used if the
1636 // branch distance is short enough. Loading the target address into a
1637 // register and branching via reg is used as fallback only.
1638 //
1639 // Input:
1640 //   r1 - left compare operand
1641 //   r2 - right compare operand
1642 void MacroAssembler::compare_and_branch_optimized(Register r1,
1643                                                   Register r2,
1644                                                   Assembler::branch_condition cond,
1645                                                   address  branch_addr,
1646                                                   bool     len64,
1647                                                   bool     has_sign) {
1648   unsigned int casenum = (len64?2:0)+(has_sign?0:1);
1649 
1650   address branch_origin = pc();
1651   if (VM_Version::has_CompareBranch() &amp;&amp; RelAddr::is_in_range_of_RelAddr16(branch_addr, branch_origin)) {
1652     switch (casenum) {
1653       case 0: z_crj( r1, r2, cond, branch_addr); break;
1654       case 1: z_clrj (r1, r2, cond, branch_addr); break;
1655       case 2: z_cgrj(r1, r2, cond, branch_addr); break;
1656       case 3: z_clgrj(r1, r2, cond, branch_addr); break;
1657       default: ShouldNotReachHere(); break;
1658     }
1659   } else {
1660     switch (casenum) {
1661       case 0: z_cr( r1, r2); break;
1662       case 1: z_clr(r1, r2); break;
1663       case 2: z_cgr(r1, r2); break;
1664       case 3: z_clgr(r1, r2); break;
1665       default: ShouldNotReachHere(); break;
1666     }
1667     branch_optimized(cond, branch_addr);
1668   }
1669 }
1670 
1671 // Generate an optimal compare and branch to the branch target.
1672 // Optimal means that a relative branch (clgij, brc or brcl) is used if the
1673 // branch distance is short enough. Loading the target address into a
1674 // register and branching via reg is used as fallback only.
1675 //
1676 // Input:
1677 //   r1 - left compare operand (in register)
1678 //   x2 - right compare operand (immediate)
1679 void MacroAssembler::compare_and_branch_optimized(Register r1,
1680                                                   jlong    x2,
1681                                                   Assembler::branch_condition cond,
1682                                                   Label&amp;   branch_target,
1683                                                   bool     len64,
1684                                                   bool     has_sign) {
1685   address      branch_origin = pc();
1686   bool         x2_imm8       = (has_sign &amp;&amp; Immediate::is_simm8(x2)) || (!has_sign &amp;&amp; Immediate::is_uimm8(x2));
1687   bool         is_RelAddr16  = branch_target.is_near() ||
1688                                (branch_target.is_bound() &amp;&amp;
1689                                 RelAddr::is_in_range_of_RelAddr16(target(branch_target), branch_origin));
1690   unsigned int casenum       = (len64?2:0)+(has_sign?0:1);
1691 
1692   if (VM_Version::has_CompareBranch() &amp;&amp; is_RelAddr16 &amp;&amp; x2_imm8) {
1693     switch (casenum) {
1694       case 0: z_cij( r1, x2, cond, branch_target); break;
1695       case 1: z_clij(r1, x2, cond, branch_target); break;
1696       case 2: z_cgij(r1, x2, cond, branch_target); break;
1697       case 3: z_clgij(r1, x2, cond, branch_target); break;
1698       default: ShouldNotReachHere(); break;
1699     }
1700     return;
1701   }
1702 
1703   if (x2 == 0) {
1704     switch (casenum) {
1705       case 0: z_ltr(r1, r1); break;
1706       case 1: z_ltr(r1, r1); break; // Caution: unsigned test only provides zero/notZero indication!
1707       case 2: z_ltgr(r1, r1); break;
1708       case 3: z_ltgr(r1, r1); break; // Caution: unsigned test only provides zero/notZero indication!
1709       default: ShouldNotReachHere(); break;
1710     }
1711   } else {
1712     if ((has_sign &amp;&amp; Immediate::is_simm16(x2)) || (!has_sign &amp;&amp; Immediate::is_uimm(x2, 15))) {
1713       switch (casenum) {
1714         case 0: z_chi(r1, x2); break;
1715         case 1: z_chi(r1, x2); break; // positive immediate &lt; 2**15
1716         case 2: z_cghi(r1, x2); break;
1717         case 3: z_cghi(r1, x2); break; // positive immediate &lt; 2**15
1718         default: break;
1719       }
1720     } else if ( (has_sign &amp;&amp; Immediate::is_simm32(x2)) || (!has_sign &amp;&amp; Immediate::is_uimm32(x2)) ) {
1721       switch (casenum) {
1722         case 0: z_cfi( r1, x2); break;
1723         case 1: z_clfi(r1, x2); break;
1724         case 2: z_cgfi(r1, x2); break;
1725         case 3: z_clgfi(r1, x2); break;
1726         default: ShouldNotReachHere(); break;
1727       }
1728     } else {
1729       // No instruction with immediate operand possible, so load into register.
1730       Register scratch = (r1 != Z_R0) ? Z_R0 : Z_R1;
1731       load_const_optimized(scratch, x2);
1732       switch (casenum) {
1733         case 0: z_cr( r1, scratch); break;
1734         case 1: z_clr(r1, scratch); break;
1735         case 2: z_cgr(r1, scratch); break;
1736         case 3: z_clgr(r1, scratch); break;
1737         default: ShouldNotReachHere(); break;
1738       }
1739     }
1740   }
1741   branch_optimized(cond, branch_target);
1742 }
1743 
1744 // Generate an optimal compare and branch to the branch target.
1745 // Optimal means that a relative branch (clgrj, brc or brcl) is used if the
1746 // branch distance is short enough. Loading the target address into a
1747 // register and branching via reg is used as fallback only.
1748 //
1749 // Input:
1750 //   r1 - left compare operand
1751 //   r2 - right compare operand
1752 void MacroAssembler::compare_and_branch_optimized(Register r1,
1753                                                   Register r2,
1754                                                   Assembler::branch_condition cond,
1755                                                   Label&amp;   branch_target,
1756                                                   bool     len64,
1757                                                   bool     has_sign) {
1758   unsigned int casenum = (len64 ? 2 : 0) + (has_sign ? 0 : 1);
1759 
1760   if (branch_target.is_bound()) {
1761     address branch_addr = target(branch_target);
1762     compare_and_branch_optimized(r1, r2, cond, branch_addr, len64, has_sign);
1763   } else {
1764     if (VM_Version::has_CompareBranch() &amp;&amp; branch_target.is_near()) {
1765       switch (casenum) {
1766         case 0: z_crj(  r1, r2, cond, branch_target); break;
1767         case 1: z_clrj( r1, r2, cond, branch_target); break;
1768         case 2: z_cgrj( r1, r2, cond, branch_target); break;
1769         case 3: z_clgrj(r1, r2, cond, branch_target); break;
1770         default: ShouldNotReachHere(); break;
1771       }
1772     } else {
1773       switch (casenum) {
1774         case 0: z_cr( r1, r2); break;
1775         case 1: z_clr(r1, r2); break;
1776         case 2: z_cgr(r1, r2); break;
1777         case 3: z_clgr(r1, r2); break;
1778         default: ShouldNotReachHere(); break;
1779       }
1780       branch_optimized(cond, branch_target);
1781     }
1782   }
1783 }
1784 
1785 //===========================================================================
1786 //===   END     H I G H E R   L E V E L   B R A N C H   E M I T T E R S   ===
1787 //===========================================================================
1788 
1789 AddressLiteral MacroAssembler::allocate_metadata_address(Metadata* obj) {
1790   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1791   int index = oop_recorder()-&gt;allocate_metadata_index(obj);
1792   RelocationHolder rspec = metadata_Relocation::spec(index);
1793   return AddressLiteral((address)obj, rspec);
1794 }
1795 
1796 AddressLiteral MacroAssembler::constant_metadata_address(Metadata* obj) {
1797   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1798   int index = oop_recorder()-&gt;find_index(obj);
1799   RelocationHolder rspec = metadata_Relocation::spec(index);
1800   return AddressLiteral((address)obj, rspec);
1801 }
1802 
1803 AddressLiteral MacroAssembler::allocate_oop_address(jobject obj) {
1804   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1805   int oop_index = oop_recorder()-&gt;allocate_oop_index(obj);
1806   return AddressLiteral(address(obj), oop_Relocation::spec(oop_index));
1807 }
1808 
1809 AddressLiteral MacroAssembler::constant_oop_address(jobject obj) {
1810   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1811   int oop_index = oop_recorder()-&gt;find_index(obj);
1812   return AddressLiteral(address(obj), oop_Relocation::spec(oop_index));
1813 }
1814 
1815 // NOTE: destroys r
1816 void MacroAssembler::c2bool(Register r, Register t) {
1817   z_lcr(t, r);   // t = -r
1818   z_or(r, t);    // r = -r OR r
1819   z_srl(r, 31);  // Yields 0 if r was 0, 1 otherwise.
1820 }
1821 
1822 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
1823                                                       Register tmp,
1824                                                       int offset) {
1825   intptr_t value = *delayed_value_addr;
1826   if (value != 0) {
1827     return RegisterOrConstant(value + offset);
1828   }
1829 
1830   BLOCK_COMMENT(&quot;delayed_value {&quot;);
1831   // Load indirectly to solve generation ordering problem.
1832   load_absolute_address(tmp, (address) delayed_value_addr); // tmp = a;
1833   z_lg(tmp, 0, tmp);                   // tmp = *tmp;
1834 
1835 #ifdef ASSERT
1836   NearLabel L;
1837   compare64_and_branch(tmp, (intptr_t)0L, Assembler::bcondNotEqual, L);
1838   z_illtrap();
1839   bind(L);
1840 #endif
1841 
1842   if (offset != 0) {
1843     z_agfi(tmp, offset);               // tmp = tmp + offset;
1844   }
1845 
1846   BLOCK_COMMENT(&quot;} delayed_value&quot;);
1847   return RegisterOrConstant(tmp);
1848 }
1849 
1850 // Patch instruction `inst&#39; at offset `inst_pos&#39; to refer to `dest_pos&#39;
1851 // and return the resulting instruction.
1852 // Dest_pos and inst_pos are 32 bit only. These parms can only designate
1853 // relative positions.
1854 // Use correct argument types. Do not pre-calculate distance.
1855 unsigned long MacroAssembler::patched_branch(address dest_pos, unsigned long inst, address inst_pos) {
1856   int c = 0;
1857   unsigned long patched_inst = 0;
1858   if (is_call_pcrelative_short(inst) ||
1859       is_branch_pcrelative_short(inst) ||
1860       is_branchoncount_pcrelative_short(inst) ||
1861       is_branchonindex32_pcrelative_short(inst)) {
1862     c = 1;
1863     int m = fmask(15, 0);    // simm16(-1, 16, 32);
1864     int v = simm16(RelAddr::pcrel_off16(dest_pos, inst_pos), 16, 32);
1865     patched_inst = (inst &amp; ~m) | v;
1866   } else if (is_compareandbranch_pcrelative_short(inst)) {
1867     c = 2;
1868     long m = fmask(31, 16);  // simm16(-1, 16, 48);
1869     long v = simm16(RelAddr::pcrel_off16(dest_pos, inst_pos), 16, 48);
1870     patched_inst = (inst &amp; ~m) | v;
1871   } else if (is_branchonindex64_pcrelative_short(inst)) {
1872     c = 3;
1873     long m = fmask(31, 16);  // simm16(-1, 16, 48);
1874     long v = simm16(RelAddr::pcrel_off16(dest_pos, inst_pos), 16, 48);
1875     patched_inst = (inst &amp; ~m) | v;
1876   } else if (is_call_pcrelative_long(inst) || is_branch_pcrelative_long(inst)) {
1877     c = 4;
1878     long m = fmask(31, 0);  // simm32(-1, 16, 48);
1879     long v = simm32(RelAddr::pcrel_off32(dest_pos, inst_pos), 16, 48);
1880     patched_inst = (inst &amp; ~m) | v;
1881   } else if (is_pcrelative_long(inst)) { // These are the non-branch pc-relative instructions.
1882     c = 5;
1883     long m = fmask(31, 0);  // simm32(-1, 16, 48);
1884     long v = simm32(RelAddr::pcrel_off32(dest_pos, inst_pos), 16, 48);
1885     patched_inst = (inst &amp; ~m) | v;
1886   } else {
1887     print_dbg_msg(tty, inst, &quot;not a relative branch&quot;, 0);
1888     dump_code_range(tty, inst_pos, 32, &quot;not a pcrelative branch&quot;);
1889     ShouldNotReachHere();
1890   }
1891 
1892   long new_off = get_pcrel_offset(patched_inst);
1893   if (new_off != (dest_pos-inst_pos)) {
1894     tty-&gt;print_cr(&quot;case %d: dest_pos = %p, inst_pos = %p, disp = %ld(%12.12lx)&quot;, c, dest_pos, inst_pos, new_off, new_off);
1895     print_dbg_msg(tty, inst,         &quot;&lt;- original instruction: branch patching error&quot;, 0);
1896     print_dbg_msg(tty, patched_inst, &quot;&lt;- patched  instruction: branch patching error&quot;, 0);
1897 #ifdef LUCY_DBG
1898     VM_Version::z_SIGSEGV();
1899 #endif
1900     ShouldNotReachHere();
1901   }
1902   return patched_inst;
1903 }
1904 
1905 // Only called when binding labels (share/vm/asm/assembler.cpp)
1906 // Pass arguments as intended. Do not pre-calculate distance.
1907 void MacroAssembler::pd_patch_instruction(address branch, address target, const char* file, int line) {
1908   unsigned long stub_inst;
1909   int           inst_len = get_instruction(branch, &amp;stub_inst);
1910 
1911   set_instruction(branch, patched_branch(target, stub_inst, branch), inst_len);
1912 }
1913 
1914 
1915 // Extract relative address (aka offset).
1916 // inv_simm16 works for 4-byte instructions only.
1917 // compare and branch instructions are 6-byte and have a 16bit offset &quot;in the middle&quot;.
1918 long MacroAssembler::get_pcrel_offset(unsigned long inst) {
1919 
1920   if (MacroAssembler::is_pcrelative_short(inst)) {
1921     if (((inst&amp;0xFFFFffff00000000UL) == 0) &amp;&amp; ((inst&amp;0x00000000FFFF0000UL) != 0)) {
1922       return RelAddr::inv_pcrel_off16(inv_simm16(inst));
1923     } else {
1924       return RelAddr::inv_pcrel_off16(inv_simm16_48(inst));
1925     }
1926   }
1927 
1928   if (MacroAssembler::is_pcrelative_long(inst)) {
1929     return RelAddr::inv_pcrel_off32(inv_simm32(inst));
1930   }
1931 
1932   print_dbg_msg(tty, inst, &quot;not a pcrelative instruction&quot;, 6);
1933 #ifdef LUCY_DBG
1934   VM_Version::z_SIGSEGV();
1935 #else
1936   ShouldNotReachHere();
1937 #endif
1938   return -1;
1939 }
1940 
1941 long MacroAssembler::get_pcrel_offset(address pc) {
1942   unsigned long inst;
1943   unsigned int  len = get_instruction(pc, &amp;inst);
1944 
1945 #ifdef ASSERT
1946   long offset;
1947   if (MacroAssembler::is_pcrelative_short(inst) || MacroAssembler::is_pcrelative_long(inst)) {
1948     offset = get_pcrel_offset(inst);
1949   } else {
1950     offset = -1;
1951   }
1952 
1953   if (offset == -1) {
1954     dump_code_range(tty, pc, 32, &quot;not a pcrelative instruction&quot;);
1955 #ifdef LUCY_DBG
1956     VM_Version::z_SIGSEGV();
1957 #else
1958     ShouldNotReachHere();
1959 #endif
1960   }
1961   return offset;
1962 #else
1963   return get_pcrel_offset(inst);
1964 #endif // ASSERT
1965 }
1966 
1967 // Get target address from pc-relative instructions.
1968 address MacroAssembler::get_target_addr_pcrel(address pc) {
1969   assert(is_pcrelative_long(pc), &quot;not a pcrelative instruction&quot;);
1970   return pc + get_pcrel_offset(pc);
1971 }
1972 
1973 // Patch pc relative load address.
1974 void MacroAssembler::patch_target_addr_pcrel(address pc, address con) {
1975   unsigned long inst;
1976   // Offset is +/- 2**32 -&gt; use long.
1977   ptrdiff_t distance = con - pc;
1978 
1979   get_instruction(pc, &amp;inst);
1980 
1981   if (is_pcrelative_short(inst)) {
1982     *(short *)(pc+2) = RelAddr::pcrel_off16(con, pc);  // Instructions are at least 2-byte aligned, no test required.
1983 
1984     // Some extra safety net.
1985     if (!RelAddr::is_in_range_of_RelAddr16(distance)) {
1986       print_dbg_msg(tty, inst, &quot;distance out of range (16bit)&quot;, 4);
1987       dump_code_range(tty, pc, 32, &quot;distance out of range (16bit)&quot;);
1988       guarantee(RelAddr::is_in_range_of_RelAddr16(distance), &quot;too far away (more than +/- 2**16&quot;);
1989     }
1990     return;
1991   }
1992 
1993   if (is_pcrelative_long(inst)) {
1994     *(int *)(pc+2)   = RelAddr::pcrel_off32(con, pc);
1995 
1996     // Some Extra safety net.
1997     if (!RelAddr::is_in_range_of_RelAddr32(distance)) {
1998       print_dbg_msg(tty, inst, &quot;distance out of range (32bit)&quot;, 6);
1999       dump_code_range(tty, pc, 32, &quot;distance out of range (32bit)&quot;);
2000       guarantee(RelAddr::is_in_range_of_RelAddr32(distance), &quot;too far away (more than +/- 2**32&quot;);
2001     }
2002     return;
2003   }
2004 
2005   guarantee(false, &quot;not a pcrelative instruction to patch!&quot;);
2006 }
2007 
2008 // &quot;Current PC&quot; here means the address just behind the basr instruction.
2009 address MacroAssembler::get_PC(Register result) {
2010   z_basr(result, Z_R0); // Don&#39;t branch, just save next instruction address in result.
2011   return pc();
2012 }
2013 
2014 // Get current PC + offset.
2015 // Offset given in bytes, must be even!
2016 // &quot;Current PC&quot; here means the address of the larl instruction plus the given offset.
2017 address MacroAssembler::get_PC(Register result, int64_t offset) {
2018   address here = pc();
2019   z_larl(result, offset/2); // Save target instruction address in result.
2020   return here + offset;
2021 }
2022 
2023 void MacroAssembler::instr_size(Register size, Register pc) {
2024   // Extract 2 most significant bits of current instruction.
2025   z_llgc(size, Address(pc));
2026   z_srl(size, 6);
2027   // Compute (x+3)&amp;6 which translates 0-&gt;2, 1-&gt;4, 2-&gt;4, 3-&gt;6.
2028   z_ahi(size, 3);
2029   z_nill(size, 6);
2030 }
2031 
2032 // Resize_frame with SP(new) = SP(old) - [offset].
2033 void MacroAssembler::resize_frame_sub(Register offset, Register fp, bool load_fp)
2034 {
2035   assert_different_registers(offset, fp, Z_SP);
2036   if (load_fp) { z_lg(fp, _z_abi(callers_sp), Z_SP); }
2037 
2038   z_sgr(Z_SP, offset);
2039   z_stg(fp, _z_abi(callers_sp), Z_SP);
2040 }
2041 
2042 // Resize_frame with SP(new) = [newSP] + offset.
2043 //   This emitter is useful if we already have calculated a pointer
2044 //   into the to-be-allocated stack space, e.g. with special alignment properties,
2045 //   but need some additional space, e.g. for spilling.
2046 //   newSP    is the pre-calculated pointer. It must not be modified.
2047 //   fp       holds, or is filled with, the frame pointer.
2048 //   offset   is the additional increment which is added to addr to form the new SP.
2049 //            Note: specify a negative value to reserve more space!
2050 //   load_fp == true  only indicates that fp is not pre-filled with the frame pointer.
2051 //                    It does not guarantee that fp contains the frame pointer at the end.
2052 void MacroAssembler::resize_frame_abs_with_offset(Register newSP, Register fp, int offset, bool load_fp) {
2053   assert_different_registers(newSP, fp, Z_SP);
2054 
2055   if (load_fp) {
2056     z_lg(fp, _z_abi(callers_sp), Z_SP);
2057   }
2058 
2059   add2reg(Z_SP, offset, newSP);
2060   z_stg(fp, _z_abi(callers_sp), Z_SP);
2061 }
2062 
2063 // Resize_frame with SP(new) = [newSP].
2064 //   load_fp == true  only indicates that fp is not pre-filled with the frame pointer.
2065 //                    It does not guarantee that fp contains the frame pointer at the end.
2066 void MacroAssembler::resize_frame_absolute(Register newSP, Register fp, bool load_fp) {
2067   assert_different_registers(newSP, fp, Z_SP);
2068 
2069   if (load_fp) {
2070     z_lg(fp, _z_abi(callers_sp), Z_SP); // need to use load/store.
2071   }
2072 
2073   z_lgr(Z_SP, newSP);
2074   if (newSP != Z_R0) { // make sure we generate correct code, no matter what register newSP uses.
2075     z_stg(fp, _z_abi(callers_sp), newSP);
2076   } else {
2077     z_stg(fp, _z_abi(callers_sp), Z_SP);
2078   }
2079 }
2080 
2081 // Resize_frame with SP(new) = SP(old) + offset.
2082 void MacroAssembler::resize_frame(RegisterOrConstant offset, Register fp, bool load_fp) {
2083   assert_different_registers(fp, Z_SP);
2084 
2085   if (load_fp) {
2086     z_lg(fp, _z_abi(callers_sp), Z_SP);
2087   }
2088   add64(Z_SP, offset);
2089   z_stg(fp, _z_abi(callers_sp), Z_SP);
2090 }
2091 
2092 void MacroAssembler::push_frame(Register bytes, Register old_sp, bool copy_sp, bool bytes_with_inverted_sign) {
2093 #ifdef ASSERT
2094   assert_different_registers(bytes, old_sp, Z_SP);
2095   if (!copy_sp) {
2096     z_cgr(old_sp, Z_SP);
2097     asm_assert_eq(&quot;[old_sp]!=[Z_SP]&quot;, 0x211);
2098   }
2099 #endif
2100   if (copy_sp) { z_lgr(old_sp, Z_SP); }
2101   if (bytes_with_inverted_sign) {
2102     z_agr(Z_SP, bytes);
2103   } else {
2104     z_sgr(Z_SP, bytes); // Z_sgfr sufficient, but probably not faster.
2105   }
2106   z_stg(old_sp, _z_abi(callers_sp), Z_SP);
2107 }
2108 
2109 unsigned int MacroAssembler::push_frame(unsigned int bytes, Register scratch) {
2110   long offset = Assembler::align(bytes, frame::alignment_in_bytes);
2111   assert(offset &gt; 0, &quot;should push a frame with positive size, size = %ld.&quot;, offset);
2112   assert(Displacement::is_validDisp(-offset), &quot;frame size out of range, size = %ld&quot;, offset);
2113 
2114   // We must not write outside the current stack bounds (given by Z_SP).
2115   // Thus, we have to first update Z_SP and then store the previous SP as stack linkage.
2116   // We rely on Z_R0 by default to be available as scratch.
2117   z_lgr(scratch, Z_SP);
2118   add2reg(Z_SP, -offset);
2119   z_stg(scratch, _z_abi(callers_sp), Z_SP);
2120 #ifdef ASSERT
2121   // Just make sure nobody uses the value in the default scratch register.
2122   // When another register is used, the caller might rely on it containing the frame pointer.
2123   if (scratch == Z_R0) {
2124     z_iihf(scratch, 0xbaadbabe);
2125     z_iilf(scratch, 0xdeadbeef);
2126   }
2127 #endif
2128   return offset;
2129 }
2130 
2131 // Push a frame of size `bytes&#39; plus abi160 on top.
2132 unsigned int MacroAssembler::push_frame_abi160(unsigned int bytes) {
2133   BLOCK_COMMENT(&quot;push_frame_abi160 {&quot;);
2134   unsigned int res = push_frame(bytes + frame::z_abi_160_size);
2135   BLOCK_COMMENT(&quot;} push_frame_abi160&quot;);
2136   return res;
2137 }
2138 
2139 // Pop current C frame.
2140 void MacroAssembler::pop_frame() {
2141   BLOCK_COMMENT(&quot;pop_frame:&quot;);
2142   Assembler::z_lg(Z_SP, _z_abi(callers_sp), Z_SP);
2143 }
2144 
2145 // Pop current C frame and restore return PC register (Z_R14).
2146 void MacroAssembler::pop_frame_restore_retPC(int frame_size_in_bytes) {
2147   BLOCK_COMMENT(&quot;pop_frame_restore_retPC:&quot;);
2148   int retPC_offset = _z_abi16(return_pc) + frame_size_in_bytes;
2149   // If possible, pop frame by add instead of load (a penny saved is a penny got :-).
2150   if (Displacement::is_validDisp(retPC_offset)) {
2151     z_lg(Z_R14, retPC_offset, Z_SP);
2152     add2reg(Z_SP, frame_size_in_bytes);
2153   } else {
2154     add2reg(Z_SP, frame_size_in_bytes);
2155     restore_return_pc();
2156   }
2157 }
2158 
2159 void MacroAssembler::call_VM_leaf_base(address entry_point, bool allow_relocation) {
2160   if (allow_relocation) {
2161     call_c(entry_point);
2162   } else {
2163     call_c_static(entry_point);
2164   }
2165 }
2166 
2167 void MacroAssembler::call_VM_leaf_base(address entry_point) {
2168   bool allow_relocation = true;
2169   call_VM_leaf_base(entry_point, allow_relocation);
2170 }
2171 
2172 void MacroAssembler::call_VM_base(Register oop_result,
2173                                   Register last_java_sp,
2174                                   address  entry_point,
2175                                   bool     allow_relocation,
2176                                   bool     check_exceptions) { // Defaults to true.
2177   // Allow_relocation indicates, if true, that the generated code shall
2178   // be fit for code relocation or referenced data relocation. In other
2179   // words: all addresses must be considered variable. PC-relative addressing
2180   // is not possible then.
2181   // On the other hand, if (allow_relocation == false), addresses and offsets
2182   // may be considered stable, enabling us to take advantage of some PC-relative
2183   // addressing tweaks. These might improve performance and reduce code size.
2184 
2185   // Determine last_java_sp register.
2186   if (!last_java_sp-&gt;is_valid()) {
2187     last_java_sp = Z_SP;  // Load Z_SP as SP.
2188   }
2189 
2190   set_top_ijava_frame_at_SP_as_last_Java_frame(last_java_sp, Z_R1, allow_relocation);
2191 
2192   // ARG1 must hold thread address.
2193   z_lgr(Z_ARG1, Z_thread);
2194 
2195   address return_pc = NULL;
2196   if (allow_relocation) {
2197     return_pc = call_c(entry_point);
2198   } else {
2199     return_pc = call_c_static(entry_point);
2200   }
2201 
2202   reset_last_Java_frame(allow_relocation);
2203 
2204   // C++ interp handles this in the interpreter.
2205   check_and_handle_popframe(Z_thread);
2206   check_and_handle_earlyret(Z_thread);
2207 
2208   // Check for pending exceptions.
2209   if (check_exceptions) {
2210     // Check for pending exceptions (java_thread is set upon return).
2211     load_and_test_long(Z_R0_scratch, Address(Z_thread, Thread::pending_exception_offset()));
2212 
2213     // This used to conditionally jump to forward_exception however it is
2214     // possible if we relocate that the branch will not reach. So we must jump
2215     // around so we can always reach.
2216 
2217     Label ok;
2218     z_bre(ok); // Bcondequal is the same as bcondZero.
2219     call_stub(StubRoutines::forward_exception_entry());
2220     bind(ok);
2221   }
2222 
2223   // Get oop result if there is one and reset the value in the thread.
2224   if (oop_result-&gt;is_valid()) {
2225     get_vm_result(oop_result);
2226   }
2227 
2228   _last_calls_return_pc = return_pc;  // Wipe out other (error handling) calls.
2229 }
2230 
2231 void MacroAssembler::call_VM_base(Register oop_result,
2232                                   Register last_java_sp,
2233                                   address  entry_point,
2234                                   bool     check_exceptions) { // Defaults to true.
2235   bool allow_relocation = true;
2236   call_VM_base(oop_result, last_java_sp, entry_point, allow_relocation, check_exceptions);
2237 }
2238 
2239 // VM calls without explicit last_java_sp.
2240 
2241 void MacroAssembler::call_VM(Register oop_result, address entry_point, bool check_exceptions) {
2242   // Call takes possible detour via InterpreterMacroAssembler.
2243   call_VM_base(oop_result, noreg, entry_point, true, check_exceptions);
2244 }
2245 
2246 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, bool check_exceptions) {
2247   // Z_ARG1 is reserved for the thread.
2248   lgr_if_needed(Z_ARG2, arg_1);
2249   call_VM(oop_result, entry_point, check_exceptions);
2250 }
2251 
2252 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, Register arg_2, bool check_exceptions) {
2253   // Z_ARG1 is reserved for the thread.
2254   lgr_if_needed(Z_ARG2, arg_1);
2255   assert(arg_2 != Z_ARG2, &quot;smashed argument&quot;);
2256   lgr_if_needed(Z_ARG3, arg_2);
2257   call_VM(oop_result, entry_point, check_exceptions);
2258 }
2259 
2260 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, Register arg_2,
2261                              Register arg_3, bool check_exceptions) {
2262   // Z_ARG1 is reserved for the thread.
2263   lgr_if_needed(Z_ARG2, arg_1);
2264   assert(arg_2 != Z_ARG2, &quot;smashed argument&quot;);
2265   lgr_if_needed(Z_ARG3, arg_2);
2266   assert(arg_3 != Z_ARG2 &amp;&amp; arg_3 != Z_ARG3, &quot;smashed argument&quot;);
2267   lgr_if_needed(Z_ARG4, arg_3);
2268   call_VM(oop_result, entry_point, check_exceptions);
2269 }
2270 
2271 // VM static calls without explicit last_java_sp.
2272 
2273 void MacroAssembler::call_VM_static(Register oop_result, address entry_point, bool check_exceptions) {
2274   // Call takes possible detour via InterpreterMacroAssembler.
2275   call_VM_base(oop_result, noreg, entry_point, false, check_exceptions);
2276 }
2277 
2278 void MacroAssembler::call_VM_static(Register oop_result, address entry_point, Register arg_1, Register arg_2,
2279                                     Register arg_3, bool check_exceptions) {
2280   // Z_ARG1 is reserved for the thread.
2281   lgr_if_needed(Z_ARG2, arg_1);
2282   assert(arg_2 != Z_ARG2, &quot;smashed argument&quot;);
2283   lgr_if_needed(Z_ARG3, arg_2);
2284   assert(arg_3 != Z_ARG2 &amp;&amp; arg_3 != Z_ARG3, &quot;smashed argument&quot;);
2285   lgr_if_needed(Z_ARG4, arg_3);
2286   call_VM_static(oop_result, entry_point, check_exceptions);
2287 }
2288 
2289 // VM calls with explicit last_java_sp.
2290 
2291 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, bool check_exceptions) {
2292   // Call takes possible detour via InterpreterMacroAssembler.
2293   call_VM_base(oop_result, last_java_sp, entry_point, true, check_exceptions);
2294 }
2295 
2296 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions) {
2297    // Z_ARG1 is reserved for the thread.
2298    lgr_if_needed(Z_ARG2, arg_1);
2299    call_VM(oop_result, last_java_sp, entry_point, check_exceptions);
2300 }
2301 
2302 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1,
2303                              Register arg_2, bool check_exceptions) {
2304    // Z_ARG1 is reserved for the thread.
2305    lgr_if_needed(Z_ARG2, arg_1);
2306    assert(arg_2 != Z_ARG2, &quot;smashed argument&quot;);
2307    lgr_if_needed(Z_ARG3, arg_2);
2308    call_VM(oop_result, last_java_sp, entry_point, check_exceptions);
2309 }
2310 
2311 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1,
2312                              Register arg_2, Register arg_3, bool check_exceptions) {
2313   // Z_ARG1 is reserved for the thread.
2314   lgr_if_needed(Z_ARG2, arg_1);
2315   assert(arg_2 != Z_ARG2, &quot;smashed argument&quot;);
2316   lgr_if_needed(Z_ARG3, arg_2);
2317   assert(arg_3 != Z_ARG2 &amp;&amp; arg_3 != Z_ARG3, &quot;smashed argument&quot;);
2318   lgr_if_needed(Z_ARG4, arg_3);
2319   call_VM(oop_result, last_java_sp, entry_point, check_exceptions);
2320 }
2321 
2322 // VM leaf calls.
2323 
2324 void MacroAssembler::call_VM_leaf(address entry_point) {
2325   // Call takes possible detour via InterpreterMacroAssembler.
2326   call_VM_leaf_base(entry_point, true);
2327 }
2328 
2329 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_1) {
2330   if (arg_1 != noreg) lgr_if_needed(Z_ARG1, arg_1);
2331   call_VM_leaf(entry_point);
2332 }
2333 
2334 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_1, Register arg_2) {
2335   if (arg_1 != noreg) lgr_if_needed(Z_ARG1, arg_1);
2336   assert(arg_2 != Z_ARG1, &quot;smashed argument&quot;);
2337   if (arg_2 != noreg) lgr_if_needed(Z_ARG2, arg_2);
2338   call_VM_leaf(entry_point);
2339 }
2340 
2341 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_1, Register arg_2, Register arg_3) {
2342   if (arg_1 != noreg) lgr_if_needed(Z_ARG1, arg_1);
2343   assert(arg_2 != Z_ARG1, &quot;smashed argument&quot;);
2344   if (arg_2 != noreg) lgr_if_needed(Z_ARG2, arg_2);
2345   assert(arg_3 != Z_ARG1 &amp;&amp; arg_3 != Z_ARG2, &quot;smashed argument&quot;);
2346   if (arg_3 != noreg) lgr_if_needed(Z_ARG3, arg_3);
2347   call_VM_leaf(entry_point);
2348 }
2349 
2350 // Static VM leaf calls.
2351 // Really static VM leaf calls are never patched.
2352 
2353 void MacroAssembler::call_VM_leaf_static(address entry_point) {
2354   // Call takes possible detour via InterpreterMacroAssembler.
2355   call_VM_leaf_base(entry_point, false);
2356 }
2357 
2358 void MacroAssembler::call_VM_leaf_static(address entry_point, Register arg_1) {
2359   if (arg_1 != noreg) lgr_if_needed(Z_ARG1, arg_1);
2360   call_VM_leaf_static(entry_point);
2361 }
2362 
2363 void MacroAssembler::call_VM_leaf_static(address entry_point, Register arg_1, Register arg_2) {
2364   if (arg_1 != noreg) lgr_if_needed(Z_ARG1, arg_1);
2365   assert(arg_2 != Z_ARG1, &quot;smashed argument&quot;);
2366   if (arg_2 != noreg) lgr_if_needed(Z_ARG2, arg_2);
2367   call_VM_leaf_static(entry_point);
2368 }
2369 
2370 void MacroAssembler::call_VM_leaf_static(address entry_point, Register arg_1, Register arg_2, Register arg_3) {
2371   if (arg_1 != noreg) lgr_if_needed(Z_ARG1, arg_1);
2372   assert(arg_2 != Z_ARG1, &quot;smashed argument&quot;);
2373   if (arg_2 != noreg) lgr_if_needed(Z_ARG2, arg_2);
2374   assert(arg_3 != Z_ARG1 &amp;&amp; arg_3 != Z_ARG2, &quot;smashed argument&quot;);
2375   if (arg_3 != noreg) lgr_if_needed(Z_ARG3, arg_3);
2376   call_VM_leaf_static(entry_point);
2377 }
2378 
2379 // Don&#39;t use detour via call_c(reg).
2380 address MacroAssembler::call_c(address function_entry) {
2381   load_const(Z_R1, function_entry);
2382   return call(Z_R1);
2383 }
2384 
2385 // Variant for really static (non-relocatable) calls which are never patched.
2386 address MacroAssembler::call_c_static(address function_entry) {
2387   load_absolute_address(Z_R1, function_entry);
2388 #if 0 // def ASSERT
2389   // Verify that call site did not move.
2390   load_const_optimized(Z_R0, function_entry);
2391   z_cgr(Z_R1, Z_R0);
2392   z_brc(bcondEqual, 3);
2393   z_illtrap(0xba);
2394 #endif
2395   return call(Z_R1);
2396 }
2397 
2398 address MacroAssembler::call_c_opt(address function_entry) {
2399   bool success = call_far_patchable(function_entry, -2 /* emit relocation + constant */);
2400   _last_calls_return_pc = success ? pc() : NULL;
2401   return _last_calls_return_pc;
2402 }
2403 
2404 // Identify a call_far_patchable instruction: LARL + LG + BASR
2405 //
2406 //    nop                   ; optionally, if required for alignment
2407 //    lgrl rx,A(TOC entry)  ; PC-relative access into constant pool
2408 //    basr Z_R14,rx         ; end of this instruction must be aligned to a word boundary
2409 //
2410 // Code pattern will eventually get patched into variant2 (see below for detection code).
2411 //
2412 bool MacroAssembler::is_call_far_patchable_variant0_at(address instruction_addr) {
2413   address iaddr = instruction_addr;
2414 
2415   // Check for the actual load instruction.
2416   if (!is_load_const_from_toc(iaddr)) { return false; }
2417   iaddr += load_const_from_toc_size();
2418 
2419   // Check for the call (BASR) instruction, finally.
2420   assert(iaddr-instruction_addr+call_byregister_size() == call_far_patchable_size(), &quot;size mismatch&quot;);
2421   return is_call_byregister(iaddr);
2422 }
2423 
2424 // Identify a call_far_patchable instruction: BRASL
2425 //
2426 // Code pattern to suits atomic patching:
2427 //    nop                       ; Optionally, if required for alignment.
2428 //    nop    ...                ; Multiple filler nops to compensate for size difference (variant0 is longer).
2429 //    nop                       ; For code pattern detection: Prepend each BRASL with a nop.
2430 //    brasl  Z_R14,&lt;reladdr&gt;    ; End of code must be 4-byte aligned !
2431 bool MacroAssembler::is_call_far_patchable_variant2_at(address instruction_addr) {
2432   const address call_addr = (address)((intptr_t)instruction_addr + call_far_patchable_size() - call_far_pcrelative_size());
2433 
2434   // Check for correct number of leading nops.
2435   address iaddr;
2436   for (iaddr = instruction_addr; iaddr &lt; call_addr; iaddr += nop_size()) {
2437     if (!is_z_nop(iaddr)) { return false; }
2438   }
2439   assert(iaddr == call_addr, &quot;sanity&quot;);
2440 
2441   // --&gt; Check for call instruction.
2442   if (is_call_far_pcrelative(call_addr)) {
2443     assert(call_addr-instruction_addr+call_far_pcrelative_size() == call_far_patchable_size(), &quot;size mismatch&quot;);
2444     return true;
2445   }
2446 
2447   return false;
2448 }
2449 
2450 // Emit a NOT mt-safely patchable 64 bit absolute call.
2451 // If toc_offset == -2, then the destination of the call (= target) is emitted
2452 //                      to the constant pool and a runtime_call relocation is added
2453 //                      to the code buffer.
2454 // If toc_offset != -2, target must already be in the constant pool at
2455 //                      _ctableStart+toc_offset (a caller can retrieve toc_offset
2456 //                      from the runtime_call relocation).
2457 // Special handling of emitting to scratch buffer when there is no constant pool.
2458 // Slightly changed code pattern. We emit an additional nop if we would
2459 // not end emitting at a word aligned address. This is to ensure
2460 // an atomically patchable displacement in brasl instructions.
2461 //
2462 // A call_far_patchable comes in different flavors:
2463 //  - LARL(CP) / LG(CP) / BR (address in constant pool, access via CP register)
2464 //  - LGRL(CP) / BR          (address in constant pool, pc-relative accesss)
2465 //  - BRASL                  (relative address of call target coded in instruction)
2466 // All flavors occupy the same amount of space. Length differences are compensated
2467 // by leading nops, such that the instruction sequence always ends at the same
2468 // byte offset. This is required to keep the return offset constant.
2469 // Furthermore, the return address (the end of the instruction sequence) is forced
2470 // to be on a 4-byte boundary. This is required for atomic patching, should we ever
2471 // need to patch the call target of the BRASL flavor.
2472 // RETURN value: false, if no constant pool entry could be allocated, true otherwise.
2473 bool MacroAssembler::call_far_patchable(address target, int64_t tocOffset) {
2474   // Get current pc and ensure word alignment for end of instr sequence.
2475   const address start_pc = pc();
2476   const intptr_t       start_off = offset();
2477   assert(!call_far_patchable_requires_alignment_nop(start_pc), &quot;call_far_patchable requires aligned address&quot;);
2478   const ptrdiff_t      dist      = (ptrdiff_t)(target - (start_pc + 2)); // Prepend each BRASL with a nop.
2479   const bool emit_target_to_pool = (tocOffset == -2) &amp;&amp; !code_section()-&gt;scratch_emit();
2480   const bool emit_relative_call  = !emit_target_to_pool &amp;&amp;
2481                                    RelAddr::is_in_range_of_RelAddr32(dist) &amp;&amp;
2482                                    ReoptimizeCallSequences &amp;&amp;
2483                                    !code_section()-&gt;scratch_emit();
2484 
2485   if (emit_relative_call) {
2486     // Add padding to get the same size as below.
2487     const unsigned int padding = call_far_patchable_size() - call_far_pcrelative_size();
2488     unsigned int current_padding;
2489     for (current_padding = 0; current_padding &lt; padding; current_padding += nop_size()) { z_nop(); }
2490     assert(current_padding == padding, &quot;sanity&quot;);
2491 
2492     // relative call: len = 2(nop) + 6 (brasl)
2493     // CodeBlob resize cannot occur in this case because
2494     // this call is emitted into pre-existing space.
2495     z_nop(); // Prepend each BRASL with a nop.
2496     z_brasl(Z_R14, target);
2497   } else {
2498     // absolute call: Get address from TOC.
2499     // len = (load TOC){6|0} + (load from TOC){6} + (basr){2} = {14|8}
2500     if (emit_target_to_pool) {
2501       // When emitting the call for the first time, we do not need to use
2502       // the pc-relative version. It will be patched anyway, when the code
2503       // buffer is copied.
2504       // Relocation is not needed when !ReoptimizeCallSequences.
2505       relocInfo::relocType rt = ReoptimizeCallSequences ? relocInfo::runtime_call_w_cp_type : relocInfo::none;
2506       AddressLiteral dest(target, rt);
2507       // Store_oop_in_toc() adds dest to the constant table. As side effect, this kills
2508       // inst_mark(). Reset if possible.
2509       bool reset_mark = (inst_mark() == pc());
2510       tocOffset = store_oop_in_toc(dest);
2511       if (reset_mark) { set_inst_mark(); }
2512       if (tocOffset == -1) {
2513         return false; // Couldn&#39;t create constant pool entry.
2514       }
2515     }
2516     assert(offset() == start_off, &quot;emit no code before this point!&quot;);
2517 
2518     address tocPos = pc() + tocOffset;
2519     if (emit_target_to_pool) {
2520       tocPos = code()-&gt;consts()-&gt;start() + tocOffset;
2521     }
2522     load_long_pcrelative(Z_R14, tocPos);
2523     z_basr(Z_R14, Z_R14);
2524   }
2525 
2526 #ifdef ASSERT
2527   // Assert that we can identify the emitted call.
2528   assert(is_call_far_patchable_at(addr_at(start_off)), &quot;can&#39;t identify emitted call&quot;);
2529   assert(offset() == start_off+call_far_patchable_size(), &quot;wrong size&quot;);
2530 
2531   if (emit_target_to_pool) {
2532     assert(get_dest_of_call_far_patchable_at(addr_at(start_off), code()-&gt;consts()-&gt;start()) == target,
2533            &quot;wrong encoding of dest address&quot;);
2534   }
2535 #endif
2536   return true; // success
2537 }
2538 
2539 // Identify a call_far_patchable instruction.
2540 // For more detailed information see header comment of call_far_patchable.
2541 bool MacroAssembler::is_call_far_patchable_at(address instruction_addr) {
2542   return is_call_far_patchable_variant2_at(instruction_addr)  || // short version: BRASL
2543          is_call_far_patchable_variant0_at(instruction_addr);    // long version LARL + LG + BASR
2544 }
2545 
2546 // Does the call_far_patchable instruction use a pc-relative encoding
2547 // of the call destination?
2548 bool MacroAssembler::is_call_far_patchable_pcrelative_at(address instruction_addr) {
2549   // Variant 2 is pc-relative.
2550   return is_call_far_patchable_variant2_at(instruction_addr);
2551 }
2552 
2553 bool MacroAssembler::is_call_far_pcrelative(address instruction_addr) {
2554   // Prepend each BRASL with a nop.
2555   return is_z_nop(instruction_addr) &amp;&amp; is_z_brasl(instruction_addr + nop_size());  // Match at position after one nop required.
2556 }
2557 
2558 // Set destination address of a call_far_patchable instruction.
2559 void MacroAssembler::set_dest_of_call_far_patchable_at(address instruction_addr, address dest, int64_t tocOffset) {
2560   ResourceMark rm;
2561 
2562   // Now that CP entry is verified, patch call to a pc-relative call (if circumstances permit).
2563   int code_size = MacroAssembler::call_far_patchable_size();
2564   CodeBuffer buf(instruction_addr, code_size);
2565   MacroAssembler masm(&amp;buf);
2566   masm.call_far_patchable(dest, tocOffset);
2567   ICache::invalidate_range(instruction_addr, code_size); // Empty on z.
2568 }
2569 
2570 // Get dest address of a call_far_patchable instruction.
2571 address MacroAssembler::get_dest_of_call_far_patchable_at(address instruction_addr, address ctable) {
2572   // Dynamic TOC: absolute address in constant pool.
2573   // Check variant2 first, it is more frequent.
2574 
2575   // Relative address encoded in call instruction.
2576   if (is_call_far_patchable_variant2_at(instruction_addr)) {
2577     return MacroAssembler::get_target_addr_pcrel(instruction_addr + nop_size()); // Prepend each BRASL with a nop.
2578 
2579   // Absolute address in constant pool.
2580   } else if (is_call_far_patchable_variant0_at(instruction_addr)) {
2581     address iaddr = instruction_addr;
2582 
2583     long    tocOffset = get_load_const_from_toc_offset(iaddr);
2584     address tocLoc    = iaddr + tocOffset;
2585     return *(address *)(tocLoc);
2586   } else {
2587     fprintf(stderr, &quot;MacroAssembler::get_dest_of_call_far_patchable_at has a problem at %p:\n&quot;, instruction_addr);
2588     fprintf(stderr, &quot;not a call_far_patchable: %16.16lx %16.16lx, len = %d\n&quot;,
2589             *(unsigned long*)instruction_addr,
2590             *(unsigned long*)(instruction_addr+8),
2591             call_far_patchable_size());
2592     Disassembler::decode(instruction_addr, instruction_addr+call_far_patchable_size());
2593     ShouldNotReachHere();
2594     return NULL;
2595   }
2596 }
2597 
2598 void MacroAssembler::align_call_far_patchable(address pc) {
2599   if (call_far_patchable_requires_alignment_nop(pc)) { z_nop(); }
2600 }
2601 
2602 void MacroAssembler::check_and_handle_earlyret(Register java_thread) {
2603 }
2604 
2605 void MacroAssembler::check_and_handle_popframe(Register java_thread) {
2606 }
2607 
2608 // Read from the polling page.
2609 // Use TM or TMY instruction, depending on read offset.
2610 //   offset = 0: Use TM, safepoint polling.
2611 //   offset &lt; 0: Use TMY, profiling safepoint polling.
2612 void MacroAssembler::load_from_polling_page(Register polling_page_address, int64_t offset) {
2613   if (Immediate::is_uimm12(offset)) {
2614     z_tm(offset, polling_page_address, mask_safepoint);
2615   } else {
2616     z_tmy(offset, polling_page_address, mask_profiling);
2617   }
2618 }
2619 
2620 // Check whether z_instruction is a read access to the polling page
2621 // which was emitted by load_from_polling_page(..).
2622 bool MacroAssembler::is_load_from_polling_page(address instr_loc) {
2623   unsigned long z_instruction;
2624   unsigned int  ilen = get_instruction(instr_loc, &amp;z_instruction);
2625 
2626   if (ilen == 2) { return false; } // It&#39;s none of the allowed instructions.
2627 
2628   if (ilen == 4) {
2629     if (!is_z_tm(z_instruction)) { return false; } // It&#39;s len=4, but not a z_tm. fail.
2630 
2631     int ms = inv_mask(z_instruction,8,32);  // mask
2632     int ra = inv_reg(z_instruction,16,32);  // base register
2633     int ds = inv_uimm12(z_instruction);     // displacement
2634 
2635     if (!(ds == 0 &amp;&amp; ra != 0 &amp;&amp; ms == mask_safepoint)) {
2636       return false; // It&#39;s not a z_tm(0, ra, mask_safepoint). Fail.
2637     }
2638 
2639   } else { /* if (ilen == 6) */
2640 
2641     assert(!is_z_lg(z_instruction), &quot;old form (LG) polling page access. Please fix and use TM(Y).&quot;);
2642 
2643     if (!is_z_tmy(z_instruction)) { return false; } // It&#39;s len=6, but not a z_tmy. fail.
2644 
2645     int ms = inv_mask(z_instruction,8,48);  // mask
2646     int ra = inv_reg(z_instruction,16,48);  // base register
2647     int ds = inv_simm20(z_instruction);     // displacement
2648   }
2649 
2650   return true;
2651 }
2652 
2653 // Extract poll address from instruction and ucontext.
2654 address MacroAssembler::get_poll_address(address instr_loc, void* ucontext) {
2655   assert(ucontext != NULL, &quot;must have ucontext&quot;);
2656   ucontext_t* uc = (ucontext_t*) ucontext;
2657   unsigned long z_instruction;
2658   unsigned int ilen = get_instruction(instr_loc, &amp;z_instruction);
2659 
2660   if (ilen == 4 &amp;&amp; is_z_tm(z_instruction)) {
2661     int ra = inv_reg(z_instruction, 16, 32);  // base register
2662     int ds = inv_uimm12(z_instruction);       // displacement
2663     address addr = (address)uc-&gt;uc_mcontext.gregs[ra];
2664     return addr + ds;
2665   } else if (ilen == 6 &amp;&amp; is_z_tmy(z_instruction)) {
2666     int ra = inv_reg(z_instruction, 16, 48);  // base register
2667     int ds = inv_simm20(z_instruction);       // displacement
2668     address addr = (address)uc-&gt;uc_mcontext.gregs[ra];
2669     return addr + ds;
2670   }
2671 
2672   ShouldNotReachHere();
2673   return NULL;
2674 }
2675 
2676 // Extract poll register from instruction.
2677 uint MacroAssembler::get_poll_register(address instr_loc) {
2678   unsigned long z_instruction;
2679   unsigned int ilen = get_instruction(instr_loc, &amp;z_instruction);
2680 
2681   if (ilen == 4 &amp;&amp; is_z_tm(z_instruction)) {
2682     return (uint)inv_reg(z_instruction, 16, 32);  // base register
2683   } else if (ilen == 6 &amp;&amp; is_z_tmy(z_instruction)) {
2684     return (uint)inv_reg(z_instruction, 16, 48);  // base register
2685   }
2686 
2687   ShouldNotReachHere();
2688   return 0;
2689 }
2690 
2691 void MacroAssembler::safepoint_poll(Label&amp; slow_path, Register temp_reg) {
2692   if (SafepointMechanism::uses_thread_local_poll()) {
2693     const Address poll_byte_addr(Z_thread, in_bytes(Thread::polling_page_offset()) + 7 /* Big Endian */);
2694     // Armed page has poll_bit set.
2695     z_tm(poll_byte_addr, SafepointMechanism::poll_bit());
2696     z_brnaz(slow_path);
2697   } else {
2698     load_const_optimized(temp_reg, SafepointSynchronize::address_of_state());
2699     z_cli(/*SafepointSynchronize::sz_state()*/4-1, temp_reg, SafepointSynchronize::_not_synchronized);
2700     z_brne(slow_path);
2701   }
2702 }
2703 
2704 // Don&#39;t rely on register locking, always use Z_R1 as scratch register instead.
2705 void MacroAssembler::bang_stack_with_offset(int offset) {
2706   // Stack grows down, caller passes positive offset.
2707   assert(offset &gt; 0, &quot;must bang with positive offset&quot;);
2708   if (Displacement::is_validDisp(-offset)) {
2709     z_tmy(-offset, Z_SP, mask_stackbang);
2710   } else {
2711     add2reg(Z_R1, -offset, Z_SP);    // Do not destroy Z_SP!!!
2712     z_tm(0, Z_R1, mask_stackbang);  // Just banging.
2713   }
2714 }
2715 
2716 void MacroAssembler::reserved_stack_check(Register return_pc) {
2717   // Test if reserved zone needs to be enabled.
2718   Label no_reserved_zone_enabling;
2719   assert(return_pc == Z_R14, &quot;Return pc must be in R14 before z_br() to StackOverflow stub.&quot;);
2720   BLOCK_COMMENT(&quot;reserved_stack_check {&quot;);
2721 
2722   z_clg(Z_SP, Address(Z_thread, JavaThread::reserved_stack_activation_offset()));
2723   z_brl(no_reserved_zone_enabling);
2724 
2725   // Enable reserved zone again, throw stack overflow exception.
2726   save_return_pc();
2727   push_frame_abi160(0);
2728   call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), Z_thread);
2729   pop_frame();
2730   restore_return_pc();
2731 
2732   load_const_optimized(Z_R1, StubRoutines::throw_delayed_StackOverflowError_entry());
2733   // Don&#39;t use call() or z_basr(), they will invalidate Z_R14 which contains the return pc.
2734   z_br(Z_R1);
2735 
2736   should_not_reach_here();
2737 
2738   bind(no_reserved_zone_enabling);
2739   BLOCK_COMMENT(&quot;} reserved_stack_check&quot;);
2740 }
2741 
2742 // Defines obj, preserves var_size_in_bytes, okay for t2 == var_size_in_bytes.
2743 void MacroAssembler::tlab_allocate(Register obj,
2744                                    Register var_size_in_bytes,
2745                                    int con_size_in_bytes,
2746                                    Register t1,
2747                                    Label&amp; slow_case) {
2748   assert_different_registers(obj, var_size_in_bytes, t1);
2749   Register end = t1;
2750   Register thread = Z_thread;
2751 
2752   z_lg(obj, Address(thread, JavaThread::tlab_top_offset()));
2753   if (var_size_in_bytes == noreg) {
2754     z_lay(end, Address(obj, con_size_in_bytes));
2755   } else {
2756     z_lay(end, Address(obj, var_size_in_bytes));
2757   }
2758   z_cg(end, Address(thread, JavaThread::tlab_end_offset()));
2759   branch_optimized(bcondHigh, slow_case);
2760 
2761   // Update the tlab top pointer.
2762   z_stg(end, Address(thread, JavaThread::tlab_top_offset()));
2763 
2764   // Recover var_size_in_bytes if necessary.
2765   if (var_size_in_bytes == end) {
2766     z_sgr(var_size_in_bytes, obj);
2767   }
2768 }
2769 
2770 // Emitter for interface method lookup.
2771 //   input: recv_klass, intf_klass, itable_index
2772 //   output: method_result
2773 //   kills: itable_index, temp1_reg, Z_R0, Z_R1
2774 // TODO: Temp2_reg is unused. we may use this emitter also in the itable stubs.
2775 // If the register is still not needed then, remove it.
2776 void MacroAssembler::lookup_interface_method(Register           recv_klass,
2777                                              Register           intf_klass,
2778                                              RegisterOrConstant itable_index,
2779                                              Register           method_result,
2780                                              Register           temp1_reg,
2781                                              Label&amp;             no_such_interface,
2782                                              bool               return_method) {
2783 
2784   const Register vtable_len = temp1_reg;    // Used to compute itable_entry_addr.
2785   const Register itable_entry_addr = Z_R1_scratch;
2786   const Register itable_interface = Z_R0_scratch;
2787 
2788   BLOCK_COMMENT(&quot;lookup_interface_method {&quot;);
2789 
2790   // Load start of itable entries into itable_entry_addr.
2791   z_llgf(vtable_len, Address(recv_klass, Klass::vtable_length_offset()));
2792   z_sllg(vtable_len, vtable_len, exact_log2(vtableEntry::size_in_bytes()));
2793 
2794   // Loop over all itable entries until desired interfaceOop(Rinterface) found.
2795   const int vtable_base_offset = in_bytes(Klass::vtable_start_offset());
2796 
2797   add2reg_with_index(itable_entry_addr,
2798                      vtable_base_offset + itableOffsetEntry::interface_offset_in_bytes(),
2799                      recv_klass, vtable_len);
2800 
2801   const int itable_offset_search_inc = itableOffsetEntry::size() * wordSize;
2802   Label     search;
2803 
2804   bind(search);
2805 
2806   // Handle IncompatibleClassChangeError.
2807   // If the entry is NULL then we&#39;ve reached the end of the table
2808   // without finding the expected interface, so throw an exception.
2809   load_and_test_long(itable_interface, Address(itable_entry_addr));
2810   z_bre(no_such_interface);
2811 
2812   add2reg(itable_entry_addr, itable_offset_search_inc);
2813   z_cgr(itable_interface, intf_klass);
2814   z_brne(search);
2815 
2816   // Entry found and itable_entry_addr points to it, get offset of vtable for interface.
2817   if (return_method) {
2818     const int vtable_offset_offset = (itableOffsetEntry::offset_offset_in_bytes() -
2819                                       itableOffsetEntry::interface_offset_in_bytes()) -
2820                                      itable_offset_search_inc;
2821 
2822     // Compute itableMethodEntry and get method and entry point
2823     // we use addressing with index and displacement, since the formula
2824     // for computing the entry&#39;s offset has a fixed and a dynamic part,
2825     // the latter depending on the matched interface entry and on the case,
2826     // that the itable index has been passed as a register, not a constant value.
2827     int method_offset = itableMethodEntry::method_offset_in_bytes();
2828                              // Fixed part (displacement), common operand.
2829     Register itable_offset = method_result;  // Dynamic part (index register).
2830 
2831     if (itable_index.is_register()) {
2832        // Compute the method&#39;s offset in that register, for the formula, see the
2833        // else-clause below.
2834        z_sllg(itable_offset, itable_index.as_register(), exact_log2(itableMethodEntry::size() * wordSize));
2835        z_agf(itable_offset, vtable_offset_offset, itable_entry_addr);
2836     } else {
2837       // Displacement increases.
2838       method_offset += itableMethodEntry::size() * wordSize * itable_index.as_constant();
2839 
2840       // Load index from itable.
2841       z_llgf(itable_offset, vtable_offset_offset, itable_entry_addr);
2842     }
2843 
2844     // Finally load the method&#39;s oop.
2845     z_lg(method_result, method_offset, itable_offset, recv_klass);
2846   }
2847   BLOCK_COMMENT(&quot;} lookup_interface_method&quot;);
2848 }
2849 
2850 // Lookup for virtual method invocation.
2851 void MacroAssembler::lookup_virtual_method(Register           recv_klass,
2852                                            RegisterOrConstant vtable_index,
2853                                            Register           method_result) {
2854   assert_different_registers(recv_klass, vtable_index.register_or_noreg());
2855   assert(vtableEntry::size() * wordSize == wordSize,
2856          &quot;else adjust the scaling in the code below&quot;);
2857 
2858   BLOCK_COMMENT(&quot;lookup_virtual_method {&quot;);
2859 
2860   const int base = in_bytes(Klass::vtable_start_offset());
2861 
2862   if (vtable_index.is_constant()) {
2863     // Load with base + disp.
2864     Address vtable_entry_addr(recv_klass,
2865                               vtable_index.as_constant() * wordSize +
2866                               base +
2867                               vtableEntry::method_offset_in_bytes());
2868 
2869     z_lg(method_result, vtable_entry_addr);
2870   } else {
2871     // Shift index properly and load with base + index + disp.
2872     Register vindex = vtable_index.as_register();
2873     Address  vtable_entry_addr(recv_klass, vindex,
2874                                base + vtableEntry::method_offset_in_bytes());
2875 
2876     z_sllg(vindex, vindex, exact_log2(wordSize));
2877     z_lg(method_result, vtable_entry_addr);
2878   }
2879   BLOCK_COMMENT(&quot;} lookup_virtual_method&quot;);
2880 }
2881 
2882 // Factor out code to call ic_miss_handler.
2883 // Generate code to call the inline cache miss handler.
2884 //
2885 // In most cases, this code will be generated out-of-line.
2886 // The method parameters are intended to provide some variability.
2887 //   ICM          - Label which has to be bound to the start of useful code (past any traps).
2888 //   trapMarker   - Marking byte for the generated illtrap instructions (if any).
2889 //                  Any value except 0x00 is supported.
2890 //                  = 0x00 - do not generate illtrap instructions.
2891 //                         use nops to fill ununsed space.
2892 //   requiredSize - required size of the generated code. If the actually
2893 //                  generated code is smaller, use padding instructions to fill up.
2894 //                  = 0 - no size requirement, no padding.
2895 //   scratch      - scratch register to hold branch target address.
2896 //
2897 //  The method returns the code offset of the bound label.
2898 unsigned int MacroAssembler::call_ic_miss_handler(Label&amp; ICM, int trapMarker, int requiredSize, Register scratch) {
2899   intptr_t startOffset = offset();
2900 
2901   // Prevent entry at content_begin().
2902   if (trapMarker != 0) {
2903     z_illtrap(trapMarker);
2904   }
2905 
2906   // Load address of inline cache miss code into scratch register
2907   // and branch to cache miss handler.
2908   BLOCK_COMMENT(&quot;IC miss handler {&quot;);
2909   BIND(ICM);
2910   unsigned int   labelOffset = offset();
2911   AddressLiteral icmiss(SharedRuntime::get_ic_miss_stub());
2912 
2913   load_const_optimized(scratch, icmiss);
2914   z_br(scratch);
2915 
2916   // Fill unused space.
2917   if (requiredSize &gt; 0) {
2918     while ((offset() - startOffset) &lt; requiredSize) {
2919       if (trapMarker == 0) {
2920         z_nop();
2921       } else {
2922         z_illtrap(trapMarker);
2923       }
2924     }
2925   }
2926   BLOCK_COMMENT(&quot;} IC miss handler&quot;);
2927   return labelOffset;
2928 }
2929 
2930 void MacroAssembler::nmethod_UEP(Label&amp; ic_miss) {
2931   Register ic_reg       = Z_inline_cache;
2932   int      klass_offset = oopDesc::klass_offset_in_bytes();
2933   if (!ImplicitNullChecks || MacroAssembler::needs_explicit_null_check(klass_offset)) {
2934     if (VM_Version::has_CompareBranch()) {
2935       z_cgij(Z_ARG1, 0, Assembler::bcondEqual, ic_miss);
2936     } else {
2937       z_ltgr(Z_ARG1, Z_ARG1);
2938       z_bre(ic_miss);
2939     }
2940   }
2941   // Compare cached class against klass from receiver.
2942   compare_klass_ptr(ic_reg, klass_offset, Z_ARG1, false);
2943   z_brne(ic_miss);
2944 }
2945 
2946 void MacroAssembler::check_klass_subtype_fast_path(Register   sub_klass,
2947                                                    Register   super_klass,
2948                                                    Register   temp1_reg,
2949                                                    Label*     L_success,
2950                                                    Label*     L_failure,
2951                                                    Label*     L_slow_path,
2952                                                    RegisterOrConstant super_check_offset) {
2953 
2954   const int sc_offset  = in_bytes(Klass::secondary_super_cache_offset());
2955   const int sco_offset = in_bytes(Klass::super_check_offset_offset());
2956 
2957   bool must_load_sco = (super_check_offset.constant_or_zero() == -1);
2958   bool need_slow_path = (must_load_sco ||
2959                          super_check_offset.constant_or_zero() == sc_offset);
2960 
2961   // Input registers must not overlap.
2962   assert_different_registers(sub_klass, super_klass, temp1_reg);
2963   if (super_check_offset.is_register()) {
2964     assert_different_registers(sub_klass, super_klass,
2965                                super_check_offset.as_register());
2966   } else if (must_load_sco) {
2967     assert(temp1_reg != noreg, &quot;supply either a temp or a register offset&quot;);
2968   }
2969 
2970   const Register Rsuper_check_offset = temp1_reg;
2971 
2972   NearLabel L_fallthrough;
2973   int label_nulls = 0;
2974   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
2975   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
2976   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
2977   assert(label_nulls &lt;= 1 ||
2978          (L_slow_path == &amp;L_fallthrough &amp;&amp; label_nulls &lt;= 2 &amp;&amp; !need_slow_path),
2979          &quot;at most one NULL in the batch, usually&quot;);
2980 
2981   BLOCK_COMMENT(&quot;check_klass_subtype_fast_path {&quot;);
2982   // If the pointers are equal, we are done (e.g., String[] elements).
2983   // This self-check enables sharing of secondary supertype arrays among
2984   // non-primary types such as array-of-interface. Otherwise, each such
2985   // type would need its own customized SSA.
2986   // We move this check to the front of the fast path because many
2987   // type checks are in fact trivially successful in this manner,
2988   // so we get a nicely predicted branch right at the start of the check.
2989   compare64_and_branch(sub_klass, super_klass, bcondEqual, *L_success);
2990 
2991   // Check the supertype display, which is uint.
2992   if (must_load_sco) {
2993     z_llgf(Rsuper_check_offset, sco_offset, super_klass);
2994     super_check_offset = RegisterOrConstant(Rsuper_check_offset);
2995   }
2996   Address super_check_addr(sub_klass, super_check_offset, 0);
2997   z_cg(super_klass, super_check_addr); // compare w/ displayed supertype
2998 
2999   // This check has worked decisively for primary supers.
3000   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
3001   // (Secondary supers are interfaces and very deeply nested subtypes.)
3002   // This works in the same check above because of a tricky aliasing
3003   // between the super_cache and the primary super display elements.
3004   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
3005   // Note that the cache is updated below if it does not help us find
3006   // what we need immediately.
3007   // So if it was a primary super, we can just fail immediately.
3008   // Otherwise, it&#39;s the slow path for us (no success at this point).
3009 
3010   // Hacked jmp, which may only be used just before L_fallthrough.
3011 #define final_jmp(label)                                                \
3012   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
3013   else                            { branch_optimized(Assembler::bcondAlways, label); } /*omit semicolon*/
3014 
3015   if (super_check_offset.is_register()) {
3016     branch_optimized(Assembler::bcondEqual, *L_success);
3017     z_cfi(super_check_offset.as_register(), sc_offset);
3018     if (L_failure == &amp;L_fallthrough) {
3019       branch_optimized(Assembler::bcondEqual, *L_slow_path);
3020     } else {
3021       branch_optimized(Assembler::bcondNotEqual, *L_failure);
3022       final_jmp(*L_slow_path);
3023     }
3024   } else if (super_check_offset.as_constant() == sc_offset) {
3025     // Need a slow path; fast failure is impossible.
3026     if (L_slow_path == &amp;L_fallthrough) {
3027       branch_optimized(Assembler::bcondEqual, *L_success);
3028     } else {
3029       branch_optimized(Assembler::bcondNotEqual, *L_slow_path);
3030       final_jmp(*L_success);
3031     }
3032   } else {
3033     // No slow path; it&#39;s a fast decision.
3034     if (L_failure == &amp;L_fallthrough) {
3035       branch_optimized(Assembler::bcondEqual, *L_success);
3036     } else {
3037       branch_optimized(Assembler::bcondNotEqual, *L_failure);
3038       final_jmp(*L_success);
3039     }
3040   }
3041 
3042   bind(L_fallthrough);
3043 #undef local_brc
3044 #undef final_jmp
3045   BLOCK_COMMENT(&quot;} check_klass_subtype_fast_path&quot;);
3046   // fallthru (to slow path)
3047 }
3048 
3049 void MacroAssembler::check_klass_subtype_slow_path(Register Rsubklass,
3050                                                    Register Rsuperklass,
3051                                                    Register Rarray_ptr,  // tmp
3052                                                    Register Rlength,     // tmp
3053                                                    Label* L_success,
3054                                                    Label* L_failure) {
3055   // Input registers must not overlap.
3056   // Also check for R1 which is explicitely used here.
3057   assert_different_registers(Z_R1, Rsubklass, Rsuperklass, Rarray_ptr, Rlength);
3058   NearLabel L_fallthrough;
3059   int label_nulls = 0;
3060   if (L_success == NULL) { L_success = &amp;L_fallthrough; label_nulls++; }
3061   if (L_failure == NULL) { L_failure = &amp;L_fallthrough; label_nulls++; }
3062   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
3063 
3064   const int ss_offset = in_bytes(Klass::secondary_supers_offset());
3065   const int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
3066 
3067   const int length_offset = Array&lt;Klass*&gt;::length_offset_in_bytes();
3068   const int base_offset   = Array&lt;Klass*&gt;::base_offset_in_bytes();
3069 
3070   // Hacked jmp, which may only be used just before L_fallthrough.
3071 #define final_jmp(label)                                                \
3072   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
3073   else                            branch_optimized(Assembler::bcondAlways, label) /*omit semicolon*/
3074 
3075   NearLabel loop_iterate, loop_count, match;
3076 
3077   BLOCK_COMMENT(&quot;check_klass_subtype_slow_path {&quot;);
3078   z_lg(Rarray_ptr, ss_offset, Rsubklass);
3079 
3080   load_and_test_int(Rlength, Address(Rarray_ptr, length_offset));
3081   branch_optimized(Assembler::bcondZero, *L_failure);
3082 
3083   // Oops in table are NO MORE compressed.
3084   z_cg(Rsuperklass, base_offset, Rarray_ptr); // Check array element for match.
3085   z_bre(match);                               // Shortcut for array length = 1.
3086 
3087   // No match yet, so we must walk the array&#39;s elements.
3088   z_lngfr(Rlength, Rlength);
3089   z_sllg(Rlength, Rlength, LogBytesPerWord); // -#bytes of cache array
3090   z_llill(Z_R1, BytesPerWord);               // Set increment/end index.
3091   add2reg(Rlength, 2 * BytesPerWord);        // start index  = -(n-2)*BytesPerWord
3092   z_slgr(Rarray_ptr, Rlength);               // start addr: +=  (n-2)*BytesPerWord
3093   z_bru(loop_count);
3094 
3095   BIND(loop_iterate);
3096   z_cg(Rsuperklass, base_offset, Rlength, Rarray_ptr); // Check array element for match.
3097   z_bre(match);
3098   BIND(loop_count);
3099   z_brxlg(Rlength, Z_R1, loop_iterate);
3100 
3101   // Rsuperklass not found among secondary super classes -&gt; failure.
3102   branch_optimized(Assembler::bcondAlways, *L_failure);
3103 
3104   // Got a hit. Return success (zero result). Set cache.
3105   // Cache load doesn&#39;t happen here. For speed it is directly emitted by the compiler.
3106 
3107   BIND(match);
3108 
3109   z_stg(Rsuperklass, sc_offset, Rsubklass); // Save result to cache.
3110 
3111   final_jmp(*L_success);
3112 
3113   // Exit to the surrounding code.
3114   BIND(L_fallthrough);
3115 #undef local_brc
3116 #undef final_jmp
3117   BLOCK_COMMENT(&quot;} check_klass_subtype_slow_path&quot;);
3118 }
3119 
3120 // Emitter for combining fast and slow path.
3121 void MacroAssembler::check_klass_subtype(Register sub_klass,
3122                                          Register super_klass,
3123                                          Register temp1_reg,
3124                                          Register temp2_reg,
3125                                          Label&amp;   L_success) {
3126   NearLabel failure;
3127   BLOCK_COMMENT(err_msg(&quot;check_klass_subtype(%s subclass of %s) {&quot;, sub_klass-&gt;name(), super_klass-&gt;name()));
3128   check_klass_subtype_fast_path(sub_klass, super_klass, temp1_reg,
3129                                 &amp;L_success, &amp;failure, NULL);
3130   check_klass_subtype_slow_path(sub_klass, super_klass,
3131                                 temp1_reg, temp2_reg, &amp;L_success, NULL);
3132   BIND(failure);
3133   BLOCK_COMMENT(&quot;} check_klass_subtype&quot;);
3134 }
3135 
3136 void MacroAssembler::clinit_barrier(Register klass, Register thread, Label* L_fast_path, Label* L_slow_path) {
3137   assert(L_fast_path != NULL || L_slow_path != NULL, &quot;at least one is required&quot;);
3138 
3139   Label L_fallthrough;
3140   if (L_fast_path == NULL) {
3141     L_fast_path = &amp;L_fallthrough;
3142   } else if (L_slow_path == NULL) {
3143     L_slow_path = &amp;L_fallthrough;
3144   }
3145 
3146   // Fast path check: class is fully initialized
3147   z_cli(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
3148   z_bre(*L_fast_path);
3149 
3150   // Fast path check: current thread is initializer thread
3151   z_cg(thread, Address(klass, InstanceKlass::init_thread_offset()));
3152   if (L_slow_path == &amp;L_fallthrough) {
3153     z_bre(*L_fast_path);
3154   } else if (L_fast_path == &amp;L_fallthrough) {
3155     z_brne(*L_slow_path);
3156   } else {
3157     Unimplemented();
3158   }
3159 
3160   bind(L_fallthrough);
3161 }
3162 
3163 // Increment a counter at counter_address when the eq condition code is
3164 // set. Kills registers tmp1_reg and tmp2_reg and preserves the condition code.
3165 void MacroAssembler::increment_counter_eq(address counter_address, Register tmp1_reg, Register tmp2_reg) {
3166   Label l;
3167   z_brne(l);
3168   load_const(tmp1_reg, counter_address);
3169   add2mem_32(Address(tmp1_reg), 1, tmp2_reg);
3170   z_cr(tmp1_reg, tmp1_reg); // Set cc to eq.
3171   bind(l);
3172 }
3173 
3174 // Semantics are dependent on the slow_case label:
3175 //   If the slow_case label is not NULL, failure to biased-lock the object
3176 //   transfers control to the location of the slow_case label. If the
3177 //   object could be biased-locked, control is transferred to the done label.
3178 //   The condition code is unpredictable.
3179 //
3180 //   If the slow_case label is NULL, failure to biased-lock the object results
3181 //   in a transfer of control to the done label with a condition code of not_equal.
3182 //   If the biased-lock could be successfully obtained, control is transfered to
3183 //   the done label with a condition code of equal.
3184 //   It is mandatory to react on the condition code At the done label.
3185 //
3186 void MacroAssembler::biased_locking_enter(Register  obj_reg,
3187                                           Register  mark_reg,
3188                                           Register  temp_reg,
3189                                           Register  temp2_reg,    // May be Z_RO!
3190                                           Label    &amp;done,
3191                                           Label    *slow_case) {
3192   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
3193   assert_different_registers(obj_reg, mark_reg, temp_reg, temp2_reg);
3194 
3195   Label cas_label; // Try, if implemented, CAS locking. Fall thru to slow path otherwise.
3196 
3197   BLOCK_COMMENT(&quot;biased_locking_enter {&quot;);
3198 
3199   // Biased locking
3200   // See whether the lock is currently biased toward our thread and
3201   // whether the epoch is still valid.
3202   // Note that the runtime guarantees sufficient alignment of JavaThread
3203   // pointers to allow age to be placed into low bits.
3204   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits,
3205          &quot;biased locking makes assumptions about bit layout&quot;);
3206   z_lr(temp_reg, mark_reg);
3207   z_nilf(temp_reg, markWord::biased_lock_mask_in_place);
3208   z_chi(temp_reg, markWord::biased_lock_pattern);
3209   z_brne(cas_label);  // Try cas if object is not biased, i.e. cannot be biased locked.
3210 
3211   load_prototype_header(temp_reg, obj_reg);
3212   load_const_optimized(temp2_reg, ~((int) markWord::age_mask_in_place));
3213 
3214   z_ogr(temp_reg, Z_thread);
3215   z_xgr(temp_reg, mark_reg);
3216   z_ngr(temp_reg, temp2_reg);
3217   if (PrintBiasedLockingStatistics) {
3218     increment_counter_eq((address) BiasedLocking::biased_lock_entry_count_addr(), mark_reg, temp2_reg);
3219     // Restore mark_reg.
3220     z_lg(mark_reg, oopDesc::mark_offset_in_bytes(), obj_reg);
3221   }
3222   branch_optimized(Assembler::bcondEqual, done);  // Biased lock obtained, return success.
3223 
3224   Label try_revoke_bias;
3225   Label try_rebias;
3226   Address mark_addr = Address(obj_reg, oopDesc::mark_offset_in_bytes());
3227 
3228   //----------------------------------------------------------------------------
3229   // At this point we know that the header has the bias pattern and
3230   // that we are not the bias owner in the current epoch. We need to
3231   // figure out more details about the state of the header in order to
3232   // know what operations can be legally performed on the object&#39;s
3233   // header.
3234 
3235   // If the low three bits in the xor result aren&#39;t clear, that means
3236   // the prototype header is no longer biased and we have to revoke
3237   // the bias on this object.
3238   z_tmll(temp_reg, markWord::biased_lock_mask_in_place);
3239   z_brnaz(try_revoke_bias);
3240 
3241   // Biasing is still enabled for this data type. See whether the
3242   // epoch of the current bias is still valid, meaning that the epoch
3243   // bits of the mark word are equal to the epoch bits of the
3244   // prototype header. (Note that the prototype header&#39;s epoch bits
3245   // only change at a safepoint.) If not, attempt to rebias the object
3246   // toward the current thread. Note that we must be absolutely sure
3247   // that the current epoch is invalid in order to do this because
3248   // otherwise the manipulations it performs on the mark word are
3249   // illegal.
3250   z_tmll(temp_reg, markWord::epoch_mask_in_place);
3251   z_brnaz(try_rebias);
3252 
3253   //----------------------------------------------------------------------------
3254   // The epoch of the current bias is still valid but we know nothing
3255   // about the owner; it might be set or it might be clear. Try to
3256   // acquire the bias of the object using an atomic operation. If this
3257   // fails we will go in to the runtime to revoke the object&#39;s bias.
3258   // Note that we first construct the presumed unbiased header so we
3259   // don&#39;t accidentally blow away another thread&#39;s valid bias.
3260   z_nilf(mark_reg, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place |
3261          markWord::epoch_mask_in_place);
3262   z_lgr(temp_reg, Z_thread);
3263   z_llgfr(mark_reg, mark_reg);
3264   z_ogr(temp_reg, mark_reg);
3265 
3266   assert(oopDesc::mark_offset_in_bytes() == 0, &quot;offset of _mark is not 0&quot;);
3267 
3268   z_csg(mark_reg, temp_reg, 0, obj_reg);
3269 
3270   // If the biasing toward our thread failed, this means that
3271   // another thread succeeded in biasing it toward itself and we
3272   // need to revoke that bias. The revocation will occur in the
3273   // interpreter runtime in the slow case.
3274 
3275   if (PrintBiasedLockingStatistics) {
3276     increment_counter_eq((address) BiasedLocking::anonymously_biased_lock_entry_count_addr(),
3277                          temp_reg, temp2_reg);
3278   }
3279   if (slow_case != NULL) {
3280     branch_optimized(Assembler::bcondNotEqual, *slow_case); // Biased lock not obtained, need to go the long way.
3281   }
3282   branch_optimized(Assembler::bcondAlways, done);           // Biased lock status given in condition code.
3283 
3284   //----------------------------------------------------------------------------
3285   bind(try_rebias);
3286   // At this point we know the epoch has expired, meaning that the
3287   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
3288   // circumstances _only_, we are allowed to use the current header&#39;s
3289   // value as the comparison value when doing the cas to acquire the
3290   // bias in the current epoch. In other words, we allow transfer of
3291   // the bias from one thread to another directly in this situation.
3292 
3293   z_nilf(mark_reg, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);
3294   load_prototype_header(temp_reg, obj_reg);
3295   z_llgfr(mark_reg, mark_reg);
3296 
3297   z_ogr(temp_reg, Z_thread);
3298 
3299   assert(oopDesc::mark_offset_in_bytes() == 0, &quot;offset of _mark is not 0&quot;);
3300 
3301   z_csg(mark_reg, temp_reg, 0, obj_reg);
3302 
3303   // If the biasing toward our thread failed, this means that
3304   // another thread succeeded in biasing it toward itself and we
3305   // need to revoke that bias. The revocation will occur in the
3306   // interpreter runtime in the slow case.
3307 
3308   if (PrintBiasedLockingStatistics) {
3309     increment_counter_eq((address) BiasedLocking::rebiased_lock_entry_count_addr(), temp_reg, temp2_reg);
3310   }
3311   if (slow_case != NULL) {
3312     branch_optimized(Assembler::bcondNotEqual, *slow_case);  // Biased lock not obtained, need to go the long way.
3313   }
3314   z_bru(done);           // Biased lock status given in condition code.
3315 
3316   //----------------------------------------------------------------------------
3317   bind(try_revoke_bias);
3318   // The prototype mark in the klass doesn&#39;t have the bias bit set any
3319   // more, indicating that objects of this data type are not supposed
3320   // to be biased any more. We are going to try to reset the mark of
3321   // this object to the prototype value and fall through to the
3322   // CAS-based locking scheme. Note that if our CAS fails, it means
3323   // that another thread raced us for the privilege of revoking the
3324   // bias of this particular object, so it&#39;s okay to continue in the
3325   // normal locking code.
3326   load_prototype_header(temp_reg, obj_reg);
3327 
3328   assert(oopDesc::mark_offset_in_bytes() == 0, &quot;offset of _mark is not 0&quot;);
3329 
3330   z_csg(mark_reg, temp_reg, 0, obj_reg);
3331 
3332   // Fall through to the normal CAS-based lock, because no matter what
3333   // the result of the above CAS, some thread must have succeeded in
3334   // removing the bias bit from the object&#39;s header.
3335   if (PrintBiasedLockingStatistics) {
3336     // z_cgr(mark_reg, temp2_reg);
3337     increment_counter_eq((address) BiasedLocking::revoked_lock_entry_count_addr(), temp_reg, temp2_reg);
3338   }
3339 
3340   bind(cas_label);
3341   BLOCK_COMMENT(&quot;} biased_locking_enter&quot;);
3342 }
3343 
3344 void MacroAssembler::biased_locking_exit(Register mark_addr, Register temp_reg, Label&amp; done) {
3345   // Check for biased locking unlock case, which is a no-op
3346   // Note: we do not have to check the thread ID for two reasons.
3347   // First, the interpreter checks for IllegalMonitorStateException at
3348   // a higher level. Second, if the bias was revoked while we held the
3349   // lock, the object could not be rebiased toward another thread, so
3350   // the bias bit would be clear.
3351   BLOCK_COMMENT(&quot;biased_locking_exit {&quot;);
3352 
3353   z_lg(temp_reg, 0, mark_addr);
3354   z_nilf(temp_reg, markWord::biased_lock_mask_in_place);
3355 
3356   z_chi(temp_reg, markWord::biased_lock_pattern);
3357   z_bre(done);
3358   BLOCK_COMMENT(&quot;} biased_locking_exit&quot;);
3359 }
3360 
3361 void MacroAssembler::compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias) {
3362   Register displacedHeader = temp1;
3363   Register currentHeader = temp1;
3364   Register temp = temp2;
3365   NearLabel done, object_has_monitor;
3366 
3367   BLOCK_COMMENT(&quot;compiler_fast_lock_object {&quot;);
3368 
3369   // Load markWord from oop into mark.
3370   z_lg(displacedHeader, 0, oop);
3371 
3372   if (try_bias) {
3373     biased_locking_enter(oop, displacedHeader, temp, Z_R0, done);
3374   }
3375 
3376   // Handle existing monitor.
3377   // The object has an existing monitor iff (mark &amp; monitor_value) != 0.
3378   guarantee(Immediate::is_uimm16(markWord::monitor_value), &quot;must be half-word&quot;);
3379   z_lr(temp, displacedHeader);
3380   z_nill(temp, markWord::monitor_value);
3381   z_brne(object_has_monitor);
3382 
3383   // Set mark to markWord | markWord::unlocked_value.
3384   z_oill(displacedHeader, markWord::unlocked_value);
3385 
3386   // Load Compare Value application register.
3387 
3388   // Initialize the box (must happen before we update the object mark).
3389   z_stg(displacedHeader, BasicLock::displaced_header_offset_in_bytes(), box);
3390 
3391   // Memory Fence (in cmpxchgd)
3392   // Compare object markWord with mark and if equal exchange scratch1 with object markWord.
3393 
3394   // If the compare-and-swap succeeded, then we found an unlocked object and we
3395   // have now locked it.
3396   z_csg(displacedHeader, box, 0, oop);
3397   assert(currentHeader==displacedHeader, &quot;must be same register&quot;); // Identified two registers from z/Architecture.
3398   z_bre(done);
3399 
3400   // We did not see an unlocked object so try the fast recursive case.
3401 
3402   z_sgr(currentHeader, Z_SP);
3403   load_const_optimized(temp, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));
3404 
3405   z_ngr(currentHeader, temp);
3406   //   z_brne(done);
3407   //   z_release();
3408   z_stg(currentHeader/*==0 or not 0*/, BasicLock::displaced_header_offset_in_bytes(), box);
3409 
3410   z_bru(done);
3411 
3412   Register zero = temp;
3413   Register monitor_tagged = displacedHeader; // Tagged with markWord::monitor_value.
3414   bind(object_has_monitor);
3415   // The object&#39;s monitor m is unlocked iff m-&gt;owner == NULL,
3416   // otherwise m-&gt;owner may contain a thread or a stack address.
3417   //
3418   // Try to CAS m-&gt;owner from NULL to current thread.
3419   z_lghi(zero, 0);
3420   // If m-&gt;owner is null, then csg succeeds and sets m-&gt;owner=THREAD and CR=EQ.
3421   z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor_tagged);
3422   // Store a non-null value into the box.
3423   z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);
3424 #ifdef ASSERT
3425   z_brne(done);
3426   // We&#39;ve acquired the monitor, check some invariants.
3427   // Invariant 1: _recursions should be 0.
3428   asm_assert_mem8_is_zero(OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions), monitor_tagged,
3429                           &quot;monitor-&gt;_recursions should be 0&quot;, -1);
3430   z_ltgr(zero, zero); // Set CR=EQ.
3431 #endif
3432   bind(done);
3433 
3434   BLOCK_COMMENT(&quot;} compiler_fast_lock_object&quot;);
3435   // If locking was successful, CR should indicate &#39;EQ&#39;.
3436   // The compiler or the native wrapper generates a branch to the runtime call
3437   // _complete_monitor_locking_Java.
3438 }
3439 
3440 void MacroAssembler::compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2, bool try_bias) {
3441   Register displacedHeader = temp1;
3442   Register currentHeader = temp2;
3443   Register temp = temp1;
3444   Register monitor = temp2;
3445 
3446   Label done, object_has_monitor;
3447 
3448   BLOCK_COMMENT(&quot;compiler_fast_unlock_object {&quot;);
3449 
3450   if (try_bias) {
3451     biased_locking_exit(oop, currentHeader, done);
3452   }
3453 
3454   // Find the lock address and load the displaced header from the stack.
3455   // if the displaced header is zero, we have a recursive unlock.
3456   load_and_test_long(displacedHeader, Address(box, BasicLock::displaced_header_offset_in_bytes()));
3457   z_bre(done);
3458 
3459   // Handle existing monitor.
3460   // The object has an existing monitor iff (mark &amp; monitor_value) != 0.
3461   z_lg(currentHeader, oopDesc::mark_offset_in_bytes(), oop);
3462   guarantee(Immediate::is_uimm16(markWord::monitor_value), &quot;must be half-word&quot;);
3463   z_nill(currentHeader, markWord::monitor_value);
3464   z_brne(object_has_monitor);
3465 
3466   // Check if it is still a light weight lock, this is true if we see
3467   // the stack address of the basicLock in the markWord of the object
3468   // copy box to currentHeader such that csg does not kill it.
3469   z_lgr(currentHeader, box);
3470   z_csg(currentHeader, displacedHeader, 0, oop);
3471   z_bru(done); // Csg sets CR as desired.
3472 
3473   // Handle existing monitor.
3474   bind(object_has_monitor);
3475   z_lg(currentHeader, oopDesc::mark_offset_in_bytes(), oop);    // CurrentHeader is tagged with monitor_value set.
3476   load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));
3477   z_brne(done);
3478   load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));
3479   z_brne(done);
3480   load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));
3481   z_brne(done);
3482   load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));
3483   z_brne(done);
3484   z_release();
3485   z_stg(temp/*=0*/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), currentHeader);
3486 
3487   bind(done);
3488 
3489   BLOCK_COMMENT(&quot;} compiler_fast_unlock_object&quot;);
3490   // flag == EQ indicates success
3491   // flag == NE indicates failure
3492 }
3493 
3494 void MacroAssembler::resolve_jobject(Register value, Register tmp1, Register tmp2) {
3495   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3496   bs-&gt;resolve_jobject(this, value, tmp1, tmp2);
3497 }
3498 
3499 // Last_Java_sp must comply to the rules in frame_s390.hpp.
3500 void MacroAssembler::set_last_Java_frame(Register last_Java_sp, Register last_Java_pc, bool allow_relocation) {
3501   BLOCK_COMMENT(&quot;set_last_Java_frame {&quot;);
3502 
3503   // Always set last_Java_pc and flags first because once last_Java_sp
3504   // is visible has_last_Java_frame is true and users will look at the
3505   // rest of the fields. (Note: flags should always be zero before we
3506   // get here so doesn&#39;t need to be set.)
3507 
3508   // Verify that last_Java_pc was zeroed on return to Java.
3509   if (allow_relocation) {
3510     asm_assert_mem8_is_zero(in_bytes(JavaThread::last_Java_pc_offset()),
3511                             Z_thread,
3512                             &quot;last_Java_pc not zeroed before leaving Java&quot;,
3513                             0x200);
3514   } else {
3515     asm_assert_mem8_is_zero_static(in_bytes(JavaThread::last_Java_pc_offset()),
3516                                    Z_thread,
3517                                    &quot;last_Java_pc not zeroed before leaving Java&quot;,
3518                                    0x200);
3519   }
3520 
3521   // When returning from calling out from Java mode the frame anchor&#39;s
3522   // last_Java_pc will always be set to NULL. It is set here so that
3523   // if we are doing a call to native (not VM) that we capture the
3524   // known pc and don&#39;t have to rely on the native call having a
3525   // standard frame linkage where we can find the pc.
3526   if (last_Java_pc!=noreg) {
3527     z_stg(last_Java_pc, Address(Z_thread, JavaThread::last_Java_pc_offset()));
3528   }
3529 
3530   // This membar release is not required on z/Architecture, since the sequence of stores
3531   // in maintained. Nevertheless, we leave it in to document the required ordering.
3532   // The implementation of z_release() should be empty.
3533   // z_release();
3534 
3535   z_stg(last_Java_sp, Address(Z_thread, JavaThread::last_Java_sp_offset()));
3536   BLOCK_COMMENT(&quot;} set_last_Java_frame&quot;);
3537 }
3538 
3539 void MacroAssembler::reset_last_Java_frame(bool allow_relocation) {
3540   BLOCK_COMMENT(&quot;reset_last_Java_frame {&quot;);
3541 
3542   if (allow_relocation) {
3543     asm_assert_mem8_isnot_zero(in_bytes(JavaThread::last_Java_sp_offset()),
3544                                Z_thread,
3545                                &quot;SP was not set, still zero&quot;,
3546                                0x202);
3547   } else {
3548     asm_assert_mem8_isnot_zero_static(in_bytes(JavaThread::last_Java_sp_offset()),
3549                                       Z_thread,
3550                                       &quot;SP was not set, still zero&quot;,
3551                                       0x202);
3552   }
3553 
3554   // _last_Java_sp = 0
3555   // Clearing storage must be atomic here, so don&#39;t use clear_mem()!
3556   store_const(Address(Z_thread, JavaThread::last_Java_sp_offset()), 0);
3557 
3558   // _last_Java_pc = 0
3559   store_const(Address(Z_thread, JavaThread::last_Java_pc_offset()), 0);
3560 
3561   BLOCK_COMMENT(&quot;} reset_last_Java_frame&quot;);
3562   return;
3563 }
3564 
3565 void MacroAssembler::set_top_ijava_frame_at_SP_as_last_Java_frame(Register sp, Register tmp1, bool allow_relocation) {
3566   assert_different_registers(sp, tmp1);
3567 
3568   // We cannot trust that code generated by the C++ compiler saves R14
3569   // to z_abi_160.return_pc, because sometimes it spills R14 using stmg at
3570   // z_abi_160.gpr14 (e.g. InterpreterRuntime::_new()).
3571   // Therefore we load the PC into tmp1 and let set_last_Java_frame() save
3572   // it into the frame anchor.
3573   get_PC(tmp1);
3574   set_last_Java_frame(/*sp=*/sp, /*pc=*/tmp1, allow_relocation);
3575 }
3576 
3577 void MacroAssembler::set_thread_state(JavaThreadState new_state) {
3578   z_release();
3579 
3580   assert(Immediate::is_uimm16(_thread_max_state), &quot;enum value out of range for instruction&quot;);
3581   assert(sizeof(JavaThreadState) == sizeof(int), &quot;enum value must have base type int&quot;);
3582   store_const(Address(Z_thread, JavaThread::thread_state_offset()), new_state, Z_R0, false);
3583 }
3584 
3585 void MacroAssembler::get_vm_result(Register oop_result) {
3586   verify_thread();
3587 
3588   z_lg(oop_result, Address(Z_thread, JavaThread::vm_result_offset()));
3589   clear_mem(Address(Z_thread, JavaThread::vm_result_offset()), sizeof(void*));
3590 
3591   verify_oop(oop_result, FILE_AND_LINE);
3592 }
3593 
3594 void MacroAssembler::get_vm_result_2(Register result) {
3595   verify_thread();
3596 
3597   z_lg(result, Address(Z_thread, JavaThread::vm_result_2_offset()));
3598   clear_mem(Address(Z_thread, JavaThread::vm_result_2_offset()), sizeof(void*));
3599 }
3600 
3601 // We require that C code which does not return a value in vm_result will
3602 // leave it undisturbed.
3603 void MacroAssembler::set_vm_result(Register oop_result) {
3604   z_stg(oop_result, Address(Z_thread, JavaThread::vm_result_offset()));
3605 }
3606 
3607 // Explicit null checks (used for method handle code).
3608 void MacroAssembler::null_check(Register reg, Register tmp, int64_t offset) {
3609   if (!ImplicitNullChecks) {
3610     NearLabel ok;
3611 
3612     compare64_and_branch(reg, (intptr_t) 0, Assembler::bcondNotEqual, ok);
3613 
3614     // We just put the address into reg if it was 0 (tmp==Z_R0 is allowed so we can&#39;t use it for the address).
3615     address exception_entry = Interpreter::throw_NullPointerException_entry();
3616     load_absolute_address(reg, exception_entry);
3617     z_br(reg);
3618 
3619     bind(ok);
3620   } else {
3621     if (needs_explicit_null_check((intptr_t)offset)) {
3622       // Provoke OS NULL exception if reg = NULL by
3623       // accessing M[reg] w/o changing any registers.
3624       z_lg(tmp, 0, reg);
3625     }
3626     // else
3627       // Nothing to do, (later) access of M[reg + offset]
3628       // will provoke OS NULL exception if reg = NULL.
3629   }
3630 }
3631 
3632 //-------------------------------------
3633 //  Compressed Klass Pointers
3634 //-------------------------------------
3635 
3636 // Klass oop manipulations if compressed.
3637 void MacroAssembler::encode_klass_not_null(Register dst, Register src) {
3638   Register current = (src != noreg) ? src : dst; // Klass is in dst if no src provided. (dst == src) also possible.
3639   address  base    = CompressedKlassPointers::base();
3640   int      shift   = CompressedKlassPointers::shift();
3641   assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
3642 
3643   BLOCK_COMMENT(&quot;cKlass encoder {&quot;);
3644 
3645 #ifdef ASSERT
3646   Label ok;
3647   z_tmll(current, KlassAlignmentInBytes-1); // Check alignment.
3648   z_brc(Assembler::bcondAllZero, ok);
3649   // The plain disassembler does not recognize illtrap. It instead displays
3650   // a 32-bit value. Issueing two illtraps assures the disassembler finds
3651   // the proper beginning of the next instruction.
3652   z_illtrap(0xee);
3653   z_illtrap(0xee);
3654   bind(ok);
3655 #endif
3656 
3657   if (base != NULL) {
3658     unsigned int base_h = ((unsigned long)base)&gt;&gt;32;
3659     unsigned int base_l = (unsigned int)((unsigned long)base);
3660     if ((base_h != 0) &amp;&amp; (base_l == 0) &amp;&amp; VM_Version::has_HighWordInstr()) {
3661       lgr_if_needed(dst, current);
3662       z_aih(dst, -((int)base_h));     // Base has no set bits in lower half.
3663     } else if ((base_h == 0) &amp;&amp; (base_l != 0)) {
3664       lgr_if_needed(dst, current);
3665       z_agfi(dst, -(int)base_l);
3666     } else {
3667       load_const(Z_R0, base);
3668       lgr_if_needed(dst, current);
3669       z_sgr(dst, Z_R0);
3670     }
3671     current = dst;
3672   }
3673   if (shift != 0) {
3674     assert (LogKlassAlignmentInBytes == shift, &quot;decode alg wrong&quot;);
3675     z_srlg(dst, current, shift);
3676     current = dst;
3677   }
3678   lgr_if_needed(dst, current); // Move may be required (if neither base nor shift != 0).
3679 
3680   BLOCK_COMMENT(&quot;} cKlass encoder&quot;);
3681 }
3682 
3683 // This function calculates the size of the code generated by
3684 //   decode_klass_not_null(register dst, Register src)
3685 // when (Universe::heap() != NULL). Hence, if the instructions
3686 // it generates change, then this method needs to be updated.
3687 int MacroAssembler::instr_size_for_decode_klass_not_null() {
3688   address  base    = CompressedKlassPointers::base();
3689   int shift_size   = CompressedKlassPointers::shift() == 0 ? 0 : 6; /* sllg */
3690   int addbase_size = 0;
3691   assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
3692 
3693   if (base != NULL) {
3694     unsigned int base_h = ((unsigned long)base)&gt;&gt;32;
3695     unsigned int base_l = (unsigned int)((unsigned long)base);
3696     if ((base_h != 0) &amp;&amp; (base_l == 0) &amp;&amp; VM_Version::has_HighWordInstr()) {
3697       addbase_size += 6; /* aih */
3698     } else if ((base_h == 0) &amp;&amp; (base_l != 0)) {
3699       addbase_size += 6; /* algfi */
3700     } else {
3701       addbase_size += load_const_size();
3702       addbase_size += 4; /* algr */
3703     }
3704   }
3705 #ifdef ASSERT
3706   addbase_size += 10;
3707   addbase_size += 2; // Extra sigill.
3708 #endif
3709   return addbase_size + shift_size;
3710 }
3711 
3712 // !!! If the instructions that get generated here change
3713 //     then function instr_size_for_decode_klass_not_null()
3714 //     needs to get updated.
3715 // This variant of decode_klass_not_null() must generate predictable code!
3716 // The code must only depend on globally known parameters.
3717 void MacroAssembler::decode_klass_not_null(Register dst) {
3718   address  base    = CompressedKlassPointers::base();
3719   int      shift   = CompressedKlassPointers::shift();
3720   int      beg_off = offset();
3721   assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
3722 
3723   BLOCK_COMMENT(&quot;cKlass decoder (const size) {&quot;);
3724 
3725   if (shift != 0) { // Shift required?
3726     z_sllg(dst, dst, shift);
3727   }
3728   if (base != NULL) {
3729     unsigned int base_h = ((unsigned long)base)&gt;&gt;32;
3730     unsigned int base_l = (unsigned int)((unsigned long)base);
3731     if ((base_h != 0) &amp;&amp; (base_l == 0) &amp;&amp; VM_Version::has_HighWordInstr()) {
3732       z_aih(dst, base_h);     // Base has no set bits in lower half.
3733     } else if ((base_h == 0) &amp;&amp; (base_l != 0)) {
3734       z_algfi(dst, base_l);   // Base has no set bits in upper half.
3735     } else {
3736       load_const(Z_R0, base); // Base has set bits everywhere.
3737       z_algr(dst, Z_R0);
3738     }
3739   }
3740 
3741 #ifdef ASSERT
3742   Label ok;
3743   z_tmll(dst, KlassAlignmentInBytes-1); // Check alignment.
3744   z_brc(Assembler::bcondAllZero, ok);
3745   // The plain disassembler does not recognize illtrap. It instead displays
3746   // a 32-bit value. Issueing two illtraps assures the disassembler finds
3747   // the proper beginning of the next instruction.
3748   z_illtrap(0xd1);
3749   z_illtrap(0xd1);
3750   bind(ok);
3751 #endif
3752   assert(offset() == beg_off + instr_size_for_decode_klass_not_null(), &quot;Code gen mismatch.&quot;);
3753 
3754   BLOCK_COMMENT(&quot;} cKlass decoder (const size)&quot;);
3755 }
3756 
3757 // This variant of decode_klass_not_null() is for cases where
3758 //  1) the size of the generated instructions may vary
3759 //  2) the result is (potentially) stored in a register different from the source.
3760 void MacroAssembler::decode_klass_not_null(Register dst, Register src) {
3761   address base  = CompressedKlassPointers::base();
3762   int     shift = CompressedKlassPointers::shift();
3763   assert(UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
3764 
3765   BLOCK_COMMENT(&quot;cKlass decoder {&quot;);
3766 
3767   if (src == noreg) src = dst;
3768 
3769   if (shift != 0) { // Shift or at least move required?
3770     z_sllg(dst, src, shift);
3771   } else {
3772     lgr_if_needed(dst, src);
3773   }
3774 
3775   if (base != NULL) {
3776     unsigned int base_h = ((unsigned long)base)&gt;&gt;32;
3777     unsigned int base_l = (unsigned int)((unsigned long)base);
3778     if ((base_h != 0) &amp;&amp; (base_l == 0) &amp;&amp; VM_Version::has_HighWordInstr()) {
3779       z_aih(dst, base_h);     // Base has not set bits in lower half.
3780     } else if ((base_h == 0) &amp;&amp; (base_l != 0)) {
3781       z_algfi(dst, base_l);   // Base has no set bits in upper half.
3782     } else {
3783       load_const_optimized(Z_R0, base); // Base has set bits everywhere.
3784       z_algr(dst, Z_R0);
3785     }
3786   }
3787 
3788 #ifdef ASSERT
3789   Label ok;
3790   z_tmll(dst, KlassAlignmentInBytes-1); // Check alignment.
3791   z_brc(Assembler::bcondAllZero, ok);
3792   // The plain disassembler does not recognize illtrap. It instead displays
3793   // a 32-bit value. Issueing two illtraps assures the disassembler finds
3794   // the proper beginning of the next instruction.
3795   z_illtrap(0xd2);
3796   z_illtrap(0xd2);
3797   bind(ok);
3798 #endif
3799   BLOCK_COMMENT(&quot;} cKlass decoder&quot;);
3800 }
3801 
3802 void MacroAssembler::load_klass(Register klass, Address mem) {
3803   if (UseCompressedClassPointers) {
3804     z_llgf(klass, mem);
3805     // Attention: no null check here!
3806     decode_klass_not_null(klass);
3807   } else {
3808     z_lg(klass, mem);
3809   }
3810 }
3811 
3812 void MacroAssembler::load_klass(Register klass, Register src_oop) {
3813   if (UseCompressedClassPointers) {
3814     z_llgf(klass, oopDesc::klass_offset_in_bytes(), src_oop);
3815     // Attention: no null check here!
3816     decode_klass_not_null(klass);
3817   } else {
3818     z_lg(klass, oopDesc::klass_offset_in_bytes(), src_oop);
3819   }
3820 }
3821 
3822 void MacroAssembler::load_prototype_header(Register Rheader, Register Rsrc_oop) {
3823   assert_different_registers(Rheader, Rsrc_oop);
3824   load_klass(Rheader, Rsrc_oop);
3825   z_lg(Rheader, Address(Rheader, Klass::prototype_header_offset()));
3826 }
3827 
3828 void MacroAssembler::store_klass(Register klass, Register dst_oop, Register ck) {
3829   if (UseCompressedClassPointers) {
3830     assert_different_registers(dst_oop, klass, Z_R0);
3831     if (ck == noreg) ck = klass;
3832     encode_klass_not_null(ck, klass);
3833     z_st(ck, Address(dst_oop, oopDesc::klass_offset_in_bytes()));
3834   } else {
3835     z_stg(klass, Address(dst_oop, oopDesc::klass_offset_in_bytes()));
3836   }
3837 }
3838 
3839 void MacroAssembler::store_klass_gap(Register s, Register d) {
3840   if (UseCompressedClassPointers) {
3841     assert(s != d, &quot;not enough registers&quot;);
3842     // Support s = noreg.
3843     if (s != noreg) {
3844       z_st(s, Address(d, oopDesc::klass_gap_offset_in_bytes()));
3845     } else {
3846       z_mvhi(Address(d, oopDesc::klass_gap_offset_in_bytes()), 0);
3847     }
3848   }
3849 }
3850 
3851 // Compare klass ptr in memory against klass ptr in register.
3852 //
3853 // Rop1            - klass in register, always uncompressed.
3854 // disp            - Offset of klass in memory, compressed/uncompressed, depending on runtime flag.
3855 // Rbase           - Base address of cKlass in memory.
3856 // maybeNULL       - True if Rop1 possibly is a NULL.
3857 void MacroAssembler::compare_klass_ptr(Register Rop1, int64_t disp, Register Rbase, bool maybeNULL) {
3858 
3859   BLOCK_COMMENT(&quot;compare klass ptr {&quot;);
3860 
3861   if (UseCompressedClassPointers) {
3862     const int shift = CompressedKlassPointers::shift();
3863     address   base  = CompressedKlassPointers::base();
3864 
3865     assert((shift == 0) || (shift == LogKlassAlignmentInBytes), &quot;cKlass encoder detected bad shift&quot;);
3866     assert_different_registers(Rop1, Z_R0);
3867     assert_different_registers(Rop1, Rbase, Z_R1);
3868 
3869     // First encode register oop and then compare with cOop in memory.
3870     // This sequence saves an unnecessary cOop load and decode.
3871     if (base == NULL) {
3872       if (shift == 0) {
3873         z_cl(Rop1, disp, Rbase);     // Unscaled
3874       } else {
3875         z_srlg(Z_R0, Rop1, shift);   // ZeroBased
3876         z_cl(Z_R0, disp, Rbase);
3877       }
3878     } else {                         // HeapBased
3879 #ifdef ASSERT
3880       bool     used_R0 = true;
3881       bool     used_R1 = true;
3882 #endif
3883       Register current = Rop1;
3884       Label    done;
3885 
3886       if (maybeNULL) {       // NULL ptr must be preserved!
3887         z_ltgr(Z_R0, current);
3888         z_bre(done);
3889         current = Z_R0;
3890       }
3891 
3892       unsigned int base_h = ((unsigned long)base)&gt;&gt;32;
3893       unsigned int base_l = (unsigned int)((unsigned long)base);
3894       if ((base_h != 0) &amp;&amp; (base_l == 0) &amp;&amp; VM_Version::has_HighWordInstr()) {
3895         lgr_if_needed(Z_R0, current);
3896         z_aih(Z_R0, -((int)base_h));     // Base has no set bits in lower half.
3897       } else if ((base_h == 0) &amp;&amp; (base_l != 0)) {
3898         lgr_if_needed(Z_R0, current);
3899         z_agfi(Z_R0, -(int)base_l);
3900       } else {
3901         int pow2_offset = get_oop_base_complement(Z_R1, ((uint64_t)(intptr_t)base));
3902         add2reg_with_index(Z_R0, pow2_offset, Z_R1, Rop1); // Subtract base by adding complement.
3903       }
3904 
3905       if (shift != 0) {
3906         z_srlg(Z_R0, Z_R0, shift);
3907       }
3908       bind(done);
3909       z_cl(Z_R0, disp, Rbase);
3910 #ifdef ASSERT
3911       if (used_R0) preset_reg(Z_R0, 0xb05bUL, 2);
3912       if (used_R1) preset_reg(Z_R1, 0xb06bUL, 2);
3913 #endif
3914     }
3915   } else {
3916     z_clg(Rop1, disp, Z_R0, Rbase);
3917   }
3918   BLOCK_COMMENT(&quot;} compare klass ptr&quot;);
3919 }
3920 
3921 //---------------------------
3922 //  Compressed oops
3923 //---------------------------
3924 
3925 void MacroAssembler::encode_heap_oop(Register oop) {
3926   oop_encoder(oop, oop, true /*maybe null*/);
3927 }
3928 
3929 void MacroAssembler::encode_heap_oop_not_null(Register oop) {
3930   oop_encoder(oop, oop, false /*not null*/);
3931 }
3932 
3933 // Called with something derived from the oop base. e.g. oop_base&gt;&gt;3.
3934 int MacroAssembler::get_oop_base_pow2_offset(uint64_t oop_base) {
3935   unsigned int oop_base_ll = ((unsigned int)(oop_base &gt;&gt;  0)) &amp; 0xffff;
3936   unsigned int oop_base_lh = ((unsigned int)(oop_base &gt;&gt; 16)) &amp; 0xffff;
3937   unsigned int oop_base_hl = ((unsigned int)(oop_base &gt;&gt; 32)) &amp; 0xffff;
3938   unsigned int oop_base_hh = ((unsigned int)(oop_base &gt;&gt; 48)) &amp; 0xffff;
3939   unsigned int n_notzero_parts = (oop_base_ll == 0 ? 0:1)
3940                                + (oop_base_lh == 0 ? 0:1)
3941                                + (oop_base_hl == 0 ? 0:1)
3942                                + (oop_base_hh == 0 ? 0:1);
3943 
3944   assert(oop_base != 0, &quot;This is for HeapBased cOops only&quot;);
3945 
3946   if (n_notzero_parts != 1) { //  Check if oop_base is just a few pages shy of a power of 2.
3947     uint64_t pow2_offset = 0x10000 - oop_base_ll;
3948     if (pow2_offset &lt; 0x8000) {  // This might not be necessary.
3949       uint64_t oop_base2 = oop_base + pow2_offset;
3950 
3951       oop_base_ll = ((unsigned int)(oop_base2 &gt;&gt;  0)) &amp; 0xffff;
3952       oop_base_lh = ((unsigned int)(oop_base2 &gt;&gt; 16)) &amp; 0xffff;
3953       oop_base_hl = ((unsigned int)(oop_base2 &gt;&gt; 32)) &amp; 0xffff;
3954       oop_base_hh = ((unsigned int)(oop_base2 &gt;&gt; 48)) &amp; 0xffff;
3955       n_notzero_parts = (oop_base_ll == 0 ? 0:1) +
3956                         (oop_base_lh == 0 ? 0:1) +
3957                         (oop_base_hl == 0 ? 0:1) +
3958                         (oop_base_hh == 0 ? 0:1);
3959       if (n_notzero_parts == 1) {
3960         assert(-(int64_t)pow2_offset != (int64_t)-1, &quot;We use -1 to signal uninitialized base register&quot;);
3961         return -pow2_offset;
3962       }
3963     }
3964   }
3965   return 0;
3966 }
3967 
3968 // If base address is offset from a straight power of two by just a few pages,
3969 // return this offset to the caller for a possible later composite add.
3970 // TODO/FIX: will only work correctly for 4k pages.
3971 int MacroAssembler::get_oop_base(Register Rbase, uint64_t oop_base) {
3972   int pow2_offset = get_oop_base_pow2_offset(oop_base);
3973 
3974   load_const_optimized(Rbase, oop_base - pow2_offset); // Best job possible.
3975 
3976   return pow2_offset;
3977 }
3978 
3979 int MacroAssembler::get_oop_base_complement(Register Rbase, uint64_t oop_base) {
3980   int offset = get_oop_base(Rbase, oop_base);
3981   z_lcgr(Rbase, Rbase);
3982   return -offset;
3983 }
3984 
3985 // Compare compressed oop in memory against oop in register.
3986 // Rop1            - Oop in register.
3987 // disp            - Offset of cOop in memory.
3988 // Rbase           - Base address of cOop in memory.
3989 // maybeNULL       - True if Rop1 possibly is a NULL.
3990 // maybeNULLtarget - Branch target for Rop1 == NULL, if flow control shall NOT continue with compare instruction.
3991 void MacroAssembler::compare_heap_oop(Register Rop1, Address mem, bool maybeNULL) {
3992   Register Rbase  = mem.baseOrR0();
3993   Register Rindex = mem.indexOrR0();
3994   int64_t  disp   = mem.disp();
3995 
3996   const int shift = CompressedOops::shift();
3997   address   base  = CompressedOops::base();
3998 
3999   assert(UseCompressedOops, &quot;must be on to call this method&quot;);
4000   assert(Universe::heap() != NULL, &quot;java heap must be initialized to call this method&quot;);
4001   assert((shift == 0) || (shift == LogMinObjAlignmentInBytes), &quot;cOop encoder detected bad shift&quot;);
4002   assert_different_registers(Rop1, Z_R0);
4003   assert_different_registers(Rop1, Rbase, Z_R1);
4004   assert_different_registers(Rop1, Rindex, Z_R1);
4005 
4006   BLOCK_COMMENT(&quot;compare heap oop {&quot;);
4007 
4008   // First encode register oop and then compare with cOop in memory.
4009   // This sequence saves an unnecessary cOop load and decode.
4010   if (base == NULL) {
4011     if (shift == 0) {
4012       z_cl(Rop1, disp, Rindex, Rbase);  // Unscaled
4013     } else {
4014       z_srlg(Z_R0, Rop1, shift);        // ZeroBased
4015       z_cl(Z_R0, disp, Rindex, Rbase);
4016     }
4017   } else {                              // HeapBased
4018 #ifdef ASSERT
4019     bool  used_R0 = true;
4020     bool  used_R1 = true;
4021 #endif
4022     Label done;
4023     int   pow2_offset = get_oop_base_complement(Z_R1, ((uint64_t)(intptr_t)base));
4024 
4025     if (maybeNULL) {       // NULL ptr must be preserved!
4026       z_ltgr(Z_R0, Rop1);
4027       z_bre(done);
4028     }
4029 
4030     add2reg_with_index(Z_R0, pow2_offset, Z_R1, Rop1);
4031     z_srlg(Z_R0, Z_R0, shift);
4032 
4033     bind(done);
4034     z_cl(Z_R0, disp, Rindex, Rbase);
4035 #ifdef ASSERT
4036     if (used_R0) preset_reg(Z_R0, 0xb05bUL, 2);
4037     if (used_R1) preset_reg(Z_R1, 0xb06bUL, 2);
4038 #endif
4039   }
4040   BLOCK_COMMENT(&quot;} compare heap oop&quot;);
4041 }
4042 
4043 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators,
4044                                      const Address&amp; addr, Register val,
4045                                      Register tmp1, Register tmp2, Register tmp3) {
4046   assert((decorators &amp; ~(AS_RAW | IN_HEAP | IN_NATIVE | IS_ARRAY | IS_NOT_NULL |
4047                          ON_UNKNOWN_OOP_REF)) == 0, &quot;unsupported decorator&quot;);
4048   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4049   decorators = AccessInternal::decorator_fixup(decorators);
4050   bool as_raw = (decorators &amp; AS_RAW) != 0;
4051   if (as_raw) {
4052     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type,
4053                                       addr, val,
4054                                       tmp1, tmp2, tmp3);
4055   } else {
4056     bs-&gt;store_at(this, decorators, type,
4057                  addr, val,
4058                  tmp1, tmp2, tmp3);
4059   }
4060 }
4061 
4062 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators,
4063                                     const Address&amp; addr, Register dst,
4064                                     Register tmp1, Register tmp2, Label *is_null) {
4065   assert((decorators &amp; ~(AS_RAW | IN_HEAP | IN_NATIVE | IS_ARRAY | IS_NOT_NULL |
4066                          ON_PHANTOM_OOP_REF | ON_WEAK_OOP_REF)) == 0, &quot;unsupported decorator&quot;);
4067   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4068   decorators = AccessInternal::decorator_fixup(decorators);
4069   bool as_raw = (decorators &amp; AS_RAW) != 0;
4070   if (as_raw) {
4071     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type,
4072                                      addr, dst,
4073                                      tmp1, tmp2, is_null);
4074   } else {
4075     bs-&gt;load_at(this, decorators, type,
4076                 addr, dst,
4077                 tmp1, tmp2, is_null);
4078   }
4079 }
4080 
4081 void MacroAssembler::load_heap_oop(Register dest, const Address &amp;a,
4082                                    Register tmp1, Register tmp2,
4083                                    DecoratorSet decorators, Label *is_null) {
4084   access_load_at(T_OBJECT, IN_HEAP | decorators, a, dest, tmp1, tmp2, is_null);
4085 }
4086 
4087 void MacroAssembler::store_heap_oop(Register Roop, const Address &amp;a,
4088                                     Register tmp1, Register tmp2, Register tmp3,
4089                                     DecoratorSet decorators) {
4090   access_store_at(T_OBJECT, IN_HEAP | decorators, a, Roop, tmp1, tmp2, tmp3);
4091 }
4092 
4093 //-------------------------------------------------
4094 // Encode compressed oop. Generally usable encoder.
4095 //-------------------------------------------------
4096 // Rsrc - contains regular oop on entry. It remains unchanged.
4097 // Rdst - contains compressed oop on exit.
4098 // Rdst and Rsrc may indicate same register, in which case Rsrc does not remain unchanged.
4099 //
4100 // Rdst must not indicate scratch register Z_R1 (Z_R1_scratch) for functionality.
4101 // Rdst should not indicate scratch register Z_R0 (Z_R0_scratch) for performance.
4102 //
4103 // only32bitValid is set, if later code only uses the lower 32 bits. In this
4104 // case we must not fix the upper 32 bits.
4105 void MacroAssembler::oop_encoder(Register Rdst, Register Rsrc, bool maybeNULL,
4106                                  Register Rbase, int pow2_offset, bool only32bitValid) {
4107 
4108   const address oop_base  = CompressedOops::base();
4109   const int     oop_shift = CompressedOops::shift();
4110   const bool    disjoint  = CompressedOops::base_disjoint();
4111 
4112   assert(UseCompressedOops, &quot;must be on to call this method&quot;);
4113   assert(Universe::heap() != NULL, &quot;java heap must be initialized to call this encoder&quot;);
4114   assert((oop_shift == 0) || (oop_shift == LogMinObjAlignmentInBytes), &quot;cOop encoder detected bad shift&quot;);
4115 
4116   if (disjoint || (oop_base == NULL)) {
4117     BLOCK_COMMENT(&quot;cOop encoder zeroBase {&quot;);
4118     if (oop_shift == 0) {
4119       if (oop_base != NULL &amp;&amp; !only32bitValid) {
4120         z_llgfr(Rdst, Rsrc); // Clear upper bits in case the register will be decoded again.
4121       } else {
4122         lgr_if_needed(Rdst, Rsrc);
4123       }
4124     } else {
4125       z_srlg(Rdst, Rsrc, oop_shift);
4126       if (oop_base != NULL &amp;&amp; !only32bitValid) {
4127         z_llgfr(Rdst, Rdst); // Clear upper bits in case the register will be decoded again.
4128       }
4129     }
4130     BLOCK_COMMENT(&quot;} cOop encoder zeroBase&quot;);
4131     return;
4132   }
4133 
4134   bool used_R0 = false;
4135   bool used_R1 = false;
4136 
4137   BLOCK_COMMENT(&quot;cOop encoder general {&quot;);
4138   assert_different_registers(Rdst, Z_R1);
4139   assert_different_registers(Rsrc, Rbase);
4140   if (maybeNULL) {
4141     Label done;
4142     // We reorder shifting and subtracting, so that we can compare
4143     // and shift in parallel:
4144     //
4145     // cycle 0:  potential LoadN, base = &lt;const&gt;
4146     // cycle 1:  base = !base     dst = src &gt;&gt; 3,    cmp cr = (src != 0)
4147     // cycle 2:  if (cr) br,      dst = dst + base + offset
4148 
4149     // Get oop_base components.
4150     if (pow2_offset == -1) {
4151       if (Rdst == Rbase) {
4152         if (Rdst == Z_R1 || Rsrc == Z_R1) {
4153           Rbase = Z_R0;
4154           used_R0 = true;
4155         } else {
4156           Rdst = Z_R1;
4157           used_R1 = true;
4158         }
4159       }
4160       if (Rbase == Z_R1) {
4161         used_R1 = true;
4162       }
4163       pow2_offset = get_oop_base_complement(Rbase, ((uint64_t)(intptr_t)oop_base) &gt;&gt; oop_shift);
4164     }
4165     assert_different_registers(Rdst, Rbase);
4166 
4167     // Check for NULL oop (must be left alone) and shift.
4168     if (oop_shift != 0) {  // Shift out alignment bits
4169       if (((intptr_t)oop_base&amp;0xc000000000000000L) == 0L) { // We are sure: no single address will have the leftmost bit set.
4170         z_srag(Rdst, Rsrc, oop_shift);  // Arithmetic shift sets the condition code.
4171       } else {
4172         z_srlg(Rdst, Rsrc, oop_shift);
4173         z_ltgr(Rsrc, Rsrc);  // This is the recommended way of testing for zero.
4174         // This probably is faster, as it does not write a register. No!
4175         // z_cghi(Rsrc, 0);
4176       }
4177     } else {
4178       z_ltgr(Rdst, Rsrc);   // Move NULL to result register.
4179     }
4180     z_bre(done);
4181 
4182     // Subtract oop_base components.
4183     if ((Rdst == Z_R0) || (Rbase == Z_R0)) {
4184       z_algr(Rdst, Rbase);
4185       if (pow2_offset != 0) { add2reg(Rdst, pow2_offset); }
4186     } else {
4187       add2reg_with_index(Rdst, pow2_offset, Rbase, Rdst);
4188     }
4189     if (!only32bitValid) {
4190       z_llgfr(Rdst, Rdst); // Clear upper bits in case the register will be decoded again.
4191     }
4192     bind(done);
4193 
4194   } else {  // not null
4195     // Get oop_base components.
4196     if (pow2_offset == -1) {
4197       pow2_offset = get_oop_base_complement(Rbase, (uint64_t)(intptr_t)oop_base);
4198     }
4199 
4200     // Subtract oop_base components and shift.
4201     if (Rdst == Z_R0 || Rsrc == Z_R0 || Rbase == Z_R0) {
4202       // Don&#39;t use lay instruction.
4203       if (Rdst == Rsrc) {
4204         z_algr(Rdst, Rbase);
4205       } else {
4206         lgr_if_needed(Rdst, Rbase);
4207         z_algr(Rdst, Rsrc);
4208       }
4209       if (pow2_offset != 0) add2reg(Rdst, pow2_offset);
4210     } else {
4211       add2reg_with_index(Rdst, pow2_offset, Rbase, Rsrc);
4212     }
4213     if (oop_shift != 0) {   // Shift out alignment bits.
4214       z_srlg(Rdst, Rdst, oop_shift);
4215     }
4216     if (!only32bitValid) {
4217       z_llgfr(Rdst, Rdst); // Clear upper bits in case the register will be decoded again.
4218     }
4219   }
4220 #ifdef ASSERT
4221   if (used_R0 &amp;&amp; Rdst != Z_R0 &amp;&amp; Rsrc != Z_R0) { preset_reg(Z_R0, 0xb01bUL, 2); }
4222   if (used_R1 &amp;&amp; Rdst != Z_R1 &amp;&amp; Rsrc != Z_R1) { preset_reg(Z_R1, 0xb02bUL, 2); }
4223 #endif
4224   BLOCK_COMMENT(&quot;} cOop encoder general&quot;);
4225 }
4226 
4227 //-------------------------------------------------
4228 // decode compressed oop. Generally usable decoder.
4229 //-------------------------------------------------
4230 // Rsrc - contains compressed oop on entry.
4231 // Rdst - contains regular oop on exit.
4232 // Rdst and Rsrc may indicate same register.
4233 // Rdst must not be the same register as Rbase, if Rbase was preloaded (before call).
4234 // Rdst can be the same register as Rbase. Then, either Z_R0 or Z_R1 must be available as scratch.
4235 // Rbase - register to use for the base
4236 // pow2_offset - offset of base to nice value. If -1, base must be loaded.
4237 // For performance, it is good to
4238 //  - avoid Z_R0 for any of the argument registers.
4239 //  - keep Rdst and Rsrc distinct from Rbase. Rdst == Rsrc is ok for performance.
4240 //  - avoid Z_R1 for Rdst if Rdst == Rbase.
4241 void MacroAssembler::oop_decoder(Register Rdst, Register Rsrc, bool maybeNULL, Register Rbase, int pow2_offset) {
4242 
4243   const address oop_base  = CompressedOops::base();
4244   const int     oop_shift = CompressedOops::shift();
4245   const bool    disjoint  = CompressedOops::base_disjoint();
4246 
4247   assert(UseCompressedOops, &quot;must be on to call this method&quot;);
4248   assert(Universe::heap() != NULL, &quot;java heap must be initialized to call this decoder&quot;);
4249   assert((oop_shift == 0) || (oop_shift == LogMinObjAlignmentInBytes),
4250          &quot;cOop encoder detected bad shift&quot;);
4251 
4252   // cOops are always loaded zero-extended from memory. No explicit zero-extension necessary.
4253 
4254   if (oop_base != NULL) {
4255     unsigned int oop_base_hl = ((unsigned int)((uint64_t)(intptr_t)oop_base &gt;&gt; 32)) &amp; 0xffff;
4256     unsigned int oop_base_hh = ((unsigned int)((uint64_t)(intptr_t)oop_base &gt;&gt; 48)) &amp; 0xffff;
4257     unsigned int oop_base_hf = ((unsigned int)((uint64_t)(intptr_t)oop_base &gt;&gt; 32)) &amp; 0xFFFFffff;
4258     if (disjoint &amp;&amp; (oop_base_hl == 0 || oop_base_hh == 0)) {
4259       BLOCK_COMMENT(&quot;cOop decoder disjointBase {&quot;);
4260       // We do not need to load the base. Instead, we can install the upper bits
4261       // with an OR instead of an ADD.
4262       Label done;
4263 
4264       // Rsrc contains a narrow oop. Thus we are sure the leftmost &lt;oop_shift&gt; bits will never be set.
4265       if (maybeNULL) {  // NULL ptr must be preserved!
4266         z_slag(Rdst, Rsrc, oop_shift);  // Arithmetic shift sets the condition code.
4267         z_bre(done);
4268       } else {
4269         z_sllg(Rdst, Rsrc, oop_shift);  // Logical shift leaves condition code alone.
4270       }
4271       if ((oop_base_hl != 0) &amp;&amp; (oop_base_hh != 0)) {
4272         z_oihf(Rdst, oop_base_hf);
4273       } else if (oop_base_hl != 0) {
4274         z_oihl(Rdst, oop_base_hl);
4275       } else {
4276         assert(oop_base_hh != 0, &quot;not heapbased mode&quot;);
4277         z_oihh(Rdst, oop_base_hh);
4278       }
4279       bind(done);
4280       BLOCK_COMMENT(&quot;} cOop decoder disjointBase&quot;);
4281     } else {
4282       BLOCK_COMMENT(&quot;cOop decoder general {&quot;);
4283       // There are three decode steps:
4284       //   scale oop offset (shift left)
4285       //   get base (in reg) and pow2_offset (constant)
4286       //   add base, pow2_offset, and oop offset
4287       // The following register overlap situations may exist:
4288       // Rdst == Rsrc,  Rbase any other
4289       //   not a problem. Scaling in-place leaves Rbase undisturbed.
4290       //   Loading Rbase does not impact the scaled offset.
4291       // Rdst == Rbase, Rsrc  any other
4292       //   scaling would destroy a possibly preloaded Rbase. Loading Rbase
4293       //   would destroy the scaled offset.
4294       //   Remedy: use Rdst_tmp if Rbase has been preloaded.
4295       //           use Rbase_tmp if base has to be loaded.
4296       // Rsrc == Rbase, Rdst  any other
4297       //   Only possible without preloaded Rbase.
4298       //   Loading Rbase does not destroy compressed oop because it was scaled into Rdst before.
4299       // Rsrc == Rbase, Rdst == Rbase
4300       //   Only possible without preloaded Rbase.
4301       //   Loading Rbase would destroy compressed oop. Scaling in-place is ok.
4302       //   Remedy: use Rbase_tmp.
4303       //
4304       Label    done;
4305       Register Rdst_tmp       = Rdst;
4306       Register Rbase_tmp      = Rbase;
4307       bool     used_R0        = false;
4308       bool     used_R1        = false;
4309       bool     base_preloaded = pow2_offset &gt;= 0;
4310       guarantee(!(base_preloaded &amp;&amp; (Rsrc == Rbase)), &quot;Register clash, check caller&quot;);
4311       assert(oop_shift != 0, &quot;room for optimization&quot;);
4312 
4313       // Check if we need to use scratch registers.
4314       if (Rdst == Rbase) {
4315         assert(!(((Rdst == Z_R0) &amp;&amp; (Rsrc == Z_R1)) || ((Rdst == Z_R1) &amp;&amp; (Rsrc == Z_R0))), &quot;need a scratch reg&quot;);
4316         if (Rdst != Rsrc) {
4317           if (base_preloaded) { Rdst_tmp  = (Rdst == Z_R1) ? Z_R0 : Z_R1; }
4318           else                { Rbase_tmp = (Rdst == Z_R1) ? Z_R0 : Z_R1; }
4319         } else {
4320           Rbase_tmp = (Rdst == Z_R1) ? Z_R0 : Z_R1;
4321         }
4322       }
4323       if (base_preloaded) lgr_if_needed(Rbase_tmp, Rbase);
4324 
4325       // Scale oop and check for NULL.
4326       // Rsrc contains a narrow oop. Thus we are sure the leftmost &lt;oop_shift&gt; bits will never be set.
4327       if (maybeNULL) {  // NULL ptr must be preserved!
4328         z_slag(Rdst_tmp, Rsrc, oop_shift);  // Arithmetic shift sets the condition code.
4329         z_bre(done);
4330       } else {
4331         z_sllg(Rdst_tmp, Rsrc, oop_shift);  // Logical shift leaves condition code alone.
4332       }
4333 
4334       // Get oop_base components.
4335       if (!base_preloaded) {
4336         pow2_offset = get_oop_base(Rbase_tmp, (uint64_t)(intptr_t)oop_base);
4337       }
4338 
4339       // Add up all components.
4340       if ((Rbase_tmp == Z_R0) || (Rdst_tmp == Z_R0)) {
4341         z_algr(Rdst_tmp, Rbase_tmp);
4342         if (pow2_offset != 0) { add2reg(Rdst_tmp, pow2_offset); }
4343       } else {
4344         add2reg_with_index(Rdst_tmp, pow2_offset, Rbase_tmp, Rdst_tmp);
4345       }
4346 
4347       bind(done);
4348       lgr_if_needed(Rdst, Rdst_tmp);
4349 #ifdef ASSERT
4350       if (used_R0 &amp;&amp; Rdst != Z_R0 &amp;&amp; Rsrc != Z_R0) { preset_reg(Z_R0, 0xb03bUL, 2); }
4351       if (used_R1 &amp;&amp; Rdst != Z_R1 &amp;&amp; Rsrc != Z_R1) { preset_reg(Z_R1, 0xb04bUL, 2); }
4352 #endif
4353       BLOCK_COMMENT(&quot;} cOop decoder general&quot;);
4354     }
4355   } else {
4356     BLOCK_COMMENT(&quot;cOop decoder zeroBase {&quot;);
4357     if (oop_shift == 0) {
4358       lgr_if_needed(Rdst, Rsrc);
4359     } else {
4360       z_sllg(Rdst, Rsrc, oop_shift);
4361     }
4362     BLOCK_COMMENT(&quot;} cOop decoder zeroBase&quot;);
4363   }
4364 }
4365 
4366 // ((OopHandle)result).resolve();
4367 void MacroAssembler::resolve_oop_handle(Register result) {
4368   // OopHandle::resolve is an indirection.
4369   z_lg(result, 0, result);
4370 }
4371 
4372 void MacroAssembler::load_mirror_from_const_method(Register mirror, Register const_method) {
4373   mem2reg_opt(mirror, Address(const_method, ConstMethod::constants_offset()));
4374   mem2reg_opt(mirror, Address(mirror, ConstantPool::pool_holder_offset_in_bytes()));
4375   mem2reg_opt(mirror, Address(mirror, Klass::java_mirror_offset()));
4376   resolve_oop_handle(mirror);
4377 }
4378 
4379 void MacroAssembler::load_method_holder(Register holder, Register method) {
4380   mem2reg_opt(holder, Address(method, Method::const_offset()));
4381   mem2reg_opt(holder, Address(holder, ConstMethod::constants_offset()));
4382   mem2reg_opt(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes()));
4383 }
4384 
4385 //---------------------------------------------------------------
4386 //---  Operations on arrays.
4387 //---------------------------------------------------------------
4388 
4389 // Compiler ensures base is doubleword aligned and cnt is #doublewords.
4390 // Emitter does not KILL cnt and base arguments, since they need to be copied to
4391 // work registers anyway.
4392 // Actually, only r0, r1, and r5 are killed.
4393 unsigned int MacroAssembler::Clear_Array(Register cnt_arg, Register base_pointer_arg, Register odd_tmp_reg) {
4394 
4395   int      block_start = offset();
4396   Register dst_len  = Z_R1;    // Holds dst len  for MVCLE.
4397   Register dst_addr = Z_R0;    // Holds dst addr for MVCLE.
4398 
4399   Label doXC, doMVCLE, done;
4400 
4401   BLOCK_COMMENT(&quot;Clear_Array {&quot;);
4402 
4403   // Check for zero len and convert to long.
4404   z_ltgfr(odd_tmp_reg, cnt_arg);
4405   z_bre(done);                    // Nothing to do if len == 0.
4406 
4407   // Prefetch data to be cleared.
4408   if (VM_Version::has_Prefetch()) {
4409     z_pfd(0x02,   0, Z_R0, base_pointer_arg);
4410     z_pfd(0x02, 256, Z_R0, base_pointer_arg);
4411   }
4412 
4413   z_sllg(dst_len, odd_tmp_reg, 3); // #bytes to clear.
4414   z_cghi(odd_tmp_reg, 32);         // Check for len &lt;= 256 bytes (&lt;=32 DW).
4415   z_brnh(doXC);                    // If so, use executed XC to clear.
4416 
4417   // MVCLE: initialize long arrays (general case).
4418   bind(doMVCLE);
4419   z_lgr(dst_addr, base_pointer_arg);
4420   // Pass 0 as source length to MVCLE: destination will be filled with padding byte 0.
4421   // The even register of the register pair is not killed.
4422   clear_reg(odd_tmp_reg, true, false);
4423   MacroAssembler::move_long_ext(dst_addr, as_Register(odd_tmp_reg-&gt;encoding()-1), 0);
4424   z_bru(done);
4425 
4426   // XC: initialize short arrays.
4427   Label XC_template; // Instr template, never exec directly!
4428     bind(XC_template);
4429     z_xc(0,0,base_pointer_arg,0,base_pointer_arg);
4430 
4431   bind(doXC);
4432     add2reg(dst_len, -1);               // Get #bytes-1 for EXECUTE.
4433     if (VM_Version::has_ExecuteExtensions()) {
4434       z_exrl(dst_len, XC_template);     // Execute XC with var. len.
4435     } else {
4436       z_larl(odd_tmp_reg, XC_template);
4437       z_ex(dst_len,0,Z_R0,odd_tmp_reg); // Execute XC with var. len.
4438     }
4439     // z_bru(done);      // fallthru
4440 
4441   bind(done);
4442 
4443   BLOCK_COMMENT(&quot;} Clear_Array&quot;);
4444 
4445   int block_end = offset();
4446   return block_end - block_start;
4447 }
4448 
4449 // Compiler ensures base is doubleword aligned and cnt is count of doublewords.
4450 // Emitter does not KILL any arguments nor work registers.
4451 // Emitter generates up to 16 XC instructions, depending on the array length.
4452 unsigned int MacroAssembler::Clear_Array_Const(long cnt, Register base) {
4453   int  block_start    = offset();
4454   int  off;
4455   int  lineSize_Bytes = AllocatePrefetchStepSize;
4456   int  lineSize_DW    = AllocatePrefetchStepSize&gt;&gt;LogBytesPerWord;
4457   bool doPrefetch     = VM_Version::has_Prefetch();
4458   int  XC_maxlen      = 256;
4459   int  numXCInstr     = cnt &gt; 0 ? (cnt*BytesPerWord-1)/XC_maxlen+1 : 0;
4460 
4461   BLOCK_COMMENT(&quot;Clear_Array_Const {&quot;);
4462   assert(cnt*BytesPerWord &lt;= 4096, &quot;ClearArrayConst can handle 4k only&quot;);
4463 
4464   // Do less prefetching for very short arrays.
4465   if (numXCInstr &gt; 0) {
4466     // Prefetch only some cache lines, then begin clearing.
4467     if (doPrefetch) {
4468       if (cnt*BytesPerWord &lt;= lineSize_Bytes/4) {  // If less than 1/4 of a cache line to clear,
4469         z_pfd(0x02, 0, Z_R0, base);                // prefetch just the first cache line.
4470       } else {
4471         assert(XC_maxlen == lineSize_Bytes, &quot;ClearArrayConst needs 256B cache lines&quot;);
4472         for (off = 0; (off &lt; AllocatePrefetchLines) &amp;&amp; (off &lt;= numXCInstr); off ++) {
4473           z_pfd(0x02, off*lineSize_Bytes, Z_R0, base);
4474         }
4475       }
4476     }
4477 
4478     for (off=0; off&lt;(numXCInstr-1); off++) {
4479       z_xc(off*XC_maxlen, XC_maxlen-1, base, off*XC_maxlen, base);
4480 
4481       // Prefetch some cache lines in advance.
4482       if (doPrefetch &amp;&amp; (off &lt;= numXCInstr-AllocatePrefetchLines)) {
4483         z_pfd(0x02, (off+AllocatePrefetchLines)*lineSize_Bytes, Z_R0, base);
4484       }
4485     }
4486     if (off*XC_maxlen &lt; cnt*BytesPerWord) {
4487       z_xc(off*XC_maxlen, (cnt*BytesPerWord-off*XC_maxlen)-1, base, off*XC_maxlen, base);
4488     }
4489   }
4490   BLOCK_COMMENT(&quot;} Clear_Array_Const&quot;);
4491 
4492   int block_end = offset();
4493   return block_end - block_start;
4494 }
4495 
4496 // Compiler ensures base is doubleword aligned and cnt is #doublewords.
4497 // Emitter does not KILL cnt and base arguments, since they need to be copied to
4498 // work registers anyway.
4499 // Actually, only r0, r1, (which are work registers) and odd_tmp_reg are killed.
4500 //
4501 // For very large arrays, exploit MVCLE H/W support.
4502 // MVCLE instruction automatically exploits H/W-optimized page mover.
4503 // - Bytes up to next page boundary are cleared with a series of XC to self.
4504 // - All full pages are cleared with the page mover H/W assist.
4505 // - Remaining bytes are again cleared by a series of XC to self.
4506 //
4507 unsigned int MacroAssembler::Clear_Array_Const_Big(long cnt, Register base_pointer_arg, Register odd_tmp_reg) {
4508 
4509   int      block_start = offset();
4510   Register dst_len  = Z_R1;      // Holds dst len  for MVCLE.
4511   Register dst_addr = Z_R0;      // Holds dst addr for MVCLE.
4512 
4513   BLOCK_COMMENT(&quot;Clear_Array_Const_Big {&quot;);
4514 
4515   // Get len to clear.
4516   load_const_optimized(dst_len, (long)cnt*8L);  // in Bytes = #DW*8
4517 
4518   // Prepare other args to MVCLE.
4519   z_lgr(dst_addr, base_pointer_arg);
4520   // Pass 0 as source length to MVCLE: destination will be filled with padding byte 0.
4521   // The even register of the register pair is not killed.
4522   (void) clear_reg(odd_tmp_reg, true, false);  // Src len of MVCLE is zero.
4523   MacroAssembler::move_long_ext(dst_addr, as_Register(odd_tmp_reg-&gt;encoding() - 1), 0);
4524   BLOCK_COMMENT(&quot;} Clear_Array_Const_Big&quot;);
4525 
4526   int block_end = offset();
4527   return block_end - block_start;
4528 }
4529 
4530 // Allocator.
4531 unsigned int MacroAssembler::CopyRawMemory_AlignedDisjoint(Register src_reg, Register dst_reg,
4532                                                            Register cnt_reg,
4533                                                            Register tmp1_reg, Register tmp2_reg) {
4534   // Tmp1 is oddReg.
4535   // Tmp2 is evenReg.
4536 
4537   int block_start = offset();
4538   Label doMVC, doMVCLE, done, MVC_template;
4539 
4540   BLOCK_COMMENT(&quot;CopyRawMemory_AlignedDisjoint {&quot;);
4541 
4542   // Check for zero len and convert to long.
4543   z_ltgfr(cnt_reg, cnt_reg);      // Remember casted value for doSTG case.
4544   z_bre(done);                    // Nothing to do if len == 0.
4545 
4546   z_sllg(Z_R1, cnt_reg, 3);       // Dst len in bytes. calc early to have the result ready.
4547 
4548   z_cghi(cnt_reg, 32);            // Check for len &lt;= 256 bytes (&lt;=32 DW).
4549   z_brnh(doMVC);                  // If so, use executed MVC to clear.
4550 
4551   bind(doMVCLE);                  // A lot of data (more than 256 bytes).
4552   // Prep dest reg pair.
4553   z_lgr(Z_R0, dst_reg);           // dst addr
4554   // Dst len already in Z_R1.
4555   // Prep src reg pair.
4556   z_lgr(tmp2_reg, src_reg);       // src addr
4557   z_lgr(tmp1_reg, Z_R1);          // Src len same as dst len.
4558 
4559   // Do the copy.
4560   move_long_ext(Z_R0, tmp2_reg, 0xb0); // Bypass cache.
4561   z_bru(done);                         // All done.
4562 
4563   bind(MVC_template);             // Just some data (not more than 256 bytes).
4564   z_mvc(0, 0, dst_reg, 0, src_reg);
4565 
4566   bind(doMVC);
4567 
4568   if (VM_Version::has_ExecuteExtensions()) {
4569     add2reg(Z_R1, -1);
4570   } else {
4571     add2reg(tmp1_reg, -1, Z_R1);
4572     z_larl(Z_R1, MVC_template);
4573   }
4574 
4575   if (VM_Version::has_Prefetch()) {
4576     z_pfd(1,  0,Z_R0,src_reg);
4577     z_pfd(2,  0,Z_R0,dst_reg);
4578     //    z_pfd(1,256,Z_R0,src_reg);    // Assume very short copy.
4579     //    z_pfd(2,256,Z_R0,dst_reg);
4580   }
4581 
4582   if (VM_Version::has_ExecuteExtensions()) {
4583     z_exrl(Z_R1, MVC_template);
4584   } else {
4585     z_ex(tmp1_reg, 0, Z_R0, Z_R1);
4586   }
4587 
4588   bind(done);
4589 
4590   BLOCK_COMMENT(&quot;} CopyRawMemory_AlignedDisjoint&quot;);
4591 
4592   int block_end = offset();
4593   return block_end - block_start;
4594 }
4595 
<a name="2" id="anc2"></a><span class="line-removed">4596 #ifdef COMPILER2</span>
<span class="line-removed">4597 //------------------------------------------------------</span>
<span class="line-removed">4598 //   Special String Intrinsics. Implementation</span>
<span class="line-removed">4599 //------------------------------------------------------</span>
<span class="line-removed">4600 </span>
<span class="line-removed">4601 // Intrinsics for CompactStrings</span>
<span class="line-removed">4602 </span>
<span class="line-removed">4603 // Compress char[] to byte[].</span>
<span class="line-removed">4604 //   Restores: src, dst</span>
<span class="line-removed">4605 //   Uses:     cnt</span>
<span class="line-removed">4606 //   Kills:    tmp, Z_R0, Z_R1.</span>
<span class="line-removed">4607 //   Early clobber: result.</span>
<span class="line-removed">4608 // Note:</span>
<span class="line-removed">4609 //   cnt is signed int. Do not rely on high word!</span>
<span class="line-removed">4610 //       counts # characters, not bytes.</span>
<span class="line-removed">4611 // The result is the number of characters copied before the first incompatible character was found.</span>
<span class="line-removed">4612 // If precise is true, the processing stops exactly at this point. Otherwise, the result may be off</span>
<span class="line-removed">4613 // by a few bytes. The result always indicates the number of copied characters.</span>
<span class="line-removed">4614 // When used as a character index, the returned value points to the first incompatible character.</span>
<span class="line-removed">4615 //</span>
<span class="line-removed">4616 // Note: Does not behave exactly like package private StringUTF16 compress java implementation in case of failure:</span>
<span class="line-removed">4617 // - Different number of characters may have been written to dead array (if precise is false).</span>
<span class="line-removed">4618 // - Returns a number &lt;cnt instead of 0. (Result gets compared with cnt.)</span>
<span class="line-removed">4619 unsigned int MacroAssembler::string_compress(Register result, Register src, Register dst, Register cnt,</span>
<span class="line-removed">4620                                              Register tmp,    bool precise) {</span>
<span class="line-removed">4621   assert_different_registers(Z_R0, Z_R1, result, src, dst, cnt, tmp);</span>
<span class="line-removed">4622 </span>
<span class="line-removed">4623   if (precise) {</span>
<span class="line-removed">4624     BLOCK_COMMENT(&quot;encode_iso_array {&quot;);</span>
<span class="line-removed">4625   } else {</span>
<span class="line-removed">4626     BLOCK_COMMENT(&quot;string_compress {&quot;);</span>
<span class="line-removed">4627   }</span>
<span class="line-removed">4628   int  block_start = offset();</span>
<span class="line-removed">4629 </span>
<span class="line-removed">4630   Register       Rsrc  = src;</span>
<span class="line-removed">4631   Register       Rdst  = dst;</span>
<span class="line-removed">4632   Register       Rix   = tmp;</span>
<span class="line-removed">4633   Register       Rcnt  = cnt;</span>
<span class="line-removed">4634   Register       Rmask = result;  // holds incompatibility check mask until result value is stored.</span>
<span class="line-removed">4635   Label          ScalarShortcut, AllDone;</span>
<span class="line-removed">4636 </span>
<span class="line-removed">4637   z_iilf(Rmask, 0xFF00FF00);</span>
<span class="line-removed">4638   z_iihf(Rmask, 0xFF00FF00);</span>
<span class="line-removed">4639 </span>
<span class="line-removed">4640 #if 0  // Sacrifice shortcuts for code compactness</span>
<span class="line-removed">4641   {</span>
<span class="line-removed">4642     //---&lt;  shortcuts for short strings (very frequent)   &gt;---</span>
<span class="line-removed">4643     //   Strings with 4 and 8 characters were fond to occur very frequently.</span>
<span class="line-removed">4644     //   Therefore, we handle them right away with minimal overhead.</span>
<span class="line-removed">4645     Label     skipShortcut, skip4Shortcut, skip8Shortcut;</span>
<span class="line-removed">4646     Register  Rout = Z_R0;</span>
<span class="line-removed">4647     z_chi(Rcnt, 4);</span>
<span class="line-removed">4648     z_brne(skip4Shortcut);                 // 4 characters are very frequent</span>
<span class="line-removed">4649       z_lg(Z_R0, 0, Rsrc);                 // Treat exactly 4 characters specially.</span>
<span class="line-removed">4650       if (VM_Version::has_DistinctOpnds()) {</span>
<span class="line-removed">4651         Rout = Z_R0;</span>
<span class="line-removed">4652         z_ngrk(Rix, Z_R0, Rmask);</span>
<span class="line-removed">4653       } else {</span>
<span class="line-removed">4654         Rout = Rix;</span>
<span class="line-removed">4655         z_lgr(Rix, Z_R0);</span>
<span class="line-removed">4656         z_ngr(Z_R0, Rmask);</span>
<span class="line-removed">4657       }</span>
<span class="line-removed">4658       z_brnz(skipShortcut);</span>
<span class="line-removed">4659       z_stcmh(Rout, 5, 0, Rdst);</span>
<span class="line-removed">4660       z_stcm(Rout,  5, 2, Rdst);</span>
<span class="line-removed">4661       z_lgfr(result, Rcnt);</span>
<span class="line-removed">4662       z_bru(AllDone);</span>
<span class="line-removed">4663     bind(skip4Shortcut);</span>
<span class="line-removed">4664 </span>
<span class="line-removed">4665     z_chi(Rcnt, 8);</span>
<span class="line-removed">4666     z_brne(skip8Shortcut);                 // There&#39;s more to do...</span>
<span class="line-removed">4667       z_lmg(Z_R0, Z_R1, 0, Rsrc);          // Treat exactly 8 characters specially.</span>
<span class="line-removed">4668       if (VM_Version::has_DistinctOpnds()) {</span>
<span class="line-removed">4669         Rout = Z_R0;</span>
<span class="line-removed">4670         z_ogrk(Rix, Z_R0, Z_R1);</span>
<span class="line-removed">4671         z_ngr(Rix, Rmask);</span>
<span class="line-removed">4672       } else {</span>
<span class="line-removed">4673         Rout = Rix;</span>
<span class="line-removed">4674         z_lgr(Rix, Z_R0);</span>
<span class="line-removed">4675         z_ogr(Z_R0, Z_R1);</span>
<span class="line-removed">4676         z_ngr(Z_R0, Rmask);</span>
<span class="line-removed">4677       }</span>
<span class="line-removed">4678       z_brnz(skipShortcut);</span>
<span class="line-removed">4679       z_stcmh(Rout, 5, 0, Rdst);</span>
<span class="line-removed">4680       z_stcm(Rout,  5, 2, Rdst);</span>
<span class="line-removed">4681       z_stcmh(Z_R1, 5, 4, Rdst);</span>
<span class="line-removed">4682       z_stcm(Z_R1,  5, 6, Rdst);</span>
<span class="line-removed">4683       z_lgfr(result, Rcnt);</span>
<span class="line-removed">4684       z_bru(AllDone);</span>
<span class="line-removed">4685 </span>
<span class="line-removed">4686     bind(skip8Shortcut);</span>
<span class="line-removed">4687     clear_reg(Z_R0, true, false);          // #characters already processed (none). Precond for scalar loop.</span>
<span class="line-removed">4688     z_brl(ScalarShortcut);                 // Just a few characters</span>
<span class="line-removed">4689 </span>
<span class="line-removed">4690     bind(skipShortcut);</span>
<span class="line-removed">4691   }</span>
<span class="line-removed">4692 #endif</span>
<span class="line-removed">4693   clear_reg(Z_R0);                         // make sure register is properly initialized.</span>
<span class="line-removed">4694 </span>
<span class="line-removed">4695   if (VM_Version::has_VectorFacility()) {</span>
<span class="line-removed">4696     const int  min_vcnt     = 32;          // Minimum #characters required to use vector instructions.</span>
<span class="line-removed">4697                                            // Otherwise just do nothing in vector mode.</span>
<span class="line-removed">4698                                            // Must be multiple of 2*(vector register length in chars (8 HW = 128 bits)).</span>
<span class="line-removed">4699     const int  log_min_vcnt = exact_log2(min_vcnt);</span>
<span class="line-removed">4700     Label      VectorLoop, VectorDone, VectorBreak;</span>
<span class="line-removed">4701 </span>
<span class="line-removed">4702     VectorRegister Vtmp1      = Z_V16;</span>
<span class="line-removed">4703     VectorRegister Vtmp2      = Z_V17;</span>
<span class="line-removed">4704     VectorRegister Vmask      = Z_V18;</span>
<span class="line-removed">4705     VectorRegister Vzero      = Z_V19;</span>
<span class="line-removed">4706     VectorRegister Vsrc_first = Z_V20;</span>
<span class="line-removed">4707     VectorRegister Vsrc_last  = Z_V23;</span>
<span class="line-removed">4708 </span>
<span class="line-removed">4709     assert((Vsrc_last-&gt;encoding() - Vsrc_first-&gt;encoding() + 1) == min_vcnt/8, &quot;logic error&quot;);</span>
<span class="line-removed">4710     assert(VM_Version::has_DistinctOpnds(), &quot;Assumption when has_VectorFacility()&quot;);</span>
<span class="line-removed">4711     z_srak(Rix, Rcnt, log_min_vcnt);       // # vector loop iterations</span>
<span class="line-removed">4712     z_brz(VectorDone);                     // not enough data for vector loop</span>
<span class="line-removed">4713 </span>
<span class="line-removed">4714     z_vzero(Vzero);                        // all zeroes</span>
<span class="line-removed">4715     z_vgmh(Vmask, 0, 7);                   // generate 0xff00 mask for all 2-byte elements</span>
<span class="line-removed">4716     z_sllg(Z_R0, Rix, log_min_vcnt);       // remember #chars that will be processed by vector loop</span>
<span class="line-removed">4717 </span>
<span class="line-removed">4718     bind(VectorLoop);</span>
<span class="line-removed">4719       z_vlm(Vsrc_first, Vsrc_last, 0, Rsrc);</span>
<span class="line-removed">4720       add2reg(Rsrc, min_vcnt*2);</span>
<span class="line-removed">4721 </span>
<span class="line-removed">4722       //---&lt;  check for incompatible character  &gt;---</span>
<span class="line-removed">4723       z_vo(Vtmp1, Z_V20, Z_V21);</span>
<span class="line-removed">4724       z_vo(Vtmp2, Z_V22, Z_V23);</span>
<span class="line-removed">4725       z_vo(Vtmp1, Vtmp1, Vtmp2);</span>
<span class="line-removed">4726       z_vn(Vtmp1, Vtmp1, Vmask);</span>
<span class="line-removed">4727       z_vceqhs(Vtmp1, Vtmp1, Vzero);       // high half of all chars must be zero for successful compress.</span>
<span class="line-removed">4728       z_bvnt(VectorBreak);                 // break vector loop if not all vector elements compare eq -&gt; incompatible character found.</span>
<span class="line-removed">4729                                            // re-process data from current iteration in break handler.</span>
<span class="line-removed">4730 </span>
<span class="line-removed">4731       //---&lt;  pack &amp; store characters  &gt;---</span>
<span class="line-removed">4732       z_vpkh(Vtmp1, Z_V20, Z_V21);         // pack (src1, src2) -&gt; tmp1</span>
<span class="line-removed">4733       z_vpkh(Vtmp2, Z_V22, Z_V23);         // pack (src3, src4) -&gt; tmp2</span>
<span class="line-removed">4734       z_vstm(Vtmp1, Vtmp2, 0, Rdst);       // store packed string</span>
<span class="line-removed">4735       add2reg(Rdst, min_vcnt);</span>
<span class="line-removed">4736 </span>
<span class="line-removed">4737       z_brct(Rix, VectorLoop);</span>
<span class="line-removed">4738 </span>
<span class="line-removed">4739     z_bru(VectorDone);</span>
<span class="line-removed">4740 </span>
<span class="line-removed">4741     bind(VectorBreak);</span>
<span class="line-removed">4742       add2reg(Rsrc, -min_vcnt*2);          // Fix Rsrc. Rsrc was already updated, but Rdst and Rix are not.</span>
<span class="line-removed">4743       z_sll(Rix, log_min_vcnt);            // # chars processed so far in VectorLoop, excl. current iteration.</span>
<span class="line-removed">4744       z_sr(Z_R0, Rix);                     // correct # chars processed in total.</span>
<span class="line-removed">4745 </span>
<span class="line-removed">4746     bind(VectorDone);</span>
<span class="line-removed">4747   }</span>
<span class="line-removed">4748 </span>
<span class="line-removed">4749   {</span>
<span class="line-removed">4750     const int  min_cnt     =  8;           // Minimum #characters required to use unrolled loop.</span>
<span class="line-removed">4751                                            // Otherwise just do nothing in unrolled loop.</span>
<span class="line-removed">4752                                            // Must be multiple of 8.</span>
<span class="line-removed">4753     const int  log_min_cnt = exact_log2(min_cnt);</span>
<span class="line-removed">4754     Label      UnrolledLoop, UnrolledDone, UnrolledBreak;</span>
<span class="line-removed">4755 </span>
<span class="line-removed">4756     if (VM_Version::has_DistinctOpnds()) {</span>
<span class="line-removed">4757       z_srk(Rix, Rcnt, Z_R0);              // remaining # chars to compress in unrolled loop</span>
<span class="line-removed">4758     } else {</span>
<span class="line-removed">4759       z_lr(Rix, Rcnt);</span>
<span class="line-removed">4760       z_sr(Rix, Z_R0);</span>
<span class="line-removed">4761     }</span>
<span class="line-removed">4762     z_sra(Rix, log_min_cnt);             // unrolled loop count</span>
<span class="line-removed">4763     z_brz(UnrolledDone);</span>
<span class="line-removed">4764 </span>
<span class="line-removed">4765     bind(UnrolledLoop);</span>
<span class="line-removed">4766       z_lmg(Z_R0, Z_R1, 0, Rsrc);</span>
<span class="line-removed">4767       if (precise) {</span>
<span class="line-removed">4768         z_ogr(Z_R1, Z_R0);                 // check all 8 chars for incompatibility</span>
<span class="line-removed">4769         z_ngr(Z_R1, Rmask);</span>
<span class="line-removed">4770         z_brnz(UnrolledBreak);</span>
<span class="line-removed">4771 </span>
<span class="line-removed">4772         z_lg(Z_R1, 8, Rsrc);               // reload destroyed register</span>
<span class="line-removed">4773         z_stcmh(Z_R0, 5, 0, Rdst);</span>
<span class="line-removed">4774         z_stcm(Z_R0,  5, 2, Rdst);</span>
<span class="line-removed">4775       } else {</span>
<span class="line-removed">4776         z_stcmh(Z_R0, 5, 0, Rdst);</span>
<span class="line-removed">4777         z_stcm(Z_R0,  5, 2, Rdst);</span>
<span class="line-removed">4778 </span>
<span class="line-removed">4779         z_ogr(Z_R0, Z_R1);</span>
<span class="line-removed">4780         z_ngr(Z_R0, Rmask);</span>
<span class="line-removed">4781         z_brnz(UnrolledBreak);</span>
<span class="line-removed">4782       }</span>
<span class="line-removed">4783       z_stcmh(Z_R1, 5, 4, Rdst);</span>
<span class="line-removed">4784       z_stcm(Z_R1,  5, 6, Rdst);</span>
<span class="line-removed">4785 </span>
<span class="line-removed">4786       add2reg(Rsrc, min_cnt*2);</span>
<span class="line-removed">4787       add2reg(Rdst, min_cnt);</span>
<span class="line-removed">4788       z_brct(Rix, UnrolledLoop);</span>
<span class="line-removed">4789 </span>
<span class="line-removed">4790     z_lgfr(Z_R0, Rcnt);                    // # chars processed in total after unrolled loop.</span>
<span class="line-removed">4791     z_nilf(Z_R0, ~(min_cnt-1));</span>
<span class="line-removed">4792     z_tmll(Rcnt, min_cnt-1);</span>
<span class="line-removed">4793     z_brnaz(ScalarShortcut);               // if all bits zero, there is nothing left to do for scalar loop.</span>
<span class="line-removed">4794                                            // Rix == 0 in all cases.</span>
<span class="line-removed">4795     z_sllg(Z_R1, Rcnt, 1);                 // # src bytes already processed. Only lower 32 bits are valid!</span>
<span class="line-removed">4796                                            //   Z_R1 contents must be treated as unsigned operand! For huge strings,</span>
<span class="line-removed">4797                                            //   (Rcnt &gt;= 2**30), the value may spill into the sign bit by sllg.</span>
<span class="line-removed">4798     z_lgfr(result, Rcnt);                  // all characters processed.</span>
<span class="line-removed">4799     z_slgfr(Rdst, Rcnt);                   // restore ptr</span>
<span class="line-removed">4800     z_slgfr(Rsrc, Z_R1);                   // restore ptr, double the element count for Rsrc restore</span>
<span class="line-removed">4801     z_bru(AllDone);</span>
<span class="line-removed">4802 </span>
<span class="line-removed">4803     bind(UnrolledBreak);</span>
<span class="line-removed">4804     z_lgfr(Z_R0, Rcnt);                    // # chars processed in total after unrolled loop</span>
<span class="line-removed">4805     z_nilf(Z_R0, ~(min_cnt-1));</span>
<span class="line-removed">4806     z_sll(Rix, log_min_cnt);               // # chars not yet processed in UnrolledLoop (due to break), broken iteration not included.</span>
<span class="line-removed">4807     z_sr(Z_R0, Rix);                       // fix # chars processed OK so far.</span>
<span class="line-removed">4808     if (!precise) {</span>
<span class="line-removed">4809       z_lgfr(result, Z_R0);</span>
<span class="line-removed">4810       z_sllg(Z_R1, Z_R0, 1);               // # src bytes already processed. Only lower 32 bits are valid!</span>
<span class="line-removed">4811                                            //   Z_R1 contents must be treated as unsigned operand! For huge strings,</span>
<span class="line-removed">4812                                            //   (Rcnt &gt;= 2**30), the value may spill into the sign bit by sllg.</span>
<span class="line-removed">4813       z_aghi(result, min_cnt/2);           // min_cnt/2 characters have already been written</span>
<span class="line-removed">4814                                            // but ptrs were not updated yet.</span>
<span class="line-removed">4815       z_slgfr(Rdst, Z_R0);                 // restore ptr</span>
<span class="line-removed">4816       z_slgfr(Rsrc, Z_R1);                 // restore ptr, double the element count for Rsrc restore</span>
<span class="line-removed">4817       z_bru(AllDone);</span>
<span class="line-removed">4818     }</span>
<span class="line-removed">4819     bind(UnrolledDone);</span>
<span class="line-removed">4820   }</span>
<span class="line-removed">4821 </span>
<span class="line-removed">4822   {</span>
<span class="line-removed">4823     Label     ScalarLoop, ScalarDone, ScalarBreak;</span>
<span class="line-removed">4824 </span>
<span class="line-removed">4825     bind(ScalarShortcut);</span>
<span class="line-removed">4826     z_ltgfr(result, Rcnt);</span>
<span class="line-removed">4827     z_brz(AllDone);</span>
<span class="line-removed">4828 </span>
<span class="line-removed">4829 #if 0  // Sacrifice shortcuts for code compactness</span>
<span class="line-removed">4830     {</span>
<span class="line-removed">4831       //---&lt;  Special treatment for very short strings (one or two characters)  &gt;---</span>
<span class="line-removed">4832       //   For these strings, we are sure that the above code was skipped.</span>
<span class="line-removed">4833       //   Thus, no registers were modified, register restore is not required.</span>
<span class="line-removed">4834       Label     ScalarDoit, Scalar2Char;</span>
<span class="line-removed">4835       z_chi(Rcnt, 2);</span>
<span class="line-removed">4836       z_brh(ScalarDoit);</span>
<span class="line-removed">4837       z_llh(Z_R1,  0, Z_R0, Rsrc);</span>
<span class="line-removed">4838       z_bre(Scalar2Char);</span>
<span class="line-removed">4839       z_tmll(Z_R1, 0xff00);</span>
<span class="line-removed">4840       z_lghi(result, 0);                   // cnt == 1, first char invalid, no chars successfully processed</span>
<span class="line-removed">4841       z_brnaz(AllDone);</span>
<span class="line-removed">4842       z_stc(Z_R1,  0, Z_R0, Rdst);</span>
<span class="line-removed">4843       z_lghi(result, 1);</span>
<span class="line-removed">4844       z_bru(AllDone);</span>
<span class="line-removed">4845 </span>
<span class="line-removed">4846       bind(Scalar2Char);</span>
<span class="line-removed">4847       z_llh(Z_R0,  2, Z_R0, Rsrc);</span>
<span class="line-removed">4848       z_tmll(Z_R1, 0xff00);</span>
<span class="line-removed">4849       z_lghi(result, 0);                   // cnt == 2, first char invalid, no chars successfully processed</span>
<span class="line-removed">4850       z_brnaz(AllDone);</span>
<span class="line-removed">4851       z_stc(Z_R1,  0, Z_R0, Rdst);</span>
<span class="line-removed">4852       z_tmll(Z_R0, 0xff00);</span>
<span class="line-removed">4853       z_lghi(result, 1);                   // cnt == 2, second char invalid, one char successfully processed</span>
<span class="line-removed">4854       z_brnaz(AllDone);</span>
<span class="line-removed">4855       z_stc(Z_R0,  1, Z_R0, Rdst);</span>
<span class="line-removed">4856       z_lghi(result, 2);</span>
<span class="line-removed">4857       z_bru(AllDone);</span>
<span class="line-removed">4858 </span>
<span class="line-removed">4859       bind(ScalarDoit);</span>
<span class="line-removed">4860     }</span>
<span class="line-removed">4861 #endif</span>
<span class="line-removed">4862 </span>
<span class="line-removed">4863     if (VM_Version::has_DistinctOpnds()) {</span>
<span class="line-removed">4864       z_srk(Rix, Rcnt, Z_R0);              // remaining # chars to compress in unrolled loop</span>
<span class="line-removed">4865     } else {</span>
<span class="line-removed">4866       z_lr(Rix, Rcnt);</span>
<span class="line-removed">4867       z_sr(Rix, Z_R0);</span>
<span class="line-removed">4868     }</span>
<span class="line-removed">4869     z_lgfr(result, Rcnt);                  // # processed characters (if all runs ok).</span>
<span class="line-removed">4870     z_brz(ScalarDone);                     // uses CC from Rix calculation</span>
<span class="line-removed">4871 </span>
<span class="line-removed">4872     bind(ScalarLoop);</span>
<span class="line-removed">4873       z_llh(Z_R1, 0, Z_R0, Rsrc);</span>
<span class="line-removed">4874       z_tmll(Z_R1, 0xff00);</span>
<span class="line-removed">4875       z_brnaz(ScalarBreak);</span>
<span class="line-removed">4876       z_stc(Z_R1, 0, Z_R0, Rdst);</span>
<span class="line-removed">4877       add2reg(Rsrc, 2);</span>
<span class="line-removed">4878       add2reg(Rdst, 1);</span>
<span class="line-removed">4879       z_brct(Rix, ScalarLoop);</span>
<span class="line-removed">4880 </span>
<span class="line-removed">4881     z_bru(ScalarDone);</span>
<span class="line-removed">4882 </span>
<span class="line-removed">4883     bind(ScalarBreak);</span>
<span class="line-removed">4884     z_sr(result, Rix);</span>
<span class="line-removed">4885 </span>
<span class="line-removed">4886     bind(ScalarDone);</span>
<span class="line-removed">4887     z_sgfr(Rdst, result);                  // restore ptr</span>
<span class="line-removed">4888     z_sgfr(Rsrc, result);                  // restore ptr, double the element count for Rsrc restore</span>
<span class="line-removed">4889     z_sgfr(Rsrc, result);</span>
<span class="line-removed">4890   }</span>
<span class="line-removed">4891   bind(AllDone);</span>
<span class="line-removed">4892 </span>
<span class="line-removed">4893   if (precise) {</span>
<span class="line-removed">4894     BLOCK_COMMENT(&quot;} encode_iso_array&quot;);</span>
<span class="line-removed">4895   } else {</span>
<span class="line-removed">4896     BLOCK_COMMENT(&quot;} string_compress&quot;);</span>
<span class="line-removed">4897   }</span>
<span class="line-removed">4898   return offset() - block_start;</span>
<span class="line-removed">4899 }</span>
<span class="line-removed">4900 </span>
<span class="line-removed">4901 // Inflate byte[] to char[].</span>
<span class="line-removed">4902 unsigned int MacroAssembler::string_inflate_trot(Register src, Register dst, Register cnt, Register tmp) {</span>
<span class="line-removed">4903   int block_start = offset();</span>
<span class="line-removed">4904 </span>
<span class="line-removed">4905   BLOCK_COMMENT(&quot;string_inflate {&quot;);</span>
<span class="line-removed">4906 </span>
<span class="line-removed">4907   Register stop_char = Z_R0;</span>
<span class="line-removed">4908   Register table     = Z_R1;</span>
<span class="line-removed">4909   Register src_addr  = tmp;</span>
<span class="line-removed">4910 </span>
<span class="line-removed">4911   assert_different_registers(Z_R0, Z_R1, tmp, src, dst, cnt);</span>
<span class="line-removed">4912   assert(dst-&gt;encoding()%2 == 0, &quot;must be even reg&quot;);</span>
<span class="line-removed">4913   assert(cnt-&gt;encoding()%2 == 1, &quot;must be odd reg&quot;);</span>
<span class="line-removed">4914   assert(cnt-&gt;encoding() - dst-&gt;encoding() == 1, &quot;must be even/odd pair&quot;);</span>
<span class="line-removed">4915 </span>
<span class="line-removed">4916   StubRoutines::zarch::generate_load_trot_table_addr(this, table);  // kills Z_R0 (if ASSERT)</span>
<span class="line-removed">4917   clear_reg(stop_char);  // Stop character. Not used here, but initialized to have a defined value.</span>
<span class="line-removed">4918   lgr_if_needed(src_addr, src);</span>
<span class="line-removed">4919   z_llgfr(cnt, cnt);     // # src characters, must be a positive simm32.</span>
<span class="line-removed">4920 </span>
<span class="line-removed">4921   translate_ot(dst, src_addr, /* mask = */ 0x0001);</span>
<span class="line-removed">4922 </span>
<span class="line-removed">4923   BLOCK_COMMENT(&quot;} string_inflate&quot;);</span>
<span class="line-removed">4924 </span>
<span class="line-removed">4925   return offset() - block_start;</span>
<span class="line-removed">4926 }</span>
<span class="line-removed">4927 </span>
<span class="line-removed">4928 // Inflate byte[] to char[].</span>
<span class="line-removed">4929 //   Restores: src, dst</span>
<span class="line-removed">4930 //   Uses:     cnt</span>
<span class="line-removed">4931 //   Kills:    tmp, Z_R0, Z_R1.</span>
<span class="line-removed">4932 // Note:</span>
<span class="line-removed">4933 //   cnt is signed int. Do not rely on high word!</span>
<span class="line-removed">4934 //       counts # characters, not bytes.</span>
<span class="line-removed">4935 unsigned int MacroAssembler::string_inflate(Register src, Register dst, Register cnt, Register tmp) {</span>
<span class="line-removed">4936   assert_different_registers(Z_R0, Z_R1, src, dst, cnt, tmp);</span>
<span class="line-removed">4937 </span>
<span class="line-removed">4938   BLOCK_COMMENT(&quot;string_inflate {&quot;);</span>
<span class="line-removed">4939   int block_start = offset();</span>
<span class="line-removed">4940 </span>
<span class="line-removed">4941   Register   Rcnt = cnt;   // # characters (src: bytes, dst: char (2-byte)), remaining after current loop.</span>
<span class="line-removed">4942   Register   Rix  = tmp;   // loop index</span>
<span class="line-removed">4943   Register   Rsrc = src;   // addr(src array)</span>
<span class="line-removed">4944   Register   Rdst = dst;   // addr(dst array)</span>
<span class="line-removed">4945   Label      ScalarShortcut, AllDone;</span>
<span class="line-removed">4946 </span>
<span class="line-removed">4947 #if 0  // Sacrifice shortcuts for code compactness</span>
<span class="line-removed">4948   {</span>
<span class="line-removed">4949     //---&lt;  shortcuts for short strings (very frequent)   &gt;---</span>
<span class="line-removed">4950     Label   skipShortcut, skip4Shortcut;</span>
<span class="line-removed">4951     z_ltr(Rcnt, Rcnt);                     // absolutely nothing to do for strings of len == 0.</span>
<span class="line-removed">4952     z_brz(AllDone);</span>
<span class="line-removed">4953     clear_reg(Z_R0);                       // make sure registers are properly initialized.</span>
<span class="line-removed">4954     clear_reg(Z_R1);</span>
<span class="line-removed">4955     z_chi(Rcnt, 4);</span>
<span class="line-removed">4956     z_brne(skip4Shortcut);                 // 4 characters are very frequent</span>
<span class="line-removed">4957       z_icm(Z_R0, 5,    0, Rsrc);          // Treat exactly 4 characters specially.</span>
<span class="line-removed">4958       z_icm(Z_R1, 5,    2, Rsrc);</span>
<span class="line-removed">4959       z_stm(Z_R0, Z_R1, 0, Rdst);</span>
<span class="line-removed">4960       z_bru(AllDone);</span>
<span class="line-removed">4961     bind(skip4Shortcut);</span>
<span class="line-removed">4962 </span>
<span class="line-removed">4963     z_chi(Rcnt, 8);</span>
<span class="line-removed">4964     z_brh(skipShortcut);                   // There&#39;s a lot to do...</span>
<span class="line-removed">4965     z_lgfr(Z_R0, Rcnt);                    // remaining #characters (&lt;= 8). Precond for scalar loop.</span>
<span class="line-removed">4966                                            // This does not destroy the &quot;register cleared&quot; state of Z_R0.</span>
<span class="line-removed">4967     z_brl(ScalarShortcut);                 // Just a few characters</span>
<span class="line-removed">4968       z_icmh(Z_R0, 5, 0, Rsrc);            // Treat exactly 8 characters specially.</span>
<span class="line-removed">4969       z_icmh(Z_R1, 5, 4, Rsrc);</span>
<span class="line-removed">4970       z_icm(Z_R0,  5, 2, Rsrc);</span>
<span class="line-removed">4971       z_icm(Z_R1,  5, 6, Rsrc);</span>
<span class="line-removed">4972       z_stmg(Z_R0, Z_R1, 0, Rdst);</span>
<span class="line-removed">4973       z_bru(AllDone);</span>
<span class="line-removed">4974     bind(skipShortcut);</span>
<span class="line-removed">4975   }</span>
<span class="line-removed">4976 #endif</span>
<span class="line-removed">4977   clear_reg(Z_R0);                         // make sure register is properly initialized.</span>
<span class="line-removed">4978 </span>
<span class="line-removed">4979   if (VM_Version::has_VectorFacility()) {</span>
<span class="line-removed">4980     const int  min_vcnt     = 32;          // Minimum #characters required to use vector instructions.</span>
<span class="line-removed">4981                                            // Otherwise just do nothing in vector mode.</span>
<span class="line-removed">4982                                            // Must be multiple of vector register length (16 bytes = 128 bits).</span>
<span class="line-removed">4983     const int  log_min_vcnt = exact_log2(min_vcnt);</span>
<span class="line-removed">4984     Label      VectorLoop, VectorDone;</span>
<span class="line-removed">4985 </span>
<span class="line-removed">4986     assert(VM_Version::has_DistinctOpnds(), &quot;Assumption when has_VectorFacility()&quot;);</span>
<span class="line-removed">4987     z_srak(Rix, Rcnt, log_min_vcnt);       // calculate # vector loop iterations</span>
<span class="line-removed">4988     z_brz(VectorDone);                     // skip if none</span>
<span class="line-removed">4989 </span>
<span class="line-removed">4990     z_sllg(Z_R0, Rix, log_min_vcnt);       // remember #chars that will be processed by vector loop</span>
<span class="line-removed">4991 </span>
<span class="line-removed">4992     bind(VectorLoop);</span>
<span class="line-removed">4993       z_vlm(Z_V20, Z_V21, 0, Rsrc);        // get next 32 characters (single-byte)</span>
<span class="line-removed">4994       add2reg(Rsrc, min_vcnt);</span>
<span class="line-removed">4995 </span>
<span class="line-removed">4996       z_vuplhb(Z_V22, Z_V20);              // V2 &lt;- (expand) V0(high)</span>
<span class="line-removed">4997       z_vupllb(Z_V23, Z_V20);              // V3 &lt;- (expand) V0(low)</span>
<span class="line-removed">4998       z_vuplhb(Z_V24, Z_V21);              // V4 &lt;- (expand) V1(high)</span>
<span class="line-removed">4999       z_vupllb(Z_V25, Z_V21);              // V5 &lt;- (expand) V1(low)</span>
<span class="line-removed">5000       z_vstm(Z_V22, Z_V25, 0, Rdst);       // store next 32 bytes</span>
<span class="line-removed">5001       add2reg(Rdst, min_vcnt*2);</span>
<span class="line-removed">5002 </span>
<span class="line-removed">5003       z_brct(Rix, VectorLoop);</span>
<span class="line-removed">5004 </span>
<span class="line-removed">5005     bind(VectorDone);</span>
<span class="line-removed">5006   }</span>
<span class="line-removed">5007 </span>
<span class="line-removed">5008   const int  min_cnt     =  8;             // Minimum #characters required to use unrolled scalar loop.</span>
<span class="line-removed">5009                                            // Otherwise just do nothing in unrolled scalar mode.</span>
<span class="line-removed">5010                                            // Must be multiple of 8.</span>
<span class="line-removed">5011   {</span>
<span class="line-removed">5012     const int  log_min_cnt = exact_log2(min_cnt);</span>
<span class="line-removed">5013     Label      UnrolledLoop, UnrolledDone;</span>
<span class="line-removed">5014 </span>
<span class="line-removed">5015 </span>
<span class="line-removed">5016     if (VM_Version::has_DistinctOpnds()) {</span>
<span class="line-removed">5017       z_srk(Rix, Rcnt, Z_R0);              // remaining # chars to process in unrolled loop</span>
<span class="line-removed">5018     } else {</span>
<span class="line-removed">5019       z_lr(Rix, Rcnt);</span>
<span class="line-removed">5020       z_sr(Rix, Z_R0);</span>
<span class="line-removed">5021     }</span>
<span class="line-removed">5022     z_sra(Rix, log_min_cnt);               // unrolled loop count</span>
<span class="line-removed">5023     z_brz(UnrolledDone);</span>
<span class="line-removed">5024 </span>
<span class="line-removed">5025     clear_reg(Z_R0);</span>
<span class="line-removed">5026     clear_reg(Z_R1);</span>
<span class="line-removed">5027 </span>
<span class="line-removed">5028     bind(UnrolledLoop);</span>
<span class="line-removed">5029       z_icmh(Z_R0, 5, 0, Rsrc);</span>
<span class="line-removed">5030       z_icmh(Z_R1, 5, 4, Rsrc);</span>
<span class="line-removed">5031       z_icm(Z_R0,  5, 2, Rsrc);</span>
<span class="line-removed">5032       z_icm(Z_R1,  5, 6, Rsrc);</span>
<span class="line-removed">5033       add2reg(Rsrc, min_cnt);</span>
<span class="line-removed">5034 </span>
<span class="line-removed">5035       z_stmg(Z_R0, Z_R1, 0, Rdst);</span>
<span class="line-removed">5036 </span>
<span class="line-removed">5037       add2reg(Rdst, min_cnt*2);</span>
<span class="line-removed">5038       z_brct(Rix, UnrolledLoop);</span>
<span class="line-removed">5039 </span>
<span class="line-removed">5040     bind(UnrolledDone);</span>
<span class="line-removed">5041     z_lgfr(Z_R0, Rcnt);                    // # chars left over after unrolled loop.</span>
<span class="line-removed">5042     z_nilf(Z_R0, min_cnt-1);</span>
<span class="line-removed">5043     z_brnz(ScalarShortcut);                // if zero, there is nothing left to do for scalar loop.</span>
<span class="line-removed">5044                                            // Rix == 0 in all cases.</span>
<span class="line-removed">5045     z_sgfr(Z_R0, Rcnt);                    // negative # characters the ptrs have been advanced previously.</span>
<span class="line-removed">5046     z_agr(Rdst, Z_R0);                     // restore ptr, double the element count for Rdst restore.</span>
<span class="line-removed">5047     z_agr(Rdst, Z_R0);</span>
<span class="line-removed">5048     z_agr(Rsrc, Z_R0);                     // restore ptr.</span>
<span class="line-removed">5049     z_bru(AllDone);</span>
<span class="line-removed">5050   }</span>
<span class="line-removed">5051 </span>
<span class="line-removed">5052   {</span>
<span class="line-removed">5053     bind(ScalarShortcut);</span>
<span class="line-removed">5054     // Z_R0 must contain remaining # characters as 64-bit signed int here.</span>
<span class="line-removed">5055     //      register contents is preserved over scalar processing (for register fixup).</span>
<span class="line-removed">5056 </span>
<span class="line-removed">5057 #if 0  // Sacrifice shortcuts for code compactness</span>
<span class="line-removed">5058     {</span>
<span class="line-removed">5059       Label      ScalarDefault;</span>
<span class="line-removed">5060       z_chi(Rcnt, 2);</span>
<span class="line-removed">5061       z_brh(ScalarDefault);</span>
<span class="line-removed">5062       z_llc(Z_R0,  0, Z_R0, Rsrc);     // 6 bytes</span>
<span class="line-removed">5063       z_sth(Z_R0,  0, Z_R0, Rdst);     // 4 bytes</span>
<span class="line-removed">5064       z_brl(AllDone);</span>
<span class="line-removed">5065       z_llc(Z_R0,  1, Z_R0, Rsrc);     // 6 bytes</span>
<span class="line-removed">5066       z_sth(Z_R0,  2, Z_R0, Rdst);     // 4 bytes</span>
<span class="line-removed">5067       z_bru(AllDone);</span>
<span class="line-removed">5068       bind(ScalarDefault);</span>
<span class="line-removed">5069     }</span>
<span class="line-removed">5070 #endif</span>
<span class="line-removed">5071 </span>
<span class="line-removed">5072     Label   CodeTable;</span>
<span class="line-removed">5073     // Some comments on Rix calculation:</span>
<span class="line-removed">5074     //  - Rcnt is small, therefore no bits shifted out of low word (sll(g) instructions).</span>
<span class="line-removed">5075     //  - high word of both Rix and Rcnt may contain garbage</span>
<span class="line-removed">5076     //  - the final lngfr takes care of that garbage, extending the sign to high word</span>
<span class="line-removed">5077     z_sllg(Rix, Z_R0, 2);                // calculate 10*Rix = (4*Rix + Rix)*2</span>
<span class="line-removed">5078     z_ar(Rix, Z_R0);</span>
<span class="line-removed">5079     z_larl(Z_R1, CodeTable);</span>
<span class="line-removed">5080     z_sll(Rix, 1);</span>
<span class="line-removed">5081     z_lngfr(Rix, Rix);      // ix range: [0..7], after inversion &amp; mult: [-(7*12)..(0*12)].</span>
<span class="line-removed">5082     z_bc(Assembler::bcondAlways, 0, Rix, Z_R1);</span>
<span class="line-removed">5083 </span>
<span class="line-removed">5084     z_llc(Z_R1,  6, Z_R0, Rsrc);  // 6 bytes</span>
<span class="line-removed">5085     z_sth(Z_R1, 12, Z_R0, Rdst);  // 4 bytes</span>
<span class="line-removed">5086 </span>
<span class="line-removed">5087     z_llc(Z_R1,  5, Z_R0, Rsrc);</span>
<span class="line-removed">5088     z_sth(Z_R1, 10, Z_R0, Rdst);</span>
<span class="line-removed">5089 </span>
<span class="line-removed">5090     z_llc(Z_R1,  4, Z_R0, Rsrc);</span>
<span class="line-removed">5091     z_sth(Z_R1,  8, Z_R0, Rdst);</span>
<span class="line-removed">5092 </span>
<span class="line-removed">5093     z_llc(Z_R1,  3, Z_R0, Rsrc);</span>
<span class="line-removed">5094     z_sth(Z_R1,  6, Z_R0, Rdst);</span>
<span class="line-removed">5095 </span>
<span class="line-removed">5096     z_llc(Z_R1,  2, Z_R0, Rsrc);</span>
<span class="line-removed">5097     z_sth(Z_R1,  4, Z_R0, Rdst);</span>
<span class="line-removed">5098 </span>
<span class="line-removed">5099     z_llc(Z_R1,  1, Z_R0, Rsrc);</span>
<span class="line-removed">5100     z_sth(Z_R1,  2, Z_R0, Rdst);</span>
<span class="line-removed">5101 </span>
<span class="line-removed">5102     z_llc(Z_R1,  0, Z_R0, Rsrc);</span>
<span class="line-removed">5103     z_sth(Z_R1,  0, Z_R0, Rdst);</span>
<span class="line-removed">5104     bind(CodeTable);</span>
<span class="line-removed">5105 </span>
<span class="line-removed">5106     z_chi(Rcnt, 8);                        // no fixup for small strings. Rdst, Rsrc were not modified.</span>
<span class="line-removed">5107     z_brl(AllDone);</span>
<span class="line-removed">5108 </span>
<span class="line-removed">5109     z_sgfr(Z_R0, Rcnt);                    // # characters the ptrs have been advanced previously.</span>
<span class="line-removed">5110     z_agr(Rdst, Z_R0);                     // restore ptr, double the element count for Rdst restore.</span>
<span class="line-removed">5111     z_agr(Rdst, Z_R0);</span>
<span class="line-removed">5112     z_agr(Rsrc, Z_R0);                     // restore ptr.</span>
<span class="line-removed">5113   }</span>
<span class="line-removed">5114   bind(AllDone);</span>
<span class="line-removed">5115 </span>
<span class="line-removed">5116   BLOCK_COMMENT(&quot;} string_inflate&quot;);</span>
<span class="line-removed">5117   return offset() - block_start;</span>
<span class="line-removed">5118 }</span>
<span class="line-removed">5119 </span>
<span class="line-removed">5120 // Inflate byte[] to char[], length known at compile time.</span>
<span class="line-removed">5121 //   Restores: src, dst</span>
<span class="line-removed">5122 //   Kills:    tmp, Z_R0, Z_R1.</span>
<span class="line-removed">5123 // Note:</span>
<span class="line-removed">5124 //   len is signed int. Counts # characters, not bytes.</span>
<span class="line-removed">5125 unsigned int MacroAssembler::string_inflate_const(Register src, Register dst, Register tmp, int len) {</span>
<span class="line-removed">5126   assert_different_registers(Z_R0, Z_R1, src, dst, tmp);</span>
<span class="line-removed">5127 </span>
<span class="line-removed">5128   BLOCK_COMMENT(&quot;string_inflate_const {&quot;);</span>
<span class="line-removed">5129   int block_start = offset();</span>
<span class="line-removed">5130 </span>
<span class="line-removed">5131   Register   Rix  = tmp;   // loop index</span>
<span class="line-removed">5132   Register   Rsrc = src;   // addr(src array)</span>
<span class="line-removed">5133   Register   Rdst = dst;   // addr(dst array)</span>
<span class="line-removed">5134   Label      ScalarShortcut, AllDone;</span>
<span class="line-removed">5135   int        nprocessed = 0;</span>
<span class="line-removed">5136   int        src_off    = 0;  // compensate for saved (optimized away) ptr advancement.</span>
<span class="line-removed">5137   int        dst_off    = 0;  // compensate for saved (optimized away) ptr advancement.</span>
<span class="line-removed">5138   bool       restore_inputs = false;</span>
<span class="line-removed">5139   bool       workreg_clear  = false;</span>
<span class="line-removed">5140 </span>
<span class="line-removed">5141   if ((len &gt;= 32) &amp;&amp; VM_Version::has_VectorFacility()) {</span>
<span class="line-removed">5142     const int  min_vcnt     = 32;          // Minimum #characters required to use vector instructions.</span>
<span class="line-removed">5143                                            // Otherwise just do nothing in vector mode.</span>
<span class="line-removed">5144                                            // Must be multiple of vector register length (16 bytes = 128 bits).</span>
<span class="line-removed">5145     const int  log_min_vcnt = exact_log2(min_vcnt);</span>
<span class="line-removed">5146     const int  iterations   = (len - nprocessed) &gt;&gt; log_min_vcnt;</span>
<span class="line-removed">5147     nprocessed             += iterations &lt;&lt; log_min_vcnt;</span>
<span class="line-removed">5148     Label      VectorLoop;</span>
<span class="line-removed">5149 </span>
<span class="line-removed">5150     if (iterations == 1) {</span>
<span class="line-removed">5151       z_vlm(Z_V20, Z_V21, 0+src_off, Rsrc);  // get next 32 characters (single-byte)</span>
<span class="line-removed">5152       z_vuplhb(Z_V22, Z_V20);                // V2 &lt;- (expand) V0(high)</span>
<span class="line-removed">5153       z_vupllb(Z_V23, Z_V20);                // V3 &lt;- (expand) V0(low)</span>
<span class="line-removed">5154       z_vuplhb(Z_V24, Z_V21);                // V4 &lt;- (expand) V1(high)</span>
<span class="line-removed">5155       z_vupllb(Z_V25, Z_V21);                // V5 &lt;- (expand) V1(low)</span>
<span class="line-removed">5156       z_vstm(Z_V22, Z_V25, 0+dst_off, Rdst); // store next 32 bytes</span>
<span class="line-removed">5157 </span>
<span class="line-removed">5158       src_off += min_vcnt;</span>
<span class="line-removed">5159       dst_off += min_vcnt*2;</span>
<span class="line-removed">5160     } else {</span>
<span class="line-removed">5161       restore_inputs = true;</span>
<span class="line-removed">5162 </span>
<span class="line-removed">5163       z_lgfi(Rix, len&gt;&gt;log_min_vcnt);</span>
<span class="line-removed">5164       bind(VectorLoop);</span>
<span class="line-removed">5165         z_vlm(Z_V20, Z_V21, 0, Rsrc);        // get next 32 characters (single-byte)</span>
<span class="line-removed">5166         add2reg(Rsrc, min_vcnt);</span>
<span class="line-removed">5167 </span>
<span class="line-removed">5168         z_vuplhb(Z_V22, Z_V20);              // V2 &lt;- (expand) V0(high)</span>
<span class="line-removed">5169         z_vupllb(Z_V23, Z_V20);              // V3 &lt;- (expand) V0(low)</span>
<span class="line-removed">5170         z_vuplhb(Z_V24, Z_V21);              // V4 &lt;- (expand) V1(high)</span>
<span class="line-removed">5171         z_vupllb(Z_V25, Z_V21);              // V5 &lt;- (expand) V1(low)</span>
<span class="line-removed">5172         z_vstm(Z_V22, Z_V25, 0, Rdst);       // store next 32 bytes</span>
<span class="line-removed">5173         add2reg(Rdst, min_vcnt*2);</span>
<span class="line-removed">5174 </span>
<span class="line-removed">5175         z_brct(Rix, VectorLoop);</span>
<span class="line-removed">5176     }</span>
<span class="line-removed">5177   }</span>
<span class="line-removed">5178 </span>
<span class="line-removed">5179   if (((len-nprocessed) &gt;= 16) &amp;&amp; VM_Version::has_VectorFacility()) {</span>
<span class="line-removed">5180     const int  min_vcnt     = 16;          // Minimum #characters required to use vector instructions.</span>
<span class="line-removed">5181                                            // Otherwise just do nothing in vector mode.</span>
<span class="line-removed">5182                                            // Must be multiple of vector register length (16 bytes = 128 bits).</span>
<span class="line-removed">5183     const int  log_min_vcnt = exact_log2(min_vcnt);</span>
<span class="line-removed">5184     const int  iterations   = (len - nprocessed) &gt;&gt; log_min_vcnt;</span>
<span class="line-removed">5185     nprocessed             += iterations &lt;&lt; log_min_vcnt;</span>
<span class="line-removed">5186     assert(iterations == 1, &quot;must be!&quot;);</span>
<span class="line-removed">5187 </span>
<span class="line-removed">5188     z_vl(Z_V20, 0+src_off, Z_R0, Rsrc);    // get next 16 characters (single-byte)</span>
<span class="line-removed">5189     z_vuplhb(Z_V22, Z_V20);                // V2 &lt;- (expand) V0(high)</span>
<span class="line-removed">5190     z_vupllb(Z_V23, Z_V20);                // V3 &lt;- (expand) V0(low)</span>
<span class="line-removed">5191     z_vstm(Z_V22, Z_V23, 0+dst_off, Rdst); // store next 32 bytes</span>
<span class="line-removed">5192 </span>
<span class="line-removed">5193     src_off += min_vcnt;</span>
<span class="line-removed">5194     dst_off += min_vcnt*2;</span>
<span class="line-removed">5195   }</span>
<span class="line-removed">5196 </span>
<span class="line-removed">5197   if ((len-nprocessed) &gt; 8) {</span>
<span class="line-removed">5198     const int  min_cnt     =  8;           // Minimum #characters required to use unrolled scalar loop.</span>
<span class="line-removed">5199                                            // Otherwise just do nothing in unrolled scalar mode.</span>
<span class="line-removed">5200                                            // Must be multiple of 8.</span>
<span class="line-removed">5201     const int  log_min_cnt = exact_log2(min_cnt);</span>
<span class="line-removed">5202     const int  iterations  = (len - nprocessed) &gt;&gt; log_min_cnt;</span>
<span class="line-removed">5203     nprocessed     += iterations &lt;&lt; log_min_cnt;</span>
<span class="line-removed">5204 </span>
<span class="line-removed">5205     //---&lt;  avoid loop overhead/ptr increment for small # iterations  &gt;---</span>
<span class="line-removed">5206     if (iterations &lt;= 2) {</span>
<span class="line-removed">5207       clear_reg(Z_R0);</span>
<span class="line-removed">5208       clear_reg(Z_R1);</span>
<span class="line-removed">5209       workreg_clear = true;</span>
<span class="line-removed">5210 </span>
<span class="line-removed">5211       z_icmh(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="line-removed">5212       z_icmh(Z_R1, 5, 4+src_off, Rsrc);</span>
<span class="line-removed">5213       z_icm(Z_R0,  5, 2+src_off, Rsrc);</span>
<span class="line-removed">5214       z_icm(Z_R1,  5, 6+src_off, Rsrc);</span>
<span class="line-removed">5215       z_stmg(Z_R0, Z_R1, 0+dst_off, Rdst);</span>
<span class="line-removed">5216 </span>
<span class="line-removed">5217       src_off += min_cnt;</span>
<span class="line-removed">5218       dst_off += min_cnt*2;</span>
<span class="line-removed">5219     }</span>
<span class="line-removed">5220 </span>
<span class="line-removed">5221     if (iterations == 2) {</span>
<span class="line-removed">5222       z_icmh(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="line-removed">5223       z_icmh(Z_R1, 5, 4+src_off, Rsrc);</span>
<span class="line-removed">5224       z_icm(Z_R0,  5, 2+src_off, Rsrc);</span>
<span class="line-removed">5225       z_icm(Z_R1,  5, 6+src_off, Rsrc);</span>
<span class="line-removed">5226       z_stmg(Z_R0, Z_R1, 0+dst_off, Rdst);</span>
<span class="line-removed">5227 </span>
<span class="line-removed">5228       src_off += min_cnt;</span>
<span class="line-removed">5229       dst_off += min_cnt*2;</span>
<span class="line-removed">5230     }</span>
<span class="line-removed">5231 </span>
<span class="line-removed">5232     if (iterations &gt; 2) {</span>
<span class="line-removed">5233       Label      UnrolledLoop;</span>
<span class="line-removed">5234       restore_inputs  = true;</span>
<span class="line-removed">5235 </span>
<span class="line-removed">5236       clear_reg(Z_R0);</span>
<span class="line-removed">5237       clear_reg(Z_R1);</span>
<span class="line-removed">5238       workreg_clear = true;</span>
<span class="line-removed">5239 </span>
<span class="line-removed">5240       z_lgfi(Rix, iterations);</span>
<span class="line-removed">5241       bind(UnrolledLoop);</span>
<span class="line-removed">5242         z_icmh(Z_R0, 5, 0, Rsrc);</span>
<span class="line-removed">5243         z_icmh(Z_R1, 5, 4, Rsrc);</span>
<span class="line-removed">5244         z_icm(Z_R0,  5, 2, Rsrc);</span>
<span class="line-removed">5245         z_icm(Z_R1,  5, 6, Rsrc);</span>
<span class="line-removed">5246         add2reg(Rsrc, min_cnt);</span>
<span class="line-removed">5247 </span>
<span class="line-removed">5248         z_stmg(Z_R0, Z_R1, 0, Rdst);</span>
<span class="line-removed">5249         add2reg(Rdst, min_cnt*2);</span>
<span class="line-removed">5250 </span>
<span class="line-removed">5251         z_brct(Rix, UnrolledLoop);</span>
<span class="line-removed">5252     }</span>
<span class="line-removed">5253   }</span>
<span class="line-removed">5254 </span>
<span class="line-removed">5255   if ((len-nprocessed) &gt; 0) {</span>
<span class="line-removed">5256     switch (len-nprocessed) {</span>
<span class="line-removed">5257       case 8:</span>
<span class="line-removed">5258         if (!workreg_clear) {</span>
<span class="line-removed">5259           clear_reg(Z_R0);</span>
<span class="line-removed">5260           clear_reg(Z_R1);</span>
<span class="line-removed">5261         }</span>
<span class="line-removed">5262         z_icmh(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="line-removed">5263         z_icmh(Z_R1, 5, 4+src_off, Rsrc);</span>
<span class="line-removed">5264         z_icm(Z_R0,  5, 2+src_off, Rsrc);</span>
<span class="line-removed">5265         z_icm(Z_R1,  5, 6+src_off, Rsrc);</span>
<span class="line-removed">5266         z_stmg(Z_R0, Z_R1, 0+dst_off, Rdst);</span>
<span class="line-removed">5267         break;</span>
<span class="line-removed">5268       case 7:</span>
<span class="line-removed">5269         if (!workreg_clear) {</span>
<span class="line-removed">5270           clear_reg(Z_R0);</span>
<span class="line-removed">5271           clear_reg(Z_R1);</span>
<span class="line-removed">5272         }</span>
<span class="line-removed">5273         clear_reg(Rix);</span>
<span class="line-removed">5274         z_icm(Z_R0,  5, 0+src_off, Rsrc);</span>
<span class="line-removed">5275         z_icm(Z_R1,  5, 2+src_off, Rsrc);</span>
<span class="line-removed">5276         z_icm(Rix,   5, 4+src_off, Rsrc);</span>
<span class="line-removed">5277         z_stm(Z_R0,  Z_R1, 0+dst_off, Rdst);</span>
<span class="line-removed">5278         z_llc(Z_R0,  6+src_off, Z_R0, Rsrc);</span>
<span class="line-removed">5279         z_st(Rix,    8+dst_off, Z_R0, Rdst);</span>
<span class="line-removed">5280         z_sth(Z_R0, 12+dst_off, Z_R0, Rdst);</span>
<span class="line-removed">5281         break;</span>
<span class="line-removed">5282       case 6:</span>
<span class="line-removed">5283         if (!workreg_clear) {</span>
<span class="line-removed">5284           clear_reg(Z_R0);</span>
<span class="line-removed">5285           clear_reg(Z_R1);</span>
<span class="line-removed">5286         }</span>
<span class="line-removed">5287         clear_reg(Rix);</span>
<span class="line-removed">5288         z_icm(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="line-removed">5289         z_icm(Z_R1, 5, 2+src_off, Rsrc);</span>
<span class="line-removed">5290         z_icm(Rix,  5, 4+src_off, Rsrc);</span>
<span class="line-removed">5291         z_stm(Z_R0, Z_R1, 0+dst_off, Rdst);</span>
<span class="line-removed">5292         z_st(Rix,   8+dst_off, Z_R0, Rdst);</span>
<span class="line-removed">5293         break;</span>
<span class="line-removed">5294       case 5:</span>
<span class="line-removed">5295         if (!workreg_clear) {</span>
<span class="line-removed">5296           clear_reg(Z_R0);</span>
<span class="line-removed">5297           clear_reg(Z_R1);</span>
<span class="line-removed">5298         }</span>
<span class="line-removed">5299         z_icm(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="line-removed">5300         z_icm(Z_R1, 5, 2+src_off, Rsrc);</span>
<span class="line-removed">5301         z_llc(Rix,  4+src_off, Z_R0, Rsrc);</span>
<span class="line-removed">5302         z_stm(Z_R0, Z_R1, 0+dst_off, Rdst);</span>
<span class="line-removed">5303         z_sth(Rix,  8+dst_off, Z_R0, Rdst);</span>
<span class="line-removed">5304         break;</span>
<span class="line-removed">5305       case 4:</span>
<span class="line-removed">5306         if (!workreg_clear) {</span>
<span class="line-removed">5307           clear_reg(Z_R0);</span>
<span class="line-removed">5308           clear_reg(Z_R1);</span>
<span class="line-removed">5309         }</span>
<span class="line-removed">5310         z_icm(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="line-removed">5311         z_icm(Z_R1, 5, 2+src_off, Rsrc);</span>
<span class="line-removed">5312         z_stm(Z_R0, Z_R1, 0+dst_off, Rdst);</span>
<span class="line-removed">5313         break;</span>
<span class="line-removed">5314       case 3:</span>
<span class="line-removed">5315         if (!workreg_clear) {</span>
<span class="line-removed">5316           clear_reg(Z_R0);</span>
<span class="line-removed">5317         }</span>
<span class="line-removed">5318         z_llc(Z_R1, 2+src_off, Z_R0, Rsrc);</span>
<span class="line-removed">5319         z_icm(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="line-removed">5320         z_sth(Z_R1, 4+dst_off, Z_R0, Rdst);</span>
<span class="line-removed">5321         z_st(Z_R0,  0+dst_off, Rdst);</span>
<span class="line-removed">5322         break;</span>
<span class="line-removed">5323       case 2:</span>
<span class="line-removed">5324         z_llc(Z_R0, 0+src_off, Z_R0, Rsrc);</span>
<span class="line-removed">5325         z_llc(Z_R1, 1+src_off, Z_R0, Rsrc);</span>
<span class="line-removed">5326         z_sth(Z_R0, 0+dst_off, Z_R0, Rdst);</span>
<span class="line-removed">5327         z_sth(Z_R1, 2+dst_off, Z_R0, Rdst);</span>
<span class="line-removed">5328         break;</span>
<span class="line-removed">5329       case 1:</span>
<span class="line-removed">5330         z_llc(Z_R0, 0+src_off, Z_R0, Rsrc);</span>
<span class="line-removed">5331         z_sth(Z_R0, 0+dst_off, Z_R0, Rdst);</span>
<span class="line-removed">5332         break;</span>
<span class="line-removed">5333       default:</span>
<span class="line-removed">5334         guarantee(false, &quot;Impossible&quot;);</span>
<span class="line-removed">5335         break;</span>
<span class="line-removed">5336     }</span>
<span class="line-removed">5337     src_off   +=  len-nprocessed;</span>
<span class="line-removed">5338     dst_off   += (len-nprocessed)*2;</span>
<span class="line-removed">5339     nprocessed = len;</span>
<span class="line-removed">5340   }</span>
<span class="line-removed">5341 </span>
<span class="line-removed">5342   //---&lt; restore modified input registers  &gt;---</span>
<span class="line-removed">5343   if ((nprocessed &gt; 0) &amp;&amp; restore_inputs) {</span>
<span class="line-removed">5344     z_agfi(Rsrc, -(nprocessed-src_off));</span>
<span class="line-removed">5345     if (nprocessed &lt; 1000000000) { // avoid int overflow</span>
<span class="line-removed">5346       z_agfi(Rdst, -(nprocessed*2-dst_off));</span>
<span class="line-removed">5347     } else {</span>
<span class="line-removed">5348       z_agfi(Rdst, -(nprocessed-dst_off));</span>
<span class="line-removed">5349       z_agfi(Rdst, -nprocessed);</span>
<span class="line-removed">5350     }</span>
<span class="line-removed">5351   }</span>
<span class="line-removed">5352 </span>
<span class="line-removed">5353   BLOCK_COMMENT(&quot;} string_inflate_const&quot;);</span>
<span class="line-removed">5354   return offset() - block_start;</span>
<span class="line-removed">5355 }</span>
<span class="line-removed">5356 </span>
<span class="line-removed">5357 // Kills src.</span>
<span class="line-removed">5358 unsigned int MacroAssembler::has_negatives(Register result, Register src, Register cnt,</span>
<span class="line-removed">5359                                            Register odd_reg, Register even_reg, Register tmp) {</span>
<span class="line-removed">5360   int block_start = offset();</span>
<span class="line-removed">5361   Label Lloop1, Lloop2, Lslow, Lnotfound, Ldone;</span>
<span class="line-removed">5362   const Register addr = src, mask = tmp;</span>
<span class="line-removed">5363 </span>
<span class="line-removed">5364   BLOCK_COMMENT(&quot;has_negatives {&quot;);</span>
<span class="line-removed">5365 </span>
<span class="line-removed">5366   z_llgfr(Z_R1, cnt);      // Number of bytes to read. (Must be a positive simm32.)</span>
<span class="line-removed">5367   z_llilf(mask, 0x80808080);</span>
<span class="line-removed">5368   z_lhi(result, 1);        // Assume true.</span>
<span class="line-removed">5369   // Last possible addr for fast loop.</span>
<span class="line-removed">5370   z_lay(odd_reg, -16, Z_R1, src);</span>
<span class="line-removed">5371   z_chi(cnt, 16);</span>
<span class="line-removed">5372   z_brl(Lslow);</span>
<span class="line-removed">5373 </span>
<span class="line-removed">5374   // ind1: index, even_reg: index increment, odd_reg: index limit</span>
<span class="line-removed">5375   z_iihf(mask, 0x80808080);</span>
<span class="line-removed">5376   z_lghi(even_reg, 16);</span>
<span class="line-removed">5377 </span>
<span class="line-removed">5378   bind(Lloop1); // 16 bytes per iteration.</span>
<span class="line-removed">5379   z_lg(Z_R0, Address(addr));</span>
<span class="line-removed">5380   z_lg(Z_R1, Address(addr, 8));</span>
<span class="line-removed">5381   z_ogr(Z_R0, Z_R1);</span>
<span class="line-removed">5382   z_ngr(Z_R0, mask);</span>
<span class="line-removed">5383   z_brne(Ldone);           // If found return 1.</span>
<span class="line-removed">5384   z_brxlg(addr, even_reg, Lloop1);</span>
<span class="line-removed">5385 </span>
<span class="line-removed">5386   bind(Lslow);</span>
<span class="line-removed">5387   z_aghi(odd_reg, 16-1);   // Last possible addr for slow loop.</span>
<span class="line-removed">5388   z_lghi(even_reg, 1);</span>
<span class="line-removed">5389   z_cgr(addr, odd_reg);</span>
<span class="line-removed">5390   z_brh(Lnotfound);</span>
<span class="line-removed">5391 </span>
<span class="line-removed">5392   bind(Lloop2); // 1 byte per iteration.</span>
<span class="line-removed">5393   z_cli(Address(addr), 0x80);</span>
<span class="line-removed">5394   z_brnl(Ldone);           // If found return 1.</span>
<span class="line-removed">5395   z_brxlg(addr, even_reg, Lloop2);</span>
<span class="line-removed">5396 </span>
<span class="line-removed">5397   bind(Lnotfound);</span>
<span class="line-removed">5398   z_lhi(result, 0);</span>
<span class="line-removed">5399 </span>
<span class="line-removed">5400   bind(Ldone);</span>
<span class="line-removed">5401 </span>
<span class="line-removed">5402   BLOCK_COMMENT(&quot;} has_negatives&quot;);</span>
<span class="line-removed">5403 </span>
<span class="line-removed">5404   return offset() - block_start;</span>
<span class="line-removed">5405 }</span>
<span class="line-removed">5406 </span>
<span class="line-removed">5407 // kill: cnt1, cnt2, odd_reg, even_reg; early clobber: result</span>
<span class="line-removed">5408 unsigned int MacroAssembler::string_compare(Register str1, Register str2,</span>
<span class="line-removed">5409                                             Register cnt1, Register cnt2,</span>
<span class="line-removed">5410                                             Register odd_reg, Register even_reg, Register result, int ae) {</span>
<span class="line-removed">5411   int block_start = offset();</span>
<span class="line-removed">5412 </span>
<span class="line-removed">5413   assert_different_registers(str1, cnt1, cnt2, odd_reg, even_reg, result);</span>
<span class="line-removed">5414   assert_different_registers(str2, cnt1, cnt2, odd_reg, even_reg, result);</span>
<span class="line-removed">5415 </span>
<span class="line-removed">5416   // If strings are equal up to min length, return the length difference.</span>
<span class="line-removed">5417   const Register diff = result, // Pre-set result with length difference.</span>
<span class="line-removed">5418                  min  = cnt1,   // min number of bytes</span>
<span class="line-removed">5419                  tmp  = cnt2;</span>
<span class="line-removed">5420 </span>
<span class="line-removed">5421   // Note: Making use of the fact that compareTo(a, b) == -compareTo(b, a)</span>
<span class="line-removed">5422   // we interchange str1 and str2 in the UL case and negate the result.</span>
<span class="line-removed">5423   // Like this, str1 is always latin1 encoded, except for the UU case.</span>
<span class="line-removed">5424   // In addition, we need 0 (or sign which is 0) extend when using 64 bit register.</span>
<span class="line-removed">5425   const bool used_as_LU = (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL);</span>
<span class="line-removed">5426 </span>
<span class="line-removed">5427   BLOCK_COMMENT(&quot;string_compare {&quot;);</span>
<span class="line-removed">5428 </span>
<span class="line-removed">5429   if (used_as_LU) {</span>
<span class="line-removed">5430     z_srl(cnt2, 1);</span>
<span class="line-removed">5431   }</span>
<span class="line-removed">5432 </span>
<span class="line-removed">5433   // See if the lengths are different, and calculate min in cnt1.</span>
<span class="line-removed">5434   // Save diff in case we need it for a tie-breaker.</span>
<span class="line-removed">5435 </span>
<span class="line-removed">5436   // diff = cnt1 - cnt2</span>
<span class="line-removed">5437   if (VM_Version::has_DistinctOpnds()) {</span>
<span class="line-removed">5438     z_srk(diff, cnt1, cnt2);</span>
<span class="line-removed">5439   } else {</span>
<span class="line-removed">5440     z_lr(diff, cnt1);</span>
<span class="line-removed">5441     z_sr(diff, cnt2);</span>
<span class="line-removed">5442   }</span>
<span class="line-removed">5443   if (str1 != str2) {</span>
<span class="line-removed">5444     if (VM_Version::has_LoadStoreConditional()) {</span>
<span class="line-removed">5445       z_locr(min, cnt2, Assembler::bcondHigh);</span>
<span class="line-removed">5446     } else {</span>
<span class="line-removed">5447       Label Lskip;</span>
<span class="line-removed">5448       z_brl(Lskip);    // min ok if cnt1 &lt; cnt2</span>
<span class="line-removed">5449       z_lr(min, cnt2); // min = cnt2</span>
<span class="line-removed">5450       bind(Lskip);</span>
<span class="line-removed">5451     }</span>
<span class="line-removed">5452   }</span>
<span class="line-removed">5453 </span>
<span class="line-removed">5454   if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">5455     z_sra(diff, 1);</span>
<span class="line-removed">5456   }</span>
<span class="line-removed">5457   if (str1 != str2) {</span>
<span class="line-removed">5458     Label Ldone;</span>
<span class="line-removed">5459     if (used_as_LU) {</span>
<span class="line-removed">5460       // Loop which searches the first difference character by character.</span>
<span class="line-removed">5461       Label Lloop;</span>
<span class="line-removed">5462       const Register ind1 = Z_R1,</span>
<span class="line-removed">5463                      ind2 = min;</span>
<span class="line-removed">5464       int stride1 = 1, stride2 = 2; // See comment above.</span>
<span class="line-removed">5465 </span>
<span class="line-removed">5466       // ind1: index, even_reg: index increment, odd_reg: index limit</span>
<span class="line-removed">5467       z_llilf(ind1, (unsigned int)(-stride1));</span>
<span class="line-removed">5468       z_lhi(even_reg, stride1);</span>
<span class="line-removed">5469       add2reg(odd_reg, -stride1, min);</span>
<span class="line-removed">5470       clear_reg(ind2); // kills min</span>
<span class="line-removed">5471 </span>
<span class="line-removed">5472       bind(Lloop);</span>
<span class="line-removed">5473       z_brxh(ind1, even_reg, Ldone);</span>
<span class="line-removed">5474       z_llc(tmp, Address(str1, ind1));</span>
<span class="line-removed">5475       z_llh(Z_R0, Address(str2, ind2));</span>
<span class="line-removed">5476       z_ahi(ind2, stride2);</span>
<span class="line-removed">5477       z_sr(tmp, Z_R0);</span>
<span class="line-removed">5478       z_bre(Lloop);</span>
<span class="line-removed">5479 </span>
<span class="line-removed">5480       z_lr(result, tmp);</span>
<span class="line-removed">5481 </span>
<span class="line-removed">5482     } else {</span>
<span class="line-removed">5483       // Use clcle in fast loop (only for same encoding).</span>
<span class="line-removed">5484       z_lgr(Z_R0, str1);</span>
<span class="line-removed">5485       z_lgr(even_reg, str2);</span>
<span class="line-removed">5486       z_llgfr(Z_R1, min);</span>
<span class="line-removed">5487       z_llgfr(odd_reg, min);</span>
<span class="line-removed">5488 </span>
<span class="line-removed">5489       if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed">5490         compare_long_ext(Z_R0, even_reg, 0);</span>
<span class="line-removed">5491       } else {</span>
<span class="line-removed">5492         compare_long_uni(Z_R0, even_reg, 0);</span>
<span class="line-removed">5493       }</span>
<span class="line-removed">5494       z_bre(Ldone);</span>
<span class="line-removed">5495       z_lgr(Z_R1, Z_R0);</span>
<span class="line-removed">5496       if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed">5497         z_llc(Z_R0, Address(even_reg));</span>
<span class="line-removed">5498         z_llc(result, Address(Z_R1));</span>
<span class="line-removed">5499       } else {</span>
<span class="line-removed">5500         z_llh(Z_R0, Address(even_reg));</span>
<span class="line-removed">5501         z_llh(result, Address(Z_R1));</span>
<span class="line-removed">5502       }</span>
<span class="line-removed">5503       z_sr(result, Z_R0);</span>
<span class="line-removed">5504     }</span>
<span class="line-removed">5505 </span>
<span class="line-removed">5506     // Otherwise, return the difference between the first mismatched chars.</span>
<span class="line-removed">5507     bind(Ldone);</span>
<span class="line-removed">5508   }</span>
<span class="line-removed">5509 </span>
<span class="line-removed">5510   if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">5511     z_lcr(result, result); // Negate result (see note above).</span>
<span class="line-removed">5512   }</span>
<span class="line-removed">5513 </span>
<span class="line-removed">5514   BLOCK_COMMENT(&quot;} string_compare&quot;);</span>
<span class="line-removed">5515 </span>
<span class="line-removed">5516   return offset() - block_start;</span>
<span class="line-removed">5517 }</span>
<span class="line-removed">5518 </span>
<span class="line-removed">5519 unsigned int MacroAssembler::array_equals(bool is_array_equ, Register ary1, Register ary2, Register limit,</span>
<span class="line-removed">5520                                           Register odd_reg, Register even_reg, Register result, bool is_byte) {</span>
<span class="line-removed">5521   int block_start = offset();</span>
<span class="line-removed">5522 </span>
<span class="line-removed">5523   BLOCK_COMMENT(&quot;array_equals {&quot;);</span>
<span class="line-removed">5524 </span>
<span class="line-removed">5525   assert_different_registers(ary1, limit, odd_reg, even_reg);</span>
<span class="line-removed">5526   assert_different_registers(ary2, limit, odd_reg, even_reg);</span>
<span class="line-removed">5527 </span>
<span class="line-removed">5528   Label Ldone, Ldone_true, Ldone_false, Lclcle, CLC_template;</span>
<span class="line-removed">5529   int base_offset = 0;</span>
<span class="line-removed">5530 </span>
<span class="line-removed">5531   if (ary1 != ary2) {</span>
<span class="line-removed">5532     if (is_array_equ) {</span>
<span class="line-removed">5533       base_offset = arrayOopDesc::base_offset_in_bytes(is_byte ? T_BYTE : T_CHAR);</span>
<span class="line-removed">5534 </span>
<span class="line-removed">5535       // Return true if the same array.</span>
<span class="line-removed">5536       compareU64_and_branch(ary1, ary2, Assembler::bcondEqual, Ldone_true);</span>
<span class="line-removed">5537 </span>
<span class="line-removed">5538       // Return false if one of them is NULL.</span>
<span class="line-removed">5539       compareU64_and_branch(ary1, (intptr_t)0, Assembler::bcondEqual, Ldone_false);</span>
<span class="line-removed">5540       compareU64_and_branch(ary2, (intptr_t)0, Assembler::bcondEqual, Ldone_false);</span>
<span class="line-removed">5541 </span>
<span class="line-removed">5542       // Load the lengths of arrays.</span>
<span class="line-removed">5543       z_llgf(odd_reg, Address(ary1, arrayOopDesc::length_offset_in_bytes()));</span>
<span class="line-removed">5544 </span>
<span class="line-removed">5545       // Return false if the two arrays are not equal length.</span>
<span class="line-removed">5546       z_c(odd_reg, Address(ary2, arrayOopDesc::length_offset_in_bytes()));</span>
<span class="line-removed">5547       z_brne(Ldone_false);</span>
<span class="line-removed">5548 </span>
<span class="line-removed">5549       // string len in bytes (right operand)</span>
<span class="line-removed">5550       if (!is_byte) {</span>
<span class="line-removed">5551         z_chi(odd_reg, 128);</span>
<span class="line-removed">5552         z_sll(odd_reg, 1); // preserves flags</span>
<span class="line-removed">5553         z_brh(Lclcle);</span>
<span class="line-removed">5554       } else {</span>
<span class="line-removed">5555         compareU32_and_branch(odd_reg, (intptr_t)256, Assembler::bcondHigh, Lclcle);</span>
<span class="line-removed">5556       }</span>
<span class="line-removed">5557     } else {</span>
<span class="line-removed">5558       z_llgfr(odd_reg, limit); // Need to zero-extend prior to using the value.</span>
<span class="line-removed">5559       compareU32_and_branch(limit, (intptr_t)256, Assembler::bcondHigh, Lclcle);</span>
<span class="line-removed">5560     }</span>
<span class="line-removed">5561 </span>
<span class="line-removed">5562 </span>
<span class="line-removed">5563     // Use clc instruction for up to 256 bytes.</span>
<span class="line-removed">5564     {</span>
<span class="line-removed">5565       Register str1_reg = ary1,</span>
<span class="line-removed">5566           str2_reg = ary2;</span>
<span class="line-removed">5567       if (is_array_equ) {</span>
<span class="line-removed">5568         str1_reg = Z_R1;</span>
<span class="line-removed">5569         str2_reg = even_reg;</span>
<span class="line-removed">5570         add2reg(str1_reg, base_offset, ary1); // string addr (left operand)</span>
<span class="line-removed">5571         add2reg(str2_reg, base_offset, ary2); // string addr (right operand)</span>
<span class="line-removed">5572       }</span>
<span class="line-removed">5573       z_ahi(odd_reg, -1); // Clc uses decremented limit. Also compare result to 0.</span>
<span class="line-removed">5574       z_brl(Ldone_true);</span>
<span class="line-removed">5575       // Note: We could jump to the template if equal.</span>
<span class="line-removed">5576 </span>
<span class="line-removed">5577       assert(VM_Version::has_ExecuteExtensions(), &quot;unsupported hardware&quot;);</span>
<span class="line-removed">5578       z_exrl(odd_reg, CLC_template);</span>
<span class="line-removed">5579       z_bre(Ldone_true);</span>
<span class="line-removed">5580       // fall through</span>
<span class="line-removed">5581 </span>
<span class="line-removed">5582       bind(Ldone_false);</span>
<span class="line-removed">5583       clear_reg(result);</span>
<span class="line-removed">5584       z_bru(Ldone);</span>
<span class="line-removed">5585 </span>
<span class="line-removed">5586       bind(CLC_template);</span>
<span class="line-removed">5587       z_clc(0, 0, str1_reg, 0, str2_reg);</span>
<span class="line-removed">5588     }</span>
<span class="line-removed">5589 </span>
<span class="line-removed">5590     // Use clcle instruction.</span>
<span class="line-removed">5591     {</span>
<span class="line-removed">5592       bind(Lclcle);</span>
<span class="line-removed">5593       add2reg(even_reg, base_offset, ary2); // string addr (right operand)</span>
<span class="line-removed">5594       add2reg(Z_R0, base_offset, ary1);     // string addr (left operand)</span>
<span class="line-removed">5595 </span>
<span class="line-removed">5596       z_lgr(Z_R1, odd_reg); // string len in bytes (left operand)</span>
<span class="line-removed">5597       if (is_byte) {</span>
<span class="line-removed">5598         compare_long_ext(Z_R0, even_reg, 0);</span>
<span class="line-removed">5599       } else {</span>
<span class="line-removed">5600         compare_long_uni(Z_R0, even_reg, 0);</span>
<span class="line-removed">5601       }</span>
<span class="line-removed">5602       z_lghi(result, 0); // Preserve flags.</span>
<span class="line-removed">5603       z_brne(Ldone);</span>
<span class="line-removed">5604     }</span>
<span class="line-removed">5605   }</span>
<span class="line-removed">5606   // fall through</span>
<span class="line-removed">5607 </span>
<span class="line-removed">5608   bind(Ldone_true);</span>
<span class="line-removed">5609   z_lghi(result, 1); // All characters are equal.</span>
<span class="line-removed">5610   bind(Ldone);</span>
<span class="line-removed">5611 </span>
<span class="line-removed">5612   BLOCK_COMMENT(&quot;} array_equals&quot;);</span>
<span class="line-removed">5613 </span>
<span class="line-removed">5614   return offset() - block_start;</span>
<span class="line-removed">5615 }</span>
<span class="line-removed">5616 </span>
<span class="line-removed">5617 // kill: haycnt, needlecnt, odd_reg, even_reg; early clobber: result</span>
<span class="line-removed">5618 unsigned int MacroAssembler::string_indexof(Register result, Register haystack, Register haycnt,</span>
<span class="line-removed">5619                                             Register needle, Register needlecnt, int needlecntval,</span>
<span class="line-removed">5620                                             Register odd_reg, Register even_reg, int ae) {</span>
<span class="line-removed">5621   int block_start = offset();</span>
<span class="line-removed">5622 </span>
<span class="line-removed">5623   // Ensure 0&lt;needlecnt&lt;=haycnt in ideal graph as prerequisite!</span>
<span class="line-removed">5624   assert(ae != StrIntrinsicNode::LU, &quot;Invalid encoding&quot;);</span>
<span class="line-removed">5625   const int h_csize = (ae == StrIntrinsicNode::LL) ? 1 : 2;</span>
<span class="line-removed">5626   const int n_csize = (ae == StrIntrinsicNode::UU) ? 2 : 1;</span>
<span class="line-removed">5627   Label L_needle1, L_Found, L_NotFound;</span>
<span class="line-removed">5628 </span>
<span class="line-removed">5629   BLOCK_COMMENT(&quot;string_indexof {&quot;);</span>
<span class="line-removed">5630 </span>
<span class="line-removed">5631   if (needle == haystack) {</span>
<span class="line-removed">5632     z_lhi(result, 0);</span>
<span class="line-removed">5633   } else {</span>
<span class="line-removed">5634 </span>
<span class="line-removed">5635   // Load first character of needle (R0 used by search_string instructions).</span>
<span class="line-removed">5636   if (n_csize == 2) { z_llgh(Z_R0, Address(needle)); } else { z_llgc(Z_R0, Address(needle)); }</span>
<span class="line-removed">5637 </span>
<span class="line-removed">5638   // Compute last haystack addr to use if no match gets found.</span>
<span class="line-removed">5639   if (needlecnt != noreg) { // variable needlecnt</span>
<span class="line-removed">5640     z_ahi(needlecnt, -1); // Remaining characters after first one.</span>
<span class="line-removed">5641     z_sr(haycnt, needlecnt); // Compute index succeeding last element to compare.</span>
<span class="line-removed">5642     if (n_csize == 2) { z_sll(needlecnt, 1); } // In bytes.</span>
<span class="line-removed">5643   } else { // constant needlecnt</span>
<span class="line-removed">5644     assert((needlecntval &amp; 0x7fff) == needlecntval, &quot;must be positive simm16 immediate&quot;);</span>
<span class="line-removed">5645     // Compute index succeeding last element to compare.</span>
<span class="line-removed">5646     if (needlecntval != 1) { z_ahi(haycnt, 1 - needlecntval); }</span>
<span class="line-removed">5647   }</span>
<span class="line-removed">5648 </span>
<span class="line-removed">5649   z_llgfr(haycnt, haycnt); // Clear high half.</span>
<span class="line-removed">5650   z_lgr(result, haystack); // Final result will be computed from needle start pointer.</span>
<span class="line-removed">5651   if (h_csize == 2) { z_sll(haycnt, 1); } // Scale to number of bytes.</span>
<span class="line-removed">5652   z_agr(haycnt, haystack); // Point to address succeeding last element (haystack+scale*(haycnt-needlecnt+1)).</span>
<span class="line-removed">5653 </span>
<span class="line-removed">5654   if (h_csize != n_csize) {</span>
<span class="line-removed">5655     assert(ae == StrIntrinsicNode::UL, &quot;Invalid encoding&quot;);</span>
<span class="line-removed">5656 </span>
<span class="line-removed">5657     if (needlecnt != noreg || needlecntval != 1) {</span>
<span class="line-removed">5658       if (needlecnt != noreg) {</span>
<span class="line-removed">5659         compare32_and_branch(needlecnt, (intptr_t)0, Assembler::bcondEqual, L_needle1);</span>
<span class="line-removed">5660       }</span>
<span class="line-removed">5661 </span>
<span class="line-removed">5662       // Main Loop: UL version (now we have at least 2 characters).</span>
<span class="line-removed">5663       Label L_OuterLoop, L_InnerLoop, L_Skip;</span>
<span class="line-removed">5664       bind(L_OuterLoop); // Search for 1st 2 characters.</span>
<span class="line-removed">5665       z_lgr(Z_R1, haycnt);</span>
<span class="line-removed">5666       MacroAssembler::search_string_uni(Z_R1, result);</span>
<span class="line-removed">5667       z_brc(Assembler::bcondNotFound, L_NotFound);</span>
<span class="line-removed">5668       z_lgr(result, Z_R1);</span>
<span class="line-removed">5669 </span>
<span class="line-removed">5670       z_lghi(Z_R1, n_csize);</span>
<span class="line-removed">5671       z_lghi(even_reg, h_csize);</span>
<span class="line-removed">5672       bind(L_InnerLoop);</span>
<span class="line-removed">5673       z_llgc(odd_reg, Address(needle, Z_R1));</span>
<span class="line-removed">5674       z_ch(odd_reg, Address(result, even_reg));</span>
<span class="line-removed">5675       z_brne(L_Skip);</span>
<span class="line-removed">5676       if (needlecnt != noreg) { z_cr(Z_R1, needlecnt); } else { z_chi(Z_R1, needlecntval - 1); }</span>
<span class="line-removed">5677       z_brnl(L_Found);</span>
<span class="line-removed">5678       z_aghi(Z_R1, n_csize);</span>
<span class="line-removed">5679       z_aghi(even_reg, h_csize);</span>
<span class="line-removed">5680       z_bru(L_InnerLoop);</span>
<span class="line-removed">5681 </span>
<span class="line-removed">5682       bind(L_Skip);</span>
<span class="line-removed">5683       z_aghi(result, h_csize); // This is the new address we want to use for comparing.</span>
<span class="line-removed">5684       z_bru(L_OuterLoop);</span>
<span class="line-removed">5685     }</span>
<span class="line-removed">5686 </span>
<span class="line-removed">5687   } else {</span>
<span class="line-removed">5688     const intptr_t needle_bytes = (n_csize == 2) ? ((needlecntval - 1) &lt;&lt; 1) : (needlecntval - 1);</span>
<span class="line-removed">5689     Label L_clcle;</span>
<span class="line-removed">5690 </span>
<span class="line-removed">5691     if (needlecnt != noreg || (needlecntval != 1 &amp;&amp; needle_bytes &lt;= 256)) {</span>
<span class="line-removed">5692       if (needlecnt != noreg) {</span>
<span class="line-removed">5693         compare32_and_branch(needlecnt, 256, Assembler::bcondHigh, L_clcle);</span>
<span class="line-removed">5694         z_ahi(needlecnt, -1); // remaining bytes -1 (for CLC)</span>
<span class="line-removed">5695         z_brl(L_needle1);</span>
<span class="line-removed">5696       }</span>
<span class="line-removed">5697 </span>
<span class="line-removed">5698       // Main Loop: clc version (now we have at least 2 characters).</span>
<span class="line-removed">5699       Label L_OuterLoop, CLC_template;</span>
<span class="line-removed">5700       bind(L_OuterLoop); // Search for 1st 2 characters.</span>
<span class="line-removed">5701       z_lgr(Z_R1, haycnt);</span>
<span class="line-removed">5702       if (h_csize == 1) {</span>
<span class="line-removed">5703         MacroAssembler::search_string(Z_R1, result);</span>
<span class="line-removed">5704       } else {</span>
<span class="line-removed">5705         MacroAssembler::search_string_uni(Z_R1, result);</span>
<span class="line-removed">5706       }</span>
<span class="line-removed">5707       z_brc(Assembler::bcondNotFound, L_NotFound);</span>
<span class="line-removed">5708       z_lgr(result, Z_R1);</span>
<span class="line-removed">5709 </span>
<span class="line-removed">5710       if (needlecnt != noreg) {</span>
<span class="line-removed">5711         assert(VM_Version::has_ExecuteExtensions(), &quot;unsupported hardware&quot;);</span>
<span class="line-removed">5712         z_exrl(needlecnt, CLC_template);</span>
<span class="line-removed">5713       } else {</span>
<span class="line-removed">5714         z_clc(h_csize, needle_bytes -1, Z_R1, n_csize, needle);</span>
<span class="line-removed">5715       }</span>
<span class="line-removed">5716       z_bre(L_Found);</span>
<span class="line-removed">5717       z_aghi(result, h_csize); // This is the new address we want to use for comparing.</span>
<span class="line-removed">5718       z_bru(L_OuterLoop);</span>
<span class="line-removed">5719 </span>
<span class="line-removed">5720       if (needlecnt != noreg) {</span>
<span class="line-removed">5721         bind(CLC_template);</span>
<span class="line-removed">5722         z_clc(h_csize, 0, Z_R1, n_csize, needle);</span>
<span class="line-removed">5723       }</span>
<span class="line-removed">5724     }</span>
<span class="line-removed">5725 </span>
<span class="line-removed">5726     if (needlecnt != noreg || needle_bytes &gt; 256) {</span>
<span class="line-removed">5727       bind(L_clcle);</span>
<span class="line-removed">5728 </span>
<span class="line-removed">5729       // Main Loop: clcle version (now we have at least 256 bytes).</span>
<span class="line-removed">5730       Label L_OuterLoop, CLC_template;</span>
<span class="line-removed">5731       bind(L_OuterLoop); // Search for 1st 2 characters.</span>
<span class="line-removed">5732       z_lgr(Z_R1, haycnt);</span>
<span class="line-removed">5733       if (h_csize == 1) {</span>
<span class="line-removed">5734         MacroAssembler::search_string(Z_R1, result);</span>
<span class="line-removed">5735       } else {</span>
<span class="line-removed">5736         MacroAssembler::search_string_uni(Z_R1, result);</span>
<span class="line-removed">5737       }</span>
<span class="line-removed">5738       z_brc(Assembler::bcondNotFound, L_NotFound);</span>
<span class="line-removed">5739 </span>
<span class="line-removed">5740       add2reg(Z_R0, n_csize, needle);</span>
<span class="line-removed">5741       add2reg(even_reg, h_csize, Z_R1);</span>
<span class="line-removed">5742       z_lgr(result, Z_R1);</span>
<span class="line-removed">5743       if (needlecnt != noreg) {</span>
<span class="line-removed">5744         z_llgfr(Z_R1, needlecnt); // needle len in bytes (left operand)</span>
<span class="line-removed">5745         z_llgfr(odd_reg, needlecnt);</span>
<span class="line-removed">5746       } else {</span>
<span class="line-removed">5747         load_const_optimized(Z_R1, needle_bytes);</span>
<span class="line-removed">5748         if (Immediate::is_simm16(needle_bytes)) { z_lghi(odd_reg, needle_bytes); } else { z_lgr(odd_reg, Z_R1); }</span>
<span class="line-removed">5749       }</span>
<span class="line-removed">5750       if (h_csize == 1) {</span>
<span class="line-removed">5751         compare_long_ext(Z_R0, even_reg, 0);</span>
<span class="line-removed">5752       } else {</span>
<span class="line-removed">5753         compare_long_uni(Z_R0, even_reg, 0);</span>
<span class="line-removed">5754       }</span>
<span class="line-removed">5755       z_bre(L_Found);</span>
<span class="line-removed">5756 </span>
<span class="line-removed">5757       if (n_csize == 2) { z_llgh(Z_R0, Address(needle)); } else { z_llgc(Z_R0, Address(needle)); } // Reload.</span>
<span class="line-removed">5758       z_aghi(result, h_csize); // This is the new address we want to use for comparing.</span>
<span class="line-removed">5759       z_bru(L_OuterLoop);</span>
<span class="line-removed">5760     }</span>
<span class="line-removed">5761   }</span>
<span class="line-removed">5762 </span>
<span class="line-removed">5763   if (needlecnt != noreg || needlecntval == 1) {</span>
<span class="line-removed">5764     bind(L_needle1);</span>
<span class="line-removed">5765 </span>
<span class="line-removed">5766     // Single needle character version.</span>
<span class="line-removed">5767     if (h_csize == 1) {</span>
<span class="line-removed">5768       MacroAssembler::search_string(haycnt, result);</span>
<span class="line-removed">5769     } else {</span>
<span class="line-removed">5770       MacroAssembler::search_string_uni(haycnt, result);</span>
<span class="line-removed">5771     }</span>
<span class="line-removed">5772     z_lgr(result, haycnt);</span>
<span class="line-removed">5773     z_brc(Assembler::bcondFound, L_Found);</span>
<span class="line-removed">5774   }</span>
<span class="line-removed">5775 </span>
<span class="line-removed">5776   bind(L_NotFound);</span>
<span class="line-removed">5777   add2reg(result, -1, haystack); // Return -1.</span>
<span class="line-removed">5778 </span>
<span class="line-removed">5779   bind(L_Found); // Return index (or -1 in fallthrough case).</span>
<span class="line-removed">5780   z_sgr(result, haystack);</span>
<span class="line-removed">5781   if (h_csize == 2) { z_srag(result, result, exact_log2(sizeof(jchar))); }</span>
<span class="line-removed">5782   }</span>
<span class="line-removed">5783   BLOCK_COMMENT(&quot;} string_indexof&quot;);</span>
<span class="line-removed">5784 </span>
<span class="line-removed">5785   return offset() - block_start;</span>
<span class="line-removed">5786 }</span>
<span class="line-removed">5787 </span>
<span class="line-removed">5788 // early clobber: result</span>
<span class="line-removed">5789 unsigned int MacroAssembler::string_indexof_char(Register result, Register haystack, Register haycnt,</span>
<span class="line-removed">5790                                                  Register needle, jchar needleChar, Register odd_reg, Register even_reg, bool is_byte) {</span>
<span class="line-removed">5791   int block_start = offset();</span>
<span class="line-removed">5792 </span>
<span class="line-removed">5793   BLOCK_COMMENT(&quot;string_indexof_char {&quot;);</span>
<span class="line-removed">5794 </span>
<span class="line-removed">5795   if (needle == haystack) {</span>
<span class="line-removed">5796     z_lhi(result, 0);</span>
<span class="line-removed">5797   } else {</span>
<span class="line-removed">5798 </span>
<span class="line-removed">5799   Label Ldone;</span>
<span class="line-removed">5800 </span>
<span class="line-removed">5801   z_llgfr(odd_reg, haycnt);  // Preset loop ctr/searchrange end.</span>
<span class="line-removed">5802   if (needle == noreg) {</span>
<span class="line-removed">5803     load_const_optimized(Z_R0, (unsigned long)needleChar);</span>
<span class="line-removed">5804   } else {</span>
<span class="line-removed">5805     if (is_byte) {</span>
<span class="line-removed">5806       z_llgcr(Z_R0, needle); // First (and only) needle char.</span>
<span class="line-removed">5807     } else {</span>
<span class="line-removed">5808       z_llghr(Z_R0, needle); // First (and only) needle char.</span>
<span class="line-removed">5809     }</span>
<span class="line-removed">5810   }</span>
<span class="line-removed">5811 </span>
<span class="line-removed">5812   if (!is_byte) {</span>
<span class="line-removed">5813     z_agr(odd_reg, odd_reg); // Calc #bytes to be processed with SRSTU.</span>
<span class="line-removed">5814   }</span>
<span class="line-removed">5815 </span>
<span class="line-removed">5816   z_lgr(even_reg, haystack); // haystack addr</span>
<span class="line-removed">5817   z_agr(odd_reg, haystack);  // First char after range end.</span>
<span class="line-removed">5818   z_lghi(result, -1);</span>
<span class="line-removed">5819 </span>
<span class="line-removed">5820   if (is_byte) {</span>
<span class="line-removed">5821     MacroAssembler::search_string(odd_reg, even_reg);</span>
<span class="line-removed">5822   } else {</span>
<span class="line-removed">5823     MacroAssembler::search_string_uni(odd_reg, even_reg);</span>
<span class="line-removed">5824   }</span>
<span class="line-removed">5825   z_brc(Assembler::bcondNotFound, Ldone);</span>
<span class="line-removed">5826   if (is_byte) {</span>
<span class="line-removed">5827     if (VM_Version::has_DistinctOpnds()) {</span>
<span class="line-removed">5828       z_sgrk(result, odd_reg, haystack);</span>
<span class="line-removed">5829     } else {</span>
<span class="line-removed">5830       z_sgr(odd_reg, haystack);</span>
<span class="line-removed">5831       z_lgr(result, odd_reg);</span>
<span class="line-removed">5832     }</span>
<span class="line-removed">5833   } else {</span>
<span class="line-removed">5834     z_slgr(odd_reg, haystack);</span>
<span class="line-removed">5835     z_srlg(result, odd_reg, exact_log2(sizeof(jchar)));</span>
<span class="line-removed">5836   }</span>
<span class="line-removed">5837 </span>
<span class="line-removed">5838   bind(Ldone);</span>
<span class="line-removed">5839   }</span>
<span class="line-removed">5840   BLOCK_COMMENT(&quot;} string_indexof_char&quot;);</span>
<span class="line-removed">5841 </span>
<span class="line-removed">5842   return offset() - block_start;</span>
<span class="line-removed">5843 }</span>
<span class="line-removed">5844 #endif</span>
<span class="line-removed">5845 </span>
5846 //-------------------------------------------------
5847 //   Constants (scalar and oop) in constant pool
5848 //-------------------------------------------------
5849 
5850 // Add a non-relocated constant to the CP.
5851 int MacroAssembler::store_const_in_toc(AddressLiteral&amp; val) {
5852   long    value  = val.value();
5853   address tocPos = long_constant(value);
5854 
5855   if (tocPos != NULL) {
5856     int tocOffset = (int)(tocPos - code()-&gt;consts()-&gt;start());
5857     return tocOffset;
5858   }
5859   // Address_constant returned NULL, so no constant entry has been created.
5860   // In that case, we return a &quot;fatal&quot; offset, just in case that subsequently
5861   // generated access code is executed.
5862   return -1;
5863 }
5864 
5865 // Returns the TOC offset where the address is stored.
5866 // Add a relocated constant to the CP.
5867 int MacroAssembler::store_oop_in_toc(AddressLiteral&amp; oop) {
5868   // Use RelocationHolder::none for the constant pool entry.
5869   // Otherwise we will end up with a failing NativeCall::verify(x),
5870   // where x is the address of the constant pool entry.
5871   address tocPos = address_constant((address)oop.value(), RelocationHolder::none);
5872 
5873   if (tocPos != NULL) {
5874     int              tocOffset = (int)(tocPos - code()-&gt;consts()-&gt;start());
5875     RelocationHolder rsp = oop.rspec();
5876     Relocation      *rel = rsp.reloc();
5877 
5878     // Store toc_offset in relocation, used by call_far_patchable.
5879     if ((relocInfo::relocType)rel-&gt;type() == relocInfo::runtime_call_w_cp_type) {
5880       ((runtime_call_w_cp_Relocation *)(rel))-&gt;set_constant_pool_offset(tocOffset);
5881     }
5882     // Relocate at the load&#39;s pc.
5883     relocate(rsp);
5884 
5885     return tocOffset;
5886   }
5887   // Address_constant returned NULL, so no constant entry has been created
5888   // in that case, we return a &quot;fatal&quot; offset, just in case that subsequently
5889   // generated access code is executed.
5890   return -1;
5891 }
5892 
5893 bool MacroAssembler::load_const_from_toc(Register dst, AddressLiteral&amp; a, Register Rtoc) {
5894   int     tocOffset = store_const_in_toc(a);
5895   if (tocOffset == -1) return false;
5896   address tocPos    = tocOffset + code()-&gt;consts()-&gt;start();
5897   assert((address)code()-&gt;consts()-&gt;start() != NULL, &quot;Please add CP address&quot;);
5898   relocate(a.rspec());
5899   load_long_pcrelative(dst, tocPos);
5900   return true;
5901 }
5902 
5903 bool MacroAssembler::load_oop_from_toc(Register dst, AddressLiteral&amp; a, Register Rtoc) {
5904   int     tocOffset = store_oop_in_toc(a);
5905   if (tocOffset == -1) return false;
5906   address tocPos    = tocOffset + code()-&gt;consts()-&gt;start();
5907   assert((address)code()-&gt;consts()-&gt;start() != NULL, &quot;Please add CP address&quot;);
5908 
5909   load_addr_pcrelative(dst, tocPos);
5910   return true;
5911 }
5912 
5913 // If the instruction sequence at the given pc is a load_const_from_toc
5914 // sequence, return the value currently stored at the referenced position
5915 // in the TOC.
5916 intptr_t MacroAssembler::get_const_from_toc(address pc) {
5917 
5918   assert(is_load_const_from_toc(pc), &quot;must be load_const_from_pool&quot;);
5919 
5920   long    offset  = get_load_const_from_toc_offset(pc);
5921   address dataLoc = NULL;
5922   if (is_load_const_from_toc_pcrelative(pc)) {
5923     dataLoc = pc + offset;
5924   } else {
5925     CodeBlob* cb = CodeCache::find_blob_unsafe(pc);   // Else we get assertion if nmethod is zombie.
5926     assert(cb &amp;&amp; cb-&gt;is_nmethod(), &quot;sanity&quot;);
5927     nmethod* nm = (nmethod*)cb;
5928     dataLoc = nm-&gt;ctable_begin() + offset;
5929   }
5930   return *(intptr_t *)dataLoc;
5931 }
5932 
5933 // If the instruction sequence at the given pc is a load_const_from_toc
5934 // sequence, copy the passed-in new_data value into the referenced
5935 // position in the TOC.
5936 void MacroAssembler::set_const_in_toc(address pc, unsigned long new_data, CodeBlob *cb) {
5937   assert(is_load_const_from_toc(pc), &quot;must be load_const_from_pool&quot;);
5938 
5939   long    offset = MacroAssembler::get_load_const_from_toc_offset(pc);
5940   address dataLoc = NULL;
5941   if (is_load_const_from_toc_pcrelative(pc)) {
5942     dataLoc = pc+offset;
5943   } else {
5944     nmethod* nm = CodeCache::find_nmethod(pc);
5945     assert((cb == NULL) || (nm == (nmethod*)cb), &quot;instruction address should be in CodeBlob&quot;);
5946     dataLoc = nm-&gt;ctable_begin() + offset;
5947   }
5948   if (*(unsigned long *)dataLoc != new_data) { // Prevent cache invalidation: update only if necessary.
5949     *(unsigned long *)dataLoc = new_data;
5950   }
5951 }
5952 
5953 // Dynamic TOC. Getter must only be called if &quot;a&quot; is a load_const_from_toc
5954 // site. Verify by calling is_load_const_from_toc() before!!
5955 // Offset is +/- 2**32 -&gt; use long.
5956 long MacroAssembler::get_load_const_from_toc_offset(address a) {
5957   assert(is_load_const_from_toc_pcrelative(a), &quot;expected pc relative load&quot;);
5958   //  expected code sequence:
5959   //    z_lgrl(t, simm32);    len = 6
5960   unsigned long inst;
5961   unsigned int  len = get_instruction(a, &amp;inst);
5962   return get_pcrel_offset(inst);
5963 }
5964 
5965 //**********************************************************************************
5966 //  inspection of generated instruction sequences for a particular pattern
5967 //**********************************************************************************
5968 
5969 bool MacroAssembler::is_load_const_from_toc_pcrelative(address a) {
5970 #ifdef ASSERT
5971   unsigned long inst;
5972   unsigned int  len = get_instruction(a+2, &amp;inst);
5973   if ((len == 6) &amp;&amp; is_load_pcrelative_long(a) &amp;&amp; is_call_pcrelative_long(inst)) {
5974     const int range = 128;
5975     Assembler::dump_code_range(tty, a, range, &quot;instr(a) == z_lgrl &amp;&amp; instr(a+2) == z_brasl&quot;);
5976     VM_Version::z_SIGSEGV();
5977   }
5978 #endif
5979   // expected code sequence:
5980   //   z_lgrl(t, relAddr32);    len = 6
5981   //TODO: verify accessed data is in CP, if possible.
5982   return is_load_pcrelative_long(a);  // TODO: might be too general. Currently, only lgrl is used.
5983 }
5984 
5985 bool MacroAssembler::is_load_const_from_toc_call(address a) {
5986   return is_load_const_from_toc(a) &amp;&amp; is_call_byregister(a + load_const_from_toc_size());
5987 }
5988 
5989 bool MacroAssembler::is_load_const_call(address a) {
5990   return is_load_const(a) &amp;&amp; is_call_byregister(a + load_const_size());
5991 }
5992 
5993 //-------------------------------------------------
5994 //   Emitters for some really CICS instructions
5995 //-------------------------------------------------
5996 
5997 void MacroAssembler::move_long_ext(Register dst, Register src, unsigned int pad) {
5998   assert(dst-&gt;encoding()%2==0, &quot;must be an even/odd register pair&quot;);
5999   assert(src-&gt;encoding()%2==0, &quot;must be an even/odd register pair&quot;);
6000   assert(pad&lt;256, &quot;must be a padding BYTE&quot;);
6001 
6002   Label retry;
6003   bind(retry);
6004   Assembler::z_mvcle(dst, src, pad);
6005   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6006 }
6007 
6008 void MacroAssembler::compare_long_ext(Register left, Register right, unsigned int pad) {
6009   assert(left-&gt;encoding() % 2 == 0, &quot;must be an even/odd register pair&quot;);
6010   assert(right-&gt;encoding() % 2 == 0, &quot;must be an even/odd register pair&quot;);
6011   assert(pad&lt;256, &quot;must be a padding BYTE&quot;);
6012 
6013   Label retry;
6014   bind(retry);
6015   Assembler::z_clcle(left, right, pad, Z_R0);
6016   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6017 }
6018 
6019 void MacroAssembler::compare_long_uni(Register left, Register right, unsigned int pad) {
6020   assert(left-&gt;encoding() % 2 == 0, &quot;must be an even/odd register pair&quot;);
6021   assert(right-&gt;encoding() % 2 == 0, &quot;must be an even/odd register pair&quot;);
6022   assert(pad&lt;=0xfff, &quot;must be a padding HALFWORD&quot;);
6023   assert(VM_Version::has_ETF2(), &quot;instruction must be available&quot;);
6024 
6025   Label retry;
6026   bind(retry);
6027   Assembler::z_clclu(left, right, pad, Z_R0);
6028   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6029 }
6030 
6031 void MacroAssembler::search_string(Register end, Register start) {
6032   assert(end-&gt;encoding() != 0, &quot;end address must not be in R0&quot;);
6033   assert(start-&gt;encoding() != 0, &quot;start address must not be in R0&quot;);
6034 
6035   Label retry;
6036   bind(retry);
6037   Assembler::z_srst(end, start);
6038   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6039 }
6040 
6041 void MacroAssembler::search_string_uni(Register end, Register start) {
6042   assert(end-&gt;encoding() != 0, &quot;end address must not be in R0&quot;);
6043   assert(start-&gt;encoding() != 0, &quot;start address must not be in R0&quot;);
6044   assert(VM_Version::has_ETF3(), &quot;instruction must be available&quot;);
6045 
6046   Label retry;
6047   bind(retry);
6048   Assembler::z_srstu(end, start);
6049   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6050 }
6051 
6052 void MacroAssembler::kmac(Register srcBuff) {
6053   assert(srcBuff-&gt;encoding()     != 0, &quot;src buffer address can&#39;t be in Z_R0&quot;);
6054   assert(srcBuff-&gt;encoding() % 2 == 0, &quot;src buffer/len must be an even/odd register pair&quot;);
6055 
6056   Label retry;
6057   bind(retry);
6058   Assembler::z_kmac(Z_R0, srcBuff);
6059   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6060 }
6061 
6062 void MacroAssembler::kimd(Register srcBuff) {
6063   assert(srcBuff-&gt;encoding()     != 0, &quot;src buffer address can&#39;t be in Z_R0&quot;);
6064   assert(srcBuff-&gt;encoding() % 2 == 0, &quot;src buffer/len must be an even/odd register pair&quot;);
6065 
6066   Label retry;
6067   bind(retry);
6068   Assembler::z_kimd(Z_R0, srcBuff);
6069   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6070 }
6071 
6072 void MacroAssembler::klmd(Register srcBuff) {
6073   assert(srcBuff-&gt;encoding()     != 0, &quot;src buffer address can&#39;t be in Z_R0&quot;);
6074   assert(srcBuff-&gt;encoding() % 2 == 0, &quot;src buffer/len must be an even/odd register pair&quot;);
6075 
6076   Label retry;
6077   bind(retry);
6078   Assembler::z_klmd(Z_R0, srcBuff);
6079   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6080 }
6081 
6082 void MacroAssembler::km(Register dstBuff, Register srcBuff) {
6083   // DstBuff and srcBuff are allowed to be the same register (encryption in-place).
6084   // DstBuff and srcBuff storage must not overlap destructively, and neither must overlap the parameter block.
6085   assert(srcBuff-&gt;encoding()     != 0, &quot;src buffer address can&#39;t be in Z_R0&quot;);
6086   assert(dstBuff-&gt;encoding() % 2 == 0, &quot;dst buffer addr must be an even register&quot;);
6087   assert(srcBuff-&gt;encoding() % 2 == 0, &quot;src buffer addr/len must be an even/odd register pair&quot;);
6088 
6089   Label retry;
6090   bind(retry);
6091   Assembler::z_km(dstBuff, srcBuff);
6092   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6093 }
6094 
6095 void MacroAssembler::kmc(Register dstBuff, Register srcBuff) {
6096   // DstBuff and srcBuff are allowed to be the same register (encryption in-place).
6097   // DstBuff and srcBuff storage must not overlap destructively, and neither must overlap the parameter block.
6098   assert(srcBuff-&gt;encoding()     != 0, &quot;src buffer address can&#39;t be in Z_R0&quot;);
6099   assert(dstBuff-&gt;encoding() % 2 == 0, &quot;dst buffer addr must be an even register&quot;);
6100   assert(srcBuff-&gt;encoding() % 2 == 0, &quot;src buffer addr/len must be an even/odd register pair&quot;);
6101 
6102   Label retry;
6103   bind(retry);
6104   Assembler::z_kmc(dstBuff, srcBuff);
6105   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6106 }
6107 
6108 void MacroAssembler::cksm(Register crcBuff, Register srcBuff) {
6109   assert(srcBuff-&gt;encoding() % 2 == 0, &quot;src buffer addr/len must be an even/odd register pair&quot;);
6110 
6111   Label retry;
6112   bind(retry);
6113   Assembler::z_cksm(crcBuff, srcBuff);
6114   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6115 }
6116 
6117 void MacroAssembler::translate_oo(Register r1, Register r2, uint m3) {
6118   assert(r1-&gt;encoding() % 2 == 0, &quot;dst addr/src len must be an even/odd register pair&quot;);
6119   assert((m3 &amp; 0b1110) == 0, &quot;Unused mask bits must be zero&quot;);
6120 
6121   Label retry;
6122   bind(retry);
6123   Assembler::z_troo(r1, r2, m3);
6124   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6125 }
6126 
6127 void MacroAssembler::translate_ot(Register r1, Register r2, uint m3) {
6128   assert(r1-&gt;encoding() % 2 == 0, &quot;dst addr/src len must be an even/odd register pair&quot;);
6129   assert((m3 &amp; 0b1110) == 0, &quot;Unused mask bits must be zero&quot;);
6130 
6131   Label retry;
6132   bind(retry);
6133   Assembler::z_trot(r1, r2, m3);
6134   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6135 }
6136 
6137 void MacroAssembler::translate_to(Register r1, Register r2, uint m3) {
6138   assert(r1-&gt;encoding() % 2 == 0, &quot;dst addr/src len must be an even/odd register pair&quot;);
6139   assert((m3 &amp; 0b1110) == 0, &quot;Unused mask bits must be zero&quot;);
6140 
6141   Label retry;
6142   bind(retry);
6143   Assembler::z_trto(r1, r2, m3);
6144   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6145 }
6146 
6147 void MacroAssembler::translate_tt(Register r1, Register r2, uint m3) {
6148   assert(r1-&gt;encoding() % 2 == 0, &quot;dst addr/src len must be an even/odd register pair&quot;);
6149   assert((m3 &amp; 0b1110) == 0, &quot;Unused mask bits must be zero&quot;);
6150 
6151   Label retry;
6152   bind(retry);
6153   Assembler::z_trtt(r1, r2, m3);
6154   Assembler::z_brc(Assembler::bcondOverflow /* CC==3 (iterate) */, retry);
6155 }
6156 
6157 //---------------------------------------
6158 // Helpers for Intrinsic Emitters
6159 //---------------------------------------
6160 
6161 /**
6162  * uint32_t crc;
6163  * timesXtoThe32[crc &amp; 0xFF] ^ (crc &gt;&gt; 8);
6164  */
6165 void MacroAssembler::fold_byte_crc32(Register crc, Register val, Register table, Register tmp) {
6166   assert_different_registers(crc, table, tmp);
6167   assert_different_registers(val, table);
6168   if (crc == val) {      // Must rotate first to use the unmodified value.
6169     rotate_then_insert(tmp, val, 56-2, 63-2, 2, true);  // Insert byte 7 of val, shifted left by 2, into byte 6..7 of tmp, clear the rest.
6170     z_srl(crc, 8);       // Unsigned shift, clear leftmost 8 bits.
6171   } else {
6172     z_srl(crc, 8);       // Unsigned shift, clear leftmost 8 bits.
6173     rotate_then_insert(tmp, val, 56-2, 63-2, 2, true);  // Insert byte 7 of val, shifted left by 2, into byte 6..7 of tmp, clear the rest.
6174   }
6175   z_x(crc, Address(table, tmp, 0));
6176 }
6177 
6178 /**
6179  * uint32_t crc;
6180  * timesXtoThe32[crc &amp; 0xFF] ^ (crc &gt;&gt; 8);
6181  */
6182 void MacroAssembler::fold_8bit_crc32(Register crc, Register table, Register tmp) {
6183   fold_byte_crc32(crc, crc, table, tmp);
6184 }
6185 
6186 /**
6187  * Emits code to update CRC-32 with a byte value according to constants in table.
6188  *
6189  * @param [in,out]crc Register containing the crc.
6190  * @param [in]val     Register containing the byte to fold into the CRC.
6191  * @param [in]table   Register containing the table of crc constants.
6192  *
6193  * uint32_t crc;
6194  * val = crc_table[(val ^ crc) &amp; 0xFF];
6195  * crc = val ^ (crc &gt;&gt; 8);
6196  */
6197 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
6198   z_xr(val, crc);
6199   fold_byte_crc32(crc, val, table, val);
6200 }
6201 
6202 
6203 /**
6204  * @param crc   register containing existing CRC (32-bit)
6205  * @param buf   register pointing to input byte buffer (byte*)
6206  * @param len   register containing number of bytes
6207  * @param table register pointing to CRC table
6208  */
6209 void MacroAssembler::update_byteLoop_crc32(Register crc, Register buf, Register len, Register table, Register data) {
6210   assert_different_registers(crc, buf, len, table, data);
6211 
6212   Label L_mainLoop, L_done;
6213   const int mainLoop_stepping = 1;
6214 
6215   // Process all bytes in a single-byte loop.
6216   z_ltr(len, len);
6217   z_brnh(L_done);
6218 
6219   bind(L_mainLoop);
6220     z_llgc(data, Address(buf, (intptr_t)0));// Current byte of input buffer (zero extended). Avoids garbage in upper half of register.
6221     add2reg(buf, mainLoop_stepping);        // Advance buffer position.
6222     update_byte_crc32(crc, data, table);
6223     z_brct(len, L_mainLoop);                // Iterate.
6224 
6225   bind(L_done);
6226 }
6227 
6228 /**
6229  * Emits code to update CRC-32 with a 4-byte value according to constants in table.
6230  * Implementation according to jdk/src/share/native/java/util/zip/zlib-1.2.8/crc32.c.
6231  *
6232  */
6233 void MacroAssembler::update_1word_crc32(Register crc, Register buf, Register table, int bufDisp, int bufInc,
6234                                         Register t0,  Register t1,  Register t2,    Register t3) {
6235   // This is what we implement (the DOBIG4 part):
6236   //
6237   // #define DOBIG4 c ^= *++buf4; \
6238   //         c = crc_table[4][c &amp; 0xff] ^ crc_table[5][(c &gt;&gt; 8) &amp; 0xff] ^ \
6239   //             crc_table[6][(c &gt;&gt; 16) &amp; 0xff] ^ crc_table[7][c &gt;&gt; 24]
6240   // #define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4
6241   // Pre-calculate (constant) column offsets, use columns 4..7 for big-endian.
6242   const int ix0 = 4*(4*CRC32_COLUMN_SIZE);
6243   const int ix1 = 5*(4*CRC32_COLUMN_SIZE);
6244   const int ix2 = 6*(4*CRC32_COLUMN_SIZE);
6245   const int ix3 = 7*(4*CRC32_COLUMN_SIZE);
6246 
6247   // XOR crc with next four bytes of buffer.
6248   lgr_if_needed(t0, crc);
6249   z_x(t0, Address(buf, bufDisp));
6250   if (bufInc != 0) {
6251     add2reg(buf, bufInc);
6252   }
6253 
6254   // Chop crc into 4 single-byte pieces, shifted left 2 bits, to form the table indices.
6255   rotate_then_insert(t3, t0, 56-2, 63-2, 2,    true);  // ((c &gt;&gt;  0) &amp; 0xff) &lt;&lt; 2
6256   rotate_then_insert(t2, t0, 56-2, 63-2, 2-8,  true);  // ((c &gt;&gt;  8) &amp; 0xff) &lt;&lt; 2
6257   rotate_then_insert(t1, t0, 56-2, 63-2, 2-16, true);  // ((c &gt;&gt; 16) &amp; 0xff) &lt;&lt; 2
6258   rotate_then_insert(t0, t0, 56-2, 63-2, 2-24, true);  // ((c &gt;&gt; 24) &amp; 0xff) &lt;&lt; 2
6259 
6260   // XOR indexed table values to calculate updated crc.
6261   z_ly(t2, Address(table, t2, (intptr_t)ix1));
6262   z_ly(t0, Address(table, t0, (intptr_t)ix3));
6263   z_xy(t2, Address(table, t3, (intptr_t)ix0));
6264   z_xy(t0, Address(table, t1, (intptr_t)ix2));
6265   z_xr(t0, t2);           // Now t0 contains the updated CRC value.
6266   lgr_if_needed(crc, t0);
6267 }
6268 
6269 /**
6270  * @param crc   register containing existing CRC (32-bit)
6271  * @param buf   register pointing to input byte buffer (byte*)
6272  * @param len   register containing number of bytes
6273  * @param table register pointing to CRC table
6274  *
6275  * uses Z_R10..Z_R13 as work register. Must be saved/restored by caller!
6276  */
6277 void MacroAssembler::kernel_crc32_1word(Register crc, Register buf, Register len, Register table,
6278                                         Register t0,  Register t1,  Register t2,  Register t3,
6279                                         bool invertCRC) {
6280   assert_different_registers(crc, buf, len, table);
6281 
6282   Label L_mainLoop, L_tail;
6283   Register  data = t0;
6284   Register  ctr  = Z_R0;
6285   const int mainLoop_stepping = 4;
6286   const int log_stepping      = exact_log2(mainLoop_stepping);
6287 
6288   // Don&#39;t test for len &lt;= 0 here. This pathological case should not occur anyway.
6289   // Optimizing for it by adding a test and a branch seems to be a waste of CPU cycles.
6290   // The situation itself is detected and handled correctly by the conditional branches
6291   // following aghi(len, -stepping) and aghi(len, +stepping).
6292 
6293   if (invertCRC) {
6294     not_(crc, noreg, false);           // 1s complement of crc
6295   }
6296 
6297   // Check for short (&lt;4 bytes) buffer.
6298   z_srag(ctr, len, log_stepping);
6299   z_brnh(L_tail);
6300 
6301   z_lrvr(crc, crc);          // Revert byte order because we are dealing with big-endian data.
6302   rotate_then_insert(len, len, 64-log_stepping, 63, 0, true); // #bytes for tailLoop
6303 
6304   BIND(L_mainLoop);
6305     update_1word_crc32(crc, buf, table, 0, mainLoop_stepping, crc, t1, t2, t3);
6306     z_brct(ctr, L_mainLoop); // Iterate.
6307 
6308   z_lrvr(crc, crc);          // Revert byte order back to original.
6309 
6310   // Process last few (&lt;8) bytes of buffer.
6311   BIND(L_tail);
6312   update_byteLoop_crc32(crc, buf, len, table, data);
6313 
6314   if (invertCRC) {
6315     not_(crc, noreg, false);           // 1s complement of crc
6316   }
6317 }
6318 
6319 /**
6320  * @param crc   register containing existing CRC (32-bit)
6321  * @param buf   register pointing to input byte buffer (byte*)
6322  * @param len   register containing number of bytes
6323  * @param table register pointing to CRC table
6324  */
6325 void MacroAssembler::kernel_crc32_1byte(Register crc, Register buf, Register len, Register table,
6326                                         Register t0,  Register t1,  Register t2,  Register t3,
6327                                         bool invertCRC) {
6328   assert_different_registers(crc, buf, len, table);
6329   Register data = t0;
6330 
6331   if (invertCRC) {
6332     not_(crc, noreg, false);           // 1s complement of crc
6333   }
6334 
6335   update_byteLoop_crc32(crc, buf, len, table, data);
6336 
6337   if (invertCRC) {
6338     not_(crc, noreg, false);           // 1s complement of crc
6339   }
6340 }
6341 
6342 void MacroAssembler::kernel_crc32_singleByte(Register crc, Register buf, Register len, Register table, Register tmp,
6343                                              bool invertCRC) {
6344   assert_different_registers(crc, buf, len, table, tmp);
6345 
6346   if (invertCRC) {
6347     not_(crc, noreg, false);           // 1s complement of crc
6348   }
6349 
6350   z_llgc(tmp, Address(buf, (intptr_t)0));  // Current byte of input buffer (zero extended). Avoids garbage in upper half of register.
6351   update_byte_crc32(crc, tmp, table);
6352 
6353   if (invertCRC) {
6354     not_(crc, noreg, false);           // 1s complement of crc
6355   }
6356 }
6357 
6358 void MacroAssembler::kernel_crc32_singleByteReg(Register crc, Register val, Register table,
6359                                                 bool invertCRC) {
6360   assert_different_registers(crc, val, table);
6361 
6362   if (invertCRC) {
6363     not_(crc, noreg, false);           // 1s complement of crc
6364   }
6365 
6366   update_byte_crc32(crc, val, table);
6367 
6368   if (invertCRC) {
6369     not_(crc, noreg, false);           // 1s complement of crc
6370   }
6371 }
6372 
6373 //
6374 // Code for BigInteger::multiplyToLen() intrinsic.
6375 //
6376 
6377 // dest_lo += src1 + src2
6378 // dest_hi += carry1 + carry2
6379 // Z_R7 is destroyed !
6380 void MacroAssembler::add2_with_carry(Register dest_hi, Register dest_lo,
6381                                      Register src1, Register src2) {
6382   clear_reg(Z_R7);
6383   z_algr(dest_lo, src1);
6384   z_alcgr(dest_hi, Z_R7);
6385   z_algr(dest_lo, src2);
6386   z_alcgr(dest_hi, Z_R7);
6387 }
6388 
6389 // Multiply 64 bit by 64 bit first loop.
6390 void MacroAssembler::multiply_64_x_64_loop(Register x, Register xstart,
6391                                            Register x_xstart,
6392                                            Register y, Register y_idx,
6393                                            Register z,
6394                                            Register carry,
6395                                            Register product,
6396                                            Register idx, Register kdx) {
6397   // jlong carry, x[], y[], z[];
6398   // for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx--, kdx--) {
6399   //   huge_128 product = y[idx] * x[xstart] + carry;
6400   //   z[kdx] = (jlong)product;
6401   //   carry  = (jlong)(product &gt;&gt;&gt; 64);
6402   // }
6403   // z[xstart] = carry;
6404 
6405   Label L_first_loop, L_first_loop_exit;
6406   Label L_one_x, L_one_y, L_multiply;
6407 
6408   z_aghi(xstart, -1);
6409   z_brl(L_one_x);   // Special case: length of x is 1.
6410 
6411   // Load next two integers of x.
6412   z_sllg(Z_R1_scratch, xstart, LogBytesPerInt);
6413   mem2reg_opt(x_xstart, Address(x, Z_R1_scratch, 0));
6414 
6415 
6416   bind(L_first_loop);
6417 
6418   z_aghi(idx, -1);
6419   z_brl(L_first_loop_exit);
6420   z_aghi(idx, -1);
6421   z_brl(L_one_y);
6422 
6423   // Load next two integers of y.
6424   z_sllg(Z_R1_scratch, idx, LogBytesPerInt);
6425   mem2reg_opt(y_idx, Address(y, Z_R1_scratch, 0));
6426 
6427 
6428   bind(L_multiply);
6429 
6430   Register multiplicand = product-&gt;successor();
6431   Register product_low = multiplicand;
6432 
6433   lgr_if_needed(multiplicand, x_xstart);
6434   z_mlgr(product, y_idx);     // multiplicand * y_idx -&gt; product::multiplicand
6435   clear_reg(Z_R7);
6436   z_algr(product_low, carry); // Add carry to result.
6437   z_alcgr(product, Z_R7);     // Add carry of the last addition.
6438   add2reg(kdx, -2);
6439 
6440   // Store result.
6441   z_sllg(Z_R7, kdx, LogBytesPerInt);
6442   reg2mem_opt(product_low, Address(z, Z_R7, 0));
6443   lgr_if_needed(carry, product);
6444   z_bru(L_first_loop);
6445 
6446 
6447   bind(L_one_y); // Load one 32 bit portion of y as (0,value).
6448 
6449   clear_reg(y_idx);
6450   mem2reg_opt(y_idx, Address(y, (intptr_t) 0), false);
6451   z_bru(L_multiply);
6452 
6453 
6454   bind(L_one_x); // Load one 32 bit portion of x as (0,value).
6455 
6456   clear_reg(x_xstart);
6457   mem2reg_opt(x_xstart, Address(x, (intptr_t) 0), false);
6458   z_bru(L_first_loop);
6459 
6460   bind(L_first_loop_exit);
6461 }
6462 
6463 // Multiply 64 bit by 64 bit and add 128 bit.
6464 void MacroAssembler::multiply_add_128_x_128(Register x_xstart, Register y,
6465                                             Register z,
6466                                             Register yz_idx, Register idx,
6467                                             Register carry, Register product,
6468                                             int offset) {
6469   // huge_128 product = (y[idx] * x_xstart) + z[kdx] + carry;
6470   // z[kdx] = (jlong)product;
6471 
6472   Register multiplicand = product-&gt;successor();
6473   Register product_low = multiplicand;
6474 
6475   z_sllg(Z_R7, idx, LogBytesPerInt);
6476   mem2reg_opt(yz_idx, Address(y, Z_R7, offset));
6477 
6478   lgr_if_needed(multiplicand, x_xstart);
6479   z_mlgr(product, yz_idx); // multiplicand * yz_idx -&gt; product::multiplicand
6480   mem2reg_opt(yz_idx, Address(z, Z_R7, offset));
6481 
6482   add2_with_carry(product, product_low, carry, yz_idx);
6483 
6484   z_sllg(Z_R7, idx, LogBytesPerInt);
6485   reg2mem_opt(product_low, Address(z, Z_R7, offset));
6486 
6487 }
6488 
6489 // Multiply 128 bit by 128 bit. Unrolled inner loop.
6490 void MacroAssembler::multiply_128_x_128_loop(Register x_xstart,
6491                                              Register y, Register z,
6492                                              Register yz_idx, Register idx,
6493                                              Register jdx,
6494                                              Register carry, Register product,
6495                                              Register carry2) {
6496   // jlong carry, x[], y[], z[];
6497   // int kdx = ystart+1;
6498   // for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
6499   //   huge_128 product = (y[idx+1] * x_xstart) + z[kdx+idx+1] + carry;
6500   //   z[kdx+idx+1] = (jlong)product;
6501   //   jlong carry2 = (jlong)(product &gt;&gt;&gt; 64);
6502   //   product = (y[idx] * x_xstart) + z[kdx+idx] + carry2;
6503   //   z[kdx+idx] = (jlong)product;
6504   //   carry = (jlong)(product &gt;&gt;&gt; 64);
6505   // }
6506   // idx += 2;
6507   // if (idx &gt; 0) {
6508   //   product = (y[idx] * x_xstart) + z[kdx+idx] + carry;
6509   //   z[kdx+idx] = (jlong)product;
6510   //   carry = (jlong)(product &gt;&gt;&gt; 64);
6511   // }
6512 
6513   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
6514 
6515   // scale the index
6516   lgr_if_needed(jdx, idx);
6517   and_imm(jdx, 0xfffffffffffffffcL);
6518   rshift(jdx, 2);
6519 
6520 
6521   bind(L_third_loop);
6522 
6523   z_aghi(jdx, -1);
6524   z_brl(L_third_loop_exit);
6525   add2reg(idx, -4);
6526 
6527   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 8);
6528   lgr_if_needed(carry2, product);
6529 
6530   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry2, product, 0);
6531   lgr_if_needed(carry, product);
6532   z_bru(L_third_loop);
6533 
6534 
6535   bind(L_third_loop_exit);  // Handle any left-over operand parts.
6536 
6537   and_imm(idx, 0x3);
6538   z_brz(L_post_third_loop_done);
6539 
6540   Label L_check_1;
6541 
6542   z_aghi(idx, -2);
6543   z_brl(L_check_1);
6544 
6545   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 0);
6546   lgr_if_needed(carry, product);
6547 
6548 
6549   bind(L_check_1);
6550 
6551   add2reg(idx, 0x2);
6552   and_imm(idx, 0x1);
6553   z_aghi(idx, -1);
6554   z_brl(L_post_third_loop_done);
6555 
6556   Register   multiplicand = product-&gt;successor();
6557   Register   product_low = multiplicand;
6558 
6559   z_sllg(Z_R7, idx, LogBytesPerInt);
6560   clear_reg(yz_idx);
6561   mem2reg_opt(yz_idx, Address(y, Z_R7, 0), false);
6562   lgr_if_needed(multiplicand, x_xstart);
6563   z_mlgr(product, yz_idx); // multiplicand * yz_idx -&gt; product::multiplicand
6564   clear_reg(yz_idx);
6565   mem2reg_opt(yz_idx, Address(z, Z_R7, 0), false);
6566 
6567   add2_with_carry(product, product_low, yz_idx, carry);
6568 
6569   z_sllg(Z_R7, idx, LogBytesPerInt);
6570   reg2mem_opt(product_low, Address(z, Z_R7, 0), false);
6571   rshift(product_low, 32);
6572 
6573   lshift(product, 32);
6574   z_ogr(product_low, product);
6575   lgr_if_needed(carry, product_low);
6576 
6577   bind(L_post_third_loop_done);
6578 }
6579 
6580 void MacroAssembler::multiply_to_len(Register x, Register xlen,
6581                                      Register y, Register ylen,
6582                                      Register z,
6583                                      Register tmp1, Register tmp2,
6584                                      Register tmp3, Register tmp4,
6585                                      Register tmp5) {
6586   ShortBranchVerifier sbv(this);
6587 
6588   assert_different_registers(x, xlen, y, ylen, z,
6589                              tmp1, tmp2, tmp3, tmp4, tmp5, Z_R1_scratch, Z_R7);
6590   assert_different_registers(x, xlen, y, ylen, z,
6591                              tmp1, tmp2, tmp3, tmp4, tmp5, Z_R8);
6592 
6593   z_stmg(Z_R7, Z_R13, _z_abi(gpr7), Z_SP);
6594 
6595   // In openJdk, we store the argument as 32-bit value to slot.
6596   Address zlen(Z_SP, _z_abi(remaining_cargs));  // Int in long on big endian.
6597 
6598   const Register idx = tmp1;
6599   const Register kdx = tmp2;
6600   const Register xstart = tmp3;
6601 
6602   const Register y_idx = tmp4;
6603   const Register carry = tmp5;
6604   const Register product  = Z_R0_scratch;
6605   const Register x_xstart = Z_R8;
6606 
6607   // First Loop.
6608   //
6609   //   final static long LONG_MASK = 0xffffffffL;
6610   //   int xstart = xlen - 1;
6611   //   int ystart = ylen - 1;
6612   //   long carry = 0;
6613   //   for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
6614   //     long product = (y[idx] &amp; LONG_MASK) * (x[xstart] &amp; LONG_MASK) + carry;
6615   //     z[kdx] = (int)product;
6616   //     carry = product &gt;&gt;&gt; 32;
6617   //   }
6618   //   z[xstart] = (int)carry;
6619   //
6620 
6621   lgr_if_needed(idx, ylen);  // idx = ylen
6622   z_llgf(kdx, zlen);         // C2 does not respect int to long conversion for stub calls, thus load zero-extended.
6623   clear_reg(carry);          // carry = 0
6624 
6625   Label L_done;
6626 
6627   lgr_if_needed(xstart, xlen);
6628   z_aghi(xstart, -1);
6629   z_brl(L_done);
6630 
6631   multiply_64_x_64_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);
6632 
6633   NearLabel L_second_loop;
6634   compare64_and_branch(kdx, RegisterOrConstant((intptr_t) 0), bcondEqual, L_second_loop);
6635 
6636   NearLabel L_carry;
6637   z_aghi(kdx, -1);
6638   z_brz(L_carry);
6639 
6640   // Store lower 32 bits of carry.
6641   z_sllg(Z_R1_scratch, kdx, LogBytesPerInt);
6642   reg2mem_opt(carry, Address(z, Z_R1_scratch, 0), false);
6643   rshift(carry, 32);
6644   z_aghi(kdx, -1);
6645 
6646 
6647   bind(L_carry);
6648 
6649   // Store upper 32 bits of carry.
6650   z_sllg(Z_R1_scratch, kdx, LogBytesPerInt);
6651   reg2mem_opt(carry, Address(z, Z_R1_scratch, 0), false);
6652 
6653   // Second and third (nested) loops.
6654   //
6655   // for (int i = xstart-1; i &gt;= 0; i--) { // Second loop
6656   //   carry = 0;
6657   //   for (int jdx=ystart, k=ystart+1+i; jdx &gt;= 0; jdx--, k--) { // Third loop
6658   //     long product = (y[jdx] &amp; LONG_MASK) * (x[i] &amp; LONG_MASK) +
6659   //                    (z[k] &amp; LONG_MASK) + carry;
6660   //     z[k] = (int)product;
6661   //     carry = product &gt;&gt;&gt; 32;
6662   //   }
6663   //   z[i] = (int)carry;
6664   // }
6665   //
6666   // i = xlen, j = tmp1, k = tmp2, carry = tmp5, x[i] = rdx
6667 
6668   const Register jdx = tmp1;
6669 
6670   bind(L_second_loop);
6671 
6672   clear_reg(carry);           // carry = 0;
6673   lgr_if_needed(jdx, ylen);   // j = ystart+1
6674 
6675   z_aghi(xstart, -1);         // i = xstart-1;
6676   z_brl(L_done);
6677 
6678   // Use free slots in the current stackframe instead of push/pop.
6679   Address zsave(Z_SP, _z_abi(carg_1));
6680   reg2mem_opt(z, zsave);
6681 
6682 
6683   Label L_last_x;
6684 
6685   z_sllg(Z_R1_scratch, xstart, LogBytesPerInt);
6686   load_address(z, Address(z, Z_R1_scratch, 4)); // z = z + k - j
6687   z_aghi(xstart, -1);                           // i = xstart-1;
6688   z_brl(L_last_x);
6689 
6690   z_sllg(Z_R1_scratch, xstart, LogBytesPerInt);
6691   mem2reg_opt(x_xstart, Address(x, Z_R1_scratch, 0));
6692 
6693 
6694   Label L_third_loop_prologue;
6695 
6696   bind(L_third_loop_prologue);
6697 
6698   Address xsave(Z_SP, _z_abi(carg_2));
6699   Address xlensave(Z_SP, _z_abi(carg_3));
6700   Address ylensave(Z_SP, _z_abi(carg_4));
6701 
6702   reg2mem_opt(x, xsave);
6703   reg2mem_opt(xstart, xlensave);
6704   reg2mem_opt(ylen, ylensave);
6705 
6706 
6707   multiply_128_x_128_loop(x_xstart, y, z, y_idx, jdx, ylen, carry, product, x);
6708 
6709   mem2reg_opt(z, zsave);
6710   mem2reg_opt(x, xsave);
6711   mem2reg_opt(xlen, xlensave);   // This is the decrement of the loop counter!
6712   mem2reg_opt(ylen, ylensave);
6713 
6714   add2reg(tmp3, 1, xlen);
6715   z_sllg(Z_R1_scratch, tmp3, LogBytesPerInt);
6716   reg2mem_opt(carry, Address(z, Z_R1_scratch, 0), false);
6717   z_aghi(tmp3, -1);
6718   z_brl(L_done);
6719 
6720   rshift(carry, 32);
6721   z_sllg(Z_R1_scratch, tmp3, LogBytesPerInt);
6722   reg2mem_opt(carry, Address(z, Z_R1_scratch, 0), false);
6723   z_bru(L_second_loop);
6724 
6725   // Next infrequent code is moved outside loops.
6726   bind(L_last_x);
6727 
6728   clear_reg(x_xstart);
6729   mem2reg_opt(x_xstart, Address(x, (intptr_t) 0), false);
6730   z_bru(L_third_loop_prologue);
6731 
6732   bind(L_done);
6733 
6734   z_lmg(Z_R7, Z_R13, _z_abi(gpr7), Z_SP);
6735 }
6736 
6737 #ifndef PRODUCT
6738 // Assert if CC indicates &quot;not equal&quot; (check_equal==true) or &quot;equal&quot; (check_equal==false).
6739 void MacroAssembler::asm_assert(bool check_equal, const char *msg, int id) {
6740   Label ok;
6741   if (check_equal) {
6742     z_bre(ok);
6743   } else {
6744     z_brne(ok);
6745   }
6746   stop(msg, id);
6747   bind(ok);
6748 }
6749 
6750 // Assert if CC indicates &quot;low&quot;.
6751 void MacroAssembler::asm_assert_low(const char *msg, int id) {
6752   Label ok;
6753   z_brnl(ok);
6754   stop(msg, id);
6755   bind(ok);
6756 }
6757 
6758 // Assert if CC indicates &quot;high&quot;.
6759 void MacroAssembler::asm_assert_high(const char *msg, int id) {
6760   Label ok;
6761   z_brnh(ok);
6762   stop(msg, id);
6763   bind(ok);
6764 }
6765 
6766 // Assert if CC indicates &quot;not equal&quot; (check_equal==true) or &quot;equal&quot; (check_equal==false)
6767 // generate non-relocatable code.
6768 void MacroAssembler::asm_assert_static(bool check_equal, const char *msg, int id) {
6769   Label ok;
6770   if (check_equal) { z_bre(ok); }
6771   else             { z_brne(ok); }
6772   stop_static(msg, id);
6773   bind(ok);
6774 }
6775 
6776 void MacroAssembler::asm_assert_mems_zero(bool check_equal, bool allow_relocation, int size, int64_t mem_offset,
6777                                           Register mem_base, const char* msg, int id) {
6778   switch (size) {
6779     case 4:
6780       load_and_test_int(Z_R0, Address(mem_base, mem_offset));
6781       break;
6782     case 8:
6783       load_and_test_long(Z_R0,  Address(mem_base, mem_offset));
6784       break;
6785     default:
6786       ShouldNotReachHere();
6787   }
6788   if (allow_relocation) { asm_assert(check_equal, msg, id); }
6789   else                  { asm_assert_static(check_equal, msg, id); }
6790 }
6791 
6792 // Check the condition
6793 //   expected_size == FP - SP
6794 // after transformation:
6795 //   expected_size - FP + SP == 0
6796 // Destroys Register expected_size if no tmp register is passed.
6797 void MacroAssembler::asm_assert_frame_size(Register expected_size, Register tmp, const char* msg, int id) {
6798   if (tmp == noreg) {
6799     tmp = expected_size;
6800   } else {
6801     if (tmp != expected_size) {
6802       z_lgr(tmp, expected_size);
6803     }
6804     z_algr(tmp, Z_SP);
6805     z_slg(tmp, 0, Z_R0, Z_SP);
6806     asm_assert_eq(msg, id);
6807   }
6808 }
6809 #endif // !PRODUCT
6810 
6811 void MacroAssembler::verify_thread() {
6812   if (VerifyThread) {
6813     unimplemented(&quot;&quot;, 117);
6814   }
6815 }
6816 
6817 // Save and restore functions: Exclude Z_R0.
6818 void MacroAssembler::save_volatile_regs(Register dst, int offset, bool include_fp, bool include_flags) {
6819   z_stmg(Z_R1, Z_R5, offset, dst); offset += 5 * BytesPerWord;
6820   if (include_fp) {
6821     z_std(Z_F0, Address(dst, offset)); offset += BytesPerWord;
6822     z_std(Z_F1, Address(dst, offset)); offset += BytesPerWord;
6823     z_std(Z_F2, Address(dst, offset)); offset += BytesPerWord;
6824     z_std(Z_F3, Address(dst, offset)); offset += BytesPerWord;
6825     z_std(Z_F4, Address(dst, offset)); offset += BytesPerWord;
6826     z_std(Z_F5, Address(dst, offset)); offset += BytesPerWord;
6827     z_std(Z_F6, Address(dst, offset)); offset += BytesPerWord;
6828     z_std(Z_F7, Address(dst, offset)); offset += BytesPerWord;
6829   }
6830   if (include_flags) {
6831     Label done;
6832     z_mvi(Address(dst, offset), 2); // encoding: equal
6833     z_bre(done);
6834     z_mvi(Address(dst, offset), 4); // encoding: higher
6835     z_brh(done);
6836     z_mvi(Address(dst, offset), 1); // encoding: lower
6837     bind(done);
6838   }
6839 }
6840 void MacroAssembler::restore_volatile_regs(Register src, int offset, bool include_fp, bool include_flags) {
6841   z_lmg(Z_R1, Z_R5, offset, src); offset += 5 * BytesPerWord;
6842   if (include_fp) {
6843     z_ld(Z_F0, Address(src, offset)); offset += BytesPerWord;
6844     z_ld(Z_F1, Address(src, offset)); offset += BytesPerWord;
6845     z_ld(Z_F2, Address(src, offset)); offset += BytesPerWord;
6846     z_ld(Z_F3, Address(src, offset)); offset += BytesPerWord;
6847     z_ld(Z_F4, Address(src, offset)); offset += BytesPerWord;
6848     z_ld(Z_F5, Address(src, offset)); offset += BytesPerWord;
6849     z_ld(Z_F6, Address(src, offset)); offset += BytesPerWord;
6850     z_ld(Z_F7, Address(src, offset)); offset += BytesPerWord;
6851   }
6852   if (include_flags) {
6853     z_cli(Address(src, offset), 2); // see encoding above
6854   }
6855 }
6856 
6857 // Plausibility check for oops.
6858 void MacroAssembler::verify_oop(Register oop, const char* msg) {
6859   if (!VerifyOops) return;
6860 
6861   BLOCK_COMMENT(&quot;verify_oop {&quot;);
6862   unsigned int nbytes_save = (5 + 8 + 1) * BytesPerWord;
6863   address entry_addr = StubRoutines::verify_oop_subroutine_entry_address();
6864 
6865   save_return_pc();
6866 
6867   // Push frame, but preserve flags
6868   z_lgr(Z_R0, Z_SP);
6869   z_lay(Z_SP, -((int64_t)nbytes_save + frame::z_abi_160_size), Z_SP);
6870   z_stg(Z_R0, _z_abi(callers_sp), Z_SP);
6871 
6872   save_volatile_regs(Z_SP, frame::z_abi_160_size, true, true);
6873 
6874   lgr_if_needed(Z_ARG2, oop);
6875   load_const_optimized(Z_ARG1, (address)msg);
6876   load_const_optimized(Z_R1, entry_addr);
6877   z_lg(Z_R1, 0, Z_R1);
6878   call_c(Z_R1);
6879 
6880   restore_volatile_regs(Z_SP, frame::z_abi_160_size, true, true);
6881   pop_frame();
6882   restore_return_pc();
6883 
6884   BLOCK_COMMENT(&quot;} verify_oop &quot;);
6885 }
6886 
6887 void MacroAssembler::verify_oop_addr(Address addr, const char* msg) {
6888   if (!VerifyOops) return;
6889 
6890   BLOCK_COMMENT(&quot;verify_oop {&quot;);
6891   unsigned int nbytes_save = (5 + 8) * BytesPerWord;
6892   address entry_addr = StubRoutines::verify_oop_subroutine_entry_address();
6893 
6894   save_return_pc();
6895   unsigned int frame_size = push_frame_abi160(nbytes_save); // kills Z_R0
6896   save_volatile_regs(Z_SP, frame::z_abi_160_size, true, false);
6897 
6898   z_lg(Z_ARG2, addr.plus_disp(frame_size));
6899   load_const_optimized(Z_ARG1, (address)msg);
6900   load_const_optimized(Z_R1, entry_addr);
6901   z_lg(Z_R1, 0, Z_R1);
6902   call_c(Z_R1);
6903 
6904   restore_volatile_regs(Z_SP, frame::z_abi_160_size, true, false);
6905   pop_frame();
6906   restore_return_pc();
6907 
6908   BLOCK_COMMENT(&quot;} verify_oop &quot;);
6909 }
6910 
6911 const char* MacroAssembler::stop_types[] = {
6912   &quot;stop&quot;,
6913   &quot;untested&quot;,
6914   &quot;unimplemented&quot;,
6915   &quot;shouldnotreachhere&quot;
6916 };
6917 
6918 static void stop_on_request(const char* tp, const char* msg) {
6919   tty-&gt;print(&quot;Z assembly code requires stop: (%s) %s\n&quot;, tp, msg);
6920   guarantee(false, &quot;Z assembly code requires stop: %s&quot;, msg);
6921 }
6922 
6923 void MacroAssembler::stop(int type, const char* msg, int id) {
6924   BLOCK_COMMENT(err_msg(&quot;stop: %s {&quot;, msg));
6925 
6926   // Setup arguments.
6927   load_const(Z_ARG1, (void*) stop_types[type%stop_end]);
6928   load_const(Z_ARG2, (void*) msg);
6929   get_PC(Z_R14);     // Following code pushes a frame without entering a new function. Use current pc as return address.
6930   save_return_pc();  // Saves return pc Z_R14.
6931   push_frame_abi160(0);
6932   call_VM_leaf(CAST_FROM_FN_PTR(address, stop_on_request), Z_ARG1, Z_ARG2);
6933   // The plain disassembler does not recognize illtrap. It instead displays
6934   // a 32-bit value. Issueing two illtraps assures the disassembler finds
6935   // the proper beginning of the next instruction.
6936   z_illtrap(); // Illegal instruction.
6937   z_illtrap(); // Illegal instruction.
6938 
6939   BLOCK_COMMENT(&quot; } stop&quot;);
6940 }
6941 
6942 // Special version of stop() for code size reduction.
6943 // Reuses the previously generated call sequence, if any.
6944 // Generates the call sequence on its own, if necessary.
6945 // Note: This code will work only in non-relocatable code!
6946 //       The relative address of the data elements (arg1, arg2) must not change.
6947 //       The reentry point must not move relative to it&#39;s users. This prerequisite
6948 //       should be given for &quot;hand-written&quot; code, if all chain calls are in the same code blob.
6949 //       Generated code must not undergo any transformation, e.g. ShortenBranches, to be safe.
6950 address MacroAssembler::stop_chain(address reentry, int type, const char* msg, int id, bool allow_relocation) {
6951   BLOCK_COMMENT(err_msg(&quot;stop_chain(%s,%s): %s {&quot;, reentry==NULL?&quot;init&quot;:&quot;cont&quot;, allow_relocation?&quot;reloc &quot;:&quot;static&quot;, msg));
6952 
6953   // Setup arguments.
6954   if (allow_relocation) {
6955     // Relocatable version (for comparison purposes). Remove after some time.
6956     load_const(Z_ARG1, (void*) stop_types[type%stop_end]);
6957     load_const(Z_ARG2, (void*) msg);
6958   } else {
6959     load_absolute_address(Z_ARG1, (address)stop_types[type%stop_end]);
6960     load_absolute_address(Z_ARG2, (address)msg);
6961   }
6962   if ((reentry != NULL) &amp;&amp; RelAddr::is_in_range_of_RelAddr16(reentry, pc())) {
6963     BLOCK_COMMENT(&quot;branch to reentry point:&quot;);
6964     z_brc(bcondAlways, reentry);
6965   } else {
6966     BLOCK_COMMENT(&quot;reentry point:&quot;);
6967     reentry = pc();      // Re-entry point for subsequent stop calls.
6968     save_return_pc();    // Saves return pc Z_R14.
6969     push_frame_abi160(0);
6970     if (allow_relocation) {
6971       reentry = NULL;    // Prevent reentry if code relocation is allowed.
6972       call_VM_leaf(CAST_FROM_FN_PTR(address, stop_on_request), Z_ARG1, Z_ARG2);
6973     } else {
6974       call_VM_leaf_static(CAST_FROM_FN_PTR(address, stop_on_request), Z_ARG1, Z_ARG2);
6975     }
6976     z_illtrap(); // Illegal instruction as emergency stop, should the above call return.
6977   }
6978   BLOCK_COMMENT(&quot; } stop_chain&quot;);
6979 
6980   return reentry;
6981 }
6982 
6983 // Special version of stop() for code size reduction.
6984 // Assumes constant relative addresses for data and runtime call.
6985 void MacroAssembler::stop_static(int type, const char* msg, int id) {
6986   stop_chain(NULL, type, msg, id, false);
6987 }
6988 
6989 void MacroAssembler::stop_subroutine() {
6990   unimplemented(&quot;stop_subroutine&quot;, 710);
6991 }
6992 
6993 // Prints msg to stdout from within generated code..
6994 void MacroAssembler::warn(const char* msg) {
6995   RegisterSaver::save_live_registers(this, RegisterSaver::all_registers, Z_R14);
6996   load_absolute_address(Z_R1, (address) warning);
6997   load_absolute_address(Z_ARG1, (address) msg);
6998   (void) call(Z_R1);
6999   RegisterSaver::restore_live_registers(this, RegisterSaver::all_registers);
7000 }
7001 
7002 #ifndef PRODUCT
7003 
7004 // Write pattern 0x0101010101010101 in region [low-before, high+after].
7005 void MacroAssembler::zap_from_to(Register low, Register high, Register val, Register addr, int before, int after) {
7006   if (!ZapEmptyStackFields) return;
7007   BLOCK_COMMENT(&quot;zap memory region {&quot;);
7008   load_const_optimized(val, 0x0101010101010101);
7009   int size = before + after;
7010   if (low == high &amp;&amp; size &lt; 5 &amp;&amp; size &gt; 0) {
7011     int offset = -before*BytesPerWord;
7012     for (int i = 0; i &lt; size; ++i) {
7013       z_stg(val, Address(low, offset));
7014       offset +=(1*BytesPerWord);
7015     }
7016   } else {
7017     add2reg(addr, -before*BytesPerWord, low);
7018     if (after) {
7019 #ifdef ASSERT
7020       jlong check = after * BytesPerWord;
7021       assert(Immediate::is_simm32(check) &amp;&amp; Immediate::is_simm32(-check), &quot;value not encodable !&quot;);
7022 #endif
7023       add2reg(high, after * BytesPerWord);
7024     }
7025     NearLabel loop;
7026     bind(loop);
7027     z_stg(val, Address(addr));
7028     add2reg(addr, 8);
7029     compare64_and_branch(addr, high, bcondNotHigh, loop);
7030     if (after) {
7031       add2reg(high, -after * BytesPerWord);
7032     }
7033   }
7034   BLOCK_COMMENT(&quot;} zap memory region&quot;);
7035 }
7036 #endif // !PRODUCT
7037 
7038 SkipIfEqual::SkipIfEqual(MacroAssembler* masm, const bool* flag_addr, bool value, Register _rscratch) {
7039   _masm = masm;
7040   _masm-&gt;load_absolute_address(_rscratch, (address)flag_addr);
7041   _masm-&gt;load_and_test_int(_rscratch, Address(_rscratch));
7042   if (value) {
7043     _masm-&gt;z_brne(_label); // Skip if true, i.e. != 0.
7044   } else {
7045     _masm-&gt;z_bre(_label);  // Skip if false, i.e. == 0.
7046   }
7047 }
7048 
7049 SkipIfEqual::~SkipIfEqual() {
7050   _masm-&gt;bind(_label);
7051 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
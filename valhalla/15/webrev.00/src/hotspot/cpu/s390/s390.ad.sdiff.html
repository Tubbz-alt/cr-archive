<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/s390.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_s390.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../sparc/interp_masm_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/s390.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  647 
  648 int CallRuntimeDirectNode::compute_padding(int current_offset) const {
  649   return (12 - current_offset) &amp; 2;
  650 }
  651 
  652 int CallLeafDirectNode::compute_padding(int current_offset) const {
  653   return (12 - current_offset) &amp; 2;
  654 }
  655 
  656 int CallLeafNoFPDirectNode::compute_padding(int current_offset) const {
  657   return (12 - current_offset) &amp; 2;
  658 }
  659 
  660 // Indicate if the safepoint node needs the polling page as an input.
  661 // Since z/Architecture does not have absolute addressing, it does.
  662 bool SafePointNode::needs_polling_address_input() {
  663   return true;
  664 }
  665 
  666 void emit_nop(CodeBuffer &amp;cbuf) {
<span class="line-modified">  667   MacroAssembler _masm(&amp;cbuf);</span>
  668   __ z_nop();
  669 }
  670 
  671 // Emit an interrupt that is caught by the debugger (for debugging compiler).
  672 void emit_break(CodeBuffer &amp;cbuf) {
<span class="line-modified">  673   MacroAssembler _masm(&amp;cbuf);</span>
  674   __ z_illtrap();
  675 }
  676 
  677 #if !defined(PRODUCT)
  678 void MachBreakpointNode::format(PhaseRegAlloc *, outputStream *os) const {
  679   os-&gt;print(&quot;TA&quot;);
  680 }
  681 #endif
  682 
  683 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  684   emit_break(cbuf);
  685 }
  686 
  687 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  688   return MachNode::size(ra_);
  689 }
  690 
  691 static inline void z_emit16(CodeBuffer &amp;cbuf, long value) {
  692   // 32bit instructions may become sign extended.
  693   assert(value &gt;= 0, &quot;unintended sign extension (int-&gt;long)&quot;);
</pre>
<hr />
<pre>
  718     value = (long)((unsigned long)((unsigned int)value));
  719   }
  720 
  721   if (value &lt; (1L &lt;&lt; 16)) { // 2-byte instruction
  722     z_emit16(cbuf, value);
  723     return 2;
  724   }
  725 
  726   if (value &lt; (1L &lt;&lt; 32)) { // 4-byte instruction, might be unaligned store
  727     z_emit32(cbuf, value);
  728     return 4;
  729   }
  730 
  731   // 6-byte instruction, probably unaligned store.
  732   z_emit48(cbuf, value);
  733   return 6;
  734 }
  735 
  736 // Check effective address (at runtime) for required alignment.
  737 static inline void z_assert_aligned(CodeBuffer &amp;cbuf, int disp, Register index, Register base, int alignment) {
<span class="line-modified">  738   MacroAssembler _masm(&amp;cbuf);</span>
  739 
  740   __ z_lay(Z_R0, disp, index, base);
  741   __ z_nill(Z_R0, alignment-1);
  742   __ z_brc(Assembler::bcondEqual, +3);
  743   __ z_illtrap();
  744 }
  745 
<span class="line-modified">  746 int emit_call_reloc(MacroAssembler &amp;_masm, intptr_t entry_point, relocInfo::relocType rtype,</span>
  747                     PhaseRegAlloc* ra_, bool is_native_call = false) {
  748   __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
  749   address old_mark = __ inst_mark();
  750   unsigned int start_off = __ offset();
  751 
  752   if (is_native_call) {
  753     ShouldNotReachHere();
  754   }
  755 
  756   if (rtype == relocInfo::runtime_call_w_cp_type) {
  757     assert((__ offset() &amp; 2) == 0, &quot;misaligned emit_call_reloc&quot;);
  758     address call_addr = __ call_c_opt((address)entry_point);
  759     if (call_addr == NULL) {
  760       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
  761       return -1;
  762     }
  763   } else {
  764     assert(rtype == relocInfo::none || rtype == relocInfo::opt_virtual_call_type ||
  765            rtype == relocInfo::static_call_type, &quot;unexpected rtype&quot;);
  766     __ relocate(rtype);
  767     // BRASL must be prepended with a nop to identify it in the instruction stream.
  768     __ z_nop();
  769     __ z_brasl(Z_R14, (address)entry_point);
  770   }
  771 
  772   unsigned int ret_off = __ offset();
  773 
  774   return (ret_off - start_off);
  775 }
  776 
<span class="line-modified">  777 static int emit_call_reloc(MacroAssembler &amp;_masm, intptr_t entry_point, RelocationHolder const&amp; rspec) {</span>
  778   __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
  779   address old_mark = __ inst_mark();
  780   unsigned int start_off = __ offset();
  781 
  782   relocInfo::relocType rtype = rspec.type();
  783   assert(rtype == relocInfo::opt_virtual_call_type || rtype == relocInfo::static_call_type,
  784          &quot;unexpected rtype&quot;);
  785 
  786   __ relocate(rspec);
  787   __ z_nop();
  788   __ z_brasl(Z_R14, (address)entry_point);
  789 
  790   unsigned int ret_off = __ offset();
  791 
  792   return (ret_off - start_off);
  793 }
  794 
  795 //=============================================================================
  796 
  797 const RegMask&amp; MachConstantBaseNode::_out_RegMask = _Z_PTR_REG_mask;
<span class="line-modified">  798 int Compile::ConstantTable::calculate_table_base_offset() const {</span>
  799   return 0;  // absolute addressing, no offset
  800 }
  801 
  802 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  803 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  804   ShouldNotReachHere();
  805 }
  806 
  807 // Even with PC-relative TOC addressing, we still need this node.
  808 // Float loads/stores do not support PC-relative addresses.
  809 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
<span class="line-modified">  810   MacroAssembler _masm(&amp;cbuf);</span>
  811   Register Rtoc = as_Register(ra_-&gt;get_encode(this));
  812   __ load_toc(Rtoc);
  813 }
  814 
  815 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  816   // PCrelative TOC access.
  817   return 6;   // sizeof(LARL)
  818 }
  819 
  820 #if !defined(PRODUCT)
  821 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  822   Register r = as_Register(ra_-&gt;get_encode(this));
  823   st-&gt;print(&quot;LARL    %s,&amp;constant_pool # MachConstantBaseNode&quot;, r-&gt;name());
  824 }
  825 #endif
  826 
  827 //=============================================================================
  828 
  829 #if !defined(PRODUCT)
  830 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
  831   Compile* C = ra_-&gt;C;
  832   st-&gt;print_cr(&quot;--- MachPrologNode ---&quot;);
  833   st-&gt;print(&quot;\t&quot;);
  834   for (int i = 0; i &lt; OptoPrologueNops; i++) {
  835     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
  836   }
  837 
  838   if (VerifyThread) {
  839     st-&gt;print_cr(&quot;Verify_Thread&quot;);
  840     st-&gt;print(&quot;\t&quot;);
  841   }
  842 
<span class="line-modified">  843   long framesize = C-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  844   int bangsize   = C-&gt;bang_size_in_bytes();</span>
  845 
  846   // Calls to C2R adapters often do not accept exceptional returns.
  847   // We require that their callers must bang for them. But be
  848   // careful, because some VM calls (such as call site linkage) can
  849   // use several kilobytes of stack. But the stack safety zone should
  850   // account for that. See bugs 4446381, 4468289, 4497237.
<span class="line-modified">  851   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
  852     st-&gt;print_cr(&quot;# stack bang&quot;); st-&gt;print(&quot;\t&quot;);
  853   }
  854   st-&gt;print_cr(&quot;push_frame %d&quot;, (int)-framesize);
  855   st-&gt;print(&quot;\t&quot;);
  856 }
  857 #endif
  858 
  859 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  860   Compile* C = ra_-&gt;C;
<span class="line-modified">  861   MacroAssembler _masm(&amp;cbuf);</span>
  862 
  863   __ verify_thread();
  864 
<span class="line-modified">  865   size_t framesize = C-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  866   size_t bangsize  = C-&gt;bang_size_in_bytes();</span>
  867 
  868   assert(framesize % wordSize == 0, &quot;must preserve wordSize alignment&quot;);
  869 
  870   if (C-&gt;clinit_barrier_on_entry()) {
  871     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  872 
  873     Label L_skip_barrier;
  874     Register klass = Z_R1_scratch;
  875 
  876     // Notify OOP recorder (don&#39;t need the relocation)
  877     AddressLiteral md = __ constant_metadata_address(C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  878     __ load_const_optimized(klass, md.value());
  879     __ clinit_barrier(klass, Z_thread, &amp;L_skip_barrier /*L_fast_path*/);
  880 
  881     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub());
  882     __ z_br(klass);
  883 
  884     __ bind(L_skip_barrier);
  885   }
  886 
  887   // Calls to C2R adapters often do not accept exceptional returns.
  888   // We require that their callers must bang for them. But be
  889   // careful, because some VM calls (such as call site linkage) can
  890   // use several kilobytes of stack. But the stack safety zone should
  891   // account for that. See bugs 4446381, 4468289, 4497237.
<span class="line-modified">  892   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
  893     __ generate_stack_overflow_check(bangsize);
  894   }
  895 
  896   assert(Immediate::is_uimm32((long)framesize), &quot;to do: choose suitable types!&quot;);
  897   __ save_return_pc();
  898 
  899   // The z/Architecture abi is already accounted for in `framesize&#39; via the
  900   // &#39;out_preserve_stack_slots&#39; declaration.
  901   __ push_frame((unsigned int)framesize/*includes JIT ABI*/);
  902 
  903   if (C-&gt;has_mach_constant_base_node()) {
  904     // NOTE: We set the table base offset here because users might be
  905     // emitted before MachConstantBaseNode.
<span class="line-modified">  906     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
  907     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  908   }
  909 }
  910 
  911 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  912   // Variable size. Determine dynamically.
  913   return MachNode::size(ra_);
  914 }
  915 
  916 int MachPrologNode::reloc() const {
  917   // Return number of relocatable values contained in this instruction.
  918   return 1; // One reloc entry for load_const(toc).
  919 }
  920 
  921 //=============================================================================
  922 
  923 #if !defined(PRODUCT)
  924 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
  925   os-&gt;print_cr(&quot;epilog&quot;);
  926   os-&gt;print(&quot;\t&quot;);
  927   if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
  928     os-&gt;print_cr(&quot;load_from_polling_page Z_R1_scratch&quot;);
  929     os-&gt;print(&quot;\t&quot;);
  930   }
  931 }
  932 #endif
  933 
  934 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">  935   MacroAssembler _masm(&amp;cbuf);</span>
  936   Compile* C = ra_-&gt;C;
  937   __ verify_thread();
  938 
  939   // If this does safepoint polling, then do it here.
  940   bool need_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
  941 
  942   // Pop frame, restore return_pc, and all stuff needed by interpreter.
<span class="line-modified">  943   int frame_size_in_bytes = Assembler::align((C-&gt;frame_slots() &lt;&lt; LogBytesPerInt), frame::alignment_in_bytes);</span>
  944   __ pop_frame_restore_retPC(frame_size_in_bytes);
  945 
  946   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  947     __ reserved_stack_check(Z_R14);
  948   }
  949 
  950   // Touch the polling page.
  951   if (need_polling) {
  952     if (SafepointMechanism::uses_thread_local_poll()) {
  953       __ z_lg(Z_R1_scratch, Address(Z_thread, Thread::polling_page_offset()));
  954     } else {
  955       AddressLiteral pp(os::get_polling_page());
  956       __ load_const_optimized(Z_R1_scratch, pp);
  957     }
  958     // We need to mark the code position where the load from the safepoint
  959     // polling page was emitted as relocInfo::poll_return_type here.
  960     __ relocate(relocInfo::poll_return_type);
  961     __ load_from_polling_page(Z_R1_scratch);
  962   }
  963 }
</pre>
<hr />
<pre>
 1017   if (cbuf) {
 1018     if (opcode &gt; (1L&lt;&lt;32)) {
 1019       return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 48) |
 1020                          Assembler::simm20(offset) | Assembler::reg(Z_R0, 12, 48) | Assembler::regz(Z_SP, 16, 48));
 1021     } else {
 1022       return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 32) |
 1023                          Assembler::uimm12(offset, 20, 32) | Assembler::reg(Z_R0, 12, 32) | Assembler::regz(Z_SP, 16, 32));
 1024     }
 1025   }
 1026 
 1027 #if !defined(PRODUCT)
 1028   if (do_print) {
 1029     os-&gt;print(&quot;%s    %s,#%d[,SP]\t # MachCopy spill code&quot;,op_str, Matcher::regName[reg], offset);
 1030   }
 1031 #endif
 1032   return (opcode &gt; (1L &lt;&lt; 32)) ? 6 : 4;
 1033 }
 1034 
 1035 static unsigned int z_mvc_helper(CodeBuffer *cbuf, int len, int dst_off, int src_off, bool do_print, outputStream *os) {
 1036   if (cbuf) {
<span class="line-modified"> 1037     MacroAssembler _masm(cbuf);</span>
 1038     __ z_mvc(dst_off, len-1, Z_SP, src_off, Z_SP);
 1039   }
 1040 
 1041 #if !defined(PRODUCT)
 1042   else if (do_print) {
 1043     os-&gt;print(&quot;MVC     %d(%d,SP),%d(SP)\t # MachCopy spill code&quot;,dst_off, len, src_off);
 1044   }
 1045 #endif
 1046 
 1047   return 6;
 1048 }
 1049 
 1050 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *os) const {
 1051   // Get registers to move.
 1052   OptoReg::Name src_hi = ra_-&gt;get_reg_second(in(1));
 1053   OptoReg::Name src_lo = ra_-&gt;get_reg_first(in(1));
 1054   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(this);
 1055   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(this);
 1056 
 1057   enum RC src_hi_rc = rc_class(src_hi);
</pre>
<hr />
<pre>
 1091     }
 1092 
 1093     int r0 = Z_R0_num;
 1094     if (is64) {
 1095       return z_ld_st_helper(cbuf, &quot;LG  &quot;, LG_ZOPC, r0, src_offset, print, os) +
 1096              z_ld_st_helper(cbuf, &quot;STG &quot;, STG_ZOPC, r0, dst_offset, print, os);
 1097     }
 1098 
 1099     return z_ld_st_helper(cbuf, &quot;LY   &quot;, LY_ZOPC, r0, src_offset, print, os) +
 1100            z_ld_st_helper(cbuf, &quot;STY  &quot;, STY_ZOPC, r0, dst_offset, print, os);
 1101   }
 1102 
 1103   // Check for float-&gt;int copy. Requires a trip through memory.
 1104   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
 1105     Unimplemented();  // Unsafe, do not remove!
 1106   }
 1107 
 1108   // Check for integer reg-reg copy.
 1109   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
 1110     if (cbuf) {
<span class="line-modified"> 1111       MacroAssembler _masm(cbuf);</span>
 1112       Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
 1113       Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
 1114       __ z_lgr(Rdst, Rsrc);
 1115       return 4;
 1116     }
 1117 #if !defined(PRODUCT)
 1118     // else
 1119     if (print) {
 1120       os-&gt;print(&quot;LGR     %s,%s\t # MachCopy spill code&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1121     }
 1122 #endif
 1123     return 4;
 1124   }
 1125 
 1126   // Check for integer store.
 1127   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
 1128     assert(!is64 || (src_hi_rc==rc_int &amp;&amp; dst_hi_rc==rc_stack),
 1129            &quot;expected same type of move for high parts&quot;);
 1130 
 1131     if (is64) {
</pre>
<hr />
<pre>
 1138 
 1139     return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);
 1140   }
 1141 
 1142   // Check for integer load
 1143   // Always load cOops zero-extended. That doesn&#39;t hurt int loads.
 1144   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
 1145 
 1146     assert(!is64 || (dst_hi_rc==rc_int &amp;&amp; src_hi_rc==rc_stack),
 1147            &quot;expected same type of move for high parts&quot;);
 1148 
 1149     mnemo = is64 ? &quot;LG  &quot; : &quot;LLGF&quot;;
 1150     opc = is64 ? LG_ZOPC : LLGF_ZOPC;
 1151 
 1152     return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);
 1153   }
 1154 
 1155   // Check for float reg-reg copy.
 1156   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
 1157     if (cbuf) {
<span class="line-modified"> 1158       MacroAssembler _masm(cbuf);</span>
 1159       FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
 1160       FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
 1161       __ z_ldr(Rdst, Rsrc);
 1162       return 2;
 1163     }
 1164 #if !defined(PRODUCT)
 1165     // else
 1166     if (print) {
 1167       os-&gt;print(&quot;LDR      %s,%s\t # MachCopy spill code&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1168     }
 1169 #endif
 1170     return 2;
 1171   }
 1172 
 1173   // Check for float store.
 1174   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
 1175     assert(!is64 || (src_hi_rc==rc_float &amp;&amp; dst_hi_rc==rc_stack),
 1176            &quot;expected same type of move for high parts&quot;);
 1177 
 1178     if (is64) {
</pre>
<hr />
<pre>
 1237 }
 1238 #endif
 1239 
 1240 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1241   implementation(&amp;cbuf, ra_, false, NULL);
 1242 }
 1243 
 1244 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1245   return implementation(NULL, ra_, true, NULL);
 1246 }
 1247 
 1248 //=============================================================================
 1249 
 1250 #if !defined(PRODUCT)
 1251 void MachNopNode::format(PhaseRegAlloc *, outputStream *os) const {
 1252   os-&gt;print(&quot;NOP     # pad for alignment (%d nops, %d bytes)&quot;, _count, _count*MacroAssembler::nop_size());
 1253 }
 1254 #endif
 1255 
 1256 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc * ra_) const {
<span class="line-modified"> 1257   MacroAssembler _masm(&amp;cbuf);</span>
 1258 
 1259   int rem_space = 0;
<span class="line-modified"> 1260   if (!(ra_-&gt;C-&gt;in_scratch_emit_size())) {</span>
 1261     rem_space = cbuf.insts()-&gt;remaining();
 1262     if (rem_space &lt;= _count*2 + 8) {
 1263       tty-&gt;print(&quot;NopNode: _count = %3.3d, remaining space before = %d&quot;, _count, rem_space);
 1264     }
 1265   }
 1266 
 1267   for (int i = 0; i &lt; _count; i++) {
 1268     __ z_nop();
 1269   }
 1270 
<span class="line-modified"> 1271   if (!(ra_-&gt;C-&gt;in_scratch_emit_size())) {</span>
 1272     if (rem_space &lt;= _count*2 + 8) {
 1273       int rem_space2 = cbuf.insts()-&gt;remaining();
 1274       tty-&gt;print_cr(&quot;, after = %d&quot;, rem_space2);
 1275     }
 1276   }
 1277 }
 1278 
 1279 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 1280    return 2 * _count;
 1281 }
 1282 
 1283 #if !defined(PRODUCT)
 1284 void BoxLockNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1285   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1286   if (ra_ &amp;&amp; ra_-&gt;node_regs_max_index() &gt; 0) {
 1287     int reg = ra_-&gt;get_reg_first(this);
 1288     os-&gt;print(&quot;ADDHI  %s, SP, %d\t//box node&quot;, Matcher::regName[reg], offset);
 1289   } else {
 1290     os-&gt;print(&quot;ADDHI  N%d = SP + %d\t// box node&quot;, _idx, offset);
 1291   }
 1292 }
 1293 #endif
 1294 
 1295 // Take care of the size function, if you make changes here!
 1296 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1297   MacroAssembler _masm(&amp;cbuf);</span>
 1298 
 1299   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1300   int reg = ra_-&gt;get_encode(this);
 1301   __ z_lay(as_Register(reg), offset, Z_SP);
 1302 }
 1303 
 1304 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1305   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
 1306   return 6;
 1307 }
 1308 
 1309  %} // end source section
 1310 
 1311 //----------SOURCE BLOCK-------------------------------------------------------
 1312 // This is a block of C++ code which provides values, functions, and
 1313 // definitions necessary in the rest of the architecture description
 1314 
 1315 source_hpp %{
 1316 
 1317 // Header information of the source block.
</pre>
<hr />
<pre>
 1343 
 1344 %} // end source_hpp section
 1345 
 1346 source %{
 1347 
 1348 #if !defined(PRODUCT)
 1349 void MachUEPNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1350   os-&gt;print_cr(&quot;---- MachUEPNode ----&quot;);
 1351   os-&gt;print_cr(&quot;\tTA&quot;);
 1352   os-&gt;print_cr(&quot;\tload_const Z_R1, SharedRuntime::get_ic_miss_stub()&quot;);
 1353   os-&gt;print_cr(&quot;\tBR(Z_R1)&quot;);
 1354   os-&gt;print_cr(&quot;\tTA  # pad with illtraps&quot;);
 1355   os-&gt;print_cr(&quot;\t...&quot;);
 1356   os-&gt;print_cr(&quot;\tTA&quot;);
 1357   os-&gt;print_cr(&quot;\tLTGR    Z_R2, Z_R2&quot;);
 1358   os-&gt;print_cr(&quot;\tBRU     ic_miss&quot;);
 1359 }
 1360 #endif
 1361 
 1362 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1363   MacroAssembler _masm(&amp;cbuf);</span>
 1364   const int ic_miss_offset = 2;
 1365 
 1366   // Inline_cache contains a klass.
 1367   Register ic_klass = as_Register(Matcher::inline_cache_reg_encode());
 1368   // ARG1 is the receiver oop.
 1369   Register R2_receiver = Z_ARG1;
 1370   int      klass_offset = oopDesc::klass_offset_in_bytes();
 1371   AddressLiteral icmiss(SharedRuntime::get_ic_miss_stub());
 1372   Register R1_ic_miss_stub_addr = Z_R1_scratch;
 1373 
 1374   // Null check of receiver.
 1375   // This is the null check of the receiver that actually should be
 1376   // done in the caller. It&#39;s here because in case of implicit null
 1377   // checks we get it for free.
 1378   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()),
 1379          &quot;second word in oop should not require explicit null check.&quot;);
 1380   if (!ImplicitNullChecks) {
 1381     Label valid;
 1382     if (VM_Version::has_CompareBranch()) {
 1383       __ z_cgij(R2_receiver, 0, Assembler::bcondNotEqual, valid);
</pre>
<hr />
<pre>
 1438 source %{
 1439 
 1440 // This exception handler code snippet is placed after the method&#39;s
 1441 // code. It is the return point if an exception occurred. it jumps to
 1442 // the exception blob.
 1443 //
 1444 // If the method gets deoptimized, the method and this code snippet
 1445 // get patched.
 1446 //
 1447 // 1) Trampoline code gets patched into the end of this exception
 1448 //   handler. the trampoline code jumps to the deoptimization blob.
 1449 //
 1450 // 2) The return address in the method&#39;s code will get patched such
 1451 //   that it jumps to the trampoline.
 1452 //
 1453 // 3) The handler will get patched such that it does not jump to the
 1454 //   exception blob, but to an entry in the deoptimization blob being
 1455 //   aware of the exception.
 1456 int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
 1457   Register temp_reg = Z_R1;
<span class="line-modified"> 1458   MacroAssembler _masm(&amp;cbuf);</span>
 1459 
 1460   address base = __ start_a_stub(size_exception_handler());
 1461   if (base == NULL) {
 1462     return 0;          // CodeBuffer::expand failed
 1463   }
 1464 
 1465   int offset = __ offset();
 1466   // Use unconditional pc-relative jump with 32-bit range here.
 1467   __ load_const_optimized(temp_reg, (address)OptoRuntime::exception_blob()-&gt;content_begin());
 1468   __ z_br(temp_reg);
 1469 
 1470   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
 1471 
 1472   __ end_a_stub();
 1473 
 1474   return offset;
 1475 }
 1476 
 1477 // Emit deopt handler code.
 1478 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
<span class="line-modified"> 1479   MacroAssembler _masm(&amp;cbuf);</span>
 1480   address        base = __ start_a_stub(size_deopt_handler());
 1481 
 1482   if (base == NULL) {
 1483     return 0;  // CodeBuffer::expand failed
 1484   }
 1485 
 1486   int offset = __ offset();
 1487 
 1488   // Size_deopt_handler() must be exact on zarch, so for simplicity
 1489   // we do not use load_const_opt here.
 1490   __ load_const(Z_R1, SharedRuntime::deopt_blob()-&gt;unpack());
 1491   __ call(Z_R1);
 1492   assert(__ offset() - offset == (int) size_deopt_handler(), &quot;must be fixed size&quot;);
 1493 
 1494   __ end_a_stub();
 1495   return offset;
 1496 }
 1497 
 1498 //=============================================================================
 1499 
</pre>
<hr />
<pre>
 1824 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER. REG_INTER causes an
 1825 // operand to generate a function which returns its register number when
 1826 // queried. CONST_INTER causes an operand to generate a function which
 1827 // returns the value of the constant when queried. MEMORY_INTER causes an
 1828 // operand to generate four functions which return the Base Register, the
 1829 // Index Register, the Scale Value, and the Offset Value of the operand when
 1830 // queried. COND_INTER causes an operand to generate six functions which
 1831 // return the encoding code (ie - encoding bits for the instruction)
 1832 // associated with each basic boolean condition for a conditional instruction.
 1833 //
 1834 // Instructions specify two basic values for encoding. Again, a function
 1835 // is available to check if the constant displacement is an oop. They use the
 1836 // ins_encode keyword to specify their encoding classes (which must be
 1837 // a sequence of enc_class names, and their parameters, specified in
 1838 // the encoding block), and they use the
 1839 // opcode keyword to specify, in order, their primary, secondary, and
 1840 // tertiary opcode. Only the opcode sections which a particular instruction
 1841 // needs for encoding need to be specified.
 1842 encode %{
 1843   enc_class enc_unimplemented %{
<span class="line-modified"> 1844     MacroAssembler _masm(&amp;cbuf);</span>
 1845     __ unimplemented(&quot;Unimplemented mach node encoding in AD file.&quot;, 13);
 1846   %}
 1847 
 1848   enc_class enc_untested %{
 1849 #ifdef ASSERT
<span class="line-modified"> 1850     MacroAssembler _masm(&amp;cbuf);</span>
 1851     __ untested(&quot;Untested mach node encoding in AD file.&quot;);
 1852 #endif
 1853   %}
 1854 
 1855   enc_class z_rrform(iRegI dst, iRegI src) %{
 1856     assert((($primary &gt;&gt; 14) &amp; 0x03) == 0, &quot;Instruction format error&quot;);
 1857     assert( ($primary &gt;&gt; 16)         == 0, &quot;Instruction format error&quot;);
 1858     z_emit16(cbuf, $primary |
 1859              Assembler::reg($dst$$reg,8,16) |
 1860              Assembler::reg($src$$reg,12,16));
 1861   %}
 1862 
 1863   enc_class z_rreform(iRegI dst1, iRegI src2) %{
 1864     assert((($primary &gt;&gt; 30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1865     z_emit32(cbuf, $primary |
 1866              Assembler::reg($dst1$$reg,24,32) |
 1867              Assembler::reg($src2$$reg,28,32));
 1868   %}
 1869 
 1870   enc_class z_rrfform(iRegI dst1, iRegI src2, iRegI src3) %{
</pre>
<hr />
<pre>
 2016   %}
 2017 
 2018   enc_class z_form_rt_mem_opt(iRegI dst, memory mem) %{
 2019     int isize = $secondary &gt; 1L &lt;&lt; 32 ? 48 : 32;
 2020     Register Ridx = $mem$$index$$Register;
 2021     if (Ridx == noreg) { Ridx = Z_R0; } // Index is 0.
 2022 
 2023     if (Displacement::is_shortDisp((long)$mem$$disp)) {
 2024       z_emit_inst(cbuf, $secondary |
 2025                   Assembler::reg($dst$$reg, 8, isize) |
 2026                   Assembler::uimm12($mem$$disp, 20, isize) |
 2027                   Assembler::reg(Ridx, 12, isize) |
 2028                   Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
 2029     } else if (Displacement::is_validDisp((long)$mem$$disp)) {
 2030       z_emit_inst(cbuf, $primary |
 2031                   Assembler::reg($dst$$reg, 8, 48) |
 2032                   Assembler::simm20($mem$$disp) |
 2033                   Assembler::reg(Ridx, 12, 48) |
 2034                   Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
 2035     } else {
<span class="line-modified"> 2036         MacroAssembler _masm(&amp;cbuf);</span>
 2037         __ load_const_optimized(Z_R1_scratch, $mem$$disp);
 2038         if (Ridx != Z_R0) { __ z_agr(Z_R1_scratch, Ridx); }
 2039         z_emit_inst(cbuf, $secondary |
 2040                     Assembler::reg($dst$$reg, 8, isize) |
 2041                     Assembler::uimm12(0, 20, isize) |
 2042                     Assembler::reg(Z_R1_scratch, 12, isize) |
 2043                     Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
 2044     }
 2045   %}
 2046 
 2047   enc_class z_enc_brul(Label lbl) %{
<span class="line-modified"> 2048     MacroAssembler _masm(&amp;cbuf);</span>
 2049     Label* p = $lbl$$label;
 2050 
 2051     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2052     // determine the size of the encoded instruction.
 2053     // Use a bound dummy label in that case.
 2054     Label d;
 2055     __ bind(d);
 2056     Label&amp; l = (NULL == p) ? d : *(p);
 2057     __ z_brul(l);
 2058   %}
 2059 
 2060   enc_class z_enc_bru(Label lbl) %{
<span class="line-modified"> 2061     MacroAssembler _masm(&amp;cbuf);</span>
 2062     Label* p = $lbl$$label;
 2063 
 2064     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2065     // determine the size of the encoded instruction.
 2066     // Use a bound dummy label in that case.
 2067     Label d;
 2068     __ bind(d);
 2069     Label&amp; l = (NULL == p) ? d : *(p);
 2070     __ z_bru(l);
 2071   %}
 2072 
 2073   enc_class z_enc_branch_con_far(cmpOp cmp, Label lbl) %{
<span class="line-modified"> 2074     MacroAssembler _masm(&amp;cbuf);</span>
 2075     Label* p = $lbl$$label;
 2076 
 2077     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2078     // determine the size of the encoded instruction.
 2079     // Use a bound dummy label in that case.
 2080     Label d;
 2081     __ bind(d);
 2082     Label&amp; l = (NULL == p) ? d : *(p);
 2083     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2084   %}
 2085 
 2086   enc_class z_enc_branch_con_short(cmpOp cmp, Label lbl) %{
<span class="line-modified"> 2087     MacroAssembler _masm(&amp;cbuf);</span>
 2088     Label* p = $lbl$$label;
 2089 
 2090     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2091     // determine the size of the encoded instruction.
 2092     // Use a bound dummy label in that case.
 2093     Label d;
 2094     __ bind(d);
 2095     Label&amp; l = (NULL == p) ? d : *(p);
 2096     __ z_brc((Assembler::branch_condition)$cmp$$cmpcode, l);
 2097   %}
 2098 
 2099   enc_class z_enc_cmpb_regreg(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified"> 2100     MacroAssembler _masm(&amp;cbuf);</span>
 2101     Label* p = $lbl$$label;
 2102 
 2103     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2104     // determine the size of the encoded instruction.
 2105     // Use a bound dummy label in that case.
 2106     Label d;
 2107     __ bind(d);
 2108     Label&amp; l = (NULL == p) ? d : *(p);
 2109     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2110     unsigned long instr = $primary;
 2111     if (instr == CRJ_ZOPC) {
 2112       __ z_crj($src1$$Register, $src2$$Register, cc, l);
 2113     } else if (instr == CLRJ_ZOPC) {
 2114       __ z_clrj($src1$$Register, $src2$$Register, cc, l);
 2115     } else if (instr == CGRJ_ZOPC) {
 2116       __ z_cgrj($src1$$Register, $src2$$Register, cc, l);
 2117     } else {
 2118       guarantee(instr == CLGRJ_ZOPC, &quot;opcode not implemented&quot;);
 2119       __ z_clgrj($src1$$Register, $src2$$Register, cc, l);
 2120     }
 2121   %}
 2122 
 2123   enc_class z_enc_cmpb_regregFar(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified"> 2124     MacroAssembler _masm(&amp;cbuf);</span>
 2125     Label* p = $lbl$$label;
 2126 
 2127     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2128     // determine the size of the encoded instruction.
 2129     // Use a bound dummy label in that case.
 2130     Label d;
 2131     __ bind(d);
 2132     Label&amp; l = (NULL == p) ? d : *(p);
 2133 
 2134     unsigned long instr = $primary;
 2135     if (instr == CR_ZOPC) {
 2136       __ z_cr($src1$$Register, $src2$$Register);
 2137     } else if (instr == CLR_ZOPC) {
 2138       __ z_clr($src1$$Register, $src2$$Register);
 2139     } else if (instr == CGR_ZOPC) {
 2140       __ z_cgr($src1$$Register, $src2$$Register);
 2141     } else {
 2142       guarantee(instr == CLGR_ZOPC, &quot;opcode not implemented&quot;);
 2143       __ z_clgr($src1$$Register, $src2$$Register);
 2144     }
 2145 
 2146     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2147   %}
 2148 
 2149   enc_class z_enc_cmpb_regimm(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified"> 2150     MacroAssembler _masm(&amp;cbuf);</span>
 2151     Label* p = $lbl$$label;
 2152 
 2153     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2154     // determine the size of the encoded instruction.
 2155     // Use a bound dummy label in that case.
 2156     Label d;
 2157     __ bind(d);
 2158     Label&amp; l = (NULL == p) ? d : *(p);
 2159 
 2160     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2161     unsigned long instr = $primary;
 2162     if (instr == CIJ_ZOPC) {
 2163       __ z_cij($src1$$Register, $src2$$constant, cc, l);
 2164     } else if (instr == CLIJ_ZOPC) {
 2165       __ z_clij($src1$$Register, $src2$$constant, cc, l);
 2166     } else if (instr == CGIJ_ZOPC) {
 2167       __ z_cgij($src1$$Register, $src2$$constant, cc, l);
 2168     } else {
 2169       guarantee(instr == CLGIJ_ZOPC, &quot;opcode not implemented&quot;);
 2170       __ z_clgij($src1$$Register, $src2$$constant, cc, l);
 2171     }
 2172   %}
 2173 
 2174   enc_class z_enc_cmpb_regimmFar(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified"> 2175     MacroAssembler _masm(&amp;cbuf);</span>
 2176     Label* p = $lbl$$label;
 2177 
 2178     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2179     // determine the size of the encoded instruction.
 2180     // Use a bound dummy label in that case.
 2181     Label d;
 2182     __ bind(d);
 2183     Label&amp; l = (NULL == p) ? d : *(p);
 2184 
 2185     unsigned long instr = $primary;
 2186     if (instr == CHI_ZOPC) {
 2187       __ z_chi($src1$$Register, $src2$$constant);
 2188     } else if (instr == CLFI_ZOPC) {
 2189       __ z_clfi($src1$$Register, $src2$$constant);
 2190     } else if (instr == CGHI_ZOPC) {
 2191       __ z_cghi($src1$$Register, $src2$$constant);
 2192     } else {
 2193       guarantee(instr == CLGFI_ZOPC, &quot;opcode not implemented&quot;);
 2194       __ z_clgfi($src1$$Register, $src2$$constant);
 2195     }
 2196 
 2197     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2198   %}
 2199 
 2200   // Call from Java to runtime.
 2201   enc_class z_enc_java_to_runtime_call(method meth) %{
<span class="line-modified"> 2202     MacroAssembler _masm(&amp;cbuf);</span>
 2203 
 2204     // Save return pc before call to the place where we need it, since
 2205     // callee doesn&#39;t.
 2206     unsigned int start_off = __ offset();
 2207     // Compute size of &quot;larl + stg + call_c_opt&quot;.
 2208     const int size_of_code = 6 + 6 + MacroAssembler::call_far_patchable_size();
 2209     __ get_PC(Z_R14, size_of_code);
 2210     __ save_return_pc();
 2211     assert(__ offset() - start_off == 12, &quot;bad prelude len: %d&quot;, __ offset() - start_off);
 2212 
 2213     assert((__ offset() &amp; 2) == 0, &quot;misaligned z_enc_java_to_runtime_call&quot;);
 2214     address call_addr = __ call_c_opt((address)$meth$$method);
 2215     if (call_addr == NULL) {
 2216       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 2217       return;
 2218     }
 2219 
 2220 #ifdef ASSERT
 2221     // Plausibility check for size_of_code assumptions.
 2222     unsigned int actual_ret_off = __ offset();
 2223     assert(start_off + size_of_code == actual_ret_off, &quot;wrong return_pc&quot;);
 2224 #endif
 2225   %}
 2226 
 2227   enc_class z_enc_java_static_call(method meth) %{
 2228     // Call to fixup routine. Fixup routine uses ScopeDesc info to determine
 2229     // whom we intended to call.
<span class="line-modified"> 2230     MacroAssembler _masm(&amp;cbuf);</span>
 2231     int ret_offset = 0;
 2232 
 2233     if (!_method) {
 2234       ret_offset = emit_call_reloc(_masm, $meth$$method,
 2235                                    relocInfo::runtime_call_w_cp_type, ra_);
 2236     } else {
 2237       int method_index = resolved_method_index(cbuf);
 2238       if (_optimized_virtual) {
 2239         ret_offset = emit_call_reloc(_masm, $meth$$method,
 2240                                      opt_virtual_call_Relocation::spec(method_index));
 2241       } else {
 2242         ret_offset = emit_call_reloc(_masm, $meth$$method,
 2243                                      static_call_Relocation::spec(method_index));
 2244       }
 2245     }
 2246     assert(__ inst_mark() != NULL, &quot;emit_call_reloc must set_inst_mark()&quot;);
 2247 
 2248     if (_method) { // Emit stub for static call.
 2249       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 2250       if (stub == NULL) {
 2251         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2252         return;
 2253       }
 2254     }
 2255   %}
 2256 
 2257   // Java dynamic call
 2258   enc_class z_enc_java_dynamic_call(method meth) %{
<span class="line-modified"> 2259     MacroAssembler _masm(&amp;cbuf);</span>
 2260     unsigned int start_off = __ offset();
 2261 
 2262     int vtable_index = this-&gt;_vtable_index;
 2263     if (vtable_index == -4) {
 2264       Register ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2265       address virtual_call_oop_addr = NULL;
 2266 
 2267       AddressLiteral empty_ic((address) Universe::non_oop_word());
 2268       virtual_call_oop_addr = __ pc();
 2269       bool success = __ load_const_from_toc(ic_reg, empty_ic);
 2270       if (!success) {
 2271         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 2272         return;
 2273       }
 2274 
 2275       // Call to fixup routine. Fixup routine uses ScopeDesc info
 2276       // to determine who we intended to call.
 2277       int method_index = resolved_method_index(cbuf);
 2278       __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
 2279       unsigned int ret_off = __ offset();
</pre>
<hr />
<pre>
 2294 
 2295       if (Displacement::is_validDisp(v_off) ) {
 2296         // Can use load instruction with large offset.
 2297         __ z_lg(Z_method, Address(Z_method /*class oop*/, v_off /*method offset*/));
 2298       } else {
 2299         // Worse case, must load offset into register.
 2300         __ load_const(Z_R1_scratch, v_off);
 2301         __ z_lg(Z_method, Address(Z_method /*class oop*/, Z_R1_scratch /*method offset*/));
 2302       }
 2303       // NOTE: for vtable dispatches, the vtable entry will never be
 2304       // null. However it may very well end up in handle_wrong_method
 2305       // if the method is abstract for the particular class.
 2306       __ z_lg(Z_R1_scratch, Address(Z_method, Method::from_compiled_offset()));
 2307       // Call target. Either compiled code or C2I adapter.
 2308       __ z_basr(Z_R14, Z_R1_scratch);
 2309       unsigned int ret_off = __ offset();
 2310     }
 2311   %}
 2312 
 2313   enc_class z_enc_cmov_reg(cmpOp cmp, iRegI dst, iRegI src) %{
<span class="line-modified"> 2314     MacroAssembler _masm(&amp;cbuf);</span>
 2315     Register Rdst = reg_to_register_object($dst$$reg);
 2316     Register Rsrc = reg_to_register_object($src$$reg);
 2317 
 2318     // Don&#39;t emit code if operands are identical (same register).
 2319     if (Rsrc != Rdst) {
 2320       Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2321 
 2322       if (VM_Version::has_LoadStoreConditional()) {
 2323         __ z_locgr(Rdst, Rsrc, cc);
 2324       } else {
 2325         // Branch if not (cmp cr).
 2326         Label done;
 2327         __ z_brc(Assembler::inverse_condition(cc), done);
 2328         __ z_lgr(Rdst, Rsrc); // Used for int and long+ptr.
 2329         __ bind(done);
 2330       }
 2331     }
 2332   %}
 2333 
 2334   enc_class z_enc_cmov_imm(cmpOp cmp, iRegI dst, immI16 src) %{
<span class="line-modified"> 2335     MacroAssembler _masm(&amp;cbuf);</span>
 2336     Register Rdst = reg_to_register_object($dst$$reg);
 2337     int      Csrc = $src$$constant;
 2338     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2339     Label done;
 2340     // Branch if not (cmp cr).
 2341     __ z_brc(Assembler::inverse_condition(cc), done);
 2342     if (Csrc == 0) {
 2343       // Don&#39;t set CC.
 2344       __ clear_reg(Rdst, true, false);  // Use for int, long &amp; ptr.
 2345     } else {
 2346       __ z_lghi(Rdst, Csrc); // Use for int, long &amp; ptr.
 2347     }
 2348     __ bind(done);
 2349   %}
 2350 
 2351   enc_class z_enc_cctobool(iRegI res) %{
<span class="line-modified"> 2352     MacroAssembler _masm(&amp;cbuf);</span>
 2353     Register Rres = reg_to_register_object($res$$reg);
 2354 
 2355     if (VM_Version::has_LoadStoreConditional()) {
 2356       __ load_const_optimized(Z_R0_scratch, 0L); // false (failed)
 2357       __ load_const_optimized(Rres, 1L);         // true  (succeed)
 2358       __ z_locgr(Rres, Z_R0_scratch, Assembler::bcondNotEqual);
 2359     } else {
 2360       Label done;
 2361       __ load_const_optimized(Rres, 0L); // false (failed)
 2362       __ z_brne(done);                   // Assume true to be the common case.
 2363       __ load_const_optimized(Rres, 1L); // true  (succeed)
 2364       __ bind(done);
 2365     }
 2366   %}
 2367 
 2368   enc_class z_enc_casI(iRegI compare_value, iRegI exchange_value, iRegP addr_ptr) %{
<span class="line-modified"> 2369     MacroAssembler _masm(&amp;cbuf);</span>
 2370     Register Rcomp = reg_to_register_object($compare_value$$reg);
 2371     Register Rnew  = reg_to_register_object($exchange_value$$reg);
 2372     Register Raddr = reg_to_register_object($addr_ptr$$reg);
 2373 
 2374     __ z_cs(Rcomp, Rnew, 0, Raddr);
 2375   %}
 2376 
 2377   enc_class z_enc_casL(iRegL compare_value, iRegL exchange_value, iRegP addr_ptr) %{
<span class="line-modified"> 2378     MacroAssembler _masm(&amp;cbuf);</span>
 2379     Register Rcomp = reg_to_register_object($compare_value$$reg);
 2380     Register Rnew  = reg_to_register_object($exchange_value$$reg);
 2381     Register Raddr = reg_to_register_object($addr_ptr$$reg);
 2382 
 2383     __ z_csg(Rcomp, Rnew, 0, Raddr);
 2384   %}
 2385 
 2386   enc_class z_enc_SwapI(memoryRSY mem, iRegI dst, iRegI tmp) %{
<span class="line-modified"> 2387     MacroAssembler _masm(&amp;cbuf);</span>
 2388     Register Rdst = reg_to_register_object($dst$$reg);
 2389     Register Rtmp = reg_to_register_object($tmp$$reg);
 2390     guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
 2391     Label    retry;
 2392 
 2393     // Iterate until swap succeeds.
 2394     __ z_llgf(Rtmp, $mem$$Address);  // current contents
 2395     __ bind(retry);
 2396       // Calculate incremented value.
 2397       __ z_csy(Rtmp, Rdst, $mem$$Address); // Try to store new value.
 2398       __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
 2399     __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
 2400   %}
 2401 
 2402   enc_class z_enc_SwapL(memoryRSY mem, iRegL dst, iRegL tmp) %{
<span class="line-modified"> 2403     MacroAssembler _masm(&amp;cbuf);</span>
 2404     Register Rdst = reg_to_register_object($dst$$reg);
 2405     Register Rtmp = reg_to_register_object($tmp$$reg);
 2406     guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
 2407     Label    retry;
 2408 
 2409     // Iterate until swap succeeds.
 2410     __ z_lg(Rtmp, $mem$$Address);  // current contents
 2411     __ bind(retry);
 2412       // Calculate incremented value.
 2413       __ z_csg(Rtmp, Rdst, $mem$$Address); // Try to store new value.
 2414       __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
 2415     __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
 2416   %}
 2417 
 2418 %} // encode
 2419 
 2420 source %{
 2421 
 2422   // Check whether outs are all Stores. If so, we can omit clearing the upper
 2423   // 32 bits after encoding.
</pre>
</td>
<td>
<hr />
<pre>
  647 
  648 int CallRuntimeDirectNode::compute_padding(int current_offset) const {
  649   return (12 - current_offset) &amp; 2;
  650 }
  651 
  652 int CallLeafDirectNode::compute_padding(int current_offset) const {
  653   return (12 - current_offset) &amp; 2;
  654 }
  655 
  656 int CallLeafNoFPDirectNode::compute_padding(int current_offset) const {
  657   return (12 - current_offset) &amp; 2;
  658 }
  659 
  660 // Indicate if the safepoint node needs the polling page as an input.
  661 // Since z/Architecture does not have absolute addressing, it does.
  662 bool SafePointNode::needs_polling_address_input() {
  663   return true;
  664 }
  665 
  666 void emit_nop(CodeBuffer &amp;cbuf) {
<span class="line-modified">  667   C2_MacroAssembler _masm(&amp;cbuf);</span>
  668   __ z_nop();
  669 }
  670 
  671 // Emit an interrupt that is caught by the debugger (for debugging compiler).
  672 void emit_break(CodeBuffer &amp;cbuf) {
<span class="line-modified">  673   C2_MacroAssembler _masm(&amp;cbuf);</span>
  674   __ z_illtrap();
  675 }
  676 
  677 #if !defined(PRODUCT)
  678 void MachBreakpointNode::format(PhaseRegAlloc *, outputStream *os) const {
  679   os-&gt;print(&quot;TA&quot;);
  680 }
  681 #endif
  682 
  683 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  684   emit_break(cbuf);
  685 }
  686 
  687 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  688   return MachNode::size(ra_);
  689 }
  690 
  691 static inline void z_emit16(CodeBuffer &amp;cbuf, long value) {
  692   // 32bit instructions may become sign extended.
  693   assert(value &gt;= 0, &quot;unintended sign extension (int-&gt;long)&quot;);
</pre>
<hr />
<pre>
  718     value = (long)((unsigned long)((unsigned int)value));
  719   }
  720 
  721   if (value &lt; (1L &lt;&lt; 16)) { // 2-byte instruction
  722     z_emit16(cbuf, value);
  723     return 2;
  724   }
  725 
  726   if (value &lt; (1L &lt;&lt; 32)) { // 4-byte instruction, might be unaligned store
  727     z_emit32(cbuf, value);
  728     return 4;
  729   }
  730 
  731   // 6-byte instruction, probably unaligned store.
  732   z_emit48(cbuf, value);
  733   return 6;
  734 }
  735 
  736 // Check effective address (at runtime) for required alignment.
  737 static inline void z_assert_aligned(CodeBuffer &amp;cbuf, int disp, Register index, Register base, int alignment) {
<span class="line-modified">  738   C2_MacroAssembler _masm(&amp;cbuf);</span>
  739 
  740   __ z_lay(Z_R0, disp, index, base);
  741   __ z_nill(Z_R0, alignment-1);
  742   __ z_brc(Assembler::bcondEqual, +3);
  743   __ z_illtrap();
  744 }
  745 
<span class="line-modified">  746 int emit_call_reloc(C2_MacroAssembler &amp;_masm, intptr_t entry_point, relocInfo::relocType rtype,</span>
  747                     PhaseRegAlloc* ra_, bool is_native_call = false) {
  748   __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
  749   address old_mark = __ inst_mark();
  750   unsigned int start_off = __ offset();
  751 
  752   if (is_native_call) {
  753     ShouldNotReachHere();
  754   }
  755 
  756   if (rtype == relocInfo::runtime_call_w_cp_type) {
  757     assert((__ offset() &amp; 2) == 0, &quot;misaligned emit_call_reloc&quot;);
  758     address call_addr = __ call_c_opt((address)entry_point);
  759     if (call_addr == NULL) {
  760       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
  761       return -1;
  762     }
  763   } else {
  764     assert(rtype == relocInfo::none || rtype == relocInfo::opt_virtual_call_type ||
  765            rtype == relocInfo::static_call_type, &quot;unexpected rtype&quot;);
  766     __ relocate(rtype);
  767     // BRASL must be prepended with a nop to identify it in the instruction stream.
  768     __ z_nop();
  769     __ z_brasl(Z_R14, (address)entry_point);
  770   }
  771 
  772   unsigned int ret_off = __ offset();
  773 
  774   return (ret_off - start_off);
  775 }
  776 
<span class="line-modified">  777 static int emit_call_reloc(C2_MacroAssembler &amp;_masm, intptr_t entry_point, RelocationHolder const&amp; rspec) {</span>
  778   __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
  779   address old_mark = __ inst_mark();
  780   unsigned int start_off = __ offset();
  781 
  782   relocInfo::relocType rtype = rspec.type();
  783   assert(rtype == relocInfo::opt_virtual_call_type || rtype == relocInfo::static_call_type,
  784          &quot;unexpected rtype&quot;);
  785 
  786   __ relocate(rspec);
  787   __ z_nop();
  788   __ z_brasl(Z_R14, (address)entry_point);
  789 
  790   unsigned int ret_off = __ offset();
  791 
  792   return (ret_off - start_off);
  793 }
  794 
  795 //=============================================================================
  796 
  797 const RegMask&amp; MachConstantBaseNode::_out_RegMask = _Z_PTR_REG_mask;
<span class="line-modified">  798 int ConstantTable::calculate_table_base_offset() const {</span>
  799   return 0;  // absolute addressing, no offset
  800 }
  801 
  802 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  803 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  804   ShouldNotReachHere();
  805 }
  806 
  807 // Even with PC-relative TOC addressing, we still need this node.
  808 // Float loads/stores do not support PC-relative addresses.
  809 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
<span class="line-modified">  810   C2_MacroAssembler _masm(&amp;cbuf);</span>
  811   Register Rtoc = as_Register(ra_-&gt;get_encode(this));
  812   __ load_toc(Rtoc);
  813 }
  814 
  815 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  816   // PCrelative TOC access.
  817   return 6;   // sizeof(LARL)
  818 }
  819 
  820 #if !defined(PRODUCT)
  821 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  822   Register r = as_Register(ra_-&gt;get_encode(this));
  823   st-&gt;print(&quot;LARL    %s,&amp;constant_pool # MachConstantBaseNode&quot;, r-&gt;name());
  824 }
  825 #endif
  826 
  827 //=============================================================================
  828 
  829 #if !defined(PRODUCT)
  830 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
  831   Compile* C = ra_-&gt;C;
  832   st-&gt;print_cr(&quot;--- MachPrologNode ---&quot;);
  833   st-&gt;print(&quot;\t&quot;);
  834   for (int i = 0; i &lt; OptoPrologueNops; i++) {
  835     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
  836   }
  837 
  838   if (VerifyThread) {
  839     st-&gt;print_cr(&quot;Verify_Thread&quot;);
  840     st-&gt;print(&quot;\t&quot;);
  841   }
  842 
<span class="line-modified">  843   long framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  844   int bangsize   = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  845 
  846   // Calls to C2R adapters often do not accept exceptional returns.
  847   // We require that their callers must bang for them. But be
  848   // careful, because some VM calls (such as call site linkage) can
  849   // use several kilobytes of stack. But the stack safety zone should
  850   // account for that. See bugs 4446381, 4468289, 4497237.
<span class="line-modified">  851   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
  852     st-&gt;print_cr(&quot;# stack bang&quot;); st-&gt;print(&quot;\t&quot;);
  853   }
  854   st-&gt;print_cr(&quot;push_frame %d&quot;, (int)-framesize);
  855   st-&gt;print(&quot;\t&quot;);
  856 }
  857 #endif
  858 
  859 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  860   Compile* C = ra_-&gt;C;
<span class="line-modified">  861   C2_MacroAssembler _masm(&amp;cbuf);</span>
  862 
  863   __ verify_thread();
  864 
<span class="line-modified">  865   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  866   size_t bangsize  = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  867 
  868   assert(framesize % wordSize == 0, &quot;must preserve wordSize alignment&quot;);
  869 
  870   if (C-&gt;clinit_barrier_on_entry()) {
  871     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  872 
  873     Label L_skip_barrier;
  874     Register klass = Z_R1_scratch;
  875 
  876     // Notify OOP recorder (don&#39;t need the relocation)
  877     AddressLiteral md = __ constant_metadata_address(C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  878     __ load_const_optimized(klass, md.value());
  879     __ clinit_barrier(klass, Z_thread, &amp;L_skip_barrier /*L_fast_path*/);
  880 
  881     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub());
  882     __ z_br(klass);
  883 
  884     __ bind(L_skip_barrier);
  885   }
  886 
  887   // Calls to C2R adapters often do not accept exceptional returns.
  888   // We require that their callers must bang for them. But be
  889   // careful, because some VM calls (such as call site linkage) can
  890   // use several kilobytes of stack. But the stack safety zone should
  891   // account for that. See bugs 4446381, 4468289, 4497237.
<span class="line-modified">  892   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
  893     __ generate_stack_overflow_check(bangsize);
  894   }
  895 
  896   assert(Immediate::is_uimm32((long)framesize), &quot;to do: choose suitable types!&quot;);
  897   __ save_return_pc();
  898 
  899   // The z/Architecture abi is already accounted for in `framesize&#39; via the
  900   // &#39;out_preserve_stack_slots&#39; declaration.
  901   __ push_frame((unsigned int)framesize/*includes JIT ABI*/);
  902 
  903   if (C-&gt;has_mach_constant_base_node()) {
  904     // NOTE: We set the table base offset here because users might be
  905     // emitted before MachConstantBaseNode.
<span class="line-modified">  906     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
  907     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  908   }
  909 }
  910 
  911 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  912   // Variable size. Determine dynamically.
  913   return MachNode::size(ra_);
  914 }
  915 
  916 int MachPrologNode::reloc() const {
  917   // Return number of relocatable values contained in this instruction.
  918   return 1; // One reloc entry for load_const(toc).
  919 }
  920 
  921 //=============================================================================
  922 
  923 #if !defined(PRODUCT)
  924 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
  925   os-&gt;print_cr(&quot;epilog&quot;);
  926   os-&gt;print(&quot;\t&quot;);
  927   if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
  928     os-&gt;print_cr(&quot;load_from_polling_page Z_R1_scratch&quot;);
  929     os-&gt;print(&quot;\t&quot;);
  930   }
  931 }
  932 #endif
  933 
  934 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">  935   C2_MacroAssembler _masm(&amp;cbuf);</span>
  936   Compile* C = ra_-&gt;C;
  937   __ verify_thread();
  938 
  939   // If this does safepoint polling, then do it here.
  940   bool need_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
  941 
  942   // Pop frame, restore return_pc, and all stuff needed by interpreter.
<span class="line-modified">  943   int frame_size_in_bytes = Assembler::align((C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt), frame::alignment_in_bytes);</span>
  944   __ pop_frame_restore_retPC(frame_size_in_bytes);
  945 
  946   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  947     __ reserved_stack_check(Z_R14);
  948   }
  949 
  950   // Touch the polling page.
  951   if (need_polling) {
  952     if (SafepointMechanism::uses_thread_local_poll()) {
  953       __ z_lg(Z_R1_scratch, Address(Z_thread, Thread::polling_page_offset()));
  954     } else {
  955       AddressLiteral pp(os::get_polling_page());
  956       __ load_const_optimized(Z_R1_scratch, pp);
  957     }
  958     // We need to mark the code position where the load from the safepoint
  959     // polling page was emitted as relocInfo::poll_return_type here.
  960     __ relocate(relocInfo::poll_return_type);
  961     __ load_from_polling_page(Z_R1_scratch);
  962   }
  963 }
</pre>
<hr />
<pre>
 1017   if (cbuf) {
 1018     if (opcode &gt; (1L&lt;&lt;32)) {
 1019       return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 48) |
 1020                          Assembler::simm20(offset) | Assembler::reg(Z_R0, 12, 48) | Assembler::regz(Z_SP, 16, 48));
 1021     } else {
 1022       return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 32) |
 1023                          Assembler::uimm12(offset, 20, 32) | Assembler::reg(Z_R0, 12, 32) | Assembler::regz(Z_SP, 16, 32));
 1024     }
 1025   }
 1026 
 1027 #if !defined(PRODUCT)
 1028   if (do_print) {
 1029     os-&gt;print(&quot;%s    %s,#%d[,SP]\t # MachCopy spill code&quot;,op_str, Matcher::regName[reg], offset);
 1030   }
 1031 #endif
 1032   return (opcode &gt; (1L &lt;&lt; 32)) ? 6 : 4;
 1033 }
 1034 
 1035 static unsigned int z_mvc_helper(CodeBuffer *cbuf, int len, int dst_off, int src_off, bool do_print, outputStream *os) {
 1036   if (cbuf) {
<span class="line-modified"> 1037     C2_MacroAssembler _masm(cbuf);</span>
 1038     __ z_mvc(dst_off, len-1, Z_SP, src_off, Z_SP);
 1039   }
 1040 
 1041 #if !defined(PRODUCT)
 1042   else if (do_print) {
 1043     os-&gt;print(&quot;MVC     %d(%d,SP),%d(SP)\t # MachCopy spill code&quot;,dst_off, len, src_off);
 1044   }
 1045 #endif
 1046 
 1047   return 6;
 1048 }
 1049 
 1050 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *os) const {
 1051   // Get registers to move.
 1052   OptoReg::Name src_hi = ra_-&gt;get_reg_second(in(1));
 1053   OptoReg::Name src_lo = ra_-&gt;get_reg_first(in(1));
 1054   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(this);
 1055   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(this);
 1056 
 1057   enum RC src_hi_rc = rc_class(src_hi);
</pre>
<hr />
<pre>
 1091     }
 1092 
 1093     int r0 = Z_R0_num;
 1094     if (is64) {
 1095       return z_ld_st_helper(cbuf, &quot;LG  &quot;, LG_ZOPC, r0, src_offset, print, os) +
 1096              z_ld_st_helper(cbuf, &quot;STG &quot;, STG_ZOPC, r0, dst_offset, print, os);
 1097     }
 1098 
 1099     return z_ld_st_helper(cbuf, &quot;LY   &quot;, LY_ZOPC, r0, src_offset, print, os) +
 1100            z_ld_st_helper(cbuf, &quot;STY  &quot;, STY_ZOPC, r0, dst_offset, print, os);
 1101   }
 1102 
 1103   // Check for float-&gt;int copy. Requires a trip through memory.
 1104   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
 1105     Unimplemented();  // Unsafe, do not remove!
 1106   }
 1107 
 1108   // Check for integer reg-reg copy.
 1109   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
 1110     if (cbuf) {
<span class="line-modified"> 1111       C2_MacroAssembler _masm(cbuf);</span>
 1112       Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
 1113       Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
 1114       __ z_lgr(Rdst, Rsrc);
 1115       return 4;
 1116     }
 1117 #if !defined(PRODUCT)
 1118     // else
 1119     if (print) {
 1120       os-&gt;print(&quot;LGR     %s,%s\t # MachCopy spill code&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1121     }
 1122 #endif
 1123     return 4;
 1124   }
 1125 
 1126   // Check for integer store.
 1127   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
 1128     assert(!is64 || (src_hi_rc==rc_int &amp;&amp; dst_hi_rc==rc_stack),
 1129            &quot;expected same type of move for high parts&quot;);
 1130 
 1131     if (is64) {
</pre>
<hr />
<pre>
 1138 
 1139     return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);
 1140   }
 1141 
 1142   // Check for integer load
 1143   // Always load cOops zero-extended. That doesn&#39;t hurt int loads.
 1144   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
 1145 
 1146     assert(!is64 || (dst_hi_rc==rc_int &amp;&amp; src_hi_rc==rc_stack),
 1147            &quot;expected same type of move for high parts&quot;);
 1148 
 1149     mnemo = is64 ? &quot;LG  &quot; : &quot;LLGF&quot;;
 1150     opc = is64 ? LG_ZOPC : LLGF_ZOPC;
 1151 
 1152     return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);
 1153   }
 1154 
 1155   // Check for float reg-reg copy.
 1156   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
 1157     if (cbuf) {
<span class="line-modified"> 1158       C2_MacroAssembler _masm(cbuf);</span>
 1159       FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
 1160       FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
 1161       __ z_ldr(Rdst, Rsrc);
 1162       return 2;
 1163     }
 1164 #if !defined(PRODUCT)
 1165     // else
 1166     if (print) {
 1167       os-&gt;print(&quot;LDR      %s,%s\t # MachCopy spill code&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1168     }
 1169 #endif
 1170     return 2;
 1171   }
 1172 
 1173   // Check for float store.
 1174   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
 1175     assert(!is64 || (src_hi_rc==rc_float &amp;&amp; dst_hi_rc==rc_stack),
 1176            &quot;expected same type of move for high parts&quot;);
 1177 
 1178     if (is64) {
</pre>
<hr />
<pre>
 1237 }
 1238 #endif
 1239 
 1240 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1241   implementation(&amp;cbuf, ra_, false, NULL);
 1242 }
 1243 
 1244 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1245   return implementation(NULL, ra_, true, NULL);
 1246 }
 1247 
 1248 //=============================================================================
 1249 
 1250 #if !defined(PRODUCT)
 1251 void MachNopNode::format(PhaseRegAlloc *, outputStream *os) const {
 1252   os-&gt;print(&quot;NOP     # pad for alignment (%d nops, %d bytes)&quot;, _count, _count*MacroAssembler::nop_size());
 1253 }
 1254 #endif
 1255 
 1256 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc * ra_) const {
<span class="line-modified"> 1257   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1258 
 1259   int rem_space = 0;
<span class="line-modified"> 1260   if (!(ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size())) {</span>
 1261     rem_space = cbuf.insts()-&gt;remaining();
 1262     if (rem_space &lt;= _count*2 + 8) {
 1263       tty-&gt;print(&quot;NopNode: _count = %3.3d, remaining space before = %d&quot;, _count, rem_space);
 1264     }
 1265   }
 1266 
 1267   for (int i = 0; i &lt; _count; i++) {
 1268     __ z_nop();
 1269   }
 1270 
<span class="line-modified"> 1271   if (!(ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size())) {</span>
 1272     if (rem_space &lt;= _count*2 + 8) {
 1273       int rem_space2 = cbuf.insts()-&gt;remaining();
 1274       tty-&gt;print_cr(&quot;, after = %d&quot;, rem_space2);
 1275     }
 1276   }
 1277 }
 1278 
 1279 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 1280    return 2 * _count;
 1281 }
 1282 
 1283 #if !defined(PRODUCT)
 1284 void BoxLockNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1285   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1286   if (ra_ &amp;&amp; ra_-&gt;node_regs_max_index() &gt; 0) {
 1287     int reg = ra_-&gt;get_reg_first(this);
 1288     os-&gt;print(&quot;ADDHI  %s, SP, %d\t//box node&quot;, Matcher::regName[reg], offset);
 1289   } else {
 1290     os-&gt;print(&quot;ADDHI  N%d = SP + %d\t// box node&quot;, _idx, offset);
 1291   }
 1292 }
 1293 #endif
 1294 
 1295 // Take care of the size function, if you make changes here!
 1296 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1297   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1298 
 1299   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1300   int reg = ra_-&gt;get_encode(this);
 1301   __ z_lay(as_Register(reg), offset, Z_SP);
 1302 }
 1303 
 1304 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1305   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
 1306   return 6;
 1307 }
 1308 
 1309  %} // end source section
 1310 
 1311 //----------SOURCE BLOCK-------------------------------------------------------
 1312 // This is a block of C++ code which provides values, functions, and
 1313 // definitions necessary in the rest of the architecture description
 1314 
 1315 source_hpp %{
 1316 
 1317 // Header information of the source block.
</pre>
<hr />
<pre>
 1343 
 1344 %} // end source_hpp section
 1345 
 1346 source %{
 1347 
 1348 #if !defined(PRODUCT)
 1349 void MachUEPNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1350   os-&gt;print_cr(&quot;---- MachUEPNode ----&quot;);
 1351   os-&gt;print_cr(&quot;\tTA&quot;);
 1352   os-&gt;print_cr(&quot;\tload_const Z_R1, SharedRuntime::get_ic_miss_stub()&quot;);
 1353   os-&gt;print_cr(&quot;\tBR(Z_R1)&quot;);
 1354   os-&gt;print_cr(&quot;\tTA  # pad with illtraps&quot;);
 1355   os-&gt;print_cr(&quot;\t...&quot;);
 1356   os-&gt;print_cr(&quot;\tTA&quot;);
 1357   os-&gt;print_cr(&quot;\tLTGR    Z_R2, Z_R2&quot;);
 1358   os-&gt;print_cr(&quot;\tBRU     ic_miss&quot;);
 1359 }
 1360 #endif
 1361 
 1362 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1363   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1364   const int ic_miss_offset = 2;
 1365 
 1366   // Inline_cache contains a klass.
 1367   Register ic_klass = as_Register(Matcher::inline_cache_reg_encode());
 1368   // ARG1 is the receiver oop.
 1369   Register R2_receiver = Z_ARG1;
 1370   int      klass_offset = oopDesc::klass_offset_in_bytes();
 1371   AddressLiteral icmiss(SharedRuntime::get_ic_miss_stub());
 1372   Register R1_ic_miss_stub_addr = Z_R1_scratch;
 1373 
 1374   // Null check of receiver.
 1375   // This is the null check of the receiver that actually should be
 1376   // done in the caller. It&#39;s here because in case of implicit null
 1377   // checks we get it for free.
 1378   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()),
 1379          &quot;second word in oop should not require explicit null check.&quot;);
 1380   if (!ImplicitNullChecks) {
 1381     Label valid;
 1382     if (VM_Version::has_CompareBranch()) {
 1383       __ z_cgij(R2_receiver, 0, Assembler::bcondNotEqual, valid);
</pre>
<hr />
<pre>
 1438 source %{
 1439 
 1440 // This exception handler code snippet is placed after the method&#39;s
 1441 // code. It is the return point if an exception occurred. it jumps to
 1442 // the exception blob.
 1443 //
 1444 // If the method gets deoptimized, the method and this code snippet
 1445 // get patched.
 1446 //
 1447 // 1) Trampoline code gets patched into the end of this exception
 1448 //   handler. the trampoline code jumps to the deoptimization blob.
 1449 //
 1450 // 2) The return address in the method&#39;s code will get patched such
 1451 //   that it jumps to the trampoline.
 1452 //
 1453 // 3) The handler will get patched such that it does not jump to the
 1454 //   exception blob, but to an entry in the deoptimization blob being
 1455 //   aware of the exception.
 1456 int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
 1457   Register temp_reg = Z_R1;
<span class="line-modified"> 1458   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1459 
 1460   address base = __ start_a_stub(size_exception_handler());
 1461   if (base == NULL) {
 1462     return 0;          // CodeBuffer::expand failed
 1463   }
 1464 
 1465   int offset = __ offset();
 1466   // Use unconditional pc-relative jump with 32-bit range here.
 1467   __ load_const_optimized(temp_reg, (address)OptoRuntime::exception_blob()-&gt;content_begin());
 1468   __ z_br(temp_reg);
 1469 
 1470   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
 1471 
 1472   __ end_a_stub();
 1473 
 1474   return offset;
 1475 }
 1476 
 1477 // Emit deopt handler code.
 1478 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
<span class="line-modified"> 1479   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1480   address        base = __ start_a_stub(size_deopt_handler());
 1481 
 1482   if (base == NULL) {
 1483     return 0;  // CodeBuffer::expand failed
 1484   }
 1485 
 1486   int offset = __ offset();
 1487 
 1488   // Size_deopt_handler() must be exact on zarch, so for simplicity
 1489   // we do not use load_const_opt here.
 1490   __ load_const(Z_R1, SharedRuntime::deopt_blob()-&gt;unpack());
 1491   __ call(Z_R1);
 1492   assert(__ offset() - offset == (int) size_deopt_handler(), &quot;must be fixed size&quot;);
 1493 
 1494   __ end_a_stub();
 1495   return offset;
 1496 }
 1497 
 1498 //=============================================================================
 1499 
</pre>
<hr />
<pre>
 1824 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER. REG_INTER causes an
 1825 // operand to generate a function which returns its register number when
 1826 // queried. CONST_INTER causes an operand to generate a function which
 1827 // returns the value of the constant when queried. MEMORY_INTER causes an
 1828 // operand to generate four functions which return the Base Register, the
 1829 // Index Register, the Scale Value, and the Offset Value of the operand when
 1830 // queried. COND_INTER causes an operand to generate six functions which
 1831 // return the encoding code (ie - encoding bits for the instruction)
 1832 // associated with each basic boolean condition for a conditional instruction.
 1833 //
 1834 // Instructions specify two basic values for encoding. Again, a function
 1835 // is available to check if the constant displacement is an oop. They use the
 1836 // ins_encode keyword to specify their encoding classes (which must be
 1837 // a sequence of enc_class names, and their parameters, specified in
 1838 // the encoding block), and they use the
 1839 // opcode keyword to specify, in order, their primary, secondary, and
 1840 // tertiary opcode. Only the opcode sections which a particular instruction
 1841 // needs for encoding need to be specified.
 1842 encode %{
 1843   enc_class enc_unimplemented %{
<span class="line-modified"> 1844     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1845     __ unimplemented(&quot;Unimplemented mach node encoding in AD file.&quot;, 13);
 1846   %}
 1847 
 1848   enc_class enc_untested %{
 1849 #ifdef ASSERT
<span class="line-modified"> 1850     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1851     __ untested(&quot;Untested mach node encoding in AD file.&quot;);
 1852 #endif
 1853   %}
 1854 
 1855   enc_class z_rrform(iRegI dst, iRegI src) %{
 1856     assert((($primary &gt;&gt; 14) &amp; 0x03) == 0, &quot;Instruction format error&quot;);
 1857     assert( ($primary &gt;&gt; 16)         == 0, &quot;Instruction format error&quot;);
 1858     z_emit16(cbuf, $primary |
 1859              Assembler::reg($dst$$reg,8,16) |
 1860              Assembler::reg($src$$reg,12,16));
 1861   %}
 1862 
 1863   enc_class z_rreform(iRegI dst1, iRegI src2) %{
 1864     assert((($primary &gt;&gt; 30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1865     z_emit32(cbuf, $primary |
 1866              Assembler::reg($dst1$$reg,24,32) |
 1867              Assembler::reg($src2$$reg,28,32));
 1868   %}
 1869 
 1870   enc_class z_rrfform(iRegI dst1, iRegI src2, iRegI src3) %{
</pre>
<hr />
<pre>
 2016   %}
 2017 
 2018   enc_class z_form_rt_mem_opt(iRegI dst, memory mem) %{
 2019     int isize = $secondary &gt; 1L &lt;&lt; 32 ? 48 : 32;
 2020     Register Ridx = $mem$$index$$Register;
 2021     if (Ridx == noreg) { Ridx = Z_R0; } // Index is 0.
 2022 
 2023     if (Displacement::is_shortDisp((long)$mem$$disp)) {
 2024       z_emit_inst(cbuf, $secondary |
 2025                   Assembler::reg($dst$$reg, 8, isize) |
 2026                   Assembler::uimm12($mem$$disp, 20, isize) |
 2027                   Assembler::reg(Ridx, 12, isize) |
 2028                   Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
 2029     } else if (Displacement::is_validDisp((long)$mem$$disp)) {
 2030       z_emit_inst(cbuf, $primary |
 2031                   Assembler::reg($dst$$reg, 8, 48) |
 2032                   Assembler::simm20($mem$$disp) |
 2033                   Assembler::reg(Ridx, 12, 48) |
 2034                   Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
 2035     } else {
<span class="line-modified"> 2036         C2_MacroAssembler _masm(&amp;cbuf);</span>
 2037         __ load_const_optimized(Z_R1_scratch, $mem$$disp);
 2038         if (Ridx != Z_R0) { __ z_agr(Z_R1_scratch, Ridx); }
 2039         z_emit_inst(cbuf, $secondary |
 2040                     Assembler::reg($dst$$reg, 8, isize) |
 2041                     Assembler::uimm12(0, 20, isize) |
 2042                     Assembler::reg(Z_R1_scratch, 12, isize) |
 2043                     Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
 2044     }
 2045   %}
 2046 
 2047   enc_class z_enc_brul(Label lbl) %{
<span class="line-modified"> 2048     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2049     Label* p = $lbl$$label;
 2050 
 2051     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2052     // determine the size of the encoded instruction.
 2053     // Use a bound dummy label in that case.
 2054     Label d;
 2055     __ bind(d);
 2056     Label&amp; l = (NULL == p) ? d : *(p);
 2057     __ z_brul(l);
 2058   %}
 2059 
 2060   enc_class z_enc_bru(Label lbl) %{
<span class="line-modified"> 2061     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2062     Label* p = $lbl$$label;
 2063 
 2064     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2065     // determine the size of the encoded instruction.
 2066     // Use a bound dummy label in that case.
 2067     Label d;
 2068     __ bind(d);
 2069     Label&amp; l = (NULL == p) ? d : *(p);
 2070     __ z_bru(l);
 2071   %}
 2072 
 2073   enc_class z_enc_branch_con_far(cmpOp cmp, Label lbl) %{
<span class="line-modified"> 2074     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2075     Label* p = $lbl$$label;
 2076 
 2077     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2078     // determine the size of the encoded instruction.
 2079     // Use a bound dummy label in that case.
 2080     Label d;
 2081     __ bind(d);
 2082     Label&amp; l = (NULL == p) ? d : *(p);
 2083     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2084   %}
 2085 
 2086   enc_class z_enc_branch_con_short(cmpOp cmp, Label lbl) %{
<span class="line-modified"> 2087     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2088     Label* p = $lbl$$label;
 2089 
 2090     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2091     // determine the size of the encoded instruction.
 2092     // Use a bound dummy label in that case.
 2093     Label d;
 2094     __ bind(d);
 2095     Label&amp; l = (NULL == p) ? d : *(p);
 2096     __ z_brc((Assembler::branch_condition)$cmp$$cmpcode, l);
 2097   %}
 2098 
 2099   enc_class z_enc_cmpb_regreg(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified"> 2100     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2101     Label* p = $lbl$$label;
 2102 
 2103     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2104     // determine the size of the encoded instruction.
 2105     // Use a bound dummy label in that case.
 2106     Label d;
 2107     __ bind(d);
 2108     Label&amp; l = (NULL == p) ? d : *(p);
 2109     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2110     unsigned long instr = $primary;
 2111     if (instr == CRJ_ZOPC) {
 2112       __ z_crj($src1$$Register, $src2$$Register, cc, l);
 2113     } else if (instr == CLRJ_ZOPC) {
 2114       __ z_clrj($src1$$Register, $src2$$Register, cc, l);
 2115     } else if (instr == CGRJ_ZOPC) {
 2116       __ z_cgrj($src1$$Register, $src2$$Register, cc, l);
 2117     } else {
 2118       guarantee(instr == CLGRJ_ZOPC, &quot;opcode not implemented&quot;);
 2119       __ z_clgrj($src1$$Register, $src2$$Register, cc, l);
 2120     }
 2121   %}
 2122 
 2123   enc_class z_enc_cmpb_regregFar(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified"> 2124     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2125     Label* p = $lbl$$label;
 2126 
 2127     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2128     // determine the size of the encoded instruction.
 2129     // Use a bound dummy label in that case.
 2130     Label d;
 2131     __ bind(d);
 2132     Label&amp; l = (NULL == p) ? d : *(p);
 2133 
 2134     unsigned long instr = $primary;
 2135     if (instr == CR_ZOPC) {
 2136       __ z_cr($src1$$Register, $src2$$Register);
 2137     } else if (instr == CLR_ZOPC) {
 2138       __ z_clr($src1$$Register, $src2$$Register);
 2139     } else if (instr == CGR_ZOPC) {
 2140       __ z_cgr($src1$$Register, $src2$$Register);
 2141     } else {
 2142       guarantee(instr == CLGR_ZOPC, &quot;opcode not implemented&quot;);
 2143       __ z_clgr($src1$$Register, $src2$$Register);
 2144     }
 2145 
 2146     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2147   %}
 2148 
 2149   enc_class z_enc_cmpb_regimm(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified"> 2150     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2151     Label* p = $lbl$$label;
 2152 
 2153     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2154     // determine the size of the encoded instruction.
 2155     // Use a bound dummy label in that case.
 2156     Label d;
 2157     __ bind(d);
 2158     Label&amp; l = (NULL == p) ? d : *(p);
 2159 
 2160     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2161     unsigned long instr = $primary;
 2162     if (instr == CIJ_ZOPC) {
 2163       __ z_cij($src1$$Register, $src2$$constant, cc, l);
 2164     } else if (instr == CLIJ_ZOPC) {
 2165       __ z_clij($src1$$Register, $src2$$constant, cc, l);
 2166     } else if (instr == CGIJ_ZOPC) {
 2167       __ z_cgij($src1$$Register, $src2$$constant, cc, l);
 2168     } else {
 2169       guarantee(instr == CLGIJ_ZOPC, &quot;opcode not implemented&quot;);
 2170       __ z_clgij($src1$$Register, $src2$$constant, cc, l);
 2171     }
 2172   %}
 2173 
 2174   enc_class z_enc_cmpb_regimmFar(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified"> 2175     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2176     Label* p = $lbl$$label;
 2177 
 2178     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2179     // determine the size of the encoded instruction.
 2180     // Use a bound dummy label in that case.
 2181     Label d;
 2182     __ bind(d);
 2183     Label&amp; l = (NULL == p) ? d : *(p);
 2184 
 2185     unsigned long instr = $primary;
 2186     if (instr == CHI_ZOPC) {
 2187       __ z_chi($src1$$Register, $src2$$constant);
 2188     } else if (instr == CLFI_ZOPC) {
 2189       __ z_clfi($src1$$Register, $src2$$constant);
 2190     } else if (instr == CGHI_ZOPC) {
 2191       __ z_cghi($src1$$Register, $src2$$constant);
 2192     } else {
 2193       guarantee(instr == CLGFI_ZOPC, &quot;opcode not implemented&quot;);
 2194       __ z_clgfi($src1$$Register, $src2$$constant);
 2195     }
 2196 
 2197     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2198   %}
 2199 
 2200   // Call from Java to runtime.
 2201   enc_class z_enc_java_to_runtime_call(method meth) %{
<span class="line-modified"> 2202     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2203 
 2204     // Save return pc before call to the place where we need it, since
 2205     // callee doesn&#39;t.
 2206     unsigned int start_off = __ offset();
 2207     // Compute size of &quot;larl + stg + call_c_opt&quot;.
 2208     const int size_of_code = 6 + 6 + MacroAssembler::call_far_patchable_size();
 2209     __ get_PC(Z_R14, size_of_code);
 2210     __ save_return_pc();
 2211     assert(__ offset() - start_off == 12, &quot;bad prelude len: %d&quot;, __ offset() - start_off);
 2212 
 2213     assert((__ offset() &amp; 2) == 0, &quot;misaligned z_enc_java_to_runtime_call&quot;);
 2214     address call_addr = __ call_c_opt((address)$meth$$method);
 2215     if (call_addr == NULL) {
 2216       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 2217       return;
 2218     }
 2219 
 2220 #ifdef ASSERT
 2221     // Plausibility check for size_of_code assumptions.
 2222     unsigned int actual_ret_off = __ offset();
 2223     assert(start_off + size_of_code == actual_ret_off, &quot;wrong return_pc&quot;);
 2224 #endif
 2225   %}
 2226 
 2227   enc_class z_enc_java_static_call(method meth) %{
 2228     // Call to fixup routine. Fixup routine uses ScopeDesc info to determine
 2229     // whom we intended to call.
<span class="line-modified"> 2230     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2231     int ret_offset = 0;
 2232 
 2233     if (!_method) {
 2234       ret_offset = emit_call_reloc(_masm, $meth$$method,
 2235                                    relocInfo::runtime_call_w_cp_type, ra_);
 2236     } else {
 2237       int method_index = resolved_method_index(cbuf);
 2238       if (_optimized_virtual) {
 2239         ret_offset = emit_call_reloc(_masm, $meth$$method,
 2240                                      opt_virtual_call_Relocation::spec(method_index));
 2241       } else {
 2242         ret_offset = emit_call_reloc(_masm, $meth$$method,
 2243                                      static_call_Relocation::spec(method_index));
 2244       }
 2245     }
 2246     assert(__ inst_mark() != NULL, &quot;emit_call_reloc must set_inst_mark()&quot;);
 2247 
 2248     if (_method) { // Emit stub for static call.
 2249       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 2250       if (stub == NULL) {
 2251         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2252         return;
 2253       }
 2254     }
 2255   %}
 2256 
 2257   // Java dynamic call
 2258   enc_class z_enc_java_dynamic_call(method meth) %{
<span class="line-modified"> 2259     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2260     unsigned int start_off = __ offset();
 2261 
 2262     int vtable_index = this-&gt;_vtable_index;
 2263     if (vtable_index == -4) {
 2264       Register ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2265       address virtual_call_oop_addr = NULL;
 2266 
 2267       AddressLiteral empty_ic((address) Universe::non_oop_word());
 2268       virtual_call_oop_addr = __ pc();
 2269       bool success = __ load_const_from_toc(ic_reg, empty_ic);
 2270       if (!success) {
 2271         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 2272         return;
 2273       }
 2274 
 2275       // Call to fixup routine. Fixup routine uses ScopeDesc info
 2276       // to determine who we intended to call.
 2277       int method_index = resolved_method_index(cbuf);
 2278       __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
 2279       unsigned int ret_off = __ offset();
</pre>
<hr />
<pre>
 2294 
 2295       if (Displacement::is_validDisp(v_off) ) {
 2296         // Can use load instruction with large offset.
 2297         __ z_lg(Z_method, Address(Z_method /*class oop*/, v_off /*method offset*/));
 2298       } else {
 2299         // Worse case, must load offset into register.
 2300         __ load_const(Z_R1_scratch, v_off);
 2301         __ z_lg(Z_method, Address(Z_method /*class oop*/, Z_R1_scratch /*method offset*/));
 2302       }
 2303       // NOTE: for vtable dispatches, the vtable entry will never be
 2304       // null. However it may very well end up in handle_wrong_method
 2305       // if the method is abstract for the particular class.
 2306       __ z_lg(Z_R1_scratch, Address(Z_method, Method::from_compiled_offset()));
 2307       // Call target. Either compiled code or C2I adapter.
 2308       __ z_basr(Z_R14, Z_R1_scratch);
 2309       unsigned int ret_off = __ offset();
 2310     }
 2311   %}
 2312 
 2313   enc_class z_enc_cmov_reg(cmpOp cmp, iRegI dst, iRegI src) %{
<span class="line-modified"> 2314     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2315     Register Rdst = reg_to_register_object($dst$$reg);
 2316     Register Rsrc = reg_to_register_object($src$$reg);
 2317 
 2318     // Don&#39;t emit code if operands are identical (same register).
 2319     if (Rsrc != Rdst) {
 2320       Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2321 
 2322       if (VM_Version::has_LoadStoreConditional()) {
 2323         __ z_locgr(Rdst, Rsrc, cc);
 2324       } else {
 2325         // Branch if not (cmp cr).
 2326         Label done;
 2327         __ z_brc(Assembler::inverse_condition(cc), done);
 2328         __ z_lgr(Rdst, Rsrc); // Used for int and long+ptr.
 2329         __ bind(done);
 2330       }
 2331     }
 2332   %}
 2333 
 2334   enc_class z_enc_cmov_imm(cmpOp cmp, iRegI dst, immI16 src) %{
<span class="line-modified"> 2335     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2336     Register Rdst = reg_to_register_object($dst$$reg);
 2337     int      Csrc = $src$$constant;
 2338     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2339     Label done;
 2340     // Branch if not (cmp cr).
 2341     __ z_brc(Assembler::inverse_condition(cc), done);
 2342     if (Csrc == 0) {
 2343       // Don&#39;t set CC.
 2344       __ clear_reg(Rdst, true, false);  // Use for int, long &amp; ptr.
 2345     } else {
 2346       __ z_lghi(Rdst, Csrc); // Use for int, long &amp; ptr.
 2347     }
 2348     __ bind(done);
 2349   %}
 2350 
 2351   enc_class z_enc_cctobool(iRegI res) %{
<span class="line-modified"> 2352     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2353     Register Rres = reg_to_register_object($res$$reg);
 2354 
 2355     if (VM_Version::has_LoadStoreConditional()) {
 2356       __ load_const_optimized(Z_R0_scratch, 0L); // false (failed)
 2357       __ load_const_optimized(Rres, 1L);         // true  (succeed)
 2358       __ z_locgr(Rres, Z_R0_scratch, Assembler::bcondNotEqual);
 2359     } else {
 2360       Label done;
 2361       __ load_const_optimized(Rres, 0L); // false (failed)
 2362       __ z_brne(done);                   // Assume true to be the common case.
 2363       __ load_const_optimized(Rres, 1L); // true  (succeed)
 2364       __ bind(done);
 2365     }
 2366   %}
 2367 
 2368   enc_class z_enc_casI(iRegI compare_value, iRegI exchange_value, iRegP addr_ptr) %{
<span class="line-modified"> 2369     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2370     Register Rcomp = reg_to_register_object($compare_value$$reg);
 2371     Register Rnew  = reg_to_register_object($exchange_value$$reg);
 2372     Register Raddr = reg_to_register_object($addr_ptr$$reg);
 2373 
 2374     __ z_cs(Rcomp, Rnew, 0, Raddr);
 2375   %}
 2376 
 2377   enc_class z_enc_casL(iRegL compare_value, iRegL exchange_value, iRegP addr_ptr) %{
<span class="line-modified"> 2378     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2379     Register Rcomp = reg_to_register_object($compare_value$$reg);
 2380     Register Rnew  = reg_to_register_object($exchange_value$$reg);
 2381     Register Raddr = reg_to_register_object($addr_ptr$$reg);
 2382 
 2383     __ z_csg(Rcomp, Rnew, 0, Raddr);
 2384   %}
 2385 
 2386   enc_class z_enc_SwapI(memoryRSY mem, iRegI dst, iRegI tmp) %{
<span class="line-modified"> 2387     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2388     Register Rdst = reg_to_register_object($dst$$reg);
 2389     Register Rtmp = reg_to_register_object($tmp$$reg);
 2390     guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
 2391     Label    retry;
 2392 
 2393     // Iterate until swap succeeds.
 2394     __ z_llgf(Rtmp, $mem$$Address);  // current contents
 2395     __ bind(retry);
 2396       // Calculate incremented value.
 2397       __ z_csy(Rtmp, Rdst, $mem$$Address); // Try to store new value.
 2398       __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
 2399     __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
 2400   %}
 2401 
 2402   enc_class z_enc_SwapL(memoryRSY mem, iRegL dst, iRegL tmp) %{
<span class="line-modified"> 2403     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2404     Register Rdst = reg_to_register_object($dst$$reg);
 2405     Register Rtmp = reg_to_register_object($tmp$$reg);
 2406     guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
 2407     Label    retry;
 2408 
 2409     // Iterate until swap succeeds.
 2410     __ z_lg(Rtmp, $mem$$Address);  // current contents
 2411     __ bind(retry);
 2412       // Calculate incremented value.
 2413       __ z_csg(Rtmp, Rdst, $mem$$Address); // Try to store new value.
 2414       __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
 2415     __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
 2416   %}
 2417 
 2418 %} // encode
 2419 
 2420 source %{
 2421 
 2422   // Check whether outs are all Stores. If so, we can omit clearing the upper
 2423   // 32 bits after encoding.
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_s390.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../sparc/interp_masm_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
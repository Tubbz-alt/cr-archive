<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/s390/s390.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_s390.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../sparc/interp_masm_sparc.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/s390.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 662,17 ***</span>
  bool SafePointNode::needs_polling_address_input() {
    return true;
  }
  
  void emit_nop(CodeBuffer &amp;cbuf) {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    __ z_nop();
  }
  
  // Emit an interrupt that is caught by the debugger (for debugging compiler).
  void emit_break(CodeBuffer &amp;cbuf) {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    __ z_illtrap();
  }
  
  #if !defined(PRODUCT)
  void MachBreakpointNode::format(PhaseRegAlloc *, outputStream *os) const {
<span class="line-new-header">--- 662,17 ---</span>
  bool SafePointNode::needs_polling_address_input() {
    return true;
  }
  
  void emit_nop(CodeBuffer &amp;cbuf) {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    __ z_nop();
  }
  
  // Emit an interrupt that is caught by the debugger (for debugging compiler).
  void emit_break(CodeBuffer &amp;cbuf) {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    __ z_illtrap();
  }
  
  #if !defined(PRODUCT)
  void MachBreakpointNode::format(PhaseRegAlloc *, outputStream *os) const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 733,19 ***</span>
    return 6;
  }
  
  // Check effective address (at runtime) for required alignment.
  static inline void z_assert_aligned(CodeBuffer &amp;cbuf, int disp, Register index, Register base, int alignment) {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
  
    __ z_lay(Z_R0, disp, index, base);
    __ z_nill(Z_R0, alignment-1);
    __ z_brc(Assembler::bcondEqual, +3);
    __ z_illtrap();
  }
  
<span class="line-modified">! int emit_call_reloc(MacroAssembler &amp;_masm, intptr_t entry_point, relocInfo::relocType rtype,</span>
                      PhaseRegAlloc* ra_, bool is_native_call = false) {
    __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
    address old_mark = __ inst_mark();
    unsigned int start_off = __ offset();
  
<span class="line-new-header">--- 733,19 ---</span>
    return 6;
  }
  
  // Check effective address (at runtime) for required alignment.
  static inline void z_assert_aligned(CodeBuffer &amp;cbuf, int disp, Register index, Register base, int alignment) {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    __ z_lay(Z_R0, disp, index, base);
    __ z_nill(Z_R0, alignment-1);
    __ z_brc(Assembler::bcondEqual, +3);
    __ z_illtrap();
  }
  
<span class="line-modified">! int emit_call_reloc(C2_MacroAssembler &amp;_masm, intptr_t entry_point, relocInfo::relocType rtype,</span>
                      PhaseRegAlloc* ra_, bool is_native_call = false) {
    __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
    address old_mark = __ inst_mark();
    unsigned int start_off = __ offset();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 772,11 ***</span>
    unsigned int ret_off = __ offset();
  
    return (ret_off - start_off);
  }
  
<span class="line-modified">! static int emit_call_reloc(MacroAssembler &amp;_masm, intptr_t entry_point, RelocationHolder const&amp; rspec) {</span>
    __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
    address old_mark = __ inst_mark();
    unsigned int start_off = __ offset();
  
    relocInfo::relocType rtype = rspec.type();
<span class="line-new-header">--- 772,11 ---</span>
    unsigned int ret_off = __ offset();
  
    return (ret_off - start_off);
  }
  
<span class="line-modified">! static int emit_call_reloc(C2_MacroAssembler &amp;_masm, intptr_t entry_point, RelocationHolder const&amp; rspec) {</span>
    __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
    address old_mark = __ inst_mark();
    unsigned int start_off = __ offset();
  
    relocInfo::relocType rtype = rspec.type();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 793,11 ***</span>
  }
  
  //=============================================================================
  
  const RegMask&amp; MachConstantBaseNode::_out_RegMask = _Z_PTR_REG_mask;
<span class="line-modified">! int Compile::ConstantTable::calculate_table_base_offset() const {</span>
    return 0;  // absolute addressing, no offset
  }
  
  bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
<span class="line-new-header">--- 793,11 ---</span>
  }
  
  //=============================================================================
  
  const RegMask&amp; MachConstantBaseNode::_out_RegMask = _Z_PTR_REG_mask;
<span class="line-modified">! int ConstantTable::calculate_table_base_offset() const {</span>
    return 0;  // absolute addressing, no offset
  }
  
  bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 805,11 ***</span>
  }
  
  // Even with PC-relative TOC addressing, we still need this node.
  // Float loads/stores do not support PC-relative addresses.
  void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    Register Rtoc = as_Register(ra_-&gt;get_encode(this));
    __ load_toc(Rtoc);
  }
  
  uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
<span class="line-new-header">--- 805,11 ---</span>
  }
  
  // Even with PC-relative TOC addressing, we still need this node.
  // Float loads/stores do not support PC-relative addresses.
  void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    Register Rtoc = as_Register(ra_-&gt;get_encode(this));
    __ load_toc(Rtoc);
  }
  
  uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 838,34 ***</span>
    if (VerifyThread) {
      st-&gt;print_cr(&quot;Verify_Thread&quot;);
      st-&gt;print(&quot;\t&quot;);
    }
  
<span class="line-modified">!   long framesize = C-&gt;frame_size_in_bytes();</span>
<span class="line-modified">!   int bangsize   = C-&gt;bang_size_in_bytes();</span>
  
    // Calls to C2R adapters often do not accept exceptional returns.
    // We require that their callers must bang for them. But be
    // careful, because some VM calls (such as call site linkage) can
    // use several kilobytes of stack. But the stack safety zone should
    // account for that. See bugs 4446381, 4468289, 4497237.
<span class="line-modified">!   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
      st-&gt;print_cr(&quot;# stack bang&quot;); st-&gt;print(&quot;\t&quot;);
    }
    st-&gt;print_cr(&quot;push_frame %d&quot;, (int)-framesize);
    st-&gt;print(&quot;\t&quot;);
  }
  #endif
  
  void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
    Compile* C = ra_-&gt;C;
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
  
    __ verify_thread();
  
<span class="line-modified">!   size_t framesize = C-&gt;frame_size_in_bytes();</span>
<span class="line-modified">!   size_t bangsize  = C-&gt;bang_size_in_bytes();</span>
  
    assert(framesize % wordSize == 0, &quot;must preserve wordSize alignment&quot;);
  
    if (C-&gt;clinit_barrier_on_entry()) {
      assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
<span class="line-new-header">--- 838,34 ---</span>
    if (VerifyThread) {
      st-&gt;print_cr(&quot;Verify_Thread&quot;);
      st-&gt;print(&quot;\t&quot;);
    }
  
<span class="line-modified">!   long framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified">!   int bangsize   = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  
    // Calls to C2R adapters often do not accept exceptional returns.
    // We require that their callers must bang for them. But be
    // careful, because some VM calls (such as call site linkage) can
    // use several kilobytes of stack. But the stack safety zone should
    // account for that. See bugs 4446381, 4468289, 4497237.
<span class="line-modified">!   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
      st-&gt;print_cr(&quot;# stack bang&quot;); st-&gt;print(&quot;\t&quot;);
    }
    st-&gt;print_cr(&quot;push_frame %d&quot;, (int)-framesize);
    st-&gt;print(&quot;\t&quot;);
  }
  #endif
  
  void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
    Compile* C = ra_-&gt;C;
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    __ verify_thread();
  
<span class="line-modified">!   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified">!   size_t bangsize  = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  
    assert(framesize % wordSize == 0, &quot;must preserve wordSize alignment&quot;);
  
    if (C-&gt;clinit_barrier_on_entry()) {
      assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 887,11 ***</span>
    // Calls to C2R adapters often do not accept exceptional returns.
    // We require that their callers must bang for them. But be
    // careful, because some VM calls (such as call site linkage) can
    // use several kilobytes of stack. But the stack safety zone should
    // account for that. See bugs 4446381, 4468289, 4497237.
<span class="line-modified">!   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
      __ generate_stack_overflow_check(bangsize);
    }
  
    assert(Immediate::is_uimm32((long)framesize), &quot;to do: choose suitable types!&quot;);
    __ save_return_pc();
<span class="line-new-header">--- 887,11 ---</span>
    // Calls to C2R adapters often do not accept exceptional returns.
    // We require that their callers must bang for them. But be
    // careful, because some VM calls (such as call site linkage) can
    // use several kilobytes of stack. But the stack safety zone should
    // account for that. See bugs 4446381, 4468289, 4497237.
<span class="line-modified">!   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
      __ generate_stack_overflow_check(bangsize);
    }
  
    assert(Immediate::is_uimm32((long)framesize), &quot;to do: choose suitable types!&quot;);
    __ save_return_pc();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 901,11 ***</span>
    __ push_frame((unsigned int)framesize/*includes JIT ABI*/);
  
    if (C-&gt;has_mach_constant_base_node()) {
      // NOTE: We set the table base offset here because users might be
      // emitted before MachConstantBaseNode.
<span class="line-modified">!     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
      constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
    }
  }
  
  uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
<span class="line-new-header">--- 901,11 ---</span>
    __ push_frame((unsigned int)framesize/*includes JIT ABI*/);
  
    if (C-&gt;has_mach_constant_base_node()) {
      // NOTE: We set the table base offset here because users might be
      // emitted before MachConstantBaseNode.
<span class="line-modified">!     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
      constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
    }
  }
  
  uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 930,19 ***</span>
    }
  }
  #endif
  
  void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    Compile* C = ra_-&gt;C;
    __ verify_thread();
  
    // If this does safepoint polling, then do it here.
    bool need_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
  
    // Pop frame, restore return_pc, and all stuff needed by interpreter.
<span class="line-modified">!   int frame_size_in_bytes = Assembler::align((C-&gt;frame_slots() &lt;&lt; LogBytesPerInt), frame::alignment_in_bytes);</span>
    __ pop_frame_restore_retPC(frame_size_in_bytes);
  
    if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
      __ reserved_stack_check(Z_R14);
    }
<span class="line-new-header">--- 930,19 ---</span>
    }
  }
  #endif
  
  void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    Compile* C = ra_-&gt;C;
    __ verify_thread();
  
    // If this does safepoint polling, then do it here.
    bool need_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
  
    // Pop frame, restore return_pc, and all stuff needed by interpreter.
<span class="line-modified">!   int frame_size_in_bytes = Assembler::align((C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt), frame::alignment_in_bytes);</span>
    __ pop_frame_restore_retPC(frame_size_in_bytes);
  
    if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
      __ reserved_stack_check(Z_R14);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1032,11 ***</span>
    return (opcode &gt; (1L &lt;&lt; 32)) ? 6 : 4;
  }
  
  static unsigned int z_mvc_helper(CodeBuffer *cbuf, int len, int dst_off, int src_off, bool do_print, outputStream *os) {
    if (cbuf) {
<span class="line-modified">!     MacroAssembler _masm(cbuf);</span>
      __ z_mvc(dst_off, len-1, Z_SP, src_off, Z_SP);
    }
  
  #if !defined(PRODUCT)
    else if (do_print) {
<span class="line-new-header">--- 1032,11 ---</span>
    return (opcode &gt; (1L &lt;&lt; 32)) ? 6 : 4;
  }
  
  static unsigned int z_mvc_helper(CodeBuffer *cbuf, int len, int dst_off, int src_off, bool do_print, outputStream *os) {
    if (cbuf) {
<span class="line-modified">!     C2_MacroAssembler _masm(cbuf);</span>
      __ z_mvc(dst_off, len-1, Z_SP, src_off, Z_SP);
    }
  
  #if !defined(PRODUCT)
    else if (do_print) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1106,11 ***</span>
    }
  
    // Check for integer reg-reg copy.
    if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
      if (cbuf) {
<span class="line-modified">!       MacroAssembler _masm(cbuf);</span>
        Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
        Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
        __ z_lgr(Rdst, Rsrc);
        return 4;
      }
<span class="line-new-header">--- 1106,11 ---</span>
    }
  
    // Check for integer reg-reg copy.
    if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
      if (cbuf) {
<span class="line-modified">!       C2_MacroAssembler _masm(cbuf);</span>
        Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
        Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
        __ z_lgr(Rdst, Rsrc);
        return 4;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1153,11 ***</span>
    }
  
    // Check for float reg-reg copy.
    if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
      if (cbuf) {
<span class="line-modified">!       MacroAssembler _masm(cbuf);</span>
        FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
        FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
        __ z_ldr(Rdst, Rsrc);
        return 2;
      }
<span class="line-new-header">--- 1153,11 ---</span>
    }
  
    // Check for float reg-reg copy.
    if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
      if (cbuf) {
<span class="line-modified">!       C2_MacroAssembler _masm(cbuf);</span>
        FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
        FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
        __ z_ldr(Rdst, Rsrc);
        return 2;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1252,25 ***</span>
    os-&gt;print(&quot;NOP     # pad for alignment (%d nops, %d bytes)&quot;, _count, _count*MacroAssembler::nop_size());
  }
  #endif
  
  void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc * ra_) const {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
  
    int rem_space = 0;
<span class="line-modified">!   if (!(ra_-&gt;C-&gt;in_scratch_emit_size())) {</span>
      rem_space = cbuf.insts()-&gt;remaining();
      if (rem_space &lt;= _count*2 + 8) {
        tty-&gt;print(&quot;NopNode: _count = %3.3d, remaining space before = %d&quot;, _count, rem_space);
      }
    }
  
    for (int i = 0; i &lt; _count; i++) {
      __ z_nop();
    }
  
<span class="line-modified">!   if (!(ra_-&gt;C-&gt;in_scratch_emit_size())) {</span>
      if (rem_space &lt;= _count*2 + 8) {
        int rem_space2 = cbuf.insts()-&gt;remaining();
        tty-&gt;print_cr(&quot;, after = %d&quot;, rem_space2);
      }
    }
<span class="line-new-header">--- 1252,25 ---</span>
    os-&gt;print(&quot;NOP     # pad for alignment (%d nops, %d bytes)&quot;, _count, _count*MacroAssembler::nop_size());
  }
  #endif
  
  void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc * ra_) const {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    int rem_space = 0;
<span class="line-modified">!   if (!(ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size())) {</span>
      rem_space = cbuf.insts()-&gt;remaining();
      if (rem_space &lt;= _count*2 + 8) {
        tty-&gt;print(&quot;NopNode: _count = %3.3d, remaining space before = %d&quot;, _count, rem_space);
      }
    }
  
    for (int i = 0; i &lt; _count; i++) {
      __ z_nop();
    }
  
<span class="line-modified">!   if (!(ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size())) {</span>
      if (rem_space &lt;= _count*2 + 8) {
        int rem_space2 = cbuf.insts()-&gt;remaining();
        tty-&gt;print_cr(&quot;, after = %d&quot;, rem_space2);
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1292,11 ***</span>
  }
  #endif
  
  // Take care of the size function, if you make changes here!
  void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
  
    int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
    int reg = ra_-&gt;get_encode(this);
    __ z_lay(as_Register(reg), offset, Z_SP);
  }
<span class="line-new-header">--- 1292,11 ---</span>
  }
  #endif
  
  // Take care of the size function, if you make changes here!
  void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
    int reg = ra_-&gt;get_encode(this);
    __ z_lay(as_Register(reg), offset, Z_SP);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1358,11 ***</span>
    os-&gt;print_cr(&quot;\tBRU     ic_miss&quot;);
  }
  #endif
  
  void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    const int ic_miss_offset = 2;
  
    // Inline_cache contains a klass.
    Register ic_klass = as_Register(Matcher::inline_cache_reg_encode());
    // ARG1 is the receiver oop.
<span class="line-new-header">--- 1358,11 ---</span>
    os-&gt;print_cr(&quot;\tBRU     ic_miss&quot;);
  }
  #endif
  
  void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    const int ic_miss_offset = 2;
  
    // Inline_cache contains a klass.
    Register ic_klass = as_Register(Matcher::inline_cache_reg_encode());
    // ARG1 is the receiver oop.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1453,11 ***</span>
  // 3) The handler will get patched such that it does not jump to the
  //   exception blob, but to an entry in the deoptimization blob being
  //   aware of the exception.
  int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
    Register temp_reg = Z_R1;
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
  
    address base = __ start_a_stub(size_exception_handler());
    if (base == NULL) {
      return 0;          // CodeBuffer::expand failed
    }
<span class="line-new-header">--- 1453,11 ---</span>
  // 3) The handler will get patched such that it does not jump to the
  //   exception blob, but to an entry in the deoptimization blob being
  //   aware of the exception.
  int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
    Register temp_reg = Z_R1;
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    address base = __ start_a_stub(size_exception_handler());
    if (base == NULL) {
      return 0;          // CodeBuffer::expand failed
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1474,11 ***</span>
    return offset;
  }
  
  // Emit deopt handler code.
  int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    address        base = __ start_a_stub(size_deopt_handler());
  
    if (base == NULL) {
      return 0;  // CodeBuffer::expand failed
    }
<span class="line-new-header">--- 1474,11 ---</span>
    return offset;
  }
  
  // Emit deopt handler code.
  int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    address        base = __ start_a_stub(size_deopt_handler());
  
    if (base == NULL) {
      return 0;  // CodeBuffer::expand failed
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1839,17 ***</span>
  // opcode keyword to specify, in order, their primary, secondary, and
  // tertiary opcode. Only the opcode sections which a particular instruction
  // needs for encoding need to be specified.
  encode %{
    enc_class enc_unimplemented %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ unimplemented(&quot;Unimplemented mach node encoding in AD file.&quot;, 13);
    %}
  
    enc_class enc_untested %{
  #ifdef ASSERT
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ untested(&quot;Untested mach node encoding in AD file.&quot;);
  #endif
    %}
  
    enc_class z_rrform(iRegI dst, iRegI src) %{
<span class="line-new-header">--- 1839,17 ---</span>
  // opcode keyword to specify, in order, their primary, secondary, and
  // tertiary opcode. Only the opcode sections which a particular instruction
  // needs for encoding need to be specified.
  encode %{
    enc_class enc_unimplemented %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ unimplemented(&quot;Unimplemented mach node encoding in AD file.&quot;, 13);
    %}
  
    enc_class enc_untested %{
  #ifdef ASSERT
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ untested(&quot;Untested mach node encoding in AD file.&quot;);
  #endif
    %}
  
    enc_class z_rrform(iRegI dst, iRegI src) %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2031,11 ***</span>
                    Assembler::reg($dst$$reg, 8, 48) |
                    Assembler::simm20($mem$$disp) |
                    Assembler::reg(Ridx, 12, 48) |
                    Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
      } else {
<span class="line-modified">!         MacroAssembler _masm(&amp;cbuf);</span>
          __ load_const_optimized(Z_R1_scratch, $mem$$disp);
          if (Ridx != Z_R0) { __ z_agr(Z_R1_scratch, Ridx); }
          z_emit_inst(cbuf, $secondary |
                      Assembler::reg($dst$$reg, 8, isize) |
                      Assembler::uimm12(0, 20, isize) |
<span class="line-new-header">--- 2031,11 ---</span>
                    Assembler::reg($dst$$reg, 8, 48) |
                    Assembler::simm20($mem$$disp) |
                    Assembler::reg(Ridx, 12, 48) |
                    Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
      } else {
<span class="line-modified">!         C2_MacroAssembler _masm(&amp;cbuf);</span>
          __ load_const_optimized(Z_R1_scratch, $mem$$disp);
          if (Ridx != Z_R0) { __ z_agr(Z_R1_scratch, Ridx); }
          z_emit_inst(cbuf, $secondary |
                      Assembler::reg($dst$$reg, 8, isize) |
                      Assembler::uimm12(0, 20, isize) |
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2043,11 ***</span>
                      Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
      }
    %}
  
    enc_class z_enc_brul(Label lbl) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
<span class="line-new-header">--- 2043,11 ---</span>
                      Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
      }
    %}
  
    enc_class z_enc_brul(Label lbl) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2056,11 ***</span>
      Label&amp; l = (NULL == p) ? d : *(p);
      __ z_brul(l);
    %}
  
    enc_class z_enc_bru(Label lbl) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
<span class="line-new-header">--- 2056,11 ---</span>
      Label&amp; l = (NULL == p) ? d : *(p);
      __ z_brul(l);
    %}
  
    enc_class z_enc_bru(Label lbl) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2069,11 ***</span>
      Label&amp; l = (NULL == p) ? d : *(p);
      __ z_bru(l);
    %}
  
    enc_class z_enc_branch_con_far(cmpOp cmp, Label lbl) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
<span class="line-new-header">--- 2069,11 ---</span>
      Label&amp; l = (NULL == p) ? d : *(p);
      __ z_bru(l);
    %}
  
    enc_class z_enc_branch_con_far(cmpOp cmp, Label lbl) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2082,11 ***</span>
      Label&amp; l = (NULL == p) ? d : *(p);
      __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
    %}
  
    enc_class z_enc_branch_con_short(cmpOp cmp, Label lbl) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
<span class="line-new-header">--- 2082,11 ---</span>
      Label&amp; l = (NULL == p) ? d : *(p);
      __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
    %}
  
    enc_class z_enc_branch_con_short(cmpOp cmp, Label lbl) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2095,11 ***</span>
      Label&amp; l = (NULL == p) ? d : *(p);
      __ z_brc((Assembler::branch_condition)$cmp$$cmpcode, l);
    %}
  
    enc_class z_enc_cmpb_regreg(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
<span class="line-new-header">--- 2095,11 ---</span>
      Label&amp; l = (NULL == p) ? d : *(p);
      __ z_brc((Assembler::branch_condition)$cmp$$cmpcode, l);
    %}
  
    enc_class z_enc_cmpb_regreg(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2119,11 ***</span>
        __ z_clgrj($src1$$Register, $src2$$Register, cc, l);
      }
    %}
  
    enc_class z_enc_cmpb_regregFar(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
<span class="line-new-header">--- 2119,11 ---</span>
        __ z_clgrj($src1$$Register, $src2$$Register, cc, l);
      }
    %}
  
    enc_class z_enc_cmpb_regregFar(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2145,11 ***</span>
  
      __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
    %}
  
    enc_class z_enc_cmpb_regimm(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
<span class="line-new-header">--- 2145,11 ---</span>
  
      __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
    %}
  
    enc_class z_enc_cmpb_regimm(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2170,11 ***</span>
        __ z_clgij($src1$$Register, $src2$$constant, cc, l);
      }
    %}
  
    enc_class z_enc_cmpb_regimmFar(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
<span class="line-new-header">--- 2170,11 ---</span>
        __ z_clgij($src1$$Register, $src2$$constant, cc, l);
      }
    %}
  
    enc_class z_enc_cmpb_regimmFar(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2197,11 ***</span>
      __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
    %}
  
    // Call from Java to runtime.
    enc_class z_enc_java_to_runtime_call(method meth) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
  
      // Save return pc before call to the place where we need it, since
      // callee doesn&#39;t.
      unsigned int start_off = __ offset();
      // Compute size of &quot;larl + stg + call_c_opt&quot;.
<span class="line-new-header">--- 2197,11 ---</span>
      __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
    %}
  
    // Call from Java to runtime.
    enc_class z_enc_java_to_runtime_call(method meth) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      // Save return pc before call to the place where we need it, since
      // callee doesn&#39;t.
      unsigned int start_off = __ offset();
      // Compute size of &quot;larl + stg + call_c_opt&quot;.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2225,11 ***</span>
    %}
  
    enc_class z_enc_java_static_call(method meth) %{
      // Call to fixup routine. Fixup routine uses ScopeDesc info to determine
      // whom we intended to call.
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      int ret_offset = 0;
  
      if (!_method) {
        ret_offset = emit_call_reloc(_masm, $meth$$method,
                                     relocInfo::runtime_call_w_cp_type, ra_);
<span class="line-new-header">--- 2225,11 ---</span>
    %}
  
    enc_class z_enc_java_static_call(method meth) %{
      // Call to fixup routine. Fixup routine uses ScopeDesc info to determine
      // whom we intended to call.
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int ret_offset = 0;
  
      if (!_method) {
        ret_offset = emit_call_reloc(_masm, $meth$$method,
                                     relocInfo::runtime_call_w_cp_type, ra_);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2254,11 ***</span>
      }
    %}
  
    // Java dynamic call
    enc_class z_enc_java_dynamic_call(method meth) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      unsigned int start_off = __ offset();
  
      int vtable_index = this-&gt;_vtable_index;
      if (vtable_index == -4) {
        Register ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
<span class="line-new-header">--- 2254,11 ---</span>
      }
    %}
  
    // Java dynamic call
    enc_class z_enc_java_dynamic_call(method meth) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      unsigned int start_off = __ offset();
  
      int vtable_index = this-&gt;_vtable_index;
      if (vtable_index == -4) {
        Register ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2309,11 ***</span>
        unsigned int ret_off = __ offset();
      }
    %}
  
    enc_class z_enc_cmov_reg(cmpOp cmp, iRegI dst, iRegI src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register Rdst = reg_to_register_object($dst$$reg);
      Register Rsrc = reg_to_register_object($src$$reg);
  
      // Don&#39;t emit code if operands are identical (same register).
      if (Rsrc != Rdst) {
<span class="line-new-header">--- 2309,11 ---</span>
        unsigned int ret_off = __ offset();
      }
    %}
  
    enc_class z_enc_cmov_reg(cmpOp cmp, iRegI dst, iRegI src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register Rdst = reg_to_register_object($dst$$reg);
      Register Rsrc = reg_to_register_object($src$$reg);
  
      // Don&#39;t emit code if operands are identical (same register).
      if (Rsrc != Rdst) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2330,11 ***</span>
        }
      }
    %}
  
    enc_class z_enc_cmov_imm(cmpOp cmp, iRegI dst, immI16 src) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register Rdst = reg_to_register_object($dst$$reg);
      int      Csrc = $src$$constant;
      Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
      Label done;
      // Branch if not (cmp cr).
<span class="line-new-header">--- 2330,11 ---</span>
        }
      }
    %}
  
    enc_class z_enc_cmov_imm(cmpOp cmp, iRegI dst, immI16 src) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register Rdst = reg_to_register_object($dst$$reg);
      int      Csrc = $src$$constant;
      Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
      Label done;
      // Branch if not (cmp cr).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2347,11 ***</span>
      }
      __ bind(done);
    %}
  
    enc_class z_enc_cctobool(iRegI res) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register Rres = reg_to_register_object($res$$reg);
  
      if (VM_Version::has_LoadStoreConditional()) {
        __ load_const_optimized(Z_R0_scratch, 0L); // false (failed)
        __ load_const_optimized(Rres, 1L);         // true  (succeed)
<span class="line-new-header">--- 2347,11 ---</span>
      }
      __ bind(done);
    %}
  
    enc_class z_enc_cctobool(iRegI res) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register Rres = reg_to_register_object($res$$reg);
  
      if (VM_Version::has_LoadStoreConditional()) {
        __ load_const_optimized(Z_R0_scratch, 0L); // false (failed)
        __ load_const_optimized(Rres, 1L);         // true  (succeed)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2364,29 ***</span>
        __ bind(done);
      }
    %}
  
    enc_class z_enc_casI(iRegI compare_value, iRegI exchange_value, iRegP addr_ptr) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register Rcomp = reg_to_register_object($compare_value$$reg);
      Register Rnew  = reg_to_register_object($exchange_value$$reg);
      Register Raddr = reg_to_register_object($addr_ptr$$reg);
  
      __ z_cs(Rcomp, Rnew, 0, Raddr);
    %}
  
    enc_class z_enc_casL(iRegL compare_value, iRegL exchange_value, iRegP addr_ptr) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register Rcomp = reg_to_register_object($compare_value$$reg);
      Register Rnew  = reg_to_register_object($exchange_value$$reg);
      Register Raddr = reg_to_register_object($addr_ptr$$reg);
  
      __ z_csg(Rcomp, Rnew, 0, Raddr);
    %}
  
    enc_class z_enc_SwapI(memoryRSY mem, iRegI dst, iRegI tmp) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register Rdst = reg_to_register_object($dst$$reg);
      Register Rtmp = reg_to_register_object($tmp$$reg);
      guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
      Label    retry;
  
<span class="line-new-header">--- 2364,29 ---</span>
        __ bind(done);
      }
    %}
  
    enc_class z_enc_casI(iRegI compare_value, iRegI exchange_value, iRegP addr_ptr) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register Rcomp = reg_to_register_object($compare_value$$reg);
      Register Rnew  = reg_to_register_object($exchange_value$$reg);
      Register Raddr = reg_to_register_object($addr_ptr$$reg);
  
      __ z_cs(Rcomp, Rnew, 0, Raddr);
    %}
  
    enc_class z_enc_casL(iRegL compare_value, iRegL exchange_value, iRegP addr_ptr) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register Rcomp = reg_to_register_object($compare_value$$reg);
      Register Rnew  = reg_to_register_object($exchange_value$$reg);
      Register Raddr = reg_to_register_object($addr_ptr$$reg);
  
      __ z_csg(Rcomp, Rnew, 0, Raddr);
    %}
  
    enc_class z_enc_SwapI(memoryRSY mem, iRegI dst, iRegI tmp) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register Rdst = reg_to_register_object($dst$$reg);
      Register Rtmp = reg_to_register_object($tmp$$reg);
      guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
      Label    retry;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2398,11 ***</span>
        __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
      __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
    %}
  
    enc_class z_enc_SwapL(memoryRSY mem, iRegL dst, iRegL tmp) %{
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      Register Rdst = reg_to_register_object($dst$$reg);
      Register Rtmp = reg_to_register_object($tmp$$reg);
      guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
      Label    retry;
  
<span class="line-new-header">--- 2398,11 ---</span>
        __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
      __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
    %}
  
    enc_class z_enc_SwapL(memoryRSY mem, iRegL dst, iRegL tmp) %{
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register Rdst = reg_to_register_object($dst$$reg);
      Register Rtmp = reg_to_register_object($tmp$$reg);
      guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
      Label    retry;
  
</pre>
<center><a href="macroAssembler_s390.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../sparc/interp_masm_sparc.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
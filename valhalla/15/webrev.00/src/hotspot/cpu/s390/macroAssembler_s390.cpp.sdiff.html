<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/macroAssembler_s390.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compiledIC_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_s390.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/macroAssembler_s390.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/codeBuffer.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  32 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
  36 #include &quot;memory/universe.hpp&quot;
  37 #include &quot;oops/accessDecorators.hpp&quot;
  38 #include &quot;oops/compressedOops.inline.hpp&quot;
  39 #include &quot;oops/klass.inline.hpp&quot;
<span class="line-removed">  40 #ifdef COMPILER2</span>
<span class="line-removed">  41 #include &quot;opto/compile.hpp&quot;</span>
<span class="line-removed">  42 #include &quot;opto/intrinsicnode.hpp&quot;</span>
<span class="line-removed">  43 #include &quot;opto/matcher.hpp&quot;</span>
<span class="line-removed">  44 #endif</span>
  45 #include &quot;prims/methodHandles.hpp&quot;
  46 #include &quot;registerSaver_s390.hpp&quot;
  47 #include &quot;runtime/biasedLocking.hpp&quot;
  48 #include &quot;runtime/icache.hpp&quot;
  49 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  50 #include &quot;runtime/objectMonitor.hpp&quot;
  51 #include &quot;runtime/os.hpp&quot;
  52 #include &quot;runtime/safepoint.hpp&quot;
  53 #include &quot;runtime/safepointMechanism.hpp&quot;
  54 #include &quot;runtime/sharedRuntime.hpp&quot;
  55 #include &quot;runtime/stubRoutines.hpp&quot;
  56 #include &quot;utilities/events.hpp&quot;
  57 #include &quot;utilities/macros.hpp&quot;
  58 #include &quot;utilities/powerOfTwo.hpp&quot;
  59 
  60 #include &lt;ucontext.h&gt;
  61 
  62 #define BLOCK_COMMENT(str) block_comment(str)
  63 #define BIND(label)        bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  64 
</pre>
<hr />
<pre>
4576     z_pfd(1,  0,Z_R0,src_reg);
4577     z_pfd(2,  0,Z_R0,dst_reg);
4578     //    z_pfd(1,256,Z_R0,src_reg);    // Assume very short copy.
4579     //    z_pfd(2,256,Z_R0,dst_reg);
4580   }
4581 
4582   if (VM_Version::has_ExecuteExtensions()) {
4583     z_exrl(Z_R1, MVC_template);
4584   } else {
4585     z_ex(tmp1_reg, 0, Z_R0, Z_R1);
4586   }
4587 
4588   bind(done);
4589 
4590   BLOCK_COMMENT(&quot;} CopyRawMemory_AlignedDisjoint&quot;);
4591 
4592   int block_end = offset();
4593   return block_end - block_start;
4594 }
4595 
<span class="line-removed">4596 #ifdef COMPILER2</span>
<span class="line-removed">4597 //------------------------------------------------------</span>
<span class="line-removed">4598 //   Special String Intrinsics. Implementation</span>
<span class="line-removed">4599 //------------------------------------------------------</span>
<span class="line-removed">4600 </span>
<span class="line-removed">4601 // Intrinsics for CompactStrings</span>
<span class="line-removed">4602 </span>
<span class="line-removed">4603 // Compress char[] to byte[].</span>
<span class="line-removed">4604 //   Restores: src, dst</span>
<span class="line-removed">4605 //   Uses:     cnt</span>
<span class="line-removed">4606 //   Kills:    tmp, Z_R0, Z_R1.</span>
<span class="line-removed">4607 //   Early clobber: result.</span>
<span class="line-removed">4608 // Note:</span>
<span class="line-removed">4609 //   cnt is signed int. Do not rely on high word!</span>
<span class="line-removed">4610 //       counts # characters, not bytes.</span>
<span class="line-removed">4611 // The result is the number of characters copied before the first incompatible character was found.</span>
<span class="line-removed">4612 // If precise is true, the processing stops exactly at this point. Otherwise, the result may be off</span>
<span class="line-removed">4613 // by a few bytes. The result always indicates the number of copied characters.</span>
<span class="line-removed">4614 // When used as a character index, the returned value points to the first incompatible character.</span>
<span class="line-removed">4615 //</span>
<span class="line-removed">4616 // Note: Does not behave exactly like package private StringUTF16 compress java implementation in case of failure:</span>
<span class="line-removed">4617 // - Different number of characters may have been written to dead array (if precise is false).</span>
<span class="line-removed">4618 // - Returns a number &lt;cnt instead of 0. (Result gets compared with cnt.)</span>
<span class="line-removed">4619 unsigned int MacroAssembler::string_compress(Register result, Register src, Register dst, Register cnt,</span>
<span class="line-removed">4620                                              Register tmp,    bool precise) {</span>
<span class="line-removed">4621   assert_different_registers(Z_R0, Z_R1, result, src, dst, cnt, tmp);</span>
<span class="line-removed">4622 </span>
<span class="line-removed">4623   if (precise) {</span>
<span class="line-removed">4624     BLOCK_COMMENT(&quot;encode_iso_array {&quot;);</span>
<span class="line-removed">4625   } else {</span>
<span class="line-removed">4626     BLOCK_COMMENT(&quot;string_compress {&quot;);</span>
<span class="line-removed">4627   }</span>
<span class="line-removed">4628   int  block_start = offset();</span>
<span class="line-removed">4629 </span>
<span class="line-removed">4630   Register       Rsrc  = src;</span>
<span class="line-removed">4631   Register       Rdst  = dst;</span>
<span class="line-removed">4632   Register       Rix   = tmp;</span>
<span class="line-removed">4633   Register       Rcnt  = cnt;</span>
<span class="line-removed">4634   Register       Rmask = result;  // holds incompatibility check mask until result value is stored.</span>
<span class="line-removed">4635   Label          ScalarShortcut, AllDone;</span>
<span class="line-removed">4636 </span>
<span class="line-removed">4637   z_iilf(Rmask, 0xFF00FF00);</span>
<span class="line-removed">4638   z_iihf(Rmask, 0xFF00FF00);</span>
<span class="line-removed">4639 </span>
<span class="line-removed">4640 #if 0  // Sacrifice shortcuts for code compactness</span>
<span class="line-removed">4641   {</span>
<span class="line-removed">4642     //---&lt;  shortcuts for short strings (very frequent)   &gt;---</span>
<span class="line-removed">4643     //   Strings with 4 and 8 characters were fond to occur very frequently.</span>
<span class="line-removed">4644     //   Therefore, we handle them right away with minimal overhead.</span>
<span class="line-removed">4645     Label     skipShortcut, skip4Shortcut, skip8Shortcut;</span>
<span class="line-removed">4646     Register  Rout = Z_R0;</span>
<span class="line-removed">4647     z_chi(Rcnt, 4);</span>
<span class="line-removed">4648     z_brne(skip4Shortcut);                 // 4 characters are very frequent</span>
<span class="line-removed">4649       z_lg(Z_R0, 0, Rsrc);                 // Treat exactly 4 characters specially.</span>
<span class="line-removed">4650       if (VM_Version::has_DistinctOpnds()) {</span>
<span class="line-removed">4651         Rout = Z_R0;</span>
<span class="line-removed">4652         z_ngrk(Rix, Z_R0, Rmask);</span>
<span class="line-removed">4653       } else {</span>
<span class="line-removed">4654         Rout = Rix;</span>
<span class="line-removed">4655         z_lgr(Rix, Z_R0);</span>
<span class="line-removed">4656         z_ngr(Z_R0, Rmask);</span>
<span class="line-removed">4657       }</span>
<span class="line-removed">4658       z_brnz(skipShortcut);</span>
<span class="line-removed">4659       z_stcmh(Rout, 5, 0, Rdst);</span>
<span class="line-removed">4660       z_stcm(Rout,  5, 2, Rdst);</span>
<span class="line-removed">4661       z_lgfr(result, Rcnt);</span>
<span class="line-removed">4662       z_bru(AllDone);</span>
<span class="line-removed">4663     bind(skip4Shortcut);</span>
<span class="line-removed">4664 </span>
<span class="line-removed">4665     z_chi(Rcnt, 8);</span>
<span class="line-removed">4666     z_brne(skip8Shortcut);                 // There&#39;s more to do...</span>
<span class="line-removed">4667       z_lmg(Z_R0, Z_R1, 0, Rsrc);          // Treat exactly 8 characters specially.</span>
<span class="line-removed">4668       if (VM_Version::has_DistinctOpnds()) {</span>
<span class="line-removed">4669         Rout = Z_R0;</span>
<span class="line-removed">4670         z_ogrk(Rix, Z_R0, Z_R1);</span>
<span class="line-removed">4671         z_ngr(Rix, Rmask);</span>
<span class="line-removed">4672       } else {</span>
<span class="line-removed">4673         Rout = Rix;</span>
<span class="line-removed">4674         z_lgr(Rix, Z_R0);</span>
<span class="line-removed">4675         z_ogr(Z_R0, Z_R1);</span>
<span class="line-removed">4676         z_ngr(Z_R0, Rmask);</span>
<span class="line-removed">4677       }</span>
<span class="line-removed">4678       z_brnz(skipShortcut);</span>
<span class="line-removed">4679       z_stcmh(Rout, 5, 0, Rdst);</span>
<span class="line-removed">4680       z_stcm(Rout,  5, 2, Rdst);</span>
<span class="line-removed">4681       z_stcmh(Z_R1, 5, 4, Rdst);</span>
<span class="line-removed">4682       z_stcm(Z_R1,  5, 6, Rdst);</span>
<span class="line-removed">4683       z_lgfr(result, Rcnt);</span>
<span class="line-removed">4684       z_bru(AllDone);</span>
<span class="line-removed">4685 </span>
<span class="line-removed">4686     bind(skip8Shortcut);</span>
<span class="line-removed">4687     clear_reg(Z_R0, true, false);          // #characters already processed (none). Precond for scalar loop.</span>
<span class="line-removed">4688     z_brl(ScalarShortcut);                 // Just a few characters</span>
<span class="line-removed">4689 </span>
<span class="line-removed">4690     bind(skipShortcut);</span>
<span class="line-removed">4691   }</span>
<span class="line-removed">4692 #endif</span>
<span class="line-removed">4693   clear_reg(Z_R0);                         // make sure register is properly initialized.</span>
<span class="line-removed">4694 </span>
<span class="line-removed">4695   if (VM_Version::has_VectorFacility()) {</span>
<span class="line-removed">4696     const int  min_vcnt     = 32;          // Minimum #characters required to use vector instructions.</span>
<span class="line-removed">4697                                            // Otherwise just do nothing in vector mode.</span>
<span class="line-removed">4698                                            // Must be multiple of 2*(vector register length in chars (8 HW = 128 bits)).</span>
<span class="line-removed">4699     const int  log_min_vcnt = exact_log2(min_vcnt);</span>
<span class="line-removed">4700     Label      VectorLoop, VectorDone, VectorBreak;</span>
<span class="line-removed">4701 </span>
<span class="line-removed">4702     VectorRegister Vtmp1      = Z_V16;</span>
<span class="line-removed">4703     VectorRegister Vtmp2      = Z_V17;</span>
<span class="line-removed">4704     VectorRegister Vmask      = Z_V18;</span>
<span class="line-removed">4705     VectorRegister Vzero      = Z_V19;</span>
<span class="line-removed">4706     VectorRegister Vsrc_first = Z_V20;</span>
<span class="line-removed">4707     VectorRegister Vsrc_last  = Z_V23;</span>
<span class="line-removed">4708 </span>
<span class="line-removed">4709     assert((Vsrc_last-&gt;encoding() - Vsrc_first-&gt;encoding() + 1) == min_vcnt/8, &quot;logic error&quot;);</span>
<span class="line-removed">4710     assert(VM_Version::has_DistinctOpnds(), &quot;Assumption when has_VectorFacility()&quot;);</span>
<span class="line-removed">4711     z_srak(Rix, Rcnt, log_min_vcnt);       // # vector loop iterations</span>
<span class="line-removed">4712     z_brz(VectorDone);                     // not enough data for vector loop</span>
<span class="line-removed">4713 </span>
<span class="line-removed">4714     z_vzero(Vzero);                        // all zeroes</span>
<span class="line-removed">4715     z_vgmh(Vmask, 0, 7);                   // generate 0xff00 mask for all 2-byte elements</span>
<span class="line-removed">4716     z_sllg(Z_R0, Rix, log_min_vcnt);       // remember #chars that will be processed by vector loop</span>
<span class="line-removed">4717 </span>
<span class="line-removed">4718     bind(VectorLoop);</span>
<span class="line-removed">4719       z_vlm(Vsrc_first, Vsrc_last, 0, Rsrc);</span>
<span class="line-removed">4720       add2reg(Rsrc, min_vcnt*2);</span>
<span class="line-removed">4721 </span>
<span class="line-removed">4722       //---&lt;  check for incompatible character  &gt;---</span>
<span class="line-removed">4723       z_vo(Vtmp1, Z_V20, Z_V21);</span>
<span class="line-removed">4724       z_vo(Vtmp2, Z_V22, Z_V23);</span>
<span class="line-removed">4725       z_vo(Vtmp1, Vtmp1, Vtmp2);</span>
<span class="line-removed">4726       z_vn(Vtmp1, Vtmp1, Vmask);</span>
<span class="line-removed">4727       z_vceqhs(Vtmp1, Vtmp1, Vzero);       // high half of all chars must be zero for successful compress.</span>
<span class="line-removed">4728       z_bvnt(VectorBreak);                 // break vector loop if not all vector elements compare eq -&gt; incompatible character found.</span>
<span class="line-removed">4729                                            // re-process data from current iteration in break handler.</span>
<span class="line-removed">4730 </span>
<span class="line-removed">4731       //---&lt;  pack &amp; store characters  &gt;---</span>
<span class="line-removed">4732       z_vpkh(Vtmp1, Z_V20, Z_V21);         // pack (src1, src2) -&gt; tmp1</span>
<span class="line-removed">4733       z_vpkh(Vtmp2, Z_V22, Z_V23);         // pack (src3, src4) -&gt; tmp2</span>
<span class="line-removed">4734       z_vstm(Vtmp1, Vtmp2, 0, Rdst);       // store packed string</span>
<span class="line-removed">4735       add2reg(Rdst, min_vcnt);</span>
<span class="line-removed">4736 </span>
<span class="line-removed">4737       z_brct(Rix, VectorLoop);</span>
<span class="line-removed">4738 </span>
<span class="line-removed">4739     z_bru(VectorDone);</span>
<span class="line-removed">4740 </span>
<span class="line-removed">4741     bind(VectorBreak);</span>
<span class="line-removed">4742       add2reg(Rsrc, -min_vcnt*2);          // Fix Rsrc. Rsrc was already updated, but Rdst and Rix are not.</span>
<span class="line-removed">4743       z_sll(Rix, log_min_vcnt);            // # chars processed so far in VectorLoop, excl. current iteration.</span>
<span class="line-removed">4744       z_sr(Z_R0, Rix);                     // correct # chars processed in total.</span>
<span class="line-removed">4745 </span>
<span class="line-removed">4746     bind(VectorDone);</span>
<span class="line-removed">4747   }</span>
<span class="line-removed">4748 </span>
<span class="line-removed">4749   {</span>
<span class="line-removed">4750     const int  min_cnt     =  8;           // Minimum #characters required to use unrolled loop.</span>
<span class="line-removed">4751                                            // Otherwise just do nothing in unrolled loop.</span>
<span class="line-removed">4752                                            // Must be multiple of 8.</span>
<span class="line-removed">4753     const int  log_min_cnt = exact_log2(min_cnt);</span>
<span class="line-removed">4754     Label      UnrolledLoop, UnrolledDone, UnrolledBreak;</span>
<span class="line-removed">4755 </span>
<span class="line-removed">4756     if (VM_Version::has_DistinctOpnds()) {</span>
<span class="line-removed">4757       z_srk(Rix, Rcnt, Z_R0);              // remaining # chars to compress in unrolled loop</span>
<span class="line-removed">4758     } else {</span>
<span class="line-removed">4759       z_lr(Rix, Rcnt);</span>
<span class="line-removed">4760       z_sr(Rix, Z_R0);</span>
<span class="line-removed">4761     }</span>
<span class="line-removed">4762     z_sra(Rix, log_min_cnt);             // unrolled loop count</span>
<span class="line-removed">4763     z_brz(UnrolledDone);</span>
<span class="line-removed">4764 </span>
<span class="line-removed">4765     bind(UnrolledLoop);</span>
<span class="line-removed">4766       z_lmg(Z_R0, Z_R1, 0, Rsrc);</span>
<span class="line-removed">4767       if (precise) {</span>
<span class="line-removed">4768         z_ogr(Z_R1, Z_R0);                 // check all 8 chars for incompatibility</span>
<span class="line-removed">4769         z_ngr(Z_R1, Rmask);</span>
<span class="line-removed">4770         z_brnz(UnrolledBreak);</span>
<span class="line-removed">4771 </span>
<span class="line-removed">4772         z_lg(Z_R1, 8, Rsrc);               // reload destroyed register</span>
<span class="line-removed">4773         z_stcmh(Z_R0, 5, 0, Rdst);</span>
<span class="line-removed">4774         z_stcm(Z_R0,  5, 2, Rdst);</span>
<span class="line-removed">4775       } else {</span>
<span class="line-removed">4776         z_stcmh(Z_R0, 5, 0, Rdst);</span>
<span class="line-removed">4777         z_stcm(Z_R0,  5, 2, Rdst);</span>
<span class="line-removed">4778 </span>
<span class="line-removed">4779         z_ogr(Z_R0, Z_R1);</span>
<span class="line-removed">4780         z_ngr(Z_R0, Rmask);</span>
<span class="line-removed">4781         z_brnz(UnrolledBreak);</span>
<span class="line-removed">4782       }</span>
<span class="line-removed">4783       z_stcmh(Z_R1, 5, 4, Rdst);</span>
<span class="line-removed">4784       z_stcm(Z_R1,  5, 6, Rdst);</span>
<span class="line-removed">4785 </span>
<span class="line-removed">4786       add2reg(Rsrc, min_cnt*2);</span>
<span class="line-removed">4787       add2reg(Rdst, min_cnt);</span>
<span class="line-removed">4788       z_brct(Rix, UnrolledLoop);</span>
<span class="line-removed">4789 </span>
<span class="line-removed">4790     z_lgfr(Z_R0, Rcnt);                    // # chars processed in total after unrolled loop.</span>
<span class="line-removed">4791     z_nilf(Z_R0, ~(min_cnt-1));</span>
<span class="line-removed">4792     z_tmll(Rcnt, min_cnt-1);</span>
<span class="line-removed">4793     z_brnaz(ScalarShortcut);               // if all bits zero, there is nothing left to do for scalar loop.</span>
<span class="line-removed">4794                                            // Rix == 0 in all cases.</span>
<span class="line-removed">4795     z_sllg(Z_R1, Rcnt, 1);                 // # src bytes already processed. Only lower 32 bits are valid!</span>
<span class="line-removed">4796                                            //   Z_R1 contents must be treated as unsigned operand! For huge strings,</span>
<span class="line-removed">4797                                            //   (Rcnt &gt;= 2**30), the value may spill into the sign bit by sllg.</span>
<span class="line-removed">4798     z_lgfr(result, Rcnt);                  // all characters processed.</span>
<span class="line-removed">4799     z_slgfr(Rdst, Rcnt);                   // restore ptr</span>
<span class="line-removed">4800     z_slgfr(Rsrc, Z_R1);                   // restore ptr, double the element count for Rsrc restore</span>
<span class="line-removed">4801     z_bru(AllDone);</span>
<span class="line-removed">4802 </span>
<span class="line-removed">4803     bind(UnrolledBreak);</span>
<span class="line-removed">4804     z_lgfr(Z_R0, Rcnt);                    // # chars processed in total after unrolled loop</span>
<span class="line-removed">4805     z_nilf(Z_R0, ~(min_cnt-1));</span>
<span class="line-removed">4806     z_sll(Rix, log_min_cnt);               // # chars not yet processed in UnrolledLoop (due to break), broken iteration not included.</span>
<span class="line-removed">4807     z_sr(Z_R0, Rix);                       // fix # chars processed OK so far.</span>
<span class="line-removed">4808     if (!precise) {</span>
<span class="line-removed">4809       z_lgfr(result, Z_R0);</span>
<span class="line-removed">4810       z_sllg(Z_R1, Z_R0, 1);               // # src bytes already processed. Only lower 32 bits are valid!</span>
<span class="line-removed">4811                                            //   Z_R1 contents must be treated as unsigned operand! For huge strings,</span>
<span class="line-removed">4812                                            //   (Rcnt &gt;= 2**30), the value may spill into the sign bit by sllg.</span>
<span class="line-removed">4813       z_aghi(result, min_cnt/2);           // min_cnt/2 characters have already been written</span>
<span class="line-removed">4814                                            // but ptrs were not updated yet.</span>
<span class="line-removed">4815       z_slgfr(Rdst, Z_R0);                 // restore ptr</span>
<span class="line-removed">4816       z_slgfr(Rsrc, Z_R1);                 // restore ptr, double the element count for Rsrc restore</span>
<span class="line-removed">4817       z_bru(AllDone);</span>
<span class="line-removed">4818     }</span>
<span class="line-removed">4819     bind(UnrolledDone);</span>
<span class="line-removed">4820   }</span>
<span class="line-removed">4821 </span>
<span class="line-removed">4822   {</span>
<span class="line-removed">4823     Label     ScalarLoop, ScalarDone, ScalarBreak;</span>
<span class="line-removed">4824 </span>
<span class="line-removed">4825     bind(ScalarShortcut);</span>
<span class="line-removed">4826     z_ltgfr(result, Rcnt);</span>
<span class="line-removed">4827     z_brz(AllDone);</span>
<span class="line-removed">4828 </span>
<span class="line-removed">4829 #if 0  // Sacrifice shortcuts for code compactness</span>
<span class="line-removed">4830     {</span>
<span class="line-removed">4831       //---&lt;  Special treatment for very short strings (one or two characters)  &gt;---</span>
<span class="line-removed">4832       //   For these strings, we are sure that the above code was skipped.</span>
<span class="line-removed">4833       //   Thus, no registers were modified, register restore is not required.</span>
<span class="line-removed">4834       Label     ScalarDoit, Scalar2Char;</span>
<span class="line-removed">4835       z_chi(Rcnt, 2);</span>
<span class="line-removed">4836       z_brh(ScalarDoit);</span>
<span class="line-removed">4837       z_llh(Z_R1,  0, Z_R0, Rsrc);</span>
<span class="line-removed">4838       z_bre(Scalar2Char);</span>
<span class="line-removed">4839       z_tmll(Z_R1, 0xff00);</span>
<span class="line-removed">4840       z_lghi(result, 0);                   // cnt == 1, first char invalid, no chars successfully processed</span>
<span class="line-removed">4841       z_brnaz(AllDone);</span>
<span class="line-removed">4842       z_stc(Z_R1,  0, Z_R0, Rdst);</span>
<span class="line-removed">4843       z_lghi(result, 1);</span>
<span class="line-removed">4844       z_bru(AllDone);</span>
<span class="line-removed">4845 </span>
<span class="line-removed">4846       bind(Scalar2Char);</span>
<span class="line-removed">4847       z_llh(Z_R0,  2, Z_R0, Rsrc);</span>
<span class="line-removed">4848       z_tmll(Z_R1, 0xff00);</span>
<span class="line-removed">4849       z_lghi(result, 0);                   // cnt == 2, first char invalid, no chars successfully processed</span>
<span class="line-removed">4850       z_brnaz(AllDone);</span>
<span class="line-removed">4851       z_stc(Z_R1,  0, Z_R0, Rdst);</span>
<span class="line-removed">4852       z_tmll(Z_R0, 0xff00);</span>
<span class="line-removed">4853       z_lghi(result, 1);                   // cnt == 2, second char invalid, one char successfully processed</span>
<span class="line-removed">4854       z_brnaz(AllDone);</span>
<span class="line-removed">4855       z_stc(Z_R0,  1, Z_R0, Rdst);</span>
<span class="line-removed">4856       z_lghi(result, 2);</span>
<span class="line-removed">4857       z_bru(AllDone);</span>
<span class="line-removed">4858 </span>
<span class="line-removed">4859       bind(ScalarDoit);</span>
<span class="line-removed">4860     }</span>
<span class="line-removed">4861 #endif</span>
<span class="line-removed">4862 </span>
<span class="line-removed">4863     if (VM_Version::has_DistinctOpnds()) {</span>
<span class="line-removed">4864       z_srk(Rix, Rcnt, Z_R0);              // remaining # chars to compress in unrolled loop</span>
<span class="line-removed">4865     } else {</span>
<span class="line-removed">4866       z_lr(Rix, Rcnt);</span>
<span class="line-removed">4867       z_sr(Rix, Z_R0);</span>
<span class="line-removed">4868     }</span>
<span class="line-removed">4869     z_lgfr(result, Rcnt);                  // # processed characters (if all runs ok).</span>
<span class="line-removed">4870     z_brz(ScalarDone);                     // uses CC from Rix calculation</span>
<span class="line-removed">4871 </span>
<span class="line-removed">4872     bind(ScalarLoop);</span>
<span class="line-removed">4873       z_llh(Z_R1, 0, Z_R0, Rsrc);</span>
<span class="line-removed">4874       z_tmll(Z_R1, 0xff00);</span>
<span class="line-removed">4875       z_brnaz(ScalarBreak);</span>
<span class="line-removed">4876       z_stc(Z_R1, 0, Z_R0, Rdst);</span>
<span class="line-removed">4877       add2reg(Rsrc, 2);</span>
<span class="line-removed">4878       add2reg(Rdst, 1);</span>
<span class="line-removed">4879       z_brct(Rix, ScalarLoop);</span>
<span class="line-removed">4880 </span>
<span class="line-removed">4881     z_bru(ScalarDone);</span>
<span class="line-removed">4882 </span>
<span class="line-removed">4883     bind(ScalarBreak);</span>
<span class="line-removed">4884     z_sr(result, Rix);</span>
<span class="line-removed">4885 </span>
<span class="line-removed">4886     bind(ScalarDone);</span>
<span class="line-removed">4887     z_sgfr(Rdst, result);                  // restore ptr</span>
<span class="line-removed">4888     z_sgfr(Rsrc, result);                  // restore ptr, double the element count for Rsrc restore</span>
<span class="line-removed">4889     z_sgfr(Rsrc, result);</span>
<span class="line-removed">4890   }</span>
<span class="line-removed">4891   bind(AllDone);</span>
<span class="line-removed">4892 </span>
<span class="line-removed">4893   if (precise) {</span>
<span class="line-removed">4894     BLOCK_COMMENT(&quot;} encode_iso_array&quot;);</span>
<span class="line-removed">4895   } else {</span>
<span class="line-removed">4896     BLOCK_COMMENT(&quot;} string_compress&quot;);</span>
<span class="line-removed">4897   }</span>
<span class="line-removed">4898   return offset() - block_start;</span>
<span class="line-removed">4899 }</span>
<span class="line-removed">4900 </span>
<span class="line-removed">4901 // Inflate byte[] to char[].</span>
<span class="line-removed">4902 unsigned int MacroAssembler::string_inflate_trot(Register src, Register dst, Register cnt, Register tmp) {</span>
<span class="line-removed">4903   int block_start = offset();</span>
<span class="line-removed">4904 </span>
<span class="line-removed">4905   BLOCK_COMMENT(&quot;string_inflate {&quot;);</span>
<span class="line-removed">4906 </span>
<span class="line-removed">4907   Register stop_char = Z_R0;</span>
<span class="line-removed">4908   Register table     = Z_R1;</span>
<span class="line-removed">4909   Register src_addr  = tmp;</span>
<span class="line-removed">4910 </span>
<span class="line-removed">4911   assert_different_registers(Z_R0, Z_R1, tmp, src, dst, cnt);</span>
<span class="line-removed">4912   assert(dst-&gt;encoding()%2 == 0, &quot;must be even reg&quot;);</span>
<span class="line-removed">4913   assert(cnt-&gt;encoding()%2 == 1, &quot;must be odd reg&quot;);</span>
<span class="line-removed">4914   assert(cnt-&gt;encoding() - dst-&gt;encoding() == 1, &quot;must be even/odd pair&quot;);</span>
<span class="line-removed">4915 </span>
<span class="line-removed">4916   StubRoutines::zarch::generate_load_trot_table_addr(this, table);  // kills Z_R0 (if ASSERT)</span>
<span class="line-removed">4917   clear_reg(stop_char);  // Stop character. Not used here, but initialized to have a defined value.</span>
<span class="line-removed">4918   lgr_if_needed(src_addr, src);</span>
<span class="line-removed">4919   z_llgfr(cnt, cnt);     // # src characters, must be a positive simm32.</span>
<span class="line-removed">4920 </span>
<span class="line-removed">4921   translate_ot(dst, src_addr, /* mask = */ 0x0001);</span>
<span class="line-removed">4922 </span>
<span class="line-removed">4923   BLOCK_COMMENT(&quot;} string_inflate&quot;);</span>
<span class="line-removed">4924 </span>
<span class="line-removed">4925   return offset() - block_start;</span>
<span class="line-removed">4926 }</span>
<span class="line-removed">4927 </span>
<span class="line-removed">4928 // Inflate byte[] to char[].</span>
<span class="line-removed">4929 //   Restores: src, dst</span>
<span class="line-removed">4930 //   Uses:     cnt</span>
<span class="line-removed">4931 //   Kills:    tmp, Z_R0, Z_R1.</span>
<span class="line-removed">4932 // Note:</span>
<span class="line-removed">4933 //   cnt is signed int. Do not rely on high word!</span>
<span class="line-removed">4934 //       counts # characters, not bytes.</span>
<span class="line-removed">4935 unsigned int MacroAssembler::string_inflate(Register src, Register dst, Register cnt, Register tmp) {</span>
<span class="line-removed">4936   assert_different_registers(Z_R0, Z_R1, src, dst, cnt, tmp);</span>
<span class="line-removed">4937 </span>
<span class="line-removed">4938   BLOCK_COMMENT(&quot;string_inflate {&quot;);</span>
<span class="line-removed">4939   int block_start = offset();</span>
<span class="line-removed">4940 </span>
<span class="line-removed">4941   Register   Rcnt = cnt;   // # characters (src: bytes, dst: char (2-byte)), remaining after current loop.</span>
<span class="line-removed">4942   Register   Rix  = tmp;   // loop index</span>
<span class="line-removed">4943   Register   Rsrc = src;   // addr(src array)</span>
<span class="line-removed">4944   Register   Rdst = dst;   // addr(dst array)</span>
<span class="line-removed">4945   Label      ScalarShortcut, AllDone;</span>
<span class="line-removed">4946 </span>
<span class="line-removed">4947 #if 0  // Sacrifice shortcuts for code compactness</span>
<span class="line-removed">4948   {</span>
<span class="line-removed">4949     //---&lt;  shortcuts for short strings (very frequent)   &gt;---</span>
<span class="line-removed">4950     Label   skipShortcut, skip4Shortcut;</span>
<span class="line-removed">4951     z_ltr(Rcnt, Rcnt);                     // absolutely nothing to do for strings of len == 0.</span>
<span class="line-removed">4952     z_brz(AllDone);</span>
<span class="line-removed">4953     clear_reg(Z_R0);                       // make sure registers are properly initialized.</span>
<span class="line-removed">4954     clear_reg(Z_R1);</span>
<span class="line-removed">4955     z_chi(Rcnt, 4);</span>
<span class="line-removed">4956     z_brne(skip4Shortcut);                 // 4 characters are very frequent</span>
<span class="line-removed">4957       z_icm(Z_R0, 5,    0, Rsrc);          // Treat exactly 4 characters specially.</span>
<span class="line-removed">4958       z_icm(Z_R1, 5,    2, Rsrc);</span>
<span class="line-removed">4959       z_stm(Z_R0, Z_R1, 0, Rdst);</span>
<span class="line-removed">4960       z_bru(AllDone);</span>
<span class="line-removed">4961     bind(skip4Shortcut);</span>
<span class="line-removed">4962 </span>
<span class="line-removed">4963     z_chi(Rcnt, 8);</span>
<span class="line-removed">4964     z_brh(skipShortcut);                   // There&#39;s a lot to do...</span>
<span class="line-removed">4965     z_lgfr(Z_R0, Rcnt);                    // remaining #characters (&lt;= 8). Precond for scalar loop.</span>
<span class="line-removed">4966                                            // This does not destroy the &quot;register cleared&quot; state of Z_R0.</span>
<span class="line-removed">4967     z_brl(ScalarShortcut);                 // Just a few characters</span>
<span class="line-removed">4968       z_icmh(Z_R0, 5, 0, Rsrc);            // Treat exactly 8 characters specially.</span>
<span class="line-removed">4969       z_icmh(Z_R1, 5, 4, Rsrc);</span>
<span class="line-removed">4970       z_icm(Z_R0,  5, 2, Rsrc);</span>
<span class="line-removed">4971       z_icm(Z_R1,  5, 6, Rsrc);</span>
<span class="line-removed">4972       z_stmg(Z_R0, Z_R1, 0, Rdst);</span>
<span class="line-removed">4973       z_bru(AllDone);</span>
<span class="line-removed">4974     bind(skipShortcut);</span>
<span class="line-removed">4975   }</span>
<span class="line-removed">4976 #endif</span>
<span class="line-removed">4977   clear_reg(Z_R0);                         // make sure register is properly initialized.</span>
<span class="line-removed">4978 </span>
<span class="line-removed">4979   if (VM_Version::has_VectorFacility()) {</span>
<span class="line-removed">4980     const int  min_vcnt     = 32;          // Minimum #characters required to use vector instructions.</span>
<span class="line-removed">4981                                            // Otherwise just do nothing in vector mode.</span>
<span class="line-removed">4982                                            // Must be multiple of vector register length (16 bytes = 128 bits).</span>
<span class="line-removed">4983     const int  log_min_vcnt = exact_log2(min_vcnt);</span>
<span class="line-removed">4984     Label      VectorLoop, VectorDone;</span>
<span class="line-removed">4985 </span>
<span class="line-removed">4986     assert(VM_Version::has_DistinctOpnds(), &quot;Assumption when has_VectorFacility()&quot;);</span>
<span class="line-removed">4987     z_srak(Rix, Rcnt, log_min_vcnt);       // calculate # vector loop iterations</span>
<span class="line-removed">4988     z_brz(VectorDone);                     // skip if none</span>
<span class="line-removed">4989 </span>
<span class="line-removed">4990     z_sllg(Z_R0, Rix, log_min_vcnt);       // remember #chars that will be processed by vector loop</span>
<span class="line-removed">4991 </span>
<span class="line-removed">4992     bind(VectorLoop);</span>
<span class="line-removed">4993       z_vlm(Z_V20, Z_V21, 0, Rsrc);        // get next 32 characters (single-byte)</span>
<span class="line-removed">4994       add2reg(Rsrc, min_vcnt);</span>
<span class="line-removed">4995 </span>
<span class="line-removed">4996       z_vuplhb(Z_V22, Z_V20);              // V2 &lt;- (expand) V0(high)</span>
<span class="line-removed">4997       z_vupllb(Z_V23, Z_V20);              // V3 &lt;- (expand) V0(low)</span>
<span class="line-removed">4998       z_vuplhb(Z_V24, Z_V21);              // V4 &lt;- (expand) V1(high)</span>
<span class="line-removed">4999       z_vupllb(Z_V25, Z_V21);              // V5 &lt;- (expand) V1(low)</span>
<span class="line-removed">5000       z_vstm(Z_V22, Z_V25, 0, Rdst);       // store next 32 bytes</span>
<span class="line-removed">5001       add2reg(Rdst, min_vcnt*2);</span>
<span class="line-removed">5002 </span>
<span class="line-removed">5003       z_brct(Rix, VectorLoop);</span>
<span class="line-removed">5004 </span>
<span class="line-removed">5005     bind(VectorDone);</span>
<span class="line-removed">5006   }</span>
<span class="line-removed">5007 </span>
<span class="line-removed">5008   const int  min_cnt     =  8;             // Minimum #characters required to use unrolled scalar loop.</span>
<span class="line-removed">5009                                            // Otherwise just do nothing in unrolled scalar mode.</span>
<span class="line-removed">5010                                            // Must be multiple of 8.</span>
<span class="line-removed">5011   {</span>
<span class="line-removed">5012     const int  log_min_cnt = exact_log2(min_cnt);</span>
<span class="line-removed">5013     Label      UnrolledLoop, UnrolledDone;</span>
<span class="line-removed">5014 </span>
<span class="line-removed">5015 </span>
<span class="line-removed">5016     if (VM_Version::has_DistinctOpnds()) {</span>
<span class="line-removed">5017       z_srk(Rix, Rcnt, Z_R0);              // remaining # chars to process in unrolled loop</span>
<span class="line-removed">5018     } else {</span>
<span class="line-removed">5019       z_lr(Rix, Rcnt);</span>
<span class="line-removed">5020       z_sr(Rix, Z_R0);</span>
<span class="line-removed">5021     }</span>
<span class="line-removed">5022     z_sra(Rix, log_min_cnt);               // unrolled loop count</span>
<span class="line-removed">5023     z_brz(UnrolledDone);</span>
<span class="line-removed">5024 </span>
<span class="line-removed">5025     clear_reg(Z_R0);</span>
<span class="line-removed">5026     clear_reg(Z_R1);</span>
<span class="line-removed">5027 </span>
<span class="line-removed">5028     bind(UnrolledLoop);</span>
<span class="line-removed">5029       z_icmh(Z_R0, 5, 0, Rsrc);</span>
<span class="line-removed">5030       z_icmh(Z_R1, 5, 4, Rsrc);</span>
<span class="line-removed">5031       z_icm(Z_R0,  5, 2, Rsrc);</span>
<span class="line-removed">5032       z_icm(Z_R1,  5, 6, Rsrc);</span>
<span class="line-removed">5033       add2reg(Rsrc, min_cnt);</span>
<span class="line-removed">5034 </span>
<span class="line-removed">5035       z_stmg(Z_R0, Z_R1, 0, Rdst);</span>
<span class="line-removed">5036 </span>
<span class="line-removed">5037       add2reg(Rdst, min_cnt*2);</span>
<span class="line-removed">5038       z_brct(Rix, UnrolledLoop);</span>
<span class="line-removed">5039 </span>
<span class="line-removed">5040     bind(UnrolledDone);</span>
<span class="line-removed">5041     z_lgfr(Z_R0, Rcnt);                    // # chars left over after unrolled loop.</span>
<span class="line-removed">5042     z_nilf(Z_R0, min_cnt-1);</span>
<span class="line-removed">5043     z_brnz(ScalarShortcut);                // if zero, there is nothing left to do for scalar loop.</span>
<span class="line-removed">5044                                            // Rix == 0 in all cases.</span>
<span class="line-removed">5045     z_sgfr(Z_R0, Rcnt);                    // negative # characters the ptrs have been advanced previously.</span>
<span class="line-removed">5046     z_agr(Rdst, Z_R0);                     // restore ptr, double the element count for Rdst restore.</span>
<span class="line-removed">5047     z_agr(Rdst, Z_R0);</span>
<span class="line-removed">5048     z_agr(Rsrc, Z_R0);                     // restore ptr.</span>
<span class="line-removed">5049     z_bru(AllDone);</span>
<span class="line-removed">5050   }</span>
<span class="line-removed">5051 </span>
<span class="line-removed">5052   {</span>
<span class="line-removed">5053     bind(ScalarShortcut);</span>
<span class="line-removed">5054     // Z_R0 must contain remaining # characters as 64-bit signed int here.</span>
<span class="line-removed">5055     //      register contents is preserved over scalar processing (for register fixup).</span>
<span class="line-removed">5056 </span>
<span class="line-removed">5057 #if 0  // Sacrifice shortcuts for code compactness</span>
<span class="line-removed">5058     {</span>
<span class="line-removed">5059       Label      ScalarDefault;</span>
<span class="line-removed">5060       z_chi(Rcnt, 2);</span>
<span class="line-removed">5061       z_brh(ScalarDefault);</span>
<span class="line-removed">5062       z_llc(Z_R0,  0, Z_R0, Rsrc);     // 6 bytes</span>
<span class="line-removed">5063       z_sth(Z_R0,  0, Z_R0, Rdst);     // 4 bytes</span>
<span class="line-removed">5064       z_brl(AllDone);</span>
<span class="line-removed">5065       z_llc(Z_R0,  1, Z_R0, Rsrc);     // 6 bytes</span>
<span class="line-removed">5066       z_sth(Z_R0,  2, Z_R0, Rdst);     // 4 bytes</span>
<span class="line-removed">5067       z_bru(AllDone);</span>
<span class="line-removed">5068       bind(ScalarDefault);</span>
<span class="line-removed">5069     }</span>
<span class="line-removed">5070 #endif</span>
<span class="line-removed">5071 </span>
<span class="line-removed">5072     Label   CodeTable;</span>
<span class="line-removed">5073     // Some comments on Rix calculation:</span>
<span class="line-removed">5074     //  - Rcnt is small, therefore no bits shifted out of low word (sll(g) instructions).</span>
<span class="line-removed">5075     //  - high word of both Rix and Rcnt may contain garbage</span>
<span class="line-removed">5076     //  - the final lngfr takes care of that garbage, extending the sign to high word</span>
<span class="line-removed">5077     z_sllg(Rix, Z_R0, 2);                // calculate 10*Rix = (4*Rix + Rix)*2</span>
<span class="line-removed">5078     z_ar(Rix, Z_R0);</span>
<span class="line-removed">5079     z_larl(Z_R1, CodeTable);</span>
<span class="line-removed">5080     z_sll(Rix, 1);</span>
<span class="line-removed">5081     z_lngfr(Rix, Rix);      // ix range: [0..7], after inversion &amp; mult: [-(7*12)..(0*12)].</span>
<span class="line-removed">5082     z_bc(Assembler::bcondAlways, 0, Rix, Z_R1);</span>
<span class="line-removed">5083 </span>
<span class="line-removed">5084     z_llc(Z_R1,  6, Z_R0, Rsrc);  // 6 bytes</span>
<span class="line-removed">5085     z_sth(Z_R1, 12, Z_R0, Rdst);  // 4 bytes</span>
<span class="line-removed">5086 </span>
<span class="line-removed">5087     z_llc(Z_R1,  5, Z_R0, Rsrc);</span>
<span class="line-removed">5088     z_sth(Z_R1, 10, Z_R0, Rdst);</span>
<span class="line-removed">5089 </span>
<span class="line-removed">5090     z_llc(Z_R1,  4, Z_R0, Rsrc);</span>
<span class="line-removed">5091     z_sth(Z_R1,  8, Z_R0, Rdst);</span>
<span class="line-removed">5092 </span>
<span class="line-removed">5093     z_llc(Z_R1,  3, Z_R0, Rsrc);</span>
<span class="line-removed">5094     z_sth(Z_R1,  6, Z_R0, Rdst);</span>
<span class="line-removed">5095 </span>
<span class="line-removed">5096     z_llc(Z_R1,  2, Z_R0, Rsrc);</span>
<span class="line-removed">5097     z_sth(Z_R1,  4, Z_R0, Rdst);</span>
<span class="line-removed">5098 </span>
<span class="line-removed">5099     z_llc(Z_R1,  1, Z_R0, Rsrc);</span>
<span class="line-removed">5100     z_sth(Z_R1,  2, Z_R0, Rdst);</span>
<span class="line-removed">5101 </span>
<span class="line-removed">5102     z_llc(Z_R1,  0, Z_R0, Rsrc);</span>
<span class="line-removed">5103     z_sth(Z_R1,  0, Z_R0, Rdst);</span>
<span class="line-removed">5104     bind(CodeTable);</span>
<span class="line-removed">5105 </span>
<span class="line-removed">5106     z_chi(Rcnt, 8);                        // no fixup for small strings. Rdst, Rsrc were not modified.</span>
<span class="line-removed">5107     z_brl(AllDone);</span>
<span class="line-removed">5108 </span>
<span class="line-removed">5109     z_sgfr(Z_R0, Rcnt);                    // # characters the ptrs have been advanced previously.</span>
<span class="line-removed">5110     z_agr(Rdst, Z_R0);                     // restore ptr, double the element count for Rdst restore.</span>
<span class="line-removed">5111     z_agr(Rdst, Z_R0);</span>
<span class="line-removed">5112     z_agr(Rsrc, Z_R0);                     // restore ptr.</span>
<span class="line-removed">5113   }</span>
<span class="line-removed">5114   bind(AllDone);</span>
<span class="line-removed">5115 </span>
<span class="line-removed">5116   BLOCK_COMMENT(&quot;} string_inflate&quot;);</span>
<span class="line-removed">5117   return offset() - block_start;</span>
<span class="line-removed">5118 }</span>
<span class="line-removed">5119 </span>
<span class="line-removed">5120 // Inflate byte[] to char[], length known at compile time.</span>
<span class="line-removed">5121 //   Restores: src, dst</span>
<span class="line-removed">5122 //   Kills:    tmp, Z_R0, Z_R1.</span>
<span class="line-removed">5123 // Note:</span>
<span class="line-removed">5124 //   len is signed int. Counts # characters, not bytes.</span>
<span class="line-removed">5125 unsigned int MacroAssembler::string_inflate_const(Register src, Register dst, Register tmp, int len) {</span>
<span class="line-removed">5126   assert_different_registers(Z_R0, Z_R1, src, dst, tmp);</span>
<span class="line-removed">5127 </span>
<span class="line-removed">5128   BLOCK_COMMENT(&quot;string_inflate_const {&quot;);</span>
<span class="line-removed">5129   int block_start = offset();</span>
<span class="line-removed">5130 </span>
<span class="line-removed">5131   Register   Rix  = tmp;   // loop index</span>
<span class="line-removed">5132   Register   Rsrc = src;   // addr(src array)</span>
<span class="line-removed">5133   Register   Rdst = dst;   // addr(dst array)</span>
<span class="line-removed">5134   Label      ScalarShortcut, AllDone;</span>
<span class="line-removed">5135   int        nprocessed = 0;</span>
<span class="line-removed">5136   int        src_off    = 0;  // compensate for saved (optimized away) ptr advancement.</span>
<span class="line-removed">5137   int        dst_off    = 0;  // compensate for saved (optimized away) ptr advancement.</span>
<span class="line-removed">5138   bool       restore_inputs = false;</span>
<span class="line-removed">5139   bool       workreg_clear  = false;</span>
<span class="line-removed">5140 </span>
<span class="line-removed">5141   if ((len &gt;= 32) &amp;&amp; VM_Version::has_VectorFacility()) {</span>
<span class="line-removed">5142     const int  min_vcnt     = 32;          // Minimum #characters required to use vector instructions.</span>
<span class="line-removed">5143                                            // Otherwise just do nothing in vector mode.</span>
<span class="line-removed">5144                                            // Must be multiple of vector register length (16 bytes = 128 bits).</span>
<span class="line-removed">5145     const int  log_min_vcnt = exact_log2(min_vcnt);</span>
<span class="line-removed">5146     const int  iterations   = (len - nprocessed) &gt;&gt; log_min_vcnt;</span>
<span class="line-removed">5147     nprocessed             += iterations &lt;&lt; log_min_vcnt;</span>
<span class="line-removed">5148     Label      VectorLoop;</span>
<span class="line-removed">5149 </span>
<span class="line-removed">5150     if (iterations == 1) {</span>
<span class="line-removed">5151       z_vlm(Z_V20, Z_V21, 0+src_off, Rsrc);  // get next 32 characters (single-byte)</span>
<span class="line-removed">5152       z_vuplhb(Z_V22, Z_V20);                // V2 &lt;- (expand) V0(high)</span>
<span class="line-removed">5153       z_vupllb(Z_V23, Z_V20);                // V3 &lt;- (expand) V0(low)</span>
<span class="line-removed">5154       z_vuplhb(Z_V24, Z_V21);                // V4 &lt;- (expand) V1(high)</span>
<span class="line-removed">5155       z_vupllb(Z_V25, Z_V21);                // V5 &lt;- (expand) V1(low)</span>
<span class="line-removed">5156       z_vstm(Z_V22, Z_V25, 0+dst_off, Rdst); // store next 32 bytes</span>
<span class="line-removed">5157 </span>
<span class="line-removed">5158       src_off += min_vcnt;</span>
<span class="line-removed">5159       dst_off += min_vcnt*2;</span>
<span class="line-removed">5160     } else {</span>
<span class="line-removed">5161       restore_inputs = true;</span>
<span class="line-removed">5162 </span>
<span class="line-removed">5163       z_lgfi(Rix, len&gt;&gt;log_min_vcnt);</span>
<span class="line-removed">5164       bind(VectorLoop);</span>
<span class="line-removed">5165         z_vlm(Z_V20, Z_V21, 0, Rsrc);        // get next 32 characters (single-byte)</span>
<span class="line-removed">5166         add2reg(Rsrc, min_vcnt);</span>
<span class="line-removed">5167 </span>
<span class="line-removed">5168         z_vuplhb(Z_V22, Z_V20);              // V2 &lt;- (expand) V0(high)</span>
<span class="line-removed">5169         z_vupllb(Z_V23, Z_V20);              // V3 &lt;- (expand) V0(low)</span>
<span class="line-removed">5170         z_vuplhb(Z_V24, Z_V21);              // V4 &lt;- (expand) V1(high)</span>
<span class="line-removed">5171         z_vupllb(Z_V25, Z_V21);              // V5 &lt;- (expand) V1(low)</span>
<span class="line-removed">5172         z_vstm(Z_V22, Z_V25, 0, Rdst);       // store next 32 bytes</span>
<span class="line-removed">5173         add2reg(Rdst, min_vcnt*2);</span>
<span class="line-removed">5174 </span>
<span class="line-removed">5175         z_brct(Rix, VectorLoop);</span>
<span class="line-removed">5176     }</span>
<span class="line-removed">5177   }</span>
<span class="line-removed">5178 </span>
<span class="line-removed">5179   if (((len-nprocessed) &gt;= 16) &amp;&amp; VM_Version::has_VectorFacility()) {</span>
<span class="line-removed">5180     const int  min_vcnt     = 16;          // Minimum #characters required to use vector instructions.</span>
<span class="line-removed">5181                                            // Otherwise just do nothing in vector mode.</span>
<span class="line-removed">5182                                            // Must be multiple of vector register length (16 bytes = 128 bits).</span>
<span class="line-removed">5183     const int  log_min_vcnt = exact_log2(min_vcnt);</span>
<span class="line-removed">5184     const int  iterations   = (len - nprocessed) &gt;&gt; log_min_vcnt;</span>
<span class="line-removed">5185     nprocessed             += iterations &lt;&lt; log_min_vcnt;</span>
<span class="line-removed">5186     assert(iterations == 1, &quot;must be!&quot;);</span>
<span class="line-removed">5187 </span>
<span class="line-removed">5188     z_vl(Z_V20, 0+src_off, Z_R0, Rsrc);    // get next 16 characters (single-byte)</span>
<span class="line-removed">5189     z_vuplhb(Z_V22, Z_V20);                // V2 &lt;- (expand) V0(high)</span>
<span class="line-removed">5190     z_vupllb(Z_V23, Z_V20);                // V3 &lt;- (expand) V0(low)</span>
<span class="line-removed">5191     z_vstm(Z_V22, Z_V23, 0+dst_off, Rdst); // store next 32 bytes</span>
<span class="line-removed">5192 </span>
<span class="line-removed">5193     src_off += min_vcnt;</span>
<span class="line-removed">5194     dst_off += min_vcnt*2;</span>
<span class="line-removed">5195   }</span>
<span class="line-removed">5196 </span>
<span class="line-removed">5197   if ((len-nprocessed) &gt; 8) {</span>
<span class="line-removed">5198     const int  min_cnt     =  8;           // Minimum #characters required to use unrolled scalar loop.</span>
<span class="line-removed">5199                                            // Otherwise just do nothing in unrolled scalar mode.</span>
<span class="line-removed">5200                                            // Must be multiple of 8.</span>
<span class="line-removed">5201     const int  log_min_cnt = exact_log2(min_cnt);</span>
<span class="line-removed">5202     const int  iterations  = (len - nprocessed) &gt;&gt; log_min_cnt;</span>
<span class="line-removed">5203     nprocessed     += iterations &lt;&lt; log_min_cnt;</span>
<span class="line-removed">5204 </span>
<span class="line-removed">5205     //---&lt;  avoid loop overhead/ptr increment for small # iterations  &gt;---</span>
<span class="line-removed">5206     if (iterations &lt;= 2) {</span>
<span class="line-removed">5207       clear_reg(Z_R0);</span>
<span class="line-removed">5208       clear_reg(Z_R1);</span>
<span class="line-removed">5209       workreg_clear = true;</span>
<span class="line-removed">5210 </span>
<span class="line-removed">5211       z_icmh(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="line-removed">5212       z_icmh(Z_R1, 5, 4+src_off, Rsrc);</span>
<span class="line-removed">5213       z_icm(Z_R0,  5, 2+src_off, Rsrc);</span>
<span class="line-removed">5214       z_icm(Z_R1,  5, 6+src_off, Rsrc);</span>
<span class="line-removed">5215       z_stmg(Z_R0, Z_R1, 0+dst_off, Rdst);</span>
<span class="line-removed">5216 </span>
<span class="line-removed">5217       src_off += min_cnt;</span>
<span class="line-removed">5218       dst_off += min_cnt*2;</span>
<span class="line-removed">5219     }</span>
<span class="line-removed">5220 </span>
<span class="line-removed">5221     if (iterations == 2) {</span>
<span class="line-removed">5222       z_icmh(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="line-removed">5223       z_icmh(Z_R1, 5, 4+src_off, Rsrc);</span>
<span class="line-removed">5224       z_icm(Z_R0,  5, 2+src_off, Rsrc);</span>
<span class="line-removed">5225       z_icm(Z_R1,  5, 6+src_off, Rsrc);</span>
<span class="line-removed">5226       z_stmg(Z_R0, Z_R1, 0+dst_off, Rdst);</span>
<span class="line-removed">5227 </span>
<span class="line-removed">5228       src_off += min_cnt;</span>
<span class="line-removed">5229       dst_off += min_cnt*2;</span>
<span class="line-removed">5230     }</span>
<span class="line-removed">5231 </span>
<span class="line-removed">5232     if (iterations &gt; 2) {</span>
<span class="line-removed">5233       Label      UnrolledLoop;</span>
<span class="line-removed">5234       restore_inputs  = true;</span>
<span class="line-removed">5235 </span>
<span class="line-removed">5236       clear_reg(Z_R0);</span>
<span class="line-removed">5237       clear_reg(Z_R1);</span>
<span class="line-removed">5238       workreg_clear = true;</span>
<span class="line-removed">5239 </span>
<span class="line-removed">5240       z_lgfi(Rix, iterations);</span>
<span class="line-removed">5241       bind(UnrolledLoop);</span>
<span class="line-removed">5242         z_icmh(Z_R0, 5, 0, Rsrc);</span>
<span class="line-removed">5243         z_icmh(Z_R1, 5, 4, Rsrc);</span>
<span class="line-removed">5244         z_icm(Z_R0,  5, 2, Rsrc);</span>
<span class="line-removed">5245         z_icm(Z_R1,  5, 6, Rsrc);</span>
<span class="line-removed">5246         add2reg(Rsrc, min_cnt);</span>
<span class="line-removed">5247 </span>
<span class="line-removed">5248         z_stmg(Z_R0, Z_R1, 0, Rdst);</span>
<span class="line-removed">5249         add2reg(Rdst, min_cnt*2);</span>
<span class="line-removed">5250 </span>
<span class="line-removed">5251         z_brct(Rix, UnrolledLoop);</span>
<span class="line-removed">5252     }</span>
<span class="line-removed">5253   }</span>
<span class="line-removed">5254 </span>
<span class="line-removed">5255   if ((len-nprocessed) &gt; 0) {</span>
<span class="line-removed">5256     switch (len-nprocessed) {</span>
<span class="line-removed">5257       case 8:</span>
<span class="line-removed">5258         if (!workreg_clear) {</span>
<span class="line-removed">5259           clear_reg(Z_R0);</span>
<span class="line-removed">5260           clear_reg(Z_R1);</span>
<span class="line-removed">5261         }</span>
<span class="line-removed">5262         z_icmh(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="line-removed">5263         z_icmh(Z_R1, 5, 4+src_off, Rsrc);</span>
<span class="line-removed">5264         z_icm(Z_R0,  5, 2+src_off, Rsrc);</span>
<span class="line-removed">5265         z_icm(Z_R1,  5, 6+src_off, Rsrc);</span>
<span class="line-removed">5266         z_stmg(Z_R0, Z_R1, 0+dst_off, Rdst);</span>
<span class="line-removed">5267         break;</span>
<span class="line-removed">5268       case 7:</span>
<span class="line-removed">5269         if (!workreg_clear) {</span>
<span class="line-removed">5270           clear_reg(Z_R0);</span>
<span class="line-removed">5271           clear_reg(Z_R1);</span>
<span class="line-removed">5272         }</span>
<span class="line-removed">5273         clear_reg(Rix);</span>
<span class="line-removed">5274         z_icm(Z_R0,  5, 0+src_off, Rsrc);</span>
<span class="line-removed">5275         z_icm(Z_R1,  5, 2+src_off, Rsrc);</span>
<span class="line-removed">5276         z_icm(Rix,   5, 4+src_off, Rsrc);</span>
<span class="line-removed">5277         z_stm(Z_R0,  Z_R1, 0+dst_off, Rdst);</span>
<span class="line-removed">5278         z_llc(Z_R0,  6+src_off, Z_R0, Rsrc);</span>
<span class="line-removed">5279         z_st(Rix,    8+dst_off, Z_R0, Rdst);</span>
<span class="line-removed">5280         z_sth(Z_R0, 12+dst_off, Z_R0, Rdst);</span>
<span class="line-removed">5281         break;</span>
<span class="line-removed">5282       case 6:</span>
<span class="line-removed">5283         if (!workreg_clear) {</span>
<span class="line-removed">5284           clear_reg(Z_R0);</span>
<span class="line-removed">5285           clear_reg(Z_R1);</span>
<span class="line-removed">5286         }</span>
<span class="line-removed">5287         clear_reg(Rix);</span>
<span class="line-removed">5288         z_icm(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="line-removed">5289         z_icm(Z_R1, 5, 2+src_off, Rsrc);</span>
<span class="line-removed">5290         z_icm(Rix,  5, 4+src_off, Rsrc);</span>
<span class="line-removed">5291         z_stm(Z_R0, Z_R1, 0+dst_off, Rdst);</span>
<span class="line-removed">5292         z_st(Rix,   8+dst_off, Z_R0, Rdst);</span>
<span class="line-removed">5293         break;</span>
<span class="line-removed">5294       case 5:</span>
<span class="line-removed">5295         if (!workreg_clear) {</span>
<span class="line-removed">5296           clear_reg(Z_R0);</span>
<span class="line-removed">5297           clear_reg(Z_R1);</span>
<span class="line-removed">5298         }</span>
<span class="line-removed">5299         z_icm(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="line-removed">5300         z_icm(Z_R1, 5, 2+src_off, Rsrc);</span>
<span class="line-removed">5301         z_llc(Rix,  4+src_off, Z_R0, Rsrc);</span>
<span class="line-removed">5302         z_stm(Z_R0, Z_R1, 0+dst_off, Rdst);</span>
<span class="line-removed">5303         z_sth(Rix,  8+dst_off, Z_R0, Rdst);</span>
<span class="line-removed">5304         break;</span>
<span class="line-removed">5305       case 4:</span>
<span class="line-removed">5306         if (!workreg_clear) {</span>
<span class="line-removed">5307           clear_reg(Z_R0);</span>
<span class="line-removed">5308           clear_reg(Z_R1);</span>
<span class="line-removed">5309         }</span>
<span class="line-removed">5310         z_icm(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="line-removed">5311         z_icm(Z_R1, 5, 2+src_off, Rsrc);</span>
<span class="line-removed">5312         z_stm(Z_R0, Z_R1, 0+dst_off, Rdst);</span>
<span class="line-removed">5313         break;</span>
<span class="line-removed">5314       case 3:</span>
<span class="line-removed">5315         if (!workreg_clear) {</span>
<span class="line-removed">5316           clear_reg(Z_R0);</span>
<span class="line-removed">5317         }</span>
<span class="line-removed">5318         z_llc(Z_R1, 2+src_off, Z_R0, Rsrc);</span>
<span class="line-removed">5319         z_icm(Z_R0, 5, 0+src_off, Rsrc);</span>
<span class="line-removed">5320         z_sth(Z_R1, 4+dst_off, Z_R0, Rdst);</span>
<span class="line-removed">5321         z_st(Z_R0,  0+dst_off, Rdst);</span>
<span class="line-removed">5322         break;</span>
<span class="line-removed">5323       case 2:</span>
<span class="line-removed">5324         z_llc(Z_R0, 0+src_off, Z_R0, Rsrc);</span>
<span class="line-removed">5325         z_llc(Z_R1, 1+src_off, Z_R0, Rsrc);</span>
<span class="line-removed">5326         z_sth(Z_R0, 0+dst_off, Z_R0, Rdst);</span>
<span class="line-removed">5327         z_sth(Z_R1, 2+dst_off, Z_R0, Rdst);</span>
<span class="line-removed">5328         break;</span>
<span class="line-removed">5329       case 1:</span>
<span class="line-removed">5330         z_llc(Z_R0, 0+src_off, Z_R0, Rsrc);</span>
<span class="line-removed">5331         z_sth(Z_R0, 0+dst_off, Z_R0, Rdst);</span>
<span class="line-removed">5332         break;</span>
<span class="line-removed">5333       default:</span>
<span class="line-removed">5334         guarantee(false, &quot;Impossible&quot;);</span>
<span class="line-removed">5335         break;</span>
<span class="line-removed">5336     }</span>
<span class="line-removed">5337     src_off   +=  len-nprocessed;</span>
<span class="line-removed">5338     dst_off   += (len-nprocessed)*2;</span>
<span class="line-removed">5339     nprocessed = len;</span>
<span class="line-removed">5340   }</span>
<span class="line-removed">5341 </span>
<span class="line-removed">5342   //---&lt; restore modified input registers  &gt;---</span>
<span class="line-removed">5343   if ((nprocessed &gt; 0) &amp;&amp; restore_inputs) {</span>
<span class="line-removed">5344     z_agfi(Rsrc, -(nprocessed-src_off));</span>
<span class="line-removed">5345     if (nprocessed &lt; 1000000000) { // avoid int overflow</span>
<span class="line-removed">5346       z_agfi(Rdst, -(nprocessed*2-dst_off));</span>
<span class="line-removed">5347     } else {</span>
<span class="line-removed">5348       z_agfi(Rdst, -(nprocessed-dst_off));</span>
<span class="line-removed">5349       z_agfi(Rdst, -nprocessed);</span>
<span class="line-removed">5350     }</span>
<span class="line-removed">5351   }</span>
<span class="line-removed">5352 </span>
<span class="line-removed">5353   BLOCK_COMMENT(&quot;} string_inflate_const&quot;);</span>
<span class="line-removed">5354   return offset() - block_start;</span>
<span class="line-removed">5355 }</span>
<span class="line-removed">5356 </span>
<span class="line-removed">5357 // Kills src.</span>
<span class="line-removed">5358 unsigned int MacroAssembler::has_negatives(Register result, Register src, Register cnt,</span>
<span class="line-removed">5359                                            Register odd_reg, Register even_reg, Register tmp) {</span>
<span class="line-removed">5360   int block_start = offset();</span>
<span class="line-removed">5361   Label Lloop1, Lloop2, Lslow, Lnotfound, Ldone;</span>
<span class="line-removed">5362   const Register addr = src, mask = tmp;</span>
<span class="line-removed">5363 </span>
<span class="line-removed">5364   BLOCK_COMMENT(&quot;has_negatives {&quot;);</span>
<span class="line-removed">5365 </span>
<span class="line-removed">5366   z_llgfr(Z_R1, cnt);      // Number of bytes to read. (Must be a positive simm32.)</span>
<span class="line-removed">5367   z_llilf(mask, 0x80808080);</span>
<span class="line-removed">5368   z_lhi(result, 1);        // Assume true.</span>
<span class="line-removed">5369   // Last possible addr for fast loop.</span>
<span class="line-removed">5370   z_lay(odd_reg, -16, Z_R1, src);</span>
<span class="line-removed">5371   z_chi(cnt, 16);</span>
<span class="line-removed">5372   z_brl(Lslow);</span>
<span class="line-removed">5373 </span>
<span class="line-removed">5374   // ind1: index, even_reg: index increment, odd_reg: index limit</span>
<span class="line-removed">5375   z_iihf(mask, 0x80808080);</span>
<span class="line-removed">5376   z_lghi(even_reg, 16);</span>
<span class="line-removed">5377 </span>
<span class="line-removed">5378   bind(Lloop1); // 16 bytes per iteration.</span>
<span class="line-removed">5379   z_lg(Z_R0, Address(addr));</span>
<span class="line-removed">5380   z_lg(Z_R1, Address(addr, 8));</span>
<span class="line-removed">5381   z_ogr(Z_R0, Z_R1);</span>
<span class="line-removed">5382   z_ngr(Z_R0, mask);</span>
<span class="line-removed">5383   z_brne(Ldone);           // If found return 1.</span>
<span class="line-removed">5384   z_brxlg(addr, even_reg, Lloop1);</span>
<span class="line-removed">5385 </span>
<span class="line-removed">5386   bind(Lslow);</span>
<span class="line-removed">5387   z_aghi(odd_reg, 16-1);   // Last possible addr for slow loop.</span>
<span class="line-removed">5388   z_lghi(even_reg, 1);</span>
<span class="line-removed">5389   z_cgr(addr, odd_reg);</span>
<span class="line-removed">5390   z_brh(Lnotfound);</span>
<span class="line-removed">5391 </span>
<span class="line-removed">5392   bind(Lloop2); // 1 byte per iteration.</span>
<span class="line-removed">5393   z_cli(Address(addr), 0x80);</span>
<span class="line-removed">5394   z_brnl(Ldone);           // If found return 1.</span>
<span class="line-removed">5395   z_brxlg(addr, even_reg, Lloop2);</span>
<span class="line-removed">5396 </span>
<span class="line-removed">5397   bind(Lnotfound);</span>
<span class="line-removed">5398   z_lhi(result, 0);</span>
<span class="line-removed">5399 </span>
<span class="line-removed">5400   bind(Ldone);</span>
<span class="line-removed">5401 </span>
<span class="line-removed">5402   BLOCK_COMMENT(&quot;} has_negatives&quot;);</span>
<span class="line-removed">5403 </span>
<span class="line-removed">5404   return offset() - block_start;</span>
<span class="line-removed">5405 }</span>
<span class="line-removed">5406 </span>
<span class="line-removed">5407 // kill: cnt1, cnt2, odd_reg, even_reg; early clobber: result</span>
<span class="line-removed">5408 unsigned int MacroAssembler::string_compare(Register str1, Register str2,</span>
<span class="line-removed">5409                                             Register cnt1, Register cnt2,</span>
<span class="line-removed">5410                                             Register odd_reg, Register even_reg, Register result, int ae) {</span>
<span class="line-removed">5411   int block_start = offset();</span>
<span class="line-removed">5412 </span>
<span class="line-removed">5413   assert_different_registers(str1, cnt1, cnt2, odd_reg, even_reg, result);</span>
<span class="line-removed">5414   assert_different_registers(str2, cnt1, cnt2, odd_reg, even_reg, result);</span>
<span class="line-removed">5415 </span>
<span class="line-removed">5416   // If strings are equal up to min length, return the length difference.</span>
<span class="line-removed">5417   const Register diff = result, // Pre-set result with length difference.</span>
<span class="line-removed">5418                  min  = cnt1,   // min number of bytes</span>
<span class="line-removed">5419                  tmp  = cnt2;</span>
<span class="line-removed">5420 </span>
<span class="line-removed">5421   // Note: Making use of the fact that compareTo(a, b) == -compareTo(b, a)</span>
<span class="line-removed">5422   // we interchange str1 and str2 in the UL case and negate the result.</span>
<span class="line-removed">5423   // Like this, str1 is always latin1 encoded, except for the UU case.</span>
<span class="line-removed">5424   // In addition, we need 0 (or sign which is 0) extend when using 64 bit register.</span>
<span class="line-removed">5425   const bool used_as_LU = (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL);</span>
<span class="line-removed">5426 </span>
<span class="line-removed">5427   BLOCK_COMMENT(&quot;string_compare {&quot;);</span>
<span class="line-removed">5428 </span>
<span class="line-removed">5429   if (used_as_LU) {</span>
<span class="line-removed">5430     z_srl(cnt2, 1);</span>
<span class="line-removed">5431   }</span>
<span class="line-removed">5432 </span>
<span class="line-removed">5433   // See if the lengths are different, and calculate min in cnt1.</span>
<span class="line-removed">5434   // Save diff in case we need it for a tie-breaker.</span>
<span class="line-removed">5435 </span>
<span class="line-removed">5436   // diff = cnt1 - cnt2</span>
<span class="line-removed">5437   if (VM_Version::has_DistinctOpnds()) {</span>
<span class="line-removed">5438     z_srk(diff, cnt1, cnt2);</span>
<span class="line-removed">5439   } else {</span>
<span class="line-removed">5440     z_lr(diff, cnt1);</span>
<span class="line-removed">5441     z_sr(diff, cnt2);</span>
<span class="line-removed">5442   }</span>
<span class="line-removed">5443   if (str1 != str2) {</span>
<span class="line-removed">5444     if (VM_Version::has_LoadStoreConditional()) {</span>
<span class="line-removed">5445       z_locr(min, cnt2, Assembler::bcondHigh);</span>
<span class="line-removed">5446     } else {</span>
<span class="line-removed">5447       Label Lskip;</span>
<span class="line-removed">5448       z_brl(Lskip);    // min ok if cnt1 &lt; cnt2</span>
<span class="line-removed">5449       z_lr(min, cnt2); // min = cnt2</span>
<span class="line-removed">5450       bind(Lskip);</span>
<span class="line-removed">5451     }</span>
<span class="line-removed">5452   }</span>
<span class="line-removed">5453 </span>
<span class="line-removed">5454   if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">5455     z_sra(diff, 1);</span>
<span class="line-removed">5456   }</span>
<span class="line-removed">5457   if (str1 != str2) {</span>
<span class="line-removed">5458     Label Ldone;</span>
<span class="line-removed">5459     if (used_as_LU) {</span>
<span class="line-removed">5460       // Loop which searches the first difference character by character.</span>
<span class="line-removed">5461       Label Lloop;</span>
<span class="line-removed">5462       const Register ind1 = Z_R1,</span>
<span class="line-removed">5463                      ind2 = min;</span>
<span class="line-removed">5464       int stride1 = 1, stride2 = 2; // See comment above.</span>
<span class="line-removed">5465 </span>
<span class="line-removed">5466       // ind1: index, even_reg: index increment, odd_reg: index limit</span>
<span class="line-removed">5467       z_llilf(ind1, (unsigned int)(-stride1));</span>
<span class="line-removed">5468       z_lhi(even_reg, stride1);</span>
<span class="line-removed">5469       add2reg(odd_reg, -stride1, min);</span>
<span class="line-removed">5470       clear_reg(ind2); // kills min</span>
<span class="line-removed">5471 </span>
<span class="line-removed">5472       bind(Lloop);</span>
<span class="line-removed">5473       z_brxh(ind1, even_reg, Ldone);</span>
<span class="line-removed">5474       z_llc(tmp, Address(str1, ind1));</span>
<span class="line-removed">5475       z_llh(Z_R0, Address(str2, ind2));</span>
<span class="line-removed">5476       z_ahi(ind2, stride2);</span>
<span class="line-removed">5477       z_sr(tmp, Z_R0);</span>
<span class="line-removed">5478       z_bre(Lloop);</span>
<span class="line-removed">5479 </span>
<span class="line-removed">5480       z_lr(result, tmp);</span>
<span class="line-removed">5481 </span>
<span class="line-removed">5482     } else {</span>
<span class="line-removed">5483       // Use clcle in fast loop (only for same encoding).</span>
<span class="line-removed">5484       z_lgr(Z_R0, str1);</span>
<span class="line-removed">5485       z_lgr(even_reg, str2);</span>
<span class="line-removed">5486       z_llgfr(Z_R1, min);</span>
<span class="line-removed">5487       z_llgfr(odd_reg, min);</span>
<span class="line-removed">5488 </span>
<span class="line-removed">5489       if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed">5490         compare_long_ext(Z_R0, even_reg, 0);</span>
<span class="line-removed">5491       } else {</span>
<span class="line-removed">5492         compare_long_uni(Z_R0, even_reg, 0);</span>
<span class="line-removed">5493       }</span>
<span class="line-removed">5494       z_bre(Ldone);</span>
<span class="line-removed">5495       z_lgr(Z_R1, Z_R0);</span>
<span class="line-removed">5496       if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed">5497         z_llc(Z_R0, Address(even_reg));</span>
<span class="line-removed">5498         z_llc(result, Address(Z_R1));</span>
<span class="line-removed">5499       } else {</span>
<span class="line-removed">5500         z_llh(Z_R0, Address(even_reg));</span>
<span class="line-removed">5501         z_llh(result, Address(Z_R1));</span>
<span class="line-removed">5502       }</span>
<span class="line-removed">5503       z_sr(result, Z_R0);</span>
<span class="line-removed">5504     }</span>
<span class="line-removed">5505 </span>
<span class="line-removed">5506     // Otherwise, return the difference between the first mismatched chars.</span>
<span class="line-removed">5507     bind(Ldone);</span>
<span class="line-removed">5508   }</span>
<span class="line-removed">5509 </span>
<span class="line-removed">5510   if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">5511     z_lcr(result, result); // Negate result (see note above).</span>
<span class="line-removed">5512   }</span>
<span class="line-removed">5513 </span>
<span class="line-removed">5514   BLOCK_COMMENT(&quot;} string_compare&quot;);</span>
<span class="line-removed">5515 </span>
<span class="line-removed">5516   return offset() - block_start;</span>
<span class="line-removed">5517 }</span>
<span class="line-removed">5518 </span>
<span class="line-removed">5519 unsigned int MacroAssembler::array_equals(bool is_array_equ, Register ary1, Register ary2, Register limit,</span>
<span class="line-removed">5520                                           Register odd_reg, Register even_reg, Register result, bool is_byte) {</span>
<span class="line-removed">5521   int block_start = offset();</span>
<span class="line-removed">5522 </span>
<span class="line-removed">5523   BLOCK_COMMENT(&quot;array_equals {&quot;);</span>
<span class="line-removed">5524 </span>
<span class="line-removed">5525   assert_different_registers(ary1, limit, odd_reg, even_reg);</span>
<span class="line-removed">5526   assert_different_registers(ary2, limit, odd_reg, even_reg);</span>
<span class="line-removed">5527 </span>
<span class="line-removed">5528   Label Ldone, Ldone_true, Ldone_false, Lclcle, CLC_template;</span>
<span class="line-removed">5529   int base_offset = 0;</span>
<span class="line-removed">5530 </span>
<span class="line-removed">5531   if (ary1 != ary2) {</span>
<span class="line-removed">5532     if (is_array_equ) {</span>
<span class="line-removed">5533       base_offset = arrayOopDesc::base_offset_in_bytes(is_byte ? T_BYTE : T_CHAR);</span>
<span class="line-removed">5534 </span>
<span class="line-removed">5535       // Return true if the same array.</span>
<span class="line-removed">5536       compareU64_and_branch(ary1, ary2, Assembler::bcondEqual, Ldone_true);</span>
<span class="line-removed">5537 </span>
<span class="line-removed">5538       // Return false if one of them is NULL.</span>
<span class="line-removed">5539       compareU64_and_branch(ary1, (intptr_t)0, Assembler::bcondEqual, Ldone_false);</span>
<span class="line-removed">5540       compareU64_and_branch(ary2, (intptr_t)0, Assembler::bcondEqual, Ldone_false);</span>
<span class="line-removed">5541 </span>
<span class="line-removed">5542       // Load the lengths of arrays.</span>
<span class="line-removed">5543       z_llgf(odd_reg, Address(ary1, arrayOopDesc::length_offset_in_bytes()));</span>
<span class="line-removed">5544 </span>
<span class="line-removed">5545       // Return false if the two arrays are not equal length.</span>
<span class="line-removed">5546       z_c(odd_reg, Address(ary2, arrayOopDesc::length_offset_in_bytes()));</span>
<span class="line-removed">5547       z_brne(Ldone_false);</span>
<span class="line-removed">5548 </span>
<span class="line-removed">5549       // string len in bytes (right operand)</span>
<span class="line-removed">5550       if (!is_byte) {</span>
<span class="line-removed">5551         z_chi(odd_reg, 128);</span>
<span class="line-removed">5552         z_sll(odd_reg, 1); // preserves flags</span>
<span class="line-removed">5553         z_brh(Lclcle);</span>
<span class="line-removed">5554       } else {</span>
<span class="line-removed">5555         compareU32_and_branch(odd_reg, (intptr_t)256, Assembler::bcondHigh, Lclcle);</span>
<span class="line-removed">5556       }</span>
<span class="line-removed">5557     } else {</span>
<span class="line-removed">5558       z_llgfr(odd_reg, limit); // Need to zero-extend prior to using the value.</span>
<span class="line-removed">5559       compareU32_and_branch(limit, (intptr_t)256, Assembler::bcondHigh, Lclcle);</span>
<span class="line-removed">5560     }</span>
<span class="line-removed">5561 </span>
<span class="line-removed">5562 </span>
<span class="line-removed">5563     // Use clc instruction for up to 256 bytes.</span>
<span class="line-removed">5564     {</span>
<span class="line-removed">5565       Register str1_reg = ary1,</span>
<span class="line-removed">5566           str2_reg = ary2;</span>
<span class="line-removed">5567       if (is_array_equ) {</span>
<span class="line-removed">5568         str1_reg = Z_R1;</span>
<span class="line-removed">5569         str2_reg = even_reg;</span>
<span class="line-removed">5570         add2reg(str1_reg, base_offset, ary1); // string addr (left operand)</span>
<span class="line-removed">5571         add2reg(str2_reg, base_offset, ary2); // string addr (right operand)</span>
<span class="line-removed">5572       }</span>
<span class="line-removed">5573       z_ahi(odd_reg, -1); // Clc uses decremented limit. Also compare result to 0.</span>
<span class="line-removed">5574       z_brl(Ldone_true);</span>
<span class="line-removed">5575       // Note: We could jump to the template if equal.</span>
<span class="line-removed">5576 </span>
<span class="line-removed">5577       assert(VM_Version::has_ExecuteExtensions(), &quot;unsupported hardware&quot;);</span>
<span class="line-removed">5578       z_exrl(odd_reg, CLC_template);</span>
<span class="line-removed">5579       z_bre(Ldone_true);</span>
<span class="line-removed">5580       // fall through</span>
<span class="line-removed">5581 </span>
<span class="line-removed">5582       bind(Ldone_false);</span>
<span class="line-removed">5583       clear_reg(result);</span>
<span class="line-removed">5584       z_bru(Ldone);</span>
<span class="line-removed">5585 </span>
<span class="line-removed">5586       bind(CLC_template);</span>
<span class="line-removed">5587       z_clc(0, 0, str1_reg, 0, str2_reg);</span>
<span class="line-removed">5588     }</span>
<span class="line-removed">5589 </span>
<span class="line-removed">5590     // Use clcle instruction.</span>
<span class="line-removed">5591     {</span>
<span class="line-removed">5592       bind(Lclcle);</span>
<span class="line-removed">5593       add2reg(even_reg, base_offset, ary2); // string addr (right operand)</span>
<span class="line-removed">5594       add2reg(Z_R0, base_offset, ary1);     // string addr (left operand)</span>
<span class="line-removed">5595 </span>
<span class="line-removed">5596       z_lgr(Z_R1, odd_reg); // string len in bytes (left operand)</span>
<span class="line-removed">5597       if (is_byte) {</span>
<span class="line-removed">5598         compare_long_ext(Z_R0, even_reg, 0);</span>
<span class="line-removed">5599       } else {</span>
<span class="line-removed">5600         compare_long_uni(Z_R0, even_reg, 0);</span>
<span class="line-removed">5601       }</span>
<span class="line-removed">5602       z_lghi(result, 0); // Preserve flags.</span>
<span class="line-removed">5603       z_brne(Ldone);</span>
<span class="line-removed">5604     }</span>
<span class="line-removed">5605   }</span>
<span class="line-removed">5606   // fall through</span>
<span class="line-removed">5607 </span>
<span class="line-removed">5608   bind(Ldone_true);</span>
<span class="line-removed">5609   z_lghi(result, 1); // All characters are equal.</span>
<span class="line-removed">5610   bind(Ldone);</span>
<span class="line-removed">5611 </span>
<span class="line-removed">5612   BLOCK_COMMENT(&quot;} array_equals&quot;);</span>
<span class="line-removed">5613 </span>
<span class="line-removed">5614   return offset() - block_start;</span>
<span class="line-removed">5615 }</span>
<span class="line-removed">5616 </span>
<span class="line-removed">5617 // kill: haycnt, needlecnt, odd_reg, even_reg; early clobber: result</span>
<span class="line-removed">5618 unsigned int MacroAssembler::string_indexof(Register result, Register haystack, Register haycnt,</span>
<span class="line-removed">5619                                             Register needle, Register needlecnt, int needlecntval,</span>
<span class="line-removed">5620                                             Register odd_reg, Register even_reg, int ae) {</span>
<span class="line-removed">5621   int block_start = offset();</span>
<span class="line-removed">5622 </span>
<span class="line-removed">5623   // Ensure 0&lt;needlecnt&lt;=haycnt in ideal graph as prerequisite!</span>
<span class="line-removed">5624   assert(ae != StrIntrinsicNode::LU, &quot;Invalid encoding&quot;);</span>
<span class="line-removed">5625   const int h_csize = (ae == StrIntrinsicNode::LL) ? 1 : 2;</span>
<span class="line-removed">5626   const int n_csize = (ae == StrIntrinsicNode::UU) ? 2 : 1;</span>
<span class="line-removed">5627   Label L_needle1, L_Found, L_NotFound;</span>
<span class="line-removed">5628 </span>
<span class="line-removed">5629   BLOCK_COMMENT(&quot;string_indexof {&quot;);</span>
<span class="line-removed">5630 </span>
<span class="line-removed">5631   if (needle == haystack) {</span>
<span class="line-removed">5632     z_lhi(result, 0);</span>
<span class="line-removed">5633   } else {</span>
<span class="line-removed">5634 </span>
<span class="line-removed">5635   // Load first character of needle (R0 used by search_string instructions).</span>
<span class="line-removed">5636   if (n_csize == 2) { z_llgh(Z_R0, Address(needle)); } else { z_llgc(Z_R0, Address(needle)); }</span>
<span class="line-removed">5637 </span>
<span class="line-removed">5638   // Compute last haystack addr to use if no match gets found.</span>
<span class="line-removed">5639   if (needlecnt != noreg) { // variable needlecnt</span>
<span class="line-removed">5640     z_ahi(needlecnt, -1); // Remaining characters after first one.</span>
<span class="line-removed">5641     z_sr(haycnt, needlecnt); // Compute index succeeding last element to compare.</span>
<span class="line-removed">5642     if (n_csize == 2) { z_sll(needlecnt, 1); } // In bytes.</span>
<span class="line-removed">5643   } else { // constant needlecnt</span>
<span class="line-removed">5644     assert((needlecntval &amp; 0x7fff) == needlecntval, &quot;must be positive simm16 immediate&quot;);</span>
<span class="line-removed">5645     // Compute index succeeding last element to compare.</span>
<span class="line-removed">5646     if (needlecntval != 1) { z_ahi(haycnt, 1 - needlecntval); }</span>
<span class="line-removed">5647   }</span>
<span class="line-removed">5648 </span>
<span class="line-removed">5649   z_llgfr(haycnt, haycnt); // Clear high half.</span>
<span class="line-removed">5650   z_lgr(result, haystack); // Final result will be computed from needle start pointer.</span>
<span class="line-removed">5651   if (h_csize == 2) { z_sll(haycnt, 1); } // Scale to number of bytes.</span>
<span class="line-removed">5652   z_agr(haycnt, haystack); // Point to address succeeding last element (haystack+scale*(haycnt-needlecnt+1)).</span>
<span class="line-removed">5653 </span>
<span class="line-removed">5654   if (h_csize != n_csize) {</span>
<span class="line-removed">5655     assert(ae == StrIntrinsicNode::UL, &quot;Invalid encoding&quot;);</span>
<span class="line-removed">5656 </span>
<span class="line-removed">5657     if (needlecnt != noreg || needlecntval != 1) {</span>
<span class="line-removed">5658       if (needlecnt != noreg) {</span>
<span class="line-removed">5659         compare32_and_branch(needlecnt, (intptr_t)0, Assembler::bcondEqual, L_needle1);</span>
<span class="line-removed">5660       }</span>
<span class="line-removed">5661 </span>
<span class="line-removed">5662       // Main Loop: UL version (now we have at least 2 characters).</span>
<span class="line-removed">5663       Label L_OuterLoop, L_InnerLoop, L_Skip;</span>
<span class="line-removed">5664       bind(L_OuterLoop); // Search for 1st 2 characters.</span>
<span class="line-removed">5665       z_lgr(Z_R1, haycnt);</span>
<span class="line-removed">5666       MacroAssembler::search_string_uni(Z_R1, result);</span>
<span class="line-removed">5667       z_brc(Assembler::bcondNotFound, L_NotFound);</span>
<span class="line-removed">5668       z_lgr(result, Z_R1);</span>
<span class="line-removed">5669 </span>
<span class="line-removed">5670       z_lghi(Z_R1, n_csize);</span>
<span class="line-removed">5671       z_lghi(even_reg, h_csize);</span>
<span class="line-removed">5672       bind(L_InnerLoop);</span>
<span class="line-removed">5673       z_llgc(odd_reg, Address(needle, Z_R1));</span>
<span class="line-removed">5674       z_ch(odd_reg, Address(result, even_reg));</span>
<span class="line-removed">5675       z_brne(L_Skip);</span>
<span class="line-removed">5676       if (needlecnt != noreg) { z_cr(Z_R1, needlecnt); } else { z_chi(Z_R1, needlecntval - 1); }</span>
<span class="line-removed">5677       z_brnl(L_Found);</span>
<span class="line-removed">5678       z_aghi(Z_R1, n_csize);</span>
<span class="line-removed">5679       z_aghi(even_reg, h_csize);</span>
<span class="line-removed">5680       z_bru(L_InnerLoop);</span>
<span class="line-removed">5681 </span>
<span class="line-removed">5682       bind(L_Skip);</span>
<span class="line-removed">5683       z_aghi(result, h_csize); // This is the new address we want to use for comparing.</span>
<span class="line-removed">5684       z_bru(L_OuterLoop);</span>
<span class="line-removed">5685     }</span>
<span class="line-removed">5686 </span>
<span class="line-removed">5687   } else {</span>
<span class="line-removed">5688     const intptr_t needle_bytes = (n_csize == 2) ? ((needlecntval - 1) &lt;&lt; 1) : (needlecntval - 1);</span>
<span class="line-removed">5689     Label L_clcle;</span>
<span class="line-removed">5690 </span>
<span class="line-removed">5691     if (needlecnt != noreg || (needlecntval != 1 &amp;&amp; needle_bytes &lt;= 256)) {</span>
<span class="line-removed">5692       if (needlecnt != noreg) {</span>
<span class="line-removed">5693         compare32_and_branch(needlecnt, 256, Assembler::bcondHigh, L_clcle);</span>
<span class="line-removed">5694         z_ahi(needlecnt, -1); // remaining bytes -1 (for CLC)</span>
<span class="line-removed">5695         z_brl(L_needle1);</span>
<span class="line-removed">5696       }</span>
<span class="line-removed">5697 </span>
<span class="line-removed">5698       // Main Loop: clc version (now we have at least 2 characters).</span>
<span class="line-removed">5699       Label L_OuterLoop, CLC_template;</span>
<span class="line-removed">5700       bind(L_OuterLoop); // Search for 1st 2 characters.</span>
<span class="line-removed">5701       z_lgr(Z_R1, haycnt);</span>
<span class="line-removed">5702       if (h_csize == 1) {</span>
<span class="line-removed">5703         MacroAssembler::search_string(Z_R1, result);</span>
<span class="line-removed">5704       } else {</span>
<span class="line-removed">5705         MacroAssembler::search_string_uni(Z_R1, result);</span>
<span class="line-removed">5706       }</span>
<span class="line-removed">5707       z_brc(Assembler::bcondNotFound, L_NotFound);</span>
<span class="line-removed">5708       z_lgr(result, Z_R1);</span>
<span class="line-removed">5709 </span>
<span class="line-removed">5710       if (needlecnt != noreg) {</span>
<span class="line-removed">5711         assert(VM_Version::has_ExecuteExtensions(), &quot;unsupported hardware&quot;);</span>
<span class="line-removed">5712         z_exrl(needlecnt, CLC_template);</span>
<span class="line-removed">5713       } else {</span>
<span class="line-removed">5714         z_clc(h_csize, needle_bytes -1, Z_R1, n_csize, needle);</span>
<span class="line-removed">5715       }</span>
<span class="line-removed">5716       z_bre(L_Found);</span>
<span class="line-removed">5717       z_aghi(result, h_csize); // This is the new address we want to use for comparing.</span>
<span class="line-removed">5718       z_bru(L_OuterLoop);</span>
<span class="line-removed">5719 </span>
<span class="line-removed">5720       if (needlecnt != noreg) {</span>
<span class="line-removed">5721         bind(CLC_template);</span>
<span class="line-removed">5722         z_clc(h_csize, 0, Z_R1, n_csize, needle);</span>
<span class="line-removed">5723       }</span>
<span class="line-removed">5724     }</span>
<span class="line-removed">5725 </span>
<span class="line-removed">5726     if (needlecnt != noreg || needle_bytes &gt; 256) {</span>
<span class="line-removed">5727       bind(L_clcle);</span>
<span class="line-removed">5728 </span>
<span class="line-removed">5729       // Main Loop: clcle version (now we have at least 256 bytes).</span>
<span class="line-removed">5730       Label L_OuterLoop, CLC_template;</span>
<span class="line-removed">5731       bind(L_OuterLoop); // Search for 1st 2 characters.</span>
<span class="line-removed">5732       z_lgr(Z_R1, haycnt);</span>
<span class="line-removed">5733       if (h_csize == 1) {</span>
<span class="line-removed">5734         MacroAssembler::search_string(Z_R1, result);</span>
<span class="line-removed">5735       } else {</span>
<span class="line-removed">5736         MacroAssembler::search_string_uni(Z_R1, result);</span>
<span class="line-removed">5737       }</span>
<span class="line-removed">5738       z_brc(Assembler::bcondNotFound, L_NotFound);</span>
<span class="line-removed">5739 </span>
<span class="line-removed">5740       add2reg(Z_R0, n_csize, needle);</span>
<span class="line-removed">5741       add2reg(even_reg, h_csize, Z_R1);</span>
<span class="line-removed">5742       z_lgr(result, Z_R1);</span>
<span class="line-removed">5743       if (needlecnt != noreg) {</span>
<span class="line-removed">5744         z_llgfr(Z_R1, needlecnt); // needle len in bytes (left operand)</span>
<span class="line-removed">5745         z_llgfr(odd_reg, needlecnt);</span>
<span class="line-removed">5746       } else {</span>
<span class="line-removed">5747         load_const_optimized(Z_R1, needle_bytes);</span>
<span class="line-removed">5748         if (Immediate::is_simm16(needle_bytes)) { z_lghi(odd_reg, needle_bytes); } else { z_lgr(odd_reg, Z_R1); }</span>
<span class="line-removed">5749       }</span>
<span class="line-removed">5750       if (h_csize == 1) {</span>
<span class="line-removed">5751         compare_long_ext(Z_R0, even_reg, 0);</span>
<span class="line-removed">5752       } else {</span>
<span class="line-removed">5753         compare_long_uni(Z_R0, even_reg, 0);</span>
<span class="line-removed">5754       }</span>
<span class="line-removed">5755       z_bre(L_Found);</span>
<span class="line-removed">5756 </span>
<span class="line-removed">5757       if (n_csize == 2) { z_llgh(Z_R0, Address(needle)); } else { z_llgc(Z_R0, Address(needle)); } // Reload.</span>
<span class="line-removed">5758       z_aghi(result, h_csize); // This is the new address we want to use for comparing.</span>
<span class="line-removed">5759       z_bru(L_OuterLoop);</span>
<span class="line-removed">5760     }</span>
<span class="line-removed">5761   }</span>
<span class="line-removed">5762 </span>
<span class="line-removed">5763   if (needlecnt != noreg || needlecntval == 1) {</span>
<span class="line-removed">5764     bind(L_needle1);</span>
<span class="line-removed">5765 </span>
<span class="line-removed">5766     // Single needle character version.</span>
<span class="line-removed">5767     if (h_csize == 1) {</span>
<span class="line-removed">5768       MacroAssembler::search_string(haycnt, result);</span>
<span class="line-removed">5769     } else {</span>
<span class="line-removed">5770       MacroAssembler::search_string_uni(haycnt, result);</span>
<span class="line-removed">5771     }</span>
<span class="line-removed">5772     z_lgr(result, haycnt);</span>
<span class="line-removed">5773     z_brc(Assembler::bcondFound, L_Found);</span>
<span class="line-removed">5774   }</span>
<span class="line-removed">5775 </span>
<span class="line-removed">5776   bind(L_NotFound);</span>
<span class="line-removed">5777   add2reg(result, -1, haystack); // Return -1.</span>
<span class="line-removed">5778 </span>
<span class="line-removed">5779   bind(L_Found); // Return index (or -1 in fallthrough case).</span>
<span class="line-removed">5780   z_sgr(result, haystack);</span>
<span class="line-removed">5781   if (h_csize == 2) { z_srag(result, result, exact_log2(sizeof(jchar))); }</span>
<span class="line-removed">5782   }</span>
<span class="line-removed">5783   BLOCK_COMMENT(&quot;} string_indexof&quot;);</span>
<span class="line-removed">5784 </span>
<span class="line-removed">5785   return offset() - block_start;</span>
<span class="line-removed">5786 }</span>
<span class="line-removed">5787 </span>
<span class="line-removed">5788 // early clobber: result</span>
<span class="line-removed">5789 unsigned int MacroAssembler::string_indexof_char(Register result, Register haystack, Register haycnt,</span>
<span class="line-removed">5790                                                  Register needle, jchar needleChar, Register odd_reg, Register even_reg, bool is_byte) {</span>
<span class="line-removed">5791   int block_start = offset();</span>
<span class="line-removed">5792 </span>
<span class="line-removed">5793   BLOCK_COMMENT(&quot;string_indexof_char {&quot;);</span>
<span class="line-removed">5794 </span>
<span class="line-removed">5795   if (needle == haystack) {</span>
<span class="line-removed">5796     z_lhi(result, 0);</span>
<span class="line-removed">5797   } else {</span>
<span class="line-removed">5798 </span>
<span class="line-removed">5799   Label Ldone;</span>
<span class="line-removed">5800 </span>
<span class="line-removed">5801   z_llgfr(odd_reg, haycnt);  // Preset loop ctr/searchrange end.</span>
<span class="line-removed">5802   if (needle == noreg) {</span>
<span class="line-removed">5803     load_const_optimized(Z_R0, (unsigned long)needleChar);</span>
<span class="line-removed">5804   } else {</span>
<span class="line-removed">5805     if (is_byte) {</span>
<span class="line-removed">5806       z_llgcr(Z_R0, needle); // First (and only) needle char.</span>
<span class="line-removed">5807     } else {</span>
<span class="line-removed">5808       z_llghr(Z_R0, needle); // First (and only) needle char.</span>
<span class="line-removed">5809     }</span>
<span class="line-removed">5810   }</span>
<span class="line-removed">5811 </span>
<span class="line-removed">5812   if (!is_byte) {</span>
<span class="line-removed">5813     z_agr(odd_reg, odd_reg); // Calc #bytes to be processed with SRSTU.</span>
<span class="line-removed">5814   }</span>
<span class="line-removed">5815 </span>
<span class="line-removed">5816   z_lgr(even_reg, haystack); // haystack addr</span>
<span class="line-removed">5817   z_agr(odd_reg, haystack);  // First char after range end.</span>
<span class="line-removed">5818   z_lghi(result, -1);</span>
<span class="line-removed">5819 </span>
<span class="line-removed">5820   if (is_byte) {</span>
<span class="line-removed">5821     MacroAssembler::search_string(odd_reg, even_reg);</span>
<span class="line-removed">5822   } else {</span>
<span class="line-removed">5823     MacroAssembler::search_string_uni(odd_reg, even_reg);</span>
<span class="line-removed">5824   }</span>
<span class="line-removed">5825   z_brc(Assembler::bcondNotFound, Ldone);</span>
<span class="line-removed">5826   if (is_byte) {</span>
<span class="line-removed">5827     if (VM_Version::has_DistinctOpnds()) {</span>
<span class="line-removed">5828       z_sgrk(result, odd_reg, haystack);</span>
<span class="line-removed">5829     } else {</span>
<span class="line-removed">5830       z_sgr(odd_reg, haystack);</span>
<span class="line-removed">5831       z_lgr(result, odd_reg);</span>
<span class="line-removed">5832     }</span>
<span class="line-removed">5833   } else {</span>
<span class="line-removed">5834     z_slgr(odd_reg, haystack);</span>
<span class="line-removed">5835     z_srlg(result, odd_reg, exact_log2(sizeof(jchar)));</span>
<span class="line-removed">5836   }</span>
<span class="line-removed">5837 </span>
<span class="line-removed">5838   bind(Ldone);</span>
<span class="line-removed">5839   }</span>
<span class="line-removed">5840   BLOCK_COMMENT(&quot;} string_indexof_char&quot;);</span>
<span class="line-removed">5841 </span>
<span class="line-removed">5842   return offset() - block_start;</span>
<span class="line-removed">5843 }</span>
<span class="line-removed">5844 #endif</span>
<span class="line-removed">5845 </span>
5846 //-------------------------------------------------
5847 //   Constants (scalar and oop) in constant pool
5848 //-------------------------------------------------
5849 
5850 // Add a non-relocated constant to the CP.
5851 int MacroAssembler::store_const_in_toc(AddressLiteral&amp; val) {
5852   long    value  = val.value();
5853   address tocPos = long_constant(value);
5854 
5855   if (tocPos != NULL) {
5856     int tocOffset = (int)(tocPos - code()-&gt;consts()-&gt;start());
5857     return tocOffset;
5858   }
5859   // Address_constant returned NULL, so no constant entry has been created.
5860   // In that case, we return a &quot;fatal&quot; offset, just in case that subsequently
5861   // generated access code is executed.
5862   return -1;
5863 }
5864 
5865 // Returns the TOC offset where the address is stored.
</pre>
</td>
<td>
<hr />
<pre>
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/codeBuffer.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  32 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  35 #include &quot;memory/resourceArea.hpp&quot;
  36 #include &quot;memory/universe.hpp&quot;
  37 #include &quot;oops/accessDecorators.hpp&quot;
  38 #include &quot;oops/compressedOops.inline.hpp&quot;
  39 #include &quot;oops/klass.inline.hpp&quot;





  40 #include &quot;prims/methodHandles.hpp&quot;
  41 #include &quot;registerSaver_s390.hpp&quot;
  42 #include &quot;runtime/biasedLocking.hpp&quot;
  43 #include &quot;runtime/icache.hpp&quot;
  44 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  45 #include &quot;runtime/objectMonitor.hpp&quot;
  46 #include &quot;runtime/os.hpp&quot;
  47 #include &quot;runtime/safepoint.hpp&quot;
  48 #include &quot;runtime/safepointMechanism.hpp&quot;
  49 #include &quot;runtime/sharedRuntime.hpp&quot;
  50 #include &quot;runtime/stubRoutines.hpp&quot;
  51 #include &quot;utilities/events.hpp&quot;
  52 #include &quot;utilities/macros.hpp&quot;
  53 #include &quot;utilities/powerOfTwo.hpp&quot;
  54 
  55 #include &lt;ucontext.h&gt;
  56 
  57 #define BLOCK_COMMENT(str) block_comment(str)
  58 #define BIND(label)        bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  59 
</pre>
<hr />
<pre>
4571     z_pfd(1,  0,Z_R0,src_reg);
4572     z_pfd(2,  0,Z_R0,dst_reg);
4573     //    z_pfd(1,256,Z_R0,src_reg);    // Assume very short copy.
4574     //    z_pfd(2,256,Z_R0,dst_reg);
4575   }
4576 
4577   if (VM_Version::has_ExecuteExtensions()) {
4578     z_exrl(Z_R1, MVC_template);
4579   } else {
4580     z_ex(tmp1_reg, 0, Z_R0, Z_R1);
4581   }
4582 
4583   bind(done);
4584 
4585   BLOCK_COMMENT(&quot;} CopyRawMemory_AlignedDisjoint&quot;);
4586 
4587   int block_end = offset();
4588   return block_end - block_start;
4589 }
4590 


































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































4591 //-------------------------------------------------
4592 //   Constants (scalar and oop) in constant pool
4593 //-------------------------------------------------
4594 
4595 // Add a non-relocated constant to the CP.
4596 int MacroAssembler::store_const_in_toc(AddressLiteral&amp; val) {
4597   long    value  = val.value();
4598   address tocPos = long_constant(value);
4599 
4600   if (tocPos != NULL) {
4601     int tocOffset = (int)(tocPos - code()-&gt;consts()-&gt;start());
4602     return tocOffset;
4603   }
4604   // Address_constant returned NULL, so no constant entry has been created.
4605   // In that case, we return a &quot;fatal&quot; offset, just in case that subsequently
4606   // generated access code is executed.
4607   return -1;
4608 }
4609 
4610 // Returns the TOC offset where the address is stored.
</pre>
</td>
</tr>
</table>
<center><a href="compiledIC_s390.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_s390.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
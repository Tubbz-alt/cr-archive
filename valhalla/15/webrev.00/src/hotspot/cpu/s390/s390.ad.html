<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/s390/s390.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
    1 //
    2 // Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
    3 // Copyright (c) 2017, 2019 SAP SE. All rights reserved.
    4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    5 //
    6 // This code is free software; you can redistribute it and/or modify it
    7 // under the terms of the GNU General Public License version 2 only, as
    8 // published by the Free Software Foundation.
    9 //
   10 // This code is distributed in the hope that it will be useful, but WITHOUT
   11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   13 // version 2 for more details (a copy is included in the LICENSE file that
   14 // accompanied this code).
   15 //
   16 // You should have received a copy of the GNU General Public License version
   17 // 2 along with this work; if not, write to the Free Software Foundation,
   18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   19 //
   20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   21 // or visit www.oracle.com if you need additional information or have any
   22 // questions.
   23 //
   24 
   25 // z/Architecture Architecture Description File
   26 
   27 // Major contributions by AS, JL, LS.
   28 
   29 //
   30 // Following information is derived from private mail communication
   31 // (Oct. 2011).
   32 //
   33 // General branch target alignment considerations
   34 //
   35 // z/Architecture does not imply a general branch target alignment requirement.
   36 // There are side effects and side considerations, though, which may
   37 // provide some performance benefit. These are:
   38 //  - Align branch target on octoword (32-byte) boundary
   39 //    On more recent models (from z9 on), I-fetch is done on a Octoword
   40 //    (32 bytes at a time) basis. To avoid I-fetching unnecessary
   41 //    instructions, branch targets should be 32-byte aligend. If this
   42 //    exact alingment cannot be achieved, having the branch target in
   43 //    the first doubleword still provides some benefit.
   44 //  - Avoid branch targets at the end of cache lines (&gt; 64 bytes distance).
   45 //    Sequential instruction prefetching after the branch target starts
   46 //    immediately after having fetched the octoword containing the
   47 //    branch target. When I-fetching crosses a cache line, there may be
   48 //    a small stall. The worst case: the branch target (at the end of
   49 //    a cache line) is a L1 I-cache miss and the next line as well.
   50 //    Then, the entire target line must be filled first (to contine at the
   51 //    branch target). Only then can the next sequential line be filled.
   52 //  - Avoid multiple poorly predicted branches in a row.
   53 //
   54 
   55 //----------REGISTER DEFINITION BLOCK------------------------------------------
   56 // This information is used by the matcher and the register allocator to
   57 // describe individual registers and classes of registers within the target
   58 // architecture.
   59 
   60 register %{
   61 
   62 //----------Architecture Description Register Definitions----------------------
   63 // General Registers
   64 // &quot;reg_def&quot; name (register save type, C convention save type,
   65 //                   ideal register type, encoding);
   66 //
   67 // Register Save Types:
   68 //
   69 //   NS  = No-Save:     The register allocator assumes that these registers
   70 //                      can be used without saving upon entry to the method, &amp;
   71 //                      that they do not need to be saved at call sites.
   72 //
   73 //   SOC = Save-On-Call: The register allocator assumes that these registers
   74 //                      can be used without saving upon entry to the method,
   75 //                      but that they must be saved at call sites.
   76 //
   77 //   SOE = Save-On-Entry: The register allocator assumes that these registers
   78 //                      must be saved before using them upon entry to the
   79 //                      method, but they do not need to be saved at call sites.
   80 //
   81 //   AS  = Always-Save: The register allocator assumes that these registers
   82 //                      must be saved before using them upon entry to the
   83 //                      method, &amp; that they must be saved at call sites.
   84 //
   85 // Ideal Register Type is used to determine how to save &amp; restore a
   86 // register. Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   87 // spilled with LoadP/StoreP. If the register supports both, use Op_RegI.
   88 //
   89 // The encoding number is the actual bit-pattern placed into the opcodes.
   90 
   91 // z/Architecture register definitions, based on the z/Architecture Principles
   92 // of Operation, 5th Edition, September 2005, and z/Linux Elf ABI Supplement,
   93 // 5th Edition, March 2001.
   94 //
   95 // For each 64-bit register we must define two registers: the register
   96 // itself, e.g. Z_R3, and a corresponding virtual other (32-bit-)&#39;half&#39;,
   97 // e.g. Z_R3_H, which is needed by the allocator, but is not used
   98 // for stores, loads, etc.
   99 
  100   // Integer/Long Registers
  101   // ----------------------------
  102 
  103   // z/Architecture has 16 64-bit integer registers.
  104 
  105   // types: v = volatile, nv = non-volatile, s = system
  106   reg_def Z_R0   (SOC, SOC, Op_RegI,  0, Z_R0-&gt;as_VMReg());   // v   scratch1
  107   reg_def Z_R0_H (SOC, SOC, Op_RegI, 99, Z_R0-&gt;as_VMReg()-&gt;next());
  108   reg_def Z_R1   (SOC, SOC, Op_RegI,  1, Z_R1-&gt;as_VMReg());   // v   scratch2
  109   reg_def Z_R1_H (SOC, SOC, Op_RegI, 99, Z_R1-&gt;as_VMReg()-&gt;next());
  110   reg_def Z_R2   (SOC, SOC, Op_RegI,  2, Z_R2-&gt;as_VMReg());   // v   iarg1 &amp; iret
  111   reg_def Z_R2_H (SOC, SOC, Op_RegI, 99, Z_R2-&gt;as_VMReg()-&gt;next());
  112   reg_def Z_R3   (SOC, SOC, Op_RegI,  3, Z_R3-&gt;as_VMReg());   // v   iarg2
  113   reg_def Z_R3_H (SOC, SOC, Op_RegI, 99, Z_R3-&gt;as_VMReg()-&gt;next());
  114   reg_def Z_R4   (SOC, SOC, Op_RegI,  4, Z_R4-&gt;as_VMReg());   // v   iarg3
  115   reg_def Z_R4_H (SOC, SOC, Op_RegI, 99, Z_R4-&gt;as_VMReg()-&gt;next());
  116   reg_def Z_R5   (SOC, SOC, Op_RegI,  5, Z_R5-&gt;as_VMReg());   // v   iarg4
  117   reg_def Z_R5_H (SOC, SOC, Op_RegI, 99, Z_R5-&gt;as_VMReg()-&gt;next());
  118   reg_def Z_R6   (SOC, SOE, Op_RegI,  6, Z_R6-&gt;as_VMReg());   // v   iarg5
  119   reg_def Z_R6_H (SOC, SOE, Op_RegI, 99, Z_R6-&gt;as_VMReg()-&gt;next());
  120   reg_def Z_R7   (SOC, SOE, Op_RegI,  7, Z_R7-&gt;as_VMReg());
  121   reg_def Z_R7_H (SOC, SOE, Op_RegI, 99, Z_R7-&gt;as_VMReg()-&gt;next());
  122   reg_def Z_R8   (SOC, SOE, Op_RegI,  8, Z_R8-&gt;as_VMReg());
  123   reg_def Z_R8_H (SOC, SOE, Op_RegI, 99, Z_R8-&gt;as_VMReg()-&gt;next());
  124   reg_def Z_R9   (SOC, SOE, Op_RegI,  9, Z_R9-&gt;as_VMReg());
  125   reg_def Z_R9_H (SOC, SOE, Op_RegI, 99, Z_R9-&gt;as_VMReg()-&gt;next());
  126   reg_def Z_R10  (SOC, SOE, Op_RegI, 10, Z_R10-&gt;as_VMReg());
  127   reg_def Z_R10_H(SOC, SOE, Op_RegI, 99, Z_R10-&gt;as_VMReg()-&gt;next());
  128   reg_def Z_R11  (SOC, SOE, Op_RegI, 11, Z_R11-&gt;as_VMReg());
  129   reg_def Z_R11_H(SOC, SOE, Op_RegI, 99, Z_R11-&gt;as_VMReg()-&gt;next());
  130   reg_def Z_R12  (SOC, SOE, Op_RegI, 12, Z_R12-&gt;as_VMReg());
  131   reg_def Z_R12_H(SOC, SOE, Op_RegI, 99, Z_R12-&gt;as_VMReg()-&gt;next());
  132   reg_def Z_R13  (SOC, SOE, Op_RegI, 13, Z_R13-&gt;as_VMReg());
  133   reg_def Z_R13_H(SOC, SOE, Op_RegI, 99, Z_R13-&gt;as_VMReg()-&gt;next());
  134   reg_def Z_R14  (NS,  NS,  Op_RegI, 14, Z_R14-&gt;as_VMReg());   // s  return_pc
  135   reg_def Z_R14_H(NS,  NS,  Op_RegI, 99, Z_R14-&gt;as_VMReg()-&gt;next());
  136   reg_def Z_R15  (NS,  NS,  Op_RegI, 15, Z_R15-&gt;as_VMReg());   // s  SP
  137   reg_def Z_R15_H(NS,  NS,  Op_RegI, 99, Z_R15-&gt;as_VMReg()-&gt;next());
  138 
  139   // Float/Double Registers
  140 
  141   // The rules of ADL require that double registers be defined in pairs.
  142   // Each pair must be two 32-bit values, but not necessarily a pair of
  143   // single float registers. In each pair, ADLC-assigned register numbers
  144   // must be adjacent, with the lower number even. Finally, when the
  145   // CPU stores such a register pair to memory, the word associated with
  146   // the lower ADLC-assigned number must be stored to the lower address.
  147 
  148   // z/Architecture has 16 64-bit floating-point registers. Each can store a single
  149   // or double precision floating-point value.
  150 
  151   // types: v = volatile, nv = non-volatile, s = system
  152   reg_def Z_F0   (SOC, SOC, Op_RegF,  0, Z_F0-&gt;as_VMReg());   // v   farg1 &amp; fret
  153   reg_def Z_F0_H (SOC, SOC, Op_RegF, 99, Z_F0-&gt;as_VMReg()-&gt;next());
  154   reg_def Z_F1   (SOC, SOC, Op_RegF,  1, Z_F1-&gt;as_VMReg());
  155   reg_def Z_F1_H (SOC, SOC, Op_RegF, 99, Z_F1-&gt;as_VMReg()-&gt;next());
  156   reg_def Z_F2   (SOC, SOC, Op_RegF,  2, Z_F2-&gt;as_VMReg());   // v   farg2
  157   reg_def Z_F2_H (SOC, SOC, Op_RegF, 99, Z_F2-&gt;as_VMReg()-&gt;next());
  158   reg_def Z_F3   (SOC, SOC, Op_RegF,  3, Z_F3-&gt;as_VMReg());
  159   reg_def Z_F3_H (SOC, SOC, Op_RegF, 99, Z_F3-&gt;as_VMReg()-&gt;next());
  160   reg_def Z_F4   (SOC, SOC, Op_RegF,  4, Z_F4-&gt;as_VMReg());   // v   farg3
  161   reg_def Z_F4_H (SOC, SOC, Op_RegF, 99, Z_F4-&gt;as_VMReg()-&gt;next());
  162   reg_def Z_F5   (SOC, SOC, Op_RegF,  5, Z_F5-&gt;as_VMReg());
  163   reg_def Z_F5_H (SOC, SOC, Op_RegF, 99, Z_F5-&gt;as_VMReg()-&gt;next());
  164   reg_def Z_F6   (SOC, SOC, Op_RegF,  6, Z_F6-&gt;as_VMReg());
  165   reg_def Z_F6_H (SOC, SOC, Op_RegF, 99, Z_F6-&gt;as_VMReg()-&gt;next());
  166   reg_def Z_F7   (SOC, SOC, Op_RegF,  7, Z_F7-&gt;as_VMReg());
  167   reg_def Z_F7_H (SOC, SOC, Op_RegF, 99, Z_F7-&gt;as_VMReg()-&gt;next());
  168   reg_def Z_F8   (SOC, SOE, Op_RegF,  8, Z_F8-&gt;as_VMReg());
  169   reg_def Z_F8_H (SOC, SOE, Op_RegF, 99, Z_F8-&gt;as_VMReg()-&gt;next());
  170   reg_def Z_F9   (SOC, SOE, Op_RegF,  9, Z_F9-&gt;as_VMReg());
  171   reg_def Z_F9_H (SOC, SOE, Op_RegF, 99, Z_F9-&gt;as_VMReg()-&gt;next());
  172   reg_def Z_F10  (SOC, SOE, Op_RegF, 10, Z_F10-&gt;as_VMReg());
  173   reg_def Z_F10_H(SOC, SOE, Op_RegF, 99, Z_F10-&gt;as_VMReg()-&gt;next());
  174   reg_def Z_F11  (SOC, SOE, Op_RegF, 11, Z_F11-&gt;as_VMReg());
  175   reg_def Z_F11_H(SOC, SOE, Op_RegF, 99, Z_F11-&gt;as_VMReg()-&gt;next());
  176   reg_def Z_F12  (SOC, SOE, Op_RegF, 12, Z_F12-&gt;as_VMReg());
  177   reg_def Z_F12_H(SOC, SOE, Op_RegF, 99, Z_F12-&gt;as_VMReg()-&gt;next());
  178   reg_def Z_F13  (SOC, SOE, Op_RegF, 13, Z_F13-&gt;as_VMReg());
  179   reg_def Z_F13_H(SOC, SOE, Op_RegF, 99, Z_F13-&gt;as_VMReg()-&gt;next());
  180   reg_def Z_F14  (SOC, SOE, Op_RegF, 14, Z_F14-&gt;as_VMReg());
  181   reg_def Z_F14_H(SOC, SOE, Op_RegF, 99, Z_F14-&gt;as_VMReg()-&gt;next());
  182   reg_def Z_F15  (SOC, SOE, Op_RegF, 15, Z_F15-&gt;as_VMReg());
  183   reg_def Z_F15_H(SOC, SOE, Op_RegF, 99, Z_F15-&gt;as_VMReg()-&gt;next());
  184 
  185 
  186   // Special Registers
  187 
  188   // Condition Codes Flag Registers
  189 
  190   // z/Architecture has the PSW (program status word) that contains
  191   // (among other information) the condition code. We treat this
  192   // part of the PSW as a condition register CR. It consists of 4
  193   // bits. Floating point instructions influence the same condition register CR.
  194 
  195   reg_def Z_CR(SOC, SOC, Op_RegFlags, 0, Z_CR-&gt;as_VMReg());   // volatile
  196 
  197 
  198 // Specify priority of register selection within phases of register
  199 // allocation. Highest priority is first. A useful heuristic is to
  200 // give registers a low priority when they are required by machine
  201 // instructions, and choose no-save registers before save-on-call, and
  202 // save-on-call before save-on-entry. Registers which participate in
  203 // fix calling sequences should come last. Registers which are used
  204 // as pairs must fall on an even boundary.
  205 
  206 // It&#39;s worth about 1% on SPEC geomean to get this right.
  207 
  208 // Chunk0, chunk1, and chunk2 form the MachRegisterNumbers enumeration
  209 // in adGlobals_s390.hpp which defines the &lt;register&gt;_num values, e.g.
  210 // Z_R3_num. Therefore, Z_R3_num may not be (and in reality is not)
  211 // the same as Z_R3-&gt;encoding()! Furthermore, we cannot make any
  212 // assumptions on ordering, e.g. Z_R3_num may be less than Z_R2_num.
  213 // Additionally, the function
  214 //   static enum RC rc_class(OptoReg::Name reg)
  215 // maps a given &lt;register&gt;_num value to its chunk type (except for flags)
  216 // and its current implementation relies on chunk0 and chunk1 having a
  217 // size of 64 each.
  218 
  219 alloc_class chunk0(
  220   // chunk0 contains *all* 32 integer registers halves.
  221 
  222   // potential SOE regs
  223   Z_R13,Z_R13_H,
  224   Z_R12,Z_R12_H,
  225   Z_R11,Z_R11_H,
  226   Z_R10,Z_R10_H,
  227 
  228   Z_R9,Z_R9_H,
  229   Z_R8,Z_R8_H,
  230   Z_R7,Z_R7_H,
  231 
  232   Z_R1,Z_R1_H,
  233   Z_R0,Z_R0_H,
  234 
  235   // argument registers
  236   Z_R6,Z_R6_H,
  237   Z_R5,Z_R5_H,
  238   Z_R4,Z_R4_H,
  239   Z_R3,Z_R3_H,
  240   Z_R2,Z_R2_H,
  241 
  242   // special registers
  243   Z_R14,Z_R14_H,
  244   Z_R15,Z_R15_H
  245 );
  246 
  247 alloc_class chunk1(
  248   // Chunk1 contains *all* 64 floating-point registers halves.
  249 
  250   Z_F15,Z_F15_H,
  251   Z_F14,Z_F14_H,
  252   Z_F13,Z_F13_H,
  253   Z_F12,Z_F12_H,
  254   Z_F11,Z_F11_H,
  255   Z_F10,Z_F10_H,
  256   Z_F9,Z_F9_H,
  257   Z_F8,Z_F8_H,
  258   // scratch register
  259   Z_F7,Z_F7_H,
  260   Z_F5,Z_F5_H,
  261   Z_F3,Z_F3_H,
  262   Z_F1,Z_F1_H,
  263   // argument registers
  264   Z_F6,Z_F6_H,
  265   Z_F4,Z_F4_H,
  266   Z_F2,Z_F2_H,
  267   Z_F0,Z_F0_H
  268 );
  269 
  270 alloc_class chunk2(
  271   Z_CR
  272 );
  273 
  274 
  275 //-------Architecture Description Register Classes-----------------------
  276 
  277 // Several register classes are automatically defined based upon
  278 // information in this architecture description.
  279 
  280 // 1) reg_class inline_cache_reg           (as defined in frame section)
  281 // 2) reg_class compiler_method_oop_reg    (as defined in frame section)
  282 // 2) reg_class interpreter_method_oop_reg (as defined in frame section)
  283 // 3) reg_class stack_slots(/* one chunk of stack-based &quot;registers&quot; */)
  284 
  285 // Integer Register Classes
  286 reg_class z_int_reg(
  287 /*Z_R0*/              // R0
  288 /*Z_R1*/
  289   Z_R2,
  290   Z_R3,
  291   Z_R4,
  292   Z_R5,
  293   Z_R6,
  294   Z_R7,
  295 /*Z_R8,*/             // Z_thread
  296   Z_R9,
  297   Z_R10,
  298   Z_R11,
  299   Z_R12,
  300   Z_R13
  301 /*Z_R14*/             // return_pc
  302 /*Z_R15*/             // SP
  303 );
  304 
  305 reg_class z_no_odd_int_reg(
  306 /*Z_R0*/              // R0
  307 /*Z_R1*/
  308   Z_R2,
  309   Z_R3,
  310   Z_R4,
  311 /*Z_R5,*/             // odd part of fix register pair
  312   Z_R6,
  313   Z_R7,
  314 /*Z_R8,*/             // Z_thread
  315   Z_R9,
  316   Z_R10,
  317   Z_R11,
  318   Z_R12,
  319   Z_R13
  320 /*Z_R14*/             // return_pc
  321 /*Z_R15*/             // SP
  322 );
  323 
  324 reg_class z_no_arg_int_reg(
  325 /*Z_R0*/              // R0
  326 /*Z_R1*/              // scratch
  327 /*Z_R2*/
  328 /*Z_R3*/
  329 /*Z_R4*/
  330 /*Z_R5*/
  331 /*Z_R6*/
  332   Z_R7,
  333 /*Z_R8*/              // Z_thread
  334   Z_R9,
  335   Z_R10,
  336   Z_R11,
  337   Z_R12,
  338   Z_R13
  339 /*Z_R14*/             // return_pc
  340 /*Z_R15*/             // SP
  341 );
  342 
  343 reg_class z_rarg1_int_reg(Z_R2);
  344 reg_class z_rarg2_int_reg(Z_R3);
  345 reg_class z_rarg3_int_reg(Z_R4);
  346 reg_class z_rarg4_int_reg(Z_R5);
  347 reg_class z_rarg5_int_reg(Z_R6);
  348 
  349 // Pointer Register Classes
  350 
  351 // 64-bit build means 64-bit pointers means hi/lo pairs.
  352 
  353 reg_class z_rarg5_ptrN_reg(Z_R6);
  354 
  355 reg_class z_rarg1_ptr_reg(Z_R2_H,Z_R2);
  356 reg_class z_rarg2_ptr_reg(Z_R3_H,Z_R3);
  357 reg_class z_rarg3_ptr_reg(Z_R4_H,Z_R4);
  358 reg_class z_rarg4_ptr_reg(Z_R5_H,Z_R5);
  359 reg_class z_rarg5_ptr_reg(Z_R6_H,Z_R6);
  360 reg_class z_thread_ptr_reg(Z_R8_H,Z_R8);
  361 
  362 reg_class z_ptr_reg(
  363 /*Z_R0_H,Z_R0*/     // R0
  364 /*Z_R1_H,Z_R1*/
  365   Z_R2_H,Z_R2,
  366   Z_R3_H,Z_R3,
  367   Z_R4_H,Z_R4,
  368   Z_R5_H,Z_R5,
  369   Z_R6_H,Z_R6,
  370   Z_R7_H,Z_R7,
  371 /*Z_R8_H,Z_R8,*/    // Z_thread
  372   Z_R9_H,Z_R9,
  373   Z_R10_H,Z_R10,
  374   Z_R11_H,Z_R11,
  375   Z_R12_H,Z_R12,
  376   Z_R13_H,Z_R13
  377 /*Z_R14_H,Z_R14*/   // return_pc
  378 /*Z_R15_H,Z_R15*/   // SP
  379 );
  380 
  381 reg_class z_lock_ptr_reg(
  382 /*Z_R0_H,Z_R0*/     // R0
  383 /*Z_R1_H,Z_R1*/
  384   Z_R2_H,Z_R2,
  385   Z_R3_H,Z_R3,
  386   Z_R4_H,Z_R4,
  387 /*Z_R5_H,Z_R5,*/
  388 /*Z_R6_H,Z_R6,*/
  389   Z_R7_H,Z_R7,
  390 /*Z_R8_H,Z_R8,*/    // Z_thread
  391   Z_R9_H,Z_R9,
  392   Z_R10_H,Z_R10,
  393   Z_R11_H,Z_R11,
  394   Z_R12_H,Z_R12,
  395   Z_R13_H,Z_R13
  396 /*Z_R14_H,Z_R14*/   // return_pc
  397 /*Z_R15_H,Z_R15*/   // SP
  398 );
  399 
  400 reg_class z_no_arg_ptr_reg(
  401 /*Z_R0_H,Z_R0*/        // R0
  402 /*Z_R1_H,Z_R1*/        // scratch
  403 /*Z_R2_H,Z_R2*/
  404 /*Z_R3_H,Z_R3*/
  405 /*Z_R4_H,Z_R4*/
  406 /*Z_R5_H,Z_R5*/
  407 /*Z_R6_H,Z_R6*/
  408   Z_R7_H, Z_R7,
  409 /*Z_R8_H,Z_R8*/        // Z_thread
  410   Z_R9_H,Z_R9,
  411   Z_R10_H,Z_R10,
  412   Z_R11_H,Z_R11,
  413   Z_R12_H,Z_R12,
  414   Z_R13_H,Z_R13
  415 /*Z_R14_H,Z_R14*/      // return_pc
  416 /*Z_R15_H,Z_R15*/      // SP
  417 );
  418 
  419 // Special class for storeP instructions, which can store SP or RPC to
  420 // TLS. (Note: Do not generalize this to &quot;any_reg&quot;. If you add
  421 // another register, such as FP, to this mask, the allocator may try
  422 // to put a temp in it.)
  423 // Register class for memory access base registers,
  424 // This class is a superset of z_ptr_reg including Z_thread.
  425 reg_class z_memory_ptr_reg(
  426 /*Z_R0_H,Z_R0*/     // R0
  427 /*Z_R1_H,Z_R1*/
  428   Z_R2_H,Z_R2,
  429   Z_R3_H,Z_R3,
  430   Z_R4_H,Z_R4,
  431   Z_R5_H,Z_R5,
  432   Z_R6_H,Z_R6,
  433   Z_R7_H,Z_R7,
  434   Z_R8_H,Z_R8,      // Z_thread
  435   Z_R9_H,Z_R9,
  436   Z_R10_H,Z_R10,
  437   Z_R11_H,Z_R11,
  438   Z_R12_H,Z_R12,
  439   Z_R13_H,Z_R13
  440 /*Z_R14_H,Z_R14*/   // return_pc
  441 /*Z_R15_H,Z_R15*/   // SP
  442 );
  443 
  444 // Other special pointer regs.
  445 reg_class z_r1_regP(Z_R1_H,Z_R1);
  446 reg_class z_r9_regP(Z_R9_H,Z_R9);
  447 
  448 
  449 // Long Register Classes
  450 
  451 reg_class z_rarg1_long_reg(Z_R2_H,Z_R2);
  452 reg_class z_rarg2_long_reg(Z_R3_H,Z_R3);
  453 reg_class z_rarg3_long_reg(Z_R4_H,Z_R4);
  454 reg_class z_rarg4_long_reg(Z_R5_H,Z_R5);
  455 reg_class z_rarg5_long_reg(Z_R6_H,Z_R6);
  456 
  457 // Longs in 1 register. Aligned adjacent hi/lo pairs.
  458 reg_class z_long_reg(
  459 /*Z_R0_H,Z_R0*/     // R0
  460 /*Z_R1_H,Z_R1*/
  461   Z_R2_H,Z_R2,
  462   Z_R3_H,Z_R3,
  463   Z_R4_H,Z_R4,
  464   Z_R5_H,Z_R5,
  465   Z_R6_H,Z_R6,
  466   Z_R7_H,Z_R7,
  467 /*Z_R8_H,Z_R8,*/    // Z_thread
  468   Z_R9_H,Z_R9,
  469   Z_R10_H,Z_R10,
  470   Z_R11_H,Z_R11,
  471   Z_R12_H,Z_R12,
  472   Z_R13_H,Z_R13
  473 /*Z_R14_H,Z_R14,*/  // return_pc
  474 /*Z_R15_H,Z_R15*/   // SP
  475 );
  476 
  477 // z_long_reg without even registers
  478 reg_class z_long_odd_reg(
  479 /*Z_R0_H,Z_R0*/     // R0
  480 /*Z_R1_H,Z_R1*/
  481   Z_R3_H,Z_R3,
  482   Z_R5_H,Z_R5,
  483   Z_R7_H,Z_R7,
  484   Z_R9_H,Z_R9,
  485   Z_R11_H,Z_R11,
  486   Z_R13_H,Z_R13
  487 /*Z_R14_H,Z_R14,*/  // return_pc
  488 /*Z_R15_H,Z_R15*/   // SP
  489 );
  490 
  491 // Special Class for Condition Code Flags Register
  492 
  493 reg_class z_condition_reg(
  494   Z_CR
  495 );
  496 
  497 // Scratch register for late profiling. Callee saved.
  498 reg_class z_rscratch2_bits64_reg(Z_R2_H, Z_R2);
  499 
  500 
  501 // Float Register Classes
  502 
  503 reg_class z_flt_reg(
  504   Z_F0,
  505 /*Z_F1,*/ // scratch
  506   Z_F2,
  507   Z_F3,
  508   Z_F4,
  509   Z_F5,
  510   Z_F6,
  511   Z_F7,
  512   Z_F8,
  513   Z_F9,
  514   Z_F10,
  515   Z_F11,
  516   Z_F12,
  517   Z_F13,
  518   Z_F14,
  519   Z_F15
  520 );
  521 reg_class z_rscratch1_flt_reg(Z_F1);
  522 
  523 // Double precision float registers have virtual `high halves&#39; that
  524 // are needed by the allocator.
  525 reg_class z_dbl_reg(
  526   Z_F0,Z_F0_H,
  527 /*Z_F1,Z_F1_H,*/ // scratch
  528   Z_F2,Z_F2_H,
  529   Z_F3,Z_F3_H,
  530   Z_F4,Z_F4_H,
  531   Z_F5,Z_F5_H,
  532   Z_F6,Z_F6_H,
  533   Z_F7,Z_F7_H,
  534   Z_F8,Z_F8_H,
  535   Z_F9,Z_F9_H,
  536   Z_F10,Z_F10_H,
  537   Z_F11,Z_F11_H,
  538   Z_F12,Z_F12_H,
  539   Z_F13,Z_F13_H,
  540   Z_F14,Z_F14_H,
  541   Z_F15,Z_F15_H
  542 );
  543 reg_class z_rscratch1_dbl_reg(Z_F1,Z_F1_H);
  544 
  545 %}
  546 
  547 //----------DEFINITION BLOCK---------------------------------------------------
  548 // Define &#39;name --&gt; value&#39; mappings to inform the ADLC of an integer valued name.
  549 // Current support includes integer values in the range [0, 0x7FFFFFFF].
  550 // Format:
  551 //        int_def  &lt;name&gt;         (&lt;int_value&gt;, &lt;expression&gt;);
  552 // Generated Code in ad_&lt;arch&gt;.hpp
  553 //        #define  &lt;name&gt;   (&lt;expression&gt;)
  554 //        // value == &lt;int_value&gt;
  555 // Generated code in ad_&lt;arch&gt;.cpp adlc_verification()
  556 //        assert(&lt;name&gt; == &lt;int_value&gt;, &quot;Expect (&lt;expression&gt;) to equal &lt;int_value&gt;&quot;);
  557 //
  558 definitions %{
  559   // The default cost (of an ALU instruction).
  560   int_def DEFAULT_COST      (   100,     100);
  561   int_def DEFAULT_COST_LOW  (    80,      80);
  562   int_def DEFAULT_COST_HIGH (   120,     120);
  563   int_def HUGE_COST         (1000000, 1000000);
  564 
  565   // Put an advantage on REG_MEM vs. MEM+REG_REG operations.
  566   int_def ALU_REG_COST      (   100, DEFAULT_COST);
  567   int_def ALU_MEMORY_COST   (   150,          150);
  568 
  569   // Memory refs are twice as expensive as run-of-the-mill.
  570   int_def MEMORY_REF_COST_HI (   220, 2 * DEFAULT_COST+20);
  571   int_def MEMORY_REF_COST    (   200, 2 * DEFAULT_COST);
  572   int_def MEMORY_REF_COST_LO (   180, 2 * DEFAULT_COST-20);
  573 
  574   // Branches are even more expensive.
  575   int_def BRANCH_COST       (   300, DEFAULT_COST * 3);
  576   int_def CALL_COST         (   300, DEFAULT_COST * 3);
  577 %}
  578 
  579 source %{
  580 
  581 #ifdef PRODUCT
  582 #define BLOCK_COMMENT(str)
  583 #define BIND(label)        __ bind(label)
  584 #else
  585 #define BLOCK_COMMENT(str) __ block_comment(str)
  586 #define BIND(label)        __ bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  587 #endif
  588 
  589 #define __ _masm.
  590 
  591 #define Z_DISP_SIZE Immediate::is_uimm12((long)opnd_array(1)-&gt;disp(ra_,this,2)) ?  4 : 6
  592 #define Z_DISP3_SIZE 6
  593 
  594 // Tertiary op of a LoadP or StoreP encoding.
  595 #define REGP_OP true
  596 
  597 // Given a register encoding, produce an Integer Register object.
  598 static Register reg_to_register_object(int register_encoding);
  599 
  600 // ****************************************************************************
  601 
  602 // REQUIRED FUNCTIONALITY
  603 
  604 // !!!!! Special hack to get all type of calls to specify the byte offset
  605 //       from the start of the call to the point where the return address
  606 //       will point.
  607 
  608 int MachCallStaticJavaNode::ret_addr_offset() {
  609   if (_method) {
  610     return 8;
  611   } else {
  612     return MacroAssembler::call_far_patchable_ret_addr_offset();
  613   }
  614 }
  615 
  616 int MachCallDynamicJavaNode::ret_addr_offset() {
  617   // Consider size of receiver type profiling (C2 tiers).
  618   int profile_receiver_type_size = 0;
  619 
  620   int vtable_index = this-&gt;_vtable_index;
  621   if (vtable_index == -4) {
  622     return 14 + profile_receiver_type_size;
  623   } else {
  624     assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
  625     return 36 + profile_receiver_type_size;
  626   }
  627 }
  628 
  629 int MachCallRuntimeNode::ret_addr_offset() {
  630   return 12 + MacroAssembler::call_far_patchable_ret_addr_offset();
  631 }
  632 
  633 // Compute padding required for nodes which need alignment
  634 //
  635 // The addresses of the call instructions needs to be 4-byte aligned to
  636 // ensure that they don&#39;t span a cache line so that they are atomically patchable.
  637 // The actual calls get emitted at different offsets within the node emitters.
  638 // ins_alignment needs to be set to 2 which means that up to 1 nop may get inserted.
  639 
  640 int CallStaticJavaDirect_dynTOCNode::compute_padding(int current_offset) const {
  641   return (0 - current_offset) &amp; 2;
  642 }
  643 
  644 int CallDynamicJavaDirect_dynTOCNode::compute_padding(int current_offset) const {
  645   return (6 - current_offset) &amp; 2;
  646 }
  647 
  648 int CallRuntimeDirectNode::compute_padding(int current_offset) const {
  649   return (12 - current_offset) &amp; 2;
  650 }
  651 
  652 int CallLeafDirectNode::compute_padding(int current_offset) const {
  653   return (12 - current_offset) &amp; 2;
  654 }
  655 
  656 int CallLeafNoFPDirectNode::compute_padding(int current_offset) const {
  657   return (12 - current_offset) &amp; 2;
  658 }
  659 
  660 // Indicate if the safepoint node needs the polling page as an input.
  661 // Since z/Architecture does not have absolute addressing, it does.
  662 bool SafePointNode::needs_polling_address_input() {
  663   return true;
  664 }
  665 
  666 void emit_nop(CodeBuffer &amp;cbuf) {
  667   C2_MacroAssembler _masm(&amp;cbuf);
  668   __ z_nop();
  669 }
  670 
  671 // Emit an interrupt that is caught by the debugger (for debugging compiler).
  672 void emit_break(CodeBuffer &amp;cbuf) {
  673   C2_MacroAssembler _masm(&amp;cbuf);
  674   __ z_illtrap();
  675 }
  676 
  677 #if !defined(PRODUCT)
  678 void MachBreakpointNode::format(PhaseRegAlloc *, outputStream *os) const {
  679   os-&gt;print(&quot;TA&quot;);
  680 }
  681 #endif
  682 
  683 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  684   emit_break(cbuf);
  685 }
  686 
  687 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  688   return MachNode::size(ra_);
  689 }
  690 
  691 static inline void z_emit16(CodeBuffer &amp;cbuf, long value) {
  692   // 32bit instructions may become sign extended.
  693   assert(value &gt;= 0, &quot;unintended sign extension (int-&gt;long)&quot;);
  694   assert(value &lt; (1L &lt;&lt; 16), &quot;instruction too large&quot;);
  695   *((unsigned short*)(cbuf.insts_end())) = (unsigned short)value;
  696   cbuf.set_insts_end(cbuf.insts_end() + sizeof(unsigned short));
  697 }
  698 
  699 static inline void z_emit32(CodeBuffer &amp;cbuf, long value) {
  700   // 32bit instructions may become sign extended.
  701   assert(value &lt; (1L &lt;&lt; 32), &quot;instruction too large&quot;);
  702   *((unsigned int*)(cbuf.insts_end())) = (unsigned int)value;
  703   cbuf.set_insts_end(cbuf.insts_end() + sizeof(unsigned int));
  704 }
  705 
  706 static inline void z_emit48(CodeBuffer &amp;cbuf, long value) {
  707   // 32bit instructions may become sign extended.
  708   assert(value &gt;= 0, &quot;unintended sign extension (int-&gt;long)&quot;);
  709   assert(value &lt; (1L &lt;&lt; 48), &quot;instruction too large&quot;);
  710   value = value&lt;&lt;16;
  711   memcpy(cbuf.insts_end(), (unsigned char*)&amp;value, 6);
  712   cbuf.set_insts_end(cbuf.insts_end() + 6);
  713 }
  714 
  715 static inline unsigned int z_emit_inst(CodeBuffer &amp;cbuf, long value) {
  716   if (value &lt; 0) {
  717     // There obviously has been an unintended sign extension (int-&gt;long). Revert it.
  718     value = (long)((unsigned long)((unsigned int)value));
  719   }
  720 
  721   if (value &lt; (1L &lt;&lt; 16)) { // 2-byte instruction
  722     z_emit16(cbuf, value);
  723     return 2;
  724   }
  725 
  726   if (value &lt; (1L &lt;&lt; 32)) { // 4-byte instruction, might be unaligned store
  727     z_emit32(cbuf, value);
  728     return 4;
  729   }
  730 
  731   // 6-byte instruction, probably unaligned store.
  732   z_emit48(cbuf, value);
  733   return 6;
  734 }
  735 
  736 // Check effective address (at runtime) for required alignment.
  737 static inline void z_assert_aligned(CodeBuffer &amp;cbuf, int disp, Register index, Register base, int alignment) {
  738   C2_MacroAssembler _masm(&amp;cbuf);
  739 
  740   __ z_lay(Z_R0, disp, index, base);
  741   __ z_nill(Z_R0, alignment-1);
  742   __ z_brc(Assembler::bcondEqual, +3);
  743   __ z_illtrap();
  744 }
  745 
  746 int emit_call_reloc(C2_MacroAssembler &amp;_masm, intptr_t entry_point, relocInfo::relocType rtype,
  747                     PhaseRegAlloc* ra_, bool is_native_call = false) {
  748   __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
  749   address old_mark = __ inst_mark();
  750   unsigned int start_off = __ offset();
  751 
  752   if (is_native_call) {
  753     ShouldNotReachHere();
  754   }
  755 
  756   if (rtype == relocInfo::runtime_call_w_cp_type) {
  757     assert((__ offset() &amp; 2) == 0, &quot;misaligned emit_call_reloc&quot;);
  758     address call_addr = __ call_c_opt((address)entry_point);
  759     if (call_addr == NULL) {
  760       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
  761       return -1;
  762     }
  763   } else {
  764     assert(rtype == relocInfo::none || rtype == relocInfo::opt_virtual_call_type ||
  765            rtype == relocInfo::static_call_type, &quot;unexpected rtype&quot;);
  766     __ relocate(rtype);
  767     // BRASL must be prepended with a nop to identify it in the instruction stream.
  768     __ z_nop();
  769     __ z_brasl(Z_R14, (address)entry_point);
  770   }
  771 
  772   unsigned int ret_off = __ offset();
  773 
  774   return (ret_off - start_off);
  775 }
  776 
  777 static int emit_call_reloc(C2_MacroAssembler &amp;_masm, intptr_t entry_point, RelocationHolder const&amp; rspec) {
  778   __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
  779   address old_mark = __ inst_mark();
  780   unsigned int start_off = __ offset();
  781 
  782   relocInfo::relocType rtype = rspec.type();
  783   assert(rtype == relocInfo::opt_virtual_call_type || rtype == relocInfo::static_call_type,
  784          &quot;unexpected rtype&quot;);
  785 
  786   __ relocate(rspec);
  787   __ z_nop();
  788   __ z_brasl(Z_R14, (address)entry_point);
  789 
  790   unsigned int ret_off = __ offset();
  791 
  792   return (ret_off - start_off);
  793 }
  794 
  795 //=============================================================================
  796 
  797 const RegMask&amp; MachConstantBaseNode::_out_RegMask = _Z_PTR_REG_mask;
  798 int ConstantTable::calculate_table_base_offset() const {
  799   return 0;  // absolute addressing, no offset
  800 }
  801 
  802 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  803 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  804   ShouldNotReachHere();
  805 }
  806 
  807 // Even with PC-relative TOC addressing, we still need this node.
  808 // Float loads/stores do not support PC-relative addresses.
  809 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  810   C2_MacroAssembler _masm(&amp;cbuf);
  811   Register Rtoc = as_Register(ra_-&gt;get_encode(this));
  812   __ load_toc(Rtoc);
  813 }
  814 
  815 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  816   // PCrelative TOC access.
  817   return 6;   // sizeof(LARL)
  818 }
  819 
  820 #if !defined(PRODUCT)
  821 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  822   Register r = as_Register(ra_-&gt;get_encode(this));
  823   st-&gt;print(&quot;LARL    %s,&amp;constant_pool # MachConstantBaseNode&quot;, r-&gt;name());
  824 }
  825 #endif
  826 
  827 //=============================================================================
  828 
  829 #if !defined(PRODUCT)
  830 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
  831   Compile* C = ra_-&gt;C;
  832   st-&gt;print_cr(&quot;--- MachPrologNode ---&quot;);
  833   st-&gt;print(&quot;\t&quot;);
  834   for (int i = 0; i &lt; OptoPrologueNops; i++) {
  835     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
  836   }
  837 
  838   if (VerifyThread) {
  839     st-&gt;print_cr(&quot;Verify_Thread&quot;);
  840     st-&gt;print(&quot;\t&quot;);
  841   }
  842 
  843   long framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  844   int bangsize   = C-&gt;output()-&gt;bang_size_in_bytes();
  845 
  846   // Calls to C2R adapters often do not accept exceptional returns.
  847   // We require that their callers must bang for them. But be
  848   // careful, because some VM calls (such as call site linkage) can
  849   // use several kilobytes of stack. But the stack safety zone should
  850   // account for that. See bugs 4446381, 4468289, 4497237.
  851   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
  852     st-&gt;print_cr(&quot;# stack bang&quot;); st-&gt;print(&quot;\t&quot;);
  853   }
  854   st-&gt;print_cr(&quot;push_frame %d&quot;, (int)-framesize);
  855   st-&gt;print(&quot;\t&quot;);
  856 }
  857 #endif
  858 
  859 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  860   Compile* C = ra_-&gt;C;
  861   C2_MacroAssembler _masm(&amp;cbuf);
  862 
  863   __ verify_thread();
  864 
  865   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  866   size_t bangsize  = C-&gt;output()-&gt;bang_size_in_bytes();
  867 
  868   assert(framesize % wordSize == 0, &quot;must preserve wordSize alignment&quot;);
  869 
  870   if (C-&gt;clinit_barrier_on_entry()) {
  871     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  872 
  873     Label L_skip_barrier;
  874     Register klass = Z_R1_scratch;
  875 
  876     // Notify OOP recorder (don&#39;t need the relocation)
  877     AddressLiteral md = __ constant_metadata_address(C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  878     __ load_const_optimized(klass, md.value());
  879     __ clinit_barrier(klass, Z_thread, &amp;L_skip_barrier /*L_fast_path*/);
  880 
  881     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub());
  882     __ z_br(klass);
  883 
  884     __ bind(L_skip_barrier);
  885   }
  886 
  887   // Calls to C2R adapters often do not accept exceptional returns.
  888   // We require that their callers must bang for them. But be
  889   // careful, because some VM calls (such as call site linkage) can
  890   // use several kilobytes of stack. But the stack safety zone should
  891   // account for that. See bugs 4446381, 4468289, 4497237.
  892   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {
  893     __ generate_stack_overflow_check(bangsize);
  894   }
  895 
  896   assert(Immediate::is_uimm32((long)framesize), &quot;to do: choose suitable types!&quot;);
  897   __ save_return_pc();
  898 
  899   // The z/Architecture abi is already accounted for in `framesize&#39; via the
  900   // &#39;out_preserve_stack_slots&#39; declaration.
  901   __ push_frame((unsigned int)framesize/*includes JIT ABI*/);
  902 
  903   if (C-&gt;has_mach_constant_base_node()) {
  904     // NOTE: We set the table base offset here because users might be
  905     // emitted before MachConstantBaseNode.
  906     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  907     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  908   }
  909 }
  910 
  911 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  912   // Variable size. Determine dynamically.
  913   return MachNode::size(ra_);
  914 }
  915 
  916 int MachPrologNode::reloc() const {
  917   // Return number of relocatable values contained in this instruction.
  918   return 1; // One reloc entry for load_const(toc).
  919 }
  920 
  921 //=============================================================================
  922 
  923 #if !defined(PRODUCT)
  924 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
  925   os-&gt;print_cr(&quot;epilog&quot;);
  926   os-&gt;print(&quot;\t&quot;);
  927   if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
  928     os-&gt;print_cr(&quot;load_from_polling_page Z_R1_scratch&quot;);
  929     os-&gt;print(&quot;\t&quot;);
  930   }
  931 }
  932 #endif
  933 
  934 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  935   C2_MacroAssembler _masm(&amp;cbuf);
  936   Compile* C = ra_-&gt;C;
  937   __ verify_thread();
  938 
  939   // If this does safepoint polling, then do it here.
  940   bool need_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
  941 
  942   // Pop frame, restore return_pc, and all stuff needed by interpreter.
  943   int frame_size_in_bytes = Assembler::align((C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt), frame::alignment_in_bytes);
  944   __ pop_frame_restore_retPC(frame_size_in_bytes);
  945 
  946   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  947     __ reserved_stack_check(Z_R14);
  948   }
  949 
  950   // Touch the polling page.
  951   if (need_polling) {
  952     if (SafepointMechanism::uses_thread_local_poll()) {
  953       __ z_lg(Z_R1_scratch, Address(Z_thread, Thread::polling_page_offset()));
  954     } else {
  955       AddressLiteral pp(os::get_polling_page());
  956       __ load_const_optimized(Z_R1_scratch, pp);
  957     }
  958     // We need to mark the code position where the load from the safepoint
  959     // polling page was emitted as relocInfo::poll_return_type here.
  960     __ relocate(relocInfo::poll_return_type);
  961     __ load_from_polling_page(Z_R1_scratch);
  962   }
  963 }
  964 
  965 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  966   // Variable size. determine dynamically.
  967   return MachNode::size(ra_);
  968 }
  969 
  970 int MachEpilogNode::reloc() const {
  971   // Return number of relocatable values contained in this instruction.
  972   return 1; // One for load_from_polling_page.
  973 }
  974 
  975 const Pipeline * MachEpilogNode::pipeline() const {
  976   return MachNode::pipeline_class();
  977 }
  978 
  979 int MachEpilogNode::safepoint_offset() const {
  980   assert(do_polling(), &quot;no return for this epilog node&quot;);
  981   return 0;
  982 }
  983 
  984 //=============================================================================
  985 
  986 // Figure out which register class each belongs in: rc_int, rc_float, rc_stack.
  987 enum RC { rc_bad, rc_int, rc_float, rc_stack };
  988 
  989 static enum RC rc_class(OptoReg::Name reg) {
  990   // Return the register class for the given register. The given register
  991   // reg is a &lt;register&gt;_num value, which is an index into the MachRegisterNumbers
  992   // enumeration in adGlobals_s390.hpp.
  993 
  994   if (reg == OptoReg::Bad) {
  995     return rc_bad;
  996   }
  997 
  998   // We have 32 integer register halves, starting at index 0.
  999   if (reg &lt; 32) {
 1000     return rc_int;
 1001   }
 1002 
 1003   // We have 32 floating-point register halves, starting at index 32.
 1004   if (reg &lt; 32+32) {
 1005     return rc_float;
 1006   }
 1007 
 1008   // Between float regs &amp; stack are the flags regs.
 1009   assert(reg &gt;= OptoReg::stack0(), &quot;blow up if spilling flags&quot;);
 1010   return rc_stack;
 1011 }
 1012 
 1013 // Returns size as obtained from z_emit_instr.
 1014 static unsigned int z_ld_st_helper(CodeBuffer *cbuf, const char *op_str, unsigned long opcode,
 1015                                    int reg, int offset, bool do_print, outputStream *os) {
 1016 
 1017   if (cbuf) {
 1018     if (opcode &gt; (1L&lt;&lt;32)) {
 1019       return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 48) |
 1020                          Assembler::simm20(offset) | Assembler::reg(Z_R0, 12, 48) | Assembler::regz(Z_SP, 16, 48));
 1021     } else {
 1022       return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 32) |
 1023                          Assembler::uimm12(offset, 20, 32) | Assembler::reg(Z_R0, 12, 32) | Assembler::regz(Z_SP, 16, 32));
 1024     }
 1025   }
 1026 
 1027 #if !defined(PRODUCT)
 1028   if (do_print) {
 1029     os-&gt;print(&quot;%s    %s,#%d[,SP]\t # MachCopy spill code&quot;,op_str, Matcher::regName[reg], offset);
 1030   }
 1031 #endif
 1032   return (opcode &gt; (1L &lt;&lt; 32)) ? 6 : 4;
 1033 }
 1034 
 1035 static unsigned int z_mvc_helper(CodeBuffer *cbuf, int len, int dst_off, int src_off, bool do_print, outputStream *os) {
 1036   if (cbuf) {
 1037     C2_MacroAssembler _masm(cbuf);
 1038     __ z_mvc(dst_off, len-1, Z_SP, src_off, Z_SP);
 1039   }
 1040 
 1041 #if !defined(PRODUCT)
 1042   else if (do_print) {
 1043     os-&gt;print(&quot;MVC     %d(%d,SP),%d(SP)\t # MachCopy spill code&quot;,dst_off, len, src_off);
 1044   }
 1045 #endif
 1046 
 1047   return 6;
 1048 }
 1049 
 1050 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *os) const {
 1051   // Get registers to move.
 1052   OptoReg::Name src_hi = ra_-&gt;get_reg_second(in(1));
 1053   OptoReg::Name src_lo = ra_-&gt;get_reg_first(in(1));
 1054   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(this);
 1055   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(this);
 1056 
 1057   enum RC src_hi_rc = rc_class(src_hi);
 1058   enum RC src_lo_rc = rc_class(src_lo);
 1059   enum RC dst_hi_rc = rc_class(dst_hi);
 1060   enum RC dst_lo_rc = rc_class(dst_lo);
 1061 
 1062   assert(src_lo != OptoReg::Bad &amp;&amp; dst_lo != OptoReg::Bad, &quot;must move at least 1 register&quot;);
 1063   bool is64 = (src_hi_rc != rc_bad);
 1064   assert(!is64 ||
 1065          ((src_lo&amp;1) == 0 &amp;&amp; src_lo+1 == src_hi &amp;&amp; (dst_lo&amp;1) == 0 &amp;&amp; dst_lo+1 == dst_hi),
 1066          &quot;expected aligned-adjacent pairs&quot;);
 1067 
 1068   // Generate spill code!
 1069 
 1070   if (src_lo == dst_lo &amp;&amp; src_hi == dst_hi) {
 1071     return 0;            // Self copy, no move.
 1072   }
 1073 
 1074   int  src_offset = ra_-&gt;reg2offset(src_lo);
 1075   int  dst_offset = ra_-&gt;reg2offset(dst_lo);
 1076   bool print = !do_size;
 1077   bool src12 = Immediate::is_uimm12(src_offset);
 1078   bool dst12 = Immediate::is_uimm12(dst_offset);
 1079 
 1080   const char   *mnemo = NULL;
 1081   unsigned long opc = 0;
 1082 
 1083   // Memory-&gt;Memory Spill. Use Z_R0 to hold the value.
 1084   if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1085 
 1086     assert(!is64 || (src_hi_rc==rc_stack &amp;&amp; dst_hi_rc==rc_stack),
 1087            &quot;expected same type of move for high parts&quot;);
 1088 
 1089     if (src12 &amp;&amp; dst12) {
 1090       return z_mvc_helper(cbuf, is64 ? 8 : 4, dst_offset, src_offset, print, os);
 1091     }
 1092 
 1093     int r0 = Z_R0_num;
 1094     if (is64) {
 1095       return z_ld_st_helper(cbuf, &quot;LG  &quot;, LG_ZOPC, r0, src_offset, print, os) +
 1096              z_ld_st_helper(cbuf, &quot;STG &quot;, STG_ZOPC, r0, dst_offset, print, os);
 1097     }
 1098 
 1099     return z_ld_st_helper(cbuf, &quot;LY   &quot;, LY_ZOPC, r0, src_offset, print, os) +
 1100            z_ld_st_helper(cbuf, &quot;STY  &quot;, STY_ZOPC, r0, dst_offset, print, os);
 1101   }
 1102 
 1103   // Check for float-&gt;int copy. Requires a trip through memory.
 1104   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
 1105     Unimplemented();  // Unsafe, do not remove!
 1106   }
 1107 
 1108   // Check for integer reg-reg copy.
 1109   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
 1110     if (cbuf) {
 1111       C2_MacroAssembler _masm(cbuf);
 1112       Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
 1113       Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
 1114       __ z_lgr(Rdst, Rsrc);
 1115       return 4;
 1116     }
 1117 #if !defined(PRODUCT)
 1118     // else
 1119     if (print) {
 1120       os-&gt;print(&quot;LGR     %s,%s\t # MachCopy spill code&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1121     }
 1122 #endif
 1123     return 4;
 1124   }
 1125 
 1126   // Check for integer store.
 1127   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
 1128     assert(!is64 || (src_hi_rc==rc_int &amp;&amp; dst_hi_rc==rc_stack),
 1129            &quot;expected same type of move for high parts&quot;);
 1130 
 1131     if (is64) {
 1132       return z_ld_st_helper(cbuf, &quot;STG &quot;, STG_ZOPC, src_lo, dst_offset, print, os);
 1133     }
 1134 
 1135     // else
 1136     mnemo = dst12 ? &quot;ST  &quot; : &quot;STY &quot;;
 1137     opc = dst12 ? ST_ZOPC : STY_ZOPC;
 1138 
 1139     return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);
 1140   }
 1141 
 1142   // Check for integer load
 1143   // Always load cOops zero-extended. That doesn&#39;t hurt int loads.
 1144   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
 1145 
 1146     assert(!is64 || (dst_hi_rc==rc_int &amp;&amp; src_hi_rc==rc_stack),
 1147            &quot;expected same type of move for high parts&quot;);
 1148 
 1149     mnemo = is64 ? &quot;LG  &quot; : &quot;LLGF&quot;;
 1150     opc = is64 ? LG_ZOPC : LLGF_ZOPC;
 1151 
 1152     return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);
 1153   }
 1154 
 1155   // Check for float reg-reg copy.
 1156   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
 1157     if (cbuf) {
 1158       C2_MacroAssembler _masm(cbuf);
 1159       FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
 1160       FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
 1161       __ z_ldr(Rdst, Rsrc);
 1162       return 2;
 1163     }
 1164 #if !defined(PRODUCT)
 1165     // else
 1166     if (print) {
 1167       os-&gt;print(&quot;LDR      %s,%s\t # MachCopy spill code&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1168     }
 1169 #endif
 1170     return 2;
 1171   }
 1172 
 1173   // Check for float store.
 1174   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
 1175     assert(!is64 || (src_hi_rc==rc_float &amp;&amp; dst_hi_rc==rc_stack),
 1176            &quot;expected same type of move for high parts&quot;);
 1177 
 1178     if (is64) {
 1179       mnemo = dst12 ? &quot;STD  &quot; : &quot;STDY &quot;;
 1180       opc = dst12 ? STD_ZOPC : STDY_ZOPC;
 1181       return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);
 1182     }
 1183     // else
 1184 
 1185     mnemo = dst12 ? &quot;STE  &quot; : &quot;STEY &quot;;
 1186     opc = dst12 ? STE_ZOPC : STEY_ZOPC;
 1187     return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);
 1188   }
 1189 
 1190   // Check for float load.
 1191   if (dst_lo_rc == rc_float &amp;&amp; src_lo_rc == rc_stack) {
 1192     assert(!is64 || (dst_hi_rc==rc_float &amp;&amp; src_hi_rc==rc_stack),
 1193            &quot;expected same type of move for high parts&quot;);
 1194 
 1195     if (is64) {
 1196       mnemo = src12 ? &quot;LD   &quot; : &quot;LDY  &quot;;
 1197       opc = src12 ? LD_ZOPC : LDY_ZOPC;
 1198       return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);
 1199     }
 1200     // else
 1201 
 1202     mnemo = src12 ? &quot;LE   &quot; : &quot;LEY  &quot;;
 1203     opc = src12 ? LE_ZOPC : LEY_ZOPC;
 1204     return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);
 1205   }
 1206 
 1207   // --------------------------------------------------------------------
 1208   // Check for hi bits still needing moving. Only happens for misaligned
 1209   // arguments to native calls.
 1210   if (src_hi == dst_hi) {
 1211     return 0;               // Self copy, no move.
 1212   }
 1213 
 1214   assert(is64 &amp;&amp; dst_hi_rc != rc_bad, &quot;src_hi &amp; dst_hi cannot be Bad&quot;);
 1215   Unimplemented();  // Unsafe, do not remove!
 1216 
 1217   return 0; // never reached, but make the compiler shut up!
 1218 }
 1219 
 1220 #if !defined(PRODUCT)
 1221 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1222   if (ra_ &amp;&amp; ra_-&gt;node_regs_max_index() &gt; 0) {
 1223     implementation(NULL, ra_, false, os);
 1224   } else {
 1225     if (req() == 2 &amp;&amp; in(1)) {
 1226       os-&gt;print(&quot;N%d = N%d\n&quot;, _idx, in(1)-&gt;_idx);
 1227     } else {
 1228       const char *c = &quot;(&quot;;
 1229       os-&gt;print(&quot;N%d = &quot;, _idx);
 1230       for (uint i = 1; i &lt; req(); ++i) {
 1231         os-&gt;print(&quot;%sN%d&quot;, c, in(i)-&gt;_idx);
 1232         c = &quot;, &quot;;
 1233       }
 1234       os-&gt;print(&quot;)&quot;);
 1235     }
 1236   }
 1237 }
 1238 #endif
 1239 
 1240 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1241   implementation(&amp;cbuf, ra_, false, NULL);
 1242 }
 1243 
 1244 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1245   return implementation(NULL, ra_, true, NULL);
 1246 }
 1247 
 1248 //=============================================================================
 1249 
 1250 #if !defined(PRODUCT)
 1251 void MachNopNode::format(PhaseRegAlloc *, outputStream *os) const {
 1252   os-&gt;print(&quot;NOP     # pad for alignment (%d nops, %d bytes)&quot;, _count, _count*MacroAssembler::nop_size());
 1253 }
 1254 #endif
 1255 
 1256 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc * ra_) const {
 1257   C2_MacroAssembler _masm(&amp;cbuf);
 1258 
 1259   int rem_space = 0;
 1260   if (!(ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size())) {
 1261     rem_space = cbuf.insts()-&gt;remaining();
 1262     if (rem_space &lt;= _count*2 + 8) {
 1263       tty-&gt;print(&quot;NopNode: _count = %3.3d, remaining space before = %d&quot;, _count, rem_space);
 1264     }
 1265   }
 1266 
 1267   for (int i = 0; i &lt; _count; i++) {
 1268     __ z_nop();
 1269   }
 1270 
 1271   if (!(ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size())) {
 1272     if (rem_space &lt;= _count*2 + 8) {
 1273       int rem_space2 = cbuf.insts()-&gt;remaining();
 1274       tty-&gt;print_cr(&quot;, after = %d&quot;, rem_space2);
 1275     }
 1276   }
 1277 }
 1278 
 1279 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 1280    return 2 * _count;
 1281 }
 1282 
 1283 #if !defined(PRODUCT)
 1284 void BoxLockNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1285   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1286   if (ra_ &amp;&amp; ra_-&gt;node_regs_max_index() &gt; 0) {
 1287     int reg = ra_-&gt;get_reg_first(this);
 1288     os-&gt;print(&quot;ADDHI  %s, SP, %d\t//box node&quot;, Matcher::regName[reg], offset);
 1289   } else {
 1290     os-&gt;print(&quot;ADDHI  N%d = SP + %d\t// box node&quot;, _idx, offset);
 1291   }
 1292 }
 1293 #endif
 1294 
 1295 // Take care of the size function, if you make changes here!
 1296 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1297   C2_MacroAssembler _masm(&amp;cbuf);
 1298 
 1299   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1300   int reg = ra_-&gt;get_encode(this);
 1301   __ z_lay(as_Register(reg), offset, Z_SP);
 1302 }
 1303 
 1304 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1305   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
 1306   return 6;
 1307 }
 1308 
 1309  %} // end source section
 1310 
 1311 //----------SOURCE BLOCK-------------------------------------------------------
 1312 // This is a block of C++ code which provides values, functions, and
 1313 // definitions necessary in the rest of the architecture description
 1314 
 1315 source_hpp %{
 1316 
 1317 // Header information of the source block.
 1318 // Method declarations/definitions which are used outside
 1319 // the ad-scope can conveniently be defined here.
 1320 //
 1321 // To keep related declarations/definitions/uses close together,
 1322 // we switch between source %{ }% and source_hpp %{ }% freely as needed.
 1323 
 1324 //--------------------------------------------------------------
 1325 // Used for optimization in Compile::Shorten_branches
 1326 //--------------------------------------------------------------
 1327 
 1328 class CallStubImpl {
 1329  public:
 1330 
 1331   // call trampolines
 1332   // Size of call trampoline stub. For add&#39;l comments, see size_java_to_interp().
 1333   static uint size_call_trampoline() {
 1334     return 0; // no call trampolines on this platform
 1335   }
 1336 
 1337   // call trampolines
 1338   // Number of relocations needed by a call trampoline stub.
 1339   static uint reloc_call_trampoline() {
 1340     return 0; // No call trampolines on this platform.
 1341   }
 1342 };
 1343 
 1344 %} // end source_hpp section
 1345 
 1346 source %{
 1347 
 1348 #if !defined(PRODUCT)
 1349 void MachUEPNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1350   os-&gt;print_cr(&quot;---- MachUEPNode ----&quot;);
 1351   os-&gt;print_cr(&quot;\tTA&quot;);
 1352   os-&gt;print_cr(&quot;\tload_const Z_R1, SharedRuntime::get_ic_miss_stub()&quot;);
 1353   os-&gt;print_cr(&quot;\tBR(Z_R1)&quot;);
 1354   os-&gt;print_cr(&quot;\tTA  # pad with illtraps&quot;);
 1355   os-&gt;print_cr(&quot;\t...&quot;);
 1356   os-&gt;print_cr(&quot;\tTA&quot;);
 1357   os-&gt;print_cr(&quot;\tLTGR    Z_R2, Z_R2&quot;);
 1358   os-&gt;print_cr(&quot;\tBRU     ic_miss&quot;);
 1359 }
 1360 #endif
 1361 
 1362 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1363   C2_MacroAssembler _masm(&amp;cbuf);
 1364   const int ic_miss_offset = 2;
 1365 
 1366   // Inline_cache contains a klass.
 1367   Register ic_klass = as_Register(Matcher::inline_cache_reg_encode());
 1368   // ARG1 is the receiver oop.
 1369   Register R2_receiver = Z_ARG1;
 1370   int      klass_offset = oopDesc::klass_offset_in_bytes();
 1371   AddressLiteral icmiss(SharedRuntime::get_ic_miss_stub());
 1372   Register R1_ic_miss_stub_addr = Z_R1_scratch;
 1373 
 1374   // Null check of receiver.
 1375   // This is the null check of the receiver that actually should be
 1376   // done in the caller. It&#39;s here because in case of implicit null
 1377   // checks we get it for free.
 1378   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()),
 1379          &quot;second word in oop should not require explicit null check.&quot;);
 1380   if (!ImplicitNullChecks) {
 1381     Label valid;
 1382     if (VM_Version::has_CompareBranch()) {
 1383       __ z_cgij(R2_receiver, 0, Assembler::bcondNotEqual, valid);
 1384     } else {
 1385       __ z_ltgr(R2_receiver, R2_receiver);
 1386       __ z_bre(valid);
 1387     }
 1388     // The ic_miss_stub will handle the null pointer exception.
 1389     __ load_const_optimized(R1_ic_miss_stub_addr, icmiss);
 1390     __ z_br(R1_ic_miss_stub_addr);
 1391     __ bind(valid);
 1392   }
 1393 
 1394   // Check whether this method is the proper implementation for the class of
 1395   // the receiver (ic miss check).
 1396   {
 1397     Label valid;
 1398     // Compare cached class against klass from receiver.
 1399     // This also does an implicit null check!
 1400     __ compare_klass_ptr(ic_klass, klass_offset, R2_receiver, false);
 1401     __ z_bre(valid);
 1402     // The inline cache points to the wrong method. Call the
 1403     // ic_miss_stub to find the proper method.
 1404     __ load_const_optimized(R1_ic_miss_stub_addr, icmiss);
 1405     __ z_br(R1_ic_miss_stub_addr);
 1406     __ bind(valid);
 1407   }
 1408 }
 1409 
 1410 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1411   // Determine size dynamically.
 1412   return MachNode::size(ra_);
 1413 }
 1414 
 1415 //=============================================================================
 1416 
 1417 %} // interrupt source section
 1418 
 1419 source_hpp %{ // Header information of the source block.
 1420 
 1421 class HandlerImpl {
 1422  public:
 1423 
 1424   static int emit_exception_handler(CodeBuffer &amp;cbuf);
 1425   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
 1426 
 1427   static uint size_exception_handler() {
 1428     return NativeJump::max_instruction_size();
 1429   }
 1430 
 1431   static uint size_deopt_handler() {
 1432     return NativeCall::max_instruction_size();
 1433   }
 1434 };
 1435 
 1436 %} // end source_hpp section
 1437 
 1438 source %{
 1439 
 1440 // This exception handler code snippet is placed after the method&#39;s
 1441 // code. It is the return point if an exception occurred. it jumps to
 1442 // the exception blob.
 1443 //
 1444 // If the method gets deoptimized, the method and this code snippet
 1445 // get patched.
 1446 //
 1447 // 1) Trampoline code gets patched into the end of this exception
 1448 //   handler. the trampoline code jumps to the deoptimization blob.
 1449 //
 1450 // 2) The return address in the method&#39;s code will get patched such
 1451 //   that it jumps to the trampoline.
 1452 //
 1453 // 3) The handler will get patched such that it does not jump to the
 1454 //   exception blob, but to an entry in the deoptimization blob being
 1455 //   aware of the exception.
 1456 int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
 1457   Register temp_reg = Z_R1;
 1458   C2_MacroAssembler _masm(&amp;cbuf);
 1459 
 1460   address base = __ start_a_stub(size_exception_handler());
 1461   if (base == NULL) {
 1462     return 0;          // CodeBuffer::expand failed
 1463   }
 1464 
 1465   int offset = __ offset();
 1466   // Use unconditional pc-relative jump with 32-bit range here.
 1467   __ load_const_optimized(temp_reg, (address)OptoRuntime::exception_blob()-&gt;content_begin());
 1468   __ z_br(temp_reg);
 1469 
 1470   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
 1471 
 1472   __ end_a_stub();
 1473 
 1474   return offset;
 1475 }
 1476 
 1477 // Emit deopt handler code.
 1478 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
 1479   C2_MacroAssembler _masm(&amp;cbuf);
 1480   address        base = __ start_a_stub(size_deopt_handler());
 1481 
 1482   if (base == NULL) {
 1483     return 0;  // CodeBuffer::expand failed
 1484   }
 1485 
 1486   int offset = __ offset();
 1487 
 1488   // Size_deopt_handler() must be exact on zarch, so for simplicity
 1489   // we do not use load_const_opt here.
 1490   __ load_const(Z_R1, SharedRuntime::deopt_blob()-&gt;unpack());
 1491   __ call(Z_R1);
 1492   assert(__ offset() - offset == (int) size_deopt_handler(), &quot;must be fixed size&quot;);
 1493 
 1494   __ end_a_stub();
 1495   return offset;
 1496 }
 1497 
 1498 //=============================================================================
 1499 
 1500 
 1501 // Given a register encoding, produce an Integer Register object.
 1502 static Register reg_to_register_object(int register_encoding) {
 1503   assert(Z_R12-&gt;encoding() == Z_R12_enc, &quot;wrong coding&quot;);
 1504   return as_Register(register_encoding);
 1505 }
 1506 
 1507 const bool Matcher::match_rule_supported(int opcode) {
 1508   if (!has_match_rule(opcode)) return false;
 1509 
 1510   switch (opcode) {
 1511     case Op_CountLeadingZerosI:
 1512     case Op_CountLeadingZerosL:
 1513     case Op_CountTrailingZerosI:
 1514     case Op_CountTrailingZerosL:
 1515       // Implementation requires FLOGR instruction, which is available since z9.
 1516       return true;
 1517 
 1518     case Op_ReverseBytesI:
 1519     case Op_ReverseBytesL:
 1520       return UseByteReverseInstruction;
 1521 
 1522     // PopCount supported by H/W from z/Architecture G5 (z196) on.
 1523     case Op_PopCountI:
 1524     case Op_PopCountL:
 1525       return UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount();
 1526 
 1527     case Op_StrComp:
 1528       return SpecialStringCompareTo;
 1529     case Op_StrEquals:
 1530       return SpecialStringEquals;
 1531     case Op_StrIndexOf:
 1532     case Op_StrIndexOfChar:
 1533       return SpecialStringIndexOf;
 1534 
 1535     case Op_GetAndAddI:
 1536     case Op_GetAndAddL:
 1537       return true;
 1538       // return VM_Version::has_AtomicMemWithImmALUOps();
 1539     case Op_GetAndSetI:
 1540     case Op_GetAndSetL:
 1541     case Op_GetAndSetP:
 1542     case Op_GetAndSetN:
 1543       return true;  // General CAS implementation, always available.
 1544 
 1545     default:
 1546       return true;  // Per default match rules are supported.
 1547                     // BUT: make sure match rule is not disabled by a false predicate!
 1548   }
 1549 
 1550   return true;  // Per default match rules are supported.
 1551                 // BUT: make sure match rule is not disabled by a false predicate!
 1552 }
 1553 
 1554 const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {
 1555   // TODO
 1556   // Identify extra cases that we might want to provide match rules for
 1557   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen.
 1558   bool ret_value = match_rule_supported(opcode);
 1559   // Add rules here.
 1560 
 1561   return ret_value;  // Per default match rules are supported.
 1562 }
 1563 
 1564 int Matcher::regnum_to_fpu_offset(int regnum) {
 1565   ShouldNotReachHere();
 1566   return regnum - 32; // The FP registers are in the second chunk.
 1567 }
 1568 
 1569 const bool Matcher::has_predicated_vectors(void) {
 1570   return false;
 1571 }
 1572 
 1573 const int Matcher::float_pressure(int default_pressure_threshold) {
 1574   return default_pressure_threshold;
 1575 }
 1576 
 1577 const bool Matcher::convL2FSupported(void) {
 1578   return true; // False means that conversion is done by runtime call.
 1579 }
 1580 
 1581 //----------SUPERWORD HELPERS----------------------------------------
 1582 
 1583 // Vector width in bytes.
 1584 const int Matcher::vector_width_in_bytes(BasicType bt) {
 1585   assert(MaxVectorSize == 8, &quot;&quot;);
 1586   return 8;
 1587 }
 1588 
 1589 // Vector ideal reg.
 1590 const uint Matcher::vector_ideal_reg(int size) {
 1591   assert(MaxVectorSize == 8 &amp;&amp; size == 8, &quot;&quot;);
 1592   return Op_RegL;
 1593 }
 1594 
 1595 // Limits on vector size (number of elements) loaded into vector.
 1596 const int Matcher::max_vector_size(const BasicType bt) {
 1597   assert(is_java_primitive(bt), &quot;only primitive type vectors&quot;);
 1598   return vector_width_in_bytes(bt)/type2aelembytes(bt);
 1599 }
 1600 
 1601 const int Matcher::min_vector_size(const BasicType bt) {
 1602   return max_vector_size(bt); // Same as max.
 1603 }
 1604 
 1605 const uint Matcher::vector_shift_count_ideal_reg(int size) {
 1606   fatal(&quot;vector shift is not supported&quot;);
 1607   return Node::NotAMachineReg;
 1608 }
 1609 
 1610 // z/Architecture does support misaligned store/load at minimal extra cost.
 1611 const bool Matcher::misaligned_vectors_ok() {
 1612   return true;
 1613 }
 1614 
 1615 // Not yet ported to z/Architecture.
 1616 const bool Matcher::pass_original_key_for_aes() {
 1617   return false;
 1618 }
 1619 
 1620 // RETURNS: whether this branch offset is short enough that a short
 1621 // branch can be used.
 1622 //
 1623 // If the platform does not provide any short branch variants, then
 1624 // this method should return `false&#39; for offset 0.
 1625 //
 1626 // `Compile::Fill_buffer&#39; will decide on basis of this information
 1627 // whether to do the pass `Compile::Shorten_branches&#39; at all.
 1628 //
 1629 // And `Compile::Shorten_branches&#39; will decide on basis of this
 1630 // information whether to replace particular branch sites by short
 1631 // ones.
 1632 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1633   // On zarch short branches use a 16 bit signed immediate that
 1634   // is the pc-relative offset in halfword (= 2 bytes) units.
 1635   return Assembler::is_within_range_of_RelAddr16((address)((long)offset), (address)0);
 1636 }
 1637 
 1638 const bool Matcher::isSimpleConstant64(jlong value) {
 1639   // Probably always true, even if a temp register is required.
 1640   return true;
 1641 }
 1642 
 1643 // Should correspond to setting above
 1644 const bool Matcher::init_array_count_is_in_bytes = false;
 1645 
 1646 // Suppress CMOVL. Conditional move available on z/Architecture only from z196 onwards. Not exploited yet.
 1647 const int Matcher::long_cmove_cost() { return ConditionalMoveLimit; }
 1648 
 1649 // Suppress CMOVF. Conditional move available on z/Architecture only from z196 onwards. Not exploited yet.
 1650 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1651 
 1652 // Does the CPU require postalloc expand (see block.cpp for description of postalloc expand)?
 1653 const bool Matcher::require_postalloc_expand = false;
 1654 
 1655 // Do we need to mask the count passed to shift instructions or does
 1656 // the cpu only look at the lower 5/6 bits anyway?
 1657 // 32bit shifts mask in emitter, 64bit shifts need no mask.
 1658 // Constant shift counts are handled in Ideal phase.
 1659 const bool Matcher::need_masked_shift_count = false;
 1660 
 1661 // No support for generic vector operands.
 1662 const bool Matcher::supports_generic_vector_operands  = false;
 1663 
 1664 MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {
 1665   ShouldNotReachHere(); // generic vector operands not supported
 1666   return NULL;
 1667 }
 1668 
 1669 bool Matcher::is_generic_reg2reg_move(MachNode* m) {
 1670   ShouldNotReachHere();  // generic vector operands not supported
 1671   return false;
 1672 }
 1673 
 1674 bool Matcher::is_generic_vector(MachOper* opnd)  {
 1675   ShouldNotReachHere();  // generic vector operands not supported
 1676   return false;
 1677 }
 1678 
 1679 // Set this as clone_shift_expressions.
 1680 bool Matcher::narrow_oop_use_complex_address() {
 1681   if (CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0) return true;
 1682   return false;
 1683 }
 1684 
 1685 bool Matcher::narrow_klass_use_complex_address() {
 1686   NOT_LP64(ShouldNotCallThis());
 1687   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1688   // TODO HS25: z port if (MatchDecodeNodes) return true;
 1689   return false;
 1690 }
 1691 
 1692 bool Matcher::const_oop_prefer_decode() {
 1693   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
 1694   return CompressedOops::base() == NULL;
 1695 }
 1696 
 1697 bool Matcher::const_klass_prefer_decode() {
 1698   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 1699   return CompressedKlassPointers::base() == NULL;
 1700 }
 1701 
 1702 // Is it better to copy float constants, or load them directly from memory?
 1703 // Most RISCs will have to materialize an address into a
 1704 // register first, so they would do better to copy the constant from stack.
 1705 const bool Matcher::rematerialize_float_constants = false;
 1706 
 1707 // If CPU can load and store mis-aligned doubles directly then no fixup is
 1708 // needed. Else we split the double into 2 integer pieces and move it
 1709 // piece-by-piece. Only happens when passing doubles into C code as the
 1710 // Java calling convention forces doubles to be aligned.
 1711 const bool Matcher::misaligned_doubles_ok = true;
 1712 
 1713 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1714 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1715 
 1716 // Do floats take an entire double register or just half?
 1717 //
 1718 // A float in resides in a zarch double register. When storing it by
 1719 // z_std, it cannot be restored in C-code by reloading it as a double
 1720 // and casting it into a float afterwards.
 1721 bool Matcher::float_in_double() { return false; }
 1722 
 1723 // Do ints take an entire long register or just half?
 1724 // The relevant question is how the int is callee-saved:
 1725 // the whole long is written but de-opt&#39;ing will have to extract
 1726 // the relevant 32 bits.
 1727 const bool Matcher::int_in_long = true;
 1728 
 1729 // Constants for c2c and c calling conventions.
 1730 
 1731 const MachRegisterNumbers z_iarg_reg[5] = {
 1732   Z_R2_num, Z_R3_num, Z_R4_num, Z_R5_num, Z_R6_num
 1733 };
 1734 
 1735 const MachRegisterNumbers z_farg_reg[4] = {
 1736   Z_F0_num, Z_F2_num, Z_F4_num, Z_F6_num
 1737 };
 1738 
 1739 const int z_num_iarg_registers = sizeof(z_iarg_reg) / sizeof(z_iarg_reg[0]);
 1740 
 1741 const int z_num_farg_registers = sizeof(z_farg_reg) / sizeof(z_farg_reg[0]);
 1742 
 1743 // Return whether or not this register is ever used as an argument. This
 1744 // function is used on startup to build the trampoline stubs in generateOptoStub.
 1745 // Registers not mentioned will be killed by the VM call in the trampoline, and
 1746 // arguments in those registers not be available to the callee.
 1747 bool Matcher::can_be_java_arg(int reg) {
 1748   // We return true for all registers contained in z_iarg_reg[] and
 1749   // z_farg_reg[] and their virtual halves.
 1750   // We must include the virtual halves in order to get STDs and LDs
 1751   // instead of STWs and LWs in the trampoline stubs.
 1752 
 1753   if (reg == Z_R2_num || reg == Z_R2_H_num ||
 1754       reg == Z_R3_num || reg == Z_R3_H_num ||
 1755       reg == Z_R4_num || reg == Z_R4_H_num ||
 1756       reg == Z_R5_num || reg == Z_R5_H_num ||
 1757       reg == Z_R6_num || reg == Z_R6_H_num) {
 1758     return true;
 1759   }
 1760 
 1761   if (reg == Z_F0_num || reg == Z_F0_H_num ||
 1762       reg == Z_F2_num || reg == Z_F2_H_num ||
 1763       reg == Z_F4_num || reg == Z_F4_H_num ||
 1764       reg == Z_F6_num || reg == Z_F6_H_num) {
 1765     return true;
 1766   }
 1767 
 1768   return false;
 1769 }
 1770 
 1771 bool Matcher::is_spillable_arg(int reg) {
 1772   return can_be_java_arg(reg);
 1773 }
 1774 
 1775 bool Matcher::use_asm_for_ldiv_by_con(jlong divisor) {
 1776   return false;
 1777 }
 1778 
 1779 // Register for DIVI projection of divmodI
 1780 RegMask Matcher::divI_proj_mask() {
 1781   return _Z_RARG4_INT_REG_mask;
 1782 }
 1783 
 1784 // Register for MODI projection of divmodI
 1785 RegMask Matcher::modI_proj_mask() {
 1786   return _Z_RARG3_INT_REG_mask;
 1787 }
 1788 
 1789 // Register for DIVL projection of divmodL
 1790 RegMask Matcher::divL_proj_mask() {
 1791   return _Z_RARG4_LONG_REG_mask;
 1792 }
 1793 
 1794 // Register for MODL projection of divmodL
 1795 RegMask Matcher::modL_proj_mask() {
 1796   return _Z_RARG3_LONG_REG_mask;
 1797 }
 1798 
 1799 // Copied from sparc.
 1800 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1801   return RegMask();
 1802 }
 1803 
 1804 const bool Matcher::convi2l_type_required = true;
 1805 
 1806 // Should the Matcher clone shifts on addressing modes, expecting them
 1807 // to be subsumed into complex addressing expressions or compute them
 1808 // into registers?
 1809 bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
 1810   return clone_base_plus_offset_address(m, mstack, address_visited);
 1811 }
 1812 
 1813 void Compile::reshape_address(AddPNode* addp) {
 1814 }
 1815 
 1816 %} // source
 1817 
 1818 //----------ENCODING BLOCK-----------------------------------------------------
 1819 // This block specifies the encoding classes used by the compiler to output
 1820 // byte streams. Encoding classes are parameterized macros used by
 1821 // Machine Instruction Nodes in order to generate the bit encoding of the
 1822 // instruction. Operands specify their base encoding interface with the
 1823 // interface keyword. There are currently supported four interfaces,
 1824 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER. REG_INTER causes an
 1825 // operand to generate a function which returns its register number when
 1826 // queried. CONST_INTER causes an operand to generate a function which
 1827 // returns the value of the constant when queried. MEMORY_INTER causes an
 1828 // operand to generate four functions which return the Base Register, the
 1829 // Index Register, the Scale Value, and the Offset Value of the operand when
 1830 // queried. COND_INTER causes an operand to generate six functions which
 1831 // return the encoding code (ie - encoding bits for the instruction)
 1832 // associated with each basic boolean condition for a conditional instruction.
 1833 //
 1834 // Instructions specify two basic values for encoding. Again, a function
 1835 // is available to check if the constant displacement is an oop. They use the
 1836 // ins_encode keyword to specify their encoding classes (which must be
 1837 // a sequence of enc_class names, and their parameters, specified in
 1838 // the encoding block), and they use the
 1839 // opcode keyword to specify, in order, their primary, secondary, and
 1840 // tertiary opcode. Only the opcode sections which a particular instruction
 1841 // needs for encoding need to be specified.
 1842 encode %{
 1843   enc_class enc_unimplemented %{
 1844     C2_MacroAssembler _masm(&amp;cbuf);
 1845     __ unimplemented(&quot;Unimplemented mach node encoding in AD file.&quot;, 13);
 1846   %}
 1847 
 1848   enc_class enc_untested %{
 1849 #ifdef ASSERT
 1850     C2_MacroAssembler _masm(&amp;cbuf);
 1851     __ untested(&quot;Untested mach node encoding in AD file.&quot;);
 1852 #endif
 1853   %}
 1854 
 1855   enc_class z_rrform(iRegI dst, iRegI src) %{
 1856     assert((($primary &gt;&gt; 14) &amp; 0x03) == 0, &quot;Instruction format error&quot;);
 1857     assert( ($primary &gt;&gt; 16)         == 0, &quot;Instruction format error&quot;);
 1858     z_emit16(cbuf, $primary |
 1859              Assembler::reg($dst$$reg,8,16) |
 1860              Assembler::reg($src$$reg,12,16));
 1861   %}
 1862 
 1863   enc_class z_rreform(iRegI dst1, iRegI src2) %{
 1864     assert((($primary &gt;&gt; 30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1865     z_emit32(cbuf, $primary |
 1866              Assembler::reg($dst1$$reg,24,32) |
 1867              Assembler::reg($src2$$reg,28,32));
 1868   %}
 1869 
 1870   enc_class z_rrfform(iRegI dst1, iRegI src2, iRegI src3) %{
 1871     assert((($primary &gt;&gt; 30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1872     z_emit32(cbuf, $primary |
 1873              Assembler::reg($dst1$$reg,24,32) |
 1874              Assembler::reg($src2$$reg,28,32) |
 1875              Assembler::reg($src3$$reg,16,32));
 1876   %}
 1877 
 1878   enc_class z_riform_signed(iRegI dst, immI16 src) %{
 1879     assert((($primary&gt;&gt;30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1880     z_emit32(cbuf, $primary |
 1881              Assembler::reg($dst$$reg,8,32) |
 1882              Assembler::simm16($src$$constant,16,32));
 1883   %}
 1884 
 1885   enc_class z_riform_unsigned(iRegI dst, uimmI16 src) %{
 1886     assert((($primary&gt;&gt;30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1887     z_emit32(cbuf, $primary |
 1888              Assembler::reg($dst$$reg,8,32) |
 1889              Assembler::uimm16($src$$constant,16,32));
 1890   %}
 1891 
 1892   enc_class z_rieform_d(iRegI dst1, iRegI src3, immI src2) %{
 1893     assert((($primary&gt;&gt;46) &amp; 0x03) == 3, &quot;Instruction format error&quot;);
 1894     z_emit48(cbuf, $primary |
 1895              Assembler::reg($dst1$$reg,8,48) |
 1896              Assembler::reg($src3$$reg,12,48) |
 1897              Assembler::simm16($src2$$constant,16,48));
 1898   %}
 1899 
 1900   enc_class z_rilform_signed(iRegI dst, immL32 src) %{
 1901     assert((($primary&gt;&gt;46) &amp; 0x03) == 3, &quot;Instruction format error&quot;);
 1902     z_emit48(cbuf, $primary |
 1903              Assembler::reg($dst$$reg,8,48) |
 1904              Assembler::simm32($src$$constant,16,48));
 1905   %}
 1906 
 1907   enc_class z_rilform_unsigned(iRegI dst, uimmL32 src) %{
 1908     assert((($primary&gt;&gt;46) &amp; 0x03) == 3, &quot;Instruction format error&quot;);
 1909     z_emit48(cbuf, $primary |
 1910              Assembler::reg($dst$$reg,8,48) |
 1911              Assembler::uimm32($src$$constant,16,48));
 1912   %}
 1913 
 1914   enc_class z_rsyform_const(iRegI dst, iRegI src1, immI src2) %{
 1915     z_emit48(cbuf, $primary |
 1916              Assembler::reg($dst$$reg,8,48) |
 1917              Assembler::reg($src1$$reg,12,48) |
 1918              Assembler::simm20($src2$$constant));
 1919   %}
 1920 
 1921   enc_class z_rsyform_reg_reg(iRegI dst, iRegI src, iRegI shft) %{
 1922     z_emit48(cbuf, $primary |
 1923              Assembler::reg($dst$$reg,8,48) |
 1924              Assembler::reg($src$$reg,12,48) |
 1925              Assembler::reg($shft$$reg,16,48) |
 1926              Assembler::simm20(0));
 1927   %}
 1928 
 1929   enc_class z_rxform_imm_reg_reg(iRegL dst, immL con, iRegL src1, iRegL src2) %{
 1930     assert((($primary&gt;&gt;30) &amp; 0x03) == 1, &quot;Instruction format error&quot;);
 1931     z_emit32(cbuf, $primary |
 1932              Assembler::reg($dst$$reg,8,32) |
 1933              Assembler::reg($src1$$reg,12,32) |
 1934              Assembler::reg($src2$$reg,16,32) |
 1935              Assembler::uimm12($con$$constant,20,32));
 1936   %}
 1937 
 1938   enc_class z_rxform_imm_reg(iRegL dst, immL con, iRegL src) %{
 1939     assert((($primary&gt;&gt;30) &amp; 0x03) == 1, &quot;Instruction format error&quot;);
 1940     z_emit32(cbuf, $primary |
 1941              Assembler::reg($dst$$reg,8,32) |
 1942              Assembler::reg($src$$reg,16,32) |
 1943              Assembler::uimm12($con$$constant,20,32));
 1944   %}
 1945 
 1946   enc_class z_rxyform_imm_reg_reg(iRegL dst, immL con, iRegL src1, iRegL src2) %{
 1947     z_emit48(cbuf, $primary |
 1948              Assembler::reg($dst$$reg,8,48) |
 1949              Assembler::reg($src1$$reg,12,48) |
 1950              Assembler::reg($src2$$reg,16,48) |
 1951              Assembler::simm20($con$$constant));
 1952   %}
 1953 
 1954   enc_class z_rxyform_imm_reg(iRegL dst, immL con, iRegL src) %{
 1955     z_emit48(cbuf, $primary |
 1956              Assembler::reg($dst$$reg,8,48) |
 1957              Assembler::reg($src$$reg,16,48) |
 1958              Assembler::simm20($con$$constant));
 1959   %}
 1960 
 1961   // Direct memory arithmetic.
 1962   enc_class z_siyform(memoryRSY mem, immI8 src) %{
 1963     int      disp = $mem$$disp;
 1964     Register base = reg_to_register_object($mem$$base);
 1965     int      con  = $src$$constant;
 1966 
 1967     assert(VM_Version::has_MemWithImmALUOps(), &quot;unsupported CPU&quot;);
 1968     z_emit_inst(cbuf, $primary |
 1969                 Assembler::regz(base,16,48) |
 1970                 Assembler::simm20(disp) |
 1971                 Assembler::simm8(con,8,48));
 1972   %}
 1973 
 1974   enc_class z_silform(memoryRS mem, immI16 src) %{
 1975     z_emit_inst(cbuf, $primary |
 1976                 Assembler::regz(reg_to_register_object($mem$$base),16,48) |
 1977                 Assembler::uimm12($mem$$disp,20,48) |
 1978                 Assembler::simm16($src$$constant,32,48));
 1979   %}
 1980 
 1981   // Encoder for FP ALU reg/mem instructions (support only short displacements).
 1982   enc_class z_form_rt_memFP(RegF dst, memoryRX mem) %{
 1983     Register Ridx = $mem$$index$$Register;
 1984     if (Ridx == noreg) { Ridx = Z_R0; } // Index is 0.
 1985     if ($primary &gt; (1L &lt;&lt; 32)) {
 1986       z_emit_inst(cbuf, $primary |
 1987                   Assembler::reg($dst$$reg, 8, 48) |
 1988                   Assembler::uimm12($mem$$disp, 20, 48) |
 1989                   Assembler::reg(Ridx, 12, 48) |
 1990                   Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
 1991     } else {
 1992       z_emit_inst(cbuf, $primary |
 1993                   Assembler::reg($dst$$reg, 8, 32) |
 1994                   Assembler::uimm12($mem$$disp, 20, 32) |
 1995                   Assembler::reg(Ridx, 12, 32) |
 1996                   Assembler::regz(reg_to_register_object($mem$$base), 16, 32));
 1997     }
 1998   %}
 1999 
 2000   enc_class z_form_rt_mem(iRegI dst, memory mem) %{
 2001     Register Ridx = $mem$$index$$Register;
 2002     if (Ridx == noreg) { Ridx = Z_R0; } // Index is 0.
 2003     if ($primary &gt; (1L&lt;&lt;32)) {
 2004       z_emit_inst(cbuf, $primary |
 2005                   Assembler::reg($dst$$reg, 8, 48) |
 2006                   Assembler::simm20($mem$$disp) |
 2007                   Assembler::reg(Ridx, 12, 48) |
 2008                   Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
 2009     } else {
 2010       z_emit_inst(cbuf, $primary |
 2011                   Assembler::reg($dst$$reg, 8, 32) |
 2012                   Assembler::uimm12($mem$$disp, 20, 32) |
 2013                   Assembler::reg(Ridx, 12, 32) |
 2014                   Assembler::regz(reg_to_register_object($mem$$base), 16, 32));
 2015     }
 2016   %}
 2017 
 2018   enc_class z_form_rt_mem_opt(iRegI dst, memory mem) %{
 2019     int isize = $secondary &gt; 1L &lt;&lt; 32 ? 48 : 32;
 2020     Register Ridx = $mem$$index$$Register;
 2021     if (Ridx == noreg) { Ridx = Z_R0; } // Index is 0.
 2022 
 2023     if (Displacement::is_shortDisp((long)$mem$$disp)) {
 2024       z_emit_inst(cbuf, $secondary |
 2025                   Assembler::reg($dst$$reg, 8, isize) |
 2026                   Assembler::uimm12($mem$$disp, 20, isize) |
 2027                   Assembler::reg(Ridx, 12, isize) |
 2028                   Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
 2029     } else if (Displacement::is_validDisp((long)$mem$$disp)) {
 2030       z_emit_inst(cbuf, $primary |
 2031                   Assembler::reg($dst$$reg, 8, 48) |
 2032                   Assembler::simm20($mem$$disp) |
 2033                   Assembler::reg(Ridx, 12, 48) |
 2034                   Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
 2035     } else {
 2036         C2_MacroAssembler _masm(&amp;cbuf);
 2037         __ load_const_optimized(Z_R1_scratch, $mem$$disp);
 2038         if (Ridx != Z_R0) { __ z_agr(Z_R1_scratch, Ridx); }
 2039         z_emit_inst(cbuf, $secondary |
 2040                     Assembler::reg($dst$$reg, 8, isize) |
 2041                     Assembler::uimm12(0, 20, isize) |
 2042                     Assembler::reg(Z_R1_scratch, 12, isize) |
 2043                     Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
 2044     }
 2045   %}
 2046 
 2047   enc_class z_enc_brul(Label lbl) %{
 2048     C2_MacroAssembler _masm(&amp;cbuf);
 2049     Label* p = $lbl$$label;
 2050 
 2051     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2052     // determine the size of the encoded instruction.
 2053     // Use a bound dummy label in that case.
 2054     Label d;
 2055     __ bind(d);
 2056     Label&amp; l = (NULL == p) ? d : *(p);
 2057     __ z_brul(l);
 2058   %}
 2059 
 2060   enc_class z_enc_bru(Label lbl) %{
 2061     C2_MacroAssembler _masm(&amp;cbuf);
 2062     Label* p = $lbl$$label;
 2063 
 2064     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2065     // determine the size of the encoded instruction.
 2066     // Use a bound dummy label in that case.
 2067     Label d;
 2068     __ bind(d);
 2069     Label&amp; l = (NULL == p) ? d : *(p);
 2070     __ z_bru(l);
 2071   %}
 2072 
 2073   enc_class z_enc_branch_con_far(cmpOp cmp, Label lbl) %{
 2074     C2_MacroAssembler _masm(&amp;cbuf);
 2075     Label* p = $lbl$$label;
 2076 
 2077     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2078     // determine the size of the encoded instruction.
 2079     // Use a bound dummy label in that case.
 2080     Label d;
 2081     __ bind(d);
 2082     Label&amp; l = (NULL == p) ? d : *(p);
 2083     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2084   %}
 2085 
 2086   enc_class z_enc_branch_con_short(cmpOp cmp, Label lbl) %{
 2087     C2_MacroAssembler _masm(&amp;cbuf);
 2088     Label* p = $lbl$$label;
 2089 
 2090     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2091     // determine the size of the encoded instruction.
 2092     // Use a bound dummy label in that case.
 2093     Label d;
 2094     __ bind(d);
 2095     Label&amp; l = (NULL == p) ? d : *(p);
 2096     __ z_brc((Assembler::branch_condition)$cmp$$cmpcode, l);
 2097   %}
 2098 
 2099   enc_class z_enc_cmpb_regreg(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
 2100     C2_MacroAssembler _masm(&amp;cbuf);
 2101     Label* p = $lbl$$label;
 2102 
 2103     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2104     // determine the size of the encoded instruction.
 2105     // Use a bound dummy label in that case.
 2106     Label d;
 2107     __ bind(d);
 2108     Label&amp; l = (NULL == p) ? d : *(p);
 2109     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2110     unsigned long instr = $primary;
 2111     if (instr == CRJ_ZOPC) {
 2112       __ z_crj($src1$$Register, $src2$$Register, cc, l);
 2113     } else if (instr == CLRJ_ZOPC) {
 2114       __ z_clrj($src1$$Register, $src2$$Register, cc, l);
 2115     } else if (instr == CGRJ_ZOPC) {
 2116       __ z_cgrj($src1$$Register, $src2$$Register, cc, l);
 2117     } else {
 2118       guarantee(instr == CLGRJ_ZOPC, &quot;opcode not implemented&quot;);
 2119       __ z_clgrj($src1$$Register, $src2$$Register, cc, l);
 2120     }
 2121   %}
 2122 
 2123   enc_class z_enc_cmpb_regregFar(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
 2124     C2_MacroAssembler _masm(&amp;cbuf);
 2125     Label* p = $lbl$$label;
 2126 
 2127     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2128     // determine the size of the encoded instruction.
 2129     // Use a bound dummy label in that case.
 2130     Label d;
 2131     __ bind(d);
 2132     Label&amp; l = (NULL == p) ? d : *(p);
 2133 
 2134     unsigned long instr = $primary;
 2135     if (instr == CR_ZOPC) {
 2136       __ z_cr($src1$$Register, $src2$$Register);
 2137     } else if (instr == CLR_ZOPC) {
 2138       __ z_clr($src1$$Register, $src2$$Register);
 2139     } else if (instr == CGR_ZOPC) {
 2140       __ z_cgr($src1$$Register, $src2$$Register);
 2141     } else {
 2142       guarantee(instr == CLGR_ZOPC, &quot;opcode not implemented&quot;);
 2143       __ z_clgr($src1$$Register, $src2$$Register);
 2144     }
 2145 
 2146     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2147   %}
 2148 
 2149   enc_class z_enc_cmpb_regimm(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
 2150     C2_MacroAssembler _masm(&amp;cbuf);
 2151     Label* p = $lbl$$label;
 2152 
 2153     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2154     // determine the size of the encoded instruction.
 2155     // Use a bound dummy label in that case.
 2156     Label d;
 2157     __ bind(d);
 2158     Label&amp; l = (NULL == p) ? d : *(p);
 2159 
 2160     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2161     unsigned long instr = $primary;
 2162     if (instr == CIJ_ZOPC) {
 2163       __ z_cij($src1$$Register, $src2$$constant, cc, l);
 2164     } else if (instr == CLIJ_ZOPC) {
 2165       __ z_clij($src1$$Register, $src2$$constant, cc, l);
 2166     } else if (instr == CGIJ_ZOPC) {
 2167       __ z_cgij($src1$$Register, $src2$$constant, cc, l);
 2168     } else {
 2169       guarantee(instr == CLGIJ_ZOPC, &quot;opcode not implemented&quot;);
 2170       __ z_clgij($src1$$Register, $src2$$constant, cc, l);
 2171     }
 2172   %}
 2173 
 2174   enc_class z_enc_cmpb_regimmFar(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
 2175     C2_MacroAssembler _masm(&amp;cbuf);
 2176     Label* p = $lbl$$label;
 2177 
 2178     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2179     // determine the size of the encoded instruction.
 2180     // Use a bound dummy label in that case.
 2181     Label d;
 2182     __ bind(d);
 2183     Label&amp; l = (NULL == p) ? d : *(p);
 2184 
 2185     unsigned long instr = $primary;
 2186     if (instr == CHI_ZOPC) {
 2187       __ z_chi($src1$$Register, $src2$$constant);
 2188     } else if (instr == CLFI_ZOPC) {
 2189       __ z_clfi($src1$$Register, $src2$$constant);
 2190     } else if (instr == CGHI_ZOPC) {
 2191       __ z_cghi($src1$$Register, $src2$$constant);
 2192     } else {
 2193       guarantee(instr == CLGFI_ZOPC, &quot;opcode not implemented&quot;);
 2194       __ z_clgfi($src1$$Register, $src2$$constant);
 2195     }
 2196 
 2197     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2198   %}
 2199 
 2200   // Call from Java to runtime.
 2201   enc_class z_enc_java_to_runtime_call(method meth) %{
 2202     C2_MacroAssembler _masm(&amp;cbuf);
 2203 
 2204     // Save return pc before call to the place where we need it, since
 2205     // callee doesn&#39;t.
 2206     unsigned int start_off = __ offset();
 2207     // Compute size of &quot;larl + stg + call_c_opt&quot;.
 2208     const int size_of_code = 6 + 6 + MacroAssembler::call_far_patchable_size();
 2209     __ get_PC(Z_R14, size_of_code);
 2210     __ save_return_pc();
 2211     assert(__ offset() - start_off == 12, &quot;bad prelude len: %d&quot;, __ offset() - start_off);
 2212 
 2213     assert((__ offset() &amp; 2) == 0, &quot;misaligned z_enc_java_to_runtime_call&quot;);
 2214     address call_addr = __ call_c_opt((address)$meth$$method);
 2215     if (call_addr == NULL) {
 2216       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 2217       return;
 2218     }
 2219 
 2220 #ifdef ASSERT
 2221     // Plausibility check for size_of_code assumptions.
 2222     unsigned int actual_ret_off = __ offset();
 2223     assert(start_off + size_of_code == actual_ret_off, &quot;wrong return_pc&quot;);
 2224 #endif
 2225   %}
 2226 
 2227   enc_class z_enc_java_static_call(method meth) %{
 2228     // Call to fixup routine. Fixup routine uses ScopeDesc info to determine
 2229     // whom we intended to call.
 2230     C2_MacroAssembler _masm(&amp;cbuf);
 2231     int ret_offset = 0;
 2232 
 2233     if (!_method) {
 2234       ret_offset = emit_call_reloc(_masm, $meth$$method,
 2235                                    relocInfo::runtime_call_w_cp_type, ra_);
 2236     } else {
 2237       int method_index = resolved_method_index(cbuf);
 2238       if (_optimized_virtual) {
 2239         ret_offset = emit_call_reloc(_masm, $meth$$method,
 2240                                      opt_virtual_call_Relocation::spec(method_index));
 2241       } else {
 2242         ret_offset = emit_call_reloc(_masm, $meth$$method,
 2243                                      static_call_Relocation::spec(method_index));
 2244       }
 2245     }
 2246     assert(__ inst_mark() != NULL, &quot;emit_call_reloc must set_inst_mark()&quot;);
 2247 
 2248     if (_method) { // Emit stub for static call.
 2249       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 2250       if (stub == NULL) {
 2251         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2252         return;
 2253       }
 2254     }
 2255   %}
 2256 
 2257   // Java dynamic call
 2258   enc_class z_enc_java_dynamic_call(method meth) %{
 2259     C2_MacroAssembler _masm(&amp;cbuf);
 2260     unsigned int start_off = __ offset();
 2261 
 2262     int vtable_index = this-&gt;_vtable_index;
 2263     if (vtable_index == -4) {
 2264       Register ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2265       address virtual_call_oop_addr = NULL;
 2266 
 2267       AddressLiteral empty_ic((address) Universe::non_oop_word());
 2268       virtual_call_oop_addr = __ pc();
 2269       bool success = __ load_const_from_toc(ic_reg, empty_ic);
 2270       if (!success) {
 2271         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 2272         return;
 2273       }
 2274 
 2275       // Call to fixup routine. Fixup routine uses ScopeDesc info
 2276       // to determine who we intended to call.
 2277       int method_index = resolved_method_index(cbuf);
 2278       __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
 2279       unsigned int ret_off = __ offset();
 2280       assert(__ offset() - start_off == 6, &quot;bad prelude len: %d&quot;, __ offset() - start_off);
 2281       ret_off += emit_call_reloc(_masm, $meth$$method, relocInfo::none, ra_);
 2282       assert(_method, &quot;lazy_constant may be wrong when _method==null&quot;);
 2283     } else {
 2284       assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 2285       // Go through the vtable. Get receiver klass. Receiver already
 2286       // checked for non-null. If we&#39;ll go thru a C2I adapter, the
 2287       // interpreter expects method in Z_method.
 2288       // Use Z_method to temporarily hold the klass oop.
 2289       // Z_R1_scratch is destroyed.
 2290       __ load_klass(Z_method, Z_R2);
 2291 
 2292       int entry_offset = in_bytes(Klass::vtable_start_offset()) + vtable_index * vtableEntry::size_in_bytes();
 2293       int v_off        = entry_offset + vtableEntry::method_offset_in_bytes();
 2294 
 2295       if (Displacement::is_validDisp(v_off) ) {
 2296         // Can use load instruction with large offset.
 2297         __ z_lg(Z_method, Address(Z_method /*class oop*/, v_off /*method offset*/));
 2298       } else {
 2299         // Worse case, must load offset into register.
 2300         __ load_const(Z_R1_scratch, v_off);
 2301         __ z_lg(Z_method, Address(Z_method /*class oop*/, Z_R1_scratch /*method offset*/));
 2302       }
 2303       // NOTE: for vtable dispatches, the vtable entry will never be
 2304       // null. However it may very well end up in handle_wrong_method
 2305       // if the method is abstract for the particular class.
 2306       __ z_lg(Z_R1_scratch, Address(Z_method, Method::from_compiled_offset()));
 2307       // Call target. Either compiled code or C2I adapter.
 2308       __ z_basr(Z_R14, Z_R1_scratch);
 2309       unsigned int ret_off = __ offset();
 2310     }
 2311   %}
 2312 
 2313   enc_class z_enc_cmov_reg(cmpOp cmp, iRegI dst, iRegI src) %{
 2314     C2_MacroAssembler _masm(&amp;cbuf);
 2315     Register Rdst = reg_to_register_object($dst$$reg);
 2316     Register Rsrc = reg_to_register_object($src$$reg);
 2317 
 2318     // Don&#39;t emit code if operands are identical (same register).
 2319     if (Rsrc != Rdst) {
 2320       Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2321 
 2322       if (VM_Version::has_LoadStoreConditional()) {
 2323         __ z_locgr(Rdst, Rsrc, cc);
 2324       } else {
 2325         // Branch if not (cmp cr).
 2326         Label done;
 2327         __ z_brc(Assembler::inverse_condition(cc), done);
 2328         __ z_lgr(Rdst, Rsrc); // Used for int and long+ptr.
 2329         __ bind(done);
 2330       }
 2331     }
 2332   %}
 2333 
 2334   enc_class z_enc_cmov_imm(cmpOp cmp, iRegI dst, immI16 src) %{
 2335     C2_MacroAssembler _masm(&amp;cbuf);
 2336     Register Rdst = reg_to_register_object($dst$$reg);
 2337     int      Csrc = $src$$constant;
 2338     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2339     Label done;
 2340     // Branch if not (cmp cr).
 2341     __ z_brc(Assembler::inverse_condition(cc), done);
 2342     if (Csrc == 0) {
 2343       // Don&#39;t set CC.
 2344       __ clear_reg(Rdst, true, false);  // Use for int, long &amp; ptr.
 2345     } else {
 2346       __ z_lghi(Rdst, Csrc); // Use for int, long &amp; ptr.
 2347     }
 2348     __ bind(done);
 2349   %}
 2350 
 2351   enc_class z_enc_cctobool(iRegI res) %{
 2352     C2_MacroAssembler _masm(&amp;cbuf);
 2353     Register Rres = reg_to_register_object($res$$reg);
 2354 
 2355     if (VM_Version::has_LoadStoreConditional()) {
 2356       __ load_const_optimized(Z_R0_scratch, 0L); // false (failed)
 2357       __ load_const_optimized(Rres, 1L);         // true  (succeed)
 2358       __ z_locgr(Rres, Z_R0_scratch, Assembler::bcondNotEqual);
 2359     } else {
 2360       Label done;
 2361       __ load_const_optimized(Rres, 0L); // false (failed)
 2362       __ z_brne(done);                   // Assume true to be the common case.
 2363       __ load_const_optimized(Rres, 1L); // true  (succeed)
 2364       __ bind(done);
 2365     }
 2366   %}
 2367 
 2368   enc_class z_enc_casI(iRegI compare_value, iRegI exchange_value, iRegP addr_ptr) %{
 2369     C2_MacroAssembler _masm(&amp;cbuf);
 2370     Register Rcomp = reg_to_register_object($compare_value$$reg);
 2371     Register Rnew  = reg_to_register_object($exchange_value$$reg);
 2372     Register Raddr = reg_to_register_object($addr_ptr$$reg);
 2373 
 2374     __ z_cs(Rcomp, Rnew, 0, Raddr);
 2375   %}
 2376 
 2377   enc_class z_enc_casL(iRegL compare_value, iRegL exchange_value, iRegP addr_ptr) %{
 2378     C2_MacroAssembler _masm(&amp;cbuf);
 2379     Register Rcomp = reg_to_register_object($compare_value$$reg);
 2380     Register Rnew  = reg_to_register_object($exchange_value$$reg);
 2381     Register Raddr = reg_to_register_object($addr_ptr$$reg);
 2382 
 2383     __ z_csg(Rcomp, Rnew, 0, Raddr);
 2384   %}
 2385 
 2386   enc_class z_enc_SwapI(memoryRSY mem, iRegI dst, iRegI tmp) %{
 2387     C2_MacroAssembler _masm(&amp;cbuf);
 2388     Register Rdst = reg_to_register_object($dst$$reg);
 2389     Register Rtmp = reg_to_register_object($tmp$$reg);
 2390     guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
 2391     Label    retry;
 2392 
 2393     // Iterate until swap succeeds.
 2394     __ z_llgf(Rtmp, $mem$$Address);  // current contents
 2395     __ bind(retry);
 2396       // Calculate incremented value.
 2397       __ z_csy(Rtmp, Rdst, $mem$$Address); // Try to store new value.
 2398       __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
 2399     __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
 2400   %}
 2401 
 2402   enc_class z_enc_SwapL(memoryRSY mem, iRegL dst, iRegL tmp) %{
 2403     C2_MacroAssembler _masm(&amp;cbuf);
 2404     Register Rdst = reg_to_register_object($dst$$reg);
 2405     Register Rtmp = reg_to_register_object($tmp$$reg);
 2406     guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
 2407     Label    retry;
 2408 
 2409     // Iterate until swap succeeds.
 2410     __ z_lg(Rtmp, $mem$$Address);  // current contents
 2411     __ bind(retry);
 2412       // Calculate incremented value.
 2413       __ z_csg(Rtmp, Rdst, $mem$$Address); // Try to store new value.
 2414       __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
 2415     __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
 2416   %}
 2417 
 2418 %} // encode
 2419 
 2420 source %{
 2421 
 2422   // Check whether outs are all Stores. If so, we can omit clearing the upper
 2423   // 32 bits after encoding.
 2424   static bool all_outs_are_Stores(const Node *n) {
 2425     for (DUIterator_Fast imax, k = n-&gt;fast_outs(imax); k &lt; imax; k++) {
 2426       Node *out = n-&gt;fast_out(k);
 2427       if (!out-&gt;is_Mach() || out-&gt;as_Mach()-&gt;ideal_Opcode() != Op_StoreN) {
 2428         // Most other outs are SpillCopy, but there are various other.
 2429         // jvm98 has arond 9% Encodes where we return false.
 2430         return false;
 2431       }
 2432     }
 2433     return true;
 2434   }
 2435 
 2436 %} // source
 2437 
 2438 
 2439 //----------FRAME--------------------------------------------------------------
 2440 // Definition of frame structure and management information.
 2441 
 2442 frame %{
 2443   // What direction does stack grow in (assumed to be same for native &amp; Java).
 2444   stack_direction(TOWARDS_LOW);
 2445 
 2446   // These two registers define part of the calling convention between
 2447   // compiled code and the interpreter.
 2448 
 2449   // Inline Cache Register
 2450   inline_cache_reg(Z_R9); // Z_inline_cache
 2451 
 2452   // Argument pointer for I2C adapters
 2453   //
 2454   // Tos is loaded in run_compiled_code to Z_ARG5=Z_R6.
 2455   // interpreter_arg_ptr_reg(Z_R6);
 2456 
 2457   // Temporary in compiled entry-points
 2458   // compiler_method_oop_reg(Z_R1);//Z_R1_scratch
 2459 
 2460   // Method Oop Register when calling interpreter
 2461   interpreter_method_oop_reg(Z_R9);//Z_method
 2462 
 2463   // Optional: name the operand used by cisc-spilling to access
 2464   // [stack_pointer + offset].
 2465   cisc_spilling_operand_name(indOffset12);
 2466 
 2467   // Number of stack slots consumed by a Monitor enter.
 2468   sync_stack_slots(frame::jit_monitor_size_in_4_byte_units);
 2469 
 2470   // Compiled code&#39;s Frame Pointer
 2471   //
 2472   // z/Architecture stack pointer
 2473   frame_pointer(Z_R15); // Z_SP
 2474 
 2475   // Interpreter stores its frame pointer in a register which is
 2476   // stored to the stack by I2CAdaptors. I2CAdaptors convert from
 2477   // interpreted java to compiled java.
 2478   //
 2479   // Z_state holds pointer to caller&#39;s cInterpreter.
 2480   interpreter_frame_pointer(Z_R7); // Z_state
 2481 
 2482   // Use alignment_in_bytes instead of log_2_of_alignment_in_bits.
 2483   stack_alignment(frame::alignment_in_bytes);
 2484 
 2485   in_preserve_stack_slots(frame::jit_in_preserve_size_in_4_byte_units);
 2486 
 2487   // A `slot&#39; is assumed 4 bytes here!
 2488   // out_preserve_stack_slots(frame::jit_out_preserve_size_in_4_byte_units);
 2489 
 2490   // Number of outgoing stack slots killed above the
 2491   // out_preserve_stack_slots for calls to C. Supports the var-args
 2492   // backing area for register parms.
 2493   varargs_C_out_slots_killed(((frame::z_abi_160_size - frame::z_jit_out_preserve_size) / VMRegImpl::stack_slot_size));
 2494 
 2495   // The after-PROLOG location of the return address. Location of
 2496   // return address specifies a type (REG or STACK) and a number
 2497   // representing the register number (i.e. - use a register name) or
 2498   // stack slot.
 2499   return_addr(REG Z_R14);
 2500 
 2501   // This is the body of the function
 2502   //
 2503   // void Matcher::calling_convention(OptoRegPair* sig /* array of ideal regs */,
 2504   //                                  uint length      /* length of array */,
 2505   //                                  bool is_outgoing)
 2506   //
 2507   // The `sig&#39; array is to be updated. Sig[j] represents the location
 2508   // of the j-th argument, either a register or a stack slot.
 2509 
 2510   // Body of function which returns an integer array locating
 2511   // arguments either in registers or in stack slots. Passed an array
 2512   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 2513   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2514   // arguments for a CALLEE. Incoming stack arguments are
 2515   // automatically biased by the preserve_stack_slots field above.
 2516   calling_convention %{
 2517     // No difference between ingoing/outgoing just pass false.
 2518     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 2519   %}
 2520 
 2521   // Body of function which returns an integer array locating
 2522   // arguments either in registers or in stack slots. Passed an array
 2523   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 2524   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2525   // arguments for a CALLEE. Incoming stack arguments are
 2526   // automatically biased by the preserve_stack_slots field above.
 2527   c_calling_convention %{
 2528     // This is obviously always outgoing.
 2529     // C argument must be in register AND stack slot.
 2530     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 2531   %}
 2532 
 2533   // Location of native (C/C++) and interpreter return values. This
 2534   // is specified to be the same as Java. In the 32-bit VM, long
 2535   // values are actually returned from native calls in O0:O1 and
 2536   // returned to the interpreter in I0:I1. The copying to and from
 2537   // the register pairs is done by the appropriate call and epilog
 2538   // opcodes. This simplifies the register allocator.
 2539   //
 2540   // Use register pair for c return value.
 2541   c_return_value %{
 2542     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot;);
 2543     static int typeToRegLo[Op_RegL+1] = { 0, 0, Z_R2_num, Z_R2_num, Z_R2_num, Z_F0_num, Z_F0_num, Z_R2_num };
 2544     static int typeToRegHi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, Z_R2_H_num, OptoReg::Bad, Z_F0_H_num, Z_R2_H_num };
 2545     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 2546   %}
 2547 
 2548   // Use register pair for return value.
 2549   // Location of compiled Java return values. Same as C
 2550   return_value %{
 2551     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL, &quot;only return normal values&quot;);
 2552     static int typeToRegLo[Op_RegL+1] = { 0, 0, Z_R2_num, Z_R2_num, Z_R2_num, Z_F0_num, Z_F0_num, Z_R2_num };
 2553     static int typeToRegHi[Op_RegL+1] = { 0, 0, OptoReg::Bad, OptoReg::Bad, Z_R2_H_num, OptoReg::Bad, Z_F0_H_num, Z_R2_H_num };
 2554     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 2555   %}
 2556 %}
 2557 
 2558 
 2559 //----------ATTRIBUTES---------------------------------------------------------
 2560 
 2561 //----------Operand Attributes-------------------------------------------------
 2562 op_attrib op_cost(1);          // Required cost attribute
 2563 
 2564 //----------Instruction Attributes---------------------------------------------
 2565 
 2566 // Cost attribute. required.
 2567 ins_attrib ins_cost(DEFAULT_COST);
 2568 
 2569 // Is this instruction a non-matching short branch variant of some
 2570 // long branch? Not required.
 2571 ins_attrib ins_short_branch(0);
 2572 
 2573 // Indicates this is a trap based check node and final control-flow fixup
 2574 // must generate a proper fall through.
 2575 ins_attrib ins_is_TrapBasedCheckNode(true);
 2576 
 2577 // Attribute of instruction to tell how many constants the instruction will generate.
 2578 // (optional attribute). Default: 0.
 2579 ins_attrib ins_num_consts(0);
 2580 
 2581 // Required alignment attribute (must be a power of 2)
 2582 // specifies the alignment that some part of the instruction (not
 2583 // necessarily the start) requires. If &gt; 1, a compute_padding()
 2584 // function must be provided for the instruction.
 2585 //
 2586 // WARNING: Don&#39;t use size(FIXED_SIZE) or size(VARIABLE_SIZE) in
 2587 // instructions which depend on the proper alignment, because the
 2588 // desired alignment isn&#39;t guaranteed for the call to &quot;emit()&quot; during
 2589 // the size computation.
 2590 ins_attrib ins_alignment(1);
 2591 
 2592 // Enforce/prohibit rematerializations.
 2593 // - If an instruction is attributed with &#39;ins_cannot_rematerialize(true)&#39;
 2594 //   then rematerialization of that instruction is prohibited and the
 2595 //   instruction&#39;s value will be spilled if necessary.
 2596 // - If an instruction is attributed with &#39;ins_should_rematerialize(true)&#39;
 2597 //   then rematerialization is enforced and the instruction&#39;s value will
 2598 //   never get spilled. a copy of the instruction will be inserted if
 2599 //   necessary.
 2600 //   Note: this may result in rematerializations in front of every use.
 2601 // (optional attribute)
 2602 ins_attrib ins_cannot_rematerialize(false);
 2603 ins_attrib ins_should_rematerialize(false);
 2604 
 2605 //----------OPERANDS-----------------------------------------------------------
 2606 // Operand definitions must precede instruction definitions for correct
 2607 // parsing in the ADLC because operands constitute user defined types
 2608 // which are used in instruction definitions.
 2609 
 2610 //----------Simple Operands----------------------------------------------------
 2611 // Immediate Operands
 2612 // Please note:
 2613 // Formats are generated automatically for constants and base registers.
 2614 
 2615 //----------------------------------------------
 2616 // SIGNED (shorter than INT) immediate operands
 2617 //----------------------------------------------
 2618 
 2619 // Byte Immediate: constant &#39;int -1&#39;
 2620 operand immB_minus1() %{
 2621   //         sign-ext constant      zero-ext constant
 2622   predicate((n-&gt;get_int() == -1) || ((n-&gt;get_int()&amp;0x000000ff) == 0x000000ff));
 2623   match(ConI);
 2624   op_cost(1);
 2625   format %{ %}
 2626   interface(CONST_INTER);
 2627 %}
 2628 
 2629 // Byte Immediate: constant, but not &#39;int 0&#39; nor &#39;int -1&#39;.
 2630 operand immB_n0m1() %{
 2631   //                             sign-ext constant     zero-ext constant
 2632   predicate(n-&gt;get_int() != 0 &amp;&amp; n-&gt;get_int() != -1 &amp;&amp; (n-&gt;get_int()&amp;0x000000ff) != 0x000000ff);
 2633   match(ConI);
 2634   op_cost(1);
 2635   format %{ %}
 2636   interface(CONST_INTER);
 2637 %}
 2638 
 2639 // Short Immediate: constant &#39;int -1&#39;
 2640 operand immS_minus1() %{
 2641   //         sign-ext constant      zero-ext constant
 2642   predicate((n-&gt;get_int() == -1) || ((n-&gt;get_int()&amp;0x0000ffff) == 0x0000ffff));
 2643   match(ConI);
 2644   op_cost(1);
 2645   format %{ %}
 2646   interface(CONST_INTER);
 2647 %}
 2648 
 2649 // Short Immediate: constant, but not &#39;int 0&#39; nor &#39;int -1&#39;.
 2650 operand immS_n0m1() %{
 2651   //                             sign-ext constant     zero-ext constant
 2652   predicate(n-&gt;get_int() != 0 &amp;&amp; n-&gt;get_int() != -1 &amp;&amp; (n-&gt;get_int()&amp;0x0000ffff) != 0x0000ffff);
 2653   match(ConI);
 2654   op_cost(1);
 2655   format %{ %}
 2656   interface(CONST_INTER);
 2657 %}
 2658 
 2659 //-----------------------------------------
 2660 //  SIGNED INT immediate operands
 2661 //-----------------------------------------
 2662 
 2663 // Integer Immediate: 32-bit
 2664 operand immI() %{
 2665   match(ConI);
 2666   op_cost(1);
 2667   format %{ %}
 2668   interface(CONST_INTER);
 2669 %}
 2670 
 2671 // Int Immediate: 20-bit
 2672 operand immI20() %{
 2673   predicate(Immediate::is_simm20(n-&gt;get_int()));
 2674   match(ConI);
 2675   op_cost(1);
 2676   format %{ %}
 2677   interface(CONST_INTER);
 2678 %}
 2679 
 2680 // Integer Immediate: 16-bit
 2681 operand immI16() %{
 2682   predicate(Immediate::is_simm16(n-&gt;get_int()));
 2683   match(ConI);
 2684   op_cost(1);
 2685   format %{ %}
 2686   interface(CONST_INTER);
 2687 %}
 2688 
 2689 // Integer Immediate: 8-bit
 2690 operand immI8() %{
 2691   predicate(Immediate::is_simm8(n-&gt;get_int()));
 2692   match(ConI);
 2693   op_cost(1);
 2694   format %{ %}
 2695   interface(CONST_INTER);
 2696 %}
 2697 
 2698 // Integer Immediate: constant &#39;int 0&#39;
 2699 operand immI_0() %{
 2700   predicate(n-&gt;get_int() == 0);
 2701   match(ConI);
 2702   op_cost(1);
 2703   format %{ %}
 2704   interface(CONST_INTER);
 2705 %}
 2706 
 2707 // Integer Immediate: constant &#39;int -1&#39;
 2708 operand immI_minus1() %{
 2709   predicate(n-&gt;get_int() == -1);
 2710   match(ConI);
 2711   op_cost(1);
 2712   format %{ %}
 2713   interface(CONST_INTER);
 2714 %}
 2715 
 2716 // Integer Immediate: constant, but not &#39;int 0&#39; nor &#39;int -1&#39;.
 2717 operand immI_n0m1() %{
 2718   predicate(n-&gt;get_int() != 0 &amp;&amp; n-&gt;get_int() != -1);
 2719   match(ConI);
 2720   op_cost(1);
 2721   format %{ %}
 2722   interface(CONST_INTER);
 2723 %}
 2724 
 2725 //-------------------------------------------
 2726 // UNSIGNED INT immediate operands
 2727 //-------------------------------------------
 2728 
 2729 // Unsigned Integer Immediate: 32-bit
 2730 operand uimmI() %{
 2731   match(ConI);
 2732   op_cost(1);
 2733   format %{ %}
 2734   interface(CONST_INTER);
 2735 %}
 2736 
 2737 // Unsigned Integer Immediate: 16-bit
 2738 operand uimmI16() %{
 2739   predicate(Immediate::is_uimm16(n-&gt;get_int()));
 2740   match(ConI);
 2741   op_cost(1);
 2742   format %{ %}
 2743   interface(CONST_INTER);
 2744 %}
 2745 
 2746 // Unsigned Integer Immediate: 12-bit
 2747 operand uimmI12() %{
 2748   predicate(Immediate::is_uimm12(n-&gt;get_int()));
 2749   match(ConI);
 2750   op_cost(1);
 2751   format %{ %}
 2752   interface(CONST_INTER);
 2753 %}
 2754 
 2755 // Unsigned Integer Immediate: 12-bit
 2756 operand uimmI8() %{
 2757   predicate(Immediate::is_uimm8(n-&gt;get_int()));
 2758   match(ConI);
 2759   op_cost(1);
 2760   format %{ %}
 2761   interface(CONST_INTER);
 2762 %}
 2763 
 2764 // Integer Immediate: 6-bit
 2765 operand uimmI6() %{
 2766   predicate(Immediate::is_uimm(n-&gt;get_int(), 6));
 2767   match(ConI);
 2768   op_cost(1);
 2769   format %{ %}
 2770   interface(CONST_INTER);
 2771 %}
 2772 
 2773 // Integer Immediate: 5-bit
 2774 operand uimmI5() %{
 2775   predicate(Immediate::is_uimm(n-&gt;get_int(), 5));
 2776   match(ConI);
 2777   op_cost(1);
 2778   format %{ %}
 2779   interface(CONST_INTER);
 2780 %}
 2781 
 2782 // Length for SS instructions, given in DWs,
 2783 //   possible range [1..512], i.e. [8..4096] Bytes
 2784 //   used     range [1..256], i.e. [8..2048] Bytes
 2785 //   operand type int
 2786 // Unsigned Integer Immediate: 9-bit
 2787 operand SSlenDW() %{
 2788   predicate(Immediate::is_uimm8(n-&gt;get_long()-1));
 2789   match(ConL);
 2790   op_cost(1);
 2791   format %{ %}
 2792   interface(CONST_INTER);
 2793 %}
 2794 
 2795 //------------------------------------------
 2796 // (UN)SIGNED INT specific values
 2797 //------------------------------------------
 2798 
 2799 // Integer Immediate: the value 1
 2800 operand immI_1() %{
 2801   predicate(n-&gt;get_int() == 1);
 2802   match(ConI);
 2803   op_cost(1);
 2804   format %{ %}
 2805   interface(CONST_INTER);
 2806 %}
 2807 
 2808 // Integer Immediate: the value 16.
 2809 operand immI_16() %{
 2810   predicate(n-&gt;get_int() == 16);
 2811   match(ConI);
 2812   op_cost(1);
 2813   format %{ %}
 2814   interface(CONST_INTER);
 2815 %}
 2816 
 2817 // Integer Immediate: the value 24.
 2818 operand immI_24() %{
 2819   predicate(n-&gt;get_int() == 24);
 2820   match(ConI);
 2821   op_cost(1);
 2822   format %{ %}
 2823   interface(CONST_INTER);
 2824 %}
 2825 
 2826 // Integer Immediate: the value 255
 2827 operand immI_255() %{
 2828   predicate(n-&gt;get_int() == 255);
 2829   match(ConI);
 2830   op_cost(1);
 2831   format %{ %}
 2832   interface(CONST_INTER);
 2833 %}
 2834 
 2835 // Integer Immediate: the values 32-63
 2836 operand immI_32_63() %{
 2837   predicate(n-&gt;get_int() &gt;= 32 &amp;&amp; n-&gt;get_int() &lt;= 63);
 2838   match(ConI);
 2839   op_cost(1);
 2840   format %{ %}
 2841   interface(CONST_INTER);
 2842 %}
 2843 
 2844 // Unsigned Integer Immediate: LL-part, extended by 1s.
 2845 operand uimmI_LL1() %{
 2846   predicate((n-&gt;get_int() &amp; 0xFFFF0000) == 0xFFFF0000);
 2847   match(ConI);
 2848   op_cost(1);
 2849   format %{ %}
 2850   interface(CONST_INTER);
 2851 %}
 2852 
 2853 // Unsigned Integer Immediate: LH-part, extended by 1s.
 2854 operand uimmI_LH1() %{
 2855   predicate((n-&gt;get_int() &amp; 0xFFFF) == 0xFFFF);
 2856   match(ConI);
 2857   op_cost(1);
 2858   format %{ %}
 2859   interface(CONST_INTER);
 2860 %}
 2861 
 2862 //------------------------------------------
 2863 // SIGNED LONG immediate operands
 2864 //------------------------------------------
 2865 
 2866 operand immL() %{
 2867   match(ConL);
 2868   op_cost(1);
 2869   format %{ %}
 2870   interface(CONST_INTER);
 2871 %}
 2872 
 2873 // Long Immediate: 32-bit
 2874 operand immL32() %{
 2875   predicate(Immediate::is_simm32(n-&gt;get_long()));
 2876   match(ConL);
 2877   op_cost(1);
 2878   format %{ %}
 2879   interface(CONST_INTER);
 2880 %}
 2881 
 2882 // Long Immediate: 20-bit
 2883 operand immL20() %{
 2884   predicate(Immediate::is_simm20(n-&gt;get_long()));
 2885   match(ConL);
 2886   op_cost(1);
 2887   format %{ %}
 2888   interface(CONST_INTER);
 2889 %}
 2890 
 2891 // Long Immediate: 16-bit
 2892 operand immL16() %{
 2893   predicate(Immediate::is_simm16(n-&gt;get_long()));
 2894   match(ConL);
 2895   op_cost(1);
 2896   format %{ %}
 2897   interface(CONST_INTER);
 2898 %}
 2899 
 2900 // Long Immediate: 8-bit
 2901 operand immL8() %{
 2902   predicate(Immediate::is_simm8(n-&gt;get_long()));
 2903   match(ConL);
 2904   op_cost(1);
 2905   format %{ %}
 2906   interface(CONST_INTER);
 2907 %}
 2908 
 2909 //--------------------------------------------
 2910 // UNSIGNED LONG immediate operands
 2911 //--------------------------------------------
 2912 
 2913 operand uimmL32() %{
 2914   predicate(Immediate::is_uimm32(n-&gt;get_long()));
 2915   match(ConL);
 2916   op_cost(1);
 2917   format %{ %}
 2918   interface(CONST_INTER);
 2919 %}
 2920 
 2921 // Unsigned Long Immediate: 16-bit
 2922 operand uimmL16() %{
 2923   predicate(Immediate::is_uimm16(n-&gt;get_long()));
 2924   match(ConL);
 2925   op_cost(1);
 2926   format %{ %}
 2927   interface(CONST_INTER);
 2928 %}
 2929 
 2930 // Unsigned Long Immediate: 12-bit
 2931 operand uimmL12() %{
 2932   predicate(Immediate::is_uimm12(n-&gt;get_long()));
 2933   match(ConL);
 2934   op_cost(1);
 2935   format %{ %}
 2936   interface(CONST_INTER);
 2937 %}
 2938 
 2939 // Unsigned Long Immediate: 8-bit
 2940 operand uimmL8() %{
 2941   predicate(Immediate::is_uimm8(n-&gt;get_long()));
 2942   match(ConL);
 2943   op_cost(1);
 2944   format %{ %}
 2945   interface(CONST_INTER);
 2946 %}
 2947 
 2948 //-------------------------------------------
 2949 // (UN)SIGNED LONG specific values
 2950 //-------------------------------------------
 2951 
 2952 // Long Immediate: the value FF
 2953 operand immL_FF() %{
 2954   predicate(n-&gt;get_long() == 0xFFL);
 2955   match(ConL);
 2956   op_cost(1);
 2957   format %{ %}
 2958   interface(CONST_INTER);
 2959 %}
 2960 
 2961 // Long Immediate: the value FFFF
 2962 operand immL_FFFF() %{
 2963   predicate(n-&gt;get_long() == 0xFFFFL);
 2964   match(ConL);
 2965   op_cost(1);
 2966   format %{ %}
 2967   interface(CONST_INTER);
 2968 %}
 2969 
 2970 // Long Immediate: the value FFFFFFFF
 2971 operand immL_FFFFFFFF() %{
 2972   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 2973   match(ConL);
 2974   op_cost(1);
 2975   format %{ %}
 2976   interface(CONST_INTER);
 2977 %}
 2978 
 2979 operand immL_0() %{
 2980   predicate(n-&gt;get_long() == 0L);
 2981   match(ConL);
 2982   op_cost(1);
 2983   format %{ %}
 2984   interface(CONST_INTER);
 2985 %}
 2986 
 2987 // Unsigned Long Immediate: LL-part, extended by 1s.
 2988 operand uimmL_LL1() %{
 2989   predicate((n-&gt;get_long() &amp; 0xFFFFFFFFFFFF0000L) == 0xFFFFFFFFFFFF0000L);
 2990   match(ConL);
 2991   op_cost(1);
 2992   format %{ %}
 2993   interface(CONST_INTER);
 2994 %}
 2995 
 2996 // Unsigned Long Immediate: LH-part, extended by 1s.
 2997 operand uimmL_LH1() %{
 2998   predicate((n-&gt;get_long() &amp; 0xFFFFFFFF0000FFFFL) == 0xFFFFFFFF0000FFFFL);
 2999   match(ConL);
 3000   op_cost(1);
 3001   format %{ %}
 3002   interface(CONST_INTER);
 3003 %}
 3004 
 3005 // Unsigned Long Immediate: HL-part, extended by 1s.
 3006 operand uimmL_HL1() %{
 3007   predicate((n-&gt;get_long() &amp; 0xFFFF0000FFFFFFFFL) == 0xFFFF0000FFFFFFFFL);
 3008   match(ConL);
 3009   op_cost(1);
 3010   format %{ %}
 3011   interface(CONST_INTER);
 3012 %}
 3013 
 3014 // Unsigned Long Immediate: HH-part, extended by 1s.
 3015 operand uimmL_HH1() %{
 3016   predicate((n-&gt;get_long() &amp; 0xFFFFFFFFFFFFL) == 0xFFFFFFFFFFFFL);
 3017   match(ConL);
 3018   op_cost(1);
 3019   format %{ %}
 3020   interface(CONST_INTER);
 3021 %}
 3022 
 3023 // Long Immediate: low 32-bit mask
 3024 operand immL_32bits() %{
 3025   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3026   match(ConL);
 3027   op_cost(1);
 3028   format %{ %}
 3029   interface(CONST_INTER);
 3030 %}
 3031 
 3032 //--------------------------------------
 3033 //  POINTER immediate operands
 3034 //--------------------------------------
 3035 
 3036 // Pointer Immediate: 64-bit
 3037 operand immP() %{
 3038   match(ConP);
 3039   op_cost(1);
 3040   format %{ %}
 3041   interface(CONST_INTER);
 3042 %}
 3043 
 3044 // Pointer Immediate: 32-bit
 3045 operand immP32() %{
 3046   predicate(Immediate::is_uimm32(n-&gt;get_ptr()));
 3047   match(ConP);
 3048   op_cost(1);
 3049   format %{ %}
 3050   interface(CONST_INTER);
 3051 %}
 3052 
 3053 // Pointer Immediate: 16-bit
 3054 operand immP16() %{
 3055   predicate(Immediate::is_uimm16(n-&gt;get_ptr()));
 3056   match(ConP);
 3057   op_cost(1);
 3058   format %{ %}
 3059   interface(CONST_INTER);
 3060 %}
 3061 
 3062 // Pointer Immediate: 8-bit
 3063 operand immP8() %{
 3064   predicate(Immediate::is_uimm8(n-&gt;get_ptr()));
 3065   match(ConP);
 3066   op_cost(1);
 3067   format %{ %}
 3068   interface(CONST_INTER);
 3069 %}
 3070 
 3071 //-----------------------------------
 3072 // POINTER specific values
 3073 //-----------------------------------
 3074 
 3075 // Pointer Immediate: NULL
 3076 operand immP0() %{
 3077   predicate(n-&gt;get_ptr() == 0);
 3078   match(ConP);
 3079   op_cost(1);
 3080   format %{ %}
 3081   interface(CONST_INTER);
 3082 %}
 3083 
 3084 //---------------------------------------------
 3085 // NARROW POINTER immediate operands
 3086 //---------------------------------------------
 3087 
 3088 // Narrow Pointer Immediate
 3089 operand immN() %{
 3090   match(ConN);
 3091   op_cost(1);
 3092   format %{ %}
 3093   interface(CONST_INTER);
 3094 %}
 3095 
 3096 operand immNKlass() %{
 3097   match(ConNKlass);
 3098   op_cost(1);
 3099   format %{ %}
 3100   interface(CONST_INTER);
 3101 %}
 3102 
 3103 // Narrow Pointer Immediate
 3104 operand immN8() %{
 3105   predicate(Immediate::is_uimm8(n-&gt;get_narrowcon()));
 3106   match(ConN);
 3107   op_cost(1);
 3108   format %{ %}
 3109   interface(CONST_INTER);
 3110 %}
 3111 
 3112 // Narrow NULL Pointer Immediate
 3113 operand immN0() %{
 3114   predicate(n-&gt;get_narrowcon() == 0);
 3115   match(ConN);
 3116   op_cost(1);
 3117   format %{ %}
 3118   interface(CONST_INTER);
 3119 %}
 3120 
 3121 // FLOAT and DOUBLE immediate operands
 3122 
 3123 // Double Immediate
 3124 operand immD() %{
 3125   match(ConD);
 3126   op_cost(1);
 3127   format %{ %}
 3128   interface(CONST_INTER);
 3129 %}
 3130 
 3131 // Double Immediate: +-0
 3132 operand immDpm0() %{
 3133   predicate(n-&gt;getd() == 0);
 3134   match(ConD);
 3135   op_cost(1);
 3136   format %{ %}
 3137   interface(CONST_INTER);
 3138 %}
 3139 
 3140 // Double Immediate: +0
 3141 operand immDp0() %{
 3142   predicate(jlong_cast(n-&gt;getd()) == 0);
 3143   match(ConD);
 3144   op_cost(1);
 3145   format %{ %}
 3146   interface(CONST_INTER);
 3147 %}
 3148 
 3149 // Float Immediate
 3150 operand immF() %{
 3151   match(ConF);
 3152   op_cost(1);
 3153   format %{ %}
 3154   interface(CONST_INTER);
 3155 %}
 3156 
 3157 // Float Immediate: +-0
 3158 operand immFpm0() %{
 3159   predicate(n-&gt;getf() == 0);
 3160   match(ConF);
 3161   op_cost(1);
 3162   format %{ %}
 3163   interface(CONST_INTER);
 3164 %}
 3165 
 3166 // Float Immediate: +0
 3167 operand immFp0() %{
 3168   predicate(jint_cast(n-&gt;getf()) == 0);
 3169   match(ConF);
 3170   op_cost(1);
 3171   format %{ %}
 3172   interface(CONST_INTER);
 3173 %}
 3174 
 3175 // End of Immediate Operands
 3176 
 3177 // Integer Register Operands
 3178 // Integer Register
 3179 operand iRegI() %{
 3180   constraint(ALLOC_IN_RC(z_int_reg));
 3181   match(RegI);
 3182   match(noArg_iRegI);
 3183   match(rarg1RegI);
 3184   match(rarg2RegI);
 3185   match(rarg3RegI);
 3186   match(rarg4RegI);
 3187   match(rarg5RegI);
 3188   match(noOdd_iRegI);
 3189   match(revenRegI);
 3190   match(roddRegI);
 3191   format %{ %}
 3192   interface(REG_INTER);
 3193 %}
 3194 
 3195 operand noArg_iRegI() %{
 3196   constraint(ALLOC_IN_RC(z_no_arg_int_reg));
 3197   match(RegI);
 3198   format %{ %}
 3199   interface(REG_INTER);
 3200 %}
 3201 
 3202 // revenRegI and roddRegI constitute and even-odd-pair.
 3203 operand revenRegI() %{
 3204   constraint(ALLOC_IN_RC(z_rarg3_int_reg));
 3205   match(iRegI);
 3206   format %{ %}
 3207   interface(REG_INTER);
 3208 %}
 3209 
 3210 // revenRegI and roddRegI constitute and even-odd-pair.
 3211 operand roddRegI() %{
 3212   constraint(ALLOC_IN_RC(z_rarg4_int_reg));
 3213   match(iRegI);
 3214   format %{ %}
 3215   interface(REG_INTER);
 3216 %}
 3217 
 3218 operand rarg1RegI() %{
 3219   constraint(ALLOC_IN_RC(z_rarg1_int_reg));
 3220   match(iRegI);
 3221   format %{ %}
 3222   interface(REG_INTER);
 3223 %}
 3224 
 3225 operand rarg2RegI() %{
 3226   constraint(ALLOC_IN_RC(z_rarg2_int_reg));
 3227   match(iRegI);
 3228   format %{ %}
 3229   interface(REG_INTER);
 3230 %}
 3231 
 3232 operand rarg3RegI() %{
 3233   constraint(ALLOC_IN_RC(z_rarg3_int_reg));
 3234   match(iRegI);
 3235   format %{ %}
 3236   interface(REG_INTER);
 3237 %}
 3238 
 3239 operand rarg4RegI() %{
 3240   constraint(ALLOC_IN_RC(z_rarg4_int_reg));
 3241   match(iRegI);
 3242   format %{ %}
 3243   interface(REG_INTER);
 3244 %}
 3245 
 3246 operand rarg5RegI() %{
 3247   constraint(ALLOC_IN_RC(z_rarg5_int_reg));
 3248   match(iRegI);
 3249   format %{ %}
 3250   interface(REG_INTER);
 3251 %}
 3252 
 3253 operand noOdd_iRegI() %{
 3254   constraint(ALLOC_IN_RC(z_no_odd_int_reg));
 3255   match(RegI);
 3256   match(revenRegI);
 3257   format %{ %}
 3258   interface(REG_INTER);
 3259 %}
 3260 
 3261 // Pointer Register
 3262 operand iRegP() %{
 3263   constraint(ALLOC_IN_RC(z_ptr_reg));
 3264   match(RegP);
 3265   match(noArg_iRegP);
 3266   match(rarg1RegP);
 3267   match(rarg2RegP);
 3268   match(rarg3RegP);
 3269   match(rarg4RegP);
 3270   match(rarg5RegP);
 3271   match(revenRegP);
 3272   match(roddRegP);
 3273   format %{ %}
 3274   interface(REG_INTER);
 3275 %}
 3276 
 3277 // thread operand
 3278 operand threadRegP() %{
 3279   constraint(ALLOC_IN_RC(z_thread_ptr_reg));
 3280   match(RegP);
 3281   format %{ &quot;Z_THREAD&quot; %}
 3282   interface(REG_INTER);
 3283 %}
 3284 
 3285 operand noArg_iRegP() %{
 3286   constraint(ALLOC_IN_RC(z_no_arg_ptr_reg));
 3287   match(iRegP);
 3288   format %{ %}
 3289   interface(REG_INTER);
 3290 %}
 3291 
 3292 operand rarg1RegP() %{
 3293   constraint(ALLOC_IN_RC(z_rarg1_ptr_reg));
 3294   match(iRegP);
 3295   format %{ %}
 3296   interface(REG_INTER);
 3297 %}
 3298 
 3299 operand rarg2RegP() %{
 3300   constraint(ALLOC_IN_RC(z_rarg2_ptr_reg));
 3301   match(iRegP);
 3302   format %{ %}
 3303   interface(REG_INTER);
 3304 %}
 3305 
 3306 operand rarg3RegP() %{
 3307   constraint(ALLOC_IN_RC(z_rarg3_ptr_reg));
 3308   match(iRegP);
 3309   format %{ %}
 3310   interface(REG_INTER);
 3311 %}
 3312 
 3313 operand rarg4RegP() %{
 3314   constraint(ALLOC_IN_RC(z_rarg4_ptr_reg));
 3315   match(iRegP);
 3316   format %{ %}
 3317   interface(REG_INTER);
 3318 %}
 3319 
 3320 operand rarg5RegP() %{
 3321   constraint(ALLOC_IN_RC(z_rarg5_ptr_reg));
 3322   match(iRegP);
 3323   format %{ %}
 3324   interface(REG_INTER);
 3325 %}
 3326 
 3327 operand memoryRegP() %{
 3328   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3329   match(RegP);
 3330   match(iRegP);
 3331   match(threadRegP);
 3332   format %{ %}
 3333   interface(REG_INTER);
 3334 %}
 3335 
 3336 // revenRegP and roddRegP constitute and even-odd-pair.
 3337 operand revenRegP() %{
 3338   constraint(ALLOC_IN_RC(z_rarg3_ptr_reg));
 3339   match(iRegP);
 3340   format %{ %}
 3341   interface(REG_INTER);
 3342 %}
 3343 
 3344 // revenRegP and roddRegP constitute and even-odd-pair.
 3345 operand roddRegP() %{
 3346   constraint(ALLOC_IN_RC(z_rarg4_ptr_reg));
 3347   match(iRegP);
 3348   format %{ %}
 3349   interface(REG_INTER);
 3350 %}
 3351 
 3352 operand lock_ptr_RegP() %{
 3353   constraint(ALLOC_IN_RC(z_lock_ptr_reg));
 3354   match(RegP);
 3355   format %{ %}
 3356   interface(REG_INTER);
 3357 %}
 3358 
 3359 operand rscratch2RegP() %{
 3360   constraint(ALLOC_IN_RC(z_rscratch2_bits64_reg));
 3361   match(RegP);
 3362   format %{ %}
 3363   interface(REG_INTER);
 3364 %}
 3365 
 3366 operand iRegN() %{
 3367   constraint(ALLOC_IN_RC(z_int_reg));
 3368   match(RegN);
 3369   match(noArg_iRegN);
 3370   match(rarg1RegN);
 3371   match(rarg2RegN);
 3372   match(rarg3RegN);
 3373   match(rarg4RegN);
 3374   match(rarg5RegN);
 3375   format %{ %}
 3376   interface(REG_INTER);
 3377 %}
 3378 
 3379 operand noArg_iRegN() %{
 3380   constraint(ALLOC_IN_RC(z_no_arg_int_reg));
 3381   match(iRegN);
 3382   format %{ %}
 3383   interface(REG_INTER);
 3384 %}
 3385 
 3386 operand rarg1RegN() %{
 3387   constraint(ALLOC_IN_RC(z_rarg1_int_reg));
 3388   match(iRegN);
 3389   format %{ %}
 3390   interface(REG_INTER);
 3391 %}
 3392 
 3393 operand rarg2RegN() %{
 3394   constraint(ALLOC_IN_RC(z_rarg2_int_reg));
 3395   match(iRegN);
 3396   format %{ %}
 3397   interface(REG_INTER);
 3398 %}
 3399 
 3400 operand rarg3RegN() %{
 3401   constraint(ALLOC_IN_RC(z_rarg3_int_reg));
 3402   match(iRegN);
 3403   format %{ %}
 3404   interface(REG_INTER);
 3405 %}
 3406 
 3407 operand rarg4RegN() %{
 3408   constraint(ALLOC_IN_RC(z_rarg4_int_reg));
 3409   match(iRegN);
 3410   format %{ %}
 3411   interface(REG_INTER);
 3412 %}
 3413 
 3414 operand rarg5RegN() %{
 3415   constraint(ALLOC_IN_RC(z_rarg5_ptrN_reg));
 3416   match(iRegN);
 3417   format %{ %}
 3418   interface(REG_INTER);
 3419 %}
 3420 
 3421 // Long Register
 3422 operand iRegL() %{
 3423   constraint(ALLOC_IN_RC(z_long_reg));
 3424   match(RegL);
 3425   match(revenRegL);
 3426   match(roddRegL);
 3427   match(allRoddRegL);
 3428   match(rarg1RegL);
 3429   match(rarg5RegL);
 3430   format %{ %}
 3431   interface(REG_INTER);
 3432 %}
 3433 
 3434 // revenRegL and roddRegL constitute and even-odd-pair.
 3435 operand revenRegL() %{
 3436   constraint(ALLOC_IN_RC(z_rarg3_long_reg));
 3437   match(iRegL);
 3438   format %{ %}
 3439   interface(REG_INTER);
 3440 %}
 3441 
 3442 // revenRegL and roddRegL constitute and even-odd-pair.
 3443 operand roddRegL() %{
 3444   constraint(ALLOC_IN_RC(z_rarg4_long_reg));
 3445   match(iRegL);
 3446   format %{ %}
 3447   interface(REG_INTER);
 3448 %}
 3449 
 3450 // available odd registers for iRegL
 3451 operand allRoddRegL() %{
 3452   constraint(ALLOC_IN_RC(z_long_odd_reg));
 3453   match(iRegL);
 3454   format %{ %}
 3455   interface(REG_INTER);
 3456 %}
 3457 
 3458 operand rarg1RegL() %{
 3459   constraint(ALLOC_IN_RC(z_rarg1_long_reg));
 3460   match(iRegL);
 3461   format %{ %}
 3462   interface(REG_INTER);
 3463 %}
 3464 
 3465 operand rarg5RegL() %{
 3466   constraint(ALLOC_IN_RC(z_rarg5_long_reg));
 3467   match(iRegL);
 3468   format %{ %}
 3469   interface(REG_INTER);
 3470 %}
 3471 
 3472 // Condition Code Flag Registers
 3473 operand flagsReg() %{
 3474   constraint(ALLOC_IN_RC(z_condition_reg));
 3475   match(RegFlags);
 3476   format %{ &quot;CR&quot; %}
 3477   interface(REG_INTER);
 3478 %}
 3479 
 3480 // Condition Code Flag Registers for rules with result tuples
 3481 operand TD_flagsReg() %{
 3482   constraint(ALLOC_IN_RC(z_condition_reg));
 3483   match(RegFlags);
 3484   format %{ &quot;CR&quot; %}
 3485   interface(REG_TUPLE_DEST_INTER);
 3486 %}
 3487 
 3488 operand regD() %{
 3489   constraint(ALLOC_IN_RC(z_dbl_reg));
 3490   match(RegD);
 3491   format %{ %}
 3492   interface(REG_INTER);
 3493 %}
 3494 
 3495 operand rscratchRegD() %{
 3496   constraint(ALLOC_IN_RC(z_rscratch1_dbl_reg));
 3497   match(RegD);
 3498   format %{ %}
 3499   interface(REG_INTER);
 3500 %}
 3501 
 3502 operand regF() %{
 3503   constraint(ALLOC_IN_RC(z_flt_reg));
 3504   match(RegF);
 3505   format %{ %}
 3506   interface(REG_INTER);
 3507 %}
 3508 
 3509 operand rscratchRegF() %{
 3510   constraint(ALLOC_IN_RC(z_rscratch1_flt_reg));
 3511   match(RegF);
 3512   format %{ %}
 3513   interface(REG_INTER);
 3514 %}
 3515 
 3516 // Special Registers
 3517 
 3518 // Method Register
 3519 operand inline_cache_regP(iRegP reg) %{
 3520   constraint(ALLOC_IN_RC(z_r9_regP)); // inline_cache_reg
 3521   match(reg);
 3522   format %{ %}
 3523   interface(REG_INTER);
 3524 %}
 3525 
 3526 operand compiler_method_oop_regP(iRegP reg) %{
 3527   constraint(ALLOC_IN_RC(z_r1_RegP)); // compiler_method_oop_reg
 3528   match(reg);
 3529   format %{ %}
 3530   interface(REG_INTER);
 3531 %}
 3532 
 3533 operand interpreter_method_oop_regP(iRegP reg) %{
 3534   constraint(ALLOC_IN_RC(z_r9_regP)); // interpreter_method_oop_reg
 3535   match(reg);
 3536   format %{ %}
 3537   interface(REG_INTER);
 3538 %}
 3539 
 3540 // Operands to remove register moves in unscaled mode.
 3541 // Match read/write registers with an EncodeP node if neither shift nor add are required.
 3542 operand iRegP2N(iRegP reg) %{
 3543   predicate(CompressedOops::shift() == 0 &amp;&amp; _leaf-&gt;as_EncodeP()-&gt;in(0) == NULL);
 3544   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3545   match(EncodeP reg);
 3546   format %{ &quot;$reg&quot; %}
 3547   interface(REG_INTER)
 3548 %}
 3549 
 3550 operand iRegN2P(iRegN reg) %{
 3551   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0 &amp;&amp;
 3552             _leaf-&gt;as_DecodeN()-&gt;in(0) == NULL);
 3553   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3554   match(DecodeN reg);
 3555   format %{ &quot;$reg&quot; %}
 3556   interface(REG_INTER)
 3557 %}
 3558 
 3559 
 3560 //----------Complex Operands---------------------------------------------------
 3561 
 3562 // Indirect Memory Reference
 3563 operand indirect(memoryRegP base) %{
 3564   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3565   match(base);
 3566   op_cost(1);
 3567   format %{ &quot;#0[,$base]&quot; %}
 3568   interface(MEMORY_INTER) %{
 3569     base($base);
 3570     index(0xffffFFFF); // noreg
 3571     scale(0x0);
 3572     disp(0x0);
 3573   %}
 3574 %}
 3575 
 3576 // Indirect with Offset (long)
 3577 operand indOffset20(memoryRegP base, immL20 offset) %{
 3578   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3579   match(AddP base offset);
 3580   op_cost(1);
 3581   format %{ &quot;$offset[,$base]&quot; %}
 3582   interface(MEMORY_INTER) %{
 3583     base($base);
 3584     index(0xffffFFFF); // noreg
 3585     scale(0x0);
 3586     disp($offset);
 3587   %}
 3588 %}
 3589 
 3590 operand indOffset20Narrow(iRegN base, immL20 offset) %{
 3591   predicate(Matcher::narrow_oop_use_complex_address());
 3592   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3593   match(AddP (DecodeN base) offset);
 3594   op_cost(1);
 3595   format %{ &quot;$offset[,$base]&quot; %}
 3596   interface(MEMORY_INTER) %{
 3597     base($base);
 3598     index(0xffffFFFF); // noreg
 3599     scale(0x0);
 3600     disp($offset);
 3601   %}
 3602 %}
 3603 
 3604 // Indirect with Offset (short)
 3605 operand indOffset12(memoryRegP base, uimmL12 offset) %{
 3606   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3607   match(AddP base offset);
 3608   op_cost(1);
 3609   format %{ &quot;$offset[[,$base]]&quot; %}
 3610   interface(MEMORY_INTER) %{
 3611     base($base);
 3612     index(0xffffFFFF); // noreg
 3613     scale(0x0);
 3614     disp($offset);
 3615   %}
 3616 %}
 3617 
 3618 operand indOffset12Narrow(iRegN base, uimmL12 offset) %{
 3619   predicate(Matcher::narrow_oop_use_complex_address());
 3620   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3621   match(AddP (DecodeN base) offset);
 3622   op_cost(1);
 3623   format %{ &quot;$offset[[,$base]]&quot; %}
 3624   interface(MEMORY_INTER) %{
 3625     base($base);
 3626     index(0xffffFFFF); // noreg
 3627     scale(0x0);
 3628     disp($offset);
 3629   %}
 3630 %}
 3631 
 3632 // Indirect with Register Index
 3633 operand indIndex(memoryRegP base, iRegL index) %{
 3634   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3635   match(AddP base index);
 3636   op_cost(1);
 3637   format %{ &quot;#0[($index,$base)]&quot; %}
 3638   interface(MEMORY_INTER) %{
 3639     base($base);
 3640     index($index);
 3641     scale(0x0);
 3642     disp(0x0);
 3643   %}
 3644 %}
 3645 
 3646 // Indirect with Offset (long) and index
 3647 operand indOffset20index(memoryRegP base, immL20 offset, iRegL index) %{
 3648   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3649   match(AddP (AddP base index) offset);
 3650   op_cost(1);
 3651   format %{ &quot;$offset[($index,$base)]&quot; %}
 3652   interface(MEMORY_INTER) %{
 3653     base($base);
 3654     index($index);
 3655     scale(0x0);
 3656     disp($offset);
 3657   %}
 3658 %}
 3659 
 3660 operand indOffset20indexNarrow(iRegN base, immL20 offset, iRegL index) %{
 3661   predicate(Matcher::narrow_oop_use_complex_address());
 3662   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3663   match(AddP (AddP (DecodeN base) index) offset);
 3664   op_cost(1);
 3665   format %{ &quot;$offset[($index,$base)]&quot; %}
 3666   interface(MEMORY_INTER) %{
 3667     base($base);
 3668     index($index);
 3669     scale(0x0);
 3670     disp($offset);
 3671   %}
 3672 %}
 3673 
 3674 // Indirect with Offset (short) and index
 3675 operand indOffset12index(memoryRegP base, uimmL12 offset, iRegL index) %{
 3676   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3677   match(AddP (AddP base index) offset);
 3678   op_cost(1);
 3679   format %{ &quot;$offset[[($index,$base)]]&quot; %}
 3680   interface(MEMORY_INTER) %{
 3681     base($base);
 3682     index($index);
 3683     scale(0x0);
 3684     disp($offset);
 3685   %}
 3686 %}
 3687 
 3688 operand indOffset12indexNarrow(iRegN base, uimmL12 offset, iRegL index) %{
 3689   predicate(Matcher::narrow_oop_use_complex_address());
 3690   constraint(ALLOC_IN_RC(z_memory_ptr_reg));
 3691   match(AddP (AddP (DecodeN base) index) offset);
 3692   op_cost(1);
 3693   format %{ &quot;$offset[[($index,$base)]]&quot; %}
 3694   interface(MEMORY_INTER) %{
 3695     base($base);
 3696     index($index);
 3697     scale(0x0);
 3698     disp($offset);
 3699   %}
 3700 %}
 3701 
 3702 //----------Special Memory Operands--------------------------------------------
 3703 
 3704 // Stack Slot Operand
 3705 // This operand is used for loading and storing temporary values on
 3706 // the stack where a match requires a value to flow through memory.
 3707 operand stackSlotI(sRegI reg) %{
 3708   constraint(ALLOC_IN_RC(stack_slots));
 3709   op_cost(1);
 3710   format %{ &quot;[$reg(stackSlotI)]&quot; %}
 3711   interface(MEMORY_INTER) %{
 3712     base(0xf);   // Z_SP
 3713     index(0xffffFFFF); // noreg
 3714     scale(0x0);
 3715     disp($reg);  // stack offset
 3716   %}
 3717 %}
 3718 
 3719 operand stackSlotP(sRegP reg) %{
 3720   constraint(ALLOC_IN_RC(stack_slots));
 3721   op_cost(1);
 3722   format %{ &quot;[$reg(stackSlotP)]&quot; %}
 3723   interface(MEMORY_INTER) %{
 3724     base(0xf);   // Z_SP
 3725     index(0xffffFFFF); // noreg
 3726     scale(0x0);
 3727     disp($reg);  // Stack Offset
 3728   %}
 3729 %}
 3730 
 3731 operand stackSlotF(sRegF reg) %{
 3732   constraint(ALLOC_IN_RC(stack_slots));
 3733   op_cost(1);
 3734   format %{ &quot;[$reg(stackSlotF)]&quot; %}
 3735   interface(MEMORY_INTER) %{
 3736     base(0xf);   // Z_SP
 3737     index(0xffffFFFF); // noreg
 3738     scale(0x0);
 3739     disp($reg);  // Stack Offset
 3740   %}
 3741 %}
 3742 
 3743 operand stackSlotD(sRegD reg) %{
 3744   constraint(ALLOC_IN_RC(stack_slots));
 3745   op_cost(1);
 3746   //match(RegD);
 3747   format %{ &quot;[$reg(stackSlotD)]&quot; %}
 3748   interface(MEMORY_INTER) %{
 3749     base(0xf);   // Z_SP
 3750     index(0xffffFFFF); // noreg
 3751     scale(0x0);
 3752     disp($reg);  // Stack Offset
 3753   %}
 3754 %}
 3755 
 3756 operand stackSlotL(sRegL reg) %{
 3757   constraint(ALLOC_IN_RC(stack_slots));
 3758   op_cost(1);  //match(RegL);
 3759   format %{ &quot;[$reg(stackSlotL)]&quot; %}
 3760   interface(MEMORY_INTER) %{
 3761     base(0xf);   // Z_SP
 3762     index(0xffffFFFF); // noreg
 3763     scale(0x0);
 3764     disp($reg);  // Stack Offset
 3765   %}
 3766 %}
 3767 
 3768 // Operands for expressing Control Flow
 3769 // NOTE: Label is a predefined operand which should not be redefined in
 3770 // the AD file. It is generically handled within the ADLC.
 3771 
 3772 //----------Conditional Branch Operands----------------------------------------
 3773 // Comparison Op  - This is the operation of the comparison, and is limited to
 3774 //                  the following set of codes:
 3775 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 3776 //
 3777 // Other attributes of the comparison, such as unsignedness, are specified
 3778 // by the comparison instruction that sets a condition code flags register.
 3779 // That result is represented by a flags operand whose subtype is appropriate
 3780 // to the unsignedness (etc.) of the comparison.
 3781 //
 3782 // Later, the instruction which matches both the Comparison Op (a Bool) and
 3783 // the flags (produced by the Cmp) specifies the coding of the comparison op
 3784 // by matching a specific subtype of Bool operand below.
 3785 
 3786 // INT cmpOps for CompareAndBranch and CompareAndTrap instructions should not
 3787 // have mask bit #3 set.
 3788 operand cmpOpT() %{
 3789   match(Bool);
 3790   format %{ &quot;&quot; %}
 3791   interface(COND_INTER) %{
 3792     equal(0x8);         // Assembler::bcondEqual
 3793     not_equal(0x6);     // Assembler::bcondNotEqual
 3794     less(0x4);          // Assembler::bcondLow
 3795     greater_equal(0xa); // Assembler::bcondNotLow
 3796     less_equal(0xc);    // Assembler::bcondNotHigh
 3797     greater(0x2);       // Assembler::bcondHigh
 3798     overflow(0x1);      // Assembler::bcondOverflow
 3799     no_overflow(0xe);   // Assembler::bcondNotOverflow
 3800   %}
 3801 %}
 3802 
 3803 // When used for floating point comparisons: unordered is treated as less.
 3804 operand cmpOpF() %{
 3805   match(Bool);
 3806   format %{ &quot;&quot; %}
 3807   interface(COND_INTER) %{
 3808     equal(0x8);
 3809     not_equal(0x7);     // Includes &#39;unordered&#39;.
 3810     less(0x5);          // Includes &#39;unordered&#39;.
 3811     greater_equal(0xa);
 3812     less_equal(0xd);    // Includes &#39;unordered&#39;.
 3813     greater(0x2);
 3814     overflow(0x0);      // Not meaningful on z/Architecture.
 3815     no_overflow(0x0);   // leave unchanged (zero) therefore
 3816   %}
 3817 %}
 3818 
 3819 // &quot;Regular&quot; cmpOp for int comparisons, includes bit #3 (overflow).
 3820 operand cmpOp() %{
 3821   match(Bool);
 3822   format %{ &quot;&quot; %}
 3823   interface(COND_INTER) %{
 3824     equal(0x8);
 3825     not_equal(0x7);     // Includes &#39;unordered&#39;.
 3826     less(0x5);          // Includes &#39;unordered&#39;.
 3827     greater_equal(0xa);
 3828     less_equal(0xd);    // Includes &#39;unordered&#39;.
 3829     greater(0x2);
 3830     overflow(0x1);      // Assembler::bcondOverflow
 3831     no_overflow(0xe);   // Assembler::bcondNotOverflow
 3832   %}
 3833 %}
 3834 
 3835 //----------OPERAND CLASSES----------------------------------------------------
 3836 // Operand Classes are groups of operands that are used to simplify
 3837 // instruction definitions by not requiring the AD writer to specify
 3838 // seperate instructions for every form of operand when the
 3839 // instruction accepts multiple operand types with the same basic
 3840 // encoding and format.  The classic case of this is memory operands.
 3841 // Indirect is not included since its use is limited to Compare &amp; Swap
 3842 
 3843 // Most general memory operand, allows base, index, and long displacement.
 3844 opclass memory(indirect, indIndex, indOffset20, indOffset20Narrow, indOffset20index, indOffset20indexNarrow);
 3845 opclass memoryRXY(indirect, indIndex, indOffset20, indOffset20Narrow, indOffset20index, indOffset20indexNarrow);
 3846 
 3847 // General memory operand, allows base, index, and short displacement.
 3848 opclass memoryRX(indirect, indIndex, indOffset12, indOffset12Narrow, indOffset12index, indOffset12indexNarrow);
 3849 
 3850 // Memory operand, allows only base and long displacement.
 3851 opclass memoryRSY(indirect, indOffset20, indOffset20Narrow);
 3852 
 3853 // Memory operand, allows only base and short displacement.
 3854 opclass memoryRS(indirect, indOffset12, indOffset12Narrow);
 3855 
 3856 // Operand classes to match encode and decode.
 3857 opclass iRegN_P2N(iRegN);
 3858 opclass iRegP_N2P(iRegP);
 3859 
 3860 
 3861 //----------PIPELINE-----------------------------------------------------------
 3862 pipeline %{
 3863 
 3864 //----------ATTRIBUTES---------------------------------------------------------
 3865 attributes %{
 3866   // z/Architecture instructions are of length 2, 4, or 6 bytes.
 3867   variable_size_instructions;
 3868   instruction_unit_size = 2;
 3869 
 3870   // Meaningless on z/Architecture.
 3871   max_instructions_per_bundle = 1;
 3872 
 3873   // The z/Architecture processor fetches 64 bytes...
 3874   instruction_fetch_unit_size = 64;
 3875 
 3876   // ...in one line.
 3877   instruction_fetch_units = 1
 3878 %}
 3879 
 3880 //----------RESOURCES----------------------------------------------------------
 3881 // Resources are the functional units available to the machine.
 3882 resources(
 3883    Z_BR,     // branch unit
 3884    Z_CR,     // condition unit
 3885    Z_FX1,    // integer arithmetic unit 1
 3886    Z_FX2,    // integer arithmetic unit 2
 3887    Z_LDST1,  // load/store unit 1
 3888    Z_LDST2,  // load/store unit 2
 3889    Z_FP1,    // float arithmetic unit 1
 3890    Z_FP2,    // float arithmetic unit 2
 3891    Z_LDST = Z_LDST1 | Z_LDST2,
 3892    Z_FX   = Z_FX1 | Z_FX2,
 3893    Z_FP   = Z_FP1 | Z_FP2
 3894   );
 3895 
 3896 //----------PIPELINE DESCRIPTION-----------------------------------------------
 3897 // Pipeline Description specifies the stages in the machine&#39;s pipeline.
 3898 pipe_desc(
 3899    // TODO: adapt
 3900    Z_IF,  // instruction fetch
 3901    Z_IC,
 3902    Z_D0,  // decode
 3903    Z_D1,  // decode
 3904    Z_D2,  // decode
 3905    Z_D3,  // decode
 3906    Z_Xfer1,
 3907    Z_GD,  // group definition
 3908    Z_MP,  // map
 3909    Z_ISS, // issue
 3910    Z_RF,  // resource fetch
 3911    Z_EX1, // execute (all units)
 3912    Z_EX2, // execute (FP, LDST)
 3913    Z_EX3, // execute (FP, LDST)
 3914    Z_EX4, // execute (FP)
 3915    Z_EX5, // execute (FP)
 3916    Z_EX6, // execute (FP)
 3917    Z_WB,  // write back
 3918    Z_Xfer2,
 3919    Z_CP
 3920   );
 3921 
 3922 //----------PIPELINE CLASSES---------------------------------------------------
 3923 // Pipeline Classes describe the stages in which input and output are
 3924 // referenced by the hardware pipeline.
 3925 
 3926 // Providing the `ins_pipe&#39; declarations in the instruction
 3927 // specifications seems to be of little use. So we use
 3928 // `pipe_class_dummy&#39; for all our instructions at present.
 3929 pipe_class pipe_class_dummy() %{
 3930   single_instruction;
 3931   fixed_latency(4);
 3932 %}
 3933 
 3934 // SIGTRAP based implicit range checks in compiled code.
 3935 // Currently, no pipe classes are used on z/Architecture.
 3936 pipe_class pipe_class_trap() %{
 3937   single_instruction;
 3938 %}
 3939 
 3940 pipe_class pipe_class_fx_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 3941   single_instruction;
 3942   dst  : Z_EX1(write);
 3943   src1 : Z_RF(read);
 3944   src2 : Z_RF(read);
 3945   Z_FX : Z_RF;
 3946 %}
 3947 
 3948 pipe_class pipe_class_ldst(iRegP dst, memory mem) %{
 3949   single_instruction;
 3950   mem : Z_RF(read);
 3951   dst : Z_WB(write);
 3952   Z_LDST : Z_RF;
 3953 %}
 3954 
 3955 define %{
 3956   MachNop = pipe_class_dummy;
 3957 %}
 3958 
 3959 %}
 3960 
 3961 //----------INSTRUCTIONS-------------------------------------------------------
 3962 
 3963 //---------- Chain stack slots between similar types --------
 3964 
 3965 // Load integer from stack slot.
 3966 instruct stkI_to_regI(iRegI dst, stackSlotI src) %{
 3967   match(Set dst src);
 3968   ins_cost(MEMORY_REF_COST);
 3969   // TODO: s390 port size(FIXED_SIZE);
 3970   format %{ &quot;L       $dst,$src\t # stk reload int&quot; %}
 3971   opcode(L_ZOPC);
 3972   ins_encode(z_form_rt_mem(dst, src));
 3973   ins_pipe(pipe_class_dummy);
 3974 %}
 3975 
 3976 // Store integer to stack slot.
 3977 instruct regI_to_stkI(stackSlotI dst, iRegI src) %{
 3978   match(Set dst src);
 3979   ins_cost(MEMORY_REF_COST);
 3980   // TODO: s390 port size(FIXED_SIZE);
 3981   format %{ &quot;ST      $src,$dst\t # stk spill int&quot; %}
 3982   opcode(ST_ZOPC);
 3983   ins_encode(z_form_rt_mem(src, dst)); // rs=rt
 3984   ins_pipe(pipe_class_dummy);
 3985 %}
 3986 
 3987 // Load long from stack slot.
 3988 instruct stkL_to_regL(iRegL dst, stackSlotL src) %{
 3989   match(Set dst src);
 3990   ins_cost(MEMORY_REF_COST);
 3991   // TODO: s390 port size(FIXED_SIZE);
 3992   format %{ &quot;LG      $dst,$src\t # stk reload long&quot; %}
 3993   opcode(LG_ZOPC);
 3994   ins_encode(z_form_rt_mem(dst, src));
 3995   ins_pipe(pipe_class_dummy);
 3996 %}
 3997 
 3998 // Store long to stack slot.
 3999 instruct regL_to_stkL(stackSlotL dst, iRegL src) %{
 4000   match(Set dst src);
 4001   ins_cost(MEMORY_REF_COST);
 4002   size(6);
 4003   format %{ &quot;STG     $src,$dst\t # stk spill long&quot; %}
 4004   opcode(STG_ZOPC);
 4005   ins_encode(z_form_rt_mem(src, dst)); // rs=rt
 4006   ins_pipe(pipe_class_dummy);
 4007 %}
 4008 
 4009 // Load pointer from stack slot, 64-bit encoding.
 4010 instruct stkP_to_regP(iRegP dst, stackSlotP src) %{
 4011   match(Set dst src);
 4012   ins_cost(MEMORY_REF_COST);
 4013   // TODO: s390 port size(FIXED_SIZE);
 4014   format %{ &quot;LG      $dst,$src\t # stk reload ptr&quot; %}
 4015   opcode(LG_ZOPC);
 4016   ins_encode(z_form_rt_mem(dst, src));
 4017   ins_pipe(pipe_class_dummy);
 4018 %}
 4019 
 4020 // Store pointer to stack slot.
 4021 instruct regP_to_stkP(stackSlotP dst, iRegP src) %{
 4022   match(Set dst src);
 4023   ins_cost(MEMORY_REF_COST);
 4024   // TODO: s390 port size(FIXED_SIZE);
 4025   format %{ &quot;STG     $src,$dst\t # stk spill ptr&quot; %}
 4026   opcode(STG_ZOPC);
 4027   ins_encode(z_form_rt_mem(src, dst)); // rs=rt
 4028   ins_pipe(pipe_class_dummy);
 4029 %}
 4030 
 4031 //  Float types
 4032 
 4033 // Load float value from stack slot.
 4034 instruct stkF_to_regF(regF dst, stackSlotF src) %{
 4035   match(Set dst src);
 4036   ins_cost(MEMORY_REF_COST);
 4037   size(4);
 4038   format %{ &quot;LE(Y)   $dst,$src\t # stk reload float&quot; %}
 4039   opcode(LE_ZOPC);
 4040   ins_encode(z_form_rt_mem(dst, src));
 4041   ins_pipe(pipe_class_dummy);
 4042 %}
 4043 
 4044 // Store float value to stack slot.
 4045 instruct regF_to_stkF(stackSlotF dst, regF src) %{
 4046   match(Set dst src);
 4047   ins_cost(MEMORY_REF_COST);
 4048   size(4);
 4049   format %{ &quot;STE(Y)  $src,$dst\t # stk spill float&quot; %}
 4050   opcode(STE_ZOPC);
 4051   ins_encode(z_form_rt_mem(src, dst));
 4052   ins_pipe(pipe_class_dummy);
 4053 %}
 4054 
 4055 // Load double value from stack slot.
 4056 instruct stkD_to_regD(regD dst, stackSlotD src) %{
 4057   match(Set dst src);
 4058   ins_cost(MEMORY_REF_COST);
 4059   // TODO: s390 port size(FIXED_SIZE);
 4060   format %{ &quot;LD(Y)   $dst,$src\t # stk reload double&quot; %}
 4061   opcode(LD_ZOPC);
 4062   ins_encode(z_form_rt_mem(dst, src));
 4063   ins_pipe(pipe_class_dummy);
 4064 %}
 4065 
 4066 // Store double value to stack slot.
 4067 instruct regD_to_stkD(stackSlotD dst, regD src) %{
 4068   match(Set dst src);
 4069   ins_cost(MEMORY_REF_COST);
 4070   size(4);
 4071   format %{ &quot;STD(Y)  $src,$dst\t # stk spill double&quot; %}
 4072   opcode(STD_ZOPC);
 4073   ins_encode(z_form_rt_mem(src, dst));
 4074   ins_pipe(pipe_class_dummy);
 4075 %}
 4076 
 4077 //----------Load/Store/Move Instructions---------------------------------------
 4078 
 4079 //----------Load Instructions--------------------------------------------------
 4080 
 4081 //------------------
 4082 //  MEMORY
 4083 //------------------
 4084 
 4085 //  BYTE
 4086 // Load Byte (8bit signed)
 4087 instruct loadB(iRegI dst, memory mem) %{
 4088   match(Set dst (LoadB mem));
 4089   ins_cost(MEMORY_REF_COST);
 4090   size(Z_DISP3_SIZE);
 4091   format %{ &quot;LB      $dst, $mem\t # sign-extend byte to int&quot; %}
 4092   opcode(LB_ZOPC, LB_ZOPC);
 4093   ins_encode(z_form_rt_mem_opt(dst, mem));
 4094   ins_pipe(pipe_class_dummy);
 4095 %}
 4096 
 4097 // Load Byte (8bit signed)
 4098 instruct loadB2L(iRegL dst, memory mem) %{
 4099   match(Set dst (ConvI2L (LoadB mem)));
 4100   ins_cost(MEMORY_REF_COST);
 4101   size(Z_DISP3_SIZE);
 4102   format %{ &quot;LGB     $dst, $mem\t # sign-extend byte to long&quot; %}
 4103   opcode(LGB_ZOPC, LGB_ZOPC);
 4104   ins_encode(z_form_rt_mem_opt(dst, mem));
 4105   ins_pipe(pipe_class_dummy);
 4106 %}
 4107 
 4108 // Load Unsigned Byte (8bit UNsigned) into an int reg.
 4109 instruct loadUB(iRegI dst, memory mem) %{
 4110   match(Set dst (LoadUB mem));
 4111   ins_cost(MEMORY_REF_COST);
 4112   size(Z_DISP3_SIZE);
 4113   format %{ &quot;LLGC    $dst,$mem\t # zero-extend byte to int&quot; %}
 4114   opcode(LLGC_ZOPC, LLGC_ZOPC);
 4115   ins_encode(z_form_rt_mem_opt(dst, mem));
 4116   ins_pipe(pipe_class_dummy);
 4117 %}
 4118 
 4119 // Load Unsigned Byte (8bit UNsigned) into a Long Register.
 4120 instruct loadUB2L(iRegL dst, memory mem) %{
 4121   match(Set dst (ConvI2L (LoadUB mem)));
 4122   ins_cost(MEMORY_REF_COST);
 4123   size(Z_DISP3_SIZE);
 4124   format %{ &quot;LLGC    $dst,$mem\t # zero-extend byte to long&quot; %}
 4125   opcode(LLGC_ZOPC, LLGC_ZOPC);
 4126   ins_encode(z_form_rt_mem_opt(dst, mem));
 4127   ins_pipe(pipe_class_dummy);
 4128 %}
 4129 
 4130 // CHAR/SHORT
 4131 
 4132 // Load Short (16bit signed)
 4133 instruct loadS(iRegI dst, memory mem) %{
 4134   match(Set dst (LoadS mem));
 4135   ins_cost(MEMORY_REF_COST);
 4136   size(Z_DISP_SIZE);
 4137   format %{ &quot;LH(Y)   $dst,$mem\t # sign-extend short to int&quot; %}
 4138   opcode(LHY_ZOPC, LH_ZOPC);
 4139   ins_encode(z_form_rt_mem_opt(dst, mem));
 4140   ins_pipe(pipe_class_dummy);
 4141 %}
 4142 
 4143 // Load Short (16bit signed)
 4144 instruct loadS2L(iRegL dst, memory mem) %{
 4145   match(Set dst (ConvI2L (LoadS mem)));
 4146   ins_cost(MEMORY_REF_COST);
 4147   size(Z_DISP3_SIZE);
 4148   format %{ &quot;LGH     $dst,$mem\t # sign-extend short to long&quot; %}
 4149   opcode(LGH_ZOPC, LGH_ZOPC);
 4150   ins_encode(z_form_rt_mem_opt(dst, mem));
 4151   ins_pipe(pipe_class_dummy);
 4152 %}
 4153 
 4154 // Load Char (16bit Unsigned)
 4155 instruct loadUS(iRegI dst, memory mem) %{
 4156   match(Set dst (LoadUS mem));
 4157   ins_cost(MEMORY_REF_COST);
 4158   size(Z_DISP3_SIZE);
 4159   format %{ &quot;LLGH    $dst,$mem\t # zero-extend short to int&quot; %}
 4160   opcode(LLGH_ZOPC, LLGH_ZOPC);
 4161   ins_encode(z_form_rt_mem_opt(dst, mem));
 4162   ins_pipe(pipe_class_dummy);
 4163 %}
 4164 
 4165 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register.
 4166 instruct loadUS2L(iRegL dst, memory mem) %{
 4167   match(Set dst (ConvI2L (LoadUS mem)));
 4168   ins_cost(MEMORY_REF_COST);
 4169   size(Z_DISP3_SIZE);
 4170   format %{ &quot;LLGH    $dst,$mem\t # zero-extend short to long&quot; %}
 4171   opcode(LLGH_ZOPC, LLGH_ZOPC);
 4172   ins_encode(z_form_rt_mem_opt(dst, mem));
 4173   ins_pipe(pipe_class_dummy);
 4174 %}
 4175 
 4176 // INT
 4177 
 4178 // Load Integer
 4179 instruct loadI(iRegI dst, memory mem) %{
 4180   match(Set dst (LoadI mem));
 4181   ins_cost(MEMORY_REF_COST);
 4182   size(Z_DISP_SIZE);
 4183   format %{ &quot;L(Y)    $dst,$mem\t #&quot; %}
 4184   opcode(LY_ZOPC, L_ZOPC);
 4185   ins_encode(z_form_rt_mem_opt(dst, mem));
 4186   ins_pipe(pipe_class_dummy);
 4187 %}
 4188 
 4189 // Load and convert to long.
 4190 instruct loadI2L(iRegL dst, memory mem) %{
 4191   match(Set dst (ConvI2L (LoadI mem)));
 4192   ins_cost(MEMORY_REF_COST);
 4193   size(Z_DISP3_SIZE);
 4194   format %{ &quot;LGF     $dst,$mem\t #&quot; %}
 4195   opcode(LGF_ZOPC, LGF_ZOPC);
 4196   ins_encode(z_form_rt_mem_opt(dst, mem));
 4197   ins_pipe(pipe_class_dummy);
 4198 %}
 4199 
 4200 // Load Unsigned Integer into a Long Register
 4201 instruct loadUI2L(iRegL dst, memory mem, immL_FFFFFFFF mask) %{
 4202   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 4203   ins_cost(MEMORY_REF_COST);
 4204   size(Z_DISP3_SIZE);
 4205   format %{ &quot;LLGF    $dst,$mem\t # zero-extend int to long&quot; %}
 4206   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4207   ins_encode(z_form_rt_mem_opt(dst, mem));
 4208   ins_pipe(pipe_class_dummy);
 4209 %}
 4210 
 4211 // range = array length (=jint)
 4212 // Load Range
 4213 instruct loadRange(iRegI dst, memory mem) %{
 4214   match(Set dst (LoadRange mem));
 4215   ins_cost(MEMORY_REF_COST);
 4216   size(Z_DISP_SIZE);
 4217   format %{ &quot;L(Y)    $dst,$mem\t # range&quot; %}
 4218   opcode(LY_ZOPC, L_ZOPC);
 4219   ins_encode(z_form_rt_mem_opt(dst, mem));
 4220   ins_pipe(pipe_class_dummy);
 4221 %}
 4222 
 4223 // LONG
 4224 
 4225 // Load Long - aligned
 4226 instruct loadL(iRegL dst, memory mem) %{
 4227   match(Set dst (LoadL mem));
 4228   ins_cost(MEMORY_REF_COST);
 4229   size(Z_DISP3_SIZE);
 4230   format %{ &quot;LG      $dst,$mem\t # long&quot; %}
 4231   opcode(LG_ZOPC, LG_ZOPC);
 4232   ins_encode(z_form_rt_mem_opt(dst, mem));
 4233   ins_pipe(pipe_class_dummy);
 4234 %}
 4235 
 4236 // Load Long - UNaligned
 4237 instruct loadL_unaligned(iRegL dst, memory mem) %{
 4238   match(Set dst (LoadL_unaligned mem));
 4239   ins_cost(MEMORY_REF_COST);
 4240   size(Z_DISP3_SIZE);
 4241   format %{ &quot;LG      $dst,$mem\t # unaligned long&quot; %}
 4242   opcode(LG_ZOPC, LG_ZOPC);
 4243   ins_encode(z_form_rt_mem_opt(dst, mem));
 4244   ins_pipe(pipe_class_dummy);
 4245 %}
 4246 
 4247 
 4248 // PTR
 4249 
 4250 // Load Pointer
 4251 instruct loadP(iRegP dst, memory mem) %{
 4252   match(Set dst (LoadP mem));
 4253   ins_cost(MEMORY_REF_COST);
 4254   size(Z_DISP3_SIZE);
 4255   format %{ &quot;LG      $dst,$mem\t # ptr&quot; %}
 4256   opcode(LG_ZOPC, LG_ZOPC);
 4257   ins_encode(z_form_rt_mem_opt(dst, mem));
 4258   ins_pipe(pipe_class_dummy);
 4259 %}
 4260 
 4261 // LoadP + CastP2L
 4262 instruct castP2X_loadP(iRegL dst, memory mem) %{
 4263   match(Set dst (CastP2X (LoadP mem)));
 4264   ins_cost(MEMORY_REF_COST);
 4265   size(Z_DISP3_SIZE);
 4266   format %{ &quot;LG      $dst,$mem\t # ptr + p2x&quot; %}
 4267   opcode(LG_ZOPC, LG_ZOPC);
 4268   ins_encode(z_form_rt_mem_opt(dst, mem));
 4269   ins_pipe(pipe_class_dummy);
 4270 %}
 4271 
 4272 // Load Klass Pointer
 4273 instruct loadKlass(iRegP dst, memory mem) %{
 4274   match(Set dst (LoadKlass mem));
 4275   ins_cost(MEMORY_REF_COST);
 4276   size(Z_DISP3_SIZE);
 4277   format %{ &quot;LG      $dst,$mem\t # klass ptr&quot; %}
 4278   opcode(LG_ZOPC, LG_ZOPC);
 4279   ins_encode(z_form_rt_mem_opt(dst, mem));
 4280   ins_pipe(pipe_class_dummy);
 4281 %}
 4282 
 4283 instruct loadTOC(iRegL dst) %{
 4284   effect(DEF dst);
 4285   ins_cost(DEFAULT_COST);
 4286   // TODO: s390 port size(FIXED_SIZE);
 4287   // TODO: check why this attribute causes many unnecessary rematerializations.
 4288   //
 4289   // The graphs I saw just had high register pressure. Further the
 4290   // register TOC is loaded to is overwritten by the constant short
 4291   // after. Here something as round robin register allocation might
 4292   // help. But rematerializing seems not to hurt, jack even seems to
 4293   // improve slightly.
 4294   //
 4295   // Without this flag we get spill-split recycle sanity check
 4296   // failures in
 4297   // spec.benchmarks._228_jack.NfaState::GenerateCode. This happens in
 4298   // a block with three loadConP_dynTOC nodes and a tlsLoadP. The
 4299   // tlsLoadP has a huge amount of outs and forces the TOC down to the
 4300   // stack. Later tlsLoadP is rematerialized, leaving the register
 4301   // allocator with TOC on the stack and a badly placed reload.
 4302   ins_should_rematerialize(true);
 4303   format %{ &quot;LARL    $dst, &amp;constant_pool\t; load dynTOC&quot; %}
 4304   ins_encode %{ __ load_toc($dst$$Register); %}
 4305   ins_pipe(pipe_class_dummy);
 4306 %}
 4307 
 4308 // FLOAT
 4309 
 4310 // Load Float
 4311 instruct loadF(regF dst, memory mem) %{
 4312   match(Set dst (LoadF mem));
 4313   ins_cost(MEMORY_REF_COST);
 4314   size(Z_DISP_SIZE);
 4315   format %{ &quot;LE(Y)    $dst,$mem&quot; %}
 4316   opcode(LEY_ZOPC, LE_ZOPC);
 4317   ins_encode(z_form_rt_mem_opt(dst, mem));
 4318   ins_pipe(pipe_class_dummy);
 4319 %}
 4320 
 4321 // DOUBLE
 4322 
 4323 // Load Double
 4324 instruct loadD(regD dst, memory mem) %{
 4325   match(Set dst (LoadD mem));
 4326   ins_cost(MEMORY_REF_COST);
 4327   size(Z_DISP_SIZE);
 4328   format %{ &quot;LD(Y)    $dst,$mem&quot; %}
 4329   opcode(LDY_ZOPC, LD_ZOPC);
 4330   ins_encode(z_form_rt_mem_opt(dst, mem));
 4331   ins_pipe(pipe_class_dummy);
 4332 %}
 4333 
 4334 // Load Double - UNaligned
 4335 instruct loadD_unaligned(regD dst, memory mem) %{
 4336   match(Set dst (LoadD_unaligned mem));
 4337   ins_cost(MEMORY_REF_COST);
 4338   size(Z_DISP_SIZE);
 4339   format %{ &quot;LD(Y)    $dst,$mem&quot; %}
 4340   opcode(LDY_ZOPC, LD_ZOPC);
 4341   ins_encode(z_form_rt_mem_opt(dst, mem));
 4342   ins_pipe(pipe_class_dummy);
 4343 %}
 4344 
 4345 
 4346 //----------------------
 4347 //  IMMEDIATES
 4348 //----------------------
 4349 
 4350 instruct loadConI(iRegI dst, immI src) %{
 4351   match(Set dst src);
 4352   ins_cost(DEFAULT_COST);
 4353   size(6);
 4354   format %{ &quot;LGFI    $dst,$src\t # (int)&quot; %}
 4355   ins_encode %{ __ z_lgfi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4356   ins_pipe(pipe_class_dummy);
 4357 %}
 4358 
 4359 instruct loadConI16(iRegI dst, immI16 src) %{
 4360   match(Set dst src);
 4361   ins_cost(DEFAULT_COST_LOW);
 4362   size(4);
 4363   format %{ &quot;LGHI    $dst,$src\t # (int)&quot; %}
 4364   ins_encode %{ __ z_lghi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4365   ins_pipe(pipe_class_dummy);
 4366 %}
 4367 
 4368 instruct loadConI_0(iRegI dst, immI_0 src, flagsReg cr) %{
 4369   match(Set dst src);
 4370   effect(KILL cr);
 4371   ins_cost(DEFAULT_COST_LOW);
 4372   size(4);
 4373   format %{ &quot;loadConI $dst,$src\t # (int) XGR because ZERO is loaded&quot; %}
 4374   opcode(XGR_ZOPC);
 4375   ins_encode(z_rreform(dst, dst));
 4376   ins_pipe(pipe_class_dummy);
 4377 %}
 4378 
 4379 instruct loadConUI16(iRegI dst, uimmI16 src) %{
 4380   match(Set dst src);
 4381   // TODO: s390 port size(FIXED_SIZE);
 4382   format %{ &quot;LLILL    $dst,$src&quot; %}
 4383   opcode(LLILL_ZOPC);
 4384   ins_encode(z_riform_unsigned(dst, src) );
 4385   ins_pipe(pipe_class_dummy);
 4386 %}
 4387 
 4388 // Load long constant from TOC with pcrelative address.
 4389 instruct loadConL_pcrelTOC(iRegL dst, immL src) %{
 4390   match(Set dst src);
 4391   ins_cost(MEMORY_REF_COST_LO);
 4392   size(6);
 4393   format %{ &quot;LGRL    $dst,[pcrelTOC]\t # load long $src from table&quot; %}
 4394   ins_encode %{
 4395     address long_address = __ long_constant($src$$constant);
 4396     if (long_address == NULL) {
 4397       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4398       return;
 4399     }
 4400     __ load_long_pcrelative($dst$$Register, long_address);
 4401   %}
 4402   ins_pipe(pipe_class_dummy);
 4403 %}
 4404 
 4405 instruct loadConL32(iRegL dst, immL32 src) %{
 4406   match(Set dst src);
 4407   ins_cost(DEFAULT_COST);
 4408   size(6);
 4409   format %{ &quot;LGFI     $dst,$src\t # (long)&quot; %}
 4410   ins_encode %{ __ z_lgfi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4411   ins_pipe(pipe_class_dummy);
 4412 %}
 4413 
 4414 instruct loadConL16(iRegL dst, immL16 src) %{
 4415   match(Set dst src);
 4416   ins_cost(DEFAULT_COST_LOW);
 4417   size(4);
 4418   format %{ &quot;LGHI     $dst,$src\t # (long)&quot; %}
 4419   ins_encode %{ __ z_lghi($dst$$Register, $src$$constant); %}  // Sign-extend to 64 bit, it&#39;s at no cost.
 4420   ins_pipe(pipe_class_dummy);
 4421 %}
 4422 
 4423 instruct loadConL_0(iRegL dst, immL_0 src, flagsReg cr) %{
 4424   match(Set dst src);
 4425   effect(KILL cr);
 4426   ins_cost(DEFAULT_COST_LOW);
 4427   format %{ &quot;LoadConL    $dst,$src\t # (long) XGR because ZERO is loaded&quot; %}
 4428   opcode(XGR_ZOPC);
 4429   ins_encode(z_rreform(dst, dst));
 4430   ins_pipe(pipe_class_dummy);
 4431 %}
 4432 
 4433 // Load ptr constant from TOC with pc relative address.
 4434 // Special handling for oop constants required.
 4435 instruct loadConP_pcrelTOC(iRegP dst, immP src) %{
 4436   match(Set dst src);
 4437   ins_cost(MEMORY_REF_COST_LO);
 4438   size(6);
 4439   format %{ &quot;LGRL    $dst,[pcrelTOC]\t # load ptr $src from table&quot; %}
 4440   ins_encode %{
 4441     relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();
 4442     if (constant_reloc == relocInfo::oop_type) {
 4443       AddressLiteral a = __ allocate_oop_address((jobject)$src$$constant);
 4444       bool success = __ load_oop_from_toc($dst$$Register, a);
 4445       if (!success) {
 4446         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4447         return;
 4448       }
 4449     } else if (constant_reloc == relocInfo::metadata_type) {
 4450       AddressLiteral a = __ constant_metadata_address((Metadata *)$src$$constant);
 4451       address const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 4452       if (const_toc_addr == NULL) {
 4453         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4454         return;
 4455       }
 4456       __ load_long_pcrelative($dst$$Register, const_toc_addr);
 4457     } else {          // Non-oop pointers, e.g. card mark base, heap top.
 4458       address long_address = __ long_constant((jlong)$src$$constant);
 4459       if (long_address == NULL) {
 4460         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 4461         return;
 4462       }
 4463       __ load_long_pcrelative($dst$$Register, long_address);
 4464     }
 4465   %}
 4466   ins_pipe(pipe_class_dummy);
 4467 %}
 4468 
 4469 // We don&#39;t use immP16 to avoid problems with oops.
 4470 instruct loadConP0(iRegP dst, immP0 src, flagsReg cr) %{
 4471   match(Set dst src);
 4472   effect(KILL cr);
 4473   size(4);
 4474   format %{ &quot;XGR     $dst,$dst\t # NULL ptr&quot; %}
 4475   opcode(XGR_ZOPC);
 4476   ins_encode(z_rreform(dst, dst));
 4477   ins_pipe(pipe_class_dummy);
 4478 %}
 4479 
 4480 //----------Load Float Constant Instructions-------------------------------------------------
 4481 
 4482 // We may not specify this instruction via an `expand&#39; rule. If we do,
 4483 // code selection will forget that this instruction needs a floating
 4484 // point constant inserted into the code buffer. So `Shorten_branches&#39;
 4485 // will fail.
 4486 instruct loadConF_dynTOC(regF dst, immF src, flagsReg cr) %{
 4487   match(Set dst src);
 4488   effect(KILL cr);
 4489   ins_cost(MEMORY_REF_COST);
 4490   size(6);
 4491   // If this instruction rematerializes, it prolongs the live range
 4492   // of the toc node, causing illegal graphs.
 4493   ins_cannot_rematerialize(true);
 4494   format %{ &quot;LE(Y)    $dst,$constantoffset[,$constanttablebase]\t # load FLOAT $src from table&quot; %}
 4495   ins_encode %{
 4496     __ load_float_largeoffset($dst$$FloatRegister, $constantoffset($src), $constanttablebase, Z_R1_scratch);
 4497   %}
 4498   ins_pipe(pipe_class_dummy);
 4499 %}
 4500 
 4501 // E may not specify this instruction via an `expand&#39; rule. If we do,
 4502 // code selection will forget that this instruction needs a floating
 4503 // point constant inserted into the code buffer. So `Shorten_branches&#39;
 4504 // will fail.
 4505 instruct loadConD_dynTOC(regD dst, immD src, flagsReg cr) %{
 4506   match(Set dst src);
 4507   effect(KILL cr);
 4508   ins_cost(MEMORY_REF_COST);
 4509   size(6);
 4510   // If this instruction rematerializes, it prolongs the live range
 4511   // of the toc node, causing illegal graphs.
 4512   ins_cannot_rematerialize(true);
 4513   format %{ &quot;LD(Y)    $dst,$constantoffset[,$constanttablebase]\t # load DOUBLE $src from table&quot; %}
 4514   ins_encode %{
 4515     __ load_double_largeoffset($dst$$FloatRegister, $constantoffset($src), $constanttablebase, Z_R1_scratch);
 4516   %}
 4517   ins_pipe(pipe_class_dummy);
 4518 %}
 4519 
 4520 // Special case: Load Const 0.0F
 4521 
 4522 // There&#39;s a special instr to clear a FP register.
 4523 instruct loadConF0(regF dst, immFp0 src) %{
 4524   match(Set dst src);
 4525   ins_cost(DEFAULT_COST_LOW);
 4526   size(4);
 4527   format %{ &quot;LZER     $dst,$src\t # clear to zero&quot; %}
 4528   opcode(LZER_ZOPC);
 4529   ins_encode(z_rreform(dst, Z_F0));
 4530   ins_pipe(pipe_class_dummy);
 4531 %}
 4532 
 4533 // There&#39;s a special instr to clear a FP register.
 4534 instruct loadConD0(regD dst, immDp0 src) %{
 4535   match(Set dst src);
 4536   ins_cost(DEFAULT_COST_LOW);
 4537   size(4);
 4538   format %{ &quot;LZDR     $dst,$src\t # clear to zero&quot; %}
 4539   opcode(LZDR_ZOPC);
 4540   ins_encode(z_rreform(dst, Z_F0));
 4541   ins_pipe(pipe_class_dummy);
 4542 %}
 4543 
 4544 
 4545 //----------Store Instructions-------------------------------------------------
 4546 
 4547 // BYTE
 4548 
 4549 // Store Byte
 4550 instruct storeB(memory mem, iRegI src) %{
 4551   match(Set mem (StoreB mem src));
 4552   ins_cost(MEMORY_REF_COST);
 4553   size(Z_DISP_SIZE);
 4554   format %{ &quot;STC(Y)  $src,$mem\t # byte&quot; %}
 4555   opcode(STCY_ZOPC, STC_ZOPC);
 4556   ins_encode(z_form_rt_mem_opt(src, mem));
 4557   ins_pipe(pipe_class_dummy);
 4558 %}
 4559 
 4560 instruct storeCM(memory mem, immI_0 src) %{
 4561   match(Set mem (StoreCM mem src));
 4562   ins_cost(MEMORY_REF_COST);
 4563   // TODO: s390 port size(VARIABLE_SIZE);
 4564   format %{ &quot;STC(Y)  $src,$mem\t # CMS card-mark byte (must be 0!)&quot; %}
 4565   ins_encode %{
 4566     guarantee($mem$$index$$Register != Z_R0, &quot;content will not be used.&quot;);
 4567     if ($mem$$index$$Register != noreg) {
 4568       // Can&#39;t use clear_mem --&gt; load const zero and store character.
 4569       __ load_const_optimized(Z_R0_scratch, (long)0);
 4570       if (Immediate::is_uimm12($mem$$disp)) {
 4571         __ z_stc(Z_R0_scratch, $mem$$Address);
 4572       } else {
 4573         __ z_stcy(Z_R0_scratch, $mem$$Address);
 4574       }
 4575     } else {
 4576       __ clear_mem(Address($mem$$Address), 1);
 4577     }
 4578   %}
 4579   ins_pipe(pipe_class_dummy);
 4580 %}
 4581 
 4582 // CHAR/SHORT
 4583 
 4584 // Store Char/Short
 4585 instruct storeC(memory mem, iRegI src) %{
 4586   match(Set mem (StoreC mem src));
 4587   ins_cost(MEMORY_REF_COST);
 4588   size(Z_DISP_SIZE);
 4589   format %{ &quot;STH(Y)  $src,$mem\t # short&quot; %}
 4590   opcode(STHY_ZOPC, STH_ZOPC);
 4591   ins_encode(z_form_rt_mem_opt(src, mem));
 4592   ins_pipe(pipe_class_dummy);
 4593 %}
 4594 
 4595 // INT
 4596 
 4597 // Store Integer
 4598 instruct storeI(memory mem, iRegI src) %{
 4599   match(Set mem (StoreI mem src));
 4600   ins_cost(MEMORY_REF_COST);
 4601   size(Z_DISP_SIZE);
 4602   format %{ &quot;ST(Y)   $src,$mem\t # int&quot; %}
 4603   opcode(STY_ZOPC, ST_ZOPC);
 4604   ins_encode(z_form_rt_mem_opt(src, mem));
 4605   ins_pipe(pipe_class_dummy);
 4606 %}
 4607 
 4608 // LONG
 4609 
 4610 // Store Long
 4611 instruct storeL(memory mem, iRegL src) %{
 4612   match(Set mem (StoreL mem src));
 4613   ins_cost(MEMORY_REF_COST);
 4614   size(Z_DISP3_SIZE);
 4615   format %{ &quot;STG     $src,$mem\t # long&quot; %}
 4616   opcode(STG_ZOPC, STG_ZOPC);
 4617   ins_encode(z_form_rt_mem_opt(src, mem));
 4618   ins_pipe(pipe_class_dummy);
 4619 %}
 4620 
 4621 // PTR
 4622 
 4623 // Store Pointer
 4624 instruct storeP(memory dst, memoryRegP src) %{
 4625   match(Set dst (StoreP dst src));
 4626   ins_cost(MEMORY_REF_COST);
 4627   size(Z_DISP3_SIZE);
 4628   format %{ &quot;STG     $src,$dst\t # ptr&quot; %}
 4629   opcode(STG_ZOPC, STG_ZOPC);
 4630   ins_encode(z_form_rt_mem_opt(src, dst));
 4631   ins_pipe(pipe_class_dummy);
 4632 %}
 4633 
 4634 // FLOAT
 4635 
 4636 // Store Float
 4637 instruct storeF(memory mem, regF src) %{
 4638   match(Set mem (StoreF mem src));
 4639   ins_cost(MEMORY_REF_COST);
 4640   size(Z_DISP_SIZE);
 4641   format %{ &quot;STE(Y)   $src,$mem\t # float&quot; %}
 4642   opcode(STEY_ZOPC, STE_ZOPC);
 4643   ins_encode(z_form_rt_mem_opt(src, mem));
 4644   ins_pipe(pipe_class_dummy);
 4645 %}
 4646 
 4647 // DOUBLE
 4648 
 4649 // Store Double
 4650 instruct storeD(memory mem, regD src) %{
 4651   match(Set mem (StoreD mem src));
 4652   ins_cost(MEMORY_REF_COST);
 4653   size(Z_DISP_SIZE);
 4654   format %{ &quot;STD(Y)   $src,$mem\t # double&quot; %}
 4655   opcode(STDY_ZOPC, STD_ZOPC);
 4656   ins_encode(z_form_rt_mem_opt(src, mem));
 4657   ins_pipe(pipe_class_dummy);
 4658 %}
 4659 
 4660 // Prefetch instructions. Must be safe to execute with invalid address (cannot fault).
 4661 
 4662 // Should support match rule for PrefetchAllocation.
 4663 // Still needed after 8068977 for PrefetchAllocate.
 4664 instruct prefetchAlloc(memory mem) %{
 4665   match(PrefetchAllocation mem);
 4666   predicate(VM_Version::has_Prefetch());
 4667   ins_cost(DEFAULT_COST);
 4668   format %{ &quot;PREFETCH 2, $mem\t # Prefetch allocation, z10 only&quot; %}
 4669   ins_encode %{ __ z_pfd(0x02, $mem$$Address); %}
 4670   ins_pipe(pipe_class_dummy);
 4671 %}
 4672 
 4673 //----------Memory init instructions------------------------------------------
 4674 
 4675 // Move Immediate to 1-byte memory.
 4676 instruct memInitB(memoryRSY mem, immI8 src) %{
 4677   match(Set mem (StoreB mem src));
 4678   ins_cost(MEMORY_REF_COST);
 4679   // TODO: s390 port size(VARIABLE_SIZE);
 4680   format %{ &quot;MVI     $mem,$src\t # direct mem init 1&quot; %}
 4681   ins_encode %{
 4682     if (Immediate::is_uimm12((long)$mem$$disp)) {
 4683       __ z_mvi($mem$$Address, $src$$constant);
 4684     } else {
 4685       __ z_mviy($mem$$Address, $src$$constant);
 4686     }
 4687   %}
 4688   ins_pipe(pipe_class_dummy);
 4689 %}
 4690 
 4691 // Move Immediate to 2-byte memory.
 4692 instruct memInitC(memoryRS mem, immI16 src) %{
 4693   match(Set mem (StoreC mem src));
 4694   ins_cost(MEMORY_REF_COST);
 4695   size(6);
 4696   format %{ &quot;MVHHI   $mem,$src\t # direct mem init 2&quot; %}
 4697   opcode(MVHHI_ZOPC);
 4698   ins_encode(z_silform(mem, src));
 4699   ins_pipe(pipe_class_dummy);
 4700 %}
 4701 
 4702 // Move Immediate to 4-byte memory.
 4703 instruct memInitI(memoryRS mem, immI16 src) %{
 4704   match(Set mem (StoreI mem src));
 4705   ins_cost(MEMORY_REF_COST);
 4706   size(6);
 4707   format %{ &quot;MVHI    $mem,$src\t # direct mem init 4&quot; %}
 4708   opcode(MVHI_ZOPC);
 4709   ins_encode(z_silform(mem, src));
 4710   ins_pipe(pipe_class_dummy);
 4711 %}
 4712 
 4713 
 4714 // Move Immediate to 8-byte memory.
 4715 instruct memInitL(memoryRS mem, immL16 src) %{
 4716   match(Set mem (StoreL mem src));
 4717   ins_cost(MEMORY_REF_COST);
 4718   size(6);
 4719   format %{ &quot;MVGHI   $mem,$src\t # direct mem init 8&quot; %}
 4720   opcode(MVGHI_ZOPC);
 4721   ins_encode(z_silform(mem, src));
 4722   ins_pipe(pipe_class_dummy);
 4723 %}
 4724 
 4725 // Move Immediate to 8-byte memory.
 4726 instruct memInitP(memoryRS mem, immP16 src) %{
 4727   match(Set mem (StoreP mem src));
 4728   ins_cost(MEMORY_REF_COST);
 4729   size(6);
 4730   format %{ &quot;MVGHI   $mem,$src\t # direct mem init 8&quot; %}
 4731   opcode(MVGHI_ZOPC);
 4732   ins_encode(z_silform(mem, src));
 4733   ins_pipe(pipe_class_dummy);
 4734 %}
 4735 
 4736 
 4737 //----------Instructions for compressed pointers (cOop and NKlass)-------------
 4738 
 4739 // See cOop encoding classes for elaborate comment.
 4740 
 4741 // Moved here because it is needed in expand rules for encode.
 4742 // Long negation.
 4743 instruct negL_reg_reg(iRegL dst, immL_0 zero, iRegL src, flagsReg cr) %{
 4744   match(Set dst (SubL zero src));
 4745   effect(KILL cr);
 4746   size(4);
 4747   format %{ &quot;NEG     $dst, $src\t # long&quot; %}
 4748   ins_encode %{ __ z_lcgr($dst$$Register, $src$$Register); %}
 4749   ins_pipe(pipe_class_dummy);
 4750 %}
 4751 
 4752 // Load Compressed Pointer
 4753 
 4754 // Load narrow oop
 4755 instruct loadN(iRegN dst, memory mem) %{
 4756   match(Set dst (LoadN mem));
 4757   ins_cost(MEMORY_REF_COST);
 4758   size(Z_DISP3_SIZE);
 4759   format %{ &quot;LoadN   $dst,$mem\t # (cOop)&quot; %}
 4760   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4761   ins_encode(z_form_rt_mem_opt(dst, mem));
 4762   ins_pipe(pipe_class_dummy);
 4763 %}
 4764 
 4765 // Load narrow Klass Pointer
 4766 instruct loadNKlass(iRegN dst, memory mem) %{
 4767   match(Set dst (LoadNKlass mem));
 4768   ins_cost(MEMORY_REF_COST);
 4769   size(Z_DISP3_SIZE);
 4770   format %{ &quot;LoadNKlass $dst,$mem\t # (klass cOop)&quot; %}
 4771   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4772   ins_encode(z_form_rt_mem_opt(dst, mem));
 4773   ins_pipe(pipe_class_dummy);
 4774 %}
 4775 
 4776 // Load constant Compressed Pointer
 4777 
 4778 instruct loadConN(iRegN dst, immN src) %{
 4779   match(Set dst src);
 4780   ins_cost(DEFAULT_COST);
 4781   size(6);
 4782   format %{ &quot;loadConN    $dst,$src\t # (cOop)&quot; %}
 4783   ins_encode %{
 4784     AddressLiteral cOop = __ constant_oop_address((jobject)$src$$constant);
 4785     __ relocate(cOop.rspec(), 1);
 4786     __ load_narrow_oop($dst$$Register, (narrowOop)cOop.value());
 4787   %}
 4788   ins_pipe(pipe_class_dummy);
 4789 %}
 4790 
 4791 instruct loadConN0(iRegN dst, immN0 src, flagsReg cr) %{
 4792   match(Set dst src);
 4793   effect(KILL cr);
 4794   ins_cost(DEFAULT_COST_LOW);
 4795   size(4);
 4796   format %{ &quot;loadConN    $dst,$src\t # (cOop) XGR because ZERO is loaded&quot; %}
 4797   opcode(XGR_ZOPC);
 4798   ins_encode(z_rreform(dst, dst));
 4799   ins_pipe(pipe_class_dummy);
 4800 %}
 4801 
 4802 instruct loadConNKlass(iRegN dst, immNKlass src) %{
 4803   match(Set dst src);
 4804   ins_cost(DEFAULT_COST);
 4805   size(6);
 4806   format %{ &quot;loadConNKlass $dst,$src\t # (cKlass)&quot; %}
 4807   ins_encode %{
 4808     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src$$constant);
 4809     __ relocate(NKlass.rspec(), 1);
 4810     __ load_narrow_klass($dst$$Register, (Klass*)NKlass.value());
 4811   %}
 4812   ins_pipe(pipe_class_dummy);
 4813 %}
 4814 
 4815 // Load and Decode Compressed Pointer
 4816 // optimized variants for Unscaled cOops
 4817 
 4818 instruct decodeLoadN(iRegP dst, memory mem) %{
 4819   match(Set dst (DecodeN (LoadN mem)));
 4820   predicate(false &amp;&amp; (CompressedOops::base()==NULL)&amp;&amp;(CompressedOops::shift()==0));
 4821   ins_cost(MEMORY_REF_COST);
 4822   size(Z_DISP3_SIZE);
 4823   format %{ &quot;DecodeLoadN  $dst,$mem\t # (cOop Load+Decode)&quot; %}
 4824   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4825   ins_encode(z_form_rt_mem_opt(dst, mem));
 4826   ins_pipe(pipe_class_dummy);
 4827 %}
 4828 
 4829 instruct decodeLoadNKlass(iRegP dst, memory mem) %{
 4830   match(Set dst (DecodeNKlass (LoadNKlass mem)));
 4831   predicate(false &amp;&amp; (CompressedKlassPointers::base()==NULL)&amp;&amp;(CompressedKlassPointers::shift()==0));
 4832   ins_cost(MEMORY_REF_COST);
 4833   size(Z_DISP3_SIZE);
 4834   format %{ &quot;DecodeLoadNKlass  $dst,$mem\t # (load/decode NKlass)&quot; %}
 4835   opcode(LLGF_ZOPC, LLGF_ZOPC);
 4836   ins_encode(z_form_rt_mem_opt(dst, mem));
 4837   ins_pipe(pipe_class_dummy);
 4838 %}
 4839 
 4840 instruct decodeLoadConNKlass(iRegP dst, immNKlass src) %{
 4841   match(Set dst (DecodeNKlass src));
 4842   ins_cost(3 * DEFAULT_COST);
 4843   size(12);
 4844   format %{ &quot;DecodeLoadConNKlass  $dst,$src\t # decode(cKlass)&quot; %}
 4845   ins_encode %{
 4846     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src$$constant);
 4847     __ relocate(NKlass.rspec(), 1);
 4848     __ load_const($dst$$Register, (Klass*)NKlass.value());
 4849   %}
 4850   ins_pipe(pipe_class_dummy);
 4851 %}
 4852 
 4853 // Decode Compressed Pointer
 4854 
 4855 // General decoder
 4856 instruct decodeN(iRegP dst, iRegN src, flagsReg cr) %{
 4857   match(Set dst (DecodeN src));
 4858   effect(KILL cr);
 4859   predicate(CompressedOops::base() == NULL || !ExpandLoadingBaseDecode);
 4860   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST + BRANCH_COST);
 4861   // TODO: s390 port size(VARIABLE_SIZE);
 4862   format %{ &quot;decodeN  $dst,$src\t # (decode cOop)&quot; %}
 4863   ins_encode %{  __ oop_decoder($dst$$Register, $src$$Register, true); %}
 4864   ins_pipe(pipe_class_dummy);
 4865 %}
 4866 
 4867 // General Klass decoder
 4868 instruct decodeKlass(iRegP dst, iRegN src, flagsReg cr) %{
 4869   match(Set dst (DecodeNKlass src));
 4870   effect(KILL cr);
 4871   ins_cost(3 * DEFAULT_COST);
 4872   format %{ &quot;decode_klass $dst,$src&quot; %}
 4873   ins_encode %{ __ decode_klass_not_null($dst$$Register, $src$$Register); %}
 4874   ins_pipe(pipe_class_dummy);
 4875 %}
 4876 
 4877 // General decoder
 4878 instruct decodeN_NN(iRegP dst, iRegN src, flagsReg cr) %{
 4879   match(Set dst (DecodeN src));
 4880   effect(KILL cr);
 4881   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull ||
 4882              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 4883             (CompressedOops::base()== NULL || !ExpandLoadingBaseDecode_NN));
 4884   ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 4885   // TODO: s390 port size(VARIABLE_SIZE);
 4886   format %{ &quot;decodeN  $dst,$src\t # (decode cOop NN)&quot; %}
 4887   ins_encode %{ __ oop_decoder($dst$$Register, $src$$Register, false); %}
 4888   ins_pipe(pipe_class_dummy);
 4889 %}
 4890 
 4891   instruct loadBase(iRegL dst, immL baseImm) %{
 4892     effect(DEF dst, USE baseImm);
 4893     predicate(false);
 4894     format %{ &quot;llihl    $dst=$baseImm \t// load heap base&quot; %}
 4895     ins_encode %{ __ get_oop_base($dst$$Register, $baseImm$$constant); %}
 4896     ins_pipe(pipe_class_dummy);
 4897   %}
 4898 
 4899   // Decoder for heapbased mode peeling off loading the base.
 4900   instruct decodeN_base(iRegP dst, iRegN src, iRegL base, flagsReg cr) %{
 4901     match(Set dst (DecodeN src base));
 4902     // Note: Effect TEMP dst was used with the intention to get
 4903     // different regs for dst and base, but this has caused ADLC to
 4904     // generate wrong code. Oop_decoder generates additional lgr when
 4905     // dst==base.
 4906     effect(KILL cr);
 4907     predicate(false);
 4908     // TODO: s390 port size(VARIABLE_SIZE);
 4909     format %{ &quot;decodeN  $dst = ($src == 0) ? NULL : ($src &lt;&lt; 3) + $base + pow2_offset\t # (decode cOop)&quot; %}
 4910     ins_encode %{
 4911       __ oop_decoder($dst$$Register, $src$$Register, true, $base$$Register,
 4912                      (jlong)MacroAssembler::get_oop_base_pow2_offset((uint64_t)(intptr_t)CompressedOops::base()));
 4913     %}
 4914     ins_pipe(pipe_class_dummy);
 4915   %}
 4916 
 4917   // Decoder for heapbased mode peeling off loading the base.
 4918   instruct decodeN_NN_base(iRegP dst, iRegN src, iRegL base, flagsReg cr) %{
 4919     match(Set dst (DecodeN src base));
 4920     effect(KILL cr);
 4921     predicate(false);
 4922     // TODO: s390 port size(VARIABLE_SIZE);
 4923     format %{ &quot;decodeN  $dst = ($src &lt;&lt; 3) + $base + pow2_offset\t # (decode cOop)&quot; %}
 4924     ins_encode %{
 4925       __ oop_decoder($dst$$Register, $src$$Register, false, $base$$Register,
 4926                      (jlong)MacroAssembler::get_oop_base_pow2_offset((uint64_t)(intptr_t)CompressedOops::base()));
 4927     %}
 4928     ins_pipe(pipe_class_dummy);
 4929   %}
 4930 
 4931 // Decoder for heapbased mode peeling off loading the base.
 4932 instruct decodeN_Ex(iRegP dst, iRegN src, flagsReg cr) %{
 4933   match(Set dst (DecodeN src));
 4934   predicate(CompressedOops::base() != NULL &amp;&amp; ExpandLoadingBaseDecode);
 4935   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST + BRANCH_COST);
 4936   // TODO: s390 port size(VARIABLE_SIZE);
 4937   expand %{
 4938     immL baseImm %{ (jlong)(intptr_t)CompressedOops::base() %}
 4939     iRegL base;
 4940     loadBase(base, baseImm);
 4941     decodeN_base(dst, src, base, cr);
 4942   %}
 4943 %}
 4944 
 4945 // Decoder for heapbased mode peeling off loading the base.
 4946 instruct decodeN_NN_Ex(iRegP dst, iRegN src, flagsReg cr) %{
 4947   match(Set dst (DecodeN src));
 4948   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull ||
 4949              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 4950             CompressedOops::base() != NULL &amp;&amp; ExpandLoadingBaseDecode_NN);
 4951   ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 4952   // TODO: s390 port size(VARIABLE_SIZE);
 4953   expand %{
 4954     immL baseImm %{ (jlong)(intptr_t)CompressedOops::base() %}
 4955     iRegL base;
 4956     loadBase(base, baseImm);
 4957     decodeN_NN_base(dst, src, base, cr);
 4958   %}
 4959 %}
 4960 
 4961 //  Encode Compressed Pointer
 4962 
 4963 // General encoder
 4964 instruct encodeP(iRegN dst, iRegP src, flagsReg cr) %{
 4965   match(Set dst (EncodeP src));
 4966   effect(KILL cr);
 4967   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull) &amp;&amp;
 4968             (CompressedOops::base() == 0 ||
 4969              CompressedOops::base_disjoint() ||
 4970              !ExpandLoadingBaseEncode));
 4971   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 4972   // TODO: s390 port size(VARIABLE_SIZE);
 4973   format %{ &quot;encodeP  $dst,$src\t # (encode cOop)&quot; %}
 4974   ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, true, Z_R1_scratch, -1, all_outs_are_Stores(this)); %}
 4975   ins_pipe(pipe_class_dummy);
 4976 %}
 4977 
 4978 // General class encoder
 4979 instruct encodeKlass(iRegN dst, iRegP src, flagsReg cr) %{
 4980   match(Set dst (EncodePKlass src));
 4981   effect(KILL cr);
 4982   format %{ &quot;encode_klass $dst,$src&quot; %}
 4983   ins_encode %{ __ encode_klass_not_null($dst$$Register, $src$$Register); %}
 4984   ins_pipe(pipe_class_dummy);
 4985 %}
 4986 
 4987 instruct encodeP_NN(iRegN dst, iRegP src, flagsReg cr) %{
 4988   match(Set dst (EncodeP src));
 4989   effect(KILL cr);
 4990   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull) &amp;&amp;
 4991             (CompressedOops::base() == 0 ||
 4992              CompressedOops::base_disjoint() ||
 4993              !ExpandLoadingBaseEncode_NN));
 4994   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 4995   // TODO: s390 port size(VARIABLE_SIZE);
 4996   format %{ &quot;encodeP  $dst,$src\t # (encode cOop)&quot; %}
 4997   ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, false, Z_R1_scratch, -1, all_outs_are_Stores(this)); %}
 4998   ins_pipe(pipe_class_dummy);
 4999 %}
 5000 
 5001   // Encoder for heapbased mode peeling off loading the base.
 5002   instruct encodeP_base(iRegN dst, iRegP src, iRegL base) %{
 5003     match(Set dst (EncodeP src (Binary base dst)));
 5004     effect(TEMP_DEF dst);
 5005     predicate(false);
 5006     ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 5007     // TODO: s390 port size(VARIABLE_SIZE);
 5008     format %{ &quot;encodeP  $dst = ($src&gt;&gt;3) +$base + pow2_offset\t # (encode cOop)&quot; %}
 5009     ins_encode %{
 5010       jlong offset = -(jlong)MacroAssembler::get_oop_base_pow2_offset
 5011         (((uint64_t)(intptr_t)CompressedOops::base()) &gt;&gt; CompressedOops::shift());
 5012       __ oop_encoder($dst$$Register, $src$$Register, true, $base$$Register, offset);
 5013     %}
 5014     ins_pipe(pipe_class_dummy);
 5015   %}
 5016 
 5017   // Encoder for heapbased mode peeling off loading the base.
 5018   instruct encodeP_NN_base(iRegN dst, iRegP src, iRegL base, immL pow2_offset) %{
 5019     match(Set dst (EncodeP src base));
 5020     effect(USE pow2_offset);
 5021     predicate(false);
 5022     ins_cost(MEMORY_REF_COST+2 * DEFAULT_COST);
 5023     // TODO: s390 port size(VARIABLE_SIZE);
 5024     format %{ &quot;encodeP  $dst = ($src&gt;&gt;3) +$base + $pow2_offset\t # (encode cOop)&quot; %}
 5025     ins_encode %{ __ oop_encoder($dst$$Register, $src$$Register, false, $base$$Register, $pow2_offset$$constant); %}
 5026     ins_pipe(pipe_class_dummy);
 5027   %}
 5028 
 5029 // Encoder for heapbased mode peeling off loading the base.
 5030 instruct encodeP_Ex(iRegN dst, iRegP src, flagsReg cr) %{
 5031   match(Set dst (EncodeP src));
 5032   effect(KILL cr);
 5033   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull) &amp;&amp;
 5034             (CompressedOops::base_overlaps() &amp;&amp; ExpandLoadingBaseEncode));
 5035   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 5036   // TODO: s390 port size(VARIABLE_SIZE);
 5037   expand %{
 5038     immL baseImm %{ ((jlong)(intptr_t)CompressedOops::base()) &gt;&gt; CompressedOops::shift() %}
 5039     immL_0 zero %{ (0) %}
 5040     flagsReg ccr;
 5041     iRegL base;
 5042     iRegL negBase;
 5043     loadBase(base, baseImm);
 5044     negL_reg_reg(negBase, zero, base, ccr);
 5045     encodeP_base(dst, src, negBase);
 5046   %}
 5047 %}
 5048 
 5049 // Encoder for heapbased mode peeling off loading the base.
 5050 instruct encodeP_NN_Ex(iRegN dst, iRegP src, flagsReg cr) %{
 5051   match(Set dst (EncodeP src));
 5052   effect(KILL cr);
 5053   predicate((n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull) &amp;&amp;
 5054             (CompressedOops::base_overlaps() &amp;&amp; ExpandLoadingBaseEncode_NN));
 5055   ins_cost(MEMORY_REF_COST+3 * DEFAULT_COST);
 5056   // TODO: s390 port size(VARIABLE_SIZE);
 5057   expand %{
 5058     immL baseImm %{ (jlong)(intptr_t)CompressedOops::base() %}
 5059     immL pow2_offset %{ -(jlong)MacroAssembler::get_oop_base_pow2_offset(((uint64_t)(intptr_t)CompressedOops::base())) %}
 5060     immL_0 zero %{ 0 %}
 5061     flagsReg ccr;
 5062     iRegL base;
 5063     iRegL negBase;
 5064     loadBase(base, baseImm);
 5065     negL_reg_reg(negBase, zero, base, ccr);
 5066     encodeP_NN_base(dst, src, negBase, pow2_offset);
 5067   %}
 5068 %}
 5069 
 5070 //  Store Compressed Pointer
 5071 
 5072 // Store Compressed Pointer
 5073 instruct storeN(memory mem, iRegN_P2N src) %{
 5074   match(Set mem (StoreN mem src));
 5075   ins_cost(MEMORY_REF_COST);
 5076   size(Z_DISP_SIZE);
 5077   format %{ &quot;ST      $src,$mem\t # (cOop)&quot; %}
 5078   opcode(STY_ZOPC, ST_ZOPC);
 5079   ins_encode(z_form_rt_mem_opt(src, mem));
 5080   ins_pipe(pipe_class_dummy);
 5081 %}
 5082 
 5083 // Store Compressed Klass pointer
 5084 instruct storeNKlass(memory mem, iRegN src) %{
 5085   match(Set mem (StoreNKlass mem src));
 5086   ins_cost(MEMORY_REF_COST);
 5087   size(Z_DISP_SIZE);
 5088   format %{ &quot;ST      $src,$mem\t # (cKlass)&quot; %}
 5089   opcode(STY_ZOPC, ST_ZOPC);
 5090   ins_encode(z_form_rt_mem_opt(src, mem));
 5091   ins_pipe(pipe_class_dummy);
 5092 %}
 5093 
 5094 // Compare Compressed Pointers
 5095 
 5096 instruct compN_iRegN(iRegN_P2N src1, iRegN_P2N src2, flagsReg cr) %{
 5097   match(Set cr (CmpN src1 src2));
 5098   ins_cost(DEFAULT_COST);
 5099   size(2);
 5100   format %{ &quot;CLR     $src1,$src2\t # (cOop)&quot; %}
 5101   opcode(CLR_ZOPC);
 5102   ins_encode(z_rrform(src1, src2));
 5103   ins_pipe(pipe_class_dummy);
 5104 %}
 5105 
 5106 instruct compN_iRegN_immN(iRegN_P2N src1, immN src2, flagsReg cr) %{
 5107   match(Set cr (CmpN src1 src2));
 5108   ins_cost(DEFAULT_COST);
 5109   size(6);
 5110   format %{ &quot;CLFI    $src1,$src2\t # (cOop) compare immediate narrow&quot; %}
 5111   ins_encode %{
 5112     AddressLiteral cOop = __ constant_oop_address((jobject)$src2$$constant);
 5113     __ relocate(cOop.rspec(), 1);
 5114     __ compare_immediate_narrow_oop($src1$$Register, (narrowOop)cOop.value());
 5115   %}
 5116   ins_pipe(pipe_class_dummy);
 5117 %}
 5118 
 5119 instruct compNKlass_iRegN_immN(iRegN src1, immNKlass src2, flagsReg cr) %{
 5120   match(Set cr (CmpN src1 src2));
 5121   ins_cost(DEFAULT_COST);
 5122   size(6);
 5123   format %{ &quot;CLFI    $src1,$src2\t # (NKlass) compare immediate narrow&quot; %}
 5124   ins_encode %{
 5125     AddressLiteral NKlass = __ constant_metadata_address((Metadata*)$src2$$constant);
 5126     __ relocate(NKlass.rspec(), 1);
 5127     __ compare_immediate_narrow_klass($src1$$Register, (Klass*)NKlass.value());
 5128   %}
 5129   ins_pipe(pipe_class_dummy);
 5130 %}
 5131 
 5132 instruct compN_iRegN_immN0(iRegN_P2N src1, immN0 src2, flagsReg cr) %{
 5133   match(Set cr (CmpN src1 src2));
 5134   ins_cost(DEFAULT_COST);
 5135   size(2);
 5136   format %{ &quot;LTR     $src1,$src2\t # (cOop) LTR because comparing against zero&quot; %}
 5137   opcode(LTR_ZOPC);
 5138   ins_encode(z_rrform(src1, src1));
 5139   ins_pipe(pipe_class_dummy);
 5140 %}
 5141 
 5142 
 5143 //----------MemBar Instructions-----------------------------------------------
 5144 
 5145 // Memory barrier flavors
 5146 
 5147 instruct membar_acquire() %{
 5148   match(MemBarAcquire);
 5149   match(LoadFence);
 5150   ins_cost(4*MEMORY_REF_COST);
 5151   size(0);
 5152   format %{ &quot;MEMBAR-acquire&quot; %}
 5153   ins_encode %{ __ z_acquire(); %}
 5154   ins_pipe(pipe_class_dummy);
 5155 %}
 5156 
 5157 instruct membar_acquire_lock() %{
 5158   match(MemBarAcquireLock);
 5159   ins_cost(0);
 5160   size(0);
 5161   format %{ &quot;MEMBAR-acquire (CAS in prior FastLock so empty encoding)&quot; %}
 5162   ins_encode(/*empty*/);
 5163   ins_pipe(pipe_class_dummy);
 5164 %}
 5165 
 5166 instruct membar_release() %{
 5167   match(MemBarRelease);
 5168   match(StoreFence);
 5169   ins_cost(4 * MEMORY_REF_COST);
 5170   size(0);
 5171   format %{ &quot;MEMBAR-release&quot; %}
 5172   ins_encode %{ __ z_release(); %}
 5173   ins_pipe(pipe_class_dummy);
 5174 %}
 5175 
 5176 instruct membar_release_lock() %{
 5177   match(MemBarReleaseLock);
 5178   ins_cost(0);
 5179   size(0);
 5180   format %{ &quot;MEMBAR-release (CAS in succeeding FastUnlock so empty encoding)&quot; %}
 5181   ins_encode(/*empty*/);
 5182   ins_pipe(pipe_class_dummy);
 5183 %}
 5184 
 5185 instruct membar_volatile() %{
 5186   match(MemBarVolatile);
 5187   ins_cost(4 * MEMORY_REF_COST);
 5188   size(2);
 5189   format %{ &quot;MEMBAR-volatile&quot; %}
 5190   ins_encode %{ __ z_fence(); %}
 5191   ins_pipe(pipe_class_dummy);
 5192 %}
 5193 
 5194 instruct unnecessary_membar_volatile() %{
 5195   match(MemBarVolatile);
 5196   predicate(Matcher::post_store_load_barrier(n));
 5197   ins_cost(0);
 5198   size(0);
 5199   format %{ &quot;# MEMBAR-volatile (empty)&quot; %}
 5200   ins_encode(/*empty*/);
 5201   ins_pipe(pipe_class_dummy);
 5202 %}
 5203 
 5204 instruct membar_CPUOrder() %{
 5205   match(MemBarCPUOrder);
 5206   ins_cost(0);
 5207   // TODO: s390 port size(FIXED_SIZE);
 5208   format %{ &quot;MEMBAR-CPUOrder (empty)&quot; %}
 5209   ins_encode(/*empty*/);
 5210   ins_pipe(pipe_class_dummy);
 5211 %}
 5212 
 5213 instruct membar_storestore() %{
 5214   match(MemBarStoreStore);
 5215   ins_cost(0);
 5216   size(0);
 5217   format %{ &quot;MEMBAR-storestore (empty)&quot; %}
 5218   ins_encode();
 5219   ins_pipe(pipe_class_dummy);
 5220 %}
 5221 
 5222 
 5223 //----------Register Move Instructions-----------------------------------------
 5224 instruct roundDouble_nop(regD dst) %{
 5225   match(Set dst (RoundDouble dst));
 5226   ins_cost(0);
 5227   // TODO: s390 port size(FIXED_SIZE);
 5228   // z/Architecture results are already &quot;rounded&quot; (i.e., normal-format IEEE).
 5229   ins_encode();
 5230   ins_pipe(pipe_class_dummy);
 5231 %}
 5232 
 5233 instruct roundFloat_nop(regF dst) %{
 5234   match(Set dst (RoundFloat dst));
 5235   ins_cost(0);
 5236   // TODO: s390 port size(FIXED_SIZE);
 5237   // z/Architecture results are already &quot;rounded&quot; (i.e., normal-format IEEE).
 5238   ins_encode();
 5239   ins_pipe(pipe_class_dummy);
 5240 %}
 5241 
 5242 // Cast Long to Pointer for unsafe natives.
 5243 instruct castX2P(iRegP dst, iRegL src) %{
 5244   match(Set dst (CastX2P src));
 5245   // TODO: s390 port size(VARIABLE_SIZE);
 5246   format %{ &quot;LGR     $dst,$src\t # CastX2P&quot; %}
 5247   ins_encode %{ __ lgr_if_needed($dst$$Register, $src$$Register); %}
 5248   ins_pipe(pipe_class_dummy);
 5249 %}
 5250 
 5251 // Cast Pointer to Long for unsafe natives.
 5252 instruct castP2X(iRegL dst, iRegP_N2P src) %{
 5253   match(Set dst (CastP2X src));
 5254   // TODO: s390 port size(VARIABLE_SIZE);
 5255   format %{ &quot;LGR     $dst,$src\t # CastP2X&quot; %}
 5256   ins_encode %{ __ lgr_if_needed($dst$$Register, $src$$Register); %}
 5257   ins_pipe(pipe_class_dummy);
 5258 %}
 5259 
 5260 instruct stfSSD(stackSlotD stkSlot, regD src) %{
 5261   // %%%% TODO: Tell the coalescer that this kind of node is a copy!
 5262   match(Set stkSlot src);   // chain rule
 5263   ins_cost(MEMORY_REF_COST);
 5264   // TODO: s390 port size(FIXED_SIZE);
 5265   format %{ &quot; STD   $src,$stkSlot\t # stk&quot; %}
 5266   opcode(STD_ZOPC);
 5267   ins_encode(z_form_rt_mem(src, stkSlot));
 5268   ins_pipe(pipe_class_dummy);
 5269 %}
 5270 
 5271 instruct stfSSF(stackSlotF stkSlot, regF src) %{
 5272   // %%%% TODO: Tell the coalescer that this kind of node is a copy!
 5273   match(Set stkSlot src);   // chain rule
 5274   ins_cost(MEMORY_REF_COST);
 5275   // TODO: s390 port size(FIXED_SIZE);
 5276   format %{ &quot;STE   $src,$stkSlot\t # stk&quot; %}
 5277   opcode(STE_ZOPC);
 5278   ins_encode(z_form_rt_mem(src, stkSlot));
 5279   ins_pipe(pipe_class_dummy);
 5280 %}
 5281 
 5282 //----------Conditional Move---------------------------------------------------
 5283 
 5284 instruct cmovN_reg(cmpOp cmp, flagsReg cr, iRegN dst, iRegN_P2N src) %{
 5285   match(Set dst (CMoveN (Binary cmp cr) (Binary dst src)));
 5286   ins_cost(DEFAULT_COST + BRANCH_COST);
 5287   // TODO: s390 port size(VARIABLE_SIZE);
 5288   format %{ &quot;CMoveN,$cmp   $dst,$src&quot; %}
 5289   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5290   ins_pipe(pipe_class_dummy);
 5291 %}
 5292 
 5293 instruct cmovN_imm(cmpOp cmp, flagsReg cr, iRegN dst, immN0 src) %{
 5294   match(Set dst (CMoveN (Binary cmp cr) (Binary dst src)));
 5295   ins_cost(DEFAULT_COST + BRANCH_COST);
 5296   // TODO: s390 port size(VARIABLE_SIZE);
 5297   format %{ &quot;CMoveN,$cmp   $dst,$src&quot; %}
 5298   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5299   ins_pipe(pipe_class_dummy);
 5300 %}
 5301 
 5302 instruct cmovI_reg(cmpOp cmp, flagsReg cr, iRegI dst, iRegI src) %{
 5303   match(Set dst (CMoveI (Binary cmp cr) (Binary dst src)));
 5304   ins_cost(DEFAULT_COST + BRANCH_COST);
 5305   // TODO: s390 port size(VARIABLE_SIZE);
 5306   format %{ &quot;CMoveI,$cmp   $dst,$src&quot; %}
 5307   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5308   ins_pipe(pipe_class_dummy);
 5309 %}
 5310 
 5311 instruct cmovI_imm(cmpOp cmp, flagsReg cr, iRegI dst, immI16 src) %{
 5312   match(Set dst (CMoveI (Binary cmp cr) (Binary dst src)));
 5313   ins_cost(DEFAULT_COST + BRANCH_COST);
 5314   // TODO: s390 port size(VARIABLE_SIZE);
 5315   format %{ &quot;CMoveI,$cmp   $dst,$src&quot; %}
 5316   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5317   ins_pipe(pipe_class_dummy);
 5318 %}
 5319 
 5320 instruct cmovP_reg(cmpOp cmp, flagsReg cr, iRegP dst, iRegP_N2P src) %{
 5321   match(Set dst (CMoveP (Binary cmp cr) (Binary dst src)));
 5322   ins_cost(DEFAULT_COST + BRANCH_COST);
 5323   // TODO: s390 port size(VARIABLE_SIZE);
 5324   format %{ &quot;CMoveP,$cmp    $dst,$src&quot; %}
 5325   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5326   ins_pipe(pipe_class_dummy);
 5327 %}
 5328 
 5329 instruct cmovP_imm(cmpOp cmp, flagsReg cr, iRegP dst, immP0 src) %{
 5330   match(Set dst (CMoveP (Binary cmp cr) (Binary dst src)));
 5331   ins_cost(DEFAULT_COST + BRANCH_COST);
 5332   // TODO: s390 port size(VARIABLE_SIZE);
 5333   format %{ &quot;CMoveP,$cmp  $dst,$src&quot; %}
 5334   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5335   ins_pipe(pipe_class_dummy);
 5336 %}
 5337 
 5338 instruct cmovF_reg(cmpOpF cmp, flagsReg cr, regF dst, regF src) %{
 5339   match(Set dst (CMoveF (Binary cmp cr) (Binary dst src)));
 5340   ins_cost(DEFAULT_COST + BRANCH_COST);
 5341   // TODO: s390 port size(VARIABLE_SIZE);
 5342   format %{ &quot;CMoveF,$cmp   $dst,$src&quot; %}
 5343   ins_encode %{
 5344     // Don&#39;t emit code if operands are identical (same register).
 5345     if ($dst$$FloatRegister != $src$$FloatRegister) {
 5346       Label done;
 5347       __ z_brc(Assembler::inverse_float_condition((Assembler::branch_condition)$cmp$$cmpcode), done);
 5348       __ z_ler($dst$$FloatRegister, $src$$FloatRegister);
 5349       __ bind(done);
 5350     }
 5351   %}
 5352   ins_pipe(pipe_class_dummy);
 5353 %}
 5354 
 5355 instruct cmovD_reg(cmpOpF cmp, flagsReg cr, regD dst, regD src) %{
 5356   match(Set dst (CMoveD (Binary cmp cr) (Binary dst src)));
 5357   ins_cost(DEFAULT_COST + BRANCH_COST);
 5358   // TODO: s390 port size(VARIABLE_SIZE);
 5359   format %{ &quot;CMoveD,$cmp   $dst,$src&quot; %}
 5360   ins_encode %{
 5361     // Don&#39;t emit code if operands are identical (same register).
 5362     if ($dst$$FloatRegister != $src$$FloatRegister) {
 5363       Label done;
 5364       __ z_brc(Assembler::inverse_float_condition((Assembler::branch_condition)$cmp$$cmpcode), done);
 5365       __ z_ldr($dst$$FloatRegister, $src$$FloatRegister);
 5366       __ bind(done);
 5367     }
 5368   %}
 5369   ins_pipe(pipe_class_dummy);
 5370 %}
 5371 
 5372 instruct cmovL_reg(cmpOp cmp, flagsReg cr, iRegL dst, iRegL src) %{
 5373   match(Set dst (CMoveL (Binary cmp cr) (Binary dst src)));
 5374   ins_cost(DEFAULT_COST + BRANCH_COST);
 5375   // TODO: s390 port size(VARIABLE_SIZE);
 5376   format %{ &quot;CMoveL,$cmp  $dst,$src&quot; %}
 5377   ins_encode(z_enc_cmov_reg(cmp,dst,src));
 5378   ins_pipe(pipe_class_dummy);
 5379 %}
 5380 
 5381 instruct cmovL_imm(cmpOp cmp, flagsReg cr, iRegL dst, immL16 src) %{
 5382   match(Set dst (CMoveL (Binary cmp cr) (Binary dst src)));
 5383   ins_cost(DEFAULT_COST + BRANCH_COST);
 5384   // TODO: s390 port size(VARIABLE_SIZE);
 5385   format %{ &quot;CMoveL,$cmp  $dst,$src&quot; %}
 5386   ins_encode(z_enc_cmov_imm(cmp,dst,src));
 5387   ins_pipe(pipe_class_dummy);
 5388 %}
 5389 
 5390 //----------OS and Locking Instructions----------------------------------------
 5391 
 5392 // This name is KNOWN by the ADLC and cannot be changed.
 5393 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
 5394 // for this guy.
 5395 instruct tlsLoadP(threadRegP dst) %{
 5396   match(Set dst (ThreadLocal));
 5397   ins_cost(0);
 5398   size(0);
 5399   ins_should_rematerialize(true);
 5400   format %{ &quot;# $dst=ThreadLocal&quot; %}
 5401   ins_encode(/* empty */);
 5402   ins_pipe(pipe_class_dummy);
 5403 %}
 5404 
 5405 instruct checkCastPP(iRegP dst) %{
 5406   match(Set dst (CheckCastPP dst));
 5407   size(0);
 5408   format %{ &quot;# checkcastPP of $dst&quot; %}
 5409   ins_encode(/*empty*/);
 5410   ins_pipe(pipe_class_dummy);
 5411 %}
 5412 
 5413 instruct castPP(iRegP dst) %{
 5414   match(Set dst (CastPP dst));
 5415   size(0);
 5416   format %{ &quot;# castPP of $dst&quot; %}
 5417   ins_encode(/*empty*/);
 5418   ins_pipe(pipe_class_dummy);
 5419 %}
 5420 
 5421 instruct castII(iRegI dst) %{
 5422   match(Set dst (CastII dst));
 5423   size(0);
 5424   format %{ &quot;# castII of $dst&quot; %}
 5425   ins_encode(/*empty*/);
 5426   ins_pipe(pipe_class_dummy);
 5427 %}
 5428 
 5429 instruct castLL(iRegL dst) %{
 5430   match(Set dst (CastLL dst));
 5431   size(0);
 5432   format %{ &quot;# castLL of $dst&quot; %}
 5433   ins_encode(/*empty*/);
 5434   ins_pipe(pipe_class_dummy);
 5435 %}
 5436 
 5437 
 5438 //----------Conditional_store--------------------------------------------------
 5439 // Conditional-store of the updated heap-top.
 5440 // Used during allocation of the shared heap.
 5441 // Sets flags (EQ) on success.
 5442 
 5443 // Implement LoadPLocked. Must be ordered against changes of the memory location
 5444 // by storePConditional.
 5445 // Don&#39;t know whether this is ever used.
 5446 instruct loadPLocked(iRegP dst, memory mem) %{
 5447   match(Set dst (LoadPLocked mem));
 5448   ins_cost(MEMORY_REF_COST);
 5449   size(Z_DISP3_SIZE);
 5450   format %{ &quot;LG      $dst,$mem\t # LoadPLocked&quot; %}
 5451   opcode(LG_ZOPC, LG_ZOPC);
 5452   ins_encode(z_form_rt_mem_opt(dst, mem));
 5453   ins_pipe(pipe_class_dummy);
 5454 %}
 5455 
 5456 // As compareAndSwapP, but return flag register instead of boolean value in
 5457 // int register.
 5458 // This instruction is matched if UseTLAB is off. Needed to pass
 5459 // option tests.  Mem_ptr must be a memory operand, else this node
 5460 // does not get Flag_needs_anti_dependence_check set by adlc. If this
 5461 // is not set this node can be rematerialized which leads to errors.
 5462 instruct storePConditional(indirect mem_ptr, rarg5RegP oldval, iRegP_N2P newval, flagsReg cr) %{
 5463   match(Set cr (StorePConditional mem_ptr (Binary oldval newval)));
 5464   effect(KILL oldval);
 5465   // TODO: s390 port size(FIXED_SIZE);
 5466   format %{ &quot;storePConditional $oldval,$newval,$mem_ptr&quot; %}
 5467   ins_encode(z_enc_casL(oldval, newval, mem_ptr));
 5468   ins_pipe(pipe_class_dummy);
 5469 %}
 5470 
 5471 // As compareAndSwapL, but return flag register instead of boolean value in
 5472 // int register.
 5473 // Used by sun/misc/AtomicLongCSImpl.java. Mem_ptr must be a memory
 5474 // operand, else this node does not get
 5475 // Flag_needs_anti_dependence_check set by adlc. If this is not set
 5476 // this node can be rematerialized which leads to errors.
 5477 instruct storeLConditional(indirect mem_ptr, rarg5RegL oldval, iRegL newval, flagsReg cr) %{
 5478   match(Set cr (StoreLConditional mem_ptr (Binary oldval newval)));
 5479   effect(KILL oldval);
 5480   // TODO: s390 port size(FIXED_SIZE);
 5481   format %{ &quot;storePConditional $oldval,$newval,$mem_ptr&quot; %}
 5482   ins_encode(z_enc_casL(oldval, newval, mem_ptr));
 5483   ins_pipe(pipe_class_dummy);
 5484 %}
 5485 
 5486 // No flag versions for CompareAndSwap{P,I,L,N} because matcher can&#39;t match them.
 5487 
 5488 instruct compareAndSwapI_bool(iRegP mem_ptr, rarg5RegI oldval, iRegI newval, iRegI res, flagsReg cr) %{
 5489   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 5490   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5491   size(16);
 5492   format %{ &quot;$res = CompareAndSwapI $oldval,$newval,$mem_ptr&quot; %}
 5493   ins_encode(z_enc_casI(oldval, newval, mem_ptr),
 5494              z_enc_cctobool(res));
 5495   ins_pipe(pipe_class_dummy);
 5496 %}
 5497 
 5498 instruct compareAndSwapL_bool(iRegP mem_ptr, rarg5RegL oldval, iRegL newval, iRegI res, flagsReg cr) %{
 5499   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 5500   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5501   size(18);
 5502   format %{ &quot;$res = CompareAndSwapL $oldval,$newval,$mem_ptr&quot; %}
 5503   ins_encode(z_enc_casL(oldval, newval, mem_ptr),
 5504              z_enc_cctobool(res));
 5505   ins_pipe(pipe_class_dummy);
 5506 %}
 5507 
 5508 instruct compareAndSwapP_bool(iRegP mem_ptr, rarg5RegP oldval, iRegP_N2P newval, iRegI res, flagsReg cr) %{
 5509   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 5510   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5511   size(18);
 5512   format %{ &quot;$res = CompareAndSwapP $oldval,$newval,$mem_ptr&quot; %}
 5513   ins_encode(z_enc_casL(oldval, newval, mem_ptr),
 5514              z_enc_cctobool(res));
 5515   ins_pipe(pipe_class_dummy);
 5516 %}
 5517 
 5518 instruct compareAndSwapN_bool(iRegP mem_ptr, rarg5RegN oldval, iRegN_P2N newval, iRegI res, flagsReg cr) %{
 5519   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 5520   effect(USE mem_ptr, USE_KILL oldval, KILL cr);
 5521   size(16);
 5522   format %{ &quot;$res = CompareAndSwapN $oldval,$newval,$mem_ptr&quot; %}
 5523   ins_encode(z_enc_casI(oldval, newval, mem_ptr),
 5524              z_enc_cctobool(res));
 5525   ins_pipe(pipe_class_dummy);
 5526 %}
 5527 
 5528 //----------Atomic operations on memory (GetAndSet*, GetAndAdd*)---------------
 5529 
 5530 // Exploit: direct memory arithmetic
 5531 // Prereqs: - instructions available
 5532 //          - instructions guarantee atomicity
 5533 //          - immediate operand to be added
 5534 //          - immediate operand is small enough (8-bit signed).
 5535 //          - result of instruction is not used
 5536 instruct addI_mem_imm8_atomic_no_res(memoryRSY mem, Universe dummy, immI8 src, flagsReg cr) %{
 5537   match(Set dummy (GetAndAddI mem src));
 5538   effect(KILL cr);
 5539   predicate(VM_Version::has_AtomicMemWithImmALUOps() &amp;&amp; n-&gt;as_LoadStore()-&gt;result_not_used());
 5540   ins_cost(MEMORY_REF_COST);
 5541   size(6);
 5542   format %{ &quot;ASI     [$mem],$src\t # GetAndAddI (atomic)&quot; %}
 5543   opcode(ASI_ZOPC);
 5544   ins_encode(z_siyform(mem, src));
 5545   ins_pipe(pipe_class_dummy);
 5546 %}
 5547 
 5548 // Fallback: direct memory arithmetic not available
 5549 // Disadvantages: - CS-Loop required, very expensive.
 5550 //                - more code generated (26 to xx bytes vs. 6 bytes)
 5551 instruct addI_mem_imm16_atomic(memoryRSY mem, iRegI dst, immI16 src, iRegI tmp, flagsReg cr) %{
 5552   match(Set dst (GetAndAddI mem src));
 5553   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5554   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5555   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5556             &quot;  LGF     $dst,[$mem]\n\t&quot;
 5557             &quot;  AHIK    $tmp,$dst,$src\n\t&quot;
 5558             &quot;  CSY     $dst,$tmp,$mem\n\t&quot;
 5559             &quot;  retry if failed\n\t&quot;
 5560             &quot;} END ATOMIC&quot;
 5561          %}
 5562   ins_encode %{
 5563     Register Rdst = $dst$$Register;
 5564     Register Rtmp = $tmp$$Register;
 5565     int      Isrc = $src$$constant;
 5566     Label    retry;
 5567 
 5568     // Iterate until update with incremented value succeeds.
 5569     __ z_lgf(Rdst, $mem$$Address);    // current contents
 5570     __ bind(retry);
 5571       // Calculate incremented value.
 5572       if (VM_Version::has_DistinctOpnds()) {
 5573         __ z_ahik(Rtmp, Rdst, Isrc);
 5574       } else {
 5575         __ z_lr(Rtmp, Rdst);
 5576         __ z_ahi(Rtmp, Isrc);
 5577       }
 5578       // Swap into memory location.
 5579       __ z_csy(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5580     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5581   %}
 5582   ins_pipe(pipe_class_dummy);
 5583 %}
 5584 
 5585 instruct addI_mem_imm32_atomic(memoryRSY mem, iRegI dst, immI src, iRegI tmp, flagsReg cr) %{
 5586   match(Set dst (GetAndAddI mem src));
 5587   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5588   ins_cost(MEMORY_REF_COST+200*DEFAULT_COST);
 5589   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5590             &quot;  LGF     $dst,[$mem]\n\t&quot;
 5591             &quot;  LGR     $tmp,$dst\n\t&quot;
 5592             &quot;  AFI     $tmp,$src\n\t&quot;
 5593             &quot;  CSY     $dst,$tmp,$mem\n\t&quot;
 5594             &quot;  retry if failed\n\t&quot;
 5595             &quot;} END ATOMIC&quot;
 5596          %}
 5597   ins_encode %{
 5598     Register Rdst = $dst$$Register;
 5599     Register Rtmp = $tmp$$Register;
 5600     int      Isrc = $src$$constant;
 5601     Label    retry;
 5602 
 5603     // Iterate until update with incremented value succeeds.
 5604     __ z_lgf(Rdst, $mem$$Address);    // current contents
 5605     __ bind(retry);
 5606       // Calculate incremented value.
 5607       __ z_lr(Rtmp, Rdst);
 5608       __ z_afi(Rtmp, Isrc);
 5609       // Swap into memory location.
 5610       __ z_csy(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5611     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5612   %}
 5613   ins_pipe(pipe_class_dummy);
 5614 %}
 5615 
 5616 instruct addI_mem_reg_atomic(memoryRSY mem, iRegI dst, iRegI src, iRegI tmp, flagsReg cr) %{
 5617   match(Set dst (GetAndAddI mem src));
 5618   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5619   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5620   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5621             &quot;  LGF     $dst,[$mem]\n\t&quot;
 5622             &quot;  ARK     $tmp,$dst,$src\n\t&quot;
 5623             &quot;  CSY     $dst,$tmp,$mem\n\t&quot;
 5624             &quot;  retry if failed\n\t&quot;
 5625             &quot;} END ATOMIC&quot;
 5626          %}
 5627   ins_encode %{
 5628     Register Rsrc = $src$$Register;
 5629     Register Rdst = $dst$$Register;
 5630     Register Rtmp = $tmp$$Register;
 5631     Label    retry;
 5632 
 5633     // Iterate until update with incremented value succeeds.
 5634     __ z_lgf(Rdst, $mem$$Address);  // current contents
 5635     __ bind(retry);
 5636       // Calculate incremented value.
 5637       if (VM_Version::has_DistinctOpnds()) {
 5638         __ z_ark(Rtmp, Rdst, Rsrc);
 5639       } else {
 5640         __ z_lr(Rtmp, Rdst);
 5641         __ z_ar(Rtmp, Rsrc);
 5642       }
 5643       __ z_csy(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5644     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5645   %}
 5646   ins_pipe(pipe_class_dummy);
 5647 %}
 5648 
 5649 
 5650 // Exploit: direct memory arithmetic
 5651 // Prereqs: - instructions available
 5652 //          - instructions guarantee atomicity
 5653 //          - immediate operand to be added
 5654 //          - immediate operand is small enough (8-bit signed).
 5655 //          - result of instruction is not used
 5656 instruct addL_mem_imm8_atomic_no_res(memoryRSY mem, Universe dummy, immL8 src, flagsReg cr) %{
 5657   match(Set dummy (GetAndAddL mem src));
 5658   effect(KILL cr);
 5659   predicate(VM_Version::has_AtomicMemWithImmALUOps() &amp;&amp; n-&gt;as_LoadStore()-&gt;result_not_used());
 5660   ins_cost(MEMORY_REF_COST);
 5661   size(6);
 5662   format %{ &quot;AGSI    [$mem],$src\t # GetAndAddL (atomic)&quot; %}
 5663   opcode(AGSI_ZOPC);
 5664   ins_encode(z_siyform(mem, src));
 5665   ins_pipe(pipe_class_dummy);
 5666 %}
 5667 
 5668 // Fallback: direct memory arithmetic not available
 5669 // Disadvantages: - CS-Loop required, very expensive.
 5670 //                - more code generated (26 to xx bytes vs. 6 bytes)
 5671 instruct addL_mem_imm16_atomic(memoryRSY mem, iRegL dst, immL16 src, iRegL tmp, flagsReg cr) %{
 5672   match(Set dst (GetAndAddL mem src));
 5673   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5674   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5675   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5676             &quot;  LG      $dst,[$mem]\n\t&quot;
 5677             &quot;  AGHIK   $tmp,$dst,$src\n\t&quot;
 5678             &quot;  CSG     $dst,$tmp,$mem\n\t&quot;
 5679             &quot;  retry if failed\n\t&quot;
 5680             &quot;} END ATOMIC&quot;
 5681          %}
 5682   ins_encode %{
 5683     Register Rdst = $dst$$Register;
 5684     Register Rtmp = $tmp$$Register;
 5685     int      Isrc = $src$$constant;
 5686     Label    retry;
 5687 
 5688     // Iterate until update with incremented value succeeds.
 5689     __ z_lg(Rdst, $mem$$Address);  // current contents
 5690     __ bind(retry);
 5691       // Calculate incremented value.
 5692       if (VM_Version::has_DistinctOpnds()) {
 5693         __ z_aghik(Rtmp, Rdst, Isrc);
 5694       } else {
 5695         __ z_lgr(Rtmp, Rdst);
 5696         __ z_aghi(Rtmp, Isrc);
 5697       }
 5698       __ z_csg(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5699     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5700   %}
 5701   ins_pipe(pipe_class_dummy);
 5702 %}
 5703 
 5704 instruct addL_mem_imm32_atomic(memoryRSY mem, iRegL dst, immL32 src, iRegL tmp, flagsReg cr) %{
 5705   match(Set dst (GetAndAddL mem src));
 5706   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5707   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5708   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5709             &quot;  LG      $dst,[$mem]\n\t&quot;
 5710             &quot;  LGR     $tmp,$dst\n\t&quot;
 5711             &quot;  AGFI    $tmp,$src\n\t&quot;
 5712             &quot;  CSG     $dst,$tmp,$mem\n\t&quot;
 5713             &quot;  retry if failed\n\t&quot;
 5714             &quot;} END ATOMIC&quot;
 5715          %}
 5716   ins_encode %{
 5717     Register Rdst = $dst$$Register;
 5718     Register Rtmp = $tmp$$Register;
 5719     int      Isrc = $src$$constant;
 5720     Label    retry;
 5721 
 5722     // Iterate until update with incremented value succeeds.
 5723     __ z_lg(Rdst, $mem$$Address);  // current contents
 5724     __ bind(retry);
 5725       // Calculate incremented value.
 5726       __ z_lgr(Rtmp, Rdst);
 5727       __ z_agfi(Rtmp, Isrc);
 5728       __ z_csg(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5729     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5730   %}
 5731   ins_pipe(pipe_class_dummy);
 5732 %}
 5733 
 5734 instruct addL_mem_reg_atomic(memoryRSY mem, iRegL dst, iRegL src, iRegL tmp, flagsReg cr) %{
 5735   match(Set dst (GetAndAddL mem src));
 5736   effect(KILL cr, TEMP_DEF dst, TEMP tmp);
 5737   ins_cost(MEMORY_REF_COST+100*DEFAULT_COST);
 5738   format %{ &quot;BEGIN ATOMIC {\n\t&quot;
 5739             &quot;  LG      $dst,[$mem]\n\t&quot;
 5740             &quot;  AGRK    $tmp,$dst,$src\n\t&quot;
 5741             &quot;  CSG     $dst,$tmp,$mem\n\t&quot;
 5742             &quot;  retry if failed\n\t&quot;
 5743             &quot;} END ATOMIC&quot;
 5744          %}
 5745   ins_encode %{
 5746     Register Rsrc = $src$$Register;
 5747     Register Rdst = $dst$$Register;
 5748     Register Rtmp = $tmp$$Register;
 5749     Label    retry;
 5750 
 5751     // Iterate until update with incremented value succeeds.
 5752     __ z_lg(Rdst, $mem$$Address);  // current contents
 5753     __ bind(retry);
 5754       // Calculate incremented value.
 5755       if (VM_Version::has_DistinctOpnds()) {
 5756         __ z_agrk(Rtmp, Rdst, Rsrc);
 5757       } else {
 5758         __ z_lgr(Rtmp, Rdst);
 5759         __ z_agr(Rtmp, Rsrc);
 5760       }
 5761       __ z_csg(Rdst, Rtmp, $mem$$Address); // Try to store new value.
 5762     __ z_brne(retry);                      // Yikes, concurrent update, need to retry.
 5763   %}
 5764   ins_pipe(pipe_class_dummy);
 5765 %}
 5766 
 5767 // Increment value in memory, save old value in dst.
 5768 instruct addI_mem_reg_atomic_z196(memoryRSY mem, iRegI dst, iRegI src) %{
 5769   match(Set dst (GetAndAddI mem src));
 5770   predicate(VM_Version::has_LoadAndALUAtomicV1());
 5771   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5772   size(6);
 5773   format %{ &quot;LAA     $dst,$src,[$mem]&quot; %}
 5774   ins_encode %{ __ z_laa($dst$$Register, $src$$Register, $mem$$Address); %}
 5775   ins_pipe(pipe_class_dummy);
 5776 %}
 5777 
 5778 // Increment value in memory, save old value in dst.
 5779 instruct addL_mem_reg_atomic_z196(memoryRSY mem, iRegL dst, iRegL src) %{
 5780   match(Set dst (GetAndAddL mem src));
 5781   predicate(VM_Version::has_LoadAndALUAtomicV1());
 5782   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5783   size(6);
 5784   format %{ &quot;LAAG    $dst,$src,[$mem]&quot; %}
 5785   ins_encode %{ __ z_laag($dst$$Register, $src$$Register, $mem$$Address); %}
 5786   ins_pipe(pipe_class_dummy);
 5787 %}
 5788 
 5789 
 5790 instruct xchgI_reg_mem(memoryRSY mem, iRegI dst, iRegI tmp, flagsReg cr) %{
 5791   match(Set dst (GetAndSetI mem dst));
 5792   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5793   format %{ &quot;XCHGI   $dst,[$mem]\t # EXCHANGE (int, atomic), temp $tmp&quot; %}
 5794   ins_encode(z_enc_SwapI(mem, dst, tmp));
 5795   ins_pipe(pipe_class_dummy);
 5796 %}
 5797 
 5798 instruct xchgL_reg_mem(memoryRSY mem, iRegL dst, iRegL tmp, flagsReg cr) %{
 5799   match(Set dst (GetAndSetL mem dst));
 5800   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5801   format %{ &quot;XCHGL   $dst,[$mem]\t # EXCHANGE (long, atomic), temp $tmp&quot; %}
 5802   ins_encode(z_enc_SwapL(mem, dst, tmp));
 5803   ins_pipe(pipe_class_dummy);
 5804 %}
 5805 
 5806 instruct xchgN_reg_mem(memoryRSY mem, iRegN dst, iRegI tmp, flagsReg cr) %{
 5807   match(Set dst (GetAndSetN mem dst));
 5808   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5809   format %{ &quot;XCHGN   $dst,[$mem]\t # EXCHANGE (coop, atomic), temp $tmp&quot; %}
 5810   ins_encode(z_enc_SwapI(mem, dst, tmp));
 5811   ins_pipe(pipe_class_dummy);
 5812 %}
 5813 
 5814 instruct xchgP_reg_mem(memoryRSY mem, iRegP dst, iRegL tmp, flagsReg cr) %{
 5815   match(Set dst (GetAndSetP mem dst));
 5816   effect(KILL cr, TEMP tmp); // USE_DEF dst by match rule.
 5817   format %{ &quot;XCHGP   $dst,[$mem]\t # EXCHANGE (oop, atomic), temp $tmp&quot; %}
 5818   ins_encode(z_enc_SwapL(mem, dst, tmp));
 5819   ins_pipe(pipe_class_dummy);
 5820 %}
 5821 
 5822 
 5823 //----------Arithmetic Instructions--------------------------------------------
 5824 
 5825 // The rules are sorted by right operand type and operand length. Please keep
 5826 // it that way.
 5827 // Left operand type is always reg. Left operand len is I, L, P
 5828 // Right operand type is reg, imm, mem. Right operand len is S, I, L, P
 5829 // Special instruction formats, e.g. multi-operand, are inserted at the end.
 5830 
 5831 // ADD
 5832 
 5833 // REG = REG + REG
 5834 
 5835 // Register Addition
 5836 instruct addI_reg_reg_CISC(iRegI dst, iRegI src, flagsReg cr) %{
 5837   match(Set dst (AddI dst src));
 5838   effect(KILL cr);
 5839   // TODO: s390 port size(FIXED_SIZE);
 5840   format %{ &quot;AR      $dst,$src\t # int  CISC ALU&quot; %}
 5841   opcode(AR_ZOPC);
 5842   ins_encode(z_rrform(dst, src));
 5843   ins_pipe(pipe_class_dummy);
 5844 %}
 5845 
 5846 // Avoid use of LA(Y) for general ALU operation.
 5847 instruct addI_reg_reg_RISC(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 5848   match(Set dst (AddI src1 src2));
 5849   effect(KILL cr);
 5850   predicate(VM_Version::has_DistinctOpnds());
 5851   ins_cost(DEFAULT_COST);
 5852   size(4);
 5853   format %{ &quot;ARK     $dst,$src1,$src2\t # int  RISC ALU&quot; %}
 5854   opcode(ARK_ZOPC);
 5855   ins_encode(z_rrfform(dst, src1, src2));
 5856   ins_pipe(pipe_class_dummy);
 5857 %}
 5858 
 5859 // REG = REG + IMM
 5860 
 5861 // Avoid use of LA(Y) for general ALU operation.
 5862 // Immediate Addition
 5863 instruct addI_reg_imm16_CISC(iRegI dst, immI16 con, flagsReg cr) %{
 5864   match(Set dst (AddI dst con));
 5865   effect(KILL cr);
 5866   ins_cost(DEFAULT_COST);
 5867   // TODO: s390 port size(FIXED_SIZE);
 5868   format %{ &quot;AHI     $dst,$con\t # int  CISC ALU&quot; %}
 5869   opcode(AHI_ZOPC);
 5870   ins_encode(z_riform_signed(dst, con));
 5871   ins_pipe(pipe_class_dummy);
 5872 %}
 5873 
 5874 // Avoid use of LA(Y) for general ALU operation.
 5875 // Immediate Addition
 5876 instruct addI_reg_imm16_RISC(iRegI dst, iRegI src, immI16 con, flagsReg cr) %{
 5877   match(Set dst (AddI src con));
 5878   effect(KILL cr);
 5879   predicate( VM_Version::has_DistinctOpnds());
 5880   ins_cost(DEFAULT_COST);
 5881   // TODO: s390 port size(FIXED_SIZE);
 5882   format %{ &quot;AHIK    $dst,$src,$con\t # int  RISC ALU&quot; %}
 5883   opcode(AHIK_ZOPC);
 5884   ins_encode(z_rieform_d(dst, src, con));
 5885   ins_pipe(pipe_class_dummy);
 5886 %}
 5887 
 5888 // Immediate Addition
 5889 instruct addI_reg_imm32(iRegI dst, immI src, flagsReg cr) %{
 5890   match(Set dst (AddI dst src));
 5891   effect(KILL cr);
 5892   ins_cost(DEFAULT_COST_HIGH);
 5893   size(6);
 5894   format %{ &quot;AFI     $dst,$src&quot; %}
 5895   opcode(AFI_ZOPC);
 5896   ins_encode(z_rilform_signed(dst, src));
 5897   ins_pipe(pipe_class_dummy);
 5898 %}
 5899 
 5900 // Immediate Addition
 5901 instruct addI_reg_imm12(iRegI dst, iRegI src, uimmI12 con) %{
 5902   match(Set dst (AddI src con));
 5903   predicate(PreferLAoverADD);
 5904   ins_cost(DEFAULT_COST_LOW);
 5905   size(4);
 5906   format %{ &quot;LA      $dst,$con(,$src)\t # int d12(,b)&quot; %}
 5907   opcode(LA_ZOPC);
 5908   ins_encode(z_rxform_imm_reg(dst, con, src));
 5909   ins_pipe(pipe_class_dummy);
 5910 %}
 5911 
 5912 // Immediate Addition
 5913 instruct addI_reg_imm20(iRegI dst, iRegI src, immI20 con) %{
 5914   match(Set dst (AddI src con));
 5915   predicate(PreferLAoverADD);
 5916   ins_cost(DEFAULT_COST);
 5917   size(6);
 5918   format %{ &quot;LAY     $dst,$con(,$src)\t # int d20(,b)&quot; %}
 5919   opcode(LAY_ZOPC);
 5920   ins_encode(z_rxyform_imm_reg(dst, con, src));
 5921   ins_pipe(pipe_class_dummy);
 5922 %}
 5923 
 5924 instruct addI_reg_reg_imm12(iRegI dst, iRegI src1, iRegI src2, uimmI12 con) %{
 5925   match(Set dst (AddI (AddI src1 src2) con));
 5926   predicate( PreferLAoverADD);
 5927   ins_cost(DEFAULT_COST_LOW);
 5928   size(4);
 5929   format %{ &quot;LA      $dst,$con($src1,$src2)\t # int d12(x,b)&quot; %}
 5930   opcode(LA_ZOPC);
 5931   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 5932   ins_pipe(pipe_class_dummy);
 5933 %}
 5934 
 5935 instruct addI_reg_reg_imm20(iRegI dst, iRegI src1, iRegI src2, immI20 con) %{
 5936   match(Set dst (AddI (AddI src1 src2) con));
 5937   predicate(PreferLAoverADD);
 5938   ins_cost(DEFAULT_COST);
 5939   size(6);
 5940   format %{ &quot;LAY     $dst,$con($src1,$src2)\t # int d20(x,b)&quot; %}
 5941   opcode(LAY_ZOPC);
 5942   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 5943   ins_pipe(pipe_class_dummy);
 5944 %}
 5945 
 5946 // REG = REG + MEM
 5947 
 5948 instruct addI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 5949   match(Set dst (AddI dst (LoadI src)));
 5950   effect(KILL cr);
 5951   ins_cost(MEMORY_REF_COST);
 5952   // TODO: s390 port size(VARIABLE_SIZE);
 5953   format %{ &quot;A(Y)    $dst, $src\t # int&quot; %}
 5954   opcode(AY_ZOPC, A_ZOPC);
 5955   ins_encode(z_form_rt_mem_opt(dst, src));
 5956   ins_pipe(pipe_class_dummy);
 5957 %}
 5958 
 5959 // MEM = MEM + IMM
 5960 
 5961 // Add Immediate to 4-byte memory operand and result
 5962 instruct addI_mem_imm(memoryRSY mem, immI8 src, flagsReg cr) %{
 5963   match(Set mem (StoreI mem (AddI (LoadI mem) src)));
 5964   effect(KILL cr);
 5965   predicate(VM_Version::has_MemWithImmALUOps());
 5966   ins_cost(MEMORY_REF_COST);
 5967   size(6);
 5968   format %{ &quot;ASI     $mem,$src\t # direct mem add 4&quot; %}
 5969   opcode(ASI_ZOPC);
 5970   ins_encode(z_siyform(mem, src));
 5971   ins_pipe(pipe_class_dummy);
 5972 %}
 5973 
 5974 
 5975 //
 5976 
 5977 // REG = REG + REG
 5978 
 5979 instruct addL_reg_regI(iRegL dst, iRegI src, flagsReg cr) %{
 5980   match(Set dst (AddL dst (ConvI2L src)));
 5981   effect(KILL cr);
 5982   size(4);
 5983   format %{ &quot;AGFR    $dst,$src\t # long&lt;-int CISC ALU&quot; %}
 5984   opcode(AGFR_ZOPC);
 5985   ins_encode(z_rreform(dst, src));
 5986   ins_pipe(pipe_class_dummy);
 5987 %}
 5988 
 5989 instruct addL_reg_reg_CISC(iRegL dst, iRegL src, flagsReg cr) %{
 5990   match(Set dst (AddL dst src));
 5991   effect(KILL cr);
 5992   // TODO: s390 port size(FIXED_SIZE);
 5993   format %{ &quot;AGR     $dst, $src\t # long CISC ALU&quot; %}
 5994   opcode(AGR_ZOPC);
 5995   ins_encode(z_rreform(dst, src));
 5996   ins_pipe(pipe_class_dummy);
 5997 %}
 5998 
 5999 // Avoid use of LA(Y) for general ALU operation.
 6000 instruct addL_reg_reg_RISC(iRegL dst, iRegL src1, iRegL src2, flagsReg cr) %{
 6001   match(Set dst (AddL src1 src2));
 6002   effect(KILL cr);
 6003   predicate(VM_Version::has_DistinctOpnds());
 6004   ins_cost(DEFAULT_COST);
 6005   size(4);
 6006   format %{ &quot;AGRK    $dst,$src1,$src2\t # long RISC ALU&quot; %}
 6007   opcode(AGRK_ZOPC);
 6008   ins_encode(z_rrfform(dst, src1, src2));
 6009   ins_pipe(pipe_class_dummy);
 6010 %}
 6011 
 6012 // REG = REG + IMM
 6013 
 6014 instruct addL_reg_imm12(iRegL dst, iRegL src, uimmL12 con) %{
 6015   match(Set dst (AddL src con));
 6016   predicate( PreferLAoverADD);
 6017   ins_cost(DEFAULT_COST_LOW);
 6018   size(4);
 6019   format %{ &quot;LA      $dst,$con(,$src)\t # long d12(,b)&quot; %}
 6020   opcode(LA_ZOPC);
 6021   ins_encode(z_rxform_imm_reg(dst, con, src));
 6022   ins_pipe(pipe_class_dummy);
 6023 %}
 6024 
 6025 instruct addL_reg_imm20(iRegL dst, iRegL src, immL20 con) %{
 6026   match(Set dst (AddL src con));
 6027   predicate(PreferLAoverADD);
 6028   ins_cost(DEFAULT_COST);
 6029   size(6);
 6030   format %{ &quot;LAY     $dst,$con(,$src)\t # long d20(,b)&quot; %}
 6031   opcode(LAY_ZOPC);
 6032   ins_encode(z_rxyform_imm_reg(dst, con, src));
 6033   ins_pipe(pipe_class_dummy);
 6034 %}
 6035 
 6036 instruct addL_reg_imm32(iRegL dst, immL32 con, flagsReg cr) %{
 6037   match(Set dst (AddL dst con));
 6038   effect(KILL cr);
 6039   ins_cost(DEFAULT_COST_HIGH);
 6040   size(6);
 6041   format %{ &quot;AGFI    $dst,$con\t # long CISC ALU&quot; %}
 6042   opcode(AGFI_ZOPC);
 6043   ins_encode(z_rilform_signed(dst, con));
 6044   ins_pipe(pipe_class_dummy);
 6045 %}
 6046 
 6047 // Avoid use of LA(Y) for general ALU operation.
 6048 instruct addL_reg_imm16_CISC(iRegL dst, immL16 con, flagsReg cr) %{
 6049   match(Set dst (AddL dst con));
 6050   effect(KILL cr);
 6051   ins_cost(DEFAULT_COST);
 6052   // TODO: s390 port size(FIXED_SIZE);
 6053   format %{ &quot;AGHI    $dst,$con\t # long CISC ALU&quot; %}
 6054   opcode(AGHI_ZOPC);
 6055   ins_encode(z_riform_signed(dst, con));
 6056   ins_pipe(pipe_class_dummy);
 6057 %}
 6058 
 6059 // Avoid use of LA(Y) for general ALU operation.
 6060 instruct addL_reg_imm16_RISC(iRegL dst, iRegL src, immL16 con, flagsReg cr) %{
 6061   match(Set dst (AddL src con));
 6062   effect(KILL cr);
 6063   predicate( VM_Version::has_DistinctOpnds());
 6064   ins_cost(DEFAULT_COST);
 6065   size(6);
 6066   format %{ &quot;AGHIK   $dst,$src,$con\t # long RISC ALU&quot; %}
 6067   opcode(AGHIK_ZOPC);
 6068   ins_encode(z_rieform_d(dst, src, con));
 6069   ins_pipe(pipe_class_dummy);
 6070 %}
 6071 
 6072 // REG = REG + MEM
 6073 
 6074 instruct addL_Reg_memI(iRegL dst, memory src, flagsReg cr)%{
 6075   match(Set dst (AddL dst (ConvI2L (LoadI src))));
 6076   effect(KILL cr);
 6077   ins_cost(MEMORY_REF_COST);
 6078   size(Z_DISP3_SIZE);
 6079   format %{ &quot;AGF     $dst, $src\t # long/int&quot; %}
 6080   opcode(AGF_ZOPC, AGF_ZOPC);
 6081   ins_encode(z_form_rt_mem_opt(dst, src));
 6082   ins_pipe(pipe_class_dummy);
 6083 %}
 6084 
 6085 instruct addL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 6086   match(Set dst (AddL dst (LoadL src)));
 6087   effect(KILL cr);
 6088   ins_cost(MEMORY_REF_COST);
 6089   size(Z_DISP3_SIZE);
 6090   format %{ &quot;AG      $dst, $src\t # long&quot; %}
 6091   opcode(AG_ZOPC, AG_ZOPC);
 6092   ins_encode(z_form_rt_mem_opt(dst, src));
 6093   ins_pipe(pipe_class_dummy);
 6094 %}
 6095 
 6096 instruct addL_reg_reg_imm12(iRegL dst, iRegL src1, iRegL src2, uimmL12 con) %{
 6097   match(Set dst (AddL (AddL src1 src2) con));
 6098   predicate( PreferLAoverADD);
 6099   ins_cost(DEFAULT_COST_LOW);
 6100   size(4);
 6101   format %{ &quot;LA     $dst,$con($src1,$src2)\t # long d12(x,b)&quot; %}
 6102   opcode(LA_ZOPC);
 6103   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 6104   ins_pipe(pipe_class_dummy);
 6105 %}
 6106 
 6107 instruct addL_reg_reg_imm20(iRegL dst, iRegL src1, iRegL src2, immL20 con) %{
 6108   match(Set dst (AddL (AddL src1 src2) con));
 6109   predicate(PreferLAoverADD);
 6110   ins_cost(DEFAULT_COST);
 6111   size(6);
 6112   format %{ &quot;LAY    $dst,$con($src1,$src2)\t # long d20(x,b)&quot; %}
 6113   opcode(LAY_ZOPC);
 6114   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 6115   ins_pipe(pipe_class_dummy);
 6116 %}
 6117 
 6118 // MEM = MEM + IMM
 6119 
 6120 // Add Immediate to 8-byte memory operand and result.
 6121 instruct addL_mem_imm(memoryRSY mem, immL8 src, flagsReg cr) %{
 6122   match(Set mem (StoreL mem (AddL (LoadL mem) src)));
 6123   effect(KILL cr);
 6124   predicate(VM_Version::has_MemWithImmALUOps());
 6125   ins_cost(MEMORY_REF_COST);
 6126   size(6);
 6127   format %{ &quot;AGSI    $mem,$src\t # direct mem add 8&quot; %}
 6128   opcode(AGSI_ZOPC);
 6129   ins_encode(z_siyform(mem, src));
 6130   ins_pipe(pipe_class_dummy);
 6131 %}
 6132 
 6133 
 6134 // REG = REG + REG
 6135 
 6136 // Ptr Addition
 6137 instruct addP_reg_reg_LA(iRegP dst, iRegP_N2P src1, iRegL src2) %{
 6138   match(Set dst (AddP src1 src2));
 6139   predicate( PreferLAoverADD);
 6140   ins_cost(DEFAULT_COST);
 6141   size(4);
 6142   format %{ &quot;LA      $dst,#0($src1,$src2)\t # ptr 0(x,b)&quot; %}
 6143   opcode(LA_ZOPC);
 6144   ins_encode(z_rxform_imm_reg_reg(dst, 0x0, src1, src2));
 6145   ins_pipe(pipe_class_dummy);
 6146 %}
 6147 
 6148 // Ptr Addition
 6149 // Avoid use of LA(Y) for general ALU operation.
 6150 instruct addP_reg_reg_CISC(iRegP dst, iRegL src, flagsReg cr) %{
 6151   match(Set dst (AddP dst src));
 6152   effect(KILL cr);
 6153   predicate(!PreferLAoverADD &amp;&amp; !VM_Version::has_DistinctOpnds());
 6154   ins_cost(DEFAULT_COST);
 6155   // TODO: s390 port size(FIXED_SIZE);
 6156   format %{ &quot;ALGR    $dst,$src\t # ptr CICS ALU&quot; %}
 6157   opcode(ALGR_ZOPC);
 6158   ins_encode(z_rreform(dst, src));
 6159   ins_pipe(pipe_class_dummy);
 6160 %}
 6161 
 6162 // Ptr Addition
 6163 // Avoid use of LA(Y) for general ALU operation.
 6164 instruct addP_reg_reg_RISC(iRegP dst, iRegP_N2P src1, iRegL src2, flagsReg cr) %{
 6165   match(Set dst (AddP src1 src2));
 6166   effect(KILL cr);
 6167   predicate(!PreferLAoverADD &amp;&amp; VM_Version::has_DistinctOpnds());
 6168   ins_cost(DEFAULT_COST);
 6169   // TODO: s390 port size(FIXED_SIZE);
 6170   format %{ &quot;ALGRK   $dst,$src1,$src2\t # ptr RISC ALU&quot; %}
 6171   opcode(ALGRK_ZOPC);
 6172   ins_encode(z_rrfform(dst, src1, src2));
 6173   ins_pipe(pipe_class_dummy);
 6174 %}
 6175 
 6176 // REG = REG + IMM
 6177 
 6178 instruct addP_reg_imm12(iRegP dst, iRegP_N2P src, uimmL12 con) %{
 6179   match(Set dst (AddP src con));
 6180   predicate( PreferLAoverADD);
 6181   ins_cost(DEFAULT_COST_LOW);
 6182   size(4);
 6183   format %{ &quot;LA      $dst,$con(,$src)\t # ptr d12(,b)&quot; %}
 6184   opcode(LA_ZOPC);
 6185   ins_encode(z_rxform_imm_reg(dst, con, src));
 6186   ins_pipe(pipe_class_dummy);
 6187 %}
 6188 
 6189 // Avoid use of LA(Y) for general ALU operation.
 6190 instruct addP_reg_imm16_CISC(iRegP dst, immL16 src, flagsReg cr) %{
 6191   match(Set dst (AddP dst src));
 6192   effect(KILL cr);
 6193   predicate(!PreferLAoverADD &amp;&amp; !VM_Version::has_DistinctOpnds());
 6194   ins_cost(DEFAULT_COST);
 6195   // TODO: s390 port size(FIXED_SIZE);
 6196   format %{ &quot;AGHI    $dst,$src\t # ptr CISC ALU&quot; %}
 6197   opcode(AGHI_ZOPC);
 6198   ins_encode(z_riform_signed(dst, src));
 6199   ins_pipe(pipe_class_dummy);
 6200 %}
 6201 
 6202 // Avoid use of LA(Y) for general ALU operation.
 6203 instruct addP_reg_imm16_RISC(iRegP dst, iRegP_N2P src, immL16 con, flagsReg cr) %{
 6204   match(Set dst (AddP src con));
 6205   effect(KILL cr);
 6206   predicate(!PreferLAoverADD &amp;&amp; VM_Version::has_DistinctOpnds());
 6207   ins_cost(DEFAULT_COST);
 6208   // TODO: s390 port size(FIXED_SIZE);
 6209   format %{ &quot;ALGHSIK $dst,$src,$con\t # ptr RISC ALU&quot; %}
 6210   opcode(ALGHSIK_ZOPC);
 6211   ins_encode(z_rieform_d(dst, src, con));
 6212   ins_pipe(pipe_class_dummy);
 6213 %}
 6214 
 6215 instruct addP_reg_imm20(iRegP dst, memoryRegP src, immL20 con) %{
 6216   match(Set dst (AddP src con));
 6217   predicate(PreferLAoverADD);
 6218   ins_cost(DEFAULT_COST);
 6219   size(6);
 6220   format %{ &quot;LAY     $dst,$con(,$src)\t # ptr d20(,b)&quot; %}
 6221   opcode(LAY_ZOPC);
 6222   ins_encode(z_rxyform_imm_reg(dst, con, src));
 6223   ins_pipe(pipe_class_dummy);
 6224 %}
 6225 
 6226 // Pointer Immediate Addition
 6227 instruct addP_reg_imm32(iRegP dst, immL32 src, flagsReg cr) %{
 6228   match(Set dst (AddP dst src));
 6229   effect(KILL cr);
 6230   ins_cost(DEFAULT_COST_HIGH);
 6231   // TODO: s390 port size(FIXED_SIZE);
 6232   format %{ &quot;AGFI    $dst,$src\t # ptr&quot; %}
 6233   opcode(AGFI_ZOPC);
 6234   ins_encode(z_rilform_signed(dst, src));
 6235   ins_pipe(pipe_class_dummy);
 6236 %}
 6237 
 6238 // REG = REG1 + REG2 + IMM
 6239 
 6240 instruct addP_reg_reg_imm12(iRegP dst, memoryRegP src1, iRegL src2, uimmL12 con) %{
 6241   match(Set dst (AddP (AddP src1 src2) con));
 6242   predicate( PreferLAoverADD);
 6243   ins_cost(DEFAULT_COST_LOW);
 6244   size(4);
 6245   format %{ &quot;LA      $dst,$con($src1,$src2)\t # ptr d12(x,b)&quot; %}
 6246   opcode(LA_ZOPC);
 6247   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 6248   ins_pipe(pipe_class_dummy);
 6249 %}
 6250 
 6251 instruct addP_regN_reg_imm12(iRegP dst, iRegP_N2P src1, iRegL src2, uimmL12 con) %{
 6252   match(Set dst (AddP (AddP src1 src2) con));
 6253   predicate( PreferLAoverADD &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0);
 6254   ins_cost(DEFAULT_COST_LOW);
 6255   size(4);
 6256   format %{ &quot;LA      $dst,$con($src1,$src2)\t # ptr d12(x,b)&quot; %}
 6257   opcode(LA_ZOPC);
 6258   ins_encode(z_rxform_imm_reg_reg(dst, con, src1, src2));
 6259   ins_pipe(pipe_class_dummy);
 6260 %}
 6261 
 6262 instruct addP_reg_reg_imm20(iRegP dst, memoryRegP src1, iRegL src2, immL20 con) %{
 6263   match(Set dst (AddP (AddP src1 src2) con));
 6264   predicate(PreferLAoverADD);
 6265   ins_cost(DEFAULT_COST);
 6266   // TODO: s390 port size(FIXED_SIZE);
 6267   format %{ &quot;LAY     $dst,$con($src1,$src2)\t # ptr d20(x,b)&quot; %}
 6268   opcode(LAY_ZOPC);
 6269   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 6270   ins_pipe(pipe_class_dummy);
 6271 %}
 6272 
 6273 instruct addP_regN_reg_imm20(iRegP dst, iRegP_N2P src1, iRegL src2, immL20 con) %{
 6274   match(Set dst (AddP (AddP src1 src2) con));
 6275   predicate( PreferLAoverADD &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0);
 6276   ins_cost(DEFAULT_COST);
 6277   // TODO: s390 port size(FIXED_SIZE);
 6278   format %{ &quot;LAY     $dst,$con($src1,$src2)\t # ptr d20(x,b)&quot; %}
 6279   opcode(LAY_ZOPC);
 6280   ins_encode(z_rxyform_imm_reg_reg(dst, con, src1, src2));
 6281   ins_pipe(pipe_class_dummy);
 6282 %}
 6283 
 6284 // MEM = MEM + IMM
 6285 
 6286 // Add Immediate to 8-byte memory operand and result
 6287 instruct addP_mem_imm(memoryRSY mem, immL8 src, flagsReg cr) %{
 6288   match(Set mem (StoreP mem (AddP (LoadP mem) src)));
 6289   effect(KILL cr);
 6290   predicate(VM_Version::has_MemWithImmALUOps());
 6291   ins_cost(MEMORY_REF_COST);
 6292   size(6);
 6293   format %{ &quot;AGSI    $mem,$src\t # direct mem add 8 (ptr)&quot; %}
 6294   opcode(AGSI_ZOPC);
 6295   ins_encode(z_siyform(mem, src));
 6296   ins_pipe(pipe_class_dummy);
 6297 %}
 6298 
 6299 // SUB
 6300 
 6301 // Register Subtraction
 6302 instruct subI_reg_reg_CISC(iRegI dst, iRegI src, flagsReg cr) %{
 6303   match(Set dst (SubI dst src));
 6304   effect(KILL cr);
 6305   // TODO: s390 port size(FIXED_SIZE);
 6306   format %{ &quot;SR      $dst,$src\t # int  CISC ALU&quot; %}
 6307   opcode(SR_ZOPC);
 6308   ins_encode(z_rrform(dst, src));
 6309   ins_pipe(pipe_class_dummy);
 6310 %}
 6311 
 6312 instruct subI_reg_reg_RISC(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 6313   match(Set dst (SubI src1 src2));
 6314   effect(KILL cr);
 6315   predicate(VM_Version::has_DistinctOpnds());
 6316   ins_cost(DEFAULT_COST);
 6317   size(4);
 6318   format %{ &quot;SRK     $dst,$src1,$src2\t # int  RISC ALU&quot; %}
 6319   opcode(SRK_ZOPC);
 6320   ins_encode(z_rrfform(dst, src1, src2));
 6321   ins_pipe(pipe_class_dummy);
 6322 %}
 6323 
 6324 instruct subI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 6325   match(Set dst (SubI dst (LoadI src)));
 6326   effect(KILL cr);
 6327   ins_cost(MEMORY_REF_COST);
 6328   // TODO: s390 port size(VARIABLE_SIZE);
 6329   format %{ &quot;S(Y)    $dst, $src\t # int&quot; %}
 6330   opcode(SY_ZOPC, S_ZOPC);
 6331   ins_encode(z_form_rt_mem_opt(dst, src));
 6332   ins_pipe(pipe_class_dummy);
 6333 %}
 6334 
 6335 instruct subI_zero_reg(iRegI dst, immI_0 zero, iRegI src, flagsReg cr) %{
 6336   match(Set dst (SubI zero src));
 6337   effect(KILL cr);
 6338   size(2);
 6339   format %{ &quot;NEG     $dst, $src&quot; %}
 6340   ins_encode %{ __ z_lcr($dst$$Register, $src$$Register); %}
 6341   ins_pipe(pipe_class_dummy);
 6342 %}
 6343 
 6344 //
 6345 
 6346 // Long subtraction
 6347 instruct subL_reg_reg_CISC(iRegL dst, iRegL src, flagsReg cr) %{
 6348   match(Set dst (SubL dst src));
 6349   effect(KILL cr);
 6350   // TODO: s390 port size(FIXED_SIZE);
 6351   format %{ &quot;SGR     $dst,$src\t # int  CISC ALU&quot; %}
 6352   opcode(SGR_ZOPC);
 6353   ins_encode(z_rreform(dst, src));
 6354   ins_pipe(pipe_class_dummy);
 6355 %}
 6356 
 6357 // Avoid use of LA(Y) for general ALU operation.
 6358 instruct subL_reg_reg_RISC(iRegL dst, iRegL src1, iRegL src2, flagsReg cr) %{
 6359   match(Set dst (SubL src1 src2));
 6360   effect(KILL cr);
 6361   predicate(VM_Version::has_DistinctOpnds());
 6362   ins_cost(DEFAULT_COST);
 6363   size(4);
 6364   format %{ &quot;SGRK    $dst,$src1,$src2\t # int  RISC ALU&quot; %}
 6365   opcode(SGRK_ZOPC);
 6366   ins_encode(z_rrfform(dst, src1, src2));
 6367   ins_pipe(pipe_class_dummy);
 6368 %}
 6369 
 6370 instruct subL_reg_regI_CISC(iRegL dst, iRegI src, flagsReg cr) %{
 6371   match(Set dst (SubL dst (ConvI2L src)));
 6372   effect(KILL cr);
 6373   size(4);
 6374   format %{ &quot;SGFR    $dst, $src\t # int  CISC ALU&quot; %}
 6375   opcode(SGFR_ZOPC);
 6376   ins_encode(z_rreform(dst, src));
 6377   ins_pipe(pipe_class_dummy);
 6378 %}
 6379 
 6380 instruct subL_Reg_memI(iRegL dst, memory src, flagsReg cr)%{
 6381   match(Set dst (SubL dst (ConvI2L (LoadI src))));
 6382   effect(KILL cr);
 6383   ins_cost(MEMORY_REF_COST);
 6384   size(Z_DISP3_SIZE);
 6385   format %{ &quot;SGF     $dst, $src\t # long/int&quot; %}
 6386   opcode(SGF_ZOPC, SGF_ZOPC);
 6387   ins_encode(z_form_rt_mem_opt(dst, src));
 6388   ins_pipe(pipe_class_dummy);
 6389 %}
 6390 
 6391 instruct subL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 6392   match(Set dst (SubL dst (LoadL src)));
 6393   effect(KILL cr);
 6394   ins_cost(MEMORY_REF_COST);
 6395   size(Z_DISP3_SIZE);
 6396   format %{ &quot;SG      $dst, $src\t # long&quot; %}
 6397   opcode(SG_ZOPC, SG_ZOPC);
 6398   ins_encode(z_form_rt_mem_opt(dst, src));
 6399   ins_pipe(pipe_class_dummy);
 6400 %}
 6401 
 6402 // Moved declaration of negL_reg_reg before encode nodes, where it is used.
 6403 
 6404 //  MUL
 6405 
 6406 // Register Multiplication
 6407 instruct mulI_reg_reg(iRegI dst, iRegI src) %{
 6408   match(Set dst (MulI dst src));
 6409   ins_cost(DEFAULT_COST);
 6410   size(4);
 6411   format %{ &quot;MSR     $dst, $src&quot; %}
 6412   opcode(MSR_ZOPC);
 6413   ins_encode(z_rreform(dst, src));
 6414   ins_pipe(pipe_class_dummy);
 6415 %}
 6416 
 6417 // Immediate Multiplication
 6418 instruct mulI_reg_imm16(iRegI dst, immI16 con) %{
 6419   match(Set dst (MulI dst con));
 6420   ins_cost(DEFAULT_COST);
 6421   // TODO: s390 port size(FIXED_SIZE);
 6422   format %{ &quot;MHI     $dst,$con&quot; %}
 6423   opcode(MHI_ZOPC);
 6424   ins_encode(z_riform_signed(dst,con));
 6425   ins_pipe(pipe_class_dummy);
 6426 %}
 6427 
 6428 // Immediate (32bit) Multiplication
 6429 instruct mulI_reg_imm32(iRegI dst, immI con) %{
 6430   match(Set dst (MulI dst con));
 6431   ins_cost(DEFAULT_COST);
 6432   size(6);
 6433   format %{ &quot;MSFI    $dst,$con&quot; %}
 6434   opcode(MSFI_ZOPC);
 6435   ins_encode(z_rilform_signed(dst,con));
 6436   ins_pipe(pipe_class_dummy);
 6437 %}
 6438 
 6439 instruct mulI_Reg_mem(iRegI dst, memory src)%{
 6440   match(Set dst (MulI dst (LoadI src)));
 6441   ins_cost(MEMORY_REF_COST);
 6442   // TODO: s390 port size(VARIABLE_SIZE);
 6443   format %{ &quot;MS(Y)   $dst, $src\t # int&quot; %}
 6444   opcode(MSY_ZOPC, MS_ZOPC);
 6445   ins_encode(z_form_rt_mem_opt(dst, src));
 6446   ins_pipe(pipe_class_dummy);
 6447 %}
 6448 
 6449 //
 6450 
 6451 instruct mulL_reg_regI(iRegL dst, iRegI src) %{
 6452   match(Set dst (MulL dst (ConvI2L src)));
 6453   ins_cost(DEFAULT_COST);
 6454   // TODO: s390 port size(FIXED_SIZE);
 6455   format %{ &quot;MSGFR   $dst $src\t # long/int&quot; %}
 6456   opcode(MSGFR_ZOPC);
 6457   ins_encode(z_rreform(dst, src));
 6458   ins_pipe(pipe_class_dummy);
 6459 %}
 6460 
 6461 instruct mulL_reg_reg(iRegL dst, iRegL src) %{
 6462   match(Set dst (MulL dst src));
 6463   ins_cost(DEFAULT_COST);
 6464   size(4);
 6465   format %{ &quot;MSGR    $dst $src\t # long&quot; %}
 6466   opcode(MSGR_ZOPC);
 6467   ins_encode(z_rreform(dst, src));
 6468   ins_pipe(pipe_class_dummy);
 6469 %}
 6470 
 6471 // Immediate Multiplication
 6472 instruct mulL_reg_imm16(iRegL dst, immL16 src) %{
 6473   match(Set dst (MulL dst src));
 6474   ins_cost(DEFAULT_COST);
 6475   // TODO: s390 port size(FIXED_SIZE);
 6476   format %{ &quot;MGHI    $dst,$src\t # long&quot; %}
 6477   opcode(MGHI_ZOPC);
 6478   ins_encode(z_riform_signed(dst, src));
 6479   ins_pipe(pipe_class_dummy);
 6480 %}
 6481 
 6482 // Immediate (32bit) Multiplication
 6483 instruct mulL_reg_imm32(iRegL dst, immL32 con) %{
 6484   match(Set dst (MulL dst con));
 6485   ins_cost(DEFAULT_COST);
 6486   size(6);
 6487   format %{ &quot;MSGFI   $dst,$con&quot; %}
 6488   opcode(MSGFI_ZOPC);
 6489   ins_encode(z_rilform_signed(dst,con));
 6490   ins_pipe(pipe_class_dummy);
 6491 %}
 6492 
 6493 instruct mulL_Reg_memI(iRegL dst, memory src)%{
 6494   match(Set dst (MulL dst (ConvI2L (LoadI src))));
 6495   ins_cost(MEMORY_REF_COST);
 6496   size(Z_DISP3_SIZE);
 6497   format %{ &quot;MSGF    $dst, $src\t # long&quot; %}
 6498   opcode(MSGF_ZOPC, MSGF_ZOPC);
 6499   ins_encode(z_form_rt_mem_opt(dst, src));
 6500   ins_pipe(pipe_class_dummy);
 6501 %}
 6502 
 6503 instruct mulL_Reg_mem(iRegL dst, memory src)%{
 6504   match(Set dst (MulL dst (LoadL src)));
 6505   ins_cost(MEMORY_REF_COST);
 6506   size(Z_DISP3_SIZE);
 6507   format %{ &quot;MSG     $dst, $src\t # long&quot; %}
 6508   opcode(MSG_ZOPC, MSG_ZOPC);
 6509   ins_encode(z_form_rt_mem_opt(dst, src));
 6510   ins_pipe(pipe_class_dummy);
 6511 %}
 6512 
 6513 instruct mulHiL_reg_reg(revenRegL Rdst, roddRegL Rsrc1, iRegL Rsrc2, iRegL Rtmp1, flagsReg cr)%{
 6514   match(Set Rdst (MulHiL Rsrc1 Rsrc2));
 6515   effect(TEMP_DEF Rdst, USE_KILL Rsrc1, TEMP Rtmp1, KILL cr);
 6516   ins_cost(7*DEFAULT_COST);
 6517   // TODO: s390 port size(VARIABLE_SIZE);
 6518   format %{ &quot;MulHiL  $Rdst, $Rsrc1, $Rsrc2\t # Multiply High Long&quot; %}
 6519   ins_encode%{
 6520     Register dst  = $Rdst$$Register;
 6521     Register src1 = $Rsrc1$$Register;
 6522     Register src2 = $Rsrc2$$Register;
 6523     Register tmp1 = $Rtmp1$$Register;
 6524     Register tmp2 = $Rdst$$Register;
 6525     // z/Architecture has only unsigned multiply (64 * 64 -&gt; 128).
 6526     // implementing mulhs(a,b) = mulhu(a,b) – (a &amp; (b&gt;&gt;63)) – (b &amp; (a&gt;&gt;63))
 6527     __ z_srag(tmp2, src1, 63);  // a&gt;&gt;63
 6528     __ z_srag(tmp1, src2, 63);  // b&gt;&gt;63
 6529     __ z_ngr(tmp2, src2);       // b &amp; (a&gt;&gt;63)
 6530     __ z_ngr(tmp1, src1);       // a &amp; (b&gt;&gt;63)
 6531     __ z_agr(tmp1, tmp2);       // ((a &amp; (b&gt;&gt;63)) + (b &amp; (a&gt;&gt;63)))
 6532     __ z_mlgr(dst, src2);       // tricky: 128-bit product is written to even/odd pair (dst,src1),
 6533                                 //         multiplicand is taken from oddReg (src1), multiplier in src2.
 6534     __ z_sgr(dst, tmp1);
 6535   %}
 6536   ins_pipe(pipe_class_dummy);
 6537 %}
 6538 
 6539 //  DIV
 6540 
 6541 // Integer DIVMOD with Register, both quotient and mod results
 6542 instruct divModI_reg_divmod(roddRegI dst1src1, revenRegI dst2, noOdd_iRegI src2, flagsReg cr) %{
 6543   match(DivModI dst1src1 src2);
 6544   effect(KILL cr);
 6545   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6546   size((VM_Version::has_CompareBranch() ? 24 : 26));
 6547   format %{ &quot;DIVMODI ($dst1src1, $dst2) $src2&quot; %}
 6548   ins_encode %{
 6549     Register d1s1 = $dst1src1$$Register;
 6550     Register d2   = $dst2$$Register;
 6551     Register s2   = $src2$$Register;
 6552 
 6553     assert_different_registers(d1s1, s2);
 6554 
 6555     Label do_div, done_div;
 6556     if (VM_Version::has_CompareBranch()) {
 6557       __ z_cij(s2, -1, Assembler::bcondNotEqual, do_div);
 6558     } else {
 6559       __ z_chi(s2, -1);
 6560       __ z_brne(do_div);
 6561     }
 6562     __ z_lcr(d1s1, d1s1);
 6563     __ clear_reg(d2, false, false);
 6564     __ z_bru(done_div);
 6565     __ bind(do_div);
 6566     __ z_lgfr(d1s1, d1s1);
 6567     __ z_dsgfr(d2, s2);
 6568     __ bind(done_div);
 6569   %}
 6570   ins_pipe(pipe_class_dummy);
 6571 %}
 6572 
 6573 
 6574 // Register Division
 6575 instruct divI_reg_reg(roddRegI dst, iRegI src1, noOdd_iRegI src2, revenRegI tmp, flagsReg cr) %{
 6576   match(Set dst (DivI src1 src2));
 6577   effect(KILL tmp, KILL cr);
 6578   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6579   size((VM_Version::has_CompareBranch() ? 20 : 22));
 6580   format %{ &quot;DIV_checked $dst, $src1,$src2\t # treats special case 0x80../-1&quot; %}
 6581   ins_encode %{
 6582     Register a = $src1$$Register;
 6583     Register b = $src2$$Register;
 6584     Register t = $dst$$Register;
 6585 
 6586     assert_different_registers(t, b);
 6587 
 6588     Label do_div, done_div;
 6589     if (VM_Version::has_CompareBranch()) {
 6590       __ z_cij(b, -1, Assembler::bcondNotEqual, do_div);
 6591     } else {
 6592       __ z_chi(b, -1);
 6593       __ z_brne(do_div);
 6594     }
 6595     __ z_lcr(t, a);
 6596     __ z_bru(done_div);
 6597     __ bind(do_div);
 6598     __ z_lgfr(t, a);
 6599     __ z_dsgfr(t-&gt;predecessor()/* t is odd part of a register pair. */, b);
 6600     __ bind(done_div);
 6601   %}
 6602   ins_pipe(pipe_class_dummy);
 6603 %}
 6604 
 6605 // Immediate Division
 6606 instruct divI_reg_imm16(roddRegI dst, iRegI src1, immI16 src2, revenRegI tmp, flagsReg cr) %{
 6607   match(Set dst (DivI src1 src2));
 6608   effect(KILL tmp, KILL cr);  // R0 is killed, too.
 6609   ins_cost(2 * DEFAULT_COST);
 6610   // TODO: s390 port size(VARIABLE_SIZE);
 6611   format %{ &quot;DIV_const  $dst,$src1,$src2&quot; %}
 6612   ins_encode %{
 6613     // No sign extension of Rdividend needed here.
 6614     if ($src2$$constant != -1) {
 6615       __ z_lghi(Z_R0_scratch, $src2$$constant);
 6616       __ z_lgfr($dst$$Register, $src1$$Register);
 6617       __ z_dsgfr($dst$$Register-&gt;predecessor()/* Dst is odd part of a register pair. */, Z_R0_scratch);
 6618     } else {
 6619       __ z_lcr($dst$$Register, $src1$$Register);
 6620     }
 6621   %}
 6622   ins_pipe(pipe_class_dummy);
 6623 %}
 6624 
 6625 // Long DIVMOD with Register, both quotient and mod results
 6626 instruct divModL_reg_divmod(roddRegL dst1src1, revenRegL dst2, iRegL src2, flagsReg cr) %{
 6627   match(DivModL dst1src1 src2);
 6628   effect(KILL cr);
 6629   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6630   size((VM_Version::has_CompareBranch() ? 22 : 24));
 6631   format %{ &quot;DIVMODL ($dst1src1, $dst2) $src2&quot; %}
 6632   ins_encode %{
 6633     Register d1s1 = $dst1src1$$Register;
 6634     Register d2   = $dst2$$Register;
 6635     Register s2   = $src2$$Register;
 6636 
 6637     Label do_div, done_div;
 6638     if (VM_Version::has_CompareBranch()) {
 6639       __ z_cgij(s2, -1, Assembler::bcondNotEqual, do_div);
 6640     } else {
 6641       __ z_cghi(s2, -1);
 6642       __ z_brne(do_div);
 6643     }
 6644     __ z_lcgr(d1s1, d1s1);
 6645     // indicate unused result
 6646     (void) __ clear_reg(d2, true, false);
 6647     __ z_bru(done_div);
 6648     __ bind(do_div);
 6649     __ z_dsgr(d2, s2);
 6650     __ bind(done_div);
 6651   %}
 6652   ins_pipe(pipe_class_dummy);
 6653 %}
 6654 
 6655 // Register Long Division
 6656 instruct divL_reg_reg(roddRegL dst, iRegL src, revenRegL tmp, flagsReg cr) %{
 6657   match(Set dst (DivL dst src));
 6658   effect(KILL tmp, KILL cr);
 6659   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6660   size((VM_Version::has_CompareBranch() ? 18 : 20));
 6661   format %{ &quot;DIVG_checked  $dst, $src\t # long, treats special case 0x80../-1&quot; %}
 6662   ins_encode %{
 6663     Register b = $src$$Register;
 6664     Register t = $dst$$Register;
 6665 
 6666     Label done_div;
 6667     __ z_lcgr(t, t);    // Does no harm. divisor is in other register.
 6668     if (VM_Version::has_CompareBranch()) {
 6669       __ z_cgij(b, -1, Assembler::bcondEqual, done_div);
 6670     } else {
 6671       __ z_cghi(b, -1);
 6672       __ z_bre(done_div);
 6673     }
 6674     __ z_lcgr(t, t);    // Restore sign.
 6675     __ z_dsgr(t-&gt;predecessor()/* t is odd part of a register pair. */, b);
 6676     __ bind(done_div);
 6677   %}
 6678   ins_pipe(pipe_class_dummy);
 6679 %}
 6680 
 6681 // Immediate Long Division
 6682 instruct divL_reg_imm16(roddRegL dst, iRegL src1, immL16 src2, revenRegL tmp, flagsReg cr) %{
 6683   match(Set dst (DivL src1 src2));
 6684   effect(KILL tmp, KILL cr);  // R0 is killed, too.
 6685   ins_cost(2 * DEFAULT_COST);
 6686   // TODO: s390 port size(VARIABLE_SIZE);
 6687   format %{ &quot;DIVG_const  $dst,$src1,$src2\t # long&quot; %}
 6688   ins_encode %{
 6689     if ($src2$$constant != -1) {
 6690       __ z_lghi(Z_R0_scratch, $src2$$constant);
 6691       __ lgr_if_needed($dst$$Register, $src1$$Register);
 6692       __ z_dsgr($dst$$Register-&gt;predecessor()/* Dst is odd part of a register pair. */, Z_R0_scratch);
 6693     } else {
 6694       __ z_lcgr($dst$$Register, $src1$$Register);
 6695     }
 6696   %}
 6697   ins_pipe(pipe_class_dummy);
 6698 %}
 6699 
 6700 // REM
 6701 
 6702 // Integer Remainder
 6703 // Register Remainder
 6704 instruct modI_reg_reg(revenRegI dst, iRegI src1, noOdd_iRegI src2, roddRegI tmp, flagsReg cr) %{
 6705   match(Set dst (ModI src1 src2));
 6706   effect(KILL tmp, KILL cr);
 6707   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6708   // TODO: s390 port size(VARIABLE_SIZE);
 6709   format %{ &quot;MOD_checked   $dst,$src1,$src2&quot; %}
 6710   ins_encode %{
 6711     Register a = $src1$$Register;
 6712     Register b = $src2$$Register;
 6713     Register t = $dst$$Register;
 6714     assert_different_registers(t-&gt;successor(), b);
 6715 
 6716     Label do_div, done_div;
 6717 
 6718     if ((t-&gt;encoding() != b-&gt;encoding()) &amp;&amp; (t-&gt;encoding() != a-&gt;encoding())) {
 6719       (void) __ clear_reg(t, true, false);  // Does no harm. Operands are in other regs.
 6720       if (VM_Version::has_CompareBranch()) {
 6721         __ z_cij(b, -1, Assembler::bcondEqual, done_div);
 6722       } else {
 6723         __ z_chi(b, -1);
 6724         __ z_bre(done_div);
 6725       }
 6726       __ z_lgfr(t-&gt;successor(), a);
 6727       __ z_dsgfr(t/* t is even part of a register pair. */, b);
 6728     } else {
 6729       if (VM_Version::has_CompareBranch()) {
 6730         __ z_cij(b, -1, Assembler::bcondNotEqual, do_div);
 6731       } else {
 6732         __ z_chi(b, -1);
 6733         __ z_brne(do_div);
 6734       }
 6735       __ clear_reg(t, true, false);
 6736       __ z_bru(done_div);
 6737       __ bind(do_div);
 6738       __ z_lgfr(t-&gt;successor(), a);
 6739       __ z_dsgfr(t/* t is even part of a register pair. */, b);
 6740     }
 6741     __ bind(done_div);
 6742   %}
 6743   ins_pipe(pipe_class_dummy);
 6744 %}
 6745 
 6746 // Immediate Remainder
 6747 instruct modI_reg_imm16(revenRegI dst, iRegI src1, immI16 src2, roddRegI tmp, flagsReg cr) %{
 6748   match(Set dst (ModI src1 src2));
 6749   effect(KILL tmp, KILL cr); // R0 is killed, too.
 6750   ins_cost(3 * DEFAULT_COST);
 6751   // TODO: s390 port size(VARIABLE_SIZE);
 6752   format %{ &quot;MOD_const  $dst,src1,$src2&quot; %}
 6753   ins_encode %{
 6754     assert_different_registers($dst$$Register, $src1$$Register);
 6755     assert_different_registers($dst$$Register-&gt;successor(), $src1$$Register);
 6756     int divisor = $src2$$constant;
 6757 
 6758     if (divisor != -1) {
 6759       __ z_lghi(Z_R0_scratch, divisor);
 6760       __ z_lgfr($dst$$Register-&gt;successor(), $src1$$Register);
 6761       __ z_dsgfr($dst$$Register/* Dst is even part of a register pair. */, Z_R0_scratch); // Instruction kills tmp.
 6762     } else {
 6763       __ clear_reg($dst$$Register, true, false);
 6764     }
 6765   %}
 6766   ins_pipe(pipe_class_dummy);
 6767 %}
 6768 
 6769 // Register Long Remainder
 6770 instruct modL_reg_reg(revenRegL dst, roddRegL src1, iRegL src2, flagsReg cr) %{
 6771   match(Set dst (ModL src1 src2));
 6772   effect(KILL src1, KILL cr); // R0 is killed, too.
 6773   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 6774   // TODO: s390 port size(VARIABLE_SIZE);
 6775   format %{ &quot;MODG_checked   $dst,$src1,$src2&quot; %}
 6776   ins_encode %{
 6777     Register a = $src1$$Register;
 6778     Register b = $src2$$Register;
 6779     Register t = $dst$$Register;
 6780     assert(t-&gt;successor() == a, &quot;(t,a) is an even-odd pair&quot; );
 6781 
 6782     Label do_div, done_div;
 6783     if (t-&gt;encoding() != b-&gt;encoding()) {
 6784       (void) __ clear_reg(t, true, false); // Does no harm. Dividend is in successor.
 6785       if (VM_Version::has_CompareBranch()) {
 6786         __ z_cgij(b, -1, Assembler::bcondEqual, done_div);
 6787       } else {
 6788         __ z_cghi(b, -1);
 6789         __ z_bre(done_div);
 6790       }
 6791       __ z_dsgr(t, b);
 6792     } else {
 6793       if (VM_Version::has_CompareBranch()) {
 6794         __ z_cgij(b, -1, Assembler::bcondNotEqual, do_div);
 6795       } else {
 6796         __ z_cghi(b, -1);
 6797         __ z_brne(do_div);
 6798       }
 6799       __ clear_reg(t, true, false);
 6800       __ z_bru(done_div);
 6801       __ bind(do_div);
 6802       __ z_dsgr(t, b);
 6803     }
 6804     __ bind(done_div);
 6805   %}
 6806   ins_pipe(pipe_class_dummy);
 6807 %}
 6808 
 6809 // Register Long Remainder
 6810 instruct modL_reg_imm16(revenRegL dst, iRegL src1, immL16 src2, roddRegL tmp, flagsReg cr) %{
 6811   match(Set dst (ModL src1 src2));
 6812   effect(KILL tmp, KILL cr); // R0 is killed, too.
 6813   ins_cost(3 * DEFAULT_COST);
 6814   // TODO: s390 port size(VARIABLE_SIZE);
 6815   format %{ &quot;MODG_const  $dst,src1,$src2\t # long&quot; %}
 6816   ins_encode %{
 6817     int divisor = $src2$$constant;
 6818     if (divisor != -1) {
 6819       __ z_lghi(Z_R0_scratch, divisor);
 6820       __ z_lgr($dst$$Register-&gt;successor(), $src1$$Register);
 6821       __ z_dsgr($dst$$Register /* Dst is even part of a register pair. */, Z_R0_scratch);  // Instruction kills tmp.
 6822     } else {
 6823       __ clear_reg($dst$$Register, true, false);
 6824     }
 6825   %}
 6826   ins_pipe(pipe_class_dummy);
 6827 %}
 6828 
 6829 // SHIFT
 6830 
 6831 // Shift left logical
 6832 
 6833 // Register Shift Left variable
 6834 instruct sllI_reg_reg(iRegI dst, iRegI src, iRegI nbits, flagsReg cr) %{
 6835   match(Set dst (LShiftI src nbits));
 6836   effect(KILL cr); // R1 is killed, too.
 6837   ins_cost(3 * DEFAULT_COST);
 6838   size(14);
 6839   format %{ &quot;SLL     $dst,$src,[$nbits] &amp; 31\t # use RISC-like SLLG also for int&quot; %}
 6840   ins_encode %{
 6841     __ z_lgr(Z_R1_scratch, $nbits$$Register);
 6842     __ z_nill(Z_R1_scratch, BitsPerJavaInteger-1);
 6843     __ z_sllg($dst$$Register, $src$$Register, 0, Z_R1_scratch);
 6844   %}
 6845   ins_pipe(pipe_class_dummy);
 6846 %}
 6847 
 6848 // Register Shift Left Immediate
 6849 // Constant shift count is masked in ideal graph already.
 6850 instruct sllI_reg_imm(iRegI dst, iRegI src, immI nbits) %{
 6851   match(Set dst (LShiftI src nbits));
 6852   size(6);
 6853   format %{ &quot;SLL     $dst,$src,$nbits\t # use RISC-like SLLG also for int&quot; %}
 6854   ins_encode %{
 6855     int Nbit = $nbits$$constant;
 6856     assert((Nbit &amp; (BitsPerJavaInteger - 1)) == Nbit, &quot;Check shift mask in ideal graph&quot;);
 6857     __ z_sllg($dst$$Register, $src$$Register, Nbit &amp; (BitsPerJavaInteger - 1), Z_R0);
 6858   %}
 6859   ins_pipe(pipe_class_dummy);
 6860 %}
 6861 
 6862 // Register Shift Left Immediate by 1bit
 6863 instruct sllI_reg_imm_1(iRegI dst, iRegI src, immI_1 nbits) %{
 6864   match(Set dst (LShiftI src nbits));
 6865   predicate(PreferLAoverADD);
 6866   ins_cost(DEFAULT_COST_LOW);
 6867   size(4);
 6868   format %{ &quot;LA      $dst,#0($src,$src)\t # SLL by 1 (int)&quot; %}
 6869   ins_encode %{ __ z_la($dst$$Register, 0, $src$$Register, $src$$Register); %}
 6870   ins_pipe(pipe_class_dummy);
 6871 %}
 6872 
 6873 // Register Shift Left Long
 6874 instruct sllL_reg_reg(iRegL dst, iRegL src1, iRegI nbits) %{
 6875   match(Set dst (LShiftL src1 nbits));
 6876   size(6);
 6877   format %{ &quot;SLLG    $dst,$src1,[$nbits]&quot; %}
 6878   opcode(SLLG_ZOPC);
 6879   ins_encode(z_rsyform_reg_reg(dst, src1, nbits));
 6880   ins_pipe(pipe_class_dummy);
 6881 %}
 6882 
 6883 // Register Shift Left Long Immediate
 6884 instruct sllL_reg_imm(iRegL dst, iRegL src1, immI nbits) %{
 6885   match(Set dst (LShiftL src1 nbits));
 6886   size(6);
 6887   format %{ &quot;SLLG    $dst,$src1,$nbits&quot; %}
 6888   opcode(SLLG_ZOPC);
 6889   ins_encode(z_rsyform_const(dst, src1, nbits));
 6890   ins_pipe(pipe_class_dummy);
 6891 %}
 6892 
 6893 // Register Shift Left Long Immediate by 1bit
 6894 instruct sllL_reg_imm_1(iRegL dst, iRegL src1, immI_1 nbits) %{
 6895   match(Set dst (LShiftL src1 nbits));
 6896   predicate(PreferLAoverADD);
 6897   ins_cost(DEFAULT_COST_LOW);
 6898   size(4);
 6899   format %{ &quot;LA      $dst,#0($src1,$src1)\t # SLLG by 1 (long)&quot; %}
 6900   ins_encode %{ __ z_la($dst$$Register, 0, $src1$$Register, $src1$$Register); %}
 6901   ins_pipe(pipe_class_dummy);
 6902 %}
 6903 
 6904 // Shift right arithmetic
 6905 
 6906 // Register Arithmetic Shift Right
 6907 instruct sraI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 6908   match(Set dst (RShiftI dst src));
 6909   effect(KILL cr); // R1 is killed, too.
 6910   ins_cost(3 * DEFAULT_COST);
 6911   size(12);
 6912   format %{ &quot;SRA     $dst,[$src] &amp; 31&quot; %}
 6913   ins_encode %{
 6914     __ z_lgr(Z_R1_scratch, $src$$Register);
 6915     __ z_nill(Z_R1_scratch, BitsPerJavaInteger-1);
 6916     __ z_sra($dst$$Register, 0, Z_R1_scratch);
 6917   %}
 6918   ins_pipe(pipe_class_dummy);
 6919 %}
 6920 
 6921 // Register Arithmetic Shift Right Immediate
 6922 // Constant shift count is masked in ideal graph already.
 6923 instruct sraI_reg_imm(iRegI dst, immI src, flagsReg cr) %{
 6924   match(Set dst (RShiftI dst src));
 6925   effect(KILL cr);
 6926   size(4);
 6927   format %{ &quot;SRA     $dst,$src&quot; %}
 6928   ins_encode %{
 6929     int Nbit = $src$$constant;
 6930     assert((Nbit &amp; (BitsPerJavaInteger - 1)) == Nbit, &quot;Check shift mask in ideal graph&quot;);
 6931     __ z_sra($dst$$Register, Nbit &amp; (BitsPerJavaInteger - 1), Z_R0);
 6932   %}
 6933   ins_pipe(pipe_class_dummy);
 6934 %}
 6935 
 6936 // Register Arithmetic Shift Right Long
 6937 instruct sraL_reg_reg(iRegL dst, iRegL src1, iRegI src2, flagsReg cr) %{
 6938   match(Set dst (RShiftL src1 src2));
 6939   effect(KILL cr);
 6940   size(6);
 6941   format %{ &quot;SRAG    $dst,$src1,[$src2]&quot; %}
 6942   opcode(SRAG_ZOPC);
 6943   ins_encode(z_rsyform_reg_reg(dst, src1, src2));
 6944   ins_pipe(pipe_class_dummy);
 6945 %}
 6946 
 6947 // Register Arithmetic Shift Right Long Immediate
 6948 instruct sraL_reg_imm(iRegL dst, iRegL src1, immI src2, flagsReg cr) %{
 6949   match(Set dst (RShiftL src1 src2));
 6950   effect(KILL cr);
 6951   size(6);
 6952   format %{ &quot;SRAG    $dst,$src1,$src2&quot; %}
 6953   opcode(SRAG_ZOPC);
 6954   ins_encode(z_rsyform_const(dst, src1, src2));
 6955   ins_pipe(pipe_class_dummy);
 6956 %}
 6957 
 6958 //  Shift right logical
 6959 
 6960 // Register Shift Right
 6961 instruct srlI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 6962   match(Set dst (URShiftI dst src));
 6963   effect(KILL cr); // R1 is killed, too.
 6964   ins_cost(3 * DEFAULT_COST);
 6965   size(12);
 6966   format %{ &quot;SRL     $dst,[$src] &amp; 31&quot; %}
 6967   ins_encode %{
 6968     __ z_lgr(Z_R1_scratch, $src$$Register);
 6969     __ z_nill(Z_R1_scratch, BitsPerJavaInteger-1);
 6970     __ z_srl($dst$$Register, 0, Z_R1_scratch);
 6971   %}
 6972   ins_pipe(pipe_class_dummy);
 6973 %}
 6974 
 6975 // Register Shift Right Immediate
 6976 // Constant shift count is masked in ideal graph already.
 6977 instruct srlI_reg_imm(iRegI dst, immI src) %{
 6978   match(Set dst (URShiftI dst src));
 6979   size(4);
 6980   format %{ &quot;SRL     $dst,$src&quot; %}
 6981   ins_encode %{
 6982     int Nbit = $src$$constant;
 6983     assert((Nbit &amp; (BitsPerJavaInteger - 1)) == Nbit, &quot;Check shift mask in ideal graph&quot;);
 6984     __ z_srl($dst$$Register, Nbit &amp; (BitsPerJavaInteger - 1), Z_R0);
 6985   %}
 6986   ins_pipe(pipe_class_dummy);
 6987 %}
 6988 
 6989 // Register Shift Right Long
 6990 instruct srlL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 6991   match(Set dst (URShiftL src1 src2));
 6992   size(6);
 6993   format %{ &quot;SRLG    $dst,$src1,[$src2]&quot; %}
 6994   opcode(SRLG_ZOPC);
 6995   ins_encode(z_rsyform_reg_reg(dst, src1, src2));
 6996   ins_pipe(pipe_class_dummy);
 6997 %}
 6998 
 6999 // Register Shift Right Long Immediate
 7000 instruct srlL_reg_imm(iRegL dst, iRegL src1, immI src2) %{
 7001   match(Set dst (URShiftL src1 src2));
 7002   size(6);
 7003   format %{ &quot;SRLG    $dst,$src1,$src2&quot; %}
 7004   opcode(SRLG_ZOPC);
 7005   ins_encode(z_rsyform_const(dst, src1, src2));
 7006   ins_pipe(pipe_class_dummy);
 7007 %}
 7008 
 7009 // Register Shift Right Immediate with a CastP2X
 7010 instruct srlP_reg_imm(iRegL dst, iRegP_N2P src1, immI src2) %{
 7011   match(Set dst (URShiftL (CastP2X src1) src2));
 7012   size(6);
 7013   format %{ &quot;SRLG    $dst,$src1,$src2\t # Cast ptr $src1 to long and shift&quot; %}
 7014   opcode(SRLG_ZOPC);
 7015   ins_encode(z_rsyform_const(dst, src1, src2));
 7016   ins_pipe(pipe_class_dummy);
 7017 %}
 7018 
 7019 //----------Rotate Instructions------------------------------------------------
 7020 
 7021 // Rotate left 32bit.
 7022 instruct rotlI_reg_immI8(iRegI dst, iRegI src, immI8 lshift, immI8 rshift) %{
 7023   match(Set dst (OrI (LShiftI src lshift) (URShiftI src rshift)));
 7024   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 7025   size(6);
 7026   format %{ &quot;RLL     $dst,$src,$lshift\t # ROTL32&quot; %}
 7027   opcode(RLL_ZOPC);
 7028   ins_encode(z_rsyform_const(dst, src, lshift));
 7029   ins_pipe(pipe_class_dummy);
 7030 %}
 7031 
 7032 // Rotate left 64bit.
 7033 instruct rotlL_reg_immI8(iRegL dst, iRegL src, immI8 lshift, immI8 rshift) %{
 7034   match(Set dst (OrL (LShiftL src lshift) (URShiftL src rshift)));
 7035   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 7036   size(6);
 7037   format %{ &quot;RLLG    $dst,$src,$lshift\t # ROTL64&quot; %}
 7038   opcode(RLLG_ZOPC);
 7039   ins_encode(z_rsyform_const(dst, src, lshift));
 7040   ins_pipe(pipe_class_dummy);
 7041 %}
 7042 
 7043 // Rotate right 32bit.
 7044 instruct rotrI_reg_immI8(iRegI dst, iRegI src, immI8 rshift, immI8 lshift) %{
 7045   match(Set dst (OrI (URShiftI src rshift) (LShiftI src lshift)));
 7046   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 7047   // TODO: s390 port size(FIXED_SIZE);
 7048   format %{ &quot;RLL     $dst,$src,$rshift\t # ROTR32&quot; %}
 7049   opcode(RLL_ZOPC);
 7050   ins_encode(z_rsyform_const(dst, src, rshift));
 7051   ins_pipe(pipe_class_dummy);
 7052 %}
 7053 
 7054 // Rotate right 64bit.
 7055 instruct rotrL_reg_immI8(iRegL dst, iRegL src, immI8 rshift, immI8 lshift) %{
 7056   match(Set dst (OrL (URShiftL src rshift) (LShiftL src lshift)));
 7057   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 7058   // TODO: s390 port size(FIXED_SIZE);
 7059   format %{ &quot;RLLG    $dst,$src,$rshift\t # ROTR64&quot; %}
 7060   opcode(RLLG_ZOPC);
 7061   ins_encode(z_rsyform_const(dst, src, rshift));
 7062   ins_pipe(pipe_class_dummy);
 7063 %}
 7064 
 7065 
 7066 //----------Overflow Math Instructions-----------------------------------------
 7067 
 7068 instruct overflowAddI_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 7069   match(Set cr (OverflowAddI op1 op2));
 7070   effect(DEF cr, USE op1, USE op2);
 7071   // TODO: s390 port size(FIXED_SIZE);
 7072   format %{ &quot;AR      $op1,$op2\t # overflow check int&quot; %}
 7073   ins_encode %{
 7074     __ z_lr(Z_R0_scratch, $op1$$Register);
 7075     __ z_ar(Z_R0_scratch, $op2$$Register);
 7076   %}
 7077   ins_pipe(pipe_class_dummy);
 7078 %}
 7079 
 7080 instruct overflowAddI_reg_imm(flagsReg cr, iRegI op1, immI op2) %{
 7081   match(Set cr (OverflowAddI op1 op2));
 7082   effect(DEF cr, USE op1, USE op2);
 7083   // TODO: s390 port size(VARIABLE_SIZE);
 7084   format %{ &quot;AR      $op1,$op2\t # overflow check int&quot; %}
 7085   ins_encode %{
 7086     __ load_const_optimized(Z_R0_scratch, $op2$$constant);
 7087     __ z_ar(Z_R0_scratch, $op1$$Register);
 7088   %}
 7089   ins_pipe(pipe_class_dummy);
 7090 %}
 7091 
 7092 instruct overflowAddL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 7093   match(Set cr (OverflowAddL op1 op2));
 7094   effect(DEF cr, USE op1, USE op2);
 7095   // TODO: s390 port size(FIXED_SIZE);
 7096   format %{ &quot;AGR     $op1,$op2\t # overflow check long&quot; %}
 7097   ins_encode %{
 7098     __ z_lgr(Z_R0_scratch, $op1$$Register);
 7099     __ z_agr(Z_R0_scratch, $op2$$Register);
 7100   %}
 7101   ins_pipe(pipe_class_dummy);
 7102 %}
 7103 
 7104 instruct overflowAddL_reg_imm(flagsReg cr, iRegL op1, immL op2) %{
 7105   match(Set cr (OverflowAddL op1 op2));
 7106   effect(DEF cr, USE op1, USE op2);
 7107   // TODO: s390 port size(VARIABLE_SIZE);
 7108   format %{ &quot;AGR     $op1,$op2\t # overflow check long&quot; %}
 7109   ins_encode %{
 7110     __ load_const_optimized(Z_R0_scratch, $op2$$constant);
 7111     __ z_agr(Z_R0_scratch, $op1$$Register);
 7112   %}
 7113   ins_pipe(pipe_class_dummy);
 7114 %}
 7115 
 7116 instruct overflowSubI_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 7117   match(Set cr (OverflowSubI op1 op2));
 7118   effect(DEF cr, USE op1, USE op2);
 7119   // TODO: s390 port size(FIXED_SIZE);
 7120   format %{ &quot;SR      $op1,$op2\t # overflow check int&quot; %}
 7121   ins_encode %{
 7122     __ z_lr(Z_R0_scratch, $op1$$Register);
 7123     __ z_sr(Z_R0_scratch, $op2$$Register);
 7124   %}
 7125   ins_pipe(pipe_class_dummy);
 7126 %}
 7127 
 7128 instruct overflowSubI_reg_imm(flagsReg cr, iRegI op1, immI op2) %{
 7129   match(Set cr (OverflowSubI op1 op2));
 7130   effect(DEF cr, USE op1, USE op2);
 7131   // TODO: s390 port size(VARIABLE_SIZE);
 7132   format %{ &quot;SR      $op1,$op2\t # overflow check int&quot; %}
 7133   ins_encode %{
 7134     __ load_const_optimized(Z_R1_scratch, $op2$$constant);
 7135     __ z_lr(Z_R0_scratch, $op1$$Register);
 7136     __ z_sr(Z_R0_scratch, Z_R1_scratch);
 7137   %}
 7138   ins_pipe(pipe_class_dummy);
 7139 %}
 7140 
 7141 instruct overflowSubL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 7142   match(Set cr (OverflowSubL op1 op2));
 7143   effect(DEF cr, USE op1, USE op2);
 7144   // TODO: s390 port size(FIXED_SIZE);
 7145   format %{ &quot;SGR     $op1,$op2\t # overflow check long&quot; %}
 7146   ins_encode %{
 7147     __ z_lgr(Z_R0_scratch, $op1$$Register);
 7148     __ z_sgr(Z_R0_scratch, $op2$$Register);
 7149   %}
 7150   ins_pipe(pipe_class_dummy);
 7151 %}
 7152 
 7153 instruct overflowSubL_reg_imm(flagsReg cr, iRegL op1, immL op2) %{
 7154   match(Set cr (OverflowSubL op1 op2));
 7155   effect(DEF cr, USE op1, USE op2);
 7156   // TODO: s390 port size(VARIABLE_SIZE);
 7157   format %{ &quot;SGR     $op1,$op2\t # overflow check long&quot; %}
 7158   ins_encode %{
 7159     __ load_const_optimized(Z_R1_scratch, $op2$$constant);
 7160     __ z_lgr(Z_R0_scratch, $op1$$Register);
 7161     __ z_sgr(Z_R0_scratch, Z_R1_scratch);
 7162   %}
 7163   ins_pipe(pipe_class_dummy);
 7164 %}
 7165 
 7166 instruct overflowNegI_rReg(flagsReg cr, immI_0 zero, iRegI op2) %{
 7167   match(Set cr (OverflowSubI zero op2));
 7168   effect(DEF cr, USE op2);
 7169   format %{ &quot;NEG    $op2\t # overflow check int&quot; %}
 7170   ins_encode %{
 7171     __ clear_reg(Z_R0_scratch, false, false);
 7172     __ z_sr(Z_R0_scratch, $op2$$Register);
 7173   %}
 7174   ins_pipe(pipe_class_dummy);
 7175 %}
 7176 
 7177 instruct overflowNegL_rReg(flagsReg cr, immL_0 zero, iRegL op2) %{
 7178   match(Set cr (OverflowSubL zero op2));
 7179   effect(DEF cr, USE op2);
 7180   format %{ &quot;NEGG    $op2\t # overflow check long&quot; %}
 7181   ins_encode %{
 7182     __ clear_reg(Z_R0_scratch, true, false);
 7183     __ z_sgr(Z_R0_scratch, $op2$$Register);
 7184   %}
 7185   ins_pipe(pipe_class_dummy);
 7186 %}
 7187 
 7188 // No intrinsics for multiplication, since there is no easy way
 7189 // to check for overflow.
 7190 
 7191 
 7192 //----------Floating Point Arithmetic Instructions-----------------------------
 7193 
 7194 //  ADD
 7195 
 7196 //  Add float single precision
 7197 instruct addF_reg_reg(regF dst, regF src, flagsReg cr) %{
 7198   match(Set dst (AddF dst src));
 7199   effect(KILL cr);
 7200   ins_cost(ALU_REG_COST);
 7201   size(4);
 7202   format %{ &quot;AEBR     $dst,$src&quot; %}
 7203   opcode(AEBR_ZOPC);
 7204   ins_encode(z_rreform(dst, src));
 7205   ins_pipe(pipe_class_dummy);
 7206 %}
 7207 
 7208 instruct addF_reg_mem(regF dst, memoryRX src, flagsReg cr)%{
 7209   match(Set dst (AddF dst (LoadF src)));
 7210   effect(KILL cr);
 7211   ins_cost(ALU_MEMORY_COST);
 7212   size(6);
 7213   format %{ &quot;AEB      $dst,$src\t # floatMemory&quot; %}
 7214   opcode(AEB_ZOPC);
 7215   ins_encode(z_form_rt_memFP(dst, src));
 7216   ins_pipe(pipe_class_dummy);
 7217 %}
 7218 
 7219 // Add float double precision
 7220 instruct addD_reg_reg(regD dst, regD src, flagsReg cr) %{
 7221   match(Set dst (AddD dst src));
 7222   effect(KILL cr);
 7223   ins_cost(ALU_REG_COST);
 7224   size(4);
 7225   format %{ &quot;ADBR     $dst,$src&quot; %}
 7226   opcode(ADBR_ZOPC);
 7227   ins_encode(z_rreform(dst, src));
 7228   ins_pipe(pipe_class_dummy);
 7229 %}
 7230 
 7231 instruct addD_reg_mem(regD dst, memoryRX src, flagsReg cr)%{
 7232   match(Set dst (AddD dst (LoadD src)));
 7233   effect(KILL cr);
 7234   ins_cost(ALU_MEMORY_COST);
 7235   size(6);
 7236   format %{ &quot;ADB      $dst,$src\t # doubleMemory&quot; %}
 7237   opcode(ADB_ZOPC);
 7238   ins_encode(z_form_rt_memFP(dst, src));
 7239   ins_pipe(pipe_class_dummy);
 7240 %}
 7241 
 7242 // SUB
 7243 
 7244 // Sub float single precision
 7245 instruct subF_reg_reg(regF dst, regF src, flagsReg cr) %{
 7246   match(Set dst (SubF dst src));
 7247   effect(KILL cr);
 7248   ins_cost(ALU_REG_COST);
 7249   size(4);
 7250   format %{ &quot;SEBR     $dst,$src&quot; %}
 7251   opcode(SEBR_ZOPC);
 7252   ins_encode(z_rreform(dst, src));
 7253   ins_pipe(pipe_class_dummy);
 7254 %}
 7255 
 7256 instruct subF_reg_mem(regF dst, memoryRX src, flagsReg cr)%{
 7257   match(Set dst (SubF dst (LoadF src)));
 7258   effect(KILL cr);
 7259   ins_cost(ALU_MEMORY_COST);
 7260   size(6);
 7261   format %{ &quot;SEB      $dst,$src\t # floatMemory&quot; %}
 7262   opcode(SEB_ZOPC);
 7263   ins_encode(z_form_rt_memFP(dst, src));
 7264   ins_pipe(pipe_class_dummy);
 7265 %}
 7266 
 7267 //  Sub float double precision
 7268 instruct subD_reg_reg(regD dst, regD src, flagsReg cr) %{
 7269   match(Set dst (SubD dst src));
 7270   effect(KILL cr);
 7271   ins_cost(ALU_REG_COST);
 7272   size(4);
 7273   format %{ &quot;SDBR     $dst,$src&quot; %}
 7274   opcode(SDBR_ZOPC);
 7275   ins_encode(z_rreform(dst, src));
 7276   ins_pipe(pipe_class_dummy);
 7277 %}
 7278 
 7279 instruct subD_reg_mem(regD dst, memoryRX src, flagsReg cr)%{
 7280   match(Set dst (SubD dst (LoadD src)));
 7281   effect(KILL cr);
 7282   ins_cost(ALU_MEMORY_COST);
 7283   size(6);
 7284   format %{ &quot;SDB      $dst,$src\t # doubleMemory&quot; %}
 7285   opcode(SDB_ZOPC);
 7286   ins_encode(z_form_rt_memFP(dst, src));
 7287   ins_pipe(pipe_class_dummy);
 7288 %}
 7289 
 7290 // MUL
 7291 
 7292 // Mul float single precision
 7293 instruct mulF_reg_reg(regF dst, regF src) %{
 7294   match(Set dst (MulF dst src));
 7295   // CC unchanged by MUL.
 7296   ins_cost(ALU_REG_COST);
 7297   size(4);
 7298   format %{ &quot;MEEBR    $dst,$src&quot; %}
 7299   opcode(MEEBR_ZOPC);
 7300   ins_encode(z_rreform(dst, src));
 7301   ins_pipe(pipe_class_dummy);
 7302 %}
 7303 
 7304 instruct mulF_reg_mem(regF dst, memoryRX src)%{
 7305   match(Set dst (MulF dst (LoadF src)));
 7306   // CC unchanged by MUL.
 7307   ins_cost(ALU_MEMORY_COST);
 7308   size(6);
 7309   format %{ &quot;MEEB     $dst,$src\t # floatMemory&quot; %}
 7310   opcode(MEEB_ZOPC);
 7311   ins_encode(z_form_rt_memFP(dst, src));
 7312   ins_pipe(pipe_class_dummy);
 7313 %}
 7314 
 7315 //  Mul float double precision
 7316 instruct mulD_reg_reg(regD dst, regD src) %{
 7317   match(Set dst (MulD dst src));
 7318   // CC unchanged by MUL.
 7319   ins_cost(ALU_REG_COST);
 7320   size(4);
 7321   format %{ &quot;MDBR     $dst,$src&quot; %}
 7322   opcode(MDBR_ZOPC);
 7323   ins_encode(z_rreform(dst, src));
 7324   ins_pipe(pipe_class_dummy);
 7325 %}
 7326 
 7327 instruct mulD_reg_mem(regD dst, memoryRX src)%{
 7328   match(Set dst (MulD dst (LoadD src)));
 7329   // CC unchanged by MUL.
 7330   ins_cost(ALU_MEMORY_COST);
 7331   size(6);
 7332   format %{ &quot;MDB      $dst,$src\t # doubleMemory&quot; %}
 7333   opcode(MDB_ZOPC);
 7334   ins_encode(z_form_rt_memFP(dst, src));
 7335   ins_pipe(pipe_class_dummy);
 7336 %}
 7337 
 7338 // Multiply-Accumulate
 7339 // src1 * src2 + dst
 7340 instruct maddF_reg_reg(regF dst, regF src1, regF src2) %{
 7341   match(Set dst (FmaF dst (Binary src1 src2)));
 7342   // CC unchanged by MUL-ADD.
 7343   ins_cost(ALU_REG_COST);
 7344   size(4);
 7345   format %{ &quot;MAEBR    $dst, $src1, $src2&quot; %}
 7346   ins_encode %{
 7347     __ z_maebr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7348   %}
 7349   ins_pipe(pipe_class_dummy);
 7350 %}
 7351 
 7352 // src1 * src2 + dst
 7353 instruct maddD_reg_reg(regD dst, regD src1, regD src2) %{
 7354   match(Set dst (FmaD dst (Binary src1 src2)));
 7355   // CC unchanged by MUL-ADD.
 7356   ins_cost(ALU_REG_COST);
 7357   size(4);
 7358   format %{ &quot;MADBR    $dst, $src1, $src2&quot; %}
 7359   ins_encode %{
 7360     __ z_madbr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7361   %}
 7362   ins_pipe(pipe_class_dummy);
 7363 %}
 7364 
 7365 // src1 * src2 - dst
 7366 instruct msubF_reg_reg(regF dst, regF src1, regF src2) %{
 7367   match(Set dst (FmaF (NegF dst) (Binary src1 src2)));
 7368   // CC unchanged by MUL-SUB.
 7369   ins_cost(ALU_REG_COST);
 7370   size(4);
 7371   format %{ &quot;MSEBR    $dst, $src1, $src2&quot; %}
 7372   ins_encode %{
 7373     __ z_msebr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7374   %}
 7375   ins_pipe(pipe_class_dummy);
 7376 %}
 7377 
 7378 // src1 * src2 - dst
 7379 instruct msubD_reg_reg(regD dst, regD src1, regD src2) %{
 7380   match(Set dst (FmaD (NegD dst) (Binary src1 src2)));
 7381   // CC unchanged by MUL-SUB.
 7382   ins_cost(ALU_REG_COST);
 7383   size(4);
 7384   format %{ &quot;MSDBR    $dst, $src1, $src2&quot; %}
 7385   ins_encode %{
 7386     __ z_msdbr($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7387   %}
 7388   ins_pipe(pipe_class_dummy);
 7389 %}
 7390 
 7391 // src1 * src2 + dst
 7392 instruct maddF_reg_mem(regF dst, regF src1, memoryRX src2) %{
 7393   match(Set dst (FmaF dst (Binary src1 (LoadF src2))));
 7394   // CC unchanged by MUL-ADD.
 7395   ins_cost(ALU_MEMORY_COST);
 7396   size(6);
 7397   format %{ &quot;MAEB     $dst, $src1, $src2&quot; %}
 7398   ins_encode %{
 7399     __ z_maeb($dst$$FloatRegister, $src1$$FloatRegister,
 7400               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7401   %}
 7402   ins_pipe(pipe_class_dummy);
 7403 %}
 7404 
 7405 // src1 * src2 + dst
 7406 instruct maddD_reg_mem(regD dst, regD src1, memoryRX src2) %{
 7407   match(Set dst (FmaD dst (Binary src1 (LoadD src2))));
 7408   // CC unchanged by MUL-ADD.
 7409   ins_cost(ALU_MEMORY_COST);
 7410   size(6);
 7411   format %{ &quot;MADB     $dst, $src1, $src2&quot; %}
 7412   ins_encode %{
 7413     __ z_madb($dst$$FloatRegister, $src1$$FloatRegister,
 7414               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7415   %}
 7416   ins_pipe(pipe_class_dummy);
 7417 %}
 7418 
 7419 // src1 * src2 - dst
 7420 instruct msubF_reg_mem(regF dst, regF src1, memoryRX src2) %{
 7421   match(Set dst (FmaF (NegF dst) (Binary src1 (LoadF src2))));
 7422   // CC unchanged by MUL-SUB.
 7423   ins_cost(ALU_MEMORY_COST);
 7424   size(6);
 7425   format %{ &quot;MSEB     $dst, $src1, $src2&quot; %}
 7426   ins_encode %{
 7427     __ z_mseb($dst$$FloatRegister, $src1$$FloatRegister,
 7428               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7429   %}
 7430   ins_pipe(pipe_class_dummy);
 7431 %}
 7432 
 7433 // src1 * src2 - dst
 7434 instruct msubD_reg_mem(regD dst, regD src1, memoryRX src2) %{
 7435   match(Set dst (FmaD (NegD dst) (Binary src1 (LoadD src2))));
 7436   // CC unchanged by MUL-SUB.
 7437   ins_cost(ALU_MEMORY_COST);
 7438   size(6);
 7439   format %{ &quot;MSDB    $dst, $src1, $src2&quot; %}
 7440   ins_encode %{
 7441     __ z_msdb($dst$$FloatRegister, $src1$$FloatRegister,
 7442               Address(reg_to_register_object($src2$$base), $src2$$index$$Register, $src2$$disp));
 7443   %}
 7444   ins_pipe(pipe_class_dummy);
 7445 %}
 7446 
 7447 // src1 * src2 + dst
 7448 instruct maddF_mem_reg(regF dst, memoryRX src1, regF src2) %{
 7449   match(Set dst (FmaF dst (Binary (LoadF src1) src2)));
 7450   // CC unchanged by MUL-ADD.
 7451   ins_cost(ALU_MEMORY_COST);
 7452   size(6);
 7453   format %{ &quot;MAEB     $dst, $src1, $src2&quot; %}
 7454   ins_encode %{
 7455     __ z_maeb($dst$$FloatRegister, $src2$$FloatRegister,
 7456               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7457   %}
 7458   ins_pipe(pipe_class_dummy);
 7459 %}
 7460 
 7461 // src1 * src2 + dst
 7462 instruct maddD_mem_reg(regD dst, memoryRX src1, regD src2) %{
 7463   match(Set dst (FmaD dst (Binary (LoadD src1) src2)));
 7464   // CC unchanged by MUL-ADD.
 7465   ins_cost(ALU_MEMORY_COST);
 7466   size(6);
 7467   format %{ &quot;MADB     $dst, $src1, $src2&quot; %}
 7468   ins_encode %{
 7469     __ z_madb($dst$$FloatRegister, $src2$$FloatRegister,
 7470               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7471   %}
 7472   ins_pipe(pipe_class_dummy);
 7473 %}
 7474 
 7475 // src1 * src2 - dst
 7476 instruct msubF_mem_reg(regF dst, memoryRX src1, regF src2) %{
 7477   match(Set dst (FmaF (NegF dst) (Binary (LoadF src1) src2)));
 7478   // CC unchanged by MUL-SUB.
 7479   ins_cost(ALU_MEMORY_COST);
 7480   size(6);
 7481   format %{ &quot;MSEB     $dst, $src1, $src2&quot; %}
 7482   ins_encode %{
 7483     __ z_mseb($dst$$FloatRegister, $src2$$FloatRegister,
 7484               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7485   %}
 7486   ins_pipe(pipe_class_dummy);
 7487 %}
 7488 
 7489 // src1 * src2 - dst
 7490 instruct msubD_mem_reg(regD dst, memoryRX src1, regD src2) %{
 7491   match(Set dst (FmaD (NegD dst) (Binary (LoadD src1) src2)));
 7492   // CC unchanged by MUL-SUB.
 7493   ins_cost(ALU_MEMORY_COST);
 7494   size(6);
 7495   format %{ &quot;MSDB    $dst, $src1, $src2&quot; %}
 7496   ins_encode %{
 7497     __ z_msdb($dst$$FloatRegister, $src2$$FloatRegister,
 7498               Address(reg_to_register_object($src1$$base), $src1$$index$$Register, $src1$$disp));
 7499   %}
 7500   ins_pipe(pipe_class_dummy);
 7501 %}
 7502 
 7503 //  DIV
 7504 
 7505 //  Div float single precision
 7506 instruct divF_reg_reg(regF dst, regF src) %{
 7507   match(Set dst (DivF dst src));
 7508   // CC unchanged by DIV.
 7509   ins_cost(ALU_REG_COST);
 7510   size(4);
 7511   format %{ &quot;DEBR     $dst,$src&quot; %}
 7512   opcode(DEBR_ZOPC);
 7513   ins_encode(z_rreform(dst, src));
 7514   ins_pipe(pipe_class_dummy);
 7515 %}
 7516 
 7517 instruct divF_reg_mem(regF dst, memoryRX src)%{
 7518   match(Set dst (DivF dst (LoadF src)));
 7519   // CC unchanged by DIV.
 7520   ins_cost(ALU_MEMORY_COST);
 7521   size(6);
 7522   format %{ &quot;DEB      $dst,$src\t # floatMemory&quot; %}
 7523   opcode(DEB_ZOPC);
 7524   ins_encode(z_form_rt_memFP(dst, src));
 7525   ins_pipe(pipe_class_dummy);
 7526 %}
 7527 
 7528 //  Div float double precision
 7529 instruct divD_reg_reg(regD dst, regD src) %{
 7530   match(Set dst (DivD dst src));
 7531   // CC unchanged by DIV.
 7532   ins_cost(ALU_REG_COST);
 7533   size(4);
 7534   format %{ &quot;DDBR     $dst,$src&quot; %}
 7535   opcode(DDBR_ZOPC);
 7536   ins_encode(z_rreform(dst, src));
 7537   ins_pipe(pipe_class_dummy);
 7538 %}
 7539 
 7540 instruct divD_reg_mem(regD dst, memoryRX src)%{
 7541   match(Set dst (DivD dst (LoadD src)));
 7542   // CC unchanged by DIV.
 7543   ins_cost(ALU_MEMORY_COST);
 7544   size(6);
 7545   format %{ &quot;DDB      $dst,$src\t # doubleMemory&quot; %}
 7546   opcode(DDB_ZOPC);
 7547   ins_encode(z_form_rt_memFP(dst, src));
 7548   ins_pipe(pipe_class_dummy);
 7549 %}
 7550 
 7551 // ABS
 7552 
 7553 // Absolute float single precision
 7554 instruct absF_reg(regF dst, regF src, flagsReg cr) %{
 7555   match(Set dst (AbsF src));
 7556   effect(KILL cr);
 7557   size(4);
 7558   format %{ &quot;LPEBR    $dst,$src\t float&quot; %}
 7559   opcode(LPEBR_ZOPC);
 7560   ins_encode(z_rreform(dst, src));
 7561   ins_pipe(pipe_class_dummy);
 7562 %}
 7563 
 7564 // Absolute float double precision
 7565 instruct absD_reg(regD dst, regD src, flagsReg cr) %{
 7566   match(Set dst (AbsD src));
 7567   effect(KILL cr);
 7568   size(4);
 7569   format %{ &quot;LPDBR    $dst,$src\t double&quot; %}
 7570   opcode(LPDBR_ZOPC);
 7571   ins_encode(z_rreform(dst, src));
 7572   ins_pipe(pipe_class_dummy);
 7573 %}
 7574 
 7575 //  NEG(ABS)
 7576 
 7577 // Negative absolute float single precision
 7578 instruct nabsF_reg(regF dst, regF src, flagsReg cr) %{
 7579   match(Set dst (NegF (AbsF src)));
 7580   effect(KILL cr);
 7581   size(4);
 7582   format %{ &quot;LNEBR    $dst,$src\t float&quot; %}
 7583   opcode(LNEBR_ZOPC);
 7584   ins_encode(z_rreform(dst, src));
 7585   ins_pipe(pipe_class_dummy);
 7586 %}
 7587 
 7588 // Negative absolute float double precision
 7589 instruct nabsD_reg(regD dst, regD src, flagsReg cr) %{
 7590   match(Set dst (NegD (AbsD src)));
 7591   effect(KILL cr);
 7592   size(4);
 7593   format %{ &quot;LNDBR    $dst,$src\t double&quot; %}
 7594   opcode(LNDBR_ZOPC);
 7595   ins_encode(z_rreform(dst, src));
 7596   ins_pipe(pipe_class_dummy);
 7597 %}
 7598 
 7599 // NEG
 7600 
 7601 instruct negF_reg(regF dst, regF src, flagsReg cr) %{
 7602   match(Set dst (NegF src));
 7603   effect(KILL cr);
 7604   size(4);
 7605   format %{ &quot;NegF     $dst,$src\t float&quot; %}
 7606   ins_encode %{ __ z_lcebr($dst$$FloatRegister, $src$$FloatRegister); %}
 7607   ins_pipe(pipe_class_dummy);
 7608 %}
 7609 
 7610 instruct negD_reg(regD dst, regD src, flagsReg cr) %{
 7611   match(Set dst (NegD src));
 7612   effect(KILL cr);
 7613   size(4);
 7614   format %{ &quot;NegD     $dst,$src\t double&quot; %}
 7615   ins_encode %{ __ z_lcdbr($dst$$FloatRegister, $src$$FloatRegister); %}
 7616   ins_pipe(pipe_class_dummy);
 7617 %}
 7618 
 7619 // SQRT
 7620 
 7621 // Sqrt float precision
 7622 instruct sqrtF_reg(regF dst, regF src) %{
 7623   match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
 7624   // CC remains unchanged.
 7625   ins_cost(ALU_REG_COST);
 7626   size(4);
 7627   format %{ &quot;SQEBR    $dst,$src&quot; %}
 7628   opcode(SQEBR_ZOPC);
 7629   ins_encode(z_rreform(dst, src));
 7630   ins_pipe(pipe_class_dummy);
 7631 %}
 7632 
 7633 // Sqrt double precision
 7634 instruct sqrtD_reg(regD dst, regD src) %{
 7635   match(Set dst (SqrtD src));
 7636   // CC remains unchanged.
 7637   ins_cost(ALU_REG_COST);
 7638   size(4);
 7639   format %{ &quot;SQDBR    $dst,$src&quot; %}
 7640   opcode(SQDBR_ZOPC);
 7641   ins_encode(z_rreform(dst, src));
 7642   ins_pipe(pipe_class_dummy);
 7643 %}
 7644 
 7645 instruct sqrtF_mem(regF dst, memoryRX src) %{
 7646   match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
 7647   // CC remains unchanged.
 7648   ins_cost(ALU_MEMORY_COST);
 7649   size(6);
 7650   format %{ &quot;SQEB     $dst,$src\t # floatMemory&quot; %}
 7651   opcode(SQEB_ZOPC);
 7652   ins_encode(z_form_rt_memFP(dst, src));
 7653   ins_pipe(pipe_class_dummy);
 7654 %}
 7655 
 7656 instruct sqrtD_mem(regD dst, memoryRX src) %{
 7657   match(Set dst (SqrtD src));
 7658   // CC remains unchanged.
 7659   ins_cost(ALU_MEMORY_COST);
 7660   // TODO: s390 port size(FIXED_SIZE);
 7661   format %{ &quot;SQDB     $dst,$src\t # doubleMemory&quot; %}
 7662   opcode(SQDB_ZOPC);
 7663   ins_encode(z_form_rt_memFP(dst, src));
 7664   ins_pipe(pipe_class_dummy);
 7665 %}
 7666 
 7667 //----------Logical Instructions-----------------------------------------------
 7668 
 7669 // Register And
 7670 instruct andI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7671   match(Set dst (AndI dst src));
 7672   effect(KILL cr);
 7673   ins_cost(DEFAULT_COST_LOW);
 7674   size(2);
 7675   format %{ &quot;NR      $dst,$src\t # int&quot; %}
 7676   opcode(NR_ZOPC);
 7677   ins_encode(z_rrform(dst, src));
 7678   ins_pipe(pipe_class_dummy);
 7679 %}
 7680 
 7681 instruct andI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 7682   match(Set dst (AndI dst (LoadI src)));
 7683   effect(KILL cr);
 7684   ins_cost(MEMORY_REF_COST);
 7685   // TODO: s390 port size(VARIABLE_SIZE);
 7686   format %{ &quot;N(Y)    $dst, $src\t # int&quot; %}
 7687   opcode(NY_ZOPC, N_ZOPC);
 7688   ins_encode(z_form_rt_mem_opt(dst, src));
 7689   ins_pipe(pipe_class_dummy);
 7690 %}
 7691 
 7692 // Immediate And
 7693 instruct andI_reg_uimm32(iRegI dst, uimmI src, flagsReg cr) %{
 7694   match(Set dst (AndI dst src));
 7695   effect(KILL cr);
 7696   ins_cost(DEFAULT_COST_HIGH);
 7697   size(6);
 7698   format %{ &quot;NILF    $dst,$src&quot; %}
 7699   opcode(NILF_ZOPC);
 7700   ins_encode(z_rilform_unsigned(dst, src));
 7701   ins_pipe(pipe_class_dummy);
 7702 %}
 7703 
 7704 instruct andI_reg_uimmI_LH1(iRegI dst, uimmI_LH1 src, flagsReg cr) %{
 7705   match(Set dst (AndI dst src));
 7706   effect(KILL cr);
 7707   ins_cost(DEFAULT_COST);
 7708   size(4);
 7709   format %{ &quot;NILH    $dst,$src&quot; %}
 7710   ins_encode %{ __ z_nilh($dst$$Register, ($src$$constant &gt;&gt; 16) &amp; 0xFFFF); %}
 7711   ins_pipe(pipe_class_dummy);
 7712 %}
 7713 
 7714 instruct andI_reg_uimmI_LL1(iRegI dst, uimmI_LL1 src, flagsReg cr) %{
 7715   match(Set dst (AndI dst src));
 7716   effect(KILL cr);
 7717   ins_cost(DEFAULT_COST);
 7718   size(4);
 7719   format %{ &quot;NILL    $dst,$src&quot; %}
 7720   ins_encode %{ __ z_nill($dst$$Register, $src$$constant &amp; 0xFFFF); %}
 7721   ins_pipe(pipe_class_dummy);
 7722 %}
 7723 
 7724 // Register And Long
 7725 instruct andL_reg_reg(iRegL dst, iRegL src, flagsReg cr) %{
 7726   match(Set dst (AndL dst src));
 7727   effect(KILL cr);
 7728   ins_cost(DEFAULT_COST);
 7729   size(4);
 7730   format %{ &quot;NGR     $dst,$src\t # long&quot; %}
 7731   opcode(NGR_ZOPC);
 7732   ins_encode(z_rreform(dst, src));
 7733   ins_pipe(pipe_class_dummy);
 7734 %}
 7735 
 7736 instruct andL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 7737   match(Set dst (AndL dst (LoadL src)));
 7738   effect(KILL cr);
 7739   ins_cost(MEMORY_REF_COST);
 7740   size(Z_DISP3_SIZE);
 7741   format %{ &quot;NG      $dst, $src\t # long&quot; %}
 7742   opcode(NG_ZOPC, NG_ZOPC);
 7743   ins_encode(z_form_rt_mem_opt(dst, src));
 7744   ins_pipe(pipe_class_dummy);
 7745 %}
 7746 
 7747 instruct andL_reg_uimmL_LL1(iRegL dst, uimmL_LL1 src, flagsReg cr) %{
 7748   match(Set dst (AndL dst src));
 7749   effect(KILL cr);
 7750   ins_cost(DEFAULT_COST);
 7751   size(4);
 7752   format %{ &quot;NILL    $dst,$src\t # long&quot; %}
 7753   ins_encode %{ __ z_nill($dst$$Register, $src$$constant &amp; 0xFFFF); %}
 7754   ins_pipe(pipe_class_dummy);
 7755 %}
 7756 
 7757 instruct andL_reg_uimmL_LH1(iRegL dst, uimmL_LH1 src, flagsReg cr) %{
 7758   match(Set dst (AndL dst src));
 7759   effect(KILL cr);
 7760   ins_cost(DEFAULT_COST);
 7761   size(4);
 7762   format %{ &quot;NILH    $dst,$src\t # long&quot; %}
 7763   ins_encode %{ __ z_nilh($dst$$Register, ($src$$constant &gt;&gt; 16) &amp; 0xFFFF); %}
 7764   ins_pipe(pipe_class_dummy);
 7765 %}
 7766 
 7767 instruct andL_reg_uimmL_HL1(iRegL dst, uimmL_HL1 src, flagsReg cr) %{
 7768   match(Set dst (AndL dst src));
 7769   effect(KILL cr);
 7770   ins_cost(DEFAULT_COST);
 7771   size(4);
 7772   format %{ &quot;NIHL    $dst,$src\t # long&quot; %}
 7773   ins_encode %{ __ z_nihl($dst$$Register, ($src$$constant &gt;&gt; 32) &amp; 0xFFFF); %}
 7774   ins_pipe(pipe_class_dummy);
 7775 %}
 7776 
 7777 instruct andL_reg_uimmL_HH1(iRegL dst, uimmL_HH1 src, flagsReg cr) %{
 7778   match(Set dst (AndL dst src));
 7779   effect(KILL cr);
 7780   ins_cost(DEFAULT_COST);
 7781   size(4);
 7782   format %{ &quot;NIHH    $dst,$src\t # long&quot; %}
 7783   ins_encode %{ __ z_nihh($dst$$Register, ($src$$constant &gt;&gt; 48) &amp; 0xFFFF); %}
 7784   ins_pipe(pipe_class_dummy);
 7785 %}
 7786 
 7787 //  OR
 7788 
 7789 // Or Instructions
 7790 // Register Or
 7791 instruct orI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7792   match(Set dst (OrI dst src));
 7793   effect(KILL cr);
 7794   size(2);
 7795   format %{ &quot;OR      $dst,$src&quot; %}
 7796   opcode(OR_ZOPC);
 7797   ins_encode(z_rrform(dst, src));
 7798   ins_pipe(pipe_class_dummy);
 7799 %}
 7800 
 7801 instruct orI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 7802   match(Set dst (OrI dst (LoadI src)));
 7803   effect(KILL cr);
 7804   ins_cost(MEMORY_REF_COST);
 7805   // TODO: s390 port size(VARIABLE_SIZE);
 7806   format %{ &quot;O(Y)    $dst, $src\t # int&quot; %}
 7807   opcode(OY_ZOPC, O_ZOPC);
 7808   ins_encode(z_form_rt_mem_opt(dst, src));
 7809   ins_pipe(pipe_class_dummy);
 7810 %}
 7811 
 7812 // Immediate Or
 7813 instruct orI_reg_uimm16(iRegI dst, uimmI16 con, flagsReg cr) %{
 7814   match(Set dst (OrI dst con));
 7815   effect(KILL cr);
 7816   size(4);
 7817   format %{ &quot;OILL    $dst,$con&quot; %}
 7818   opcode(OILL_ZOPC);
 7819   ins_encode(z_riform_unsigned(dst,con));
 7820   ins_pipe(pipe_class_dummy);
 7821 %}
 7822 
 7823 instruct orI_reg_uimm32(iRegI dst, uimmI con, flagsReg cr) %{
 7824   match(Set dst (OrI dst con));
 7825   effect(KILL cr);
 7826   ins_cost(DEFAULT_COST_HIGH);
 7827   size(6);
 7828   format %{ &quot;OILF    $dst,$con&quot; %}
 7829   opcode(OILF_ZOPC);
 7830   ins_encode(z_rilform_unsigned(dst,con));
 7831   ins_pipe(pipe_class_dummy);
 7832 %}
 7833 
 7834 // Register Or Long
 7835 instruct orL_reg_reg(iRegL dst, iRegL src, flagsReg cr) %{
 7836   match(Set dst (OrL dst src));
 7837   effect(KILL cr);
 7838   ins_cost(DEFAULT_COST);
 7839   size(4);
 7840   format %{ &quot;OGR      $dst,$src\t # long&quot; %}
 7841   opcode(OGR_ZOPC);
 7842   ins_encode(z_rreform(dst, src));
 7843   ins_pipe(pipe_class_dummy);
 7844 %}
 7845 
 7846 instruct orL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 7847   match(Set dst (OrL dst (LoadL src)));
 7848   effect(KILL cr);
 7849   ins_cost(MEMORY_REF_COST);
 7850   size(Z_DISP3_SIZE);
 7851   format %{ &quot;OG      $dst, $src\t # long&quot; %}
 7852   opcode(OG_ZOPC, OG_ZOPC);
 7853   ins_encode(z_form_rt_mem_opt(dst, src));
 7854   ins_pipe(pipe_class_dummy);
 7855 %}
 7856 
 7857 // Immediate Or long
 7858 instruct orL_reg_uimm16(iRegL dst, uimmL16 con, flagsReg cr) %{
 7859   match(Set dst (OrL dst con));
 7860   effect(KILL cr);
 7861   ins_cost(DEFAULT_COST);
 7862   size(4);
 7863   format %{ &quot;OILL    $dst,$con\t # long&quot; %}
 7864   opcode(OILL_ZOPC);
 7865   ins_encode(z_riform_unsigned(dst,con));
 7866   ins_pipe(pipe_class_dummy);
 7867 %}
 7868 
 7869 instruct orL_reg_uimm32(iRegI dst, uimmL32 con, flagsReg cr) %{
 7870   match(Set dst (OrI dst con));
 7871   effect(KILL cr);
 7872   ins_cost(DEFAULT_COST_HIGH);
 7873   // TODO: s390 port size(FIXED_SIZE);
 7874   format %{ &quot;OILF    $dst,$con\t # long&quot; %}
 7875   opcode(OILF_ZOPC);
 7876   ins_encode(z_rilform_unsigned(dst,con));
 7877   ins_pipe(pipe_class_dummy);
 7878 %}
 7879 
 7880 // XOR
 7881 
 7882 // Register Xor
 7883 instruct xorI_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7884   match(Set dst (XorI dst src));
 7885   effect(KILL cr);
 7886   size(2);
 7887   format %{ &quot;XR      $dst,$src&quot; %}
 7888   opcode(XR_ZOPC);
 7889   ins_encode(z_rrform(dst, src));
 7890   ins_pipe(pipe_class_dummy);
 7891 %}
 7892 
 7893 instruct xorI_Reg_mem(iRegI dst, memory src, flagsReg cr)%{
 7894   match(Set dst (XorI dst (LoadI src)));
 7895   effect(KILL cr);
 7896   ins_cost(MEMORY_REF_COST);
 7897   // TODO: s390 port size(VARIABLE_SIZE);
 7898   format %{ &quot;X(Y)    $dst, $src\t # int&quot; %}
 7899   opcode(XY_ZOPC, X_ZOPC);
 7900   ins_encode(z_form_rt_mem_opt(dst, src));
 7901   ins_pipe(pipe_class_dummy);
 7902 %}
 7903 
 7904 // Immediate Xor
 7905 instruct xorI_reg_uimm32(iRegI dst, uimmI src, flagsReg cr) %{
 7906   match(Set dst (XorI dst src));
 7907   effect(KILL cr);
 7908   ins_cost(DEFAULT_COST_HIGH);
 7909   size(6);
 7910   format %{ &quot;XILF    $dst,$src&quot; %}
 7911   opcode(XILF_ZOPC);
 7912   ins_encode(z_rilform_unsigned(dst, src));
 7913   ins_pipe(pipe_class_dummy);
 7914 %}
 7915 
 7916 // Register Xor Long
 7917 instruct xorL_reg_reg(iRegL dst, iRegL src, flagsReg cr) %{
 7918   match(Set dst (XorL dst src));
 7919   effect(KILL cr);
 7920   ins_cost(DEFAULT_COST);
 7921   size(4);
 7922   format %{ &quot;XGR     $dst,$src\t # long&quot; %}
 7923   opcode(XGR_ZOPC);
 7924   ins_encode(z_rreform(dst, src));
 7925   ins_pipe(pipe_class_dummy);
 7926 %}
 7927 
 7928 instruct xorL_Reg_mem(iRegL dst, memory src, flagsReg cr)%{
 7929   match(Set dst (XorL dst (LoadL src)));
 7930   effect(KILL cr);
 7931   ins_cost(MEMORY_REF_COST);
 7932   size(Z_DISP3_SIZE);
 7933   format %{ &quot;XG      $dst, $src\t # long&quot; %}
 7934   opcode(XG_ZOPC, XG_ZOPC);
 7935   ins_encode(z_form_rt_mem_opt(dst, src));
 7936   ins_pipe(pipe_class_dummy);
 7937 %}
 7938 
 7939 // Immediate Xor Long
 7940 instruct xorL_reg_uimm32(iRegL dst, uimmL32 con, flagsReg cr) %{
 7941   match(Set dst (XorL dst con));
 7942   effect(KILL cr);
 7943   ins_cost(DEFAULT_COST_HIGH);
 7944   size(6);
 7945   format %{ &quot;XILF    $dst,$con\t # long&quot; %}
 7946   opcode(XILF_ZOPC);
 7947   ins_encode(z_rilform_unsigned(dst,con));
 7948   ins_pipe(pipe_class_dummy);
 7949 %}
 7950 
 7951 //----------Convert to Boolean-------------------------------------------------
 7952 
 7953 // Convert integer to boolean.
 7954 instruct convI2B(iRegI dst, iRegI src, flagsReg cr) %{
 7955   match(Set dst (Conv2B src));
 7956   effect(KILL cr);
 7957   ins_cost(3 * DEFAULT_COST);
 7958   size(6);
 7959   format %{ &quot;convI2B $dst,$src&quot; %}
 7960   ins_encode %{
 7961     __ z_lnr($dst$$Register, $src$$Register);  // Rdst := -|Rsrc|, i.e. Rdst == 0 &lt;=&gt; Rsrc == 0
 7962     __ z_srl($dst$$Register, 31);              // Rdst := sign(Rdest)
 7963   %}
 7964   ins_pipe(pipe_class_dummy);
 7965 %}
 7966 
 7967 instruct convP2B(iRegI dst, iRegP_N2P src, flagsReg cr) %{
 7968   match(Set dst (Conv2B src));
 7969   effect(KILL cr);
 7970   ins_cost(3 * DEFAULT_COST);
 7971   size(10);
 7972   format %{ &quot;convP2B $dst,$src&quot; %}
 7973   ins_encode %{
 7974     __ z_lngr($dst$$Register, $src$$Register);     // Rdst := -|Rsrc| i.e. Rdst == 0 &lt;=&gt; Rsrc == 0
 7975     __ z_srlg($dst$$Register, $dst$$Register, 63); // Rdst := sign(Rdest)
 7976   %}
 7977   ins_pipe(pipe_class_dummy);
 7978 %}
 7979 
 7980 instruct cmpLTMask_reg_reg(iRegI dst, iRegI src, flagsReg cr) %{
 7981   match(Set dst (CmpLTMask dst src));
 7982   effect(KILL cr);
 7983   ins_cost(2 * DEFAULT_COST);
 7984   size(18);
 7985   format %{ &quot;Set $dst CmpLTMask $dst,$src&quot; %}
 7986   ins_encode %{
 7987     // Avoid signed 32 bit overflow: Do sign extend and sub 64 bit.
 7988     __ z_lgfr(Z_R0_scratch, $src$$Register);
 7989     __ z_lgfr($dst$$Register, $dst$$Register);
 7990     __ z_sgr($dst$$Register, Z_R0_scratch);
 7991     __ z_srag($dst$$Register, $dst$$Register, 63);
 7992   %}
 7993   ins_pipe(pipe_class_dummy);
 7994 %}
 7995 
 7996 instruct cmpLTMask_reg_zero(iRegI dst, immI_0 zero, flagsReg cr) %{
 7997   match(Set dst (CmpLTMask dst zero));
 7998   effect(KILL cr);
 7999   ins_cost(DEFAULT_COST);
 8000   size(4);
 8001   format %{ &quot;Set $dst CmpLTMask $dst,$zero&quot; %}
 8002   ins_encode %{ __ z_sra($dst$$Register, 31); %}
 8003   ins_pipe(pipe_class_dummy);
 8004 %}
 8005 
 8006 
 8007 //----------Arithmetic Conversion Instructions---------------------------------
 8008 // The conversions operations are all Alpha sorted. Please keep it that way!
 8009 
 8010 instruct convD2F_reg(regF dst, regD src) %{
 8011   match(Set dst (ConvD2F src));
 8012   // CC remains unchanged.
 8013   size(4);
 8014   format %{ &quot;LEDBR   $dst,$src&quot; %}
 8015   opcode(LEDBR_ZOPC);
 8016   ins_encode(z_rreform(dst, src));
 8017   ins_pipe(pipe_class_dummy);
 8018 %}
 8019 
 8020 instruct convF2I_reg(iRegI dst, regF src, flagsReg cr) %{
 8021   match(Set dst (ConvF2I src));
 8022   effect(KILL cr);
 8023   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8024   size(16);
 8025   format %{ &quot;convF2I  $dst,$src&quot; %}
 8026   ins_encode %{
 8027     Label done;
 8028     __ clear_reg($dst$$Register, false, false);  // Initialize with result for unordered: 0.
 8029     __ z_cebr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 8030     __ z_brno(done);                             // Result is zero if unordered argument.
 8031     __ z_cfebr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 8032     __ bind(done);
 8033   %}
 8034   ins_pipe(pipe_class_dummy);
 8035 %}
 8036 
 8037 instruct convD2I_reg(iRegI dst, regD src, flagsReg cr) %{
 8038   match(Set dst (ConvD2I src));
 8039   effect(KILL cr);
 8040   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8041   size(16);
 8042   format %{ &quot;convD2I  $dst,$src&quot; %}
 8043   ins_encode %{
 8044     Label done;
 8045     __ clear_reg($dst$$Register, false, false);  // Initialize with result for unordered: 0.
 8046     __ z_cdbr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 8047     __ z_brno(done);                             // Result is zero if unordered argument.
 8048     __ z_cfdbr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 8049     __ bind(done);
 8050   %}
 8051   ins_pipe(pipe_class_dummy);
 8052 %}
 8053 
 8054 instruct convF2L_reg(iRegL dst, regF src, flagsReg cr) %{
 8055   match(Set dst (ConvF2L src));
 8056   effect(KILL cr);
 8057   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8058   size(16);
 8059   format %{ &quot;convF2L  $dst,$src&quot; %}
 8060   ins_encode %{
 8061     Label done;
 8062     __ clear_reg($dst$$Register, true, false);  // Initialize with result for unordered: 0.
 8063     __ z_cebr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 8064     __ z_brno(done);                             // Result is zero if unordered argument.
 8065     __ z_cgebr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 8066     __ bind(done);
 8067   %}
 8068   ins_pipe(pipe_class_dummy);
 8069 %}
 8070 
 8071 instruct convD2L_reg(iRegL dst, regD src, flagsReg cr) %{
 8072   match(Set dst (ConvD2L src));
 8073   effect(KILL cr);
 8074   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8075   size(16);
 8076   format %{ &quot;convD2L  $dst,$src&quot; %}
 8077   ins_encode %{
 8078     Label done;
 8079     __ clear_reg($dst$$Register, true, false);  // Initialize with result for unordered: 0.
 8080     __ z_cdbr($src$$FloatRegister, $src$$FloatRegister);   // Round.
 8081     __ z_brno(done);                             // Result is zero if unordered argument.
 8082     __ z_cgdbr($dst$$Register, $src$$FloatRegister, Assembler::to_zero);
 8083     __ bind(done);
 8084   %}
 8085   ins_pipe(pipe_class_dummy);
 8086 %}
 8087 
 8088 instruct convF2D_reg(regD dst, regF src) %{
 8089   match(Set dst (ConvF2D src));
 8090   // CC remains unchanged.
 8091   size(4);
 8092   format %{ &quot;LDEBR   $dst,$src&quot; %}
 8093   opcode(LDEBR_ZOPC);
 8094   ins_encode(z_rreform(dst, src));
 8095   ins_pipe(pipe_class_dummy);
 8096 %}
 8097 
 8098 instruct convF2D_mem(regD dst, memoryRX src) %{
 8099   match(Set dst (ConvF2D src));
 8100   // CC remains unchanged.
 8101   size(6);
 8102   format %{ &quot;LDEB    $dst,$src&quot; %}
 8103   opcode(LDEB_ZOPC);
 8104   ins_encode(z_form_rt_memFP(dst, src));
 8105   ins_pipe(pipe_class_dummy);
 8106 %}
 8107 
 8108 instruct convI2D_reg(regD dst, iRegI src) %{
 8109   match(Set dst (ConvI2D src));
 8110   // CC remains unchanged.
 8111   ins_cost(DEFAULT_COST);
 8112   size(4);
 8113   format %{ &quot;CDFBR   $dst,$src&quot; %}
 8114   opcode(CDFBR_ZOPC);
 8115   ins_encode(z_rreform(dst, src));
 8116   ins_pipe(pipe_class_dummy);
 8117 %}
 8118 
 8119 // Optimization that saves up to two memory operations for each conversion.
 8120 instruct convI2F_ireg(regF dst, iRegI src) %{
 8121   match(Set dst (ConvI2F src));
 8122   // CC remains unchanged.
 8123   ins_cost(DEFAULT_COST);
 8124   size(4);
 8125   format %{ &quot;CEFBR   $dst,$src\t # convert int to float&quot; %}
 8126   opcode(CEFBR_ZOPC);
 8127   ins_encode(z_rreform(dst, src));
 8128   ins_pipe(pipe_class_dummy);
 8129 %}
 8130 
 8131 instruct convI2L_reg(iRegL dst, iRegI src) %{
 8132   match(Set dst (ConvI2L src));
 8133   size(4);
 8134   format %{ &quot;LGFR    $dst,$src\t # int-&gt;long&quot; %}
 8135   opcode(LGFR_ZOPC);
 8136   ins_encode(z_rreform(dst, src));
 8137   ins_pipe(pipe_class_dummy);
 8138 %}
 8139 
 8140 // Zero-extend convert int to long.
 8141 instruct convI2L_reg_zex(iRegL dst, iRegI src, immL_32bits mask) %{
 8142   match(Set dst (AndL (ConvI2L src) mask));
 8143   size(4);
 8144   format %{ &quot;LLGFR   $dst, $src \t # zero-extend int to long&quot; %}
 8145   ins_encode %{ __ z_llgfr($dst$$Register, $src$$Register); %}
 8146   ins_pipe(pipe_class_dummy);
 8147 %}
 8148 
 8149 // Zero-extend convert int to long.
 8150 instruct convI2L_mem_zex(iRegL dst, memory src, immL_32bits mask) %{
 8151   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
 8152   // Uses load_const_optmized, so size can vary.
 8153   // TODO: s390 port size(VARIABLE_SIZE);
 8154   format %{ &quot;LLGF    $dst, $src \t # zero-extend int to long&quot; %}
 8155   opcode(LLGF_ZOPC, LLGF_ZOPC);
 8156   ins_encode(z_form_rt_mem_opt(dst, src));
 8157   ins_pipe(pipe_class_dummy);
 8158 %}
 8159 
 8160 // Zero-extend long
 8161 instruct zeroExtend_long(iRegL dst, iRegL src, immL_32bits mask) %{
 8162   match(Set dst (AndL src mask));
 8163   size(4);
 8164   format %{ &quot;LLGFR   $dst, $src \t # zero-extend long to long&quot; %}
 8165   ins_encode %{ __ z_llgfr($dst$$Register, $src$$Register); %}
 8166   ins_pipe(pipe_class_dummy);
 8167 %}
 8168 
 8169 instruct rShiftI16_lShiftI16_reg(iRegI dst, iRegI src, immI_16 amount) %{
 8170   match(Set dst (RShiftI (LShiftI src amount) amount));
 8171   size(4);
 8172   format %{ &quot;LHR     $dst,$src\t short-&gt;int&quot; %}
 8173   opcode(LHR_ZOPC);
 8174   ins_encode(z_rreform(dst, src));
 8175   ins_pipe(pipe_class_dummy);
 8176 %}
 8177 
 8178 instruct rShiftI24_lShiftI24_reg(iRegI dst, iRegI src, immI_24 amount) %{
 8179   match(Set dst (RShiftI (LShiftI src amount) amount));
 8180   size(4);
 8181   format %{ &quot;LBR     $dst,$src\t byte-&gt;int&quot; %}
 8182   opcode(LBR_ZOPC);
 8183   ins_encode(z_rreform(dst, src));
 8184   ins_pipe(pipe_class_dummy);
 8185 %}
 8186 
 8187 instruct MoveF2I_stack_reg(iRegI dst, stackSlotF src) %{
 8188   match(Set dst (MoveF2I src));
 8189   ins_cost(MEMORY_REF_COST);
 8190   size(4);
 8191   format %{ &quot;L       $dst,$src\t # MoveF2I&quot; %}
 8192   opcode(L_ZOPC);
 8193   ins_encode(z_form_rt_mem(dst, src));
 8194   ins_pipe(pipe_class_dummy);
 8195 %}
 8196 
 8197 // javax.imageio.stream.ImageInputStreamImpl.toFloats([B[FII)
 8198 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
 8199   match(Set dst (MoveI2F src));
 8200   ins_cost(MEMORY_REF_COST);
 8201   // TODO: s390 port size(FIXED_SIZE);
 8202   format %{ &quot;LE      $dst,$src\t # MoveI2F&quot; %}
 8203   opcode(LE_ZOPC);
 8204   ins_encode(z_form_rt_mem(dst, src));
 8205   ins_pipe(pipe_class_dummy);
 8206 %}
 8207 
 8208 instruct MoveD2L_stack_reg(iRegL dst, stackSlotD src) %{
 8209   match(Set dst (MoveD2L src));
 8210   ins_cost(MEMORY_REF_COST);
 8211   size(6);
 8212   format %{ &quot;LG      $src,$dst\t # MoveD2L&quot; %}
 8213   opcode(LG_ZOPC);
 8214   ins_encode(z_form_rt_mem(dst, src));
 8215   ins_pipe(pipe_class_dummy);
 8216 %}
 8217 
 8218 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
 8219   match(Set dst (MoveL2D src));
 8220   ins_cost(MEMORY_REF_COST);
 8221   size(4);
 8222   format %{ &quot;LD      $dst,$src\t # MoveL2D&quot; %}
 8223   opcode(LD_ZOPC);
 8224   ins_encode(z_form_rt_mem(dst, src));
 8225   ins_pipe(pipe_class_dummy);
 8226 %}
 8227 
 8228 instruct MoveI2F_reg_stack(stackSlotF dst, iRegI src) %{
 8229   match(Set dst (MoveI2F src));
 8230   ins_cost(MEMORY_REF_COST);
 8231   size(4);
 8232   format %{ &quot;ST      $src,$dst\t # MoveI2F&quot; %}
 8233   opcode(ST_ZOPC);
 8234   ins_encode(z_form_rt_mem(src, dst));
 8235   ins_pipe(pipe_class_dummy);
 8236 %}
 8237 
 8238 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
 8239   match(Set dst (MoveD2L src));
 8240   effect(DEF dst, USE src);
 8241   ins_cost(MEMORY_REF_COST);
 8242   size(4);
 8243   format %{ &quot;STD     $src,$dst\t # MoveD2L&quot; %}
 8244   opcode(STD_ZOPC);
 8245   ins_encode(z_form_rt_mem(src,dst));
 8246   ins_pipe(pipe_class_dummy);
 8247 %}
 8248 
 8249 instruct MoveL2D_reg_stack(stackSlotD dst, iRegL src) %{
 8250   match(Set dst (MoveL2D src));
 8251   ins_cost(MEMORY_REF_COST);
 8252   size(6);
 8253   format %{ &quot;STG     $src,$dst\t # MoveL2D&quot; %}
 8254   opcode(STG_ZOPC);
 8255   ins_encode(z_form_rt_mem(src,dst));
 8256   ins_pipe(pipe_class_dummy);
 8257 %}
 8258 
 8259 instruct convL2F_reg(regF dst, iRegL src) %{
 8260   match(Set dst (ConvL2F src));
 8261   // CC remains unchanged.
 8262   ins_cost(DEFAULT_COST);
 8263   size(4);
 8264   format %{ &quot;CEGBR   $dst,$src&quot; %}
 8265   opcode(CEGBR_ZOPC);
 8266   ins_encode(z_rreform(dst, src));
 8267   ins_pipe(pipe_class_dummy);
 8268 %}
 8269 
 8270 instruct convL2D_reg(regD dst, iRegL src) %{
 8271   match(Set dst (ConvL2D src));
 8272   // CC remains unchanged.
 8273   ins_cost(DEFAULT_COST);
 8274   size(4);
 8275   format %{ &quot;CDGBR   $dst,$src&quot; %}
 8276   opcode(CDGBR_ZOPC);
 8277   ins_encode(z_rreform(dst, src));
 8278   ins_pipe(pipe_class_dummy);
 8279 %}
 8280 
 8281 instruct convL2I_reg(iRegI dst, iRegL src) %{
 8282   match(Set dst (ConvL2I src));
 8283   // TODO: s390 port size(VARIABLE_SIZE);
 8284   format %{ &quot;LR      $dst,$src\t # long-&gt;int (if needed)&quot; %}
 8285   ins_encode %{ __ lr_if_needed($dst$$Register, $src$$Register); %}
 8286   ins_pipe(pipe_class_dummy);
 8287 %}
 8288 
 8289 // Register Shift Right Immediate
 8290 instruct shrL_reg_imm6_L2I(iRegI dst, iRegL src, immI_32_63 cnt, flagsReg cr) %{
 8291   match(Set dst (ConvL2I (RShiftL src cnt)));
 8292   effect(KILL cr);
 8293   size(6);
 8294   format %{ &quot;SRAG    $dst,$src,$cnt&quot; %}
 8295   opcode(SRAG_ZOPC);
 8296   ins_encode(z_rsyform_const(dst, src, cnt));
 8297   ins_pipe(pipe_class_dummy);
 8298 %}
 8299 
 8300 //----------TRAP based zero checks and range checks----------------------------
 8301 
 8302 // SIGTRAP based implicit range checks in compiled code.
 8303 // A range check in the ideal world has one of the following shapes:
 8304 //   - (If le (CmpU length index)), (IfTrue  throw exception)
 8305 //   - (If lt (CmpU index length)), (IfFalse throw exception)
 8306 //
 8307 // Match range check &#39;If le (CmpU length index)&#39;
 8308 instruct rangeCheck_iReg_uimmI16(cmpOpT cmp, iRegI length, uimmI16 index, label labl) %{
 8309   match(If cmp (CmpU length index));
 8310   effect(USE labl);
 8311   predicate(TrapBasedRangeChecks &amp;&amp;
 8312             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le &amp;&amp;
 8313             PROB_UNLIKELY(_leaf-&gt;as_If ()-&gt;_prob) &gt;= PROB_ALWAYS &amp;&amp;
 8314             Matcher::branches_to_uncommon_trap(_leaf));
 8315   ins_cost(1);
 8316   // TODO: s390 port size(FIXED_SIZE);
 8317 
 8318   ins_is_TrapBasedCheckNode(true);
 8319 
 8320   format %{ &quot;RangeCheck len=$length cmp=$cmp idx=$index =&gt; trap $labl&quot; %}
 8321   ins_encode %{ __ z_clfit($length$$Register, $index$$constant, $cmp$$cmpcode); %}
 8322   ins_pipe(pipe_class_trap);
 8323 %}
 8324 
 8325 // Match range check &#39;If lt (CmpU index length)&#39;
 8326 instruct rangeCheck_iReg_iReg(cmpOpT cmp, iRegI index, iRegI length, label labl, flagsReg cr) %{
 8327   match(If cmp (CmpU index length));
 8328   effect(USE labl, KILL cr);
 8329   predicate(TrapBasedRangeChecks &amp;&amp;
 8330             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
 8331             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
 8332             Matcher::branches_to_uncommon_trap(_leaf));
 8333   ins_cost(1);
 8334   // TODO: s390 port size(FIXED_SIZE);
 8335 
 8336   ins_is_TrapBasedCheckNode(true);
 8337 
 8338   format %{ &quot;RangeCheck idx=$index cmp=$cmp len=$length =&gt; trap $labl&quot; %}
 8339   ins_encode %{ __ z_clrt($index$$Register, $length$$Register, $cmp$$cmpcode); %}
 8340   ins_pipe(pipe_class_trap);
 8341 %}
 8342 
 8343 // Match range check &#39;If lt (CmpU index length)&#39;
 8344 instruct rangeCheck_uimmI16_iReg(cmpOpT cmp, iRegI index, uimmI16 length, label labl) %{
 8345   match(If cmp (CmpU index length));
 8346   effect(USE labl);
 8347   predicate(TrapBasedRangeChecks &amp;&amp;
 8348             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
 8349             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
 8350             Matcher::branches_to_uncommon_trap(_leaf));
 8351   ins_cost(1);
 8352   // TODO: s390 port size(FIXED_SIZE);
 8353 
 8354   ins_is_TrapBasedCheckNode(true);
 8355 
 8356   format %{ &quot;RangeCheck idx=$index cmp=$cmp len= $length =&gt; trap $labl&quot; %}
 8357   ins_encode %{ __ z_clfit($index$$Register, $length$$constant, $cmp$$cmpcode); %}
 8358   ins_pipe(pipe_class_trap);
 8359 %}
 8360 
 8361 // Implicit zero checks (more implicit null checks).
 8362 instruct zeroCheckP_iReg_imm0(cmpOpT cmp, iRegP_N2P value, immP0 zero, label labl) %{
 8363   match(If cmp (CmpP value zero));
 8364   effect(USE labl);
 8365   predicate(TrapBasedNullChecks &amp;&amp;
 8366             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
 8367             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
 8368             Matcher::branches_to_uncommon_trap(_leaf));
 8369   size(6);
 8370 
 8371   ins_is_TrapBasedCheckNode(true);
 8372 
 8373   format %{ &quot;ZeroCheckP value=$value cmp=$cmp zero=$zero =&gt; trap $labl&quot; %}
 8374   ins_encode %{ __ z_cgit($value$$Register, 0, $cmp$$cmpcode); %}
 8375   ins_pipe(pipe_class_trap);
 8376 %}
 8377 
 8378 // Implicit zero checks (more implicit null checks).
 8379 instruct zeroCheckN_iReg_imm0(cmpOpT cmp, iRegN_P2N value, immN0 zero, label labl) %{
 8380   match(If cmp (CmpN value zero));
 8381   effect(USE labl);
 8382   predicate(TrapBasedNullChecks &amp;&amp;
 8383             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
 8384             _leaf-&gt;as_If ()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
 8385             Matcher::branches_to_uncommon_trap(_leaf));
 8386   size(6);
 8387 
 8388   ins_is_TrapBasedCheckNode(true);
 8389 
 8390   format %{ &quot;ZeroCheckN value=$value cmp=$cmp zero=$zero =&gt; trap $labl&quot; %}
 8391   ins_encode %{ __ z_cit($value$$Register, 0, $cmp$$cmpcode); %}
 8392   ins_pipe(pipe_class_trap);
 8393 %}
 8394 
 8395 //----------Compare instructions-----------------------------------------------
 8396 
 8397 // INT signed
 8398 
 8399 // Compare Integers
 8400 instruct compI_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 8401   match(Set cr (CmpI op1 op2));
 8402   size(2);
 8403   format %{ &quot;CR      $op1,$op2&quot; %}
 8404   opcode(CR_ZOPC);
 8405   ins_encode(z_rrform(op1, op2));
 8406   ins_pipe(pipe_class_dummy);
 8407 %}
 8408 
 8409 instruct compI_reg_imm(flagsReg cr, iRegI op1, immI op2) %{
 8410   match(Set cr (CmpI op1 op2));
 8411   size(6);
 8412   format %{ &quot;CFI     $op1,$op2&quot; %}
 8413   opcode(CFI_ZOPC);
 8414   ins_encode(z_rilform_signed(op1, op2));
 8415   ins_pipe(pipe_class_dummy);
 8416 %}
 8417 
 8418 instruct compI_reg_imm16(flagsReg cr, iRegI op1, immI16 op2) %{
 8419   match(Set cr (CmpI op1 op2));
 8420   size(4);
 8421   format %{ &quot;CHI     $op1,$op2&quot; %}
 8422   opcode(CHI_ZOPC);
 8423   ins_encode(z_riform_signed(op1, op2));
 8424   ins_pipe(pipe_class_dummy);
 8425 %}
 8426 
 8427 instruct compI_reg_imm0(flagsReg cr, iRegI op1, immI_0 zero) %{
 8428   match(Set cr (CmpI op1 zero));
 8429   ins_cost(DEFAULT_COST_LOW);
 8430   size(2);
 8431   format %{ &quot;LTR     $op1,$op1&quot; %}
 8432   opcode(LTR_ZOPC);
 8433   ins_encode(z_rrform(op1, op1));
 8434   ins_pipe(pipe_class_dummy);
 8435 %}
 8436 
 8437 instruct compI_reg_mem(flagsReg cr, iRegI op1, memory op2)%{
 8438   match(Set cr (CmpI op1 (LoadI op2)));
 8439   ins_cost(MEMORY_REF_COST);
 8440   // TODO: s390 port size(VARIABLE_SIZE);
 8441   format %{ &quot;C(Y)    $op1, $op2\t # int&quot; %}
 8442   opcode(CY_ZOPC, C_ZOPC);
 8443   ins_encode(z_form_rt_mem_opt(op1, op2));
 8444   ins_pipe(pipe_class_dummy);
 8445 %}
 8446 
 8447 // INT unsigned
 8448 
 8449 instruct compU_reg_reg(flagsReg cr, iRegI op1, iRegI op2) %{
 8450   match(Set cr (CmpU op1 op2));
 8451   size(2);
 8452   format %{ &quot;CLR     $op1,$op2\t # unsigned&quot; %}
 8453   opcode(CLR_ZOPC);
 8454   ins_encode(z_rrform(op1, op2));
 8455   ins_pipe(pipe_class_dummy);
 8456 %}
 8457 
 8458 instruct compU_reg_uimm(flagsReg cr, iRegI op1, uimmI op2) %{
 8459   match(Set cr (CmpU op1 op2));
 8460   size(6);
 8461   format %{ &quot;CLFI    $op1,$op2\t # unsigned&quot; %}
 8462   opcode(CLFI_ZOPC);
 8463   ins_encode(z_rilform_unsigned(op1, op2));
 8464   ins_pipe(pipe_class_dummy);
 8465 %}
 8466 
 8467 instruct compU_reg_mem(flagsReg cr, iRegI op1, memory op2)%{
 8468   match(Set cr (CmpU op1 (LoadI op2)));
 8469   ins_cost(MEMORY_REF_COST);
 8470   // TODO: s390 port size(VARIABLE_SIZE);
 8471   format %{ &quot;CL(Y)   $op1, $op2\t # unsigned&quot; %}
 8472   opcode(CLY_ZOPC, CL_ZOPC);
 8473   ins_encode(z_form_rt_mem_opt(op1, op2));
 8474   ins_pipe(pipe_class_dummy);
 8475 %}
 8476 
 8477 // LONG signed
 8478 
 8479 instruct compL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 8480   match(Set cr (CmpL op1 op2));
 8481   size(4);
 8482   format %{ &quot;CGR     $op1,$op2\t # long&quot; %}
 8483   opcode(CGR_ZOPC);
 8484   ins_encode(z_rreform(op1, op2));
 8485   ins_pipe(pipe_class_dummy);
 8486 %}
 8487 
 8488 instruct compL_reg_regI(flagsReg cr, iRegL op1, iRegI op2) %{
 8489   match(Set cr (CmpL op1 (ConvI2L op2)));
 8490   size(4);
 8491   format %{ &quot;CGFR    $op1,$op2\t # long/int&quot; %}
 8492   opcode(CGFR_ZOPC);
 8493   ins_encode(z_rreform(op1, op2));
 8494   ins_pipe(pipe_class_dummy);
 8495 %}
 8496 
 8497 instruct compL_reg_imm32(flagsReg cr, iRegL op1, immL32 con) %{
 8498   match(Set cr (CmpL op1 con));
 8499   size(6);
 8500   format %{ &quot;CGFI    $op1,$con&quot; %}
 8501   opcode(CGFI_ZOPC);
 8502   ins_encode(z_rilform_signed(op1, con));
 8503   ins_pipe(pipe_class_dummy);
 8504 %}
 8505 
 8506 instruct compL_reg_imm16(flagsReg cr, iRegL op1, immL16 con) %{
 8507   match(Set cr (CmpL op1 con));
 8508   size(4);
 8509   format %{ &quot;CGHI    $op1,$con&quot; %}
 8510   opcode(CGHI_ZOPC);
 8511   ins_encode(z_riform_signed(op1, con));
 8512   ins_pipe(pipe_class_dummy);
 8513 %}
 8514 
 8515 instruct compL_reg_imm0(flagsReg cr, iRegL op1, immL_0 con) %{
 8516   match(Set cr (CmpL op1 con));
 8517   ins_cost(DEFAULT_COST_LOW);
 8518   size(4);
 8519   format %{ &quot;LTGR    $op1,$op1&quot; %}
 8520   opcode(LTGR_ZOPC);
 8521   ins_encode(z_rreform(op1, op1));
 8522   ins_pipe(pipe_class_dummy);
 8523 %}
 8524 
 8525 instruct compL_conv_reg_imm0(flagsReg cr, iRegI op1, immL_0 con) %{
 8526   match(Set cr (CmpL (ConvI2L op1) con));
 8527   ins_cost(DEFAULT_COST_LOW);
 8528   size(4);
 8529   format %{ &quot;LTGFR    $op1,$op1&quot; %}
 8530   opcode(LTGFR_ZOPC);
 8531   ins_encode(z_rreform(op1, op1));
 8532   ins_pipe(pipe_class_dummy);
 8533 %}
 8534 
 8535 instruct compL_reg_mem(iRegL dst, memory src, flagsReg cr)%{
 8536   match(Set cr (CmpL dst (LoadL src)));
 8537   ins_cost(MEMORY_REF_COST);
 8538   size(Z_DISP3_SIZE);
 8539   format %{ &quot;CG      $dst, $src\t # long&quot; %}
 8540   opcode(CG_ZOPC, CG_ZOPC);
 8541   ins_encode(z_form_rt_mem_opt(dst, src));
 8542   ins_pipe(pipe_class_dummy);
 8543 %}
 8544 
 8545 instruct compL_reg_memI(iRegL dst, memory src, flagsReg cr)%{
 8546   match(Set cr (CmpL dst (ConvI2L (LoadI src))));
 8547   ins_cost(MEMORY_REF_COST);
 8548   size(Z_DISP3_SIZE);
 8549   format %{ &quot;CGF     $dst, $src\t # long/int&quot; %}
 8550   opcode(CGF_ZOPC, CGF_ZOPC);
 8551   ins_encode(z_form_rt_mem_opt(dst, src));
 8552   ins_pipe(pipe_class_dummy);
 8553 %}
 8554 
 8555 //  LONG unsigned
 8556 // Added CmpUL for LoopPredicate.
 8557 instruct compUL_reg_reg(flagsReg cr, iRegL op1, iRegL op2) %{
 8558   match(Set cr (CmpUL op1 op2));
 8559   size(4);
 8560   format %{ &quot;CLGR    $op1,$op2\t # long&quot; %}
 8561   opcode(CLGR_ZOPC);
 8562   ins_encode(z_rreform(op1, op2));
 8563   ins_pipe(pipe_class_dummy);
 8564 %}
 8565 
 8566 instruct compUL_reg_imm32(flagsReg cr, iRegL op1, uimmL32 con) %{
 8567   match(Set cr (CmpUL op1 con));
 8568   size(6);
 8569   format %{ &quot;CLGFI   $op1,$con&quot; %}
 8570   opcode(CLGFI_ZOPC);
 8571   ins_encode(z_rilform_unsigned(op1, con));
 8572   ins_pipe(pipe_class_dummy);
 8573 %}
 8574 
 8575 //  PTR unsigned
 8576 
 8577 instruct compP_reg_reg(flagsReg cr, iRegP_N2P op1, iRegP_N2P op2) %{
 8578   match(Set cr (CmpP op1 op2));
 8579   size(4);
 8580   format %{ &quot;CLGR    $op1,$op2\t # ptr&quot; %}
 8581   opcode(CLGR_ZOPC);
 8582   ins_encode(z_rreform(op1, op2));
 8583   ins_pipe(pipe_class_dummy);
 8584 %}
 8585 
 8586 instruct compP_reg_imm0(flagsReg cr, iRegP_N2P op1, immP0 op2) %{
 8587   match(Set cr (CmpP op1 op2));
 8588   ins_cost(DEFAULT_COST_LOW);
 8589   size(4);
 8590   format %{ &quot;LTGR    $op1, $op1\t # ptr&quot; %}
 8591   opcode(LTGR_ZOPC);
 8592   ins_encode(z_rreform(op1, op1));
 8593   ins_pipe(pipe_class_dummy);
 8594 %}
 8595 
 8596 // Don&#39;t use LTGFR which performs sign extend.
 8597 instruct compP_decode_reg_imm0(flagsReg cr, iRegN op1, immP0 op2) %{
 8598   match(Set cr (CmpP (DecodeN op1) op2));
 8599   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0);
 8600   ins_cost(DEFAULT_COST_LOW);
 8601   size(2);
 8602   format %{ &quot;LTR    $op1, $op1\t # ptr&quot; %}
 8603   opcode(LTR_ZOPC);
 8604   ins_encode(z_rrform(op1, op1));
 8605   ins_pipe(pipe_class_dummy);
 8606 %}
 8607 
 8608 instruct compP_reg_mem(iRegP dst, memory src, flagsReg cr)%{
 8609   match(Set cr (CmpP dst (LoadP src)));
 8610   ins_cost(MEMORY_REF_COST);
 8611   size(Z_DISP3_SIZE);
 8612   format %{ &quot;CLG     $dst, $src\t # ptr&quot; %}
 8613   opcode(CLG_ZOPC, CLG_ZOPC);
 8614   ins_encode(z_form_rt_mem_opt(dst, src));
 8615   ins_pipe(pipe_class_dummy);
 8616 %}
 8617 
 8618 //----------Max and Min--------------------------------------------------------
 8619 
 8620 // Max Register with Register
 8621 instruct z196_minI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8622   match(Set dst (MinI src1 src2));
 8623   effect(KILL cr);
 8624   predicate(VM_Version::has_LoadStoreConditional());
 8625   ins_cost(3 * DEFAULT_COST);
 8626   // TODO: s390 port size(VARIABLE_SIZE);
 8627   format %{ &quot;MinI $dst $src1,$src2\t MinI (z196 only)&quot; %}
 8628   ins_encode %{
 8629     Register Rdst = $dst$$Register;
 8630     Register Rsrc1 = $src1$$Register;
 8631     Register Rsrc2 = $src2$$Register;
 8632 
 8633     if (Rsrc1 == Rsrc2) {
 8634       if (Rdst != Rsrc1) {
 8635         __ z_lgfr(Rdst, Rsrc1);
 8636       }
 8637     } else if (Rdst == Rsrc1) {   // Rdst preset with src1.
 8638       __ z_cr(Rsrc1, Rsrc2);      // Move src2 only if src1 is NotLow.
 8639       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotLow);
 8640     } else if (Rdst == Rsrc2) {   // Rdst preset with src2.
 8641       __ z_cr(Rsrc2, Rsrc1);      // Move src1 only if src2 is NotLow.
 8642       __ z_locr(Rdst, Rsrc1, Assembler::bcondNotLow);
 8643     } else {
 8644       // Rdst is disjoint from operands, move in either case.
 8645       __ z_cr(Rsrc1, Rsrc2);
 8646       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotLow);
 8647       __ z_locr(Rdst, Rsrc1, Assembler::bcondLow);
 8648     }
 8649   %}
 8650   ins_pipe(pipe_class_dummy);
 8651 %}
 8652 
 8653 // Min Register with Register.
 8654 instruct z10_minI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8655   match(Set dst (MinI src1 src2));
 8656   effect(KILL cr);
 8657   predicate(VM_Version::has_CompareBranch());
 8658   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8659   // TODO: s390 port size(VARIABLE_SIZE);
 8660   format %{ &quot;MinI $dst $src1,$src2\t MinI (z10 only)&quot; %}
 8661   ins_encode %{
 8662     Register Rdst = $dst$$Register;
 8663     Register Rsrc1 = $src1$$Register;
 8664     Register Rsrc2 = $src2$$Register;
 8665     Label done;
 8666 
 8667     if (Rsrc1 == Rsrc2) {
 8668       if (Rdst != Rsrc1) {
 8669         __ z_lgfr(Rdst, Rsrc1);
 8670       }
 8671     } else if (Rdst == Rsrc1) {
 8672       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondLow, done);
 8673       __ z_lgfr(Rdst, Rsrc2);
 8674     } else if (Rdst == Rsrc2) {
 8675       __ z_crj(Rsrc2, Rsrc1, Assembler::bcondLow, done);
 8676       __ z_lgfr(Rdst, Rsrc1);
 8677     } else {
 8678       __ z_lgfr(Rdst, Rsrc1);
 8679       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondLow, done);
 8680       __ z_lgfr(Rdst, Rsrc2);
 8681     }
 8682     __ bind(done);
 8683   %}
 8684   ins_pipe(pipe_class_dummy);
 8685 %}
 8686 
 8687 instruct minI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8688   match(Set dst (MinI src1 src2));
 8689   effect(KILL cr);
 8690   predicate(!VM_Version::has_CompareBranch());
 8691   ins_cost(3 * DEFAULT_COST + BRANCH_COST);
 8692   // TODO: s390 port size(VARIABLE_SIZE);
 8693   format %{ &quot;MinI $dst $src1,$src2\t MinI&quot; %}
 8694   ins_encode %{
 8695     Register Rdst = $dst$$Register;
 8696     Register Rsrc1 = $src1$$Register;
 8697     Register Rsrc2 = $src2$$Register;
 8698     Label done;
 8699 
 8700     if (Rsrc1 == Rsrc2) {
 8701       if (Rdst != Rsrc1) {
 8702         __ z_lgfr(Rdst, Rsrc1);
 8703       }
 8704     } else if (Rdst == Rsrc1) {
 8705       __ z_cr(Rsrc1, Rsrc2);
 8706       __ z_brl(done);
 8707       __ z_lgfr(Rdst, Rsrc2);
 8708     } else if (Rdst == Rsrc2) {
 8709       __ z_cr(Rsrc2, Rsrc1);
 8710       __ z_brl(done);
 8711       __ z_lgfr(Rdst, Rsrc1);
 8712     } else {
 8713       __ z_lgfr(Rdst, Rsrc1);
 8714       __ z_cr(Rsrc1, Rsrc2);
 8715       __ z_brl(done);
 8716       __ z_lgfr(Rdst, Rsrc2);
 8717     }
 8718     __ bind(done);
 8719   %}
 8720   ins_pipe(pipe_class_dummy);
 8721 %}
 8722 
 8723 instruct z196_minI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8724   match(Set dst (MinI src1 src2));
 8725   effect(KILL cr);
 8726   predicate(VM_Version::has_LoadStoreConditional());
 8727   ins_cost(3 * DEFAULT_COST);
 8728   // TODO: s390 port size(VARIABLE_SIZE);
 8729   format %{ &quot;MinI $dst $src1,$src2\t MinI const32 (z196 only)&quot; %}
 8730   ins_encode %{
 8731     Register Rdst = $dst$$Register;
 8732     Register Rsrc1 = $src1$$Register;
 8733     int      Isrc2 = $src2$$constant;
 8734 
 8735     if (Rdst == Rsrc1) {
 8736       __ load_const_optimized(Z_R0_scratch, Isrc2);
 8737       __ z_cfi(Rsrc1, Isrc2);
 8738       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotLow);
 8739     } else {
 8740       __ load_const_optimized(Rdst, Isrc2);
 8741       __ z_cfi(Rsrc1, Isrc2);
 8742       __ z_locr(Rdst, Rsrc1, Assembler::bcondLow);
 8743     }
 8744   %}
 8745   ins_pipe(pipe_class_dummy);
 8746 %}
 8747 
 8748 instruct minI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8749   match(Set dst (MinI src1 src2));
 8750   effect(KILL cr);
 8751   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8752   // TODO: s390 port size(VARIABLE_SIZE);
 8753   format %{ &quot;MinI $dst $src1,$src2\t MinI const32&quot; %}
 8754   ins_encode %{
 8755     Label done;
 8756     if ($dst$$Register != $src1$$Register) {
 8757       __ z_lgfr($dst$$Register, $src1$$Register);
 8758     }
 8759     __ z_cfi($src1$$Register, $src2$$constant);
 8760     __ z_brl(done);
 8761     __ z_lgfi($dst$$Register, $src2$$constant);
 8762     __ bind(done);
 8763   %}
 8764   ins_pipe(pipe_class_dummy);
 8765 %}
 8766 
 8767 instruct z196_minI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 8768   match(Set dst (MinI src1 src2));
 8769   effect(KILL cr);
 8770   predicate(VM_Version::has_LoadStoreConditional());
 8771   ins_cost(3 * DEFAULT_COST);
 8772   // TODO: s390 port size(VARIABLE_SIZE);
 8773   format %{ &quot;MinI $dst $src1,$src2\t MinI const16 (z196 only)&quot; %}
 8774   ins_encode %{
 8775     Register Rdst = $dst$$Register;
 8776     Register Rsrc1 = $src1$$Register;
 8777     int      Isrc2 = $src2$$constant;
 8778 
 8779     if (Rdst == Rsrc1) {
 8780       __ load_const_optimized(Z_R0_scratch, Isrc2);
 8781       __ z_chi(Rsrc1, Isrc2);
 8782       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotLow);
 8783     } else {
 8784       __ load_const_optimized(Rdst, Isrc2);
 8785       __ z_chi(Rsrc1, Isrc2);
 8786       __ z_locr(Rdst, Rsrc1, Assembler::bcondLow);
 8787     }
 8788   %}
 8789   ins_pipe(pipe_class_dummy);
 8790 %}
 8791 
 8792 instruct minI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 8793   match(Set dst (MinI src1 src2));
 8794   effect(KILL cr);
 8795   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8796   // TODO: s390 port size(VARIABLE_SIZE);
 8797   format %{ &quot;MinI $dst $src1,$src2\t MinI const16&quot; %}
 8798   ins_encode %{
 8799     Label done;
 8800     if ($dst$$Register != $src1$$Register) {
 8801       __ z_lgfr($dst$$Register, $src1$$Register);
 8802     }
 8803     __ z_chi($src1$$Register, $src2$$constant);
 8804     __ z_brl(done);
 8805     __ z_lghi($dst$$Register, $src2$$constant);
 8806     __ bind(done);
 8807   %}
 8808   ins_pipe(pipe_class_dummy);
 8809 %}
 8810 
 8811 instruct z10_minI_reg_imm8(iRegI dst, iRegI src1, immI8 src2, flagsReg cr) %{
 8812   match(Set dst (MinI src1 src2));
 8813   effect(KILL cr);
 8814   predicate(VM_Version::has_CompareBranch());
 8815   ins_cost(DEFAULT_COST + BRANCH_COST);
 8816   // TODO: s390 port size(VARIABLE_SIZE);
 8817   format %{ &quot;MinI $dst $src1,$src2\t MinI const8 (z10 only)&quot; %}
 8818   ins_encode %{
 8819     Label done;
 8820     if ($dst$$Register != $src1$$Register) {
 8821       __ z_lgfr($dst$$Register, $src1$$Register);
 8822     }
 8823     __ z_cij($src1$$Register, $src2$$constant, Assembler::bcondLow, done);
 8824     __ z_lghi($dst$$Register, $src2$$constant);
 8825     __ bind(done);
 8826   %}
 8827   ins_pipe(pipe_class_dummy);
 8828 %}
 8829 
 8830 // Max Register with Register
 8831 instruct z196_maxI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8832   match(Set dst (MaxI src1 src2));
 8833   effect(KILL cr);
 8834   predicate(VM_Version::has_LoadStoreConditional());
 8835   ins_cost(3 * DEFAULT_COST);
 8836   // TODO: s390 port size(VARIABLE_SIZE);
 8837   format %{ &quot;MaxI $dst $src1,$src2\t MaxI (z196 only)&quot; %}
 8838   ins_encode %{
 8839     Register Rdst = $dst$$Register;
 8840     Register Rsrc1 = $src1$$Register;
 8841     Register Rsrc2 = $src2$$Register;
 8842 
 8843     if (Rsrc1 == Rsrc2) {
 8844       if (Rdst != Rsrc1) {
 8845         __ z_lgfr(Rdst, Rsrc1);
 8846       }
 8847     } else if (Rdst == Rsrc1) { // Rdst preset with src1.
 8848       __ z_cr(Rsrc1, Rsrc2);    // Move src2 only if src1 is NotHigh.
 8849       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotHigh);
 8850     } else if (Rdst == Rsrc2) { // Rdst preset with src2.
 8851       __ z_cr(Rsrc2, Rsrc1);    // Move src1 only if src2 is NotHigh.
 8852       __ z_locr(Rdst, Rsrc1, Assembler::bcondNotHigh);
 8853     } else {                    // Rdst is disjoint from operands, move in either case.
 8854       __ z_cr(Rsrc1, Rsrc2);
 8855       __ z_locr(Rdst, Rsrc2, Assembler::bcondNotHigh);
 8856       __ z_locr(Rdst, Rsrc1, Assembler::bcondHigh);
 8857     }
 8858   %}
 8859   ins_pipe(pipe_class_dummy);
 8860 %}
 8861 
 8862 // Max Register with Register
 8863 instruct z10_maxI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8864   match(Set dst (MaxI src1 src2));
 8865   effect(KILL cr);
 8866   predicate(VM_Version::has_CompareBranch());
 8867   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8868   // TODO: s390 port size(VARIABLE_SIZE);
 8869   format %{ &quot;MaxI $dst $src1,$src2\t MaxI (z10 only)&quot; %}
 8870   ins_encode %{
 8871     Register Rdst = $dst$$Register;
 8872     Register Rsrc1 = $src1$$Register;
 8873     Register Rsrc2 = $src2$$Register;
 8874     Label done;
 8875 
 8876     if (Rsrc1 == Rsrc2) {
 8877       if (Rdst != Rsrc1) {
 8878         __ z_lgfr(Rdst, Rsrc1);
 8879       }
 8880     } else if (Rdst == Rsrc1) {
 8881       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondHigh, done);
 8882       __ z_lgfr(Rdst, Rsrc2);
 8883     } else if (Rdst == Rsrc2) {
 8884       __ z_crj(Rsrc2, Rsrc1, Assembler::bcondHigh, done);
 8885       __ z_lgfr(Rdst, Rsrc1);
 8886     } else {
 8887       __ z_lgfr(Rdst, Rsrc1);
 8888       __ z_crj(Rsrc1, Rsrc2, Assembler::bcondHigh, done);
 8889       __ z_lgfr(Rdst, Rsrc2);
 8890     }
 8891     __ bind(done);
 8892   %}
 8893   ins_pipe(pipe_class_dummy);
 8894 %}
 8895 
 8896 instruct maxI_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 8897   match(Set dst (MaxI src1 src2));
 8898   effect(KILL cr);
 8899   predicate(!VM_Version::has_CompareBranch());
 8900   ins_cost(3 * DEFAULT_COST + BRANCH_COST);
 8901   // TODO: s390 port size(VARIABLE_SIZE);
 8902   format %{ &quot;MaxI $dst $src1,$src2\t MaxI&quot; %}
 8903   ins_encode %{
 8904     Register Rdst = $dst$$Register;
 8905     Register Rsrc1 = $src1$$Register;
 8906     Register Rsrc2 = $src2$$Register;
 8907     Label done;
 8908 
 8909     if (Rsrc1 == Rsrc2) {
 8910       if (Rdst != Rsrc1) {
 8911         __ z_lgfr(Rdst, Rsrc1);
 8912       }
 8913     } else if (Rdst == Rsrc1) {
 8914       __ z_cr(Rsrc1, Rsrc2);
 8915       __ z_brh(done);
 8916       __ z_lgfr(Rdst, Rsrc2);
 8917     } else if (Rdst == Rsrc2) {
 8918       __ z_cr(Rsrc2, Rsrc1);
 8919       __ z_brh(done);
 8920       __ z_lgfr(Rdst, Rsrc1);
 8921     } else {
 8922       __ z_lgfr(Rdst, Rsrc1);
 8923       __ z_cr(Rsrc1, Rsrc2);
 8924       __ z_brh(done);
 8925       __ z_lgfr(Rdst, Rsrc2);
 8926     }
 8927 
 8928     __ bind(done);
 8929   %}
 8930 
 8931   ins_pipe(pipe_class_dummy);
 8932 %}
 8933 
 8934 instruct z196_maxI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8935   match(Set dst (MaxI src1 src2));
 8936   effect(KILL cr);
 8937   predicate(VM_Version::has_LoadStoreConditional());
 8938   ins_cost(3 * DEFAULT_COST);
 8939   // TODO: s390 port size(VARIABLE_SIZE);
 8940   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const32 (z196 only)&quot; %}
 8941   ins_encode %{
 8942     Register Rdst = $dst$$Register;
 8943     Register Rsrc1 = $src1$$Register;
 8944     int      Isrc2 = $src2$$constant;
 8945 
 8946     if (Rdst == Rsrc1) {
 8947       __ load_const_optimized(Z_R0_scratch, Isrc2);
 8948       __ z_cfi(Rsrc1, Isrc2);
 8949       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotHigh);
 8950     } else {
 8951       __ load_const_optimized(Rdst, Isrc2);
 8952       __ z_cfi(Rsrc1, Isrc2);
 8953       __ z_locr(Rdst, Rsrc1, Assembler::bcondHigh);
 8954     }
 8955   %}
 8956   ins_pipe(pipe_class_dummy);
 8957 %}
 8958 
 8959 instruct maxI_reg_imm32(iRegI dst, iRegI src1, immI src2, flagsReg cr) %{
 8960   match(Set dst (MaxI src1 src2));
 8961   effect(KILL cr);
 8962   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 8963   // TODO: s390 port size(VARIABLE_SIZE);
 8964   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const32&quot; %}
 8965   ins_encode %{
 8966     Label done;
 8967     if ($dst$$Register != $src1$$Register) {
 8968       __ z_lgfr($dst$$Register, $src1$$Register);
 8969     }
 8970     __ z_cfi($src1$$Register, $src2$$constant);
 8971     __ z_brh(done);
 8972     __ z_lgfi($dst$$Register, $src2$$constant);
 8973     __ bind(done);
 8974   %}
 8975   ins_pipe(pipe_class_dummy);
 8976 %}
 8977 
 8978 instruct z196_maxI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 8979   match(Set dst (MaxI src1 src2));
 8980   effect(KILL cr);
 8981   predicate(VM_Version::has_LoadStoreConditional());
 8982   ins_cost(3 * DEFAULT_COST);
 8983   // TODO: s390 port size(VARIABLE_SIZE);
 8984   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const16 (z196 only)&quot; %}
 8985   ins_encode %{
 8986     Register Rdst = $dst$$Register;
 8987     Register Rsrc1 = $src1$$Register;
 8988     int      Isrc2 = $src2$$constant;
 8989     if (Rdst == Rsrc1) {
 8990       __ load_const_optimized(Z_R0_scratch, Isrc2);
 8991       __ z_chi(Rsrc1, Isrc2);
 8992       __ z_locr(Rdst, Z_R0_scratch, Assembler::bcondNotHigh);
 8993     } else {
 8994       __ load_const_optimized(Rdst, Isrc2);
 8995       __ z_chi(Rsrc1, Isrc2);
 8996       __ z_locr(Rdst, Rsrc1, Assembler::bcondHigh);
 8997     }
 8998   %}
 8999   ins_pipe(pipe_class_dummy);
 9000 %}
 9001 
 9002 instruct maxI_reg_imm16(iRegI dst, iRegI src1, immI16 src2, flagsReg cr) %{
 9003   match(Set dst (MaxI src1 src2));
 9004   effect(KILL cr);
 9005   ins_cost(2 * DEFAULT_COST + BRANCH_COST);
 9006   // TODO: s390 port size(VARIABLE_SIZE);
 9007   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const16&quot; %}
 9008   ins_encode %{
 9009     Label done;
 9010     if ($dst$$Register != $src1$$Register) {
 9011       __ z_lgfr($dst$$Register, $src1$$Register);
 9012     }
 9013     __ z_chi($src1$$Register, $src2$$constant);
 9014     __ z_brh(done);
 9015     __ z_lghi($dst$$Register, $src2$$constant);
 9016     __ bind(done);
 9017   %}
 9018   ins_pipe(pipe_class_dummy);
 9019 %}
 9020 
 9021 instruct z10_maxI_reg_imm8(iRegI dst, iRegI src1, immI8 src2, flagsReg cr) %{
 9022   match(Set dst (MaxI src1 src2));
 9023   effect(KILL cr);
 9024   predicate(VM_Version::has_CompareBranch());
 9025   ins_cost(DEFAULT_COST + BRANCH_COST);
 9026   // TODO: s390 port size(VARIABLE_SIZE);
 9027   format %{ &quot;MaxI $dst $src1,$src2\t MaxI const8&quot; %}
 9028   ins_encode %{
 9029     Label done;
 9030     if ($dst$$Register != $src1$$Register) {
 9031       __ z_lgfr($dst$$Register, $src1$$Register);
 9032     }
 9033     __ z_cij($src1$$Register, $src2$$constant, Assembler::bcondHigh, done);
 9034     __ z_lghi($dst$$Register, $src2$$constant);
 9035     __ bind(done);
 9036   %}
 9037   ins_pipe(pipe_class_dummy);
 9038 %}
 9039 
 9040 //----------Abs---------------------------------------------------------------
 9041 
 9042 instruct absI_reg(iRegI dst, iRegI src, flagsReg cr) %{
 9043   match(Set dst (AbsI src));
 9044   effect(KILL cr);
 9045   ins_cost(DEFAULT_COST_LOW);
 9046   // TODO: s390 port size(FIXED_SIZE);
 9047   format %{ &quot;LPR     $dst, $src&quot; %}
 9048   opcode(LPR_ZOPC);
 9049   ins_encode(z_rrform(dst, src));
 9050   ins_pipe(pipe_class_dummy);
 9051 %}
 9052 
 9053 instruct negabsI_reg(iRegI dst, iRegI src, immI_0 zero, flagsReg cr) %{
 9054   match(Set dst (SubI zero (AbsI src)));
 9055   effect(KILL cr);
 9056   ins_cost(DEFAULT_COST_LOW);
 9057   // TODO: s390 port size(FIXED_SIZE);
 9058   format %{ &quot;LNR     $dst, $src&quot; %}
 9059   opcode(LNR_ZOPC);
 9060   ins_encode(z_rrform(dst, src));
 9061   ins_pipe(pipe_class_dummy);
 9062 %}
 9063 
 9064 //----------Float Compares----------------------------------------------------
 9065 
 9066 // Compare floating, generate condition code.
 9067 instruct cmpF_cc(flagsReg cr, regF src1, regF src2) %{
 9068   match(Set cr (CmpF src1 src2));
 9069   ins_cost(ALU_REG_COST);
 9070   size(4);
 9071   format %{ &quot;FCMPcc   $src1,$src2\t # float&quot; %}
 9072   ins_encode %{ __ z_cebr($src1$$FloatRegister, $src2$$FloatRegister); %}
 9073   ins_pipe(pipe_class_dummy);
 9074 %}
 9075 
 9076 instruct cmpD_cc(flagsReg cr, regD src1, regD src2) %{
 9077   match(Set cr (CmpD src1 src2));
 9078   ins_cost(ALU_REG_COST);
 9079   size(4);
 9080   format %{ &quot;FCMPcc   $src1,$src2 \t # double&quot; %}
 9081   ins_encode %{ __ z_cdbr($src1$$FloatRegister, $src2$$FloatRegister); %}
 9082   ins_pipe(pipe_class_dummy);
 9083 %}
 9084 
 9085 instruct cmpF_cc_mem(flagsReg cr, regF src1, memoryRX src2) %{
 9086   match(Set cr (CmpF src1 (LoadF src2)));
 9087   ins_cost(ALU_MEMORY_COST);
 9088   size(6);
 9089   format %{ &quot;FCMPcc_mem $src1,$src2\t # floatMemory&quot; %}
 9090   opcode(CEB_ZOPC);
 9091   ins_encode(z_form_rt_memFP(src1, src2));
 9092   ins_pipe(pipe_class_dummy);
 9093 %}
 9094 
 9095 instruct cmpD_cc_mem(flagsReg cr, regD src1, memoryRX src2) %{
 9096   match(Set cr (CmpD src1 (LoadD src2)));
 9097   ins_cost(ALU_MEMORY_COST);
 9098   size(6);
 9099   format %{ &quot;DCMPcc_mem $src1,$src2\t # doubleMemory&quot; %}
 9100   opcode(CDB_ZOPC);
 9101   ins_encode(z_form_rt_memFP(src1, src2));
 9102   ins_pipe(pipe_class_dummy);
 9103 %}
 9104 
 9105 // Compare floating, generate condition code
 9106 instruct cmpF0_cc(flagsReg cr, regF src1, immFpm0 src2) %{
 9107   match(Set cr (CmpF src1 src2));
 9108   ins_cost(DEFAULT_COST);
 9109   size(4);
 9110   format %{ &quot;LTEBR    $src1,$src1\t # float&quot; %}
 9111   opcode(LTEBR_ZOPC);
 9112   ins_encode(z_rreform(src1, src1));
 9113   ins_pipe(pipe_class_dummy);
 9114 %}
 9115 
 9116 instruct cmpD0_cc(flagsReg cr, regD src1, immDpm0 src2) %{
 9117   match(Set cr (CmpD src1 src2));
 9118   ins_cost(DEFAULT_COST);
 9119   size(4);
 9120   format %{ &quot;LTDBR    $src1,$src1 \t # double&quot; %}
 9121   opcode(LTDBR_ZOPC);
 9122   ins_encode(z_rreform(src1, src1));
 9123   ins_pipe(pipe_class_dummy);
 9124 %}
 9125 
 9126 // Compare floating, generate -1,0,1
 9127 instruct cmpF_reg(iRegI dst, regF src1, regF src2, flagsReg cr) %{
 9128   match(Set dst (CmpF3 src1 src2));
 9129   effect(KILL cr);
 9130   ins_cost(DEFAULT_COST * 5 + BRANCH_COST);
 9131   size(24);
 9132   format %{ &quot;CmpF3    $dst,$src1,$src2&quot; %}
 9133   ins_encode %{
 9134     // compare registers
 9135     __ z_cebr($src1$$FloatRegister, $src2$$FloatRegister);
 9136     // Convert condition code into -1,0,1, where
 9137     // -1 means unordered or less
 9138     //  0 means equal
 9139     //  1 means greater.
 9140     if (VM_Version::has_LoadStoreConditional()) {
 9141       Register one       = Z_R0_scratch;
 9142       Register minus_one = Z_R1_scratch;
 9143       __ z_lghi(minus_one, -1);
 9144       __ z_lghi(one, 1);
 9145       __ z_lghi( $dst$$Register, 0);
 9146       __ z_locgr($dst$$Register, one,       Assembler::bcondHigh);
 9147       __ z_locgr($dst$$Register, minus_one, Assembler::bcondLowOrNotOrdered);
 9148     } else {
 9149       Label done;
 9150       __ clear_reg($dst$$Register, true, false);
 9151       __ z_bre(done);
 9152       __ z_lhi($dst$$Register, 1);
 9153       __ z_brh(done);
 9154       __ z_lhi($dst$$Register, -1);
 9155       __ bind(done);
 9156     }
 9157   %}
 9158   ins_pipe(pipe_class_dummy);
 9159 %}
 9160 
 9161 instruct cmpD_reg(iRegI dst, regD src1, regD src2, flagsReg cr) %{
 9162   match(Set dst (CmpD3 src1 src2));
 9163   effect(KILL cr);
 9164   ins_cost(DEFAULT_COST * 5 + BRANCH_COST);
 9165   size(24);
 9166   format %{ &quot;CmpD3    $dst,$src1,$src2&quot; %}
 9167   ins_encode %{
 9168     // compare registers
 9169     __ z_cdbr($src1$$FloatRegister, $src2$$FloatRegister);
 9170     // Convert condition code into -1,0,1, where
 9171     // -1 means unordered or less
 9172     //  0 means equal
 9173     //  1 means greater.
 9174     if (VM_Version::has_LoadStoreConditional()) {
 9175       Register one       = Z_R0_scratch;
 9176       Register minus_one = Z_R1_scratch;
 9177       __ z_lghi(minus_one, -1);
 9178       __ z_lghi(one, 1);
 9179       __ z_lghi( $dst$$Register, 0);
 9180       __ z_locgr($dst$$Register, one,       Assembler::bcondHigh);
 9181       __ z_locgr($dst$$Register, minus_one, Assembler::bcondLowOrNotOrdered);
 9182     } else {
 9183       Label done;
 9184       // indicate unused result
 9185       (void) __ clear_reg($dst$$Register, true, false);
 9186       __ z_bre(done);
 9187       __ z_lhi($dst$$Register, 1);
 9188       __ z_brh(done);
 9189       __ z_lhi($dst$$Register, -1);
 9190       __ bind(done);
 9191     }
 9192   %}
 9193   ins_pipe(pipe_class_dummy);
 9194 %}
 9195 
 9196 //----------Branches---------------------------------------------------------
 9197 // Jump
 9198 
 9199 // Direct Branch.
 9200 instruct branch(label labl) %{
 9201   match(Goto);
 9202   effect(USE labl);
 9203   ins_cost(BRANCH_COST);
 9204   size(4);
 9205   format %{ &quot;BRU     $labl&quot; %}
 9206   ins_encode(z_enc_bru(labl));
 9207   ins_pipe(pipe_class_dummy);
 9208   // If set to 1 this indicates that the current instruction is a
 9209   // short variant of a long branch. This avoids using this
 9210   // instruction in first-pass matching. It will then only be used in
 9211   // the `Shorten_branches&#39; pass.
 9212   ins_short_branch(1);
 9213 %}
 9214 
 9215 // Direct Branch.
 9216 instruct branchFar(label labl) %{
 9217   match(Goto);
 9218   effect(USE labl);
 9219   ins_cost(BRANCH_COST);
 9220   size(6);
 9221   format %{ &quot;BRUL   $labl&quot; %}
 9222   ins_encode(z_enc_brul(labl));
 9223   ins_pipe(pipe_class_dummy);
 9224   // This is not a short variant of a branch, but the long variant.
 9225   ins_short_branch(0);
 9226 %}
 9227 
 9228 // Conditional Near Branch
 9229 instruct branchCon(cmpOp cmp, flagsReg cr, label lbl) %{
 9230   // Same match rule as `branchConFar&#39;.
 9231   match(If cmp cr);
 9232   effect(USE lbl);
 9233   ins_cost(BRANCH_COST);
 9234   size(4);
 9235   format %{ &quot;branch_con_short,$cmp   $lbl&quot; %}
 9236   ins_encode(z_enc_branch_con_short(cmp, lbl));
 9237   ins_pipe(pipe_class_dummy);
 9238   // If set to 1 this indicates that the current instruction is a
 9239   // short variant of a long branch. This avoids using this
 9240   // instruction in first-pass matching. It will then only be used in
 9241   // the `Shorten_branches&#39; pass.
 9242   ins_short_branch(1);
 9243 %}
 9244 
 9245 // This is for cases when the z/Architecture conditional branch instruction
 9246 // does not reach far enough. So we emit a far branch here, which is
 9247 // more expensive.
 9248 //
 9249 // Conditional Far Branch
 9250 instruct branchConFar(cmpOp cmp, flagsReg cr, label lbl) %{
 9251   // Same match rule as `branchCon&#39;.
 9252   match(If cmp cr);
 9253   effect(USE cr, USE lbl);
 9254   // Make more expensive to prefer compare_and_branch over separate instructions.
 9255   ins_cost(2 * BRANCH_COST);
 9256   size(6);
 9257   format %{ &quot;branch_con_far,$cmp   $lbl&quot; %}
 9258   ins_encode(z_enc_branch_con_far(cmp, lbl));
 9259   ins_pipe(pipe_class_dummy);
 9260   // This is not a short variant of a branch, but the long variant..
 9261   ins_short_branch(0);
 9262 %}
 9263 
 9264 instruct branchLoopEnd(cmpOp cmp, flagsReg cr, label labl) %{
 9265   match(CountedLoopEnd cmp cr);
 9266   effect(USE labl);
 9267   ins_cost(BRANCH_COST);
 9268   size(4);
 9269   format %{ &quot;branch_con_short,$cmp   $labl\t # counted loop end&quot; %}
 9270   ins_encode(z_enc_branch_con_short(cmp, labl));
 9271   ins_pipe(pipe_class_dummy);
 9272   // If set to 1 this indicates that the current instruction is a
 9273   // short variant of a long branch. This avoids using this
 9274   // instruction in first-pass matching. It will then only be used in
 9275   // the `Shorten_branches&#39; pass.
 9276   ins_short_branch(1);
 9277 %}
 9278 
 9279 instruct branchLoopEndFar(cmpOp cmp, flagsReg cr, label labl) %{
 9280   match(CountedLoopEnd cmp cr);
 9281   effect(USE labl);
 9282   ins_cost(BRANCH_COST);
 9283   size(6);
 9284   format %{ &quot;branch_con_far,$cmp   $labl\t # counted loop end&quot; %}
 9285   ins_encode(z_enc_branch_con_far(cmp, labl));
 9286   ins_pipe(pipe_class_dummy);
 9287   // This is not a short variant of a branch, but the long variant.
 9288   ins_short_branch(0);
 9289 %}
 9290 
 9291 //----------Compare and Branch (short distance)------------------------------
 9292 
 9293 // INT REG operands for loop counter processing.
 9294 instruct testAndBranchLoopEnd_Reg(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9295   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9296   effect(USE labl, KILL cr);
 9297   predicate(VM_Version::has_CompareBranch());
 9298   ins_cost(BRANCH_COST);
 9299   // TODO: s390 port size(FIXED_SIZE);
 9300   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end SHORT&quot; %}
 9301   opcode(CRJ_ZOPC);
 9302   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9303   ins_pipe(pipe_class_dummy);
 9304   ins_short_branch(1);
 9305 %}
 9306 
 9307 // INT REG operands.
 9308 instruct cmpb_RegI(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9309   match(If boolnode (CmpI src1 src2));
 9310   effect(USE labl, KILL cr);
 9311   predicate(VM_Version::has_CompareBranch());
 9312   ins_cost(BRANCH_COST);
 9313   // TODO: s390 port size(FIXED_SIZE);
 9314   format %{ &quot;CRJ,$boolnode  $src1,$src2,$labl\t # SHORT&quot; %}
 9315   opcode(CRJ_ZOPC);
 9316   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9317   ins_pipe(pipe_class_dummy);
 9318   ins_short_branch(1);
 9319 %}
 9320 
 9321 // Unsigned INT REG operands
 9322 instruct cmpbU_RegI(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9323   match(If boolnode (CmpU src1 src2));
 9324   effect(USE labl, KILL cr);
 9325   predicate(VM_Version::has_CompareBranch());
 9326   ins_cost(BRANCH_COST);
 9327   // TODO: s390 port size(FIXED_SIZE);
 9328   format %{ &quot;CLRJ,$boolnode  $src1,$src2,$labl\t # SHORT&quot; %}
 9329   opcode(CLRJ_ZOPC);
 9330   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9331   ins_pipe(pipe_class_dummy);
 9332   ins_short_branch(1);
 9333 %}
 9334 
 9335 // LONG REG operands
 9336 instruct cmpb_RegL(cmpOpT boolnode, iRegL src1, iRegL src2, label labl, flagsReg cr) %{
 9337   match(If boolnode (CmpL src1 src2));
 9338   effect(USE labl, KILL cr);
 9339   predicate(VM_Version::has_CompareBranch());
 9340   ins_cost(BRANCH_COST);
 9341   // TODO: s390 port size(FIXED_SIZE);
 9342   format %{ &quot;CGRJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9343   opcode(CGRJ_ZOPC);
 9344   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9345   ins_pipe(pipe_class_dummy);
 9346   ins_short_branch(1);
 9347 %}
 9348 
 9349 //  PTR REG operands
 9350 
 9351 // Separate rules for regular and narrow oops.  ADLC can&#39;t recognize
 9352 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9353 // will not shorten.
 9354 
 9355 instruct cmpb_RegPP(cmpOpT boolnode, iRegP src1, iRegP src2, label labl, flagsReg cr) %{
 9356   match(If boolnode (CmpP src1 src2));
 9357   effect(USE labl, KILL cr);
 9358   predicate(VM_Version::has_CompareBranch());
 9359   ins_cost(BRANCH_COST);
 9360   // TODO: s390 port size(FIXED_SIZE);
 9361   format %{ &quot;CLGRJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9362   opcode(CLGRJ_ZOPC);
 9363   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9364   ins_pipe(pipe_class_dummy);
 9365   ins_short_branch(1);
 9366 %}
 9367 
 9368 instruct cmpb_RegNN(cmpOpT boolnode, iRegN src1, iRegN src2, label labl, flagsReg cr) %{
 9369   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9370   effect(USE labl, KILL cr);
 9371   predicate(VM_Version::has_CompareBranch());
 9372   ins_cost(BRANCH_COST);
 9373   // TODO: s390 port size(FIXED_SIZE);
 9374   format %{ &quot;CLGRJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9375   opcode(CLGRJ_ZOPC);
 9376   ins_encode(z_enc_cmpb_regreg(src1, src2, labl, boolnode));
 9377   ins_pipe(pipe_class_dummy);
 9378   ins_short_branch(1);
 9379 %}
 9380 
 9381 // INT REG/IMM operands for loop counter processing
 9382 instruct testAndBranchLoopEnd_Imm(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9383   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9384   effect(USE labl, KILL cr);
 9385   predicate(VM_Version::has_CompareBranch());
 9386   ins_cost(BRANCH_COST);
 9387   // TODO: s390 port size(FIXED_SIZE);
 9388   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end SHORT&quot; %}
 9389   opcode(CIJ_ZOPC);
 9390   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9391   ins_pipe(pipe_class_dummy);
 9392   ins_short_branch(1);
 9393 %}
 9394 
 9395 // INT REG/IMM operands
 9396 instruct cmpb_RegI_imm(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9397   match(If boolnode (CmpI src1 src2));
 9398   effect(USE labl, KILL cr);
 9399   predicate(VM_Version::has_CompareBranch());
 9400   ins_cost(BRANCH_COST);
 9401   // TODO: s390 port size(FIXED_SIZE);
 9402   format %{ &quot;CIJ,$boolnode  $src1,$src2,$labl\t # SHORT&quot; %}
 9403   opcode(CIJ_ZOPC);
 9404   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9405   ins_pipe(pipe_class_dummy);
 9406   ins_short_branch(1);
 9407 %}
 9408 
 9409 // INT REG/IMM operands
 9410 instruct cmpbU_RegI_imm(cmpOpT boolnode, iRegI src1, uimmI8 src2, label labl, flagsReg cr) %{
 9411   match(If boolnode (CmpU src1 src2));
 9412   effect(USE labl, KILL cr);
 9413   predicate(VM_Version::has_CompareBranch());
 9414   ins_cost(BRANCH_COST);
 9415   // TODO: s390 port size(FIXED_SIZE);
 9416   format %{ &quot;CLIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9417   opcode(CLIJ_ZOPC);
 9418   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9419   ins_pipe(pipe_class_dummy);
 9420   ins_short_branch(1);
 9421 %}
 9422 
 9423 // LONG REG/IMM operands
 9424 instruct cmpb_RegL_imm(cmpOpT boolnode, iRegL src1, immL8 src2, label labl, flagsReg cr) %{
 9425   match(If boolnode (CmpL src1 src2));
 9426   effect(USE labl, KILL cr);
 9427   predicate(VM_Version::has_CompareBranch());
 9428   ins_cost(BRANCH_COST);
 9429   // TODO: s390 port size(FIXED_SIZE);
 9430   format %{ &quot;CGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9431   opcode(CGIJ_ZOPC);
 9432   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9433   ins_pipe(pipe_class_dummy);
 9434   ins_short_branch(1);
 9435 %}
 9436 
 9437 // PTR REG-imm operands
 9438 
 9439 // Separate rules for regular and narrow oops. ADLC can&#39;t recognize
 9440 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9441 // will not shorten.
 9442 
 9443 instruct cmpb_RegP_immP(cmpOpT boolnode, iRegP src1, immP8 src2, label labl, flagsReg cr) %{
 9444   match(If boolnode (CmpP src1 src2));
 9445   effect(USE labl, KILL cr);
 9446   predicate(VM_Version::has_CompareBranch());
 9447   ins_cost(BRANCH_COST);
 9448   // TODO: s390 port size(FIXED_SIZE);
 9449   format %{ &quot;CLGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9450   opcode(CLGIJ_ZOPC);
 9451   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9452   ins_pipe(pipe_class_dummy);
 9453   ins_short_branch(1);
 9454 %}
 9455 
 9456 // Compare against zero only, do not mix N and P oops (encode/decode required).
 9457 instruct cmpb_RegN_immP0(cmpOpT boolnode, iRegN src1, immP0 src2, label labl, flagsReg cr) %{
 9458   match(If boolnode (CmpP (DecodeN src1) src2));
 9459   effect(USE labl, KILL cr);
 9460   predicate(VM_Version::has_CompareBranch());
 9461   ins_cost(BRANCH_COST);
 9462   // TODO: s390 port size(FIXED_SIZE);
 9463   format %{ &quot;CLGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9464   opcode(CLGIJ_ZOPC);
 9465   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9466   ins_pipe(pipe_class_dummy);
 9467   ins_short_branch(1);
 9468 %}
 9469 
 9470 instruct cmpb_RegN_imm(cmpOpT boolnode, iRegN src1, immN8 src2, label labl, flagsReg cr) %{
 9471   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9472   effect(USE labl, KILL cr);
 9473   predicate(VM_Version::has_CompareBranch());
 9474   ins_cost(BRANCH_COST);
 9475   // TODO: s390 port size(FIXED_SIZE);
 9476   format %{ &quot;CLGIJ,$boolnode $src1,$src2,$labl\t # SHORT&quot; %}
 9477   opcode(CLGIJ_ZOPC);
 9478   ins_encode(z_enc_cmpb_regimm(src1, src2, labl, boolnode));
 9479   ins_pipe(pipe_class_dummy);
 9480   ins_short_branch(1);
 9481 %}
 9482 
 9483 
 9484 //----------Compare and Branch (far distance)------------------------------
 9485 
 9486 // INT REG operands for loop counter processing
 9487 instruct testAndBranchLoopEnd_RegFar(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9488   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9489   effect(USE labl, KILL cr);
 9490   predicate(VM_Version::has_CompareBranch());
 9491   ins_cost(BRANCH_COST+DEFAULT_COST);
 9492   // TODO: s390 port size(FIXED_SIZE);
 9493   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end FAR&quot; %}
 9494   opcode(CR_ZOPC, BRCL_ZOPC);
 9495   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9496   ins_pipe(pipe_class_dummy);
 9497   ins_short_branch(0);
 9498 %}
 9499 
 9500 // INT REG operands
 9501 instruct cmpb_RegI_Far(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9502   match(If boolnode (CmpI src1 src2));
 9503   effect(USE labl, KILL cr);
 9504   predicate(VM_Version::has_CompareBranch());
 9505   ins_cost(BRANCH_COST+DEFAULT_COST);
 9506   // TODO: s390 port size(FIXED_SIZE);
 9507   format %{ &quot;CRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9508   opcode(CR_ZOPC, BRCL_ZOPC);
 9509   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9510   ins_pipe(pipe_class_dummy);
 9511   ins_short_branch(0);
 9512 %}
 9513 
 9514 // INT REG operands
 9515 instruct cmpbU_RegI_Far(cmpOpT boolnode, iRegI src1, iRegI src2, label labl, flagsReg cr) %{
 9516   match(If boolnode (CmpU src1 src2));
 9517   effect(USE labl, KILL cr);
 9518   predicate(VM_Version::has_CompareBranch());
 9519   ins_cost(BRANCH_COST+DEFAULT_COST);
 9520   // TODO: s390 port size(FIXED_SIZE);
 9521   format %{ &quot;CLRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9522   opcode(CLR_ZOPC, BRCL_ZOPC);
 9523   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9524   ins_pipe(pipe_class_dummy);
 9525   ins_short_branch(0);
 9526 %}
 9527 
 9528 // LONG REG operands
 9529 instruct cmpb_RegL_Far(cmpOpT boolnode, iRegL src1, iRegL src2, label labl, flagsReg cr) %{
 9530   match(If boolnode (CmpL src1 src2));
 9531   effect(USE labl, KILL cr);
 9532   predicate(VM_Version::has_CompareBranch());
 9533   ins_cost(BRANCH_COST+DEFAULT_COST);
 9534   // TODO: s390 port size(FIXED_SIZE);
 9535   format %{ &quot;CGRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9536   opcode(CGR_ZOPC, BRCL_ZOPC);
 9537   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9538   ins_pipe(pipe_class_dummy);
 9539   ins_short_branch(0);
 9540 %}
 9541 
 9542 // PTR REG operands
 9543 
 9544 // Separate rules for regular and narrow oops. ADLC can&#39;t recognize
 9545 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9546 // will not shorten.
 9547 
 9548 instruct cmpb_RegPP_Far(cmpOpT boolnode, iRegP src1, iRegP src2, label labl, flagsReg cr) %{
 9549   match(If boolnode (CmpP src1 src2));
 9550   effect(USE labl, KILL cr);
 9551   predicate(VM_Version::has_CompareBranch());
 9552   ins_cost(BRANCH_COST+DEFAULT_COST);
 9553   // TODO: s390 port size(FIXED_SIZE);
 9554   format %{ &quot;CLGRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9555   opcode(CLGR_ZOPC, BRCL_ZOPC);
 9556   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9557   ins_pipe(pipe_class_dummy);
 9558   ins_short_branch(0);
 9559 %}
 9560 
 9561 instruct cmpb_RegNN_Far(cmpOpT boolnode, iRegN src1, iRegN src2, label labl, flagsReg cr) %{
 9562   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9563   effect(USE labl, KILL cr);
 9564   predicate(VM_Version::has_CompareBranch());
 9565   ins_cost(BRANCH_COST+DEFAULT_COST);
 9566   // TODO: s390 port size(FIXED_SIZE);
 9567   format %{ &quot;CLGRJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9568   opcode(CLGR_ZOPC, BRCL_ZOPC);
 9569   ins_encode(z_enc_cmpb_regregFar(src1, src2, labl, boolnode));
 9570   ins_pipe(pipe_class_dummy);
 9571   ins_short_branch(0);
 9572 %}
 9573 
 9574 // INT REG/IMM operands for loop counter processing
 9575 instruct testAndBranchLoopEnd_ImmFar(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9576   match(CountedLoopEnd boolnode (CmpI src1 src2));
 9577   effect(USE labl, KILL cr);
 9578   predicate(VM_Version::has_CompareBranch());
 9579   ins_cost(BRANCH_COST+DEFAULT_COST);
 9580   // TODO: s390 port size(FIXED_SIZE);
 9581   format %{ &quot;test_and_branch_loop_end,$boolnode  $src1,$src2,$labl\t # counted loop end FAR&quot; %}
 9582   opcode(CHI_ZOPC, BRCL_ZOPC);
 9583   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9584   ins_pipe(pipe_class_dummy);
 9585   ins_short_branch(0);
 9586 %}
 9587 
 9588 // INT REG/IMM operands
 9589 instruct cmpb_RegI_imm_Far(cmpOpT boolnode, iRegI src1, immI8 src2, label labl, flagsReg cr) %{
 9590   match(If boolnode (CmpI src1 src2));
 9591   effect(USE labl, KILL cr);
 9592   predicate(VM_Version::has_CompareBranch());
 9593   ins_cost(BRANCH_COST+DEFAULT_COST);
 9594   // TODO: s390 port size(FIXED_SIZE);
 9595   format %{ &quot;CIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9596   opcode(CHI_ZOPC, BRCL_ZOPC);
 9597   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9598   ins_pipe(pipe_class_dummy);
 9599   ins_short_branch(0);
 9600 %}
 9601 
 9602 // INT REG/IMM operands
 9603 instruct cmpbU_RegI_imm_Far(cmpOpT boolnode, iRegI src1, uimmI8 src2, label labl, flagsReg cr) %{
 9604   match(If boolnode (CmpU src1 src2));
 9605   effect(USE labl, KILL cr);
 9606   predicate(VM_Version::has_CompareBranch());
 9607   ins_cost(BRANCH_COST+DEFAULT_COST);
 9608   // TODO: s390 port size(FIXED_SIZE);
 9609   format %{ &quot;CLIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9610   opcode(CLFI_ZOPC, BRCL_ZOPC);
 9611   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9612   ins_pipe(pipe_class_dummy);
 9613   ins_short_branch(0);
 9614 %}
 9615 
 9616 // LONG REG/IMM operands
 9617 instruct cmpb_RegL_imm_Far(cmpOpT boolnode, iRegL src1, immL8 src2, label labl, flagsReg cr) %{
 9618   match(If boolnode (CmpL src1 src2));
 9619   effect(USE labl, KILL cr);
 9620   predicate(VM_Version::has_CompareBranch());
 9621   ins_cost(BRANCH_COST+DEFAULT_COST);
 9622   // TODO: s390 port size(FIXED_SIZE);
 9623   format %{ &quot;CGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9624   opcode(CGHI_ZOPC, BRCL_ZOPC);
 9625   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9626   ins_pipe(pipe_class_dummy);
 9627   ins_short_branch(0);
 9628 %}
 9629 
 9630 // PTR REG-imm operands
 9631 
 9632 // Separate rules for regular and narrow oops. ADLC can&#39;t recognize
 9633 // rules with polymorphic operands to be sisters -&gt; shorten_branches
 9634 // will not shorten.
 9635 
 9636 instruct cmpb_RegP_immP_Far(cmpOpT boolnode, iRegP src1, immP8 src2, label labl, flagsReg cr) %{
 9637   match(If boolnode (CmpP src1 src2));
 9638   effect(USE labl, KILL cr);
 9639   predicate(VM_Version::has_CompareBranch());
 9640   ins_cost(BRANCH_COST+DEFAULT_COST);
 9641   // TODO: s390 port size(FIXED_SIZE);
 9642   format %{ &quot;CLGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9643   opcode(CLGFI_ZOPC, BRCL_ZOPC);
 9644   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9645   ins_pipe(pipe_class_dummy);
 9646   ins_short_branch(0);
 9647 %}
 9648 
 9649 // Compare against zero only, do not mix N and P oops (encode/decode required).
 9650 instruct cmpb_RegN_immP0_Far(cmpOpT boolnode, iRegN src1, immP0 src2, label labl, flagsReg cr) %{
 9651   match(If boolnode (CmpP (DecodeN src1) src2));
 9652   effect(USE labl, KILL cr);
 9653   predicate(VM_Version::has_CompareBranch());
 9654   ins_cost(BRANCH_COST+DEFAULT_COST);
 9655   // TODO: s390 port size(FIXED_SIZE);
 9656   format %{ &quot;CLGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9657   opcode(CLGFI_ZOPC, BRCL_ZOPC);
 9658   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9659   ins_pipe(pipe_class_dummy);
 9660   ins_short_branch(0);
 9661 %}
 9662 
 9663 instruct cmpb_RegN_immN_Far(cmpOpT boolnode, iRegN src1, immN8 src2, label labl, flagsReg cr) %{
 9664   match(If boolnode (CmpP (DecodeN src1) (DecodeN src2)));
 9665   effect(USE labl, KILL cr);
 9666   predicate(VM_Version::has_CompareBranch());
 9667   ins_cost(BRANCH_COST+DEFAULT_COST);
 9668   // TODO: s390 port size(FIXED_SIZE);
 9669   format %{ &quot;CLGIJ,$boolnode   $src1,$src2,$labl\t # FAR(substituted)&quot; %}
 9670   opcode(CLGFI_ZOPC, BRCL_ZOPC);
 9671   ins_encode(z_enc_cmpb_regimmFar(src1, src2, labl, boolnode));
 9672   ins_pipe(pipe_class_dummy);
 9673   ins_short_branch(0);
 9674 %}
 9675 
 9676 // ============================================================================
 9677 // Long Compare
 9678 
 9679 // Due to a shortcoming in the ADLC, it mixes up expressions like:
 9680 // (foo (CmpI (CmpL X Y) 0)) and (bar (CmpI (CmpL X 0L) 0)). Note the
 9681 // difference between &#39;Y&#39; and &#39;0L&#39;. The tree-matches for the CmpI sections
 9682 // are collapsed internally in the ADLC&#39;s dfa-gen code. The match for
 9683 // (CmpI (CmpL X Y) 0) is silently replaced with (CmpI (CmpL X 0L) 0) and the
 9684 // foo match ends up with the wrong leaf. One fix is to not match both
 9685 // reg-reg and reg-zero forms of long-compare. This is unfortunate because
 9686 // both forms beat the trinary form of long-compare and both are very useful
 9687 // on platforms which have few registers.
 9688 
 9689 // Manifest a CmpL3 result in an integer register. Very painful.
 9690 // This is the test to avoid.
 9691 instruct cmpL3_reg_reg(iRegI dst, iRegL src1, iRegL src2, flagsReg cr) %{
 9692   match(Set dst (CmpL3 src1 src2));
 9693   effect(KILL cr);
 9694   ins_cost(DEFAULT_COST * 5 + BRANCH_COST);
 9695   size(24);
 9696   format %{ &quot;CmpL3 $dst,$src1,$src2&quot; %}
 9697   ins_encode %{
 9698     Label done;
 9699     // compare registers
 9700     __ z_cgr($src1$$Register, $src2$$Register);
 9701     // Convert condition code into -1,0,1, where
 9702     // -1 means less
 9703     //  0 means equal
 9704     //  1 means greater.
 9705     if (VM_Version::has_LoadStoreConditional()) {
 9706       Register one       = Z_R0_scratch;
 9707       Register minus_one = Z_R1_scratch;
 9708       __ z_lghi(minus_one, -1);
 9709       __ z_lghi(one, 1);
 9710       __ z_lghi( $dst$$Register, 0);
 9711       __ z_locgr($dst$$Register, one,       Assembler::bcondHigh);
 9712       __ z_locgr($dst$$Register, minus_one, Assembler::bcondLow);
 9713     } else {
 9714       __ clear_reg($dst$$Register, true, false);
 9715       __ z_bre(done);
 9716       __ z_lhi($dst$$Register, 1);
 9717       __ z_brh(done);
 9718       __ z_lhi($dst$$Register, -1);
 9719     }
 9720     __ bind(done);
 9721   %}
 9722   ins_pipe(pipe_class_dummy);
 9723 %}
 9724 
 9725 // ============================================================================
 9726 // Safepoint Instruction
 9727 
 9728 instruct safePoint() %{
 9729   match(SafePoint);
 9730   predicate(false);
 9731   // TODO: s390 port size(FIXED_SIZE);
 9732   format %{ &quot;UNIMPLEMENTED Safepoint_ &quot; %}
 9733   ins_encode(enc_unimplemented());
 9734   ins_pipe(pipe_class_dummy);
 9735 %}
 9736 
 9737 instruct safePoint_poll(iRegP poll, flagsReg cr) %{
 9738   match(SafePoint poll);
 9739   effect(USE poll, KILL cr); // R0 is killed, too.
 9740   // TODO: s390 port size(FIXED_SIZE);
 9741   format %{ &quot;TM      #0[,$poll],#111\t # Safepoint: poll for GC&quot; %}
 9742   ins_encode %{
 9743     // Mark the code position where the load from the safepoint
 9744     // polling page was emitted as relocInfo::poll_type.
 9745     __ relocate(relocInfo::poll_type);
 9746     __ load_from_polling_page($poll$$Register);
 9747   %}
 9748   ins_pipe(pipe_class_dummy);
 9749 %}
 9750 
 9751 // ============================================================================
 9752 
 9753 // Call Instructions
 9754 
 9755 // Call Java Static Instruction
 9756 instruct CallStaticJavaDirect_dynTOC(method meth) %{
 9757   match(CallStaticJava);
 9758   effect(USE meth);
 9759   ins_cost(CALL_COST);
 9760   // TODO: s390 port size(VARIABLE_SIZE);
 9761   format %{ &quot;CALL,static dynTOC $meth; ==&gt; &quot; %}
 9762   ins_encode( z_enc_java_static_call(meth) );
 9763   ins_pipe(pipe_class_dummy);
 9764   ins_alignment(2);
 9765 %}
 9766 
 9767 // Call Java Dynamic Instruction
 9768 instruct CallDynamicJavaDirect_dynTOC(method meth) %{
 9769   match(CallDynamicJava);
 9770   effect(USE meth);
 9771   ins_cost(CALL_COST);
 9772   // TODO: s390 port size(VARIABLE_SIZE);
 9773   format %{ &quot;CALL,dynamic dynTOC $meth; ==&gt; &quot; %}
 9774   ins_encode(z_enc_java_dynamic_call(meth));
 9775   ins_pipe(pipe_class_dummy);
 9776   ins_alignment(2);
 9777 %}
 9778 
 9779 // Call Runtime Instruction
 9780 instruct CallRuntimeDirect(method meth) %{
 9781   match(CallRuntime);
 9782   effect(USE meth);
 9783   ins_cost(CALL_COST);
 9784   // TODO: s390 port size(VARIABLE_SIZE);
 9785   ins_num_consts(1);
 9786   ins_alignment(2);
 9787   format %{ &quot;CALL,runtime&quot; %}
 9788   ins_encode( z_enc_java_to_runtime_call(meth) );
 9789   ins_pipe(pipe_class_dummy);
 9790 %}
 9791 
 9792 // Call runtime without safepoint - same as CallRuntime
 9793 instruct CallLeafDirect(method meth) %{
 9794   match(CallLeaf);
 9795   effect(USE meth);
 9796   ins_cost(CALL_COST);
 9797   // TODO: s390 port size(VARIABLE_SIZE);
 9798   ins_num_consts(1);
 9799   ins_alignment(2);
 9800   format %{ &quot;CALL,runtime leaf $meth&quot; %}
 9801   ins_encode( z_enc_java_to_runtime_call(meth) );
 9802   ins_pipe(pipe_class_dummy);
 9803 %}
 9804 
 9805 // Call runtime without safepoint - same as CallLeaf
 9806 instruct CallLeafNoFPDirect(method meth) %{
 9807   match(CallLeafNoFP);
 9808   effect(USE meth);
 9809   ins_cost(CALL_COST);
 9810   // TODO: s390 port size(VARIABLE_SIZE);
 9811   ins_num_consts(1);
 9812   format %{ &quot;CALL,runtime leaf nofp $meth&quot; %}
 9813   ins_encode( z_enc_java_to_runtime_call(meth) );
 9814   ins_pipe(pipe_class_dummy);
 9815   ins_alignment(2);
 9816 %}
 9817 
 9818 // Tail Call; Jump from runtime stub to Java code.
 9819 // Also known as an &#39;interprocedural jump&#39;.
 9820 // Target of jump will eventually return to caller.
 9821 // TailJump below removes the return address.
 9822 instruct TailCalljmpInd(iRegP jump_target, inline_cache_regP method_oop) %{
 9823   match(TailCall jump_target method_oop);
 9824   ins_cost(CALL_COST);
 9825   size(2);
 9826   format %{ &quot;Jmp     $jump_target\t # $method_oop holds method oop&quot; %}
 9827   ins_encode %{ __ z_br($jump_target$$Register); %}
 9828   ins_pipe(pipe_class_dummy);
 9829 %}
 9830 
 9831 // Return Instruction
 9832 instruct Ret() %{
 9833   match(Return);
 9834   size(2);
 9835   format %{ &quot;BR(Z_R14) // branch to link register&quot; %}
 9836   ins_encode %{ __ z_br(Z_R14); %}
 9837   ins_pipe(pipe_class_dummy);
 9838 %}
 9839 
 9840 // Tail Jump; remove the return address; jump to target.
 9841 // TailCall above leaves the return address around.
 9842 // TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
 9843 // ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
 9844 // &quot;restore&quot; before this instruction (in Epilogue), we need to materialize it
 9845 // in %i0.
 9846 instruct tailjmpInd(iRegP jump_target, rarg1RegP ex_oop) %{
 9847   match(TailJump jump_target ex_oop);
 9848   ins_cost(CALL_COST);
 9849   size(8);
 9850   format %{ &quot;TailJump $jump_target&quot; %}
 9851   ins_encode %{
 9852     __ z_lg(Z_ARG2/* issuing pc */, _z_abi(return_pc), Z_SP);
 9853     __ z_br($jump_target$$Register);
 9854   %}
 9855   ins_pipe(pipe_class_dummy);
 9856 %}
 9857 
 9858 // Create exception oop: created by stack-crawling runtime code.
 9859 // Created exception is now available to this handler, and is setup
 9860 // just prior to jumping to this handler. No code emitted.
 9861 instruct CreateException(rarg1RegP ex_oop) %{
 9862   match(Set ex_oop (CreateEx));
 9863   ins_cost(0);
 9864   size(0);
 9865   format %{ &quot;# exception oop; no code emitted&quot; %}
 9866   ins_encode(/*empty*/);
 9867   ins_pipe(pipe_class_dummy);
 9868 %}
 9869 
 9870 // Rethrow exception: The exception oop will come in the first
 9871 // argument position. Then JUMP (not call) to the rethrow stub code.
 9872 instruct RethrowException() %{
 9873   match(Rethrow);
 9874   ins_cost(CALL_COST);
 9875   // TODO: s390 port size(VARIABLE_SIZE);
 9876   format %{ &quot;Jmp    rethrow_stub&quot; %}
 9877   ins_encode %{
 9878     cbuf.set_insts_mark();
 9879     __ load_const_optimized(Z_R1_scratch, (address)OptoRuntime::rethrow_stub());
 9880     __ z_br(Z_R1_scratch);
 9881   %}
 9882   ins_pipe(pipe_class_dummy);
 9883 %}
 9884 
 9885 // Die now.
 9886 instruct ShouldNotReachHere() %{
 9887   match(Halt);
 9888   ins_cost(CALL_COST);
 9889   size(2);
 9890   format %{ &quot;ILLTRAP; ShouldNotReachHere&quot; %}
 9891   ins_encode %{ __ z_illtrap(); %}
 9892   ins_pipe(pipe_class_dummy);
 9893 %}
 9894 
 9895 // ============================================================================
 9896 // The 2nd slow-half of a subtype check. Scan the subklass&#39;s 2ndary superklass
 9897 // array for an instance of the superklass. Set a hidden internal cache on a
 9898 // hit (cache is checked with exposed code in gen_subtype_check()). Return
 9899 // not zero for a miss or zero for a hit. The encoding ALSO sets flags.
 9900 instruct partialSubtypeCheck(rarg1RegP index, rarg2RegP sub, rarg3RegP super, flagsReg pcc,
 9901                              rarg4RegP scratch1, rarg5RegP scratch2) %{
 9902   match(Set index (PartialSubtypeCheck sub super));
 9903   effect(KILL pcc, KILL scratch1, KILL scratch2);
 9904   ins_cost(10 * DEFAULT_COST);
 9905   // TODO: s390 port size(FIXED_SIZE);
 9906   format %{ &quot;  CALL   PartialSubtypeCheck\n&quot; %}
 9907   ins_encode %{
 9908     AddressLiteral stub_address(StubRoutines::zarch::partial_subtype_check());
 9909     __ load_const_optimized(Z_ARG4, stub_address);
 9910     __ z_basr(Z_R14, Z_ARG4);
 9911   %}
 9912   ins_pipe(pipe_class_dummy);
 9913 %}
 9914 
 9915 instruct partialSubtypeCheck_vs_zero(flagsReg pcc, rarg2RegP sub, rarg3RegP super, immP0 zero,
 9916                                      rarg1RegP index, rarg4RegP scratch1, rarg5RegP scratch2) %{
 9917   match(Set pcc (CmpI (PartialSubtypeCheck sub super) zero));
 9918   effect(KILL scratch1, KILL scratch2, KILL index);
 9919   ins_cost(10 * DEFAULT_COST);
 9920   // TODO: s390 port size(FIXED_SIZE);
 9921   format %{ &quot;CALL   PartialSubtypeCheck_vs_zero\n&quot; %}
 9922   ins_encode %{
 9923     AddressLiteral stub_address(StubRoutines::zarch::partial_subtype_check());
 9924     __ load_const_optimized(Z_ARG4, stub_address);
 9925     __ z_basr(Z_R14, Z_ARG4);
 9926   %}
 9927   ins_pipe(pipe_class_dummy);
 9928 %}
 9929 
 9930 // ============================================================================
 9931 // inlined locking and unlocking
 9932 
 9933 instruct cmpFastLock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{
 9934   match(Set pcc (FastLock oop box));
 9935   effect(TEMP tmp1, TEMP tmp2);
 9936   ins_cost(100);
 9937   // TODO: s390 port size(VARIABLE_SIZE); // Uses load_const_optimized.
 9938   format %{ &quot;FASTLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5&quot; %}
 9939   ins_encode %{ __ compiler_fast_lock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,
 9940                                              UseBiasedLocking &amp;&amp; !UseOptoBiasInlining); %}
 9941   ins_pipe(pipe_class_dummy);
 9942 %}
 9943 
 9944 instruct cmpFastUnlock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{
 9945   match(Set pcc (FastUnlock oop box));
 9946   effect(TEMP tmp1, TEMP tmp2);
 9947   ins_cost(100);
 9948   // TODO: s390 port size(FIXED_SIZE);  // emitted code depends on UseBiasedLocking being on/off.
 9949   format %{ &quot;FASTUNLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5&quot; %}
 9950   ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register,
 9951                                                UseBiasedLocking &amp;&amp; !UseOptoBiasInlining); %}
 9952   ins_pipe(pipe_class_dummy);
 9953 %}
 9954 
 9955 instruct inlineCallClearArrayConst(SSlenDW cnt, iRegP_N2P base, Universe dummy, flagsReg cr) %{
 9956   match(Set dummy (ClearArray cnt base));
 9957   effect(KILL cr);
 9958   ins_cost(100);
 9959   // TODO: s390 port size(VARIABLE_SIZE);       // Variable in size due to varying #instructions.
 9960   format %{ &quot;ClearArrayConst $cnt,$base&quot; %}
 9961   ins_encode %{ __ Clear_Array_Const($cnt$$constant, $base$$Register); %}
 9962   ins_pipe(pipe_class_dummy);
 9963 %}
 9964 
 9965 instruct inlineCallClearArrayConstBig(immL cnt, iRegP_N2P base, Universe dummy, allRoddRegL tmpL, flagsReg cr) %{
 9966   match(Set dummy (ClearArray cnt base));
 9967   effect(TEMP tmpL, KILL cr); // R0, R1 are killed, too.
 9968   ins_cost(200);
 9969   // TODO: s390 port size(VARIABLE_SIZE);       // Variable in size due to optimized constant loader.
 9970   format %{ &quot;ClearArrayConstBig $cnt,$base&quot; %}
 9971   ins_encode %{ __ Clear_Array_Const_Big($cnt$$constant, $base$$Register, $tmpL$$Register); %}
 9972   ins_pipe(pipe_class_dummy);
 9973 %}
 9974 
 9975 instruct inlineCallClearArray(iRegL cnt, iRegP_N2P base, Universe dummy, allRoddRegL tmpL, flagsReg cr) %{
 9976   match(Set dummy (ClearArray cnt base));
 9977   effect(TEMP tmpL, KILL cr); // R0, R1 are killed, too.
 9978   ins_cost(300);
 9979   // TODO: s390 port size(FIXED_SIZE);  // z/Architecture: emitted code depends on PreferLAoverADD being on/off.
 9980   format %{ &quot;ClearArrayVar $cnt,$base&quot; %}
 9981   ins_encode %{ __ Clear_Array($cnt$$Register, $base$$Register, $tmpL$$Register); %}
 9982   ins_pipe(pipe_class_dummy);
 9983 %}
 9984 
 9985 // ============================================================================
 9986 // CompactStrings
 9987 
 9988 // String equals
 9989 instruct string_equalsL(iRegP str1, iRegP str2, iRegI cnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
 9990   match(Set result (StrEquals (Binary str1 str2) cnt));
 9991   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
 9992   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
 9993   ins_cost(300);
 9994   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result&quot; %}
 9995   ins_encode %{
 9996     __ array_equals(false, $str1$$Register, $str2$$Register,
 9997                     $cnt$$Register, $oddReg$$Register, $evenReg$$Register,
 9998                     $result$$Register, true /* byte */);
 9999   %}
10000   ins_pipe(pipe_class_dummy);
10001 %}
10002 
10003 instruct string_equalsU(iRegP str1, iRegP str2, iRegI cnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10004   match(Set result (StrEquals (Binary str1 str2) cnt));
10005   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10006   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10007   ins_cost(300);
10008   format %{ &quot;String Equals char[] $str1,$str2,$cnt -&gt; $result&quot; %}
10009   ins_encode %{
10010     __ array_equals(false, $str1$$Register, $str2$$Register,
10011                     $cnt$$Register, $oddReg$$Register, $evenReg$$Register,
10012                     $result$$Register, false /* byte */);
10013   %}
10014   ins_pipe(pipe_class_dummy);
10015 %}
10016 
10017 instruct string_equals_imm(iRegP str1, iRegP str2, uimmI8 cnt, iRegI result, flagsReg cr) %{
10018   match(Set result (StrEquals (Binary str1 str2) cnt));
10019   effect(KILL cr); // R0 is killed, too.
10020   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL || ((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10021   ins_cost(100);
10022   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result&quot; %}
10023   ins_encode %{
10024     const int cnt_imm = $cnt$$constant;
10025     if (cnt_imm) { __ z_clc(0, cnt_imm - 1, $str1$$Register, 0, $str2$$Register); }
10026     __ z_lhi($result$$Register, 1);
10027     if (cnt_imm) {
10028       if (VM_Version::has_LoadStoreConditional()) {
10029         __ z_lhi(Z_R0_scratch, 0);
10030         __ z_locr($result$$Register, Z_R0_scratch, Assembler::bcondNotEqual);
10031       } else {
10032         Label Lskip;
10033         __ z_bre(Lskip);
10034         __ clear_reg($result$$Register);
10035         __ bind(Lskip);
10036       }
10037     }
10038   %}
10039   ins_pipe(pipe_class_dummy);
10040 %}
10041 
10042 instruct string_equalsC_imm(iRegP str1, iRegP str2, immI8 cnt, iRegI result, flagsReg cr) %{
10043   match(Set result (StrEquals (Binary str1 str2) cnt));
10044   effect(KILL cr); // R0 is killed, too.
10045   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10046   ins_cost(100);
10047   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result&quot; %}
10048   ins_encode %{
10049     const int cnt_imm = $cnt$$constant; // positive immI8 (7 bits used)
10050     if (cnt_imm) { __ z_clc(0, (cnt_imm &lt;&lt; 1) - 1, $str1$$Register, 0, $str2$$Register); }
10051     __ z_lhi($result$$Register, 1);
10052     if (cnt_imm) {
10053       if (VM_Version::has_LoadStoreConditional()) {
10054         __ z_lhi(Z_R0_scratch, 0);
10055         __ z_locr($result$$Register, Z_R0_scratch, Assembler::bcondNotEqual);
10056       } else {
10057         Label Lskip;
10058         __ z_bre(Lskip);
10059         __ clear_reg($result$$Register);
10060         __ bind(Lskip);
10061       }
10062     }
10063   %}
10064   ins_pipe(pipe_class_dummy);
10065 %}
10066 
10067 // Array equals
10068 instruct array_equalsB(iRegP ary1, iRegP ary2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10069   match(Set result (AryEq ary1 ary2));
10070   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10071   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10072   ins_cost(300);
10073   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result&quot; %}
10074   ins_encode %{
10075     __ array_equals(true, $ary1$$Register, $ary2$$Register,
10076                     noreg, $oddReg$$Register, $evenReg$$Register,
10077                     $result$$Register, true /* byte */);
10078   %}
10079   ins_pipe(pipe_class_dummy);
10080 %}
10081 
10082 instruct array_equalsC(iRegP ary1, iRegP ary2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10083   match(Set result (AryEq ary1 ary2));
10084   effect(TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10085   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10086   ins_cost(300);
10087   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result&quot; %}
10088   ins_encode %{
10089     __ array_equals(true, $ary1$$Register, $ary2$$Register,
10090                     noreg, $oddReg$$Register, $evenReg$$Register,
10091                     $result$$Register, false /* byte */);
10092   %}
10093   ins_pipe(pipe_class_dummy);
10094 %}
10095 
10096 // String CompareTo
10097 instruct string_compareL(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10098   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10099   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10100   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10101   ins_cost(300);
10102   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10103   ins_encode %{
10104     __ string_compare($str1$$Register, $str2$$Register,
10105                       $cnt1$$Register, $cnt2$$Register,
10106                       $oddReg$$Register, $evenReg$$Register,
10107                       $result$$Register, StrIntrinsicNode::LL);
10108   %}
10109   ins_pipe(pipe_class_dummy);
10110 %}
10111 
10112 instruct string_compareU(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10113   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10114   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10115   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10116   ins_cost(300);
10117   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10118   ins_encode %{
10119     __ string_compare($str1$$Register, $str2$$Register,
10120                       $cnt1$$Register, $cnt2$$Register,
10121                       $oddReg$$Register, $evenReg$$Register,
10122                       $result$$Register, StrIntrinsicNode::UU);
10123   %}
10124   ins_pipe(pipe_class_dummy);
10125 %}
10126 
10127 instruct string_compareLU(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10128   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10129   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10130   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
10131   ins_cost(300);
10132   format %{ &quot;String Compare byte[],char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10133   ins_encode %{
10134     __ string_compare($str1$$Register, $str2$$Register,
10135                       $cnt1$$Register, $cnt2$$Register,
10136                       $oddReg$$Register, $evenReg$$Register,
10137                       $result$$Register, StrIntrinsicNode::LU);
10138   %}
10139   ins_pipe(pipe_class_dummy);
10140 %}
10141 
10142 instruct string_compareUL(iRegP str1, iRegP str2, rarg2RegI cnt1, rarg5RegI cnt2, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10143   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10144   effect(TEMP_DEF result, USE_KILL cnt1, USE_KILL cnt2, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10145   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10146   ins_cost(300);
10147   format %{ &quot;String Compare char[],byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result&quot; %}
10148   ins_encode %{
10149     __ string_compare($str2$$Register, $str1$$Register,
10150                       $cnt2$$Register, $cnt1$$Register,
10151                       $oddReg$$Register, $evenReg$$Register,
10152                       $result$$Register, StrIntrinsicNode::UL);
10153   %}
10154   ins_pipe(pipe_class_dummy);
10155 %}
10156 
10157 // String IndexOfChar
10158 instruct indexOfChar_U(iRegP haystack, iRegI haycnt, iRegI ch, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10159   match(Set result (StrIndexOfChar (Binary haystack haycnt) ch));
10160   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10161   ins_cost(200);
10162   format %{ &quot;String IndexOfChar [0..$haycnt]($haystack), $ch -&gt; $result&quot; %}
10163   ins_encode %{
10164     __ string_indexof_char($result$$Register,
10165                            $haystack$$Register, $haycnt$$Register,
10166                            $ch$$Register, 0 /* unused, ch is in register */,
10167                            $oddReg$$Register, $evenReg$$Register, false /*is_byte*/);
10168   %}
10169   ins_pipe(pipe_class_dummy);
10170 %}
10171 
10172 instruct indexOf_imm1_U(iRegP haystack, iRegI haycnt, immP needle, immI_1 needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10173   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10174   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10175   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10176   ins_cost(200);
10177   format %{ &quot;String IndexOf UL [0..$haycnt]($haystack), [0]($needle) -&gt; $result&quot; %}
10178   ins_encode %{
10179     immPOper *needleOper = (immPOper *)$needle;
10180     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
10181     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
10182     jchar chr;
10183 #ifdef VM_LITTLE_ENDIAN
10184     Unimplemented();
10185 #else
10186     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte()) &lt;&lt; 8) |
10187            ((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte());
10188 #endif
10189     __ string_indexof_char($result$$Register,
10190                            $haystack$$Register, $haycnt$$Register,
10191                            noreg, chr,
10192                            $oddReg$$Register, $evenReg$$Register, false /*is_byte*/);
10193   %}
10194   ins_pipe(pipe_class_dummy);
10195 %}
10196 
10197 instruct indexOf_imm1_L(iRegP haystack, iRegI haycnt, immP needle, immI_1 needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10198   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10199   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10200   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10201   ins_cost(200);
10202   format %{ &quot;String IndexOf L [0..$haycnt]($haystack), [0]($needle) -&gt; $result&quot; %}
10203   ins_encode %{
10204     immPOper *needleOper = (immPOper *)$needle;
10205     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
10206     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
10207     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
10208     __ string_indexof_char($result$$Register,
10209                            $haystack$$Register, $haycnt$$Register,
10210                            noreg, chr,
10211                            $oddReg$$Register, $evenReg$$Register, true /*is_byte*/);
10212   %}
10213   ins_pipe(pipe_class_dummy);
10214 %}
10215 
10216 instruct indexOf_imm1_UL(iRegP haystack, iRegI haycnt, immP needle, immI_1 needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10217   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10218   effect(TEMP_DEF result, TEMP evenReg, TEMP oddReg, KILL cr); // R0, R1 are killed, too.
10219   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10220   ins_cost(200);
10221   format %{ &quot;String IndexOf UL [0..$haycnt]($haystack), [0]($needle) -&gt; $result&quot; %}
10222   ins_encode %{
10223     immPOper *needleOper = (immPOper *)$needle;
10224     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
10225     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
10226     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
10227     __ string_indexof_char($result$$Register,
10228                            $haystack$$Register, $haycnt$$Register,
10229                            noreg, chr,
10230                            $oddReg$$Register, $evenReg$$Register, false /*is_byte*/);
10231   %}
10232   ins_pipe(pipe_class_dummy);
10233 %}
10234 
10235 // String IndexOf
10236 instruct indexOf_imm_U(iRegP haystack, rarg2RegI haycnt, iRegP needle, immI16 needlecntImm, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10237   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
10238   effect(TEMP_DEF result, USE_KILL haycnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10239   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10240   ins_cost(250);
10241   format %{ &quot;String IndexOf U [0..$needlecntImm]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10242   ins_encode %{
10243     __ string_indexof($result$$Register,
10244                       $haystack$$Register, $haycnt$$Register,
10245                       $needle$$Register, noreg, $needlecntImm$$constant,
10246                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UU);
10247   %}
10248   ins_pipe(pipe_class_dummy);
10249 %}
10250 
10251 instruct indexOf_imm_L(iRegP haystack, rarg2RegI haycnt, iRegP needle, immI16 needlecntImm, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10252   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
10253   effect(TEMP_DEF result, USE_KILL haycnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10254   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10255   ins_cost(250);
10256   format %{ &quot;String IndexOf L [0..$needlecntImm]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10257   ins_encode %{
10258     __ string_indexof($result$$Register,
10259                       $haystack$$Register, $haycnt$$Register,
10260                       $needle$$Register, noreg, $needlecntImm$$constant,
10261                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::LL);
10262   %}
10263   ins_pipe(pipe_class_dummy);
10264 %}
10265 
10266 instruct indexOf_imm_UL(iRegP haystack, rarg2RegI haycnt, iRegP needle, immI16 needlecntImm, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10267   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
10268   effect(TEMP_DEF result, USE_KILL haycnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10269   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10270   ins_cost(250);
10271   format %{ &quot;String IndexOf UL [0..$needlecntImm]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10272   ins_encode %{
10273     __ string_indexof($result$$Register,
10274                       $haystack$$Register, $haycnt$$Register,
10275                       $needle$$Register, noreg, $needlecntImm$$constant,
10276                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UL);
10277   %}
10278   ins_pipe(pipe_class_dummy);
10279 %}
10280 
10281 instruct indexOf_U(iRegP haystack, rarg2RegI haycnt, iRegP needle, rarg5RegI needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10282   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10283   effect(TEMP_DEF result, USE_KILL haycnt, USE_KILL needlecnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10284   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU || ((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::none);
10285   ins_cost(300);
10286   format %{ &quot;String IndexOf U [0..$needlecnt]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10287   ins_encode %{
10288     __ string_indexof($result$$Register,
10289                       $haystack$$Register, $haycnt$$Register,
10290                       $needle$$Register, $needlecnt$$Register, 0,
10291                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UU);
10292   %}
10293   ins_pipe(pipe_class_dummy);
10294 %}
10295 
10296 instruct indexOf_L(iRegP haystack, rarg2RegI haycnt, iRegP needle, rarg5RegI needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10297   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10298   effect(TEMP_DEF result, USE_KILL haycnt, USE_KILL needlecnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10299   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10300   ins_cost(300);
10301   format %{ &quot;String IndexOf L [0..$needlecnt]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10302   ins_encode %{
10303     __ string_indexof($result$$Register,
10304                       $haystack$$Register, $haycnt$$Register,
10305                       $needle$$Register, $needlecnt$$Register, 0,
10306                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::LL);
10307   %}
10308   ins_pipe(pipe_class_dummy);
10309 %}
10310 
10311 instruct indexOf_UL(iRegP haystack, rarg2RegI haycnt, iRegP needle, rarg5RegI needlecnt, iRegI result, roddRegL oddReg, revenRegL evenReg, flagsReg cr) %{
10312   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
10313   effect(TEMP_DEF result, USE_KILL haycnt, USE_KILL needlecnt, TEMP oddReg, TEMP evenReg, KILL cr); // R0, R1 are killed, too.
10314   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10315   ins_cost(300);
10316   format %{ &quot;String IndexOf UL [0..$needlecnt]($needle) .in. [0..$haycnt]($haystack) -&gt; $result&quot; %}
10317   ins_encode %{
10318     __ string_indexof($result$$Register,
10319                       $haystack$$Register, $haycnt$$Register,
10320                       $needle$$Register, $needlecnt$$Register, 0,
10321                       $oddReg$$Register, $evenReg$$Register, StrIntrinsicNode::UL);
10322   %}
10323   ins_pipe(pipe_class_dummy);
10324 %}
10325 
10326 // char[] to byte[] compression
10327 instruct string_compress(iRegP src, iRegP dst, iRegI result, iRegI len, iRegI tmp, flagsReg cr) %{
10328   match(Set result (StrCompressedCopy src (Binary dst len)));
10329   effect(TEMP_DEF result, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10330   ins_cost(300);
10331   format %{ &quot;String Compress $src-&gt;$dst($len) -&gt; $result&quot; %}
10332   ins_encode %{
10333     __ string_compress($result$$Register, $src$$Register, $dst$$Register, $len$$Register,
10334                        $tmp$$Register, false);
10335   %}
10336   ins_pipe(pipe_class_dummy);
10337 %}
10338 
10339 // byte[] to char[] inflation. trot implementation is shorter, but slower than the unrolled icm(h) loop.
10340 //instruct string_inflate_trot(Universe dummy, iRegP src, revenRegP dst, roddRegI len, iRegI tmp, flagsReg cr) %{
10341 //  match(Set dummy (StrInflatedCopy src (Binary dst len)));
10342 //  effect(USE_KILL dst, USE_KILL len, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10343 //  predicate(VM_Version::has_ETF2Enhancements());
10344 //  ins_cost(300);
10345 //  format %{ &quot;String Inflate (trot) $dst,$src($len)&quot; %}
10346 //  ins_encode %{
10347 //    __ string_inflate_trot($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register);
10348 //  %}
10349 //  ins_pipe(pipe_class_dummy);
10350 //%}
10351 
10352 // byte[] to char[] inflation
10353 instruct string_inflate(Universe dummy, iRegP src, iRegP dst, iRegI len, iRegI tmp, flagsReg cr) %{
10354   match(Set dummy (StrInflatedCopy src (Binary dst len)));
10355   effect(TEMP tmp, KILL cr); // R0, R1 are killed, too.
10356   ins_cost(300);
10357   format %{ &quot;String Inflate $src-&gt;$dst($len)&quot; %}
10358   ins_encode %{
10359     __ string_inflate($src$$Register, $dst$$Register, $len$$Register, $tmp$$Register);
10360   %}
10361   ins_pipe(pipe_class_dummy);
10362 %}
10363 
10364 // byte[] to char[] inflation
10365 instruct string_inflate_const(Universe dummy, iRegP src, iRegP dst, iRegI tmp, immI len, flagsReg cr) %{
10366   match(Set dummy (StrInflatedCopy src (Binary dst len)));
10367   effect(TEMP tmp, KILL cr); // R0, R1 are killed, too.
10368   ins_cost(300);
10369   format %{ &quot;String Inflate (constLen) $src-&gt;$dst($len)&quot; %}
10370   ins_encode %{
10371     __ string_inflate_const($src$$Register, $dst$$Register, $tmp$$Register, $len$$constant);
10372   %}
10373   ins_pipe(pipe_class_dummy);
10374 %}
10375 
10376 // StringCoding.java intrinsics
10377 instruct has_negatives(rarg5RegP ary1, iRegI len, iRegI result, roddRegI oddReg, revenRegI evenReg, iRegI tmp, flagsReg cr) %{
10378   match(Set result (HasNegatives ary1 len));
10379   effect(TEMP_DEF result, USE_KILL ary1, TEMP oddReg, TEMP evenReg, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10380   ins_cost(300);
10381   format %{ &quot;has negatives byte[] $ary1($len) -&gt; $result&quot; %}
10382   ins_encode %{
10383     __ has_negatives($result$$Register, $ary1$$Register, $len$$Register,
10384                      $oddReg$$Register, $evenReg$$Register, $tmp$$Register);
10385   %}
10386   ins_pipe(pipe_class_dummy);
10387 %}
10388 
10389 // encode char[] to byte[] in ISO_8859_1
10390 instruct encode_iso_array(iRegP src, iRegP dst, iRegI result, iRegI len, iRegI tmp, flagsReg cr) %{
10391   match(Set result (EncodeISOArray src (Binary dst len)));
10392   effect(TEMP_DEF result, TEMP tmp, KILL cr); // R0, R1 are killed, too.
10393   ins_cost(300);
10394   format %{ &quot;Encode array $src-&gt;$dst($len) -&gt; $result&quot; %}
10395   ins_encode %{
10396     __ string_compress($result$$Register, $src$$Register, $dst$$Register, $len$$Register,
10397                        $tmp$$Register, true);
10398   %}
10399   ins_pipe(pipe_class_dummy);
10400 %}
10401 
10402 
10403 //----------PEEPHOLE RULES-----------------------------------------------------
10404 // These must follow all instruction definitions as they use the names
10405 // defined in the instructions definitions.
10406 //
10407 // peepmatch (root_instr_name [preceeding_instruction]*);
10408 //
10409 // peepconstraint %{
10410 // (instruction_number.operand_name relational_op instruction_number.operand_name
10411 //  [, ...]);
10412 // // instruction numbers are zero-based using left to right order in peepmatch
10413 //
10414 // peepreplace (instr_name([instruction_number.operand_name]*));
10415 // // provide an instruction_number.operand_name for each operand that appears
10416 // // in the replacement instruction&#39;s match rule
10417 //
10418 // ---------VM FLAGS---------------------------------------------------------
10419 //
10420 // All peephole optimizations can be turned off using -XX:-OptoPeephole
10421 //
10422 // Each peephole rule is given an identifying number starting with zero and
10423 // increasing by one in the order seen by the parser. An individual peephole
10424 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
10425 // on the command-line.
10426 //
10427 // ---------CURRENT LIMITATIONS----------------------------------------------
10428 //
10429 // Only match adjacent instructions in same basic block
10430 // Only equality constraints
10431 // Only constraints between operands, not (0.dest_reg == EAX_enc)
10432 // Only one replacement instruction
10433 //
10434 // ---------EXAMPLE----------------------------------------------------------
10435 //
10436 // // pertinent parts of existing instructions in architecture description
10437 // instruct movI(eRegI dst, eRegI src) %{
10438 //   match(Set dst (CopyI src));
10439 // %}
10440 //
10441 // instruct incI_eReg(eRegI dst, immI1 src, eFlagsReg cr) %{
10442 //   match(Set dst (AddI dst src));
10443 //   effect(KILL cr);
10444 // %}
10445 //
10446 // // Change (inc mov) to lea
10447 // peephole %{
10448 //   // increment preceeded by register-register move
10449 //   peepmatch (incI_eReg movI);
10450 //   // require that the destination register of the increment
10451 //   // match the destination register of the move
10452 //   peepconstraint (0.dst == 1.dst);
10453 //   // construct a replacement instruction that sets
10454 //   // the destination to (move&#39;s source register + one)
10455 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10456 // %}
10457 //
10458 // Implementation no longer uses movX instructions since
10459 // machine-independent system no longer uses CopyX nodes.
10460 //
10461 // peephole %{
10462 //   peepmatch (incI_eReg movI);
10463 //   peepconstraint (0.dst == 1.dst);
10464 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10465 // %}
10466 //
10467 // peephole %{
10468 //   peepmatch (decI_eReg movI);
10469 //   peepconstraint (0.dst == 1.dst);
10470 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10471 // %}
10472 //
10473 // peephole %{
10474 //   peepmatch (addI_eReg_imm movI);
10475 //   peepconstraint (0.dst == 1.dst);
10476 //   peepreplace (leaI_eReg_immI(0.dst 1.src 0.src));
10477 // %}
10478 //
10479 // peephole %{
10480 //   peepmatch (addP_eReg_imm movP);
10481 //   peepconstraint (0.dst == 1.dst);
10482 //   peepreplace (leaP_eReg_immI(0.dst 1.src 0.src));
10483 // %}
10484 
10485 
10486 //  This peephole rule does not work, probably because ADLC can&#39;t handle two effects:
10487 //  Effect 1 is defining 0.op1 and effect 2 is setting CC
10488 // condense a load from memory and subsequent test for zero
10489 // into a single, more efficient ICM instruction.
10490 // peephole %{
10491 //   peepmatch (compI_iReg_imm0 loadI);
10492 //   peepconstraint (1.dst == 0.op1);
10493 //   peepreplace (loadtest15_iReg_mem(0.op1 0.op1 1.mem));
10494 // %}
10495 
10496 // // Change load of spilled value to only a spill
10497 // instruct storeI(memory mem, eRegI src) %{
10498 //   match(Set mem (StoreI mem src));
10499 // %}
10500 //
10501 // instruct loadI(eRegI dst, memory mem) %{
10502 //   match(Set dst (LoadI mem));
10503 // %}
10504 //
10505 peephole %{
10506   peepmatch (loadI storeI);
10507   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
10508   peepreplace (storeI(1.mem 1.mem 1.src));
10509 %}
10510 
10511 peephole %{
10512   peepmatch (loadL storeL);
10513   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
10514   peepreplace (storeL(1.mem 1.mem 1.src));
10515 %}
10516 
10517 peephole %{
10518   peepmatch (loadP storeP);
10519   peepconstraint (1.src == 0.dst, 1.dst == 0.mem);
10520   peepreplace (storeP(1.dst 1.dst 1.src));
10521 %}
10522 
10523 //----------SUPERWORD RULES---------------------------------------------------
10524 
10525 //  Expand rules for special cases
10526 
10527 instruct expand_storeF(stackSlotF mem, regF src) %{
10528   // No match rule, false predicate, for expand only.
10529   effect(DEF mem, USE src);
10530   predicate(false);
10531   ins_cost(MEMORY_REF_COST);
10532   // TODO: s390 port size(FIXED_SIZE);
10533   format %{ &quot;STE      $src,$mem\t # replicate(float2stack)&quot; %}
10534   opcode(STE_ZOPC, STE_ZOPC);
10535   ins_encode(z_form_rt_mem(src, mem));
10536   ins_pipe(pipe_class_dummy);
10537 %}
10538 
10539 instruct expand_LoadLogical_I2L(iRegL dst, stackSlotF mem) %{
10540   // No match rule, false predicate, for expand only.
10541   effect(DEF dst, USE mem);
10542   predicate(false);
10543   ins_cost(MEMORY_REF_COST);
10544   // TODO: s390 port size(FIXED_SIZE);
10545   format %{ &quot;LLGF     $dst,$mem\t # replicate(stack2reg(unsigned))&quot; %}
10546   opcode(LLGF_ZOPC, LLGF_ZOPC);
10547   ins_encode(z_form_rt_mem(dst, mem));
10548   ins_pipe(pipe_class_dummy);
10549 %}
10550 
10551 // Replicate scalar int to packed int values (8 Bytes)
10552 instruct expand_Repl2I_reg(iRegL dst, iRegL src) %{
10553   // Dummy match rule, false predicate, for expand only.
10554   match(Set dst (ConvI2L src));
10555   predicate(false);
10556   ins_cost(DEFAULT_COST);
10557   // TODO: s390 port size(FIXED_SIZE);
10558   format %{ &quot;REPLIC2F $dst,$src\t # replicate(pack2F)&quot; %}
10559   ins_encode %{
10560     if ($dst$$Register == $src$$Register) {
10561       __ z_sllg(Z_R0_scratch, $src$$Register, 64-32);
10562       __ z_ogr($dst$$Register, Z_R0_scratch);
10563     }  else {
10564       __ z_sllg($dst$$Register, $src$$Register, 64-32);
10565       __ z_ogr( $dst$$Register, $src$$Register);
10566     }
10567   %}
10568   ins_pipe(pipe_class_dummy);
10569 %}
10570 
10571 // Replication
10572 
10573 // Exploit rotate_then_insert, if available
10574 // Replicate scalar byte to packed byte values (8 Bytes).
10575 instruct Repl8B_reg_risbg(iRegL dst, iRegI src, flagsReg cr) %{
10576   match(Set dst (ReplicateB src));
10577   effect(KILL cr);
10578   predicate((n-&gt;as_Vector()-&gt;length() == 8));
10579   format %{ &quot;REPLIC8B $dst,$src\t # pack8B&quot; %}
10580   ins_encode %{
10581     if ($dst$$Register != $src$$Register) {
10582       __ z_lgr($dst$$Register, $src$$Register);
10583     }
10584     __ rotate_then_insert($dst$$Register, $dst$$Register, 48, 55,  8, false);
10585     __ rotate_then_insert($dst$$Register, $dst$$Register, 32, 47, 16, false);
10586     __ rotate_then_insert($dst$$Register, $dst$$Register,  0, 31, 32, false);
10587   %}
10588   ins_pipe(pipe_class_dummy);
10589 %}
10590 
10591 // Replicate scalar byte to packed byte values (8 Bytes).
10592 instruct Repl8B_imm(iRegL dst, immB_n0m1 src) %{
10593   match(Set dst (ReplicateB src));
10594   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10595   ins_should_rematerialize(true);
10596   format %{ &quot;REPLIC8B $dst,$src\t # pack8B imm&quot; %}
10597   ins_encode %{
10598     int64_t  Isrc8 = $src$$constant &amp; 0x000000ff;
10599     int64_t Isrc16 =  Isrc8 &lt;&lt;  8 |  Isrc8;
10600     int64_t Isrc32 = Isrc16 &lt;&lt; 16 | Isrc16;
10601     assert(Isrc8 != 0x000000ff &amp;&amp; Isrc8 != 0, &quot;should be handled by other match rules.&quot;);
10602 
10603     __ z_llilf($dst$$Register, Isrc32);
10604     __ z_iihf($dst$$Register, Isrc32);
10605   %}
10606   ins_pipe(pipe_class_dummy);
10607 %}
10608 
10609 // Replicate scalar byte to packed byte values (8 Bytes).
10610 instruct Repl8B_imm0(iRegL dst, immI_0 src) %{
10611   match(Set dst (ReplicateB src));
10612   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10613   ins_should_rematerialize(true);
10614   format %{ &quot;REPLIC8B $dst,$src\t # pack8B imm0&quot; %}
10615   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10616   ins_pipe(pipe_class_dummy);
10617 %}
10618 
10619 // Replicate scalar byte to packed byte values (8 Bytes).
10620 instruct Repl8B_immm1(iRegL dst, immB_minus1 src) %{
10621   match(Set dst (ReplicateB src));
10622   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10623   ins_should_rematerialize(true);
10624   format %{ &quot;REPLIC8B $dst,$src\t # pack8B immm1&quot; %}
10625   ins_encode %{ __ z_lghi($dst$$Register, -1); %}
10626   ins_pipe(pipe_class_dummy);
10627 %}
10628 
10629 // Exploit rotate_then_insert, if available
10630 // Replicate scalar short to packed short values (8 Bytes).
10631 instruct Repl4S_reg_risbg(iRegL dst, iRegI src, flagsReg cr) %{
10632   match(Set dst (ReplicateS src));
10633   effect(KILL cr);
10634   predicate((n-&gt;as_Vector()-&gt;length() == 4));
10635   format %{ &quot;REPLIC4S $dst,$src\t # pack4S&quot; %}
10636   ins_encode %{
10637     if ($dst$$Register != $src$$Register) {
10638       __ z_lgr($dst$$Register, $src$$Register);
10639     }
10640     __ rotate_then_insert($dst$$Register, $dst$$Register, 32, 47, 16, false);
10641     __ rotate_then_insert($dst$$Register, $dst$$Register,  0, 31, 32, false);
10642   %}
10643   ins_pipe(pipe_class_dummy);
10644 %}
10645 
10646 // Replicate scalar short to packed short values (8 Bytes).
10647 instruct Repl4S_imm(iRegL dst, immS_n0m1 src) %{
10648   match(Set dst (ReplicateS src));
10649   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10650   ins_should_rematerialize(true);
10651   format %{ &quot;REPLIC4S $dst,$src\t # pack4S imm&quot; %}
10652   ins_encode %{
10653     int64_t Isrc16 = $src$$constant &amp; 0x0000ffff;
10654     int64_t Isrc32 = Isrc16 &lt;&lt; 16 | Isrc16;
10655     assert(Isrc16 != 0x0000ffff &amp;&amp; Isrc16 != 0, &quot;Repl4S_imm: (src == &quot; INT64_FORMAT
10656            &quot;) should be handled by other match rules.&quot;, $src$$constant);
10657 
10658     __ z_llilf($dst$$Register, Isrc32);
10659     __ z_iihf($dst$$Register, Isrc32);
10660   %}
10661   ins_pipe(pipe_class_dummy);
10662 %}
10663 
10664 // Replicate scalar short to packed short values (8 Bytes).
10665 instruct Repl4S_imm0(iRegL dst, immI_0 src) %{
10666   match(Set dst (ReplicateS src));
10667   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10668   ins_should_rematerialize(true);
10669   format %{ &quot;REPLIC4S $dst,$src\t # pack4S imm0&quot; %}
10670   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10671   ins_pipe(pipe_class_dummy);
10672 %}
10673 
10674 // Replicate scalar short to packed short values (8 Bytes).
10675 instruct Repl4S_immm1(iRegL dst, immS_minus1 src) %{
10676   match(Set dst (ReplicateS src));
10677   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10678   ins_should_rematerialize(true);
10679   format %{ &quot;REPLIC4S $dst,$src\t # pack4S immm1&quot; %}
10680   ins_encode %{ __ z_lghi($dst$$Register, -1); %}
10681   ins_pipe(pipe_class_dummy);
10682 %}
10683 
10684 // Exploit rotate_then_insert, if available.
10685 // Replicate scalar int to packed int values (8 Bytes).
10686 instruct Repl2I_reg_risbg(iRegL dst, iRegI src, flagsReg cr) %{
10687   match(Set dst (ReplicateI src));
10688   effect(KILL cr);
10689   predicate((n-&gt;as_Vector()-&gt;length() == 2));
10690   format %{ &quot;REPLIC2I $dst,$src\t # pack2I&quot; %}
10691   ins_encode %{
10692     if ($dst$$Register != $src$$Register) {
10693       __ z_lgr($dst$$Register, $src$$Register);
10694     }
10695     __ rotate_then_insert($dst$$Register, $dst$$Register, 0, 31, 32, false);
10696   %}
10697   ins_pipe(pipe_class_dummy);
10698 %}
10699 
10700 // Replicate scalar int to packed int values (8 Bytes).
10701 instruct Repl2I_imm(iRegL dst, immI_n0m1 src) %{
10702   match(Set dst (ReplicateI src));
10703   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10704   ins_should_rematerialize(true);
10705   format %{ &quot;REPLIC2I $dst,$src\t # pack2I imm&quot; %}
10706   ins_encode %{
10707     int64_t Isrc32 = $src$$constant;
10708     assert(Isrc32 != -1 &amp;&amp; Isrc32 != 0, &quot;should be handled by other match rules.&quot;);
10709 
10710     __ z_llilf($dst$$Register, Isrc32);
10711     __ z_iihf($dst$$Register, Isrc32);
10712   %}
10713   ins_pipe(pipe_class_dummy);
10714 %}
10715 
10716 // Replicate scalar int to packed int values (8 Bytes).
10717 instruct Repl2I_imm0(iRegL dst, immI_0 src) %{
10718   match(Set dst (ReplicateI src));
10719   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10720   ins_should_rematerialize(true);
10721   format %{ &quot;REPLIC2I $dst,$src\t # pack2I imm0&quot; %}
10722   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10723   ins_pipe(pipe_class_dummy);
10724 %}
10725 
10726 // Replicate scalar int to packed int values (8 Bytes).
10727 instruct Repl2I_immm1(iRegL dst, immI_minus1 src) %{
10728   match(Set dst (ReplicateI src));
10729   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10730   ins_should_rematerialize(true);
10731   format %{ &quot;REPLIC2I $dst,$src\t # pack2I immm1&quot; %}
10732   ins_encode %{ __ z_lghi($dst$$Register, -1); %}
10733   ins_pipe(pipe_class_dummy);
10734 %}
10735 
10736 //
10737 
10738 instruct Repl2F_reg_indirect(iRegL dst, regF src, flagsReg cr) %{
10739   match(Set dst (ReplicateF src));
10740   effect(KILL cr);
10741   predicate(!VM_Version::has_FPSupportEnhancements() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);
10742   format %{ &quot;REPLIC2F $dst,$src\t # pack2F indirect&quot; %}
10743   expand %{
10744     stackSlotF tmp;
10745     iRegL      tmp2;
10746     expand_storeF(tmp, src);
10747     expand_LoadLogical_I2L(tmp2, tmp);
10748     expand_Repl2I_reg(dst, tmp2);
10749   %}
10750 %}
10751 
10752 // Replicate scalar float to packed float values in GREG (8 Bytes).
10753 instruct Repl2F_reg_direct(iRegL dst, regF src, flagsReg cr) %{
10754   match(Set dst (ReplicateF src));
10755   effect(KILL cr);
10756   predicate(VM_Version::has_FPSupportEnhancements() &amp;&amp; n-&gt;as_Vector()-&gt;length() == 2);
10757   format %{ &quot;REPLIC2F $dst,$src\t # pack2F direct&quot; %}
10758   ins_encode %{
10759     assert(VM_Version::has_FPSupportEnhancements(), &quot;encoder should never be called on old H/W&quot;);
10760     __ z_lgdr($dst$$Register, $src$$FloatRegister);
10761 
10762     __ z_srlg(Z_R0_scratch, $dst$$Register, 32);  // Floats are left-justified in 64bit reg.
10763     __ z_iilf($dst$$Register, 0);                 // Save a &quot;result not ready&quot; stall.
10764     __ z_ogr($dst$$Register, Z_R0_scratch);
10765   %}
10766   ins_pipe(pipe_class_dummy);
10767 %}
10768 
10769 // Replicate scalar float immediate to packed float values in GREG (8 Bytes).
10770 instruct Repl2F_imm(iRegL dst, immF src) %{
10771   match(Set dst (ReplicateF src));
10772   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10773   ins_should_rematerialize(true);
10774   format %{ &quot;REPLIC2F $dst,$src\t # pack2F imm&quot; %}
10775   ins_encode %{
10776     union {
10777       int   Isrc32;
10778       float Fsrc32;
10779     };
10780     Fsrc32 = $src$$constant;
10781     __ z_llilf($dst$$Register, Isrc32);
10782     __ z_iihf($dst$$Register, Isrc32);
10783   %}
10784   ins_pipe(pipe_class_dummy);
10785 %}
10786 
10787 // Replicate scalar float immediate zeroes to packed float values in GREG (8 Bytes).
10788 // Do this only for &#39;real&#39; zeroes, especially don&#39;t loose sign of negative zeroes.
10789 instruct Repl2F_imm0(iRegL dst, immFp0 src) %{
10790   match(Set dst (ReplicateF src));
10791   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10792   ins_should_rematerialize(true);
10793   format %{ &quot;REPLIC2F $dst,$src\t # pack2F imm0&quot; %}
10794   ins_encode %{ __ z_laz($dst$$Register, 0, Z_R0); %}
10795   ins_pipe(pipe_class_dummy);
10796 %}
10797 
10798 // Store
10799 
10800 // Store Aligned Packed Byte register to memory (8 Bytes).
10801 instruct storeA8B(memory mem, iRegL src) %{
10802   match(Set mem (StoreVector mem src));
10803   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
10804   ins_cost(MEMORY_REF_COST);
10805   // TODO: s390 port size(VARIABLE_SIZE);
10806   format %{ &quot;STG     $src,$mem\t # ST(packed8B)&quot; %}
10807   opcode(STG_ZOPC, STG_ZOPC);
10808   ins_encode(z_form_rt_mem_opt(src, mem));
10809   ins_pipe(pipe_class_dummy);
10810 %}
10811 
10812 // Load
10813 
10814 instruct loadV8(iRegL dst, memory mem) %{
10815   match(Set dst (LoadVector mem));
10816   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);
10817   ins_cost(MEMORY_REF_COST);
10818   // TODO: s390 port size(VARIABLE_SIZE);
10819   format %{ &quot;LG      $dst,$mem\t # L(packed8B)&quot; %}
10820   opcode(LG_ZOPC, LG_ZOPC);
10821   ins_encode(z_form_rt_mem_opt(dst, mem));
10822   ins_pipe(pipe_class_dummy);
10823 %}
10824 
10825 //----------POPULATION COUNT RULES--------------------------------------------
10826 
10827 // Byte reverse
10828 
10829 instruct bytes_reverse_int(iRegI dst, iRegI src) %{
10830   match(Set dst (ReverseBytesI src));
10831   predicate(UseByteReverseInstruction);  // See Matcher::match_rule_supported
10832   ins_cost(DEFAULT_COST);
10833   size(4);
10834   format %{ &quot;LRVR    $dst,$src\t # byte reverse int&quot; %}
10835   opcode(LRVR_ZOPC);
10836   ins_encode(z_rreform(dst, src));
10837   ins_pipe(pipe_class_dummy);
10838 %}
10839 
10840 instruct bytes_reverse_long(iRegL dst, iRegL src) %{
10841   match(Set dst (ReverseBytesL src));
10842   predicate(UseByteReverseInstruction);  // See Matcher::match_rule_supported
10843   ins_cost(DEFAULT_COST);
10844   // TODO: s390 port size(FIXED_SIZE);
10845   format %{ &quot;LRVGR   $dst,$src\t # byte reverse long&quot; %}
10846   opcode(LRVGR_ZOPC);
10847   ins_encode(z_rreform(dst, src));
10848   ins_pipe(pipe_class_dummy);
10849 %}
10850 
10851 // Leading zeroes
10852 
10853 // The instruction FLOGR (Find Leftmost One in Grande (64bit) Register)
10854 // returns the bit position of the leftmost 1 in the 64bit source register.
10855 // As the bits are numbered from left to right (0..63), the returned
10856 // position index is equivalent to the number of leading zeroes.
10857 // If no 1-bit is found (i.e. the regsiter contains zero), the instruction
10858 // returns position 64. That&#39;s exactly what we need.
10859 
10860 instruct countLeadingZerosI(revenRegI dst, iRegI src, roddRegI tmp, flagsReg cr) %{
10861   match(Set dst (CountLeadingZerosI src));
10862   effect(KILL tmp, KILL cr);
10863   ins_cost(3 * DEFAULT_COST);
10864   size(14);
10865   format %{ &quot;SLLG    $dst,$src,32\t # no need to always count 32 zeroes first\n\t&quot;
10866             &quot;IILH    $dst,0x8000 \t # insert \&quot;stop bit\&quot; to force result 32 for zero src.\n\t&quot;
10867             &quot;FLOGR   $dst,$dst&quot;
10868          %}
10869   ins_encode %{
10870     // Performance experiments indicate that &quot;FLOGR&quot; is using some kind of
10871     // iteration to find the leftmost &quot;1&quot; bit.
10872     //
10873     // The prior implementation zero-extended the 32-bit argument to 64 bit,
10874     // thus forcing &quot;FLOGR&quot; to count 32 bits of which we know they are zero.
10875     // We could gain measurable speedup in micro benchmark:
10876     //
10877     //               leading   trailing
10878     //   z10:   int     2.04       1.68
10879     //         long     1.00       1.02
10880     //   z196:  int     0.99       1.23
10881     //         long     1.00       1.11
10882     //
10883     // By shifting the argument into the high-word instead of zero-extending it.
10884     // The add&#39;l branch on condition (taken for a zero argument, very infrequent,
10885     // good prediction) is well compensated for by the savings.
10886     //
10887     // We leave the previous implementation in for some time in the future when
10888     // the &quot;FLOGR&quot; instruction may become less iterative.
10889 
10890     // Version 2: shows 62%(z9), 204%(z10), -1%(z196) improvement over original
10891     __ z_sllg($dst$$Register, $src$$Register, 32); // No need to always count 32 zeroes first.
10892     __ z_iilh($dst$$Register, 0x8000);   // Insert &quot;stop bit&quot; to force result 32 for zero src.
10893     __ z_flogr($dst$$Register, $dst$$Register);
10894   %}
10895   ins_pipe(pipe_class_dummy);
10896 %}
10897 
10898 instruct countLeadingZerosL(revenRegI dst, iRegL src, roddRegI tmp, flagsReg cr) %{
10899   match(Set dst (CountLeadingZerosL src));
10900   effect(KILL tmp, KILL cr);
10901   ins_cost(DEFAULT_COST);
10902   size(4);
10903   format %{ &quot;FLOGR   $dst,$src \t # count leading zeros (long)\n\t&quot; %}
10904   ins_encode %{ __ z_flogr($dst$$Register, $src$$Register); %}
10905   ins_pipe(pipe_class_dummy);
10906 %}
10907 
10908 // trailing zeroes
10909 
10910 // We transform the trailing zeroes problem to a leading zeroes problem
10911 // such that can use the FLOGR instruction to our advantage.
10912 
10913 // With
10914 //   tmp1 = src - 1
10915 // we flip all trailing zeroes to ones and the rightmost one to zero.
10916 // All other bits remain unchanged.
10917 // With the complement
10918 //   tmp2 = ~src
10919 // we get all ones in the trailing zeroes positions. Thus,
10920 //   tmp3 = tmp1 &amp; tmp2
10921 // yields ones in the trailing zeroes positions and zeroes elsewhere.
10922 // Now we can apply FLOGR and get 64-(trailing zeroes).
10923 instruct countTrailingZerosI(revenRegI dst, iRegI src, roddRegI tmp, flagsReg cr) %{
10924   match(Set dst (CountTrailingZerosI src));
10925   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
10926   ins_cost(8 * DEFAULT_COST);
10927   // TODO: s390 port size(FIXED_SIZE);  // Emitted code depends on PreferLAoverADD being on/off.
10928   format %{ &quot;LLGFR   $dst,$src  \t # clear upper 32 bits (we are dealing with int)\n\t&quot;
10929             &quot;LCGFR   $tmp,$src  \t # load 2&#39;s complement (32-&gt;64 bit)\n\t&quot;
10930             &quot;AGHI    $dst,-1    \t # tmp1 = src-1\n\t&quot;
10931             &quot;AGHI    $tmp,-1    \t # tmp2 = -src-1 = ~src\n\t&quot;
10932             &quot;NGR     $dst,$tmp  \t # tmp3 = tmp1&amp;tmp2\n\t&quot;
10933             &quot;FLOGR   $dst,$dst  \t # count trailing zeros (int)\n\t&quot;
10934             &quot;AHI     $dst,-64   \t # tmp4 = 64-(trailing zeroes)-64\n\t&quot;
10935             &quot;LCR     $dst,$dst  \t # res = -tmp4&quot;
10936          %}
10937   ins_encode %{
10938     Register Rdst = $dst$$Register;
10939     Register Rsrc = $src$$Register;
10940     // Rtmp only needed for for zero-argument shortcut. With kill effect in
10941     // match rule Rsrc = roddReg would be possible, saving one register.
10942     Register Rtmp = $tmp$$Register;
10943 
10944     assert_different_registers(Rdst, Rsrc, Rtmp);
10945 
10946     // Algorithm:
10947     // - Isolate the least significant (rightmost) set bit using (src &amp; (-src)).
10948     //   All other bits in the result are zero.
10949     // - Find the &quot;leftmost one&quot; bit position in the single-bit result from previous step.
10950     // - 63-(&quot;leftmost one&quot; bit position) gives the # of trailing zeros.
10951 
10952     // Version 2: shows 79%(z9), 68%(z10), 23%(z196) improvement over original.
10953     Label done;
10954     __ load_const_optimized(Rdst, 32); // Prepare for shortcut (zero argument), result will be 32.
10955     __ z_lcgfr(Rtmp, Rsrc);
10956     __ z_bre(done);                    // Taken very infrequently, good prediction, no BHT entry.
10957 
10958     __ z_nr(Rtmp, Rsrc);               // (src) &amp; (-src) leaves nothing but least significant bit.
10959     __ z_ahi(Rtmp,  -1);               // Subtract one to fill all trailing zero positions with ones.
10960                                        // Use 32bit op to prevent borrow propagation (case Rdst = 0x80000000)
10961                                        // into upper half of reg. Not relevant with sllg below.
10962     __ z_sllg(Rdst, Rtmp, 32);         // Shift interesting contents to upper half of register.
10963     __ z_bre(done);                    // Shortcut for argument = 1, result will be 0.
10964                                        // Depends on CC set by ahi above.
10965                                        // Taken very infrequently, good prediction, no BHT entry.
10966                                        // Branch delayed to have Rdst set correctly (Rtmp == 0(32bit)
10967                                        // after SLLG Rdst == 0(64bit)).
10968     __ z_flogr(Rdst, Rdst);            // Kills tmp which is the oddReg for dst.
10969     __ add2reg(Rdst,  -32);            // 32-pos(leftmost1) is #trailing zeros
10970     __ z_lcgfr(Rdst, Rdst);            // Provide 64bit result at no cost.
10971     __ bind(done);
10972   %}
10973   ins_pipe(pipe_class_dummy);
10974 %}
10975 
10976 instruct countTrailingZerosL(revenRegI dst, iRegL src, roddRegL tmp, flagsReg cr) %{
10977   match(Set dst (CountTrailingZerosL src));
10978   effect(TEMP_DEF dst, KILL tmp, KILL cr);
10979   ins_cost(8 * DEFAULT_COST);
10980   // TODO: s390 port size(FIXED_SIZE);  // Emitted code depends on PreferLAoverADD being on/off.
10981   format %{ &quot;LCGR    $dst,$src  \t # preserve src\n\t&quot;
10982             &quot;NGR     $dst,$src  \t #\n\t&quot;
10983             &quot;AGHI    $dst,-1    \t # tmp1 = src-1\n\t&quot;
10984             &quot;FLOGR   $dst,$dst  \t # count trailing zeros (long), kill $tmp\n\t&quot;
10985             &quot;AHI     $dst,-64   \t # tmp4 = 64-(trailing zeroes)-64\n\t&quot;
10986             &quot;LCR     $dst,$dst  \t #&quot;
10987          %}
10988   ins_encode %{
10989     Register Rdst = $dst$$Register;
10990     Register Rsrc = $src$$Register;
10991     assert_different_registers(Rdst, Rsrc); // Rtmp == Rsrc allowed.
10992 
10993     // New version: shows 5%(z9), 2%(z10), 11%(z196) improvement over original.
10994     __ z_lcgr(Rdst, Rsrc);
10995     __ z_ngr(Rdst, Rsrc);
10996     __ add2reg(Rdst,   -1);
10997     __ z_flogr(Rdst, Rdst); // Kills tmp which is the oddReg for dst.
10998     __ add2reg(Rdst,  -64);
10999     __ z_lcgfr(Rdst, Rdst); // Provide 64bit result at no cost.
11000   %}
11001   ins_pipe(pipe_class_dummy);
11002 %}
11003 
11004 
11005 // bit count
11006 
11007 instruct popCountI(iRegI dst, iRegI src, iRegI tmp, flagsReg cr) %{
11008   match(Set dst (PopCountI src));
11009   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
11010   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount());
11011   ins_cost(DEFAULT_COST);
11012   size(24);
11013   format %{ &quot;POPCNT  $dst,$src\t # pop count int&quot; %}
11014   ins_encode %{
11015     Register Rdst = $dst$$Register;
11016     Register Rsrc = $src$$Register;
11017     Register Rtmp = $tmp$$Register;
11018 
11019     // Prefer compile-time assertion over run-time SIGILL.
11020     assert(VM_Version::has_PopCount(), &quot;bad predicate for countLeadingZerosI&quot;);
11021     assert_different_registers(Rdst, Rtmp);
11022 
11023     // Version 2: shows 10%(z196) improvement over original.
11024     __ z_popcnt(Rdst, Rsrc);
11025     __ z_srlg(Rtmp, Rdst, 16); // calc  byte4+byte6 and byte5+byte7
11026     __ z_alr(Rdst, Rtmp);      //   into byte6 and byte7
11027     __ z_srlg(Rtmp, Rdst,  8); // calc (byte4+byte6) + (byte5+byte7)
11028     __ z_alr(Rdst, Rtmp);      //   into byte7
11029     __ z_llgcr(Rdst, Rdst);    // zero-extend sum
11030   %}
11031   ins_pipe(pipe_class_dummy);
11032 %}
11033 
11034 instruct popCountL(iRegI dst, iRegL src, iRegL tmp, flagsReg cr) %{
11035   match(Set dst (PopCountL src));
11036   effect(TEMP_DEF dst, TEMP tmp, KILL cr);
11037   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_PopCount());
11038   ins_cost(DEFAULT_COST);
11039   // TODO: s390 port size(FIXED_SIZE);
11040   format %{ &quot;POPCNT  $dst,$src\t # pop count long&quot; %}
11041   ins_encode %{
11042     Register Rdst = $dst$$Register;
11043     Register Rsrc = $src$$Register;
11044     Register Rtmp = $tmp$$Register;
11045 
11046     // Prefer compile-time assertion over run-time SIGILL.
11047     assert(VM_Version::has_PopCount(), &quot;bad predicate for countLeadingZerosI&quot;);
11048     assert_different_registers(Rdst, Rtmp);
11049 
11050     // Original version. Using LA instead of algr seems to be a really bad idea (-35%).
11051     __ z_popcnt(Rdst, Rsrc);
11052     __ z_ahhlr(Rdst, Rdst, Rdst);
11053     __ z_sllg(Rtmp, Rdst, 16);
11054     __ z_algr(Rdst, Rtmp);
11055     __ z_sllg(Rtmp, Rdst,  8);
11056     __ z_algr(Rdst, Rtmp);
11057     __ z_srlg(Rdst, Rdst, 56);
11058   %}
11059   ins_pipe(pipe_class_dummy);
11060 %}
11061 
11062 //----------SMARTSPILL RULES---------------------------------------------------
11063 // These must follow all instruction definitions as they use the names
11064 // defined in the instructions definitions.
11065 
11066 // ============================================================================
11067 // TYPE PROFILING RULES
    </pre>
  </body>
</html>
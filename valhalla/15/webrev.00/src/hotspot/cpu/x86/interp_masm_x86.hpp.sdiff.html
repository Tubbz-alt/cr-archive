<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/interp_masm_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/interp_masm_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
275   void record_klass_in_profile_helper(Register receiver, Register mdp,
276                                       Register reg2, int start_row,
277                                       Label&amp; done, bool is_virtual_call);
278   void record_item_in_profile_helper(Register item, Register mdp,
279                                      Register reg2, int start_row, Label&amp; done, int total_rows,
280                                      OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn,
281                                      int non_profiled_offset);
282 
283   void update_mdp_by_offset(Register mdp_in, int offset_of_offset);
284   void update_mdp_by_offset(Register mdp_in, Register reg, int offset_of_disp);
285   void update_mdp_by_constant(Register mdp_in, int constant);
286   void update_mdp_for_ret(Register return_bci);
287 
288   void profile_taken_branch(Register mdp, Register bumped_count);
289   void profile_not_taken_branch(Register mdp);
290   void profile_call(Register mdp);
291   void profile_final_call(Register mdp);
292   void profile_virtual_call(Register receiver, Register mdp,
293                             Register scratch2,
294                             bool receiver_can_be_null = false);
<span class="line-removed">295   void profile_called_method(Register method, Register mdp, Register reg2) NOT_JVMCI_RETURN;</span>
296   void profile_ret(Register return_bci, Register mdp);
297   void profile_null_seen(Register mdp);
298   void profile_typecheck(Register mdp, Register klass, Register scratch);
299   void profile_typecheck_failed(Register mdp);
300   void profile_switch_default(Register mdp);
301   void profile_switch_case(Register index_in_scratch, Register mdp,
302                            Register scratch2);
303   void profile_array(Register mdp, Register array, Register tmp);
304   void profile_element(Register mdp, Register element, Register tmp);
305 
306   // Debugging
307   // only if +VerifyOops &amp;&amp; state == atos
308 #define interp_verify_oop(reg, state) _interp_verify_oop(reg, state, __FILE__, __LINE__);
309   void _interp_verify_oop(Register reg, TosState state, const char* file, int line);
310   // only if +VerifyFPU  &amp;&amp; (state == ftos || state == dtos)
311   void verify_FPU(int stack_depth, TosState state = ftos);
312 
313   typedef enum { NotifyJVMTI, SkipNotifyJVMTI } NotifyMethodExitMode;
314 
315   // support for jvmti/dtrace
</pre>
</td>
<td>
<hr />
<pre>
275   void record_klass_in_profile_helper(Register receiver, Register mdp,
276                                       Register reg2, int start_row,
277                                       Label&amp; done, bool is_virtual_call);
278   void record_item_in_profile_helper(Register item, Register mdp,
279                                      Register reg2, int start_row, Label&amp; done, int total_rows,
280                                      OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn,
281                                      int non_profiled_offset);
282 
283   void update_mdp_by_offset(Register mdp_in, int offset_of_offset);
284   void update_mdp_by_offset(Register mdp_in, Register reg, int offset_of_disp);
285   void update_mdp_by_constant(Register mdp_in, int constant);
286   void update_mdp_for_ret(Register return_bci);
287 
288   void profile_taken_branch(Register mdp, Register bumped_count);
289   void profile_not_taken_branch(Register mdp);
290   void profile_call(Register mdp);
291   void profile_final_call(Register mdp);
292   void profile_virtual_call(Register receiver, Register mdp,
293                             Register scratch2,
294                             bool receiver_can_be_null = false);

295   void profile_ret(Register return_bci, Register mdp);
296   void profile_null_seen(Register mdp);
297   void profile_typecheck(Register mdp, Register klass, Register scratch);
298   void profile_typecheck_failed(Register mdp);
299   void profile_switch_default(Register mdp);
300   void profile_switch_case(Register index_in_scratch, Register mdp,
301                            Register scratch2);
302   void profile_array(Register mdp, Register array, Register tmp);
303   void profile_element(Register mdp, Register element, Register tmp);
304 
305   // Debugging
306   // only if +VerifyOops &amp;&amp; state == atos
307 #define interp_verify_oop(reg, state) _interp_verify_oop(reg, state, __FILE__, __LINE__);
308   void _interp_verify_oop(Register reg, TosState state, const char* file, int line);
309   // only if +VerifyFPU  &amp;&amp; (state == ftos || state == dtos)
310   void verify_FPU(int stack_depth, TosState state = ftos);
311 
312   typedef enum { NotifyJVMTI, SkipNotifyJVMTI } NotifyMethodExitMode;
313 
314   // support for jvmti/dtrace
</pre>
</td>
</tr>
</table>
<center><a href="interp_masm_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
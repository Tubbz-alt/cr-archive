<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/c1_LIRGenerator_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;c1/c1_Compilation.hpp&quot;
  27 #include &quot;c1/c1_FrameMap.hpp&quot;
  28 #include &quot;c1/c1_Instruction.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_LIRGenerator.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArray.hpp&quot;
  34 #include &quot;ci/ciObjArrayKlass.hpp&quot;
  35 #include &quot;ci/ciTypeArrayKlass.hpp&quot;
  36 #include &quot;ci/ciValueKlass.hpp&quot;
  37 #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
  38 #include &quot;runtime/sharedRuntime.hpp&quot;
  39 #include &quot;runtime/stubRoutines.hpp&quot;
  40 #include &quot;utilities/powerOfTwo.hpp&quot;
  41 #include &quot;vmreg_x86.inline.hpp&quot;
  42 
  43 #ifdef ASSERT
  44 #define __ gen()-&gt;lir(__FILE__, __LINE__)-&gt;
  45 #else
  46 #define __ gen()-&gt;lir()-&gt;
  47 #endif
  48 
  49 // Item will be loaded into a byte register; Intel only
  50 void LIRItem::load_byte_item() {
  51   load_item();
  52   LIR_Opr res = result();
  53 
  54   if (!res-&gt;is_virtual() || !_gen-&gt;is_vreg_flag_set(res, LIRGenerator::byte_reg)) {
  55     // make sure that it is a byte register
  56     assert(!value()-&gt;type()-&gt;is_float() &amp;&amp; !value()-&gt;type()-&gt;is_double(),
  57            &quot;can&#39;t load floats in byte register&quot;);
  58     LIR_Opr reg = _gen-&gt;rlock_byte(T_BYTE);
  59     __ move(res, reg);
  60 
  61     _result = reg;
  62   }
  63 }
  64 
  65 
  66 void LIRItem::load_nonconstant() {
  67   LIR_Opr r = value()-&gt;operand();
  68   if (r-&gt;is_constant()) {
  69     _result = r;
  70   } else {
  71     load_item();
  72   }
  73 }
  74 
  75 //--------------------------------------------------------------
  76 //               LIRGenerator
  77 //--------------------------------------------------------------
  78 
  79 
  80 LIR_Opr LIRGenerator::exceptionOopOpr() { return FrameMap::rax_oop_opr; }
  81 LIR_Opr LIRGenerator::exceptionPcOpr()  { return FrameMap::rdx_opr; }
  82 LIR_Opr LIRGenerator::divInOpr()        { return FrameMap::rax_opr; }
  83 LIR_Opr LIRGenerator::divOutOpr()       { return FrameMap::rax_opr; }
  84 LIR_Opr LIRGenerator::remOutOpr()       { return FrameMap::rdx_opr; }
  85 LIR_Opr LIRGenerator::shiftCountOpr()   { return FrameMap::rcx_opr; }
  86 LIR_Opr LIRGenerator::syncLockOpr()     { return new_register(T_INT); }
  87 LIR_Opr LIRGenerator::syncTempOpr()     { return FrameMap::rax_opr; }
  88 LIR_Opr LIRGenerator::getThreadTemp()   { return LIR_OprFact::illegalOpr; }
  89 
  90 
  91 LIR_Opr LIRGenerator::result_register_for(ValueType* type, bool callee) {
  92   LIR_Opr opr;
  93   switch (type-&gt;tag()) {
  94     case intTag:     opr = FrameMap::rax_opr;          break;
  95     case objectTag:  opr = FrameMap::rax_oop_opr;      break;
  96     case longTag:    opr = FrameMap::long0_opr;        break;
  97     case floatTag:   opr = UseSSE &gt;= 1 ? FrameMap::xmm0_float_opr  : FrameMap::fpu0_float_opr;  break;
  98     case doubleTag:  opr = UseSSE &gt;= 2 ? FrameMap::xmm0_double_opr : FrameMap::fpu0_double_opr;  break;
  99 
 100     case addressTag:
 101     default: ShouldNotReachHere(); return LIR_OprFact::illegalOpr;
 102   }
 103 
 104   assert(opr-&gt;type_field() == as_OprType(as_BasicType(type)), &quot;type mismatch&quot;);
 105   return opr;
 106 }
 107 
 108 
 109 LIR_Opr LIRGenerator::rlock_byte(BasicType type) {
 110   LIR_Opr reg = new_register(T_INT);
 111   set_vreg_flag(reg, LIRGenerator::byte_reg);
 112   return reg;
 113 }
 114 
 115 
 116 void LIRGenerator::init_temps_for_substitutability_check(LIR_Opr&amp; tmp1, LIR_Opr&amp; tmp2) {
 117   // We just need one 32-bit temp register for x86/x64, to check whether both
 118   // oops have markWord::always_locked_pattern. See LIR_Assembler::emit_opSubstitutabilityCheck().
 119   // @temp = %r10d
 120   // mov $0x405, %r10d
 121   // and (%left), %r10d   /* if need to check left */
 122   // and (%right), %r10d  /* if need to check right */
 123   // cmp $0x405, $r10d
 124   // jne L_oops_not_equal
 125   tmp1 = new_register(T_INT);
 126   tmp2 = LIR_OprFact::illegalOpr;
 127 }
 128 
 129 //--------- loading items into registers --------------------------------
 130 
 131 
 132 // i486 instructions can inline constants
 133 bool LIRGenerator::can_store_as_constant(Value v, BasicType type) const {
 134   if (type == T_SHORT || type == T_CHAR) {
 135     // there is no immediate move of word values in asembler_i486.?pp
 136     return false;
 137   }
 138   Constant* c = v-&gt;as_Constant();
 139   if (c &amp;&amp; c-&gt;state_before() == NULL) {
 140     // constants of any type can be stored directly, except for
 141     // unloaded object constants.
 142     return true;
 143   }
 144   return false;
 145 }
 146 
 147 
 148 bool LIRGenerator::can_inline_as_constant(Value v) const {
 149   if (v-&gt;type()-&gt;tag() == longTag) return false;
 150   return v-&gt;type()-&gt;tag() != objectTag ||
 151     (v-&gt;type()-&gt;is_constant() &amp;&amp; v-&gt;type()-&gt;as_ObjectType()-&gt;constant_value()-&gt;is_null_object());
 152 }
 153 
 154 
 155 bool LIRGenerator::can_inline_as_constant(LIR_Const* c) const {
 156   if (c-&gt;type() == T_LONG) return false;
 157   return c-&gt;type() != T_OBJECT || c-&gt;as_jobject() == NULL;
 158 }
 159 
 160 
 161 LIR_Opr LIRGenerator::safepoint_poll_register() {
 162   NOT_LP64( if (SafepointMechanism::uses_thread_local_poll()) { return new_register(T_ADDRESS); } )
 163   return LIR_OprFact::illegalOpr;
 164 }
 165 
 166 
 167 LIR_Address* LIRGenerator::generate_address(LIR_Opr base, LIR_Opr index,
 168                                             int shift, int disp, BasicType type) {
 169   assert(base-&gt;is_register(), &quot;must be&quot;);
 170   if (index-&gt;is_constant()) {
 171     LIR_Const *constant = index-&gt;as_constant_ptr();
 172 #ifdef _LP64
 173     jlong c;
 174     if (constant-&gt;type() == T_INT) {
 175       c = (jlong(index-&gt;as_jint()) &lt;&lt; shift) + disp;
 176     } else {
 177       assert(constant-&gt;type() == T_LONG, &quot;should be&quot;);
 178       c = (index-&gt;as_jlong() &lt;&lt; shift) + disp;
 179     }
 180     if ((jlong)((jint)c) == c) {
 181       return new LIR_Address(base, (jint)c, type);
 182     } else {
 183       LIR_Opr tmp = new_register(T_LONG);
 184       __ move(index, tmp);
 185       return new LIR_Address(base, tmp, type);
 186     }
 187 #else
 188     return new LIR_Address(base,
 189                            ((intx)(constant-&gt;as_jint()) &lt;&lt; shift) + disp,
 190                            type);
 191 #endif
 192   } else {
 193     return new LIR_Address(base, index, (LIR_Address::Scale)shift, disp, type);
 194   }
 195 }
 196 
 197 
 198 LIR_Address* LIRGenerator::emit_array_address(LIR_Opr array_opr, LIR_Opr index_opr,
 199                                               BasicType type) {
 200   int offset_in_bytes = arrayOopDesc::base_offset_in_bytes(type);
 201 
 202   LIR_Address* addr;
 203   if (index_opr-&gt;is_constant()) {
 204     int elem_size = type2aelembytes(type);
 205     addr = new LIR_Address(array_opr,
 206                            offset_in_bytes + (intx)(index_opr-&gt;as_jint()) * elem_size, type);
 207   } else {
 208 #ifdef _LP64
 209     if (index_opr-&gt;type() == T_INT) {
 210       LIR_Opr tmp = new_register(T_LONG);
 211       __ convert(Bytecodes::_i2l, index_opr, tmp);
 212       index_opr = tmp;
 213     }
 214 #endif // _LP64
 215     addr =  new LIR_Address(array_opr,
 216                             index_opr,
 217                             LIR_Address::scale(type),
 218                             offset_in_bytes, type);
 219   }
 220   return addr;
 221 }
 222 
 223 
 224 LIR_Opr LIRGenerator::load_immediate(int x, BasicType type) {
 225   LIR_Opr r = NULL;
 226   if (type == T_LONG) {
 227     r = LIR_OprFact::longConst(x);
 228   } else if (type == T_INT) {
 229     r = LIR_OprFact::intConst(x);
 230   } else {
 231     ShouldNotReachHere();
 232   }
 233   return r;
 234 }
 235 
 236 void LIRGenerator::increment_counter(address counter, BasicType type, int step) {
 237   LIR_Opr pointer = new_pointer_register();
 238   __ move(LIR_OprFact::intptrConst(counter), pointer);
 239   LIR_Address* addr = new LIR_Address(pointer, type);
 240   increment_counter(addr, step);
 241 }
 242 
 243 
 244 void LIRGenerator::increment_counter(LIR_Address* addr, int step) {
 245   __ add((LIR_Opr)addr, LIR_OprFact::intConst(step), (LIR_Opr)addr);
 246 }
 247 
 248 void LIRGenerator::cmp_mem_int(LIR_Condition condition, LIR_Opr base, int disp, int c, CodeEmitInfo* info) {
 249   __ cmp_mem_int(condition, base, disp, c, info);
 250 }
 251 
 252 
 253 void LIRGenerator::cmp_reg_mem(LIR_Condition condition, LIR_Opr reg, LIR_Opr base, int disp, BasicType type, CodeEmitInfo* info) {
 254   __ cmp_reg_mem(condition, reg, new LIR_Address(base, disp, type), info);
 255 }
 256 
 257 
 258 bool LIRGenerator::strength_reduce_multiply(LIR_Opr left, jint c, LIR_Opr result, LIR_Opr tmp) {
 259   if (tmp-&gt;is_valid() &amp;&amp; c &gt; 0 &amp;&amp; c &lt; max_jint) {
 260     if (is_power_of_2(c + 1)) {
 261       __ move(left, tmp);
 262       __ shift_left(left, log2_jint(c + 1), left);
 263       __ sub(left, tmp, result);
 264       return true;
 265     } else if (is_power_of_2(c - 1)) {
 266       __ move(left, tmp);
 267       __ shift_left(left, log2_jint(c - 1), left);
 268       __ add(left, tmp, result);
 269       return true;
 270     }
 271   }
 272   return false;
 273 }
 274 
 275 
 276 void LIRGenerator::store_stack_parameter (LIR_Opr item, ByteSize offset_from_sp) {
 277   BasicType type = item-&gt;type();
 278   __ store(item, new LIR_Address(FrameMap::rsp_opr, in_bytes(offset_from_sp), type));
 279 }
 280 
 281 void LIRGenerator::array_store_check(LIR_Opr value, LIR_Opr array, CodeEmitInfo* store_check_info, ciMethod* profiled_method, int profiled_bci) {
 282   LIR_Opr tmp1 = new_register(objectType);
 283   LIR_Opr tmp2 = new_register(objectType);
 284   LIR_Opr tmp3 = new_register(objectType);
 285   __ store_check(value, array, tmp1, tmp2, tmp3, store_check_info, profiled_method, profiled_bci);
 286 }
 287 
 288 //----------------------------------------------------------------------
 289 //             visitor functions
 290 //----------------------------------------------------------------------
 291 
 292 void LIRGenerator::do_MonitorEnter(MonitorEnter* x) {
 293   assert(x-&gt;is_pinned(),&quot;&quot;);
 294   LIRItem obj(x-&gt;obj(), this);
 295   obj.load_item();
 296 
 297   set_no_result(x);
 298 
 299   // &quot;lock&quot; stores the address of the monitor stack slot, so this is not an oop
 300   LIR_Opr lock = new_register(T_INT);
 301   // Need a scratch register for biased locking on x86
 302   LIR_Opr scratch = LIR_OprFact::illegalOpr;
 303   if (UseBiasedLocking || x-&gt;maybe_valuetype()) {
 304     scratch = new_register(T_INT);
 305   }
 306 
 307   CodeEmitInfo* info_for_exception = NULL;
 308   if (x-&gt;needs_null_check()) {
 309     info_for_exception = state_for(x);
 310   }
 311 
 312   CodeStub* throw_imse_stub = x-&gt;maybe_valuetype() ?
 313       new SimpleExceptionStub(Runtime1::throw_illegal_monitor_state_exception_id,
 314                               LIR_OprFact::illegalOpr, state_for(x))
 315     : NULL;
 316 
 317   // this CodeEmitInfo must not have the xhandlers because here the
 318   // object is already locked (xhandlers expect object to be unlocked)
 319   CodeEmitInfo* info = state_for(x, x-&gt;state(), true);
 320   monitor_enter(obj.result(), lock, syncTempOpr(), scratch,
 321                 x-&gt;monitor_no(), info_for_exception, info, throw_imse_stub);
 322 }
 323 
 324 
 325 void LIRGenerator::do_MonitorExit(MonitorExit* x) {
 326   assert(x-&gt;is_pinned(),&quot;&quot;);
 327 
 328   LIRItem obj(x-&gt;obj(), this);
 329   obj.dont_load_item();
 330 
 331   LIR_Opr lock = new_register(T_INT);
 332   LIR_Opr obj_temp = new_register(T_INT);
 333   set_no_result(x);
 334   monitor_exit(obj_temp, lock, syncTempOpr(), LIR_OprFact::illegalOpr, x-&gt;monitor_no());
 335 }
 336 
 337 
 338 // _ineg, _lneg, _fneg, _dneg
 339 void LIRGenerator::do_NegateOp(NegateOp* x) {
 340   LIRItem value(x-&gt;x(), this);
 341   value.set_destroys_register();
 342   value.load_item();
 343   LIR_Opr reg = rlock(x);
 344 
 345   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 346 #ifdef _LP64
 347   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
 348     if (x-&gt;type()-&gt;tag() == doubleTag) {
 349       tmp = new_register(T_DOUBLE);
 350       __ move(LIR_OprFact::doubleConst(-0.0), tmp);
 351     }
 352     else if (x-&gt;type()-&gt;tag() == floatTag) {
 353       tmp = new_register(T_FLOAT);
 354       __ move(LIR_OprFact::floatConst(-0.0), tmp);
 355     }
 356   }
 357 #endif
 358   __ negate(value.result(), reg, tmp);
 359 
 360   set_result(x, round_item(reg));
 361 }
 362 
 363 
 364 // for  _fadd, _fmul, _fsub, _fdiv, _frem
 365 //      _dadd, _dmul, _dsub, _ddiv, _drem
 366 void LIRGenerator::do_ArithmeticOp_FPU(ArithmeticOp* x) {
 367   LIRItem left(x-&gt;x(),  this);
 368   LIRItem right(x-&gt;y(), this);
 369   LIRItem* left_arg  = &amp;left;
 370   LIRItem* right_arg = &amp;right;
 371   assert(!left.is_stack() || !right.is_stack(), &quot;can&#39;t both be memory operands&quot;);
 372   bool must_load_both = (x-&gt;op() == Bytecodes::_frem || x-&gt;op() == Bytecodes::_drem);
 373   if (left.is_register() || x-&gt;x()-&gt;type()-&gt;is_constant() || must_load_both) {
 374     left.load_item();
 375   } else {
 376     left.dont_load_item();
 377   }
 378 
 379   // do not load right operand if it is a constant.  only 0 and 1 are
 380   // loaded because there are special instructions for loading them
 381   // without memory access (not needed for SSE2 instructions)
 382   bool must_load_right = false;
 383   if (right.is_constant()) {
 384     LIR_Const* c = right.result()-&gt;as_constant_ptr();
 385     assert(c != NULL, &quot;invalid constant&quot;);
 386     assert(c-&gt;type() == T_FLOAT || c-&gt;type() == T_DOUBLE, &quot;invalid type&quot;);
 387 
 388     if (c-&gt;type() == T_FLOAT) {
 389       must_load_right = UseSSE &lt; 1 &amp;&amp; (c-&gt;is_one_float() || c-&gt;is_zero_float());
 390     } else {
 391       must_load_right = UseSSE &lt; 2 &amp;&amp; (c-&gt;is_one_double() || c-&gt;is_zero_double());
 392     }
 393   }
 394 
 395   if (must_load_both) {
 396     // frem and drem destroy also right operand, so move it to a new register
 397     right.set_destroys_register();
 398     right.load_item();
 399   } else if (right.is_register() || must_load_right) {
 400     right.load_item();
 401   } else {
 402     right.dont_load_item();
 403   }
 404   LIR_Opr reg = rlock(x);
 405   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 406   if (x-&gt;is_strictfp() &amp;&amp; (x-&gt;op() == Bytecodes::_dmul || x-&gt;op() == Bytecodes::_ddiv)) {
 407     tmp = new_register(T_DOUBLE);
 408   }
 409 
 410 #ifdef _LP64
 411   if (x-&gt;op() == Bytecodes::_frem || x-&gt;op() == Bytecodes::_drem) {
 412     // frem and drem are implemented as a direct call into the runtime.
 413     LIRItem left(x-&gt;x(), this);
 414     LIRItem right(x-&gt;y(), this);
 415 
 416     BasicType bt = as_BasicType(x-&gt;type());
 417     BasicTypeList signature(2);
 418     signature.append(bt);
 419     signature.append(bt);
 420     CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 421 
 422     const LIR_Opr result_reg = result_register_for(x-&gt;type());
 423     left.load_item_force(cc-&gt;at(0));
 424     right.load_item_force(cc-&gt;at(1));
 425 
 426     address entry = NULL;
 427     switch (x-&gt;op()) {
 428       case Bytecodes::_frem:
 429         entry = CAST_FROM_FN_PTR(address, SharedRuntime::frem);
 430         break;
 431       case Bytecodes::_drem:
 432         entry = CAST_FROM_FN_PTR(address, SharedRuntime::drem);
 433         break;
 434       default:
 435         ShouldNotReachHere();
 436     }
 437 
 438     LIR_Opr result = rlock_result(x);
 439     __ call_runtime_leaf(entry, getThreadTemp(), result_reg, cc-&gt;args());
 440     __ move(result_reg, result);
 441   } else {
 442     arithmetic_op_fpu(x-&gt;op(), reg, left.result(), right.result(), x-&gt;is_strictfp(), tmp);
 443     set_result(x, round_item(reg));
 444   }
 445 #else
 446   if ((UseSSE &gt;= 1 &amp;&amp; x-&gt;op() == Bytecodes::_frem) || (UseSSE &gt;= 2 &amp;&amp; x-&gt;op() == Bytecodes::_drem)) {
 447     // special handling for frem and drem: no SSE instruction, so must use FPU with temporary fpu stack slots
 448     LIR_Opr fpu0, fpu1;
 449     if (x-&gt;op() == Bytecodes::_frem) {
 450       fpu0 = LIR_OprFact::single_fpu(0);
 451       fpu1 = LIR_OprFact::single_fpu(1);
 452     } else {
 453       fpu0 = LIR_OprFact::double_fpu(0);
 454       fpu1 = LIR_OprFact::double_fpu(1);
 455     }
 456     __ move(right.result(), fpu1); // order of left and right operand is important!
 457     __ move(left.result(), fpu0);
 458     __ rem (fpu0, fpu1, fpu0);
 459     __ move(fpu0, reg);
 460 
 461   } else {
 462     arithmetic_op_fpu(x-&gt;op(), reg, left.result(), right.result(), x-&gt;is_strictfp(), tmp);
 463   }
 464   set_result(x, round_item(reg));
 465 #endif // _LP64
 466 }
 467 
 468 
 469 // for  _ladd, _lmul, _lsub, _ldiv, _lrem
 470 void LIRGenerator::do_ArithmeticOp_Long(ArithmeticOp* x) {
 471   if (x-&gt;op() == Bytecodes::_ldiv || x-&gt;op() == Bytecodes::_lrem ) {
 472     // long division is implemented as a direct call into the runtime
 473     LIRItem left(x-&gt;x(), this);
 474     LIRItem right(x-&gt;y(), this);
 475 
 476     // the check for division by zero destroys the right operand
 477     right.set_destroys_register();
 478 
 479     BasicTypeList signature(2);
 480     signature.append(T_LONG);
 481     signature.append(T_LONG);
 482     CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 483 
 484     // check for division by zero (destroys registers of right operand!)
 485     CodeEmitInfo* info = state_for(x);
 486 
 487     const LIR_Opr result_reg = result_register_for(x-&gt;type());
 488     left.load_item_force(cc-&gt;at(1));
 489     right.load_item();
 490 
 491     __ move(right.result(), cc-&gt;at(0));
 492 
 493     __ cmp(lir_cond_equal, right.result(), LIR_OprFact::longConst(0));
 494     __ branch(lir_cond_equal, T_LONG, new DivByZeroStub(info));
 495 
 496     address entry = NULL;
 497     switch (x-&gt;op()) {
 498     case Bytecodes::_lrem:
 499       entry = CAST_FROM_FN_PTR(address, SharedRuntime::lrem);
 500       break; // check if dividend is 0 is done elsewhere
 501     case Bytecodes::_ldiv:
 502       entry = CAST_FROM_FN_PTR(address, SharedRuntime::ldiv);
 503       break; // check if dividend is 0 is done elsewhere
 504     default:
 505       ShouldNotReachHere();
 506     }
 507 
 508     LIR_Opr result = rlock_result(x);
 509     __ call_runtime_leaf(entry, getThreadTemp(), result_reg, cc-&gt;args());
 510     __ move(result_reg, result);
 511   } else if (x-&gt;op() == Bytecodes::_lmul) {
 512     // missing test if instr is commutative and if we should swap
 513     LIRItem left(x-&gt;x(), this);
 514     LIRItem right(x-&gt;y(), this);
 515 
 516     // right register is destroyed by the long mul, so it must be
 517     // copied to a new register.
 518     right.set_destroys_register();
 519 
 520     left.load_item();
 521     right.load_item();
 522 
 523     LIR_Opr reg = FrameMap::long0_opr;
 524     arithmetic_op_long(x-&gt;op(), reg, left.result(), right.result(), NULL);
 525     LIR_Opr result = rlock_result(x);
 526     __ move(reg, result);
 527   } else {
 528     // missing test if instr is commutative and if we should swap
 529     LIRItem left(x-&gt;x(), this);
 530     LIRItem right(x-&gt;y(), this);
 531 
 532     left.load_item();
 533     // don&#39;t load constants to save register
 534     right.load_nonconstant();
 535     rlock_result(x);
 536     arithmetic_op_long(x-&gt;op(), x-&gt;operand(), left.result(), right.result(), NULL);
 537   }
 538 }
 539 
 540 
 541 
 542 // for: _iadd, _imul, _isub, _idiv, _irem
 543 void LIRGenerator::do_ArithmeticOp_Int(ArithmeticOp* x) {
 544   if (x-&gt;op() == Bytecodes::_idiv || x-&gt;op() == Bytecodes::_irem) {
 545     // The requirements for division and modulo
 546     // input : rax,: dividend                         min_int
 547     //         reg: divisor   (may not be rax,/rdx)   -1
 548     //
 549     // output: rax,: quotient  (= rax, idiv reg)       min_int
 550     //         rdx: remainder (= rax, irem reg)       0
 551 
 552     // rax, and rdx will be destroyed
 553 
 554     // Note: does this invalidate the spec ???
 555     LIRItem right(x-&gt;y(), this);
 556     LIRItem left(x-&gt;x() , this);   // visit left second, so that the is_register test is valid
 557 
 558     // call state_for before load_item_force because state_for may
 559     // force the evaluation of other instructions that are needed for
 560     // correct debug info.  Otherwise the live range of the fix
 561     // register might be too long.
 562     CodeEmitInfo* info = state_for(x);
 563 
 564     left.load_item_force(divInOpr());
 565 
 566     right.load_item();
 567 
 568     LIR_Opr result = rlock_result(x);
 569     LIR_Opr result_reg;
 570     if (x-&gt;op() == Bytecodes::_idiv) {
 571       result_reg = divOutOpr();
 572     } else {
 573       result_reg = remOutOpr();
 574     }
 575 
 576     if (!ImplicitDiv0Checks) {
 577       __ cmp(lir_cond_equal, right.result(), LIR_OprFact::intConst(0));
 578       __ branch(lir_cond_equal, T_INT, new DivByZeroStub(info));
 579       // Idiv/irem cannot trap (passing info would generate an assertion).
 580       info = NULL;
 581     }
 582     LIR_Opr tmp = FrameMap::rdx_opr; // idiv and irem use rdx in their implementation
 583     if (x-&gt;op() == Bytecodes::_irem) {
 584       __ irem(left.result(), right.result(), result_reg, tmp, info);
 585     } else if (x-&gt;op() == Bytecodes::_idiv) {
 586       __ idiv(left.result(), right.result(), result_reg, tmp, info);
 587     } else {
 588       ShouldNotReachHere();
 589     }
 590 
 591     __ move(result_reg, result);
 592   } else {
 593     // missing test if instr is commutative and if we should swap
 594     LIRItem left(x-&gt;x(),  this);
 595     LIRItem right(x-&gt;y(), this);
 596     LIRItem* left_arg = &amp;left;
 597     LIRItem* right_arg = &amp;right;
 598     if (x-&gt;is_commutative() &amp;&amp; left.is_stack() &amp;&amp; right.is_register()) {
 599       // swap them if left is real stack (or cached) and right is real register(not cached)
 600       left_arg = &amp;right;
 601       right_arg = &amp;left;
 602     }
 603 
 604     left_arg-&gt;load_item();
 605 
 606     // do not need to load right, as we can handle stack and constants
 607     if (x-&gt;op() == Bytecodes::_imul ) {
 608       // check if we can use shift instead
 609       bool use_constant = false;
 610       bool use_tmp = false;
 611       if (right_arg-&gt;is_constant()) {
 612         jint iconst = right_arg-&gt;get_jint_constant();
 613         if (iconst &gt; 0 &amp;&amp; iconst &lt; max_jint) {
 614           if (is_power_of_2(iconst)) {
 615             use_constant = true;
 616           } else if (is_power_of_2(iconst - 1) || is_power_of_2(iconst + 1)) {
 617             use_constant = true;
 618             use_tmp = true;
 619           }
 620         }
 621       }
 622       if (use_constant) {
 623         right_arg-&gt;dont_load_item();
 624       } else {
 625         right_arg-&gt;load_item();
 626       }
 627       LIR_Opr tmp = LIR_OprFact::illegalOpr;
 628       if (use_tmp) {
 629         tmp = new_register(T_INT);
 630       }
 631       rlock_result(x);
 632 
 633       arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left_arg-&gt;result(), right_arg-&gt;result(), tmp);
 634     } else {
 635       right_arg-&gt;dont_load_item();
 636       rlock_result(x);
 637       LIR_Opr tmp = LIR_OprFact::illegalOpr;
 638       arithmetic_op_int(x-&gt;op(), x-&gt;operand(), left_arg-&gt;result(), right_arg-&gt;result(), tmp);
 639     }
 640   }
 641 }
 642 
 643 
 644 void LIRGenerator::do_ArithmeticOp(ArithmeticOp* x) {
 645   // when an operand with use count 1 is the left operand, then it is
 646   // likely that no move for 2-operand-LIR-form is necessary
 647   if (x-&gt;is_commutative() &amp;&amp; x-&gt;y()-&gt;as_Constant() == NULL &amp;&amp; x-&gt;x()-&gt;use_count() &gt; x-&gt;y()-&gt;use_count()) {
 648     x-&gt;swap_operands();
 649   }
 650 
 651   ValueTag tag = x-&gt;type()-&gt;tag();
 652   assert(x-&gt;x()-&gt;type()-&gt;tag() == tag &amp;&amp; x-&gt;y()-&gt;type()-&gt;tag() == tag, &quot;wrong parameters&quot;);
 653   switch (tag) {
 654     case floatTag:
 655     case doubleTag:  do_ArithmeticOp_FPU(x);  return;
 656     case longTag:    do_ArithmeticOp_Long(x); return;
 657     case intTag:     do_ArithmeticOp_Int(x);  return;
 658     default:         ShouldNotReachHere();    return;
 659   }
 660 }
 661 
 662 
 663 // _ishl, _lshl, _ishr, _lshr, _iushr, _lushr
 664 void LIRGenerator::do_ShiftOp(ShiftOp* x) {
 665   // count must always be in rcx
 666   LIRItem value(x-&gt;x(), this);
 667   LIRItem count(x-&gt;y(), this);
 668 
 669   ValueTag elemType = x-&gt;type()-&gt;tag();
 670   bool must_load_count = !count.is_constant() || elemType == longTag;
 671   if (must_load_count) {
 672     // count for long must be in register
 673     count.load_item_force(shiftCountOpr());
 674   } else {
 675     count.dont_load_item();
 676   }
 677   value.load_item();
 678   LIR_Opr reg = rlock_result(x);
 679 
 680   shift_op(x-&gt;op(), reg, value.result(), count.result(), LIR_OprFact::illegalOpr);
 681 }
 682 
 683 
 684 // _iand, _land, _ior, _lor, _ixor, _lxor
 685 void LIRGenerator::do_LogicOp(LogicOp* x) {
 686   // when an operand with use count 1 is the left operand, then it is
 687   // likely that no move for 2-operand-LIR-form is necessary
 688   if (x-&gt;is_commutative() &amp;&amp; x-&gt;y()-&gt;as_Constant() == NULL &amp;&amp; x-&gt;x()-&gt;use_count() &gt; x-&gt;y()-&gt;use_count()) {
 689     x-&gt;swap_operands();
 690   }
 691 
 692   LIRItem left(x-&gt;x(), this);
 693   LIRItem right(x-&gt;y(), this);
 694 
 695   left.load_item();
 696   right.load_nonconstant();
 697   LIR_Opr reg = rlock_result(x);
 698 
 699   logic_op(x-&gt;op(), reg, left.result(), right.result());
 700 }
 701 
 702 
 703 
 704 // _lcmp, _fcmpl, _fcmpg, _dcmpl, _dcmpg
 705 void LIRGenerator::do_CompareOp(CompareOp* x) {
 706   LIRItem left(x-&gt;x(), this);
 707   LIRItem right(x-&gt;y(), this);
 708   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
 709   if (tag == longTag) {
 710     left.set_destroys_register();
 711   }
 712   left.load_item();
 713   right.load_item();
 714   LIR_Opr reg = rlock_result(x);
 715 
 716   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
 717     Bytecodes::Code code = x-&gt;op();
 718     __ fcmp2int(left.result(), right.result(), reg, (code == Bytecodes::_fcmpl || code == Bytecodes::_dcmpl));
 719   } else if (x-&gt;x()-&gt;type()-&gt;tag() == longTag) {
 720     __ lcmp2int(left.result(), right.result(), reg);
 721   } else {
 722     Unimplemented();
 723   }
 724 }
 725 
 726 LIR_Opr LIRGenerator::atomic_cmpxchg(BasicType type, LIR_Opr addr, LIRItem&amp; cmp_value, LIRItem&amp; new_value) {
 727   LIR_Opr ill = LIR_OprFact::illegalOpr;  // for convenience
 728   if (is_reference_type(type)) {
 729     cmp_value.load_item_force(FrameMap::rax_oop_opr);
 730     new_value.load_item();
 731     __ cas_obj(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 732   } else if (type == T_INT) {
 733     cmp_value.load_item_force(FrameMap::rax_opr);
 734     new_value.load_item();
 735     __ cas_int(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 736   } else if (type == T_LONG) {
 737     cmp_value.load_item_force(FrameMap::long0_opr);
 738     new_value.load_item_force(FrameMap::long1_opr);
 739     __ cas_long(addr-&gt;as_address_ptr()-&gt;base(), cmp_value.result(), new_value.result(), ill, ill);
 740   } else {
 741     Unimplemented();
 742   }
 743   LIR_Opr result = new_register(T_INT);
 744   __ cmove(lir_cond_equal, LIR_OprFact::intConst(1), LIR_OprFact::intConst(0),
 745            result, T_INT);
 746   return result;
 747 }
 748 
 749 LIR_Opr LIRGenerator::atomic_xchg(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 750   bool is_oop = is_reference_type(type);
 751   LIR_Opr result = new_register(type);
 752   value.load_item();
 753   // Because we want a 2-arg form of xchg and xadd
 754   __ move(value.result(), result);
 755   assert(type == T_INT || is_oop LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
 756   __ xchg(addr, result, result, LIR_OprFact::illegalOpr);
 757   return result;
 758 }
 759 
 760 LIR_Opr LIRGenerator::atomic_add(BasicType type, LIR_Opr addr, LIRItem&amp; value) {
 761   LIR_Opr result = new_register(type);
 762   value.load_item();
 763   // Because we want a 2-arg form of xchg and xadd
 764   __ move(value.result(), result);
 765   assert(type == T_INT LP64_ONLY( || type == T_LONG ), &quot;unexpected type&quot;);
 766   __ xadd(addr, result, result, LIR_OprFact::illegalOpr);
 767   return result;
 768 }
 769 
 770 void LIRGenerator::do_FmaIntrinsic(Intrinsic* x) {
 771   assert(x-&gt;number_of_arguments() == 3, &quot;wrong type&quot;);
 772   assert(UseFMA, &quot;Needs FMA instructions support.&quot;);
 773   LIRItem value(x-&gt;argument_at(0), this);
 774   LIRItem value1(x-&gt;argument_at(1), this);
 775   LIRItem value2(x-&gt;argument_at(2), this);
 776 
 777   value2.set_destroys_register();
 778 
 779   value.load_item();
 780   value1.load_item();
 781   value2.load_item();
 782 
 783   LIR_Opr calc_input = value.result();
 784   LIR_Opr calc_input1 = value1.result();
 785   LIR_Opr calc_input2 = value2.result();
 786   LIR_Opr calc_result = rlock_result(x);
 787 
 788   switch (x-&gt;id()) {
 789   case vmIntrinsics::_fmaD:   __ fmad(calc_input, calc_input1, calc_input2, calc_result); break;
 790   case vmIntrinsics::_fmaF:   __ fmaf(calc_input, calc_input1, calc_input2, calc_result); break;
 791   default:                    ShouldNotReachHere();
 792   }
 793 
 794 }
 795 
 796 
 797 void LIRGenerator::do_MathIntrinsic(Intrinsic* x) {
 798   assert(x-&gt;number_of_arguments() == 1 || (x-&gt;number_of_arguments() == 2 &amp;&amp; x-&gt;id() == vmIntrinsics::_dpow), &quot;wrong type&quot;);
 799 
 800   if (x-&gt;id() == vmIntrinsics::_dexp || x-&gt;id() == vmIntrinsics::_dlog ||
 801       x-&gt;id() == vmIntrinsics::_dpow || x-&gt;id() == vmIntrinsics::_dcos ||
 802       x-&gt;id() == vmIntrinsics::_dsin || x-&gt;id() == vmIntrinsics::_dtan ||
 803       x-&gt;id() == vmIntrinsics::_dlog10) {
 804     do_LibmIntrinsic(x);
 805     return;
 806   }
 807 
 808   LIRItem value(x-&gt;argument_at(0), this);
 809 
 810   bool use_fpu = false;
 811   if (UseSSE &lt; 2) {
 812     value.set_destroys_register();
 813   }
 814   value.load_item();
 815 
 816   LIR_Opr calc_input = value.result();
 817   LIR_Opr calc_result = rlock_result(x);
 818 
 819   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 820 #ifdef _LP64
 821   if (UseAVX &gt; 2 &amp;&amp; (!VM_Version::supports_avx512vl()) &amp;&amp;
 822       (x-&gt;id() == vmIntrinsics::_dabs)) {
 823     tmp = new_register(T_DOUBLE);
 824     __ move(LIR_OprFact::doubleConst(-0.0), tmp);
 825   }
 826 #endif
 827 
 828   switch(x-&gt;id()) {
 829     case vmIntrinsics::_dabs:   __ abs  (calc_input, calc_result, tmp); break;
 830     case vmIntrinsics::_dsqrt:  __ sqrt (calc_input, calc_result, LIR_OprFact::illegalOpr); break;
 831     default:                    ShouldNotReachHere();
 832   }
 833 
 834   if (use_fpu) {
 835     __ move(calc_result, x-&gt;operand());
 836   }
 837 }
 838 
 839 void LIRGenerator::do_LibmIntrinsic(Intrinsic* x) {
 840   LIRItem value(x-&gt;argument_at(0), this);
 841   value.set_destroys_register();
 842 
 843   LIR_Opr calc_result = rlock_result(x);
 844   LIR_Opr result_reg = result_register_for(x-&gt;type());
 845 
 846   CallingConvention* cc = NULL;
 847 
 848   if (x-&gt;id() == vmIntrinsics::_dpow) {
 849     LIRItem value1(x-&gt;argument_at(1), this);
 850 
 851     value1.set_destroys_register();
 852 
 853     BasicTypeList signature(2);
 854     signature.append(T_DOUBLE);
 855     signature.append(T_DOUBLE);
 856     cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 857     value.load_item_force(cc-&gt;at(0));
 858     value1.load_item_force(cc-&gt;at(1));
 859   } else {
 860     BasicTypeList signature(1);
 861     signature.append(T_DOUBLE);
 862     cc = frame_map()-&gt;c_calling_convention(&amp;signature);
 863     value.load_item_force(cc-&gt;at(0));
 864   }
 865 
 866 #ifndef _LP64
 867   LIR_Opr tmp = FrameMap::fpu0_double_opr;
 868   result_reg = tmp;
 869   switch(x-&gt;id()) {
 870     case vmIntrinsics::_dexp:
 871       if (StubRoutines::dexp() != NULL) {
 872         __ call_runtime_leaf(StubRoutines::dexp(), getThreadTemp(), result_reg, cc-&gt;args());
 873       } else {
 874         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dexp), getThreadTemp(), result_reg, cc-&gt;args());
 875       }
 876       break;
 877     case vmIntrinsics::_dlog:
 878       if (StubRoutines::dlog() != NULL) {
 879         __ call_runtime_leaf(StubRoutines::dlog(), getThreadTemp(), result_reg, cc-&gt;args());
 880       } else {
 881         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog), getThreadTemp(), result_reg, cc-&gt;args());
 882       }
 883       break;
 884     case vmIntrinsics::_dlog10:
 885       if (StubRoutines::dlog10() != NULL) {
 886        __ call_runtime_leaf(StubRoutines::dlog10(), getThreadTemp(), result_reg, cc-&gt;args());
 887       } else {
 888         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog10), getThreadTemp(), result_reg, cc-&gt;args());
 889       }
 890       break;
 891     case vmIntrinsics::_dpow:
 892       if (StubRoutines::dpow() != NULL) {
 893         __ call_runtime_leaf(StubRoutines::dpow(), getThreadTemp(), result_reg, cc-&gt;args());
 894       } else {
 895         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dpow), getThreadTemp(), result_reg, cc-&gt;args());
 896       }
 897       break;
 898     case vmIntrinsics::_dsin:
 899       if (VM_Version::supports_sse2() &amp;&amp; StubRoutines::dsin() != NULL) {
 900         __ call_runtime_leaf(StubRoutines::dsin(), getThreadTemp(), result_reg, cc-&gt;args());
 901       } else {
 902         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dsin), getThreadTemp(), result_reg, cc-&gt;args());
 903       }
 904       break;
 905     case vmIntrinsics::_dcos:
 906       if (VM_Version::supports_sse2() &amp;&amp; StubRoutines::dcos() != NULL) {
 907         __ call_runtime_leaf(StubRoutines::dcos(), getThreadTemp(), result_reg, cc-&gt;args());
 908       } else {
 909         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dcos), getThreadTemp(), result_reg, cc-&gt;args());
 910       }
 911       break;
 912     case vmIntrinsics::_dtan:
 913       if (StubRoutines::dtan() != NULL) {
 914         __ call_runtime_leaf(StubRoutines::dtan(), getThreadTemp(), result_reg, cc-&gt;args());
 915       } else {
 916         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtan), getThreadTemp(), result_reg, cc-&gt;args());
 917       }
 918       break;
 919     default:  ShouldNotReachHere();
 920   }
 921 #else
 922   switch (x-&gt;id()) {
 923     case vmIntrinsics::_dexp:
 924       if (StubRoutines::dexp() != NULL) {
 925         __ call_runtime_leaf(StubRoutines::dexp(), getThreadTemp(), result_reg, cc-&gt;args());
 926       } else {
 927         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dexp), getThreadTemp(), result_reg, cc-&gt;args());
 928       }
 929       break;
 930     case vmIntrinsics::_dlog:
 931       if (StubRoutines::dlog() != NULL) {
 932       __ call_runtime_leaf(StubRoutines::dlog(), getThreadTemp(), result_reg, cc-&gt;args());
 933       } else {
 934         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog), getThreadTemp(), result_reg, cc-&gt;args());
 935       }
 936       break;
 937     case vmIntrinsics::_dlog10:
 938       if (StubRoutines::dlog10() != NULL) {
 939       __ call_runtime_leaf(StubRoutines::dlog10(), getThreadTemp(), result_reg, cc-&gt;args());
 940       } else {
 941         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dlog10), getThreadTemp(), result_reg, cc-&gt;args());
 942       }
 943       break;
 944     case vmIntrinsics::_dpow:
 945        if (StubRoutines::dpow() != NULL) {
 946       __ call_runtime_leaf(StubRoutines::dpow(), getThreadTemp(), result_reg, cc-&gt;args());
 947       } else {
 948         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dpow), getThreadTemp(), result_reg, cc-&gt;args());
 949       }
 950       break;
 951     case vmIntrinsics::_dsin:
 952       if (StubRoutines::dsin() != NULL) {
 953         __ call_runtime_leaf(StubRoutines::dsin(), getThreadTemp(), result_reg, cc-&gt;args());
 954       } else {
 955         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dsin), getThreadTemp(), result_reg, cc-&gt;args());
 956       }
 957       break;
 958     case vmIntrinsics::_dcos:
 959       if (StubRoutines::dcos() != NULL) {
 960         __ call_runtime_leaf(StubRoutines::dcos(), getThreadTemp(), result_reg, cc-&gt;args());
 961       } else {
 962         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dcos), getThreadTemp(), result_reg, cc-&gt;args());
 963       }
 964       break;
 965     case vmIntrinsics::_dtan:
 966        if (StubRoutines::dtan() != NULL) {
 967       __ call_runtime_leaf(StubRoutines::dtan(), getThreadTemp(), result_reg, cc-&gt;args());
 968       } else {
 969         __ call_runtime_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtan), getThreadTemp(), result_reg, cc-&gt;args());
 970       }
 971       break;
 972     default:  ShouldNotReachHere();
 973   }
 974 #endif // _LP64
 975   __ move(result_reg, calc_result);
 976 }
 977 
 978 void LIRGenerator::do_ArrayCopy(Intrinsic* x) {
 979   assert(x-&gt;number_of_arguments() == 5, &quot;wrong type&quot;);
 980 
 981   // Make all state_for calls early since they can emit code
 982   CodeEmitInfo* info = state_for(x, x-&gt;state());
 983 
 984   LIRItem src(x-&gt;argument_at(0), this);
 985   LIRItem src_pos(x-&gt;argument_at(1), this);
 986   LIRItem dst(x-&gt;argument_at(2), this);
 987   LIRItem dst_pos(x-&gt;argument_at(3), this);
 988   LIRItem length(x-&gt;argument_at(4), this);
 989 
 990   // operands for arraycopy must use fixed registers, otherwise
 991   // LinearScan will fail allocation (because arraycopy always needs a
 992   // call)
 993 
 994 #ifndef _LP64
 995   src.load_item_force     (FrameMap::rcx_oop_opr);
 996   src_pos.load_item_force (FrameMap::rdx_opr);
 997   dst.load_item_force     (FrameMap::rax_oop_opr);
 998   dst_pos.load_item_force (FrameMap::rbx_opr);
 999   length.load_item_force  (FrameMap::rdi_opr);
1000   LIR_Opr tmp =           (FrameMap::rsi_opr);
1001 #else
1002 
1003   // The java calling convention will give us enough registers
1004   // so that on the stub side the args will be perfect already.
1005   // On the other slow/special case side we call C and the arg
1006   // positions are not similar enough to pick one as the best.
1007   // Also because the java calling convention is a &quot;shifted&quot; version
1008   // of the C convention we can process the java args trivially into C
1009   // args without worry of overwriting during the xfer
1010 
1011   src.load_item_force     (FrameMap::as_oop_opr(j_rarg0));
1012   src_pos.load_item_force (FrameMap::as_opr(j_rarg1));
1013   dst.load_item_force     (FrameMap::as_oop_opr(j_rarg2));
1014   dst_pos.load_item_force (FrameMap::as_opr(j_rarg3));
1015   length.load_item_force  (FrameMap::as_opr(j_rarg4));
1016 
1017   LIR_Opr tmp =           FrameMap::as_opr(j_rarg5);
1018 #endif // LP64
1019 
1020   set_no_result(x);
1021 
1022   int flags;
1023   ciArrayKlass* expected_type;
1024   arraycopy_helper(x, &amp;flags, &amp;expected_type);
1025 
1026   __ arraycopy(src.result(), src_pos.result(), dst.result(), dst_pos.result(), length.result(), tmp, expected_type, flags, info); // does add_safepoint
1027 }
1028 
1029 void LIRGenerator::do_update_CRC32(Intrinsic* x) {
1030   assert(UseCRC32Intrinsics, &quot;need AVX and LCMUL instructions support&quot;);
1031   // Make all state_for calls early since they can emit code
1032   LIR_Opr result = rlock_result(x);
1033   int flags = 0;
1034   switch (x-&gt;id()) {
1035     case vmIntrinsics::_updateCRC32: {
1036       LIRItem crc(x-&gt;argument_at(0), this);
1037       LIRItem val(x-&gt;argument_at(1), this);
1038       // val is destroyed by update_crc32
1039       val.set_destroys_register();
1040       crc.load_item();
1041       val.load_item();
1042       __ update_crc32(crc.result(), val.result(), result);
1043       break;
1044     }
1045     case vmIntrinsics::_updateBytesCRC32:
1046     case vmIntrinsics::_updateByteBufferCRC32: {
1047       bool is_updateBytes = (x-&gt;id() == vmIntrinsics::_updateBytesCRC32);
1048 
1049       LIRItem crc(x-&gt;argument_at(0), this);
1050       LIRItem buf(x-&gt;argument_at(1), this);
1051       LIRItem off(x-&gt;argument_at(2), this);
1052       LIRItem len(x-&gt;argument_at(3), this);
1053       buf.load_item();
1054       off.load_nonconstant();
1055 
1056       LIR_Opr index = off.result();
1057       int offset = is_updateBytes ? arrayOopDesc::base_offset_in_bytes(T_BYTE) : 0;
1058       if(off.result()-&gt;is_constant()) {
1059         index = LIR_OprFact::illegalOpr;
1060        offset += off.result()-&gt;as_jint();
1061       }
1062       LIR_Opr base_op = buf.result();
1063 
1064 #ifndef _LP64
1065       if (!is_updateBytes) { // long b raw address
1066          base_op = new_register(T_INT);
1067          __ convert(Bytecodes::_l2i, buf.result(), base_op);
1068       }
1069 #else
1070       if (index-&gt;is_valid()) {
1071         LIR_Opr tmp = new_register(T_LONG);
1072         __ convert(Bytecodes::_i2l, index, tmp);
1073         index = tmp;
1074       }
1075 #endif
1076 
1077       if (is_updateBytes) {
1078         base_op = access_resolve(IS_NOT_NULL | ACCESS_READ, base_op);
1079       }
1080 
1081       LIR_Address* a = new LIR_Address(base_op,
1082                                        index,
1083                                        offset,
1084                                        T_BYTE);
1085       BasicTypeList signature(3);
1086       signature.append(T_INT);
1087       signature.append(T_ADDRESS);
1088       signature.append(T_INT);
1089       CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
1090       const LIR_Opr result_reg = result_register_for(x-&gt;type());
1091 
1092       LIR_Opr addr = new_pointer_register();
1093       __ leal(LIR_OprFact::address(a), addr);
1094 
1095       crc.load_item_force(cc-&gt;at(0));
1096       __ move(addr, cc-&gt;at(1));
1097       len.load_item_force(cc-&gt;at(2));
1098 
1099       __ call_runtime_leaf(StubRoutines::updateBytesCRC32(), getThreadTemp(), result_reg, cc-&gt;args());
1100       __ move(result_reg, result);
1101 
1102       break;
1103     }
1104     default: {
1105       ShouldNotReachHere();
1106     }
1107   }
1108 }
1109 
1110 void LIRGenerator::do_update_CRC32C(Intrinsic* x) {
1111   Unimplemented();
1112 }
1113 
1114 void LIRGenerator::do_vectorizedMismatch(Intrinsic* x) {
1115   assert(UseVectorizedMismatchIntrinsic, &quot;need AVX instruction support&quot;);
1116 
1117   // Make all state_for calls early since they can emit code
1118   LIR_Opr result = rlock_result(x);
1119 
1120   LIRItem a(x-&gt;argument_at(0), this); // Object
1121   LIRItem aOffset(x-&gt;argument_at(1), this); // long
1122   LIRItem b(x-&gt;argument_at(2), this); // Object
1123   LIRItem bOffset(x-&gt;argument_at(3), this); // long
1124   LIRItem length(x-&gt;argument_at(4), this); // int
1125   LIRItem log2ArrayIndexScale(x-&gt;argument_at(5), this); // int
1126 
1127   a.load_item();
1128   aOffset.load_nonconstant();
1129   b.load_item();
1130   bOffset.load_nonconstant();
1131 
1132   long constant_aOffset = 0;
1133   LIR_Opr result_aOffset = aOffset.result();
1134   if (result_aOffset-&gt;is_constant()) {
1135     constant_aOffset = result_aOffset-&gt;as_jlong();
1136     result_aOffset = LIR_OprFact::illegalOpr;
1137   }
1138   LIR_Opr result_a = access_resolve(ACCESS_READ, a.result());
1139 
1140   long constant_bOffset = 0;
1141   LIR_Opr result_bOffset = bOffset.result();
1142   if (result_bOffset-&gt;is_constant()) {
1143     constant_bOffset = result_bOffset-&gt;as_jlong();
1144     result_bOffset = LIR_OprFact::illegalOpr;
1145   }
1146   LIR_Opr result_b = access_resolve(ACCESS_READ, b.result());
1147 
1148 #ifndef _LP64
1149   result_a = new_register(T_INT);
1150   __ convert(Bytecodes::_l2i, a.result(), result_a);
1151   result_b = new_register(T_INT);
1152   __ convert(Bytecodes::_l2i, b.result(), result_b);
1153 #endif
1154 
1155 
1156   LIR_Address* addr_a = new LIR_Address(result_a,
1157                                         result_aOffset,
1158                                         constant_aOffset,
1159                                         T_BYTE);
1160 
1161   LIR_Address* addr_b = new LIR_Address(result_b,
1162                                         result_bOffset,
1163                                         constant_bOffset,
1164                                         T_BYTE);
1165 
1166   BasicTypeList signature(4);
1167   signature.append(T_ADDRESS);
1168   signature.append(T_ADDRESS);
1169   signature.append(T_INT);
1170   signature.append(T_INT);
1171   CallingConvention* cc = frame_map()-&gt;c_calling_convention(&amp;signature);
1172   const LIR_Opr result_reg = result_register_for(x-&gt;type());
1173 
1174   LIR_Opr ptr_addr_a = new_pointer_register();
1175   __ leal(LIR_OprFact::address(addr_a), ptr_addr_a);
1176 
1177   LIR_Opr ptr_addr_b = new_pointer_register();
1178   __ leal(LIR_OprFact::address(addr_b), ptr_addr_b);
1179 
1180   __ move(ptr_addr_a, cc-&gt;at(0));
1181   __ move(ptr_addr_b, cc-&gt;at(1));
1182   length.load_item_force(cc-&gt;at(2));
1183   log2ArrayIndexScale.load_item_force(cc-&gt;at(3));
1184 
1185   __ call_runtime_leaf(StubRoutines::vectorizedMismatch(), getThreadTemp(), result_reg, cc-&gt;args());
1186   __ move(result_reg, result);
1187 }
1188 
1189 // _i2l, _i2f, _i2d, _l2i, _l2f, _l2d, _f2i, _f2l, _f2d, _d2i, _d2l, _d2f
1190 // _i2b, _i2c, _i2s
1191 LIR_Opr fixed_register_for(BasicType type) {
1192   switch (type) {
1193     case T_FLOAT:  return FrameMap::fpu0_float_opr;
1194     case T_DOUBLE: return FrameMap::fpu0_double_opr;
1195     case T_INT:    return FrameMap::rax_opr;
1196     case T_LONG:   return FrameMap::long0_opr;
1197     default:       ShouldNotReachHere(); return LIR_OprFact::illegalOpr;
1198   }
1199 }
1200 
1201 void LIRGenerator::do_Convert(Convert* x) {
1202 #ifdef _LP64
1203   LIRItem value(x-&gt;value(), this);
1204   value.load_item();
1205   LIR_Opr input = value.result();
1206   LIR_Opr result = rlock(x);
1207   __ convert(x-&gt;op(), input, result);
1208   assert(result-&gt;is_virtual(), &quot;result must be virtual register&quot;);
1209   set_result(x, result);
1210 #else
1211   // flags that vary for the different operations and different SSE-settings
1212   bool fixed_input = false, fixed_result = false, round_result = false, needs_stub = false;
1213 
1214   switch (x-&gt;op()) {
1215     case Bytecodes::_i2l: // fall through
1216     case Bytecodes::_l2i: // fall through
1217     case Bytecodes::_i2b: // fall through
1218     case Bytecodes::_i2c: // fall through
1219     case Bytecodes::_i2s: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = false; break;
1220 
1221     case Bytecodes::_f2d: fixed_input = UseSSE == 1; fixed_result = false;       round_result = false;      needs_stub = false; break;
1222     case Bytecodes::_d2f: fixed_input = false;       fixed_result = UseSSE == 1; round_result = UseSSE &lt; 1; needs_stub = false; break;
1223     case Bytecodes::_i2f: fixed_input = false;       fixed_result = false;       round_result = UseSSE &lt; 1; needs_stub = false; break;
1224     case Bytecodes::_i2d: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = false; break;
1225     case Bytecodes::_f2i: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = true;  break;
1226     case Bytecodes::_d2i: fixed_input = false;       fixed_result = false;       round_result = false;      needs_stub = true;  break;
1227     case Bytecodes::_l2f: fixed_input = false;       fixed_result = UseSSE &gt;= 1; round_result = UseSSE &lt; 1; needs_stub = false; break;
1228     case Bytecodes::_l2d: fixed_input = false;       fixed_result = UseSSE &gt;= 2; round_result = UseSSE &lt; 2; needs_stub = false; break;
1229     case Bytecodes::_f2l: fixed_input = true;        fixed_result = true;        round_result = false;      needs_stub = false; break;
1230     case Bytecodes::_d2l: fixed_input = true;        fixed_result = true;        round_result = false;      needs_stub = false; break;
1231     default: ShouldNotReachHere();
1232   }
1233 
1234   LIRItem value(x-&gt;value(), this);
1235   value.load_item();
1236   LIR_Opr input = value.result();
1237   LIR_Opr result = rlock(x);
1238 
1239   // arguments of lir_convert
1240   LIR_Opr conv_input = input;
1241   LIR_Opr conv_result = result;
1242   ConversionStub* stub = NULL;
1243 
1244   if (fixed_input) {
1245     conv_input = fixed_register_for(input-&gt;type());
1246     __ move(input, conv_input);
1247   }
1248 
1249   assert(fixed_result == false || round_result == false, &quot;cannot set both&quot;);
1250   if (fixed_result) {
1251     conv_result = fixed_register_for(result-&gt;type());
1252   } else if (round_result) {
1253     result = new_register(result-&gt;type());
1254     set_vreg_flag(result, must_start_in_memory);
1255   }
1256 
1257   if (needs_stub) {
1258     stub = new ConversionStub(x-&gt;op(), conv_input, conv_result);
1259   }
1260 
1261   __ convert(x-&gt;op(), conv_input, conv_result, stub);
1262 
1263   if (result != conv_result) {
1264     __ move(conv_result, result);
1265   }
1266 
1267   assert(result-&gt;is_virtual(), &quot;result must be virtual register&quot;);
1268   set_result(x, result);
1269 #endif // _LP64
1270 }
1271 
1272 
1273 void LIRGenerator::do_NewInstance(NewInstance* x) {
1274   print_if_not_loaded(x);
1275 
1276   CodeEmitInfo* info = state_for(x, x-&gt;state());
1277   LIR_Opr reg = result_register_for(x-&gt;type());
1278   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(),
1279                        FrameMap::rcx_oop_opr,
1280                        FrameMap::rdi_oop_opr,
1281                        FrameMap::rsi_oop_opr,
1282                        LIR_OprFact::illegalOpr,
1283                        FrameMap::rdx_metadata_opr, info);
1284   LIR_Opr result = rlock_result(x);
1285   __ move(reg, result);
1286 }
1287 
1288 void LIRGenerator::do_NewValueTypeInstance(NewValueTypeInstance* x) {
1289   // Mapping to do_NewInstance (same code) but use state_before for reexecution.
1290   CodeEmitInfo* info = state_for(x, x-&gt;state_before());
1291   x-&gt;set_to_object_type();
1292   LIR_Opr reg = result_register_for(x-&gt;type());
1293   new_instance(reg, x-&gt;klass(), x-&gt;is_unresolved(),
1294              FrameMap::rcx_oop_opr,
1295              FrameMap::rdi_oop_opr,
1296              FrameMap::rsi_oop_opr,
1297              LIR_OprFact::illegalOpr,
1298              FrameMap::rdx_metadata_opr, info);
1299   LIR_Opr result = rlock_result(x);
1300   __ move(reg, result);
1301 
1302 }
1303 
1304 void LIRGenerator::do_NewTypeArray(NewTypeArray* x) {
1305   CodeEmitInfo* info = state_for(x, x-&gt;state());
1306 
1307   LIRItem length(x-&gt;length(), this);
1308   length.load_item_force(FrameMap::rbx_opr);
1309 
1310   LIR_Opr reg = result_register_for(x-&gt;type());
1311   LIR_Opr tmp1 = FrameMap::rcx_oop_opr;
1312   LIR_Opr tmp2 = FrameMap::rsi_oop_opr;
1313   LIR_Opr tmp3 = FrameMap::rdi_oop_opr;
1314   LIR_Opr tmp4 = reg;
1315   LIR_Opr klass_reg = FrameMap::rdx_metadata_opr;
1316   LIR_Opr len = length.result();
1317   BasicType elem_type = x-&gt;elt_type();
1318 
1319   __ metadata2reg(ciTypeArrayKlass::make(elem_type)-&gt;constant_encoding(), klass_reg);
1320 
1321   CodeStub* slow_path = new NewTypeArrayStub(klass_reg, len, reg, info);
1322   __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);
1323 
1324   LIR_Opr result = rlock_result(x);
1325   __ move(reg, result);
1326 }
1327 
1328 
1329 void LIRGenerator::do_NewObjectArray(NewObjectArray* x) {
1330   LIRItem length(x-&gt;length(), this);
1331   // in case of patching (i.e., object class is not yet loaded), we need to reexecute the instruction
1332   // and therefore provide the state before the parameters have been consumed
1333   CodeEmitInfo* patching_info = NULL;
1334   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1335     patching_info =  state_for(x, x-&gt;state_before());
1336   }
1337 
1338   CodeEmitInfo* info = state_for(x, x-&gt;state());
1339 
1340   const LIR_Opr reg = result_register_for(x-&gt;type());
1341   LIR_Opr tmp1 = FrameMap::rcx_oop_opr;
1342   LIR_Opr tmp2 = FrameMap::rsi_oop_opr;
1343   LIR_Opr tmp3 = FrameMap::rdi_oop_opr;
1344   LIR_Opr tmp4 = reg;
1345   LIR_Opr klass_reg = FrameMap::rdx_metadata_opr;
1346 
1347   length.load_item_force(FrameMap::rbx_opr);
1348   LIR_Opr len = length.result();
1349 
1350   ciKlass* obj = (ciKlass*) x-&gt;exact_type();
1351   CodeStub* slow_path = new NewObjectArrayStub(klass_reg, len, reg, info, x-&gt;is_never_null());
1352   if (obj == ciEnv::unloaded_ciobjarrayklass()) {
1353     BAILOUT(&quot;encountered unloaded_ciobjarrayklass due to out of memory error&quot;);
1354   }
1355   klass2reg_with_patching(klass_reg, obj, patching_info);
1356   if (x-&gt;is_never_null()) {
1357     __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_VALUETYPE, klass_reg, slow_path);
1358   } else {
1359     __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);
1360   }
1361 
1362   LIR_Opr result = rlock_result(x);
1363   __ move(reg, result);
1364 }
1365 
1366 
1367 void LIRGenerator::do_NewMultiArray(NewMultiArray* x) {
1368   Values* dims = x-&gt;dims();
1369   int i = dims-&gt;length();
1370   LIRItemList* items = new LIRItemList(i, i, NULL);
1371   while (i-- &gt; 0) {
1372     LIRItem* size = new LIRItem(dims-&gt;at(i), this);
1373     items-&gt;at_put(i, size);
1374   }
1375 
1376   // Evaluate state_for early since it may emit code.
1377   CodeEmitInfo* patching_info = NULL;
1378   if (!x-&gt;klass()-&gt;is_loaded() || PatchALot) {
1379     patching_info = state_for(x, x-&gt;state_before());
1380 
1381     // Cannot re-use same xhandlers for multiple CodeEmitInfos, so
1382     // clone all handlers (NOTE: Usually this is handled transparently
1383     // by the CodeEmitInfo cloning logic in CodeStub constructors but
1384     // is done explicitly here because a stub isn&#39;t being used).
1385     x-&gt;set_exception_handlers(new XHandlers(x-&gt;exception_handlers()));
1386   }
1387   CodeEmitInfo* info = state_for(x, x-&gt;state());
1388 
1389   i = dims-&gt;length();
1390   while (i-- &gt; 0) {
1391     LIRItem* size = items-&gt;at(i);
1392     size-&gt;load_nonconstant();
1393 
1394     store_stack_parameter(size-&gt;result(), in_ByteSize(i*4));
1395   }
1396 
1397   LIR_Opr klass_reg = FrameMap::rax_metadata_opr;
1398   klass2reg_with_patching(klass_reg, x-&gt;klass(), patching_info);
1399 
1400   LIR_Opr rank = FrameMap::rbx_opr;
1401   __ move(LIR_OprFact::intConst(x-&gt;rank()), rank);
1402   LIR_Opr varargs = FrameMap::rcx_opr;
1403   __ move(FrameMap::rsp_opr, varargs);
1404   LIR_OprList* args = new LIR_OprList(3);
1405   args-&gt;append(klass_reg);
1406   args-&gt;append(rank);
1407   args-&gt;append(varargs);
1408   LIR_Opr reg = result_register_for(x-&gt;type());
1409   __ call_runtime(Runtime1::entry_for(Runtime1::new_multi_array_id),
1410                   LIR_OprFact::illegalOpr,
1411                   reg, args, info);
1412 
1413   LIR_Opr result = rlock_result(x);
1414   __ move(reg, result);
1415 }
1416 
1417 
1418 void LIRGenerator::do_BlockBegin(BlockBegin* x) {
1419   // nothing to do for now
1420 }
1421 
1422 
1423 void LIRGenerator::do_CheckCast(CheckCast* x) {
1424   LIRItem obj(x-&gt;obj(), this);
1425 
1426   CodeEmitInfo* patching_info = NULL;
1427   if (!x-&gt;klass()-&gt;is_loaded() || (PatchALot &amp;&amp; !x-&gt;is_incompatible_class_change_check() &amp;&amp; !x-&gt;is_invokespecial_receiver_check())) {
1428     // must do this before locking the destination register as an oop register,
1429     // and before the obj is loaded (the latter is for deoptimization)
1430     patching_info = state_for(x, x-&gt;state_before());
1431   }
1432   obj.load_item();
1433 
1434   // info for exceptions
1435   CodeEmitInfo* info_for_exception =
1436       (x-&gt;needs_exception_state() ? state_for(x) :
1437                                     state_for(x, x-&gt;state_before(), true /*ignore_xhandler*/));
1438 
1439   if (x-&gt;is_never_null()) {
1440     __ null_check(obj.result(), new CodeEmitInfo(info_for_exception));
1441   }
1442 
1443   CodeStub* stub;
1444   if (x-&gt;is_incompatible_class_change_check()) {
1445     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1446     stub = new SimpleExceptionStub(Runtime1::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);
1447   } else if (x-&gt;is_invokespecial_receiver_check()) {
1448     assert(patching_info == NULL, &quot;can&#39;t patch this&quot;);
1449     stub = new DeoptimizeStub(info_for_exception, Deoptimization::Reason_class_check, Deoptimization::Action_none);
1450   } else {
1451     stub = new SimpleExceptionStub(Runtime1::throw_class_cast_exception_id, obj.result(), info_for_exception);
1452   }
1453   LIR_Opr reg = rlock_result(x);
1454   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1455   if (!x-&gt;klass()-&gt;is_loaded() || UseCompressedClassPointers) {
1456     tmp3 = new_register(objectType);
1457   }
1458   __ checkcast(reg, obj.result(), x-&gt;klass(),
1459                new_register(objectType), new_register(objectType), tmp3,
1460                x-&gt;direct_compare(), info_for_exception, patching_info, stub,
1461                x-&gt;profiled_method(), x-&gt;profiled_bci(), x-&gt;is_never_null());
1462 }
1463 
1464 
1465 void LIRGenerator::do_InstanceOf(InstanceOf* x) {
1466   LIRItem obj(x-&gt;obj(), this);
1467 
1468   // result and test object may not be in same register
1469   LIR_Opr reg = rlock_result(x);
1470   CodeEmitInfo* patching_info = NULL;
1471   if ((!x-&gt;klass()-&gt;is_loaded() || PatchALot)) {
1472     // must do this before locking the destination register as an oop register
1473     patching_info = state_for(x, x-&gt;state_before());
1474   }
1475   obj.load_item();
1476   LIR_Opr tmp3 = LIR_OprFact::illegalOpr;
1477   if (!x-&gt;klass()-&gt;is_loaded() || UseCompressedClassPointers) {
1478     tmp3 = new_register(objectType);
1479   }
1480   __ instanceof(reg, obj.result(), x-&gt;klass(),
1481                 new_register(objectType), new_register(objectType), tmp3,
1482                 x-&gt;direct_compare(), patching_info, x-&gt;profiled_method(), x-&gt;profiled_bci());
1483 }
1484 
1485 
1486 void LIRGenerator::do_If(If* x) {
1487   assert(x-&gt;number_of_sux() == 2, &quot;inconsistency&quot;);
1488   ValueTag tag = x-&gt;x()-&gt;type()-&gt;tag();
1489   bool is_safepoint = x-&gt;is_safepoint();
1490 
1491   If::Condition cond = x-&gt;cond();
1492 
1493   LIRItem xitem(x-&gt;x(), this);
1494   LIRItem yitem(x-&gt;y(), this);
1495   LIRItem* xin = &amp;xitem;
1496   LIRItem* yin = &amp;yitem;
1497 
1498   if (tag == longTag) {
1499     // for longs, only conditions &quot;eql&quot;, &quot;neq&quot;, &quot;lss&quot;, &quot;geq&quot; are valid;
1500     // mirror for other conditions
1501     if (cond == If::gtr || cond == If::leq) {
1502       cond = Instruction::mirror(cond);
1503       xin = &amp;yitem;
1504       yin = &amp;xitem;
1505     }
1506     xin-&gt;set_destroys_register();
1507   }
1508   xin-&gt;load_item();
1509   if (tag == longTag &amp;&amp; yin-&gt;is_constant() &amp;&amp; yin-&gt;get_jlong_constant() == 0 &amp;&amp; (cond == If::eql || cond == If::neq)) {
1510     // inline long zero
1511     yin-&gt;dont_load_item();
1512   } else if (tag == longTag || tag == floatTag || tag == doubleTag || x-&gt;substitutability_check()) {
1513     // longs cannot handle constants at right side
1514     yin-&gt;load_item();
1515   } else {
1516     yin-&gt;dont_load_item();
1517   }
1518 
1519   LIR_Opr left = xin-&gt;result();
1520   LIR_Opr right = yin-&gt;result();
1521 
1522   set_no_result(x);
1523 
1524   // add safepoint before generating condition code so it can be recomputed
1525   if (x-&gt;is_safepoint()) {
1526     // increment backedge counter if needed
1527     increment_backedge_counter_conditionally(lir_cond(cond), left, right, state_for(x, x-&gt;state_before()),
1528         x-&gt;tsux()-&gt;bci(), x-&gt;fsux()-&gt;bci(), x-&gt;profiled_bci());
1529     __ safepoint(safepoint_poll_register(), state_for(x, x-&gt;state_before()));
1530   }
1531 
1532   if (x-&gt;substitutability_check()) {
1533     substitutability_check(x, *xin, *yin);
1534   } else {
1535     __ cmp(lir_cond(cond), left, right);
1536   }
1537   // Generate branch profiling. Profiling code doesn&#39;t kill flags.
1538   profile_branch(x, cond);
1539   move_to_phi(x-&gt;state());
1540   if (x-&gt;x()-&gt;type()-&gt;is_float_kind()) {
1541     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux(), x-&gt;usux());
1542   } else {
1543     __ branch(lir_cond(cond), right-&gt;type(), x-&gt;tsux());
1544   }
1545   assert(x-&gt;default_sux() == x-&gt;fsux(), &quot;wrong destination above&quot;);
1546   __ jump(x-&gt;default_sux());
1547 }
1548 
1549 
1550 LIR_Opr LIRGenerator::getThreadPointer() {
1551 #ifdef _LP64
1552   return FrameMap::as_pointer_opr(r15_thread);
1553 #else
1554   LIR_Opr result = new_register(T_INT);
1555   __ get_thread(result);
1556   return result;
1557 #endif //
1558 }
1559 
1560 void LIRGenerator::trace_block_entry(BlockBegin* block) {
1561   store_stack_parameter(LIR_OprFact::intConst(block-&gt;block_id()), in_ByteSize(0));
1562   LIR_OprList* args = new LIR_OprList();
1563   address func = CAST_FROM_FN_PTR(address, Runtime1::trace_block_entry);
1564   __ call_runtime_leaf(func, LIR_OprFact::illegalOpr, LIR_OprFact::illegalOpr, args);
1565 }
1566 
1567 
1568 void LIRGenerator::volatile_field_store(LIR_Opr value, LIR_Address* address,
1569                                         CodeEmitInfo* info) {
1570   if (address-&gt;type() == T_LONG) {
1571     address = new LIR_Address(address-&gt;base(),
1572                               address-&gt;index(), address-&gt;scale(),
1573                               address-&gt;disp(), T_DOUBLE);
1574     // Transfer the value atomically by using FP moves.  This means
1575     // the value has to be moved between CPU and FPU registers.  It
1576     // always has to be moved through spill slot since there&#39;s no
1577     // quick way to pack the value into an SSE register.
1578     LIR_Opr temp_double = new_register(T_DOUBLE);
1579     LIR_Opr spill = new_register(T_LONG);
1580     set_vreg_flag(spill, must_start_in_memory);
1581     __ move(value, spill);
1582     __ volatile_move(spill, temp_double, T_LONG);
1583     __ volatile_move(temp_double, LIR_OprFact::address(address), T_LONG, info);
1584   } else {
1585     __ store(value, address, info);
1586   }
1587 }
1588 
1589 void LIRGenerator::volatile_field_load(LIR_Address* address, LIR_Opr result,
1590                                        CodeEmitInfo* info) {
1591   if (address-&gt;type() == T_LONG) {
1592     address = new LIR_Address(address-&gt;base(),
1593                               address-&gt;index(), address-&gt;scale(),
1594                               address-&gt;disp(), T_DOUBLE);
1595     // Transfer the value atomically by using FP moves.  This means
1596     // the value has to be moved between CPU and FPU registers.  In
1597     // SSE0 and SSE1 mode it has to be moved through spill slot but in
1598     // SSE2+ mode it can be moved directly.
1599     LIR_Opr temp_double = new_register(T_DOUBLE);
1600     __ volatile_move(LIR_OprFact::address(address), temp_double, T_LONG, info);
1601     __ volatile_move(temp_double, result, T_LONG);
1602     if (UseSSE &lt; 2) {
1603       // no spill slot needed in SSE2 mode because xmm-&gt;cpu register move is possible
1604       set_vreg_flag(result, must_start_in_memory);
1605     }
1606   } else {
1607     __ load(address, result, info);
1608   }
1609 }
    </pre>
  </body>
</html>
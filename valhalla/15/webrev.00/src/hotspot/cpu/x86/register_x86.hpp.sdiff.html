<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/register_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="register_definitions_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_x86_32.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/register_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
113 
114   inline VMReg as_VMReg();
115 
116   // derived registers, offsets, and addresses
117 
118   FloatRegister successor() const                          { return as_FloatRegister(encoding() + 1); }
119 
120   // accessors
121   int   encoding() const                          { assert(is_valid(), &quot;invalid register&quot;); return (intptr_t)this; }
122   bool  is_valid() const                          { return 0 &lt;= (intptr_t)this &amp;&amp; (intptr_t)this &lt; number_of_registers; }
123   const char* name() const;
124 
125 };
126 
127 CONSTANT_REGISTER_DECLARATION(FloatRegister, fnoreg, (-1));
128 
129 // Use XMMRegister as shortcut
130 class XMMRegisterImpl;
131 typedef XMMRegisterImpl* XMMRegister;
132 
<span class="line-removed">133 // Use MMXRegister as shortcut</span>
<span class="line-removed">134 class MMXRegisterImpl;</span>
<span class="line-removed">135 typedef MMXRegisterImpl* MMXRegister;</span>
<span class="line-removed">136 </span>
137 inline XMMRegister as_XMMRegister(int encoding) {
138   return (XMMRegister)(intptr_t)encoding;
139 }
140 
<span class="line-removed">141 inline MMXRegister as_MMXRegister(int encoding) {</span>
<span class="line-removed">142   return (MMXRegister)(intptr_t)encoding;</span>
<span class="line-removed">143 }</span>
144 
145 // The implementation of XMM registers for the IA32 architecture
146 class XMMRegisterImpl: public AbstractRegisterImpl {
147  public:
148   enum {
149 #ifndef AMD64
150     number_of_registers = 8,
151     max_slots_per_register = 16   // 512-bit
152 #else
153     number_of_registers = 32,
154     max_slots_per_register = 16   // 512-bit
155 #endif // AMD64
156   };
157 
158   // construction
159   friend XMMRegister as_XMMRegister(int encoding);
160 
161   inline VMReg as_VMReg();
162 
163   // derived registers, offsets, and addresses
</pre>
<hr />
<pre>
195 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm18,    (18));
196 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm19,    (19));
197 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm20,    (20));
198 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm21,    (21));
199 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm22,    (22));
200 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm23,    (23));
201 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm24,    (24));
202 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm25,    (25));
203 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm26,    (26));
204 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm27,    (27));
205 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm28,    (28));
206 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm29,    (29));
207 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm30,    (30));
208 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm31,    (31));
209 #endif // AMD64
210 
211 // Only used by the 32bit stubGenerator. These can&#39;t be described by vmreg and hence
212 // can&#39;t be described in oopMaps and therefore can&#39;t be used by the compilers (at least
213 // were deopt might wan&#39;t to see them).
214 
<span class="line-removed">215 // The MMX registers, for P3 and up chips</span>
<span class="line-removed">216 CONSTANT_REGISTER_DECLARATION(MMXRegister, mnoreg , (-1));</span>
<span class="line-removed">217 CONSTANT_REGISTER_DECLARATION(MMXRegister, mmx0 , ( 0));</span>
<span class="line-removed">218 CONSTANT_REGISTER_DECLARATION(MMXRegister, mmx1 , ( 1));</span>
<span class="line-removed">219 CONSTANT_REGISTER_DECLARATION(MMXRegister, mmx2 , ( 2));</span>
<span class="line-removed">220 CONSTANT_REGISTER_DECLARATION(MMXRegister, mmx3 , ( 3));</span>
<span class="line-removed">221 CONSTANT_REGISTER_DECLARATION(MMXRegister, mmx4 , ( 4));</span>
<span class="line-removed">222 CONSTANT_REGISTER_DECLARATION(MMXRegister, mmx5 , ( 5));</span>
<span class="line-removed">223 CONSTANT_REGISTER_DECLARATION(MMXRegister, mmx6 , ( 6));</span>
<span class="line-removed">224 CONSTANT_REGISTER_DECLARATION(MMXRegister, mmx7 , ( 7));</span>
<span class="line-removed">225 </span>
226 // Use XMMRegister as shortcut
227 class KRegisterImpl;
228 typedef KRegisterImpl* KRegister;
229 
230 inline KRegister as_KRegister(int encoding) {
231   return (KRegister)(intptr_t)encoding;
232 }
233 
234 // The implementation of XMM registers for the IA32 architecture
235 class KRegisterImpl : public AbstractRegisterImpl {
236 public:
237   enum {
238     number_of_registers = 8,
239     max_slots_per_register = 1
240   };
241 
242   // construction
243   friend KRegister as_KRegister(int encoding);
244 
245   inline VMReg as_VMReg();
</pre>
</td>
<td>
<hr />
<pre>
113 
114   inline VMReg as_VMReg();
115 
116   // derived registers, offsets, and addresses
117 
118   FloatRegister successor() const                          { return as_FloatRegister(encoding() + 1); }
119 
120   // accessors
121   int   encoding() const                          { assert(is_valid(), &quot;invalid register&quot;); return (intptr_t)this; }
122   bool  is_valid() const                          { return 0 &lt;= (intptr_t)this &amp;&amp; (intptr_t)this &lt; number_of_registers; }
123   const char* name() const;
124 
125 };
126 
127 CONSTANT_REGISTER_DECLARATION(FloatRegister, fnoreg, (-1));
128 
129 // Use XMMRegister as shortcut
130 class XMMRegisterImpl;
131 typedef XMMRegisterImpl* XMMRegister;
132 




133 inline XMMRegister as_XMMRegister(int encoding) {
134   return (XMMRegister)(intptr_t)encoding;
135 }
136 



137 
138 // The implementation of XMM registers for the IA32 architecture
139 class XMMRegisterImpl: public AbstractRegisterImpl {
140  public:
141   enum {
142 #ifndef AMD64
143     number_of_registers = 8,
144     max_slots_per_register = 16   // 512-bit
145 #else
146     number_of_registers = 32,
147     max_slots_per_register = 16   // 512-bit
148 #endif // AMD64
149   };
150 
151   // construction
152   friend XMMRegister as_XMMRegister(int encoding);
153 
154   inline VMReg as_VMReg();
155 
156   // derived registers, offsets, and addresses
</pre>
<hr />
<pre>
188 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm18,    (18));
189 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm19,    (19));
190 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm20,    (20));
191 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm21,    (21));
192 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm22,    (22));
193 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm23,    (23));
194 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm24,    (24));
195 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm25,    (25));
196 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm26,    (26));
197 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm27,    (27));
198 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm28,    (28));
199 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm29,    (29));
200 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm30,    (30));
201 CONSTANT_REGISTER_DECLARATION(XMMRegister, xmm31,    (31));
202 #endif // AMD64
203 
204 // Only used by the 32bit stubGenerator. These can&#39;t be described by vmreg and hence
205 // can&#39;t be described in oopMaps and therefore can&#39;t be used by the compilers (at least
206 // were deopt might wan&#39;t to see them).
207 











208 // Use XMMRegister as shortcut
209 class KRegisterImpl;
210 typedef KRegisterImpl* KRegister;
211 
212 inline KRegister as_KRegister(int encoding) {
213   return (KRegister)(intptr_t)encoding;
214 }
215 
216 // The implementation of XMM registers for the IA32 architecture
217 class KRegisterImpl : public AbstractRegisterImpl {
218 public:
219   enum {
220     number_of_registers = 8,
221     max_slots_per_register = 1
222   };
223 
224   // construction
225   friend KRegister as_KRegister(int encoding);
226 
227   inline VMReg as_VMReg();
</pre>
</td>
</tr>
</table>
<center><a href="register_definitions_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_x86_32.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/assembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="assembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/assembler_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 322 #endif // ASSERT
 323 
 324   // accessors
 325   bool        uses(Register reg) const { return _base == reg || _index == reg; }
 326   Register    base()             const { return _base;  }
 327   Register    index()            const { return _index; }
 328   XMMRegister xmmindex()         const { return _xmmindex; }
 329   ScaleFactor scale()            const { return _scale; }
 330   int         disp()             const { return _disp;  }
 331   bool        isxmmindex()       const { return _isxmmindex; }
 332 
 333   // Convert the raw encoding form into the form expected by the constructor for
 334   // Address.  An index of 4 (rsp) corresponds to having no index, so convert
 335   // that to noreg for the Address constructor.
 336   static Address make_raw(int base, int index, int scale, int disp, relocInfo::relocType disp_reloc);
 337 
 338   static Address make_array(ArrayAddress);
 339 
 340  private:
 341   bool base_needs_rex() const {
<span class="line-modified"> 342     return _base != noreg &amp;&amp; _base-&gt;encoding() &gt;= 8;</span>
 343   }
 344 
 345   bool index_needs_rex() const {
<span class="line-modified"> 346     return _index != noreg &amp;&amp;_index-&gt;encoding() &gt;= 8;</span>
 347   }
 348 
 349   bool xmmindex_needs_rex() const {
<span class="line-modified"> 350     return _xmmindex != xnoreg &amp;&amp; _xmmindex-&gt;encoding() &gt;= 8;</span>
 351   }
 352 
 353   relocInfo::relocType reloc() const { return _rspec.type(); }
 354 
 355   friend class Assembler;
 356   friend class MacroAssembler;
 357   friend class LIR_Assembler; // base/index/scale/disp
 358 };
 359 
 360 //
 361 // AddressLiteral has been split out from Address because operands of this type
 362 // need to be treated specially on 32bit vs. 64bit platforms. By splitting it out
 363 // the few instructions that need to deal with address literals are unique and the
 364 // MacroAssembler does not have to implement every instruction in the Assembler
 365 // in order to search for address literals that may need special handling depending
 366 // on the instruction and the platform. As small step on the way to merging i486/amd64
 367 // directories.
 368 //
 369 class AddressLiteral {
 370   friend class ArrayAddress;
</pre>
<hr />
<pre>
 642   // We could use a &quot;safe enough&quot; estimate (15), but just default to
 643   // instruction length guess from above.
 644   static unsigned int instr_maxlen() { return 4; }
 645 
 646   // NOTE: The general philopsophy of the declarations here is that 64bit versions
 647   // of instructions are freely declared without the need for wrapping them an ifdef.
 648   // (Some dangerous instructions are ifdef&#39;s out of inappropriate jvm&#39;s.)
 649   // In the .cpp file the implementations are wrapped so that they are dropped out
 650   // of the resulting jvm. This is done mostly to keep the footprint of MINIMAL
 651   // to the size it was prior to merging up the 32bit and 64bit assemblers.
 652   //
 653   // This does mean you&#39;ll get a linker/runtime error if you use a 64bit only instruction
 654   // in a 32bit vm. This is somewhat unfortunate but keeps the ifdef noise down.
 655 
 656 private:
 657 
 658   bool _legacy_mode_bw;
 659   bool _legacy_mode_dq;
 660   bool _legacy_mode_vl;
 661   bool _legacy_mode_vlbw;
<span class="line-modified"> 662   bool _is_managed;</span>
<span class="line-removed"> 663   bool _vector_masking;    // For stub code use only</span>
 664 
 665   class InstructionAttr *_attributes;
 666 
 667   // 64bit prefixes
<span class="line-modified"> 668   int prefix_and_encode(int reg_enc, bool byteinst = false);</span>
<span class="line-modified"> 669   int prefixq_and_encode(int reg_enc);</span>

 670 





 671   int prefix_and_encode(int dst_enc, int src_enc) {
 672     return prefix_and_encode(dst_enc, false, src_enc, false);
 673   }
 674   int prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte);
<span class="line-removed"> 675   int prefixq_and_encode(int dst_enc, int src_enc);</span>
 676 
<span class="line-modified"> 677   void prefix(Register reg);</span>
<span class="line-modified"> 678   void prefix(Register dst, Register src, Prefix p);</span>
<span class="line-modified"> 679   void prefix(Register dst, Address adr, Prefix p);</span>
<span class="line-modified"> 680   void prefix(Address adr);</span>
<span class="line-modified"> 681   void prefixq(Address adr);</span>
 682 
<span class="line-modified"> 683   void prefix(Address adr, Register reg,  bool byteinst = false);</span>
<span class="line-removed"> 684   void prefix(Address adr, XMMRegister reg);</span>
 685   void prefixq(Address adr, Register reg);
 686   void prefixq(Address adr, XMMRegister reg);
 687 
<span class="line-modified"> 688   void prefetch_prefix(Address src);</span>

 689 
 690   void rex_prefix(Address adr, XMMRegister xreg,
 691                   VexSimdPrefix pre, VexOpcode opc, bool rex_w);
 692   int  rex_prefix_and_encode(int dst_enc, int src_enc,
 693                              VexSimdPrefix pre, VexOpcode opc, bool rex_w);
 694 
 695   void vex_prefix(bool vex_r, bool vex_b, bool vex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc);
 696 
 697   void evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_v,
 698                    int nds_enc, VexSimdPrefix pre, VexOpcode opc);
 699 
 700   void vex_prefix(Address adr, int nds_enc, int xreg_enc,
 701                   VexSimdPrefix pre, VexOpcode opc,
 702                   InstructionAttr *attributes);
 703 
 704   int  vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc,
 705                              VexSimdPrefix pre, VexOpcode opc,
 706                              InstructionAttr *attributes);
 707 
 708   void simd_prefix(XMMRegister xreg, XMMRegister nds, Address adr, VexSimdPrefix pre,
 709                    VexOpcode opc, InstructionAttr *attributes);
 710 
 711   int simd_prefix_and_encode(XMMRegister dst, XMMRegister nds, XMMRegister src, VexSimdPrefix pre,
 712                              VexOpcode opc, InstructionAttr *attributes);
 713 
 714   // Helper functions for groups of instructions
 715   void emit_arith_b(int op1, int op2, Register dst, int imm8);
 716 
 717   void emit_arith(int op1, int op2, Register dst, int32_t imm32);
 718   // Force generation of a 4 byte immediate value even if it fits into 8bit
 719   void emit_arith_imm32(int op1, int op2, Register dst, int32_t imm32);
 720   void emit_arith(int op1, int op2, Register dst, Register src);
 721 
 722   bool emit_compressed_disp_byte(int &amp;disp);
 723 















 724   void emit_operand(Register reg,
 725                     Register base, Register index, Address::ScaleFactor scale,
 726                     int disp,
 727                     RelocationHolder const&amp; rspec,
 728                     int rip_relative_correction = 0);
 729 
<span class="line-modified"> 730   void emit_operand(XMMRegister reg, Register base, XMMRegister index,</span>
<span class="line-modified"> 731                     Address::ScaleFactor scale,</span>
<span class="line-modified"> 732                     int disp, RelocationHolder const&amp; rspec);</span>

 733 
<span class="line-modified"> 734   void emit_operand(Register reg, Address adr, int rip_relative_correction = 0);</span>



 735 
<span class="line-modified"> 736   // operands that only take the original 32bit registers</span>
<span class="line-modified"> 737   void emit_operand32(Register reg, Address adr);</span>
 738 
 739   void emit_operand(XMMRegister reg,
 740                     Register base, Register index, Address::ScaleFactor scale,
 741                     int disp,
 742                     RelocationHolder const&amp; rspec);
 743 
 744   void emit_operand(XMMRegister reg, Address adr);
 745 
<span class="line-removed"> 746   void emit_operand(MMXRegister reg, Address adr);</span>
<span class="line-removed"> 747 </span>
<span class="line-removed"> 748   // workaround gcc (3.2.1-7) bug</span>
<span class="line-removed"> 749   void emit_operand(Address adr, MMXRegister reg);</span>
<span class="line-removed"> 750 </span>
<span class="line-removed"> 751 </span>
 752   // Immediate-to-memory forms
 753   void emit_arith_operand(int op1, Register rm, Address adr, int32_t imm32);
 754 
<span class="line-removed"> 755   void emit_farith(int b1, int b2, int i);</span>
<span class="line-removed"> 756 </span>
<span class="line-removed"> 757 </span>
 758  protected:
 759   #ifdef ASSERT
 760   void check_relocation(RelocationHolder const&amp; rspec, int format);
 761   #endif
 762 
 763   void emit_data(jint data, relocInfo::relocType    rtype, int format);
 764   void emit_data(jint data, RelocationHolder const&amp; rspec, int format);
 765   void emit_data64(jlong data, relocInfo::relocType rtype, int format = 0);
 766   void emit_data64(jlong data, RelocationHolder const&amp; rspec, int format = 0);
 767 
 768   bool reachable(AddressLiteral adr) NOT_LP64({ return true;});
 769 
 770   // These are all easily abused and hence protected
 771 
 772   // 32BIT ONLY SECTION
 773 #ifndef _LP64
 774   // Make these disappear in 64bit mode since they would never be correct
 775   void cmp_literal32(Register src1, int32_t imm32, RelocationHolder const&amp; rspec);   // 32BIT ONLY
 776   void cmp_literal32(Address src1, int32_t imm32, RelocationHolder const&amp; rspec);    // 32BIT ONLY
 777 
</pre>
<hr />
<pre>
 854   }
 855 
 856   // Decoding
 857   static address locate_operand(address inst, WhichOperand which);
 858   static address locate_next_instruction(address inst);
 859 
 860   // Utilities
 861   static bool is_polling_page_far() NOT_LP64({ return false;});
 862   static bool query_compressed_disp_byte(int disp, bool is_evex_inst, int vector_len,
 863                                          int cur_tuple_type, int in_size_in_bits, int cur_encoding);
 864 
 865   // Generic instructions
 866   // Does 32bit or 64bit as needed for the platform. In some sense these
 867   // belong in macro assembler but there is no need for both varieties to exist
 868 
 869   void init_attributes(void) {
 870     _legacy_mode_bw = (VM_Version::supports_avx512bw() == false);
 871     _legacy_mode_dq = (VM_Version::supports_avx512dq() == false);
 872     _legacy_mode_vl = (VM_Version::supports_avx512vl() == false);
 873     _legacy_mode_vlbw = (VM_Version::supports_avx512vlbw() == false);
<span class="line-modified"> 874     _is_managed = false;</span>
<span class="line-removed"> 875     _vector_masking = false;</span>
 876     _attributes = NULL;
 877   }
 878 
 879   void set_attributes(InstructionAttr *attributes) { _attributes = attributes; }
 880   void clear_attributes(void) { _attributes = NULL; }
 881 
<span class="line-modified"> 882   void set_managed(void) { _is_managed = true; }</span>
<span class="line-modified"> 883   void clear_managed(void) { _is_managed = false; }</span>
<span class="line-modified"> 884   bool is_managed(void) { return _is_managed; }</span>


 885 
 886   void lea(Register dst, Address src);
 887 
 888   void mov(Register dst, Register src);
 889 











 890   void pusha();
 891   void popa();
 892 
 893   void pushf();
 894   void popf();
 895 
 896   void push(int32_t imm32);
 897 
 898   void push(Register src);
 899 
 900   void pop(Register dst);
 901 
 902   // These are dummies to prevent surprise implicit conversions to Register
 903   void push(void* v);
 904   void pop(void* v);
 905 
 906   // These do register sized moves/scans
 907   void rep_mov();
 908   void rep_stos();
 909   void rep_stosb();
</pre>
<hr />
<pre>
1120 
1121   void cvttpd2dq(XMMRegister dst, XMMRegister src);
1122 
1123   //Abs of packed Integer values
1124   void pabsb(XMMRegister dst, XMMRegister src);
1125   void pabsw(XMMRegister dst, XMMRegister src);
1126   void pabsd(XMMRegister dst, XMMRegister src);
1127   void vpabsb(XMMRegister dst, XMMRegister src, int vector_len);
1128   void vpabsw(XMMRegister dst, XMMRegister src, int vector_len);
1129   void vpabsd(XMMRegister dst, XMMRegister src, int vector_len);
1130   void evpabsq(XMMRegister dst, XMMRegister src, int vector_len);
1131 
1132   // Divide Scalar Double-Precision Floating-Point Values
1133   void divsd(XMMRegister dst, Address src);
1134   void divsd(XMMRegister dst, XMMRegister src);
1135 
1136   // Divide Scalar Single-Precision Floating-Point Values
1137   void divss(XMMRegister dst, Address src);
1138   void divss(XMMRegister dst, XMMRegister src);
1139 
<span class="line-removed">1140   void emms();</span>
1141 
1142 #ifndef _LP64









1143   void fabs();
1144 
1145   void fadd(int i);
1146 
1147   void fadd_d(Address src);
1148   void fadd_s(Address src);
1149 
1150   // &quot;Alternate&quot; versions of x87 instructions place result down in FPU
1151   // stack instead of on TOS
1152 
1153   void fadda(int i); // &quot;alternate&quot; fadd
1154   void faddp(int i = 1);
1155 
1156   void fchs();
1157 
1158   void fcom(int i);
1159 
1160   void fcomp(int i = 1);
1161   void fcomp_d(Address src);
1162   void fcomp_s(Address src);
</pre>
<hr />
<pre>
1488 
1489   // Move lower 64bit to high 64bit in 128bit register
1490   void movlhps(XMMRegister dst, XMMRegister src);
1491 
1492   void movl(Register dst, int32_t imm32);
1493   void movl(Address dst, int32_t imm32);
1494   void movl(Register dst, Register src);
1495   void movl(Register dst, Address src);
1496   void movl(Address dst, Register src);
1497 
1498   // These dummies prevent using movl from converting a zero (like NULL) into Register
1499   // by giving the compiler two choices it can&#39;t resolve
1500 
1501   void movl(Address  dst, void* junk);
1502   void movl(Register dst, void* junk);
1503 
1504 #ifdef _LP64
1505   void movq(Register dst, Register src);
1506   void movq(Register dst, Address src);
1507   void movq(Address  dst, Register src);
<span class="line-removed">1508 #endif</span>
<span class="line-removed">1509 </span>
<span class="line-removed">1510   void movq(Address     dst, MMXRegister src );</span>
<span class="line-removed">1511   void movq(MMXRegister dst, Address src );</span>
1512 
<span class="line-removed">1513 #ifdef _LP64</span>
1514   // These dummies prevent using movq from converting a zero (like NULL) into Register
1515   // by giving the compiler two choices it can&#39;t resolve
1516 
1517   void movq(Address  dst, void* dummy);
1518   void movq(Register dst, void* dummy);
1519 #endif
1520 
1521   // Move Quadword
1522   void movq(Address     dst, XMMRegister src);
1523   void movq(XMMRegister dst, Address src);
1524 
1525   void movsbl(Register dst, Address src);
1526   void movsbl(Register dst, Register src);
1527 
1528 #ifdef _LP64
1529   void movsbq(Register dst, Address src);
1530   void movsbq(Register dst, Register src);
1531 
1532   // Move signed 32bit immediate to 64bit extending sign
1533   void movslq(Address  dst, int32_t imm64);
</pre>
<hr />
<pre>
2254   // They should be called only from corresponding MacroAssembler instructions.
2255   void andpd(XMMRegister dst, Address src);
2256   void andps(XMMRegister dst, Address src);
2257   void xorpd(XMMRegister dst, Address src);
2258   void xorps(XMMRegister dst, Address src);
2259 
2260 };
2261 
2262 // The Intel x86/Amd64 Assembler attributes: All fields enclosed here are to guide encoding level decisions.
2263 // Specific set functions are for specialized use, else defaults or whatever was supplied to object construction
2264 // are applied.
2265 class InstructionAttr {
2266 public:
2267   InstructionAttr(
2268     int vector_len,     // The length of vector to be applied in encoding - for both AVX and EVEX
2269     bool rex_vex_w,     // Width of data: if 32-bits or less, false, else if 64-bit or specially defined, true
2270     bool legacy_mode,   // Details if either this instruction is conditionally encoded to AVX or earlier if true else possibly EVEX
2271     bool no_reg_mask,   // when true, k0 is used when EVEX encoding is chosen, else embedded_opmask_register_specifier is used
2272     bool uses_vl)       // This instruction may have legacy constraints based on vector length for EVEX
2273     :
<span class="line-removed">2274       _avx_vector_len(vector_len),</span>
2275       _rex_vex_w(rex_vex_w),
<span class="line-modified">2276       _rex_vex_w_reverted(false),</span>
<span class="line-removed">2277       _legacy_mode(legacy_mode),</span>
2278       _no_reg_mask(no_reg_mask),
2279       _uses_vl(uses_vl),
<span class="line-modified">2280       _tuple_type(Assembler::EVEX_ETUP),</span>
<span class="line-removed">2281       _input_size_in_bits(Assembler::EVEX_NObit),</span>
2282       _is_evex_instruction(false),
<span class="line-removed">2283       _evex_encoding(0),</span>
2284       _is_clear_context(true),
2285       _is_extended_context(false),




2286       _embedded_opmask_register_specifier(0), // hard code k0
<span class="line-modified">2287       _current_assembler(NULL) {</span>
<span class="line-removed">2288     if (UseAVX &lt; 3) _legacy_mode = true;</span>
<span class="line-removed">2289   }</span>
2290 
2291   ~InstructionAttr() {
2292     if (_current_assembler != NULL) {
2293       _current_assembler-&gt;clear_attributes();
2294     }
2295     _current_assembler = NULL;
2296   }
2297 
2298 private:
<span class="line-removed">2299   int  _avx_vector_len;</span>
2300   bool _rex_vex_w;
<span class="line-removed">2301   bool _rex_vex_w_reverted;</span>
2302   bool _legacy_mode;
2303   bool _no_reg_mask;
2304   bool _uses_vl;
<span class="line-modified">2305   int  _tuple_type;</span>
<span class="line-removed">2306   int  _input_size_in_bits;</span>
2307   bool _is_evex_instruction;
<span class="line-removed">2308   int  _evex_encoding;</span>
2309   bool _is_clear_context;
2310   bool _is_extended_context;




2311   int _embedded_opmask_register_specifier;
2312 
2313   Assembler *_current_assembler;
2314 
2315 public:
2316   // query functions for field accessors
<span class="line-removed">2317   int  get_vector_len(void) const { return _avx_vector_len; }</span>
2318   bool is_rex_vex_w(void) const { return _rex_vex_w; }
<span class="line-removed">2319   bool is_rex_vex_w_reverted(void) { return _rex_vex_w_reverted; }</span>
2320   bool is_legacy_mode(void) const { return _legacy_mode; }
2321   bool is_no_reg_mask(void) const { return _no_reg_mask; }
2322   bool uses_vl(void) const { return _uses_vl; }





2323   int  get_tuple_type(void) const { return _tuple_type; }
2324   int  get_input_size(void) const { return _input_size_in_bits; }
<span class="line-removed">2325   int  is_evex_instruction(void) const { return _is_evex_instruction; }</span>
2326   int  get_evex_encoding(void) const { return _evex_encoding; }
<span class="line-modified">2327   bool is_clear_context(void) const { return _is_clear_context; }</span>
<span class="line-removed">2328   bool is_extended_context(void) const { return _is_extended_context; }</span>
<span class="line-removed">2329   int get_embedded_opmask_register_specifier(void) const { return _embedded_opmask_register_specifier; }</span>
2330 
2331   // Set the vector len manually
2332   void set_vector_len(int vector_len) { _avx_vector_len = vector_len; }
2333 
2334   // Set revert rex_vex_w for avx encoding
2335   void set_rex_vex_w_reverted(void) { _rex_vex_w_reverted = true; }
2336 
2337   // Set rex_vex_w based on state
2338   void set_rex_vex_w(bool state) { _rex_vex_w = state; }
2339 
2340   // Set the instruction to be encoded in AVX mode
2341   void set_is_legacy_mode(void) { _legacy_mode = true; }
2342 
2343   // Set the current instuction to be encoded as an EVEX instuction
2344   void set_is_evex_instruction(void) { _is_evex_instruction = true; }
2345 
2346   // Internal encoding data used in compressed immediate offset programming
2347   void set_evex_encoding(int value) { _evex_encoding = value; }
2348 
2349   // Set the Evex.Z field to be used to clear all non directed XMM/YMM/ZMM components
</pre>
</td>
<td>
<hr />
<pre>
 322 #endif // ASSERT
 323 
 324   // accessors
 325   bool        uses(Register reg) const { return _base == reg || _index == reg; }
 326   Register    base()             const { return _base;  }
 327   Register    index()            const { return _index; }
 328   XMMRegister xmmindex()         const { return _xmmindex; }
 329   ScaleFactor scale()            const { return _scale; }
 330   int         disp()             const { return _disp;  }
 331   bool        isxmmindex()       const { return _isxmmindex; }
 332 
 333   // Convert the raw encoding form into the form expected by the constructor for
 334   // Address.  An index of 4 (rsp) corresponds to having no index, so convert
 335   // that to noreg for the Address constructor.
 336   static Address make_raw(int base, int index, int scale, int disp, relocInfo::relocType disp_reloc);
 337 
 338   static Address make_array(ArrayAddress);
 339 
 340  private:
 341   bool base_needs_rex() const {
<span class="line-modified"> 342     return _base-&gt;is_valid() &amp;&amp; _base-&gt;encoding() &gt;= 8;</span>
 343   }
 344 
 345   bool index_needs_rex() const {
<span class="line-modified"> 346     return _index-&gt;is_valid() &amp;&amp;_index-&gt;encoding() &gt;= 8;</span>
 347   }
 348 
 349   bool xmmindex_needs_rex() const {
<span class="line-modified"> 350     return _xmmindex-&gt;is_valid() &amp;&amp; _xmmindex-&gt;encoding() &gt;= 8;</span>
 351   }
 352 
 353   relocInfo::relocType reloc() const { return _rspec.type(); }
 354 
 355   friend class Assembler;
 356   friend class MacroAssembler;
 357   friend class LIR_Assembler; // base/index/scale/disp
 358 };
 359 
 360 //
 361 // AddressLiteral has been split out from Address because operands of this type
 362 // need to be treated specially on 32bit vs. 64bit platforms. By splitting it out
 363 // the few instructions that need to deal with address literals are unique and the
 364 // MacroAssembler does not have to implement every instruction in the Assembler
 365 // in order to search for address literals that may need special handling depending
 366 // on the instruction and the platform. As small step on the way to merging i486/amd64
 367 // directories.
 368 //
 369 class AddressLiteral {
 370   friend class ArrayAddress;
</pre>
<hr />
<pre>
 642   // We could use a &quot;safe enough&quot; estimate (15), but just default to
 643   // instruction length guess from above.
 644   static unsigned int instr_maxlen() { return 4; }
 645 
 646   // NOTE: The general philopsophy of the declarations here is that 64bit versions
 647   // of instructions are freely declared without the need for wrapping them an ifdef.
 648   // (Some dangerous instructions are ifdef&#39;s out of inappropriate jvm&#39;s.)
 649   // In the .cpp file the implementations are wrapped so that they are dropped out
 650   // of the resulting jvm. This is done mostly to keep the footprint of MINIMAL
 651   // to the size it was prior to merging up the 32bit and 64bit assemblers.
 652   //
 653   // This does mean you&#39;ll get a linker/runtime error if you use a 64bit only instruction
 654   // in a 32bit vm. This is somewhat unfortunate but keeps the ifdef noise down.
 655 
 656 private:
 657 
 658   bool _legacy_mode_bw;
 659   bool _legacy_mode_dq;
 660   bool _legacy_mode_vl;
 661   bool _legacy_mode_vlbw;
<span class="line-modified"> 662   NOT_LP64(bool _is_managed;)</span>

 663 
 664   class InstructionAttr *_attributes;
 665 
 666   // 64bit prefixes
<span class="line-modified"> 667   void prefix(Register reg);</span>
<span class="line-modified"> 668   void prefix(Register dst, Register src, Prefix p);</span>
<span class="line-added"> 669   void prefix(Register dst, Address adr, Prefix p);</span>
 670 
<span class="line-added"> 671   void prefix(Address adr);</span>
<span class="line-added"> 672   void prefix(Address adr, Register reg,  bool byteinst = false);</span>
<span class="line-added"> 673   void prefix(Address adr, XMMRegister reg);</span>
<span class="line-added"> 674 </span>
<span class="line-added"> 675   int prefix_and_encode(int reg_enc, bool byteinst = false);</span>
 676   int prefix_and_encode(int dst_enc, int src_enc) {
 677     return prefix_and_encode(dst_enc, false, src_enc, false);
 678   }
 679   int prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte);

 680 
<span class="line-modified"> 681   // Some prefixq variants always emit exactly one prefix byte, so besides a</span>
<span class="line-modified"> 682   // prefix-emitting method we provide a method to get the prefix byte to emit,</span>
<span class="line-modified"> 683   // which can then be folded into a byte stream.</span>
<span class="line-modified"> 684   int8_t get_prefixq(Address adr);</span>
<span class="line-modified"> 685   int8_t get_prefixq(Address adr, Register reg);</span>
 686 
<span class="line-modified"> 687   void prefixq(Address adr);</span>

 688   void prefixq(Address adr, Register reg);
 689   void prefixq(Address adr, XMMRegister reg);
 690 
<span class="line-modified"> 691   int prefixq_and_encode(int reg_enc);</span>
<span class="line-added"> 692   int prefixq_and_encode(int dst_enc, int src_enc);</span>
 693 
 694   void rex_prefix(Address adr, XMMRegister xreg,
 695                   VexSimdPrefix pre, VexOpcode opc, bool rex_w);
 696   int  rex_prefix_and_encode(int dst_enc, int src_enc,
 697                              VexSimdPrefix pre, VexOpcode opc, bool rex_w);
 698 
 699   void vex_prefix(bool vex_r, bool vex_b, bool vex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc);
 700 
 701   void evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_v,
 702                    int nds_enc, VexSimdPrefix pre, VexOpcode opc);
 703 
 704   void vex_prefix(Address adr, int nds_enc, int xreg_enc,
 705                   VexSimdPrefix pre, VexOpcode opc,
 706                   InstructionAttr *attributes);
 707 
 708   int  vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc,
 709                              VexSimdPrefix pre, VexOpcode opc,
 710                              InstructionAttr *attributes);
 711 
 712   void simd_prefix(XMMRegister xreg, XMMRegister nds, Address adr, VexSimdPrefix pre,
 713                    VexOpcode opc, InstructionAttr *attributes);
 714 
 715   int simd_prefix_and_encode(XMMRegister dst, XMMRegister nds, XMMRegister src, VexSimdPrefix pre,
 716                              VexOpcode opc, InstructionAttr *attributes);
 717 
 718   // Helper functions for groups of instructions
 719   void emit_arith_b(int op1, int op2, Register dst, int imm8);
 720 
 721   void emit_arith(int op1, int op2, Register dst, int32_t imm32);
 722   // Force generation of a 4 byte immediate value even if it fits into 8bit
 723   void emit_arith_imm32(int op1, int op2, Register dst, int32_t imm32);
 724   void emit_arith(int op1, int op2, Register dst, Register src);
 725 
 726   bool emit_compressed_disp_byte(int &amp;disp);
 727 
<span class="line-added"> 728   void emit_modrm(int mod, int dst_enc, int src_enc);</span>
<span class="line-added"> 729   void emit_modrm_disp8(int mod, int dst_enc, int src_enc,</span>
<span class="line-added"> 730                         int disp);</span>
<span class="line-added"> 731   void emit_modrm_sib(int mod, int dst_enc, int src_enc,</span>
<span class="line-added"> 732                       Address::ScaleFactor scale, int index_enc, int base_enc);</span>
<span class="line-added"> 733   void emit_modrm_sib_disp8(int mod, int dst_enc, int src_enc,</span>
<span class="line-added"> 734                             Address::ScaleFactor scale, int index_enc, int base_enc,</span>
<span class="line-added"> 735                             int disp);</span>
<span class="line-added"> 736 </span>
<span class="line-added"> 737   void emit_operand_helper(int reg_enc,</span>
<span class="line-added"> 738                            int base_enc, int index_enc, Address::ScaleFactor scale,</span>
<span class="line-added"> 739                            int disp,</span>
<span class="line-added"> 740                            RelocationHolder const&amp; rspec,</span>
<span class="line-added"> 741                            int rip_relative_correction = 0);</span>
<span class="line-added"> 742 </span>
 743   void emit_operand(Register reg,
 744                     Register base, Register index, Address::ScaleFactor scale,
 745                     int disp,
 746                     RelocationHolder const&amp; rspec,
 747                     int rip_relative_correction = 0);
 748 
<span class="line-modified"> 749   void emit_operand(Register reg,</span>
<span class="line-modified"> 750                     Register base, XMMRegister index, Address::ScaleFactor scale,</span>
<span class="line-modified"> 751                     int disp,</span>
<span class="line-added"> 752                     RelocationHolder const&amp; rspec);</span>
 753 
<span class="line-modified"> 754   void emit_operand(XMMRegister xreg,</span>
<span class="line-added"> 755                     Register base, XMMRegister xindex, Address::ScaleFactor scale,</span>
<span class="line-added"> 756                     int disp,</span>
<span class="line-added"> 757                     RelocationHolder const&amp; rspec);</span>
 758 
<span class="line-modified"> 759   void emit_operand(Register reg, Address adr,</span>
<span class="line-modified"> 760                     int rip_relative_correction = 0);</span>
 761 
 762   void emit_operand(XMMRegister reg,
 763                     Register base, Register index, Address::ScaleFactor scale,
 764                     int disp,
 765                     RelocationHolder const&amp; rspec);
 766 
 767   void emit_operand(XMMRegister reg, Address adr);
 768 






 769   // Immediate-to-memory forms
 770   void emit_arith_operand(int op1, Register rm, Address adr, int32_t imm32);
 771 



 772  protected:
 773   #ifdef ASSERT
 774   void check_relocation(RelocationHolder const&amp; rspec, int format);
 775   #endif
 776 
 777   void emit_data(jint data, relocInfo::relocType    rtype, int format);
 778   void emit_data(jint data, RelocationHolder const&amp; rspec, int format);
 779   void emit_data64(jlong data, relocInfo::relocType rtype, int format = 0);
 780   void emit_data64(jlong data, RelocationHolder const&amp; rspec, int format = 0);
 781 
 782   bool reachable(AddressLiteral adr) NOT_LP64({ return true;});
 783 
 784   // These are all easily abused and hence protected
 785 
 786   // 32BIT ONLY SECTION
 787 #ifndef _LP64
 788   // Make these disappear in 64bit mode since they would never be correct
 789   void cmp_literal32(Register src1, int32_t imm32, RelocationHolder const&amp; rspec);   // 32BIT ONLY
 790   void cmp_literal32(Address src1, int32_t imm32, RelocationHolder const&amp; rspec);    // 32BIT ONLY
 791 
</pre>
<hr />
<pre>
 868   }
 869 
 870   // Decoding
 871   static address locate_operand(address inst, WhichOperand which);
 872   static address locate_next_instruction(address inst);
 873 
 874   // Utilities
 875   static bool is_polling_page_far() NOT_LP64({ return false;});
 876   static bool query_compressed_disp_byte(int disp, bool is_evex_inst, int vector_len,
 877                                          int cur_tuple_type, int in_size_in_bits, int cur_encoding);
 878 
 879   // Generic instructions
 880   // Does 32bit or 64bit as needed for the platform. In some sense these
 881   // belong in macro assembler but there is no need for both varieties to exist
 882 
 883   void init_attributes(void) {
 884     _legacy_mode_bw = (VM_Version::supports_avx512bw() == false);
 885     _legacy_mode_dq = (VM_Version::supports_avx512dq() == false);
 886     _legacy_mode_vl = (VM_Version::supports_avx512vl() == false);
 887     _legacy_mode_vlbw = (VM_Version::supports_avx512vlbw() == false);
<span class="line-modified"> 888     NOT_LP64(_is_managed = false;)</span>

 889     _attributes = NULL;
 890   }
 891 
 892   void set_attributes(InstructionAttr *attributes) { _attributes = attributes; }
 893   void clear_attributes(void) { _attributes = NULL; }
 894 
<span class="line-modified"> 895   void set_managed(void) { NOT_LP64(_is_managed = true;) }</span>
<span class="line-modified"> 896   void clear_managed(void) { NOT_LP64(_is_managed = false;) }</span>
<span class="line-modified"> 897   bool is_managed(void) {</span>
<span class="line-added"> 898     NOT_LP64(return _is_managed;)</span>
<span class="line-added"> 899     LP64_ONLY(return false;) }</span>
 900 
 901   void lea(Register dst, Address src);
 902 
 903   void mov(Register dst, Register src);
 904 
<span class="line-added"> 905 #ifdef _LP64</span>
<span class="line-added"> 906   // support caching the result of some routines</span>
<span class="line-added"> 907 </span>
<span class="line-added"> 908   // must be called before pusha(), popa(), vzeroupper() - checked with asserts</span>
<span class="line-added"> 909   static void precompute_instructions();</span>
<span class="line-added"> 910 </span>
<span class="line-added"> 911   void pusha_uncached();</span>
<span class="line-added"> 912   void popa_uncached();</span>
<span class="line-added"> 913 #endif</span>
<span class="line-added"> 914   void vzeroupper_uncached();</span>
<span class="line-added"> 915 </span>
 916   void pusha();
 917   void popa();
 918 
 919   void pushf();
 920   void popf();
 921 
 922   void push(int32_t imm32);
 923 
 924   void push(Register src);
 925 
 926   void pop(Register dst);
 927 
 928   // These are dummies to prevent surprise implicit conversions to Register
 929   void push(void* v);
 930   void pop(void* v);
 931 
 932   // These do register sized moves/scans
 933   void rep_mov();
 934   void rep_stos();
 935   void rep_stosb();
</pre>
<hr />
<pre>
1146 
1147   void cvttpd2dq(XMMRegister dst, XMMRegister src);
1148 
1149   //Abs of packed Integer values
1150   void pabsb(XMMRegister dst, XMMRegister src);
1151   void pabsw(XMMRegister dst, XMMRegister src);
1152   void pabsd(XMMRegister dst, XMMRegister src);
1153   void vpabsb(XMMRegister dst, XMMRegister src, int vector_len);
1154   void vpabsw(XMMRegister dst, XMMRegister src, int vector_len);
1155   void vpabsd(XMMRegister dst, XMMRegister src, int vector_len);
1156   void evpabsq(XMMRegister dst, XMMRegister src, int vector_len);
1157 
1158   // Divide Scalar Double-Precision Floating-Point Values
1159   void divsd(XMMRegister dst, Address src);
1160   void divsd(XMMRegister dst, XMMRegister src);
1161 
1162   // Divide Scalar Single-Precision Floating-Point Values
1163   void divss(XMMRegister dst, Address src);
1164   void divss(XMMRegister dst, XMMRegister src);
1165 

1166 
1167 #ifndef _LP64
<span class="line-added">1168  private:</span>
<span class="line-added">1169   // operands that only take the original 32bit registers</span>
<span class="line-added">1170   void emit_operand32(Register reg, Address adr);</span>
<span class="line-added">1171 </span>
<span class="line-added">1172   void emit_farith(int b1, int b2, int i);</span>
<span class="line-added">1173 </span>
<span class="line-added">1174  public:</span>
<span class="line-added">1175   void emms();</span>
<span class="line-added">1176 </span>
1177   void fabs();
1178 
1179   void fadd(int i);
1180 
1181   void fadd_d(Address src);
1182   void fadd_s(Address src);
1183 
1184   // &quot;Alternate&quot; versions of x87 instructions place result down in FPU
1185   // stack instead of on TOS
1186 
1187   void fadda(int i); // &quot;alternate&quot; fadd
1188   void faddp(int i = 1);
1189 
1190   void fchs();
1191 
1192   void fcom(int i);
1193 
1194   void fcomp(int i = 1);
1195   void fcomp_d(Address src);
1196   void fcomp_s(Address src);
</pre>
<hr />
<pre>
1522 
1523   // Move lower 64bit to high 64bit in 128bit register
1524   void movlhps(XMMRegister dst, XMMRegister src);
1525 
1526   void movl(Register dst, int32_t imm32);
1527   void movl(Address dst, int32_t imm32);
1528   void movl(Register dst, Register src);
1529   void movl(Register dst, Address src);
1530   void movl(Address dst, Register src);
1531 
1532   // These dummies prevent using movl from converting a zero (like NULL) into Register
1533   // by giving the compiler two choices it can&#39;t resolve
1534 
1535   void movl(Address  dst, void* junk);
1536   void movl(Register dst, void* junk);
1537 
1538 #ifdef _LP64
1539   void movq(Register dst, Register src);
1540   void movq(Register dst, Address src);
1541   void movq(Address  dst, Register src);




1542 

1543   // These dummies prevent using movq from converting a zero (like NULL) into Register
1544   // by giving the compiler two choices it can&#39;t resolve
1545 
1546   void movq(Address  dst, void* dummy);
1547   void movq(Register dst, void* dummy);
1548 #endif
1549 
1550   // Move Quadword
1551   void movq(Address     dst, XMMRegister src);
1552   void movq(XMMRegister dst, Address src);
1553 
1554   void movsbl(Register dst, Address src);
1555   void movsbl(Register dst, Register src);
1556 
1557 #ifdef _LP64
1558   void movsbq(Register dst, Address src);
1559   void movsbq(Register dst, Register src);
1560 
1561   // Move signed 32bit immediate to 64bit extending sign
1562   void movslq(Address  dst, int32_t imm64);
</pre>
<hr />
<pre>
2283   // They should be called only from corresponding MacroAssembler instructions.
2284   void andpd(XMMRegister dst, Address src);
2285   void andps(XMMRegister dst, Address src);
2286   void xorpd(XMMRegister dst, Address src);
2287   void xorps(XMMRegister dst, Address src);
2288 
2289 };
2290 
2291 // The Intel x86/Amd64 Assembler attributes: All fields enclosed here are to guide encoding level decisions.
2292 // Specific set functions are for specialized use, else defaults or whatever was supplied to object construction
2293 // are applied.
2294 class InstructionAttr {
2295 public:
2296   InstructionAttr(
2297     int vector_len,     // The length of vector to be applied in encoding - for both AVX and EVEX
2298     bool rex_vex_w,     // Width of data: if 32-bits or less, false, else if 64-bit or specially defined, true
2299     bool legacy_mode,   // Details if either this instruction is conditionally encoded to AVX or earlier if true else possibly EVEX
2300     bool no_reg_mask,   // when true, k0 is used when EVEX encoding is chosen, else embedded_opmask_register_specifier is used
2301     bool uses_vl)       // This instruction may have legacy constraints based on vector length for EVEX
2302     :

2303       _rex_vex_w(rex_vex_w),
<span class="line-modified">2304       _legacy_mode(legacy_mode || UseAVX &lt; 3),</span>

2305       _no_reg_mask(no_reg_mask),
2306       _uses_vl(uses_vl),
<span class="line-modified">2307       _rex_vex_w_reverted(false),</span>

2308       _is_evex_instruction(false),

2309       _is_clear_context(true),
2310       _is_extended_context(false),
<span class="line-added">2311       _avx_vector_len(vector_len),</span>
<span class="line-added">2312       _tuple_type(Assembler::EVEX_ETUP),</span>
<span class="line-added">2313       _input_size_in_bits(Assembler::EVEX_NObit),</span>
<span class="line-added">2314       _evex_encoding(0),</span>
2315       _embedded_opmask_register_specifier(0), // hard code k0
<span class="line-modified">2316       _current_assembler(NULL) { }</span>


2317 
2318   ~InstructionAttr() {
2319     if (_current_assembler != NULL) {
2320       _current_assembler-&gt;clear_attributes();
2321     }
2322     _current_assembler = NULL;
2323   }
2324 
2325 private:

2326   bool _rex_vex_w;

2327   bool _legacy_mode;
2328   bool _no_reg_mask;
2329   bool _uses_vl;
<span class="line-modified">2330   bool _rex_vex_w_reverted;</span>

2331   bool _is_evex_instruction;

2332   bool _is_clear_context;
2333   bool _is_extended_context;
<span class="line-added">2334   int  _avx_vector_len;</span>
<span class="line-added">2335   int  _tuple_type;</span>
<span class="line-added">2336   int  _input_size_in_bits;</span>
<span class="line-added">2337   int  _evex_encoding;</span>
2338   int _embedded_opmask_register_specifier;
2339 
2340   Assembler *_current_assembler;
2341 
2342 public:
2343   // query functions for field accessors

2344   bool is_rex_vex_w(void) const { return _rex_vex_w; }

2345   bool is_legacy_mode(void) const { return _legacy_mode; }
2346   bool is_no_reg_mask(void) const { return _no_reg_mask; }
2347   bool uses_vl(void) const { return _uses_vl; }
<span class="line-added">2348   bool is_rex_vex_w_reverted(void) { return _rex_vex_w_reverted; }</span>
<span class="line-added">2349   bool is_evex_instruction(void) const { return _is_evex_instruction; }</span>
<span class="line-added">2350   bool is_clear_context(void) const { return _is_clear_context; }</span>
<span class="line-added">2351   bool is_extended_context(void) const { return _is_extended_context; }</span>
<span class="line-added">2352   int  get_vector_len(void) const { return _avx_vector_len; }</span>
2353   int  get_tuple_type(void) const { return _tuple_type; }
2354   int  get_input_size(void) const { return _input_size_in_bits; }

2355   int  get_evex_encoding(void) const { return _evex_encoding; }
<span class="line-modified">2356   int  get_embedded_opmask_register_specifier(void) const { return _embedded_opmask_register_specifier; }</span>


2357 
2358   // Set the vector len manually
2359   void set_vector_len(int vector_len) { _avx_vector_len = vector_len; }
2360 
2361   // Set revert rex_vex_w for avx encoding
2362   void set_rex_vex_w_reverted(void) { _rex_vex_w_reverted = true; }
2363 
2364   // Set rex_vex_w based on state
2365   void set_rex_vex_w(bool state) { _rex_vex_w = state; }
2366 
2367   // Set the instruction to be encoded in AVX mode
2368   void set_is_legacy_mode(void) { _legacy_mode = true; }
2369 
2370   // Set the current instuction to be encoded as an EVEX instuction
2371   void set_is_evex_instruction(void) { _is_evex_instruction = true; }
2372 
2373   // Internal encoding data used in compressed immediate offset programming
2374   void set_evex_encoding(int value) { _evex_encoding = value; }
2375 
2376   // Set the Evex.Z field to be used to clear all non directed XMM/YMM/ZMM components
</pre>
</td>
</tr>
</table>
<center><a href="assembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRGenerator_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="x86_32.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../os/aix/os_aix.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/x86_64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  768     __ movdl(dst, rt);
  769   }
  770   else {
  771     __ mov64(rt, 0x7ff8000000000000L); // Double.NaN
  772     __ movdq(dst, rt);
  773   }
  774   __ jmp(done);
  775 
  776   __ bind(below);
  777   if (single)
  778     __ movflt(dst, min ? a : b);
  779   else
  780     __ movdbl(dst, min ? a : b);
  781 
  782   __ bind(done);
  783 }
  784 
  785 //=============================================================================
  786 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  787 
<span class="line-modified">  788 int Compile::ConstantTable::calculate_table_base_offset() const {</span>
  789   return 0;  // absolute addressing, no offset
  790 }
  791 
  792 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  793 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  794   ShouldNotReachHere();
  795 }
  796 
  797 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  798   // Empty encoding
  799 }
  800 
  801 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  802   return 0;
  803 }
  804 
  805 #ifndef PRODUCT
  806 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  807   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  808 }
  809 #endif
  810 
  811 
  812 //=============================================================================
  813 #ifndef PRODUCT
  814 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  815   Compile* C = ra_-&gt;C;
  816 
<span class="line-modified">  817   int framesize = C-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  818   int bangsize = C-&gt;bang_size_in_bytes();</span>
  819   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  820   // Remove wordSize for return addr which is already pushed.
  821   framesize -= wordSize;
  822 
<span class="line-modified">  823   if (C-&gt;need_stack_bang(bangsize)) {</span>
  824     framesize -= wordSize;
  825     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  826     st-&gt;print(&quot;\n\t&quot;);
  827     st-&gt;print(&quot;pushq   rbp\t# Save rbp&quot;);
  828     if (PreserveFramePointer) {
  829         st-&gt;print(&quot;\n\t&quot;);
  830         st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  831     }
  832     if (framesize) {
  833       st-&gt;print(&quot;\n\t&quot;);
  834       st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  835     }
  836   } else {
  837     st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  838     st-&gt;print(&quot;\n\t&quot;);
  839     framesize -= wordSize;
  840     st-&gt;print(&quot;movq    [rsp + #%d], rbp\t# Save rbp&quot;,framesize);
  841     if (PreserveFramePointer) {
  842       st-&gt;print(&quot;\n\t&quot;);
  843       st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
</pre>
<hr />
<pre>
  880 
  881     Label L_skip_barrier;
  882     Register klass = rscratch1;
  883 
  884     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  885     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  886 
  887     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  888 
  889     __ bind(L_skip_barrier);
  890   }
  891 
  892   __ verified_entry(C);
  893   __ bind(*_verified_entry);
  894 
  895   if (C-&gt;stub_function() == NULL) {
  896     BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
  897     bs-&gt;nmethod_entry_barrier(&amp;_masm);
  898   }
  899 
<span class="line-modified">  900   C-&gt;set_frame_complete(cbuf.insts_size());</span>
  901 
  902   if (C-&gt;has_mach_constant_base_node()) {
  903     // NOTE: We set the table base offset here because users might be
  904     // emitted before MachConstantBaseNode.
<span class="line-modified">  905     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
  906     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  907   }
  908 }
  909 
  910 int MachPrologNode::reloc() const
  911 {
  912   return 0; // a large enough number
  913 }
  914 
  915 //=============================================================================
  916 #ifndef PRODUCT
  917 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  918 {
  919   Compile* C = ra_-&gt;C;
  920   if (generate_vzeroupper(C)) {
  921     st-&gt;print(&quot;vzeroupper&quot;);
  922     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  923   }
  924 
<span class="line-modified">  925   int framesize = C-&gt;frame_size_in_bytes();</span>
  926   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  927   // Remove word for return adr already pushed
  928   // and RBP
  929   framesize -= 2*wordSize;
  930 
  931   if (framesize) {
  932     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  933     st-&gt;print(&quot;\t&quot;);
  934   }
  935 
  936   st-&gt;print_cr(&quot;popq    rbp&quot;);
  937   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  938     st-&gt;print(&quot;\t&quot;);
  939     if (SafepointMechanism::uses_thread_local_poll()) {
  940       st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  941                    &quot;testl   rax, [rscratch1]\t&quot;
  942                    &quot;# Safepoint: poll for GC&quot;);
  943     } else if (Assembler::is_polling_page_far()) {
  944       st-&gt;print_cr(&quot;movq    rscratch1, #polling_page_address\n\t&quot;
  945                    &quot;testl   rax, [rscratch1]\t&quot;
</pre>
<hr />
<pre>
  947     } else {
  948       st-&gt;print_cr(&quot;testl   rax, [rip + #offset_to_poll_page]\t&quot;
  949                    &quot;# Safepoint: poll for GC&quot;);
  950     }
  951   }
  952 }
  953 #endif
  954 
  955 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  956 {
  957   Compile* C = ra_-&gt;C;
  958   MacroAssembler _masm(&amp;cbuf);
  959 
  960   if (generate_vzeroupper(C)) {
  961     // Clear upper bits of YMM registers when current compiled code uses
  962     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  963     __ vzeroupper();
  964   }
  965 
  966   // Subtract two words to account for return address and rbp
<span class="line-modified">  967   int initial_framesize = C-&gt;frame_size_in_bytes() - 2*wordSize;</span>
<span class="line-modified">  968   __ remove_frame(initial_framesize, C-&gt;needs_stack_repair(), C-&gt;sp_inc_offset());</span>
  969 
  970   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  971     __ reserved_stack_check();
  972   }
  973 
  974   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  975     MacroAssembler _masm(&amp;cbuf);
  976     if (SafepointMechanism::uses_thread_local_poll()) {
  977       __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  978       __ relocate(relocInfo::poll_return_type);
  979       __ testl(rax, Address(rscratch1, 0));
  980     } else {
  981       AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
  982       if (Assembler::is_polling_page_far()) {
  983         __ lea(rscratch1, polling_page);
  984         __ relocate(relocInfo::poll_return_type);
  985         __ testl(rax, Address(rscratch1, 0));
  986       } else {
  987         __ testl(rax, polling_page);
  988       }
</pre>
<hr />
<pre>
 3095   match(ConL);
 3096 
 3097   op_cost(10);
 3098   format %{ %}
 3099   interface(CONST_INTER);
 3100 %}
 3101 
 3102 // Long Immediate 32-bit signed
 3103 operand immL32()
 3104 %{
 3105   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
 3106   match(ConL);
 3107 
 3108   op_cost(15);
 3109   format %{ %}
 3110   interface(CONST_INTER);
 3111 %}
 3112 
 3113 operand immL_Pow2()
 3114 %{
<span class="line-modified"> 3115   predicate(is_power_of_2(n-&gt;get_long()));</span>
 3116   match(ConL);
 3117 
 3118   op_cost(15);
 3119   format %{ %}
 3120   interface(CONST_INTER);
 3121 %}
 3122 
 3123 operand immL_NotPow2()
 3124 %{
<span class="line-modified"> 3125   predicate(is_power_of_2(~n-&gt;get_long()));</span>
 3126   match(ConL);
 3127 
 3128   op_cost(15);
 3129   format %{ %}
 3130   interface(CONST_INTER);
 3131 %}
 3132 
 3133 // Long Immediate zero
 3134 operand immL0()
 3135 %{
 3136   predicate(n-&gt;get_long() == 0L);
 3137   match(ConL);
 3138 
 3139   op_cost(10);
 3140   format %{ %}
 3141   interface(CONST_INTER);
 3142 %}
 3143 
 3144 // Constant for increment
 3145 operand immL1()
</pre>
<hr />
<pre>
10060   ins_cost(125);
10061   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10062   opcode(0x81, 0x1); /* Opcode 81 /1 id */
10063   ins_encode(REX_mem_wide(dst), OpcSE(src),
10064              RM_opc_mem(secondary, dst), Con8or32(src));
10065   ins_pipe(ialu_mem_imm);
10066 %}
10067 
10068 instruct btsL_mem_imm(memory dst, immL_Pow2 con, rFlagsReg cr)
10069 %{
10070   // con should be a pure 64-bit power of 2 immediate
10071   // because AND/OR works well enough for 8/32-bit values.
10072   predicate(log2_long(n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 31);
10073 
10074   match(Set dst (StoreL dst (OrL (LoadL dst) con)));
10075   effect(KILL cr);
10076 
10077   ins_cost(125);
10078   format %{ &quot;btsq    $dst, log2($con)\t# long&quot; %}
10079   ins_encode %{
<span class="line-modified">10080     __ btsq($dst$$Address, log2_long($con$$constant));</span>
10081   %}
10082   ins_pipe(ialu_mem_imm);
10083 %}
10084 
10085 // Xor Instructions
10086 // Xor Register with Register
10087 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
10088 %{
10089   match(Set dst (XorL dst src));
10090   effect(KILL cr);
10091 
10092   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10093   opcode(0x33);
10094   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10095   ins_pipe(ialu_reg_reg);
10096 %}
10097 
10098 // Xor Register with Immediate -1
10099 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
10100   match(Set dst (XorL dst imm));
</pre>
</td>
<td>
<hr />
<pre>
  768     __ movdl(dst, rt);
  769   }
  770   else {
  771     __ mov64(rt, 0x7ff8000000000000L); // Double.NaN
  772     __ movdq(dst, rt);
  773   }
  774   __ jmp(done);
  775 
  776   __ bind(below);
  777   if (single)
  778     __ movflt(dst, min ? a : b);
  779   else
  780     __ movdbl(dst, min ? a : b);
  781 
  782   __ bind(done);
  783 }
  784 
  785 //=============================================================================
  786 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  787 
<span class="line-modified">  788 int ConstantTable::calculate_table_base_offset() const {</span>
  789   return 0;  // absolute addressing, no offset
  790 }
  791 
  792 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  793 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  794   ShouldNotReachHere();
  795 }
  796 
  797 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  798   // Empty encoding
  799 }
  800 
  801 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  802   return 0;
  803 }
  804 
  805 #ifndef PRODUCT
  806 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  807   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  808 }
  809 #endif
  810 
  811 
  812 //=============================================================================
  813 #ifndef PRODUCT
  814 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  815   Compile* C = ra_-&gt;C;
  816 
<span class="line-modified">  817   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  818   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  819   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  820   // Remove wordSize for return addr which is already pushed.
  821   framesize -= wordSize;
  822 
<span class="line-modified">  823   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {</span>
  824     framesize -= wordSize;
  825     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  826     st-&gt;print(&quot;\n\t&quot;);
  827     st-&gt;print(&quot;pushq   rbp\t# Save rbp&quot;);
  828     if (PreserveFramePointer) {
  829         st-&gt;print(&quot;\n\t&quot;);
  830         st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  831     }
  832     if (framesize) {
  833       st-&gt;print(&quot;\n\t&quot;);
  834       st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  835     }
  836   } else {
  837     st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  838     st-&gt;print(&quot;\n\t&quot;);
  839     framesize -= wordSize;
  840     st-&gt;print(&quot;movq    [rsp + #%d], rbp\t# Save rbp&quot;,framesize);
  841     if (PreserveFramePointer) {
  842       st-&gt;print(&quot;\n\t&quot;);
  843       st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
</pre>
<hr />
<pre>
  880 
  881     Label L_skip_barrier;
  882     Register klass = rscratch1;
  883 
  884     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  885     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  886 
  887     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  888 
  889     __ bind(L_skip_barrier);
  890   }
  891 
  892   __ verified_entry(C);
  893   __ bind(*_verified_entry);
  894 
  895   if (C-&gt;stub_function() == NULL) {
  896     BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
  897     bs-&gt;nmethod_entry_barrier(&amp;_masm);
  898   }
  899 
<span class="line-modified">  900   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());</span>
  901 
  902   if (C-&gt;has_mach_constant_base_node()) {
  903     // NOTE: We set the table base offset here because users might be
  904     // emitted before MachConstantBaseNode.
<span class="line-modified">  905     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
  906     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  907   }
  908 }
  909 
  910 int MachPrologNode::reloc() const
  911 {
  912   return 0; // a large enough number
  913 }
  914 
  915 //=============================================================================
  916 #ifndef PRODUCT
  917 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  918 {
  919   Compile* C = ra_-&gt;C;
  920   if (generate_vzeroupper(C)) {
  921     st-&gt;print(&quot;vzeroupper&quot;);
  922     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  923   }
  924 
<span class="line-modified">  925   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
  926   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  927   // Remove word for return adr already pushed
  928   // and RBP
  929   framesize -= 2*wordSize;
  930 
  931   if (framesize) {
  932     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  933     st-&gt;print(&quot;\t&quot;);
  934   }
  935 
  936   st-&gt;print_cr(&quot;popq    rbp&quot;);
  937   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  938     st-&gt;print(&quot;\t&quot;);
  939     if (SafepointMechanism::uses_thread_local_poll()) {
  940       st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  941                    &quot;testl   rax, [rscratch1]\t&quot;
  942                    &quot;# Safepoint: poll for GC&quot;);
  943     } else if (Assembler::is_polling_page_far()) {
  944       st-&gt;print_cr(&quot;movq    rscratch1, #polling_page_address\n\t&quot;
  945                    &quot;testl   rax, [rscratch1]\t&quot;
</pre>
<hr />
<pre>
  947     } else {
  948       st-&gt;print_cr(&quot;testl   rax, [rip + #offset_to_poll_page]\t&quot;
  949                    &quot;# Safepoint: poll for GC&quot;);
  950     }
  951   }
  952 }
  953 #endif
  954 
  955 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  956 {
  957   Compile* C = ra_-&gt;C;
  958   MacroAssembler _masm(&amp;cbuf);
  959 
  960   if (generate_vzeroupper(C)) {
  961     // Clear upper bits of YMM registers when current compiled code uses
  962     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  963     __ vzeroupper();
  964   }
  965 
  966   // Subtract two words to account for return address and rbp
<span class="line-modified">  967   int initial_framesize = C-&gt;output()-&gt;frame_size_in_bytes() - 2*wordSize;</span>
<span class="line-modified">  968   __ remove_frame(initial_framesize, C-&gt;needs_stack_repair(), C-&gt;output()-&gt;sp_inc_offset());</span>
  969 
  970   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  971     __ reserved_stack_check();
  972   }
  973 
  974   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  975     MacroAssembler _masm(&amp;cbuf);
  976     if (SafepointMechanism::uses_thread_local_poll()) {
  977       __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  978       __ relocate(relocInfo::poll_return_type);
  979       __ testl(rax, Address(rscratch1, 0));
  980     } else {
  981       AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
  982       if (Assembler::is_polling_page_far()) {
  983         __ lea(rscratch1, polling_page);
  984         __ relocate(relocInfo::poll_return_type);
  985         __ testl(rax, Address(rscratch1, 0));
  986       } else {
  987         __ testl(rax, polling_page);
  988       }
</pre>
<hr />
<pre>
 3095   match(ConL);
 3096 
 3097   op_cost(10);
 3098   format %{ %}
 3099   interface(CONST_INTER);
 3100 %}
 3101 
 3102 // Long Immediate 32-bit signed
 3103 operand immL32()
 3104 %{
 3105   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
 3106   match(ConL);
 3107 
 3108   op_cost(15);
 3109   format %{ %}
 3110   interface(CONST_INTER);
 3111 %}
 3112 
 3113 operand immL_Pow2()
 3114 %{
<span class="line-modified"> 3115   predicate(is_power_of_2((julong)n-&gt;get_long()));</span>
 3116   match(ConL);
 3117 
 3118   op_cost(15);
 3119   format %{ %}
 3120   interface(CONST_INTER);
 3121 %}
 3122 
 3123 operand immL_NotPow2()
 3124 %{
<span class="line-modified"> 3125   predicate(is_power_of_2((julong)~n-&gt;get_long()));</span>
 3126   match(ConL);
 3127 
 3128   op_cost(15);
 3129   format %{ %}
 3130   interface(CONST_INTER);
 3131 %}
 3132 
 3133 // Long Immediate zero
 3134 operand immL0()
 3135 %{
 3136   predicate(n-&gt;get_long() == 0L);
 3137   match(ConL);
 3138 
 3139   op_cost(10);
 3140   format %{ %}
 3141   interface(CONST_INTER);
 3142 %}
 3143 
 3144 // Constant for increment
 3145 operand immL1()
</pre>
<hr />
<pre>
10060   ins_cost(125);
10061   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10062   opcode(0x81, 0x1); /* Opcode 81 /1 id */
10063   ins_encode(REX_mem_wide(dst), OpcSE(src),
10064              RM_opc_mem(secondary, dst), Con8or32(src));
10065   ins_pipe(ialu_mem_imm);
10066 %}
10067 
10068 instruct btsL_mem_imm(memory dst, immL_Pow2 con, rFlagsReg cr)
10069 %{
10070   // con should be a pure 64-bit power of 2 immediate
10071   // because AND/OR works well enough for 8/32-bit values.
10072   predicate(log2_long(n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 31);
10073 
10074   match(Set dst (StoreL dst (OrL (LoadL dst) con)));
10075   effect(KILL cr);
10076 
10077   ins_cost(125);
10078   format %{ &quot;btsq    $dst, log2($con)\t# long&quot; %}
10079   ins_encode %{
<span class="line-modified">10080     __ btsq($dst$$Address, log2_long((julong)$con$$constant));</span>
10081   %}
10082   ins_pipe(ialu_mem_imm);
10083 %}
10084 
10085 // Xor Instructions
10086 // Xor Register with Register
10087 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
10088 %{
10089   match(Set dst (XorL dst src));
10090   effect(KILL cr);
10091 
10092   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10093   opcode(0x33);
10094   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10095   ins_pipe(ialu_reg_reg);
10096 %}
10097 
10098 // Xor Register with Immediate -1
10099 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
10100   match(Set dst (XorL dst imm));
</pre>
</td>
</tr>
</table>
<center><a href="x86_32.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../os/aix/os_aix.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/templateTable_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="stubGenerator_x86_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmStructs_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/templateTable_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
4067 
4068   // It&#39;s final, need a null check here!
4069   __ null_check(recv);
4070 
4071   // profile this call
4072   __ profile_final_call(rax);
4073   __ profile_arguments_type(rax, method, rbcp, true);
4074 
4075   __ jump_from_interpreted(method, rax);
4076 
4077   __ bind(notFinal);
4078 
4079   // get receiver klass
4080   __ null_check(recv, oopDesc::klass_offset_in_bytes());
4081   __ load_klass(rax, recv);
4082 
4083   // profile this call
4084   __ profile_virtual_call(rax, rlocals, rdx);
4085   // get target Method* &amp; entry point
4086   __ lookup_virtual_method(rax, index, method);
<span class="line-removed">4087   __ profile_called_method(method, rdx, rbcp);</span>
4088 
4089   __ profile_arguments_type(rdx, method, rbcp, true);
4090   __ jump_from_interpreted(method, rdx);
4091 }
4092 
4093 void TemplateTable::invokevirtual(int byte_no) {
4094   transition(vtos, vtos);
4095   assert(byte_no == f2_byte, &quot;use this argument&quot;);
4096   prepare_invoke(byte_no,
4097                  rbx,    // method or vtable index
4098                  noreg,  // unused itable index
4099                  rcx, rdx); // recv, flags
4100 
4101   // rbx: index
4102   // rcx: receiver
4103   // rdx: flags
4104 
4105   invokevirtual_helper(rbx, rcx, rdx);
4106 }
4107 
</pre>
<hr />
<pre>
4219   __ subl(rbx, Method::itable_index_max);
4220   __ negl(rbx);
4221 
4222   // Preserve recvKlass for throw_AbstractMethodErrorVerbose.
4223   __ mov(rlocals, rdx);
4224   __ lookup_interface_method(// inputs: rec. class, interface, itable index
4225                              rlocals, rax, rbx,
4226                              // outputs: method, scan temp. reg
4227                              rbx, rbcp,
4228                              no_such_interface);
4229 
4230   // rbx: Method* to call
4231   // rcx: receiver
4232   // Check for abstract method error
4233   // Note: This should be done more efficiently via a throw_abstract_method_error
4234   //       interpreter entry point and a conditional jump to it in case of a null
4235   //       method.
4236   __ testptr(rbx, rbx);
4237   __ jcc(Assembler::zero, no_such_method);
4238 
<span class="line-removed">4239   __ profile_called_method(rbx, rbcp, rdx);</span>
4240   __ profile_arguments_type(rdx, rbx, rbcp, true);
4241 
4242   // do the call
4243   // rcx: receiver
4244   // rbx,: Method*
4245   __ jump_from_interpreted(rbx, rdx);
4246   __ should_not_reach_here();
4247 
4248   // exception handling code follows...
4249   // note: must restore interpreter registers to canonical
4250   //       state for exception handling to work correctly!
4251 
4252   __ bind(no_such_method);
4253   // throw exception
4254   __ pop(rbx);           // pop return address (pushed by prepare_invoke)
4255   __ restore_bcp();      // rbcp must be correct for exception handler   (was destroyed)
4256   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
4257   // Pass arguments for generating a verbose error message.
4258 #ifdef _LP64
4259   recvKlass = c_rarg1;
</pre>
</td>
<td>
<hr />
<pre>
4067 
4068   // It&#39;s final, need a null check here!
4069   __ null_check(recv);
4070 
4071   // profile this call
4072   __ profile_final_call(rax);
4073   __ profile_arguments_type(rax, method, rbcp, true);
4074 
4075   __ jump_from_interpreted(method, rax);
4076 
4077   __ bind(notFinal);
4078 
4079   // get receiver klass
4080   __ null_check(recv, oopDesc::klass_offset_in_bytes());
4081   __ load_klass(rax, recv);
4082 
4083   // profile this call
4084   __ profile_virtual_call(rax, rlocals, rdx);
4085   // get target Method* &amp; entry point
4086   __ lookup_virtual_method(rax, index, method);

4087 
4088   __ profile_arguments_type(rdx, method, rbcp, true);
4089   __ jump_from_interpreted(method, rdx);
4090 }
4091 
4092 void TemplateTable::invokevirtual(int byte_no) {
4093   transition(vtos, vtos);
4094   assert(byte_no == f2_byte, &quot;use this argument&quot;);
4095   prepare_invoke(byte_no,
4096                  rbx,    // method or vtable index
4097                  noreg,  // unused itable index
4098                  rcx, rdx); // recv, flags
4099 
4100   // rbx: index
4101   // rcx: receiver
4102   // rdx: flags
4103 
4104   invokevirtual_helper(rbx, rcx, rdx);
4105 }
4106 
</pre>
<hr />
<pre>
4218   __ subl(rbx, Method::itable_index_max);
4219   __ negl(rbx);
4220 
4221   // Preserve recvKlass for throw_AbstractMethodErrorVerbose.
4222   __ mov(rlocals, rdx);
4223   __ lookup_interface_method(// inputs: rec. class, interface, itable index
4224                              rlocals, rax, rbx,
4225                              // outputs: method, scan temp. reg
4226                              rbx, rbcp,
4227                              no_such_interface);
4228 
4229   // rbx: Method* to call
4230   // rcx: receiver
4231   // Check for abstract method error
4232   // Note: This should be done more efficiently via a throw_abstract_method_error
4233   //       interpreter entry point and a conditional jump to it in case of a null
4234   //       method.
4235   __ testptr(rbx, rbx);
4236   __ jcc(Assembler::zero, no_such_method);
4237 

4238   __ profile_arguments_type(rdx, rbx, rbcp, true);
4239 
4240   // do the call
4241   // rcx: receiver
4242   // rbx,: Method*
4243   __ jump_from_interpreted(rbx, rdx);
4244   __ should_not_reach_here();
4245 
4246   // exception handling code follows...
4247   // note: must restore interpreter registers to canonical
4248   //       state for exception handling to work correctly!
4249 
4250   __ bind(no_such_method);
4251   // throw exception
4252   __ pop(rbx);           // pop return address (pushed by prepare_invoke)
4253   __ restore_bcp();      // rbcp must be correct for exception handler   (was destroyed)
4254   __ restore_locals();   // make sure locals pointer is correct as well (was destroyed)
4255   // Pass arguments for generating a verbose error message.
4256 #ifdef _LP64
4257   recvKlass = c_rarg1;
</pre>
</td>
</tr>
</table>
<center><a href="stubGenerator_x86_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmStructs_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/x86/c1_Runtime1_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.hpp&quot;
  27 #include &quot;c1/c1_Defs.hpp&quot;
  28 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  29 #include &quot;c1/c1_Runtime1.hpp&quot;
  30 #include &quot;ci/ciUtilities.hpp&quot;
  31 #include &quot;gc/shared/cardTable.hpp&quot;
  32 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;memory/universe.hpp&quot;
  35 #include &quot;nativeInst_x86.hpp&quot;
  36 #include &quot;oops/compiledICHolder.hpp&quot;
  37 #include &quot;oops/oop.inline.hpp&quot;
  38 #include &quot;prims/jvmtiExport.hpp&quot;
  39 #include &quot;register_x86.hpp&quot;
  40 #include &quot;runtime/sharedRuntime.hpp&quot;
  41 #include &quot;runtime/signature.hpp&quot;
  42 #include &quot;runtime/vframeArray.hpp&quot;
  43 #include &quot;utilities/macros.hpp&quot;
  44 #include &quot;vmreg_x86.inline.hpp&quot;
  45 
  46 // Implementation of StubAssembler
  47 
  48 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry, int args_size) {
  49   // setup registers
  50   const Register thread = NOT_LP64(rdi) LP64_ONLY(r15_thread); // is callee-saved register (Visual C++ calling conventions)
  51   assert(!(oop_result1-&gt;is_valid() || metadata_result-&gt;is_valid()) || oop_result1 != metadata_result, &quot;registers must be different&quot;);
  52   assert(oop_result1 != thread &amp;&amp; metadata_result != thread, &quot;registers must be different&quot;);
  53   assert(args_size &gt;= 0, &quot;illegal args_size&quot;);
  54   bool align_stack = false;
  55 #ifdef _LP64
  56   // At a method handle call, the stack may not be properly aligned
  57   // when returning with an exception.
  58   align_stack = (stub_id() == Runtime1::handle_exception_from_callee_id);
  59 #endif
  60 
  61 #ifdef _LP64
  62   mov(c_rarg0, thread);
  63   set_num_rt_args(0); // Nothing on stack
  64 #else
  65   set_num_rt_args(1 + args_size);
  66 
  67   // push java thread (becomes first argument of C function)
  68   get_thread(thread);
  69   push(thread);
  70 #endif // _LP64
  71 
  72   int call_offset;
  73   if (!align_stack) {
  74     set_last_Java_frame(thread, noreg, rbp, NULL);
  75   } else {
  76     address the_pc = pc();
  77     call_offset = offset();
  78     set_last_Java_frame(thread, noreg, rbp, the_pc);
  79     andptr(rsp, -(StackAlignmentInBytes));    // Align stack
  80   }
  81 
  82   // do the call
  83   call(RuntimeAddress(entry));
  84   if (!align_stack) {
  85     call_offset = offset();
  86   }
  87   // verify callee-saved register
  88 #ifdef ASSERT
  89   guarantee(thread != rax, &quot;change this code&quot;);
  90   push(rax);
  91   { Label L;
  92     get_thread(rax);
  93     cmpptr(thread, rax);
  94     jcc(Assembler::equal, L);
  95     int3();
  96     stop(&quot;StubAssembler::call_RT: rdi not callee saved?&quot;);
  97     bind(L);
  98   }
  99   pop(rax);
 100 #endif
 101   reset_last_Java_frame(thread, true);
 102 
 103   // discard thread and arguments
 104   NOT_LP64(addptr(rsp, num_rt_args()*BytesPerWord));
 105 
 106   // check for pending exceptions
 107   { Label L;
 108     cmpptr(Address(thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);
 109     jcc(Assembler::equal, L);
 110     // exception pending =&gt; remove activation and forward to exception handler
 111     movptr(rax, Address(thread, Thread::pending_exception_offset()));
 112     // make sure that the vm_results are cleared
 113     if (oop_result1-&gt;is_valid()) {
 114       movptr(Address(thread, JavaThread::vm_result_offset()), NULL_WORD);
 115     }
 116     if (metadata_result-&gt;is_valid()) {
 117       movptr(Address(thread, JavaThread::vm_result_2_offset()), NULL_WORD);
 118     }
 119     if (frame_size() == no_frame_size) {
 120       leave();
 121       jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
 122     } else if (_stub_id == Runtime1::forward_exception_id) {
 123       should_not_reach_here();
 124     } else {
 125       jump(RuntimeAddress(Runtime1::entry_for(Runtime1::forward_exception_id)));
 126     }
 127     bind(L);
 128   }
 129   // get oop results if there are any and reset the values in the thread
 130   if (oop_result1-&gt;is_valid()) {
 131     get_vm_result(oop_result1, thread);
 132   }
 133   if (metadata_result-&gt;is_valid()) {
 134     get_vm_result_2(metadata_result, thread);
 135   }
 136   return call_offset;
 137 }
 138 
 139 
 140 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry, Register arg1) {
 141 #ifdef _LP64
 142   mov(c_rarg1, arg1);
 143 #else
 144   push(arg1);
 145 #endif // _LP64
 146   return call_RT(oop_result1, metadata_result, entry, 1);
 147 }
 148 
 149 
 150 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry, Register arg1, Register arg2) {
 151 #ifdef _LP64
 152   if (c_rarg1 == arg2) {
 153     if (c_rarg2 == arg1) {
 154       xchgq(arg1, arg2);
 155     } else {
 156       mov(c_rarg2, arg2);
 157       mov(c_rarg1, arg1);
 158     }
 159   } else {
 160     mov(c_rarg1, arg1);
 161     mov(c_rarg2, arg2);
 162   }
 163 #else
 164   push(arg2);
 165   push(arg1);
 166 #endif // _LP64
 167   return call_RT(oop_result1, metadata_result, entry, 2);
 168 }
 169 
 170 
 171 int StubAssembler::call_RT(Register oop_result1, Register metadata_result, address entry, Register arg1, Register arg2, Register arg3) {
 172 #ifdef _LP64
 173   // if there is any conflict use the stack
 174   if (arg1 == c_rarg2 || arg1 == c_rarg3 ||
 175       arg2 == c_rarg1 || arg1 == c_rarg3 ||
 176       arg3 == c_rarg1 || arg1 == c_rarg2) {
 177     push(arg3);
 178     push(arg2);
 179     push(arg1);
 180     pop(c_rarg1);
 181     pop(c_rarg2);
 182     pop(c_rarg3);
 183   } else {
 184     mov(c_rarg1, arg1);
 185     mov(c_rarg2, arg2);
 186     mov(c_rarg3, arg3);
 187   }
 188 #else
 189   push(arg3);
 190   push(arg2);
 191   push(arg1);
 192 #endif // _LP64
 193   return call_RT(oop_result1, metadata_result, entry, 3);
 194 }
 195 
 196 
 197 // Implementation of StubFrame
 198 
 199 class StubFrame: public StackObj {
 200  private:
 201   StubAssembler* _sasm;
 202 
 203  public:
 204   StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments);
 205   void load_argument(int offset_in_words, Register reg);
 206 
 207   ~StubFrame();
 208 };
 209 
 210 void StubAssembler::prologue(const char* name, bool must_gc_arguments) {
 211   set_info(name, must_gc_arguments);
 212   enter();
 213 }
 214 
 215 void StubAssembler::epilogue() {
 216   leave();
 217   ret(0);
 218 }
 219 
 220 #define __ _sasm-&gt;
 221 
 222 StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments) {
 223   _sasm = sasm;
 224   __ prologue(name, must_gc_arguments);
 225 }
 226 
 227 // load parameters that were stored with LIR_Assembler::store_parameter
 228 // Note: offsets for store_parameter and load_argument must match
 229 void StubFrame::load_argument(int offset_in_words, Register reg) {
 230   __ load_parameter(offset_in_words, reg);
 231 }
 232 
 233 
 234 StubFrame::~StubFrame() {
 235   __ epilogue();
 236 }
 237 
 238 #undef __
 239 
 240 
 241 // Implementation of Runtime1
 242 
 243 const int float_regs_as_doubles_size_in_slots = pd_nof_fpu_regs_frame_map * 2;
 244 const int xmm_regs_as_doubles_size_in_slots = FrameMap::nof_xmm_regs * 2;
 245 
 246 // Stack layout for saving/restoring  all the registers needed during a runtime
 247 // call (this includes deoptimization)
 248 // Note: note that users of this frame may well have arguments to some runtime
 249 // while these values are on the stack. These positions neglect those arguments
 250 // but the code in save_live_registers will take the argument count into
 251 // account.
 252 //
 253 #ifdef _LP64
 254   #define SLOT2(x) x,
 255   #define SLOT_PER_WORD 2
 256 #else
 257   #define SLOT2(x)
 258   #define SLOT_PER_WORD 1
 259 #endif // _LP64
 260 
 261 enum reg_save_layout {
 262   // 64bit needs to keep stack 16 byte aligned. So we add some alignment dummies to make that
 263   // happen and will assert if the stack size we create is misaligned
 264 #ifdef _LP64
 265   align_dummy_0, align_dummy_1,
 266 #endif // _LP64
 267 #ifdef _WIN64
 268   // Windows always allocates space for it&#39;s argument registers (see
 269   // frame::arg_reg_save_area_bytes).
 270   arg_reg_save_1, arg_reg_save_1H,                                                          // 0, 4
 271   arg_reg_save_2, arg_reg_save_2H,                                                          // 8, 12
 272   arg_reg_save_3, arg_reg_save_3H,                                                          // 16, 20
 273   arg_reg_save_4, arg_reg_save_4H,                                                          // 24, 28
 274 #endif // _WIN64
 275   xmm_regs_as_doubles_off,                                                                  // 32
 276   float_regs_as_doubles_off = xmm_regs_as_doubles_off + xmm_regs_as_doubles_size_in_slots,  // 160
 277   fpu_state_off = float_regs_as_doubles_off + float_regs_as_doubles_size_in_slots,          // 224
 278   // fpu_state_end_off is exclusive
 279   fpu_state_end_off = fpu_state_off + (FPUStateSizeInWords / SLOT_PER_WORD),                // 352
 280   marker = fpu_state_end_off, SLOT2(markerH)                                                // 352, 356
 281   extra_space_offset,                                                                       // 360
 282 #ifdef _LP64
 283   r15_off = extra_space_offset, r15H_off,                                                   // 360, 364
 284   r14_off, r14H_off,                                                                        // 368, 372
 285   r13_off, r13H_off,                                                                        // 376, 380
 286   r12_off, r12H_off,                                                                        // 384, 388
 287   r11_off, r11H_off,                                                                        // 392, 396
 288   r10_off, r10H_off,                                                                        // 400, 404
 289   r9_off, r9H_off,                                                                          // 408, 412
 290   r8_off, r8H_off,                                                                          // 416, 420
 291   rdi_off, rdiH_off,                                                                        // 424, 428
 292 #else
 293   rdi_off = extra_space_offset,
 294 #endif // _LP64
 295   rsi_off, SLOT2(rsiH_off)                                                                  // 432, 436
 296   rbp_off, SLOT2(rbpH_off)                                                                  // 440, 444
 297   rsp_off, SLOT2(rspH_off)                                                                  // 448, 452
 298   rbx_off, SLOT2(rbxH_off)                                                                  // 456, 460
 299   rdx_off, SLOT2(rdxH_off)                                                                  // 464, 468
 300   rcx_off, SLOT2(rcxH_off)                                                                  // 472, 476
 301   rax_off, SLOT2(raxH_off)                                                                  // 480, 484
 302   saved_rbp_off, SLOT2(saved_rbpH_off)                                                      // 488, 492
 303   return_off, SLOT2(returnH_off)                                                            // 496, 500
 304   reg_save_frame_size   // As noted: neglects any parameters to runtime                     // 504
 305 };
 306 
 307 // Save off registers which might be killed by calls into the runtime.
 308 // Tries to smart of about FP registers.  In particular we separate
 309 // saving and describing the FPU registers for deoptimization since we
 310 // have to save the FPU registers twice if we describe them and on P4
 311 // saving FPU registers which don&#39;t contain anything appears
 312 // expensive.  The deopt blob is the only thing which needs to
 313 // describe FPU registers.  In all other cases it should be sufficient
 314 // to simply save their current value.
 315 
 316 static OopMap* generate_oop_map(StubAssembler* sasm, int num_rt_args,
 317                                 bool save_fpu_registers = true) {
 318 
 319   // In 64bit all the args are in regs so there are no additional stack slots
 320   LP64_ONLY(num_rt_args = 0);
 321   LP64_ONLY(assert((reg_save_frame_size * VMRegImpl::stack_slot_size) % 16 == 0, &quot;must be 16 byte aligned&quot;);)
 322   int frame_size_in_slots = reg_save_frame_size + num_rt_args; // args + thread
 323   sasm-&gt;set_frame_size(frame_size_in_slots / VMRegImpl::slots_per_word);
 324 
 325   // record saved value locations in an OopMap
 326   // locations are offsets from sp after runtime call; num_rt_args is number of arguments in call, including thread
 327   OopMap* map = new OopMap(frame_size_in_slots, 0);
 328   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rax_off + num_rt_args), rax-&gt;as_VMReg());
 329   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rcx_off + num_rt_args), rcx-&gt;as_VMReg());
 330   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rdx_off + num_rt_args), rdx-&gt;as_VMReg());
 331   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rbx_off + num_rt_args), rbx-&gt;as_VMReg());
 332   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rsi_off + num_rt_args), rsi-&gt;as_VMReg());
 333   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rdi_off + num_rt_args), rdi-&gt;as_VMReg());
 334 #ifdef _LP64
 335   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r8_off + num_rt_args),  r8-&gt;as_VMReg());
 336   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r9_off + num_rt_args),  r9-&gt;as_VMReg());
 337   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r10_off + num_rt_args), r10-&gt;as_VMReg());
 338   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r11_off + num_rt_args), r11-&gt;as_VMReg());
 339   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r12_off + num_rt_args), r12-&gt;as_VMReg());
 340   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r13_off + num_rt_args), r13-&gt;as_VMReg());
 341   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r14_off + num_rt_args), r14-&gt;as_VMReg());
 342   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r15_off + num_rt_args), r15-&gt;as_VMReg());
 343 
 344   // This is stupid but needed.
 345   map-&gt;set_callee_saved(VMRegImpl::stack2reg(raxH_off + num_rt_args), rax-&gt;as_VMReg()-&gt;next());
 346   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rcxH_off + num_rt_args), rcx-&gt;as_VMReg()-&gt;next());
 347   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rdxH_off + num_rt_args), rdx-&gt;as_VMReg()-&gt;next());
 348   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rbxH_off + num_rt_args), rbx-&gt;as_VMReg()-&gt;next());
 349   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rsiH_off + num_rt_args), rsi-&gt;as_VMReg()-&gt;next());
 350   map-&gt;set_callee_saved(VMRegImpl::stack2reg(rdiH_off + num_rt_args), rdi-&gt;as_VMReg()-&gt;next());
 351 
 352   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r8H_off + num_rt_args),  r8-&gt;as_VMReg()-&gt;next());
 353   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r9H_off + num_rt_args),  r9-&gt;as_VMReg()-&gt;next());
 354   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r10H_off + num_rt_args), r10-&gt;as_VMReg()-&gt;next());
 355   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r11H_off + num_rt_args), r11-&gt;as_VMReg()-&gt;next());
 356   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r12H_off + num_rt_args), r12-&gt;as_VMReg()-&gt;next());
 357   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r13H_off + num_rt_args), r13-&gt;as_VMReg()-&gt;next());
 358   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r14H_off + num_rt_args), r14-&gt;as_VMReg()-&gt;next());
 359   map-&gt;set_callee_saved(VMRegImpl::stack2reg(r15H_off + num_rt_args), r15-&gt;as_VMReg()-&gt;next());
 360 #endif // _LP64
 361 
 362   int xmm_bypass_limit = FrameMap::nof_xmm_regs;
 363 #ifdef _LP64
 364   if (UseAVX &lt; 3) {
 365     xmm_bypass_limit = xmm_bypass_limit / 2;
 366   }
 367 #endif
 368 
 369   if (save_fpu_registers) {
 370     if (UseSSE &lt; 2) {
 371       int fpu_off = float_regs_as_doubles_off;
 372       for (int n = 0; n &lt; FrameMap::nof_fpu_regs; n++) {
 373         VMReg fpu_name_0 = FrameMap::fpu_regname(n);
 374         map-&gt;set_callee_saved(VMRegImpl::stack2reg(fpu_off +     num_rt_args), fpu_name_0);
 375         // %%% This is really a waste but we&#39;ll keep things as they were for now
 376         if (true) {
 377           map-&gt;set_callee_saved(VMRegImpl::stack2reg(fpu_off + 1 + num_rt_args), fpu_name_0-&gt;next());
 378         }
 379         fpu_off += 2;
 380       }
 381       assert(fpu_off == fpu_state_off, &quot;incorrect number of fpu stack slots&quot;);
 382     }
 383 
 384     if (UseSSE &gt;= 2) {
 385       int xmm_off = xmm_regs_as_doubles_off;
 386       for (int n = 0; n &lt; FrameMap::nof_xmm_regs; n++) {
 387         if (n &lt; xmm_bypass_limit) {
 388           VMReg xmm_name_0 = as_XMMRegister(n)-&gt;as_VMReg();
 389           map-&gt;set_callee_saved(VMRegImpl::stack2reg(xmm_off + num_rt_args), xmm_name_0);
 390           // %%% This is really a waste but we&#39;ll keep things as they were for now
 391           if (true) {
 392             map-&gt;set_callee_saved(VMRegImpl::stack2reg(xmm_off + 1 + num_rt_args), xmm_name_0-&gt;next());
 393           }
 394         }
 395         xmm_off += 2;
 396       }
 397       assert(xmm_off == float_regs_as_doubles_off, &quot;incorrect number of xmm registers&quot;);
 398 
 399     } else if (UseSSE == 1) {
 400       int xmm_off = xmm_regs_as_doubles_off;
 401       for (int n = 0; n &lt; FrameMap::nof_fpu_regs; n++) {
 402         VMReg xmm_name_0 = as_XMMRegister(n)-&gt;as_VMReg();
 403         map-&gt;set_callee_saved(VMRegImpl::stack2reg(xmm_off + num_rt_args), xmm_name_0);
 404         xmm_off += 2;
 405       }
 406       assert(xmm_off == float_regs_as_doubles_off, &quot;incorrect number of xmm registers&quot;);
 407     }
 408   }
 409 
 410   return map;
 411 }
 412 
 413 #define __ this-&gt;
 414 
 415 void C1_MacroAssembler::save_live_registers_no_oop_map(bool save_fpu_registers) {
 416   __ block_comment(&quot;save_live_registers&quot;);
 417 
 418   __ pusha();         // integer registers
 419 
 420   // assert(float_regs_as_doubles_off % 2 == 0, &quot;misaligned offset&quot;);
 421   // assert(xmm_regs_as_doubles_off % 2 == 0, &quot;misaligned offset&quot;);
 422 
 423   __ subptr(rsp, extra_space_offset * VMRegImpl::stack_slot_size);
 424 
 425 #ifdef ASSERT
 426   __ movptr(Address(rsp, marker * VMRegImpl::stack_slot_size), (int32_t)0xfeedbeef);
 427 #endif
 428 
 429   if (save_fpu_registers) {
 430 #ifndef _LP64
 431     if (UseSSE &lt; 2) {
 432       // save FPU stack
 433       __ fnsave(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size));
 434       __ fwait();
 435 
 436 #ifdef ASSERT
 437       Label ok;
 438       __ cmpw(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size), StubRoutines::fpu_cntrl_wrd_std());
 439       __ jccb(Assembler::equal, ok);
 440       __ stop(&quot;corrupted control word detected&quot;);
 441       __ bind(ok);
 442 #endif
 443 
 444       // Reset the control word to guard against exceptions being unmasked
 445       // since fstp_d can cause FPU stack underflow exceptions.  Write it
 446       // into the on stack copy and then reload that to make sure that the
 447       // current and future values are correct.
 448       __ movw(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size), StubRoutines::fpu_cntrl_wrd_std());
 449       __ frstor(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size));
 450 
 451       // Save the FPU registers in de-opt-able form
 452       int offset = 0;
 453       for (int n = 0; n &lt; FrameMap::nof_fpu_regs; n++) {
 454         __ fstp_d(Address(rsp, float_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset));
 455         offset += 8;
 456       }
 457     }
 458 #endif // !_LP64
 459 
 460     if (UseSSE &gt;= 2) {
 461       // save XMM registers
 462       // XMM registers can contain float or double values, but this is not known here,
 463       // so always save them as doubles.
 464       // note that float values are _not_ converted automatically, so for float values
 465       // the second word contains only garbage data.
 466       int xmm_bypass_limit = FrameMap::nof_xmm_regs;
 467       int offset = 0;
 468 #ifdef _LP64
 469       if (UseAVX &lt; 3) {
 470         xmm_bypass_limit = xmm_bypass_limit / 2;
 471       }
 472 #endif
 473       for (int n = 0; n &lt; xmm_bypass_limit; n++) {
 474         XMMRegister xmm_name = as_XMMRegister(n);
 475         __ movdbl(Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset), xmm_name);
 476         offset += 8;
 477       }
 478 #ifndef _LP64
 479     } else if (UseSSE == 1) {
 480       // save XMM registers as float because double not supported without SSE2(num MMX == num fpu)
 481       int offset = 0;
 482       for (int n = 0; n &lt; FrameMap::nof_fpu_regs; n++) {
 483         XMMRegister xmm_name = as_XMMRegister(n);
 484         __ movflt(Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset), xmm_name);
 485         offset += 8;
 486       }
 487 #endif // !_LP64
 488     }
 489   }
 490 
 491   // FPU stack must be empty now
 492   NOT_LP64( __ verify_FPU(0, &quot;save_live_registers&quot;); )
 493 }
 494 
 495 #undef __
 496 #define __ sasm-&gt;
 497 
 498 static void restore_fpu(C1_MacroAssembler* sasm, bool restore_fpu_registers) {
 499 #ifdef _LP64
 500   if (restore_fpu_registers) {
 501     // restore XMM registers
 502     int xmm_bypass_limit = FrameMap::nof_xmm_regs;
 503     if (UseAVX &lt; 3) {
 504       xmm_bypass_limit = xmm_bypass_limit / 2;
 505     }
 506     int offset = 0;
 507     for (int n = 0; n &lt; xmm_bypass_limit; n++) {
 508       XMMRegister xmm_name = as_XMMRegister(n);
 509       __ movdbl(xmm_name, Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset));
 510       offset += 8;
 511     }
 512   }
 513 #else
 514   if (restore_fpu_registers) {
 515     if (UseSSE &gt;= 2) {
 516       // restore XMM registers
 517       int xmm_bypass_limit = FrameMap::nof_xmm_regs;
 518       int offset = 0;
 519       for (int n = 0; n &lt; xmm_bypass_limit; n++) {
 520         XMMRegister xmm_name = as_XMMRegister(n);
 521         __ movdbl(xmm_name, Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset));
 522         offset += 8;
 523       }
 524     } else if (UseSSE == 1) {
 525       // restore XMM registers(num MMX == num fpu)
 526       int offset = 0;
 527       for (int n = 0; n &lt; FrameMap::nof_fpu_regs; n++) {
 528         XMMRegister xmm_name = as_XMMRegister(n);
 529         __ movflt(xmm_name, Address(rsp, xmm_regs_as_doubles_off * VMRegImpl::stack_slot_size + offset));
 530         offset += 8;
 531       }
 532     }
 533 
 534     if (UseSSE &lt; 2) {
 535       __ frstor(Address(rsp, fpu_state_off * VMRegImpl::stack_slot_size));
 536     } else {
 537       // check that FPU stack is really empty
 538       __ verify_FPU(0, &quot;restore_live_registers&quot;);
 539     }
 540   } else {
 541     // check that FPU stack is really empty
 542     __ verify_FPU(0, &quot;restore_live_registers&quot;);
 543   }
 544 #endif // _LP64
 545 
 546 #ifdef ASSERT
 547   {
 548     Label ok;
 549     __ cmpptr(Address(rsp, marker * VMRegImpl::stack_slot_size), (int32_t)0xfeedbeef);
 550     __ jcc(Assembler::equal, ok);
 551     __ stop(&quot;bad offsets in frame&quot;);
 552     __ bind(ok);
 553   }
 554 #endif // ASSERT
 555 
 556   __ addptr(rsp, extra_space_offset * VMRegImpl::stack_slot_size);
 557 }
 558 
 559 #undef __
 560 #define __ this-&gt;
 561 
 562 void C1_MacroAssembler::restore_live_registers(bool restore_fpu_registers) {
 563   __ block_comment(&quot;restore_live_registers&quot;);
 564 
 565   restore_fpu(this, restore_fpu_registers);
 566   __ popa();
 567 }
 568 
 569 
 570 void C1_MacroAssembler::restore_live_registers_except_rax(bool restore_fpu_registers) {
 571   __ block_comment(&quot;restore_live_registers_except_rax&quot;);
 572 
 573   restore_fpu(this, restore_fpu_registers);
 574 
 575 #ifdef _LP64
 576   __ movptr(r15, Address(rsp, 0));
 577   __ movptr(r14, Address(rsp, wordSize));
 578   __ movptr(r13, Address(rsp, 2 * wordSize));
 579   __ movptr(r12, Address(rsp, 3 * wordSize));
 580   __ movptr(r11, Address(rsp, 4 * wordSize));
 581   __ movptr(r10, Address(rsp, 5 * wordSize));
 582   __ movptr(r9,  Address(rsp, 6 * wordSize));
 583   __ movptr(r8,  Address(rsp, 7 * wordSize));
 584   __ movptr(rdi, Address(rsp, 8 * wordSize));
 585   __ movptr(rsi, Address(rsp, 9 * wordSize));
 586   __ movptr(rbp, Address(rsp, 10 * wordSize));
 587   // skip rsp
 588   __ movptr(rbx, Address(rsp, 12 * wordSize));
 589   __ movptr(rdx, Address(rsp, 13 * wordSize));
 590   __ movptr(rcx, Address(rsp, 14 * wordSize));
 591 
 592   __ addptr(rsp, 16 * wordSize);
 593 #else
 594 
 595   __ pop(rdi);
 596   __ pop(rsi);
 597   __ pop(rbp);
 598   __ pop(rbx); // skip this value
 599   __ pop(rbx);
 600   __ pop(rdx);
 601   __ pop(rcx);
 602   __ addptr(rsp, BytesPerWord);
 603 #endif // _LP64
 604 }
 605 
 606 #undef __
 607 #define __ sasm-&gt;
 608 
 609 static OopMap* save_live_registers(StubAssembler* sasm, int num_rt_args,
 610                                    bool save_fpu_registers = true) {
 611   __ save_live_registers_no_oop_map(save_fpu_registers);
 612   return generate_oop_map(sasm, num_rt_args, save_fpu_registers);
 613 }
 614 
 615 static void restore_live_registers(StubAssembler* sasm, bool restore_fpu_registers = true) {
 616   __ restore_live_registers(restore_fpu_registers);
 617 }
 618 
 619 static void restore_live_registers_except_rax(StubAssembler* sasm, bool restore_fpu_registers = true) {
 620   sasm-&gt;restore_live_registers_except_rax(restore_fpu_registers);
 621 }
 622 
 623 
 624 void Runtime1::initialize_pd() {
 625   // nothing to do
 626 }
 627 
 628 
 629 // Target: the entry point of the method that creates and posts the exception oop.
 630 // has_argument: true if the exception needs arguments (passed on the stack because
 631 //               registers must be preserved).
 632 OopMapSet* Runtime1::generate_exception_throw(StubAssembler* sasm, address target, bool has_argument) {
 633   // Preserve all registers.
 634   int num_rt_args = has_argument ? (2 + 1) : 1;
 635   OopMap* oop_map = save_live_registers(sasm, num_rt_args);
 636 
 637   // Now all registers are saved and can be used freely.
 638   // Verify that no old value is used accidentally.
 639   __ invalidate_registers(true, true, true, true, true, true);
 640 
 641   // Registers used by this stub.
 642   const Register temp_reg = rbx;
 643 
 644   // Load arguments for exception that are passed as arguments into the stub.
 645   if (has_argument) {
 646 #ifdef _LP64
 647     __ movptr(c_rarg1, Address(rbp, 2*BytesPerWord));
 648     __ movptr(c_rarg2, Address(rbp, 3*BytesPerWord));
 649 #else
 650     __ movptr(temp_reg, Address(rbp, 3*BytesPerWord));
 651     __ push(temp_reg);
 652     __ movptr(temp_reg, Address(rbp, 2*BytesPerWord));
 653     __ push(temp_reg);
 654 #endif // _LP64
 655   }
 656   int call_offset = __ call_RT(noreg, noreg, target, num_rt_args - 1);
 657 
 658   OopMapSet* oop_maps = new OopMapSet();
 659   oop_maps-&gt;add_gc_map(call_offset, oop_map);
 660 
 661   __ stop(&quot;should not reach here&quot;);
 662 
 663   return oop_maps;
 664 }
 665 
 666 
 667 OopMapSet* Runtime1::generate_handle_exception(StubID id, StubAssembler *sasm) {
 668   __ block_comment(&quot;generate_handle_exception&quot;);
 669 
 670   // incoming parameters
 671   const Register exception_oop = rax;
 672   const Register exception_pc  = rdx;
 673   // other registers used in this stub
 674   const Register thread = NOT_LP64(rdi) LP64_ONLY(r15_thread);
 675 
 676   // Save registers, if required.
 677   OopMapSet* oop_maps = new OopMapSet();
 678   OopMap* oop_map = NULL;
 679   switch (id) {
 680   case forward_exception_id:
 681     // We&#39;re handling an exception in the context of a compiled frame.
 682     // The registers have been saved in the standard places.  Perform
 683     // an exception lookup in the caller and dispatch to the handler
 684     // if found.  Otherwise unwind and dispatch to the callers
 685     // exception handler.
 686     oop_map = generate_oop_map(sasm, 1 /*thread*/);
 687 
 688     // load and clear pending exception oop into RAX
 689     __ movptr(exception_oop, Address(thread, Thread::pending_exception_offset()));
 690     __ movptr(Address(thread, Thread::pending_exception_offset()), NULL_WORD);
 691 
 692     // load issuing PC (the return address for this stub) into rdx
 693     __ movptr(exception_pc, Address(rbp, 1*BytesPerWord));
 694 
 695     // make sure that the vm_results are cleared (may be unnecessary)
 696     __ movptr(Address(thread, JavaThread::vm_result_offset()),   NULL_WORD);
 697     __ movptr(Address(thread, JavaThread::vm_result_2_offset()), NULL_WORD);
 698     break;
 699   case handle_exception_nofpu_id:
 700   case handle_exception_id:
 701     // At this point all registers MAY be live.
 702     oop_map = save_live_registers(sasm, 1 /*thread*/, id != handle_exception_nofpu_id);
 703     break;
 704   case handle_exception_from_callee_id: {
 705     // At this point all registers except exception oop (RAX) and
 706     // exception pc (RDX) are dead.
 707     const int frame_size = 2 /*BP, return address*/ NOT_LP64(+ 1 /*thread*/) WIN64_ONLY(+ frame::arg_reg_save_area_bytes / BytesPerWord);
 708     oop_map = new OopMap(frame_size * VMRegImpl::slots_per_word, 0);
 709     sasm-&gt;set_frame_size(frame_size);
 710     WIN64_ONLY(__ subq(rsp, frame::arg_reg_save_area_bytes));
 711     break;
 712   }
 713   default:  ShouldNotReachHere();
 714   }
 715 
 716 #if !defined(_LP64) &amp;&amp; defined(TIERED)
 717   if (UseSSE &lt; 2) {
 718     // C2 can leave the fpu stack dirty
 719     __ empty_FPU_stack();
 720   }
 721 #endif // !_LP64 &amp;&amp; TIERED
 722 
 723   // verify that only rax, and rdx is valid at this time
 724   __ invalidate_registers(false, true, true, false, true, true);
 725   // verify that rax, contains a valid exception
 726   __ verify_not_null_oop(exception_oop);
 727 
 728   // load address of JavaThread object for thread-local data
 729   NOT_LP64(__ get_thread(thread);)
 730 
 731 #ifdef ASSERT
 732   // check that fields in JavaThread for exception oop and issuing pc are
 733   // empty before writing to them
 734   Label oop_empty;
 735   __ cmpptr(Address(thread, JavaThread::exception_oop_offset()), (int32_t) NULL_WORD);
 736   __ jcc(Assembler::equal, oop_empty);
 737   __ stop(&quot;exception oop already set&quot;);
 738   __ bind(oop_empty);
 739 
 740   Label pc_empty;
 741   __ cmpptr(Address(thread, JavaThread::exception_pc_offset()), 0);
 742   __ jcc(Assembler::equal, pc_empty);
 743   __ stop(&quot;exception pc already set&quot;);
 744   __ bind(pc_empty);
 745 #endif
 746 
 747   // save exception oop and issuing pc into JavaThread
 748   // (exception handler will load it from here)
 749   __ movptr(Address(thread, JavaThread::exception_oop_offset()), exception_oop);
 750   __ movptr(Address(thread, JavaThread::exception_pc_offset()),  exception_pc);
 751 
 752   // patch throwing pc into return address (has bci &amp; oop map)
 753   __ movptr(Address(rbp, 1*BytesPerWord), exception_pc);
 754 
 755   // compute the exception handler.
 756   // the exception oop and the throwing pc are read from the fields in JavaThread
 757   int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, exception_handler_for_pc));
 758   oop_maps-&gt;add_gc_map(call_offset, oop_map);
 759 
 760   // rax: handler address
 761   //      will be the deopt blob if nmethod was deoptimized while we looked up
 762   //      handler regardless of whether handler existed in the nmethod.
 763 
 764   // only rax, is valid at this time, all other registers have been destroyed by the runtime call
 765   __ invalidate_registers(false, true, true, true, true, true);
 766 
 767   // patch the return address, this stub will directly return to the exception handler
 768   __ movptr(Address(rbp, 1*BytesPerWord), rax);
 769 
 770   switch (id) {
 771   case forward_exception_id:
 772   case handle_exception_nofpu_id:
 773   case handle_exception_id:
 774     // Restore the registers that were saved at the beginning.
 775     restore_live_registers(sasm, id != handle_exception_nofpu_id);
 776     break;
 777   case handle_exception_from_callee_id:
 778     // WIN64_ONLY: No need to add frame::arg_reg_save_area_bytes to SP
 779     // since we do a leave anyway.
 780 
 781     // Pop the return address.
 782     __ leave();
 783     __ pop(rcx);
 784     __ jmp(rcx);  // jump to exception handler
 785     break;
 786   default:  ShouldNotReachHere();
 787   }
 788 
 789   return oop_maps;
 790 }
 791 
 792 
 793 void Runtime1::generate_unwind_exception(StubAssembler *sasm) {
 794   // incoming parameters
 795   const Register exception_oop = rax;
 796   // callee-saved copy of exception_oop during runtime call
 797   const Register exception_oop_callee_saved = NOT_LP64(rsi) LP64_ONLY(r14);
 798   // other registers used in this stub
 799   const Register exception_pc = rdx;
 800   const Register handler_addr = rbx;
 801   const Register thread = NOT_LP64(rdi) LP64_ONLY(r15_thread);
 802 
 803   // verify that only rax, is valid at this time
 804   __ invalidate_registers(false, true, true, true, true, true);
 805 
 806 #ifdef ASSERT
 807   // check that fields in JavaThread for exception oop and issuing pc are empty
 808   NOT_LP64(__ get_thread(thread);)
 809   Label oop_empty;
 810   __ cmpptr(Address(thread, JavaThread::exception_oop_offset()), 0);
 811   __ jcc(Assembler::equal, oop_empty);
 812   __ stop(&quot;exception oop must be empty&quot;);
 813   __ bind(oop_empty);
 814 
 815   Label pc_empty;
 816   __ cmpptr(Address(thread, JavaThread::exception_pc_offset()), 0);
 817   __ jcc(Assembler::equal, pc_empty);
 818   __ stop(&quot;exception pc must be empty&quot;);
 819   __ bind(pc_empty);
 820 #endif
 821 
 822   // clear the FPU stack in case any FPU results are left behind
 823   NOT_LP64( __ empty_FPU_stack(); )
 824 
 825   // save exception_oop in callee-saved register to preserve it during runtime calls
 826   __ verify_not_null_oop(exception_oop);
 827   __ movptr(exception_oop_callee_saved, exception_oop);
 828 
 829   NOT_LP64(__ get_thread(thread);)
 830   // Get return address (is on top of stack after leave).
 831   __ movptr(exception_pc, Address(rsp, 0));
 832 
 833   // search the exception handler address of the caller (using the return address)
 834   __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), thread, exception_pc);
 835   // rax: exception handler address of the caller
 836 
 837   // Only RAX and RSI are valid at this time, all other registers have been destroyed by the call.
 838   __ invalidate_registers(false, true, true, true, false, true);
 839 
 840   // move result of call into correct register
 841   __ movptr(handler_addr, rax);
 842 
 843   // Restore exception oop to RAX (required convention of exception handler).
 844   __ movptr(exception_oop, exception_oop_callee_saved);
 845 
 846   // verify that there is really a valid exception in rax
 847   __ verify_not_null_oop(exception_oop);
 848 
 849   // get throwing pc (= return address).
 850   // rdx has been destroyed by the call, so it must be set again
 851   // the pop is also necessary to simulate the effect of a ret(0)
 852   __ pop(exception_pc);
 853 
 854   // continue at exception handler (return address removed)
 855   // note: do *not* remove arguments when unwinding the
 856   //       activation since the caller assumes having
 857   //       all arguments on the stack when entering the
 858   //       runtime to determine the exception handler
 859   //       (GC happens at call site with arguments!)
 860   // rax: exception oop
 861   // rdx: throwing pc
 862   // rbx: exception handler
 863   __ jmp(handler_addr);
 864 }
 865 
 866 
 867 OopMapSet* Runtime1::generate_patching(StubAssembler* sasm, address target) {
 868   // use the maximum number of runtime-arguments here because it is difficult to
 869   // distinguish each RT-Call.
 870   // Note: This number affects also the RT-Call in generate_handle_exception because
 871   //       the oop-map is shared for all calls.
 872   const int num_rt_args = 2;  // thread + dummy
 873 
 874   DeoptimizationBlob* deopt_blob = SharedRuntime::deopt_blob();
 875   assert(deopt_blob != NULL, &quot;deoptimization blob must have been created&quot;);
 876 
 877   OopMap* oop_map = save_live_registers(sasm, num_rt_args);
 878 
 879 #ifdef _LP64
 880   const Register thread = r15_thread;
 881   // No need to worry about dummy
 882   __ mov(c_rarg0, thread);
 883 #else
 884   __ push(rax); // push dummy
 885 
 886   const Register thread = rdi; // is callee-saved register (Visual C++ calling conventions)
 887   // push java thread (becomes first argument of C function)
 888   __ get_thread(thread);
 889   __ push(thread);
 890 #endif // _LP64
 891   __ set_last_Java_frame(thread, noreg, rbp, NULL);
 892   // do the call
 893   __ call(RuntimeAddress(target));
 894   OopMapSet* oop_maps = new OopMapSet();
 895   oop_maps-&gt;add_gc_map(__ offset(), oop_map);
 896   // verify callee-saved register
 897 #ifdef ASSERT
 898   guarantee(thread != rax, &quot;change this code&quot;);
 899   __ push(rax);
 900   { Label L;
 901     __ get_thread(rax);
 902     __ cmpptr(thread, rax);
 903     __ jcc(Assembler::equal, L);
 904     __ stop(&quot;StubAssembler::call_RT: rdi/r15 not callee saved?&quot;);
 905     __ bind(L);
 906   }
 907   __ pop(rax);
 908 #endif
 909   __ reset_last_Java_frame(thread, true);
 910 #ifndef _LP64
 911   __ pop(rcx); // discard thread arg
 912   __ pop(rcx); // discard dummy
 913 #endif // _LP64
 914 
 915   // check for pending exceptions
 916   { Label L;
 917     __ cmpptr(Address(thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);
 918     __ jcc(Assembler::equal, L);
 919     // exception pending =&gt; remove activation and forward to exception handler
 920 
 921     __ testptr(rax, rax);                                   // have we deoptimized?
 922     __ jump_cc(Assembler::equal,
 923                RuntimeAddress(Runtime1::entry_for(Runtime1::forward_exception_id)));
 924 
 925     // the deopt blob expects exceptions in the special fields of
 926     // JavaThread, so copy and clear pending exception.
 927 
 928     // load and clear pending exception
 929     __ movptr(rax, Address(thread, Thread::pending_exception_offset()));
 930     __ movptr(Address(thread, Thread::pending_exception_offset()), NULL_WORD);
 931 
 932     // check that there is really a valid exception
 933     __ verify_not_null_oop(rax);
 934 
 935     // load throwing pc: this is the return address of the stub
 936     __ movptr(rdx, Address(rsp, return_off * VMRegImpl::stack_slot_size));
 937 
 938 #ifdef ASSERT
 939     // check that fields in JavaThread for exception oop and issuing pc are empty
 940     Label oop_empty;
 941     __ cmpptr(Address(thread, JavaThread::exception_oop_offset()), (int32_t)NULL_WORD);
 942     __ jcc(Assembler::equal, oop_empty);
 943     __ stop(&quot;exception oop must be empty&quot;);
 944     __ bind(oop_empty);
 945 
 946     Label pc_empty;
 947     __ cmpptr(Address(thread, JavaThread::exception_pc_offset()), (int32_t)NULL_WORD);
 948     __ jcc(Assembler::equal, pc_empty);
 949     __ stop(&quot;exception pc must be empty&quot;);
 950     __ bind(pc_empty);
 951 #endif
 952 
 953     // store exception oop and throwing pc to JavaThread
 954     __ movptr(Address(thread, JavaThread::exception_oop_offset()), rax);
 955     __ movptr(Address(thread, JavaThread::exception_pc_offset()), rdx);
 956 
 957     restore_live_registers(sasm);
 958 
 959     __ leave();
 960     __ addptr(rsp, BytesPerWord);  // remove return address from stack
 961 
 962     // Forward the exception directly to deopt blob. We can blow no
 963     // registers and must leave throwing pc on the stack.  A patch may
 964     // have values live in registers so the entry point with the
 965     // exception in tls.
 966     __ jump(RuntimeAddress(deopt_blob-&gt;unpack_with_exception_in_tls()));
 967 
 968     __ bind(L);
 969   }
 970 
 971 
 972   // Runtime will return true if the nmethod has been deoptimized during
 973   // the patching process. In that case we must do a deopt reexecute instead.
 974 
 975   Label cont;
 976 
 977   __ testptr(rax, rax);                                 // have we deoptimized?
 978   __ jcc(Assembler::equal, cont);                       // no
 979 
 980   // Will reexecute. Proper return address is already on the stack we just restore
 981   // registers, pop all of our frame but the return address and jump to the deopt blob
 982   restore_live_registers(sasm);
 983   __ leave();
 984   __ jump(RuntimeAddress(deopt_blob-&gt;unpack_with_reexecution()));
 985 
 986   __ bind(cont);
 987   restore_live_registers(sasm);
 988   __ leave();
 989   __ ret(0);
 990 
 991   return oop_maps;
 992 }
 993 
 994 
 995 OopMapSet* Runtime1::generate_code_for(StubID id, StubAssembler* sasm) {
 996 
 997   // for better readability
 998   const bool must_gc_arguments = true;
 999   const bool dont_gc_arguments = false;
1000 
1001   // default value; overwritten for some optimized stubs that are called from methods that do not use the fpu
1002   bool save_fpu_registers = true;
1003 
1004   // stub code &amp; info for the different stubs
1005   OopMapSet* oop_maps = NULL;
1006   switch (id) {
1007     case forward_exception_id:
1008       {
1009         oop_maps = generate_handle_exception(id, sasm);
1010         __ leave();
1011         __ ret(0);
1012       }
1013       break;
1014 
1015     case new_instance_id:
1016     case fast_new_instance_id:
1017     case fast_new_instance_init_check_id:
1018       {
1019         Register klass = rdx; // Incoming
1020         Register obj   = rax; // Result
1021 
1022         if (id == new_instance_id) {
1023           __ set_info(&quot;new_instance&quot;, dont_gc_arguments);
1024         } else if (id == fast_new_instance_id) {
1025           __ set_info(&quot;fast new_instance&quot;, dont_gc_arguments);
1026         } else {
1027           assert(id == fast_new_instance_init_check_id, &quot;bad StubID&quot;);
1028           __ set_info(&quot;fast new_instance init check&quot;, dont_gc_arguments);
1029         }
1030 
1031         // If TLAB is disabled, see if there is support for inlining contiguous
1032         // allocations.
1033         // Otherwise, just go to the slow path.
1034         if ((id == fast_new_instance_id || id == fast_new_instance_init_check_id) &amp;&amp; !UseTLAB
1035             &amp;&amp; Universe::heap()-&gt;supports_inline_contig_alloc()) {
1036           Label slow_path;
1037           Register obj_size = rcx;
1038           Register t1       = rbx;
1039           Register t2       = rsi;
1040           assert_different_registers(klass, obj, obj_size, t1, t2);
1041 
1042           __ push(rdi);
1043           __ push(rbx);
1044 
1045           if (id == fast_new_instance_init_check_id) {
1046             // make sure the klass is initialized
1047             __ cmpb(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
1048             __ jcc(Assembler::notEqual, slow_path);
1049           }
1050 
1051 #ifdef ASSERT
1052           // assert object can be fast path allocated
1053           {
1054             Label ok, not_ok;
1055             __ movl(obj_size, Address(klass, Klass::layout_helper_offset()));
1056             __ cmpl(obj_size, 0);  // make sure it&#39;s an instance (LH &gt; 0)
1057             __ jcc(Assembler::lessEqual, not_ok);
1058             __ testl(obj_size, Klass::_lh_instance_slow_path_bit);
1059             __ jcc(Assembler::zero, ok);
1060             __ bind(not_ok);
1061             __ stop(&quot;assert(can be fast path allocated)&quot;);
1062             __ should_not_reach_here();
1063             __ bind(ok);
1064           }
1065 #endif // ASSERT
1066 
1067           const Register thread = NOT_LP64(rdi) LP64_ONLY(r15_thread);
1068           NOT_LP64(__ get_thread(thread));
1069 
1070           // get the instance size (size is postive so movl is fine for 64bit)
1071           __ movl(obj_size, Address(klass, Klass::layout_helper_offset()));
1072 
1073           __ eden_allocate(thread, obj, obj_size, 0, t1, slow_path);
1074 
1075           __ initialize_object(obj, klass, obj_size, 0, t1, t2, /* is_tlab_allocated */ false);
1076           __ verify_oop(obj);
1077           __ pop(rbx);
1078           __ pop(rdi);
1079           __ ret(0);
1080 
1081           __ bind(slow_path);
1082           __ pop(rbx);
1083           __ pop(rdi);
1084         }
1085 
1086         __ enter();
1087         OopMap* map = save_live_registers(sasm, 2);
1088         int call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_instance), klass);
1089         oop_maps = new OopMapSet();
1090         oop_maps-&gt;add_gc_map(call_offset, map);
1091         restore_live_registers_except_rax(sasm);
1092         __ verify_oop(obj);
1093         __ leave();
1094         __ ret(0);
1095 
1096         // rax,: new instance
1097       }
1098 
1099       break;
1100 
1101     case counter_overflow_id:
1102       {
1103         Register bci = rax, method = rbx;
1104         __ enter();
1105         OopMap* map = save_live_registers(sasm, 3);
1106         // Retrieve bci
1107         __ movl(bci, Address(rbp, 2*BytesPerWord));
1108         // And a pointer to the Method*
1109         __ movptr(method, Address(rbp, 3*BytesPerWord));
1110         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, counter_overflow), bci, method);
1111         oop_maps = new OopMapSet();
1112         oop_maps-&gt;add_gc_map(call_offset, map);
1113         restore_live_registers(sasm);
1114         __ leave();
1115         __ ret(0);
1116       }
1117       break;
1118 
1119     case new_type_array_id:
1120     case new_object_array_id:
1121     case new_value_array_id:
1122       {
1123         Register length   = rbx; // Incoming
1124         Register klass    = rdx; // Incoming
1125         Register obj      = rax; // Result
1126 
1127         if (id == new_type_array_id) {
1128           __ set_info(&quot;new_type_array&quot;, dont_gc_arguments);
1129         } else if (id == new_object_array_id) {
1130           __ set_info(&quot;new_object_array&quot;, dont_gc_arguments);
1131         } else {
1132           __ set_info(&quot;new_value_array&quot;, dont_gc_arguments);
1133         }
1134 
1135 #ifdef ASSERT
1136         // assert object type is really an array of the proper kind
1137         {
1138           Label ok;
1139           Register t0 = obj;
1140           __ movl(t0, Address(klass, Klass::layout_helper_offset()));
1141           __ sarl(t0, Klass::_lh_array_tag_shift);
1142           switch (id) {
1143           case new_type_array_id:
1144             __ cmpl(t0, Klass::_lh_array_tag_type_value);
1145             __ jcc(Assembler::equal, ok);
1146             __ stop(&quot;assert(is a type array klass)&quot;);
1147             break;
1148           case new_object_array_id:
1149             __ cmpl(t0, Klass::_lh_array_tag_obj_value); // new &quot;[Ljava/lang/Object;&quot;
1150             __ jcc(Assembler::equal, ok);
1151             __ cmpl(t0, Klass::_lh_array_tag_vt_value);  // new &quot;[LVT;&quot;
1152             __ jcc(Assembler::equal, ok);
1153             __ stop(&quot;assert(is an object or value array klass)&quot;);
1154             break;
1155           case new_value_array_id:
1156             // new &quot;[QVT;&quot;
1157             __ cmpl(t0, Klass::_lh_array_tag_vt_value);  // the array can be flattened.
1158             __ jcc(Assembler::equal, ok);
1159             __ cmpl(t0, Klass::_lh_array_tag_obj_value); // the array cannot be flattened (due to ValueArrayElemMaxFlatSize, etc)
1160             __ jcc(Assembler::equal, ok);
1161             __ stop(&quot;assert(is an object or value array klass)&quot;);
1162             break;
1163           default:  ShouldNotReachHere();
1164           }
1165           __ should_not_reach_here();
1166           __ bind(ok);
1167         }
1168 #endif // ASSERT
1169 
1170         // If TLAB is disabled, see if there is support for inlining contiguous
1171         // allocations.
1172         // Otherwise, just go to the slow path.
1173         if (!UseTLAB &amp;&amp; Universe::heap()-&gt;supports_inline_contig_alloc()) {
1174           Register arr_size = rsi;
1175           Register t1       = rcx;  // must be rcx for use as shift count
1176           Register t2       = rdi;
1177           Label slow_path;
1178 
1179           // get the allocation size: round_up(hdr + length &lt;&lt; (layout_helper &amp; 0x1F))
1180           // since size is positive movl does right thing on 64bit
1181           __ movl(t1, Address(klass, Klass::layout_helper_offset()));
1182           // since size is postive movl does right thing on 64bit
1183           __ movl(arr_size, length);
1184           assert(t1 == rcx, &quot;fixed register usage&quot;);
1185           __ shlptr(arr_size /* by t1=rcx, mod 32 */);
1186           __ shrptr(t1, Klass::_lh_header_size_shift);
1187           __ andptr(t1, Klass::_lh_header_size_mask);
1188           __ addptr(arr_size, t1);
1189           __ addptr(arr_size, MinObjAlignmentInBytesMask); // align up
1190           __ andptr(arr_size, ~MinObjAlignmentInBytesMask);
1191 
1192           // Using t2 for non 64-bit.
1193           const Register thread = NOT_LP64(t2) LP64_ONLY(r15_thread);
1194           NOT_LP64(__ get_thread(thread));
1195           __ eden_allocate(thread, obj, arr_size, 0, t1, slow_path);  // preserves arr_size
1196 
1197           __ initialize_header(obj, klass, length, t1, t2);
1198           __ movb(t1, Address(klass, in_bytes(Klass::layout_helper_offset()) + (Klass::_lh_header_size_shift / BitsPerByte)));
1199           assert(Klass::_lh_header_size_shift % BitsPerByte == 0, &quot;bytewise&quot;);
1200           assert(Klass::_lh_header_size_mask &lt;= 0xFF, &quot;bytewise&quot;);
1201           __ andptr(t1, Klass::_lh_header_size_mask);
1202           __ subptr(arr_size, t1);  // body length
1203           __ addptr(t1, obj);       // body start
1204           __ initialize_body(t1, arr_size, 0, t2);
1205           __ verify_oop(obj);
1206           __ ret(0);
1207 
1208           __ bind(slow_path);
1209         }
1210 
1211         __ enter();
1212         OopMap* map = save_live_registers(sasm, 3);
1213         int call_offset;
1214         if (id == new_type_array_id) {
1215           call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_type_array), klass, length);
1216         } else if (id == new_object_array_id) {
1217           call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_object_array), klass, length);
1218         } else {
1219           assert(id == new_value_array_id, &quot;must be&quot;);
1220           call_offset = __ call_RT(obj, noreg, CAST_FROM_FN_PTR(address, new_value_array), klass, length);
1221         }
1222 
1223         oop_maps = new OopMapSet();
1224         oop_maps-&gt;add_gc_map(call_offset, map);
1225         restore_live_registers_except_rax(sasm);
1226 
1227         __ verify_oop(obj);
1228         __ leave();
1229         __ ret(0);
1230 
1231         // rax,: new array
1232       }
1233       break;
1234 
1235     case new_multi_array_id:
1236       { StubFrame f(sasm, &quot;new_multi_array&quot;, dont_gc_arguments);
1237         // rax,: klass
1238         // rbx,: rank
1239         // rcx: address of 1st dimension
1240         OopMap* map = save_live_registers(sasm, 4);
1241         int call_offset = __ call_RT(rax, noreg, CAST_FROM_FN_PTR(address, new_multi_array), rax, rbx, rcx);
1242 
1243         oop_maps = new OopMapSet();
1244         oop_maps-&gt;add_gc_map(call_offset, map);
1245         restore_live_registers_except_rax(sasm);
1246 
1247         // rax,: new multi array
1248         __ verify_oop(rax);
1249       }
1250       break;
1251 
1252     case load_flattened_array_id:
1253       {
1254         StubFrame f(sasm, &quot;load_flattened_array&quot;, dont_gc_arguments);
1255         OopMap* map = save_live_registers(sasm, 3);
1256 
1257         // Called with store_parameter and not C abi
1258 
1259         f.load_argument(1, rax); // rax,: array
1260         f.load_argument(0, rbx); // rbx,: index
1261         int call_offset = __ call_RT(rax, noreg, CAST_FROM_FN_PTR(address, load_flattened_array), rax, rbx);
1262 
1263         oop_maps = new OopMapSet();
1264         oop_maps-&gt;add_gc_map(call_offset, map);
1265         restore_live_registers_except_rax(sasm);
1266 
1267         // rax,: loaded element at array[index]
1268         __ verify_oop(rax);
1269       }
1270       break;
1271 
1272     case store_flattened_array_id:
1273       {
1274         StubFrame f(sasm, &quot;store_flattened_array&quot;, dont_gc_arguments);
1275         OopMap* map = save_live_registers(sasm, 4);
1276 
1277         // Called with store_parameter and not C abi
1278 
1279         f.load_argument(2, rax); // rax,: array
1280         f.load_argument(1, rbx); // rbx,: index
1281         f.load_argument(0, rcx); // rcx,: value
1282         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, store_flattened_array), rax, rbx, rcx);
1283 
1284         oop_maps = new OopMapSet();
1285         oop_maps-&gt;add_gc_map(call_offset, map);
1286         restore_live_registers_except_rax(sasm);
1287       }
1288       break;
1289 
1290     case substitutability_check_id:
1291       {
1292         StubFrame f(sasm, &quot;substitutability_check&quot;, dont_gc_arguments);
1293         OopMap* map = save_live_registers(sasm, 3);
1294 
1295         // Called with store_parameter and not C abi
1296 
1297         f.load_argument(1, rax); // rax,: left
1298         f.load_argument(0, rbx); // rbx,: right
1299         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, substitutability_check), rax, rbx);
1300 
1301         oop_maps = new OopMapSet();
1302         oop_maps-&gt;add_gc_map(call_offset, map);
1303         restore_live_registers_except_rax(sasm);
1304 
1305         // rax,: are the two operands substitutable
1306       }
1307       break;
1308 
1309 
1310     case buffer_value_args_id:
1311     case buffer_value_args_no_receiver_id:
1312       {
1313         const char* name = (id == buffer_value_args_id) ?
1314           &quot;buffer_value_args&quot; : &quot;buffer_value_args_no_receiver&quot;;
1315         StubFrame f(sasm, name, dont_gc_arguments);
1316         OopMap* map = save_live_registers(sasm, 2);
1317         Register method = rbx;
1318         address entry = (id == buffer_value_args_id) ?
1319           CAST_FROM_FN_PTR(address, buffer_value_args) :
1320           CAST_FROM_FN_PTR(address, buffer_value_args_no_receiver);
1321         int call_offset = __ call_RT(rax, noreg, entry, method);
1322         oop_maps = new OopMapSet();
1323         oop_maps-&gt;add_gc_map(call_offset, map);
1324         restore_live_registers_except_rax(sasm);
1325         __ verify_oop(rax);  // rax: an array of buffered value objects
1326       }
1327       break;
1328 
1329     case register_finalizer_id:
1330       {
1331         __ set_info(&quot;register_finalizer&quot;, dont_gc_arguments);
1332 
1333         // This is called via call_runtime so the arguments
1334         // will be place in C abi locations
1335 
1336 #ifdef _LP64
1337         __ verify_oop(c_rarg0);
1338         __ mov(rax, c_rarg0);
1339 #else
1340         // The object is passed on the stack and we haven&#39;t pushed a
1341         // frame yet so it&#39;s one work away from top of stack.
1342         __ movptr(rax, Address(rsp, 1 * BytesPerWord));
1343         __ verify_oop(rax);
1344 #endif // _LP64
1345 
1346         // load the klass and check the has finalizer flag
1347         Label register_finalizer;
1348         Register t = rsi;
1349         __ load_klass(t, rax);
1350         __ movl(t, Address(t, Klass::access_flags_offset()));
1351         __ testl(t, JVM_ACC_HAS_FINALIZER);
1352         __ jcc(Assembler::notZero, register_finalizer);
1353         __ ret(0);
1354 
1355         __ bind(register_finalizer);
1356         __ enter();
1357         OopMap* oop_map = save_live_registers(sasm, 2 /*num_rt_args */);
1358         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, SharedRuntime::register_finalizer), rax);
1359         oop_maps = new OopMapSet();
1360         oop_maps-&gt;add_gc_map(call_offset, oop_map);
1361 
1362         // Now restore all the live registers
1363         restore_live_registers(sasm);
1364 
1365         __ leave();
1366         __ ret(0);
1367       }
1368       break;
1369 
1370     case throw_range_check_failed_id:
1371       { StubFrame f(sasm, &quot;range_check_failed&quot;, dont_gc_arguments);
1372         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_range_check_exception), true);
1373       }
1374       break;
1375 
1376     case throw_index_exception_id:
1377       { StubFrame f(sasm, &quot;index_range_check_failed&quot;, dont_gc_arguments);
1378         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_index_exception), true);
1379       }
1380       break;
1381 
1382     case throw_div0_exception_id:
1383       { StubFrame f(sasm, &quot;throw_div0_exception&quot;, dont_gc_arguments);
1384         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_div0_exception), false);
1385       }
1386       break;
1387 
1388     case throw_null_pointer_exception_id:
1389       { StubFrame f(sasm, &quot;throw_null_pointer_exception&quot;, dont_gc_arguments);
1390         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_null_pointer_exception), false);
1391       }
1392       break;
1393 
1394     case handle_exception_nofpu_id:
1395     case handle_exception_id:
1396       { StubFrame f(sasm, &quot;handle_exception&quot;, dont_gc_arguments);
1397         oop_maps = generate_handle_exception(id, sasm);
1398       }
1399       break;
1400 
1401     case handle_exception_from_callee_id:
1402       { StubFrame f(sasm, &quot;handle_exception_from_callee&quot;, dont_gc_arguments);
1403         oop_maps = generate_handle_exception(id, sasm);
1404       }
1405       break;
1406 
1407     case unwind_exception_id:
1408       { __ set_info(&quot;unwind_exception&quot;, dont_gc_arguments);
1409         // note: no stubframe since we are about to leave the current
1410         //       activation and we are calling a leaf VM function only.
1411         generate_unwind_exception(sasm);
1412       }
1413       break;
1414 
1415     case throw_array_store_exception_id:
1416       { StubFrame f(sasm, &quot;throw_array_store_exception&quot;, dont_gc_arguments);
1417         // tos + 0: link
1418         //     + 1: return address
1419         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_array_store_exception), true);
1420       }
1421       break;
1422 
1423     case throw_class_cast_exception_id:
1424       { StubFrame f(sasm, &quot;throw_class_cast_exception&quot;, dont_gc_arguments);
1425         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_class_cast_exception), true);
1426       }
1427       break;
1428 
1429     case throw_incompatible_class_change_error_id:
1430       { StubFrame f(sasm, &quot;throw_incompatible_class_change_error&quot;, dont_gc_arguments);
1431         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_incompatible_class_change_error), false);
1432       }
1433       break;
1434 
1435     case throw_illegal_monitor_state_exception_id:
1436       { StubFrame f(sasm, &quot;throw_illegal_monitor_state_exception&quot;, dont_gc_arguments);
1437         oop_maps = generate_exception_throw(sasm, CAST_FROM_FN_PTR(address, throw_illegal_monitor_state_exception), false);
1438       }
1439       break;
1440 
1441     case slow_subtype_check_id:
1442       {
1443         // Typical calling sequence:
1444         // __ push(klass_RInfo);  // object klass or other subclass
1445         // __ push(sup_k_RInfo);  // array element klass or other superclass
1446         // __ call(slow_subtype_check);
1447         // Note that the subclass is pushed first, and is therefore deepest.
1448         // Previous versions of this code reversed the names &#39;sub&#39; and &#39;super&#39;.
1449         // This was operationally harmless but made the code unreadable.
1450         enum layout {
1451           rax_off, SLOT2(raxH_off)
1452           rcx_off, SLOT2(rcxH_off)
1453           rsi_off, SLOT2(rsiH_off)
1454           rdi_off, SLOT2(rdiH_off)
1455           // saved_rbp_off, SLOT2(saved_rbpH_off)
1456           return_off, SLOT2(returnH_off)
1457           sup_k_off, SLOT2(sup_kH_off)
1458           klass_off, SLOT2(superH_off)
1459           framesize,
1460           result_off = klass_off  // deepest argument is also the return value
1461         };
1462 
1463         __ set_info(&quot;slow_subtype_check&quot;, dont_gc_arguments);
1464         __ push(rdi);
1465         __ push(rsi);
1466         __ push(rcx);
1467         __ push(rax);
1468 
1469         // This is called by pushing args and not with C abi
1470         __ movptr(rsi, Address(rsp, (klass_off) * VMRegImpl::stack_slot_size)); // subclass
1471         __ movptr(rax, Address(rsp, (sup_k_off) * VMRegImpl::stack_slot_size)); // superclass
1472 
1473         Label miss;
1474         __ check_klass_subtype_slow_path(rsi, rax, rcx, rdi, NULL, &amp;miss);
1475 
1476         // fallthrough on success:
1477         __ movptr(Address(rsp, (result_off) * VMRegImpl::stack_slot_size), 1); // result
1478         __ pop(rax);
1479         __ pop(rcx);
1480         __ pop(rsi);
1481         __ pop(rdi);
1482         __ ret(0);
1483 
1484         __ bind(miss);
1485         __ movptr(Address(rsp, (result_off) * VMRegImpl::stack_slot_size), NULL_WORD); // result
1486         __ pop(rax);
1487         __ pop(rcx);
1488         __ pop(rsi);
1489         __ pop(rdi);
1490         __ ret(0);
1491       }
1492       break;
1493 
1494     case monitorenter_nofpu_id:
1495       save_fpu_registers = false;
1496       // fall through
1497     case monitorenter_id:
1498       {
1499         StubFrame f(sasm, &quot;monitorenter&quot;, dont_gc_arguments);
1500         OopMap* map = save_live_registers(sasm, 3, save_fpu_registers);
1501 
1502         // Called with store_parameter and not C abi
1503 
1504         f.load_argument(1, rax); // rax,: object
1505         f.load_argument(0, rbx); // rbx,: lock address
1506 
1507         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, monitorenter), rax, rbx);
1508 
1509         oop_maps = new OopMapSet();
1510         oop_maps-&gt;add_gc_map(call_offset, map);
1511         restore_live_registers(sasm, save_fpu_registers);
1512       }
1513       break;
1514 
1515     case monitorexit_nofpu_id:
1516       save_fpu_registers = false;
1517       // fall through
1518     case monitorexit_id:
1519       {
1520         StubFrame f(sasm, &quot;monitorexit&quot;, dont_gc_arguments);
1521         OopMap* map = save_live_registers(sasm, 2, save_fpu_registers);
1522 
1523         // Called with store_parameter and not C abi
1524 
1525         f.load_argument(0, rax); // rax,: lock address
1526 
1527         // note: really a leaf routine but must setup last java sp
1528         //       =&gt; use call_RT for now (speed can be improved by
1529         //       doing last java sp setup manually)
1530         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, monitorexit), rax);
1531 
1532         oop_maps = new OopMapSet();
1533         oop_maps-&gt;add_gc_map(call_offset, map);
1534         restore_live_registers(sasm, save_fpu_registers);
1535       }
1536       break;
1537 
1538     case deoptimize_id:
1539       {
1540         StubFrame f(sasm, &quot;deoptimize&quot;, dont_gc_arguments);
1541         const int num_rt_args = 2;  // thread, trap_request
1542         OopMap* oop_map = save_live_registers(sasm, num_rt_args);
1543         f.load_argument(0, rax);
1544         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, deoptimize), rax);
1545         oop_maps = new OopMapSet();
1546         oop_maps-&gt;add_gc_map(call_offset, oop_map);
1547         restore_live_registers(sasm);
1548         DeoptimizationBlob* deopt_blob = SharedRuntime::deopt_blob();
1549         assert(deopt_blob != NULL, &quot;deoptimization blob must have been created&quot;);
1550         __ leave();
1551         __ jump(RuntimeAddress(deopt_blob-&gt;unpack_with_reexecution()));
1552       }
1553       break;
1554 
1555     case access_field_patching_id:
1556       { StubFrame f(sasm, &quot;access_field_patching&quot;, dont_gc_arguments);
1557         // we should set up register map
1558         oop_maps = generate_patching(sasm, CAST_FROM_FN_PTR(address, access_field_patching));
1559       }
1560       break;
1561 
1562     case load_klass_patching_id:
1563       { StubFrame f(sasm, &quot;load_klass_patching&quot;, dont_gc_arguments);
1564         // we should set up register map
1565         oop_maps = generate_patching(sasm, CAST_FROM_FN_PTR(address, move_klass_patching));
1566       }
1567       break;
1568 
1569     case load_mirror_patching_id:
1570       { StubFrame f(sasm, &quot;load_mirror_patching&quot;, dont_gc_arguments);
1571         // we should set up register map
1572         oop_maps = generate_patching(sasm, CAST_FROM_FN_PTR(address, move_mirror_patching));
1573       }
1574       break;
1575 
1576     case load_appendix_patching_id:
1577       { StubFrame f(sasm, &quot;load_appendix_patching&quot;, dont_gc_arguments);
1578         // we should set up register map
1579         oop_maps = generate_patching(sasm, CAST_FROM_FN_PTR(address, move_appendix_patching));
1580       }
1581       break;
1582 
1583     case dtrace_object_alloc_id:
1584       { // rax,: object
1585         StubFrame f(sasm, &quot;dtrace_object_alloc&quot;, dont_gc_arguments);
1586         // we can&#39;t gc here so skip the oopmap but make sure that all
1587         // the live registers get saved.
1588         save_live_registers(sasm, 1);
1589 
1590         __ NOT_LP64(push(rax)) LP64_ONLY(mov(c_rarg0, rax));
1591         __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc)));
1592         NOT_LP64(__ pop(rax));
1593 
1594         restore_live_registers(sasm);
1595       }
1596       break;
1597 
1598     case fpu2long_stub_id:
1599       {
1600 #ifdef _LP64
1601         Label done;
1602         __ cvttsd2siq(rax, Address(rsp, wordSize));
1603         __ cmp64(rax, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
1604         __ jccb(Assembler::notEqual, done);
1605         __ movq(rax, Address(rsp, wordSize));
1606         __ subptr(rsp, 8);
1607         __ movq(Address(rsp, 0), rax);
1608         __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));
1609         __ pop(rax);
1610         __ bind(done);
1611         __ ret(0);
1612 #else
1613         // rax, and rdx are destroyed, but should be free since the result is returned there
1614         // preserve rsi,ecx
1615         __ push(rsi);
1616         __ push(rcx);
1617 
1618         // check for NaN
1619         Label return0, do_return, return_min_jlong, do_convert;
1620 
1621         Address value_high_word(rsp, wordSize + 4);
1622         Address value_low_word(rsp, wordSize);
1623         Address result_high_word(rsp, 3*wordSize + 4);
1624         Address result_low_word(rsp, 3*wordSize);
1625 
1626         __ subptr(rsp, 32);                    // more than enough on 32bit
1627         __ fst_d(value_low_word);
1628         __ movl(rax, value_high_word);
1629         __ andl(rax, 0x7ff00000);
1630         __ cmpl(rax, 0x7ff00000);
1631         __ jcc(Assembler::notEqual, do_convert);
1632         __ movl(rax, value_high_word);
1633         __ andl(rax, 0xfffff);
1634         __ orl(rax, value_low_word);
1635         __ jcc(Assembler::notZero, return0);
1636 
1637         __ bind(do_convert);
1638         __ fnstcw(Address(rsp, 0));
1639         __ movzwl(rax, Address(rsp, 0));
1640         __ orl(rax, 0xc00);
1641         __ movw(Address(rsp, 2), rax);
1642         __ fldcw(Address(rsp, 2));
1643         __ fwait();
1644         __ fistp_d(result_low_word);
1645         __ fldcw(Address(rsp, 0));
1646         __ fwait();
1647         // This gets the entire long in rax on 64bit
1648         __ movptr(rax, result_low_word);
1649         // testing of high bits
1650         __ movl(rdx, result_high_word);
1651         __ mov(rcx, rax);
1652         // What the heck is the point of the next instruction???
1653         __ xorl(rcx, 0x0);
1654         __ movl(rsi, 0x80000000);
1655         __ xorl(rsi, rdx);
1656         __ orl(rcx, rsi);
1657         __ jcc(Assembler::notEqual, do_return);
1658         __ fldz();
1659         __ fcomp_d(value_low_word);
1660         __ fnstsw_ax();
1661         __ sahf();
1662         __ jcc(Assembler::above, return_min_jlong);
1663         // return max_jlong
1664         __ movl(rdx, 0x7fffffff);
1665         __ movl(rax, 0xffffffff);
1666         __ jmp(do_return);
1667 
1668         __ bind(return_min_jlong);
1669         __ movl(rdx, 0x80000000);
1670         __ xorl(rax, rax);
1671         __ jmp(do_return);
1672 
1673         __ bind(return0);
1674         __ fpop();
1675         __ xorptr(rdx,rdx);
1676         __ xorptr(rax,rax);
1677 
1678         __ bind(do_return);
1679         __ addptr(rsp, 32);
1680         __ pop(rcx);
1681         __ pop(rsi);
1682         __ ret(0);
1683 #endif // _LP64
1684       }
1685       break;
1686 
1687     case predicate_failed_trap_id:
1688       {
1689         StubFrame f(sasm, &quot;predicate_failed_trap&quot;, dont_gc_arguments);
1690 
1691         OopMap* map = save_live_registers(sasm, 1);
1692 
1693         int call_offset = __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, predicate_failed_trap));
1694         oop_maps = new OopMapSet();
1695         oop_maps-&gt;add_gc_map(call_offset, map);
1696         restore_live_registers(sasm);
1697         __ leave();
1698         DeoptimizationBlob* deopt_blob = SharedRuntime::deopt_blob();
1699         assert(deopt_blob != NULL, &quot;deoptimization blob must have been created&quot;);
1700 
1701         __ jump(RuntimeAddress(deopt_blob-&gt;unpack_with_reexecution()));
1702       }
1703       break;
1704 
1705     default:
1706       { StubFrame f(sasm, &quot;unimplemented entry&quot;, dont_gc_arguments);
1707         __ movptr(rax, (int)id);
1708         __ call_RT(noreg, noreg, CAST_FROM_FN_PTR(address, unimplemented_entry), rax);
1709         __ should_not_reach_here();
1710       }
1711       break;
1712   }
1713   return oop_maps;
1714 }
1715 
1716 #undef __
1717 
1718 const char *Runtime1::pd_name_for_address(address entry) {
1719   return &quot;&lt;unknown function&gt;&quot;;
1720 }
    </pre>
  </body>
</html>
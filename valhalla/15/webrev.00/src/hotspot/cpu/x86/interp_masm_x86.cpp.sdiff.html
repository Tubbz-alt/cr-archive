<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/interp_masm_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globals_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interp_masm_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/interp_masm_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1750 
1751     // If no method data exists, go to profile_continue.
1752     test_method_data_pointer(mdp, profile_continue);
1753 
1754     Label skip_receiver_profile;
1755     if (receiver_can_be_null) {
1756       Label not_null;
1757       testptr(receiver, receiver);
1758       jccb(Assembler::notZero, not_null);
1759       // We are making a call.  Increment the count for null receiver.
1760       increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));
1761       jmp(skip_receiver_profile);
1762       bind(not_null);
1763     }
1764 
1765     // Record the receiver type.
1766     record_klass_in_profile(receiver, mdp, reg2, true);
1767     bind(skip_receiver_profile);
1768 
1769     // The method data pointer needs to be updated to reflect the new target.
<span class="line-removed">1770 #if INCLUDE_JVMCI</span>
<span class="line-removed">1771     if (MethodProfileWidth == 0) {</span>
<span class="line-removed">1772       update_mdp_by_constant(mdp, in_bytes(VirtualCallData::virtual_call_data_size()));</span>
<span class="line-removed">1773     }</span>
<span class="line-removed">1774 #else // INCLUDE_JVMCI</span>
<span class="line-removed">1775     update_mdp_by_constant(mdp,</span>
<span class="line-removed">1776                            in_bytes(VirtualCallData::</span>
<span class="line-removed">1777                                     virtual_call_data_size()));</span>
<span class="line-removed">1778 #endif // INCLUDE_JVMCI</span>
<span class="line-removed">1779     bind(profile_continue);</span>
<span class="line-removed">1780   }</span>
<span class="line-removed">1781 }</span>
<span class="line-removed">1782 </span>
<span class="line-removed">1783 #if INCLUDE_JVMCI</span>
<span class="line-removed">1784 void InterpreterMacroAssembler::profile_called_method(Register method, Register mdp, Register reg2) {</span>
<span class="line-removed">1785   assert_different_registers(method, mdp, reg2);</span>
<span class="line-removed">1786   if (ProfileInterpreter &amp;&amp; MethodProfileWidth &gt; 0) {</span>
<span class="line-removed">1787     Label profile_continue;</span>
<span class="line-removed">1788 </span>
<span class="line-removed">1789     // If no method data exists, go to profile_continue.</span>
<span class="line-removed">1790     test_method_data_pointer(mdp, profile_continue);</span>
<span class="line-removed">1791 </span>
<span class="line-removed">1792     Label done;</span>
<span class="line-removed">1793     record_item_in_profile_helper(method, mdp, reg2, 0, done, MethodProfileWidth,</span>
<span class="line-removed">1794       &amp;VirtualCallData::method_offset, &amp;VirtualCallData::method_count_offset, in_bytes(VirtualCallData::nonprofiled_receiver_count_offset()));</span>
<span class="line-removed">1795     bind(done);</span>
<span class="line-removed">1796 </span>
1797     update_mdp_by_constant(mdp, in_bytes(VirtualCallData::virtual_call_data_size()));
1798     bind(profile_continue);
1799   }
1800 }
<span class="line-removed">1801 #endif // INCLUDE_JVMCI</span>
1802 
1803 // This routine creates a state machine for updating the multi-row
1804 // type profile at a virtual call site (or other type-sensitive bytecode).
1805 // The machine visits each row (of receiver/count) until the receiver type
1806 // is found, or until it runs out of rows.  At the same time, it remembers
1807 // the location of the first empty row.  (An empty row records null for its
1808 // receiver, and can be allocated for a newly-observed receiver type.)
1809 // Because there are two degrees of freedom in the state, a simple linear
1810 // search will not work; it must be a decision tree.  Hence this helper
1811 // function is recursive, to generate the required tree structured code.
1812 // It&#39;s the interpreter, so we are trading off code space for speed.
1813 // See below for example code.
1814 void InterpreterMacroAssembler::record_klass_in_profile_helper(
1815                                         Register receiver, Register mdp,
1816                                         Register reg2, int start_row,
1817                                         Label&amp; done, bool is_virtual_call) {
1818   if (TypeProfileWidth == 0) {
1819     if (is_virtual_call) {
1820       increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));
1821     }
</pre>
</td>
<td>
<hr />
<pre>
1750 
1751     // If no method data exists, go to profile_continue.
1752     test_method_data_pointer(mdp, profile_continue);
1753 
1754     Label skip_receiver_profile;
1755     if (receiver_can_be_null) {
1756       Label not_null;
1757       testptr(receiver, receiver);
1758       jccb(Assembler::notZero, not_null);
1759       // We are making a call.  Increment the count for null receiver.
1760       increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));
1761       jmp(skip_receiver_profile);
1762       bind(not_null);
1763     }
1764 
1765     // Record the receiver type.
1766     record_klass_in_profile(receiver, mdp, reg2, true);
1767     bind(skip_receiver_profile);
1768 
1769     // The method data pointer needs to be updated to reflect the new target.



























1770     update_mdp_by_constant(mdp, in_bytes(VirtualCallData::virtual_call_data_size()));
1771     bind(profile_continue);
1772   }
1773 }

1774 
1775 // This routine creates a state machine for updating the multi-row
1776 // type profile at a virtual call site (or other type-sensitive bytecode).
1777 // The machine visits each row (of receiver/count) until the receiver type
1778 // is found, or until it runs out of rows.  At the same time, it remembers
1779 // the location of the first empty row.  (An empty row records null for its
1780 // receiver, and can be allocated for a newly-observed receiver type.)
1781 // Because there are two degrees of freedom in the state, a simple linear
1782 // search will not work; it must be a decision tree.  Hence this helper
1783 // function is recursive, to generate the required tree structured code.
1784 // It&#39;s the interpreter, so we are trading off code space for speed.
1785 // See below for example code.
1786 void InterpreterMacroAssembler::record_klass_in_profile_helper(
1787                                         Register receiver, Register mdp,
1788                                         Register reg2, int start_row,
1789                                         Label&amp; done, bool is_virtual_call) {
1790   if (TypeProfileWidth == 0) {
1791     if (is_virtual_call) {
1792       increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));
1793     }
</pre>
</td>
</tr>
</table>
<center><a href="globals_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interp_masm_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/assembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../sparc/vm_version_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/assembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 231       code_section()-&gt;relocate(inst_mark(), rspec, disp32_operand);
 232     else
 233       code_section()-&gt;relocate(inst_mark(), rspec, format);
 234   }
 235   emit_int32(data);
 236 }
 237 
 238 static int encode(Register r) {
 239   int enc = r-&gt;encoding();
 240   if (enc &gt;= 8) {
 241     enc -= 8;
 242   }
 243   return enc;
 244 }
 245 
 246 void Assembler::emit_arith_b(int op1, int op2, Register dst, int imm8) {
 247   assert(dst-&gt;has_byte_register(), &quot;must have byte register&quot;);
 248   assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
 249   assert(isByte(imm8), &quot;not a byte&quot;);
 250   assert((op1 &amp; 0x01) == 0, &quot;should be 8bit operation&quot;);
<span class="line-modified"> 251   emit_int8(op1);</span>
<span class="line-removed"> 252   emit_int8(op2 | encode(dst));</span>
<span class="line-removed"> 253   emit_int8(imm8);</span>
 254 }
 255 
 256 
 257 void Assembler::emit_arith(int op1, int op2, Register dst, int32_t imm32) {
 258   assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
 259   assert((op1 &amp; 0x01) == 1, &quot;should be 32bit operation&quot;);
 260   assert((op1 &amp; 0x02) == 0, &quot;sign-extension bit should not be set&quot;);
 261   if (is8bit(imm32)) {
<span class="line-modified"> 262     emit_int8(op1 | 0x02); // set sign bit</span>
<span class="line-modified"> 263     emit_int8(op2 | encode(dst));</span>
<span class="line-modified"> 264     emit_int8(imm32 &amp; 0xFF);</span>
 265   } else {
<span class="line-modified"> 266     emit_int8(op1);</span>
<span class="line-removed"> 267     emit_int8(op2 | encode(dst));</span>
 268     emit_int32(imm32);
 269   }
 270 }
 271 
 272 // Force generation of a 4 byte immediate value even if it fits into 8bit
 273 void Assembler::emit_arith_imm32(int op1, int op2, Register dst, int32_t imm32) {
 274   assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
 275   assert((op1 &amp; 0x01) == 1, &quot;should be 32bit operation&quot;);
 276   assert((op1 &amp; 0x02) == 0, &quot;sign-extension bit should not be set&quot;);
<span class="line-modified"> 277   emit_int8(op1);</span>
<span class="line-removed"> 278   emit_int8(op2 | encode(dst));</span>
 279   emit_int32(imm32);
 280 }
 281 
 282 // immediate-to-memory forms
 283 void Assembler::emit_arith_operand(int op1, Register rm, Address adr, int32_t imm32) {
 284   assert((op1 &amp; 0x01) == 1, &quot;should be 32bit operation&quot;);
 285   assert((op1 &amp; 0x02) == 0, &quot;sign-extension bit should not be set&quot;);
 286   if (is8bit(imm32)) {
 287     emit_int8(op1 | 0x02); // set sign bit
 288     emit_operand(rm, adr, 1);
 289     emit_int8(imm32 &amp; 0xFF);
 290   } else {
 291     emit_int8(op1);
 292     emit_operand(rm, adr, 4);
 293     emit_int32(imm32);
 294   }
 295 }
 296 
 297 
 298 void Assembler::emit_arith(int op1, int op2, Register dst, Register src) {
 299   assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
<span class="line-modified"> 300   emit_int8(op1);</span>
<span class="line-removed"> 301   emit_int8(op2 | encode(dst) &lt;&lt; 3 | encode(src));</span>
 302 }
 303 
 304 
 305 bool Assembler::query_compressed_disp_byte(int disp, bool is_evex_inst, int vector_len,
 306                                            int cur_tuple_type, int in_size_in_bits, int cur_encoding) {
 307   int mod_idx = 0;
 308   // We will test if the displacement fits the compressed format and if so
 309   // apply the compression to the displacment iff the result is8bit.
 310   if (VM_Version::supports_evex() &amp;&amp; is_evex_inst) {
 311     switch (cur_tuple_type) {
 312     case EVEX_FV:
 313       if ((cur_encoding &amp; VEX_W) == VEX_W) {
 314         mod_idx = ((cur_encoding &amp; EVEX_Rb) == EVEX_Rb) ? 3 : 2;
 315       } else {
 316         mod_idx = ((cur_encoding &amp; EVEX_Rb) == EVEX_Rb) ? 1 : 0;
 317       }
 318       break;
 319 
 320     case EVEX_HV:
 321       mod_idx = ((cur_encoding &amp; EVEX_Rb) == EVEX_Rb) ? 1 : 0;
</pre>
<hr />
<pre>
 458       assert(0, &quot;no valid evex tuple_table entry&quot;);
 459       break;
 460     }
 461 
 462     int vector_len = _attributes-&gt;get_vector_len();
 463     if (vector_len &gt;= AVX_128bit &amp;&amp; vector_len &lt;= AVX_512bit) {
 464       int disp_factor = tuple_table[tuple_type + mod_idx][vector_len];
 465       if ((disp % disp_factor) == 0) {
 466         int new_disp = disp / disp_factor;
 467         if (is8bit(new_disp)) {
 468           disp = new_disp;
 469         }
 470       } else {
 471         return false;
 472       }
 473     }
 474   }
 475   return is8bit(disp);
 476 }
 477 



 478 
<span class="line-modified"> 479 void Assembler::emit_operand(Register reg, Register base, Register index,</span>
<span class="line-modified"> 480                              Address::ScaleFactor scale, int disp,</span>
<span class="line-modified"> 481                              RelocationHolder const&amp; rspec,</span>
<span class="line-modified"> 482                              int rip_relative_correction) {</span>
<span class="line-modified"> 483   relocInfo::relocType rtype = (relocInfo::relocType) rspec.type();</span>



































 484 
<span class="line-modified"> 485   // Encode the registers as needed in the fields they are used in</span>






 486 
<span class="line-modified"> 487   int regenc = encode(reg) &lt;&lt; 3;</span>
<span class="line-modified"> 488   int indexenc = index-&gt;is_valid() ? encode(index) &lt;&lt; 3 : 0;</span>
<span class="line-modified"> 489   int baseenc = base-&gt;is_valid() ? encode(base) : 0;</span>


 490 
<span class="line-modified"> 491   if (base-&gt;is_valid()) {</span>
<span class="line-modified"> 492     if (index-&gt;is_valid()) {</span>
 493       assert(scale != Address::no_scale, &quot;inconsistent address&quot;);
 494       // [base + index*scale + disp]
<span class="line-modified"> 495       if (disp == 0 &amp;&amp; rtype == relocInfo::none  &amp;&amp;</span>
<span class="line-modified"> 496           base != rbp LP64_ONLY(&amp;&amp; base != r13)) {</span>
 497         // [base + index*scale]
 498         // [00 reg 100][ss index base]
<span class="line-modified"> 499         assert(index != rsp, &quot;illegal addressing mode&quot;);</span>
<span class="line-modified"> 500         emit_int8(0x04 | regenc);</span>
<span class="line-modified"> 501         emit_int8(scale &lt;&lt; 6 | indexenc | baseenc);</span>
<span class="line-removed"> 502       } else if (emit_compressed_disp_byte(disp) &amp;&amp; rtype == relocInfo::none) {</span>
 503         // [base + index*scale + imm8]
 504         // [01 reg 100][ss index base] imm8
<span class="line-modified"> 505         assert(index != rsp, &quot;illegal addressing mode&quot;);</span>
<span class="line-modified"> 506         emit_int8(0x44 | regenc);</span>
<span class="line-modified"> 507         emit_int8(scale &lt;&lt; 6 | indexenc | baseenc);</span>
<span class="line-removed"> 508         emit_int8(disp &amp; 0xFF);</span>
 509       } else {
 510         // [base + index*scale + disp32]
 511         // [10 reg 100][ss index base] disp32
<span class="line-modified"> 512         assert(index != rsp, &quot;illegal addressing mode&quot;);</span>
<span class="line-modified"> 513         emit_int8(0x84 | regenc);</span>
<span class="line-removed"> 514         emit_int8(scale &lt;&lt; 6 | indexenc | baseenc);</span>
 515         emit_data(disp, rspec, disp32_operand);
 516       }
<span class="line-modified"> 517     } else if (base == rsp LP64_ONLY(|| base == r12)) {</span>
 518       // [rsp + disp]
<span class="line-modified"> 519       if (disp == 0 &amp;&amp; rtype == relocInfo::none) {</span>
 520         // [rsp]
 521         // [00 reg 100][00 100 100]
<span class="line-modified"> 522         emit_int8(0x04 | regenc);</span>
<span class="line-modified"> 523         emit_int8(0x24);</span>
<span class="line-modified"> 524       } else if (emit_compressed_disp_byte(disp) &amp;&amp; rtype == relocInfo::none) {</span>
 525         // [rsp + imm8]
 526         // [01 reg 100][00 100 100] disp8
<span class="line-modified"> 527         emit_int8(0x44 | regenc);</span>
<span class="line-modified"> 528         emit_int8(0x24);</span>
<span class="line-modified"> 529         emit_int8(disp &amp; 0xFF);</span>
 530       } else {
 531         // [rsp + imm32]
 532         // [10 reg 100][00 100 100] disp32
<span class="line-modified"> 533         emit_int8(0x84 | regenc);</span>
<span class="line-modified"> 534         emit_int8(0x24);</span>
 535         emit_data(disp, rspec, disp32_operand);
 536       }
 537     } else {
 538       // [base + disp]
<span class="line-modified"> 539       assert(base != rsp LP64_ONLY(&amp;&amp; base != r12), &quot;illegal addressing mode&quot;);</span>
<span class="line-modified"> 540       if (disp == 0 &amp;&amp; rtype == relocInfo::none &amp;&amp;</span>
<span class="line-modified"> 541           base != rbp LP64_ONLY(&amp;&amp; base != r13)) {</span>
 542         // [base]
 543         // [00 reg base]
<span class="line-modified"> 544         emit_int8(0x00 | regenc | baseenc);</span>
<span class="line-modified"> 545       } else if (emit_compressed_disp_byte(disp) &amp;&amp; rtype == relocInfo::none) {</span>
 546         // [base + disp8]
 547         // [01 reg base] disp8
<span class="line-modified"> 548         emit_int8(0x40 | regenc | baseenc);</span>
<span class="line-modified"> 549         emit_int8(disp &amp; 0xFF);</span>
 550       } else {
 551         // [base + disp32]
 552         // [10 reg base] disp32
<span class="line-modified"> 553         emit_int8(0x80 | regenc | baseenc);</span>
 554         emit_data(disp, rspec, disp32_operand);
 555       }
 556     }
 557   } else {
<span class="line-modified"> 558     if (index-&gt;is_valid()) {</span>
 559       assert(scale != Address::no_scale, &quot;inconsistent address&quot;);

 560       // [index*scale + disp]
 561       // [00 reg 100][ss index 101] disp32
<span class="line-modified"> 562       assert(index != rsp, &quot;illegal addressing mode&quot;);</span>
<span class="line-modified"> 563       emit_int8(0x04 | regenc);</span>
<span class="line-removed"> 564       emit_int8(scale &lt;&lt; 6 | indexenc | 0x05);</span>
 565       emit_data(disp, rspec, disp32_operand);
<span class="line-modified"> 566     } else if (rtype != relocInfo::none ) {</span>

 567       // [disp] (64bit) RIP-RELATIVE (32bit) abs
<span class="line-modified"> 568       // [00 000 101] disp32</span>
 569 
<span class="line-modified"> 570       emit_int8(0x05 | regenc);</span>
 571       // Note that the RIP-rel. correction applies to the generated
 572       // disp field, but _not_ to the target address in the rspec.
 573 
 574       // disp was created by converting the target address minus the pc
 575       // at the start of the instruction. That needs more correction here.
 576       // intptr_t disp = target - next_ip;
 577       assert(inst_mark() != NULL, &quot;must be inside InstructionMark&quot;);
 578       address next_ip = pc() + sizeof(int32_t) + rip_relative_correction;
 579       int64_t adjusted = disp;
 580       // Do rip-rel adjustment for 64bit
 581       LP64_ONLY(adjusted -=  (next_ip - inst_mark()));
 582       assert(is_simm32(adjusted),
 583              &quot;must be 32bit offset (RIP relative address)&quot;);
 584       emit_data((int32_t) adjusted, rspec, disp32_operand);
 585 
 586     } else {

 587       // 32bit never did this, did everything as the rip-rel/disp code above
 588       // [disp] ABSOLUTE
 589       // [00 reg 100][00 100 101] disp32
<span class="line-modified"> 590       emit_int8(0x04 | regenc);</span>
<span class="line-modified"> 591       emit_int8(0x25);</span>
 592       emit_data(disp, rspec, disp32_operand);
 593     }
 594   }
 595 }
 596 
<span class="line-modified"> 597 void Assembler::emit_operand(XMMRegister reg, Register base, Register index,</span>









 598                              Address::ScaleFactor scale, int disp,
 599                              RelocationHolder const&amp; rspec) {
<span class="line-modified"> 600   if (UseAVX &gt; 2) {</span>
<span class="line-modified"> 601     int xreg_enc = reg-&gt;encoding();</span>
<span class="line-modified"> 602     if (xreg_enc &gt; 15) {</span>
<span class="line-modified"> 603       XMMRegister new_reg = as_XMMRegister(xreg_enc &amp; 0xf);</span>
<span class="line-removed"> 604       emit_operand((Register)new_reg, base, index, scale, disp, rspec);</span>
<span class="line-removed"> 605       return;</span>
<span class="line-removed"> 606     }</span>
<span class="line-removed"> 607   }</span>
<span class="line-removed"> 608   emit_operand((Register)reg, base, index, scale, disp, rspec);</span>
 609 }
 610 
<span class="line-modified"> 611 void Assembler::emit_operand(XMMRegister reg, Register base, XMMRegister index,</span>
 612                              Address::ScaleFactor scale, int disp,
 613                              RelocationHolder const&amp; rspec) {
<span class="line-modified"> 614   if (UseAVX &gt; 2) {</span>
<span class="line-modified"> 615     int xreg_enc = reg-&gt;encoding();</span>
<span class="line-modified"> 616     int xmmindex_enc = index-&gt;encoding();</span>
<span class="line-modified"> 617     XMMRegister new_reg = as_XMMRegister(xreg_enc &amp; 0xf);</span>
<span class="line-removed"> 618     XMMRegister new_index = as_XMMRegister(xmmindex_enc &amp; 0xf);</span>
<span class="line-removed"> 619     emit_operand((Register)new_reg, base, (Register)new_index, scale, disp, rspec);</span>
<span class="line-removed"> 620   } else {</span>
<span class="line-removed"> 621     emit_operand((Register)reg, base, (Register)index, scale, disp, rspec);</span>
<span class="line-removed"> 622   }</span>
 623 }
 624 
<span class="line-removed"> 625 </span>
 626 // Secret local extension to Assembler::WhichOperand:
 627 #define end_pc_operand (_WhichOperand_limit)
 628 
 629 address Assembler::locate_operand(address inst, WhichOperand which) {
 630   // Decode the given instruction, and return the address of
 631   // an embedded 32-bit operand word.
 632 
 633   // If &quot;which&quot; is disp32_operand, selects the displacement portion
 634   // of an effective address specifier.
 635   // If &quot;which&quot; is imm64_operand, selects the trailing immediate constant.
 636   // If &quot;which&quot; is call32_operand, selects the displacement of a call or jump.
 637   // Caller is responsible for ensuring that there is such an operand,
 638   // and that it is 32/64 bits wide.
 639 
 640   // If &quot;which&quot; is end_pc_operand, find the end of the instruction.
 641 
 642   address ip = inst;
 643   bool is_64bit = false;
 644 
 645   debug_only(bool has_disp32 = false);
</pre>
<hr />
<pre>
1092   address opnd;
1093 
1094   Relocation* r = rspec.reloc();
1095   if (r-&gt;type() == relocInfo::none) {
1096     return;
1097   } else if (r-&gt;is_call() || format == call32_operand) {
1098     // assert(format == imm32_operand, &quot;cannot specify a nonzero format&quot;);
1099     opnd = locate_operand(inst, call32_operand);
1100   } else if (r-&gt;is_data()) {
1101     assert(format == imm_operand || format == disp32_operand
1102            LP64_ONLY(|| format == narrow_oop_operand), &quot;format ok&quot;);
1103     opnd = locate_operand(inst, (WhichOperand)format);
1104   } else {
1105     assert(format == imm_operand, &quot;cannot specify a format&quot;);
1106     return;
1107   }
1108   assert(opnd == pc(), &quot;must put operand where relocs can find it&quot;);
1109 }
1110 #endif // ASSERT
1111 
<span class="line-removed">1112 void Assembler::emit_operand32(Register reg, Address adr) {</span>
<span class="line-removed">1113   assert(reg-&gt;encoding() &lt; 8, &quot;no extended registers&quot;);</span>
<span class="line-removed">1114   assert(!adr.base_needs_rex() &amp;&amp; !adr.index_needs_rex(), &quot;no extended registers&quot;);</span>
<span class="line-removed">1115   emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,</span>
<span class="line-removed">1116                adr._rspec);</span>
<span class="line-removed">1117 }</span>
<span class="line-removed">1118 </span>
1119 void Assembler::emit_operand(Register reg, Address adr,
1120                              int rip_relative_correction) {
1121   emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,
1122                adr._rspec,
1123                rip_relative_correction);
1124 }
1125 
1126 void Assembler::emit_operand(XMMRegister reg, Address adr) {
1127     if (adr.isxmmindex()) {
1128        emit_operand(reg, adr._base, adr._xmmindex, adr._scale, adr._disp, adr._rspec);
1129     } else {
1130        emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,
1131        adr._rspec);
1132     }
1133 }
1134 
<span class="line-removed">1135 // MMX operations</span>
<span class="line-removed">1136 void Assembler::emit_operand(MMXRegister reg, Address adr) {</span>
<span class="line-removed">1137   assert(!adr.base_needs_rex() &amp;&amp; !adr.index_needs_rex(), &quot;no extended registers&quot;);</span>
<span class="line-removed">1138   emit_operand((Register)reg, adr._base, adr._index, adr._scale, adr._disp, adr._rspec);</span>
<span class="line-removed">1139 }</span>
<span class="line-removed">1140 </span>
<span class="line-removed">1141 // work around gcc (3.2.1-7a) bug</span>
<span class="line-removed">1142 void Assembler::emit_operand(Address adr, MMXRegister reg) {</span>
<span class="line-removed">1143   assert(!adr.base_needs_rex() &amp;&amp; !adr.index_needs_rex(), &quot;no extended registers&quot;);</span>
<span class="line-removed">1144   emit_operand((Register)reg, adr._base, adr._index, adr._scale, adr._disp, adr._rspec);</span>
<span class="line-removed">1145 }</span>
<span class="line-removed">1146 </span>
<span class="line-removed">1147 </span>
<span class="line-removed">1148 void Assembler::emit_farith(int b1, int b2, int i) {</span>
<span class="line-removed">1149   assert(isByte(b1) &amp;&amp; isByte(b2), &quot;wrong opcode&quot;);</span>
<span class="line-removed">1150   assert(0 &lt;= i &amp;&amp;  i &lt; 8, &quot;illegal stack offset&quot;);</span>
<span class="line-removed">1151   emit_int8(b1);</span>
<span class="line-removed">1152   emit_int8(b2 + i);</span>
<span class="line-removed">1153 }</span>
<span class="line-removed">1154 </span>
<span class="line-removed">1155 </span>
1156 // Now the Assembler instructions (identical for 32/64 bits)
1157 
1158 void Assembler::adcl(Address dst, int32_t imm32) {
1159   InstructionMark im(this);
1160   prefix(dst);
1161   emit_arith_operand(0x81, rdx, dst, imm32);
1162 }
1163 
1164 void Assembler::adcl(Address dst, Register src) {
1165   InstructionMark im(this);
1166   prefix(dst, src);
1167   emit_int8(0x11);
1168   emit_operand(src, dst);
1169 }
1170 
1171 void Assembler::adcl(Register dst, int32_t imm32) {
1172   prefix(dst);
1173   emit_arith(0x81, 0xD0, dst, imm32);
1174 }
1175 
</pre>
<hr />
<pre>
1218 void Assembler::addl(Register dst, int32_t imm32) {
1219   prefix(dst);
1220   emit_arith(0x81, 0xC0, dst, imm32);
1221 }
1222 
1223 void Assembler::addl(Register dst, Address src) {
1224   InstructionMark im(this);
1225   prefix(src, dst);
1226   emit_int8(0x03);
1227   emit_operand(dst, src);
1228 }
1229 
1230 void Assembler::addl(Register dst, Register src) {
1231   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
1232   emit_arith(0x03, 0xC0, dst, src);
1233 }
1234 
1235 void Assembler::addr_nop_4() {
1236   assert(UseAddressNop, &quot;no CPU support&quot;);
1237   // 4 bytes: NOP DWORD PTR [EAX+0]
<span class="line-modified">1238   emit_int8(0x0F);</span>
<span class="line-modified">1239   emit_int8(0x1F);</span>
<span class="line-modified">1240   emit_int8(0x40); // emit_rm(cbuf, 0x1, EAX_enc, EAX_enc);</span>
<span class="line-modified">1241   emit_int8(0);    // 8-bits offset (1 byte)</span>
1242 }
1243 
1244 void Assembler::addr_nop_5() {
1245   assert(UseAddressNop, &quot;no CPU support&quot;);
1246   // 5 bytes: NOP DWORD PTR [EAX+EAX*0+0] 8-bits offset
<span class="line-modified">1247   emit_int8(0x0F);</span>
<span class="line-modified">1248   emit_int8(0x1F);</span>
<span class="line-modified">1249   emit_int8(0x44); // emit_rm(cbuf, 0x1, EAX_enc, 0x4);</span>
<span class="line-modified">1250   emit_int8(0x00); // emit_rm(cbuf, 0x0, EAX_enc, EAX_enc);</span>
<span class="line-modified">1251   emit_int8(0);    // 8-bits offset (1 byte)</span>
1252 }
1253 
1254 void Assembler::addr_nop_7() {
1255   assert(UseAddressNop, &quot;no CPU support&quot;);
1256   // 7 bytes: NOP DWORD PTR [EAX+0] 32-bits offset
<span class="line-modified">1257   emit_int8(0x0F);</span>
<span class="line-modified">1258   emit_int8(0x1F);</span>
<span class="line-modified">1259   emit_int8((unsigned char)0x80);</span>
1260                    // emit_rm(cbuf, 0x2, EAX_enc, EAX_enc);
1261   emit_int32(0);   // 32-bits offset (4 bytes)
1262 }
1263 
1264 void Assembler::addr_nop_8() {
1265   assert(UseAddressNop, &quot;no CPU support&quot;);
1266   // 8 bytes: NOP DWORD PTR [EAX+EAX*0+0] 32-bits offset
<span class="line-modified">1267   emit_int8(0x0F);</span>
<span class="line-modified">1268   emit_int8(0x1F);</span>
<span class="line-modified">1269   emit_int8((unsigned char)0x84);</span>
<span class="line-modified">1270                    // emit_rm(cbuf, 0x2, EAX_enc, 0x4);</span>
<span class="line-modified">1271   emit_int8(0x00); // emit_rm(cbuf, 0x0, EAX_enc, EAX_enc);</span>
<span class="line-modified">1272   emit_int32(0);   // 32-bits offset (4 bytes)</span>
1273 }
1274 
1275 void Assembler::addsd(XMMRegister dst, XMMRegister src) {
1276   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1277   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1278   attributes.set_rex_vex_w_reverted();
1279   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1280   emit_int8(0x58);</span>
<span class="line-removed">1281   emit_int8((unsigned char)(0xC0 | encode));</span>
1282 }
1283 
1284 void Assembler::addsd(XMMRegister dst, Address src) {
1285   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1286   InstructionMark im(this);
1287   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1288   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
1289   attributes.set_rex_vex_w_reverted();
1290   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1291   emit_int8(0x58);
1292   emit_operand(dst, src);
1293 }
1294 
1295 void Assembler::addss(XMMRegister dst, XMMRegister src) {
1296   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1297   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1298   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1299   emit_int8(0x58);</span>
<span class="line-removed">1300   emit_int8((unsigned char)(0xC0 | encode));</span>
1301 }
1302 
1303 void Assembler::addss(XMMRegister dst, Address src) {
1304   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1305   InstructionMark im(this);
1306   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1307   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1308   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1309   emit_int8(0x58);
1310   emit_operand(dst, src);
1311 }
1312 
1313 void Assembler::aesdec(XMMRegister dst, Address src) {
1314   assert(VM_Version::supports_aes(), &quot;&quot;);
1315   InstructionMark im(this);
1316   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1317   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1318   emit_int8((unsigned char)0xDE);
1319   emit_operand(dst, src);
1320 }
1321 
1322 void Assembler::aesdec(XMMRegister dst, XMMRegister src) {
1323   assert(VM_Version::supports_aes(), &quot;&quot;);
1324   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1325   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1326   emit_int8((unsigned char)0xDE);</span>
<span class="line-removed">1327   emit_int8(0xC0 | encode);</span>
1328 }
1329 
1330 void Assembler::vaesdec(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">1331   assert(VM_Version::supports_vaes(), &quot;&quot;);</span>
1332   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1333   attributes.set_is_evex_instruction();
1334   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1335   emit_int8((unsigned char)0xDE);</span>
<span class="line-removed">1336   emit_int8((unsigned char)(0xC0 | encode));</span>
1337 }
1338 
1339 
1340 void Assembler::aesdeclast(XMMRegister dst, Address src) {
1341   assert(VM_Version::supports_aes(), &quot;&quot;);
1342   InstructionMark im(this);
1343   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1344   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1345   emit_int8((unsigned char)0xDF);
1346   emit_operand(dst, src);
1347 }
1348 
1349 void Assembler::aesdeclast(XMMRegister dst, XMMRegister src) {
1350   assert(VM_Version::supports_aes(), &quot;&quot;);
1351   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1352   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1353   emit_int8((unsigned char)0xDF);</span>
<span class="line-removed">1354   emit_int8((unsigned char)(0xC0 | encode));</span>
1355 }
1356 
1357 void Assembler::vaesdeclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">1358   assert(VM_Version::supports_vaes(), &quot;&quot;);</span>
1359   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1360   attributes.set_is_evex_instruction();
1361   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1362   emit_int8((unsigned char)0xDF);</span>
<span class="line-removed">1363   emit_int8((unsigned char)(0xC0 | encode));</span>
1364 }
1365 
1366 void Assembler::aesenc(XMMRegister dst, Address src) {
1367   assert(VM_Version::supports_aes(), &quot;&quot;);
1368   InstructionMark im(this);
1369   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1370   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1371   emit_int8((unsigned char)0xDC);
1372   emit_operand(dst, src);
1373 }
1374 
1375 void Assembler::aesenc(XMMRegister dst, XMMRegister src) {
1376   assert(VM_Version::supports_aes(), &quot;&quot;);
1377   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1378   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1379   emit_int8((unsigned char)0xDC);</span>
<span class="line-removed">1380   emit_int8(0xC0 | encode);</span>
1381 }
1382 
1383 void Assembler::vaesenc(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">1384   assert(VM_Version::supports_vaes(), &quot;requires vaes support/enabling&quot;);</span>
1385   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1386   attributes.set_is_evex_instruction();
1387   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1388   emit_int8((unsigned char)0xDC);</span>
<span class="line-removed">1389   emit_int8((unsigned char)(0xC0 | encode));</span>
1390 }
1391 
1392 void Assembler::aesenclast(XMMRegister dst, Address src) {
1393   assert(VM_Version::supports_aes(), &quot;&quot;);
1394   InstructionMark im(this);
1395   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1396   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1397   emit_int8((unsigned char)0xDD);
1398   emit_operand(dst, src);
1399 }
1400 
1401 void Assembler::aesenclast(XMMRegister dst, XMMRegister src) {
1402   assert(VM_Version::supports_aes(), &quot;&quot;);
1403   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1404   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1405   emit_int8((unsigned char)0xDD);</span>
<span class="line-removed">1406   emit_int8((unsigned char)(0xC0 | encode));</span>
1407 }
1408 
1409 void Assembler::vaesenclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">1410   assert(VM_Version::supports_vaes(), &quot;requires vaes support/enabling&quot;);</span>
1411   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1412   attributes.set_is_evex_instruction();
1413   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1414   emit_int8((unsigned char)0xDD);</span>
<span class="line-removed">1415   emit_int8((unsigned char)(0xC0 | encode));</span>
1416 }
1417 
1418 void Assembler::andl(Address dst, int32_t imm32) {
1419   InstructionMark im(this);
1420   prefix(dst);
1421   emit_int8((unsigned char)0x81);
1422   emit_operand(rsp, dst, 4);
1423   emit_int32(imm32);
1424 }
1425 
1426 void Assembler::andl(Register dst, int32_t imm32) {
1427   prefix(dst);
1428   emit_arith(0x81, 0xE0, dst, imm32);
1429 }
1430 
1431 void Assembler::andl(Register dst, Address src) {
1432   InstructionMark im(this);
1433   prefix(src, dst);
1434   emit_int8(0x23);
1435   emit_operand(dst, src);
1436 }
1437 
1438 void Assembler::andl(Register dst, Register src) {
1439   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
1440   emit_arith(0x23, 0xC0, dst, src);
1441 }
1442 
1443 void Assembler::andnl(Register dst, Register src1, Register src2) {
1444   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1445   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1446   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1447   emit_int8((unsigned char)0xF2);</span>
<span class="line-removed">1448   emit_int8((unsigned char)(0xC0 | encode));</span>
1449 }
1450 
1451 void Assembler::andnl(Register dst, Register src1, Address src2) {
1452   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1453   InstructionMark im(this);
1454   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1455   vex_prefix(src2, src1-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1456   emit_int8((unsigned char)0xF2);
1457   emit_operand(dst, src2);
1458 }
1459 
1460 void Assembler::bsfl(Register dst, Register src) {
1461   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">1462   emit_int8(0x0F);</span>
<span class="line-modified">1463   emit_int8((unsigned char)0xBC);</span>
<span class="line-modified">1464   emit_int8((unsigned char)(0xC0 | encode));</span>
1465 }
1466 
1467 void Assembler::bsrl(Register dst, Register src) {
1468   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">1469   emit_int8(0x0F);</span>
<span class="line-modified">1470   emit_int8((unsigned char)0xBD);</span>
<span class="line-modified">1471   emit_int8((unsigned char)(0xC0 | encode));</span>
1472 }
1473 
1474 void Assembler::bswapl(Register reg) { // bswap
1475   int encode = prefix_and_encode(reg-&gt;encoding());
<span class="line-modified">1476   emit_int8(0x0F);</span>
<span class="line-removed">1477   emit_int8((unsigned char)(0xC8 | encode));</span>
1478 }
1479 
1480 void Assembler::blsil(Register dst, Register src) {
1481   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1482   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1483   int encode = vex_prefix_and_encode(rbx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1484   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">1485   emit_int8((unsigned char)(0xC0 | encode));</span>
1486 }
1487 
1488 void Assembler::blsil(Register dst, Address src) {
1489   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1490   InstructionMark im(this);
1491   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1492   vex_prefix(src, dst-&gt;encoding(), rbx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1493   emit_int8((unsigned char)0xF3);
1494   emit_operand(rbx, src);
1495 }
1496 
1497 void Assembler::blsmskl(Register dst, Register src) {
1498   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1499   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1500   int encode = vex_prefix_and_encode(rdx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1501   emit_int8((unsigned char)0xF3);</span>
<span class="line-modified">1502   emit_int8((unsigned char)(0xC0 | encode));</span>
1503 }
1504 
1505 void Assembler::blsmskl(Register dst, Address src) {
1506   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1507   InstructionMark im(this);
1508   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1509   vex_prefix(src, dst-&gt;encoding(), rdx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1510   emit_int8((unsigned char)0xF3);
1511   emit_operand(rdx, src);
1512 }
1513 
1514 void Assembler::blsrl(Register dst, Register src) {
1515   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1516   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1517   int encode = vex_prefix_and_encode(rcx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1518   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">1519   emit_int8((unsigned char)(0xC0 | encode));</span>
1520 }
1521 
1522 void Assembler::blsrl(Register dst, Address src) {
1523   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1524   InstructionMark im(this);
1525   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1526   vex_prefix(src, dst-&gt;encoding(), rcx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1527   emit_int8((unsigned char)0xF3);
1528   emit_operand(rcx, src);
1529 }
1530 
1531 void Assembler::call(Label&amp; L, relocInfo::relocType rtype) {
1532   // suspect disp32 is always good
1533   int operand = LP64_ONLY(disp32_operand) NOT_LP64(imm_operand);
1534 
1535   if (L.is_bound()) {
1536     const int long_size = 5;
1537     int offs = (int)( target(L) - pc() );
1538     assert(offs &lt;= 0, &quot;assembler error&quot;);
1539     InstructionMark im(this);
1540     // 1110 1000 #32-bit disp
1541     emit_int8((unsigned char)0xE8);
1542     emit_data(offs - long_size, rtype, operand);
1543   } else {
1544     InstructionMark im(this);
1545     // 1110 1000 #32-bit disp
1546     L.add_patch_at(code(), locator());
1547 
1548     emit_int8((unsigned char)0xE8);
1549     emit_data(int(0), rtype, operand);
1550   }
1551 }
1552 
1553 void Assembler::call(Register dst) {
1554   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">1555   emit_int8((unsigned char)0xFF);</span>
<span class="line-removed">1556   emit_int8((unsigned char)(0xD0 | encode));</span>
1557 }
1558 
1559 
1560 void Assembler::call(Address adr) {
1561   InstructionMark im(this);
1562   prefix(adr);
1563   emit_int8((unsigned char)0xFF);
1564   emit_operand(rdx, adr);
1565 }
1566 
1567 void Assembler::call_literal(address entry, RelocationHolder const&amp; rspec) {
1568   InstructionMark im(this);
1569   emit_int8((unsigned char)0xE8);
1570   intptr_t disp = entry - (pc() + sizeof(int32_t));
1571   // Entry is NULL in case of a scratch emit.
1572   assert(entry == NULL || is_simm32(disp), &quot;disp=&quot; INTPTR_FORMAT &quot; must be 32bit offset (call2)&quot;, disp);
1573   // Technically, should use call32_operand, but this format is
1574   // implied by the fact that we&#39;re emitting a call instruction.
1575 
1576   int operand = LP64_ONLY(disp32_operand) NOT_LP64(call32_operand);
1577   emit_data((int) disp, rspec, operand);
1578 }
1579 
1580 void Assembler::cdql() {
1581   emit_int8((unsigned char)0x99);
1582 }
1583 
1584 void Assembler::cld() {
1585   emit_int8((unsigned char)0xFC);
1586 }
1587 
1588 void Assembler::cmovl(Condition cc, Register dst, Register src) {
1589   NOT_LP64(guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;));
1590   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">1591   emit_int8(0x0F);</span>
<span class="line-modified">1592   emit_int8(0x40 | cc);</span>
<span class="line-modified">1593   emit_int8((unsigned char)(0xC0 | encode));</span>
1594 }
1595 
1596 
1597 void Assembler::cmovl(Condition cc, Register dst, Address src) {
1598   NOT_LP64(guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;));
1599   prefix(src, dst);
<span class="line-modified">1600   emit_int8(0x0F);</span>
<span class="line-removed">1601   emit_int8(0x40 | cc);</span>
1602   emit_operand(dst, src);
1603 }
1604 
1605 void Assembler::cmpb(Address dst, int imm8) {
1606   InstructionMark im(this);
1607   prefix(dst);
1608   emit_int8((unsigned char)0x80);
1609   emit_operand(rdi, dst, 1);
1610   emit_int8(imm8);
1611 }
1612 
1613 void Assembler::cmpl(Address dst, int32_t imm32) {
1614   InstructionMark im(this);
1615   prefix(dst);
1616   emit_int8((unsigned char)0x81);
1617   emit_operand(rdi, dst, 4);
1618   emit_int32(imm32);
1619 }
1620 
1621 void Assembler::cmpl(Register dst, int32_t imm32) {
1622   prefix(dst);
1623   emit_arith(0x81, 0xF8, dst, imm32);
1624 }
1625 
1626 void Assembler::cmpl(Register dst, Register src) {
1627   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
1628   emit_arith(0x3B, 0xC0, dst, src);
1629 }
1630 
1631 void Assembler::cmpl(Register dst, Address  src) {
1632   InstructionMark im(this);
1633   prefix(src, dst);
<span class="line-modified">1634   emit_int8((unsigned char)0x3B);</span>
1635   emit_operand(dst, src);
1636 }
1637 
1638 void Assembler::cmpw(Address dst, int imm16) {
1639   InstructionMark im(this);
1640   assert(!dst.base_needs_rex() &amp;&amp; !dst.index_needs_rex(), &quot;no extended registers&quot;);
<span class="line-modified">1641   emit_int8(0x66);</span>
<span class="line-removed">1642   emit_int8((unsigned char)0x81);</span>
1643   emit_operand(rdi, dst, 2);
1644   emit_int16(imm16);
1645 }
1646 
1647 // The 32-bit cmpxchg compares the value at adr with the contents of rax,
1648 // and stores reg into adr if so; otherwise, the value at adr is loaded into rax,.
1649 // The ZF is set if the compared values were equal, and cleared otherwise.
1650 void Assembler::cmpxchgl(Register reg, Address adr) { // cmpxchg
1651   InstructionMark im(this);
1652   prefix(adr, reg);
<span class="line-modified">1653   emit_int8(0x0F);</span>
<span class="line-removed">1654   emit_int8((unsigned char)0xB1);</span>
1655   emit_operand(reg, adr);
1656 }
1657 
1658 // The 8-bit cmpxchg compares the value at adr with the contents of rax,
1659 // and stores reg into adr if so; otherwise, the value at adr is loaded into rax,.
1660 // The ZF is set if the compared values were equal, and cleared otherwise.
1661 void Assembler::cmpxchgb(Register reg, Address adr) { // cmpxchg
1662   InstructionMark im(this);
1663   prefix(adr, reg, true);
<span class="line-modified">1664   emit_int8(0x0F);</span>
<span class="line-removed">1665   emit_int8((unsigned char)0xB0);</span>
1666   emit_operand(reg, adr);
1667 }
1668 
1669 void Assembler::comisd(XMMRegister dst, Address src) {
1670   // NOTE: dbx seems to decode this as comiss even though the
1671   // 0x66 is there. Strangly ucomisd comes out correct
1672   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1673   InstructionMark im(this);
1674   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);;
1675   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
1676   attributes.set_rex_vex_w_reverted();
1677   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
1678   emit_int8(0x2F);
1679   emit_operand(dst, src);
1680 }
1681 
1682 void Assembler::comisd(XMMRegister dst, XMMRegister src) {
1683   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1684   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1685   attributes.set_rex_vex_w_reverted();
1686   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1687   emit_int8(0x2F);</span>
<span class="line-removed">1688   emit_int8((unsigned char)(0xC0 | encode));</span>
1689 }
1690 
1691 void Assembler::comiss(XMMRegister dst, Address src) {
1692   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1693   InstructionMark im(this);
1694   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1695   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1696   simd_prefix(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
1697   emit_int8(0x2F);
1698   emit_operand(dst, src);
1699 }
1700 
1701 void Assembler::comiss(XMMRegister dst, XMMRegister src) {
1702   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1703   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1704   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1705   emit_int8(0x2F);</span>
<span class="line-removed">1706   emit_int8((unsigned char)(0xC0 | encode));</span>
1707 }
1708 
1709 void Assembler::cpuid() {
<span class="line-modified">1710   emit_int8(0x0F);</span>
<span class="line-removed">1711   emit_int8((unsigned char)0xA2);</span>
1712 }
1713 
1714 // Opcode / Instruction                      Op /  En  64 - Bit Mode     Compat / Leg Mode Description                  Implemented
1715 // F2 0F 38 F0 / r       CRC32 r32, r / m8   RM        Valid             Valid             Accumulate CRC32 on r / m8.  v
1716 // F2 REX 0F 38 F0 / r   CRC32 r32, r / m8*  RM        Valid             N.E.              Accumulate CRC32 on r / m8.  -
1717 // F2 REX.W 0F 38 F0 / r CRC32 r64, r / m8   RM        Valid             N.E.              Accumulate CRC32 on r / m8.  -
1718 //
1719 // F2 0F 38 F1 / r       CRC32 r32, r / m16  RM        Valid             Valid             Accumulate CRC32 on r / m16. v
1720 //
1721 // F2 0F 38 F1 / r       CRC32 r32, r / m32  RM        Valid             Valid             Accumulate CRC32 on r / m32. v
1722 //
1723 // F2 REX.W 0F 38 F1 / r CRC32 r64, r / m64  RM        Valid             N.E.              Accumulate CRC32 on r / m64. v
1724 void Assembler::crc32(Register crc, Register v, int8_t sizeInBytes) {
1725   assert(VM_Version::supports_sse4_2(), &quot;&quot;);
1726   int8_t w = 0x01;
1727   Prefix p = Prefix_EMPTY;
1728 
<span class="line-modified">1729   emit_int8((int8_t)0xF2);</span>
1730   switch (sizeInBytes) {
1731   case 1:
1732     w = 0;
1733     break;
1734   case 2:
1735   case 4:
1736     break;
1737   LP64_ONLY(case 8:)
1738     // This instruction is not valid in 32 bits
1739     // Note:
1740     // http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf
1741     //
1742     // Page B - 72   Vol. 2C says
1743     // qwreg2 to qwreg            1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : 11 qwreg1 qwreg2
1744     // mem64 to qwreg             1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : mod qwreg r / m
1745     //                                                                            F0!!!
1746     // while 3 - 208 Vol. 2A
1747     // F2 REX.W 0F 38 F1 / r       CRC32 r64, r / m64             RM         Valid      N.E.Accumulate CRC32 on r / m64.
1748     //
1749     // the 0 on a last bit is reserved for a different flavor of this instruction :
1750     // F2 REX.W 0F 38 F0 / r       CRC32 r64, r / m8              RM         Valid      N.E.Accumulate CRC32 on r / m8.
1751     p = REX_W;
1752     break;
1753   default:
1754     assert(0, &quot;Unsupported value for a sizeInBytes argument&quot;);
1755     break;
1756   }
1757   LP64_ONLY(prefix(crc, v, p);)
<span class="line-modified">1758   emit_int8((int8_t)0x0F);</span>
<span class="line-modified">1759   emit_int8(0x38);</span>
<span class="line-modified">1760   emit_int8((int8_t)(0xF0 | w));</span>
<span class="line-modified">1761   emit_int8(0xC0 | ((crc-&gt;encoding() &amp; 0x7) &lt;&lt; 3) | (v-&gt;encoding() &amp; 7));</span>
1762 }
1763 
1764 void Assembler::crc32(Register crc, Address adr, int8_t sizeInBytes) {
1765   assert(VM_Version::supports_sse4_2(), &quot;&quot;);
1766   InstructionMark im(this);
1767   int8_t w = 0x01;
1768   Prefix p = Prefix_EMPTY;
1769 
1770   emit_int8((int8_t)0xF2);
1771   switch (sizeInBytes) {
1772   case 1:
1773     w = 0;
1774     break;
1775   case 2:
1776   case 4:
1777     break;
1778   LP64_ONLY(case 8:)
1779     // This instruction is not valid in 32 bits
1780     p = REX_W;
1781     break;
1782   default:
1783     assert(0, &quot;Unsupported value for a sizeInBytes argument&quot;);
1784     break;
1785   }
1786   LP64_ONLY(prefix(crc, adr, p);)
<span class="line-modified">1787   emit_int8((int8_t)0x0F);</span>
<span class="line-removed">1788   emit_int8(0x38);</span>
<span class="line-removed">1789   emit_int8((int8_t)(0xF0 | w));</span>
1790   emit_operand(crc, adr);
1791 }
1792 
1793 void Assembler::cvtdq2pd(XMMRegister dst, XMMRegister src) {
1794   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1795   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1796   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1797   emit_int8((unsigned char)0xE6);</span>
<span class="line-removed">1798   emit_int8((unsigned char)(0xC0 | encode));</span>
1799 }
1800 
1801 void Assembler::cvtdq2ps(XMMRegister dst, XMMRegister src) {
1802   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1803   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1804   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1805   emit_int8(0x5B);</span>
<span class="line-removed">1806   emit_int8((unsigned char)(0xC0 | encode));</span>
1807 }
1808 
1809 void Assembler::cvtsd2ss(XMMRegister dst, XMMRegister src) {
1810   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1811   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1812   attributes.set_rex_vex_w_reverted();
1813   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1814   emit_int8(0x5A);</span>
<span class="line-removed">1815   emit_int8((unsigned char)(0xC0 | encode));</span>
1816 }
1817 
1818 void Assembler::cvtsd2ss(XMMRegister dst, Address src) {
1819   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1820   InstructionMark im(this);
1821   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1822   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
1823   attributes.set_rex_vex_w_reverted();
1824   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1825   emit_int8(0x5A);
1826   emit_operand(dst, src);
1827 }
1828 
1829 void Assembler::cvtsi2sdl(XMMRegister dst, Register src) {
1830   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1831   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1832   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1833   emit_int8(0x2A);</span>
<span class="line-removed">1834   emit_int8((unsigned char)(0xC0 | encode));</span>
1835 }
1836 
1837 void Assembler::cvtsi2sdl(XMMRegister dst, Address src) {
1838   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1839   InstructionMark im(this);
1840   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1841   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1842   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1843   emit_int8(0x2A);
1844   emit_operand(dst, src);
1845 }
1846 
1847 void Assembler::cvtsi2ssl(XMMRegister dst, Register src) {
1848   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1849   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1850   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1851   emit_int8(0x2A);</span>
<span class="line-removed">1852   emit_int8((unsigned char)(0xC0 | encode));</span>
1853 }
1854 
1855 void Assembler::cvtsi2ssl(XMMRegister dst, Address src) {
1856   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1857   InstructionMark im(this);
1858   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1859   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1860   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1861   emit_int8(0x2A);
1862   emit_operand(dst, src);
1863 }
1864 
1865 void Assembler::cvtsi2ssq(XMMRegister dst, Register src) {
1866   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1867   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1868   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1869   emit_int8(0x2A);</span>
<span class="line-removed">1870   emit_int8((unsigned char)(0xC0 | encode));</span>
1871 }
1872 
1873 void Assembler::cvtss2sd(XMMRegister dst, XMMRegister src) {
1874   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1875   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1876   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1877   emit_int8(0x5A);</span>
<span class="line-removed">1878   emit_int8((unsigned char)(0xC0 | encode));</span>
1879 }
1880 
1881 void Assembler::cvtss2sd(XMMRegister dst, Address src) {
1882   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1883   InstructionMark im(this);
1884   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1885   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1886   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1887   emit_int8(0x5A);
1888   emit_operand(dst, src);
1889 }
1890 
1891 
1892 void Assembler::cvttsd2sil(Register dst, XMMRegister src) {
1893   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1894   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1895   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1896   emit_int8(0x2C);</span>
<span class="line-removed">1897   emit_int8((unsigned char)(0xC0 | encode));</span>
1898 }
1899 
1900 void Assembler::cvttss2sil(Register dst, XMMRegister src) {
1901   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1902   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1903   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1904   emit_int8(0x2C);</span>
<span class="line-removed">1905   emit_int8((unsigned char)(0xC0 | encode));</span>
1906 }
1907 
1908 void Assembler::cvttpd2dq(XMMRegister dst, XMMRegister src) {
1909   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1910   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
1911   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1912   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1913   emit_int8((unsigned char)0xE6);</span>
<span class="line-removed">1914   emit_int8((unsigned char)(0xC0 | encode));</span>
1915 }
1916 
1917 void Assembler::pabsb(XMMRegister dst, XMMRegister src) {
1918   assert(VM_Version::supports_ssse3(), &quot;&quot;);
1919   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
1920   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1921   emit_int8(0x1C);</span>
<span class="line-removed">1922   emit_int8((unsigned char)(0xC0 | encode));</span>
1923 }
1924 
1925 void Assembler::pabsw(XMMRegister dst, XMMRegister src) {
1926   assert(VM_Version::supports_ssse3(), &quot;&quot;);
1927   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
1928   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1929   emit_int8(0x1D);</span>
<span class="line-removed">1930   emit_int8((unsigned char)(0xC0 | encode));</span>
1931 }
1932 
1933 void Assembler::pabsd(XMMRegister dst, XMMRegister src) {
1934   assert(VM_Version::supports_ssse3(), &quot;&quot;);
1935   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1936   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1937   emit_int8(0x1E);</span>
<span class="line-removed">1938   emit_int8((unsigned char)(0xC0 | encode));</span>
1939 }
1940 
1941 void Assembler::vpabsb(XMMRegister dst, XMMRegister src, int vector_len) {
1942   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
1943   vector_len == AVX_256bit? VM_Version::supports_avx2() :
1944   vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
1945   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
1946   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1947   emit_int8((unsigned char)0x1C);</span>
<span class="line-removed">1948   emit_int8((unsigned char)(0xC0 | encode));</span>
1949 }
1950 
1951 void Assembler::vpabsw(XMMRegister dst, XMMRegister src, int vector_len) {
1952   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
1953   vector_len == AVX_256bit? VM_Version::supports_avx2() :
1954   vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
1955   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
1956   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1957   emit_int8((unsigned char)0x1D);</span>
<span class="line-removed">1958   emit_int8((unsigned char)(0xC0 | encode));</span>
1959 }
1960 
1961 void Assembler::vpabsd(XMMRegister dst, XMMRegister src, int vector_len) {
1962   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
1963   vector_len == AVX_256bit? VM_Version::supports_avx2() :
1964   vector_len == AVX_512bit? VM_Version::supports_evex() : 0, &quot;&quot;);
1965   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1966   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1967   emit_int8((unsigned char)0x1E);</span>
<span class="line-removed">1968   emit_int8((unsigned char)(0xC0 | encode));</span>
1969 }
1970 
1971 void Assembler::evpabsq(XMMRegister dst, XMMRegister src, int vector_len) {
1972   assert(UseAVX &gt; 2, &quot;&quot;);
1973   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1974   attributes.set_is_evex_instruction();
1975   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1976   emit_int8((unsigned char)0x1F);</span>
<span class="line-removed">1977   emit_int8((unsigned char)(0xC0 | encode));</span>
1978 }
1979 
1980 void Assembler::decl(Address dst) {
1981   // Don&#39;t use it directly. Use MacroAssembler::decrement() instead.
1982   InstructionMark im(this);
1983   prefix(dst);
1984   emit_int8((unsigned char)0xFF);
1985   emit_operand(rcx, dst);
1986 }
1987 
1988 void Assembler::divsd(XMMRegister dst, Address src) {
1989   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1990   InstructionMark im(this);
1991   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1992   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
1993   attributes.set_rex_vex_w_reverted();
1994   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1995   emit_int8(0x5E);
1996   emit_operand(dst, src);
1997 }
1998 
1999 void Assembler::divsd(XMMRegister dst, XMMRegister src) {
2000   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2001   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2002   attributes.set_rex_vex_w_reverted();
2003   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2004   emit_int8(0x5E);</span>
<span class="line-removed">2005   emit_int8((unsigned char)(0xC0 | encode));</span>
2006 }
2007 
2008 void Assembler::divss(XMMRegister dst, Address src) {
2009   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2010   InstructionMark im(this);
2011   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2012   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2013   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2014   emit_int8(0x5E);
2015   emit_operand(dst, src);
2016 }
2017 
2018 void Assembler::divss(XMMRegister dst, XMMRegister src) {
2019   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2020   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2021   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2022   emit_int8(0x5E);</span>
<span class="line-removed">2023   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">2024 }</span>
<span class="line-removed">2025 </span>
<span class="line-removed">2026 void Assembler::emms() {</span>
<span class="line-removed">2027   NOT_LP64(assert(VM_Version::supports_mmx(), &quot;&quot;));</span>
<span class="line-removed">2028   emit_int8(0x0F);</span>
<span class="line-removed">2029   emit_int8(0x77);</span>
2030 }
2031 
2032 void Assembler::hlt() {
2033   emit_int8((unsigned char)0xF4);
2034 }
2035 
2036 void Assembler::idivl(Register src) {
2037   int encode = prefix_and_encode(src-&gt;encoding());
<span class="line-modified">2038   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">2039   emit_int8((unsigned char)(0xF8 | encode));</span>
2040 }
2041 
2042 void Assembler::divl(Register src) { // Unsigned
2043   int encode = prefix_and_encode(src-&gt;encoding());
<span class="line-modified">2044   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">2045   emit_int8((unsigned char)(0xF0 | encode));</span>
2046 }
2047 
2048 void Assembler::imull(Register src) {
2049   int encode = prefix_and_encode(src-&gt;encoding());
<span class="line-modified">2050   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">2051   emit_int8((unsigned char)(0xE8 | encode));</span>
2052 }
2053 
2054 void Assembler::imull(Register dst, Register src) {
2055   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">2056   emit_int8(0x0F);</span>
<span class="line-modified">2057   emit_int8((unsigned char)0xAF);</span>
<span class="line-modified">2058   emit_int8((unsigned char)(0xC0 | encode));</span>
2059 }
2060 
2061 
2062 void Assembler::imull(Register dst, Register src, int value) {
2063   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
2064   if (is8bit(value)) {
<span class="line-modified">2065     emit_int8(0x6B);</span>
<span class="line-removed">2066     emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">2067     emit_int8(value &amp; 0xFF);</span>
2068   } else {
<span class="line-modified">2069     emit_int8(0x69);</span>
<span class="line-removed">2070     emit_int8((unsigned char)(0xC0 | encode));</span>
2071     emit_int32(value);
2072   }
2073 }
2074 
2075 void Assembler::imull(Register dst, Address src) {
2076   InstructionMark im(this);
2077   prefix(src, dst);
<span class="line-modified">2078   emit_int8(0x0F);</span>
<span class="line-removed">2079   emit_int8((unsigned char) 0xAF);</span>
2080   emit_operand(dst, src);
2081 }
2082 
2083 
2084 void Assembler::incl(Address dst) {
2085   // Don&#39;t use it directly. Use MacroAssembler::increment() instead.
2086   InstructionMark im(this);
2087   prefix(dst);
2088   emit_int8((unsigned char)0xFF);
2089   emit_operand(rax, dst);
2090 }
2091 
2092 void Assembler::jcc(Condition cc, Label&amp; L, bool maybe_short) {
2093   InstructionMark im(this);
2094   assert((0 &lt;= cc) &amp;&amp; (cc &lt; 16), &quot;illegal cc&quot;);
2095   if (L.is_bound()) {
2096     address dst = target(L);
2097     assert(dst != NULL, &quot;jcc most probably wrong&quot;);
2098 
2099     const int short_size = 2;
2100     const int long_size = 6;
2101     intptr_t offs = (intptr_t)dst - (intptr_t)pc();
2102     if (maybe_short &amp;&amp; is8bit(offs - short_size)) {
2103       // 0111 tttn #8-bit disp
<span class="line-modified">2104       emit_int8(0x70 | cc);</span>
<span class="line-removed">2105       emit_int8((offs - short_size) &amp; 0xFF);</span>
2106     } else {
2107       // 0000 1111 1000 tttn #32-bit disp
2108       assert(is_simm32(offs - long_size),
2109              &quot;must be 32bit offset (call4)&quot;);
<span class="line-modified">2110       emit_int8(0x0F);</span>
<span class="line-removed">2111       emit_int8((unsigned char)(0x80 | cc));</span>
2112       emit_int32(offs - long_size);
2113     }
2114   } else {
2115     // Note: could eliminate cond. jumps to this jump if condition
2116     //       is the same however, seems to be rather unlikely case.
2117     // Note: use jccb() if label to be bound is very close to get
2118     //       an 8-bit displacement
2119     L.add_patch_at(code(), locator());
<span class="line-modified">2120     emit_int8(0x0F);</span>
<span class="line-removed">2121     emit_int8((unsigned char)(0x80 | cc));</span>
2122     emit_int32(0);
2123   }
2124 }
2125 
2126 void Assembler::jccb_0(Condition cc, Label&amp; L, const char* file, int line) {
2127   if (L.is_bound()) {
2128     const int short_size = 2;
2129     address entry = target(L);
2130 #ifdef ASSERT
2131     intptr_t dist = (intptr_t)entry - ((intptr_t)pc() + short_size);
2132     intptr_t delta = short_branch_delta();
2133     if (delta != 0) {
2134       dist += (dist &lt; 0 ? (-delta) :delta);
2135     }
2136     assert(is8bit(dist), &quot;Dispacement too large for a short jmp at %s:%d&quot;, file, line);
2137 #endif
2138     intptr_t offs = (intptr_t)entry - (intptr_t)pc();
2139     // 0111 tttn #8-bit disp
<span class="line-modified">2140     emit_int8(0x70 | cc);</span>
<span class="line-removed">2141     emit_int8((offs - short_size) &amp; 0xFF);</span>
2142   } else {
2143     InstructionMark im(this);
2144     L.add_patch_at(code(), locator(), file, line);
<span class="line-modified">2145     emit_int8(0x70 | cc);</span>
<span class="line-removed">2146     emit_int8(0);</span>
2147   }
2148 }
2149 
2150 void Assembler::jmp(Address adr) {
2151   InstructionMark im(this);
2152   prefix(adr);
2153   emit_int8((unsigned char)0xFF);
2154   emit_operand(rsp, adr);
2155 }
2156 
2157 void Assembler::jmp(Label&amp; L, bool maybe_short) {
2158   if (L.is_bound()) {
2159     address entry = target(L);
2160     assert(entry != NULL, &quot;jmp most probably wrong&quot;);
2161     InstructionMark im(this);
2162     const int short_size = 2;
2163     const int long_size = 5;
2164     intptr_t offs = entry - pc();
2165     if (maybe_short &amp;&amp; is8bit(offs - short_size)) {
<span class="line-modified">2166       emit_int8((unsigned char)0xEB);</span>
<span class="line-removed">2167       emit_int8((offs - short_size) &amp; 0xFF);</span>
2168     } else {
2169       emit_int8((unsigned char)0xE9);
2170       emit_int32(offs - long_size);
2171     }
2172   } else {
2173     // By default, forward jumps are always 32-bit displacements, since
2174     // we can&#39;t yet know where the label will be bound.  If you&#39;re sure that
2175     // the forward jump will not run beyond 256 bytes, use jmpb to
2176     // force an 8-bit displacement.
2177     InstructionMark im(this);
2178     L.add_patch_at(code(), locator());
2179     emit_int8((unsigned char)0xE9);
2180     emit_int32(0);
2181   }
2182 }
2183 
2184 void Assembler::jmp(Register entry) {
2185   int encode = prefix_and_encode(entry-&gt;encoding());
<span class="line-modified">2186   emit_int8((unsigned char)0xFF);</span>
<span class="line-removed">2187   emit_int8((unsigned char)(0xE0 | encode));</span>
2188 }
2189 
2190 void Assembler::jmp_literal(address dest, RelocationHolder const&amp; rspec) {
2191   InstructionMark im(this);
2192   emit_int8((unsigned char)0xE9);
2193   assert(dest != NULL, &quot;must have a target&quot;);
2194   intptr_t disp = dest - (pc() + sizeof(int32_t));
2195   assert(is_simm32(disp), &quot;must be 32bit offset (jmp)&quot;);
2196   emit_data(disp, rspec.reloc(), call32_operand);
2197 }
2198 
2199 void Assembler::jmpb_0(Label&amp; L, const char* file, int line) {
2200   if (L.is_bound()) {
2201     const int short_size = 2;
2202     address entry = target(L);
2203     assert(entry != NULL, &quot;jmp most probably wrong&quot;);
2204 #ifdef ASSERT
2205     intptr_t dist = (intptr_t)entry - ((intptr_t)pc() + short_size);
2206     intptr_t delta = short_branch_delta();
2207     if (delta != 0) {
2208       dist += (dist &lt; 0 ? (-delta) :delta);
2209     }
2210     assert(is8bit(dist), &quot;Dispacement too large for a short jmp at %s:%d&quot;, file, line);
2211 #endif
2212     intptr_t offs = entry - pc();
<span class="line-modified">2213     emit_int8((unsigned char)0xEB);</span>
<span class="line-removed">2214     emit_int8((offs - short_size) &amp; 0xFF);</span>
2215   } else {
2216     InstructionMark im(this);
2217     L.add_patch_at(code(), locator(), file, line);
<span class="line-modified">2218     emit_int8((unsigned char)0xEB);</span>
<span class="line-removed">2219     emit_int8(0);</span>
2220   }
2221 }
2222 
2223 void Assembler::ldmxcsr( Address src) {
2224   if (UseAVX &gt; 0 ) {
2225     InstructionMark im(this);
2226     InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2227     vex_prefix(src, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2228     emit_int8((unsigned char)0xAE);
2229     emit_operand(as_Register(2), src);
2230   } else {
2231     NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2232     InstructionMark im(this);
2233     prefix(src);
<span class="line-modified">2234     emit_int8(0x0F);</span>
<span class="line-removed">2235     emit_int8((unsigned char)0xAE);</span>
2236     emit_operand(as_Register(2), src);
2237   }
2238 }
2239 
2240 void Assembler::leal(Register dst, Address src) {
2241   InstructionMark im(this);
2242 #ifdef _LP64
2243   emit_int8(0x67); // addr32
2244   prefix(src, dst);
2245 #endif // LP64
2246   emit_int8((unsigned char)0x8D);
2247   emit_operand(dst, src);
2248 }
2249 
2250 void Assembler::lfence() {
<span class="line-modified">2251   emit_int8(0x0F);</span>
<span class="line-removed">2252   emit_int8((unsigned char)0xAE);</span>
<span class="line-removed">2253   emit_int8((unsigned char)0xE8);</span>
2254 }
2255 
2256 void Assembler::lock() {
2257   emit_int8((unsigned char)0xF0);
2258 }
2259 
2260 void Assembler::lzcntl(Register dst, Register src) {
2261   assert(VM_Version::supports_lzcnt(), &quot;encoding is treated as BSR&quot;);
2262   emit_int8((unsigned char)0xF3);
2263   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">2264   emit_int8(0x0F);</span>
<span class="line-removed">2265   emit_int8((unsigned char)0xBD);</span>
<span class="line-removed">2266   emit_int8((unsigned char)(0xC0 | encode));</span>
2267 }
2268 
2269 // Emit mfence instruction
2270 void Assembler::mfence() {
2271   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;unsupported&quot;);)
<span class="line-modified">2272   emit_int8(0x0F);</span>
<span class="line-removed">2273   emit_int8((unsigned char)0xAE);</span>
<span class="line-removed">2274   emit_int8((unsigned char)0xF0);</span>
2275 }
2276 
2277 // Emit sfence instruction
2278 void Assembler::sfence() {
2279   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;unsupported&quot;);)
<span class="line-modified">2280   emit_int8(0x0F);</span>
<span class="line-removed">2281   emit_int8((unsigned char)0xAE);</span>
<span class="line-removed">2282   emit_int8((unsigned char)0xF8);</span>
2283 }
2284 
2285 void Assembler::mov(Register dst, Register src) {
2286   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2287 }
2288 
2289 void Assembler::movapd(XMMRegister dst, XMMRegister src) {
2290   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2291   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
2292   InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2293   attributes.set_rex_vex_w_reverted();
2294   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2295   emit_int8(0x28);</span>
<span class="line-removed">2296   emit_int8((unsigned char)(0xC0 | encode));</span>
2297 }
2298 
2299 void Assembler::movaps(XMMRegister dst, XMMRegister src) {
2300   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2301   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
2302   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2303   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2304   emit_int8(0x28);</span>
<span class="line-removed">2305   emit_int8((unsigned char)(0xC0 | encode));</span>
2306 }
2307 
2308 void Assembler::movlhps(XMMRegister dst, XMMRegister src) {
2309   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2310   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2311   int encode = simd_prefix_and_encode(dst, src, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2312   emit_int8(0x16);</span>
<span class="line-removed">2313   emit_int8((unsigned char)(0xC0 | encode));</span>
2314 }
2315 
2316 void Assembler::movb(Register dst, Address src) {
2317   NOT_LP64(assert(dst-&gt;has_byte_register(), &quot;must have byte register&quot;));
2318   InstructionMark im(this);
2319   prefix(src, dst, true);
2320   emit_int8((unsigned char)0x8A);
2321   emit_operand(dst, src);
2322 }
2323 
2324 void Assembler::movddup(XMMRegister dst, XMMRegister src) {
2325   NOT_LP64(assert(VM_Version::supports_sse3(), &quot;&quot;));
2326   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
2327   InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2328   attributes.set_rex_vex_w_reverted();
2329   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2330   emit_int8(0x12);</span>
<span class="line-removed">2331   emit_int8(0xC0 | encode);</span>
2332 }
2333 
2334 void Assembler::kmovbl(KRegister dst, Register src) {
2335   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
2336   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2337   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2338   emit_int8((unsigned char)0x92);</span>
<span class="line-removed">2339   emit_int8((unsigned char)(0xC0 | encode));</span>
2340 }
2341 
2342 void Assembler::kmovbl(Register dst, KRegister src) {
2343   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
2344   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2345   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2346   emit_int8((unsigned char)0x93);</span>
<span class="line-removed">2347   emit_int8((unsigned char)(0xC0 | encode));</span>
2348 }
2349 
2350 void Assembler::kmovwl(KRegister dst, Register src) {
2351   assert(VM_Version::supports_evex(), &quot;&quot;);
2352   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2353   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2354   emit_int8((unsigned char)0x92);</span>
<span class="line-removed">2355   emit_int8((unsigned char)(0xC0 | encode));</span>
2356 }
2357 
2358 void Assembler::kmovwl(Register dst, KRegister src) {
2359   assert(VM_Version::supports_evex(), &quot;&quot;);
2360   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2361   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2362   emit_int8((unsigned char)0x93);</span>
<span class="line-removed">2363   emit_int8((unsigned char)(0xC0 | encode));</span>
2364 }
2365 
2366 void Assembler::kmovwl(KRegister dst, Address src) {
2367   assert(VM_Version::supports_evex(), &quot;&quot;);
2368   InstructionMark im(this);
2369   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2370   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2371   emit_int8((unsigned char)0x90);
2372   emit_operand((Register)dst, src);
2373 }
2374 
2375 void Assembler::kmovdl(KRegister dst, Register src) {
2376   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2377   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2378   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2379   emit_int8((unsigned char)0x92);</span>
<span class="line-removed">2380   emit_int8((unsigned char)(0xC0 | encode));</span>
2381 }
2382 
2383 void Assembler::kmovdl(Register dst, KRegister src) {
2384   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2385   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2386   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2387   emit_int8((unsigned char)0x93);</span>
<span class="line-removed">2388   emit_int8((unsigned char)(0xC0 | encode));</span>
2389 }
2390 
2391 void Assembler::kmovql(KRegister dst, KRegister src) {
2392   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2393   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2394   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2395   emit_int8((unsigned char)0x90);</span>
<span class="line-removed">2396   emit_int8((unsigned char)(0xC0 | encode));</span>
2397 }
2398 
2399 void Assembler::kmovql(KRegister dst, Address src) {
2400   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2401   InstructionMark im(this);
2402   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2403   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2404   emit_int8((unsigned char)0x90);
2405   emit_operand((Register)dst, src);
2406 }
2407 
2408 void Assembler::kmovql(Address dst, KRegister src) {
2409   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2410   InstructionMark im(this);
2411   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2412   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2413   emit_int8((unsigned char)0x90);
2414   emit_operand((Register)src, dst);
2415 }
2416 
2417 void Assembler::kmovql(KRegister dst, Register src) {
2418   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2419   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2420   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2421   emit_int8((unsigned char)0x92);</span>
<span class="line-removed">2422   emit_int8((unsigned char)(0xC0 | encode));</span>
2423 }
2424 
2425 void Assembler::kmovql(Register dst, KRegister src) {
2426   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2427   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2428   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2429   emit_int8((unsigned char)0x93);</span>
<span class="line-removed">2430   emit_int8((unsigned char)(0xC0 | encode));</span>
2431 }
2432 
2433 void Assembler::knotwl(KRegister dst, KRegister src) {
2434   assert(VM_Version::supports_evex(), &quot;&quot;);
2435   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2436   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2437   emit_int8((unsigned char)0x44);</span>
<span class="line-removed">2438   emit_int8((unsigned char)(0xC0 | encode));</span>
2439 }
2440 
2441 // This instruction produces ZF or CF flags
2442 void Assembler::kortestbl(KRegister src1, KRegister src2) {
2443   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
2444   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2445   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2446   emit_int8((unsigned char)0x98);</span>
<span class="line-removed">2447   emit_int8((unsigned char)(0xC0 | encode));</span>
2448 }
2449 
2450 // This instruction produces ZF or CF flags
2451 void Assembler::kortestwl(KRegister src1, KRegister src2) {
2452   assert(VM_Version::supports_evex(), &quot;&quot;);
2453   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2454   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2455   emit_int8((unsigned char)0x98);</span>
<span class="line-removed">2456   emit_int8((unsigned char)(0xC0 | encode));</span>
2457 }
2458 
2459 // This instruction produces ZF or CF flags
2460 void Assembler::kortestdl(KRegister src1, KRegister src2) {
2461   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2462   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2463   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2464   emit_int8((unsigned char)0x98);</span>
<span class="line-removed">2465   emit_int8((unsigned char)(0xC0 | encode));</span>
2466 }
2467 
2468 // This instruction produces ZF or CF flags
2469 void Assembler::kortestql(KRegister src1, KRegister src2) {
2470   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2471   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2472   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2473   emit_int8((unsigned char)0x98);</span>
<span class="line-removed">2474   emit_int8((unsigned char)(0xC0 | encode));</span>
2475 }
2476 
2477 // This instruction produces ZF or CF flags
2478 void Assembler::ktestql(KRegister src1, KRegister src2) {
2479   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2480   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2481   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2482   emit_int8((unsigned char)0x99);</span>
<span class="line-removed">2483   emit_int8((unsigned char)(0xC0 | encode));</span>
2484 }
2485 
2486 void Assembler::ktestq(KRegister src1, KRegister src2) {
2487   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2488   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2489   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2490   emit_int8((unsigned char)0x99);</span>
<span class="line-removed">2491   emit_int8((unsigned char)(0xC0 | encode));</span>
2492 }
2493 
2494 void Assembler::ktestd(KRegister src1, KRegister src2) {
2495   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2496   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2497   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2498   emit_int8((unsigned char)0x99);</span>
<span class="line-removed">2499   emit_int8((unsigned char)(0xC0 | encode));</span>
2500 }
2501 
2502 void Assembler::movb(Address dst, int imm8) {
2503   InstructionMark im(this);
2504    prefix(dst);
2505   emit_int8((unsigned char)0xC6);
2506   emit_operand(rax, dst, 1);
2507   emit_int8(imm8);
2508 }
2509 
2510 
2511 void Assembler::movb(Address dst, Register src) {
2512   assert(src-&gt;has_byte_register(), &quot;must have byte register&quot;);
2513   InstructionMark im(this);
2514   prefix(dst, src, true);
2515   emit_int8((unsigned char)0x88);
2516   emit_operand(src, dst);
2517 }
2518 
2519 void Assembler::movdl(XMMRegister dst, Register src) {
2520   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2521   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2522   int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2523   emit_int8(0x6E);</span>
<span class="line-removed">2524   emit_int8((unsigned char)(0xC0 | encode));</span>
2525 }
2526 
2527 void Assembler::movdl(Register dst, XMMRegister src) {
2528   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2529   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2530   // swap src/dst to get correct prefix
2531   int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2532   emit_int8(0x7E);</span>
<span class="line-removed">2533   emit_int8((unsigned char)(0xC0 | encode));</span>
2534 }
2535 
2536 void Assembler::movdl(XMMRegister dst, Address src) {
2537   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2538   InstructionMark im(this);
2539   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2540   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2541   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2542   emit_int8(0x6E);
2543   emit_operand(dst, src);
2544 }
2545 
2546 void Assembler::movdl(Address dst, XMMRegister src) {
2547   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2548   InstructionMark im(this);
2549   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2550   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2551   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2552   emit_int8(0x7E);
2553   emit_operand(src, dst);
2554 }
2555 
2556 void Assembler::movdqa(XMMRegister dst, XMMRegister src) {
2557   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2558   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2559   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2560   emit_int8(0x6F);</span>
<span class="line-removed">2561   emit_int8((unsigned char)(0xC0 | encode));</span>
2562 }
2563 
2564 void Assembler::movdqa(XMMRegister dst, Address src) {
2565   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2566   InstructionMark im(this);
2567   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2568   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2569   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2570   emit_int8(0x6F);
2571   emit_operand(dst, src);
2572 }
2573 
2574 void Assembler::movdqu(XMMRegister dst, Address src) {
2575   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2576   InstructionMark im(this);
2577   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2578   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2579   simd_prefix(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2580   emit_int8(0x6F);
2581   emit_operand(dst, src);
2582 }
2583 
2584 void Assembler::movdqu(XMMRegister dst, XMMRegister src) {
2585   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2586   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2587   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2588   emit_int8(0x6F);</span>
<span class="line-removed">2589   emit_int8((unsigned char)(0xC0 | encode));</span>
2590 }
2591 
2592 void Assembler::movdqu(Address dst, XMMRegister src) {
2593   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2594   InstructionMark im(this);
2595   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2596   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2597   attributes.reset_is_clear_context();
2598   simd_prefix(src, xnoreg, dst, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2599   emit_int8(0x7F);
2600   emit_operand(src, dst);
2601 }
2602 
2603 // Move Unaligned 256bit Vector
2604 void Assembler::vmovdqu(XMMRegister dst, XMMRegister src) {
2605   assert(UseAVX &gt; 0, &quot;&quot;);
2606   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2607   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2608   emit_int8(0x6F);</span>
<span class="line-removed">2609   emit_int8((unsigned char)(0xC0 | encode));</span>
2610 }
2611 
2612 void Assembler::vmovdqu(XMMRegister dst, Address src) {
2613   assert(UseAVX &gt; 0, &quot;&quot;);
2614   InstructionMark im(this);
2615   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2616   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2617   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2618   emit_int8(0x6F);
2619   emit_operand(dst, src);
2620 }
2621 
2622 void Assembler::vmovdqu(Address dst, XMMRegister src) {
2623   assert(UseAVX &gt; 0, &quot;&quot;);
2624   InstructionMark im(this);
2625   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2626   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2627   attributes.reset_is_clear_context();
2628   // swap src&lt;-&gt;dst for encoding
2629   assert(src != xnoreg, &quot;sanity&quot;);
2630   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2631   emit_int8(0x7F);
2632   emit_operand(src, dst);
2633 }
2634 
2635 // Move Unaligned EVEX enabled Vector (programmable : 8,16,32,64)
2636 void Assembler::evmovdqub(XMMRegister dst, XMMRegister src, int vector_len) {
2637   assert(VM_Version::supports_evex(), &quot;&quot;);
2638   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
2639   attributes.set_is_evex_instruction();
2640   int prefix = (_legacy_mode_bw) ? VEX_SIMD_F2 : VEX_SIMD_F3;
2641   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), (Assembler::VexSimdPrefix)prefix, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2642   emit_int8(0x6F);</span>
<span class="line-removed">2643   emit_int8((unsigned char)(0xC0 | encode));</span>
2644 }
2645 
2646 void Assembler::evmovdqub(XMMRegister dst, Address src, int vector_len) {
2647   assert(VM_Version::supports_evex(), &quot;&quot;);
2648   InstructionMark im(this);
2649   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
2650   int prefix = (_legacy_mode_bw) ? VEX_SIMD_F2 : VEX_SIMD_F3;
2651   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2652   attributes.set_is_evex_instruction();
2653   vex_prefix(src, 0, dst-&gt;encoding(), (Assembler::VexSimdPrefix)prefix, VEX_OPCODE_0F, &amp;attributes);
2654   emit_int8(0x6F);
2655   emit_operand(dst, src);
2656 }
2657 
2658 void Assembler::evmovdqub(Address dst, XMMRegister src, int vector_len) {
2659   assert(VM_Version::supports_evex(), &quot;&quot;);
2660   assert(src != xnoreg, &quot;sanity&quot;);
2661   InstructionMark im(this);
2662   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
2663   int prefix = (_legacy_mode_bw) ? VEX_SIMD_F2 : VEX_SIMD_F3;
</pre>
<hr />
<pre>
2719 
2720 void Assembler::evmovdquw(Address dst, KRegister mask, XMMRegister src, int vector_len) {
2721   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
2722   assert(src != xnoreg, &quot;sanity&quot;);
2723   InstructionMark im(this);
2724   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
2725   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2726   attributes.reset_is_clear_context();
2727   attributes.set_embedded_opmask_register_specifier(mask);
2728   attributes.set_is_evex_instruction();
2729   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2730   emit_int8(0x7F);
2731   emit_operand(src, dst);
2732 }
2733 
2734 void Assembler::evmovdqul(XMMRegister dst, XMMRegister src, int vector_len) {
2735   assert(VM_Version::supports_evex(), &quot;&quot;);
2736   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2737   attributes.set_is_evex_instruction();
2738   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2739   emit_int8(0x6F);</span>
<span class="line-removed">2740   emit_int8((unsigned char)(0xC0 | encode));</span>
2741 }
2742 
2743 void Assembler::evmovdqul(XMMRegister dst, Address src, int vector_len) {
2744   assert(VM_Version::supports_evex(), &quot;&quot;);
2745   InstructionMark im(this);
2746   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true , /* uses_vl */ true);
2747   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2748   attributes.set_is_evex_instruction();
2749   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2750   emit_int8(0x6F);
2751   emit_operand(dst, src);
2752 }
2753 
2754 void Assembler::evmovdqul(Address dst, XMMRegister src, int vector_len) {
2755   assert(VM_Version::supports_evex(), &quot;&quot;);
2756   assert(src != xnoreg, &quot;sanity&quot;);
2757   InstructionMark im(this);
2758   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2759   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2760   attributes.reset_is_clear_context();
2761   attributes.set_is_evex_instruction();
2762   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2763   emit_int8(0x7F);
2764   emit_operand(src, dst);
2765 }
2766 
2767 void Assembler::evmovdquq(XMMRegister dst, XMMRegister src, int vector_len) {
2768   assert(VM_Version::supports_evex(), &quot;&quot;);
2769   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2770   attributes.set_is_evex_instruction();
2771   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2772   emit_int8(0x6F);</span>
<span class="line-removed">2773   emit_int8((unsigned char)(0xC0 | encode));</span>
2774 }
2775 
2776 void Assembler::evmovdquq(XMMRegister dst, Address src, int vector_len) {
2777   assert(VM_Version::supports_evex(), &quot;&quot;);
2778   InstructionMark im(this);
2779   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2780   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2781   attributes.set_is_evex_instruction();
2782   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2783   emit_int8(0x6F);
2784   emit_operand(dst, src);
2785 }
2786 
2787 void Assembler::evmovdquq(Address dst, XMMRegister src, int vector_len) {
2788   assert(VM_Version::supports_evex(), &quot;&quot;);
2789   assert(src != xnoreg, &quot;sanity&quot;);
2790   InstructionMark im(this);
2791   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2792   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2793   attributes.reset_is_clear_context();
2794   attributes.set_is_evex_instruction();
2795   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2796   emit_int8(0x7F);
2797   emit_operand(src, dst);
2798 }
2799 
2800 // Uses zero extension on 64bit
2801 
2802 void Assembler::movl(Register dst, int32_t imm32) {
2803   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">2804   emit_int8((unsigned char)(0xB8 | encode));</span>
2805   emit_int32(imm32);
2806 }
2807 
2808 void Assembler::movl(Register dst, Register src) {
2809   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">2810   emit_int8((unsigned char)0x8B);</span>
<span class="line-removed">2811   emit_int8((unsigned char)(0xC0 | encode));</span>
2812 }
2813 
2814 void Assembler::movl(Register dst, Address src) {
2815   InstructionMark im(this);
2816   prefix(src, dst);
2817   emit_int8((unsigned char)0x8B);
2818   emit_operand(dst, src);
2819 }
2820 
2821 void Assembler::movl(Address dst, int32_t imm32) {
2822   InstructionMark im(this);
2823   prefix(dst);
2824   emit_int8((unsigned char)0xC7);
2825   emit_operand(rax, dst, 4);
2826   emit_int32(imm32);
2827 }
2828 
2829 void Assembler::movl(Address dst, Register src) {
2830   InstructionMark im(this);
2831   prefix(dst, src);
2832   emit_int8((unsigned char)0x89);
2833   emit_operand(src, dst);
2834 }
2835 
2836 // New cpus require to use movsd and movss to avoid partial register stall
2837 // when loading from memory. But for old Opteron use movlpd instead of movsd.
2838 // The selection is done in MacroAssembler::movdbl() and movflt().
2839 void Assembler::movlpd(XMMRegister dst, Address src) {
2840   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2841   InstructionMark im(this);
2842   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2843   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2844   attributes.set_rex_vex_w_reverted();
2845   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2846   emit_int8(0x12);
2847   emit_operand(dst, src);
2848 }
2849 
<span class="line-removed">2850 void Assembler::movq( MMXRegister dst, Address src ) {</span>
<span class="line-removed">2851   assert( VM_Version::supports_mmx(), &quot;&quot; );</span>
<span class="line-removed">2852   emit_int8(0x0F);</span>
<span class="line-removed">2853   emit_int8(0x6F);</span>
<span class="line-removed">2854   emit_operand(dst, src);</span>
<span class="line-removed">2855 }</span>
<span class="line-removed">2856 </span>
<span class="line-removed">2857 void Assembler::movq( Address dst, MMXRegister src ) {</span>
<span class="line-removed">2858   assert( VM_Version::supports_mmx(), &quot;&quot; );</span>
<span class="line-removed">2859   emit_int8(0x0F);</span>
<span class="line-removed">2860   emit_int8(0x7F);</span>
<span class="line-removed">2861   // workaround gcc (3.2.1-7a) bug</span>
<span class="line-removed">2862   // In that version of gcc with only an emit_operand(MMX, Address)</span>
<span class="line-removed">2863   // gcc will tail jump and try and reverse the parameters completely</span>
<span class="line-removed">2864   // obliterating dst in the process. By having a version available</span>
<span class="line-removed">2865   // that doesn&#39;t need to swap the args at the tail jump the bug is</span>
<span class="line-removed">2866   // avoided.</span>
<span class="line-removed">2867   emit_operand(dst, src);</span>
<span class="line-removed">2868 }</span>
<span class="line-removed">2869 </span>
2870 void Assembler::movq(XMMRegister dst, Address src) {
2871   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2872   InstructionMark im(this);
2873   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2874   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2875   attributes.set_rex_vex_w_reverted();
2876   simd_prefix(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2877   emit_int8(0x7E);
2878   emit_operand(dst, src);
2879 }
2880 
2881 void Assembler::movq(Address dst, XMMRegister src) {
2882   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2883   InstructionMark im(this);
2884   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2885   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2886   attributes.set_rex_vex_w_reverted();
2887   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2888   emit_int8((unsigned char)0xD6);
2889   emit_operand(src, dst);
2890 }
2891 
2892 void Assembler::movsbl(Register dst, Address src) { // movsxb
2893   InstructionMark im(this);
2894   prefix(src, dst);
<span class="line-modified">2895   emit_int8(0x0F);</span>
<span class="line-removed">2896   emit_int8((unsigned char)0xBE);</span>
2897   emit_operand(dst, src);
2898 }
2899 
2900 void Assembler::movsbl(Register dst, Register src) { // movsxb
2901   NOT_LP64(assert(src-&gt;has_byte_register(), &quot;must have byte register&quot;));
2902   int encode = prefix_and_encode(dst-&gt;encoding(), false, src-&gt;encoding(), true);
<span class="line-modified">2903   emit_int8(0x0F);</span>
<span class="line-removed">2904   emit_int8((unsigned char)0xBE);</span>
<span class="line-removed">2905   emit_int8((unsigned char)(0xC0 | encode));</span>
2906 }
2907 
2908 void Assembler::movsd(XMMRegister dst, XMMRegister src) {
2909   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2910   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2911   attributes.set_rex_vex_w_reverted();
2912   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2913   emit_int8(0x10);</span>
<span class="line-removed">2914   emit_int8((unsigned char)(0xC0 | encode));</span>
2915 }
2916 
2917 void Assembler::movsd(XMMRegister dst, Address src) {
2918   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2919   InstructionMark im(this);
2920   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2921   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2922   attributes.set_rex_vex_w_reverted();
2923   simd_prefix(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2924   emit_int8(0x10);
2925   emit_operand(dst, src);
2926 }
2927 
2928 void Assembler::movsd(Address dst, XMMRegister src) {
2929   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2930   InstructionMark im(this);
2931   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2932   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2933   attributes.reset_is_clear_context();
2934   attributes.set_rex_vex_w_reverted();
2935   simd_prefix(src, xnoreg, dst, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2936   emit_int8(0x11);
2937   emit_operand(src, dst);
2938 }
2939 
2940 void Assembler::movss(XMMRegister dst, XMMRegister src) {
2941   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2942   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2943   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2944   emit_int8(0x10);</span>
<span class="line-removed">2945   emit_int8((unsigned char)(0xC0 | encode));</span>
2946 }
2947 
2948 void Assembler::movss(XMMRegister dst, Address src) {
2949   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2950   InstructionMark im(this);
2951   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2952   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2953   simd_prefix(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2954   emit_int8(0x10);
2955   emit_operand(dst, src);
2956 }
2957 
2958 void Assembler::movss(Address dst, XMMRegister src) {
2959   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2960   InstructionMark im(this);
2961   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2962   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2963   attributes.reset_is_clear_context();
2964   simd_prefix(src, xnoreg, dst, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2965   emit_int8(0x11);
2966   emit_operand(src, dst);
2967 }
2968 
2969 void Assembler::movswl(Register dst, Address src) { // movsxw
2970   InstructionMark im(this);
2971   prefix(src, dst);
<span class="line-modified">2972   emit_int8(0x0F);</span>
<span class="line-removed">2973   emit_int8((unsigned char)0xBF);</span>
2974   emit_operand(dst, src);
2975 }
2976 
2977 void Assembler::movswl(Register dst, Register src) { // movsxw
2978   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">2979   emit_int8(0x0F);</span>
<span class="line-removed">2980   emit_int8((unsigned char)0xBF);</span>
<span class="line-removed">2981   emit_int8((unsigned char)(0xC0 | encode));</span>
2982 }
2983 
2984 void Assembler::movw(Address dst, int imm16) {
2985   InstructionMark im(this);
2986 
2987   emit_int8(0x66); // switch to 16-bit mode
2988   prefix(dst);
2989   emit_int8((unsigned char)0xC7);
2990   emit_operand(rax, dst, 2);
2991   emit_int16(imm16);
2992 }
2993 
2994 void Assembler::movw(Register dst, Address src) {
2995   InstructionMark im(this);
2996   emit_int8(0x66);
2997   prefix(src, dst);
2998   emit_int8((unsigned char)0x8B);
2999   emit_operand(dst, src);
3000 }
3001 
3002 void Assembler::movw(Address dst, Register src) {
3003   InstructionMark im(this);
3004   emit_int8(0x66);
3005   prefix(dst, src);
3006   emit_int8((unsigned char)0x89);
3007   emit_operand(src, dst);
3008 }
3009 
3010 void Assembler::movzbl(Register dst, Address src) { // movzxb
3011   InstructionMark im(this);
3012   prefix(src, dst);
<span class="line-modified">3013   emit_int8(0x0F);</span>
<span class="line-removed">3014   emit_int8((unsigned char)0xB6);</span>
3015   emit_operand(dst, src);
3016 }
3017 
3018 void Assembler::movzbl(Register dst, Register src) { // movzxb
3019   NOT_LP64(assert(src-&gt;has_byte_register(), &quot;must have byte register&quot;));
3020   int encode = prefix_and_encode(dst-&gt;encoding(), false, src-&gt;encoding(), true);
<span class="line-modified">3021   emit_int8(0x0F);</span>
<span class="line-removed">3022   emit_int8((unsigned char)0xB6);</span>
<span class="line-removed">3023   emit_int8(0xC0 | encode);</span>
3024 }
3025 
3026 void Assembler::movzwl(Register dst, Address src) { // movzxw
3027   InstructionMark im(this);
3028   prefix(src, dst);
<span class="line-modified">3029   emit_int8(0x0F);</span>
<span class="line-removed">3030   emit_int8((unsigned char)0xB7);</span>
3031   emit_operand(dst, src);
3032 }
3033 
3034 void Assembler::movzwl(Register dst, Register src) { // movzxw
3035   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">3036   emit_int8(0x0F);</span>
<span class="line-removed">3037   emit_int8((unsigned char)0xB7);</span>
<span class="line-removed">3038   emit_int8(0xC0 | encode);</span>
3039 }
3040 
3041 void Assembler::mull(Address src) {
3042   InstructionMark im(this);
3043   prefix(src);
3044   emit_int8((unsigned char)0xF7);
3045   emit_operand(rsp, src);
3046 }
3047 
3048 void Assembler::mull(Register src) {
3049   int encode = prefix_and_encode(src-&gt;encoding());
<span class="line-modified">3050   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">3051   emit_int8((unsigned char)(0xE0 | encode));</span>
3052 }
3053 
3054 void Assembler::mulsd(XMMRegister dst, Address src) {
3055   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
3056   InstructionMark im(this);
3057   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
3058   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
3059   attributes.set_rex_vex_w_reverted();
3060   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
3061   emit_int8(0x59);
3062   emit_operand(dst, src);
3063 }
3064 
3065 void Assembler::mulsd(XMMRegister dst, XMMRegister src) {
3066   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
3067   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
3068   attributes.set_rex_vex_w_reverted();
3069   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3070   emit_int8(0x59);</span>
<span class="line-removed">3071   emit_int8((unsigned char)(0xC0 | encode));</span>
3072 }
3073 
3074 void Assembler::mulss(XMMRegister dst, Address src) {
3075   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
3076   InstructionMark im(this);
3077   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
3078   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
3079   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
3080   emit_int8(0x59);
3081   emit_operand(dst, src);
3082 }
3083 
3084 void Assembler::mulss(XMMRegister dst, XMMRegister src) {
3085   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
3086   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
3087   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3088   emit_int8(0x59);</span>
<span class="line-removed">3089   emit_int8((unsigned char)(0xC0 | encode));</span>
3090 }
3091 
3092 void Assembler::negl(Register dst) {
3093   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">3094   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">3095   emit_int8((unsigned char)(0xD8 | encode));</span>
3096 }
3097 
3098 void Assembler::nop(int i) {
3099 #ifdef ASSERT
3100   assert(i &gt; 0, &quot; &quot;);
3101   // The fancy nops aren&#39;t currently recognized by debuggers making it a
3102   // pain to disassemble code while debugging. If asserts are on clearly
3103   // speed is not an issue so simply use the single byte traditional nop
3104   // to do alignment.
3105 
3106   for (; i &gt; 0 ; i--) emit_int8((unsigned char)0x90);
3107   return;
3108 
3109 #endif // ASSERT
3110 
3111   if (UseAddressNop &amp;&amp; VM_Version::is_intel()) {
3112     //
3113     // Using multi-bytes nops &quot;0x0F 0x1F [address]&quot; for Intel
3114     //  1: 0x90
3115     //  2: 0x66 0x90
3116     //  3: 0x66 0x66 0x90 (don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding)
3117     //  4: 0x0F 0x1F 0x40 0x00
3118     //  5: 0x0F 0x1F 0x44 0x00 0x00
3119     //  6: 0x66 0x0F 0x1F 0x44 0x00 0x00
3120     //  7: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
3121     //  8: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3122     //  9: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3123     // 10: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3124     // 11: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3125 
3126     // The rest coding is Intel specific - don&#39;t use consecutive address nops
3127 
3128     // 12: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3129     // 13: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3130     // 14: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3131     // 15: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3132 
3133     while(i &gt;= 15) {
3134       // For Intel don&#39;t generate consecutive addess nops (mix with regular nops)
3135       i -= 15;
<span class="line-modified">3136       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">3137       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">3138       emit_int8(0x66);   // size prefix</span>
3139       addr_nop_8();
<span class="line-modified">3140       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">3141       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">3142       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">3143       emit_int8((unsigned char)0x90);</span>
<span class="line-removed">3144                          // nop</span>
3145     }
3146     switch (i) {
3147       case 14:
3148         emit_int8(0x66); // size prefix
3149       case 13:
3150         emit_int8(0x66); // size prefix
3151       case 12:
3152         addr_nop_8();
<span class="line-modified">3153         emit_int8(0x66); // size prefix</span>
<span class="line-removed">3154         emit_int8(0x66); // size prefix</span>
<span class="line-removed">3155         emit_int8(0x66); // size prefix</span>
<span class="line-removed">3156         emit_int8((unsigned char)0x90);</span>
<span class="line-removed">3157                          // nop</span>
3158         break;
3159       case 11:
3160         emit_int8(0x66); // size prefix
3161       case 10:
3162         emit_int8(0x66); // size prefix
3163       case 9:
3164         emit_int8(0x66); // size prefix
3165       case 8:
3166         addr_nop_8();
3167         break;
3168       case 7:
3169         addr_nop_7();
3170         break;
3171       case 6:
3172         emit_int8(0x66); // size prefix
3173       case 5:
3174         addr_nop_5();
3175         break;
3176       case 4:
3177         addr_nop_4();
</pre>
<hr />
<pre>
3199     //  4: 0x0F 0x1F 0x40 0x00
3200     //  5: 0x0F 0x1F 0x44 0x00 0x00
3201     //  6: 0x66 0x0F 0x1F 0x44 0x00 0x00
3202     //  7: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
3203     //  8: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3204     //  9: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3205     // 10: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3206     // 11: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3207 
3208     // The rest coding is AMD specific - use consecutive address nops
3209 
3210     // 12: 0x66 0x0F 0x1F 0x44 0x00 0x00 0x66 0x0F 0x1F 0x44 0x00 0x00
3211     // 13: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00 0x66 0x0F 0x1F 0x44 0x00 0x00
3212     // 14: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
3213     // 15: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
3214     // 16: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3215     //     Size prefixes (0x66) are added for larger sizes
3216 
3217     while(i &gt;= 22) {
3218       i -= 11;
<span class="line-modified">3219       emit_int8(0x66); // size prefix</span>
<span class="line-removed">3220       emit_int8(0x66); // size prefix</span>
<span class="line-removed">3221       emit_int8(0x66); // size prefix</span>
3222       addr_nop_8();
3223     }
3224     // Generate first nop for size between 21-12
3225     switch (i) {
3226       case 21:
3227         i -= 1;
3228         emit_int8(0x66); // size prefix
3229       case 20:
3230       case 19:
3231         i -= 1;
3232         emit_int8(0x66); // size prefix
3233       case 18:
3234       case 17:
3235         i -= 1;
3236         emit_int8(0x66); // size prefix
3237       case 16:
3238       case 15:
3239         i -= 8;
3240         addr_nop_8();
3241         break;
</pre>
<hr />
<pre>
3298     //  3: 0x66 0x66 0x90 (don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding)
3299     //  4: 0x0F 0x1F 0x40 0x00
3300     //  5: 0x0F 0x1F 0x44 0x00 0x00
3301     //  6: 0x66 0x0F 0x1F 0x44 0x00 0x00
3302     //  7: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
3303     //  8: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3304     //  9: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3305     // 10: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3306     // 11: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3307 
3308     // The rest coding is ZX specific - don&#39;t use consecutive address nops
3309 
3310     // 12: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3311     // 13: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3312     // 14: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3313     // 15: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3314 
3315     while (i &gt;= 15) {
3316       // For ZX don&#39;t generate consecutive addess nops (mix with regular nops)
3317       i -= 15;
<span class="line-modified">3318       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">3319       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">3320       emit_int8(0x66);   // size prefix</span>
3321       addr_nop_8();
<span class="line-modified">3322       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">3323       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">3324       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">3325       emit_int8((unsigned char)0x90);</span>
<span class="line-removed">3326                          // nop</span>
3327     }
3328     switch (i) {
3329       case 14:
3330         emit_int8(0x66); // size prefix
3331       case 13:
3332         emit_int8(0x66); // size prefix
3333       case 12:
3334         addr_nop_8();
<span class="line-modified">3335         emit_int8(0x66); // size prefix</span>
<span class="line-removed">3336         emit_int8(0x66); // size prefix</span>
<span class="line-removed">3337         emit_int8(0x66); // size prefix</span>
<span class="line-removed">3338         emit_int8((unsigned char)0x90);</span>
<span class="line-removed">3339                          // nop</span>
3340         break;
3341       case 11:
3342         emit_int8(0x66); // size prefix
3343       case 10:
3344         emit_int8(0x66); // size prefix
3345       case 9:
3346         emit_int8(0x66); // size prefix
3347       case 8:
3348         addr_nop_8();
3349         break;
3350       case 7:
3351         addr_nop_7();
3352         break;
3353       case 6:
3354         emit_int8(0x66); // size prefix
3355       case 5:
3356         addr_nop_5();
3357         break;
3358       case 4:
3359         addr_nop_4();
</pre>
<hr />
<pre>
3369         break;
3370       default:
3371         assert(i == 0, &quot; &quot;);
3372     }
3373     return;
3374   }
3375 
3376   // Using nops with size prefixes &quot;0x66 0x90&quot;.
3377   // From AMD Optimization Guide:
3378   //  1: 0x90
3379   //  2: 0x66 0x90
3380   //  3: 0x66 0x66 0x90
3381   //  4: 0x66 0x66 0x66 0x90
3382   //  5: 0x66 0x66 0x90 0x66 0x90
3383   //  6: 0x66 0x66 0x90 0x66 0x66 0x90
3384   //  7: 0x66 0x66 0x66 0x90 0x66 0x66 0x90
3385   //  8: 0x66 0x66 0x66 0x90 0x66 0x66 0x66 0x90
3386   //  9: 0x66 0x66 0x90 0x66 0x66 0x90 0x66 0x66 0x90
3387   // 10: 0x66 0x66 0x66 0x90 0x66 0x66 0x90 0x66 0x66 0x90
3388   //
<span class="line-modified">3389   while(i &gt; 12) {</span>
3390     i -= 4;
<span class="line-modified">3391     emit_int8(0x66); // size prefix</span>
<span class="line-removed">3392     emit_int8(0x66);</span>
<span class="line-removed">3393     emit_int8(0x66);</span>
<span class="line-removed">3394     emit_int8((unsigned char)0x90);</span>
<span class="line-removed">3395                      // nop</span>
3396   }
3397   // 1 - 12 nops
<span class="line-modified">3398   if(i &gt; 8) {</span>
<span class="line-modified">3399     if(i &gt; 9) {</span>
3400       i -= 1;
3401       emit_int8(0x66);
3402     }
3403     i -= 3;
<span class="line-modified">3404     emit_int8(0x66);</span>
<span class="line-removed">3405     emit_int8(0x66);</span>
<span class="line-removed">3406     emit_int8((unsigned char)0x90);</span>
3407   }
3408   // 1 - 8 nops
<span class="line-modified">3409   if(i &gt; 4) {</span>
<span class="line-modified">3410     if(i &gt; 6) {</span>
3411       i -= 1;
3412       emit_int8(0x66);
3413     }
3414     i -= 3;
<span class="line-modified">3415     emit_int8(0x66);</span>
<span class="line-removed">3416     emit_int8(0x66);</span>
<span class="line-removed">3417     emit_int8((unsigned char)0x90);</span>
3418   }
3419   switch (i) {
3420     case 4:
3421       emit_int8(0x66);
3422     case 3:
3423       emit_int8(0x66);
3424     case 2:
3425       emit_int8(0x66);
3426     case 1:
3427       emit_int8((unsigned char)0x90);
3428       break;
3429     default:
3430       assert(i == 0, &quot; &quot;);
3431   }
3432 }
3433 
3434 void Assembler::notl(Register dst) {
3435   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">3436   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">3437   emit_int8((unsigned char)(0xD0 | encode));</span>
3438 }
3439 
3440 void Assembler::orl(Address dst, int32_t imm32) {
3441   InstructionMark im(this);
3442   prefix(dst);
3443   emit_arith_operand(0x81, rcx, dst, imm32);
3444 }
3445 
3446 void Assembler::orl(Register dst, int32_t imm32) {
3447   prefix(dst);
3448   emit_arith(0x81, 0xC8, dst, imm32);
3449 }
3450 
3451 void Assembler::orl(Register dst, Address src) {
3452   InstructionMark im(this);
3453   prefix(src, dst);
3454   emit_int8(0x0B);
3455   emit_operand(dst, src);
3456 }
3457 
</pre>
<hr />
<pre>
3473   emit_int8((unsigned char)0x80);
3474   emit_operand(rcx, dst, 1);
3475   emit_int8(imm8);
3476 }
3477 
3478 void Assembler::packuswb(XMMRegister dst, Address src) {
3479   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
3480   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
3481   InstructionMark im(this);
3482   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3483   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
3484   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3485   emit_int8(0x67);
3486   emit_operand(dst, src);
3487 }
3488 
3489 void Assembler::packuswb(XMMRegister dst, XMMRegister src) {
3490   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
3491   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3492   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3493   emit_int8(0x67);</span>
<span class="line-removed">3494   emit_int8((unsigned char)(0xC0 | encode));</span>
3495 }
3496 
3497 void Assembler::vpackuswb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3498   assert(UseAVX &gt; 0, &quot;some form of AVX must be enabled&quot;);
3499   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3500   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3501   emit_int8(0x67);</span>
<span class="line-removed">3502   emit_int8((unsigned char)(0xC0 | encode));</span>
3503 }
3504 
3505 void Assembler::vpermq(XMMRegister dst, XMMRegister src, int imm8, int vector_len) {
3506   assert(VM_Version::supports_avx2(), &quot;&quot;);
3507   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3508   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3509   emit_int8(0x00);</span>
<span class="line-removed">3510   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">3511   emit_int8(imm8);</span>
3512 }
3513 
3514 void Assembler::vpermq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3515   assert(UseAVX &gt; 2, &quot;requires AVX512F&quot;);
3516   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3517   attributes.set_is_evex_instruction();
3518   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3519   emit_int8((unsigned char)0x36);</span>
<span class="line-removed">3520   emit_int8((unsigned char)(0xC0 | encode));</span>
3521 }
3522 
3523 void Assembler::vperm2i128(XMMRegister dst,  XMMRegister nds, XMMRegister src, int imm8) {
3524   assert(VM_Version::supports_avx2(), &quot;&quot;);
3525   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3526   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3527   emit_int8(0x46);</span>
<span class="line-removed">3528   emit_int8(0xC0 | encode);</span>
<span class="line-removed">3529   emit_int8(imm8);</span>
3530 }
3531 
3532 void Assembler::vperm2f128(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8) {
3533   assert(VM_Version::supports_avx(), &quot;&quot;);
3534   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3535   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3536   emit_int8(0x06);</span>
<span class="line-removed">3537   emit_int8(0xC0 | encode);</span>
<span class="line-removed">3538   emit_int8(imm8);</span>
3539 }
3540 
3541 void Assembler::evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3542   assert(VM_Version::supports_evex(), &quot;&quot;);
3543   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3544   attributes.set_is_evex_instruction();
3545   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3546   emit_int8(0x76);</span>
<span class="line-removed">3547   emit_int8((unsigned char)(0xC0 | encode));</span>
3548 }
3549 
3550 
3551 void Assembler::pause() {
<span class="line-modified">3552   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">3553   emit_int8((unsigned char)0x90);</span>
3554 }
3555 
3556 void Assembler::ud2() {
<span class="line-modified">3557   emit_int8(0x0F);</span>
<span class="line-removed">3558   emit_int8(0x0B);</span>
3559 }
3560 
3561 void Assembler::pcmpestri(XMMRegister dst, Address src, int imm8) {
3562   assert(VM_Version::supports_sse4_2(), &quot;&quot;);
3563   InstructionMark im(this);
3564   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3565   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3566   emit_int8(0x61);
3567   emit_operand(dst, src);
3568   emit_int8(imm8);
3569 }
3570 
3571 void Assembler::pcmpestri(XMMRegister dst, XMMRegister src, int imm8) {
3572   assert(VM_Version::supports_sse4_2(), &quot;&quot;);
3573   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3574   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3575   emit_int8(0x61);</span>
<span class="line-removed">3576   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">3577   emit_int8(imm8);</span>
3578 }
3579 
3580 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3581 void Assembler::pcmpeqb(XMMRegister dst, XMMRegister src) {
3582   assert(VM_Version::supports_sse2(), &quot;&quot;);
3583   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3584   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3585   emit_int8(0x74);</span>
<span class="line-removed">3586   emit_int8((unsigned char)(0xC0 | encode));</span>
3587 }
3588 
3589 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3590 void Assembler::vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3591   assert(VM_Version::supports_avx(), &quot;&quot;);
3592   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3593   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3594   emit_int8(0x74);</span>
<span class="line-removed">3595   emit_int8((unsigned char)(0xC0 | encode));</span>
3596 }
3597 
3598 // In this context, kdst is written the mask used to process the equal components
3599 void Assembler::evpcmpeqb(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
3600   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
3601   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3602   attributes.set_is_evex_instruction();
3603   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3604   emit_int8(0x74);</span>
<span class="line-removed">3605   emit_int8((unsigned char)(0xC0 | encode));</span>
3606 }
3607 
3608 void Assembler::evpcmpgtb(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3609   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3610   InstructionMark im(this);
3611   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3612   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3613   attributes.set_is_evex_instruction();
3614   int dst_enc = kdst-&gt;encoding();
3615   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3616   emit_int8(0x64);
3617   emit_operand(as_Register(dst_enc), src);
3618 }
3619 
3620 void Assembler::evpcmpgtb(KRegister kdst, KRegister mask, XMMRegister nds, Address src, int vector_len) {
3621   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3622   InstructionMark im(this);
3623   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
3624   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3625   attributes.reset_is_clear_context();
3626   attributes.set_embedded_opmask_register_specifier(mask);
3627   attributes.set_is_evex_instruction();
3628   int dst_enc = kdst-&gt;encoding();
3629   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3630   emit_int8(0x64);
3631   emit_operand(as_Register(dst_enc), src);
3632 }
3633 
3634 void Assembler::evpcmpuw(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {
3635   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3636   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3637   attributes.set_is_evex_instruction();
3638   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3639   emit_int8(0x3E);</span>
<span class="line-removed">3640   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">3641   emit_int8(vcc);</span>
3642 }
3643 
3644 void Assembler::evpcmpuw(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {
3645   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3646   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
3647   attributes.reset_is_clear_context();
3648   attributes.set_embedded_opmask_register_specifier(mask);
3649   attributes.set_is_evex_instruction();
3650   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3651   emit_int8(0x3E);</span>
<span class="line-removed">3652   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">3653   emit_int8(vcc);</span>
3654 }
3655 
3656 void Assembler::evpcmpuw(KRegister kdst, XMMRegister nds, Address src, ComparisonPredicate vcc, int vector_len) {
3657   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3658   InstructionMark im(this);
3659   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3660   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3661   attributes.set_is_evex_instruction();
3662   int dst_enc = kdst-&gt;encoding();
3663   vex_prefix(src, nds-&gt;encoding(), kdst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3664   emit_int8(0x3E);
3665   emit_operand(as_Register(dst_enc), src);
3666   emit_int8(vcc);
3667 }
3668 
3669 void Assembler::evpcmpeqb(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3670   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
3671   InstructionMark im(this);
3672   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3673   attributes.set_is_evex_instruction();
</pre>
<hr />
<pre>
3679 }
3680 
3681 void Assembler::evpcmpeqb(KRegister kdst, KRegister mask, XMMRegister nds, Address src, int vector_len) {
3682   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3683   InstructionMark im(this);
3684   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_reg_mask */ false, /* uses_vl */ true);
3685   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3686   attributes.reset_is_clear_context();
3687   attributes.set_embedded_opmask_register_specifier(mask);
3688   attributes.set_is_evex_instruction();
3689   vex_prefix(src, nds-&gt;encoding(), kdst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3690   emit_int8(0x74);
3691   emit_operand(as_Register(kdst-&gt;encoding()), src);
3692 }
3693 
3694 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3695 void Assembler::pcmpeqw(XMMRegister dst, XMMRegister src) {
3696   assert(VM_Version::supports_sse2(), &quot;&quot;);
3697   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3698   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3699   emit_int8(0x75);</span>
<span class="line-removed">3700   emit_int8((unsigned char)(0xC0 | encode));</span>
3701 }
3702 
3703 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3704 void Assembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3705   assert(VM_Version::supports_avx(), &quot;&quot;);
3706   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3707   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3708   emit_int8(0x75);</span>
<span class="line-removed">3709   emit_int8((unsigned char)(0xC0 | encode));</span>
3710 }
3711 
3712 // In this context, kdst is written the mask used to process the equal components
3713 void Assembler::evpcmpeqw(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
3714   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
3715   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3716   attributes.set_is_evex_instruction();
3717   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3718   emit_int8(0x75);</span>
<span class="line-removed">3719   emit_int8((unsigned char)(0xC0 | encode));</span>
3720 }
3721 
3722 void Assembler::evpcmpeqw(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3723   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
3724   InstructionMark im(this);
3725   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3726   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3727   attributes.set_is_evex_instruction();
3728   int dst_enc = kdst-&gt;encoding();
3729   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3730   emit_int8(0x75);
3731   emit_operand(as_Register(dst_enc), src);
3732 }
3733 
3734 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3735 void Assembler::pcmpeqd(XMMRegister dst, XMMRegister src) {
3736   assert(VM_Version::supports_sse2(), &quot;&quot;);
3737   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3738   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3739   emit_int8(0x76);</span>
<span class="line-removed">3740   emit_int8((unsigned char)(0xC0 | encode));</span>
3741 }
3742 
3743 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3744 void Assembler::vpcmpeqd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3745   assert(VM_Version::supports_avx(), &quot;&quot;);
3746   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3747   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3748   emit_int8(0x76);</span>
<span class="line-removed">3749   emit_int8((unsigned char)(0xC0 | encode));</span>
3750 }
3751 
3752 // In this context, kdst is written the mask used to process the equal components
3753 void Assembler::evpcmpeqd(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
3754   assert(VM_Version::supports_evex(), &quot;&quot;);
3755   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3756   attributes.set_is_evex_instruction();
3757   attributes.reset_is_clear_context();
3758   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3759   emit_int8(0x76);</span>
<span class="line-removed">3760   emit_int8((unsigned char)(0xC0 | encode));</span>
3761 }
3762 
3763 void Assembler::evpcmpeqd(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3764   assert(VM_Version::supports_evex(), &quot;&quot;);
3765   InstructionMark im(this);
3766   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3767   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
3768   attributes.reset_is_clear_context();
3769   attributes.set_is_evex_instruction();
3770   int dst_enc = kdst-&gt;encoding();
3771   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3772   emit_int8(0x76);
3773   emit_operand(as_Register(dst_enc), src);
3774 }
3775 
3776 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3777 void Assembler::pcmpeqq(XMMRegister dst, XMMRegister src) {
3778   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3779   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3780   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3781   emit_int8(0x29);</span>
<span class="line-removed">3782   emit_int8((unsigned char)(0xC0 | encode));</span>
3783 }
3784 
3785 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3786 void Assembler::vpcmpeqq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3787   assert(VM_Version::supports_avx(), &quot;&quot;);
3788   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3789   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3790   emit_int8(0x29);</span>
<span class="line-removed">3791   emit_int8((unsigned char)(0xC0 | encode));</span>
3792 }
3793 
3794 // In this context, kdst is written the mask used to process the equal components
3795 void Assembler::evpcmpeqq(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
3796   assert(VM_Version::supports_evex(), &quot;&quot;);
3797   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3798   attributes.reset_is_clear_context();
3799   attributes.set_is_evex_instruction();
3800   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3801   emit_int8(0x29);</span>
<span class="line-removed">3802   emit_int8((unsigned char)(0xC0 | encode));</span>
3803 }
3804 
3805 // In this context, kdst is written the mask used to process the equal components
3806 void Assembler::evpcmpeqq(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3807   assert(VM_Version::supports_evex(), &quot;&quot;);
3808   InstructionMark im(this);
3809   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3810   attributes.reset_is_clear_context();
3811   attributes.set_is_evex_instruction();
3812   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
3813   int dst_enc = kdst-&gt;encoding();
3814   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
3815   emit_int8(0x29);
3816   emit_operand(as_Register(dst_enc), src);
3817 }
3818 
3819 void Assembler::pmovmskb(Register dst, XMMRegister src) {
3820   assert(VM_Version::supports_sse2(), &quot;&quot;);
3821   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3822   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3823   emit_int8((unsigned char)0xD7);</span>
<span class="line-removed">3824   emit_int8((unsigned char)(0xC0 | encode));</span>
3825 }
3826 
3827 void Assembler::vpmovmskb(Register dst, XMMRegister src) {
3828   assert(VM_Version::supports_avx2(), &quot;&quot;);
3829   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3830   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3831   emit_int8((unsigned char)0xD7);</span>
<span class="line-removed">3832   emit_int8((unsigned char)(0xC0 | encode));</span>
3833 }
3834 
3835 void Assembler::pextrd(Register dst, XMMRegister src, int imm8) {
3836   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3837   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3838   int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3839   emit_int8(0x16);</span>
<span class="line-removed">3840   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">3841   emit_int8(imm8);</span>
3842 }
3843 
3844 void Assembler::pextrd(Address dst, XMMRegister src, int imm8) {
3845   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3846   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3847   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
3848   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3849   emit_int8(0x16);
3850   emit_operand(src, dst);
3851   emit_int8(imm8);
3852 }
3853 
3854 void Assembler::pextrq(Register dst, XMMRegister src, int imm8) {
3855   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3856   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3857   int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3858   emit_int8(0x16);</span>
<span class="line-removed">3859   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">3860   emit_int8(imm8);</span>
3861 }
3862 
3863 void Assembler::pextrq(Address dst, XMMRegister src, int imm8) {
3864   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3865   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3866   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
3867   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3868   emit_int8(0x16);
3869   emit_operand(src, dst);
3870   emit_int8(imm8);
3871 }
3872 
3873 void Assembler::pextrw(Register dst, XMMRegister src, int imm8) {
3874   assert(VM_Version::supports_sse2(), &quot;&quot;);
3875   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3876   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3877   emit_int8((unsigned char)0xC5);</span>
<span class="line-removed">3878   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">3879   emit_int8(imm8);</span>
3880 }
3881 
3882 void Assembler::pextrw(Address dst, XMMRegister src, int imm8) {
3883   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3884   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3885   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_16bit);
3886   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3887   emit_int8((unsigned char)0x15);</span>
3888   emit_operand(src, dst);
3889   emit_int8(imm8);
3890 }
3891 
3892 void Assembler::pextrb(Address dst, XMMRegister src, int imm8) {
3893   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3894   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3895   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_8bit);
3896   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3897   emit_int8(0x14);
3898   emit_operand(src, dst);
3899   emit_int8(imm8);
3900 }
3901 
3902 void Assembler::pinsrd(XMMRegister dst, Register src, int imm8) {
3903   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3904   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3905   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3906   emit_int8(0x22);</span>
<span class="line-removed">3907   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">3908   emit_int8(imm8);</span>
3909 }
3910 
3911 void Assembler::pinsrd(XMMRegister dst, Address src, int imm8) {
3912   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3913   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3914   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
3915   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3916   emit_int8(0x22);
3917   emit_operand(dst,src);
3918   emit_int8(imm8);
3919 }
3920 
3921 void Assembler::pinsrq(XMMRegister dst, Register src, int imm8) {
3922   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3923   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3924   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3925   emit_int8(0x22);</span>
<span class="line-removed">3926   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">3927   emit_int8(imm8);</span>
3928 }
3929 
3930 void Assembler::pinsrq(XMMRegister dst, Address src, int imm8) {
3931   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3932   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3933   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
3934   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3935   emit_int8(0x22);
3936   emit_operand(dst, src);
3937   emit_int8(imm8);
3938 }
3939 
3940 void Assembler::pinsrw(XMMRegister dst, Register src, int imm8) {
3941   assert(VM_Version::supports_sse2(), &quot;&quot;);
3942   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3943   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3944   emit_int8((unsigned char)0xC4);</span>
<span class="line-removed">3945   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">3946   emit_int8(imm8);</span>
3947 }
3948 
3949 void Assembler::pinsrw(XMMRegister dst, Address src, int imm8) {
3950   assert(VM_Version::supports_sse2(), &quot;&quot;);
3951   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3952   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_16bit);
3953   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3954   emit_int8((unsigned char)0xC4);
3955   emit_operand(dst, src);
3956   emit_int8(imm8);
3957 }
3958 
3959 void Assembler::pinsrb(XMMRegister dst, Address src, int imm8) {
3960   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3961   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3962   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_8bit);
3963   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3964   emit_int8(0x20);
3965   emit_operand(dst, src);
3966   emit_int8(imm8);
3967 }
3968 
3969 void Assembler::pmovzxbw(XMMRegister dst, Address src) {
3970   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3971   InstructionMark im(this);
3972   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3973   attributes.set_address_attributes(/* tuple_type */ EVEX_HVM, /* input_size_in_bits */ EVEX_NObit);
3974   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
3975   emit_int8(0x30);
3976   emit_operand(dst, src);
3977 }
3978 
3979 void Assembler::pmovzxbw(XMMRegister dst, XMMRegister src) {
3980   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3981   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3982   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3983   emit_int8(0x30);</span>
<span class="line-removed">3984   emit_int8((unsigned char)(0xC0 | encode));</span>
3985 }
3986 
3987 void Assembler::pmovsxbw(XMMRegister dst, XMMRegister src) {
3988   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3989   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3990   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3991   emit_int8(0x20);</span>
<span class="line-removed">3992   emit_int8((unsigned char)(0xC0 | encode));</span>
3993 }
3994 
3995 void Assembler::vpmovzxbw(XMMRegister dst, Address src, int vector_len) {
3996   assert(VM_Version::supports_avx(), &quot;&quot;);
3997   InstructionMark im(this);
3998   assert(dst != xnoreg, &quot;sanity&quot;);
3999   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4000   attributes.set_address_attributes(/* tuple_type */ EVEX_HVM, /* input_size_in_bits */ EVEX_NObit);
4001   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4002   emit_int8(0x30);
4003   emit_operand(dst, src);
4004 }
4005 
4006 void Assembler::vpmovzxbw(XMMRegister dst, XMMRegister src, int vector_len) {
4007   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
4008   vector_len == AVX_256bit? VM_Version::supports_avx2() :
4009   vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
4010   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4011   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">4012   emit_int8(0x30);</span>
<span class="line-removed">4013   emit_int8((unsigned char) (0xC0 | encode));</span>
4014 }
4015 
4016 void Assembler::vpmovsxbw(XMMRegister dst, XMMRegister src, int vector_len) {
4017   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
4018   vector_len == AVX_256bit? VM_Version::supports_avx2() :
4019   vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
4020   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4021   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">4022   emit_int8(0x20);</span>
<span class="line-removed">4023   emit_int8((unsigned char)(0xC0 | encode));</span>
4024 }
4025 
4026 void Assembler::evpmovzxbw(XMMRegister dst, KRegister mask, Address src, int vector_len) {
4027   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
4028   assert(dst != xnoreg, &quot;sanity&quot;);
4029   InstructionMark im(this);
4030   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
4031   attributes.set_address_attributes(/* tuple_type */ EVEX_HVM, /* input_size_in_bits */ EVEX_NObit);
4032   attributes.set_embedded_opmask_register_specifier(mask);
4033   attributes.set_is_evex_instruction();
4034   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4035   emit_int8(0x30);
4036   emit_operand(dst, src);
4037 }
4038 void Assembler::evpmovwb(Address dst, XMMRegister src, int vector_len) {
4039   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
4040   assert(src != xnoreg, &quot;sanity&quot;);
4041   InstructionMark im(this);
4042   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4043   attributes.set_address_attributes(/* tuple_type */ EVEX_HVM, /* input_size_in_bits */ EVEX_NObit);
</pre>
<hr />
<pre>
4062 }
4063 
4064 void Assembler::evpmovdb(Address dst, XMMRegister src, int vector_len) {
4065   assert(VM_Version::supports_evex(), &quot;&quot;);
4066   assert(src != xnoreg, &quot;sanity&quot;);
4067   InstructionMark im(this);
4068   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4069   attributes.set_address_attributes(/* tuple_type */ EVEX_QVM, /* input_size_in_bits */ EVEX_NObit);
4070   attributes.set_is_evex_instruction();
4071   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &amp;attributes);
4072   emit_int8(0x31);
4073   emit_operand(src, dst);
4074 }
4075 
4076 void Assembler::vpmovzxwd(XMMRegister dst, XMMRegister src, int vector_len) {
4077   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
4078   vector_len == AVX_256bit? VM_Version::supports_avx2() :
4079   vector_len == AVX_512bit? VM_Version::supports_evex() : 0, &quot; &quot;);
4080   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4081   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">4082   emit_int8(0x33);</span>
<span class="line-removed">4083   emit_int8((unsigned char)(0xC0 | encode));</span>
4084 }
4085 
4086 void Assembler::pmaddwd(XMMRegister dst, XMMRegister src) {
4087   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4088   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4089   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4090   emit_int8((unsigned char)0xF5);</span>
<span class="line-removed">4091   emit_int8((unsigned char)(0xC0 | encode));</span>
4092 }
4093 
4094 void Assembler::vpmaddwd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
4095   assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
4096     (vector_len == AVX_256bit ? VM_Version::supports_avx2() :
4097     (vector_len == AVX_512bit ? VM_Version::supports_evex() : 0)), &quot;&quot;);
4098   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4099   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4100   emit_int8((unsigned char)0xF5);</span>
<span class="line-removed">4101   emit_int8((unsigned char)(0xC0 | encode));</span>
4102 }
4103 
4104 void Assembler::evpdpwssd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
4105   assert(VM_Version::supports_evex(), &quot;&quot;);
<span class="line-modified">4106   assert(VM_Version::supports_vnni(), &quot;must support vnni&quot;);</span>
4107   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4108   attributes.set_is_evex_instruction();
4109   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">4110   emit_int8(0x52);</span>
<span class="line-removed">4111   emit_int8((unsigned char)(0xC0 | encode));</span>
4112 }
4113 
4114 // generic
4115 void Assembler::pop(Register dst) {
4116   int encode = prefix_and_encode(dst-&gt;encoding());
4117   emit_int8(0x58 | encode);
4118 }
4119 
4120 void Assembler::popcntl(Register dst, Address src) {
4121   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);
4122   InstructionMark im(this);
4123   emit_int8((unsigned char)0xF3);
4124   prefix(src, dst);
<span class="line-modified">4125   emit_int8(0x0F);</span>
<span class="line-removed">4126   emit_int8((unsigned char)0xB8);</span>
4127   emit_operand(dst, src);
4128 }
4129 
4130 void Assembler::popcntl(Register dst, Register src) {
4131   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);
4132   emit_int8((unsigned char)0xF3);
4133   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">4134   emit_int8(0x0F);</span>
<span class="line-removed">4135   emit_int8((unsigned char)0xB8);</span>
<span class="line-removed">4136   emit_int8((unsigned char)(0xC0 | encode));</span>
4137 }
4138 
4139 void Assembler::vpopcntd(XMMRegister dst, XMMRegister src, int vector_len) {
<span class="line-modified">4140   assert(VM_Version::supports_vpopcntdq(), &quot;must support vpopcntdq feature&quot;);</span>
4141   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4142   attributes.set_is_evex_instruction();
4143   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">4144   emit_int8(0x55);</span>
<span class="line-removed">4145   emit_int8((unsigned char)(0xC0 | encode));</span>
4146 }
4147 
4148 void Assembler::popf() {
4149   emit_int8((unsigned char)0x9D);
4150 }
4151 
4152 #ifndef _LP64 // no 32bit push/pop on amd64
4153 void Assembler::popl(Address dst) {
4154   // NOTE: this will adjust stack by 8byte on 64bits
4155   InstructionMark im(this);
4156   prefix(dst);
4157   emit_int8((unsigned char)0x8F);
4158   emit_operand(rax, dst);
4159 }
4160 #endif
4161 
<span class="line-removed">4162 void Assembler::prefetch_prefix(Address src) {</span>
<span class="line-removed">4163   prefix(src);</span>
<span class="line-removed">4164   emit_int8(0x0F);</span>
<span class="line-removed">4165 }</span>
<span class="line-removed">4166 </span>
4167 void Assembler::prefetchnta(Address src) {
4168   NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
4169   InstructionMark im(this);
<span class="line-modified">4170   prefetch_prefix(src);</span>
<span class="line-modified">4171   emit_int8(0x18);</span>
4172   emit_operand(rax, src); // 0, src
4173 }
4174 
4175 void Assembler::prefetchr(Address src) {
4176   assert(VM_Version::supports_3dnow_prefetch(), &quot;must support&quot;);
4177   InstructionMark im(this);
<span class="line-modified">4178   prefetch_prefix(src);</span>
<span class="line-modified">4179   emit_int8(0x0D);</span>
4180   emit_operand(rax, src); // 0, src
4181 }
4182 
4183 void Assembler::prefetcht0(Address src) {
4184   NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
4185   InstructionMark im(this);
<span class="line-modified">4186   prefetch_prefix(src);</span>
<span class="line-modified">4187   emit_int8(0x18);</span>
4188   emit_operand(rcx, src); // 1, src
4189 }
4190 
4191 void Assembler::prefetcht1(Address src) {
4192   NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
4193   InstructionMark im(this);
<span class="line-modified">4194   prefetch_prefix(src);</span>
<span class="line-modified">4195   emit_int8(0x18);</span>
4196   emit_operand(rdx, src); // 2, src
4197 }
4198 
4199 void Assembler::prefetcht2(Address src) {
4200   NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
4201   InstructionMark im(this);
<span class="line-modified">4202   prefetch_prefix(src);</span>
<span class="line-modified">4203   emit_int8(0x18);</span>
4204   emit_operand(rbx, src); // 3, src
4205 }
4206 
4207 void Assembler::prefetchw(Address src) {
4208   assert(VM_Version::supports_3dnow_prefetch(), &quot;must support&quot;);
4209   InstructionMark im(this);
<span class="line-modified">4210   prefetch_prefix(src);</span>
<span class="line-modified">4211   emit_int8(0x0D);</span>
4212   emit_operand(rcx, src); // 1, src
4213 }
4214 
4215 void Assembler::prefix(Prefix p) {
4216   emit_int8(p);
4217 }
4218 
4219 void Assembler::pshufb(XMMRegister dst, XMMRegister src) {
4220   assert(VM_Version::supports_ssse3(), &quot;&quot;);
4221   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4222   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">4223   emit_int8(0x00);</span>
<span class="line-removed">4224   emit_int8((unsigned char)(0xC0 | encode));</span>
4225 }
4226 
4227 void Assembler::vpshufb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
4228   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
4229          vector_len == AVX_256bit? VM_Version::supports_avx2() :
4230          vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
4231   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4232   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">4233   emit_int8(0x00);</span>
<span class="line-removed">4234   emit_int8((unsigned char)(0xC0 | encode));</span>
4235 }
4236 
4237 void Assembler::pshufb(XMMRegister dst, Address src) {
4238   assert(VM_Version::supports_ssse3(), &quot;&quot;);
4239   InstructionMark im(this);
4240   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4241   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
4242   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4243   emit_int8(0x00);
4244   emit_operand(dst, src);
4245 }
4246 
4247 void Assembler::pshufd(XMMRegister dst, XMMRegister src, int mode) {
4248   assert(isByte(mode), &quot;invalid value&quot;);
4249   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4250   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
4251   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4252   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4253   emit_int8(0x70);</span>
<span class="line-removed">4254   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">4255   emit_int8(mode &amp; 0xFF);</span>
4256 }
4257 
4258 void Assembler::vpshufd(XMMRegister dst, XMMRegister src, int mode, int vector_len) {
4259   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
4260          (vector_len == AVX_256bit? VM_Version::supports_avx2() :
4261          (vector_len == AVX_512bit? VM_Version::supports_evex() : 0)), &quot;&quot;);
4262   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4263   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4264   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4265   emit_int8(0x70);</span>
<span class="line-removed">4266   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">4267   emit_int8(mode &amp; 0xFF);</span>
4268 }
4269 
4270 void Assembler::pshufd(XMMRegister dst, Address src, int mode) {
4271   assert(isByte(mode), &quot;invalid value&quot;);
4272   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4273   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4274   InstructionMark im(this);
4275   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4276   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
4277   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4278   emit_int8(0x70);
4279   emit_operand(dst, src);
4280   emit_int8(mode &amp; 0xFF);
4281 }
4282 
4283 void Assembler::pshuflw(XMMRegister dst, XMMRegister src, int mode) {
4284   assert(isByte(mode), &quot;invalid value&quot;);
4285   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4286   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4287   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4288   emit_int8(0x70);</span>
<span class="line-removed">4289   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">4290   emit_int8(mode &amp; 0xFF);</span>
4291 }
4292 
4293 void Assembler::pshuflw(XMMRegister dst, Address src, int mode) {
4294   assert(isByte(mode), &quot;invalid value&quot;);
4295   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4296   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4297   InstructionMark im(this);
4298   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4299   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
4300   simd_prefix(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4301   emit_int8(0x70);
4302   emit_operand(dst, src);
4303   emit_int8(mode &amp; 0xFF);
4304 }
4305 
4306 void Assembler::evshufi64x2(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {
4307   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
4308   assert(vector_len == Assembler::AVX_256bit || vector_len == Assembler::AVX_512bit, &quot;&quot;);
4309   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4310   attributes.set_is_evex_instruction();
4311   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">4312   emit_int8(0x43);</span>
<span class="line-removed">4313   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">4314   emit_int8(imm8 &amp; 0xFF);</span>
4315 }
4316 
4317 void Assembler::psrldq(XMMRegister dst, int shift) {
4318   // Shift left 128 bit value in dst XMMRegister by shift number of bytes.
4319   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4320   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4321   int encode = simd_prefix_and_encode(xmm3, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4322   emit_int8(0x73);</span>
<span class="line-removed">4323   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">4324   emit_int8(shift);</span>
4325 }
4326 
4327 void Assembler::vpsrldq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
4328   assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
4329          vector_len == AVX_256bit ? VM_Version::supports_avx2() :
4330          vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
4331   InstructionAttr attributes(vector_len, /*vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4332   int encode = vex_prefix_and_encode(xmm3-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4333   emit_int8(0x73);</span>
<span class="line-removed">4334   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">4335   emit_int8(shift &amp; 0xFF);</span>
4336 }
4337 
4338 void Assembler::pslldq(XMMRegister dst, int shift) {
4339   // Shift left 128 bit value in dst XMMRegister by shift number of bytes.
4340   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4341   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4342   // XMM7 is for /7 encoding: 66 0F 73 /7 ib
4343   int encode = simd_prefix_and_encode(xmm7, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4344   emit_int8(0x73);</span>
<span class="line-removed">4345   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">4346   emit_int8(shift);</span>
4347 }
4348 
4349 void Assembler::vpslldq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
4350   assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
4351          vector_len == AVX_256bit ? VM_Version::supports_avx2() :
4352          vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
4353   InstructionAttr attributes(vector_len, /*vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4354   int encode = vex_prefix_and_encode(xmm7-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4355   emit_int8(0x73);</span>
<span class="line-removed">4356   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">4357   emit_int8(shift &amp; 0xFF);</span>
4358 }
4359 
4360 void Assembler::ptest(XMMRegister dst, Address src) {
4361   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
4362   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4363   InstructionMark im(this);
4364   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4365   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4366   emit_int8(0x17);
4367   emit_operand(dst, src);
4368 }
4369 
4370 void Assembler::ptest(XMMRegister dst, XMMRegister src) {
4371   assert(VM_Version::supports_sse4_1() || VM_Version::supports_avx(), &quot;&quot;);
4372   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4373   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4374   emit_int8(0x17);
<span class="line-modified">4375   emit_int8((unsigned char)(0xC0 | encode));</span>
4376 }
4377 
4378 void Assembler::vptest(XMMRegister dst, Address src) {
4379   assert(VM_Version::supports_avx(), &quot;&quot;);
4380   InstructionMark im(this);
4381   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4382   assert(dst != xnoreg, &quot;sanity&quot;);
4383   // swap src&lt;-&gt;dst for encoding
4384   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4385   emit_int8(0x17);
4386   emit_operand(dst, src);
4387 }
4388 
4389 void Assembler::vptest(XMMRegister dst, XMMRegister src) {
4390   assert(VM_Version::supports_avx(), &quot;&quot;);
4391   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4392   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">4393   emit_int8(0x17);</span>
<span class="line-removed">4394   emit_int8((unsigned char)(0xC0 | encode));</span>
4395 }
4396 
4397 void Assembler::punpcklbw(XMMRegister dst, Address src) {
4398   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4399   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4400   InstructionMark im(this);
4401   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_vlbw, /* no_mask_reg */ true, /* uses_vl */ true);
4402   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
4403   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4404   emit_int8(0x60);
4405   emit_operand(dst, src);
4406 }
4407 
4408 void Assembler::punpcklbw(XMMRegister dst, XMMRegister src) {
4409   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4410   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_vlbw, /* no_mask_reg */ true, /* uses_vl */ true);
4411   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4412   emit_int8(0x60);</span>
<span class="line-removed">4413   emit_int8((unsigned char)(0xC0 | encode));</span>
4414 }
4415 
4416 void Assembler::punpckldq(XMMRegister dst, Address src) {
4417   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4418   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4419   InstructionMark im(this);
4420   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4421   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
4422   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4423   emit_int8(0x62);
4424   emit_operand(dst, src);
4425 }
4426 
4427 void Assembler::punpckldq(XMMRegister dst, XMMRegister src) {
4428   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4429   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4430   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4431   emit_int8(0x62);</span>
<span class="line-removed">4432   emit_int8((unsigned char)(0xC0 | encode));</span>
4433 }
4434 
4435 void Assembler::punpcklqdq(XMMRegister dst, XMMRegister src) {
4436   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4437   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4438   attributes.set_rex_vex_w_reverted();
4439   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4440   emit_int8(0x6C);</span>
<span class="line-removed">4441   emit_int8((unsigned char)(0xC0 | encode));</span>
4442 }
4443 
4444 void Assembler::push(int32_t imm32) {
4445   // in 64bits we push 64bits onto the stack but only
4446   // take a 32bit immediate
4447   emit_int8(0x68);
4448   emit_int32(imm32);
4449 }
4450 
4451 void Assembler::push(Register src) {
4452   int encode = prefix_and_encode(src-&gt;encoding());
<span class="line-removed">4453 </span>
4454   emit_int8(0x50 | encode);
4455 }
4456 
4457 void Assembler::pushf() {
4458   emit_int8((unsigned char)0x9C);
4459 }
4460 
4461 #ifndef _LP64 // no 32bit push/pop on amd64
4462 void Assembler::pushl(Address src) {
4463   // Note this will push 64bit on 64bit
4464   InstructionMark im(this);
4465   prefix(src);
4466   emit_int8((unsigned char)0xFF);
4467   emit_operand(rsi, src);
4468 }
4469 #endif
4470 
4471 void Assembler::rcll(Register dst, int imm8) {
4472   assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
4473   int encode = prefix_and_encode(dst-&gt;encoding());
4474   if (imm8 == 1) {
<span class="line-modified">4475     emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">4476     emit_int8((unsigned char)(0xD0 | encode));</span>
4477   } else {
<span class="line-modified">4478     emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">4479     emit_int8((unsigned char)0xD0 | encode);</span>
<span class="line-removed">4480     emit_int8(imm8);</span>
4481   }
4482 }
4483 
4484 void Assembler::rcpps(XMMRegister dst, XMMRegister src) {
4485   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4486   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4487   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4488   emit_int8(0x53);</span>
<span class="line-removed">4489   emit_int8((unsigned char)(0xC0 | encode));</span>
4490 }
4491 
4492 void Assembler::rcpss(XMMRegister dst, XMMRegister src) {
4493   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4494   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4495   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4496   emit_int8(0x53);</span>
<span class="line-removed">4497   emit_int8((unsigned char)(0xC0 | encode));</span>
4498 }
4499 
4500 void Assembler::rdtsc() {
<span class="line-modified">4501   emit_int8((unsigned char)0x0F);</span>
<span class="line-removed">4502   emit_int8((unsigned char)0x31);</span>
4503 }
4504 
4505 // copies data from [esi] to [edi] using rcx pointer sized words
4506 // generic
4507 void Assembler::rep_mov() {
<span class="line-modified">4508   emit_int8((unsigned char)0xF3);</span>
4509   // MOVSQ
<span class="line-modified">4510   LP64_ONLY(prefix(REX_W));</span>
<span class="line-modified">4511   emit_int8((unsigned char)0xA5);</span>
4512 }
4513 
4514 // sets rcx bytes with rax, value at [edi]
4515 void Assembler::rep_stosb() {
<span class="line-modified">4516   emit_int8((unsigned char)0xF3); // REP</span>
<span class="line-modified">4517   LP64_ONLY(prefix(REX_W));</span>
<span class="line-modified">4518   emit_int8((unsigned char)0xAA); // STOSB</span>

4519 }
4520 
4521 // sets rcx pointer sized words with rax, value at [edi]
4522 // generic
4523 void Assembler::rep_stos() {
<span class="line-modified">4524   emit_int8((unsigned char)0xF3); // REP</span>
<span class="line-modified">4525   LP64_ONLY(prefix(REX_W));       // LP64:STOSQ, LP32:STOSD</span>
<span class="line-modified">4526   emit_int8((unsigned char)0xAB);</span>

4527 }
4528 
4529 // scans rcx pointer sized words at [edi] for occurance of rax,
4530 // generic
4531 void Assembler::repne_scan() { // repne_scan
<span class="line-removed">4532   emit_int8((unsigned char)0xF2);</span>
4533   // SCASQ
<span class="line-modified">4534   LP64_ONLY(prefix(REX_W));</span>
<span class="line-modified">4535   emit_int8((unsigned char)0xAF);</span>
4536 }
4537 
4538 #ifdef _LP64
4539 // scans rcx 4 byte words at [edi] for occurance of rax,
4540 // generic
4541 void Assembler::repne_scanl() { // repne_scan
<span class="line-removed">4542   emit_int8((unsigned char)0xF2);</span>
4543   // SCASL
<span class="line-modified">4544   emit_int8((unsigned char)0xAF);</span>
4545 }
4546 #endif
4547 
4548 void Assembler::ret(int imm16) {
4549   if (imm16 == 0) {
4550     emit_int8((unsigned char)0xC3);
4551   } else {
4552     emit_int8((unsigned char)0xC2);
4553     emit_int16(imm16);
4554   }
4555 }
4556 
4557 void Assembler::sahf() {
4558 #ifdef _LP64
4559   // Not supported in 64bit mode
4560   ShouldNotReachHere();
4561 #endif
4562   emit_int8((unsigned char)0x9E);
4563 }
4564 
4565 void Assembler::sarl(Register dst, int imm8) {
4566   int encode = prefix_and_encode(dst-&gt;encoding());
4567   assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
4568   if (imm8 == 1) {
<span class="line-modified">4569     emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">4570     emit_int8((unsigned char)(0xF8 | encode));</span>
4571   } else {
<span class="line-modified">4572     emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">4573     emit_int8((unsigned char)(0xF8 | encode));</span>
<span class="line-removed">4574     emit_int8(imm8);</span>
4575   }
4576 }
4577 
4578 void Assembler::sarl(Register dst) {
4579   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">4580   emit_int8((unsigned char)0xD3);</span>
<span class="line-removed">4581   emit_int8((unsigned char)(0xF8 | encode));</span>
4582 }
4583 
4584 void Assembler::sbbl(Address dst, int32_t imm32) {
4585   InstructionMark im(this);
4586   prefix(dst);
4587   emit_arith_operand(0x81, rbx, dst, imm32);
4588 }
4589 
4590 void Assembler::sbbl(Register dst, int32_t imm32) {
4591   prefix(dst);
4592   emit_arith(0x81, 0xD8, dst, imm32);
4593 }
4594 
4595 
4596 void Assembler::sbbl(Register dst, Address src) {
4597   InstructionMark im(this);
4598   prefix(src, dst);
4599   emit_int8(0x1B);
4600   emit_operand(dst, src);
4601 }
4602 
4603 void Assembler::sbbl(Register dst, Register src) {
4604   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
4605   emit_arith(0x1B, 0xC0, dst, src);
4606 }
4607 
4608 void Assembler::setb(Condition cc, Register dst) {
4609   assert(0 &lt;= cc &amp;&amp; cc &lt; 16, &quot;illegal cc&quot;);
4610   int encode = prefix_and_encode(dst-&gt;encoding(), true);
<span class="line-modified">4611   emit_int8(0x0F);</span>
<span class="line-removed">4612   emit_int8((unsigned char)0x90 | cc);</span>
<span class="line-removed">4613   emit_int8((unsigned char)(0xC0 | encode));</span>
4614 }
4615 
4616 void Assembler::palignr(XMMRegister dst, XMMRegister src, int imm8) {
4617   assert(VM_Version::supports_ssse3(), &quot;&quot;);
4618   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4619   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">4620   emit_int8((unsigned char)0x0F);</span>
<span class="line-removed">4621   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">4622   emit_int8(imm8);</span>
4623 }
4624 
4625 void Assembler::vpalignr(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {
4626   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
4627          vector_len == AVX_256bit? VM_Version::supports_avx2() :
4628          0, &quot;&quot;);
4629   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4630   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">4631   emit_int8((unsigned char)0x0F);</span>
<span class="line-removed">4632   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">4633   emit_int8(imm8);</span>
4634 }
4635 
4636 void Assembler::evalignq(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
4637   assert(VM_Version::supports_evex(), &quot;&quot;);
4638   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4639   attributes.set_is_evex_instruction();
4640   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">4641   emit_int8(0x3);</span>
<span class="line-removed">4642   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">4643   emit_int8(imm8);</span>
4644 }
4645 
4646 void Assembler::pblendw(XMMRegister dst, XMMRegister src, int imm8) {
4647   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
4648   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4649   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">4650   emit_int8((unsigned char)0x0E);</span>
<span class="line-removed">4651   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">4652   emit_int8(imm8);</span>
4653 }
4654 
4655 void Assembler::sha1rnds4(XMMRegister dst, XMMRegister src, int imm8) {
4656   assert(VM_Version::supports_sha(), &quot;&quot;);
4657   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, /* rex_w */ false);
<span class="line-modified">4658   emit_int8((unsigned char)0xCC);</span>
<span class="line-removed">4659   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">4660   emit_int8((unsigned char)imm8);</span>
4661 }
4662 
4663 void Assembler::sha1nexte(XMMRegister dst, XMMRegister src) {
4664   assert(VM_Version::supports_sha(), &quot;&quot;);
4665   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">4666   emit_int8((unsigned char)0xC8);</span>
<span class="line-removed">4667   emit_int8((unsigned char)(0xC0 | encode));</span>
4668 }
4669 
4670 void Assembler::sha1msg1(XMMRegister dst, XMMRegister src) {
4671   assert(VM_Version::supports_sha(), &quot;&quot;);
4672   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">4673   emit_int8((unsigned char)0xC9);</span>
<span class="line-removed">4674   emit_int8((unsigned char)(0xC0 | encode));</span>
4675 }
4676 
4677 void Assembler::sha1msg2(XMMRegister dst, XMMRegister src) {
4678   assert(VM_Version::supports_sha(), &quot;&quot;);
4679   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">4680   emit_int8((unsigned char)0xCA);</span>
<span class="line-removed">4681   emit_int8((unsigned char)(0xC0 | encode));</span>
4682 }
4683 
4684 // xmm0 is implicit additional source to this instruction.
4685 void Assembler::sha256rnds2(XMMRegister dst, XMMRegister src) {
4686   assert(VM_Version::supports_sha(), &quot;&quot;);
4687   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">4688   emit_int8((unsigned char)0xCB);</span>
<span class="line-removed">4689   emit_int8((unsigned char)(0xC0 | encode));</span>
4690 }
4691 
4692 void Assembler::sha256msg1(XMMRegister dst, XMMRegister src) {
4693   assert(VM_Version::supports_sha(), &quot;&quot;);
4694   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">4695   emit_int8((unsigned char)0xCC);</span>
<span class="line-removed">4696   emit_int8((unsigned char)(0xC0 | encode));</span>
4697 }
4698 
4699 void Assembler::sha256msg2(XMMRegister dst, XMMRegister src) {
4700   assert(VM_Version::supports_sha(), &quot;&quot;);
4701   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">4702   emit_int8((unsigned char)0xCD);</span>
<span class="line-removed">4703   emit_int8((unsigned char)(0xC0 | encode));</span>
4704 }
4705 
4706 
4707 void Assembler::shll(Register dst, int imm8) {
4708   assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
4709   int encode = prefix_and_encode(dst-&gt;encoding());
4710   if (imm8 == 1 ) {
<span class="line-modified">4711     emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">4712     emit_int8((unsigned char)(0xE0 | encode));</span>
4713   } else {
<span class="line-modified">4714     emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">4715     emit_int8((unsigned char)(0xE0 | encode));</span>
<span class="line-removed">4716     emit_int8(imm8);</span>
4717   }
4718 }
4719 
4720 void Assembler::shll(Register dst) {
4721   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">4722   emit_int8((unsigned char)0xD3);</span>
<span class="line-removed">4723   emit_int8((unsigned char)(0xE0 | encode));</span>
4724 }
4725 
4726 void Assembler::shrl(Register dst, int imm8) {
4727   assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
4728   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">4729   emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">4730   emit_int8((unsigned char)(0xE8 | encode));</span>
<span class="line-removed">4731   emit_int8(imm8);</span>
4732 }
4733 
4734 void Assembler::shrl(Register dst) {
4735   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">4736   emit_int8((unsigned char)0xD3);</span>
<span class="line-removed">4737   emit_int8((unsigned char)(0xE8 | encode));</span>
4738 }
4739 
4740 void Assembler::shldl(Register dst, Register src) {
4741   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="line-modified">4742   emit_int8(0x0F);</span>
<span class="line-removed">4743   emit_int8((unsigned char)0xA5);</span>
<span class="line-removed">4744   emit_int8((unsigned char)(0xC0 | encode));</span>
4745 }
4746 
4747 void Assembler::shldl(Register dst, Register src, int8_t imm8) {
4748   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="line-modified">4749   emit_int8(0x0F);</span>
<span class="line-removed">4750   emit_int8((unsigned char)0xA4);</span>
<span class="line-removed">4751   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">4752   emit_int8(imm8);</span>
4753 }
4754 
4755 void Assembler::shrdl(Register dst, Register src) {
4756   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="line-modified">4757   emit_int8(0x0F);</span>
<span class="line-removed">4758   emit_int8((unsigned char)0xAD);</span>
<span class="line-removed">4759   emit_int8((unsigned char)(0xC0 | encode));</span>
4760 }
4761 
4762 void Assembler::shrdl(Register dst, Register src, int8_t imm8) {
4763   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="line-modified">4764   emit_int8(0x0F);</span>
<span class="line-removed">4765   emit_int8((unsigned char)0xAC);</span>
<span class="line-removed">4766   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">4767   emit_int8(imm8);</span>
4768 }
4769 
4770 // copies a single word from [esi] to [edi]
4771 void Assembler::smovl() {
4772   emit_int8((unsigned char)0xA5);
4773 }
4774 
4775 void Assembler::roundsd(XMMRegister dst, XMMRegister src, int32_t rmode) {
4776   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
4777   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4778   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">4779   emit_int8(0x0B);</span>
<span class="line-removed">4780   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">4781   emit_int8((unsigned char)rmode);</span>
4782 }
4783 
4784 void Assembler::roundsd(XMMRegister dst, Address src, int32_t rmode) {
4785   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
4786   InstructionMark im(this);
4787   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4788   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
4789   emit_int8(0x0B);
4790   emit_operand(dst, src);
4791   emit_int8((unsigned char)rmode);
4792 }
4793 
4794 void Assembler::sqrtsd(XMMRegister dst, XMMRegister src) {
4795   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4796   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4797   attributes.set_rex_vex_w_reverted();
4798   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4799   emit_int8(0x51);</span>
<span class="line-removed">4800   emit_int8((unsigned char)(0xC0 | encode));</span>
4801 }
4802 
4803 void Assembler::sqrtsd(XMMRegister dst, Address src) {
4804   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4805   InstructionMark im(this);
4806   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4807   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4808   attributes.set_rex_vex_w_reverted();
4809   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4810   emit_int8(0x51);
4811   emit_operand(dst, src);
4812 }
4813 
4814 void Assembler::sqrtss(XMMRegister dst, XMMRegister src) {
4815   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4816   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4817   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4818   emit_int8(0x51);</span>
<span class="line-removed">4819   emit_int8((unsigned char)(0xC0 | encode));</span>
4820 }
4821 
4822 void Assembler::std() {
4823   emit_int8((unsigned char)0xFD);
4824 }
4825 
4826 void Assembler::sqrtss(XMMRegister dst, Address src) {
4827   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4828   InstructionMark im(this);
4829   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4830   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
4831   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
4832   emit_int8(0x51);
4833   emit_operand(dst, src);
4834 }
4835 
4836 void Assembler::stmxcsr( Address dst) {
4837   if (UseAVX &gt; 0 ) {
4838     assert(VM_Version::supports_avx(), &quot;&quot;);
4839     InstructionMark im(this);
4840     InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4841     vex_prefix(dst, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
4842     emit_int8((unsigned char)0xAE);
4843     emit_operand(as_Register(3), dst);
4844   } else {
4845     NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4846     InstructionMark im(this);
4847     prefix(dst);
<span class="line-modified">4848     emit_int8(0x0F);</span>
<span class="line-removed">4849     emit_int8((unsigned char)0xAE);</span>
4850     emit_operand(as_Register(3), dst);
4851   }
4852 }
4853 
4854 void Assembler::subl(Address dst, int32_t imm32) {
4855   InstructionMark im(this);
4856   prefix(dst);
4857   emit_arith_operand(0x81, rbp, dst, imm32);
4858 }
4859 
4860 void Assembler::subl(Address dst, Register src) {
4861   InstructionMark im(this);
4862   prefix(dst, src);
4863   emit_int8(0x29);
4864   emit_operand(src, dst);
4865 }
4866 
4867 void Assembler::subl(Register dst, int32_t imm32) {
4868   prefix(dst);
4869   emit_arith(0x81, 0xE8, dst, imm32);
</pre>
<hr />
<pre>
4875   emit_arith_imm32(0x81, 0xE8, dst, imm32);
4876 }
4877 
4878 void Assembler::subl(Register dst, Address src) {
4879   InstructionMark im(this);
4880   prefix(src, dst);
4881   emit_int8(0x2B);
4882   emit_operand(dst, src);
4883 }
4884 
4885 void Assembler::subl(Register dst, Register src) {
4886   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
4887   emit_arith(0x2B, 0xC0, dst, src);
4888 }
4889 
4890 void Assembler::subsd(XMMRegister dst, XMMRegister src) {
4891   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4892   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4893   attributes.set_rex_vex_w_reverted();
4894   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4895   emit_int8(0x5C);</span>
<span class="line-removed">4896   emit_int8((unsigned char)(0xC0 | encode));</span>
4897 }
4898 
4899 void Assembler::subsd(XMMRegister dst, Address src) {
4900   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4901   InstructionMark im(this);
4902   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4903   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4904   attributes.set_rex_vex_w_reverted();
4905   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4906   emit_int8(0x5C);
4907   emit_operand(dst, src);
4908 }
4909 
4910 void Assembler::subss(XMMRegister dst, XMMRegister src) {
4911   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4912   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true , /* uses_vl */ false);
4913   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4914   emit_int8(0x5C);</span>
<span class="line-removed">4915   emit_int8((unsigned char)(0xC0 | encode));</span>
4916 }
4917 
4918 void Assembler::subss(XMMRegister dst, Address src) {
4919   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4920   InstructionMark im(this);
4921   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4922   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
4923   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
4924   emit_int8(0x5C);
4925   emit_operand(dst, src);
4926 }
4927 
4928 void Assembler::testb(Register dst, int imm8) {
4929   NOT_LP64(assert(dst-&gt;has_byte_register(), &quot;must have byte register&quot;));
4930   (void) prefix_and_encode(dst-&gt;encoding(), true);
4931   emit_arith_b(0xF6, 0xC0, dst, imm8);
4932 }
4933 
4934 void Assembler::testb(Address dst, int imm8) {
4935   InstructionMark im(this);
4936   prefix(dst);
4937   emit_int8((unsigned char)0xF6);
4938   emit_operand(rax, dst, 1);
4939   emit_int8(imm8);
4940 }
4941 
4942 void Assembler::testl(Register dst, int32_t imm32) {
4943   // not using emit_arith because test
4944   // doesn&#39;t support sign-extension of
4945   // 8bit operands
4946   int encode = dst-&gt;encoding();
4947   if (encode == 0) {
4948     emit_int8((unsigned char)0xA9);
4949   } else {
4950     encode = prefix_and_encode(encode);
<span class="line-modified">4951     emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">4952     emit_int8((unsigned char)(0xC0 | encode));</span>
4953   }
4954   emit_int32(imm32);
4955 }
4956 
4957 void Assembler::testl(Register dst, Register src) {
4958   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
4959   emit_arith(0x85, 0xC0, dst, src);
4960 }
4961 
4962 void Assembler::testl(Register dst, Address src) {
4963   InstructionMark im(this);
4964   prefix(src, dst);
4965   emit_int8((unsigned char)0x85);
4966   emit_operand(dst, src);
4967 }
4968 
4969 void Assembler::tzcntl(Register dst, Register src) {
4970   assert(VM_Version::supports_bmi1(), &quot;tzcnt instruction not supported&quot;);
4971   emit_int8((unsigned char)0xF3);
4972   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">4973   emit_int8(0x0F);</span>
<span class="line-modified">4974   emit_int8((unsigned char)0xBC);</span>
<span class="line-modified">4975   emit_int8((unsigned char)0xC0 | encode);</span>
4976 }
4977 
4978 void Assembler::tzcntq(Register dst, Register src) {
4979   assert(VM_Version::supports_bmi1(), &quot;tzcnt instruction not supported&quot;);
4980   emit_int8((unsigned char)0xF3);
4981   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">4982   emit_int8(0x0F);</span>
<span class="line-removed">4983   emit_int8((unsigned char)0xBC);</span>
<span class="line-removed">4984   emit_int8((unsigned char)(0xC0 | encode));</span>
4985 }
4986 
4987 void Assembler::ucomisd(XMMRegister dst, Address src) {
4988   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4989   InstructionMark im(this);
4990   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4991   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4992   attributes.set_rex_vex_w_reverted();
4993   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4994   emit_int8(0x2E);
4995   emit_operand(dst, src);
4996 }
4997 
4998 void Assembler::ucomisd(XMMRegister dst, XMMRegister src) {
4999   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5000   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5001   attributes.set_rex_vex_w_reverted();
5002   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5003   emit_int8(0x2E);</span>
<span class="line-removed">5004   emit_int8((unsigned char)(0xC0 | encode));</span>
5005 }
5006 
5007 void Assembler::ucomiss(XMMRegister dst, Address src) {
5008   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5009   InstructionMark im(this);
5010   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5011   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
5012   simd_prefix(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5013   emit_int8(0x2E);
5014   emit_operand(dst, src);
5015 }
5016 
5017 void Assembler::ucomiss(XMMRegister dst, XMMRegister src) {
5018   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5019   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5020   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5021   emit_int8(0x2E);</span>
<span class="line-removed">5022   emit_int8((unsigned char)(0xC0 | encode));</span>
5023 }
5024 
5025 void Assembler::xabort(int8_t imm8) {
<span class="line-modified">5026   emit_int8((unsigned char)0xC6);</span>
<span class="line-removed">5027   emit_int8((unsigned char)0xF8);</span>
<span class="line-removed">5028   emit_int8((unsigned char)(imm8 &amp; 0xFF));</span>
5029 }
5030 
5031 void Assembler::xaddb(Address dst, Register src) {
5032   InstructionMark im(this);
5033   prefix(dst, src, true);
<span class="line-modified">5034   emit_int8(0x0F);</span>
<span class="line-removed">5035   emit_int8((unsigned char)0xC0);</span>
5036   emit_operand(src, dst);
5037 }
5038 
5039 void Assembler::xaddw(Address dst, Register src) {
5040   InstructionMark im(this);
5041   emit_int8(0x66);
5042   prefix(dst, src);
<span class="line-modified">5043   emit_int8(0x0F);</span>
<span class="line-removed">5044   emit_int8((unsigned char)0xC1);</span>
5045   emit_operand(src, dst);
5046 }
5047 
5048 void Assembler::xaddl(Address dst, Register src) {
5049   InstructionMark im(this);
5050   prefix(dst, src);
<span class="line-modified">5051   emit_int8(0x0F);</span>
<span class="line-removed">5052   emit_int8((unsigned char)0xC1);</span>
5053   emit_operand(src, dst);
5054 }
5055 
5056 void Assembler::xbegin(Label&amp; abort, relocInfo::relocType rtype) {
5057   InstructionMark im(this);
5058   relocate(rtype);
5059   if (abort.is_bound()) {
5060     address entry = target(abort);
5061     assert(entry != NULL, &quot;abort entry NULL&quot;);
5062     intptr_t offset = entry - pc();
<span class="line-modified">5063     emit_int8((unsigned char)0xC7);</span>
<span class="line-removed">5064     emit_int8((unsigned char)0xF8);</span>
5065     emit_int32(offset - 6); // 2 opcode + 4 address
5066   } else {
5067     abort.add_patch_at(code(), locator());
<span class="line-modified">5068     emit_int8((unsigned char)0xC7);</span>
<span class="line-removed">5069     emit_int8((unsigned char)0xF8);</span>
5070     emit_int32(0);
5071   }
5072 }
5073 
5074 void Assembler::xchgb(Register dst, Address src) { // xchg
5075   InstructionMark im(this);
5076   prefix(src, dst, true);
5077   emit_int8((unsigned char)0x86);
5078   emit_operand(dst, src);
5079 }
5080 
5081 void Assembler::xchgw(Register dst, Address src) { // xchg
5082   InstructionMark im(this);
5083   emit_int8(0x66);
5084   prefix(src, dst);
5085   emit_int8((unsigned char)0x87);
5086   emit_operand(dst, src);
5087 }
5088 
5089 void Assembler::xchgl(Register dst, Address src) { // xchg
5090   InstructionMark im(this);
5091   prefix(src, dst);
5092   emit_int8((unsigned char)0x87);
5093   emit_operand(dst, src);
5094 }
5095 
5096 void Assembler::xchgl(Register dst, Register src) {
5097   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">5098   emit_int8((unsigned char)0x87);</span>
<span class="line-removed">5099   emit_int8((unsigned char)(0xC0 | encode));</span>
5100 }
5101 
5102 void Assembler::xend() {
<span class="line-modified">5103   emit_int8((unsigned char)0x0F);</span>
<span class="line-removed">5104   emit_int8((unsigned char)0x01);</span>
<span class="line-removed">5105   emit_int8((unsigned char)0xD5);</span>
5106 }
5107 
5108 void Assembler::xgetbv() {
<span class="line-modified">5109   emit_int8(0x0F);</span>
<span class="line-removed">5110   emit_int8(0x01);</span>
<span class="line-removed">5111   emit_int8((unsigned char)0xD0);</span>
5112 }
5113 
5114 void Assembler::xorl(Register dst, int32_t imm32) {
5115   prefix(dst);
5116   emit_arith(0x81, 0xF0, dst, imm32);
5117 }
5118 
5119 void Assembler::xorl(Register dst, Address src) {
5120   InstructionMark im(this);
5121   prefix(src, dst);
5122   emit_int8(0x33);
5123   emit_operand(dst, src);
5124 }
5125 
5126 void Assembler::xorl(Register dst, Register src) {
5127   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
5128   emit_arith(0x33, 0xC0, dst, src);
5129 }
5130 
5131 void Assembler::xorb(Register dst, Address src) {
</pre>
<hr />
<pre>
5136 }
5137 
5138 // AVX 3-operands scalar float-point arithmetic instructions
5139 
5140 void Assembler::vaddsd(XMMRegister dst, XMMRegister nds, Address src) {
5141   assert(VM_Version::supports_avx(), &quot;&quot;);
5142   InstructionMark im(this);
5143   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5144   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
5145   attributes.set_rex_vex_w_reverted();
5146   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
5147   emit_int8(0x58);
5148   emit_operand(dst, src);
5149 }
5150 
5151 void Assembler::vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
5152   assert(VM_Version::supports_avx(), &quot;&quot;);
5153   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5154   attributes.set_rex_vex_w_reverted();
5155   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5156   emit_int8(0x58);</span>
<span class="line-removed">5157   emit_int8((unsigned char)(0xC0 | encode));</span>
5158 }
5159 
5160 void Assembler::vaddss(XMMRegister dst, XMMRegister nds, Address src) {
5161   assert(VM_Version::supports_avx(), &quot;&quot;);
5162   InstructionMark im(this);
5163   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5164   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
5165   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
5166   emit_int8(0x58);
5167   emit_operand(dst, src);
5168 }
5169 
5170 void Assembler::vaddss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
5171   assert(VM_Version::supports_avx(), &quot;&quot;);
5172   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5173   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5174   emit_int8(0x58);</span>
<span class="line-removed">5175   emit_int8((unsigned char)(0xC0 | encode));</span>
5176 }
5177 
5178 void Assembler::vdivsd(XMMRegister dst, XMMRegister nds, Address src) {
5179   assert(VM_Version::supports_avx(), &quot;&quot;);
5180   InstructionMark im(this);
5181   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5182   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
5183   attributes.set_rex_vex_w_reverted();
5184   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
5185   emit_int8(0x5E);
5186   emit_operand(dst, src);
5187 }
5188 
5189 void Assembler::vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
5190   assert(VM_Version::supports_avx(), &quot;&quot;);
5191   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5192   attributes.set_rex_vex_w_reverted();
5193   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5194   emit_int8(0x5E);</span>
<span class="line-removed">5195   emit_int8((unsigned char)(0xC0 | encode));</span>
5196 }
5197 
5198 void Assembler::vdivss(XMMRegister dst, XMMRegister nds, Address src) {
5199   assert(VM_Version::supports_avx(), &quot;&quot;);
5200   InstructionMark im(this);
5201   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5202   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
5203   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
5204   emit_int8(0x5E);
5205   emit_operand(dst, src);
5206 }
5207 
5208 void Assembler::vdivss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
5209   assert(VM_Version::supports_avx(), &quot;&quot;);
5210   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5211   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5212   emit_int8(0x5E);</span>
<span class="line-removed">5213   emit_int8((unsigned char)(0xC0 | encode));</span>
5214 }
5215 
5216 void Assembler::vfmadd231sd(XMMRegister dst, XMMRegister src1, XMMRegister src2) {
5217   assert(VM_Version::supports_fma(), &quot;&quot;);
5218   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5219   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">5220   emit_int8((unsigned char)0xB9);</span>
<span class="line-removed">5221   emit_int8((unsigned char)(0xC0 | encode));</span>
5222 }
5223 
5224 void Assembler::vfmadd231ss(XMMRegister dst, XMMRegister src1, XMMRegister src2) {
5225   assert(VM_Version::supports_fma(), &quot;&quot;);
5226   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5227   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">5228   emit_int8((unsigned char)0xB9);</span>
<span class="line-removed">5229   emit_int8((unsigned char)(0xC0 | encode));</span>
5230 }
5231 
5232 void Assembler::vmulsd(XMMRegister dst, XMMRegister nds, Address src) {
5233   assert(VM_Version::supports_avx(), &quot;&quot;);
5234   InstructionMark im(this);
5235   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5236   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
5237   attributes.set_rex_vex_w_reverted();
5238   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
5239   emit_int8(0x59);
5240   emit_operand(dst, src);
5241 }
5242 
5243 void Assembler::vmulsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
5244   assert(VM_Version::supports_avx(), &quot;&quot;);
5245   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5246   attributes.set_rex_vex_w_reverted();
5247   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5248   emit_int8(0x59);</span>
<span class="line-removed">5249   emit_int8((unsigned char)(0xC0 | encode));</span>
5250 }
5251 
5252 void Assembler::vmulss(XMMRegister dst, XMMRegister nds, Address src) {
5253   assert(VM_Version::supports_avx(), &quot;&quot;);
5254   InstructionMark im(this);
5255   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5256   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
5257   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
5258   emit_int8(0x59);
5259   emit_operand(dst, src);
5260 }
5261 
5262 void Assembler::vmulss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
5263   assert(VM_Version::supports_avx(), &quot;&quot;);
5264   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5265   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5266   emit_int8(0x59);</span>
<span class="line-removed">5267   emit_int8((unsigned char)(0xC0 | encode));</span>
5268 }
5269 
5270 void Assembler::vsubsd(XMMRegister dst, XMMRegister nds, Address src) {
5271   assert(VM_Version::supports_avx(), &quot;&quot;);
5272   InstructionMark im(this);
5273   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5274   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
5275   attributes.set_rex_vex_w_reverted();
5276   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
5277   emit_int8(0x5C);
5278   emit_operand(dst, src);
5279 }
5280 
5281 void Assembler::vsubsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
5282   assert(VM_Version::supports_avx(), &quot;&quot;);
5283   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5284   attributes.set_rex_vex_w_reverted();
5285   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5286   emit_int8(0x5C);</span>
<span class="line-removed">5287   emit_int8((unsigned char)(0xC0 | encode));</span>
5288 }
5289 
5290 void Assembler::vsubss(XMMRegister dst, XMMRegister nds, Address src) {
5291   assert(VM_Version::supports_avx(), &quot;&quot;);
5292   InstructionMark im(this);
5293   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5294   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
5295   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
5296   emit_int8(0x5C);
5297   emit_operand(dst, src);
5298 }
5299 
5300 void Assembler::vsubss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
5301   assert(VM_Version::supports_avx(), &quot;&quot;);
5302   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
5303   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5304   emit_int8(0x5C);</span>
<span class="line-removed">5305   emit_int8((unsigned char)(0xC0 | encode));</span>
5306 }
5307 
5308 //====================VECTOR ARITHMETIC=====================================
5309 
5310 // Float-point vector arithmetic
5311 
5312 void Assembler::addpd(XMMRegister dst, XMMRegister src) {
5313   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5314   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5315   attributes.set_rex_vex_w_reverted();
5316   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5317   emit_int8(0x58);</span>
<span class="line-removed">5318   emit_int8((unsigned char)(0xC0 | encode));</span>
5319 }
5320 
5321 void Assembler::addpd(XMMRegister dst, Address src) {
5322   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5323   InstructionMark im(this);
5324   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5325   attributes.set_rex_vex_w_reverted();
5326   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5327   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5328   emit_int8(0x58);
5329   emit_operand(dst, src);
5330 }
5331 
5332 
5333 void Assembler::addps(XMMRegister dst, XMMRegister src) {
5334   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5335   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5336   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5337   emit_int8(0x58);</span>
<span class="line-removed">5338   emit_int8((unsigned char)(0xC0 | encode));</span>
5339 }
5340 
5341 void Assembler::vaddpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5342   assert(VM_Version::supports_avx(), &quot;&quot;);
5343   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5344   attributes.set_rex_vex_w_reverted();
5345   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5346   emit_int8(0x58);</span>
<span class="line-removed">5347   emit_int8((unsigned char)(0xC0 | encode));</span>
5348 }
5349 
5350 void Assembler::vaddps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5351   assert(VM_Version::supports_avx(), &quot;&quot;);
5352   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5353   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5354   emit_int8(0x58);</span>
<span class="line-removed">5355   emit_int8((unsigned char)(0xC0 | encode));</span>
5356 }
5357 
5358 void Assembler::vaddpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5359   assert(VM_Version::supports_avx(), &quot;&quot;);
5360   InstructionMark im(this);
5361   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5362   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5363   attributes.set_rex_vex_w_reverted();
5364   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5365   emit_int8(0x58);
5366   emit_operand(dst, src);
5367 }
5368 
5369 void Assembler::vaddps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5370   assert(VM_Version::supports_avx(), &quot;&quot;);
5371   InstructionMark im(this);
5372   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5373   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5374   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5375   emit_int8(0x58);
5376   emit_operand(dst, src);
5377 }
5378 
5379 void Assembler::subpd(XMMRegister dst, XMMRegister src) {
5380   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5381   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5382   attributes.set_rex_vex_w_reverted();
5383   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5384   emit_int8(0x5C);</span>
<span class="line-removed">5385   emit_int8((unsigned char)(0xC0 | encode));</span>
5386 }
5387 
5388 void Assembler::subps(XMMRegister dst, XMMRegister src) {
5389   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5390   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5391   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5392   emit_int8(0x5C);</span>
<span class="line-removed">5393   emit_int8((unsigned char)(0xC0 | encode));</span>
5394 }
5395 
5396 void Assembler::vsubpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5397   assert(VM_Version::supports_avx(), &quot;&quot;);
5398   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5399   attributes.set_rex_vex_w_reverted();
5400   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5401   emit_int8(0x5C);</span>
<span class="line-removed">5402   emit_int8((unsigned char)(0xC0 | encode));</span>
5403 }
5404 
5405 void Assembler::vsubps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5406   assert(VM_Version::supports_avx(), &quot;&quot;);
5407   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5408   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5409   emit_int8(0x5C);</span>
<span class="line-removed">5410   emit_int8((unsigned char)(0xC0 | encode));</span>
5411 }
5412 
5413 void Assembler::vsubpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5414   assert(VM_Version::supports_avx(), &quot;&quot;);
5415   InstructionMark im(this);
5416   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5417   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5418   attributes.set_rex_vex_w_reverted();
5419   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5420   emit_int8(0x5C);
5421   emit_operand(dst, src);
5422 }
5423 
5424 void Assembler::vsubps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5425   assert(VM_Version::supports_avx(), &quot;&quot;);
5426   InstructionMark im(this);
5427   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5428   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5429   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5430   emit_int8(0x5C);
5431   emit_operand(dst, src);
5432 }
5433 
5434 void Assembler::mulpd(XMMRegister dst, XMMRegister src) {
5435   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5436   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5437   attributes.set_rex_vex_w_reverted();
5438   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5439   emit_int8(0x59);</span>
<span class="line-removed">5440   emit_int8((unsigned char)(0xC0 | encode));</span>
5441 }
5442 
5443 void Assembler::mulpd(XMMRegister dst, Address src) {
5444   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5445   InstructionMark im(this);
5446   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5447   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5448   attributes.set_rex_vex_w_reverted();
5449   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5450   emit_int8(0x59);
5451   emit_operand(dst, src);
5452 }
5453 
5454 void Assembler::mulps(XMMRegister dst, XMMRegister src) {
5455   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5456   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5457   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5458   emit_int8(0x59);</span>
<span class="line-removed">5459   emit_int8((unsigned char)(0xC0 | encode));</span>
5460 }
5461 
5462 void Assembler::vmulpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5463   assert(VM_Version::supports_avx(), &quot;&quot;);
5464   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5465   attributes.set_rex_vex_w_reverted();
5466   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5467   emit_int8(0x59);</span>
<span class="line-removed">5468   emit_int8((unsigned char)(0xC0 | encode));</span>
5469 }
5470 
5471 void Assembler::vmulps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5472   assert(VM_Version::supports_avx(), &quot;&quot;);
5473   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5474   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5475   emit_int8(0x59);</span>
<span class="line-removed">5476   emit_int8((unsigned char)(0xC0 | encode));</span>
5477 }
5478 
5479 void Assembler::vmulpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5480   assert(VM_Version::supports_avx(), &quot;&quot;);
5481   InstructionMark im(this);
5482   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5483   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5484   attributes.set_rex_vex_w_reverted();
5485   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5486   emit_int8(0x59);
5487   emit_operand(dst, src);
5488 }
5489 
5490 void Assembler::vmulps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5491   assert(VM_Version::supports_avx(), &quot;&quot;);
5492   InstructionMark im(this);
5493   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5494   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5495   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5496   emit_int8(0x59);
5497   emit_operand(dst, src);
5498 }
5499 
5500 void Assembler::vfmadd231pd(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {
5501   assert(VM_Version::supports_fma(), &quot;&quot;);
5502   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5503   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">5504   emit_int8((unsigned char)0xB8);</span>
<span class="line-removed">5505   emit_int8((unsigned char)(0xC0 | encode));</span>
5506 }
5507 
5508 void Assembler::vfmadd231ps(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {
5509   assert(VM_Version::supports_fma(), &quot;&quot;);
5510   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5511   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">5512   emit_int8((unsigned char)0xB8);</span>
<span class="line-removed">5513   emit_int8((unsigned char)(0xC0 | encode));</span>
5514 }
5515 
5516 void Assembler::vfmadd231pd(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {
5517   assert(VM_Version::supports_fma(), &quot;&quot;);
5518   InstructionMark im(this);
5519   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5520   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5521   vex_prefix(src2, src1-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5522   emit_int8((unsigned char)0xB8);
5523   emit_operand(dst, src2);
5524 }
5525 
5526 void Assembler::vfmadd231ps(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {
5527   assert(VM_Version::supports_fma(), &quot;&quot;);
5528   InstructionMark im(this);
5529   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5530   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5531   vex_prefix(src2, src1-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5532   emit_int8((unsigned char)0xB8);
5533   emit_operand(dst, src2);
5534 }
5535 
5536 void Assembler::divpd(XMMRegister dst, XMMRegister src) {
5537   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5538   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5539   attributes.set_rex_vex_w_reverted();
5540   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5541   emit_int8(0x5E);</span>
<span class="line-removed">5542   emit_int8((unsigned char)(0xC0 | encode));</span>
5543 }
5544 
5545 void Assembler::divps(XMMRegister dst, XMMRegister src) {
5546   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5547   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5548   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5549   emit_int8(0x5E);</span>
<span class="line-removed">5550   emit_int8((unsigned char)(0xC0 | encode));</span>
5551 }
5552 
5553 void Assembler::vdivpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5554   assert(VM_Version::supports_avx(), &quot;&quot;);
5555   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5556   attributes.set_rex_vex_w_reverted();
5557   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5558   emit_int8(0x5E);</span>
<span class="line-removed">5559   emit_int8((unsigned char)(0xC0 | encode));</span>
5560 }
5561 
5562 void Assembler::vdivps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5563   assert(VM_Version::supports_avx(), &quot;&quot;);
5564   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5565   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5566   emit_int8(0x5E);</span>
<span class="line-removed">5567   emit_int8((unsigned char)(0xC0 | encode));</span>
5568 }
5569 
5570 void Assembler::vdivpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5571   assert(VM_Version::supports_avx(), &quot;&quot;);
5572   InstructionMark im(this);
5573   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5574   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5575   attributes.set_rex_vex_w_reverted();
5576   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5577   emit_int8(0x5E);
5578   emit_operand(dst, src);
5579 }
5580 
5581 void Assembler::vdivps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5582   assert(VM_Version::supports_avx(), &quot;&quot;);
5583   InstructionMark im(this);
5584   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5585   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5586   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5587   emit_int8(0x5E);
5588   emit_operand(dst, src);
5589 }
5590 
5591 void Assembler::vroundpd(XMMRegister dst, XMMRegister src, int32_t rmode, int vector_len) {
5592   assert(VM_Version::supports_avx(), &quot;&quot;);
5593   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
5594   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">5595   emit_int8(0x09);</span>
<span class="line-removed">5596   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">5597   emit_int8((unsigned char)(rmode));</span>
5598 }
5599 
5600 void Assembler::vroundpd(XMMRegister dst, Address src, int32_t rmode,  int vector_len) {
5601   assert(VM_Version::supports_avx(), &quot;&quot;);
5602   InstructionMark im(this);
5603   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
5604   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
5605   emit_int8(0x09);
5606   emit_operand(dst, src);
<span class="line-modified">5607   emit_int8((unsigned char)(rmode));</span>
5608 }
5609 
5610 void Assembler::vrndscalepd(XMMRegister dst,  XMMRegister src,  int32_t rmode, int vector_len) {
5611   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
5612   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5613   attributes.set_is_evex_instruction();
5614   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">5615   emit_int8((unsigned char)0x09);</span>
<span class="line-removed">5616   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">5617   emit_int8((unsigned char)(rmode));</span>
5618 }
5619 
5620 void Assembler::vrndscalepd(XMMRegister dst, Address src, int32_t rmode, int vector_len) {
5621   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
5622   assert(dst != xnoreg, &quot;sanity&quot;);
5623   InstructionMark im(this);
5624   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5625   attributes.set_is_evex_instruction();
5626   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5627   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">5628   emit_int8((unsigned char)0x09);</span>
5629   emit_operand(dst, src);
<span class="line-modified">5630   emit_int8((unsigned char)(rmode));</span>
5631 }
5632 
5633 
5634 void Assembler::vsqrtpd(XMMRegister dst, XMMRegister src, int vector_len) {
5635   assert(VM_Version::supports_avx(), &quot;&quot;);
5636   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5637   attributes.set_rex_vex_w_reverted();
5638   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5639   emit_int8(0x51);</span>
<span class="line-removed">5640   emit_int8((unsigned char)(0xC0 | encode));</span>
5641 }
5642 
5643 void Assembler::vsqrtpd(XMMRegister dst, Address src, int vector_len) {
5644   assert(VM_Version::supports_avx(), &quot;&quot;);
5645   InstructionMark im(this);
5646   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5647   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5648   attributes.set_rex_vex_w_reverted();
5649   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5650   emit_int8(0x51);
5651   emit_operand(dst, src);
5652 }
5653 
5654 void Assembler::vsqrtps(XMMRegister dst, XMMRegister src, int vector_len) {
5655   assert(VM_Version::supports_avx(), &quot;&quot;);
5656   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5657   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5658   emit_int8(0x51);</span>
<span class="line-removed">5659   emit_int8((unsigned char)(0xC0 | encode));</span>
5660 }
5661 
5662 void Assembler::vsqrtps(XMMRegister dst, Address src, int vector_len) {
5663   assert(VM_Version::supports_avx(), &quot;&quot;);
5664   InstructionMark im(this);
5665   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5666   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5667   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5668   emit_int8(0x51);
5669   emit_operand(dst, src);
5670 }
5671 
5672 void Assembler::andpd(XMMRegister dst, XMMRegister src) {
5673   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5674   InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5675   attributes.set_rex_vex_w_reverted();
5676   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5677   emit_int8(0x54);</span>
<span class="line-removed">5678   emit_int8((unsigned char)(0xC0 | encode));</span>
5679 }
5680 
5681 void Assembler::andps(XMMRegister dst, XMMRegister src) {
5682   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5683   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5684   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5685   emit_int8(0x54);</span>
<span class="line-removed">5686   emit_int8((unsigned char)(0xC0 | encode));</span>
5687 }
5688 
5689 void Assembler::andps(XMMRegister dst, Address src) {
5690   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5691   InstructionMark im(this);
5692   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5693   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5694   simd_prefix(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5695   emit_int8(0x54);
5696   emit_operand(dst, src);
5697 }
5698 
5699 void Assembler::andpd(XMMRegister dst, Address src) {
5700   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5701   InstructionMark im(this);
5702   InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5703   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5704   attributes.set_rex_vex_w_reverted();
5705   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5706   emit_int8(0x54);
5707   emit_operand(dst, src);
5708 }
5709 
5710 void Assembler::vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5711   assert(VM_Version::supports_avx(), &quot;&quot;);
5712   InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5713   attributes.set_rex_vex_w_reverted();
5714   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5715   emit_int8(0x54);</span>
<span class="line-removed">5716   emit_int8((unsigned char)(0xC0 | encode));</span>
5717 }
5718 
5719 void Assembler::vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5720   assert(VM_Version::supports_avx(), &quot;&quot;);
5721   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5722   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5723   emit_int8(0x54);</span>
<span class="line-removed">5724   emit_int8((unsigned char)(0xC0 | encode));</span>
5725 }
5726 
5727 void Assembler::vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5728   assert(VM_Version::supports_avx(), &quot;&quot;);
5729   InstructionMark im(this);
5730   InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5731   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5732   attributes.set_rex_vex_w_reverted();
5733   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5734   emit_int8(0x54);
5735   emit_operand(dst, src);
5736 }
5737 
5738 void Assembler::vandps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5739   assert(VM_Version::supports_avx(), &quot;&quot;);
5740   InstructionMark im(this);
5741   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5742   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5743   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5744   emit_int8(0x54);
5745   emit_operand(dst, src);
5746 }
5747 
5748 void Assembler::unpckhpd(XMMRegister dst, XMMRegister src) {
5749   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5750   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5751   attributes.set_rex_vex_w_reverted();
5752   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5753   emit_int8(0x15);
<span class="line-modified">5754   emit_int8((unsigned char)(0xC0 | encode));</span>
5755 }
5756 
5757 void Assembler::unpcklpd(XMMRegister dst, XMMRegister src) {
5758   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5759   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5760   attributes.set_rex_vex_w_reverted();
5761   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5762   emit_int8(0x14);</span>
<span class="line-removed">5763   emit_int8((unsigned char)(0xC0 | encode));</span>
5764 }
5765 
5766 void Assembler::xorpd(XMMRegister dst, XMMRegister src) {
5767   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5768   InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5769   attributes.set_rex_vex_w_reverted();
5770   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5771   emit_int8(0x57);</span>
<span class="line-removed">5772   emit_int8((unsigned char)(0xC0 | encode));</span>
5773 }
5774 
5775 void Assembler::xorps(XMMRegister dst, XMMRegister src) {
5776   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5777   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5778   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5779   emit_int8(0x57);</span>
<span class="line-removed">5780   emit_int8((unsigned char)(0xC0 | encode));</span>
5781 }
5782 
5783 void Assembler::xorpd(XMMRegister dst, Address src) {
5784   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5785   InstructionMark im(this);
5786   InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5787   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5788   attributes.set_rex_vex_w_reverted();
5789   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5790   emit_int8(0x57);
5791   emit_operand(dst, src);
5792 }
5793 
5794 void Assembler::xorps(XMMRegister dst, Address src) {
5795   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5796   InstructionMark im(this);
5797   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5798   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5799   simd_prefix(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5800   emit_int8(0x57);
5801   emit_operand(dst, src);
5802 }
5803 
5804 void Assembler::vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5805   assert(VM_Version::supports_avx(), &quot;&quot;);
5806   InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5807   attributes.set_rex_vex_w_reverted();
5808   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5809   emit_int8(0x57);</span>
<span class="line-removed">5810   emit_int8((unsigned char)(0xC0 | encode));</span>
5811 }
5812 
5813 void Assembler::vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5814   assert(VM_Version::supports_avx(), &quot;&quot;);
5815   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5816   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5817   emit_int8(0x57);</span>
<span class="line-removed">5818   emit_int8((unsigned char)(0xC0 | encode));</span>
5819 }
5820 
5821 void Assembler::vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5822   assert(VM_Version::supports_avx(), &quot;&quot;);
5823   InstructionMark im(this);
5824   InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5825   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5826   attributes.set_rex_vex_w_reverted();
5827   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5828   emit_int8(0x57);
5829   emit_operand(dst, src);
5830 }
5831 
5832 void Assembler::vxorps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5833   assert(VM_Version::supports_avx(), &quot;&quot;);
5834   InstructionMark im(this);
5835   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5836   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5837   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5838   emit_int8(0x57);
5839   emit_operand(dst, src);
5840 }
5841 
5842 // Integer vector arithmetic
5843 void Assembler::vphaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5844   assert(VM_Version::supports_avx() &amp;&amp; (vector_len == 0) ||
5845          VM_Version::supports_avx2(), &quot;256 bit integer vectors requires AVX2&quot;);
5846   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
5847   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">5848   emit_int8(0x01);</span>
<span class="line-removed">5849   emit_int8((unsigned char)(0xC0 | encode));</span>
5850 }
5851 
5852 void Assembler::vphaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5853   assert(VM_Version::supports_avx() &amp;&amp; (vector_len == 0) ||
5854          VM_Version::supports_avx2(), &quot;256 bit integer vectors requires AVX2&quot;);
5855   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
5856   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">5857   emit_int8(0x02);</span>
<span class="line-removed">5858   emit_int8((unsigned char)(0xC0 | encode));</span>
5859 }
5860 
5861 void Assembler::paddb(XMMRegister dst, XMMRegister src) {
5862   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5863   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5864   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5865   emit_int8((unsigned char)0xFC);</span>
<span class="line-removed">5866   emit_int8((unsigned char)(0xC0 | encode));</span>
5867 }
5868 
5869 void Assembler::paddw(XMMRegister dst, XMMRegister src) {
5870   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5871   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5872   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5873   emit_int8((unsigned char)0xFD);</span>
<span class="line-removed">5874   emit_int8((unsigned char)(0xC0 | encode));</span>
5875 }
5876 
5877 void Assembler::paddd(XMMRegister dst, XMMRegister src) {
5878   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5879   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5880   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5881   emit_int8((unsigned char)0xFE);</span>
<span class="line-removed">5882   emit_int8((unsigned char)(0xC0 | encode));</span>
5883 }
5884 
5885 void Assembler::paddd(XMMRegister dst, Address src) {
5886   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5887   InstructionMark im(this);
5888   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5889   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5890   emit_int8((unsigned char)0xFE);
5891   emit_operand(dst, src);
5892 }
5893 
5894 void Assembler::paddq(XMMRegister dst, XMMRegister src) {
5895   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5896   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5897   attributes.set_rex_vex_w_reverted();
5898   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5899   emit_int8((unsigned char)0xD4);</span>
<span class="line-removed">5900   emit_int8((unsigned char)(0xC0 | encode));</span>
5901 }
5902 
5903 void Assembler::phaddw(XMMRegister dst, XMMRegister src) {
5904   assert(VM_Version::supports_sse3(), &quot;&quot;);
5905   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
5906   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">5907   emit_int8(0x01);</span>
<span class="line-removed">5908   emit_int8((unsigned char)(0xC0 | encode));</span>
5909 }
5910 
5911 void Assembler::phaddd(XMMRegister dst, XMMRegister src) {
5912   assert(VM_Version::supports_sse3(), &quot;&quot;);
5913   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
5914   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">5915   emit_int8(0x02);</span>
<span class="line-removed">5916   emit_int8((unsigned char)(0xC0 | encode));</span>
5917 }
5918 
5919 void Assembler::vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5920   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5921   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5922   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5923   emit_int8((unsigned char)0xFC);</span>
<span class="line-removed">5924   emit_int8((unsigned char)(0xC0 | encode));</span>
5925 }
5926 
5927 void Assembler::vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5928   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5929   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5930   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5931   emit_int8((unsigned char)0xFD);</span>
<span class="line-removed">5932   emit_int8((unsigned char)(0xC0 | encode));</span>
5933 }
5934 
5935 void Assembler::vpaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5936   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5937   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5938   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5939   emit_int8((unsigned char)0xFE);</span>
<span class="line-removed">5940   emit_int8((unsigned char)(0xC0 | encode));</span>
5941 }
5942 
5943 void Assembler::vpaddq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5944   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5945   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5946   attributes.set_rex_vex_w_reverted();
5947   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5948   emit_int8((unsigned char)0xD4);</span>
<span class="line-removed">5949   emit_int8((unsigned char)(0xC0 | encode));</span>
5950 }
5951 
5952 void Assembler::vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5953   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5954   InstructionMark im(this);
5955   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5956   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
5957   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5958   emit_int8((unsigned char)0xFC);
5959   emit_operand(dst, src);
5960 }
5961 
5962 void Assembler::vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5963   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5964   InstructionMark im(this);
5965   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5966   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
5967   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5968   emit_int8((unsigned char)0xFD);
5969   emit_operand(dst, src);
</pre>
<hr />
<pre>
5977   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5978   emit_int8((unsigned char)0xFE);
5979   emit_operand(dst, src);
5980 }
5981 
5982 void Assembler::vpaddq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5983   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5984   InstructionMark im(this);
5985   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5986   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5987   attributes.set_rex_vex_w_reverted();
5988   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5989   emit_int8((unsigned char)0xD4);
5990   emit_operand(dst, src);
5991 }
5992 
5993 void Assembler::psubb(XMMRegister dst, XMMRegister src) {
5994   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5995   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5996   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5997   emit_int8((unsigned char)0xF8);</span>
<span class="line-removed">5998   emit_int8((unsigned char)(0xC0 | encode));</span>
5999 }
6000 
6001 void Assembler::psubw(XMMRegister dst, XMMRegister src) {
6002   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6003   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6004   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6005   emit_int8((unsigned char)0xF9);</span>
<span class="line-removed">6006   emit_int8((unsigned char)(0xC0 | encode));</span>
6007 }
6008 
6009 void Assembler::psubd(XMMRegister dst, XMMRegister src) {
6010   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6011   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6012   emit_int8((unsigned char)0xFA);</span>
<span class="line-removed">6013   emit_int8((unsigned char)(0xC0 | encode));</span>
6014 }
6015 
6016 void Assembler::psubq(XMMRegister dst, XMMRegister src) {
6017   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6018   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6019   attributes.set_rex_vex_w_reverted();
6020   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6021   emit_int8((unsigned char)0xFB);
<span class="line-modified">6022   emit_int8((unsigned char)(0xC0 | encode));</span>
6023 }
6024 
6025 void Assembler::vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6026   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6027   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6028   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6029   emit_int8((unsigned char)0xF8);</span>
<span class="line-removed">6030   emit_int8((unsigned char)(0xC0 | encode));</span>
6031 }
6032 
6033 void Assembler::vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6034   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6035   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6036   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6037   emit_int8((unsigned char)0xF9);</span>
<span class="line-removed">6038   emit_int8((unsigned char)(0xC0 | encode));</span>
6039 }
6040 
6041 void Assembler::vpsubd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6042   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6043   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6044   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6045   emit_int8((unsigned char)0xFA);</span>
<span class="line-removed">6046   emit_int8((unsigned char)(0xC0 | encode));</span>
6047 }
6048 
6049 void Assembler::vpsubq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6050   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6051   InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6052   attributes.set_rex_vex_w_reverted();
6053   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6054   emit_int8((unsigned char)0xFB);</span>
<span class="line-removed">6055   emit_int8((unsigned char)(0xC0 | encode));</span>
6056 }
6057 
6058 void Assembler::vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6059   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6060   InstructionMark im(this);
6061   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6062   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
6063   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6064   emit_int8((unsigned char)0xF8);
6065   emit_operand(dst, src);
6066 }
6067 
6068 void Assembler::vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6069   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6070   InstructionMark im(this);
6071   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6072   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
6073   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6074   emit_int8((unsigned char)0xF9);
6075   emit_operand(dst, src);
</pre>
<hr />
<pre>
6083   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6084   emit_int8((unsigned char)0xFA);
6085   emit_operand(dst, src);
6086 }
6087 
6088 void Assembler::vpsubq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6089   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6090   InstructionMark im(this);
6091   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6092   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
6093   attributes.set_rex_vex_w_reverted();
6094   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6095   emit_int8((unsigned char)0xFB);
6096   emit_operand(dst, src);
6097 }
6098 
6099 void Assembler::pmullw(XMMRegister dst, XMMRegister src) {
6100   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6101   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6102   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6103   emit_int8((unsigned char)0xD5);</span>
<span class="line-removed">6104   emit_int8((unsigned char)(0xC0 | encode));</span>
6105 }
6106 
6107 void Assembler::pmulld(XMMRegister dst, XMMRegister src) {
6108   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
6109   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6110   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">6111   emit_int8(0x40);</span>
<span class="line-removed">6112   emit_int8((unsigned char)(0xC0 | encode));</span>
6113 }
6114 
6115 void Assembler::vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6116   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6117   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6118   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6119   emit_int8((unsigned char)0xD5);</span>
<span class="line-removed">6120   emit_int8((unsigned char)(0xC0 | encode));</span>
6121 }
6122 
6123 void Assembler::vpmulld(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6124   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6125   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6126   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">6127   emit_int8(0x40);</span>
<span class="line-removed">6128   emit_int8((unsigned char)(0xC0 | encode));</span>
6129 }
6130 
6131 void Assembler::vpmullq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6132   assert(UseAVX &gt; 2, &quot;requires some form of EVEX&quot;);
6133   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
6134   attributes.set_is_evex_instruction();
6135   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">6136   emit_int8(0x40);</span>
<span class="line-removed">6137   emit_int8((unsigned char)(0xC0 | encode));</span>
6138 }
6139 
6140 void Assembler::vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6141   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6142   InstructionMark im(this);
6143   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6144   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
6145   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6146   emit_int8((unsigned char)0xD5);
6147   emit_operand(dst, src);
6148 }
6149 
6150 void Assembler::vpmulld(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6151   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6152   InstructionMark im(this);
6153   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6154   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
6155   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6156   emit_int8(0x40);
6157   emit_operand(dst, src);
6158 }
6159 
6160 void Assembler::vpmullq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6161   assert(UseAVX &gt; 2, &quot;requires some form of EVEX&quot;);
6162   InstructionMark im(this);
6163   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
6164   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
6165   attributes.set_is_evex_instruction();
6166   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6167   emit_int8(0x40);
6168   emit_operand(dst, src);
6169 }
6170 
6171 // Shift packed integers left by specified number of bits.
6172 void Assembler::psllw(XMMRegister dst, int shift) {
6173   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6174   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6175   // XMM6 is for /6 encoding: 66 0F 71 /6 ib
6176   int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6177   emit_int8(0x71);</span>
<span class="line-removed">6178   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">6179   emit_int8(shift &amp; 0xFF);</span>
6180 }
6181 
6182 void Assembler::pslld(XMMRegister dst, int shift) {
6183   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6184   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6185   // XMM6 is for /6 encoding: 66 0F 72 /6 ib
6186   int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6187   emit_int8(0x72);</span>
<span class="line-removed">6188   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">6189   emit_int8(shift &amp; 0xFF);</span>
6190 }
6191 
6192 void Assembler::psllq(XMMRegister dst, int shift) {
6193   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6194   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6195   // XMM6 is for /6 encoding: 66 0F 73 /6 ib
6196   int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6197   emit_int8(0x73);</span>
<span class="line-removed">6198   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">6199   emit_int8(shift &amp; 0xFF);</span>
6200 }
6201 
6202 void Assembler::psllw(XMMRegister dst, XMMRegister shift) {
6203   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6204   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6205   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6206   emit_int8((unsigned char)0xF1);</span>
<span class="line-removed">6207   emit_int8((unsigned char)(0xC0 | encode));</span>
6208 }
6209 
6210 void Assembler::pslld(XMMRegister dst, XMMRegister shift) {
6211   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6212   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6213   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6214   emit_int8((unsigned char)0xF2);</span>
<span class="line-removed">6215   emit_int8((unsigned char)(0xC0 | encode));</span>
6216 }
6217 
6218 void Assembler::psllq(XMMRegister dst, XMMRegister shift) {
6219   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6220   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6221   attributes.set_rex_vex_w_reverted();
6222   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6223   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">6224   emit_int8((unsigned char)(0xC0 | encode));</span>
6225 }
6226 
6227 void Assembler::vpsllw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6228   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6229   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6230   // XMM6 is for /6 encoding: 66 0F 71 /6 ib
6231   int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6232   emit_int8(0x71);</span>
<span class="line-removed">6233   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">6234   emit_int8(shift &amp; 0xFF);</span>
6235 }
6236 
6237 void Assembler::vpslld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6238   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6239   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6240   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6241   // XMM6 is for /6 encoding: 66 0F 72 /6 ib
6242   int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6243   emit_int8(0x72);</span>
<span class="line-removed">6244   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">6245   emit_int8(shift &amp; 0xFF);</span>
6246 }
6247 
6248 void Assembler::vpsllq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6249   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6250   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6251   attributes.set_rex_vex_w_reverted();
6252   // XMM6 is for /6 encoding: 66 0F 73 /6 ib
6253   int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6254   emit_int8(0x73);</span>
<span class="line-removed">6255   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">6256   emit_int8(shift &amp; 0xFF);</span>
6257 }
6258 
6259 void Assembler::vpsllw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6260   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6261   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6262   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6263   emit_int8((unsigned char)0xF1);</span>
<span class="line-removed">6264   emit_int8((unsigned char)(0xC0 | encode));</span>
6265 }
6266 
6267 void Assembler::vpslld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6268   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6269   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6270   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6271   emit_int8((unsigned char)0xF2);</span>
<span class="line-removed">6272   emit_int8((unsigned char)(0xC0 | encode));</span>
6273 }
6274 
6275 void Assembler::vpsllq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6276   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6277   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6278   attributes.set_rex_vex_w_reverted();
6279   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6280   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">6281   emit_int8((unsigned char)(0xC0 | encode));</span>
6282 }
6283 
6284 // Shift packed integers logically right by specified number of bits.
6285 void Assembler::psrlw(XMMRegister dst, int shift) {
6286   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6287   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6288   // XMM2 is for /2 encoding: 66 0F 71 /2 ib
6289   int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6290   emit_int8(0x71);</span>
<span class="line-removed">6291   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">6292   emit_int8(shift &amp; 0xFF);</span>
6293 }
6294 
6295 void Assembler::psrld(XMMRegister dst, int shift) {
6296   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6297   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6298   // XMM2 is for /2 encoding: 66 0F 72 /2 ib
6299   int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6300   emit_int8(0x72);</span>
<span class="line-removed">6301   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">6302   emit_int8(shift &amp; 0xFF);</span>
6303 }
6304 
6305 void Assembler::psrlq(XMMRegister dst, int shift) {
6306   // Do not confuse it with psrldq SSE2 instruction which
6307   // shifts 128 bit value in xmm register by number of bytes.
6308   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6309   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6310   attributes.set_rex_vex_w_reverted();
6311   // XMM2 is for /2 encoding: 66 0F 73 /2 ib
6312   int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6313   emit_int8(0x73);</span>
<span class="line-removed">6314   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">6315   emit_int8(shift &amp; 0xFF);</span>
6316 }
6317 
6318 void Assembler::psrlw(XMMRegister dst, XMMRegister shift) {
6319   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6320   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6321   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6322   emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">6323   emit_int8((unsigned char)(0xC0 | encode));</span>
6324 }
6325 
6326 void Assembler::psrld(XMMRegister dst, XMMRegister shift) {
6327   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6328   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6329   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6330   emit_int8((unsigned char)0xD2);</span>
<span class="line-removed">6331   emit_int8((unsigned char)(0xC0 | encode));</span>
6332 }
6333 
6334 void Assembler::psrlq(XMMRegister dst, XMMRegister shift) {
6335   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6336   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6337   attributes.set_rex_vex_w_reverted();
6338   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6339   emit_int8((unsigned char)0xD3);</span>
<span class="line-removed">6340   emit_int8((unsigned char)(0xC0 | encode));</span>
6341 }
6342 
6343 void Assembler::vpsrlw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6344   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6345   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6346   // XMM2 is for /2 encoding: 66 0F 71 /2 ib
6347   int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6348   emit_int8(0x71);</span>
<span class="line-removed">6349   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">6350   emit_int8(shift &amp; 0xFF);</span>
6351 }
6352 
6353 void Assembler::vpsrld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6354   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6355   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6356   // XMM2 is for /2 encoding: 66 0F 72 /2 ib
6357   int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6358   emit_int8(0x72);</span>
<span class="line-removed">6359   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">6360   emit_int8(shift &amp; 0xFF);</span>
6361 }
6362 
6363 void Assembler::vpsrlq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6364   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6365   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6366   attributes.set_rex_vex_w_reverted();
6367   // XMM2 is for /2 encoding: 66 0F 73 /2 ib
6368   int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6369   emit_int8(0x73);</span>
<span class="line-removed">6370   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">6371   emit_int8(shift &amp; 0xFF);</span>
6372 }
6373 
6374 void Assembler::vpsrlw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6375   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6376   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6377   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6378   emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">6379   emit_int8((unsigned char)(0xC0 | encode));</span>
6380 }
6381 
6382 void Assembler::vpsrld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6383   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6384   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6385   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6386   emit_int8((unsigned char)0xD2);</span>
<span class="line-removed">6387   emit_int8((unsigned char)(0xC0 | encode));</span>
6388 }
6389 
6390 void Assembler::vpsrlq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6391   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6392   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6393   attributes.set_rex_vex_w_reverted();
6394   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6395   emit_int8((unsigned char)0xD3);</span>
<span class="line-removed">6396   emit_int8((unsigned char)(0xC0 | encode));</span>
6397 }
6398 
6399 void Assembler::evpsrlvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6400   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
6401   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6402   attributes.set_is_evex_instruction();
6403   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">6404   emit_int8(0x10);</span>
<span class="line-removed">6405   emit_int8((unsigned char)(0xC0 | encode));</span>
6406 }
6407 
6408 void Assembler::evpsllvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6409   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
6410   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6411   attributes.set_is_evex_instruction();
6412   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">6413   emit_int8(0x12);</span>
<span class="line-removed">6414   emit_int8((unsigned char)(0xC0 | encode));</span>
6415 }
6416 
6417 // Shift packed integers arithmetically right by specified number of bits.
6418 void Assembler::psraw(XMMRegister dst, int shift) {
6419   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6420   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6421   // XMM4 is for /4 encoding: 66 0F 71 /4 ib
6422   int encode = simd_prefix_and_encode(xmm4, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6423   emit_int8(0x71);</span>
<span class="line-removed">6424   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">6425   emit_int8(shift &amp; 0xFF);</span>
6426 }
6427 
6428 void Assembler::psrad(XMMRegister dst, int shift) {
6429   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6430   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6431   // XMM4 is for /4 encoding: 66 0F 72 /4 ib
6432   int encode = simd_prefix_and_encode(xmm4, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6433   emit_int8(0x72);
<span class="line-modified">6434   emit_int8((unsigned char)(0xC0 | encode));</span>
6435   emit_int8(shift &amp; 0xFF);
6436 }
6437 
6438 void Assembler::psraw(XMMRegister dst, XMMRegister shift) {
6439   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6440   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6441   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6442   emit_int8((unsigned char)0xE1);</span>
<span class="line-removed">6443   emit_int8((unsigned char)(0xC0 | encode));</span>
6444 }
6445 
6446 void Assembler::psrad(XMMRegister dst, XMMRegister shift) {
6447   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6448   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6449   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6450   emit_int8((unsigned char)0xE2);</span>
<span class="line-removed">6451   emit_int8((unsigned char)(0xC0 | encode));</span>
6452 }
6453 
6454 void Assembler::vpsraw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6455   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6456   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6457   // XMM4 is for /4 encoding: 66 0F 71 /4 ib
6458   int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6459   emit_int8(0x71);</span>
<span class="line-removed">6460   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">6461   emit_int8(shift &amp; 0xFF);</span>
6462 }
6463 
6464 void Assembler::vpsrad(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6465   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6466   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6467   // XMM4 is for /4 encoding: 66 0F 71 /4 ib
6468   int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6469   emit_int8(0x72);</span>
<span class="line-removed">6470   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">6471   emit_int8(shift &amp; 0xFF);</span>
6472 }
6473 
6474 void Assembler::vpsraw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6475   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6476   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6477   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6478   emit_int8((unsigned char)0xE1);</span>
<span class="line-removed">6479   emit_int8((unsigned char)(0xC0 | encode));</span>
6480 }
6481 
6482 void Assembler::vpsrad(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6483   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6484   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6485   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6486   emit_int8((unsigned char)0xE2);</span>
<span class="line-removed">6487   emit_int8((unsigned char)(0xC0 | encode));</span>
6488 }
6489 
6490 void Assembler::evpsraq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6491   assert(UseAVX &gt; 2, &quot;requires AVX512&quot;);
6492   assert ((VM_Version::supports_avx512vl() || vector_len == 2), &quot;requires AVX512vl&quot;);
6493   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6494   attributes.set_is_evex_instruction();
6495   int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6496   emit_int8((unsigned char)0x72);</span>
<span class="line-removed">6497   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">6498   emit_int8(shift &amp; 0xFF);</span>
6499 }
6500 
6501 void Assembler::evpsraq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6502   assert(UseAVX &gt; 2, &quot;requires AVX512&quot;);
6503   assert ((VM_Version::supports_avx512vl() || vector_len == 2), &quot;requires AVX512vl&quot;);
6504   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6505   attributes.set_is_evex_instruction();
6506   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6507   emit_int8((unsigned char)0xE2);</span>
<span class="line-removed">6508   emit_int8((unsigned char)(0xC0 | encode));</span>
6509 }
6510 
6511 // logical operations packed integers
6512 void Assembler::pand(XMMRegister dst, XMMRegister src) {
6513   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6514   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6515   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6516   emit_int8((unsigned char)0xDB);</span>
<span class="line-removed">6517   emit_int8((unsigned char)(0xC0 | encode));</span>
6518 }
6519 
6520 void Assembler::vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6521   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6522   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6523   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6524   emit_int8((unsigned char)0xDB);</span>
<span class="line-removed">6525   emit_int8((unsigned char)(0xC0 | encode));</span>
6526 }
6527 
6528 void Assembler::vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6529   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6530   InstructionMark im(this);
6531   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6532   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
6533   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6534   emit_int8((unsigned char)0xDB);
6535   emit_operand(dst, src);
6536 }
6537 
6538 void Assembler::vpandq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6539   assert(VM_Version::supports_evex(), &quot;&quot;);
6540   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6541   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6542   emit_int8((unsigned char)0xDB);</span>
<span class="line-removed">6543   emit_int8((unsigned char)(0xC0 | encode));</span>
6544 }
6545 
6546 void Assembler::vpshldvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
<span class="line-modified">6547   assert(VM_Version::supports_vbmi2(), &quot;requires vbmi2&quot;);</span>
6548   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6549   attributes.set_is_evex_instruction();
6550   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6551   emit_int8(0x71);
<span class="line-modified">6552   emit_int8((unsigned char)(0xC0 | encode));</span>
6553 }
6554 
6555 void Assembler::vpshrdvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
<span class="line-modified">6556   assert(VM_Version::supports_vbmi2(), &quot;requires vbmi2&quot;);</span>
6557   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6558   attributes.set_is_evex_instruction();
6559   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">6560   emit_int8(0x73);</span>
<span class="line-removed">6561   emit_int8((unsigned char)(0xC0 | encode));</span>
6562 }
6563 
6564 void Assembler::pandn(XMMRegister dst, XMMRegister src) {
6565   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6566   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6567   attributes.set_rex_vex_w_reverted();
6568   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6569   emit_int8((unsigned char)0xDF);</span>
<span class="line-removed">6570   emit_int8((unsigned char)(0xC0 | encode));</span>
6571 }
6572 
6573 void Assembler::vpandn(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6574   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6575   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6576   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6577   emit_int8((unsigned char)0xDF);</span>
<span class="line-removed">6578   emit_int8((unsigned char)(0xC0 | encode));</span>
6579 }
6580 
6581 
6582 void Assembler::por(XMMRegister dst, XMMRegister src) {
6583   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6584   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6585   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6586   emit_int8((unsigned char)0xEB);</span>
<span class="line-removed">6587   emit_int8((unsigned char)(0xC0 | encode));</span>
6588 }
6589 
6590 void Assembler::vpor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6591   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6592   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6593   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6594   emit_int8((unsigned char)0xEB);</span>
<span class="line-removed">6595   emit_int8((unsigned char)(0xC0 | encode));</span>
6596 }
6597 
6598 void Assembler::vpor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6599   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6600   InstructionMark im(this);
6601   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6602   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
6603   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6604   emit_int8((unsigned char)0xEB);
6605   emit_operand(dst, src);
6606 }
6607 
6608 void Assembler::vporq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6609   assert(VM_Version::supports_evex(), &quot;&quot;);
6610   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6611   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6612   emit_int8((unsigned char)0xEB);</span>
<span class="line-removed">6613   emit_int8((unsigned char)(0xC0 | encode));</span>
6614 }
6615 
6616 
6617 void Assembler::pxor(XMMRegister dst, XMMRegister src) {
6618   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6619   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6620   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6621   emit_int8((unsigned char)0xEF);</span>
<span class="line-removed">6622   emit_int8((unsigned char)(0xC0 | encode));</span>
6623 }
6624 
6625 void Assembler::vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6626   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6627   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6628   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6629   emit_int8((unsigned char)0xEF);</span>
<span class="line-removed">6630   emit_int8((unsigned char)(0xC0 | encode));</span>
6631 }
6632 
6633 void Assembler::vpxor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6634   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6635   InstructionMark im(this);
6636   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6637   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
6638   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6639   emit_int8((unsigned char)0xEF);
6640   emit_operand(dst, src);
6641 }
6642 
6643 void Assembler::evpxorq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6644   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
6645   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6646   attributes.set_is_evex_instruction();
6647   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6648   emit_int8((unsigned char)0xEF);
<span class="line-modified">6649   emit_int8((unsigned char)(0xC0 | encode));</span>
6650 }
6651 
6652 void Assembler::evpxorq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6653   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
6654   assert(dst != xnoreg, &quot;sanity&quot;);
6655   InstructionMark im(this);
6656   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6657   attributes.set_is_evex_instruction();
6658   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
6659   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6660   emit_int8((unsigned char)0xEF);
6661   emit_operand(dst, src);
6662 }
6663 
6664 
6665 // vinserti forms
6666 
6667 void Assembler::vinserti128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6668   assert(VM_Version::supports_avx2(), &quot;&quot;);
6669   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6670   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6671   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6672   emit_int8(0x38);</span>
<span class="line-removed">6673   emit_int8((unsigned char)(0xC0 | encode));</span>
6674   // 0x00 - insert into lower 128 bits
6675   // 0x01 - insert into upper 128 bits
<span class="line-modified">6676   emit_int8(imm8 &amp; 0x01);</span>
6677 }
6678 
6679 void Assembler::vinserti128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6680   assert(VM_Version::supports_avx2(), &quot;&quot;);
6681   assert(dst != xnoreg, &quot;sanity&quot;);
6682   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6683   InstructionMark im(this);
6684   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6685   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6686   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6687   emit_int8(0x38);
6688   emit_operand(dst, src);
6689   // 0x00 - insert into lower 128 bits
6690   // 0x01 - insert into upper 128 bits
6691   emit_int8(imm8 &amp; 0x01);
6692 }
6693 
6694 void Assembler::vinserti32x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6695   assert(VM_Version::supports_evex(), &quot;&quot;);
6696   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6697   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6698   attributes.set_is_evex_instruction();
6699   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6700   emit_int8(0x38);</span>
<span class="line-removed">6701   emit_int8((unsigned char)(0xC0 | encode));</span>
6702   // 0x00 - insert into q0 128 bits (0..127)
6703   // 0x01 - insert into q1 128 bits (128..255)
6704   // 0x02 - insert into q2 128 bits (256..383)
6705   // 0x03 - insert into q3 128 bits (384..511)
<span class="line-modified">6706   emit_int8(imm8 &amp; 0x03);</span>
6707 }
6708 
6709 void Assembler::vinserti32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6710   assert(VM_Version::supports_avx(), &quot;&quot;);
6711   assert(dst != xnoreg, &quot;sanity&quot;);
6712   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6713   InstructionMark im(this);
6714   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6715   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6716   attributes.set_is_evex_instruction();
6717   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6718   emit_int8(0x18);
6719   emit_operand(dst, src);
6720   // 0x00 - insert into q0 128 bits (0..127)
6721   // 0x01 - insert into q1 128 bits (128..255)
6722   // 0x02 - insert into q2 128 bits (256..383)
6723   // 0x03 - insert into q3 128 bits (384..511)
6724   emit_int8(imm8 &amp; 0x03);
6725 }
6726 
6727 void Assembler::vinserti64x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6728   assert(VM_Version::supports_evex(), &quot;&quot;);
6729   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6730   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6731   attributes.set_is_evex_instruction();
6732   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6733   emit_int8(0x3A);</span>
<span class="line-removed">6734   emit_int8((unsigned char)(0xC0 | encode));</span>
6735   // 0x00 - insert into lower 256 bits
6736   // 0x01 - insert into upper 256 bits
<span class="line-modified">6737   emit_int8(imm8 &amp; 0x01);</span>
6738 }
6739 
6740 
6741 // vinsertf forms
6742 
6743 void Assembler::vinsertf128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6744   assert(VM_Version::supports_avx(), &quot;&quot;);
6745   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6746   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6747   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6748   emit_int8(0x18);</span>
<span class="line-removed">6749   emit_int8((unsigned char)(0xC0 | encode));</span>
6750   // 0x00 - insert into lower 128 bits
6751   // 0x01 - insert into upper 128 bits
<span class="line-modified">6752   emit_int8(imm8 &amp; 0x01);</span>
6753 }
6754 
6755 void Assembler::vinsertf128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6756   assert(VM_Version::supports_avx(), &quot;&quot;);
6757   assert(dst != xnoreg, &quot;sanity&quot;);
6758   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6759   InstructionMark im(this);
6760   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6761   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6762   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6763   emit_int8(0x18);
6764   emit_operand(dst, src);
6765   // 0x00 - insert into lower 128 bits
6766   // 0x01 - insert into upper 128 bits
6767   emit_int8(imm8 &amp; 0x01);
6768 }
6769 
6770 void Assembler::vinsertf32x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6771   assert(VM_Version::supports_avx2(), &quot;&quot;);
6772   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6773   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6774   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6775   emit_int8(0x18);</span>
<span class="line-removed">6776   emit_int8((unsigned char)(0xC0 | encode));</span>
6777   // 0x00 - insert into q0 128 bits (0..127)
6778   // 0x01 - insert into q1 128 bits (128..255)
6779   // 0x02 - insert into q0 128 bits (256..383)
6780   // 0x03 - insert into q1 128 bits (384..512)
<span class="line-modified">6781   emit_int8(imm8 &amp; 0x03);</span>
6782 }
6783 
6784 void Assembler::vinsertf32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6785   assert(VM_Version::supports_avx(), &quot;&quot;);
6786   assert(dst != xnoreg, &quot;sanity&quot;);
6787   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6788   InstructionMark im(this);
6789   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6790   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6791   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6792   emit_int8(0x18);
6793   emit_operand(dst, src);
6794   // 0x00 - insert into q0 128 bits (0..127)
6795   // 0x01 - insert into q1 128 bits (128..255)
6796   // 0x02 - insert into q0 128 bits (256..383)
6797   // 0x03 - insert into q1 128 bits (384..512)
6798   emit_int8(imm8 &amp; 0x03);
6799 }
6800 
6801 void Assembler::vinsertf64x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6802   assert(VM_Version::supports_evex(), &quot;&quot;);
6803   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6804   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6805   attributes.set_is_evex_instruction();
6806   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6807   emit_int8(0x1A);</span>
<span class="line-removed">6808   emit_int8((unsigned char)(0xC0 | encode));</span>
6809   // 0x00 - insert into lower 256 bits
6810   // 0x01 - insert into upper 256 bits
<span class="line-modified">6811   emit_int8(imm8 &amp; 0x01);</span>
6812 }
6813 
6814 void Assembler::vinsertf64x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6815   assert(VM_Version::supports_evex(), &quot;&quot;);
6816   assert(dst != xnoreg, &quot;sanity&quot;);
6817   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6818   InstructionMark im(this);
6819   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6820   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_64bit);
6821   attributes.set_is_evex_instruction();
6822   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6823   emit_int8(0x1A);
6824   emit_operand(dst, src);
6825   // 0x00 - insert into lower 256 bits
6826   // 0x01 - insert into upper 256 bits
6827   emit_int8(imm8 &amp; 0x01);
6828 }
6829 
6830 
6831 // vextracti forms
6832 
6833 void Assembler::vextracti128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6834   assert(VM_Version::supports_avx2(), &quot;&quot;);
6835   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6836   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6837   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6838   emit_int8(0x39);</span>
<span class="line-removed">6839   emit_int8((unsigned char)(0xC0 | encode));</span>
6840   // 0x00 - extract from lower 128 bits
6841   // 0x01 - extract from upper 128 bits
<span class="line-modified">6842   emit_int8(imm8 &amp; 0x01);</span>
6843 }
6844 
6845 void Assembler::vextracti128(Address dst, XMMRegister src, uint8_t imm8) {
6846   assert(VM_Version::supports_avx2(), &quot;&quot;);
6847   assert(src != xnoreg, &quot;sanity&quot;);
6848   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6849   InstructionMark im(this);
6850   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6851   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6852   attributes.reset_is_clear_context();
6853   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6854   emit_int8(0x39);
6855   emit_operand(src, dst);
6856   // 0x00 - extract from lower 128 bits
6857   // 0x01 - extract from upper 128 bits
6858   emit_int8(imm8 &amp; 0x01);
6859 }
6860 
6861 void Assembler::vextracti32x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6862   assert(VM_Version::supports_evex(), &quot;&quot;);
6863   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6864   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6865   attributes.set_is_evex_instruction();
6866   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6867   emit_int8(0x39);</span>
<span class="line-removed">6868   emit_int8((unsigned char)(0xC0 | encode));</span>
6869   // 0x00 - extract from bits 127:0
6870   // 0x01 - extract from bits 255:128
6871   // 0x02 - extract from bits 383:256
6872   // 0x03 - extract from bits 511:384
<span class="line-modified">6873   emit_int8(imm8 &amp; 0x03);</span>
6874 }
6875 
6876 void Assembler::vextracti32x4(Address dst, XMMRegister src, uint8_t imm8) {
6877   assert(VM_Version::supports_evex(), &quot;&quot;);
6878   assert(src != xnoreg, &quot;sanity&quot;);
6879   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6880   InstructionMark im(this);
6881   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6882   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6883   attributes.reset_is_clear_context();
6884   attributes.set_is_evex_instruction();
6885   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6886   emit_int8(0x39);
6887   emit_operand(src, dst);
6888   // 0x00 - extract from bits 127:0
6889   // 0x01 - extract from bits 255:128
6890   // 0x02 - extract from bits 383:256
6891   // 0x03 - extract from bits 511:384
6892   emit_int8(imm8 &amp; 0x03);
6893 }
6894 
6895 void Assembler::vextracti64x2(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6896   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
6897   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6898   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6899   attributes.set_is_evex_instruction();
6900   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6901   emit_int8(0x39);</span>
<span class="line-removed">6902   emit_int8((unsigned char)(0xC0 | encode));</span>
6903   // 0x00 - extract from bits 127:0
6904   // 0x01 - extract from bits 255:128
6905   // 0x02 - extract from bits 383:256
6906   // 0x03 - extract from bits 511:384
<span class="line-modified">6907   emit_int8(imm8 &amp; 0x03);</span>
6908 }
6909 
6910 void Assembler::vextracti64x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6911   assert(VM_Version::supports_evex(), &quot;&quot;);
6912   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6913   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6914   attributes.set_is_evex_instruction();
6915   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6916   emit_int8(0x3B);</span>
<span class="line-removed">6917   emit_int8((unsigned char)(0xC0 | encode));</span>
6918   // 0x00 - extract from lower 256 bits
6919   // 0x01 - extract from upper 256 bits
<span class="line-modified">6920   emit_int8(imm8 &amp; 0x01);</span>
6921 }
6922 
6923 void Assembler::vextracti64x4(Address dst, XMMRegister src, uint8_t imm8) {
6924   assert(VM_Version::supports_evex(), &quot;&quot;);
6925   assert(src != xnoreg, &quot;sanity&quot;);
6926   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6927   InstructionMark im(this);
6928   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6929   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_64bit);
6930   attributes.reset_is_clear_context();
6931   attributes.set_is_evex_instruction();
6932   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6933   emit_int8(0x38);
6934   emit_operand(src, dst);
6935   // 0x00 - extract from lower 256 bits
6936   // 0x01 - extract from upper 256 bits
6937   emit_int8(imm8 &amp; 0x01);
6938 }
6939 // vextractf forms
6940 
6941 void Assembler::vextractf128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6942   assert(VM_Version::supports_avx(), &quot;&quot;);
6943   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6944   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6945   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6946   emit_int8(0x19);</span>
<span class="line-removed">6947   emit_int8((unsigned char)(0xC0 | encode));</span>
6948   // 0x00 - extract from lower 128 bits
6949   // 0x01 - extract from upper 128 bits
<span class="line-modified">6950   emit_int8(imm8 &amp; 0x01);</span>
6951 }
6952 
6953 void Assembler::vextractf128(Address dst, XMMRegister src, uint8_t imm8) {
6954   assert(VM_Version::supports_avx(), &quot;&quot;);
6955   assert(src != xnoreg, &quot;sanity&quot;);
6956   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6957   InstructionMark im(this);
6958   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6959   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6960   attributes.reset_is_clear_context();
6961   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6962   emit_int8(0x19);
6963   emit_operand(src, dst);
6964   // 0x00 - extract from lower 128 bits
6965   // 0x01 - extract from upper 128 bits
6966   emit_int8(imm8 &amp; 0x01);
6967 }
6968 
6969 void Assembler::vextractf32x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6970   assert(VM_Version::supports_evex(), &quot;&quot;);
6971   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6972   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6973   attributes.set_is_evex_instruction();
6974   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6975   emit_int8(0x19);</span>
<span class="line-removed">6976   emit_int8((unsigned char)(0xC0 | encode));</span>
6977   // 0x00 - extract from bits 127:0
6978   // 0x01 - extract from bits 255:128
6979   // 0x02 - extract from bits 383:256
6980   // 0x03 - extract from bits 511:384
<span class="line-modified">6981   emit_int8(imm8 &amp; 0x03);</span>
6982 }
6983 
6984 void Assembler::vextractf32x4(Address dst, XMMRegister src, uint8_t imm8) {
6985   assert(VM_Version::supports_evex(), &quot;&quot;);
6986   assert(src != xnoreg, &quot;sanity&quot;);
6987   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6988   InstructionMark im(this);
6989   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6990   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6991   attributes.reset_is_clear_context();
6992   attributes.set_is_evex_instruction();
6993   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6994   emit_int8(0x19);
6995   emit_operand(src, dst);
6996   // 0x00 - extract from bits 127:0
6997   // 0x01 - extract from bits 255:128
6998   // 0x02 - extract from bits 383:256
6999   // 0x03 - extract from bits 511:384
7000   emit_int8(imm8 &amp; 0x03);
7001 }
7002 
7003 void Assembler::vextractf64x2(XMMRegister dst, XMMRegister src, uint8_t imm8) {
7004   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
7005   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
7006   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7007   attributes.set_is_evex_instruction();
7008   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">7009   emit_int8(0x19);</span>
<span class="line-removed">7010   emit_int8((unsigned char)(0xC0 | encode));</span>
7011   // 0x00 - extract from bits 127:0
7012   // 0x01 - extract from bits 255:128
7013   // 0x02 - extract from bits 383:256
7014   // 0x03 - extract from bits 511:384
<span class="line-modified">7015   emit_int8(imm8 &amp; 0x03);</span>
7016 }
7017 
7018 void Assembler::vextractf64x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
7019   assert(VM_Version::supports_evex(), &quot;&quot;);
7020   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
7021   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7022   attributes.set_is_evex_instruction();
7023   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">7024   emit_int8(0x1B);</span>
<span class="line-removed">7025   emit_int8((unsigned char)(0xC0 | encode));</span>
7026   // 0x00 - extract from lower 256 bits
7027   // 0x01 - extract from upper 256 bits
<span class="line-modified">7028   emit_int8(imm8 &amp; 0x01);</span>
7029 }
7030 
7031 void Assembler::vextractf64x4(Address dst, XMMRegister src, uint8_t imm8) {
7032   assert(VM_Version::supports_evex(), &quot;&quot;);
7033   assert(src != xnoreg, &quot;sanity&quot;);
7034   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
7035   InstructionMark im(this);
7036   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7037   attributes.set_address_attributes(/* tuple_type */ EVEX_T4,/* input_size_in_bits */  EVEX_64bit);
7038   attributes.reset_is_clear_context();
7039   attributes.set_is_evex_instruction();
7040   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
7041   emit_int8(0x1B);
7042   emit_operand(src, dst);
7043   // 0x00 - extract from lower 256 bits
7044   // 0x01 - extract from upper 256 bits
7045   emit_int8(imm8 &amp; 0x01);
7046 }
7047 
7048 // duplicate 1-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
7049 void Assembler::vpbroadcastb(XMMRegister dst, XMMRegister src, int vector_len) {
7050   assert(VM_Version::supports_avx2(), &quot;&quot;);
7051   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
7052   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">7053   emit_int8(0x78);</span>
<span class="line-removed">7054   emit_int8((unsigned char)(0xC0 | encode));</span>
7055 }
7056 
7057 void Assembler::vpbroadcastb(XMMRegister dst, Address src, int vector_len) {
7058   assert(VM_Version::supports_avx2(), &quot;&quot;);
7059   assert(dst != xnoreg, &quot;sanity&quot;);
7060   InstructionMark im(this);
7061   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
7062   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_8bit);
7063   // swap src&lt;-&gt;dst for encoding
7064   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7065   emit_int8(0x78);
7066   emit_operand(dst, src);
7067 }
7068 
7069 // duplicate 2-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
7070 void Assembler::vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len) {
7071   assert(VM_Version::supports_avx2(), &quot;&quot;);
7072   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
7073   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">7074   emit_int8(0x79);</span>
<span class="line-removed">7075   emit_int8((unsigned char)(0xC0 | encode));</span>
7076 }
7077 
7078 void Assembler::vpbroadcastw(XMMRegister dst, Address src, int vector_len) {
7079   assert(VM_Version::supports_avx2(), &quot;&quot;);
7080   assert(dst != xnoreg, &quot;sanity&quot;);
7081   InstructionMark im(this);
7082   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
7083   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_16bit);
7084   // swap src&lt;-&gt;dst for encoding
7085   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7086   emit_int8(0x79);
7087   emit_operand(dst, src);
7088 }
7089 
7090 // xmm/mem sourced byte/word/dword/qword replicate
7091 
7092 // duplicate 4-byte integer data from src into programmed locations in dest : requires AVX512VL
7093 void Assembler::vpbroadcastd(XMMRegister dst, XMMRegister src, int vector_len) {
7094   assert(UseAVX &gt;= 2, &quot;&quot;);
7095   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7096   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">7097   emit_int8(0x58);</span>
<span class="line-removed">7098   emit_int8((unsigned char)(0xC0 | encode));</span>
7099 }
7100 
7101 void Assembler::vpbroadcastd(XMMRegister dst, Address src, int vector_len) {
7102   assert(VM_Version::supports_avx2(), &quot;&quot;);
7103   assert(dst != xnoreg, &quot;sanity&quot;);
7104   InstructionMark im(this);
7105   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7106   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
7107   // swap src&lt;-&gt;dst for encoding
7108   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7109   emit_int8(0x58);
7110   emit_operand(dst, src);
7111 }
7112 
7113 // duplicate 8-byte integer data from src into programmed locations in dest : requires AVX512VL
7114 void Assembler::vpbroadcastq(XMMRegister dst, XMMRegister src, int vector_len) {
7115   assert(VM_Version::supports_avx2(), &quot;&quot;);
7116   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7117   attributes.set_rex_vex_w_reverted();
7118   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">7119   emit_int8(0x59);</span>
<span class="line-removed">7120   emit_int8((unsigned char)(0xC0 | encode));</span>
7121 }
7122 
7123 void Assembler::vpbroadcastq(XMMRegister dst, Address src, int vector_len) {
7124   assert(VM_Version::supports_avx2(), &quot;&quot;);
7125   assert(dst != xnoreg, &quot;sanity&quot;);
7126   InstructionMark im(this);
7127   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7128   attributes.set_rex_vex_w_reverted();
7129   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
7130   // swap src&lt;-&gt;dst for encoding
7131   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7132   emit_int8(0x59);
7133   emit_operand(dst, src);
7134 }
7135 void Assembler::evbroadcasti64x2(XMMRegister dst, XMMRegister src, int vector_len) {
7136   assert(vector_len != Assembler::AVX_128bit, &quot;&quot;);
7137   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
7138   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7139   attributes.set_rex_vex_w_reverted();
7140   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">7141   emit_int8(0x5A);</span>
<span class="line-removed">7142   emit_int8((unsigned char)(0xC0 | encode));</span>
7143 }
7144 
7145 void Assembler::evbroadcasti64x2(XMMRegister dst, Address src, int vector_len) {
7146   assert(vector_len != Assembler::AVX_128bit, &quot;&quot;);
7147   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
7148   assert(dst != xnoreg, &quot;sanity&quot;);
7149   InstructionMark im(this);
7150   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7151   attributes.set_rex_vex_w_reverted();
7152   attributes.set_address_attributes(/* tuple_type */ EVEX_T2, /* input_size_in_bits */ EVEX_64bit);
7153   // swap src&lt;-&gt;dst for encoding
7154   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7155   emit_int8(0x5A);
7156   emit_operand(dst, src);
7157 }
7158 
7159 // scalar single/double precision replicate
7160 
7161 // duplicate single precision data from src into programmed locations in dest : requires AVX512VL
7162 void Assembler::vbroadcastss(XMMRegister dst, XMMRegister src, int vector_len) {
<span class="line-modified">7163   assert(VM_Version::supports_avx(), &quot;&quot;);</span>
7164   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7165   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">7166   emit_int8(0x18);</span>
<span class="line-removed">7167   emit_int8((unsigned char)(0xC0 | encode));</span>
7168 }
7169 
7170 void Assembler::vbroadcastss(XMMRegister dst, Address src, int vector_len) {
7171   assert(VM_Version::supports_avx(), &quot;&quot;);
7172   assert(dst != xnoreg, &quot;sanity&quot;);
7173   InstructionMark im(this);
7174   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7175   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
7176   // swap src&lt;-&gt;dst for encoding
7177   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7178   emit_int8(0x18);
7179   emit_operand(dst, src);
7180 }
7181 
7182 // duplicate double precision data from src into programmed locations in dest : requires AVX512VL
7183 void Assembler::vbroadcastsd(XMMRegister dst, XMMRegister src, int vector_len) {
<span class="line-modified">7184   assert(VM_Version::supports_avx(), &quot;&quot;);</span>

7185   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7186   attributes.set_rex_vex_w_reverted();
7187   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">7188   emit_int8(0x19);</span>
<span class="line-removed">7189   emit_int8((unsigned char)(0xC0 | encode));</span>
7190 }
7191 
7192 void Assembler::vbroadcastsd(XMMRegister dst, Address src, int vector_len) {
7193   assert(VM_Version::supports_avx(), &quot;&quot;);

7194   assert(dst != xnoreg, &quot;sanity&quot;);
7195   InstructionMark im(this);
7196   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7197   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
7198   attributes.set_rex_vex_w_reverted();
7199   // swap src&lt;-&gt;dst for encoding
7200   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7201   emit_int8(0x19);
7202   emit_operand(dst, src);
7203 }
7204 
7205 
7206 // gpr source broadcast forms
7207 
7208 // duplicate 1-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
7209 void Assembler::evpbroadcastb(XMMRegister dst, Register src, int vector_len) {
7210   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
7211   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
7212   attributes.set_is_evex_instruction();
7213   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">7214   emit_int8(0x7A);</span>
<span class="line-removed">7215   emit_int8((unsigned char)(0xC0 | encode));</span>
7216 }
7217 
7218 // duplicate 2-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
7219 void Assembler::evpbroadcastw(XMMRegister dst, Register src, int vector_len) {
7220   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
7221   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
7222   attributes.set_is_evex_instruction();
7223   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">7224   emit_int8(0x7B);</span>
<span class="line-removed">7225   emit_int8((unsigned char)(0xC0 | encode));</span>
7226 }
7227 
7228 // duplicate 4-byte integer data from src into programmed locations in dest : requires AVX512VL
7229 void Assembler::evpbroadcastd(XMMRegister dst, Register src, int vector_len) {
7230   assert(VM_Version::supports_evex(), &quot;&quot;);
7231   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7232   attributes.set_is_evex_instruction();
7233   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">7234   emit_int8(0x7C);</span>
<span class="line-removed">7235   emit_int8((unsigned char)(0xC0 | encode));</span>
7236 }
7237 
7238 // duplicate 8-byte integer data from src into programmed locations in dest : requires AVX512VL
7239 void Assembler::evpbroadcastq(XMMRegister dst, Register src, int vector_len) {
7240   assert(VM_Version::supports_evex(), &quot;&quot;);
7241   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7242   attributes.set_is_evex_instruction();
7243   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">7244   emit_int8(0x7C);</span>
<span class="line-removed">7245   emit_int8((unsigned char)(0xC0 | encode));</span>
7246 }
7247 void Assembler::evpgatherdd(XMMRegister dst, KRegister mask, Address src, int vector_len) {
7248   assert(VM_Version::supports_evex(), &quot;&quot;);
7249   assert(dst != xnoreg, &quot;sanity&quot;);
7250   InstructionMark im(this);
7251   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
7252   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
7253   attributes.reset_is_clear_context();
7254   attributes.set_embedded_opmask_register_specifier(mask);
7255   attributes.set_is_evex_instruction();
7256   // swap src&lt;-&gt;dst for encoding
7257   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
7258   emit_int8((unsigned char)0x90);
7259   emit_operand(dst, src);
7260 }
7261 // Carry-Less Multiplication Quadword
7262 void Assembler::pclmulqdq(XMMRegister dst, XMMRegister src, int mask) {
7263   assert(VM_Version::supports_clmul(), &quot;&quot;);
7264   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
7265   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">7266   emit_int8(0x44);</span>
<span class="line-removed">7267   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">7268   emit_int8((unsigned char)mask);</span>
7269 }
7270 
7271 // Carry-Less Multiplication Quadword
7272 void Assembler::vpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask) {
7273   assert(VM_Version::supports_avx() &amp;&amp; VM_Version::supports_clmul(), &quot;&quot;);
7274   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
7275   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">7276   emit_int8(0x44);</span>
<span class="line-removed">7277   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">7278   emit_int8((unsigned char)mask);</span>
7279 }
7280 
7281 void Assembler::evpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask, int vector_len) {
7282   assert(VM_Version::supports_avx512_vpclmulqdq(), &quot;Requires vector carryless multiplication support&quot;);
7283   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
7284   attributes.set_is_evex_instruction();
7285   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">7286   emit_int8(0x44);</span>
<span class="line-removed">7287   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">7288   emit_int8((unsigned char)mask);</span>
7289 }
7290 
<span class="line-modified">7291 void Assembler::vzeroupper() {</span>
7292   if (VM_Version::supports_vzeroupper()) {
7293     InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
7294     (void)vex_prefix_and_encode(0, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
7295     emit_int8(0x77);
7296   }
7297 }
7298 
7299 #ifndef _LP64
7300 // 32bit only pieces of the assembler
7301 









7302 void Assembler::cmp_literal32(Register src1, int32_t imm32, RelocationHolder const&amp; rspec) {
7303   // NO PREFIX AS NEVER 64BIT
7304   InstructionMark im(this);
<span class="line-modified">7305   emit_int8((unsigned char)0x81);</span>
<span class="line-removed">7306   emit_int8((unsigned char)(0xF8 | src1-&gt;encoding()));</span>
7307   emit_data(imm32, rspec, 0);
7308 }
7309 
7310 void Assembler::cmp_literal32(Address src1, int32_t imm32, RelocationHolder const&amp; rspec) {
7311   // NO PREFIX AS NEVER 64BIT (not even 32bit versions of 64bit regs
7312   InstructionMark im(this);
7313   emit_int8((unsigned char)0x81);
7314   emit_operand(rdi, src1);
7315   emit_data(imm32, rspec, 0);
7316 }
7317 
7318 // The 64-bit (32bit platform) cmpxchg compares the value at adr with the contents of rdx:rax,
7319 // and stores rcx:rbx into adr if so; otherwise, the value at adr is loaded
7320 // into rdx:rax.  The ZF is set if the compared values were equal, and cleared otherwise.
7321 void Assembler::cmpxchg8(Address adr) {
7322   InstructionMark im(this);
<span class="line-modified">7323   emit_int8(0x0F);</span>
<span class="line-removed">7324   emit_int8((unsigned char)0xC7);</span>
7325   emit_operand(rcx, adr);
7326 }
7327 
7328 void Assembler::decl(Register dst) {
7329   // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
7330  emit_int8(0x48 | dst-&gt;encoding());
7331 }
7332 
7333 // 64bit doesn&#39;t use the x87
7334 













7335 void Assembler::fabs() {
<span class="line-modified">7336   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">7337   emit_int8((unsigned char)0xE1);</span>
7338 }
7339 
7340 void Assembler::fadd(int i) {
7341   emit_farith(0xD8, 0xC0, i);
7342 }
7343 
7344 void Assembler::fadd_d(Address src) {
7345   InstructionMark im(this);
7346   emit_int8((unsigned char)0xDC);
7347   emit_operand32(rax, src);
7348 }
7349 
7350 void Assembler::fadd_s(Address src) {
7351   InstructionMark im(this);
7352   emit_int8((unsigned char)0xD8);
7353   emit_operand32(rax, src);
7354 }
7355 
7356 void Assembler::fadda(int i) {
7357   emit_farith(0xDC, 0xC0, i);
7358 }
7359 
7360 void Assembler::faddp(int i) {
7361   emit_farith(0xDE, 0xC0, i);
7362 }
7363 
7364 void Assembler::fchs() {
<span class="line-modified">7365   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">7366   emit_int8((unsigned char)0xE0);</span>
7367 }
7368 
7369 void Assembler::fcom(int i) {
7370   emit_farith(0xD8, 0xD0, i);
7371 }
7372 
7373 void Assembler::fcomp(int i) {
7374   emit_farith(0xD8, 0xD8, i);
7375 }
7376 
7377 void Assembler::fcomp_d(Address src) {
7378   InstructionMark im(this);
7379   emit_int8((unsigned char)0xDC);
7380   emit_operand32(rbx, src);
7381 }
7382 
7383 void Assembler::fcomp_s(Address src) {
7384   InstructionMark im(this);
7385   emit_int8((unsigned char)0xD8);
7386   emit_operand32(rbx, src);
7387 }
7388 
7389 void Assembler::fcompp() {
<span class="line-modified">7390   emit_int8((unsigned char)0xDE);</span>
<span class="line-removed">7391   emit_int8((unsigned char)0xD9);</span>
7392 }
7393 
7394 void Assembler::fcos() {
<span class="line-modified">7395   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">7396   emit_int8((unsigned char)0xFF);</span>
7397 }
7398 
7399 void Assembler::fdecstp() {
<span class="line-modified">7400   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">7401   emit_int8((unsigned char)0xF6);</span>
7402 }
7403 
7404 void Assembler::fdiv(int i) {
7405   emit_farith(0xD8, 0xF0, i);
7406 }
7407 
7408 void Assembler::fdiv_d(Address src) {
7409   InstructionMark im(this);
7410   emit_int8((unsigned char)0xDC);
7411   emit_operand32(rsi, src);
7412 }
7413 
7414 void Assembler::fdiv_s(Address src) {
7415   InstructionMark im(this);
7416   emit_int8((unsigned char)0xD8);
7417   emit_operand32(rsi, src);
7418 }
7419 
7420 void Assembler::fdiva(int i) {
7421   emit_farith(0xDC, 0xF8, i);
</pre>
<hr />
<pre>
7452   emit_farith(0xDE, 0xF0, i);                    // ST(0) &lt;- ST(1) / ST(0) and pop (Intel manual wrong)
7453 }
7454 
7455 void Assembler::ffree(int i) {
7456   emit_farith(0xDD, 0xC0, i);
7457 }
7458 
7459 void Assembler::fild_d(Address adr) {
7460   InstructionMark im(this);
7461   emit_int8((unsigned char)0xDF);
7462   emit_operand32(rbp, adr);
7463 }
7464 
7465 void Assembler::fild_s(Address adr) {
7466   InstructionMark im(this);
7467   emit_int8((unsigned char)0xDB);
7468   emit_operand32(rax, adr);
7469 }
7470 
7471 void Assembler::fincstp() {
<span class="line-modified">7472   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">7473   emit_int8((unsigned char)0xF7);</span>
7474 }
7475 
7476 void Assembler::finit() {
<span class="line-modified">7477   emit_int8((unsigned char)0x9B);</span>
<span class="line-removed">7478   emit_int8((unsigned char)0xDB);</span>
<span class="line-removed">7479   emit_int8((unsigned char)0xE3);</span>
7480 }
7481 
7482 void Assembler::fist_s(Address adr) {
7483   InstructionMark im(this);
7484   emit_int8((unsigned char)0xDB);
7485   emit_operand32(rdx, adr);
7486 }
7487 
7488 void Assembler::fistp_d(Address adr) {
7489   InstructionMark im(this);
7490   emit_int8((unsigned char)0xDF);
7491   emit_operand32(rdi, adr);
7492 }
7493 
7494 void Assembler::fistp_s(Address adr) {
7495   InstructionMark im(this);
7496   emit_int8((unsigned char)0xDB);
7497   emit_operand32(rbx, adr);
7498 }
7499 
7500 void Assembler::fld1() {
<span class="line-modified">7501   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">7502   emit_int8((unsigned char)0xE8);</span>
7503 }
7504 
7505 void Assembler::fld_d(Address adr) {
7506   InstructionMark im(this);
7507   emit_int8((unsigned char)0xDD);
7508   emit_operand32(rax, adr);
7509 }
7510 
7511 void Assembler::fld_s(Address adr) {
7512   InstructionMark im(this);
7513   emit_int8((unsigned char)0xD9);
7514   emit_operand32(rax, adr);
7515 }
7516 
7517 
7518 void Assembler::fld_s(int index) {
7519   emit_farith(0xD9, 0xC0, index);
7520 }
7521 
7522 void Assembler::fld_x(Address adr) {
7523   InstructionMark im(this);
7524   emit_int8((unsigned char)0xDB);
7525   emit_operand32(rbp, adr);
7526 }
7527 
7528 void Assembler::fldcw(Address src) {
7529   InstructionMark im(this);
7530   emit_int8((unsigned char)0xD9);
7531   emit_operand32(rbp, src);
7532 }
7533 
7534 void Assembler::fldenv(Address src) {
7535   InstructionMark im(this);
7536   emit_int8((unsigned char)0xD9);
7537   emit_operand32(rsp, src);
7538 }
7539 
7540 void Assembler::fldlg2() {
<span class="line-modified">7541   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">7542   emit_int8((unsigned char)0xEC);</span>
7543 }
7544 
7545 void Assembler::fldln2() {
<span class="line-modified">7546   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">7547   emit_int8((unsigned char)0xED);</span>
7548 }
7549 
7550 void Assembler::fldz() {
<span class="line-modified">7551   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">7552   emit_int8((unsigned char)0xEE);</span>
7553 }
7554 
7555 void Assembler::flog() {
7556   fldln2();
7557   fxch();
7558   fyl2x();
7559 }
7560 
7561 void Assembler::flog10() {
7562   fldlg2();
7563   fxch();
7564   fyl2x();
7565 }
7566 
7567 void Assembler::fmul(int i) {
7568   emit_farith(0xD8, 0xC8, i);
7569 }
7570 
7571 void Assembler::fmul_d(Address src) {
7572   InstructionMark im(this);
</pre>
<hr />
<pre>
7579   emit_int8((unsigned char)0xD8);
7580   emit_operand32(rcx, src);
7581 }
7582 
7583 void Assembler::fmula(int i) {
7584   emit_farith(0xDC, 0xC8, i);
7585 }
7586 
7587 void Assembler::fmulp(int i) {
7588   emit_farith(0xDE, 0xC8, i);
7589 }
7590 
7591 void Assembler::fnsave(Address dst) {
7592   InstructionMark im(this);
7593   emit_int8((unsigned char)0xDD);
7594   emit_operand32(rsi, dst);
7595 }
7596 
7597 void Assembler::fnstcw(Address src) {
7598   InstructionMark im(this);
<span class="line-modified">7599   emit_int8((unsigned char)0x9B);</span>
<span class="line-removed">7600   emit_int8((unsigned char)0xD9);</span>
7601   emit_operand32(rdi, src);
7602 }
7603 
7604 void Assembler::fnstsw_ax() {
<span class="line-modified">7605   emit_int8((unsigned char)0xDF);</span>
<span class="line-removed">7606   emit_int8((unsigned char)0xE0);</span>
7607 }
7608 
7609 void Assembler::fprem() {
<span class="line-modified">7610   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">7611   emit_int8((unsigned char)0xF8);</span>
7612 }
7613 
7614 void Assembler::fprem1() {
<span class="line-modified">7615   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">7616   emit_int8((unsigned char)0xF5);</span>
7617 }
7618 
7619 void Assembler::frstor(Address src) {
7620   InstructionMark im(this);
7621   emit_int8((unsigned char)0xDD);
7622   emit_operand32(rsp, src);
7623 }
7624 
7625 void Assembler::fsin() {
<span class="line-modified">7626   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">7627   emit_int8((unsigned char)0xFE);</span>
7628 }
7629 
7630 void Assembler::fsqrt() {
<span class="line-modified">7631   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">7632   emit_int8((unsigned char)0xFA);</span>
7633 }
7634 
7635 void Assembler::fst_d(Address adr) {
7636   InstructionMark im(this);
7637   emit_int8((unsigned char)0xDD);
7638   emit_operand32(rdx, adr);
7639 }
7640 
7641 void Assembler::fst_s(Address adr) {
7642   InstructionMark im(this);
7643   emit_int8((unsigned char)0xD9);
7644   emit_operand32(rdx, adr);
7645 }
7646 
7647 void Assembler::fstp_d(Address adr) {
7648   InstructionMark im(this);
7649   emit_int8((unsigned char)0xDD);
7650   emit_operand32(rbx, adr);
7651 }
7652 
</pre>
<hr />
<pre>
7698   InstructionMark im(this);
7699   emit_int8((unsigned char)0xDC);
7700   emit_operand32(rbp, src);
7701 }
7702 
7703 void Assembler::fsubr_s(Address src) {
7704   InstructionMark im(this);
7705   emit_int8((unsigned char)0xD8);
7706   emit_operand32(rbp, src);
7707 }
7708 
7709 void Assembler::fsubra(int i) {
7710   emit_farith(0xDC, 0xE0, i);
7711 }
7712 
7713 void Assembler::fsubrp(int i) {
7714   emit_farith(0xDE, 0xE0, i);                    // ST(0) &lt;- ST(1) - ST(0) and pop (Intel manual wrong)
7715 }
7716 
7717 void Assembler::ftan() {
<span class="line-modified">7718   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">7719   emit_int8((unsigned char)0xF2);</span>
<span class="line-removed">7720   emit_int8((unsigned char)0xDD);</span>
<span class="line-removed">7721   emit_int8((unsigned char)0xD8);</span>
7722 }
7723 
7724 void Assembler::ftst() {
<span class="line-modified">7725   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">7726   emit_int8((unsigned char)0xE4);</span>
7727 }
7728 
7729 void Assembler::fucomi(int i) {
7730   // make sure the instruction is supported (introduced for P6, together with cmov)
7731   guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;);
7732   emit_farith(0xDB, 0xE8, i);
7733 }
7734 
7735 void Assembler::fucomip(int i) {
7736   // make sure the instruction is supported (introduced for P6, together with cmov)
7737   guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;);
7738   emit_farith(0xDF, 0xE8, i);
7739 }
7740 
7741 void Assembler::fwait() {
7742   emit_int8((unsigned char)0x9B);
7743 }
7744 
7745 void Assembler::fxch(int i) {
7746   emit_farith(0xD9, 0xC8, i);
7747 }
7748 
7749 void Assembler::fyl2x() {
<span class="line-modified">7750   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">7751   emit_int8((unsigned char)0xF1);</span>
7752 }
7753 
7754 void Assembler::frndint() {
<span class="line-modified">7755   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">7756   emit_int8((unsigned char)0xFC);</span>
7757 }
7758 
7759 void Assembler::f2xm1() {
<span class="line-modified">7760   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">7761   emit_int8((unsigned char)0xF0);</span>
7762 }
7763 
7764 void Assembler::fldl2e() {
<span class="line-modified">7765   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">7766   emit_int8((unsigned char)0xEA);</span>
7767 }
7768 #endif // !_LP64
7769 
7770 // SSE SIMD prefix byte values corresponding to VexSimdPrefix encoding.
7771 static int simd_pre[4] = { 0, 0x66, 0xF3, 0xF2 };
7772 // SSE opcode second byte values (first is 0x0F) corresponding to VexOpcode encoding.
7773 static int simd_opc[4] = { 0,    0, 0x38, 0x3A };
7774 
7775 // Generate SSE legacy REX prefix and SIMD opcode based on VEX encoding.
7776 void Assembler::rex_prefix(Address adr, XMMRegister xreg, VexSimdPrefix pre, VexOpcode opc, bool rex_w) {
7777   if (pre &gt; 0) {
7778     emit_int8(simd_pre[pre]);
7779   }
7780   if (rex_w) {
7781     prefixq(adr, xreg);
7782   } else {
7783     prefix(adr, xreg);
7784   }
7785   if (opc &gt; 0) {
7786     emit_int8(0x0F);
</pre>
<hr />
<pre>
7794 int Assembler::rex_prefix_and_encode(int dst_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, bool rex_w) {
7795   if (pre &gt; 0) {
7796     emit_int8(simd_pre[pre]);
7797   }
7798   int encode = (rex_w) ? prefixq_and_encode(dst_enc, src_enc) : prefix_and_encode(dst_enc, src_enc);
7799   if (opc &gt; 0) {
7800     emit_int8(0x0F);
7801     int opc2 = simd_opc[opc];
7802     if (opc2 &gt; 0) {
7803       emit_int8(opc2);
7804     }
7805   }
7806   return encode;
7807 }
7808 
7809 
7810 void Assembler::vex_prefix(bool vex_r, bool vex_b, bool vex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc) {
7811   int vector_len = _attributes-&gt;get_vector_len();
7812   bool vex_w = _attributes-&gt;is_rex_vex_w();
7813   if (vex_b || vex_x || vex_w || (opc == VEX_OPCODE_0F_38) || (opc == VEX_OPCODE_0F_3A)) {
<span class="line-removed">7814     prefix(VEX_3bytes);</span>
<span class="line-removed">7815 </span>
7816     int byte1 = (vex_r ? VEX_R : 0) | (vex_x ? VEX_X : 0) | (vex_b ? VEX_B : 0);
7817     byte1 = (~byte1) &amp; 0xE0;
7818     byte1 |= opc;
<span class="line-removed">7819     emit_int8(byte1);</span>
7820 
7821     int byte2 = ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
7822     byte2 |= (vex_w ? VEX_W : 0) | ((vector_len &gt; 0) ? 4 : 0) | pre;
<span class="line-removed">7823     emit_int8(byte2);</span>
<span class="line-removed">7824   } else {</span>
<span class="line-removed">7825     prefix(VEX_2bytes);</span>
7826 


7827     int byte1 = vex_r ? VEX_R : 0;
7828     byte1 = (~byte1) &amp; 0x80;
7829     byte1 |= ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
7830     byte1 |= ((vector_len &gt; 0 ) ? 4 : 0) | pre;
<span class="line-modified">7831     emit_int8(byte1);</span>
7832   }
7833 }
7834 
7835 // This is a 4 byte encoding
7836 void Assembler::evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_v, int nds_enc, VexSimdPrefix pre, VexOpcode opc){
7837   // EVEX 0x62 prefix
<span class="line-modified">7838   prefix(EVEX_4bytes);</span>

7839   bool vex_w = _attributes-&gt;is_rex_vex_w();
7840   int evex_encoding = (vex_w ? VEX_W : 0);
7841   // EVEX.b is not currently used for broadcast of single element or data rounding modes
7842   _attributes-&gt;set_evex_encoding(evex_encoding);
7843 
7844   // P0: byte 2, initialized to RXBR`00mm
7845   // instead of not&#39;d
7846   int byte2 = (vex_r ? VEX_R : 0) | (vex_x ? VEX_X : 0) | (vex_b ? VEX_B : 0) | (evex_r ? EVEX_Rb : 0);
7847   byte2 = (~byte2) &amp; 0xF0;
7848   // confine opc opcode extensions in mm bits to lower two bits
7849   // of form {0F, 0F_38, 0F_3A}
7850   byte2 |= opc;
<span class="line-removed">7851   emit_int8(byte2);</span>
7852 
7853   // P1: byte 3 as Wvvvv1pp
7854   int byte3 = ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
7855   // p[10] is always 1
7856   byte3 |= EVEX_F;
7857   byte3 |= (vex_w &amp; 1) &lt;&lt; 7;
7858   // confine pre opcode extensions in pp bits to lower two bits
7859   // of form {66, F3, F2}
7860   byte3 |= pre;
<span class="line-removed">7861   emit_int8(byte3);</span>
7862 
7863   // P2: byte 4 as zL&#39;Lbv&#39;aaa
7864   // kregs are implemented in the low 3 bits as aaa
7865   int byte4 = (_attributes-&gt;is_no_reg_mask()) ?
7866               0 :
7867               _attributes-&gt;get_embedded_opmask_register_specifier();
7868   // EVEX.v` for extending EVEX.vvvv or VIDX
7869   byte4 |= (evex_v ? 0: EVEX_V);
7870   // third EXEC.b for broadcast actions
7871   byte4 |= (_attributes-&gt;is_extended_context() ? EVEX_Rb : 0);
7872   // fourth EVEX.L&#39;L for vector length : 0 is 128, 1 is 256, 2 is 512, currently we do not support 1024
7873   byte4 |= ((_attributes-&gt;get_vector_len())&amp; 0x3) &lt;&lt; 5;
7874   // last is EVEX.z for zero/merge actions
7875   if (_attributes-&gt;is_no_reg_mask() == false) {
7876     byte4 |= (_attributes-&gt;is_clear_context() ? EVEX_Z : 0);
7877   }
<span class="line-modified">7878   emit_int8(byte4);</span>

7879 }
7880 
7881 void Assembler::vex_prefix(Address adr, int nds_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes) {
<span class="line-modified">7882   bool vex_r = ((xreg_enc &amp; 8) == 8) ? 1 : 0;</span>
7883   bool vex_b = adr.base_needs_rex();
7884   bool vex_x;
7885   if (adr.isxmmindex()) {
7886     vex_x = adr.xmmindex_needs_rex();
7887   } else {
7888     vex_x = adr.index_needs_rex();
7889   }
7890   set_attributes(attributes);
7891   attributes-&gt;set_current_assembler(this);
7892 
7893   // For EVEX instruction (which is not marked as pure EVEX instruction) check and see if this instruction
7894   // is allowed in legacy mode and has resources which will fit in it.
7895   // Pure EVEX instructions will have is_evex_instruction set in their definition.
7896   if (!attributes-&gt;is_legacy_mode()) {
<span class="line-modified">7897     if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_evex_instruction() &amp;&amp; !_is_managed) {</span>
7898       if ((attributes-&gt;get_vector_len() != AVX_512bit) &amp;&amp; (nds_enc &lt; 16) &amp;&amp; (xreg_enc &lt; 16)) {
7899           attributes-&gt;set_is_legacy_mode();
7900       }
7901     }
7902   }
7903 
7904   if (UseAVX &gt; 2) {
7905     assert(((!attributes-&gt;uses_vl()) ||
7906             (attributes-&gt;get_vector_len() == AVX_512bit) ||
7907             (!_legacy_mode_vl) ||
7908             (attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
7909     assert(((nds_enc &lt; 16 &amp;&amp; xreg_enc &lt; 16) || (!attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
7910   }
7911 
<span class="line-modified">7912   _is_managed = false;</span>
7913   if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_legacy_mode())
7914   {
7915     bool evex_r = (xreg_enc &gt;= 16);
7916     bool evex_v;
7917     // EVEX.V&#39; is set to true when VSIB is used as we may need to use higher order XMM registers (16-31)
7918     if (adr.isxmmindex())  {
7919       evex_v = ((adr._xmmindex-&gt;encoding() &gt; 15) ? true : false);
7920     } else {
7921       evex_v = (nds_enc &gt;= 16);
7922     }
7923     attributes-&gt;set_is_evex_instruction();
7924     evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_v, nds_enc, pre, opc);
7925   } else {
7926     if (UseAVX &gt; 2 &amp;&amp; attributes-&gt;is_rex_vex_w_reverted()) {
7927       attributes-&gt;set_rex_vex_w(false);
7928     }
7929     vex_prefix(vex_r, vex_b, vex_x, nds_enc, pre, opc);
7930   }
7931 }
7932 
7933 int Assembler::vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes) {
<span class="line-modified">7934   bool vex_r = ((dst_enc &amp; 8) == 8) ? 1 : 0;</span>
<span class="line-modified">7935   bool vex_b = ((src_enc &amp; 8) == 8) ? 1 : 0;</span>
7936   bool vex_x = false;
7937   set_attributes(attributes);
7938   attributes-&gt;set_current_assembler(this);
7939 
7940   // For EVEX instruction (which is not marked as pure EVEX instruction) check and see if this instruction
7941   // is allowed in legacy mode and has resources which will fit in it.
7942   // Pure EVEX instructions will have is_evex_instruction set in their definition.
7943   if (!attributes-&gt;is_legacy_mode()) {
<span class="line-modified">7944     if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_evex_instruction() &amp;&amp; !_is_managed) {</span>
7945       if ((!attributes-&gt;uses_vl() || (attributes-&gt;get_vector_len() != AVX_512bit)) &amp;&amp;
7946           (dst_enc &lt; 16) &amp;&amp; (nds_enc &lt; 16) &amp;&amp; (src_enc &lt; 16)) {
7947           attributes-&gt;set_is_legacy_mode();
7948       }
7949     }
7950   }
7951 
7952   if (UseAVX &gt; 2) {
7953     // All the scalar fp instructions (with uses_vl as false) can have legacy_mode as false
7954     // Instruction with uses_vl true are vector instructions
7955     // All the vector instructions with AVX_512bit length can have legacy_mode as false
7956     // All the vector instructions with &lt; AVX_512bit length can have legacy_mode as false if AVX512vl() is supported
7957     // Rest all should have legacy_mode set as true
7958     assert(((!attributes-&gt;uses_vl()) ||
7959             (attributes-&gt;get_vector_len() == AVX_512bit) ||
7960             (!_legacy_mode_vl) ||
7961             (attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
7962     // Instruction with legacy_mode true should have dst, nds and src &lt; 15
7963     assert(((dst_enc &lt; 16 &amp;&amp; nds_enc &lt; 16 &amp;&amp; src_enc &lt; 16) || (!attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
7964   }
7965 
<span class="line-modified">7966   _is_managed = false;</span>
7967   if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_legacy_mode())
7968   {
7969     bool evex_r = (dst_enc &gt;= 16);
7970     bool evex_v = (nds_enc &gt;= 16);
7971     // can use vex_x as bank extender on rm encoding
7972     vex_x = (src_enc &gt;= 16);
7973     attributes-&gt;set_is_evex_instruction();
7974     evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_v, nds_enc, pre, opc);
7975   } else {
7976     if (UseAVX &gt; 2 &amp;&amp; attributes-&gt;is_rex_vex_w_reverted()) {
7977       attributes-&gt;set_rex_vex_w(false);
7978     }
7979     vex_prefix(vex_r, vex_b, vex_x, nds_enc, pre, opc);
7980   }
7981 
7982   // return modrm byte components for operands
7983   return (((dst_enc &amp; 7) &lt;&lt; 3) | (src_enc &amp; 7));
7984 }
7985 
7986 
</pre>
<hr />
<pre>
7996   }
7997 }
7998 
7999 int Assembler::simd_prefix_and_encode(XMMRegister dst, XMMRegister nds, XMMRegister src, VexSimdPrefix pre,
8000                                       VexOpcode opc, InstructionAttr *attributes) {
8001   int dst_enc = dst-&gt;encoding();
8002   int src_enc = src-&gt;encoding();
8003   if (UseAVX &gt; 0) {
8004     int nds_enc = nds-&gt;is_valid() ? nds-&gt;encoding() : 0;
8005     return vex_prefix_and_encode(dst_enc, nds_enc, src_enc, pre, opc, attributes);
8006   } else {
8007     assert((nds == dst) || (nds == src) || (nds == xnoreg), &quot;wrong sse encoding&quot;);
8008     return rex_prefix_and_encode(dst_enc, src_enc, pre, opc, attributes-&gt;is_rex_vex_w());
8009   }
8010 }
8011 
8012 void Assembler::vmaxss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
8013   assert(VM_Version::supports_avx(), &quot;&quot;);
8014   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8015   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">8016   emit_int8(0x5F);</span>
<span class="line-removed">8017   emit_int8((unsigned char)(0xC0 | encode));</span>
8018 }
8019 
8020 void Assembler::vmaxsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
8021   assert(VM_Version::supports_avx(), &quot;&quot;);
8022   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8023   attributes.set_rex_vex_w_reverted();
8024   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">8025   emit_int8(0x5F);</span>
<span class="line-removed">8026   emit_int8((unsigned char)(0xC0 | encode));</span>
8027 }
8028 
8029 void Assembler::vminss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
8030   assert(VM_Version::supports_avx(), &quot;&quot;);
8031   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8032   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">8033   emit_int8(0x5D);</span>
<span class="line-removed">8034   emit_int8((unsigned char)(0xC0 | encode));</span>
8035 }
8036 
8037 void Assembler::vminsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
8038   assert(VM_Version::supports_avx(), &quot;&quot;);
8039   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8040   attributes.set_rex_vex_w_reverted();
8041   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">8042   emit_int8(0x5D);</span>
<span class="line-removed">8043   emit_int8((unsigned char)(0xC0 | encode));</span>
8044 }
8045 
8046 void Assembler::cmppd(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len) {
8047   assert(VM_Version::supports_avx(), &quot;&quot;);
8048   assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
8049   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
8050   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">8051   emit_int8((unsigned char)0xC2);</span>
<span class="line-removed">8052   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">8053   emit_int8((unsigned char)(0xF &amp; cop));</span>
8054 }
8055 
8056 void Assembler::blendvpd(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len) {
8057   assert(VM_Version::supports_avx(), &quot;&quot;);
8058   assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
8059   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
8060   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-removed">8061   emit_int8((unsigned char)0x4B);</span>
<span class="line-removed">8062   emit_int8((unsigned char)(0xC0 | encode));</span>
8063   int src2_enc = src2-&gt;encoding();
<span class="line-modified">8064   emit_int8((unsigned char)(0xF0 &amp; src2_enc&lt;&lt;4));</span>
8065 }
8066 
8067 void Assembler::cmpps(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len) {
8068   assert(VM_Version::supports_avx(), &quot;&quot;);
8069   assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
8070   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
8071   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">8072   emit_int8((unsigned char)0xC2);</span>
<span class="line-removed">8073   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">8074   emit_int8((unsigned char)(0xF &amp; cop));</span>
8075 }
8076 
8077 void Assembler::blendvps(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len) {
8078   assert(VM_Version::supports_avx(), &quot;&quot;);
8079   assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
8080   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
8081   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-removed">8082   emit_int8((unsigned char)0x4A);</span>
<span class="line-removed">8083   emit_int8((unsigned char)(0xC0 | encode));</span>
8084   int src2_enc = src2-&gt;encoding();
<span class="line-modified">8085   emit_int8((unsigned char)(0xF0 &amp; src2_enc&lt;&lt;4));</span>
8086 }
8087 
8088 void Assembler::vpblendd(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {
8089   assert(VM_Version::supports_avx2(), &quot;&quot;);
8090   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
8091   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">8092   emit_int8((unsigned char)0x02);</span>
<span class="line-removed">8093   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">8094   emit_int8((unsigned char)imm8);</span>
8095 }
8096 
8097 void Assembler::shlxl(Register dst, Register src1, Register src2) {
8098   assert(VM_Version::supports_bmi2(), &quot;&quot;);
8099   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
8100   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src2-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">8101   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">8102   emit_int8((unsigned char)(0xC0 | encode));</span>
8103 }
8104 
8105 void Assembler::shlxq(Register dst, Register src1, Register src2) {
8106   assert(VM_Version::supports_bmi2(), &quot;&quot;);
8107   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
8108   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src2-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">8109   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">8110   emit_int8((unsigned char)(0xC0 | encode));</span>
8111 }
8112 
8113 #ifndef _LP64
8114 
8115 void Assembler::incl(Register dst) {
8116   // Don&#39;t use it directly. Use MacroAssembler::incrementl() instead.
8117   emit_int8(0x40 | dst-&gt;encoding());
8118 }
8119 
8120 void Assembler::lea(Register dst, Address src) {
8121   leal(dst, src);
8122 }
8123 
8124 void Assembler::mov_literal32(Address dst, int32_t imm32, RelocationHolder const&amp; rspec) {
8125   InstructionMark im(this);
8126   emit_int8((unsigned char)0xC7);
8127   emit_operand(rax, dst);
8128   emit_data((int)imm32, rspec, 0);
8129 }
8130 
8131 void Assembler::mov_literal32(Register dst, int32_t imm32, RelocationHolder const&amp; rspec) {
8132   InstructionMark im(this);
8133   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">8134   emit_int8((unsigned char)(0xB8 | encode));</span>
8135   emit_data((int)imm32, rspec, 0);
8136 }
8137 
8138 void Assembler::popa() { // 32bit
8139   emit_int8(0x61);
8140 }
8141 
8142 void Assembler::push_literal32(int32_t imm32, RelocationHolder const&amp; rspec) {
8143   InstructionMark im(this);
8144   emit_int8(0x68);
8145   emit_data(imm32, rspec, 0);
8146 }
8147 
8148 void Assembler::pusha() { // 32bit
8149   emit_int8(0x60);
8150 }
8151 
8152 void Assembler::set_byte_if_not_zero(Register dst) {
<span class="line-modified">8153   emit_int8(0x0F);</span>
<span class="line-removed">8154   emit_int8((unsigned char)0x95);</span>
<span class="line-removed">8155   emit_int8((unsigned char)(0xE0 | dst-&gt;encoding()));</span>
8156 }
8157 
8158 #else // LP64
8159 
8160 void Assembler::set_byte_if_not_zero(Register dst) {
8161   int enc = prefix_and_encode(dst-&gt;encoding(), true);
<span class="line-modified">8162   emit_int8(0x0F);</span>
<span class="line-removed">8163   emit_int8((unsigned char)0x95);</span>
<span class="line-removed">8164   emit_int8((unsigned char)(0xE0 | enc));</span>
8165 }
8166 
8167 // 64bit only pieces of the assembler
8168 // This should only be used by 64bit instructions that can use rip-relative
8169 // it cannot be used by instructions that want an immediate value.
8170 
8171 bool Assembler::reachable(AddressLiteral adr) {
8172   int64_t disp;


8173   // None will force a 64bit literal to the code stream. Likely a placeholder
8174   // for something that will be patched later and we need to certain it will
8175   // always be reachable.
<span class="line-modified">8176   if (adr.reloc() == relocInfo::none) {</span>
8177     return false;
8178   }
<span class="line-modified">8179   if (adr.reloc() == relocInfo::internal_word_type) {</span>
8180     // This should be rip relative and easily reachable.
8181     return true;
8182   }
<span class="line-modified">8183   if (adr.reloc() == relocInfo::virtual_call_type ||</span>
<span class="line-modified">8184       adr.reloc() == relocInfo::opt_virtual_call_type ||</span>
<span class="line-modified">8185       adr.reloc() == relocInfo::static_call_type ||</span>
<span class="line-modified">8186       adr.reloc() == relocInfo::static_stub_type ) {</span>
8187     // This should be rip relative within the code cache and easily
8188     // reachable until we get huge code caches. (At which point
8189     // ic code is going to have issues).
8190     return true;
8191   }
<span class="line-modified">8192   if (adr.reloc() != relocInfo::external_word_type &amp;&amp;</span>
<span class="line-modified">8193       adr.reloc() != relocInfo::poll_return_type &amp;&amp;  // these are really external_word but need special</span>
<span class="line-modified">8194       adr.reloc() != relocInfo::poll_type &amp;&amp;         // relocs to identify them</span>
<span class="line-modified">8195       adr.reloc() != relocInfo::runtime_call_type ) {</span>
8196     return false;
8197   }
8198 
8199   // Stress the correction code
8200   if (ForceUnreachable) {
8201     // Must be runtimecall reloc, see if it is in the codecache
8202     // Flipping stuff in the codecache to be unreachable causes issues
8203     // with things like inline caches where the additional instructions
8204     // are not handled.
8205     if (CodeCache::find_blob(adr._target) == NULL) {
8206       return false;
8207     }
8208   }
8209   // For external_word_type/runtime_call_type if it is reachable from where we
8210   // are now (possibly a temp buffer) and where we might end up
8211   // anywhere in the codeCache then we are always reachable.
8212   // This would have to change if we ever save/restore shared code
8213   // to be more pessimistic.
8214   disp = (int64_t)adr._target - ((int64_t)CodeCache::low_bound() + sizeof(int));
8215   if (!is_simm32(disp)) return false;
</pre>
<hr />
<pre>
8251   } else {
8252     emit_data64(data, Relocation::spec_simple(rtype), format);
8253   }
8254 }
8255 
8256 void Assembler::emit_data64(jlong data,
8257                             RelocationHolder const&amp; rspec,
8258                             int format) {
8259   assert(imm_operand == 0, &quot;default format must be immediate in this file&quot;);
8260   assert(imm_operand == format, &quot;must be immediate&quot;);
8261   assert(inst_mark() != NULL, &quot;must be inside InstructionMark&quot;);
8262   // Do not use AbstractAssembler::relocate, which is not intended for
8263   // embedded words.  Instead, relocate to the enclosing instruction.
8264   code_section()-&gt;relocate(inst_mark(), rspec, format);
8265 #ifdef ASSERT
8266   check_relocation(rspec, format);
8267 #endif
8268   emit_int64(data);
8269 }
8270 
<span class="line-modified">8271 int Assembler::prefix_and_encode(int reg_enc, bool byteinst) {</span>
<span class="line-modified">8272   if (reg_enc &gt;= 8) {</span>
8273     prefix(REX_B);
<span class="line-removed">8274     reg_enc -= 8;</span>
<span class="line-removed">8275   } else if (byteinst &amp;&amp; reg_enc &gt;= 4) {</span>
<span class="line-removed">8276     prefix(REX);</span>
8277   }
<span class="line-removed">8278   return reg_enc;</span>
8279 }
8280 
<span class="line-modified">8281 int Assembler::prefixq_and_encode(int reg_enc) {</span>
<span class="line-modified">8282   if (reg_enc &lt; 8) {</span>
<span class="line-modified">8283     prefix(REX_W);</span>
<span class="line-modified">8284   } else {</span>
<span class="line-modified">8285     prefix(REX_WB);</span>
<span class="line-modified">8286     reg_enc -= 8;</span>




8287   }
<span class="line-removed">8288   return reg_enc;</span>
8289 }
8290 
<span class="line-modified">8291 int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte) {</span>
<span class="line-modified">8292   if (dst_enc &lt; 8) {</span>
<span class="line-modified">8293     if (src_enc &gt;= 8) {</span>


8294       prefix(REX_B);
<span class="line-removed">8295       src_enc -= 8;</span>
<span class="line-removed">8296     } else if ((src_is_byte &amp;&amp; src_enc &gt;= 4) || (dst_is_byte &amp;&amp; dst_enc &gt;= 4)) {</span>
<span class="line-removed">8297       prefix(REX);</span>
8298     }
8299   } else {
<span class="line-modified">8300     if (src_enc &lt; 8) {</span>
<span class="line-modified">8301       prefix(REX_R);</span>
<span class="line-removed">8302     } else {</span>
<span class="line-removed">8303       prefix(REX_RB);</span>
<span class="line-removed">8304       src_enc -= 8;</span>
8305     }
<span class="line-modified">8306     dst_enc -= 8;</span>
<span class="line-modified">8307   }</span>
<span class="line-modified">8308   return dst_enc &lt;&lt; 3 | src_enc;</span>
<span class="line-modified">8309 }</span>
<span class="line-modified">8310 </span>
<span class="line-modified">8311 int Assembler::prefixq_and_encode(int dst_enc, int src_enc) {</span>
<span class="line-modified">8312   if (dst_enc &lt; 8) {</span>
<span class="line-removed">8313     if (src_enc &lt; 8) {</span>
<span class="line-removed">8314       prefix(REX_W);</span>
<span class="line-removed">8315     } else {</span>
<span class="line-removed">8316       prefix(REX_WB);</span>
<span class="line-removed">8317       src_enc -= 8;</span>
<span class="line-removed">8318     }</span>
<span class="line-removed">8319   } else {</span>
<span class="line-removed">8320     if (src_enc &lt; 8) {</span>
<span class="line-removed">8321       prefix(REX_WR);</span>
<span class="line-removed">8322     } else {</span>
<span class="line-removed">8323       prefix(REX_WRB);</span>
<span class="line-removed">8324       src_enc -= 8;</span>
<span class="line-removed">8325     }</span>
<span class="line-removed">8326     dst_enc -= 8;</span>
<span class="line-removed">8327   }</span>
<span class="line-removed">8328   return dst_enc &lt;&lt; 3 | src_enc;</span>
<span class="line-removed">8329 }</span>
<span class="line-removed">8330 </span>
<span class="line-removed">8331 void Assembler::prefix(Register reg) {</span>
<span class="line-removed">8332   if (reg-&gt;encoding() &gt;= 8) {</span>
<span class="line-removed">8333     prefix(REX_B);</span>
<span class="line-removed">8334   }</span>
<span class="line-removed">8335 }</span>
<span class="line-removed">8336 </span>
<span class="line-removed">8337 void Assembler::prefix(Register dst, Register src, Prefix p) {</span>
<span class="line-removed">8338   if (src-&gt;encoding() &gt;= 8) {</span>
<span class="line-removed">8339     p = (Prefix)(p | REX_B);</span>
<span class="line-removed">8340   }</span>
<span class="line-removed">8341   if (dst-&gt;encoding() &gt;= 8) {</span>
<span class="line-removed">8342     p = (Prefix)( p | REX_R);</span>
<span class="line-removed">8343   }</span>
<span class="line-removed">8344   if (p != Prefix_EMPTY) {</span>
<span class="line-removed">8345     // do not generate an empty prefix</span>
<span class="line-removed">8346     prefix(p);</span>
<span class="line-removed">8347   }</span>
<span class="line-removed">8348 }</span>
<span class="line-removed">8349 </span>
<span class="line-removed">8350 void Assembler::prefix(Register dst, Address adr, Prefix p) {</span>
<span class="line-removed">8351   if (adr.base_needs_rex()) {</span>
<span class="line-removed">8352     if (adr.index_needs_rex()) {</span>
<span class="line-removed">8353       assert(false, &quot;prefix(Register dst, Address adr, Prefix p) does not support handling of an X&quot;);</span>
<span class="line-removed">8354     } else {</span>
<span class="line-removed">8355       prefix(REX_B);</span>
<span class="line-removed">8356     }</span>
<span class="line-removed">8357   } else {</span>
<span class="line-removed">8358     if (adr.index_needs_rex()) {</span>
<span class="line-removed">8359       assert(false, &quot;prefix(Register dst, Address adr, Prefix p) does not support handling of an X&quot;);</span>
<span class="line-removed">8360     }</span>
<span class="line-removed">8361   }</span>
<span class="line-removed">8362   if (dst-&gt;encoding() &gt;= 8) {</span>
<span class="line-removed">8363     p = (Prefix)(p | REX_R);</span>
<span class="line-removed">8364   }</span>
<span class="line-removed">8365   if (p != Prefix_EMPTY) {</span>
<span class="line-removed">8366     // do not generate an empty prefix</span>
<span class="line-removed">8367     prefix(p);</span>
8368   }
8369 }
8370 
8371 void Assembler::prefix(Address adr) {
8372   if (adr.base_needs_rex()) {
8373     if (adr.index_needs_rex()) {
8374       prefix(REX_XB);
8375     } else {
8376       prefix(REX_B);
8377     }
8378   } else {
8379     if (adr.index_needs_rex()) {
8380       prefix(REX_X);
8381     }
8382   }
8383 }
8384 
<span class="line-removed">8385 void Assembler::prefixq(Address adr) {</span>
<span class="line-removed">8386   if (adr.base_needs_rex()) {</span>
<span class="line-removed">8387     if (adr.index_needs_rex()) {</span>
<span class="line-removed">8388       prefix(REX_WXB);</span>
<span class="line-removed">8389     } else {</span>
<span class="line-removed">8390       prefix(REX_WB);</span>
<span class="line-removed">8391     }</span>
<span class="line-removed">8392   } else {</span>
<span class="line-removed">8393     if (adr.index_needs_rex()) {</span>
<span class="line-removed">8394       prefix(REX_WX);</span>
<span class="line-removed">8395     } else {</span>
<span class="line-removed">8396       prefix(REX_W);</span>
<span class="line-removed">8397     }</span>
<span class="line-removed">8398   }</span>
<span class="line-removed">8399 }</span>
<span class="line-removed">8400 </span>
<span class="line-removed">8401 </span>
8402 void Assembler::prefix(Address adr, Register reg, bool byteinst) {
8403   if (reg-&gt;encoding() &lt; 8) {
8404     if (adr.base_needs_rex()) {
8405       if (adr.index_needs_rex()) {
8406         prefix(REX_XB);
8407       } else {
8408         prefix(REX_B);
8409       }
8410     } else {
8411       if (adr.index_needs_rex()) {
8412         prefix(REX_X);
<span class="line-modified">8413       } else if (byteinst &amp;&amp; reg-&gt;encoding() &gt;= 4 ) {</span>
8414         prefix(REX);
8415       }
8416     }
8417   } else {
8418     if (adr.base_needs_rex()) {
8419       if (adr.index_needs_rex()) {
8420         prefix(REX_RXB);
8421       } else {
8422         prefix(REX_RB);
8423       }
8424     } else {
8425       if (adr.index_needs_rex()) {
8426         prefix(REX_RX);
8427       } else {
8428         prefix(REX_R);
8429       }
8430     }
8431   }
8432 }
8433 
<span class="line-modified">8434 void Assembler::prefixq(Address adr, Register src) {</span>
<span class="line-modified">8435   if (src-&gt;encoding() &lt; 8) {</span>
8436     if (adr.base_needs_rex()) {
8437       if (adr.index_needs_rex()) {
<span class="line-modified">8438         prefix(REX_WXB);</span>
8439       } else {
<span class="line-modified">8440         prefix(REX_WB);</span>
8441       }
8442     } else {
8443       if (adr.index_needs_rex()) {
<span class="line-modified">8444         prefix(REX_WX);</span>
<span class="line-removed">8445       } else {</span>
<span class="line-removed">8446         prefix(REX_W);</span>
8447       }
8448     }
8449   } else {
8450     if (adr.base_needs_rex()) {
8451       if (adr.index_needs_rex()) {
<span class="line-modified">8452         prefix(REX_WRXB);</span>
8453       } else {
<span class="line-modified">8454         prefix(REX_WRB);</span>
8455       }
8456     } else {
8457       if (adr.index_needs_rex()) {
<span class="line-modified">8458         prefix(REX_WRX);</span>
8459       } else {
<span class="line-modified">8460         prefix(REX_WR);</span>
8461       }
8462     }
8463   }
8464 }
8465 
<span class="line-modified">8466 void Assembler::prefix(Address adr, XMMRegister reg) {</span>
<span class="line-modified">8467   if (reg-&gt;encoding() &lt; 8) {</span>









































8468     if (adr.base_needs_rex()) {
8469       if (adr.index_needs_rex()) {
<span class="line-modified">8470         prefix(REX_XB);</span>
8471       } else {
<span class="line-modified">8472         prefix(REX_B);</span>
8473       }
8474     } else {
8475       if (adr.index_needs_rex()) {
<span class="line-modified">8476         prefix(REX_X);</span>


8477       }
8478     }
8479   } else {
8480     if (adr.base_needs_rex()) {
8481       if (adr.index_needs_rex()) {
<span class="line-modified">8482         prefix(REX_RXB);</span>
8483       } else {
<span class="line-modified">8484         prefix(REX_RB);</span>
8485       }
8486     } else {
8487       if (adr.index_needs_rex()) {
<span class="line-modified">8488         prefix(REX_RX);</span>
8489       } else {
<span class="line-modified">8490         prefix(REX_R);</span>
8491       }
8492     }
8493   }










8494 }
8495 
8496 void Assembler::prefixq(Address adr, XMMRegister src) {
8497   if (src-&gt;encoding() &lt; 8) {
8498     if (adr.base_needs_rex()) {
8499       if (adr.index_needs_rex()) {
8500         prefix(REX_WXB);
8501       } else {
8502         prefix(REX_WB);
8503       }
8504     } else {
8505       if (adr.index_needs_rex()) {
8506         prefix(REX_WX);
8507       } else {
8508         prefix(REX_W);
8509       }
8510     }
8511   } else {
8512     if (adr.base_needs_rex()) {
8513       if (adr.index_needs_rex()) {
8514         prefix(REX_WRXB);
8515       } else {
8516         prefix(REX_WRB);
8517       }
8518     } else {
8519       if (adr.index_needs_rex()) {
8520         prefix(REX_WRX);
8521       } else {
8522         prefix(REX_WR);
8523       }
8524     }
8525   }
8526 }
8527 






























8528 void Assembler::adcq(Register dst, int32_t imm32) {
8529   (void) prefixq_and_encode(dst-&gt;encoding());
8530   emit_arith(0x81, 0xD0, dst, imm32);
8531 }
8532 
8533 void Assembler::adcq(Register dst, Address src) {
8534   InstructionMark im(this);
<span class="line-modified">8535   prefixq(src, dst);</span>
<span class="line-removed">8536   emit_int8(0x13);</span>
8537   emit_operand(dst, src);
8538 }
8539 
8540 void Assembler::adcq(Register dst, Register src) {
8541   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8542   emit_arith(0x13, 0xC0, dst, src);
8543 }
8544 
8545 void Assembler::addq(Address dst, int32_t imm32) {
8546   InstructionMark im(this);
8547   prefixq(dst);
<span class="line-modified">8548   emit_arith_operand(0x81, rax, dst,imm32);</span>
8549 }
8550 
8551 void Assembler::addq(Address dst, Register src) {
8552   InstructionMark im(this);
<span class="line-modified">8553   prefixq(dst, src);</span>
<span class="line-removed">8554   emit_int8(0x01);</span>
8555   emit_operand(src, dst);
8556 }
8557 
8558 void Assembler::addq(Register dst, int32_t imm32) {
8559   (void) prefixq_and_encode(dst-&gt;encoding());
8560   emit_arith(0x81, 0xC0, dst, imm32);
8561 }
8562 
8563 void Assembler::addq(Register dst, Address src) {
8564   InstructionMark im(this);
<span class="line-modified">8565   prefixq(src, dst);</span>
<span class="line-removed">8566   emit_int8(0x03);</span>
8567   emit_operand(dst, src);
8568 }
8569 
8570 void Assembler::addq(Register dst, Register src) {
8571   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8572   emit_arith(0x03, 0xC0, dst, src);
8573 }
8574 
8575 void Assembler::adcxq(Register dst, Register src) {
8576   //assert(VM_Version::supports_adx(), &quot;adx instructions not supported&quot;);
<span class="line-modified">8577   emit_int8((unsigned char)0x66);</span>
8578   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">8579   emit_int8(0x0F);</span>
<span class="line-modified">8580   emit_int8(0x38);</span>
<span class="line-modified">8581   emit_int8((unsigned char)0xF6);</span>
<span class="line-modified">8582   emit_int8((unsigned char)(0xC0 | encode));</span>
8583 }
8584 
8585 void Assembler::adoxq(Register dst, Register src) {
8586   //assert(VM_Version::supports_adx(), &quot;adx instructions not supported&quot;);
8587   emit_int8((unsigned char)0xF3);
8588   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">8589   emit_int8(0x0F);</span>
<span class="line-modified">8590   emit_int8(0x38);</span>
<span class="line-modified">8591   emit_int8((unsigned char)0xF6);</span>
<span class="line-modified">8592   emit_int8((unsigned char)(0xC0 | encode));</span>
8593 }
8594 
8595 void Assembler::andq(Address dst, int32_t imm32) {
8596   InstructionMark im(this);
<span class="line-modified">8597   prefixq(dst);</span>
<span class="line-removed">8598   emit_int8((unsigned char)0x81);</span>
8599   emit_operand(rsp, dst, 4);
8600   emit_int32(imm32);
8601 }
8602 
8603 void Assembler::andq(Register dst, int32_t imm32) {
8604   (void) prefixq_and_encode(dst-&gt;encoding());
8605   emit_arith(0x81, 0xE0, dst, imm32);
8606 }
8607 
8608 void Assembler::andq(Register dst, Address src) {
8609   InstructionMark im(this);
<span class="line-modified">8610   prefixq(src, dst);</span>
<span class="line-removed">8611   emit_int8(0x23);</span>
8612   emit_operand(dst, src);
8613 }
8614 
8615 void Assembler::andq(Register dst, Register src) {
8616   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8617   emit_arith(0x23, 0xC0, dst, src);
8618 }
8619 
8620 void Assembler::andnq(Register dst, Register src1, Register src2) {
8621   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8622   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8623   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">8624   emit_int8((unsigned char)0xF2);</span>
<span class="line-removed">8625   emit_int8((unsigned char)(0xC0 | encode));</span>
8626 }
8627 
8628 void Assembler::andnq(Register dst, Register src1, Address src2) {
8629   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8630   InstructionMark im(this);
8631   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8632   vex_prefix(src2, src1-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8633   emit_int8((unsigned char)0xF2);
8634   emit_operand(dst, src2);
8635 }
8636 
8637 void Assembler::bsfq(Register dst, Register src) {
8638   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">8639   emit_int8(0x0F);</span>
<span class="line-removed">8640   emit_int8((unsigned char)0xBC);</span>
<span class="line-removed">8641   emit_int8((unsigned char)(0xC0 | encode));</span>
8642 }
8643 
8644 void Assembler::bsrq(Register dst, Register src) {
8645   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">8646   emit_int8(0x0F);</span>
<span class="line-removed">8647   emit_int8((unsigned char)0xBD);</span>
<span class="line-removed">8648   emit_int8((unsigned char)(0xC0 | encode));</span>
8649 }
8650 
8651 void Assembler::bswapq(Register reg) {
8652   int encode = prefixq_and_encode(reg-&gt;encoding());
<span class="line-modified">8653   emit_int8(0x0F);</span>
<span class="line-removed">8654   emit_int8((unsigned char)(0xC8 | encode));</span>
8655 }
8656 
8657 void Assembler::blsiq(Register dst, Register src) {
8658   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8659   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8660   int encode = vex_prefix_and_encode(rbx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">8661   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">8662   emit_int8((unsigned char)(0xC0 | encode));</span>
8663 }
8664 
8665 void Assembler::blsiq(Register dst, Address src) {
8666   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8667   InstructionMark im(this);
8668   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8669   vex_prefix(src, dst-&gt;encoding(), rbx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8670   emit_int8((unsigned char)0xF3);
8671   emit_operand(rbx, src);
8672 }
8673 
8674 void Assembler::blsmskq(Register dst, Register src) {
8675   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8676   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8677   int encode = vex_prefix_and_encode(rdx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">8678   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">8679   emit_int8((unsigned char)(0xC0 | encode));</span>
8680 }
8681 
8682 void Assembler::blsmskq(Register dst, Address src) {
8683   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8684   InstructionMark im(this);
8685   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8686   vex_prefix(src, dst-&gt;encoding(), rdx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8687   emit_int8((unsigned char)0xF3);
8688   emit_operand(rdx, src);
8689 }
8690 
8691 void Assembler::blsrq(Register dst, Register src) {
8692   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8693   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8694   int encode = vex_prefix_and_encode(rcx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">8695   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">8696   emit_int8((unsigned char)(0xC0 | encode));</span>
8697 }
8698 
8699 void Assembler::blsrq(Register dst, Address src) {
8700   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8701   InstructionMark im(this);
8702   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8703   vex_prefix(src, dst-&gt;encoding(), rcx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8704   emit_int8((unsigned char)0xF3);
8705   emit_operand(rcx, src);
8706 }
8707 
8708 void Assembler::cdqq() {
<span class="line-modified">8709   prefix(REX_W);</span>
<span class="line-removed">8710   emit_int8((unsigned char)0x99);</span>
8711 }
8712 
8713 void Assembler::clflush(Address adr) {
8714   assert(VM_Version::supports_clflush(), &quot;should do&quot;);
8715   prefix(adr);
<span class="line-modified">8716   emit_int8(0x0F);</span>
<span class="line-removed">8717   emit_int8((unsigned char)0xAE);</span>
8718   emit_operand(rdi, adr);
8719 }
8720 
8721 void Assembler::clflushopt(Address adr) {
8722   assert(VM_Version::supports_clflushopt(), &quot;should do!&quot;);
8723   // adr should be base reg only with no index or offset
8724   assert(adr.index() == noreg, &quot;index should be noreg&quot;);
8725   assert(adr.scale() == Address::no_scale, &quot;scale should be no_scale&quot;);
8726   assert(adr.disp() == 0, &quot;displacement should be 0&quot;);
8727   // instruction prefix is 0x66
8728   emit_int8(0x66);
8729   prefix(adr);
<span class="line-modified">8730   // opcode family is 0x0f 0xAE</span>
<span class="line-modified">8731   emit_int8(0x0F);</span>
<span class="line-removed">8732   emit_int8((unsigned char)0xAE);</span>
8733   // extended opcode byte is 7 == rdi
8734   emit_operand(rdi, adr);
8735 }
8736 
8737 void Assembler::clwb(Address adr) {
8738   assert(VM_Version::supports_clwb(), &quot;should do!&quot;);
8739   // adr should be base reg only with no index or offset
8740   assert(adr.index() == noreg, &quot;index should be noreg&quot;);
8741   assert(adr.scale() == Address::no_scale, &quot;scale should be no_scale&quot;);
8742   assert(adr.disp() == 0, &quot;displacement should be 0&quot;);
8743   // instruction prefix is 0x66
8744   emit_int8(0x66);
8745   prefix(adr);
8746   // opcode family is 0x0f 0xAE
<span class="line-modified">8747   emit_int8(0x0F);</span>
<span class="line-removed">8748   emit_int8((unsigned char)0xAE);</span>
8749   // extended opcode byte is 6 == rsi
8750   emit_operand(rsi, adr);
8751 }
8752 
8753 void Assembler::cmovq(Condition cc, Register dst, Register src) {
8754   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">8755   emit_int8(0x0F);</span>
<span class="line-removed">8756   emit_int8(0x40 | cc);</span>
<span class="line-removed">8757   emit_int8((unsigned char)(0xC0 | encode));</span>
8758 }
8759 
8760 void Assembler::cmovq(Condition cc, Register dst, Address src) {
8761   InstructionMark im(this);
<span class="line-modified">8762   prefixq(src, dst);</span>
<span class="line-removed">8763   emit_int8(0x0F);</span>
<span class="line-removed">8764   emit_int8(0x40 | cc);</span>
8765   emit_operand(dst, src);
8766 }
8767 
8768 void Assembler::cmpq(Address dst, int32_t imm32) {
8769   InstructionMark im(this);
<span class="line-modified">8770   prefixq(dst);</span>
<span class="line-removed">8771   emit_int8((unsigned char)0x81);</span>
8772   emit_operand(rdi, dst, 4);
8773   emit_int32(imm32);
8774 }
8775 
8776 void Assembler::cmpq(Register dst, int32_t imm32) {
8777   (void) prefixq_and_encode(dst-&gt;encoding());
8778   emit_arith(0x81, 0xF8, dst, imm32);
8779 }
8780 
8781 void Assembler::cmpq(Address dst, Register src) {
8782   InstructionMark im(this);
<span class="line-modified">8783   prefixq(dst, src);</span>
<span class="line-removed">8784   emit_int8(0x3B);</span>
8785   emit_operand(src, dst);
8786 }
8787 
8788 void Assembler::cmpq(Register dst, Register src) {
8789   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8790   emit_arith(0x3B, 0xC0, dst, src);
8791 }
8792 
<span class="line-modified">8793 void Assembler::cmpq(Register dst, Address  src) {</span>
8794   InstructionMark im(this);
<span class="line-modified">8795   prefixq(src, dst);</span>
<span class="line-removed">8796   emit_int8(0x3B);</span>
8797   emit_operand(dst, src);
8798 }
8799 
8800 void Assembler::cmpxchgq(Register reg, Address adr) {
8801   InstructionMark im(this);
<span class="line-modified">8802   prefixq(adr, reg);</span>
<span class="line-removed">8803   emit_int8(0x0F);</span>
<span class="line-removed">8804   emit_int8((unsigned char)0xB1);</span>
8805   emit_operand(reg, adr);
8806 }
8807 
8808 void Assembler::cvtsi2sdq(XMMRegister dst, Register src) {
8809   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8810   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8811   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">8812   emit_int8(0x2A);</span>
<span class="line-removed">8813   emit_int8((unsigned char)(0xC0 | encode));</span>
8814 }
8815 
8816 void Assembler::cvtsi2sdq(XMMRegister dst, Address src) {
8817   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8818   InstructionMark im(this);
8819   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8820   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
8821   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
8822   emit_int8(0x2A);
8823   emit_operand(dst, src);
8824 }
8825 
8826 void Assembler::cvtsi2ssq(XMMRegister dst, Address src) {
8827   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
8828   InstructionMark im(this);
8829   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8830   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
8831   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
8832   emit_int8(0x2A);
8833   emit_operand(dst, src);
8834 }
8835 
8836 void Assembler::cvttsd2siq(Register dst, Address src) {
8837   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8838   // F2 REX.W 0F 2C /r
8839   // CVTTSD2SI r64, xmm1/m64
8840   InstructionMark im(this);
<span class="line-modified">8841   emit_int8((unsigned char)0xF2);</span>
<span class="line-removed">8842   prefix(REX_W);</span>
<span class="line-removed">8843   emit_int8(0x0F);</span>
<span class="line-removed">8844   emit_int8(0x2C);</span>
8845   emit_operand(dst, src);
8846 }
8847 
8848 void Assembler::cvttsd2siq(Register dst, XMMRegister src) {
8849   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8850   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8851   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">8852   emit_int8(0x2C);</span>
<span class="line-removed">8853   emit_int8((unsigned char)(0xC0 | encode));</span>
8854 }
8855 
8856 void Assembler::cvttss2siq(Register dst, XMMRegister src) {
8857   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
8858   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8859   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">8860   emit_int8(0x2C);</span>
<span class="line-removed">8861   emit_int8((unsigned char)(0xC0 | encode));</span>
8862 }
8863 
8864 void Assembler::decl(Register dst) {
8865   // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
8866   // Use two-byte form (one-byte form is a REX prefix in 64-bit mode)
8867   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">8868   emit_int8((unsigned char)0xFF);</span>
<span class="line-removed">8869   emit_int8((unsigned char)(0xC8 | encode));</span>
8870 }
8871 
8872 void Assembler::decq(Register dst) {
8873   // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
8874   // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
8875   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">8876   emit_int8((unsigned char)0xFF);</span>
<span class="line-removed">8877   emit_int8(0xC8 | encode);</span>
8878 }
8879 
8880 void Assembler::decq(Address dst) {
8881   // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
8882   InstructionMark im(this);
<span class="line-modified">8883   prefixq(dst);</span>
<span class="line-removed">8884   emit_int8((unsigned char)0xFF);</span>
8885   emit_operand(rcx, dst);
8886 }
8887 
8888 void Assembler::fxrstor(Address src) {
<span class="line-modified">8889   prefixq(src);</span>
<span class="line-removed">8890   emit_int8(0x0F);</span>
<span class="line-removed">8891   emit_int8((unsigned char)0xAE);</span>
8892   emit_operand(as_Register(1), src);
8893 }
8894 
8895 void Assembler::xrstor(Address src) {
<span class="line-modified">8896   prefixq(src);</span>
<span class="line-removed">8897   emit_int8(0x0F);</span>
<span class="line-removed">8898   emit_int8((unsigned char)0xAE);</span>
8899   emit_operand(as_Register(5), src);
8900 }
8901 
8902 void Assembler::fxsave(Address dst) {
<span class="line-modified">8903   prefixq(dst);</span>
<span class="line-removed">8904   emit_int8(0x0F);</span>
<span class="line-removed">8905   emit_int8((unsigned char)0xAE);</span>
8906   emit_operand(as_Register(0), dst);
8907 }
8908 
8909 void Assembler::xsave(Address dst) {
<span class="line-modified">8910   prefixq(dst);</span>
<span class="line-removed">8911   emit_int8(0x0F);</span>
<span class="line-removed">8912   emit_int8((unsigned char)0xAE);</span>
8913   emit_operand(as_Register(4), dst);
8914 }
8915 
8916 void Assembler::idivq(Register src) {
8917   int encode = prefixq_and_encode(src-&gt;encoding());
<span class="line-modified">8918   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">8919   emit_int8((unsigned char)(0xF8 | encode));</span>
8920 }
8921 
8922 void Assembler::imulq(Register dst, Register src) {
8923   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">8924   emit_int8(0x0F);</span>
<span class="line-removed">8925   emit_int8((unsigned char)0xAF);</span>
<span class="line-removed">8926   emit_int8((unsigned char)(0xC0 | encode));</span>
8927 }
8928 
8929 void Assembler::imulq(Register dst, Register src, int value) {
8930   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8931   if (is8bit(value)) {
<span class="line-modified">8932     emit_int8(0x6B);</span>
<span class="line-removed">8933     emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">8934     emit_int8(value &amp; 0xFF);</span>
8935   } else {
<span class="line-modified">8936     emit_int8(0x69);</span>
<span class="line-removed">8937     emit_int8((unsigned char)(0xC0 | encode));</span>
8938     emit_int32(value);
8939   }
8940 }
8941 
8942 void Assembler::imulq(Register dst, Address src) {
8943   InstructionMark im(this);
<span class="line-modified">8944   prefixq(src, dst);</span>
<span class="line-removed">8945   emit_int8(0x0F);</span>
<span class="line-removed">8946   emit_int8((unsigned char) 0xAF);</span>
8947   emit_operand(dst, src);
8948 }
8949 
8950 void Assembler::incl(Register dst) {
8951   // Don&#39;t use it directly. Use MacroAssembler::incrementl() instead.
8952   // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
8953   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">8954   emit_int8((unsigned char)0xFF);</span>
<span class="line-removed">8955   emit_int8((unsigned char)(0xC0 | encode));</span>
8956 }
8957 
8958 void Assembler::incq(Register dst) {
8959   // Don&#39;t use it directly. Use MacroAssembler::incrementq() instead.
8960   // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
8961   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">8962   emit_int8((unsigned char)0xFF);</span>
<span class="line-removed">8963   emit_int8((unsigned char)(0xC0 | encode));</span>
8964 }
8965 
8966 void Assembler::incq(Address dst) {
8967   // Don&#39;t use it directly. Use MacroAssembler::incrementq() instead.
8968   InstructionMark im(this);
<span class="line-modified">8969   prefixq(dst);</span>
<span class="line-removed">8970   emit_int8((unsigned char)0xFF);</span>
8971   emit_operand(rax, dst);
8972 }
8973 
8974 void Assembler::lea(Register dst, Address src) {
8975   leaq(dst, src);
8976 }
8977 
8978 void Assembler::leaq(Register dst, Address src) {
8979   InstructionMark im(this);
<span class="line-modified">8980   prefixq(src, dst);</span>
<span class="line-removed">8981   emit_int8((unsigned char)0x8D);</span>
8982   emit_operand(dst, src);
8983 }
8984 
8985 void Assembler::mov64(Register dst, int64_t imm64) {
8986   InstructionMark im(this);
8987   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">8988   emit_int8((unsigned char)(0xB8 | encode));</span>
8989   emit_int64(imm64);
8990 }
8991 
8992 void Assembler::mov_literal64(Register dst, intptr_t imm64, RelocationHolder const&amp; rspec) {
8993   InstructionMark im(this);
8994   int encode = prefixq_and_encode(dst-&gt;encoding());
8995   emit_int8(0xB8 | encode);
8996   emit_data64(imm64, rspec);
8997 }
8998 
8999 void Assembler::mov_narrow_oop(Register dst, int32_t imm32, RelocationHolder const&amp; rspec) {
9000   InstructionMark im(this);
9001   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">9002   emit_int8((unsigned char)(0xB8 | encode));</span>
9003   emit_data((int)imm32, rspec, narrow_oop_operand);
9004 }
9005 
9006 void Assembler::mov_narrow_oop(Address dst, int32_t imm32,  RelocationHolder const&amp; rspec) {
9007   InstructionMark im(this);
9008   prefix(dst);
9009   emit_int8((unsigned char)0xC7);
9010   emit_operand(rax, dst, 4);
9011   emit_data((int)imm32, rspec, narrow_oop_operand);
9012 }
9013 
9014 void Assembler::cmp_narrow_oop(Register src1, int32_t imm32, RelocationHolder const&amp; rspec) {
9015   InstructionMark im(this);
9016   int encode = prefix_and_encode(src1-&gt;encoding());
<span class="line-modified">9017   emit_int8((unsigned char)0x81);</span>
<span class="line-removed">9018   emit_int8((unsigned char)(0xF8 | encode));</span>
9019   emit_data((int)imm32, rspec, narrow_oop_operand);
9020 }
9021 
9022 void Assembler::cmp_narrow_oop(Address src1, int32_t imm32, RelocationHolder const&amp; rspec) {
9023   InstructionMark im(this);
9024   prefix(src1);
9025   emit_int8((unsigned char)0x81);
9026   emit_operand(rax, src1, 4);
9027   emit_data((int)imm32, rspec, narrow_oop_operand);
9028 }
9029 
9030 void Assembler::lzcntq(Register dst, Register src) {
9031   assert(VM_Version::supports_lzcnt(), &quot;encoding is treated as BSR&quot;);
9032   emit_int8((unsigned char)0xF3);
9033   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">9034   emit_int8(0x0F);</span>
<span class="line-removed">9035   emit_int8((unsigned char)0xBD);</span>
<span class="line-removed">9036   emit_int8((unsigned char)(0xC0 | encode));</span>
9037 }
9038 
9039 void Assembler::movdq(XMMRegister dst, Register src) {
9040   // table D-1 says MMX/SSE2
9041   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
9042   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
9043   int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">9044   emit_int8(0x6E);</span>
<span class="line-removed">9045   emit_int8((unsigned char)(0xC0 | encode));</span>
9046 }
9047 
9048 void Assembler::movdq(Register dst, XMMRegister src) {
9049   // table D-1 says MMX/SSE2
9050   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
9051   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
9052   // swap src/dst to get correct prefix
9053   int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">9054   emit_int8(0x7E);</span>
<span class="line-modified">9055   emit_int8((unsigned char)(0xC0 | encode));</span>
9056 }
9057 
9058 void Assembler::movq(Register dst, Register src) {
9059   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">9060   emit_int8((unsigned char)0x8B);</span>
<span class="line-modified">9061   emit_int8((unsigned char)(0xC0 | encode));</span>
9062 }
9063 
9064 void Assembler::movq(Register dst, Address src) {
9065   InstructionMark im(this);
<span class="line-modified">9066   prefixq(src, dst);</span>
<span class="line-removed">9067   emit_int8((unsigned char)0x8B);</span>
9068   emit_operand(dst, src);
9069 }
9070 
9071 void Assembler::movq(Address dst, Register src) {
9072   InstructionMark im(this);
<span class="line-modified">9073   prefixq(dst, src);</span>
<span class="line-removed">9074   emit_int8((unsigned char)0x89);</span>
9075   emit_operand(src, dst);
9076 }
9077 
9078 void Assembler::movsbq(Register dst, Address src) {
9079   InstructionMark im(this);
<span class="line-modified">9080   prefixq(src, dst);</span>
<span class="line-modified">9081   emit_int8(0x0F);</span>
<span class="line-modified">9082   emit_int8((unsigned char)0xBE);</span>
9083   emit_operand(dst, src);
9084 }
9085 
9086 void Assembler::movsbq(Register dst, Register src) {
9087   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">9088   emit_int8(0x0F);</span>
<span class="line-removed">9089   emit_int8((unsigned char)0xBE);</span>
<span class="line-removed">9090   emit_int8((unsigned char)(0xC0 | encode));</span>
9091 }
9092 
9093 void Assembler::movslq(Register dst, int32_t imm32) {
9094   // dbx shows movslq(rcx, 3) as movq     $0x0000000049000000,(%rbx)
9095   // and movslq(r8, 3); as movl     $0x0000000048000000,(%rbx)
9096   // as a result we shouldn&#39;t use until tested at runtime...
9097   ShouldNotReachHere();
9098   InstructionMark im(this);
9099   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">9100   emit_int8((unsigned char)(0xC7 | encode));</span>
9101   emit_int32(imm32);
9102 }
9103 
9104 void Assembler::movslq(Address dst, int32_t imm32) {
9105   assert(is_simm32(imm32), &quot;lost bits&quot;);
9106   InstructionMark im(this);
<span class="line-modified">9107   prefixq(dst);</span>
<span class="line-removed">9108   emit_int8((unsigned char)0xC7);</span>
9109   emit_operand(rax, dst, 4);
9110   emit_int32(imm32);
9111 }
9112 
9113 void Assembler::movslq(Register dst, Address src) {
9114   InstructionMark im(this);
<span class="line-modified">9115   prefixq(src, dst);</span>
<span class="line-removed">9116   emit_int8(0x63);</span>
9117   emit_operand(dst, src);
9118 }
9119 
9120 void Assembler::movslq(Register dst, Register src) {
9121   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">9122   emit_int8(0x63);</span>
<span class="line-removed">9123   emit_int8((unsigned char)(0xC0 | encode));</span>
9124 }
9125 
9126 void Assembler::movswq(Register dst, Address src) {
9127   InstructionMark im(this);
<span class="line-modified">9128   prefixq(src, dst);</span>
<span class="line-modified">9129   emit_int8(0x0F);</span>
<span class="line-modified">9130   emit_int8((unsigned char)0xBF);</span>
9131   emit_operand(dst, src);
9132 }
9133 
9134 void Assembler::movswq(Register dst, Register src) {
9135   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">9136   emit_int8((unsigned char)0x0F);</span>
<span class="line-removed">9137   emit_int8((unsigned char)0xBF);</span>
<span class="line-removed">9138   emit_int8((unsigned char)(0xC0 | encode));</span>
9139 }
9140 
9141 void Assembler::movzbq(Register dst, Address src) {
9142   InstructionMark im(this);
<span class="line-modified">9143   prefixq(src, dst);</span>
<span class="line-modified">9144   emit_int8((unsigned char)0x0F);</span>
<span class="line-modified">9145   emit_int8((unsigned char)0xB6);</span>
9146   emit_operand(dst, src);
9147 }
9148 
9149 void Assembler::movzbq(Register dst, Register src) {
9150   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">9151   emit_int8(0x0F);</span>
<span class="line-removed">9152   emit_int8((unsigned char)0xB6);</span>
<span class="line-removed">9153   emit_int8(0xC0 | encode);</span>
9154 }
9155 
9156 void Assembler::movzwq(Register dst, Address src) {
9157   InstructionMark im(this);
<span class="line-modified">9158   prefixq(src, dst);</span>
<span class="line-modified">9159   emit_int8((unsigned char)0x0F);</span>
<span class="line-modified">9160   emit_int8((unsigned char)0xB7);</span>
9161   emit_operand(dst, src);
9162 }
9163 
9164 void Assembler::movzwq(Register dst, Register src) {
9165   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">9166   emit_int8((unsigned char)0x0F);</span>
<span class="line-removed">9167   emit_int8((unsigned char)0xB7);</span>
<span class="line-removed">9168   emit_int8((unsigned char)(0xC0 | encode));</span>
9169 }
9170 
9171 void Assembler::mulq(Address src) {
9172   InstructionMark im(this);
<span class="line-modified">9173   prefixq(src);</span>
<span class="line-removed">9174   emit_int8((unsigned char)0xF7);</span>
9175   emit_operand(rsp, src);
9176 }
9177 
9178 void Assembler::mulq(Register src) {
9179   int encode = prefixq_and_encode(src-&gt;encoding());
<span class="line-modified">9180   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">9181   emit_int8((unsigned char)(0xE0 | encode));</span>
9182 }
9183 
9184 void Assembler::mulxq(Register dst1, Register dst2, Register src) {
9185   assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
9186   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
9187   int encode = vex_prefix_and_encode(dst1-&gt;encoding(), dst2-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">9188   emit_int8((unsigned char)0xF6);</span>
<span class="line-removed">9189   emit_int8((unsigned char)(0xC0 | encode));</span>
9190 }
9191 
9192 void Assembler::negq(Register dst) {
9193   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">9194   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">9195   emit_int8((unsigned char)(0xD8 | encode));</span>
9196 }
9197 
9198 void Assembler::notq(Register dst) {
9199   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">9200   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">9201   emit_int8((unsigned char)(0xD0 | encode));</span>
9202 }
9203 
9204 void Assembler::btsq(Address dst, int imm8) {
9205   assert(isByte(imm8), &quot;not a byte&quot;);
9206   InstructionMark im(this);
<span class="line-modified">9207   prefixq(dst);</span>
<span class="line-modified">9208   emit_int8((unsigned char)0x0F);</span>
<span class="line-modified">9209   emit_int8((unsigned char)0xBA);</span>
9210   emit_operand(rbp /* 5 */, dst, 1);
9211   emit_int8(imm8);
9212 }
9213 
9214 void Assembler::btrq(Address dst, int imm8) {
9215   assert(isByte(imm8), &quot;not a byte&quot;);
9216   InstructionMark im(this);
<span class="line-modified">9217   prefixq(dst);</span>
<span class="line-modified">9218   emit_int8((unsigned char)0x0F);</span>
<span class="line-modified">9219   emit_int8((unsigned char)0xBA);</span>
9220   emit_operand(rsi /* 6 */, dst, 1);
9221   emit_int8(imm8);
9222 }
9223 
9224 void Assembler::orq(Address dst, int32_t imm32) {
9225   InstructionMark im(this);
<span class="line-modified">9226   prefixq(dst);</span>
<span class="line-removed">9227   emit_int8((unsigned char)0x81);</span>
9228   emit_operand(rcx, dst, 4);
9229   emit_int32(imm32);
9230 }
9231 
9232 void Assembler::orq(Register dst, int32_t imm32) {
9233   (void) prefixq_and_encode(dst-&gt;encoding());
9234   emit_arith(0x81, 0xC8, dst, imm32);
9235 }
9236 
9237 void Assembler::orq(Register dst, Address src) {
9238   InstructionMark im(this);
<span class="line-modified">9239   prefixq(src, dst);</span>
<span class="line-removed">9240   emit_int8(0x0B);</span>
9241   emit_operand(dst, src);
9242 }
9243 
9244 void Assembler::orq(Register dst, Register src) {
9245   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9246   emit_arith(0x0B, 0xC0, dst, src);
9247 }
9248 


























































































9249 void Assembler::popa() { // 64bit




9250   movq(r15, Address(rsp, 0));
9251   movq(r14, Address(rsp, wordSize));
9252   movq(r13, Address(rsp, 2 * wordSize));
9253   movq(r12, Address(rsp, 3 * wordSize));
9254   movq(r11, Address(rsp, 4 * wordSize));
9255   movq(r10, Address(rsp, 5 * wordSize));
9256   movq(r9,  Address(rsp, 6 * wordSize));
9257   movq(r8,  Address(rsp, 7 * wordSize));
9258   movq(rdi, Address(rsp, 8 * wordSize));
9259   movq(rsi, Address(rsp, 9 * wordSize));
9260   movq(rbp, Address(rsp, 10 * wordSize));
9261   // skip rsp
9262   movq(rbx, Address(rsp, 12 * wordSize));
9263   movq(rdx, Address(rsp, 13 * wordSize));
9264   movq(rcx, Address(rsp, 14 * wordSize));
9265   movq(rax, Address(rsp, 15 * wordSize));
9266 
9267   addq(rsp, 16 * wordSize);
9268 }
9269 
<span class="line-modified">9270 void Assembler::popcntq(Register dst, Address src) {</span>
<span class="line-modified">9271   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);</span>
<span class="line-removed">9272   InstructionMark im(this);</span>
<span class="line-removed">9273   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">9274   prefixq(src, dst);</span>
<span class="line-removed">9275   emit_int8((unsigned char)0x0F);</span>
<span class="line-removed">9276   emit_int8((unsigned char)0xB8);</span>
<span class="line-removed">9277   emit_operand(dst, src);</span>
<span class="line-removed">9278 }</span>
<span class="line-removed">9279 </span>
<span class="line-removed">9280 void Assembler::popcntq(Register dst, Register src) {</span>
<span class="line-removed">9281   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);</span>
<span class="line-removed">9282   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">9283   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());</span>
<span class="line-removed">9284   emit_int8((unsigned char)0x0F);</span>
<span class="line-removed">9285   emit_int8((unsigned char)0xB8);</span>
<span class="line-removed">9286   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">9287 }</span>
<span class="line-removed">9288 </span>
<span class="line-removed">9289 void Assembler::popq(Address dst) {</span>
<span class="line-removed">9290   InstructionMark im(this);</span>
<span class="line-removed">9291   prefixq(dst);</span>
<span class="line-removed">9292   emit_int8((unsigned char)0x8F);</span>
<span class="line-removed">9293   emit_operand(rax, dst);</span>
9294 }
9295 
<span class="line-modified">9296 void Assembler::pusha() { // 64bit</span>
9297   // we have to store original rsp.  ABI says that 128 bytes
9298   // below rsp are local scratch.
9299   movq(Address(rsp, -5 * wordSize), rsp);
9300 
9301   subq(rsp, 16 * wordSize);
9302 
9303   movq(Address(rsp, 15 * wordSize), rax);
9304   movq(Address(rsp, 14 * wordSize), rcx);
9305   movq(Address(rsp, 13 * wordSize), rdx);
9306   movq(Address(rsp, 12 * wordSize), rbx);
9307   // skip rsp
9308   movq(Address(rsp, 10 * wordSize), rbp);
9309   movq(Address(rsp, 9 * wordSize), rsi);
9310   movq(Address(rsp, 8 * wordSize), rdi);
9311   movq(Address(rsp, 7 * wordSize), r8);
9312   movq(Address(rsp, 6 * wordSize), r9);
9313   movq(Address(rsp, 5 * wordSize), r10);
9314   movq(Address(rsp, 4 * wordSize), r11);
9315   movq(Address(rsp, 3 * wordSize), r12);
9316   movq(Address(rsp, 2 * wordSize), r13);
9317   movq(Address(rsp, wordSize), r14);
9318   movq(Address(rsp, 0), r15);
9319 }
9320 




9321 void Assembler::pushq(Address src) {
9322   InstructionMark im(this);
<span class="line-modified">9323   prefixq(src);</span>
<span class="line-removed">9324   emit_int8((unsigned char)0xFF);</span>
9325   emit_operand(rsi, src);
9326 }
9327 
9328 void Assembler::rclq(Register dst, int imm8) {
9329   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
9330   int encode = prefixq_and_encode(dst-&gt;encoding());
9331   if (imm8 == 1) {
<span class="line-modified">9332     emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">9333     emit_int8((unsigned char)(0xD0 | encode));</span>
9334   } else {
<span class="line-modified">9335     emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">9336     emit_int8((unsigned char)(0xD0 | encode));</span>
<span class="line-removed">9337     emit_int8(imm8);</span>
9338   }
9339 }
9340 
9341 void Assembler::rcrq(Register dst, int imm8) {
9342   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
9343   int encode = prefixq_and_encode(dst-&gt;encoding());
9344   if (imm8 == 1) {
<span class="line-modified">9345     emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">9346     emit_int8((unsigned char)(0xD8 | encode));</span>
9347   } else {
<span class="line-modified">9348     emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">9349     emit_int8((unsigned char)(0xD8 | encode));</span>
<span class="line-removed">9350     emit_int8(imm8);</span>
9351   }
9352 }
9353 
9354 void Assembler::rorq(Register dst, int imm8) {
9355   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
9356   int encode = prefixq_and_encode(dst-&gt;encoding());
9357   if (imm8 == 1) {
<span class="line-modified">9358     emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">9359     emit_int8((unsigned char)(0xC8 | encode));</span>
9360   } else {
<span class="line-modified">9361     emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">9362     emit_int8((unsigned char)(0xc8 | encode));</span>
<span class="line-removed">9363     emit_int8(imm8);</span>
9364   }
9365 }
9366 
9367 void Assembler::rorxq(Register dst, Register src, int imm8) {
9368   assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
9369   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
9370   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">9371   emit_int8((unsigned char)0xF0);</span>
<span class="line-removed">9372   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">9373   emit_int8(imm8);</span>
9374 }
9375 
9376 void Assembler::rorxd(Register dst, Register src, int imm8) {
9377   assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
9378   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
9379   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">9380   emit_int8((unsigned char)0xF0);</span>
<span class="line-removed">9381   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">9382   emit_int8(imm8);</span>
9383 }
9384 
9385 void Assembler::sarq(Register dst, int imm8) {
9386   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
9387   int encode = prefixq_and_encode(dst-&gt;encoding());
9388   if (imm8 == 1) {
<span class="line-modified">9389     emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">9390     emit_int8((unsigned char)(0xF8 | encode));</span>
9391   } else {
<span class="line-modified">9392     emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">9393     emit_int8((unsigned char)(0xF8 | encode));</span>
<span class="line-removed">9394     emit_int8(imm8);</span>
9395   }
9396 }
9397 
9398 void Assembler::sarq(Register dst) {
9399   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">9400   emit_int8((unsigned char)0xD3);</span>
<span class="line-removed">9401   emit_int8((unsigned char)(0xF8 | encode));</span>
9402 }
9403 
9404 void Assembler::sbbq(Address dst, int32_t imm32) {
9405   InstructionMark im(this);
9406   prefixq(dst);
9407   emit_arith_operand(0x81, rbx, dst, imm32);
9408 }
9409 
9410 void Assembler::sbbq(Register dst, int32_t imm32) {
9411   (void) prefixq_and_encode(dst-&gt;encoding());
9412   emit_arith(0x81, 0xD8, dst, imm32);
9413 }
9414 
9415 void Assembler::sbbq(Register dst, Address src) {
9416   InstructionMark im(this);
<span class="line-modified">9417   prefixq(src, dst);</span>
<span class="line-removed">9418   emit_int8(0x1B);</span>
9419   emit_operand(dst, src);
9420 }
9421 
9422 void Assembler::sbbq(Register dst, Register src) {
9423   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9424   emit_arith(0x1B, 0xC0, dst, src);
9425 }
9426 
9427 void Assembler::shlq(Register dst, int imm8) {
9428   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
9429   int encode = prefixq_and_encode(dst-&gt;encoding());
9430   if (imm8 == 1) {
<span class="line-modified">9431     emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">9432     emit_int8((unsigned char)(0xE0 | encode));</span>
9433   } else {
<span class="line-modified">9434     emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">9435     emit_int8((unsigned char)(0xE0 | encode));</span>
<span class="line-removed">9436     emit_int8(imm8);</span>
9437   }
9438 }
9439 
9440 void Assembler::shlq(Register dst) {
9441   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">9442   emit_int8((unsigned char)0xD3);</span>
<span class="line-removed">9443   emit_int8((unsigned char)(0xE0 | encode));</span>
9444 }
9445 
9446 void Assembler::shrq(Register dst, int imm8) {
9447   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
9448   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">9449   emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">9450   emit_int8((unsigned char)(0xE8 | encode));</span>
<span class="line-removed">9451   emit_int8(imm8);</span>
9452 }
9453 
9454 void Assembler::shrq(Register dst) {
9455   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">9456   emit_int8((unsigned char)0xD3);</span>
<span class="line-removed">9457   emit_int8(0xE8 | encode);</span>
9458 }
9459 
9460 void Assembler::subq(Address dst, int32_t imm32) {
9461   InstructionMark im(this);
9462   prefixq(dst);
9463   emit_arith_operand(0x81, rbp, dst, imm32);
9464 }
9465 
9466 void Assembler::subq(Address dst, Register src) {
9467   InstructionMark im(this);
<span class="line-modified">9468   prefixq(dst, src);</span>
<span class="line-removed">9469   emit_int8(0x29);</span>
9470   emit_operand(src, dst);
9471 }
9472 
9473 void Assembler::subq(Register dst, int32_t imm32) {
9474   (void) prefixq_and_encode(dst-&gt;encoding());
9475   emit_arith(0x81, 0xE8, dst, imm32);
9476 }
9477 
9478 // Force generation of a 4 byte immediate value even if it fits into 8bit
9479 void Assembler::subq_imm32(Register dst, int32_t imm32) {
9480   (void) prefixq_and_encode(dst-&gt;encoding());
9481   emit_arith_imm32(0x81, 0xE8, dst, imm32);
9482 }
9483 
9484 void Assembler::subq(Register dst, Address src) {
9485   InstructionMark im(this);
<span class="line-modified">9486   prefixq(src, dst);</span>
<span class="line-removed">9487   emit_int8(0x2B);</span>
9488   emit_operand(dst, src);
9489 }
9490 
9491 void Assembler::subq(Register dst, Register src) {
9492   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9493   emit_arith(0x2B, 0xC0, dst, src);
9494 }
9495 
9496 void Assembler::testq(Register dst, int32_t imm32) {
9497   // not using emit_arith because test
9498   // doesn&#39;t support sign-extension of
9499   // 8bit operands
9500   int encode = dst-&gt;encoding();
9501   if (encode == 0) {
<span class="line-modified">9502     prefix(REX_W);</span>
<span class="line-removed">9503     emit_int8((unsigned char)0xA9);</span>
9504   } else {
9505     encode = prefixq_and_encode(encode);
<span class="line-modified">9506     emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">9507     emit_int8((unsigned char)(0xC0 | encode));</span>
9508   }
9509   emit_int32(imm32);
9510 }
9511 
9512 void Assembler::testq(Register dst, Register src) {
9513   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9514   emit_arith(0x85, 0xC0, dst, src);
9515 }
9516 
9517 void Assembler::testq(Register dst, Address src) {
9518   InstructionMark im(this);
<span class="line-modified">9519   prefixq(src, dst);</span>
<span class="line-removed">9520   emit_int8((unsigned char)0x85);</span>
9521   emit_operand(dst, src);
9522 }
9523 
9524 void Assembler::xaddq(Address dst, Register src) {
9525   InstructionMark im(this);
<span class="line-modified">9526   prefixq(dst, src);</span>
<span class="line-removed">9527   emit_int8(0x0F);</span>
<span class="line-removed">9528   emit_int8((unsigned char)0xC1);</span>
9529   emit_operand(src, dst);
9530 }
9531 
9532 void Assembler::xchgq(Register dst, Address src) {
9533   InstructionMark im(this);
<span class="line-modified">9534   prefixq(src, dst);</span>
<span class="line-removed">9535   emit_int8((unsigned char)0x87);</span>
9536   emit_operand(dst, src);
9537 }
9538 
9539 void Assembler::xchgq(Register dst, Register src) {
9540   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">9541   emit_int8((unsigned char)0x87);</span>
<span class="line-removed">9542   emit_int8((unsigned char)(0xc0 | encode));</span>
9543 }
9544 
9545 void Assembler::xorq(Register dst, Register src) {
9546   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9547   emit_arith(0x33, 0xC0, dst, src);
9548 }
9549 
9550 void Assembler::xorq(Register dst, Address src) {
9551   InstructionMark im(this);
<span class="line-modified">9552   prefixq(src, dst);</span>
<span class="line-removed">9553   emit_int8(0x33);</span>
9554   emit_operand(dst, src);
9555 }
9556 
9557 #endif // !LP64
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
</pre>
<hr />
<pre>
 231       code_section()-&gt;relocate(inst_mark(), rspec, disp32_operand);
 232     else
 233       code_section()-&gt;relocate(inst_mark(), rspec, format);
 234   }
 235   emit_int32(data);
 236 }
 237 
 238 static int encode(Register r) {
 239   int enc = r-&gt;encoding();
 240   if (enc &gt;= 8) {
 241     enc -= 8;
 242   }
 243   return enc;
 244 }
 245 
 246 void Assembler::emit_arith_b(int op1, int op2, Register dst, int imm8) {
 247   assert(dst-&gt;has_byte_register(), &quot;must have byte register&quot;);
 248   assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
 249   assert(isByte(imm8), &quot;not a byte&quot;);
 250   assert((op1 &amp; 0x01) == 0, &quot;should be 8bit operation&quot;);
<span class="line-modified"> 251   emit_int24(op1, (op2 | encode(dst)), imm8);</span>


 252 }
 253 
 254 
 255 void Assembler::emit_arith(int op1, int op2, Register dst, int32_t imm32) {
 256   assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
 257   assert((op1 &amp; 0x01) == 1, &quot;should be 32bit operation&quot;);
 258   assert((op1 &amp; 0x02) == 0, &quot;sign-extension bit should not be set&quot;);
 259   if (is8bit(imm32)) {
<span class="line-modified"> 260     emit_int24(op1 | 0x02,        // set sign bit</span>
<span class="line-modified"> 261                op2 | encode(dst),</span>
<span class="line-modified"> 262                imm32 &amp; 0xFF);</span>
 263   } else {
<span class="line-modified"> 264     emit_int16(op1, (op2 | encode(dst)));</span>

 265     emit_int32(imm32);
 266   }
 267 }
 268 
 269 // Force generation of a 4 byte immediate value even if it fits into 8bit
 270 void Assembler::emit_arith_imm32(int op1, int op2, Register dst, int32_t imm32) {
 271   assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
 272   assert((op1 &amp; 0x01) == 1, &quot;should be 32bit operation&quot;);
 273   assert((op1 &amp; 0x02) == 0, &quot;sign-extension bit should not be set&quot;);
<span class="line-modified"> 274   emit_int16(op1, (op2 | encode(dst)));</span>

 275   emit_int32(imm32);
 276 }
 277 
 278 // immediate-to-memory forms
 279 void Assembler::emit_arith_operand(int op1, Register rm, Address adr, int32_t imm32) {
 280   assert((op1 &amp; 0x01) == 1, &quot;should be 32bit operation&quot;);
 281   assert((op1 &amp; 0x02) == 0, &quot;sign-extension bit should not be set&quot;);
 282   if (is8bit(imm32)) {
 283     emit_int8(op1 | 0x02); // set sign bit
 284     emit_operand(rm, adr, 1);
 285     emit_int8(imm32 &amp; 0xFF);
 286   } else {
 287     emit_int8(op1);
 288     emit_operand(rm, adr, 4);
 289     emit_int32(imm32);
 290   }
 291 }
 292 
 293 
 294 void Assembler::emit_arith(int op1, int op2, Register dst, Register src) {
 295   assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
<span class="line-modified"> 296   emit_int16(op1, (op2 | encode(dst) &lt;&lt; 3 | encode(src)));</span>

 297 }
 298 
 299 
 300 bool Assembler::query_compressed_disp_byte(int disp, bool is_evex_inst, int vector_len,
 301                                            int cur_tuple_type, int in_size_in_bits, int cur_encoding) {
 302   int mod_idx = 0;
 303   // We will test if the displacement fits the compressed format and if so
 304   // apply the compression to the displacment iff the result is8bit.
 305   if (VM_Version::supports_evex() &amp;&amp; is_evex_inst) {
 306     switch (cur_tuple_type) {
 307     case EVEX_FV:
 308       if ((cur_encoding &amp; VEX_W) == VEX_W) {
 309         mod_idx = ((cur_encoding &amp; EVEX_Rb) == EVEX_Rb) ? 3 : 2;
 310       } else {
 311         mod_idx = ((cur_encoding &amp; EVEX_Rb) == EVEX_Rb) ? 1 : 0;
 312       }
 313       break;
 314 
 315     case EVEX_HV:
 316       mod_idx = ((cur_encoding &amp; EVEX_Rb) == EVEX_Rb) ? 1 : 0;
</pre>
<hr />
<pre>
 453       assert(0, &quot;no valid evex tuple_table entry&quot;);
 454       break;
 455     }
 456 
 457     int vector_len = _attributes-&gt;get_vector_len();
 458     if (vector_len &gt;= AVX_128bit &amp;&amp; vector_len &lt;= AVX_512bit) {
 459       int disp_factor = tuple_table[tuple_type + mod_idx][vector_len];
 460       if ((disp % disp_factor) == 0) {
 461         int new_disp = disp / disp_factor;
 462         if (is8bit(new_disp)) {
 463           disp = new_disp;
 464         }
 465       } else {
 466         return false;
 467       }
 468     }
 469   }
 470   return is8bit(disp);
 471 }
 472 
<span class="line-added"> 473 static bool is_valid_encoding(int reg_enc) {</span>
<span class="line-added"> 474   return reg_enc &gt;= 0;</span>
<span class="line-added"> 475 }</span>
 476 
<span class="line-modified"> 477 static int raw_encode(Register reg) {</span>
<span class="line-modified"> 478   assert(reg == noreg || reg-&gt;is_valid(), &quot;sanity&quot;);</span>
<span class="line-modified"> 479   int reg_enc = (intptr_t)reg;</span>
<span class="line-modified"> 480   assert(reg_enc == -1 || is_valid_encoding(reg_enc), &quot;sanity&quot;);</span>
<span class="line-modified"> 481   return reg_enc;</span>
<span class="line-added"> 482 }</span>
<span class="line-added"> 483 </span>
<span class="line-added"> 484 static int raw_encode(XMMRegister xmmreg) {</span>
<span class="line-added"> 485   assert(xmmreg == xnoreg || xmmreg-&gt;is_valid(), &quot;sanity&quot;);</span>
<span class="line-added"> 486   int xmmreg_enc = (intptr_t)xmmreg;</span>
<span class="line-added"> 487   assert(xmmreg_enc == -1 || is_valid_encoding(xmmreg_enc), &quot;sanity&quot;);</span>
<span class="line-added"> 488   return xmmreg_enc;</span>
<span class="line-added"> 489 }</span>
<span class="line-added"> 490 </span>
<span class="line-added"> 491 static int modrm_encoding(int mod, int dst_enc, int src_enc) {</span>
<span class="line-added"> 492   return (mod &amp; 3) &lt;&lt; 6 | (dst_enc &amp; 7) &lt;&lt; 3 | (src_enc &amp; 7);</span>
<span class="line-added"> 493 }</span>
<span class="line-added"> 494 </span>
<span class="line-added"> 495 static int sib_encoding(Address::ScaleFactor scale, int index_enc, int base_enc) {</span>
<span class="line-added"> 496   return (scale &amp; 3) &lt;&lt; 6 | (index_enc &amp; 7) &lt;&lt; 3 | (base_enc &amp; 7);</span>
<span class="line-added"> 497 }</span>
<span class="line-added"> 498 </span>
<span class="line-added"> 499 inline void Assembler::emit_modrm(int mod, int dst_enc, int src_enc) {</span>
<span class="line-added"> 500   assert((mod &amp; 3) != 0b11, &quot;forbidden&quot;);</span>
<span class="line-added"> 501   int modrm = modrm_encoding(mod, dst_enc, src_enc);</span>
<span class="line-added"> 502   emit_int8(modrm);</span>
<span class="line-added"> 503 }</span>
<span class="line-added"> 504 </span>
<span class="line-added"> 505 inline void Assembler::emit_modrm_disp8(int mod, int dst_enc, int src_enc,</span>
<span class="line-added"> 506                                         int disp) {</span>
<span class="line-added"> 507   int modrm = modrm_encoding(mod, dst_enc, src_enc);</span>
<span class="line-added"> 508   emit_int16(modrm, disp &amp; 0xFF);</span>
<span class="line-added"> 509 }</span>
<span class="line-added"> 510 </span>
<span class="line-added"> 511 inline void Assembler::emit_modrm_sib(int mod, int dst_enc, int src_enc,</span>
<span class="line-added"> 512                                       Address::ScaleFactor scale, int index_enc, int base_enc) {</span>
<span class="line-added"> 513   int modrm = modrm_encoding(mod, dst_enc, src_enc);</span>
<span class="line-added"> 514   int sib = sib_encoding(scale, index_enc, base_enc);</span>
<span class="line-added"> 515   emit_int16(modrm, sib);</span>
<span class="line-added"> 516 }</span>
 517 
<span class="line-modified"> 518 inline void Assembler::emit_modrm_sib_disp8(int mod, int dst_enc, int src_enc,</span>
<span class="line-added"> 519                                             Address::ScaleFactor scale, int index_enc, int base_enc,</span>
<span class="line-added"> 520                                             int disp) {</span>
<span class="line-added"> 521   int modrm = modrm_encoding(mod, dst_enc, src_enc);</span>
<span class="line-added"> 522   int sib = sib_encoding(scale, index_enc, base_enc);</span>
<span class="line-added"> 523   emit_int24(modrm, sib, disp &amp; 0xFF);</span>
<span class="line-added"> 524 }</span>
 525 
<span class="line-modified"> 526 void Assembler::emit_operand_helper(int reg_enc, int base_enc, int index_enc,</span>
<span class="line-modified"> 527                                     Address::ScaleFactor scale, int disp,</span>
<span class="line-modified"> 528                                     RelocationHolder const&amp; rspec,</span>
<span class="line-added"> 529                                     int rip_relative_correction) {</span>
<span class="line-added"> 530   bool no_relocation = (rspec.type() == relocInfo::none);</span>
 531 
<span class="line-modified"> 532   if (is_valid_encoding(base_enc)) {</span>
<span class="line-modified"> 533     if (is_valid_encoding(index_enc)) {</span>
 534       assert(scale != Address::no_scale, &quot;inconsistent address&quot;);
 535       // [base + index*scale + disp]
<span class="line-modified"> 536       if (disp == 0 &amp;&amp; no_relocation &amp;&amp;</span>
<span class="line-modified"> 537           base_enc != rbp-&gt;encoding() LP64_ONLY(&amp;&amp; base_enc != r13-&gt;encoding())) {</span>
 538         // [base + index*scale]
 539         // [00 reg 100][ss index base]
<span class="line-modified"> 540         emit_modrm_sib(0b00, reg_enc, 0b100,</span>
<span class="line-modified"> 541                        scale, index_enc, base_enc);</span>
<span class="line-modified"> 542       } else if (emit_compressed_disp_byte(disp) &amp;&amp; no_relocation) {</span>

 543         // [base + index*scale + imm8]
 544         // [01 reg 100][ss index base] imm8
<span class="line-modified"> 545         emit_modrm_sib_disp8(0b01, reg_enc, 0b100,</span>
<span class="line-modified"> 546                              scale, index_enc, base_enc,</span>
<span class="line-modified"> 547                              disp);</span>

 548       } else {
 549         // [base + index*scale + disp32]
 550         // [10 reg 100][ss index base] disp32
<span class="line-modified"> 551         emit_modrm_sib(0b10, reg_enc, 0b100,</span>
<span class="line-modified"> 552                        scale, index_enc, base_enc);</span>

 553         emit_data(disp, rspec, disp32_operand);
 554       }
<span class="line-modified"> 555     } else if (base_enc == rsp-&gt;encoding() LP64_ONLY(|| base_enc == r12-&gt;encoding())) {</span>
 556       // [rsp + disp]
<span class="line-modified"> 557       if (disp == 0 &amp;&amp; no_relocation) {</span>
 558         // [rsp]
 559         // [00 reg 100][00 100 100]
<span class="line-modified"> 560         emit_modrm_sib(0b00, reg_enc, 0b100,</span>
<span class="line-modified"> 561                        Address::times_1, 0b100, 0b100);</span>
<span class="line-modified"> 562       } else if (emit_compressed_disp_byte(disp) &amp;&amp; no_relocation) {</span>
 563         // [rsp + imm8]
 564         // [01 reg 100][00 100 100] disp8
<span class="line-modified"> 565         emit_modrm_sib_disp8(0b01, reg_enc, 0b100,</span>
<span class="line-modified"> 566                              Address::times_1, 0b100, 0b100,</span>
<span class="line-modified"> 567                              disp);</span>
 568       } else {
 569         // [rsp + imm32]
 570         // [10 reg 100][00 100 100] disp32
<span class="line-modified"> 571         emit_modrm_sib(0b10, reg_enc, 0b100,</span>
<span class="line-modified"> 572                        Address::times_1, 0b100, 0b100);</span>
 573         emit_data(disp, rspec, disp32_operand);
 574       }
 575     } else {
 576       // [base + disp]
<span class="line-modified"> 577       assert(base_enc != rsp-&gt;encoding() LP64_ONLY(&amp;&amp; base_enc != r12-&gt;encoding()), &quot;illegal addressing mode&quot;);</span>
<span class="line-modified"> 578       if (disp == 0 &amp;&amp; no_relocation &amp;&amp;</span>
<span class="line-modified"> 579           base_enc != rbp-&gt;encoding() LP64_ONLY(&amp;&amp; base_enc != r13-&gt;encoding())) {</span>
 580         // [base]
 581         // [00 reg base]
<span class="line-modified"> 582         emit_modrm(0, reg_enc, base_enc);</span>
<span class="line-modified"> 583       } else if (emit_compressed_disp_byte(disp) &amp;&amp; no_relocation) {</span>
 584         // [base + disp8]
 585         // [01 reg base] disp8
<span class="line-modified"> 586         emit_modrm_disp8(0b01, reg_enc, base_enc,</span>
<span class="line-modified"> 587                          disp);</span>
 588       } else {
 589         // [base + disp32]
 590         // [10 reg base] disp32
<span class="line-modified"> 591         emit_modrm(0b10, reg_enc, base_enc);</span>
 592         emit_data(disp, rspec, disp32_operand);
 593       }
 594     }
 595   } else {
<span class="line-modified"> 596     if (is_valid_encoding(index_enc)) {</span>
 597       assert(scale != Address::no_scale, &quot;inconsistent address&quot;);
<span class="line-added"> 598       // base == noreg</span>
 599       // [index*scale + disp]
 600       // [00 reg 100][ss index 101] disp32
<span class="line-modified"> 601       emit_modrm_sib(0b00, reg_enc, 0b100,</span>
<span class="line-modified"> 602                      scale, index_enc, 0b101 /* no base */);</span>

 603       emit_data(disp, rspec, disp32_operand);
<span class="line-modified"> 604     } else if (!no_relocation) {</span>
<span class="line-added"> 605       // base == noreg, index == noreg</span>
 606       // [disp] (64bit) RIP-RELATIVE (32bit) abs
<span class="line-modified"> 607       // [00 reg 101] disp32</span>
 608 
<span class="line-modified"> 609       emit_modrm(0b00, reg_enc, 0b101 /* no base */);</span>
 610       // Note that the RIP-rel. correction applies to the generated
 611       // disp field, but _not_ to the target address in the rspec.
 612 
 613       // disp was created by converting the target address minus the pc
 614       // at the start of the instruction. That needs more correction here.
 615       // intptr_t disp = target - next_ip;
 616       assert(inst_mark() != NULL, &quot;must be inside InstructionMark&quot;);
 617       address next_ip = pc() + sizeof(int32_t) + rip_relative_correction;
 618       int64_t adjusted = disp;
 619       // Do rip-rel adjustment for 64bit
 620       LP64_ONLY(adjusted -=  (next_ip - inst_mark()));
 621       assert(is_simm32(adjusted),
 622              &quot;must be 32bit offset (RIP relative address)&quot;);
 623       emit_data((int32_t) adjusted, rspec, disp32_operand);
 624 
 625     } else {
<span class="line-added"> 626       // base == noreg, index == noreg, no_relocation == true</span>
 627       // 32bit never did this, did everything as the rip-rel/disp code above
 628       // [disp] ABSOLUTE
 629       // [00 reg 100][00 100 101] disp32
<span class="line-modified"> 630       emit_modrm_sib(0b00, reg_enc, 0b100 /* no base */,</span>
<span class="line-modified"> 631                      Address::times_1, 0b100, 0b101);</span>
 632       emit_data(disp, rspec, disp32_operand);
 633     }
 634   }
 635 }
 636 
<span class="line-modified"> 637 void Assembler::emit_operand(Register reg, Register base, Register index,</span>
<span class="line-added"> 638                              Address::ScaleFactor scale, int disp,</span>
<span class="line-added"> 639                              RelocationHolder const&amp; rspec,</span>
<span class="line-added"> 640                              int rip_relative_correction) {</span>
<span class="line-added"> 641   assert(!index-&gt;is_valid() || index != rsp, &quot;illegal addressing mode&quot;);</span>
<span class="line-added"> 642   emit_operand_helper(raw_encode(reg), raw_encode(base), raw_encode(index),</span>
<span class="line-added"> 643                       scale, disp, rspec, rip_relative_correction);</span>
<span class="line-added"> 644 </span>
<span class="line-added"> 645 }</span>
<span class="line-added"> 646 void Assembler::emit_operand(XMMRegister xmmreg, Register base, Register index,</span>
 647                              Address::ScaleFactor scale, int disp,
 648                              RelocationHolder const&amp; rspec) {
<span class="line-modified"> 649   assert(!index-&gt;is_valid() || index != rsp, &quot;illegal addressing mode&quot;);</span>
<span class="line-modified"> 650   assert(xmmreg-&gt;encoding() &lt; 16 || UseAVX &gt; 2, &quot;not supported&quot;);</span>
<span class="line-modified"> 651   emit_operand_helper(raw_encode(xmmreg), raw_encode(base), raw_encode(index),</span>
<span class="line-modified"> 652                       scale, disp, rspec);</span>





 653 }
 654 
<span class="line-modified"> 655 void Assembler::emit_operand(XMMRegister xmmreg, Register base, XMMRegister xmmindex,</span>
 656                              Address::ScaleFactor scale, int disp,
 657                              RelocationHolder const&amp; rspec) {
<span class="line-modified"> 658   assert(xmmreg-&gt;encoding() &lt; 16 || UseAVX &gt; 2, &quot;not supported&quot;);</span>
<span class="line-modified"> 659   assert(xmmindex-&gt;encoding() &lt; 16 || UseAVX &gt; 2, &quot;not supported&quot;);</span>
<span class="line-modified"> 660   emit_operand_helper(raw_encode(xmmreg), raw_encode(base), raw_encode(xmmindex),</span>
<span class="line-modified"> 661                       scale, disp, rspec, /* rip_relative_correction */ 0);</span>





 662 }
 663 

 664 // Secret local extension to Assembler::WhichOperand:
 665 #define end_pc_operand (_WhichOperand_limit)
 666 
 667 address Assembler::locate_operand(address inst, WhichOperand which) {
 668   // Decode the given instruction, and return the address of
 669   // an embedded 32-bit operand word.
 670 
 671   // If &quot;which&quot; is disp32_operand, selects the displacement portion
 672   // of an effective address specifier.
 673   // If &quot;which&quot; is imm64_operand, selects the trailing immediate constant.
 674   // If &quot;which&quot; is call32_operand, selects the displacement of a call or jump.
 675   // Caller is responsible for ensuring that there is such an operand,
 676   // and that it is 32/64 bits wide.
 677 
 678   // If &quot;which&quot; is end_pc_operand, find the end of the instruction.
 679 
 680   address ip = inst;
 681   bool is_64bit = false;
 682 
 683   debug_only(bool has_disp32 = false);
</pre>
<hr />
<pre>
1130   address opnd;
1131 
1132   Relocation* r = rspec.reloc();
1133   if (r-&gt;type() == relocInfo::none) {
1134     return;
1135   } else if (r-&gt;is_call() || format == call32_operand) {
1136     // assert(format == imm32_operand, &quot;cannot specify a nonzero format&quot;);
1137     opnd = locate_operand(inst, call32_operand);
1138   } else if (r-&gt;is_data()) {
1139     assert(format == imm_operand || format == disp32_operand
1140            LP64_ONLY(|| format == narrow_oop_operand), &quot;format ok&quot;);
1141     opnd = locate_operand(inst, (WhichOperand)format);
1142   } else {
1143     assert(format == imm_operand, &quot;cannot specify a format&quot;);
1144     return;
1145   }
1146   assert(opnd == pc(), &quot;must put operand where relocs can find it&quot;);
1147 }
1148 #endif // ASSERT
1149 







1150 void Assembler::emit_operand(Register reg, Address adr,
1151                              int rip_relative_correction) {
1152   emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,
1153                adr._rspec,
1154                rip_relative_correction);
1155 }
1156 
1157 void Assembler::emit_operand(XMMRegister reg, Address adr) {
1158     if (adr.isxmmindex()) {
1159        emit_operand(reg, adr._base, adr._xmmindex, adr._scale, adr._disp, adr._rspec);
1160     } else {
1161        emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,
1162        adr._rspec);
1163     }
1164 }
1165 





















1166 // Now the Assembler instructions (identical for 32/64 bits)
1167 
1168 void Assembler::adcl(Address dst, int32_t imm32) {
1169   InstructionMark im(this);
1170   prefix(dst);
1171   emit_arith_operand(0x81, rdx, dst, imm32);
1172 }
1173 
1174 void Assembler::adcl(Address dst, Register src) {
1175   InstructionMark im(this);
1176   prefix(dst, src);
1177   emit_int8(0x11);
1178   emit_operand(src, dst);
1179 }
1180 
1181 void Assembler::adcl(Register dst, int32_t imm32) {
1182   prefix(dst);
1183   emit_arith(0x81, 0xD0, dst, imm32);
1184 }
1185 
</pre>
<hr />
<pre>
1228 void Assembler::addl(Register dst, int32_t imm32) {
1229   prefix(dst);
1230   emit_arith(0x81, 0xC0, dst, imm32);
1231 }
1232 
1233 void Assembler::addl(Register dst, Address src) {
1234   InstructionMark im(this);
1235   prefix(src, dst);
1236   emit_int8(0x03);
1237   emit_operand(dst, src);
1238 }
1239 
1240 void Assembler::addl(Register dst, Register src) {
1241   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
1242   emit_arith(0x03, 0xC0, dst, src);
1243 }
1244 
1245 void Assembler::addr_nop_4() {
1246   assert(UseAddressNop, &quot;no CPU support&quot;);
1247   // 4 bytes: NOP DWORD PTR [EAX+0]
<span class="line-modified">1248   emit_int32(0x0F,</span>
<span class="line-modified">1249              0x1F,</span>
<span class="line-modified">1250              0x40, // emit_rm(cbuf, 0x1, EAX_enc, EAX_enc);</span>
<span class="line-modified">1251              0);   // 8-bits offset (1 byte)</span>
1252 }
1253 
1254 void Assembler::addr_nop_5() {
1255   assert(UseAddressNop, &quot;no CPU support&quot;);
1256   // 5 bytes: NOP DWORD PTR [EAX+EAX*0+0] 8-bits offset
<span class="line-modified">1257   emit_int32(0x0F,</span>
<span class="line-modified">1258              0x1F,</span>
<span class="line-modified">1259              0x44,  // emit_rm(cbuf, 0x1, EAX_enc, 0x4);</span>
<span class="line-modified">1260              0x00); // emit_rm(cbuf, 0x0, EAX_enc, EAX_enc);</span>
<span class="line-modified">1261   emit_int8(0);     // 8-bits offset (1 byte)</span>
1262 }
1263 
1264 void Assembler::addr_nop_7() {
1265   assert(UseAddressNop, &quot;no CPU support&quot;);
1266   // 7 bytes: NOP DWORD PTR [EAX+0] 32-bits offset
<span class="line-modified">1267   emit_int24(0x0F,</span>
<span class="line-modified">1268              0x1F,</span>
<span class="line-modified">1269              (unsigned char)0x80);</span>
1270                    // emit_rm(cbuf, 0x2, EAX_enc, EAX_enc);
1271   emit_int32(0);   // 32-bits offset (4 bytes)
1272 }
1273 
1274 void Assembler::addr_nop_8() {
1275   assert(UseAddressNop, &quot;no CPU support&quot;);
1276   // 8 bytes: NOP DWORD PTR [EAX+EAX*0+0] 32-bits offset
<span class="line-modified">1277   emit_int32(0x0F,</span>
<span class="line-modified">1278              0x1F,</span>
<span class="line-modified">1279              (unsigned char)0x84,</span>
<span class="line-modified">1280                     // emit_rm(cbuf, 0x2, EAX_enc, 0x4);</span>
<span class="line-modified">1281              0x00); // emit_rm(cbuf, 0x0, EAX_enc, EAX_enc);</span>
<span class="line-modified">1282   emit_int32(0);    // 32-bits offset (4 bytes)</span>
1283 }
1284 
1285 void Assembler::addsd(XMMRegister dst, XMMRegister src) {
1286   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1287   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1288   attributes.set_rex_vex_w_reverted();
1289   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1290   emit_int16(0x58, (0xC0 | encode));</span>

1291 }
1292 
1293 void Assembler::addsd(XMMRegister dst, Address src) {
1294   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1295   InstructionMark im(this);
1296   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1297   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
1298   attributes.set_rex_vex_w_reverted();
1299   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1300   emit_int8(0x58);
1301   emit_operand(dst, src);
1302 }
1303 
1304 void Assembler::addss(XMMRegister dst, XMMRegister src) {
1305   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1306   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1307   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1308   emit_int16(0x58, (0xC0 | encode));</span>

1309 }
1310 
1311 void Assembler::addss(XMMRegister dst, Address src) {
1312   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1313   InstructionMark im(this);
1314   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1315   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1316   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1317   emit_int8(0x58);
1318   emit_operand(dst, src);
1319 }
1320 
1321 void Assembler::aesdec(XMMRegister dst, Address src) {
1322   assert(VM_Version::supports_aes(), &quot;&quot;);
1323   InstructionMark im(this);
1324   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1325   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1326   emit_int8((unsigned char)0xDE);
1327   emit_operand(dst, src);
1328 }
1329 
1330 void Assembler::aesdec(XMMRegister dst, XMMRegister src) {
1331   assert(VM_Version::supports_aes(), &quot;&quot;);
1332   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1333   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1334   emit_int16((unsigned char)0xDE, (0xC0 | encode));</span>

1335 }
1336 
1337 void Assembler::vaesdec(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">1338   assert(VM_Version::supports_avx512_vaes(), &quot;&quot;);</span>
1339   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1340   attributes.set_is_evex_instruction();
1341   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1342   emit_int16((unsigned char)0xDE, (0xC0 | encode));</span>

1343 }
1344 
1345 
1346 void Assembler::aesdeclast(XMMRegister dst, Address src) {
1347   assert(VM_Version::supports_aes(), &quot;&quot;);
1348   InstructionMark im(this);
1349   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1350   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1351   emit_int8((unsigned char)0xDF);
1352   emit_operand(dst, src);
1353 }
1354 
1355 void Assembler::aesdeclast(XMMRegister dst, XMMRegister src) {
1356   assert(VM_Version::supports_aes(), &quot;&quot;);
1357   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1358   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1359   emit_int16((unsigned char)0xDF, (0xC0 | encode));</span>

1360 }
1361 
1362 void Assembler::vaesdeclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">1363   assert(VM_Version::supports_avx512_vaes(), &quot;&quot;);</span>
1364   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1365   attributes.set_is_evex_instruction();
1366   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1367   emit_int16((unsigned char)0xDF, (0xC0 | encode));</span>

1368 }
1369 
1370 void Assembler::aesenc(XMMRegister dst, Address src) {
1371   assert(VM_Version::supports_aes(), &quot;&quot;);
1372   InstructionMark im(this);
1373   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1374   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1375   emit_int8((unsigned char)0xDC);
1376   emit_operand(dst, src);
1377 }
1378 
1379 void Assembler::aesenc(XMMRegister dst, XMMRegister src) {
1380   assert(VM_Version::supports_aes(), &quot;&quot;);
1381   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1382   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1383   emit_int16((unsigned char)0xDC, 0xC0 | encode);</span>

1384 }
1385 
1386 void Assembler::vaesenc(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">1387   assert(VM_Version::supports_avx512_vaes(), &quot;requires vaes support/enabling&quot;);</span>
1388   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1389   attributes.set_is_evex_instruction();
1390   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1391   emit_int16((unsigned char)0xDC, (0xC0 | encode));</span>

1392 }
1393 
1394 void Assembler::aesenclast(XMMRegister dst, Address src) {
1395   assert(VM_Version::supports_aes(), &quot;&quot;);
1396   InstructionMark im(this);
1397   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1398   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
1399   emit_int8((unsigned char)0xDD);
1400   emit_operand(dst, src);
1401 }
1402 
1403 void Assembler::aesenclast(XMMRegister dst, XMMRegister src) {
1404   assert(VM_Version::supports_aes(), &quot;&quot;);
1405   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1406   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1407   emit_int16((unsigned char)0xDD, (0xC0 | encode));</span>

1408 }
1409 
1410 void Assembler::vaesenclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">1411   assert(VM_Version::supports_avx512_vaes(), &quot;requires vaes support/enabling&quot;);</span>
1412   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1413   attributes.set_is_evex_instruction();
1414   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1415   emit_int16((unsigned char)0xDD, (0xC0 | encode));</span>

1416 }
1417 
1418 void Assembler::andl(Address dst, int32_t imm32) {
1419   InstructionMark im(this);
1420   prefix(dst);
1421   emit_int8((unsigned char)0x81);
1422   emit_operand(rsp, dst, 4);
1423   emit_int32(imm32);
1424 }
1425 
1426 void Assembler::andl(Register dst, int32_t imm32) {
1427   prefix(dst);
1428   emit_arith(0x81, 0xE0, dst, imm32);
1429 }
1430 
1431 void Assembler::andl(Register dst, Address src) {
1432   InstructionMark im(this);
1433   prefix(src, dst);
1434   emit_int8(0x23);
1435   emit_operand(dst, src);
1436 }
1437 
1438 void Assembler::andl(Register dst, Register src) {
1439   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
1440   emit_arith(0x23, 0xC0, dst, src);
1441 }
1442 
1443 void Assembler::andnl(Register dst, Register src1, Register src2) {
1444   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1445   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1446   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1447   emit_int16((unsigned char)0xF2, (0xC0 | encode));</span>

1448 }
1449 
1450 void Assembler::andnl(Register dst, Register src1, Address src2) {
1451   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1452   InstructionMark im(this);
1453   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1454   vex_prefix(src2, src1-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1455   emit_int8((unsigned char)0xF2);
1456   emit_operand(dst, src2);
1457 }
1458 
1459 void Assembler::bsfl(Register dst, Register src) {
1460   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">1461   emit_int24(0x0F,</span>
<span class="line-modified">1462              (unsigned char)0xBC,</span>
<span class="line-modified">1463              0xC0 | encode);</span>
1464 }
1465 
1466 void Assembler::bsrl(Register dst, Register src) {
1467   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">1468   emit_int24(0x0F,</span>
<span class="line-modified">1469              (unsigned char)0xBD,</span>
<span class="line-modified">1470              0xC0 | encode);</span>
1471 }
1472 
1473 void Assembler::bswapl(Register reg) { // bswap
1474   int encode = prefix_and_encode(reg-&gt;encoding());
<span class="line-modified">1475   emit_int16(0x0F, (0xC8 | encode));</span>

1476 }
1477 
1478 void Assembler::blsil(Register dst, Register src) {
1479   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1480   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1481   int encode = vex_prefix_and_encode(rbx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1482   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>

1483 }
1484 
1485 void Assembler::blsil(Register dst, Address src) {
1486   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1487   InstructionMark im(this);
1488   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1489   vex_prefix(src, dst-&gt;encoding(), rbx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1490   emit_int8((unsigned char)0xF3);
1491   emit_operand(rbx, src);
1492 }
1493 
1494 void Assembler::blsmskl(Register dst, Register src) {
1495   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1496   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1497   int encode = vex_prefix_and_encode(rdx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1498   emit_int16((unsigned char)0xF3,</span>
<span class="line-modified">1499              0xC0 | encode);</span>
1500 }
1501 
1502 void Assembler::blsmskl(Register dst, Address src) {
1503   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1504   InstructionMark im(this);
1505   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1506   vex_prefix(src, dst-&gt;encoding(), rdx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1507   emit_int8((unsigned char)0xF3);
1508   emit_operand(rdx, src);
1509 }
1510 
1511 void Assembler::blsrl(Register dst, Register src) {
1512   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1513   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1514   int encode = vex_prefix_and_encode(rcx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1515   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>

1516 }
1517 
1518 void Assembler::blsrl(Register dst, Address src) {
1519   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
1520   InstructionMark im(this);
1521   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
1522   vex_prefix(src, dst-&gt;encoding(), rcx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
1523   emit_int8((unsigned char)0xF3);
1524   emit_operand(rcx, src);
1525 }
1526 
1527 void Assembler::call(Label&amp; L, relocInfo::relocType rtype) {
1528   // suspect disp32 is always good
1529   int operand = LP64_ONLY(disp32_operand) NOT_LP64(imm_operand);
1530 
1531   if (L.is_bound()) {
1532     const int long_size = 5;
1533     int offs = (int)( target(L) - pc() );
1534     assert(offs &lt;= 0, &quot;assembler error&quot;);
1535     InstructionMark im(this);
1536     // 1110 1000 #32-bit disp
1537     emit_int8((unsigned char)0xE8);
1538     emit_data(offs - long_size, rtype, operand);
1539   } else {
1540     InstructionMark im(this);
1541     // 1110 1000 #32-bit disp
1542     L.add_patch_at(code(), locator());
1543 
1544     emit_int8((unsigned char)0xE8);
1545     emit_data(int(0), rtype, operand);
1546   }
1547 }
1548 
1549 void Assembler::call(Register dst) {
1550   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">1551   emit_int16((unsigned char)0xFF, (0xD0 | encode));</span>

1552 }
1553 
1554 
1555 void Assembler::call(Address adr) {
1556   InstructionMark im(this);
1557   prefix(adr);
1558   emit_int8((unsigned char)0xFF);
1559   emit_operand(rdx, adr);
1560 }
1561 
1562 void Assembler::call_literal(address entry, RelocationHolder const&amp; rspec) {
1563   InstructionMark im(this);
1564   emit_int8((unsigned char)0xE8);
1565   intptr_t disp = entry - (pc() + sizeof(int32_t));
1566   // Entry is NULL in case of a scratch emit.
1567   assert(entry == NULL || is_simm32(disp), &quot;disp=&quot; INTPTR_FORMAT &quot; must be 32bit offset (call2)&quot;, disp);
1568   // Technically, should use call32_operand, but this format is
1569   // implied by the fact that we&#39;re emitting a call instruction.
1570 
1571   int operand = LP64_ONLY(disp32_operand) NOT_LP64(call32_operand);
1572   emit_data((int) disp, rspec, operand);
1573 }
1574 
1575 void Assembler::cdql() {
1576   emit_int8((unsigned char)0x99);
1577 }
1578 
1579 void Assembler::cld() {
1580   emit_int8((unsigned char)0xFC);
1581 }
1582 
1583 void Assembler::cmovl(Condition cc, Register dst, Register src) {
1584   NOT_LP64(guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;));
1585   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">1586   emit_int24(0x0F,</span>
<span class="line-modified">1587              0x40 | cc,</span>
<span class="line-modified">1588              0xC0 | encode);</span>
1589 }
1590 
1591 
1592 void Assembler::cmovl(Condition cc, Register dst, Address src) {
1593   NOT_LP64(guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;));
1594   prefix(src, dst);
<span class="line-modified">1595   emit_int16(0x0F, (0x40 | cc));</span>

1596   emit_operand(dst, src);
1597 }
1598 
1599 void Assembler::cmpb(Address dst, int imm8) {
1600   InstructionMark im(this);
1601   prefix(dst);
1602   emit_int8((unsigned char)0x80);
1603   emit_operand(rdi, dst, 1);
1604   emit_int8(imm8);
1605 }
1606 
1607 void Assembler::cmpl(Address dst, int32_t imm32) {
1608   InstructionMark im(this);
1609   prefix(dst);
1610   emit_int8((unsigned char)0x81);
1611   emit_operand(rdi, dst, 4);
1612   emit_int32(imm32);
1613 }
1614 
1615 void Assembler::cmpl(Register dst, int32_t imm32) {
1616   prefix(dst);
1617   emit_arith(0x81, 0xF8, dst, imm32);
1618 }
1619 
1620 void Assembler::cmpl(Register dst, Register src) {
1621   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
1622   emit_arith(0x3B, 0xC0, dst, src);
1623 }
1624 
1625 void Assembler::cmpl(Register dst, Address  src) {
1626   InstructionMark im(this);
1627   prefix(src, dst);
<span class="line-modified">1628   emit_int8(0x3B);</span>
1629   emit_operand(dst, src);
1630 }
1631 
1632 void Assembler::cmpw(Address dst, int imm16) {
1633   InstructionMark im(this);
1634   assert(!dst.base_needs_rex() &amp;&amp; !dst.index_needs_rex(), &quot;no extended registers&quot;);
<span class="line-modified">1635   emit_int16(0x66, (unsigned char)0x81);</span>

1636   emit_operand(rdi, dst, 2);
1637   emit_int16(imm16);
1638 }
1639 
1640 // The 32-bit cmpxchg compares the value at adr with the contents of rax,
1641 // and stores reg into adr if so; otherwise, the value at adr is loaded into rax,.
1642 // The ZF is set if the compared values were equal, and cleared otherwise.
1643 void Assembler::cmpxchgl(Register reg, Address adr) { // cmpxchg
1644   InstructionMark im(this);
1645   prefix(adr, reg);
<span class="line-modified">1646   emit_int16(0x0F, (unsigned char)0xB1);</span>

1647   emit_operand(reg, adr);
1648 }
1649 
1650 // The 8-bit cmpxchg compares the value at adr with the contents of rax,
1651 // and stores reg into adr if so; otherwise, the value at adr is loaded into rax,.
1652 // The ZF is set if the compared values were equal, and cleared otherwise.
1653 void Assembler::cmpxchgb(Register reg, Address adr) { // cmpxchg
1654   InstructionMark im(this);
1655   prefix(adr, reg, true);
<span class="line-modified">1656   emit_int16(0x0F, (unsigned char)0xB0);</span>

1657   emit_operand(reg, adr);
1658 }
1659 
1660 void Assembler::comisd(XMMRegister dst, Address src) {
1661   // NOTE: dbx seems to decode this as comiss even though the
1662   // 0x66 is there. Strangly ucomisd comes out correct
1663   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1664   InstructionMark im(this);
1665   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);;
1666   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
1667   attributes.set_rex_vex_w_reverted();
1668   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
1669   emit_int8(0x2F);
1670   emit_operand(dst, src);
1671 }
1672 
1673 void Assembler::comisd(XMMRegister dst, XMMRegister src) {
1674   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1675   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1676   attributes.set_rex_vex_w_reverted();
1677   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1678   emit_int16(0x2F, (0xC0 | encode));</span>

1679 }
1680 
1681 void Assembler::comiss(XMMRegister dst, Address src) {
1682   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1683   InstructionMark im(this);
1684   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1685   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1686   simd_prefix(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
1687   emit_int8(0x2F);
1688   emit_operand(dst, src);
1689 }
1690 
1691 void Assembler::comiss(XMMRegister dst, XMMRegister src) {
1692   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1693   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1694   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1695   emit_int16(0x2F, (0xC0 | encode));</span>

1696 }
1697 
1698 void Assembler::cpuid() {
<span class="line-modified">1699   emit_int16(0x0F, (unsigned char)0xA2);</span>

1700 }
1701 
1702 // Opcode / Instruction                      Op /  En  64 - Bit Mode     Compat / Leg Mode Description                  Implemented
1703 // F2 0F 38 F0 / r       CRC32 r32, r / m8   RM        Valid             Valid             Accumulate CRC32 on r / m8.  v
1704 // F2 REX 0F 38 F0 / r   CRC32 r32, r / m8*  RM        Valid             N.E.              Accumulate CRC32 on r / m8.  -
1705 // F2 REX.W 0F 38 F0 / r CRC32 r64, r / m8   RM        Valid             N.E.              Accumulate CRC32 on r / m8.  -
1706 //
1707 // F2 0F 38 F1 / r       CRC32 r32, r / m16  RM        Valid             Valid             Accumulate CRC32 on r / m16. v
1708 //
1709 // F2 0F 38 F1 / r       CRC32 r32, r / m32  RM        Valid             Valid             Accumulate CRC32 on r / m32. v
1710 //
1711 // F2 REX.W 0F 38 F1 / r CRC32 r64, r / m64  RM        Valid             N.E.              Accumulate CRC32 on r / m64. v
1712 void Assembler::crc32(Register crc, Register v, int8_t sizeInBytes) {
1713   assert(VM_Version::supports_sse4_2(), &quot;&quot;);
1714   int8_t w = 0x01;
1715   Prefix p = Prefix_EMPTY;
1716 
<span class="line-modified">1717   emit_int8((unsigned char)0xF2);</span>
1718   switch (sizeInBytes) {
1719   case 1:
1720     w = 0;
1721     break;
1722   case 2:
1723   case 4:
1724     break;
1725   LP64_ONLY(case 8:)
1726     // This instruction is not valid in 32 bits
1727     // Note:
1728     // http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf
1729     //
1730     // Page B - 72   Vol. 2C says
1731     // qwreg2 to qwreg            1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : 11 qwreg1 qwreg2
1732     // mem64 to qwreg             1111 0010 : 0100 1R0B : 0000 1111 : 0011 1000 : 1111 0000 : mod qwreg r / m
1733     //                                                                            F0!!!
1734     // while 3 - 208 Vol. 2A
1735     // F2 REX.W 0F 38 F1 / r       CRC32 r64, r / m64             RM         Valid      N.E.Accumulate CRC32 on r / m64.
1736     //
1737     // the 0 on a last bit is reserved for a different flavor of this instruction :
1738     // F2 REX.W 0F 38 F0 / r       CRC32 r64, r / m8              RM         Valid      N.E.Accumulate CRC32 on r / m8.
1739     p = REX_W;
1740     break;
1741   default:
1742     assert(0, &quot;Unsupported value for a sizeInBytes argument&quot;);
1743     break;
1744   }
1745   LP64_ONLY(prefix(crc, v, p);)
<span class="line-modified">1746   emit_int32(0x0F,</span>
<span class="line-modified">1747              0x38,</span>
<span class="line-modified">1748              0xF0 | w,</span>
<span class="line-modified">1749              0xC0 | ((crc-&gt;encoding() &amp; 0x7) &lt;&lt; 3) | (v-&gt;encoding() &amp; 7));</span>
1750 }
1751 
1752 void Assembler::crc32(Register crc, Address adr, int8_t sizeInBytes) {
1753   assert(VM_Version::supports_sse4_2(), &quot;&quot;);
1754   InstructionMark im(this);
1755   int8_t w = 0x01;
1756   Prefix p = Prefix_EMPTY;
1757 
1758   emit_int8((int8_t)0xF2);
1759   switch (sizeInBytes) {
1760   case 1:
1761     w = 0;
1762     break;
1763   case 2:
1764   case 4:
1765     break;
1766   LP64_ONLY(case 8:)
1767     // This instruction is not valid in 32 bits
1768     p = REX_W;
1769     break;
1770   default:
1771     assert(0, &quot;Unsupported value for a sizeInBytes argument&quot;);
1772     break;
1773   }
1774   LP64_ONLY(prefix(crc, adr, p);)
<span class="line-modified">1775   emit_int24(0x0F, 0x38, (0xF0 | w));</span>


1776   emit_operand(crc, adr);
1777 }
1778 
1779 void Assembler::cvtdq2pd(XMMRegister dst, XMMRegister src) {
1780   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1781   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1782   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1783   emit_int16((unsigned char)0xE6, (0xC0 | encode));</span>

1784 }
1785 
1786 void Assembler::cvtdq2ps(XMMRegister dst, XMMRegister src) {
1787   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1788   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1789   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1790   emit_int16(0x5B, (0xC0 | encode));</span>

1791 }
1792 
1793 void Assembler::cvtsd2ss(XMMRegister dst, XMMRegister src) {
1794   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1795   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1796   attributes.set_rex_vex_w_reverted();
1797   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1798   emit_int16(0x5A, (0xC0 | encode));</span>

1799 }
1800 
1801 void Assembler::cvtsd2ss(XMMRegister dst, Address src) {
1802   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1803   InstructionMark im(this);
1804   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1805   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
1806   attributes.set_rex_vex_w_reverted();
1807   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1808   emit_int8(0x5A);
1809   emit_operand(dst, src);
1810 }
1811 
1812 void Assembler::cvtsi2sdl(XMMRegister dst, Register src) {
1813   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1814   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1815   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1816   emit_int16(0x2A, (0xC0 | encode));</span>

1817 }
1818 
1819 void Assembler::cvtsi2sdl(XMMRegister dst, Address src) {
1820   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1821   InstructionMark im(this);
1822   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1823   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1824   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1825   emit_int8(0x2A);
1826   emit_operand(dst, src);
1827 }
1828 
1829 void Assembler::cvtsi2ssl(XMMRegister dst, Register src) {
1830   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1831   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1832   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1833   emit_int16(0x2A, (0xC0 | encode));</span>

1834 }
1835 
1836 void Assembler::cvtsi2ssl(XMMRegister dst, Address src) {
1837   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1838   InstructionMark im(this);
1839   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1840   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1841   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1842   emit_int8(0x2A);
1843   emit_operand(dst, src);
1844 }
1845 
1846 void Assembler::cvtsi2ssq(XMMRegister dst, Register src) {
1847   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1848   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1849   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1850   emit_int16(0x2A, (0xC0 | encode));</span>

1851 }
1852 
1853 void Assembler::cvtss2sd(XMMRegister dst, XMMRegister src) {
1854   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1855   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1856   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1857   emit_int16(0x5A, (0xC0 | encode));</span>

1858 }
1859 
1860 void Assembler::cvtss2sd(XMMRegister dst, Address src) {
1861   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1862   InstructionMark im(this);
1863   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1864   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1865   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1866   emit_int8(0x5A);
1867   emit_operand(dst, src);
1868 }
1869 
1870 
1871 void Assembler::cvttsd2sil(Register dst, XMMRegister src) {
1872   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1873   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1874   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1875   emit_int16(0x2C, (0xC0 | encode));</span>

1876 }
1877 
1878 void Assembler::cvttss2sil(Register dst, XMMRegister src) {
1879   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1880   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1881   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1882   emit_int16(0x2C, (0xC0 | encode));</span>

1883 }
1884 
1885 void Assembler::cvttpd2dq(XMMRegister dst, XMMRegister src) {
1886   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1887   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
1888   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1889   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1890   emit_int16((unsigned char)0xE6, (0xC0 | encode));</span>

1891 }
1892 
1893 void Assembler::pabsb(XMMRegister dst, XMMRegister src) {
1894   assert(VM_Version::supports_ssse3(), &quot;&quot;);
1895   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
1896   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1897   emit_int16(0x1C, (0xC0 | encode));</span>

1898 }
1899 
1900 void Assembler::pabsw(XMMRegister dst, XMMRegister src) {
1901   assert(VM_Version::supports_ssse3(), &quot;&quot;);
1902   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
1903   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1904   emit_int16(0x1D, (0xC0 | encode));</span>

1905 }
1906 
1907 void Assembler::pabsd(XMMRegister dst, XMMRegister src) {
1908   assert(VM_Version::supports_ssse3(), &quot;&quot;);
1909   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1910   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1911   emit_int16(0x1E, (0xC0 | encode));</span>

1912 }
1913 
1914 void Assembler::vpabsb(XMMRegister dst, XMMRegister src, int vector_len) {
1915   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
1916   vector_len == AVX_256bit? VM_Version::supports_avx2() :
1917   vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
1918   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
1919   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1920   emit_int16(0x1C, (0xC0 | encode));</span>

1921 }
1922 
1923 void Assembler::vpabsw(XMMRegister dst, XMMRegister src, int vector_len) {
1924   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
1925   vector_len == AVX_256bit? VM_Version::supports_avx2() :
1926   vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
1927   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
1928   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1929   emit_int16(0x1D, (0xC0 | encode));</span>

1930 }
1931 
1932 void Assembler::vpabsd(XMMRegister dst, XMMRegister src, int vector_len) {
1933   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
1934   vector_len == AVX_256bit? VM_Version::supports_avx2() :
1935   vector_len == AVX_512bit? VM_Version::supports_evex() : 0, &quot;&quot;);
1936   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1937   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1938   emit_int16(0x1E, (0xC0 | encode));</span>

1939 }
1940 
1941 void Assembler::evpabsq(XMMRegister dst, XMMRegister src, int vector_len) {
1942   assert(UseAVX &gt; 2, &quot;&quot;);
1943   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
1944   attributes.set_is_evex_instruction();
1945   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">1946   emit_int16(0x1F, (0xC0 | encode));</span>

1947 }
1948 
1949 void Assembler::decl(Address dst) {
1950   // Don&#39;t use it directly. Use MacroAssembler::decrement() instead.
1951   InstructionMark im(this);
1952   prefix(dst);
1953   emit_int8((unsigned char)0xFF);
1954   emit_operand(rcx, dst);
1955 }
1956 
1957 void Assembler::divsd(XMMRegister dst, Address src) {
1958   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1959   InstructionMark im(this);
1960   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1961   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
1962   attributes.set_rex_vex_w_reverted();
1963   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
1964   emit_int8(0x5E);
1965   emit_operand(dst, src);
1966 }
1967 
1968 void Assembler::divsd(XMMRegister dst, XMMRegister src) {
1969   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
1970   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1971   attributes.set_rex_vex_w_reverted();
1972   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1973   emit_int16(0x5E, (0xC0 | encode));</span>

1974 }
1975 
1976 void Assembler::divss(XMMRegister dst, Address src) {
1977   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1978   InstructionMark im(this);
1979   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1980   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
1981   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
1982   emit_int8(0x5E);
1983   emit_operand(dst, src);
1984 }
1985 
1986 void Assembler::divss(XMMRegister dst, XMMRegister src) {
1987   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
1988   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
1989   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">1990   emit_int16(0x5E, (0xC0 | encode));</span>







1991 }
1992 
1993 void Assembler::hlt() {
1994   emit_int8((unsigned char)0xF4);
1995 }
1996 
1997 void Assembler::idivl(Register src) {
1998   int encode = prefix_and_encode(src-&gt;encoding());
<span class="line-modified">1999   emit_int16((unsigned char)0xF7, (0xF8 | encode));</span>

2000 }
2001 
2002 void Assembler::divl(Register src) { // Unsigned
2003   int encode = prefix_and_encode(src-&gt;encoding());
<span class="line-modified">2004   emit_int16((unsigned char)0xF7, (0xF0 | encode));</span>

2005 }
2006 
2007 void Assembler::imull(Register src) {
2008   int encode = prefix_and_encode(src-&gt;encoding());
<span class="line-modified">2009   emit_int16((unsigned char)0xF7, (0xE8 | encode));</span>

2010 }
2011 
2012 void Assembler::imull(Register dst, Register src) {
2013   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">2014   emit_int24(0x0F,</span>
<span class="line-modified">2015              (unsigned char)0xAF,</span>
<span class="line-modified">2016              (0xC0 | encode));</span>
2017 }
2018 
2019 
2020 void Assembler::imull(Register dst, Register src, int value) {
2021   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
2022   if (is8bit(value)) {
<span class="line-modified">2023     emit_int24(0x6B, (0xC0 | encode), value &amp; 0xFF);</span>


2024   } else {
<span class="line-modified">2025     emit_int16(0x69, (0xC0 | encode));</span>

2026     emit_int32(value);
2027   }
2028 }
2029 
2030 void Assembler::imull(Register dst, Address src) {
2031   InstructionMark im(this);
2032   prefix(src, dst);
<span class="line-modified">2033   emit_int16(0x0F, (unsigned char)0xAF);</span>

2034   emit_operand(dst, src);
2035 }
2036 
2037 
2038 void Assembler::incl(Address dst) {
2039   // Don&#39;t use it directly. Use MacroAssembler::increment() instead.
2040   InstructionMark im(this);
2041   prefix(dst);
2042   emit_int8((unsigned char)0xFF);
2043   emit_operand(rax, dst);
2044 }
2045 
2046 void Assembler::jcc(Condition cc, Label&amp; L, bool maybe_short) {
2047   InstructionMark im(this);
2048   assert((0 &lt;= cc) &amp;&amp; (cc &lt; 16), &quot;illegal cc&quot;);
2049   if (L.is_bound()) {
2050     address dst = target(L);
2051     assert(dst != NULL, &quot;jcc most probably wrong&quot;);
2052 
2053     const int short_size = 2;
2054     const int long_size = 6;
2055     intptr_t offs = (intptr_t)dst - (intptr_t)pc();
2056     if (maybe_short &amp;&amp; is8bit(offs - short_size)) {
2057       // 0111 tttn #8-bit disp
<span class="line-modified">2058       emit_int16(0x70 | cc, (offs - short_size) &amp; 0xFF);</span>

2059     } else {
2060       // 0000 1111 1000 tttn #32-bit disp
2061       assert(is_simm32(offs - long_size),
2062              &quot;must be 32bit offset (call4)&quot;);
<span class="line-modified">2063       emit_int16(0x0F, (0x80 | cc));</span>

2064       emit_int32(offs - long_size);
2065     }
2066   } else {
2067     // Note: could eliminate cond. jumps to this jump if condition
2068     //       is the same however, seems to be rather unlikely case.
2069     // Note: use jccb() if label to be bound is very close to get
2070     //       an 8-bit displacement
2071     L.add_patch_at(code(), locator());
<span class="line-modified">2072     emit_int16(0x0F, (0x80 | cc));</span>

2073     emit_int32(0);
2074   }
2075 }
2076 
2077 void Assembler::jccb_0(Condition cc, Label&amp; L, const char* file, int line) {
2078   if (L.is_bound()) {
2079     const int short_size = 2;
2080     address entry = target(L);
2081 #ifdef ASSERT
2082     intptr_t dist = (intptr_t)entry - ((intptr_t)pc() + short_size);
2083     intptr_t delta = short_branch_delta();
2084     if (delta != 0) {
2085       dist += (dist &lt; 0 ? (-delta) :delta);
2086     }
2087     assert(is8bit(dist), &quot;Dispacement too large for a short jmp at %s:%d&quot;, file, line);
2088 #endif
2089     intptr_t offs = (intptr_t)entry - (intptr_t)pc();
2090     // 0111 tttn #8-bit disp
<span class="line-modified">2091     emit_int16(0x70 | cc, (offs - short_size) &amp; 0xFF);</span>

2092   } else {
2093     InstructionMark im(this);
2094     L.add_patch_at(code(), locator(), file, line);
<span class="line-modified">2095     emit_int16(0x70 | cc, 0);</span>

2096   }
2097 }
2098 
2099 void Assembler::jmp(Address adr) {
2100   InstructionMark im(this);
2101   prefix(adr);
2102   emit_int8((unsigned char)0xFF);
2103   emit_operand(rsp, adr);
2104 }
2105 
2106 void Assembler::jmp(Label&amp; L, bool maybe_short) {
2107   if (L.is_bound()) {
2108     address entry = target(L);
2109     assert(entry != NULL, &quot;jmp most probably wrong&quot;);
2110     InstructionMark im(this);
2111     const int short_size = 2;
2112     const int long_size = 5;
2113     intptr_t offs = entry - pc();
2114     if (maybe_short &amp;&amp; is8bit(offs - short_size)) {
<span class="line-modified">2115       emit_int16((unsigned char)0xEB, ((offs - short_size) &amp; 0xFF));</span>

2116     } else {
2117       emit_int8((unsigned char)0xE9);
2118       emit_int32(offs - long_size);
2119     }
2120   } else {
2121     // By default, forward jumps are always 32-bit displacements, since
2122     // we can&#39;t yet know where the label will be bound.  If you&#39;re sure that
2123     // the forward jump will not run beyond 256 bytes, use jmpb to
2124     // force an 8-bit displacement.
2125     InstructionMark im(this);
2126     L.add_patch_at(code(), locator());
2127     emit_int8((unsigned char)0xE9);
2128     emit_int32(0);
2129   }
2130 }
2131 
2132 void Assembler::jmp(Register entry) {
2133   int encode = prefix_and_encode(entry-&gt;encoding());
<span class="line-modified">2134   emit_int16((unsigned char)0xFF, (0xE0 | encode));</span>

2135 }
2136 
2137 void Assembler::jmp_literal(address dest, RelocationHolder const&amp; rspec) {
2138   InstructionMark im(this);
2139   emit_int8((unsigned char)0xE9);
2140   assert(dest != NULL, &quot;must have a target&quot;);
2141   intptr_t disp = dest - (pc() + sizeof(int32_t));
2142   assert(is_simm32(disp), &quot;must be 32bit offset (jmp)&quot;);
2143   emit_data(disp, rspec.reloc(), call32_operand);
2144 }
2145 
2146 void Assembler::jmpb_0(Label&amp; L, const char* file, int line) {
2147   if (L.is_bound()) {
2148     const int short_size = 2;
2149     address entry = target(L);
2150     assert(entry != NULL, &quot;jmp most probably wrong&quot;);
2151 #ifdef ASSERT
2152     intptr_t dist = (intptr_t)entry - ((intptr_t)pc() + short_size);
2153     intptr_t delta = short_branch_delta();
2154     if (delta != 0) {
2155       dist += (dist &lt; 0 ? (-delta) :delta);
2156     }
2157     assert(is8bit(dist), &quot;Dispacement too large for a short jmp at %s:%d&quot;, file, line);
2158 #endif
2159     intptr_t offs = entry - pc();
<span class="line-modified">2160     emit_int16((unsigned char)0xEB, (offs - short_size) &amp; 0xFF);</span>

2161   } else {
2162     InstructionMark im(this);
2163     L.add_patch_at(code(), locator(), file, line);
<span class="line-modified">2164     emit_int16((unsigned char)0xEB, 0);</span>

2165   }
2166 }
2167 
2168 void Assembler::ldmxcsr( Address src) {
2169   if (UseAVX &gt; 0 ) {
2170     InstructionMark im(this);
2171     InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2172     vex_prefix(src, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2173     emit_int8((unsigned char)0xAE);
2174     emit_operand(as_Register(2), src);
2175   } else {
2176     NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2177     InstructionMark im(this);
2178     prefix(src);
<span class="line-modified">2179     emit_int16(0x0F, (unsigned char)0xAE);</span>

2180     emit_operand(as_Register(2), src);
2181   }
2182 }
2183 
2184 void Assembler::leal(Register dst, Address src) {
2185   InstructionMark im(this);
2186 #ifdef _LP64
2187   emit_int8(0x67); // addr32
2188   prefix(src, dst);
2189 #endif // LP64
2190   emit_int8((unsigned char)0x8D);
2191   emit_operand(dst, src);
2192 }
2193 
2194 void Assembler::lfence() {
<span class="line-modified">2195   emit_int24(0x0F, (unsigned char)0xAE, (unsigned char)0xE8);</span>


2196 }
2197 
2198 void Assembler::lock() {
2199   emit_int8((unsigned char)0xF0);
2200 }
2201 
2202 void Assembler::lzcntl(Register dst, Register src) {
2203   assert(VM_Version::supports_lzcnt(), &quot;encoding is treated as BSR&quot;);
2204   emit_int8((unsigned char)0xF3);
2205   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">2206   emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));</span>


2207 }
2208 
2209 // Emit mfence instruction
2210 void Assembler::mfence() {
2211   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;unsupported&quot;);)
<span class="line-modified">2212   emit_int24(0x0F, (unsigned char)0xAE, (unsigned char)0xF0);</span>


2213 }
2214 
2215 // Emit sfence instruction
2216 void Assembler::sfence() {
2217   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;unsupported&quot;);)
<span class="line-modified">2218   emit_int24(0x0F, (unsigned char)0xAE, (unsigned char)0xF8);</span>


2219 }
2220 
2221 void Assembler::mov(Register dst, Register src) {
2222   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2223 }
2224 
2225 void Assembler::movapd(XMMRegister dst, XMMRegister src) {
2226   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2227   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
2228   InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2229   attributes.set_rex_vex_w_reverted();
2230   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2231   emit_int16(0x28, (0xC0 | encode));</span>

2232 }
2233 
2234 void Assembler::movaps(XMMRegister dst, XMMRegister src) {
2235   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2236   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
2237   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2238   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2239   emit_int16(0x28, (0xC0 | encode));</span>

2240 }
2241 
2242 void Assembler::movlhps(XMMRegister dst, XMMRegister src) {
2243   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2244   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2245   int encode = simd_prefix_and_encode(dst, src, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2246   emit_int16(0x16, (0xC0 | encode));</span>

2247 }
2248 
2249 void Assembler::movb(Register dst, Address src) {
2250   NOT_LP64(assert(dst-&gt;has_byte_register(), &quot;must have byte register&quot;));
2251   InstructionMark im(this);
2252   prefix(src, dst, true);
2253   emit_int8((unsigned char)0x8A);
2254   emit_operand(dst, src);
2255 }
2256 
2257 void Assembler::movddup(XMMRegister dst, XMMRegister src) {
2258   NOT_LP64(assert(VM_Version::supports_sse3(), &quot;&quot;));
2259   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
2260   InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2261   attributes.set_rex_vex_w_reverted();
2262   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2263   emit_int16(0x12, 0xC0 | encode);</span>

2264 }
2265 
2266 void Assembler::kmovbl(KRegister dst, Register src) {
2267   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
2268   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2269   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2270   emit_int16((unsigned char)0x92, (0xC0 | encode));</span>

2271 }
2272 
2273 void Assembler::kmovbl(Register dst, KRegister src) {
2274   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
2275   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2276   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2277   emit_int16((unsigned char)0x93, (0xC0 | encode));</span>

2278 }
2279 
2280 void Assembler::kmovwl(KRegister dst, Register src) {
2281   assert(VM_Version::supports_evex(), &quot;&quot;);
2282   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2283   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2284   emit_int16((unsigned char)0x92, (0xC0 | encode));</span>

2285 }
2286 
2287 void Assembler::kmovwl(Register dst, KRegister src) {
2288   assert(VM_Version::supports_evex(), &quot;&quot;);
2289   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2290   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2291   emit_int16((unsigned char)0x93, (0xC0 | encode));</span>

2292 }
2293 
2294 void Assembler::kmovwl(KRegister dst, Address src) {
2295   assert(VM_Version::supports_evex(), &quot;&quot;);
2296   InstructionMark im(this);
2297   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2298   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2299   emit_int8((unsigned char)0x90);
2300   emit_operand((Register)dst, src);
2301 }
2302 
2303 void Assembler::kmovdl(KRegister dst, Register src) {
2304   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2305   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2306   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2307   emit_int16((unsigned char)0x92, (0xC0 | encode));</span>

2308 }
2309 
2310 void Assembler::kmovdl(Register dst, KRegister src) {
2311   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2312   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2313   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2314   emit_int16((unsigned char)0x93, (0xC0 | encode));</span>

2315 }
2316 
2317 void Assembler::kmovql(KRegister dst, KRegister src) {
2318   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2319   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2320   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2321   emit_int16((unsigned char)0x90, (0xC0 | encode));</span>

2322 }
2323 
2324 void Assembler::kmovql(KRegister dst, Address src) {
2325   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2326   InstructionMark im(this);
2327   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2328   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2329   emit_int8((unsigned char)0x90);
2330   emit_operand((Register)dst, src);
2331 }
2332 
2333 void Assembler::kmovql(Address dst, KRegister src) {
2334   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2335   InstructionMark im(this);
2336   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2337   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
2338   emit_int8((unsigned char)0x90);
2339   emit_operand((Register)src, dst);
2340 }
2341 
2342 void Assembler::kmovql(KRegister dst, Register src) {
2343   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2344   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2345   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2346   emit_int16((unsigned char)0x92, (0xC0 | encode));</span>

2347 }
2348 
2349 void Assembler::kmovql(Register dst, KRegister src) {
2350   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2351   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2352   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2353   emit_int16((unsigned char)0x93, (0xC0 | encode));</span>

2354 }
2355 
2356 void Assembler::knotwl(KRegister dst, KRegister src) {
2357   assert(VM_Version::supports_evex(), &quot;&quot;);
2358   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2359   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2360   emit_int16(0x44, (0xC0 | encode));</span>

2361 }
2362 
2363 // This instruction produces ZF or CF flags
2364 void Assembler::kortestbl(KRegister src1, KRegister src2) {
2365   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
2366   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2367   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2368   emit_int16((unsigned char)0x98, (0xC0 | encode));</span>

2369 }
2370 
2371 // This instruction produces ZF or CF flags
2372 void Assembler::kortestwl(KRegister src1, KRegister src2) {
2373   assert(VM_Version::supports_evex(), &quot;&quot;);
2374   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2375   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2376   emit_int16((unsigned char)0x98, (0xC0 | encode));</span>

2377 }
2378 
2379 // This instruction produces ZF or CF flags
2380 void Assembler::kortestdl(KRegister src1, KRegister src2) {
2381   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2382   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2383   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2384   emit_int16((unsigned char)0x98, (0xC0 | encode));</span>

2385 }
2386 
2387 // This instruction produces ZF or CF flags
2388 void Assembler::kortestql(KRegister src1, KRegister src2) {
2389   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2390   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2391   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2392   emit_int16((unsigned char)0x98, (0xC0 | encode));</span>

2393 }
2394 
2395 // This instruction produces ZF or CF flags
2396 void Assembler::ktestql(KRegister src1, KRegister src2) {
2397   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2398   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2399   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2400   emit_int16((unsigned char)0x99, (0xC0 | encode));</span>

2401 }
2402 
2403 void Assembler::ktestq(KRegister src1, KRegister src2) {
2404   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2405   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2406   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2407   emit_int16((unsigned char)0x99, (0xC0 | encode));</span>

2408 }
2409 
2410 void Assembler::ktestd(KRegister src1, KRegister src2) {
2411   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
2412   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
2413   int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2414   emit_int16((unsigned char)0x99, (0xC0 | encode));</span>

2415 }
2416 
2417 void Assembler::movb(Address dst, int imm8) {
2418   InstructionMark im(this);
2419    prefix(dst);
2420   emit_int8((unsigned char)0xC6);
2421   emit_operand(rax, dst, 1);
2422   emit_int8(imm8);
2423 }
2424 
2425 
2426 void Assembler::movb(Address dst, Register src) {
2427   assert(src-&gt;has_byte_register(), &quot;must have byte register&quot;);
2428   InstructionMark im(this);
2429   prefix(dst, src, true);
2430   emit_int8((unsigned char)0x88);
2431   emit_operand(src, dst);
2432 }
2433 
2434 void Assembler::movdl(XMMRegister dst, Register src) {
2435   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2436   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2437   int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2438   emit_int16(0x6E, (0xC0 | encode));</span>

2439 }
2440 
2441 void Assembler::movdl(Register dst, XMMRegister src) {
2442   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2443   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2444   // swap src/dst to get correct prefix
2445   int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2446   emit_int16(0x7E, (0xC0 | encode));</span>

2447 }
2448 
2449 void Assembler::movdl(XMMRegister dst, Address src) {
2450   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2451   InstructionMark im(this);
2452   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2453   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2454   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2455   emit_int8(0x6E);
2456   emit_operand(dst, src);
2457 }
2458 
2459 void Assembler::movdl(Address dst, XMMRegister src) {
2460   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2461   InstructionMark im(this);
2462   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2463   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2464   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2465   emit_int8(0x7E);
2466   emit_operand(src, dst);
2467 }
2468 
2469 void Assembler::movdqa(XMMRegister dst, XMMRegister src) {
2470   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2471   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2472   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2473   emit_int16(0x6F, (0xC0 | encode));</span>

2474 }
2475 
2476 void Assembler::movdqa(XMMRegister dst, Address src) {
2477   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2478   InstructionMark im(this);
2479   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2480   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2481   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2482   emit_int8(0x6F);
2483   emit_operand(dst, src);
2484 }
2485 
2486 void Assembler::movdqu(XMMRegister dst, Address src) {
2487   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2488   InstructionMark im(this);
2489   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2490   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2491   simd_prefix(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2492   emit_int8(0x6F);
2493   emit_operand(dst, src);
2494 }
2495 
2496 void Assembler::movdqu(XMMRegister dst, XMMRegister src) {
2497   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2498   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2499   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2500   emit_int16(0x6F, (0xC0 | encode));</span>

2501 }
2502 
2503 void Assembler::movdqu(Address dst, XMMRegister src) {
2504   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2505   InstructionMark im(this);
2506   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2507   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2508   attributes.reset_is_clear_context();
2509   simd_prefix(src, xnoreg, dst, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2510   emit_int8(0x7F);
2511   emit_operand(src, dst);
2512 }
2513 
2514 // Move Unaligned 256bit Vector
2515 void Assembler::vmovdqu(XMMRegister dst, XMMRegister src) {
2516   assert(UseAVX &gt; 0, &quot;&quot;);
2517   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2518   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2519   emit_int16(0x6F, (0xC0 | encode));</span>

2520 }
2521 
2522 void Assembler::vmovdqu(XMMRegister dst, Address src) {
2523   assert(UseAVX &gt; 0, &quot;&quot;);
2524   InstructionMark im(this);
2525   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2526   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2527   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2528   emit_int8(0x6F);
2529   emit_operand(dst, src);
2530 }
2531 
2532 void Assembler::vmovdqu(Address dst, XMMRegister src) {
2533   assert(UseAVX &gt; 0, &quot;&quot;);
2534   InstructionMark im(this);
2535   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2536   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2537   attributes.reset_is_clear_context();
2538   // swap src&lt;-&gt;dst for encoding
2539   assert(src != xnoreg, &quot;sanity&quot;);
2540   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2541   emit_int8(0x7F);
2542   emit_operand(src, dst);
2543 }
2544 
2545 // Move Unaligned EVEX enabled Vector (programmable : 8,16,32,64)
2546 void Assembler::evmovdqub(XMMRegister dst, XMMRegister src, int vector_len) {
2547   assert(VM_Version::supports_evex(), &quot;&quot;);
2548   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
2549   attributes.set_is_evex_instruction();
2550   int prefix = (_legacy_mode_bw) ? VEX_SIMD_F2 : VEX_SIMD_F3;
2551   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), (Assembler::VexSimdPrefix)prefix, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2552   emit_int16(0x6F, (0xC0 | encode));</span>

2553 }
2554 
2555 void Assembler::evmovdqub(XMMRegister dst, Address src, int vector_len) {
2556   assert(VM_Version::supports_evex(), &quot;&quot;);
2557   InstructionMark im(this);
2558   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
2559   int prefix = (_legacy_mode_bw) ? VEX_SIMD_F2 : VEX_SIMD_F3;
2560   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2561   attributes.set_is_evex_instruction();
2562   vex_prefix(src, 0, dst-&gt;encoding(), (Assembler::VexSimdPrefix)prefix, VEX_OPCODE_0F, &amp;attributes);
2563   emit_int8(0x6F);
2564   emit_operand(dst, src);
2565 }
2566 
2567 void Assembler::evmovdqub(Address dst, XMMRegister src, int vector_len) {
2568   assert(VM_Version::supports_evex(), &quot;&quot;);
2569   assert(src != xnoreg, &quot;sanity&quot;);
2570   InstructionMark im(this);
2571   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
2572   int prefix = (_legacy_mode_bw) ? VEX_SIMD_F2 : VEX_SIMD_F3;
</pre>
<hr />
<pre>
2628 
2629 void Assembler::evmovdquw(Address dst, KRegister mask, XMMRegister src, int vector_len) {
2630   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
2631   assert(src != xnoreg, &quot;sanity&quot;);
2632   InstructionMark im(this);
2633   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
2634   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2635   attributes.reset_is_clear_context();
2636   attributes.set_embedded_opmask_register_specifier(mask);
2637   attributes.set_is_evex_instruction();
2638   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2639   emit_int8(0x7F);
2640   emit_operand(src, dst);
2641 }
2642 
2643 void Assembler::evmovdqul(XMMRegister dst, XMMRegister src, int vector_len) {
2644   assert(VM_Version::supports_evex(), &quot;&quot;);
2645   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2646   attributes.set_is_evex_instruction();
2647   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2648   emit_int16(0x6F, (0xC0 | encode));</span>

2649 }
2650 
2651 void Assembler::evmovdqul(XMMRegister dst, Address src, int vector_len) {
2652   assert(VM_Version::supports_evex(), &quot;&quot;);
2653   InstructionMark im(this);
2654   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true , /* uses_vl */ true);
2655   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2656   attributes.set_is_evex_instruction();
2657   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2658   emit_int8(0x6F);
2659   emit_operand(dst, src);
2660 }
2661 
2662 void Assembler::evmovdqul(Address dst, XMMRegister src, int vector_len) {
2663   assert(VM_Version::supports_evex(), &quot;&quot;);
2664   assert(src != xnoreg, &quot;sanity&quot;);
2665   InstructionMark im(this);
2666   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2667   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2668   attributes.reset_is_clear_context();
2669   attributes.set_is_evex_instruction();
2670   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2671   emit_int8(0x7F);
2672   emit_operand(src, dst);
2673 }
2674 
2675 void Assembler::evmovdquq(XMMRegister dst, XMMRegister src, int vector_len) {
2676   assert(VM_Version::supports_evex(), &quot;&quot;);
2677   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2678   attributes.set_is_evex_instruction();
2679   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2680   emit_int16(0x6F, (0xC0 | encode));</span>

2681 }
2682 
2683 void Assembler::evmovdquq(XMMRegister dst, Address src, int vector_len) {
2684   assert(VM_Version::supports_evex(), &quot;&quot;);
2685   InstructionMark im(this);
2686   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2687   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2688   attributes.set_is_evex_instruction();
2689   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2690   emit_int8(0x6F);
2691   emit_operand(dst, src);
2692 }
2693 
2694 void Assembler::evmovdquq(Address dst, XMMRegister src, int vector_len) {
2695   assert(VM_Version::supports_evex(), &quot;&quot;);
2696   assert(src != xnoreg, &quot;sanity&quot;);
2697   InstructionMark im(this);
2698   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2699   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
2700   attributes.reset_is_clear_context();
2701   attributes.set_is_evex_instruction();
2702   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2703   emit_int8(0x7F);
2704   emit_operand(src, dst);
2705 }
2706 
2707 // Uses zero extension on 64bit
2708 
2709 void Assembler::movl(Register dst, int32_t imm32) {
2710   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">2711   emit_int8(0xB8 | encode);</span>
2712   emit_int32(imm32);
2713 }
2714 
2715 void Assembler::movl(Register dst, Register src) {
2716   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">2717   emit_int16((unsigned char)0x8B, (0xC0 | encode));</span>

2718 }
2719 
2720 void Assembler::movl(Register dst, Address src) {
2721   InstructionMark im(this);
2722   prefix(src, dst);
2723   emit_int8((unsigned char)0x8B);
2724   emit_operand(dst, src);
2725 }
2726 
2727 void Assembler::movl(Address dst, int32_t imm32) {
2728   InstructionMark im(this);
2729   prefix(dst);
2730   emit_int8((unsigned char)0xC7);
2731   emit_operand(rax, dst, 4);
2732   emit_int32(imm32);
2733 }
2734 
2735 void Assembler::movl(Address dst, Register src) {
2736   InstructionMark im(this);
2737   prefix(dst, src);
2738   emit_int8((unsigned char)0x89);
2739   emit_operand(src, dst);
2740 }
2741 
2742 // New cpus require to use movsd and movss to avoid partial register stall
2743 // when loading from memory. But for old Opteron use movlpd instead of movsd.
2744 // The selection is done in MacroAssembler::movdbl() and movflt().
2745 void Assembler::movlpd(XMMRegister dst, Address src) {
2746   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2747   InstructionMark im(this);
2748   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
2749   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2750   attributes.set_rex_vex_w_reverted();
2751   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2752   emit_int8(0x12);
2753   emit_operand(dst, src);
2754 }
2755 




















2756 void Assembler::movq(XMMRegister dst, Address src) {
2757   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2758   InstructionMark im(this);
2759   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2760   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2761   attributes.set_rex_vex_w_reverted();
2762   simd_prefix(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2763   emit_int8(0x7E);
2764   emit_operand(dst, src);
2765 }
2766 
2767 void Assembler::movq(Address dst, XMMRegister src) {
2768   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2769   InstructionMark im(this);
2770   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2771   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2772   attributes.set_rex_vex_w_reverted();
2773   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
2774   emit_int8((unsigned char)0xD6);
2775   emit_operand(src, dst);
2776 }
2777 
2778 void Assembler::movsbl(Register dst, Address src) { // movsxb
2779   InstructionMark im(this);
2780   prefix(src, dst);
<span class="line-modified">2781   emit_int16(0x0F, (unsigned char)0xBE);</span>

2782   emit_operand(dst, src);
2783 }
2784 
2785 void Assembler::movsbl(Register dst, Register src) { // movsxb
2786   NOT_LP64(assert(src-&gt;has_byte_register(), &quot;must have byte register&quot;));
2787   int encode = prefix_and_encode(dst-&gt;encoding(), false, src-&gt;encoding(), true);
<span class="line-modified">2788   emit_int24(0x0F, (unsigned char)0xBE, (0xC0 | encode));</span>


2789 }
2790 
2791 void Assembler::movsd(XMMRegister dst, XMMRegister src) {
2792   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2793   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2794   attributes.set_rex_vex_w_reverted();
2795   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2796   emit_int16(0x10, (0xC0 | encode));</span>

2797 }
2798 
2799 void Assembler::movsd(XMMRegister dst, Address src) {
2800   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2801   InstructionMark im(this);
2802   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2803   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2804   attributes.set_rex_vex_w_reverted();
2805   simd_prefix(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2806   emit_int8(0x10);
2807   emit_operand(dst, src);
2808 }
2809 
2810 void Assembler::movsd(Address dst, XMMRegister src) {
2811   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2812   InstructionMark im(this);
2813   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2814   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2815   attributes.reset_is_clear_context();
2816   attributes.set_rex_vex_w_reverted();
2817   simd_prefix(src, xnoreg, dst, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2818   emit_int8(0x11);
2819   emit_operand(src, dst);
2820 }
2821 
2822 void Assembler::movss(XMMRegister dst, XMMRegister src) {
2823   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2824   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2825   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2826   emit_int16(0x10, (0xC0 | encode));</span>

2827 }
2828 
2829 void Assembler::movss(XMMRegister dst, Address src) {
2830   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2831   InstructionMark im(this);
2832   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2833   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2834   simd_prefix(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2835   emit_int8(0x10);
2836   emit_operand(dst, src);
2837 }
2838 
2839 void Assembler::movss(Address dst, XMMRegister src) {
2840   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2841   InstructionMark im(this);
2842   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2843   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2844   attributes.reset_is_clear_context();
2845   simd_prefix(src, xnoreg, dst, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2846   emit_int8(0x11);
2847   emit_operand(src, dst);
2848 }
2849 
2850 void Assembler::movswl(Register dst, Address src) { // movsxw
2851   InstructionMark im(this);
2852   prefix(src, dst);
<span class="line-modified">2853   emit_int16(0x0F, (unsigned char)0xBF);</span>

2854   emit_operand(dst, src);
2855 }
2856 
2857 void Assembler::movswl(Register dst, Register src) { // movsxw
2858   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">2859   emit_int24(0x0F, (unsigned char)0xBF, (0xC0 | encode));</span>


2860 }
2861 
2862 void Assembler::movw(Address dst, int imm16) {
2863   InstructionMark im(this);
2864 
2865   emit_int8(0x66); // switch to 16-bit mode
2866   prefix(dst);
2867   emit_int8((unsigned char)0xC7);
2868   emit_operand(rax, dst, 2);
2869   emit_int16(imm16);
2870 }
2871 
2872 void Assembler::movw(Register dst, Address src) {
2873   InstructionMark im(this);
2874   emit_int8(0x66);
2875   prefix(src, dst);
2876   emit_int8((unsigned char)0x8B);
2877   emit_operand(dst, src);
2878 }
2879 
2880 void Assembler::movw(Address dst, Register src) {
2881   InstructionMark im(this);
2882   emit_int8(0x66);
2883   prefix(dst, src);
2884   emit_int8((unsigned char)0x89);
2885   emit_operand(src, dst);
2886 }
2887 
2888 void Assembler::movzbl(Register dst, Address src) { // movzxb
2889   InstructionMark im(this);
2890   prefix(src, dst);
<span class="line-modified">2891   emit_int16(0x0F, (unsigned char)0xB6);</span>

2892   emit_operand(dst, src);
2893 }
2894 
2895 void Assembler::movzbl(Register dst, Register src) { // movzxb
2896   NOT_LP64(assert(src-&gt;has_byte_register(), &quot;must have byte register&quot;));
2897   int encode = prefix_and_encode(dst-&gt;encoding(), false, src-&gt;encoding(), true);
<span class="line-modified">2898   emit_int24(0x0F, (unsigned char)0xB6, 0xC0 | encode);</span>


2899 }
2900 
2901 void Assembler::movzwl(Register dst, Address src) { // movzxw
2902   InstructionMark im(this);
2903   prefix(src, dst);
<span class="line-modified">2904   emit_int16(0x0F, (unsigned char)0xB7);</span>

2905   emit_operand(dst, src);
2906 }
2907 
2908 void Assembler::movzwl(Register dst, Register src) { // movzxw
2909   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">2910   emit_int24(0x0F, (unsigned char)0xB7, 0xC0 | encode);</span>


2911 }
2912 
2913 void Assembler::mull(Address src) {
2914   InstructionMark im(this);
2915   prefix(src);
2916   emit_int8((unsigned char)0xF7);
2917   emit_operand(rsp, src);
2918 }
2919 
2920 void Assembler::mull(Register src) {
2921   int encode = prefix_and_encode(src-&gt;encoding());
<span class="line-modified">2922   emit_int16((unsigned char)0xF7, (0xE0 | encode));</span>

2923 }
2924 
2925 void Assembler::mulsd(XMMRegister dst, Address src) {
2926   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2927   InstructionMark im(this);
2928   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2929   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
2930   attributes.set_rex_vex_w_reverted();
2931   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
2932   emit_int8(0x59);
2933   emit_operand(dst, src);
2934 }
2935 
2936 void Assembler::mulsd(XMMRegister dst, XMMRegister src) {
2937   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
2938   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2939   attributes.set_rex_vex_w_reverted();
2940   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2941   emit_int16(0x59, (0xC0 | encode));</span>

2942 }
2943 
2944 void Assembler::mulss(XMMRegister dst, Address src) {
2945   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2946   InstructionMark im(this);
2947   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2948   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
2949   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
2950   emit_int8(0x59);
2951   emit_operand(dst, src);
2952 }
2953 
2954 void Assembler::mulss(XMMRegister dst, XMMRegister src) {
2955   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
2956   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
2957   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">2958   emit_int16(0x59, (0xC0 | encode));</span>

2959 }
2960 
2961 void Assembler::negl(Register dst) {
2962   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">2963   emit_int16((unsigned char)0xF7, (0xD8 | encode));</span>

2964 }
2965 
2966 void Assembler::nop(int i) {
2967 #ifdef ASSERT
2968   assert(i &gt; 0, &quot; &quot;);
2969   // The fancy nops aren&#39;t currently recognized by debuggers making it a
2970   // pain to disassemble code while debugging. If asserts are on clearly
2971   // speed is not an issue so simply use the single byte traditional nop
2972   // to do alignment.
2973 
2974   for (; i &gt; 0 ; i--) emit_int8((unsigned char)0x90);
2975   return;
2976 
2977 #endif // ASSERT
2978 
2979   if (UseAddressNop &amp;&amp; VM_Version::is_intel()) {
2980     //
2981     // Using multi-bytes nops &quot;0x0F 0x1F [address]&quot; for Intel
2982     //  1: 0x90
2983     //  2: 0x66 0x90
2984     //  3: 0x66 0x66 0x90 (don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding)
2985     //  4: 0x0F 0x1F 0x40 0x00
2986     //  5: 0x0F 0x1F 0x44 0x00 0x00
2987     //  6: 0x66 0x0F 0x1F 0x44 0x00 0x00
2988     //  7: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
2989     //  8: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
2990     //  9: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
2991     // 10: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
2992     // 11: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
2993 
2994     // The rest coding is Intel specific - don&#39;t use consecutive address nops
2995 
2996     // 12: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
2997     // 13: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
2998     // 14: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
2999     // 15: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3000 
3001     while(i &gt;= 15) {
3002       // For Intel don&#39;t generate consecutive addess nops (mix with regular nops)
3003       i -= 15;
<span class="line-modified">3004       emit_int24(0x66, 0x66, 0x66);</span>


3005       addr_nop_8();
<span class="line-modified">3006       emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>




3007     }
3008     switch (i) {
3009       case 14:
3010         emit_int8(0x66); // size prefix
3011       case 13:
3012         emit_int8(0x66); // size prefix
3013       case 12:
3014         addr_nop_8();
<span class="line-modified">3015         emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>




3016         break;
3017       case 11:
3018         emit_int8(0x66); // size prefix
3019       case 10:
3020         emit_int8(0x66); // size prefix
3021       case 9:
3022         emit_int8(0x66); // size prefix
3023       case 8:
3024         addr_nop_8();
3025         break;
3026       case 7:
3027         addr_nop_7();
3028         break;
3029       case 6:
3030         emit_int8(0x66); // size prefix
3031       case 5:
3032         addr_nop_5();
3033         break;
3034       case 4:
3035         addr_nop_4();
</pre>
<hr />
<pre>
3057     //  4: 0x0F 0x1F 0x40 0x00
3058     //  5: 0x0F 0x1F 0x44 0x00 0x00
3059     //  6: 0x66 0x0F 0x1F 0x44 0x00 0x00
3060     //  7: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
3061     //  8: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3062     //  9: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3063     // 10: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3064     // 11: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3065 
3066     // The rest coding is AMD specific - use consecutive address nops
3067 
3068     // 12: 0x66 0x0F 0x1F 0x44 0x00 0x00 0x66 0x0F 0x1F 0x44 0x00 0x00
3069     // 13: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00 0x66 0x0F 0x1F 0x44 0x00 0x00
3070     // 14: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
3071     // 15: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
3072     // 16: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3073     //     Size prefixes (0x66) are added for larger sizes
3074 
3075     while(i &gt;= 22) {
3076       i -= 11;
<span class="line-modified">3077       emit_int24(0x66, 0x66, 0x66);</span>


3078       addr_nop_8();
3079     }
3080     // Generate first nop for size between 21-12
3081     switch (i) {
3082       case 21:
3083         i -= 1;
3084         emit_int8(0x66); // size prefix
3085       case 20:
3086       case 19:
3087         i -= 1;
3088         emit_int8(0x66); // size prefix
3089       case 18:
3090       case 17:
3091         i -= 1;
3092         emit_int8(0x66); // size prefix
3093       case 16:
3094       case 15:
3095         i -= 8;
3096         addr_nop_8();
3097         break;
</pre>
<hr />
<pre>
3154     //  3: 0x66 0x66 0x90 (don&#39;t use &quot;0x0F 0x1F 0x00&quot; - need patching safe padding)
3155     //  4: 0x0F 0x1F 0x40 0x00
3156     //  5: 0x0F 0x1F 0x44 0x00 0x00
3157     //  6: 0x66 0x0F 0x1F 0x44 0x00 0x00
3158     //  7: 0x0F 0x1F 0x80 0x00 0x00 0x00 0x00
3159     //  8: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3160     //  9: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3161     // 10: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3162     // 11: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
3163 
3164     // The rest coding is ZX specific - don&#39;t use consecutive address nops
3165 
3166     // 12: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3167     // 13: 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3168     // 14: 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3169     // 15: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
3170 
3171     while (i &gt;= 15) {
3172       // For ZX don&#39;t generate consecutive addess nops (mix with regular nops)
3173       i -= 15;
<span class="line-modified">3174       emit_int24(0x66, 0x66, 0x66);</span>


3175       addr_nop_8();
<span class="line-modified">3176       emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>




3177     }
3178     switch (i) {
3179       case 14:
3180         emit_int8(0x66); // size prefix
3181       case 13:
3182         emit_int8(0x66); // size prefix
3183       case 12:
3184         addr_nop_8();
<span class="line-modified">3185         emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>




3186         break;
3187       case 11:
3188         emit_int8(0x66); // size prefix
3189       case 10:
3190         emit_int8(0x66); // size prefix
3191       case 9:
3192         emit_int8(0x66); // size prefix
3193       case 8:
3194         addr_nop_8();
3195         break;
3196       case 7:
3197         addr_nop_7();
3198         break;
3199       case 6:
3200         emit_int8(0x66); // size prefix
3201       case 5:
3202         addr_nop_5();
3203         break;
3204       case 4:
3205         addr_nop_4();
</pre>
<hr />
<pre>
3215         break;
3216       default:
3217         assert(i == 0, &quot; &quot;);
3218     }
3219     return;
3220   }
3221 
3222   // Using nops with size prefixes &quot;0x66 0x90&quot;.
3223   // From AMD Optimization Guide:
3224   //  1: 0x90
3225   //  2: 0x66 0x90
3226   //  3: 0x66 0x66 0x90
3227   //  4: 0x66 0x66 0x66 0x90
3228   //  5: 0x66 0x66 0x90 0x66 0x90
3229   //  6: 0x66 0x66 0x90 0x66 0x66 0x90
3230   //  7: 0x66 0x66 0x66 0x90 0x66 0x66 0x90
3231   //  8: 0x66 0x66 0x66 0x90 0x66 0x66 0x66 0x90
3232   //  9: 0x66 0x66 0x90 0x66 0x66 0x90 0x66 0x66 0x90
3233   // 10: 0x66 0x66 0x66 0x90 0x66 0x66 0x90 0x66 0x66 0x90
3234   //
<span class="line-modified">3235   while (i &gt; 12) {</span>
3236     i -= 4;
<span class="line-modified">3237     emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>




3238   }
3239   // 1 - 12 nops
<span class="line-modified">3240   if (i &gt; 8) {</span>
<span class="line-modified">3241     if (i &gt; 9) {</span>
3242       i -= 1;
3243       emit_int8(0x66);
3244     }
3245     i -= 3;
<span class="line-modified">3246     emit_int24(0x66, 0x66, (unsigned char)0x90);</span>


3247   }
3248   // 1 - 8 nops
<span class="line-modified">3249   if (i &gt; 4) {</span>
<span class="line-modified">3250     if (i &gt; 6) {</span>
3251       i -= 1;
3252       emit_int8(0x66);
3253     }
3254     i -= 3;
<span class="line-modified">3255     emit_int24(0x66, 0x66, (unsigned char)0x90);</span>


3256   }
3257   switch (i) {
3258     case 4:
3259       emit_int8(0x66);
3260     case 3:
3261       emit_int8(0x66);
3262     case 2:
3263       emit_int8(0x66);
3264     case 1:
3265       emit_int8((unsigned char)0x90);
3266       break;
3267     default:
3268       assert(i == 0, &quot; &quot;);
3269   }
3270 }
3271 
3272 void Assembler::notl(Register dst) {
3273   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">3274   emit_int16((unsigned char)0xF7, (0xD0 | encode));</span>

3275 }
3276 
3277 void Assembler::orl(Address dst, int32_t imm32) {
3278   InstructionMark im(this);
3279   prefix(dst);
3280   emit_arith_operand(0x81, rcx, dst, imm32);
3281 }
3282 
3283 void Assembler::orl(Register dst, int32_t imm32) {
3284   prefix(dst);
3285   emit_arith(0x81, 0xC8, dst, imm32);
3286 }
3287 
3288 void Assembler::orl(Register dst, Address src) {
3289   InstructionMark im(this);
3290   prefix(src, dst);
3291   emit_int8(0x0B);
3292   emit_operand(dst, src);
3293 }
3294 
</pre>
<hr />
<pre>
3310   emit_int8((unsigned char)0x80);
3311   emit_operand(rcx, dst, 1);
3312   emit_int8(imm8);
3313 }
3314 
3315 void Assembler::packuswb(XMMRegister dst, Address src) {
3316   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
3317   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
3318   InstructionMark im(this);
3319   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3320   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
3321   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3322   emit_int8(0x67);
3323   emit_operand(dst, src);
3324 }
3325 
3326 void Assembler::packuswb(XMMRegister dst, XMMRegister src) {
3327   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
3328   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3329   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3330   emit_int16(0x67, (0xC0 | encode));</span>

3331 }
3332 
3333 void Assembler::vpackuswb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3334   assert(UseAVX &gt; 0, &quot;some form of AVX must be enabled&quot;);
3335   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3336   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3337   emit_int16(0x67, (0xC0 | encode));</span>

3338 }
3339 
3340 void Assembler::vpermq(XMMRegister dst, XMMRegister src, int imm8, int vector_len) {
3341   assert(VM_Version::supports_avx2(), &quot;&quot;);
3342   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3343   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3344   emit_int24(0x00, (0xC0 | encode), imm8);</span>


3345 }
3346 
3347 void Assembler::vpermq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3348   assert(UseAVX &gt; 2, &quot;requires AVX512F&quot;);
3349   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3350   attributes.set_is_evex_instruction();
3351   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3352   emit_int16(0x36, (0xC0 | encode));</span>

3353 }
3354 
3355 void Assembler::vperm2i128(XMMRegister dst,  XMMRegister nds, XMMRegister src, int imm8) {
3356   assert(VM_Version::supports_avx2(), &quot;&quot;);
3357   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3358   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3359   emit_int24(0x46, (0xC0 | encode), imm8);</span>


3360 }
3361 
3362 void Assembler::vperm2f128(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8) {
3363   assert(VM_Version::supports_avx(), &quot;&quot;);
3364   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3365   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3366   emit_int24(0x06, (0xC0 | encode), imm8);</span>


3367 }
3368 
3369 void Assembler::evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3370   assert(VM_Version::supports_evex(), &quot;&quot;);
3371   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3372   attributes.set_is_evex_instruction();
3373   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3374   emit_int16(0x76, (0xC0 | encode));</span>

3375 }
3376 
3377 
3378 void Assembler::pause() {
<span class="line-modified">3379   emit_int16((unsigned char)0xF3, (unsigned char)0x90);</span>

3380 }
3381 
3382 void Assembler::ud2() {
<span class="line-modified">3383   emit_int16(0x0F, 0x0B);</span>

3384 }
3385 
3386 void Assembler::pcmpestri(XMMRegister dst, Address src, int imm8) {
3387   assert(VM_Version::supports_sse4_2(), &quot;&quot;);
3388   InstructionMark im(this);
3389   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3390   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3391   emit_int8(0x61);
3392   emit_operand(dst, src);
3393   emit_int8(imm8);
3394 }
3395 
3396 void Assembler::pcmpestri(XMMRegister dst, XMMRegister src, int imm8) {
3397   assert(VM_Version::supports_sse4_2(), &quot;&quot;);
3398   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3399   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3400   emit_int24(0x61, (0xC0 | encode), imm8);</span>


3401 }
3402 
3403 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3404 void Assembler::pcmpeqb(XMMRegister dst, XMMRegister src) {
3405   assert(VM_Version::supports_sse2(), &quot;&quot;);
3406   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3407   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3408   emit_int16(0x74, (0xC0 | encode));</span>

3409 }
3410 
3411 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3412 void Assembler::vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3413   assert(VM_Version::supports_avx(), &quot;&quot;);
3414   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3415   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3416   emit_int16(0x74, (0xC0 | encode));</span>

3417 }
3418 
3419 // In this context, kdst is written the mask used to process the equal components
3420 void Assembler::evpcmpeqb(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
3421   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
3422   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3423   attributes.set_is_evex_instruction();
3424   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3425   emit_int16(0x74, (0xC0 | encode));</span>

3426 }
3427 
3428 void Assembler::evpcmpgtb(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3429   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3430   InstructionMark im(this);
3431   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3432   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3433   attributes.set_is_evex_instruction();
3434   int dst_enc = kdst-&gt;encoding();
3435   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3436   emit_int8(0x64);
3437   emit_operand(as_Register(dst_enc), src);
3438 }
3439 
3440 void Assembler::evpcmpgtb(KRegister kdst, KRegister mask, XMMRegister nds, Address src, int vector_len) {
3441   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3442   InstructionMark im(this);
3443   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
3444   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3445   attributes.reset_is_clear_context();
3446   attributes.set_embedded_opmask_register_specifier(mask);
3447   attributes.set_is_evex_instruction();
3448   int dst_enc = kdst-&gt;encoding();
3449   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3450   emit_int8(0x64);
3451   emit_operand(as_Register(dst_enc), src);
3452 }
3453 
3454 void Assembler::evpcmpuw(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {
3455   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3456   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3457   attributes.set_is_evex_instruction();
3458   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3459   emit_int24(0x3E, (0xC0 | encode), vcc);</span>


3460 }
3461 
3462 void Assembler::evpcmpuw(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {
3463   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3464   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
3465   attributes.reset_is_clear_context();
3466   attributes.set_embedded_opmask_register_specifier(mask);
3467   attributes.set_is_evex_instruction();
3468   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3469   emit_int24(0x3E, (0xC0 | encode), vcc);</span>


3470 }
3471 
3472 void Assembler::evpcmpuw(KRegister kdst, XMMRegister nds, Address src, ComparisonPredicate vcc, int vector_len) {
3473   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3474   InstructionMark im(this);
3475   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3476   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3477   attributes.set_is_evex_instruction();
3478   int dst_enc = kdst-&gt;encoding();
3479   vex_prefix(src, nds-&gt;encoding(), kdst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3480   emit_int8(0x3E);
3481   emit_operand(as_Register(dst_enc), src);
3482   emit_int8(vcc);
3483 }
3484 
3485 void Assembler::evpcmpeqb(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3486   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
3487   InstructionMark im(this);
3488   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3489   attributes.set_is_evex_instruction();
</pre>
<hr />
<pre>
3495 }
3496 
3497 void Assembler::evpcmpeqb(KRegister kdst, KRegister mask, XMMRegister nds, Address src, int vector_len) {
3498   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3499   InstructionMark im(this);
3500   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_reg_mask */ false, /* uses_vl */ true);
3501   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3502   attributes.reset_is_clear_context();
3503   attributes.set_embedded_opmask_register_specifier(mask);
3504   attributes.set_is_evex_instruction();
3505   vex_prefix(src, nds-&gt;encoding(), kdst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3506   emit_int8(0x74);
3507   emit_operand(as_Register(kdst-&gt;encoding()), src);
3508 }
3509 
3510 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3511 void Assembler::pcmpeqw(XMMRegister dst, XMMRegister src) {
3512   assert(VM_Version::supports_sse2(), &quot;&quot;);
3513   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3514   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3515   emit_int16(0x75, (0xC0 | encode));</span>

3516 }
3517 
3518 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3519 void Assembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3520   assert(VM_Version::supports_avx(), &quot;&quot;);
3521   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3522   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3523   emit_int16(0x75, (0xC0 | encode));</span>

3524 }
3525 
3526 // In this context, kdst is written the mask used to process the equal components
3527 void Assembler::evpcmpeqw(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
3528   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
3529   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3530   attributes.set_is_evex_instruction();
3531   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3532   emit_int16(0x75, (0xC0 | encode));</span>

3533 }
3534 
3535 void Assembler::evpcmpeqw(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3536   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
3537   InstructionMark im(this);
3538   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3539   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
3540   attributes.set_is_evex_instruction();
3541   int dst_enc = kdst-&gt;encoding();
3542   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3543   emit_int8(0x75);
3544   emit_operand(as_Register(dst_enc), src);
3545 }
3546 
3547 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3548 void Assembler::pcmpeqd(XMMRegister dst, XMMRegister src) {
3549   assert(VM_Version::supports_sse2(), &quot;&quot;);
3550   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3551   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3552   emit_int16(0x76, (0xC0 | encode));</span>

3553 }
3554 
3555 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3556 void Assembler::vpcmpeqd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3557   assert(VM_Version::supports_avx(), &quot;&quot;);
3558   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3559   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3560   emit_int16(0x76, (0xC0 | encode));</span>

3561 }
3562 
3563 // In this context, kdst is written the mask used to process the equal components
3564 void Assembler::evpcmpeqd(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
3565   assert(VM_Version::supports_evex(), &quot;&quot;);
3566   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3567   attributes.set_is_evex_instruction();
3568   attributes.reset_is_clear_context();
3569   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3570   emit_int16(0x76, (0xC0 | encode));</span>

3571 }
3572 
3573 void Assembler::evpcmpeqd(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3574   assert(VM_Version::supports_evex(), &quot;&quot;);
3575   InstructionMark im(this);
3576   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3577   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
3578   attributes.reset_is_clear_context();
3579   attributes.set_is_evex_instruction();
3580   int dst_enc = kdst-&gt;encoding();
3581   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3582   emit_int8(0x76);
3583   emit_operand(as_Register(dst_enc), src);
3584 }
3585 
3586 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3587 void Assembler::pcmpeqq(XMMRegister dst, XMMRegister src) {
3588   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3589   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3590   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3591   emit_int16(0x29, (0xC0 | encode));</span>

3592 }
3593 
3594 // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
3595 void Assembler::vpcmpeqq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3596   assert(VM_Version::supports_avx(), &quot;&quot;);
3597   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3598   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3599   emit_int16(0x29, (0xC0 | encode));</span>

3600 }
3601 
3602 // In this context, kdst is written the mask used to process the equal components
3603 void Assembler::evpcmpeqq(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
3604   assert(VM_Version::supports_evex(), &quot;&quot;);
3605   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3606   attributes.reset_is_clear_context();
3607   attributes.set_is_evex_instruction();
3608   int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3609   emit_int16(0x29, (0xC0 | encode));</span>

3610 }
3611 
3612 // In this context, kdst is written the mask used to process the equal components
3613 void Assembler::evpcmpeqq(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
3614   assert(VM_Version::supports_evex(), &quot;&quot;);
3615   InstructionMark im(this);
3616   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3617   attributes.reset_is_clear_context();
3618   attributes.set_is_evex_instruction();
3619   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
3620   int dst_enc = kdst-&gt;encoding();
3621   vex_prefix(src, nds-&gt;encoding(), dst_enc, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
3622   emit_int8(0x29);
3623   emit_operand(as_Register(dst_enc), src);
3624 }
3625 
3626 void Assembler::pmovmskb(Register dst, XMMRegister src) {
3627   assert(VM_Version::supports_sse2(), &quot;&quot;);
3628   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3629   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3630   emit_int16((unsigned char)0xD7, (0xC0 | encode));</span>

3631 }
3632 
3633 void Assembler::vpmovmskb(Register dst, XMMRegister src) {
3634   assert(VM_Version::supports_avx2(), &quot;&quot;);
3635   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
3636   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3637   emit_int16((unsigned char)0xD7, (0xC0 | encode));</span>

3638 }
3639 
3640 void Assembler::pextrd(Register dst, XMMRegister src, int imm8) {
3641   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3642   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3643   int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3644   emit_int24(0x16, (0xC0 | encode), imm8);</span>


3645 }
3646 
3647 void Assembler::pextrd(Address dst, XMMRegister src, int imm8) {
3648   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3649   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3650   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
3651   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3652   emit_int8(0x16);
3653   emit_operand(src, dst);
3654   emit_int8(imm8);
3655 }
3656 
3657 void Assembler::pextrq(Register dst, XMMRegister src, int imm8) {
3658   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3659   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3660   int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3661   emit_int24(0x16, (0xC0 | encode), imm8);</span>


3662 }
3663 
3664 void Assembler::pextrq(Address dst, XMMRegister src, int imm8) {
3665   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3666   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3667   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
3668   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3669   emit_int8(0x16);
3670   emit_operand(src, dst);
3671   emit_int8(imm8);
3672 }
3673 
3674 void Assembler::pextrw(Register dst, XMMRegister src, int imm8) {
3675   assert(VM_Version::supports_sse2(), &quot;&quot;);
3676   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3677   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3678   emit_int24((unsigned char)0xC5, (0xC0 | encode), imm8);</span>


3679 }
3680 
3681 void Assembler::pextrw(Address dst, XMMRegister src, int imm8) {
3682   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3683   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3684   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_16bit);
3685   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3686   emit_int8(0x15);</span>
3687   emit_operand(src, dst);
3688   emit_int8(imm8);
3689 }
3690 
3691 void Assembler::pextrb(Address dst, XMMRegister src, int imm8) {
3692   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3693   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3694   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_8bit);
3695   simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3696   emit_int8(0x14);
3697   emit_operand(src, dst);
3698   emit_int8(imm8);
3699 }
3700 
3701 void Assembler::pinsrd(XMMRegister dst, Register src, int imm8) {
3702   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3703   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3704   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3705   emit_int24(0x22, (0xC0 | encode), imm8);</span>


3706 }
3707 
3708 void Assembler::pinsrd(XMMRegister dst, Address src, int imm8) {
3709   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3710   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3711   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
3712   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3713   emit_int8(0x22);
3714   emit_operand(dst,src);
3715   emit_int8(imm8);
3716 }
3717 
3718 void Assembler::pinsrq(XMMRegister dst, Register src, int imm8) {
3719   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3720   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3721   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">3722   emit_int24(0x22, (0xC0 | encode), imm8);</span>


3723 }
3724 
3725 void Assembler::pinsrq(XMMRegister dst, Address src, int imm8) {
3726   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3727   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
3728   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
3729   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3730   emit_int8(0x22);
3731   emit_operand(dst, src);
3732   emit_int8(imm8);
3733 }
3734 
3735 void Assembler::pinsrw(XMMRegister dst, Register src, int imm8) {
3736   assert(VM_Version::supports_sse2(), &quot;&quot;);
3737   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3738   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3739   emit_int24((unsigned char)0xC4, (0xC0 | encode), imm8);</span>


3740 }
3741 
3742 void Assembler::pinsrw(XMMRegister dst, Address src, int imm8) {
3743   assert(VM_Version::supports_sse2(), &quot;&quot;);
3744   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3745   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_16bit);
3746   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
3747   emit_int8((unsigned char)0xC4);
3748   emit_operand(dst, src);
3749   emit_int8(imm8);
3750 }
3751 
3752 void Assembler::pinsrb(XMMRegister dst, Address src, int imm8) {
3753   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3754   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3755   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_8bit);
3756   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
3757   emit_int8(0x20);
3758   emit_operand(dst, src);
3759   emit_int8(imm8);
3760 }
3761 
3762 void Assembler::pmovzxbw(XMMRegister dst, Address src) {
3763   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3764   InstructionMark im(this);
3765   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3766   attributes.set_address_attributes(/* tuple_type */ EVEX_HVM, /* input_size_in_bits */ EVEX_NObit);
3767   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
3768   emit_int8(0x30);
3769   emit_operand(dst, src);
3770 }
3771 
3772 void Assembler::pmovzxbw(XMMRegister dst, XMMRegister src) {
3773   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3774   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3775   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3776   emit_int16(0x30, (0xC0 | encode));</span>

3777 }
3778 
3779 void Assembler::pmovsxbw(XMMRegister dst, XMMRegister src) {
3780   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
3781   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3782   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3783   emit_int16(0x20, (0xC0 | encode));</span>

3784 }
3785 
3786 void Assembler::vpmovzxbw(XMMRegister dst, Address src, int vector_len) {
3787   assert(VM_Version::supports_avx(), &quot;&quot;);
3788   InstructionMark im(this);
3789   assert(dst != xnoreg, &quot;sanity&quot;);
3790   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3791   attributes.set_address_attributes(/* tuple_type */ EVEX_HVM, /* input_size_in_bits */ EVEX_NObit);
3792   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
3793   emit_int8(0x30);
3794   emit_operand(dst, src);
3795 }
3796 
3797 void Assembler::vpmovzxbw(XMMRegister dst, XMMRegister src, int vector_len) {
3798   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
3799   vector_len == AVX_256bit? VM_Version::supports_avx2() :
3800   vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
3801   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3802   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3803   emit_int16(0x30, (unsigned char) (0xC0 | encode));</span>

3804 }
3805 
3806 void Assembler::vpmovsxbw(XMMRegister dst, XMMRegister src, int vector_len) {
3807   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
3808   vector_len == AVX_256bit? VM_Version::supports_avx2() :
3809   vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
3810   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3811   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3812   emit_int16(0x20, (0xC0 | encode));</span>

3813 }
3814 
3815 void Assembler::evpmovzxbw(XMMRegister dst, KRegister mask, Address src, int vector_len) {
3816   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3817   assert(dst != xnoreg, &quot;sanity&quot;);
3818   InstructionMark im(this);
3819   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
3820   attributes.set_address_attributes(/* tuple_type */ EVEX_HVM, /* input_size_in_bits */ EVEX_NObit);
3821   attributes.set_embedded_opmask_register_specifier(mask);
3822   attributes.set_is_evex_instruction();
3823   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
3824   emit_int8(0x30);
3825   emit_operand(dst, src);
3826 }
3827 void Assembler::evpmovwb(Address dst, XMMRegister src, int vector_len) {
3828   assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
3829   assert(src != xnoreg, &quot;sanity&quot;);
3830   InstructionMark im(this);
3831   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3832   attributes.set_address_attributes(/* tuple_type */ EVEX_HVM, /* input_size_in_bits */ EVEX_NObit);
</pre>
<hr />
<pre>
3851 }
3852 
3853 void Assembler::evpmovdb(Address dst, XMMRegister src, int vector_len) {
3854   assert(VM_Version::supports_evex(), &quot;&quot;);
3855   assert(src != xnoreg, &quot;sanity&quot;);
3856   InstructionMark im(this);
3857   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3858   attributes.set_address_attributes(/* tuple_type */ EVEX_QVM, /* input_size_in_bits */ EVEX_NObit);
3859   attributes.set_is_evex_instruction();
3860   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &amp;attributes);
3861   emit_int8(0x31);
3862   emit_operand(src, dst);
3863 }
3864 
3865 void Assembler::vpmovzxwd(XMMRegister dst, XMMRegister src, int vector_len) {
3866   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
3867   vector_len == AVX_256bit? VM_Version::supports_avx2() :
3868   vector_len == AVX_512bit? VM_Version::supports_evex() : 0, &quot; &quot;);
3869   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3870   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3871   emit_int16(0x33, (0xC0 | encode));</span>

3872 }
3873 
3874 void Assembler::pmaddwd(XMMRegister dst, XMMRegister src) {
3875   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
3876   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3877   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3878   emit_int16((unsigned char)0xF5, (0xC0 | encode));</span>

3879 }
3880 
3881 void Assembler::vpmaddwd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3882   assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
3883     (vector_len == AVX_256bit ? VM_Version::supports_avx2() :
3884     (vector_len == AVX_512bit ? VM_Version::supports_evex() : 0)), &quot;&quot;);
3885   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3886   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">3887   emit_int16((unsigned char)0xF5, (0xC0 | encode));</span>

3888 }
3889 
3890 void Assembler::evpdpwssd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3891   assert(VM_Version::supports_evex(), &quot;&quot;);
<span class="line-modified">3892   assert(VM_Version::supports_avx512_vnni(), &quot;must support vnni&quot;);</span>
3893   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3894   attributes.set_is_evex_instruction();
3895   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3896   emit_int16(0x52, (0xC0 | encode));</span>

3897 }
3898 
3899 // generic
3900 void Assembler::pop(Register dst) {
3901   int encode = prefix_and_encode(dst-&gt;encoding());
3902   emit_int8(0x58 | encode);
3903 }
3904 
3905 void Assembler::popcntl(Register dst, Address src) {
3906   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);
3907   InstructionMark im(this);
3908   emit_int8((unsigned char)0xF3);
3909   prefix(src, dst);
<span class="line-modified">3910   emit_int16(0x0F, (unsigned char)0xB8);</span>

3911   emit_operand(dst, src);
3912 }
3913 
3914 void Assembler::popcntl(Register dst, Register src) {
3915   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);
3916   emit_int8((unsigned char)0xF3);
3917   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">3918   emit_int24(0x0F, (unsigned char)0xB8, (0xC0 | encode));</span>


3919 }
3920 
3921 void Assembler::vpopcntd(XMMRegister dst, XMMRegister src, int vector_len) {
<span class="line-modified">3922   assert(VM_Version::supports_avx512_vpopcntdq(), &quot;must support vpopcntdq feature&quot;);</span>
3923   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
3924   attributes.set_is_evex_instruction();
3925   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3926   emit_int16(0x55, (0xC0 | encode));</span>

3927 }
3928 
3929 void Assembler::popf() {
3930   emit_int8((unsigned char)0x9D);
3931 }
3932 
3933 #ifndef _LP64 // no 32bit push/pop on amd64
3934 void Assembler::popl(Address dst) {
3935   // NOTE: this will adjust stack by 8byte on 64bits
3936   InstructionMark im(this);
3937   prefix(dst);
3938   emit_int8((unsigned char)0x8F);
3939   emit_operand(rax, dst);
3940 }
3941 #endif
3942 





3943 void Assembler::prefetchnta(Address src) {
3944   NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
3945   InstructionMark im(this);
<span class="line-modified">3946   prefix(src);</span>
<span class="line-modified">3947   emit_int16(0x0F, 0x18);</span>
3948   emit_operand(rax, src); // 0, src
3949 }
3950 
3951 void Assembler::prefetchr(Address src) {
3952   assert(VM_Version::supports_3dnow_prefetch(), &quot;must support&quot;);
3953   InstructionMark im(this);
<span class="line-modified">3954   prefix(src);</span>
<span class="line-modified">3955   emit_int16(0x0F, 0x0D);</span>
3956   emit_operand(rax, src); // 0, src
3957 }
3958 
3959 void Assembler::prefetcht0(Address src) {
3960   NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
3961   InstructionMark im(this);
<span class="line-modified">3962   prefix(src);</span>
<span class="line-modified">3963   emit_int16(0x0F, 0x18);</span>
3964   emit_operand(rcx, src); // 1, src
3965 }
3966 
3967 void Assembler::prefetcht1(Address src) {
3968   NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
3969   InstructionMark im(this);
<span class="line-modified">3970   prefix(src);</span>
<span class="line-modified">3971   emit_int16(0x0F, 0x18);</span>
3972   emit_operand(rdx, src); // 2, src
3973 }
3974 
3975 void Assembler::prefetcht2(Address src) {
3976   NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
3977   InstructionMark im(this);
<span class="line-modified">3978   prefix(src);</span>
<span class="line-modified">3979   emit_int16(0x0F, 0x18);</span>
3980   emit_operand(rbx, src); // 3, src
3981 }
3982 
3983 void Assembler::prefetchw(Address src) {
3984   assert(VM_Version::supports_3dnow_prefetch(), &quot;must support&quot;);
3985   InstructionMark im(this);
<span class="line-modified">3986   prefix(src);</span>
<span class="line-modified">3987   emit_int16(0x0F, 0x0D);</span>
3988   emit_operand(rcx, src); // 1, src
3989 }
3990 
3991 void Assembler::prefix(Prefix p) {
3992   emit_int8(p);
3993 }
3994 
3995 void Assembler::pshufb(XMMRegister dst, XMMRegister src) {
3996   assert(VM_Version::supports_ssse3(), &quot;&quot;);
3997   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
3998   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">3999   emit_int16(0x00, (0xC0 | encode));</span>

4000 }
4001 
4002 void Assembler::vpshufb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
4003   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
4004          vector_len == AVX_256bit? VM_Version::supports_avx2() :
4005          vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
4006   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4007   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">4008   emit_int16(0x00, (0xC0 | encode));</span>

4009 }
4010 
4011 void Assembler::pshufb(XMMRegister dst, Address src) {
4012   assert(VM_Version::supports_ssse3(), &quot;&quot;);
4013   InstructionMark im(this);
4014   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4015   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
4016   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4017   emit_int8(0x00);
4018   emit_operand(dst, src);
4019 }
4020 
4021 void Assembler::pshufd(XMMRegister dst, XMMRegister src, int mode) {
4022   assert(isByte(mode), &quot;invalid value&quot;);
4023   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4024   int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
4025   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4026   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4027   emit_int24(0x70, (0xC0 | encode), mode &amp; 0xFF);</span>


4028 }
4029 
4030 void Assembler::vpshufd(XMMRegister dst, XMMRegister src, int mode, int vector_len) {
4031   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
4032          (vector_len == AVX_256bit? VM_Version::supports_avx2() :
4033          (vector_len == AVX_512bit? VM_Version::supports_evex() : 0)), &quot;&quot;);
4034   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4035   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4036   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4037   emit_int24(0x70, (0xC0 | encode), mode &amp; 0xFF);</span>


4038 }
4039 
4040 void Assembler::pshufd(XMMRegister dst, Address src, int mode) {
4041   assert(isByte(mode), &quot;invalid value&quot;);
4042   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4043   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4044   InstructionMark im(this);
4045   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4046   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
4047   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4048   emit_int8(0x70);
4049   emit_operand(dst, src);
4050   emit_int8(mode &amp; 0xFF);
4051 }
4052 
4053 void Assembler::pshuflw(XMMRegister dst, XMMRegister src, int mode) {
4054   assert(isByte(mode), &quot;invalid value&quot;);
4055   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4056   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4057   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4058   emit_int24(0x70, (0xC0 | encode), mode &amp; 0xFF);</span>


4059 }
4060 
4061 void Assembler::pshuflw(XMMRegister dst, Address src, int mode) {
4062   assert(isByte(mode), &quot;invalid value&quot;);
4063   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4064   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4065   InstructionMark im(this);
4066   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4067   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
4068   simd_prefix(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4069   emit_int8(0x70);
4070   emit_operand(dst, src);
4071   emit_int8(mode &amp; 0xFF);
4072 }
4073 
4074 void Assembler::evshufi64x2(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {
4075   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
4076   assert(vector_len == Assembler::AVX_256bit || vector_len == Assembler::AVX_512bit, &quot;&quot;);
4077   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4078   attributes.set_is_evex_instruction();
4079   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">4080   emit_int24(0x43, (0xC0 | encode), imm8 &amp; 0xFF);</span>


4081 }
4082 
4083 void Assembler::psrldq(XMMRegister dst, int shift) {
4084   // Shift left 128 bit value in dst XMMRegister by shift number of bytes.
4085   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4086   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4087   int encode = simd_prefix_and_encode(xmm3, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4088   emit_int24(0x73, (0xC0 | encode), shift);</span>


4089 }
4090 
4091 void Assembler::vpsrldq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
4092   assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
4093          vector_len == AVX_256bit ? VM_Version::supports_avx2() :
4094          vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
4095   InstructionAttr attributes(vector_len, /*vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4096   int encode = vex_prefix_and_encode(xmm3-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4097   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>


4098 }
4099 
4100 void Assembler::pslldq(XMMRegister dst, int shift) {
4101   // Shift left 128 bit value in dst XMMRegister by shift number of bytes.
4102   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4103   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4104   // XMM7 is for /7 encoding: 66 0F 73 /7 ib
4105   int encode = simd_prefix_and_encode(xmm7, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4106   emit_int24(0x73, (0xC0 | encode), shift);</span>


4107 }
4108 
4109 void Assembler::vpslldq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
4110   assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
4111          vector_len == AVX_256bit ? VM_Version::supports_avx2() :
4112          vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
4113   InstructionAttr attributes(vector_len, /*vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4114   int encode = vex_prefix_and_encode(xmm7-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4115   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>


4116 }
4117 
4118 void Assembler::ptest(XMMRegister dst, Address src) {
4119   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
4120   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4121   InstructionMark im(this);
4122   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4123   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4124   emit_int8(0x17);
4125   emit_operand(dst, src);
4126 }
4127 
4128 void Assembler::ptest(XMMRegister dst, XMMRegister src) {
4129   assert(VM_Version::supports_sse4_1() || VM_Version::supports_avx(), &quot;&quot;);
4130   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4131   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4132   emit_int8(0x17);
<span class="line-modified">4133   emit_int8((0xC0 | encode));</span>
4134 }
4135 
4136 void Assembler::vptest(XMMRegister dst, Address src) {
4137   assert(VM_Version::supports_avx(), &quot;&quot;);
4138   InstructionMark im(this);
4139   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4140   assert(dst != xnoreg, &quot;sanity&quot;);
4141   // swap src&lt;-&gt;dst for encoding
4142   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
4143   emit_int8(0x17);
4144   emit_operand(dst, src);
4145 }
4146 
4147 void Assembler::vptest(XMMRegister dst, XMMRegister src) {
4148   assert(VM_Version::supports_avx(), &quot;&quot;);
4149   InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4150   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">4151   emit_int16(0x17, (0xC0 | encode));</span>

4152 }
4153 
4154 void Assembler::punpcklbw(XMMRegister dst, Address src) {
4155   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4156   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4157   InstructionMark im(this);
4158   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_vlbw, /* no_mask_reg */ true, /* uses_vl */ true);
4159   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
4160   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4161   emit_int8(0x60);
4162   emit_operand(dst, src);
4163 }
4164 
4165 void Assembler::punpcklbw(XMMRegister dst, XMMRegister src) {
4166   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4167   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_vlbw, /* no_mask_reg */ true, /* uses_vl */ true);
4168   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4169   emit_int16(0x60, (0xC0 | encode));</span>

4170 }
4171 
4172 void Assembler::punpckldq(XMMRegister dst, Address src) {
4173   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4174   assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
4175   InstructionMark im(this);
4176   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4177   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
4178   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4179   emit_int8(0x62);
4180   emit_operand(dst, src);
4181 }
4182 
4183 void Assembler::punpckldq(XMMRegister dst, XMMRegister src) {
4184   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4185   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4186   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4187   emit_int16(0x62, (0xC0 | encode));</span>

4188 }
4189 
4190 void Assembler::punpcklqdq(XMMRegister dst, XMMRegister src) {
4191   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4192   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4193   attributes.set_rex_vex_w_reverted();
4194   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4195   emit_int16(0x6C, (0xC0 | encode));</span>

4196 }
4197 
4198 void Assembler::push(int32_t imm32) {
4199   // in 64bits we push 64bits onto the stack but only
4200   // take a 32bit immediate
4201   emit_int8(0x68);
4202   emit_int32(imm32);
4203 }
4204 
4205 void Assembler::push(Register src) {
4206   int encode = prefix_and_encode(src-&gt;encoding());

4207   emit_int8(0x50 | encode);
4208 }
4209 
4210 void Assembler::pushf() {
4211   emit_int8((unsigned char)0x9C);
4212 }
4213 
4214 #ifndef _LP64 // no 32bit push/pop on amd64
4215 void Assembler::pushl(Address src) {
4216   // Note this will push 64bit on 64bit
4217   InstructionMark im(this);
4218   prefix(src);
4219   emit_int8((unsigned char)0xFF);
4220   emit_operand(rsi, src);
4221 }
4222 #endif
4223 
4224 void Assembler::rcll(Register dst, int imm8) {
4225   assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
4226   int encode = prefix_and_encode(dst-&gt;encoding());
4227   if (imm8 == 1) {
<span class="line-modified">4228     emit_int16((unsigned char)0xD1, (0xD0 | encode));</span>

4229   } else {
<span class="line-modified">4230     emit_int24((unsigned char)0xC1, (0xD0 | encode), imm8);</span>


4231   }
4232 }
4233 
4234 void Assembler::rcpps(XMMRegister dst, XMMRegister src) {
4235   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4236   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4237   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4238   emit_int16(0x53, (0xC0 | encode));</span>

4239 }
4240 
4241 void Assembler::rcpss(XMMRegister dst, XMMRegister src) {
4242   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4243   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4244   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4245   emit_int16(0x53, (0xC0 | encode));</span>

4246 }
4247 
4248 void Assembler::rdtsc() {
<span class="line-modified">4249   emit_int16(0x0F, 0x31);</span>

4250 }
4251 
4252 // copies data from [esi] to [edi] using rcx pointer sized words
4253 // generic
4254 void Assembler::rep_mov() {
<span class="line-modified">4255   // REP</span>
4256   // MOVSQ
<span class="line-modified">4257   LP64_ONLY(emit_int24((unsigned char)0xF3, REX_W, (unsigned char)0xA5);)</span>
<span class="line-modified">4258   NOT_LP64( emit_int16((unsigned char)0xF3,        (unsigned char)0xA5);)</span>
4259 }
4260 
4261 // sets rcx bytes with rax, value at [edi]
4262 void Assembler::rep_stosb() {
<span class="line-modified">4263   // REP</span>
<span class="line-modified">4264   // STOSB</span>
<span class="line-modified">4265   LP64_ONLY(emit_int24((unsigned char)0xF3, REX_W, (unsigned char)0xAA);)</span>
<span class="line-added">4266   NOT_LP64( emit_int16((unsigned char)0xF3,        (unsigned char)0xAA);)</span>
4267 }
4268 
4269 // sets rcx pointer sized words with rax, value at [edi]
4270 // generic
4271 void Assembler::rep_stos() {
<span class="line-modified">4272   // REP</span>
<span class="line-modified">4273   // LP64:STOSQ, LP32:STOSD</span>
<span class="line-modified">4274   LP64_ONLY(emit_int24((unsigned char)0xF3, REX_W, (unsigned char)0xAB);)</span>
<span class="line-added">4275   NOT_LP64( emit_int16((unsigned char)0xF3,        (unsigned char)0xAB);)</span>
4276 }
4277 
4278 // scans rcx pointer sized words at [edi] for occurance of rax,
4279 // generic
4280 void Assembler::repne_scan() { // repne_scan

4281   // SCASQ
<span class="line-modified">4282   LP64_ONLY(emit_int24((unsigned char)0xF2, REX_W, (unsigned char)0xAF);)</span>
<span class="line-modified">4283   NOT_LP64( emit_int16((unsigned char)0xF2,        (unsigned char)0xAF);)</span>
4284 }
4285 
4286 #ifdef _LP64
4287 // scans rcx 4 byte words at [edi] for occurance of rax,
4288 // generic
4289 void Assembler::repne_scanl() { // repne_scan

4290   // SCASL
<span class="line-modified">4291   emit_int16((unsigned char)0xF2, (unsigned char)0xAF);</span>
4292 }
4293 #endif
4294 
4295 void Assembler::ret(int imm16) {
4296   if (imm16 == 0) {
4297     emit_int8((unsigned char)0xC3);
4298   } else {
4299     emit_int8((unsigned char)0xC2);
4300     emit_int16(imm16);
4301   }
4302 }
4303 
4304 void Assembler::sahf() {
4305 #ifdef _LP64
4306   // Not supported in 64bit mode
4307   ShouldNotReachHere();
4308 #endif
4309   emit_int8((unsigned char)0x9E);
4310 }
4311 
4312 void Assembler::sarl(Register dst, int imm8) {
4313   int encode = prefix_and_encode(dst-&gt;encoding());
4314   assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
4315   if (imm8 == 1) {
<span class="line-modified">4316     emit_int16((unsigned char)0xD1, (0xF8 | encode));</span>

4317   } else {
<span class="line-modified">4318     emit_int24((unsigned char)0xC1, (0xF8 | encode), imm8);</span>


4319   }
4320 }
4321 
4322 void Assembler::sarl(Register dst) {
4323   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">4324   emit_int16((unsigned char)0xD3, (0xF8 | encode));</span>

4325 }
4326 
4327 void Assembler::sbbl(Address dst, int32_t imm32) {
4328   InstructionMark im(this);
4329   prefix(dst);
4330   emit_arith_operand(0x81, rbx, dst, imm32);
4331 }
4332 
4333 void Assembler::sbbl(Register dst, int32_t imm32) {
4334   prefix(dst);
4335   emit_arith(0x81, 0xD8, dst, imm32);
4336 }
4337 
4338 
4339 void Assembler::sbbl(Register dst, Address src) {
4340   InstructionMark im(this);
4341   prefix(src, dst);
4342   emit_int8(0x1B);
4343   emit_operand(dst, src);
4344 }
4345 
4346 void Assembler::sbbl(Register dst, Register src) {
4347   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
4348   emit_arith(0x1B, 0xC0, dst, src);
4349 }
4350 
4351 void Assembler::setb(Condition cc, Register dst) {
4352   assert(0 &lt;= cc &amp;&amp; cc &lt; 16, &quot;illegal cc&quot;);
4353   int encode = prefix_and_encode(dst-&gt;encoding(), true);
<span class="line-modified">4354   emit_int24(0x0F, (unsigned char)0x90 | cc, (0xC0 | encode));</span>


4355 }
4356 
4357 void Assembler::palignr(XMMRegister dst, XMMRegister src, int imm8) {
4358   assert(VM_Version::supports_ssse3(), &quot;&quot;);
4359   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4360   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">4361   emit_int24(0x0F, (0xC0 | encode), imm8);</span>


4362 }
4363 
4364 void Assembler::vpalignr(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {
4365   assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
4366          vector_len == AVX_256bit? VM_Version::supports_avx2() :
4367          0, &quot;&quot;);
4368   InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
4369   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">4370   emit_int24(0x0F, (0xC0 | encode), imm8);</span>


4371 }
4372 
4373 void Assembler::evalignq(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
4374   assert(VM_Version::supports_evex(), &quot;&quot;);
4375   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4376   attributes.set_is_evex_instruction();
4377   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">4378   emit_int24(0x3, (0xC0 | encode), imm8);</span>


4379 }
4380 
4381 void Assembler::pblendw(XMMRegister dst, XMMRegister src, int imm8) {
4382   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
4383   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4384   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">4385   emit_int24(0x0E, (0xC0 | encode), imm8);</span>


4386 }
4387 
4388 void Assembler::sha1rnds4(XMMRegister dst, XMMRegister src, int imm8) {
4389   assert(VM_Version::supports_sha(), &quot;&quot;);
4390   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, /* rex_w */ false);
<span class="line-modified">4391   emit_int24((unsigned char)0xCC, (0xC0 | encode), (unsigned char)imm8);</span>


4392 }
4393 
4394 void Assembler::sha1nexte(XMMRegister dst, XMMRegister src) {
4395   assert(VM_Version::supports_sha(), &quot;&quot;);
4396   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">4397   emit_int16((unsigned char)0xC8, (0xC0 | encode));</span>

4398 }
4399 
4400 void Assembler::sha1msg1(XMMRegister dst, XMMRegister src) {
4401   assert(VM_Version::supports_sha(), &quot;&quot;);
4402   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">4403   emit_int16((unsigned char)0xC9, (0xC0 | encode));</span>

4404 }
4405 
4406 void Assembler::sha1msg2(XMMRegister dst, XMMRegister src) {
4407   assert(VM_Version::supports_sha(), &quot;&quot;);
4408   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">4409   emit_int16((unsigned char)0xCA, (0xC0 | encode));</span>

4410 }
4411 
4412 // xmm0 is implicit additional source to this instruction.
4413 void Assembler::sha256rnds2(XMMRegister dst, XMMRegister src) {
4414   assert(VM_Version::supports_sha(), &quot;&quot;);
4415   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">4416   emit_int16((unsigned char)0xCB, (0xC0 | encode));</span>

4417 }
4418 
4419 void Assembler::sha256msg1(XMMRegister dst, XMMRegister src) {
4420   assert(VM_Version::supports_sha(), &quot;&quot;);
4421   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">4422   emit_int16((unsigned char)0xCC, (0xC0 | encode));</span>

4423 }
4424 
4425 void Assembler::sha256msg2(XMMRegister dst, XMMRegister src) {
4426   assert(VM_Version::supports_sha(), &quot;&quot;);
4427   int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">4428   emit_int16((unsigned char)0xCD, (0xC0 | encode));</span>

4429 }
4430 
4431 
4432 void Assembler::shll(Register dst, int imm8) {
4433   assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
4434   int encode = prefix_and_encode(dst-&gt;encoding());
4435   if (imm8 == 1 ) {
<span class="line-modified">4436     emit_int16((unsigned char)0xD1, (0xE0 | encode));</span>

4437   } else {
<span class="line-modified">4438     emit_int24((unsigned char)0xC1, (0xE0 | encode), imm8);</span>


4439   }
4440 }
4441 
4442 void Assembler::shll(Register dst) {
4443   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">4444   emit_int16((unsigned char)0xD3, (0xE0 | encode));</span>

4445 }
4446 
4447 void Assembler::shrl(Register dst, int imm8) {
4448   assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
4449   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">4450   emit_int24((unsigned char)0xC1, (0xE8 | encode), imm8);</span>


4451 }
4452 
4453 void Assembler::shrl(Register dst) {
4454   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">4455   emit_int16((unsigned char)0xD3, (0xE8 | encode));</span>

4456 }
4457 
4458 void Assembler::shldl(Register dst, Register src) {
4459   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="line-modified">4460   emit_int24(0x0F, (unsigned char)0xA5, (0xC0 | encode));</span>


4461 }
4462 
4463 void Assembler::shldl(Register dst, Register src, int8_t imm8) {
4464   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="line-modified">4465   emit_int32(0x0F, (unsigned char)0xA4, (0xC0 | encode), imm8);</span>



4466 }
4467 
4468 void Assembler::shrdl(Register dst, Register src) {
4469   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="line-modified">4470   emit_int24(0x0F, (unsigned char)0xAD, (0xC0 | encode));</span>


4471 }
4472 
4473 void Assembler::shrdl(Register dst, Register src, int8_t imm8) {
4474   int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="line-modified">4475   emit_int32(0x0F, (unsigned char)0xAC, (0xC0 | encode), imm8);</span>



4476 }
4477 
4478 // copies a single word from [esi] to [edi]
4479 void Assembler::smovl() {
4480   emit_int8((unsigned char)0xA5);
4481 }
4482 
4483 void Assembler::roundsd(XMMRegister dst, XMMRegister src, int32_t rmode) {
4484   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
4485   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4486   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">4487   emit_int24(0x0B, (0xC0 | encode), (unsigned char)rmode);</span>


4488 }
4489 
4490 void Assembler::roundsd(XMMRegister dst, Address src, int32_t rmode) {
4491   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
4492   InstructionMark im(this);
4493   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4494   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
4495   emit_int8(0x0B);
4496   emit_operand(dst, src);
4497   emit_int8((unsigned char)rmode);
4498 }
4499 
4500 void Assembler::sqrtsd(XMMRegister dst, XMMRegister src) {
4501   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4502   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4503   attributes.set_rex_vex_w_reverted();
4504   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4505   emit_int16(0x51, (0xC0 | encode));</span>

4506 }
4507 
4508 void Assembler::sqrtsd(XMMRegister dst, Address src) {
4509   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4510   InstructionMark im(this);
4511   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4512   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4513   attributes.set_rex_vex_w_reverted();
4514   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4515   emit_int8(0x51);
4516   emit_operand(dst, src);
4517 }
4518 
4519 void Assembler::sqrtss(XMMRegister dst, XMMRegister src) {
4520   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4521   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4522   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4523   emit_int16(0x51, (0xC0 | encode));</span>

4524 }
4525 
4526 void Assembler::std() {
4527   emit_int8((unsigned char)0xFD);
4528 }
4529 
4530 void Assembler::sqrtss(XMMRegister dst, Address src) {
4531   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4532   InstructionMark im(this);
4533   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4534   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
4535   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
4536   emit_int8(0x51);
4537   emit_operand(dst, src);
4538 }
4539 
4540 void Assembler::stmxcsr( Address dst) {
4541   if (UseAVX &gt; 0 ) {
4542     assert(VM_Version::supports_avx(), &quot;&quot;);
4543     InstructionMark im(this);
4544     InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
4545     vex_prefix(dst, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
4546     emit_int8((unsigned char)0xAE);
4547     emit_operand(as_Register(3), dst);
4548   } else {
4549     NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4550     InstructionMark im(this);
4551     prefix(dst);
<span class="line-modified">4552     emit_int16(0x0F, (unsigned char)0xAE);</span>

4553     emit_operand(as_Register(3), dst);
4554   }
4555 }
4556 
4557 void Assembler::subl(Address dst, int32_t imm32) {
4558   InstructionMark im(this);
4559   prefix(dst);
4560   emit_arith_operand(0x81, rbp, dst, imm32);
4561 }
4562 
4563 void Assembler::subl(Address dst, Register src) {
4564   InstructionMark im(this);
4565   prefix(dst, src);
4566   emit_int8(0x29);
4567   emit_operand(src, dst);
4568 }
4569 
4570 void Assembler::subl(Register dst, int32_t imm32) {
4571   prefix(dst);
4572   emit_arith(0x81, 0xE8, dst, imm32);
</pre>
<hr />
<pre>
4578   emit_arith_imm32(0x81, 0xE8, dst, imm32);
4579 }
4580 
4581 void Assembler::subl(Register dst, Address src) {
4582   InstructionMark im(this);
4583   prefix(src, dst);
4584   emit_int8(0x2B);
4585   emit_operand(dst, src);
4586 }
4587 
4588 void Assembler::subl(Register dst, Register src) {
4589   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
4590   emit_arith(0x2B, 0xC0, dst, src);
4591 }
4592 
4593 void Assembler::subsd(XMMRegister dst, XMMRegister src) {
4594   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4595   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4596   attributes.set_rex_vex_w_reverted();
4597   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4598   emit_int16(0x5C, (0xC0 | encode));</span>

4599 }
4600 
4601 void Assembler::subsd(XMMRegister dst, Address src) {
4602   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4603   InstructionMark im(this);
4604   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4605   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4606   attributes.set_rex_vex_w_reverted();
4607   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4608   emit_int8(0x5C);
4609   emit_operand(dst, src);
4610 }
4611 
4612 void Assembler::subss(XMMRegister dst, XMMRegister src) {
4613   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4614   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true , /* uses_vl */ false);
4615   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4616   emit_int16(0x5C, (0xC0 | encode));</span>

4617 }
4618 
4619 void Assembler::subss(XMMRegister dst, Address src) {
4620   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4621   InstructionMark im(this);
4622   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4623   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
4624   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
4625   emit_int8(0x5C);
4626   emit_operand(dst, src);
4627 }
4628 
4629 void Assembler::testb(Register dst, int imm8) {
4630   NOT_LP64(assert(dst-&gt;has_byte_register(), &quot;must have byte register&quot;));
4631   (void) prefix_and_encode(dst-&gt;encoding(), true);
4632   emit_arith_b(0xF6, 0xC0, dst, imm8);
4633 }
4634 
4635 void Assembler::testb(Address dst, int imm8) {
4636   InstructionMark im(this);
4637   prefix(dst);
4638   emit_int8((unsigned char)0xF6);
4639   emit_operand(rax, dst, 1);
4640   emit_int8(imm8);
4641 }
4642 
4643 void Assembler::testl(Register dst, int32_t imm32) {
4644   // not using emit_arith because test
4645   // doesn&#39;t support sign-extension of
4646   // 8bit operands
4647   int encode = dst-&gt;encoding();
4648   if (encode == 0) {
4649     emit_int8((unsigned char)0xA9);
4650   } else {
4651     encode = prefix_and_encode(encode);
<span class="line-modified">4652     emit_int16((unsigned char)0xF7, (0xC0 | encode));</span>

4653   }
4654   emit_int32(imm32);
4655 }
4656 
4657 void Assembler::testl(Register dst, Register src) {
4658   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
4659   emit_arith(0x85, 0xC0, dst, src);
4660 }
4661 
4662 void Assembler::testl(Register dst, Address src) {
4663   InstructionMark im(this);
4664   prefix(src, dst);
4665   emit_int8((unsigned char)0x85);
4666   emit_operand(dst, src);
4667 }
4668 
4669 void Assembler::tzcntl(Register dst, Register src) {
4670   assert(VM_Version::supports_bmi1(), &quot;tzcnt instruction not supported&quot;);
4671   emit_int8((unsigned char)0xF3);
4672   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">4673   emit_int24(0x0F,</span>
<span class="line-modified">4674              (unsigned char)0xBC,</span>
<span class="line-modified">4675              0xC0 | encode);</span>
4676 }
4677 
4678 void Assembler::tzcntq(Register dst, Register src) {
4679   assert(VM_Version::supports_bmi1(), &quot;tzcnt instruction not supported&quot;);
4680   emit_int8((unsigned char)0xF3);
4681   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">4682   emit_int24(0x0F, (unsigned char)0xBC, (0xC0 | encode));</span>


4683 }
4684 
4685 void Assembler::ucomisd(XMMRegister dst, Address src) {
4686   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4687   InstructionMark im(this);
4688   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4689   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4690   attributes.set_rex_vex_w_reverted();
4691   simd_prefix(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
4692   emit_int8(0x2E);
4693   emit_operand(dst, src);
4694 }
4695 
4696 void Assembler::ucomisd(XMMRegister dst, XMMRegister src) {
4697   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4698   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4699   attributes.set_rex_vex_w_reverted();
4700   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4701   emit_int16(0x2E, (0xC0 | encode));</span>

4702 }
4703 
4704 void Assembler::ucomiss(XMMRegister dst, Address src) {
4705   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4706   InstructionMark im(this);
4707   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4708   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
4709   simd_prefix(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
4710   emit_int8(0x2E);
4711   emit_operand(dst, src);
4712 }
4713 
4714 void Assembler::ucomiss(XMMRegister dst, XMMRegister src) {
4715   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
4716   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4717   int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4718   emit_int16(0x2E, (0xC0 | encode));</span>

4719 }
4720 
4721 void Assembler::xabort(int8_t imm8) {
<span class="line-modified">4722   emit_int24((unsigned char)0xC6, (unsigned char)0xF8, (imm8 &amp; 0xFF));</span>


4723 }
4724 
4725 void Assembler::xaddb(Address dst, Register src) {
4726   InstructionMark im(this);
4727   prefix(dst, src, true);
<span class="line-modified">4728   emit_int16(0x0F, (unsigned char)0xC0);</span>

4729   emit_operand(src, dst);
4730 }
4731 
4732 void Assembler::xaddw(Address dst, Register src) {
4733   InstructionMark im(this);
4734   emit_int8(0x66);
4735   prefix(dst, src);
<span class="line-modified">4736   emit_int16(0x0F, (unsigned char)0xC1);</span>

4737   emit_operand(src, dst);
4738 }
4739 
4740 void Assembler::xaddl(Address dst, Register src) {
4741   InstructionMark im(this);
4742   prefix(dst, src);
<span class="line-modified">4743   emit_int16(0x0F, (unsigned char)0xC1);</span>

4744   emit_operand(src, dst);
4745 }
4746 
4747 void Assembler::xbegin(Label&amp; abort, relocInfo::relocType rtype) {
4748   InstructionMark im(this);
4749   relocate(rtype);
4750   if (abort.is_bound()) {
4751     address entry = target(abort);
4752     assert(entry != NULL, &quot;abort entry NULL&quot;);
4753     intptr_t offset = entry - pc();
<span class="line-modified">4754     emit_int16((unsigned char)0xC7, (unsigned char)0xF8);</span>

4755     emit_int32(offset - 6); // 2 opcode + 4 address
4756   } else {
4757     abort.add_patch_at(code(), locator());
<span class="line-modified">4758     emit_int16((unsigned char)0xC7, (unsigned char)0xF8);</span>

4759     emit_int32(0);
4760   }
4761 }
4762 
4763 void Assembler::xchgb(Register dst, Address src) { // xchg
4764   InstructionMark im(this);
4765   prefix(src, dst, true);
4766   emit_int8((unsigned char)0x86);
4767   emit_operand(dst, src);
4768 }
4769 
4770 void Assembler::xchgw(Register dst, Address src) { // xchg
4771   InstructionMark im(this);
4772   emit_int8(0x66);
4773   prefix(src, dst);
4774   emit_int8((unsigned char)0x87);
4775   emit_operand(dst, src);
4776 }
4777 
4778 void Assembler::xchgl(Register dst, Address src) { // xchg
4779   InstructionMark im(this);
4780   prefix(src, dst);
4781   emit_int8((unsigned char)0x87);
4782   emit_operand(dst, src);
4783 }
4784 
4785 void Assembler::xchgl(Register dst, Register src) {
4786   int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">4787   emit_int16((unsigned char)0x87, (0xC0 | encode));</span>

4788 }
4789 
4790 void Assembler::xend() {
<span class="line-modified">4791   emit_int24(0x0F, 0x01, (unsigned char)0xD5);</span>


4792 }
4793 
4794 void Assembler::xgetbv() {
<span class="line-modified">4795   emit_int24(0x0F, 0x01, (unsigned char)0xD0);</span>


4796 }
4797 
4798 void Assembler::xorl(Register dst, int32_t imm32) {
4799   prefix(dst);
4800   emit_arith(0x81, 0xF0, dst, imm32);
4801 }
4802 
4803 void Assembler::xorl(Register dst, Address src) {
4804   InstructionMark im(this);
4805   prefix(src, dst);
4806   emit_int8(0x33);
4807   emit_operand(dst, src);
4808 }
4809 
4810 void Assembler::xorl(Register dst, Register src) {
4811   (void) prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
4812   emit_arith(0x33, 0xC0, dst, src);
4813 }
4814 
4815 void Assembler::xorb(Register dst, Address src) {
</pre>
<hr />
<pre>
4820 }
4821 
4822 // AVX 3-operands scalar float-point arithmetic instructions
4823 
4824 void Assembler::vaddsd(XMMRegister dst, XMMRegister nds, Address src) {
4825   assert(VM_Version::supports_avx(), &quot;&quot;);
4826   InstructionMark im(this);
4827   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4828   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4829   attributes.set_rex_vex_w_reverted();
4830   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4831   emit_int8(0x58);
4832   emit_operand(dst, src);
4833 }
4834 
4835 void Assembler::vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
4836   assert(VM_Version::supports_avx(), &quot;&quot;);
4837   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4838   attributes.set_rex_vex_w_reverted();
4839   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4840   emit_int16(0x58, (0xC0 | encode));</span>

4841 }
4842 
4843 void Assembler::vaddss(XMMRegister dst, XMMRegister nds, Address src) {
4844   assert(VM_Version::supports_avx(), &quot;&quot;);
4845   InstructionMark im(this);
4846   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4847   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
4848   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
4849   emit_int8(0x58);
4850   emit_operand(dst, src);
4851 }
4852 
4853 void Assembler::vaddss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
4854   assert(VM_Version::supports_avx(), &quot;&quot;);
4855   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4856   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4857   emit_int16(0x58, (0xC0 | encode));</span>

4858 }
4859 
4860 void Assembler::vdivsd(XMMRegister dst, XMMRegister nds, Address src) {
4861   assert(VM_Version::supports_avx(), &quot;&quot;);
4862   InstructionMark im(this);
4863   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4864   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4865   attributes.set_rex_vex_w_reverted();
4866   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4867   emit_int8(0x5E);
4868   emit_operand(dst, src);
4869 }
4870 
4871 void Assembler::vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
4872   assert(VM_Version::supports_avx(), &quot;&quot;);
4873   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4874   attributes.set_rex_vex_w_reverted();
4875   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4876   emit_int16(0x5E, (0xC0 | encode));</span>

4877 }
4878 
4879 void Assembler::vdivss(XMMRegister dst, XMMRegister nds, Address src) {
4880   assert(VM_Version::supports_avx(), &quot;&quot;);
4881   InstructionMark im(this);
4882   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4883   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
4884   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
4885   emit_int8(0x5E);
4886   emit_operand(dst, src);
4887 }
4888 
4889 void Assembler::vdivss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
4890   assert(VM_Version::supports_avx(), &quot;&quot;);
4891   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4892   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4893   emit_int16(0x5E, (0xC0 | encode));</span>

4894 }
4895 
4896 void Assembler::vfmadd231sd(XMMRegister dst, XMMRegister src1, XMMRegister src2) {
4897   assert(VM_Version::supports_fma(), &quot;&quot;);
4898   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4899   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">4900   emit_int16((unsigned char)0xB9, (0xC0 | encode));</span>

4901 }
4902 
4903 void Assembler::vfmadd231ss(XMMRegister dst, XMMRegister src1, XMMRegister src2) {
4904   assert(VM_Version::supports_fma(), &quot;&quot;);
4905   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4906   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">4907   emit_int16((unsigned char)0xB9, (0xC0 | encode));</span>

4908 }
4909 
4910 void Assembler::vmulsd(XMMRegister dst, XMMRegister nds, Address src) {
4911   assert(VM_Version::supports_avx(), &quot;&quot;);
4912   InstructionMark im(this);
4913   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4914   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4915   attributes.set_rex_vex_w_reverted();
4916   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4917   emit_int8(0x59);
4918   emit_operand(dst, src);
4919 }
4920 
4921 void Assembler::vmulsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
4922   assert(VM_Version::supports_avx(), &quot;&quot;);
4923   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4924   attributes.set_rex_vex_w_reverted();
4925   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4926   emit_int16(0x59, (0xC0 | encode));</span>

4927 }
4928 
4929 void Assembler::vmulss(XMMRegister dst, XMMRegister nds, Address src) {
4930   assert(VM_Version::supports_avx(), &quot;&quot;);
4931   InstructionMark im(this);
4932   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4933   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
4934   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
4935   emit_int8(0x59);
4936   emit_operand(dst, src);
4937 }
4938 
4939 void Assembler::vmulss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
4940   assert(VM_Version::supports_avx(), &quot;&quot;);
4941   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4942   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4943   emit_int16(0x59, (0xC0 | encode));</span>

4944 }
4945 
4946 void Assembler::vsubsd(XMMRegister dst, XMMRegister nds, Address src) {
4947   assert(VM_Version::supports_avx(), &quot;&quot;);
4948   InstructionMark im(this);
4949   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4950   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
4951   attributes.set_rex_vex_w_reverted();
4952   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
4953   emit_int8(0x5C);
4954   emit_operand(dst, src);
4955 }
4956 
4957 void Assembler::vsubsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
4958   assert(VM_Version::supports_avx(), &quot;&quot;);
4959   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4960   attributes.set_rex_vex_w_reverted();
4961   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4962   emit_int16(0x5C, (0xC0 | encode));</span>

4963 }
4964 
4965 void Assembler::vsubss(XMMRegister dst, XMMRegister nds, Address src) {
4966   assert(VM_Version::supports_avx(), &quot;&quot;);
4967   InstructionMark im(this);
4968   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4969   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
4970   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
4971   emit_int8(0x5C);
4972   emit_operand(dst, src);
4973 }
4974 
4975 void Assembler::vsubss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
4976   assert(VM_Version::supports_avx(), &quot;&quot;);
4977   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
4978   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4979   emit_int16(0x5C, (0xC0 | encode));</span>

4980 }
4981 
4982 //====================VECTOR ARITHMETIC=====================================
4983 
4984 // Float-point vector arithmetic
4985 
4986 void Assembler::addpd(XMMRegister dst, XMMRegister src) {
4987   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4988   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4989   attributes.set_rex_vex_w_reverted();
4990   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">4991   emit_int16(0x58, (0xC0 | encode));</span>

4992 }
4993 
4994 void Assembler::addpd(XMMRegister dst, Address src) {
4995   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
4996   InstructionMark im(this);
4997   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
4998   attributes.set_rex_vex_w_reverted();
4999   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5000   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5001   emit_int8(0x58);
5002   emit_operand(dst, src);
5003 }
5004 
5005 
5006 void Assembler::addps(XMMRegister dst, XMMRegister src) {
5007   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5008   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5009   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5010   emit_int16(0x58, (0xC0 | encode));</span>

5011 }
5012 
5013 void Assembler::vaddpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5014   assert(VM_Version::supports_avx(), &quot;&quot;);
5015   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5016   attributes.set_rex_vex_w_reverted();
5017   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5018   emit_int16(0x58, (0xC0 | encode));</span>

5019 }
5020 
5021 void Assembler::vaddps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5022   assert(VM_Version::supports_avx(), &quot;&quot;);
5023   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5024   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5025   emit_int16(0x58, (0xC0 | encode));</span>

5026 }
5027 
5028 void Assembler::vaddpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5029   assert(VM_Version::supports_avx(), &quot;&quot;);
5030   InstructionMark im(this);
5031   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5032   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5033   attributes.set_rex_vex_w_reverted();
5034   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5035   emit_int8(0x58);
5036   emit_operand(dst, src);
5037 }
5038 
5039 void Assembler::vaddps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5040   assert(VM_Version::supports_avx(), &quot;&quot;);
5041   InstructionMark im(this);
5042   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5043   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5044   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5045   emit_int8(0x58);
5046   emit_operand(dst, src);
5047 }
5048 
5049 void Assembler::subpd(XMMRegister dst, XMMRegister src) {
5050   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5051   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5052   attributes.set_rex_vex_w_reverted();
5053   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5054   emit_int16(0x5C, (0xC0 | encode));</span>

5055 }
5056 
5057 void Assembler::subps(XMMRegister dst, XMMRegister src) {
5058   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5059   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5060   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5061   emit_int16(0x5C, (0xC0 | encode));</span>

5062 }
5063 
5064 void Assembler::vsubpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5065   assert(VM_Version::supports_avx(), &quot;&quot;);
5066   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5067   attributes.set_rex_vex_w_reverted();
5068   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5069   emit_int16(0x5C, (0xC0 | encode));</span>

5070 }
5071 
5072 void Assembler::vsubps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5073   assert(VM_Version::supports_avx(), &quot;&quot;);
5074   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5075   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5076   emit_int16(0x5C, (0xC0 | encode));</span>

5077 }
5078 
5079 void Assembler::vsubpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5080   assert(VM_Version::supports_avx(), &quot;&quot;);
5081   InstructionMark im(this);
5082   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5083   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5084   attributes.set_rex_vex_w_reverted();
5085   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5086   emit_int8(0x5C);
5087   emit_operand(dst, src);
5088 }
5089 
5090 void Assembler::vsubps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5091   assert(VM_Version::supports_avx(), &quot;&quot;);
5092   InstructionMark im(this);
5093   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5094   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5095   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5096   emit_int8(0x5C);
5097   emit_operand(dst, src);
5098 }
5099 
5100 void Assembler::mulpd(XMMRegister dst, XMMRegister src) {
5101   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5102   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5103   attributes.set_rex_vex_w_reverted();
5104   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5105   emit_int16(0x59, (0xC0 | encode));</span>

5106 }
5107 
5108 void Assembler::mulpd(XMMRegister dst, Address src) {
5109   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5110   InstructionMark im(this);
5111   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5112   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5113   attributes.set_rex_vex_w_reverted();
5114   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5115   emit_int8(0x59);
5116   emit_operand(dst, src);
5117 }
5118 
5119 void Assembler::mulps(XMMRegister dst, XMMRegister src) {
5120   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5121   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5122   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5123   emit_int16(0x59, (0xC0 | encode));</span>

5124 }
5125 
5126 void Assembler::vmulpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5127   assert(VM_Version::supports_avx(), &quot;&quot;);
5128   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5129   attributes.set_rex_vex_w_reverted();
5130   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5131   emit_int16(0x59, (0xC0 | encode));</span>

5132 }
5133 
5134 void Assembler::vmulps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5135   assert(VM_Version::supports_avx(), &quot;&quot;);
5136   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5137   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5138   emit_int16(0x59, (0xC0 | encode));</span>

5139 }
5140 
5141 void Assembler::vmulpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5142   assert(VM_Version::supports_avx(), &quot;&quot;);
5143   InstructionMark im(this);
5144   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5145   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5146   attributes.set_rex_vex_w_reverted();
5147   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5148   emit_int8(0x59);
5149   emit_operand(dst, src);
5150 }
5151 
5152 void Assembler::vmulps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5153   assert(VM_Version::supports_avx(), &quot;&quot;);
5154   InstructionMark im(this);
5155   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5156   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5157   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5158   emit_int8(0x59);
5159   emit_operand(dst, src);
5160 }
5161 
5162 void Assembler::vfmadd231pd(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {
5163   assert(VM_Version::supports_fma(), &quot;&quot;);
5164   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5165   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">5166   emit_int16((unsigned char)0xB8, (0xC0 | encode));</span>

5167 }
5168 
5169 void Assembler::vfmadd231ps(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {
5170   assert(VM_Version::supports_fma(), &quot;&quot;);
5171   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5172   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">5173   emit_int16((unsigned char)0xB8, (0xC0 | encode));</span>

5174 }
5175 
5176 void Assembler::vfmadd231pd(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {
5177   assert(VM_Version::supports_fma(), &quot;&quot;);
5178   InstructionMark im(this);
5179   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5180   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5181   vex_prefix(src2, src1-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5182   emit_int8((unsigned char)0xB8);
5183   emit_operand(dst, src2);
5184 }
5185 
5186 void Assembler::vfmadd231ps(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {
5187   assert(VM_Version::supports_fma(), &quot;&quot;);
5188   InstructionMark im(this);
5189   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5190   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5191   vex_prefix(src2, src1-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5192   emit_int8((unsigned char)0xB8);
5193   emit_operand(dst, src2);
5194 }
5195 
5196 void Assembler::divpd(XMMRegister dst, XMMRegister src) {
5197   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5198   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5199   attributes.set_rex_vex_w_reverted();
5200   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5201   emit_int16(0x5E, (0xC0 | encode));</span>

5202 }
5203 
5204 void Assembler::divps(XMMRegister dst, XMMRegister src) {
5205   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5206   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5207   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5208   emit_int16(0x5E, (0xC0 | encode));</span>

5209 }
5210 
5211 void Assembler::vdivpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5212   assert(VM_Version::supports_avx(), &quot;&quot;);
5213   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5214   attributes.set_rex_vex_w_reverted();
5215   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5216   emit_int16(0x5E, (0xC0 | encode));</span>

5217 }
5218 
5219 void Assembler::vdivps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5220   assert(VM_Version::supports_avx(), &quot;&quot;);
5221   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5222   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5223   emit_int16(0x5E, (0xC0 | encode));</span>

5224 }
5225 
5226 void Assembler::vdivpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5227   assert(VM_Version::supports_avx(), &quot;&quot;);
5228   InstructionMark im(this);
5229   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5230   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5231   attributes.set_rex_vex_w_reverted();
5232   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5233   emit_int8(0x5E);
5234   emit_operand(dst, src);
5235 }
5236 
5237 void Assembler::vdivps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5238   assert(VM_Version::supports_avx(), &quot;&quot;);
5239   InstructionMark im(this);
5240   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5241   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5242   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5243   emit_int8(0x5E);
5244   emit_operand(dst, src);
5245 }
5246 
5247 void Assembler::vroundpd(XMMRegister dst, XMMRegister src, int32_t rmode, int vector_len) {
5248   assert(VM_Version::supports_avx(), &quot;&quot;);
5249   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
5250   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">5251   emit_int24(0x09, (0xC0 | encode), (rmode));</span>


5252 }
5253 
5254 void Assembler::vroundpd(XMMRegister dst, Address src, int32_t rmode,  int vector_len) {
5255   assert(VM_Version::supports_avx(), &quot;&quot;);
5256   InstructionMark im(this);
5257   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
5258   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
5259   emit_int8(0x09);
5260   emit_operand(dst, src);
<span class="line-modified">5261   emit_int8((rmode));</span>
5262 }
5263 
5264 void Assembler::vrndscalepd(XMMRegister dst,  XMMRegister src,  int32_t rmode, int vector_len) {
5265   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
5266   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5267   attributes.set_is_evex_instruction();
5268   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">5269   emit_int24(0x09, (0xC0 | encode), (rmode));</span>


5270 }
5271 
5272 void Assembler::vrndscalepd(XMMRegister dst, Address src, int32_t rmode, int vector_len) {
5273   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
5274   assert(dst != xnoreg, &quot;sanity&quot;);
5275   InstructionMark im(this);
5276   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5277   attributes.set_is_evex_instruction();
5278   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5279   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">5280   emit_int8(0x09);</span>
5281   emit_operand(dst, src);
<span class="line-modified">5282   emit_int8((rmode));</span>
5283 }
5284 
5285 
5286 void Assembler::vsqrtpd(XMMRegister dst, XMMRegister src, int vector_len) {
5287   assert(VM_Version::supports_avx(), &quot;&quot;);
5288   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5289   attributes.set_rex_vex_w_reverted();
5290   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5291   emit_int16(0x51, (0xC0 | encode));</span>

5292 }
5293 
5294 void Assembler::vsqrtpd(XMMRegister dst, Address src, int vector_len) {
5295   assert(VM_Version::supports_avx(), &quot;&quot;);
5296   InstructionMark im(this);
5297   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5298   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5299   attributes.set_rex_vex_w_reverted();
5300   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5301   emit_int8(0x51);
5302   emit_operand(dst, src);
5303 }
5304 
5305 void Assembler::vsqrtps(XMMRegister dst, XMMRegister src, int vector_len) {
5306   assert(VM_Version::supports_avx(), &quot;&quot;);
5307   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5308   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5309   emit_int16(0x51, (0xC0 | encode));</span>

5310 }
5311 
5312 void Assembler::vsqrtps(XMMRegister dst, Address src, int vector_len) {
5313   assert(VM_Version::supports_avx(), &quot;&quot;);
5314   InstructionMark im(this);
5315   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5316   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5317   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5318   emit_int8(0x51);
5319   emit_operand(dst, src);
5320 }
5321 
5322 void Assembler::andpd(XMMRegister dst, XMMRegister src) {
5323   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5324   InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5325   attributes.set_rex_vex_w_reverted();
5326   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5327   emit_int16(0x54, (0xC0 | encode));</span>

5328 }
5329 
5330 void Assembler::andps(XMMRegister dst, XMMRegister src) {
5331   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5332   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5333   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5334   emit_int16(0x54, (0xC0 | encode));</span>

5335 }
5336 
5337 void Assembler::andps(XMMRegister dst, Address src) {
5338   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5339   InstructionMark im(this);
5340   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5341   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5342   simd_prefix(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5343   emit_int8(0x54);
5344   emit_operand(dst, src);
5345 }
5346 
5347 void Assembler::andpd(XMMRegister dst, Address src) {
5348   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5349   InstructionMark im(this);
5350   InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5351   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5352   attributes.set_rex_vex_w_reverted();
5353   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5354   emit_int8(0x54);
5355   emit_operand(dst, src);
5356 }
5357 
5358 void Assembler::vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5359   assert(VM_Version::supports_avx(), &quot;&quot;);
5360   InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5361   attributes.set_rex_vex_w_reverted();
5362   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5363   emit_int16(0x54, (0xC0 | encode));</span>

5364 }
5365 
5366 void Assembler::vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5367   assert(VM_Version::supports_avx(), &quot;&quot;);
5368   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5369   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5370   emit_int16(0x54, (0xC0 | encode));</span>

5371 }
5372 
5373 void Assembler::vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5374   assert(VM_Version::supports_avx(), &quot;&quot;);
5375   InstructionMark im(this);
5376   InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5377   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5378   attributes.set_rex_vex_w_reverted();
5379   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5380   emit_int8(0x54);
5381   emit_operand(dst, src);
5382 }
5383 
5384 void Assembler::vandps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5385   assert(VM_Version::supports_avx(), &quot;&quot;);
5386   InstructionMark im(this);
5387   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5388   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5389   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5390   emit_int8(0x54);
5391   emit_operand(dst, src);
5392 }
5393 
5394 void Assembler::unpckhpd(XMMRegister dst, XMMRegister src) {
5395   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5396   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5397   attributes.set_rex_vex_w_reverted();
5398   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5399   emit_int8(0x15);
<span class="line-modified">5400   emit_int8((0xC0 | encode));</span>
5401 }
5402 
5403 void Assembler::unpcklpd(XMMRegister dst, XMMRegister src) {
5404   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5405   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5406   attributes.set_rex_vex_w_reverted();
5407   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5408   emit_int16(0x14, (0xC0 | encode));</span>

5409 }
5410 
5411 void Assembler::xorpd(XMMRegister dst, XMMRegister src) {
5412   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5413   InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5414   attributes.set_rex_vex_w_reverted();
5415   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5416   emit_int16(0x57, (0xC0 | encode));</span>

5417 }
5418 
5419 void Assembler::xorps(XMMRegister dst, XMMRegister src) {
5420   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5421   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5422   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5423   emit_int16(0x57, (0xC0 | encode));</span>

5424 }
5425 
5426 void Assembler::xorpd(XMMRegister dst, Address src) {
5427   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5428   InstructionMark im(this);
5429   InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5430   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5431   attributes.set_rex_vex_w_reverted();
5432   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5433   emit_int8(0x57);
5434   emit_operand(dst, src);
5435 }
5436 
5437 void Assembler::xorps(XMMRegister dst, Address src) {
5438   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
5439   InstructionMark im(this);
5440   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5441   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5442   simd_prefix(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5443   emit_int8(0x57);
5444   emit_operand(dst, src);
5445 }
5446 
5447 void Assembler::vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5448   assert(VM_Version::supports_avx(), &quot;&quot;);
5449   InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5450   attributes.set_rex_vex_w_reverted();
5451   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5452   emit_int16(0x57, (0xC0 | encode));</span>

5453 }
5454 
5455 void Assembler::vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5456   assert(VM_Version::supports_avx(), &quot;&quot;);
5457   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5458   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5459   emit_int16(0x57, (0xC0 | encode));</span>

5460 }
5461 
5462 void Assembler::vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5463   assert(VM_Version::supports_avx(), &quot;&quot;);
5464   InstructionMark im(this);
5465   InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5466   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5467   attributes.set_rex_vex_w_reverted();
5468   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5469   emit_int8(0x57);
5470   emit_operand(dst, src);
5471 }
5472 
5473 void Assembler::vxorps(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5474   assert(VM_Version::supports_avx(), &quot;&quot;);
5475   InstructionMark im(this);
5476   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5477   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5478   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
5479   emit_int8(0x57);
5480   emit_operand(dst, src);
5481 }
5482 
5483 // Integer vector arithmetic
5484 void Assembler::vphaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5485   assert(VM_Version::supports_avx() &amp;&amp; (vector_len == 0) ||
5486          VM_Version::supports_avx2(), &quot;256 bit integer vectors requires AVX2&quot;);
5487   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
5488   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">5489   emit_int16(0x01, (0xC0 | encode));</span>

5490 }
5491 
5492 void Assembler::vphaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5493   assert(VM_Version::supports_avx() &amp;&amp; (vector_len == 0) ||
5494          VM_Version::supports_avx2(), &quot;256 bit integer vectors requires AVX2&quot;);
5495   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
5496   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">5497   emit_int16(0x02, (0xC0 | encode));</span>

5498 }
5499 
5500 void Assembler::paddb(XMMRegister dst, XMMRegister src) {
5501   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5502   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5503   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5504   emit_int16((unsigned char)0xFC, (0xC0 | encode));</span>

5505 }
5506 
5507 void Assembler::paddw(XMMRegister dst, XMMRegister src) {
5508   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5509   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5510   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5511   emit_int16((unsigned char)0xFD, (0xC0 | encode));</span>

5512 }
5513 
5514 void Assembler::paddd(XMMRegister dst, XMMRegister src) {
5515   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5516   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5517   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5518   emit_int16((unsigned char)0xFE, (0xC0 | encode));</span>

5519 }
5520 
5521 void Assembler::paddd(XMMRegister dst, Address src) {
5522   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5523   InstructionMark im(this);
5524   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5525   simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5526   emit_int8((unsigned char)0xFE);
5527   emit_operand(dst, src);
5528 }
5529 
5530 void Assembler::paddq(XMMRegister dst, XMMRegister src) {
5531   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5532   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5533   attributes.set_rex_vex_w_reverted();
5534   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5535   emit_int16((unsigned char)0xD4, (0xC0 | encode));</span>

5536 }
5537 
5538 void Assembler::phaddw(XMMRegister dst, XMMRegister src) {
5539   assert(VM_Version::supports_sse3(), &quot;&quot;);
5540   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
5541   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">5542   emit_int16(0x01, (0xC0 | encode));</span>

5543 }
5544 
5545 void Assembler::phaddd(XMMRegister dst, XMMRegister src) {
5546   assert(VM_Version::supports_sse3(), &quot;&quot;);
5547   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
5548   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">5549   emit_int16(0x02, (0xC0 | encode));</span>

5550 }
5551 
5552 void Assembler::vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5553   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5554   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5555   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5556   emit_int16((unsigned char)0xFC, (0xC0 | encode));</span>

5557 }
5558 
5559 void Assembler::vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5560   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5561   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5562   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5563   emit_int16((unsigned char)0xFD, (0xC0 | encode));</span>

5564 }
5565 
5566 void Assembler::vpaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5567   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5568   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5569   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5570   emit_int16((unsigned char)0xFE, (0xC0 | encode));</span>

5571 }
5572 
5573 void Assembler::vpaddq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5574   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5575   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5576   attributes.set_rex_vex_w_reverted();
5577   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5578   emit_int16((unsigned char)0xD4, (0xC0 | encode));</span>

5579 }
5580 
5581 void Assembler::vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5582   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5583   InstructionMark im(this);
5584   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5585   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
5586   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5587   emit_int8((unsigned char)0xFC);
5588   emit_operand(dst, src);
5589 }
5590 
5591 void Assembler::vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5592   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5593   InstructionMark im(this);
5594   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5595   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
5596   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5597   emit_int8((unsigned char)0xFD);
5598   emit_operand(dst, src);
</pre>
<hr />
<pre>
5606   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5607   emit_int8((unsigned char)0xFE);
5608   emit_operand(dst, src);
5609 }
5610 
5611 void Assembler::vpaddq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5612   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5613   InstructionMark im(this);
5614   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5615   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5616   attributes.set_rex_vex_w_reverted();
5617   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5618   emit_int8((unsigned char)0xD4);
5619   emit_operand(dst, src);
5620 }
5621 
5622 void Assembler::psubb(XMMRegister dst, XMMRegister src) {
5623   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5624   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5625   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5626   emit_int16((unsigned char)0xF8, (0xC0 | encode));</span>

5627 }
5628 
5629 void Assembler::psubw(XMMRegister dst, XMMRegister src) {
5630   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5631   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5632   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5633   emit_int16((unsigned char)0xF9, (0xC0 | encode));</span>

5634 }
5635 
5636 void Assembler::psubd(XMMRegister dst, XMMRegister src) {
5637   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5638   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5639   emit_int16((unsigned char)0xFA, (0xC0 | encode));</span>

5640 }
5641 
5642 void Assembler::psubq(XMMRegister dst, XMMRegister src) {
5643   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5644   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5645   attributes.set_rex_vex_w_reverted();
5646   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5647   emit_int8((unsigned char)0xFB);
<span class="line-modified">5648   emit_int8((0xC0 | encode));</span>
5649 }
5650 
5651 void Assembler::vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5652   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5653   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5654   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5655   emit_int16((unsigned char)0xF8, (0xC0 | encode));</span>

5656 }
5657 
5658 void Assembler::vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5659   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5660   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5661   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5662   emit_int16((unsigned char)0xF9, (0xC0 | encode));</span>

5663 }
5664 
5665 void Assembler::vpsubd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5666   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5667   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5668   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5669   emit_int16((unsigned char)0xFA, (0xC0 | encode));</span>

5670 }
5671 
5672 void Assembler::vpsubq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5673   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5674   InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5675   attributes.set_rex_vex_w_reverted();
5676   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5677   emit_int16((unsigned char)0xFB, (0xC0 | encode));</span>

5678 }
5679 
5680 void Assembler::vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5681   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5682   InstructionMark im(this);
5683   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5684   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
5685   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5686   emit_int8((unsigned char)0xF8);
5687   emit_operand(dst, src);
5688 }
5689 
5690 void Assembler::vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5691   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5692   InstructionMark im(this);
5693   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5694   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
5695   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5696   emit_int8((unsigned char)0xF9);
5697   emit_operand(dst, src);
</pre>
<hr />
<pre>
5705   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5706   emit_int8((unsigned char)0xFA);
5707   emit_operand(dst, src);
5708 }
5709 
5710 void Assembler::vpsubq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5711   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5712   InstructionMark im(this);
5713   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5714   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5715   attributes.set_rex_vex_w_reverted();
5716   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5717   emit_int8((unsigned char)0xFB);
5718   emit_operand(dst, src);
5719 }
5720 
5721 void Assembler::pmullw(XMMRegister dst, XMMRegister src) {
5722   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5723   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5724   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5725   emit_int16((unsigned char)0xD5, (0xC0 | encode));</span>

5726 }
5727 
5728 void Assembler::pmulld(XMMRegister dst, XMMRegister src) {
5729   assert(VM_Version::supports_sse4_1(), &quot;&quot;);
5730   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5731   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">5732   emit_int16(0x40, (0xC0 | encode));</span>

5733 }
5734 
5735 void Assembler::vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5736   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5737   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5738   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5739   emit_int16((unsigned char)0xD5, (0xC0 | encode));</span>

5740 }
5741 
5742 void Assembler::vpmulld(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5743   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5744   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5745   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">5746   emit_int16(0x40, (0xC0 | encode));</span>

5747 }
5748 
5749 void Assembler::vpmullq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5750   assert(UseAVX &gt; 2, &quot;requires some form of EVEX&quot;);
5751   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5752   attributes.set_is_evex_instruction();
5753   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">5754   emit_int16(0x40, (0xC0 | encode));</span>

5755 }
5756 
5757 void Assembler::vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5758   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5759   InstructionMark im(this);
5760   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5761   attributes.set_address_attributes(/* tuple_type */ EVEX_FVM, /* input_size_in_bits */ EVEX_NObit);
5762   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
5763   emit_int8((unsigned char)0xD5);
5764   emit_operand(dst, src);
5765 }
5766 
5767 void Assembler::vpmulld(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5768   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5769   InstructionMark im(this);
5770   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5771   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
5772   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5773   emit_int8(0x40);
5774   emit_operand(dst, src);
5775 }
5776 
5777 void Assembler::vpmullq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
5778   assert(UseAVX &gt; 2, &quot;requires some form of EVEX&quot;);
5779   InstructionMark im(this);
5780   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
5781   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
5782   attributes.set_is_evex_instruction();
5783   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
5784   emit_int8(0x40);
5785   emit_operand(dst, src);
5786 }
5787 
5788 // Shift packed integers left by specified number of bits.
5789 void Assembler::psllw(XMMRegister dst, int shift) {
5790   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5791   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5792   // XMM6 is for /6 encoding: 66 0F 71 /6 ib
5793   int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5794   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>


5795 }
5796 
5797 void Assembler::pslld(XMMRegister dst, int shift) {
5798   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5799   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5800   // XMM6 is for /6 encoding: 66 0F 72 /6 ib
5801   int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5802   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>


5803 }
5804 
5805 void Assembler::psllq(XMMRegister dst, int shift) {
5806   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5807   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5808   // XMM6 is for /6 encoding: 66 0F 73 /6 ib
5809   int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5810   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>


5811 }
5812 
5813 void Assembler::psllw(XMMRegister dst, XMMRegister shift) {
5814   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5815   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5816   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5817   emit_int16((unsigned char)0xF1, (0xC0 | encode));</span>

5818 }
5819 
5820 void Assembler::pslld(XMMRegister dst, XMMRegister shift) {
5821   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5822   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5823   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5824   emit_int16((unsigned char)0xF2, (0xC0 | encode));</span>

5825 }
5826 
5827 void Assembler::psllq(XMMRegister dst, XMMRegister shift) {
5828   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5829   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5830   attributes.set_rex_vex_w_reverted();
5831   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5832   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>

5833 }
5834 
5835 void Assembler::vpsllw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
5836   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5837   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5838   // XMM6 is for /6 encoding: 66 0F 71 /6 ib
5839   int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5840   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>


5841 }
5842 
5843 void Assembler::vpslld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
5844   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5845   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5846   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5847   // XMM6 is for /6 encoding: 66 0F 72 /6 ib
5848   int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5849   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>


5850 }
5851 
5852 void Assembler::vpsllq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
5853   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5854   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5855   attributes.set_rex_vex_w_reverted();
5856   // XMM6 is for /6 encoding: 66 0F 73 /6 ib
5857   int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5858   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>


5859 }
5860 
5861 void Assembler::vpsllw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
5862   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5863   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5864   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5865   emit_int16((unsigned char)0xF1, (0xC0 | encode));</span>

5866 }
5867 
5868 void Assembler::vpslld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
5869   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5870   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5871   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5872   emit_int16((unsigned char)0xF2, (0xC0 | encode));</span>

5873 }
5874 
5875 void Assembler::vpsllq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
5876   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5877   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5878   attributes.set_rex_vex_w_reverted();
5879   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5880   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>

5881 }
5882 
5883 // Shift packed integers logically right by specified number of bits.
5884 void Assembler::psrlw(XMMRegister dst, int shift) {
5885   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5886   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5887   // XMM2 is for /2 encoding: 66 0F 71 /2 ib
5888   int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5889   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>


5890 }
5891 
5892 void Assembler::psrld(XMMRegister dst, int shift) {
5893   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5894   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5895   // XMM2 is for /2 encoding: 66 0F 72 /2 ib
5896   int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5897   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>


5898 }
5899 
5900 void Assembler::psrlq(XMMRegister dst, int shift) {
5901   // Do not confuse it with psrldq SSE2 instruction which
5902   // shifts 128 bit value in xmm register by number of bytes.
5903   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5904   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5905   attributes.set_rex_vex_w_reverted();
5906   // XMM2 is for /2 encoding: 66 0F 73 /2 ib
5907   int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5908   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>


5909 }
5910 
5911 void Assembler::psrlw(XMMRegister dst, XMMRegister shift) {
5912   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5913   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5914   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5915   emit_int16((unsigned char)0xD1, (0xC0 | encode));</span>

5916 }
5917 
5918 void Assembler::psrld(XMMRegister dst, XMMRegister shift) {
5919   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5920   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5921   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5922   emit_int16((unsigned char)0xD2, (0xC0 | encode));</span>

5923 }
5924 
5925 void Assembler::psrlq(XMMRegister dst, XMMRegister shift) {
5926   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5927   InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5928   attributes.set_rex_vex_w_reverted();
5929   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5930   emit_int16((unsigned char)0xD3, (0xC0 | encode));</span>

5931 }
5932 
5933 void Assembler::vpsrlw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
5934   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5935   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5936   // XMM2 is for /2 encoding: 66 0F 71 /2 ib
5937   int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5938   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>


5939 }
5940 
5941 void Assembler::vpsrld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
5942   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5943   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5944   // XMM2 is for /2 encoding: 66 0F 72 /2 ib
5945   int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5946   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>


5947 }
5948 
5949 void Assembler::vpsrlq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
5950   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5951   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5952   attributes.set_rex_vex_w_reverted();
5953   // XMM2 is for /2 encoding: 66 0F 73 /2 ib
5954   int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5955   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>


5956 }
5957 
5958 void Assembler::vpsrlw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
5959   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5960   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
5961   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5962   emit_int16((unsigned char)0xD1, (0xC0 | encode));</span>

5963 }
5964 
5965 void Assembler::vpsrld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
5966   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5967   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5968   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5969   emit_int16((unsigned char)0xD2, (0xC0 | encode));</span>

5970 }
5971 
5972 void Assembler::vpsrlq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
5973   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
5974   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5975   attributes.set_rex_vex_w_reverted();
5976   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">5977   emit_int16((unsigned char)0xD3, (0xC0 | encode));</span>

5978 }
5979 
5980 void Assembler::evpsrlvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5981   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
5982   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5983   attributes.set_is_evex_instruction();
5984   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">5985   emit_int16(0x10, (0xC0 | encode));</span>

5986 }
5987 
5988 void Assembler::evpsllvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
5989   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
5990   InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
5991   attributes.set_is_evex_instruction();
5992   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">5993   emit_int16(0x12, (0xC0 | encode));</span>

5994 }
5995 
5996 // Shift packed integers arithmetically right by specified number of bits.
5997 void Assembler::psraw(XMMRegister dst, int shift) {
5998   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
5999   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6000   // XMM4 is for /4 encoding: 66 0F 71 /4 ib
6001   int encode = simd_prefix_and_encode(xmm4, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6002   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>


6003 }
6004 
6005 void Assembler::psrad(XMMRegister dst, int shift) {
6006   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6007   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6008   // XMM4 is for /4 encoding: 66 0F 72 /4 ib
6009   int encode = simd_prefix_and_encode(xmm4, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6010   emit_int8(0x72);
<span class="line-modified">6011   emit_int8((0xC0 | encode));</span>
6012   emit_int8(shift &amp; 0xFF);
6013 }
6014 
6015 void Assembler::psraw(XMMRegister dst, XMMRegister shift) {
6016   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6017   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6018   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6019   emit_int16((unsigned char)0xE1, (0xC0 | encode));</span>

6020 }
6021 
6022 void Assembler::psrad(XMMRegister dst, XMMRegister shift) {
6023   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6024   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6025   int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6026   emit_int16((unsigned char)0xE2, (0xC0 | encode));</span>

6027 }
6028 
6029 void Assembler::vpsraw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6030   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6031   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6032   // XMM4 is for /4 encoding: 66 0F 71 /4 ib
6033   int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6034   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>


6035 }
6036 
6037 void Assembler::vpsrad(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6038   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6039   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6040   // XMM4 is for /4 encoding: 66 0F 71 /4 ib
6041   int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6042   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>


6043 }
6044 
6045 void Assembler::vpsraw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6046   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6047   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6048   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6049   emit_int16((unsigned char)0xE1, (0xC0 | encode));</span>

6050 }
6051 
6052 void Assembler::vpsrad(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6053   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6054   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6055   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6056   emit_int16((unsigned char)0xE2, (0xC0 | encode));</span>

6057 }
6058 
6059 void Assembler::evpsraq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
6060   assert(UseAVX &gt; 2, &quot;requires AVX512&quot;);
6061   assert ((VM_Version::supports_avx512vl() || vector_len == 2), &quot;requires AVX512vl&quot;);
6062   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6063   attributes.set_is_evex_instruction();
6064   int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6065   emit_int24((unsigned char)0x72, (0xC0 | encode), shift &amp; 0xFF);</span>


6066 }
6067 
6068 void Assembler::evpsraq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
6069   assert(UseAVX &gt; 2, &quot;requires AVX512&quot;);
6070   assert ((VM_Version::supports_avx512vl() || vector_len == 2), &quot;requires AVX512vl&quot;);
6071   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6072   attributes.set_is_evex_instruction();
6073   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6074   emit_int16((unsigned char)0xE2, (0xC0 | encode));</span>

6075 }
6076 
6077 // logical operations packed integers
6078 void Assembler::pand(XMMRegister dst, XMMRegister src) {
6079   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6080   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6081   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6082   emit_int16((unsigned char)0xDB, (0xC0 | encode));</span>

6083 }
6084 
6085 void Assembler::vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6086   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6087   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6088   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6089   emit_int16((unsigned char)0xDB, (0xC0 | encode));</span>

6090 }
6091 
6092 void Assembler::vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6093   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6094   InstructionMark im(this);
6095   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6096   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
6097   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6098   emit_int8((unsigned char)0xDB);
6099   emit_operand(dst, src);
6100 }
6101 
6102 void Assembler::vpandq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6103   assert(VM_Version::supports_evex(), &quot;&quot;);
6104   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6105   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6106   emit_int16((unsigned char)0xDB, (0xC0 | encode));</span>

6107 }
6108 
6109 void Assembler::vpshldvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
<span class="line-modified">6110   assert(VM_Version::supports_avx512_vbmi2(), &quot;requires vbmi2&quot;);</span>
6111   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6112   attributes.set_is_evex_instruction();
6113   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6114   emit_int8(0x71);
<span class="line-modified">6115   emit_int8((0xC0 | encode));</span>
6116 }
6117 
6118 void Assembler::vpshrdvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
<span class="line-modified">6119   assert(VM_Version::supports_avx512_vbmi2(), &quot;requires vbmi2&quot;);</span>
6120   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6121   attributes.set_is_evex_instruction();
6122   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">6123   emit_int16(0x73, (0xC0 | encode));</span>

6124 }
6125 
6126 void Assembler::pandn(XMMRegister dst, XMMRegister src) {
6127   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6128   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6129   attributes.set_rex_vex_w_reverted();
6130   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6131   emit_int16((unsigned char)0xDF, (0xC0 | encode));</span>

6132 }
6133 
6134 void Assembler::vpandn(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6135   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6136   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6137   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6138   emit_int16((unsigned char)0xDF, (0xC0 | encode));</span>

6139 }
6140 
6141 
6142 void Assembler::por(XMMRegister dst, XMMRegister src) {
6143   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6144   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6145   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6146   emit_int16((unsigned char)0xEB, (0xC0 | encode));</span>

6147 }
6148 
6149 void Assembler::vpor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6150   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6151   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6152   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6153   emit_int16((unsigned char)0xEB, (0xC0 | encode));</span>

6154 }
6155 
6156 void Assembler::vpor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6157   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6158   InstructionMark im(this);
6159   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6160   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
6161   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6162   emit_int8((unsigned char)0xEB);
6163   emit_operand(dst, src);
6164 }
6165 
6166 void Assembler::vporq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6167   assert(VM_Version::supports_evex(), &quot;&quot;);
6168   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6169   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6170   emit_int16((unsigned char)0xEB, (0xC0 | encode));</span>

6171 }
6172 
6173 
6174 void Assembler::pxor(XMMRegister dst, XMMRegister src) {
6175   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
6176   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6177   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6178   emit_int16((unsigned char)0xEF, (0xC0 | encode));</span>

6179 }
6180 
6181 void Assembler::vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6182   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6183   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6184   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">6185   emit_int16((unsigned char)0xEF, (0xC0 | encode));</span>

6186 }
6187 
6188 void Assembler::vpxor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6189   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
6190   InstructionMark im(this);
6191   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6192   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_32bit);
6193   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6194   emit_int8((unsigned char)0xEF);
6195   emit_operand(dst, src);
6196 }
6197 
6198 void Assembler::evpxorq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
6199   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
6200   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6201   attributes.set_is_evex_instruction();
6202   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6203   emit_int8((unsigned char)0xEF);
<span class="line-modified">6204   emit_int8((0xC0 | encode));</span>
6205 }
6206 
6207 void Assembler::evpxorq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
6208   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
6209   assert(dst != xnoreg, &quot;sanity&quot;);
6210   InstructionMark im(this);
6211   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6212   attributes.set_is_evex_instruction();
6213   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
6214   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
6215   emit_int8((unsigned char)0xEF);
6216   emit_operand(dst, src);
6217 }
6218 
6219 
6220 // vinserti forms
6221 
6222 void Assembler::vinserti128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6223   assert(VM_Version::supports_avx2(), &quot;&quot;);
6224   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6225   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6226   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6227   // last byte:</span>

6228   // 0x00 - insert into lower 128 bits
6229   // 0x01 - insert into upper 128 bits
<span class="line-modified">6230   emit_int24(0x38, (0xC0 | encode), imm8 &amp; 0x01);</span>
6231 }
6232 
6233 void Assembler::vinserti128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6234   assert(VM_Version::supports_avx2(), &quot;&quot;);
6235   assert(dst != xnoreg, &quot;sanity&quot;);
6236   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6237   InstructionMark im(this);
6238   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6239   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6240   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6241   emit_int8(0x38);
6242   emit_operand(dst, src);
6243   // 0x00 - insert into lower 128 bits
6244   // 0x01 - insert into upper 128 bits
6245   emit_int8(imm8 &amp; 0x01);
6246 }
6247 
6248 void Assembler::vinserti32x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6249   assert(VM_Version::supports_evex(), &quot;&quot;);
6250   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6251   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6252   attributes.set_is_evex_instruction();
6253   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6254   // imm8:</span>

6255   // 0x00 - insert into q0 128 bits (0..127)
6256   // 0x01 - insert into q1 128 bits (128..255)
6257   // 0x02 - insert into q2 128 bits (256..383)
6258   // 0x03 - insert into q3 128 bits (384..511)
<span class="line-modified">6259   emit_int24(0x38, (0xC0 | encode), imm8 &amp; 0x03);</span>
6260 }
6261 
6262 void Assembler::vinserti32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6263   assert(VM_Version::supports_avx(), &quot;&quot;);
6264   assert(dst != xnoreg, &quot;sanity&quot;);
6265   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6266   InstructionMark im(this);
6267   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6268   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6269   attributes.set_is_evex_instruction();
6270   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6271   emit_int8(0x18);
6272   emit_operand(dst, src);
6273   // 0x00 - insert into q0 128 bits (0..127)
6274   // 0x01 - insert into q1 128 bits (128..255)
6275   // 0x02 - insert into q2 128 bits (256..383)
6276   // 0x03 - insert into q3 128 bits (384..511)
6277   emit_int8(imm8 &amp; 0x03);
6278 }
6279 
6280 void Assembler::vinserti64x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6281   assert(VM_Version::supports_evex(), &quot;&quot;);
6282   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6283   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6284   attributes.set_is_evex_instruction();
6285   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6286   //imm8:</span>

6287   // 0x00 - insert into lower 256 bits
6288   // 0x01 - insert into upper 256 bits
<span class="line-modified">6289   emit_int24(0x3A, (0xC0 | encode), imm8 &amp; 0x01);</span>
6290 }
6291 
6292 
6293 // vinsertf forms
6294 
6295 void Assembler::vinsertf128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6296   assert(VM_Version::supports_avx(), &quot;&quot;);
6297   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6298   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6299   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6300   // imm8:</span>

6301   // 0x00 - insert into lower 128 bits
6302   // 0x01 - insert into upper 128 bits
<span class="line-modified">6303   emit_int24(0x18, (0xC0 | encode), imm8 &amp; 0x01);</span>
6304 }
6305 
6306 void Assembler::vinsertf128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6307   assert(VM_Version::supports_avx(), &quot;&quot;);
6308   assert(dst != xnoreg, &quot;sanity&quot;);
6309   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6310   InstructionMark im(this);
6311   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6312   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6313   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6314   emit_int8(0x18);
6315   emit_operand(dst, src);
6316   // 0x00 - insert into lower 128 bits
6317   // 0x01 - insert into upper 128 bits
6318   emit_int8(imm8 &amp; 0x01);
6319 }
6320 
6321 void Assembler::vinsertf32x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6322   assert(VM_Version::supports_avx2(), &quot;&quot;);
6323   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6324   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6325   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6326   // imm8:</span>

6327   // 0x00 - insert into q0 128 bits (0..127)
6328   // 0x01 - insert into q1 128 bits (128..255)
6329   // 0x02 - insert into q0 128 bits (256..383)
6330   // 0x03 - insert into q1 128 bits (384..512)
<span class="line-modified">6331   emit_int24(0x18, (0xC0 | encode), imm8 &amp; 0x03);</span>
6332 }
6333 
6334 void Assembler::vinsertf32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6335   assert(VM_Version::supports_avx(), &quot;&quot;);
6336   assert(dst != xnoreg, &quot;sanity&quot;);
6337   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6338   InstructionMark im(this);
6339   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6340   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6341   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6342   emit_int8(0x18);
6343   emit_operand(dst, src);
6344   // 0x00 - insert into q0 128 bits (0..127)
6345   // 0x01 - insert into q1 128 bits (128..255)
6346   // 0x02 - insert into q0 128 bits (256..383)
6347   // 0x03 - insert into q1 128 bits (384..512)
6348   emit_int8(imm8 &amp; 0x03);
6349 }
6350 
6351 void Assembler::vinsertf64x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
6352   assert(VM_Version::supports_evex(), &quot;&quot;);
6353   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6354   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6355   attributes.set_is_evex_instruction();
6356   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6357   // imm8:</span>

6358   // 0x00 - insert into lower 256 bits
6359   // 0x01 - insert into upper 256 bits
<span class="line-modified">6360   emit_int24(0x1A, (0xC0 | encode), imm8 &amp; 0x01);</span>
6361 }
6362 
6363 void Assembler::vinsertf64x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
6364   assert(VM_Version::supports_evex(), &quot;&quot;);
6365   assert(dst != xnoreg, &quot;sanity&quot;);
6366   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6367   InstructionMark im(this);
6368   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6369   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_64bit);
6370   attributes.set_is_evex_instruction();
6371   vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6372   emit_int8(0x1A);
6373   emit_operand(dst, src);
6374   // 0x00 - insert into lower 256 bits
6375   // 0x01 - insert into upper 256 bits
6376   emit_int8(imm8 &amp; 0x01);
6377 }
6378 
6379 
6380 // vextracti forms
6381 
6382 void Assembler::vextracti128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6383   assert(VM_Version::supports_avx2(), &quot;&quot;);
6384   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6385   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6386   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6387   // imm8:</span>

6388   // 0x00 - extract from lower 128 bits
6389   // 0x01 - extract from upper 128 bits
<span class="line-modified">6390   emit_int24(0x39, (0xC0 | encode), imm8 &amp; 0x01);</span>
6391 }
6392 
6393 void Assembler::vextracti128(Address dst, XMMRegister src, uint8_t imm8) {
6394   assert(VM_Version::supports_avx2(), &quot;&quot;);
6395   assert(src != xnoreg, &quot;sanity&quot;);
6396   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6397   InstructionMark im(this);
6398   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6399   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6400   attributes.reset_is_clear_context();
6401   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6402   emit_int8(0x39);
6403   emit_operand(src, dst);
6404   // 0x00 - extract from lower 128 bits
6405   // 0x01 - extract from upper 128 bits
6406   emit_int8(imm8 &amp; 0x01);
6407 }
6408 
6409 void Assembler::vextracti32x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6410   assert(VM_Version::supports_evex(), &quot;&quot;);
6411   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6412   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6413   attributes.set_is_evex_instruction();
6414   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6415   // imm8:</span>

6416   // 0x00 - extract from bits 127:0
6417   // 0x01 - extract from bits 255:128
6418   // 0x02 - extract from bits 383:256
6419   // 0x03 - extract from bits 511:384
<span class="line-modified">6420   emit_int24(0x39, (0xC0 | encode), imm8 &amp; 0x03);</span>
6421 }
6422 
6423 void Assembler::vextracti32x4(Address dst, XMMRegister src, uint8_t imm8) {
6424   assert(VM_Version::supports_evex(), &quot;&quot;);
6425   assert(src != xnoreg, &quot;sanity&quot;);
6426   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6427   InstructionMark im(this);
6428   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6429   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6430   attributes.reset_is_clear_context();
6431   attributes.set_is_evex_instruction();
6432   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6433   emit_int8(0x39);
6434   emit_operand(src, dst);
6435   // 0x00 - extract from bits 127:0
6436   // 0x01 - extract from bits 255:128
6437   // 0x02 - extract from bits 383:256
6438   // 0x03 - extract from bits 511:384
6439   emit_int8(imm8 &amp; 0x03);
6440 }
6441 
6442 void Assembler::vextracti64x2(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6443   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
6444   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6445   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6446   attributes.set_is_evex_instruction();
6447   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6448   // imm8:</span>

6449   // 0x00 - extract from bits 127:0
6450   // 0x01 - extract from bits 255:128
6451   // 0x02 - extract from bits 383:256
6452   // 0x03 - extract from bits 511:384
<span class="line-modified">6453   emit_int24(0x39, (0xC0 | encode), imm8 &amp; 0x03);</span>
6454 }
6455 
6456 void Assembler::vextracti64x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6457   assert(VM_Version::supports_evex(), &quot;&quot;);
6458   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6459   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6460   attributes.set_is_evex_instruction();
6461   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6462   // imm8:</span>

6463   // 0x00 - extract from lower 256 bits
6464   // 0x01 - extract from upper 256 bits
<span class="line-modified">6465   emit_int24(0x3B, (0xC0 | encode), imm8 &amp; 0x01);</span>
6466 }
6467 
6468 void Assembler::vextracti64x4(Address dst, XMMRegister src, uint8_t imm8) {
6469   assert(VM_Version::supports_evex(), &quot;&quot;);
6470   assert(src != xnoreg, &quot;sanity&quot;);
6471   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6472   InstructionMark im(this);
6473   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6474   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_64bit);
6475   attributes.reset_is_clear_context();
6476   attributes.set_is_evex_instruction();
6477   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6478   emit_int8(0x38);
6479   emit_operand(src, dst);
6480   // 0x00 - extract from lower 256 bits
6481   // 0x01 - extract from upper 256 bits
6482   emit_int8(imm8 &amp; 0x01);
6483 }
6484 // vextractf forms
6485 
6486 void Assembler::vextractf128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6487   assert(VM_Version::supports_avx(), &quot;&quot;);
6488   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6489   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6490   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6491   // imm8:</span>

6492   // 0x00 - extract from lower 128 bits
6493   // 0x01 - extract from upper 128 bits
<span class="line-modified">6494   emit_int24(0x19, (0xC0 | encode), imm8 &amp; 0x01);</span>
6495 }
6496 
6497 void Assembler::vextractf128(Address dst, XMMRegister src, uint8_t imm8) {
6498   assert(VM_Version::supports_avx(), &quot;&quot;);
6499   assert(src != xnoreg, &quot;sanity&quot;);
6500   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6501   InstructionMark im(this);
6502   InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6503   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6504   attributes.reset_is_clear_context();
6505   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6506   emit_int8(0x19);
6507   emit_operand(src, dst);
6508   // 0x00 - extract from lower 128 bits
6509   // 0x01 - extract from upper 128 bits
6510   emit_int8(imm8 &amp; 0x01);
6511 }
6512 
6513 void Assembler::vextractf32x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6514   assert(VM_Version::supports_evex(), &quot;&quot;);
6515   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6516   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6517   attributes.set_is_evex_instruction();
6518   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6519   // imm8:</span>

6520   // 0x00 - extract from bits 127:0
6521   // 0x01 - extract from bits 255:128
6522   // 0x02 - extract from bits 383:256
6523   // 0x03 - extract from bits 511:384
<span class="line-modified">6524   emit_int24(0x19, (0xC0 | encode), imm8 &amp; 0x03);</span>
6525 }
6526 
6527 void Assembler::vextractf32x4(Address dst, XMMRegister src, uint8_t imm8) {
6528   assert(VM_Version::supports_evex(), &quot;&quot;);
6529   assert(src != xnoreg, &quot;sanity&quot;);
6530   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6531   InstructionMark im(this);
6532   InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6533   attributes.set_address_attributes(/* tuple_type */ EVEX_T4, /* input_size_in_bits */ EVEX_32bit);
6534   attributes.reset_is_clear_context();
6535   attributes.set_is_evex_instruction();
6536   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6537   emit_int8(0x19);
6538   emit_operand(src, dst);
6539   // 0x00 - extract from bits 127:0
6540   // 0x01 - extract from bits 255:128
6541   // 0x02 - extract from bits 383:256
6542   // 0x03 - extract from bits 511:384
6543   emit_int8(imm8 &amp; 0x03);
6544 }
6545 
6546 void Assembler::vextractf64x2(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6547   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
6548   assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
6549   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6550   attributes.set_is_evex_instruction();
6551   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6552   // imm8:</span>

6553   // 0x00 - extract from bits 127:0
6554   // 0x01 - extract from bits 255:128
6555   // 0x02 - extract from bits 383:256
6556   // 0x03 - extract from bits 511:384
<span class="line-modified">6557   emit_int24(0x19, (0xC0 | encode), imm8 &amp; 0x03);</span>
6558 }
6559 
6560 void Assembler::vextractf64x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
6561   assert(VM_Version::supports_evex(), &quot;&quot;);
6562   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6563   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6564   attributes.set_is_evex_instruction();
6565   int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6566   // imm8:</span>

6567   // 0x00 - extract from lower 256 bits
6568   // 0x01 - extract from upper 256 bits
<span class="line-modified">6569   emit_int24(0x1B, (0xC0 | encode), imm8 &amp; 0x01);</span>
6570 }
6571 
6572 void Assembler::vextractf64x4(Address dst, XMMRegister src, uint8_t imm8) {
6573   assert(VM_Version::supports_evex(), &quot;&quot;);
6574   assert(src != xnoreg, &quot;sanity&quot;);
6575   assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
6576   InstructionMark im(this);
6577   InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6578   attributes.set_address_attributes(/* tuple_type */ EVEX_T4,/* input_size_in_bits */  EVEX_64bit);
6579   attributes.reset_is_clear_context();
6580   attributes.set_is_evex_instruction();
6581   vex_prefix(dst, 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
6582   emit_int8(0x1B);
6583   emit_operand(src, dst);
6584   // 0x00 - extract from lower 256 bits
6585   // 0x01 - extract from upper 256 bits
6586   emit_int8(imm8 &amp; 0x01);
6587 }
6588 
6589 // duplicate 1-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
6590 void Assembler::vpbroadcastb(XMMRegister dst, XMMRegister src, int vector_len) {
6591   assert(VM_Version::supports_avx2(), &quot;&quot;);
6592   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6593   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">6594   emit_int16(0x78, (0xC0 | encode));</span>

6595 }
6596 
6597 void Assembler::vpbroadcastb(XMMRegister dst, Address src, int vector_len) {
6598   assert(VM_Version::supports_avx2(), &quot;&quot;);
6599   assert(dst != xnoreg, &quot;sanity&quot;);
6600   InstructionMark im(this);
6601   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6602   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_8bit);
6603   // swap src&lt;-&gt;dst for encoding
6604   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6605   emit_int8(0x78);
6606   emit_operand(dst, src);
6607 }
6608 
6609 // duplicate 2-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
6610 void Assembler::vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len) {
6611   assert(VM_Version::supports_avx2(), &quot;&quot;);
6612   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6613   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">6614   emit_int16(0x79, (0xC0 | encode));</span>

6615 }
6616 
6617 void Assembler::vpbroadcastw(XMMRegister dst, Address src, int vector_len) {
6618   assert(VM_Version::supports_avx2(), &quot;&quot;);
6619   assert(dst != xnoreg, &quot;sanity&quot;);
6620   InstructionMark im(this);
6621   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6622   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_16bit);
6623   // swap src&lt;-&gt;dst for encoding
6624   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6625   emit_int8(0x79);
6626   emit_operand(dst, src);
6627 }
6628 
6629 // xmm/mem sourced byte/word/dword/qword replicate
6630 
6631 // duplicate 4-byte integer data from src into programmed locations in dest : requires AVX512VL
6632 void Assembler::vpbroadcastd(XMMRegister dst, XMMRegister src, int vector_len) {
6633   assert(UseAVX &gt;= 2, &quot;&quot;);
6634   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6635   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">6636   emit_int16(0x58, (0xC0 | encode));</span>

6637 }
6638 
6639 void Assembler::vpbroadcastd(XMMRegister dst, Address src, int vector_len) {
6640   assert(VM_Version::supports_avx2(), &quot;&quot;);
6641   assert(dst != xnoreg, &quot;sanity&quot;);
6642   InstructionMark im(this);
6643   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6644   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
6645   // swap src&lt;-&gt;dst for encoding
6646   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6647   emit_int8(0x58);
6648   emit_operand(dst, src);
6649 }
6650 
6651 // duplicate 8-byte integer data from src into programmed locations in dest : requires AVX512VL
6652 void Assembler::vpbroadcastq(XMMRegister dst, XMMRegister src, int vector_len) {
6653   assert(VM_Version::supports_avx2(), &quot;&quot;);
6654   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6655   attributes.set_rex_vex_w_reverted();
6656   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">6657   emit_int16(0x59, (0xC0 | encode));</span>

6658 }
6659 
6660 void Assembler::vpbroadcastq(XMMRegister dst, Address src, int vector_len) {
6661   assert(VM_Version::supports_avx2(), &quot;&quot;);
6662   assert(dst != xnoreg, &quot;sanity&quot;);
6663   InstructionMark im(this);
6664   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6665   attributes.set_rex_vex_w_reverted();
6666   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
6667   // swap src&lt;-&gt;dst for encoding
6668   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6669   emit_int8(0x59);
6670   emit_operand(dst, src);
6671 }
6672 void Assembler::evbroadcasti64x2(XMMRegister dst, XMMRegister src, int vector_len) {
6673   assert(vector_len != Assembler::AVX_128bit, &quot;&quot;);
6674   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
6675   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6676   attributes.set_rex_vex_w_reverted();
6677   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">6678   emit_int16(0x5A, (0xC0 | encode));</span>

6679 }
6680 
6681 void Assembler::evbroadcasti64x2(XMMRegister dst, Address src, int vector_len) {
6682   assert(vector_len != Assembler::AVX_128bit, &quot;&quot;);
6683   assert(VM_Version::supports_avx512dq(), &quot;&quot;);
6684   assert(dst != xnoreg, &quot;sanity&quot;);
6685   InstructionMark im(this);
6686   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6687   attributes.set_rex_vex_w_reverted();
6688   attributes.set_address_attributes(/* tuple_type */ EVEX_T2, /* input_size_in_bits */ EVEX_64bit);
6689   // swap src&lt;-&gt;dst for encoding
6690   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6691   emit_int8(0x5A);
6692   emit_operand(dst, src);
6693 }
6694 
6695 // scalar single/double precision replicate
6696 
6697 // duplicate single precision data from src into programmed locations in dest : requires AVX512VL
6698 void Assembler::vbroadcastss(XMMRegister dst, XMMRegister src, int vector_len) {
<span class="line-modified">6699   assert(VM_Version::supports_avx2(), &quot;&quot;);</span>
6700   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6701   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">6702   emit_int16(0x18, (0xC0 | encode));</span>

6703 }
6704 
6705 void Assembler::vbroadcastss(XMMRegister dst, Address src, int vector_len) {
6706   assert(VM_Version::supports_avx(), &quot;&quot;);
6707   assert(dst != xnoreg, &quot;sanity&quot;);
6708   InstructionMark im(this);
6709   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6710   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_32bit);
6711   // swap src&lt;-&gt;dst for encoding
6712   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6713   emit_int8(0x18);
6714   emit_operand(dst, src);
6715 }
6716 
6717 // duplicate double precision data from src into programmed locations in dest : requires AVX512VL
6718 void Assembler::vbroadcastsd(XMMRegister dst, XMMRegister src, int vector_len) {
<span class="line-modified">6719   assert(VM_Version::supports_avx2(), &quot;&quot;);</span>
<span class="line-added">6720   assert(vector_len == AVX_256bit || vector_len == AVX_512bit, &quot;&quot;);</span>
6721   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6722   attributes.set_rex_vex_w_reverted();
6723   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">6724   emit_int16(0x19, (0xC0 | encode));</span>

6725 }
6726 
6727 void Assembler::vbroadcastsd(XMMRegister dst, Address src, int vector_len) {
6728   assert(VM_Version::supports_avx(), &quot;&quot;);
<span class="line-added">6729   assert(vector_len == AVX_256bit || vector_len == AVX_512bit, &quot;&quot;);</span>
6730   assert(dst != xnoreg, &quot;sanity&quot;);
6731   InstructionMark im(this);
6732   InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6733   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
6734   attributes.set_rex_vex_w_reverted();
6735   // swap src&lt;-&gt;dst for encoding
6736   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6737   emit_int8(0x19);
6738   emit_operand(dst, src);
6739 }
6740 
6741 
6742 // gpr source broadcast forms
6743 
6744 // duplicate 1-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
6745 void Assembler::evpbroadcastb(XMMRegister dst, Register src, int vector_len) {
6746   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
6747   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6748   attributes.set_is_evex_instruction();
6749   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">6750   emit_int16(0x7A, (0xC0 | encode));</span>

6751 }
6752 
6753 // duplicate 2-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
6754 void Assembler::evpbroadcastw(XMMRegister dst, Register src, int vector_len) {
6755   assert(VM_Version::supports_avx512bw(), &quot;&quot;);
6756   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
6757   attributes.set_is_evex_instruction();
6758   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">6759   emit_int16(0x7B, (0xC0 | encode));</span>

6760 }
6761 
6762 // duplicate 4-byte integer data from src into programmed locations in dest : requires AVX512VL
6763 void Assembler::evpbroadcastd(XMMRegister dst, Register src, int vector_len) {
6764   assert(VM_Version::supports_evex(), &quot;&quot;);
6765   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6766   attributes.set_is_evex_instruction();
6767   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">6768   emit_int16(0x7C, (0xC0 | encode));</span>

6769 }
6770 
6771 // duplicate 8-byte integer data from src into programmed locations in dest : requires AVX512VL
6772 void Assembler::evpbroadcastq(XMMRegister dst, Register src, int vector_len) {
6773   assert(VM_Version::supports_evex(), &quot;&quot;);
6774   InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6775   attributes.set_is_evex_instruction();
6776   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">6777   emit_int16(0x7C, (0xC0 | encode));</span>

6778 }
6779 void Assembler::evpgatherdd(XMMRegister dst, KRegister mask, Address src, int vector_len) {
6780   assert(VM_Version::supports_evex(), &quot;&quot;);
6781   assert(dst != xnoreg, &quot;sanity&quot;);
6782   InstructionMark im(this);
6783   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
6784   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
6785   attributes.reset_is_clear_context();
6786   attributes.set_embedded_opmask_register_specifier(mask);
6787   attributes.set_is_evex_instruction();
6788   // swap src&lt;-&gt;dst for encoding
6789   vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
6790   emit_int8((unsigned char)0x90);
6791   emit_operand(dst, src);
6792 }
6793 // Carry-Less Multiplication Quadword
6794 void Assembler::pclmulqdq(XMMRegister dst, XMMRegister src, int mask) {
6795   assert(VM_Version::supports_clmul(), &quot;&quot;);
6796   InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
6797   int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6798   emit_int24(0x44, (0xC0 | encode), (unsigned char)mask);</span>


6799 }
6800 
6801 // Carry-Less Multiplication Quadword
6802 void Assembler::vpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask) {
6803   assert(VM_Version::supports_avx() &amp;&amp; VM_Version::supports_clmul(), &quot;&quot;);
6804   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
6805   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6806   emit_int24(0x44, (0xC0 | encode), (unsigned char)mask);</span>


6807 }
6808 
6809 void Assembler::evpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask, int vector_len) {
6810   assert(VM_Version::supports_avx512_vpclmulqdq(), &quot;Requires vector carryless multiplication support&quot;);
6811   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
6812   attributes.set_is_evex_instruction();
6813   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">6814   emit_int24(0x44, (0xC0 | encode), (unsigned char)mask);</span>


6815 }
6816 
<span class="line-modified">6817 void Assembler::vzeroupper_uncached() {</span>
6818   if (VM_Version::supports_vzeroupper()) {
6819     InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
6820     (void)vex_prefix_and_encode(0, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
6821     emit_int8(0x77);
6822   }
6823 }
6824 
6825 #ifndef _LP64
6826 // 32bit only pieces of the assembler
6827 
<span class="line-added">6828 void Assembler::emms() {</span>
<span class="line-added">6829   NOT_LP64(assert(VM_Version::supports_mmx(), &quot;&quot;));</span>
<span class="line-added">6830   emit_int16(0x0F, 0x77);</span>
<span class="line-added">6831 }</span>
<span class="line-added">6832 </span>
<span class="line-added">6833 void Assembler::vzeroupper() {</span>
<span class="line-added">6834   vzeroupper_uncached();</span>
<span class="line-added">6835 }</span>
<span class="line-added">6836 </span>
6837 void Assembler::cmp_literal32(Register src1, int32_t imm32, RelocationHolder const&amp; rspec) {
6838   // NO PREFIX AS NEVER 64BIT
6839   InstructionMark im(this);
<span class="line-modified">6840   emit_int16((unsigned char)0x81, (0xF8 | src1-&gt;encoding()));</span>

6841   emit_data(imm32, rspec, 0);
6842 }
6843 
6844 void Assembler::cmp_literal32(Address src1, int32_t imm32, RelocationHolder const&amp; rspec) {
6845   // NO PREFIX AS NEVER 64BIT (not even 32bit versions of 64bit regs
6846   InstructionMark im(this);
6847   emit_int8((unsigned char)0x81);
6848   emit_operand(rdi, src1);
6849   emit_data(imm32, rspec, 0);
6850 }
6851 
6852 // The 64-bit (32bit platform) cmpxchg compares the value at adr with the contents of rdx:rax,
6853 // and stores rcx:rbx into adr if so; otherwise, the value at adr is loaded
6854 // into rdx:rax.  The ZF is set if the compared values were equal, and cleared otherwise.
6855 void Assembler::cmpxchg8(Address adr) {
6856   InstructionMark im(this);
<span class="line-modified">6857   emit_int16(0x0F, (unsigned char)0xC7);</span>

6858   emit_operand(rcx, adr);
6859 }
6860 
6861 void Assembler::decl(Register dst) {
6862   // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
6863  emit_int8(0x48 | dst-&gt;encoding());
6864 }
6865 
6866 // 64bit doesn&#39;t use the x87
6867 
<span class="line-added">6868 void Assembler::emit_operand32(Register reg, Address adr) {</span>
<span class="line-added">6869   assert(reg-&gt;encoding() &lt; 8, &quot;no extended registers&quot;);</span>
<span class="line-added">6870   assert(!adr.base_needs_rex() &amp;&amp; !adr.index_needs_rex(), &quot;no extended registers&quot;);</span>
<span class="line-added">6871   emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,</span>
<span class="line-added">6872                adr._rspec);</span>
<span class="line-added">6873 }</span>
<span class="line-added">6874 </span>
<span class="line-added">6875 void Assembler::emit_farith(int b1, int b2, int i) {</span>
<span class="line-added">6876   assert(isByte(b1) &amp;&amp; isByte(b2), &quot;wrong opcode&quot;);</span>
<span class="line-added">6877   assert(0 &lt;= i &amp;&amp;  i &lt; 8, &quot;illegal stack offset&quot;);</span>
<span class="line-added">6878   emit_int16(b1, b2 + i);</span>
<span class="line-added">6879 }</span>
<span class="line-added">6880 </span>
6881 void Assembler::fabs() {
<span class="line-modified">6882   emit_int16((unsigned char)0xD9, (unsigned char)0xE1);</span>

6883 }
6884 
6885 void Assembler::fadd(int i) {
6886   emit_farith(0xD8, 0xC0, i);
6887 }
6888 
6889 void Assembler::fadd_d(Address src) {
6890   InstructionMark im(this);
6891   emit_int8((unsigned char)0xDC);
6892   emit_operand32(rax, src);
6893 }
6894 
6895 void Assembler::fadd_s(Address src) {
6896   InstructionMark im(this);
6897   emit_int8((unsigned char)0xD8);
6898   emit_operand32(rax, src);
6899 }
6900 
6901 void Assembler::fadda(int i) {
6902   emit_farith(0xDC, 0xC0, i);
6903 }
6904 
6905 void Assembler::faddp(int i) {
6906   emit_farith(0xDE, 0xC0, i);
6907 }
6908 
6909 void Assembler::fchs() {
<span class="line-modified">6910   emit_int16((unsigned char)0xD9, (unsigned char)0xE0);</span>

6911 }
6912 
6913 void Assembler::fcom(int i) {
6914   emit_farith(0xD8, 0xD0, i);
6915 }
6916 
6917 void Assembler::fcomp(int i) {
6918   emit_farith(0xD8, 0xD8, i);
6919 }
6920 
6921 void Assembler::fcomp_d(Address src) {
6922   InstructionMark im(this);
6923   emit_int8((unsigned char)0xDC);
6924   emit_operand32(rbx, src);
6925 }
6926 
6927 void Assembler::fcomp_s(Address src) {
6928   InstructionMark im(this);
6929   emit_int8((unsigned char)0xD8);
6930   emit_operand32(rbx, src);
6931 }
6932 
6933 void Assembler::fcompp() {
<span class="line-modified">6934   emit_int16((unsigned char)0xDE, (unsigned char)0xD9);</span>

6935 }
6936 
6937 void Assembler::fcos() {
<span class="line-modified">6938   emit_int16((unsigned char)0xD9, (unsigned char)0xFF);</span>

6939 }
6940 
6941 void Assembler::fdecstp() {
<span class="line-modified">6942   emit_int16((unsigned char)0xD9, (unsigned char)0xF6);</span>

6943 }
6944 
6945 void Assembler::fdiv(int i) {
6946   emit_farith(0xD8, 0xF0, i);
6947 }
6948 
6949 void Assembler::fdiv_d(Address src) {
6950   InstructionMark im(this);
6951   emit_int8((unsigned char)0xDC);
6952   emit_operand32(rsi, src);
6953 }
6954 
6955 void Assembler::fdiv_s(Address src) {
6956   InstructionMark im(this);
6957   emit_int8((unsigned char)0xD8);
6958   emit_operand32(rsi, src);
6959 }
6960 
6961 void Assembler::fdiva(int i) {
6962   emit_farith(0xDC, 0xF8, i);
</pre>
<hr />
<pre>
6993   emit_farith(0xDE, 0xF0, i);                    // ST(0) &lt;- ST(1) / ST(0) and pop (Intel manual wrong)
6994 }
6995 
6996 void Assembler::ffree(int i) {
6997   emit_farith(0xDD, 0xC0, i);
6998 }
6999 
7000 void Assembler::fild_d(Address adr) {
7001   InstructionMark im(this);
7002   emit_int8((unsigned char)0xDF);
7003   emit_operand32(rbp, adr);
7004 }
7005 
7006 void Assembler::fild_s(Address adr) {
7007   InstructionMark im(this);
7008   emit_int8((unsigned char)0xDB);
7009   emit_operand32(rax, adr);
7010 }
7011 
7012 void Assembler::fincstp() {
<span class="line-modified">7013   emit_int16((unsigned char)0xD9, (unsigned char)0xF7);</span>

7014 }
7015 
7016 void Assembler::finit() {
<span class="line-modified">7017   emit_int24((unsigned char)0x9B, (unsigned char)0xDB, (unsigned char)0xE3);</span>


7018 }
7019 
7020 void Assembler::fist_s(Address adr) {
7021   InstructionMark im(this);
7022   emit_int8((unsigned char)0xDB);
7023   emit_operand32(rdx, adr);
7024 }
7025 
7026 void Assembler::fistp_d(Address adr) {
7027   InstructionMark im(this);
7028   emit_int8((unsigned char)0xDF);
7029   emit_operand32(rdi, adr);
7030 }
7031 
7032 void Assembler::fistp_s(Address adr) {
7033   InstructionMark im(this);
7034   emit_int8((unsigned char)0xDB);
7035   emit_operand32(rbx, adr);
7036 }
7037 
7038 void Assembler::fld1() {
<span class="line-modified">7039   emit_int16((unsigned char)0xD9, (unsigned char)0xE8);</span>

7040 }
7041 
7042 void Assembler::fld_d(Address adr) {
7043   InstructionMark im(this);
7044   emit_int8((unsigned char)0xDD);
7045   emit_operand32(rax, adr);
7046 }
7047 
7048 void Assembler::fld_s(Address adr) {
7049   InstructionMark im(this);
7050   emit_int8((unsigned char)0xD9);
7051   emit_operand32(rax, adr);
7052 }
7053 
7054 
7055 void Assembler::fld_s(int index) {
7056   emit_farith(0xD9, 0xC0, index);
7057 }
7058 
7059 void Assembler::fld_x(Address adr) {
7060   InstructionMark im(this);
7061   emit_int8((unsigned char)0xDB);
7062   emit_operand32(rbp, adr);
7063 }
7064 
7065 void Assembler::fldcw(Address src) {
7066   InstructionMark im(this);
7067   emit_int8((unsigned char)0xD9);
7068   emit_operand32(rbp, src);
7069 }
7070 
7071 void Assembler::fldenv(Address src) {
7072   InstructionMark im(this);
7073   emit_int8((unsigned char)0xD9);
7074   emit_operand32(rsp, src);
7075 }
7076 
7077 void Assembler::fldlg2() {
<span class="line-modified">7078   emit_int16((unsigned char)0xD9, (unsigned char)0xEC);</span>

7079 }
7080 
7081 void Assembler::fldln2() {
<span class="line-modified">7082   emit_int16((unsigned char)0xD9, (unsigned char)0xED);</span>

7083 }
7084 
7085 void Assembler::fldz() {
<span class="line-modified">7086   emit_int16((unsigned char)0xD9, (unsigned char)0xEE);</span>

7087 }
7088 
7089 void Assembler::flog() {
7090   fldln2();
7091   fxch();
7092   fyl2x();
7093 }
7094 
7095 void Assembler::flog10() {
7096   fldlg2();
7097   fxch();
7098   fyl2x();
7099 }
7100 
7101 void Assembler::fmul(int i) {
7102   emit_farith(0xD8, 0xC8, i);
7103 }
7104 
7105 void Assembler::fmul_d(Address src) {
7106   InstructionMark im(this);
</pre>
<hr />
<pre>
7113   emit_int8((unsigned char)0xD8);
7114   emit_operand32(rcx, src);
7115 }
7116 
7117 void Assembler::fmula(int i) {
7118   emit_farith(0xDC, 0xC8, i);
7119 }
7120 
7121 void Assembler::fmulp(int i) {
7122   emit_farith(0xDE, 0xC8, i);
7123 }
7124 
7125 void Assembler::fnsave(Address dst) {
7126   InstructionMark im(this);
7127   emit_int8((unsigned char)0xDD);
7128   emit_operand32(rsi, dst);
7129 }
7130 
7131 void Assembler::fnstcw(Address src) {
7132   InstructionMark im(this);
<span class="line-modified">7133   emit_int16((unsigned char)0x9B, (unsigned char)0xD9);</span>

7134   emit_operand32(rdi, src);
7135 }
7136 
7137 void Assembler::fnstsw_ax() {
<span class="line-modified">7138   emit_int16((unsigned char)0xDF, (unsigned char)0xE0);</span>

7139 }
7140 
7141 void Assembler::fprem() {
<span class="line-modified">7142   emit_int16((unsigned char)0xD9, (unsigned char)0xF8);</span>

7143 }
7144 
7145 void Assembler::fprem1() {
<span class="line-modified">7146   emit_int16((unsigned char)0xD9, (unsigned char)0xF5);</span>

7147 }
7148 
7149 void Assembler::frstor(Address src) {
7150   InstructionMark im(this);
7151   emit_int8((unsigned char)0xDD);
7152   emit_operand32(rsp, src);
7153 }
7154 
7155 void Assembler::fsin() {
<span class="line-modified">7156   emit_int16((unsigned char)0xD9, (unsigned char)0xFE);</span>

7157 }
7158 
7159 void Assembler::fsqrt() {
<span class="line-modified">7160   emit_int16((unsigned char)0xD9, (unsigned char)0xFA);</span>

7161 }
7162 
7163 void Assembler::fst_d(Address adr) {
7164   InstructionMark im(this);
7165   emit_int8((unsigned char)0xDD);
7166   emit_operand32(rdx, adr);
7167 }
7168 
7169 void Assembler::fst_s(Address adr) {
7170   InstructionMark im(this);
7171   emit_int8((unsigned char)0xD9);
7172   emit_operand32(rdx, adr);
7173 }
7174 
7175 void Assembler::fstp_d(Address adr) {
7176   InstructionMark im(this);
7177   emit_int8((unsigned char)0xDD);
7178   emit_operand32(rbx, adr);
7179 }
7180 
</pre>
<hr />
<pre>
7226   InstructionMark im(this);
7227   emit_int8((unsigned char)0xDC);
7228   emit_operand32(rbp, src);
7229 }
7230 
7231 void Assembler::fsubr_s(Address src) {
7232   InstructionMark im(this);
7233   emit_int8((unsigned char)0xD8);
7234   emit_operand32(rbp, src);
7235 }
7236 
7237 void Assembler::fsubra(int i) {
7238   emit_farith(0xDC, 0xE0, i);
7239 }
7240 
7241 void Assembler::fsubrp(int i) {
7242   emit_farith(0xDE, 0xE0, i);                    // ST(0) &lt;- ST(1) - ST(0) and pop (Intel manual wrong)
7243 }
7244 
7245 void Assembler::ftan() {
<span class="line-modified">7246   emit_int32((unsigned char)0xD9, (unsigned char)0xF2, (unsigned char)0xDD, (unsigned char)0xD8);</span>



7247 }
7248 
7249 void Assembler::ftst() {
<span class="line-modified">7250   emit_int16((unsigned char)0xD9, (unsigned char)0xE4);</span>

7251 }
7252 
7253 void Assembler::fucomi(int i) {
7254   // make sure the instruction is supported (introduced for P6, together with cmov)
7255   guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;);
7256   emit_farith(0xDB, 0xE8, i);
7257 }
7258 
7259 void Assembler::fucomip(int i) {
7260   // make sure the instruction is supported (introduced for P6, together with cmov)
7261   guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;);
7262   emit_farith(0xDF, 0xE8, i);
7263 }
7264 
7265 void Assembler::fwait() {
7266   emit_int8((unsigned char)0x9B);
7267 }
7268 
7269 void Assembler::fxch(int i) {
7270   emit_farith(0xD9, 0xC8, i);
7271 }
7272 
7273 void Assembler::fyl2x() {
<span class="line-modified">7274   emit_int16((unsigned char)0xD9, (unsigned char)0xF1);</span>

7275 }
7276 
7277 void Assembler::frndint() {
<span class="line-modified">7278   emit_int16((unsigned char)0xD9, (unsigned char)0xFC);</span>

7279 }
7280 
7281 void Assembler::f2xm1() {
<span class="line-modified">7282   emit_int16((unsigned char)0xD9, (unsigned char)0xF0);</span>

7283 }
7284 
7285 void Assembler::fldl2e() {
<span class="line-modified">7286   emit_int16((unsigned char)0xD9, (unsigned char)0xEA);</span>

7287 }
7288 #endif // !_LP64
7289 
7290 // SSE SIMD prefix byte values corresponding to VexSimdPrefix encoding.
7291 static int simd_pre[4] = { 0, 0x66, 0xF3, 0xF2 };
7292 // SSE opcode second byte values (first is 0x0F) corresponding to VexOpcode encoding.
7293 static int simd_opc[4] = { 0,    0, 0x38, 0x3A };
7294 
7295 // Generate SSE legacy REX prefix and SIMD opcode based on VEX encoding.
7296 void Assembler::rex_prefix(Address adr, XMMRegister xreg, VexSimdPrefix pre, VexOpcode opc, bool rex_w) {
7297   if (pre &gt; 0) {
7298     emit_int8(simd_pre[pre]);
7299   }
7300   if (rex_w) {
7301     prefixq(adr, xreg);
7302   } else {
7303     prefix(adr, xreg);
7304   }
7305   if (opc &gt; 0) {
7306     emit_int8(0x0F);
</pre>
<hr />
<pre>
7314 int Assembler::rex_prefix_and_encode(int dst_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, bool rex_w) {
7315   if (pre &gt; 0) {
7316     emit_int8(simd_pre[pre]);
7317   }
7318   int encode = (rex_w) ? prefixq_and_encode(dst_enc, src_enc) : prefix_and_encode(dst_enc, src_enc);
7319   if (opc &gt; 0) {
7320     emit_int8(0x0F);
7321     int opc2 = simd_opc[opc];
7322     if (opc2 &gt; 0) {
7323       emit_int8(opc2);
7324     }
7325   }
7326   return encode;
7327 }
7328 
7329 
7330 void Assembler::vex_prefix(bool vex_r, bool vex_b, bool vex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc) {
7331   int vector_len = _attributes-&gt;get_vector_len();
7332   bool vex_w = _attributes-&gt;is_rex_vex_w();
7333   if (vex_b || vex_x || vex_w || (opc == VEX_OPCODE_0F_38) || (opc == VEX_OPCODE_0F_3A)) {


7334     int byte1 = (vex_r ? VEX_R : 0) | (vex_x ? VEX_X : 0) | (vex_b ? VEX_B : 0);
7335     byte1 = (~byte1) &amp; 0xE0;
7336     byte1 |= opc;

7337 
7338     int byte2 = ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
7339     byte2 |= (vex_w ? VEX_W : 0) | ((vector_len &gt; 0) ? 4 : 0) | pre;



7340 
<span class="line-added">7341     emit_int24((unsigned char)VEX_3bytes, byte1, byte2);</span>
<span class="line-added">7342   } else {</span>
7343     int byte1 = vex_r ? VEX_R : 0;
7344     byte1 = (~byte1) &amp; 0x80;
7345     byte1 |= ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
7346     byte1 |= ((vector_len &gt; 0 ) ? 4 : 0) | pre;
<span class="line-modified">7347     emit_int16((unsigned char)VEX_2bytes, byte1);</span>
7348   }
7349 }
7350 
7351 // This is a 4 byte encoding
7352 void Assembler::evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_v, int nds_enc, VexSimdPrefix pre, VexOpcode opc){
7353   // EVEX 0x62 prefix
<span class="line-modified">7354   // byte1 = EVEX_4bytes;</span>
<span class="line-added">7355 </span>
7356   bool vex_w = _attributes-&gt;is_rex_vex_w();
7357   int evex_encoding = (vex_w ? VEX_W : 0);
7358   // EVEX.b is not currently used for broadcast of single element or data rounding modes
7359   _attributes-&gt;set_evex_encoding(evex_encoding);
7360 
7361   // P0: byte 2, initialized to RXBR`00mm
7362   // instead of not&#39;d
7363   int byte2 = (vex_r ? VEX_R : 0) | (vex_x ? VEX_X : 0) | (vex_b ? VEX_B : 0) | (evex_r ? EVEX_Rb : 0);
7364   byte2 = (~byte2) &amp; 0xF0;
7365   // confine opc opcode extensions in mm bits to lower two bits
7366   // of form {0F, 0F_38, 0F_3A}
7367   byte2 |= opc;

7368 
7369   // P1: byte 3 as Wvvvv1pp
7370   int byte3 = ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
7371   // p[10] is always 1
7372   byte3 |= EVEX_F;
7373   byte3 |= (vex_w &amp; 1) &lt;&lt; 7;
7374   // confine pre opcode extensions in pp bits to lower two bits
7375   // of form {66, F3, F2}
7376   byte3 |= pre;

7377 
7378   // P2: byte 4 as zL&#39;Lbv&#39;aaa
7379   // kregs are implemented in the low 3 bits as aaa
7380   int byte4 = (_attributes-&gt;is_no_reg_mask()) ?
7381               0 :
7382               _attributes-&gt;get_embedded_opmask_register_specifier();
7383   // EVEX.v` for extending EVEX.vvvv or VIDX
7384   byte4 |= (evex_v ? 0: EVEX_V);
7385   // third EXEC.b for broadcast actions
7386   byte4 |= (_attributes-&gt;is_extended_context() ? EVEX_Rb : 0);
7387   // fourth EVEX.L&#39;L for vector length : 0 is 128, 1 is 256, 2 is 512, currently we do not support 1024
7388   byte4 |= ((_attributes-&gt;get_vector_len())&amp; 0x3) &lt;&lt; 5;
7389   // last is EVEX.z for zero/merge actions
7390   if (_attributes-&gt;is_no_reg_mask() == false) {
7391     byte4 |= (_attributes-&gt;is_clear_context() ? EVEX_Z : 0);
7392   }
<span class="line-modified">7393 </span>
<span class="line-added">7394   emit_int32(EVEX_4bytes, byte2, byte3, byte4);</span>
7395 }
7396 
7397 void Assembler::vex_prefix(Address adr, int nds_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes) {
<span class="line-modified">7398   bool vex_r = (xreg_enc &amp; 8) == 8;</span>
7399   bool vex_b = adr.base_needs_rex();
7400   bool vex_x;
7401   if (adr.isxmmindex()) {
7402     vex_x = adr.xmmindex_needs_rex();
7403   } else {
7404     vex_x = adr.index_needs_rex();
7405   }
7406   set_attributes(attributes);
7407   attributes-&gt;set_current_assembler(this);
7408 
7409   // For EVEX instruction (which is not marked as pure EVEX instruction) check and see if this instruction
7410   // is allowed in legacy mode and has resources which will fit in it.
7411   // Pure EVEX instructions will have is_evex_instruction set in their definition.
7412   if (!attributes-&gt;is_legacy_mode()) {
<span class="line-modified">7413     if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_evex_instruction() &amp;&amp; !is_managed()) {</span>
7414       if ((attributes-&gt;get_vector_len() != AVX_512bit) &amp;&amp; (nds_enc &lt; 16) &amp;&amp; (xreg_enc &lt; 16)) {
7415           attributes-&gt;set_is_legacy_mode();
7416       }
7417     }
7418   }
7419 
7420   if (UseAVX &gt; 2) {
7421     assert(((!attributes-&gt;uses_vl()) ||
7422             (attributes-&gt;get_vector_len() == AVX_512bit) ||
7423             (!_legacy_mode_vl) ||
7424             (attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
7425     assert(((nds_enc &lt; 16 &amp;&amp; xreg_enc &lt; 16) || (!attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
7426   }
7427 
<span class="line-modified">7428   clear_managed();</span>
7429   if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_legacy_mode())
7430   {
7431     bool evex_r = (xreg_enc &gt;= 16);
7432     bool evex_v;
7433     // EVEX.V&#39; is set to true when VSIB is used as we may need to use higher order XMM registers (16-31)
7434     if (adr.isxmmindex())  {
7435       evex_v = ((adr._xmmindex-&gt;encoding() &gt; 15) ? true : false);
7436     } else {
7437       evex_v = (nds_enc &gt;= 16);
7438     }
7439     attributes-&gt;set_is_evex_instruction();
7440     evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_v, nds_enc, pre, opc);
7441   } else {
7442     if (UseAVX &gt; 2 &amp;&amp; attributes-&gt;is_rex_vex_w_reverted()) {
7443       attributes-&gt;set_rex_vex_w(false);
7444     }
7445     vex_prefix(vex_r, vex_b, vex_x, nds_enc, pre, opc);
7446   }
7447 }
7448 
7449 int Assembler::vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes) {
<span class="line-modified">7450   bool vex_r = (dst_enc &amp; 8) == 8;</span>
<span class="line-modified">7451   bool vex_b = (src_enc &amp; 8) == 8;</span>
7452   bool vex_x = false;
7453   set_attributes(attributes);
7454   attributes-&gt;set_current_assembler(this);
7455 
7456   // For EVEX instruction (which is not marked as pure EVEX instruction) check and see if this instruction
7457   // is allowed in legacy mode and has resources which will fit in it.
7458   // Pure EVEX instructions will have is_evex_instruction set in their definition.
7459   if (!attributes-&gt;is_legacy_mode()) {
<span class="line-modified">7460     if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_evex_instruction() &amp;&amp; !is_managed()) {</span>
7461       if ((!attributes-&gt;uses_vl() || (attributes-&gt;get_vector_len() != AVX_512bit)) &amp;&amp;
7462           (dst_enc &lt; 16) &amp;&amp; (nds_enc &lt; 16) &amp;&amp; (src_enc &lt; 16)) {
7463           attributes-&gt;set_is_legacy_mode();
7464       }
7465     }
7466   }
7467 
7468   if (UseAVX &gt; 2) {
7469     // All the scalar fp instructions (with uses_vl as false) can have legacy_mode as false
7470     // Instruction with uses_vl true are vector instructions
7471     // All the vector instructions with AVX_512bit length can have legacy_mode as false
7472     // All the vector instructions with &lt; AVX_512bit length can have legacy_mode as false if AVX512vl() is supported
7473     // Rest all should have legacy_mode set as true
7474     assert(((!attributes-&gt;uses_vl()) ||
7475             (attributes-&gt;get_vector_len() == AVX_512bit) ||
7476             (!_legacy_mode_vl) ||
7477             (attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
7478     // Instruction with legacy_mode true should have dst, nds and src &lt; 15
7479     assert(((dst_enc &lt; 16 &amp;&amp; nds_enc &lt; 16 &amp;&amp; src_enc &lt; 16) || (!attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
7480   }
7481 
<span class="line-modified">7482   clear_managed();</span>
7483   if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_legacy_mode())
7484   {
7485     bool evex_r = (dst_enc &gt;= 16);
7486     bool evex_v = (nds_enc &gt;= 16);
7487     // can use vex_x as bank extender on rm encoding
7488     vex_x = (src_enc &gt;= 16);
7489     attributes-&gt;set_is_evex_instruction();
7490     evex_prefix(vex_r, vex_b, vex_x, evex_r, evex_v, nds_enc, pre, opc);
7491   } else {
7492     if (UseAVX &gt; 2 &amp;&amp; attributes-&gt;is_rex_vex_w_reverted()) {
7493       attributes-&gt;set_rex_vex_w(false);
7494     }
7495     vex_prefix(vex_r, vex_b, vex_x, nds_enc, pre, opc);
7496   }
7497 
7498   // return modrm byte components for operands
7499   return (((dst_enc &amp; 7) &lt;&lt; 3) | (src_enc &amp; 7));
7500 }
7501 
7502 
</pre>
<hr />
<pre>
7512   }
7513 }
7514 
7515 int Assembler::simd_prefix_and_encode(XMMRegister dst, XMMRegister nds, XMMRegister src, VexSimdPrefix pre,
7516                                       VexOpcode opc, InstructionAttr *attributes) {
7517   int dst_enc = dst-&gt;encoding();
7518   int src_enc = src-&gt;encoding();
7519   if (UseAVX &gt; 0) {
7520     int nds_enc = nds-&gt;is_valid() ? nds-&gt;encoding() : 0;
7521     return vex_prefix_and_encode(dst_enc, nds_enc, src_enc, pre, opc, attributes);
7522   } else {
7523     assert((nds == dst) || (nds == src) || (nds == xnoreg), &quot;wrong sse encoding&quot;);
7524     return rex_prefix_and_encode(dst_enc, src_enc, pre, opc, attributes-&gt;is_rex_vex_w());
7525   }
7526 }
7527 
7528 void Assembler::vmaxss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
7529   assert(VM_Version::supports_avx(), &quot;&quot;);
7530   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
7531   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">7532   emit_int16(0x5F, (0xC0 | encode));</span>

7533 }
7534 
7535 void Assembler::vmaxsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
7536   assert(VM_Version::supports_avx(), &quot;&quot;);
7537   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
7538   attributes.set_rex_vex_w_reverted();
7539   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">7540   emit_int16(0x5F, (0xC0 | encode));</span>

7541 }
7542 
7543 void Assembler::vminss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
7544   assert(VM_Version::supports_avx(), &quot;&quot;);
7545   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
7546   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">7547   emit_int16(0x5D, (0xC0 | encode));</span>

7548 }
7549 
7550 void Assembler::vminsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
7551   assert(VM_Version::supports_avx(), &quot;&quot;);
7552   InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
7553   attributes.set_rex_vex_w_reverted();
7554   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">7555   emit_int16(0x5D, (0xC0 | encode));</span>

7556 }
7557 
7558 void Assembler::cmppd(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len) {
7559   assert(VM_Version::supports_avx(), &quot;&quot;);
7560   assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
7561   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
7562   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">7563   emit_int24((unsigned char)0xC2, (0xC0 | encode), (0xF &amp; cop));</span>


7564 }
7565 
7566 void Assembler::blendvpd(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len) {
7567   assert(VM_Version::supports_avx(), &quot;&quot;);
7568   assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
7569   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
7570   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);


7571   int src2_enc = src2-&gt;encoding();
<span class="line-modified">7572   emit_int24(0x4B, (0xC0 | encode), (0xF0 &amp; src2_enc &lt;&lt; 4));</span>
7573 }
7574 
7575 void Assembler::cmpps(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len) {
7576   assert(VM_Version::supports_avx(), &quot;&quot;);
7577   assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
7578   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
7579   int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">7580   emit_int24((unsigned char)0xC2, (0xC0 | encode), (0xF &amp; cop));</span>


7581 }
7582 
7583 void Assembler::blendvps(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len) {
7584   assert(VM_Version::supports_avx(), &quot;&quot;);
7585   assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
7586   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
7587   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);


7588   int src2_enc = src2-&gt;encoding();
<span class="line-modified">7589   emit_int24(0x4A, (0xC0 | encode), (0xF0 &amp; src2_enc &lt;&lt; 4));</span>
7590 }
7591 
7592 void Assembler::vpblendd(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {
7593   assert(VM_Version::supports_avx2(), &quot;&quot;);
7594   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
7595   int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">7596   emit_int24(0x02, (0xC0 | encode), (unsigned char)imm8);</span>


7597 }
7598 
7599 void Assembler::shlxl(Register dst, Register src1, Register src2) {
7600   assert(VM_Version::supports_bmi2(), &quot;&quot;);
7601   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
7602   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src2-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">7603   emit_int16((unsigned char)0xF7, (0xC0 | encode));</span>

7604 }
7605 
7606 void Assembler::shlxq(Register dst, Register src1, Register src2) {
7607   assert(VM_Version::supports_bmi2(), &quot;&quot;);
7608   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
7609   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src2-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">7610   emit_int16((unsigned char)0xF7, (0xC0 | encode));</span>

7611 }
7612 
7613 #ifndef _LP64
7614 
7615 void Assembler::incl(Register dst) {
7616   // Don&#39;t use it directly. Use MacroAssembler::incrementl() instead.
7617   emit_int8(0x40 | dst-&gt;encoding());
7618 }
7619 
7620 void Assembler::lea(Register dst, Address src) {
7621   leal(dst, src);
7622 }
7623 
7624 void Assembler::mov_literal32(Address dst, int32_t imm32, RelocationHolder const&amp; rspec) {
7625   InstructionMark im(this);
7626   emit_int8((unsigned char)0xC7);
7627   emit_operand(rax, dst);
7628   emit_data((int)imm32, rspec, 0);
7629 }
7630 
7631 void Assembler::mov_literal32(Register dst, int32_t imm32, RelocationHolder const&amp; rspec) {
7632   InstructionMark im(this);
7633   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">7634   emit_int8((0xB8 | encode));</span>
7635   emit_data((int)imm32, rspec, 0);
7636 }
7637 
7638 void Assembler::popa() { // 32bit
7639   emit_int8(0x61);
7640 }
7641 
7642 void Assembler::push_literal32(int32_t imm32, RelocationHolder const&amp; rspec) {
7643   InstructionMark im(this);
7644   emit_int8(0x68);
7645   emit_data(imm32, rspec, 0);
7646 }
7647 
7648 void Assembler::pusha() { // 32bit
7649   emit_int8(0x60);
7650 }
7651 
7652 void Assembler::set_byte_if_not_zero(Register dst) {
<span class="line-modified">7653   emit_int24(0x0F, (unsigned char)0x95, (0xE0 | dst-&gt;encoding()));</span>


7654 }
7655 
7656 #else // LP64
7657 
7658 void Assembler::set_byte_if_not_zero(Register dst) {
7659   int enc = prefix_and_encode(dst-&gt;encoding(), true);
<span class="line-modified">7660   emit_int24(0x0F, (unsigned char)0x95, (0xE0 | enc));</span>


7661 }
7662 
7663 // 64bit only pieces of the assembler
7664 // This should only be used by 64bit instructions that can use rip-relative
7665 // it cannot be used by instructions that want an immediate value.
7666 
7667 bool Assembler::reachable(AddressLiteral adr) {
7668   int64_t disp;
<span class="line-added">7669   relocInfo::relocType relocType = adr.reloc();</span>
<span class="line-added">7670 </span>
7671   // None will force a 64bit literal to the code stream. Likely a placeholder
7672   // for something that will be patched later and we need to certain it will
7673   // always be reachable.
<span class="line-modified">7674   if (relocType == relocInfo::none) {</span>
7675     return false;
7676   }
<span class="line-modified">7677   if (relocType == relocInfo::internal_word_type) {</span>
7678     // This should be rip relative and easily reachable.
7679     return true;
7680   }
<span class="line-modified">7681   if (relocType == relocInfo::virtual_call_type ||</span>
<span class="line-modified">7682       relocType == relocInfo::opt_virtual_call_type ||</span>
<span class="line-modified">7683       relocType == relocInfo::static_call_type ||</span>
<span class="line-modified">7684       relocType == relocInfo::static_stub_type ) {</span>
7685     // This should be rip relative within the code cache and easily
7686     // reachable until we get huge code caches. (At which point
7687     // ic code is going to have issues).
7688     return true;
7689   }
<span class="line-modified">7690   if (relocType != relocInfo::external_word_type &amp;&amp;</span>
<span class="line-modified">7691       relocType != relocInfo::poll_return_type &amp;&amp;  // these are really external_word but need special</span>
<span class="line-modified">7692       relocType != relocInfo::poll_type &amp;&amp;         // relocs to identify them</span>
<span class="line-modified">7693       relocType != relocInfo::runtime_call_type ) {</span>
7694     return false;
7695   }
7696 
7697   // Stress the correction code
7698   if (ForceUnreachable) {
7699     // Must be runtimecall reloc, see if it is in the codecache
7700     // Flipping stuff in the codecache to be unreachable causes issues
7701     // with things like inline caches where the additional instructions
7702     // are not handled.
7703     if (CodeCache::find_blob(adr._target) == NULL) {
7704       return false;
7705     }
7706   }
7707   // For external_word_type/runtime_call_type if it is reachable from where we
7708   // are now (possibly a temp buffer) and where we might end up
7709   // anywhere in the codeCache then we are always reachable.
7710   // This would have to change if we ever save/restore shared code
7711   // to be more pessimistic.
7712   disp = (int64_t)adr._target - ((int64_t)CodeCache::low_bound() + sizeof(int));
7713   if (!is_simm32(disp)) return false;
</pre>
<hr />
<pre>
7749   } else {
7750     emit_data64(data, Relocation::spec_simple(rtype), format);
7751   }
7752 }
7753 
7754 void Assembler::emit_data64(jlong data,
7755                             RelocationHolder const&amp; rspec,
7756                             int format) {
7757   assert(imm_operand == 0, &quot;default format must be immediate in this file&quot;);
7758   assert(imm_operand == format, &quot;must be immediate&quot;);
7759   assert(inst_mark() != NULL, &quot;must be inside InstructionMark&quot;);
7760   // Do not use AbstractAssembler::relocate, which is not intended for
7761   // embedded words.  Instead, relocate to the enclosing instruction.
7762   code_section()-&gt;relocate(inst_mark(), rspec, format);
7763 #ifdef ASSERT
7764   check_relocation(rspec, format);
7765 #endif
7766   emit_int64(data);
7767 }
7768 
<span class="line-modified">7769 void Assembler::prefix(Register reg) {</span>
<span class="line-modified">7770   if (reg-&gt;encoding() &gt;= 8) {</span>
7771     prefix(REX_B);



7772   }

7773 }
7774 
<span class="line-modified">7775 void Assembler::prefix(Register dst, Register src, Prefix p) {</span>
<span class="line-modified">7776   if (src-&gt;encoding() &gt;= 8) {</span>
<span class="line-modified">7777     p = (Prefix)(p | REX_B);</span>
<span class="line-modified">7778   }</span>
<span class="line-modified">7779   if (dst-&gt;encoding() &gt;= 8) {</span>
<span class="line-modified">7780     p = (Prefix)(p | REX_R);</span>
<span class="line-added">7781   }</span>
<span class="line-added">7782   if (p != Prefix_EMPTY) {</span>
<span class="line-added">7783     // do not generate an empty prefix</span>
<span class="line-added">7784     prefix(p);</span>
7785   }

7786 }
7787 
<span class="line-modified">7788 void Assembler::prefix(Register dst, Address adr, Prefix p) {</span>
<span class="line-modified">7789   if (adr.base_needs_rex()) {</span>
<span class="line-modified">7790     if (adr.index_needs_rex()) {</span>
<span class="line-added">7791       assert(false, &quot;prefix(Register dst, Address adr, Prefix p) does not support handling of an X&quot;);</span>
<span class="line-added">7792     } else {</span>
7793       prefix(REX_B);



7794     }
7795   } else {
<span class="line-modified">7796     if (adr.index_needs_rex()) {</span>
<span class="line-modified">7797       assert(false, &quot;prefix(Register dst, Address adr, Prefix p) does not support handling of an X&quot;);</span>



7798     }
<span class="line-modified">7799   }</span>
<span class="line-modified">7800   if (dst-&gt;encoding() &gt;= 8) {</span>
<span class="line-modified">7801     p = (Prefix)(p | REX_R);</span>
<span class="line-modified">7802   }</span>
<span class="line-modified">7803   if (p != Prefix_EMPTY) {</span>
<span class="line-modified">7804     // do not generate an empty prefix</span>
<span class="line-modified">7805     prefix(p);</span>























































7806   }
7807 }
7808 
7809 void Assembler::prefix(Address adr) {
7810   if (adr.base_needs_rex()) {
7811     if (adr.index_needs_rex()) {
7812       prefix(REX_XB);
7813     } else {
7814       prefix(REX_B);
7815     }
7816   } else {
7817     if (adr.index_needs_rex()) {
7818       prefix(REX_X);
7819     }
7820   }
7821 }
7822 

















7823 void Assembler::prefix(Address adr, Register reg, bool byteinst) {
7824   if (reg-&gt;encoding() &lt; 8) {
7825     if (adr.base_needs_rex()) {
7826       if (adr.index_needs_rex()) {
7827         prefix(REX_XB);
7828       } else {
7829         prefix(REX_B);
7830       }
7831     } else {
7832       if (adr.index_needs_rex()) {
7833         prefix(REX_X);
<span class="line-modified">7834       } else if (byteinst &amp;&amp; reg-&gt;encoding() &gt;= 4) {</span>
7835         prefix(REX);
7836       }
7837     }
7838   } else {
7839     if (adr.base_needs_rex()) {
7840       if (adr.index_needs_rex()) {
7841         prefix(REX_RXB);
7842       } else {
7843         prefix(REX_RB);
7844       }
7845     } else {
7846       if (adr.index_needs_rex()) {
7847         prefix(REX_RX);
7848       } else {
7849         prefix(REX_R);
7850       }
7851     }
7852   }
7853 }
7854 
<span class="line-modified">7855 void Assembler::prefix(Address adr, XMMRegister reg) {</span>
<span class="line-modified">7856   if (reg-&gt;encoding() &lt; 8) {</span>
7857     if (adr.base_needs_rex()) {
7858       if (adr.index_needs_rex()) {
<span class="line-modified">7859         prefix(REX_XB);</span>
7860       } else {
<span class="line-modified">7861         prefix(REX_B);</span>
7862       }
7863     } else {
7864       if (adr.index_needs_rex()) {
<span class="line-modified">7865         prefix(REX_X);</span>


7866       }
7867     }
7868   } else {
7869     if (adr.base_needs_rex()) {
7870       if (adr.index_needs_rex()) {
<span class="line-modified">7871         prefix(REX_RXB);</span>
7872       } else {
<span class="line-modified">7873         prefix(REX_RB);</span>
7874       }
7875     } else {
7876       if (adr.index_needs_rex()) {
<span class="line-modified">7877         prefix(REX_RX);</span>
7878       } else {
<span class="line-modified">7879         prefix(REX_R);</span>
7880       }
7881     }
7882   }
7883 }
7884 
<span class="line-modified">7885 int Assembler::prefix_and_encode(int reg_enc, bool byteinst) {</span>
<span class="line-modified">7886   if (reg_enc &gt;= 8) {</span>
<span class="line-added">7887     prefix(REX_B);</span>
<span class="line-added">7888     reg_enc -= 8;</span>
<span class="line-added">7889   } else if (byteinst &amp;&amp; reg_enc &gt;= 4) {</span>
<span class="line-added">7890     prefix(REX);</span>
<span class="line-added">7891   }</span>
<span class="line-added">7892   return reg_enc;</span>
<span class="line-added">7893 }</span>
<span class="line-added">7894 </span>
<span class="line-added">7895 int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte) {</span>
<span class="line-added">7896   if (dst_enc &lt; 8) {</span>
<span class="line-added">7897     if (src_enc &gt;= 8) {</span>
<span class="line-added">7898       prefix(REX_B);</span>
<span class="line-added">7899       src_enc -= 8;</span>
<span class="line-added">7900     } else if ((src_is_byte &amp;&amp; src_enc &gt;= 4) || (dst_is_byte &amp;&amp; dst_enc &gt;= 4)) {</span>
<span class="line-added">7901       prefix(REX);</span>
<span class="line-added">7902     }</span>
<span class="line-added">7903   } else {</span>
<span class="line-added">7904     if (src_enc &lt; 8) {</span>
<span class="line-added">7905       prefix(REX_R);</span>
<span class="line-added">7906     } else {</span>
<span class="line-added">7907       prefix(REX_RB);</span>
<span class="line-added">7908       src_enc -= 8;</span>
<span class="line-added">7909     }</span>
<span class="line-added">7910     dst_enc -= 8;</span>
<span class="line-added">7911   }</span>
<span class="line-added">7912   return dst_enc &lt;&lt; 3 | src_enc;</span>
<span class="line-added">7913 }</span>
<span class="line-added">7914 </span>
<span class="line-added">7915 int8_t Assembler::get_prefixq(Address adr) {</span>
<span class="line-added">7916   int8_t prfx = get_prefixq(adr, rax);</span>
<span class="line-added">7917   assert(REX_W &lt;= prfx &amp;&amp; prfx &lt;= REX_WXB, &quot;must be&quot;);</span>
<span class="line-added">7918   return prfx;</span>
<span class="line-added">7919 }</span>
<span class="line-added">7920 </span>
<span class="line-added">7921 int8_t Assembler::get_prefixq(Address adr, Register src) {</span>
<span class="line-added">7922   int8_t prfx = (int8_t)(REX_W +</span>
<span class="line-added">7923                          ((int)adr.base_needs_rex()) +</span>
<span class="line-added">7924                          ((int)adr.index_needs_rex() &lt;&lt; 1) +</span>
<span class="line-added">7925                          ((int)(src-&gt;encoding() &gt;= 8) &lt;&lt; 2));</span>
<span class="line-added">7926 #ifdef ASSERT</span>
<span class="line-added">7927   if (src-&gt;encoding() &lt; 8) {</span>
7928     if (adr.base_needs_rex()) {
7929       if (adr.index_needs_rex()) {
<span class="line-modified">7930         assert(prfx == REX_WXB, &quot;must be&quot;);</span>
7931       } else {
<span class="line-modified">7932         assert(prfx == REX_WB, &quot;must be&quot;);</span>
7933       }
7934     } else {
7935       if (adr.index_needs_rex()) {
<span class="line-modified">7936         assert(prfx == REX_WX, &quot;must be&quot;);</span>
<span class="line-added">7937       } else {</span>
<span class="line-added">7938         assert(prfx == REX_W, &quot;must be&quot;);</span>
7939       }
7940     }
7941   } else {
7942     if (adr.base_needs_rex()) {
7943       if (adr.index_needs_rex()) {
<span class="line-modified">7944         assert(prfx == REX_WRXB, &quot;must be&quot;);</span>
7945       } else {
<span class="line-modified">7946         assert(prfx == REX_WRB, &quot;must be&quot;);</span>
7947       }
7948     } else {
7949       if (adr.index_needs_rex()) {
<span class="line-modified">7950         assert(prfx == REX_WRX, &quot;must be&quot;);</span>
7951       } else {
<span class="line-modified">7952         assert(prfx == REX_WR, &quot;must be&quot;);</span>
7953       }
7954     }
7955   }
<span class="line-added">7956 #endif</span>
<span class="line-added">7957   return prfx;</span>
<span class="line-added">7958 }</span>
<span class="line-added">7959 </span>
<span class="line-added">7960 void Assembler::prefixq(Address adr) {</span>
<span class="line-added">7961   emit_int8(get_prefixq(adr));</span>
<span class="line-added">7962 }</span>
<span class="line-added">7963 </span>
<span class="line-added">7964 void Assembler::prefixq(Address adr, Register src) {</span>
<span class="line-added">7965   emit_int8(get_prefixq(adr, src));</span>
7966 }
7967 
7968 void Assembler::prefixq(Address adr, XMMRegister src) {
7969   if (src-&gt;encoding() &lt; 8) {
7970     if (adr.base_needs_rex()) {
7971       if (adr.index_needs_rex()) {
7972         prefix(REX_WXB);
7973       } else {
7974         prefix(REX_WB);
7975       }
7976     } else {
7977       if (adr.index_needs_rex()) {
7978         prefix(REX_WX);
7979       } else {
7980         prefix(REX_W);
7981       }
7982     }
7983   } else {
7984     if (adr.base_needs_rex()) {
7985       if (adr.index_needs_rex()) {
7986         prefix(REX_WRXB);
7987       } else {
7988         prefix(REX_WRB);
7989       }
7990     } else {
7991       if (adr.index_needs_rex()) {
7992         prefix(REX_WRX);
7993       } else {
7994         prefix(REX_WR);
7995       }
7996     }
7997   }
7998 }
7999 
<span class="line-added">8000 int Assembler::prefixq_and_encode(int reg_enc) {</span>
<span class="line-added">8001   if (reg_enc &lt; 8) {</span>
<span class="line-added">8002     prefix(REX_W);</span>
<span class="line-added">8003   } else {</span>
<span class="line-added">8004     prefix(REX_WB);</span>
<span class="line-added">8005     reg_enc -= 8;</span>
<span class="line-added">8006   }</span>
<span class="line-added">8007   return reg_enc;</span>
<span class="line-added">8008 }</span>
<span class="line-added">8009 </span>
<span class="line-added">8010 int Assembler::prefixq_and_encode(int dst_enc, int src_enc) {</span>
<span class="line-added">8011   if (dst_enc &lt; 8) {</span>
<span class="line-added">8012     if (src_enc &lt; 8) {</span>
<span class="line-added">8013       prefix(REX_W);</span>
<span class="line-added">8014     } else {</span>
<span class="line-added">8015       prefix(REX_WB);</span>
<span class="line-added">8016       src_enc -= 8;</span>
<span class="line-added">8017     }</span>
<span class="line-added">8018   } else {</span>
<span class="line-added">8019     if (src_enc &lt; 8) {</span>
<span class="line-added">8020       prefix(REX_WR);</span>
<span class="line-added">8021     } else {</span>
<span class="line-added">8022       prefix(REX_WRB);</span>
<span class="line-added">8023       src_enc -= 8;</span>
<span class="line-added">8024     }</span>
<span class="line-added">8025     dst_enc -= 8;</span>
<span class="line-added">8026   }</span>
<span class="line-added">8027   return dst_enc &lt;&lt; 3 | src_enc;</span>
<span class="line-added">8028 }</span>
<span class="line-added">8029 </span>
8030 void Assembler::adcq(Register dst, int32_t imm32) {
8031   (void) prefixq_and_encode(dst-&gt;encoding());
8032   emit_arith(0x81, 0xD0, dst, imm32);
8033 }
8034 
8035 void Assembler::adcq(Register dst, Address src) {
8036   InstructionMark im(this);
<span class="line-modified">8037   emit_int16(get_prefixq(src, dst), 0x13);</span>

8038   emit_operand(dst, src);
8039 }
8040 
8041 void Assembler::adcq(Register dst, Register src) {
8042   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8043   emit_arith(0x13, 0xC0, dst, src);
8044 }
8045 
8046 void Assembler::addq(Address dst, int32_t imm32) {
8047   InstructionMark im(this);
8048   prefixq(dst);
<span class="line-modified">8049   emit_arith_operand(0x81, rax, dst, imm32);</span>
8050 }
8051 
8052 void Assembler::addq(Address dst, Register src) {
8053   InstructionMark im(this);
<span class="line-modified">8054   emit_int16(get_prefixq(dst, src), 0x01);</span>

8055   emit_operand(src, dst);
8056 }
8057 
8058 void Assembler::addq(Register dst, int32_t imm32) {
8059   (void) prefixq_and_encode(dst-&gt;encoding());
8060   emit_arith(0x81, 0xC0, dst, imm32);
8061 }
8062 
8063 void Assembler::addq(Register dst, Address src) {
8064   InstructionMark im(this);
<span class="line-modified">8065   emit_int16(get_prefixq(src, dst), 0x03);</span>

8066   emit_operand(dst, src);
8067 }
8068 
8069 void Assembler::addq(Register dst, Register src) {
8070   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8071   emit_arith(0x03, 0xC0, dst, src);
8072 }
8073 
8074 void Assembler::adcxq(Register dst, Register src) {
8075   //assert(VM_Version::supports_adx(), &quot;adx instructions not supported&quot;);
<span class="line-modified">8076   emit_int8(0x66);</span>
8077   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">8078   emit_int32(0x0F,</span>
<span class="line-modified">8079              0x38,</span>
<span class="line-modified">8080              (unsigned char)0xF6,</span>
<span class="line-modified">8081              (0xC0 | encode));</span>
8082 }
8083 
8084 void Assembler::adoxq(Register dst, Register src) {
8085   //assert(VM_Version::supports_adx(), &quot;adx instructions not supported&quot;);
8086   emit_int8((unsigned char)0xF3);
8087   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">8088   emit_int32(0x0F,</span>
<span class="line-modified">8089              0x38,</span>
<span class="line-modified">8090              (unsigned char)0xF6,</span>
<span class="line-modified">8091              (0xC0 | encode));</span>
8092 }
8093 
8094 void Assembler::andq(Address dst, int32_t imm32) {
8095   InstructionMark im(this);
<span class="line-modified">8096   emit_int16(get_prefixq(dst), (unsigned char)0x81);</span>

8097   emit_operand(rsp, dst, 4);
8098   emit_int32(imm32);
8099 }
8100 
8101 void Assembler::andq(Register dst, int32_t imm32) {
8102   (void) prefixq_and_encode(dst-&gt;encoding());
8103   emit_arith(0x81, 0xE0, dst, imm32);
8104 }
8105 
8106 void Assembler::andq(Register dst, Address src) {
8107   InstructionMark im(this);
<span class="line-modified">8108   emit_int16(get_prefixq(src, dst), 0x23);</span>

8109   emit_operand(dst, src);
8110 }
8111 
8112 void Assembler::andq(Register dst, Register src) {
8113   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8114   emit_arith(0x23, 0xC0, dst, src);
8115 }
8116 
8117 void Assembler::andnq(Register dst, Register src1, Register src2) {
8118   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8119   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8120   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">8121   emit_int16((unsigned char)0xF2, (0xC0 | encode));</span>

8122 }
8123 
8124 void Assembler::andnq(Register dst, Register src1, Address src2) {
8125   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8126   InstructionMark im(this);
8127   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8128   vex_prefix(src2, src1-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8129   emit_int8((unsigned char)0xF2);
8130   emit_operand(dst, src2);
8131 }
8132 
8133 void Assembler::bsfq(Register dst, Register src) {
8134   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">8135   emit_int24(0x0F, (unsigned char)0xBC, (0xC0 | encode));</span>


8136 }
8137 
8138 void Assembler::bsrq(Register dst, Register src) {
8139   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">8140   emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));</span>


8141 }
8142 
8143 void Assembler::bswapq(Register reg) {
8144   int encode = prefixq_and_encode(reg-&gt;encoding());
<span class="line-modified">8145   emit_int16(0x0F, (0xC8 | encode));</span>

8146 }
8147 
8148 void Assembler::blsiq(Register dst, Register src) {
8149   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8150   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8151   int encode = vex_prefix_and_encode(rbx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">8152   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>

8153 }
8154 
8155 void Assembler::blsiq(Register dst, Address src) {
8156   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8157   InstructionMark im(this);
8158   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8159   vex_prefix(src, dst-&gt;encoding(), rbx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8160   emit_int8((unsigned char)0xF3);
8161   emit_operand(rbx, src);
8162 }
8163 
8164 void Assembler::blsmskq(Register dst, Register src) {
8165   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8166   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8167   int encode = vex_prefix_and_encode(rdx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">8168   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>

8169 }
8170 
8171 void Assembler::blsmskq(Register dst, Address src) {
8172   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8173   InstructionMark im(this);
8174   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8175   vex_prefix(src, dst-&gt;encoding(), rdx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8176   emit_int8((unsigned char)0xF3);
8177   emit_operand(rdx, src);
8178 }
8179 
8180 void Assembler::blsrq(Register dst, Register src) {
8181   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8182   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8183   int encode = vex_prefix_and_encode(rcx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">8184   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>

8185 }
8186 
8187 void Assembler::blsrq(Register dst, Address src) {
8188   assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
8189   InstructionMark im(this);
8190   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8191   vex_prefix(src, dst-&gt;encoding(), rcx-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
8192   emit_int8((unsigned char)0xF3);
8193   emit_operand(rcx, src);
8194 }
8195 
8196 void Assembler::cdqq() {
<span class="line-modified">8197   emit_int16(REX_W, (unsigned char)0x99);</span>

8198 }
8199 
8200 void Assembler::clflush(Address adr) {
8201   assert(VM_Version::supports_clflush(), &quot;should do&quot;);
8202   prefix(adr);
<span class="line-modified">8203   emit_int16(0x0F, (unsigned char)0xAE);</span>

8204   emit_operand(rdi, adr);
8205 }
8206 
8207 void Assembler::clflushopt(Address adr) {
8208   assert(VM_Version::supports_clflushopt(), &quot;should do!&quot;);
8209   // adr should be base reg only with no index or offset
8210   assert(adr.index() == noreg, &quot;index should be noreg&quot;);
8211   assert(adr.scale() == Address::no_scale, &quot;scale should be no_scale&quot;);
8212   assert(adr.disp() == 0, &quot;displacement should be 0&quot;);
8213   // instruction prefix is 0x66
8214   emit_int8(0x66);
8215   prefix(adr);
<span class="line-modified">8216   // opcode family is 0x0F 0xAE</span>
<span class="line-modified">8217   emit_int16(0x0F, (unsigned char)0xAE);</span>

8218   // extended opcode byte is 7 == rdi
8219   emit_operand(rdi, adr);
8220 }
8221 
8222 void Assembler::clwb(Address adr) {
8223   assert(VM_Version::supports_clwb(), &quot;should do!&quot;);
8224   // adr should be base reg only with no index or offset
8225   assert(adr.index() == noreg, &quot;index should be noreg&quot;);
8226   assert(adr.scale() == Address::no_scale, &quot;scale should be no_scale&quot;);
8227   assert(adr.disp() == 0, &quot;displacement should be 0&quot;);
8228   // instruction prefix is 0x66
8229   emit_int8(0x66);
8230   prefix(adr);
8231   // opcode family is 0x0f 0xAE
<span class="line-modified">8232   emit_int16(0x0F, (unsigned char)0xAE);</span>

8233   // extended opcode byte is 6 == rsi
8234   emit_operand(rsi, adr);
8235 }
8236 
8237 void Assembler::cmovq(Condition cc, Register dst, Register src) {
8238   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">8239   emit_int24(0x0F, (0x40 | cc), (0xC0 | encode));</span>


8240 }
8241 
8242 void Assembler::cmovq(Condition cc, Register dst, Address src) {
8243   InstructionMark im(this);
<span class="line-modified">8244   emit_int24(get_prefixq(src, dst), 0x0F, (0x40 | cc));</span>


8245   emit_operand(dst, src);
8246 }
8247 
8248 void Assembler::cmpq(Address dst, int32_t imm32) {
8249   InstructionMark im(this);
<span class="line-modified">8250   emit_int16(get_prefixq(dst), (unsigned char)0x81);</span>

8251   emit_operand(rdi, dst, 4);
8252   emit_int32(imm32);
8253 }
8254 
8255 void Assembler::cmpq(Register dst, int32_t imm32) {
8256   (void) prefixq_and_encode(dst-&gt;encoding());
8257   emit_arith(0x81, 0xF8, dst, imm32);
8258 }
8259 
8260 void Assembler::cmpq(Address dst, Register src) {
8261   InstructionMark im(this);
<span class="line-modified">8262   emit_int16(get_prefixq(dst, src), 0x3B);</span>

8263   emit_operand(src, dst);
8264 }
8265 
8266 void Assembler::cmpq(Register dst, Register src) {
8267   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8268   emit_arith(0x3B, 0xC0, dst, src);
8269 }
8270 
<span class="line-modified">8271 void Assembler::cmpq(Register dst, Address src) {</span>
8272   InstructionMark im(this);
<span class="line-modified">8273   emit_int16(get_prefixq(src, dst), 0x3B);</span>

8274   emit_operand(dst, src);
8275 }
8276 
8277 void Assembler::cmpxchgq(Register reg, Address adr) {
8278   InstructionMark im(this);
<span class="line-modified">8279   emit_int24(get_prefixq(adr, reg), 0x0F, (unsigned char)0xB1);</span>


8280   emit_operand(reg, adr);
8281 }
8282 
8283 void Assembler::cvtsi2sdq(XMMRegister dst, Register src) {
8284   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8285   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8286   int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">8287   emit_int16(0x2A, (0xC0 | encode));</span>

8288 }
8289 
8290 void Assembler::cvtsi2sdq(XMMRegister dst, Address src) {
8291   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8292   InstructionMark im(this);
8293   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8294   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
8295   simd_prefix(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
8296   emit_int8(0x2A);
8297   emit_operand(dst, src);
8298 }
8299 
8300 void Assembler::cvtsi2ssq(XMMRegister dst, Address src) {
8301   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
8302   InstructionMark im(this);
8303   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8304   attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
8305   simd_prefix(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
8306   emit_int8(0x2A);
8307   emit_operand(dst, src);
8308 }
8309 
8310 void Assembler::cvttsd2siq(Register dst, Address src) {
8311   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8312   // F2 REX.W 0F 2C /r
8313   // CVTTSD2SI r64, xmm1/m64
8314   InstructionMark im(this);
<span class="line-modified">8315   emit_int32((unsigned char)0xF2, REX_W, 0x0F, 0x2C);</span>



8316   emit_operand(dst, src);
8317 }
8318 
8319 void Assembler::cvttsd2siq(Register dst, XMMRegister src) {
8320   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8321   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8322   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">8323   emit_int16(0x2C, (0xC0 | encode));</span>

8324 }
8325 
8326 void Assembler::cvttss2siq(Register dst, XMMRegister src) {
8327   NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
8328   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8329   int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">8330   emit_int16(0x2C, (0xC0 | encode));</span>

8331 }
8332 
8333 void Assembler::decl(Register dst) {
8334   // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
8335   // Use two-byte form (one-byte form is a REX prefix in 64-bit mode)
8336   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">8337   emit_int16((unsigned char)0xFF, (0xC8 | encode));</span>

8338 }
8339 
8340 void Assembler::decq(Register dst) {
8341   // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
8342   // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
8343   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">8344   emit_int16((unsigned char)0xFF, 0xC8 | encode);</span>

8345 }
8346 
8347 void Assembler::decq(Address dst) {
8348   // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
8349   InstructionMark im(this);
<span class="line-modified">8350   emit_int16(get_prefixq(dst), (unsigned char)0xFF);</span>

8351   emit_operand(rcx, dst);
8352 }
8353 
8354 void Assembler::fxrstor(Address src) {
<span class="line-modified">8355   emit_int24(get_prefixq(src), 0x0F, (unsigned char)0xAE);</span>


8356   emit_operand(as_Register(1), src);
8357 }
8358 
8359 void Assembler::xrstor(Address src) {
<span class="line-modified">8360   emit_int24(get_prefixq(src), 0x0F, (unsigned char)0xAE);</span>


8361   emit_operand(as_Register(5), src);
8362 }
8363 
8364 void Assembler::fxsave(Address dst) {
<span class="line-modified">8365   emit_int24(get_prefixq(dst), 0x0F, (unsigned char)0xAE);</span>


8366   emit_operand(as_Register(0), dst);
8367 }
8368 
8369 void Assembler::xsave(Address dst) {
<span class="line-modified">8370   emit_int24(get_prefixq(dst), 0x0F, (unsigned char)0xAE);</span>


8371   emit_operand(as_Register(4), dst);
8372 }
8373 
8374 void Assembler::idivq(Register src) {
8375   int encode = prefixq_and_encode(src-&gt;encoding());
<span class="line-modified">8376   emit_int16((unsigned char)0xF7, (0xF8 | encode));</span>

8377 }
8378 
8379 void Assembler::imulq(Register dst, Register src) {
8380   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">8381   emit_int24(0x0F, (unsigned char)0xAF, (0xC0 | encode));</span>


8382 }
8383 
8384 void Assembler::imulq(Register dst, Register src, int value) {
8385   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8386   if (is8bit(value)) {
<span class="line-modified">8387     emit_int24(0x6B, (0xC0 | encode), (value &amp; 0xFF));</span>


8388   } else {
<span class="line-modified">8389     emit_int16(0x69, (0xC0 | encode));</span>

8390     emit_int32(value);
8391   }
8392 }
8393 
8394 void Assembler::imulq(Register dst, Address src) {
8395   InstructionMark im(this);
<span class="line-modified">8396   emit_int24(get_prefixq(src, dst), 0x0F, (unsigned char)0xAF);</span>


8397   emit_operand(dst, src);
8398 }
8399 
8400 void Assembler::incl(Register dst) {
8401   // Don&#39;t use it directly. Use MacroAssembler::incrementl() instead.
8402   // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
8403   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">8404   emit_int16((unsigned char)0xFF, (0xC0 | encode));</span>

8405 }
8406 
8407 void Assembler::incq(Register dst) {
8408   // Don&#39;t use it directly. Use MacroAssembler::incrementq() instead.
8409   // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
8410   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">8411   emit_int16((unsigned char)0xFF, (0xC0 | encode));</span>

8412 }
8413 
8414 void Assembler::incq(Address dst) {
8415   // Don&#39;t use it directly. Use MacroAssembler::incrementq() instead.
8416   InstructionMark im(this);
<span class="line-modified">8417   emit_int16(get_prefixq(dst), (unsigned char)0xFF);</span>

8418   emit_operand(rax, dst);
8419 }
8420 
8421 void Assembler::lea(Register dst, Address src) {
8422   leaq(dst, src);
8423 }
8424 
8425 void Assembler::leaq(Register dst, Address src) {
8426   InstructionMark im(this);
<span class="line-modified">8427   emit_int16(get_prefixq(src, dst), (unsigned char)0x8D);</span>

8428   emit_operand(dst, src);
8429 }
8430 
8431 void Assembler::mov64(Register dst, int64_t imm64) {
8432   InstructionMark im(this);
8433   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">8434   emit_int8(0xB8 | encode);</span>
8435   emit_int64(imm64);
8436 }
8437 
8438 void Assembler::mov_literal64(Register dst, intptr_t imm64, RelocationHolder const&amp; rspec) {
8439   InstructionMark im(this);
8440   int encode = prefixq_and_encode(dst-&gt;encoding());
8441   emit_int8(0xB8 | encode);
8442   emit_data64(imm64, rspec);
8443 }
8444 
8445 void Assembler::mov_narrow_oop(Register dst, int32_t imm32, RelocationHolder const&amp; rspec) {
8446   InstructionMark im(this);
8447   int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">8448   emit_int8(0xB8 | encode);</span>
8449   emit_data((int)imm32, rspec, narrow_oop_operand);
8450 }
8451 
8452 void Assembler::mov_narrow_oop(Address dst, int32_t imm32,  RelocationHolder const&amp; rspec) {
8453   InstructionMark im(this);
8454   prefix(dst);
8455   emit_int8((unsigned char)0xC7);
8456   emit_operand(rax, dst, 4);
8457   emit_data((int)imm32, rspec, narrow_oop_operand);
8458 }
8459 
8460 void Assembler::cmp_narrow_oop(Register src1, int32_t imm32, RelocationHolder const&amp; rspec) {
8461   InstructionMark im(this);
8462   int encode = prefix_and_encode(src1-&gt;encoding());
<span class="line-modified">8463   emit_int16((unsigned char)0x81, (0xF8 | encode));</span>

8464   emit_data((int)imm32, rspec, narrow_oop_operand);
8465 }
8466 
8467 void Assembler::cmp_narrow_oop(Address src1, int32_t imm32, RelocationHolder const&amp; rspec) {
8468   InstructionMark im(this);
8469   prefix(src1);
8470   emit_int8((unsigned char)0x81);
8471   emit_operand(rax, src1, 4);
8472   emit_data((int)imm32, rspec, narrow_oop_operand);
8473 }
8474 
8475 void Assembler::lzcntq(Register dst, Register src) {
8476   assert(VM_Version::supports_lzcnt(), &quot;encoding is treated as BSR&quot;);
8477   emit_int8((unsigned char)0xF3);
8478   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">8479   emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));</span>


8480 }
8481 
8482 void Assembler::movdq(XMMRegister dst, Register src) {
8483   // table D-1 says MMX/SSE2
8484   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8485   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8486   int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">8487   emit_int16(0x6E, (0xC0 | encode));</span>

8488 }
8489 
8490 void Assembler::movdq(Register dst, XMMRegister src) {
8491   // table D-1 says MMX/SSE2
8492   NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
8493   InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
8494   // swap src/dst to get correct prefix
8495   int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">8496   emit_int16(0x7E,</span>
<span class="line-modified">8497              (0xC0 | encode));</span>
8498 }
8499 
8500 void Assembler::movq(Register dst, Register src) {
8501   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">8502   emit_int16((unsigned char)0x8B,</span>
<span class="line-modified">8503              (0xC0 | encode));</span>
8504 }
8505 
8506 void Assembler::movq(Register dst, Address src) {
8507   InstructionMark im(this);
<span class="line-modified">8508   emit_int16(get_prefixq(src, dst), (unsigned char)0x8B);</span>

8509   emit_operand(dst, src);
8510 }
8511 
8512 void Assembler::movq(Address dst, Register src) {
8513   InstructionMark im(this);
<span class="line-modified">8514   emit_int16(get_prefixq(dst, src), (unsigned char)0x89);</span>

8515   emit_operand(src, dst);
8516 }
8517 
8518 void Assembler::movsbq(Register dst, Address src) {
8519   InstructionMark im(this);
<span class="line-modified">8520   emit_int24(get_prefixq(src, dst),</span>
<span class="line-modified">8521              0x0F,</span>
<span class="line-modified">8522              (unsigned char)0xBE);</span>
8523   emit_operand(dst, src);
8524 }
8525 
8526 void Assembler::movsbq(Register dst, Register src) {
8527   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">8528   emit_int24(0x0F, (unsigned char)0xBE, (0xC0 | encode));</span>


8529 }
8530 
8531 void Assembler::movslq(Register dst, int32_t imm32) {
8532   // dbx shows movslq(rcx, 3) as movq     $0x0000000049000000,(%rbx)
8533   // and movslq(r8, 3); as movl     $0x0000000048000000,(%rbx)
8534   // as a result we shouldn&#39;t use until tested at runtime...
8535   ShouldNotReachHere();
8536   InstructionMark im(this);
8537   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">8538   emit_int8(0xC7 | encode);</span>
8539   emit_int32(imm32);
8540 }
8541 
8542 void Assembler::movslq(Address dst, int32_t imm32) {
8543   assert(is_simm32(imm32), &quot;lost bits&quot;);
8544   InstructionMark im(this);
<span class="line-modified">8545   emit_int16(get_prefixq(dst), (unsigned char)0xC7);</span>

8546   emit_operand(rax, dst, 4);
8547   emit_int32(imm32);
8548 }
8549 
8550 void Assembler::movslq(Register dst, Address src) {
8551   InstructionMark im(this);
<span class="line-modified">8552   emit_int16(get_prefixq(src, dst), 0x63);</span>

8553   emit_operand(dst, src);
8554 }
8555 
8556 void Assembler::movslq(Register dst, Register src) {
8557   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">8558   emit_int16(0x63, (0xC0 | encode));</span>

8559 }
8560 
8561 void Assembler::movswq(Register dst, Address src) {
8562   InstructionMark im(this);
<span class="line-modified">8563   emit_int24(get_prefixq(src, dst),</span>
<span class="line-modified">8564              0x0F,</span>
<span class="line-modified">8565              (unsigned char)0xBF);</span>
8566   emit_operand(dst, src);
8567 }
8568 
8569 void Assembler::movswq(Register dst, Register src) {
8570   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">8571   emit_int24(0x0F, (unsigned char)0xBF, (0xC0 | encode));</span>


8572 }
8573 
8574 void Assembler::movzbq(Register dst, Address src) {
8575   InstructionMark im(this);
<span class="line-modified">8576   emit_int24(get_prefixq(src, dst),</span>
<span class="line-modified">8577              0x0F,</span>
<span class="line-modified">8578              (unsigned char)0xB6);</span>
8579   emit_operand(dst, src);
8580 }
8581 
8582 void Assembler::movzbq(Register dst, Register src) {
8583   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">8584   emit_int24(0x0F, (unsigned char)0xB6, (0xC0 | encode));</span>


8585 }
8586 
8587 void Assembler::movzwq(Register dst, Address src) {
8588   InstructionMark im(this);
<span class="line-modified">8589   emit_int24(get_prefixq(src, dst),</span>
<span class="line-modified">8590              0x0F,</span>
<span class="line-modified">8591              (unsigned char)0xB7);</span>
8592   emit_operand(dst, src);
8593 }
8594 
8595 void Assembler::movzwq(Register dst, Register src) {
8596   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">8597   emit_int24(0x0F, (unsigned char)0xB7, (0xC0 | encode));</span>


8598 }
8599 
8600 void Assembler::mulq(Address src) {
8601   InstructionMark im(this);
<span class="line-modified">8602   emit_int16(get_prefixq(src), (unsigned char)0xF7);</span>

8603   emit_operand(rsp, src);
8604 }
8605 
8606 void Assembler::mulq(Register src) {
8607   int encode = prefixq_and_encode(src-&gt;encoding());
<span class="line-modified">8608   emit_int16((unsigned char)0xF7, (0xE0 | encode));</span>

8609 }
8610 
8611 void Assembler::mulxq(Register dst1, Register dst2, Register src) {
8612   assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
8613   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8614   int encode = vex_prefix_and_encode(dst1-&gt;encoding(), dst2-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">8615   emit_int16((unsigned char)0xF6, (0xC0 | encode));</span>

8616 }
8617 
8618 void Assembler::negq(Register dst) {
8619   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">8620   emit_int16((unsigned char)0xF7, (0xD8 | encode));</span>

8621 }
8622 
8623 void Assembler::notq(Register dst) {
8624   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">8625   emit_int16((unsigned char)0xF7, (0xD0 | encode));</span>

8626 }
8627 
8628 void Assembler::btsq(Address dst, int imm8) {
8629   assert(isByte(imm8), &quot;not a byte&quot;);
8630   InstructionMark im(this);
<span class="line-modified">8631   emit_int24(get_prefixq(dst),</span>
<span class="line-modified">8632              0x0F,</span>
<span class="line-modified">8633              (unsigned char)0xBA);</span>
8634   emit_operand(rbp /* 5 */, dst, 1);
8635   emit_int8(imm8);
8636 }
8637 
8638 void Assembler::btrq(Address dst, int imm8) {
8639   assert(isByte(imm8), &quot;not a byte&quot;);
8640   InstructionMark im(this);
<span class="line-modified">8641   emit_int24(get_prefixq(dst),</span>
<span class="line-modified">8642              0x0F,</span>
<span class="line-modified">8643              (unsigned char)0xBA);</span>
8644   emit_operand(rsi /* 6 */, dst, 1);
8645   emit_int8(imm8);
8646 }
8647 
8648 void Assembler::orq(Address dst, int32_t imm32) {
8649   InstructionMark im(this);
<span class="line-modified">8650   emit_int16(get_prefixq(dst), (unsigned char)0x81);</span>

8651   emit_operand(rcx, dst, 4);
8652   emit_int32(imm32);
8653 }
8654 
8655 void Assembler::orq(Register dst, int32_t imm32) {
8656   (void) prefixq_and_encode(dst-&gt;encoding());
8657   emit_arith(0x81, 0xC8, dst, imm32);
8658 }
8659 
8660 void Assembler::orq(Register dst, Address src) {
8661   InstructionMark im(this);
<span class="line-modified">8662   emit_int16(get_prefixq(src, dst), 0x0B);</span>

8663   emit_operand(dst, src);
8664 }
8665 
8666 void Assembler::orq(Register dst, Register src) {
8667   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8668   emit_arith(0x0B, 0xC0, dst, src);
8669 }
8670 
<span class="line-added">8671 void Assembler::popcntq(Register dst, Address src) {</span>
<span class="line-added">8672   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);</span>
<span class="line-added">8673   InstructionMark im(this);</span>
<span class="line-added">8674   emit_int32((unsigned char)0xF3,</span>
<span class="line-added">8675              get_prefixq(src, dst),</span>
<span class="line-added">8676              0x0F,</span>
<span class="line-added">8677              (unsigned char)0xB8);</span>
<span class="line-added">8678   emit_operand(dst, src);</span>
<span class="line-added">8679 }</span>
<span class="line-added">8680 </span>
<span class="line-added">8681 void Assembler::popcntq(Register dst, Register src) {</span>
<span class="line-added">8682   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);</span>
<span class="line-added">8683   emit_int8((unsigned char)0xF3);</span>
<span class="line-added">8684   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());</span>
<span class="line-added">8685   emit_int24(0x0F, (unsigned char)0xB8, (0xC0 | encode));</span>
<span class="line-added">8686 }</span>
<span class="line-added">8687 </span>
<span class="line-added">8688 void Assembler::popq(Address dst) {</span>
<span class="line-added">8689   InstructionMark im(this);</span>
<span class="line-added">8690   emit_int16(get_prefixq(dst), (unsigned char)0x8F);</span>
<span class="line-added">8691   emit_operand(rax, dst);</span>
<span class="line-added">8692 }</span>
<span class="line-added">8693 </span>
<span class="line-added">8694 // Precomputable: popa, pusha, vzeroupper</span>
<span class="line-added">8695 </span>
<span class="line-added">8696 // The result of these routines are invariant from one invocation to another</span>
<span class="line-added">8697 // invocation for the duration of a run. Caching the result on bootstrap</span>
<span class="line-added">8698 // and copying it out on subsequent invocations can thus be beneficial</span>
<span class="line-added">8699 static bool     precomputed = false;</span>
<span class="line-added">8700 </span>
<span class="line-added">8701 static u_char* popa_code  = NULL;</span>
<span class="line-added">8702 static int     popa_len   = 0;</span>
<span class="line-added">8703 </span>
<span class="line-added">8704 static u_char* pusha_code = NULL;</span>
<span class="line-added">8705 static int     pusha_len  = 0;</span>
<span class="line-added">8706 </span>
<span class="line-added">8707 static u_char* vzup_code  = NULL;</span>
<span class="line-added">8708 static int     vzup_len   = 0;</span>
<span class="line-added">8709 </span>
<span class="line-added">8710 void Assembler::precompute_instructions() {</span>
<span class="line-added">8711   assert(!Universe::is_fully_initialized(), &quot;must still be single threaded&quot;);</span>
<span class="line-added">8712   guarantee(!precomputed, &quot;only once&quot;);</span>
<span class="line-added">8713   precomputed = true;</span>
<span class="line-added">8714   ResourceMark rm;</span>
<span class="line-added">8715 </span>
<span class="line-added">8716   // Make a temporary buffer big enough for the routines we&#39;re capturing</span>
<span class="line-added">8717   int size = 256;</span>
<span class="line-added">8718   char* tmp_code = NEW_RESOURCE_ARRAY(char, size);</span>
<span class="line-added">8719   CodeBuffer buffer((address)tmp_code, size);</span>
<span class="line-added">8720   MacroAssembler masm(&amp;buffer);</span>
<span class="line-added">8721 </span>
<span class="line-added">8722   address begin_popa  = masm.code_section()-&gt;end();</span>
<span class="line-added">8723   masm.popa_uncached();</span>
<span class="line-added">8724   address end_popa    = masm.code_section()-&gt;end();</span>
<span class="line-added">8725   masm.pusha_uncached();</span>
<span class="line-added">8726   address end_pusha   = masm.code_section()-&gt;end();</span>
<span class="line-added">8727   masm.vzeroupper_uncached();</span>
<span class="line-added">8728   address end_vzup    = masm.code_section()-&gt;end();</span>
<span class="line-added">8729 </span>
<span class="line-added">8730   // Save the instructions to permanent buffers.</span>
<span class="line-added">8731   popa_len = (int)(end_popa - begin_popa);</span>
<span class="line-added">8732   popa_code = NEW_C_HEAP_ARRAY(u_char, popa_len, mtInternal);</span>
<span class="line-added">8733   memcpy(popa_code, begin_popa, popa_len);</span>
<span class="line-added">8734 </span>
<span class="line-added">8735   pusha_len = (int)(end_pusha - end_popa);</span>
<span class="line-added">8736   pusha_code = NEW_C_HEAP_ARRAY(u_char, pusha_len, mtInternal);</span>
<span class="line-added">8737   memcpy(pusha_code, end_popa, pusha_len);</span>
<span class="line-added">8738 </span>
<span class="line-added">8739   vzup_len = (int)(end_vzup - end_pusha);</span>
<span class="line-added">8740   if (vzup_len &gt; 0) {</span>
<span class="line-added">8741     vzup_code = NEW_C_HEAP_ARRAY(u_char, vzup_len, mtInternal);</span>
<span class="line-added">8742     memcpy(vzup_code, end_pusha, vzup_len);</span>
<span class="line-added">8743   } else {</span>
<span class="line-added">8744     vzup_code = pusha_code; // dummy</span>
<span class="line-added">8745   }</span>
<span class="line-added">8746 </span>
<span class="line-added">8747   assert(masm.code()-&gt;total_oop_size() == 0 &amp;&amp;</span>
<span class="line-added">8748          masm.code()-&gt;total_metadata_size() == 0 &amp;&amp;</span>
<span class="line-added">8749          masm.code()-&gt;total_relocation_size() == 0,</span>
<span class="line-added">8750          &quot;pre-computed code can&#39;t reference oops, metadata or contain relocations&quot;);</span>
<span class="line-added">8751 }</span>
<span class="line-added">8752 </span>
<span class="line-added">8753 static void emit_copy(CodeSection* code_section, u_char* src, int src_len) {</span>
<span class="line-added">8754   assert(src != NULL, &quot;code to copy must have been pre-computed&quot;);</span>
<span class="line-added">8755   assert(code_section-&gt;limit() - code_section-&gt;end() &gt; src_len, &quot;code buffer not large enough&quot;);</span>
<span class="line-added">8756   address end = code_section-&gt;end();</span>
<span class="line-added">8757   memcpy(end, src, src_len);</span>
<span class="line-added">8758   code_section-&gt;set_end(end + src_len);</span>
<span class="line-added">8759 }</span>
<span class="line-added">8760 </span>
8761 void Assembler::popa() { // 64bit
<span class="line-added">8762   emit_copy(code_section(), popa_code, popa_len);</span>
<span class="line-added">8763 }</span>
<span class="line-added">8764 </span>
<span class="line-added">8765 void Assembler::popa_uncached() { // 64bit</span>
8766   movq(r15, Address(rsp, 0));
8767   movq(r14, Address(rsp, wordSize));
8768   movq(r13, Address(rsp, 2 * wordSize));
8769   movq(r12, Address(rsp, 3 * wordSize));
8770   movq(r11, Address(rsp, 4 * wordSize));
8771   movq(r10, Address(rsp, 5 * wordSize));
8772   movq(r9,  Address(rsp, 6 * wordSize));
8773   movq(r8,  Address(rsp, 7 * wordSize));
8774   movq(rdi, Address(rsp, 8 * wordSize));
8775   movq(rsi, Address(rsp, 9 * wordSize));
8776   movq(rbp, Address(rsp, 10 * wordSize));
8777   // skip rsp
8778   movq(rbx, Address(rsp, 12 * wordSize));
8779   movq(rdx, Address(rsp, 13 * wordSize));
8780   movq(rcx, Address(rsp, 14 * wordSize));
8781   movq(rax, Address(rsp, 15 * wordSize));
8782 
8783   addq(rsp, 16 * wordSize);
8784 }
8785 
<span class="line-modified">8786 void Assembler::pusha() { // 64bit</span>
<span class="line-modified">8787   emit_copy(code_section(), pusha_code, pusha_len);</span>






















8788 }
8789 
<span class="line-modified">8790 void Assembler::pusha_uncached() { // 64bit</span>
8791   // we have to store original rsp.  ABI says that 128 bytes
8792   // below rsp are local scratch.
8793   movq(Address(rsp, -5 * wordSize), rsp);
8794 
8795   subq(rsp, 16 * wordSize);
8796 
8797   movq(Address(rsp, 15 * wordSize), rax);
8798   movq(Address(rsp, 14 * wordSize), rcx);
8799   movq(Address(rsp, 13 * wordSize), rdx);
8800   movq(Address(rsp, 12 * wordSize), rbx);
8801   // skip rsp
8802   movq(Address(rsp, 10 * wordSize), rbp);
8803   movq(Address(rsp, 9 * wordSize), rsi);
8804   movq(Address(rsp, 8 * wordSize), rdi);
8805   movq(Address(rsp, 7 * wordSize), r8);
8806   movq(Address(rsp, 6 * wordSize), r9);
8807   movq(Address(rsp, 5 * wordSize), r10);
8808   movq(Address(rsp, 4 * wordSize), r11);
8809   movq(Address(rsp, 3 * wordSize), r12);
8810   movq(Address(rsp, 2 * wordSize), r13);
8811   movq(Address(rsp, wordSize), r14);
8812   movq(Address(rsp, 0), r15);
8813 }
8814 
<span class="line-added">8815 void Assembler::vzeroupper() {</span>
<span class="line-added">8816   emit_copy(code_section(), vzup_code, vzup_len);</span>
<span class="line-added">8817 }</span>
<span class="line-added">8818 </span>
8819 void Assembler::pushq(Address src) {
8820   InstructionMark im(this);
<span class="line-modified">8821   emit_int16(get_prefixq(src), (unsigned char)0xFF);</span>

8822   emit_operand(rsi, src);
8823 }
8824 
8825 void Assembler::rclq(Register dst, int imm8) {
8826   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
8827   int encode = prefixq_and_encode(dst-&gt;encoding());
8828   if (imm8 == 1) {
<span class="line-modified">8829     emit_int16((unsigned char)0xD1, (0xD0 | encode));</span>

8830   } else {
<span class="line-modified">8831     emit_int24((unsigned char)0xC1, (0xD0 | encode), imm8);</span>


8832   }
8833 }
8834 
8835 void Assembler::rcrq(Register dst, int imm8) {
8836   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
8837   int encode = prefixq_and_encode(dst-&gt;encoding());
8838   if (imm8 == 1) {
<span class="line-modified">8839     emit_int16((unsigned char)0xD1, (0xD8 | encode));</span>

8840   } else {
<span class="line-modified">8841     emit_int24((unsigned char)0xC1, (0xD8 | encode), imm8);</span>


8842   }
8843 }
8844 
8845 void Assembler::rorq(Register dst, int imm8) {
8846   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
8847   int encode = prefixq_and_encode(dst-&gt;encoding());
8848   if (imm8 == 1) {
<span class="line-modified">8849     emit_int16((unsigned char)0xD1, (0xC8 | encode));</span>

8850   } else {
<span class="line-modified">8851     emit_int24((unsigned char)0xC1, (0xc8 | encode), imm8);</span>


8852   }
8853 }
8854 
8855 void Assembler::rorxq(Register dst, Register src, int imm8) {
8856   assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
8857   InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8858   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">8859   emit_int24((unsigned char)0xF0, (0xC0 | encode), imm8);</span>


8860 }
8861 
8862 void Assembler::rorxd(Register dst, Register src, int imm8) {
8863   assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
8864   InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
8865   int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">8866   emit_int24((unsigned char)0xF0, (0xC0 | encode), imm8);</span>


8867 }
8868 
8869 void Assembler::sarq(Register dst, int imm8) {
8870   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
8871   int encode = prefixq_and_encode(dst-&gt;encoding());
8872   if (imm8 == 1) {
<span class="line-modified">8873     emit_int16((unsigned char)0xD1, (0xF8 | encode));</span>

8874   } else {
<span class="line-modified">8875     emit_int24((unsigned char)0xC1, (0xF8 | encode), imm8);</span>


8876   }
8877 }
8878 
8879 void Assembler::sarq(Register dst) {
8880   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">8881   emit_int16((unsigned char)0xD3, (0xF8 | encode));</span>

8882 }
8883 
8884 void Assembler::sbbq(Address dst, int32_t imm32) {
8885   InstructionMark im(this);
8886   prefixq(dst);
8887   emit_arith_operand(0x81, rbx, dst, imm32);
8888 }
8889 
8890 void Assembler::sbbq(Register dst, int32_t imm32) {
8891   (void) prefixq_and_encode(dst-&gt;encoding());
8892   emit_arith(0x81, 0xD8, dst, imm32);
8893 }
8894 
8895 void Assembler::sbbq(Register dst, Address src) {
8896   InstructionMark im(this);
<span class="line-modified">8897   emit_int16(get_prefixq(src, dst), 0x1B);</span>

8898   emit_operand(dst, src);
8899 }
8900 
8901 void Assembler::sbbq(Register dst, Register src) {
8902   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8903   emit_arith(0x1B, 0xC0, dst, src);
8904 }
8905 
8906 void Assembler::shlq(Register dst, int imm8) {
8907   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
8908   int encode = prefixq_and_encode(dst-&gt;encoding());
8909   if (imm8 == 1) {
<span class="line-modified">8910     emit_int16((unsigned char)0xD1, (0xE0 | encode));</span>

8911   } else {
<span class="line-modified">8912     emit_int24((unsigned char)0xC1, (0xE0 | encode), imm8);</span>


8913   }
8914 }
8915 
8916 void Assembler::shlq(Register dst) {
8917   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">8918   emit_int16((unsigned char)0xD3, (0xE0 | encode));</span>

8919 }
8920 
8921 void Assembler::shrq(Register dst, int imm8) {
8922   assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
8923   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">8924   emit_int24((unsigned char)0xC1, (0xE8 | encode), imm8);</span>


8925 }
8926 
8927 void Assembler::shrq(Register dst) {
8928   int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">8929   emit_int16((unsigned char)0xD3, 0xE8 | encode);</span>

8930 }
8931 
8932 void Assembler::subq(Address dst, int32_t imm32) {
8933   InstructionMark im(this);
8934   prefixq(dst);
8935   emit_arith_operand(0x81, rbp, dst, imm32);
8936 }
8937 
8938 void Assembler::subq(Address dst, Register src) {
8939   InstructionMark im(this);
<span class="line-modified">8940   emit_int16(get_prefixq(dst, src), 0x29);</span>

8941   emit_operand(src, dst);
8942 }
8943 
8944 void Assembler::subq(Register dst, int32_t imm32) {
8945   (void) prefixq_and_encode(dst-&gt;encoding());
8946   emit_arith(0x81, 0xE8, dst, imm32);
8947 }
8948 
8949 // Force generation of a 4 byte immediate value even if it fits into 8bit
8950 void Assembler::subq_imm32(Register dst, int32_t imm32) {
8951   (void) prefixq_and_encode(dst-&gt;encoding());
8952   emit_arith_imm32(0x81, 0xE8, dst, imm32);
8953 }
8954 
8955 void Assembler::subq(Register dst, Address src) {
8956   InstructionMark im(this);
<span class="line-modified">8957   emit_int16(get_prefixq(src, dst), 0x2B);</span>

8958   emit_operand(dst, src);
8959 }
8960 
8961 void Assembler::subq(Register dst, Register src) {
8962   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8963   emit_arith(0x2B, 0xC0, dst, src);
8964 }
8965 
8966 void Assembler::testq(Register dst, int32_t imm32) {
8967   // not using emit_arith because test
8968   // doesn&#39;t support sign-extension of
8969   // 8bit operands
8970   int encode = dst-&gt;encoding();
8971   if (encode == 0) {
<span class="line-modified">8972     emit_int16(REX_W, (unsigned char)0xA9);</span>

8973   } else {
8974     encode = prefixq_and_encode(encode);
<span class="line-modified">8975     emit_int16((unsigned char)0xF7, (0xC0 | encode));</span>

8976   }
8977   emit_int32(imm32);
8978 }
8979 
8980 void Assembler::testq(Register dst, Register src) {
8981   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
8982   emit_arith(0x85, 0xC0, dst, src);
8983 }
8984 
8985 void Assembler::testq(Register dst, Address src) {
8986   InstructionMark im(this);
<span class="line-modified">8987   emit_int16(get_prefixq(src, dst), (unsigned char)0x85);</span>

8988   emit_operand(dst, src);
8989 }
8990 
8991 void Assembler::xaddq(Address dst, Register src) {
8992   InstructionMark im(this);
<span class="line-modified">8993   emit_int24(get_prefixq(dst, src), 0x0F, (unsigned char)0xC1);</span>


8994   emit_operand(src, dst);
8995 }
8996 
8997 void Assembler::xchgq(Register dst, Address src) {
8998   InstructionMark im(this);
<span class="line-modified">8999   emit_int16(get_prefixq(src, dst), (unsigned char)0x87);</span>

9000   emit_operand(dst, src);
9001 }
9002 
9003 void Assembler::xchgq(Register dst, Register src) {
9004   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">9005   emit_int16((unsigned char)0x87, (0xc0 | encode));</span>

9006 }
9007 
9008 void Assembler::xorq(Register dst, Register src) {
9009   (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
9010   emit_arith(0x33, 0xC0, dst, src);
9011 }
9012 
9013 void Assembler::xorq(Register dst, Address src) {
9014   InstructionMark im(this);
<span class="line-modified">9015   emit_int16(get_prefixq(src, dst), 0x33);</span>

9016   emit_operand(dst, src);
9017 }
9018 
9019 #endif // !LP64
</pre>
</td>
</tr>
</table>
<center><a href="../sparc/vm_version_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
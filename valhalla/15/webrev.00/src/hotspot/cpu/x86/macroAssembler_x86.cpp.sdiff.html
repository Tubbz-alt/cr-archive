<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   35 #include &quot;memory/universe.hpp&quot;
   36 #include &quot;oops/accessDecorators.hpp&quot;
   37 #include &quot;oops/compressedOops.inline.hpp&quot;
   38 #include &quot;oops/klass.inline.hpp&quot;
   39 #include &quot;prims/methodHandles.hpp&quot;
   40 #include &quot;runtime/biasedLocking.hpp&quot;
   41 #include &quot;runtime/flags/flagSetting.hpp&quot;
   42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
   43 #include &quot;runtime/objectMonitor.hpp&quot;
   44 #include &quot;runtime/os.hpp&quot;
   45 #include &quot;runtime/safepoint.hpp&quot;
   46 #include &quot;runtime/safepointMechanism.hpp&quot;
   47 #include &quot;runtime/sharedRuntime.hpp&quot;
   48 #include &quot;runtime/signature_cc.hpp&quot;
   49 #include &quot;runtime/stubRoutines.hpp&quot;
   50 #include &quot;runtime/thread.hpp&quot;
   51 #include &quot;utilities/macros.hpp&quot;
   52 #include &quot;vmreg_x86.inline.hpp&quot;
   53 #include &quot;crc32c.h&quot;
   54 #ifdef COMPILER2
<span class="line-modified">   55 #include &quot;opto/intrinsicnode.hpp&quot;</span>
   56 #endif
   57 
   58 #ifdef PRODUCT
   59 #define BLOCK_COMMENT(str) /* nothing */
   60 #define STOP(error) stop(error)
   61 #else
   62 #define BLOCK_COMMENT(str) block_comment(str)
   63 #define STOP(error) block_comment(error); stop(error)
   64 #endif
   65 
   66 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
   67 
   68 #ifdef ASSERT
   69 bool AbstractAssembler::pd_check_instruction_mark() { return true; }
   70 #endif
   71 
   72 static Assembler::Condition reverse[] = {
   73     Assembler::noOverflow     /* overflow      = 0x0 */ ,
   74     Assembler::overflow       /* noOverflow    = 0x1 */ ,
   75     Assembler::aboveEqual     /* carrySet      = 0x2, below         = 0x2 */ ,
</pre>
<hr />
<pre>
 1268   bind(cas_label);
 1269 
 1270   return null_check_offset;
 1271 }
 1272 
 1273 void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label&amp; done) {
 1274   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
 1275 
 1276   // Check for biased locking unlock case, which is a no-op
 1277   // Note: we do not have to check the thread ID for two reasons.
 1278   // First, the interpreter checks for IllegalMonitorStateException at
 1279   // a higher level. Second, if the bias was revoked while we held the
 1280   // lock, the object could not be rebiased toward another thread, so
 1281   // the bias bit would be clear.
 1282   movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
 1283   andptr(temp_reg, markWord::biased_lock_mask_in_place);
 1284   cmpptr(temp_reg, markWord::biased_lock_pattern);
 1285   jcc(Assembler::equal, done);
 1286 }
 1287 
<span class="line-removed"> 1288 #ifdef COMPILER2</span>
<span class="line-removed"> 1289 </span>
<span class="line-removed"> 1290 #if INCLUDE_RTM_OPT</span>
<span class="line-removed"> 1291 </span>
<span class="line-removed"> 1292 // Update rtm_counters based on abort status</span>
<span class="line-removed"> 1293 // input: abort_status</span>
<span class="line-removed"> 1294 //        rtm_counters (RTMLockingCounters*)</span>
<span class="line-removed"> 1295 // flags are killed</span>
<span class="line-removed"> 1296 void MacroAssembler::rtm_counters_update(Register abort_status, Register rtm_counters) {</span>
<span class="line-removed"> 1297 </span>
<span class="line-removed"> 1298   atomic_incptr(Address(rtm_counters, RTMLockingCounters::abort_count_offset()));</span>
<span class="line-removed"> 1299   if (PrintPreciseRTMLockingStatistics) {</span>
<span class="line-removed"> 1300     for (int i = 0; i &lt; RTMLockingCounters::ABORT_STATUS_LIMIT; i++) {</span>
<span class="line-removed"> 1301       Label check_abort;</span>
<span class="line-removed"> 1302       testl(abort_status, (1&lt;&lt;i));</span>
<span class="line-removed"> 1303       jccb(Assembler::equal, check_abort);</span>
<span class="line-removed"> 1304       atomic_incptr(Address(rtm_counters, RTMLockingCounters::abortX_count_offset() + (i * sizeof(uintx))));</span>
<span class="line-removed"> 1305       bind(check_abort);</span>
<span class="line-removed"> 1306     }</span>
<span class="line-removed"> 1307   }</span>
<span class="line-removed"> 1308 }</span>
<span class="line-removed"> 1309 </span>
<span class="line-removed"> 1310 // Branch if (random &amp; (count-1) != 0), count is 2^n</span>
<span class="line-removed"> 1311 // tmp, scr and flags are killed</span>
<span class="line-removed"> 1312 void MacroAssembler::branch_on_random_using_rdtsc(Register tmp, Register scr, int count, Label&amp; brLabel) {</span>
<span class="line-removed"> 1313   assert(tmp == rax, &quot;&quot;);</span>
<span class="line-removed"> 1314   assert(scr == rdx, &quot;&quot;);</span>
<span class="line-removed"> 1315   rdtsc(); // modifies EDX:EAX</span>
<span class="line-removed"> 1316   andptr(tmp, count-1);</span>
<span class="line-removed"> 1317   jccb(Assembler::notZero, brLabel);</span>
<span class="line-removed"> 1318 }</span>
<span class="line-removed"> 1319 </span>
<span class="line-removed"> 1320 // Perform abort ratio calculation, set no_rtm bit if high ratio</span>
<span class="line-removed"> 1321 // input:  rtm_counters_Reg (RTMLockingCounters* address)</span>
<span class="line-removed"> 1322 // tmpReg, rtm_counters_Reg and flags are killed</span>
<span class="line-removed"> 1323 void MacroAssembler::rtm_abort_ratio_calculation(Register tmpReg,</span>
<span class="line-removed"> 1324                                                  Register rtm_counters_Reg,</span>
<span class="line-removed"> 1325                                                  RTMLockingCounters* rtm_counters,</span>
<span class="line-removed"> 1326                                                  Metadata* method_data) {</span>
<span class="line-removed"> 1327   Label L_done, L_check_always_rtm1, L_check_always_rtm2;</span>
<span class="line-removed"> 1328 </span>
<span class="line-removed"> 1329   if (RTMLockingCalculationDelay &gt; 0) {</span>
<span class="line-removed"> 1330     // Delay calculation</span>
<span class="line-removed"> 1331     movptr(tmpReg, ExternalAddress((address) RTMLockingCounters::rtm_calculation_flag_addr()), tmpReg);</span>
<span class="line-removed"> 1332     testptr(tmpReg, tmpReg);</span>
<span class="line-removed"> 1333     jccb(Assembler::equal, L_done);</span>
<span class="line-removed"> 1334   }</span>
<span class="line-removed"> 1335   // Abort ratio calculation only if abort_count &gt; RTMAbortThreshold</span>
<span class="line-removed"> 1336   //   Aborted transactions = abort_count * 100</span>
<span class="line-removed"> 1337   //   All transactions = total_count *  RTMTotalCountIncrRate</span>
<span class="line-removed"> 1338   //   Set no_rtm bit if (Aborted transactions &gt;= All transactions * RTMAbortRatio)</span>
<span class="line-removed"> 1339 </span>
<span class="line-removed"> 1340   movptr(tmpReg, Address(rtm_counters_Reg, RTMLockingCounters::abort_count_offset()));</span>
<span class="line-removed"> 1341   cmpptr(tmpReg, RTMAbortThreshold);</span>
<span class="line-removed"> 1342   jccb(Assembler::below, L_check_always_rtm2);</span>
<span class="line-removed"> 1343   imulptr(tmpReg, tmpReg, 100);</span>
<span class="line-removed"> 1344 </span>
<span class="line-removed"> 1345   Register scrReg = rtm_counters_Reg;</span>
<span class="line-removed"> 1346   movptr(scrReg, Address(rtm_counters_Reg, RTMLockingCounters::total_count_offset()));</span>
<span class="line-removed"> 1347   imulptr(scrReg, scrReg, RTMTotalCountIncrRate);</span>
<span class="line-removed"> 1348   imulptr(scrReg, scrReg, RTMAbortRatio);</span>
<span class="line-removed"> 1349   cmpptr(tmpReg, scrReg);</span>
<span class="line-removed"> 1350   jccb(Assembler::below, L_check_always_rtm1);</span>
<span class="line-removed"> 1351   if (method_data != NULL) {</span>
<span class="line-removed"> 1352     // set rtm_state to &quot;no rtm&quot; in MDO</span>
<span class="line-removed"> 1353     mov_metadata(tmpReg, method_data);</span>
<span class="line-removed"> 1354     lock();</span>
<span class="line-removed"> 1355     orl(Address(tmpReg, MethodData::rtm_state_offset_in_bytes()), NoRTM);</span>
<span class="line-removed"> 1356   }</span>
<span class="line-removed"> 1357   jmpb(L_done);</span>
<span class="line-removed"> 1358   bind(L_check_always_rtm1);</span>
<span class="line-removed"> 1359   // Reload RTMLockingCounters* address</span>
<span class="line-removed"> 1360   lea(rtm_counters_Reg, ExternalAddress((address)rtm_counters));</span>
<span class="line-removed"> 1361   bind(L_check_always_rtm2);</span>
<span class="line-removed"> 1362   movptr(tmpReg, Address(rtm_counters_Reg, RTMLockingCounters::total_count_offset()));</span>
<span class="line-removed"> 1363   cmpptr(tmpReg, RTMLockingThreshold / RTMTotalCountIncrRate);</span>
<span class="line-removed"> 1364   jccb(Assembler::below, L_done);</span>
<span class="line-removed"> 1365   if (method_data != NULL) {</span>
<span class="line-removed"> 1366     // set rtm_state to &quot;always rtm&quot; in MDO</span>
<span class="line-removed"> 1367     mov_metadata(tmpReg, method_data);</span>
<span class="line-removed"> 1368     lock();</span>
<span class="line-removed"> 1369     orl(Address(tmpReg, MethodData::rtm_state_offset_in_bytes()), UseRTM);</span>
<span class="line-removed"> 1370   }</span>
<span class="line-removed"> 1371   bind(L_done);</span>
<span class="line-removed"> 1372 }</span>
<span class="line-removed"> 1373 </span>
<span class="line-removed"> 1374 // Update counters and perform abort ratio calculation</span>
<span class="line-removed"> 1375 // input:  abort_status_Reg</span>
<span class="line-removed"> 1376 // rtm_counters_Reg, flags are killed</span>
<span class="line-removed"> 1377 void MacroAssembler::rtm_profiling(Register abort_status_Reg,</span>
<span class="line-removed"> 1378                                    Register rtm_counters_Reg,</span>
<span class="line-removed"> 1379                                    RTMLockingCounters* rtm_counters,</span>
<span class="line-removed"> 1380                                    Metadata* method_data,</span>
<span class="line-removed"> 1381                                    bool profile_rtm) {</span>
<span class="line-removed"> 1382 </span>
<span class="line-removed"> 1383   assert(rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);</span>
<span class="line-removed"> 1384   // update rtm counters based on rax value at abort</span>
<span class="line-removed"> 1385   // reads abort_status_Reg, updates flags</span>
<span class="line-removed"> 1386   lea(rtm_counters_Reg, ExternalAddress((address)rtm_counters));</span>
<span class="line-removed"> 1387   rtm_counters_update(abort_status_Reg, rtm_counters_Reg);</span>
<span class="line-removed"> 1388   if (profile_rtm) {</span>
<span class="line-removed"> 1389     // Save abort status because abort_status_Reg is used by following code.</span>
<span class="line-removed"> 1390     if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed"> 1391       push(abort_status_Reg);</span>
<span class="line-removed"> 1392     }</span>
<span class="line-removed"> 1393     assert(rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);</span>
<span class="line-removed"> 1394     rtm_abort_ratio_calculation(abort_status_Reg, rtm_counters_Reg, rtm_counters, method_data);</span>
<span class="line-removed"> 1395     // restore abort status</span>
<span class="line-removed"> 1396     if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed"> 1397       pop(abort_status_Reg);</span>
<span class="line-removed"> 1398     }</span>
<span class="line-removed"> 1399   }</span>
<span class="line-removed"> 1400 }</span>
<span class="line-removed"> 1401 </span>
<span class="line-removed"> 1402 // Retry on abort if abort&#39;s status is 0x6: can retry (0x2) | memory conflict (0x4)</span>
<span class="line-removed"> 1403 // inputs: retry_count_Reg</span>
<span class="line-removed"> 1404 //       : abort_status_Reg</span>
<span class="line-removed"> 1405 // output: retry_count_Reg decremented by 1</span>
<span class="line-removed"> 1406 // flags are killed</span>
<span class="line-removed"> 1407 void MacroAssembler::rtm_retry_lock_on_abort(Register retry_count_Reg, Register abort_status_Reg, Label&amp; retryLabel) {</span>
<span class="line-removed"> 1408   Label doneRetry;</span>
<span class="line-removed"> 1409   assert(abort_status_Reg == rax, &quot;&quot;);</span>
<span class="line-removed"> 1410   // The abort reason bits are in eax (see all states in rtmLocking.hpp)</span>
<span class="line-removed"> 1411   // 0x6 = conflict on which we can retry (0x2) | memory conflict (0x4)</span>
<span class="line-removed"> 1412   // if reason is in 0x6 and retry count != 0 then retry</span>
<span class="line-removed"> 1413   andptr(abort_status_Reg, 0x6);</span>
<span class="line-removed"> 1414   jccb(Assembler::zero, doneRetry);</span>
<span class="line-removed"> 1415   testl(retry_count_Reg, retry_count_Reg);</span>
<span class="line-removed"> 1416   jccb(Assembler::zero, doneRetry);</span>
<span class="line-removed"> 1417   pause();</span>
<span class="line-removed"> 1418   decrementl(retry_count_Reg);</span>
<span class="line-removed"> 1419   jmp(retryLabel);</span>
<span class="line-removed"> 1420   bind(doneRetry);</span>
<span class="line-removed"> 1421 }</span>
<span class="line-removed"> 1422 </span>
<span class="line-removed"> 1423 // Spin and retry if lock is busy,</span>
<span class="line-removed"> 1424 // inputs: box_Reg (monitor address)</span>
<span class="line-removed"> 1425 //       : retry_count_Reg</span>
<span class="line-removed"> 1426 // output: retry_count_Reg decremented by 1</span>
<span class="line-removed"> 1427 //       : clear z flag if retry count exceeded</span>
<span class="line-removed"> 1428 // tmp_Reg, scr_Reg, flags are killed</span>
<span class="line-removed"> 1429 void MacroAssembler::rtm_retry_lock_on_busy(Register retry_count_Reg, Register box_Reg,</span>
<span class="line-removed"> 1430                                             Register tmp_Reg, Register scr_Reg, Label&amp; retryLabel) {</span>
<span class="line-removed"> 1431   Label SpinLoop, SpinExit, doneRetry;</span>
<span class="line-removed"> 1432   int owner_offset = OM_OFFSET_NO_MONITOR_VALUE_TAG(owner);</span>
<span class="line-removed"> 1433 </span>
<span class="line-removed"> 1434   testl(retry_count_Reg, retry_count_Reg);</span>
<span class="line-removed"> 1435   jccb(Assembler::zero, doneRetry);</span>
<span class="line-removed"> 1436   decrementl(retry_count_Reg);</span>
<span class="line-removed"> 1437   movptr(scr_Reg, RTMSpinLoopCount);</span>
<span class="line-removed"> 1438 </span>
<span class="line-removed"> 1439   bind(SpinLoop);</span>
<span class="line-removed"> 1440   pause();</span>
<span class="line-removed"> 1441   decrementl(scr_Reg);</span>
<span class="line-removed"> 1442   jccb(Assembler::lessEqual, SpinExit);</span>
<span class="line-removed"> 1443   movptr(tmp_Reg, Address(box_Reg, owner_offset));</span>
<span class="line-removed"> 1444   testptr(tmp_Reg, tmp_Reg);</span>
<span class="line-removed"> 1445   jccb(Assembler::notZero, SpinLoop);</span>
<span class="line-removed"> 1446 </span>
<span class="line-removed"> 1447   bind(SpinExit);</span>
<span class="line-removed"> 1448   jmp(retryLabel);</span>
<span class="line-removed"> 1449   bind(doneRetry);</span>
<span class="line-removed"> 1450   incrementl(retry_count_Reg); // clear z flag</span>
<span class="line-removed"> 1451 }</span>
<span class="line-removed"> 1452 </span>
<span class="line-removed"> 1453 // Use RTM for normal stack locks</span>
<span class="line-removed"> 1454 // Input: objReg (object to lock)</span>
<span class="line-removed"> 1455 void MacroAssembler::rtm_stack_locking(Register objReg, Register tmpReg, Register scrReg,</span>
<span class="line-removed"> 1456                                        Register retry_on_abort_count_Reg,</span>
<span class="line-removed"> 1457                                        RTMLockingCounters* stack_rtm_counters,</span>
<span class="line-removed"> 1458                                        Metadata* method_data, bool profile_rtm,</span>
<span class="line-removed"> 1459                                        Label&amp; DONE_LABEL, Label&amp; IsInflated) {</span>
<span class="line-removed"> 1460   assert(UseRTMForStackLocks, &quot;why call this otherwise?&quot;);</span>
<span class="line-removed"> 1461   assert(!UseBiasedLocking, &quot;Biased locking is not supported with RTM locking&quot;);</span>
<span class="line-removed"> 1462   assert(tmpReg == rax, &quot;&quot;);</span>
<span class="line-removed"> 1463   assert(scrReg == rdx, &quot;&quot;);</span>
<span class="line-removed"> 1464   Label L_rtm_retry, L_decrement_retry, L_on_abort;</span>
<span class="line-removed"> 1465 </span>
<span class="line-removed"> 1466   if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed"> 1467     movl(retry_on_abort_count_Reg, RTMRetryCount); // Retry on abort</span>
<span class="line-removed"> 1468     bind(L_rtm_retry);</span>
<span class="line-removed"> 1469   }</span>
<span class="line-removed"> 1470   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-removed"> 1471   testptr(tmpReg, markWord::monitor_value);  // inflated vs stack-locked|neutral|biased</span>
<span class="line-removed"> 1472   jcc(Assembler::notZero, IsInflated);</span>
<span class="line-removed"> 1473 </span>
<span class="line-removed"> 1474   if (PrintPreciseRTMLockingStatistics || profile_rtm) {</span>
<span class="line-removed"> 1475     Label L_noincrement;</span>
<span class="line-removed"> 1476     if (RTMTotalCountIncrRate &gt; 1) {</span>
<span class="line-removed"> 1477       // tmpReg, scrReg and flags are killed</span>
<span class="line-removed"> 1478       branch_on_random_using_rdtsc(tmpReg, scrReg, RTMTotalCountIncrRate, L_noincrement);</span>
<span class="line-removed"> 1479     }</span>
<span class="line-removed"> 1480     assert(stack_rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);</span>
<span class="line-removed"> 1481     atomic_incptr(ExternalAddress((address)stack_rtm_counters-&gt;total_count_addr()), scrReg);</span>
<span class="line-removed"> 1482     bind(L_noincrement);</span>
<span class="line-removed"> 1483   }</span>
<span class="line-removed"> 1484   xbegin(L_on_abort);</span>
<span class="line-removed"> 1485   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));       // fetch markword</span>
<span class="line-removed"> 1486   andptr(tmpReg, markWord::biased_lock_mask_in_place); // look at 3 lock bits</span>
<span class="line-removed"> 1487   cmpptr(tmpReg, markWord::unlocked_value);            // bits = 001 unlocked</span>
<span class="line-removed"> 1488   jcc(Assembler::equal, DONE_LABEL);        // all done if unlocked</span>
<span class="line-removed"> 1489 </span>
<span class="line-removed"> 1490   Register abort_status_Reg = tmpReg; // status of abort is stored in RAX</span>
<span class="line-removed"> 1491   if (UseRTMXendForLockBusy) {</span>
<span class="line-removed"> 1492     xend();</span>
<span class="line-removed"> 1493     movptr(abort_status_Reg, 0x2);   // Set the abort status to 2 (so we can retry)</span>
<span class="line-removed"> 1494     jmp(L_decrement_retry);</span>
<span class="line-removed"> 1495   }</span>
<span class="line-removed"> 1496   else {</span>
<span class="line-removed"> 1497     xabort(0);</span>
<span class="line-removed"> 1498   }</span>
<span class="line-removed"> 1499   bind(L_on_abort);</span>
<span class="line-removed"> 1500   if (PrintPreciseRTMLockingStatistics || profile_rtm) {</span>
<span class="line-removed"> 1501     rtm_profiling(abort_status_Reg, scrReg, stack_rtm_counters, method_data, profile_rtm);</span>
<span class="line-removed"> 1502   }</span>
<span class="line-removed"> 1503   bind(L_decrement_retry);</span>
<span class="line-removed"> 1504   if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed"> 1505     // retry on lock abort if abort status is &#39;can retry&#39; (0x2) or &#39;memory conflict&#39; (0x4)</span>
<span class="line-removed"> 1506     rtm_retry_lock_on_abort(retry_on_abort_count_Reg, abort_status_Reg, L_rtm_retry);</span>
<span class="line-removed"> 1507   }</span>
<span class="line-removed"> 1508 }</span>
<span class="line-removed"> 1509 </span>
<span class="line-removed"> 1510 // Use RTM for inflating locks</span>
<span class="line-removed"> 1511 // inputs: objReg (object to lock)</span>
<span class="line-removed"> 1512 //         boxReg (on-stack box address (displaced header location) - KILLED)</span>
<span class="line-removed"> 1513 //         tmpReg (ObjectMonitor address + markWord::monitor_value)</span>
<span class="line-removed"> 1514 void MacroAssembler::rtm_inflated_locking(Register objReg, Register boxReg, Register tmpReg,</span>
<span class="line-removed"> 1515                                           Register scrReg, Register retry_on_busy_count_Reg,</span>
<span class="line-removed"> 1516                                           Register retry_on_abort_count_Reg,</span>
<span class="line-removed"> 1517                                           RTMLockingCounters* rtm_counters,</span>
<span class="line-removed"> 1518                                           Metadata* method_data, bool profile_rtm,</span>
<span class="line-removed"> 1519                                           Label&amp; DONE_LABEL) {</span>
<span class="line-removed"> 1520   assert(UseRTMLocking, &quot;why call this otherwise?&quot;);</span>
<span class="line-removed"> 1521   assert(tmpReg == rax, &quot;&quot;);</span>
<span class="line-removed"> 1522   assert(scrReg == rdx, &quot;&quot;);</span>
<span class="line-removed"> 1523   Label L_rtm_retry, L_decrement_retry, L_on_abort;</span>
<span class="line-removed"> 1524   int owner_offset = OM_OFFSET_NO_MONITOR_VALUE_TAG(owner);</span>
<span class="line-removed"> 1525 </span>
<span class="line-removed"> 1526   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.</span>
<span class="line-removed"> 1527   movptr(Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));</span>
<span class="line-removed"> 1528   movptr(boxReg, tmpReg); // Save ObjectMonitor address</span>
<span class="line-removed"> 1529 </span>
<span class="line-removed"> 1530   if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed"> 1531     movl(retry_on_busy_count_Reg, RTMRetryCount);  // Retry on lock busy</span>
<span class="line-removed"> 1532     movl(retry_on_abort_count_Reg, RTMRetryCount); // Retry on abort</span>
<span class="line-removed"> 1533     bind(L_rtm_retry);</span>
<span class="line-removed"> 1534   }</span>
<span class="line-removed"> 1535   if (PrintPreciseRTMLockingStatistics || profile_rtm) {</span>
<span class="line-removed"> 1536     Label L_noincrement;</span>
<span class="line-removed"> 1537     if (RTMTotalCountIncrRate &gt; 1) {</span>
<span class="line-removed"> 1538       // tmpReg, scrReg and flags are killed</span>
<span class="line-removed"> 1539       branch_on_random_using_rdtsc(tmpReg, scrReg, RTMTotalCountIncrRate, L_noincrement);</span>
<span class="line-removed"> 1540     }</span>
<span class="line-removed"> 1541     assert(rtm_counters != NULL, &quot;should not be NULL when profiling RTM&quot;);</span>
<span class="line-removed"> 1542     atomic_incptr(ExternalAddress((address)rtm_counters-&gt;total_count_addr()), scrReg);</span>
<span class="line-removed"> 1543     bind(L_noincrement);</span>
<span class="line-removed"> 1544   }</span>
<span class="line-removed"> 1545   xbegin(L_on_abort);</span>
<span class="line-removed"> 1546   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-removed"> 1547   movptr(tmpReg, Address(tmpReg, owner_offset));</span>
<span class="line-removed"> 1548   testptr(tmpReg, tmpReg);</span>
<span class="line-removed"> 1549   jcc(Assembler::zero, DONE_LABEL);</span>
<span class="line-removed"> 1550   if (UseRTMXendForLockBusy) {</span>
<span class="line-removed"> 1551     xend();</span>
<span class="line-removed"> 1552     jmp(L_decrement_retry);</span>
<span class="line-removed"> 1553   }</span>
<span class="line-removed"> 1554   else {</span>
<span class="line-removed"> 1555     xabort(0);</span>
<span class="line-removed"> 1556   }</span>
<span class="line-removed"> 1557   bind(L_on_abort);</span>
<span class="line-removed"> 1558   Register abort_status_Reg = tmpReg; // status of abort is stored in RAX</span>
<span class="line-removed"> 1559   if (PrintPreciseRTMLockingStatistics || profile_rtm) {</span>
<span class="line-removed"> 1560     rtm_profiling(abort_status_Reg, scrReg, rtm_counters, method_data, profile_rtm);</span>
<span class="line-removed"> 1561   }</span>
<span class="line-removed"> 1562   if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed"> 1563     // retry on lock abort if abort status is &#39;can retry&#39; (0x2) or &#39;memory conflict&#39; (0x4)</span>
<span class="line-removed"> 1564     rtm_retry_lock_on_abort(retry_on_abort_count_Reg, abort_status_Reg, L_rtm_retry);</span>
<span class="line-removed"> 1565   }</span>
<span class="line-removed"> 1566 </span>
<span class="line-removed"> 1567   movptr(tmpReg, Address(boxReg, owner_offset)) ;</span>
<span class="line-removed"> 1568   testptr(tmpReg, tmpReg) ;</span>
<span class="line-removed"> 1569   jccb(Assembler::notZero, L_decrement_retry) ;</span>
<span class="line-removed"> 1570 </span>
<span class="line-removed"> 1571   // Appears unlocked - try to swing _owner from null to non-null.</span>
<span class="line-removed"> 1572   // Invariant: tmpReg == 0.  tmpReg is EAX which is the implicit cmpxchg comparand.</span>
<span class="line-removed"> 1573 #ifdef _LP64</span>
<span class="line-removed"> 1574   Register threadReg = r15_thread;</span>
<span class="line-removed"> 1575 #else</span>
<span class="line-removed"> 1576   get_thread(scrReg);</span>
<span class="line-removed"> 1577   Register threadReg = scrReg;</span>
<span class="line-removed"> 1578 #endif</span>
<span class="line-removed"> 1579   lock();</span>
<span class="line-removed"> 1580   cmpxchgptr(threadReg, Address(boxReg, owner_offset)); // Updates tmpReg</span>
<span class="line-removed"> 1581 </span>
<span class="line-removed"> 1582   if (RTMRetryCount &gt; 0) {</span>
<span class="line-removed"> 1583     // success done else retry</span>
<span class="line-removed"> 1584     jccb(Assembler::equal, DONE_LABEL) ;</span>
<span class="line-removed"> 1585     bind(L_decrement_retry);</span>
<span class="line-removed"> 1586     // Spin and retry if lock is busy.</span>
<span class="line-removed"> 1587     rtm_retry_lock_on_busy(retry_on_busy_count_Reg, boxReg, tmpReg, scrReg, L_rtm_retry);</span>
<span class="line-removed"> 1588   }</span>
<span class="line-removed"> 1589   else {</span>
<span class="line-removed"> 1590     bind(L_decrement_retry);</span>
<span class="line-removed"> 1591   }</span>
<span class="line-removed"> 1592 }</span>
<span class="line-removed"> 1593 </span>
<span class="line-removed"> 1594 #endif //  INCLUDE_RTM_OPT</span>
<span class="line-removed"> 1595 </span>
<span class="line-removed"> 1596 // fast_lock and fast_unlock used by C2</span>
<span class="line-removed"> 1597 </span>
<span class="line-removed"> 1598 // Because the transitions from emitted code to the runtime</span>
<span class="line-removed"> 1599 // monitorenter/exit helper stubs are so slow it&#39;s critical that</span>
<span class="line-removed"> 1600 // we inline both the stack-locking fast path and the inflated fast path.</span>
<span class="line-removed"> 1601 //</span>
<span class="line-removed"> 1602 // See also: cmpFastLock and cmpFastUnlock.</span>
<span class="line-removed"> 1603 //</span>
<span class="line-removed"> 1604 // What follows is a specialized inline transliteration of the code</span>
<span class="line-removed"> 1605 // in enter() and exit(). If we&#39;re concerned about I$ bloat another</span>
<span class="line-removed"> 1606 // option would be to emit TrySlowEnter and TrySlowExit methods</span>
<span class="line-removed"> 1607 // at startup-time.  These methods would accept arguments as</span>
<span class="line-removed"> 1608 // (rax,=Obj, rbx=Self, rcx=box, rdx=Scratch) and return success-failure</span>
<span class="line-removed"> 1609 // indications in the icc.ZFlag.  fast_lock and fast_unlock would simply</span>
<span class="line-removed"> 1610 // marshal the arguments and emit calls to TrySlowEnter and TrySlowExit.</span>
<span class="line-removed"> 1611 // In practice, however, the # of lock sites is bounded and is usually small.</span>
<span class="line-removed"> 1612 // Besides the call overhead, TrySlowEnter and TrySlowExit might suffer</span>
<span class="line-removed"> 1613 // if the processor uses simple bimodal branch predictors keyed by EIP</span>
<span class="line-removed"> 1614 // Since the helper routines would be called from multiple synchronization</span>
<span class="line-removed"> 1615 // sites.</span>
<span class="line-removed"> 1616 //</span>
<span class="line-removed"> 1617 // An even better approach would be write &quot;MonitorEnter()&quot; and &quot;MonitorExit()&quot;</span>
<span class="line-removed"> 1618 // in java - using j.u.c and unsafe - and just bind the lock and unlock sites</span>
<span class="line-removed"> 1619 // to those specialized methods.  That&#39;d give us a mostly platform-independent</span>
<span class="line-removed"> 1620 // implementation that the JITs could optimize and inline at their pleasure.</span>
<span class="line-removed"> 1621 // Done correctly, the only time we&#39;d need to cross to native could would be</span>
<span class="line-removed"> 1622 // to park() or unpark() threads.  We&#39;d also need a few more unsafe operators</span>
<span class="line-removed"> 1623 // to (a) prevent compiler-JIT reordering of non-volatile accesses, and</span>
<span class="line-removed"> 1624 // (b) explicit barriers or fence operations.</span>
<span class="line-removed"> 1625 //</span>
<span class="line-removed"> 1626 // TODO:</span>
<span class="line-removed"> 1627 //</span>
<span class="line-removed"> 1628 // *  Arrange for C2 to pass &quot;Self&quot; into fast_lock and fast_unlock in one of the registers (scr).</span>
<span class="line-removed"> 1629 //    This avoids manifesting the Self pointer in the fast_lock and fast_unlock terminals.</span>
<span class="line-removed"> 1630 //    Given TLAB allocation, Self is usually manifested in a register, so passing it into</span>
<span class="line-removed"> 1631 //    the lock operators would typically be faster than reifying Self.</span>
<span class="line-removed"> 1632 //</span>
<span class="line-removed"> 1633 // *  Ideally I&#39;d define the primitives as:</span>
<span class="line-removed"> 1634 //       fast_lock   (nax Obj, nax box, EAX tmp, nax scr) where box, tmp and scr are KILLED.</span>
<span class="line-removed"> 1635 //       fast_unlock (nax Obj, EAX box, nax tmp) where box and tmp are KILLED</span>
<span class="line-removed"> 1636 //    Unfortunately ADLC bugs prevent us from expressing the ideal form.</span>
<span class="line-removed"> 1637 //    Instead, we&#39;re stuck with a rather awkward and brittle register assignments below.</span>
<span class="line-removed"> 1638 //    Furthermore the register assignments are overconstrained, possibly resulting in</span>
<span class="line-removed"> 1639 //    sub-optimal code near the synchronization site.</span>
<span class="line-removed"> 1640 //</span>
<span class="line-removed"> 1641 // *  Eliminate the sp-proximity tests and just use &quot;== Self&quot; tests instead.</span>
<span class="line-removed"> 1642 //    Alternately, use a better sp-proximity test.</span>
<span class="line-removed"> 1643 //</span>
<span class="line-removed"> 1644 // *  Currently ObjectMonitor._Owner can hold either an sp value or a (THREAD *) value.</span>
<span class="line-removed"> 1645 //    Either one is sufficient to uniquely identify a thread.</span>
<span class="line-removed"> 1646 //    TODO: eliminate use of sp in _owner and use get_thread(tr) instead.</span>
<span class="line-removed"> 1647 //</span>
<span class="line-removed"> 1648 // *  Intrinsify notify() and notifyAll() for the common cases where the</span>
<span class="line-removed"> 1649 //    object is locked by the calling thread but the waitlist is empty.</span>
<span class="line-removed"> 1650 //    avoid the expensive JNI call to JVM_Notify() and JVM_NotifyAll().</span>
<span class="line-removed"> 1651 //</span>
<span class="line-removed"> 1652 // *  use jccb and jmpb instead of jcc and jmp to improve code density.</span>
<span class="line-removed"> 1653 //    But beware of excessive branch density on AMD Opterons.</span>
<span class="line-removed"> 1654 //</span>
<span class="line-removed"> 1655 // *  Both fast_lock and fast_unlock set the ICC.ZF to indicate success</span>
<span class="line-removed"> 1656 //    or failure of the fast path.  If the fast path fails then we pass</span>
<span class="line-removed"> 1657 //    control to the slow path, typically in C.  In fast_lock and</span>
<span class="line-removed"> 1658 //    fast_unlock we often branch to DONE_LABEL, just to find that C2</span>
<span class="line-removed"> 1659 //    will emit a conditional branch immediately after the node.</span>
<span class="line-removed"> 1660 //    So we have branches to branches and lots of ICC.ZF games.</span>
<span class="line-removed"> 1661 //    Instead, it might be better to have C2 pass a &quot;FailureLabel&quot;</span>
<span class="line-removed"> 1662 //    into fast_lock and fast_unlock.  In the case of success, control</span>
<span class="line-removed"> 1663 //    will drop through the node.  ICC.ZF is undefined at exit.</span>
<span class="line-removed"> 1664 //    In the case of failure, the node will branch directly to the</span>
<span class="line-removed"> 1665 //    FailureLabel</span>
<span class="line-removed"> 1666 </span>
<span class="line-removed"> 1667 </span>
<span class="line-removed"> 1668 // obj: object to lock</span>
<span class="line-removed"> 1669 // box: on-stack box address (displaced header location) - KILLED</span>
<span class="line-removed"> 1670 // rax,: tmp -- KILLED</span>
<span class="line-removed"> 1671 // scr: tmp -- KILLED</span>
<span class="line-removed"> 1672 void MacroAssembler::fast_lock(Register objReg, Register boxReg, Register tmpReg,</span>
<span class="line-removed"> 1673                                Register scrReg, Register cx1Reg, Register cx2Reg,</span>
<span class="line-removed"> 1674                                BiasedLockingCounters* counters,</span>
<span class="line-removed"> 1675                                RTMLockingCounters* rtm_counters,</span>
<span class="line-removed"> 1676                                RTMLockingCounters* stack_rtm_counters,</span>
<span class="line-removed"> 1677                                Metadata* method_data,</span>
<span class="line-removed"> 1678                                bool use_rtm, bool profile_rtm) {</span>
<span class="line-removed"> 1679   // Ensure the register assignments are disjoint</span>
<span class="line-removed"> 1680   assert(tmpReg == rax, &quot;&quot;);</span>
<span class="line-removed"> 1681 </span>
<span class="line-removed"> 1682   if (use_rtm) {</span>
<span class="line-removed"> 1683     assert_different_registers(objReg, boxReg, tmpReg, scrReg, cx1Reg, cx2Reg);</span>
<span class="line-removed"> 1684   } else {</span>
<span class="line-removed"> 1685     assert(cx1Reg == noreg, &quot;&quot;);</span>
<span class="line-removed"> 1686     assert(cx2Reg == noreg, &quot;&quot;);</span>
<span class="line-removed"> 1687     assert_different_registers(objReg, boxReg, tmpReg, scrReg);</span>
<span class="line-removed"> 1688   }</span>
<span class="line-removed"> 1689 </span>
<span class="line-removed"> 1690   if (counters != NULL) {</span>
<span class="line-removed"> 1691     atomic_incl(ExternalAddress((address)counters-&gt;total_entry_count_addr()), scrReg);</span>
<span class="line-removed"> 1692   }</span>
<span class="line-removed"> 1693 </span>
<span class="line-removed"> 1694   // Possible cases that we&#39;ll encounter in fast_lock</span>
<span class="line-removed"> 1695   // ------------------------------------------------</span>
<span class="line-removed"> 1696   // * Inflated</span>
<span class="line-removed"> 1697   //    -- unlocked</span>
<span class="line-removed"> 1698   //    -- Locked</span>
<span class="line-removed"> 1699   //       = by self</span>
<span class="line-removed"> 1700   //       = by other</span>
<span class="line-removed"> 1701   // * biased</span>
<span class="line-removed"> 1702   //    -- by Self</span>
<span class="line-removed"> 1703   //    -- by other</span>
<span class="line-removed"> 1704   // * neutral</span>
<span class="line-removed"> 1705   // * stack-locked</span>
<span class="line-removed"> 1706   //    -- by self</span>
<span class="line-removed"> 1707   //       = sp-proximity test hits</span>
<span class="line-removed"> 1708   //       = sp-proximity test generates false-negative</span>
<span class="line-removed"> 1709   //    -- by other</span>
<span class="line-removed"> 1710   //</span>
<span class="line-removed"> 1711 </span>
<span class="line-removed"> 1712   Label IsInflated, DONE_LABEL;</span>
<span class="line-removed"> 1713 </span>
<span class="line-removed"> 1714   // it&#39;s stack-locked, biased or neutral</span>
<span class="line-removed"> 1715   // TODO: optimize away redundant LDs of obj-&gt;mark and improve the markword triage</span>
<span class="line-removed"> 1716   // order to reduce the number of conditional branches in the most common cases.</span>
<span class="line-removed"> 1717   // Beware -- there&#39;s a subtle invariant that fetch of the markword</span>
<span class="line-removed"> 1718   // at [FETCH], below, will never observe a biased encoding (*101b).</span>
<span class="line-removed"> 1719   // If this invariant is not held we risk exclusion (safety) failure.</span>
<span class="line-removed"> 1720   if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {</span>
<span class="line-removed"> 1721     biased_locking_enter(boxReg, objReg, tmpReg, scrReg, false, DONE_LABEL, NULL, counters);</span>
<span class="line-removed"> 1722   }</span>
<span class="line-removed"> 1723 </span>
<span class="line-removed"> 1724 #if INCLUDE_RTM_OPT</span>
<span class="line-removed"> 1725   if (UseRTMForStackLocks &amp;&amp; use_rtm) {</span>
<span class="line-removed"> 1726     rtm_stack_locking(objReg, tmpReg, scrReg, cx2Reg,</span>
<span class="line-removed"> 1727                       stack_rtm_counters, method_data, profile_rtm,</span>
<span class="line-removed"> 1728                       DONE_LABEL, IsInflated);</span>
<span class="line-removed"> 1729   }</span>
<span class="line-removed"> 1730 #endif // INCLUDE_RTM_OPT</span>
<span class="line-removed"> 1731 </span>
<span class="line-removed"> 1732   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));          // [FETCH]</span>
<span class="line-removed"> 1733   testptr(tmpReg, markWord::monitor_value); // inflated vs stack-locked|neutral|biased</span>
<span class="line-removed"> 1734   jccb(Assembler::notZero, IsInflated);</span>
<span class="line-removed"> 1735 </span>
<span class="line-removed"> 1736   // Attempt stack-locking ...</span>
<span class="line-removed"> 1737   orptr (tmpReg, markWord::unlocked_value);</span>
<span class="line-removed"> 1738   if (EnableValhalla &amp;&amp; !UseBiasedLocking) {</span>
<span class="line-removed"> 1739     // Mask always_locked bit such that we go to the slow path if object is a value type</span>
<span class="line-removed"> 1740     andptr(tmpReg, ~((int) markWord::biased_lock_bit_in_place));</span>
<span class="line-removed"> 1741   }</span>
<span class="line-removed"> 1742   movptr(Address(boxReg, 0), tmpReg);          // Anticipate successful CAS</span>
<span class="line-removed"> 1743   lock();</span>
<span class="line-removed"> 1744   cmpxchgptr(boxReg, Address(objReg, oopDesc::mark_offset_in_bytes()));      // Updates tmpReg</span>
<span class="line-removed"> 1745   if (counters != NULL) {</span>
<span class="line-removed"> 1746     cond_inc32(Assembler::equal,</span>
<span class="line-removed"> 1747                ExternalAddress((address)counters-&gt;fast_path_entry_count_addr()));</span>
<span class="line-removed"> 1748   }</span>
<span class="line-removed"> 1749   jcc(Assembler::equal, DONE_LABEL);           // Success</span>
<span class="line-removed"> 1750 </span>
<span class="line-removed"> 1751   // Recursive locking.</span>
<span class="line-removed"> 1752   // The object is stack-locked: markword contains stack pointer to BasicLock.</span>
<span class="line-removed"> 1753   // Locked by current thread if difference with current SP is less than one page.</span>
<span class="line-removed"> 1754   subptr(tmpReg, rsp);</span>
<span class="line-removed"> 1755   // Next instruction set ZFlag == 1 (Success) if difference is less then one page.</span>
<span class="line-removed"> 1756   andptr(tmpReg, (int32_t) (NOT_LP64(0xFFFFF003) LP64_ONLY(7 - os::vm_page_size())) );</span>
<span class="line-removed"> 1757   movptr(Address(boxReg, 0), tmpReg);</span>
<span class="line-removed"> 1758   if (counters != NULL) {</span>
<span class="line-removed"> 1759     cond_inc32(Assembler::equal,</span>
<span class="line-removed"> 1760                ExternalAddress((address)counters-&gt;fast_path_entry_count_addr()));</span>
<span class="line-removed"> 1761   }</span>
<span class="line-removed"> 1762   jmp(DONE_LABEL);</span>
<span class="line-removed"> 1763 </span>
<span class="line-removed"> 1764   bind(IsInflated);</span>
<span class="line-removed"> 1765   // The object is inflated. tmpReg contains pointer to ObjectMonitor* + markWord::monitor_value</span>
<span class="line-removed"> 1766 </span>
<span class="line-removed"> 1767 #if INCLUDE_RTM_OPT</span>
<span class="line-removed"> 1768   // Use the same RTM locking code in 32- and 64-bit VM.</span>
<span class="line-removed"> 1769   if (use_rtm) {</span>
<span class="line-removed"> 1770     rtm_inflated_locking(objReg, boxReg, tmpReg, scrReg, cx1Reg, cx2Reg,</span>
<span class="line-removed"> 1771                          rtm_counters, method_data, profile_rtm, DONE_LABEL);</span>
<span class="line-removed"> 1772   } else {</span>
<span class="line-removed"> 1773 #endif // INCLUDE_RTM_OPT</span>
<span class="line-removed"> 1774 </span>
<span class="line-removed"> 1775 #ifndef _LP64</span>
<span class="line-removed"> 1776   // The object is inflated.</span>
<span class="line-removed"> 1777 </span>
<span class="line-removed"> 1778   // boxReg refers to the on-stack BasicLock in the current frame.</span>
<span class="line-removed"> 1779   // We&#39;d like to write:</span>
<span class="line-removed"> 1780   //   set box-&gt;_displaced_header = markWord::unused_mark().  Any non-0 value suffices.</span>
<span class="line-removed"> 1781   // This is convenient but results a ST-before-CAS penalty.  The following CAS suffers</span>
<span class="line-removed"> 1782   // additional latency as we have another ST in the store buffer that must drain.</span>
<span class="line-removed"> 1783 </span>
<span class="line-removed"> 1784   // avoid ST-before-CAS</span>
<span class="line-removed"> 1785   // register juggle because we need tmpReg for cmpxchgptr below</span>
<span class="line-removed"> 1786   movptr(scrReg, boxReg);</span>
<span class="line-removed"> 1787   movptr(boxReg, tmpReg);                   // consider: LEA box, [tmp-2]</span>
<span class="line-removed"> 1788 </span>
<span class="line-removed"> 1789   // Optimistic form: consider XORL tmpReg,tmpReg</span>
<span class="line-removed"> 1790   movptr(tmpReg, NULL_WORD);</span>
<span class="line-removed"> 1791 </span>
<span class="line-removed"> 1792   // Appears unlocked - try to swing _owner from null to non-null.</span>
<span class="line-removed"> 1793   // Ideally, I&#39;d manifest &quot;Self&quot; with get_thread and then attempt</span>
<span class="line-removed"> 1794   // to CAS the register containing Self into m-&gt;Owner.</span>
<span class="line-removed"> 1795   // But we don&#39;t have enough registers, so instead we can either try to CAS</span>
<span class="line-removed"> 1796   // rsp or the address of the box (in scr) into &amp;m-&gt;owner.  If the CAS succeeds</span>
<span class="line-removed"> 1797   // we later store &quot;Self&quot; into m-&gt;Owner.  Transiently storing a stack address</span>
<span class="line-removed"> 1798   // (rsp or the address of the box) into  m-&gt;owner is harmless.</span>
<span class="line-removed"> 1799   // Invariant: tmpReg == 0.  tmpReg is EAX which is the implicit cmpxchg comparand.</span>
<span class="line-removed"> 1800   lock();</span>
<span class="line-removed"> 1801   cmpxchgptr(scrReg, Address(boxReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));</span>
<span class="line-removed"> 1802   movptr(Address(scrReg, 0), 3);          // box-&gt;_displaced_header = 3</span>
<span class="line-removed"> 1803   // If we weren&#39;t able to swing _owner from NULL to the BasicLock</span>
<span class="line-removed"> 1804   // then take the slow path.</span>
<span class="line-removed"> 1805   jccb  (Assembler::notZero, DONE_LABEL);</span>
<span class="line-removed"> 1806   // update _owner from BasicLock to thread</span>
<span class="line-removed"> 1807   get_thread (scrReg);                    // beware: clobbers ICCs</span>
<span class="line-removed"> 1808   movptr(Address(boxReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), scrReg);</span>
<span class="line-removed"> 1809   xorptr(boxReg, boxReg);                 // set icc.ZFlag = 1 to indicate success</span>
<span class="line-removed"> 1810 </span>
<span class="line-removed"> 1811   // If the CAS fails we can either retry or pass control to the slow path.</span>
<span class="line-removed"> 1812   // We use the latter tactic.</span>
<span class="line-removed"> 1813   // Pass the CAS result in the icc.ZFlag into DONE_LABEL</span>
<span class="line-removed"> 1814   // If the CAS was successful ...</span>
<span class="line-removed"> 1815   //   Self has acquired the lock</span>
<span class="line-removed"> 1816   //   Invariant: m-&gt;_recursions should already be 0, so we don&#39;t need to explicitly set it.</span>
<span class="line-removed"> 1817   // Intentional fall-through into DONE_LABEL ...</span>
<span class="line-removed"> 1818 #else // _LP64</span>
<span class="line-removed"> 1819   // It&#39;s inflated and we use scrReg for ObjectMonitor* in this section.</span>
<span class="line-removed"> 1820   movq(scrReg, tmpReg);</span>
<span class="line-removed"> 1821   xorq(tmpReg, tmpReg);</span>
<span class="line-removed"> 1822   lock();</span>
<span class="line-removed"> 1823   cmpxchgptr(r15_thread, Address(scrReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));</span>
<span class="line-removed"> 1824   // Unconditionally set box-&gt;_displaced_header = markWord::unused_mark().</span>
<span class="line-removed"> 1825   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.</span>
<span class="line-removed"> 1826   movptr(Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));</span>
<span class="line-removed"> 1827   // Intentional fall-through into DONE_LABEL ...</span>
<span class="line-removed"> 1828   // Propagate ICC.ZF from CAS above into DONE_LABEL.</span>
<span class="line-removed"> 1829 #endif // _LP64</span>
<span class="line-removed"> 1830 #if INCLUDE_RTM_OPT</span>
<span class="line-removed"> 1831   } // use_rtm()</span>
<span class="line-removed"> 1832 #endif</span>
<span class="line-removed"> 1833   // DONE_LABEL is a hot target - we&#39;d really like to place it at the</span>
<span class="line-removed"> 1834   // start of cache line by padding with NOPs.</span>
<span class="line-removed"> 1835   // See the AMD and Intel software optimization manuals for the</span>
<span class="line-removed"> 1836   // most efficient &quot;long&quot; NOP encodings.</span>
<span class="line-removed"> 1837   // Unfortunately none of our alignment mechanisms suffice.</span>
<span class="line-removed"> 1838   bind(DONE_LABEL);</span>
<span class="line-removed"> 1839 </span>
<span class="line-removed"> 1840   // At DONE_LABEL the icc ZFlag is set as follows ...</span>
<span class="line-removed"> 1841   // fast_unlock uses the same protocol.</span>
<span class="line-removed"> 1842   // ZFlag == 1 -&gt; Success</span>
<span class="line-removed"> 1843   // ZFlag == 0 -&gt; Failure - force control through the slow path</span>
<span class="line-removed"> 1844 }</span>
<span class="line-removed"> 1845 </span>
<span class="line-removed"> 1846 // obj: object to unlock</span>
<span class="line-removed"> 1847 // box: box address (displaced header location), killed.  Must be EAX.</span>
<span class="line-removed"> 1848 // tmp: killed, cannot be obj nor box.</span>
<span class="line-removed"> 1849 //</span>
<span class="line-removed"> 1850 // Some commentary on balanced locking:</span>
<span class="line-removed"> 1851 //</span>
<span class="line-removed"> 1852 // fast_lock and fast_unlock are emitted only for provably balanced lock sites.</span>
<span class="line-removed"> 1853 // Methods that don&#39;t have provably balanced locking are forced to run in the</span>
<span class="line-removed"> 1854 // interpreter - such methods won&#39;t be compiled to use fast_lock and fast_unlock.</span>
<span class="line-removed"> 1855 // The interpreter provides two properties:</span>
<span class="line-removed"> 1856 // I1:  At return-time the interpreter automatically and quietly unlocks any</span>
<span class="line-removed"> 1857 //      objects acquired the current activation (frame).  Recall that the</span>
<span class="line-removed"> 1858 //      interpreter maintains an on-stack list of locks currently held by</span>
<span class="line-removed"> 1859 //      a frame.</span>
<span class="line-removed"> 1860 // I2:  If a method attempts to unlock an object that is not held by the</span>
<span class="line-removed"> 1861 //      the frame the interpreter throws IMSX.</span>
<span class="line-removed"> 1862 //</span>
<span class="line-removed"> 1863 // Lets say A(), which has provably balanced locking, acquires O and then calls B().</span>
<span class="line-removed"> 1864 // B() doesn&#39;t have provably balanced locking so it runs in the interpreter.</span>
<span class="line-removed"> 1865 // Control returns to A() and A() unlocks O.  By I1 and I2, above, we know that O</span>
<span class="line-removed"> 1866 // is still locked by A().</span>
<span class="line-removed"> 1867 //</span>
<span class="line-removed"> 1868 // The only other source of unbalanced locking would be JNI.  The &quot;Java Native Interface:</span>
<span class="line-removed"> 1869 // Programmer&#39;s Guide and Specification&quot; claims that an object locked by jni_monitorenter</span>
<span class="line-removed"> 1870 // should not be unlocked by &quot;normal&quot; java-level locking and vice-versa.  The specification</span>
<span class="line-removed"> 1871 // doesn&#39;t specify what will occur if a program engages in such mixed-mode locking, however.</span>
<span class="line-removed"> 1872 // Arguably given that the spec legislates the JNI case as undefined our implementation</span>
<span class="line-removed"> 1873 // could reasonably *avoid* checking owner in fast_unlock().</span>
<span class="line-removed"> 1874 // In the interest of performance we elide m-&gt;Owner==Self check in unlock.</span>
<span class="line-removed"> 1875 // A perfectly viable alternative is to elide the owner check except when</span>
<span class="line-removed"> 1876 // Xcheck:jni is enabled.</span>
<span class="line-removed"> 1877 </span>
<span class="line-removed"> 1878 void MacroAssembler::fast_unlock(Register objReg, Register boxReg, Register tmpReg, bool use_rtm) {</span>
<span class="line-removed"> 1879   assert(boxReg == rax, &quot;&quot;);</span>
<span class="line-removed"> 1880   assert_different_registers(objReg, boxReg, tmpReg);</span>
<span class="line-removed"> 1881 </span>
<span class="line-removed"> 1882   Label DONE_LABEL, Stacked, CheckSucc;</span>
<span class="line-removed"> 1883 </span>
<span class="line-removed"> 1884   // Critically, the biased locking test must have precedence over</span>
<span class="line-removed"> 1885   // and appear before the (box-&gt;dhw == 0) recursive stack-lock test.</span>
<span class="line-removed"> 1886   if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {</span>
<span class="line-removed"> 1887     biased_locking_exit(objReg, tmpReg, DONE_LABEL);</span>
<span class="line-removed"> 1888   }</span>
<span class="line-removed"> 1889 </span>
<span class="line-removed"> 1890 #if INCLUDE_RTM_OPT</span>
<span class="line-removed"> 1891   if (UseRTMForStackLocks &amp;&amp; use_rtm) {</span>
<span class="line-removed"> 1892     assert(!UseBiasedLocking, &quot;Biased locking is not supported with RTM locking&quot;);</span>
<span class="line-removed"> 1893     Label L_regular_unlock;</span>
<span class="line-removed"> 1894     movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // fetch markword</span>
<span class="line-removed"> 1895     andptr(tmpReg, markWord::biased_lock_mask_in_place);              // look at 3 lock bits</span>
<span class="line-removed"> 1896     cmpptr(tmpReg, markWord::unlocked_value);                         // bits = 001 unlocked</span>
<span class="line-removed"> 1897     jccb(Assembler::notEqual, L_regular_unlock);                      // if !HLE RegularLock</span>
<span class="line-removed"> 1898     xend();                                                           // otherwise end...</span>
<span class="line-removed"> 1899     jmp(DONE_LABEL);                                                  // ... and we&#39;re done</span>
<span class="line-removed"> 1900     bind(L_regular_unlock);</span>
<span class="line-removed"> 1901   }</span>
<span class="line-removed"> 1902 #endif</span>
<span class="line-removed"> 1903 </span>
<span class="line-removed"> 1904   cmpptr(Address(boxReg, 0), (int32_t)NULL_WORD);                   // Examine the displaced header</span>
<span class="line-removed"> 1905   jcc   (Assembler::zero, DONE_LABEL);                              // 0 indicates recursive stack-lock</span>
<span class="line-removed"> 1906   movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // Examine the object&#39;s markword</span>
<span class="line-removed"> 1907   testptr(tmpReg, markWord::monitor_value);                         // Inflated?</span>
<span class="line-removed"> 1908   jccb  (Assembler::zero, Stacked);</span>
<span class="line-removed"> 1909 </span>
<span class="line-removed"> 1910   // It&#39;s inflated.</span>
<span class="line-removed"> 1911 #if INCLUDE_RTM_OPT</span>
<span class="line-removed"> 1912   if (use_rtm) {</span>
<span class="line-removed"> 1913     Label L_regular_inflated_unlock;</span>
<span class="line-removed"> 1914     int owner_offset = OM_OFFSET_NO_MONITOR_VALUE_TAG(owner);</span>
<span class="line-removed"> 1915     movptr(boxReg, Address(tmpReg, owner_offset));</span>
<span class="line-removed"> 1916     testptr(boxReg, boxReg);</span>
<span class="line-removed"> 1917     jccb(Assembler::notZero, L_regular_inflated_unlock);</span>
<span class="line-removed"> 1918     xend();</span>
<span class="line-removed"> 1919     jmpb(DONE_LABEL);</span>
<span class="line-removed"> 1920     bind(L_regular_inflated_unlock);</span>
<span class="line-removed"> 1921   }</span>
<span class="line-removed"> 1922 #endif</span>
<span class="line-removed"> 1923 </span>
<span class="line-removed"> 1924   // Despite our balanced locking property we still check that m-&gt;_owner == Self</span>
<span class="line-removed"> 1925   // as java routines or native JNI code called by this thread might</span>
<span class="line-removed"> 1926   // have released the lock.</span>
<span class="line-removed"> 1927   // Refer to the comments in synchronizer.cpp for how we might encode extra</span>
<span class="line-removed"> 1928   // state in _succ so we can avoid fetching EntryList|cxq.</span>
<span class="line-removed"> 1929   //</span>
<span class="line-removed"> 1930   // I&#39;d like to add more cases in fast_lock() and fast_unlock() --</span>
<span class="line-removed"> 1931   // such as recursive enter and exit -- but we have to be wary of</span>
<span class="line-removed"> 1932   // I$ bloat, T$ effects and BP$ effects.</span>
<span class="line-removed"> 1933   //</span>
<span class="line-removed"> 1934   // If there&#39;s no contention try a 1-0 exit.  That is, exit without</span>
<span class="line-removed"> 1935   // a costly MEMBAR or CAS.  See synchronizer.cpp for details on how</span>
<span class="line-removed"> 1936   // we detect and recover from the race that the 1-0 exit admits.</span>
<span class="line-removed"> 1937   //</span>
<span class="line-removed"> 1938   // Conceptually fast_unlock() must execute a STST|LDST &quot;release&quot; barrier</span>
<span class="line-removed"> 1939   // before it STs null into _owner, releasing the lock.  Updates</span>
<span class="line-removed"> 1940   // to data protected by the critical section must be visible before</span>
<span class="line-removed"> 1941   // we drop the lock (and thus before any other thread could acquire</span>
<span class="line-removed"> 1942   // the lock and observe the fields protected by the lock).</span>
<span class="line-removed"> 1943   // IA32&#39;s memory-model is SPO, so STs are ordered with respect to</span>
<span class="line-removed"> 1944   // each other and there&#39;s no need for an explicit barrier (fence).</span>
<span class="line-removed"> 1945   // See also http://gee.cs.oswego.edu/dl/jmm/cookbook.html.</span>
<span class="line-removed"> 1946 #ifndef _LP64</span>
<span class="line-removed"> 1947   get_thread (boxReg);</span>
<span class="line-removed"> 1948 </span>
<span class="line-removed"> 1949   // Note that we could employ various encoding schemes to reduce</span>
<span class="line-removed"> 1950   // the number of loads below (currently 4) to just 2 or 3.</span>
<span class="line-removed"> 1951   // Refer to the comments in synchronizer.cpp.</span>
<span class="line-removed"> 1952   // In practice the chain of fetches doesn&#39;t seem to impact performance, however.</span>
<span class="line-removed"> 1953   xorptr(boxReg, boxReg);</span>
<span class="line-removed"> 1954   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));</span>
<span class="line-removed"> 1955   jccb  (Assembler::notZero, DONE_LABEL);</span>
<span class="line-removed"> 1956   movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));</span>
<span class="line-removed"> 1957   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));</span>
<span class="line-removed"> 1958   jccb  (Assembler::notZero, CheckSucc);</span>
<span class="line-removed"> 1959   movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);</span>
<span class="line-removed"> 1960   jmpb  (DONE_LABEL);</span>
<span class="line-removed"> 1961 </span>
<span class="line-removed"> 1962   bind (Stacked);</span>
<span class="line-removed"> 1963   // It&#39;s not inflated and it&#39;s not recursively stack-locked and it&#39;s not biased.</span>
<span class="line-removed"> 1964   // It must be stack-locked.</span>
<span class="line-removed"> 1965   // Try to reset the header to displaced header.</span>
<span class="line-removed"> 1966   // The &quot;box&quot; value on the stack is stable, so we can reload</span>
<span class="line-removed"> 1967   // and be assured we observe the same value as above.</span>
<span class="line-removed"> 1968   movptr(tmpReg, Address(boxReg, 0));</span>
<span class="line-removed"> 1969   lock();</span>
<span class="line-removed"> 1970   cmpxchgptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // Uses RAX which is box</span>
<span class="line-removed"> 1971   // Intention fall-thru into DONE_LABEL</span>
<span class="line-removed"> 1972 </span>
<span class="line-removed"> 1973   // DONE_LABEL is a hot target - we&#39;d really like to place it at the</span>
<span class="line-removed"> 1974   // start of cache line by padding with NOPs.</span>
<span class="line-removed"> 1975   // See the AMD and Intel software optimization manuals for the</span>
<span class="line-removed"> 1976   // most efficient &quot;long&quot; NOP encodings.</span>
<span class="line-removed"> 1977   // Unfortunately none of our alignment mechanisms suffice.</span>
<span class="line-removed"> 1978   bind (CheckSucc);</span>
<span class="line-removed"> 1979 #else // _LP64</span>
<span class="line-removed"> 1980   // It&#39;s inflated</span>
<span class="line-removed"> 1981   xorptr(boxReg, boxReg);</span>
<span class="line-removed"> 1982   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));</span>
<span class="line-removed"> 1983   jccb  (Assembler::notZero, DONE_LABEL);</span>
<span class="line-removed"> 1984   movptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));</span>
<span class="line-removed"> 1985   orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));</span>
<span class="line-removed"> 1986   jccb  (Assembler::notZero, CheckSucc);</span>
<span class="line-removed"> 1987   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.</span>
<span class="line-removed"> 1988   movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), (int32_t)NULL_WORD);</span>
<span class="line-removed"> 1989   jmpb  (DONE_LABEL);</span>
<span class="line-removed"> 1990 </span>
<span class="line-removed"> 1991   // Try to avoid passing control into the slow_path ...</span>
<span class="line-removed"> 1992   Label LSuccess, LGoSlowPath ;</span>
<span class="line-removed"> 1993   bind  (CheckSucc);</span>
<span class="line-removed"> 1994 </span>
<span class="line-removed"> 1995   // The following optional optimization can be elided if necessary</span>
<span class="line-removed"> 1996   // Effectively: if (succ == null) goto slow path</span>
<span class="line-removed"> 1997   // The code reduces the window for a race, however,</span>
<span class="line-removed"> 1998   // and thus benefits performance.</span>
<span class="line-removed"> 1999   cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), (int32_t)NULL_WORD);</span>
<span class="line-removed"> 2000   jccb  (Assembler::zero, LGoSlowPath);</span>
<span class="line-removed"> 2001 </span>
<span class="line-removed"> 2002   xorptr(boxReg, boxReg);</span>
<span class="line-removed"> 2003   // Without cast to int32_t this style of movptr will destroy r10 which is typically obj.</span>
<span class="line-removed"> 2004   movptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), (int32_t)NULL_WORD);</span>
<span class="line-removed"> 2005 </span>
<span class="line-removed"> 2006   // Memory barrier/fence</span>
<span class="line-removed"> 2007   // Dekker pivot point -- fulcrum : ST Owner; MEMBAR; LD Succ</span>
<span class="line-removed"> 2008   // Instead of MFENCE we use a dummy locked add of 0 to the top-of-stack.</span>
<span class="line-removed"> 2009   // This is faster on Nehalem and AMD Shanghai/Barcelona.</span>
<span class="line-removed"> 2010   // See https://blogs.oracle.com/dave/entry/instruction_selection_for_volatile_fences</span>
<span class="line-removed"> 2011   // We might also restructure (ST Owner=0;barrier;LD _Succ) to</span>
<span class="line-removed"> 2012   // (mov box,0; xchgq box, &amp;m-&gt;Owner; LD _succ) .</span>
<span class="line-removed"> 2013   lock(); addl(Address(rsp, 0), 0);</span>
<span class="line-removed"> 2014 </span>
<span class="line-removed"> 2015   cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), (int32_t)NULL_WORD);</span>
<span class="line-removed"> 2016   jccb  (Assembler::notZero, LSuccess);</span>
<span class="line-removed"> 2017 </span>
<span class="line-removed"> 2018   // Rare inopportune interleaving - race.</span>
<span class="line-removed"> 2019   // The successor vanished in the small window above.</span>
<span class="line-removed"> 2020   // The lock is contended -- (cxq|EntryList) != null -- and there&#39;s no apparent successor.</span>
<span class="line-removed"> 2021   // We need to ensure progress and succession.</span>
<span class="line-removed"> 2022   // Try to reacquire the lock.</span>
<span class="line-removed"> 2023   // If that fails then the new owner is responsible for succession and this</span>
<span class="line-removed"> 2024   // thread needs to take no further action and can exit via the fast path (success).</span>
<span class="line-removed"> 2025   // If the re-acquire succeeds then pass control into the slow path.</span>
<span class="line-removed"> 2026   // As implemented, this latter mode is horrible because we generated more</span>
<span class="line-removed"> 2027   // coherence traffic on the lock *and* artifically extended the critical section</span>
<span class="line-removed"> 2028   // length while by virtue of passing control into the slow path.</span>
<span class="line-removed"> 2029 </span>
<span class="line-removed"> 2030   // box is really RAX -- the following CMPXCHG depends on that binding</span>
<span class="line-removed"> 2031   // cmpxchg R,[M] is equivalent to rax = CAS(M,rax,R)</span>
<span class="line-removed"> 2032   lock();</span>
<span class="line-removed"> 2033   cmpxchgptr(r15_thread, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));</span>
<span class="line-removed"> 2034   // There&#39;s no successor so we tried to regrab the lock.</span>
<span class="line-removed"> 2035   // If that didn&#39;t work, then another thread grabbed the</span>
<span class="line-removed"> 2036   // lock so we&#39;re done (and exit was a success).</span>
<span class="line-removed"> 2037   jccb  (Assembler::notEqual, LSuccess);</span>
<span class="line-removed"> 2038   // Intentional fall-through into slow path</span>
<span class="line-removed"> 2039 </span>
<span class="line-removed"> 2040   bind  (LGoSlowPath);</span>
<span class="line-removed"> 2041   orl   (boxReg, 1);                      // set ICC.ZF=0 to indicate failure</span>
<span class="line-removed"> 2042   jmpb  (DONE_LABEL);</span>
<span class="line-removed"> 2043 </span>
<span class="line-removed"> 2044   bind  (LSuccess);</span>
<span class="line-removed"> 2045   testl (boxReg, 0);                      // set ICC.ZF=1 to indicate success</span>
<span class="line-removed"> 2046   jmpb  (DONE_LABEL);</span>
<span class="line-removed"> 2047 </span>
<span class="line-removed"> 2048   bind  (Stacked);</span>
<span class="line-removed"> 2049   movptr(tmpReg, Address (boxReg, 0));      // re-fetch</span>
<span class="line-removed"> 2050   lock();</span>
<span class="line-removed"> 2051   cmpxchgptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); // Uses RAX which is box</span>
<span class="line-removed"> 2052 </span>
<span class="line-removed"> 2053 #endif</span>
<span class="line-removed"> 2054   bind(DONE_LABEL);</span>
<span class="line-removed"> 2055 }</span>
<span class="line-removed"> 2056 #endif // COMPILER2</span>
<span class="line-removed"> 2057 </span>
 2058 void MacroAssembler::c2bool(Register x) {
 2059   // implements x == 0 ? 0 : 1
 2060   // note: must only look at least-significant byte of x
 2061   //       since C-style booleans are stored in one byte
 2062   //       only! (was bug)
 2063   andl(x, 0xFF);
 2064   setb(Assembler::notZero, x);
 2065 }
 2066 
 2067 // Wouldn&#39;t need if AddressLiteral version had new name
 2068 void MacroAssembler::call(Label&amp; L, relocInfo::relocType rtype) {
 2069   Assembler::call(L, rtype);
 2070 }
 2071 
 2072 void MacroAssembler::call(Register entry) {
 2073   Assembler::call(entry);
 2074 }
 2075 
 2076 void MacroAssembler::call(AddressLiteral entry) {
 2077   if (reachable(entry)) {
</pre>
<hr />
<pre>
 2717 }
 2718 
 2719 void MacroAssembler::divsd(XMMRegister dst, AddressLiteral src) {
 2720   if (reachable(src)) {
 2721     Assembler::divsd(dst, as_Address(src));
 2722   } else {
 2723     lea(rscratch1, src);
 2724     Assembler::divsd(dst, Address(rscratch1, 0));
 2725   }
 2726 }
 2727 
 2728 void MacroAssembler::divss(XMMRegister dst, AddressLiteral src) {
 2729   if (reachable(src)) {
 2730     Assembler::divss(dst, as_Address(src));
 2731   } else {
 2732     lea(rscratch1, src);
 2733     Assembler::divss(dst, Address(rscratch1, 0));
 2734   }
 2735 }
 2736 
<span class="line-removed"> 2737 #ifndef _LP64</span>
<span class="line-removed"> 2738 void MacroAssembler::empty_FPU_stack() {</span>
<span class="line-removed"> 2739   if (VM_Version::supports_mmx()) {</span>
<span class="line-removed"> 2740     emms();</span>
<span class="line-removed"> 2741   } else {</span>
<span class="line-removed"> 2742     for (int i = 8; i-- &gt; 0; ) ffree(i);</span>
<span class="line-removed"> 2743   }</span>
<span class="line-removed"> 2744 }</span>
<span class="line-removed"> 2745 #endif // !LP64</span>
<span class="line-removed"> 2746 </span>
<span class="line-removed"> 2747 </span>
 2748 void MacroAssembler::enter() {
 2749   push(rbp);
 2750   mov(rbp, rsp);
 2751 }
 2752 
 2753 // A 5 byte nop that is safe for patching (see patch_verified_entry)
 2754 void MacroAssembler::fat_nop() {
 2755   if (UseAddressNop) {
 2756     addr_nop_5();
 2757   } else {
 2758     emit_int8(0x26); // es:
 2759     emit_int8(0x2e); // cs:
 2760     emit_int8(0x64); // fs:
 2761     emit_int8(0x65); // gs:
 2762     emit_int8((unsigned char)0x90);
 2763   }
 2764 }
 2765 
<span class="line-modified"> 2766 #if !defined(_LP64)</span>
 2767 void MacroAssembler::fcmp(Register tmp) {
 2768   fcmp(tmp, 1, true, true);
 2769 }
 2770 
 2771 void MacroAssembler::fcmp(Register tmp, int index, bool pop_left, bool pop_right) {
 2772   assert(!pop_right || pop_left, &quot;usage error&quot;);
 2773   if (VM_Version::supports_cmov()) {
 2774     assert(tmp == noreg, &quot;unneeded temp&quot;);
 2775     if (pop_left) {
 2776       fucomip(index);
 2777     } else {
 2778       fucomi(index);
 2779     }
 2780     if (pop_right) {
 2781       fpop();
 2782     }
 2783   } else {
 2784     assert(tmp != noreg, &quot;need temp&quot;);
 2785     if (pop_left) {
 2786       if (pop_right) {
</pre>
<hr />
<pre>
 2849   ffree();
 2850   fincstp();
 2851 }
 2852 
 2853 void MacroAssembler::fremr(Register tmp) {
 2854   save_rax(tmp);
 2855   { Label L;
 2856     bind(L);
 2857     fprem();
 2858     fwait(); fnstsw_ax();
 2859     sahf();
 2860     jcc(Assembler::parity, L);
 2861   }
 2862   restore_rax(tmp);
 2863   // Result is in ST0.
 2864   // Note: fxch &amp; fpop to get rid of ST1
 2865   // (otherwise FPU stack could overflow eventually)
 2866   fxch(1);
 2867   fpop();
 2868 }








 2869 #endif // !LP64
 2870 
 2871 void MacroAssembler::mulpd(XMMRegister dst, AddressLiteral src) {
 2872   if (reachable(src)) {
 2873     Assembler::mulpd(dst, as_Address(src));
 2874   } else {
 2875     lea(rscratch1, src);
 2876     Assembler::mulpd(dst, Address(rscratch1, 0));
 2877   }
 2878 }
 2879 
 2880 void MacroAssembler::load_float(Address src) {



 2881   if (UseSSE &gt;= 1) {
 2882     movflt(xmm0, src);
 2883   } else {
<span class="line-modified"> 2884     LP64_ONLY(ShouldNotReachHere());</span>
<span class="line-removed"> 2885     NOT_LP64(fld_s(src));</span>
 2886   }

 2887 }
 2888 
 2889 void MacroAssembler::store_float(Address dst) {



 2890   if (UseSSE &gt;= 1) {
 2891     movflt(dst, xmm0);
 2892   } else {
<span class="line-modified"> 2893     LP64_ONLY(ShouldNotReachHere());</span>
<span class="line-removed"> 2894     NOT_LP64(fstp_s(dst));</span>
 2895   }

 2896 }
 2897 
 2898 void MacroAssembler::load_double(Address src) {



 2899   if (UseSSE &gt;= 2) {
 2900     movdbl(xmm0, src);
 2901   } else {
<span class="line-modified"> 2902     LP64_ONLY(ShouldNotReachHere());</span>
<span class="line-removed"> 2903     NOT_LP64(fld_d(src));</span>
 2904   }

 2905 }
 2906 
 2907 void MacroAssembler::store_double(Address dst) {



 2908   if (UseSSE &gt;= 2) {
 2909     movdbl(dst, xmm0);
 2910   } else {
<span class="line-modified"> 2911     LP64_ONLY(ShouldNotReachHere());</span>
<span class="line-removed"> 2912     NOT_LP64(fstp_d(dst));</span>
 2913   }

 2914 }
 2915 
 2916 // dst = c = a * b + c
 2917 void MacroAssembler::fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
 2918   Assembler::vfmadd231sd(c, a, b);
 2919   if (dst != c) {
 2920     movdbl(dst, c);
 2921   }
 2922 }
 2923 
 2924 // dst = c = a * b + c
 2925 void MacroAssembler::fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
 2926   Assembler::vfmadd231ss(c, a, b);
 2927   if (dst != c) {
 2928     movflt(dst, c);
 2929   }
 2930 }
 2931 
 2932 // dst = c = a * b + c
 2933 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
</pre>
<hr />
<pre>
 3198 }
 3199 
 3200 void MacroAssembler::movdl(XMMRegister dst, AddressLiteral src) {
 3201   if (reachable(src)) {
 3202     movdl(dst, as_Address(src));
 3203   } else {
 3204     lea(rscratch1, src);
 3205     movdl(dst, Address(rscratch1, 0));
 3206   }
 3207 }
 3208 
 3209 void MacroAssembler::movq(XMMRegister dst, AddressLiteral src) {
 3210   if (reachable(src)) {
 3211     movq(dst, as_Address(src));
 3212   } else {
 3213     lea(rscratch1, src);
 3214     movq(dst, Address(rscratch1, 0));
 3215   }
 3216 }
 3217 
<span class="line-removed"> 3218 #ifdef COMPILER2</span>
<span class="line-removed"> 3219 void MacroAssembler::setvectmask(Register dst, Register src) {</span>
<span class="line-removed"> 3220   guarantee(PostLoopMultiversioning, &quot;must be&quot;);</span>
<span class="line-removed"> 3221   Assembler::movl(dst, 1);</span>
<span class="line-removed"> 3222   Assembler::shlxl(dst, dst, src);</span>
<span class="line-removed"> 3223   Assembler::decl(dst);</span>
<span class="line-removed"> 3224   Assembler::kmovdl(k1, dst);</span>
<span class="line-removed"> 3225   Assembler::movl(dst, src);</span>
<span class="line-removed"> 3226 }</span>
<span class="line-removed"> 3227 </span>
<span class="line-removed"> 3228 void MacroAssembler::restorevectmask() {</span>
<span class="line-removed"> 3229   guarantee(PostLoopMultiversioning, &quot;must be&quot;);</span>
<span class="line-removed"> 3230   Assembler::knotwl(k1, k0);</span>
<span class="line-removed"> 3231 }</span>
<span class="line-removed"> 3232 #endif // COMPILER2</span>
<span class="line-removed"> 3233 </span>
 3234 void MacroAssembler::movdbl(XMMRegister dst, AddressLiteral src) {
 3235   if (reachable(src)) {
 3236     if (UseXmmLoadAndClearUpper) {
 3237       movsd (dst, as_Address(src));
 3238     } else {
 3239       movlpd(dst, as_Address(src));
 3240     }
 3241   } else {
 3242     lea(rscratch1, src);
 3243     if (UseXmmLoadAndClearUpper) {
 3244       movsd (dst, Address(rscratch1, 0));
 3245     } else {
 3246       movlpd(dst, Address(rscratch1, 0));
 3247     }
 3248   }
 3249 }
 3250 
 3251 void MacroAssembler::movflt(XMMRegister dst, AddressLiteral src) {
 3252   if (reachable(src)) {
 3253     movss(dst, as_Address(src));
</pre>
<hr />
<pre>
 4088   } else {
 4089     lea(scratch_reg, src);
 4090     vxorps(dst, nds, Address(scratch_reg, 0), vector_len);
 4091   }
 4092 }
 4093 
 4094 void MacroAssembler::vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
 4095   if (UseAVX &gt; 1 || (vector_len &lt; 1)) {
 4096     if (reachable(src)) {
 4097       Assembler::vpxor(dst, nds, as_Address(src), vector_len);
 4098     } else {
 4099       lea(scratch_reg, src);
 4100       Assembler::vpxor(dst, nds, Address(scratch_reg, 0), vector_len);
 4101     }
 4102   }
 4103   else {
 4104     MacroAssembler::vxorpd(dst, nds, src, vector_len, scratch_reg);
 4105   }
 4106 }
 4107 
<span class="line-removed"> 4108 //-------------------------------------------------------------------------------------------</span>
<span class="line-removed"> 4109 #ifdef COMPILER2</span>
<span class="line-removed"> 4110 // Generic instructions support for use in .ad files C2 code generation</span>
<span class="line-removed"> 4111 </span>
<span class="line-removed"> 4112 void MacroAssembler::vabsnegd(int opcode, XMMRegister dst, XMMRegister src, Register scr) {</span>
<span class="line-removed"> 4113   if (dst != src) {</span>
<span class="line-removed"> 4114     movdqu(dst, src);</span>
<span class="line-removed"> 4115   }</span>
<span class="line-removed"> 4116   if (opcode == Op_AbsVD) {</span>
<span class="line-removed"> 4117     andpd(dst, ExternalAddress(StubRoutines::x86::vector_double_sign_mask()), scr);</span>
<span class="line-removed"> 4118   } else {</span>
<span class="line-removed"> 4119     assert((opcode == Op_NegVD),&quot;opcode should be Op_NegD&quot;);</span>
<span class="line-removed"> 4120     xorpd(dst, ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), scr);</span>
<span class="line-removed"> 4121   }</span>
<span class="line-removed"> 4122 }</span>
<span class="line-removed"> 4123 </span>
<span class="line-removed"> 4124 void MacroAssembler::vabsnegd(int opcode, XMMRegister dst, XMMRegister src, int vector_len, Register scr) {</span>
<span class="line-removed"> 4125   if (opcode == Op_AbsVD) {</span>
<span class="line-removed"> 4126     vandpd(dst, src, ExternalAddress(StubRoutines::x86::vector_double_sign_mask()), vector_len, scr);</span>
<span class="line-removed"> 4127   } else {</span>
<span class="line-removed"> 4128     assert((opcode == Op_NegVD),&quot;opcode should be Op_NegD&quot;);</span>
<span class="line-removed"> 4129     vxorpd(dst, src, ExternalAddress(StubRoutines::x86::vector_double_sign_flip()), vector_len, scr);</span>
<span class="line-removed"> 4130   }</span>
<span class="line-removed"> 4131 }</span>
<span class="line-removed"> 4132 </span>
<span class="line-removed"> 4133 void MacroAssembler::vabsnegf(int opcode, XMMRegister dst, XMMRegister src, Register scr) {</span>
<span class="line-removed"> 4134   if (dst != src) {</span>
<span class="line-removed"> 4135     movdqu(dst, src);</span>
<span class="line-removed"> 4136   }</span>
<span class="line-removed"> 4137   if (opcode == Op_AbsVF) {</span>
<span class="line-removed"> 4138     andps(dst, ExternalAddress(StubRoutines::x86::vector_float_sign_mask()), scr);</span>
<span class="line-removed"> 4139   } else {</span>
<span class="line-removed"> 4140     assert((opcode == Op_NegVF),&quot;opcode should be Op_NegF&quot;);</span>
<span class="line-removed"> 4141     xorps(dst, ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), scr);</span>
<span class="line-removed"> 4142   }</span>
<span class="line-removed"> 4143 }</span>
<span class="line-removed"> 4144 </span>
<span class="line-removed"> 4145 void MacroAssembler::vabsnegf(int opcode, XMMRegister dst, XMMRegister src, int vector_len, Register scr) {</span>
<span class="line-removed"> 4146   if (opcode == Op_AbsVF) {</span>
<span class="line-removed"> 4147     vandps(dst, src, ExternalAddress(StubRoutines::x86::vector_float_sign_mask()), vector_len, scr);</span>
<span class="line-removed"> 4148   } else {</span>
<span class="line-removed"> 4149     assert((opcode == Op_NegVF),&quot;opcode should be Op_NegF&quot;);</span>
<span class="line-removed"> 4150     vxorps(dst, src, ExternalAddress(StubRoutines::x86::vector_float_sign_flip()), vector_len, scr);</span>
<span class="line-removed"> 4151   }</span>
<span class="line-removed"> 4152 }</span>
<span class="line-removed"> 4153 </span>
<span class="line-removed"> 4154 void MacroAssembler::vextendbw(bool sign, XMMRegister dst, XMMRegister src) {</span>
<span class="line-removed"> 4155   if (sign) {</span>
<span class="line-removed"> 4156     pmovsxbw(dst, src);</span>
<span class="line-removed"> 4157   } else {</span>
<span class="line-removed"> 4158     pmovzxbw(dst, src);</span>
<span class="line-removed"> 4159   }</span>
<span class="line-removed"> 4160 }</span>
<span class="line-removed"> 4161 </span>
<span class="line-removed"> 4162 void MacroAssembler::vextendbw(bool sign, XMMRegister dst, XMMRegister src, int vector_len) {</span>
<span class="line-removed"> 4163   if (sign) {</span>
<span class="line-removed"> 4164     vpmovsxbw(dst, src, vector_len);</span>
<span class="line-removed"> 4165   } else {</span>
<span class="line-removed"> 4166     vpmovzxbw(dst, src, vector_len);</span>
<span class="line-removed"> 4167   }</span>
<span class="line-removed"> 4168 }</span>
<span class="line-removed"> 4169 </span>
<span class="line-removed"> 4170 void MacroAssembler::vshiftd(int opcode, XMMRegister dst, XMMRegister src) {</span>
<span class="line-removed"> 4171   if (opcode == Op_RShiftVI) {</span>
<span class="line-removed"> 4172     psrad(dst, src);</span>
<span class="line-removed"> 4173   } else if (opcode == Op_LShiftVI) {</span>
<span class="line-removed"> 4174     pslld(dst, src);</span>
<span class="line-removed"> 4175   } else {</span>
<span class="line-removed"> 4176     assert((opcode == Op_URShiftVI),&quot;opcode should be Op_URShiftVI&quot;);</span>
<span class="line-removed"> 4177     psrld(dst, src);</span>
<span class="line-removed"> 4178   }</span>
<span class="line-removed"> 4179 }</span>
<span class="line-removed"> 4180 </span>
<span class="line-removed"> 4181 void MacroAssembler::vshiftd(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {</span>
<span class="line-removed"> 4182   if (opcode == Op_RShiftVI) {</span>
<span class="line-removed"> 4183     vpsrad(dst, nds, src, vector_len);</span>
<span class="line-removed"> 4184   } else if (opcode == Op_LShiftVI) {</span>
<span class="line-removed"> 4185     vpslld(dst, nds, src, vector_len);</span>
<span class="line-removed"> 4186   } else {</span>
<span class="line-removed"> 4187     assert((opcode == Op_URShiftVI),&quot;opcode should be Op_URShiftVI&quot;);</span>
<span class="line-removed"> 4188     vpsrld(dst, nds, src, vector_len);</span>
<span class="line-removed"> 4189   }</span>
<span class="line-removed"> 4190 }</span>
<span class="line-removed"> 4191 </span>
<span class="line-removed"> 4192 void MacroAssembler::vshiftw(int opcode, XMMRegister dst, XMMRegister src) {</span>
<span class="line-removed"> 4193   if ((opcode == Op_RShiftVS) || (opcode == Op_RShiftVB)) {</span>
<span class="line-removed"> 4194     psraw(dst, src);</span>
<span class="line-removed"> 4195   } else if ((opcode == Op_LShiftVS) || (opcode == Op_LShiftVB)) {</span>
<span class="line-removed"> 4196     psllw(dst, src);</span>
<span class="line-removed"> 4197   } else {</span>
<span class="line-removed"> 4198     assert(((opcode == Op_URShiftVS) || (opcode == Op_URShiftVB)),&quot;opcode should be one of Op_URShiftVS or Op_URShiftVB&quot;);</span>
<span class="line-removed"> 4199     psrlw(dst, src);</span>
<span class="line-removed"> 4200   }</span>
<span class="line-removed"> 4201 }</span>
<span class="line-removed"> 4202 </span>
<span class="line-removed"> 4203 void MacroAssembler::vshiftw(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {</span>
<span class="line-removed"> 4204   if ((opcode == Op_RShiftVS) || (opcode == Op_RShiftVB)) {</span>
<span class="line-removed"> 4205     vpsraw(dst, nds, src, vector_len);</span>
<span class="line-removed"> 4206   } else if ((opcode == Op_LShiftVS) || (opcode == Op_LShiftVB)) {</span>
<span class="line-removed"> 4207     vpsllw(dst, nds, src, vector_len);</span>
<span class="line-removed"> 4208   } else {</span>
<span class="line-removed"> 4209     assert(((opcode == Op_URShiftVS) || (opcode == Op_URShiftVB)),&quot;opcode should be one of Op_URShiftVS or Op_URShiftVB&quot;);</span>
<span class="line-removed"> 4210     vpsrlw(dst, nds, src, vector_len);</span>
<span class="line-removed"> 4211   }</span>
<span class="line-removed"> 4212 }</span>
<span class="line-removed"> 4213 </span>
<span class="line-removed"> 4214 void MacroAssembler::vshiftq(int opcode, XMMRegister dst, XMMRegister src) {</span>
<span class="line-removed"> 4215   if (opcode == Op_RShiftVL) {</span>
<span class="line-removed"> 4216     psrlq(dst, src);  // using srl to implement sra on pre-avs512 systems</span>
<span class="line-removed"> 4217   } else if (opcode == Op_LShiftVL) {</span>
<span class="line-removed"> 4218     psllq(dst, src);</span>
<span class="line-removed"> 4219   } else {</span>
<span class="line-removed"> 4220     assert((opcode == Op_URShiftVL),&quot;opcode should be Op_URShiftVL&quot;);</span>
<span class="line-removed"> 4221     psrlq(dst, src);</span>
<span class="line-removed"> 4222   }</span>
<span class="line-removed"> 4223 }</span>
<span class="line-removed"> 4224 </span>
<span class="line-removed"> 4225 void MacroAssembler::vshiftq(int opcode, XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {</span>
<span class="line-removed"> 4226   if (opcode == Op_RShiftVL) {</span>
<span class="line-removed"> 4227     evpsraq(dst, nds, src, vector_len);</span>
<span class="line-removed"> 4228   } else if (opcode == Op_LShiftVL) {</span>
<span class="line-removed"> 4229     vpsllq(dst, nds, src, vector_len);</span>
<span class="line-removed"> 4230   } else {</span>
<span class="line-removed"> 4231     assert((opcode == Op_URShiftVL),&quot;opcode should be Op_URShiftVL&quot;);</span>
<span class="line-removed"> 4232     vpsrlq(dst, nds, src, vector_len);</span>
<span class="line-removed"> 4233   }</span>
<span class="line-removed"> 4234 }</span>
<span class="line-removed"> 4235 #endif</span>
 4236 //-------------------------------------------------------------------------------------------
 4237 
 4238 void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {
 4239   const int32_t inverted_jweak_mask = ~static_cast&lt;int32_t&gt;(JNIHandles::weak_tag_mask);
 4240   STATIC_ASSERT(inverted_jweak_mask == -2); // otherwise check this code
 4241   // The inverted mask is sign-extended
 4242   andptr(possibly_jweak, inverted_jweak_mask);
 4243 }
 4244 
 4245 void MacroAssembler::resolve_jobject(Register value,
 4246                                      Register thread,
 4247                                      Register tmp) {
 4248   assert_different_registers(value, thread, tmp);
 4249   Label done, not_weak;
 4250   testptr(value, value);
 4251   jcc(Assembler::zero, done);                // Use NULL as-is.
 4252   testptr(value, JNIHandles::weak_tag_mask); // Test for jweak tag.
 4253   jcc(Assembler::zero, not_weak);
 4254   // Resolve jweak.
 4255   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
</pre>
<hr />
<pre>
 5947 }
 5948 
 5949 void MacroAssembler::reinit_heapbase() {
 5950   if (UseCompressedOops || UseCompressedClassPointers) {
 5951     if (Universe::heap() != NULL) {
 5952       if (CompressedOops::base() == NULL) {
 5953         MacroAssembler::xorptr(r12_heapbase, r12_heapbase);
 5954       } else {
 5955         mov64(r12_heapbase, (int64_t)CompressedOops::ptrs_base());
 5956       }
 5957     } else {
 5958       movptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
 5959     }
 5960   }
 5961 }
 5962 
 5963 #endif // _LP64
 5964 
 5965 // C2 compiled method&#39;s prolog code.
 5966 void MacroAssembler::verified_entry(Compile* C, int sp_inc) {
<span class="line-modified"> 5967   int framesize = C-&gt;frame_size_in_bytes();</span>
<span class="line-modified"> 5968   int bangsize = C-&gt;bang_size_in_bytes();</span>
 5969   bool fp_mode_24b = false;
<span class="line-modified"> 5970   int stack_bang_size = C-&gt;need_stack_bang(bangsize) ? bangsize : 0;</span>
 5971 
 5972   // WARNING: Initial instruction MUST be 5 bytes or longer so that
 5973   // NativeJump::patch_verified_entry will be able to patch out the entry
 5974   // code safely. The push to verify stack depth is ok at 5 bytes,
 5975   // the frame allocation can be either 3 or 6 bytes. So if we don&#39;t do
 5976   // stack bang then we must use the 6 byte frame allocation even if
 5977   // we have no frame. :-(
 5978   assert(stack_bang_size &gt;= framesize || stack_bang_size &lt;= 0, &quot;stack bang size incorrect&quot;);
 5979 
 5980   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
 5981   // Remove word for return addr
 5982   framesize -= wordSize;
 5983   stack_bang_size -= wordSize;
 5984 
 5985   // Calls to C2R adapters often do not accept exceptional returns.
 5986   // We require that their callers must bang for them.  But be careful, because
 5987   // some VM calls (such as call site linkage) can use several kilobytes of
 5988   // stack.  But the stack safety zone should account for that.
 5989   // See bugs 4446381, 4468289, 4497237.
 5990   if (stack_bang_size &gt; 0) {
</pre>
<hr />
<pre>
 6006     }
 6007   } else {
 6008     // Create frame (force generation of a 4 byte immediate value)
 6009     subptr_imm32(rsp, framesize);
 6010 
 6011     // Save RBP register now.
 6012     framesize -= wordSize;
 6013     movptr(Address(rsp, framesize), rbp);
 6014     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
 6015     if (PreserveFramePointer) {
 6016       movptr(rbp, rsp);
 6017       if (framesize &gt; 0) {
 6018         addptr(rbp, framesize);
 6019       }
 6020     }
 6021   }
 6022 
 6023   if (C-&gt;needs_stack_repair()) {
 6024     // Save stack increment (also account for fixed framesize and rbp)
 6025     assert((sp_inc &amp; (StackAlignmentInBytes-1)) == 0, &quot;stack increment not aligned&quot;);
<span class="line-modified"> 6026     movptr(Address(rsp, C-&gt;sp_inc_offset()), sp_inc + framesize + wordSize);</span>
 6027   }
 6028 
 6029   if (VerifyStackAtCalls) { // Majik cookie to verify stack depth
 6030     framesize -= wordSize;
 6031     movptr(Address(rsp, framesize), (int32_t)0xbadb100d);
 6032   }
 6033 
 6034 #ifndef _LP64
 6035   // If method sets FPU control word do it now
 6036   if (fp_mode_24b) {
 6037     fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
 6038   }
 6039   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
 6040     verify_FPU(0, &quot;FPU stack must be clean on entry&quot;);
 6041   }
 6042 #endif
 6043 
 6044 #ifdef ASSERT
 6045   if (VerifyStackAtCalls) {
 6046     Label L;
</pre>
<hr />
<pre>
 6441     ret_off = 0;
 6442   } else {
 6443     // C2 code ensures that sp_inc is a reserved slot.
 6444     ret_off = sp_inc;
 6445   }
 6446 
 6447   shuffle_value_args_common(is_packing, receiver_only, extra_stack_offset,
 6448                             sig_bt, sig_cc,
 6449                             args_passed, args_on_stack, regs,
 6450                             args_passed_to, args_on_stack_to, regs_to,
 6451                             sp_inc, ret_off);
 6452 }
 6453 
 6454 VMReg MacroAssembler::spill_reg_for(VMReg reg) {
 6455   return reg-&gt;is_XMMRegister() ? xmm8-&gt;as_VMReg() : r14-&gt;as_VMReg();
 6456 }
 6457 
 6458 void MacroAssembler::remove_frame(int initial_framesize, bool needs_stack_repair, int sp_inc_offset) {
 6459   assert((initial_framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
 6460   if (needs_stack_repair) {
<span class="line-removed"> 6461     // Restore rbp and repair rsp by adding the stack increment</span>
 6462     movq(rbp, Address(rsp, initial_framesize));
 6463     addq(rsp, Address(rsp, sp_inc_offset));
 6464   } else {
 6465     if (initial_framesize &gt; 0) {
 6466       addq(rsp, initial_framesize);
 6467     }
 6468     pop(rbp);
 6469   }
 6470 }
 6471 
 6472 void MacroAssembler::clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, bool is_large, bool word_copy_only) {
 6473   // cnt - number of qwords (8-byte words).
 6474   // base - start address, qword aligned.
 6475   // is_large - if optimizers know cnt is larger than InitArrayShortSize
 6476   assert(base==rdi, &quot;base register must be edi for rep stos&quot;);
 6477   assert(val==rax,   &quot;tmp register must be eax for rep stos&quot;);
 6478   assert(cnt==rcx,   &quot;cnt register must be ecx for rep stos&quot;);
 6479   assert(InitArrayShortSize % BytesPerLong == 0,
 6480     &quot;InitArrayShortSize should be the multiple of BytesPerLong&quot;);
 6481 
</pre>
<hr />
<pre>
 6498     jccb(Assembler::greaterEqual, LOOP);
 6499     jmpb(DONE);
 6500 
 6501     BIND(LONG);
 6502   }
 6503 
 6504   // Use longer rep-prefixed ops for non-small counts:
 6505   if (UseFastStosb &amp;&amp; !word_copy_only) {
 6506     shlptr(cnt, 3); // convert to number of bytes
 6507     rep_stosb();
 6508   } else if (UseXMMForObjInit) {
 6509     xmm_clear_mem(base, cnt, val, xtmp);
 6510   } else {
 6511     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
 6512     rep_stos();
 6513   }
 6514 
 6515   BIND(DONE);
 6516 }
 6517 
<span class="line-removed"> 6518 #ifdef COMPILER2</span>
<span class="line-removed"> 6519 </span>
<span class="line-removed"> 6520 // IndexOf for constant substrings with size &gt;= 8 chars</span>
<span class="line-removed"> 6521 // which don&#39;t need to be loaded through stack.</span>
<span class="line-removed"> 6522 void MacroAssembler::string_indexofC8(Register str1, Register str2,</span>
<span class="line-removed"> 6523                                       Register cnt1, Register cnt2,</span>
<span class="line-removed"> 6524                                       int int_cnt2,  Register result,</span>
<span class="line-removed"> 6525                                       XMMRegister vec, Register tmp,</span>
<span class="line-removed"> 6526                                       int ae) {</span>
<span class="line-removed"> 6527   ShortBranchVerifier sbv(this);</span>
<span class="line-removed"> 6528   assert(UseSSE42Intrinsics, &quot;SSE4.2 intrinsics are required&quot;);</span>
<span class="line-removed"> 6529   assert(ae != StrIntrinsicNode::LU, &quot;Invalid encoding&quot;);</span>
<span class="line-removed"> 6530 </span>
<span class="line-removed"> 6531   // This method uses the pcmpestri instruction with bound registers</span>
<span class="line-removed"> 6532   //   inputs:</span>
<span class="line-removed"> 6533   //     xmm - substring</span>
<span class="line-removed"> 6534   //     rax - substring length (elements count)</span>
<span class="line-removed"> 6535   //     mem - scanned string</span>
<span class="line-removed"> 6536   //     rdx - string length (elements count)</span>
<span class="line-removed"> 6537   //     0xd - mode: 1100 (substring search) + 01 (unsigned shorts)</span>
<span class="line-removed"> 6538   //     0xc - mode: 1100 (substring search) + 00 (unsigned bytes)</span>
<span class="line-removed"> 6539   //   outputs:</span>
<span class="line-removed"> 6540   //     rcx - matched index in string</span>
<span class="line-removed"> 6541   assert(cnt1 == rdx &amp;&amp; cnt2 == rax &amp;&amp; tmp == rcx, &quot;pcmpestri&quot;);</span>
<span class="line-removed"> 6542   int mode   = (ae == StrIntrinsicNode::LL) ? 0x0c : 0x0d; // bytes or shorts</span>
<span class="line-removed"> 6543   int stride = (ae == StrIntrinsicNode::LL) ? 16 : 8; //UU, UL -&gt; 8</span>
<span class="line-removed"> 6544   Address::ScaleFactor scale1 = (ae == StrIntrinsicNode::LL) ? Address::times_1 : Address::times_2;</span>
<span class="line-removed"> 6545   Address::ScaleFactor scale2 = (ae == StrIntrinsicNode::UL) ? Address::times_1 : scale1;</span>
<span class="line-removed"> 6546 </span>
<span class="line-removed"> 6547   Label RELOAD_SUBSTR, SCAN_TO_SUBSTR, SCAN_SUBSTR,</span>
<span class="line-removed"> 6548         RET_FOUND, RET_NOT_FOUND, EXIT, FOUND_SUBSTR,</span>
<span class="line-removed"> 6549         MATCH_SUBSTR_HEAD, RELOAD_STR, FOUND_CANDIDATE;</span>
<span class="line-removed"> 6550 </span>
<span class="line-removed"> 6551   // Note, inline_string_indexOf() generates checks:</span>
<span class="line-removed"> 6552   // if (substr.count &gt; string.count) return -1;</span>
<span class="line-removed"> 6553   // if (substr.count == 0) return 0;</span>
<span class="line-removed"> 6554   assert(int_cnt2 &gt;= stride, &quot;this code is used only for cnt2 &gt;= 8 chars&quot;);</span>
<span class="line-removed"> 6555 </span>
<span class="line-removed"> 6556   // Load substring.</span>
<span class="line-removed"> 6557   if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6558     pmovzxbw(vec, Address(str2, 0));</span>
<span class="line-removed"> 6559   } else {</span>
<span class="line-removed"> 6560     movdqu(vec, Address(str2, 0));</span>
<span class="line-removed"> 6561   }</span>
<span class="line-removed"> 6562   movl(cnt2, int_cnt2);</span>
<span class="line-removed"> 6563   movptr(result, str1); // string addr</span>
<span class="line-removed"> 6564 </span>
<span class="line-removed"> 6565   if (int_cnt2 &gt; stride) {</span>
<span class="line-removed"> 6566     jmpb(SCAN_TO_SUBSTR);</span>
<span class="line-removed"> 6567 </span>
<span class="line-removed"> 6568     // Reload substr for rescan, this code</span>
<span class="line-removed"> 6569     // is executed only for large substrings (&gt; 8 chars)</span>
<span class="line-removed"> 6570     bind(RELOAD_SUBSTR);</span>
<span class="line-removed"> 6571     if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6572       pmovzxbw(vec, Address(str2, 0));</span>
<span class="line-removed"> 6573     } else {</span>
<span class="line-removed"> 6574       movdqu(vec, Address(str2, 0));</span>
<span class="line-removed"> 6575     }</span>
<span class="line-removed"> 6576     negptr(cnt2); // Jumped here with negative cnt2, convert to positive</span>
<span class="line-removed"> 6577 </span>
<span class="line-removed"> 6578     bind(RELOAD_STR);</span>
<span class="line-removed"> 6579     // We came here after the beginning of the substring was</span>
<span class="line-removed"> 6580     // matched but the rest of it was not so we need to search</span>
<span class="line-removed"> 6581     // again. Start from the next element after the previous match.</span>
<span class="line-removed"> 6582 </span>
<span class="line-removed"> 6583     // cnt2 is number of substring reminding elements and</span>
<span class="line-removed"> 6584     // cnt1 is number of string reminding elements when cmp failed.</span>
<span class="line-removed"> 6585     // Restored cnt1 = cnt1 - cnt2 + int_cnt2</span>
<span class="line-removed"> 6586     subl(cnt1, cnt2);</span>
<span class="line-removed"> 6587     addl(cnt1, int_cnt2);</span>
<span class="line-removed"> 6588     movl(cnt2, int_cnt2); // Now restore cnt2</span>
<span class="line-removed"> 6589 </span>
<span class="line-removed"> 6590     decrementl(cnt1);     // Shift to next element</span>
<span class="line-removed"> 6591     cmpl(cnt1, cnt2);</span>
<span class="line-removed"> 6592     jcc(Assembler::negative, RET_NOT_FOUND);  // Left less then substring</span>
<span class="line-removed"> 6593 </span>
<span class="line-removed"> 6594     addptr(result, (1&lt;&lt;scale1));</span>
<span class="line-removed"> 6595 </span>
<span class="line-removed"> 6596   } // (int_cnt2 &gt; 8)</span>
<span class="line-removed"> 6597 </span>
<span class="line-removed"> 6598   // Scan string for start of substr in 16-byte vectors</span>
<span class="line-removed"> 6599   bind(SCAN_TO_SUBSTR);</span>
<span class="line-removed"> 6600   pcmpestri(vec, Address(result, 0), mode);</span>
<span class="line-removed"> 6601   jccb(Assembler::below, FOUND_CANDIDATE);   // CF == 1</span>
<span class="line-removed"> 6602   subl(cnt1, stride);</span>
<span class="line-removed"> 6603   jccb(Assembler::lessEqual, RET_NOT_FOUND); // Scanned full string</span>
<span class="line-removed"> 6604   cmpl(cnt1, cnt2);</span>
<span class="line-removed"> 6605   jccb(Assembler::negative, RET_NOT_FOUND);  // Left less then substring</span>
<span class="line-removed"> 6606   addptr(result, 16);</span>
<span class="line-removed"> 6607   jmpb(SCAN_TO_SUBSTR);</span>
<span class="line-removed"> 6608 </span>
<span class="line-removed"> 6609   // Found a potential substr</span>
<span class="line-removed"> 6610   bind(FOUND_CANDIDATE);</span>
<span class="line-removed"> 6611   // Matched whole vector if first element matched (tmp(rcx) == 0).</span>
<span class="line-removed"> 6612   if (int_cnt2 == stride) {</span>
<span class="line-removed"> 6613     jccb(Assembler::overflow, RET_FOUND);    // OF == 1</span>
<span class="line-removed"> 6614   } else { // int_cnt2 &gt; 8</span>
<span class="line-removed"> 6615     jccb(Assembler::overflow, FOUND_SUBSTR);</span>
<span class="line-removed"> 6616   }</span>
<span class="line-removed"> 6617   // After pcmpestri tmp(rcx) contains matched element index</span>
<span class="line-removed"> 6618   // Compute start addr of substr</span>
<span class="line-removed"> 6619   lea(result, Address(result, tmp, scale1));</span>
<span class="line-removed"> 6620 </span>
<span class="line-removed"> 6621   // Make sure string is still long enough</span>
<span class="line-removed"> 6622   subl(cnt1, tmp);</span>
<span class="line-removed"> 6623   cmpl(cnt1, cnt2);</span>
<span class="line-removed"> 6624   if (int_cnt2 == stride) {</span>
<span class="line-removed"> 6625     jccb(Assembler::greaterEqual, SCAN_TO_SUBSTR);</span>
<span class="line-removed"> 6626   } else { // int_cnt2 &gt; 8</span>
<span class="line-removed"> 6627     jccb(Assembler::greaterEqual, MATCH_SUBSTR_HEAD);</span>
<span class="line-removed"> 6628   }</span>
<span class="line-removed"> 6629   // Left less then substring.</span>
<span class="line-removed"> 6630 </span>
<span class="line-removed"> 6631   bind(RET_NOT_FOUND);</span>
<span class="line-removed"> 6632   movl(result, -1);</span>
<span class="line-removed"> 6633   jmp(EXIT);</span>
<span class="line-removed"> 6634 </span>
<span class="line-removed"> 6635   if (int_cnt2 &gt; stride) {</span>
<span class="line-removed"> 6636     // This code is optimized for the case when whole substring</span>
<span class="line-removed"> 6637     // is matched if its head is matched.</span>
<span class="line-removed"> 6638     bind(MATCH_SUBSTR_HEAD);</span>
<span class="line-removed"> 6639     pcmpestri(vec, Address(result, 0), mode);</span>
<span class="line-removed"> 6640     // Reload only string if does not match</span>
<span class="line-removed"> 6641     jcc(Assembler::noOverflow, RELOAD_STR); // OF == 0</span>
<span class="line-removed"> 6642 </span>
<span class="line-removed"> 6643     Label CONT_SCAN_SUBSTR;</span>
<span class="line-removed"> 6644     // Compare the rest of substring (&gt; 8 chars).</span>
<span class="line-removed"> 6645     bind(FOUND_SUBSTR);</span>
<span class="line-removed"> 6646     // First 8 chars are already matched.</span>
<span class="line-removed"> 6647     negptr(cnt2);</span>
<span class="line-removed"> 6648     addptr(cnt2, stride);</span>
<span class="line-removed"> 6649 </span>
<span class="line-removed"> 6650     bind(SCAN_SUBSTR);</span>
<span class="line-removed"> 6651     subl(cnt1, stride);</span>
<span class="line-removed"> 6652     cmpl(cnt2, -stride); // Do not read beyond substring</span>
<span class="line-removed"> 6653     jccb(Assembler::lessEqual, CONT_SCAN_SUBSTR);</span>
<span class="line-removed"> 6654     // Back-up strings to avoid reading beyond substring:</span>
<span class="line-removed"> 6655     // cnt1 = cnt1 - cnt2 + 8</span>
<span class="line-removed"> 6656     addl(cnt1, cnt2); // cnt2 is negative</span>
<span class="line-removed"> 6657     addl(cnt1, stride);</span>
<span class="line-removed"> 6658     movl(cnt2, stride); negptr(cnt2);</span>
<span class="line-removed"> 6659     bind(CONT_SCAN_SUBSTR);</span>
<span class="line-removed"> 6660     if (int_cnt2 &lt; (int)G) {</span>
<span class="line-removed"> 6661       int tail_off1 = int_cnt2&lt;&lt;scale1;</span>
<span class="line-removed"> 6662       int tail_off2 = int_cnt2&lt;&lt;scale2;</span>
<span class="line-removed"> 6663       if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6664         pmovzxbw(vec, Address(str2, cnt2, scale2, tail_off2));</span>
<span class="line-removed"> 6665       } else {</span>
<span class="line-removed"> 6666         movdqu(vec, Address(str2, cnt2, scale2, tail_off2));</span>
<span class="line-removed"> 6667       }</span>
<span class="line-removed"> 6668       pcmpestri(vec, Address(result, cnt2, scale1, tail_off1), mode);</span>
<span class="line-removed"> 6669     } else {</span>
<span class="line-removed"> 6670       // calculate index in register to avoid integer overflow (int_cnt2*2)</span>
<span class="line-removed"> 6671       movl(tmp, int_cnt2);</span>
<span class="line-removed"> 6672       addptr(tmp, cnt2);</span>
<span class="line-removed"> 6673       if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6674         pmovzxbw(vec, Address(str2, tmp, scale2, 0));</span>
<span class="line-removed"> 6675       } else {</span>
<span class="line-removed"> 6676         movdqu(vec, Address(str2, tmp, scale2, 0));</span>
<span class="line-removed"> 6677       }</span>
<span class="line-removed"> 6678       pcmpestri(vec, Address(result, tmp, scale1, 0), mode);</span>
<span class="line-removed"> 6679     }</span>
<span class="line-removed"> 6680     // Need to reload strings pointers if not matched whole vector</span>
<span class="line-removed"> 6681     jcc(Assembler::noOverflow, RELOAD_SUBSTR); // OF == 0</span>
<span class="line-removed"> 6682     addptr(cnt2, stride);</span>
<span class="line-removed"> 6683     jcc(Assembler::negative, SCAN_SUBSTR);</span>
<span class="line-removed"> 6684     // Fall through if found full substring</span>
<span class="line-removed"> 6685 </span>
<span class="line-removed"> 6686   } // (int_cnt2 &gt; 8)</span>
<span class="line-removed"> 6687 </span>
<span class="line-removed"> 6688   bind(RET_FOUND);</span>
<span class="line-removed"> 6689   // Found result if we matched full small substring.</span>
<span class="line-removed"> 6690   // Compute substr offset</span>
<span class="line-removed"> 6691   subptr(result, str1);</span>
<span class="line-removed"> 6692   if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6693     shrl(result, 1); // index</span>
<span class="line-removed"> 6694   }</span>
<span class="line-removed"> 6695   bind(EXIT);</span>
<span class="line-removed"> 6696 </span>
<span class="line-removed"> 6697 } // string_indexofC8</span>
<span class="line-removed"> 6698 </span>
<span class="line-removed"> 6699 // Small strings are loaded through stack if they cross page boundary.</span>
<span class="line-removed"> 6700 void MacroAssembler::string_indexof(Register str1, Register str2,</span>
<span class="line-removed"> 6701                                     Register cnt1, Register cnt2,</span>
<span class="line-removed"> 6702                                     int int_cnt2,  Register result,</span>
<span class="line-removed"> 6703                                     XMMRegister vec, Register tmp,</span>
<span class="line-removed"> 6704                                     int ae) {</span>
<span class="line-removed"> 6705   ShortBranchVerifier sbv(this);</span>
<span class="line-removed"> 6706   assert(UseSSE42Intrinsics, &quot;SSE4.2 intrinsics are required&quot;);</span>
<span class="line-removed"> 6707   assert(ae != StrIntrinsicNode::LU, &quot;Invalid encoding&quot;);</span>
<span class="line-removed"> 6708 </span>
<span class="line-removed"> 6709   //</span>
<span class="line-removed"> 6710   // int_cnt2 is length of small (&lt; 8 chars) constant substring</span>
<span class="line-removed"> 6711   // or (-1) for non constant substring in which case its length</span>
<span class="line-removed"> 6712   // is in cnt2 register.</span>
<span class="line-removed"> 6713   //</span>
<span class="line-removed"> 6714   // Note, inline_string_indexOf() generates checks:</span>
<span class="line-removed"> 6715   // if (substr.count &gt; string.count) return -1;</span>
<span class="line-removed"> 6716   // if (substr.count == 0) return 0;</span>
<span class="line-removed"> 6717   //</span>
<span class="line-removed"> 6718   int stride = (ae == StrIntrinsicNode::LL) ? 16 : 8; //UU, UL -&gt; 8</span>
<span class="line-removed"> 6719   assert(int_cnt2 == -1 || (0 &lt; int_cnt2 &amp;&amp; int_cnt2 &lt; stride), &quot;should be != 0&quot;);</span>
<span class="line-removed"> 6720   // This method uses the pcmpestri instruction with bound registers</span>
<span class="line-removed"> 6721   //   inputs:</span>
<span class="line-removed"> 6722   //     xmm - substring</span>
<span class="line-removed"> 6723   //     rax - substring length (elements count)</span>
<span class="line-removed"> 6724   //     mem - scanned string</span>
<span class="line-removed"> 6725   //     rdx - string length (elements count)</span>
<span class="line-removed"> 6726   //     0xd - mode: 1100 (substring search) + 01 (unsigned shorts)</span>
<span class="line-removed"> 6727   //     0xc - mode: 1100 (substring search) + 00 (unsigned bytes)</span>
<span class="line-removed"> 6728   //   outputs:</span>
<span class="line-removed"> 6729   //     rcx - matched index in string</span>
<span class="line-removed"> 6730   assert(cnt1 == rdx &amp;&amp; cnt2 == rax &amp;&amp; tmp == rcx, &quot;pcmpestri&quot;);</span>
<span class="line-removed"> 6731   int mode = (ae == StrIntrinsicNode::LL) ? 0x0c : 0x0d; // bytes or shorts</span>
<span class="line-removed"> 6732   Address::ScaleFactor scale1 = (ae == StrIntrinsicNode::LL) ? Address::times_1 : Address::times_2;</span>
<span class="line-removed"> 6733   Address::ScaleFactor scale2 = (ae == StrIntrinsicNode::UL) ? Address::times_1 : scale1;</span>
<span class="line-removed"> 6734 </span>
<span class="line-removed"> 6735   Label RELOAD_SUBSTR, SCAN_TO_SUBSTR, SCAN_SUBSTR, ADJUST_STR,</span>
<span class="line-removed"> 6736         RET_FOUND, RET_NOT_FOUND, CLEANUP, FOUND_SUBSTR,</span>
<span class="line-removed"> 6737         FOUND_CANDIDATE;</span>
<span class="line-removed"> 6738 </span>
<span class="line-removed"> 6739   { //========================================================</span>
<span class="line-removed"> 6740     // We don&#39;t know where these strings are located</span>
<span class="line-removed"> 6741     // and we can&#39;t read beyond them. Load them through stack.</span>
<span class="line-removed"> 6742     Label BIG_STRINGS, CHECK_STR, COPY_SUBSTR, COPY_STR;</span>
<span class="line-removed"> 6743 </span>
<span class="line-removed"> 6744     movptr(tmp, rsp); // save old SP</span>
<span class="line-removed"> 6745 </span>
<span class="line-removed"> 6746     if (int_cnt2 &gt; 0) {     // small (&lt; 8 chars) constant substring</span>
<span class="line-removed"> 6747       if (int_cnt2 == (1&gt;&gt;scale2)) { // One byte</span>
<span class="line-removed"> 6748         assert((ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UL), &quot;Only possible for latin1 encoding&quot;);</span>
<span class="line-removed"> 6749         load_unsigned_byte(result, Address(str2, 0));</span>
<span class="line-removed"> 6750         movdl(vec, result); // move 32 bits</span>
<span class="line-removed"> 6751       } else if (ae == StrIntrinsicNode::LL &amp;&amp; int_cnt2 == 3) {  // Three bytes</span>
<span class="line-removed"> 6752         // Not enough header space in 32-bit VM: 12+3 = 15.</span>
<span class="line-removed"> 6753         movl(result, Address(str2, -1));</span>
<span class="line-removed"> 6754         shrl(result, 8);</span>
<span class="line-removed"> 6755         movdl(vec, result); // move 32 bits</span>
<span class="line-removed"> 6756       } else if (ae != StrIntrinsicNode::UL &amp;&amp; int_cnt2 == (2&gt;&gt;scale2)) {  // One char</span>
<span class="line-removed"> 6757         load_unsigned_short(result, Address(str2, 0));</span>
<span class="line-removed"> 6758         movdl(vec, result); // move 32 bits</span>
<span class="line-removed"> 6759       } else if (ae != StrIntrinsicNode::UL &amp;&amp; int_cnt2 == (4&gt;&gt;scale2)) { // Two chars</span>
<span class="line-removed"> 6760         movdl(vec, Address(str2, 0)); // move 32 bits</span>
<span class="line-removed"> 6761       } else if (ae != StrIntrinsicNode::UL &amp;&amp; int_cnt2 == (8&gt;&gt;scale2)) { // Four chars</span>
<span class="line-removed"> 6762         movq(vec, Address(str2, 0));  // move 64 bits</span>
<span class="line-removed"> 6763       } else { // cnt2 = { 3, 5, 6, 7 } || (ae == StrIntrinsicNode::UL &amp;&amp; cnt2 ={2, ..., 7})</span>
<span class="line-removed"> 6764         // Array header size is 12 bytes in 32-bit VM</span>
<span class="line-removed"> 6765         // + 6 bytes for 3 chars == 18 bytes,</span>
<span class="line-removed"> 6766         // enough space to load vec and shift.</span>
<span class="line-removed"> 6767         assert(HeapWordSize*TypeArrayKlass::header_size() &gt;= 12,&quot;sanity&quot;);</span>
<span class="line-removed"> 6768         if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6769           int tail_off = int_cnt2-8;</span>
<span class="line-removed"> 6770           pmovzxbw(vec, Address(str2, tail_off));</span>
<span class="line-removed"> 6771           psrldq(vec, -2*tail_off);</span>
<span class="line-removed"> 6772         }</span>
<span class="line-removed"> 6773         else {</span>
<span class="line-removed"> 6774           int tail_off = int_cnt2*(1&lt;&lt;scale2);</span>
<span class="line-removed"> 6775           movdqu(vec, Address(str2, tail_off-16));</span>
<span class="line-removed"> 6776           psrldq(vec, 16-tail_off);</span>
<span class="line-removed"> 6777         }</span>
<span class="line-removed"> 6778       }</span>
<span class="line-removed"> 6779     } else { // not constant substring</span>
<span class="line-removed"> 6780       cmpl(cnt2, stride);</span>
<span class="line-removed"> 6781       jccb(Assembler::aboveEqual, BIG_STRINGS); // Both strings are big enough</span>
<span class="line-removed"> 6782 </span>
<span class="line-removed"> 6783       // We can read beyond string if srt+16 does not cross page boundary</span>
<span class="line-removed"> 6784       // since heaps are aligned and mapped by pages.</span>
<span class="line-removed"> 6785       assert(os::vm_page_size() &lt; (int)G, &quot;default page should be small&quot;);</span>
<span class="line-removed"> 6786       movl(result, str2); // We need only low 32 bits</span>
<span class="line-removed"> 6787       andl(result, (os::vm_page_size()-1));</span>
<span class="line-removed"> 6788       cmpl(result, (os::vm_page_size()-16));</span>
<span class="line-removed"> 6789       jccb(Assembler::belowEqual, CHECK_STR);</span>
<span class="line-removed"> 6790 </span>
<span class="line-removed"> 6791       // Move small strings to stack to allow load 16 bytes into vec.</span>
<span class="line-removed"> 6792       subptr(rsp, 16);</span>
<span class="line-removed"> 6793       int stk_offset = wordSize-(1&lt;&lt;scale2);</span>
<span class="line-removed"> 6794       push(cnt2);</span>
<span class="line-removed"> 6795 </span>
<span class="line-removed"> 6796       bind(COPY_SUBSTR);</span>
<span class="line-removed"> 6797       if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6798         load_unsigned_byte(result, Address(str2, cnt2, scale2, -1));</span>
<span class="line-removed"> 6799         movb(Address(rsp, cnt2, scale2, stk_offset), result);</span>
<span class="line-removed"> 6800       } else if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 6801         load_unsigned_short(result, Address(str2, cnt2, scale2, -2));</span>
<span class="line-removed"> 6802         movw(Address(rsp, cnt2, scale2, stk_offset), result);</span>
<span class="line-removed"> 6803       }</span>
<span class="line-removed"> 6804       decrement(cnt2);</span>
<span class="line-removed"> 6805       jccb(Assembler::notZero, COPY_SUBSTR);</span>
<span class="line-removed"> 6806 </span>
<span class="line-removed"> 6807       pop(cnt2);</span>
<span class="line-removed"> 6808       movptr(str2, rsp);  // New substring address</span>
<span class="line-removed"> 6809     } // non constant</span>
<span class="line-removed"> 6810 </span>
<span class="line-removed"> 6811     bind(CHECK_STR);</span>
<span class="line-removed"> 6812     cmpl(cnt1, stride);</span>
<span class="line-removed"> 6813     jccb(Assembler::aboveEqual, BIG_STRINGS);</span>
<span class="line-removed"> 6814 </span>
<span class="line-removed"> 6815     // Check cross page boundary.</span>
<span class="line-removed"> 6816     movl(result, str1); // We need only low 32 bits</span>
<span class="line-removed"> 6817     andl(result, (os::vm_page_size()-1));</span>
<span class="line-removed"> 6818     cmpl(result, (os::vm_page_size()-16));</span>
<span class="line-removed"> 6819     jccb(Assembler::belowEqual, BIG_STRINGS);</span>
<span class="line-removed"> 6820 </span>
<span class="line-removed"> 6821     subptr(rsp, 16);</span>
<span class="line-removed"> 6822     int stk_offset = -(1&lt;&lt;scale1);</span>
<span class="line-removed"> 6823     if (int_cnt2 &lt; 0) { // not constant</span>
<span class="line-removed"> 6824       push(cnt2);</span>
<span class="line-removed"> 6825       stk_offset += wordSize;</span>
<span class="line-removed"> 6826     }</span>
<span class="line-removed"> 6827     movl(cnt2, cnt1);</span>
<span class="line-removed"> 6828 </span>
<span class="line-removed"> 6829     bind(COPY_STR);</span>
<span class="line-removed"> 6830     if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 6831       load_unsigned_byte(result, Address(str1, cnt2, scale1, -1));</span>
<span class="line-removed"> 6832       movb(Address(rsp, cnt2, scale1, stk_offset), result);</span>
<span class="line-removed"> 6833     } else {</span>
<span class="line-removed"> 6834       load_unsigned_short(result, Address(str1, cnt2, scale1, -2));</span>
<span class="line-removed"> 6835       movw(Address(rsp, cnt2, scale1, stk_offset), result);</span>
<span class="line-removed"> 6836     }</span>
<span class="line-removed"> 6837     decrement(cnt2);</span>
<span class="line-removed"> 6838     jccb(Assembler::notZero, COPY_STR);</span>
<span class="line-removed"> 6839 </span>
<span class="line-removed"> 6840     if (int_cnt2 &lt; 0) { // not constant</span>
<span class="line-removed"> 6841       pop(cnt2);</span>
<span class="line-removed"> 6842     }</span>
<span class="line-removed"> 6843     movptr(str1, rsp);  // New string address</span>
<span class="line-removed"> 6844 </span>
<span class="line-removed"> 6845     bind(BIG_STRINGS);</span>
<span class="line-removed"> 6846     // Load substring.</span>
<span class="line-removed"> 6847     if (int_cnt2 &lt; 0) { // -1</span>
<span class="line-removed"> 6848       if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6849         pmovzxbw(vec, Address(str2, 0));</span>
<span class="line-removed"> 6850       } else {</span>
<span class="line-removed"> 6851         movdqu(vec, Address(str2, 0));</span>
<span class="line-removed"> 6852       }</span>
<span class="line-removed"> 6853       push(cnt2);       // substr count</span>
<span class="line-removed"> 6854       push(str2);       // substr addr</span>
<span class="line-removed"> 6855       push(str1);       // string addr</span>
<span class="line-removed"> 6856     } else {</span>
<span class="line-removed"> 6857       // Small (&lt; 8 chars) constant substrings are loaded already.</span>
<span class="line-removed"> 6858       movl(cnt2, int_cnt2);</span>
<span class="line-removed"> 6859     }</span>
<span class="line-removed"> 6860     push(tmp);  // original SP</span>
<span class="line-removed"> 6861 </span>
<span class="line-removed"> 6862   } // Finished loading</span>
<span class="line-removed"> 6863 </span>
<span class="line-removed"> 6864   //========================================================</span>
<span class="line-removed"> 6865   // Start search</span>
<span class="line-removed"> 6866   //</span>
<span class="line-removed"> 6867 </span>
<span class="line-removed"> 6868   movptr(result, str1); // string addr</span>
<span class="line-removed"> 6869 </span>
<span class="line-removed"> 6870   if (int_cnt2  &lt; 0) {  // Only for non constant substring</span>
<span class="line-removed"> 6871     jmpb(SCAN_TO_SUBSTR);</span>
<span class="line-removed"> 6872 </span>
<span class="line-removed"> 6873     // SP saved at sp+0</span>
<span class="line-removed"> 6874     // String saved at sp+1*wordSize</span>
<span class="line-removed"> 6875     // Substr saved at sp+2*wordSize</span>
<span class="line-removed"> 6876     // Substr count saved at sp+3*wordSize</span>
<span class="line-removed"> 6877 </span>
<span class="line-removed"> 6878     // Reload substr for rescan, this code</span>
<span class="line-removed"> 6879     // is executed only for large substrings (&gt; 8 chars)</span>
<span class="line-removed"> 6880     bind(RELOAD_SUBSTR);</span>
<span class="line-removed"> 6881     movptr(str2, Address(rsp, 2*wordSize));</span>
<span class="line-removed"> 6882     movl(cnt2, Address(rsp, 3*wordSize));</span>
<span class="line-removed"> 6883     if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6884       pmovzxbw(vec, Address(str2, 0));</span>
<span class="line-removed"> 6885     } else {</span>
<span class="line-removed"> 6886       movdqu(vec, Address(str2, 0));</span>
<span class="line-removed"> 6887     }</span>
<span class="line-removed"> 6888     // We came here after the beginning of the substring was</span>
<span class="line-removed"> 6889     // matched but the rest of it was not so we need to search</span>
<span class="line-removed"> 6890     // again. Start from the next element after the previous match.</span>
<span class="line-removed"> 6891     subptr(str1, result); // Restore counter</span>
<span class="line-removed"> 6892     if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6893       shrl(str1, 1);</span>
<span class="line-removed"> 6894     }</span>
<span class="line-removed"> 6895     addl(cnt1, str1);</span>
<span class="line-removed"> 6896     decrementl(cnt1);   // Shift to next element</span>
<span class="line-removed"> 6897     cmpl(cnt1, cnt2);</span>
<span class="line-removed"> 6898     jcc(Assembler::negative, RET_NOT_FOUND);  // Left less then substring</span>
<span class="line-removed"> 6899 </span>
<span class="line-removed"> 6900     addptr(result, (1&lt;&lt;scale1));</span>
<span class="line-removed"> 6901   } // non constant</span>
<span class="line-removed"> 6902 </span>
<span class="line-removed"> 6903   // Scan string for start of substr in 16-byte vectors</span>
<span class="line-removed"> 6904   bind(SCAN_TO_SUBSTR);</span>
<span class="line-removed"> 6905   assert(cnt1 == rdx &amp;&amp; cnt2 == rax &amp;&amp; tmp == rcx, &quot;pcmpestri&quot;);</span>
<span class="line-removed"> 6906   pcmpestri(vec, Address(result, 0), mode);</span>
<span class="line-removed"> 6907   jccb(Assembler::below, FOUND_CANDIDATE);   // CF == 1</span>
<span class="line-removed"> 6908   subl(cnt1, stride);</span>
<span class="line-removed"> 6909   jccb(Assembler::lessEqual, RET_NOT_FOUND); // Scanned full string</span>
<span class="line-removed"> 6910   cmpl(cnt1, cnt2);</span>
<span class="line-removed"> 6911   jccb(Assembler::negative, RET_NOT_FOUND);  // Left less then substring</span>
<span class="line-removed"> 6912   addptr(result, 16);</span>
<span class="line-removed"> 6913 </span>
<span class="line-removed"> 6914   bind(ADJUST_STR);</span>
<span class="line-removed"> 6915   cmpl(cnt1, stride); // Do not read beyond string</span>
<span class="line-removed"> 6916   jccb(Assembler::greaterEqual, SCAN_TO_SUBSTR);</span>
<span class="line-removed"> 6917   // Back-up string to avoid reading beyond string.</span>
<span class="line-removed"> 6918   lea(result, Address(result, cnt1, scale1, -16));</span>
<span class="line-removed"> 6919   movl(cnt1, stride);</span>
<span class="line-removed"> 6920   jmpb(SCAN_TO_SUBSTR);</span>
<span class="line-removed"> 6921 </span>
<span class="line-removed"> 6922   // Found a potential substr</span>
<span class="line-removed"> 6923   bind(FOUND_CANDIDATE);</span>
<span class="line-removed"> 6924   // After pcmpestri tmp(rcx) contains matched element index</span>
<span class="line-removed"> 6925 </span>
<span class="line-removed"> 6926   // Make sure string is still long enough</span>
<span class="line-removed"> 6927   subl(cnt1, tmp);</span>
<span class="line-removed"> 6928   cmpl(cnt1, cnt2);</span>
<span class="line-removed"> 6929   jccb(Assembler::greaterEqual, FOUND_SUBSTR);</span>
<span class="line-removed"> 6930   // Left less then substring.</span>
<span class="line-removed"> 6931 </span>
<span class="line-removed"> 6932   bind(RET_NOT_FOUND);</span>
<span class="line-removed"> 6933   movl(result, -1);</span>
<span class="line-removed"> 6934   jmp(CLEANUP);</span>
<span class="line-removed"> 6935 </span>
<span class="line-removed"> 6936   bind(FOUND_SUBSTR);</span>
<span class="line-removed"> 6937   // Compute start addr of substr</span>
<span class="line-removed"> 6938   lea(result, Address(result, tmp, scale1));</span>
<span class="line-removed"> 6939   if (int_cnt2 &gt; 0) { // Constant substring</span>
<span class="line-removed"> 6940     // Repeat search for small substring (&lt; 8 chars)</span>
<span class="line-removed"> 6941     // from new point without reloading substring.</span>
<span class="line-removed"> 6942     // Have to check that we don&#39;t read beyond string.</span>
<span class="line-removed"> 6943     cmpl(tmp, stride-int_cnt2);</span>
<span class="line-removed"> 6944     jccb(Assembler::greater, ADJUST_STR);</span>
<span class="line-removed"> 6945     // Fall through if matched whole substring.</span>
<span class="line-removed"> 6946   } else { // non constant</span>
<span class="line-removed"> 6947     assert(int_cnt2 == -1, &quot;should be != 0&quot;);</span>
<span class="line-removed"> 6948 </span>
<span class="line-removed"> 6949     addl(tmp, cnt2);</span>
<span class="line-removed"> 6950     // Found result if we matched whole substring.</span>
<span class="line-removed"> 6951     cmpl(tmp, stride);</span>
<span class="line-removed"> 6952     jcc(Assembler::lessEqual, RET_FOUND);</span>
<span class="line-removed"> 6953 </span>
<span class="line-removed"> 6954     // Repeat search for small substring (&lt;= 8 chars)</span>
<span class="line-removed"> 6955     // from new point &#39;str1&#39; without reloading substring.</span>
<span class="line-removed"> 6956     cmpl(cnt2, stride);</span>
<span class="line-removed"> 6957     // Have to check that we don&#39;t read beyond string.</span>
<span class="line-removed"> 6958     jccb(Assembler::lessEqual, ADJUST_STR);</span>
<span class="line-removed"> 6959 </span>
<span class="line-removed"> 6960     Label CHECK_NEXT, CONT_SCAN_SUBSTR, RET_FOUND_LONG;</span>
<span class="line-removed"> 6961     // Compare the rest of substring (&gt; 8 chars).</span>
<span class="line-removed"> 6962     movptr(str1, result);</span>
<span class="line-removed"> 6963 </span>
<span class="line-removed"> 6964     cmpl(tmp, cnt2);</span>
<span class="line-removed"> 6965     // First 8 chars are already matched.</span>
<span class="line-removed"> 6966     jccb(Assembler::equal, CHECK_NEXT);</span>
<span class="line-removed"> 6967 </span>
<span class="line-removed"> 6968     bind(SCAN_SUBSTR);</span>
<span class="line-removed"> 6969     pcmpestri(vec, Address(str1, 0), mode);</span>
<span class="line-removed"> 6970     // Need to reload strings pointers if not matched whole vector</span>
<span class="line-removed"> 6971     jcc(Assembler::noOverflow, RELOAD_SUBSTR); // OF == 0</span>
<span class="line-removed"> 6972 </span>
<span class="line-removed"> 6973     bind(CHECK_NEXT);</span>
<span class="line-removed"> 6974     subl(cnt2, stride);</span>
<span class="line-removed"> 6975     jccb(Assembler::lessEqual, RET_FOUND_LONG); // Found full substring</span>
<span class="line-removed"> 6976     addptr(str1, 16);</span>
<span class="line-removed"> 6977     if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6978       addptr(str2, 8);</span>
<span class="line-removed"> 6979     } else {</span>
<span class="line-removed"> 6980       addptr(str2, 16);</span>
<span class="line-removed"> 6981     }</span>
<span class="line-removed"> 6982     subl(cnt1, stride);</span>
<span class="line-removed"> 6983     cmpl(cnt2, stride); // Do not read beyond substring</span>
<span class="line-removed"> 6984     jccb(Assembler::greaterEqual, CONT_SCAN_SUBSTR);</span>
<span class="line-removed"> 6985     // Back-up strings to avoid reading beyond substring.</span>
<span class="line-removed"> 6986 </span>
<span class="line-removed"> 6987     if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6988       lea(str2, Address(str2, cnt2, scale2, -8));</span>
<span class="line-removed"> 6989       lea(str1, Address(str1, cnt2, scale1, -16));</span>
<span class="line-removed"> 6990     } else {</span>
<span class="line-removed"> 6991       lea(str2, Address(str2, cnt2, scale2, -16));</span>
<span class="line-removed"> 6992       lea(str1, Address(str1, cnt2, scale1, -16));</span>
<span class="line-removed"> 6993     }</span>
<span class="line-removed"> 6994     subl(cnt1, cnt2);</span>
<span class="line-removed"> 6995     movl(cnt2, stride);</span>
<span class="line-removed"> 6996     addl(cnt1, stride);</span>
<span class="line-removed"> 6997     bind(CONT_SCAN_SUBSTR);</span>
<span class="line-removed"> 6998     if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 6999       pmovzxbw(vec, Address(str2, 0));</span>
<span class="line-removed"> 7000     } else {</span>
<span class="line-removed"> 7001       movdqu(vec, Address(str2, 0));</span>
<span class="line-removed"> 7002     }</span>
<span class="line-removed"> 7003     jmp(SCAN_SUBSTR);</span>
<span class="line-removed"> 7004 </span>
<span class="line-removed"> 7005     bind(RET_FOUND_LONG);</span>
<span class="line-removed"> 7006     movptr(str1, Address(rsp, wordSize));</span>
<span class="line-removed"> 7007   } // non constant</span>
<span class="line-removed"> 7008 </span>
<span class="line-removed"> 7009   bind(RET_FOUND);</span>
<span class="line-removed"> 7010   // Compute substr offset</span>
<span class="line-removed"> 7011   subptr(result, str1);</span>
<span class="line-removed"> 7012   if (ae == StrIntrinsicNode::UU || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 7013     shrl(result, 1); // index</span>
<span class="line-removed"> 7014   }</span>
<span class="line-removed"> 7015   bind(CLEANUP);</span>
<span class="line-removed"> 7016   pop(rsp); // restore SP</span>
<span class="line-removed"> 7017 </span>
<span class="line-removed"> 7018 } // string_indexof</span>
<span class="line-removed"> 7019 </span>
<span class="line-removed"> 7020 void MacroAssembler::string_indexof_char(Register str1, Register cnt1, Register ch, Register result,</span>
<span class="line-removed"> 7021                                          XMMRegister vec1, XMMRegister vec2, XMMRegister vec3, Register tmp) {</span>
<span class="line-removed"> 7022   ShortBranchVerifier sbv(this);</span>
<span class="line-removed"> 7023   assert(UseSSE42Intrinsics, &quot;SSE4.2 intrinsics are required&quot;);</span>
<span class="line-removed"> 7024 </span>
<span class="line-removed"> 7025   int stride = 8;</span>
<span class="line-removed"> 7026 </span>
<span class="line-removed"> 7027   Label FOUND_CHAR, SCAN_TO_CHAR, SCAN_TO_CHAR_LOOP,</span>
<span class="line-removed"> 7028         SCAN_TO_8_CHAR, SCAN_TO_8_CHAR_LOOP, SCAN_TO_16_CHAR_LOOP,</span>
<span class="line-removed"> 7029         RET_NOT_FOUND, SCAN_TO_8_CHAR_INIT,</span>
<span class="line-removed"> 7030         FOUND_SEQ_CHAR, DONE_LABEL;</span>
<span class="line-removed"> 7031 </span>
<span class="line-removed"> 7032   movptr(result, str1);</span>
<span class="line-removed"> 7033   if (UseAVX &gt;= 2) {</span>
<span class="line-removed"> 7034     cmpl(cnt1, stride);</span>
<span class="line-removed"> 7035     jcc(Assembler::less, SCAN_TO_CHAR);</span>
<span class="line-removed"> 7036     cmpl(cnt1, 2*stride);</span>
<span class="line-removed"> 7037     jcc(Assembler::less, SCAN_TO_8_CHAR_INIT);</span>
<span class="line-removed"> 7038     movdl(vec1, ch);</span>
<span class="line-removed"> 7039     vpbroadcastw(vec1, vec1, Assembler::AVX_256bit);</span>
<span class="line-removed"> 7040     vpxor(vec2, vec2);</span>
<span class="line-removed"> 7041     movl(tmp, cnt1);</span>
<span class="line-removed"> 7042     andl(tmp, 0xFFFFFFF0);  //vector count (in chars)</span>
<span class="line-removed"> 7043     andl(cnt1,0x0000000F);  //tail count (in chars)</span>
<span class="line-removed"> 7044 </span>
<span class="line-removed"> 7045     bind(SCAN_TO_16_CHAR_LOOP);</span>
<span class="line-removed"> 7046     vmovdqu(vec3, Address(result, 0));</span>
<span class="line-removed"> 7047     vpcmpeqw(vec3, vec3, vec1, 1);</span>
<span class="line-removed"> 7048     vptest(vec2, vec3);</span>
<span class="line-removed"> 7049     jcc(Assembler::carryClear, FOUND_CHAR);</span>
<span class="line-removed"> 7050     addptr(result, 32);</span>
<span class="line-removed"> 7051     subl(tmp, 2*stride);</span>
<span class="line-removed"> 7052     jcc(Assembler::notZero, SCAN_TO_16_CHAR_LOOP);</span>
<span class="line-removed"> 7053     jmp(SCAN_TO_8_CHAR);</span>
<span class="line-removed"> 7054     bind(SCAN_TO_8_CHAR_INIT);</span>
<span class="line-removed"> 7055     movdl(vec1, ch);</span>
<span class="line-removed"> 7056     pshuflw(vec1, vec1, 0x00);</span>
<span class="line-removed"> 7057     pshufd(vec1, vec1, 0);</span>
<span class="line-removed"> 7058     pxor(vec2, vec2);</span>
<span class="line-removed"> 7059   }</span>
<span class="line-removed"> 7060   bind(SCAN_TO_8_CHAR);</span>
<span class="line-removed"> 7061   cmpl(cnt1, stride);</span>
<span class="line-removed"> 7062   jcc(Assembler::less, SCAN_TO_CHAR);</span>
<span class="line-removed"> 7063   if (UseAVX &lt; 2) {</span>
<span class="line-removed"> 7064     movdl(vec1, ch);</span>
<span class="line-removed"> 7065     pshuflw(vec1, vec1, 0x00);</span>
<span class="line-removed"> 7066     pshufd(vec1, vec1, 0);</span>
<span class="line-removed"> 7067     pxor(vec2, vec2);</span>
<span class="line-removed"> 7068   }</span>
<span class="line-removed"> 7069   movl(tmp, cnt1);</span>
<span class="line-removed"> 7070   andl(tmp, 0xFFFFFFF8);  //vector count (in chars)</span>
<span class="line-removed"> 7071   andl(cnt1,0x00000007);  //tail count (in chars)</span>
<span class="line-removed"> 7072 </span>
<span class="line-removed"> 7073   bind(SCAN_TO_8_CHAR_LOOP);</span>
<span class="line-removed"> 7074   movdqu(vec3, Address(result, 0));</span>
<span class="line-removed"> 7075   pcmpeqw(vec3, vec1);</span>
<span class="line-removed"> 7076   ptest(vec2, vec3);</span>
<span class="line-removed"> 7077   jcc(Assembler::carryClear, FOUND_CHAR);</span>
<span class="line-removed"> 7078   addptr(result, 16);</span>
<span class="line-removed"> 7079   subl(tmp, stride);</span>
<span class="line-removed"> 7080   jcc(Assembler::notZero, SCAN_TO_8_CHAR_LOOP);</span>
<span class="line-removed"> 7081   bind(SCAN_TO_CHAR);</span>
<span class="line-removed"> 7082   testl(cnt1, cnt1);</span>
<span class="line-removed"> 7083   jcc(Assembler::zero, RET_NOT_FOUND);</span>
<span class="line-removed"> 7084   bind(SCAN_TO_CHAR_LOOP);</span>
<span class="line-removed"> 7085   load_unsigned_short(tmp, Address(result, 0));</span>
<span class="line-removed"> 7086   cmpl(ch, tmp);</span>
<span class="line-removed"> 7087   jccb(Assembler::equal, FOUND_SEQ_CHAR);</span>
<span class="line-removed"> 7088   addptr(result, 2);</span>
<span class="line-removed"> 7089   subl(cnt1, 1);</span>
<span class="line-removed"> 7090   jccb(Assembler::zero, RET_NOT_FOUND);</span>
<span class="line-removed"> 7091   jmp(SCAN_TO_CHAR_LOOP);</span>
<span class="line-removed"> 7092 </span>
<span class="line-removed"> 7093   bind(RET_NOT_FOUND);</span>
<span class="line-removed"> 7094   movl(result, -1);</span>
<span class="line-removed"> 7095   jmpb(DONE_LABEL);</span>
<span class="line-removed"> 7096 </span>
<span class="line-removed"> 7097   bind(FOUND_CHAR);</span>
<span class="line-removed"> 7098   if (UseAVX &gt;= 2) {</span>
<span class="line-removed"> 7099     vpmovmskb(tmp, vec3);</span>
<span class="line-removed"> 7100   } else {</span>
<span class="line-removed"> 7101     pmovmskb(tmp, vec3);</span>
<span class="line-removed"> 7102   }</span>
<span class="line-removed"> 7103   bsfl(ch, tmp);</span>
<span class="line-removed"> 7104   addl(result, ch);</span>
<span class="line-removed"> 7105 </span>
<span class="line-removed"> 7106   bind(FOUND_SEQ_CHAR);</span>
<span class="line-removed"> 7107   subptr(result, str1);</span>
<span class="line-removed"> 7108   shrl(result, 1);</span>
<span class="line-removed"> 7109 </span>
<span class="line-removed"> 7110   bind(DONE_LABEL);</span>
<span class="line-removed"> 7111 } // string_indexof_char</span>
<span class="line-removed"> 7112 </span>
<span class="line-removed"> 7113 // helper function for string_compare</span>
<span class="line-removed"> 7114 void MacroAssembler::load_next_elements(Register elem1, Register elem2, Register str1, Register str2,</span>
<span class="line-removed"> 7115                                         Address::ScaleFactor scale, Address::ScaleFactor scale1,</span>
<span class="line-removed"> 7116                                         Address::ScaleFactor scale2, Register index, int ae) {</span>
<span class="line-removed"> 7117   if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 7118     load_unsigned_byte(elem1, Address(str1, index, scale, 0));</span>
<span class="line-removed"> 7119     load_unsigned_byte(elem2, Address(str2, index, scale, 0));</span>
<span class="line-removed"> 7120   } else if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 7121     load_unsigned_short(elem1, Address(str1, index, scale, 0));</span>
<span class="line-removed"> 7122     load_unsigned_short(elem2, Address(str2, index, scale, 0));</span>
<span class="line-removed"> 7123   } else {</span>
<span class="line-removed"> 7124     load_unsigned_byte(elem1, Address(str1, index, scale1, 0));</span>
<span class="line-removed"> 7125     load_unsigned_short(elem2, Address(str2, index, scale2, 0));</span>
<span class="line-removed"> 7126   }</span>
<span class="line-removed"> 7127 }</span>
<span class="line-removed"> 7128 </span>
<span class="line-removed"> 7129 // Compare strings, used for char[] and byte[].</span>
<span class="line-removed"> 7130 void MacroAssembler::string_compare(Register str1, Register str2,</span>
<span class="line-removed"> 7131                                     Register cnt1, Register cnt2, Register result,</span>
<span class="line-removed"> 7132                                     XMMRegister vec1, int ae) {</span>
<span class="line-removed"> 7133   ShortBranchVerifier sbv(this);</span>
<span class="line-removed"> 7134   Label LENGTH_DIFF_LABEL, POP_LABEL, DONE_LABEL, WHILE_HEAD_LABEL;</span>
<span class="line-removed"> 7135   Label COMPARE_WIDE_VECTORS_LOOP_FAILED;  // used only _LP64 &amp;&amp; AVX3</span>
<span class="line-removed"> 7136   int stride, stride2, adr_stride, adr_stride1, adr_stride2;</span>
<span class="line-removed"> 7137   int stride2x2 = 0x40;</span>
<span class="line-removed"> 7138   Address::ScaleFactor scale = Address::no_scale;</span>
<span class="line-removed"> 7139   Address::ScaleFactor scale1 = Address::no_scale;</span>
<span class="line-removed"> 7140   Address::ScaleFactor scale2 = Address::no_scale;</span>
<span class="line-removed"> 7141 </span>
<span class="line-removed"> 7142   if (ae != StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 7143     stride2x2 = 0x20;</span>
<span class="line-removed"> 7144   }</span>
<span class="line-removed"> 7145 </span>
<span class="line-removed"> 7146   if (ae == StrIntrinsicNode::LU || ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 7147     shrl(cnt2, 1);</span>
<span class="line-removed"> 7148   }</span>
<span class="line-removed"> 7149   // Compute the minimum of the string lengths and the</span>
<span class="line-removed"> 7150   // difference of the string lengths (stack).</span>
<span class="line-removed"> 7151   // Do the conditional move stuff</span>
<span class="line-removed"> 7152   movl(result, cnt1);</span>
<span class="line-removed"> 7153   subl(cnt1, cnt2);</span>
<span class="line-removed"> 7154   push(cnt1);</span>
<span class="line-removed"> 7155   cmov32(Assembler::lessEqual, cnt2, result);    // cnt2 = min(cnt1, cnt2)</span>
<span class="line-removed"> 7156 </span>
<span class="line-removed"> 7157   // Is the minimum length zero?</span>
<span class="line-removed"> 7158   testl(cnt2, cnt2);</span>
<span class="line-removed"> 7159   jcc(Assembler::zero, LENGTH_DIFF_LABEL);</span>
<span class="line-removed"> 7160   if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 7161     // Load first bytes</span>
<span class="line-removed"> 7162     load_unsigned_byte(result, Address(str1, 0));  // result = str1[0]</span>
<span class="line-removed"> 7163     load_unsigned_byte(cnt1, Address(str2, 0));    // cnt1   = str2[0]</span>
<span class="line-removed"> 7164   } else if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 7165     // Load first characters</span>
<span class="line-removed"> 7166     load_unsigned_short(result, Address(str1, 0));</span>
<span class="line-removed"> 7167     load_unsigned_short(cnt1, Address(str2, 0));</span>
<span class="line-removed"> 7168   } else {</span>
<span class="line-removed"> 7169     load_unsigned_byte(result, Address(str1, 0));</span>
<span class="line-removed"> 7170     load_unsigned_short(cnt1, Address(str2, 0));</span>
<span class="line-removed"> 7171   }</span>
<span class="line-removed"> 7172   subl(result, cnt1);</span>
<span class="line-removed"> 7173   jcc(Assembler::notZero,  POP_LABEL);</span>
<span class="line-removed"> 7174 </span>
<span class="line-removed"> 7175   if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 7176     // Divide length by 2 to get number of chars</span>
<span class="line-removed"> 7177     shrl(cnt2, 1);</span>
<span class="line-removed"> 7178   }</span>
<span class="line-removed"> 7179   cmpl(cnt2, 1);</span>
<span class="line-removed"> 7180   jcc(Assembler::equal, LENGTH_DIFF_LABEL);</span>
<span class="line-removed"> 7181 </span>
<span class="line-removed"> 7182   // Check if the strings start at the same location and setup scale and stride</span>
<span class="line-removed"> 7183   if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 7184     cmpptr(str1, str2);</span>
<span class="line-removed"> 7185     jcc(Assembler::equal, LENGTH_DIFF_LABEL);</span>
<span class="line-removed"> 7186     if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 7187       scale = Address::times_1;</span>
<span class="line-removed"> 7188       stride = 16;</span>
<span class="line-removed"> 7189     } else {</span>
<span class="line-removed"> 7190       scale = Address::times_2;</span>
<span class="line-removed"> 7191       stride = 8;</span>
<span class="line-removed"> 7192     }</span>
<span class="line-removed"> 7193   } else {</span>
<span class="line-removed"> 7194     scale1 = Address::times_1;</span>
<span class="line-removed"> 7195     scale2 = Address::times_2;</span>
<span class="line-removed"> 7196     // scale not used</span>
<span class="line-removed"> 7197     stride = 8;</span>
<span class="line-removed"> 7198   }</span>
<span class="line-removed"> 7199 </span>
<span class="line-removed"> 7200   if (UseAVX &gt;= 2 &amp;&amp; UseSSE42Intrinsics) {</span>
<span class="line-removed"> 7201     Label COMPARE_WIDE_VECTORS, VECTOR_NOT_EQUAL, COMPARE_WIDE_TAIL, COMPARE_SMALL_STR;</span>
<span class="line-removed"> 7202     Label COMPARE_WIDE_VECTORS_LOOP, COMPARE_16_CHARS, COMPARE_INDEX_CHAR;</span>
<span class="line-removed"> 7203     Label COMPARE_WIDE_VECTORS_LOOP_AVX2;</span>
<span class="line-removed"> 7204     Label COMPARE_TAIL_LONG;</span>
<span class="line-removed"> 7205     Label COMPARE_WIDE_VECTORS_LOOP_AVX3;  // used only _LP64 &amp;&amp; AVX3</span>
<span class="line-removed"> 7206 </span>
<span class="line-removed"> 7207     int pcmpmask = 0x19;</span>
<span class="line-removed"> 7208     if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 7209       pcmpmask &amp;= ~0x01;</span>
<span class="line-removed"> 7210     }</span>
<span class="line-removed"> 7211 </span>
<span class="line-removed"> 7212     // Setup to compare 16-chars (32-bytes) vectors,</span>
<span class="line-removed"> 7213     // start from first character again because it has aligned address.</span>
<span class="line-removed"> 7214     if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 7215       stride2 = 32;</span>
<span class="line-removed"> 7216     } else {</span>
<span class="line-removed"> 7217       stride2 = 16;</span>
<span class="line-removed"> 7218     }</span>
<span class="line-removed"> 7219     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 7220       adr_stride = stride &lt;&lt; scale;</span>
<span class="line-removed"> 7221     } else {</span>
<span class="line-removed"> 7222       adr_stride1 = 8;  //stride &lt;&lt; scale1;</span>
<span class="line-removed"> 7223       adr_stride2 = 16; //stride &lt;&lt; scale2;</span>
<span class="line-removed"> 7224     }</span>
<span class="line-removed"> 7225 </span>
<span class="line-removed"> 7226     assert(result == rax &amp;&amp; cnt2 == rdx &amp;&amp; cnt1 == rcx, &quot;pcmpestri&quot;);</span>
<span class="line-removed"> 7227     // rax and rdx are used by pcmpestri as elements counters</span>
<span class="line-removed"> 7228     movl(result, cnt2);</span>
<span class="line-removed"> 7229     andl(cnt2, ~(stride2-1));   // cnt2 holds the vector count</span>
<span class="line-removed"> 7230     jcc(Assembler::zero, COMPARE_TAIL_LONG);</span>
<span class="line-removed"> 7231 </span>
<span class="line-removed"> 7232     // fast path : compare first 2 8-char vectors.</span>
<span class="line-removed"> 7233     bind(COMPARE_16_CHARS);</span>
<span class="line-removed"> 7234     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 7235       movdqu(vec1, Address(str1, 0));</span>
<span class="line-removed"> 7236     } else {</span>
<span class="line-removed"> 7237       pmovzxbw(vec1, Address(str1, 0));</span>
<span class="line-removed"> 7238     }</span>
<span class="line-removed"> 7239     pcmpestri(vec1, Address(str2, 0), pcmpmask);</span>
<span class="line-removed"> 7240     jccb(Assembler::below, COMPARE_INDEX_CHAR);</span>
<span class="line-removed"> 7241 </span>
<span class="line-removed"> 7242     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 7243       movdqu(vec1, Address(str1, adr_stride));</span>
<span class="line-removed"> 7244       pcmpestri(vec1, Address(str2, adr_stride), pcmpmask);</span>
<span class="line-removed"> 7245     } else {</span>
<span class="line-removed"> 7246       pmovzxbw(vec1, Address(str1, adr_stride1));</span>
<span class="line-removed"> 7247       pcmpestri(vec1, Address(str2, adr_stride2), pcmpmask);</span>
<span class="line-removed"> 7248     }</span>
<span class="line-removed"> 7249     jccb(Assembler::aboveEqual, COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 7250     addl(cnt1, stride);</span>
<span class="line-removed"> 7251 </span>
<span class="line-removed"> 7252     // Compare the characters at index in cnt1</span>
<span class="line-removed"> 7253     bind(COMPARE_INDEX_CHAR); // cnt1 has the offset of the mismatching character</span>
<span class="line-removed"> 7254     load_next_elements(result, cnt2, str1, str2, scale, scale1, scale2, cnt1, ae);</span>
<span class="line-removed"> 7255     subl(result, cnt2);</span>
<span class="line-removed"> 7256     jmp(POP_LABEL);</span>
<span class="line-removed"> 7257 </span>
<span class="line-removed"> 7258     // Setup the registers to start vector comparison loop</span>
<span class="line-removed"> 7259     bind(COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 7260     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 7261       lea(str1, Address(str1, result, scale));</span>
<span class="line-removed"> 7262       lea(str2, Address(str2, result, scale));</span>
<span class="line-removed"> 7263     } else {</span>
<span class="line-removed"> 7264       lea(str1, Address(str1, result, scale1));</span>
<span class="line-removed"> 7265       lea(str2, Address(str2, result, scale2));</span>
<span class="line-removed"> 7266     }</span>
<span class="line-removed"> 7267     subl(result, stride2);</span>
<span class="line-removed"> 7268     subl(cnt2, stride2);</span>
<span class="line-removed"> 7269     jcc(Assembler::zero, COMPARE_WIDE_TAIL);</span>
<span class="line-removed"> 7270     negptr(result);</span>
<span class="line-removed"> 7271 </span>
<span class="line-removed"> 7272     //  In a loop, compare 16-chars (32-bytes) at once using (vpxor+vptest)</span>
<span class="line-removed"> 7273     bind(COMPARE_WIDE_VECTORS_LOOP);</span>
<span class="line-removed"> 7274 </span>
<span class="line-removed"> 7275 #ifdef _LP64</span>
<span class="line-removed"> 7276     if ((AVX3Threshold == 0) &amp;&amp; VM_Version::supports_avx512vlbw()) { // trying 64 bytes fast loop</span>
<span class="line-removed"> 7277       cmpl(cnt2, stride2x2);</span>
<span class="line-removed"> 7278       jccb(Assembler::below, COMPARE_WIDE_VECTORS_LOOP_AVX2);</span>
<span class="line-removed"> 7279       testl(cnt2, stride2x2-1);   // cnt2 holds the vector count</span>
<span class="line-removed"> 7280       jccb(Assembler::notZero, COMPARE_WIDE_VECTORS_LOOP_AVX2);   // means we cannot subtract by 0x40</span>
<span class="line-removed"> 7281 </span>
<span class="line-removed"> 7282       bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); // the hottest loop</span>
<span class="line-removed"> 7283       if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 7284         evmovdquq(vec1, Address(str1, result, scale), Assembler::AVX_512bit);</span>
<span class="line-removed"> 7285         evpcmpeqb(k7, vec1, Address(str2, result, scale), Assembler::AVX_512bit); // k7 == 11..11, if operands equal, otherwise k7 has some 0</span>
<span class="line-removed"> 7286       } else {</span>
<span class="line-removed"> 7287         vpmovzxbw(vec1, Address(str1, result, scale1), Assembler::AVX_512bit);</span>
<span class="line-removed"> 7288         evpcmpeqb(k7, vec1, Address(str2, result, scale2), Assembler::AVX_512bit); // k7 == 11..11, if operands equal, otherwise k7 has some 0</span>
<span class="line-removed"> 7289       }</span>
<span class="line-removed"> 7290       kortestql(k7, k7);</span>
<span class="line-removed"> 7291       jcc(Assembler::aboveEqual, COMPARE_WIDE_VECTORS_LOOP_FAILED);     // miscompare</span>
<span class="line-removed"> 7292       addptr(result, stride2x2);  // update since we already compared at this addr</span>
<span class="line-removed"> 7293       subl(cnt2, stride2x2);      // and sub the size too</span>
<span class="line-removed"> 7294       jccb(Assembler::notZero, COMPARE_WIDE_VECTORS_LOOP_AVX3);</span>
<span class="line-removed"> 7295 </span>
<span class="line-removed"> 7296       vpxor(vec1, vec1);</span>
<span class="line-removed"> 7297       jmpb(COMPARE_WIDE_TAIL);</span>
<span class="line-removed"> 7298     }//if (VM_Version::supports_avx512vlbw())</span>
<span class="line-removed"> 7299 #endif // _LP64</span>
<span class="line-removed"> 7300 </span>
<span class="line-removed"> 7301 </span>
<span class="line-removed"> 7302     bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);</span>
<span class="line-removed"> 7303     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 7304       vmovdqu(vec1, Address(str1, result, scale));</span>
<span class="line-removed"> 7305       vpxor(vec1, Address(str2, result, scale));</span>
<span class="line-removed"> 7306     } else {</span>
<span class="line-removed"> 7307       vpmovzxbw(vec1, Address(str1, result, scale1), Assembler::AVX_256bit);</span>
<span class="line-removed"> 7308       vpxor(vec1, Address(str2, result, scale2));</span>
<span class="line-removed"> 7309     }</span>
<span class="line-removed"> 7310     vptest(vec1, vec1);</span>
<span class="line-removed"> 7311     jcc(Assembler::notZero, VECTOR_NOT_EQUAL);</span>
<span class="line-removed"> 7312     addptr(result, stride2);</span>
<span class="line-removed"> 7313     subl(cnt2, stride2);</span>
<span class="line-removed"> 7314     jcc(Assembler::notZero, COMPARE_WIDE_VECTORS_LOOP);</span>
<span class="line-removed"> 7315     // clean upper bits of YMM registers</span>
<span class="line-removed"> 7316     vpxor(vec1, vec1);</span>
<span class="line-removed"> 7317 </span>
<span class="line-removed"> 7318     // compare wide vectors tail</span>
<span class="line-removed"> 7319     bind(COMPARE_WIDE_TAIL);</span>
<span class="line-removed"> 7320     testptr(result, result);</span>
<span class="line-removed"> 7321     jcc(Assembler::zero, LENGTH_DIFF_LABEL);</span>
<span class="line-removed"> 7322 </span>
<span class="line-removed"> 7323     movl(result, stride2);</span>
<span class="line-removed"> 7324     movl(cnt2, result);</span>
<span class="line-removed"> 7325     negptr(result);</span>
<span class="line-removed"> 7326     jmp(COMPARE_WIDE_VECTORS_LOOP_AVX2);</span>
<span class="line-removed"> 7327 </span>
<span class="line-removed"> 7328     // Identifies the mismatching (higher or lower)16-bytes in the 32-byte vectors.</span>
<span class="line-removed"> 7329     bind(VECTOR_NOT_EQUAL);</span>
<span class="line-removed"> 7330     // clean upper bits of YMM registers</span>
<span class="line-removed"> 7331     vpxor(vec1, vec1);</span>
<span class="line-removed"> 7332     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 7333       lea(str1, Address(str1, result, scale));</span>
<span class="line-removed"> 7334       lea(str2, Address(str2, result, scale));</span>
<span class="line-removed"> 7335     } else {</span>
<span class="line-removed"> 7336       lea(str1, Address(str1, result, scale1));</span>
<span class="line-removed"> 7337       lea(str2, Address(str2, result, scale2));</span>
<span class="line-removed"> 7338     }</span>
<span class="line-removed"> 7339     jmp(COMPARE_16_CHARS);</span>
<span class="line-removed"> 7340 </span>
<span class="line-removed"> 7341     // Compare tail chars, length between 1 to 15 chars</span>
<span class="line-removed"> 7342     bind(COMPARE_TAIL_LONG);</span>
<span class="line-removed"> 7343     movl(cnt2, result);</span>
<span class="line-removed"> 7344     cmpl(cnt2, stride);</span>
<span class="line-removed"> 7345     jcc(Assembler::less, COMPARE_SMALL_STR);</span>
<span class="line-removed"> 7346 </span>
<span class="line-removed"> 7347     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 7348       movdqu(vec1, Address(str1, 0));</span>
<span class="line-removed"> 7349     } else {</span>
<span class="line-removed"> 7350       pmovzxbw(vec1, Address(str1, 0));</span>
<span class="line-removed"> 7351     }</span>
<span class="line-removed"> 7352     pcmpestri(vec1, Address(str2, 0), pcmpmask);</span>
<span class="line-removed"> 7353     jcc(Assembler::below, COMPARE_INDEX_CHAR);</span>
<span class="line-removed"> 7354     subptr(cnt2, stride);</span>
<span class="line-removed"> 7355     jcc(Assembler::zero, LENGTH_DIFF_LABEL);</span>
<span class="line-removed"> 7356     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 7357       lea(str1, Address(str1, result, scale));</span>
<span class="line-removed"> 7358       lea(str2, Address(str2, result, scale));</span>
<span class="line-removed"> 7359     } else {</span>
<span class="line-removed"> 7360       lea(str1, Address(str1, result, scale1));</span>
<span class="line-removed"> 7361       lea(str2, Address(str2, result, scale2));</span>
<span class="line-removed"> 7362     }</span>
<span class="line-removed"> 7363     negptr(cnt2);</span>
<span class="line-removed"> 7364     jmpb(WHILE_HEAD_LABEL);</span>
<span class="line-removed"> 7365 </span>
<span class="line-removed"> 7366     bind(COMPARE_SMALL_STR);</span>
<span class="line-removed"> 7367   } else if (UseSSE42Intrinsics) {</span>
<span class="line-removed"> 7368     Label COMPARE_WIDE_VECTORS, VECTOR_NOT_EQUAL, COMPARE_TAIL;</span>
<span class="line-removed"> 7369     int pcmpmask = 0x19;</span>
<span class="line-removed"> 7370     // Setup to compare 8-char (16-byte) vectors,</span>
<span class="line-removed"> 7371     // start from first character again because it has aligned address.</span>
<span class="line-removed"> 7372     movl(result, cnt2);</span>
<span class="line-removed"> 7373     andl(cnt2, ~(stride - 1));   // cnt2 holds the vector count</span>
<span class="line-removed"> 7374     if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 7375       pcmpmask &amp;= ~0x01;</span>
<span class="line-removed"> 7376     }</span>
<span class="line-removed"> 7377     jcc(Assembler::zero, COMPARE_TAIL);</span>
<span class="line-removed"> 7378     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 7379       lea(str1, Address(str1, result, scale));</span>
<span class="line-removed"> 7380       lea(str2, Address(str2, result, scale));</span>
<span class="line-removed"> 7381     } else {</span>
<span class="line-removed"> 7382       lea(str1, Address(str1, result, scale1));</span>
<span class="line-removed"> 7383       lea(str2, Address(str2, result, scale2));</span>
<span class="line-removed"> 7384     }</span>
<span class="line-removed"> 7385     negptr(result);</span>
<span class="line-removed"> 7386 </span>
<span class="line-removed"> 7387     // pcmpestri</span>
<span class="line-removed"> 7388     //   inputs:</span>
<span class="line-removed"> 7389     //     vec1- substring</span>
<span class="line-removed"> 7390     //     rax - negative string length (elements count)</span>
<span class="line-removed"> 7391     //     mem - scanned string</span>
<span class="line-removed"> 7392     //     rdx - string length (elements count)</span>
<span class="line-removed"> 7393     //     pcmpmask - cmp mode: 11000 (string compare with negated result)</span>
<span class="line-removed"> 7394     //               + 00 (unsigned bytes) or  + 01 (unsigned shorts)</span>
<span class="line-removed"> 7395     //   outputs:</span>
<span class="line-removed"> 7396     //     rcx - first mismatched element index</span>
<span class="line-removed"> 7397     assert(result == rax &amp;&amp; cnt2 == rdx &amp;&amp; cnt1 == rcx, &quot;pcmpestri&quot;);</span>
<span class="line-removed"> 7398 </span>
<span class="line-removed"> 7399     bind(COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 7400     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 7401       movdqu(vec1, Address(str1, result, scale));</span>
<span class="line-removed"> 7402       pcmpestri(vec1, Address(str2, result, scale), pcmpmask);</span>
<span class="line-removed"> 7403     } else {</span>
<span class="line-removed"> 7404       pmovzxbw(vec1, Address(str1, result, scale1));</span>
<span class="line-removed"> 7405       pcmpestri(vec1, Address(str2, result, scale2), pcmpmask);</span>
<span class="line-removed"> 7406     }</span>
<span class="line-removed"> 7407     // After pcmpestri cnt1(rcx) contains mismatched element index</span>
<span class="line-removed"> 7408 </span>
<span class="line-removed"> 7409     jccb(Assembler::below, VECTOR_NOT_EQUAL);  // CF==1</span>
<span class="line-removed"> 7410     addptr(result, stride);</span>
<span class="line-removed"> 7411     subptr(cnt2, stride);</span>
<span class="line-removed"> 7412     jccb(Assembler::notZero, COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 7413 </span>
<span class="line-removed"> 7414     // compare wide vectors tail</span>
<span class="line-removed"> 7415     testptr(result, result);</span>
<span class="line-removed"> 7416     jcc(Assembler::zero, LENGTH_DIFF_LABEL);</span>
<span class="line-removed"> 7417 </span>
<span class="line-removed"> 7418     movl(cnt2, stride);</span>
<span class="line-removed"> 7419     movl(result, stride);</span>
<span class="line-removed"> 7420     negptr(result);</span>
<span class="line-removed"> 7421     if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 7422       movdqu(vec1, Address(str1, result, scale));</span>
<span class="line-removed"> 7423       pcmpestri(vec1, Address(str2, result, scale), pcmpmask);</span>
<span class="line-removed"> 7424     } else {</span>
<span class="line-removed"> 7425       pmovzxbw(vec1, Address(str1, result, scale1));</span>
<span class="line-removed"> 7426       pcmpestri(vec1, Address(str2, result, scale2), pcmpmask);</span>
<span class="line-removed"> 7427     }</span>
<span class="line-removed"> 7428     jccb(Assembler::aboveEqual, LENGTH_DIFF_LABEL);</span>
<span class="line-removed"> 7429 </span>
<span class="line-removed"> 7430     // Mismatched characters in the vectors</span>
<span class="line-removed"> 7431     bind(VECTOR_NOT_EQUAL);</span>
<span class="line-removed"> 7432     addptr(cnt1, result);</span>
<span class="line-removed"> 7433     load_next_elements(result, cnt2, str1, str2, scale, scale1, scale2, cnt1, ae);</span>
<span class="line-removed"> 7434     subl(result, cnt2);</span>
<span class="line-removed"> 7435     jmpb(POP_LABEL);</span>
<span class="line-removed"> 7436 </span>
<span class="line-removed"> 7437     bind(COMPARE_TAIL); // limit is zero</span>
<span class="line-removed"> 7438     movl(cnt2, result);</span>
<span class="line-removed"> 7439     // Fallthru to tail compare</span>
<span class="line-removed"> 7440   }</span>
<span class="line-removed"> 7441   // Shift str2 and str1 to the end of the arrays, negate min</span>
<span class="line-removed"> 7442   if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 7443     lea(str1, Address(str1, cnt2, scale));</span>
<span class="line-removed"> 7444     lea(str2, Address(str2, cnt2, scale));</span>
<span class="line-removed"> 7445   } else {</span>
<span class="line-removed"> 7446     lea(str1, Address(str1, cnt2, scale1));</span>
<span class="line-removed"> 7447     lea(str2, Address(str2, cnt2, scale2));</span>
<span class="line-removed"> 7448   }</span>
<span class="line-removed"> 7449   decrementl(cnt2);  // first character was compared already</span>
<span class="line-removed"> 7450   negptr(cnt2);</span>
<span class="line-removed"> 7451 </span>
<span class="line-removed"> 7452   // Compare the rest of the elements</span>
<span class="line-removed"> 7453   bind(WHILE_HEAD_LABEL);</span>
<span class="line-removed"> 7454   load_next_elements(result, cnt1, str1, str2, scale, scale1, scale2, cnt2, ae);</span>
<span class="line-removed"> 7455   subl(result, cnt1);</span>
<span class="line-removed"> 7456   jccb(Assembler::notZero, POP_LABEL);</span>
<span class="line-removed"> 7457   increment(cnt2);</span>
<span class="line-removed"> 7458   jccb(Assembler::notZero, WHILE_HEAD_LABEL);</span>
<span class="line-removed"> 7459 </span>
<span class="line-removed"> 7460   // Strings are equal up to min length.  Return the length difference.</span>
<span class="line-removed"> 7461   bind(LENGTH_DIFF_LABEL);</span>
<span class="line-removed"> 7462   pop(result);</span>
<span class="line-removed"> 7463   if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 7464     // Divide diff by 2 to get number of chars</span>
<span class="line-removed"> 7465     sarl(result, 1);</span>
<span class="line-removed"> 7466   }</span>
<span class="line-removed"> 7467   jmpb(DONE_LABEL);</span>
<span class="line-removed"> 7468 </span>
<span class="line-removed"> 7469 #ifdef _LP64</span>
<span class="line-removed"> 7470   if (VM_Version::supports_avx512vlbw()) {</span>
<span class="line-removed"> 7471 </span>
<span class="line-removed"> 7472     bind(COMPARE_WIDE_VECTORS_LOOP_FAILED);</span>
<span class="line-removed"> 7473 </span>
<span class="line-removed"> 7474     kmovql(cnt1, k7);</span>
<span class="line-removed"> 7475     notq(cnt1);</span>
<span class="line-removed"> 7476     bsfq(cnt2, cnt1);</span>
<span class="line-removed"> 7477     if (ae != StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 7478       // Divide diff by 2 to get number of chars</span>
<span class="line-removed"> 7479       sarl(cnt2, 1);</span>
<span class="line-removed"> 7480     }</span>
<span class="line-removed"> 7481     addq(result, cnt2);</span>
<span class="line-removed"> 7482     if (ae == StrIntrinsicNode::LL) {</span>
<span class="line-removed"> 7483       load_unsigned_byte(cnt1, Address(str2, result));</span>
<span class="line-removed"> 7484       load_unsigned_byte(result, Address(str1, result));</span>
<span class="line-removed"> 7485     } else if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed"> 7486       load_unsigned_short(cnt1, Address(str2, result, scale));</span>
<span class="line-removed"> 7487       load_unsigned_short(result, Address(str1, result, scale));</span>
<span class="line-removed"> 7488     } else {</span>
<span class="line-removed"> 7489       load_unsigned_short(cnt1, Address(str2, result, scale2));</span>
<span class="line-removed"> 7490       load_unsigned_byte(result, Address(str1, result, scale1));</span>
<span class="line-removed"> 7491     }</span>
<span class="line-removed"> 7492     subl(result, cnt1);</span>
<span class="line-removed"> 7493     jmpb(POP_LABEL);</span>
<span class="line-removed"> 7494   }//if (VM_Version::supports_avx512vlbw())</span>
<span class="line-removed"> 7495 #endif // _LP64</span>
<span class="line-removed"> 7496 </span>
<span class="line-removed"> 7497   // Discard the stored length difference</span>
<span class="line-removed"> 7498   bind(POP_LABEL);</span>
<span class="line-removed"> 7499   pop(cnt1);</span>
<span class="line-removed"> 7500 </span>
<span class="line-removed"> 7501   // That&#39;s it</span>
<span class="line-removed"> 7502   bind(DONE_LABEL);</span>
<span class="line-removed"> 7503   if(ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed"> 7504     negl(result);</span>
<span class="line-removed"> 7505   }</span>
<span class="line-removed"> 7506 </span>
<span class="line-removed"> 7507 }</span>
<span class="line-removed"> 7508 </span>
<span class="line-removed"> 7509 // Search for Non-ASCII character (Negative byte value) in a byte array,</span>
<span class="line-removed"> 7510 // return true if it has any and false otherwise.</span>
<span class="line-removed"> 7511 //   ..\jdk\src\java.base\share\classes\java\lang\StringCoding.java</span>
<span class="line-removed"> 7512 //   @HotSpotIntrinsicCandidate</span>
<span class="line-removed"> 7513 //   private static boolean hasNegatives(byte[] ba, int off, int len) {</span>
<span class="line-removed"> 7514 //     for (int i = off; i &lt; off + len; i++) {</span>
<span class="line-removed"> 7515 //       if (ba[i] &lt; 0) {</span>
<span class="line-removed"> 7516 //         return true;</span>
<span class="line-removed"> 7517 //       }</span>
<span class="line-removed"> 7518 //     }</span>
<span class="line-removed"> 7519 //     return false;</span>
<span class="line-removed"> 7520 //   }</span>
<span class="line-removed"> 7521 void MacroAssembler::has_negatives(Register ary1, Register len,</span>
<span class="line-removed"> 7522   Register result, Register tmp1,</span>
<span class="line-removed"> 7523   XMMRegister vec1, XMMRegister vec2) {</span>
<span class="line-removed"> 7524   // rsi: byte array</span>
<span class="line-removed"> 7525   // rcx: len</span>
<span class="line-removed"> 7526   // rax: result</span>
<span class="line-removed"> 7527   ShortBranchVerifier sbv(this);</span>
<span class="line-removed"> 7528   assert_different_registers(ary1, len, result, tmp1);</span>
<span class="line-removed"> 7529   assert_different_registers(vec1, vec2);</span>
<span class="line-removed"> 7530   Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_CHAR, COMPARE_VECTORS, COMPARE_BYTE;</span>
<span class="line-removed"> 7531 </span>
<span class="line-removed"> 7532   // len == 0</span>
<span class="line-removed"> 7533   testl(len, len);</span>
<span class="line-removed"> 7534   jcc(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed"> 7535 </span>
<span class="line-removed"> 7536   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp; // AVX512</span>
<span class="line-removed"> 7537     VM_Version::supports_avx512vlbw() &amp;&amp;</span>
<span class="line-removed"> 7538     VM_Version::supports_bmi2()) {</span>
<span class="line-removed"> 7539 </span>
<span class="line-removed"> 7540     Label test_64_loop, test_tail;</span>
<span class="line-removed"> 7541     Register tmp3_aliased = len;</span>
<span class="line-removed"> 7542 </span>
<span class="line-removed"> 7543     movl(tmp1, len);</span>
<span class="line-removed"> 7544     vpxor(vec2, vec2, vec2, Assembler::AVX_512bit);</span>
<span class="line-removed"> 7545 </span>
<span class="line-removed"> 7546     andl(tmp1, 64 - 1);   // tail count (in chars) 0x3F</span>
<span class="line-removed"> 7547     andl(len, ~(64 - 1));    // vector count (in chars)</span>
<span class="line-removed"> 7548     jccb(Assembler::zero, test_tail);</span>
<span class="line-removed"> 7549 </span>
<span class="line-removed"> 7550     lea(ary1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed"> 7551     negptr(len);</span>
<span class="line-removed"> 7552 </span>
<span class="line-removed"> 7553     bind(test_64_loop);</span>
<span class="line-removed"> 7554     // Check whether our 64 elements of size byte contain negatives</span>
<span class="line-removed"> 7555     evpcmpgtb(k2, vec2, Address(ary1, len, Address::times_1), Assembler::AVX_512bit);</span>
<span class="line-removed"> 7556     kortestql(k2, k2);</span>
<span class="line-removed"> 7557     jcc(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed"> 7558 </span>
<span class="line-removed"> 7559     addptr(len, 64);</span>
<span class="line-removed"> 7560     jccb(Assembler::notZero, test_64_loop);</span>
<span class="line-removed"> 7561 </span>
<span class="line-removed"> 7562 </span>
<span class="line-removed"> 7563     bind(test_tail);</span>
<span class="line-removed"> 7564     // bail out when there is nothing to be done</span>
<span class="line-removed"> 7565     testl(tmp1, -1);</span>
<span class="line-removed"> 7566     jcc(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed"> 7567 </span>
<span class="line-removed"> 7568     // ~(~0 &lt;&lt; len) applied up to two times (for 32-bit scenario)</span>
<span class="line-removed"> 7569 #ifdef _LP64</span>
<span class="line-removed"> 7570     mov64(tmp3_aliased, 0xFFFFFFFFFFFFFFFF);</span>
<span class="line-removed"> 7571     shlxq(tmp3_aliased, tmp3_aliased, tmp1);</span>
<span class="line-removed"> 7572     notq(tmp3_aliased);</span>
<span class="line-removed"> 7573     kmovql(k3, tmp3_aliased);</span>
<span class="line-removed"> 7574 #else</span>
<span class="line-removed"> 7575     Label k_init;</span>
<span class="line-removed"> 7576     jmp(k_init);</span>
<span class="line-removed"> 7577 </span>
<span class="line-removed"> 7578     // We could not read 64-bits from a general purpose register thus we move</span>
<span class="line-removed"> 7579     // data required to compose 64 1&#39;s to the instruction stream</span>
<span class="line-removed"> 7580     // We emit 64 byte wide series of elements from 0..63 which later on would</span>
<span class="line-removed"> 7581     // be used as a compare targets with tail count contained in tmp1 register.</span>
<span class="line-removed"> 7582     // Result would be a k register having tmp1 consecutive number or 1</span>
<span class="line-removed"> 7583     // counting from least significant bit.</span>
<span class="line-removed"> 7584     address tmp = pc();</span>
<span class="line-removed"> 7585     emit_int64(0x0706050403020100);</span>
<span class="line-removed"> 7586     emit_int64(0x0F0E0D0C0B0A0908);</span>
<span class="line-removed"> 7587     emit_int64(0x1716151413121110);</span>
<span class="line-removed"> 7588     emit_int64(0x1F1E1D1C1B1A1918);</span>
<span class="line-removed"> 7589     emit_int64(0x2726252423222120);</span>
<span class="line-removed"> 7590     emit_int64(0x2F2E2D2C2B2A2928);</span>
<span class="line-removed"> 7591     emit_int64(0x3736353433323130);</span>
<span class="line-removed"> 7592     emit_int64(0x3F3E3D3C3B3A3938);</span>
<span class="line-removed"> 7593 </span>
<span class="line-removed"> 7594     bind(k_init);</span>
<span class="line-removed"> 7595     lea(len, InternalAddress(tmp));</span>
<span class="line-removed"> 7596     // create mask to test for negative byte inside a vector</span>
<span class="line-removed"> 7597     evpbroadcastb(vec1, tmp1, Assembler::AVX_512bit);</span>
<span class="line-removed"> 7598     evpcmpgtb(k3, vec1, Address(len, 0), Assembler::AVX_512bit);</span>
<span class="line-removed"> 7599 </span>
<span class="line-removed"> 7600 #endif</span>
<span class="line-removed"> 7601     evpcmpgtb(k2, k3, vec2, Address(ary1, 0), Assembler::AVX_512bit);</span>
<span class="line-removed"> 7602     ktestq(k2, k3);</span>
<span class="line-removed"> 7603     jcc(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed"> 7604 </span>
<span class="line-removed"> 7605     jmp(FALSE_LABEL);</span>
<span class="line-removed"> 7606   } else {</span>
<span class="line-removed"> 7607     movl(result, len); // copy</span>
<span class="line-removed"> 7608 </span>
<span class="line-removed"> 7609     if (UseAVX &gt;= 2 &amp;&amp; UseSSE &gt;= 2) {</span>
<span class="line-removed"> 7610       // With AVX2, use 32-byte vector compare</span>
<span class="line-removed"> 7611       Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;</span>
<span class="line-removed"> 7612 </span>
<span class="line-removed"> 7613       // Compare 32-byte vectors</span>
<span class="line-removed"> 7614       andl(result, 0x0000001f);  //   tail count (in bytes)</span>
<span class="line-removed"> 7615       andl(len, 0xffffffe0);   // vector count (in bytes)</span>
<span class="line-removed"> 7616       jccb(Assembler::zero, COMPARE_TAIL);</span>
<span class="line-removed"> 7617 </span>
<span class="line-removed"> 7618       lea(ary1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed"> 7619       negptr(len);</span>
<span class="line-removed"> 7620 </span>
<span class="line-removed"> 7621       movl(tmp1, 0x80808080);   // create mask to test for Unicode chars in vector</span>
<span class="line-removed"> 7622       movdl(vec2, tmp1);</span>
<span class="line-removed"> 7623       vpbroadcastd(vec2, vec2, Assembler::AVX_256bit);</span>
<span class="line-removed"> 7624 </span>
<span class="line-removed"> 7625       bind(COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 7626       vmovdqu(vec1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed"> 7627       vptest(vec1, vec2);</span>
<span class="line-removed"> 7628       jccb(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed"> 7629       addptr(len, 32);</span>
<span class="line-removed"> 7630       jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 7631 </span>
<span class="line-removed"> 7632       testl(result, result);</span>
<span class="line-removed"> 7633       jccb(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed"> 7634 </span>
<span class="line-removed"> 7635       vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));</span>
<span class="line-removed"> 7636       vptest(vec1, vec2);</span>
<span class="line-removed"> 7637       jccb(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed"> 7638       jmpb(FALSE_LABEL);</span>
<span class="line-removed"> 7639 </span>
<span class="line-removed"> 7640       bind(COMPARE_TAIL); // len is zero</span>
<span class="line-removed"> 7641       movl(len, result);</span>
<span class="line-removed"> 7642       // Fallthru to tail compare</span>
<span class="line-removed"> 7643     } else if (UseSSE42Intrinsics) {</span>
<span class="line-removed"> 7644       // With SSE4.2, use double quad vector compare</span>
<span class="line-removed"> 7645       Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;</span>
<span class="line-removed"> 7646 </span>
<span class="line-removed"> 7647       // Compare 16-byte vectors</span>
<span class="line-removed"> 7648       andl(result, 0x0000000f);  //   tail count (in bytes)</span>
<span class="line-removed"> 7649       andl(len, 0xfffffff0);   // vector count (in bytes)</span>
<span class="line-removed"> 7650       jcc(Assembler::zero, COMPARE_TAIL);</span>
<span class="line-removed"> 7651 </span>
<span class="line-removed"> 7652       lea(ary1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed"> 7653       negptr(len);</span>
<span class="line-removed"> 7654 </span>
<span class="line-removed"> 7655       movl(tmp1, 0x80808080);</span>
<span class="line-removed"> 7656       movdl(vec2, tmp1);</span>
<span class="line-removed"> 7657       pshufd(vec2, vec2, 0);</span>
<span class="line-removed"> 7658 </span>
<span class="line-removed"> 7659       bind(COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 7660       movdqu(vec1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed"> 7661       ptest(vec1, vec2);</span>
<span class="line-removed"> 7662       jcc(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed"> 7663       addptr(len, 16);</span>
<span class="line-removed"> 7664       jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 7665 </span>
<span class="line-removed"> 7666       testl(result, result);</span>
<span class="line-removed"> 7667       jcc(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed"> 7668 </span>
<span class="line-removed"> 7669       movdqu(vec1, Address(ary1, result, Address::times_1, -16));</span>
<span class="line-removed"> 7670       ptest(vec1, vec2);</span>
<span class="line-removed"> 7671       jccb(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed"> 7672       jmpb(FALSE_LABEL);</span>
<span class="line-removed"> 7673 </span>
<span class="line-removed"> 7674       bind(COMPARE_TAIL); // len is zero</span>
<span class="line-removed"> 7675       movl(len, result);</span>
<span class="line-removed"> 7676       // Fallthru to tail compare</span>
<span class="line-removed"> 7677     }</span>
<span class="line-removed"> 7678   }</span>
<span class="line-removed"> 7679   // Compare 4-byte vectors</span>
<span class="line-removed"> 7680   andl(len, 0xfffffffc); // vector count (in bytes)</span>
<span class="line-removed"> 7681   jccb(Assembler::zero, COMPARE_CHAR);</span>
<span class="line-removed"> 7682 </span>
<span class="line-removed"> 7683   lea(ary1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed"> 7684   negptr(len);</span>
<span class="line-removed"> 7685 </span>
<span class="line-removed"> 7686   bind(COMPARE_VECTORS);</span>
<span class="line-removed"> 7687   movl(tmp1, Address(ary1, len, Address::times_1));</span>
<span class="line-removed"> 7688   andl(tmp1, 0x80808080);</span>
<span class="line-removed"> 7689   jccb(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed"> 7690   addptr(len, 4);</span>
<span class="line-removed"> 7691   jcc(Assembler::notZero, COMPARE_VECTORS);</span>
<span class="line-removed"> 7692 </span>
<span class="line-removed"> 7693   // Compare trailing char (final 2 bytes), if any</span>
<span class="line-removed"> 7694   bind(COMPARE_CHAR);</span>
<span class="line-removed"> 7695   testl(result, 0x2);   // tail  char</span>
<span class="line-removed"> 7696   jccb(Assembler::zero, COMPARE_BYTE);</span>
<span class="line-removed"> 7697   load_unsigned_short(tmp1, Address(ary1, 0));</span>
<span class="line-removed"> 7698   andl(tmp1, 0x00008080);</span>
<span class="line-removed"> 7699   jccb(Assembler::notZero, TRUE_LABEL);</span>
<span class="line-removed"> 7700   subptr(result, 2);</span>
<span class="line-removed"> 7701   lea(ary1, Address(ary1, 2));</span>
<span class="line-removed"> 7702 </span>
<span class="line-removed"> 7703   bind(COMPARE_BYTE);</span>
<span class="line-removed"> 7704   testl(result, 0x1);   // tail  byte</span>
<span class="line-removed"> 7705   jccb(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed"> 7706   load_unsigned_byte(tmp1, Address(ary1, 0));</span>
<span class="line-removed"> 7707   andl(tmp1, 0x00000080);</span>
<span class="line-removed"> 7708   jccb(Assembler::notEqual, TRUE_LABEL);</span>
<span class="line-removed"> 7709   jmpb(FALSE_LABEL);</span>
<span class="line-removed"> 7710 </span>
<span class="line-removed"> 7711   bind(TRUE_LABEL);</span>
<span class="line-removed"> 7712   movl(result, 1);   // return true</span>
<span class="line-removed"> 7713   jmpb(DONE);</span>
<span class="line-removed"> 7714 </span>
<span class="line-removed"> 7715   bind(FALSE_LABEL);</span>
<span class="line-removed"> 7716   xorl(result, result); // return false</span>
<span class="line-removed"> 7717 </span>
<span class="line-removed"> 7718   // That&#39;s it</span>
<span class="line-removed"> 7719   bind(DONE);</span>
<span class="line-removed"> 7720   if (UseAVX &gt;= 2 &amp;&amp; UseSSE &gt;= 2) {</span>
<span class="line-removed"> 7721     // clean upper bits of YMM registers</span>
<span class="line-removed"> 7722     vpxor(vec1, vec1);</span>
<span class="line-removed"> 7723     vpxor(vec2, vec2);</span>
<span class="line-removed"> 7724   }</span>
<span class="line-removed"> 7725 }</span>
<span class="line-removed"> 7726 // Compare char[] or byte[] arrays aligned to 4 bytes or substrings.</span>
<span class="line-removed"> 7727 void MacroAssembler::arrays_equals(bool is_array_equ, Register ary1, Register ary2,</span>
<span class="line-removed"> 7728                                    Register limit, Register result, Register chr,</span>
<span class="line-removed"> 7729                                    XMMRegister vec1, XMMRegister vec2, bool is_char) {</span>
<span class="line-removed"> 7730   ShortBranchVerifier sbv(this);</span>
<span class="line-removed"> 7731   Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_VECTORS, COMPARE_CHAR, COMPARE_BYTE;</span>
<span class="line-removed"> 7732 </span>
<span class="line-removed"> 7733   int length_offset  = arrayOopDesc::length_offset_in_bytes();</span>
<span class="line-removed"> 7734   int base_offset    = arrayOopDesc::base_offset_in_bytes(is_char ? T_CHAR : T_BYTE);</span>
<span class="line-removed"> 7735 </span>
<span class="line-removed"> 7736   if (is_array_equ) {</span>
<span class="line-removed"> 7737     // Check the input args</span>
<span class="line-removed"> 7738     cmpoop(ary1, ary2);</span>
<span class="line-removed"> 7739     jcc(Assembler::equal, TRUE_LABEL);</span>
<span class="line-removed"> 7740 </span>
<span class="line-removed"> 7741     // Need additional checks for arrays_equals.</span>
<span class="line-removed"> 7742     testptr(ary1, ary1);</span>
<span class="line-removed"> 7743     jcc(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed"> 7744     testptr(ary2, ary2);</span>
<span class="line-removed"> 7745     jcc(Assembler::zero, FALSE_LABEL);</span>
<span class="line-removed"> 7746 </span>
<span class="line-removed"> 7747     // Check the lengths</span>
<span class="line-removed"> 7748     movl(limit, Address(ary1, length_offset));</span>
<span class="line-removed"> 7749     cmpl(limit, Address(ary2, length_offset));</span>
<span class="line-removed"> 7750     jcc(Assembler::notEqual, FALSE_LABEL);</span>
<span class="line-removed"> 7751   }</span>
<span class="line-removed"> 7752 </span>
<span class="line-removed"> 7753   // count == 0</span>
<span class="line-removed"> 7754   testl(limit, limit);</span>
<span class="line-removed"> 7755   jcc(Assembler::zero, TRUE_LABEL);</span>
<span class="line-removed"> 7756 </span>
<span class="line-removed"> 7757   if (is_array_equ) {</span>
<span class="line-removed"> 7758     // Load array address</span>
<span class="line-removed"> 7759     lea(ary1, Address(ary1, base_offset));</span>
<span class="line-removed"> 7760     lea(ary2, Address(ary2, base_offset));</span>
<span class="line-removed"> 7761   }</span>
<span class="line-removed"> 7762 </span>
<span class="line-removed"> 7763   if (is_array_equ &amp;&amp; is_char) {</span>
<span class="line-removed"> 7764     // arrays_equals when used for char[].</span>
<span class="line-removed"> 7765     shll(limit, 1);      // byte count != 0</span>
<span class="line-removed"> 7766   }</span>
<span class="line-removed"> 7767   movl(result, limit); // copy</span>
<span class="line-removed"> 7768 </span>
<span class="line-removed"> 7769   if (UseAVX &gt;= 2) {</span>
<span class="line-removed"> 7770     // With AVX2, use 32-byte vector compare</span>
<span class="line-removed"> 7771     Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;</span>
<span class="line-removed"> 7772 </span>
<span class="line-removed"> 7773     // Compare 32-byte vectors</span>
<span class="line-removed"> 7774     andl(result, 0x0000001f);  //   tail count (in bytes)</span>
<span class="line-removed"> 7775     andl(limit, 0xffffffe0);   // vector count (in bytes)</span>
<span class="line-removed"> 7776     jcc(Assembler::zero, COMPARE_TAIL);</span>
<span class="line-removed"> 7777 </span>
<span class="line-removed"> 7778     lea(ary1, Address(ary1, limit, Address::times_1));</span>
<span class="line-removed"> 7779     lea(ary2, Address(ary2, limit, Address::times_1));</span>
<span class="line-removed"> 7780     negptr(limit);</span>
<span class="line-removed"> 7781 </span>
<span class="line-removed"> 7782 #ifdef _LP64</span>
<span class="line-removed"> 7783     if ((AVX3Threshold == 0) &amp;&amp; VM_Version::supports_avx512vlbw()) { // trying 64 bytes fast loop</span>
<span class="line-removed"> 7784       Label COMPARE_WIDE_VECTORS_LOOP_AVX2, COMPARE_WIDE_VECTORS_LOOP_AVX3;</span>
<span class="line-removed"> 7785 </span>
<span class="line-removed"> 7786       cmpl(limit, -64);</span>
<span class="line-removed"> 7787       jcc(Assembler::greater, COMPARE_WIDE_VECTORS_LOOP_AVX2);</span>
<span class="line-removed"> 7788 </span>
<span class="line-removed"> 7789       bind(COMPARE_WIDE_VECTORS_LOOP_AVX3); // the hottest loop</span>
<span class="line-removed"> 7790 </span>
<span class="line-removed"> 7791       evmovdquq(vec1, Address(ary1, limit, Address::times_1), Assembler::AVX_512bit);</span>
<span class="line-removed"> 7792       evpcmpeqb(k7, vec1, Address(ary2, limit, Address::times_1), Assembler::AVX_512bit);</span>
<span class="line-removed"> 7793       kortestql(k7, k7);</span>
<span class="line-removed"> 7794       jcc(Assembler::aboveEqual, FALSE_LABEL);     // miscompare</span>
<span class="line-removed"> 7795       addptr(limit, 64);  // update since we already compared at this addr</span>
<span class="line-removed"> 7796       cmpl(limit, -64);</span>
<span class="line-removed"> 7797       jccb(Assembler::lessEqual, COMPARE_WIDE_VECTORS_LOOP_AVX3);</span>
<span class="line-removed"> 7798 </span>
<span class="line-removed"> 7799       // At this point we may still need to compare -limit+result bytes.</span>
<span class="line-removed"> 7800       // We could execute the next two instruction and just continue via non-wide path:</span>
<span class="line-removed"> 7801       //  cmpl(limit, 0);</span>
<span class="line-removed"> 7802       //  jcc(Assembler::equal, COMPARE_TAIL);  // true</span>
<span class="line-removed"> 7803       // But since we stopped at the points ary{1,2}+limit which are</span>
<span class="line-removed"> 7804       // not farther than 64 bytes from the ends of arrays ary{1,2}+result</span>
<span class="line-removed"> 7805       // (|limit| &lt;= 32 and result &lt; 32),</span>
<span class="line-removed"> 7806       // we may just compare the last 64 bytes.</span>
<span class="line-removed"> 7807       //</span>
<span class="line-removed"> 7808       addptr(result, -64);   // it is safe, bc we just came from this area</span>
<span class="line-removed"> 7809       evmovdquq(vec1, Address(ary1, result, Address::times_1), Assembler::AVX_512bit);</span>
<span class="line-removed"> 7810       evpcmpeqb(k7, vec1, Address(ary2, result, Address::times_1), Assembler::AVX_512bit);</span>
<span class="line-removed"> 7811       kortestql(k7, k7);</span>
<span class="line-removed"> 7812       jcc(Assembler::aboveEqual, FALSE_LABEL);     // miscompare</span>
<span class="line-removed"> 7813 </span>
<span class="line-removed"> 7814       jmp(TRUE_LABEL);</span>
<span class="line-removed"> 7815 </span>
<span class="line-removed"> 7816       bind(COMPARE_WIDE_VECTORS_LOOP_AVX2);</span>
<span class="line-removed"> 7817 </span>
<span class="line-removed"> 7818     }//if (VM_Version::supports_avx512vlbw())</span>
<span class="line-removed"> 7819 #endif //_LP64</span>
<span class="line-removed"> 7820     bind(COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 7821     vmovdqu(vec1, Address(ary1, limit, Address::times_1));</span>
<span class="line-removed"> 7822     vmovdqu(vec2, Address(ary2, limit, Address::times_1));</span>
<span class="line-removed"> 7823     vpxor(vec1, vec2);</span>
<span class="line-removed"> 7824 </span>
<span class="line-removed"> 7825     vptest(vec1, vec1);</span>
<span class="line-removed"> 7826     jcc(Assembler::notZero, FALSE_LABEL);</span>
<span class="line-removed"> 7827     addptr(limit, 32);</span>
<span class="line-removed"> 7828     jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 7829 </span>
<span class="line-removed"> 7830     testl(result, result);</span>
<span class="line-removed"> 7831     jcc(Assembler::zero, TRUE_LABEL);</span>
<span class="line-removed"> 7832 </span>
<span class="line-removed"> 7833     vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));</span>
<span class="line-removed"> 7834     vmovdqu(vec2, Address(ary2, result, Address::times_1, -32));</span>
<span class="line-removed"> 7835     vpxor(vec1, vec2);</span>
<span class="line-removed"> 7836 </span>
<span class="line-removed"> 7837     vptest(vec1, vec1);</span>
<span class="line-removed"> 7838     jccb(Assembler::notZero, FALSE_LABEL);</span>
<span class="line-removed"> 7839     jmpb(TRUE_LABEL);</span>
<span class="line-removed"> 7840 </span>
<span class="line-removed"> 7841     bind(COMPARE_TAIL); // limit is zero</span>
<span class="line-removed"> 7842     movl(limit, result);</span>
<span class="line-removed"> 7843     // Fallthru to tail compare</span>
<span class="line-removed"> 7844   } else if (UseSSE42Intrinsics) {</span>
<span class="line-removed"> 7845     // With SSE4.2, use double quad vector compare</span>
<span class="line-removed"> 7846     Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;</span>
<span class="line-removed"> 7847 </span>
<span class="line-removed"> 7848     // Compare 16-byte vectors</span>
<span class="line-removed"> 7849     andl(result, 0x0000000f);  //   tail count (in bytes)</span>
<span class="line-removed"> 7850     andl(limit, 0xfffffff0);   // vector count (in bytes)</span>
<span class="line-removed"> 7851     jcc(Assembler::zero, COMPARE_TAIL);</span>
<span class="line-removed"> 7852 </span>
<span class="line-removed"> 7853     lea(ary1, Address(ary1, limit, Address::times_1));</span>
<span class="line-removed"> 7854     lea(ary2, Address(ary2, limit, Address::times_1));</span>
<span class="line-removed"> 7855     negptr(limit);</span>
<span class="line-removed"> 7856 </span>
<span class="line-removed"> 7857     bind(COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 7858     movdqu(vec1, Address(ary1, limit, Address::times_1));</span>
<span class="line-removed"> 7859     movdqu(vec2, Address(ary2, limit, Address::times_1));</span>
<span class="line-removed"> 7860     pxor(vec1, vec2);</span>
<span class="line-removed"> 7861 </span>
<span class="line-removed"> 7862     ptest(vec1, vec1);</span>
<span class="line-removed"> 7863     jcc(Assembler::notZero, FALSE_LABEL);</span>
<span class="line-removed"> 7864     addptr(limit, 16);</span>
<span class="line-removed"> 7865     jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);</span>
<span class="line-removed"> 7866 </span>
<span class="line-removed"> 7867     testl(result, result);</span>
<span class="line-removed"> 7868     jcc(Assembler::zero, TRUE_LABEL);</span>
<span class="line-removed"> 7869 </span>
<span class="line-removed"> 7870     movdqu(vec1, Address(ary1, result, Address::times_1, -16));</span>
<span class="line-removed"> 7871     movdqu(vec2, Address(ary2, result, Address::times_1, -16));</span>
<span class="line-removed"> 7872     pxor(vec1, vec2);</span>
<span class="line-removed"> 7873 </span>
<span class="line-removed"> 7874     ptest(vec1, vec1);</span>
<span class="line-removed"> 7875     jccb(Assembler::notZero, FALSE_LABEL);</span>
<span class="line-removed"> 7876     jmpb(TRUE_LABEL);</span>
<span class="line-removed"> 7877 </span>
<span class="line-removed"> 7878     bind(COMPARE_TAIL); // limit is zero</span>
<span class="line-removed"> 7879     movl(limit, result);</span>
<span class="line-removed"> 7880     // Fallthru to tail compare</span>
<span class="line-removed"> 7881   }</span>
<span class="line-removed"> 7882 </span>
<span class="line-removed"> 7883   // Compare 4-byte vectors</span>
<span class="line-removed"> 7884   andl(limit, 0xfffffffc); // vector count (in bytes)</span>
<span class="line-removed"> 7885   jccb(Assembler::zero, COMPARE_CHAR);</span>
<span class="line-removed"> 7886 </span>
<span class="line-removed"> 7887   lea(ary1, Address(ary1, limit, Address::times_1));</span>
<span class="line-removed"> 7888   lea(ary2, Address(ary2, limit, Address::times_1));</span>
<span class="line-removed"> 7889   negptr(limit);</span>
<span class="line-removed"> 7890 </span>
<span class="line-removed"> 7891   bind(COMPARE_VECTORS);</span>
<span class="line-removed"> 7892   movl(chr, Address(ary1, limit, Address::times_1));</span>
<span class="line-removed"> 7893   cmpl(chr, Address(ary2, limit, Address::times_1));</span>
<span class="line-removed"> 7894   jccb(Assembler::notEqual, FALSE_LABEL);</span>
<span class="line-removed"> 7895   addptr(limit, 4);</span>
<span class="line-removed"> 7896   jcc(Assembler::notZero, COMPARE_VECTORS);</span>
<span class="line-removed"> 7897 </span>
<span class="line-removed"> 7898   // Compare trailing char (final 2 bytes), if any</span>
<span class="line-removed"> 7899   bind(COMPARE_CHAR);</span>
<span class="line-removed"> 7900   testl(result, 0x2);   // tail  char</span>
<span class="line-removed"> 7901   jccb(Assembler::zero, COMPARE_BYTE);</span>
<span class="line-removed"> 7902   load_unsigned_short(chr, Address(ary1, 0));</span>
<span class="line-removed"> 7903   load_unsigned_short(limit, Address(ary2, 0));</span>
<span class="line-removed"> 7904   cmpl(chr, limit);</span>
<span class="line-removed"> 7905   jccb(Assembler::notEqual, FALSE_LABEL);</span>
<span class="line-removed"> 7906 </span>
<span class="line-removed"> 7907   if (is_array_equ &amp;&amp; is_char) {</span>
<span class="line-removed"> 7908     bind(COMPARE_BYTE);</span>
<span class="line-removed"> 7909   } else {</span>
<span class="line-removed"> 7910     lea(ary1, Address(ary1, 2));</span>
<span class="line-removed"> 7911     lea(ary2, Address(ary2, 2));</span>
<span class="line-removed"> 7912 </span>
<span class="line-removed"> 7913     bind(COMPARE_BYTE);</span>
<span class="line-removed"> 7914     testl(result, 0x1);   // tail  byte</span>
<span class="line-removed"> 7915     jccb(Assembler::zero, TRUE_LABEL);</span>
<span class="line-removed"> 7916     load_unsigned_byte(chr, Address(ary1, 0));</span>
<span class="line-removed"> 7917     load_unsigned_byte(limit, Address(ary2, 0));</span>
<span class="line-removed"> 7918     cmpl(chr, limit);</span>
<span class="line-removed"> 7919     jccb(Assembler::notEqual, FALSE_LABEL);</span>
<span class="line-removed"> 7920   }</span>
<span class="line-removed"> 7921   bind(TRUE_LABEL);</span>
<span class="line-removed"> 7922   movl(result, 1);   // return true</span>
<span class="line-removed"> 7923   jmpb(DONE);</span>
<span class="line-removed"> 7924 </span>
<span class="line-removed"> 7925   bind(FALSE_LABEL);</span>
<span class="line-removed"> 7926   xorl(result, result); // return false</span>
<span class="line-removed"> 7927 </span>
<span class="line-removed"> 7928   // That&#39;s it</span>
<span class="line-removed"> 7929   bind(DONE);</span>
<span class="line-removed"> 7930   if (UseAVX &gt;= 2) {</span>
<span class="line-removed"> 7931     // clean upper bits of YMM registers</span>
<span class="line-removed"> 7932     vpxor(vec1, vec1);</span>
<span class="line-removed"> 7933     vpxor(vec2, vec2);</span>
<span class="line-removed"> 7934   }</span>
<span class="line-removed"> 7935 }</span>
<span class="line-removed"> 7936 </span>
<span class="line-removed"> 7937 #endif</span>
<span class="line-removed"> 7938 </span>
 7939 void MacroAssembler::generate_fill(BasicType t, bool aligned,
 7940                                    Register to, Register value, Register count,
 7941                                    Register rtmp, XMMRegister xtmp) {
 7942   ShortBranchVerifier sbv(this);
 7943   assert_different_registers(to, value, count, rtmp);
 7944   Label L_exit;
 7945   Label L_fill_2_bytes, L_fill_4_bytes;
 7946 
 7947   int shift = -1;
 7948   switch (t) {
 7949     case T_BYTE:
 7950       shift = 2;
 7951       break;
 7952     case T_SHORT:
 7953       shift = 1;
 7954       break;
 7955     case T_INT:
 7956       shift = 0;
 7957       break;
 7958     default: ShouldNotReachHere();
</pre>
</td>
<td>
<hr />
<pre>
   35 #include &quot;memory/universe.hpp&quot;
   36 #include &quot;oops/accessDecorators.hpp&quot;
   37 #include &quot;oops/compressedOops.inline.hpp&quot;
   38 #include &quot;oops/klass.inline.hpp&quot;
   39 #include &quot;prims/methodHandles.hpp&quot;
   40 #include &quot;runtime/biasedLocking.hpp&quot;
   41 #include &quot;runtime/flags/flagSetting.hpp&quot;
   42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
   43 #include &quot;runtime/objectMonitor.hpp&quot;
   44 #include &quot;runtime/os.hpp&quot;
   45 #include &quot;runtime/safepoint.hpp&quot;
   46 #include &quot;runtime/safepointMechanism.hpp&quot;
   47 #include &quot;runtime/sharedRuntime.hpp&quot;
   48 #include &quot;runtime/signature_cc.hpp&quot;
   49 #include &quot;runtime/stubRoutines.hpp&quot;
   50 #include &quot;runtime/thread.hpp&quot;
   51 #include &quot;utilities/macros.hpp&quot;
   52 #include &quot;vmreg_x86.inline.hpp&quot;
   53 #include &quot;crc32c.h&quot;
   54 #ifdef COMPILER2
<span class="line-modified">   55 #include &quot;opto/output.hpp&quot;</span>
   56 #endif
   57 
   58 #ifdef PRODUCT
   59 #define BLOCK_COMMENT(str) /* nothing */
   60 #define STOP(error) stop(error)
   61 #else
   62 #define BLOCK_COMMENT(str) block_comment(str)
   63 #define STOP(error) block_comment(error); stop(error)
   64 #endif
   65 
   66 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
   67 
   68 #ifdef ASSERT
   69 bool AbstractAssembler::pd_check_instruction_mark() { return true; }
   70 #endif
   71 
   72 static Assembler::Condition reverse[] = {
   73     Assembler::noOverflow     /* overflow      = 0x0 */ ,
   74     Assembler::overflow       /* noOverflow    = 0x1 */ ,
   75     Assembler::aboveEqual     /* carrySet      = 0x2, below         = 0x2 */ ,
</pre>
<hr />
<pre>
 1268   bind(cas_label);
 1269 
 1270   return null_check_offset;
 1271 }
 1272 
 1273 void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label&amp; done) {
 1274   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
 1275 
 1276   // Check for biased locking unlock case, which is a no-op
 1277   // Note: we do not have to check the thread ID for two reasons.
 1278   // First, the interpreter checks for IllegalMonitorStateException at
 1279   // a higher level. Second, if the bias was revoked while we held the
 1280   // lock, the object could not be rebiased toward another thread, so
 1281   // the bias bit would be clear.
 1282   movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
 1283   andptr(temp_reg, markWord::biased_lock_mask_in_place);
 1284   cmpptr(temp_reg, markWord::biased_lock_pattern);
 1285   jcc(Assembler::equal, done);
 1286 }
 1287 


































































































































































































































































































































































































































































































































































































































































































































































































 1288 void MacroAssembler::c2bool(Register x) {
 1289   // implements x == 0 ? 0 : 1
 1290   // note: must only look at least-significant byte of x
 1291   //       since C-style booleans are stored in one byte
 1292   //       only! (was bug)
 1293   andl(x, 0xFF);
 1294   setb(Assembler::notZero, x);
 1295 }
 1296 
 1297 // Wouldn&#39;t need if AddressLiteral version had new name
 1298 void MacroAssembler::call(Label&amp; L, relocInfo::relocType rtype) {
 1299   Assembler::call(L, rtype);
 1300 }
 1301 
 1302 void MacroAssembler::call(Register entry) {
 1303   Assembler::call(entry);
 1304 }
 1305 
 1306 void MacroAssembler::call(AddressLiteral entry) {
 1307   if (reachable(entry)) {
</pre>
<hr />
<pre>
 1947 }
 1948 
 1949 void MacroAssembler::divsd(XMMRegister dst, AddressLiteral src) {
 1950   if (reachable(src)) {
 1951     Assembler::divsd(dst, as_Address(src));
 1952   } else {
 1953     lea(rscratch1, src);
 1954     Assembler::divsd(dst, Address(rscratch1, 0));
 1955   }
 1956 }
 1957 
 1958 void MacroAssembler::divss(XMMRegister dst, AddressLiteral src) {
 1959   if (reachable(src)) {
 1960     Assembler::divss(dst, as_Address(src));
 1961   } else {
 1962     lea(rscratch1, src);
 1963     Assembler::divss(dst, Address(rscratch1, 0));
 1964   }
 1965 }
 1966 











 1967 void MacroAssembler::enter() {
 1968   push(rbp);
 1969   mov(rbp, rsp);
 1970 }
 1971 
 1972 // A 5 byte nop that is safe for patching (see patch_verified_entry)
 1973 void MacroAssembler::fat_nop() {
 1974   if (UseAddressNop) {
 1975     addr_nop_5();
 1976   } else {
 1977     emit_int8(0x26); // es:
 1978     emit_int8(0x2e); // cs:
 1979     emit_int8(0x64); // fs:
 1980     emit_int8(0x65); // gs:
 1981     emit_int8((unsigned char)0x90);
 1982   }
 1983 }
 1984 
<span class="line-modified"> 1985 #ifndef _LP64</span>
 1986 void MacroAssembler::fcmp(Register tmp) {
 1987   fcmp(tmp, 1, true, true);
 1988 }
 1989 
 1990 void MacroAssembler::fcmp(Register tmp, int index, bool pop_left, bool pop_right) {
 1991   assert(!pop_right || pop_left, &quot;usage error&quot;);
 1992   if (VM_Version::supports_cmov()) {
 1993     assert(tmp == noreg, &quot;unneeded temp&quot;);
 1994     if (pop_left) {
 1995       fucomip(index);
 1996     } else {
 1997       fucomi(index);
 1998     }
 1999     if (pop_right) {
 2000       fpop();
 2001     }
 2002   } else {
 2003     assert(tmp != noreg, &quot;need temp&quot;);
 2004     if (pop_left) {
 2005       if (pop_right) {
</pre>
<hr />
<pre>
 2068   ffree();
 2069   fincstp();
 2070 }
 2071 
 2072 void MacroAssembler::fremr(Register tmp) {
 2073   save_rax(tmp);
 2074   { Label L;
 2075     bind(L);
 2076     fprem();
 2077     fwait(); fnstsw_ax();
 2078     sahf();
 2079     jcc(Assembler::parity, L);
 2080   }
 2081   restore_rax(tmp);
 2082   // Result is in ST0.
 2083   // Note: fxch &amp; fpop to get rid of ST1
 2084   // (otherwise FPU stack could overflow eventually)
 2085   fxch(1);
 2086   fpop();
 2087 }
<span class="line-added"> 2088 </span>
<span class="line-added"> 2089 void MacroAssembler::empty_FPU_stack() {</span>
<span class="line-added"> 2090   if (VM_Version::supports_mmx()) {</span>
<span class="line-added"> 2091     emms();</span>
<span class="line-added"> 2092   } else {</span>
<span class="line-added"> 2093     for (int i = 8; i-- &gt; 0; ) ffree(i);</span>
<span class="line-added"> 2094   }</span>
<span class="line-added"> 2095 }</span>
 2096 #endif // !LP64
 2097 
 2098 void MacroAssembler::mulpd(XMMRegister dst, AddressLiteral src) {
 2099   if (reachable(src)) {
 2100     Assembler::mulpd(dst, as_Address(src));
 2101   } else {
 2102     lea(rscratch1, src);
 2103     Assembler::mulpd(dst, Address(rscratch1, 0));
 2104   }
 2105 }
 2106 
 2107 void MacroAssembler::load_float(Address src) {
<span class="line-added"> 2108 #ifdef _LP64</span>
<span class="line-added"> 2109   movflt(xmm0, src);</span>
<span class="line-added"> 2110 #else</span>
 2111   if (UseSSE &gt;= 1) {
 2112     movflt(xmm0, src);
 2113   } else {
<span class="line-modified"> 2114     fld_s(src);</span>

 2115   }
<span class="line-added"> 2116 #endif // LP64</span>
 2117 }
 2118 
 2119 void MacroAssembler::store_float(Address dst) {
<span class="line-added"> 2120 #ifdef _LP64</span>
<span class="line-added"> 2121   movflt(dst, xmm0);</span>
<span class="line-added"> 2122 #else</span>
 2123   if (UseSSE &gt;= 1) {
 2124     movflt(dst, xmm0);
 2125   } else {
<span class="line-modified"> 2126     fstp_s(dst);</span>

 2127   }
<span class="line-added"> 2128 #endif // LP64</span>
 2129 }
 2130 
 2131 void MacroAssembler::load_double(Address src) {
<span class="line-added"> 2132 #ifdef _LP64</span>
<span class="line-added"> 2133   movdbl(xmm0, src);</span>
<span class="line-added"> 2134 #else</span>
 2135   if (UseSSE &gt;= 2) {
 2136     movdbl(xmm0, src);
 2137   } else {
<span class="line-modified"> 2138     fld_d(src);</span>

 2139   }
<span class="line-added"> 2140 #endif // LP64</span>
 2141 }
 2142 
 2143 void MacroAssembler::store_double(Address dst) {
<span class="line-added"> 2144 #ifdef _LP64</span>
<span class="line-added"> 2145   movdbl(dst, xmm0);</span>
<span class="line-added"> 2146 #else</span>
 2147   if (UseSSE &gt;= 2) {
 2148     movdbl(dst, xmm0);
 2149   } else {
<span class="line-modified"> 2150     fstp_d(dst);</span>

 2151   }
<span class="line-added"> 2152 #endif // LP64</span>
 2153 }
 2154 
 2155 // dst = c = a * b + c
 2156 void MacroAssembler::fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
 2157   Assembler::vfmadd231sd(c, a, b);
 2158   if (dst != c) {
 2159     movdbl(dst, c);
 2160   }
 2161 }
 2162 
 2163 // dst = c = a * b + c
 2164 void MacroAssembler::fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
 2165   Assembler::vfmadd231ss(c, a, b);
 2166   if (dst != c) {
 2167     movflt(dst, c);
 2168   }
 2169 }
 2170 
 2171 // dst = c = a * b + c
 2172 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
</pre>
<hr />
<pre>
 2437 }
 2438 
 2439 void MacroAssembler::movdl(XMMRegister dst, AddressLiteral src) {
 2440   if (reachable(src)) {
 2441     movdl(dst, as_Address(src));
 2442   } else {
 2443     lea(rscratch1, src);
 2444     movdl(dst, Address(rscratch1, 0));
 2445   }
 2446 }
 2447 
 2448 void MacroAssembler::movq(XMMRegister dst, AddressLiteral src) {
 2449   if (reachable(src)) {
 2450     movq(dst, as_Address(src));
 2451   } else {
 2452     lea(rscratch1, src);
 2453     movq(dst, Address(rscratch1, 0));
 2454   }
 2455 }
 2456 
















 2457 void MacroAssembler::movdbl(XMMRegister dst, AddressLiteral src) {
 2458   if (reachable(src)) {
 2459     if (UseXmmLoadAndClearUpper) {
 2460       movsd (dst, as_Address(src));
 2461     } else {
 2462       movlpd(dst, as_Address(src));
 2463     }
 2464   } else {
 2465     lea(rscratch1, src);
 2466     if (UseXmmLoadAndClearUpper) {
 2467       movsd (dst, Address(rscratch1, 0));
 2468     } else {
 2469       movlpd(dst, Address(rscratch1, 0));
 2470     }
 2471   }
 2472 }
 2473 
 2474 void MacroAssembler::movflt(XMMRegister dst, AddressLiteral src) {
 2475   if (reachable(src)) {
 2476     movss(dst, as_Address(src));
</pre>
<hr />
<pre>
 3311   } else {
 3312     lea(scratch_reg, src);
 3313     vxorps(dst, nds, Address(scratch_reg, 0), vector_len);
 3314   }
 3315 }
 3316 
 3317 void MacroAssembler::vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
 3318   if (UseAVX &gt; 1 || (vector_len &lt; 1)) {
 3319     if (reachable(src)) {
 3320       Assembler::vpxor(dst, nds, as_Address(src), vector_len);
 3321     } else {
 3322       lea(scratch_reg, src);
 3323       Assembler::vpxor(dst, nds, Address(scratch_reg, 0), vector_len);
 3324     }
 3325   }
 3326   else {
 3327     MacroAssembler::vxorpd(dst, nds, src, vector_len, scratch_reg);
 3328   }
 3329 }
 3330 
































































































































 3331 //-------------------------------------------------------------------------------------------
 3332 
 3333 void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {
 3334   const int32_t inverted_jweak_mask = ~static_cast&lt;int32_t&gt;(JNIHandles::weak_tag_mask);
 3335   STATIC_ASSERT(inverted_jweak_mask == -2); // otherwise check this code
 3336   // The inverted mask is sign-extended
 3337   andptr(possibly_jweak, inverted_jweak_mask);
 3338 }
 3339 
 3340 void MacroAssembler::resolve_jobject(Register value,
 3341                                      Register thread,
 3342                                      Register tmp) {
 3343   assert_different_registers(value, thread, tmp);
 3344   Label done, not_weak;
 3345   testptr(value, value);
 3346   jcc(Assembler::zero, done);                // Use NULL as-is.
 3347   testptr(value, JNIHandles::weak_tag_mask); // Test for jweak tag.
 3348   jcc(Assembler::zero, not_weak);
 3349   // Resolve jweak.
 3350   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
</pre>
<hr />
<pre>
 5042 }
 5043 
 5044 void MacroAssembler::reinit_heapbase() {
 5045   if (UseCompressedOops || UseCompressedClassPointers) {
 5046     if (Universe::heap() != NULL) {
 5047       if (CompressedOops::base() == NULL) {
 5048         MacroAssembler::xorptr(r12_heapbase, r12_heapbase);
 5049       } else {
 5050         mov64(r12_heapbase, (int64_t)CompressedOops::ptrs_base());
 5051       }
 5052     } else {
 5053       movptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
 5054     }
 5055   }
 5056 }
 5057 
 5058 #endif // _LP64
 5059 
 5060 // C2 compiled method&#39;s prolog code.
 5061 void MacroAssembler::verified_entry(Compile* C, int sp_inc) {
<span class="line-modified"> 5062   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified"> 5063   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
 5064   bool fp_mode_24b = false;
<span class="line-modified"> 5065   int stack_bang_size = C-&gt;output()-&gt;need_stack_bang(bangsize) ? bangsize : 0;</span>
 5066 
 5067   // WARNING: Initial instruction MUST be 5 bytes or longer so that
 5068   // NativeJump::patch_verified_entry will be able to patch out the entry
 5069   // code safely. The push to verify stack depth is ok at 5 bytes,
 5070   // the frame allocation can be either 3 or 6 bytes. So if we don&#39;t do
 5071   // stack bang then we must use the 6 byte frame allocation even if
 5072   // we have no frame. :-(
 5073   assert(stack_bang_size &gt;= framesize || stack_bang_size &lt;= 0, &quot;stack bang size incorrect&quot;);
 5074 
 5075   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
 5076   // Remove word for return addr
 5077   framesize -= wordSize;
 5078   stack_bang_size -= wordSize;
 5079 
 5080   // Calls to C2R adapters often do not accept exceptional returns.
 5081   // We require that their callers must bang for them.  But be careful, because
 5082   // some VM calls (such as call site linkage) can use several kilobytes of
 5083   // stack.  But the stack safety zone should account for that.
 5084   // See bugs 4446381, 4468289, 4497237.
 5085   if (stack_bang_size &gt; 0) {
</pre>
<hr />
<pre>
 5101     }
 5102   } else {
 5103     // Create frame (force generation of a 4 byte immediate value)
 5104     subptr_imm32(rsp, framesize);
 5105 
 5106     // Save RBP register now.
 5107     framesize -= wordSize;
 5108     movptr(Address(rsp, framesize), rbp);
 5109     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
 5110     if (PreserveFramePointer) {
 5111       movptr(rbp, rsp);
 5112       if (framesize &gt; 0) {
 5113         addptr(rbp, framesize);
 5114       }
 5115     }
 5116   }
 5117 
 5118   if (C-&gt;needs_stack_repair()) {
 5119     // Save stack increment (also account for fixed framesize and rbp)
 5120     assert((sp_inc &amp; (StackAlignmentInBytes-1)) == 0, &quot;stack increment not aligned&quot;);
<span class="line-modified"> 5121     movptr(Address(rsp, C-&gt;output()-&gt;sp_inc_offset()), sp_inc + framesize + wordSize);</span>
 5122   }
 5123 
 5124   if (VerifyStackAtCalls) { // Majik cookie to verify stack depth
 5125     framesize -= wordSize;
 5126     movptr(Address(rsp, framesize), (int32_t)0xbadb100d);
 5127   }
 5128 
 5129 #ifndef _LP64
 5130   // If method sets FPU control word do it now
 5131   if (fp_mode_24b) {
 5132     fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
 5133   }
 5134   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
 5135     verify_FPU(0, &quot;FPU stack must be clean on entry&quot;);
 5136   }
 5137 #endif
 5138 
 5139 #ifdef ASSERT
 5140   if (VerifyStackAtCalls) {
 5141     Label L;
</pre>
<hr />
<pre>
 5536     ret_off = 0;
 5537   } else {
 5538     // C2 code ensures that sp_inc is a reserved slot.
 5539     ret_off = sp_inc;
 5540   }
 5541 
 5542   shuffle_value_args_common(is_packing, receiver_only, extra_stack_offset,
 5543                             sig_bt, sig_cc,
 5544                             args_passed, args_on_stack, regs,
 5545                             args_passed_to, args_on_stack_to, regs_to,
 5546                             sp_inc, ret_off);
 5547 }
 5548 
 5549 VMReg MacroAssembler::spill_reg_for(VMReg reg) {
 5550   return reg-&gt;is_XMMRegister() ? xmm8-&gt;as_VMReg() : r14-&gt;as_VMReg();
 5551 }
 5552 
 5553 void MacroAssembler::remove_frame(int initial_framesize, bool needs_stack_repair, int sp_inc_offset) {
 5554   assert((initial_framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
 5555   if (needs_stack_repair) {

 5556     movq(rbp, Address(rsp, initial_framesize));
 5557     addq(rsp, Address(rsp, sp_inc_offset));
 5558   } else {
 5559     if (initial_framesize &gt; 0) {
 5560       addq(rsp, initial_framesize);
 5561     }
 5562     pop(rbp);
 5563   }
 5564 }
 5565 
 5566 void MacroAssembler::clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, bool is_large, bool word_copy_only) {
 5567   // cnt - number of qwords (8-byte words).
 5568   // base - start address, qword aligned.
 5569   // is_large - if optimizers know cnt is larger than InitArrayShortSize
 5570   assert(base==rdi, &quot;base register must be edi for rep stos&quot;);
 5571   assert(val==rax,   &quot;tmp register must be eax for rep stos&quot;);
 5572   assert(cnt==rcx,   &quot;cnt register must be ecx for rep stos&quot;);
 5573   assert(InitArrayShortSize % BytesPerLong == 0,
 5574     &quot;InitArrayShortSize should be the multiple of BytesPerLong&quot;);
 5575 
</pre>
<hr />
<pre>
 5592     jccb(Assembler::greaterEqual, LOOP);
 5593     jmpb(DONE);
 5594 
 5595     BIND(LONG);
 5596   }
 5597 
 5598   // Use longer rep-prefixed ops for non-small counts:
 5599   if (UseFastStosb &amp;&amp; !word_copy_only) {
 5600     shlptr(cnt, 3); // convert to number of bytes
 5601     rep_stosb();
 5602   } else if (UseXMMForObjInit) {
 5603     xmm_clear_mem(base, cnt, val, xtmp);
 5604   } else {
 5605     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
 5606     rep_stos();
 5607   }
 5608 
 5609   BIND(DONE);
 5610 }
 5611 













































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































 5612 void MacroAssembler::generate_fill(BasicType t, bool aligned,
 5613                                    Register to, Register value, Register count,
 5614                                    Register rtmp, XMMRegister xtmp) {
 5615   ShortBranchVerifier sbv(this);
 5616   assert_different_registers(to, value, count, rtmp);
 5617   Label L_exit;
 5618   Label L_fill_2_bytes, L_fill_4_bytes;
 5619 
 5620   int shift = -1;
 5621   switch (t) {
 5622     case T_BYTE:
 5623       shift = 2;
 5624       break;
 5625     case T_SHORT:
 5626       shift = 1;
 5627       break;
 5628     case T_INT:
 5629       shift = 0;
 5630       break;
 5631     default: ShouldNotReachHere();
</pre>
</td>
</tr>
</table>
<center><a href="interp_masm_x86.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
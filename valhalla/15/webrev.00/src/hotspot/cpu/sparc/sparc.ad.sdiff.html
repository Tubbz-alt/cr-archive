<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/sparc/sparc.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_sparc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/sparc.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  575     }
  576   }
  577 }
  578 
  579 int MachCallRuntimeNode::ret_addr_offset() {
  580   if (MacroAssembler::is_far_target(entry_point())) {
  581     return NativeFarCall::instruction_size;
  582   } else {
  583     return NativeCall::instruction_size;
  584   }
  585 }
  586 
  587 // Indicate if the safepoint node needs the polling page as an input.
  588 // Since Sparc does not have absolute addressing, it does.
  589 bool SafePointNode::needs_polling_address_input() {
  590   return true;
  591 }
  592 
  593 // emit an interrupt that is caught by the debugger (for debugging compiler)
  594 void emit_break(CodeBuffer &amp;cbuf) {
<span class="line-modified">  595   MacroAssembler _masm(&amp;cbuf);</span>
  596   __ breakpoint_trap();
  597 }
  598 
  599 #ifndef PRODUCT
  600 void MachBreakpointNode::format( PhaseRegAlloc *, outputStream *st ) const {
  601   st-&gt;print(&quot;TA&quot;);
  602 }
  603 #endif
  604 
  605 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  606   emit_break(cbuf);
  607 }
  608 
  609 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  610   return MachNode::size(ra_);
  611 }
  612 
  613 // Traceable jump
  614 void  emit_jmpl(CodeBuffer &amp;cbuf, int jump_target) {
<span class="line-modified">  615   MacroAssembler _masm(&amp;cbuf);</span>
  616   Register rdest = reg_to_register_object(jump_target);
  617   __ JMP(rdest, 0);
  618   __ delayed()-&gt;nop();
  619 }
  620 
  621 // Traceable jump and set exception pc
  622 void  emit_jmpl_set_exception_pc(CodeBuffer &amp;cbuf, int jump_target) {
<span class="line-modified">  623   MacroAssembler _masm(&amp;cbuf);</span>
  624   Register rdest = reg_to_register_object(jump_target);
  625   __ JMP(rdest, 0);
  626   __ delayed()-&gt;add(O7, frame::pc_return_offset, Oissuing_pc );
  627 }
  628 
  629 void emit_nop(CodeBuffer &amp;cbuf) {
<span class="line-modified">  630   MacroAssembler _masm(&amp;cbuf);</span>
  631   __ nop();
  632 }
  633 
  634 void emit_illtrap(CodeBuffer &amp;cbuf) {
<span class="line-modified">  635   MacroAssembler _masm(&amp;cbuf);</span>
  636   __ illtrap(0);
  637 }
  638 
  639 
  640 intptr_t get_offset_from_base(const MachNode* n, const TypePtr* atype, int disp32) {
  641   assert(n-&gt;rule() != loadUB_rule, &quot;&quot;);
  642 
  643   intptr_t offset = 0;
  644   const TypePtr *adr_type = TYPE_PTR_SENTINAL;  // Check for base==RegI, disp==immP
  645   const Node* addr = n-&gt;get_base_and_disp(offset, adr_type);
  646   assert(adr_type == (const TypePtr*)-1, &quot;VerifyOops: no support for sparc operands with base==RegI, disp==immP&quot;);
  647   assert(addr != NULL &amp;&amp; addr != (Node*)-1, &quot;invalid addr&quot;);
  648   assert(addr-&gt;bottom_type()-&gt;isa_oopptr() == atype, &quot;&quot;);
  649   atype = atype-&gt;add_offset(offset);
  650   assert(disp32 == offset, &quot;wrong disp32&quot;);
  651   return atype-&gt;_offset;
  652 }
  653 
  654 
  655 intptr_t get_offset_from_base_2(const MachNode* n, const TypePtr* atype, int disp32) {
</pre>
<hr />
<pre>
  891             ShouldNotReachHere();
  892           }
  893         }
  894       }
  895     }
  896   }
  897 #endif
  898 
  899   uint instr = (Assembler::ldst_op &lt;&lt; 30)
  900              | (dst_enc        &lt;&lt; 25)
  901              | (primary        &lt;&lt; 19)
  902              | (src1_enc       &lt;&lt; 14);
  903 
  904   uint index = src2_enc;
  905   int disp = disp32;
  906 
  907   if (src1_enc == R_SP_enc || src1_enc == R_FP_enc) {
  908     disp += STACK_BIAS;
  909     // Check that stack offset fits, load into O7 if not
  910     if (!Assembler::is_simm13(disp)) {
<span class="line-modified">  911       MacroAssembler _masm(&amp;cbuf);</span>
  912       __ set(disp, O7);
  913       if (index != R_G0_enc) {
  914         __ add(O7, reg_to_register_object(index), O7);
  915       }
  916       index = R_O7_enc;
  917       disp = 0;
  918     }
  919   }
  920 
  921   if( disp == 0 ) {
  922     // use reg-reg form
  923     // bit 13 is already zero
  924     instr |= index;
  925   } else {
  926     // use reg-imm form
  927     instr |= 0x00002000;          // set bit 13 to one
  928     instr |= disp &amp; 0x1FFF;
  929   }
  930 
  931   cbuf.insts()-&gt;emit_int32(instr);
  932 
  933 #ifdef ASSERT
  934   if (VerifyOops) {
<span class="line-modified">  935     MacroAssembler _masm(&amp;cbuf);</span>
  936     if (is_verified_oop_base) {
  937       __ verify_oop(reg_to_register_object(src1_enc));
  938     }
  939     if (is_verified_oop_store) {
  940       __ verify_oop(reg_to_register_object(dst_enc));
  941     }
  942     if (tmp_enc != -1) {
  943       __ mov(O7, reg_to_register_object(tmp_enc));
  944     }
  945     if (is_verified_oop_load) {
  946       __ verify_oop(reg_to_register_object(dst_enc));
  947     }
  948   }
  949 #endif
  950 }
  951 
  952 void emit_call_reloc(CodeBuffer &amp;cbuf, intptr_t entry_point, RelocationHolder const&amp; rspec, bool preserve_g2 = false) {
  953   // The method which records debug information at every safepoint
  954   // expects the call to be the first instruction in the snippet as
  955   // it creates a PcDesc structure which tracks the offset of a call
  956   // from the start of the codeBlob. This offset is computed as
  957   // code_end() - code_begin() of the code which has been emitted
  958   // so far.
  959   // In this particular case we have skirted around the problem by
  960   // putting the &quot;mov&quot; instruction in the delay slot but the problem
  961   // may bite us again at some other point and a cleaner/generic
  962   // solution using relocations would be needed.
<span class="line-modified">  963   MacroAssembler _masm(&amp;cbuf);</span>
  964   __ set_inst_mark();
  965 
  966   // We flush the current window just so that there is a valid stack copy
  967   // the fact that the current window becomes active again instantly is
  968   // not a problem there is nothing live in it.
  969 
  970 #ifdef ASSERT
  971   int startpos = __ offset();
  972 #endif /* ASSERT */
  973 
  974   __ call((address)entry_point, rspec);
  975 
  976   if (preserve_g2)   __ delayed()-&gt;mov(G2, L7);
  977   else __ delayed()-&gt;nop();
  978 
  979   if (preserve_g2)   __ mov(L7, G2);
  980 
  981 #ifdef ASSERT
  982   if (preserve_g2 &amp;&amp; (VerifyCompiledCode || VerifyOops)) {
  983     // Trash argument dump slots.
</pre>
<hr />
<pre>
  985     __ mov(G1, G5);
  986     __ stx(G1, SP, STACK_BIAS + 0x80);
  987     __ stx(G1, SP, STACK_BIAS + 0x88);
  988     __ stx(G1, SP, STACK_BIAS + 0x90);
  989     __ stx(G1, SP, STACK_BIAS + 0x98);
  990     __ stx(G1, SP, STACK_BIAS + 0xA0);
  991     __ stx(G1, SP, STACK_BIAS + 0xA8);
  992   }
  993 #endif /*ASSERT*/
  994 }
  995 
  996 //=============================================================================
  997 // REQUIRED FUNCTIONALITY for encoding
  998 void emit_lo(CodeBuffer &amp;cbuf, int val) {  }
  999 void emit_hi(CodeBuffer &amp;cbuf, int val) {  }
 1000 
 1001 
 1002 //=============================================================================
 1003 const RegMask&amp; MachConstantBaseNode::_out_RegMask = PTR_REG_mask();
 1004 
<span class="line-modified"> 1005 int Compile::ConstantTable::calculate_table_base_offset() const {</span>
 1006   if (UseRDPCForConstantTableBase) {
 1007     // The table base offset might be less but then it fits into
 1008     // simm13 anyway and we are good (cf. MachConstantBaseNode::emit).
 1009     return Assembler::min_simm13();
 1010   } else {
 1011     int offset = -(size() / 2);
 1012     if (!Assembler::is_simm13(offset)) {
 1013       offset = Assembler::min_simm13();
 1014     }
 1015     return offset;
 1016   }
 1017 }
 1018 
 1019 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
 1020 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 1021   ShouldNotReachHere();
 1022 }
 1023 
 1024 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1025   Compile* C = ra_-&gt;C;
<span class="line-modified"> 1026   Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
<span class="line-modified"> 1027   MacroAssembler _masm(&amp;cbuf);</span>
 1028 
 1029   Register r = as_Register(ra_-&gt;get_encode(this));
 1030   CodeSection* consts_section = __ code()-&gt;consts();
 1031   int consts_size = consts_section-&gt;align_at_start(consts_section-&gt;size());
 1032   assert(constant_table.size() == consts_size, &quot;must be: %d == %d&quot;, constant_table.size(), consts_size);
 1033 
 1034   if (UseRDPCForConstantTableBase) {
 1035     // For the following RDPC logic to work correctly the consts
 1036     // section must be allocated right before the insts section.  This
 1037     // assert checks for that.  The layout and the SECT_* constants
 1038     // are defined in src/share/vm/asm/codeBuffer.hpp.
 1039     assert(CodeBuffer::SECT_CONSTS + 1 == CodeBuffer::SECT_INSTS, &quot;must be&quot;);
 1040     int insts_offset = __ offset();
 1041 
 1042     // Layout:
 1043     //
 1044     // |----------- consts section ------------|----------- insts section -----------...
 1045     // |------ constant table -----|- padding -|------------------x----
 1046     //                                                            \ current PC (RDPC instruction)
 1047     // |&lt;------------- consts_size -----------&gt;|&lt;- insts_offset -&gt;|
</pre>
<hr />
<pre>
 1111     st-&gt;print(&quot;SET    &amp;constanttable,%s\t! constant table base&quot;, reg);
 1112   }
 1113 }
 1114 #endif
 1115 
 1116 
 1117 //=============================================================================
 1118 
 1119 #ifndef PRODUCT
 1120 void MachPrologNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1121   Compile* C = ra_-&gt;C;
 1122 
 1123   for (int i = 0; i &lt; OptoPrologueNops; i++) {
 1124     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
 1125   }
 1126 
 1127   if( VerifyThread ) {
 1128     st-&gt;print_cr(&quot;Verify_Thread&quot;); st-&gt;print(&quot;\t&quot;);
 1129   }
 1130 
<span class="line-modified"> 1131   size_t framesize = C-&gt;frame_size_in_bytes();</span>
<span class="line-modified"> 1132   int bangsize = C-&gt;bang_size_in_bytes();</span>
 1133 
 1134   // Calls to C2R adapters often do not accept exceptional returns.
 1135   // We require that their callers must bang for them.  But be careful, because
 1136   // some VM calls (such as call site linkage) can use several kilobytes of
 1137   // stack.  But the stack safety zone should account for that.
 1138   // See bugs 4446381, 4468289, 4497237.
<span class="line-modified"> 1139   if (C-&gt;need_stack_bang(bangsize)) {</span>
 1140     st-&gt;print_cr(&quot;! stack bang (%d bytes)&quot;, bangsize); st-&gt;print(&quot;\t&quot;);
 1141   }
 1142 
 1143   if (Assembler::is_simm13(-framesize)) {
 1144     st-&gt;print   (&quot;SAVE   R_SP,-&quot; SIZE_FORMAT &quot;,R_SP&quot;,framesize);
 1145   } else {
 1146     st-&gt;print_cr(&quot;SETHI  R_SP,hi%%(-&quot; SIZE_FORMAT &quot;),R_G3&quot;,framesize); st-&gt;print(&quot;\t&quot;);
 1147     st-&gt;print_cr(&quot;ADD    R_G3,lo%%(-&quot; SIZE_FORMAT &quot;),R_G3&quot;,framesize); st-&gt;print(&quot;\t&quot;);
 1148     st-&gt;print   (&quot;SAVE   R_SP,R_G3,R_SP&quot;);
 1149   }
 1150 
 1151 }
 1152 #endif
 1153 
 1154 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1155   Compile* C = ra_-&gt;C;
<span class="line-modified"> 1156   MacroAssembler _masm(&amp;cbuf);</span>
 1157 
 1158   for (int i = 0; i &lt; OptoPrologueNops; i++) {
 1159     __ nop();
 1160   }
 1161 
 1162   __ verify_thread();
 1163 
<span class="line-modified"> 1164   size_t framesize = C-&gt;frame_size_in_bytes();</span>
 1165   assert(framesize &gt;= 16*wordSize, &quot;must have room for reg. save area&quot;);
 1166   assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
<span class="line-modified"> 1167   int bangsize = C-&gt;bang_size_in_bytes();</span>
 1168 
 1169   // Calls to C2R adapters often do not accept exceptional returns.
 1170   // We require that their callers must bang for them.  But be careful, because
 1171   // some VM calls (such as call site linkage) can use several kilobytes of
 1172   // stack.  But the stack safety zone should account for that.
 1173   // See bugs 4446381, 4468289, 4497237.
<span class="line-modified"> 1174   if (C-&gt;need_stack_bang(bangsize)) {</span>
 1175     __ generate_stack_overflow_check(bangsize);
 1176   }
 1177 
 1178   if (Assembler::is_simm13(-framesize)) {
 1179     __ save(SP, -framesize, SP);
 1180   } else {
 1181     __ sethi(-framesize &amp; ~0x3ff, G3);
 1182     __ add(G3, -framesize &amp; 0x3ff, G3);
 1183     __ save(SP, G3, SP);
 1184   }
<span class="line-modified"> 1185   C-&gt;set_frame_complete( __ offset() );</span>
 1186 
 1187   if (!UseRDPCForConstantTableBase &amp;&amp; C-&gt;has_mach_constant_base_node()) {
 1188     // NOTE: We set the table base offset here because users might be
 1189     // emitted before MachConstantBaseNode.
<span class="line-modified"> 1190     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
 1191     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 1192   }
 1193 }
 1194 
 1195 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
 1196   return MachNode::size(ra_);
 1197 }
 1198 
 1199 int MachPrologNode::reloc() const {
 1200   return 10; // a large enough number
 1201 }
 1202 
 1203 //=============================================================================
 1204 #ifndef PRODUCT
 1205 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1206   Compile* C = ra_-&gt;C;
 1207 
 1208   if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
 1209     if (SafepointMechanism::uses_global_page_poll()) {
 1210       st-&gt;print(&quot;SETHI  #PollAddr,L0\t! Load Polling address\n\t&quot;);
 1211     } else {
 1212       st-&gt;print(&quot;LDX    [R_G2 + #poll_offset],L0\t! Load local polling address\n\t&quot;);
 1213     }
 1214     st-&gt;print(&quot;LDX    [L0],G0\t!Poll for Safepointing\n\t&quot;);
 1215   }
 1216 
 1217   if(do_polling()) {
 1218     if (UseCBCond &amp;&amp; !ra_-&gt;C-&gt;is_method_compilation()) {
 1219       st-&gt;print(&quot;NOP\n\t&quot;);
 1220     }
 1221     st-&gt;print(&quot;RET\n\t&quot;);
 1222   }
 1223 
 1224   st-&gt;print(&quot;RESTORE&quot;);
 1225 }
 1226 #endif
 1227 
 1228 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1229   MacroAssembler _masm(&amp;cbuf);</span>
 1230   Compile* C = ra_-&gt;C;
 1231 
 1232   __ verify_thread();
 1233 
 1234   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
 1235     __ reserved_stack_check();
 1236   }
 1237 
 1238   // If this does safepoint polling, then do it here
 1239   if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
 1240     if (SafepointMechanism::uses_thread_local_poll()) {
 1241       __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), L0);
 1242     } else {
 1243       AddressLiteral polling_page(os::get_polling_page());
 1244       __ sethi(polling_page, L0);
 1245     }
 1246     __ relocate(relocInfo::poll_return_type);
 1247     __ ld_ptr(L0, 0, G0);
 1248   }
 1249 
</pre>
<hr />
<pre>
 1517   implementation( NULL, ra_, false, st );
 1518 }
 1519 #endif
 1520 
 1521 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1522   implementation( &amp;cbuf, ra_, false, NULL );
 1523 }
 1524 
 1525 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1526   return MachNode::size(ra_);
 1527 }
 1528 
 1529 //=============================================================================
 1530 #ifndef PRODUCT
 1531 void MachNopNode::format(PhaseRegAlloc *, outputStream *st) const {
 1532   st-&gt;print(&quot;NOP \t# %d bytes pad for loops and calls&quot;, 4 * _count);
 1533 }
 1534 #endif
 1535 
 1536 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *) const {
<span class="line-modified"> 1537   MacroAssembler _masm(&amp;cbuf);</span>
 1538   for (int i = 0; i &lt; _count; i += 1) {
 1539     __ nop();
 1540   }
 1541 }
 1542 
 1543 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 1544   return 4 * _count;
 1545 }
 1546 
 1547 
 1548 //=============================================================================
 1549 #ifndef PRODUCT
 1550 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1551   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1552   int reg = ra_-&gt;get_reg_first(this);
 1553   st-&gt;print(&quot;LEA    [R_SP+#%d+BIAS],%s&quot;,offset,Matcher::regName[reg]);
 1554 }
 1555 #endif
 1556 
 1557 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1558   MacroAssembler _masm(&amp;cbuf);</span>
 1559   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem()) + STACK_BIAS;
 1560   int reg = ra_-&gt;get_encode(this);
 1561 
 1562   if (Assembler::is_simm13(offset)) {
 1563      __ add(SP, offset, reg_to_register_object(reg));
 1564   } else {
 1565      __ set(offset, O7);
 1566      __ add(SP, O7, reg_to_register_object(reg));
 1567   }
 1568 }
 1569 
 1570 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1571   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
 1572   assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
<span class="line-modified"> 1573   return ra_-&gt;C-&gt;scratch_emit_size(this);</span>
 1574 }
 1575 
 1576 //=============================================================================
 1577 #ifndef PRODUCT
 1578 void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1579   st-&gt;print_cr(&quot;\nUEP:&quot;);
 1580   if (UseCompressedClassPointers) {
 1581     assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 1582     st-&gt;print_cr(&quot;\tLDUW   [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check - compressed klass&quot;);
 1583     if (CompressedKlassPointers::base() != 0) {
 1584       st-&gt;print_cr(&quot;\tSET    CompressedKlassPointers::base,R_G6_heap_base&quot;);
 1585       if (CompressedKlassPointers::shift() != 0) {
 1586         st-&gt;print_cr(&quot;\tSLL    R_G5,CompressedKlassPointers::shift,R_G5&quot;);
 1587       }
 1588       st-&gt;print_cr(&quot;\tADD    R_G5,R_G6_heap_base,R_G5&quot;);
 1589       st-&gt;print_cr(&quot;\tSET    CompressedOops::ptrs_base,R_G6_heap_base&quot;);
 1590     } else {
 1591       st-&gt;print_cr(&quot;\tSLL    R_G5,CompressedKlassPointers::shift,R_G5&quot;);
 1592     }
 1593   } else {
 1594     st-&gt;print_cr(&quot;\tLDX    [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check&quot;);
 1595   }
 1596   st-&gt;print_cr(&quot;\tCMP    R_G5,R_G3&quot; );
 1597   st-&gt;print   (&quot;\tTne    xcc,R_G0+ST_RESERVED_FOR_USER_0+2&quot;);
 1598 }
 1599 #endif
 1600 
 1601 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1602   MacroAssembler _masm(&amp;cbuf);</span>
 1603   Register G5_ic_reg  = reg_to_register_object(Matcher::inline_cache_reg_encode());
 1604   Register temp_reg   = G3;
 1605   assert( G5_ic_reg != temp_reg, &quot;conflicting registers&quot; );
 1606 
 1607   // Load klass from receiver
 1608   __ load_klass(O0, temp_reg);
 1609   // Compare against expected klass
 1610   __ cmp(temp_reg, G5_ic_reg);
 1611   // Branch to miss code, checks xcc or icc depending
 1612   __ trap(Assembler::notEqual, Assembler::ptr_cc, G0, ST_RESERVED_FOR_USER_0+2);
 1613 }
 1614 
 1615 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1616   return MachNode::size(ra_);
 1617 }
 1618 
 1619 
 1620 //=============================================================================
 1621 
 1622 
 1623 // Emit exception handler code.
 1624 int HandlerImpl::emit_exception_handler(CodeBuffer&amp; cbuf) {
 1625   Register temp_reg = G3;
 1626   AddressLiteral exception_blob(OptoRuntime::exception_blob()-&gt;entry_point());
<span class="line-modified"> 1627   MacroAssembler _masm(&amp;cbuf);</span>
 1628 
 1629   address base = __ start_a_stub(size_exception_handler());
 1630   if (base == NULL) {
 1631     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1632     return 0;  // CodeBuffer::expand failed
 1633   }
 1634 
 1635   int offset = __ offset();
 1636 
 1637   __ JUMP(exception_blob, temp_reg, 0); // sethi;jmp
 1638   __ delayed()-&gt;nop();
 1639 
 1640   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
 1641 
 1642   __ end_a_stub();
 1643 
 1644   return offset;
 1645 }
 1646 
 1647 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
 1648   // Can&#39;t use any of the current frame&#39;s registers as we may have deopted
 1649   // at a poll and everything (including G3) can be live.
 1650   Register temp_reg = L0;
 1651   AddressLiteral deopt_blob(SharedRuntime::deopt_blob()-&gt;unpack());
<span class="line-modified"> 1652   MacroAssembler _masm(&amp;cbuf);</span>
 1653 
 1654   address base = __ start_a_stub(size_deopt_handler());
 1655   if (base == NULL) {
 1656     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1657     return 0;  // CodeBuffer::expand failed
 1658   }
 1659 
 1660   int offset = __ offset();
 1661   __ save_frame(0);
 1662   __ JUMP(deopt_blob, temp_reg, 0); // sethi;jmp
 1663   __ delayed()-&gt;restore();
 1664 
 1665   assert(__ offset() - offset &lt;= (int) size_deopt_handler(), &quot;overflow&quot;);
 1666 
 1667   __ end_a_stub();
 1668   return offset;
 1669 
 1670 }
 1671 
 1672 // Given a register encoding, produce a Integer Register object
</pre>
<hr />
<pre>
 1990 // operand to generate a function which returns its register number when
 1991 // queried.   CONST_INTER causes an operand to generate a function which
 1992 // returns the value of the constant when queried.  MEMORY_INTER causes an
 1993 // operand to generate four functions which return the Base Register, the
 1994 // Index Register, the Scale Value, and the Offset Value of the operand when
 1995 // queried.  COND_INTER causes an operand to generate six functions which
 1996 // return the encoding code (ie - encoding bits for the instruction)
 1997 // associated with each basic boolean condition for a conditional instruction.
 1998 //
 1999 // Instructions specify two basic values for encoding.  Again, a function
 2000 // is available to check if the constant displacement is an oop. They use the
 2001 // ins_encode keyword to specify their encoding classes (which must be
 2002 // a sequence of enc_class names, and their parameters, specified in
 2003 // the encoding block), and they use the
 2004 // opcode keyword to specify, in order, their primary, secondary, and
 2005 // tertiary opcode.  Only the opcode sections which a particular instruction
 2006 // needs for encoding need to be specified.
 2007 encode %{
 2008   enc_class enc_untested %{
 2009 #ifdef ASSERT
<span class="line-modified"> 2010     MacroAssembler _masm(&amp;cbuf);</span>
 2011     __ untested(&quot;encoding&quot;);
 2012 #endif
 2013   %}
 2014 
 2015   enc_class form3_mem_reg( memory mem, iRegI dst ) %{
 2016     emit_form3_mem_reg(cbuf, ra_, this, $primary, $tertiary,
 2017                        $mem$$base, $mem$$disp, $mem$$index, $dst$$reg);
 2018   %}
 2019 
 2020   enc_class simple_form3_mem_reg( memory mem, iRegI dst ) %{
 2021     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2022                        $mem$$base, $mem$$disp, $mem$$index, $dst$$reg);
 2023   %}
 2024 
 2025   enc_class form3_mem_prefetch_read( memory mem ) %{
 2026     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2027                        $mem$$base, $mem$$disp, $mem$$index, 0/*prefetch function many-reads*/);
 2028   %}
 2029 
 2030   enc_class form3_mem_prefetch_write( memory mem ) %{
</pre>
<hr />
<pre>
 2125   %}
 2126 
 2127   enc_class form3_sd_rs1_imm6_rd( iRegL rs1, immU6 imm6, iRegL rd ) %{
 2128     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, ($imm6$$constant &amp; 0x3F) | 0x1000 );
 2129   %}
 2130 
 2131   enc_class form3_sd_rs1_rs2_rd( iRegL rs1, iRegI rs2, iRegL rd ) %{
 2132     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, 0x80, $rs2$$reg );
 2133   %}
 2134 
 2135   enc_class form3_rs1_simm13_rd( iRegI rs1, immI13 simm13, iRegI rd ) %{
 2136     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $simm13$$constant );
 2137   %}
 2138 
 2139   enc_class move_return_pc_to_o1() %{
 2140     emit3_simm13( cbuf, Assembler::arith_op, R_O1_enc, Assembler::add_op3, R_O7_enc, frame::pc_return_offset );
 2141   %}
 2142 
 2143   /* %%% merge with enc_to_bool */
 2144   enc_class enc_convP2B( iRegI dst, iRegP src ) %{
<span class="line-modified"> 2145     MacroAssembler _masm(&amp;cbuf);</span>
 2146 
 2147     Register   src_reg = reg_to_register_object($src$$reg);
 2148     Register   dst_reg = reg_to_register_object($dst$$reg);
 2149     __ movr(Assembler::rc_nz, src_reg, 1, dst_reg);
 2150   %}
 2151 
 2152   enc_class enc_cadd_cmpLTMask( iRegI p, iRegI q, iRegI y, iRegI tmp ) %{
 2153     // (Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)))
<span class="line-modified"> 2154     MacroAssembler _masm(&amp;cbuf);</span>
 2155 
 2156     Register   p_reg = reg_to_register_object($p$$reg);
 2157     Register   q_reg = reg_to_register_object($q$$reg);
 2158     Register   y_reg = reg_to_register_object($y$$reg);
 2159     Register tmp_reg = reg_to_register_object($tmp$$reg);
 2160 
 2161     __ subcc( p_reg, q_reg,   p_reg );
 2162     __ add  ( p_reg, y_reg, tmp_reg );
 2163     __ movcc( Assembler::less, false, Assembler::icc, tmp_reg, p_reg );
 2164   %}
 2165 
 2166   enc_class form_d2i_helper(regD src, regF dst) %{
 2167     // fcmp %fcc0,$src,$src
 2168     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmpd_opf, $src$$reg );
 2169     // branch %fcc0 not-nan, predict taken
 2170     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2171     // fdtoi $src,$dst
 2172     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fdtoi_opf, $src$$reg );
 2173     // fitos $dst,$dst (if nan)
 2174     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fitos_opf, $dst$$reg );
</pre>
<hr />
<pre>
 2267   %}
 2268 
 2269 
 2270   // Compare longs and convert into -1, 0, 1.
 2271   enc_class cmpl_flag( iRegL src1, iRegL src2, iRegI dst ) %{
 2272     // CMP $src1,$src2
 2273     emit3( cbuf, Assembler::arith_op, 0, Assembler::subcc_op3, $src1$$reg, 0, $src2$$reg );
 2274     // blt,a,pn done
 2275     emit2_19( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::less   , Assembler::bp_op2, Assembler::xcc, 0/*predict not taken*/, 5 );
 2276     // mov dst,-1 in delay slot
 2277     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0, -1 );
 2278     // bgt,a,pn done
 2279     emit2_19( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::greater, Assembler::bp_op2, Assembler::xcc, 0/*predict not taken*/, 3 );
 2280     // mov dst,1 in delay slot
 2281     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0,  1 );
 2282     // CLR    $dst
 2283     emit3( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3 , 0, 0, 0 );
 2284   %}
 2285 
 2286   enc_class enc_PartialSubtypeCheck() %{
<span class="line-modified"> 2287     MacroAssembler _masm(&amp;cbuf);</span>
 2288     __ call(StubRoutines::Sparc::partial_subtype_check(), relocInfo::runtime_call_type);
 2289     __ delayed()-&gt;nop();
 2290   %}
 2291 
 2292   enc_class enc_bp( label labl, cmpOp cmp, flagsReg cc ) %{
<span class="line-modified"> 2293     MacroAssembler _masm(&amp;cbuf);</span>
 2294     Label* L = $labl$$label;
 2295     Assembler::Predict predict_taken =
 2296       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 2297 
 2298     __ bp( (Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 2299     __ delayed()-&gt;nop();
 2300   %}
 2301 
 2302   enc_class enc_bpr( label labl, cmpOp_reg cmp, iRegI op1 ) %{
<span class="line-modified"> 2303     MacroAssembler _masm(&amp;cbuf);</span>
 2304     Label* L = $labl$$label;
 2305     Assembler::Predict predict_taken =
 2306       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 2307 
 2308     __ bpr( (Assembler::RCondition)($cmp$$cmpcode), false, predict_taken, as_Register($op1$$reg), *L);
 2309     __ delayed()-&gt;nop();
 2310   %}
 2311 
 2312   enc_class enc_cmov_reg( cmpOp cmp, iRegI dst, iRegI src, immI pcc) %{
 2313     int op = (Assembler::arith_op &lt;&lt; 30) |
 2314              ($dst$$reg &lt;&lt; 25) |
 2315              (Assembler::movcc_op3 &lt;&lt; 19) |
 2316              (1 &lt;&lt; 18) |                    // cc2 bit for &#39;icc&#39;
 2317              ($cmp$$cmpcode &lt;&lt; 14) |
 2318              (0 &lt;&lt; 13) |                    // select register move
 2319              ($pcc$$constant &lt;&lt; 11) |       // cc1, cc0 bits for &#39;icc&#39; or &#39;xcc&#39;
 2320              ($src$$reg &lt;&lt; 0);
 2321     cbuf.insts()-&gt;emit_int32(op);
 2322   %}
 2323 
</pre>
<hr />
<pre>
 2402     int op = (Assembler::arith_op &lt;&lt; 30) |
 2403              ($dst$$reg &lt;&lt; 25) |
 2404              (Assembler::movcc_op3 &lt;&lt; 19) |
 2405              (6 &lt;&lt; 16) |                    // cc2 bit for &#39;xcc&#39;
 2406              ($primary &lt;&lt; 14) |
 2407              (0 &lt;&lt; 13) |                    // select register move
 2408              (0 &lt;&lt; 11) |                    // cc1, cc0 bits for &#39;icc&#39;
 2409              ($src$$reg &lt;&lt; 0);
 2410     cbuf.insts()-&gt;emit_int32(op);
 2411   %}
 2412 
 2413   enc_class Set13( immI13 src, iRegI rd ) %{
 2414     emit3_simm13( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, $src$$constant );
 2415   %}
 2416 
 2417   enc_class SetHi22( immI src, iRegI rd ) %{
 2418     emit2_22( cbuf, Assembler::branch_op, $rd$$reg, Assembler::sethi_op2, $src$$constant );
 2419   %}
 2420 
 2421   enc_class Set32( immI src, iRegI rd ) %{
<span class="line-modified"> 2422     MacroAssembler _masm(&amp;cbuf);</span>
 2423     __ set($src$$constant, reg_to_register_object($rd$$reg));
 2424   %}
 2425 
 2426   enc_class call_epilog %{
 2427     if( VerifyStackAtCalls ) {
<span class="line-modified"> 2428       MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-modified"> 2429       int framesize = ra_-&gt;C-&gt;frame_size_in_bytes();</span>
 2430       Register temp_reg = G3;
 2431       __ add(SP, framesize, temp_reg);
 2432       __ cmp(temp_reg, FP);
 2433       __ breakpoint_trap(Assembler::notEqual, Assembler::ptr_cc);
 2434     }
 2435   %}
 2436 
 2437   // Long values come back from native calls in O0:O1 in the 32-bit VM, copy the value
 2438   // to G1 so the register allocator will not have to deal with the misaligned register
 2439   // pair.
 2440   enc_class adjust_long_from_native_call %{
 2441   %}
 2442 
 2443   enc_class Java_To_Runtime (method meth) %{    // CALL Java_To_Runtime
 2444     // CALL directly to the runtime
 2445     // The user of this is responsible for ensuring that R_L7 is empty (killed).
 2446     emit_call_reloc(cbuf, $meth$$method, runtime_call_Relocation::spec(), /*preserve_g2=*/true);
 2447   %}
 2448 
 2449   enc_class preserve_SP %{
<span class="line-modified"> 2450     MacroAssembler _masm(&amp;cbuf);</span>
 2451     __ mov(SP, L7_mh_SP_save);
 2452   %}
 2453 
 2454   enc_class restore_SP %{
<span class="line-modified"> 2455     MacroAssembler _masm(&amp;cbuf);</span>
 2456     __ mov(L7_mh_SP_save, SP);
 2457   %}
 2458 
 2459   enc_class Java_Static_Call (method meth) %{    // JAVA STATIC CALL
 2460     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 2461     // who we intended to call.
 2462     if (!_method) {
 2463       emit_call_reloc(cbuf, $meth$$method, runtime_call_Relocation::spec());
 2464     } else {
 2465       int method_index = resolved_method_index(cbuf);
 2466       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2467                                                   : static_call_Relocation::spec(method_index);
 2468       emit_call_reloc(cbuf, $meth$$method, rspec);
 2469 
 2470       // Emit stub for static call.
 2471       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 2472       if (stub == NULL) {
 2473         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2474         return;
 2475       }
 2476     }
 2477   %}
 2478 
 2479   enc_class Java_Dynamic_Call (method meth) %{    // JAVA DYNAMIC CALL
<span class="line-modified"> 2480     MacroAssembler _masm(&amp;cbuf);</span>
 2481     __ set_inst_mark();
 2482     int vtable_index = this-&gt;_vtable_index;
 2483     // MachCallDynamicJavaNode::ret_addr_offset uses this same test
 2484     if (vtable_index &lt; 0) {
 2485       // must be invalid_vtable_index, not nonvirtual_vtable_index
 2486       assert(vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
 2487       Register G5_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2488       assert(G5_ic_reg == G5_inline_cache_reg, &quot;G5_inline_cache_reg used in assemble_ic_buffer_code()&quot;);
 2489       assert(G5_ic_reg == G5_megamorphic_method, &quot;G5_megamorphic_method used in megamorphic call stub&quot;);
 2490       __ ic_call((address)$meth$$method, /*emit_delay=*/true, resolved_method_index(cbuf));
 2491     } else {
 2492       assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 2493       // Just go thru the vtable
 2494       // get receiver klass (receiver already checked for non-null)
 2495       // If we end up going thru a c2i adapter interpreter expects method in G5
 2496       int off = __ offset();
 2497       __ load_klass(O0, G3_scratch);
 2498       int klass_load_size;
 2499       if (UseCompressedClassPointers) {
 2500         assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
</pre>
<hr />
<pre>
 2509       } else {
 2510         // Generate 2 instructions
 2511         __ Assembler::sethi(v_off &amp; ~0x3ff, G5_method);
 2512         __ or3(G5_method, v_off &amp; 0x3ff, G5_method);
 2513         // ld_ptr, set_hi, set
 2514         assert(__ offset() - off == klass_load_size + 2*BytesPerInstWord,
 2515                &quot;Unexpected instruction size(s)&quot;);
 2516         __ ld_ptr(G3, G5_method, G5_method);
 2517       }
 2518       // NOTE: for vtable dispatches, the vtable entry will never be null.
 2519       // However it may very well end up in handle_wrong_method if the
 2520       // method is abstract for the particular class.
 2521       __ ld_ptr(G5_method, in_bytes(Method::from_compiled_offset()), G3_scratch);
 2522       // jump to target (either compiled code or c2iadapter)
 2523       __ jmpl(G3_scratch, G0, O7);
 2524       __ delayed()-&gt;nop();
 2525     }
 2526   %}
 2527 
 2528   enc_class Java_Compiled_Call (method meth) %{    // JAVA COMPILED CALL
<span class="line-modified"> 2529     MacroAssembler _masm(&amp;cbuf);</span>
 2530 
 2531     Register G5_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2532     Register temp_reg = G3;   // caller must kill G3!  We cannot reuse G5_ic_reg here because
 2533                               // we might be calling a C2I adapter which needs it.
 2534 
 2535     assert(temp_reg != G5_ic_reg, &quot;conflicting registers&quot;);
 2536     // Load nmethod
 2537     __ ld_ptr(G5_ic_reg, in_bytes(Method::from_compiled_offset()), temp_reg);
 2538 
 2539     // CALL to compiled java, indirect the contents of G3
 2540     __ set_inst_mark();
 2541     __ callr(temp_reg, G0);
 2542     __ delayed()-&gt;nop();
 2543   %}
 2544 
 2545 enc_class idiv_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst) %{
<span class="line-modified"> 2546     MacroAssembler _masm(&amp;cbuf);</span>
 2547     Register Rdividend = reg_to_register_object($src1$$reg);
 2548     Register Rdivisor = reg_to_register_object($src2$$reg);
 2549     Register Rresult = reg_to_register_object($dst$$reg);
 2550 
 2551     __ sra(Rdivisor, 0, Rdivisor);
 2552     __ sra(Rdividend, 0, Rdividend);
 2553     __ sdivx(Rdividend, Rdivisor, Rresult);
 2554 %}
 2555 
 2556 enc_class idiv_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst) %{
<span class="line-modified"> 2557     MacroAssembler _masm(&amp;cbuf);</span>
 2558 
 2559     Register Rdividend = reg_to_register_object($src1$$reg);
 2560     int divisor = $imm$$constant;
 2561     Register Rresult = reg_to_register_object($dst$$reg);
 2562 
 2563     __ sra(Rdividend, 0, Rdividend);
 2564     __ sdivx(Rdividend, divisor, Rresult);
 2565 %}
 2566 
 2567 enc_class enc_mul_hi(iRegIsafe dst, iRegIsafe src1, iRegIsafe src2) %{
<span class="line-modified"> 2568     MacroAssembler _masm(&amp;cbuf);</span>
 2569     Register Rsrc1 = reg_to_register_object($src1$$reg);
 2570     Register Rsrc2 = reg_to_register_object($src2$$reg);
 2571     Register Rdst  = reg_to_register_object($dst$$reg);
 2572 
 2573     __ sra( Rsrc1, 0, Rsrc1 );
 2574     __ sra( Rsrc2, 0, Rsrc2 );
 2575     __ mulx( Rsrc1, Rsrc2, Rdst );
 2576     __ srlx( Rdst, 32, Rdst );
 2577 %}
 2578 
 2579 enc_class irem_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst, o7RegL scratch) %{
<span class="line-modified"> 2580     MacroAssembler _masm(&amp;cbuf);</span>
 2581     Register Rdividend = reg_to_register_object($src1$$reg);
 2582     Register Rdivisor = reg_to_register_object($src2$$reg);
 2583     Register Rresult = reg_to_register_object($dst$$reg);
 2584     Register Rscratch = reg_to_register_object($scratch$$reg);
 2585 
 2586     assert(Rdividend != Rscratch, &quot;&quot;);
 2587     assert(Rdivisor  != Rscratch, &quot;&quot;);
 2588 
 2589     __ sra(Rdividend, 0, Rdividend);
 2590     __ sra(Rdivisor, 0, Rdivisor);
 2591     __ sdivx(Rdividend, Rdivisor, Rscratch);
 2592     __ mulx(Rscratch, Rdivisor, Rscratch);
 2593     __ sub(Rdividend, Rscratch, Rresult);
 2594 %}
 2595 
 2596 enc_class irem_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst, o7RegL scratch) %{
<span class="line-modified"> 2597     MacroAssembler _masm(&amp;cbuf);</span>
 2598 
 2599     Register Rdividend = reg_to_register_object($src1$$reg);
 2600     int divisor = $imm$$constant;
 2601     Register Rresult = reg_to_register_object($dst$$reg);
 2602     Register Rscratch = reg_to_register_object($scratch$$reg);
 2603 
 2604     assert(Rdividend != Rscratch, &quot;&quot;);
 2605 
 2606     __ sra(Rdividend, 0, Rdividend);
 2607     __ sdivx(Rdividend, divisor, Rscratch);
 2608     __ mulx(Rscratch, divisor, Rscratch);
 2609     __ sub(Rdividend, Rscratch, Rresult);
 2610 %}
 2611 
 2612 enc_class fabss (sflt_reg dst, sflt_reg src) %{
<span class="line-modified"> 2613     MacroAssembler _masm(&amp;cbuf);</span>
 2614 
 2615     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2616     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2617 
 2618     __ fabs(FloatRegisterImpl::S, Fsrc, Fdst);
 2619 %}
 2620 
 2621 enc_class fabsd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2622     MacroAssembler _masm(&amp;cbuf);</span>
 2623 
 2624     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2625     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2626 
 2627     __ fabs(FloatRegisterImpl::D, Fsrc, Fdst);
 2628 %}
 2629 
 2630 enc_class fnegd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2631     MacroAssembler _masm(&amp;cbuf);</span>
 2632 
 2633     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2634     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2635 
 2636     __ fneg(FloatRegisterImpl::D, Fsrc, Fdst);
 2637 %}
 2638 
 2639 enc_class fsqrts (sflt_reg dst, sflt_reg src) %{
<span class="line-modified"> 2640     MacroAssembler _masm(&amp;cbuf);</span>
 2641 
 2642     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2643     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2644 
 2645     __ fsqrt(FloatRegisterImpl::S, Fsrc, Fdst);
 2646 %}
 2647 
 2648 enc_class fsqrtd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2649     MacroAssembler _masm(&amp;cbuf);</span>
 2650 
 2651     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2652     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2653 
 2654     __ fsqrt(FloatRegisterImpl::D, Fsrc, Fdst);
 2655 %}
 2656 
 2657 
 2658 enc_class fmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified"> 2659     MacroAssembler _masm(&amp;cbuf);</span>
 2660 
 2661     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2662     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2663     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2664     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2665 
 2666     __ fmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2667 %}
 2668 
 2669 enc_class fmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified"> 2670     MacroAssembler _masm(&amp;cbuf);</span>
 2671 
 2672     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2673     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2674     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2675     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2676 
 2677     __ fmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2678 %}
 2679 
 2680 enc_class fmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified"> 2681     MacroAssembler _masm(&amp;cbuf);</span>
 2682 
 2683     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2684     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2685     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2686     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2687 
 2688     __ fmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2689 %}
 2690 
 2691 enc_class fmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified"> 2692     MacroAssembler _masm(&amp;cbuf);</span>
 2693 
 2694     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2695     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2696     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2697     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2698 
 2699     __ fmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2700 %}
 2701 
 2702 enc_class fnmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified"> 2703     MacroAssembler _masm(&amp;cbuf);</span>
 2704 
 2705     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2706     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2707     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2708     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2709 
 2710     __ fnmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2711 %}
 2712 
 2713 enc_class fnmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified"> 2714     MacroAssembler _masm(&amp;cbuf);</span>
 2715 
 2716     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2717     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2718     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2719     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2720 
 2721     __ fnmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2722 %}
 2723 
 2724 enc_class fnmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified"> 2725     MacroAssembler _masm(&amp;cbuf);</span>
 2726 
 2727     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2728     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2729     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2730     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2731 
 2732     __ fnmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2733 %}
 2734 
 2735 enc_class fnmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified"> 2736     MacroAssembler _masm(&amp;cbuf);</span>
 2737 
 2738     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2739     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2740     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2741     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2742 
 2743     __ fnmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2744 %}
 2745 
 2746 
 2747 enc_class fmovs (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2748     MacroAssembler _masm(&amp;cbuf);</span>
 2749 
 2750     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2751     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2752 
 2753     __ fmov(FloatRegisterImpl::S, Fsrc, Fdst);
 2754 %}
 2755 
 2756 enc_class fmovd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2757     MacroAssembler _masm(&amp;cbuf);</span>
 2758 
 2759     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2760     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2761 
 2762     __ fmov(FloatRegisterImpl::D, Fsrc, Fdst);
 2763 %}
 2764 
 2765 enc_class Fast_Lock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
<span class="line-modified"> 2766     MacroAssembler _masm(&amp;cbuf);</span>
 2767 
 2768     Register Roop  = reg_to_register_object($oop$$reg);
 2769     Register Rbox  = reg_to_register_object($box$$reg);
 2770     Register Rscratch = reg_to_register_object($scratch$$reg);
 2771     Register Rmark =    reg_to_register_object($scratch2$$reg);
 2772 
 2773     assert(Roop  != Rscratch, &quot;&quot;);
 2774     assert(Roop  != Rmark, &quot;&quot;);
 2775     assert(Rbox  != Rscratch, &quot;&quot;);
 2776     assert(Rbox  != Rmark, &quot;&quot;);
 2777 
 2778     __ compiler_lock_object(Roop, Rmark, Rbox, Rscratch, _counters, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
 2779 %}
 2780 
 2781 enc_class Fast_Unlock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
<span class="line-modified"> 2782     MacroAssembler _masm(&amp;cbuf);</span>
 2783 
 2784     Register Roop  = reg_to_register_object($oop$$reg);
 2785     Register Rbox  = reg_to_register_object($box$$reg);
 2786     Register Rscratch = reg_to_register_object($scratch$$reg);
 2787     Register Rmark =    reg_to_register_object($scratch2$$reg);
 2788 
 2789     assert(Roop  != Rscratch, &quot;&quot;);
 2790     assert(Roop  != Rmark, &quot;&quot;);
 2791     assert(Rbox  != Rscratch, &quot;&quot;);
 2792     assert(Rbox  != Rmark, &quot;&quot;);
 2793 
 2794     __ compiler_unlock_object(Roop, Rmark, Rbox, Rscratch, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
 2795   %}
 2796 
 2797   enc_class enc_cas( iRegP mem, iRegP old, iRegP new ) %{
<span class="line-modified"> 2798     MacroAssembler _masm(&amp;cbuf);</span>
 2799     Register Rmem = reg_to_register_object($mem$$reg);
 2800     Register Rold = reg_to_register_object($old$$reg);
 2801     Register Rnew = reg_to_register_object($new$$reg);
 2802 
 2803     __ cas_ptr(Rmem, Rold, Rnew); // Swap(*Rmem,Rnew) if *Rmem == Rold
 2804     __ cmp( Rold, Rnew );
 2805   %}
 2806 
 2807   enc_class enc_casx( iRegP mem, iRegL old, iRegL new) %{
 2808     Register Rmem = reg_to_register_object($mem$$reg);
 2809     Register Rold = reg_to_register_object($old$$reg);
 2810     Register Rnew = reg_to_register_object($new$$reg);
 2811 
<span class="line-modified"> 2812     MacroAssembler _masm(&amp;cbuf);</span>
 2813     __ mov(Rnew, O7);
 2814     __ casx(Rmem, Rold, O7);
 2815     __ cmp( Rold, O7 );
 2816   %}
 2817 
 2818   // raw int cas, used for compareAndSwap
 2819   enc_class enc_casi( iRegP mem, iRegL old, iRegL new) %{
 2820     Register Rmem = reg_to_register_object($mem$$reg);
 2821     Register Rold = reg_to_register_object($old$$reg);
 2822     Register Rnew = reg_to_register_object($new$$reg);
 2823 
<span class="line-modified"> 2824     MacroAssembler _masm(&amp;cbuf);</span>
 2825     __ mov(Rnew, O7);
 2826     __ cas(Rmem, Rold, O7);
 2827     __ cmp( Rold, O7 );
 2828   %}
 2829 
 2830   // raw int cas without using tmp register for compareAndExchange
 2831   enc_class enc_casi_exch( iRegP mem, iRegL old, iRegL new) %{
 2832     Register Rmem = reg_to_register_object($mem$$reg);
 2833     Register Rold = reg_to_register_object($old$$reg);
 2834     Register Rnew = reg_to_register_object($new$$reg);
 2835 
<span class="line-modified"> 2836     MacroAssembler _masm(&amp;cbuf);</span>
 2837     __ cas(Rmem, Rold, Rnew);
 2838   %}
 2839 
 2840   // 64-bit cas without using tmp register for compareAndExchange
 2841   enc_class enc_casx_exch( iRegP mem, iRegL old, iRegL new) %{
 2842     Register Rmem = reg_to_register_object($mem$$reg);
 2843     Register Rold = reg_to_register_object($old$$reg);
 2844     Register Rnew = reg_to_register_object($new$$reg);
 2845 
<span class="line-modified"> 2846     MacroAssembler _masm(&amp;cbuf);</span>
 2847     __ casx(Rmem, Rold, Rnew);
 2848   %}
 2849 
 2850   enc_class enc_lflags_ne_to_boolean( iRegI res ) %{
 2851     Register Rres = reg_to_register_object($res$$reg);
 2852 
<span class="line-modified"> 2853     MacroAssembler _masm(&amp;cbuf);</span>
 2854     __ mov(1, Rres);
 2855     __ movcc( Assembler::notEqual, false, Assembler::xcc, G0, Rres );
 2856   %}
 2857 
 2858   enc_class enc_iflags_ne_to_boolean( iRegI res ) %{
 2859     Register Rres = reg_to_register_object($res$$reg);
 2860 
<span class="line-modified"> 2861     MacroAssembler _masm(&amp;cbuf);</span>
 2862     __ mov(1, Rres);
 2863     __ movcc( Assembler::notEqual, false, Assembler::icc, G0, Rres );
 2864   %}
 2865 
 2866   enc_class floating_cmp ( iRegP dst, regF src1, regF src2 ) %{
<span class="line-modified"> 2867     MacroAssembler _masm(&amp;cbuf);</span>
 2868     Register Rdst = reg_to_register_object($dst$$reg);
 2869     FloatRegister Fsrc1 = $primary ? reg_to_SingleFloatRegister_object($src1$$reg)
 2870                                      : reg_to_DoubleFloatRegister_object($src1$$reg);
 2871     FloatRegister Fsrc2 = $primary ? reg_to_SingleFloatRegister_object($src2$$reg)
 2872                                      : reg_to_DoubleFloatRegister_object($src2$$reg);
 2873 
 2874     // Convert condition code fcc0 into -1,0,1; unordered reports less-than (-1)
 2875     __ float_cmp( $primary, -1, Fsrc1, Fsrc2, Rdst);
 2876   %}
 2877 
 2878   enc_class enc_rethrow() %{
 2879     cbuf.set_insts_mark();
 2880     Register temp_reg = G3;
 2881     AddressLiteral rethrow_stub(OptoRuntime::rethrow_stub());
 2882     assert(temp_reg != reg_to_register_object(R_I0_num), &quot;temp must not break oop_reg&quot;);
<span class="line-modified"> 2883     MacroAssembler _masm(&amp;cbuf);</span>
 2884 #ifdef ASSERT
 2885     __ save_frame(0);
 2886     AddressLiteral last_rethrow_addrlit(&amp;last_rethrow);
 2887     __ sethi(last_rethrow_addrlit, L1);
 2888     Address addr(L1, last_rethrow_addrlit.low10());
 2889     __ rdpc(L2);
 2890     __ inc(L2, 3 * BytesPerInstWord);  // skip this &amp; 2 more insns to point at jump_to
 2891     __ st_ptr(L2, addr);
 2892     __ restore();
 2893 #endif
 2894     __ JUMP(rethrow_stub, temp_reg, 0); // sethi;jmp
 2895     __ delayed()-&gt;nop();
 2896   %}
 2897 
 2898   enc_class emit_mem_nop() %{
 2899     // Generates the instruction LDUXA [o6,g0],#0x82,g0
 2900     cbuf.insts()-&gt;emit_int32((unsigned int) 0xc0839040);
 2901   %}
 2902 
 2903   enc_class emit_fadd_nop() %{
 2904     // Generates the instruction FMOVS f31,f31
 2905     cbuf.insts()-&gt;emit_int32((unsigned int) 0xbfa0003f);
 2906   %}
 2907 
 2908   enc_class emit_br_nop() %{
 2909     // Generates the instruction BPN,PN .
 2910     cbuf.insts()-&gt;emit_int32((unsigned int) 0x00400000);
 2911   %}
 2912 
 2913   enc_class enc_membar_acquire %{
<span class="line-modified"> 2914     MacroAssembler _masm(&amp;cbuf);</span>
 2915     __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::LoadLoad) );
 2916   %}
 2917 
 2918   enc_class enc_membar_release %{
<span class="line-modified"> 2919     MacroAssembler _masm(&amp;cbuf);</span>
 2920     __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::StoreStore) );
 2921   %}
 2922 
 2923   enc_class enc_membar_volatile %{
<span class="line-modified"> 2924     MacroAssembler _masm(&amp;cbuf);</span>
 2925     __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad) );
 2926   %}
 2927 
 2928 %}
 2929 
 2930 //----------FRAME--------------------------------------------------------------
 2931 // Definition of frame structure and management information.
 2932 //
 2933 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2934 //                             |   (to get allocators register number
 2935 //  G  Owned by    |        |  v    add VMRegImpl::stack0)
 2936 //  r   CALLER     |        |
 2937 //  o     |        +--------+      pad to even-align allocators stack-slot
 2938 //  w     V        |  pad0  |        numbers; owned by CALLER
 2939 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2940 //  h     ^        |   in   |  5
 2941 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2942 //  |     |        |        |  3
 2943 //  |     |        +--------+
 2944 //  V     |        | old out|      Empty on Intel, window on Sparc
</pre>
<hr />
<pre>
 8837 //----------Branches---------------------------------------------------------
 8838 // Jump
 8839 // (compare &#39;operand indIndex&#39; and &#39;instruct addP_reg_reg&#39; above)
 8840 instruct jumpXtnd(iRegX switch_val, o7RegI table) %{
 8841   match(Jump switch_val);
 8842   effect(TEMP table);
 8843 
 8844   ins_cost(350);
 8845 
 8846   format %{  &quot;ADD    $constanttablebase, $constantoffset, O7\n\t&quot;
 8847              &quot;LD     [O7 + $switch_val], O7\n\t&quot;
 8848              &quot;JUMP   O7&quot; %}
 8849   ins_encode %{
 8850     // Calculate table address into a register.
 8851     Register table_reg;
 8852     Register label_reg = O7;
 8853     // If we are calculating the size of this instruction don&#39;t trust
 8854     // zero offsets because they might change when
 8855     // MachConstantBaseNode decides to optimize the constant table
 8856     // base.
<span class="line-modified"> 8857     if ((constant_offset() == 0) &amp;&amp; !Compile::current()-&gt;in_scratch_emit_size()) {</span>
 8858       table_reg = $constanttablebase;
 8859     } else {
 8860       table_reg = O7;
 8861       RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset, O7);
 8862       __ add($constanttablebase, con_offset, table_reg);
 8863     }
 8864 
 8865     // Jump to base address + switch value
 8866     __ ld_ptr(table_reg, $switch_val$$Register, label_reg);
 8867     __ jmp(label_reg, G0);
 8868     __ delayed()-&gt;nop();
 8869   %}
 8870   ins_pipe(ialu_reg_reg);
 8871 %}
 8872 
 8873 // Direct Branch.  Use V8 version with longer range.
 8874 instruct branch(label labl) %{
 8875   match(Goto);
 8876   effect(USE labl);
 8877 
</pre>
</td>
<td>
<hr />
<pre>
  575     }
  576   }
  577 }
  578 
  579 int MachCallRuntimeNode::ret_addr_offset() {
  580   if (MacroAssembler::is_far_target(entry_point())) {
  581     return NativeFarCall::instruction_size;
  582   } else {
  583     return NativeCall::instruction_size;
  584   }
  585 }
  586 
  587 // Indicate if the safepoint node needs the polling page as an input.
  588 // Since Sparc does not have absolute addressing, it does.
  589 bool SafePointNode::needs_polling_address_input() {
  590   return true;
  591 }
  592 
  593 // emit an interrupt that is caught by the debugger (for debugging compiler)
  594 void emit_break(CodeBuffer &amp;cbuf) {
<span class="line-modified">  595   C2_MacroAssembler _masm(&amp;cbuf);</span>
  596   __ breakpoint_trap();
  597 }
  598 
  599 #ifndef PRODUCT
  600 void MachBreakpointNode::format( PhaseRegAlloc *, outputStream *st ) const {
  601   st-&gt;print(&quot;TA&quot;);
  602 }
  603 #endif
  604 
  605 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  606   emit_break(cbuf);
  607 }
  608 
  609 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  610   return MachNode::size(ra_);
  611 }
  612 
  613 // Traceable jump
  614 void  emit_jmpl(CodeBuffer &amp;cbuf, int jump_target) {
<span class="line-modified">  615   C2_MacroAssembler _masm(&amp;cbuf);</span>
  616   Register rdest = reg_to_register_object(jump_target);
  617   __ JMP(rdest, 0);
  618   __ delayed()-&gt;nop();
  619 }
  620 
  621 // Traceable jump and set exception pc
  622 void  emit_jmpl_set_exception_pc(CodeBuffer &amp;cbuf, int jump_target) {
<span class="line-modified">  623   C2_MacroAssembler _masm(&amp;cbuf);</span>
  624   Register rdest = reg_to_register_object(jump_target);
  625   __ JMP(rdest, 0);
  626   __ delayed()-&gt;add(O7, frame::pc_return_offset, Oissuing_pc );
  627 }
  628 
  629 void emit_nop(CodeBuffer &amp;cbuf) {
<span class="line-modified">  630   C2_MacroAssembler _masm(&amp;cbuf);</span>
  631   __ nop();
  632 }
  633 
  634 void emit_illtrap(CodeBuffer &amp;cbuf) {
<span class="line-modified">  635   C2_MacroAssembler _masm(&amp;cbuf);</span>
  636   __ illtrap(0);
  637 }
  638 
  639 
  640 intptr_t get_offset_from_base(const MachNode* n, const TypePtr* atype, int disp32) {
  641   assert(n-&gt;rule() != loadUB_rule, &quot;&quot;);
  642 
  643   intptr_t offset = 0;
  644   const TypePtr *adr_type = TYPE_PTR_SENTINAL;  // Check for base==RegI, disp==immP
  645   const Node* addr = n-&gt;get_base_and_disp(offset, adr_type);
  646   assert(adr_type == (const TypePtr*)-1, &quot;VerifyOops: no support for sparc operands with base==RegI, disp==immP&quot;);
  647   assert(addr != NULL &amp;&amp; addr != (Node*)-1, &quot;invalid addr&quot;);
  648   assert(addr-&gt;bottom_type()-&gt;isa_oopptr() == atype, &quot;&quot;);
  649   atype = atype-&gt;add_offset(offset);
  650   assert(disp32 == offset, &quot;wrong disp32&quot;);
  651   return atype-&gt;_offset;
  652 }
  653 
  654 
  655 intptr_t get_offset_from_base_2(const MachNode* n, const TypePtr* atype, int disp32) {
</pre>
<hr />
<pre>
  891             ShouldNotReachHere();
  892           }
  893         }
  894       }
  895     }
  896   }
  897 #endif
  898 
  899   uint instr = (Assembler::ldst_op &lt;&lt; 30)
  900              | (dst_enc        &lt;&lt; 25)
  901              | (primary        &lt;&lt; 19)
  902              | (src1_enc       &lt;&lt; 14);
  903 
  904   uint index = src2_enc;
  905   int disp = disp32;
  906 
  907   if (src1_enc == R_SP_enc || src1_enc == R_FP_enc) {
  908     disp += STACK_BIAS;
  909     // Check that stack offset fits, load into O7 if not
  910     if (!Assembler::is_simm13(disp)) {
<span class="line-modified">  911       C2_MacroAssembler _masm(&amp;cbuf);</span>
  912       __ set(disp, O7);
  913       if (index != R_G0_enc) {
  914         __ add(O7, reg_to_register_object(index), O7);
  915       }
  916       index = R_O7_enc;
  917       disp = 0;
  918     }
  919   }
  920 
  921   if( disp == 0 ) {
  922     // use reg-reg form
  923     // bit 13 is already zero
  924     instr |= index;
  925   } else {
  926     // use reg-imm form
  927     instr |= 0x00002000;          // set bit 13 to one
  928     instr |= disp &amp; 0x1FFF;
  929   }
  930 
  931   cbuf.insts()-&gt;emit_int32(instr);
  932 
  933 #ifdef ASSERT
  934   if (VerifyOops) {
<span class="line-modified">  935     C2_MacroAssembler _masm(&amp;cbuf);</span>
  936     if (is_verified_oop_base) {
  937       __ verify_oop(reg_to_register_object(src1_enc));
  938     }
  939     if (is_verified_oop_store) {
  940       __ verify_oop(reg_to_register_object(dst_enc));
  941     }
  942     if (tmp_enc != -1) {
  943       __ mov(O7, reg_to_register_object(tmp_enc));
  944     }
  945     if (is_verified_oop_load) {
  946       __ verify_oop(reg_to_register_object(dst_enc));
  947     }
  948   }
  949 #endif
  950 }
  951 
  952 void emit_call_reloc(CodeBuffer &amp;cbuf, intptr_t entry_point, RelocationHolder const&amp; rspec, bool preserve_g2 = false) {
  953   // The method which records debug information at every safepoint
  954   // expects the call to be the first instruction in the snippet as
  955   // it creates a PcDesc structure which tracks the offset of a call
  956   // from the start of the codeBlob. This offset is computed as
  957   // code_end() - code_begin() of the code which has been emitted
  958   // so far.
  959   // In this particular case we have skirted around the problem by
  960   // putting the &quot;mov&quot; instruction in the delay slot but the problem
  961   // may bite us again at some other point and a cleaner/generic
  962   // solution using relocations would be needed.
<span class="line-modified">  963   C2_MacroAssembler _masm(&amp;cbuf);</span>
  964   __ set_inst_mark();
  965 
  966   // We flush the current window just so that there is a valid stack copy
  967   // the fact that the current window becomes active again instantly is
  968   // not a problem there is nothing live in it.
  969 
  970 #ifdef ASSERT
  971   int startpos = __ offset();
  972 #endif /* ASSERT */
  973 
  974   __ call((address)entry_point, rspec);
  975 
  976   if (preserve_g2)   __ delayed()-&gt;mov(G2, L7);
  977   else __ delayed()-&gt;nop();
  978 
  979   if (preserve_g2)   __ mov(L7, G2);
  980 
  981 #ifdef ASSERT
  982   if (preserve_g2 &amp;&amp; (VerifyCompiledCode || VerifyOops)) {
  983     // Trash argument dump slots.
</pre>
<hr />
<pre>
  985     __ mov(G1, G5);
  986     __ stx(G1, SP, STACK_BIAS + 0x80);
  987     __ stx(G1, SP, STACK_BIAS + 0x88);
  988     __ stx(G1, SP, STACK_BIAS + 0x90);
  989     __ stx(G1, SP, STACK_BIAS + 0x98);
  990     __ stx(G1, SP, STACK_BIAS + 0xA0);
  991     __ stx(G1, SP, STACK_BIAS + 0xA8);
  992   }
  993 #endif /*ASSERT*/
  994 }
  995 
  996 //=============================================================================
  997 // REQUIRED FUNCTIONALITY for encoding
  998 void emit_lo(CodeBuffer &amp;cbuf, int val) {  }
  999 void emit_hi(CodeBuffer &amp;cbuf, int val) {  }
 1000 
 1001 
 1002 //=============================================================================
 1003 const RegMask&amp; MachConstantBaseNode::_out_RegMask = PTR_REG_mask();
 1004 
<span class="line-modified"> 1005 int ConstantTable::calculate_table_base_offset() const {</span>
 1006   if (UseRDPCForConstantTableBase) {
 1007     // The table base offset might be less but then it fits into
 1008     // simm13 anyway and we are good (cf. MachConstantBaseNode::emit).
 1009     return Assembler::min_simm13();
 1010   } else {
 1011     int offset = -(size() / 2);
 1012     if (!Assembler::is_simm13(offset)) {
 1013       offset = Assembler::min_simm13();
 1014     }
 1015     return offset;
 1016   }
 1017 }
 1018 
 1019 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
 1020 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 1021   ShouldNotReachHere();
 1022 }
 1023 
 1024 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1025   Compile* C = ra_-&gt;C;
<span class="line-modified"> 1026   ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
<span class="line-modified"> 1027   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1028 
 1029   Register r = as_Register(ra_-&gt;get_encode(this));
 1030   CodeSection* consts_section = __ code()-&gt;consts();
 1031   int consts_size = consts_section-&gt;align_at_start(consts_section-&gt;size());
 1032   assert(constant_table.size() == consts_size, &quot;must be: %d == %d&quot;, constant_table.size(), consts_size);
 1033 
 1034   if (UseRDPCForConstantTableBase) {
 1035     // For the following RDPC logic to work correctly the consts
 1036     // section must be allocated right before the insts section.  This
 1037     // assert checks for that.  The layout and the SECT_* constants
 1038     // are defined in src/share/vm/asm/codeBuffer.hpp.
 1039     assert(CodeBuffer::SECT_CONSTS + 1 == CodeBuffer::SECT_INSTS, &quot;must be&quot;);
 1040     int insts_offset = __ offset();
 1041 
 1042     // Layout:
 1043     //
 1044     // |----------- consts section ------------|----------- insts section -----------...
 1045     // |------ constant table -----|- padding -|------------------x----
 1046     //                                                            \ current PC (RDPC instruction)
 1047     // |&lt;------------- consts_size -----------&gt;|&lt;- insts_offset -&gt;|
</pre>
<hr />
<pre>
 1111     st-&gt;print(&quot;SET    &amp;constanttable,%s\t! constant table base&quot;, reg);
 1112   }
 1113 }
 1114 #endif
 1115 
 1116 
 1117 //=============================================================================
 1118 
 1119 #ifndef PRODUCT
 1120 void MachPrologNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1121   Compile* C = ra_-&gt;C;
 1122 
 1123   for (int i = 0; i &lt; OptoPrologueNops; i++) {
 1124     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
 1125   }
 1126 
 1127   if( VerifyThread ) {
 1128     st-&gt;print_cr(&quot;Verify_Thread&quot;); st-&gt;print(&quot;\t&quot;);
 1129   }
 1130 
<span class="line-modified"> 1131   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified"> 1132   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
 1133 
 1134   // Calls to C2R adapters often do not accept exceptional returns.
 1135   // We require that their callers must bang for them.  But be careful, because
 1136   // some VM calls (such as call site linkage) can use several kilobytes of
 1137   // stack.  But the stack safety zone should account for that.
 1138   // See bugs 4446381, 4468289, 4497237.
<span class="line-modified"> 1139   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {</span>
 1140     st-&gt;print_cr(&quot;! stack bang (%d bytes)&quot;, bangsize); st-&gt;print(&quot;\t&quot;);
 1141   }
 1142 
 1143   if (Assembler::is_simm13(-framesize)) {
 1144     st-&gt;print   (&quot;SAVE   R_SP,-&quot; SIZE_FORMAT &quot;,R_SP&quot;,framesize);
 1145   } else {
 1146     st-&gt;print_cr(&quot;SETHI  R_SP,hi%%(-&quot; SIZE_FORMAT &quot;),R_G3&quot;,framesize); st-&gt;print(&quot;\t&quot;);
 1147     st-&gt;print_cr(&quot;ADD    R_G3,lo%%(-&quot; SIZE_FORMAT &quot;),R_G3&quot;,framesize); st-&gt;print(&quot;\t&quot;);
 1148     st-&gt;print   (&quot;SAVE   R_SP,R_G3,R_SP&quot;);
 1149   }
 1150 
 1151 }
 1152 #endif
 1153 
 1154 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1155   Compile* C = ra_-&gt;C;
<span class="line-modified"> 1156   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1157 
 1158   for (int i = 0; i &lt; OptoPrologueNops; i++) {
 1159     __ nop();
 1160   }
 1161 
 1162   __ verify_thread();
 1163 
<span class="line-modified"> 1164   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
 1165   assert(framesize &gt;= 16*wordSize, &quot;must have room for reg. save area&quot;);
 1166   assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
<span class="line-modified"> 1167   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
 1168 
 1169   // Calls to C2R adapters often do not accept exceptional returns.
 1170   // We require that their callers must bang for them.  But be careful, because
 1171   // some VM calls (such as call site linkage) can use several kilobytes of
 1172   // stack.  But the stack safety zone should account for that.
 1173   // See bugs 4446381, 4468289, 4497237.
<span class="line-modified"> 1174   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {</span>
 1175     __ generate_stack_overflow_check(bangsize);
 1176   }
 1177 
 1178   if (Assembler::is_simm13(-framesize)) {
 1179     __ save(SP, -framesize, SP);
 1180   } else {
 1181     __ sethi(-framesize &amp; ~0x3ff, G3);
 1182     __ add(G3, -framesize &amp; 0x3ff, G3);
 1183     __ save(SP, G3, SP);
 1184   }
<span class="line-modified"> 1185   C-&gt;output()-&gt;set_frame_complete( __ offset() );</span>
 1186 
 1187   if (!UseRDPCForConstantTableBase &amp;&amp; C-&gt;has_mach_constant_base_node()) {
 1188     // NOTE: We set the table base offset here because users might be
 1189     // emitted before MachConstantBaseNode.
<span class="line-modified"> 1190     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
 1191     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 1192   }
 1193 }
 1194 
 1195 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
 1196   return MachNode::size(ra_);
 1197 }
 1198 
 1199 int MachPrologNode::reloc() const {
 1200   return 10; // a large enough number
 1201 }
 1202 
 1203 //=============================================================================
 1204 #ifndef PRODUCT
 1205 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1206   Compile* C = ra_-&gt;C;
 1207 
 1208   if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
 1209     if (SafepointMechanism::uses_global_page_poll()) {
 1210       st-&gt;print(&quot;SETHI  #PollAddr,L0\t! Load Polling address\n\t&quot;);
 1211     } else {
 1212       st-&gt;print(&quot;LDX    [R_G2 + #poll_offset],L0\t! Load local polling address\n\t&quot;);
 1213     }
 1214     st-&gt;print(&quot;LDX    [L0],G0\t!Poll for Safepointing\n\t&quot;);
 1215   }
 1216 
 1217   if(do_polling()) {
 1218     if (UseCBCond &amp;&amp; !ra_-&gt;C-&gt;is_method_compilation()) {
 1219       st-&gt;print(&quot;NOP\n\t&quot;);
 1220     }
 1221     st-&gt;print(&quot;RET\n\t&quot;);
 1222   }
 1223 
 1224   st-&gt;print(&quot;RESTORE&quot;);
 1225 }
 1226 #endif
 1227 
 1228 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1229   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1230   Compile* C = ra_-&gt;C;
 1231 
 1232   __ verify_thread();
 1233 
 1234   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
 1235     __ reserved_stack_check();
 1236   }
 1237 
 1238   // If this does safepoint polling, then do it here
 1239   if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
 1240     if (SafepointMechanism::uses_thread_local_poll()) {
 1241       __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), L0);
 1242     } else {
 1243       AddressLiteral polling_page(os::get_polling_page());
 1244       __ sethi(polling_page, L0);
 1245     }
 1246     __ relocate(relocInfo::poll_return_type);
 1247     __ ld_ptr(L0, 0, G0);
 1248   }
 1249 
</pre>
<hr />
<pre>
 1517   implementation( NULL, ra_, false, st );
 1518 }
 1519 #endif
 1520 
 1521 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1522   implementation( &amp;cbuf, ra_, false, NULL );
 1523 }
 1524 
 1525 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1526   return MachNode::size(ra_);
 1527 }
 1528 
 1529 //=============================================================================
 1530 #ifndef PRODUCT
 1531 void MachNopNode::format(PhaseRegAlloc *, outputStream *st) const {
 1532   st-&gt;print(&quot;NOP \t# %d bytes pad for loops and calls&quot;, 4 * _count);
 1533 }
 1534 #endif
 1535 
 1536 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *) const {
<span class="line-modified"> 1537   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1538   for (int i = 0; i &lt; _count; i += 1) {
 1539     __ nop();
 1540   }
 1541 }
 1542 
 1543 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 1544   return 4 * _count;
 1545 }
 1546 
 1547 
 1548 //=============================================================================
 1549 #ifndef PRODUCT
 1550 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1551   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1552   int reg = ra_-&gt;get_reg_first(this);
 1553   st-&gt;print(&quot;LEA    [R_SP+#%d+BIAS],%s&quot;,offset,Matcher::regName[reg]);
 1554 }
 1555 #endif
 1556 
 1557 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1558   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1559   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem()) + STACK_BIAS;
 1560   int reg = ra_-&gt;get_encode(this);
 1561 
 1562   if (Assembler::is_simm13(offset)) {
 1563      __ add(SP, offset, reg_to_register_object(reg));
 1564   } else {
 1565      __ set(offset, O7);
 1566      __ add(SP, O7, reg_to_register_object(reg));
 1567   }
 1568 }
 1569 
 1570 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1571   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
 1572   assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
<span class="line-modified"> 1573   return ra_-&gt;C-&gt;output()-&gt;scratch_emit_size(this);</span>
 1574 }
 1575 
 1576 //=============================================================================
 1577 #ifndef PRODUCT
 1578 void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1579   st-&gt;print_cr(&quot;\nUEP:&quot;);
 1580   if (UseCompressedClassPointers) {
 1581     assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 1582     st-&gt;print_cr(&quot;\tLDUW   [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check - compressed klass&quot;);
 1583     if (CompressedKlassPointers::base() != 0) {
 1584       st-&gt;print_cr(&quot;\tSET    CompressedKlassPointers::base,R_G6_heap_base&quot;);
 1585       if (CompressedKlassPointers::shift() != 0) {
 1586         st-&gt;print_cr(&quot;\tSLL    R_G5,CompressedKlassPointers::shift,R_G5&quot;);
 1587       }
 1588       st-&gt;print_cr(&quot;\tADD    R_G5,R_G6_heap_base,R_G5&quot;);
 1589       st-&gt;print_cr(&quot;\tSET    CompressedOops::ptrs_base,R_G6_heap_base&quot;);
 1590     } else {
 1591       st-&gt;print_cr(&quot;\tSLL    R_G5,CompressedKlassPointers::shift,R_G5&quot;);
 1592     }
 1593   } else {
 1594     st-&gt;print_cr(&quot;\tLDX    [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check&quot;);
 1595   }
 1596   st-&gt;print_cr(&quot;\tCMP    R_G5,R_G3&quot; );
 1597   st-&gt;print   (&quot;\tTne    xcc,R_G0+ST_RESERVED_FOR_USER_0+2&quot;);
 1598 }
 1599 #endif
 1600 
 1601 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1602   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1603   Register G5_ic_reg  = reg_to_register_object(Matcher::inline_cache_reg_encode());
 1604   Register temp_reg   = G3;
 1605   assert( G5_ic_reg != temp_reg, &quot;conflicting registers&quot; );
 1606 
 1607   // Load klass from receiver
 1608   __ load_klass(O0, temp_reg);
 1609   // Compare against expected klass
 1610   __ cmp(temp_reg, G5_ic_reg);
 1611   // Branch to miss code, checks xcc or icc depending
 1612   __ trap(Assembler::notEqual, Assembler::ptr_cc, G0, ST_RESERVED_FOR_USER_0+2);
 1613 }
 1614 
 1615 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1616   return MachNode::size(ra_);
 1617 }
 1618 
 1619 
 1620 //=============================================================================
 1621 
 1622 
 1623 // Emit exception handler code.
 1624 int HandlerImpl::emit_exception_handler(CodeBuffer&amp; cbuf) {
 1625   Register temp_reg = G3;
 1626   AddressLiteral exception_blob(OptoRuntime::exception_blob()-&gt;entry_point());
<span class="line-modified"> 1627   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1628 
 1629   address base = __ start_a_stub(size_exception_handler());
 1630   if (base == NULL) {
 1631     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1632     return 0;  // CodeBuffer::expand failed
 1633   }
 1634 
 1635   int offset = __ offset();
 1636 
 1637   __ JUMP(exception_blob, temp_reg, 0); // sethi;jmp
 1638   __ delayed()-&gt;nop();
 1639 
 1640   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
 1641 
 1642   __ end_a_stub();
 1643 
 1644   return offset;
 1645 }
 1646 
 1647 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
 1648   // Can&#39;t use any of the current frame&#39;s registers as we may have deopted
 1649   // at a poll and everything (including G3) can be live.
 1650   Register temp_reg = L0;
 1651   AddressLiteral deopt_blob(SharedRuntime::deopt_blob()-&gt;unpack());
<span class="line-modified"> 1652   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1653 
 1654   address base = __ start_a_stub(size_deopt_handler());
 1655   if (base == NULL) {
 1656     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1657     return 0;  // CodeBuffer::expand failed
 1658   }
 1659 
 1660   int offset = __ offset();
 1661   __ save_frame(0);
 1662   __ JUMP(deopt_blob, temp_reg, 0); // sethi;jmp
 1663   __ delayed()-&gt;restore();
 1664 
 1665   assert(__ offset() - offset &lt;= (int) size_deopt_handler(), &quot;overflow&quot;);
 1666 
 1667   __ end_a_stub();
 1668   return offset;
 1669 
 1670 }
 1671 
 1672 // Given a register encoding, produce a Integer Register object
</pre>
<hr />
<pre>
 1990 // operand to generate a function which returns its register number when
 1991 // queried.   CONST_INTER causes an operand to generate a function which
 1992 // returns the value of the constant when queried.  MEMORY_INTER causes an
 1993 // operand to generate four functions which return the Base Register, the
 1994 // Index Register, the Scale Value, and the Offset Value of the operand when
 1995 // queried.  COND_INTER causes an operand to generate six functions which
 1996 // return the encoding code (ie - encoding bits for the instruction)
 1997 // associated with each basic boolean condition for a conditional instruction.
 1998 //
 1999 // Instructions specify two basic values for encoding.  Again, a function
 2000 // is available to check if the constant displacement is an oop. They use the
 2001 // ins_encode keyword to specify their encoding classes (which must be
 2002 // a sequence of enc_class names, and their parameters, specified in
 2003 // the encoding block), and they use the
 2004 // opcode keyword to specify, in order, their primary, secondary, and
 2005 // tertiary opcode.  Only the opcode sections which a particular instruction
 2006 // needs for encoding need to be specified.
 2007 encode %{
 2008   enc_class enc_untested %{
 2009 #ifdef ASSERT
<span class="line-modified"> 2010     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2011     __ untested(&quot;encoding&quot;);
 2012 #endif
 2013   %}
 2014 
 2015   enc_class form3_mem_reg( memory mem, iRegI dst ) %{
 2016     emit_form3_mem_reg(cbuf, ra_, this, $primary, $tertiary,
 2017                        $mem$$base, $mem$$disp, $mem$$index, $dst$$reg);
 2018   %}
 2019 
 2020   enc_class simple_form3_mem_reg( memory mem, iRegI dst ) %{
 2021     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2022                        $mem$$base, $mem$$disp, $mem$$index, $dst$$reg);
 2023   %}
 2024 
 2025   enc_class form3_mem_prefetch_read( memory mem ) %{
 2026     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2027                        $mem$$base, $mem$$disp, $mem$$index, 0/*prefetch function many-reads*/);
 2028   %}
 2029 
 2030   enc_class form3_mem_prefetch_write( memory mem ) %{
</pre>
<hr />
<pre>
 2125   %}
 2126 
 2127   enc_class form3_sd_rs1_imm6_rd( iRegL rs1, immU6 imm6, iRegL rd ) %{
 2128     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, ($imm6$$constant &amp; 0x3F) | 0x1000 );
 2129   %}
 2130 
 2131   enc_class form3_sd_rs1_rs2_rd( iRegL rs1, iRegI rs2, iRegL rd ) %{
 2132     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, 0x80, $rs2$$reg );
 2133   %}
 2134 
 2135   enc_class form3_rs1_simm13_rd( iRegI rs1, immI13 simm13, iRegI rd ) %{
 2136     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $simm13$$constant );
 2137   %}
 2138 
 2139   enc_class move_return_pc_to_o1() %{
 2140     emit3_simm13( cbuf, Assembler::arith_op, R_O1_enc, Assembler::add_op3, R_O7_enc, frame::pc_return_offset );
 2141   %}
 2142 
 2143   /* %%% merge with enc_to_bool */
 2144   enc_class enc_convP2B( iRegI dst, iRegP src ) %{
<span class="line-modified"> 2145     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2146 
 2147     Register   src_reg = reg_to_register_object($src$$reg);
 2148     Register   dst_reg = reg_to_register_object($dst$$reg);
 2149     __ movr(Assembler::rc_nz, src_reg, 1, dst_reg);
 2150   %}
 2151 
 2152   enc_class enc_cadd_cmpLTMask( iRegI p, iRegI q, iRegI y, iRegI tmp ) %{
 2153     // (Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)))
<span class="line-modified"> 2154     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2155 
 2156     Register   p_reg = reg_to_register_object($p$$reg);
 2157     Register   q_reg = reg_to_register_object($q$$reg);
 2158     Register   y_reg = reg_to_register_object($y$$reg);
 2159     Register tmp_reg = reg_to_register_object($tmp$$reg);
 2160 
 2161     __ subcc( p_reg, q_reg,   p_reg );
 2162     __ add  ( p_reg, y_reg, tmp_reg );
 2163     __ movcc( Assembler::less, false, Assembler::icc, tmp_reg, p_reg );
 2164   %}
 2165 
 2166   enc_class form_d2i_helper(regD src, regF dst) %{
 2167     // fcmp %fcc0,$src,$src
 2168     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmpd_opf, $src$$reg );
 2169     // branch %fcc0 not-nan, predict taken
 2170     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2171     // fdtoi $src,$dst
 2172     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fdtoi_opf, $src$$reg );
 2173     // fitos $dst,$dst (if nan)
 2174     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fitos_opf, $dst$$reg );
</pre>
<hr />
<pre>
 2267   %}
 2268 
 2269 
 2270   // Compare longs and convert into -1, 0, 1.
 2271   enc_class cmpl_flag( iRegL src1, iRegL src2, iRegI dst ) %{
 2272     // CMP $src1,$src2
 2273     emit3( cbuf, Assembler::arith_op, 0, Assembler::subcc_op3, $src1$$reg, 0, $src2$$reg );
 2274     // blt,a,pn done
 2275     emit2_19( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::less   , Assembler::bp_op2, Assembler::xcc, 0/*predict not taken*/, 5 );
 2276     // mov dst,-1 in delay slot
 2277     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0, -1 );
 2278     // bgt,a,pn done
 2279     emit2_19( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::greater, Assembler::bp_op2, Assembler::xcc, 0/*predict not taken*/, 3 );
 2280     // mov dst,1 in delay slot
 2281     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0,  1 );
 2282     // CLR    $dst
 2283     emit3( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3 , 0, 0, 0 );
 2284   %}
 2285 
 2286   enc_class enc_PartialSubtypeCheck() %{
<span class="line-modified"> 2287     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2288     __ call(StubRoutines::Sparc::partial_subtype_check(), relocInfo::runtime_call_type);
 2289     __ delayed()-&gt;nop();
 2290   %}
 2291 
 2292   enc_class enc_bp( label labl, cmpOp cmp, flagsReg cc ) %{
<span class="line-modified"> 2293     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2294     Label* L = $labl$$label;
 2295     Assembler::Predict predict_taken =
 2296       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 2297 
 2298     __ bp( (Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 2299     __ delayed()-&gt;nop();
 2300   %}
 2301 
 2302   enc_class enc_bpr( label labl, cmpOp_reg cmp, iRegI op1 ) %{
<span class="line-modified"> 2303     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2304     Label* L = $labl$$label;
 2305     Assembler::Predict predict_taken =
 2306       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 2307 
 2308     __ bpr( (Assembler::RCondition)($cmp$$cmpcode), false, predict_taken, as_Register($op1$$reg), *L);
 2309     __ delayed()-&gt;nop();
 2310   %}
 2311 
 2312   enc_class enc_cmov_reg( cmpOp cmp, iRegI dst, iRegI src, immI pcc) %{
 2313     int op = (Assembler::arith_op &lt;&lt; 30) |
 2314              ($dst$$reg &lt;&lt; 25) |
 2315              (Assembler::movcc_op3 &lt;&lt; 19) |
 2316              (1 &lt;&lt; 18) |                    // cc2 bit for &#39;icc&#39;
 2317              ($cmp$$cmpcode &lt;&lt; 14) |
 2318              (0 &lt;&lt; 13) |                    // select register move
 2319              ($pcc$$constant &lt;&lt; 11) |       // cc1, cc0 bits for &#39;icc&#39; or &#39;xcc&#39;
 2320              ($src$$reg &lt;&lt; 0);
 2321     cbuf.insts()-&gt;emit_int32(op);
 2322   %}
 2323 
</pre>
<hr />
<pre>
 2402     int op = (Assembler::arith_op &lt;&lt; 30) |
 2403              ($dst$$reg &lt;&lt; 25) |
 2404              (Assembler::movcc_op3 &lt;&lt; 19) |
 2405              (6 &lt;&lt; 16) |                    // cc2 bit for &#39;xcc&#39;
 2406              ($primary &lt;&lt; 14) |
 2407              (0 &lt;&lt; 13) |                    // select register move
 2408              (0 &lt;&lt; 11) |                    // cc1, cc0 bits for &#39;icc&#39;
 2409              ($src$$reg &lt;&lt; 0);
 2410     cbuf.insts()-&gt;emit_int32(op);
 2411   %}
 2412 
 2413   enc_class Set13( immI13 src, iRegI rd ) %{
 2414     emit3_simm13( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, $src$$constant );
 2415   %}
 2416 
 2417   enc_class SetHi22( immI src, iRegI rd ) %{
 2418     emit2_22( cbuf, Assembler::branch_op, $rd$$reg, Assembler::sethi_op2, $src$$constant );
 2419   %}
 2420 
 2421   enc_class Set32( immI src, iRegI rd ) %{
<span class="line-modified"> 2422     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2423     __ set($src$$constant, reg_to_register_object($rd$$reg));
 2424   %}
 2425 
 2426   enc_class call_epilog %{
 2427     if( VerifyStackAtCalls ) {
<span class="line-modified"> 2428       C2_MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-modified"> 2429       int framesize = ra_-&gt;C-&gt;output()-&gt;frame_size_in_bytes();</span>
 2430       Register temp_reg = G3;
 2431       __ add(SP, framesize, temp_reg);
 2432       __ cmp(temp_reg, FP);
 2433       __ breakpoint_trap(Assembler::notEqual, Assembler::ptr_cc);
 2434     }
 2435   %}
 2436 
 2437   // Long values come back from native calls in O0:O1 in the 32-bit VM, copy the value
 2438   // to G1 so the register allocator will not have to deal with the misaligned register
 2439   // pair.
 2440   enc_class adjust_long_from_native_call %{
 2441   %}
 2442 
 2443   enc_class Java_To_Runtime (method meth) %{    // CALL Java_To_Runtime
 2444     // CALL directly to the runtime
 2445     // The user of this is responsible for ensuring that R_L7 is empty (killed).
 2446     emit_call_reloc(cbuf, $meth$$method, runtime_call_Relocation::spec(), /*preserve_g2=*/true);
 2447   %}
 2448 
 2449   enc_class preserve_SP %{
<span class="line-modified"> 2450     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2451     __ mov(SP, L7_mh_SP_save);
 2452   %}
 2453 
 2454   enc_class restore_SP %{
<span class="line-modified"> 2455     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2456     __ mov(L7_mh_SP_save, SP);
 2457   %}
 2458 
 2459   enc_class Java_Static_Call (method meth) %{    // JAVA STATIC CALL
 2460     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 2461     // who we intended to call.
 2462     if (!_method) {
 2463       emit_call_reloc(cbuf, $meth$$method, runtime_call_Relocation::spec());
 2464     } else {
 2465       int method_index = resolved_method_index(cbuf);
 2466       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2467                                                   : static_call_Relocation::spec(method_index);
 2468       emit_call_reloc(cbuf, $meth$$method, rspec);
 2469 
 2470       // Emit stub for static call.
 2471       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 2472       if (stub == NULL) {
 2473         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2474         return;
 2475       }
 2476     }
 2477   %}
 2478 
 2479   enc_class Java_Dynamic_Call (method meth) %{    // JAVA DYNAMIC CALL
<span class="line-modified"> 2480     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2481     __ set_inst_mark();
 2482     int vtable_index = this-&gt;_vtable_index;
 2483     // MachCallDynamicJavaNode::ret_addr_offset uses this same test
 2484     if (vtable_index &lt; 0) {
 2485       // must be invalid_vtable_index, not nonvirtual_vtable_index
 2486       assert(vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
 2487       Register G5_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2488       assert(G5_ic_reg == G5_inline_cache_reg, &quot;G5_inline_cache_reg used in assemble_ic_buffer_code()&quot;);
 2489       assert(G5_ic_reg == G5_megamorphic_method, &quot;G5_megamorphic_method used in megamorphic call stub&quot;);
 2490       __ ic_call((address)$meth$$method, /*emit_delay=*/true, resolved_method_index(cbuf));
 2491     } else {
 2492       assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 2493       // Just go thru the vtable
 2494       // get receiver klass (receiver already checked for non-null)
 2495       // If we end up going thru a c2i adapter interpreter expects method in G5
 2496       int off = __ offset();
 2497       __ load_klass(O0, G3_scratch);
 2498       int klass_load_size;
 2499       if (UseCompressedClassPointers) {
 2500         assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
</pre>
<hr />
<pre>
 2509       } else {
 2510         // Generate 2 instructions
 2511         __ Assembler::sethi(v_off &amp; ~0x3ff, G5_method);
 2512         __ or3(G5_method, v_off &amp; 0x3ff, G5_method);
 2513         // ld_ptr, set_hi, set
 2514         assert(__ offset() - off == klass_load_size + 2*BytesPerInstWord,
 2515                &quot;Unexpected instruction size(s)&quot;);
 2516         __ ld_ptr(G3, G5_method, G5_method);
 2517       }
 2518       // NOTE: for vtable dispatches, the vtable entry will never be null.
 2519       // However it may very well end up in handle_wrong_method if the
 2520       // method is abstract for the particular class.
 2521       __ ld_ptr(G5_method, in_bytes(Method::from_compiled_offset()), G3_scratch);
 2522       // jump to target (either compiled code or c2iadapter)
 2523       __ jmpl(G3_scratch, G0, O7);
 2524       __ delayed()-&gt;nop();
 2525     }
 2526   %}
 2527 
 2528   enc_class Java_Compiled_Call (method meth) %{    // JAVA COMPILED CALL
<span class="line-modified"> 2529     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2530 
 2531     Register G5_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2532     Register temp_reg = G3;   // caller must kill G3!  We cannot reuse G5_ic_reg here because
 2533                               // we might be calling a C2I adapter which needs it.
 2534 
 2535     assert(temp_reg != G5_ic_reg, &quot;conflicting registers&quot;);
 2536     // Load nmethod
 2537     __ ld_ptr(G5_ic_reg, in_bytes(Method::from_compiled_offset()), temp_reg);
 2538 
 2539     // CALL to compiled java, indirect the contents of G3
 2540     __ set_inst_mark();
 2541     __ callr(temp_reg, G0);
 2542     __ delayed()-&gt;nop();
 2543   %}
 2544 
 2545 enc_class idiv_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst) %{
<span class="line-modified"> 2546     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2547     Register Rdividend = reg_to_register_object($src1$$reg);
 2548     Register Rdivisor = reg_to_register_object($src2$$reg);
 2549     Register Rresult = reg_to_register_object($dst$$reg);
 2550 
 2551     __ sra(Rdivisor, 0, Rdivisor);
 2552     __ sra(Rdividend, 0, Rdividend);
 2553     __ sdivx(Rdividend, Rdivisor, Rresult);
 2554 %}
 2555 
 2556 enc_class idiv_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst) %{
<span class="line-modified"> 2557     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2558 
 2559     Register Rdividend = reg_to_register_object($src1$$reg);
 2560     int divisor = $imm$$constant;
 2561     Register Rresult = reg_to_register_object($dst$$reg);
 2562 
 2563     __ sra(Rdividend, 0, Rdividend);
 2564     __ sdivx(Rdividend, divisor, Rresult);
 2565 %}
 2566 
 2567 enc_class enc_mul_hi(iRegIsafe dst, iRegIsafe src1, iRegIsafe src2) %{
<span class="line-modified"> 2568     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2569     Register Rsrc1 = reg_to_register_object($src1$$reg);
 2570     Register Rsrc2 = reg_to_register_object($src2$$reg);
 2571     Register Rdst  = reg_to_register_object($dst$$reg);
 2572 
 2573     __ sra( Rsrc1, 0, Rsrc1 );
 2574     __ sra( Rsrc2, 0, Rsrc2 );
 2575     __ mulx( Rsrc1, Rsrc2, Rdst );
 2576     __ srlx( Rdst, 32, Rdst );
 2577 %}
 2578 
 2579 enc_class irem_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst, o7RegL scratch) %{
<span class="line-modified"> 2580     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2581     Register Rdividend = reg_to_register_object($src1$$reg);
 2582     Register Rdivisor = reg_to_register_object($src2$$reg);
 2583     Register Rresult = reg_to_register_object($dst$$reg);
 2584     Register Rscratch = reg_to_register_object($scratch$$reg);
 2585 
 2586     assert(Rdividend != Rscratch, &quot;&quot;);
 2587     assert(Rdivisor  != Rscratch, &quot;&quot;);
 2588 
 2589     __ sra(Rdividend, 0, Rdividend);
 2590     __ sra(Rdivisor, 0, Rdivisor);
 2591     __ sdivx(Rdividend, Rdivisor, Rscratch);
 2592     __ mulx(Rscratch, Rdivisor, Rscratch);
 2593     __ sub(Rdividend, Rscratch, Rresult);
 2594 %}
 2595 
 2596 enc_class irem_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst, o7RegL scratch) %{
<span class="line-modified"> 2597     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2598 
 2599     Register Rdividend = reg_to_register_object($src1$$reg);
 2600     int divisor = $imm$$constant;
 2601     Register Rresult = reg_to_register_object($dst$$reg);
 2602     Register Rscratch = reg_to_register_object($scratch$$reg);
 2603 
 2604     assert(Rdividend != Rscratch, &quot;&quot;);
 2605 
 2606     __ sra(Rdividend, 0, Rdividend);
 2607     __ sdivx(Rdividend, divisor, Rscratch);
 2608     __ mulx(Rscratch, divisor, Rscratch);
 2609     __ sub(Rdividend, Rscratch, Rresult);
 2610 %}
 2611 
 2612 enc_class fabss (sflt_reg dst, sflt_reg src) %{
<span class="line-modified"> 2613     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2614 
 2615     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2616     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2617 
 2618     __ fabs(FloatRegisterImpl::S, Fsrc, Fdst);
 2619 %}
 2620 
 2621 enc_class fabsd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2622     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2623 
 2624     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2625     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2626 
 2627     __ fabs(FloatRegisterImpl::D, Fsrc, Fdst);
 2628 %}
 2629 
 2630 enc_class fnegd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2631     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2632 
 2633     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2634     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2635 
 2636     __ fneg(FloatRegisterImpl::D, Fsrc, Fdst);
 2637 %}
 2638 
 2639 enc_class fsqrts (sflt_reg dst, sflt_reg src) %{
<span class="line-modified"> 2640     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2641 
 2642     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2643     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2644 
 2645     __ fsqrt(FloatRegisterImpl::S, Fsrc, Fdst);
 2646 %}
 2647 
 2648 enc_class fsqrtd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2649     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2650 
 2651     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2652     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2653 
 2654     __ fsqrt(FloatRegisterImpl::D, Fsrc, Fdst);
 2655 %}
 2656 
 2657 
 2658 enc_class fmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified"> 2659     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2660 
 2661     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2662     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2663     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2664     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2665 
 2666     __ fmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2667 %}
 2668 
 2669 enc_class fmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified"> 2670     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2671 
 2672     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2673     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2674     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2675     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2676 
 2677     __ fmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2678 %}
 2679 
 2680 enc_class fmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified"> 2681     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2682 
 2683     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2684     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2685     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2686     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2687 
 2688     __ fmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2689 %}
 2690 
 2691 enc_class fmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified"> 2692     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2693 
 2694     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2695     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2696     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2697     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2698 
 2699     __ fmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2700 %}
 2701 
 2702 enc_class fnmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified"> 2703     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2704 
 2705     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2706     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2707     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2708     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2709 
 2710     __ fnmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2711 %}
 2712 
 2713 enc_class fnmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified"> 2714     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2715 
 2716     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2717     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2718     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2719     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2720 
 2721     __ fnmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2722 %}
 2723 
 2724 enc_class fnmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified"> 2725     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2726 
 2727     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2728     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2729     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2730     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2731 
 2732     __ fnmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2733 %}
 2734 
 2735 enc_class fnmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified"> 2736     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2737 
 2738     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2739     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2740     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2741     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2742 
 2743     __ fnmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2744 %}
 2745 
 2746 
 2747 enc_class fmovs (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2748     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2749 
 2750     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2751     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2752 
 2753     __ fmov(FloatRegisterImpl::S, Fsrc, Fdst);
 2754 %}
 2755 
 2756 enc_class fmovd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2757     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2758 
 2759     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2760     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2761 
 2762     __ fmov(FloatRegisterImpl::D, Fsrc, Fdst);
 2763 %}
 2764 
 2765 enc_class Fast_Lock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
<span class="line-modified"> 2766     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2767 
 2768     Register Roop  = reg_to_register_object($oop$$reg);
 2769     Register Rbox  = reg_to_register_object($box$$reg);
 2770     Register Rscratch = reg_to_register_object($scratch$$reg);
 2771     Register Rmark =    reg_to_register_object($scratch2$$reg);
 2772 
 2773     assert(Roop  != Rscratch, &quot;&quot;);
 2774     assert(Roop  != Rmark, &quot;&quot;);
 2775     assert(Rbox  != Rscratch, &quot;&quot;);
 2776     assert(Rbox  != Rmark, &quot;&quot;);
 2777 
 2778     __ compiler_lock_object(Roop, Rmark, Rbox, Rscratch, _counters, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
 2779 %}
 2780 
 2781 enc_class Fast_Unlock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
<span class="line-modified"> 2782     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2783 
 2784     Register Roop  = reg_to_register_object($oop$$reg);
 2785     Register Rbox  = reg_to_register_object($box$$reg);
 2786     Register Rscratch = reg_to_register_object($scratch$$reg);
 2787     Register Rmark =    reg_to_register_object($scratch2$$reg);
 2788 
 2789     assert(Roop  != Rscratch, &quot;&quot;);
 2790     assert(Roop  != Rmark, &quot;&quot;);
 2791     assert(Rbox  != Rscratch, &quot;&quot;);
 2792     assert(Rbox  != Rmark, &quot;&quot;);
 2793 
 2794     __ compiler_unlock_object(Roop, Rmark, Rbox, Rscratch, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
 2795   %}
 2796 
 2797   enc_class enc_cas( iRegP mem, iRegP old, iRegP new ) %{
<span class="line-modified"> 2798     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2799     Register Rmem = reg_to_register_object($mem$$reg);
 2800     Register Rold = reg_to_register_object($old$$reg);
 2801     Register Rnew = reg_to_register_object($new$$reg);
 2802 
 2803     __ cas_ptr(Rmem, Rold, Rnew); // Swap(*Rmem,Rnew) if *Rmem == Rold
 2804     __ cmp( Rold, Rnew );
 2805   %}
 2806 
 2807   enc_class enc_casx( iRegP mem, iRegL old, iRegL new) %{
 2808     Register Rmem = reg_to_register_object($mem$$reg);
 2809     Register Rold = reg_to_register_object($old$$reg);
 2810     Register Rnew = reg_to_register_object($new$$reg);
 2811 
<span class="line-modified"> 2812     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2813     __ mov(Rnew, O7);
 2814     __ casx(Rmem, Rold, O7);
 2815     __ cmp( Rold, O7 );
 2816   %}
 2817 
 2818   // raw int cas, used for compareAndSwap
 2819   enc_class enc_casi( iRegP mem, iRegL old, iRegL new) %{
 2820     Register Rmem = reg_to_register_object($mem$$reg);
 2821     Register Rold = reg_to_register_object($old$$reg);
 2822     Register Rnew = reg_to_register_object($new$$reg);
 2823 
<span class="line-modified"> 2824     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2825     __ mov(Rnew, O7);
 2826     __ cas(Rmem, Rold, O7);
 2827     __ cmp( Rold, O7 );
 2828   %}
 2829 
 2830   // raw int cas without using tmp register for compareAndExchange
 2831   enc_class enc_casi_exch( iRegP mem, iRegL old, iRegL new) %{
 2832     Register Rmem = reg_to_register_object($mem$$reg);
 2833     Register Rold = reg_to_register_object($old$$reg);
 2834     Register Rnew = reg_to_register_object($new$$reg);
 2835 
<span class="line-modified"> 2836     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2837     __ cas(Rmem, Rold, Rnew);
 2838   %}
 2839 
 2840   // 64-bit cas without using tmp register for compareAndExchange
 2841   enc_class enc_casx_exch( iRegP mem, iRegL old, iRegL new) %{
 2842     Register Rmem = reg_to_register_object($mem$$reg);
 2843     Register Rold = reg_to_register_object($old$$reg);
 2844     Register Rnew = reg_to_register_object($new$$reg);
 2845 
<span class="line-modified"> 2846     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2847     __ casx(Rmem, Rold, Rnew);
 2848   %}
 2849 
 2850   enc_class enc_lflags_ne_to_boolean( iRegI res ) %{
 2851     Register Rres = reg_to_register_object($res$$reg);
 2852 
<span class="line-modified"> 2853     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2854     __ mov(1, Rres);
 2855     __ movcc( Assembler::notEqual, false, Assembler::xcc, G0, Rres );
 2856   %}
 2857 
 2858   enc_class enc_iflags_ne_to_boolean( iRegI res ) %{
 2859     Register Rres = reg_to_register_object($res$$reg);
 2860 
<span class="line-modified"> 2861     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2862     __ mov(1, Rres);
 2863     __ movcc( Assembler::notEqual, false, Assembler::icc, G0, Rres );
 2864   %}
 2865 
 2866   enc_class floating_cmp ( iRegP dst, regF src1, regF src2 ) %{
<span class="line-modified"> 2867     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2868     Register Rdst = reg_to_register_object($dst$$reg);
 2869     FloatRegister Fsrc1 = $primary ? reg_to_SingleFloatRegister_object($src1$$reg)
 2870                                      : reg_to_DoubleFloatRegister_object($src1$$reg);
 2871     FloatRegister Fsrc2 = $primary ? reg_to_SingleFloatRegister_object($src2$$reg)
 2872                                      : reg_to_DoubleFloatRegister_object($src2$$reg);
 2873 
 2874     // Convert condition code fcc0 into -1,0,1; unordered reports less-than (-1)
 2875     __ float_cmp( $primary, -1, Fsrc1, Fsrc2, Rdst);
 2876   %}
 2877 
 2878   enc_class enc_rethrow() %{
 2879     cbuf.set_insts_mark();
 2880     Register temp_reg = G3;
 2881     AddressLiteral rethrow_stub(OptoRuntime::rethrow_stub());
 2882     assert(temp_reg != reg_to_register_object(R_I0_num), &quot;temp must not break oop_reg&quot;);
<span class="line-modified"> 2883     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2884 #ifdef ASSERT
 2885     __ save_frame(0);
 2886     AddressLiteral last_rethrow_addrlit(&amp;last_rethrow);
 2887     __ sethi(last_rethrow_addrlit, L1);
 2888     Address addr(L1, last_rethrow_addrlit.low10());
 2889     __ rdpc(L2);
 2890     __ inc(L2, 3 * BytesPerInstWord);  // skip this &amp; 2 more insns to point at jump_to
 2891     __ st_ptr(L2, addr);
 2892     __ restore();
 2893 #endif
 2894     __ JUMP(rethrow_stub, temp_reg, 0); // sethi;jmp
 2895     __ delayed()-&gt;nop();
 2896   %}
 2897 
 2898   enc_class emit_mem_nop() %{
 2899     // Generates the instruction LDUXA [o6,g0],#0x82,g0
 2900     cbuf.insts()-&gt;emit_int32((unsigned int) 0xc0839040);
 2901   %}
 2902 
 2903   enc_class emit_fadd_nop() %{
 2904     // Generates the instruction FMOVS f31,f31
 2905     cbuf.insts()-&gt;emit_int32((unsigned int) 0xbfa0003f);
 2906   %}
 2907 
 2908   enc_class emit_br_nop() %{
 2909     // Generates the instruction BPN,PN .
 2910     cbuf.insts()-&gt;emit_int32((unsigned int) 0x00400000);
 2911   %}
 2912 
 2913   enc_class enc_membar_acquire %{
<span class="line-modified"> 2914     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2915     __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::LoadLoad) );
 2916   %}
 2917 
 2918   enc_class enc_membar_release %{
<span class="line-modified"> 2919     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2920     __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::StoreStore) );
 2921   %}
 2922 
 2923   enc_class enc_membar_volatile %{
<span class="line-modified"> 2924     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2925     __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad) );
 2926   %}
 2927 
 2928 %}
 2929 
 2930 //----------FRAME--------------------------------------------------------------
 2931 // Definition of frame structure and management information.
 2932 //
 2933 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2934 //                             |   (to get allocators register number
 2935 //  G  Owned by    |        |  v    add VMRegImpl::stack0)
 2936 //  r   CALLER     |        |
 2937 //  o     |        +--------+      pad to even-align allocators stack-slot
 2938 //  w     V        |  pad0  |        numbers; owned by CALLER
 2939 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2940 //  h     ^        |   in   |  5
 2941 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2942 //  |     |        |        |  3
 2943 //  |     |        +--------+
 2944 //  V     |        | old out|      Empty on Intel, window on Sparc
</pre>
<hr />
<pre>
 8837 //----------Branches---------------------------------------------------------
 8838 // Jump
 8839 // (compare &#39;operand indIndex&#39; and &#39;instruct addP_reg_reg&#39; above)
 8840 instruct jumpXtnd(iRegX switch_val, o7RegI table) %{
 8841   match(Jump switch_val);
 8842   effect(TEMP table);
 8843 
 8844   ins_cost(350);
 8845 
 8846   format %{  &quot;ADD    $constanttablebase, $constantoffset, O7\n\t&quot;
 8847              &quot;LD     [O7 + $switch_val], O7\n\t&quot;
 8848              &quot;JUMP   O7&quot; %}
 8849   ins_encode %{
 8850     // Calculate table address into a register.
 8851     Register table_reg;
 8852     Register label_reg = O7;
 8853     // If we are calculating the size of this instruction don&#39;t trust
 8854     // zero offsets because they might change when
 8855     // MachConstantBaseNode decides to optimize the constant table
 8856     // base.
<span class="line-modified"> 8857     if ((constant_offset() == 0) &amp;&amp; !Compile::current()-&gt;output()-&gt;in_scratch_emit_size()) {</span>
 8858       table_reg = $constanttablebase;
 8859     } else {
 8860       table_reg = O7;
 8861       RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset, O7);
 8862       __ add($constanttablebase, con_offset, table_reg);
 8863     }
 8864 
 8865     // Jump to base address + switch value
 8866     __ ld_ptr(table_reg, $switch_val$$Register, label_reg);
 8867     __ jmp(label_reg, G0);
 8868     __ delayed()-&gt;nop();
 8869   %}
 8870   ins_pipe(ialu_reg_reg);
 8871 %}
 8872 
 8873 // Direct Branch.  Use V8 version with longer range.
 8874 instruct branch(label labl) %{
 8875   match(Goto);
 8876   effect(USE labl);
 8877 
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_sparc.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/sparc/macroAssembler_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;compiler/disassembler.hpp&quot;
  29 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;memory/universe.hpp&quot;
  35 #include &quot;oops/accessDecorators.hpp&quot;
  36 #include &quot;oops/compressedOops.hpp&quot;
  37 #include &quot;oops/klass.inline.hpp&quot;
  38 #include &quot;prims/methodHandles.hpp&quot;
  39 #include &quot;runtime/biasedLocking.hpp&quot;
  40 #include &quot;runtime/flags/flagSetting.hpp&quot;
  41 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  42 #include &quot;runtime/jniHandles.inline.hpp&quot;
  43 #include &quot;runtime/objectMonitor.hpp&quot;
  44 #include &quot;runtime/os.inline.hpp&quot;
  45 #include &quot;runtime/safepoint.hpp&quot;
  46 #include &quot;runtime/safepointMechanism.hpp&quot;
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
  48 #include &quot;runtime/stubRoutines.hpp&quot;
  49 #include &quot;utilities/align.hpp&quot;
  50 #include &quot;utilities/macros.hpp&quot;
  51 #include &quot;utilities/powerOfTwo.hpp&quot;
<a name="1" id="anc1"></a>


  52 
  53 #ifdef PRODUCT
  54 #define BLOCK_COMMENT(str) /* nothing */
  55 #define STOP(error) stop(error)
  56 #else
  57 #define BLOCK_COMMENT(str) block_comment(str)
  58 #define STOP(error) block_comment(error); stop(error)
  59 #endif
  60 
  61 // Convert the raw encoding form into the form expected by the
  62 // constructor for Address.
  63 Address Address::make_raw(int base, int index, int scale, int disp, relocInfo::relocType disp_reloc) {
  64   assert(scale == 0, &quot;not supported&quot;);
  65   RelocationHolder rspec;
  66   if (disp_reloc != relocInfo::none) {
  67     rspec = Relocation::spec_simple(disp_reloc);
  68   }
  69 
  70   Register rindex = as_Register(index);
  71   if (rindex != G0) {
  72     Address madr(as_Register(base), rindex);
  73     madr._rspec = rspec;
  74     return madr;
  75   } else {
  76     Address madr(as_Register(base), disp);
  77     madr._rspec = rspec;
  78     return madr;
  79   }
  80 }
  81 
  82 Address Argument::address_in_frame() const {
  83   // Warning: In LP64 mode disp will occupy more than 10 bits, but
  84   //          op codes such as ld or ldx, only access disp() to get
  85   //          their simm13 argument.
  86   int disp = ((_number - Argument::n_register_parameters + frame::memory_parameter_word_sp_offset) * BytesPerWord) + STACK_BIAS;
  87   if (is_in())
  88     return Address(FP, disp); // In argument.
  89   else
  90     return Address(SP, disp); // Out argument.
  91 }
  92 
  93 static const char* argumentNames[][2] = {
  94   {&quot;A0&quot;,&quot;P0&quot;}, {&quot;A1&quot;,&quot;P1&quot;}, {&quot;A2&quot;,&quot;P2&quot;}, {&quot;A3&quot;,&quot;P3&quot;}, {&quot;A4&quot;,&quot;P4&quot;},
  95   {&quot;A5&quot;,&quot;P5&quot;}, {&quot;A6&quot;,&quot;P6&quot;}, {&quot;A7&quot;,&quot;P7&quot;}, {&quot;A8&quot;,&quot;P8&quot;}, {&quot;A9&quot;,&quot;P9&quot;},
  96   {&quot;A(n&gt;9)&quot;,&quot;P(n&gt;9)&quot;}
  97 };
  98 
  99 const char* Argument::name() const {
 100   int nofArgs = sizeof argumentNames / sizeof argumentNames[0];
 101   int num = number();
 102   if (num &gt;= nofArgs)  num = nofArgs - 1;
 103   return argumentNames[num][is_in() ? 1 : 0];
 104 }
 105 
 106 #ifdef ASSERT
 107 // On RISC, there&#39;s no benefit to verifying instruction boundaries.
 108 bool AbstractAssembler::pd_check_instruction_mark() { return false; }
 109 #endif
 110 
 111 // Patch instruction inst at offset inst_pos to refer to dest_pos
 112 // and return the resulting instruction.
 113 // We should have pcs, not offsets, but since all is relative, it will work out
 114 // OK.
 115 int MacroAssembler::patched_branch(int dest_pos, int inst, int inst_pos) {
 116   int m; // mask for displacement field
 117   int v; // new value for displacement field
 118   const int word_aligned_ones = -4;
 119   switch (inv_op(inst)) {
 120   default: ShouldNotReachHere();
 121   case call_op:    m = wdisp(word_aligned_ones, 0, 30);  v = wdisp(dest_pos, inst_pos, 30); break;
 122   case branch_op:
 123     switch (inv_op2(inst)) {
 124       case fbp_op2:    m = wdisp(  word_aligned_ones, 0, 19);  v = wdisp(  dest_pos, inst_pos, 19); break;
 125       case bp_op2:     m = wdisp(  word_aligned_ones, 0, 19);  v = wdisp(  dest_pos, inst_pos, 19); break;
 126       case fb_op2:     m = wdisp(  word_aligned_ones, 0, 22);  v = wdisp(  dest_pos, inst_pos, 22); break;
 127       case br_op2:     m = wdisp(  word_aligned_ones, 0, 22);  v = wdisp(  dest_pos, inst_pos, 22); break;
 128       case bpr_op2: {
 129         if (is_cbcond(inst)) {
 130           m = wdisp10(word_aligned_ones, 0);
 131           v = wdisp10(dest_pos, inst_pos);
 132         } else {
 133           m = wdisp16(word_aligned_ones, 0);
 134           v = wdisp16(dest_pos, inst_pos);
 135         }
 136         break;
 137       }
 138       default: ShouldNotReachHere();
 139     }
 140   }
 141   return  inst &amp; ~m  |  v;
 142 }
 143 
 144 // Return the offset of the branch destionation of instruction inst
 145 // at offset pos.
 146 // Should have pcs, but since all is relative, it works out.
 147 int MacroAssembler::branch_destination(int inst, int pos) {
 148   int r;
 149   switch (inv_op(inst)) {
 150   default: ShouldNotReachHere();
 151   case call_op:        r = inv_wdisp(inst, pos, 30);  break;
 152   case branch_op:
 153     switch (inv_op2(inst)) {
 154       case fbp_op2:    r = inv_wdisp(  inst, pos, 19);  break;
 155       case bp_op2:     r = inv_wdisp(  inst, pos, 19);  break;
 156       case fb_op2:     r = inv_wdisp(  inst, pos, 22);  break;
 157       case br_op2:     r = inv_wdisp(  inst, pos, 22);  break;
 158       case bpr_op2: {
 159         if (is_cbcond(inst)) {
 160           r = inv_wdisp10(inst, pos);
 161         } else {
 162           r = inv_wdisp16(inst, pos);
 163         }
 164         break;
 165       }
 166       default: ShouldNotReachHere();
 167     }
 168   }
 169   return r;
 170 }
 171 
 172 void MacroAssembler::resolve_jobject(Register value, Register tmp) {
 173   Label done, not_weak;
 174   br_null(value, false, Assembler::pn, done); // Use NULL as-is.
 175   delayed()-&gt;andcc(value, JNIHandles::weak_tag_mask, G0); // Test for jweak
 176   brx(Assembler::zero, true, Assembler::pt, not_weak);
 177   delayed()-&gt;nop();
 178   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
 179                  Address(value, -JNIHandles::weak_tag_value), value, tmp);
 180   verify_oop(value);
 181   br (Assembler::always, true, Assembler::pt, done);
 182   delayed()-&gt;nop();
 183   bind(not_weak);
 184   access_load_at(T_OBJECT, IN_NATIVE, Address(value, 0), value, tmp);
 185   verify_oop(value);
 186   bind(done);
 187 }
 188 
 189 void MacroAssembler::null_check(Register reg, int offset) {
 190   if (needs_explicit_null_check((intptr_t)offset)) {
 191     // provoke OS NULL exception if reg = NULL by
 192     // accessing M[reg] w/o changing any registers
 193     ld_ptr(reg, 0, G0);
 194   }
 195   else {
 196     // nothing to do, (later) access of M[reg + offset]
 197     // will provoke OS NULL exception if reg = NULL
 198   }
 199 }
 200 
 201 // Ring buffer jumps
 202 
 203 
 204 void MacroAssembler::jmp2(Register r1, Register r2, const char* file, int line ) {
 205   assert_not_delayed();
 206   jmpl(r1, r2, G0);
 207 }
 208 void MacroAssembler::jmp(Register r1, int offset, const char* file, int line ) {
 209   assert_not_delayed();
 210   jmp(r1, offset);
 211 }
 212 
 213 // This code sequence is relocatable to any address, even on LP64.
 214 void MacroAssembler::jumpl(const AddressLiteral&amp; addrlit, Register temp, Register d, int offset, const char* file, int line) {
 215   assert_not_delayed();
 216   // Force fixed length sethi because NativeJump and NativeFarCall don&#39;t handle
 217   // variable length instruction streams.
 218   patchable_sethi(addrlit, temp);
 219   Address a(temp, addrlit.low10() + offset);  // Add the offset to the displacement.
 220   jmpl(a.base(), a.disp(), d);
 221 }
 222 
 223 void MacroAssembler::jump(const AddressLiteral&amp; addrlit, Register temp, int offset, const char* file, int line) {
 224   jumpl(addrlit, temp, G0, offset, file, line);
 225 }
 226 
 227 
 228 // Conditional breakpoint (for assertion checks in assembly code)
 229 void MacroAssembler::breakpoint_trap(Condition c, CC cc) {
 230   trap(c, cc, G0, ST_RESERVED_FOR_USER_0);
 231 }
 232 
 233 // We want to use ST_BREAKPOINT here, but the debugger is confused by it.
 234 void MacroAssembler::breakpoint_trap() {
 235   trap(ST_RESERVED_FOR_USER_0);
 236 }
 237 
 238 void MacroAssembler::safepoint_poll(Label&amp; slow_path, bool a, Register thread_reg, Register temp_reg) {
 239   if (SafepointMechanism::uses_thread_local_poll()) {
 240     ldx(Address(thread_reg, Thread::polling_page_offset()), temp_reg, 0);
 241     // Armed page has poll bit set.
 242     and3(temp_reg, SafepointMechanism::poll_bit(), temp_reg);
 243     br_notnull(temp_reg, a, Assembler::pn, slow_path);
 244   } else {
 245     AddressLiteral sync_state(SafepointSynchronize::address_of_state());
 246 
 247     load_contents(sync_state, temp_reg);
 248     cmp(temp_reg, SafepointSynchronize::_not_synchronized);
 249     br(Assembler::notEqual, a, Assembler::pn, slow_path);
 250   }
 251 }
 252 
 253 void MacroAssembler::enter() {
 254   Unimplemented();
 255 }
 256 
 257 void MacroAssembler::leave() {
 258   Unimplemented();
 259 }
 260 
 261 // Calls to C land
 262 
 263 #ifdef ASSERT
 264 // a hook for debugging
 265 static Thread* reinitialize_thread() {
 266   return Thread::current();
 267 }
 268 #else
 269 #define reinitialize_thread Thread::current
 270 #endif
 271 
 272 #ifdef ASSERT
 273 address last_get_thread = NULL;
 274 #endif
 275 
 276 // call this when G2_thread is not known to be valid
 277 void MacroAssembler::get_thread() {
 278   save_frame(0);                // to avoid clobbering O0
 279   mov(G1, L0);                  // avoid clobbering G1
 280   mov(G5_method, L1);           // avoid clobbering G5
 281   mov(G3, L2);                  // avoid clobbering G3 also
 282   mov(G4, L5);                  // avoid clobbering G4
 283 #ifdef ASSERT
 284   AddressLiteral last_get_thread_addrlit(&amp;last_get_thread);
 285   set(last_get_thread_addrlit, L3);
 286   rdpc(L4);
 287   inc(L4, 3 * BytesPerInstWord); // skip rdpc + inc + st_ptr to point L4 at call  st_ptr(L4, L3, 0);
 288 #endif
 289   call(CAST_FROM_FN_PTR(address, reinitialize_thread), relocInfo::runtime_call_type);
 290   delayed()-&gt;nop();
 291   mov(L0, G1);
 292   mov(L1, G5_method);
 293   mov(L2, G3);
 294   mov(L5, G4);
 295   restore(O0, 0, G2_thread);
 296 }
 297 
 298 static Thread* verify_thread_subroutine(Thread* gthread_value) {
 299   Thread* correct_value = Thread::current();
 300   guarantee(gthread_value == correct_value, &quot;G2_thread value must be the thread&quot;);
 301   return correct_value;
 302 }
 303 
 304 void MacroAssembler::verify_thread() {
 305   if (VerifyThread) {
 306     // NOTE: this chops off the heads of the 64-bit O registers.
 307     // make sure G2_thread contains the right value
 308     save_frame_and_mov(0, Lmethod, Lmethod);   // to avoid clobbering O0 (and propagate Lmethod)
 309     mov(G1, L1);                // avoid clobbering G1
 310     // G2 saved below
 311     mov(G3, L3);                // avoid clobbering G3
 312     mov(G4, L4);                // avoid clobbering G4
 313     mov(G5_method, L5);         // avoid clobbering G5_method
 314     call(CAST_FROM_FN_PTR(address,verify_thread_subroutine), relocInfo::runtime_call_type);
 315     delayed()-&gt;mov(G2_thread, O0);
 316 
 317     mov(L1, G1);                // Restore G1
 318     // G2 restored below
 319     mov(L3, G3);                // restore G3
 320     mov(L4, G4);                // restore G4
 321     mov(L5, G5_method);         // restore G5_method
 322     restore(O0, 0, G2_thread);
 323   }
 324 }
 325 
 326 
 327 void MacroAssembler::save_thread(const Register thread_cache) {
 328   verify_thread();
 329   if (thread_cache-&gt;is_valid()) {
 330     assert(thread_cache-&gt;is_local() || thread_cache-&gt;is_in(), &quot;bad volatile&quot;);
 331     mov(G2_thread, thread_cache);
 332   }
 333   if (VerifyThread) {
 334     // smash G2_thread, as if the VM were about to anyway
 335     set(0x67676767, G2_thread);
 336   }
 337 }
 338 
 339 
 340 void MacroAssembler::restore_thread(const Register thread_cache) {
 341   if (thread_cache-&gt;is_valid()) {
 342     assert(thread_cache-&gt;is_local() || thread_cache-&gt;is_in(), &quot;bad volatile&quot;);
 343     mov(thread_cache, G2_thread);
 344     verify_thread();
 345   } else {
 346     // do it the slow way
 347     get_thread();
 348   }
 349 }
 350 
 351 
 352 // %%% maybe get rid of [re]set_last_Java_frame
 353 void MacroAssembler::set_last_Java_frame(Register last_java_sp, Register last_Java_pc) {
 354   assert_not_delayed();
 355   Address flags(G2_thread, JavaThread::frame_anchor_offset() +
 356                            JavaFrameAnchor::flags_offset());
 357   Address pc_addr(G2_thread, JavaThread::last_Java_pc_offset());
 358 
 359   // Always set last_Java_pc and flags first because once last_Java_sp is visible
 360   // has_last_Java_frame is true and users will look at the rest of the fields.
 361   // (Note: flags should always be zero before we get here so doesn&#39;t need to be set.)
 362 
 363 #ifdef ASSERT
 364   // Verify that flags was zeroed on return to Java
 365   Label PcOk;
 366   save_frame(0);                // to avoid clobbering O0
 367   ld_ptr(pc_addr, L0);
 368   br_null_short(L0, Assembler::pt, PcOk);
 369   STOP(&quot;last_Java_pc not zeroed before leaving Java&quot;);
 370   bind(PcOk);
 371 
 372   // Verify that flags was zeroed on return to Java
 373   Label FlagsOk;
 374   ld(flags, L0);
 375   tst(L0);
 376   br(Assembler::zero, false, Assembler::pt, FlagsOk);
 377   delayed() -&gt; restore();
 378   STOP(&quot;flags not zeroed before leaving Java&quot;);
 379   bind(FlagsOk);
 380 #endif /* ASSERT */
 381   //
 382   // When returning from calling out from Java mode the frame anchor&#39;s last_Java_pc
 383   // will always be set to NULL. It is set here so that if we are doing a call to
 384   // native (not VM) that we capture the known pc and don&#39;t have to rely on the
 385   // native call having a standard frame linkage where we can find the pc.
 386 
 387   if (last_Java_pc-&gt;is_valid()) {
 388     st_ptr(last_Java_pc, pc_addr);
 389   }
 390 
 391 #ifdef ASSERT
 392   // Make sure that we have an odd stack
 393   Label StackOk;
 394   andcc(last_java_sp, 0x01, G0);
 395   br(Assembler::notZero, false, Assembler::pt, StackOk);
 396   delayed()-&gt;nop();
 397   STOP(&quot;Stack Not Biased in set_last_Java_frame&quot;);
 398   bind(StackOk);
 399 #endif // ASSERT
 400   assert( last_java_sp != G4_scratch, &quot;bad register usage in set_last_Java_frame&quot;);
 401   add( last_java_sp, STACK_BIAS, G4_scratch );
 402   st_ptr(G4_scratch, G2_thread, JavaThread::last_Java_sp_offset());
 403 }
 404 
 405 void MacroAssembler::reset_last_Java_frame(void) {
 406   assert_not_delayed();
 407 
 408   Address sp_addr(G2_thread, JavaThread::last_Java_sp_offset());
 409   Address pc_addr(G2_thread, JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset());
 410   Address flags  (G2_thread, JavaThread::frame_anchor_offset() + JavaFrameAnchor::flags_offset());
 411 
 412 #ifdef ASSERT
 413   // check that it WAS previously set
 414     save_frame_and_mov(0, Lmethod, Lmethod);     // Propagate Lmethod to helper frame
 415     ld_ptr(sp_addr, L0);
 416     tst(L0);
 417     breakpoint_trap(Assembler::zero, Assembler::ptr_cc);
 418     restore();
 419 #endif // ASSERT
 420 
 421   st_ptr(G0, sp_addr);
 422   // Always return last_Java_pc to zero
 423   st_ptr(G0, pc_addr);
 424   // Always null flags after return to Java
 425   st(G0, flags);
 426 }
 427 
 428 
 429 void MacroAssembler::call_VM_base(
 430   Register        oop_result,
 431   Register        thread_cache,
 432   Register        last_java_sp,
 433   address         entry_point,
 434   int             number_of_arguments,
 435   bool            check_exceptions)
 436 {
 437   assert_not_delayed();
 438 
 439   // determine last_java_sp register
 440   if (!last_java_sp-&gt;is_valid()) {
 441     last_java_sp = SP;
 442   }
 443   // debugging support
 444   assert(number_of_arguments &gt;= 0   , &quot;cannot have negative number of arguments&quot;);
 445 
 446   // 64-bit last_java_sp is biased!
 447   set_last_Java_frame(last_java_sp, noreg);
 448   if (VerifyThread)  mov(G2_thread, O0); // about to be smashed; pass early
 449   save_thread(thread_cache);
 450   // do the call
 451   call(entry_point, relocInfo::runtime_call_type);
 452   if (!VerifyThread)
 453     delayed()-&gt;mov(G2_thread, O0);  // pass thread as first argument
 454   else
 455     delayed()-&gt;nop();             // (thread already passed)
 456   restore_thread(thread_cache);
 457   reset_last_Java_frame();
 458 
 459   // check for pending exceptions. use Gtemp as scratch register.
 460   if (check_exceptions) {
 461     check_and_forward_exception(Gtemp);
 462   }
 463 
 464 #ifdef ASSERT
 465   set(badHeapWordVal, G3);
 466   set(badHeapWordVal, G4);
 467   set(badHeapWordVal, G5);
 468 #endif
 469 
 470   // get oop result if there is one and reset the value in the thread
 471   if (oop_result-&gt;is_valid()) {
 472     get_vm_result(oop_result);
 473   }
 474 }
 475 
 476 void MacroAssembler::check_and_forward_exception(Register scratch_reg)
 477 {
 478   Label L;
 479 
 480   check_and_handle_popframe(scratch_reg);
 481   check_and_handle_earlyret(scratch_reg);
 482 
 483   Address exception_addr(G2_thread, Thread::pending_exception_offset());
 484   ld_ptr(exception_addr, scratch_reg);
 485   br_null_short(scratch_reg, pt, L);
 486   // we use O7 linkage so that forward_exception_entry has the issuing PC
 487   call(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type);
 488   delayed()-&gt;nop();
 489   bind(L);
 490 }
 491 
 492 
 493 void MacroAssembler::check_and_handle_popframe(Register scratch_reg) {
 494 }
 495 
 496 
 497 void MacroAssembler::check_and_handle_earlyret(Register scratch_reg) {
 498 }
 499 
 500 
 501 void MacroAssembler::call_VM(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions) {
 502   call_VM_base(oop_result, noreg, noreg, entry_point, number_of_arguments, check_exceptions);
 503 }
 504 
 505 
 506 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, bool check_exceptions) {
 507   // O0 is reserved for the thread
 508   mov(arg_1, O1);
 509   call_VM(oop_result, entry_point, 1, check_exceptions);
 510 }
 511 
 512 
 513 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, Register arg_2, bool check_exceptions) {
 514   // O0 is reserved for the thread
 515   mov(arg_1, O1);
 516   mov(arg_2, O2); assert(arg_2 != O1, &quot;smashed argument&quot;);
 517   call_VM(oop_result, entry_point, 2, check_exceptions);
 518 }
 519 
 520 
 521 void MacroAssembler::call_VM(Register oop_result, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions) {
 522   // O0 is reserved for the thread
 523   mov(arg_1, O1);
 524   mov(arg_2, O2); assert(arg_2 != O1,                &quot;smashed argument&quot;);
 525   mov(arg_3, O3); assert(arg_3 != O1 &amp;&amp; arg_3 != O2, &quot;smashed argument&quot;);
 526   call_VM(oop_result, entry_point, 3, check_exceptions);
 527 }
 528 
 529 
 530 
 531 // Note: The following call_VM overloadings are useful when a &quot;save&quot;
 532 // has already been performed by a stub, and the last Java frame is
 533 // the previous one.  In that case, last_java_sp must be passed as FP
 534 // instead of SP.
 535 
 536 
 537 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, int number_of_arguments, bool check_exceptions) {
 538   call_VM_base(oop_result, noreg, last_java_sp, entry_point, number_of_arguments, check_exceptions);
 539 }
 540 
 541 
 542 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, bool check_exceptions) {
 543   // O0 is reserved for the thread
 544   mov(arg_1, O1);
 545   call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
 546 }
 547 
 548 
 549 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, bool check_exceptions) {
 550   // O0 is reserved for the thread
 551   mov(arg_1, O1);
 552   mov(arg_2, O2); assert(arg_2 != O1, &quot;smashed argument&quot;);
 553   call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
 554 }
 555 
 556 
 557 void MacroAssembler::call_VM(Register oop_result, Register last_java_sp, address entry_point, Register arg_1, Register arg_2, Register arg_3, bool check_exceptions) {
 558   // O0 is reserved for the thread
 559   mov(arg_1, O1);
 560   mov(arg_2, O2); assert(arg_2 != O1,                &quot;smashed argument&quot;);
 561   mov(arg_3, O3); assert(arg_3 != O1 &amp;&amp; arg_3 != O2, &quot;smashed argument&quot;);
 562   call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
 563 }
 564 
 565 
 566 
 567 void MacroAssembler::call_VM_leaf_base(Register thread_cache, address entry_point, int number_of_arguments) {
 568   assert_not_delayed();
 569   save_thread(thread_cache);
 570   // do the call
 571   call(entry_point, relocInfo::runtime_call_type);
 572   delayed()-&gt;nop();
 573   restore_thread(thread_cache);
 574 #ifdef ASSERT
 575   set(badHeapWordVal, G3);
 576   set(badHeapWordVal, G4);
 577   set(badHeapWordVal, G5);
 578 #endif
 579 }
 580 
 581 
 582 void MacroAssembler::call_VM_leaf(Register thread_cache, address entry_point, int number_of_arguments) {
 583   call_VM_leaf_base(thread_cache, entry_point, number_of_arguments);
 584 }
 585 
 586 
 587 void MacroAssembler::call_VM_leaf(Register thread_cache, address entry_point, Register arg_1) {
 588   mov(arg_1, O0);
 589   call_VM_leaf(thread_cache, entry_point, 1);
 590 }
 591 
 592 
 593 void MacroAssembler::call_VM_leaf(Register thread_cache, address entry_point, Register arg_1, Register arg_2) {
 594   mov(arg_1, O0);
 595   mov(arg_2, O1); assert(arg_2 != O0, &quot;smashed argument&quot;);
 596   call_VM_leaf(thread_cache, entry_point, 2);
 597 }
 598 
 599 
 600 void MacroAssembler::call_VM_leaf(Register thread_cache, address entry_point, Register arg_1, Register arg_2, Register arg_3) {
 601   mov(arg_1, O0);
 602   mov(arg_2, O1); assert(arg_2 != O0,                &quot;smashed argument&quot;);
 603   mov(arg_3, O2); assert(arg_3 != O0 &amp;&amp; arg_3 != O1, &quot;smashed argument&quot;);
 604   call_VM_leaf(thread_cache, entry_point, 3);
 605 }
 606 
 607 
 608 void MacroAssembler::get_vm_result(Register oop_result) {
 609   verify_thread();
 610   Address vm_result_addr(G2_thread, JavaThread::vm_result_offset());
 611   ld_ptr(    vm_result_addr, oop_result);
 612   st_ptr(G0, vm_result_addr);
 613   verify_oop(oop_result);
 614 }
 615 
 616 
 617 void MacroAssembler::get_vm_result_2(Register metadata_result) {
 618   verify_thread();
 619   Address vm_result_addr_2(G2_thread, JavaThread::vm_result_2_offset());
 620   ld_ptr(vm_result_addr_2, metadata_result);
 621   st_ptr(G0, vm_result_addr_2);
 622 }
 623 
 624 
 625 // We require that C code which does not return a value in vm_result will
 626 // leave it undisturbed.
 627 void MacroAssembler::set_vm_result(Register oop_result) {
 628   verify_thread();
 629   Address vm_result_addr(G2_thread, JavaThread::vm_result_offset());
 630   verify_oop(oop_result);
 631 
 632 # ifdef ASSERT
 633     // Check that we are not overwriting any other oop.
 634     save_frame_and_mov(0, Lmethod, Lmethod);     // Propagate Lmethod
 635     ld_ptr(vm_result_addr, L0);
 636     tst(L0);
 637     restore();
 638     breakpoint_trap(notZero, Assembler::ptr_cc);
 639     // }
 640 # endif
 641 
 642   st_ptr(oop_result, vm_result_addr);
 643 }
 644 
 645 
 646 void MacroAssembler::ic_call(address entry, bool emit_delay, jint method_index) {
 647   RelocationHolder rspec = virtual_call_Relocation::spec(pc(), method_index);
 648   patchable_set((intptr_t)Universe::non_oop_word(), G5_inline_cache_reg);
 649   relocate(rspec);
 650   call(entry, relocInfo::none);
 651   if (emit_delay) {
 652     delayed()-&gt;nop();
 653   }
 654 }
 655 
 656 
 657 void MacroAssembler::internal_sethi(const AddressLiteral&amp; addrlit, Register d, bool ForceRelocatable) {
 658   address save_pc;
 659   int shiftcnt;
 660 #ifdef VALIDATE_PIPELINE
 661   assert_no_delay(&quot;Cannot put two instructions in delay-slot.&quot;);
 662 #endif
 663   v9_dep();
 664   save_pc = pc();
 665 
 666   int msb32 = (int) (addrlit.value() &gt;&gt; 32);
 667   int lsb32 = (int) (addrlit.value());
 668 
 669   if (msb32 == 0 &amp;&amp; lsb32 &gt;= 0) {
 670     Assembler::sethi(lsb32, d, addrlit.rspec());
 671   }
 672   else if (msb32 == -1) {
 673     Assembler::sethi(~lsb32, d, addrlit.rspec());
 674     xor3(d, ~low10(~0), d);
 675   }
 676   else {
 677     Assembler::sethi(msb32, d, addrlit.rspec());  // msb 22-bits
 678     if (msb32 &amp; 0x3ff)                            // Any bits?
 679       or3(d, msb32 &amp; 0x3ff, d);                   // msb 32-bits are now in lsb 32
 680     if (lsb32 &amp; 0xFFFFFC00) {                     // done?
 681       if ((lsb32 &gt;&gt; 20) &amp; 0xfff) {                // Any bits set?
 682         sllx(d, 12, d);                           // Make room for next 12 bits
 683         or3(d, (lsb32 &gt;&gt; 20) &amp; 0xfff, d);         // Or in next 12
 684         shiftcnt = 0;                             // We already shifted
 685       }
 686       else
 687         shiftcnt = 12;
 688       if ((lsb32 &gt;&gt; 10) &amp; 0x3ff) {
 689         sllx(d, shiftcnt + 10, d);                // Make room for last 10 bits
 690         or3(d, (lsb32 &gt;&gt; 10) &amp; 0x3ff, d);         // Or in next 10
 691         shiftcnt = 0;
 692       }
 693       else
 694         shiftcnt = 10;
 695       sllx(d, shiftcnt + 10, d);                  // Shift leaving disp field 0&#39;d
 696     }
 697     else
 698       sllx(d, 32, d);
 699   }
 700   // Pad out the instruction sequence so it can be patched later.
 701   if (ForceRelocatable || (addrlit.rtype() != relocInfo::none &amp;&amp;
 702                            addrlit.rtype() != relocInfo::runtime_call_type)) {
 703     while (pc() &lt; (save_pc + (7 * BytesPerInstWord)))
 704       nop();
 705   }
 706 }
 707 
 708 
 709 void MacroAssembler::sethi(const AddressLiteral&amp; addrlit, Register d) {
 710   internal_sethi(addrlit, d, false);
 711 }
 712 
 713 
 714 void MacroAssembler::patchable_sethi(const AddressLiteral&amp; addrlit, Register d) {
 715   internal_sethi(addrlit, d, true);
 716 }
 717 
 718 
 719 int MacroAssembler::insts_for_sethi(address a, bool worst_case) {
 720   if (worst_case)  return 7;
 721   intptr_t iaddr = (intptr_t) a;
 722   int msb32 = (int) (iaddr &gt;&gt; 32);
 723   int lsb32 = (int) (iaddr);
 724   int count;
 725   if (msb32 == 0 &amp;&amp; lsb32 &gt;= 0)
 726     count = 1;
 727   else if (msb32 == -1)
 728     count = 2;
 729   else {
 730     count = 2;
 731     if (msb32 &amp; 0x3ff)
 732       count++;
 733     if (lsb32 &amp; 0xFFFFFC00 ) {
 734       if ((lsb32 &gt;&gt; 20) &amp; 0xfff)  count += 2;
 735       if ((lsb32 &gt;&gt; 10) &amp; 0x3ff)  count += 2;
 736     }
 737   }
 738   return count;
 739 }
 740 
 741 int MacroAssembler::worst_case_insts_for_set() {
 742   return insts_for_sethi(NULL, true) + 1;
 743 }
 744 
 745 
 746 // Keep in sync with MacroAssembler::insts_for_internal_set
 747 void MacroAssembler::internal_set(const AddressLiteral&amp; addrlit, Register d, bool ForceRelocatable) {
 748   intptr_t value = addrlit.value();
 749 
 750   if (!ForceRelocatable &amp;&amp; addrlit.rspec().type() == relocInfo::none) {
 751     // can optimize
 752     if (-4096 &lt;= value &amp;&amp; value &lt;= 4095) {
 753       or3(G0, value, d); // setsw (this leaves upper 32 bits sign-extended)
 754       return;
 755     }
 756     if (inv_hi22(hi22(value)) == value) {
 757       sethi(addrlit, d);
 758       return;
 759     }
 760   }
 761   assert_no_delay(&quot;Cannot put two instructions in delay-slot.&quot;);
 762   internal_sethi(addrlit, d, ForceRelocatable);
 763   if (ForceRelocatable || addrlit.rspec().type() != relocInfo::none || addrlit.low10() != 0) {
 764     add(d, addrlit.low10(), d, addrlit.rspec());
 765   }
 766 }
 767 
 768 // Keep in sync with MacroAssembler::internal_set
 769 int MacroAssembler::insts_for_internal_set(intptr_t value) {
 770   // can optimize
 771   if (-4096 &lt;= value &amp;&amp; value &lt;= 4095) {
 772     return 1;
 773   }
 774   if (inv_hi22(hi22(value)) == value) {
 775     return insts_for_sethi((address) value);
 776   }
 777   int count = insts_for_sethi((address) value);
 778   AddressLiteral al(value);
 779   if (al.low10() != 0) {
 780     count++;
 781   }
 782   return count;
 783 }
 784 
 785 void MacroAssembler::set(const AddressLiteral&amp; al, Register d) {
 786   internal_set(al, d, false);
 787 }
 788 
 789 void MacroAssembler::set(intptr_t value, Register d) {
 790   AddressLiteral al(value);
 791   internal_set(al, d, false);
 792 }
 793 
 794 void MacroAssembler::set(address addr, Register d, RelocationHolder const&amp; rspec) {
 795   AddressLiteral al(addr, rspec);
 796   internal_set(al, d, false);
 797 }
 798 
 799 void MacroAssembler::patchable_set(const AddressLiteral&amp; al, Register d) {
 800   internal_set(al, d, true);
 801 }
 802 
 803 void MacroAssembler::patchable_set(intptr_t value, Register d) {
 804   AddressLiteral al(value);
 805   internal_set(al, d, true);
 806 }
 807 
 808 
 809 void MacroAssembler::set64(jlong value, Register d, Register tmp) {
 810   assert_not_delayed();
 811   v9_dep();
 812 
 813   int hi = (int)(value &gt;&gt; 32);
 814   int lo = (int)(value &amp; ~0);
 815   int bits_33to2 = (int)((value &gt;&gt; 2) &amp; ~0);
 816   // (Matcher::isSimpleConstant64 knows about the following optimizations.)
 817   if (Assembler::is_simm13(lo) &amp;&amp; value == lo) {
 818     or3(G0, lo, d);
 819   } else if (hi == 0) {
 820     Assembler::sethi(lo, d);   // hardware version zero-extends to upper 32
 821     if (low10(lo) != 0)
 822       or3(d, low10(lo), d);
 823   }
 824   else if ((hi &gt;&gt; 2) == 0) {
 825     Assembler::sethi(bits_33to2, d);  // hardware version zero-extends to upper 32
 826     sllx(d, 2, d);
 827     if (low12(lo) != 0)
 828       or3(d, low12(lo), d);
 829   }
 830   else if (hi == -1) {
 831     Assembler::sethi(~lo, d);  // hardware version zero-extends to upper 32
 832     xor3(d, low10(lo) ^ ~low10(~0), d);
 833   }
 834   else if (lo == 0) {
 835     if (Assembler::is_simm13(hi)) {
 836       or3(G0, hi, d);
 837     } else {
 838       Assembler::sethi(hi, d);   // hardware version zero-extends to upper 32
 839       if (low10(hi) != 0)
 840         or3(d, low10(hi), d);
 841     }
 842     sllx(d, 32, d);
 843   }
 844   else {
 845     Assembler::sethi(hi, tmp);
 846     Assembler::sethi(lo,   d); // macro assembler version sign-extends
 847     if (low10(hi) != 0)
 848       or3 (tmp, low10(hi), tmp);
 849     if (low10(lo) != 0)
 850       or3 (  d, low10(lo),   d);
 851     sllx(tmp, 32, tmp);
 852     or3 (d, tmp, d);
 853   }
 854 }
 855 
 856 int MacroAssembler::insts_for_set64(jlong value) {
 857   v9_dep();
 858 
 859   int hi = (int) (value &gt;&gt; 32);
 860   int lo = (int) (value &amp; ~0);
 861   int count = 0;
 862 
 863   // (Matcher::isSimpleConstant64 knows about the following optimizations.)
 864   if (Assembler::is_simm13(lo) &amp;&amp; value == lo) {
 865     count++;
 866   } else if (hi == 0) {
 867     count++;
 868     if (low10(lo) != 0)
 869       count++;
 870   }
 871   else if (hi == -1) {
 872     count += 2;
 873   }
 874   else if (lo == 0) {
 875     if (Assembler::is_simm13(hi)) {
 876       count++;
 877     } else {
 878       count++;
 879       if (low10(hi) != 0)
 880         count++;
 881     }
 882     count++;
 883   }
 884   else {
 885     count += 2;
 886     if (low10(hi) != 0)
 887       count++;
 888     if (low10(lo) != 0)
 889       count++;
 890     count += 2;
 891   }
 892   return count;
 893 }
 894 
 895 // compute size in bytes of sparc frame, given
 896 // number of extraWords
 897 int MacroAssembler::total_frame_size_in_bytes(int extraWords) {
 898 
 899   int nWords = frame::memory_parameter_word_sp_offset;
 900 
 901   nWords += extraWords;
 902 
 903   if (nWords &amp; 1) ++nWords; // round up to double-word
 904 
 905   return nWords * BytesPerWord;
 906 }
 907 
 908 
 909 // save_frame: given number of &quot;extra&quot; words in frame,
 910 // issue approp. save instruction (p 200, v8 manual)
 911 
 912 void MacroAssembler::save_frame(int extraWords) {
 913   int delta = -total_frame_size_in_bytes(extraWords);
 914   if (is_simm13(delta)) {
 915     save(SP, delta, SP);
 916   } else {
 917     set(delta, G3_scratch);
 918     save(SP, G3_scratch, SP);
 919   }
 920 }
 921 
 922 
 923 void MacroAssembler::save_frame_c1(int size_in_bytes) {
 924   if (is_simm13(-size_in_bytes)) {
 925     save(SP, -size_in_bytes, SP);
 926   } else {
 927     set(-size_in_bytes, G3_scratch);
 928     save(SP, G3_scratch, SP);
 929   }
 930 }
 931 
 932 
 933 void MacroAssembler::save_frame_and_mov(int extraWords,
 934                                         Register s1, Register d1,
 935                                         Register s2, Register d2) {
 936   assert_not_delayed();
 937 
 938   // The trick here is to use precisely the same memory word
 939   // that trap handlers also use to save the register.
 940   // This word cannot be used for any other purpose, but
 941   // it works fine to save the register&#39;s value, whether or not
 942   // an interrupt flushes register windows at any given moment!
 943   Address s1_addr;
 944   if (s1-&gt;is_valid() &amp;&amp; (s1-&gt;is_in() || s1-&gt;is_local())) {
 945     s1_addr = s1-&gt;address_in_saved_window();
 946     st_ptr(s1, s1_addr);
 947   }
 948 
 949   Address s2_addr;
 950   if (s2-&gt;is_valid() &amp;&amp; (s2-&gt;is_in() || s2-&gt;is_local())) {
 951     s2_addr = s2-&gt;address_in_saved_window();
 952     st_ptr(s2, s2_addr);
 953   }
 954 
 955   save_frame(extraWords);
 956 
 957   if (s1_addr.base() == SP) {
 958     ld_ptr(s1_addr.after_save(), d1);
 959   } else if (s1-&gt;is_valid()) {
 960     mov(s1-&gt;after_save(), d1);
 961   }
 962 
 963   if (s2_addr.base() == SP) {
 964     ld_ptr(s2_addr.after_save(), d2);
 965   } else if (s2-&gt;is_valid()) {
 966     mov(s2-&gt;after_save(), d2);
 967   }
 968 }
 969 
 970 
 971 AddressLiteral MacroAssembler::allocate_metadata_address(Metadata* obj) {
 972   assert(oop_recorder() != NULL, &quot;this assembler needs a Recorder&quot;);
 973   int index = oop_recorder()-&gt;allocate_metadata_index(obj);
 974   RelocationHolder rspec = metadata_Relocation::spec(index);
 975   return AddressLiteral((address)obj, rspec);
 976 }
 977 
 978 AddressLiteral MacroAssembler::constant_metadata_address(Metadata* obj) {
 979   assert(oop_recorder() != NULL, &quot;this assembler needs a Recorder&quot;);
 980   int index = oop_recorder()-&gt;find_index(obj);
 981   RelocationHolder rspec = metadata_Relocation::spec(index);
 982   return AddressLiteral((address)obj, rspec);
 983 }
 984 
 985 
 986 AddressLiteral MacroAssembler::constant_oop_address(jobject obj) {
 987 #ifdef ASSERT
 988   {
 989     ThreadInVMfromUnknown tiv;
 990     assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 991     assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;not an oop&quot;);
 992   }
 993 #endif
 994   int oop_index = oop_recorder()-&gt;find_index(obj);
 995   return AddressLiteral(obj, oop_Relocation::spec(oop_index));
 996 }
 997 
 998 void  MacroAssembler::set_narrow_oop(jobject obj, Register d) {
 999   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1000   int oop_index = oop_recorder()-&gt;find_index(obj);
1001   RelocationHolder rspec = oop_Relocation::spec(oop_index);
1002 
1003   assert_not_delayed();
1004   // Relocation with special format (see relocInfo_sparc.hpp).
1005   relocate(rspec, 1);
1006   // Assembler::sethi(0x3fffff, d);
1007   emit_int32( op(branch_op) | rd(d) | op2(sethi_op2) | hi22(0x3fffff) );
1008   // Don&#39;t add relocation for &#39;add&#39;. Do patching during &#39;sethi&#39; processing.
1009   add(d, 0x3ff, d);
1010 
1011 }
1012 
1013 void  MacroAssembler::set_narrow_klass(Klass* k, Register d) {
1014   assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
1015   int klass_index = oop_recorder()-&gt;find_index(k);
1016   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
1017   narrowOop encoded_k = CompressedKlassPointers::encode(k);
1018 
1019   assert_not_delayed();
1020   // Relocation with special format (see relocInfo_sparc.hpp).
1021   relocate(rspec, 1);
1022   // Assembler::sethi(encoded_k, d);
1023   emit_int32( op(branch_op) | rd(d) | op2(sethi_op2) | hi22(encoded_k) );
1024   // Don&#39;t add relocation for &#39;add&#39;. Do patching during &#39;sethi&#39; processing.
1025   add(d, low10(encoded_k), d);
1026 
1027 }
1028 
1029 void MacroAssembler::align(int modulus) {
1030   while (offset() % modulus != 0) nop();
1031 }
1032 
1033 void RegistersForDebugging::print(outputStream* s) {
1034   FlagSetting fs(Debugging, true);
1035   int j;
1036   for (j = 0; j &lt; 8; ++j) {
1037     if (j != 6) { s-&gt;print(&quot;i%d = &quot;, j); os::print_location(s, i[j]); }
1038     else        { s-&gt;print( &quot;fp = &quot;   ); os::print_location(s, i[j]); }
1039   }
1040   s-&gt;cr();
1041 
1042   for (j = 0;  j &lt; 8;  ++j) {
1043     s-&gt;print(&quot;l%d = &quot;, j); os::print_location(s, l[j]);
1044   }
1045   s-&gt;cr();
1046 
1047   for (j = 0; j &lt; 8; ++j) {
1048     if (j != 6) { s-&gt;print(&quot;o%d = &quot;, j); os::print_location(s, o[j]); }
1049     else        { s-&gt;print( &quot;sp = &quot;   ); os::print_location(s, o[j]); }
1050   }
1051   s-&gt;cr();
1052 
1053   for (j = 0; j &lt; 8; ++j) {
1054     s-&gt;print(&quot;g%d = &quot;, j); os::print_location(s, g[j]);
1055   }
1056   s-&gt;cr();
1057 
1058   // print out floats with compression
1059   for (j = 0; j &lt; 32; ) {
1060     jfloat val = f[j];
1061     int last = j;
1062     for ( ;  last+1 &lt; 32;  ++last ) {
1063       char b1[1024], b2[1024];
1064       sprintf(b1, &quot;%f&quot;, val);
1065       sprintf(b2, &quot;%f&quot;, f[last+1]);
1066       if (strcmp(b1, b2))
1067         break;
1068     }
1069     s-&gt;print(&quot;f%d&quot;, j);
1070     if ( j != last )  s-&gt;print(&quot; - f%d&quot;, last);
1071     s-&gt;print(&quot; = %f&quot;, val);
1072     s-&gt;fill_to(25);
1073     s-&gt;print_cr(&quot; (0x%x)&quot;, *(int*)&amp;val);
1074     j = last + 1;
1075   }
1076   s-&gt;cr();
1077 
1078   // and doubles (evens only)
1079   for (j = 0; j &lt; 32; ) {
1080     jdouble val = d[j];
1081     int last = j;
1082     for ( ;  last+1 &lt; 32;  ++last ) {
1083       char b1[1024], b2[1024];
1084       sprintf(b1, &quot;%f&quot;, val);
1085       sprintf(b2, &quot;%f&quot;, d[last+1]);
1086       if (strcmp(b1, b2))
1087         break;
1088     }
1089     s-&gt;print(&quot;d%d&quot;, 2 * j);
1090     if ( j != last )  s-&gt;print(&quot; - d%d&quot;, last);
1091     s-&gt;print(&quot; = %f&quot;, val);
1092     s-&gt;fill_to(30);
1093     s-&gt;print(&quot;(0x%x)&quot;, *(int*)&amp;val);
1094     s-&gt;fill_to(42);
1095     s-&gt;print_cr(&quot;(0x%x)&quot;, *(1 + (int*)&amp;val));
1096     j = last + 1;
1097   }
1098   s-&gt;cr();
1099 }
1100 
1101 void RegistersForDebugging::save_registers(MacroAssembler* a) {
1102   a-&gt;sub(FP, align_up(sizeof(RegistersForDebugging), sizeof(jdouble)) - STACK_BIAS, O0);
1103   a-&gt;flushw();
1104   int i;
1105   for (i = 0; i &lt; 8; ++i) {
1106     a-&gt;ld_ptr(as_iRegister(i)-&gt;address_in_saved_window().after_save(), L1);  a-&gt;st_ptr( L1, O0, i_offset(i));
1107     a-&gt;ld_ptr(as_lRegister(i)-&gt;address_in_saved_window().after_save(), L1);  a-&gt;st_ptr( L1, O0, l_offset(i));
1108     a-&gt;st_ptr(as_oRegister(i)-&gt;after_save(), O0, o_offset(i));
1109     a-&gt;st_ptr(as_gRegister(i)-&gt;after_save(), O0, g_offset(i));
1110   }
1111   for (i = 0;  i &lt; 32; ++i) {
1112     a-&gt;stf(FloatRegisterImpl::S, as_FloatRegister(i), O0, f_offset(i));
1113   }
1114   for (i = 0; i &lt; 64; i += 2) {
1115     a-&gt;stf(FloatRegisterImpl::D, as_FloatRegister(i), O0, d_offset(i));
1116   }
1117 }
1118 
1119 void RegistersForDebugging::restore_registers(MacroAssembler* a, Register r) {
1120   for (int i = 1; i &lt; 8;  ++i) {
1121     a-&gt;ld_ptr(r, g_offset(i), as_gRegister(i));
1122   }
1123   for (int j = 0; j &lt; 32; ++j) {
1124     a-&gt;ldf(FloatRegisterImpl::S, O0, f_offset(j), as_FloatRegister(j));
1125   }
1126   for (int k = 0; k &lt; 64; k += 2) {
1127     a-&gt;ldf(FloatRegisterImpl::D, O0, d_offset(k), as_FloatRegister(k));
1128   }
1129 }
1130 
1131 void MacroAssembler::_verify_oop(Register reg, const char* msg, const char * file, int line) {
1132   // plausibility check for oops
1133   if (!VerifyOops) return;
1134 
1135   if (reg == G0)  return;       // always NULL, which is always an oop
1136 
1137   BLOCK_COMMENT(&quot;verify_oop {&quot;);
1138   char buffer[64];
1139 #ifdef COMPILER1
1140   if (CommentedAssembly) {
1141     snprintf(buffer, sizeof(buffer), &quot;verify_oop at %d&quot;, offset());
1142     block_comment(buffer);
1143   }
1144 #endif
1145 
1146   const char* real_msg = NULL;
1147   {
1148     ResourceMark rm;
1149     stringStream ss;
1150     ss.print(&quot;%s at offset %d (%s:%d)&quot;, msg, offset(), file, line);
1151     real_msg = code_string(ss.as_string());
1152   }
1153 
1154   // Call indirectly to solve generation ordering problem
1155   AddressLiteral a(StubRoutines::verify_oop_subroutine_entry_address());
1156 
1157   // Make some space on stack above the current register window.
1158   // Enough to hold 8 64-bit registers.
1159   add(SP,-8*8,SP);
1160 
1161   // Save some 64-bit registers; a normal &#39;save&#39; chops the heads off
1162   // of 64-bit longs in the 32-bit build.
1163   stx(O0,SP,frame::register_save_words*wordSize+STACK_BIAS+0*8);
1164   stx(O1,SP,frame::register_save_words*wordSize+STACK_BIAS+1*8);
1165   mov(reg,O0); // Move arg into O0; arg might be in O7 which is about to be crushed
1166   stx(O7,SP,frame::register_save_words*wordSize+STACK_BIAS+7*8);
1167 
1168   // Size of set() should stay the same
1169   patchable_set((intptr_t)real_msg, O1);
1170   // Load address to call to into O7
1171   load_ptr_contents(a, O7);
1172   // Register call to verify_oop_subroutine
1173   callr(O7, G0);
1174   delayed()-&gt;nop();
1175   // recover frame size
1176   add(SP, 8*8,SP);
1177   BLOCK_COMMENT(&quot;} verify_oop&quot;);
1178 }
1179 
1180 void MacroAssembler::_verify_oop_addr(Address addr, const char* msg, const char * file, int line) {
1181   // plausibility check for oops
1182   if (!VerifyOops) return;
1183 
1184   const char* real_msg = NULL;
1185   {
1186     ResourceMark rm;
1187     stringStream ss;
1188     ss.print(&quot;%s at SP+%d (%s:%d)&quot;, msg, addr.disp(), file, line);
1189     real_msg = code_string(ss.as_string());
1190   }
1191 
1192   // Call indirectly to solve generation ordering problem
1193   AddressLiteral a(StubRoutines::verify_oop_subroutine_entry_address());
1194 
1195   // Make some space on stack above the current register window.
1196   // Enough to hold 8 64-bit registers.
1197   add(SP,-8*8,SP);
1198 
1199   // Save some 64-bit registers; a normal &#39;save&#39; chops the heads off
1200   // of 64-bit longs in the 32-bit build.
1201   stx(O0,SP,frame::register_save_words*wordSize+STACK_BIAS+0*8);
1202   stx(O1,SP,frame::register_save_words*wordSize+STACK_BIAS+1*8);
1203   ld_ptr(addr.base(), addr.disp() + 8*8, O0); // Load arg into O0; arg might be in O7 which is about to be crushed
1204   stx(O7,SP,frame::register_save_words*wordSize+STACK_BIAS+7*8);
1205 
1206   // Size of set() should stay the same
1207   patchable_set((intptr_t)real_msg, O1);
1208   // Load address to call to into O7
1209   load_ptr_contents(a, O7);
1210   // Register call to verify_oop_subroutine
1211   callr(O7, G0);
1212   delayed()-&gt;nop();
1213   // recover frame size
1214   add(SP, 8*8,SP);
1215 }
1216 
1217 // side-door communication with signalHandler in os_solaris.cpp
1218 address MacroAssembler::_verify_oop_implicit_branch[3] = { NULL };
1219 
1220 // This macro is expanded just once; it creates shared code.  Contract:
1221 // receives an oop in O0.  Must restore O0 &amp; O7 from TLS.  Must not smash ANY
1222 // registers, including flags.  May not use a register &#39;save&#39;, as this blows
1223 // the high bits of the O-regs if they contain Long values.  Acts as a &#39;leaf&#39;
1224 // call.
1225 void MacroAssembler::verify_oop_subroutine() {
1226   // Leaf call; no frame.
1227   Label succeed, fail, null_or_fail;
1228 
1229   // O0 and O7 were saved already (O0 in O0&#39;s TLS home, O7 in O5&#39;s TLS home).
1230   // O0 is now the oop to be checked.  O7 is the return address.
1231   Register O0_obj = O0;
1232 
1233   // Save some more registers for temps.
1234   stx(O2,SP,frame::register_save_words*wordSize+STACK_BIAS+2*8);
1235   stx(O3,SP,frame::register_save_words*wordSize+STACK_BIAS+3*8);
1236   stx(O4,SP,frame::register_save_words*wordSize+STACK_BIAS+4*8);
1237   stx(O5,SP,frame::register_save_words*wordSize+STACK_BIAS+5*8);
1238 
1239   // Save flags
1240   Register O5_save_flags = O5;
1241   rdccr( O5_save_flags );
1242 
1243   { // count number of verifies
1244     Register O2_adr   = O2;
1245     Register O3_accum = O3;
1246     inc_counter(StubRoutines::verify_oop_count_addr(), O2_adr, O3_accum);
1247   }
1248 
1249   Register O2_mask = O2;
1250   Register O3_bits = O3;
1251   Register O4_temp = O4;
1252 
1253   // mark lower end of faulting range
1254   assert(_verify_oop_implicit_branch[0] == NULL, &quot;set once&quot;);
1255   _verify_oop_implicit_branch[0] = pc();
1256 
1257   // We can&#39;t check the mark oop because it could be in the process of
1258   // locking or unlocking while this is running.
1259   set(Universe::verify_oop_mask (), O2_mask);
1260   set(Universe::verify_oop_bits (), O3_bits);
1261 
1262   // assert((obj &amp; oop_mask) == oop_bits);
1263   and3(O0_obj, O2_mask, O4_temp);
1264   cmp_and_brx_short(O4_temp, O3_bits, notEqual, pn, null_or_fail);
1265 
1266   if ((NULL_WORD &amp; Universe::verify_oop_mask()) == Universe::verify_oop_bits()) {
1267     // the null_or_fail case is useless; must test for null separately
1268     br_null_short(O0_obj, pn, succeed);
1269   }
1270 
1271   // Check the Klass* of this object for being in the right area of memory.
1272   // Cannot do the load in the delay above slot in case O0 is null
1273   load_klass(O0_obj, O0_obj);
1274   // assert((klass != NULL)
1275   br_null_short(O0_obj, pn, fail);
1276 
1277   wrccr( O5_save_flags ); // Restore CCR&#39;s
1278 
1279   // mark upper end of faulting range
1280   _verify_oop_implicit_branch[1] = pc();
1281 
1282   //-----------------------
1283   // all tests pass
1284   bind(succeed);
1285 
1286   // Restore prior 64-bit registers
1287   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+0*8,O0);
1288   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+1*8,O1);
1289   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+2*8,O2);
1290   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+3*8,O3);
1291   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+4*8,O4);
1292   ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+5*8,O5);
1293 
1294   retl();                       // Leaf return; restore prior O7 in delay slot
1295   delayed()-&gt;ldx(SP,frame::register_save_words*wordSize+STACK_BIAS+7*8,O7);
1296 
1297   //-----------------------
1298   bind(null_or_fail);           // nulls are less common but OK
1299   br_null(O0_obj, false, pt, succeed);
1300   delayed()-&gt;wrccr( O5_save_flags ); // Restore CCR&#39;s
1301 
1302   //-----------------------
1303   // report failure:
1304   bind(fail);
1305   _verify_oop_implicit_branch[2] = pc();
1306 
1307   wrccr( O5_save_flags ); // Restore CCR&#39;s
1308 
1309   save_frame(align_up(sizeof(RegistersForDebugging) / BytesPerWord, 2));
1310 
1311   // stop_subroutine expects message pointer in I1.
1312   mov(I1, O1);
1313 
1314   // Restore prior 64-bit registers
1315   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+0*8,I0);
1316   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+1*8,I1);
1317   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+2*8,I2);
1318   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+3*8,I3);
1319   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+4*8,I4);
1320   ldx(FP,frame::register_save_words*wordSize+STACK_BIAS+5*8,I5);
1321 
1322   // factor long stop-sequence into subroutine to save space
1323   assert(StubRoutines::Sparc::stop_subroutine_entry_address(), &quot;hasn&#39;t been generated yet&quot;);
1324 
1325   // call indirectly to solve generation ordering problem
1326   AddressLiteral al(StubRoutines::Sparc::stop_subroutine_entry_address());
1327   load_ptr_contents(al, O5);
1328   jmpl(O5, 0, O7);
1329   delayed()-&gt;nop();
1330 }
1331 
1332 
1333 void MacroAssembler::stop(const char* msg) {
1334   // save frame first to get O7 for return address
1335   // add one word to size in case struct is odd number of words long
1336   // It must be doubleword-aligned for storing doubles into it.
1337 
1338     save_frame(align_up(sizeof(RegistersForDebugging) / BytesPerWord, 2));
1339 
1340     // stop_subroutine expects message pointer in I1.
1341     // Size of set() should stay the same
1342     patchable_set((intptr_t)msg, O1);
1343 
1344     // factor long stop-sequence into subroutine to save space
1345     assert(StubRoutines::Sparc::stop_subroutine_entry_address(), &quot;hasn&#39;t been generated yet&quot;);
1346 
1347     // call indirectly to solve generation ordering problem
1348     AddressLiteral a(StubRoutines::Sparc::stop_subroutine_entry_address());
1349     load_ptr_contents(a, O5);
1350     jmpl(O5, 0, O7);
1351     delayed()-&gt;nop();
1352 
1353     breakpoint_trap();   // make stop actually stop rather than writing
1354                          // unnoticeable results in the output files.
1355 
1356     // restore(); done in callee to save space!
1357 }
1358 
1359 
1360 void MacroAssembler::warn(const char* msg) {
1361   save_frame(align_up(sizeof(RegistersForDebugging) / BytesPerWord, 2));
1362   RegistersForDebugging::save_registers(this);
1363   mov(O0, L0);
1364   // Size of set() should stay the same
1365   patchable_set((intptr_t)msg, O0);
1366   call( CAST_FROM_FN_PTR(address, warning) );
1367   delayed()-&gt;nop();
1368 //  ret();
1369 //  delayed()-&gt;restore();
1370   RegistersForDebugging::restore_registers(this, L0);
1371   restore();
1372 }
1373 
1374 
1375 void MacroAssembler::untested(const char* what) {
1376   // We must be able to turn interactive prompting off
1377   // in order to run automated test scripts on the VM
1378   // Use the flag ShowMessageBoxOnError
1379 
1380   const char* b = NULL;
1381   {
1382     ResourceMark rm;
1383     stringStream ss;
1384     ss.print(&quot;untested: %s&quot;, what);
1385     b = code_string(ss.as_string());
1386   }
1387   if (ShowMessageBoxOnError) { STOP(b); }
1388   else                       { warn(b); }
1389 }
1390 
1391 
1392 void MacroAssembler::unimplemented(const char* what) {
1393   const char* buf = NULL;
1394   {
1395     ResourceMark rm;
1396     stringStream ss;
1397     ss.print(&quot;unimplemented: %s&quot;, what);
1398     buf = code_string(ss.as_string());
1399   }
1400   stop(buf);
1401 }
1402 
1403 
1404 void MacroAssembler::stop_subroutine() {
1405   RegistersForDebugging::save_registers(this);
1406 
1407   // for the sake of the debugger, stick a PC on the current frame
1408   // (this assumes that the caller has performed an extra &quot;save&quot;)
1409   mov(I7, L7);
1410   add(O7, -7 * BytesPerInt, I7);
1411 
1412   save_frame(); // one more save to free up another O7 register
1413   mov(I0, O1); // addr of reg save area
1414 
1415   // We expect pointer to message in I1. Caller must set it up in O1
1416   mov(I1, O0); // get msg
1417   call (CAST_FROM_FN_PTR(address, MacroAssembler::debug), relocInfo::runtime_call_type);
1418   delayed()-&gt;nop();
1419 
1420   restore();
1421 
1422   RegistersForDebugging::restore_registers(this, O0);
1423 
1424   save_frame(0);
1425   call(CAST_FROM_FN_PTR(address,breakpoint));
1426   delayed()-&gt;nop();
1427   restore();
1428 
1429   mov(L7, I7);
1430   retl();
1431   delayed()-&gt;restore(); // see stop above
1432 }
1433 
1434 
1435 void MacroAssembler::debug(char* msg, RegistersForDebugging* regs) {
1436   if ( ShowMessageBoxOnError ) {
1437     JavaThread* thread = JavaThread::current();
1438     JavaThreadState saved_state = thread-&gt;thread_state();
1439     thread-&gt;set_thread_state(_thread_in_vm);
1440       {
1441         // In order to get locks work, we need to fake a in_VM state
1442         ttyLocker ttyl;
1443         ::tty-&gt;print_cr(&quot;EXECUTION STOPPED: %s\n&quot;, msg);
1444         if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
1445         BytecodeCounter::print();
1446         }
1447         if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;))
1448           regs-&gt;print(::tty);
1449       }
1450     BREAKPOINT;
1451       ThreadStateTransition::transition(JavaThread::current(), _thread_in_vm, saved_state);
1452   }
1453   else {
1454      ::tty-&gt;print_cr(&quot;=============== DEBUG MESSAGE: %s ================\n&quot;, msg);
1455   }
1456   assert(false, &quot;DEBUG MESSAGE: %s&quot;, msg);
1457 }
1458 
1459 
1460 void MacroAssembler::calc_mem_param_words(Register Rparam_words, Register Rresult) {
1461   subcc( Rparam_words, Argument::n_register_parameters, Rresult); // how many mem words?
1462   Label no_extras;
1463   br( negative, true, pt, no_extras ); // if neg, clear reg
1464   delayed()-&gt;set(0, Rresult);          // annuled, so only if taken
1465   bind( no_extras );
1466 }
1467 
1468 
1469 void MacroAssembler::calc_frame_size(Register Rextra_words, Register Rresult) {
1470   add(Rextra_words, frame::memory_parameter_word_sp_offset, Rresult);
1471   bclr(1, Rresult);
1472   sll(Rresult, LogBytesPerWord, Rresult);  // Rresult has total frame bytes
1473 }
1474 
1475 
1476 void MacroAssembler::calc_frame_size_and_save(Register Rextra_words, Register Rresult) {
1477   calc_frame_size(Rextra_words, Rresult);
1478   neg(Rresult);
1479   save(SP, Rresult, SP);
1480 }
1481 
1482 
1483 // ---------------------------------------------------------
1484 Assembler::RCondition cond2rcond(Assembler::Condition c) {
1485   switch (c) {
1486     /*case zero: */
1487     case Assembler::equal:        return Assembler::rc_z;
1488     case Assembler::lessEqual:    return Assembler::rc_lez;
1489     case Assembler::less:         return Assembler::rc_lz;
1490     /*case notZero:*/
1491     case Assembler::notEqual:     return Assembler::rc_nz;
1492     case Assembler::greater:      return Assembler::rc_gz;
1493     case Assembler::greaterEqual: return Assembler::rc_gez;
1494   }
1495   ShouldNotReachHere();
1496   return Assembler::rc_z;
1497 }
1498 
1499 // compares (32 bit) register with zero and branches.  NOT FOR USE WITH 64-bit POINTERS
1500 void MacroAssembler::cmp_zero_and_br(Condition c, Register s1, Label&amp; L, bool a, Predict p) {
1501   tst(s1);
1502   br (c, a, p, L);
1503 }
1504 
1505 // Compares a pointer register with zero and branches on null.
1506 // Does a test &amp; branch on 32-bit systems and a register-branch on 64-bit.
1507 void MacroAssembler::br_null( Register s1, bool a, Predict p, Label&amp; L ) {
1508   assert_not_delayed();
1509   bpr( rc_z, a, p, s1, L );
1510 }
1511 
1512 void MacroAssembler::br_notnull( Register s1, bool a, Predict p, Label&amp; L ) {
1513   assert_not_delayed();
1514   bpr( rc_nz, a, p, s1, L );
1515 }
1516 
1517 // Compare registers and branch with nop in delay slot or cbcond without delay slot.
1518 
1519 // Compare integer (32 bit) values (icc only).
1520 void MacroAssembler::cmp_and_br_short(Register s1, Register s2, Condition c,
1521                                       Predict p, Label&amp; L) {
1522   assert_not_delayed();
1523   if (use_cbcond(L)) {
1524     Assembler::cbcond(c, icc, s1, s2, L);
1525   } else {
1526     cmp(s1, s2);
1527     br(c, false, p, L);
1528     delayed()-&gt;nop();
1529   }
1530 }
1531 
1532 // Compare integer (32 bit) values (icc only).
1533 void MacroAssembler::cmp_and_br_short(Register s1, int simm13a, Condition c,
1534                                       Predict p, Label&amp; L) {
1535   assert_not_delayed();
1536   if (is_simm(simm13a,5) &amp;&amp; use_cbcond(L)) {
1537     Assembler::cbcond(c, icc, s1, simm13a, L);
1538   } else {
1539     cmp(s1, simm13a);
1540     br(c, false, p, L);
1541     delayed()-&gt;nop();
1542   }
1543 }
1544 
1545 // Branch that tests xcc in LP64 and icc in !LP64
1546 void MacroAssembler::cmp_and_brx_short(Register s1, Register s2, Condition c,
1547                                        Predict p, Label&amp; L) {
1548   assert_not_delayed();
1549   if (use_cbcond(L)) {
1550     Assembler::cbcond(c, ptr_cc, s1, s2, L);
1551   } else {
1552     cmp(s1, s2);
1553     brx(c, false, p, L);
1554     delayed()-&gt;nop();
1555   }
1556 }
1557 
1558 // Branch that tests xcc in LP64 and icc in !LP64
1559 void MacroAssembler::cmp_and_brx_short(Register s1, int simm13a, Condition c,
1560                                        Predict p, Label&amp; L) {
1561   assert_not_delayed();
1562   if (is_simm(simm13a,5) &amp;&amp; use_cbcond(L)) {
1563     Assembler::cbcond(c, ptr_cc, s1, simm13a, L);
1564   } else {
1565     cmp(s1, simm13a);
1566     brx(c, false, p, L);
1567     delayed()-&gt;nop();
1568   }
1569 }
1570 
1571 // Short branch version for compares a pointer with zero.
1572 
1573 void MacroAssembler::br_null_short(Register s1, Predict p, Label&amp; L) {
1574   assert_not_delayed();
1575   if (use_cbcond(L)) {
1576     Assembler::cbcond(zero, ptr_cc, s1, 0, L);
1577   } else {
1578     br_null(s1, false, p, L);
1579     delayed()-&gt;nop();
1580   }
1581 }
1582 
1583 void MacroAssembler::br_notnull_short(Register s1, Predict p, Label&amp; L) {
1584   assert_not_delayed();
1585   if (use_cbcond(L)) {
1586     Assembler::cbcond(notZero, ptr_cc, s1, 0, L);
1587   } else {
1588     br_notnull(s1, false, p, L);
1589     delayed()-&gt;nop();
1590   }
1591 }
1592 
1593 // Unconditional short branch
1594 void MacroAssembler::ba_short(Label&amp; L) {
1595   assert_not_delayed();
1596   if (use_cbcond(L)) {
1597     Assembler::cbcond(equal, icc, G0, G0, L);
1598   } else {
1599     br(always, false, pt, L);
1600     delayed()-&gt;nop();
1601   }
1602 }
1603 
1604 // Branch if &#39;icc&#39; says zero or not (i.e. icc.z == 1|0).
1605 
1606 void MacroAssembler::br_icc_zero(bool iszero, Predict p, Label &amp;L) {
1607   assert_not_delayed();
1608   Condition cf = (iszero ? Assembler::zero : Assembler::notZero);
1609   br(cf, false, p, L);
1610   delayed()-&gt;nop();
1611 }
1612 
1613 // instruction sequences factored across compiler &amp; interpreter
1614 
1615 
1616 void MacroAssembler::lcmp( Register Ra_hi, Register Ra_low,
1617                            Register Rb_hi, Register Rb_low,
1618                            Register Rresult) {
1619 
1620   Label check_low_parts, done;
1621 
1622   cmp(Ra_hi, Rb_hi );  // compare hi parts
1623   br(equal, true, pt, check_low_parts);
1624   delayed()-&gt;cmp(Ra_low, Rb_low); // test low parts
1625 
1626   // And, with an unsigned comparison, it does not matter if the numbers
1627   // are negative or not.
1628   // E.g., -2 cmp -1: the low parts are 0xfffffffe and 0xffffffff.
1629   // The second one is bigger (unsignedly).
1630 
1631   // Other notes:  The first move in each triplet can be unconditional
1632   // (and therefore probably prefetchable).
1633   // And the equals case for the high part does not need testing,
1634   // since that triplet is reached only after finding the high halves differ.
1635 
1636   mov(-1, Rresult);
1637   ba(done);
1638   delayed()-&gt;movcc(greater, false, icc,  1, Rresult);
1639 
1640   bind(check_low_parts);
1641 
1642   mov(                               -1, Rresult);
1643   movcc(equal,           false, icc,  0, Rresult);
1644   movcc(greaterUnsigned, false, icc,  1, Rresult);
1645 
1646   bind(done);
1647 }
1648 
1649 void MacroAssembler::lneg( Register Rhi, Register Rlow ) {
1650   subcc(  G0, Rlow, Rlow );
1651   subc(   G0, Rhi,  Rhi  );
1652 }
1653 
1654 void MacroAssembler::lshl( Register Rin_high,  Register Rin_low,
1655                            Register Rcount,
1656                            Register Rout_high, Register Rout_low,
1657                            Register Rtemp ) {
1658 
1659 
1660   Register Ralt_count = Rtemp;
1661   Register Rxfer_bits = Rtemp;
1662 
1663   assert( Ralt_count != Rin_high
1664       &amp;&amp;  Ralt_count != Rin_low
1665       &amp;&amp;  Ralt_count != Rcount
1666       &amp;&amp;  Rxfer_bits != Rin_low
1667       &amp;&amp;  Rxfer_bits != Rin_high
1668       &amp;&amp;  Rxfer_bits != Rcount
1669       &amp;&amp;  Rxfer_bits != Rout_low
1670       &amp;&amp;  Rout_low   != Rin_high,
1671         &quot;register alias checks&quot;);
1672 
1673   Label big_shift, done;
1674 
1675   // This code can be optimized to use the 64 bit shifts in V9.
1676   // Here we use the 32 bit shifts.
1677 
1678   and3( Rcount, 0x3f, Rcount);     // take least significant 6 bits
1679   subcc(Rcount,   31, Ralt_count);
1680   br(greater, true, pn, big_shift);
1681   delayed()-&gt;dec(Ralt_count);
1682 
1683   // shift &lt; 32 bits, Ralt_count = Rcount-31
1684 
1685   // We get the transfer bits by shifting right by 32-count the low
1686   // register. This is done by shifting right by 31-count and then by one
1687   // more to take care of the special (rare) case where count is zero
1688   // (shifting by 32 would not work).
1689 
1690   neg(Ralt_count);
1691 
1692   // The order of the next two instructions is critical in the case where
1693   // Rin and Rout are the same and should not be reversed.
1694 
1695   srl(Rin_low, Ralt_count, Rxfer_bits); // shift right by 31-count
1696   if (Rcount != Rout_low) {
1697     sll(Rin_low, Rcount, Rout_low); // low half
1698   }
1699   sll(Rin_high, Rcount, Rout_high);
1700   if (Rcount == Rout_low) {
1701     sll(Rin_low, Rcount, Rout_low); // low half
1702   }
1703   srl(Rxfer_bits, 1, Rxfer_bits ); // shift right by one more
1704   ba(done);
1705   delayed()-&gt;or3(Rout_high, Rxfer_bits, Rout_high);   // new hi value: or in shifted old hi part and xfer from low
1706 
1707   // shift &gt;= 32 bits, Ralt_count = Rcount-32
1708   bind(big_shift);
1709   sll(Rin_low, Ralt_count, Rout_high  );
1710   clr(Rout_low);
1711 
1712   bind(done);
1713 }
1714 
1715 
1716 void MacroAssembler::lshr( Register Rin_high,  Register Rin_low,
1717                            Register Rcount,
1718                            Register Rout_high, Register Rout_low,
1719                            Register Rtemp ) {
1720 
1721   Register Ralt_count = Rtemp;
1722   Register Rxfer_bits = Rtemp;
1723 
1724   assert( Ralt_count != Rin_high
1725       &amp;&amp;  Ralt_count != Rin_low
1726       &amp;&amp;  Ralt_count != Rcount
1727       &amp;&amp;  Rxfer_bits != Rin_low
1728       &amp;&amp;  Rxfer_bits != Rin_high
1729       &amp;&amp;  Rxfer_bits != Rcount
1730       &amp;&amp;  Rxfer_bits != Rout_high
1731       &amp;&amp;  Rout_high  != Rin_low,
1732         &quot;register alias checks&quot;);
1733 
1734   Label big_shift, done;
1735 
1736   // This code can be optimized to use the 64 bit shifts in V9.
1737   // Here we use the 32 bit shifts.
1738 
1739   and3( Rcount, 0x3f, Rcount);     // take least significant 6 bits
1740   subcc(Rcount,   31, Ralt_count);
1741   br(greater, true, pn, big_shift);
1742   delayed()-&gt;dec(Ralt_count);
1743 
1744   // shift &lt; 32 bits, Ralt_count = Rcount-31
1745 
1746   // We get the transfer bits by shifting left by 32-count the high
1747   // register. This is done by shifting left by 31-count and then by one
1748   // more to take care of the special (rare) case where count is zero
1749   // (shifting by 32 would not work).
1750 
1751   neg(Ralt_count);
1752   if (Rcount != Rout_low) {
1753     srl(Rin_low, Rcount, Rout_low);
1754   }
1755 
1756   // The order of the next two instructions is critical in the case where
1757   // Rin and Rout are the same and should not be reversed.
1758 
1759   sll(Rin_high, Ralt_count, Rxfer_bits); // shift left by 31-count
1760   sra(Rin_high,     Rcount, Rout_high ); // high half
1761   sll(Rxfer_bits,        1, Rxfer_bits); // shift left by one more
1762   if (Rcount == Rout_low) {
1763     srl(Rin_low, Rcount, Rout_low);
1764   }
1765   ba(done);
1766   delayed()-&gt;or3(Rout_low, Rxfer_bits, Rout_low); // new low value: or shifted old low part and xfer from high
1767 
1768   // shift &gt;= 32 bits, Ralt_count = Rcount-32
1769   bind(big_shift);
1770 
1771   sra(Rin_high, Ralt_count, Rout_low);
1772   sra(Rin_high,         31, Rout_high); // sign into hi
1773 
1774   bind( done );
1775 }
1776 
1777 
1778 
1779 void MacroAssembler::lushr( Register Rin_high,  Register Rin_low,
1780                             Register Rcount,
1781                             Register Rout_high, Register Rout_low,
1782                             Register Rtemp ) {
1783 
1784   Register Ralt_count = Rtemp;
1785   Register Rxfer_bits = Rtemp;
1786 
1787   assert( Ralt_count != Rin_high
1788       &amp;&amp;  Ralt_count != Rin_low
1789       &amp;&amp;  Ralt_count != Rcount
1790       &amp;&amp;  Rxfer_bits != Rin_low
1791       &amp;&amp;  Rxfer_bits != Rin_high
1792       &amp;&amp;  Rxfer_bits != Rcount
1793       &amp;&amp;  Rxfer_bits != Rout_high
1794       &amp;&amp;  Rout_high  != Rin_low,
1795         &quot;register alias checks&quot;);
1796 
1797   Label big_shift, done;
1798 
1799   // This code can be optimized to use the 64 bit shifts in V9.
1800   // Here we use the 32 bit shifts.
1801 
1802   and3( Rcount, 0x3f, Rcount);     // take least significant 6 bits
1803   subcc(Rcount,   31, Ralt_count);
1804   br(greater, true, pn, big_shift);
1805   delayed()-&gt;dec(Ralt_count);
1806 
1807   // shift &lt; 32 bits, Ralt_count = Rcount-31
1808 
1809   // We get the transfer bits by shifting left by 32-count the high
1810   // register. This is done by shifting left by 31-count and then by one
1811   // more to take care of the special (rare) case where count is zero
1812   // (shifting by 32 would not work).
1813 
1814   neg(Ralt_count);
1815   if (Rcount != Rout_low) {
1816     srl(Rin_low, Rcount, Rout_low);
1817   }
1818 
1819   // The order of the next two instructions is critical in the case where
1820   // Rin and Rout are the same and should not be reversed.
1821 
1822   sll(Rin_high, Ralt_count, Rxfer_bits); // shift left by 31-count
1823   srl(Rin_high,     Rcount, Rout_high ); // high half
1824   sll(Rxfer_bits,        1, Rxfer_bits); // shift left by one more
1825   if (Rcount == Rout_low) {
1826     srl(Rin_low, Rcount, Rout_low);
1827   }
1828   ba(done);
1829   delayed()-&gt;or3(Rout_low, Rxfer_bits, Rout_low); // new low value: or shifted old low part and xfer from high
1830 
1831   // shift &gt;= 32 bits, Ralt_count = Rcount-32
1832   bind(big_shift);
1833 
1834   srl(Rin_high, Ralt_count, Rout_low);
1835   clr(Rout_high);
1836 
1837   bind( done );
1838 }
1839 
1840 void MacroAssembler::lcmp( Register Ra, Register Rb, Register Rresult) {
1841   cmp(Ra, Rb);
1842   mov(-1, Rresult);
1843   movcc(equal,   false, xcc,  0, Rresult);
1844   movcc(greater, false, xcc,  1, Rresult);
1845 }
1846 
1847 
1848 void MacroAssembler::load_sized_value(Address src, Register dst, size_t size_in_bytes, bool is_signed) {
1849   switch (size_in_bytes) {
1850   case  8:  ld_long(src, dst); break;
1851   case  4:  ld(     src, dst); break;
1852   case  2:  is_signed ? ldsh(src, dst) : lduh(src, dst); break;
1853   case  1:  is_signed ? ldsb(src, dst) : ldub(src, dst); break;
1854   default:  ShouldNotReachHere();
1855   }
1856 }
1857 
1858 void MacroAssembler::store_sized_value(Register src, Address dst, size_t size_in_bytes) {
1859   switch (size_in_bytes) {
1860   case  8:  st_long(src, dst); break;
1861   case  4:  st(     src, dst); break;
1862   case  2:  sth(    src, dst); break;
1863   case  1:  stb(    src, dst); break;
1864   default:  ShouldNotReachHere();
1865   }
1866 }
1867 
1868 
1869 void MacroAssembler::float_cmp( bool is_float, int unordered_result,
1870                                 FloatRegister Fa, FloatRegister Fb,
1871                                 Register Rresult) {
1872   if (is_float) {
1873     fcmp(FloatRegisterImpl::S, fcc0, Fa, Fb);
1874   } else {
1875     fcmp(FloatRegisterImpl::D, fcc0, Fa, Fb);
1876   }
1877 
1878   if (unordered_result == 1) {
1879     mov(                                    -1, Rresult);
1880     movcc(f_equal,              true, fcc0,  0, Rresult);
1881     movcc(f_unorderedOrGreater, true, fcc0,  1, Rresult);
1882   } else {
1883     mov(                                    -1, Rresult);
1884     movcc(f_equal,              true, fcc0,  0, Rresult);
1885     movcc(f_greater,            true, fcc0,  1, Rresult);
1886   }
1887 }
1888 
1889 
1890 void MacroAssembler::save_all_globals_into_locals() {
1891   mov(G1,L1);
1892   mov(G2,L2);
1893   mov(G3,L3);
1894   mov(G4,L4);
1895   mov(G5,L5);
1896   mov(G6,L6);
1897   mov(G7,L7);
1898 }
1899 
1900 void MacroAssembler::restore_globals_from_locals() {
1901   mov(L1,G1);
1902   mov(L2,G2);
1903   mov(L3,G3);
1904   mov(L4,G4);
1905   mov(L5,G5);
1906   mov(L6,G6);
1907   mov(L7,G7);
1908 }
1909 
1910 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
1911                                                       Register tmp,
1912                                                       int offset) {
1913   intptr_t value = *delayed_value_addr;
1914   if (value != 0)
1915     return RegisterOrConstant(value + offset);
1916 
1917   // load indirectly to solve generation ordering problem
1918   AddressLiteral a(delayed_value_addr);
1919   load_ptr_contents(a, tmp);
1920 
1921 #ifdef ASSERT
1922   tst(tmp);
1923   breakpoint_trap(zero, xcc);
1924 #endif
1925 
1926   if (offset != 0)
1927     add(tmp, offset, tmp);
1928 
1929   return RegisterOrConstant(tmp);
1930 }
1931 
1932 
1933 RegisterOrConstant MacroAssembler::regcon_andn_ptr(RegisterOrConstant s1, RegisterOrConstant s2, RegisterOrConstant d, Register temp) {
1934   assert(d.register_or_noreg() != G0, &quot;lost side effect&quot;);
1935   if ((s2.is_constant() &amp;&amp; s2.as_constant() == 0) ||
1936       (s2.is_register() &amp;&amp; s2.as_register() == G0)) {
1937     // Do nothing, just move value.
1938     if (s1.is_register()) {
1939       if (d.is_constant())  d = temp;
1940       mov(s1.as_register(), d.as_register());
1941       return d;
1942     } else {
1943       return s1;
1944     }
1945   }
1946 
1947   if (s1.is_register()) {
1948     assert_different_registers(s1.as_register(), temp);
1949     if (d.is_constant())  d = temp;
1950     andn(s1.as_register(), ensure_simm13_or_reg(s2, temp), d.as_register());
1951     return d;
1952   } else {
1953     if (s2.is_register()) {
1954       assert_different_registers(s2.as_register(), temp);
1955       if (d.is_constant())  d = temp;
1956       set(s1.as_constant(), temp);
1957       andn(temp, s2.as_register(), d.as_register());
1958       return d;
1959     } else {
1960       intptr_t res = s1.as_constant() &amp; ~s2.as_constant();
1961       return res;
1962     }
1963   }
1964 }
1965 
1966 RegisterOrConstant MacroAssembler::regcon_inc_ptr(RegisterOrConstant s1, RegisterOrConstant s2, RegisterOrConstant d, Register temp) {
1967   assert(d.register_or_noreg() != G0, &quot;lost side effect&quot;);
1968   if ((s2.is_constant() &amp;&amp; s2.as_constant() == 0) ||
1969       (s2.is_register() &amp;&amp; s2.as_register() == G0)) {
1970     // Do nothing, just move value.
1971     if (s1.is_register()) {
1972       if (d.is_constant())  d = temp;
1973       mov(s1.as_register(), d.as_register());
1974       return d;
1975     } else {
1976       return s1;
1977     }
1978   }
1979 
1980   if (s1.is_register()) {
1981     assert_different_registers(s1.as_register(), temp);
1982     if (d.is_constant())  d = temp;
1983     add(s1.as_register(), ensure_simm13_or_reg(s2, temp), d.as_register());
1984     return d;
1985   } else {
1986     if (s2.is_register()) {
1987       assert_different_registers(s2.as_register(), temp);
1988       if (d.is_constant())  d = temp;
1989       add(s2.as_register(), ensure_simm13_or_reg(s1, temp), d.as_register());
1990       return d;
1991     } else {
1992       intptr_t res = s1.as_constant() + s2.as_constant();
1993       return res;
1994     }
1995   }
1996 }
1997 
1998 RegisterOrConstant MacroAssembler::regcon_sll_ptr(RegisterOrConstant s1, RegisterOrConstant s2, RegisterOrConstant d, Register temp) {
1999   assert(d.register_or_noreg() != G0, &quot;lost side effect&quot;);
2000   if (!is_simm13(s2.constant_or_zero()))
2001     s2 = (s2.as_constant() &amp; 0xFF);
2002   if ((s2.is_constant() &amp;&amp; s2.as_constant() == 0) ||
2003       (s2.is_register() &amp;&amp; s2.as_register() == G0)) {
2004     // Do nothing, just move value.
2005     if (s1.is_register()) {
2006       if (d.is_constant())  d = temp;
2007       mov(s1.as_register(), d.as_register());
2008       return d;
2009     } else {
2010       return s1;
2011     }
2012   }
2013 
2014   if (s1.is_register()) {
2015     assert_different_registers(s1.as_register(), temp);
2016     if (d.is_constant())  d = temp;
2017     sll_ptr(s1.as_register(), ensure_simm13_or_reg(s2, temp), d.as_register());
2018     return d;
2019   } else {
2020     if (s2.is_register()) {
2021       assert_different_registers(s2.as_register(), temp);
2022       if (d.is_constant())  d = temp;
2023       set(s1.as_constant(), temp);
2024       sll_ptr(temp, s2.as_register(), d.as_register());
2025       return d;
2026     } else {
2027       intptr_t res = s1.as_constant() &lt;&lt; s2.as_constant();
2028       return res;
2029     }
2030   }
2031 }
2032 
2033 
2034 // Look up the method for a megamorphic invokeinterface call.
2035 // The target method is determined by &lt;intf_klass, itable_index&gt;.
2036 // The receiver klass is in recv_klass.
2037 // On success, the result will be in method_result, and execution falls through.
2038 // On failure, execution transfers to the given label.
2039 void MacroAssembler::lookup_interface_method(Register recv_klass,
2040                                              Register intf_klass,
2041                                              RegisterOrConstant itable_index,
2042                                              Register method_result,
2043                                              Register scan_temp,
2044                                              Register sethi_temp,
2045                                              Label&amp; L_no_such_interface,
2046                                              bool return_method) {
2047   assert_different_registers(recv_klass, intf_klass, method_result, scan_temp);
2048   assert(!return_method || itable_index.is_constant() || itable_index.as_register() == method_result,
2049          &quot;caller must use same register for non-constant itable index as for method&quot;);
2050 
2051   Label L_no_such_interface_restore;
2052   bool did_save = false;
2053   if (scan_temp == noreg || sethi_temp == noreg) {
2054     Register recv_2 = recv_klass-&gt;is_global() ? recv_klass : L0;
2055     Register intf_2 = intf_klass-&gt;is_global() ? intf_klass : L1;
2056     assert(method_result-&gt;is_global(), &quot;must be able to return value&quot;);
2057     scan_temp  = L2;
2058     sethi_temp = L3;
2059     save_frame_and_mov(0, recv_klass, recv_2, intf_klass, intf_2);
2060     recv_klass = recv_2;
2061     intf_klass = intf_2;
2062     did_save = true;
2063   }
2064 
2065   // Compute start of first itableOffsetEntry (which is at the end of the vtable)
2066   int vtable_base = in_bytes(Klass::vtable_start_offset());
2067   int scan_step   = itableOffsetEntry::size() * wordSize;
2068   int vte_size    = vtableEntry::size_in_bytes();
2069 
2070   lduw(recv_klass, in_bytes(Klass::vtable_length_offset()), scan_temp);
2071   // %%% We should store the aligned, prescaled offset in the klassoop.
2072   // Then the next several instructions would fold away.
2073 
2074   int itb_offset = vtable_base;
2075   int itb_scale = exact_log2(vtableEntry::size_in_bytes());
2076   sll(scan_temp, itb_scale,  scan_temp);
2077   add(scan_temp, itb_offset, scan_temp);
2078   add(recv_klass, scan_temp, scan_temp);
2079 
2080   if (return_method) {
2081     // Adjust recv_klass by scaled itable_index, so we can free itable_index.
2082     RegisterOrConstant itable_offset = itable_index;
2083     itable_offset = regcon_sll_ptr(itable_index, exact_log2(itableMethodEntry::size() * wordSize), itable_offset);
2084     itable_offset = regcon_inc_ptr(itable_offset, itableMethodEntry::method_offset_in_bytes(), itable_offset);
2085     add(recv_klass, ensure_simm13_or_reg(itable_offset, sethi_temp), recv_klass);
2086   }
2087 
2088   // for (scan = klass-&gt;itable(); scan-&gt;interface() != NULL; scan += scan_step) {
2089   //   if (scan-&gt;interface() == intf) {
2090   //     result = (klass + scan-&gt;offset() + itable_index);
2091   //   }
2092   // }
2093   Label L_search, L_found_method;
2094 
2095   for (int peel = 1; peel &gt;= 0; peel--) {
2096     // %%%% Could load both offset and interface in one ldx, if they were
2097     // in the opposite order.  This would save a load.
2098     ld_ptr(scan_temp, itableOffsetEntry::interface_offset_in_bytes(), method_result);
2099 
2100     // Check that this entry is non-null.  A null entry means that
2101     // the receiver class doesn&#39;t implement the interface, and wasn&#39;t the
2102     // same as when the caller was compiled.
2103     bpr(Assembler::rc_z, false, Assembler::pn, method_result, did_save ? L_no_such_interface_restore : L_no_such_interface);
2104     delayed()-&gt;cmp(method_result, intf_klass);
2105 
2106     if (peel) {
2107       brx(Assembler::equal,    false, Assembler::pt, L_found_method);
2108     } else {
2109       brx(Assembler::notEqual, false, Assembler::pn, L_search);
2110       // (invert the test to fall through to found_method...)
2111     }
2112     delayed()-&gt;add(scan_temp, scan_step, scan_temp);
2113 
2114     if (!peel)  break;
2115 
2116     bind(L_search);
2117   }
2118 
2119   bind(L_found_method);
2120 
2121   if (return_method) {
2122     // Got a hit.
2123     int ito_offset = itableOffsetEntry::offset_offset_in_bytes();
2124     // scan_temp[-scan_step] points to the vtable offset we need
2125     ito_offset -= scan_step;
2126     lduw(scan_temp, ito_offset, scan_temp);
2127     ld_ptr(recv_klass, scan_temp, method_result);
2128   }
2129 
2130   if (did_save) {
2131     Label L_done;
2132     ba(L_done);
2133     delayed()-&gt;restore();
2134 
2135     bind(L_no_such_interface_restore);
2136     ba(L_no_such_interface);
2137     delayed()-&gt;restore();
2138 
2139     bind(L_done);
2140   }
2141 }
2142 
2143 
2144 // virtual method calling
2145 void MacroAssembler::lookup_virtual_method(Register recv_klass,
2146                                            RegisterOrConstant vtable_index,
2147                                            Register method_result) {
2148   assert_different_registers(recv_klass, method_result, vtable_index.register_or_noreg());
2149   Register sethi_temp = method_result;
2150   const int base = in_bytes(Klass::vtable_start_offset()) +
2151                    // method pointer offset within the vtable entry:
2152                    vtableEntry::method_offset_in_bytes();
2153   RegisterOrConstant vtable_offset = vtable_index;
2154   // Each of the following three lines potentially generates an instruction.
2155   // But the total number of address formation instructions will always be
2156   // at most two, and will often be zero.  In any case, it will be optimal.
2157   // If vtable_index is a register, we will have (sll_ptr N,x; inc_ptr B,x; ld_ptr k,x).
2158   // If vtable_index is a constant, we will have at most (set B+X&lt;&lt;N,t; ld_ptr k,t).
2159   vtable_offset = regcon_sll_ptr(vtable_index, exact_log2(vtableEntry::size_in_bytes()), vtable_offset);
2160   vtable_offset = regcon_inc_ptr(vtable_offset, base, vtable_offset, sethi_temp);
2161   Address vtable_entry_addr(recv_klass, ensure_simm13_or_reg(vtable_offset, sethi_temp));
2162   ld_ptr(vtable_entry_addr, method_result);
2163 }
2164 
2165 
2166 void MacroAssembler::check_klass_subtype(Register sub_klass,
2167                                          Register super_klass,
2168                                          Register temp_reg,
2169                                          Register temp2_reg,
2170                                          Label&amp; L_success) {
2171   Register sub_2 = sub_klass;
2172   Register sup_2 = super_klass;
2173   if (!sub_2-&gt;is_global())  sub_2 = L0;
2174   if (!sup_2-&gt;is_global())  sup_2 = L1;
2175   bool did_save = false;
2176   if (temp_reg == noreg || temp2_reg == noreg) {
2177     temp_reg = L2;
2178     temp2_reg = L3;
2179     save_frame_and_mov(0, sub_klass, sub_2, super_klass, sup_2);
2180     sub_klass = sub_2;
2181     super_klass = sup_2;
2182     did_save = true;
2183   }
2184   Label L_failure, L_pop_to_failure, L_pop_to_success;
2185   check_klass_subtype_fast_path(sub_klass, super_klass,
2186                                 temp_reg, temp2_reg,
2187                                 (did_save ? &amp;L_pop_to_success : &amp;L_success),
2188                                 (did_save ? &amp;L_pop_to_failure : &amp;L_failure), NULL);
2189 
2190   if (!did_save)
2191     save_frame_and_mov(0, sub_klass, sub_2, super_klass, sup_2);
2192   check_klass_subtype_slow_path(sub_2, sup_2,
2193                                 L2, L3, L4, L5,
2194                                 NULL, &amp;L_pop_to_failure);
2195 
2196   // on success:
2197   bind(L_pop_to_success);
2198   restore();
2199   ba_short(L_success);
2200 
2201   // on failure:
2202   bind(L_pop_to_failure);
2203   restore();
2204   bind(L_failure);
2205 }
2206 
2207 
2208 void MacroAssembler::check_klass_subtype_fast_path(Register sub_klass,
2209                                                    Register super_klass,
2210                                                    Register temp_reg,
2211                                                    Register temp2_reg,
2212                                                    Label* L_success,
2213                                                    Label* L_failure,
2214                                                    Label* L_slow_path,
2215                                         RegisterOrConstant super_check_offset) {
2216   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
2217   int sco_offset = in_bytes(Klass::super_check_offset_offset());
2218 
2219   bool must_load_sco  = (super_check_offset.constant_or_zero() == -1);
2220   bool need_slow_path = (must_load_sco ||
2221                          super_check_offset.constant_or_zero() == sco_offset);
2222 
2223   assert_different_registers(sub_klass, super_klass, temp_reg);
2224   if (super_check_offset.is_register()) {
2225     assert_different_registers(sub_klass, super_klass, temp_reg,
2226                                super_check_offset.as_register());
2227   } else if (must_load_sco) {
2228     assert(temp2_reg != noreg, &quot;supply either a temp or a register offset&quot;);
2229   }
2230 
2231   Label L_fallthrough;
2232   int label_nulls = 0;
2233   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
2234   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
2235   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
2236   assert(label_nulls &lt;= 1 ||
2237          (L_slow_path == &amp;L_fallthrough &amp;&amp; label_nulls &lt;= 2 &amp;&amp; !need_slow_path),
2238          &quot;at most one NULL in the batch, usually&quot;);
2239 
2240   // If the pointers are equal, we are done (e.g., String[] elements).
2241   // This self-check enables sharing of secondary supertype arrays among
2242   // non-primary types such as array-of-interface.  Otherwise, each such
2243   // type would need its own customized SSA.
2244   // We move this check to the front of the fast path because many
2245   // type checks are in fact trivially successful in this manner,
2246   // so we get a nicely predicted branch right at the start of the check.
2247   cmp(super_klass, sub_klass);
2248   brx(Assembler::equal, false, Assembler::pn, *L_success);
2249   delayed()-&gt;nop();
2250 
2251   // Check the supertype display:
2252   if (must_load_sco) {
2253     // The super check offset is always positive...
2254     lduw(super_klass, sco_offset, temp2_reg);
2255     super_check_offset = RegisterOrConstant(temp2_reg);
2256     // super_check_offset is register.
2257     assert_different_registers(sub_klass, super_klass, temp_reg, super_check_offset.as_register());
2258   }
2259   ld_ptr(sub_klass, super_check_offset, temp_reg);
2260   cmp(super_klass, temp_reg);
2261 
2262   // This check has worked decisively for primary supers.
2263   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
2264   // (Secondary supers are interfaces and very deeply nested subtypes.)
2265   // This works in the same check above because of a tricky aliasing
2266   // between the super_cache and the primary super display elements.
2267   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
2268   // Note that the cache is updated below if it does not help us find
2269   // what we need immediately.
2270   // So if it was a primary super, we can just fail immediately.
2271   // Otherwise, it&#39;s the slow path for us (no success at this point).
2272 
2273   // Hacked ba(), which may only be used just before L_fallthrough.
2274 #define FINAL_JUMP(label)            \
2275   if (&amp;(label) != &amp;L_fallthrough) {  \
2276     ba(label);  delayed()-&gt;nop();    \
2277   }
2278 
2279   if (super_check_offset.is_register()) {
2280     brx(Assembler::equal, false, Assembler::pn, *L_success);
2281     delayed()-&gt;cmp(super_check_offset.as_register(), sc_offset);
2282 
2283     if (L_failure == &amp;L_fallthrough) {
2284       brx(Assembler::equal, false, Assembler::pt, *L_slow_path);
2285       delayed()-&gt;nop();
2286     } else {
2287       brx(Assembler::notEqual, false, Assembler::pn, *L_failure);
2288       delayed()-&gt;nop();
2289       FINAL_JUMP(*L_slow_path);
2290     }
2291   } else if (super_check_offset.as_constant() == sc_offset) {
2292     // Need a slow path; fast failure is impossible.
2293     if (L_slow_path == &amp;L_fallthrough) {
2294       brx(Assembler::equal, false, Assembler::pt, *L_success);
2295       delayed()-&gt;nop();
2296     } else {
2297       brx(Assembler::notEqual, false, Assembler::pn, *L_slow_path);
2298       delayed()-&gt;nop();
2299       FINAL_JUMP(*L_success);
2300     }
2301   } else {
2302     // No slow path; it&#39;s a fast decision.
2303     if (L_failure == &amp;L_fallthrough) {
2304       brx(Assembler::equal, false, Assembler::pt, *L_success);
2305       delayed()-&gt;nop();
2306     } else {
2307       brx(Assembler::notEqual, false, Assembler::pn, *L_failure);
2308       delayed()-&gt;nop();
2309       FINAL_JUMP(*L_success);
2310     }
2311   }
2312 
2313   bind(L_fallthrough);
2314 
2315 #undef FINAL_JUMP
2316 }
2317 
2318 
2319 void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,
2320                                                    Register super_klass,
2321                                                    Register count_temp,
2322                                                    Register scan_temp,
2323                                                    Register scratch_reg,
2324                                                    Register coop_reg,
2325                                                    Label* L_success,
2326                                                    Label* L_failure) {
2327   assert_different_registers(sub_klass, super_klass,
2328                              count_temp, scan_temp, scratch_reg, coop_reg);
2329 
2330   Label L_fallthrough, L_loop;
2331   int label_nulls = 0;
2332   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
2333   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
2334   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
2335 
2336   // a couple of useful fields in sub_klass:
2337   int ss_offset = in_bytes(Klass::secondary_supers_offset());
2338   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
2339 
2340   // Do a linear scan of the secondary super-klass chain.
2341   // This code is rarely used, so simplicity is a virtue here.
2342 
2343 #ifndef PRODUCT
2344   int* pst_counter = &amp;SharedRuntime::_partial_subtype_ctr;
2345   inc_counter((address) pst_counter, count_temp, scan_temp);
2346 #endif
2347 
2348   // We will consult the secondary-super array.
2349   ld_ptr(sub_klass, ss_offset, scan_temp);
2350 
2351   Register search_key = super_klass;
2352 
2353   // Load the array length.  (Positive movl does right thing on LP64.)
2354   lduw(scan_temp, Array&lt;Klass*&gt;::length_offset_in_bytes(), count_temp);
2355 
2356   // Check for empty secondary super list
2357   tst(count_temp);
2358 
2359   // In the array of super classes elements are pointer sized.
2360   int element_size = wordSize;
2361 
2362   // Top of search loop
2363   bind(L_loop);
2364   br(Assembler::equal, false, Assembler::pn, *L_failure);
2365   delayed()-&gt;add(scan_temp, element_size, scan_temp);
2366 
2367   // Skip the array header in all array accesses.
2368   int elem_offset = Array&lt;Klass*&gt;::base_offset_in_bytes();
2369   elem_offset -= element_size;   // the scan pointer was pre-incremented also
2370 
2371   // Load next super to check
2372     ld_ptr( scan_temp, elem_offset, scratch_reg );
2373 
2374   // Look for Rsuper_klass on Rsub_klass&#39;s secondary super-class-overflow list
2375   cmp(scratch_reg, search_key);
2376 
2377   // A miss means we are NOT a subtype and need to keep looping
2378   brx(Assembler::notEqual, false, Assembler::pn, L_loop);
2379   delayed()-&gt;deccc(count_temp); // decrement trip counter in delay slot
2380 
2381   // Success.  Cache the super we found and proceed in triumph.
2382   st_ptr(super_klass, sub_klass, sc_offset);
2383 
2384   if (L_success != &amp;L_fallthrough) {
2385     ba(*L_success);
2386     delayed()-&gt;nop();
2387   }
2388 
2389   bind(L_fallthrough);
2390 }
2391 
2392 
2393 RegisterOrConstant MacroAssembler::argument_offset(RegisterOrConstant arg_slot,
2394                                                    Register temp_reg,
2395                                                    int extra_slot_offset) {
2396   // cf. TemplateTable::prepare_invoke(), if (load_receiver).
2397   int stackElementSize = Interpreter::stackElementSize;
2398   int offset = extra_slot_offset * stackElementSize;
2399   if (arg_slot.is_constant()) {
2400     offset += arg_slot.as_constant() * stackElementSize;
2401     return offset;
2402   } else {
2403     assert(temp_reg != noreg, &quot;must specify&quot;);
2404     sll_ptr(arg_slot.as_register(), exact_log2(stackElementSize), temp_reg);
2405     if (offset != 0)
2406       add(temp_reg, offset, temp_reg);
2407     return temp_reg;
2408   }
2409 }
2410 
2411 
2412 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
2413                                          Register temp_reg,
2414                                          int extra_slot_offset) {
2415   return Address(Gargs, argument_offset(arg_slot, temp_reg, extra_slot_offset));
2416 }
2417 
2418 
2419 void MacroAssembler::biased_locking_enter(Register obj_reg, Register mark_reg,
2420                                           Register temp_reg,
2421                                           Label&amp; done, Label* slow_case,
2422                                           BiasedLockingCounters* counters) {
2423   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
2424 
2425   if (PrintBiasedLockingStatistics) {
2426     assert_different_registers(obj_reg, mark_reg, temp_reg, O7);
2427     if (counters == NULL)
2428       counters = BiasedLocking::counters();
2429   }
2430 
2431   Label cas_label;
2432 
2433   // Biased locking
2434   // See whether the lock is currently biased toward our thread and
2435   // whether the epoch is still valid
2436   // Note that the runtime guarantees sufficient alignment of JavaThread
2437   // pointers to allow age to be placed into low bits
2438   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);
2439   and3(mark_reg, markWord::biased_lock_mask_in_place, temp_reg);
2440   cmp_and_brx_short(temp_reg, markWord::biased_lock_pattern, Assembler::notEqual, Assembler::pn, cas_label);
2441 
2442   load_klass(obj_reg, temp_reg);
2443   ld_ptr(Address(temp_reg, Klass::prototype_header_offset()), temp_reg);
2444   or3(G2_thread, temp_reg, temp_reg);
2445   xor3(mark_reg, temp_reg, temp_reg);
2446   andcc(temp_reg, ~((int) markWord::age_mask_in_place), temp_reg);
2447   if (counters != NULL) {
2448     cond_inc(Assembler::equal, (address) counters-&gt;biased_lock_entry_count_addr(), mark_reg, temp_reg);
2449     // Reload mark_reg as we may need it later
2450     ld_ptr(Address(obj_reg, oopDesc::mark_offset_in_bytes()), mark_reg);
2451   }
2452   brx(Assembler::equal, true, Assembler::pt, done);
2453   delayed()-&gt;nop();
2454 
2455   Label try_revoke_bias;
2456   Label try_rebias;
2457   Address mark_addr = Address(obj_reg, oopDesc::mark_offset_in_bytes());
2458   assert(mark_addr.disp() == 0, &quot;cas must take a zero displacement&quot;);
2459 
2460   // At this point we know that the header has the bias pattern and
2461   // that we are not the bias owner in the current epoch. We need to
2462   // figure out more details about the state of the header in order to
2463   // know what operations can be legally performed on the object&#39;s
2464   // header.
2465 
2466   // If the low three bits in the xor result aren&#39;t clear, that means
2467   // the prototype header is no longer biased and we have to revoke
2468   // the bias on this object.
2469   btst(markWord::biased_lock_mask_in_place, temp_reg);
2470   brx(Assembler::notZero, false, Assembler::pn, try_revoke_bias);
2471 
2472   // Biasing is still enabled for this data type. See whether the
2473   // epoch of the current bias is still valid, meaning that the epoch
2474   // bits of the mark word are equal to the epoch bits of the
2475   // prototype header. (Note that the prototype header&#39;s epoch bits
2476   // only change at a safepoint.) If not, attempt to rebias the object
2477   // toward the current thread. Note that we must be absolutely sure
2478   // that the current epoch is invalid in order to do this because
2479   // otherwise the manipulations it performs on the mark word are
2480   // illegal.
2481   delayed()-&gt;btst(markWord::epoch_mask_in_place, temp_reg);
2482   brx(Assembler::notZero, false, Assembler::pn, try_rebias);
2483 
2484   // The epoch of the current bias is still valid but we know nothing
2485   // about the owner; it might be set or it might be clear. Try to
2486   // acquire the bias of the object using an atomic operation. If this
2487   // fails we will go in to the runtime to revoke the object&#39;s bias.
2488   // Note that we first construct the presumed unbiased header so we
2489   // don&#39;t accidentally blow away another thread&#39;s valid bias.
2490   delayed()-&gt;and3(mark_reg,
2491                   markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place,
2492                   mark_reg);
2493   or3(G2_thread, mark_reg, temp_reg);
2494   cas_ptr(mark_addr.base(), mark_reg, temp_reg);
2495   // If the biasing toward our thread failed, this means that
2496   // another thread succeeded in biasing it toward itself and we
2497   // need to revoke that bias. The revocation will occur in the
2498   // interpreter runtime in the slow case.
2499   cmp(mark_reg, temp_reg);
2500   if (counters != NULL) {
2501     cond_inc(Assembler::zero, (address) counters-&gt;anonymously_biased_lock_entry_count_addr(), mark_reg, temp_reg);
2502   }
2503   if (slow_case != NULL) {
2504     brx(Assembler::notEqual, true, Assembler::pn, *slow_case);
2505     delayed()-&gt;nop();
2506   }
2507   ba_short(done);
2508 
2509   bind(try_rebias);
2510   // At this point we know the epoch has expired, meaning that the
2511   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
2512   // circumstances _only_, we are allowed to use the current header&#39;s
2513   // value as the comparison value when doing the cas to acquire the
2514   // bias in the current epoch. In other words, we allow transfer of
2515   // the bias from one thread to another directly in this situation.
2516   //
2517   // FIXME: due to a lack of registers we currently blow away the age
2518   // bits in this situation. Should attempt to preserve them.
2519   load_klass(obj_reg, temp_reg);
2520   ld_ptr(Address(temp_reg, Klass::prototype_header_offset()), temp_reg);
2521   or3(G2_thread, temp_reg, temp_reg);
2522   cas_ptr(mark_addr.base(), mark_reg, temp_reg);
2523   // If the biasing toward our thread failed, this means that
2524   // another thread succeeded in biasing it toward itself and we
2525   // need to revoke that bias. The revocation will occur in the
2526   // interpreter runtime in the slow case.
2527   cmp(mark_reg, temp_reg);
2528   if (counters != NULL) {
2529     cond_inc(Assembler::zero, (address) counters-&gt;rebiased_lock_entry_count_addr(), mark_reg, temp_reg);
2530   }
2531   if (slow_case != NULL) {
2532     brx(Assembler::notEqual, true, Assembler::pn, *slow_case);
2533     delayed()-&gt;nop();
2534   }
2535   ba_short(done);
2536 
2537   bind(try_revoke_bias);
2538   // The prototype mark in the klass doesn&#39;t have the bias bit set any
2539   // more, indicating that objects of this data type are not supposed
2540   // to be biased any more. We are going to try to reset the mark of
2541   // this object to the prototype value and fall through to the
2542   // CAS-based locking scheme. Note that if our CAS fails, it means
2543   // that another thread raced us for the privilege of revoking the
2544   // bias of this particular object, so it&#39;s okay to continue in the
2545   // normal locking code.
2546   //
2547   // FIXME: due to a lack of registers we currently blow away the age
2548   // bits in this situation. Should attempt to preserve them.
2549   load_klass(obj_reg, temp_reg);
2550   ld_ptr(Address(temp_reg, Klass::prototype_header_offset()), temp_reg);
2551   cas_ptr(mark_addr.base(), mark_reg, temp_reg);
2552   // Fall through to the normal CAS-based lock, because no matter what
2553   // the result of the above CAS, some thread must have succeeded in
2554   // removing the bias bit from the object&#39;s header.
2555   if (counters != NULL) {
2556     cmp(mark_reg, temp_reg);
2557     cond_inc(Assembler::zero, (address) counters-&gt;revoked_lock_entry_count_addr(), mark_reg, temp_reg);
2558   }
2559 
2560   bind(cas_label);
2561 }
2562 
2563 void MacroAssembler::biased_locking_exit (Address mark_addr, Register temp_reg, Label&amp; done,
2564                                           bool allow_delay_slot_filling) {
2565   // Check for biased locking unlock case, which is a no-op
2566   // Note: we do not have to check the thread ID for two reasons.
2567   // First, the interpreter checks for IllegalMonitorStateException at
2568   // a higher level. Second, if the bias was revoked while we held the
2569   // lock, the object could not be rebiased toward another thread, so
2570   // the bias bit would be clear.
2571   ld_ptr(mark_addr, temp_reg);
2572   and3(temp_reg, markWord::biased_lock_mask_in_place, temp_reg);
2573   cmp(temp_reg, markWord::biased_lock_pattern);
2574   brx(Assembler::equal, allow_delay_slot_filling, Assembler::pt, done);
2575   delayed();
2576   if (!allow_delay_slot_filling) {
2577     nop();
2578   }
2579 }
2580 
2581 
2582 // compiler_lock_object() and compiler_unlock_object() are direct transliterations
2583 // of i486.ad fast_lock() and fast_unlock().  See those methods for detailed comments.
2584 // The code could be tightened up considerably.
2585 //
2586 // box-&gt;dhw disposition - post-conditions at DONE_LABEL.
2587 // -   Successful inflated lock:  box-&gt;dhw != 0.
2588 //     Any non-zero value suffices.
2589 //     Consider G2_thread, rsp, boxReg, or markWord::unused_mark()
2590 // -   Successful Stack-lock: box-&gt;dhw == mark.
2591 //     box-&gt;dhw must contain the displaced mark word value
2592 // -   Failure -- icc.ZFlag == 0 and box-&gt;dhw is undefined.
2593 //     The slow-path enter() is responsible for setting
2594 //     box-&gt;dhw = NonZero (typically markWord::unused_mark()).
2595 // -   Biased: box-&gt;dhw is undefined
2596 //
2597 // SPARC refworkload performance - specifically jetstream and scimark - are
2598 // extremely sensitive to the size of the code emitted by compiler_lock_object
2599 // and compiler_unlock_object.  Critically, the key factor is code size, not path
2600 // length.  (Simply experiments to pad CLO with unexecuted NOPs demonstrte the
2601 // effect).
2602 
2603 
2604 void MacroAssembler::compiler_lock_object(Register Roop, Register Rmark,
2605                                           Register Rbox, Register Rscratch,
2606                                           BiasedLockingCounters* counters,
2607                                           bool try_bias) {
2608    Address mark_addr(Roop, oopDesc::mark_offset_in_bytes());
2609 
2610    verify_oop(Roop);
2611    Label done ;
2612 
2613    if (counters != NULL) {
2614      inc_counter((address) counters-&gt;total_entry_count_addr(), Rmark, Rscratch);
2615    }
2616 
2617    // Aggressively avoid the Store-before-CAS penalty
2618    // Defer the store into box-&gt;dhw until after the CAS
2619    Label IsInflated, Recursive ;
2620 
2621 // Anticipate CAS -- Avoid RTS-&gt;RTO upgrade
2622 // prefetch (mark_addr, Assembler::severalWritesAndPossiblyReads);
2623 
2624    ld_ptr(mark_addr, Rmark);           // fetch obj-&gt;mark
2625    // Triage: biased, stack-locked, neutral, inflated
2626 
2627    if (try_bias) {
2628      biased_locking_enter(Roop, Rmark, Rscratch, done, NULL, counters);
2629      // Invariant: if control reaches this point in the emitted stream
2630      // then Rmark has not been modified.
2631    }
2632    andcc(Rmark, 2, G0);
2633    brx(Assembler::notZero, false, Assembler::pn, IsInflated);
2634    delayed()-&gt;                         // Beware - dangling delay-slot
2635 
2636    // Try stack-lock acquisition.
2637    // Transiently install BUSY (0) encoding in the mark word.
2638    // if the CAS of 0 into the mark was successful then we execute:
2639    //   ST box-&gt;dhw  = mark   -- save fetched mark in on-stack basiclock box
2640    //   ST obj-&gt;mark = box    -- overwrite transient 0 value
2641    // This presumes TSO, of course.
2642 
2643    mov(0, Rscratch);
2644    or3(Rmark, markWord::unlocked_value, Rmark);
2645    assert(mark_addr.disp() == 0, &quot;cas must take a zero displacement&quot;);
2646    cas_ptr(mark_addr.base(), Rmark, Rscratch);
2647 // prefetch (mark_addr, Assembler::severalWritesAndPossiblyReads);
2648    cmp(Rscratch, Rmark);
2649    brx(Assembler::notZero, false, Assembler::pn, Recursive);
2650    delayed()-&gt;st_ptr(Rmark, Rbox, BasicLock::displaced_header_offset_in_bytes());
2651    if (counters != NULL) {
2652      cond_inc(Assembler::equal, (address) counters-&gt;fast_path_entry_count_addr(), Rmark, Rscratch);
2653    }
2654    ba(done);
2655    delayed()-&gt;st_ptr(Rbox, mark_addr);
2656 
2657    bind(Recursive);
2658    // Stack-lock attempt failed - check for recursive stack-lock.
2659    // Tests show that we can remove the recursive case with no impact
2660    // on refworkload 0.83.  If we need to reduce the size of the code
2661    // emitted by compiler_lock_object() the recursive case is perfect
2662    // candidate.
2663    //
2664    // A more extreme idea is to always inflate on stack-lock recursion.
2665    // This lets us eliminate the recursive checks in compiler_lock_object
2666    // and compiler_unlock_object and the (box-&gt;dhw == 0) encoding.
2667    // A brief experiment - requiring changes to synchronizer.cpp, interpreter,
2668    // and showed a performance *increase*.  In the same experiment I eliminated
2669    // the fast-path stack-lock code from the interpreter and always passed
2670    // control to the &quot;slow&quot; operators in synchronizer.cpp.
2671 
2672    // RScratch contains the fetched obj-&gt;mark value from the failed CAS.
2673    sub(Rscratch, STACK_BIAS, Rscratch);
2674    sub(Rscratch, SP, Rscratch);
2675    assert(os::vm_page_size() &gt; 0xfff, &quot;page size too small - change the constant&quot;);
2676    andcc(Rscratch, 0xfffff003, Rscratch);
2677    if (counters != NULL) {
2678      // Accounting needs the Rscratch register
2679      st_ptr(Rscratch, Rbox, BasicLock::displaced_header_offset_in_bytes());
2680      cond_inc(Assembler::equal, (address) counters-&gt;fast_path_entry_count_addr(), Rmark, Rscratch);
2681      ba_short(done);
2682    } else {
2683      ba(done);
2684      delayed()-&gt;st_ptr(Rscratch, Rbox, BasicLock::displaced_header_offset_in_bytes());
2685    }
2686 
2687    bind   (IsInflated);
2688 
2689    // Try to CAS m-&gt;owner from null to Self
2690    // Invariant: if we acquire the lock then _recursions should be 0.
2691    add(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), Rmark);
2692    mov(G2_thread, Rscratch);
2693    cas_ptr(Rmark, G0, Rscratch);
2694    andcc(Rscratch, Rscratch, G0);             // set ICCs for done: icc.zf iff success
2695    // set icc.zf : 1=success 0=failure
2696    // ST box-&gt;displaced_header = NonZero.
2697    // Any non-zero value suffices:
2698    //    markWord::unused_mark(), G2_thread, RBox, RScratch, rsp, etc.
2699    st_ptr(Rbox, Rbox, BasicLock::displaced_header_offset_in_bytes());
2700    // Intentional fall-through into done
2701 
2702    bind   (done);
2703 }
2704 
2705 void MacroAssembler::compiler_unlock_object(Register Roop, Register Rmark,
2706                                             Register Rbox, Register Rscratch,
2707                                             bool try_bias) {
2708    Address mark_addr(Roop, oopDesc::mark_offset_in_bytes());
2709 
2710    Label done ;
2711 
2712    // Beware ... If the aggregate size of the code emitted by CLO and CUO is
2713    // is too large performance rolls abruptly off a cliff.
2714    // This could be related to inlining policies, code cache management, or
2715    // I$ effects.
2716    Label LStacked ;
2717 
2718    if (try_bias) {
2719       // TODO: eliminate redundant LDs of obj-&gt;mark
2720       biased_locking_exit(mark_addr, Rscratch, done);
2721    }
2722 
2723    ld_ptr(Roop, oopDesc::mark_offset_in_bytes(), Rmark);
2724    ld_ptr(Rbox, BasicLock::displaced_header_offset_in_bytes(), Rscratch);
2725    andcc(Rscratch, Rscratch, G0);
2726    brx(Assembler::zero, false, Assembler::pn, done);
2727    delayed()-&gt;nop();      // consider: relocate fetch of mark, above, into this DS
2728    andcc(Rmark, 2, G0);
2729    brx(Assembler::zero, false, Assembler::pt, LStacked);
2730    delayed()-&gt;nop();
2731 
2732    // It&#39;s inflated
2733    // Conceptually we need a #loadstore|#storestore &quot;release&quot; MEMBAR before
2734    // the ST of 0 into _owner which releases the lock.  This prevents loads
2735    // and stores within the critical section from reordering (floating)
2736    // past the store that releases the lock.  But TSO is a strong memory model
2737    // and that particular flavor of barrier is a noop, so we can safely elide it.
2738    // Note that we use 1-0 locking by default for the inflated case.  We
2739    // close the resultant (and rare) race by having contended threads in
2740    // monitorenter periodically poll _owner.
2741 
2742    // 1-0 form : avoids CAS and MEMBAR in the common case
2743    // Do not bother to ratify that m-&gt;Owner == Self.
2744    ld_ptr(Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), Rbox);
2745    orcc(Rbox, G0, G0);
2746    brx(Assembler::notZero, false, Assembler::pn, done);
2747    delayed()-&gt;
2748    ld_ptr(Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)), Rscratch);
2749    ld_ptr(Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)), Rbox);
2750    orcc(Rbox, Rscratch, G0);
2751    brx(Assembler::zero, false, Assembler::pt, done);
2752    delayed()-&gt;
2753    st_ptr(G0, Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));
2754 
2755    membar(StoreLoad);
2756    // Check that _succ is (or remains) non-zero
2757    ld_ptr(Address(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), Rscratch);
2758    andcc(Rscratch, Rscratch, G0);
2759    brx(Assembler::notZero, false, Assembler::pt, done);
2760    delayed()-&gt;andcc(G0, G0, G0);
2761    add(Rmark, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), Rmark);
2762    mov(G2_thread, Rscratch);
2763    cas_ptr(Rmark, G0, Rscratch);
2764    cmp(Rscratch, G0);
2765    // invert icc.zf and goto done
2766    // A slightly better v8+/v9 idiom would be the following:
2767    //   movrnz Rscratch,1,Rscratch
2768    //   ba done
2769    //   xorcc Rscratch,1,G0
2770    // In v8+ mode the idiom would be valid IFF Rscratch was a G or O register
2771    brx(Assembler::notZero, false, Assembler::pt, done);
2772    delayed()-&gt;cmp(G0, G0);
2773    br(Assembler::always, false, Assembler::pt, done);
2774    delayed()-&gt;cmp(G0, 1);
2775 
2776    bind   (LStacked);
2777    // Consider: we could replace the expensive CAS in the exit
2778    // path with a simple ST of the displaced mark value fetched from
2779    // the on-stack basiclock box.  That admits a race where a thread T2
2780    // in the slow lock path -- inflating with monitor M -- could race a
2781    // thread T1 in the fast unlock path, resulting in a missed wakeup for T2.
2782    // More precisely T1 in the stack-lock unlock path could &quot;stomp&quot; the
2783    // inflated mark value M installed by T2, resulting in an orphan
2784    // object monitor M and T2 becoming stranded.  We can remedy that situation
2785    // by having T2 periodically poll the object&#39;s mark word using timed wait
2786    // operations.  If T2 discovers that a stomp has occurred it vacates
2787    // the monitor M and wakes any other threads stranded on the now-orphan M.
2788    // In addition the monitor scavenger, which performs deflation,
2789    // would also need to check for orpan monitors and stranded threads.
2790    //
2791    // Finally, inflation is also used when T2 needs to assign a hashCode
2792    // to O and O is stack-locked by T1.  The &quot;stomp&quot; race could cause
2793    // an assigned hashCode value to be lost.  We can avoid that condition
2794    // and provide the necessary hashCode stability invariants by ensuring
2795    // that hashCode generation is idempotent between copying GCs.
2796    // For example we could compute the hashCode of an object O as
2797    // O&#39;s heap address XOR some high quality RNG value that is refreshed
2798    // at GC-time.  The monitor scavenger would install the hashCode
2799    // found in any orphan monitors.  Again, the mechanism admits a
2800    // lost-update &quot;stomp&quot; WAW race but detects and recovers as needed.
2801    //
2802    // A prototype implementation showed excellent results, although
2803    // the scavenger and timeout code was rather involved.
2804 
2805    cas_ptr(mark_addr.base(), Rbox, Rscratch);
2806    cmp(Rbox, Rscratch);
2807    // Intentional fall through into done ...
2808 
2809    bind(done);
2810 }
2811 
2812 void MacroAssembler::verify_tlab() {
2813 #ifdef ASSERT
2814   if (UseTLAB &amp;&amp; VerifyOops) {
2815     Label next, next2, ok;
2816     Register t1 = L0;
2817     Register t2 = L1;
2818     Register t3 = L2;
2819 
2820     save_frame(0);
2821     ld_ptr(G2_thread, in_bytes(JavaThread::tlab_top_offset()), t1);
2822     ld_ptr(G2_thread, in_bytes(JavaThread::tlab_start_offset()), t2);
2823     or3(t1, t2, t3);
2824     cmp_and_br_short(t1, t2, Assembler::greaterEqual, Assembler::pn, next);
2825     STOP(&quot;assert(top &gt;= start)&quot;);
2826     should_not_reach_here();
2827 
2828     bind(next);
2829     ld_ptr(G2_thread, in_bytes(JavaThread::tlab_top_offset()), t1);
2830     ld_ptr(G2_thread, in_bytes(JavaThread::tlab_end_offset()), t2);
2831     or3(t3, t2, t3);
2832     cmp_and_br_short(t1, t2, Assembler::lessEqual, Assembler::pn, next2);
2833     STOP(&quot;assert(top &lt;= end)&quot;);
2834     should_not_reach_here();
2835 
2836     bind(next2);
2837     and3(t3, MinObjAlignmentInBytesMask, t3);
2838     cmp_and_br_short(t3, 0, Assembler::lessEqual, Assembler::pn, ok);
2839     STOP(&quot;assert(aligned)&quot;);
2840     should_not_reach_here();
2841 
2842     bind(ok);
2843     restore();
2844   }
2845 #endif
2846 }
2847 
2848 
2849 void MacroAssembler::eden_allocate(
2850   Register obj,                        // result: pointer to object after successful allocation
2851   Register var_size_in_bytes,          // object size in bytes if unknown at compile time; invalid otherwise
2852   int      con_size_in_bytes,          // object size in bytes if   known at compile time
2853   Register t1,                         // temp register
2854   Register t2,                         // temp register
2855   Label&amp;   slow_case                   // continuation point if fast allocation fails
2856 ){
2857   // make sure arguments make sense
2858   assert_different_registers(obj, var_size_in_bytes, t1, t2);
2859   assert(0 &lt;= con_size_in_bytes &amp;&amp; Assembler::is_simm13(con_size_in_bytes), &quot;illegal object size&quot;);
2860   assert((con_size_in_bytes &amp; MinObjAlignmentInBytesMask) == 0, &quot;object size is not multiple of alignment&quot;);
2861 
2862   if (!Universe::heap()-&gt;supports_inline_contig_alloc()) {
2863     // No allocation in the shared eden.
2864     ba(slow_case);
2865     delayed()-&gt;nop();
2866   } else {
2867     // get eden boundaries
2868     // note: we need both top &amp; top_addr!
2869     const Register top_addr = t1;
2870     const Register end      = t2;
2871 
2872     CollectedHeap* ch = Universe::heap();
2873     set((intx)ch-&gt;top_addr(), top_addr);
2874     intx delta = (intx)ch-&gt;end_addr() - (intx)ch-&gt;top_addr();
2875     ld_ptr(top_addr, delta, end);
2876     ld_ptr(top_addr, 0, obj);
2877 
2878     // try to allocate
2879     Label retry;
2880     bind(retry);
2881 #ifdef ASSERT
2882     // make sure eden top is properly aligned
2883     {
2884       Label L;
2885       btst(MinObjAlignmentInBytesMask, obj);
2886       br(Assembler::zero, false, Assembler::pt, L);
2887       delayed()-&gt;nop();
2888       STOP(&quot;eden top is not properly aligned&quot;);
2889       bind(L);
2890     }
2891 #endif // ASSERT
2892     const Register free = end;
2893     sub(end, obj, free);                                   // compute amount of free space
2894     if (var_size_in_bytes-&gt;is_valid()) {
2895       // size is unknown at compile time
2896       cmp(free, var_size_in_bytes);
2897       brx(Assembler::lessUnsigned, false, Assembler::pn, slow_case); // if there is not enough space go the slow case
2898       delayed()-&gt;add(obj, var_size_in_bytes, end);
2899     } else {
2900       // size is known at compile time
2901       cmp(free, con_size_in_bytes);
2902       brx(Assembler::lessUnsigned, false, Assembler::pn, slow_case); // if there is not enough space go the slow case
2903       delayed()-&gt;add(obj, con_size_in_bytes, end);
2904     }
2905     // Compare obj with the value at top_addr; if still equal, swap the value of
2906     // end with the value at top_addr. If not equal, read the value at top_addr
2907     // into end.
2908     cas_ptr(top_addr, obj, end);
2909     // if someone beat us on the allocation, try again, otherwise continue
2910     cmp(obj, end);
2911     brx(Assembler::notEqual, false, Assembler::pn, retry);
2912     delayed()-&gt;mov(end, obj);                              // nop if successfull since obj == end
2913 
2914 #ifdef ASSERT
2915     // make sure eden top is properly aligned
2916     {
2917       Label L;
2918       const Register top_addr = t1;
2919 
2920       set((intx)ch-&gt;top_addr(), top_addr);
2921       ld_ptr(top_addr, 0, top_addr);
2922       btst(MinObjAlignmentInBytesMask, top_addr);
2923       br(Assembler::zero, false, Assembler::pt, L);
2924       delayed()-&gt;nop();
2925       STOP(&quot;eden top is not properly aligned&quot;);
2926       bind(L);
2927     }
2928 #endif // ASSERT
2929   }
2930 }
2931 
2932 
2933 void MacroAssembler::tlab_allocate(
2934   Register obj,                        // result: pointer to object after successful allocation
2935   Register var_size_in_bytes,          // object size in bytes if unknown at compile time; invalid otherwise
2936   int      con_size_in_bytes,          // object size in bytes if   known at compile time
2937   Register t1,                         // temp register
2938   Label&amp;   slow_case                   // continuation point if fast allocation fails
2939 ){
2940   // make sure arguments make sense
2941   assert_different_registers(obj, var_size_in_bytes, t1);
2942   assert(0 &lt;= con_size_in_bytes &amp;&amp; is_simm13(con_size_in_bytes), &quot;illegal object size&quot;);
2943   assert((con_size_in_bytes &amp; MinObjAlignmentInBytesMask) == 0, &quot;object size is not multiple of alignment&quot;);
2944 
2945   const Register free  = t1;
2946 
2947   verify_tlab();
2948 
2949   ld_ptr(G2_thread, in_bytes(JavaThread::tlab_top_offset()), obj);
2950 
2951   // calculate amount of free space
2952   ld_ptr(G2_thread, in_bytes(JavaThread::tlab_end_offset()), free);
2953   sub(free, obj, free);
2954 
2955   Label done;
2956   if (var_size_in_bytes == noreg) {
2957     cmp(free, con_size_in_bytes);
2958   } else {
2959     cmp(free, var_size_in_bytes);
2960   }
2961   br(Assembler::less, false, Assembler::pn, slow_case);
2962   // calculate the new top pointer
2963   if (var_size_in_bytes == noreg) {
2964     delayed()-&gt;add(obj, con_size_in_bytes, free);
2965   } else {
2966     delayed()-&gt;add(obj, var_size_in_bytes, free);
2967   }
2968 
2969   bind(done);
2970 
2971 #ifdef ASSERT
2972   // make sure new free pointer is properly aligned
2973   {
2974     Label L;
2975     btst(MinObjAlignmentInBytesMask, free);
2976     br(Assembler::zero, false, Assembler::pt, L);
2977     delayed()-&gt;nop();
2978     STOP(&quot;updated TLAB free is not properly aligned&quot;);
2979     bind(L);
2980   }
2981 #endif // ASSERT
2982 
2983   // update the tlab top pointer
2984   st_ptr(free, G2_thread, in_bytes(JavaThread::tlab_top_offset()));
2985   verify_tlab();
2986 }
2987 
2988 void MacroAssembler::zero_memory(Register base, Register index) {
2989   assert_different_registers(base, index);
2990   Label loop;
2991   bind(loop);
2992   subcc(index, HeapWordSize, index);
2993   brx(Assembler::greaterEqual, true, Assembler::pt, loop);
2994   delayed()-&gt;st_ptr(G0, base, index);
2995 }
2996 
2997 void MacroAssembler::incr_allocated_bytes(RegisterOrConstant size_in_bytes,
2998                                           Register t1, Register t2) {
2999   // Bump total bytes allocated by this thread
3000   assert(t1-&gt;is_global(), &quot;must be global reg&quot;); // so all 64 bits are saved on a context switch
3001   assert_different_registers(size_in_bytes.register_or_noreg(), t1, t2);
3002   // v8 support has gone the way of the dodo
3003   ldx(G2_thread, in_bytes(JavaThread::allocated_bytes_offset()), t1);
3004   add(t1, ensure_simm13_or_reg(size_in_bytes, t2), t1);
3005   stx(t1, G2_thread, in_bytes(JavaThread::allocated_bytes_offset()));
3006 }
3007 
3008 Assembler::Condition MacroAssembler::negate_condition(Assembler::Condition cond) {
3009   switch (cond) {
3010     // Note some conditions are synonyms for others
3011     case Assembler::never:                return Assembler::always;
3012     case Assembler::zero:                 return Assembler::notZero;
3013     case Assembler::lessEqual:            return Assembler::greater;
3014     case Assembler::less:                 return Assembler::greaterEqual;
3015     case Assembler::lessEqualUnsigned:    return Assembler::greaterUnsigned;
3016     case Assembler::lessUnsigned:         return Assembler::greaterEqualUnsigned;
3017     case Assembler::negative:             return Assembler::positive;
3018     case Assembler::overflowSet:          return Assembler::overflowClear;
3019     case Assembler::always:               return Assembler::never;
3020     case Assembler::notZero:              return Assembler::zero;
3021     case Assembler::greater:              return Assembler::lessEqual;
3022     case Assembler::greaterEqual:         return Assembler::less;
3023     case Assembler::greaterUnsigned:      return Assembler::lessEqualUnsigned;
3024     case Assembler::greaterEqualUnsigned: return Assembler::lessUnsigned;
3025     case Assembler::positive:             return Assembler::negative;
3026     case Assembler::overflowClear:        return Assembler::overflowSet;
3027   }
3028 
3029   ShouldNotReachHere(); return Assembler::overflowClear;
3030 }
3031 
3032 void MacroAssembler::cond_inc(Assembler::Condition cond, address counter_ptr,
3033                               Register Rtmp1, Register Rtmp2 /*, Register Rtmp3, Register Rtmp4 */) {
3034   Condition negated_cond = negate_condition(cond);
3035   Label L;
3036   brx(negated_cond, false, Assembler::pt, L);
3037   delayed()-&gt;nop();
3038   inc_counter(counter_ptr, Rtmp1, Rtmp2);
3039   bind(L);
3040 }
3041 
3042 void MacroAssembler::inc_counter(address counter_addr, Register Rtmp1, Register Rtmp2) {
3043   AddressLiteral addrlit(counter_addr);
3044   sethi(addrlit, Rtmp1);                 // Move hi22 bits into temporary register.
3045   Address addr(Rtmp1, addrlit.low10());  // Build an address with low10 bits.
3046   ld(addr, Rtmp2);
3047   inc(Rtmp2);
3048   st(Rtmp2, addr);
3049 }
3050 
3051 void MacroAssembler::inc_counter(int* counter_addr, Register Rtmp1, Register Rtmp2) {
3052   inc_counter((address) counter_addr, Rtmp1, Rtmp2);
3053 }
3054 
3055 SkipIfEqual::SkipIfEqual(
3056     MacroAssembler* masm, Register temp, const bool* flag_addr,
3057     Assembler::Condition condition) {
3058   _masm = masm;
3059   AddressLiteral flag(flag_addr);
3060   _masm-&gt;sethi(flag, temp);
3061   _masm-&gt;ldub(temp, flag.low10(), temp);
3062   _masm-&gt;tst(temp);
3063   _masm-&gt;br(condition, false, Assembler::pt, _label);
3064   _masm-&gt;delayed()-&gt;nop();
3065 }
3066 
3067 SkipIfEqual::~SkipIfEqual() {
3068   _masm-&gt;bind(_label);
3069 }
3070 
3071 void MacroAssembler::bang_stack_with_offset(int offset) {
3072   // stack grows down, caller passes positive offset
3073   assert(offset &gt; 0, &quot;must bang with negative offset&quot;);
3074   set((-offset)+STACK_BIAS, G3_scratch);
3075   st(G0, SP, G3_scratch);
3076 }
3077 
3078 // Writes to stack successive pages until offset reached to check for
3079 // stack overflow + shadow pages.  This clobbers tsp and scratch.
3080 void MacroAssembler::bang_stack_size(Register Rsize, Register Rtsp,
3081                                      Register Rscratch) {
3082   // Use stack pointer in temp stack pointer
3083   mov(SP, Rtsp);
3084 
3085   // Bang stack for total size given plus stack shadow page size.
3086   // Bang one page at a time because a large size can overflow yellow and
3087   // red zones (the bang will fail but stack overflow handling can&#39;t tell that
3088   // it was a stack overflow bang vs a regular segv).
3089   int offset = os::vm_page_size();
3090   Register Roffset = Rscratch;
3091 
3092   Label loop;
3093   bind(loop);
3094   set((-offset)+STACK_BIAS, Rscratch);
3095   st(G0, Rtsp, Rscratch);
3096   set(offset, Roffset);
3097   sub(Rsize, Roffset, Rsize);
3098   cmp(Rsize, G0);
3099   br(Assembler::greater, false, Assembler::pn, loop);
3100   delayed()-&gt;sub(Rtsp, Roffset, Rtsp);
3101 
3102   // Bang down shadow pages too.
3103   // At this point, (tmp-0) is the last address touched, so don&#39;t
3104   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
3105   // was post-decremented.)  Skip this address by starting at i=1, and
3106   // touch a few more pages below.  N.B.  It is important to touch all
3107   // the way down to and including i=StackShadowPages.
3108   for (int i = 1; i &lt; JavaThread::stack_shadow_zone_size() / os::vm_page_size(); i++) {
3109     set((-i*offset)+STACK_BIAS, Rscratch);
3110     st(G0, Rtsp, Rscratch);
3111   }
3112 }
3113 
3114 void MacroAssembler::reserved_stack_check() {
3115   // testing if reserved zone needs to be enabled
3116   Label no_reserved_zone_enabling;
3117 
3118   ld_ptr(G2_thread, JavaThread::reserved_stack_activation_offset(), G4_scratch);
3119   cmp_and_brx_short(SP, G4_scratch, Assembler::lessUnsigned, Assembler::pt, no_reserved_zone_enabling);
3120 
3121   call_VM_leaf(L0, CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), G2_thread);
3122 
3123   AddressLiteral stub(StubRoutines::throw_delayed_StackOverflowError_entry());
3124   jump_to(stub, G4_scratch);
3125   delayed()-&gt;restore();
3126 
3127   should_not_reach_here();
3128 
3129   bind(no_reserved_zone_enabling);
3130 }
3131 // ((OopHandle)result).resolve();
3132 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
3133   // OopHandle::resolve is an indirection.
3134   access_load_at(T_OBJECT, IN_NATIVE, Address(result, 0), result, tmp);
3135 }
3136 
3137 void MacroAssembler::load_mirror(Register mirror, Register method, Register tmp) {
3138   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
3139   ld_ptr(method, in_bytes(Method::const_offset()), mirror);
3140   ld_ptr(mirror, in_bytes(ConstMethod::constants_offset()), mirror);
3141   ld_ptr(mirror, ConstantPool::pool_holder_offset_in_bytes(), mirror);
3142   ld_ptr(mirror, mirror_offset, mirror);
3143   resolve_oop_handle(mirror, tmp);
3144 }
3145 
3146 void MacroAssembler::load_klass(Register src_oop, Register klass) {
3147   // The number of bytes in this code is used by
3148   // MachCallDynamicJavaNode::ret_addr_offset()
3149   // if this changes, change that.
3150   if (UseCompressedClassPointers) {
3151     lduw(src_oop, oopDesc::klass_offset_in_bytes(), klass);
3152     decode_klass_not_null(klass);
3153   } else {
3154     ld_ptr(src_oop, oopDesc::klass_offset_in_bytes(), klass);
3155   }
3156 }
3157 
3158 void MacroAssembler::store_klass(Register klass, Register dst_oop) {
3159   if (UseCompressedClassPointers) {
3160     assert(dst_oop != klass, &quot;not enough registers&quot;);
3161     encode_klass_not_null(klass);
3162     st(klass, dst_oop, oopDesc::klass_offset_in_bytes());
3163   } else {
3164     st_ptr(klass, dst_oop, oopDesc::klass_offset_in_bytes());
3165   }
3166 }
3167 
3168 void MacroAssembler::store_klass_gap(Register s, Register d) {
3169   if (UseCompressedClassPointers) {
3170     assert(s != d, &quot;not enough registers&quot;);
3171     st(s, d, oopDesc::klass_gap_offset_in_bytes());
3172   }
3173 }
3174 
3175 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators,
3176                                      Register src, Address dst, Register tmp) {
3177   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3178   decorators = AccessInternal::decorator_fixup(decorators);
3179   bool as_raw = (decorators &amp; AS_RAW) != 0;
3180   if (as_raw) {
3181     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, src, dst, tmp);
3182   } else {
3183     bs-&gt;store_at(this, decorators, type, src, dst, tmp);
3184   }
3185 }
3186 
3187 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators,
3188                                     Address src, Register dst, Register tmp) {
3189   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3190   decorators = AccessInternal::decorator_fixup(decorators);
3191   bool as_raw = (decorators &amp; AS_RAW) != 0;
3192   if (as_raw) {
3193     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type, src, dst, tmp);
3194   } else {
3195     bs-&gt;load_at(this, decorators, type, src, dst, tmp);
3196   }
3197 }
3198 
3199 void MacroAssembler::load_heap_oop(const Address&amp; s, Register d, Register tmp, DecoratorSet decorators) {
3200   access_load_at(T_OBJECT, IN_HEAP | decorators, s, d, tmp);
3201 }
3202 
3203 void MacroAssembler::load_heap_oop(Register s1, Register s2, Register d, Register tmp, DecoratorSet decorators) {
3204   access_load_at(T_OBJECT, IN_HEAP | decorators, Address(s1, s2), d, tmp);
3205 }
3206 
3207 void MacroAssembler::load_heap_oop(Register s1, int simm13a, Register d, Register tmp, DecoratorSet decorators) {
3208   access_load_at(T_OBJECT, IN_HEAP | decorators, Address(s1, simm13a), d, tmp);
3209 }
3210 
3211 void MacroAssembler::load_heap_oop(Register s1, RegisterOrConstant s2, Register d, Register tmp, DecoratorSet decorators) {
3212   if (s2.is_constant()) {
3213     access_load_at(T_OBJECT, IN_HEAP | decorators, Address(s1, s2.as_constant()), d, tmp);
3214   } else {
3215     access_load_at(T_OBJECT, IN_HEAP | decorators, Address(s1, s2.as_register()), d, tmp);
3216   }
3217 }
3218 
3219 void MacroAssembler::store_heap_oop(Register d, Register s1, Register s2, Register tmp, DecoratorSet decorators) {
3220   access_store_at(T_OBJECT, IN_HEAP | decorators, d, Address(s1, s2), tmp);
3221 }
3222 
3223 void MacroAssembler::store_heap_oop(Register d, Register s1, int simm13a, Register tmp, DecoratorSet decorators) {
3224   access_store_at(T_OBJECT, IN_HEAP | decorators, d, Address(s1, simm13a), tmp);
3225 }
3226 
3227 void MacroAssembler::store_heap_oop(Register d, const Address&amp; a, int offset, Register tmp, DecoratorSet decorators) {
3228   if (a.has_index()) {
3229     assert(!a.has_disp(), &quot;not supported yet&quot;);
3230     assert(offset == 0, &quot;not supported yet&quot;);
3231     access_store_at(T_OBJECT, IN_HEAP | decorators, d, Address(a.base(), a.index()), tmp);
3232   } else {
3233     access_store_at(T_OBJECT, IN_HEAP | decorators, d, Address(a.base(), a.disp() + offset), tmp);
3234   }
3235 }
3236 
3237 
3238 void MacroAssembler::encode_heap_oop(Register src, Register dst) {
3239   assert (UseCompressedOops, &quot;must be compressed&quot;);
3240   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3241   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3242   verify_oop(src);
3243   if (CompressedOops::base() == NULL) {
3244     srlx(src, LogMinObjAlignmentInBytes, dst);
3245     return;
3246   }
3247   Label done;
3248   if (src == dst) {
3249     // optimize for frequent case src == dst
3250     bpr(rc_nz, true, Assembler::pt, src, done);
3251     delayed() -&gt; sub(src, G6_heapbase, dst); // annuled if not taken
3252     bind(done);
3253     srlx(src, LogMinObjAlignmentInBytes, dst);
3254   } else {
3255     bpr(rc_z, false, Assembler::pn, src, done);
3256     delayed() -&gt; mov(G0, dst);
3257     // could be moved before branch, and annulate delay,
3258     // but may add some unneeded work decoding null
3259     sub(src, G6_heapbase, dst);
3260     srlx(dst, LogMinObjAlignmentInBytes, dst);
3261     bind(done);
3262   }
3263 }
3264 
3265 
3266 void MacroAssembler::encode_heap_oop_not_null(Register r) {
3267   assert (UseCompressedOops, &quot;must be compressed&quot;);
3268   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3269   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3270   verify_oop(r);
3271   if (CompressedOops::base() != NULL)
3272     sub(r, G6_heapbase, r);
3273   srlx(r, LogMinObjAlignmentInBytes, r);
3274 }
3275 
3276 void MacroAssembler::encode_heap_oop_not_null(Register src, Register dst) {
3277   assert (UseCompressedOops, &quot;must be compressed&quot;);
3278   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3279   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3280   verify_oop(src);
3281   if (CompressedOops::base() == NULL) {
3282     srlx(src, LogMinObjAlignmentInBytes, dst);
3283   } else {
3284     sub(src, G6_heapbase, dst);
3285     srlx(dst, LogMinObjAlignmentInBytes, dst);
3286   }
3287 }
3288 
3289 // Same algorithm as oops.inline.hpp decode_heap_oop.
3290 void  MacroAssembler::decode_heap_oop(Register src, Register dst) {
3291   assert (UseCompressedOops, &quot;must be compressed&quot;);
3292   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3293   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3294   sllx(src, LogMinObjAlignmentInBytes, dst);
3295   if (CompressedOops::base() != NULL) {
3296     Label done;
3297     bpr(rc_nz, true, Assembler::pt, dst, done);
3298     delayed() -&gt; add(dst, G6_heapbase, dst); // annuled if not taken
3299     bind(done);
3300   }
3301   verify_oop(dst);
3302 }
3303 
3304 void  MacroAssembler::decode_heap_oop_not_null(Register r) {
3305   // Do not add assert code to this unless you change vtableStubs_sparc.cpp
3306   // pd_code_size_limit.
3307   // Also do not verify_oop as this is called by verify_oop.
3308   assert (UseCompressedOops, &quot;must be compressed&quot;);
3309   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3310   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3311   sllx(r, LogMinObjAlignmentInBytes, r);
3312   if (CompressedOops::base() != NULL)
3313     add(r, G6_heapbase, r);
3314 }
3315 
3316 void  MacroAssembler::decode_heap_oop_not_null(Register src, Register dst) {
3317   // Do not add assert code to this unless you change vtableStubs_sparc.cpp
3318   // pd_code_size_limit.
3319   // Also do not verify_oop as this is called by verify_oop.
3320   assert (UseCompressedOops, &quot;must be compressed&quot;);
3321   assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3322   sllx(src, LogMinObjAlignmentInBytes, dst);
3323   if (CompressedOops::base() != NULL)
3324     add(dst, G6_heapbase, dst);
3325 }
3326 
3327 void MacroAssembler::encode_klass_not_null(Register r) {
3328   assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
3329   if (CompressedKlassPointers::base() != NULL) {
3330     assert(r != G6_heapbase, &quot;bad register choice&quot;);
3331     set((intptr_t)CompressedKlassPointers::base(), G6_heapbase);
3332     sub(r, G6_heapbase, r);
3333     if (CompressedKlassPointers::shift() != 0) {
3334       assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
3335       srlx(r, LogKlassAlignmentInBytes, r);
3336     }
3337     reinit_heapbase();
3338   } else {
3339     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift() || CompressedKlassPointers::shift() == 0, &quot;decode alg wrong&quot;);
3340     srlx(r, CompressedKlassPointers::shift(), r);
3341   }
3342 }
3343 
3344 void MacroAssembler::encode_klass_not_null(Register src, Register dst) {
3345   if (src == dst) {
3346     encode_klass_not_null(src);
3347   } else {
3348     assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
3349     if (CompressedKlassPointers::base() != NULL) {
3350       set((intptr_t)CompressedKlassPointers::base(), dst);
3351       sub(src, dst, dst);
3352       if (CompressedKlassPointers::shift() != 0) {
3353         srlx(dst, LogKlassAlignmentInBytes, dst);
3354       }
3355     } else {
3356       // shift src into dst
3357       assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift() || CompressedKlassPointers::shift() == 0, &quot;decode alg wrong&quot;);
3358       srlx(src, CompressedKlassPointers::shift(), dst);
3359     }
3360   }
3361 }
3362 
3363 // Function instr_size_for_decode_klass_not_null() counts the instructions
3364 // generated by decode_klass_not_null() and reinit_heapbase().  Hence, if
3365 // the instructions they generate change, then this method needs to be updated.
3366 int MacroAssembler::instr_size_for_decode_klass_not_null() {
3367   assert (UseCompressedClassPointers, &quot;only for compressed klass ptrs&quot;);
3368   int num_instrs = 1;  // shift src,dst or add
3369   if (CompressedKlassPointers::base() != NULL) {
3370     // set + add + set
3371     num_instrs += insts_for_internal_set((intptr_t)CompressedKlassPointers::base()) +
3372                   insts_for_internal_set((intptr_t)CompressedOops::ptrs_base());
3373     if (CompressedKlassPointers::shift() != 0) {
3374       num_instrs += 1;  // sllx
3375     }
3376   }
3377   return num_instrs * BytesPerInstWord;
3378 }
3379 
3380 // !!! If the instructions that get generated here change then function
3381 // instr_size_for_decode_klass_not_null() needs to get updated.
3382 void  MacroAssembler::decode_klass_not_null(Register r) {
3383   // Do not add assert code to this unless you change vtableStubs_sparc.cpp
3384   // pd_code_size_limit.
3385   assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
3386   if (CompressedKlassPointers::base() != NULL) {
3387     assert(r != G6_heapbase, &quot;bad register choice&quot;);
3388     set((intptr_t)CompressedKlassPointers::base(), G6_heapbase);
3389     if (CompressedKlassPointers::shift() != 0)
3390       sllx(r, LogKlassAlignmentInBytes, r);
3391     add(r, G6_heapbase, r);
3392     reinit_heapbase();
3393   } else {
3394     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift() || CompressedKlassPointers::shift() == 0, &quot;decode alg wrong&quot;);
3395     sllx(r, CompressedKlassPointers::shift(), r);
3396   }
3397 }
3398 
3399 void  MacroAssembler::decode_klass_not_null(Register src, Register dst) {
3400   if (src == dst) {
3401     decode_klass_not_null(src);
3402   } else {
3403     // Do not add assert code to this unless you change vtableStubs_sparc.cpp
3404     // pd_code_size_limit.
3405     assert (UseCompressedClassPointers, &quot;must be compressed&quot;);
3406     if (CompressedKlassPointers::base() != NULL) {
3407       if (CompressedKlassPointers::shift() != 0) {
3408         assert((src != G6_heapbase) &amp;&amp; (dst != G6_heapbase), &quot;bad register choice&quot;);
3409         set((intptr_t)CompressedKlassPointers::base(), G6_heapbase);
3410         sllx(src, LogKlassAlignmentInBytes, dst);
3411         add(dst, G6_heapbase, dst);
3412         reinit_heapbase();
3413       } else {
3414         set((intptr_t)CompressedKlassPointers::base(), dst);
3415         add(src, dst, dst);
3416       }
3417     } else {
3418       // shift/mov src into dst.
3419       assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift() || CompressedKlassPointers::shift() == 0, &quot;decode alg wrong&quot;);
3420       sllx(src, CompressedKlassPointers::shift(), dst);
3421     }
3422   }
3423 }
3424 
3425 void MacroAssembler::reinit_heapbase() {
3426   if (UseCompressedOops || UseCompressedClassPointers) {
3427     if (Universe::heap() != NULL) {
3428       set((intptr_t)CompressedOops::ptrs_base(), G6_heapbase);
3429     } else {
3430       AddressLiteral base(CompressedOops::ptrs_base_addr());
3431       load_ptr_contents(base, G6_heapbase);
3432     }
3433   }
3434 }
3435 
<a name="2" id="anc2"></a>











































































































































































































































































































































































































































































































3436 // Use BIS for zeroing (count is in bytes).
3437 void MacroAssembler::bis_zeroing(Register to, Register count, Register temp, Label&amp; Ldone) {
3438   assert(UseBlockZeroing &amp;&amp; VM_Version::has_blk_zeroing(), &quot;only works with BIS zeroing&quot;);
3439   Register end = count;
3440   int cache_line_size = VM_Version::prefetch_data_size();
3441   assert(cache_line_size &gt; 0, &quot;cache line size should be known for this code&quot;);
3442   // Minimum count when BIS zeroing can be used since
3443   // it needs membar which is expensive.
3444   int block_zero_size  = MAX2(cache_line_size*3, (int)BlockZeroingLowLimit);
3445 
3446   Label small_loop;
3447   // Check if count is negative (dead code) or zero.
3448   // Note, count uses 64bit in 64 bit VM.
3449   cmp_and_brx_short(count, 0, Assembler::lessEqual, Assembler::pn, Ldone);
3450 
3451   // Use BIS zeroing only for big arrays since it requires membar.
3452   if (Assembler::is_simm13(block_zero_size)) { // &lt; 4096
3453     cmp(count, block_zero_size);
3454   } else {
3455     set(block_zero_size, temp);
3456     cmp(count, temp);
3457   }
3458   br(Assembler::lessUnsigned, false, Assembler::pt, small_loop);
3459   delayed()-&gt;add(to, count, end);
3460 
3461   // Note: size is &gt;= three (32 bytes) cache lines.
3462 
3463   // Clean the beginning of space up to next cache line.
3464   for (int offs = 0; offs &lt; cache_line_size; offs += 8) {
3465     stx(G0, to, offs);
3466   }
3467 
3468   // align to next cache line
3469   add(to, cache_line_size, to);
3470   and3(to, -cache_line_size, to);
3471 
3472   // Note: size left &gt;= two (32 bytes) cache lines.
3473 
3474   // BIS should not be used to zero tail (64 bytes)
3475   // to avoid zeroing a header of the following object.
3476   sub(end, (cache_line_size*2)-8, end);
3477 
3478   Label bis_loop;
3479   bind(bis_loop);
3480   stxa(G0, to, G0, Assembler::ASI_ST_BLKINIT_PRIMARY);
3481   add(to, cache_line_size, to);
3482   cmp_and_brx_short(to, end, Assembler::lessUnsigned, Assembler::pt, bis_loop);
3483 
3484   // BIS needs membar.
3485   membar(Assembler::StoreLoad);
3486 
3487   add(end, (cache_line_size*2)-8, end); // restore end
3488   cmp_and_brx_short(to, end, Assembler::greaterEqualUnsigned, Assembler::pn, Ldone);
3489 
3490   // Clean the tail.
3491   bind(small_loop);
3492   stx(G0, to, 0);
3493   add(to, 8, to);
3494   cmp_and_brx_short(to, end, Assembler::lessUnsigned, Assembler::pt, small_loop);
3495   nop(); // Separate short branches
3496 }
3497 
3498 /**
3499  * Update CRC-32[C] with a byte value according to constants in table
3500  *
3501  * @param [in,out]crc   Register containing the crc.
3502  * @param [in]val       Register containing the byte to fold into the CRC.
3503  * @param [in]table     Register containing the table of crc constants.
3504  *
3505  * uint32_t crc;
3506  * val = crc_table[(val ^ crc) &amp; 0xFF];
3507  * crc = val ^ (crc &gt;&gt; 8);
3508  */
3509 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
3510   xor3(val, crc, val);
3511   and3(val, 0xFF, val);
3512   sllx(val, 2, val);
3513   lduw(table, val, val);
3514   srlx(crc, 8, crc);
3515   xor3(val, crc, crc);
3516 }
3517 
3518 // Reverse byte order of lower 32 bits, assuming upper 32 bits all zeros
3519 void MacroAssembler::reverse_bytes_32(Register src, Register dst, Register tmp) {
3520     srlx(src, 24, dst);
3521 
3522     sllx(src, 32+8, tmp);
3523     srlx(tmp, 32+24, tmp);
3524     sllx(tmp, 8, tmp);
3525     or3(dst, tmp, dst);
3526 
3527     sllx(src, 32+16, tmp);
3528     srlx(tmp, 32+24, tmp);
3529     sllx(tmp, 16, tmp);
3530     or3(dst, tmp, dst);
3531 
3532     sllx(src, 32+24, tmp);
3533     srlx(tmp, 32, tmp);
3534     or3(dst, tmp, dst);
3535 }
3536 
3537 void MacroAssembler::movitof_revbytes(Register src, FloatRegister dst, Register tmp1, Register tmp2) {
3538   reverse_bytes_32(src, tmp1, tmp2);
3539   movxtod(tmp1, dst);
3540 }
3541 
3542 void MacroAssembler::movftoi_revbytes(FloatRegister src, Register dst, Register tmp1, Register tmp2) {
3543   movdtox(src, tmp1);
3544   reverse_bytes_32(tmp1, dst, tmp2);
3545 }
3546 
3547 void MacroAssembler::fold_128bit_crc32(Register xcrc_hi, Register xcrc_lo, Register xK_hi, Register xK_lo, Register xtmp_hi, Register xtmp_lo, Register buf, int offset) {
3548   xmulx(xcrc_hi, xK_hi, xtmp_lo);
3549   xmulxhi(xcrc_hi, xK_hi, xtmp_hi);
3550   xmulxhi(xcrc_lo, xK_lo, xcrc_hi);
3551   xmulx(xcrc_lo, xK_lo, xcrc_lo);
3552   xor3(xcrc_lo, xtmp_lo, xcrc_lo);
3553   xor3(xcrc_hi, xtmp_hi, xcrc_hi);
3554   ldxl(buf, G0, xtmp_lo);
3555   inc(buf, 8);
3556   ldxl(buf, G0, xtmp_hi);
3557   inc(buf, 8);
3558   xor3(xcrc_lo, xtmp_lo, xcrc_lo);
3559   xor3(xcrc_hi, xtmp_hi, xcrc_hi);
3560 }
3561 
3562 void MacroAssembler::fold_128bit_crc32(Register xcrc_hi, Register xcrc_lo, Register xK_hi, Register xK_lo, Register xtmp_hi, Register xtmp_lo, Register xbuf_hi, Register xbuf_lo) {
3563   mov(xcrc_lo, xtmp_lo);
3564   mov(xcrc_hi, xtmp_hi);
3565   xmulx(xtmp_hi, xK_hi, xtmp_lo);
3566   xmulxhi(xtmp_hi, xK_hi, xtmp_hi);
3567   xmulxhi(xcrc_lo, xK_lo, xcrc_hi);
3568   xmulx(xcrc_lo, xK_lo, xcrc_lo);
3569   xor3(xcrc_lo, xbuf_lo, xcrc_lo);
3570   xor3(xcrc_hi, xbuf_hi, xcrc_hi);
3571   xor3(xcrc_lo, xtmp_lo, xcrc_lo);
3572   xor3(xcrc_hi, xtmp_hi, xcrc_hi);
3573 }
3574 
3575 void MacroAssembler::fold_8bit_crc32(Register xcrc, Register table, Register xtmp, Register tmp) {
3576   and3(xcrc, 0xFF, tmp);
3577   sllx(tmp, 2, tmp);
3578   lduw(table, tmp, xtmp);
3579   srlx(xcrc, 8, xcrc);
3580   xor3(xtmp, xcrc, xcrc);
3581 }
3582 
3583 void MacroAssembler::fold_8bit_crc32(Register crc, Register table, Register tmp) {
3584   and3(crc, 0xFF, tmp);
3585   srlx(crc, 8, crc);
3586   sllx(tmp, 2, tmp);
3587   lduw(table, tmp, tmp);
3588   xor3(tmp, crc, crc);
3589 }
3590 
3591 #define CRC32_TMP_REG_NUM 18
3592 
3593 #define CRC32_CONST_64  0x163cd6124
3594 #define CRC32_CONST_96  0x0ccaa009e
3595 #define CRC32_CONST_160 0x1751997d0
3596 #define CRC32_CONST_480 0x1c6e41596
3597 #define CRC32_CONST_544 0x154442bd4
3598 
3599 void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len, Register table) {
3600 
3601   Label L_cleanup_loop, L_cleanup_check, L_align_loop, L_align_check;
3602   Label L_main_loop_prologue;
3603   Label L_fold_512b, L_fold_512b_loop, L_fold_128b;
3604   Label L_fold_tail, L_fold_tail_loop;
3605   Label L_8byte_fold_check;
3606 
3607   const Register tmp[CRC32_TMP_REG_NUM] = {L0, L1, L2, L3, L4, L5, L6, G1, I0, I1, I2, I3, I4, I5, I7, O4, O5, G3};
3608 
3609   Register const_64  = tmp[CRC32_TMP_REG_NUM-1];
3610   Register const_96  = tmp[CRC32_TMP_REG_NUM-1];
3611   Register const_160 = tmp[CRC32_TMP_REG_NUM-2];
3612   Register const_480 = tmp[CRC32_TMP_REG_NUM-1];
3613   Register const_544 = tmp[CRC32_TMP_REG_NUM-2];
3614 
3615   set(ExternalAddress(StubRoutines::crc_table_addr()), table);
3616 
3617   not1(crc); // ~c
3618   clruwu(crc); // clear upper 32 bits of crc
3619 
3620   // Check if below cutoff, proceed directly to cleanup code
3621   mov(31, G4);
3622   cmp_and_br_short(len, G4, Assembler::lessEqualUnsigned, Assembler::pt, L_cleanup_check);
3623 
3624   // Align buffer to 8 byte boundry
3625   mov(8, O5);
3626   and3(buf, 0x7, O4);
3627   sub(O5, O4, O5);
3628   and3(O5, 0x7, O5);
3629   sub(len, O5, len);
3630   ba(L_align_check);
3631   delayed()-&gt;nop();
3632 
3633   // Alignment loop, table look up method for up to 7 bytes
3634   bind(L_align_loop);
3635   ldub(buf, 0, O4);
3636   inc(buf);
3637   dec(O5);
3638   xor3(O4, crc, O4);
3639   and3(O4, 0xFF, O4);
3640   sllx(O4, 2, O4);
3641   lduw(table, O4, O4);
3642   srlx(crc, 8, crc);
3643   xor3(O4, crc, crc);
3644   bind(L_align_check);
3645   nop();
3646   cmp_and_br_short(O5, 0, Assembler::notEqual, Assembler::pt, L_align_loop);
3647 
3648   // Aligned on 64-bit (8-byte) boundry at this point
3649   // Check if still above cutoff (31-bytes)
3650   mov(31, G4);
3651   cmp_and_br_short(len, G4, Assembler::lessEqualUnsigned, Assembler::pt, L_cleanup_check);
3652   // At least 32 bytes left to process
3653 
3654   // Free up registers by storing them to FP registers
3655   for (int i = 0; i &lt; CRC32_TMP_REG_NUM; i++) {
3656     movxtod(tmp[i], as_FloatRegister(2*i));
3657   }
3658 
3659   // Determine which loop to enter
3660   // Shared prologue
3661   ldxl(buf, G0, tmp[0]);
3662   inc(buf, 8);
3663   ldxl(buf, G0, tmp[1]);
3664   inc(buf, 8);
3665   xor3(tmp[0], crc, tmp[0]); // Fold CRC into first few bytes
3666   and3(crc, 0, crc); // Clear out the crc register
3667   // Main loop needs 128-bytes at least
3668   mov(128, G4);
3669   mov(64, tmp[2]);
3670   cmp_and_br_short(len, G4, Assembler::greaterEqualUnsigned, Assembler::pt, L_main_loop_prologue);
3671   // Less than 64 bytes
3672   nop();
3673   cmp_and_br_short(len, tmp[2], Assembler::lessUnsigned, Assembler::pt, L_fold_tail);
3674   // Between 64 and 127 bytes
3675   set64(CRC32_CONST_96,  const_96,  tmp[8]);
3676   set64(CRC32_CONST_160, const_160, tmp[9]);
3677   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[2], tmp[3], buf, 0);
3678   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[4], tmp[5], buf, 16);
3679   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[6], tmp[7], buf, 32);
3680   dec(len, 48);
3681   ba(L_fold_tail);
3682   delayed()-&gt;nop();
3683 
3684   bind(L_main_loop_prologue);
3685   for (int i = 2; i &lt; 8; i++) {
3686     ldxl(buf, G0, tmp[i]);
3687     inc(buf, 8);
3688   }
3689 
3690   // Fold total 512 bits of polynomial on each iteration,
3691   // 128 bits per each of 4 parallel streams
3692   set64(CRC32_CONST_480, const_480, tmp[8]);
3693   set64(CRC32_CONST_544, const_544, tmp[9]);
3694 
3695   mov(128, G4);
3696   bind(L_fold_512b_loop);
3697   fold_128bit_crc32(tmp[1], tmp[0], const_480, const_544, tmp[9],  tmp[8],  buf,  0);
3698   fold_128bit_crc32(tmp[3], tmp[2], const_480, const_544, tmp[11], tmp[10], buf, 16);
3699   fold_128bit_crc32(tmp[5], tmp[4], const_480, const_544, tmp[13], tmp[12], buf, 32);
3700   fold_128bit_crc32(tmp[7], tmp[6], const_480, const_544, tmp[15], tmp[14], buf, 64);
3701   dec(len, 64);
3702   cmp_and_br_short(len, G4, Assembler::greaterEqualUnsigned, Assembler::pt, L_fold_512b_loop);
3703 
3704   // Fold 512 bits to 128 bits
3705   bind(L_fold_512b);
3706   set64(CRC32_CONST_96,  const_96,  tmp[8]);
3707   set64(CRC32_CONST_160, const_160, tmp[9]);
3708 
3709   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[8], tmp[9], tmp[3], tmp[2]);
3710   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[8], tmp[9], tmp[5], tmp[4]);
3711   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[8], tmp[9], tmp[7], tmp[6]);
3712   dec(len, 48);
3713 
3714   // Fold the rest of 128 bits data chunks
3715   bind(L_fold_tail);
3716   mov(32, G4);
3717   cmp_and_br_short(len, G4, Assembler::lessEqualUnsigned, Assembler::pt, L_fold_128b);
3718 
3719   set64(CRC32_CONST_96,  const_96,  tmp[8]);
3720   set64(CRC32_CONST_160, const_160, tmp[9]);
3721 
3722   bind(L_fold_tail_loop);
3723   fold_128bit_crc32(tmp[1], tmp[0], const_96, const_160, tmp[2], tmp[3], buf, 0);
3724   sub(len, 16, len);
3725   cmp_and_br_short(len, G4, Assembler::greaterEqualUnsigned, Assembler::pt, L_fold_tail_loop);
3726 
3727   // Fold the 128 bits in tmps 0 - 1 into tmp 1
3728   bind(L_fold_128b);
3729 
3730   set64(CRC32_CONST_64, const_64, tmp[4]);
3731 
3732   xmulx(const_64, tmp[0], tmp[2]);
3733   xmulxhi(const_64, tmp[0], tmp[3]);
3734 
3735   srl(tmp[2], G0, tmp[4]);
3736   xmulx(const_64, tmp[4], tmp[4]);
3737 
3738   srlx(tmp[2], 32, tmp[2]);
3739   sllx(tmp[3], 32, tmp[3]);
3740   or3(tmp[2], tmp[3], tmp[2]);
3741 
3742   xor3(tmp[4], tmp[1], tmp[4]);
3743   xor3(tmp[4], tmp[2], tmp[1]);
3744   dec(len, 8);
3745 
3746   // Use table lookup for the 8 bytes left in tmp[1]
3747   dec(len, 8);
3748 
3749   // 8 8-bit folds to compute 32-bit CRC.
3750   for (int j = 0; j &lt; 4; j++) {
3751     fold_8bit_crc32(tmp[1], table, tmp[2], tmp[3]);
3752   }
3753   srl(tmp[1], G0, crc); // move 32 bits to general register
3754   for (int j = 0; j &lt; 4; j++) {
3755     fold_8bit_crc32(crc, table, tmp[3]);
3756   }
3757 
3758   bind(L_8byte_fold_check);
3759 
3760   // Restore int registers saved in FP registers
3761   for (int i = 0; i &lt; CRC32_TMP_REG_NUM; i++) {
3762     movdtox(as_FloatRegister(2*i), tmp[i]);
3763   }
3764 
3765   ba(L_cleanup_check);
3766   delayed()-&gt;nop();
3767 
3768   // Table look-up method for the remaining few bytes
3769   bind(L_cleanup_loop);
3770   ldub(buf, 0, O4);
3771   inc(buf);
3772   dec(len);
3773   xor3(O4, crc, O4);
3774   and3(O4, 0xFF, O4);
3775   sllx(O4, 2, O4);
3776   lduw(table, O4, O4);
3777   srlx(crc, 8, crc);
3778   xor3(O4, crc, crc);
3779   bind(L_cleanup_check);
3780   nop();
3781   cmp_and_br_short(len, 0, Assembler::greaterUnsigned, Assembler::pt, L_cleanup_loop);
3782 
3783   not1(crc);
3784 }
3785 
3786 #define CHUNK_LEN   128          /* 128 x 8B = 1KB */
3787 #define CHUNK_K1    0x1307a0206  /* reverseBits(pow(x, CHUNK_LEN*8*8*3 - 32) mod P(x)) &lt;&lt; 1 */
3788 #define CHUNK_K2    0x1a0f717c4  /* reverseBits(pow(x, CHUNK_LEN*8*8*2 - 32) mod P(x)) &lt;&lt; 1 */
3789 #define CHUNK_K3    0x0170076fa  /* reverseBits(pow(x, CHUNK_LEN*8*8*1 - 32) mod P(x)) &lt;&lt; 1 */
3790 
3791 void MacroAssembler::kernel_crc32c(Register crc, Register buf, Register len, Register table) {
3792 
3793   Label L_crc32c_head, L_crc32c_aligned;
3794   Label L_crc32c_parallel, L_crc32c_parallel_loop;
3795   Label L_crc32c_serial, L_crc32c_x32_loop, L_crc32c_x8, L_crc32c_x8_loop;
3796   Label L_crc32c_done, L_crc32c_tail, L_crc32c_return;
3797 
3798   set(ExternalAddress(StubRoutines::crc32c_table_addr()), table);
3799 
3800   cmp_and_br_short(len, 0, Assembler::lessEqual, Assembler::pn, L_crc32c_return);
3801 
3802   // clear upper 32 bits of crc
3803   clruwu(crc);
3804 
3805   and3(buf, 7, G4);
3806   cmp_and_brx_short(G4, 0, Assembler::equal, Assembler::pt, L_crc32c_aligned);
3807 
3808   mov(8, G1);
3809   sub(G1, G4, G4);
3810 
3811   // ------ process the misaligned head (7 bytes or less) ------
3812   bind(L_crc32c_head);
3813 
3814   // crc = (crc &gt;&gt;&gt; 8) ^ byteTable[(crc ^ b) &amp; 0xFF];
3815   ldub(buf, 0, G1);
3816   update_byte_crc32(crc, G1, table);
3817 
3818   inc(buf);
3819   dec(len);
3820   cmp_and_br_short(len, 0, Assembler::equal, Assembler::pn, L_crc32c_return);
3821   dec(G4);
3822   cmp_and_br_short(G4, 0, Assembler::greater, Assembler::pt, L_crc32c_head);
3823 
3824   // ------ process the 8-byte-aligned body ------
3825   bind(L_crc32c_aligned);
3826   nop();
3827   cmp_and_br_short(len, 8, Assembler::less, Assembler::pn, L_crc32c_tail);
3828 
3829   // reverse the byte order of lower 32 bits to big endian, and move to FP side
3830   movitof_revbytes(crc, F0, G1, G3);
3831 
3832   set(CHUNK_LEN*8*4, G4);
3833   cmp_and_br_short(len, G4, Assembler::less, Assembler::pt, L_crc32c_serial);
3834 
3835   // ------ process four 1KB chunks in parallel ------
3836   bind(L_crc32c_parallel);
3837 
3838   fzero(FloatRegisterImpl::D, F2);
3839   fzero(FloatRegisterImpl::D, F4);
3840   fzero(FloatRegisterImpl::D, F6);
3841 
3842   mov(CHUNK_LEN - 1, G4);
3843   bind(L_crc32c_parallel_loop);
3844   // schedule ldf&#39;s ahead of crc32c&#39;s to hide the load-use latency
3845   ldf(FloatRegisterImpl::D, buf, 0,            F8);
3846   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*8,  F10);
3847   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*16, F12);
3848   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*24, F14);
3849   crc32c(F0, F8,  F0);
3850   crc32c(F2, F10, F2);
3851   crc32c(F4, F12, F4);
3852   crc32c(F6, F14, F6);
3853   inc(buf, 8);
3854   dec(G4);
3855   cmp_and_br_short(G4, 0, Assembler::greater, Assembler::pt, L_crc32c_parallel_loop);
3856 
3857   ldf(FloatRegisterImpl::D, buf, 0,            F8);
3858   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*8,  F10);
3859   ldf(FloatRegisterImpl::D, buf, CHUNK_LEN*16, F12);
3860   crc32c(F0, F8,  F0);
3861   crc32c(F2, F10, F2);
3862   crc32c(F4, F12, F4);
3863 
3864   inc(buf, CHUNK_LEN*24);
3865   ldfl(FloatRegisterImpl::D, buf, G0, F14);  // load in little endian
3866   inc(buf, 8);
3867 
3868   prefetch(buf, 0,            Assembler::severalReads);
3869   prefetch(buf, CHUNK_LEN*8,  Assembler::severalReads);
3870   prefetch(buf, CHUNK_LEN*16, Assembler::severalReads);
3871   prefetch(buf, CHUNK_LEN*24, Assembler::severalReads);
3872 
3873   // move to INT side, and reverse the byte order of lower 32 bits to little endian
3874   movftoi_revbytes(F0, O4, G1, G4);
3875   movftoi_revbytes(F2, O5, G1, G4);
3876   movftoi_revbytes(F4, G5, G1, G4);
3877 
3878   // combine the results of 4 chunks
3879   set64(CHUNK_K1, G3, G1);
3880   xmulx(O4, G3, O4);
3881   set64(CHUNK_K2, G3, G1);
3882   xmulx(O5, G3, O5);
3883   set64(CHUNK_K3, G3, G1);
3884   xmulx(G5, G3, G5);
3885 
3886   movdtox(F14, G4);
3887   xor3(O4, O5, O5);
3888   xor3(G5, O5, O5);
3889   xor3(G4, O5, O5);
3890 
3891   // reverse the byte order to big endian, via stack, and move to FP side
3892   // TODO: use new revb instruction
3893   add(SP, -8, G1);
3894   srlx(G1, 3, G1);
3895   sllx(G1, 3, G1);
3896   stx(O5, G1, G0);
3897   ldfl(FloatRegisterImpl::D, G1, G0, F2);  // load in little endian
3898 
3899   crc32c(F6, F2, F0);
3900 
3901   set(CHUNK_LEN*8*4, G4);
3902   sub(len, G4, len);
3903   cmp_and_br_short(len, G4, Assembler::greaterEqual, Assembler::pt, L_crc32c_parallel);
3904   nop();
3905   cmp_and_br_short(len, 0, Assembler::equal, Assembler::pt, L_crc32c_done);
3906 
3907   bind(L_crc32c_serial);
3908 
3909   mov(32, G4);
3910   cmp_and_br_short(len, G4, Assembler::less, Assembler::pn, L_crc32c_x8);
3911 
3912   // ------ process 32B chunks ------
3913   bind(L_crc32c_x32_loop);
3914   ldf(FloatRegisterImpl::D, buf, 0, F2);
3915   crc32c(F0, F2, F0);
3916   ldf(FloatRegisterImpl::D, buf, 8, F2);
3917   crc32c(F0, F2, F0);
3918   ldf(FloatRegisterImpl::D, buf, 16, F2);
3919   crc32c(F0, F2, F0);
3920   ldf(FloatRegisterImpl::D, buf, 24, F2);
3921   inc(buf, 32);
3922   crc32c(F0, F2, F0);
3923   dec(len, 32);
3924   cmp_and_br_short(len, G4, Assembler::greaterEqual, Assembler::pt, L_crc32c_x32_loop);
3925 
3926   bind(L_crc32c_x8);
3927   nop();
3928   cmp_and_br_short(len, 8, Assembler::less, Assembler::pt, L_crc32c_done);
3929 
3930   // ------ process 8B chunks ------
3931   bind(L_crc32c_x8_loop);
3932   ldf(FloatRegisterImpl::D, buf, 0, F2);
3933   inc(buf, 8);
3934   crc32c(F0, F2, F0);
3935   dec(len, 8);
3936   cmp_and_br_short(len, 8, Assembler::greaterEqual, Assembler::pt, L_crc32c_x8_loop);
3937 
3938   bind(L_crc32c_done);
3939 
3940   // move to INT side, and reverse the byte order of lower 32 bits to little endian
3941   movftoi_revbytes(F0, crc, G1, G3);
3942 
3943   cmp_and_br_short(len, 0, Assembler::equal, Assembler::pt, L_crc32c_return);
3944 
3945   // ------ process the misaligned tail (7 bytes or less) ------
3946   bind(L_crc32c_tail);
3947 
3948   // crc = (crc &gt;&gt;&gt; 8) ^ byteTable[(crc ^ b) &amp; 0xFF];
3949   ldub(buf, 0, G1);
3950   update_byte_crc32(crc, G1, table);
3951 
3952   inc(buf);
3953   dec(len);
3954   cmp_and_br_short(len, 0, Assembler::greater, Assembler::pt, L_crc32c_tail);
3955 
3956   bind(L_crc32c_return);
3957   nop();
3958 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
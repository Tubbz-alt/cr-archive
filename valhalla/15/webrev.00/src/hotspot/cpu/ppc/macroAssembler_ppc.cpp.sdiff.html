<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/ppc/macroAssembler_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../arm/macroAssembler_arm.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_ppc.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/macroAssembler_ppc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;compiler/disassembler.hpp&quot;
  29 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;nativeInst_ppc.hpp&quot;
  35 #include &quot;oops/klass.inline.hpp&quot;

  36 #include &quot;prims/methodHandles.hpp&quot;
  37 #include &quot;runtime/biasedLocking.hpp&quot;
  38 #include &quot;runtime/icache.hpp&quot;
  39 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  40 #include &quot;runtime/objectMonitor.hpp&quot;
  41 #include &quot;runtime/os.hpp&quot;
  42 #include &quot;runtime/safepoint.hpp&quot;
  43 #include &quot;runtime/safepointMechanism.hpp&quot;
  44 #include &quot;runtime/sharedRuntime.hpp&quot;
  45 #include &quot;runtime/stubRoutines.hpp&quot;
  46 #include &quot;utilities/macros.hpp&quot;
  47 #include &quot;utilities/powerOfTwo.hpp&quot;
<span class="line-removed">  48 #ifdef COMPILER2</span>
<span class="line-removed">  49 #include &quot;opto/intrinsicnode.hpp&quot;</span>
<span class="line-removed">  50 #endif</span>
  51 
  52 #ifdef PRODUCT
  53 #define BLOCK_COMMENT(str) // nothing
  54 #else
  55 #define BLOCK_COMMENT(str) block_comment(str)
  56 #endif
  57 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  58 
  59 #ifdef ASSERT
  60 // On RISC, there&#39;s no benefit to verifying instruction boundaries.
  61 bool AbstractAssembler::pd_check_instruction_mark() { return false; }
  62 #endif
  63 
  64 void MacroAssembler::ld_largeoffset_unchecked(Register d, int si31, Register a, int emit_filler_nop) {
  65   assert(Assembler::is_simm(si31, 31) &amp;&amp; si31 &gt;= 0, &quot;si31 out of range&quot;);
  66   if (Assembler::is_simm(si31, 16)) {
  67     ld(d, si31, a);
  68     if (emit_filler_nop) nop();
  69   } else {
  70     const int hi = MacroAssembler::largeoffset_si16_si16_hi(si31);
</pre>
<hr />
<pre>
3294     dcbz(base_ptr);                    // Clear 128byte aligned block.
3295     addi(base_ptr, base_ptr, cl_size);
3296     bdnz(fastloop);
3297 
3298   bind(small_rest);
3299     cmpdi(CCR0, cnt_dwords, 0);        // size 0?
3300     beq(CCR0, done);                   // rest == 0
3301     li(tmp, 0);
3302     mtctr(cnt_dwords);                 // Load counter.
3303 
3304   bind(restloop);                      // Clear rest.
3305     std(tmp, 0, base_ptr);             // Clear 8byte aligned block.
3306     addi(base_ptr, base_ptr, 8);
3307     bdnz(restloop);
3308 
3309   bind(done);
3310 }
3311 
3312 /////////////////////////////////////////// String intrinsics ////////////////////////////////////////////
3313 
<span class="line-removed">3314 #ifdef COMPILER2</span>
<span class="line-removed">3315 // Intrinsics for CompactStrings</span>
<span class="line-removed">3316 </span>
<span class="line-removed">3317 // Compress char[] to byte[] by compressing 16 bytes at once.</span>
<span class="line-removed">3318 void MacroAssembler::string_compress_16(Register src, Register dst, Register cnt,</span>
<span class="line-removed">3319                                         Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5,</span>
<span class="line-removed">3320                                         Label&amp; Lfailure) {</span>
<span class="line-removed">3321 </span>
<span class="line-removed">3322   const Register tmp0 = R0;</span>
<span class="line-removed">3323   assert_different_registers(src, dst, cnt, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5);</span>
<span class="line-removed">3324   Label Lloop, Lslow;</span>
<span class="line-removed">3325 </span>
<span class="line-removed">3326   // Check if cnt &gt;= 8 (= 16 bytes)</span>
<span class="line-removed">3327   lis(tmp1, 0xFF);                // tmp1 = 0x00FF00FF00FF00FF</span>
<span class="line-removed">3328   srwi_(tmp2, cnt, 3);</span>
<span class="line-removed">3329   beq(CCR0, Lslow);</span>
<span class="line-removed">3330   ori(tmp1, tmp1, 0xFF);</span>
<span class="line-removed">3331   rldimi(tmp1, tmp1, 32, 0);</span>
<span class="line-removed">3332   mtctr(tmp2);</span>
<span class="line-removed">3333 </span>
<span class="line-removed">3334   // 2x unrolled loop</span>
<span class="line-removed">3335   bind(Lloop);</span>
<span class="line-removed">3336   ld(tmp2, 0, src);               // _0_1_2_3 (Big Endian)</span>
<span class="line-removed">3337   ld(tmp4, 8, src);               // _4_5_6_7</span>
<span class="line-removed">3338 </span>
<span class="line-removed">3339   orr(tmp0, tmp2, tmp4);</span>
<span class="line-removed">3340   rldicl(tmp3, tmp2, 6*8, 64-24); // _____1_2</span>
<span class="line-removed">3341   rldimi(tmp2, tmp2, 2*8, 2*8);   // _0_2_3_3</span>
<span class="line-removed">3342   rldicl(tmp5, tmp4, 6*8, 64-24); // _____5_6</span>
<span class="line-removed">3343   rldimi(tmp4, tmp4, 2*8, 2*8);   // _4_6_7_7</span>
<span class="line-removed">3344 </span>
<span class="line-removed">3345   andc_(tmp0, tmp0, tmp1);</span>
<span class="line-removed">3346   bne(CCR0, Lfailure);            // Not latin1.</span>
<span class="line-removed">3347   addi(src, src, 16);</span>
<span class="line-removed">3348 </span>
<span class="line-removed">3349   rlwimi(tmp3, tmp2, 0*8, 24, 31);// _____1_3</span>
<span class="line-removed">3350   srdi(tmp2, tmp2, 3*8);          // ____0_2_</span>
<span class="line-removed">3351   rlwimi(tmp5, tmp4, 0*8, 24, 31);// _____5_7</span>
<span class="line-removed">3352   srdi(tmp4, tmp4, 3*8);          // ____4_6_</span>
<span class="line-removed">3353 </span>
<span class="line-removed">3354   orr(tmp2, tmp2, tmp3);          // ____0123</span>
<span class="line-removed">3355   orr(tmp4, tmp4, tmp5);          // ____4567</span>
<span class="line-removed">3356 </span>
<span class="line-removed">3357   stw(tmp2, 0, dst);</span>
<span class="line-removed">3358   stw(tmp4, 4, dst);</span>
<span class="line-removed">3359   addi(dst, dst, 8);</span>
<span class="line-removed">3360   bdnz(Lloop);</span>
<span class="line-removed">3361 </span>
<span class="line-removed">3362   bind(Lslow);                    // Fallback to slow version</span>
<span class="line-removed">3363 }</span>
<span class="line-removed">3364 </span>
<span class="line-removed">3365 // Compress char[] to byte[]. cnt must be positive int.</span>
<span class="line-removed">3366 void MacroAssembler::string_compress(Register src, Register dst, Register cnt, Register tmp, Label&amp; Lfailure) {</span>
<span class="line-removed">3367   Label Lloop;</span>
<span class="line-removed">3368   mtctr(cnt);</span>
<span class="line-removed">3369 </span>
<span class="line-removed">3370   bind(Lloop);</span>
<span class="line-removed">3371   lhz(tmp, 0, src);</span>
<span class="line-removed">3372   cmplwi(CCR0, tmp, 0xff);</span>
<span class="line-removed">3373   bgt(CCR0, Lfailure);            // Not latin1.</span>
<span class="line-removed">3374   addi(src, src, 2);</span>
<span class="line-removed">3375   stb(tmp, 0, dst);</span>
<span class="line-removed">3376   addi(dst, dst, 1);</span>
<span class="line-removed">3377   bdnz(Lloop);</span>
<span class="line-removed">3378 }</span>
<span class="line-removed">3379 </span>
<span class="line-removed">3380 // Inflate byte[] to char[] by inflating 16 bytes at once.</span>
<span class="line-removed">3381 void MacroAssembler::string_inflate_16(Register src, Register dst, Register cnt,</span>
<span class="line-removed">3382                                        Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5) {</span>
<span class="line-removed">3383   const Register tmp0 = R0;</span>
<span class="line-removed">3384   assert_different_registers(src, dst, cnt, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5);</span>
<span class="line-removed">3385   Label Lloop, Lslow;</span>
<span class="line-removed">3386 </span>
<span class="line-removed">3387   // Check if cnt &gt;= 8</span>
<span class="line-removed">3388   srwi_(tmp2, cnt, 3);</span>
<span class="line-removed">3389   beq(CCR0, Lslow);</span>
<span class="line-removed">3390   lis(tmp1, 0xFF);                // tmp1 = 0x00FF00FF</span>
<span class="line-removed">3391   ori(tmp1, tmp1, 0xFF);</span>
<span class="line-removed">3392   mtctr(tmp2);</span>
<span class="line-removed">3393 </span>
<span class="line-removed">3394   // 2x unrolled loop</span>
<span class="line-removed">3395   bind(Lloop);</span>
<span class="line-removed">3396   lwz(tmp2, 0, src);              // ____0123 (Big Endian)</span>
<span class="line-removed">3397   lwz(tmp4, 4, src);              // ____4567</span>
<span class="line-removed">3398   addi(src, src, 8);</span>
<span class="line-removed">3399 </span>
<span class="line-removed">3400   rldicl(tmp3, tmp2, 7*8, 64-8);  // _______2</span>
<span class="line-removed">3401   rlwimi(tmp2, tmp2, 3*8, 16, 23);// ____0113</span>
<span class="line-removed">3402   rldicl(tmp5, tmp4, 7*8, 64-8);  // _______6</span>
<span class="line-removed">3403   rlwimi(tmp4, tmp4, 3*8, 16, 23);// ____4557</span>
<span class="line-removed">3404 </span>
<span class="line-removed">3405   andc(tmp0, tmp2, tmp1);         // ____0_1_</span>
<span class="line-removed">3406   rlwimi(tmp2, tmp3, 2*8, 0, 23); // _____2_3</span>
<span class="line-removed">3407   andc(tmp3, tmp4, tmp1);         // ____4_5_</span>
<span class="line-removed">3408   rlwimi(tmp4, tmp5, 2*8, 0, 23); // _____6_7</span>
<span class="line-removed">3409 </span>
<span class="line-removed">3410   rldimi(tmp2, tmp0, 3*8, 0*8);   // _0_1_2_3</span>
<span class="line-removed">3411   rldimi(tmp4, tmp3, 3*8, 0*8);   // _4_5_6_7</span>
<span class="line-removed">3412 </span>
<span class="line-removed">3413   std(tmp2, 0, dst);</span>
<span class="line-removed">3414   std(tmp4, 8, dst);</span>
<span class="line-removed">3415   addi(dst, dst, 16);</span>
<span class="line-removed">3416   bdnz(Lloop);</span>
<span class="line-removed">3417 </span>
<span class="line-removed">3418   bind(Lslow);                    // Fallback to slow version</span>
<span class="line-removed">3419 }</span>
<span class="line-removed">3420 </span>
<span class="line-removed">3421 // Inflate byte[] to char[]. cnt must be positive int.</span>
<span class="line-removed">3422 void MacroAssembler::string_inflate(Register src, Register dst, Register cnt, Register tmp) {</span>
<span class="line-removed">3423   Label Lloop;</span>
<span class="line-removed">3424   mtctr(cnt);</span>
<span class="line-removed">3425 </span>
<span class="line-removed">3426   bind(Lloop);</span>
<span class="line-removed">3427   lbz(tmp, 0, src);</span>
<span class="line-removed">3428   addi(src, src, 1);</span>
<span class="line-removed">3429   sth(tmp, 0, dst);</span>
<span class="line-removed">3430   addi(dst, dst, 2);</span>
<span class="line-removed">3431   bdnz(Lloop);</span>
<span class="line-removed">3432 }</span>
<span class="line-removed">3433 </span>
<span class="line-removed">3434 void MacroAssembler::string_compare(Register str1, Register str2,</span>
<span class="line-removed">3435                                     Register cnt1, Register cnt2,</span>
<span class="line-removed">3436                                     Register tmp1, Register result, int ae) {</span>
<span class="line-removed">3437   const Register tmp0 = R0,</span>
<span class="line-removed">3438                  diff = tmp1;</span>
<span class="line-removed">3439 </span>
<span class="line-removed">3440   assert_different_registers(str1, str2, cnt1, cnt2, tmp0, tmp1, result);</span>
<span class="line-removed">3441   Label Ldone, Lslow, Lloop, Lreturn_diff;</span>
<span class="line-removed">3442 </span>
<span class="line-removed">3443   // Note: Making use of the fact that compareTo(a, b) == -compareTo(b, a)</span>
<span class="line-removed">3444   // we interchange str1 and str2 in the UL case and negate the result.</span>
<span class="line-removed">3445   // Like this, str1 is always latin1 encoded, except for the UU case.</span>
<span class="line-removed">3446   // In addition, we need 0 (or sign which is 0) extend.</span>
<span class="line-removed">3447 </span>
<span class="line-removed">3448   if (ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">3449     srwi(cnt1, cnt1, 1);</span>
<span class="line-removed">3450   } else {</span>
<span class="line-removed">3451     clrldi(cnt1, cnt1, 32);</span>
<span class="line-removed">3452   }</span>
<span class="line-removed">3453 </span>
<span class="line-removed">3454   if (ae != StrIntrinsicNode::LL) {</span>
<span class="line-removed">3455     srwi(cnt2, cnt2, 1);</span>
<span class="line-removed">3456   } else {</span>
<span class="line-removed">3457     clrldi(cnt2, cnt2, 32);</span>
<span class="line-removed">3458   }</span>
<span class="line-removed">3459 </span>
<span class="line-removed">3460   // See if the lengths are different, and calculate min in cnt1.</span>
<span class="line-removed">3461   // Save diff in case we need it for a tie-breaker.</span>
<span class="line-removed">3462   subf_(diff, cnt2, cnt1); // diff = cnt1 - cnt2</span>
<span class="line-removed">3463   // if (diff &gt; 0) { cnt1 = cnt2; }</span>
<span class="line-removed">3464   if (VM_Version::has_isel()) {</span>
<span class="line-removed">3465     isel(cnt1, CCR0, Assembler::greater, /*invert*/ false, cnt2);</span>
<span class="line-removed">3466   } else {</span>
<span class="line-removed">3467     Label Lskip;</span>
<span class="line-removed">3468     blt(CCR0, Lskip);</span>
<span class="line-removed">3469     mr(cnt1, cnt2);</span>
<span class="line-removed">3470     bind(Lskip);</span>
<span class="line-removed">3471   }</span>
<span class="line-removed">3472 </span>
<span class="line-removed">3473   // Rename registers</span>
<span class="line-removed">3474   Register chr1 = result;</span>
<span class="line-removed">3475   Register chr2 = tmp0;</span>
<span class="line-removed">3476 </span>
<span class="line-removed">3477   // Compare multiple characters in fast loop (only implemented for same encoding).</span>
<span class="line-removed">3478   int stride1 = 8, stride2 = 8;</span>
<span class="line-removed">3479   if (ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UU) {</span>
<span class="line-removed">3480     int log2_chars_per_iter = (ae == StrIntrinsicNode::LL) ? 3 : 2;</span>
<span class="line-removed">3481     Label Lfastloop, Lskipfast;</span>
<span class="line-removed">3482 </span>
<span class="line-removed">3483     srwi_(tmp0, cnt1, log2_chars_per_iter);</span>
<span class="line-removed">3484     beq(CCR0, Lskipfast);</span>
<span class="line-removed">3485     rldicl(cnt2, cnt1, 0, 64 - log2_chars_per_iter); // Remaining characters.</span>
<span class="line-removed">3486     li(cnt1, 1 &lt;&lt; log2_chars_per_iter); // Initialize for failure case: Rescan characters from current iteration.</span>
<span class="line-removed">3487     mtctr(tmp0);</span>
<span class="line-removed">3488 </span>
<span class="line-removed">3489     bind(Lfastloop);</span>
<span class="line-removed">3490     ld(chr1, 0, str1);</span>
<span class="line-removed">3491     ld(chr2, 0, str2);</span>
<span class="line-removed">3492     cmpd(CCR0, chr1, chr2);</span>
<span class="line-removed">3493     bne(CCR0, Lslow);</span>
<span class="line-removed">3494     addi(str1, str1, stride1);</span>
<span class="line-removed">3495     addi(str2, str2, stride2);</span>
<span class="line-removed">3496     bdnz(Lfastloop);</span>
<span class="line-removed">3497     mr(cnt1, cnt2); // Remaining characters.</span>
<span class="line-removed">3498     bind(Lskipfast);</span>
<span class="line-removed">3499   }</span>
<span class="line-removed">3500 </span>
<span class="line-removed">3501   // Loop which searches the first difference character by character.</span>
<span class="line-removed">3502   cmpwi(CCR0, cnt1, 0);</span>
<span class="line-removed">3503   beq(CCR0, Lreturn_diff);</span>
<span class="line-removed">3504   bind(Lslow);</span>
<span class="line-removed">3505   mtctr(cnt1);</span>
<span class="line-removed">3506 </span>
<span class="line-removed">3507   switch (ae) {</span>
<span class="line-removed">3508     case StrIntrinsicNode::LL: stride1 = 1; stride2 = 1; break;</span>
<span class="line-removed">3509     case StrIntrinsicNode::UL: // fallthru (see comment above)</span>
<span class="line-removed">3510     case StrIntrinsicNode::LU: stride1 = 1; stride2 = 2; break;</span>
<span class="line-removed">3511     case StrIntrinsicNode::UU: stride1 = 2; stride2 = 2; break;</span>
<span class="line-removed">3512     default: ShouldNotReachHere(); break;</span>
<span class="line-removed">3513   }</span>
<span class="line-removed">3514 </span>
<span class="line-removed">3515   bind(Lloop);</span>
<span class="line-removed">3516   if (stride1 == 1) { lbz(chr1, 0, str1); } else { lhz(chr1, 0, str1); }</span>
<span class="line-removed">3517   if (stride2 == 1) { lbz(chr2, 0, str2); } else { lhz(chr2, 0, str2); }</span>
<span class="line-removed">3518   subf_(result, chr2, chr1); // result = chr1 - chr2</span>
<span class="line-removed">3519   bne(CCR0, Ldone);</span>
<span class="line-removed">3520   addi(str1, str1, stride1);</span>
<span class="line-removed">3521   addi(str2, str2, stride2);</span>
<span class="line-removed">3522   bdnz(Lloop);</span>
<span class="line-removed">3523 </span>
<span class="line-removed">3524   // If strings are equal up to min length, return the length difference.</span>
<span class="line-removed">3525   bind(Lreturn_diff);</span>
<span class="line-removed">3526   mr(result, diff);</span>
<span class="line-removed">3527 </span>
<span class="line-removed">3528   // Otherwise, return the difference between the first mismatched chars.</span>
<span class="line-removed">3529   bind(Ldone);</span>
<span class="line-removed">3530   if (ae == StrIntrinsicNode::UL) {</span>
<span class="line-removed">3531     neg(result, result); // Negate result (see note above).</span>
<span class="line-removed">3532   }</span>
<span class="line-removed">3533 }</span>
<span class="line-removed">3534 </span>
<span class="line-removed">3535 void MacroAssembler::array_equals(bool is_array_equ, Register ary1, Register ary2,</span>
<span class="line-removed">3536                                   Register limit, Register tmp1, Register result, bool is_byte) {</span>
<span class="line-removed">3537   const Register tmp0 = R0;</span>
<span class="line-removed">3538   assert_different_registers(ary1, ary2, limit, tmp0, tmp1, result);</span>
<span class="line-removed">3539   Label Ldone, Lskiploop, Lloop, Lfastloop, Lskipfast;</span>
<span class="line-removed">3540   bool limit_needs_shift = false;</span>
<span class="line-removed">3541 </span>
<span class="line-removed">3542   if (is_array_equ) {</span>
<span class="line-removed">3543     const int length_offset = arrayOopDesc::length_offset_in_bytes();</span>
<span class="line-removed">3544     const int base_offset   = arrayOopDesc::base_offset_in_bytes(is_byte ? T_BYTE : T_CHAR);</span>
<span class="line-removed">3545 </span>
<span class="line-removed">3546     // Return true if the same array.</span>
<span class="line-removed">3547     cmpd(CCR0, ary1, ary2);</span>
<span class="line-removed">3548     beq(CCR0, Lskiploop);</span>
<span class="line-removed">3549 </span>
<span class="line-removed">3550     // Return false if one of them is NULL.</span>
<span class="line-removed">3551     cmpdi(CCR0, ary1, 0);</span>
<span class="line-removed">3552     cmpdi(CCR1, ary2, 0);</span>
<span class="line-removed">3553     li(result, 0);</span>
<span class="line-removed">3554     cror(CCR0, Assembler::equal, CCR1, Assembler::equal);</span>
<span class="line-removed">3555     beq(CCR0, Ldone);</span>
<span class="line-removed">3556 </span>
<span class="line-removed">3557     // Load the lengths of arrays.</span>
<span class="line-removed">3558     lwz(limit, length_offset, ary1);</span>
<span class="line-removed">3559     lwz(tmp0, length_offset, ary2);</span>
<span class="line-removed">3560 </span>
<span class="line-removed">3561     // Return false if the two arrays are not equal length.</span>
<span class="line-removed">3562     cmpw(CCR0, limit, tmp0);</span>
<span class="line-removed">3563     bne(CCR0, Ldone);</span>
<span class="line-removed">3564 </span>
<span class="line-removed">3565     // Load array addresses.</span>
<span class="line-removed">3566     addi(ary1, ary1, base_offset);</span>
<span class="line-removed">3567     addi(ary2, ary2, base_offset);</span>
<span class="line-removed">3568   } else {</span>
<span class="line-removed">3569     limit_needs_shift = !is_byte;</span>
<span class="line-removed">3570     li(result, 0); // Assume not equal.</span>
<span class="line-removed">3571   }</span>
<span class="line-removed">3572 </span>
<span class="line-removed">3573   // Rename registers</span>
<span class="line-removed">3574   Register chr1 = tmp0;</span>
<span class="line-removed">3575   Register chr2 = tmp1;</span>
<span class="line-removed">3576 </span>
<span class="line-removed">3577   // Compare 8 bytes per iteration in fast loop.</span>
<span class="line-removed">3578   const int log2_chars_per_iter = is_byte ? 3 : 2;</span>
<span class="line-removed">3579 </span>
<span class="line-removed">3580   srwi_(tmp0, limit, log2_chars_per_iter + (limit_needs_shift ? 1 : 0));</span>
<span class="line-removed">3581   beq(CCR0, Lskipfast);</span>
<span class="line-removed">3582   mtctr(tmp0);</span>
<span class="line-removed">3583 </span>
<span class="line-removed">3584   bind(Lfastloop);</span>
<span class="line-removed">3585   ld(chr1, 0, ary1);</span>
<span class="line-removed">3586   ld(chr2, 0, ary2);</span>
<span class="line-removed">3587   addi(ary1, ary1, 8);</span>
<span class="line-removed">3588   addi(ary2, ary2, 8);</span>
<span class="line-removed">3589   cmpd(CCR0, chr1, chr2);</span>
<span class="line-removed">3590   bne(CCR0, Ldone);</span>
<span class="line-removed">3591   bdnz(Lfastloop);</span>
<span class="line-removed">3592 </span>
<span class="line-removed">3593   bind(Lskipfast);</span>
<span class="line-removed">3594   rldicl_(limit, limit, limit_needs_shift ? 64 - 1 : 0, 64 - log2_chars_per_iter); // Remaining characters.</span>
<span class="line-removed">3595   beq(CCR0, Lskiploop);</span>
<span class="line-removed">3596   mtctr(limit);</span>
<span class="line-removed">3597 </span>
<span class="line-removed">3598   // Character by character.</span>
<span class="line-removed">3599   bind(Lloop);</span>
<span class="line-removed">3600   if (is_byte) {</span>
<span class="line-removed">3601     lbz(chr1, 0, ary1);</span>
<span class="line-removed">3602     lbz(chr2, 0, ary2);</span>
<span class="line-removed">3603     addi(ary1, ary1, 1);</span>
<span class="line-removed">3604     addi(ary2, ary2, 1);</span>
<span class="line-removed">3605   } else {</span>
<span class="line-removed">3606     lhz(chr1, 0, ary1);</span>
<span class="line-removed">3607     lhz(chr2, 0, ary2);</span>
<span class="line-removed">3608     addi(ary1, ary1, 2);</span>
<span class="line-removed">3609     addi(ary2, ary2, 2);</span>
<span class="line-removed">3610   }</span>
<span class="line-removed">3611   cmpw(CCR0, chr1, chr2);</span>
<span class="line-removed">3612   bne(CCR0, Ldone);</span>
<span class="line-removed">3613   bdnz(Lloop);</span>
<span class="line-removed">3614 </span>
<span class="line-removed">3615   bind(Lskiploop);</span>
<span class="line-removed">3616   li(result, 1); // All characters are equal.</span>
<span class="line-removed">3617   bind(Ldone);</span>
<span class="line-removed">3618 }</span>
<span class="line-removed">3619 </span>
<span class="line-removed">3620 void MacroAssembler::string_indexof(Register result, Register haystack, Register haycnt,</span>
<span class="line-removed">3621                                     Register needle, ciTypeArray* needle_values, Register needlecnt, int needlecntval,</span>
<span class="line-removed">3622                                     Register tmp1, Register tmp2, Register tmp3, Register tmp4, int ae) {</span>
<span class="line-removed">3623 </span>
<span class="line-removed">3624   // Ensure 0&lt;needlecnt&lt;=haycnt in ideal graph as prerequisite!</span>
<span class="line-removed">3625   Label L_TooShort, L_Found, L_NotFound, L_End;</span>
<span class="line-removed">3626   Register last_addr = haycnt, // Kill haycnt at the beginning.</span>
<span class="line-removed">3627   addr      = tmp1,</span>
<span class="line-removed">3628   n_start   = tmp2,</span>
<span class="line-removed">3629   ch1       = tmp3,</span>
<span class="line-removed">3630   ch2       = R0;</span>
<span class="line-removed">3631 </span>
<span class="line-removed">3632   assert(ae != StrIntrinsicNode::LU, &quot;Invalid encoding&quot;);</span>
<span class="line-removed">3633   const int h_csize = (ae == StrIntrinsicNode::LL) ? 1 : 2;</span>
<span class="line-removed">3634   const int n_csize = (ae == StrIntrinsicNode::UU) ? 2 : 1;</span>
<span class="line-removed">3635 </span>
<span class="line-removed">3636   // **************************************************************************************************</span>
<span class="line-removed">3637   // Prepare for main loop: optimized for needle count &gt;=2, bail out otherwise.</span>
<span class="line-removed">3638   // **************************************************************************************************</span>
<span class="line-removed">3639 </span>
<span class="line-removed">3640   // Compute last haystack addr to use if no match gets found.</span>
<span class="line-removed">3641   clrldi(haycnt, haycnt, 32);         // Ensure positive int is valid as 64 bit value.</span>
<span class="line-removed">3642   addi(addr, haystack, -h_csize);     // Accesses use pre-increment.</span>
<span class="line-removed">3643   if (needlecntval == 0) { // variable needlecnt</span>
<span class="line-removed">3644    cmpwi(CCR6, needlecnt, 2);</span>
<span class="line-removed">3645    clrldi(needlecnt, needlecnt, 32);  // Ensure positive int is valid as 64 bit value.</span>
<span class="line-removed">3646    blt(CCR6, L_TooShort);             // Variable needlecnt: handle short needle separately.</span>
<span class="line-removed">3647   }</span>
<span class="line-removed">3648 </span>
<span class="line-removed">3649   if (n_csize == 2) { lwz(n_start, 0, needle); } else { lhz(n_start, 0, needle); } // Load first 2 characters of needle.</span>
<span class="line-removed">3650 </span>
<span class="line-removed">3651   if (needlecntval == 0) { // variable needlecnt</span>
<span class="line-removed">3652    subf(ch1, needlecnt, haycnt);      // Last character index to compare is haycnt-needlecnt.</span>
<span class="line-removed">3653    addi(needlecnt, needlecnt, -2);    // Rest of needle.</span>
<span class="line-removed">3654   } else { // constant needlecnt</span>
<span class="line-removed">3655   guarantee(needlecntval != 1, &quot;IndexOf with single-character needle must be handled separately&quot;);</span>
<span class="line-removed">3656   assert((needlecntval &amp; 0x7fff) == needlecntval, &quot;wrong immediate&quot;);</span>
<span class="line-removed">3657    addi(ch1, haycnt, -needlecntval);  // Last character index to compare is haycnt-needlecnt.</span>
<span class="line-removed">3658    if (needlecntval &gt; 3) { li(needlecnt, needlecntval - 2); } // Rest of needle.</span>
<span class="line-removed">3659   }</span>
<span class="line-removed">3660 </span>
<span class="line-removed">3661   if (h_csize == 2) { slwi(ch1, ch1, 1); } // Scale to number of bytes.</span>
<span class="line-removed">3662 </span>
<span class="line-removed">3663   if (ae ==StrIntrinsicNode::UL) {</span>
<span class="line-removed">3664    srwi(tmp4, n_start, 1*8);          // ___0</span>
<span class="line-removed">3665    rlwimi(n_start, tmp4, 2*8, 0, 23); // _0_1</span>
<span class="line-removed">3666   }</span>
<span class="line-removed">3667 </span>
<span class="line-removed">3668   add(last_addr, haystack, ch1);      // Point to last address to compare (haystack+2*(haycnt-needlecnt)).</span>
<span class="line-removed">3669 </span>
<span class="line-removed">3670   // Main Loop (now we have at least 2 characters).</span>
<span class="line-removed">3671   Label L_OuterLoop, L_InnerLoop, L_FinalCheck, L_Comp1, L_Comp2;</span>
<span class="line-removed">3672   bind(L_OuterLoop); // Search for 1st 2 characters.</span>
<span class="line-removed">3673   Register addr_diff = tmp4;</span>
<span class="line-removed">3674    subf(addr_diff, addr, last_addr);  // Difference between already checked address and last address to check.</span>
<span class="line-removed">3675    addi(addr, addr, h_csize);         // This is the new address we want to use for comparing.</span>
<span class="line-removed">3676    srdi_(ch2, addr_diff, h_csize);</span>
<span class="line-removed">3677    beq(CCR0, L_FinalCheck);           // 2 characters left?</span>
<span class="line-removed">3678    mtctr(ch2);                        // num of characters / 2</span>
<span class="line-removed">3679   bind(L_InnerLoop);                  // Main work horse (2x unrolled search loop)</span>
<span class="line-removed">3680    if (h_csize == 2) {                // Load 2 characters of haystack (ignore alignment).</span>
<span class="line-removed">3681     lwz(ch1, 0, addr);</span>
<span class="line-removed">3682     lwz(ch2, 2, addr);</span>
<span class="line-removed">3683    } else {</span>
<span class="line-removed">3684     lhz(ch1, 0, addr);</span>
<span class="line-removed">3685     lhz(ch2, 1, addr);</span>
<span class="line-removed">3686    }</span>
<span class="line-removed">3687    cmpw(CCR0, ch1, n_start);          // Compare 2 characters (1 would be sufficient but try to reduce branches to CompLoop).</span>
<span class="line-removed">3688    cmpw(CCR1, ch2, n_start);</span>
<span class="line-removed">3689    beq(CCR0, L_Comp1);                // Did we find the needle start?</span>
<span class="line-removed">3690    beq(CCR1, L_Comp2);</span>
<span class="line-removed">3691    addi(addr, addr, 2 * h_csize);</span>
<span class="line-removed">3692    bdnz(L_InnerLoop);</span>
<span class="line-removed">3693   bind(L_FinalCheck);</span>
<span class="line-removed">3694    andi_(addr_diff, addr_diff, h_csize); // Remaining characters not covered by InnerLoop: (num of characters) &amp; 1.</span>
<span class="line-removed">3695    beq(CCR0, L_NotFound);</span>
<span class="line-removed">3696    if (h_csize == 2) { lwz(ch1, 0, addr); } else { lhz(ch1, 0, addr); } // One position left at which we have to compare.</span>
<span class="line-removed">3697    cmpw(CCR1, ch1, n_start);</span>
<span class="line-removed">3698    beq(CCR1, L_Comp1);</span>
<span class="line-removed">3699   bind(L_NotFound);</span>
<span class="line-removed">3700    li(result, -1);                    // not found</span>
<span class="line-removed">3701    b(L_End);</span>
<span class="line-removed">3702 </span>
<span class="line-removed">3703    // **************************************************************************************************</span>
<span class="line-removed">3704    // Special Case: unfortunately, the variable needle case can be called with needlecnt&lt;2</span>
<span class="line-removed">3705    // **************************************************************************************************</span>
<span class="line-removed">3706   if (needlecntval == 0) {           // We have to handle these cases separately.</span>
<span class="line-removed">3707   Label L_OneCharLoop;</span>
<span class="line-removed">3708   bind(L_TooShort);</span>
<span class="line-removed">3709    mtctr(haycnt);</span>
<span class="line-removed">3710    if (n_csize == 2) { lhz(n_start, 0, needle); } else { lbz(n_start, 0, needle); } // First character of needle</span>
<span class="line-removed">3711   bind(L_OneCharLoop);</span>
<span class="line-removed">3712    if (h_csize == 2) { lhzu(ch1, 2, addr); } else { lbzu(ch1, 1, addr); }</span>
<span class="line-removed">3713    cmpw(CCR1, ch1, n_start);</span>
<span class="line-removed">3714    beq(CCR1, L_Found);               // Did we find the one character needle?</span>
<span class="line-removed">3715    bdnz(L_OneCharLoop);</span>
<span class="line-removed">3716    li(result, -1);                   // Not found.</span>
<span class="line-removed">3717    b(L_End);</span>
<span class="line-removed">3718   }</span>
<span class="line-removed">3719 </span>
<span class="line-removed">3720   // **************************************************************************************************</span>
<span class="line-removed">3721   // Regular Case Part II: compare rest of needle (first 2 characters have been compared already)</span>
<span class="line-removed">3722   // **************************************************************************************************</span>
<span class="line-removed">3723 </span>
<span class="line-removed">3724   // Compare the rest</span>
<span class="line-removed">3725   bind(L_Comp2);</span>
<span class="line-removed">3726    addi(addr, addr, h_csize);        // First comparison has failed, 2nd one hit.</span>
<span class="line-removed">3727   bind(L_Comp1);                     // Addr points to possible needle start.</span>
<span class="line-removed">3728   if (needlecntval != 2) {           // Const needlecnt==2?</span>
<span class="line-removed">3729    if (needlecntval != 3) {</span>
<span class="line-removed">3730     if (needlecntval == 0) { beq(CCR6, L_Found); } // Variable needlecnt==2?</span>
<span class="line-removed">3731     Register n_ind = tmp4,</span>
<span class="line-removed">3732              h_ind = n_ind;</span>
<span class="line-removed">3733     li(n_ind, 2 * n_csize);          // First 2 characters are already compared, use index 2.</span>
<span class="line-removed">3734     mtctr(needlecnt);                // Decremented by 2, still &gt; 0.</span>
<span class="line-removed">3735    Label L_CompLoop;</span>
<span class="line-removed">3736    bind(L_CompLoop);</span>
<span class="line-removed">3737     if (ae ==StrIntrinsicNode::UL) {</span>
<span class="line-removed">3738       h_ind = ch1;</span>
<span class="line-removed">3739       sldi(h_ind, n_ind, 1);</span>
<span class="line-removed">3740     }</span>
<span class="line-removed">3741     if (n_csize == 2) { lhzx(ch2, needle, n_ind); } else { lbzx(ch2, needle, n_ind); }</span>
<span class="line-removed">3742     if (h_csize == 2) { lhzx(ch1, addr, h_ind); } else { lbzx(ch1, addr, h_ind); }</span>
<span class="line-removed">3743     cmpw(CCR1, ch1, ch2);</span>
<span class="line-removed">3744     bne(CCR1, L_OuterLoop);</span>
<span class="line-removed">3745     addi(n_ind, n_ind, n_csize);</span>
<span class="line-removed">3746     bdnz(L_CompLoop);</span>
<span class="line-removed">3747    } else { // No loop required if there&#39;s only one needle character left.</span>
<span class="line-removed">3748     if (n_csize == 2) { lhz(ch2, 2 * 2, needle); } else { lbz(ch2, 2 * 1, needle); }</span>
<span class="line-removed">3749     if (h_csize == 2) { lhz(ch1, 2 * 2, addr); } else { lbz(ch1, 2 * 1, addr); }</span>
<span class="line-removed">3750     cmpw(CCR1, ch1, ch2);</span>
<span class="line-removed">3751     bne(CCR1, L_OuterLoop);</span>
<span class="line-removed">3752    }</span>
<span class="line-removed">3753   }</span>
<span class="line-removed">3754   // Return index ...</span>
<span class="line-removed">3755   bind(L_Found);</span>
<span class="line-removed">3756    subf(result, haystack, addr);     // relative to haystack, ...</span>
<span class="line-removed">3757    if (h_csize == 2) { srdi(result, result, 1); } // in characters.</span>
<span class="line-removed">3758   bind(L_End);</span>
<span class="line-removed">3759 } // string_indexof</span>
<span class="line-removed">3760 </span>
<span class="line-removed">3761 void MacroAssembler::string_indexof_char(Register result, Register haystack, Register haycnt,</span>
<span class="line-removed">3762                                          Register needle, jchar needleChar, Register tmp1, Register tmp2, bool is_byte) {</span>
<span class="line-removed">3763   assert_different_registers(haystack, haycnt, needle, tmp1, tmp2);</span>
<span class="line-removed">3764 </span>
<span class="line-removed">3765   Label L_InnerLoop, L_FinalCheck, L_Found1, L_Found2, L_NotFound, L_End;</span>
<span class="line-removed">3766   Register addr = tmp1,</span>
<span class="line-removed">3767            ch1 = tmp2,</span>
<span class="line-removed">3768            ch2 = R0;</span>
<span class="line-removed">3769 </span>
<span class="line-removed">3770   const int h_csize = is_byte ? 1 : 2;</span>
<span class="line-removed">3771 </span>
<span class="line-removed">3772 //4:</span>
<span class="line-removed">3773    srwi_(tmp2, haycnt, 1);   // Shift right by exact_log2(UNROLL_FACTOR).</span>
<span class="line-removed">3774    mr(addr, haystack);</span>
<span class="line-removed">3775    beq(CCR0, L_FinalCheck);</span>
<span class="line-removed">3776    mtctr(tmp2);              // Move to count register.</span>
<span class="line-removed">3777 //8:</span>
<span class="line-removed">3778   bind(L_InnerLoop);         // Main work horse (2x unrolled search loop).</span>
<span class="line-removed">3779    if (!is_byte) {</span>
<span class="line-removed">3780     lhz(ch1, 0, addr);</span>
<span class="line-removed">3781     lhz(ch2, 2, addr);</span>
<span class="line-removed">3782    } else {</span>
<span class="line-removed">3783     lbz(ch1, 0, addr);</span>
<span class="line-removed">3784     lbz(ch2, 1, addr);</span>
<span class="line-removed">3785    }</span>
<span class="line-removed">3786    (needle != R0) ? cmpw(CCR0, ch1, needle) : cmplwi(CCR0, ch1, (unsigned int)needleChar);</span>
<span class="line-removed">3787    (needle != R0) ? cmpw(CCR1, ch2, needle) : cmplwi(CCR1, ch2, (unsigned int)needleChar);</span>
<span class="line-removed">3788    beq(CCR0, L_Found1);      // Did we find the needle?</span>
<span class="line-removed">3789    beq(CCR1, L_Found2);</span>
<span class="line-removed">3790    addi(addr, addr, 2 * h_csize);</span>
<span class="line-removed">3791    bdnz(L_InnerLoop);</span>
<span class="line-removed">3792 //16:</span>
<span class="line-removed">3793   bind(L_FinalCheck);</span>
<span class="line-removed">3794    andi_(R0, haycnt, 1);</span>
<span class="line-removed">3795    beq(CCR0, L_NotFound);</span>
<span class="line-removed">3796    if (!is_byte) { lhz(ch1, 0, addr); } else { lbz(ch1, 0, addr); } // One position left at which we have to compare.</span>
<span class="line-removed">3797    (needle != R0) ? cmpw(CCR1, ch1, needle) : cmplwi(CCR1, ch1, (unsigned int)needleChar);</span>
<span class="line-removed">3798    beq(CCR1, L_Found1);</span>
<span class="line-removed">3799 //21:</span>
<span class="line-removed">3800   bind(L_NotFound);</span>
<span class="line-removed">3801    li(result, -1);           // Not found.</span>
<span class="line-removed">3802    b(L_End);</span>
<span class="line-removed">3803 </span>
<span class="line-removed">3804   bind(L_Found2);</span>
<span class="line-removed">3805    addi(addr, addr, h_csize);</span>
<span class="line-removed">3806 //24:</span>
<span class="line-removed">3807   bind(L_Found1);            // Return index ...</span>
<span class="line-removed">3808    subf(result, haystack, addr); // relative to haystack, ...</span>
<span class="line-removed">3809    if (!is_byte) { srdi(result, result, 1); } // in characters.</span>
<span class="line-removed">3810   bind(L_End);</span>
<span class="line-removed">3811 } // string_indexof_char</span>
<span class="line-removed">3812 </span>
<span class="line-removed">3813 </span>
<span class="line-removed">3814 void MacroAssembler::has_negatives(Register src, Register cnt, Register result,</span>
<span class="line-removed">3815                                    Register tmp1, Register tmp2) {</span>
<span class="line-removed">3816   const Register tmp0 = R0;</span>
<span class="line-removed">3817   assert_different_registers(src, result, cnt, tmp0, tmp1, tmp2);</span>
<span class="line-removed">3818   Label Lfastloop, Lslow, Lloop, Lnoneg, Ldone;</span>
<span class="line-removed">3819 </span>
<span class="line-removed">3820   // Check if cnt &gt;= 8 (= 16 bytes)</span>
<span class="line-removed">3821   lis(tmp1, (int)(short)0x8080);  // tmp1 = 0x8080808080808080</span>
<span class="line-removed">3822   srwi_(tmp2, cnt, 4);</span>
<span class="line-removed">3823   li(result, 1);                  // Assume there&#39;s a negative byte.</span>
<span class="line-removed">3824   beq(CCR0, Lslow);</span>
<span class="line-removed">3825   ori(tmp1, tmp1, 0x8080);</span>
<span class="line-removed">3826   rldimi(tmp1, tmp1, 32, 0);</span>
<span class="line-removed">3827   mtctr(tmp2);</span>
<span class="line-removed">3828 </span>
<span class="line-removed">3829   // 2x unrolled loop</span>
<span class="line-removed">3830   bind(Lfastloop);</span>
<span class="line-removed">3831   ld(tmp2, 0, src);</span>
<span class="line-removed">3832   ld(tmp0, 8, src);</span>
<span class="line-removed">3833 </span>
<span class="line-removed">3834   orr(tmp0, tmp2, tmp0);</span>
<span class="line-removed">3835 </span>
<span class="line-removed">3836   and_(tmp0, tmp0, tmp1);</span>
<span class="line-removed">3837   bne(CCR0, Ldone);               // Found negative byte.</span>
<span class="line-removed">3838   addi(src, src, 16);</span>
<span class="line-removed">3839 </span>
<span class="line-removed">3840   bdnz(Lfastloop);</span>
<span class="line-removed">3841 </span>
<span class="line-removed">3842   bind(Lslow);                    // Fallback to slow version</span>
<span class="line-removed">3843   rldicl_(tmp0, cnt, 0, 64-4);</span>
<span class="line-removed">3844   beq(CCR0, Lnoneg);</span>
<span class="line-removed">3845   mtctr(tmp0);</span>
<span class="line-removed">3846   bind(Lloop);</span>
<span class="line-removed">3847   lbz(tmp0, 0, src);</span>
<span class="line-removed">3848   addi(src, src, 1);</span>
<span class="line-removed">3849   andi_(tmp0, tmp0, 0x80);</span>
<span class="line-removed">3850   bne(CCR0, Ldone);               // Found negative byte.</span>
<span class="line-removed">3851   bdnz(Lloop);</span>
<span class="line-removed">3852   bind(Lnoneg);</span>
<span class="line-removed">3853   li(result, 0);</span>
<span class="line-removed">3854 </span>
<span class="line-removed">3855   bind(Ldone);</span>
<span class="line-removed">3856 }</span>
<span class="line-removed">3857 </span>
<span class="line-removed">3858 #endif // Compiler2</span>
<span class="line-removed">3859 </span>
3860 // Helpers for Intrinsic Emitters
3861 //
3862 // Revert the byte order of a 32bit value in a register
3863 //   src: 0x44556677
3864 //   dst: 0x77665544
3865 // Three steps to obtain the result:
3866 //  1) Rotate src (as doubleword) left 5 bytes. That puts the leftmost byte of the src word
3867 //     into the rightmost byte position. Afterwards, everything left of the rightmost byte is cleared.
3868 //     This value initializes dst.
3869 //  2) Rotate src (as word) left 3 bytes. That puts the rightmost byte of the src word into the leftmost
3870 //     byte position. Furthermore, byte 5 is rotated into byte 6 position where it is supposed to go.
3871 //     This value is mask inserted into dst with a [0..23] mask of 1s.
3872 //  3) Rotate src (as word) left 1 byte. That puts byte 6 into byte 5 position.
3873 //     This value is mask inserted into dst with a [8..15] mask of 1s.
3874 void MacroAssembler::load_reverse_32(Register dst, Register src) {
3875   assert_different_registers(dst, src);
3876 
3877   rldicl(dst, src, (4+1)*8, 56);       // Rotate byte 4 into position 7 (rightmost), clear all to the left.
3878   rlwimi(dst, src,     3*8,  0, 23);   // Insert byte 5 into position 6, 7 into 4, leave pos 7 alone.
3879   rlwimi(dst, src,     1*8,  8, 15);   // Insert byte 6 into position 5, leave the rest alone.
</pre>
</td>
<td>
<hr />
<pre>
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;compiler/disassembler.hpp&quot;
  29 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;nativeInst_ppc.hpp&quot;
  35 #include &quot;oops/klass.inline.hpp&quot;
<span class="line-added">  36 #include &quot;oops/methodData.hpp&quot;</span>
  37 #include &quot;prims/methodHandles.hpp&quot;
  38 #include &quot;runtime/biasedLocking.hpp&quot;
  39 #include &quot;runtime/icache.hpp&quot;
  40 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  41 #include &quot;runtime/objectMonitor.hpp&quot;
  42 #include &quot;runtime/os.hpp&quot;
  43 #include &quot;runtime/safepoint.hpp&quot;
  44 #include &quot;runtime/safepointMechanism.hpp&quot;
  45 #include &quot;runtime/sharedRuntime.hpp&quot;
  46 #include &quot;runtime/stubRoutines.hpp&quot;
  47 #include &quot;utilities/macros.hpp&quot;
  48 #include &quot;utilities/powerOfTwo.hpp&quot;



  49 
  50 #ifdef PRODUCT
  51 #define BLOCK_COMMENT(str) // nothing
  52 #else
  53 #define BLOCK_COMMENT(str) block_comment(str)
  54 #endif
  55 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  56 
  57 #ifdef ASSERT
  58 // On RISC, there&#39;s no benefit to verifying instruction boundaries.
  59 bool AbstractAssembler::pd_check_instruction_mark() { return false; }
  60 #endif
  61 
  62 void MacroAssembler::ld_largeoffset_unchecked(Register d, int si31, Register a, int emit_filler_nop) {
  63   assert(Assembler::is_simm(si31, 31) &amp;&amp; si31 &gt;= 0, &quot;si31 out of range&quot;);
  64   if (Assembler::is_simm(si31, 16)) {
  65     ld(d, si31, a);
  66     if (emit_filler_nop) nop();
  67   } else {
  68     const int hi = MacroAssembler::largeoffset_si16_si16_hi(si31);
</pre>
<hr />
<pre>
3292     dcbz(base_ptr);                    // Clear 128byte aligned block.
3293     addi(base_ptr, base_ptr, cl_size);
3294     bdnz(fastloop);
3295 
3296   bind(small_rest);
3297     cmpdi(CCR0, cnt_dwords, 0);        // size 0?
3298     beq(CCR0, done);                   // rest == 0
3299     li(tmp, 0);
3300     mtctr(cnt_dwords);                 // Load counter.
3301 
3302   bind(restloop);                      // Clear rest.
3303     std(tmp, 0, base_ptr);             // Clear 8byte aligned block.
3304     addi(base_ptr, base_ptr, 8);
3305     bdnz(restloop);
3306 
3307   bind(done);
3308 }
3309 
3310 /////////////////////////////////////////// String intrinsics ////////////////////////////////////////////
3311 


































































































































































































































































































































































































































































































































































3312 // Helpers for Intrinsic Emitters
3313 //
3314 // Revert the byte order of a 32bit value in a register
3315 //   src: 0x44556677
3316 //   dst: 0x77665544
3317 // Three steps to obtain the result:
3318 //  1) Rotate src (as doubleword) left 5 bytes. That puts the leftmost byte of the src word
3319 //     into the rightmost byte position. Afterwards, everything left of the rightmost byte is cleared.
3320 //     This value initializes dst.
3321 //  2) Rotate src (as word) left 3 bytes. That puts the rightmost byte of the src word into the leftmost
3322 //     byte position. Furthermore, byte 5 is rotated into byte 6 position where it is supposed to go.
3323 //     This value is mask inserted into dst with a [0..23] mask of 1s.
3324 //  3) Rotate src (as word) left 1 byte. That puts byte 6 into byte 5 position.
3325 //     This value is mask inserted into dst with a [8..15] mask of 1s.
3326 void MacroAssembler::load_reverse_32(Register dst, Register src) {
3327   assert_different_registers(dst, src);
3328 
3329   rldicl(dst, src, (4+1)*8, 56);       // Rotate byte 4 into position 7 (rightmost), clear all to the left.
3330   rlwimi(dst, src,     3*8,  0, 23);   // Insert byte 5 into position 6, 7 into 4, leave pos 7 alone.
3331   rlwimi(dst, src,     1*8,  8, 15);   // Insert byte 6 into position 5, leave the rest alone.
</pre>
</td>
</tr>
</table>
<center><a href="../arm/macroAssembler_arm.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_ppc.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
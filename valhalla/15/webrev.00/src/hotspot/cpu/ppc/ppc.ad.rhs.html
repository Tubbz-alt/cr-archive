<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/ppc/ppc.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 //
    2 // Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
    3 // Copyright (c) 2012, 2019 SAP SE. All rights reserved.
    4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    5 //
    6 // This code is free software; you can redistribute it and/or modify it
    7 // under the terms of the GNU General Public License version 2 only, as
    8 // published by the Free Software Foundation.
    9 //
   10 // This code is distributed in the hope that it will be useful, but WITHOUT
   11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   13 // version 2 for more details (a copy is included in the LICENSE file that
   14 // accompanied this code).
   15 //
   16 // You should have received a copy of the GNU General Public License version
   17 // 2 along with this work; if not, write to the Free Software Foundation,
   18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   19 //
   20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   21 // or visit www.oracle.com if you need additional information or have any
   22 // questions.
   23 //
   24 //
   25 
   26 //
   27 // PPC64 Architecture Description File
   28 //
   29 
   30 //----------REGISTER DEFINITION BLOCK------------------------------------------
   31 // This information is used by the matcher and the register allocator to
   32 // describe individual registers and classes of registers within the target
   33 // architecture.
   34 register %{
   35 //----------Architecture Description Register Definitions----------------------
   36 // General Registers
   37 // &quot;reg_def&quot;  name (register save type, C convention save type,
   38 //                  ideal register type, encoding);
   39 //
   40 // Register Save Types:
   41 //
   42 //   NS  = No-Save:     The register allocator assumes that these registers
   43 //                      can be used without saving upon entry to the method, &amp;
   44 //                      that they do not need to be saved at call sites.
   45 //
   46 //   SOC = Save-On-Call: The register allocator assumes that these registers
   47 //                      can be used without saving upon entry to the method,
   48 //                      but that they must be saved at call sites.
   49 //                      These are called &quot;volatiles&quot; on ppc.
   50 //
   51 //   SOE = Save-On-Entry: The register allocator assumes that these registers
   52 //                      must be saved before using them upon entry to the
   53 //                      method, but they do not need to be saved at call
   54 //                      sites.
   55 //                      These are called &quot;nonvolatiles&quot; on ppc.
   56 //
   57 //   AS  = Always-Save:   The register allocator assumes that these registers
   58 //                      must be saved before using them upon entry to the
   59 //                      method, &amp; that they must be saved at call sites.
   60 //
   61 // Ideal Register Type is used to determine how to save &amp; restore a
   62 // register. Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   63 // spilled with LoadP/StoreP. If the register supports both, use Op_RegI.
   64 //
   65 // The encoding number is the actual bit-pattern placed into the opcodes.
   66 //
   67 // PPC64 register definitions, based on the 64-bit PowerPC ELF ABI
   68 // Supplement Version 1.7 as of 2003-10-29.
   69 //
   70 // For each 64-bit register we must define two registers: the register
   71 // itself, e.g. R3, and a corresponding virtual other (32-bit-)&#39;half&#39;,
   72 // e.g. R3_H, which is needed by the allocator, but is not used
   73 // for stores, loads, etc.
   74 
   75 // ----------------------------
   76 // Integer/Long Registers
   77 // ----------------------------
   78 
   79   // PPC64 has 32 64-bit integer registers.
   80 
   81   // types: v = volatile, nv = non-volatile, s = system
   82   reg_def R0   ( SOC, SOC, Op_RegI,  0, R0-&gt;as_VMReg()         );  // v   used in prologs
   83   reg_def R0_H ( SOC, SOC, Op_RegI, 99, R0-&gt;as_VMReg()-&gt;next() );
   84   reg_def R1   ( NS,  NS,  Op_RegI,  1, R1-&gt;as_VMReg()         );  // s   SP
   85   reg_def R1_H ( NS,  NS,  Op_RegI, 99, R1-&gt;as_VMReg()-&gt;next() );
   86   reg_def R2   ( SOC, SOC, Op_RegI,  2, R2-&gt;as_VMReg()         );  // v   TOC
   87   reg_def R2_H ( SOC, SOC, Op_RegI, 99, R2-&gt;as_VMReg()-&gt;next() );
   88   reg_def R3   ( SOC, SOC, Op_RegI,  3, R3-&gt;as_VMReg()         );  // v   iarg1 &amp; iret
   89   reg_def R3_H ( SOC, SOC, Op_RegI, 99, R3-&gt;as_VMReg()-&gt;next() );
   90   reg_def R4   ( SOC, SOC, Op_RegI,  4, R4-&gt;as_VMReg()         );  //     iarg2
   91   reg_def R4_H ( SOC, SOC, Op_RegI, 99, R4-&gt;as_VMReg()-&gt;next() );
   92   reg_def R5   ( SOC, SOC, Op_RegI,  5, R5-&gt;as_VMReg()         );  // v   iarg3
   93   reg_def R5_H ( SOC, SOC, Op_RegI, 99, R5-&gt;as_VMReg()-&gt;next() );
   94   reg_def R6   ( SOC, SOC, Op_RegI,  6, R6-&gt;as_VMReg()         );  // v   iarg4
   95   reg_def R6_H ( SOC, SOC, Op_RegI, 99, R6-&gt;as_VMReg()-&gt;next() );
   96   reg_def R7   ( SOC, SOC, Op_RegI,  7, R7-&gt;as_VMReg()         );  // v   iarg5
   97   reg_def R7_H ( SOC, SOC, Op_RegI, 99, R7-&gt;as_VMReg()-&gt;next() );
   98   reg_def R8   ( SOC, SOC, Op_RegI,  8, R8-&gt;as_VMReg()         );  // v   iarg6
   99   reg_def R8_H ( SOC, SOC, Op_RegI, 99, R8-&gt;as_VMReg()-&gt;next() );
  100   reg_def R9   ( SOC, SOC, Op_RegI,  9, R9-&gt;as_VMReg()         );  // v   iarg7
  101   reg_def R9_H ( SOC, SOC, Op_RegI, 99, R9-&gt;as_VMReg()-&gt;next() );
  102   reg_def R10  ( SOC, SOC, Op_RegI, 10, R10-&gt;as_VMReg()        );  // v   iarg8
  103   reg_def R10_H( SOC, SOC, Op_RegI, 99, R10-&gt;as_VMReg()-&gt;next());
  104   reg_def R11  ( SOC, SOC, Op_RegI, 11, R11-&gt;as_VMReg()        );  // v   ENV / scratch
  105   reg_def R11_H( SOC, SOC, Op_RegI, 99, R11-&gt;as_VMReg()-&gt;next());
  106   reg_def R12  ( SOC, SOC, Op_RegI, 12, R12-&gt;as_VMReg()        );  // v   scratch
  107   reg_def R12_H( SOC, SOC, Op_RegI, 99, R12-&gt;as_VMReg()-&gt;next());
  108   reg_def R13  ( NS,  NS,  Op_RegI, 13, R13-&gt;as_VMReg()        );  // s   system thread id
  109   reg_def R13_H( NS,  NS,  Op_RegI, 99, R13-&gt;as_VMReg()-&gt;next());
  110   reg_def R14  ( SOC, SOE, Op_RegI, 14, R14-&gt;as_VMReg()        );  // nv
  111   reg_def R14_H( SOC, SOE, Op_RegI, 99, R14-&gt;as_VMReg()-&gt;next());
  112   reg_def R15  ( SOC, SOE, Op_RegI, 15, R15-&gt;as_VMReg()        );  // nv
  113   reg_def R15_H( SOC, SOE, Op_RegI, 99, R15-&gt;as_VMReg()-&gt;next());
  114   reg_def R16  ( SOC, SOE, Op_RegI, 16, R16-&gt;as_VMReg()        );  // nv
  115   reg_def R16_H( SOC, SOE, Op_RegI, 99, R16-&gt;as_VMReg()-&gt;next());
  116   reg_def R17  ( SOC, SOE, Op_RegI, 17, R17-&gt;as_VMReg()        );  // nv
  117   reg_def R17_H( SOC, SOE, Op_RegI, 99, R17-&gt;as_VMReg()-&gt;next());
  118   reg_def R18  ( SOC, SOE, Op_RegI, 18, R18-&gt;as_VMReg()        );  // nv
  119   reg_def R18_H( SOC, SOE, Op_RegI, 99, R18-&gt;as_VMReg()-&gt;next());
  120   reg_def R19  ( SOC, SOE, Op_RegI, 19, R19-&gt;as_VMReg()        );  // nv
  121   reg_def R19_H( SOC, SOE, Op_RegI, 99, R19-&gt;as_VMReg()-&gt;next());
  122   reg_def R20  ( SOC, SOE, Op_RegI, 20, R20-&gt;as_VMReg()        );  // nv
  123   reg_def R20_H( SOC, SOE, Op_RegI, 99, R20-&gt;as_VMReg()-&gt;next());
  124   reg_def R21  ( SOC, SOE, Op_RegI, 21, R21-&gt;as_VMReg()        );  // nv
  125   reg_def R21_H( SOC, SOE, Op_RegI, 99, R21-&gt;as_VMReg()-&gt;next());
  126   reg_def R22  ( SOC, SOE, Op_RegI, 22, R22-&gt;as_VMReg()        );  // nv
  127   reg_def R22_H( SOC, SOE, Op_RegI, 99, R22-&gt;as_VMReg()-&gt;next());
  128   reg_def R23  ( SOC, SOE, Op_RegI, 23, R23-&gt;as_VMReg()        );  // nv
  129   reg_def R23_H( SOC, SOE, Op_RegI, 99, R23-&gt;as_VMReg()-&gt;next());
  130   reg_def R24  ( SOC, SOE, Op_RegI, 24, R24-&gt;as_VMReg()        );  // nv
  131   reg_def R24_H( SOC, SOE, Op_RegI, 99, R24-&gt;as_VMReg()-&gt;next());
  132   reg_def R25  ( SOC, SOE, Op_RegI, 25, R25-&gt;as_VMReg()        );  // nv
  133   reg_def R25_H( SOC, SOE, Op_RegI, 99, R25-&gt;as_VMReg()-&gt;next());
  134   reg_def R26  ( SOC, SOE, Op_RegI, 26, R26-&gt;as_VMReg()        );  // nv
  135   reg_def R26_H( SOC, SOE, Op_RegI, 99, R26-&gt;as_VMReg()-&gt;next());
  136   reg_def R27  ( SOC, SOE, Op_RegI, 27, R27-&gt;as_VMReg()        );  // nv
  137   reg_def R27_H( SOC, SOE, Op_RegI, 99, R27-&gt;as_VMReg()-&gt;next());
  138   reg_def R28  ( SOC, SOE, Op_RegI, 28, R28-&gt;as_VMReg()        );  // nv
  139   reg_def R28_H( SOC, SOE, Op_RegI, 99, R28-&gt;as_VMReg()-&gt;next());
  140   reg_def R29  ( SOC, SOE, Op_RegI, 29, R29-&gt;as_VMReg()        );  // nv
  141   reg_def R29_H( SOC, SOE, Op_RegI, 99, R29-&gt;as_VMReg()-&gt;next());
  142   reg_def R30  ( SOC, SOE, Op_RegI, 30, R30-&gt;as_VMReg()        );  // nv
  143   reg_def R30_H( SOC, SOE, Op_RegI, 99, R30-&gt;as_VMReg()-&gt;next());
  144   reg_def R31  ( SOC, SOE, Op_RegI, 31, R31-&gt;as_VMReg()        );  // nv
  145   reg_def R31_H( SOC, SOE, Op_RegI, 99, R31-&gt;as_VMReg()-&gt;next());
  146 
  147 
  148 // ----------------------------
  149 // Float/Double Registers
  150 // ----------------------------
  151 
  152   // Double Registers
  153   // The rules of ADL require that double registers be defined in pairs.
  154   // Each pair must be two 32-bit values, but not necessarily a pair of
  155   // single float registers. In each pair, ADLC-assigned register numbers
  156   // must be adjacent, with the lower number even. Finally, when the
  157   // CPU stores such a register pair to memory, the word associated with
  158   // the lower ADLC-assigned number must be stored to the lower address.
  159 
  160   // PPC64 has 32 64-bit floating-point registers. Each can store a single
  161   // or double precision floating-point value.
  162 
  163   // types: v = volatile, nv = non-volatile, s = system
  164   reg_def F0   ( SOC, SOC, Op_RegF,  0, F0-&gt;as_VMReg()         );  // v   scratch
  165   reg_def F0_H ( SOC, SOC, Op_RegF, 99, F0-&gt;as_VMReg()-&gt;next() );
  166   reg_def F1   ( SOC, SOC, Op_RegF,  1, F1-&gt;as_VMReg()         );  // v   farg1 &amp; fret
  167   reg_def F1_H ( SOC, SOC, Op_RegF, 99, F1-&gt;as_VMReg()-&gt;next() );
  168   reg_def F2   ( SOC, SOC, Op_RegF,  2, F2-&gt;as_VMReg()         );  // v   farg2
  169   reg_def F2_H ( SOC, SOC, Op_RegF, 99, F2-&gt;as_VMReg()-&gt;next() );
  170   reg_def F3   ( SOC, SOC, Op_RegF,  3, F3-&gt;as_VMReg()         );  // v   farg3
  171   reg_def F3_H ( SOC, SOC, Op_RegF, 99, F3-&gt;as_VMReg()-&gt;next() );
  172   reg_def F4   ( SOC, SOC, Op_RegF,  4, F4-&gt;as_VMReg()         );  // v   farg4
  173   reg_def F4_H ( SOC, SOC, Op_RegF, 99, F4-&gt;as_VMReg()-&gt;next() );
  174   reg_def F5   ( SOC, SOC, Op_RegF,  5, F5-&gt;as_VMReg()         );  // v   farg5
  175   reg_def F5_H ( SOC, SOC, Op_RegF, 99, F5-&gt;as_VMReg()-&gt;next() );
  176   reg_def F6   ( SOC, SOC, Op_RegF,  6, F6-&gt;as_VMReg()         );  // v   farg6
  177   reg_def F6_H ( SOC, SOC, Op_RegF, 99, F6-&gt;as_VMReg()-&gt;next() );
  178   reg_def F7   ( SOC, SOC, Op_RegF,  7, F7-&gt;as_VMReg()         );  // v   farg7
  179   reg_def F7_H ( SOC, SOC, Op_RegF, 99, F7-&gt;as_VMReg()-&gt;next() );
  180   reg_def F8   ( SOC, SOC, Op_RegF,  8, F8-&gt;as_VMReg()         );  // v   farg8
  181   reg_def F8_H ( SOC, SOC, Op_RegF, 99, F8-&gt;as_VMReg()-&gt;next() );
  182   reg_def F9   ( SOC, SOC, Op_RegF,  9, F9-&gt;as_VMReg()         );  // v   farg9
  183   reg_def F9_H ( SOC, SOC, Op_RegF, 99, F9-&gt;as_VMReg()-&gt;next() );
  184   reg_def F10  ( SOC, SOC, Op_RegF, 10, F10-&gt;as_VMReg()        );  // v   farg10
  185   reg_def F10_H( SOC, SOC, Op_RegF, 99, F10-&gt;as_VMReg()-&gt;next());
  186   reg_def F11  ( SOC, SOC, Op_RegF, 11, F11-&gt;as_VMReg()        );  // v   farg11
  187   reg_def F11_H( SOC, SOC, Op_RegF, 99, F11-&gt;as_VMReg()-&gt;next());
  188   reg_def F12  ( SOC, SOC, Op_RegF, 12, F12-&gt;as_VMReg()        );  // v   farg12
  189   reg_def F12_H( SOC, SOC, Op_RegF, 99, F12-&gt;as_VMReg()-&gt;next());
  190   reg_def F13  ( SOC, SOC, Op_RegF, 13, F13-&gt;as_VMReg()        );  // v   farg13
  191   reg_def F13_H( SOC, SOC, Op_RegF, 99, F13-&gt;as_VMReg()-&gt;next());
  192   reg_def F14  ( SOC, SOE, Op_RegF, 14, F14-&gt;as_VMReg()        );  // nv
  193   reg_def F14_H( SOC, SOE, Op_RegF, 99, F14-&gt;as_VMReg()-&gt;next());
  194   reg_def F15  ( SOC, SOE, Op_RegF, 15, F15-&gt;as_VMReg()        );  // nv
  195   reg_def F15_H( SOC, SOE, Op_RegF, 99, F15-&gt;as_VMReg()-&gt;next());
  196   reg_def F16  ( SOC, SOE, Op_RegF, 16, F16-&gt;as_VMReg()        );  // nv
  197   reg_def F16_H( SOC, SOE, Op_RegF, 99, F16-&gt;as_VMReg()-&gt;next());
  198   reg_def F17  ( SOC, SOE, Op_RegF, 17, F17-&gt;as_VMReg()        );  // nv
  199   reg_def F17_H( SOC, SOE, Op_RegF, 99, F17-&gt;as_VMReg()-&gt;next());
  200   reg_def F18  ( SOC, SOE, Op_RegF, 18, F18-&gt;as_VMReg()        );  // nv
  201   reg_def F18_H( SOC, SOE, Op_RegF, 99, F18-&gt;as_VMReg()-&gt;next());
  202   reg_def F19  ( SOC, SOE, Op_RegF, 19, F19-&gt;as_VMReg()        );  // nv
  203   reg_def F19_H( SOC, SOE, Op_RegF, 99, F19-&gt;as_VMReg()-&gt;next());
  204   reg_def F20  ( SOC, SOE, Op_RegF, 20, F20-&gt;as_VMReg()        );  // nv
  205   reg_def F20_H( SOC, SOE, Op_RegF, 99, F20-&gt;as_VMReg()-&gt;next());
  206   reg_def F21  ( SOC, SOE, Op_RegF, 21, F21-&gt;as_VMReg()        );  // nv
  207   reg_def F21_H( SOC, SOE, Op_RegF, 99, F21-&gt;as_VMReg()-&gt;next());
  208   reg_def F22  ( SOC, SOE, Op_RegF, 22, F22-&gt;as_VMReg()        );  // nv
  209   reg_def F22_H( SOC, SOE, Op_RegF, 99, F22-&gt;as_VMReg()-&gt;next());
  210   reg_def F23  ( SOC, SOE, Op_RegF, 23, F23-&gt;as_VMReg()        );  // nv
  211   reg_def F23_H( SOC, SOE, Op_RegF, 99, F23-&gt;as_VMReg()-&gt;next());
  212   reg_def F24  ( SOC, SOE, Op_RegF, 24, F24-&gt;as_VMReg()        );  // nv
  213   reg_def F24_H( SOC, SOE, Op_RegF, 99, F24-&gt;as_VMReg()-&gt;next());
  214   reg_def F25  ( SOC, SOE, Op_RegF, 25, F25-&gt;as_VMReg()        );  // nv
  215   reg_def F25_H( SOC, SOE, Op_RegF, 99, F25-&gt;as_VMReg()-&gt;next());
  216   reg_def F26  ( SOC, SOE, Op_RegF, 26, F26-&gt;as_VMReg()        );  // nv
  217   reg_def F26_H( SOC, SOE, Op_RegF, 99, F26-&gt;as_VMReg()-&gt;next());
  218   reg_def F27  ( SOC, SOE, Op_RegF, 27, F27-&gt;as_VMReg()        );  // nv
  219   reg_def F27_H( SOC, SOE, Op_RegF, 99, F27-&gt;as_VMReg()-&gt;next());
  220   reg_def F28  ( SOC, SOE, Op_RegF, 28, F28-&gt;as_VMReg()        );  // nv
  221   reg_def F28_H( SOC, SOE, Op_RegF, 99, F28-&gt;as_VMReg()-&gt;next());
  222   reg_def F29  ( SOC, SOE, Op_RegF, 29, F29-&gt;as_VMReg()        );  // nv
  223   reg_def F29_H( SOC, SOE, Op_RegF, 99, F29-&gt;as_VMReg()-&gt;next());
  224   reg_def F30  ( SOC, SOE, Op_RegF, 30, F30-&gt;as_VMReg()        );  // nv
  225   reg_def F30_H( SOC, SOE, Op_RegF, 99, F30-&gt;as_VMReg()-&gt;next());
  226   reg_def F31  ( SOC, SOE, Op_RegF, 31, F31-&gt;as_VMReg()        );  // nv
  227   reg_def F31_H( SOC, SOE, Op_RegF, 99, F31-&gt;as_VMReg()-&gt;next());
  228 
  229 // ----------------------------
  230 // Special Registers
  231 // ----------------------------
  232 
  233 // Condition Codes Flag Registers
  234 
  235   // PPC64 has 8 condition code &quot;registers&quot; which are all contained
  236   // in the CR register.
  237 
  238   // types: v = volatile, nv = non-volatile, s = system
  239   reg_def CCR0(SOC, SOC, Op_RegFlags, 0, CCR0-&gt;as_VMReg());  // v
  240   reg_def CCR1(SOC, SOC, Op_RegFlags, 1, CCR1-&gt;as_VMReg());  // v
  241   reg_def CCR2(SOC, SOC, Op_RegFlags, 2, CCR2-&gt;as_VMReg());  // nv
  242   reg_def CCR3(SOC, SOC, Op_RegFlags, 3, CCR3-&gt;as_VMReg());  // nv
  243   reg_def CCR4(SOC, SOC, Op_RegFlags, 4, CCR4-&gt;as_VMReg());  // nv
  244   reg_def CCR5(SOC, SOC, Op_RegFlags, 5, CCR5-&gt;as_VMReg());  // v
  245   reg_def CCR6(SOC, SOC, Op_RegFlags, 6, CCR6-&gt;as_VMReg());  // v
  246   reg_def CCR7(SOC, SOC, Op_RegFlags, 7, CCR7-&gt;as_VMReg());  // v
  247 
  248   // Special registers of PPC64
  249 
  250   reg_def SR_XER(    SOC, SOC, Op_RegP, 0, SR_XER-&gt;as_VMReg());     // v
  251   reg_def SR_LR(     SOC, SOC, Op_RegP, 1, SR_LR-&gt;as_VMReg());      // v
  252   reg_def SR_CTR(    SOC, SOC, Op_RegP, 2, SR_CTR-&gt;as_VMReg());     // v
  253   reg_def SR_VRSAVE( SOC, SOC, Op_RegP, 3, SR_VRSAVE-&gt;as_VMReg());  // v
  254   reg_def SR_SPEFSCR(SOC, SOC, Op_RegP, 4, SR_SPEFSCR-&gt;as_VMReg()); // v
  255   reg_def SR_PPR(    SOC, SOC, Op_RegP, 5, SR_PPR-&gt;as_VMReg());     // v
  256 
  257 // ----------------------------
  258 // Vector-Scalar Registers
  259 // ----------------------------
  260   reg_def VSR0 ( SOC, SOC, Op_VecX, 0, NULL);
  261   reg_def VSR1 ( SOC, SOC, Op_VecX, 1, NULL);
  262   reg_def VSR2 ( SOC, SOC, Op_VecX, 2, NULL);
  263   reg_def VSR3 ( SOC, SOC, Op_VecX, 3, NULL);
  264   reg_def VSR4 ( SOC, SOC, Op_VecX, 4, NULL);
  265   reg_def VSR5 ( SOC, SOC, Op_VecX, 5, NULL);
  266   reg_def VSR6 ( SOC, SOC, Op_VecX, 6, NULL);
  267   reg_def VSR7 ( SOC, SOC, Op_VecX, 7, NULL);
  268   reg_def VSR8 ( SOC, SOC, Op_VecX, 8, NULL);
  269   reg_def VSR9 ( SOC, SOC, Op_VecX, 9, NULL);
  270   reg_def VSR10 ( SOC, SOC, Op_VecX, 10, NULL);
  271   reg_def VSR11 ( SOC, SOC, Op_VecX, 11, NULL);
  272   reg_def VSR12 ( SOC, SOC, Op_VecX, 12, NULL);
  273   reg_def VSR13 ( SOC, SOC, Op_VecX, 13, NULL);
  274   reg_def VSR14 ( SOC, SOC, Op_VecX, 14, NULL);
  275   reg_def VSR15 ( SOC, SOC, Op_VecX, 15, NULL);
  276   reg_def VSR16 ( SOC, SOC, Op_VecX, 16, NULL);
  277   reg_def VSR17 ( SOC, SOC, Op_VecX, 17, NULL);
  278   reg_def VSR18 ( SOC, SOC, Op_VecX, 18, NULL);
  279   reg_def VSR19 ( SOC, SOC, Op_VecX, 19, NULL);
  280   reg_def VSR20 ( SOC, SOC, Op_VecX, 20, NULL);
  281   reg_def VSR21 ( SOC, SOC, Op_VecX, 21, NULL);
  282   reg_def VSR22 ( SOC, SOC, Op_VecX, 22, NULL);
  283   reg_def VSR23 ( SOC, SOC, Op_VecX, 23, NULL);
  284   reg_def VSR24 ( SOC, SOC, Op_VecX, 24, NULL);
  285   reg_def VSR25 ( SOC, SOC, Op_VecX, 25, NULL);
  286   reg_def VSR26 ( SOC, SOC, Op_VecX, 26, NULL);
  287   reg_def VSR27 ( SOC, SOC, Op_VecX, 27, NULL);
  288   reg_def VSR28 ( SOC, SOC, Op_VecX, 28, NULL);
  289   reg_def VSR29 ( SOC, SOC, Op_VecX, 29, NULL);
  290   reg_def VSR30 ( SOC, SOC, Op_VecX, 30, NULL);
  291   reg_def VSR31 ( SOC, SOC, Op_VecX, 31, NULL);
  292   reg_def VSR32 ( SOC, SOC, Op_VecX, 32, NULL);
  293   reg_def VSR33 ( SOC, SOC, Op_VecX, 33, NULL);
  294   reg_def VSR34 ( SOC, SOC, Op_VecX, 34, NULL);
  295   reg_def VSR35 ( SOC, SOC, Op_VecX, 35, NULL);
  296   reg_def VSR36 ( SOC, SOC, Op_VecX, 36, NULL);
  297   reg_def VSR37 ( SOC, SOC, Op_VecX, 37, NULL);
  298   reg_def VSR38 ( SOC, SOC, Op_VecX, 38, NULL);
  299   reg_def VSR39 ( SOC, SOC, Op_VecX, 39, NULL);
  300   reg_def VSR40 ( SOC, SOC, Op_VecX, 40, NULL);
  301   reg_def VSR41 ( SOC, SOC, Op_VecX, 41, NULL);
  302   reg_def VSR42 ( SOC, SOC, Op_VecX, 42, NULL);
  303   reg_def VSR43 ( SOC, SOC, Op_VecX, 43, NULL);
  304   reg_def VSR44 ( SOC, SOC, Op_VecX, 44, NULL);
  305   reg_def VSR45 ( SOC, SOC, Op_VecX, 45, NULL);
  306   reg_def VSR46 ( SOC, SOC, Op_VecX, 46, NULL);
  307   reg_def VSR47 ( SOC, SOC, Op_VecX, 47, NULL);
  308   reg_def VSR48 ( SOC, SOC, Op_VecX, 48, NULL);
  309   reg_def VSR49 ( SOC, SOC, Op_VecX, 49, NULL);
  310   reg_def VSR50 ( SOC, SOC, Op_VecX, 50, NULL);
  311   reg_def VSR51 ( SOC, SOC, Op_VecX, 51, NULL);
  312   reg_def VSR52 ( SOC, SOC, Op_VecX, 52, NULL);
  313   reg_def VSR53 ( SOC, SOC, Op_VecX, 53, NULL);
  314   reg_def VSR54 ( SOC, SOC, Op_VecX, 54, NULL);
  315   reg_def VSR55 ( SOC, SOC, Op_VecX, 55, NULL);
  316   reg_def VSR56 ( SOC, SOC, Op_VecX, 56, NULL);
  317   reg_def VSR57 ( SOC, SOC, Op_VecX, 57, NULL);
  318   reg_def VSR58 ( SOC, SOC, Op_VecX, 58, NULL);
  319   reg_def VSR59 ( SOC, SOC, Op_VecX, 59, NULL);
  320   reg_def VSR60 ( SOC, SOC, Op_VecX, 60, NULL);
  321   reg_def VSR61 ( SOC, SOC, Op_VecX, 61, NULL);
  322   reg_def VSR62 ( SOC, SOC, Op_VecX, 62, NULL);
  323   reg_def VSR63 ( SOC, SOC, Op_VecX, 63, NULL);
  324 
  325 // ----------------------------
  326 // Specify priority of register selection within phases of register
  327 // allocation. Highest priority is first. A useful heuristic is to
  328 // give registers a low priority when they are required by machine
  329 // instructions, like EAX and EDX on I486, and choose no-save registers
  330 // before save-on-call, &amp; save-on-call before save-on-entry. Registers
  331 // which participate in fixed calling sequences should come last.
  332 // Registers which are used as pairs must fall on an even boundary.
  333 
  334 // It&#39;s worth about 1% on SPEC geomean to get this right.
  335 
  336 // Chunk0, chunk1, and chunk2 form the MachRegisterNumbers enumeration
  337 // in adGlobals_ppc.hpp which defines the &lt;register&gt;_num values, e.g.
  338 // R3_num. Therefore, R3_num may not be (and in reality is not)
  339 // the same as R3-&gt;encoding()! Furthermore, we cannot make any
  340 // assumptions on ordering, e.g. R3_num may be less than R2_num.
  341 // Additionally, the function
  342 //   static enum RC rc_class(OptoReg::Name reg )
  343 // maps a given &lt;register&gt;_num value to its chunk type (except for flags)
  344 // and its current implementation relies on chunk0 and chunk1 having a
  345 // size of 64 each.
  346 
  347 // If you change this allocation class, please have a look at the
  348 // default values for the parameters RoundRobinIntegerRegIntervalStart
  349 // and RoundRobinFloatRegIntervalStart
  350 
  351 alloc_class chunk0 (
  352   // Chunk0 contains *all* 64 integer registers halves.
  353 
  354   // &quot;non-volatile&quot; registers
  355   R14, R14_H,
  356   R15, R15_H,
  357   R17, R17_H,
  358   R18, R18_H,
  359   R19, R19_H,
  360   R20, R20_H,
  361   R21, R21_H,
  362   R22, R22_H,
  363   R23, R23_H,
  364   R24, R24_H,
  365   R25, R25_H,
  366   R26, R26_H,
  367   R27, R27_H,
  368   R28, R28_H,
  369   R29, R29_H,
  370   R30, R30_H,
  371   R31, R31_H,
  372 
  373   // scratch/special registers
  374   R11, R11_H,
  375   R12, R12_H,
  376 
  377   // argument registers
  378   R10, R10_H,
  379   R9,  R9_H,
  380   R8,  R8_H,
  381   R7,  R7_H,
  382   R6,  R6_H,
  383   R5,  R5_H,
  384   R4,  R4_H,
  385   R3,  R3_H,
  386 
  387   // special registers, not available for allocation
  388   R16, R16_H,     // R16_thread
  389   R13, R13_H,     // system thread id
  390   R2,  R2_H,      // may be used for TOC
  391   R1,  R1_H,      // SP
  392   R0,  R0_H       // R0 (scratch)
  393 );
  394 
  395 // If you change this allocation class, please have a look at the
  396 // default values for the parameters RoundRobinIntegerRegIntervalStart
  397 // and RoundRobinFloatRegIntervalStart
  398 
  399 alloc_class chunk1 (
  400   // Chunk1 contains *all* 64 floating-point registers halves.
  401 
  402   // scratch register
  403   F0,  F0_H,
  404 
  405   // argument registers
  406   F13, F13_H,
  407   F12, F12_H,
  408   F11, F11_H,
  409   F10, F10_H,
  410   F9,  F9_H,
  411   F8,  F8_H,
  412   F7,  F7_H,
  413   F6,  F6_H,
  414   F5,  F5_H,
  415   F4,  F4_H,
  416   F3,  F3_H,
  417   F2,  F2_H,
  418   F1,  F1_H,
  419 
  420   // non-volatile registers
  421   F14, F14_H,
  422   F15, F15_H,
  423   F16, F16_H,
  424   F17, F17_H,
  425   F18, F18_H,
  426   F19, F19_H,
  427   F20, F20_H,
  428   F21, F21_H,
  429   F22, F22_H,
  430   F23, F23_H,
  431   F24, F24_H,
  432   F25, F25_H,
  433   F26, F26_H,
  434   F27, F27_H,
  435   F28, F28_H,
  436   F29, F29_H,
  437   F30, F30_H,
  438   F31, F31_H
  439 );
  440 
  441 alloc_class chunk2 (
  442   // Chunk2 contains *all* 8 condition code registers.
  443 
  444   CCR0,
  445   CCR1,
  446   CCR2,
  447   CCR3,
  448   CCR4,
  449   CCR5,
  450   CCR6,
  451   CCR7
  452 );
  453 
  454 alloc_class chunk3 (
  455   VSR0,
  456   VSR1,
  457   VSR2,
  458   VSR3,
  459   VSR4,
  460   VSR5,
  461   VSR6,
  462   VSR7,
  463   VSR8,
  464   VSR9,
  465   VSR10,
  466   VSR11,
  467   VSR12,
  468   VSR13,
  469   VSR14,
  470   VSR15,
  471   VSR16,
  472   VSR17,
  473   VSR18,
  474   VSR19,
  475   VSR20,
  476   VSR21,
  477   VSR22,
  478   VSR23,
  479   VSR24,
  480   VSR25,
  481   VSR26,
  482   VSR27,
  483   VSR28,
  484   VSR29,
  485   VSR30,
  486   VSR31,
  487   VSR32,
  488   VSR33,
  489   VSR34,
  490   VSR35,
  491   VSR36,
  492   VSR37,
  493   VSR38,
  494   VSR39,
  495   VSR40,
  496   VSR41,
  497   VSR42,
  498   VSR43,
  499   VSR44,
  500   VSR45,
  501   VSR46,
  502   VSR47,
  503   VSR48,
  504   VSR49,
  505   VSR50,
  506   VSR51,
  507   VSR52,
  508   VSR53,
  509   VSR54,
  510   VSR55,
  511   VSR56,
  512   VSR57,
  513   VSR58,
  514   VSR59,
  515   VSR60,
  516   VSR61,
  517   VSR62,
  518   VSR63
  519 );
  520 
  521 alloc_class chunk4 (
  522   // special registers
  523   // These registers are not allocated, but used for nodes generated by postalloc expand.
  524   SR_XER,
  525   SR_LR,
  526   SR_CTR,
  527   SR_VRSAVE,
  528   SR_SPEFSCR,
  529   SR_PPR
  530 );
  531 
  532 //-------Architecture Description Register Classes-----------------------
  533 
  534 // Several register classes are automatically defined based upon
  535 // information in this architecture description.
  536 
  537 // 1) reg_class inline_cache_reg           ( as defined in frame section )
  538 // 2) reg_class compiler_method_oop_reg    ( as defined in frame section )
  539 // 2) reg_class interpreter_method_oop_reg ( as defined in frame section )
  540 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  541 //
  542 
  543 // ----------------------------
  544 // 32 Bit Register Classes
  545 // ----------------------------
  546 
  547 // We specify registers twice, once as read/write, and once read-only.
  548 // We use the read-only registers for source operands. With this, we
  549 // can include preset read only registers in this class, as a hard-coded
  550 // &#39;0&#39;-register. (We used to simulate this on ppc.)
  551 
  552 // 32 bit registers that can be read and written i.e. these registers
  553 // can be dest (or src) of normal instructions.
  554 reg_class bits32_reg_rw(
  555 /*R0*/              // R0
  556 /*R1*/              // SP
  557   R2,               // TOC
  558   R3,
  559   R4,
  560   R5,
  561   R6,
  562   R7,
  563   R8,
  564   R9,
  565   R10,
  566   R11,
  567   R12,
  568 /*R13*/             // system thread id
  569   R14,
  570   R15,
  571 /*R16*/             // R16_thread
  572   R17,
  573   R18,
  574   R19,
  575   R20,
  576   R21,
  577   R22,
  578   R23,
  579   R24,
  580   R25,
  581   R26,
  582   R27,
  583   R28,
  584 /*R29,*/             // global TOC
  585   R30,
  586   R31
  587 );
  588 
  589 // 32 bit registers that can only be read i.e. these registers can
  590 // only be src of all instructions.
  591 reg_class bits32_reg_ro(
  592 /*R0*/              // R0
  593 /*R1*/              // SP
  594   R2                // TOC
  595   R3,
  596   R4,
  597   R5,
  598   R6,
  599   R7,
  600   R8,
  601   R9,
  602   R10,
  603   R11,
  604   R12,
  605 /*R13*/             // system thread id
  606   R14,
  607   R15,
  608 /*R16*/             // R16_thread
  609   R17,
  610   R18,
  611   R19,
  612   R20,
  613   R21,
  614   R22,
  615   R23,
  616   R24,
  617   R25,
  618   R26,
  619   R27,
  620   R28,
  621 /*R29,*/
  622   R30,
  623   R31
  624 );
  625 
  626 reg_class rscratch1_bits32_reg(R11);
  627 reg_class rscratch2_bits32_reg(R12);
  628 reg_class rarg1_bits32_reg(R3);
  629 reg_class rarg2_bits32_reg(R4);
  630 reg_class rarg3_bits32_reg(R5);
  631 reg_class rarg4_bits32_reg(R6);
  632 
  633 // ----------------------------
  634 // 64 Bit Register Classes
  635 // ----------------------------
  636 // 64-bit build means 64-bit pointers means hi/lo pairs
  637 
  638 reg_class rscratch1_bits64_reg(R11_H, R11);
  639 reg_class rscratch2_bits64_reg(R12_H, R12);
  640 reg_class rarg1_bits64_reg(R3_H, R3);
  641 reg_class rarg2_bits64_reg(R4_H, R4);
  642 reg_class rarg3_bits64_reg(R5_H, R5);
  643 reg_class rarg4_bits64_reg(R6_H, R6);
  644 // Thread register, &#39;written&#39; by tlsLoadP, see there.
  645 reg_class thread_bits64_reg(R16_H, R16);
  646 
  647 reg_class r19_bits64_reg(R19_H, R19);
  648 
  649 // 64 bit registers that can be read and written i.e. these registers
  650 // can be dest (or src) of normal instructions.
  651 reg_class bits64_reg_rw(
  652 /*R0_H,  R0*/     // R0
  653 /*R1_H,  R1*/     // SP
  654   R2_H,  R2,      // TOC
  655   R3_H,  R3,
  656   R4_H,  R4,
  657   R5_H,  R5,
  658   R6_H,  R6,
  659   R7_H,  R7,
  660   R8_H,  R8,
  661   R9_H,  R9,
  662   R10_H, R10,
  663   R11_H, R11,
  664   R12_H, R12,
  665 /*R13_H, R13*/   // system thread id
  666   R14_H, R14,
  667   R15_H, R15,
  668 /*R16_H, R16*/   // R16_thread
  669   R17_H, R17,
  670   R18_H, R18,
  671   R19_H, R19,
  672   R20_H, R20,
  673   R21_H, R21,
  674   R22_H, R22,
  675   R23_H, R23,
  676   R24_H, R24,
  677   R25_H, R25,
  678   R26_H, R26,
  679   R27_H, R27,
  680   R28_H, R28,
  681 /*R29_H, R29,*/
  682   R30_H, R30,
  683   R31_H, R31
  684 );
  685 
  686 // 64 bit registers used excluding r2, r11 and r12
  687 // Used to hold the TOC to avoid collisions with expanded LeafCall which uses
  688 // r2, r11 and r12 internally.
  689 reg_class bits64_reg_leaf_call(
  690 /*R0_H,  R0*/     // R0
  691 /*R1_H,  R1*/     // SP
  692 /*R2_H,  R2*/     // TOC
  693   R3_H,  R3,
  694   R4_H,  R4,
  695   R5_H,  R5,
  696   R6_H,  R6,
  697   R7_H,  R7,
  698   R8_H,  R8,
  699   R9_H,  R9,
  700   R10_H, R10,
  701 /*R11_H, R11*/
  702 /*R12_H, R12*/
  703 /*R13_H, R13*/   // system thread id
  704   R14_H, R14,
  705   R15_H, R15,
  706 /*R16_H, R16*/   // R16_thread
  707   R17_H, R17,
  708   R18_H, R18,
  709   R19_H, R19,
  710   R20_H, R20,
  711   R21_H, R21,
  712   R22_H, R22,
  713   R23_H, R23,
  714   R24_H, R24,
  715   R25_H, R25,
  716   R26_H, R26,
  717   R27_H, R27,
  718   R28_H, R28,
  719 /*R29_H, R29,*/
  720   R30_H, R30,
  721   R31_H, R31
  722 );
  723 
  724 // Used to hold the TOC to avoid collisions with expanded DynamicCall
  725 // which uses r19 as inline cache internally and expanded LeafCall which uses
  726 // r2, r11 and r12 internally.
  727 reg_class bits64_constant_table_base(
  728 /*R0_H,  R0*/     // R0
  729 /*R1_H,  R1*/     // SP
  730 /*R2_H,  R2*/     // TOC
  731   R3_H,  R3,
  732   R4_H,  R4,
  733   R5_H,  R5,
  734   R6_H,  R6,
  735   R7_H,  R7,
  736   R8_H,  R8,
  737   R9_H,  R9,
  738   R10_H, R10,
  739 /*R11_H, R11*/
  740 /*R12_H, R12*/
  741 /*R13_H, R13*/   // system thread id
  742   R14_H, R14,
  743   R15_H, R15,
  744 /*R16_H, R16*/   // R16_thread
  745   R17_H, R17,
  746   R18_H, R18,
  747 /*R19_H, R19*/
  748   R20_H, R20,
  749   R21_H, R21,
  750   R22_H, R22,
  751   R23_H, R23,
  752   R24_H, R24,
  753   R25_H, R25,
  754   R26_H, R26,
  755   R27_H, R27,
  756   R28_H, R28,
  757 /*R29_H, R29,*/
  758   R30_H, R30,
  759   R31_H, R31
  760 );
  761 
  762 // 64 bit registers that can only be read i.e. these registers can
  763 // only be src of all instructions.
  764 reg_class bits64_reg_ro(
  765 /*R0_H,  R0*/     // R0
  766   R1_H,  R1,
  767   R2_H,  R2,       // TOC
  768   R3_H,  R3,
  769   R4_H,  R4,
  770   R5_H,  R5,
  771   R6_H,  R6,
  772   R7_H,  R7,
  773   R8_H,  R8,
  774   R9_H,  R9,
  775   R10_H, R10,
  776   R11_H, R11,
  777   R12_H, R12,
  778 /*R13_H, R13*/   // system thread id
  779   R14_H, R14,
  780   R15_H, R15,
  781   R16_H, R16,    // R16_thread
  782   R17_H, R17,
  783   R18_H, R18,
  784   R19_H, R19,
  785   R20_H, R20,
  786   R21_H, R21,
  787   R22_H, R22,
  788   R23_H, R23,
  789   R24_H, R24,
  790   R25_H, R25,
  791   R26_H, R26,
  792   R27_H, R27,
  793   R28_H, R28,
  794 /*R29_H, R29,*/ // TODO: let allocator handle TOC!!
  795   R30_H, R30,
  796   R31_H, R31
  797 );
  798 
  799 
  800 // ----------------------------
  801 // Special Class for Condition Code Flags Register
  802 
  803 reg_class int_flags(
  804 /*CCR0*/             // scratch
  805 /*CCR1*/             // scratch
  806 /*CCR2*/             // nv!
  807 /*CCR3*/             // nv!
  808 /*CCR4*/             // nv!
  809   CCR5,
  810   CCR6,
  811   CCR7
  812 );
  813 
  814 reg_class int_flags_ro(
  815   CCR0,
  816   CCR1,
  817   CCR2,
  818   CCR3,
  819   CCR4,
  820   CCR5,
  821   CCR6,
  822   CCR7
  823 );
  824 
  825 reg_class int_flags_CR0(CCR0);
  826 reg_class int_flags_CR1(CCR1);
  827 reg_class int_flags_CR6(CCR6);
  828 reg_class ctr_reg(SR_CTR);
  829 
  830 // ----------------------------
  831 // Float Register Classes
  832 // ----------------------------
  833 
  834 reg_class flt_reg(
  835   F0,
  836   F1,
  837   F2,
  838   F3,
  839   F4,
  840   F5,
  841   F6,
  842   F7,
  843   F8,
  844   F9,
  845   F10,
  846   F11,
  847   F12,
  848   F13,
  849   F14,              // nv!
  850   F15,              // nv!
  851   F16,              // nv!
  852   F17,              // nv!
  853   F18,              // nv!
  854   F19,              // nv!
  855   F20,              // nv!
  856   F21,              // nv!
  857   F22,              // nv!
  858   F23,              // nv!
  859   F24,              // nv!
  860   F25,              // nv!
  861   F26,              // nv!
  862   F27,              // nv!
  863   F28,              // nv!
  864   F29,              // nv!
  865   F30,              // nv!
  866   F31               // nv!
  867 );
  868 
  869 // Double precision float registers have virtual `high halves&#39; that
  870 // are needed by the allocator.
  871 reg_class dbl_reg(
  872   F0,  F0_H,
  873   F1,  F1_H,
  874   F2,  F2_H,
  875   F3,  F3_H,
  876   F4,  F4_H,
  877   F5,  F5_H,
  878   F6,  F6_H,
  879   F7,  F7_H,
  880   F8,  F8_H,
  881   F9,  F9_H,
  882   F10, F10_H,
  883   F11, F11_H,
  884   F12, F12_H,
  885   F13, F13_H,
  886   F14, F14_H,    // nv!
  887   F15, F15_H,    // nv!
  888   F16, F16_H,    // nv!
  889   F17, F17_H,    // nv!
  890   F18, F18_H,    // nv!
  891   F19, F19_H,    // nv!
  892   F20, F20_H,    // nv!
  893   F21, F21_H,    // nv!
  894   F22, F22_H,    // nv!
  895   F23, F23_H,    // nv!
  896   F24, F24_H,    // nv!
  897   F25, F25_H,    // nv!
  898   F26, F26_H,    // nv!
  899   F27, F27_H,    // nv!
  900   F28, F28_H,    // nv!
  901   F29, F29_H,    // nv!
  902   F30, F30_H,    // nv!
  903   F31, F31_H     // nv!
  904 );
  905 
  906 // ----------------------------
  907 // Vector-Scalar Register Class
  908 // ----------------------------
  909 
  910 reg_class vs_reg(
  911   // Attention: Only these ones are saved &amp; restored at safepoint by RegisterSaver.
  912   VSR32,
  913   VSR33,
  914   VSR34,
  915   VSR35,
  916   VSR36,
  917   VSR37,
  918   VSR38,
  919   VSR39,
  920   VSR40,
  921   VSR41,
  922   VSR42,
  923   VSR43,
  924   VSR44,
  925   VSR45,
  926   VSR46,
  927   VSR47,
  928   VSR48,
  929   VSR49,
  930   VSR50,
  931   VSR51
  932   // VSR52-VSR63 // nv!
  933 );
  934 
  935  %}
  936 
  937 //----------DEFINITION BLOCK---------------------------------------------------
  938 // Define name --&gt; value mappings to inform the ADLC of an integer valued name
  939 // Current support includes integer values in the range [0, 0x7FFFFFFF]
  940 // Format:
  941 //        int_def  &lt;name&gt;         ( &lt;int_value&gt;, &lt;expression&gt;);
  942 // Generated Code in ad_&lt;arch&gt;.hpp
  943 //        #define  &lt;name&gt;   (&lt;expression&gt;)
  944 //        // value == &lt;int_value&gt;
  945 // Generated code in ad_&lt;arch&gt;.cpp adlc_verification()
  946 //        assert( &lt;name&gt; == &lt;int_value&gt;, &quot;Expect (&lt;expression&gt;) to equal &lt;int_value&gt;&quot;);
  947 //
  948 definitions %{
  949   // The default cost (of an ALU instruction).
  950   int_def DEFAULT_COST_LOW        (     30,      30);
  951   int_def DEFAULT_COST            (    100,     100);
  952   int_def HUGE_COST               (1000000, 1000000);
  953 
  954   // Memory refs
  955   int_def MEMORY_REF_COST_LOW     (    200, DEFAULT_COST * 2);
  956   int_def MEMORY_REF_COST         (    300, DEFAULT_COST * 3);
  957 
  958   // Branches are even more expensive.
  959   int_def BRANCH_COST             (    900, DEFAULT_COST * 9);
  960   int_def CALL_COST               (   1300, DEFAULT_COST * 13);
  961 %}
  962 
  963 
  964 //----------SOURCE BLOCK-------------------------------------------------------
  965 // This is a block of C++ code which provides values, functions, and
  966 // definitions necessary in the rest of the architecture description.
  967 source_hpp %{
  968   // Header information of the source block.
  969   // Method declarations/definitions which are used outside
  970   // the ad-scope can conveniently be defined here.
  971   //
  972   // To keep related declarations/definitions/uses close together,
  973   // we switch between source %{ }% and source_hpp %{ }% freely as needed.
  974 
  975 #include &quot;opto/convertnode.hpp&quot;
  976 
  977   // Returns true if Node n is followed by a MemBar node that
  978   // will do an acquire. If so, this node must not do the acquire
  979   // operation.
  980   bool followed_by_acquire(const Node *n);
  981 %}
  982 
  983 source %{
  984 
  985 // Should the Matcher clone shifts on addressing modes, expecting them
  986 // to be subsumed into complex addressing expressions or compute them
  987 // into registers?
  988 bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {
  989   return clone_base_plus_offset_address(m, mstack, address_visited);
  990 }
  991 
  992 void Compile::reshape_address(AddPNode* addp) {
  993 }
  994 
  995 // Optimize load-acquire.
  996 //
  997 // Check if acquire is unnecessary due to following operation that does
  998 // acquire anyways.
  999 // Walk the pattern:
 1000 //
 1001 //      n: Load.acq
 1002 //           |
 1003 //      MemBarAcquire
 1004 //       |         |
 1005 //  Proj(ctrl)  Proj(mem)
 1006 //       |         |
 1007 //   MemBarRelease/Volatile
 1008 //
 1009 bool followed_by_acquire(const Node *load) {
 1010   assert(load-&gt;is_Load(), &quot;So far implemented only for loads.&quot;);
 1011 
 1012   // Find MemBarAcquire.
 1013   const Node *mba = NULL;
 1014   for (DUIterator_Fast imax, i = load-&gt;fast_outs(imax); i &lt; imax; i++) {
 1015     const Node *out = load-&gt;fast_out(i);
 1016     if (out-&gt;Opcode() == Op_MemBarAcquire) {
 1017       if (out-&gt;in(0) == load) continue; // Skip control edge, membar should be found via precedence edge.
 1018       mba = out;
 1019       break;
 1020     }
 1021   }
 1022   if (!mba) return false;
 1023 
 1024   // Find following MemBar node.
 1025   //
 1026   // The following node must be reachable by control AND memory
 1027   // edge to assure no other operations are in between the two nodes.
 1028   //
 1029   // So first get the Proj node, mem_proj, to use it to iterate forward.
 1030   Node *mem_proj = NULL;
 1031   for (DUIterator_Fast imax, i = mba-&gt;fast_outs(imax); i &lt; imax; i++) {
 1032     mem_proj = mba-&gt;fast_out(i);      // Runs out of bounds and asserts if Proj not found.
 1033     assert(mem_proj-&gt;is_Proj(), &quot;only projections here&quot;);
 1034     ProjNode *proj = mem_proj-&gt;as_Proj();
 1035     if (proj-&gt;_con == TypeFunc::Memory &amp;&amp;
 1036         !Compile::current()-&gt;node_arena()-&gt;contains(mem_proj)) // Unmatched old-space only
 1037       break;
 1038   }
 1039   assert(mem_proj-&gt;as_Proj()-&gt;_con == TypeFunc::Memory, &quot;Graph broken&quot;);
 1040 
 1041   // Search MemBar behind Proj. If there are other memory operations
 1042   // behind the Proj we lost.
 1043   for (DUIterator_Fast jmax, j = mem_proj-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 1044     Node *x = mem_proj-&gt;fast_out(j);
 1045     // Proj might have an edge to a store or load node which precedes the membar.
 1046     if (x-&gt;is_Mem()) return false;
 1047 
 1048     // On PPC64 release and volatile are implemented by an instruction
 1049     // that also has acquire semantics. I.e. there is no need for an
 1050     // acquire before these.
 1051     int xop = x-&gt;Opcode();
 1052     if (xop == Op_MemBarRelease || xop == Op_MemBarVolatile) {
 1053       // Make sure we&#39;re not missing Call/Phi/MergeMem by checking
 1054       // control edges. The control edge must directly lead back
 1055       // to the MemBarAcquire
 1056       Node *ctrl_proj = x-&gt;in(0);
 1057       if (ctrl_proj-&gt;is_Proj() &amp;&amp; ctrl_proj-&gt;in(0) == mba) {
 1058         return true;
 1059       }
 1060     }
 1061   }
 1062 
 1063   return false;
 1064 }
 1065 
 1066 #define __ _masm.
 1067 
 1068 // Tertiary op of a LoadP or StoreP encoding.
 1069 #define REGP_OP true
 1070 
 1071 // ****************************************************************************
 1072 
 1073 // REQUIRED FUNCTIONALITY
 1074 
 1075 // !!!!! Special hack to get all type of calls to specify the byte offset
 1076 //       from the start of the call to the point where the return address
 1077 //       will point.
 1078 
 1079 // PPC port: Removed use of lazy constant construct.
 1080 
 1081 int MachCallStaticJavaNode::ret_addr_offset() {
 1082   // It&#39;s only a single branch-and-link instruction.
 1083   return 4;
 1084 }
 1085 
 1086 int MachCallDynamicJavaNode::ret_addr_offset() {
 1087   // Offset is 4 with postalloc expanded calls (bl is one instruction). We use
 1088   // postalloc expanded calls if we use inline caches and do not update method data.
 1089   if (UseInlineCaches)
 1090     return 4;
 1091 
 1092   int vtable_index = this-&gt;_vtable_index;
 1093   if (vtable_index &lt; 0) {
 1094     // Must be invalid_vtable_index, not nonvirtual_vtable_index.
 1095     assert(vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
 1096     return 12;
 1097   } else {
 1098     assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 1099     return 24;
 1100   }
 1101 }
 1102 
 1103 int MachCallRuntimeNode::ret_addr_offset() {
 1104 #if defined(ABI_ELFv2)
 1105   return 28;
 1106 #else
 1107   return 40;
 1108 #endif
 1109 }
 1110 
 1111 //=============================================================================
 1112 
 1113 // condition code conversions
 1114 
 1115 static int cc_to_boint(int cc) {
 1116   return Assembler::bcondCRbiIs0 | (cc &amp; 8);
 1117 }
 1118 
 1119 static int cc_to_inverse_boint(int cc) {
 1120   return Assembler::bcondCRbiIs0 | (8-(cc &amp; 8));
 1121 }
 1122 
 1123 static int cc_to_biint(int cc, int flags_reg) {
 1124   return (flags_reg &lt;&lt; 2) | (cc &amp; 3);
 1125 }
 1126 
 1127 //=============================================================================
 1128 
 1129 // Compute padding required for nodes which need alignment. The padding
 1130 // is the number of bytes (not instructions) which will be inserted before
 1131 // the instruction. The padding must match the size of a NOP instruction.
 1132 
 1133 // Currently not used on this platform.
 1134 
 1135 //=============================================================================
 1136 
 1137 // Indicate if the safepoint node needs the polling page as an input.
 1138 bool SafePointNode::needs_polling_address_input() {
 1139   // The address is loaded from thread by a seperate node.
 1140   return true;
 1141 }
 1142 
 1143 //=============================================================================
 1144 
 1145 // Emit an interrupt that is caught by the debugger (for debugging compiler).
 1146 void emit_break(CodeBuffer &amp;cbuf) {
<a name="1" id="anc1"></a><span class="line-modified"> 1147   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1148   __ illtrap();
 1149 }
 1150 
 1151 #ifndef PRODUCT
 1152 void MachBreakpointNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1153   st-&gt;print(&quot;BREAKPOINT&quot;);
 1154 }
 1155 #endif
 1156 
 1157 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1158   emit_break(cbuf);
 1159 }
 1160 
 1161 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
 1162   return MachNode::size(ra_);
 1163 }
 1164 
 1165 //=============================================================================
 1166 
 1167 void emit_nop(CodeBuffer &amp;cbuf) {
<a name="2" id="anc2"></a><span class="line-modified"> 1168   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1169   __ nop();
 1170 }
 1171 
 1172 static inline void emit_long(CodeBuffer &amp;cbuf, int value) {
 1173   *((int*)(cbuf.insts_end())) = value;
 1174   cbuf.set_insts_end(cbuf.insts_end() + BytesPerInstWord);
 1175 }
 1176 
 1177 //=============================================================================
 1178 
 1179 %} // interrupt source
 1180 
 1181 source_hpp %{ // Header information of the source block.
 1182 
 1183 //--------------------------------------------------------------
 1184 //---&lt;  Used for optimization in Compile::Shorten_branches  &gt;---
 1185 //--------------------------------------------------------------
 1186 
<a name="3" id="anc3"></a><span class="line-added"> 1187 class C2_MacroAssembler;</span>
<span class="line-added"> 1188 </span>
 1189 class CallStubImpl {
 1190 
 1191  public:
 1192 
 1193   // Emit call stub, compiled java to interpreter.
<a name="4" id="anc4"></a><span class="line-modified"> 1194   static void emit_trampoline_stub(C2_MacroAssembler &amp;_masm, int destination_toc_offset, int insts_call_instruction_offset);</span>
 1195 
 1196   // Size of call trampoline stub.
 1197   // This doesn&#39;t need to be accurate to the byte, but it
 1198   // must be larger than or equal to the real size of the stub.
 1199   static uint size_call_trampoline() {
 1200     return MacroAssembler::trampoline_stub_size;
 1201   }
 1202 
 1203   // number of relocations needed by a call trampoline stub
 1204   static uint reloc_call_trampoline() {
 1205     return 5;
 1206   }
 1207 
 1208 };
 1209 
 1210 %} // end source_hpp
 1211 
 1212 source %{
 1213 
 1214 // Emit a trampoline stub for a call to a target which is too far away.
 1215 //
 1216 // code sequences:
 1217 //
 1218 // call-site:
 1219 //   branch-and-link to &lt;destination&gt; or &lt;trampoline stub&gt;
 1220 //
 1221 // Related trampoline stub for this call-site in the stub section:
 1222 //   load the call target from the constant pool
 1223 //   branch via CTR (LR/link still points to the call-site above)
 1224 
<a name="5" id="anc5"></a><span class="line-modified"> 1225 void CallStubImpl::emit_trampoline_stub(C2_MacroAssembler &amp;_masm, int destination_toc_offset, int insts_call_instruction_offset) {</span>
 1226   address stub = __ emit_trampoline_stub(destination_toc_offset, insts_call_instruction_offset);
 1227   if (stub == NULL) {
 1228     ciEnv::current()-&gt;record_out_of_memory_failure();
 1229   }
 1230 }
 1231 
 1232 //=============================================================================
 1233 
 1234 // Emit an inline branch-and-link call and a related trampoline stub.
 1235 //
 1236 // code sequences:
 1237 //
 1238 // call-site:
 1239 //   branch-and-link to &lt;destination&gt; or &lt;trampoline stub&gt;
 1240 //
 1241 // Related trampoline stub for this call-site in the stub section:
 1242 //   load the call target from the constant pool
 1243 //   branch via CTR (LR/link still points to the call-site above)
 1244 //
 1245 
 1246 typedef struct {
 1247   int insts_call_instruction_offset;
 1248   int ret_addr_offset;
 1249 } EmitCallOffsets;
 1250 
 1251 // Emit a branch-and-link instruction that branches to a trampoline.
 1252 // - Remember the offset of the branch-and-link instruction.
 1253 // - Add a relocation at the branch-and-link instruction.
 1254 // - Emit a branch-and-link.
 1255 // - Remember the return pc offset.
<a name="6" id="anc6"></a><span class="line-modified"> 1256 EmitCallOffsets emit_call_with_trampoline_stub(C2_MacroAssembler &amp;_masm, address entry_point, relocInfo::relocType rtype) {</span>
 1257   EmitCallOffsets offsets = { -1, -1 };
 1258   const int start_offset = __ offset();
 1259   offsets.insts_call_instruction_offset = __ offset();
 1260 
 1261   // No entry point given, use the current pc.
 1262   if (entry_point == NULL) entry_point = __ pc();
 1263 
 1264   // Put the entry point as a constant into the constant pool.
 1265   const address entry_point_toc_addr   = __ address_constant(entry_point, RelocationHolder::none);
 1266   if (entry_point_toc_addr == NULL) {
 1267     ciEnv::current()-&gt;record_out_of_memory_failure();
 1268     return offsets;
 1269   }
 1270   const int     entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);
 1271 
 1272   // Emit the trampoline stub which will be related to the branch-and-link below.
 1273   CallStubImpl::emit_trampoline_stub(_masm, entry_point_toc_offset, offsets.insts_call_instruction_offset);
 1274   if (ciEnv::current()-&gt;failing()) { return offsets; } // Code cache may be full.
 1275   __ relocate(rtype);
 1276 
 1277   // Note: At this point we do not have the address of the trampoline
 1278   // stub, and the entry point might be too far away for bl, so __ pc()
 1279   // serves as dummy and the bl will be patched later.
 1280   __ bl((address) __ pc());
 1281 
 1282   offsets.ret_addr_offset = __ offset() - start_offset;
 1283 
 1284   return offsets;
 1285 }
 1286 
 1287 //=============================================================================
 1288 
 1289 // Factory for creating loadConL* nodes for large/small constant pool.
 1290 
 1291 static inline jlong replicate_immF(float con) {
 1292   // Replicate float con 2 times and pack into vector.
 1293   int val = *((int*)&amp;con);
 1294   jlong lval = val;
 1295   lval = (lval &lt;&lt; 32) | (lval &amp; 0xFFFFFFFFl);
 1296   return lval;
 1297 }
 1298 
 1299 //=============================================================================
 1300 
 1301 const RegMask&amp; MachConstantBaseNode::_out_RegMask = BITS64_CONSTANT_TABLE_BASE_mask();
<a name="7" id="anc7"></a><span class="line-modified"> 1302 int ConstantTable::calculate_table_base_offset() const {</span>
 1303   return 0;  // absolute addressing, no offset
 1304 }
 1305 
 1306 bool MachConstantBaseNode::requires_postalloc_expand() const { return true; }
 1307 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 1308   iRegPdstOper *op_dst = new iRegPdstOper();
 1309   MachNode *m1 = new loadToc_hiNode();
 1310   MachNode *m2 = new loadToc_loNode();
 1311 
 1312   m1-&gt;add_req(NULL);
 1313   m2-&gt;add_req(NULL, m1);
 1314   m1-&gt;_opnds[0] = op_dst;
 1315   m2-&gt;_opnds[0] = op_dst;
 1316   m2-&gt;_opnds[1] = op_dst;
 1317   ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 1318   ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 1319   nodes-&gt;push(m1);
 1320   nodes-&gt;push(m2);
 1321 }
 1322 
 1323 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1324   // Is postalloc expanded.
 1325   ShouldNotReachHere();
 1326 }
 1327 
 1328 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
 1329   return 0;
 1330 }
 1331 
 1332 #ifndef PRODUCT
 1333 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 1334   st-&gt;print(&quot;-- \t// MachConstantBaseNode (empty encoding)&quot;);
 1335 }
 1336 #endif
 1337 
 1338 //=============================================================================
 1339 
 1340 #ifndef PRODUCT
 1341 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1342   Compile* C = ra_-&gt;C;
<a name="8" id="anc8"></a><span class="line-modified"> 1343   const long framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
 1344 
 1345   st-&gt;print(&quot;PROLOG\n\t&quot;);
<a name="9" id="anc9"></a><span class="line-modified"> 1346   if (C-&gt;output()-&gt;need_stack_bang(framesize)) {</span>
 1347     st-&gt;print(&quot;stack_overflow_check\n\t&quot;);
 1348   }
 1349 
 1350   if (!false /* TODO: PPC port C-&gt;is_frameless_method()*/) {
 1351     st-&gt;print(&quot;save return pc\n\t&quot;);
 1352     st-&gt;print(&quot;push frame %ld\n\t&quot;, -framesize);
 1353   }
 1354 }
 1355 #endif
 1356 
 1357 // Macro used instead of the common __ to emulate the pipes of PPC.
 1358 // Instead of e.g. __ ld(...) one hase to write ___(ld) ld(...) This enables the
 1359 // micro scheduler to cope with &quot;hand written&quot; assembler like in the prolog. Though
 1360 // still no scheduling of this code is possible, the micro scheduler is aware of the
 1361 // code and can update its internal data. The following mechanism is used to achieve this:
 1362 // The micro scheduler calls size() of each compound node during scheduling. size() does a
 1363 // dummy emit and only during this dummy emit C-&gt;hb_scheduling() is not NULL.
 1364 #if 0 // TODO: PPC port
 1365 #define ___(op) if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                    \
 1366                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;PdEmulatePipe(ppc64Opcode_##op); \
 1367                 _masm.
 1368 #define ___stop if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                    \
 1369                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;PdEmulatePipe(archOpcode_none)
 1370 #define ___advance if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                 \
 1371                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;advance_offset
 1372 #else
 1373 #define ___(op) if (UsePower6SchedulerPPC64)                                          \
 1374                   Unimplemented();                                                    \
 1375                 _masm.
 1376 #define ___stop if (UsePower6SchedulerPPC64)                                          \
 1377                   Unimplemented()
 1378 #define ___advance if (UsePower6SchedulerPPC64)                                       \
 1379                   Unimplemented()
 1380 #endif
 1381 
 1382 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1383   Compile* C = ra_-&gt;C;
<a name="10" id="anc10"></a><span class="line-modified"> 1384   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1385 
<a name="11" id="anc11"></a><span class="line-modified"> 1386   const long framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
 1387   assert(framesize % (2 * wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
 1388 
 1389   const bool method_is_frameless      = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
 1390 
 1391   const Register return_pc            = R20; // Must match return_addr() in frame section.
 1392   const Register callers_sp           = R21;
 1393   const Register push_frame_temp      = R22;
 1394   const Register toc_temp             = R23;
 1395   assert_different_registers(R11, return_pc, callers_sp, push_frame_temp, toc_temp);
 1396 
 1397   if (method_is_frameless) {
 1398     // Add nop at beginning of all frameless methods to prevent any
 1399     // oop instructions from getting overwritten by make_not_entrant
 1400     // (patching attempt would fail).
 1401     ___(nop) nop();
 1402   } else {
 1403     // Get return pc.
 1404     ___(mflr) mflr(return_pc);
 1405   }
 1406 
 1407   if (C-&gt;clinit_barrier_on_entry()) {
 1408     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 1409 
 1410     Label L_skip_barrier;
 1411     Register klass = toc_temp;
 1412 
 1413     // Notify OOP recorder (don&#39;t need the relocation)
 1414     AddressLiteral md = __ constant_metadata_address(C-&gt;method()-&gt;holder()-&gt;constant_encoding());
 1415     __ load_const_optimized(klass, md.value(), R0);
 1416     __ clinit_barrier(klass, R16_thread, &amp;L_skip_barrier /*L_fast_path*/);
 1417 
 1418     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub(), R0);
 1419     __ mtctr(klass);
 1420     __ bctr();
 1421 
 1422     __ bind(L_skip_barrier);
 1423   }
 1424 
 1425   // Calls to C2R adapters often do not accept exceptional returns.
 1426   // We require that their callers must bang for them. But be
 1427   // careful, because some VM calls (such as call site linkage) can
 1428   // use several kilobytes of stack. But the stack safety zone should
 1429   // account for that. See bugs 4446381, 4468289, 4497237.
 1430 
<a name="12" id="anc12"></a><span class="line-modified"> 1431   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
 1432   assert(bangsize &gt;= framesize || bangsize &lt;= 0, &quot;stack bang size incorrect&quot;);
<a name="13" id="anc13"></a><span class="line-modified"> 1433   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
 1434     // Unfortunately we cannot use the function provided in
 1435     // assembler.cpp as we have to emulate the pipes. So I had to
 1436     // insert the code of generate_stack_overflow_check(), see
 1437     // assembler.cpp for some illuminative comments.
 1438     const int page_size = os::vm_page_size();
 1439     int bang_end = JavaThread::stack_shadow_zone_size();
 1440 
 1441     // This is how far the previous frame&#39;s stack banging extended.
 1442     const int bang_end_safe = bang_end;
 1443 
 1444     if (bangsize &gt; page_size) {
 1445       bang_end += bangsize;
 1446     }
 1447 
 1448     int bang_offset = bang_end_safe;
 1449 
 1450     while (bang_offset &lt;= bang_end) {
 1451       // Need at least one stack bang at end of shadow zone.
 1452 
 1453       // Again I had to copy code, this time from assembler_ppc.cpp,
 1454       // bang_stack_with_offset - see there for comments.
 1455 
 1456       // Stack grows down, caller passes positive offset.
 1457       assert(bang_offset &gt; 0, &quot;must bang with positive offset&quot;);
 1458 
 1459       long stdoffset = -bang_offset;
 1460 
 1461       if (Assembler::is_simm(stdoffset, 16)) {
 1462         // Signed 16 bit offset, a simple std is ok.
 1463         if (UseLoadInstructionsForStackBangingPPC64) {
 1464           ___(ld) ld(R0,  (int)(signed short)stdoffset, R1_SP);
 1465         } else {
 1466           ___(std) std(R0, (int)(signed short)stdoffset, R1_SP);
 1467         }
 1468       } else if (Assembler::is_simm(stdoffset, 31)) {
 1469         // Use largeoffset calculations for addis &amp; ld/std.
 1470         const int hi = MacroAssembler::largeoffset_si16_si16_hi(stdoffset);
 1471         const int lo = MacroAssembler::largeoffset_si16_si16_lo(stdoffset);
 1472 
 1473         Register tmp = R11;
 1474         ___(addis) addis(tmp, R1_SP, hi);
 1475         if (UseLoadInstructionsForStackBangingPPC64) {
 1476           ___(ld) ld(R0, lo, tmp);
 1477         } else {
 1478           ___(std) std(R0, lo, tmp);
 1479         }
 1480       } else {
 1481         ShouldNotReachHere();
 1482       }
 1483 
 1484       bang_offset += page_size;
 1485     }
 1486     // R11 trashed
<a name="14" id="anc14"></a><span class="line-modified"> 1487   } // C-&gt;output()-&gt;need_stack_bang(framesize) &amp;&amp; UseStackBanging</span>
 1488 
 1489   unsigned int bytes = (unsigned int)framesize;
 1490   long offset = Assembler::align_addr(bytes, frame::alignment_in_bytes);
 1491   ciMethod *currMethod = C-&gt;method();
 1492 
 1493   // Optimized version for most common case.
 1494   if (UsePower6SchedulerPPC64 &amp;&amp;
 1495       !method_is_frameless &amp;&amp; Assembler::is_simm((int)(-offset), 16) &amp;&amp;
 1496       !(false /* ConstantsALot TODO: PPC port*/)) {
 1497     ___(or) mr(callers_sp, R1_SP);
 1498     ___(std) std(return_pc, _abi(lr), R1_SP);
 1499     ___(stdu) stdu(R1_SP, -offset, R1_SP);
 1500     return;
 1501   }
 1502 
 1503   if (!method_is_frameless) {
 1504     // Get callers sp.
 1505     ___(or) mr(callers_sp, R1_SP);
 1506 
 1507     // Push method&#39;s frame, modifies SP.
 1508     assert(Assembler::is_uimm(framesize, 32U), &quot;wrong type&quot;);
 1509     // The ABI is already accounted for in &#39;framesize&#39; via the
 1510     // &#39;out_preserve&#39; area.
 1511     Register tmp = push_frame_temp;
 1512     // Had to insert code of push_frame((unsigned int)framesize, push_frame_temp).
 1513     if (Assembler::is_simm(-offset, 16)) {
 1514       ___(stdu) stdu(R1_SP, -offset, R1_SP);
 1515     } else {
 1516       long x = -offset;
 1517       // Had to insert load_const(tmp, -offset).
 1518       ___(addis)  lis( tmp, (int)((signed short)(((x &gt;&gt; 32) &amp; 0xffff0000) &gt;&gt; 16)));
 1519       ___(ori)    ori( tmp, tmp, ((x &gt;&gt; 32) &amp; 0x0000ffff));
 1520       ___(rldicr) sldi(tmp, tmp, 32);
 1521       ___(oris)   oris(tmp, tmp, (x &amp; 0xffff0000) &gt;&gt; 16);
 1522       ___(ori)    ori( tmp, tmp, (x &amp; 0x0000ffff));
 1523 
 1524       ___(stdux) stdux(R1_SP, R1_SP, tmp);
 1525     }
 1526   }
 1527 #if 0 // TODO: PPC port
 1528   // For testing large constant pools, emit a lot of constants to constant pool.
 1529   // &quot;Randomize&quot; const_size.
 1530   if (ConstantsALot) {
 1531     const int num_consts = const_size();
 1532     for (int i = 0; i &lt; num_consts; i++) {
 1533       __ long_constant(0xB0B5B00BBABE);
 1534     }
 1535   }
 1536 #endif
 1537   if (!method_is_frameless) {
 1538     // Save return pc.
 1539     ___(std) std(return_pc, _abi(lr), callers_sp);
 1540   }
 1541 
<a name="15" id="anc15"></a><span class="line-modified"> 1542   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());</span>
 1543 }
 1544 #undef ___
 1545 #undef ___stop
 1546 #undef ___advance
 1547 
 1548 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
 1549   // Variable size. determine dynamically.
 1550   return MachNode::size(ra_);
 1551 }
 1552 
 1553 int MachPrologNode::reloc() const {
 1554   // Return number of relocatable values contained in this instruction.
 1555   return 1; // 1 reloc entry for load_const(toc).
 1556 }
 1557 
 1558 //=============================================================================
 1559 
 1560 #ifndef PRODUCT
 1561 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1562   Compile* C = ra_-&gt;C;
 1563 
 1564   st-&gt;print(&quot;EPILOG\n\t&quot;);
 1565   st-&gt;print(&quot;restore return pc\n\t&quot;);
 1566   st-&gt;print(&quot;pop frame\n\t&quot;);
 1567 
 1568   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 1569     st-&gt;print(&quot;touch polling page\n\t&quot;);
 1570   }
 1571 }
 1572 #endif
 1573 
 1574 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1575   Compile* C = ra_-&gt;C;
<a name="16" id="anc16"></a><span class="line-modified"> 1576   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1577 
<a name="17" id="anc17"></a><span class="line-modified"> 1578   const long framesize = ((long)C-&gt;output()-&gt;frame_slots()) &lt;&lt; LogBytesPerInt;</span>
 1579   assert(framesize &gt;= 0, &quot;negative frame-size?&quot;);
 1580 
 1581   const bool method_needs_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
 1582   const bool method_is_frameless  = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
 1583   const Register return_pc        = R31;  // Must survive C-call to enable_stack_reserved_zone().
 1584   const Register polling_page     = R12;
 1585 
 1586   if (!method_is_frameless) {
 1587     // Restore return pc relative to callers&#39; sp.
 1588     __ ld(return_pc, ((int)framesize) + _abi(lr), R1_SP);
 1589   }
 1590 
 1591   if (method_needs_polling) {
 1592     if (SafepointMechanism::uses_thread_local_poll()) {
 1593       __ ld(polling_page, in_bytes(JavaThread::polling_page_offset()), R16_thread);
 1594     } else {
 1595       __ load_const_optimized(polling_page, (long)(address) os::get_polling_page());
 1596     }
 1597   }
 1598 
 1599   if (!method_is_frameless) {
 1600     // Move return pc to LR.
 1601     __ mtlr(return_pc);
 1602     // Pop frame (fixed frame-size).
 1603     __ addi(R1_SP, R1_SP, (int)framesize);
 1604   }
 1605 
 1606   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
 1607     __ reserved_stack_check(return_pc);
 1608   }
 1609 
 1610   if (method_needs_polling) {
 1611     // We need to mark the code position where the load from the safepoint
 1612     // polling page was emitted as relocInfo::poll_return_type here.
 1613     __ relocate(relocInfo::poll_return_type);
 1614     __ load_from_polling_page(polling_page);
 1615   }
 1616 }
 1617 
 1618 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
 1619   // Variable size. Determine dynamically.
 1620   return MachNode::size(ra_);
 1621 }
 1622 
 1623 int MachEpilogNode::reloc() const {
 1624   // Return number of relocatable values contained in this instruction.
 1625   return 1; // 1 for load_from_polling_page.
 1626 }
 1627 
 1628 const Pipeline * MachEpilogNode::pipeline() const {
 1629   return MachNode::pipeline_class();
 1630 }
 1631 
 1632 // This method seems to be obsolete. It is declared in machnode.hpp
 1633 // and defined in all *.ad files, but it is never called. Should we
 1634 // get rid of it?
 1635 int MachEpilogNode::safepoint_offset() const {
 1636   assert(do_polling(), &quot;no return for this epilog node&quot;);
 1637   return 0;
 1638 }
 1639 
 1640 #if 0 // TODO: PPC port
 1641 void MachLoadPollAddrLateNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
<a name="18" id="anc18"></a><span class="line-modified"> 1642   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1643   if (LoadPollAddressFromThread) {
 1644     _masm.ld(R11, in_bytes(JavaThread::poll_address_offset()), R16_thread);
 1645   } else {
 1646     _masm.nop();
 1647   }
 1648 }
 1649 
 1650 uint MachLoadPollAddrLateNode::size(PhaseRegAlloc* ra_) const {
 1651   if (LoadPollAddressFromThread) {
 1652     return 4;
 1653   } else {
 1654     return 4;
 1655   }
 1656 }
 1657 
 1658 #ifndef PRODUCT
 1659 void MachLoadPollAddrLateNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 1660   st-&gt;print_cr(&quot; LD R11, PollAddressOffset, R16_thread \t// LoadPollAddressFromThread&quot;);
 1661 }
 1662 #endif
 1663 
 1664 const RegMask &amp;MachLoadPollAddrLateNode::out_RegMask() const {
 1665   return RSCRATCH1_BITS64_REG_mask();
 1666 }
 1667 #endif // PPC port
 1668 
 1669 // =============================================================================
 1670 
 1671 // Figure out which register class each belongs in: rc_int, rc_float, rc_vs or
 1672 // rc_stack.
 1673 enum RC { rc_bad, rc_int, rc_float, rc_vs, rc_stack };
 1674 
 1675 static enum RC rc_class(OptoReg::Name reg) {
 1676   // Return the register class for the given register. The given register
 1677   // reg is a &lt;register&gt;_num value, which is an index into the MachRegisterNumbers
 1678   // enumeration in adGlobals_ppc.hpp.
 1679 
 1680   if (reg == OptoReg::Bad) return rc_bad;
 1681 
 1682   // We have 64 integer register halves, starting at index 0.
 1683   if (reg &lt; 64) return rc_int;
 1684 
 1685   // We have 64 floating-point register halves, starting at index 64.
 1686   if (reg &lt; 64+64) return rc_float;
 1687 
 1688   // We have 64 vector-scalar registers, starting at index 128.
 1689   if (reg &lt; 64+64+64) return rc_vs;
 1690 
 1691   // Between float regs &amp; stack are the flags regs.
 1692   assert(OptoReg::is_stack(reg) || reg &lt; 64+64+64, &quot;blow up if spilling flags&quot;);
 1693 
 1694   return rc_stack;
 1695 }
 1696 
 1697 static int ld_st_helper(CodeBuffer *cbuf, const char *op_str, uint opcode, int reg, int offset,
 1698                         bool do_print, Compile* C, outputStream *st) {
 1699 
 1700   assert(opcode == Assembler::LD_OPCODE   ||
 1701          opcode == Assembler::STD_OPCODE  ||
 1702          opcode == Assembler::LWZ_OPCODE  ||
 1703          opcode == Assembler::STW_OPCODE  ||
 1704          opcode == Assembler::LFD_OPCODE  ||
 1705          opcode == Assembler::STFD_OPCODE ||
 1706          opcode == Assembler::LFS_OPCODE  ||
 1707          opcode == Assembler::STFS_OPCODE,
 1708          &quot;opcode not supported&quot;);
 1709 
 1710   if (cbuf) {
 1711     int d =
 1712       (Assembler::LD_OPCODE == opcode || Assembler::STD_OPCODE == opcode) ?
 1713         Assembler::ds(offset+0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/)
 1714       : Assembler::d1(offset+0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/); // Makes no difference in opt build.
 1715     emit_long(*cbuf, opcode | Assembler::rt(Matcher::_regEncode[reg]) | d | Assembler::ra(R1_SP));
 1716   }
 1717 #ifndef PRODUCT
 1718   else if (do_print) {
 1719     st-&gt;print(&quot;%-7s %s, [R1_SP + #%d+%d] \t// spill copy&quot;,
 1720               op_str,
 1721               Matcher::regName[reg],
 1722               offset, 0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/);
 1723   }
 1724 #endif
 1725   return 4; // size
 1726 }
 1727 
 1728 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *st) const {
 1729   Compile* C = ra_-&gt;C;
 1730 
 1731   // Get registers to move.
 1732   OptoReg::Name src_hi = ra_-&gt;get_reg_second(in(1));
 1733   OptoReg::Name src_lo = ra_-&gt;get_reg_first(in(1));
 1734   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(this);
 1735   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(this);
 1736 
 1737   enum RC src_hi_rc = rc_class(src_hi);
 1738   enum RC src_lo_rc = rc_class(src_lo);
 1739   enum RC dst_hi_rc = rc_class(dst_hi);
 1740   enum RC dst_lo_rc = rc_class(dst_lo);
 1741 
 1742   assert(src_lo != OptoReg::Bad &amp;&amp; dst_lo != OptoReg::Bad, &quot;must move at least 1 register&quot;);
 1743   if (src_hi != OptoReg::Bad)
 1744     assert((src_lo&amp;1)==0 &amp;&amp; src_lo+1==src_hi &amp;&amp;
 1745            (dst_lo&amp;1)==0 &amp;&amp; dst_lo+1==dst_hi,
 1746            &quot;expected aligned-adjacent pairs&quot;);
 1747   // Generate spill code!
 1748   int size = 0;
 1749 
 1750   if (src_lo == dst_lo &amp;&amp; src_hi == dst_hi)
 1751     return size;            // Self copy, no move.
 1752 
 1753   if (bottom_type()-&gt;isa_vect() != NULL &amp;&amp; ideal_reg() == Op_VecX) {
 1754     // Memory-&gt;Memory Spill.
 1755     if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1756       int src_offset = ra_-&gt;reg2offset(src_lo);
 1757       int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1758       if (cbuf) {
<a name="19" id="anc19"></a><span class="line-modified"> 1759         C2_MacroAssembler _masm(cbuf);</span>
 1760         __ ld(R0, src_offset, R1_SP);
 1761         __ std(R0, dst_offset, R1_SP);
 1762         __ ld(R0, src_offset+8, R1_SP);
 1763         __ std(R0, dst_offset+8, R1_SP);
 1764       }
 1765       size += 16;
 1766     }
 1767     // VectorSRegister-&gt;Memory Spill.
 1768     else if (src_lo_rc == rc_vs &amp;&amp; dst_lo_rc == rc_stack) {
 1769       VectorSRegister Rsrc = as_VectorSRegister(Matcher::_regEncode[src_lo]);
 1770       int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1771       if (cbuf) {
<a name="20" id="anc20"></a><span class="line-modified"> 1772         C2_MacroAssembler _masm(cbuf);</span>
 1773         __ addi(R0, R1_SP, dst_offset);
 1774         __ stxvd2x(Rsrc, R0);
 1775       }
 1776       size += 8;
 1777     }
 1778     // Memory-&gt;VectorSRegister Spill.
 1779     else if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_vs) {
 1780       VectorSRegister Rdst = as_VectorSRegister(Matcher::_regEncode[dst_lo]);
 1781       int src_offset = ra_-&gt;reg2offset(src_lo);
 1782       if (cbuf) {
<a name="21" id="anc21"></a><span class="line-modified"> 1783         C2_MacroAssembler _masm(cbuf);</span>
 1784         __ addi(R0, R1_SP, src_offset);
 1785         __ lxvd2x(Rdst, R0);
 1786       }
 1787       size += 8;
 1788     }
 1789     // VectorSRegister-&gt;VectorSRegister.
 1790     else if (src_lo_rc == rc_vs &amp;&amp; dst_lo_rc == rc_vs) {
 1791       VectorSRegister Rsrc = as_VectorSRegister(Matcher::_regEncode[src_lo]);
 1792       VectorSRegister Rdst = as_VectorSRegister(Matcher::_regEncode[dst_lo]);
 1793       if (cbuf) {
<a name="22" id="anc22"></a><span class="line-modified"> 1794         C2_MacroAssembler _masm(cbuf);</span>
 1795         __ xxlor(Rdst, Rsrc, Rsrc);
 1796       }
 1797       size += 4;
 1798     }
 1799     else {
 1800       ShouldNotReachHere(); // No VSR spill.
 1801     }
 1802     return size;
 1803   }
 1804 
 1805   // --------------------------------------
 1806   // Memory-&gt;Memory Spill. Use R0 to hold the value.
 1807   if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1808     int src_offset = ra_-&gt;reg2offset(src_lo);
 1809     int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1810     if (src_hi != OptoReg::Bad) {
 1811       assert(src_hi_rc==rc_stack &amp;&amp; dst_hi_rc==rc_stack,
 1812              &quot;expected same type of move for high parts&quot;);
 1813       size += ld_st_helper(cbuf, &quot;LD  &quot;, Assembler::LD_OPCODE,  R0_num, src_offset, !do_size, C, st);
 1814       if (!cbuf &amp;&amp; !do_size) st-&gt;print(&quot;\n\t&quot;);
 1815       size += ld_st_helper(cbuf, &quot;STD &quot;, Assembler::STD_OPCODE, R0_num, dst_offset, !do_size, C, st);
 1816     } else {
 1817       size += ld_st_helper(cbuf, &quot;LWZ &quot;, Assembler::LWZ_OPCODE, R0_num, src_offset, !do_size, C, st);
 1818       if (!cbuf &amp;&amp; !do_size) st-&gt;print(&quot;\n\t&quot;);
 1819       size += ld_st_helper(cbuf, &quot;STW &quot;, Assembler::STW_OPCODE, R0_num, dst_offset, !do_size, C, st);
 1820     }
 1821     return size;
 1822   }
 1823 
 1824   // --------------------------------------
 1825   // Check for float-&gt;int copy; requires a trip through memory.
 1826   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
 1827     Unimplemented();
 1828   }
 1829 
 1830   // --------------------------------------
 1831   // Check for integer reg-reg copy.
 1832   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
 1833       Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
 1834       Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
 1835       size = (Rsrc != Rdst) ? 4 : 0;
 1836 
 1837       if (cbuf) {
<a name="23" id="anc23"></a><span class="line-modified"> 1838         C2_MacroAssembler _masm(cbuf);</span>
 1839         if (size) {
 1840           __ mr(Rdst, Rsrc);
 1841         }
 1842       }
 1843 #ifndef PRODUCT
 1844       else if (!do_size) {
 1845         if (size) {
 1846           st-&gt;print(&quot;%-7s %s, %s \t// spill copy&quot;, &quot;MR&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1847         } else {
 1848           st-&gt;print(&quot;%-7s %s, %s \t// spill copy&quot;, &quot;MR-NOP&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1849         }
 1850       }
 1851 #endif
 1852       return size;
 1853   }
 1854 
 1855   // Check for integer store.
 1856   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
 1857     int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1858     if (src_hi != OptoReg::Bad) {
 1859       assert(src_hi_rc==rc_int &amp;&amp; dst_hi_rc==rc_stack,
 1860              &quot;expected same type of move for high parts&quot;);
 1861       size += ld_st_helper(cbuf, &quot;STD &quot;, Assembler::STD_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1862     } else {
 1863       size += ld_st_helper(cbuf, &quot;STW &quot;, Assembler::STW_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1864     }
 1865     return size;
 1866   }
 1867 
 1868   // Check for integer load.
 1869   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
 1870     int src_offset = ra_-&gt;reg2offset(src_lo);
 1871     if (src_hi != OptoReg::Bad) {
 1872       assert(dst_hi_rc==rc_int &amp;&amp; src_hi_rc==rc_stack,
 1873              &quot;expected same type of move for high parts&quot;);
 1874       size += ld_st_helper(cbuf, &quot;LD  &quot;, Assembler::LD_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1875     } else {
 1876       size += ld_st_helper(cbuf, &quot;LWZ &quot;, Assembler::LWZ_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1877     }
 1878     return size;
 1879   }
 1880 
 1881   // Check for float reg-reg copy.
 1882   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
 1883     if (cbuf) {
<a name="24" id="anc24"></a><span class="line-modified"> 1884       C2_MacroAssembler _masm(cbuf);</span>
 1885       FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
 1886       FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
 1887       __ fmr(Rdst, Rsrc);
 1888     }
 1889 #ifndef PRODUCT
 1890     else if (!do_size) {
 1891       st-&gt;print(&quot;%-7s %s, %s \t// spill copy&quot;, &quot;FMR&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1892     }
 1893 #endif
 1894     return 4;
 1895   }
 1896 
 1897   // Check for float store.
 1898   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
 1899     int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1900     if (src_hi != OptoReg::Bad) {
 1901       assert(src_hi_rc==rc_float &amp;&amp; dst_hi_rc==rc_stack,
 1902              &quot;expected same type of move for high parts&quot;);
 1903       size += ld_st_helper(cbuf, &quot;STFD&quot;, Assembler::STFD_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1904     } else {
 1905       size += ld_st_helper(cbuf, &quot;STFS&quot;, Assembler::STFS_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1906     }
 1907     return size;
 1908   }
 1909 
 1910   // Check for float load.
 1911   if (dst_lo_rc == rc_float &amp;&amp; src_lo_rc == rc_stack) {
 1912     int src_offset = ra_-&gt;reg2offset(src_lo);
 1913     if (src_hi != OptoReg::Bad) {
 1914       assert(dst_hi_rc==rc_float &amp;&amp; src_hi_rc==rc_stack,
 1915              &quot;expected same type of move for high parts&quot;);
 1916       size += ld_st_helper(cbuf, &quot;LFD &quot;, Assembler::LFD_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1917     } else {
 1918       size += ld_st_helper(cbuf, &quot;LFS &quot;, Assembler::LFS_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1919     }
 1920     return size;
 1921   }
 1922 
 1923   // --------------------------------------------------------------------
 1924   // Check for hi bits still needing moving. Only happens for misaligned
 1925   // arguments to native calls.
 1926   if (src_hi == dst_hi)
 1927     return size;               // Self copy; no move.
 1928 
 1929   assert(src_hi_rc != rc_bad &amp;&amp; dst_hi_rc != rc_bad, &quot;src_hi &amp; dst_hi cannot be Bad&quot;);
 1930   ShouldNotReachHere(); // Unimplemented
 1931   return 0;
 1932 }
 1933 
 1934 #ifndef PRODUCT
 1935 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1936   if (!ra_)
 1937     st-&gt;print(&quot;N%d = SpillCopy(N%d)&quot;, _idx, in(1)-&gt;_idx);
 1938   else
 1939     implementation(NULL, ra_, false, st);
 1940 }
 1941 #endif
 1942 
 1943 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1944   implementation(&amp;cbuf, ra_, false, NULL);
 1945 }
 1946 
 1947 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1948   return implementation(NULL, ra_, true, NULL);
 1949 }
 1950 
 1951 #if 0 // TODO: PPC port
 1952 ArchOpcode MachSpillCopyNode_archOpcode(MachSpillCopyNode *n, PhaseRegAlloc *ra_) {
 1953 #ifndef PRODUCT
 1954   if (ra_-&gt;node_regs_max_index() == 0) return archOpcode_undefined;
 1955 #endif
 1956   assert(ra_-&gt;node_regs_max_index() != 0, &quot;&quot;);
 1957 
 1958   // Get registers to move.
 1959   OptoReg::Name src_hi = ra_-&gt;get_reg_second(n-&gt;in(1));
 1960   OptoReg::Name src_lo = ra_-&gt;get_reg_first(n-&gt;in(1));
 1961   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(n);
 1962   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(n);
 1963 
 1964   enum RC src_lo_rc = rc_class(src_lo);
 1965   enum RC dst_lo_rc = rc_class(dst_lo);
 1966 
 1967   if (src_lo == dst_lo &amp;&amp; src_hi == dst_hi)
 1968     return ppc64Opcode_none;            // Self copy, no move.
 1969 
 1970   // --------------------------------------
 1971   // Memory-&gt;Memory Spill. Use R0 to hold the value.
 1972   if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1973     return ppc64Opcode_compound;
 1974   }
 1975 
 1976   // --------------------------------------
 1977   // Check for float-&gt;int copy; requires a trip through memory.
 1978   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
 1979     Unimplemented();
 1980   }
 1981 
 1982   // --------------------------------------
 1983   // Check for integer reg-reg copy.
 1984   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
 1985     Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
 1986     Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
 1987     if (Rsrc == Rdst) {
 1988       return ppc64Opcode_none;
 1989     } else {
 1990       return ppc64Opcode_or;
 1991     }
 1992   }
 1993 
 1994   // Check for integer store.
 1995   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
 1996     if (src_hi != OptoReg::Bad) {
 1997       return ppc64Opcode_std;
 1998     } else {
 1999       return ppc64Opcode_stw;
 2000     }
 2001   }
 2002 
 2003   // Check for integer load.
 2004   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
 2005     if (src_hi != OptoReg::Bad) {
 2006       return ppc64Opcode_ld;
 2007     } else {
 2008       return ppc64Opcode_lwz;
 2009     }
 2010   }
 2011 
 2012   // Check for float reg-reg copy.
 2013   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
 2014     return ppc64Opcode_fmr;
 2015   }
 2016 
 2017   // Check for float store.
 2018   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
 2019     if (src_hi != OptoReg::Bad) {
 2020       return ppc64Opcode_stfd;
 2021     } else {
 2022       return ppc64Opcode_stfs;
 2023     }
 2024   }
 2025 
 2026   // Check for float load.
 2027   if (dst_lo_rc == rc_float &amp;&amp; src_lo_rc == rc_stack) {
 2028     if (src_hi != OptoReg::Bad) {
 2029       return ppc64Opcode_lfd;
 2030     } else {
 2031       return ppc64Opcode_lfs;
 2032     }
 2033   }
 2034 
 2035   // --------------------------------------------------------------------
 2036   // Check for hi bits still needing moving. Only happens for misaligned
 2037   // arguments to native calls.
 2038   if (src_hi == dst_hi) {
 2039     return ppc64Opcode_none;               // Self copy; no move.
 2040   }
 2041 
 2042   ShouldNotReachHere();
 2043   return ppc64Opcode_undefined;
 2044 }
 2045 #endif // PPC port
 2046 
 2047 #ifndef PRODUCT
 2048 void MachNopNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 2049   st-&gt;print(&quot;NOP \t// %d nops to pad for loops.&quot;, _count);
 2050 }
 2051 #endif
 2052 
 2053 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *) const {
<a name="25" id="anc25"></a><span class="line-modified"> 2054   C2_MacroAssembler _masm(&amp;cbuf);</span>
 2055   // _count contains the number of nops needed for padding.
 2056   for (int i = 0; i &lt; _count; i++) {
 2057     __ nop();
 2058   }
 2059 }
 2060 
 2061 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 2062   return _count * 4;
 2063 }
 2064 
 2065 #ifndef PRODUCT
 2066 void BoxLockNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 2067   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 2068   char reg_str[128];
 2069   ra_-&gt;dump_register(this, reg_str);
 2070   st-&gt;print(&quot;ADDI    %s, SP, %d \t// box node&quot;, reg_str, offset);
 2071 }
 2072 #endif
 2073 
 2074 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<a name="26" id="anc26"></a><span class="line-modified"> 2075   C2_MacroAssembler _masm(&amp;cbuf);</span>
 2076 
 2077   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 2078   int reg    = ra_-&gt;get_encode(this);
 2079 
 2080   if (Assembler::is_simm(offset, 16)) {
 2081     __ addi(as_Register(reg), R1, offset);
 2082   } else {
 2083     ShouldNotReachHere();
 2084   }
 2085 }
 2086 
 2087 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 2088   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_).
 2089   return 4;
 2090 }
 2091 
 2092 #ifndef PRODUCT
 2093 void MachUEPNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 2094   st-&gt;print_cr(&quot;---- MachUEPNode ----&quot;);
 2095   st-&gt;print_cr(&quot;...&quot;);
 2096 }
 2097 #endif
 2098 
 2099 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 2100   // This is the unverified entry point.
<a name="27" id="anc27"></a><span class="line-modified"> 2101   C2_MacroAssembler _masm(&amp;cbuf);</span>
 2102 
 2103   // Inline_cache contains a klass.
 2104   Register ic_klass       = as_Register(Matcher::inline_cache_reg_encode());
 2105   Register receiver_klass = R12_scratch2;  // tmp
 2106 
 2107   assert_different_registers(ic_klass, receiver_klass, R11_scratch1, R3_ARG1);
 2108   assert(R11_scratch1 == R11, &quot;need prologue scratch register&quot;);
 2109 
 2110   // Check for NULL argument if we don&#39;t have implicit null checks.
 2111   if (!ImplicitNullChecks || !os::zero_page_read_protected()) {
 2112     if (TrapBasedNullChecks) {
 2113       __ trap_null_check(R3_ARG1);
 2114     } else {
 2115       Label valid;
 2116       __ cmpdi(CCR0, R3_ARG1, 0);
 2117       __ bne_predict_taken(CCR0, valid);
 2118       // We have a null argument, branch to ic_miss_stub.
 2119       __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
 2120                            relocInfo::runtime_call_type);
 2121       __ bind(valid);
 2122     }
 2123   }
 2124   // Assume argument is not NULL, load klass from receiver.
 2125   __ load_klass(receiver_klass, R3_ARG1);
 2126 
 2127   if (TrapBasedICMissChecks) {
 2128     __ trap_ic_miss_check(receiver_klass, ic_klass);
 2129   } else {
 2130     Label valid;
 2131     __ cmpd(CCR0, receiver_klass, ic_klass);
 2132     __ beq_predict_taken(CCR0, valid);
 2133     // We have an unexpected klass, branch to ic_miss_stub.
 2134     __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
 2135                          relocInfo::runtime_call_type);
 2136     __ bind(valid);
 2137   }
 2138 
 2139   // Argument is valid and klass is as expected, continue.
 2140 }
 2141 
 2142 #if 0 // TODO: PPC port
 2143 // Optimize UEP code on z (save a load_const() call in main path).
 2144 int MachUEPNode::ep_offset() {
 2145   return 0;
 2146 }
 2147 #endif
 2148 
 2149 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 2150   // Variable size. Determine dynamically.
 2151   return MachNode::size(ra_);
 2152 }
 2153 
 2154 //=============================================================================
 2155 
 2156 %} // interrupt source
 2157 
 2158 source_hpp %{ // Header information of the source block.
 2159 
 2160 class HandlerImpl {
 2161 
 2162  public:
 2163 
 2164   static int emit_exception_handler(CodeBuffer &amp;cbuf);
 2165   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
 2166 
 2167   static uint size_exception_handler() {
 2168     // The exception_handler is a b64_patchable.
 2169     return MacroAssembler::b64_patchable_size;
 2170   }
 2171 
 2172   static uint size_deopt_handler() {
 2173     // The deopt_handler is a bl64_patchable.
 2174     return MacroAssembler::bl64_patchable_size;
 2175   }
 2176 
 2177 };
 2178 
 2179 %} // end source_hpp
 2180 
 2181 source %{
 2182 
 2183 int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
<a name="28" id="anc28"></a><span class="line-modified"> 2184   C2_MacroAssembler _masm(&amp;cbuf);</span>
 2185 
 2186   address base = __ start_a_stub(size_exception_handler());
 2187   if (base == NULL) return 0; // CodeBuffer::expand failed
 2188 
 2189   int offset = __ offset();
 2190   __ b64_patchable((address)OptoRuntime::exception_blob()-&gt;content_begin(),
 2191                        relocInfo::runtime_call_type);
 2192   assert(__ offset() - offset == (int)size_exception_handler(), &quot;must be fixed size&quot;);
 2193   __ end_a_stub();
 2194 
 2195   return offset;
 2196 }
 2197 
 2198 // The deopt_handler is like the exception handler, but it calls to
 2199 // the deoptimization blob instead of jumping to the exception blob.
 2200 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
<a name="29" id="anc29"></a><span class="line-modified"> 2201   C2_MacroAssembler _masm(&amp;cbuf);</span>
 2202 
 2203   address base = __ start_a_stub(size_deopt_handler());
 2204   if (base == NULL) return 0; // CodeBuffer::expand failed
 2205 
 2206   int offset = __ offset();
 2207   __ bl64_patchable((address)SharedRuntime::deopt_blob()-&gt;unpack(),
 2208                         relocInfo::runtime_call_type);
 2209   assert(__ offset() - offset == (int) size_deopt_handler(), &quot;must be fixed size&quot;);
 2210   __ end_a_stub();
 2211 
 2212   return offset;
 2213 }
 2214 
 2215 //=============================================================================
 2216 
 2217 // Use a frame slots bias for frameless methods if accessing the stack.
 2218 static int frame_slots_bias(int reg_enc, PhaseRegAlloc* ra_) {
 2219   if (as_Register(reg_enc) == R1_SP) {
 2220     return 0; // TODO: PPC port ra_-&gt;C-&gt;frame_slots_sp_bias_in_bytes();
 2221   }
 2222   return 0;
 2223 }
 2224 
 2225 const bool Matcher::match_rule_supported(int opcode) {
 2226   if (!has_match_rule(opcode))
 2227     return false;
 2228 
 2229   bool ret_value = true;
 2230   switch (opcode) {
 2231   case Op_SqrtD:
 2232     return VM_Version::has_fsqrt();
 2233   case Op_CountLeadingZerosI:
 2234   case Op_CountLeadingZerosL:
 2235     if (!UseCountLeadingZerosInstructionsPPC64)
 2236       return false;
 2237     break;
 2238   case Op_CountTrailingZerosI:
 2239   case Op_CountTrailingZerosL:
 2240     if (!UseCountLeadingZerosInstructionsPPC64 &amp;&amp;
 2241         !UseCountTrailingZerosInstructionsPPC64)
 2242       return false;
 2243     break;
 2244 
 2245   case Op_PopCountI:
 2246   case Op_PopCountL:
 2247     return (UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
 2248 
 2249   case Op_StrComp:
 2250     return SpecialStringCompareTo;
 2251   case Op_StrEquals:
 2252     return SpecialStringEquals;
 2253   case Op_StrIndexOf:
 2254   case Op_StrIndexOfChar:
 2255     return SpecialStringIndexOf;
 2256   case Op_AddVB:
 2257   case Op_AddVS:
 2258   case Op_AddVI:
 2259   case Op_AddVF:
 2260   case Op_AddVD:
 2261   case Op_SubVB:
 2262   case Op_SubVS:
 2263   case Op_SubVI:
 2264   case Op_SubVF:
 2265   case Op_SubVD:
 2266   case Op_MulVS:
 2267   case Op_MulVF:
 2268   case Op_MulVD:
 2269   case Op_DivVF:
 2270   case Op_DivVD:
 2271   case Op_AbsVF:
 2272   case Op_AbsVD:
 2273   case Op_NegVF:
 2274   case Op_NegVD:
 2275   case Op_SqrtVF:
 2276   case Op_SqrtVD:
 2277   case Op_AddVL:
 2278   case Op_SubVL:
 2279   case Op_MulVI:
 2280   case Op_RoundDoubleModeV:
 2281     return SuperwordUseVSX;
 2282   case Op_PopCountVI:
 2283     return (SuperwordUseVSX &amp;&amp; UsePopCountInstruction);
 2284   case Op_FmaVF:
 2285   case Op_FmaVD:
 2286     return (SuperwordUseVSX &amp;&amp; UseFMA);
 2287   case Op_Digit:
 2288   case Op_LowerCase:
 2289   case Op_UpperCase:
 2290   case Op_Whitespace:
 2291     return UseCharacterCompareIntrinsics;
 2292 
 2293   case Op_CacheWB:
 2294   case Op_CacheWBPreSync:
 2295   case Op_CacheWBPostSync:
 2296     if (!VM_Version::supports_data_cache_line_flush()) {
 2297       ret_value = false;
 2298     }
 2299     break;
 2300   }
 2301 
 2302   return ret_value;  // Per default match rules are supported.
 2303 }
 2304 
 2305 const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {
 2306 
 2307   // TODO
 2308   // identify extra cases that we might want to provide match rules for
 2309   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
 2310   bool ret_value = match_rule_supported(opcode);
 2311   // Add rules here.
 2312 
 2313   return ret_value;  // Per default match rules are supported.
 2314 }
 2315 
 2316 const bool Matcher::has_predicated_vectors(void) {
 2317   return false;
 2318 }
 2319 
 2320 const int Matcher::float_pressure(int default_pressure_threshold) {
 2321   return default_pressure_threshold;
 2322 }
 2323 
 2324 int Matcher::regnum_to_fpu_offset(int regnum) {
 2325   // No user for this method?
 2326   Unimplemented();
 2327   return 999;
 2328 }
 2329 
 2330 const bool Matcher::convL2FSupported(void) {
 2331   // fcfids can do the conversion (&gt;= Power7).
 2332   // fcfid + frsp showed rounding problem when result should be 0x3f800001.
 2333   return VM_Version::has_fcfids(); // False means that conversion is done by runtime call.
 2334 }
 2335 
 2336 // Vector width in bytes.
 2337 const int Matcher::vector_width_in_bytes(BasicType bt) {
 2338   if (SuperwordUseVSX) {
 2339     assert(MaxVectorSize == 16, &quot;&quot;);
 2340     return 16;
 2341   } else {
 2342     assert(MaxVectorSize == 8, &quot;&quot;);
 2343     return 8;
 2344   }
 2345 }
 2346 
 2347 // Vector ideal reg.
 2348 const uint Matcher::vector_ideal_reg(int size) {
 2349   if (SuperwordUseVSX) {
 2350     assert(MaxVectorSize == 16 &amp;&amp; size == 16, &quot;&quot;);
 2351     return Op_VecX;
 2352   } else {
 2353     assert(MaxVectorSize == 8 &amp;&amp; size == 8, &quot;&quot;);
 2354     return Op_RegL;
 2355   }
 2356 }
 2357 
 2358 const uint Matcher::vector_shift_count_ideal_reg(int size) {
 2359   fatal(&quot;vector shift is not supported&quot;);
 2360   return Node::NotAMachineReg;
 2361 }
 2362 
 2363 // Limits on vector size (number of elements) loaded into vector.
 2364 const int Matcher::max_vector_size(const BasicType bt) {
 2365   assert(is_java_primitive(bt), &quot;only primitive type vectors&quot;);
 2366   return vector_width_in_bytes(bt)/type2aelembytes(bt);
 2367 }
 2368 
 2369 const int Matcher::min_vector_size(const BasicType bt) {
 2370   return max_vector_size(bt); // Same as max.
 2371 }
 2372 
 2373 // PPC implementation uses VSX load/store instructions (if
 2374 // SuperwordUseVSX) which support 4 byte but not arbitrary alignment
 2375 const bool Matcher::misaligned_vectors_ok() {
 2376   return false;
 2377 }
 2378 
 2379 // PPC AES support not yet implemented
 2380 const bool Matcher::pass_original_key_for_aes() {
 2381   return false;
 2382 }
 2383 
 2384 // RETURNS: whether this branch offset is short enough that a short
 2385 // branch can be used.
 2386 //
 2387 // If the platform does not provide any short branch variants, then
 2388 // this method should return `false&#39; for offset 0.
 2389 //
 2390 // `Compile::Fill_buffer&#39; will decide on basis of this information
 2391 // whether to do the pass `Compile::Shorten_branches&#39; at all.
 2392 //
 2393 // And `Compile::Shorten_branches&#39; will decide on basis of this
 2394 // information whether to replace particular branch sites by short
 2395 // ones.
 2396 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 2397   // Is the offset within the range of a ppc64 pc relative branch?
 2398   bool b;
 2399 
 2400   const int safety_zone = 3 * BytesPerInstWord;
 2401   b = Assembler::is_simm((offset&lt;0 ? offset-safety_zone : offset+safety_zone),
 2402                          29 - 16 + 1 + 2);
 2403   return b;
 2404 }
 2405 
 2406 const bool Matcher::isSimpleConstant64(jlong value) {
 2407   // Probably always true, even if a temp register is required.
 2408   return true;
 2409 }
 2410 /* TODO: PPC port
 2411 // Make a new machine dependent decode node (with its operands).
 2412 MachTypeNode *Matcher::make_decode_node() {
 2413   assert(CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0,
 2414          &quot;This method is only implemented for unscaled cOops mode so far&quot;);
 2415   MachTypeNode *decode = new decodeN_unscaledNode();
 2416   decode-&gt;set_opnd_array(0, new iRegPdstOper());
 2417   decode-&gt;set_opnd_array(1, new iRegNsrcOper());
 2418   return decode;
 2419 }
 2420 */
 2421 
 2422 // false =&gt; size gets scaled to BytesPerLong, ok.
 2423 const bool Matcher::init_array_count_is_in_bytes = false;
 2424 
 2425 // Use conditional move (CMOVL) on Power7.
 2426 const int Matcher::long_cmove_cost() { return 0; } // this only makes long cmoves more expensive than int cmoves
 2427 
 2428 // Suppress CMOVF. Conditional move available (sort of) on PPC64 only from P7 onwards. Not exploited yet.
 2429 // fsel doesn&#39;t accept a condition register as input, so this would be slightly different.
 2430 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 2431 
 2432 // Power6 requires postalloc expand (see block.cpp for description of postalloc expand).
 2433 const bool Matcher::require_postalloc_expand = true;
 2434 
 2435 // Do we need to mask the count passed to shift instructions or does
 2436 // the cpu only look at the lower 5/6 bits anyway?
 2437 // PowerPC requires masked shift counts.
 2438 const bool Matcher::need_masked_shift_count = true;
 2439 
 2440 // No support for generic vector operands.
 2441 const bool Matcher::supports_generic_vector_operands  = false;
 2442 
 2443 MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {
 2444   ShouldNotReachHere(); // generic vector operands not supported
 2445   return NULL;
 2446 }
 2447 
 2448 bool Matcher::is_generic_reg2reg_move(MachNode* m) {
 2449   ShouldNotReachHere();  // generic vector operands not supported
 2450   return false;
 2451 }
 2452 
 2453 bool Matcher::is_generic_vector(MachOper* opnd)  {
 2454   ShouldNotReachHere();  // generic vector operands not supported
 2455   return false;
 2456 }
 2457 
 2458 // This affects two different things:
 2459 //  - how Decode nodes are matched
 2460 //  - how ImplicitNullCheck opportunities are recognized
 2461 // If true, the matcher will try to remove all Decodes and match them
 2462 // (as operands) into nodes. NullChecks are not prepared to deal with
 2463 // Decodes by final_graph_reshaping().
 2464 // If false, final_graph_reshaping() forces the decode behind the Cmp
 2465 // for a NullCheck. The matcher matches the Decode node into a register.
 2466 // Implicit_null_check optimization moves the Decode along with the
 2467 // memory operation back up before the NullCheck.
 2468 bool Matcher::narrow_oop_use_complex_address() {
 2469   // TODO: PPC port if (MatchDecodeNodes) return true;
 2470   return false;
 2471 }
 2472 
 2473 bool Matcher::narrow_klass_use_complex_address() {
 2474   NOT_LP64(ShouldNotCallThis());
 2475   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 2476   // TODO: PPC port if (MatchDecodeNodes) return true;
 2477   return false;
 2478 }
 2479 
 2480 bool Matcher::const_oop_prefer_decode() {
 2481   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
 2482   return CompressedOops::base() == NULL;
 2483 }
 2484 
 2485 bool Matcher::const_klass_prefer_decode() {
 2486   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 2487   return CompressedKlassPointers::base() == NULL;
 2488 }
 2489 
 2490 // Is it better to copy float constants, or load them directly from memory?
 2491 // Intel can load a float constant from a direct address, requiring no
 2492 // extra registers. Most RISCs will have to materialize an address into a
 2493 // register first, so they would do better to copy the constant from stack.
 2494 const bool Matcher::rematerialize_float_constants = false;
 2495 
 2496 // If CPU can load and store mis-aligned doubles directly then no fixup is
 2497 // needed. Else we split the double into 2 integer pieces and move it
 2498 // piece-by-piece. Only happens when passing doubles into C code as the
 2499 // Java calling convention forces doubles to be aligned.
 2500 const bool Matcher::misaligned_doubles_ok = true;
 2501 
 2502 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 2503  Unimplemented();
 2504 }
 2505 
 2506 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 2507 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 2508 
 2509 // Do floats take an entire double register or just half?
 2510 //
 2511 // A float occupies a ppc64 double register. For the allocator, a
 2512 // ppc64 double register appears as a pair of float registers.
 2513 bool Matcher::float_in_double() { return true; }
 2514 
 2515 // Do ints take an entire long register or just half?
 2516 // The relevant question is how the int is callee-saved:
 2517 // the whole long is written but de-opt&#39;ing will have to extract
 2518 // the relevant 32 bits.
 2519 const bool Matcher::int_in_long = true;
 2520 
 2521 // Constants for c2c and c calling conventions.
 2522 
 2523 const MachRegisterNumbers iarg_reg[8] = {
 2524   R3_num, R4_num, R5_num, R6_num,
 2525   R7_num, R8_num, R9_num, R10_num
 2526 };
 2527 
 2528 const MachRegisterNumbers farg_reg[13] = {
 2529   F1_num, F2_num, F3_num, F4_num,
 2530   F5_num, F6_num, F7_num, F8_num,
 2531   F9_num, F10_num, F11_num, F12_num,
 2532   F13_num
 2533 };
 2534 
 2535 const MachRegisterNumbers vsarg_reg[64] = {
 2536   VSR0_num, VSR1_num, VSR2_num, VSR3_num,
 2537   VSR4_num, VSR5_num, VSR6_num, VSR7_num,
 2538   VSR8_num, VSR9_num, VSR10_num, VSR11_num,
 2539   VSR12_num, VSR13_num, VSR14_num, VSR15_num,
 2540   VSR16_num, VSR17_num, VSR18_num, VSR19_num,
 2541   VSR20_num, VSR21_num, VSR22_num, VSR23_num,
 2542   VSR24_num, VSR23_num, VSR24_num, VSR25_num,
 2543   VSR28_num, VSR29_num, VSR30_num, VSR31_num,
 2544   VSR32_num, VSR33_num, VSR34_num, VSR35_num,
 2545   VSR36_num, VSR37_num, VSR38_num, VSR39_num,
 2546   VSR40_num, VSR41_num, VSR42_num, VSR43_num,
 2547   VSR44_num, VSR45_num, VSR46_num, VSR47_num,
 2548   VSR48_num, VSR49_num, VSR50_num, VSR51_num,
 2549   VSR52_num, VSR53_num, VSR54_num, VSR55_num,
 2550   VSR56_num, VSR57_num, VSR58_num, VSR59_num,
 2551   VSR60_num, VSR61_num, VSR62_num, VSR63_num
 2552 };
 2553 
 2554 const int num_iarg_registers = sizeof(iarg_reg) / sizeof(iarg_reg[0]);
 2555 
 2556 const int num_farg_registers = sizeof(farg_reg) / sizeof(farg_reg[0]);
 2557 
 2558 const int num_vsarg_registers = sizeof(vsarg_reg) / sizeof(vsarg_reg[0]);
 2559 
 2560 // Return whether or not this register is ever used as an argument. This
 2561 // function is used on startup to build the trampoline stubs in generateOptoStub.
 2562 // Registers not mentioned will be killed by the VM call in the trampoline, and
 2563 // arguments in those registers not be available to the callee.
 2564 bool Matcher::can_be_java_arg(int reg) {
 2565   // We return true for all registers contained in iarg_reg[] and
 2566   // farg_reg[] and their virtual halves.
 2567   // We must include the virtual halves in order to get STDs and LDs
 2568   // instead of STWs and LWs in the trampoline stubs.
 2569 
 2570   if (   reg == R3_num  || reg == R3_H_num
 2571       || reg == R4_num  || reg == R4_H_num
 2572       || reg == R5_num  || reg == R5_H_num
 2573       || reg == R6_num  || reg == R6_H_num
 2574       || reg == R7_num  || reg == R7_H_num
 2575       || reg == R8_num  || reg == R8_H_num
 2576       || reg == R9_num  || reg == R9_H_num
 2577       || reg == R10_num || reg == R10_H_num)
 2578     return true;
 2579 
 2580   if (   reg == F1_num  || reg == F1_H_num
 2581       || reg == F2_num  || reg == F2_H_num
 2582       || reg == F3_num  || reg == F3_H_num
 2583       || reg == F4_num  || reg == F4_H_num
 2584       || reg == F5_num  || reg == F5_H_num
 2585       || reg == F6_num  || reg == F6_H_num
 2586       || reg == F7_num  || reg == F7_H_num
 2587       || reg == F8_num  || reg == F8_H_num
 2588       || reg == F9_num  || reg == F9_H_num
 2589       || reg == F10_num || reg == F10_H_num
 2590       || reg == F11_num || reg == F11_H_num
 2591       || reg == F12_num || reg == F12_H_num
 2592       || reg == F13_num || reg == F13_H_num)
 2593     return true;
 2594 
 2595   return false;
 2596 }
 2597 
 2598 bool Matcher::is_spillable_arg(int reg) {
 2599   return can_be_java_arg(reg);
 2600 }
 2601 
 2602 bool Matcher::use_asm_for_ldiv_by_con(jlong divisor) {
 2603   return false;
 2604 }
 2605 
 2606 // Register for DIVI projection of divmodI.
 2607 RegMask Matcher::divI_proj_mask() {
 2608   ShouldNotReachHere();
 2609   return RegMask();
 2610 }
 2611 
 2612 // Register for MODI projection of divmodI.
 2613 RegMask Matcher::modI_proj_mask() {
 2614   ShouldNotReachHere();
 2615   return RegMask();
 2616 }
 2617 
 2618 // Register for DIVL projection of divmodL.
 2619 RegMask Matcher::divL_proj_mask() {
 2620   ShouldNotReachHere();
 2621   return RegMask();
 2622 }
 2623 
 2624 // Register for MODL projection of divmodL.
 2625 RegMask Matcher::modL_proj_mask() {
 2626   ShouldNotReachHere();
 2627   return RegMask();
 2628 }
 2629 
 2630 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 2631   return RegMask();
 2632 }
 2633 
 2634 const bool Matcher::convi2l_type_required = true;
 2635 
 2636 %}
 2637 
 2638 //----------ENCODING BLOCK-----------------------------------------------------
 2639 // This block specifies the encoding classes used by the compiler to output
 2640 // byte streams. Encoding classes are parameterized macros used by
 2641 // Machine Instruction Nodes in order to generate the bit encoding of the
 2642 // instruction. Operands specify their base encoding interface with the
 2643 // interface keyword. There are currently supported four interfaces,
 2644 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER. REG_INTER causes an
 2645 // operand to generate a function which returns its register number when
 2646 // queried. CONST_INTER causes an operand to generate a function which
 2647 // returns the value of the constant when queried. MEMORY_INTER causes an
 2648 // operand to generate four functions which return the Base Register, the
 2649 // Index Register, the Scale Value, and the Offset Value of the operand when
 2650 // queried. COND_INTER causes an operand to generate six functions which
 2651 // return the encoding code (ie - encoding bits for the instruction)
 2652 // associated with each basic boolean condition for a conditional instruction.
 2653 //
 2654 // Instructions specify two basic values for encoding. Again, a function
 2655 // is available to check if the constant displacement is an oop. They use the
 2656 // ins_encode keyword to specify their encoding classes (which must be
 2657 // a sequence of enc_class names, and their parameters, specified in
 2658 // the encoding block), and they use the
 2659 // opcode keyword to specify, in order, their primary, secondary, and
 2660 // tertiary opcode. Only the opcode sections which a particular instruction
 2661 // needs for encoding need to be specified.
 2662 encode %{
 2663   enc_class enc_unimplemented %{
 2664     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<a name="30" id="anc30"></a><span class="line-modified"> 2665     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2666     __ unimplemented(&quot;Unimplemented mach node encoding in AD file.&quot;, 13);
 2667   %}
 2668 
 2669   enc_class enc_untested %{
 2670 #ifdef ASSERT
 2671     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<a name="31" id="anc31"></a><span class="line-modified"> 2672     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2673     __ untested(&quot;Untested mach node encoding in AD file.&quot;);
 2674 #else
 2675     // TODO: PPC port $archOpcode(ppc64Opcode_none);
 2676 #endif
 2677   %}
 2678 
 2679   enc_class enc_lbz(iRegIdst dst, memory mem) %{
 2680     // TODO: PPC port $archOpcode(ppc64Opcode_lbz);
<a name="32" id="anc32"></a><span class="line-modified"> 2681     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2682     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2683     __ lbz($dst$$Register, Idisp, $mem$$base$$Register);
 2684   %}
 2685 
 2686   // Load acquire.
 2687   enc_class enc_lbz_ac(iRegIdst dst, memory mem) %{
 2688     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<a name="33" id="anc33"></a><span class="line-modified"> 2689     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2690     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2691     __ lbz($dst$$Register, Idisp, $mem$$base$$Register);
 2692     __ twi_0($dst$$Register);
 2693     __ isync();
 2694   %}
 2695 
 2696   enc_class enc_lhz(iRegIdst dst, memory mem) %{
 2697     // TODO: PPC port $archOpcode(ppc64Opcode_lhz);
 2698 
<a name="34" id="anc34"></a><span class="line-modified"> 2699     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2700     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2701     __ lhz($dst$$Register, Idisp, $mem$$base$$Register);
 2702   %}
 2703 
 2704   // Load acquire.
 2705   enc_class enc_lhz_ac(iRegIdst dst, memory mem) %{
 2706     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2707 
<a name="35" id="anc35"></a><span class="line-modified"> 2708     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2709     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2710     __ lhz($dst$$Register, Idisp, $mem$$base$$Register);
 2711     __ twi_0($dst$$Register);
 2712     __ isync();
 2713   %}
 2714 
 2715   enc_class enc_lwz(iRegIdst dst, memory mem) %{
 2716     // TODO: PPC port $archOpcode(ppc64Opcode_lwz);
 2717 
<a name="36" id="anc36"></a><span class="line-modified"> 2718     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2719     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2720     __ lwz($dst$$Register, Idisp, $mem$$base$$Register);
 2721   %}
 2722 
 2723   // Load acquire.
 2724   enc_class enc_lwz_ac(iRegIdst dst, memory mem) %{
 2725     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2726 
<a name="37" id="anc37"></a><span class="line-modified"> 2727     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2728     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2729     __ lwz($dst$$Register, Idisp, $mem$$base$$Register);
 2730     __ twi_0($dst$$Register);
 2731     __ isync();
 2732   %}
 2733 
 2734   enc_class enc_ld(iRegLdst dst, memoryAlg4 mem) %{
 2735     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
<a name="38" id="anc38"></a><span class="line-modified"> 2736     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2737     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2738     // Operand &#39;ds&#39; requires 4-alignment.
 2739     assert((Idisp &amp; 0x3) == 0, &quot;unaligned offset&quot;);
 2740     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
 2741   %}
 2742 
 2743   // Load acquire.
 2744   enc_class enc_ld_ac(iRegLdst dst, memoryAlg4 mem) %{
 2745     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<a name="39" id="anc39"></a><span class="line-modified"> 2746     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2747     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2748     // Operand &#39;ds&#39; requires 4-alignment.
 2749     assert((Idisp &amp; 0x3) == 0, &quot;unaligned offset&quot;);
 2750     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
 2751     __ twi_0($dst$$Register);
 2752     __ isync();
 2753   %}
 2754 
 2755   enc_class enc_lfd(RegF dst, memory mem) %{
 2756     // TODO: PPC port $archOpcode(ppc64Opcode_lfd);
<a name="40" id="anc40"></a><span class="line-modified"> 2757     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2758     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2759     __ lfd($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 2760   %}
 2761 
 2762   enc_class enc_load_long_constL(iRegLdst dst, immL src, iRegLdst toc) %{
 2763     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 2764 
<a name="41" id="anc41"></a><span class="line-modified"> 2765     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2766     int toc_offset = 0;
 2767 
 2768     address const_toc_addr;
 2769     // Create a non-oop constant, no relocation needed.
 2770     // If it is an IC, it has a virtual_call_Relocation.
 2771     const_toc_addr = __ long_constant((jlong)$src$$constant);
 2772     if (const_toc_addr == NULL) {
 2773       ciEnv::current()-&gt;record_out_of_memory_failure();
 2774       return;
 2775     }
 2776 
 2777     // Get the constant&#39;s TOC offset.
 2778     toc_offset = __ offset_to_method_toc(const_toc_addr);
 2779 
 2780     // Keep the current instruction offset in mind.
 2781     ((loadConLNode*)this)-&gt;_cbuf_insts_offset = __ offset();
 2782 
 2783     __ ld($dst$$Register, toc_offset, $toc$$Register);
 2784   %}
 2785 
 2786   enc_class enc_load_long_constL_hi(iRegLdst dst, iRegLdst toc, immL src) %{
 2787     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 2788 
<a name="42" id="anc42"></a><span class="line-modified"> 2789     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2790 
<a name="43" id="anc43"></a><span class="line-modified"> 2791     if (!ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size()) {</span>
 2792       address const_toc_addr;
 2793       // Create a non-oop constant, no relocation needed.
 2794       // If it is an IC, it has a virtual_call_Relocation.
 2795       const_toc_addr = __ long_constant((jlong)$src$$constant);
 2796       if (const_toc_addr == NULL) {
 2797         ciEnv::current()-&gt;record_out_of_memory_failure();
 2798         return;
 2799       }
 2800 
 2801       // Get the constant&#39;s TOC offset.
 2802       const int toc_offset = __ offset_to_method_toc(const_toc_addr);
 2803       // Store the toc offset of the constant.
 2804       ((loadConL_hiNode*)this)-&gt;_const_toc_offset = toc_offset;
 2805 
 2806       // Also keep the current instruction offset in mind.
 2807       ((loadConL_hiNode*)this)-&gt;_cbuf_insts_offset = __ offset();
 2808     }
 2809 
 2810     __ addis($dst$$Register, $toc$$Register, MacroAssembler::largeoffset_si16_si16_hi(_const_toc_offset));
 2811   %}
 2812 
 2813 %} // encode
 2814 
 2815 source %{
 2816 
 2817 typedef struct {
 2818   loadConL_hiNode *_large_hi;
 2819   loadConL_loNode *_large_lo;
 2820   loadConLNode    *_small;
 2821   MachNode        *_last;
 2822 } loadConLNodesTuple;
 2823 
 2824 loadConLNodesTuple loadConLNodesTuple_create(PhaseRegAlloc *ra_, Node *toc, immLOper *immSrc,
 2825                                              OptoReg::Name reg_second, OptoReg::Name reg_first) {
 2826   loadConLNodesTuple nodes;
 2827 
 2828   const bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 2829   if (large_constant_pool) {
 2830     // Create new nodes.
 2831     loadConL_hiNode *m1 = new loadConL_hiNode();
 2832     loadConL_loNode *m2 = new loadConL_loNode();
 2833 
 2834     // inputs for new nodes
 2835     m1-&gt;add_req(NULL, toc);
 2836     m2-&gt;add_req(NULL, m1);
 2837 
 2838     // operands for new nodes
 2839     m1-&gt;_opnds[0] = new iRegLdstOper(); // dst
 2840     m1-&gt;_opnds[1] = immSrc;             // src
 2841     m1-&gt;_opnds[2] = new iRegPdstOper(); // toc
 2842     m2-&gt;_opnds[0] = new iRegLdstOper(); // dst
 2843     m2-&gt;_opnds[1] = immSrc;             // src
 2844     m2-&gt;_opnds[2] = new iRegLdstOper(); // base
 2845 
 2846     // Initialize ins_attrib TOC fields.
 2847     m1-&gt;_const_toc_offset = -1;
 2848     m2-&gt;_const_toc_offset_hi_node = m1;
 2849 
 2850     // Initialize ins_attrib instruction offset.
 2851     m1-&gt;_cbuf_insts_offset = -1;
 2852 
 2853     // register allocation for new nodes
 2854     ra_-&gt;set_pair(m1-&gt;_idx, reg_second, reg_first);
 2855     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2856 
 2857     // Create result.
 2858     nodes._large_hi = m1;
 2859     nodes._large_lo = m2;
 2860     nodes._small = NULL;
 2861     nodes._last = nodes._large_lo;
 2862     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 2863   } else {
 2864     loadConLNode *m2 = new loadConLNode();
 2865 
 2866     // inputs for new nodes
 2867     m2-&gt;add_req(NULL, toc);
 2868 
 2869     // operands for new nodes
 2870     m2-&gt;_opnds[0] = new iRegLdstOper(); // dst
 2871     m2-&gt;_opnds[1] = immSrc;             // src
 2872     m2-&gt;_opnds[2] = new iRegPdstOper(); // toc
 2873 
 2874     // Initialize ins_attrib instruction offset.
 2875     m2-&gt;_cbuf_insts_offset = -1;
 2876 
 2877     // register allocation for new nodes
 2878     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2879 
 2880     // Create result.
 2881     nodes._large_hi = NULL;
 2882     nodes._large_lo = NULL;
 2883     nodes._small = m2;
 2884     nodes._last = nodes._small;
 2885     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 2886   }
 2887 
 2888   return nodes;
 2889 }
 2890 
 2891 typedef struct {
 2892   loadConL_hiNode *_large_hi;
 2893   loadConL_loNode *_large_lo;
 2894   mtvsrdNode      *_moved;
 2895   xxspltdNode     *_replicated;
 2896   loadConLNode    *_small;
 2897   MachNode        *_last;
 2898 } loadConLReplicatedNodesTuple;
 2899 
 2900 loadConLReplicatedNodesTuple loadConLReplicatedNodesTuple_create(Compile *C, PhaseRegAlloc *ra_, Node *toc, immLOper *immSrc,
 2901                                                  vecXOper *dst, immI_0Oper *zero,
 2902                                                  OptoReg::Name reg_second, OptoReg::Name reg_first,
 2903                                                  OptoReg::Name reg_vec_second, OptoReg::Name reg_vec_first) {
 2904   loadConLReplicatedNodesTuple nodes;
 2905 
 2906   const bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 2907   if (large_constant_pool) {
 2908     // Create new nodes.
 2909     loadConL_hiNode *m1 = new  loadConL_hiNode();
 2910     loadConL_loNode *m2 = new  loadConL_loNode();
 2911     mtvsrdNode *m3 = new  mtvsrdNode();
 2912     xxspltdNode *m4 = new  xxspltdNode();
 2913 
 2914     // inputs for new nodes
 2915     m1-&gt;add_req(NULL, toc);
 2916     m2-&gt;add_req(NULL, m1);
 2917     m3-&gt;add_req(NULL, m2);
 2918     m4-&gt;add_req(NULL, m3);
 2919 
 2920     // operands for new nodes
 2921     m1-&gt;_opnds[0] = new  iRegLdstOper(); // dst
 2922     m1-&gt;_opnds[1] = immSrc;              // src
 2923     m1-&gt;_opnds[2] = new  iRegPdstOper(); // toc
 2924 
 2925     m2-&gt;_opnds[0] = new  iRegLdstOper(); // dst
 2926     m2-&gt;_opnds[1] = immSrc;              // src
 2927     m2-&gt;_opnds[2] = new  iRegLdstOper(); // base
 2928 
 2929     m3-&gt;_opnds[0] = new  vecXOper();     // dst
 2930     m3-&gt;_opnds[1] = new  iRegLdstOper(); // src
 2931 
 2932     m4-&gt;_opnds[0] = new  vecXOper();     // dst
 2933     m4-&gt;_opnds[1] = new  vecXOper();     // src
 2934     m4-&gt;_opnds[2] = zero;
 2935 
 2936     // Initialize ins_attrib TOC fields.
 2937     m1-&gt;_const_toc_offset = -1;
 2938     m2-&gt;_const_toc_offset_hi_node = m1;
 2939 
 2940     // Initialize ins_attrib instruction offset.
 2941     m1-&gt;_cbuf_insts_offset = -1;
 2942 
 2943     // register allocation for new nodes
 2944     ra_-&gt;set_pair(m1-&gt;_idx, reg_second, reg_first);
 2945     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2946     ra_-&gt;set1(m3-&gt;_idx, reg_second);
 2947     ra_-&gt;set2(m3-&gt;_idx, reg_vec_first);
 2948     ra_-&gt;set_pair(m4-&gt;_idx, reg_vec_second, reg_vec_first);
 2949 
 2950     // Create result.
 2951     nodes._large_hi = m1;
 2952     nodes._large_lo = m2;
 2953     nodes._moved = m3;
 2954     nodes._replicated = m4;
 2955     nodes._small = NULL;
 2956     nodes._last = nodes._replicated;
 2957     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 2958   } else {
 2959     loadConLNode *m2 = new  loadConLNode();
 2960     mtvsrdNode *m3 = new  mtvsrdNode();
 2961     xxspltdNode *m4 = new  xxspltdNode();
 2962 
 2963     // inputs for new nodes
 2964     m2-&gt;add_req(NULL, toc);
 2965 
 2966     // operands for new nodes
 2967     m2-&gt;_opnds[0] = new  iRegLdstOper(); // dst
 2968     m2-&gt;_opnds[1] = immSrc;              // src
 2969     m2-&gt;_opnds[2] = new  iRegPdstOper(); // toc
 2970 
 2971     m3-&gt;_opnds[0] = new  vecXOper();     // dst
 2972     m3-&gt;_opnds[1] = new  iRegLdstOper(); // src
 2973 
 2974     m4-&gt;_opnds[0] = new  vecXOper();     // dst
 2975     m4-&gt;_opnds[1] = new  vecXOper();     // src
 2976     m4-&gt;_opnds[2] = zero;
 2977 
 2978     // Initialize ins_attrib instruction offset.
 2979     m2-&gt;_cbuf_insts_offset = -1;
 2980     ra_-&gt;set1(m3-&gt;_idx, reg_second);
 2981     ra_-&gt;set2(m3-&gt;_idx, reg_vec_first);
 2982     ra_-&gt;set_pair(m4-&gt;_idx, reg_vec_second, reg_vec_first);
 2983 
 2984     // register allocation for new nodes
 2985     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2986 
 2987     // Create result.
 2988     nodes._large_hi = NULL;
 2989     nodes._large_lo = NULL;
 2990     nodes._small = m2;
 2991     nodes._moved = m3;
 2992     nodes._replicated = m4;
 2993     nodes._last = nodes._replicated;
 2994     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 2995   }
 2996 
 2997   return nodes;
 2998 }
 2999 
 3000 %} // source
 3001 
 3002 encode %{
 3003   // Postalloc expand emitter for loading a long constant from the method&#39;s TOC.
 3004   // Enc_class needed as consttanttablebase is not supported by postalloc
 3005   // expand.
 3006   enc_class postalloc_expand_load_long_constant(iRegLdst dst, immL src, iRegLdst toc) %{
 3007     // Create new nodes.
 3008     loadConLNodesTuple loadConLNodes =
 3009       loadConLNodesTuple_create(ra_, n_toc, op_src,
 3010                                 ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3011 
 3012     // Push new nodes.
 3013     if (loadConLNodes._large_hi) nodes-&gt;push(loadConLNodes._large_hi);
 3014     if (loadConLNodes._last)     nodes-&gt;push(loadConLNodes._last);
 3015 
 3016     // some asserts
 3017     assert(nodes-&gt;length() &gt;= 1, &quot;must have created at least 1 node&quot;);
 3018     assert(loadConLNodes._last-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 3019   %}
 3020 
 3021   enc_class enc_load_long_constP(iRegLdst dst, immP src, iRegLdst toc) %{
 3022     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 3023 
<a name="44" id="anc44"></a><span class="line-modified"> 3024     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3025     int toc_offset = 0;
 3026 
 3027     intptr_t val = $src$$constant;
 3028     relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();  // src
 3029     address const_toc_addr;
 3030     if (constant_reloc == relocInfo::oop_type) {
 3031       // Create an oop constant and a corresponding relocation.
 3032       AddressLiteral a = __ allocate_oop_address((jobject)val);
 3033       const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3034       __ relocate(a.rspec());
 3035     } else if (constant_reloc == relocInfo::metadata_type) {
 3036       AddressLiteral a = __ constant_metadata_address((Metadata *)val);
 3037       const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3038       __ relocate(a.rspec());
 3039     } else {
 3040       // Create a non-oop constant, no relocation needed.
 3041       const_toc_addr = __ long_constant((jlong)$src$$constant);
 3042     }
 3043 
 3044     if (const_toc_addr == NULL) {
 3045       ciEnv::current()-&gt;record_out_of_memory_failure();
 3046       return;
 3047     }
 3048     // Get the constant&#39;s TOC offset.
 3049     toc_offset = __ offset_to_method_toc(const_toc_addr);
 3050 
 3051     __ ld($dst$$Register, toc_offset, $toc$$Register);
 3052   %}
 3053 
 3054   enc_class enc_load_long_constP_hi(iRegLdst dst, immP src, iRegLdst toc) %{
 3055     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 3056 
<a name="45" id="anc45"></a><span class="line-modified"> 3057     C2_MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-modified"> 3058     if (!ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size()) {</span>
 3059       intptr_t val = $src$$constant;
 3060       relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();  // src
 3061       address const_toc_addr;
 3062       if (constant_reloc == relocInfo::oop_type) {
 3063         // Create an oop constant and a corresponding relocation.
 3064         AddressLiteral a = __ allocate_oop_address((jobject)val);
 3065         const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3066         __ relocate(a.rspec());
 3067       } else if (constant_reloc == relocInfo::metadata_type) {
 3068         AddressLiteral a = __ constant_metadata_address((Metadata *)val);
 3069         const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3070         __ relocate(a.rspec());
 3071       } else {  // non-oop pointers, e.g. card mark base, heap top
 3072         // Create a non-oop constant, no relocation needed.
 3073         const_toc_addr = __ long_constant((jlong)$src$$constant);
 3074       }
 3075 
 3076       if (const_toc_addr == NULL) {
 3077         ciEnv::current()-&gt;record_out_of_memory_failure();
 3078         return;
 3079       }
 3080       // Get the constant&#39;s TOC offset.
 3081       const int toc_offset = __ offset_to_method_toc(const_toc_addr);
 3082       // Store the toc offset of the constant.
 3083       ((loadConP_hiNode*)this)-&gt;_const_toc_offset = toc_offset;
 3084     }
 3085 
 3086     __ addis($dst$$Register, $toc$$Register, MacroAssembler::largeoffset_si16_si16_hi(_const_toc_offset));
 3087   %}
 3088 
 3089   // Postalloc expand emitter for loading a ptr constant from the method&#39;s TOC.
 3090   // Enc_class needed as consttanttablebase is not supported by postalloc
 3091   // expand.
 3092   enc_class postalloc_expand_load_ptr_constant(iRegPdst dst, immP src, iRegLdst toc) %{
 3093     const bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 3094     if (large_constant_pool) {
 3095       // Create new nodes.
 3096       loadConP_hiNode *m1 = new loadConP_hiNode();
 3097       loadConP_loNode *m2 = new loadConP_loNode();
 3098 
 3099       // inputs for new nodes
 3100       m1-&gt;add_req(NULL, n_toc);
 3101       m2-&gt;add_req(NULL, m1);
 3102 
 3103       // operands for new nodes
 3104       m1-&gt;_opnds[0] = new iRegPdstOper(); // dst
 3105       m1-&gt;_opnds[1] = op_src;             // src
 3106       m1-&gt;_opnds[2] = new iRegPdstOper(); // toc
 3107       m2-&gt;_opnds[0] = new iRegPdstOper(); // dst
 3108       m2-&gt;_opnds[1] = op_src;             // src
 3109       m2-&gt;_opnds[2] = new iRegLdstOper(); // base
 3110 
 3111       // Initialize ins_attrib TOC fields.
 3112       m1-&gt;_const_toc_offset = -1;
 3113       m2-&gt;_const_toc_offset_hi_node = m1;
 3114 
 3115       // Register allocation for new nodes.
 3116       ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3117       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3118 
 3119       nodes-&gt;push(m1);
 3120       nodes-&gt;push(m2);
 3121       assert(m2-&gt;bottom_type()-&gt;isa_ptr(), &quot;must be ptr&quot;);
 3122     } else {
 3123       loadConPNode *m2 = new loadConPNode();
 3124 
 3125       // inputs for new nodes
 3126       m2-&gt;add_req(NULL, n_toc);
 3127 
 3128       // operands for new nodes
 3129       m2-&gt;_opnds[0] = new iRegPdstOper(); // dst
 3130       m2-&gt;_opnds[1] = op_src;             // src
 3131       m2-&gt;_opnds[2] = new iRegPdstOper(); // toc
 3132 
 3133       // Register allocation for new nodes.
 3134       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3135 
 3136       nodes-&gt;push(m2);
 3137       assert(m2-&gt;bottom_type()-&gt;isa_ptr(), &quot;must be ptr&quot;);
 3138     }
 3139   %}
 3140 
 3141   // Enc_class needed as consttanttablebase is not supported by postalloc
 3142   // expand.
 3143   enc_class postalloc_expand_load_float_constant(regF dst, immF src, iRegLdst toc) %{
 3144     bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 3145 
 3146     MachNode *m2;
 3147     if (large_constant_pool) {
 3148       m2 = new loadConFCompNode();
 3149     } else {
 3150       m2 = new loadConFNode();
 3151     }
 3152     // inputs for new nodes
 3153     m2-&gt;add_req(NULL, n_toc);
 3154 
 3155     // operands for new nodes
 3156     m2-&gt;_opnds[0] = op_dst;
 3157     m2-&gt;_opnds[1] = op_src;
 3158     m2-&gt;_opnds[2] = new iRegPdstOper(); // constanttablebase
 3159 
 3160     // register allocation for new nodes
 3161     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3162     nodes-&gt;push(m2);
 3163   %}
 3164 
 3165   // Enc_class needed as consttanttablebase is not supported by postalloc
 3166   // expand.
 3167   enc_class postalloc_expand_load_double_constant(regD dst, immD src, iRegLdst toc) %{
 3168     bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 3169 
 3170     MachNode *m2;
 3171     if (large_constant_pool) {
 3172       m2 = new loadConDCompNode();
 3173     } else {
 3174       m2 = new loadConDNode();
 3175     }
 3176     // inputs for new nodes
 3177     m2-&gt;add_req(NULL, n_toc);
 3178 
 3179     // operands for new nodes
 3180     m2-&gt;_opnds[0] = op_dst;
 3181     m2-&gt;_opnds[1] = op_src;
 3182     m2-&gt;_opnds[2] = new iRegPdstOper(); // constanttablebase
 3183 
 3184     // register allocation for new nodes
 3185     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3186     nodes-&gt;push(m2);
 3187   %}
 3188 
 3189   enc_class enc_stw(iRegIsrc src, memory mem) %{
 3190     // TODO: PPC port $archOpcode(ppc64Opcode_stw);
<a name="46" id="anc46"></a><span class="line-modified"> 3191     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3192     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3193     __ stw($src$$Register, Idisp, $mem$$base$$Register);
 3194   %}
 3195 
 3196   enc_class enc_std(iRegIsrc src, memoryAlg4 mem) %{
 3197     // TODO: PPC port $archOpcode(ppc64Opcode_std);
<a name="47" id="anc47"></a><span class="line-modified"> 3198     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3199     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3200     // Operand &#39;ds&#39; requires 4-alignment.
 3201     assert((Idisp &amp; 0x3) == 0, &quot;unaligned offset&quot;);
 3202     __ std($src$$Register, Idisp, $mem$$base$$Register);
 3203   %}
 3204 
 3205   enc_class enc_stfs(RegF src, memory mem) %{
 3206     // TODO: PPC port $archOpcode(ppc64Opcode_stfs);
<a name="48" id="anc48"></a><span class="line-modified"> 3207     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3208     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3209     __ stfs($src$$FloatRegister, Idisp, $mem$$base$$Register);
 3210   %}
 3211 
 3212   enc_class enc_stfd(RegF src, memory mem) %{
 3213     // TODO: PPC port $archOpcode(ppc64Opcode_stfd);
<a name="49" id="anc49"></a><span class="line-modified"> 3214     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3215     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3216     __ stfd($src$$FloatRegister, Idisp, $mem$$base$$Register);
 3217   %}
 3218 
 3219   // Use release_store for card-marking to ensure that previous
 3220   // oop-stores are visible before the card-mark change.
 3221   enc_class enc_cms_card_mark(memory mem, iRegLdst releaseFieldAddr, flagsReg crx) %{
 3222     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3223     // FIXME: Implement this as a cmove and use a fixed condition code
 3224     // register which is written on every transition to compiled code,
 3225     // e.g. in call-stub and when returning from runtime stubs.
 3226     //
 3227     // Proposed code sequence for the cmove implementation:
 3228     //
 3229     // Label skip_release;
 3230     // __ beq(CCRfixed, skip_release);
 3231     // __ release();
 3232     // __ bind(skip_release);
 3233     // __ stb(card mark);
 3234 
<a name="50" id="anc50"></a><span class="line-modified"> 3235     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3236     Label skip_storestore;
 3237 
 3238 #if 0 // TODO: PPC port
 3239     // Check CMSCollectorCardTableBarrierSetBSExt::_requires_release and do the
 3240     // StoreStore barrier conditionally.
 3241     __ lwz(R0, 0, $releaseFieldAddr$$Register);
 3242     __ cmpwi($crx$$CondRegister, R0, 0);
 3243     __ beq_predict_taken($crx$$CondRegister, skip_storestore);
 3244 #endif
 3245     __ li(R0, 0);
 3246     __ membar(Assembler::StoreStore);
 3247 #if 0 // TODO: PPC port
 3248     __ bind(skip_storestore);
 3249 #endif
 3250 
 3251     // Do the store.
 3252     if ($mem$$index == 0) {
 3253       __ stb(R0, $mem$$disp, $mem$$base$$Register);
 3254     } else {
 3255       assert(0 == $mem$$disp, &quot;no displacement possible with indexed load/stores on ppc&quot;);
 3256       __ stbx(R0, $mem$$base$$Register, $mem$$index$$Register);
 3257     }
 3258   %}
 3259 
 3260   enc_class postalloc_expand_encode_oop(iRegNdst dst, iRegPdst src, flagsReg crx) %{
 3261 
 3262     if (VM_Version::has_isel()) {
 3263       // use isel instruction with Power 7
 3264       cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();
 3265       encodeP_subNode    *n_sub_base = new encodeP_subNode();
 3266       encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();
 3267       cond_set_0_oopNode *n_cond_set = new cond_set_0_oopNode();
 3268 
 3269       n_compare-&gt;add_req(n_region, n_src);
 3270       n_compare-&gt;_opnds[0] = op_crx;
 3271       n_compare-&gt;_opnds[1] = op_src;
 3272       n_compare-&gt;_opnds[2] = new immL16Oper(0);
 3273 
 3274       n_sub_base-&gt;add_req(n_region, n_src);
 3275       n_sub_base-&gt;_opnds[0] = op_dst;
 3276       n_sub_base-&gt;_opnds[1] = op_src;
 3277       n_sub_base-&gt;_bottom_type = _bottom_type;
 3278 
 3279       n_shift-&gt;add_req(n_region, n_sub_base);
 3280       n_shift-&gt;_opnds[0] = op_dst;
 3281       n_shift-&gt;_opnds[1] = op_dst;
 3282       n_shift-&gt;_bottom_type = _bottom_type;
 3283 
 3284       n_cond_set-&gt;add_req(n_region, n_compare, n_shift);
 3285       n_cond_set-&gt;_opnds[0] = op_dst;
 3286       n_cond_set-&gt;_opnds[1] = op_crx;
 3287       n_cond_set-&gt;_opnds[2] = op_dst;
 3288       n_cond_set-&gt;_bottom_type = _bottom_type;
 3289 
 3290       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3291       ra_-&gt;set_pair(n_sub_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3292       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3293       ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3294 
 3295       nodes-&gt;push(n_compare);
 3296       nodes-&gt;push(n_sub_base);
 3297       nodes-&gt;push(n_shift);
 3298       nodes-&gt;push(n_cond_set);
 3299 
 3300     } else {
 3301       // before Power 7
 3302       moveRegNode        *n_move     = new moveRegNode();
 3303       cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();
 3304       encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();
 3305       cond_sub_baseNode  *n_sub_base = new cond_sub_baseNode();
 3306 
 3307       n_move-&gt;add_req(n_region, n_src);
 3308       n_move-&gt;_opnds[0] = op_dst;
 3309       n_move-&gt;_opnds[1] = op_src;
 3310       ra_-&gt;set_oop(n_move, true); // Until here, &#39;n_move&#39; still produces an oop.
 3311 
 3312       n_compare-&gt;add_req(n_region, n_src);
 3313       n_compare-&gt;add_prec(n_move);
 3314 
 3315       n_compare-&gt;_opnds[0] = op_crx;
 3316       n_compare-&gt;_opnds[1] = op_src;
 3317       n_compare-&gt;_opnds[2] = new immL16Oper(0);
 3318 
 3319       n_sub_base-&gt;add_req(n_region, n_compare, n_src);
 3320       n_sub_base-&gt;_opnds[0] = op_dst;
 3321       n_sub_base-&gt;_opnds[1] = op_crx;
 3322       n_sub_base-&gt;_opnds[2] = op_src;
 3323       n_sub_base-&gt;_bottom_type = _bottom_type;
 3324 
 3325       n_shift-&gt;add_req(n_region, n_sub_base);
 3326       n_shift-&gt;_opnds[0] = op_dst;
 3327       n_shift-&gt;_opnds[1] = op_dst;
 3328       n_shift-&gt;_bottom_type = _bottom_type;
 3329 
 3330       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3331       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3332       ra_-&gt;set_pair(n_sub_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3333       ra_-&gt;set_pair(n_move-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3334 
 3335       nodes-&gt;push(n_move);
 3336       nodes-&gt;push(n_compare);
 3337       nodes-&gt;push(n_sub_base);
 3338       nodes-&gt;push(n_shift);
 3339     }
 3340 
 3341     assert(!(ra_-&gt;is_oop(this)), &quot;sanity&quot;); // This is not supposed to be GC&#39;ed.
 3342   %}
 3343 
 3344   enc_class postalloc_expand_encode_oop_not_null(iRegNdst dst, iRegPdst src) %{
 3345 
 3346     encodeP_subNode *n1 = new encodeP_subNode();
 3347     n1-&gt;add_req(n_region, n_src);
 3348     n1-&gt;_opnds[0] = op_dst;
 3349     n1-&gt;_opnds[1] = op_src;
 3350     n1-&gt;_bottom_type = _bottom_type;
 3351 
 3352     encodeP_shiftNode *n2 = new encodeP_shiftNode();
 3353     n2-&gt;add_req(n_region, n1);
 3354     n2-&gt;_opnds[0] = op_dst;
 3355     n2-&gt;_opnds[1] = op_dst;
 3356     n2-&gt;_bottom_type = _bottom_type;
 3357     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3358     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3359 
 3360     nodes-&gt;push(n1);
 3361     nodes-&gt;push(n2);
 3362     assert(!(ra_-&gt;is_oop(this)), &quot;sanity&quot;); // This is not supposed to be GC&#39;ed.
 3363   %}
 3364 
 3365   enc_class postalloc_expand_decode_oop(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
 3366     decodeN_shiftNode *n_shift    = new decodeN_shiftNode();
 3367     cmpN_reg_imm0Node *n_compare  = new cmpN_reg_imm0Node();
 3368 
 3369     n_compare-&gt;add_req(n_region, n_src);
 3370     n_compare-&gt;_opnds[0] = op_crx;
 3371     n_compare-&gt;_opnds[1] = op_src;
 3372     n_compare-&gt;_opnds[2] = new immN_0Oper(TypeNarrowOop::NULL_PTR);
 3373 
 3374     n_shift-&gt;add_req(n_region, n_src);
 3375     n_shift-&gt;_opnds[0] = op_dst;
 3376     n_shift-&gt;_opnds[1] = op_src;
 3377     n_shift-&gt;_bottom_type = _bottom_type;
 3378 
 3379     if (VM_Version::has_isel()) {
 3380       // use isel instruction with Power 7
 3381 
 3382       decodeN_addNode *n_add_base = new decodeN_addNode();
 3383       n_add_base-&gt;add_req(n_region, n_shift);
 3384       n_add_base-&gt;_opnds[0] = op_dst;
 3385       n_add_base-&gt;_opnds[1] = op_dst;
 3386       n_add_base-&gt;_bottom_type = _bottom_type;
 3387 
 3388       cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();
 3389       n_cond_set-&gt;add_req(n_region, n_compare, n_add_base);
 3390       n_cond_set-&gt;_opnds[0] = op_dst;
 3391       n_cond_set-&gt;_opnds[1] = op_crx;
 3392       n_cond_set-&gt;_opnds[2] = op_dst;
 3393       n_cond_set-&gt;_bottom_type = _bottom_type;
 3394 
 3395       assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 3396       ra_-&gt;set_oop(n_cond_set, true);
 3397 
 3398       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3399       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3400       ra_-&gt;set_pair(n_add_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3401       ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3402 
 3403       nodes-&gt;push(n_compare);
 3404       nodes-&gt;push(n_shift);
 3405       nodes-&gt;push(n_add_base);
 3406       nodes-&gt;push(n_cond_set);
 3407 
 3408     } else {
 3409       // before Power 7
 3410       cond_add_baseNode *n_add_base = new cond_add_baseNode();
 3411 
 3412       n_add_base-&gt;add_req(n_region, n_compare, n_shift);
 3413       n_add_base-&gt;_opnds[0] = op_dst;
 3414       n_add_base-&gt;_opnds[1] = op_crx;
 3415       n_add_base-&gt;_opnds[2] = op_dst;
 3416       n_add_base-&gt;_bottom_type = _bottom_type;
 3417 
 3418       assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 3419       ra_-&gt;set_oop(n_add_base, true);
 3420 
 3421       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3422       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3423       ra_-&gt;set_pair(n_add_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3424 
 3425       nodes-&gt;push(n_compare);
 3426       nodes-&gt;push(n_shift);
 3427       nodes-&gt;push(n_add_base);
 3428     }
 3429   %}
 3430 
 3431   enc_class postalloc_expand_decode_oop_not_null(iRegPdst dst, iRegNsrc src) %{
 3432     decodeN_shiftNode *n1 = new decodeN_shiftNode();
 3433     n1-&gt;add_req(n_region, n_src);
 3434     n1-&gt;_opnds[0] = op_dst;
 3435     n1-&gt;_opnds[1] = op_src;
 3436     n1-&gt;_bottom_type = _bottom_type;
 3437 
 3438     decodeN_addNode *n2 = new decodeN_addNode();
 3439     n2-&gt;add_req(n_region, n1);
 3440     n2-&gt;_opnds[0] = op_dst;
 3441     n2-&gt;_opnds[1] = op_dst;
 3442     n2-&gt;_bottom_type = _bottom_type;
 3443     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3444     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3445 
 3446     assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 3447     ra_-&gt;set_oop(n2, true);
 3448 
 3449     nodes-&gt;push(n1);
 3450     nodes-&gt;push(n2);
 3451   %}
 3452 
 3453   enc_class enc_cmove_reg(iRegIdst dst, flagsRegSrc crx, iRegIsrc src, cmpOp cmp) %{
 3454     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3455 
<a name="51" id="anc51"></a><span class="line-modified"> 3456     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3457     int cc        = $cmp$$cmpcode;
 3458     int flags_reg = $crx$$reg;
 3459     Label done;
 3460     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 3461     // Branch if not (cmp crx).
 3462     __ bc(cc_to_inverse_boint(cc), cc_to_biint(cc, flags_reg), done);
 3463     __ mr($dst$$Register, $src$$Register);
 3464     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3465     __ bind(done);
 3466   %}
 3467 
 3468   enc_class enc_cmove_imm(iRegIdst dst, flagsRegSrc crx, immI16 src, cmpOp cmp) %{
 3469     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3470 
<a name="52" id="anc52"></a><span class="line-modified"> 3471     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3472     Label done;
 3473     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 3474     // Branch if not (cmp crx).
 3475     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
 3476     __ li($dst$$Register, $src$$constant);
 3477     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3478     __ bind(done);
 3479   %}
 3480 
 3481   // This enc_class is needed so that scheduler gets proper
 3482   // input mapping for latency computation.
 3483   enc_class enc_andc(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 3484     // TODO: PPC port $archOpcode(ppc64Opcode_andc);
<a name="53" id="anc53"></a><span class="line-modified"> 3485     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3486     __ andc($dst$$Register, $src1$$Register, $src2$$Register);
 3487   %}
 3488 
 3489   enc_class enc_convI2B_regI__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{
 3490     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3491 
<a name="54" id="anc54"></a><span class="line-modified"> 3492     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3493 
 3494     Label done;
 3495     __ cmpwi($crx$$CondRegister, $src$$Register, 0);
 3496     __ li($dst$$Register, $zero$$constant);
 3497     __ beq($crx$$CondRegister, done);
 3498     __ li($dst$$Register, $notzero$$constant);
 3499     __ bind(done);
 3500   %}
 3501 
 3502   enc_class enc_convP2B_regP__cmove(iRegIdst dst, iRegPsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{
 3503     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3504 
<a name="55" id="anc55"></a><span class="line-modified"> 3505     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3506 
 3507     Label done;
 3508     __ cmpdi($crx$$CondRegister, $src$$Register, 0);
 3509     __ li($dst$$Register, $zero$$constant);
 3510     __ beq($crx$$CondRegister, done);
 3511     __ li($dst$$Register, $notzero$$constant);
 3512     __ bind(done);
 3513   %}
 3514 
 3515   enc_class enc_cmove_bso_stackSlotL(iRegLdst dst, flagsRegSrc crx, stackSlotL mem ) %{
 3516     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3517 
<a name="56" id="anc56"></a><span class="line-modified"> 3518     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3519     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3520     Label done;
 3521     __ bso($crx$$CondRegister, done);
 3522     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
 3523     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3524     __ bind(done);
 3525   %}
 3526 
 3527   enc_class enc_cmove_bso_reg(iRegLdst dst, flagsRegSrc crx, regD src) %{
 3528     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3529 
<a name="57" id="anc57"></a><span class="line-modified"> 3530     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3531     Label done;
 3532     __ bso($crx$$CondRegister, done);
 3533     __ mffprd($dst$$Register, $src$$FloatRegister);
 3534     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3535     __ bind(done);
 3536   %}
 3537 
 3538   enc_class enc_bc(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
 3539     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
 3540 
<a name="58" id="anc58"></a><span class="line-modified"> 3541     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3542     Label d;   // dummy
 3543     __ bind(d);
 3544     Label* p = ($lbl$$label);
 3545     // `p&#39; is `NULL&#39; when this encoding class is used only to
 3546     // determine the size of the encoded instruction.
 3547     Label&amp; l = (NULL == p)? d : *(p);
 3548     int cc = $cmp$$cmpcode;
 3549     int flags_reg = $crx$$reg;
 3550     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 3551     int bhint = Assembler::bhintNoHint;
 3552 
 3553     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
 3554       if (_prob &lt;= PROB_NEVER) {
 3555         bhint = Assembler::bhintIsNotTaken;
 3556       } else if (_prob &gt;= PROB_ALWAYS) {
 3557         bhint = Assembler::bhintIsTaken;
 3558       }
 3559     }
 3560 
 3561     __ bc(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3562           cc_to_biint(cc, flags_reg),
 3563           l);
 3564   %}
 3565 
 3566   enc_class enc_bc_far(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
 3567     // The scheduler doesn&#39;t know about branch shortening, so we set the opcode
 3568     // to ppc64Opcode_bc in order to hide this detail from the scheduler.
 3569     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
 3570 
<a name="59" id="anc59"></a><span class="line-modified"> 3571     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3572     Label d;    // dummy
 3573     __ bind(d);
 3574     Label* p = ($lbl$$label);
 3575     // `p&#39; is `NULL&#39; when this encoding class is used only to
 3576     // determine the size of the encoded instruction.
 3577     Label&amp; l = (NULL == p)? d : *(p);
 3578     int cc = $cmp$$cmpcode;
 3579     int flags_reg = $crx$$reg;
 3580     int bhint = Assembler::bhintNoHint;
 3581 
 3582     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
 3583       if (_prob &lt;= PROB_NEVER) {
 3584         bhint = Assembler::bhintIsNotTaken;
 3585       } else if (_prob &gt;= PROB_ALWAYS) {
 3586         bhint = Assembler::bhintIsTaken;
 3587       }
 3588     }
 3589 
 3590     // Tell the conditional far branch to optimize itself when being relocated.
 3591     __ bc_far(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3592                   cc_to_biint(cc, flags_reg),
 3593                   l,
 3594                   MacroAssembler::bc_far_optimize_on_relocate);
 3595   %}
 3596 
 3597   // Branch used with Power6 scheduling (can be shortened without changing the node).
 3598   enc_class enc_bc_short_far(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
 3599     // The scheduler doesn&#39;t know about branch shortening, so we set the opcode
 3600     // to ppc64Opcode_bc in order to hide this detail from the scheduler.
 3601     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
 3602 
<a name="60" id="anc60"></a><span class="line-modified"> 3603     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3604     Label d;   // dummy
 3605     __ bind(d);
 3606     Label* p = ($lbl$$label);
 3607     // `p&#39; is `NULL&#39; when this encoding class is used only to
 3608     // determine the size of the encoded instruction.
 3609     Label&amp; l = (NULL == p)? d : *(p);
 3610     int cc = $cmp$$cmpcode;
 3611     int flags_reg = $crx$$reg;
 3612     int bhint = Assembler::bhintNoHint;
 3613 
 3614     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
 3615       if (_prob &lt;= PROB_NEVER) {
 3616         bhint = Assembler::bhintIsNotTaken;
 3617       } else if (_prob &gt;= PROB_ALWAYS) {
 3618         bhint = Assembler::bhintIsTaken;
 3619       }
 3620     }
 3621 
 3622 #if 0 // TODO: PPC port
 3623     if (_size == 8) {
 3624       // Tell the conditional far branch to optimize itself when being relocated.
 3625       __ bc_far(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3626                     cc_to_biint(cc, flags_reg),
 3627                     l,
 3628                     MacroAssembler::bc_far_optimize_on_relocate);
 3629     } else {
 3630       __ bc    (Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3631                     cc_to_biint(cc, flags_reg),
 3632                     l);
 3633     }
 3634 #endif
 3635     Unimplemented();
 3636   %}
 3637 
 3638   // Postalloc expand emitter for loading a replicatef float constant from
 3639   // the method&#39;s TOC.
 3640   // Enc_class needed as consttanttablebase is not supported by postalloc
 3641   // expand.
 3642   enc_class postalloc_expand_load_replF_constant(iRegLdst dst, immF src, iRegLdst toc) %{
 3643     // Create new nodes.
 3644 
 3645     // Make an operand with the bit pattern to load as float.
 3646     immLOper *op_repl = new immLOper((jlong)replicate_immF(op_src-&gt;constantF()));
 3647 
 3648     loadConLNodesTuple loadConLNodes =
 3649       loadConLNodesTuple_create(ra_, n_toc, op_repl,
 3650                                 ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3651 
 3652     // Push new nodes.
 3653     if (loadConLNodes._large_hi) nodes-&gt;push(loadConLNodes._large_hi);
 3654     if (loadConLNodes._last)     nodes-&gt;push(loadConLNodes._last);
 3655 
 3656     assert(nodes-&gt;length() &gt;= 1, &quot;must have created at least 1 node&quot;);
 3657     assert(loadConLNodes._last-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 3658   %}
 3659 
 3660   enc_class postalloc_expand_load_replF_constant_vsx(vecX dst, immF src, iRegLdst toc, iRegLdst tmp) %{
 3661     // Create new nodes.
 3662 
 3663     // Make an operand with the bit pattern to load as float.
 3664     immLOper *op_repl = new  immLOper((jlong)replicate_immF(op_src-&gt;constantF()));
 3665     immI_0Oper *op_zero = new  immI_0Oper(0);
 3666 
 3667     loadConLReplicatedNodesTuple loadConLNodes =
 3668       loadConLReplicatedNodesTuple_create(C, ra_, n_toc, op_repl, op_dst, op_zero,
 3669                                 ra_-&gt;get_reg_second(n_tmp), ra_-&gt;get_reg_first(n_tmp),
 3670                                 ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3671 
 3672     // Push new nodes.
 3673     if (loadConLNodes._large_hi) { nodes-&gt;push(loadConLNodes._large_hi); }
 3674     if (loadConLNodes._large_lo) { nodes-&gt;push(loadConLNodes._large_lo); }
 3675     if (loadConLNodes._moved)    { nodes-&gt;push(loadConLNodes._moved); }
 3676     if (loadConLNodes._last)     { nodes-&gt;push(loadConLNodes._last); }
 3677 
 3678     assert(nodes-&gt;length() &gt;= 1, &quot;must have created at least 1 node&quot;);
 3679   %}
 3680 
 3681   // This enc_class is needed so that scheduler gets proper
 3682   // input mapping for latency computation.
 3683   enc_class enc_poll(immI dst, iRegLdst poll) %{
 3684     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 3685     // Fake operand dst needed for PPC scheduler.
 3686     assert($dst$$constant == 0x0, &quot;dst must be 0x0&quot;);
 3687 
<a name="61" id="anc61"></a><span class="line-modified"> 3688     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3689     // Mark the code position where the load from the safepoint
 3690     // polling page was emitted as relocInfo::poll_type.
 3691     __ relocate(relocInfo::poll_type);
 3692     __ load_from_polling_page($poll$$Register);
 3693   %}
 3694 
 3695   // A Java static call or a runtime call.
 3696   //
 3697   // Branch-and-link relative to a trampoline.
 3698   // The trampoline loads the target address and does a long branch to there.
 3699   // In case we call java, the trampoline branches to a interpreter_stub
 3700   // which loads the inline cache and the real call target from the constant pool.
 3701   //
 3702   // This basically looks like this:
 3703   //
 3704   // &gt;&gt;&gt;&gt; consts      -+  -+
 3705   //                   |   |- offset1
 3706   // [call target1]    | &lt;-+
 3707   // [IC cache]        |- offset2
 3708   // [call target2] &lt;--+
 3709   //
 3710   // &lt;&lt;&lt;&lt; consts
 3711   // &gt;&gt;&gt;&gt; insts
 3712   //
 3713   // bl offset16               -+  -+             ??? // How many bits available?
 3714   //                            |   |
 3715   // &lt;&lt;&lt;&lt; insts                 |   |
 3716   // &gt;&gt;&gt;&gt; stubs                 |   |
 3717   //                            |   |- trampoline_stub_Reloc
 3718   // trampoline stub:           | &lt;-+
 3719   //   r2 = toc                 |
 3720   //   r2 = [r2 + offset1]      |       // Load call target1 from const section
 3721   //   mtctr r2                 |
 3722   //   bctr                     |- static_stub_Reloc
 3723   // comp_to_interp_stub:   &lt;---+
 3724   //   r1 = toc
 3725   //   ICreg = [r1 + IC_offset]         // Load IC from const section
 3726   //   r1    = [r1 + offset2]           // Load call target2 from const section
 3727   //   mtctr r1
 3728   //   bctr
 3729   //
 3730   // &lt;&lt;&lt;&lt; stubs
 3731   //
 3732   // The call instruction in the code either
 3733   // - Branches directly to a compiled method if the offset is encodable in instruction.
 3734   // - Branches to the trampoline stub if the offset to the compiled method is not encodable.
 3735   // - Branches to the compiled_to_interp stub if the target is interpreted.
 3736   //
 3737   // Further there are three relocations from the loads to the constants in
 3738   // the constant section.
 3739   //
 3740   // Usage of r1 and r2 in the stubs allows to distinguish them.
 3741   enc_class enc_java_static_call(method meth) %{
 3742     // TODO: PPC port $archOpcode(ppc64Opcode_bl);
 3743 
<a name="62" id="anc62"></a><span class="line-modified"> 3744     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3745     address entry_point = (address)$meth$$method;
 3746 
 3747     if (!_method) {
 3748       // A call to a runtime wrapper, e.g. new, new_typeArray_Java, uncommon_trap.
 3749       emit_call_with_trampoline_stub(_masm, entry_point, relocInfo::runtime_call_type);
 3750     } else {
 3751       // Remember the offset not the address.
 3752       const int start_offset = __ offset();
 3753 
 3754       // The trampoline stub.
 3755       // No entry point given, use the current pc.
 3756       // Make sure branch fits into
 3757       if (entry_point == 0) entry_point = __ pc();
 3758 
 3759       // Put the entry point as a constant into the constant pool.
 3760       const address entry_point_toc_addr = __ address_constant(entry_point, RelocationHolder::none);
 3761       if (entry_point_toc_addr == NULL) {
 3762         ciEnv::current()-&gt;record_out_of_memory_failure();
 3763         return;
 3764       }
 3765       const int entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);
 3766 
 3767       // Emit the trampoline stub which will be related to the branch-and-link below.
 3768       CallStubImpl::emit_trampoline_stub(_masm, entry_point_toc_offset, start_offset);
 3769       if (ciEnv::current()-&gt;failing()) { return; } // Code cache may be full.
 3770       int method_index = resolved_method_index(cbuf);
 3771       __ relocate(_optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 3772                   : static_call_Relocation::spec(method_index));
 3773 
 3774       // The real call.
 3775       // Note: At this point we do not have the address of the trampoline
 3776       // stub, and the entry point might be too far away for bl, so __ pc()
 3777       // serves as dummy and the bl will be patched later.
 3778       cbuf.set_insts_mark();
 3779       __ bl(__ pc());  // Emits a relocation.
 3780 
 3781       // The stub for call to interpreter.
 3782       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 3783       if (stub == NULL) {
 3784         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 3785         return;
 3786       }
 3787     }
 3788   %}
 3789 
 3790   // Second node of expanded dynamic call - the call.
 3791   enc_class enc_java_dynamic_call_sched(method meth) %{
 3792     // TODO: PPC port $archOpcode(ppc64Opcode_bl);
 3793 
<a name="63" id="anc63"></a><span class="line-modified"> 3794     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3795 
<a name="64" id="anc64"></a><span class="line-modified"> 3796     if (!ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size()) {</span>
 3797       // Create a call trampoline stub for the given method.
 3798       const address entry_point = !($meth$$method) ? 0 : (address)$meth$$method;
 3799       const address entry_point_const = __ address_constant(entry_point, RelocationHolder::none);
 3800       if (entry_point_const == NULL) {
 3801         ciEnv::current()-&gt;record_out_of_memory_failure();
 3802         return;
 3803       }
 3804       const int entry_point_const_toc_offset = __ offset_to_method_toc(entry_point_const);
 3805       CallStubImpl::emit_trampoline_stub(_masm, entry_point_const_toc_offset, __ offset());
 3806       if (ra_-&gt;C-&gt;env()-&gt;failing()) { return; } // Code cache may be full.
 3807 
 3808       // Build relocation at call site with ic position as data.
 3809       assert((_load_ic_hi_node != NULL &amp;&amp; _load_ic_node == NULL) ||
 3810              (_load_ic_hi_node == NULL &amp;&amp; _load_ic_node != NULL),
 3811              &quot;must have one, but can&#39;t have both&quot;);
 3812       assert((_load_ic_hi_node != NULL &amp;&amp; _load_ic_hi_node-&gt;_cbuf_insts_offset != -1) ||
 3813              (_load_ic_node != NULL    &amp;&amp; _load_ic_node-&gt;_cbuf_insts_offset != -1),
 3814              &quot;must contain instruction offset&quot;);
 3815       const int virtual_call_oop_addr_offset = _load_ic_hi_node != NULL
 3816         ? _load_ic_hi_node-&gt;_cbuf_insts_offset
 3817         : _load_ic_node-&gt;_cbuf_insts_offset;
 3818       const address virtual_call_oop_addr = __ addr_at(virtual_call_oop_addr_offset);
 3819       assert(MacroAssembler::is_load_const_from_method_toc_at(virtual_call_oop_addr),
 3820              &quot;should be load from TOC&quot;);
 3821       int method_index = resolved_method_index(cbuf);
 3822       __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
 3823     }
 3824 
 3825     // At this point I do not have the address of the trampoline stub,
 3826     // and the entry point might be too far away for bl. Pc() serves
 3827     // as dummy and bl will be patched later.
 3828     __ bl((address) __ pc());
 3829   %}
 3830 
 3831   // postalloc expand emitter for virtual calls.
 3832   enc_class postalloc_expand_java_dynamic_call_sched(method meth, iRegLdst toc) %{
 3833 
 3834     // Create the nodes for loading the IC from the TOC.
 3835     loadConLNodesTuple loadConLNodes_IC =
 3836       loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong)Universe::non_oop_word()),
 3837                                 OptoReg::Name(R19_H_num), OptoReg::Name(R19_num));
 3838 
 3839     // Create the call node.
 3840     CallDynamicJavaDirectSchedNode *call = new CallDynamicJavaDirectSchedNode();
 3841     call-&gt;_method_handle_invoke = _method_handle_invoke;
 3842     call-&gt;_vtable_index      = _vtable_index;
 3843     call-&gt;_method            = _method;
 3844     call-&gt;_bci               = _bci;
 3845     call-&gt;_optimized_virtual = _optimized_virtual;
 3846     call-&gt;_tf                = _tf;
 3847     call-&gt;_entry_point       = _entry_point;
 3848     call-&gt;_cnt               = _cnt;
 3849     call-&gt;_argsize           = _argsize;
 3850     call-&gt;_oop_map           = _oop_map;
 3851     call-&gt;_jvms              = _jvms;
 3852     call-&gt;_jvmadj            = _jvmadj;
 3853     call-&gt;_in_rms            = _in_rms;
 3854     call-&gt;_nesting           = _nesting;
 3855     call-&gt;_override_symbolic_info = _override_symbolic_info;
 3856 
 3857     // New call needs all inputs of old call.
 3858     // Req...
 3859     for (uint i = 0; i &lt; req(); ++i) {
 3860       // The expanded node does not need toc any more.
 3861       // Add the inline cache constant here instead. This expresses the
 3862       // register of the inline cache must be live at the call.
 3863       // Else we would have to adapt JVMState by -1.
 3864       if (i == mach_constant_base_node_input()) {
 3865         call-&gt;add_req(loadConLNodes_IC._last);
 3866       } else {
 3867         call-&gt;add_req(in(i));
 3868       }
 3869     }
 3870     // ...as well as prec
 3871     for (uint i = req(); i &lt; len(); ++i) {
 3872       call-&gt;add_prec(in(i));
 3873     }
 3874 
 3875     // Remember nodes loading the inline cache into r19.
 3876     call-&gt;_load_ic_hi_node = loadConLNodes_IC._large_hi;
 3877     call-&gt;_load_ic_node    = loadConLNodes_IC._small;
 3878 
 3879     // Operands for new nodes.
 3880     call-&gt;_opnds[0] = _opnds[0];
 3881     call-&gt;_opnds[1] = _opnds[1];
 3882 
 3883     // Only the inline cache is associated with a register.
 3884     assert(Matcher::inline_cache_reg() == OptoReg::Name(R19_num), &quot;ic reg should be R19&quot;);
 3885 
 3886     // Push new nodes.
 3887     if (loadConLNodes_IC._large_hi) nodes-&gt;push(loadConLNodes_IC._large_hi);
 3888     if (loadConLNodes_IC._last)     nodes-&gt;push(loadConLNodes_IC._last);
 3889     nodes-&gt;push(call);
 3890   %}
 3891 
 3892   // Compound version of call dynamic
 3893   // Toc is only passed so that it can be used in ins_encode statement.
 3894   // In the code we have to use $constanttablebase.
 3895   enc_class enc_java_dynamic_call(method meth, iRegLdst toc) %{
 3896     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<a name="65" id="anc65"></a><span class="line-modified"> 3897     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3898     int start_offset = __ offset();
 3899 
 3900     Register Rtoc = (ra_) ? $constanttablebase : R2_TOC;
 3901 #if 0
 3902     int vtable_index = this-&gt;_vtable_index;
 3903     if (_vtable_index &lt; 0) {
 3904       // Must be invalid_vtable_index, not nonvirtual_vtable_index.
 3905       assert(_vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
 3906       Register ic_reg = as_Register(Matcher::inline_cache_reg_encode());
 3907 
 3908       // Virtual call relocation will point to ic load.
 3909       address virtual_call_meta_addr = __ pc();
 3910       // Load a clear inline cache.
 3911       AddressLiteral empty_ic((address) Universe::non_oop_word());
 3912       bool success = __ load_const_from_method_toc(ic_reg, empty_ic, Rtoc, /*fixed_size*/ true);
 3913       if (!success) {
 3914         ciEnv::current()-&gt;record_out_of_memory_failure();
 3915         return;
 3916       }
 3917       // CALL to fixup routine.  Fixup routine uses ScopeDesc info
 3918       // to determine who we intended to call.
 3919       __ relocate(virtual_call_Relocation::spec(virtual_call_meta_addr));
 3920       emit_call_with_trampoline_stub(_masm, (address)$meth$$method, relocInfo::none);
 3921       assert(((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() == __ offset() - start_offset,
 3922              &quot;Fix constant in ret_addr_offset()&quot;);
 3923     } else {
 3924       assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 3925       // Go thru the vtable. Get receiver klass. Receiver already
 3926       // checked for non-null. If we&#39;ll go thru a C2I adapter, the
 3927       // interpreter expects method in R19_method.
 3928 
 3929       __ load_klass(R11_scratch1, R3);
 3930 
 3931       int entry_offset = in_bytes(Klass::vtable_start_offset()) + _vtable_index * vtableEntry::size_in_bytes();
 3932       int v_off = entry_offset + vtableEntry::method_offset_in_bytes();
 3933       __ li(R19_method, v_off);
 3934       __ ldx(R19_method/*method oop*/, R19_method/*method offset*/, R11_scratch1/*class*/);
 3935       // NOTE: for vtable dispatches, the vtable entry will never be
 3936       // null. However it may very well end up in handle_wrong_method
 3937       // if the method is abstract for the particular class.
 3938       __ ld(R11_scratch1, in_bytes(Method::from_compiled_offset()), R19_method);
 3939       // Call target. Either compiled code or C2I adapter.
 3940       __ mtctr(R11_scratch1);
 3941       __ bctrl();
 3942       if (((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() != __ offset() - start_offset) {
 3943         tty-&gt;print(&quot; %d, %d\n&quot;, ((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset(),__ offset() - start_offset);
 3944       }
 3945       assert(((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() == __ offset() - start_offset,
 3946              &quot;Fix constant in ret_addr_offset()&quot;);
 3947     }
 3948 #endif
 3949     Unimplemented();  // ret_addr_offset not yet fixed. Depends on compressed oops (load klass!).
 3950   %}
 3951 
 3952   // a runtime call
 3953   enc_class enc_java_to_runtime_call (method meth) %{
 3954     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3955 
<a name="66" id="anc66"></a><span class="line-modified"> 3956     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3957     const address start_pc = __ pc();
 3958 
 3959 #if defined(ABI_ELFv2)
 3960     address entry= !($meth$$method) ? NULL : (address)$meth$$method;
 3961     __ call_c(entry, relocInfo::runtime_call_type);
 3962 #else
 3963     // The function we&#39;re going to call.
 3964     FunctionDescriptor fdtemp;
 3965     const FunctionDescriptor* fd = !($meth$$method) ? &amp;fdtemp : (FunctionDescriptor*)$meth$$method;
 3966 
 3967     Register Rtoc = R12_scratch2;
 3968     // Calculate the method&#39;s TOC.
 3969     __ calculate_address_from_global_toc(Rtoc, __ method_toc());
 3970     // Put entry, env, toc into the constant pool, this needs up to 3 constant
 3971     // pool entries; call_c_using_toc will optimize the call.
 3972     bool success = __ call_c_using_toc(fd, relocInfo::runtime_call_type, Rtoc);
 3973     if (!success) {
 3974       ciEnv::current()-&gt;record_out_of_memory_failure();
 3975       return;
 3976     }
 3977 #endif
 3978 
 3979     // Check the ret_addr_offset.
 3980     assert(((MachCallRuntimeNode*)this)-&gt;ret_addr_offset() ==  __ last_calls_return_pc() - start_pc,
 3981            &quot;Fix constant in ret_addr_offset()&quot;);
 3982   %}
 3983 
 3984   // Move to ctr for leaf call.
 3985   // This enc_class is needed so that scheduler gets proper
 3986   // input mapping for latency computation.
 3987   enc_class enc_leaf_call_mtctr(iRegLsrc src) %{
 3988     // TODO: PPC port $archOpcode(ppc64Opcode_mtctr);
<a name="67" id="anc67"></a><span class="line-modified"> 3989     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3990     __ mtctr($src$$Register);
 3991   %}
 3992 
 3993   // Postalloc expand emitter for runtime leaf calls.
 3994   enc_class postalloc_expand_java_to_runtime_call(method meth, iRegLdst toc) %{
 3995     loadConLNodesTuple loadConLNodes_Entry;
 3996 #if defined(ABI_ELFv2)
 3997     jlong entry_address = (jlong) this-&gt;entry_point();
 3998     assert(entry_address, &quot;need address here&quot;);
 3999     loadConLNodes_Entry = loadConLNodesTuple_create(ra_, n_toc, new immLOper(entry_address),
 4000                                                     OptoReg::Name(R12_H_num), OptoReg::Name(R12_num));
 4001 #else
 4002     // Get the struct that describes the function we are about to call.
 4003     FunctionDescriptor* fd = (FunctionDescriptor*) this-&gt;entry_point();
 4004     assert(fd, &quot;need fd here&quot;);
 4005     jlong entry_address = (jlong) fd-&gt;entry();
 4006     // new nodes
 4007     loadConLNodesTuple loadConLNodes_Env;
 4008     loadConLNodesTuple loadConLNodes_Toc;
 4009 
 4010     // Create nodes and operands for loading the entry point.
 4011     loadConLNodes_Entry = loadConLNodesTuple_create(ra_, n_toc, new immLOper(entry_address),
 4012                                                     OptoReg::Name(R12_H_num), OptoReg::Name(R12_num));
 4013 
 4014 
 4015     // Create nodes and operands for loading the env pointer.
 4016     if (fd-&gt;env() != NULL) {
 4017       loadConLNodes_Env = loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong) fd-&gt;env()),
 4018                                                     OptoReg::Name(R11_H_num), OptoReg::Name(R11_num));
 4019     } else {
 4020       loadConLNodes_Env._large_hi = NULL;
 4021       loadConLNodes_Env._large_lo = NULL;
 4022       loadConLNodes_Env._small    = NULL;
 4023       loadConLNodes_Env._last = new loadConL16Node();
 4024       loadConLNodes_Env._last-&gt;_opnds[0] = new iRegLdstOper();
 4025       loadConLNodes_Env._last-&gt;_opnds[1] = new immL16Oper(0);
 4026       ra_-&gt;set_pair(loadConLNodes_Env._last-&gt;_idx, OptoReg::Name(R11_H_num), OptoReg::Name(R11_num));
 4027     }
 4028 
 4029     // Create nodes and operands for loading the Toc point.
 4030     loadConLNodes_Toc = loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong) fd-&gt;toc()),
 4031                                                   OptoReg::Name(R2_H_num), OptoReg::Name(R2_num));
 4032 #endif // ABI_ELFv2
 4033     // mtctr node
 4034     MachNode *mtctr = new CallLeafDirect_mtctrNode();
 4035 
 4036     assert(loadConLNodes_Entry._last != NULL, &quot;entry must exist&quot;);
 4037     mtctr-&gt;add_req(0, loadConLNodes_Entry._last);
 4038 
 4039     mtctr-&gt;_opnds[0] = new iRegLdstOper();
 4040     mtctr-&gt;_opnds[1] = new iRegLdstOper();
 4041 
 4042     // call node
 4043     MachCallLeafNode *call = new CallLeafDirectNode();
 4044 
 4045     call-&gt;_opnds[0] = _opnds[0];
 4046     call-&gt;_opnds[1] = new methodOper((intptr_t) entry_address); // May get set later.
 4047 
 4048     // Make the new call node look like the old one.
 4049     call-&gt;_name        = _name;
 4050     call-&gt;_tf          = _tf;
 4051     call-&gt;_entry_point = _entry_point;
 4052     call-&gt;_cnt         = _cnt;
 4053     call-&gt;_argsize     = _argsize;
 4054     call-&gt;_oop_map     = _oop_map;
 4055     guarantee(!_jvms, &quot;You must clone the jvms and adapt the offsets by fix_jvms().&quot;);
 4056     call-&gt;_jvms        = NULL;
 4057     call-&gt;_jvmadj      = _jvmadj;
 4058     call-&gt;_in_rms      = _in_rms;
 4059     call-&gt;_nesting     = _nesting;
 4060 
 4061 
 4062     // New call needs all inputs of old call.
 4063     // Req...
 4064     for (uint i = 0; i &lt; req(); ++i) {
 4065       if (i != mach_constant_base_node_input()) {
 4066         call-&gt;add_req(in(i));
 4067       }
 4068     }
 4069 
 4070     // These must be reqired edges, as the registers are live up to
 4071     // the call. Else the constants are handled as kills.
 4072     call-&gt;add_req(mtctr);
 4073 #if !defined(ABI_ELFv2)
 4074     call-&gt;add_req(loadConLNodes_Env._last);
 4075     call-&gt;add_req(loadConLNodes_Toc._last);
 4076 #endif
 4077 
 4078     // ...as well as prec
 4079     for (uint i = req(); i &lt; len(); ++i) {
 4080       call-&gt;add_prec(in(i));
 4081     }
 4082 
 4083     // registers
 4084     ra_-&gt;set1(mtctr-&gt;_idx, OptoReg::Name(SR_CTR_num));
 4085 
 4086     // Insert the new nodes.
 4087     if (loadConLNodes_Entry._large_hi) nodes-&gt;push(loadConLNodes_Entry._large_hi);
 4088     if (loadConLNodes_Entry._last)     nodes-&gt;push(loadConLNodes_Entry._last);
 4089 #if !defined(ABI_ELFv2)
 4090     if (loadConLNodes_Env._large_hi)   nodes-&gt;push(loadConLNodes_Env._large_hi);
 4091     if (loadConLNodes_Env._last)       nodes-&gt;push(loadConLNodes_Env._last);
 4092     if (loadConLNodes_Toc._large_hi)   nodes-&gt;push(loadConLNodes_Toc._large_hi);
 4093     if (loadConLNodes_Toc._last)       nodes-&gt;push(loadConLNodes_Toc._last);
 4094 #endif
 4095     nodes-&gt;push(mtctr);
 4096     nodes-&gt;push(call);
 4097   %}
 4098 %}
 4099 
 4100 //----------FRAME--------------------------------------------------------------
 4101 // Definition of frame structure and management information.
 4102 
 4103 frame %{
 4104   // What direction does stack grow in (assumed to be same for native &amp; Java).
 4105   stack_direction(TOWARDS_LOW);
 4106 
 4107   // These two registers define part of the calling convention between
 4108   // compiled code and the interpreter.
 4109 
 4110   // Inline Cache Register or method for I2C.
 4111   inline_cache_reg(R19); // R19_method
 4112 
 4113   // Method Oop Register when calling interpreter.
 4114   interpreter_method_oop_reg(R19); // R19_method
 4115 
 4116   // Optional: name the operand used by cisc-spilling to access
 4117   // [stack_pointer + offset].
 4118   cisc_spilling_operand_name(indOffset);
 4119 
 4120   // Number of stack slots consumed by a Monitor enter.
 4121   sync_stack_slots((frame::jit_monitor_size / VMRegImpl::stack_slot_size));
 4122 
 4123   // Compiled code&#39;s Frame Pointer.
 4124   frame_pointer(R1); // R1_SP
 4125 
 4126   // Interpreter stores its frame pointer in a register which is
 4127   // stored to the stack by I2CAdaptors. I2CAdaptors convert from
 4128   // interpreted java to compiled java.
 4129   //
 4130   // R14_state holds pointer to caller&#39;s cInterpreter.
 4131   interpreter_frame_pointer(R14); // R14_state
 4132 
 4133   stack_alignment(frame::alignment_in_bytes);
 4134 
 4135   in_preserve_stack_slots((frame::jit_in_preserve_size / VMRegImpl::stack_slot_size));
 4136 
 4137   // Number of outgoing stack slots killed above the
 4138   // out_preserve_stack_slots for calls to C. Supports the var-args
 4139   // backing area for register parms.
 4140   //
 4141   varargs_C_out_slots_killed(((frame::abi_reg_args_size - frame::jit_out_preserve_size) / VMRegImpl::stack_slot_size));
 4142 
 4143   // The after-PROLOG location of the return address. Location of
 4144   // return address specifies a type (REG or STACK) and a number
 4145   // representing the register number (i.e. - use a register name) or
 4146   // stack slot.
 4147   //
 4148   // A: Link register is stored in stack slot ...
 4149   // M:  ... but it&#39;s in the caller&#39;s frame according to PPC-64 ABI.
 4150   // J: Therefore, we make sure that the link register is also in R11_scratch1
 4151   //    at the end of the prolog.
 4152   // B: We use R20, now.
 4153   //return_addr(REG R20);
 4154 
 4155   // G: After reading the comments made by all the luminaries on their
 4156   //    failure to tell the compiler where the return address really is,
 4157   //    I hardly dare to try myself.  However, I&#39;m convinced it&#39;s in slot
 4158   //    4 what apparently works and saves us some spills.
 4159   return_addr(STACK 4);
 4160 
 4161   // This is the body of the function
 4162   //
 4163   // void Matcher::calling_convention(OptoRegPair* sig, // array of ideal regs
 4164   //                                  uint length,      // length of array
 4165   //                                  bool is_outgoing)
 4166   //
 4167   // The `sig&#39; array is to be updated. sig[j] represents the location
 4168   // of the j-th argument, either a register or a stack slot.
 4169 
 4170   // Comment taken from i486.ad:
 4171   // Body of function which returns an integer array locating
 4172   // arguments either in registers or in stack slots. Passed an array
 4173   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 4174   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 4175   // arguments for a CALLEE. Incoming stack arguments are
 4176   // automatically biased by the preserve_stack_slots field above.
 4177   calling_convention %{
 4178     // No difference between ingoing/outgoing. Just pass false.
 4179     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 4180   %}
 4181 
 4182   // Comment taken from i486.ad:
 4183   // Body of function which returns an integer array locating
 4184   // arguments either in registers or in stack slots. Passed an array
 4185   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 4186   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 4187   // arguments for a CALLEE. Incoming stack arguments are
 4188   // automatically biased by the preserve_stack_slots field above.
 4189   c_calling_convention %{
 4190     // This is obviously always outgoing.
 4191     // C argument in register AND stack slot.
 4192     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 4193   %}
 4194 
 4195   // Location of native (C/C++) and interpreter return values. This
 4196   // is specified to be the same as Java. In the 32-bit VM, long
 4197   // values are actually returned from native calls in O0:O1 and
 4198   // returned to the interpreter in I0:I1. The copying to and from
 4199   // the register pairs is done by the appropriate call and epilog
 4200   // opcodes. This simplifies the register allocator.
 4201   c_return_value %{
 4202     assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
 4203             (ideal_reg == Op_RegN &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0),
 4204             &quot;only return normal values&quot;);
 4205     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
 4206     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
 4207     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
 4208     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 4209   %}
 4210 
 4211   // Location of compiled Java return values.  Same as C
 4212   return_value %{
 4213     assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
 4214             (ideal_reg == Op_RegN &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0),
 4215             &quot;only return normal values&quot;);
 4216     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
 4217     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
 4218     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
 4219     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 4220   %}
 4221 %}
 4222 
 4223 
 4224 //----------ATTRIBUTES---------------------------------------------------------
 4225 
 4226 //----------Operand Attributes-------------------------------------------------
 4227 op_attrib op_cost(1);          // Required cost attribute.
 4228 
 4229 //----------Instruction Attributes---------------------------------------------
 4230 
 4231 // Cost attribute. required.
 4232 ins_attrib ins_cost(DEFAULT_COST);
 4233 
 4234 // Is this instruction a non-matching short branch variant of some
 4235 // long branch? Not required.
 4236 ins_attrib ins_short_branch(0);
 4237 
 4238 ins_attrib ins_is_TrapBasedCheckNode(true);
 4239 
 4240 // Number of constants.
 4241 // This instruction uses the given number of constants
 4242 // (optional attribute).
 4243 // This is needed to determine in time whether the constant pool will
 4244 // exceed 4000 entries. Before postalloc_expand the overall number of constants
 4245 // is determined. It&#39;s also used to compute the constant pool size
 4246 // in Output().
 4247 ins_attrib ins_num_consts(0);
 4248 
 4249 // Required alignment attribute (must be a power of 2) specifies the
 4250 // alignment that some part of the instruction (not necessarily the
 4251 // start) requires. If &gt; 1, a compute_padding() function must be
 4252 // provided for the instruction.
 4253 ins_attrib ins_alignment(1);
 4254 
 4255 // Enforce/prohibit rematerializations.
 4256 // - If an instruction is attributed with &#39;ins_cannot_rematerialize(true)&#39;
 4257 //   then rematerialization of that instruction is prohibited and the
 4258 //   instruction&#39;s value will be spilled if necessary.
 4259 //   Causes that MachNode::rematerialize() returns false.
 4260 // - If an instruction is attributed with &#39;ins_should_rematerialize(true)&#39;
 4261 //   then rematerialization should be enforced and a copy of the instruction
 4262 //   should be inserted if possible; rematerialization is not guaranteed.
 4263 //   Note: this may result in rematerializations in front of every use.
 4264 //   Causes that MachNode::rematerialize() can return true.
 4265 // (optional attribute)
 4266 ins_attrib ins_cannot_rematerialize(false);
 4267 ins_attrib ins_should_rematerialize(false);
 4268 
 4269 // Instruction has variable size depending on alignment.
 4270 ins_attrib ins_variable_size_depending_on_alignment(false);
 4271 
 4272 // Instruction is a nop.
 4273 ins_attrib ins_is_nop(false);
 4274 
 4275 // Instruction is mapped to a MachIfFastLock node (instead of MachFastLock).
 4276 ins_attrib ins_use_mach_if_fast_lock_node(false);
 4277 
 4278 // Field for the toc offset of a constant.
 4279 //
 4280 // This is needed if the toc offset is not encodable as an immediate in
 4281 // the PPC load instruction. If so, the upper (hi) bits of the offset are
 4282 // added to the toc, and from this a load with immediate is performed.
 4283 // With postalloc expand, we get two nodes that require the same offset
 4284 // but which don&#39;t know about each other. The offset is only known
 4285 // when the constant is added to the constant pool during emitting.
 4286 // It is generated in the &#39;hi&#39;-node adding the upper bits, and saved
 4287 // in this node.  The &#39;lo&#39;-node has a link to the &#39;hi&#39;-node and reads
 4288 // the offset from there when it gets encoded.
 4289 ins_attrib ins_field_const_toc_offset(0);
 4290 ins_attrib ins_field_const_toc_offset_hi_node(0);
 4291 
 4292 // A field that can hold the instructions offset in the code buffer.
 4293 // Set in the nodes emitter.
 4294 ins_attrib ins_field_cbuf_insts_offset(-1);
 4295 
 4296 // Fields for referencing a call&#39;s load-IC-node.
 4297 // If the toc offset can not be encoded as an immediate in a load, we
 4298 // use two nodes.
 4299 ins_attrib ins_field_load_ic_hi_node(0);
 4300 ins_attrib ins_field_load_ic_node(0);
 4301 
 4302 //----------OPERANDS-----------------------------------------------------------
 4303 // Operand definitions must precede instruction definitions for correct
 4304 // parsing in the ADLC because operands constitute user defined types
 4305 // which are used in instruction definitions.
 4306 //
 4307 // Formats are generated automatically for constants and base registers.
 4308 
 4309 operand vecX() %{
 4310   constraint(ALLOC_IN_RC(vs_reg));
 4311   match(VecX);
 4312 
 4313   format %{ %}
 4314   interface(REG_INTER);
 4315 %}
 4316 
 4317 //----------Simple Operands----------------------------------------------------
 4318 // Immediate Operands
 4319 
 4320 // Integer Immediate: 32-bit
 4321 operand immI() %{
 4322   match(ConI);
 4323   op_cost(40);
 4324   format %{ %}
 4325   interface(CONST_INTER);
 4326 %}
 4327 
 4328 operand immI8() %{
 4329   predicate(Assembler::is_simm(n-&gt;get_int(), 8));
 4330   op_cost(0);
 4331   match(ConI);
 4332   format %{ %}
 4333   interface(CONST_INTER);
 4334 %}
 4335 
 4336 // Integer Immediate: 16-bit
 4337 operand immI16() %{
 4338   predicate(Assembler::is_simm(n-&gt;get_int(), 16));
 4339   op_cost(0);
 4340   match(ConI);
 4341   format %{ %}
 4342   interface(CONST_INTER);
 4343 %}
 4344 
 4345 // Integer Immediate: 32-bit, where lowest 16 bits are 0x0000.
 4346 operand immIhi16() %{
 4347   predicate(((n-&gt;get_int() &amp; 0xffff0000) != 0) &amp;&amp; ((n-&gt;get_int() &amp; 0xffff) == 0));
 4348   match(ConI);
 4349   op_cost(0);
 4350   format %{ %}
 4351   interface(CONST_INTER);
 4352 %}
 4353 
 4354 operand immInegpow2() %{
 4355   predicate(is_power_of_2((jlong) (julong) (juint) (-(n-&gt;get_int()))));
 4356   match(ConI);
 4357   op_cost(0);
 4358   format %{ %}
 4359   interface(CONST_INTER);
 4360 %}
 4361 
 4362 operand immIpow2minus1() %{
 4363   predicate(is_power_of_2((((jlong) (n-&gt;get_int()))+1)));
 4364   match(ConI);
 4365   op_cost(0);
 4366   format %{ %}
 4367   interface(CONST_INTER);
 4368 %}
 4369 
 4370 operand immIpowerOf2() %{
 4371   predicate(is_power_of_2((((jlong) (julong) (juint) (n-&gt;get_int())))));
 4372   match(ConI);
 4373   op_cost(0);
 4374   format %{ %}
 4375   interface(CONST_INTER);
 4376 %}
 4377 
 4378 // Unsigned Integer Immediate: the values 0-31
 4379 operand uimmI5() %{
 4380   predicate(Assembler::is_uimm(n-&gt;get_int(), 5));
 4381   match(ConI);
 4382   op_cost(0);
 4383   format %{ %}
 4384   interface(CONST_INTER);
 4385 %}
 4386 
 4387 // Unsigned Integer Immediate: 6-bit
 4388 operand uimmI6() %{
 4389   predicate(Assembler::is_uimm(n-&gt;get_int(), 6));
 4390   match(ConI);
 4391   op_cost(0);
 4392   format %{ %}
 4393   interface(CONST_INTER);
 4394 %}
 4395 
 4396 // Unsigned Integer Immediate:  6-bit int, greater than 32
 4397 operand uimmI6_ge32() %{
 4398   predicate(Assembler::is_uimm(n-&gt;get_int(), 6) &amp;&amp; n-&gt;get_int() &gt;= 32);
 4399   match(ConI);
 4400   op_cost(0);
 4401   format %{ %}
 4402   interface(CONST_INTER);
 4403 %}
 4404 
 4405 // Unsigned Integer Immediate: 15-bit
 4406 operand uimmI15() %{
 4407   predicate(Assembler::is_uimm(n-&gt;get_int(), 15));
 4408   match(ConI);
 4409   op_cost(0);
 4410   format %{ %}
 4411   interface(CONST_INTER);
 4412 %}
 4413 
 4414 // Unsigned Integer Immediate: 16-bit
 4415 operand uimmI16() %{
 4416   predicate(Assembler::is_uimm(n-&gt;get_int(), 16));
 4417   match(ConI);
 4418   op_cost(0);
 4419   format %{ %}
 4420   interface(CONST_INTER);
 4421 %}
 4422 
 4423 // constant &#39;int 0&#39;.
 4424 operand immI_0() %{
 4425   predicate(n-&gt;get_int() == 0);
 4426   match(ConI);
 4427   op_cost(0);
 4428   format %{ %}
 4429   interface(CONST_INTER);
 4430 %}
 4431 
 4432 // constant &#39;int 1&#39;.
 4433 operand immI_1() %{
 4434   predicate(n-&gt;get_int() == 1);
 4435   match(ConI);
 4436   op_cost(0);
 4437   format %{ %}
 4438   interface(CONST_INTER);
 4439 %}
 4440 
 4441 // constant &#39;int -1&#39;.
 4442 operand immI_minus1() %{
 4443   predicate(n-&gt;get_int() == -1);
 4444   match(ConI);
 4445   op_cost(0);
 4446   format %{ %}
 4447   interface(CONST_INTER);
 4448 %}
 4449 
 4450 // int value 16.
 4451 operand immI_16() %{
 4452   predicate(n-&gt;get_int() == 16);
 4453   match(ConI);
 4454   op_cost(0);
 4455   format %{ %}
 4456   interface(CONST_INTER);
 4457 %}
 4458 
 4459 // int value 24.
 4460 operand immI_24() %{
 4461   predicate(n-&gt;get_int() == 24);
 4462   match(ConI);
 4463   op_cost(0);
 4464   format %{ %}
 4465   interface(CONST_INTER);
 4466 %}
 4467 
 4468 // Compressed oops constants
 4469 // Pointer Immediate
 4470 operand immN() %{
 4471   match(ConN);
 4472 
 4473   op_cost(10);
 4474   format %{ %}
 4475   interface(CONST_INTER);
 4476 %}
 4477 
 4478 // NULL Pointer Immediate
 4479 operand immN_0() %{
 4480   predicate(n-&gt;get_narrowcon() == 0);
 4481   match(ConN);
 4482 
 4483   op_cost(0);
 4484   format %{ %}
 4485   interface(CONST_INTER);
 4486 %}
 4487 
 4488 // Compressed klass constants
 4489 operand immNKlass() %{
 4490   match(ConNKlass);
 4491 
 4492   op_cost(0);
 4493   format %{ %}
 4494   interface(CONST_INTER);
 4495 %}
 4496 
 4497 // This operand can be used to avoid matching of an instruct
 4498 // with chain rule.
 4499 operand immNKlass_NM() %{
 4500   match(ConNKlass);
 4501   predicate(false);
 4502   op_cost(0);
 4503   format %{ %}
 4504   interface(CONST_INTER);
 4505 %}
 4506 
 4507 // Pointer Immediate: 64-bit
 4508 operand immP() %{
 4509   match(ConP);
 4510   op_cost(0);
 4511   format %{ %}
 4512   interface(CONST_INTER);
 4513 %}
 4514 
 4515 // Operand to avoid match of loadConP.
 4516 // This operand can be used to avoid matching of an instruct
 4517 // with chain rule.
 4518 operand immP_NM() %{
 4519   match(ConP);
 4520   predicate(false);
 4521   op_cost(0);
 4522   format %{ %}
 4523   interface(CONST_INTER);
 4524 %}
 4525 
 4526 // costant &#39;pointer 0&#39;.
 4527 operand immP_0() %{
 4528   predicate(n-&gt;get_ptr() == 0);
 4529   match(ConP);
 4530   op_cost(0);
 4531   format %{ %}
 4532   interface(CONST_INTER);
 4533 %}
 4534 
 4535 // pointer 0x0 or 0x1
 4536 operand immP_0or1() %{
 4537   predicate((n-&gt;get_ptr() == 0) || (n-&gt;get_ptr() == 1));
 4538   match(ConP);
 4539   op_cost(0);
 4540   format %{ %}
 4541   interface(CONST_INTER);
 4542 %}
 4543 
 4544 operand immL() %{
 4545   match(ConL);
 4546   op_cost(40);
 4547   format %{ %}
 4548   interface(CONST_INTER);
 4549 %}
 4550 
 4551 operand immLmax30() %{
 4552   predicate((n-&gt;get_long() &lt;= 30));
 4553   match(ConL);
 4554   op_cost(0);
 4555   format %{ %}
 4556   interface(CONST_INTER);
 4557 %}
 4558 
 4559 // Long Immediate: 16-bit
 4560 operand immL16() %{
 4561   predicate(Assembler::is_simm(n-&gt;get_long(), 16));
 4562   match(ConL);
 4563   op_cost(0);
 4564   format %{ %}
 4565   interface(CONST_INTER);
 4566 %}
 4567 
 4568 // Long Immediate: 16-bit, 4-aligned
 4569 operand immL16Alg4() %{
 4570   predicate(Assembler::is_simm(n-&gt;get_long(), 16) &amp;&amp; ((n-&gt;get_long() &amp; 0x3) == 0));
 4571   match(ConL);
 4572   op_cost(0);
 4573   format %{ %}
 4574   interface(CONST_INTER);
 4575 %}
 4576 
 4577 // Long Immediate: 32-bit, where lowest 16 bits are 0x0000.
 4578 operand immL32hi16() %{
 4579   predicate(Assembler::is_simm(n-&gt;get_long(), 32) &amp;&amp; ((n-&gt;get_long() &amp; 0xffffL) == 0L));
 4580   match(ConL);
 4581   op_cost(0);
 4582   format %{ %}
 4583   interface(CONST_INTER);
 4584 %}
 4585 
 4586 // Long Immediate: 32-bit
 4587 operand immL32() %{
 4588   predicate(Assembler::is_simm(n-&gt;get_long(), 32));
 4589   match(ConL);
 4590   op_cost(0);
 4591   format %{ %}
 4592   interface(CONST_INTER);
 4593 %}
 4594 
 4595 // Long Immediate: 64-bit, where highest 16 bits are not 0x0000.
 4596 operand immLhighest16() %{
 4597   predicate((n-&gt;get_long() &amp; 0xffff000000000000L) != 0L &amp;&amp; (n-&gt;get_long() &amp; 0x0000ffffffffffffL) == 0L);
 4598   match(ConL);
 4599   op_cost(0);
 4600   format %{ %}
 4601   interface(CONST_INTER);
 4602 %}
 4603 
 4604 operand immLnegpow2() %{
 4605   predicate(is_power_of_2((jlong)-(n-&gt;get_long())));
 4606   match(ConL);
 4607   op_cost(0);
 4608   format %{ %}
 4609   interface(CONST_INTER);
 4610 %}
 4611 
 4612 operand immLpow2minus1() %{
 4613   predicate(is_power_of_2((((jlong) (n-&gt;get_long()))+1)) &amp;&amp;
 4614             (n-&gt;get_long() != (jlong)0xffffffffffffffffL));
 4615   match(ConL);
 4616   op_cost(0);
 4617   format %{ %}
 4618   interface(CONST_INTER);
 4619 %}
 4620 
 4621 // constant &#39;long 0&#39;.
 4622 operand immL_0() %{
 4623   predicate(n-&gt;get_long() == 0L);
 4624   match(ConL);
 4625   op_cost(0);
 4626   format %{ %}
 4627   interface(CONST_INTER);
 4628 %}
 4629 
 4630 // constat &#39; long -1&#39;.
 4631 operand immL_minus1() %{
 4632   predicate(n-&gt;get_long() == -1L);
 4633   match(ConL);
 4634   op_cost(0);
 4635   format %{ %}
 4636   interface(CONST_INTER);
 4637 %}
 4638 
 4639 // Long Immediate: low 32-bit mask
 4640 operand immL_32bits() %{
 4641   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 4642   match(ConL);
 4643   op_cost(0);
 4644   format %{ %}
 4645   interface(CONST_INTER);
 4646 %}
 4647 
 4648 // Unsigned Long Immediate: 16-bit
 4649 operand uimmL16() %{
 4650   predicate(Assembler::is_uimm(n-&gt;get_long(), 16));
 4651   match(ConL);
 4652   op_cost(0);
 4653   format %{ %}
 4654   interface(CONST_INTER);
 4655 %}
 4656 
 4657 // Float Immediate
 4658 operand immF() %{
 4659   match(ConF);
 4660   op_cost(40);
 4661   format %{ %}
 4662   interface(CONST_INTER);
 4663 %}
 4664 
 4665 // Float Immediate: +0.0f.
 4666 operand immF_0() %{
 4667   predicate(jint_cast(n-&gt;getf()) == 0);
 4668   match(ConF);
 4669 
 4670   op_cost(0);
 4671   format %{ %}
 4672   interface(CONST_INTER);
 4673 %}
 4674 
 4675 // Double Immediate
 4676 operand immD() %{
 4677   match(ConD);
 4678   op_cost(40);
 4679   format %{ %}
 4680   interface(CONST_INTER);
 4681 %}
 4682 
 4683 // Double Immediate: +0.0d.
 4684 operand immD_0() %{
 4685   predicate(jlong_cast(n-&gt;getd()) == 0);
 4686   match(ConD);
 4687 
 4688   op_cost(0);
 4689   format %{ %}
 4690   interface(CONST_INTER);
 4691 %}
 4692 
 4693 // Integer Register Operands
 4694 // Integer Destination Register
 4695 // See definition of reg_class bits32_reg_rw.
 4696 operand iRegIdst() %{
 4697   constraint(ALLOC_IN_RC(bits32_reg_rw));
 4698   match(RegI);
 4699   match(rscratch1RegI);
 4700   match(rscratch2RegI);
 4701   match(rarg1RegI);
 4702   match(rarg2RegI);
 4703   match(rarg3RegI);
 4704   match(rarg4RegI);
 4705   format %{ %}
 4706   interface(REG_INTER);
 4707 %}
 4708 
 4709 // Integer Source Register
 4710 // See definition of reg_class bits32_reg_ro.
 4711 operand iRegIsrc() %{
 4712   constraint(ALLOC_IN_RC(bits32_reg_ro));
 4713   match(RegI);
 4714   match(rscratch1RegI);
 4715   match(rscratch2RegI);
 4716   match(rarg1RegI);
 4717   match(rarg2RegI);
 4718   match(rarg3RegI);
 4719   match(rarg4RegI);
 4720   format %{ %}
 4721   interface(REG_INTER);
 4722 %}
 4723 
 4724 operand rscratch1RegI() %{
 4725   constraint(ALLOC_IN_RC(rscratch1_bits32_reg));
 4726   match(iRegIdst);
 4727   format %{ %}
 4728   interface(REG_INTER);
 4729 %}
 4730 
 4731 operand rscratch2RegI() %{
 4732   constraint(ALLOC_IN_RC(rscratch2_bits32_reg));
 4733   match(iRegIdst);
 4734   format %{ %}
 4735   interface(REG_INTER);
 4736 %}
 4737 
 4738 operand rarg1RegI() %{
 4739   constraint(ALLOC_IN_RC(rarg1_bits32_reg));
 4740   match(iRegIdst);
 4741   format %{ %}
 4742   interface(REG_INTER);
 4743 %}
 4744 
 4745 operand rarg2RegI() %{
 4746   constraint(ALLOC_IN_RC(rarg2_bits32_reg));
 4747   match(iRegIdst);
 4748   format %{ %}
 4749   interface(REG_INTER);
 4750 %}
 4751 
 4752 operand rarg3RegI() %{
 4753   constraint(ALLOC_IN_RC(rarg3_bits32_reg));
 4754   match(iRegIdst);
 4755   format %{ %}
 4756   interface(REG_INTER);
 4757 %}
 4758 
 4759 operand rarg4RegI() %{
 4760   constraint(ALLOC_IN_RC(rarg4_bits32_reg));
 4761   match(iRegIdst);
 4762   format %{ %}
 4763   interface(REG_INTER);
 4764 %}
 4765 
 4766 operand rarg1RegL() %{
 4767   constraint(ALLOC_IN_RC(rarg1_bits64_reg));
 4768   match(iRegLdst);
 4769   format %{ %}
 4770   interface(REG_INTER);
 4771 %}
 4772 
 4773 operand rarg2RegL() %{
 4774   constraint(ALLOC_IN_RC(rarg2_bits64_reg));
 4775   match(iRegLdst);
 4776   format %{ %}
 4777   interface(REG_INTER);
 4778 %}
 4779 
 4780 operand rarg3RegL() %{
 4781   constraint(ALLOC_IN_RC(rarg3_bits64_reg));
 4782   match(iRegLdst);
 4783   format %{ %}
 4784   interface(REG_INTER);
 4785 %}
 4786 
 4787 operand rarg4RegL() %{
 4788   constraint(ALLOC_IN_RC(rarg4_bits64_reg));
 4789   match(iRegLdst);
 4790   format %{ %}
 4791   interface(REG_INTER);
 4792 %}
 4793 
 4794 // Pointer Destination Register
 4795 // See definition of reg_class bits64_reg_rw.
 4796 operand iRegPdst() %{
 4797   constraint(ALLOC_IN_RC(bits64_reg_rw));
 4798   match(RegP);
 4799   match(rscratch1RegP);
 4800   match(rscratch2RegP);
 4801   match(rarg1RegP);
 4802   match(rarg2RegP);
 4803   match(rarg3RegP);
 4804   match(rarg4RegP);
 4805   format %{ %}
 4806   interface(REG_INTER);
 4807 %}
 4808 
 4809 // Pointer Destination Register
 4810 // Operand not using r11 and r12 (killed in epilog).
 4811 operand iRegPdstNoScratch() %{
 4812   constraint(ALLOC_IN_RC(bits64_reg_leaf_call));
 4813   match(RegP);
 4814   match(rarg1RegP);
 4815   match(rarg2RegP);
 4816   match(rarg3RegP);
 4817   match(rarg4RegP);
 4818   format %{ %}
 4819   interface(REG_INTER);
 4820 %}
 4821 
 4822 // Pointer Source Register
 4823 // See definition of reg_class bits64_reg_ro.
 4824 operand iRegPsrc() %{
 4825   constraint(ALLOC_IN_RC(bits64_reg_ro));
 4826   match(RegP);
 4827   match(iRegPdst);
 4828   match(rscratch1RegP);
 4829   match(rscratch2RegP);
 4830   match(rarg1RegP);
 4831   match(rarg2RegP);
 4832   match(rarg3RegP);
 4833   match(rarg4RegP);
 4834   match(threadRegP);
 4835   format %{ %}
 4836   interface(REG_INTER);
 4837 %}
 4838 
 4839 // Thread operand.
 4840 operand threadRegP() %{
 4841   constraint(ALLOC_IN_RC(thread_bits64_reg));
 4842   match(iRegPdst);
 4843   format %{ &quot;R16&quot; %}
 4844   interface(REG_INTER);
 4845 %}
 4846 
 4847 operand rscratch1RegP() %{
 4848   constraint(ALLOC_IN_RC(rscratch1_bits64_reg));
 4849   match(iRegPdst);
 4850   format %{ &quot;R11&quot; %}
 4851   interface(REG_INTER);
 4852 %}
 4853 
 4854 operand rscratch2RegP() %{
 4855   constraint(ALLOC_IN_RC(rscratch2_bits64_reg));
 4856   match(iRegPdst);
 4857   format %{ %}
 4858   interface(REG_INTER);
 4859 %}
 4860 
 4861 operand rarg1RegP() %{
 4862   constraint(ALLOC_IN_RC(rarg1_bits64_reg));
 4863   match(iRegPdst);
 4864   format %{ %}
 4865   interface(REG_INTER);
 4866 %}
 4867 
 4868 operand rarg2RegP() %{
 4869   constraint(ALLOC_IN_RC(rarg2_bits64_reg));
 4870   match(iRegPdst);
 4871   format %{ %}
 4872   interface(REG_INTER);
 4873 %}
 4874 
 4875 operand rarg3RegP() %{
 4876   constraint(ALLOC_IN_RC(rarg3_bits64_reg));
 4877   match(iRegPdst);
 4878   format %{ %}
 4879   interface(REG_INTER);
 4880 %}
 4881 
 4882 operand rarg4RegP() %{
 4883   constraint(ALLOC_IN_RC(rarg4_bits64_reg));
 4884   match(iRegPdst);
 4885   format %{ %}
 4886   interface(REG_INTER);
 4887 %}
 4888 
 4889 operand iRegNsrc() %{
 4890   constraint(ALLOC_IN_RC(bits32_reg_ro));
 4891   match(RegN);
 4892   match(iRegNdst);
 4893 
 4894   format %{ %}
 4895   interface(REG_INTER);
 4896 %}
 4897 
 4898 operand iRegNdst() %{
 4899   constraint(ALLOC_IN_RC(bits32_reg_rw));
 4900   match(RegN);
 4901 
 4902   format %{ %}
 4903   interface(REG_INTER);
 4904 %}
 4905 
 4906 // Long Destination Register
 4907 // See definition of reg_class bits64_reg_rw.
 4908 operand iRegLdst() %{
 4909   constraint(ALLOC_IN_RC(bits64_reg_rw));
 4910   match(RegL);
 4911   match(rscratch1RegL);
 4912   match(rscratch2RegL);
 4913   format %{ %}
 4914   interface(REG_INTER);
 4915 %}
 4916 
 4917 // Long Source Register
 4918 // See definition of reg_class bits64_reg_ro.
 4919 operand iRegLsrc() %{
 4920   constraint(ALLOC_IN_RC(bits64_reg_ro));
 4921   match(RegL);
 4922   match(iRegLdst);
 4923   match(rscratch1RegL);
 4924   match(rscratch2RegL);
 4925   format %{ %}
 4926   interface(REG_INTER);
 4927 %}
 4928 
 4929 // Special operand for ConvL2I.
 4930 operand iRegL2Isrc(iRegLsrc reg) %{
 4931   constraint(ALLOC_IN_RC(bits64_reg_ro));
 4932   match(ConvL2I reg);
 4933   format %{ &quot;ConvL2I($reg)&quot; %}
 4934   interface(REG_INTER)
 4935 %}
 4936 
 4937 operand rscratch1RegL() %{
 4938   constraint(ALLOC_IN_RC(rscratch1_bits64_reg));
 4939   match(RegL);
 4940   format %{ %}
 4941   interface(REG_INTER);
 4942 %}
 4943 
 4944 operand rscratch2RegL() %{
 4945   constraint(ALLOC_IN_RC(rscratch2_bits64_reg));
 4946   match(RegL);
 4947   format %{ %}
 4948   interface(REG_INTER);
 4949 %}
 4950 
 4951 // Condition Code Flag Registers
 4952 operand flagsReg() %{
 4953   constraint(ALLOC_IN_RC(int_flags));
 4954   match(RegFlags);
 4955   format %{ %}
 4956   interface(REG_INTER);
 4957 %}
 4958 
 4959 operand flagsRegSrc() %{
 4960   constraint(ALLOC_IN_RC(int_flags_ro));
 4961   match(RegFlags);
 4962   match(flagsReg);
 4963   match(flagsRegCR0);
 4964   format %{ %}
 4965   interface(REG_INTER);
 4966 %}
 4967 
 4968 // Condition Code Flag Register CR0
 4969 operand flagsRegCR0() %{
 4970   constraint(ALLOC_IN_RC(int_flags_CR0));
 4971   match(RegFlags);
 4972   format %{ &quot;CR0&quot; %}
 4973   interface(REG_INTER);
 4974 %}
 4975 
 4976 operand flagsRegCR1() %{
 4977   constraint(ALLOC_IN_RC(int_flags_CR1));
 4978   match(RegFlags);
 4979   format %{ &quot;CR1&quot; %}
 4980   interface(REG_INTER);
 4981 %}
 4982 
 4983 operand flagsRegCR6() %{
 4984   constraint(ALLOC_IN_RC(int_flags_CR6));
 4985   match(RegFlags);
 4986   format %{ &quot;CR6&quot; %}
 4987   interface(REG_INTER);
 4988 %}
 4989 
 4990 operand regCTR() %{
 4991   constraint(ALLOC_IN_RC(ctr_reg));
 4992   // RegFlags should work. Introducing a RegSpecial type would cause a
 4993   // lot of changes.
 4994   match(RegFlags);
 4995   format %{&quot;SR_CTR&quot; %}
 4996   interface(REG_INTER);
 4997 %}
 4998 
 4999 operand regD() %{
 5000   constraint(ALLOC_IN_RC(dbl_reg));
 5001   match(RegD);
 5002   format %{ %}
 5003   interface(REG_INTER);
 5004 %}
 5005 
 5006 operand regF() %{
 5007   constraint(ALLOC_IN_RC(flt_reg));
 5008   match(RegF);
 5009   format %{ %}
 5010   interface(REG_INTER);
 5011 %}
 5012 
 5013 // Special Registers
 5014 
 5015 // Method Register
 5016 operand inline_cache_regP(iRegPdst reg) %{
 5017   constraint(ALLOC_IN_RC(r19_bits64_reg)); // inline_cache_reg
 5018   match(reg);
 5019   format %{ %}
 5020   interface(REG_INTER);
 5021 %}
 5022 
 5023 operand compiler_method_oop_regP(iRegPdst reg) %{
 5024   constraint(ALLOC_IN_RC(rscratch1_bits64_reg)); // compiler_method_oop_reg
 5025   match(reg);
 5026   format %{ %}
 5027   interface(REG_INTER);
 5028 %}
 5029 
 5030 operand interpreter_method_oop_regP(iRegPdst reg) %{
 5031   constraint(ALLOC_IN_RC(r19_bits64_reg)); // interpreter_method_oop_reg
 5032   match(reg);
 5033   format %{ %}
 5034   interface(REG_INTER);
 5035 %}
 5036 
 5037 // Operands to remove register moves in unscaled mode.
 5038 // Match read/write registers with an EncodeP node if neither shift nor add are required.
 5039 operand iRegP2N(iRegPsrc reg) %{
 5040   predicate(false /* TODO: PPC port MatchDecodeNodes*/&amp;&amp; CompressedOops::shift() == 0);
 5041   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5042   match(EncodeP reg);
 5043   format %{ &quot;$reg&quot; %}
 5044   interface(REG_INTER)
 5045 %}
 5046 
 5047 operand iRegN2P(iRegNsrc reg) %{
 5048   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5049   constraint(ALLOC_IN_RC(bits32_reg_ro));
 5050   match(DecodeN reg);
 5051   format %{ &quot;$reg&quot; %}
 5052   interface(REG_INTER)
 5053 %}
 5054 
 5055 operand iRegN2P_klass(iRegNsrc reg) %{
 5056   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5057   constraint(ALLOC_IN_RC(bits32_reg_ro));
 5058   match(DecodeNKlass reg);
 5059   format %{ &quot;$reg&quot; %}
 5060   interface(REG_INTER)
 5061 %}
 5062 
 5063 //----------Complex Operands---------------------------------------------------
 5064 // Indirect Memory Reference
 5065 operand indirect(iRegPsrc reg) %{
 5066   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5067   match(reg);
 5068   op_cost(100);
 5069   format %{ &quot;[$reg]&quot; %}
 5070   interface(MEMORY_INTER) %{
 5071     base($reg);
 5072     index(0x0);
 5073     scale(0x0);
 5074     disp(0x0);
 5075   %}
 5076 %}
 5077 
 5078 // Indirect with Offset
 5079 operand indOffset16(iRegPsrc reg, immL16 offset) %{
 5080   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5081   match(AddP reg offset);
 5082   op_cost(100);
 5083   format %{ &quot;[$reg + $offset]&quot; %}
 5084   interface(MEMORY_INTER) %{
 5085     base($reg);
 5086     index(0x0);
 5087     scale(0x0);
 5088     disp($offset);
 5089   %}
 5090 %}
 5091 
 5092 // Indirect with 4-aligned Offset
 5093 operand indOffset16Alg4(iRegPsrc reg, immL16Alg4 offset) %{
 5094   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5095   match(AddP reg offset);
 5096   op_cost(100);
 5097   format %{ &quot;[$reg + $offset]&quot; %}
 5098   interface(MEMORY_INTER) %{
 5099     base($reg);
 5100     index(0x0);
 5101     scale(0x0);
 5102     disp($offset);
 5103   %}
 5104 %}
 5105 
 5106 //----------Complex Operands for Compressed OOPs-------------------------------
 5107 // Compressed OOPs with narrow_oop_shift == 0.
 5108 
 5109 // Indirect Memory Reference, compressed OOP
 5110 operand indirectNarrow(iRegNsrc reg) %{
 5111   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5112   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5113   match(DecodeN reg);
 5114   op_cost(100);
 5115   format %{ &quot;[$reg]&quot; %}
 5116   interface(MEMORY_INTER) %{
 5117     base($reg);
 5118     index(0x0);
 5119     scale(0x0);
 5120     disp(0x0);
 5121   %}
 5122 %}
 5123 
 5124 operand indirectNarrow_klass(iRegNsrc reg) %{
 5125   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5126   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5127   match(DecodeNKlass reg);
 5128   op_cost(100);
 5129   format %{ &quot;[$reg]&quot; %}
 5130   interface(MEMORY_INTER) %{
 5131     base($reg);
 5132     index(0x0);
 5133     scale(0x0);
 5134     disp(0x0);
 5135   %}
 5136 %}
 5137 
 5138 // Indirect with Offset, compressed OOP
 5139 operand indOffset16Narrow(iRegNsrc reg, immL16 offset) %{
 5140   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5141   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5142   match(AddP (DecodeN reg) offset);
 5143   op_cost(100);
 5144   format %{ &quot;[$reg + $offset]&quot; %}
 5145   interface(MEMORY_INTER) %{
 5146     base($reg);
 5147     index(0x0);
 5148     scale(0x0);
 5149     disp($offset);
 5150   %}
 5151 %}
 5152 
 5153 operand indOffset16Narrow_klass(iRegNsrc reg, immL16 offset) %{
 5154   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5155   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5156   match(AddP (DecodeNKlass reg) offset);
 5157   op_cost(100);
 5158   format %{ &quot;[$reg + $offset]&quot; %}
 5159   interface(MEMORY_INTER) %{
 5160     base($reg);
 5161     index(0x0);
 5162     scale(0x0);
 5163     disp($offset);
 5164   %}
 5165 %}
 5166 
 5167 // Indirect with 4-aligned Offset, compressed OOP
 5168 operand indOffset16NarrowAlg4(iRegNsrc reg, immL16Alg4 offset) %{
 5169   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5170   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5171   match(AddP (DecodeN reg) offset);
 5172   op_cost(100);
 5173   format %{ &quot;[$reg + $offset]&quot; %}
 5174   interface(MEMORY_INTER) %{
 5175     base($reg);
 5176     index(0x0);
 5177     scale(0x0);
 5178     disp($offset);
 5179   %}
 5180 %}
 5181 
 5182 operand indOffset16NarrowAlg4_klass(iRegNsrc reg, immL16Alg4 offset) %{
 5183   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5184   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5185   match(AddP (DecodeNKlass reg) offset);
 5186   op_cost(100);
 5187   format %{ &quot;[$reg + $offset]&quot; %}
 5188   interface(MEMORY_INTER) %{
 5189     base($reg);
 5190     index(0x0);
 5191     scale(0x0);
 5192     disp($offset);
 5193   %}
 5194 %}
 5195 
 5196 //----------Special Memory Operands--------------------------------------------
 5197 // Stack Slot Operand
 5198 //
 5199 // This operand is used for loading and storing temporary values on
 5200 // the stack where a match requires a value to flow through memory.
 5201 operand stackSlotI(sRegI reg) %{
 5202   constraint(ALLOC_IN_RC(stack_slots));
 5203   op_cost(100);
 5204   //match(RegI);
 5205   format %{ &quot;[sp+$reg]&quot; %}
 5206   interface(MEMORY_INTER) %{
 5207     base(0x1);   // R1_SP
 5208     index(0x0);
 5209     scale(0x0);
 5210     disp($reg);  // Stack Offset
 5211   %}
 5212 %}
 5213 
 5214 operand stackSlotL(sRegL reg) %{
 5215   constraint(ALLOC_IN_RC(stack_slots));
 5216   op_cost(100);
 5217   //match(RegL);
 5218   format %{ &quot;[sp+$reg]&quot; %}
 5219   interface(MEMORY_INTER) %{
 5220     base(0x1);   // R1_SP
 5221     index(0x0);
 5222     scale(0x0);
 5223     disp($reg);  // Stack Offset
 5224   %}
 5225 %}
 5226 
 5227 operand stackSlotP(sRegP reg) %{
 5228   constraint(ALLOC_IN_RC(stack_slots));
 5229   op_cost(100);
 5230   //match(RegP);
 5231   format %{ &quot;[sp+$reg]&quot; %}
 5232   interface(MEMORY_INTER) %{
 5233     base(0x1);   // R1_SP
 5234     index(0x0);
 5235     scale(0x0);
 5236     disp($reg);  // Stack Offset
 5237   %}
 5238 %}
 5239 
 5240 operand stackSlotF(sRegF reg) %{
 5241   constraint(ALLOC_IN_RC(stack_slots));
 5242   op_cost(100);
 5243   //match(RegF);
 5244   format %{ &quot;[sp+$reg]&quot; %}
 5245   interface(MEMORY_INTER) %{
 5246     base(0x1);   // R1_SP
 5247     index(0x0);
 5248     scale(0x0);
 5249     disp($reg);  // Stack Offset
 5250   %}
 5251 %}
 5252 
 5253 operand stackSlotD(sRegD reg) %{
 5254   constraint(ALLOC_IN_RC(stack_slots));
 5255   op_cost(100);
 5256   //match(RegD);
 5257   format %{ &quot;[sp+$reg]&quot; %}
 5258   interface(MEMORY_INTER) %{
 5259     base(0x1);   // R1_SP
 5260     index(0x0);
 5261     scale(0x0);
 5262     disp($reg);  // Stack Offset
 5263   %}
 5264 %}
 5265 
 5266 // Operands for expressing Control Flow
 5267 // NOTE: Label is a predefined operand which should not be redefined in
 5268 //       the AD file. It is generically handled within the ADLC.
 5269 
 5270 //----------Conditional Branch Operands----------------------------------------
 5271 // Comparison Op
 5272 //
 5273 // This is the operation of the comparison, and is limited to the
 5274 // following set of codes: L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE
 5275 // (!=).
 5276 //
 5277 // Other attributes of the comparison, such as unsignedness, are specified
 5278 // by the comparison instruction that sets a condition code flags register.
 5279 // That result is represented by a flags operand whose subtype is appropriate
 5280 // to the unsignedness (etc.) of the comparison.
 5281 //
 5282 // Later, the instruction which matches both the Comparison Op (a Bool) and
 5283 // the flags (produced by the Cmp) specifies the coding of the comparison op
 5284 // by matching a specific subtype of Bool operand below.
 5285 
 5286 // When used for floating point comparisons: unordered same as less.
 5287 operand cmpOp() %{
 5288   match(Bool);
 5289   format %{ &quot;&quot; %}
 5290   interface(COND_INTER) %{
 5291                            // BO only encodes bit 4 of bcondCRbiIsX, as bits 1-3 are always &#39;100&#39;.
 5292                            //           BO          &amp;  BI
 5293     equal(0xA);            // 10 10:   bcondCRbiIs1 &amp; Condition::equal
 5294     not_equal(0x2);        // 00 10:   bcondCRbiIs0 &amp; Condition::equal
 5295     less(0x8);             // 10 00:   bcondCRbiIs1 &amp; Condition::less
 5296     greater_equal(0x0);    // 00 00:   bcondCRbiIs0 &amp; Condition::less
 5297     less_equal(0x1);       // 00 01:   bcondCRbiIs0 &amp; Condition::greater
 5298     greater(0x9);          // 10 01:   bcondCRbiIs1 &amp; Condition::greater
 5299     overflow(0xB);         // 10 11:   bcondCRbiIs1 &amp; Condition::summary_overflow
 5300     no_overflow(0x3);      // 00 11:   bcondCRbiIs0 &amp; Condition::summary_overflow
 5301   %}
 5302 %}
 5303 
 5304 //----------OPERAND CLASSES----------------------------------------------------
 5305 // Operand Classes are groups of operands that are used to simplify
 5306 // instruction definitions by not requiring the AD writer to specify
 5307 // seperate instructions for every form of operand when the
 5308 // instruction accepts multiple operand types with the same basic
 5309 // encoding and format. The classic case of this is memory operands.
 5310 // Indirect is not included since its use is limited to Compare &amp; Swap.
 5311 
 5312 opclass memory(indirect, indOffset16 /*, indIndex, tlsReference*/, indirectNarrow, indirectNarrow_klass, indOffset16Narrow, indOffset16Narrow_klass);
 5313 // Memory operand where offsets are 4-aligned. Required for ld, std.
 5314 opclass memoryAlg4(indirect, indOffset16Alg4, indirectNarrow, indOffset16NarrowAlg4, indOffset16NarrowAlg4_klass);
 5315 opclass indirectMemory(indirect, indirectNarrow);
 5316 
 5317 // Special opclass for I and ConvL2I.
 5318 opclass iRegIsrc_iRegL2Isrc(iRegIsrc, iRegL2Isrc);
 5319 
 5320 // Operand classes to match encode and decode. iRegN_P2N is only used
 5321 // for storeN. I have never seen an encode node elsewhere.
 5322 opclass iRegN_P2N(iRegNsrc, iRegP2N);
 5323 opclass iRegP_N2P(iRegPsrc, iRegN2P, iRegN2P_klass);
 5324 
 5325 //----------PIPELINE-----------------------------------------------------------
 5326 
 5327 pipeline %{
 5328 
 5329 // See J.M.Tendler et al. &quot;Power4 system microarchitecture&quot;, IBM
 5330 // J. Res. &amp; Dev., No. 1, Jan. 2002.
 5331 
 5332 //----------ATTRIBUTES---------------------------------------------------------
 5333 attributes %{
 5334 
 5335   // Power4 instructions are of fixed length.
 5336   fixed_size_instructions;
 5337 
 5338   // TODO: if `bundle&#39; means number of instructions fetched
 5339   // per cycle, this is 8. If `bundle&#39; means Power4 `group&#39;, that is
 5340   // max instructions issued per cycle, this is 5.
 5341   max_instructions_per_bundle = 8;
 5342 
 5343   // A Power4 instruction is 4 bytes long.
 5344   instruction_unit_size = 4;
 5345 
 5346   // The Power4 processor fetches 64 bytes...
 5347   instruction_fetch_unit_size = 64;
 5348 
 5349   // ...in one line
 5350   instruction_fetch_units = 1
 5351 
 5352   // Unused, list one so that array generated by adlc is not empty.
 5353   // Aix compiler chokes if _nop_count = 0.
 5354   nops(fxNop);
 5355 %}
 5356 
 5357 //----------RESOURCES----------------------------------------------------------
 5358 // Resources are the functional units available to the machine
 5359 resources(
 5360    PPC_BR,         // branch unit
 5361    PPC_CR,         // condition unit
 5362    PPC_FX1,        // integer arithmetic unit 1
 5363    PPC_FX2,        // integer arithmetic unit 2
 5364    PPC_LDST1,      // load/store unit 1
 5365    PPC_LDST2,      // load/store unit 2
 5366    PPC_FP1,        // float arithmetic unit 1
 5367    PPC_FP2,        // float arithmetic unit 2
 5368    PPC_LDST = PPC_LDST1 | PPC_LDST2,
 5369    PPC_FX = PPC_FX1 | PPC_FX2,
 5370    PPC_FP = PPC_FP1 | PPC_FP2
 5371  );
 5372 
 5373 //----------PIPELINE DESCRIPTION-----------------------------------------------
 5374 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 5375 pipe_desc(
 5376    // Power4 longest pipeline path
 5377    PPC_IF,   // instruction fetch
 5378    PPC_IC,
 5379    //PPC_BP, // branch prediction
 5380    PPC_D0,   // decode
 5381    PPC_D1,   // decode
 5382    PPC_D2,   // decode
 5383    PPC_D3,   // decode
 5384    PPC_Xfer1,
 5385    PPC_GD,   // group definition
 5386    PPC_MP,   // map
 5387    PPC_ISS,  // issue
 5388    PPC_RF,   // resource fetch
 5389    PPC_EX1,  // execute (all units)
 5390    PPC_EX2,  // execute (FP, LDST)
 5391    PPC_EX3,  // execute (FP, LDST)
 5392    PPC_EX4,  // execute (FP)
 5393    PPC_EX5,  // execute (FP)
 5394    PPC_EX6,  // execute (FP)
 5395    PPC_WB,   // write back
 5396    PPC_Xfer2,
 5397    PPC_CP
 5398  );
 5399 
 5400 //----------PIPELINE CLASSES---------------------------------------------------
 5401 // Pipeline Classes describe the stages in which input and output are
 5402 // referenced by the hardware pipeline.
 5403 
 5404 // Simple pipeline classes.
 5405 
 5406 // Default pipeline class.
 5407 pipe_class pipe_class_default() %{
 5408   single_instruction;
 5409   fixed_latency(2);
 5410 %}
 5411 
 5412 // Pipeline class for empty instructions.
 5413 pipe_class pipe_class_empty() %{
 5414   single_instruction;
 5415   fixed_latency(0);
 5416 %}
 5417 
 5418 // Pipeline class for compares.
 5419 pipe_class pipe_class_compare() %{
 5420   single_instruction;
 5421   fixed_latency(16);
 5422 %}
 5423 
 5424 // Pipeline class for traps.
 5425 pipe_class pipe_class_trap() %{
 5426   single_instruction;
 5427   fixed_latency(100);
 5428 %}
 5429 
 5430 // Pipeline class for memory operations.
 5431 pipe_class pipe_class_memory() %{
 5432   single_instruction;
 5433   fixed_latency(16);
 5434 %}
 5435 
 5436 // Pipeline class for call.
 5437 pipe_class pipe_class_call() %{
 5438   single_instruction;
 5439   fixed_latency(100);
 5440 %}
 5441 
 5442 // Define the class for the Nop node.
 5443 define %{
 5444    MachNop = pipe_class_default;
 5445 %}
 5446 
 5447 %}
 5448 
 5449 //----------INSTRUCTIONS-------------------------------------------------------
 5450 
 5451 // Naming of instructions:
 5452 //   opA_operB / opA_operB_operC:
 5453 //     Operation &#39;op&#39; with one or two source operands &#39;oper&#39;. Result
 5454 //     type is A, source operand types are B and C.
 5455 //     Iff A == B == C, B and C are left out.
 5456 //
 5457 // The instructions are ordered according to the following scheme:
 5458 //  - loads
 5459 //  - load constants
 5460 //  - prefetch
 5461 //  - store
 5462 //  - encode/decode
 5463 //  - membar
 5464 //  - conditional moves
 5465 //  - compare &amp; swap
 5466 //  - arithmetic and logic operations
 5467 //    * int: Add, Sub, Mul, Div, Mod
 5468 //    * int: lShift, arShift, urShift, rot
 5469 //    * float: Add, Sub, Mul, Div
 5470 //    * and, or, xor ...
 5471 //  - register moves: float &lt;-&gt; int, reg &lt;-&gt; stack, repl
 5472 //  - cast (high level type cast, XtoP, castPP, castII, not_null etc.
 5473 //  - conv (low level type cast requiring bit changes (sign extend etc)
 5474 //  - compares, range &amp; zero checks.
 5475 //  - branches
 5476 //  - complex operations, intrinsics, min, max, replicate
 5477 //  - lock
 5478 //  - Calls
 5479 //
 5480 // If there are similar instructions with different types they are sorted:
 5481 // int before float
 5482 // small before big
 5483 // signed before unsigned
 5484 // e.g., loadS before loadUS before loadI before loadF.
 5485 
 5486 
 5487 //----------Load/Store Instructions--------------------------------------------
 5488 
 5489 //----------Load Instructions--------------------------------------------------
 5490 
 5491 // Converts byte to int.
 5492 // As convB2I_reg, but without match rule.  The match rule of convB2I_reg
 5493 // reuses the &#39;amount&#39; operand, but adlc expects that operand specification
 5494 // and operands in match rule are equivalent.
 5495 instruct convB2I_reg_2(iRegIdst dst, iRegIsrc src) %{
 5496   effect(DEF dst, USE src);
 5497   format %{ &quot;EXTSB   $dst, $src \t// byte-&gt;int&quot; %}
 5498   size(4);
 5499   ins_encode %{
 5500     // TODO: PPC port $archOpcode(ppc64Opcode_extsb);
 5501     __ extsb($dst$$Register, $src$$Register);
 5502   %}
 5503   ins_pipe(pipe_class_default);
 5504 %}
 5505 
 5506 instruct loadUB_indirect(iRegIdst dst, indirectMemory mem) %{
 5507   // match-rule, false predicate
 5508   match(Set dst (LoadB mem));
 5509   predicate(false);
 5510 
 5511   format %{ &quot;LBZ     $dst, $mem&quot; %}
 5512   size(4);
 5513   ins_encode( enc_lbz(dst, mem) );
 5514   ins_pipe(pipe_class_memory);
 5515 %}
 5516 
 5517 instruct loadUB_indirect_ac(iRegIdst dst, indirectMemory mem) %{
 5518   // match-rule, false predicate
 5519   match(Set dst (LoadB mem));
 5520   predicate(false);
 5521 
 5522   format %{ &quot;LBZ     $dst, $mem\n\t&quot;
 5523             &quot;TWI     $dst\n\t&quot;
 5524             &quot;ISYNC&quot; %}
 5525   size(12);
 5526   ins_encode( enc_lbz_ac(dst, mem) );
 5527   ins_pipe(pipe_class_memory);
 5528 %}
 5529 
 5530 // Load Byte (8bit signed). LoadB = LoadUB + ConvUB2B.
 5531 instruct loadB_indirect_Ex(iRegIdst dst, indirectMemory mem) %{
 5532   match(Set dst (LoadB mem));
 5533   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5534   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5535   expand %{
 5536     iRegIdst tmp;
 5537     loadUB_indirect(tmp, mem);
 5538     convB2I_reg_2(dst, tmp);
 5539   %}
 5540 %}
 5541 
 5542 instruct loadB_indirect_ac_Ex(iRegIdst dst, indirectMemory mem) %{
 5543   match(Set dst (LoadB mem));
 5544   ins_cost(3*MEMORY_REF_COST + DEFAULT_COST);
 5545   expand %{
 5546     iRegIdst tmp;
 5547     loadUB_indirect_ac(tmp, mem);
 5548     convB2I_reg_2(dst, tmp);
 5549   %}
 5550 %}
 5551 
 5552 instruct loadUB_indOffset16(iRegIdst dst, indOffset16 mem) %{
 5553   // match-rule, false predicate
 5554   match(Set dst (LoadB mem));
 5555   predicate(false);
 5556 
 5557   format %{ &quot;LBZ     $dst, $mem&quot; %}
 5558   size(4);
 5559   ins_encode( enc_lbz(dst, mem) );
 5560   ins_pipe(pipe_class_memory);
 5561 %}
 5562 
 5563 instruct loadUB_indOffset16_ac(iRegIdst dst, indOffset16 mem) %{
 5564   // match-rule, false predicate
 5565   match(Set dst (LoadB mem));
 5566   predicate(false);
 5567 
 5568   format %{ &quot;LBZ     $dst, $mem\n\t&quot;
 5569             &quot;TWI     $dst\n\t&quot;
 5570             &quot;ISYNC&quot; %}
 5571   size(12);
 5572   ins_encode( enc_lbz_ac(dst, mem) );
 5573   ins_pipe(pipe_class_memory);
 5574 %}
 5575 
 5576 // Load Byte (8bit signed). LoadB = LoadUB + ConvUB2B.
 5577 instruct loadB_indOffset16_Ex(iRegIdst dst, indOffset16 mem) %{
 5578   match(Set dst (LoadB mem));
 5579   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5580   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5581 
 5582   expand %{
 5583     iRegIdst tmp;
 5584     loadUB_indOffset16(tmp, mem);
 5585     convB2I_reg_2(dst, tmp);
 5586   %}
 5587 %}
 5588 
 5589 instruct loadB_indOffset16_ac_Ex(iRegIdst dst, indOffset16 mem) %{
 5590   match(Set dst (LoadB mem));
 5591   ins_cost(3*MEMORY_REF_COST + DEFAULT_COST);
 5592 
 5593   expand %{
 5594     iRegIdst tmp;
 5595     loadUB_indOffset16_ac(tmp, mem);
 5596     convB2I_reg_2(dst, tmp);
 5597   %}
 5598 %}
 5599 
 5600 // Load Unsigned Byte (8bit UNsigned) into an int reg.
 5601 instruct loadUB(iRegIdst dst, memory mem) %{
 5602   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5603   match(Set dst (LoadUB mem));
 5604   ins_cost(MEMORY_REF_COST);
 5605 
 5606   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to int&quot; %}
 5607   size(4);
 5608   ins_encode( enc_lbz(dst, mem) );
 5609   ins_pipe(pipe_class_memory);
 5610 %}
 5611 
 5612 // Load  Unsigned Byte (8bit UNsigned) acquire.
 5613 instruct loadUB_ac(iRegIdst dst, memory mem) %{
 5614   match(Set dst (LoadUB mem));
 5615   ins_cost(3*MEMORY_REF_COST);
 5616 
 5617   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to int, acquire\n\t&quot;
 5618             &quot;TWI     $dst\n\t&quot;
 5619             &quot;ISYNC&quot; %}
 5620   size(12);
 5621   ins_encode( enc_lbz_ac(dst, mem) );
 5622   ins_pipe(pipe_class_memory);
 5623 %}
 5624 
 5625 // Load Unsigned Byte (8bit UNsigned) into a Long Register.
 5626 instruct loadUB2L(iRegLdst dst, memory mem) %{
 5627   match(Set dst (ConvI2L (LoadUB mem)));
 5628   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(_kids[0]-&gt;_leaf));
 5629   ins_cost(MEMORY_REF_COST);
 5630 
 5631   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to long&quot; %}
 5632   size(4);
 5633   ins_encode( enc_lbz(dst, mem) );
 5634   ins_pipe(pipe_class_memory);
 5635 %}
 5636 
 5637 instruct loadUB2L_ac(iRegLdst dst, memory mem) %{
 5638   match(Set dst (ConvI2L (LoadUB mem)));
 5639   ins_cost(3*MEMORY_REF_COST);
 5640 
 5641   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to long, acquire\n\t&quot;
 5642             &quot;TWI     $dst\n\t&quot;
 5643             &quot;ISYNC&quot; %}
 5644   size(12);
 5645   ins_encode( enc_lbz_ac(dst, mem) );
 5646   ins_pipe(pipe_class_memory);
 5647 %}
 5648 
 5649 // Load Short (16bit signed)
 5650 instruct loadS(iRegIdst dst, memory mem) %{
 5651   match(Set dst (LoadS mem));
 5652   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5653   ins_cost(MEMORY_REF_COST);
 5654 
 5655   format %{ &quot;LHA     $dst, $mem&quot; %}
 5656   size(4);
 5657   ins_encode %{
 5658     // TODO: PPC port $archOpcode(ppc64Opcode_lha);
 5659     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5660     __ lha($dst$$Register, Idisp, $mem$$base$$Register);
 5661   %}
 5662   ins_pipe(pipe_class_memory);
 5663 %}
 5664 
 5665 // Load Short (16bit signed) acquire.
 5666 instruct loadS_ac(iRegIdst dst, memory mem) %{
 5667   match(Set dst (LoadS mem));
 5668   ins_cost(3*MEMORY_REF_COST);
 5669 
 5670   format %{ &quot;LHA     $dst, $mem\t acquire\n\t&quot;
 5671             &quot;TWI     $dst\n\t&quot;
 5672             &quot;ISYNC&quot; %}
 5673   size(12);
 5674   ins_encode %{
 5675     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 5676     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5677     __ lha($dst$$Register, Idisp, $mem$$base$$Register);
 5678     __ twi_0($dst$$Register);
 5679     __ isync();
 5680   %}
 5681   ins_pipe(pipe_class_memory);
 5682 %}
 5683 
 5684 // Load Char (16bit unsigned)
 5685 instruct loadUS(iRegIdst dst, memory mem) %{
 5686   match(Set dst (LoadUS mem));
 5687   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5688   ins_cost(MEMORY_REF_COST);
 5689 
 5690   format %{ &quot;LHZ     $dst, $mem&quot; %}
 5691   size(4);
 5692   ins_encode( enc_lhz(dst, mem) );
 5693   ins_pipe(pipe_class_memory);
 5694 %}
 5695 
 5696 // Load Char (16bit unsigned) acquire.
 5697 instruct loadUS_ac(iRegIdst dst, memory mem) %{
 5698   match(Set dst (LoadUS mem));
 5699   ins_cost(3*MEMORY_REF_COST);
 5700 
 5701   format %{ &quot;LHZ     $dst, $mem \t// acquire\n\t&quot;
 5702             &quot;TWI     $dst\n\t&quot;
 5703             &quot;ISYNC&quot; %}
 5704   size(12);
 5705   ins_encode( enc_lhz_ac(dst, mem) );
 5706   ins_pipe(pipe_class_memory);
 5707 %}
 5708 
 5709 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register.
 5710 instruct loadUS2L(iRegLdst dst, memory mem) %{
 5711   match(Set dst (ConvI2L (LoadUS mem)));
 5712   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(_kids[0]-&gt;_leaf));
 5713   ins_cost(MEMORY_REF_COST);
 5714 
 5715   format %{ &quot;LHZ     $dst, $mem \t// short, zero-extend to long&quot; %}
 5716   size(4);
 5717   ins_encode( enc_lhz(dst, mem) );
 5718   ins_pipe(pipe_class_memory);
 5719 %}
 5720 
 5721 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register acquire.
 5722 instruct loadUS2L_ac(iRegLdst dst, memory mem) %{
 5723   match(Set dst (ConvI2L (LoadUS mem)));
 5724   ins_cost(3*MEMORY_REF_COST);
 5725 
 5726   format %{ &quot;LHZ     $dst, $mem \t// short, zero-extend to long, acquire\n\t&quot;
 5727             &quot;TWI     $dst\n\t&quot;
 5728             &quot;ISYNC&quot; %}
 5729   size(12);
 5730   ins_encode( enc_lhz_ac(dst, mem) );
 5731   ins_pipe(pipe_class_memory);
 5732 %}
 5733 
 5734 // Load Integer.
 5735 instruct loadI(iRegIdst dst, memory mem) %{
 5736   match(Set dst (LoadI mem));
 5737   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5738   ins_cost(MEMORY_REF_COST);
 5739 
 5740   format %{ &quot;LWZ     $dst, $mem&quot; %}
 5741   size(4);
 5742   ins_encode( enc_lwz(dst, mem) );
 5743   ins_pipe(pipe_class_memory);
 5744 %}
 5745 
 5746 // Load Integer acquire.
 5747 instruct loadI_ac(iRegIdst dst, memory mem) %{
 5748   match(Set dst (LoadI mem));
 5749   ins_cost(3*MEMORY_REF_COST);
 5750 
 5751   format %{ &quot;LWZ     $dst, $mem \t// load acquire\n\t&quot;
 5752             &quot;TWI     $dst\n\t&quot;
 5753             &quot;ISYNC&quot; %}
 5754   size(12);
 5755   ins_encode( enc_lwz_ac(dst, mem) );
 5756   ins_pipe(pipe_class_memory);
 5757 %}
 5758 
 5759 // Match loading integer and casting it to unsigned int in
 5760 // long register.
 5761 // LoadI + ConvI2L + AndL 0xffffffff.
 5762 instruct loadUI2L(iRegLdst dst, memory mem, immL_32bits mask) %{
 5763   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5764   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5765   ins_cost(MEMORY_REF_COST);
 5766 
 5767   format %{ &quot;LWZ     $dst, $mem \t// zero-extend to long&quot; %}
 5768   size(4);
 5769   ins_encode( enc_lwz(dst, mem) );
 5770   ins_pipe(pipe_class_memory);
 5771 %}
 5772 
 5773 // Match loading integer and casting it to long.
 5774 instruct loadI2L(iRegLdst dst, memoryAlg4 mem) %{
 5775   match(Set dst (ConvI2L (LoadI mem)));
 5776   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5777   ins_cost(MEMORY_REF_COST);
 5778 
 5779   format %{ &quot;LWA     $dst, $mem \t// loadI2L&quot; %}
 5780   size(4);
 5781   ins_encode %{
 5782     // TODO: PPC port $archOpcode(ppc64Opcode_lwa);
 5783     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5784     __ lwa($dst$$Register, Idisp, $mem$$base$$Register);
 5785   %}
 5786   ins_pipe(pipe_class_memory);
 5787 %}
 5788 
 5789 // Match loading integer and casting it to long - acquire.
 5790 instruct loadI2L_ac(iRegLdst dst, memoryAlg4 mem) %{
 5791   match(Set dst (ConvI2L (LoadI mem)));
 5792   ins_cost(3*MEMORY_REF_COST);
 5793 
 5794   format %{ &quot;LWA     $dst, $mem \t// loadI2L acquire&quot;
 5795             &quot;TWI     $dst\n\t&quot;
 5796             &quot;ISYNC&quot; %}
 5797   size(12);
 5798   ins_encode %{
 5799     // TODO: PPC port $archOpcode(ppc64Opcode_lwa);
 5800     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5801     __ lwa($dst$$Register, Idisp, $mem$$base$$Register);
 5802     __ twi_0($dst$$Register);
 5803     __ isync();
 5804   %}
 5805   ins_pipe(pipe_class_memory);
 5806 %}
 5807 
 5808 // Load Long - aligned
 5809 instruct loadL(iRegLdst dst, memoryAlg4 mem) %{
 5810   match(Set dst (LoadL mem));
 5811   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5812   ins_cost(MEMORY_REF_COST);
 5813 
 5814   format %{ &quot;LD      $dst, $mem \t// long&quot; %}
 5815   size(4);
 5816   ins_encode( enc_ld(dst, mem) );
 5817   ins_pipe(pipe_class_memory);
 5818 %}
 5819 
 5820 // Load Long - aligned acquire.
 5821 instruct loadL_ac(iRegLdst dst, memoryAlg4 mem) %{
 5822   match(Set dst (LoadL mem));
 5823   ins_cost(3*MEMORY_REF_COST);
 5824 
 5825   format %{ &quot;LD      $dst, $mem \t// long acquire\n\t&quot;
 5826             &quot;TWI     $dst\n\t&quot;
 5827             &quot;ISYNC&quot; %}
 5828   size(12);
 5829   ins_encode( enc_ld_ac(dst, mem) );
 5830   ins_pipe(pipe_class_memory);
 5831 %}
 5832 
 5833 // Load Long - UNaligned
 5834 instruct loadL_unaligned(iRegLdst dst, memoryAlg4 mem) %{
 5835   match(Set dst (LoadL_unaligned mem));
 5836   // predicate(...) // Unaligned_ac is not needed (and wouldn&#39;t make sense).
 5837   ins_cost(MEMORY_REF_COST);
 5838 
 5839   format %{ &quot;LD      $dst, $mem \t// unaligned long&quot; %}
 5840   size(4);
 5841   ins_encode( enc_ld(dst, mem) );
 5842   ins_pipe(pipe_class_memory);
 5843 %}
 5844 
 5845 // Load nodes for superwords
 5846 
 5847 // Load Aligned Packed Byte
 5848 instruct loadV8(iRegLdst dst, memoryAlg4 mem) %{
 5849   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);
 5850   match(Set dst (LoadVector mem));
 5851   ins_cost(MEMORY_REF_COST);
 5852 
 5853   format %{ &quot;LD      $dst, $mem \t// load 8-byte Vector&quot; %}
 5854   size(4);
 5855   ins_encode( enc_ld(dst, mem) );
 5856   ins_pipe(pipe_class_memory);
 5857 %}
 5858 
 5859 // Load Aligned Packed Byte
 5860 instruct loadV16(vecX dst, indirect mem) %{
 5861   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 16);
 5862   match(Set dst (LoadVector mem));
 5863   ins_cost(MEMORY_REF_COST);
 5864 
 5865   format %{ &quot;LXVD2X      $dst, $mem \t// load 16-byte Vector&quot; %}
 5866   size(4);
 5867   ins_encode %{
 5868     __ lxvd2x($dst$$VectorSRegister, $mem$$Register);
 5869   %}
 5870   ins_pipe(pipe_class_default);
 5871 %}
 5872 
 5873 // Load Range, range = array length (=jint)
 5874 instruct loadRange(iRegIdst dst, memory mem) %{
 5875   match(Set dst (LoadRange mem));
 5876   ins_cost(MEMORY_REF_COST);
 5877 
 5878   format %{ &quot;LWZ     $dst, $mem \t// range&quot; %}
 5879   size(4);
 5880   ins_encode( enc_lwz(dst, mem) );
 5881   ins_pipe(pipe_class_memory);
 5882 %}
 5883 
 5884 // Load Compressed Pointer
 5885 instruct loadN(iRegNdst dst, memory mem) %{
 5886   match(Set dst (LoadN mem));
 5887   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5888   ins_cost(MEMORY_REF_COST);
 5889 
 5890   format %{ &quot;LWZ     $dst, $mem \t// load compressed ptr&quot; %}
 5891   size(4);
 5892   ins_encode( enc_lwz(dst, mem) );
 5893   ins_pipe(pipe_class_memory);
 5894 %}
 5895 
 5896 // Load Compressed Pointer acquire.
 5897 instruct loadN_ac(iRegNdst dst, memory mem) %{
 5898   match(Set dst (LoadN mem));
 5899   ins_cost(3*MEMORY_REF_COST);
 5900 
 5901   format %{ &quot;LWZ     $dst, $mem \t// load acquire compressed ptr\n\t&quot;
 5902             &quot;TWI     $dst\n\t&quot;
 5903             &quot;ISYNC&quot; %}
 5904   size(12);
 5905   ins_encode( enc_lwz_ac(dst, mem) );
 5906   ins_pipe(pipe_class_memory);
 5907 %}
 5908 
 5909 // Load Compressed Pointer and decode it if narrow_oop_shift == 0.
 5910 instruct loadN2P_unscaled(iRegPdst dst, memory mem) %{
 5911   match(Set dst (DecodeN (LoadN mem)));
 5912   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() &amp;&amp; CompressedOops::shift() == 0);
 5913   ins_cost(MEMORY_REF_COST);
 5914 
 5915   format %{ &quot;LWZ     $dst, $mem \t// DecodeN (unscaled)&quot; %}
 5916   size(4);
 5917   ins_encode( enc_lwz(dst, mem) );
 5918   ins_pipe(pipe_class_memory);
 5919 %}
 5920 
 5921 instruct loadN2P_klass_unscaled(iRegPdst dst, memory mem) %{
 5922   match(Set dst (DecodeNKlass (LoadNKlass mem)));
 5923   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0 &amp;&amp;
 5924             _kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5925   ins_cost(MEMORY_REF_COST);
 5926 
 5927   format %{ &quot;LWZ     $dst, $mem \t// DecodeN (unscaled)&quot; %}
 5928   size(4);
 5929   ins_encode( enc_lwz(dst, mem) );
 5930   ins_pipe(pipe_class_memory);
 5931 %}
 5932 
 5933 // Load Pointer
 5934 instruct loadP(iRegPdst dst, memoryAlg4 mem) %{
 5935   match(Set dst (LoadP mem));
 5936   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5937   ins_cost(MEMORY_REF_COST);
 5938 
 5939   format %{ &quot;LD      $dst, $mem \t// ptr&quot; %}
 5940   size(4);
 5941   ins_encode( enc_ld(dst, mem) );
 5942   ins_pipe(pipe_class_memory);
 5943 %}
 5944 
 5945 // Load Pointer acquire.
 5946 instruct loadP_ac(iRegPdst dst, memoryAlg4 mem) %{
 5947   match(Set dst (LoadP mem));
 5948   ins_cost(3*MEMORY_REF_COST);
 5949 
 5950   format %{ &quot;LD      $dst, $mem \t// ptr acquire\n\t&quot;
 5951             &quot;TWI     $dst\n\t&quot;
 5952             &quot;ISYNC&quot; %}
 5953   size(12);
 5954   ins_encode( enc_ld_ac(dst, mem) );
 5955   ins_pipe(pipe_class_memory);
 5956 %}
 5957 
 5958 // LoadP + CastP2L
 5959 instruct loadP2X(iRegLdst dst, memoryAlg4 mem) %{
 5960   match(Set dst (CastP2X (LoadP mem)));
 5961   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5962   ins_cost(MEMORY_REF_COST);
 5963 
 5964   format %{ &quot;LD      $dst, $mem \t// ptr + p2x&quot; %}
 5965   size(4);
 5966   ins_encode( enc_ld(dst, mem) );
 5967   ins_pipe(pipe_class_memory);
 5968 %}
 5969 
 5970 // Load compressed klass pointer.
 5971 instruct loadNKlass(iRegNdst dst, memory mem) %{
 5972   match(Set dst (LoadNKlass mem));
 5973   ins_cost(MEMORY_REF_COST);
 5974 
 5975   format %{ &quot;LWZ     $dst, $mem \t// compressed klass ptr&quot; %}
 5976   size(4);
 5977   ins_encode( enc_lwz(dst, mem) );
 5978   ins_pipe(pipe_class_memory);
 5979 %}
 5980 
 5981 // Load Klass Pointer
 5982 instruct loadKlass(iRegPdst dst, memoryAlg4 mem) %{
 5983   match(Set dst (LoadKlass mem));
 5984   ins_cost(MEMORY_REF_COST);
 5985 
 5986   format %{ &quot;LD      $dst, $mem \t// klass ptr&quot; %}
 5987   size(4);
 5988   ins_encode( enc_ld(dst, mem) );
 5989   ins_pipe(pipe_class_memory);
 5990 %}
 5991 
 5992 // Load Float
 5993 instruct loadF(regF dst, memory mem) %{
 5994   match(Set dst (LoadF mem));
 5995   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5996   ins_cost(MEMORY_REF_COST);
 5997 
 5998   format %{ &quot;LFS     $dst, $mem&quot; %}
 5999   size(4);
 6000   ins_encode %{
 6001     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
 6002     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6003     __ lfs($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 6004   %}
 6005   ins_pipe(pipe_class_memory);
 6006 %}
 6007 
 6008 // Load Float acquire.
 6009 instruct loadF_ac(regF dst, memory mem, flagsRegCR0 cr0) %{
 6010   match(Set dst (LoadF mem));
 6011   effect(TEMP cr0);
 6012   ins_cost(3*MEMORY_REF_COST);
 6013 
 6014   format %{ &quot;LFS     $dst, $mem \t// acquire\n\t&quot;
 6015             &quot;FCMPU   cr0, $dst, $dst\n\t&quot;
 6016             &quot;BNE     cr0, next\n&quot;
 6017             &quot;next:\n\t&quot;
 6018             &quot;ISYNC&quot; %}
 6019   size(16);
 6020   ins_encode %{
 6021     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6022     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6023     Label next;
 6024     __ lfs($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 6025     __ fcmpu(CCR0, $dst$$FloatRegister, $dst$$FloatRegister);
 6026     __ bne(CCR0, next);
 6027     __ bind(next);
 6028     __ isync();
 6029   %}
 6030   ins_pipe(pipe_class_memory);
 6031 %}
 6032 
 6033 // Load Double - aligned
 6034 instruct loadD(regD dst, memory mem) %{
 6035   match(Set dst (LoadD mem));
 6036   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 6037   ins_cost(MEMORY_REF_COST);
 6038 
 6039   format %{ &quot;LFD     $dst, $mem&quot; %}
 6040   size(4);
 6041   ins_encode( enc_lfd(dst, mem) );
 6042   ins_pipe(pipe_class_memory);
 6043 %}
 6044 
 6045 // Load Double - aligned acquire.
 6046 instruct loadD_ac(regD dst, memory mem, flagsRegCR0 cr0) %{
 6047   match(Set dst (LoadD mem));
 6048   effect(TEMP cr0);
 6049   ins_cost(3*MEMORY_REF_COST);
 6050 
 6051   format %{ &quot;LFD     $dst, $mem \t// acquire\n\t&quot;
 6052             &quot;FCMPU   cr0, $dst, $dst\n\t&quot;
 6053             &quot;BNE     cr0, next\n&quot;
 6054             &quot;next:\n\t&quot;
 6055             &quot;ISYNC&quot; %}
 6056   size(16);
 6057   ins_encode %{
 6058     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6059     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6060     Label next;
 6061     __ lfd($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 6062     __ fcmpu(CCR0, $dst$$FloatRegister, $dst$$FloatRegister);
 6063     __ bne(CCR0, next);
 6064     __ bind(next);
 6065     __ isync();
 6066   %}
 6067   ins_pipe(pipe_class_memory);
 6068 %}
 6069 
 6070 // Load Double - UNaligned
 6071 instruct loadD_unaligned(regD dst, memory mem) %{
 6072   match(Set dst (LoadD_unaligned mem));
 6073   // predicate(...) // Unaligned_ac is not needed (and wouldn&#39;t make sense).
 6074   ins_cost(MEMORY_REF_COST);
 6075 
 6076   format %{ &quot;LFD     $dst, $mem&quot; %}
 6077   size(4);
 6078   ins_encode( enc_lfd(dst, mem) );
 6079   ins_pipe(pipe_class_memory);
 6080 %}
 6081 
 6082 //----------Constants--------------------------------------------------------
 6083 
 6084 // Load MachConstantTableBase: add hi offset to global toc.
 6085 // TODO: Handle hidden register r29 in bundler!
 6086 instruct loadToc_hi(iRegLdst dst) %{
 6087   effect(DEF dst);
 6088   ins_cost(DEFAULT_COST);
 6089 
 6090   format %{ &quot;ADDIS   $dst, R29, DISP.hi \t// load TOC hi&quot; %}
 6091   size(4);
 6092   ins_encode %{
 6093     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6094     __ calculate_address_from_global_toc_hi16only($dst$$Register, __ method_toc());
 6095   %}
 6096   ins_pipe(pipe_class_default);
 6097 %}
 6098 
 6099 // Load MachConstantTableBase: add lo offset to global toc.
 6100 instruct loadToc_lo(iRegLdst dst, iRegLdst src) %{
 6101   effect(DEF dst, USE src);
 6102   ins_cost(DEFAULT_COST);
 6103 
 6104   format %{ &quot;ADDI    $dst, $src, DISP.lo \t// load TOC lo&quot; %}
 6105   size(4);
 6106   ins_encode %{
 6107     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6108     __ calculate_address_from_global_toc_lo16only($dst$$Register, __ method_toc());
 6109   %}
 6110   ins_pipe(pipe_class_default);
 6111 %}
 6112 
 6113 // Load 16-bit integer constant 0xssss????
 6114 instruct loadConI16(iRegIdst dst, immI16 src) %{
 6115   match(Set dst src);
 6116 
 6117   format %{ &quot;LI      $dst, $src&quot; %}
 6118   size(4);
 6119   ins_encode %{
 6120     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6121     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
 6122   %}
 6123   ins_pipe(pipe_class_default);
 6124 %}
 6125 
 6126 // Load integer constant 0x????0000
 6127 instruct loadConIhi16(iRegIdst dst, immIhi16 src) %{
 6128   match(Set dst src);
 6129   ins_cost(DEFAULT_COST);
 6130 
 6131   format %{ &quot;LIS     $dst, $src.hi&quot; %}
 6132   size(4);
 6133   ins_encode %{
 6134     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6135     // Lis sign extends 16-bit src then shifts it 16 bit to the left.
 6136     __ lis($dst$$Register, (int)((short)(($src$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
 6137   %}
 6138   ins_pipe(pipe_class_default);
 6139 %}
 6140 
 6141 // Part 2 of loading 32 bit constant: hi16 is is src1 (properly shifted
 6142 // and sign extended), this adds the low 16 bits.
 6143 instruct loadConI32_lo16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
 6144   // no match-rule, false predicate
 6145   effect(DEF dst, USE src1, USE src2);
 6146   predicate(false);
 6147 
 6148   format %{ &quot;ORI     $dst, $src1.hi, $src2.lo&quot; %}
 6149   size(4);
 6150   ins_encode %{
 6151     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6152     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
 6153   %}
 6154   ins_pipe(pipe_class_default);
 6155 %}
 6156 
 6157 instruct loadConI_Ex(iRegIdst dst, immI src) %{
 6158   match(Set dst src);
 6159   ins_cost(DEFAULT_COST*2);
 6160 
 6161   expand %{
 6162     // Would like to use $src$$constant.
 6163     immI16 srcLo %{ _opnds[1]-&gt;constant() %}
 6164     // srcHi can be 0000 if srcLo sign-extends to a negative number.
 6165     immIhi16 srcHi %{ _opnds[1]-&gt;constant() %}
 6166     iRegIdst tmpI;
 6167     loadConIhi16(tmpI, srcHi);
 6168     loadConI32_lo16(dst, tmpI, srcLo);
 6169   %}
 6170 %}
 6171 
 6172 // No constant pool entries required.
 6173 instruct loadConL16(iRegLdst dst, immL16 src) %{
 6174   match(Set dst src);
 6175 
 6176   format %{ &quot;LI      $dst, $src \t// long&quot; %}
 6177   size(4);
 6178   ins_encode %{
 6179     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6180     __ li($dst$$Register, (int)((short) ($src$$constant &amp; 0xFFFF)));
 6181   %}
 6182   ins_pipe(pipe_class_default);
 6183 %}
 6184 
 6185 // Load long constant 0xssssssss????0000
 6186 instruct loadConL32hi16(iRegLdst dst, immL32hi16 src) %{
 6187   match(Set dst src);
 6188   ins_cost(DEFAULT_COST);
 6189 
 6190   format %{ &quot;LIS     $dst, $src.hi \t// long&quot; %}
 6191   size(4);
 6192   ins_encode %{
 6193     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6194     __ lis($dst$$Register, (int)((short)(($src$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
 6195   %}
 6196   ins_pipe(pipe_class_default);
 6197 %}
 6198 
 6199 // To load a 32 bit constant: merge lower 16 bits into already loaded
 6200 // high 16 bits.
 6201 instruct loadConL32_lo16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
 6202   // no match-rule, false predicate
 6203   effect(DEF dst, USE src1, USE src2);
 6204   predicate(false);
 6205 
 6206   format %{ &quot;ORI     $dst, $src1, $src2.lo&quot; %}
 6207   size(4);
 6208   ins_encode %{
 6209     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6210     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
 6211   %}
 6212   ins_pipe(pipe_class_default);
 6213 %}
 6214 
 6215 // Load 32-bit long constant
 6216 instruct loadConL32_Ex(iRegLdst dst, immL32 src) %{
 6217   match(Set dst src);
 6218   ins_cost(DEFAULT_COST*2);
 6219 
 6220   expand %{
 6221     // Would like to use $src$$constant.
 6222     immL16     srcLo %{ _opnds[1]-&gt;constant() /*&amp; 0x0000FFFFL */%}
 6223     // srcHi can be 0000 if srcLo sign-extends to a negative number.
 6224     immL32hi16 srcHi %{ _opnds[1]-&gt;constant() /*&amp; 0xFFFF0000L */%}
 6225     iRegLdst tmpL;
 6226     loadConL32hi16(tmpL, srcHi);
 6227     loadConL32_lo16(dst, tmpL, srcLo);
 6228   %}
 6229 %}
 6230 
 6231 // Load long constant 0x????000000000000.
 6232 instruct loadConLhighest16_Ex(iRegLdst dst, immLhighest16 src) %{
 6233   match(Set dst src);
 6234   ins_cost(DEFAULT_COST);
 6235 
 6236   expand %{
 6237     immL32hi16 srcHi %{ _opnds[1]-&gt;constant() &gt;&gt; 32 /*&amp; 0xFFFF0000L */%}
 6238     immI shift32 %{ 32 %}
 6239     iRegLdst tmpL;
 6240     loadConL32hi16(tmpL, srcHi);
 6241     lshiftL_regL_immI(dst, tmpL, shift32);
 6242   %}
 6243 %}
 6244 
 6245 // Expand node for constant pool load: small offset.
 6246 instruct loadConL(iRegLdst dst, immL src, iRegLdst toc) %{
 6247   effect(DEF dst, USE src, USE toc);
 6248   ins_cost(MEMORY_REF_COST);
 6249 
 6250   ins_num_consts(1);
 6251   // Needed so that CallDynamicJavaDirect can compute the address of this
 6252   // instruction for relocation.
 6253   ins_field_cbuf_insts_offset(int);
 6254 
 6255   format %{ &quot;LD      $dst, offset, $toc \t// load long $src from TOC&quot; %}
 6256   size(4);
 6257   ins_encode( enc_load_long_constL(dst, src, toc) );
 6258   ins_pipe(pipe_class_memory);
 6259 %}
 6260 
 6261 // Expand node for constant pool load: large offset.
 6262 instruct loadConL_hi(iRegLdst dst, immL src, iRegLdst toc) %{
 6263   effect(DEF dst, USE src, USE toc);
 6264   predicate(false);
 6265 
 6266   ins_num_consts(1);
 6267   ins_field_const_toc_offset(int);
 6268   // Needed so that CallDynamicJavaDirect can compute the address of this
 6269   // instruction for relocation.
 6270   ins_field_cbuf_insts_offset(int);
 6271 
 6272   format %{ &quot;ADDIS   $dst, $toc, offset \t// load long $src from TOC (hi)&quot; %}
 6273   size(4);
 6274   ins_encode( enc_load_long_constL_hi(dst, toc, src) );
 6275   ins_pipe(pipe_class_default);
 6276 %}
 6277 
 6278 // Expand node for constant pool load: large offset.
 6279 // No constant pool entries required.
 6280 instruct loadConL_lo(iRegLdst dst, immL src, iRegLdst base) %{
 6281   effect(DEF dst, USE src, USE base);
 6282   predicate(false);
 6283 
 6284   ins_field_const_toc_offset_hi_node(loadConL_hiNode*);
 6285 
 6286   format %{ &quot;LD      $dst, offset, $base \t// load long $src from TOC (lo)&quot; %}
 6287   size(4);
 6288   ins_encode %{
 6289     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
<a name="68" id="anc68"></a><span class="line-modified"> 6290     int offset = ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;</span>
 6291     __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
 6292   %}
 6293   ins_pipe(pipe_class_memory);
 6294 %}
 6295 
 6296 // Load long constant from constant table. Expand in case of
 6297 // offset &gt; 16 bit is needed.
 6298 // Adlc adds toc node MachConstantTableBase.
 6299 instruct loadConL_Ex(iRegLdst dst, immL src) %{
 6300   match(Set dst src);
 6301   ins_cost(MEMORY_REF_COST);
 6302 
 6303   format %{ &quot;LD      $dst, offset, $constanttablebase\t// load long $src from table, postalloc expanded&quot; %}
 6304   // We can not inline the enc_class for the expand as that does not support constanttablebase.
 6305   postalloc_expand( postalloc_expand_load_long_constant(dst, src, constanttablebase) );
 6306 %}
 6307 
 6308 // Load NULL as compressed oop.
 6309 instruct loadConN0(iRegNdst dst, immN_0 src) %{
 6310   match(Set dst src);
 6311   ins_cost(DEFAULT_COST);
 6312 
 6313   format %{ &quot;LI      $dst, $src \t// compressed ptr&quot; %}
 6314   size(4);
 6315   ins_encode %{
 6316     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6317     __ li($dst$$Register, 0);
 6318   %}
 6319   ins_pipe(pipe_class_default);
 6320 %}
 6321 
 6322 // Load hi part of compressed oop constant.
 6323 instruct loadConN_hi(iRegNdst dst, immN src) %{
 6324   effect(DEF dst, USE src);
 6325   ins_cost(DEFAULT_COST);
 6326 
 6327   format %{ &quot;LIS     $dst, $src \t// narrow oop hi&quot; %}
 6328   size(4);
 6329   ins_encode %{
 6330     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6331     __ lis($dst$$Register, (int)(short)(($src$$constant &gt;&gt; 16) &amp; 0xffff));
 6332   %}
 6333   ins_pipe(pipe_class_default);
 6334 %}
 6335 
 6336 // Add lo part of compressed oop constant to already loaded hi part.
 6337 instruct loadConN_lo(iRegNdst dst, iRegNsrc src1, immN src2) %{
 6338   effect(DEF dst, USE src1, USE src2);
 6339   ins_cost(DEFAULT_COST);
 6340 
 6341   format %{ &quot;ORI     $dst, $src1, $src2 \t// narrow oop lo&quot; %}
 6342   size(4);
 6343   ins_encode %{
 6344     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6345     assert(__ oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 6346     int oop_index = __ oop_recorder()-&gt;find_index((jobject)$src2$$constant);
 6347     RelocationHolder rspec = oop_Relocation::spec(oop_index);
 6348     __ relocate(rspec, 1);
 6349     __ ori($dst$$Register, $src1$$Register, $src2$$constant &amp; 0xffff);
 6350   %}
 6351   ins_pipe(pipe_class_default);
 6352 %}
 6353 
 6354 instruct rldicl(iRegLdst dst, iRegLsrc src, immI16 shift, immI16 mask_begin) %{
 6355   effect(DEF dst, USE src, USE shift, USE mask_begin);
 6356 
 6357   size(4);
 6358   ins_encode %{
 6359     __ rldicl($dst$$Register, $src$$Register, $shift$$constant, $mask_begin$$constant);
 6360   %}
 6361   ins_pipe(pipe_class_default);
 6362 %}
 6363 
 6364 // Needed to postalloc expand loadConN: ConN is loaded as ConI
 6365 // leaving the upper 32 bits with sign-extension bits.
 6366 // This clears these bits: dst = src &amp; 0xFFFFFFFF.
 6367 // TODO: Eventually call this maskN_regN_FFFFFFFF.
 6368 instruct clearMs32b(iRegNdst dst, iRegNsrc src) %{
 6369   effect(DEF dst, USE src);
 6370   predicate(false);
 6371 
 6372   format %{ &quot;MASK    $dst, $src, 0xFFFFFFFF&quot; %} // mask
 6373   size(4);
 6374   ins_encode %{
 6375     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 6376     __ clrldi($dst$$Register, $src$$Register, 0x20);
 6377   %}
 6378   ins_pipe(pipe_class_default);
 6379 %}
 6380 
 6381 // Optimize DecodeN for disjoint base.
 6382 // Load base of compressed oops into a register
 6383 instruct loadBase(iRegLdst dst) %{
 6384   effect(DEF dst);
 6385 
 6386   format %{ &quot;LoadConst $dst, heapbase&quot; %}
 6387   ins_encode %{
 6388     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6389     __ load_const_optimized($dst$$Register, CompressedOops::base(), R0);
 6390   %}
 6391   ins_pipe(pipe_class_default);
 6392 %}
 6393 
 6394 // Loading ConN must be postalloc expanded so that edges between
 6395 // the nodes are safe. They may not interfere with a safepoint.
 6396 // GL TODO: This needs three instructions: better put this into the constant pool.
 6397 instruct loadConN_Ex(iRegNdst dst, immN src) %{
 6398   match(Set dst src);
 6399   ins_cost(DEFAULT_COST*2);
 6400 
 6401   format %{ &quot;LoadN   $dst, $src \t// postalloc expanded&quot; %} // mask
 6402   postalloc_expand %{
 6403     MachNode *m1 = new loadConN_hiNode();
 6404     MachNode *m2 = new loadConN_loNode();
 6405     MachNode *m3 = new clearMs32bNode();
 6406     m1-&gt;add_req(NULL);
 6407     m2-&gt;add_req(NULL, m1);
 6408     m3-&gt;add_req(NULL, m2);
 6409     m1-&gt;_opnds[0] = op_dst;
 6410     m1-&gt;_opnds[1] = op_src;
 6411     m2-&gt;_opnds[0] = op_dst;
 6412     m2-&gt;_opnds[1] = op_dst;
 6413     m2-&gt;_opnds[2] = op_src;
 6414     m3-&gt;_opnds[0] = op_dst;
 6415     m3-&gt;_opnds[1] = op_dst;
 6416     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6417     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6418     ra_-&gt;set_pair(m3-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6419     nodes-&gt;push(m1);
 6420     nodes-&gt;push(m2);
 6421     nodes-&gt;push(m3);
 6422   %}
 6423 %}
 6424 
 6425 // We have seen a safepoint between the hi and lo parts, and this node was handled
 6426 // as an oop. Therefore this needs a match rule so that build_oop_map knows this is
 6427 // not a narrow oop.
 6428 instruct loadConNKlass_hi(iRegNdst dst, immNKlass_NM src) %{
 6429   match(Set dst src);
 6430   effect(DEF dst, USE src);
 6431   ins_cost(DEFAULT_COST);
 6432 
 6433   format %{ &quot;LIS     $dst, $src \t// narrow klass hi&quot; %}
 6434   size(4);
 6435   ins_encode %{
 6436     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6437     intptr_t Csrc = CompressedKlassPointers::encode((Klass *)$src$$constant);
 6438     __ lis($dst$$Register, (int)(short)((Csrc &gt;&gt; 16) &amp; 0xffff));
 6439   %}
 6440   ins_pipe(pipe_class_default);
 6441 %}
 6442 
 6443 // As loadConNKlass_hi this must be recognized as narrow klass, not oop!
 6444 instruct loadConNKlass_mask(iRegNdst dst, immNKlass_NM src1, iRegNsrc src2) %{
 6445   match(Set dst src1);
 6446   effect(TEMP src2);
 6447   ins_cost(DEFAULT_COST);
 6448 
 6449   format %{ &quot;MASK    $dst, $src2, 0xFFFFFFFF&quot; %} // mask
 6450   size(4);
 6451   ins_encode %{
 6452     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 6453     __ clrldi($dst$$Register, $src2$$Register, 0x20);
 6454   %}
 6455   ins_pipe(pipe_class_default);
 6456 %}
 6457 
 6458 // This needs a match rule so that build_oop_map knows this is
 6459 // not a narrow oop.
 6460 instruct loadConNKlass_lo(iRegNdst dst, immNKlass_NM src1, iRegNsrc src2) %{
 6461   match(Set dst src1);
 6462   effect(TEMP src2);
 6463   ins_cost(DEFAULT_COST);
 6464 
 6465   format %{ &quot;ORI     $dst, $src1, $src2 \t// narrow klass lo&quot; %}
 6466   size(4);
 6467   ins_encode %{
 6468     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6469     intptr_t Csrc = CompressedKlassPointers::encode((Klass *)$src1$$constant);
 6470     assert(__ oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 6471     int klass_index = __ oop_recorder()-&gt;find_index((Klass *)$src1$$constant);
 6472     RelocationHolder rspec = metadata_Relocation::spec(klass_index);
 6473 
 6474     __ relocate(rspec, 1);
 6475     __ ori($dst$$Register, $src2$$Register, Csrc &amp; 0xffff);
 6476   %}
 6477   ins_pipe(pipe_class_default);
 6478 %}
 6479 
 6480 // Loading ConNKlass must be postalloc expanded so that edges between
 6481 // the nodes are safe. They may not interfere with a safepoint.
 6482 instruct loadConNKlass_Ex(iRegNdst dst, immNKlass src) %{
 6483   match(Set dst src);
 6484   ins_cost(DEFAULT_COST*2);
 6485 
 6486   format %{ &quot;LoadN   $dst, $src \t// postalloc expanded&quot; %} // mask
 6487   postalloc_expand %{
 6488     // Load high bits into register. Sign extended.
 6489     MachNode *m1 = new loadConNKlass_hiNode();
 6490     m1-&gt;add_req(NULL);
 6491     m1-&gt;_opnds[0] = op_dst;
 6492     m1-&gt;_opnds[1] = op_src;
 6493     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6494     nodes-&gt;push(m1);
 6495 
 6496     MachNode *m2 = m1;
 6497     if (!Assembler::is_uimm((jlong)CompressedKlassPointers::encode((Klass *)op_src-&gt;constant()), 31)) {
 6498       // Value might be 1-extended. Mask out these bits.
 6499       m2 = new loadConNKlass_maskNode();
 6500       m2-&gt;add_req(NULL, m1);
 6501       m2-&gt;_opnds[0] = op_dst;
 6502       m2-&gt;_opnds[1] = op_src;
 6503       m2-&gt;_opnds[2] = op_dst;
 6504       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6505       nodes-&gt;push(m2);
 6506     }
 6507 
 6508     MachNode *m3 = new loadConNKlass_loNode();
 6509     m3-&gt;add_req(NULL, m2);
 6510     m3-&gt;_opnds[0] = op_dst;
 6511     m3-&gt;_opnds[1] = op_src;
 6512     m3-&gt;_opnds[2] = op_dst;
 6513     ra_-&gt;set_pair(m3-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6514     nodes-&gt;push(m3);
 6515   %}
 6516 %}
 6517 
 6518 // 0x1 is used in object initialization (initial object header).
 6519 // No constant pool entries required.
 6520 instruct loadConP0or1(iRegPdst dst, immP_0or1 src) %{
 6521   match(Set dst src);
 6522 
 6523   format %{ &quot;LI      $dst, $src \t// ptr&quot; %}
 6524   size(4);
 6525   ins_encode %{
 6526     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6527     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
 6528   %}
 6529   ins_pipe(pipe_class_default);
 6530 %}
 6531 
 6532 // Expand node for constant pool load: small offset.
 6533 // The match rule is needed to generate the correct bottom_type(),
 6534 // however this node should never match. The use of predicate is not
 6535 // possible since ADLC forbids predicates for chain rules. The higher
 6536 // costs do not prevent matching in this case. For that reason the
 6537 // operand immP_NM with predicate(false) is used.
 6538 instruct loadConP(iRegPdst dst, immP_NM src, iRegLdst toc) %{
 6539   match(Set dst src);
 6540   effect(TEMP toc);
 6541 
 6542   ins_num_consts(1);
 6543 
 6544   format %{ &quot;LD      $dst, offset, $toc \t// load ptr $src from TOC&quot; %}
 6545   size(4);
 6546   ins_encode( enc_load_long_constP(dst, src, toc) );
 6547   ins_pipe(pipe_class_memory);
 6548 %}
 6549 
 6550 // Expand node for constant pool load: large offset.
 6551 instruct loadConP_hi(iRegPdst dst, immP_NM src, iRegLdst toc) %{
 6552   effect(DEF dst, USE src, USE toc);
 6553   predicate(false);
 6554 
 6555   ins_num_consts(1);
 6556   ins_field_const_toc_offset(int);
 6557 
 6558   format %{ &quot;ADDIS   $dst, $toc, offset \t// load ptr $src from TOC (hi)&quot; %}
 6559   size(4);
 6560   ins_encode( enc_load_long_constP_hi(dst, src, toc) );
 6561   ins_pipe(pipe_class_default);
 6562 %}
 6563 
 6564 // Expand node for constant pool load: large offset.
 6565 instruct loadConP_lo(iRegPdst dst, immP_NM src, iRegLdst base) %{
 6566   match(Set dst src);
 6567   effect(TEMP base);
 6568 
 6569   ins_field_const_toc_offset_hi_node(loadConP_hiNode*);
 6570 
 6571   format %{ &quot;LD      $dst, offset, $base \t// load ptr $src from TOC (lo)&quot; %}
 6572   size(4);
 6573   ins_encode %{
 6574     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
<a name="69" id="anc69"></a><span class="line-modified"> 6575     int offset = ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;</span>
 6576     __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
 6577   %}
 6578   ins_pipe(pipe_class_memory);
 6579 %}
 6580 
 6581 // Load pointer constant from constant table. Expand in case an
 6582 // offset &gt; 16 bit is needed.
 6583 // Adlc adds toc node MachConstantTableBase.
 6584 instruct loadConP_Ex(iRegPdst dst, immP src) %{
 6585   match(Set dst src);
 6586   ins_cost(MEMORY_REF_COST);
 6587 
 6588   // This rule does not use &quot;expand&quot; because then
 6589   // the result type is not known to be an Oop.  An ADLC
 6590   // enhancement will be needed to make that work - not worth it!
 6591 
 6592   // If this instruction rematerializes, it prolongs the live range
 6593   // of the toc node, causing illegal graphs.
 6594   // assert(edge_from_to(_reg_node[reg_lo],def)) fails in verify_good_schedule().
 6595   ins_cannot_rematerialize(true);
 6596 
 6597   format %{ &quot;LD    $dst, offset, $constanttablebase \t//  load ptr $src from table, postalloc expanded&quot; %}
 6598   postalloc_expand( postalloc_expand_load_ptr_constant(dst, src, constanttablebase) );
 6599 %}
 6600 
 6601 // Expand node for constant pool load: small offset.
 6602 instruct loadConF(regF dst, immF src, iRegLdst toc) %{
 6603   effect(DEF dst, USE src, USE toc);
 6604   ins_cost(MEMORY_REF_COST);
 6605 
 6606   ins_num_consts(1);
 6607 
 6608   format %{ &quot;LFS     $dst, offset, $toc \t// load float $src from TOC&quot; %}
 6609   size(4);
 6610   ins_encode %{
 6611     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
 6612     address float_address = __ float_constant($src$$constant);
 6613     if (float_address == NULL) {
 6614       ciEnv::current()-&gt;record_out_of_memory_failure();
 6615       return;
 6616     }
 6617     __ lfs($dst$$FloatRegister, __ offset_to_method_toc(float_address), $toc$$Register);
 6618   %}
 6619   ins_pipe(pipe_class_memory);
 6620 %}
 6621 
 6622 // Expand node for constant pool load: large offset.
 6623 instruct loadConFComp(regF dst, immF src, iRegLdst toc) %{
 6624   effect(DEF dst, USE src, USE toc);
 6625   ins_cost(MEMORY_REF_COST);
 6626 
 6627   ins_num_consts(1);
 6628 
 6629   format %{ &quot;ADDIS   $toc, $toc, offset_hi\n\t&quot;
 6630             &quot;LFS     $dst, offset_lo, $toc \t// load float $src from TOC (hi/lo)\n\t&quot;
 6631             &quot;ADDIS   $toc, $toc, -offset_hi&quot;%}
 6632   size(12);
 6633   ins_encode %{
 6634     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6635     FloatRegister Rdst    = $dst$$FloatRegister;
 6636     Register Rtoc         = $toc$$Register;
 6637     address float_address = __ float_constant($src$$constant);
 6638     if (float_address == NULL) {
 6639       ciEnv::current()-&gt;record_out_of_memory_failure();
 6640       return;
 6641     }
 6642     int offset            = __ offset_to_method_toc(float_address);
 6643     int hi = (offset + (1&lt;&lt;15))&gt;&gt;16;
 6644     int lo = offset - hi * (1&lt;&lt;16);
 6645 
 6646     __ addis(Rtoc, Rtoc, hi);
 6647     __ lfs(Rdst, lo, Rtoc);
 6648     __ addis(Rtoc, Rtoc, -hi);
 6649   %}
 6650   ins_pipe(pipe_class_memory);
 6651 %}
 6652 
 6653 // Adlc adds toc node MachConstantTableBase.
 6654 instruct loadConF_Ex(regF dst, immF src) %{
 6655   match(Set dst src);
 6656   ins_cost(MEMORY_REF_COST);
 6657 
 6658   // See loadConP.
 6659   ins_cannot_rematerialize(true);
 6660 
 6661   format %{ &quot;LFS     $dst, offset, $constanttablebase \t// load $src from table, postalloc expanded&quot; %}
 6662   postalloc_expand( postalloc_expand_load_float_constant(dst, src, constanttablebase) );
 6663 %}
 6664 
 6665 // Expand node for constant pool load: small offset.
 6666 instruct loadConD(regD dst, immD src, iRegLdst toc) %{
 6667   effect(DEF dst, USE src, USE toc);
 6668   ins_cost(MEMORY_REF_COST);
 6669 
 6670   ins_num_consts(1);
 6671 
 6672   format %{ &quot;LFD     $dst, offset, $toc \t// load double $src from TOC&quot; %}
 6673   size(4);
 6674   ins_encode %{
 6675     // TODO: PPC port $archOpcode(ppc64Opcode_lfd);
 6676     address float_address = __ double_constant($src$$constant);
 6677     if (float_address == NULL) {
 6678       ciEnv::current()-&gt;record_out_of_memory_failure();
 6679       return;
 6680     }
 6681     int offset =  __ offset_to_method_toc(float_address);
 6682     __ lfd($dst$$FloatRegister, offset, $toc$$Register);
 6683   %}
 6684   ins_pipe(pipe_class_memory);
 6685 %}
 6686 
 6687 // Expand node for constant pool load: large offset.
 6688 instruct loadConDComp(regD dst, immD src, iRegLdst toc) %{
 6689   effect(DEF dst, USE src, USE toc);
 6690   ins_cost(MEMORY_REF_COST);
 6691 
 6692   ins_num_consts(1);
 6693 
 6694   format %{ &quot;ADDIS   $toc, $toc, offset_hi\n\t&quot;
 6695             &quot;LFD     $dst, offset_lo, $toc \t// load double $src from TOC (hi/lo)\n\t&quot;
 6696             &quot;ADDIS   $toc, $toc, -offset_hi&quot; %}
 6697   size(12);
 6698   ins_encode %{
 6699     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6700     FloatRegister Rdst    = $dst$$FloatRegister;
 6701     Register      Rtoc    = $toc$$Register;
 6702     address float_address = __ double_constant($src$$constant);
 6703     if (float_address == NULL) {
 6704       ciEnv::current()-&gt;record_out_of_memory_failure();
 6705       return;
 6706     }
 6707     int offset = __ offset_to_method_toc(float_address);
 6708     int hi = (offset + (1&lt;&lt;15))&gt;&gt;16;
 6709     int lo = offset - hi * (1&lt;&lt;16);
 6710 
 6711     __ addis(Rtoc, Rtoc, hi);
 6712     __ lfd(Rdst, lo, Rtoc);
 6713     __ addis(Rtoc, Rtoc, -hi);
 6714   %}
 6715   ins_pipe(pipe_class_memory);
 6716 %}
 6717 
 6718 // Adlc adds toc node MachConstantTableBase.
 6719 instruct loadConD_Ex(regD dst, immD src) %{
 6720   match(Set dst src);
 6721   ins_cost(MEMORY_REF_COST);
 6722 
 6723   // See loadConP.
 6724   ins_cannot_rematerialize(true);
 6725 
 6726   format %{ &quot;ConD    $dst, offset, $constanttablebase \t// load $src from table, postalloc expanded&quot; %}
 6727   postalloc_expand( postalloc_expand_load_double_constant(dst, src, constanttablebase) );
 6728 %}
 6729 
 6730 // Prefetch instructions.
 6731 // Must be safe to execute with invalid address (cannot fault).
 6732 
 6733 // Special prefetch versions which use the dcbz instruction.
 6734 instruct prefetch_alloc_zero(indirectMemory mem, iRegLsrc src) %{
 6735   match(PrefetchAllocation (AddP mem src));
 6736   predicate(AllocatePrefetchStyle == 3);
 6737   ins_cost(MEMORY_REF_COST);
 6738 
 6739   format %{ &quot;PREFETCH $mem, 2, $src \t// Prefetch write-many with zero&quot; %}
 6740   size(4);
 6741   ins_encode %{
 6742     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6743     __ dcbz($src$$Register, $mem$$base$$Register);
 6744   %}
 6745   ins_pipe(pipe_class_memory);
 6746 %}
 6747 
 6748 instruct prefetch_alloc_zero_no_offset(indirectMemory mem) %{
 6749   match(PrefetchAllocation mem);
 6750   predicate(AllocatePrefetchStyle == 3);
 6751   ins_cost(MEMORY_REF_COST);
 6752 
 6753   format %{ &quot;PREFETCH $mem, 2 \t// Prefetch write-many with zero&quot; %}
 6754   size(4);
 6755   ins_encode %{
 6756     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6757     __ dcbz($mem$$base$$Register);
 6758   %}
 6759   ins_pipe(pipe_class_memory);
 6760 %}
 6761 
 6762 instruct prefetch_alloc(indirectMemory mem, iRegLsrc src) %{
 6763   match(PrefetchAllocation (AddP mem src));
 6764   predicate(AllocatePrefetchStyle != 3);
 6765   ins_cost(MEMORY_REF_COST);
 6766 
 6767   format %{ &quot;PREFETCH $mem, 2, $src \t// Prefetch write-many&quot; %}
 6768   size(4);
 6769   ins_encode %{
 6770     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6771     __ dcbtst($src$$Register, $mem$$base$$Register);
 6772   %}
 6773   ins_pipe(pipe_class_memory);
 6774 %}
 6775 
 6776 instruct prefetch_alloc_no_offset(indirectMemory mem) %{
 6777   match(PrefetchAllocation mem);
 6778   predicate(AllocatePrefetchStyle != 3);
 6779   ins_cost(MEMORY_REF_COST);
 6780 
 6781   format %{ &quot;PREFETCH $mem, 2 \t// Prefetch write-many&quot; %}
 6782   size(4);
 6783   ins_encode %{
 6784     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6785     __ dcbtst($mem$$base$$Register);
 6786   %}
 6787   ins_pipe(pipe_class_memory);
 6788 %}
 6789 
 6790 //----------Store Instructions-------------------------------------------------
 6791 
 6792 // Store Byte
 6793 instruct storeB(memory mem, iRegIsrc src) %{
 6794   match(Set mem (StoreB mem src));
 6795   ins_cost(MEMORY_REF_COST);
 6796 
 6797   format %{ &quot;STB     $src, $mem \t// byte&quot; %}
 6798   size(4);
 6799   ins_encode %{
 6800     // TODO: PPC port $archOpcode(ppc64Opcode_stb);
 6801     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6802     __ stb($src$$Register, Idisp, $mem$$base$$Register);
 6803   %}
 6804   ins_pipe(pipe_class_memory);
 6805 %}
 6806 
 6807 // Store Char/Short
 6808 instruct storeC(memory mem, iRegIsrc src) %{
 6809   match(Set mem (StoreC mem src));
 6810   ins_cost(MEMORY_REF_COST);
 6811 
 6812   format %{ &quot;STH     $src, $mem \t// short&quot; %}
 6813   size(4);
 6814   ins_encode %{
 6815     // TODO: PPC port $archOpcode(ppc64Opcode_sth);
 6816     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6817     __ sth($src$$Register, Idisp, $mem$$base$$Register);
 6818   %}
 6819   ins_pipe(pipe_class_memory);
 6820 %}
 6821 
 6822 // Store Integer
 6823 instruct storeI(memory mem, iRegIsrc src) %{
 6824   match(Set mem (StoreI mem src));
 6825   ins_cost(MEMORY_REF_COST);
 6826 
 6827   format %{ &quot;STW     $src, $mem&quot; %}
 6828   size(4);
 6829   ins_encode( enc_stw(src, mem) );
 6830   ins_pipe(pipe_class_memory);
 6831 %}
 6832 
 6833 // ConvL2I + StoreI.
 6834 instruct storeI_convL2I(memory mem, iRegLsrc src) %{
 6835   match(Set mem (StoreI mem (ConvL2I src)));
 6836   ins_cost(MEMORY_REF_COST);
 6837 
 6838   format %{ &quot;STW     l2i($src), $mem&quot; %}
 6839   size(4);
 6840   ins_encode( enc_stw(src, mem) );
 6841   ins_pipe(pipe_class_memory);
 6842 %}
 6843 
 6844 // Store Long
 6845 instruct storeL(memoryAlg4 mem, iRegLsrc src) %{
 6846   match(Set mem (StoreL mem src));
 6847   ins_cost(MEMORY_REF_COST);
 6848 
 6849   format %{ &quot;STD     $src, $mem \t// long&quot; %}
 6850   size(4);
 6851   ins_encode( enc_std(src, mem) );
 6852   ins_pipe(pipe_class_memory);
 6853 %}
 6854 
 6855 // Store super word nodes.
 6856 
 6857 // Store Aligned Packed Byte long register to memory
 6858 instruct storeA8B(memoryAlg4 mem, iRegLsrc src) %{
 6859   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
 6860   match(Set mem (StoreVector mem src));
 6861   ins_cost(MEMORY_REF_COST);
 6862 
 6863   format %{ &quot;STD     $mem, $src \t// packed8B&quot; %}
 6864   size(4);
 6865   ins_encode( enc_std(src, mem) );
 6866   ins_pipe(pipe_class_memory);
 6867 %}
 6868 
 6869 // Store Packed Byte long register to memory
 6870 instruct storeV16(indirect mem, vecX src) %{
 6871   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 16);
 6872   match(Set mem (StoreVector mem src));
 6873   ins_cost(MEMORY_REF_COST);
 6874 
 6875   format %{ &quot;STXVD2X     $mem, $src \t// store 16-byte Vector&quot; %}
 6876   size(4);
 6877   ins_encode %{
 6878     __ stxvd2x($src$$VectorSRegister, $mem$$Register);
 6879   %}
 6880   ins_pipe(pipe_class_default);
 6881 %}
 6882 
 6883 // Store Compressed Oop
 6884 instruct storeN(memory dst, iRegN_P2N src) %{
 6885   match(Set dst (StoreN dst src));
 6886   ins_cost(MEMORY_REF_COST);
 6887 
 6888   format %{ &quot;STW     $src, $dst \t// compressed oop&quot; %}
 6889   size(4);
 6890   ins_encode( enc_stw(src, dst) );
 6891   ins_pipe(pipe_class_memory);
 6892 %}
 6893 
 6894 // Store Compressed KLass
 6895 instruct storeNKlass(memory dst, iRegN_P2N src) %{
 6896   match(Set dst (StoreNKlass dst src));
 6897   ins_cost(MEMORY_REF_COST);
 6898 
 6899   format %{ &quot;STW     $src, $dst \t// compressed klass&quot; %}
 6900   size(4);
 6901   ins_encode( enc_stw(src, dst) );
 6902   ins_pipe(pipe_class_memory);
 6903 %}
 6904 
 6905 // Store Pointer
 6906 instruct storeP(memoryAlg4 dst, iRegPsrc src) %{
 6907   match(Set dst (StoreP dst src));
 6908   ins_cost(MEMORY_REF_COST);
 6909 
 6910   format %{ &quot;STD     $src, $dst \t// ptr&quot; %}
 6911   size(4);
 6912   ins_encode( enc_std(src, dst) );
 6913   ins_pipe(pipe_class_memory);
 6914 %}
 6915 
 6916 // Store Float
 6917 instruct storeF(memory mem, regF src) %{
 6918   match(Set mem (StoreF mem src));
 6919   ins_cost(MEMORY_REF_COST);
 6920 
 6921   format %{ &quot;STFS    $src, $mem&quot; %}
 6922   size(4);
 6923   ins_encode( enc_stfs(src, mem) );
 6924   ins_pipe(pipe_class_memory);
 6925 %}
 6926 
 6927 // Store Double
 6928 instruct storeD(memory mem, regD src) %{
 6929   match(Set mem (StoreD mem src));
 6930   ins_cost(MEMORY_REF_COST);
 6931 
 6932   format %{ &quot;STFD    $src, $mem&quot; %}
 6933   size(4);
 6934   ins_encode( enc_stfd(src, mem) );
 6935   ins_pipe(pipe_class_memory);
 6936 %}
 6937 
 6938 //----------Store Instructions With Zeros--------------------------------------
 6939 
 6940 // Card-mark for CMS garbage collection.
 6941 // This cardmark does an optimization so that it must not always
 6942 // do a releasing store. For this, it gets the address of
 6943 // CMSCollectorCardTableBarrierSetBSExt::_requires_release as input.
 6944 // (Using releaseFieldAddr in the match rule is a hack.)
 6945 instruct storeCM_CMS(memory mem, iRegLdst releaseFieldAddr, flagsReg crx) %{
 6946   match(Set mem (StoreCM mem releaseFieldAddr));
 6947   effect(TEMP crx);
 6948   predicate(false);
 6949   ins_cost(MEMORY_REF_COST);
 6950 
 6951   // See loadConP.
 6952   ins_cannot_rematerialize(true);
 6953 
 6954   format %{ &quot;STB     #0, $mem \t// CMS card-mark byte (must be 0!), checking requires_release in [$releaseFieldAddr]&quot; %}
 6955   ins_encode( enc_cms_card_mark(mem, releaseFieldAddr, crx) );
 6956   ins_pipe(pipe_class_memory);
 6957 %}
 6958 
 6959 instruct storeCM_G1(memory mem, immI_0 zero) %{
 6960   match(Set mem (StoreCM mem zero));
 6961   predicate(UseG1GC);
 6962   ins_cost(MEMORY_REF_COST);
 6963 
 6964   ins_cannot_rematerialize(true);
 6965 
 6966   format %{ &quot;STB     #0, $mem \t// CMS card-mark byte store (G1)&quot; %}
 6967   size(8);
 6968   ins_encode %{
 6969     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6970     __ li(R0, 0);
 6971     //__ release(); // G1: oops are allowed to get visible after dirty marking
 6972     guarantee($mem$$base$$Register != R1_SP, &quot;use frame_slots_bias&quot;);
 6973     __ stb(R0, $mem$$disp, $mem$$base$$Register);
 6974   %}
 6975   ins_pipe(pipe_class_memory);
 6976 %}
 6977 
 6978 // Convert oop pointer into compressed form.
 6979 
 6980 // Nodes for postalloc expand.
 6981 
 6982 // Shift node for expand.
 6983 instruct encodeP_shift(iRegNdst dst, iRegNsrc src) %{
 6984   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 6985   match(Set dst (EncodeP src));
 6986   predicate(false);
 6987 
 6988   format %{ &quot;SRDI    $dst, $src, 3 \t// encode&quot; %}
 6989   size(4);
 6990   ins_encode %{
 6991     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 6992     __ srdi($dst$$Register, $src$$Register, CompressedOops::shift() &amp; 0x3f);
 6993   %}
 6994   ins_pipe(pipe_class_default);
 6995 %}
 6996 
 6997 // Add node for expand.
 6998 instruct encodeP_sub(iRegPdst dst, iRegPdst src) %{
 6999   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7000   match(Set dst (EncodeP src));
 7001   predicate(false);
 7002 
 7003   format %{ &quot;SUB     $dst, $src, oop_base \t// encode&quot; %}
 7004   ins_encode %{
 7005     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7006     __ sub_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);
 7007   %}
 7008   ins_pipe(pipe_class_default);
 7009 %}
 7010 
 7011 // Conditional sub base.
 7012 instruct cond_sub_base(iRegNdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 7013   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7014   match(Set dst (EncodeP (Binary crx src1)));
 7015   predicate(false);
 7016 
 7017   format %{ &quot;BEQ     $crx, done\n\t&quot;
 7018             &quot;SUB     $dst, $src1, heapbase \t// encode: subtract base if != NULL\n&quot;
 7019             &quot;done:&quot; %}
 7020   ins_encode %{
 7021     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7022     Label done;
 7023     __ beq($crx$$CondRegister, done);
 7024     __ sub_const_optimized($dst$$Register, $src1$$Register, CompressedOops::base(), R0);
 7025     __ bind(done);
 7026   %}
 7027   ins_pipe(pipe_class_default);
 7028 %}
 7029 
 7030 // Power 7 can use isel instruction
 7031 instruct cond_set_0_oop(iRegNdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 7032   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7033   match(Set dst (EncodeP (Binary crx src1)));
 7034   predicate(false);
 7035 
 7036   format %{ &quot;CMOVE   $dst, $crx eq, 0, $src1 \t// encode: preserve 0&quot; %}
 7037   size(4);
 7038   ins_encode %{
 7039     // This is a Power7 instruction for which no machine description exists.
 7040     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7041     __ isel_0($dst$$Register, $crx$$CondRegister, Assembler::equal, $src1$$Register);
 7042   %}
 7043   ins_pipe(pipe_class_default);
 7044 %}
 7045 
 7046 // Disjoint narrow oop base.
 7047 instruct encodeP_Disjoint(iRegNdst dst, iRegPsrc src) %{
 7048   match(Set dst (EncodeP src));
 7049   predicate(CompressedOops::base_disjoint());
 7050 
 7051   format %{ &quot;EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base&quot; %}
 7052   size(4);
 7053   ins_encode %{
 7054     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7055     __ rldicl($dst$$Register, $src$$Register, 64-CompressedOops::shift(), 32);
 7056   %}
 7057   ins_pipe(pipe_class_default);
 7058 %}
 7059 
 7060 // shift != 0, base != 0
 7061 instruct encodeP_Ex(iRegNdst dst, flagsReg crx, iRegPsrc src) %{
 7062   match(Set dst (EncodeP src));
 7063   effect(TEMP crx);
 7064   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 7065             CompressedOops::shift() != 0 &amp;&amp;
 7066             CompressedOops::base_overlaps());
 7067 
 7068   format %{ &quot;EncodeP $dst, $crx, $src \t// postalloc expanded&quot; %}
 7069   postalloc_expand( postalloc_expand_encode_oop(dst, src, crx));
 7070 %}
 7071 
 7072 // shift != 0, base != 0
 7073 instruct encodeP_not_null_Ex(iRegNdst dst, iRegPsrc src) %{
 7074   match(Set dst (EncodeP src));
 7075   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull &amp;&amp;
 7076             CompressedOops::shift() != 0 &amp;&amp;
 7077             CompressedOops::base_overlaps());
 7078 
 7079   format %{ &quot;EncodeP $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7080   postalloc_expand( postalloc_expand_encode_oop_not_null(dst, src) );
 7081 %}
 7082 
 7083 // shift != 0, base == 0
 7084 // TODO: This is the same as encodeP_shift. Merge!
 7085 instruct encodeP_not_null_base_null(iRegNdst dst, iRegPsrc src) %{
 7086   match(Set dst (EncodeP src));
 7087   predicate(CompressedOops::shift() != 0 &amp;&amp;
 7088             CompressedOops::base() ==0);
 7089 
 7090   format %{ &quot;SRDI    $dst, $src, #3 \t// encodeP, $src != NULL&quot; %}
 7091   size(4);
 7092   ins_encode %{
 7093     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7094     __ srdi($dst$$Register, $src$$Register, CompressedOops::shift() &amp; 0x3f);
 7095   %}
 7096   ins_pipe(pipe_class_default);
 7097 %}
 7098 
 7099 // Compressed OOPs with narrow_oop_shift == 0.
 7100 // shift == 0, base == 0
 7101 instruct encodeP_narrow_oop_shift_0(iRegNdst dst, iRegPsrc src) %{
 7102   match(Set dst (EncodeP src));
 7103   predicate(CompressedOops::shift() == 0);
 7104 
 7105   format %{ &quot;MR      $dst, $src \t// Ptr-&gt;Narrow&quot; %}
 7106   // variable size, 0 or 4.
 7107   ins_encode %{
 7108     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7109     __ mr_if_needed($dst$$Register, $src$$Register);
 7110   %}
 7111   ins_pipe(pipe_class_default);
 7112 %}
 7113 
 7114 // Decode nodes.
 7115 
 7116 // Shift node for expand.
 7117 instruct decodeN_shift(iRegPdst dst, iRegPsrc src) %{
 7118   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7119   match(Set dst (DecodeN src));
 7120   predicate(false);
 7121 
 7122   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeN&quot; %}
 7123   size(4);
 7124   ins_encode %{
 7125     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 7126     __ sldi($dst$$Register, $src$$Register, CompressedOops::shift());
 7127   %}
 7128   ins_pipe(pipe_class_default);
 7129 %}
 7130 
 7131 // Add node for expand.
 7132 instruct decodeN_add(iRegPdst dst, iRegPdst src) %{
 7133   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7134   match(Set dst (DecodeN src));
 7135   predicate(false);
 7136 
 7137   format %{ &quot;ADD     $dst, $src, heapbase \t// DecodeN, add oop base&quot; %}
 7138   ins_encode %{
 7139     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7140     __ add_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);
 7141   %}
 7142   ins_pipe(pipe_class_default);
 7143 %}
 7144 
 7145 // conditianal add base for expand
 7146 instruct cond_add_base(iRegPdst dst, flagsRegSrc crx, iRegPsrc src) %{
 7147   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7148   // NOTICE that the rule is nonsense - we just have to make sure that:
 7149   //  - _matrule-&gt;_rChild-&gt;_opType == &quot;DecodeN&quot; (see InstructForm::captures_bottom_type() in formssel.cpp)
 7150   //  - we have to match &#39;crx&#39; to avoid an &quot;illegal USE of non-input: flagsReg crx&quot; error in ADLC.
 7151   match(Set dst (DecodeN (Binary crx src)));
 7152   predicate(false);
 7153 
 7154   format %{ &quot;BEQ     $crx, done\n\t&quot;
 7155             &quot;ADD     $dst, $src, heapbase \t// DecodeN: add oop base if $src != NULL\n&quot;
 7156             &quot;done:&quot; %}
 7157   ins_encode %{
 7158     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7159     Label done;
 7160     __ beq($crx$$CondRegister, done);
 7161     __ add_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);
 7162     __ bind(done);
 7163   %}
 7164   ins_pipe(pipe_class_default);
 7165 %}
 7166 
 7167 instruct cond_set_0_ptr(iRegPdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 7168   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7169   // NOTICE that the rule is nonsense - we just have to make sure that:
 7170   //  - _matrule-&gt;_rChild-&gt;_opType == &quot;DecodeN&quot; (see InstructForm::captures_bottom_type() in formssel.cpp)
 7171   //  - we have to match &#39;crx&#39; to avoid an &quot;illegal USE of non-input: flagsReg crx&quot; error in ADLC.
 7172   match(Set dst (DecodeN (Binary crx src1)));
 7173   predicate(false);
 7174 
 7175   format %{ &quot;CMOVE   $dst, $crx eq, 0, $src1 \t// decode: preserve 0&quot; %}
 7176   size(4);
 7177   ins_encode %{
 7178     // This is a Power7 instruction for which no machine description exists.
 7179     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7180     __ isel_0($dst$$Register, $crx$$CondRegister, Assembler::equal, $src1$$Register);
 7181   %}
 7182   ins_pipe(pipe_class_default);
 7183 %}
 7184 
 7185 //  shift != 0, base != 0
 7186 instruct decodeN_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
 7187   match(Set dst (DecodeN src));
 7188   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 7189              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
 7190             CompressedOops::shift() != 0 &amp;&amp;
 7191             CompressedOops::base() != 0);
 7192   ins_cost(4 * DEFAULT_COST); // Should be more expensive than decodeN_Disjoint_isel_Ex.
 7193   effect(TEMP crx);
 7194 
 7195   format %{ &quot;DecodeN $dst, $src \t// Kills $crx, postalloc expanded&quot; %}
 7196   postalloc_expand( postalloc_expand_decode_oop(dst, src, crx) );
 7197 %}
 7198 
 7199 // shift != 0, base == 0
 7200 instruct decodeN_nullBase(iRegPdst dst, iRegNsrc src) %{
 7201   match(Set dst (DecodeN src));
 7202   predicate(CompressedOops::shift() != 0 &amp;&amp;
 7203             CompressedOops::base() == 0);
 7204 
 7205   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeN (zerobased)&quot; %}
 7206   size(4);
 7207   ins_encode %{
 7208     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 7209     __ sldi($dst$$Register, $src$$Register, CompressedOops::shift());
 7210   %}
 7211   ins_pipe(pipe_class_default);
 7212 %}
 7213 
 7214 // Optimize DecodeN for disjoint base.
 7215 // Shift narrow oop and or it into register that already contains the heap base.
 7216 // Base == dst must hold, and is assured by construction in postaloc_expand.
 7217 instruct decodeN_mergeDisjoint(iRegPdst dst, iRegNsrc src, iRegLsrc base) %{
 7218   match(Set dst (DecodeN src));
 7219   effect(TEMP base);
 7220   predicate(false);
 7221 
 7222   format %{ &quot;RLDIMI  $dst, $src, shift, 32-shift \t// DecodeN (disjoint base)&quot; %}
 7223   size(4);
 7224   ins_encode %{
 7225     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
 7226     __ rldimi($dst$$Register, $src$$Register, CompressedOops::shift(), 32-CompressedOops::shift());
 7227   %}
 7228   ins_pipe(pipe_class_default);
 7229 %}
 7230 
 7231 // Optimize DecodeN for disjoint base.
 7232 // This node requires only one cycle on the critical path.
 7233 // We must postalloc_expand as we can not express use_def effects where
 7234 // the used register is L and the def&#39;ed register P.
 7235 instruct decodeN_Disjoint_notNull_Ex(iRegPdst dst, iRegNsrc src) %{
 7236   match(Set dst (DecodeN src));
 7237   effect(TEMP_DEF dst);
 7238   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
 7239              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 7240             CompressedOops::base_disjoint());
 7241   ins_cost(DEFAULT_COST);
 7242 
 7243   format %{ &quot;MOV     $dst, heapbase \t\n&quot;
 7244             &quot;RLDIMI  $dst, $src, shift, 32-shift \t// decode with disjoint base&quot; %}
 7245   postalloc_expand %{
 7246     loadBaseNode *n1 = new loadBaseNode();
 7247     n1-&gt;add_req(NULL);
 7248     n1-&gt;_opnds[0] = op_dst;
 7249 
 7250     decodeN_mergeDisjointNode *n2 = new decodeN_mergeDisjointNode();
 7251     n2-&gt;add_req(n_region, n_src, n1);
 7252     n2-&gt;_opnds[0] = op_dst;
 7253     n2-&gt;_opnds[1] = op_src;
 7254     n2-&gt;_opnds[2] = op_dst;
 7255     n2-&gt;_bottom_type = _bottom_type;
 7256 
 7257     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7258     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7259 
 7260     nodes-&gt;push(n1);
 7261     nodes-&gt;push(n2);
 7262   %}
 7263 %}
 7264 
 7265 instruct decodeN_Disjoint_isel_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
 7266   match(Set dst (DecodeN src));
 7267   effect(TEMP_DEF dst, TEMP crx);
 7268   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 7269              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
 7270             CompressedOops::base_disjoint() &amp;&amp; VM_Version::has_isel());
 7271   ins_cost(3 * DEFAULT_COST);
 7272 
 7273   format %{ &quot;DecodeN  $dst, $src \t// decode with disjoint base using isel&quot; %}
 7274   postalloc_expand %{
 7275     loadBaseNode *n1 = new loadBaseNode();
 7276     n1-&gt;add_req(NULL);
 7277     n1-&gt;_opnds[0] = op_dst;
 7278 
 7279     cmpN_reg_imm0Node *n_compare  = new cmpN_reg_imm0Node();
 7280     n_compare-&gt;add_req(n_region, n_src);
 7281     n_compare-&gt;_opnds[0] = op_crx;
 7282     n_compare-&gt;_opnds[1] = op_src;
 7283     n_compare-&gt;_opnds[2] = new immN_0Oper(TypeNarrowOop::NULL_PTR);
 7284 
 7285     decodeN_mergeDisjointNode *n2 = new decodeN_mergeDisjointNode();
 7286     n2-&gt;add_req(n_region, n_src, n1);
 7287     n2-&gt;_opnds[0] = op_dst;
 7288     n2-&gt;_opnds[1] = op_src;
 7289     n2-&gt;_opnds[2] = op_dst;
 7290     n2-&gt;_bottom_type = _bottom_type;
 7291 
 7292     cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();
 7293     n_cond_set-&gt;add_req(n_region, n_compare, n2);
 7294     n_cond_set-&gt;_opnds[0] = op_dst;
 7295     n_cond_set-&gt;_opnds[1] = op_crx;
 7296     n_cond_set-&gt;_opnds[2] = op_dst;
 7297     n_cond_set-&gt;_bottom_type = _bottom_type;
 7298 
 7299     assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 7300     ra_-&gt;set_oop(n_cond_set, true);
 7301 
 7302     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7303     ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 7304     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7305     ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7306 
 7307     nodes-&gt;push(n1);
 7308     nodes-&gt;push(n_compare);
 7309     nodes-&gt;push(n2);
 7310     nodes-&gt;push(n_cond_set);
 7311   %}
 7312 %}
 7313 
 7314 // src != 0, shift != 0, base != 0
 7315 instruct decodeN_notNull_addBase_Ex(iRegPdst dst, iRegNsrc src) %{
 7316   match(Set dst (DecodeN src));
 7317   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
 7318              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 7319             CompressedOops::shift() != 0 &amp;&amp;
 7320             CompressedOops::base() != 0);
 7321   ins_cost(2 * DEFAULT_COST);
 7322 
 7323   format %{ &quot;DecodeN $dst, $src \t// $src != NULL, postalloc expanded&quot; %}
 7324   postalloc_expand( postalloc_expand_decode_oop_not_null(dst, src));
 7325 %}
 7326 
 7327 // Compressed OOPs with narrow_oop_shift == 0.
 7328 instruct decodeN_unscaled(iRegPdst dst, iRegNsrc src) %{
 7329   match(Set dst (DecodeN src));
 7330   predicate(CompressedOops::shift() == 0);
 7331   ins_cost(DEFAULT_COST);
 7332 
 7333   format %{ &quot;MR      $dst, $src \t// DecodeN (unscaled)&quot; %}
 7334   // variable size, 0 or 4.
 7335   ins_encode %{
 7336     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7337     __ mr_if_needed($dst$$Register, $src$$Register);
 7338   %}
 7339   ins_pipe(pipe_class_default);
 7340 %}
 7341 
 7342 // Convert compressed oop into int for vectors alignment masking.
 7343 instruct decodeN2I_unscaled(iRegIdst dst, iRegNsrc src) %{
 7344   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 7345   predicate(CompressedOops::shift() == 0);
 7346   ins_cost(DEFAULT_COST);
 7347 
 7348   format %{ &quot;MR      $dst, $src \t// (int)DecodeN (unscaled)&quot; %}
 7349   // variable size, 0 or 4.
 7350   ins_encode %{
 7351     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7352     __ mr_if_needed($dst$$Register, $src$$Register);
 7353   %}
 7354   ins_pipe(pipe_class_default);
 7355 %}
 7356 
 7357 // Convert klass pointer into compressed form.
 7358 
 7359 // Nodes for postalloc expand.
 7360 
 7361 // Shift node for expand.
 7362 instruct encodePKlass_shift(iRegNdst dst, iRegNsrc src) %{
 7363   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7364   match(Set dst (EncodePKlass src));
 7365   predicate(false);
 7366 
 7367   format %{ &quot;SRDI    $dst, $src, 3 \t// encode&quot; %}
 7368   size(4);
 7369   ins_encode %{
 7370     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7371     __ srdi($dst$$Register, $src$$Register, CompressedKlassPointers::shift());
 7372   %}
 7373   ins_pipe(pipe_class_default);
 7374 %}
 7375 
 7376 // Add node for expand.
 7377 instruct encodePKlass_sub_base(iRegPdst dst, iRegLsrc base, iRegPdst src) %{
 7378   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7379   match(Set dst (EncodePKlass (Binary base src)));
 7380   predicate(false);
 7381 
 7382   format %{ &quot;SUB     $dst, $base, $src \t// encode&quot; %}
 7383   size(4);
 7384   ins_encode %{
 7385     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 7386     __ subf($dst$$Register, $base$$Register, $src$$Register);
 7387   %}
 7388   ins_pipe(pipe_class_default);
 7389 %}
 7390 
 7391 // Disjoint narrow oop base.
 7392 instruct encodePKlass_Disjoint(iRegNdst dst, iRegPsrc src) %{
 7393   match(Set dst (EncodePKlass src));
 7394   predicate(false /* TODO: PPC port CompressedKlassPointers::base_disjoint()*/);
 7395 
 7396   format %{ &quot;EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base&quot; %}
 7397   size(4);
 7398   ins_encode %{
 7399     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7400     __ rldicl($dst$$Register, $src$$Register, 64-CompressedKlassPointers::shift(), 32);
 7401   %}
 7402   ins_pipe(pipe_class_default);
 7403 %}
 7404 
 7405 // shift != 0, base != 0
 7406 instruct encodePKlass_not_null_Ex(iRegNdst dst, iRegLsrc base, iRegPsrc src) %{
 7407   match(Set dst (EncodePKlass (Binary base src)));
 7408   predicate(false);
 7409 
 7410   format %{ &quot;EncodePKlass $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7411   postalloc_expand %{
 7412     encodePKlass_sub_baseNode *n1 = new encodePKlass_sub_baseNode();
 7413     n1-&gt;add_req(n_region, n_base, n_src);
 7414     n1-&gt;_opnds[0] = op_dst;
 7415     n1-&gt;_opnds[1] = op_base;
 7416     n1-&gt;_opnds[2] = op_src;
 7417     n1-&gt;_bottom_type = _bottom_type;
 7418 
 7419     encodePKlass_shiftNode *n2 = new encodePKlass_shiftNode();
 7420     n2-&gt;add_req(n_region, n1);
 7421     n2-&gt;_opnds[0] = op_dst;
 7422     n2-&gt;_opnds[1] = op_dst;
 7423     n2-&gt;_bottom_type = _bottom_type;
 7424     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7425     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7426 
 7427     nodes-&gt;push(n1);
 7428     nodes-&gt;push(n2);
 7429   %}
 7430 %}
 7431 
 7432 // shift != 0, base != 0
 7433 instruct encodePKlass_not_null_ExEx(iRegNdst dst, iRegPsrc src) %{
 7434   match(Set dst (EncodePKlass src));
 7435   //predicate(CompressedKlassPointers::shift() != 0 &amp;&amp;
 7436   //          true /* TODO: PPC port CompressedKlassPointers::base_overlaps()*/);
 7437 
 7438   //format %{ &quot;EncodePKlass $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7439   ins_cost(DEFAULT_COST*2);  // Don&#39;t count constant.
 7440   expand %{
 7441     immL baseImm %{ (jlong)(intptr_t)CompressedKlassPointers::base() %}
 7442     iRegLdst base;
 7443     loadConL_Ex(base, baseImm);
 7444     encodePKlass_not_null_Ex(dst, base, src);
 7445   %}
 7446 %}
 7447 
 7448 // Decode nodes.
 7449 
 7450 // Shift node for expand.
 7451 instruct decodeNKlass_shift(iRegPdst dst, iRegPsrc src) %{
 7452   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7453   match(Set dst (DecodeNKlass src));
 7454   predicate(false);
 7455 
 7456   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeNKlass&quot; %}
 7457   size(4);
 7458   ins_encode %{
 7459     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 7460     __ sldi($dst$$Register, $src$$Register, CompressedKlassPointers::shift());
 7461   %}
 7462   ins_pipe(pipe_class_default);
 7463 %}
 7464 
 7465 // Add node for expand.
 7466 
 7467 instruct decodeNKlass_add_base(iRegPdst dst, iRegLsrc base, iRegPdst src) %{
 7468   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7469   match(Set dst (DecodeNKlass (Binary base src)));
 7470   predicate(false);
 7471 
 7472   format %{ &quot;ADD     $dst, $base, $src \t// DecodeNKlass, add klass base&quot; %}
 7473   size(4);
 7474   ins_encode %{
 7475     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 7476     __ add($dst$$Register, $base$$Register, $src$$Register);
 7477   %}
 7478   ins_pipe(pipe_class_default);
 7479 %}
 7480 
 7481 // src != 0, shift != 0, base != 0
 7482 instruct decodeNKlass_notNull_addBase_Ex(iRegPdst dst, iRegLsrc base, iRegNsrc src) %{
 7483   match(Set dst (DecodeNKlass (Binary base src)));
 7484   //effect(kill src); // We need a register for the immediate result after shifting.
 7485   predicate(false);
 7486 
 7487   format %{ &quot;DecodeNKlass $dst =  $base + ($src &lt;&lt; 3) \t// $src != NULL, postalloc expanded&quot; %}
 7488   postalloc_expand %{
 7489     decodeNKlass_add_baseNode *n1 = new decodeNKlass_add_baseNode();
 7490     n1-&gt;add_req(n_region, n_base, n_src);
 7491     n1-&gt;_opnds[0] = op_dst;
 7492     n1-&gt;_opnds[1] = op_base;
 7493     n1-&gt;_opnds[2] = op_src;
 7494     n1-&gt;_bottom_type = _bottom_type;
 7495 
 7496     decodeNKlass_shiftNode *n2 = new decodeNKlass_shiftNode();
 7497     n2-&gt;add_req(n_region, n1);
 7498     n2-&gt;_opnds[0] = op_dst;
 7499     n2-&gt;_opnds[1] = op_dst;
 7500     n2-&gt;_bottom_type = _bottom_type;
 7501 
 7502     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7503     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7504 
 7505     nodes-&gt;push(n1);
 7506     nodes-&gt;push(n2);
 7507   %}
 7508 %}
 7509 
 7510 // src != 0, shift != 0, base != 0
 7511 instruct decodeNKlass_notNull_addBase_ExEx(iRegPdst dst, iRegNsrc src) %{
 7512   match(Set dst (DecodeNKlass src));
 7513   // predicate(CompressedKlassPointers::shift() != 0 &amp;&amp;
 7514   //           CompressedKlassPointers::base() != 0);
 7515 
 7516   //format %{ &quot;DecodeNKlass $dst, $src \t// $src != NULL, expanded&quot; %}
 7517 
 7518   ins_cost(DEFAULT_COST*2);  // Don&#39;t count constant.
 7519   expand %{
 7520     // We add first, then we shift. Like this, we can get along with one register less.
 7521     // But we have to load the base pre-shifted.
 7522     immL baseImm %{ (jlong)((intptr_t)CompressedKlassPointers::base() &gt;&gt; CompressedKlassPointers::shift()) %}
 7523     iRegLdst base;
 7524     loadConL_Ex(base, baseImm);
 7525     decodeNKlass_notNull_addBase_Ex(dst, base, src);
 7526   %}
 7527 %}
 7528 
 7529 //----------MemBar Instructions-----------------------------------------------
 7530 // Memory barrier flavors
 7531 
 7532 instruct membar_acquire() %{
 7533   match(LoadFence);
 7534   ins_cost(4*MEMORY_REF_COST);
 7535 
 7536   format %{ &quot;MEMBAR-acquire&quot; %}
 7537   size(4);
 7538   ins_encode %{
 7539     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
 7540     __ acquire();
 7541   %}
 7542   ins_pipe(pipe_class_default);
 7543 %}
 7544 
 7545 instruct unnecessary_membar_acquire() %{
 7546   match(MemBarAcquire);
 7547   ins_cost(0);
 7548 
 7549   format %{ &quot; -- \t// redundant MEMBAR-acquire - empty&quot; %}
 7550   size(0);
 7551   ins_encode( /*empty*/ );
 7552   ins_pipe(pipe_class_default);
 7553 %}
 7554 
 7555 instruct membar_acquire_lock() %{
 7556   match(MemBarAcquireLock);
 7557   ins_cost(0);
 7558 
 7559   format %{ &quot; -- \t// redundant MEMBAR-acquire - empty (acquire as part of CAS in prior FastLock)&quot; %}
 7560   size(0);
 7561   ins_encode( /*empty*/ );
 7562   ins_pipe(pipe_class_default);
 7563 %}
 7564 
 7565 instruct membar_release() %{
 7566   match(MemBarRelease);
 7567   match(StoreFence);
 7568   ins_cost(4*MEMORY_REF_COST);
 7569 
 7570   format %{ &quot;MEMBAR-release&quot; %}
 7571   size(4);
 7572   ins_encode %{
 7573     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
 7574     __ release();
 7575   %}
 7576   ins_pipe(pipe_class_default);
 7577 %}
 7578 
 7579 instruct membar_storestore() %{
 7580   match(MemBarStoreStore);
 7581   ins_cost(4*MEMORY_REF_COST);
 7582 
 7583   format %{ &quot;MEMBAR-store-store&quot; %}
 7584   size(4);
 7585   ins_encode %{
 7586     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
 7587     __ membar(Assembler::StoreStore);
 7588   %}
 7589   ins_pipe(pipe_class_default);
 7590 %}
 7591 
 7592 instruct membar_release_lock() %{
 7593   match(MemBarReleaseLock);
 7594   ins_cost(0);
 7595 
 7596   format %{ &quot; -- \t// redundant MEMBAR-release - empty (release in FastUnlock)&quot; %}
 7597   size(0);
 7598   ins_encode( /*empty*/ );
 7599   ins_pipe(pipe_class_default);
 7600 %}
 7601 
 7602 instruct membar_volatile() %{
 7603   match(MemBarVolatile);
 7604   ins_cost(4*MEMORY_REF_COST);
 7605 
 7606   format %{ &quot;MEMBAR-volatile&quot; %}
 7607   size(4);
 7608   ins_encode %{
 7609     // TODO: PPC port $archOpcode(ppc64Opcode_sync);
 7610     __ fence();
 7611   %}
 7612   ins_pipe(pipe_class_default);
 7613 %}
 7614 
 7615 // This optimization is wrong on PPC. The following pattern is not supported:
 7616 //  MemBarVolatile
 7617 //   ^        ^
 7618 //   |        |
 7619 //  CtrlProj MemProj
 7620 //   ^        ^
 7621 //   |        |
 7622 //   |       Load
 7623 //   |
 7624 //  MemBarVolatile
 7625 //
 7626 //  The first MemBarVolatile could get optimized out! According to
 7627 //  Vladimir, this pattern can not occur on Oracle platforms.
 7628 //  However, it does occur on PPC64 (because of membars in
 7629 //  inline_unsafe_load_store).
 7630 //
 7631 // Add this node again if we found a good solution for inline_unsafe_load_store().
 7632 // Don&#39;t forget to look at the implementation of post_store_load_barrier again,
 7633 // we did other fixes in that method.
 7634 //instruct unnecessary_membar_volatile() %{
 7635 //  match(MemBarVolatile);
 7636 //  predicate(Matcher::post_store_load_barrier(n));
 7637 //  ins_cost(0);
 7638 //
 7639 //  format %{ &quot; -- \t// redundant MEMBAR-volatile - empty&quot; %}
 7640 //  size(0);
 7641 //  ins_encode( /*empty*/ );
 7642 //  ins_pipe(pipe_class_default);
 7643 //%}
 7644 
 7645 instruct membar_CPUOrder() %{
 7646   match(MemBarCPUOrder);
 7647   ins_cost(0);
 7648 
 7649   format %{ &quot; -- \t// MEMBAR-CPUOrder - empty: PPC64 processors are self-consistent.&quot; %}
 7650   size(0);
 7651   ins_encode( /*empty*/ );
 7652   ins_pipe(pipe_class_default);
 7653 %}
 7654 
 7655 //----------Conditional Move---------------------------------------------------
 7656 
 7657 // Cmove using isel.
 7658 instruct cmovI_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, iRegIsrc src) %{
 7659   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
 7660   predicate(VM_Version::has_isel());
 7661   ins_cost(DEFAULT_COST);
 7662 
 7663   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7664   size(4);
 7665   ins_encode %{
 7666     // This is a Power7 instruction for which no machine description
 7667     // exists. Anyways, the scheduler should be off on Power7.
 7668     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7669     int cc        = $cmp$$cmpcode;
 7670     __ isel($dst$$Register, $crx$$CondRegister,
 7671             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7672   %}
 7673   ins_pipe(pipe_class_default);
 7674 %}
 7675 
 7676 instruct cmovI_reg(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, iRegIsrc src) %{
 7677   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
 7678   predicate(!VM_Version::has_isel());
 7679   ins_cost(DEFAULT_COST+BRANCH_COST);
 7680 
 7681   ins_variable_size_depending_on_alignment(true);
 7682 
 7683   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7684   // Worst case is branch + move + stop, no stop without scheduler
 7685   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7686   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7687   ins_pipe(pipe_class_default);
 7688 %}
 7689 
 7690 instruct cmovI_imm(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, immI16 src) %{
 7691   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
 7692   ins_cost(DEFAULT_COST+BRANCH_COST);
 7693 
 7694   ins_variable_size_depending_on_alignment(true);
 7695 
 7696   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7697   // Worst case is branch + move + stop, no stop without scheduler
 7698   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7699   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7700   ins_pipe(pipe_class_default);
 7701 %}
 7702 
 7703 // Cmove using isel.
 7704 instruct cmovL_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, iRegLsrc src) %{
 7705   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
 7706   predicate(VM_Version::has_isel());
 7707   ins_cost(DEFAULT_COST);
 7708 
 7709   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7710   size(4);
 7711   ins_encode %{
 7712     // This is a Power7 instruction for which no machine description
 7713     // exists. Anyways, the scheduler should be off on Power7.
 7714     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7715     int cc        = $cmp$$cmpcode;
 7716     __ isel($dst$$Register, $crx$$CondRegister,
 7717             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7718   %}
 7719   ins_pipe(pipe_class_default);
 7720 %}
 7721 
 7722 instruct cmovL_reg(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, iRegLsrc src) %{
 7723   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
 7724   predicate(!VM_Version::has_isel());
 7725   ins_cost(DEFAULT_COST+BRANCH_COST);
 7726 
 7727   ins_variable_size_depending_on_alignment(true);
 7728 
 7729   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7730   // Worst case is branch + move + stop, no stop without scheduler.
 7731   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7732   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7733   ins_pipe(pipe_class_default);
 7734 %}
 7735 
 7736 instruct cmovL_imm(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, immL16 src) %{
 7737   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
 7738   ins_cost(DEFAULT_COST+BRANCH_COST);
 7739 
 7740   ins_variable_size_depending_on_alignment(true);
 7741 
 7742   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7743   // Worst case is branch + move + stop, no stop without scheduler.
 7744   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7745   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7746   ins_pipe(pipe_class_default);
 7747 %}
 7748 
 7749 // Cmove using isel.
 7750 instruct cmovN_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, iRegNsrc src) %{
 7751   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
 7752   predicate(VM_Version::has_isel());
 7753   ins_cost(DEFAULT_COST);
 7754 
 7755   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7756   size(4);
 7757   ins_encode %{
 7758     // This is a Power7 instruction for which no machine description
 7759     // exists. Anyways, the scheduler should be off on Power7.
 7760     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7761     int cc        = $cmp$$cmpcode;
 7762     __ isel($dst$$Register, $crx$$CondRegister,
 7763             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7764   %}
 7765   ins_pipe(pipe_class_default);
 7766 %}
 7767 
 7768 // Conditional move for RegN. Only cmov(reg, reg).
 7769 instruct cmovN_reg(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, iRegNsrc src) %{
 7770   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
 7771   predicate(!VM_Version::has_isel());
 7772   ins_cost(DEFAULT_COST+BRANCH_COST);
 7773 
 7774   ins_variable_size_depending_on_alignment(true);
 7775 
 7776   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7777   // Worst case is branch + move + stop, no stop without scheduler.
 7778   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7779   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7780   ins_pipe(pipe_class_default);
 7781 %}
 7782 
 7783 instruct cmovN_imm(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, immN_0 src) %{
 7784   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
 7785   ins_cost(DEFAULT_COST+BRANCH_COST);
 7786 
 7787   ins_variable_size_depending_on_alignment(true);
 7788 
 7789   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7790   // Worst case is branch + move + stop, no stop without scheduler.
 7791   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7792   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7793   ins_pipe(pipe_class_default);
 7794 %}
 7795 
 7796 // Cmove using isel.
 7797 instruct cmovP_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, iRegPsrc src) %{
 7798   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
 7799   predicate(VM_Version::has_isel());
 7800   ins_cost(DEFAULT_COST);
 7801 
 7802   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7803   size(4);
 7804   ins_encode %{
 7805     // This is a Power7 instruction for which no machine description
 7806     // exists. Anyways, the scheduler should be off on Power7.
 7807     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7808     int cc        = $cmp$$cmpcode;
 7809     __ isel($dst$$Register, $crx$$CondRegister,
 7810             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7811   %}
 7812   ins_pipe(pipe_class_default);
 7813 %}
 7814 
 7815 instruct cmovP_reg(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, iRegP_N2P src) %{
 7816   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
 7817   predicate(!VM_Version::has_isel());
 7818   ins_cost(DEFAULT_COST+BRANCH_COST);
 7819 
 7820   ins_variable_size_depending_on_alignment(true);
 7821 
 7822   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7823   // Worst case is branch + move + stop, no stop without scheduler.
 7824   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7825   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7826   ins_pipe(pipe_class_default);
 7827 %}
 7828 
 7829 instruct cmovP_imm(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, immP_0 src) %{
 7830   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
 7831   ins_cost(DEFAULT_COST+BRANCH_COST);
 7832 
 7833   ins_variable_size_depending_on_alignment(true);
 7834 
 7835   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7836   // Worst case is branch + move + stop, no stop without scheduler.
 7837   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7838   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7839   ins_pipe(pipe_class_default);
 7840 %}
 7841 
 7842 instruct cmovF_reg(cmpOp cmp, flagsRegSrc crx, regF dst, regF src) %{
 7843   match(Set dst (CMoveF (Binary cmp crx) (Binary dst src)));
 7844   ins_cost(DEFAULT_COST+BRANCH_COST);
 7845 
 7846   ins_variable_size_depending_on_alignment(true);
 7847 
 7848   format %{ &quot;CMOVEF  $cmp, $crx, $dst, $src\n\t&quot; %}
 7849   // Worst case is branch + move + stop, no stop without scheduler.
 7850   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 7851   ins_encode %{
 7852     // TODO: PPC port $archOpcode(ppc64Opcode_cmovef);
 7853     Label done;
 7854     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 7855     // Branch if not (cmp crx).
 7856     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
 7857     __ fmr($dst$$FloatRegister, $src$$FloatRegister);
 7858     // TODO PPC port __ endgroup_if_needed(_size == 12);
 7859     __ bind(done);
 7860   %}
 7861   ins_pipe(pipe_class_default);
 7862 %}
 7863 
 7864 instruct cmovD_reg(cmpOp cmp, flagsRegSrc crx, regD dst, regD src) %{
 7865   match(Set dst (CMoveD (Binary cmp crx) (Binary dst src)));
 7866   ins_cost(DEFAULT_COST+BRANCH_COST);
 7867 
 7868   ins_variable_size_depending_on_alignment(true);
 7869 
 7870   format %{ &quot;CMOVEF  $cmp, $crx, $dst, $src\n\t&quot; %}
 7871   // Worst case is branch + move + stop, no stop without scheduler.
 7872   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 7873   ins_encode %{
 7874     // TODO: PPC port $archOpcode(ppc64Opcode_cmovef);
 7875     Label done;
 7876     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 7877     // Branch if not (cmp crx).
 7878     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
 7879     __ fmr($dst$$FloatRegister, $src$$FloatRegister);
 7880     // TODO PPC port __ endgroup_if_needed(_size == 12);
 7881     __ bind(done);
 7882   %}
 7883   ins_pipe(pipe_class_default);
 7884 %}
 7885 
 7886 //----------Conditional_store--------------------------------------------------
 7887 // Conditional-store of the updated heap-top.
 7888 // Used during allocation of the shared heap.
 7889 // Sets flags (EQ) on success. Implemented with a CASA on Sparc.
 7890 
 7891 // As compareAndSwapL, but return flag register instead of boolean value in
 7892 // int register.
 7893 // Used by sun/misc/AtomicLongCSImpl.java.
 7894 // Mem_ptr must be a memory operand, else this node does not get
 7895 // Flag_needs_anti_dependence_check set by adlc. If this is not set this node
 7896 // can be rematerialized which leads to errors.
 7897 instruct storeLConditional_regP_regL_regL(flagsReg crx, indirect mem_ptr, iRegLsrc oldVal, iRegLsrc newVal, flagsRegCR0 cr0) %{
 7898   match(Set crx (StoreLConditional mem_ptr (Binary oldVal newVal)));
 7899   effect(TEMP cr0);
 7900   format %{ &quot;CMPXCHGD if ($crx = ($oldVal == *$mem_ptr)) *mem_ptr = $newVal; as bool&quot; %}
 7901   ins_encode %{
 7902     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7903     __ cmpxchgd($crx$$CondRegister, R0, $oldVal$$Register, $newVal$$Register, $mem_ptr$$Register,
 7904                 MacroAssembler::MemBarAcq, MacroAssembler::cmpxchgx_hint_atomic_update(),
 7905                 noreg, NULL, true);
 7906   %}
 7907   ins_pipe(pipe_class_default);
 7908 %}
 7909 
 7910 // As compareAndSwapP, but return flag register instead of boolean value in
 7911 // int register.
 7912 // This instruction is matched if UseTLAB is off.
 7913 // Mem_ptr must be a memory operand, else this node does not get
 7914 // Flag_needs_anti_dependence_check set by adlc. If this is not set this node
 7915 // can be rematerialized which leads to errors.
 7916 instruct storePConditional_regP_regP_regP(flagsRegCR0 cr0, indirect mem_ptr, iRegPsrc oldVal, iRegPsrc newVal) %{
 7917   match(Set cr0 (StorePConditional mem_ptr (Binary oldVal newVal)));
 7918   ins_cost(2*MEMORY_REF_COST);
 7919 
 7920   format %{ &quot;STDCX_  if ($cr0 = ($oldVal == *$mem_ptr)) *mem_ptr = $newVal; as bool&quot; %}
 7921   ins_encode %{
 7922     // TODO: PPC port $archOpcode(ppc64Opcode_stdcx_);
 7923     __ stdcx_($newVal$$Register, $mem_ptr$$Register);
 7924   %}
 7925   ins_pipe(pipe_class_memory);
 7926 %}
 7927 
 7928 // Implement LoadPLocked. Must be ordered against changes of the memory location
 7929 // by storePConditional.
 7930 // Don&#39;t know whether this is ever used.
 7931 instruct loadPLocked(iRegPdst dst, memory mem) %{
 7932   match(Set dst (LoadPLocked mem));
 7933   ins_cost(2*MEMORY_REF_COST);
 7934 
 7935   format %{ &quot;LDARX   $dst, $mem \t// loadPLocked\n\t&quot; %}
 7936   size(4);
 7937   ins_encode %{
 7938     // TODO: PPC port $archOpcode(ppc64Opcode_ldarx);
 7939     __ ldarx($dst$$Register, $mem$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 7940   %}
 7941   ins_pipe(pipe_class_memory);
 7942 %}
 7943 
 7944 //----------Compare-And-Swap---------------------------------------------------
 7945 
 7946 // CompareAndSwap{P,I,L} have more than one output, therefore &quot;CmpI
 7947 // (CompareAndSwap ...)&quot; or &quot;If (CmpI (CompareAndSwap ..))&quot;  cannot be
 7948 // matched.
 7949 
 7950 // Strong versions:
 7951 
 7952 instruct compareAndSwapB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 7953   match(Set res (CompareAndSwapB mem_ptr (Binary src1 src2)));
 7954   predicate(VM_Version::has_lqarx());
 7955   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 7956   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 7957   ins_encode %{
 7958     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7959     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 7960     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 7961                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 7962                 $res$$Register, true);
 7963     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 7964       __ isync();
 7965     } else {
 7966       __ sync();
 7967     }
 7968   %}
 7969   ins_pipe(pipe_class_default);
 7970 %}
 7971 
 7972 instruct compareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 7973   match(Set res (CompareAndSwapB mem_ptr (Binary src1 src2)));
 7974   predicate(!VM_Version::has_lqarx());
 7975   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 7976   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 7977   ins_encode %{
 7978     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7979     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 7980     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 7981                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 7982                 $res$$Register, true);
 7983     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 7984       __ isync();
 7985     } else {
 7986       __ sync();
 7987     }
 7988   %}
 7989   ins_pipe(pipe_class_default);
 7990 %}
 7991 
 7992 instruct compareAndSwapS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 7993   match(Set res (CompareAndSwapS mem_ptr (Binary src1 src2)));
 7994   predicate(VM_Version::has_lqarx());
 7995   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 7996   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 7997   ins_encode %{
 7998     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7999     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8000     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8001                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8002                 $res$$Register, true);
 8003     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8004       __ isync();
 8005     } else {
 8006       __ sync();
 8007     }
 8008   %}
 8009   ins_pipe(pipe_class_default);
 8010 %}
 8011 
 8012 instruct compareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8013   match(Set res (CompareAndSwapS mem_ptr (Binary src1 src2)));
 8014   predicate(!VM_Version::has_lqarx());
 8015   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8016   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8017   ins_encode %{
 8018     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8019     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8020     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8021                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8022                 $res$$Register, true);
 8023     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8024       __ isync();
 8025     } else {
 8026       __ sync();
 8027     }
 8028   %}
 8029   ins_pipe(pipe_class_default);
 8030 %}
 8031 
 8032 instruct compareAndSwapI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8033   match(Set res (CompareAndSwapI mem_ptr (Binary src1 src2)));
 8034   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8035   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8036   ins_encode %{
 8037     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8038     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8039     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8040                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8041                 $res$$Register, true);
 8042     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8043       __ isync();
 8044     } else {
 8045       __ sync();
 8046     }
 8047   %}
 8048   ins_pipe(pipe_class_default);
 8049 %}
 8050 
 8051 instruct compareAndSwapN_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8052   match(Set res (CompareAndSwapN mem_ptr (Binary src1 src2)));
 8053   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8054   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8055   ins_encode %{
 8056     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8057     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8058     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8059                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8060                 $res$$Register, true);
 8061     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8062       __ isync();
 8063     } else {
 8064       __ sync();
 8065     }
 8066   %}
 8067   ins_pipe(pipe_class_default);
 8068 %}
 8069 
 8070 instruct compareAndSwapL_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8071   match(Set res (CompareAndSwapL mem_ptr (Binary src1 src2)));
 8072   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8073   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8074   ins_encode %{
 8075     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8076     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8077     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8078                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8079                 $res$$Register, NULL, true);
 8080     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8081       __ isync();
 8082     } else {
 8083       __ sync();
 8084     }
 8085   %}
 8086   ins_pipe(pipe_class_default);
 8087 %}
 8088 
 8089 instruct compareAndSwapP_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8090   match(Set res (CompareAndSwapP mem_ptr (Binary src1 src2)));
 8091   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8092   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool; ptr&quot; %}
 8093   ins_encode %{
 8094     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8095     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8096     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8097                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8098                 $res$$Register, NULL, true);
 8099     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8100       __ isync();
 8101     } else {
 8102       __ sync();
 8103     }
 8104   %}
 8105   ins_pipe(pipe_class_default);
 8106 %}
 8107 
 8108 // Weak versions:
 8109 
 8110 instruct weakCompareAndSwapB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8111   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8112   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8113   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8114   format %{ &quot;weak CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8115   ins_encode %{
 8116     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8117     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8118     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8119                 MacroAssembler::MemBarNone,
 8120                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8121   %}
 8122   ins_pipe(pipe_class_default);
 8123 %}
 8124 
 8125 instruct weakCompareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8126   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8127   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8128   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8129   format %{ &quot;weak CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8130   ins_encode %{
 8131     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8132     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8133     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8134                 MacroAssembler::MemBarNone,
 8135                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8136   %}
 8137   ins_pipe(pipe_class_default);
 8138 %}
 8139 
 8140 instruct weakCompareAndSwapB_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8141   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8142   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8143   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8144   format %{ &quot;weak CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8145   ins_encode %{
 8146     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8147     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8148     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8149                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8150                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8151   %}
 8152   ins_pipe(pipe_class_default);
 8153 %}
 8154 
 8155 instruct weakCompareAndSwapB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8156   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8157   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8158   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8159   format %{ &quot;weak CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8160   ins_encode %{
 8161     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8162     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8163     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8164                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8165                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8166   %}
 8167   ins_pipe(pipe_class_default);
 8168 %}
 8169 
 8170 instruct weakCompareAndSwapS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8171   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8172   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8173   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8174   format %{ &quot;weak CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8175   ins_encode %{
 8176     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8177     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8178     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8179                 MacroAssembler::MemBarNone,
 8180                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8181   %}
 8182   ins_pipe(pipe_class_default);
 8183 %}
 8184 
 8185 instruct weakCompareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8186   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8187   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8188   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8189   format %{ &quot;weak CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8190   ins_encode %{
 8191     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8192     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8193     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8194                 MacroAssembler::MemBarNone,
 8195                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8196   %}
 8197   ins_pipe(pipe_class_default);
 8198 %}
 8199 
 8200 instruct weakCompareAndSwapS_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8201   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8202   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8203   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8204   format %{ &quot;weak CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8205   ins_encode %{
 8206     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8207     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8208     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8209                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8210                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8211   %}
 8212   ins_pipe(pipe_class_default);
 8213 %}
 8214 
 8215 instruct weakCompareAndSwapS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8216   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8217   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8218   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8219   format %{ &quot;weak CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8220   ins_encode %{
 8221     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8222     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8223     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8224                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8225                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8226   %}
 8227   ins_pipe(pipe_class_default);
 8228 %}
 8229 
 8230 instruct weakCompareAndSwapI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8231   match(Set res (WeakCompareAndSwapI mem_ptr (Binary src1 src2)));
 8232   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8233   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8234   format %{ &quot;weak CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8235   ins_encode %{
 8236     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8237     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8238     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8239                 MacroAssembler::MemBarNone,
 8240                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8241   %}
 8242   ins_pipe(pipe_class_default);
 8243 %}
 8244 
 8245 instruct weakCompareAndSwapI_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8246   match(Set res (WeakCompareAndSwapI mem_ptr (Binary src1 src2)));
 8247   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8248   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8249   format %{ &quot;weak CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8250   ins_encode %{
 8251     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8252     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8253     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8254     // value is never passed to caller.
 8255     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8256                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8257                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8258   %}
 8259   ins_pipe(pipe_class_default);
 8260 %}
 8261 
 8262 instruct weakCompareAndSwapN_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8263   match(Set res (WeakCompareAndSwapN mem_ptr (Binary src1 src2)));
 8264   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8265   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8266   format %{ &quot;weak CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8267   ins_encode %{
 8268     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8269     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8270     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8271                 MacroAssembler::MemBarNone,
 8272                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8273   %}
 8274   ins_pipe(pipe_class_default);
 8275 %}
 8276 
 8277 instruct weakCompareAndSwapN_acq_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8278   match(Set res (WeakCompareAndSwapN mem_ptr (Binary src1 src2)));
 8279   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8280   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8281   format %{ &quot;weak CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8282   ins_encode %{
 8283     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8284     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8285     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8286     // value is never passed to caller.
 8287     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8288                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8289                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8290   %}
 8291   ins_pipe(pipe_class_default);
 8292 %}
 8293 
 8294 instruct weakCompareAndSwapL_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8295   match(Set res (WeakCompareAndSwapL mem_ptr (Binary src1 src2)));
 8296   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8297   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8298   format %{ &quot;weak CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8299   ins_encode %{
 8300     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8301     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8302     // value is never passed to caller.
 8303     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8304                 MacroAssembler::MemBarNone,
 8305                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8306   %}
 8307   ins_pipe(pipe_class_default);
 8308 %}
 8309 
 8310 instruct weakCompareAndSwapL_acq_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8311   match(Set res (WeakCompareAndSwapL mem_ptr (Binary src1 src2)));
 8312   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8313   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8314   format %{ &quot;weak CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8315   ins_encode %{
 8316     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8317     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8318     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8319     // value is never passed to caller.
 8320     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8321                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8322                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8323   %}
 8324   ins_pipe(pipe_class_default);
 8325 %}
 8326 
 8327 instruct weakCompareAndSwapP_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8328   match(Set res (WeakCompareAndSwapP mem_ptr (Binary src1 src2)));
 8329   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8330   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8331   format %{ &quot;weak CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool; ptr&quot; %}
 8332   ins_encode %{
 8333     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8334     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8335     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8336                 MacroAssembler::MemBarNone,
 8337                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8338   %}
 8339   ins_pipe(pipe_class_default);
 8340 %}
 8341 
 8342 instruct weakCompareAndSwapP_acq_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8343   match(Set res (WeakCompareAndSwapP mem_ptr (Binary src1 src2)));
 8344   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8345   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8346   format %{ &quot;weak CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as bool; ptr&quot; %}
 8347   ins_encode %{
 8348     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8349     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8350     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8351     // value is never passed to caller.
 8352     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8353                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8354                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8355   %}
 8356   ins_pipe(pipe_class_default);
 8357 %}
 8358 
 8359 // CompareAndExchange
 8360 
 8361 instruct compareAndExchangeB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8362   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8363   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8364   effect(TEMP_DEF res, TEMP cr0);
 8365   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8366   ins_encode %{
 8367     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8368     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8369     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8370                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8371                 noreg, true);
 8372   %}
 8373   ins_pipe(pipe_class_default);
 8374 %}
 8375 
 8376 instruct compareAndExchangeB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8377   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8378   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8379   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8380   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8381   ins_encode %{
 8382     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8383     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8384     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8385                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8386                 noreg, true);
 8387   %}
 8388   ins_pipe(pipe_class_default);
 8389 %}
 8390 
 8391 instruct compareAndExchangeB_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8392   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8393   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8394   effect(TEMP_DEF res, TEMP cr0);
 8395   format %{ &quot;CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8396   ins_encode %{
 8397     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8398     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8399     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8400                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8401                 noreg, true);
 8402     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8403       __ isync();
 8404     } else {
 8405       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8406       __ sync();
 8407     }
 8408   %}
 8409   ins_pipe(pipe_class_default);
 8410 %}
 8411 
 8412 instruct compareAndExchangeB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8413   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8414   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8415   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8416   format %{ &quot;CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8417   ins_encode %{
 8418     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8419     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8420     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8421                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8422                 noreg, true);
 8423     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8424       __ isync();
 8425     } else {
 8426       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8427       __ sync();
 8428     }
 8429   %}
 8430   ins_pipe(pipe_class_default);
 8431 %}
 8432 
 8433 instruct compareAndExchangeS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8434   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8435   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8436   effect(TEMP_DEF res, TEMP cr0);
 8437   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8438   ins_encode %{
 8439     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8440     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8441     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8442                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8443                 noreg, true);
 8444   %}
 8445   ins_pipe(pipe_class_default);
 8446 %}
 8447 
 8448 instruct compareAndExchangeS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8449   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8450   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8451   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8452   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8453   ins_encode %{
 8454     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8455     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8456     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8457                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8458                 noreg, true);
 8459   %}
 8460   ins_pipe(pipe_class_default);
 8461 %}
 8462 
 8463 instruct compareAndExchangeS_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8464   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8465   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8466   effect(TEMP_DEF res, TEMP cr0);
 8467   format %{ &quot;CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8468   ins_encode %{
 8469     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8470     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8471     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8472                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8473                 noreg, true);
 8474     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8475       __ isync();
 8476     } else {
 8477       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8478       __ sync();
 8479     }
 8480   %}
 8481   ins_pipe(pipe_class_default);
 8482 %}
 8483 
 8484 instruct compareAndExchangeS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8485   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8486   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8487   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8488   format %{ &quot;CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8489   ins_encode %{
 8490     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8491     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8492     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8493                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8494                 noreg, true);
 8495     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8496       __ isync();
 8497     } else {
 8498       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8499       __ sync();
 8500     }
 8501   %}
 8502   ins_pipe(pipe_class_default);
 8503 %}
 8504 
 8505 instruct compareAndExchangeI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8506   match(Set res (CompareAndExchangeI mem_ptr (Binary src1 src2)));
 8507   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8508   effect(TEMP_DEF res, TEMP cr0);
 8509   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8510   ins_encode %{
 8511     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8512     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8513     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8514                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8515                 noreg, true);
 8516   %}
 8517   ins_pipe(pipe_class_default);
 8518 %}
 8519 
 8520 instruct compareAndExchangeI_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8521   match(Set res (CompareAndExchangeI mem_ptr (Binary src1 src2)));
 8522   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8523   effect(TEMP_DEF res, TEMP cr0);
 8524   format %{ &quot;CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8525   ins_encode %{
 8526     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8527     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8528     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8529                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8530                 noreg, true);
 8531     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8532       __ isync();
 8533     } else {
 8534       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8535       __ sync();
 8536     }
 8537   %}
 8538   ins_pipe(pipe_class_default);
 8539 %}
 8540 
 8541 instruct compareAndExchangeN_regP_regN_regN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8542   match(Set res (CompareAndExchangeN mem_ptr (Binary src1 src2)));
 8543   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8544   effect(TEMP_DEF res, TEMP cr0);
 8545   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as narrow oop&quot; %}
 8546   ins_encode %{
 8547     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8548     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8549     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8550                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8551                 noreg, true);
 8552   %}
 8553   ins_pipe(pipe_class_default);
 8554 %}
 8555 
 8556 instruct compareAndExchangeN_acq_regP_regN_regN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8557   match(Set res (CompareAndExchangeN mem_ptr (Binary src1 src2)));
 8558   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8559   effect(TEMP_DEF res, TEMP cr0);
 8560   format %{ &quot;CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as narrow oop&quot; %}
 8561   ins_encode %{
 8562     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8563     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8564     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8565                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8566                 noreg, true);
 8567     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8568       __ isync();
 8569     } else {
 8570       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8571       __ sync();
 8572     }
 8573   %}
 8574   ins_pipe(pipe_class_default);
 8575 %}
 8576 
 8577 instruct compareAndExchangeL_regP_regL_regL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8578   match(Set res (CompareAndExchangeL mem_ptr (Binary src1 src2)));
 8579   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8580   effect(TEMP_DEF res, TEMP cr0);
 8581   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as long&quot; %}
 8582   ins_encode %{
 8583     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8584     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8585     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8586                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8587                 noreg, NULL, true);
 8588   %}
 8589   ins_pipe(pipe_class_default);
 8590 %}
 8591 
 8592 instruct compareAndExchangeL_acq_regP_regL_regL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8593   match(Set res (CompareAndExchangeL mem_ptr (Binary src1 src2)));
 8594   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8595   effect(TEMP_DEF res, TEMP cr0);
 8596   format %{ &quot;CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as long&quot; %}
 8597   ins_encode %{
 8598     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8599     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8600     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8601                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8602                 noreg, NULL, true);
 8603     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8604       __ isync();
 8605     } else {
 8606       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8607       __ sync();
 8608     }
 8609   %}
 8610   ins_pipe(pipe_class_default);
 8611 %}
 8612 
 8613 instruct compareAndExchangeP_regP_regP_regP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8614   match(Set res (CompareAndExchangeP mem_ptr (Binary src1 src2)));
 8615   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8616   effect(TEMP_DEF res, TEMP cr0);
 8617   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as ptr; ptr&quot; %}
 8618   ins_encode %{
 8619     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8620     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8621     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8622                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8623                 noreg, NULL, true);
 8624   %}
 8625   ins_pipe(pipe_class_default);
 8626 %}
 8627 
 8628 instruct compareAndExchangeP_acq_regP_regP_regP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8629   match(Set res (CompareAndExchangeP mem_ptr (Binary src1 src2)));
 8630   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8631   effect(TEMP_DEF res, TEMP cr0);
 8632   format %{ &quot;CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as ptr; ptr&quot; %}
 8633   ins_encode %{
 8634     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8635     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8636     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8637                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8638                 noreg, NULL, true);
 8639     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8640       __ isync();
 8641     } else {
 8642       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8643       __ sync();
 8644     }
 8645   %}
 8646   ins_pipe(pipe_class_default);
 8647 %}
 8648 
 8649 // Special RMW
 8650 
 8651 instruct getAndAddB(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8652   match(Set res (GetAndAddB mem_ptr src));
 8653   predicate(VM_Version::has_lqarx());
 8654   effect(TEMP_DEF res, TEMP cr0);
 8655   format %{ &quot;GetAndAddB $res, $mem_ptr, $src&quot; %}
 8656   ins_encode %{
 8657     __ getandaddb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8658                   R0, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8659     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8660       __ isync();
 8661     } else {
 8662       __ sync();
 8663     }
 8664   %}
 8665   ins_pipe(pipe_class_default);
 8666 %}
 8667 
 8668 instruct getAndAddB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8669   match(Set res (GetAndAddB mem_ptr src));
 8670   predicate(!VM_Version::has_lqarx());
 8671   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8672   format %{ &quot;GetAndAddB $res, $mem_ptr, $src&quot; %}
 8673   ins_encode %{
 8674     __ getandaddb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8675                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8676     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8677       __ isync();
 8678     } else {
 8679       __ sync();
 8680     }
 8681   %}
 8682   ins_pipe(pipe_class_default);
 8683 %}
 8684 
 8685 instruct getAndAddS(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8686   match(Set res (GetAndAddS mem_ptr src));
 8687   predicate(VM_Version::has_lqarx());
 8688   effect(TEMP_DEF res, TEMP cr0);
 8689   format %{ &quot;GetAndAddS $res, $mem_ptr, $src&quot; %}
 8690   ins_encode %{
 8691     __ getandaddh($res$$Register, $src$$Register, $mem_ptr$$Register,
 8692                   R0, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8693     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8694       __ isync();
 8695     } else {
 8696       __ sync();
 8697     }
 8698   %}
 8699   ins_pipe(pipe_class_default);
 8700 %}
 8701 
 8702 instruct getAndAddS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8703   match(Set res (GetAndAddS mem_ptr src));
 8704   predicate(!VM_Version::has_lqarx());
 8705   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8706   format %{ &quot;GetAndAddS $res, $mem_ptr, $src&quot; %}
 8707   ins_encode %{
 8708     __ getandaddh($res$$Register, $src$$Register, $mem_ptr$$Register,
 8709                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8710     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8711       __ isync();
 8712     } else {
 8713       __ sync();
 8714     }
 8715   %}
 8716   ins_pipe(pipe_class_default);
 8717 %}
 8718 
 8719 instruct getAndAddI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8720   match(Set res (GetAndAddI mem_ptr src));
 8721   effect(TEMP_DEF res, TEMP cr0);
 8722   format %{ &quot;GetAndAddI $res, $mem_ptr, $src&quot; %}
 8723   ins_encode %{
 8724     __ getandaddw($res$$Register, $src$$Register, $mem_ptr$$Register,
 8725                   R0, MacroAssembler::cmpxchgx_hint_atomic_update());
 8726     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8727       __ isync();
 8728     } else {
 8729       __ sync();
 8730     }
 8731   %}
 8732   ins_pipe(pipe_class_default);
 8733 %}
 8734 
 8735 instruct getAndAddL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src, flagsRegCR0 cr0) %{
 8736   match(Set res (GetAndAddL mem_ptr src));
 8737   effect(TEMP_DEF res, TEMP cr0);
 8738   format %{ &quot;GetAndAddL $res, $mem_ptr, $src&quot; %}
 8739   ins_encode %{
 8740     __ getandaddd($res$$Register, $src$$Register, $mem_ptr$$Register,
 8741                   R0, MacroAssembler::cmpxchgx_hint_atomic_update());
 8742     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8743       __ isync();
 8744     } else {
 8745       __ sync();
 8746     }
 8747   %}
 8748   ins_pipe(pipe_class_default);
 8749 %}
 8750 
 8751 instruct getAndSetB(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8752   match(Set res (GetAndSetB mem_ptr src));
 8753   predicate(VM_Version::has_lqarx());
 8754   effect(TEMP_DEF res, TEMP cr0);
 8755   format %{ &quot;GetAndSetB $res, $mem_ptr, $src&quot; %}
 8756   ins_encode %{
 8757     __ getandsetb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8758                   noreg, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8759     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8760       __ isync();
 8761     } else {
 8762       __ sync();
 8763     }
 8764   %}
 8765   ins_pipe(pipe_class_default);
 8766 %}
 8767 
 8768 instruct getAndSetB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8769   match(Set res (GetAndSetB mem_ptr src));
 8770   predicate(!VM_Version::has_lqarx());
 8771   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8772   format %{ &quot;GetAndSetB $res, $mem_ptr, $src&quot; %}
 8773   ins_encode %{
 8774     __ getandsetb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8775                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8776     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8777       __ isync();
 8778     } else {
 8779       __ sync();
 8780     }
 8781   %}
 8782   ins_pipe(pipe_class_default);
 8783 %}
 8784 
 8785 instruct getAndSetS(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8786   match(Set res (GetAndSetS mem_ptr src));
 8787   predicate(VM_Version::has_lqarx());
 8788   effect(TEMP_DEF res, TEMP cr0);
 8789   format %{ &quot;GetAndSetS $res, $mem_ptr, $src&quot; %}
 8790   ins_encode %{
 8791     __ getandseth($res$$Register, $src$$Register, $mem_ptr$$Register,
 8792                   noreg, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8793     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8794       __ isync();
 8795     } else {
 8796       __ sync();
 8797     }
 8798   %}
 8799   ins_pipe(pipe_class_default);
 8800 %}
 8801 
 8802 instruct getAndSetS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8803   match(Set res (GetAndSetS mem_ptr src));
 8804   predicate(!VM_Version::has_lqarx());
 8805   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8806   format %{ &quot;GetAndSetS $res, $mem_ptr, $src&quot; %}
 8807   ins_encode %{
 8808     __ getandseth($res$$Register, $src$$Register, $mem_ptr$$Register,
 8809                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8810     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8811       __ isync();
 8812     } else {
 8813       __ sync();
 8814     }
 8815   %}
 8816   ins_pipe(pipe_class_default);
 8817 %}
 8818 
 8819 instruct getAndSetI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8820   match(Set res (GetAndSetI mem_ptr src));
 8821   effect(TEMP_DEF res, TEMP cr0);
 8822   format %{ &quot;GetAndSetI $res, $mem_ptr, $src&quot; %}
 8823   ins_encode %{
 8824     __ getandsetw($res$$Register, $src$$Register, $mem_ptr$$Register,
 8825                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8826     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8827       __ isync();
 8828     } else {
 8829       __ sync();
 8830     }
 8831   %}
 8832   ins_pipe(pipe_class_default);
 8833 %}
 8834 
 8835 instruct getAndSetL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src, flagsRegCR0 cr0) %{
 8836   match(Set res (GetAndSetL mem_ptr src));
 8837   effect(TEMP_DEF res, TEMP cr0);
 8838   format %{ &quot;GetAndSetL $res, $mem_ptr, $src&quot; %}
 8839   ins_encode %{
 8840     __ getandsetd($res$$Register, $src$$Register, $mem_ptr$$Register,
 8841                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8842     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8843       __ isync();
 8844     } else {
 8845       __ sync();
 8846     }
 8847   %}
 8848   ins_pipe(pipe_class_default);
 8849 %}
 8850 
 8851 instruct getAndSetP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src, flagsRegCR0 cr0) %{
 8852   match(Set res (GetAndSetP mem_ptr src));
 8853   effect(TEMP_DEF res, TEMP cr0);
 8854   format %{ &quot;GetAndSetP $res, $mem_ptr, $src&quot; %}
 8855   ins_encode %{
 8856     __ getandsetd($res$$Register, $src$$Register, $mem_ptr$$Register,
 8857                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8858     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8859       __ isync();
 8860     } else {
 8861       __ sync();
 8862     }
 8863   %}
 8864   ins_pipe(pipe_class_default);
 8865 %}
 8866 
 8867 instruct getAndSetN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src, flagsRegCR0 cr0) %{
 8868   match(Set res (GetAndSetN mem_ptr src));
 8869   effect(TEMP_DEF res, TEMP cr0);
 8870   format %{ &quot;GetAndSetN $res, $mem_ptr, $src&quot; %}
 8871   ins_encode %{
 8872     __ getandsetw($res$$Register, $src$$Register, $mem_ptr$$Register,
 8873                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8874     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8875       __ isync();
 8876     } else {
 8877       __ sync();
 8878     }
 8879   %}
 8880   ins_pipe(pipe_class_default);
 8881 %}
 8882 
 8883 //----------Arithmetic Instructions--------------------------------------------
 8884 // Addition Instructions
 8885 
 8886 // Register Addition
 8887 instruct addI_reg_reg(iRegIdst dst, iRegIsrc_iRegL2Isrc src1, iRegIsrc_iRegL2Isrc src2) %{
 8888   match(Set dst (AddI src1 src2));
 8889   format %{ &quot;ADD     $dst, $src1, $src2&quot; %}
 8890   size(4);
 8891   ins_encode %{
 8892     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8893     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8894   %}
 8895   ins_pipe(pipe_class_default);
 8896 %}
 8897 
 8898 // Expand does not work with above instruct. (??)
 8899 instruct addI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 8900   // no match-rule
 8901   effect(DEF dst, USE src1, USE src2);
 8902   format %{ &quot;ADD     $dst, $src1, $src2&quot; %}
 8903   size(4);
 8904   ins_encode %{
 8905     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8906     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8907   %}
 8908   ins_pipe(pipe_class_default);
 8909 %}
 8910 
 8911 instruct tree_addI_addI_addI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
 8912   match(Set dst (AddI (AddI (AddI src1 src2) src3) src4));
 8913   ins_cost(DEFAULT_COST*3);
 8914 
 8915   expand %{
 8916     // FIXME: we should do this in the ideal world.
 8917     iRegIdst tmp1;
 8918     iRegIdst tmp2;
 8919     addI_reg_reg(tmp1, src1, src2);
 8920     addI_reg_reg_2(tmp2, src3, src4); // Adlc complains about addI_reg_reg.
 8921     addI_reg_reg(dst, tmp1, tmp2);
 8922   %}
 8923 %}
 8924 
 8925 // Immediate Addition
 8926 instruct addI_reg_imm16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
 8927   match(Set dst (AddI src1 src2));
 8928   format %{ &quot;ADDI    $dst, $src1, $src2&quot; %}
 8929   size(4);
 8930   ins_encode %{
 8931     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 8932     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
 8933   %}
 8934   ins_pipe(pipe_class_default);
 8935 %}
 8936 
 8937 // Immediate Addition with 16-bit shifted operand
 8938 instruct addI_reg_immhi16(iRegIdst dst, iRegIsrc src1, immIhi16 src2) %{
 8939   match(Set dst (AddI src1 src2));
 8940   format %{ &quot;ADDIS   $dst, $src1, $src2&quot; %}
 8941   size(4);
 8942   ins_encode %{
 8943     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 8944     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
 8945   %}
 8946   ins_pipe(pipe_class_default);
 8947 %}
 8948 
 8949 // Long Addition
 8950 instruct addL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 8951   match(Set dst (AddL src1 src2));
 8952   format %{ &quot;ADD     $dst, $src1, $src2 \t// long&quot; %}
 8953   size(4);
 8954   ins_encode %{
 8955     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8956     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8957   %}
 8958   ins_pipe(pipe_class_default);
 8959 %}
 8960 
 8961 // Expand does not work with above instruct. (??)
 8962 instruct addL_reg_reg_2(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 8963   // no match-rule
 8964   effect(DEF dst, USE src1, USE src2);
 8965   format %{ &quot;ADD     $dst, $src1, $src2 \t// long&quot; %}
 8966   size(4);
 8967   ins_encode %{
 8968     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8969     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8970   %}
 8971   ins_pipe(pipe_class_default);
 8972 %}
 8973 
 8974 instruct tree_addL_addL_addL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2, iRegLsrc src3, iRegLsrc src4) %{
 8975   match(Set dst (AddL (AddL (AddL src1 src2) src3) src4));
 8976   ins_cost(DEFAULT_COST*3);
 8977 
 8978   expand %{
 8979     // FIXME: we should do this in the ideal world.
 8980     iRegLdst tmp1;
 8981     iRegLdst tmp2;
 8982     addL_reg_reg(tmp1, src1, src2);
 8983     addL_reg_reg_2(tmp2, src3, src4); // Adlc complains about orI_reg_reg.
 8984     addL_reg_reg(dst, tmp1, tmp2);
 8985   %}
 8986 %}
 8987 
 8988 // AddL + ConvL2I.
 8989 instruct addI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
 8990   match(Set dst (ConvL2I (AddL src1 src2)));
 8991 
 8992   format %{ &quot;ADD     $dst, $src1, $src2 \t// long + l2i&quot; %}
 8993   size(4);
 8994   ins_encode %{
 8995     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8996     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8997   %}
 8998   ins_pipe(pipe_class_default);
 8999 %}
 9000 
 9001 // No constant pool entries required.
 9002 instruct addL_reg_imm16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
 9003   match(Set dst (AddL src1 src2));
 9004 
 9005   format %{ &quot;ADDI    $dst, $src1, $src2&quot; %}
 9006   size(4);
 9007   ins_encode %{
 9008     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 9009     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
 9010   %}
 9011   ins_pipe(pipe_class_default);
 9012 %}
 9013 
 9014 // Long Immediate Addition with 16-bit shifted operand.
 9015 // No constant pool entries required.
 9016 instruct addL_reg_immhi16(iRegLdst dst, iRegLsrc src1, immL32hi16 src2) %{
 9017   match(Set dst (AddL src1 src2));
 9018 
 9019   format %{ &quot;ADDIS   $dst, $src1, $src2&quot; %}
 9020   size(4);
 9021   ins_encode %{
 9022     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 9023     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
 9024   %}
 9025   ins_pipe(pipe_class_default);
 9026 %}
 9027 
 9028 // Pointer Register Addition
 9029 instruct addP_reg_reg(iRegPdst dst, iRegP_N2P src1, iRegLsrc src2) %{
 9030   match(Set dst (AddP src1 src2));
 9031   format %{ &quot;ADD     $dst, $src1, $src2&quot; %}
 9032   size(4);
 9033   ins_encode %{
 9034     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 9035     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 9036   %}
 9037   ins_pipe(pipe_class_default);
 9038 %}
 9039 
 9040 // Pointer Immediate Addition
 9041 // No constant pool entries required.
 9042 instruct addP_reg_imm16(iRegPdst dst, iRegP_N2P src1, immL16 src2) %{
 9043   match(Set dst (AddP src1 src2));
 9044 
 9045   format %{ &quot;ADDI    $dst, $src1, $src2&quot; %}
 9046   size(4);
 9047   ins_encode %{
 9048     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 9049     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
 9050   %}
 9051   ins_pipe(pipe_class_default);
 9052 %}
 9053 
 9054 // Pointer Immediate Addition with 16-bit shifted operand.
 9055 // No constant pool entries required.
 9056 instruct addP_reg_immhi16(iRegPdst dst, iRegP_N2P src1, immL32hi16 src2) %{
 9057   match(Set dst (AddP src1 src2));
 9058 
 9059   format %{ &quot;ADDIS   $dst, $src1, $src2&quot; %}
 9060   size(4);
 9061   ins_encode %{
 9062     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 9063     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
 9064   %}
 9065   ins_pipe(pipe_class_default);
 9066 %}
 9067 
 9068 //---------------------
 9069 // Subtraction Instructions
 9070 
 9071 // Register Subtraction
 9072 instruct subI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9073   match(Set dst (SubI src1 src2));
 9074   format %{ &quot;SUBF    $dst, $src2, $src1&quot; %}
 9075   size(4);
 9076   ins_encode %{
 9077     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 9078     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
 9079   %}
 9080   ins_pipe(pipe_class_default);
 9081 %}
 9082 
 9083 // Immediate Subtraction
 9084 // Immediate Subtraction: The compiler converts &quot;x-c0&quot; into &quot;x+ -c0&quot; (see SubLNode::Ideal),
 9085 // Don&#39;t try to use addi with - $src2$$constant since it can overflow when $src2$$constant == minI16.
 9086 
 9087 // SubI from constant (using subfic).
 9088 instruct subI_imm16_reg(iRegIdst dst, immI16 src1, iRegIsrc src2) %{
 9089   match(Set dst (SubI src1 src2));
 9090   format %{ &quot;SUBI    $dst, $src1, $src2&quot; %}
 9091 
 9092   size(4);
 9093   ins_encode %{
 9094     // TODO: PPC port $archOpcode(ppc64Opcode_subfic);
 9095     __ subfic($dst$$Register, $src2$$Register, $src1$$constant);
 9096   %}
 9097   ins_pipe(pipe_class_default);
 9098 %}
 9099 
 9100 // Turn the sign-bit of an integer into a 32-bit mask, 0x0...0 for
 9101 // positive integers and 0xF...F for negative ones.
 9102 instruct signmask32I_regI(iRegIdst dst, iRegIsrc src) %{
 9103   // no match-rule, false predicate
 9104   effect(DEF dst, USE src);
 9105   predicate(false);
 9106 
 9107   format %{ &quot;SRAWI   $dst, $src, #31&quot; %}
 9108   size(4);
 9109   ins_encode %{
 9110     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
 9111     __ srawi($dst$$Register, $src$$Register, 0x1f);
 9112   %}
 9113   ins_pipe(pipe_class_default);
 9114 %}
 9115 
 9116 instruct absI_reg_Ex(iRegIdst dst, iRegIsrc src) %{
 9117   match(Set dst (AbsI src));
 9118   ins_cost(DEFAULT_COST*3);
 9119 
 9120   expand %{
 9121     iRegIdst tmp1;
 9122     iRegIdst tmp2;
 9123     signmask32I_regI(tmp1, src);
 9124     xorI_reg_reg(tmp2, tmp1, src);
 9125     subI_reg_reg(dst, tmp2, tmp1);
 9126   %}
 9127 %}
 9128 
 9129 instruct negI_regI(iRegIdst dst, immI_0 zero, iRegIsrc src2) %{
 9130   match(Set dst (SubI zero src2));
 9131   format %{ &quot;NEG     $dst, $src2&quot; %}
 9132   size(4);
 9133   ins_encode %{
 9134     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9135     __ neg($dst$$Register, $src2$$Register);
 9136   %}
 9137   ins_pipe(pipe_class_default);
 9138 %}
 9139 
 9140 // Long subtraction
 9141 instruct subL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9142   match(Set dst (SubL src1 src2));
 9143   format %{ &quot;SUBF    $dst, $src2, $src1 \t// long&quot; %}
 9144   size(4);
 9145   ins_encode %{
 9146     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 9147     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
 9148   %}
 9149   ins_pipe(pipe_class_default);
 9150 %}
 9151 
 9152 // SubL + convL2I.
 9153 instruct subI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9154   match(Set dst (ConvL2I (SubL src1 src2)));
 9155 
 9156   format %{ &quot;SUBF    $dst, $src2, $src1 \t// long + l2i&quot; %}
 9157   size(4);
 9158   ins_encode %{
 9159     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 9160     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
 9161   %}
 9162   ins_pipe(pipe_class_default);
 9163 %}
 9164 
 9165 // Turn the sign-bit of a long into a 64-bit mask, 0x0...0 for
 9166 // positive longs and 0xF...F for negative ones.
 9167 instruct signmask64I_regL(iRegIdst dst, iRegLsrc src) %{
 9168   // no match-rule, false predicate
 9169   effect(DEF dst, USE src);
 9170   predicate(false);
 9171 
 9172   format %{ &quot;SRADI   $dst, $src, #63&quot; %}
 9173   size(4);
 9174   ins_encode %{
 9175     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9176     __ sradi($dst$$Register, $src$$Register, 0x3f);
 9177   %}
 9178   ins_pipe(pipe_class_default);
 9179 %}
 9180 
 9181 // Turn the sign-bit of a long into a 64-bit mask, 0x0...0 for
 9182 // positive longs and 0xF...F for negative ones.
 9183 instruct signmask64L_regL(iRegLdst dst, iRegLsrc src) %{
 9184   // no match-rule, false predicate
 9185   effect(DEF dst, USE src);
 9186   predicate(false);
 9187 
 9188   format %{ &quot;SRADI   $dst, $src, #63&quot; %}
 9189   size(4);
 9190   ins_encode %{
 9191     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9192     __ sradi($dst$$Register, $src$$Register, 0x3f);
 9193   %}
 9194   ins_pipe(pipe_class_default);
 9195 %}
 9196 
 9197 // Long negation
 9198 instruct negL_reg_reg(iRegLdst dst, immL_0 zero, iRegLsrc src2) %{
 9199   match(Set dst (SubL zero src2));
 9200   format %{ &quot;NEG     $dst, $src2 \t// long&quot; %}
 9201   size(4);
 9202   ins_encode %{
 9203     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9204     __ neg($dst$$Register, $src2$$Register);
 9205   %}
 9206   ins_pipe(pipe_class_default);
 9207 %}
 9208 
 9209 // NegL + ConvL2I.
 9210 instruct negI_con0_regL(iRegIdst dst, immL_0 zero, iRegLsrc src2) %{
 9211   match(Set dst (ConvL2I (SubL zero src2)));
 9212 
 9213   format %{ &quot;NEG     $dst, $src2 \t// long + l2i&quot; %}
 9214   size(4);
 9215   ins_encode %{
 9216     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9217     __ neg($dst$$Register, $src2$$Register);
 9218   %}
 9219   ins_pipe(pipe_class_default);
 9220 %}
 9221 
 9222 // Multiplication Instructions
 9223 // Integer Multiplication
 9224 
 9225 // Register Multiplication
 9226 instruct mulI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9227   match(Set dst (MulI src1 src2));
 9228   ins_cost(DEFAULT_COST);
 9229 
 9230   format %{ &quot;MULLW   $dst, $src1, $src2&quot; %}
 9231   size(4);
 9232   ins_encode %{
 9233     // TODO: PPC port $archOpcode(ppc64Opcode_mullw);
 9234     __ mullw($dst$$Register, $src1$$Register, $src2$$Register);
 9235   %}
 9236   ins_pipe(pipe_class_default);
 9237 %}
 9238 
 9239 // Immediate Multiplication
 9240 instruct mulI_reg_imm16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
 9241   match(Set dst (MulI src1 src2));
 9242   ins_cost(DEFAULT_COST);
 9243 
 9244   format %{ &quot;MULLI   $dst, $src1, $src2&quot; %}
 9245   size(4);
 9246   ins_encode %{
 9247     // TODO: PPC port $archOpcode(ppc64Opcode_mulli);
 9248     __ mulli($dst$$Register, $src1$$Register, $src2$$constant);
 9249   %}
 9250   ins_pipe(pipe_class_default);
 9251 %}
 9252 
 9253 instruct mulL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9254   match(Set dst (MulL src1 src2));
 9255   ins_cost(DEFAULT_COST);
 9256 
 9257   format %{ &quot;MULLD   $dst $src1, $src2 \t// long&quot; %}
 9258   size(4);
 9259   ins_encode %{
 9260     // TODO: PPC port $archOpcode(ppc64Opcode_mulld);
 9261     __ mulld($dst$$Register, $src1$$Register, $src2$$Register);
 9262   %}
 9263   ins_pipe(pipe_class_default);
 9264 %}
 9265 
 9266 // Multiply high for optimized long division by constant.
 9267 instruct mulHighL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9268   match(Set dst (MulHiL src1 src2));
 9269   ins_cost(DEFAULT_COST);
 9270 
 9271   format %{ &quot;MULHD   $dst $src1, $src2 \t// long&quot; %}
 9272   size(4);
 9273   ins_encode %{
 9274     // TODO: PPC port $archOpcode(ppc64Opcode_mulhd);
 9275     __ mulhd($dst$$Register, $src1$$Register, $src2$$Register);
 9276   %}
 9277   ins_pipe(pipe_class_default);
 9278 %}
 9279 
 9280 // Immediate Multiplication
 9281 instruct mulL_reg_imm16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
 9282   match(Set dst (MulL src1 src2));
 9283   ins_cost(DEFAULT_COST);
 9284 
 9285   format %{ &quot;MULLI   $dst, $src1, $src2&quot; %}
 9286   size(4);
 9287   ins_encode %{
 9288     // TODO: PPC port $archOpcode(ppc64Opcode_mulli);
 9289     __ mulli($dst$$Register, $src1$$Register, $src2$$constant);
 9290   %}
 9291   ins_pipe(pipe_class_default);
 9292 %}
 9293 
 9294 // Integer Division with Immediate -1: Negate.
 9295 instruct divI_reg_immIvalueMinus1(iRegIdst dst, iRegIsrc src1, immI_minus1 src2) %{
 9296   match(Set dst (DivI src1 src2));
 9297   ins_cost(DEFAULT_COST);
 9298 
 9299   format %{ &quot;NEG     $dst, $src1 \t// /-1&quot; %}
 9300   size(4);
 9301   ins_encode %{
 9302     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9303     __ neg($dst$$Register, $src1$$Register);
 9304   %}
 9305   ins_pipe(pipe_class_default);
 9306 %}
 9307 
 9308 // Integer Division with constant, but not -1.
 9309 // We should be able to improve this by checking the type of src2.
 9310 // It might well be that src2 is known to be positive.
 9311 instruct divI_reg_regnotMinus1(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9312   match(Set dst (DivI src1 src2));
 9313   predicate(n-&gt;in(2)-&gt;find_int_con(-1) != -1); // src2 is a constant, but not -1
 9314   ins_cost(2*DEFAULT_COST);
 9315 
 9316   format %{ &quot;DIVW    $dst, $src1, $src2 \t// /not-1&quot; %}
 9317   size(4);
 9318   ins_encode %{
 9319     // TODO: PPC port $archOpcode(ppc64Opcode_divw);
 9320     __ divw($dst$$Register, $src1$$Register, $src2$$Register);
 9321   %}
 9322   ins_pipe(pipe_class_default);
 9323 %}
 9324 
 9325 instruct cmovI_bne_negI_reg(iRegIdst dst, flagsRegSrc crx, iRegIsrc src1) %{
 9326   effect(USE_DEF dst, USE src1, USE crx);
 9327   predicate(false);
 9328 
 9329   ins_variable_size_depending_on_alignment(true);
 9330 
 9331   format %{ &quot;CMOVE   $dst, neg($src1), $crx&quot; %}
 9332   // Worst case is branch + move + stop, no stop without scheduler.
 9333   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 9334   ins_encode %{
 9335     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 9336     Label done;
 9337     __ bne($crx$$CondRegister, done);
 9338     __ neg($dst$$Register, $src1$$Register);
 9339     // TODO PPC port __ endgroup_if_needed(_size == 12);
 9340     __ bind(done);
 9341   %}
 9342   ins_pipe(pipe_class_default);
 9343 %}
 9344 
 9345 // Integer Division with Registers not containing constants.
 9346 instruct divI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9347   match(Set dst (DivI src1 src2));
 9348   ins_cost(10*DEFAULT_COST);
 9349 
 9350   expand %{
 9351     immI16 imm %{ (int)-1 %}
 9352     flagsReg tmp1;
 9353     cmpI_reg_imm16(tmp1, src2, imm);          // check src2 == -1
 9354     divI_reg_regnotMinus1(dst, src1, src2);   // dst = src1 / src2
 9355     cmovI_bne_negI_reg(dst, tmp1, src1);      // cmove dst = neg(src1) if src2 == -1
 9356   %}
 9357 %}
 9358 
 9359 // Long Division with Immediate -1: Negate.
 9360 instruct divL_reg_immLvalueMinus1(iRegLdst dst, iRegLsrc src1, immL_minus1 src2) %{
 9361   match(Set dst (DivL src1 src2));
 9362   ins_cost(DEFAULT_COST);
 9363 
 9364   format %{ &quot;NEG     $dst, $src1 \t// /-1, long&quot; %}
 9365   size(4);
 9366   ins_encode %{
 9367     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9368     __ neg($dst$$Register, $src1$$Register);
 9369   %}
 9370   ins_pipe(pipe_class_default);
 9371 %}
 9372 
 9373 // Long Division with constant, but not -1.
 9374 instruct divL_reg_regnotMinus1(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9375   match(Set dst (DivL src1 src2));
 9376   predicate(n-&gt;in(2)-&gt;find_long_con(-1L) != -1L); // Src2 is a constant, but not -1.
 9377   ins_cost(2*DEFAULT_COST);
 9378 
 9379   format %{ &quot;DIVD    $dst, $src1, $src2 \t// /not-1, long&quot; %}
 9380   size(4);
 9381   ins_encode %{
 9382     // TODO: PPC port $archOpcode(ppc64Opcode_divd);
 9383     __ divd($dst$$Register, $src1$$Register, $src2$$Register);
 9384   %}
 9385   ins_pipe(pipe_class_default);
 9386 %}
 9387 
 9388 instruct cmovL_bne_negL_reg(iRegLdst dst, flagsRegSrc crx, iRegLsrc src1) %{
 9389   effect(USE_DEF dst, USE src1, USE crx);
 9390   predicate(false);
 9391 
 9392   ins_variable_size_depending_on_alignment(true);
 9393 
 9394   format %{ &quot;CMOVE   $dst, neg($src1), $crx&quot; %}
 9395   // Worst case is branch + move + stop, no stop without scheduler.
 9396   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 9397   ins_encode %{
 9398     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 9399     Label done;
 9400     __ bne($crx$$CondRegister, done);
 9401     __ neg($dst$$Register, $src1$$Register);
 9402     // TODO PPC port __ endgroup_if_needed(_size == 12);
 9403     __ bind(done);
 9404   %}
 9405   ins_pipe(pipe_class_default);
 9406 %}
 9407 
 9408 // Long Division with Registers not containing constants.
 9409 instruct divL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9410   match(Set dst (DivL src1 src2));
 9411   ins_cost(10*DEFAULT_COST);
 9412 
 9413   expand %{
 9414     immL16 imm %{ (int)-1 %}
 9415     flagsReg tmp1;
 9416     cmpL_reg_imm16(tmp1, src2, imm);          // check src2 == -1
 9417     divL_reg_regnotMinus1(dst, src1, src2);   // dst = src1 / src2
 9418     cmovL_bne_negL_reg(dst, tmp1, src1);      // cmove dst = neg(src1) if src2 == -1
 9419   %}
 9420 %}
 9421 
 9422 // Integer Remainder with registers.
 9423 instruct modI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9424   match(Set dst (ModI src1 src2));
 9425   ins_cost(10*DEFAULT_COST);
 9426 
 9427   expand %{
 9428     immI16 imm %{ (int)-1 %}
 9429     flagsReg tmp1;
 9430     iRegIdst tmp2;
 9431     iRegIdst tmp3;
 9432     cmpI_reg_imm16(tmp1, src2, imm);           // check src2 == -1
 9433     divI_reg_regnotMinus1(tmp2, src1, src2);   // tmp2 = src1 / src2
 9434     cmovI_bne_negI_reg(tmp2, tmp1, src1);      // cmove tmp2 = neg(src1) if src2 == -1
 9435     mulI_reg_reg(tmp3, src2, tmp2);            // tmp3 = src2 * tmp2
 9436     subI_reg_reg(dst, src1, tmp3);             // dst = src1 - tmp3
 9437   %}
 9438 %}
 9439 
 9440 // Long Remainder with registers
 9441 instruct modL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9442   match(Set dst (ModL src1 src2));
 9443   ins_cost(10*DEFAULT_COST);
 9444 
 9445   expand %{
 9446     immL16 imm %{ (int)-1 %}
 9447     flagsReg tmp1;
 9448     iRegLdst tmp2;
 9449     iRegLdst tmp3;
 9450     cmpL_reg_imm16(tmp1, src2, imm);             // check src2 == -1
 9451     divL_reg_regnotMinus1(tmp2, src1, src2);     // tmp2 = src1 / src2
 9452     cmovL_bne_negL_reg(tmp2, tmp1, src1);        // cmove tmp2 = neg(src1) if src2 == -1
 9453     mulL_reg_reg(tmp3, src2, tmp2);              // tmp3 = src2 * tmp2
 9454     subL_reg_reg(dst, src1, tmp3);               // dst = src1 - tmp3
 9455   %}
 9456 %}
 9457 
 9458 // Integer Shift Instructions
 9459 
 9460 // Register Shift Left
 9461 
 9462 // Clear all but the lowest #mask bits.
 9463 // Used to normalize shift amounts in registers.
 9464 instruct maskI_reg_imm(iRegIdst dst, iRegIsrc src, uimmI6 mask) %{
 9465   // no match-rule, false predicate
 9466   effect(DEF dst, USE src, USE mask);
 9467   predicate(false);
 9468 
 9469   format %{ &quot;MASK    $dst, $src, $mask \t// clear $mask upper bits&quot; %}
 9470   size(4);
 9471   ins_encode %{
 9472     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9473     __ clrldi($dst$$Register, $src$$Register, $mask$$constant);
 9474   %}
 9475   ins_pipe(pipe_class_default);
 9476 %}
 9477 
 9478 instruct lShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9479   // no match-rule, false predicate
 9480   effect(DEF dst, USE src1, USE src2);
 9481   predicate(false);
 9482 
 9483   format %{ &quot;SLW     $dst, $src1, $src2&quot; %}
 9484   size(4);
 9485   ins_encode %{
 9486     // TODO: PPC port $archOpcode(ppc64Opcode_slw);
 9487     __ slw($dst$$Register, $src1$$Register, $src2$$Register);
 9488   %}
 9489   ins_pipe(pipe_class_default);
 9490 %}
 9491 
 9492 instruct lShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9493   match(Set dst (LShiftI src1 src2));
 9494   ins_cost(DEFAULT_COST*2);
 9495   expand %{
 9496     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
 9497     iRegIdst tmpI;
 9498     maskI_reg_imm(tmpI, src2, mask);
 9499     lShiftI_reg_reg(dst, src1, tmpI);
 9500   %}
 9501 %}
 9502 
 9503 // Register Shift Left Immediate
 9504 instruct lShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
 9505   match(Set dst (LShiftI src1 src2));
 9506 
 9507   format %{ &quot;SLWI    $dst, $src1, ($src2 &amp; 0x1f)&quot; %}
 9508   size(4);
 9509   ins_encode %{
 9510     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9511     __ slwi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
 9512   %}
 9513   ins_pipe(pipe_class_default);
 9514 %}
 9515 
 9516 // AndI with negpow2-constant + LShiftI
 9517 instruct lShiftI_andI_immInegpow2_imm5(iRegIdst dst, iRegIsrc src1, immInegpow2 src2, uimmI5 src3) %{
 9518   match(Set dst (LShiftI (AndI src1 src2) src3));
 9519   predicate(UseRotateAndMaskInstructionsPPC64);
 9520 
 9521   format %{ &quot;RLWINM  $dst, lShiftI(AndI($src1, $src2), $src3)&quot; %}
 9522   size(4);
 9523   ins_encode %{
 9524     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm); // FIXME: assert that rlwinm is equal to addi
 9525     long src2      = $src2$$constant;
 9526     long src3      = $src3$$constant;
 9527     long maskbits  = src3 + log2_long((jlong) (julong) (juint) -src2);
 9528     if (maskbits &gt;= 32) {
 9529       __ li($dst$$Register, 0); // addi
 9530     } else {
 9531       __ rlwinm($dst$$Register, $src1$$Register, src3 &amp; 0x1f, 0, (31-maskbits) &amp; 0x1f);
 9532     }
 9533   %}
 9534   ins_pipe(pipe_class_default);
 9535 %}
 9536 
 9537 // RShiftI + AndI with negpow2-constant + LShiftI
 9538 instruct lShiftI_andI_immInegpow2_rShiftI_imm5(iRegIdst dst, iRegIsrc src1, immInegpow2 src2, uimmI5 src3) %{
 9539   match(Set dst (LShiftI (AndI (RShiftI src1 src3) src2) src3));
 9540   predicate(UseRotateAndMaskInstructionsPPC64);
 9541 
 9542   format %{ &quot;RLWINM  $dst, lShiftI(AndI(RShiftI($src1, $src3), $src2), $src3)&quot; %}
 9543   size(4);
 9544   ins_encode %{
 9545     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm); // FIXME: assert that rlwinm is equal to addi
 9546     long src2      = $src2$$constant;
 9547     long src3      = $src3$$constant;
 9548     long maskbits  = src3 + log2_long((jlong) (julong) (juint) -src2);
 9549     if (maskbits &gt;= 32) {
 9550       __ li($dst$$Register, 0); // addi
 9551     } else {
 9552       __ rlwinm($dst$$Register, $src1$$Register, 0, 0, (31-maskbits) &amp; 0x1f);
 9553     }
 9554   %}
 9555   ins_pipe(pipe_class_default);
 9556 %}
 9557 
 9558 instruct lShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9559   // no match-rule, false predicate
 9560   effect(DEF dst, USE src1, USE src2);
 9561   predicate(false);
 9562 
 9563   format %{ &quot;SLD     $dst, $src1, $src2&quot; %}
 9564   size(4);
 9565   ins_encode %{
 9566     // TODO: PPC port $archOpcode(ppc64Opcode_sld);
 9567     __ sld($dst$$Register, $src1$$Register, $src2$$Register);
 9568   %}
 9569   ins_pipe(pipe_class_default);
 9570 %}
 9571 
 9572 // Register Shift Left
 9573 instruct lShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9574   match(Set dst (LShiftL src1 src2));
 9575   ins_cost(DEFAULT_COST*2);
 9576   expand %{
 9577     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
 9578     iRegIdst tmpI;
 9579     maskI_reg_imm(tmpI, src2, mask);
 9580     lShiftL_regL_regI(dst, src1, tmpI);
 9581   %}
 9582 %}
 9583 
 9584 // Register Shift Left Immediate
 9585 instruct lshiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
 9586   match(Set dst (LShiftL src1 src2));
 9587   format %{ &quot;SLDI    $dst, $src1, ($src2 &amp; 0x3f)&quot; %}
 9588   size(4);
 9589   ins_encode %{
 9590     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 9591     __ sldi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9592   %}
 9593   ins_pipe(pipe_class_default);
 9594 %}
 9595 
 9596 // If we shift more than 32 bits, we need not convert I2L.
 9597 instruct lShiftL_regI_immGE32(iRegLdst dst, iRegIsrc src1, uimmI6_ge32 src2) %{
 9598   match(Set dst (LShiftL (ConvI2L src1) src2));
 9599   ins_cost(DEFAULT_COST);
 9600 
 9601   size(4);
 9602   format %{ &quot;SLDI    $dst, i2l($src1), $src2&quot; %}
 9603   ins_encode %{
 9604     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 9605     __ sldi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9606   %}
 9607   ins_pipe(pipe_class_default);
 9608 %}
 9609 
 9610 // Shift a postivie int to the left.
 9611 // Clrlsldi clears the upper 32 bits and shifts.
 9612 instruct scaledPositiveI2L_lShiftL_convI2L_reg_imm6(iRegLdst dst, iRegIsrc src1, uimmI6 src2) %{
 9613   match(Set dst (LShiftL (ConvI2L src1) src2));
 9614   predicate(((ConvI2LNode*)(_kids[0]-&gt;_leaf))-&gt;type()-&gt;is_long()-&gt;is_positive_int());
 9615 
 9616   format %{ &quot;SLDI    $dst, i2l(positive_int($src1)), $src2&quot; %}
 9617   size(4);
 9618   ins_encode %{
 9619     // TODO: PPC port $archOpcode(ppc64Opcode_rldic);
 9620     __ clrlsldi($dst$$Register, $src1$$Register, 0x20, $src2$$constant);
 9621   %}
 9622   ins_pipe(pipe_class_default);
 9623 %}
 9624 
 9625 instruct arShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9626   // no match-rule, false predicate
 9627   effect(DEF dst, USE src1, USE src2);
 9628   predicate(false);
 9629 
 9630   format %{ &quot;SRAW    $dst, $src1, $src2&quot; %}
 9631   size(4);
 9632   ins_encode %{
 9633     // TODO: PPC port $archOpcode(ppc64Opcode_sraw);
 9634     __ sraw($dst$$Register, $src1$$Register, $src2$$Register);
 9635   %}
 9636   ins_pipe(pipe_class_default);
 9637 %}
 9638 
 9639 // Register Arithmetic Shift Right
 9640 instruct arShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9641   match(Set dst (RShiftI src1 src2));
 9642   ins_cost(DEFAULT_COST*2);
 9643   expand %{
 9644     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
 9645     iRegIdst tmpI;
 9646     maskI_reg_imm(tmpI, src2, mask);
 9647     arShiftI_reg_reg(dst, src1, tmpI);
 9648   %}
 9649 %}
 9650 
 9651 // Register Arithmetic Shift Right Immediate
 9652 instruct arShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
 9653   match(Set dst (RShiftI src1 src2));
 9654 
 9655   format %{ &quot;SRAWI   $dst, $src1, ($src2 &amp; 0x1f)&quot; %}
 9656   size(4);
 9657   ins_encode %{
 9658     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
 9659     __ srawi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
 9660   %}
 9661   ins_pipe(pipe_class_default);
 9662 %}
 9663 
 9664 instruct arShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9665   // no match-rule, false predicate
 9666   effect(DEF dst, USE src1, USE src2);
 9667   predicate(false);
 9668 
 9669   format %{ &quot;SRAD    $dst, $src1, $src2&quot; %}
 9670   size(4);
 9671   ins_encode %{
 9672     // TODO: PPC port $archOpcode(ppc64Opcode_srad);
 9673     __ srad($dst$$Register, $src1$$Register, $src2$$Register);
 9674   %}
 9675   ins_pipe(pipe_class_default);
 9676 %}
 9677 
 9678 // Register Shift Right Arithmetic Long
 9679 instruct arShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9680   match(Set dst (RShiftL src1 src2));
 9681   ins_cost(DEFAULT_COST*2);
 9682 
 9683   expand %{
 9684     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
 9685     iRegIdst tmpI;
 9686     maskI_reg_imm(tmpI, src2, mask);
 9687     arShiftL_regL_regI(dst, src1, tmpI);
 9688   %}
 9689 %}
 9690 
 9691 // Register Shift Right Immediate
 9692 instruct arShiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
 9693   match(Set dst (RShiftL src1 src2));
 9694 
 9695   format %{ &quot;SRADI   $dst, $src1, ($src2 &amp; 0x3f)&quot; %}
 9696   size(4);
 9697   ins_encode %{
 9698     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9699     __ sradi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9700   %}
 9701   ins_pipe(pipe_class_default);
 9702 %}
 9703 
 9704 // RShiftL + ConvL2I
 9705 instruct convL2I_arShiftL_regL_immI(iRegIdst dst, iRegLsrc src1, immI src2) %{
 9706   match(Set dst (ConvL2I (RShiftL src1 src2)));
 9707 
 9708   format %{ &quot;SRADI   $dst, $src1, ($src2 &amp; 0x3f) \t// long + l2i&quot; %}
 9709   size(4);
 9710   ins_encode %{
 9711     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9712     __ sradi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9713   %}
 9714   ins_pipe(pipe_class_default);
 9715 %}
 9716 
 9717 instruct urShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9718   // no match-rule, false predicate
 9719   effect(DEF dst, USE src1, USE src2);
 9720   predicate(false);
 9721 
 9722   format %{ &quot;SRW     $dst, $src1, $src2&quot; %}
 9723   size(4);
 9724   ins_encode %{
 9725     // TODO: PPC port $archOpcode(ppc64Opcode_srw);
 9726     __ srw($dst$$Register, $src1$$Register, $src2$$Register);
 9727   %}
 9728   ins_pipe(pipe_class_default);
 9729 %}
 9730 
 9731 // Register Shift Right
 9732 instruct urShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9733   match(Set dst (URShiftI src1 src2));
 9734   ins_cost(DEFAULT_COST*2);
 9735 
 9736   expand %{
 9737     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
 9738     iRegIdst tmpI;
 9739     maskI_reg_imm(tmpI, src2, mask);
 9740     urShiftI_reg_reg(dst, src1, tmpI);
 9741   %}
 9742 %}
 9743 
 9744 // Register Shift Right Immediate
 9745 instruct urShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
 9746   match(Set dst (URShiftI src1 src2));
 9747 
 9748   format %{ &quot;SRWI    $dst, $src1, ($src2 &amp; 0x1f)&quot; %}
 9749   size(4);
 9750   ins_encode %{
 9751     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9752     __ srwi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
 9753   %}
 9754   ins_pipe(pipe_class_default);
 9755 %}
 9756 
 9757 instruct urShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9758   // no match-rule, false predicate
 9759   effect(DEF dst, USE src1, USE src2);
 9760   predicate(false);
 9761 
 9762   format %{ &quot;SRD     $dst, $src1, $src2&quot; %}
 9763   size(4);
 9764   ins_encode %{
 9765     // TODO: PPC port $archOpcode(ppc64Opcode_srd);
 9766     __ srd($dst$$Register, $src1$$Register, $src2$$Register);
 9767   %}
 9768   ins_pipe(pipe_class_default);
 9769 %}
 9770 
 9771 // Register Shift Right
 9772 instruct urShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9773   match(Set dst (URShiftL src1 src2));
 9774   ins_cost(DEFAULT_COST*2);
 9775 
 9776   expand %{
 9777     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
 9778     iRegIdst tmpI;
 9779     maskI_reg_imm(tmpI, src2, mask);
 9780     urShiftL_regL_regI(dst, src1, tmpI);
 9781   %}
 9782 %}
 9783 
 9784 // Register Shift Right Immediate
 9785 instruct urShiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
 9786   match(Set dst (URShiftL src1 src2));
 9787 
 9788   format %{ &quot;SRDI    $dst, $src1, ($src2 &amp; 0x3f)&quot; %}
 9789   size(4);
 9790   ins_encode %{
 9791     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9792     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9793   %}
 9794   ins_pipe(pipe_class_default);
 9795 %}
 9796 
 9797 // URShiftL + ConvL2I.
 9798 instruct convL2I_urShiftL_regL_immI(iRegIdst dst, iRegLsrc src1, immI src2) %{
 9799   match(Set dst (ConvL2I (URShiftL src1 src2)));
 9800 
 9801   format %{ &quot;SRDI    $dst, $src1, ($src2 &amp; 0x3f) \t// long + l2i&quot; %}
 9802   size(4);
 9803   ins_encode %{
 9804     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9805     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9806   %}
 9807   ins_pipe(pipe_class_default);
 9808 %}
 9809 
 9810 // Register Shift Right Immediate with a CastP2X
 9811 instruct shrP_convP2X_reg_imm6(iRegLdst dst, iRegP_N2P src1, uimmI6 src2) %{
 9812   match(Set dst (URShiftL (CastP2X src1) src2));
 9813 
 9814   format %{ &quot;SRDI    $dst, $src1, $src2 \t// Cast ptr $src1 to long and shift&quot; %}
 9815   size(4);
 9816   ins_encode %{
 9817     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9818     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9819   %}
 9820   ins_pipe(pipe_class_default);
 9821 %}
 9822 
 9823 // Bitfield Extract: URShiftI + AndI
 9824 instruct andI_urShiftI_regI_immI_immIpow2minus1(iRegIdst dst, iRegIsrc src1, immI src2, immIpow2minus1 src3) %{
 9825   match(Set dst (AndI (URShiftI src1 src2) src3));
 9826 
 9827   format %{ &quot;EXTRDI  $dst, $src1, shift=$src2, mask=$src3 \t// int bitfield extract&quot; %}
 9828   size(4);
 9829   ins_encode %{
 9830     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9831     int rshift = ($src2$$constant) &amp; 0x1f;
 9832     int length = log2_long(((jlong) $src3$$constant) + 1);
 9833     if (rshift + length &gt; 32) {
 9834       // if necessary, adjust mask to omit rotated bits.
 9835       length = 32 - rshift;
 9836     }
 9837     __ extrdi($dst$$Register, $src1$$Register, length, 64 - (rshift + length));
 9838   %}
 9839   ins_pipe(pipe_class_default);
 9840 %}
 9841 
 9842 // Bitfield Extract: URShiftL + AndL
 9843 instruct andL_urShiftL_regL_immI_immLpow2minus1(iRegLdst dst, iRegLsrc src1, immI src2, immLpow2minus1 src3) %{
 9844   match(Set dst (AndL (URShiftL src1 src2) src3));
 9845 
 9846   format %{ &quot;EXTRDI  $dst, $src1, shift=$src2, mask=$src3 \t// long bitfield extract&quot; %}
 9847   size(4);
 9848   ins_encode %{
 9849     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9850     int rshift  = ($src2$$constant) &amp; 0x3f;
 9851     int length = log2_long(((jlong) $src3$$constant) + 1);
 9852     if (rshift + length &gt; 64) {
 9853       // if necessary, adjust mask to omit rotated bits.
 9854       length = 64 - rshift;
 9855     }
 9856     __ extrdi($dst$$Register, $src1$$Register, length, 64 - (rshift + length));
 9857   %}
 9858   ins_pipe(pipe_class_default);
 9859 %}
 9860 
 9861 instruct sxtI_reg(iRegIdst dst, iRegIsrc src) %{
 9862   match(Set dst (ConvL2I (ConvI2L src)));
 9863 
 9864   format %{ &quot;EXTSW   $dst, $src \t// int-&gt;int&quot; %}
 9865   size(4);
 9866   ins_encode %{
 9867     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
 9868     __ extsw($dst$$Register, $src$$Register);
 9869   %}
 9870   ins_pipe(pipe_class_default);
 9871 %}
 9872 
 9873 //----------Rotate Instructions------------------------------------------------
 9874 
 9875 // Rotate Left by 8-bit immediate
 9876 instruct rotlI_reg_immi8(iRegIdst dst, iRegIsrc src, immI8 lshift, immI8 rshift) %{
 9877   match(Set dst (OrI (LShiftI src lshift) (URShiftI src rshift)));
 9878   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9879 
 9880   format %{ &quot;ROTLWI  $dst, $src, $lshift&quot; %}
 9881   size(4);
 9882   ins_encode %{
 9883     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9884     __ rotlwi($dst$$Register, $src$$Register, $lshift$$constant);
 9885   %}
 9886   ins_pipe(pipe_class_default);
 9887 %}
 9888 
 9889 // Rotate Right by 8-bit immediate
 9890 instruct rotrI_reg_immi8(iRegIdst dst, iRegIsrc src, immI8 rshift, immI8 lshift) %{
 9891   match(Set dst (OrI (URShiftI src rshift) (LShiftI src lshift)));
 9892   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9893 
 9894   format %{ &quot;ROTRWI  $dst, $rshift&quot; %}
 9895   size(4);
 9896   ins_encode %{
 9897     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9898     __ rotrwi($dst$$Register, $src$$Register, $rshift$$constant);
 9899   %}
 9900   ins_pipe(pipe_class_default);
 9901 %}
 9902 
 9903 //----------Floating Point Arithmetic Instructions-----------------------------
 9904 
 9905 // Add float single precision
 9906 instruct addF_reg_reg(regF dst, regF src1, regF src2) %{
 9907   match(Set dst (AddF src1 src2));
 9908 
 9909   format %{ &quot;FADDS   $dst, $src1, $src2&quot; %}
 9910   size(4);
 9911   ins_encode %{
 9912     // TODO: PPC port $archOpcode(ppc64Opcode_fadds);
 9913     __ fadds($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9914   %}
 9915   ins_pipe(pipe_class_default);
 9916 %}
 9917 
 9918 // Add float double precision
 9919 instruct addD_reg_reg(regD dst, regD src1, regD src2) %{
 9920   match(Set dst (AddD src1 src2));
 9921 
 9922   format %{ &quot;FADD    $dst, $src1, $src2&quot; %}
 9923   size(4);
 9924   ins_encode %{
 9925     // TODO: PPC port $archOpcode(ppc64Opcode_fadd);
 9926     __ fadd($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9927   %}
 9928   ins_pipe(pipe_class_default);
 9929 %}
 9930 
 9931 // Sub float single precision
 9932 instruct subF_reg_reg(regF dst, regF src1, regF src2) %{
 9933   match(Set dst (SubF src1 src2));
 9934 
 9935   format %{ &quot;FSUBS   $dst, $src1, $src2&quot; %}
 9936   size(4);
 9937   ins_encode %{
 9938     // TODO: PPC port $archOpcode(ppc64Opcode_fsubs);
 9939     __ fsubs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9940   %}
 9941   ins_pipe(pipe_class_default);
 9942 %}
 9943 
 9944 // Sub float double precision
 9945 instruct subD_reg_reg(regD dst, regD src1, regD src2) %{
 9946   match(Set dst (SubD src1 src2));
 9947   format %{ &quot;FSUB    $dst, $src1, $src2&quot; %}
 9948   size(4);
 9949   ins_encode %{
 9950     // TODO: PPC port $archOpcode(ppc64Opcode_fsub);
 9951     __ fsub($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9952   %}
 9953   ins_pipe(pipe_class_default);
 9954 %}
 9955 
 9956 // Mul float single precision
 9957 instruct mulF_reg_reg(regF dst, regF src1, regF src2) %{
 9958   match(Set dst (MulF src1 src2));
 9959   format %{ &quot;FMULS   $dst, $src1, $src2&quot; %}
 9960   size(4);
 9961   ins_encode %{
 9962     // TODO: PPC port $archOpcode(ppc64Opcode_fmuls);
 9963     __ fmuls($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9964   %}
 9965   ins_pipe(pipe_class_default);
 9966 %}
 9967 
 9968 // Mul float double precision
 9969 instruct mulD_reg_reg(regD dst, regD src1, regD src2) %{
 9970   match(Set dst (MulD src1 src2));
 9971   format %{ &quot;FMUL    $dst, $src1, $src2&quot; %}
 9972   size(4);
 9973   ins_encode %{
 9974     // TODO: PPC port $archOpcode(ppc64Opcode_fmul);
 9975     __ fmul($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9976   %}
 9977   ins_pipe(pipe_class_default);
 9978 %}
 9979 
 9980 // Div float single precision
 9981 instruct divF_reg_reg(regF dst, regF src1, regF src2) %{
 9982   match(Set dst (DivF src1 src2));
 9983   format %{ &quot;FDIVS   $dst, $src1, $src2&quot; %}
 9984   size(4);
 9985   ins_encode %{
 9986     // TODO: PPC port $archOpcode(ppc64Opcode_fdivs);
 9987     __ fdivs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9988   %}
 9989   ins_pipe(pipe_class_default);
 9990 %}
 9991 
 9992 // Div float double precision
 9993 instruct divD_reg_reg(regD dst, regD src1, regD src2) %{
 9994   match(Set dst (DivD src1 src2));
 9995   format %{ &quot;FDIV    $dst, $src1, $src2&quot; %}
 9996   size(4);
 9997   ins_encode %{
 9998     // TODO: PPC port $archOpcode(ppc64Opcode_fdiv);
 9999     __ fdiv($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
10000   %}
10001   ins_pipe(pipe_class_default);
10002 %}
10003 
10004 // Absolute float single precision
10005 instruct absF_reg(regF dst, regF src) %{
10006   match(Set dst (AbsF src));
10007   format %{ &quot;FABS    $dst, $src \t// float&quot; %}
10008   size(4);
10009   ins_encode %{
10010     // TODO: PPC port $archOpcode(ppc64Opcode_fabs);
10011     __ fabs($dst$$FloatRegister, $src$$FloatRegister);
10012   %}
10013   ins_pipe(pipe_class_default);
10014 %}
10015 
10016 // Absolute float double precision
10017 instruct absD_reg(regD dst, regD src) %{
10018   match(Set dst (AbsD src));
10019   format %{ &quot;FABS    $dst, $src \t// double&quot; %}
10020   size(4);
10021   ins_encode %{
10022     // TODO: PPC port $archOpcode(ppc64Opcode_fabs);
10023     __ fabs($dst$$FloatRegister, $src$$FloatRegister);
10024   %}
10025   ins_pipe(pipe_class_default);
10026 %}
10027 
10028 instruct negF_reg(regF dst, regF src) %{
10029   match(Set dst (NegF src));
10030   format %{ &quot;FNEG    $dst, $src \t// float&quot; %}
10031   size(4);
10032   ins_encode %{
10033     // TODO: PPC port $archOpcode(ppc64Opcode_fneg);
10034     __ fneg($dst$$FloatRegister, $src$$FloatRegister);
10035   %}
10036   ins_pipe(pipe_class_default);
10037 %}
10038 
10039 instruct negD_reg(regD dst, regD src) %{
10040   match(Set dst (NegD src));
10041   format %{ &quot;FNEG    $dst, $src \t// double&quot; %}
10042   size(4);
10043   ins_encode %{
10044     // TODO: PPC port $archOpcode(ppc64Opcode_fneg);
10045     __ fneg($dst$$FloatRegister, $src$$FloatRegister);
10046   %}
10047   ins_pipe(pipe_class_default);
10048 %}
10049 
10050 // AbsF + NegF.
10051 instruct negF_absF_reg(regF dst, regF src) %{
10052   match(Set dst (NegF (AbsF src)));
10053   format %{ &quot;FNABS   $dst, $src \t// float&quot; %}
10054   size(4);
10055   ins_encode %{
10056     // TODO: PPC port $archOpcode(ppc64Opcode_fnabs);
10057     __ fnabs($dst$$FloatRegister, $src$$FloatRegister);
10058   %}
10059   ins_pipe(pipe_class_default);
10060 %}
10061 
10062 // AbsD + NegD.
10063 instruct negD_absD_reg(regD dst, regD src) %{
10064   match(Set dst (NegD (AbsD src)));
10065   format %{ &quot;FNABS   $dst, $src \t// double&quot; %}
10066   size(4);
10067   ins_encode %{
10068     // TODO: PPC port $archOpcode(ppc64Opcode_fnabs);
10069     __ fnabs($dst$$FloatRegister, $src$$FloatRegister);
10070   %}
10071   ins_pipe(pipe_class_default);
10072 %}
10073 
10074 // VM_Version::has_fsqrt() decides if this node will be used.
10075 // Sqrt float double precision
10076 instruct sqrtD_reg(regD dst, regD src) %{
10077   match(Set dst (SqrtD src));
10078   format %{ &quot;FSQRT   $dst, $src&quot; %}
10079   size(4);
10080   ins_encode %{
10081     // TODO: PPC port $archOpcode(ppc64Opcode_fsqrt);
10082     __ fsqrt($dst$$FloatRegister, $src$$FloatRegister);
10083   %}
10084   ins_pipe(pipe_class_default);
10085 %}
10086 
10087 // Single-precision sqrt.
10088 instruct sqrtF_reg(regF dst, regF src) %{
10089   match(Set dst (SqrtF src));
10090   predicate(VM_Version::has_fsqrts());
10091   ins_cost(DEFAULT_COST);
10092 
10093   format %{ &quot;FSQRTS  $dst, $src&quot; %}
10094   size(4);
10095   ins_encode %{
10096     // TODO: PPC port $archOpcode(ppc64Opcode_fsqrts);
10097     __ fsqrts($dst$$FloatRegister, $src$$FloatRegister);
10098   %}
10099   ins_pipe(pipe_class_default);
10100 %}
10101 
10102 instruct roundDouble_nop(regD dst) %{
10103   match(Set dst (RoundDouble dst));
10104   ins_cost(0);
10105 
10106   format %{ &quot; -- \t// RoundDouble not needed - empty&quot; %}
10107   size(0);
10108   // PPC results are already &quot;rounded&quot; (i.e., normal-format IEEE).
10109   ins_encode( /*empty*/ );
10110   ins_pipe(pipe_class_default);
10111 %}
10112 
10113 instruct roundFloat_nop(regF dst) %{
10114   match(Set dst (RoundFloat dst));
10115   ins_cost(0);
10116 
10117   format %{ &quot; -- \t// RoundFloat not needed - empty&quot; %}
10118   size(0);
10119   // PPC results are already &quot;rounded&quot; (i.e., normal-format IEEE).
10120   ins_encode( /*empty*/ );
10121   ins_pipe(pipe_class_default);
10122 %}
10123 
10124 
10125 // Multiply-Accumulate
10126 // src1 * src2 + src3
10127 instruct maddF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10128   match(Set dst (FmaF src3 (Binary src1 src2)));
10129 
10130   format %{ &quot;FMADDS  $dst, $src1, $src2, $src3&quot; %}
10131   size(4);
10132   ins_encode %{
10133     // TODO: PPC port $archOpcode(ppc64Opcode_fmadds);
10134     __ fmadds($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10135   %}
10136   ins_pipe(pipe_class_default);
10137 %}
10138 
10139 // src1 * src2 + src3
10140 instruct maddD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10141   match(Set dst (FmaD src3 (Binary src1 src2)));
10142 
10143   format %{ &quot;FMADD   $dst, $src1, $src2, $src3&quot; %}
10144   size(4);
10145   ins_encode %{
10146     // TODO: PPC port $archOpcode(ppc64Opcode_fmadd);
10147     __ fmadd($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10148   %}
10149   ins_pipe(pipe_class_default);
10150 %}
10151 
10152 // -src1 * src2 + src3 = -(src1*src2-src3)
10153 instruct mnsubF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10154   match(Set dst (FmaF src3 (Binary (NegF src1) src2)));
10155   match(Set dst (FmaF src3 (Binary src1 (NegF src2))));
10156 
10157   format %{ &quot;FNMSUBS $dst, $src1, $src2, $src3&quot; %}
10158   size(4);
10159   ins_encode %{
10160     // TODO: PPC port $archOpcode(ppc64Opcode_fnmsubs);
10161     __ fnmsubs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10162   %}
10163   ins_pipe(pipe_class_default);
10164 %}
10165 
10166 // -src1 * src2 + src3 = -(src1*src2-src3)
10167 instruct mnsubD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10168   match(Set dst (FmaD src3 (Binary (NegD src1) src2)));
10169   match(Set dst (FmaD src3 (Binary src1 (NegD src2))));
10170 
10171   format %{ &quot;FNMSUB  $dst, $src1, $src2, $src3&quot; %}
10172   size(4);
10173   ins_encode %{
10174     // TODO: PPC port $archOpcode(ppc64Opcode_fnmsub);
10175     __ fnmsub($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10176   %}
10177   ins_pipe(pipe_class_default);
10178 %}
10179 
10180 // -src1 * src2 - src3 = -(src1*src2+src3)
10181 instruct mnaddF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10182   match(Set dst (FmaF (NegF src3) (Binary (NegF src1) src2)));
10183   match(Set dst (FmaF (NegF src3) (Binary src1 (NegF src2))));
10184 
10185   format %{ &quot;FNMADDS $dst, $src1, $src2, $src3&quot; %}
10186   size(4);
10187   ins_encode %{
10188     // TODO: PPC port $archOpcode(ppc64Opcode_fnmadds);
10189     __ fnmadds($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10190   %}
10191   ins_pipe(pipe_class_default);
10192 %}
10193 
10194 // -src1 * src2 - src3 = -(src1*src2+src3)
10195 instruct mnaddD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10196   match(Set dst (FmaD (NegD src3) (Binary (NegD src1) src2)));
10197   match(Set dst (FmaD (NegD src3) (Binary src1 (NegD src2))));
10198 
10199   format %{ &quot;FNMADD  $dst, $src1, $src2, $src3&quot; %}
10200   size(4);
10201   ins_encode %{
10202     // TODO: PPC port $archOpcode(ppc64Opcode_fnmadd);
10203     __ fnmadd($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10204   %}
10205   ins_pipe(pipe_class_default);
10206 %}
10207 
10208 // src1 * src2 - src3
10209 instruct msubF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10210   match(Set dst (FmaF (NegF src3) (Binary src1 src2)));
10211 
10212   format %{ &quot;FMSUBS  $dst, $src1, $src2, $src3&quot; %}
10213   size(4);
10214   ins_encode %{
10215     // TODO: PPC port $archOpcode(ppc64Opcode_fmsubs);
10216     __ fmsubs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10217   %}
10218   ins_pipe(pipe_class_default);
10219 %}
10220 
10221 // src1 * src2 - src3
10222 instruct msubD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10223   match(Set dst (FmaD (NegD src3) (Binary src1 src2)));
10224 
10225   format %{ &quot;FMSUB   $dst, $src1, $src2, $src3&quot; %}
10226   size(4);
10227   ins_encode %{
10228     // TODO: PPC port $archOpcode(ppc64Opcode_fmsub);
10229     __ fmsub($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10230   %}
10231   ins_pipe(pipe_class_default);
10232 %}
10233 
10234 
10235 //----------Logical Instructions-----------------------------------------------
10236 
10237 // And Instructions
10238 
10239 // Register And
10240 instruct andI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10241   match(Set dst (AndI src1 src2));
10242   format %{ &quot;AND     $dst, $src1, $src2&quot; %}
10243   size(4);
10244   ins_encode %{
10245     // TODO: PPC port $archOpcode(ppc64Opcode_and);
10246     __ andr($dst$$Register, $src1$$Register, $src2$$Register);
10247   %}
10248   ins_pipe(pipe_class_default);
10249 %}
10250 
10251 // Left shifted Immediate And
10252 instruct andI_reg_immIhi16(iRegIdst dst, iRegIsrc src1, immIhi16  src2, flagsRegCR0 cr0) %{
10253   match(Set dst (AndI src1 src2));
10254   effect(KILL cr0);
10255   format %{ &quot;ANDIS   $dst, $src1, $src2.hi&quot; %}
10256   size(4);
10257   ins_encode %{
10258     // TODO: PPC port $archOpcode(ppc64Opcode_andis_);
10259     __ andis_($dst$$Register, $src1$$Register, (int)((unsigned short)(($src2$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
10260   %}
10261   ins_pipe(pipe_class_default);
10262 %}
10263 
10264 // Immediate And
10265 instruct andI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2, flagsRegCR0 cr0) %{
10266   match(Set dst (AndI src1 src2));
10267   effect(KILL cr0);
10268 
10269   format %{ &quot;ANDI    $dst, $src1, $src2&quot; %}
10270   size(4);
10271   ins_encode %{
10272     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
10273     // FIXME: avoid andi_ ?
10274     __ andi_($dst$$Register, $src1$$Register, $src2$$constant);
10275   %}
10276   ins_pipe(pipe_class_default);
10277 %}
10278 
10279 // Immediate And where the immediate is a negative power of 2.
10280 instruct andI_reg_immInegpow2(iRegIdst dst, iRegIsrc src1, immInegpow2 src2) %{
10281   match(Set dst (AndI src1 src2));
10282   format %{ &quot;ANDWI   $dst, $src1, $src2&quot; %}
10283   size(4);
10284   ins_encode %{
10285     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
10286     __ clrrdi($dst$$Register, $src1$$Register, log2_long((jlong)(julong)(juint)-($src2$$constant)));
10287   %}
10288   ins_pipe(pipe_class_default);
10289 %}
10290 
10291 instruct andI_reg_immIpow2minus1(iRegIdst dst, iRegIsrc src1, immIpow2minus1 src2) %{
10292   match(Set dst (AndI src1 src2));
10293   format %{ &quot;ANDWI   $dst, $src1, $src2&quot; %}
10294   size(4);
10295   ins_encode %{
10296     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
10297     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
10298   %}
10299   ins_pipe(pipe_class_default);
10300 %}
10301 
10302 instruct andI_reg_immIpowerOf2(iRegIdst dst, iRegIsrc src1, immIpowerOf2 src2) %{
10303   match(Set dst (AndI src1 src2));
10304   predicate(UseRotateAndMaskInstructionsPPC64);
10305   format %{ &quot;ANDWI   $dst, $src1, $src2&quot; %}
10306   size(4);
10307   ins_encode %{
10308     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
10309     __ rlwinm($dst$$Register, $src1$$Register, 0,
10310               (31-log2_long((jlong) $src2$$constant)) &amp; 0x1f, (31-log2_long((jlong) $src2$$constant)) &amp; 0x1f);
10311   %}
10312   ins_pipe(pipe_class_default);
10313 %}
10314 
10315 // Register And Long
10316 instruct andL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10317   match(Set dst (AndL src1 src2));
10318   ins_cost(DEFAULT_COST);
10319 
10320   format %{ &quot;AND     $dst, $src1, $src2 \t// long&quot; %}
10321   size(4);
10322   ins_encode %{
10323     // TODO: PPC port $archOpcode(ppc64Opcode_and);
10324     __ andr($dst$$Register, $src1$$Register, $src2$$Register);
10325   %}
10326   ins_pipe(pipe_class_default);
10327 %}
10328 
10329 // Immediate And long
10330 instruct andL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 src2, flagsRegCR0 cr0) %{
10331   match(Set dst (AndL src1 src2));
10332   effect(KILL cr0);
10333 
10334   format %{ &quot;ANDI    $dst, $src1, $src2 \t// long&quot; %}
10335   size(4);
10336   ins_encode %{
10337     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
10338     // FIXME: avoid andi_ ?
10339     __ andi_($dst$$Register, $src1$$Register, $src2$$constant);
10340   %}
10341   ins_pipe(pipe_class_default);
10342 %}
10343 
10344 // Immediate And Long where the immediate is a negative power of 2.
10345 instruct andL_reg_immLnegpow2(iRegLdst dst, iRegLsrc src1, immLnegpow2 src2) %{
10346   match(Set dst (AndL src1 src2));
10347   format %{ &quot;ANDDI   $dst, $src1, $src2&quot; %}
10348   size(4);
10349   ins_encode %{
10350     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
10351     __ clrrdi($dst$$Register, $src1$$Register, log2_long((jlong)-$src2$$constant));
10352   %}
10353   ins_pipe(pipe_class_default);
10354 %}
10355 
10356 instruct andL_reg_immLpow2minus1(iRegLdst dst, iRegLsrc src1, immLpow2minus1 src2) %{
10357   match(Set dst (AndL src1 src2));
10358   format %{ &quot;ANDDI   $dst, $src1, $src2&quot; %}
10359   size(4);
10360   ins_encode %{
10361     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
10362     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
10363   %}
10364   ins_pipe(pipe_class_default);
10365 %}
10366 
10367 // AndL + ConvL2I.
10368 instruct convL2I_andL_reg_immLpow2minus1(iRegIdst dst, iRegLsrc src1, immLpow2minus1 src2) %{
10369   match(Set dst (ConvL2I (AndL src1 src2)));
10370   ins_cost(DEFAULT_COST);
10371 
10372   format %{ &quot;ANDDI   $dst, $src1, $src2 \t// long + l2i&quot; %}
10373   size(4);
10374   ins_encode %{
10375     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
10376     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
10377   %}
10378   ins_pipe(pipe_class_default);
10379 %}
10380 
10381 // Or Instructions
10382 
10383 // Register Or
10384 instruct orI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10385   match(Set dst (OrI src1 src2));
10386   format %{ &quot;OR      $dst, $src1, $src2&quot; %}
10387   size(4);
10388   ins_encode %{
10389     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10390     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10391   %}
10392   ins_pipe(pipe_class_default);
10393 %}
10394 
10395 // Expand does not work with above instruct. (??)
10396 instruct orI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10397   // no match-rule
10398   effect(DEF dst, USE src1, USE src2);
10399   format %{ &quot;OR      $dst, $src1, $src2&quot; %}
10400   size(4);
10401   ins_encode %{
10402     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10403     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10404   %}
10405   ins_pipe(pipe_class_default);
10406 %}
10407 
10408 instruct tree_orI_orI_orI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
10409   match(Set dst (OrI (OrI (OrI src1 src2) src3) src4));
10410   ins_cost(DEFAULT_COST*3);
10411 
10412   expand %{
10413     // FIXME: we should do this in the ideal world.
10414     iRegIdst tmp1;
10415     iRegIdst tmp2;
10416     orI_reg_reg(tmp1, src1, src2);
10417     orI_reg_reg_2(tmp2, src3, src4); // Adlc complains about orI_reg_reg.
10418     orI_reg_reg(dst, tmp1, tmp2);
10419   %}
10420 %}
10421 
10422 // Immediate Or
10423 instruct orI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2) %{
10424   match(Set dst (OrI src1 src2));
10425   format %{ &quot;ORI     $dst, $src1, $src2&quot; %}
10426   size(4);
10427   ins_encode %{
10428     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
10429     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
10430   %}
10431   ins_pipe(pipe_class_default);
10432 %}
10433 
10434 // Register Or Long
10435 instruct orL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10436   match(Set dst (OrL src1 src2));
10437   ins_cost(DEFAULT_COST);
10438 
10439   size(4);
10440   format %{ &quot;OR      $dst, $src1, $src2 \t// long&quot; %}
10441   ins_encode %{
10442     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10443     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10444   %}
10445   ins_pipe(pipe_class_default);
10446 %}
10447 
10448 // OrL + ConvL2I.
10449 instruct orI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
10450   match(Set dst (ConvL2I (OrL src1 src2)));
10451   ins_cost(DEFAULT_COST);
10452 
10453   format %{ &quot;OR      $dst, $src1, $src2 \t// long + l2i&quot; %}
10454   size(4);
10455   ins_encode %{
10456     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10457     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10458   %}
10459   ins_pipe(pipe_class_default);
10460 %}
10461 
10462 // Immediate Or long
10463 instruct orL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 con) %{
10464   match(Set dst (OrL src1 con));
10465   ins_cost(DEFAULT_COST);
10466 
10467   format %{ &quot;ORI     $dst, $src1, $con \t// long&quot; %}
10468   size(4);
10469   ins_encode %{
10470     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
10471     __ ori($dst$$Register, $src1$$Register, ($con$$constant) &amp; 0xFFFF);
10472   %}
10473   ins_pipe(pipe_class_default);
10474 %}
10475 
10476 // Xor Instructions
10477 
10478 // Register Xor
10479 instruct xorI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10480   match(Set dst (XorI src1 src2));
10481   format %{ &quot;XOR     $dst, $src1, $src2&quot; %}
10482   size(4);
10483   ins_encode %{
10484     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10485     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10486   %}
10487   ins_pipe(pipe_class_default);
10488 %}
10489 
10490 // Expand does not work with above instruct. (??)
10491 instruct xorI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10492   // no match-rule
10493   effect(DEF dst, USE src1, USE src2);
10494   format %{ &quot;XOR     $dst, $src1, $src2&quot; %}
10495   size(4);
10496   ins_encode %{
10497     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10498     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10499   %}
10500   ins_pipe(pipe_class_default);
10501 %}
10502 
10503 instruct tree_xorI_xorI_xorI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
10504   match(Set dst (XorI (XorI (XorI src1 src2) src3) src4));
10505   ins_cost(DEFAULT_COST*3);
10506 
10507   expand %{
10508     // FIXME: we should do this in the ideal world.
10509     iRegIdst tmp1;
10510     iRegIdst tmp2;
10511     xorI_reg_reg(tmp1, src1, src2);
10512     xorI_reg_reg_2(tmp2, src3, src4); // Adlc complains about xorI_reg_reg.
10513     xorI_reg_reg(dst, tmp1, tmp2);
10514   %}
10515 %}
10516 
10517 // Immediate Xor
10518 instruct xorI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2) %{
10519   match(Set dst (XorI src1 src2));
10520   format %{ &quot;XORI    $dst, $src1, $src2&quot; %}
10521   size(4);
10522   ins_encode %{
10523     // TODO: PPC port $archOpcode(ppc64Opcode_xori);
10524     __ xori($dst$$Register, $src1$$Register, $src2$$constant);
10525   %}
10526   ins_pipe(pipe_class_default);
10527 %}
10528 
10529 // Register Xor Long
10530 instruct xorL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10531   match(Set dst (XorL src1 src2));
10532   ins_cost(DEFAULT_COST);
10533 
10534   format %{ &quot;XOR     $dst, $src1, $src2 \t// long&quot; %}
10535   size(4);
10536   ins_encode %{
10537     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10538     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10539   %}
10540   ins_pipe(pipe_class_default);
10541 %}
10542 
10543 // XorL + ConvL2I.
10544 instruct xorI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
10545   match(Set dst (ConvL2I (XorL src1 src2)));
10546   ins_cost(DEFAULT_COST);
10547 
10548   format %{ &quot;XOR     $dst, $src1, $src2 \t// long + l2i&quot; %}
10549   size(4);
10550   ins_encode %{
10551     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10552     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10553   %}
10554   ins_pipe(pipe_class_default);
10555 %}
10556 
10557 // Immediate Xor Long
10558 instruct xorL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 src2) %{
10559   match(Set dst (XorL src1 src2));
10560   ins_cost(DEFAULT_COST);
10561 
10562   format %{ &quot;XORI    $dst, $src1, $src2 \t// long&quot; %}
10563   size(4);
10564   ins_encode %{
10565     // TODO: PPC port $archOpcode(ppc64Opcode_xori);
10566     __ xori($dst$$Register, $src1$$Register, $src2$$constant);
10567   %}
10568   ins_pipe(pipe_class_default);
10569 %}
10570 
10571 instruct notI_reg(iRegIdst dst, iRegIsrc src1, immI_minus1 src2) %{
10572   match(Set dst (XorI src1 src2));
10573   ins_cost(DEFAULT_COST);
10574 
10575   format %{ &quot;NOT     $dst, $src1 ($src2)&quot; %}
10576   size(4);
10577   ins_encode %{
10578     // TODO: PPC port $archOpcode(ppc64Opcode_nor);
10579     __ nor($dst$$Register, $src1$$Register, $src1$$Register);
10580   %}
10581   ins_pipe(pipe_class_default);
10582 %}
10583 
10584 instruct notL_reg(iRegLdst dst, iRegLsrc src1, immL_minus1 src2) %{
10585   match(Set dst (XorL src1 src2));
10586   ins_cost(DEFAULT_COST);
10587 
10588   format %{ &quot;NOT     $dst, $src1 ($src2) \t// long&quot; %}
10589   size(4);
10590   ins_encode %{
10591     // TODO: PPC port $archOpcode(ppc64Opcode_nor);
10592     __ nor($dst$$Register, $src1$$Register, $src1$$Register);
10593   %}
10594   ins_pipe(pipe_class_default);
10595 %}
10596 
10597 // And-complement
10598 instruct andcI_reg_reg(iRegIdst dst, iRegIsrc src1, immI_minus1 src2, iRegIsrc src3) %{
10599   match(Set dst (AndI (XorI src1 src2) src3));
10600   ins_cost(DEFAULT_COST);
10601 
10602   format %{ &quot;ANDW    $dst, xori($src1, $src2), $src3&quot; %}
10603   size(4);
10604   ins_encode( enc_andc(dst, src3, src1) );
10605   ins_pipe(pipe_class_default);
10606 %}
10607 
10608 // And-complement
10609 instruct andcL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10610   // no match-rule, false predicate
10611   effect(DEF dst, USE src1, USE src2);
10612   predicate(false);
10613 
10614   format %{ &quot;ANDC    $dst, $src1, $src2&quot; %}
10615   size(4);
10616   ins_encode %{
10617     // TODO: PPC port $archOpcode(ppc64Opcode_andc);
10618     __ andc($dst$$Register, $src1$$Register, $src2$$Register);
10619   %}
10620   ins_pipe(pipe_class_default);
10621 %}
10622 
10623 //----------Moves between int/long and float/double----------------------------
10624 //
10625 // The following rules move values from int/long registers/stack-locations
10626 // to float/double registers/stack-locations and vice versa, without doing any
10627 // conversions. These rules are used to implement the bit-conversion methods
10628 // of java.lang.Float etc., e.g.
10629 //   int   floatToIntBits(float value)
10630 //   float intBitsToFloat(int bits)
10631 //
10632 // Notes on the implementation on ppc64:
10633 // For Power7 and earlier, the rules are limited to those which move between a
10634 // register and a stack-location, because we always have to go through memory
10635 // when moving between a float register and an integer register.
10636 // This restriction is removed in Power8 with the introduction of the mtfprd
10637 // and mffprd instructions.
10638 
10639 instruct moveL2D_reg(regD dst, iRegLsrc src) %{
10640   match(Set dst (MoveL2D src));
10641   predicate(VM_Version::has_mtfprd());
10642 
10643   format %{ &quot;MTFPRD  $dst, $src&quot; %}
10644   size(4);
10645   ins_encode %{
10646     __ mtfprd($dst$$FloatRegister, $src$$Register);
10647   %}
10648   ins_pipe(pipe_class_default);
10649 %}
10650 
10651 instruct moveI2D_reg(regD dst, iRegIsrc src) %{
10652   // no match-rule, false predicate
10653   effect(DEF dst, USE src);
10654   predicate(false);
10655 
10656   format %{ &quot;MTFPRWA $dst, $src&quot; %}
10657   size(4);
10658   ins_encode %{
10659     __ mtfprwa($dst$$FloatRegister, $src$$Register);
10660   %}
10661   ins_pipe(pipe_class_default);
10662 %}
10663 
10664 //---------- Chain stack slots between similar types --------
10665 
10666 // These are needed so that the rules below can match.
10667 
10668 // Load integer from stack slot
10669 instruct stkI_to_regI(iRegIdst dst, stackSlotI src) %{
10670   match(Set dst src);
10671   ins_cost(MEMORY_REF_COST);
10672 
10673   format %{ &quot;LWZ     $dst, $src&quot; %}
10674   size(4);
10675   ins_encode( enc_lwz(dst, src) );
10676   ins_pipe(pipe_class_memory);
10677 %}
10678 
10679 // Store integer to stack slot
10680 instruct regI_to_stkI(stackSlotI dst, iRegIsrc src) %{
10681   match(Set dst src);
10682   ins_cost(MEMORY_REF_COST);
10683 
10684   format %{ &quot;STW     $src, $dst \t// stk&quot; %}
10685   size(4);
10686   ins_encode( enc_stw(src, dst) ); // rs=rt
10687   ins_pipe(pipe_class_memory);
10688 %}
10689 
10690 // Load long from stack slot
10691 instruct stkL_to_regL(iRegLdst dst, stackSlotL src) %{
10692   match(Set dst src);
10693   ins_cost(MEMORY_REF_COST);
10694 
10695   format %{ &quot;LD      $dst, $src \t// long&quot; %}
10696   size(4);
10697   ins_encode( enc_ld(dst, src) );
10698   ins_pipe(pipe_class_memory);
10699 %}
10700 
10701 // Store long to stack slot
10702 instruct regL_to_stkL(stackSlotL dst, iRegLsrc src) %{
10703   match(Set dst src);
10704   ins_cost(MEMORY_REF_COST);
10705 
10706   format %{ &quot;STD     $src, $dst \t// long&quot; %}
10707   size(4);
10708   ins_encode( enc_std(src, dst) ); // rs=rt
10709   ins_pipe(pipe_class_memory);
10710 %}
10711 
10712 //----------Moves between int and float
10713 
10714 // Move float value from float stack-location to integer register.
10715 instruct moveF2I_stack_reg(iRegIdst dst, stackSlotF src) %{
10716   match(Set dst (MoveF2I src));
10717   ins_cost(MEMORY_REF_COST);
10718 
10719   format %{ &quot;LWZ     $dst, $src \t// MoveF2I&quot; %}
10720   size(4);
10721   ins_encode( enc_lwz(dst, src) );
10722   ins_pipe(pipe_class_memory);
10723 %}
10724 
10725 // Move float value from float register to integer stack-location.
10726 instruct moveF2I_reg_stack(stackSlotI dst, regF src) %{
10727   match(Set dst (MoveF2I src));
10728   ins_cost(MEMORY_REF_COST);
10729 
10730   format %{ &quot;STFS    $src, $dst \t// MoveF2I&quot; %}
10731   size(4);
10732   ins_encode( enc_stfs(src, dst) );
10733   ins_pipe(pipe_class_memory);
10734 %}
10735 
10736 // Move integer value from integer stack-location to float register.
10737 instruct moveI2F_stack_reg(regF dst, stackSlotI src) %{
10738   match(Set dst (MoveI2F src));
10739   ins_cost(MEMORY_REF_COST);
10740 
10741   format %{ &quot;LFS     $dst, $src \t// MoveI2F&quot; %}
10742   size(4);
10743   ins_encode %{
10744     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
10745     int Idisp = $src$$disp + frame_slots_bias($src$$base, ra_);
10746     __ lfs($dst$$FloatRegister, Idisp, $src$$base$$Register);
10747   %}
10748   ins_pipe(pipe_class_memory);
10749 %}
10750 
10751 // Move integer value from integer register to float stack-location.
10752 instruct moveI2F_reg_stack(stackSlotF dst, iRegIsrc src) %{
10753   match(Set dst (MoveI2F src));
10754   ins_cost(MEMORY_REF_COST);
10755 
10756   format %{ &quot;STW     $src, $dst \t// MoveI2F&quot; %}
10757   size(4);
10758   ins_encode( enc_stw(src, dst) );
10759   ins_pipe(pipe_class_memory);
10760 %}
10761 
10762 //----------Moves between long and float
10763 
10764 instruct moveF2L_reg_stack(stackSlotL dst, regF src) %{
10765   // no match-rule, false predicate
10766   effect(DEF dst, USE src);
10767   predicate(false);
10768 
10769   format %{ &quot;storeD  $src, $dst \t// STACK&quot; %}
10770   size(4);
10771   ins_encode( enc_stfd(src, dst) );
10772   ins_pipe(pipe_class_default);
10773 %}
10774 
10775 //----------Moves between long and double
10776 
10777 // Move double value from double stack-location to long register.
10778 instruct moveD2L_stack_reg(iRegLdst dst, stackSlotD src) %{
10779   match(Set dst (MoveD2L src));
10780   ins_cost(MEMORY_REF_COST);
10781   size(4);
10782   format %{ &quot;LD      $dst, $src \t// MoveD2L&quot; %}
10783   ins_encode( enc_ld(dst, src) );
10784   ins_pipe(pipe_class_memory);
10785 %}
10786 
10787 // Move double value from double register to long stack-location.
10788 instruct moveD2L_reg_stack(stackSlotL dst, regD src) %{
10789   match(Set dst (MoveD2L src));
10790   effect(DEF dst, USE src);
10791   ins_cost(MEMORY_REF_COST);
10792 
10793   format %{ &quot;STFD    $src, $dst \t// MoveD2L&quot; %}
10794   size(4);
10795   ins_encode( enc_stfd(src, dst) );
10796   ins_pipe(pipe_class_memory);
10797 %}
10798 
10799 // Move long value from long stack-location to double register.
10800 instruct moveL2D_stack_reg(regD dst, stackSlotL src) %{
10801   match(Set dst (MoveL2D src));
10802   ins_cost(MEMORY_REF_COST);
10803 
10804   format %{ &quot;LFD     $dst, $src \t// MoveL2D&quot; %}
10805   size(4);
10806   ins_encode( enc_lfd(dst, src) );
10807   ins_pipe(pipe_class_memory);
10808 %}
10809 
10810 // Move long value from long register to double stack-location.
10811 instruct moveL2D_reg_stack(stackSlotD dst, iRegLsrc src) %{
10812   match(Set dst (MoveL2D src));
10813   ins_cost(MEMORY_REF_COST);
10814 
10815   format %{ &quot;STD     $src, $dst \t// MoveL2D&quot; %}
10816   size(4);
10817   ins_encode( enc_std(src, dst) );
10818   ins_pipe(pipe_class_memory);
10819 %}
10820 
10821 //----------Register Move Instructions-----------------------------------------
10822 
10823 // Replicate for Superword
10824 
10825 instruct moveReg(iRegLdst dst, iRegIsrc src) %{
10826   predicate(false);
10827   effect(DEF dst, USE src);
10828 
10829   format %{ &quot;MR      $dst, $src \t// replicate &quot; %}
10830   // variable size, 0 or 4.
10831   ins_encode %{
10832     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10833     __ mr_if_needed($dst$$Register, $src$$Register);
10834   %}
10835   ins_pipe(pipe_class_default);
10836 %}
10837 
10838 //----------Cast instructions (Java-level type cast)---------------------------
10839 
10840 // Cast Long to Pointer for unsafe natives.
10841 instruct castX2P(iRegPdst dst, iRegLsrc src) %{
10842   match(Set dst (CastX2P src));
10843 
10844   format %{ &quot;MR      $dst, $src \t// Long-&gt;Ptr&quot; %}
10845   // variable size, 0 or 4.
10846   ins_encode %{
10847     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10848     __ mr_if_needed($dst$$Register, $src$$Register);
10849   %}
10850  ins_pipe(pipe_class_default);
10851 %}
10852 
10853 // Cast Pointer to Long for unsafe natives.
10854 instruct castP2X(iRegLdst dst, iRegP_N2P src) %{
10855   match(Set dst (CastP2X src));
10856 
10857   format %{ &quot;MR      $dst, $src \t// Ptr-&gt;Long&quot; %}
10858   // variable size, 0 or 4.
10859   ins_encode %{
10860     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10861     __ mr_if_needed($dst$$Register, $src$$Register);
10862   %}
10863   ins_pipe(pipe_class_default);
10864 %}
10865 
10866 instruct castPP(iRegPdst dst) %{
10867   match(Set dst (CastPP dst));
10868   format %{ &quot; -- \t// castPP of $dst&quot; %}
10869   size(0);
10870   ins_encode( /*empty*/ );
10871   ins_pipe(pipe_class_default);
10872 %}
10873 
10874 instruct castII(iRegIdst dst) %{
10875   match(Set dst (CastII dst));
10876   format %{ &quot; -- \t// castII of $dst&quot; %}
10877   size(0);
10878   ins_encode( /*empty*/ );
10879   ins_pipe(pipe_class_default);
10880 %}
10881 
10882 instruct castLL(iRegLdst dst) %{
10883   match(Set dst (CastLL dst));
10884   format %{ &quot; -- \t// castLL of $dst&quot; %}
10885   size(0);
10886   ins_encode( /*empty*/ );
10887   ins_pipe(pipe_class_default);
10888 %}
10889 
10890 instruct checkCastPP(iRegPdst dst) %{
10891   match(Set dst (CheckCastPP dst));
10892   format %{ &quot; -- \t// checkcastPP of $dst&quot; %}
10893   size(0);
10894   ins_encode( /*empty*/ );
10895   ins_pipe(pipe_class_default);
10896 %}
10897 
10898 //----------Convert instructions-----------------------------------------------
10899 
10900 // Convert to boolean.
10901 
10902 // int_to_bool(src) : { 1   if src != 0
10903 //                    { 0   else
10904 //
10905 // strategy:
10906 // 1) Count leading zeros of 32 bit-value src,
10907 //    this returns 32 (0b10.0000) iff src == 0 and &lt;32 otherwise.
10908 // 2) Shift 5 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.
10909 // 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.
10910 
10911 // convI2Bool
10912 instruct convI2Bool_reg__cntlz_Ex(iRegIdst dst, iRegIsrc src) %{
10913   match(Set dst (Conv2B src));
10914   predicate(UseCountLeadingZerosInstructionsPPC64);
10915   ins_cost(DEFAULT_COST);
10916 
10917   expand %{
10918     immI shiftAmount %{ 0x5 %}
10919     uimmI16 mask %{ 0x1 %}
10920     iRegIdst tmp1;
10921     iRegIdst tmp2;
10922     countLeadingZerosI(tmp1, src);
10923     urShiftI_reg_imm(tmp2, tmp1, shiftAmount);
10924     xorI_reg_uimm16(dst, tmp2, mask);
10925   %}
10926 %}
10927 
10928 instruct convI2Bool_reg__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx) %{
10929   match(Set dst (Conv2B src));
10930   effect(TEMP crx);
10931   predicate(!UseCountLeadingZerosInstructionsPPC64);
10932   ins_cost(DEFAULT_COST);
10933 
10934   format %{ &quot;CMPWI   $crx, $src, #0 \t// convI2B&quot;
10935             &quot;LI      $dst, #0\n\t&quot;
10936             &quot;BEQ     $crx, done\n\t&quot;
10937             &quot;LI      $dst, #1\n&quot;
10938             &quot;done:&quot; %}
10939   size(16);
10940   ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x0, 0x1) );
10941   ins_pipe(pipe_class_compare);
10942 %}
10943 
10944 // ConvI2B + XorI
10945 instruct xorI_convI2Bool_reg_immIvalue1__cntlz_Ex(iRegIdst dst, iRegIsrc src, immI_1 mask) %{
10946   match(Set dst (XorI (Conv2B src) mask));
10947   predicate(UseCountLeadingZerosInstructionsPPC64);
10948   ins_cost(DEFAULT_COST);
10949 
10950   expand %{
10951     immI shiftAmount %{ 0x5 %}
10952     iRegIdst tmp1;
10953     countLeadingZerosI(tmp1, src);
10954     urShiftI_reg_imm(dst, tmp1, shiftAmount);
10955   %}
10956 %}
10957 
10958 instruct xorI_convI2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI_1 mask) %{
10959   match(Set dst (XorI (Conv2B src) mask));
10960   effect(TEMP crx);
10961   predicate(!UseCountLeadingZerosInstructionsPPC64);
10962   ins_cost(DEFAULT_COST);
10963 
10964   format %{ &quot;CMPWI   $crx, $src, #0 \t// Xor(convI2B($src), $mask)&quot;
10965             &quot;LI      $dst, #1\n\t&quot;
10966             &quot;BEQ     $crx, done\n\t&quot;
10967             &quot;LI      $dst, #0\n&quot;
10968             &quot;done:&quot; %}
10969   size(16);
10970   ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x1, 0x0) );
10971   ins_pipe(pipe_class_compare);
10972 %}
10973 
10974 // AndI 0b0..010..0 + ConvI2B
10975 instruct convI2Bool_andI_reg_immIpowerOf2(iRegIdst dst, iRegIsrc src, immIpowerOf2 mask) %{
10976   match(Set dst (Conv2B (AndI src mask)));
10977   predicate(UseRotateAndMaskInstructionsPPC64);
10978   ins_cost(DEFAULT_COST);
10979 
10980   format %{ &quot;RLWINM  $dst, $src, $mask \t// convI2B(AndI($src, $mask))&quot; %}
10981   size(4);
10982   ins_encode %{
10983     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
10984     __ rlwinm($dst$$Register, $src$$Register, (32-log2_long((jlong)$mask$$constant)) &amp; 0x1f, 31, 31);
10985   %}
10986   ins_pipe(pipe_class_default);
10987 %}
10988 
10989 // Convert pointer to boolean.
10990 //
10991 // ptr_to_bool(src) : { 1   if src != 0
10992 //                    { 0   else
10993 //
10994 // strategy:
10995 // 1) Count leading zeros of 64 bit-value src,
10996 //    this returns 64 (0b100.0000) iff src == 0 and &lt;64 otherwise.
10997 // 2) Shift 6 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.
10998 // 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.
10999 
11000 // ConvP2B
11001 instruct convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src) %{
11002   match(Set dst (Conv2B src));
11003   predicate(UseCountLeadingZerosInstructionsPPC64);
11004   ins_cost(DEFAULT_COST);
11005 
11006   expand %{
11007     immI shiftAmount %{ 0x6 %}
11008     uimmI16 mask %{ 0x1 %}
11009     iRegIdst tmp1;
11010     iRegIdst tmp2;
11011     countLeadingZerosP(tmp1, src);
11012     urShiftI_reg_imm(tmp2, tmp1, shiftAmount);
11013     xorI_reg_uimm16(dst, tmp2, mask);
11014   %}
11015 %}
11016 
11017 instruct convP2Bool_reg__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx) %{
11018   match(Set dst (Conv2B src));
11019   effect(TEMP crx);
11020   predicate(!UseCountLeadingZerosInstructionsPPC64);
11021   ins_cost(DEFAULT_COST);
11022 
11023   format %{ &quot;CMPDI   $crx, $src, #0 \t// convP2B&quot;
11024             &quot;LI      $dst, #0\n\t&quot;
11025             &quot;BEQ     $crx, done\n\t&quot;
11026             &quot;LI      $dst, #1\n&quot;
11027             &quot;done:&quot; %}
11028   size(16);
11029   ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x0, 0x1) );
11030   ins_pipe(pipe_class_compare);
11031 %}
11032 
11033 // ConvP2B + XorI
11034 instruct xorI_convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src, immI_1 mask) %{
11035   match(Set dst (XorI (Conv2B src) mask));
11036   predicate(UseCountLeadingZerosInstructionsPPC64);
11037   ins_cost(DEFAULT_COST);
11038 
11039   expand %{
11040     immI shiftAmount %{ 0x6 %}
11041     iRegIdst tmp1;
11042     countLeadingZerosP(tmp1, src);
11043     urShiftI_reg_imm(dst, tmp1, shiftAmount);
11044   %}
11045 %}
11046 
11047 instruct xorI_convP2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx, immI_1 mask) %{
11048   match(Set dst (XorI (Conv2B src) mask));
11049   effect(TEMP crx);
11050   predicate(!UseCountLeadingZerosInstructionsPPC64);
11051   ins_cost(DEFAULT_COST);
11052 
11053   format %{ &quot;CMPDI   $crx, $src, #0 \t// XorI(convP2B($src), $mask)&quot;
11054             &quot;LI      $dst, #1\n\t&quot;
11055             &quot;BEQ     $crx, done\n\t&quot;
11056             &quot;LI      $dst, #0\n&quot;
11057             &quot;done:&quot; %}
11058   size(16);
11059   ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x1, 0x0) );
11060   ins_pipe(pipe_class_compare);
11061 %}
11062 
11063 // if src1 &lt; src2, return -1 else return 0
11064 instruct cmpLTMask_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
11065   match(Set dst (CmpLTMask src1 src2));
11066   ins_cost(DEFAULT_COST*4);
11067 
11068   expand %{
11069     iRegLdst src1s;
11070     iRegLdst src2s;
11071     iRegLdst diff;
11072     convI2L_reg(src1s, src1); // Ensure proper sign extension.
11073     convI2L_reg(src2s, src2); // Ensure proper sign extension.
11074     subL_reg_reg(diff, src1s, src2s);
11075     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
11076     signmask64I_regL(dst, diff);
11077   %}
11078 %}
11079 
11080 instruct cmpLTMask_reg_immI0(iRegIdst dst, iRegIsrc src1, immI_0 src2) %{
11081   match(Set dst (CmpLTMask src1 src2)); // if src1 &lt; src2, return -1 else return 0
11082   format %{ &quot;SRAWI   $dst, $src1, $src2 \t// CmpLTMask&quot; %}
11083   size(4);
11084   ins_encode %{
11085     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
11086     __ srawi($dst$$Register, $src1$$Register, 0x1f);
11087   %}
11088   ins_pipe(pipe_class_default);
11089 %}
11090 
11091 //----------Arithmetic Conversion Instructions---------------------------------
11092 
11093 // Convert to Byte  -- nop
11094 // Convert to Short -- nop
11095 
11096 // Convert to Int
11097 
11098 instruct convB2I_reg(iRegIdst dst, iRegIsrc src, immI_24 amount) %{
11099   match(Set dst (RShiftI (LShiftI src amount) amount));
11100   format %{ &quot;EXTSB   $dst, $src \t// byte-&gt;int&quot; %}
11101   size(4);
11102   ins_encode %{
11103     // TODO: PPC port $archOpcode(ppc64Opcode_extsb);
11104     __ extsb($dst$$Register, $src$$Register);
11105   %}
11106   ins_pipe(pipe_class_default);
11107 %}
11108 
11109 instruct extsh(iRegIdst dst, iRegIsrc src) %{
11110   effect(DEF dst, USE src);
11111 
11112   size(4);
11113   ins_encode %{
11114     __ extsh($dst$$Register, $src$$Register);
11115   %}
11116   ins_pipe(pipe_class_default);
11117 %}
11118 
11119 // LShiftI 16 + RShiftI 16 converts short to int.
11120 instruct convS2I_reg(iRegIdst dst, iRegIsrc src, immI_16 amount) %{
11121   match(Set dst (RShiftI (LShiftI src amount) amount));
11122   format %{ &quot;EXTSH   $dst, $src \t// short-&gt;int&quot; %}
11123   size(4);
11124   ins_encode %{
11125     // TODO: PPC port $archOpcode(ppc64Opcode_extsh);
11126     __ extsh($dst$$Register, $src$$Register);
11127   %}
11128   ins_pipe(pipe_class_default);
11129 %}
11130 
11131 // ConvL2I + ConvI2L: Sign extend int in long register.
11132 instruct sxtI_L2L_reg(iRegLdst dst, iRegLsrc src) %{
11133   match(Set dst (ConvI2L (ConvL2I src)));
11134 
11135   format %{ &quot;EXTSW   $dst, $src \t// long-&gt;long&quot; %}
11136   size(4);
11137   ins_encode %{
11138     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
11139     __ extsw($dst$$Register, $src$$Register);
11140   %}
11141   ins_pipe(pipe_class_default);
11142 %}
11143 
11144 instruct convL2I_reg(iRegIdst dst, iRegLsrc src) %{
11145   match(Set dst (ConvL2I src));
11146   format %{ &quot;MR      $dst, $src \t// long-&gt;int&quot; %}
11147   // variable size, 0 or 4
11148   ins_encode %{
11149     // TODO: PPC port $archOpcode(ppc64Opcode_or);
11150     __ mr_if_needed($dst$$Register, $src$$Register);
11151   %}
11152   ins_pipe(pipe_class_default);
11153 %}
11154 
11155 instruct convD2IRaw_regD(regD dst, regD src) %{
11156   // no match-rule, false predicate
11157   effect(DEF dst, USE src);
11158   predicate(false);
11159 
11160   format %{ &quot;FCTIWZ $dst, $src \t// convD2I, $src != NaN&quot; %}
11161   size(4);
11162   ins_encode %{
11163     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);;
11164     __ fctiwz($dst$$FloatRegister, $src$$FloatRegister);
11165   %}
11166   ins_pipe(pipe_class_default);
11167 %}
11168 
11169 instruct cmovI_bso_stackSlotL(iRegIdst dst, flagsRegSrc crx, stackSlotL src) %{
11170   // no match-rule, false predicate
11171   effect(DEF dst, USE crx, USE src);
11172   predicate(false);
11173 
11174   ins_variable_size_depending_on_alignment(true);
11175 
11176   format %{ &quot;cmovI   $crx, $dst, $src&quot; %}
11177   // Worst case is branch + move + stop, no stop without scheduler.
11178   size((false /* TODO: PPC PORT(InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
11179   ins_encode( enc_cmove_bso_stackSlotL(dst, crx, src) );
11180   ins_pipe(pipe_class_default);
11181 %}
11182 
11183 instruct cmovI_bso_reg(iRegIdst dst, flagsRegSrc crx, regD src) %{
11184   // no match-rule, false predicate
11185   effect(DEF dst, USE crx, USE src);
11186   predicate(false);
11187 
11188   ins_variable_size_depending_on_alignment(true);
11189 
11190   format %{ &quot;cmovI   $crx, $dst, $src&quot; %}
11191   // Worst case is branch + move + stop, no stop without scheduler.
11192   size((false /* TODO: PPC PORT(InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
11193   ins_encode( enc_cmove_bso_reg(dst, crx, src) );
11194   ins_pipe(pipe_class_default);
11195 %}
11196 
11197 instruct cmovI_bso_stackSlotL_conLvalue0_Ex(iRegIdst dst, flagsRegSrc crx, stackSlotL mem) %{
11198   // no match-rule, false predicate
11199   effect(DEF dst, USE crx, USE mem);
11200   predicate(false);
11201 
11202   format %{ &quot;CmovI   $dst, $crx, $mem \t// postalloc expanded&quot; %}
11203   postalloc_expand %{
11204     //
11205     // replaces
11206     //
11207     //   region  dst  crx  mem
11208     //    \       |    |   /
11209     //     dst=cmovI_bso_stackSlotL_conLvalue0
11210     //
11211     // with
11212     //
11213     //   region  dst
11214     //    \       /
11215     //     dst=loadConI16(0)
11216     //      |
11217     //      ^  region  dst  crx  mem
11218     //      |   \       |    |    /
11219     //      dst=cmovI_bso_stackSlotL
11220     //
11221 
11222     // Create new nodes.
11223     MachNode *m1 = new loadConI16Node();
11224     MachNode *m2 = new cmovI_bso_stackSlotLNode();
11225 
11226     // inputs for new nodes
11227     m1-&gt;add_req(n_region);
11228     m2-&gt;add_req(n_region, n_crx, n_mem);
11229 
11230     // precedences for new nodes
11231     m2-&gt;add_prec(m1);
11232 
11233     // operands for new nodes
11234     m1-&gt;_opnds[0] = op_dst;
11235     m1-&gt;_opnds[1] = new immI16Oper(0);
11236 
11237     m2-&gt;_opnds[0] = op_dst;
11238     m2-&gt;_opnds[1] = op_crx;
11239     m2-&gt;_opnds[2] = op_mem;
11240 
11241     // registers for new nodes
11242     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11243     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11244 
11245     // Insert new nodes.
11246     nodes-&gt;push(m1);
11247     nodes-&gt;push(m2);
11248   %}
11249 %}
11250 
11251 instruct cmovI_bso_reg_conLvalue0_Ex(iRegIdst dst, flagsRegSrc crx, regD src) %{
11252   // no match-rule, false predicate
11253   effect(DEF dst, USE crx, USE src);
11254   predicate(false);
11255 
11256   format %{ &quot;CmovI   $dst, $crx, $src \t// postalloc expanded&quot; %}
11257   postalloc_expand %{
11258     //
11259     // replaces
11260     //
11261     //   region  dst  crx  src
11262     //    \       |    |   /
11263     //     dst=cmovI_bso_reg_conLvalue0
11264     //
11265     // with
11266     //
11267     //   region  dst
11268     //    \       /
11269     //     dst=loadConI16(0)
11270     //      |
11271     //      ^  region  dst  crx  src
11272     //      |   \       |    |    /
11273     //      dst=cmovI_bso_reg
11274     //
11275 
11276     // Create new nodes.
11277     MachNode *m1 = new loadConI16Node();
11278     MachNode *m2 = new cmovI_bso_regNode();
11279 
11280     // inputs for new nodes
11281     m1-&gt;add_req(n_region);
11282     m2-&gt;add_req(n_region, n_crx, n_src);
11283 
11284     // precedences for new nodes
11285     m2-&gt;add_prec(m1);
11286 
11287     // operands for new nodes
11288     m1-&gt;_opnds[0] = op_dst;
11289     m1-&gt;_opnds[1] = new immI16Oper(0);
11290 
11291     m2-&gt;_opnds[0] = op_dst;
11292     m2-&gt;_opnds[1] = op_crx;
11293     m2-&gt;_opnds[2] = op_src;
11294 
11295     // registers for new nodes
11296     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11297     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11298 
11299     // Insert new nodes.
11300     nodes-&gt;push(m1);
11301     nodes-&gt;push(m2);
11302   %}
11303 %}
11304 
11305 // Double to Int conversion, NaN is mapped to 0.
11306 instruct convD2I_reg_ExEx(iRegIdst dst, regD src) %{
11307   match(Set dst (ConvD2I src));
11308   predicate(!VM_Version::has_mtfprd());
11309   ins_cost(DEFAULT_COST);
11310 
11311   expand %{
11312     regD tmpD;
11313     stackSlotL tmpS;
11314     flagsReg crx;
11315     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11316     convD2IRaw_regD(tmpD, src);                         // Convert float to int (speculated).
11317     moveD2L_reg_stack(tmpS, tmpD);                      // Store float to stack (speculated).
11318     cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11319   %}
11320 %}
11321 
11322 // Double to Int conversion, NaN is mapped to 0. Special version for Power8.
11323 instruct convD2I_reg_mffprd_ExEx(iRegIdst dst, regD src) %{
11324   match(Set dst (ConvD2I src));
11325   predicate(VM_Version::has_mtfprd());
11326   ins_cost(DEFAULT_COST);
11327 
11328   expand %{
11329     regD tmpD;
11330     flagsReg crx;
11331     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11332     convD2IRaw_regD(tmpD, src);                         // Convert float to int (speculated).
11333     cmovI_bso_reg_conLvalue0_Ex(dst, crx, tmpD);        // Cmove based on NaN check.
11334   %}
11335 %}
11336 
11337 instruct convF2IRaw_regF(regF dst, regF src) %{
11338   // no match-rule, false predicate
11339   effect(DEF dst, USE src);
11340   predicate(false);
11341 
11342   format %{ &quot;FCTIWZ $dst, $src \t// convF2I, $src != NaN&quot; %}
11343   size(4);
11344   ins_encode %{
11345     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
11346     __ fctiwz($dst$$FloatRegister, $src$$FloatRegister);
11347   %}
11348   ins_pipe(pipe_class_default);
11349 %}
11350 
11351 // Float to Int conversion, NaN is mapped to 0.
11352 instruct convF2I_regF_ExEx(iRegIdst dst, regF src) %{
11353   match(Set dst (ConvF2I src));
11354   predicate(!VM_Version::has_mtfprd());
11355   ins_cost(DEFAULT_COST);
11356 
11357   expand %{
11358     regF tmpF;
11359     stackSlotL tmpS;
11360     flagsReg crx;
11361     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11362     convF2IRaw_regF(tmpF, src);                         // Convert float to int (speculated).
11363     moveF2L_reg_stack(tmpS, tmpF);                      // Store float to stack (speculated).
11364     cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11365   %}
11366 %}
11367 
11368 // Float to Int conversion, NaN is mapped to 0. Special version for Power8.
11369 instruct convF2I_regF_mffprd_ExEx(iRegIdst dst, regF src) %{
11370   match(Set dst (ConvF2I src));
11371   predicate(VM_Version::has_mtfprd());
11372   ins_cost(DEFAULT_COST);
11373 
11374   expand %{
11375     regF tmpF;
11376     flagsReg crx;
11377     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11378     convF2IRaw_regF(tmpF, src);                         // Convert float to int (speculated).
11379     cmovI_bso_reg_conLvalue0_Ex(dst, crx, tmpF);        // Cmove based on NaN check.
11380   %}
11381 %}
11382 
11383 // Convert to Long
11384 
11385 instruct convI2L_reg(iRegLdst dst, iRegIsrc src) %{
11386   match(Set dst (ConvI2L src));
11387   format %{ &quot;EXTSW   $dst, $src \t// int-&gt;long&quot; %}
11388   size(4);
11389   ins_encode %{
11390     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
11391     __ extsw($dst$$Register, $src$$Register);
11392   %}
11393   ins_pipe(pipe_class_default);
11394 %}
11395 
11396 // Zero-extend: convert unsigned int to long (convUI2L).
11397 instruct zeroExtendL_regI(iRegLdst dst, iRegIsrc src, immL_32bits mask) %{
11398   match(Set dst (AndL (ConvI2L src) mask));
11399   ins_cost(DEFAULT_COST);
11400 
11401   format %{ &quot;CLRLDI  $dst, $src, #32 \t// zero-extend int to long&quot; %}
11402   size(4);
11403   ins_encode %{
11404     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
11405     __ clrldi($dst$$Register, $src$$Register, 32);
11406   %}
11407   ins_pipe(pipe_class_default);
11408 %}
11409 
11410 // Zero-extend: convert unsigned int to long in long register.
11411 instruct zeroExtendL_regL(iRegLdst dst, iRegLsrc src, immL_32bits mask) %{
11412   match(Set dst (AndL src mask));
11413   ins_cost(DEFAULT_COST);
11414 
11415   format %{ &quot;CLRLDI  $dst, $src, #32 \t// zero-extend int to long&quot; %}
11416   size(4);
11417   ins_encode %{
11418     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
11419     __ clrldi($dst$$Register, $src$$Register, 32);
11420   %}
11421   ins_pipe(pipe_class_default);
11422 %}
11423 
11424 instruct convF2LRaw_regF(regF dst, regF src) %{
11425   // no match-rule, false predicate
11426   effect(DEF dst, USE src);
11427   predicate(false);
11428 
11429   format %{ &quot;FCTIDZ $dst, $src \t// convF2L, $src != NaN&quot; %}
11430   size(4);
11431   ins_encode %{
11432     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
11433     __ fctidz($dst$$FloatRegister, $src$$FloatRegister);
11434   %}
11435   ins_pipe(pipe_class_default);
11436 %}
11437 
11438 instruct cmovL_bso_stackSlotL(iRegLdst dst, flagsRegSrc crx, stackSlotL src) %{
11439   // no match-rule, false predicate
11440   effect(DEF dst, USE crx, USE src);
11441   predicate(false);
11442 
11443   ins_variable_size_depending_on_alignment(true);
11444 
11445   format %{ &quot;cmovL   $crx, $dst, $src&quot; %}
11446   // Worst case is branch + move + stop, no stop without scheduler.
11447   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
11448   ins_encode( enc_cmove_bso_stackSlotL(dst, crx, src) );
11449   ins_pipe(pipe_class_default);
11450 %}
11451 
11452 instruct cmovL_bso_reg(iRegLdst dst, flagsRegSrc crx, regD src) %{
11453   // no match-rule, false predicate
11454   effect(DEF dst, USE crx, USE src);
11455   predicate(false);
11456 
11457   ins_variable_size_depending_on_alignment(true);
11458 
11459   format %{ &quot;cmovL   $crx, $dst, $src&quot; %}
11460   // Worst case is branch + move + stop, no stop without scheduler.
11461   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
11462   ins_encode( enc_cmove_bso_reg(dst, crx, src) );
11463   ins_pipe(pipe_class_default);
11464 %}
11465 
11466 instruct cmovL_bso_stackSlotL_conLvalue0_Ex(iRegLdst dst, flagsRegSrc crx, stackSlotL mem) %{
11467   // no match-rule, false predicate
11468   effect(DEF dst, USE crx, USE mem);
11469   predicate(false);
11470 
11471   format %{ &quot;CmovL   $dst, $crx, $mem \t// postalloc expanded&quot; %}
11472   postalloc_expand %{
11473     //
11474     // replaces
11475     //
11476     //   region  dst  crx  mem
11477     //    \       |    |   /
11478     //     dst=cmovL_bso_stackSlotL_conLvalue0
11479     //
11480     // with
11481     //
11482     //   region  dst
11483     //    \       /
11484     //     dst=loadConL16(0)
11485     //      |
11486     //      ^  region  dst  crx  mem
11487     //      |   \       |    |    /
11488     //      dst=cmovL_bso_stackSlotL
11489     //
11490 
11491     // Create new nodes.
11492     MachNode *m1 = new loadConL16Node();
11493     MachNode *m2 = new cmovL_bso_stackSlotLNode();
11494 
11495     // inputs for new nodes
11496     m1-&gt;add_req(n_region);
11497     m2-&gt;add_req(n_region, n_crx, n_mem);
11498     m2-&gt;add_prec(m1);
11499 
11500     // operands for new nodes
11501     m1-&gt;_opnds[0] = op_dst;
11502     m1-&gt;_opnds[1] = new immL16Oper(0);
11503     m2-&gt;_opnds[0] = op_dst;
11504     m2-&gt;_opnds[1] = op_crx;
11505     m2-&gt;_opnds[2] = op_mem;
11506 
11507     // registers for new nodes
11508     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11509     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11510 
11511     // Insert new nodes.
11512     nodes-&gt;push(m1);
11513     nodes-&gt;push(m2);
11514   %}
11515 %}
11516 
11517 instruct cmovL_bso_reg_conLvalue0_Ex(iRegLdst dst, flagsRegSrc crx, regD src) %{
11518   // no match-rule, false predicate
11519   effect(DEF dst, USE crx, USE src);
11520   predicate(false);
11521 
11522   format %{ &quot;CmovL   $dst, $crx, $src \t// postalloc expanded&quot; %}
11523   postalloc_expand %{
11524     //
11525     // replaces
11526     //
11527     //   region  dst  crx  src
11528     //    \       |    |   /
11529     //     dst=cmovL_bso_reg_conLvalue0
11530     //
11531     // with
11532     //
11533     //   region  dst
11534     //    \       /
11535     //     dst=loadConL16(0)
11536     //      |
11537     //      ^  region  dst  crx  src
11538     //      |   \       |    |    /
11539     //      dst=cmovL_bso_reg
11540     //
11541 
11542     // Create new nodes.
11543     MachNode *m1 = new loadConL16Node();
11544     MachNode *m2 = new cmovL_bso_regNode();
11545 
11546     // inputs for new nodes
11547     m1-&gt;add_req(n_region);
11548     m2-&gt;add_req(n_region, n_crx, n_src);
11549     m2-&gt;add_prec(m1);
11550 
11551     // operands for new nodes
11552     m1-&gt;_opnds[0] = op_dst;
11553     m1-&gt;_opnds[1] = new immL16Oper(0);
11554     m2-&gt;_opnds[0] = op_dst;
11555     m2-&gt;_opnds[1] = op_crx;
11556     m2-&gt;_opnds[2] = op_src;
11557 
11558     // registers for new nodes
11559     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11560     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11561 
11562     // Insert new nodes.
11563     nodes-&gt;push(m1);
11564     nodes-&gt;push(m2);
11565   %}
11566 %}
11567 
11568 // Float to Long conversion, NaN is mapped to 0.
11569 instruct convF2L_reg_ExEx(iRegLdst dst, regF src) %{
11570   match(Set dst (ConvF2L src));
11571   predicate(!VM_Version::has_mtfprd());
11572   ins_cost(DEFAULT_COST);
11573 
11574   expand %{
11575     regF tmpF;
11576     stackSlotL tmpS;
11577     flagsReg crx;
11578     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11579     convF2LRaw_regF(tmpF, src);                         // Convert float to long (speculated).
11580     moveF2L_reg_stack(tmpS, tmpF);                      // Store float to stack (speculated).
11581     cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11582   %}
11583 %}
11584 
11585 // Float to Long conversion, NaN is mapped to 0. Special version for Power8.
11586 instruct convF2L_reg_mffprd_ExEx(iRegLdst dst, regF src) %{
11587   match(Set dst (ConvF2L src));
11588   predicate(VM_Version::has_mtfprd());
11589   ins_cost(DEFAULT_COST);
11590 
11591   expand %{
11592     regF tmpF;
11593     flagsReg crx;
11594     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11595     convF2LRaw_regF(tmpF, src);                         // Convert float to long (speculated).
11596     cmovL_bso_reg_conLvalue0_Ex(dst, crx, tmpF);        // Cmove based on NaN check.
11597   %}
11598 %}
11599 
11600 instruct convD2LRaw_regD(regD dst, regD src) %{
11601   // no match-rule, false predicate
11602   effect(DEF dst, USE src);
11603   predicate(false);
11604 
11605   format %{ &quot;FCTIDZ $dst, $src \t// convD2L $src != NaN&quot; %}
11606   size(4);
11607   ins_encode %{
11608     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
11609     __ fctidz($dst$$FloatRegister, $src$$FloatRegister);
11610   %}
11611   ins_pipe(pipe_class_default);
11612 %}
11613 
11614 // Double to Long conversion, NaN is mapped to 0.
11615 instruct convD2L_reg_ExEx(iRegLdst dst, regD src) %{
11616   match(Set dst (ConvD2L src));
11617   predicate(!VM_Version::has_mtfprd());
11618   ins_cost(DEFAULT_COST);
11619 
11620   expand %{
11621     regD tmpD;
11622     stackSlotL tmpS;
11623     flagsReg crx;
11624     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11625     convD2LRaw_regD(tmpD, src);                         // Convert float to long (speculated).
11626     moveD2L_reg_stack(tmpS, tmpD);                      // Store float to stack (speculated).
11627     cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11628   %}
11629 %}
11630 
11631 // Double to Long conversion, NaN is mapped to 0. Special version for Power8.
11632 instruct convD2L_reg_mffprd_ExEx(iRegLdst dst, regD src) %{
11633   match(Set dst (ConvD2L src));
11634   predicate(VM_Version::has_mtfprd());
11635   ins_cost(DEFAULT_COST);
11636 
11637   expand %{
11638     regD tmpD;
11639     flagsReg crx;
11640     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11641     convD2LRaw_regD(tmpD, src);                         // Convert float to long (speculated).
11642     cmovL_bso_reg_conLvalue0_Ex(dst, crx, tmpD);        // Cmove based on NaN check.
11643   %}
11644 %}
11645 
11646 // Convert to Float
11647 
11648 // Placed here as needed in expand.
11649 instruct convL2DRaw_regD(regD dst, regD src) %{
11650   // no match-rule, false predicate
11651   effect(DEF dst, USE src);
11652   predicate(false);
11653 
11654   format %{ &quot;FCFID $dst, $src \t// convL2D&quot; %}
11655   size(4);
11656   ins_encode %{
11657     // TODO: PPC port $archOpcode(ppc64Opcode_fcfid);
11658     __ fcfid($dst$$FloatRegister, $src$$FloatRegister);
11659   %}
11660   ins_pipe(pipe_class_default);
11661 %}
11662 
11663 // Placed here as needed in expand.
11664 instruct convD2F_reg(regF dst, regD src) %{
11665   match(Set dst (ConvD2F src));
11666   format %{ &quot;FRSP    $dst, $src \t// convD2F&quot; %}
11667   size(4);
11668   ins_encode %{
11669     // TODO: PPC port $archOpcode(ppc64Opcode_frsp);
11670     __ frsp($dst$$FloatRegister, $src$$FloatRegister);
11671   %}
11672   ins_pipe(pipe_class_default);
11673 %}
11674 
11675 // Integer to Float conversion.
11676 instruct convI2F_ireg_Ex(regF dst, iRegIsrc src) %{
11677   match(Set dst (ConvI2F src));
11678   predicate(!VM_Version::has_fcfids());
11679   ins_cost(DEFAULT_COST);
11680 
11681   expand %{
11682     iRegLdst tmpL;
11683     stackSlotL tmpS;
11684     regD tmpD;
11685     regD tmpD2;
11686     convI2L_reg(tmpL, src);              // Sign-extension int to long.
11687     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
11688     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11689     convL2DRaw_regD(tmpD2, tmpD);        // Convert to double.
11690     convD2F_reg(dst, tmpD2);             // Convert double to float.
11691   %}
11692 %}
11693 
11694 instruct convL2FRaw_regF(regF dst, regD src) %{
11695   // no match-rule, false predicate
11696   effect(DEF dst, USE src);
11697   predicate(false);
11698 
11699   format %{ &quot;FCFIDS $dst, $src \t// convL2F&quot; %}
11700   size(4);
11701   ins_encode %{
11702     // TODO: PPC port $archOpcode(ppc64Opcode_fcfid);
11703     __ fcfids($dst$$FloatRegister, $src$$FloatRegister);
11704   %}
11705   ins_pipe(pipe_class_default);
11706 %}
11707 
11708 // Integer to Float conversion. Special version for Power7.
11709 instruct convI2F_ireg_fcfids_Ex(regF dst, iRegIsrc src) %{
11710   match(Set dst (ConvI2F src));
11711   predicate(VM_Version::has_fcfids() &amp;&amp; !VM_Version::has_mtfprd());
11712   ins_cost(DEFAULT_COST);
11713 
11714   expand %{
11715     iRegLdst tmpL;
11716     stackSlotL tmpS;
11717     regD tmpD;
11718     convI2L_reg(tmpL, src);              // Sign-extension int to long.
11719     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
11720     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11721     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11722   %}
11723 %}
11724 
11725 // Integer to Float conversion. Special version for Power8.
11726 instruct convI2F_ireg_mtfprd_Ex(regF dst, iRegIsrc src) %{
11727   match(Set dst (ConvI2F src));
11728   predicate(VM_Version::has_fcfids() &amp;&amp; VM_Version::has_mtfprd());
11729   ins_cost(DEFAULT_COST);
11730 
11731   expand %{
11732     regD tmpD;
11733     moveI2D_reg(tmpD, src);
11734     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11735   %}
11736 %}
11737 
11738 // L2F to avoid runtime call.
11739 instruct convL2F_ireg_fcfids_Ex(regF dst, iRegLsrc src) %{
11740   match(Set dst (ConvL2F src));
11741   predicate(VM_Version::has_fcfids() &amp;&amp; !VM_Version::has_mtfprd());
11742   ins_cost(DEFAULT_COST);
11743 
11744   expand %{
11745     stackSlotL tmpS;
11746     regD tmpD;
11747     regL_to_stkL(tmpS, src);             // Store long to stack.
11748     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11749     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11750   %}
11751 %}
11752 
11753 // L2F to avoid runtime call.  Special version for Power8.
11754 instruct convL2F_ireg_mtfprd_Ex(regF dst, iRegLsrc src) %{
11755   match(Set dst (ConvL2F src));
11756   predicate(VM_Version::has_fcfids() &amp;&amp; VM_Version::has_mtfprd());
11757   ins_cost(DEFAULT_COST);
11758 
11759   expand %{
11760     regD tmpD;
11761     moveL2D_reg(tmpD, src);
11762     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11763   %}
11764 %}
11765 
11766 // Moved up as used in expand.
11767 //instruct convD2F_reg(regF dst, regD src) %{%}
11768 
11769 // Convert to Double
11770 
11771 // Integer to Double conversion.
11772 instruct convI2D_reg_Ex(regD dst, iRegIsrc src) %{
11773   match(Set dst (ConvI2D src));
11774   predicate(!VM_Version::has_mtfprd());
11775   ins_cost(DEFAULT_COST);
11776 
11777   expand %{
11778     iRegLdst tmpL;
11779     stackSlotL tmpS;
11780     regD tmpD;
11781     convI2L_reg(tmpL, src);              // Sign-extension int to long.
11782     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
11783     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11784     convL2DRaw_regD(dst, tmpD);          // Convert to double.
11785   %}
11786 %}
11787 
11788 // Integer to Double conversion. Special version for Power8.
11789 instruct convI2D_reg_mtfprd_Ex(regD dst, iRegIsrc src) %{
11790   match(Set dst (ConvI2D src));
11791   predicate(VM_Version::has_mtfprd());
11792   ins_cost(DEFAULT_COST);
11793 
11794   expand %{
11795     regD tmpD;
11796     moveI2D_reg(tmpD, src);
11797     convL2DRaw_regD(dst, tmpD);          // Convert to double.
11798   %}
11799 %}
11800 
11801 // Long to Double conversion
11802 instruct convL2D_reg_Ex(regD dst, stackSlotL src) %{
11803   match(Set dst (ConvL2D src));
11804   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
11805 
11806   expand %{
11807     regD tmpD;
11808     moveL2D_stack_reg(tmpD, src);
11809     convL2DRaw_regD(dst, tmpD);
11810   %}
11811 %}
11812 
11813 // Long to Double conversion. Special version for Power8.
11814 instruct convL2D_reg_mtfprd_Ex(regD dst, iRegLsrc src) %{
11815   match(Set dst (ConvL2D src));
11816   predicate(VM_Version::has_mtfprd());
11817   ins_cost(DEFAULT_COST);
11818 
11819   expand %{
11820     regD tmpD;
11821     moveL2D_reg(tmpD, src);
11822     convL2DRaw_regD(dst, tmpD);          // Convert to double.
11823   %}
11824 %}
11825 
11826 instruct convF2D_reg(regD dst, regF src) %{
11827   match(Set dst (ConvF2D src));
11828   format %{ &quot;FMR     $dst, $src \t// float-&gt;double&quot; %}
11829   // variable size, 0 or 4
11830   ins_encode %{
11831     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
11832     __ fmr_if_needed($dst$$FloatRegister, $src$$FloatRegister);
11833   %}
11834   ins_pipe(pipe_class_default);
11835 %}
11836 
11837 //----------Control Flow Instructions------------------------------------------
11838 // Compare Instructions
11839 
11840 // Compare Integers
11841 instruct cmpI_reg_reg(flagsReg crx, iRegIsrc src1, iRegIsrc src2) %{
11842   match(Set crx (CmpI src1 src2));
11843   size(4);
11844   format %{ &quot;CMPW    $crx, $src1, $src2&quot; %}
11845   ins_encode %{
11846     // TODO: PPC port $archOpcode(ppc64Opcode_cmp);
11847     __ cmpw($crx$$CondRegister, $src1$$Register, $src2$$Register);
11848   %}
11849   ins_pipe(pipe_class_compare);
11850 %}
11851 
11852 instruct cmpI_reg_imm16(flagsReg crx, iRegIsrc src1, immI16 src2) %{
11853   match(Set crx (CmpI src1 src2));
11854   format %{ &quot;CMPWI   $crx, $src1, $src2&quot; %}
11855   size(4);
11856   ins_encode %{
11857     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
11858     __ cmpwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11859   %}
11860   ins_pipe(pipe_class_compare);
11861 %}
11862 
11863 // (src1 &amp; src2) == 0?
11864 instruct testI_reg_imm(flagsRegCR0 cr0, iRegIsrc src1, uimmI16 src2, immI_0 zero) %{
11865   match(Set cr0 (CmpI (AndI src1 src2) zero));
11866   // r0 is killed
11867   format %{ &quot;ANDI    R0, $src1, $src2 \t// BTST int&quot; %}
11868   size(4);
11869   ins_encode %{
11870     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
11871     __ andi_(R0, $src1$$Register, $src2$$constant);
11872   %}
11873   ins_pipe(pipe_class_compare);
11874 %}
11875 
11876 instruct cmpL_reg_reg(flagsReg crx, iRegLsrc src1, iRegLsrc src2) %{
11877   match(Set crx (CmpL src1 src2));
11878   format %{ &quot;CMPD    $crx, $src1, $src2&quot; %}
11879   size(4);
11880   ins_encode %{
11881     // TODO: PPC port $archOpcode(ppc64Opcode_cmp);
11882     __ cmpd($crx$$CondRegister, $src1$$Register, $src2$$Register);
11883   %}
11884   ins_pipe(pipe_class_compare);
11885 %}
11886 
11887 instruct cmpL_reg_imm16(flagsReg crx, iRegLsrc src1, immL16 src2) %{
11888   match(Set crx (CmpL src1 src2));
11889   format %{ &quot;CMPDI   $crx, $src1, $src2&quot; %}
11890   size(4);
11891   ins_encode %{
11892     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
11893     __ cmpdi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11894   %}
11895   ins_pipe(pipe_class_compare);
11896 %}
11897 
11898 // Added CmpUL for LoopPredicate.
11899 instruct cmpUL_reg_reg(flagsReg crx, iRegLsrc src1, iRegLsrc src2) %{
11900   match(Set crx (CmpUL src1 src2));
11901   format %{ &quot;CMPLD   $crx, $src1, $src2&quot; %}
11902   size(4);
11903   ins_encode %{
11904     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
11905     __ cmpld($crx$$CondRegister, $src1$$Register, $src2$$Register);
11906   %}
11907   ins_pipe(pipe_class_compare);
11908 %}
11909 
11910 instruct cmpUL_reg_imm16(flagsReg crx, iRegLsrc src1, uimmL16 src2) %{
11911   match(Set crx (CmpUL src1 src2));
11912   format %{ &quot;CMPLDI  $crx, $src1, $src2&quot; %}
11913   size(4);
11914   ins_encode %{
11915     // TODO: PPC port $archOpcode(ppc64Opcode_cmpli);
11916     __ cmpldi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11917   %}
11918   ins_pipe(pipe_class_compare);
11919 %}
11920 
11921 instruct testL_reg_reg(flagsRegCR0 cr0, iRegLsrc src1, iRegLsrc src2, immL_0 zero) %{
11922   match(Set cr0 (CmpL (AndL src1 src2) zero));
11923   // r0 is killed
11924   format %{ &quot;AND     R0, $src1, $src2 \t// BTST long&quot; %}
11925   size(4);
11926   ins_encode %{
11927     // TODO: PPC port $archOpcode(ppc64Opcode_and_);
11928     __ and_(R0, $src1$$Register, $src2$$Register);
11929   %}
11930   ins_pipe(pipe_class_compare);
11931 %}
11932 
11933 instruct testL_reg_imm(flagsRegCR0 cr0, iRegLsrc src1, uimmL16 src2, immL_0 zero) %{
11934   match(Set cr0 (CmpL (AndL src1 src2) zero));
11935   // r0 is killed
11936   format %{ &quot;ANDI    R0, $src1, $src2 \t// BTST long&quot; %}
11937   size(4);
11938   ins_encode %{
11939     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
11940     __ andi_(R0, $src1$$Register, $src2$$constant);
11941   %}
11942   ins_pipe(pipe_class_compare);
11943 %}
11944 
11945 instruct cmovI_conIvalueMinus1_conIvalue1(iRegIdst dst, flagsRegSrc crx) %{
11946   // no match-rule, false predicate
11947   effect(DEF dst, USE crx);
11948   predicate(false);
11949 
11950   ins_variable_size_depending_on_alignment(true);
11951 
11952   format %{ &quot;cmovI   $crx, $dst, -1, 0, +1&quot; %}
11953   // Worst case is branch + move + branch + move + stop, no stop without scheduler.
11954   size((false /* TODO: PPC PORTInsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 20 : 16));
11955   ins_encode %{
11956     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
11957     Label done;
11958     // li(Rdst, 0);              // equal -&gt; 0
11959     __ beq($crx$$CondRegister, done);
11960     __ li($dst$$Register, 1);    // greater -&gt; +1
11961     __ bgt($crx$$CondRegister, done);
11962     __ li($dst$$Register, -1);   // unordered or less -&gt; -1
11963     // TODO: PPC port__ endgroup_if_needed(_size == 20);
11964     __ bind(done);
11965   %}
11966   ins_pipe(pipe_class_compare);
11967 %}
11968 
11969 instruct cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(iRegIdst dst, flagsRegSrc crx) %{
11970   // no match-rule, false predicate
11971   effect(DEF dst, USE crx);
11972   predicate(false);
11973 
11974   format %{ &quot;CmovI    $crx, $dst, -1, 0, +1 \t// postalloc expanded&quot; %}
11975   postalloc_expand %{
11976     //
11977     // replaces
11978     //
11979     //   region  crx
11980     //    \       |
11981     //     dst=cmovI_conIvalueMinus1_conIvalue0_conIvalue1
11982     //
11983     // with
11984     //
11985     //   region
11986     //    \
11987     //     dst=loadConI16(0)
11988     //      |
11989     //      ^  region  crx
11990     //      |   \       |
11991     //      dst=cmovI_conIvalueMinus1_conIvalue1
11992     //
11993 
11994     // Create new nodes.
11995     MachNode *m1 = new loadConI16Node();
11996     MachNode *m2 = new cmovI_conIvalueMinus1_conIvalue1Node();
11997 
11998     // inputs for new nodes
11999     m1-&gt;add_req(n_region);
12000     m2-&gt;add_req(n_region, n_crx);
12001     m2-&gt;add_prec(m1);
12002 
12003     // operands for new nodes
12004     m1-&gt;_opnds[0] = op_dst;
12005     m1-&gt;_opnds[1] = new immI16Oper(0);
12006     m2-&gt;_opnds[0] = op_dst;
12007     m2-&gt;_opnds[1] = op_crx;
12008 
12009     // registers for new nodes
12010     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
12011     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
12012 
12013     // Insert new nodes.
12014     nodes-&gt;push(m1);
12015     nodes-&gt;push(m2);
12016   %}
12017 %}
12018 
12019 // Manifest a CmpL3 result in an integer register. Very painful.
12020 // This is the test to avoid.
12021 // (src1 &lt; src2) ? -1 : ((src1 &gt; src2) ? 1 : 0)
12022 instruct cmpL3_reg_reg_ExEx(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
12023   match(Set dst (CmpL3 src1 src2));
12024   ins_cost(DEFAULT_COST*5+BRANCH_COST);
12025 
12026   expand %{
12027     flagsReg tmp1;
12028     cmpL_reg_reg(tmp1, src1, src2);
12029     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
12030   %}
12031 %}
12032 
12033 // Implicit range checks.
12034 // A range check in the ideal world has one of the following shapes:
12035 //  - (If le (CmpU length index)), (IfTrue  throw exception)
12036 //  - (If lt (CmpU index length)), (IfFalse throw exception)
12037 //
12038 // Match range check &#39;If le (CmpU length index)&#39;.
12039 instruct rangeCheck_iReg_uimm15(cmpOp cmp, iRegIsrc src_length, uimmI15 index, label labl) %{
12040   match(If cmp (CmpU src_length index));
12041   effect(USE labl);
12042   predicate(TrapBasedRangeChecks &amp;&amp;
12043             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le &amp;&amp;
12044             PROB_UNLIKELY(_leaf-&gt;as_If()-&gt;_prob) &gt;= PROB_ALWAYS &amp;&amp;
12045             (Matcher::branches_to_uncommon_trap(_leaf)));
12046 
12047   ins_is_TrapBasedCheckNode(true);
12048 
12049   format %{ &quot;TWI     $index $cmp $src_length \t// RangeCheck =&gt; trap $labl&quot; %}
12050   size(4);
12051   ins_encode %{
12052     // TODO: PPC port $archOpcode(ppc64Opcode_twi);
12053     if ($cmp$$cmpcode == 0x1 /* less_equal */) {
12054       __ trap_range_check_le($src_length$$Register, $index$$constant);
12055     } else {
12056       // Both successors are uncommon traps, probability is 0.
12057       // Node got flipped during fixup flow.
12058       assert($cmp$$cmpcode == 0x9, &quot;must be greater&quot;);
12059       __ trap_range_check_g($src_length$$Register, $index$$constant);
12060     }
12061   %}
12062   ins_pipe(pipe_class_trap);
12063 %}
12064 
12065 // Match range check &#39;If lt (CmpU index length)&#39;.
12066 instruct rangeCheck_iReg_iReg(cmpOp cmp, iRegIsrc src_index, iRegIsrc src_length, label labl) %{
12067   match(If cmp (CmpU src_index src_length));
12068   effect(USE labl);
12069   predicate(TrapBasedRangeChecks &amp;&amp;
12070             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
12071             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
12072             (Matcher::branches_to_uncommon_trap(_leaf)));
12073 
12074   ins_is_TrapBasedCheckNode(true);
12075 
12076   format %{ &quot;TW      $src_index $cmp $src_length \t// RangeCheck =&gt; trap $labl&quot; %}
12077   size(4);
12078   ins_encode %{
12079     // TODO: PPC port $archOpcode(ppc64Opcode_tw);
12080     if ($cmp$$cmpcode == 0x0 /* greater_equal */) {
12081       __ trap_range_check_ge($src_index$$Register, $src_length$$Register);
12082     } else {
12083       // Both successors are uncommon traps, probability is 0.
12084       // Node got flipped during fixup flow.
12085       assert($cmp$$cmpcode == 0x8, &quot;must be less&quot;);
12086       __ trap_range_check_l($src_index$$Register, $src_length$$Register);
12087     }
12088   %}
12089   ins_pipe(pipe_class_trap);
12090 %}
12091 
12092 // Match range check &#39;If lt (CmpU index length)&#39;.
12093 instruct rangeCheck_uimm15_iReg(cmpOp cmp, iRegIsrc src_index, uimmI15 length, label labl) %{
12094   match(If cmp (CmpU src_index length));
12095   effect(USE labl);
12096   predicate(TrapBasedRangeChecks &amp;&amp;
12097             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
12098             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
12099             (Matcher::branches_to_uncommon_trap(_leaf)));
12100 
12101   ins_is_TrapBasedCheckNode(true);
12102 
12103   format %{ &quot;TWI     $src_index $cmp $length \t// RangeCheck =&gt; trap $labl&quot; %}
12104   size(4);
12105   ins_encode %{
12106     // TODO: PPC port $archOpcode(ppc64Opcode_twi);
12107     if ($cmp$$cmpcode == 0x0 /* greater_equal */) {
12108       __ trap_range_check_ge($src_index$$Register, $length$$constant);
12109     } else {
12110       // Both successors are uncommon traps, probability is 0.
12111       // Node got flipped during fixup flow.
12112       assert($cmp$$cmpcode == 0x8, &quot;must be less&quot;);
12113       __ trap_range_check_l($src_index$$Register, $length$$constant);
12114     }
12115   %}
12116   ins_pipe(pipe_class_trap);
12117 %}
12118 
12119 instruct compU_reg_reg(flagsReg crx, iRegIsrc src1, iRegIsrc src2) %{
12120   match(Set crx (CmpU src1 src2));
12121   format %{ &quot;CMPLW   $crx, $src1, $src2 \t// unsigned&quot; %}
12122   size(4);
12123   ins_encode %{
12124     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12125     __ cmplw($crx$$CondRegister, $src1$$Register, $src2$$Register);
12126   %}
12127   ins_pipe(pipe_class_compare);
12128 %}
12129 
12130 instruct compU_reg_uimm16(flagsReg crx, iRegIsrc src1, uimmI16 src2) %{
12131   match(Set crx (CmpU src1 src2));
12132   size(4);
12133   format %{ &quot;CMPLWI  $crx, $src1, $src2&quot; %}
12134   ins_encode %{
12135     // TODO: PPC port $archOpcode(ppc64Opcode_cmpli);
12136     __ cmplwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
12137   %}
12138   ins_pipe(pipe_class_compare);
12139 %}
12140 
12141 // Implicit zero checks (more implicit null checks).
12142 // No constant pool entries required.
12143 instruct zeroCheckN_iReg_imm0(cmpOp cmp, iRegNsrc value, immN_0 zero, label labl) %{
12144   match(If cmp (CmpN value zero));
12145   effect(USE labl);
12146   predicate(TrapBasedNullChecks &amp;&amp;
12147             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
12148             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
12149             Matcher::branches_to_uncommon_trap(_leaf));
12150   ins_cost(1);
12151 
12152   ins_is_TrapBasedCheckNode(true);
12153 
12154   format %{ &quot;TDI     $value $cmp $zero \t// ZeroCheckN =&gt; trap $labl&quot; %}
12155   size(4);
12156   ins_encode %{
12157     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
12158     if ($cmp$$cmpcode == 0xA) {
12159       __ trap_null_check($value$$Register);
12160     } else {
12161       // Both successors are uncommon traps, probability is 0.
12162       // Node got flipped during fixup flow.
12163       assert($cmp$$cmpcode == 0x2 , &quot;must be equal(0xA) or notEqual(0x2)&quot;);
12164       __ trap_null_check($value$$Register, Assembler::traptoGreaterThanUnsigned);
12165     }
12166   %}
12167   ins_pipe(pipe_class_trap);
12168 %}
12169 
12170 // Compare narrow oops.
12171 instruct cmpN_reg_reg(flagsReg crx, iRegNsrc src1, iRegNsrc src2) %{
12172   match(Set crx (CmpN src1 src2));
12173 
12174   size(4);
12175   ins_cost(2);
12176   format %{ &quot;CMPLW   $crx, $src1, $src2 \t// compressed ptr&quot; %}
12177   ins_encode %{
12178     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12179     __ cmplw($crx$$CondRegister, $src1$$Register, $src2$$Register);
12180   %}
12181   ins_pipe(pipe_class_compare);
12182 %}
12183 
12184 instruct cmpN_reg_imm0(flagsReg crx, iRegNsrc src1, immN_0 src2) %{
12185   match(Set crx (CmpN src1 src2));
12186   // Make this more expensive than zeroCheckN_iReg_imm0.
12187   ins_cost(2);
12188 
12189   format %{ &quot;CMPLWI  $crx, $src1, $src2 \t// compressed ptr&quot; %}
12190   size(4);
12191   ins_encode %{
12192     // TODO: PPC port $archOpcode(ppc64Opcode_cmpli);
12193     __ cmplwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
12194   %}
12195   ins_pipe(pipe_class_compare);
12196 %}
12197 
12198 // Implicit zero checks (more implicit null checks).
12199 // No constant pool entries required.
12200 instruct zeroCheckP_reg_imm0(cmpOp cmp, iRegP_N2P value, immP_0 zero, label labl) %{
12201   match(If cmp (CmpP value zero));
12202   effect(USE labl);
12203   predicate(TrapBasedNullChecks &amp;&amp;
12204             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
12205             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
12206             Matcher::branches_to_uncommon_trap(_leaf));
12207   ins_cost(1); // Should not be cheaper than zeroCheckN.
12208 
12209   ins_is_TrapBasedCheckNode(true);
12210 
12211   format %{ &quot;TDI     $value $cmp $zero \t// ZeroCheckP =&gt; trap $labl&quot; %}
12212   size(4);
12213   ins_encode %{
12214     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
12215     if ($cmp$$cmpcode == 0xA) {
12216       __ trap_null_check($value$$Register);
12217     } else {
12218       // Both successors are uncommon traps, probability is 0.
12219       // Node got flipped during fixup flow.
12220       assert($cmp$$cmpcode == 0x2 , &quot;must be equal(0xA) or notEqual(0x2)&quot;);
12221       __ trap_null_check($value$$Register, Assembler::traptoGreaterThanUnsigned);
12222     }
12223   %}
12224   ins_pipe(pipe_class_trap);
12225 %}
12226 
12227 // Compare Pointers
12228 instruct cmpP_reg_reg(flagsReg crx, iRegP_N2P src1, iRegP_N2P src2) %{
12229   match(Set crx (CmpP src1 src2));
12230   format %{ &quot;CMPLD   $crx, $src1, $src2 \t// ptr&quot; %}
12231   size(4);
12232   ins_encode %{
12233     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12234     __ cmpld($crx$$CondRegister, $src1$$Register, $src2$$Register);
12235   %}
12236   ins_pipe(pipe_class_compare);
12237 %}
12238 
12239 instruct cmpP_reg_null(flagsReg crx, iRegP_N2P src1, immP_0or1 src2) %{
12240   match(Set crx (CmpP src1 src2));
12241   format %{ &quot;CMPLDI   $crx, $src1, $src2 \t// ptr&quot; %}
12242   size(4);
12243   ins_encode %{
12244     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12245     __ cmpldi($crx$$CondRegister, $src1$$Register, (int)((short)($src2$$constant &amp; 0xFFFF)));
12246   %}
12247   ins_pipe(pipe_class_compare);
12248 %}
12249 
12250 // Used in postalloc expand.
12251 instruct cmpP_reg_imm16(flagsReg crx, iRegPsrc src1, immL16 src2) %{
12252   // This match rule prevents reordering of node before a safepoint.
12253   // This only makes sense if this instructions is used exclusively
12254   // for the expansion of EncodeP!
12255   match(Set crx (CmpP src1 src2));
12256   predicate(false);
12257 
12258   format %{ &quot;CMPDI   $crx, $src1, $src2&quot; %}
12259   size(4);
12260   ins_encode %{
12261     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
12262     __ cmpdi($crx$$CondRegister, $src1$$Register, $src2$$constant);
12263   %}
12264   ins_pipe(pipe_class_compare);
12265 %}
12266 
12267 //----------Float Compares----------------------------------------------------
12268 
12269 instruct cmpFUnordered_reg_reg(flagsReg crx, regF src1, regF src2) %{
12270   // Needs matchrule, see cmpDUnordered.
12271   match(Set crx (CmpF src1 src2));
12272   // no match-rule, false predicate
12273   predicate(false);
12274 
12275   format %{ &quot;cmpFUrd $crx, $src1, $src2&quot; %}
12276   size(4);
12277   ins_encode %{
12278     // TODO: PPC port $archOpcode(ppc64Opcode_fcmpu);
12279     __ fcmpu($crx$$CondRegister, $src1$$FloatRegister, $src2$$FloatRegister);
12280   %}
12281   ins_pipe(pipe_class_default);
12282 %}
12283 
12284 instruct cmov_bns_less(flagsReg crx) %{
12285   // no match-rule, false predicate
12286   effect(DEF crx);
12287   predicate(false);
12288 
12289   ins_variable_size_depending_on_alignment(true);
12290 
12291   format %{ &quot;cmov    $crx&quot; %}
12292   // Worst case is branch + move + stop, no stop without scheduler.
12293   size((false /* TODO: PPC PORT(InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 16 : 12));
12294   ins_encode %{
12295     // TODO: PPC port $archOpcode(ppc64Opcode_cmovecr);
12296     Label done;
12297     __ bns($crx$$CondRegister, done);        // not unordered -&gt; keep crx
12298     __ li(R0, 0);
12299     __ cmpwi($crx$$CondRegister, R0, 1);     // unordered -&gt; set crx to &#39;less&#39;
12300     // TODO PPC port __ endgroup_if_needed(_size == 16);
12301     __ bind(done);
12302   %}
12303   ins_pipe(pipe_class_default);
12304 %}
12305 
12306 // Compare floating, generate condition code.
12307 instruct cmpF_reg_reg_Ex(flagsReg crx, regF src1, regF src2) %{
12308   // FIXME: should we match &#39;If cmp (CmpF src1 src2))&#39; ??
12309   //
12310   // The following code sequence occurs a lot in mpegaudio:
12311   //
12312   // block BXX:
12313   // 0: instruct cmpFUnordered_reg_reg (cmpF_reg_reg-0):
12314   //    cmpFUrd CCR6, F11, F9
12315   // 4: instruct cmov_bns_less (cmpF_reg_reg-1):
12316   //    cmov CCR6
12317   // 8: instruct branchConSched:
12318   //    B_FARle CCR6, B56  P=0.500000 C=-1.000000
12319   match(Set crx (CmpF src1 src2));
12320   ins_cost(DEFAULT_COST+BRANCH_COST);
12321 
12322   format %{ &quot;CmpF    $crx, $src1, $src2 \t// postalloc expanded&quot; %}
12323   postalloc_expand %{
12324     //
12325     // replaces
12326     //
12327     //   region  src1  src2
12328     //    \       |     |
12329     //     crx=cmpF_reg_reg
12330     //
12331     // with
12332     //
12333     //   region  src1  src2
12334     //    \       |     |
12335     //     crx=cmpFUnordered_reg_reg
12336     //      |
12337     //      ^  region
12338     //      |   \
12339     //      crx=cmov_bns_less
12340     //
12341 
12342     // Create new nodes.
12343     MachNode *m1 = new cmpFUnordered_reg_regNode();
12344     MachNode *m2 = new cmov_bns_lessNode();
12345 
12346     // inputs for new nodes
12347     m1-&gt;add_req(n_region, n_src1, n_src2);
12348     m2-&gt;add_req(n_region);
12349     m2-&gt;add_prec(m1);
12350 
12351     // operands for new nodes
12352     m1-&gt;_opnds[0] = op_crx;
12353     m1-&gt;_opnds[1] = op_src1;
12354     m1-&gt;_opnds[2] = op_src2;
12355     m2-&gt;_opnds[0] = op_crx;
12356 
12357     // registers for new nodes
12358     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12359     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12360 
12361     // Insert new nodes.
12362     nodes-&gt;push(m1);
12363     nodes-&gt;push(m2);
12364   %}
12365 %}
12366 
12367 // Compare float, generate -1,0,1
12368 instruct cmpF3_reg_reg_ExEx(iRegIdst dst, regF src1, regF src2) %{
12369   match(Set dst (CmpF3 src1 src2));
12370   ins_cost(DEFAULT_COST*5+BRANCH_COST);
12371 
12372   expand %{
12373     flagsReg tmp1;
12374     cmpFUnordered_reg_reg(tmp1, src1, src2);
12375     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
12376   %}
12377 %}
12378 
12379 instruct cmpDUnordered_reg_reg(flagsReg crx, regD src1, regD src2) %{
12380   // Needs matchrule so that ideal opcode is Cmp. This causes that gcm places the
12381   // node right before the conditional move using it.
12382   // In jck test api/java_awt/geom/QuadCurve2DFloat/index.html#SetCurveTesttestCase7,
12383   // compilation of java.awt.geom.RectangularShape::getBounds()Ljava/awt/Rectangle
12384   // crashed in register allocation where the flags Reg between cmpDUnoredered and a
12385   // conditional move was supposed to be spilled.
12386   match(Set crx (CmpD src1 src2));
12387   // False predicate, shall not be matched.
12388   predicate(false);
12389 
12390   format %{ &quot;cmpFUrd $crx, $src1, $src2&quot; %}
12391   size(4);
12392   ins_encode %{
12393     // TODO: PPC port $archOpcode(ppc64Opcode_fcmpu);
12394     __ fcmpu($crx$$CondRegister, $src1$$FloatRegister, $src2$$FloatRegister);
12395   %}
12396   ins_pipe(pipe_class_default);
12397 %}
12398 
12399 instruct cmpD_reg_reg_Ex(flagsReg crx, regD src1, regD src2) %{
12400   match(Set crx (CmpD src1 src2));
12401   ins_cost(DEFAULT_COST+BRANCH_COST);
12402 
12403   format %{ &quot;CmpD    $crx, $src1, $src2 \t// postalloc expanded&quot; %}
12404   postalloc_expand %{
12405     //
12406     // replaces
12407     //
12408     //   region  src1  src2
12409     //    \       |     |
12410     //     crx=cmpD_reg_reg
12411     //
12412     // with
12413     //
12414     //   region  src1  src2
12415     //    \       |     |
12416     //     crx=cmpDUnordered_reg_reg
12417     //      |
12418     //      ^  region
12419     //      |   \
12420     //      crx=cmov_bns_less
12421     //
12422 
12423     // create new nodes
12424     MachNode *m1 = new cmpDUnordered_reg_regNode();
12425     MachNode *m2 = new cmov_bns_lessNode();
12426 
12427     // inputs for new nodes
12428     m1-&gt;add_req(n_region, n_src1, n_src2);
12429     m2-&gt;add_req(n_region);
12430     m2-&gt;add_prec(m1);
12431 
12432     // operands for new nodes
12433     m1-&gt;_opnds[0] = op_crx;
12434     m1-&gt;_opnds[1] = op_src1;
12435     m1-&gt;_opnds[2] = op_src2;
12436     m2-&gt;_opnds[0] = op_crx;
12437 
12438     // registers for new nodes
12439     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12440     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12441 
12442     // Insert new nodes.
12443     nodes-&gt;push(m1);
12444     nodes-&gt;push(m2);
12445   %}
12446 %}
12447 
12448 // Compare double, generate -1,0,1
12449 instruct cmpD3_reg_reg_ExEx(iRegIdst dst, regD src1, regD src2) %{
12450   match(Set dst (CmpD3 src1 src2));
12451   ins_cost(DEFAULT_COST*5+BRANCH_COST);
12452 
12453   expand %{
12454     flagsReg tmp1;
12455     cmpDUnordered_reg_reg(tmp1, src1, src2);
12456     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
12457   %}
12458 %}
12459 
12460 // Compare char
12461 instruct cmprb_Digit_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12462   match(Set dst (Digit src1));
12463   effect(TEMP src2, TEMP crx);
12464   ins_cost(3 * DEFAULT_COST);
12465 
12466   format %{ &quot;LI      $src2, 0x3930\n\t&quot;
12467             &quot;CMPRB   $crx, 0, $src1, $src2\n\t&quot;
12468             &quot;SETB    $dst, $crx&quot; %}
12469   size(12);
12470   ins_encode %{
12471     // 0x30: 0, 0x39: 9
12472     __ li($src2$$Register, 0x3930);
12473     // compare src1 with ranges 0x30 to 0x39
12474     __ cmprb($crx$$CondRegister, 0, $src1$$Register, $src2$$Register);
12475     __ setb($dst$$Register, $crx$$CondRegister);
12476   %}
12477   ins_pipe(pipe_class_default);
12478 %}
12479 
12480 instruct cmprb_LowerCase_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12481   match(Set dst (LowerCase src1));
12482   effect(TEMP src2, TEMP crx);
12483   ins_cost(12 * DEFAULT_COST);
12484 
12485   format %{ &quot;LI      $src2, 0x7A61\n\t&quot;
12486             &quot;CMPRB   $crx, 0, $src1, $src2\n\t&quot;
12487             &quot;BGT     $crx, done\n\t&quot;
12488             &quot;LIS     $src2, (signed short)0xF6DF\n\t&quot;
12489             &quot;ORI     $src2, $src2, 0xFFF8\n\t&quot;
12490             &quot;CMPRB   $crx, 1, $src1, $src2\n\t&quot;
12491             &quot;BGT     $crx, done\n\t&quot;
12492             &quot;LIS     $src2, (signed short)0xAAB5\n\t&quot;
12493             &quot;ORI     $src2, $src2, 0xBABA\n\t&quot;
12494             &quot;INSRDI  $src2, $src2, 32, 0\n\t&quot;
12495             &quot;CMPEQB  $crx, 1, $src1, $src2\n&quot;
12496             &quot;done:\n\t&quot;
12497             &quot;SETB    $dst, $crx&quot; %}
12498 
12499   size(48);
12500   ins_encode %{
12501     Label done;
12502     // 0x61: a, 0x7A: z
12503     __ li($src2$$Register, 0x7A61);
12504     // compare src1 with ranges 0x61 to 0x7A
12505     __ cmprb($crx$$CondRegister, 0, $src1$$Register, $src2$$Register);
12506     __ bgt($crx$$CondRegister, done);
12507 
12508     // 0xDF: sharp s, 0xFF: y with diaeresis, 0xF7 is not the lower case
12509     __ lis($src2$$Register, (signed short)0xF6DF);
12510     __ ori($src2$$Register, $src2$$Register, 0xFFF8);
12511     // compare src1 with ranges 0xDF to 0xF6 and 0xF8 to 0xFF
12512     __ cmprb($crx$$CondRegister, 1, $src1$$Register, $src2$$Register);
12513     __ bgt($crx$$CondRegister, done);
12514 
12515     // 0xAA: feminine ordinal indicator
12516     // 0xB5: micro sign
12517     // 0xBA: masculine ordinal indicator
12518     __ lis($src2$$Register, (signed short)0xAAB5);
12519     __ ori($src2$$Register, $src2$$Register, 0xBABA);
12520     __ insrdi($src2$$Register, $src2$$Register, 32, 0);
12521     // compare src1 with 0xAA, 0xB5, and 0xBA
12522     __ cmpeqb($crx$$CondRegister, $src1$$Register, $src2$$Register);
12523 
12524     __ bind(done);
12525     __ setb($dst$$Register, $crx$$CondRegister);
12526   %}
12527   ins_pipe(pipe_class_default);
12528 %}
12529 
12530 instruct cmprb_UpperCase_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12531   match(Set dst (UpperCase src1));
12532   effect(TEMP src2, TEMP crx);
12533   ins_cost(7 * DEFAULT_COST);
12534 
12535   format %{ &quot;LI      $src2, 0x5A41\n\t&quot;
12536             &quot;CMPRB   $crx, 0, $src1, $src2\n\t&quot;
12537             &quot;BGT     $crx, done\n\t&quot;
12538             &quot;LIS     $src2, (signed short)0xD6C0\n\t&quot;
12539             &quot;ORI     $src2, $src2, 0xDED8\n\t&quot;
12540             &quot;CMPRB   $crx, 1, $src1, $src2\n&quot;
12541             &quot;done:\n\t&quot;
12542             &quot;SETB    $dst, $crx&quot; %}
12543 
12544   size(28);
12545   ins_encode %{
12546     Label done;
12547     // 0x41: A, 0x5A: Z
12548     __ li($src2$$Register, 0x5A41);
12549     // compare src1 with a range 0x41 to 0x5A
12550     __ cmprb($crx$$CondRegister, 0, $src1$$Register, $src2$$Register);
12551     __ bgt($crx$$CondRegister, done);
12552 
12553     // 0xC0: a with grave, 0xDE: thorn, 0xD7 is not the upper case
12554     __ lis($src2$$Register, (signed short)0xD6C0);
12555     __ ori($src2$$Register, $src2$$Register, 0xDED8);
12556     // compare src1 with ranges 0xC0 to 0xD6 and 0xD8 to 0xDE
12557     __ cmprb($crx$$CondRegister, 1, $src1$$Register, $src2$$Register);
12558 
12559     __ bind(done);
12560     __ setb($dst$$Register, $crx$$CondRegister);
12561   %}
12562   ins_pipe(pipe_class_default);
12563 %}
12564 
12565 instruct cmprb_Whitespace_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12566   match(Set dst (Whitespace src1));
12567   effect(TEMP src2, TEMP crx);
12568   ins_cost(4 * DEFAULT_COST);
12569 
12570   format %{ &quot;LI      $src2, 0x0D09\n\t&quot;
12571             &quot;ADDIS   $src2, 0x201C\n\t&quot;
12572             &quot;CMPRB   $crx, 1, $src1, $src2\n\t&quot;
12573             &quot;SETB    $dst, $crx&quot; %}
12574   size(16);
12575   ins_encode %{
12576     // 0x09 to 0x0D, 0x1C to 0x20
12577     __ li($src2$$Register, 0x0D09);
12578     __ addis($src2$$Register, $src2$$Register, 0x0201C);
12579     // compare src with ranges 0x09 to 0x0D and 0x1C to 0x20
12580     __ cmprb($crx$$CondRegister, 1, $src1$$Register, $src2$$Register);
12581     __ setb($dst$$Register, $crx$$CondRegister);
12582   %}
12583   ins_pipe(pipe_class_default);
12584 %}
12585 
12586 //----------Branches---------------------------------------------------------
12587 // Jump
12588 
12589 // Direct Branch.
12590 instruct branch(label labl) %{
12591   match(Goto);
12592   effect(USE labl);
12593   ins_cost(BRANCH_COST);
12594 
12595   format %{ &quot;B       $labl&quot; %}
12596   size(4);
12597   ins_encode %{
12598     // TODO: PPC port $archOpcode(ppc64Opcode_b);
12599      Label d;    // dummy
12600      __ bind(d);
12601      Label* p = $labl$$label;
12602      // `p&#39; is `NULL&#39; when this encoding class is used only to
12603      // determine the size of the encoded instruction.
12604      Label&amp; l = (NULL == p)? d : *(p);
12605      __ b(l);
12606   %}
12607   ins_pipe(pipe_class_default);
12608 %}
12609 
12610 // Conditional Near Branch
12611 instruct branchCon(cmpOp cmp, flagsRegSrc crx, label lbl) %{
12612   // Same match rule as `branchConFar&#39;.
12613   match(If cmp crx);
12614   effect(USE lbl);
12615   ins_cost(BRANCH_COST);
12616 
12617   // If set to 1 this indicates that the current instruction is a
12618   // short variant of a long branch. This avoids using this
12619   // instruction in first-pass matching. It will then only be used in
12620   // the `Shorten_branches&#39; pass.
12621   ins_short_branch(1);
12622 
12623   format %{ &quot;B$cmp     $crx, $lbl&quot; %}
12624   size(4);
12625   ins_encode( enc_bc(crx, cmp, lbl) );
12626   ins_pipe(pipe_class_default);
12627 %}
12628 
12629 // This is for cases when the ppc64 `bc&#39; instruction does not
12630 // reach far enough. So we emit a far branch here, which is more
12631 // expensive.
12632 //
12633 // Conditional Far Branch
12634 instruct branchConFar(cmpOp cmp, flagsRegSrc crx, label lbl) %{
12635   // Same match rule as `branchCon&#39;.
12636   match(If cmp crx);
12637   effect(USE crx, USE lbl);
12638   predicate(!false /* TODO: PPC port HB_Schedule*/);
12639   // Higher cost than `branchCon&#39;.
12640   ins_cost(5*BRANCH_COST);
12641 
12642   // This is not a short variant of a branch, but the long variant.
12643   ins_short_branch(0);
12644 
12645   format %{ &quot;B_FAR$cmp $crx, $lbl&quot; %}
12646   size(8);
12647   ins_encode( enc_bc_far(crx, cmp, lbl) );
12648   ins_pipe(pipe_class_default);
12649 %}
12650 
12651 // Conditional Branch used with Power6 scheduler (can be far or short).
12652 instruct branchConSched(cmpOp cmp, flagsRegSrc crx, label lbl) %{
12653   // Same match rule as `branchCon&#39;.
12654   match(If cmp crx);
12655   effect(USE crx, USE lbl);
12656   predicate(false /* TODO: PPC port HB_Schedule*/);
12657   // Higher cost than `branchCon&#39;.
12658   ins_cost(5*BRANCH_COST);
12659 
12660   // Actually size doesn&#39;t depend on alignment but on shortening.
12661   ins_variable_size_depending_on_alignment(true);
12662   // long variant.
12663   ins_short_branch(0);
12664 
12665   format %{ &quot;B_FAR$cmp $crx, $lbl&quot; %}
12666   size(8); // worst case
12667   ins_encode( enc_bc_short_far(crx, cmp, lbl) );
12668   ins_pipe(pipe_class_default);
12669 %}
12670 
12671 instruct branchLoopEnd(cmpOp cmp, flagsRegSrc crx, label labl) %{
12672   match(CountedLoopEnd cmp crx);
12673   effect(USE labl);
12674   ins_cost(BRANCH_COST);
12675 
12676   // short variant.
12677   ins_short_branch(1);
12678 
12679   format %{ &quot;B$cmp     $crx, $labl \t// counted loop end&quot; %}
12680   size(4);
12681   ins_encode( enc_bc(crx, cmp, labl) );
12682   ins_pipe(pipe_class_default);
12683 %}
12684 
12685 instruct branchLoopEndFar(cmpOp cmp, flagsRegSrc crx, label labl) %{
12686   match(CountedLoopEnd cmp crx);
12687   effect(USE labl);
12688   predicate(!false /* TODO: PPC port HB_Schedule */);
12689   ins_cost(BRANCH_COST);
12690 
12691   // Long variant.
12692   ins_short_branch(0);
12693 
12694   format %{ &quot;B_FAR$cmp $crx, $labl \t// counted loop end&quot; %}
12695   size(8);
12696   ins_encode( enc_bc_far(crx, cmp, labl) );
12697   ins_pipe(pipe_class_default);
12698 %}
12699 
12700 // Conditional Branch used with Power6 scheduler (can be far or short).
12701 instruct branchLoopEndSched(cmpOp cmp, flagsRegSrc crx, label labl) %{
12702   match(CountedLoopEnd cmp crx);
12703   effect(USE labl);
12704   predicate(false /* TODO: PPC port HB_Schedule */);
12705   // Higher cost than `branchCon&#39;.
12706   ins_cost(5*BRANCH_COST);
12707 
12708   // Actually size doesn&#39;t depend on alignment but on shortening.
12709   ins_variable_size_depending_on_alignment(true);
12710   // Long variant.
12711   ins_short_branch(0);
12712 
12713   format %{ &quot;B_FAR$cmp $crx, $labl \t// counted loop end&quot; %}
12714   size(8); // worst case
12715   ins_encode( enc_bc_short_far(crx, cmp, labl) );
12716   ins_pipe(pipe_class_default);
12717 %}
12718 
12719 // ============================================================================
12720 // Java runtime operations, intrinsics and other complex operations.
12721 
12722 // The 2nd slow-half of a subtype check. Scan the subklass&#39;s 2ndary superklass
12723 // array for an instance of the superklass. Set a hidden internal cache on a
12724 // hit (cache is checked with exposed code in gen_subtype_check()). Return
12725 // not zero for a miss or zero for a hit. The encoding ALSO sets flags.
12726 //
12727 // GL TODO: Improve this.
12728 // - result should not be a TEMP
12729 // - Add match rule as on sparc avoiding additional Cmp.
12730 instruct partialSubtypeCheck(iRegPdst result, iRegP_N2P subklass, iRegP_N2P superklass,
12731                              iRegPdst tmp_klass, iRegPdst tmp_arrayptr) %{
12732   match(Set result (PartialSubtypeCheck subklass superklass));
12733   effect(TEMP_DEF result, TEMP tmp_klass, TEMP tmp_arrayptr);
12734   ins_cost(DEFAULT_COST*10);
12735 
12736   format %{ &quot;PartialSubtypeCheck $result = ($subklass instanceOf $superklass) tmp: $tmp_klass, $tmp_arrayptr&quot; %}
12737   ins_encode %{
12738     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12739     __ check_klass_subtype_slow_path($subklass$$Register, $superklass$$Register, $tmp_arrayptr$$Register,
12740                                      $tmp_klass$$Register, NULL, $result$$Register);
12741   %}
12742   ins_pipe(pipe_class_default);
12743 %}
12744 
12745 // inlined locking and unlocking
12746 
12747 instruct cmpFastLock(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2) %{
12748   match(Set crx (FastLock oop box));
12749   effect(TEMP tmp1, TEMP tmp2);
12750   predicate(!Compile::current()-&gt;use_rtm());
12751 
12752   format %{ &quot;FASTLOCK  $oop, $box, $tmp1, $tmp2&quot; %}
12753   ins_encode %{
12754     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12755     __ compiler_fast_lock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12756                                  $tmp1$$Register, $tmp2$$Register, /*tmp3*/ R0,
12757                                  UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
12758     // If locking was successfull, crx should indicate &#39;EQ&#39;.
12759     // The compiler generates a branch to the runtime call to
12760     // _complete_monitor_locking_Java for the case where crx is &#39;NE&#39;.
12761   %}
12762   ins_pipe(pipe_class_compare);
12763 %}
12764 
12765 // Separate version for TM. Use bound register for box to enable USE_KILL.
12766 instruct cmpFastLock_tm(flagsReg crx, iRegPdst oop, rarg2RegP box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
12767   match(Set crx (FastLock oop box));
12768   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL box);
12769   predicate(Compile::current()-&gt;use_rtm());
12770 
12771   format %{ &quot;FASTLOCK  $oop, $box, $tmp1, $tmp2, $tmp3 (TM)&quot; %}
12772   ins_encode %{
12773     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12774     __ compiler_fast_lock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12775                                  $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
12776                                  /*Biased Locking*/ false,
12777                                  _rtm_counters, _stack_rtm_counters,
12778                                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12779                                  /*TM*/ true, ra_-&gt;C-&gt;profile_rtm());
12780     // If locking was successfull, crx should indicate &#39;EQ&#39;.
12781     // The compiler generates a branch to the runtime call to
12782     // _complete_monitor_locking_Java for the case where crx is &#39;NE&#39;.
12783   %}
12784   ins_pipe(pipe_class_compare);
12785 %}
12786 
12787 instruct cmpFastUnlock(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
12788   match(Set crx (FastUnlock oop box));
12789   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);
12790   predicate(!Compile::current()-&gt;use_rtm());
12791 
12792   format %{ &quot;FASTUNLOCK  $oop, $box, $tmp1, $tmp2&quot; %}
12793   ins_encode %{
12794     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12795     __ compiler_fast_unlock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12796                                    $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
12797                                    UseBiasedLocking &amp;&amp; !UseOptoBiasInlining,
12798                                    false);
12799     // If unlocking was successfull, crx should indicate &#39;EQ&#39;.
12800     // The compiler generates a branch to the runtime call to
12801     // _complete_monitor_unlocking_Java for the case where crx is &#39;NE&#39;.
12802   %}
12803   ins_pipe(pipe_class_compare);
12804 %}
12805 
12806 instruct cmpFastUnlock_tm(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
12807   match(Set crx (FastUnlock oop box));
12808   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);
12809   predicate(Compile::current()-&gt;use_rtm());
12810 
12811   format %{ &quot;FASTUNLOCK  $oop, $box, $tmp1, $tmp2 (TM)&quot; %}
12812   ins_encode %{
12813     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12814     __ compiler_fast_unlock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12815                                    $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
12816                                    /*Biased Locking*/ false, /*TM*/ true);
12817     // If unlocking was successfull, crx should indicate &#39;EQ&#39;.
12818     // The compiler generates a branch to the runtime call to
12819     // _complete_monitor_unlocking_Java for the case where crx is &#39;NE&#39;.
12820   %}
12821   ins_pipe(pipe_class_compare);
12822 %}
12823 
12824 // Align address.
12825 instruct align_addr(iRegPdst dst, iRegPsrc src, immLnegpow2 mask) %{
12826   match(Set dst (CastX2P (AndL (CastP2X src) mask)));
12827 
12828   format %{ &quot;ANDDI   $dst, $src, $mask \t// next aligned address&quot; %}
12829   size(4);
12830   ins_encode %{
12831     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
12832     __ clrrdi($dst$$Register, $src$$Register, log2_long((jlong)-$mask$$constant));
12833   %}
12834   ins_pipe(pipe_class_default);
12835 %}
12836 
12837 // Array size computation.
12838 instruct array_size(iRegLdst dst, iRegPsrc end, iRegPsrc start) %{
12839   match(Set dst (SubL (CastP2X end) (CastP2X start)));
12840 
12841   format %{ &quot;SUB     $dst, $end, $start \t// array size in bytes&quot; %}
12842   size(4);
12843   ins_encode %{
12844     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
12845     __ subf($dst$$Register, $start$$Register, $end$$Register);
12846   %}
12847   ins_pipe(pipe_class_default);
12848 %}
12849 
12850 // Clear-array with constant short array length. The versions below can use dcbz with cnt &gt; 30.
12851 instruct inlineCallClearArrayShort(immLmax30 cnt, rarg2RegP base, Universe dummy, regCTR ctr) %{
12852   match(Set dummy (ClearArray cnt base));
12853   effect(USE_KILL base, KILL ctr);
12854   ins_cost(2 * MEMORY_REF_COST);
12855 
12856   format %{ &quot;ClearArray $cnt, $base&quot; %}
12857   ins_encode %{
12858     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12859     __ clear_memory_constlen($base$$Register, $cnt$$constant, R0); // kills base, R0
12860   %}
12861   ins_pipe(pipe_class_default);
12862 %}
12863 
12864 // Clear-array with constant large array length.
12865 instruct inlineCallClearArrayLarge(immL cnt, rarg2RegP base, Universe dummy, iRegLdst tmp, regCTR ctr) %{
12866   match(Set dummy (ClearArray cnt base));
12867   effect(USE_KILL base, TEMP tmp, KILL ctr);
12868   ins_cost(3 * MEMORY_REF_COST);
12869 
12870   format %{ &quot;ClearArray $cnt, $base \t// KILL $tmp&quot; %}
12871   ins_encode %{
12872     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12873     __ clear_memory_doubleword($base$$Register, $tmp$$Register, R0, $cnt$$constant); // kills base, R0
12874   %}
12875   ins_pipe(pipe_class_default);
12876 %}
12877 
12878 // Clear-array with dynamic array length.
12879 instruct inlineCallClearArray(rarg1RegL cnt, rarg2RegP base, Universe dummy, regCTR ctr) %{
12880   match(Set dummy (ClearArray cnt base));
12881   effect(USE_KILL cnt, USE_KILL base, KILL ctr);
12882   ins_cost(4 * MEMORY_REF_COST);
12883 
12884   format %{ &quot;ClearArray $cnt, $base&quot; %}
12885   ins_encode %{
12886     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12887     __ clear_memory_doubleword($base$$Register, $cnt$$Register, R0); // kills cnt, base, R0
12888   %}
12889   ins_pipe(pipe_class_default);
12890 %}
12891 
12892 instruct string_compareL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12893                          iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12894   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
12895   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12896   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12897   ins_cost(300);
12898   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12899   ins_encode %{
12900     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12901     __ string_compare($str1$$Register, $str2$$Register,
12902                       $cnt1$$Register, $cnt2$$Register,
12903                       $tmp$$Register,
12904                       $result$$Register, StrIntrinsicNode::LL);
12905   %}
12906   ins_pipe(pipe_class_default);
12907 %}
12908 
12909 instruct string_compareU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12910                          iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12911   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
12912   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12913   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12914   ins_cost(300);
12915   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12916   ins_encode %{
12917     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12918     __ string_compare($str1$$Register, $str2$$Register,
12919                       $cnt1$$Register, $cnt2$$Register,
12920                       $tmp$$Register,
12921                       $result$$Register, StrIntrinsicNode::UU);
12922   %}
12923   ins_pipe(pipe_class_default);
12924 %}
12925 
12926 instruct string_compareLU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12927                           iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12928   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
12929   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12930   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12931   ins_cost(300);
12932   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12933   ins_encode %{
12934     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12935     __ string_compare($str1$$Register, $str2$$Register,
12936                       $cnt1$$Register, $cnt2$$Register,
12937                       $tmp$$Register,
12938                       $result$$Register, StrIntrinsicNode::LU);
12939   %}
12940   ins_pipe(pipe_class_default);
12941 %}
12942 
12943 instruct string_compareUL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12944                           iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12945   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
12946   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12947   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12948   ins_cost(300);
12949   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12950   ins_encode %{
12951     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12952     __ string_compare($str2$$Register, $str1$$Register,
12953                       $cnt2$$Register, $cnt1$$Register,
12954                       $tmp$$Register,
12955                       $result$$Register, StrIntrinsicNode::UL);
12956   %}
12957   ins_pipe(pipe_class_default);
12958 %}
12959 
12960 instruct string_equalsL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt, iRegIdst result,
12961                         iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12962   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
12963   match(Set result (StrEquals (Binary str1 str2) cnt));
12964   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP tmp, KILL ctr, KILL cr0);
12965   ins_cost(300);
12966   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result \t// KILL $tmp&quot; %}
12967   ins_encode %{
12968     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12969     __ array_equals(false, $str1$$Register, $str2$$Register,
12970                     $cnt$$Register, $tmp$$Register,
12971                     $result$$Register, true /* byte */);
12972   %}
12973   ins_pipe(pipe_class_default);
12974 %}
12975 
12976 instruct string_equalsU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt, iRegIdst result,
12977                         iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12978   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
12979   match(Set result (StrEquals (Binary str1 str2) cnt));
12980   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP tmp, KILL ctr, KILL cr0);
12981   ins_cost(300);
12982   format %{ &quot;String Equals char[]  $str1,$str2,$cnt -&gt; $result \t// KILL $tmp&quot; %}
12983   ins_encode %{
12984     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12985     __ array_equals(false, $str1$$Register, $str2$$Register,
12986                     $cnt$$Register, $tmp$$Register,
12987                     $result$$Register, false /* byte */);
12988   %}
12989   ins_pipe(pipe_class_default);
12990 %}
12991 
12992 instruct array_equalsB(rarg1RegP ary1, rarg2RegP ary2, iRegIdst result,
12993                        iRegIdst tmp1, iRegIdst tmp2, regCTR ctr, flagsRegCR0 cr0, flagsRegCR0 cr1) %{
12994   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
12995   match(Set result (AryEq ary1 ary2));
12996   effect(TEMP_DEF result, USE_KILL ary1, USE_KILL ary2, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0, KILL cr1);
12997   ins_cost(300);
12998   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result \t// KILL $tmp1,$tmp2&quot; %}
12999   ins_encode %{
13000     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13001     __ array_equals(true, $ary1$$Register, $ary2$$Register,
13002                     $tmp1$$Register, $tmp2$$Register,
13003                     $result$$Register, true /* byte */);
13004   %}
13005   ins_pipe(pipe_class_default);
13006 %}
13007 
13008 instruct array_equalsC(rarg1RegP ary1, rarg2RegP ary2, iRegIdst result,
13009                        iRegIdst tmp1, iRegIdst tmp2, regCTR ctr, flagsRegCR0 cr0, flagsRegCR0 cr1) %{
13010   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
13011   match(Set result (AryEq ary1 ary2));
13012   effect(TEMP_DEF result, USE_KILL ary1, USE_KILL ary2, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0, KILL cr1);
13013   ins_cost(300);
13014   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result \t// KILL $tmp1,$tmp2&quot; %}
13015   ins_encode %{
13016     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13017     __ array_equals(true, $ary1$$Register, $ary2$$Register,
13018                     $tmp1$$Register, $tmp2$$Register,
13019                     $result$$Register, false /* byte */);
13020   %}
13021   ins_pipe(pipe_class_default);
13022 %}
13023 
13024 instruct indexOf_imm1_char_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13025                              immP needleImm, immL offsetImm, immI_1 needlecntImm,
13026                              iRegIdst tmp1, iRegIdst tmp2,
13027                              flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13028   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
13029   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13030   // Required for EA: check if it is still a type_array.
13031   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
13032   ins_cost(150);
13033 
13034   format %{ &quot;String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]&quot;
13035             &quot;-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13036 
13037   ins_encode %{
13038     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13039     immPOper *needleOper = (immPOper *)$needleImm;
13040     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
13041     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
13042     jchar chr;
13043 #ifdef VM_LITTLE_ENDIAN
13044     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte()) &lt;&lt; 8) |
13045            ((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte());
13046 #else
13047     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte()) &lt;&lt; 8) |
13048            ((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte());
13049 #endif
13050     __ string_indexof_char($result$$Register,
13051                            $haystack$$Register, $haycnt$$Register,
13052                            R0, chr,
13053                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13054   %}
13055   ins_pipe(pipe_class_compare);
13056 %}
13057 
13058 instruct indexOf_imm1_char_L(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13059                              immP needleImm, immL offsetImm, immI_1 needlecntImm,
13060                              iRegIdst tmp1, iRegIdst tmp2,
13061                              flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13062   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
13063   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13064   // Required for EA: check if it is still a type_array.
13065   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
13066   ins_cost(150);
13067 
13068   format %{ &quot;String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]&quot;
13069             &quot;-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13070 
13071   ins_encode %{
13072     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13073     immPOper *needleOper = (immPOper *)$needleImm;
13074     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
13075     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
13076     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13077     __ string_indexof_char($result$$Register,
13078                            $haystack$$Register, $haycnt$$Register,
13079                            R0, chr,
13080                            $tmp1$$Register, $tmp2$$Register, true /*is_byte*/);
13081   %}
13082   ins_pipe(pipe_class_compare);
13083 %}
13084 
13085 instruct indexOf_imm1_char_UL(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13086                               immP needleImm, immL offsetImm, immI_1 needlecntImm,
13087                               iRegIdst tmp1, iRegIdst tmp2,
13088                               flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13089   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
13090   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13091   // Required for EA: check if it is still a type_array.
13092   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
13093   ins_cost(150);
13094 
13095   format %{ &quot;String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]&quot;
13096             &quot;-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13097 
13098   ins_encode %{
13099     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13100     immPOper *needleOper = (immPOper *)$needleImm;
13101     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
13102     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
13103     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13104     __ string_indexof_char($result$$Register,
13105                            $haystack$$Register, $haycnt$$Register,
13106                            R0, chr,
13107                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13108   %}
13109   ins_pipe(pipe_class_compare);
13110 %}
13111 
13112 instruct indexOf_imm1_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13113                         rscratch2RegP needle, immI_1 needlecntImm,
13114                         iRegIdst tmp1, iRegIdst tmp2,
13115                         flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13116   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13117   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13118   // Required for EA: check if it is still a type_array.
13119   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU &amp;&amp;
13120             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13121             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13122   ins_cost(180);
13123 
13124   format %{ &quot;String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13125             &quot; -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13126   ins_encode %{
13127     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13128     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13129     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13130     guarantee(needle_values, &quot;sanity&quot;);
13131     jchar chr;
13132 #ifdef VM_LITTLE_ENDIAN
13133     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte()) &lt;&lt; 8) |
13134            ((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte());
13135 #else
13136     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte()) &lt;&lt; 8) |
13137            ((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte());
13138 #endif
13139     __ string_indexof_char($result$$Register,
13140                            $haystack$$Register, $haycnt$$Register,
13141                            R0, chr,
13142                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13143   %}
13144   ins_pipe(pipe_class_compare);
13145 %}
13146 
13147 instruct indexOf_imm1_L(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13148                         rscratch2RegP needle, immI_1 needlecntImm,
13149                         iRegIdst tmp1, iRegIdst tmp2,
13150                         flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13151   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13152   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13153   // Required for EA: check if it is still a type_array.
13154   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL &amp;&amp;
13155             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13156             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13157   ins_cost(180);
13158 
13159   format %{ &quot;String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13160             &quot; -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13161   ins_encode %{
13162     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13163     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13164     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13165     guarantee(needle_values, &quot;sanity&quot;);
13166     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13167     __ string_indexof_char($result$$Register,
13168                            $haystack$$Register, $haycnt$$Register,
13169                            R0, chr,
13170                            $tmp1$$Register, $tmp2$$Register, true /*is_byte*/);
13171   %}
13172   ins_pipe(pipe_class_compare);
13173 %}
13174 
13175 instruct indexOf_imm1_UL(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13176                          rscratch2RegP needle, immI_1 needlecntImm,
13177                          iRegIdst tmp1, iRegIdst tmp2,
13178                          flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13179   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13180   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13181   // Required for EA: check if it is still a type_array.
13182   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL &amp;&amp;
13183             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13184             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13185   ins_cost(180);
13186 
13187   format %{ &quot;String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13188             &quot; -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13189   ins_encode %{
13190     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13191     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13192     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13193     guarantee(needle_values, &quot;sanity&quot;);
13194     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13195     __ string_indexof_char($result$$Register,
13196                            $haystack$$Register, $haycnt$$Register,
13197                            R0, chr,
13198                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13199   %}
13200   ins_pipe(pipe_class_compare);
13201 %}
13202 
13203 instruct indexOfChar_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13204                        iRegIsrc ch, iRegIdst tmp1, iRegIdst tmp2,
13205                        flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13206   match(Set result (StrIndexOfChar (Binary haystack haycnt) ch));
13207   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13208   ins_cost(180);
13209 
13210   format %{ &quot;String IndexOfChar $haystack[0..$haycnt], $ch&quot;
13211             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13212   ins_encode %{
13213     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13214     __ string_indexof_char($result$$Register,
13215                            $haystack$$Register, $haycnt$$Register,
13216                            $ch$$Register, 0 /* this is not used if the character is already in a register */,
13217                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13218   %}
13219   ins_pipe(pipe_class_compare);
13220 %}
13221 
13222 instruct indexOf_imm_U(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
13223                        iRegPsrc needle, uimmI15 needlecntImm,
13224                        iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
13225                        flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13226   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13227   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
13228          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13229   // Required for EA: check if it is still a type_array.
13230   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU &amp;&amp;
13231             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13232             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13233   ins_cost(250);
13234 
13235   format %{ &quot;String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13236             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1&quot; %}
13237   ins_encode %{
13238     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13239     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13240     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13241 
13242     __ string_indexof($result$$Register,
13243                       $haystack$$Register, $haycnt$$Register,
13244                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
13245                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UU);
13246   %}
13247   ins_pipe(pipe_class_compare);
13248 %}
13249 
13250 instruct indexOf_imm_L(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
13251                        iRegPsrc needle, uimmI15 needlecntImm,
13252                        iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
13253                        flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13254   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13255   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
13256          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13257   // Required for EA: check if it is still a type_array.
13258   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL &amp;&amp;
13259             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13260             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13261   ins_cost(250);
13262 
13263   format %{ &quot;String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13264             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1&quot; %}
13265   ins_encode %{
13266     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13267     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13268     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13269 
13270     __ string_indexof($result$$Register,
13271                       $haystack$$Register, $haycnt$$Register,
13272                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
13273                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::LL);
13274   %}
13275   ins_pipe(pipe_class_compare);
13276 %}
13277 
13278 instruct indexOf_imm_UL(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
13279                         iRegPsrc needle, uimmI15 needlecntImm,
13280                         iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
13281                         flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13282   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13283   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
13284          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13285   // Required for EA: check if it is still a type_array.
13286   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL &amp;&amp;
13287             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13288             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13289   ins_cost(250);
13290 
13291   format %{ &quot;String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13292             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1&quot; %}
13293   ins_encode %{
13294     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13295     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13296     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13297 
13298     __ string_indexof($result$$Register,
13299                       $haystack$$Register, $haycnt$$Register,
13300                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
13301                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UL);
13302   %}
13303   ins_pipe(pipe_class_compare);
13304 %}
13305 
13306 instruct indexOf_U(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
13307                    iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
13308                    flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13309   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
13310   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
13311          TEMP_DEF result,
13312          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13313   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
13314   ins_cost(300);
13315 
13316   format %{ &quot;String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]&quot;
13317              &quot; -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1&quot; %}
13318   ins_encode %{
13319     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13320     __ string_indexof($result$$Register,
13321                       $haystack$$Register, $haycnt$$Register,
13322                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
13323                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UU);
13324   %}
13325   ins_pipe(pipe_class_compare);
13326 %}
13327 
13328 instruct indexOf_L(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
13329                    iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
13330                    flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13331   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
13332   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
13333          TEMP_DEF result,
13334          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13335   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
13336   ins_cost(300);
13337 
13338   format %{ &quot;String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]&quot;
13339              &quot; -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1&quot; %}
13340   ins_encode %{
13341     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13342     __ string_indexof($result$$Register,
13343                       $haystack$$Register, $haycnt$$Register,
13344                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
13345                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::LL);
13346   %}
13347   ins_pipe(pipe_class_compare);
13348 %}
13349 
13350 instruct indexOf_UL(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
13351                     iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
13352                     flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13353   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
13354   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
13355          TEMP_DEF result,
13356          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13357   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
13358   ins_cost(300);
13359 
13360   format %{ &quot;String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]&quot;
13361              &quot; -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1&quot; %}
13362   ins_encode %{
13363     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13364     __ string_indexof($result$$Register,
13365                       $haystack$$Register, $haycnt$$Register,
13366                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
13367                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UL);
13368   %}
13369   ins_pipe(pipe_class_compare);
13370 %}
13371 
13372 // char[] to byte[] compression
13373 instruct string_compress(rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegIdst result, iRegLdst tmp1,
13374                          iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
13375   match(Set result (StrCompressedCopy src (Binary dst len)));
13376   effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5,
13377          USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
13378   ins_cost(300);
13379   format %{ &quot;String Compress $src,$dst,$len -&gt; $result \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5&quot; %}
13380   ins_encode %{
13381     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13382     Label Lskip, Ldone;
13383     __ li($result$$Register, 0);
13384     __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
13385                           $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register, Ldone);
13386     __ rldicl_($tmp1$$Register, $len$$Register, 0, 64-3); // Remaining characters.
13387     __ beq(CCR0, Lskip);
13388     __ string_compress($src$$Register, $dst$$Register, $tmp1$$Register, $tmp2$$Register, Ldone);
13389     __ bind(Lskip);
13390     __ mr($result$$Register, $len$$Register);
13391     __ bind(Ldone);
13392   %}
13393   ins_pipe(pipe_class_default);
13394 %}
13395 
13396 // byte[] to char[] inflation
13397 instruct string_inflate(Universe dummy, rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegLdst tmp1,
13398                         iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
13399   match(Set dummy (StrInflatedCopy src (Binary dst len)));
13400   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
13401   ins_cost(300);
13402   format %{ &quot;String Inflate $src,$dst,$len \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5&quot; %}
13403   ins_encode %{
13404     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13405     Label Ldone;
13406     __ string_inflate_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
13407                          $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register);
13408     __ rldicl_($tmp1$$Register, $len$$Register, 0, 64-3); // Remaining characters.
13409     __ beq(CCR0, Ldone);
13410     __ string_inflate($src$$Register, $dst$$Register, $tmp1$$Register, $tmp2$$Register);
13411     __ bind(Ldone);
13412   %}
13413   ins_pipe(pipe_class_default);
13414 %}
13415 
13416 // StringCoding.java intrinsics
13417 instruct has_negatives(rarg1RegP ary1, iRegIsrc len, iRegIdst result, iRegLdst tmp1, iRegLdst tmp2,
13418                        regCTR ctr, flagsRegCR0 cr0)
13419 %{
13420   match(Set result (HasNegatives ary1 len));
13421   effect(TEMP_DEF result, USE_KILL ary1, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0);
13422   ins_cost(300);
13423   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result \t// KILL $tmp1, $tmp2&quot; %}
13424   ins_encode %{
13425     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13426     __ has_negatives($ary1$$Register, $len$$Register, $result$$Register,
13427                      $tmp1$$Register, $tmp2$$Register);
13428   %}
13429   ins_pipe(pipe_class_default);
13430 %}
13431 
13432 // encode char[] to byte[] in ISO_8859_1
13433 instruct encode_iso_array(rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegIdst result, iRegLdst tmp1,
13434                           iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
13435   match(Set result (EncodeISOArray src (Binary dst len)));
13436   effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5,
13437          USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
13438   ins_cost(300);
13439   format %{ &quot;Encode array $src,$dst,$len -&gt; $result \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5&quot; %}
13440   ins_encode %{
13441     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13442     Label Lslow, Lfailure1, Lfailure2, Ldone;
13443     __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
13444                           $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register, Lfailure1);
13445     __ rldicl_($result$$Register, $len$$Register, 0, 64-3); // Remaining characters.
13446     __ beq(CCR0, Ldone);
13447     __ bind(Lslow);
13448     __ string_compress($src$$Register, $dst$$Register, $result$$Register, $tmp2$$Register, Lfailure2);
13449     __ li($result$$Register, 0);
13450     __ b(Ldone);
13451 
13452     __ bind(Lfailure1);
13453     __ mr($result$$Register, $len$$Register);
13454     __ mfctr($tmp1$$Register);
13455     __ rldimi_($result$$Register, $tmp1$$Register, 3, 0); // Remaining characters.
13456     __ beq(CCR0, Ldone);
13457     __ b(Lslow);
13458 
13459     __ bind(Lfailure2);
13460     __ mfctr($result$$Register); // Remaining characters.
13461 
13462     __ bind(Ldone);
13463     __ subf($result$$Register, $result$$Register, $len$$Register);
13464   %}
13465   ins_pipe(pipe_class_default);
13466 %}
13467 
13468 
13469 //---------- Min/Max Instructions ---------------------------------------------
13470 
13471 instruct minI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
13472   match(Set dst (MinI src1 src2));
13473   ins_cost(DEFAULT_COST*6);
13474 
13475   expand %{
13476     iRegLdst src1s;
13477     iRegLdst src2s;
13478     iRegLdst diff;
13479     iRegLdst sm;
13480     iRegLdst doz; // difference or zero
13481     convI2L_reg(src1s, src1); // Ensure proper sign extension.
13482     convI2L_reg(src2s, src2); // Ensure proper sign extension.
13483     subL_reg_reg(diff, src2s, src1s);
13484     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
13485     signmask64L_regL(sm, diff);
13486     andL_reg_reg(doz, diff, sm); // &lt;=0
13487     addI_regL_regL(dst, doz, src1s);
13488   %}
13489 %}
13490 
13491 instruct minI_reg_reg_isel(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
13492   match(Set dst (MinI src1 src2));
13493   effect(KILL cr0);
13494   predicate(VM_Version::has_isel());
13495   ins_cost(DEFAULT_COST*2);
13496 
13497   ins_encode %{
13498     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13499     __ cmpw(CCR0, $src1$$Register, $src2$$Register);
13500     __ isel($dst$$Register, CCR0, Assembler::less, /*invert*/false, $src1$$Register, $src2$$Register);
13501   %}
13502   ins_pipe(pipe_class_default);
13503 %}
13504 
13505 instruct maxI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
13506   match(Set dst (MaxI src1 src2));
13507   ins_cost(DEFAULT_COST*6);
13508 
13509   expand %{
13510     iRegLdst src1s;
13511     iRegLdst src2s;
13512     iRegLdst diff;
13513     iRegLdst sm;
13514     iRegLdst doz; // difference or zero
13515     convI2L_reg(src1s, src1); // Ensure proper sign extension.
13516     convI2L_reg(src2s, src2); // Ensure proper sign extension.
13517     subL_reg_reg(diff, src2s, src1s);
13518     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
13519     signmask64L_regL(sm, diff);
13520     andcL_reg_reg(doz, diff, sm); // &gt;=0
13521     addI_regL_regL(dst, doz, src1s);
13522   %}
13523 %}
13524 
13525 instruct maxI_reg_reg_isel(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
13526   match(Set dst (MaxI src1 src2));
13527   effect(KILL cr0);
13528   predicate(VM_Version::has_isel());
13529   ins_cost(DEFAULT_COST*2);
13530 
13531   ins_encode %{
13532     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13533     __ cmpw(CCR0, $src1$$Register, $src2$$Register);
13534     __ isel($dst$$Register, CCR0, Assembler::greater, /*invert*/false, $src1$$Register, $src2$$Register);
13535   %}
13536   ins_pipe(pipe_class_default);
13537 %}
13538 
13539 //---------- Population Count Instructions ------------------------------------
13540 
13541 // Popcnt for Power7.
13542 instruct popCountI(iRegIdst dst, iRegIsrc src) %{
13543   match(Set dst (PopCountI src));
13544   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
13545   ins_cost(DEFAULT_COST);
13546 
13547   format %{ &quot;POPCNTW $dst, $src&quot; %}
13548   size(4);
13549   ins_encode %{
13550     // TODO: PPC port $archOpcode(ppc64Opcode_popcntb);
13551     __ popcntw($dst$$Register, $src$$Register);
13552   %}
13553   ins_pipe(pipe_class_default);
13554 %}
13555 
13556 // Popcnt for Power7.
13557 instruct popCountL(iRegIdst dst, iRegLsrc src) %{
13558   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
13559   match(Set dst (PopCountL src));
13560   ins_cost(DEFAULT_COST);
13561 
13562   format %{ &quot;POPCNTD $dst, $src&quot; %}
13563   size(4);
13564   ins_encode %{
13565     // TODO: PPC port $archOpcode(ppc64Opcode_popcntb);
13566     __ popcntd($dst$$Register, $src$$Register);
13567   %}
13568   ins_pipe(pipe_class_default);
13569 %}
13570 
13571 instruct countLeadingZerosI(iRegIdst dst, iRegIsrc src) %{
13572   match(Set dst (CountLeadingZerosI src));
13573   predicate(UseCountLeadingZerosInstructionsPPC64);  // See Matcher::match_rule_supported.
13574   ins_cost(DEFAULT_COST);
13575 
13576   format %{ &quot;CNTLZW  $dst, $src&quot; %}
13577   size(4);
13578   ins_encode %{
13579     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzw);
13580     __ cntlzw($dst$$Register, $src$$Register);
13581   %}
13582   ins_pipe(pipe_class_default);
13583 %}
13584 
13585 instruct countLeadingZerosL(iRegIdst dst, iRegLsrc src) %{
13586   match(Set dst (CountLeadingZerosL src));
13587   predicate(UseCountLeadingZerosInstructionsPPC64);  // See Matcher::match_rule_supported.
13588   ins_cost(DEFAULT_COST);
13589 
13590   format %{ &quot;CNTLZD  $dst, $src&quot; %}
13591   size(4);
13592   ins_encode %{
13593     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzd);
13594     __ cntlzd($dst$$Register, $src$$Register);
13595   %}
13596   ins_pipe(pipe_class_default);
13597 %}
13598 
13599 instruct countLeadingZerosP(iRegIdst dst, iRegPsrc src) %{
13600   // no match-rule, false predicate
13601   effect(DEF dst, USE src);
13602   predicate(false);
13603 
13604   format %{ &quot;CNTLZD  $dst, $src&quot; %}
13605   size(4);
13606   ins_encode %{
13607     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzd);
13608     __ cntlzd($dst$$Register, $src$$Register);
13609   %}
13610   ins_pipe(pipe_class_default);
13611 %}
13612 
13613 instruct countTrailingZerosI_Ex(iRegIdst dst, iRegIsrc src) %{
13614   match(Set dst (CountTrailingZerosI src));
13615   predicate(UseCountLeadingZerosInstructionsPPC64 &amp;&amp; !UseCountTrailingZerosInstructionsPPC64);
13616   ins_cost(DEFAULT_COST);
13617 
13618   expand %{
13619     immI16 imm1 %{ (int)-1 %}
13620     immI16 imm2 %{ (int)32 %}
13621     immI_minus1 m1 %{ -1 %}
13622     iRegIdst tmpI1;
13623     iRegIdst tmpI2;
13624     iRegIdst tmpI3;
13625     addI_reg_imm16(tmpI1, src, imm1);
13626     andcI_reg_reg(tmpI2, src, m1, tmpI1);
13627     countLeadingZerosI(tmpI3, tmpI2);
13628     subI_imm16_reg(dst, imm2, tmpI3);
13629   %}
13630 %}
13631 
13632 instruct countTrailingZerosI_cnttzw(iRegIdst dst, iRegIsrc src) %{
13633   match(Set dst (CountTrailingZerosI src));
13634   predicate(UseCountTrailingZerosInstructionsPPC64);
13635   ins_cost(DEFAULT_COST);
13636 
13637   format %{ &quot;CNTTZW  $dst, $src&quot; %}
13638   size(4);
13639   ins_encode %{
13640     __ cnttzw($dst$$Register, $src$$Register);
13641   %}
13642   ins_pipe(pipe_class_default);
13643 %}
13644 
13645 instruct countTrailingZerosL_Ex(iRegIdst dst, iRegLsrc src) %{
13646   match(Set dst (CountTrailingZerosL src));
13647   predicate(UseCountLeadingZerosInstructionsPPC64 &amp;&amp; !UseCountTrailingZerosInstructionsPPC64);
13648   ins_cost(DEFAULT_COST);
13649 
13650   expand %{
13651     immL16 imm1 %{ (long)-1 %}
13652     immI16 imm2 %{ (int)64 %}
13653     iRegLdst tmpL1;
13654     iRegLdst tmpL2;
13655     iRegIdst tmpL3;
13656     addL_reg_imm16(tmpL1, src, imm1);
13657     andcL_reg_reg(tmpL2, tmpL1, src);
13658     countLeadingZerosL(tmpL3, tmpL2);
13659     subI_imm16_reg(dst, imm2, tmpL3);
13660  %}
13661 %}
13662 
13663 instruct countTrailingZerosL_cnttzd(iRegIdst dst, iRegLsrc src) %{
13664   match(Set dst (CountTrailingZerosL src));
13665   predicate(UseCountTrailingZerosInstructionsPPC64);
13666   ins_cost(DEFAULT_COST);
13667 
13668   format %{ &quot;CNTTZD  $dst, $src&quot; %}
13669   size(4);
13670   ins_encode %{
13671     __ cnttzd($dst$$Register, $src$$Register);
13672   %}
13673   ins_pipe(pipe_class_default);
13674 %}
13675 
13676 // Expand nodes for byte_reverse_int.
13677 instruct insrwi_a(iRegIdst dst, iRegIsrc src, immI16 pos, immI16 shift) %{
13678   effect(DEF dst, USE src, USE pos, USE shift);
13679   predicate(false);
13680 
13681   format %{ &quot;INSRWI  $dst, $src, $pos, $shift&quot; %}
13682   size(4);
13683   ins_encode %{
13684     // TODO: PPC port $archOpcode(ppc64Opcode_rlwimi);
13685     __ insrwi($dst$$Register, $src$$Register, $shift$$constant, $pos$$constant);
13686   %}
13687   ins_pipe(pipe_class_default);
13688 %}
13689 
13690 // As insrwi_a, but with USE_DEF.
13691 instruct insrwi(iRegIdst dst, iRegIsrc src, immI16 pos, immI16 shift) %{
13692   effect(USE_DEF dst, USE src, USE pos, USE shift);
13693   predicate(false);
13694 
13695   format %{ &quot;INSRWI  $dst, $src, $pos, $shift&quot; %}
13696   size(4);
13697   ins_encode %{
13698     // TODO: PPC port $archOpcode(ppc64Opcode_rlwimi);
13699     __ insrwi($dst$$Register, $src$$Register, $shift$$constant, $pos$$constant);
13700   %}
13701   ins_pipe(pipe_class_default);
13702 %}
13703 
13704 // Just slightly faster than java implementation.
13705 instruct bytes_reverse_int_Ex(iRegIdst dst, iRegIsrc src) %{
13706   match(Set dst (ReverseBytesI src));
13707   ins_cost(7*DEFAULT_COST);
13708 
13709   expand %{
13710     immI16 imm24 %{ (int) 24 %}
13711     immI16 imm16 %{ (int) 16 %}
13712     immI16  imm8 %{ (int)  8 %}
13713     immI16  imm4 %{ (int)  4 %}
13714     immI16  imm0 %{ (int)  0 %}
13715     iRegLdst tmpI1;
13716     iRegLdst tmpI2;
13717     iRegLdst tmpI3;
13718 
13719     urShiftI_reg_imm(tmpI1, src, imm24);
13720     insrwi_a(dst, tmpI1, imm24, imm8);
13721     urShiftI_reg_imm(tmpI2, src, imm16);
13722     insrwi(dst, tmpI2, imm8, imm16);
13723     urShiftI_reg_imm(tmpI3, src, imm8);
13724     insrwi(dst, tmpI3, imm8, imm8);
13725     insrwi(dst, src, imm0, imm8);
13726   %}
13727 %}
13728 
13729 instruct bytes_reverse_long_Ex(iRegLdst dst, iRegLsrc src) %{
13730   match(Set dst (ReverseBytesL src));
13731   ins_cost(15*DEFAULT_COST);
13732 
13733   expand %{
13734     immI16 imm56 %{ (int) 56 %}
13735     immI16 imm48 %{ (int) 48 %}
13736     immI16 imm40 %{ (int) 40 %}
13737     immI16 imm32 %{ (int) 32 %}
13738     immI16 imm24 %{ (int) 24 %}
13739     immI16 imm16 %{ (int) 16 %}
13740     immI16  imm8 %{ (int)  8 %}
13741     immI16  imm0 %{ (int)  0 %}
13742     iRegLdst tmpL1;
13743     iRegLdst tmpL2;
13744     iRegLdst tmpL3;
13745     iRegLdst tmpL4;
13746     iRegLdst tmpL5;
13747     iRegLdst tmpL6;
13748 
13749                                         // src   : |a|b|c|d|e|f|g|h|
13750     rldicl(tmpL1, src, imm8, imm24);    // tmpL1 : | | | |e|f|g|h|a|
13751     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |a| | | |e|
13752     rldicl(tmpL3, tmpL2, imm32, imm0);  // tmpL3 : | | | |e| | | |a|
13753     rldicl(tmpL1, src, imm16, imm24);   // tmpL1 : | | | |f|g|h|a|b|
13754     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |b| | | |f|
13755     rldicl(tmpL4, tmpL2, imm40, imm0);  // tmpL4 : | | |f| | | |b| |
13756     orL_reg_reg(tmpL5, tmpL3, tmpL4);   // tmpL5 : | | |f|e| | |b|a|
13757     rldicl(tmpL1, src, imm24, imm24);   // tmpL1 : | | | |g|h|a|b|c|
13758     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |c| | | |g|
13759     rldicl(tmpL3, tmpL2, imm48, imm0);  // tmpL3 : | |g| | | |c| | |
13760     rldicl(tmpL1, src, imm32, imm24);   // tmpL1 : | | | |h|a|b|c|d|
13761     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |d| | | |h|
13762     rldicl(tmpL4, tmpL2, imm56, imm0);  // tmpL4 : |h| | | |d| | | |
13763     orL_reg_reg(tmpL6, tmpL3, tmpL4);   // tmpL6 : |h|g| | |d|c| | |
13764     orL_reg_reg(dst, tmpL5, tmpL6);     // dst   : |h|g|f|e|d|c|b|a|
13765   %}
13766 %}
13767 
13768 instruct bytes_reverse_ushort_Ex(iRegIdst dst, iRegIsrc src) %{
13769   match(Set dst (ReverseBytesUS src));
13770   ins_cost(2*DEFAULT_COST);
13771 
13772   expand %{
13773     immI16  imm16 %{ (int) 16 %}
13774     immI16   imm8 %{ (int)  8 %}
13775 
13776     urShiftI_reg_imm(dst, src, imm8);
13777     insrwi(dst, src, imm16, imm8);
13778   %}
13779 %}
13780 
13781 instruct bytes_reverse_short_Ex(iRegIdst dst, iRegIsrc src) %{
13782   match(Set dst (ReverseBytesS src));
13783   ins_cost(3*DEFAULT_COST);
13784 
13785   expand %{
13786     immI16  imm16 %{ (int) 16 %}
13787     immI16   imm8 %{ (int)  8 %}
13788     iRegLdst tmpI1;
13789 
13790     urShiftI_reg_imm(tmpI1, src, imm8);
13791     insrwi(tmpI1, src, imm16, imm8);
13792     extsh(dst, tmpI1);
13793   %}
13794 %}
13795 
13796 // Load Integer reversed byte order
13797 instruct loadI_reversed(iRegIdst dst, indirect mem) %{
13798   match(Set dst (ReverseBytesI (LoadI mem)));
13799   ins_cost(MEMORY_REF_COST);
13800 
13801   size(4);
13802   ins_encode %{
13803     __ lwbrx($dst$$Register, $mem$$Register);
13804   %}
13805   ins_pipe(pipe_class_default);
13806 %}
13807 
13808 // Load Long - aligned and reversed
13809 instruct loadL_reversed(iRegLdst dst, indirect mem) %{
13810   match(Set dst (ReverseBytesL (LoadL mem)));
13811   predicate(VM_Version::has_ldbrx());
13812   ins_cost(MEMORY_REF_COST);
13813 
13814   size(4);
13815   ins_encode %{
13816     __ ldbrx($dst$$Register, $mem$$Register);
13817   %}
13818   ins_pipe(pipe_class_default);
13819 %}
13820 
13821 // Load unsigned short / char reversed byte order
13822 instruct loadUS_reversed(iRegIdst dst, indirect mem) %{
13823   match(Set dst (ReverseBytesUS (LoadUS mem)));
13824   ins_cost(MEMORY_REF_COST);
13825 
13826   size(4);
13827   ins_encode %{
13828     __ lhbrx($dst$$Register, $mem$$Register);
13829   %}
13830   ins_pipe(pipe_class_default);
13831 %}
13832 
13833 // Load short reversed byte order
13834 instruct loadS_reversed(iRegIdst dst, indirect mem) %{
13835   match(Set dst (ReverseBytesS (LoadS mem)));
13836   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
13837 
13838   size(8);
13839   ins_encode %{
13840     __ lhbrx($dst$$Register, $mem$$Register);
13841     __ extsh($dst$$Register, $dst$$Register);
13842   %}
13843   ins_pipe(pipe_class_default);
13844 %}
13845 
13846 // Store Integer reversed byte order
13847 instruct storeI_reversed(iRegIsrc src, indirect mem) %{
13848   match(Set mem (StoreI mem (ReverseBytesI src)));
13849   ins_cost(MEMORY_REF_COST);
13850 
13851   size(4);
13852   ins_encode %{
13853     __ stwbrx($src$$Register, $mem$$Register);
13854   %}
13855   ins_pipe(pipe_class_default);
13856 %}
13857 
13858 // Store Long reversed byte order
13859 instruct storeL_reversed(iRegLsrc src, indirect mem) %{
13860   match(Set mem (StoreL mem (ReverseBytesL src)));
13861   predicate(VM_Version::has_stdbrx());
13862   ins_cost(MEMORY_REF_COST);
13863 
13864   size(4);
13865   ins_encode %{
13866     __ stdbrx($src$$Register, $mem$$Register);
13867   %}
13868   ins_pipe(pipe_class_default);
13869 %}
13870 
13871 // Store unsigned short / char reversed byte order
13872 instruct storeUS_reversed(iRegIsrc src, indirect mem) %{
13873   match(Set mem (StoreC mem (ReverseBytesUS src)));
13874   ins_cost(MEMORY_REF_COST);
13875 
13876   size(4);
13877   ins_encode %{
13878     __ sthbrx($src$$Register, $mem$$Register);
13879   %}
13880   ins_pipe(pipe_class_default);
13881 %}
13882 
13883 // Store short reversed byte order
13884 instruct storeS_reversed(iRegIsrc src, indirect mem) %{
13885   match(Set mem (StoreC mem (ReverseBytesS src)));
13886   ins_cost(MEMORY_REF_COST);
13887 
13888   size(4);
13889   ins_encode %{
13890     __ sthbrx($src$$Register, $mem$$Register);
13891   %}
13892   ins_pipe(pipe_class_default);
13893 %}
13894 
13895 instruct mtvsrwz(vecX temp1, iRegIsrc src) %{
13896   effect(DEF temp1, USE src);
13897 
13898   format %{ &quot;MTVSRWZ $temp1, $src \t// Move to 16-byte register&quot; %}
13899   size(4);
13900   ins_encode %{
13901     __ mtvsrwz($temp1$$VectorSRegister, $src$$Register);
13902   %}
13903   ins_pipe(pipe_class_default);
13904 %}
13905 
13906 instruct xxspltw(vecX dst, vecX src, immI8 imm1) %{
13907   effect(DEF dst, USE src, USE imm1);
13908 
13909   format %{ &quot;XXSPLTW $dst, $src, $imm1 \t// Splat word&quot; %}
13910   size(4);
13911   ins_encode %{
13912     __ xxspltw($dst$$VectorSRegister, $src$$VectorSRegister, $imm1$$constant);
13913   %}
13914   ins_pipe(pipe_class_default);
13915 %}
13916 
13917 instruct xscvdpspn_regF(vecX dst, regF src) %{
13918   effect(DEF dst, USE src);
13919 
13920   format %{ &quot;XSCVDPSPN $dst, $src \t// Convert scalar single precision to vector single precision&quot; %}
13921   size(4);
13922   ins_encode %{
13923     __ xscvdpspn($dst$$VectorSRegister, $src$$FloatRegister-&gt;to_vsr());
13924   %}
13925   ins_pipe(pipe_class_default);
13926 %}
13927 
13928 //---------- Replicate Vector Instructions ------------------------------------
13929 
13930 // Insrdi does replicate if src == dst.
13931 instruct repl32(iRegLdst dst) %{
13932   predicate(false);
13933   effect(USE_DEF dst);
13934 
13935   format %{ &quot;INSRDI  $dst, #0, $dst, #32 \t// replicate&quot; %}
13936   size(4);
13937   ins_encode %{
13938     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
13939     __ insrdi($dst$$Register, $dst$$Register, 32, 0);
13940   %}
13941   ins_pipe(pipe_class_default);
13942 %}
13943 
13944 // Insrdi does replicate if src == dst.
13945 instruct repl48(iRegLdst dst) %{
13946   predicate(false);
13947   effect(USE_DEF dst);
13948 
13949   format %{ &quot;INSRDI  $dst, #0, $dst, #48 \t// replicate&quot; %}
13950   size(4);
13951   ins_encode %{
13952     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
13953     __ insrdi($dst$$Register, $dst$$Register, 48, 0);
13954   %}
13955   ins_pipe(pipe_class_default);
13956 %}
13957 
13958 // Insrdi does replicate if src == dst.
13959 instruct repl56(iRegLdst dst) %{
13960   predicate(false);
13961   effect(USE_DEF dst);
13962 
13963   format %{ &quot;INSRDI  $dst, #0, $dst, #56 \t// replicate&quot; %}
13964   size(4);
13965   ins_encode %{
13966     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
13967     __ insrdi($dst$$Register, $dst$$Register, 56, 0);
13968   %}
13969   ins_pipe(pipe_class_default);
13970 %}
13971 
13972 instruct repl8B_reg_Ex(iRegLdst dst, iRegIsrc src) %{
13973   match(Set dst (ReplicateB src));
13974   predicate(n-&gt;as_Vector()-&gt;length() == 8);
13975   expand %{
13976     moveReg(dst, src);
13977     repl56(dst);
13978     repl48(dst);
13979     repl32(dst);
13980   %}
13981 %}
13982 
13983 instruct repl8B_immI0(iRegLdst dst, immI_0 zero) %{
13984   match(Set dst (ReplicateB zero));
13985   predicate(n-&gt;as_Vector()-&gt;length() == 8);
13986   format %{ &quot;LI      $dst, #0 \t// replicate8B&quot; %}
13987   size(4);
13988   ins_encode %{
13989     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
13990     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
13991   %}
13992   ins_pipe(pipe_class_default);
13993 %}
13994 
13995 instruct repl8B_immIminus1(iRegLdst dst, immI_minus1 src) %{
13996   match(Set dst (ReplicateB src));
13997   predicate(n-&gt;as_Vector()-&gt;length() == 8);
13998   format %{ &quot;LI      $dst, #-1 \t// replicate8B&quot; %}
13999   size(4);
14000   ins_encode %{
14001     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14002     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
14003   %}
14004   ins_pipe(pipe_class_default);
14005 %}
14006 
14007 instruct repl16B_reg_Ex(vecX dst, iRegIsrc src) %{
14008   match(Set dst (ReplicateB src));
14009   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14010 
14011   expand %{
14012     iRegLdst tmpL;
14013     vecX tmpV;
14014     immI8  imm1 %{ (int)  1 %}
14015     moveReg(tmpL, src);
14016     repl56(tmpL);
14017     repl48(tmpL);
14018     mtvsrwz(tmpV, tmpL);
14019     xxspltw(dst, tmpV, imm1);
14020   %}
14021 %}
14022 
14023 instruct repl16B_immI0(vecX dst, immI_0 zero) %{
14024   match(Set dst (ReplicateB zero));
14025   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14026 
14027   format %{ &quot;XXLXOR      $dst, $zero \t// replicate16B&quot; %}
14028   size(4);
14029   ins_encode %{
14030     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14031   %}
14032   ins_pipe(pipe_class_default);
14033 %}
14034 
14035 instruct repl16B_immIminus1(vecX dst, immI_minus1 src) %{
14036   match(Set dst (ReplicateB src));
14037   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14038 
14039   format %{ &quot;XXLEQV      $dst, $src \t// replicate16B&quot; %}
14040   size(4);
14041   ins_encode %{
14042     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14043   %}
14044   ins_pipe(pipe_class_default);
14045 %}
14046 
14047 instruct repl4S_reg_Ex(iRegLdst dst, iRegIsrc src) %{
14048   match(Set dst (ReplicateS src));
14049   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14050   expand %{
14051     moveReg(dst, src);
14052     repl48(dst);
14053     repl32(dst);
14054   %}
14055 %}
14056 
14057 instruct repl4S_immI0(iRegLdst dst, immI_0 zero) %{
14058   match(Set dst (ReplicateS zero));
14059   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14060   format %{ &quot;LI      $dst, #0 \t// replicate4S&quot; %}
14061   size(4);
14062   ins_encode %{
14063     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14064     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
14065   %}
14066   ins_pipe(pipe_class_default);
14067 %}
14068 
14069 instruct repl4S_immIminus1(iRegLdst dst, immI_minus1 src) %{
14070   match(Set dst (ReplicateS src));
14071   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14072   format %{ &quot;LI      $dst, -1 \t// replicate4S&quot; %}
14073   size(4);
14074   ins_encode %{
14075     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14076     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
14077   %}
14078   ins_pipe(pipe_class_default);
14079 %}
14080 
14081 instruct repl8S_reg_Ex(vecX dst, iRegIsrc src) %{
14082   match(Set dst (ReplicateS src));
14083   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14084 
14085   expand %{
14086     iRegLdst tmpL;
14087     vecX tmpV;
14088     immI8  zero %{ (int)  0 %}
14089     moveReg(tmpL, src);
14090     repl48(tmpL);
14091     repl32(tmpL);
14092     mtvsrd(tmpV, tmpL);
14093     xxpermdi(dst, tmpV, tmpV, zero);
14094   %}
14095 %}
14096 
14097 instruct repl8S_immI0(vecX dst, immI_0 zero) %{
14098   match(Set dst (ReplicateS zero));
14099   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14100 
14101   format %{ &quot;XXLXOR      $dst, $zero \t// replicate8S&quot; %}
14102   size(4);
14103   ins_encode %{
14104     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14105   %}
14106   ins_pipe(pipe_class_default);
14107 %}
14108 
14109 instruct repl8S_immIminus1(vecX dst, immI_minus1 src) %{
14110   match(Set dst (ReplicateS src));
14111   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14112 
14113   format %{ &quot;XXLEQV      $dst, $src \t// replicate8S&quot; %}
14114   size(4);
14115   ins_encode %{
14116     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14117   %}
14118   ins_pipe(pipe_class_default);
14119 %}
14120 
14121 instruct repl2I_reg_Ex(iRegLdst dst, iRegIsrc src) %{
14122   match(Set dst (ReplicateI src));
14123   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14124   ins_cost(2 * DEFAULT_COST);
14125   expand %{
14126     moveReg(dst, src);
14127     repl32(dst);
14128   %}
14129 %}
14130 
14131 instruct repl2I_immI0(iRegLdst dst, immI_0 zero) %{
14132   match(Set dst (ReplicateI zero));
14133   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14134   format %{ &quot;LI      $dst, #0 \t// replicate2I&quot; %}
14135   size(4);
14136   ins_encode %{
14137     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14138     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
14139   %}
14140   ins_pipe(pipe_class_default);
14141 %}
14142 
14143 instruct repl2I_immIminus1(iRegLdst dst, immI_minus1 src) %{
14144   match(Set dst (ReplicateI src));
14145   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14146   format %{ &quot;LI      $dst, -1 \t// replicate2I&quot; %}
14147   size(4);
14148   ins_encode %{
14149     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14150     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
14151   %}
14152   ins_pipe(pipe_class_default);
14153 %}
14154 
14155 instruct repl4I_reg_Ex(vecX dst, iRegIsrc src) %{
14156   match(Set dst (ReplicateI src));
14157   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14158   ins_cost(2 * DEFAULT_COST);
14159 
14160   expand %{
14161     iRegLdst tmpL;
14162     vecX tmpV;
14163     immI8  zero %{ (int)  0 %}
14164     moveReg(tmpL, src);
14165     repl32(tmpL);
14166     mtvsrd(tmpV, tmpL);
14167     xxpermdi(dst, tmpV, tmpV, zero);
14168   %}
14169 %}
14170 
14171 instruct repl4I_immI0(vecX dst, immI_0 zero) %{
14172   match(Set dst (ReplicateI zero));
14173   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14174 
14175   format %{ &quot;XXLXOR      $dst, $zero \t// replicate4I&quot; %}
14176   size(4);
14177   ins_encode %{
14178     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14179   %}
14180   ins_pipe(pipe_class_default);
14181 %}
14182 
14183 instruct repl4I_immIminus1(vecX dst, immI_minus1 src) %{
14184   match(Set dst (ReplicateI src));
14185   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14186 
14187   format %{ &quot;XXLEQV      $dst, $dst, $dst \t// replicate4I&quot; %}
14188   size(4);
14189   ins_encode %{
14190     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14191   %}
14192   ins_pipe(pipe_class_default);
14193 %}
14194 
14195 // Move float to int register via stack, replicate.
14196 instruct repl2F_reg_Ex(iRegLdst dst, regF src) %{
14197   match(Set dst (ReplicateF src));
14198   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14199   ins_cost(2 * MEMORY_REF_COST + DEFAULT_COST);
14200   expand %{
14201     stackSlotL tmpS;
14202     iRegIdst tmpI;
14203     moveF2I_reg_stack(tmpS, src);   // Move float to stack.
14204     moveF2I_stack_reg(tmpI, tmpS);  // Move stack to int reg.
14205     moveReg(dst, tmpI);             // Move int to long reg.
14206     repl32(dst);                    // Replicate bitpattern.
14207   %}
14208 %}
14209 
14210 // Replicate scalar constant to packed float values in Double register
14211 instruct repl2F_immF_Ex(iRegLdst dst, immF src) %{
14212   match(Set dst (ReplicateF src));
14213   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14214   ins_cost(5 * DEFAULT_COST);
14215 
14216   format %{ &quot;LD      $dst, offset, $constanttablebase\t// load replicated float $src $src from table, postalloc expanded&quot; %}
14217   postalloc_expand( postalloc_expand_load_replF_constant(dst, src, constanttablebase) );
14218 %}
14219 
14220 // Replicate scalar zero constant to packed float values in Double register
14221 instruct repl2F_immF0(iRegLdst dst, immF_0 zero) %{
14222   match(Set dst (ReplicateF zero));
14223   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14224 
14225   format %{ &quot;LI      $dst, #0 \t// replicate2F&quot; %}
14226   ins_encode %{
14227     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14228     __ li($dst$$Register, 0x0);
14229   %}
14230   ins_pipe(pipe_class_default);
14231 %}
14232 
14233 
14234 //----------Vector Arithmetic Instructions--------------------------------------
14235 
14236 // Vector Addition Instructions
14237 
14238 instruct vadd16B_reg(vecX dst, vecX src1, vecX src2) %{
14239   match(Set dst (AddVB src1 src2));
14240   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14241   format %{ &quot;VADDUBM  $dst,$src1,$src2\t// add packed16B&quot; %}
14242   size(4);
14243   ins_encode %{
14244     __ vaddubm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14245   %}
14246   ins_pipe(pipe_class_default);
14247 %}
14248 
14249 instruct vadd8S_reg(vecX dst, vecX src1, vecX src2) %{
14250   match(Set dst (AddVS src1 src2));
14251   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14252   format %{ &quot;VADDUHM  $dst,$src1,$src2\t// add packed8S&quot; %}
14253   size(4);
14254   ins_encode %{
14255     __ vadduhm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14256   %}
14257   ins_pipe(pipe_class_default);
14258 %}
14259 
14260 instruct vadd4I_reg(vecX dst, vecX src1, vecX src2) %{
14261   match(Set dst (AddVI src1 src2));
14262   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14263   format %{ &quot;VADDUWM  $dst,$src1,$src2\t// add packed4I&quot; %}
14264   size(4);
14265   ins_encode %{
14266     __ vadduwm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14267   %}
14268   ins_pipe(pipe_class_default);
14269 %}
14270 
14271 instruct vadd4F_reg(vecX dst, vecX src1, vecX src2) %{
14272   match(Set dst (AddVF src1 src2));
14273   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14274   format %{ &quot;VADDFP  $dst,$src1,$src2\t// add packed4F&quot; %}
14275   size(4);
14276   ins_encode %{
14277     __ vaddfp($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14278   %}
14279   ins_pipe(pipe_class_default);
14280 %}
14281 
14282 instruct vadd2L_reg(vecX dst, vecX src1, vecX src2) %{
14283   match(Set dst (AddVL src1 src2));
14284   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14285   format %{ &quot;VADDUDM  $dst,$src1,$src2\t// add packed2L&quot; %}
14286   size(4);
14287   ins_encode %{
14288     __ vaddudm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14289   %}
14290   ins_pipe(pipe_class_default);
14291 %}
14292 
14293 instruct vadd2D_reg(vecX dst, vecX src1, vecX src2) %{
14294   match(Set dst (AddVD src1 src2));
14295   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14296   format %{ &quot;XVADDDP  $dst,$src1,$src2\t// add packed2D&quot; %}
14297   size(4);
14298   ins_encode %{
14299     __ xvadddp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14300   %}
14301   ins_pipe(pipe_class_default);
14302 %}
14303 
14304 // Vector Subtraction Instructions
14305 
14306 instruct vsub16B_reg(vecX dst, vecX src1, vecX src2) %{
14307   match(Set dst (SubVB src1 src2));
14308   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14309   format %{ &quot;VSUBUBM  $dst,$src1,$src2\t// sub packed16B&quot; %}
14310   size(4);
14311   ins_encode %{
14312     __ vsububm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14313   %}
14314   ins_pipe(pipe_class_default);
14315 %}
14316 
14317 instruct vsub8S_reg(vecX dst, vecX src1, vecX src2) %{
14318   match(Set dst (SubVS src1 src2));
14319   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14320   format %{ &quot;VSUBUHM  $dst,$src1,$src2\t// sub packed8S&quot; %}
14321   size(4);
14322   ins_encode %{
14323     __ vsubuhm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14324   %}
14325   ins_pipe(pipe_class_default);
14326 %}
14327 
14328 instruct vsub4I_reg(vecX dst, vecX src1, vecX src2) %{
14329   match(Set dst (SubVI src1 src2));
14330   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14331   format %{ &quot;VSUBUWM  $dst,$src1,$src2\t// sub packed4I&quot; %}
14332   size(4);
14333   ins_encode %{
14334     __ vsubuwm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14335   %}
14336   ins_pipe(pipe_class_default);
14337 %}
14338 
14339 instruct vsub4F_reg(vecX dst, vecX src1, vecX src2) %{
14340   match(Set dst (SubVF src1 src2));
14341   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14342   format %{ &quot;VSUBFP  $dst,$src1,$src2\t// sub packed4F&quot; %}
14343   size(4);
14344   ins_encode %{
14345     __ vsubfp($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14346   %}
14347   ins_pipe(pipe_class_default);
14348 %}
14349 
14350 instruct vsub2L_reg(vecX dst, vecX src1, vecX src2) %{
14351   match(Set dst (SubVL src1 src2));
14352   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14353   format %{ &quot;VSUBUDM  $dst,$src1,$src2\t// sub packed2L&quot; %}
14354   size(4);
14355   ins_encode %{
14356     __ vsubudm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14357   %}
14358   ins_pipe(pipe_class_default);
14359 %}
14360 
14361 instruct vsub2D_reg(vecX dst, vecX src1, vecX src2) %{
14362   match(Set dst (SubVD src1 src2));
14363   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14364   format %{ &quot;XVSUBDP  $dst,$src1,$src2\t// sub packed2D&quot; %}
14365   size(4);
14366   ins_encode %{
14367     __ xvsubdp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14368   %}
14369   ins_pipe(pipe_class_default);
14370 %}
14371 
14372 // Vector Multiplication Instructions
14373 
14374 instruct vmul8S_reg(vecX dst, vecX src1, vecX src2, vecX tmp) %{
14375   match(Set dst (MulVS src1 src2));
14376   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14377   effect(TEMP tmp);
14378   format %{ &quot;VSPLTISH  $tmp,0\t// mul packed8S&quot; %}
14379   format %{ &quot;VMLADDUHM  $dst,$src1,$src2\t// mul packed8S&quot; %}
14380   size(8);
14381   ins_encode %{
14382     __ vspltish($tmp$$VectorSRegister-&gt;to_vr(), 0);
14383     __ vmladduhm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr(), $tmp$$VectorSRegister-&gt;to_vr());
14384   %}
14385   ins_pipe(pipe_class_default);
14386 %}
14387 
14388 instruct vmul4I_reg(vecX dst, vecX src1, vecX src2) %{
14389   match(Set dst (MulVI src1 src2));
14390   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14391   format %{ &quot;VMULUWM  $dst,$src1,$src2\t// mul packed4I&quot; %}
14392   size(4);
14393   ins_encode %{
14394     __ vmuluwm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14395   %}
14396   ins_pipe(pipe_class_default);
14397 %}
14398 
14399 instruct vmul4F_reg(vecX dst, vecX src1, vecX src2) %{
14400   match(Set dst (MulVF src1 src2));
14401   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14402   format %{ &quot;XVMULSP  $dst,$src1,$src2\t// mul packed4F&quot; %}
14403   size(4);
14404   ins_encode %{
14405     __ xvmulsp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14406   %}
14407   ins_pipe(pipe_class_default);
14408 %}
14409 
14410 instruct vmul2D_reg(vecX dst, vecX src1, vecX src2) %{
14411   match(Set dst (MulVD src1 src2));
14412   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14413   format %{ &quot;XVMULDP  $dst,$src1,$src2\t// mul packed2D&quot; %}
14414   size(4);
14415   ins_encode %{
14416     __ xvmuldp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14417   %}
14418   ins_pipe(pipe_class_default);
14419 %}
14420 
14421 // Vector Division Instructions
14422 
14423 instruct vdiv4F_reg(vecX dst, vecX src1, vecX src2) %{
14424   match(Set dst (DivVF src1 src2));
14425   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14426   format %{ &quot;XVDIVSP  $dst,$src1,$src2\t// div packed4F&quot; %}
14427   size(4);
14428   ins_encode %{
14429     __ xvdivsp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14430   %}
14431   ins_pipe(pipe_class_default);
14432 %}
14433 
14434 instruct vdiv2D_reg(vecX dst, vecX src1, vecX src2) %{
14435   match(Set dst (DivVD src1 src2));
14436   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14437   format %{ &quot;XVDIVDP  $dst,$src1,$src2\t// div packed2D&quot; %}
14438   size(4);
14439   ins_encode %{
14440     __ xvdivdp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14441   %}
14442   ins_pipe(pipe_class_default);
14443 %}
14444 
14445 // Vector Absolute Instructions
14446 
14447 instruct vabs4F_reg(vecX dst, vecX src) %{
14448   match(Set dst (AbsVF src));
14449   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14450   format %{ &quot;XVABSSP $dst,$src\t// absolute packed4F&quot; %}
14451   size(4);
14452   ins_encode %{
14453     __ xvabssp($dst$$VectorSRegister, $src$$VectorSRegister);
14454   %}
14455   ins_pipe(pipe_class_default);
14456 %}
14457 
14458 instruct vabs2D_reg(vecX dst, vecX src) %{
14459   match(Set dst (AbsVD src));
14460   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14461   format %{ &quot;XVABSDP $dst,$src\t// absolute packed2D&quot; %}
14462   size(4);
14463   ins_encode %{
14464     __ xvabsdp($dst$$VectorSRegister, $src$$VectorSRegister);
14465   %}
14466   ins_pipe(pipe_class_default);
14467 %}
14468 
14469 // Round Instructions
14470 instruct roundD_reg(regD dst, regD src, immI8 rmode) %{
14471   match(Set dst (RoundDoubleMode src rmode));
14472   format %{ &quot;RoundDoubleMode $src,$rmode&quot; %}
14473   size(4);
14474   ins_encode %{
14475     switch ($rmode$$constant) {
14476       case RoundDoubleModeNode::rmode_rint:
14477         __ frin($dst$$FloatRegister, $src$$FloatRegister);
14478         break;
14479       case RoundDoubleModeNode::rmode_floor:
14480         __ frim($dst$$FloatRegister, $src$$FloatRegister);
14481         break;
14482       case RoundDoubleModeNode::rmode_ceil:
14483         __ frip($dst$$FloatRegister, $src$$FloatRegister);
14484         break;
14485       default:
14486         ShouldNotReachHere();
14487     }
14488   %}
14489   ins_pipe(pipe_class_default);
14490 %}
14491 
14492 // Vector Round Instructions
14493 instruct vround2D_reg(vecX dst, vecX src, immI8 rmode) %{
14494   match(Set dst (RoundDoubleModeV src rmode));
14495   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14496   format %{ &quot;RoundDoubleModeV $src,$rmode&quot; %}
14497   size(4);
14498   ins_encode %{
14499     switch ($rmode$$constant) {
14500       case RoundDoubleModeNode::rmode_rint:
14501         __ xvrdpi($dst$$VectorSRegister, $src$$VectorSRegister);
14502         break;
14503       case RoundDoubleModeNode::rmode_floor:
14504         __ xvrdpim($dst$$VectorSRegister, $src$$VectorSRegister);
14505         break;
14506       case RoundDoubleModeNode::rmode_ceil:
14507         __ xvrdpip($dst$$VectorSRegister, $src$$VectorSRegister);
14508         break;
14509       default:
14510         ShouldNotReachHere();
14511     }
14512   %}
14513   ins_pipe(pipe_class_default);
14514 %}
14515 
14516 // Vector Negate Instructions
14517 
14518 instruct vneg4F_reg(vecX dst, vecX src) %{
14519   match(Set dst (NegVF src));
14520   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14521   format %{ &quot;XVNEGSP $dst,$src\t// negate packed4F&quot; %}
14522   size(4);
14523   ins_encode %{
14524     __ xvnegsp($dst$$VectorSRegister, $src$$VectorSRegister);
14525   %}
14526   ins_pipe(pipe_class_default);
14527 %}
14528 
14529 instruct vneg2D_reg(vecX dst, vecX src) %{
14530   match(Set dst (NegVD src));
14531   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14532   format %{ &quot;XVNEGDP $dst,$src\t// negate packed2D&quot; %}
14533   size(4);
14534   ins_encode %{
14535     __ xvnegdp($dst$$VectorSRegister, $src$$VectorSRegister);
14536   %}
14537   ins_pipe(pipe_class_default);
14538 %}
14539 
14540 // Vector Square Root Instructions
14541 
14542 instruct vsqrt4F_reg(vecX dst, vecX src) %{
14543   match(Set dst (SqrtVF src));
14544   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14545   format %{ &quot;XVSQRTSP $dst,$src\t// sqrt packed4F&quot; %}
14546   size(4);
14547   ins_encode %{
14548     __ xvsqrtsp($dst$$VectorSRegister, $src$$VectorSRegister);
14549   %}
14550   ins_pipe(pipe_class_default);
14551 %}
14552 
14553 instruct vsqrt2D_reg(vecX dst, vecX src) %{
14554   match(Set dst (SqrtVD src));
14555   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14556   format %{ &quot;XVSQRTDP  $dst,$src\t// sqrt packed2D&quot; %}
14557   size(4);
14558   ins_encode %{
14559     __ xvsqrtdp($dst$$VectorSRegister, $src$$VectorSRegister);
14560   %}
14561   ins_pipe(pipe_class_default);
14562 %}
14563 
14564 // Vector Population Count Instructions
14565 
14566 instruct vpopcnt4I_reg(vecX dst, vecX src) %{
14567   match(Set dst (PopCountVI src));
14568   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14569   format %{ &quot;VPOPCNTW $dst,$src\t// pop count packed4I&quot; %}
14570   size(4);
14571   ins_encode %{
14572     __ vpopcntw($dst$$VectorSRegister-&gt;to_vr(), $src$$VectorSRegister-&gt;to_vr());
14573   %}
14574   ins_pipe(pipe_class_default);
14575 %}
14576 
14577 // --------------------------------- FMA --------------------------------------
14578 // dst + src1 * src2
14579 instruct vfma4F(vecX dst, vecX src1, vecX src2) %{
14580   match(Set dst (FmaVF dst (Binary src1 src2)));
14581   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14582 
14583   format %{ &quot;XVMADDASP   $dst, $src1, $src2&quot; %}
14584 
14585   size(4);
14586   ins_encode %{
14587     __ xvmaddasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14588   %}
14589   ins_pipe(pipe_class_default);
14590 %}
14591 
14592 // dst - src1 * src2
14593 instruct vfma4F_neg1(vecX dst, vecX src1, vecX src2) %{
14594   match(Set dst (FmaVF dst (Binary (NegVF src1) src2)));
14595   match(Set dst (FmaVF dst (Binary src1 (NegVF src2))));
14596   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14597 
14598   format %{ &quot;XVNMSUBASP   $dst, $src1, $src2&quot; %}
14599 
14600   size(4);
14601   ins_encode %{
14602     __ xvnmsubasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14603   %}
14604   ins_pipe(pipe_class_default);
14605 %}
14606 
14607 // - dst + src1 * src2
14608 instruct vfma4F_neg2(vecX dst, vecX src1, vecX src2) %{
14609   match(Set dst (FmaVF (NegVF dst) (Binary src1 src2)));
14610   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14611 
14612   format %{ &quot;XVMSUBASP   $dst, $src1, $src2&quot; %}
14613 
14614   size(4);
14615   ins_encode %{
14616     __ xvmsubasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14617   %}
14618   ins_pipe(pipe_class_default);
14619 %}
14620 
14621 // dst + src1 * src2
14622 instruct vfma2D(vecX dst, vecX src1, vecX src2) %{
14623   match(Set dst (FmaVD  dst (Binary src1 src2)));
14624   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14625 
14626   format %{ &quot;XVMADDADP   $dst, $src1, $src2&quot; %}
14627 
14628   size(4);
14629   ins_encode %{
14630     __ xvmaddadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14631   %}
14632   ins_pipe(pipe_class_default);
14633 %}
14634 
14635 // dst - src1 * src2
14636 instruct vfma2D_neg1(vecX dst, vecX src1, vecX src2) %{
14637   match(Set dst (FmaVD  dst (Binary (NegVD src1) src2)));
14638   match(Set dst (FmaVD  dst (Binary src1 (NegVD src2))));
14639   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14640 
14641   format %{ &quot;XVNMSUBADP   $dst, $src1, $src2&quot; %}
14642 
14643   size(4);
14644   ins_encode %{
14645     __ xvnmsubadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14646   %}
14647   ins_pipe(pipe_class_default);
14648 %}
14649 
14650 // - dst + src1 * src2
14651 instruct vfma2D_neg2(vecX dst, vecX src1, vecX src2) %{
14652   match(Set dst (FmaVD (NegVD dst) (Binary src1 src2)));
14653   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14654 
14655   format %{ &quot;XVMSUBADP   $dst, $src1, $src2&quot; %}
14656 
14657   size(4);
14658   ins_encode %{
14659     __ xvmsubadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14660   %}
14661   ins_pipe(pipe_class_default);
14662 %}
14663 
14664 //----------Overflow Math Instructions-----------------------------------------
14665 
14666 // Note that we have to make sure that XER.SO is reset before using overflow instructions.
14667 // Simple Overflow operations can be matched by very few instructions (e.g. addExact: xor, and_, bc).
14668 // Seems like only Long intrinsincs have an advantage. (The only expensive one is OverflowMulL.)
14669 
14670 instruct overflowAddL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
14671   match(Set cr0 (OverflowAddL op1 op2));
14672 
14673   format %{ &quot;add_    $op1, $op2\t# overflow check long&quot; %}
14674   ins_encode %{
14675     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14676     __ li(R0, 0);
14677     __ mtxer(R0); // clear XER.SO
14678     __ addo_(R0, $op1$$Register, $op2$$Register);
14679   %}
14680   ins_pipe(pipe_class_default);
14681 %}
14682 
14683 instruct overflowSubL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
14684   match(Set cr0 (OverflowSubL op1 op2));
14685 
14686   format %{ &quot;subfo_  R0, $op2, $op1\t# overflow check long&quot; %}
14687   ins_encode %{
14688     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14689     __ li(R0, 0);
14690     __ mtxer(R0); // clear XER.SO
14691     __ subfo_(R0, $op2$$Register, $op1$$Register);
14692   %}
14693   ins_pipe(pipe_class_default);
14694 %}
14695 
14696 instruct overflowNegL_reg(flagsRegCR0 cr0, immL_0 zero, iRegLsrc op2) %{
14697   match(Set cr0 (OverflowSubL zero op2));
14698 
14699   format %{ &quot;nego_   R0, $op2\t# overflow check long&quot; %}
14700   ins_encode %{
14701     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14702     __ li(R0, 0);
14703     __ mtxer(R0); // clear XER.SO
14704     __ nego_(R0, $op2$$Register);
14705   %}
14706   ins_pipe(pipe_class_default);
14707 %}
14708 
14709 instruct overflowMulL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
14710   match(Set cr0 (OverflowMulL op1 op2));
14711 
14712   format %{ &quot;mulldo_ R0, $op1, $op2\t# overflow check long&quot; %}
14713   ins_encode %{
14714     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14715     __ li(R0, 0);
14716     __ mtxer(R0); // clear XER.SO
14717     __ mulldo_(R0, $op1$$Register, $op2$$Register);
14718   %}
14719   ins_pipe(pipe_class_default);
14720 %}
14721 
14722 instruct repl4F_reg_Ex(vecX dst, regF src) %{
14723   match(Set dst (ReplicateF src));
14724   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14725   ins_cost(DEFAULT_COST);
14726   expand %{
14727     vecX tmpV;
14728     immI8  zero %{ (int)  0 %}
14729 
14730     xscvdpspn_regF(tmpV, src);
14731     xxspltw(dst, tmpV, zero);
14732   %}
14733 %}
14734 
14735 instruct repl4F_immF_Ex(vecX dst, immF src, iRegLdst tmp) %{
14736   match(Set dst (ReplicateF src));
14737   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14738   effect(TEMP tmp);
14739   ins_cost(10 * DEFAULT_COST);
14740 
14741   postalloc_expand( postalloc_expand_load_replF_constant_vsx(dst, src, constanttablebase, tmp) );
14742 %}
14743 
14744 instruct repl4F_immF0(vecX dst, immF_0 zero) %{
14745   match(Set dst (ReplicateF zero));
14746   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14747 
14748   format %{ &quot;XXLXOR      $dst, $zero \t// replicate4F&quot; %}
14749   ins_encode %{
14750     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14751   %}
14752   ins_pipe(pipe_class_default);
14753 %}
14754 
14755 instruct repl2D_reg_Ex(vecX dst, regD src) %{
14756   match(Set dst (ReplicateD src));
14757   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14758 
14759   format %{ &quot;XXPERMDI      $dst, $src, $src, 0 \t// Splat doubleword&quot; %}
14760   size(4);
14761   ins_encode %{
14762     __ xxpermdi($dst$$VectorSRegister, $src$$FloatRegister-&gt;to_vsr(), $src$$FloatRegister-&gt;to_vsr(), 0);
14763   %}
14764   ins_pipe(pipe_class_default);
14765 %}
14766 
14767 instruct repl2D_immD0(vecX dst, immD_0 zero) %{
14768   match(Set dst (ReplicateD zero));
14769   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14770 
14771   format %{ &quot;XXLXOR      $dst, $zero \t// replicate2D&quot; %}
14772   size(4);
14773   ins_encode %{
14774     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14775   %}
14776   ins_pipe(pipe_class_default);
14777 %}
14778 
14779 instruct mtvsrd(vecX dst, iRegLsrc src) %{
14780   predicate(false);
14781   effect(DEF dst, USE src);
14782 
14783   format %{ &quot;MTVSRD      $dst, $src \t// Move to 16-byte register&quot; %}
14784   size(4);
14785   ins_encode %{
14786     __ mtvsrd($dst$$VectorSRegister, $src$$Register);
14787   %}
14788   ins_pipe(pipe_class_default);
14789 %}
14790 
14791 instruct xxspltd(vecX dst, vecX src, immI8 zero) %{
14792   effect(DEF dst, USE src, USE zero);
14793 
14794   format %{ &quot;XXSPLATD      $dst, $src, $zero \t// Splat doubleword&quot; %}
14795   size(4);
14796   ins_encode %{
14797     __ xxpermdi($dst$$VectorSRegister, $src$$VectorSRegister, $src$$VectorSRegister, $zero$$constant);
14798   %}
14799   ins_pipe(pipe_class_default);
14800 %}
14801 
14802 instruct xxpermdi(vecX dst, vecX src1, vecX src2, immI8 zero) %{
14803   effect(DEF dst, USE src1, USE src2, USE zero);
14804 
14805   format %{ &quot;XXPERMDI      $dst, $src1, $src2, $zero \t// Splat doubleword&quot; %}
14806   size(4);
14807   ins_encode %{
14808     __ xxpermdi($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister, $zero$$constant);
14809   %}
14810   ins_pipe(pipe_class_default);
14811 %}
14812 
14813 instruct repl2L_reg_Ex(vecX dst, iRegLsrc src) %{
14814   match(Set dst (ReplicateL src));
14815   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14816   expand %{
14817     vecX tmpV;
14818     immI8  zero %{ (int)  0 %}
14819     mtvsrd(tmpV, src);
14820     xxpermdi(dst, tmpV, tmpV, zero);
14821   %}
14822 %}
14823 
14824 instruct repl2L_immI0(vecX dst, immI_0 zero) %{
14825   match(Set dst (ReplicateL zero));
14826   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14827 
14828   format %{ &quot;XXLXOR      $dst, $zero \t// replicate2L&quot; %}
14829   size(4);
14830   ins_encode %{
14831     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14832   %}
14833   ins_pipe(pipe_class_default);
14834 %}
14835 
14836 instruct repl2L_immIminus1(vecX dst, immI_minus1 src) %{
14837   match(Set dst (ReplicateL src));
14838   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14839 
14840   format %{ &quot;XXLEQV      $dst, $src \t// replicate2L&quot; %}
14841   size(4);
14842   ins_encode %{
14843     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14844   %}
14845   ins_pipe(pipe_class_default);
14846 %}
14847 
14848 // ============================================================================
14849 // Safepoint Instruction
14850 
14851 instruct safePoint_poll(iRegPdst poll) %{
14852   match(SafePoint poll);
14853 
14854   // It caused problems to add the effect that r0 is killed, but this
14855   // effect no longer needs to be mentioned, since r0 is not contained
14856   // in a reg_class.
14857 
14858   format %{ &quot;LD      R0, #0, $poll \t// Safepoint poll for GC&quot; %}
14859   size(4);
14860   ins_encode( enc_poll(0x0, poll) );
14861   ins_pipe(pipe_class_default);
14862 %}
14863 
14864 // ============================================================================
14865 // Call Instructions
14866 
14867 // Call Java Static Instruction
14868 
14869 // Schedulable version of call static node.
14870 instruct CallStaticJavaDirect(method meth) %{
14871   match(CallStaticJava);
14872   effect(USE meth);
14873   ins_cost(CALL_COST);
14874 
14875   ins_num_consts(3 /* up to 3 patchable constants: inline cache, 2 call targets. */);
14876 
14877   format %{ &quot;CALL,static $meth \t// ==&gt; &quot; %}
14878   size(4);
14879   ins_encode( enc_java_static_call(meth) );
14880   ins_pipe(pipe_class_call);
14881 %}
14882 
14883 // Call Java Dynamic Instruction
14884 
14885 // Used by postalloc expand of CallDynamicJavaDirectSchedEx (actual call).
14886 // Loading of IC was postalloc expanded. The nodes loading the IC are reachable
14887 // via fields ins_field_load_ic_hi_node and ins_field_load_ic_node.
14888 // The call destination must still be placed in the constant pool.
14889 instruct CallDynamicJavaDirectSched(method meth) %{
14890   match(CallDynamicJava); // To get all the data fields we need ...
14891   effect(USE meth);
14892   predicate(false);       // ... but never match.
14893 
14894   ins_field_load_ic_hi_node(loadConL_hiNode*);
14895   ins_field_load_ic_node(loadConLNode*);
14896   ins_num_consts(1 /* 1 patchable constant: call destination */);
14897 
14898   format %{ &quot;BL        \t// dynamic $meth ==&gt; &quot; %}
14899   size(4);
14900   ins_encode( enc_java_dynamic_call_sched(meth) );
14901   ins_pipe(pipe_class_call);
14902 %}
14903 
14904 // Schedulable (i.e. postalloc expanded) version of call dynamic java.
14905 // We use postalloc expanded calls if we use inline caches
14906 // and do not update method data.
14907 //
14908 // This instruction has two constants: inline cache (IC) and call destination.
14909 // Loading the inline cache will be postalloc expanded, thus leaving a call with
14910 // one constant.
14911 instruct CallDynamicJavaDirectSched_Ex(method meth) %{
14912   match(CallDynamicJava);
14913   effect(USE meth);
14914   predicate(UseInlineCaches);
14915   ins_cost(CALL_COST);
14916 
14917   ins_num_consts(2 /* 2 patchable constants: inline cache, call destination. */);
14918 
14919   format %{ &quot;CALL,dynamic $meth \t// postalloc expanded&quot; %}
14920   postalloc_expand( postalloc_expand_java_dynamic_call_sched(meth, constanttablebase) );
14921 %}
14922 
14923 // Compound version of call dynamic java
14924 // We use postalloc expanded calls if we use inline caches
14925 // and do not update method data.
14926 instruct CallDynamicJavaDirect(method meth) %{
14927   match(CallDynamicJava);
14928   effect(USE meth);
14929   predicate(!UseInlineCaches);
14930   ins_cost(CALL_COST);
14931 
14932   // Enc_java_to_runtime_call needs up to 4 constants (method data oop).
14933   ins_num_consts(4);
14934 
14935   format %{ &quot;CALL,dynamic $meth \t// ==&gt; &quot; %}
14936   ins_encode( enc_java_dynamic_call(meth, constanttablebase) );
14937   ins_pipe(pipe_class_call);
14938 %}
14939 
14940 // Call Runtime Instruction
14941 
14942 instruct CallRuntimeDirect(method meth) %{
14943   match(CallRuntime);
14944   effect(USE meth);
14945   ins_cost(CALL_COST);
14946 
14947   // Enc_java_to_runtime_call needs up to 3 constants: call target,
14948   // env for callee, C-toc.
14949   ins_num_consts(3);
14950 
14951   format %{ &quot;CALL,runtime&quot; %}
14952   ins_encode( enc_java_to_runtime_call(meth) );
14953   ins_pipe(pipe_class_call);
14954 %}
14955 
14956 // Call Leaf
14957 
14958 // Used by postalloc expand of CallLeafDirect_Ex (mtctr).
14959 instruct CallLeafDirect_mtctr(iRegLdst dst, iRegLsrc src) %{
14960   effect(DEF dst, USE src);
14961 
14962   ins_num_consts(1);
14963 
14964   format %{ &quot;MTCTR   $src&quot; %}
14965   size(4);
14966   ins_encode( enc_leaf_call_mtctr(src) );
14967   ins_pipe(pipe_class_default);
14968 %}
14969 
14970 // Used by postalloc expand of CallLeafDirect_Ex (actual call).
14971 instruct CallLeafDirect(method meth) %{
14972   match(CallLeaf);   // To get the data all the data fields we need ...
14973   effect(USE meth);
14974   predicate(false);  // but never match.
14975 
14976   format %{ &quot;BCTRL     \t// leaf call $meth ==&gt; &quot; %}
14977   size(4);
14978   ins_encode %{
14979     // TODO: PPC port $archOpcode(ppc64Opcode_bctrl);
14980     __ bctrl();
14981   %}
14982   ins_pipe(pipe_class_call);
14983 %}
14984 
14985 // postalloc expand of CallLeafDirect.
14986 // Load adress to call from TOC, then bl to it.
14987 instruct CallLeafDirect_Ex(method meth) %{
14988   match(CallLeaf);
14989   effect(USE meth);
14990   ins_cost(CALL_COST);
14991 
14992   // Postalloc_expand_java_to_runtime_call needs up to 3 constants: call target,
14993   // env for callee, C-toc.
14994   ins_num_consts(3);
14995 
14996   format %{ &quot;CALL,runtime leaf $meth \t// postalloc expanded&quot; %}
14997   postalloc_expand( postalloc_expand_java_to_runtime_call(meth, constanttablebase) );
14998 %}
14999 
15000 // Call runtime without safepoint - same as CallLeaf.
15001 // postalloc expand of CallLeafNoFPDirect.
15002 // Load adress to call from TOC, then bl to it.
15003 instruct CallLeafNoFPDirect_Ex(method meth) %{
15004   match(CallLeafNoFP);
15005   effect(USE meth);
15006   ins_cost(CALL_COST);
15007 
15008   // Enc_java_to_runtime_call needs up to 3 constants: call target,
15009   // env for callee, C-toc.
15010   ins_num_consts(3);
15011 
15012   format %{ &quot;CALL,runtime leaf nofp $meth \t// postalloc expanded&quot; %}
15013   postalloc_expand( postalloc_expand_java_to_runtime_call(meth, constanttablebase) );
15014 %}
15015 
15016 // Tail Call; Jump from runtime stub to Java code.
15017 // Also known as an &#39;interprocedural jump&#39;.
15018 // Target of jump will eventually return to caller.
15019 // TailJump below removes the return address.
15020 instruct TailCalljmpInd(iRegPdstNoScratch jump_target, inline_cache_regP method_oop) %{
15021   match(TailCall jump_target method_oop);
15022   ins_cost(CALL_COST);
15023 
15024   format %{ &quot;MTCTR   $jump_target \t// $method_oop holds method oop\n\t&quot;
15025             &quot;BCTR         \t// tail call&quot; %}
15026   size(8);
15027   ins_encode %{
15028     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
15029     __ mtctr($jump_target$$Register);
15030     __ bctr();
15031   %}
15032   ins_pipe(pipe_class_call);
15033 %}
15034 
15035 // Return Instruction
15036 instruct Ret() %{
15037   match(Return);
15038   format %{ &quot;BLR      \t// branch to link register&quot; %}
15039   size(4);
15040   ins_encode %{
15041     // TODO: PPC port $archOpcode(ppc64Opcode_blr);
15042     // LR is restored in MachEpilogNode. Just do the RET here.
15043     __ blr();
15044   %}
15045   ins_pipe(pipe_class_default);
15046 %}
15047 
15048 // Tail Jump; remove the return address; jump to target.
15049 // TailCall above leaves the return address around.
15050 // TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
15051 // ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
15052 // &quot;restore&quot; before this instruction (in Epilogue), we need to materialize it
15053 // in %i0.
15054 instruct tailjmpInd(iRegPdstNoScratch jump_target, rarg1RegP ex_oop) %{
15055   match(TailJump jump_target ex_oop);
15056   ins_cost(CALL_COST);
15057 
15058   format %{ &quot;LD      R4_ARG2 = LR\n\t&quot;
15059             &quot;MTCTR   $jump_target\n\t&quot;
15060             &quot;BCTR     \t// TailJump, exception oop: $ex_oop&quot; %}
15061   size(12);
15062   ins_encode %{
15063     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
15064     __ ld(R4_ARG2/* issuing pc */, _abi(lr), R1_SP);
15065     __ mtctr($jump_target$$Register);
15066     __ bctr();
15067   %}
15068   ins_pipe(pipe_class_call);
15069 %}
15070 
15071 // Create exception oop: created by stack-crawling runtime code.
15072 // Created exception is now available to this handler, and is setup
15073 // just prior to jumping to this handler. No code emitted.
15074 instruct CreateException(rarg1RegP ex_oop) %{
15075   match(Set ex_oop (CreateEx));
15076   ins_cost(0);
15077 
15078   format %{ &quot; -- \t// exception oop; no code emitted&quot; %}
15079   size(0);
15080   ins_encode( /*empty*/ );
15081   ins_pipe(pipe_class_default);
15082 %}
15083 
15084 // Rethrow exception: The exception oop will come in the first
15085 // argument position. Then JUMP (not call) to the rethrow stub code.
15086 instruct RethrowException() %{
15087   match(Rethrow);
15088   ins_cost(CALL_COST);
15089 
15090   format %{ &quot;Jmp     rethrow_stub&quot; %}
15091   ins_encode %{
15092     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
15093     cbuf.set_insts_mark();
15094     __ b64_patchable((address)OptoRuntime::rethrow_stub(), relocInfo::runtime_call_type);
15095   %}
15096   ins_pipe(pipe_class_call);
15097 %}
15098 
15099 // Die now.
15100 instruct ShouldNotReachHere() %{
15101   match(Halt);
15102   ins_cost(CALL_COST);
15103 
15104   format %{ &quot;ShouldNotReachHere&quot; %}
15105   size(4);
15106   ins_encode %{
15107     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
15108     __ trap_should_not_reach_here();
15109   %}
15110   ins_pipe(pipe_class_default);
15111 %}
15112 
15113 // This name is KNOWN by the ADLC and cannot be changed.  The ADLC
15114 // forces a &#39;TypeRawPtr::BOTTOM&#39; output type for this guy.
15115 // Get a DEF on threadRegP, no costs, no encoding, use
15116 // &#39;ins_should_rematerialize(true)&#39; to avoid spilling.
15117 instruct tlsLoadP(threadRegP dst) %{
15118   match(Set dst (ThreadLocal));
15119   ins_cost(0);
15120 
15121   ins_should_rematerialize(true);
15122 
15123   format %{ &quot; -- \t// $dst=Thread::current(), empty&quot; %}
15124   size(0);
15125   ins_encode( /*empty*/ );
15126   ins_pipe(pipe_class_empty);
15127 %}
15128 
15129 //---Some PPC specific nodes---------------------------------------------------
15130 
15131 // Stop a group.
15132 instruct endGroup() %{
15133   ins_cost(0);
15134 
15135   ins_is_nop(true);
15136 
15137   format %{ &quot;End Bundle (ori r1, r1, 0)&quot; %}
15138   size(4);
15139   ins_encode %{
15140     // TODO: PPC port $archOpcode(ppc64Opcode_endgroup);
15141     __ endgroup();
15142   %}
15143   ins_pipe(pipe_class_default);
15144 %}
15145 
15146 // Nop instructions
15147 
15148 instruct fxNop() %{
15149   ins_cost(0);
15150 
15151   ins_is_nop(true);
15152 
15153   format %{ &quot;fxNop&quot; %}
15154   size(4);
15155   ins_encode %{
15156     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
15157     __ nop();
15158   %}
15159   ins_pipe(pipe_class_default);
15160 %}
15161 
15162 instruct fpNop0() %{
15163   ins_cost(0);
15164 
15165   ins_is_nop(true);
15166 
15167   format %{ &quot;fpNop0&quot; %}
15168   size(4);
15169   ins_encode %{
15170     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
15171     __ fpnop0();
15172   %}
15173   ins_pipe(pipe_class_default);
15174 %}
15175 
15176 instruct fpNop1() %{
15177   ins_cost(0);
15178 
15179   ins_is_nop(true);
15180 
15181   format %{ &quot;fpNop1&quot; %}
15182   size(4);
15183   ins_encode %{
15184     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
15185     __ fpnop1();
15186   %}
15187   ins_pipe(pipe_class_default);
15188 %}
15189 
15190 instruct brNop0() %{
15191   ins_cost(0);
15192   size(4);
15193   format %{ &quot;brNop0&quot; %}
15194   ins_encode %{
15195     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
15196     __ brnop0();
15197   %}
15198   ins_is_nop(true);
15199   ins_pipe(pipe_class_default);
15200 %}
15201 
15202 instruct brNop1() %{
15203   ins_cost(0);
15204 
15205   ins_is_nop(true);
15206 
15207   format %{ &quot;brNop1&quot; %}
15208   size(4);
15209   ins_encode %{
15210     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
15211     __ brnop1();
15212   %}
15213   ins_pipe(pipe_class_default);
15214 %}
15215 
15216 instruct brNop2() %{
15217   ins_cost(0);
15218 
15219   ins_is_nop(true);
15220 
15221   format %{ &quot;brNop2&quot; %}
15222   size(4);
15223   ins_encode %{
15224     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
15225     __ brnop2();
15226   %}
15227   ins_pipe(pipe_class_default);
15228 %}
15229 
15230 instruct cacheWB(indirect addr)
15231 %{
15232   match(CacheWB addr);
15233 
15234   ins_cost(100);
15235   format %{ &quot;cache writeback, address = $addr&quot; %}
15236   ins_encode %{
15237     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);
15238     assert($addr$$disp == 0, &quot;should be&quot;);
15239     __ cache_wb(Address($addr$$base$$Register));
15240   %}
15241   ins_pipe(pipe_class_default);
15242 %}
15243 
15244 instruct cacheWBPreSync()
15245 %{
15246   match(CacheWBPreSync);
15247 
15248   ins_cost(0);
15249   format %{ &quot;cache writeback presync&quot; %}
15250   ins_encode %{
15251     __ cache_wbsync(true);
15252   %}
15253   ins_pipe(pipe_class_default);
15254 %}
15255 
15256 instruct cacheWBPostSync()
15257 %{
15258   match(CacheWBPostSync);
15259 
15260   ins_cost(100);
15261   format %{ &quot;cache writeback postsync&quot; %}
15262   ins_encode %{
15263     __ cache_wbsync(false);
15264   %}
15265   ins_pipe(pipe_class_default);
15266 %}
15267 
15268 //----------PEEPHOLE RULES-----------------------------------------------------
15269 // These must follow all instruction definitions as they use the names
15270 // defined in the instructions definitions.
15271 //
15272 // peepmatch ( root_instr_name [preceeding_instruction]* );
15273 //
15274 // peepconstraint %{
15275 // (instruction_number.operand_name relational_op instruction_number.operand_name
15276 //  [, ...] );
15277 // // instruction numbers are zero-based using left to right order in peepmatch
15278 //
15279 // peepreplace ( instr_name ( [instruction_number.operand_name]* ) );
15280 // // provide an instruction_number.operand_name for each operand that appears
15281 // // in the replacement instruction&#39;s match rule
15282 //
15283 // ---------VM FLAGS---------------------------------------------------------
15284 //
15285 // All peephole optimizations can be turned off using -XX:-OptoPeephole
15286 //
15287 // Each peephole rule is given an identifying number starting with zero and
15288 // increasing by one in the order seen by the parser. An individual peephole
15289 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
15290 // on the command-line.
15291 //
15292 // ---------CURRENT LIMITATIONS----------------------------------------------
15293 //
15294 // Only match adjacent instructions in same basic block
15295 // Only equality constraints
15296 // Only constraints between operands, not (0.dest_reg == EAX_enc)
15297 // Only one replacement instruction
15298 //
15299 // ---------EXAMPLE----------------------------------------------------------
15300 //
15301 // // pertinent parts of existing instructions in architecture description
15302 // instruct movI(eRegI dst, eRegI src) %{
15303 //   match(Set dst (CopyI src));
15304 // %}
15305 //
15306 // instruct incI_eReg(eRegI dst, immI1 src, eFlagsReg cr) %{
15307 //   match(Set dst (AddI dst src));
15308 //   effect(KILL cr);
15309 // %}
15310 //
15311 // // Change (inc mov) to lea
15312 // peephole %{
15313 //   // increment preceeded by register-register move
15314 //   peepmatch ( incI_eReg movI );
15315 //   // require that the destination register of the increment
15316 //   // match the destination register of the move
15317 //   peepconstraint ( 0.dst == 1.dst );
15318 //   // construct a replacement instruction that sets
15319 //   // the destination to ( move&#39;s source register + one )
15320 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15321 // %}
15322 //
15323 // Implementation no longer uses movX instructions since
15324 // machine-independent system no longer uses CopyX nodes.
15325 //
15326 // peephole %{
15327 //   peepmatch ( incI_eReg movI );
15328 //   peepconstraint ( 0.dst == 1.dst );
15329 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15330 // %}
15331 //
15332 // peephole %{
15333 //   peepmatch ( decI_eReg movI );
15334 //   peepconstraint ( 0.dst == 1.dst );
15335 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15336 // %}
15337 //
15338 // peephole %{
15339 //   peepmatch ( addI_eReg_imm movI );
15340 //   peepconstraint ( 0.dst == 1.dst );
15341 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15342 // %}
15343 //
15344 // peephole %{
15345 //   peepmatch ( addP_eReg_imm movP );
15346 //   peepconstraint ( 0.dst == 1.dst );
15347 //   peepreplace ( leaP_eReg_immI( 0.dst 1.src 0.src ) );
15348 // %}
15349 
15350 // // Change load of spilled value to only a spill
15351 // instruct storeI(memory mem, eRegI src) %{
15352 //   match(Set mem (StoreI mem src));
15353 // %}
15354 //
15355 // instruct loadI(eRegI dst, memory mem) %{
15356 //   match(Set dst (LoadI mem));
15357 // %}
15358 //
15359 peephole %{
15360   peepmatch ( loadI storeI );
15361   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
15362   peepreplace ( storeI( 1.mem 1.mem 1.src ) );
15363 %}
15364 
15365 peephole %{
15366   peepmatch ( loadL storeL );
15367   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
15368   peepreplace ( storeL( 1.mem 1.mem 1.src ) );
15369 %}
15370 
15371 peephole %{
15372   peepmatch ( loadP storeP );
15373   peepconstraint ( 1.src == 0.dst, 1.dst == 0.mem );
15374   peepreplace ( storeP( 1.dst 1.dst 1.src ) );
15375 %}
15376 
15377 //----------SMARTSPILL RULES---------------------------------------------------
15378 // These must follow all instruction definitions as they use the names
15379 // defined in the instructions definitions.
<a name="70" id="anc70"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="70" type="hidden" />
</body>
</html>
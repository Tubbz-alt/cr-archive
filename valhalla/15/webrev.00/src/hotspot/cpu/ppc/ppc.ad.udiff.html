<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/ppc/ppc.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_ppc.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_ppc_64.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/ppc/ppc.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1142,11 +1142,11 @@</span>
  
  //=============================================================================
  
  // Emit an interrupt that is caught by the debugger (for debugging compiler).
  void emit_break(CodeBuffer &amp;cbuf) {
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
    __ illtrap();
  }
  
  #ifndef PRODUCT
  void MachBreakpointNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1163,11 +1163,11 @@</span>
  }
  
  //=============================================================================
  
  void emit_nop(CodeBuffer &amp;cbuf) {
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
    __ nop();
  }
  
  static inline void emit_long(CodeBuffer &amp;cbuf, int value) {
    *((int*)(cbuf.insts_end())) = value;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1182,16 +1182,18 @@</span>
  
  //--------------------------------------------------------------
  //---&lt;  Used for optimization in Compile::Shorten_branches  &gt;---
  //--------------------------------------------------------------
  
<span class="udiff-line-added">+ class C2_MacroAssembler;</span>
<span class="udiff-line-added">+ </span>
  class CallStubImpl {
  
   public:
  
    // Emit call stub, compiled java to interpreter.
<span class="udiff-line-modified-removed">-   static void emit_trampoline_stub(MacroAssembler &amp;_masm, int destination_toc_offset, int insts_call_instruction_offset);</span>
<span class="udiff-line-modified-added">+   static void emit_trampoline_stub(C2_MacroAssembler &amp;_masm, int destination_toc_offset, int insts_call_instruction_offset);</span>
  
    // Size of call trampoline stub.
    // This doesn&#39;t need to be accurate to the byte, but it
    // must be larger than or equal to the real size of the stub.
    static uint size_call_trampoline() {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1218,11 +1220,11 @@</span>
  //
  // Related trampoline stub for this call-site in the stub section:
  //   load the call target from the constant pool
  //   branch via CTR (LR/link still points to the call-site above)
  
<span class="udiff-line-modified-removed">- void CallStubImpl::emit_trampoline_stub(MacroAssembler &amp;_masm, int destination_toc_offset, int insts_call_instruction_offset) {</span>
<span class="udiff-line-modified-added">+ void CallStubImpl::emit_trampoline_stub(C2_MacroAssembler &amp;_masm, int destination_toc_offset, int insts_call_instruction_offset) {</span>
    address stub = __ emit_trampoline_stub(destination_toc_offset, insts_call_instruction_offset);
    if (stub == NULL) {
      ciEnv::current()-&gt;record_out_of_memory_failure();
    }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1249,11 +1251,11 @@</span>
  // Emit a branch-and-link instruction that branches to a trampoline.
  // - Remember the offset of the branch-and-link instruction.
  // - Add a relocation at the branch-and-link instruction.
  // - Emit a branch-and-link.
  // - Remember the return pc offset.
<span class="udiff-line-modified-removed">- EmitCallOffsets emit_call_with_trampoline_stub(MacroAssembler &amp;_masm, address entry_point, relocInfo::relocType rtype) {</span>
<span class="udiff-line-modified-added">+ EmitCallOffsets emit_call_with_trampoline_stub(C2_MacroAssembler &amp;_masm, address entry_point, relocInfo::relocType rtype) {</span>
    EmitCallOffsets offsets = { -1, -1 };
    const int start_offset = __ offset();
    offsets.insts_call_instruction_offset = __ offset();
  
    // No entry point given, use the current pc.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1295,11 +1297,11 @@</span>
  }
  
  //=============================================================================
  
  const RegMask&amp; MachConstantBaseNode::_out_RegMask = BITS64_CONSTANT_TABLE_BASE_mask();
<span class="udiff-line-modified-removed">- int Compile::ConstantTable::calculate_table_base_offset() const {</span>
<span class="udiff-line-modified-added">+ int ConstantTable::calculate_table_base_offset() const {</span>
    return 0;  // absolute addressing, no offset
  }
  
  bool MachConstantBaseNode::requires_postalloc_expand() const { return true; }
  void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1336,14 +1338,14 @@</span>
  //=============================================================================
  
  #ifndef PRODUCT
  void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
    Compile* C = ra_-&gt;C;
<span class="udiff-line-modified-removed">-   const long framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
<span class="udiff-line-modified-added">+   const long framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
  
    st-&gt;print(&quot;PROLOG\n\t&quot;);
<span class="udiff-line-modified-removed">-   if (C-&gt;need_stack_bang(framesize)) {</span>
<span class="udiff-line-modified-added">+   if (C-&gt;output()-&gt;need_stack_bang(framesize)) {</span>
      st-&gt;print(&quot;stack_overflow_check\n\t&quot;);
    }
  
    if (!false /* TODO: PPC port C-&gt;is_frameless_method()*/) {
      st-&gt;print(&quot;save return pc\n\t&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1377,13 +1379,13 @@</span>
                    Unimplemented()
  #endif
  
  void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
    Compile* C = ra_-&gt;C;
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
<span class="udiff-line-modified-removed">-   const long framesize = C-&gt;frame_size_in_bytes();</span>
<span class="udiff-line-modified-added">+   const long framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
    assert(framesize % (2 * wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
  
    const bool method_is_frameless      = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
  
    const Register return_pc            = R20; // Must match return_addr() in frame section.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1424,13 +1426,13 @@</span>
    // We require that their callers must bang for them. But be
    // careful, because some VM calls (such as call site linkage) can
    // use several kilobytes of stack. But the stack safety zone should
    // account for that. See bugs 4446381, 4468289, 4497237.
  
<span class="udiff-line-modified-removed">-   int bangsize = C-&gt;bang_size_in_bytes();</span>
<span class="udiff-line-modified-added">+   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
    assert(bangsize &gt;= framesize || bangsize &lt;= 0, &quot;stack bang size incorrect&quot;);
<span class="udiff-line-modified-removed">-   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
<span class="udiff-line-modified-added">+   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
      // Unfortunately we cannot use the function provided in
      // assembler.cpp as we have to emulate the pipes. So I had to
      // insert the code of generate_stack_overflow_check(), see
      // assembler.cpp for some illuminative comments.
      const int page_size = os::vm_page_size();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1480,11 +1482,11 @@</span>
        }
  
        bang_offset += page_size;
      }
      // R11 trashed
<span class="udiff-line-modified-removed">-   } // C-&gt;need_stack_bang(framesize) &amp;&amp; UseStackBanging</span>
<span class="udiff-line-modified-added">+   } // C-&gt;output()-&gt;need_stack_bang(framesize) &amp;&amp; UseStackBanging</span>
  
    unsigned int bytes = (unsigned int)framesize;
    long offset = Assembler::align_addr(bytes, frame::alignment_in_bytes);
    ciMethod *currMethod = C-&gt;method();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1535,11 +1537,11 @@</span>
    if (!method_is_frameless) {
      // Save return pc.
      ___(std) std(return_pc, _abi(lr), callers_sp);
    }
  
<span class="udiff-line-modified-removed">-   C-&gt;set_frame_complete(cbuf.insts_size());</span>
<span class="udiff-line-modified-added">+   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());</span>
  }
  #undef ___
  #undef ___stop
  #undef ___advance
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1569,13 +1571,13 @@</span>
  }
  #endif
  
  void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
    Compile* C = ra_-&gt;C;
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
<span class="udiff-line-modified-removed">-   const long framesize = ((long)C-&gt;frame_slots()) &lt;&lt; LogBytesPerInt;</span>
<span class="udiff-line-modified-added">+   const long framesize = ((long)C-&gt;output()-&gt;frame_slots()) &lt;&lt; LogBytesPerInt;</span>
    assert(framesize &gt;= 0, &quot;negative frame-size?&quot;);
  
    const bool method_needs_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
    const bool method_is_frameless  = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
    const Register return_pc        = R31;  // Must survive C-call to enable_stack_reserved_zone().
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1635,11 +1637,11 @@</span>
    return 0;
  }
  
  #if 0 // TODO: PPC port
  void MachLoadPollAddrLateNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
    if (LoadPollAddressFromThread) {
      _masm.ld(R11, in_bytes(JavaThread::poll_address_offset()), R16_thread);
    } else {
      _masm.nop();
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1752,11 +1754,11 @@</span>
      // Memory-&gt;Memory Spill.
      if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
        int src_offset = ra_-&gt;reg2offset(src_lo);
        int dst_offset = ra_-&gt;reg2offset(dst_lo);
        if (cbuf) {
<span class="udiff-line-modified-removed">-         MacroAssembler _masm(cbuf);</span>
<span class="udiff-line-modified-added">+         C2_MacroAssembler _masm(cbuf);</span>
          __ ld(R0, src_offset, R1_SP);
          __ std(R0, dst_offset, R1_SP);
          __ ld(R0, src_offset+8, R1_SP);
          __ std(R0, dst_offset+8, R1_SP);
        }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1765,33 +1767,33 @@</span>
      // VectorSRegister-&gt;Memory Spill.
      else if (src_lo_rc == rc_vs &amp;&amp; dst_lo_rc == rc_stack) {
        VectorSRegister Rsrc = as_VectorSRegister(Matcher::_regEncode[src_lo]);
        int dst_offset = ra_-&gt;reg2offset(dst_lo);
        if (cbuf) {
<span class="udiff-line-modified-removed">-         MacroAssembler _masm(cbuf);</span>
<span class="udiff-line-modified-added">+         C2_MacroAssembler _masm(cbuf);</span>
          __ addi(R0, R1_SP, dst_offset);
          __ stxvd2x(Rsrc, R0);
        }
        size += 8;
      }
      // Memory-&gt;VectorSRegister Spill.
      else if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_vs) {
        VectorSRegister Rdst = as_VectorSRegister(Matcher::_regEncode[dst_lo]);
        int src_offset = ra_-&gt;reg2offset(src_lo);
        if (cbuf) {
<span class="udiff-line-modified-removed">-         MacroAssembler _masm(cbuf);</span>
<span class="udiff-line-modified-added">+         C2_MacroAssembler _masm(cbuf);</span>
          __ addi(R0, R1_SP, src_offset);
          __ lxvd2x(Rdst, R0);
        }
        size += 8;
      }
      // VectorSRegister-&gt;VectorSRegister.
      else if (src_lo_rc == rc_vs &amp;&amp; dst_lo_rc == rc_vs) {
        VectorSRegister Rsrc = as_VectorSRegister(Matcher::_regEncode[src_lo]);
        VectorSRegister Rdst = as_VectorSRegister(Matcher::_regEncode[dst_lo]);
        if (cbuf) {
<span class="udiff-line-modified-removed">-         MacroAssembler _masm(cbuf);</span>
<span class="udiff-line-modified-added">+         C2_MacroAssembler _masm(cbuf);</span>
          __ xxlor(Rdst, Rsrc, Rsrc);
        }
        size += 4;
      }
      else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1831,11 +1833,11 @@</span>
        Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
        Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
        size = (Rsrc != Rdst) ? 4 : 0;
  
        if (cbuf) {
<span class="udiff-line-modified-removed">-         MacroAssembler _masm(cbuf);</span>
<span class="udiff-line-modified-added">+         C2_MacroAssembler _masm(cbuf);</span>
          if (size) {
            __ mr(Rdst, Rsrc);
          }
        }
  #ifndef PRODUCT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1877,11 +1879,11 @@</span>
    }
  
    // Check for float reg-reg copy.
    if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
      if (cbuf) {
<span class="udiff-line-modified-removed">-       MacroAssembler _masm(cbuf);</span>
<span class="udiff-line-modified-added">+       C2_MacroAssembler _masm(cbuf);</span>
        FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
        FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
        __ fmr(Rdst, Rsrc);
      }
  #ifndef PRODUCT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2047,11 +2049,11 @@</span>
    st-&gt;print(&quot;NOP \t// %d nops to pad for loops.&quot;, _count);
  }
  #endif
  
  void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *) const {
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
    // _count contains the number of nops needed for padding.
    for (int i = 0; i &lt; _count; i++) {
      __ nop();
    }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2068,11 +2070,11 @@</span>
    st-&gt;print(&quot;ADDI    %s, SP, %d \t// box node&quot;, reg_str, offset);
  }
  #endif
  
  void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
    int reg    = ra_-&gt;get_encode(this);
  
    if (Assembler::is_simm(offset, 16)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2094,11 +2096,11 @@</span>
  }
  #endif
  
  void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
    // This is the unverified entry point.
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    // Inline_cache contains a klass.
    Register ic_klass       = as_Register(Matcher::inline_cache_reg_encode());
    Register receiver_klass = R12_scratch2;  // tmp
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2177,11 +2179,11 @@</span>
  %} // end source_hpp
  
  source %{
  
  int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    address base = __ start_a_stub(size_exception_handler());
    if (base == NULL) return 0; // CodeBuffer::expand failed
  
    int offset = __ offset();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2194,11 +2196,11 @@</span>
  }
  
  // The deopt_handler is like the exception handler, but it calls to
  // the deoptimization blob instead of jumping to the exception blob.
  int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    address base = __ start_a_stub(size_deopt_handler());
    if (base == NULL) return 0; // CodeBuffer::expand failed
  
    int offset = __ offset();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2658,111 +2660,111 @@</span>
  // tertiary opcode. Only the opcode sections which a particular instruction
  // needs for encoding need to be specified.
  encode %{
    enc_class enc_unimplemented %{
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ unimplemented(&quot;Unimplemented mach node encoding in AD file.&quot;, 13);
    %}
  
    enc_class enc_untested %{
  #ifdef ASSERT
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ untested(&quot;Untested mach node encoding in AD file.&quot;);
  #else
      // TODO: PPC port $archOpcode(ppc64Opcode_none);
  #endif
    %}
  
    enc_class enc_lbz(iRegIdst dst, memory mem) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_lbz);
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
      __ lbz($dst$$Register, Idisp, $mem$$base$$Register);
    %}
  
    // Load acquire.
    enc_class enc_lbz_ac(iRegIdst dst, memory mem) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
      __ lbz($dst$$Register, Idisp, $mem$$base$$Register);
      __ twi_0($dst$$Register);
      __ isync();
    %}
  
    enc_class enc_lhz(iRegIdst dst, memory mem) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_lhz);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
      __ lhz($dst$$Register, Idisp, $mem$$base$$Register);
    %}
  
    // Load acquire.
    enc_class enc_lhz_ac(iRegIdst dst, memory mem) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
      __ lhz($dst$$Register, Idisp, $mem$$base$$Register);
      __ twi_0($dst$$Register);
      __ isync();
    %}
  
    enc_class enc_lwz(iRegIdst dst, memory mem) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_lwz);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
      __ lwz($dst$$Register, Idisp, $mem$$base$$Register);
    %}
  
    // Load acquire.
    enc_class enc_lwz_ac(iRegIdst dst, memory mem) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
      __ lwz($dst$$Register, Idisp, $mem$$base$$Register);
      __ twi_0($dst$$Register);
      __ isync();
    %}
  
    enc_class enc_ld(iRegLdst dst, memoryAlg4 mem) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_ld);
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
      // Operand &#39;ds&#39; requires 4-alignment.
      assert((Idisp &amp; 0x3) == 0, &quot;unaligned offset&quot;);
      __ ld($dst$$Register, Idisp, $mem$$base$$Register);
    %}
  
    // Load acquire.
    enc_class enc_ld_ac(iRegLdst dst, memoryAlg4 mem) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
      // Operand &#39;ds&#39; requires 4-alignment.
      assert((Idisp &amp; 0x3) == 0, &quot;unaligned offset&quot;);
      __ ld($dst$$Register, Idisp, $mem$$base$$Register);
      __ twi_0($dst$$Register);
      __ isync();
    %}
  
    enc_class enc_lfd(RegF dst, memory mem) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_lfd);
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
      __ lfd($dst$$FloatRegister, Idisp, $mem$$base$$Register);
    %}
  
    enc_class enc_load_long_constL(iRegLdst dst, immL src, iRegLdst toc) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_ld);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int toc_offset = 0;
  
      address const_toc_addr;
      // Create a non-oop constant, no relocation needed.
      // If it is an IC, it has a virtual_call_Relocation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2782,13 +2784,13 @@</span>
    %}
  
    enc_class enc_load_long_constL_hi(iRegLdst dst, iRegLdst toc, immL src) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_addis);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
<span class="udiff-line-modified-removed">-     if (!ra_-&gt;C-&gt;in_scratch_emit_size()) {</span>
<span class="udiff-line-modified-added">+     if (!ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size()) {</span>
        address const_toc_addr;
        // Create a non-oop constant, no relocation needed.
        // If it is an IC, it has a virtual_call_Relocation.
        const_toc_addr = __ long_constant((jlong)$src$$constant);
        if (const_toc_addr == NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3017,11 +3019,11 @@</span>
    %}
  
    enc_class enc_load_long_constP(iRegLdst dst, immP src, iRegLdst toc) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_ld);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int toc_offset = 0;
  
      intptr_t val = $src$$constant;
      relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();  // src
      address const_toc_addr;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3050,12 +3052,12 @@</span>
    %}
  
    enc_class enc_load_long_constP_hi(iRegLdst dst, immP src, iRegLdst toc) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_addis);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-removed">-     if (!ra_-&gt;C-&gt;in_scratch_emit_size()) {</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     if (!ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size()) {</span>
        intptr_t val = $src$$constant;
        relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();  // src
        address const_toc_addr;
        if (constant_reloc == relocInfo::oop_type) {
          // Create an oop constant and a corresponding relocation.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3184,34 +3186,34 @@</span>
      nodes-&gt;push(m2);
    %}
  
    enc_class enc_stw(iRegIsrc src, memory mem) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_stw);
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
      __ stw($src$$Register, Idisp, $mem$$base$$Register);
    %}
  
    enc_class enc_std(iRegIsrc src, memoryAlg4 mem) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_std);
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
      // Operand &#39;ds&#39; requires 4-alignment.
      assert((Idisp &amp; 0x3) == 0, &quot;unaligned offset&quot;);
      __ std($src$$Register, Idisp, $mem$$base$$Register);
    %}
  
    enc_class enc_stfs(RegF src, memory mem) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_stfs);
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
      __ stfs($src$$FloatRegister, Idisp, $mem$$base$$Register);
    %}
  
    enc_class enc_stfd(RegF src, memory mem) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_stfd);
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
      __ stfd($src$$FloatRegister, Idisp, $mem$$base$$Register);
    %}
  
    // Use release_store for card-marking to ensure that previous
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3228,11 +3230,11 @@</span>
      // __ beq(CCRfixed, skip_release);
      // __ release();
      // __ bind(skip_release);
      // __ stb(card mark);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label skip_storestore;
  
  #if 0 // TODO: PPC port
      // Check CMSCollectorCardTableBarrierSetBSExt::_requires_release and do the
      // StoreStore barrier conditionally.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3449,11 +3451,11 @@</span>
    %}
  
    enc_class enc_cmove_reg(iRegIdst dst, flagsRegSrc crx, iRegIsrc src, cmpOp cmp) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int cc        = $cmp$$cmpcode;
      int flags_reg = $crx$$reg;
      Label done;
      assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
      // Branch if not (cmp crx).
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3464,11 +3466,11 @@</span>
    %}
  
    enc_class enc_cmove_imm(iRegIdst dst, flagsRegSrc crx, immI16 src, cmpOp cmp) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label done;
      assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
      // Branch if not (cmp crx).
      __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
      __ li($dst$$Register, $src$$constant);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3478,18 +3480,18 @@</span>
  
    // This enc_class is needed so that scheduler gets proper
    // input mapping for latency computation.
    enc_class enc_andc(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_andc);
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ andc($dst$$Register, $src1$$Register, $src2$$Register);
    %}
  
    enc_class enc_convI2B_regI__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      Label done;
      __ cmpwi($crx$$CondRegister, $src$$Register, 0);
      __ li($dst$$Register, $zero$$constant);
      __ beq($crx$$CondRegister, done);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3498,11 +3500,11 @@</span>
    %}
  
    enc_class enc_convP2B_regP__cmove(iRegIdst dst, iRegPsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      Label done;
      __ cmpdi($crx$$CondRegister, $src$$Register, 0);
      __ li($dst$$Register, $zero$$constant);
      __ beq($crx$$CondRegister, done);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3511,11 +3513,11 @@</span>
    %}
  
    enc_class enc_cmove_bso_stackSlotL(iRegLdst dst, flagsRegSrc crx, stackSlotL mem ) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
      Label done;
      __ bso($crx$$CondRegister, done);
      __ ld($dst$$Register, Idisp, $mem$$base$$Register);
      // TODO PPC port __ endgroup_if_needed(_size == 12);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3523,22 +3525,22 @@</span>
    %}
  
    enc_class enc_cmove_bso_reg(iRegLdst dst, flagsRegSrc crx, regD src) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label done;
      __ bso($crx$$CondRegister, done);
      __ mffprd($dst$$Register, $src$$FloatRegister);
      // TODO PPC port __ endgroup_if_needed(_size == 12);
      __ bind(done);
    %}
  
    enc_class enc_bc(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_bc);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label d;   // dummy
      __ bind(d);
      Label* p = ($lbl$$label);
      // `p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3564,11 +3566,11 @@</span>
    enc_class enc_bc_far(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
      // The scheduler doesn&#39;t know about branch shortening, so we set the opcode
      // to ppc64Opcode_bc in order to hide this detail from the scheduler.
      // TODO: PPC port $archOpcode(ppc64Opcode_bc);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label d;    // dummy
      __ bind(d);
      Label* p = ($lbl$$label);
      // `p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3596,11 +3598,11 @@</span>
    enc_class enc_bc_short_far(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
      // The scheduler doesn&#39;t know about branch shortening, so we set the opcode
      // to ppc64Opcode_bc in order to hide this detail from the scheduler.
      // TODO: PPC port $archOpcode(ppc64Opcode_bc);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label d;   // dummy
      __ bind(d);
      Label* p = ($lbl$$label);
      // `p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3681,11 +3683,11 @@</span>
    enc_class enc_poll(immI dst, iRegLdst poll) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_ld);
      // Fake operand dst needed for PPC scheduler.
      assert($dst$$constant == 0x0, &quot;dst must be 0x0&quot;);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      // Mark the code position where the load from the safepoint
      // polling page was emitted as relocInfo::poll_type.
      __ relocate(relocInfo::poll_type);
      __ load_from_polling_page($poll$$Register);
    %}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3737,11 +3739,11 @@</span>
    //
    // Usage of r1 and r2 in the stubs allows to distinguish them.
    enc_class enc_java_static_call(method meth) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_bl);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      address entry_point = (address)$meth$$method;
  
      if (!_method) {
        // A call to a runtime wrapper, e.g. new, new_typeArray_Java, uncommon_trap.
        emit_call_with_trampoline_stub(_masm, entry_point, relocInfo::runtime_call_type);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3787,13 +3789,13 @@</span>
  
    // Second node of expanded dynamic call - the call.
    enc_class enc_java_dynamic_call_sched(method meth) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_bl);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
<span class="udiff-line-modified-removed">-     if (!ra_-&gt;C-&gt;in_scratch_emit_size()) {</span>
<span class="udiff-line-modified-added">+     if (!ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size()) {</span>
        // Create a call trampoline stub for the given method.
        const address entry_point = !($meth$$method) ? 0 : (address)$meth$$method;
        const address entry_point_const = __ address_constant(entry_point, RelocationHolder::none);
        if (entry_point_const == NULL) {
          ciEnv::current()-&gt;record_out_of_memory_failure();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3890,11 +3892,11 @@</span>
    // Compound version of call dynamic
    // Toc is only passed so that it can be used in ins_encode statement.
    // In the code we have to use $constanttablebase.
    enc_class enc_java_dynamic_call(method meth, iRegLdst toc) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int start_offset = __ offset();
  
      Register Rtoc = (ra_) ? $constanttablebase : R2_TOC;
  #if 0
      int vtable_index = this-&gt;_vtable_index;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3949,11 +3951,11 @@</span>
  
    // a runtime call
    enc_class enc_java_to_runtime_call (method meth) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_compound);
  
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      const address start_pc = __ pc();
  
  #if defined(ABI_ELFv2)
      address entry= !($meth$$method) ? NULL : (address)$meth$$method;
      __ call_c(entry, relocInfo::runtime_call_type);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3982,11 +3984,11 @@</span>
    // Move to ctr for leaf call.
    // This enc_class is needed so that scheduler gets proper
    // input mapping for latency computation.
    enc_class enc_leaf_call_mtctr(iRegLsrc src) %{
      // TODO: PPC port $archOpcode(ppc64Opcode_mtctr);
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ mtctr($src$$Register);
    %}
  
    // Postalloc expand emitter for runtime leaf calls.
    enc_class postalloc_expand_java_to_runtime_call(method meth, iRegLdst toc) %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6283,11 +6285,11 @@</span>
  
    format %{ &quot;LD      $dst, offset, $base \t// load long $src from TOC (lo)&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_ld);
<span class="udiff-line-modified-removed">-     int offset = ra_-&gt;C-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;</span>
<span class="udiff-line-modified-added">+     int offset = ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;</span>
      __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
    %}
    ins_pipe(pipe_class_memory);
  %}
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6568,11 +6570,11 @@</span>
  
    format %{ &quot;LD      $dst, offset, $base \t// load ptr $src from TOC (lo)&quot; %}
    size(4);
    ins_encode %{
      // TODO: PPC port $archOpcode(ppc64Opcode_ld);
<span class="udiff-line-modified-removed">-     int offset = ra_-&gt;C-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;</span>
<span class="udiff-line-modified-added">+     int offset = ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;</span>
      __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
    %}
    ins_pipe(pipe_class_memory);
  %}
  
</pre>
<center><a href="macroAssembler_ppc.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_ppc_64.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
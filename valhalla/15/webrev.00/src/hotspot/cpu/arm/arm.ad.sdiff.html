<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/arm/arm.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../aarch64/vm_version_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRAssembler_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/arm.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  120 
  121 source %{
  122 #define __ _masm.
  123 
  124 static FloatRegister reg_to_FloatRegister_object(int register_encoding);
  125 static Register reg_to_register_object(int register_encoding);
  126 
  127 
  128 // ****************************************************************************
  129 
  130 // REQUIRED FUNCTIONALITY
  131 
  132 // Indicate if the safepoint node needs the polling page as an input.
  133 // Since ARM does not have absolute addressing, it does.
  134 bool SafePointNode::needs_polling_address_input() {
  135   return true;
  136 }
  137 
  138 // emit an interrupt that is caught by the debugger (for debugging compiler)
  139 void emit_break(CodeBuffer &amp;cbuf) {
<span class="line-modified">  140   MacroAssembler _masm(&amp;cbuf);</span>
  141   __ breakpoint();
  142 }
  143 
  144 #ifndef PRODUCT
  145 void MachBreakpointNode::format( PhaseRegAlloc *, outputStream *st ) const {
  146   st-&gt;print(&quot;TA&quot;);
  147 }
  148 #endif
  149 
  150 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  151   emit_break(cbuf);
  152 }
  153 
  154 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  155   return MachNode::size(ra_);
  156 }
  157 
  158 
  159 void emit_nop(CodeBuffer &amp;cbuf) {
<span class="line-modified">  160   MacroAssembler _masm(&amp;cbuf);</span>
  161   __ nop();
  162 }
  163 
  164 
  165 void emit_call_reloc(CodeBuffer &amp;cbuf, const MachCallNode *n, MachOper *m, RelocationHolder const&amp; rspec) {
  166   int ret_addr_offset0 = n-&gt;as_MachCall()-&gt;ret_addr_offset();
  167   int call_site_offset = cbuf.insts()-&gt;mark_off();
<span class="line-modified">  168   MacroAssembler _masm(&amp;cbuf);</span>
  169   __ set_inst_mark(); // needed in emit_to_interp_stub() to locate the call
  170   address target = (address)m-&gt;method();
  171   assert(n-&gt;as_MachCall()-&gt;entry_point() == target, &quot;sanity&quot;);
  172   assert(maybe_far_call(n) == !__ reachable_from_cache(target), &quot;sanity&quot;);
  173   assert(cache_reachable() == __ cache_fully_reachable(), &quot;sanity&quot;);
  174 
  175   assert(target != NULL, &quot;need real address&quot;);
  176 
  177   int ret_addr_offset = -1;
  178   if (rspec.type() == relocInfo::runtime_call_type) {
  179     __ call(target, rspec);
  180     ret_addr_offset = __ offset();
  181   } else {
  182     // scratches Rtemp
  183     ret_addr_offset = __ patchable_call(target, rspec, true);
  184   }
  185   assert(ret_addr_offset - call_site_offset == ret_addr_offset0, &quot;fix ret_addr_offset()&quot;);
  186 }
  187 
  188 //=============================================================================
  189 // REQUIRED FUNCTIONALITY for encoding
  190 void emit_lo(CodeBuffer &amp;cbuf, int val) {  }
  191 void emit_hi(CodeBuffer &amp;cbuf, int val) {  }
  192 
  193 
  194 //=============================================================================
  195 const RegMask&amp; MachConstantBaseNode::_out_RegMask = PTR_REG_mask();
  196 
<span class="line-modified">  197 int Compile::ConstantTable::calculate_table_base_offset() const {</span>
  198   int offset = -(size() / 2);
  199   // flds, fldd: 8-bit  offset multiplied by 4: +/- 1024
  200   // ldr, ldrb : 12-bit offset:                 +/- 4096
  201   if (!Assembler::is_simm10(offset)) {
  202     offset = Assembler::min_simm10();
  203   }
  204   return offset;
  205 }
  206 
  207 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  208 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  209   ShouldNotReachHere();
  210 }
  211 
  212 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  213   Compile* C = ra_-&gt;C;
<span class="line-modified">  214   Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
<span class="line-modified">  215   MacroAssembler _masm(&amp;cbuf);</span>
  216 
  217   Register r = as_Register(ra_-&gt;get_encode(this));
  218   CodeSection* consts_section = __ code()-&gt;consts();
  219   int consts_size = consts_section-&gt;align_at_start(consts_section-&gt;size());
  220   assert(constant_table.size() == consts_size, &quot;must be: %d == %d&quot;, constant_table.size(), consts_size);
  221 
  222   // Materialize the constant table base.
  223   address baseaddr = consts_section-&gt;start() + -(constant_table.table_base_offset());
  224   RelocationHolder rspec = internal_word_Relocation::spec(baseaddr);
  225   __ mov_address(r, baseaddr, rspec);
  226 }
  227 
  228 uint MachConstantBaseNode::size(PhaseRegAlloc*) const {
  229   return 8;
  230 }
  231 
  232 #ifndef PRODUCT
  233 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  234   char reg[128];
  235   ra_-&gt;dump_register(this, reg);
  236   st-&gt;print(&quot;MOV_SLOW    &amp;constanttable,%s\t! constant table base&quot;, reg);
  237 }
  238 #endif
  239 
  240 #ifndef PRODUCT
  241 void MachPrologNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  242   Compile* C = ra_-&gt;C;
  243 
  244   for (int i = 0; i &lt; OptoPrologueNops; i++) {
  245     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
  246   }
  247 
<span class="line-modified">  248   size_t framesize = C-&gt;frame_size_in_bytes();</span>
  249   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
<span class="line-modified">  250   int bangsize = C-&gt;bang_size_in_bytes();</span>
  251   // Remove two words for return addr and rbp,
  252   framesize -= 2*wordSize;
  253   bangsize -= 2*wordSize;
  254 
  255   // Calls to C2R adapters often do not accept exceptional returns.
  256   // We require that their callers must bang for them.  But be careful, because
  257   // some VM calls (such as call site linkage) can use several kilobytes of
  258   // stack.  But the stack safety zone should account for that.
  259   // See bugs 4446381, 4468289, 4497237.
<span class="line-modified">  260   if (C-&gt;need_stack_bang(bangsize)) {</span>
  261     st-&gt;print_cr(&quot;! stack bang (%d bytes)&quot;, bangsize); st-&gt;print(&quot;\t&quot;);
  262   }
  263   st-&gt;print_cr(&quot;PUSH   R_FP|R_LR_LR&quot;); st-&gt;print(&quot;\t&quot;);
  264   if (framesize != 0) {
  265     st-&gt;print   (&quot;SUB    R_SP, R_SP, &quot; SIZE_FORMAT,framesize);
  266   }
  267 }
  268 #endif
  269 
  270 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  271   Compile* C = ra_-&gt;C;
<span class="line-modified">  272   MacroAssembler _masm(&amp;cbuf);</span>
  273 
  274   for (int i = 0; i &lt; OptoPrologueNops; i++) {
  275     __ nop();
  276   }
  277 
<span class="line-modified">  278   size_t framesize = C-&gt;frame_size_in_bytes();</span>
  279   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
<span class="line-modified">  280   int bangsize = C-&gt;bang_size_in_bytes();</span>
  281   // Remove two words for return addr and fp,
  282   framesize -= 2*wordSize;
  283   bangsize -= 2*wordSize;
  284 
  285   // Calls to C2R adapters often do not accept exceptional returns.
  286   // We require that their callers must bang for them.  But be careful, because
  287   // some VM calls (such as call site linkage) can use several kilobytes of
  288   // stack.  But the stack safety zone should account for that.
  289   // See bugs 4446381, 4468289, 4497237.
<span class="line-modified">  290   if (C-&gt;need_stack_bang(bangsize)) {</span>
  291     __ arm_stack_overflow_check(bangsize, Rtemp);
  292   }
  293 
  294   __ raw_push(FP, LR);
  295   if (framesize != 0) {
  296     __ sub_slow(SP, SP, framesize);
  297   }
  298 
  299   // offset from scratch buffer is not valid
  300   if (strcmp(cbuf.name(), &quot;Compile::Fill_buffer&quot;) == 0) {
<span class="line-modified">  301     C-&gt;set_frame_complete( __ offset() );</span>
  302   }
  303 
  304   if (C-&gt;has_mach_constant_base_node()) {
  305     // NOTE: We set the table base offset here because users might be
  306     // emitted before MachConstantBaseNode.
<span class="line-modified">  307     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
  308     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  309   }
  310 }
  311 
  312 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  313   return MachNode::size(ra_);
  314 }
  315 
  316 int MachPrologNode::reloc() const {
  317   return 10; // a large enough number
  318 }
  319 
  320 //=============================================================================
  321 #ifndef PRODUCT
  322 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  323   Compile* C = ra_-&gt;C;
  324 
<span class="line-modified">  325   size_t framesize = C-&gt;frame_size_in_bytes();</span>
  326   framesize -= 2*wordSize;
  327 
  328   if (framesize != 0) {
  329     st-&gt;print(&quot;ADD    R_SP, R_SP, &quot; SIZE_FORMAT &quot;\n\t&quot;,framesize);
  330   }
  331   st-&gt;print(&quot;POP    R_FP|R_LR_LR&quot;);
  332 
  333   if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
  334     st-&gt;print(&quot;\n\t&quot;);
  335     st-&gt;print(&quot;MOV    Rtemp, #PollAddr\t! Load Polling address\n\t&quot;);
  336     st-&gt;print(&quot;LDR    Rtemp,[Rtemp]\t!Poll for Safepointing&quot;);
  337   }
  338 }
  339 #endif
  340 
  341 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">  342   MacroAssembler _masm(&amp;cbuf);</span>
  343   Compile* C = ra_-&gt;C;
  344 
<span class="line-modified">  345   size_t framesize = C-&gt;frame_size_in_bytes();</span>
  346   framesize -= 2*wordSize;
  347   if (framesize != 0) {
  348     __ add_slow(SP, SP, framesize);
  349   }
  350   __ raw_pop(FP, LR);
  351 
  352   // If this does safepoint polling, then do it here
  353   if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
  354     __ read_polling_page(Rtemp, relocInfo::poll_return_type);
  355   }
  356 }
  357 
  358 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  359   return MachNode::size(ra_);
  360 }
  361 
  362 int MachEpilogNode::reloc() const {
  363   return 16; // a large enough number
  364 }
  365 
</pre>
<hr />
<pre>
  412   enum RC dst_first_rc = rc_class(dst_first);
  413 
  414   assert( OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first), &quot;must move at least 1 register&quot; );
  415 
  416   // Generate spill code!
  417   int size = 0;
  418 
  419   if (src_first == dst_first &amp;&amp; src_second == dst_second)
  420     return size;            // Self copy, no move
  421 
  422 #ifdef TODO
  423   if (bottom_type()-&gt;isa_vect() != NULL) {
  424   }
  425 #endif
  426 
  427   // Shared code does not expect instruction set capability based bailouts here.
  428   // Handle offset unreachable bailout with minimal change in shared code.
  429   // Bailout only for real instruction emit.
  430   // This requires a single comment change in shared code. ( see output.cpp &quot;Normal&quot; instruction case )
  431 
<span class="line-modified">  432   MacroAssembler _masm(cbuf);</span>
  433 
  434   // --------------------------------------
  435   // Check for mem-mem move.  Load into unused float registers and fall into
  436   // the float-store case.
  437   if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack) {
  438     int offset = ra_-&gt;reg2offset(src_first);
  439     if (cbuf &amp;&amp; !is_memoryfp(offset)) {
  440       ra_-&gt;C-&gt;record_method_not_compilable(&quot;unable to handle large constant offsets&quot;);
  441       return 0;
  442     } else {
  443       if (src_second_rc != rc_bad) {
  444         assert((src_first&amp;1)==0 &amp;&amp; src_first+1 == src_second, &quot;pair of registers must be aligned/contiguous&quot;);
  445         src_first     = OptoReg::Name(R_mem_copy_lo_num);
  446         src_second    = OptoReg::Name(R_mem_copy_hi_num);
  447         src_first_rc  = rc_float;
  448         src_second_rc = rc_float;
  449         if (cbuf) {
  450           __ ldr_double(Rmemcopy, Address(SP, offset));
  451         } else if (!do_size) {
  452           st-&gt;print(LDR_DOUBLE &quot;   R_%s,[R_SP + #%d]\t! spill&quot;,OptoReg::regname(src_first),offset);
</pre>
<hr />
<pre>
  773   implementation( NULL, ra_, false, st );
  774 }
  775 #endif
  776 
  777 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  778   implementation( &amp;cbuf, ra_, false, NULL );
  779 }
  780 
  781 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
  782   return implementation( NULL, ra_, true, NULL );
  783 }
  784 
  785 //=============================================================================
  786 #ifndef PRODUCT
  787 void MachNopNode::format( PhaseRegAlloc *, outputStream *st ) const {
  788   st-&gt;print(&quot;NOP \t# %d bytes pad for loops and calls&quot;, 4 * _count);
  789 }
  790 #endif
  791 
  792 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc * ) const {
<span class="line-modified">  793   MacroAssembler _masm(&amp;cbuf);</span>
  794   for(int i = 0; i &lt; _count; i += 1) {
  795     __ nop();
  796   }
  797 }
  798 
  799 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
  800   return 4 * _count;
  801 }
  802 
  803 
  804 //=============================================================================
  805 #ifndef PRODUCT
  806 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  807   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
  808   int reg = ra_-&gt;get_reg_first(this);
  809   st-&gt;print(&quot;ADD    %s,R_SP+#%d&quot;,Matcher::regName[reg], offset);
  810 }
  811 #endif
  812 
  813 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">  814   MacroAssembler _masm(&amp;cbuf);</span>
  815   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
  816   int reg = ra_-&gt;get_encode(this);
  817   Register dst = reg_to_register_object(reg);
  818 
  819   if (is_aimm(offset)) {
  820     __ add(dst, SP, offset);
  821   } else {
  822     __ mov_slow(dst, offset);
  823     __ add(dst, SP, dst);
  824   }
  825 }
  826 
  827 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
  828   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
  829   assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
<span class="line-modified">  830   return ra_-&gt;C-&gt;scratch_emit_size(this);</span>
  831 }
  832 
  833 //=============================================================================
  834 #ifndef PRODUCT
  835 #define R_RTEMP &quot;R_R12&quot;
  836 void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  837   st-&gt;print_cr(&quot;\nUEP:&quot;);
  838   if (UseCompressedClassPointers) {
  839     st-&gt;print_cr(&quot;\tLDR_w &quot; R_RTEMP &quot;,[R_R0 + oopDesc::klass_offset_in_bytes]\t! Inline cache check&quot;);
  840     st-&gt;print_cr(&quot;\tdecode_klass &quot; R_RTEMP);
  841   } else {
  842     st-&gt;print_cr(&quot;\tLDR   &quot; R_RTEMP &quot;,[R_R0 + oopDesc::klass_offset_in_bytes]\t! Inline cache check&quot;);
  843   }
  844   st-&gt;print_cr(&quot;\tCMP   &quot; R_RTEMP &quot;,R_R8&quot; );
  845   st-&gt;print   (&quot;\tB.NE  SharedRuntime::handle_ic_miss_stub&quot;);
  846 }
  847 #endif
  848 
  849 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">  850   MacroAssembler _masm(&amp;cbuf);</span>
  851   Register iCache  = reg_to_register_object(Matcher::inline_cache_reg_encode());
  852   assert(iCache == Ricklass, &quot;should be&quot;);
  853   Register receiver = R0;
  854 
  855   __ load_klass(Rtemp, receiver);
  856   __ cmp(Rtemp, iCache);
  857   __ jump(SharedRuntime::get_ic_miss_stub(), relocInfo::runtime_call_type, noreg, ne);
  858 }
  859 
  860 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
  861   return MachNode::size(ra_);
  862 }
  863 
  864 
  865 //=============================================================================
  866 
  867 // Emit exception handler code.
  868 int HandlerImpl::emit_exception_handler(CodeBuffer&amp; cbuf) {
<span class="line-modified">  869   MacroAssembler _masm(&amp;cbuf);</span>
  870 
  871   address base = __ start_a_stub(size_exception_handler());
  872   if (base == NULL) {
  873     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
  874     return 0;  // CodeBuffer::expand failed
  875   }
  876 
  877   int offset = __ offset();
  878 
  879   // OK to trash LR, because exception blob will kill it
  880   __ jump(OptoRuntime::exception_blob()-&gt;entry_point(), relocInfo::runtime_call_type, LR_tmp);
  881 
  882   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
  883 
  884   __ end_a_stub();
  885 
  886   return offset;
  887 }
  888 
  889 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
  890   // Can&#39;t use any of the current frame&#39;s registers as we may have deopted
  891   // at a poll and everything can be live.
<span class="line-modified">  892   MacroAssembler _masm(&amp;cbuf);</span>
  893 
  894   address base = __ start_a_stub(size_deopt_handler());
  895   if (base == NULL) {
  896     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
  897     return 0;  // CodeBuffer::expand failed
  898   }
  899 
  900   int offset = __ offset();
  901   address deopt_pc = __ pc();
  902 
  903   __ sub(SP, SP, wordSize); // make room for saved PC
  904   __ push(LR); // save LR that may be live when we get here
  905   __ mov_relative_address(LR, deopt_pc);
  906   __ str(LR, Address(SP, wordSize)); // save deopt PC
  907   __ pop(LR); // restore LR
  908   __ jump(SharedRuntime::deopt_blob()-&gt;unpack(), relocInfo::runtime_call_type, noreg);
  909 
  910   assert(__ offset() - offset &lt;= (int) size_deopt_handler(), &quot;overflow&quot;);
  911 
  912   __ end_a_stub();
</pre>
<hr />
<pre>
 1263       emit_call_reloc(cbuf, as_MachCall(), $meth, runtime_call_Relocation::spec());
 1264     } else {
 1265       int method_index = resolved_method_index(cbuf);
 1266       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 1267                                                   : static_call_Relocation::spec(method_index);
 1268       emit_call_reloc(cbuf, as_MachCall(), $meth, rspec);
 1269 
 1270       // Emit stubs for static call.
 1271       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 1272       if (stub == NULL) {
 1273         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1274         return;
 1275       }
 1276     }
 1277   %}
 1278 
 1279   enc_class save_last_PC %{
 1280     // preserve mark
 1281     address mark = cbuf.insts()-&gt;mark();
 1282     debug_only(int off0 = cbuf.insts_size());
<span class="line-modified"> 1283     MacroAssembler _masm(&amp;cbuf);</span>
 1284     int ret_addr_offset = as_MachCall()-&gt;ret_addr_offset();
 1285     __ adr(LR, mark + ret_addr_offset);
 1286     __ str(LR, Address(Rthread, JavaThread::last_Java_pc_offset()));
 1287     debug_only(int off1 = cbuf.insts_size());
 1288     assert(off1 - off0 == 2 * Assembler::InstructionSize, &quot;correct size prediction&quot;);
 1289     // restore mark
 1290     cbuf.insts()-&gt;set_mark(mark);
 1291   %}
 1292 
 1293   enc_class preserve_SP %{
 1294     // preserve mark
 1295     address mark = cbuf.insts()-&gt;mark();
 1296     debug_only(int off0 = cbuf.insts_size());
<span class="line-modified"> 1297     MacroAssembler _masm(&amp;cbuf);</span>
 1298     // FP is preserved across all calls, even compiled calls.
 1299     // Use it to preserve SP in places where the callee might change the SP.
 1300     __ mov(Rmh_SP_save, SP);
 1301     debug_only(int off1 = cbuf.insts_size());
 1302     assert(off1 - off0 == 4, &quot;correct size prediction&quot;);
 1303     // restore mark
 1304     cbuf.insts()-&gt;set_mark(mark);
 1305   %}
 1306 
 1307   enc_class restore_SP %{
<span class="line-modified"> 1308     MacroAssembler _masm(&amp;cbuf);</span>
 1309     __ mov(SP, Rmh_SP_save);
 1310   %}
 1311 
 1312   enc_class Java_Dynamic_Call (method meth) %{
<span class="line-modified"> 1313     MacroAssembler _masm(&amp;cbuf);</span>
 1314     Register R8_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 1315     assert(R8_ic_reg == Ricklass, &quot;should be&quot;);
 1316     __ set_inst_mark();
 1317     __ movw(R8_ic_reg, ((unsigned int)Universe::non_oop_word()) &amp; 0xffff);
 1318     __ movt(R8_ic_reg, ((unsigned int)Universe::non_oop_word()) &gt;&gt; 16);
 1319     address  virtual_call_oop_addr = __ inst_mark();
 1320     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 1321     // who we intended to call.
 1322     int method_index = resolved_method_index(cbuf);
 1323     __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
 1324     emit_call_reloc(cbuf, as_MachCall(), $meth, RelocationHolder::none);
 1325   %}
 1326 
 1327   enc_class LdReplImmI(immI src, regD dst, iRegI tmp, int cnt, int wth) %{
 1328     // FIXME: load from constant table?
 1329     // Load a constant replicated &quot;count&quot; times with width &quot;width&quot;
 1330     int count = $cnt$$constant;
 1331     int width = $wth$$constant;
 1332     assert(count*width == 4, &quot;sanity&quot;);
 1333     int val = $src$$constant;
 1334     if (width &lt; 4) {
 1335       int bit_width = width * 8;
 1336       val &amp;= (((int)1) &lt;&lt; bit_width) - 1; // mask off sign bits
 1337       for (int i = 0; i &lt; count - 1; i++) {
 1338         val |= (val &lt;&lt; bit_width);
 1339       }
 1340     }
<span class="line-modified"> 1341     MacroAssembler _masm(&amp;cbuf);</span>
 1342 
 1343     if (val == -1) {
 1344       __ mvn($tmp$$Register, 0);
 1345     } else if (val == 0) {
 1346       __ mov($tmp$$Register, 0);
 1347     } else {
 1348       __ movw($tmp$$Register, val &amp; 0xffff);
 1349       __ movt($tmp$$Register, (unsigned int)val &gt;&gt; 16);
 1350     }
 1351     __ fmdrr($dst$$FloatRegister, $tmp$$Register, $tmp$$Register);
 1352   %}
 1353 
 1354   enc_class LdReplImmF(immF src, regD dst, iRegI tmp) %{
 1355     // Replicate float con 2 times and pack into vector (8 bytes) in regD.
 1356     float fval = $src$$constant;
 1357     int val = *((int*)&amp;fval);
<span class="line-modified"> 1358     MacroAssembler _masm(&amp;cbuf);</span>
 1359 
 1360     if (val == -1) {
 1361       __ mvn($tmp$$Register, 0);
 1362     } else if (val == 0) {
 1363       __ mov($tmp$$Register, 0);
 1364     } else {
 1365       __ movw($tmp$$Register, val &amp; 0xffff);
 1366       __ movt($tmp$$Register, (unsigned int)val &gt;&gt; 16);
 1367     }
 1368     __ fmdrr($dst$$FloatRegister, $tmp$$Register, $tmp$$Register);
 1369   %}
 1370 
 1371   enc_class enc_String_Compare(R0RegP str1, R1RegP str2, R2RegI cnt1, R3RegI cnt2, iRegI result, iRegI tmp1, iRegI tmp2) %{
 1372     Label Ldone, Lloop;
<span class="line-modified"> 1373     MacroAssembler _masm(&amp;cbuf);</span>
 1374 
 1375     Register   str1_reg = $str1$$Register;
 1376     Register   str2_reg = $str2$$Register;
 1377     Register   cnt1_reg = $cnt1$$Register; // int
 1378     Register   cnt2_reg = $cnt2$$Register; // int
 1379     Register   tmp1_reg = $tmp1$$Register;
 1380     Register   tmp2_reg = $tmp2$$Register;
 1381     Register result_reg = $result$$Register;
 1382 
 1383     assert_different_registers(str1_reg, str2_reg, cnt1_reg, cnt2_reg, tmp1_reg, tmp2_reg);
 1384 
 1385     // Compute the minimum of the string lengths(str1_reg) and the
 1386     // difference of the string lengths (stack)
 1387 
 1388     // See if the lengths are different, and calculate min in str1_reg.
 1389     // Stash diff in tmp2 in case we need it for a tie-breaker.
 1390     __ subs_32(tmp2_reg, cnt1_reg, cnt2_reg);
 1391     __ mov(cnt1_reg, AsmOperand(cnt1_reg, lsl, exact_log2(sizeof(jchar)))); // scale the limit
 1392     __ mov(cnt1_reg, AsmOperand(cnt2_reg, lsl, exact_log2(sizeof(jchar))), pl); // scale the limit
 1393 
</pre>
<hr />
<pre>
 1445     __ subs(chr1_reg, chr1_reg, chr2_reg);
 1446     if (result_reg != chr1_reg) {
 1447       __ mov(result_reg, chr1_reg, ne);
 1448     }
 1449     __ b(Ldone, ne);
 1450 
 1451     __ adds(limit_reg, limit_reg, sizeof(jchar));
 1452     __ b(Lloop, ne);
 1453 
 1454     // If strings are equal up to min length, return the length difference.
 1455     if (result_reg != tmp2_reg) {
 1456       __ mov(result_reg, tmp2_reg);
 1457     }
 1458 
 1459     // Otherwise, return the difference between the first mismatched chars.
 1460     __ bind(Ldone);
 1461   %}
 1462 
 1463   enc_class enc_String_Equals(R0RegP str1, R1RegP str2, R2RegI cnt, iRegI result, iRegI tmp1, iRegI tmp2) %{
 1464     Label Lchar, Lchar_loop, Ldone, Lequal;
<span class="line-modified"> 1465     MacroAssembler _masm(&amp;cbuf);</span>
 1466 
 1467     Register   str1_reg = $str1$$Register;
 1468     Register   str2_reg = $str2$$Register;
 1469     Register    cnt_reg = $cnt$$Register; // int
 1470     Register   tmp1_reg = $tmp1$$Register;
 1471     Register   tmp2_reg = $tmp2$$Register;
 1472     Register result_reg = $result$$Register;
 1473 
 1474     assert_different_registers(str1_reg, str2_reg, cnt_reg, tmp1_reg, tmp2_reg, result_reg);
 1475 
 1476     __ cmp(str1_reg, str2_reg); //same char[] ?
 1477     __ b(Lequal, eq);
 1478 
 1479     __ cbz_32(cnt_reg, Lequal); // count == 0
 1480 
 1481     //rename registers
 1482     Register limit_reg = cnt_reg;
 1483     Register  chr1_reg = tmp1_reg;
 1484     Register  chr2_reg = tmp2_reg;
 1485 
</pre>
<hr />
<pre>
 1507     __ add(str2_reg, limit_reg, str2_reg);
 1508     __ neg(limit_reg, limit_reg); //negate count
 1509 
 1510     // Lchar_loop
 1511     __ bind(Lchar_loop);
 1512     __ ldrh(chr1_reg, Address(str1_reg, limit_reg));
 1513     __ ldrh(chr2_reg, Address(str2_reg, limit_reg));
 1514     __ cmp(chr1_reg, chr2_reg);
 1515     __ b(Ldone, ne);
 1516     __ adds(limit_reg, limit_reg, sizeof(jchar));
 1517     __ b(Lchar_loop, ne);
 1518 
 1519     __ bind(Lequal);
 1520     __ mov(result_reg, 1);  //equal
 1521 
 1522     __ bind(Ldone);
 1523   %}
 1524 
 1525   enc_class enc_Array_Equals(R0RegP ary1, R1RegP ary2, iRegI tmp1, iRegI tmp2, iRegI tmp3, iRegI result) %{
 1526     Label Ldone, Lloop, Lequal;
<span class="line-modified"> 1527     MacroAssembler _masm(&amp;cbuf);</span>
 1528 
 1529     Register   ary1_reg = $ary1$$Register;
 1530     Register   ary2_reg = $ary2$$Register;
 1531     Register   tmp1_reg = $tmp1$$Register;
 1532     Register   tmp2_reg = $tmp2$$Register;
 1533     Register   tmp3_reg = $tmp3$$Register;
 1534     Register result_reg = $result$$Register;
 1535 
 1536     assert_different_registers(ary1_reg, ary2_reg, tmp1_reg, tmp2_reg, tmp3_reg, result_reg);
 1537 
 1538     int length_offset  = arrayOopDesc::length_offset_in_bytes();
 1539     int base_offset    = arrayOopDesc::base_offset_in_bytes(T_CHAR);
 1540 
 1541     // return true if the same array
 1542     __ teq(ary1_reg, ary2_reg);
 1543     __ mov(result_reg, 1, eq);
 1544     __ b(Ldone, eq); // equal
 1545 
 1546     __ tst(ary1_reg, ary1_reg);
 1547     __ mov(result_reg, 0, eq);
</pre>
</td>
<td>
<hr />
<pre>
  120 
  121 source %{
  122 #define __ _masm.
  123 
  124 static FloatRegister reg_to_FloatRegister_object(int register_encoding);
  125 static Register reg_to_register_object(int register_encoding);
  126 
  127 
  128 // ****************************************************************************
  129 
  130 // REQUIRED FUNCTIONALITY
  131 
  132 // Indicate if the safepoint node needs the polling page as an input.
  133 // Since ARM does not have absolute addressing, it does.
  134 bool SafePointNode::needs_polling_address_input() {
  135   return true;
  136 }
  137 
  138 // emit an interrupt that is caught by the debugger (for debugging compiler)
  139 void emit_break(CodeBuffer &amp;cbuf) {
<span class="line-modified">  140   C2_MacroAssembler _masm(&amp;cbuf);</span>
  141   __ breakpoint();
  142 }
  143 
  144 #ifndef PRODUCT
  145 void MachBreakpointNode::format( PhaseRegAlloc *, outputStream *st ) const {
  146   st-&gt;print(&quot;TA&quot;);
  147 }
  148 #endif
  149 
  150 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  151   emit_break(cbuf);
  152 }
  153 
  154 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  155   return MachNode::size(ra_);
  156 }
  157 
  158 
  159 void emit_nop(CodeBuffer &amp;cbuf) {
<span class="line-modified">  160   C2_MacroAssembler _masm(&amp;cbuf);</span>
  161   __ nop();
  162 }
  163 
  164 
  165 void emit_call_reloc(CodeBuffer &amp;cbuf, const MachCallNode *n, MachOper *m, RelocationHolder const&amp; rspec) {
  166   int ret_addr_offset0 = n-&gt;as_MachCall()-&gt;ret_addr_offset();
  167   int call_site_offset = cbuf.insts()-&gt;mark_off();
<span class="line-modified">  168   C2_MacroAssembler _masm(&amp;cbuf);</span>
  169   __ set_inst_mark(); // needed in emit_to_interp_stub() to locate the call
  170   address target = (address)m-&gt;method();
  171   assert(n-&gt;as_MachCall()-&gt;entry_point() == target, &quot;sanity&quot;);
  172   assert(maybe_far_call(n) == !__ reachable_from_cache(target), &quot;sanity&quot;);
  173   assert(cache_reachable() == __ cache_fully_reachable(), &quot;sanity&quot;);
  174 
  175   assert(target != NULL, &quot;need real address&quot;);
  176 
  177   int ret_addr_offset = -1;
  178   if (rspec.type() == relocInfo::runtime_call_type) {
  179     __ call(target, rspec);
  180     ret_addr_offset = __ offset();
  181   } else {
  182     // scratches Rtemp
  183     ret_addr_offset = __ patchable_call(target, rspec, true);
  184   }
  185   assert(ret_addr_offset - call_site_offset == ret_addr_offset0, &quot;fix ret_addr_offset()&quot;);
  186 }
  187 
  188 //=============================================================================
  189 // REQUIRED FUNCTIONALITY for encoding
  190 void emit_lo(CodeBuffer &amp;cbuf, int val) {  }
  191 void emit_hi(CodeBuffer &amp;cbuf, int val) {  }
  192 
  193 
  194 //=============================================================================
  195 const RegMask&amp; MachConstantBaseNode::_out_RegMask = PTR_REG_mask();
  196 
<span class="line-modified">  197 int ConstantTable::calculate_table_base_offset() const {</span>
  198   int offset = -(size() / 2);
  199   // flds, fldd: 8-bit  offset multiplied by 4: +/- 1024
  200   // ldr, ldrb : 12-bit offset:                 +/- 4096
  201   if (!Assembler::is_simm10(offset)) {
  202     offset = Assembler::min_simm10();
  203   }
  204   return offset;
  205 }
  206 
  207 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  208 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  209   ShouldNotReachHere();
  210 }
  211 
  212 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  213   Compile* C = ra_-&gt;C;
<span class="line-modified">  214   ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
<span class="line-modified">  215   C2_MacroAssembler _masm(&amp;cbuf);</span>
  216 
  217   Register r = as_Register(ra_-&gt;get_encode(this));
  218   CodeSection* consts_section = __ code()-&gt;consts();
  219   int consts_size = consts_section-&gt;align_at_start(consts_section-&gt;size());
  220   assert(constant_table.size() == consts_size, &quot;must be: %d == %d&quot;, constant_table.size(), consts_size);
  221 
  222   // Materialize the constant table base.
  223   address baseaddr = consts_section-&gt;start() + -(constant_table.table_base_offset());
  224   RelocationHolder rspec = internal_word_Relocation::spec(baseaddr);
  225   __ mov_address(r, baseaddr, rspec);
  226 }
  227 
  228 uint MachConstantBaseNode::size(PhaseRegAlloc*) const {
  229   return 8;
  230 }
  231 
  232 #ifndef PRODUCT
  233 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  234   char reg[128];
  235   ra_-&gt;dump_register(this, reg);
  236   st-&gt;print(&quot;MOV_SLOW    &amp;constanttable,%s\t! constant table base&quot;, reg);
  237 }
  238 #endif
  239 
  240 #ifndef PRODUCT
  241 void MachPrologNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  242   Compile* C = ra_-&gt;C;
  243 
  244   for (int i = 0; i &lt; OptoPrologueNops; i++) {
  245     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
  246   }
  247 
<span class="line-modified">  248   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
  249   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
<span class="line-modified">  250   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  251   // Remove two words for return addr and rbp,
  252   framesize -= 2*wordSize;
  253   bangsize -= 2*wordSize;
  254 
  255   // Calls to C2R adapters often do not accept exceptional returns.
  256   // We require that their callers must bang for them.  But be careful, because
  257   // some VM calls (such as call site linkage) can use several kilobytes of
  258   // stack.  But the stack safety zone should account for that.
  259   // See bugs 4446381, 4468289, 4497237.
<span class="line-modified">  260   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {</span>
  261     st-&gt;print_cr(&quot;! stack bang (%d bytes)&quot;, bangsize); st-&gt;print(&quot;\t&quot;);
  262   }
  263   st-&gt;print_cr(&quot;PUSH   R_FP|R_LR_LR&quot;); st-&gt;print(&quot;\t&quot;);
  264   if (framesize != 0) {
  265     st-&gt;print   (&quot;SUB    R_SP, R_SP, &quot; SIZE_FORMAT,framesize);
  266   }
  267 }
  268 #endif
  269 
  270 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  271   Compile* C = ra_-&gt;C;
<span class="line-modified">  272   C2_MacroAssembler _masm(&amp;cbuf);</span>
  273 
  274   for (int i = 0; i &lt; OptoPrologueNops; i++) {
  275     __ nop();
  276   }
  277 
<span class="line-modified">  278   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
  279   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
<span class="line-modified">  280   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  281   // Remove two words for return addr and fp,
  282   framesize -= 2*wordSize;
  283   bangsize -= 2*wordSize;
  284 
  285   // Calls to C2R adapters often do not accept exceptional returns.
  286   // We require that their callers must bang for them.  But be careful, because
  287   // some VM calls (such as call site linkage) can use several kilobytes of
  288   // stack.  But the stack safety zone should account for that.
  289   // See bugs 4446381, 4468289, 4497237.
<span class="line-modified">  290   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {</span>
  291     __ arm_stack_overflow_check(bangsize, Rtemp);
  292   }
  293 
  294   __ raw_push(FP, LR);
  295   if (framesize != 0) {
  296     __ sub_slow(SP, SP, framesize);
  297   }
  298 
  299   // offset from scratch buffer is not valid
  300   if (strcmp(cbuf.name(), &quot;Compile::Fill_buffer&quot;) == 0) {
<span class="line-modified">  301     C-&gt;output()-&gt;set_frame_complete( __ offset() );</span>
  302   }
  303 
  304   if (C-&gt;has_mach_constant_base_node()) {
  305     // NOTE: We set the table base offset here because users might be
  306     // emitted before MachConstantBaseNode.
<span class="line-modified">  307     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
  308     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  309   }
  310 }
  311 
  312 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  313   return MachNode::size(ra_);
  314 }
  315 
  316 int MachPrologNode::reloc() const {
  317   return 10; // a large enough number
  318 }
  319 
  320 //=============================================================================
  321 #ifndef PRODUCT
  322 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  323   Compile* C = ra_-&gt;C;
  324 
<span class="line-modified">  325   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
  326   framesize -= 2*wordSize;
  327 
  328   if (framesize != 0) {
  329     st-&gt;print(&quot;ADD    R_SP, R_SP, &quot; SIZE_FORMAT &quot;\n\t&quot;,framesize);
  330   }
  331   st-&gt;print(&quot;POP    R_FP|R_LR_LR&quot;);
  332 
  333   if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
  334     st-&gt;print(&quot;\n\t&quot;);
  335     st-&gt;print(&quot;MOV    Rtemp, #PollAddr\t! Load Polling address\n\t&quot;);
  336     st-&gt;print(&quot;LDR    Rtemp,[Rtemp]\t!Poll for Safepointing&quot;);
  337   }
  338 }
  339 #endif
  340 
  341 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">  342   C2_MacroAssembler _masm(&amp;cbuf);</span>
  343   Compile* C = ra_-&gt;C;
  344 
<span class="line-modified">  345   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
  346   framesize -= 2*wordSize;
  347   if (framesize != 0) {
  348     __ add_slow(SP, SP, framesize);
  349   }
  350   __ raw_pop(FP, LR);
  351 
  352   // If this does safepoint polling, then do it here
  353   if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
  354     __ read_polling_page(Rtemp, relocInfo::poll_return_type);
  355   }
  356 }
  357 
  358 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  359   return MachNode::size(ra_);
  360 }
  361 
  362 int MachEpilogNode::reloc() const {
  363   return 16; // a large enough number
  364 }
  365 
</pre>
<hr />
<pre>
  412   enum RC dst_first_rc = rc_class(dst_first);
  413 
  414   assert( OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first), &quot;must move at least 1 register&quot; );
  415 
  416   // Generate spill code!
  417   int size = 0;
  418 
  419   if (src_first == dst_first &amp;&amp; src_second == dst_second)
  420     return size;            // Self copy, no move
  421 
  422 #ifdef TODO
  423   if (bottom_type()-&gt;isa_vect() != NULL) {
  424   }
  425 #endif
  426 
  427   // Shared code does not expect instruction set capability based bailouts here.
  428   // Handle offset unreachable bailout with minimal change in shared code.
  429   // Bailout only for real instruction emit.
  430   // This requires a single comment change in shared code. ( see output.cpp &quot;Normal&quot; instruction case )
  431 
<span class="line-modified">  432   C2_MacroAssembler _masm(cbuf);</span>
  433 
  434   // --------------------------------------
  435   // Check for mem-mem move.  Load into unused float registers and fall into
  436   // the float-store case.
  437   if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack) {
  438     int offset = ra_-&gt;reg2offset(src_first);
  439     if (cbuf &amp;&amp; !is_memoryfp(offset)) {
  440       ra_-&gt;C-&gt;record_method_not_compilable(&quot;unable to handle large constant offsets&quot;);
  441       return 0;
  442     } else {
  443       if (src_second_rc != rc_bad) {
  444         assert((src_first&amp;1)==0 &amp;&amp; src_first+1 == src_second, &quot;pair of registers must be aligned/contiguous&quot;);
  445         src_first     = OptoReg::Name(R_mem_copy_lo_num);
  446         src_second    = OptoReg::Name(R_mem_copy_hi_num);
  447         src_first_rc  = rc_float;
  448         src_second_rc = rc_float;
  449         if (cbuf) {
  450           __ ldr_double(Rmemcopy, Address(SP, offset));
  451         } else if (!do_size) {
  452           st-&gt;print(LDR_DOUBLE &quot;   R_%s,[R_SP + #%d]\t! spill&quot;,OptoReg::regname(src_first),offset);
</pre>
<hr />
<pre>
  773   implementation( NULL, ra_, false, st );
  774 }
  775 #endif
  776 
  777 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  778   implementation( &amp;cbuf, ra_, false, NULL );
  779 }
  780 
  781 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
  782   return implementation( NULL, ra_, true, NULL );
  783 }
  784 
  785 //=============================================================================
  786 #ifndef PRODUCT
  787 void MachNopNode::format( PhaseRegAlloc *, outputStream *st ) const {
  788   st-&gt;print(&quot;NOP \t# %d bytes pad for loops and calls&quot;, 4 * _count);
  789 }
  790 #endif
  791 
  792 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc * ) const {
<span class="line-modified">  793   C2_MacroAssembler _masm(&amp;cbuf);</span>
  794   for(int i = 0; i &lt; _count; i += 1) {
  795     __ nop();
  796   }
  797 }
  798 
  799 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
  800   return 4 * _count;
  801 }
  802 
  803 
  804 //=============================================================================
  805 #ifndef PRODUCT
  806 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  807   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
  808   int reg = ra_-&gt;get_reg_first(this);
  809   st-&gt;print(&quot;ADD    %s,R_SP+#%d&quot;,Matcher::regName[reg], offset);
  810 }
  811 #endif
  812 
  813 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">  814   C2_MacroAssembler _masm(&amp;cbuf);</span>
  815   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
  816   int reg = ra_-&gt;get_encode(this);
  817   Register dst = reg_to_register_object(reg);
  818 
  819   if (is_aimm(offset)) {
  820     __ add(dst, SP, offset);
  821   } else {
  822     __ mov_slow(dst, offset);
  823     __ add(dst, SP, dst);
  824   }
  825 }
  826 
  827 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
  828   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
  829   assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
<span class="line-modified">  830   return ra_-&gt;C-&gt;output()-&gt;scratch_emit_size(this);</span>
  831 }
  832 
  833 //=============================================================================
  834 #ifndef PRODUCT
  835 #define R_RTEMP &quot;R_R12&quot;
  836 void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  837   st-&gt;print_cr(&quot;\nUEP:&quot;);
  838   if (UseCompressedClassPointers) {
  839     st-&gt;print_cr(&quot;\tLDR_w &quot; R_RTEMP &quot;,[R_R0 + oopDesc::klass_offset_in_bytes]\t! Inline cache check&quot;);
  840     st-&gt;print_cr(&quot;\tdecode_klass &quot; R_RTEMP);
  841   } else {
  842     st-&gt;print_cr(&quot;\tLDR   &quot; R_RTEMP &quot;,[R_R0 + oopDesc::klass_offset_in_bytes]\t! Inline cache check&quot;);
  843   }
  844   st-&gt;print_cr(&quot;\tCMP   &quot; R_RTEMP &quot;,R_R8&quot; );
  845   st-&gt;print   (&quot;\tB.NE  SharedRuntime::handle_ic_miss_stub&quot;);
  846 }
  847 #endif
  848 
  849 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">  850   C2_MacroAssembler _masm(&amp;cbuf);</span>
  851   Register iCache  = reg_to_register_object(Matcher::inline_cache_reg_encode());
  852   assert(iCache == Ricklass, &quot;should be&quot;);
  853   Register receiver = R0;
  854 
  855   __ load_klass(Rtemp, receiver);
  856   __ cmp(Rtemp, iCache);
  857   __ jump(SharedRuntime::get_ic_miss_stub(), relocInfo::runtime_call_type, noreg, ne);
  858 }
  859 
  860 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
  861   return MachNode::size(ra_);
  862 }
  863 
  864 
  865 //=============================================================================
  866 
  867 // Emit exception handler code.
  868 int HandlerImpl::emit_exception_handler(CodeBuffer&amp; cbuf) {
<span class="line-modified">  869   C2_MacroAssembler _masm(&amp;cbuf);</span>
  870 
  871   address base = __ start_a_stub(size_exception_handler());
  872   if (base == NULL) {
  873     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
  874     return 0;  // CodeBuffer::expand failed
  875   }
  876 
  877   int offset = __ offset();
  878 
  879   // OK to trash LR, because exception blob will kill it
  880   __ jump(OptoRuntime::exception_blob()-&gt;entry_point(), relocInfo::runtime_call_type, LR_tmp);
  881 
  882   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
  883 
  884   __ end_a_stub();
  885 
  886   return offset;
  887 }
  888 
  889 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
  890   // Can&#39;t use any of the current frame&#39;s registers as we may have deopted
  891   // at a poll and everything can be live.
<span class="line-modified">  892   C2_MacroAssembler _masm(&amp;cbuf);</span>
  893 
  894   address base = __ start_a_stub(size_deopt_handler());
  895   if (base == NULL) {
  896     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
  897     return 0;  // CodeBuffer::expand failed
  898   }
  899 
  900   int offset = __ offset();
  901   address deopt_pc = __ pc();
  902 
  903   __ sub(SP, SP, wordSize); // make room for saved PC
  904   __ push(LR); // save LR that may be live when we get here
  905   __ mov_relative_address(LR, deopt_pc);
  906   __ str(LR, Address(SP, wordSize)); // save deopt PC
  907   __ pop(LR); // restore LR
  908   __ jump(SharedRuntime::deopt_blob()-&gt;unpack(), relocInfo::runtime_call_type, noreg);
  909 
  910   assert(__ offset() - offset &lt;= (int) size_deopt_handler(), &quot;overflow&quot;);
  911 
  912   __ end_a_stub();
</pre>
<hr />
<pre>
 1263       emit_call_reloc(cbuf, as_MachCall(), $meth, runtime_call_Relocation::spec());
 1264     } else {
 1265       int method_index = resolved_method_index(cbuf);
 1266       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 1267                                                   : static_call_Relocation::spec(method_index);
 1268       emit_call_reloc(cbuf, as_MachCall(), $meth, rspec);
 1269 
 1270       // Emit stubs for static call.
 1271       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 1272       if (stub == NULL) {
 1273         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1274         return;
 1275       }
 1276     }
 1277   %}
 1278 
 1279   enc_class save_last_PC %{
 1280     // preserve mark
 1281     address mark = cbuf.insts()-&gt;mark();
 1282     debug_only(int off0 = cbuf.insts_size());
<span class="line-modified"> 1283     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1284     int ret_addr_offset = as_MachCall()-&gt;ret_addr_offset();
 1285     __ adr(LR, mark + ret_addr_offset);
 1286     __ str(LR, Address(Rthread, JavaThread::last_Java_pc_offset()));
 1287     debug_only(int off1 = cbuf.insts_size());
 1288     assert(off1 - off0 == 2 * Assembler::InstructionSize, &quot;correct size prediction&quot;);
 1289     // restore mark
 1290     cbuf.insts()-&gt;set_mark(mark);
 1291   %}
 1292 
 1293   enc_class preserve_SP %{
 1294     // preserve mark
 1295     address mark = cbuf.insts()-&gt;mark();
 1296     debug_only(int off0 = cbuf.insts_size());
<span class="line-modified"> 1297     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1298     // FP is preserved across all calls, even compiled calls.
 1299     // Use it to preserve SP in places where the callee might change the SP.
 1300     __ mov(Rmh_SP_save, SP);
 1301     debug_only(int off1 = cbuf.insts_size());
 1302     assert(off1 - off0 == 4, &quot;correct size prediction&quot;);
 1303     // restore mark
 1304     cbuf.insts()-&gt;set_mark(mark);
 1305   %}
 1306 
 1307   enc_class restore_SP %{
<span class="line-modified"> 1308     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1309     __ mov(SP, Rmh_SP_save);
 1310   %}
 1311 
 1312   enc_class Java_Dynamic_Call (method meth) %{
<span class="line-modified"> 1313     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1314     Register R8_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 1315     assert(R8_ic_reg == Ricklass, &quot;should be&quot;);
 1316     __ set_inst_mark();
 1317     __ movw(R8_ic_reg, ((unsigned int)Universe::non_oop_word()) &amp; 0xffff);
 1318     __ movt(R8_ic_reg, ((unsigned int)Universe::non_oop_word()) &gt;&gt; 16);
 1319     address  virtual_call_oop_addr = __ inst_mark();
 1320     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 1321     // who we intended to call.
 1322     int method_index = resolved_method_index(cbuf);
 1323     __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
 1324     emit_call_reloc(cbuf, as_MachCall(), $meth, RelocationHolder::none);
 1325   %}
 1326 
 1327   enc_class LdReplImmI(immI src, regD dst, iRegI tmp, int cnt, int wth) %{
 1328     // FIXME: load from constant table?
 1329     // Load a constant replicated &quot;count&quot; times with width &quot;width&quot;
 1330     int count = $cnt$$constant;
 1331     int width = $wth$$constant;
 1332     assert(count*width == 4, &quot;sanity&quot;);
 1333     int val = $src$$constant;
 1334     if (width &lt; 4) {
 1335       int bit_width = width * 8;
 1336       val &amp;= (((int)1) &lt;&lt; bit_width) - 1; // mask off sign bits
 1337       for (int i = 0; i &lt; count - 1; i++) {
 1338         val |= (val &lt;&lt; bit_width);
 1339       }
 1340     }
<span class="line-modified"> 1341     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1342 
 1343     if (val == -1) {
 1344       __ mvn($tmp$$Register, 0);
 1345     } else if (val == 0) {
 1346       __ mov($tmp$$Register, 0);
 1347     } else {
 1348       __ movw($tmp$$Register, val &amp; 0xffff);
 1349       __ movt($tmp$$Register, (unsigned int)val &gt;&gt; 16);
 1350     }
 1351     __ fmdrr($dst$$FloatRegister, $tmp$$Register, $tmp$$Register);
 1352   %}
 1353 
 1354   enc_class LdReplImmF(immF src, regD dst, iRegI tmp) %{
 1355     // Replicate float con 2 times and pack into vector (8 bytes) in regD.
 1356     float fval = $src$$constant;
 1357     int val = *((int*)&amp;fval);
<span class="line-modified"> 1358     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1359 
 1360     if (val == -1) {
 1361       __ mvn($tmp$$Register, 0);
 1362     } else if (val == 0) {
 1363       __ mov($tmp$$Register, 0);
 1364     } else {
 1365       __ movw($tmp$$Register, val &amp; 0xffff);
 1366       __ movt($tmp$$Register, (unsigned int)val &gt;&gt; 16);
 1367     }
 1368     __ fmdrr($dst$$FloatRegister, $tmp$$Register, $tmp$$Register);
 1369   %}
 1370 
 1371   enc_class enc_String_Compare(R0RegP str1, R1RegP str2, R2RegI cnt1, R3RegI cnt2, iRegI result, iRegI tmp1, iRegI tmp2) %{
 1372     Label Ldone, Lloop;
<span class="line-modified"> 1373     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1374 
 1375     Register   str1_reg = $str1$$Register;
 1376     Register   str2_reg = $str2$$Register;
 1377     Register   cnt1_reg = $cnt1$$Register; // int
 1378     Register   cnt2_reg = $cnt2$$Register; // int
 1379     Register   tmp1_reg = $tmp1$$Register;
 1380     Register   tmp2_reg = $tmp2$$Register;
 1381     Register result_reg = $result$$Register;
 1382 
 1383     assert_different_registers(str1_reg, str2_reg, cnt1_reg, cnt2_reg, tmp1_reg, tmp2_reg);
 1384 
 1385     // Compute the minimum of the string lengths(str1_reg) and the
 1386     // difference of the string lengths (stack)
 1387 
 1388     // See if the lengths are different, and calculate min in str1_reg.
 1389     // Stash diff in tmp2 in case we need it for a tie-breaker.
 1390     __ subs_32(tmp2_reg, cnt1_reg, cnt2_reg);
 1391     __ mov(cnt1_reg, AsmOperand(cnt1_reg, lsl, exact_log2(sizeof(jchar)))); // scale the limit
 1392     __ mov(cnt1_reg, AsmOperand(cnt2_reg, lsl, exact_log2(sizeof(jchar))), pl); // scale the limit
 1393 
</pre>
<hr />
<pre>
 1445     __ subs(chr1_reg, chr1_reg, chr2_reg);
 1446     if (result_reg != chr1_reg) {
 1447       __ mov(result_reg, chr1_reg, ne);
 1448     }
 1449     __ b(Ldone, ne);
 1450 
 1451     __ adds(limit_reg, limit_reg, sizeof(jchar));
 1452     __ b(Lloop, ne);
 1453 
 1454     // If strings are equal up to min length, return the length difference.
 1455     if (result_reg != tmp2_reg) {
 1456       __ mov(result_reg, tmp2_reg);
 1457     }
 1458 
 1459     // Otherwise, return the difference between the first mismatched chars.
 1460     __ bind(Ldone);
 1461   %}
 1462 
 1463   enc_class enc_String_Equals(R0RegP str1, R1RegP str2, R2RegI cnt, iRegI result, iRegI tmp1, iRegI tmp2) %{
 1464     Label Lchar, Lchar_loop, Ldone, Lequal;
<span class="line-modified"> 1465     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1466 
 1467     Register   str1_reg = $str1$$Register;
 1468     Register   str2_reg = $str2$$Register;
 1469     Register    cnt_reg = $cnt$$Register; // int
 1470     Register   tmp1_reg = $tmp1$$Register;
 1471     Register   tmp2_reg = $tmp2$$Register;
 1472     Register result_reg = $result$$Register;
 1473 
 1474     assert_different_registers(str1_reg, str2_reg, cnt_reg, tmp1_reg, tmp2_reg, result_reg);
 1475 
 1476     __ cmp(str1_reg, str2_reg); //same char[] ?
 1477     __ b(Lequal, eq);
 1478 
 1479     __ cbz_32(cnt_reg, Lequal); // count == 0
 1480 
 1481     //rename registers
 1482     Register limit_reg = cnt_reg;
 1483     Register  chr1_reg = tmp1_reg;
 1484     Register  chr2_reg = tmp2_reg;
 1485 
</pre>
<hr />
<pre>
 1507     __ add(str2_reg, limit_reg, str2_reg);
 1508     __ neg(limit_reg, limit_reg); //negate count
 1509 
 1510     // Lchar_loop
 1511     __ bind(Lchar_loop);
 1512     __ ldrh(chr1_reg, Address(str1_reg, limit_reg));
 1513     __ ldrh(chr2_reg, Address(str2_reg, limit_reg));
 1514     __ cmp(chr1_reg, chr2_reg);
 1515     __ b(Ldone, ne);
 1516     __ adds(limit_reg, limit_reg, sizeof(jchar));
 1517     __ b(Lchar_loop, ne);
 1518 
 1519     __ bind(Lequal);
 1520     __ mov(result_reg, 1);  //equal
 1521 
 1522     __ bind(Ldone);
 1523   %}
 1524 
 1525   enc_class enc_Array_Equals(R0RegP ary1, R1RegP ary2, iRegI tmp1, iRegI tmp2, iRegI tmp3, iRegI result) %{
 1526     Label Ldone, Lloop, Lequal;
<span class="line-modified"> 1527     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1528 
 1529     Register   ary1_reg = $ary1$$Register;
 1530     Register   ary2_reg = $ary2$$Register;
 1531     Register   tmp1_reg = $tmp1$$Register;
 1532     Register   tmp2_reg = $tmp2$$Register;
 1533     Register   tmp3_reg = $tmp3$$Register;
 1534     Register result_reg = $result$$Register;
 1535 
 1536     assert_different_registers(ary1_reg, ary2_reg, tmp1_reg, tmp2_reg, tmp3_reg, result_reg);
 1537 
 1538     int length_offset  = arrayOopDesc::length_offset_in_bytes();
 1539     int base_offset    = arrayOopDesc::base_offset_in_bytes(T_CHAR);
 1540 
 1541     // return true if the same array
 1542     __ teq(ary1_reg, ary2_reg);
 1543     __ mov(result_reg, 1, eq);
 1544     __ b(Ldone, eq); // equal
 1545 
 1546     __ tst(ary1_reg, ary1_reg);
 1547     __ mov(result_reg, 0, eq);
</pre>
</td>
</tr>
</table>
<center><a href="../aarch64/vm_version_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRAssembler_arm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
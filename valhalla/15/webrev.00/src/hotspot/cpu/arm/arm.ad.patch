diff a/src/hotspot/cpu/arm/arm.ad b/src/hotspot/cpu/arm/arm.ad
--- a/src/hotspot/cpu/arm/arm.ad
+++ b/src/hotspot/cpu/arm/arm.ad
@@ -135,11 +135,11 @@
   return true;
 }
 
 // emit an interrupt that is caught by the debugger (for debugging compiler)
 void emit_break(CodeBuffer &cbuf) {
-  MacroAssembler _masm(&cbuf);
+  C2_MacroAssembler _masm(&cbuf);
   __ breakpoint();
 }
 
 #ifndef PRODUCT
 void MachBreakpointNode::format( PhaseRegAlloc *, outputStream *st ) const {
@@ -155,19 +155,19 @@
   return MachNode::size(ra_);
 }
 
 
 void emit_nop(CodeBuffer &cbuf) {
-  MacroAssembler _masm(&cbuf);
+  C2_MacroAssembler _masm(&cbuf);
   __ nop();
 }
 
 
 void emit_call_reloc(CodeBuffer &cbuf, const MachCallNode *n, MachOper *m, RelocationHolder const& rspec) {
   int ret_addr_offset0 = n->as_MachCall()->ret_addr_offset();
   int call_site_offset = cbuf.insts()->mark_off();
-  MacroAssembler _masm(&cbuf);
+  C2_MacroAssembler _masm(&cbuf);
   __ set_inst_mark(); // needed in emit_to_interp_stub() to locate the call
   address target = (address)m->method();
   assert(n->as_MachCall()->entry_point() == target, "sanity");
   assert(maybe_far_call(n) == !__ reachable_from_cache(target), "sanity");
   assert(cache_reachable() == __ cache_fully_reachable(), "sanity");
@@ -192,11 +192,11 @@
 
 
 //=============================================================================
 const RegMask& MachConstantBaseNode::_out_RegMask = PTR_REG_mask();
 
-int Compile::ConstantTable::calculate_table_base_offset() const {
+int ConstantTable::calculate_table_base_offset() const {
   int offset = -(size() / 2);
   // flds, fldd: 8-bit  offset multiplied by 4: +/- 1024
   // ldr, ldrb : 12-bit offset:                 +/- 4096
   if (!Assembler::is_simm10(offset)) {
     offset = Assembler::min_simm10();
@@ -209,12 +209,12 @@
   ShouldNotReachHere();
 }
 
 void MachConstantBaseNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const {
   Compile* C = ra_->C;
-  Compile::ConstantTable& constant_table = C->constant_table();
-  MacroAssembler _masm(&cbuf);
+  ConstantTable& constant_table = C->output()->constant_table();
+  C2_MacroAssembler _masm(&cbuf);
 
   Register r = as_Register(ra_->get_encode(this));
   CodeSection* consts_section = __ code()->consts();
   int consts_size = consts_section->align_at_start(consts_section->size());
   assert(constant_table.size() == consts_size, "must be: %d == %d", constant_table.size(), consts_size);
@@ -243,23 +243,23 @@
 
   for (int i = 0; i < OptoPrologueNops; i++) {
     st->print_cr("NOP"); st->print("\t");
   }
 
-  size_t framesize = C->frame_size_in_bytes();
+  size_t framesize = C->output()->frame_size_in_bytes();
   assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
-  int bangsize = C->bang_size_in_bytes();
+  int bangsize = C->output()->bang_size_in_bytes();
   // Remove two words for return addr and rbp,
   framesize -= 2*wordSize;
   bangsize -= 2*wordSize;
 
   // Calls to C2R adapters often do not accept exceptional returns.
   // We require that their callers must bang for them.  But be careful, because
   // some VM calls (such as call site linkage) can use several kilobytes of
   // stack.  But the stack safety zone should account for that.
   // See bugs 4446381, 4468289, 4497237.
-  if (C->need_stack_bang(bangsize)) {
+  if (C->output()->need_stack_bang(bangsize)) {
     st->print_cr("! stack bang (%d bytes)", bangsize); st->print("\t");
   }
   st->print_cr("PUSH   R_FP|R_LR_LR"); st->print("\t");
   if (framesize != 0) {
     st->print   ("SUB    R_SP, R_SP, " SIZE_FORMAT,framesize);
@@ -267,46 +267,46 @@
 }
 #endif
 
 void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
   Compile* C = ra_->C;
-  MacroAssembler _masm(&cbuf);
+  C2_MacroAssembler _masm(&cbuf);
 
   for (int i = 0; i < OptoPrologueNops; i++) {
     __ nop();
   }
 
-  size_t framesize = C->frame_size_in_bytes();
+  size_t framesize = C->output()->frame_size_in_bytes();
   assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
-  int bangsize = C->bang_size_in_bytes();
+  int bangsize = C->output()->bang_size_in_bytes();
   // Remove two words for return addr and fp,
   framesize -= 2*wordSize;
   bangsize -= 2*wordSize;
 
   // Calls to C2R adapters often do not accept exceptional returns.
   // We require that their callers must bang for them.  But be careful, because
   // some VM calls (such as call site linkage) can use several kilobytes of
   // stack.  But the stack safety zone should account for that.
   // See bugs 4446381, 4468289, 4497237.
-  if (C->need_stack_bang(bangsize)) {
+  if (C->output()->need_stack_bang(bangsize)) {
     __ arm_stack_overflow_check(bangsize, Rtemp);
   }
 
   __ raw_push(FP, LR);
   if (framesize != 0) {
     __ sub_slow(SP, SP, framesize);
   }
 
   // offset from scratch buffer is not valid
   if (strcmp(cbuf.name(), "Compile::Fill_buffer") == 0) {
-    C->set_frame_complete( __ offset() );
+    C->output()->set_frame_complete( __ offset() );
   }
 
   if (C->has_mach_constant_base_node()) {
     // NOTE: We set the table base offset here because users might be
     // emitted before MachConstantBaseNode.
-    Compile::ConstantTable& constant_table = C->constant_table();
+    ConstantTable& constant_table = C->output()->constant_table();
     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
   }
 }
 
 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
@@ -320,11 +320,11 @@
 //=============================================================================
 #ifndef PRODUCT
 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
   Compile* C = ra_->C;
 
-  size_t framesize = C->frame_size_in_bytes();
+  size_t framesize = C->output()->frame_size_in_bytes();
   framesize -= 2*wordSize;
 
   if (framesize != 0) {
     st->print("ADD    R_SP, R_SP, " SIZE_FORMAT "\n\t",framesize);
   }
@@ -337,14 +337,14 @@
   }
 }
 #endif
 
 void MachEpilogNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
-  MacroAssembler _masm(&cbuf);
+  C2_MacroAssembler _masm(&cbuf);
   Compile* C = ra_->C;
 
-  size_t framesize = C->frame_size_in_bytes();
+  size_t framesize = C->output()->frame_size_in_bytes();
   framesize -= 2*wordSize;
   if (framesize != 0) {
     __ add_slow(SP, SP, framesize);
   }
   __ raw_pop(FP, LR);
@@ -427,11 +427,11 @@
   // Shared code does not expect instruction set capability based bailouts here.
   // Handle offset unreachable bailout with minimal change in shared code.
   // Bailout only for real instruction emit.
   // This requires a single comment change in shared code. ( see output.cpp "Normal" instruction case )
 
-  MacroAssembler _masm(cbuf);
+  C2_MacroAssembler _masm(cbuf);
 
   // --------------------------------------
   // Check for mem-mem move.  Load into unused float registers and fall into
   // the float-store case.
   if (src_first_rc == rc_stack && dst_first_rc == rc_stack) {
@@ -788,11 +788,11 @@
   st->print("NOP \t# %d bytes pad for loops and calls", 4 * _count);
 }
 #endif
 
 void MachNopNode::emit(CodeBuffer &cbuf, PhaseRegAlloc * ) const {
-  MacroAssembler _masm(&cbuf);
+  C2_MacroAssembler _masm(&cbuf);
   for(int i = 0; i < _count; i += 1) {
     __ nop();
   }
 }
 
@@ -809,11 +809,11 @@
   st->print("ADD    %s,R_SP+#%d",Matcher::regName[reg], offset);
 }
 #endif
 
 void BoxLockNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
-  MacroAssembler _masm(&cbuf);
+  C2_MacroAssembler _masm(&cbuf);
   int offset = ra_->reg2offset(in_RegMask(0).find_first_elem());
   int reg = ra_->get_encode(this);
   Register dst = reg_to_register_object(reg);
 
   if (is_aimm(offset)) {
@@ -825,11 +825,11 @@
 }
 
 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
   // BoxLockNode is not a MachNode, so we can't just call MachNode::size(ra_)
   assert(ra_ == ra_->C->regalloc(), "sanity");
-  return ra_->C->scratch_emit_size(this);
+  return ra_->C->output()->scratch_emit_size(this);
 }
 
 //=============================================================================
 #ifndef PRODUCT
 #define R_RTEMP "R_R12"
@@ -845,11 +845,11 @@
   st->print   ("\tB.NE  SharedRuntime::handle_ic_miss_stub");
 }
 #endif
 
 void MachUEPNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
-  MacroAssembler _masm(&cbuf);
+  C2_MacroAssembler _masm(&cbuf);
   Register iCache  = reg_to_register_object(Matcher::inline_cache_reg_encode());
   assert(iCache == Ricklass, "should be");
   Register receiver = R0;
 
   __ load_klass(Rtemp, receiver);
@@ -864,11 +864,11 @@
 
 //=============================================================================
 
 // Emit exception handler code.
 int HandlerImpl::emit_exception_handler(CodeBuffer& cbuf) {
-  MacroAssembler _masm(&cbuf);
+  C2_MacroAssembler _masm(&cbuf);
 
   address base = __ start_a_stub(size_exception_handler());
   if (base == NULL) {
     ciEnv::current()->record_failure("CodeCache is full");
     return 0;  // CodeBuffer::expand failed
@@ -887,11 +887,11 @@
 }
 
 int HandlerImpl::emit_deopt_handler(CodeBuffer& cbuf) {
   // Can't use any of the current frame's registers as we may have deopted
   // at a poll and everything can be live.
-  MacroAssembler _masm(&cbuf);
+  C2_MacroAssembler _masm(&cbuf);
 
   address base = __ start_a_stub(size_deopt_handler());
   if (base == NULL) {
     ciEnv::current()->record_failure("CodeCache is full");
     return 0;  // CodeBuffer::expand failed
@@ -1278,11 +1278,11 @@
 
   enc_class save_last_PC %{
     // preserve mark
     address mark = cbuf.insts()->mark();
     debug_only(int off0 = cbuf.insts_size());
-    MacroAssembler _masm(&cbuf);
+    C2_MacroAssembler _masm(&cbuf);
     int ret_addr_offset = as_MachCall()->ret_addr_offset();
     __ adr(LR, mark + ret_addr_offset);
     __ str(LR, Address(Rthread, JavaThread::last_Java_pc_offset()));
     debug_only(int off1 = cbuf.insts_size());
     assert(off1 - off0 == 2 * Assembler::InstructionSize, "correct size prediction");
@@ -1292,27 +1292,27 @@
 
   enc_class preserve_SP %{
     // preserve mark
     address mark = cbuf.insts()->mark();
     debug_only(int off0 = cbuf.insts_size());
-    MacroAssembler _masm(&cbuf);
+    C2_MacroAssembler _masm(&cbuf);
     // FP is preserved across all calls, even compiled calls.
     // Use it to preserve SP in places where the callee might change the SP.
     __ mov(Rmh_SP_save, SP);
     debug_only(int off1 = cbuf.insts_size());
     assert(off1 - off0 == 4, "correct size prediction");
     // restore mark
     cbuf.insts()->set_mark(mark);
   %}
 
   enc_class restore_SP %{
-    MacroAssembler _masm(&cbuf);
+    C2_MacroAssembler _masm(&cbuf);
     __ mov(SP, Rmh_SP_save);
   %}
 
   enc_class Java_Dynamic_Call (method meth) %{
-    MacroAssembler _masm(&cbuf);
+    C2_MacroAssembler _masm(&cbuf);
     Register R8_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
     assert(R8_ic_reg == Ricklass, "should be");
     __ set_inst_mark();
     __ movw(R8_ic_reg, ((unsigned int)Universe::non_oop_word()) & 0xffff);
     __ movt(R8_ic_reg, ((unsigned int)Universe::non_oop_word()) >> 16);
@@ -1336,11 +1336,11 @@
       val &= (((int)1) << bit_width) - 1; // mask off sign bits
       for (int i = 0; i < count - 1; i++) {
         val |= (val << bit_width);
       }
     }
-    MacroAssembler _masm(&cbuf);
+    C2_MacroAssembler _masm(&cbuf);
 
     if (val == -1) {
       __ mvn($tmp$$Register, 0);
     } else if (val == 0) {
       __ mov($tmp$$Register, 0);
@@ -1353,11 +1353,11 @@
 
   enc_class LdReplImmF(immF src, regD dst, iRegI tmp) %{
     // Replicate float con 2 times and pack into vector (8 bytes) in regD.
     float fval = $src$$constant;
     int val = *((int*)&fval);
-    MacroAssembler _masm(&cbuf);
+    C2_MacroAssembler _masm(&cbuf);
 
     if (val == -1) {
       __ mvn($tmp$$Register, 0);
     } else if (val == 0) {
       __ mov($tmp$$Register, 0);
@@ -1368,11 +1368,11 @@
     __ fmdrr($dst$$FloatRegister, $tmp$$Register, $tmp$$Register);
   %}
 
   enc_class enc_String_Compare(R0RegP str1, R1RegP str2, R2RegI cnt1, R3RegI cnt2, iRegI result, iRegI tmp1, iRegI tmp2) %{
     Label Ldone, Lloop;
-    MacroAssembler _masm(&cbuf);
+    C2_MacroAssembler _masm(&cbuf);
 
     Register   str1_reg = $str1$$Register;
     Register   str2_reg = $str2$$Register;
     Register   cnt1_reg = $cnt1$$Register; // int
     Register   cnt2_reg = $cnt2$$Register; // int
@@ -1460,11 +1460,11 @@
     __ bind(Ldone);
   %}
 
   enc_class enc_String_Equals(R0RegP str1, R1RegP str2, R2RegI cnt, iRegI result, iRegI tmp1, iRegI tmp2) %{
     Label Lchar, Lchar_loop, Ldone, Lequal;
-    MacroAssembler _masm(&cbuf);
+    C2_MacroAssembler _masm(&cbuf);
 
     Register   str1_reg = $str1$$Register;
     Register   str2_reg = $str2$$Register;
     Register    cnt_reg = $cnt$$Register; // int
     Register   tmp1_reg = $tmp1$$Register;
@@ -1522,11 +1522,11 @@
     __ bind(Ldone);
   %}
 
   enc_class enc_Array_Equals(R0RegP ary1, R1RegP ary2, iRegI tmp1, iRegI tmp2, iRegI tmp3, iRegI result) %{
     Label Ldone, Lloop, Lequal;
-    MacroAssembler _masm(&cbuf);
+    C2_MacroAssembler _masm(&cbuf);
 
     Register   ary1_reg = $ary1$$Register;
     Register   ary2_reg = $ary2$$Register;
     Register   tmp1_reg = $tmp1$$Register;
     Register   tmp2_reg = $tmp2$$Register;

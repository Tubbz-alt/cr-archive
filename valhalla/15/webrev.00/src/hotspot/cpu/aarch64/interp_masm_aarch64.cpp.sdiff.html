<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/interp_masm_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="gc/shenandoah/shenandoahBarrierSetAssembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interp_masm_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/interp_masm_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1170   if (ProfileInterpreter) {
1171     Label profile_continue;
1172 
1173     // If no method data exists, go to profile_continue.
1174     test_method_data_pointer(mdp, profile_continue);
1175 
1176     Label skip_receiver_profile;
1177     if (receiver_can_be_null) {
1178       Label not_null;
1179       // We are making a call.  Increment the count for null receiver.
1180       increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));
1181       b(skip_receiver_profile);
1182       bind(not_null);
1183     }
1184 
1185     // Record the receiver type.
1186     record_klass_in_profile(receiver, mdp, reg2, true);
1187     bind(skip_receiver_profile);
1188 
1189     // The method data pointer needs to be updated to reflect the new target.
<span class="line-removed">1190 #if INCLUDE_JVMCI</span>
<span class="line-removed">1191     if (MethodProfileWidth == 0) {</span>
<span class="line-removed">1192       update_mdp_by_constant(mdp, in_bytes(VirtualCallData::virtual_call_data_size()));</span>
<span class="line-removed">1193     }</span>
<span class="line-removed">1194 #else // INCLUDE_JVMCI</span>
<span class="line-removed">1195     update_mdp_by_constant(mdp,</span>
<span class="line-removed">1196                            in_bytes(VirtualCallData::</span>
<span class="line-removed">1197                                     virtual_call_data_size()));</span>
<span class="line-removed">1198 #endif // INCLUDE_JVMCI</span>
<span class="line-removed">1199     bind(profile_continue);</span>
<span class="line-removed">1200   }</span>
<span class="line-removed">1201 }</span>
<span class="line-removed">1202 </span>
<span class="line-removed">1203 #if INCLUDE_JVMCI</span>
<span class="line-removed">1204 void InterpreterMacroAssembler::profile_called_method(Register method, Register mdp, Register reg2) {</span>
<span class="line-removed">1205   assert_different_registers(method, mdp, reg2);</span>
<span class="line-removed">1206   if (ProfileInterpreter &amp;&amp; MethodProfileWidth &gt; 0) {</span>
<span class="line-removed">1207     Label profile_continue;</span>
<span class="line-removed">1208 </span>
<span class="line-removed">1209     // If no method data exists, go to profile_continue.</span>
<span class="line-removed">1210     test_method_data_pointer(mdp, profile_continue);</span>
<span class="line-removed">1211 </span>
<span class="line-removed">1212     Label done;</span>
<span class="line-removed">1213     record_item_in_profile_helper(method, mdp, reg2, 0, done, MethodProfileWidth,</span>
<span class="line-removed">1214       &amp;VirtualCallData::method_offset, &amp;VirtualCallData::method_count_offset, in_bytes(VirtualCallData::nonprofiled_receiver_count_offset()));</span>
<span class="line-removed">1215     bind(done);</span>
<span class="line-removed">1216 </span>
1217     update_mdp_by_constant(mdp, in_bytes(VirtualCallData::virtual_call_data_size()));
1218     bind(profile_continue);
1219   }
1220 }
<span class="line-removed">1221 #endif // INCLUDE_JVMCI</span>
1222 
1223 // This routine creates a state machine for updating the multi-row
1224 // type profile at a virtual call site (or other type-sensitive bytecode).
1225 // The machine visits each row (of receiver/count) until the receiver type
1226 // is found, or until it runs out of rows.  At the same time, it remembers
1227 // the location of the first empty row.  (An empty row records null for its
1228 // receiver, and can be allocated for a newly-observed receiver type.)
1229 // Because there are two degrees of freedom in the state, a simple linear
1230 // search will not work; it must be a decision tree.  Hence this helper
1231 // function is recursive, to generate the required tree structured code.
1232 // It&#39;s the interpreter, so we are trading off code space for speed.
1233 // See below for example code.
1234 void InterpreterMacroAssembler::record_klass_in_profile_helper(
1235                                         Register receiver, Register mdp,
1236                                         Register reg2, int start_row,
1237                                         Label&amp; done, bool is_virtual_call) {
1238   if (TypeProfileWidth == 0) {
1239     if (is_virtual_call) {
1240       increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));
1241     }
</pre>
</td>
<td>
<hr />
<pre>
1170   if (ProfileInterpreter) {
1171     Label profile_continue;
1172 
1173     // If no method data exists, go to profile_continue.
1174     test_method_data_pointer(mdp, profile_continue);
1175 
1176     Label skip_receiver_profile;
1177     if (receiver_can_be_null) {
1178       Label not_null;
1179       // We are making a call.  Increment the count for null receiver.
1180       increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));
1181       b(skip_receiver_profile);
1182       bind(not_null);
1183     }
1184 
1185     // Record the receiver type.
1186     record_klass_in_profile(receiver, mdp, reg2, true);
1187     bind(skip_receiver_profile);
1188 
1189     // The method data pointer needs to be updated to reflect the new target.



























1190     update_mdp_by_constant(mdp, in_bytes(VirtualCallData::virtual_call_data_size()));
1191     bind(profile_continue);
1192   }
1193 }

1194 
1195 // This routine creates a state machine for updating the multi-row
1196 // type profile at a virtual call site (or other type-sensitive bytecode).
1197 // The machine visits each row (of receiver/count) until the receiver type
1198 // is found, or until it runs out of rows.  At the same time, it remembers
1199 // the location of the first empty row.  (An empty row records null for its
1200 // receiver, and can be allocated for a newly-observed receiver type.)
1201 // Because there are two degrees of freedom in the state, a simple linear
1202 // search will not work; it must be a decision tree.  Hence this helper
1203 // function is recursive, to generate the required tree structured code.
1204 // It&#39;s the interpreter, so we are trading off code space for speed.
1205 // See below for example code.
1206 void InterpreterMacroAssembler::record_klass_in_profile_helper(
1207                                         Register receiver, Register mdp,
1208                                         Register reg2, int start_row,
1209                                         Label&amp; done, bool is_virtual_call) {
1210   if (TypeProfileWidth == 0) {
1211     if (is_virtual_call) {
1212       increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));
1213     }
</pre>
</td>
</tr>
</table>
<center><a href="gc/shenandoah/shenandoahBarrierSetAssembler_aarch64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="interp_masm_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;memory/universe.hpp&quot;
  40 #include &quot;nativeInst_aarch64.hpp&quot;
  41 #include &quot;oops/accessDecorators.hpp&quot;
  42 #include &quot;oops/compressedOops.inline.hpp&quot;
  43 #include &quot;oops/klass.inline.hpp&quot;
  44 #include &quot;runtime/biasedLocking.hpp&quot;
  45 #include &quot;runtime/icache.hpp&quot;
  46 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  47 #include &quot;runtime/jniHandles.inline.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 #include &quot;runtime/signature_cc.hpp&quot;
  50 #include &quot;runtime/thread.hpp&quot;
  51 #include &quot;utilities/powerOfTwo.hpp&quot;
  52 #ifdef COMPILER1
  53 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  54 #endif
  55 #ifdef COMPILER2
  56 #include &quot;oops/oop.hpp&quot;
  57 #include &quot;opto/compile.hpp&quot;
<span class="line-removed">  58 #include &quot;opto/intrinsicnode.hpp&quot;</span>
  59 #include &quot;opto/node.hpp&quot;

  60 #endif
  61 
  62 #ifdef PRODUCT
  63 #define BLOCK_COMMENT(str) /* nothing */
  64 #define STOP(error) stop(error)
  65 #else
  66 #define BLOCK_COMMENT(str) block_comment(str)
  67 #define STOP(error) block_comment(error); stop(error)
  68 #endif
  69 
  70 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  71 
  72 // Patch any kind of instruction; there may be several instructions.
  73 // Return the total length (in bytes) of the instructions.
  74 int MacroAssembler::pd_patch_instruction_size(address branch, address target) {
  75   int instructions = 1;
  76   assert((uint64_t)target &lt; (1ul &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);
  77   long offset = (target - branch) &gt;&gt; 2;
  78   unsigned insn = *(unsigned*)branch;
  79   if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b111011) == 0b011000) {
</pre>
<hr />
<pre>
 729 
 730 // Maybe emit a call via a trampoline.  If the code cache is small
 731 // trampolines won&#39;t be emitted.
 732 
 733 address MacroAssembler::trampoline_call(Address entry, CodeBuffer *cbuf) {
 734   assert(JavaThread::current()-&gt;is_Compiler_thread(), &quot;just checking&quot;);
 735   assert(entry.rspec().type() == relocInfo::runtime_call_type
 736          || entry.rspec().type() == relocInfo::opt_virtual_call_type
 737          || entry.rspec().type() == relocInfo::static_call_type
 738          || entry.rspec().type() == relocInfo::virtual_call_type, &quot;wrong reloc type&quot;);
 739 
 740   // We need a trampoline if branches are far.
 741   if (far_branches()) {
 742     bool in_scratch_emit_size = false;
 743 #ifdef COMPILER2
 744     // We don&#39;t want to emit a trampoline if C2 is generating dummy
 745     // code during its branch shortening phase.
 746     CompileTask* task = ciEnv::current()-&gt;task();
 747     in_scratch_emit_size =
 748       (task != NULL &amp;&amp; is_c2_compile(task-&gt;comp_level()) &amp;&amp;
<span class="line-modified"> 749        Compile::current()-&gt;in_scratch_emit_size());</span>
 750 #endif
 751     if (!in_scratch_emit_size) {
 752       address stub = emit_trampoline_stub(offset(), entry.target());
 753       if (stub == NULL) {
 754         return NULL; // CodeCache is full
 755       }
 756     }
 757   }
 758 
 759   if (cbuf) cbuf-&gt;set_insts_mark();
 760   relocate(entry.rspec());
 761   if (!far_branches()) {
 762     bl(entry.target());
 763   } else {
 764     bl(pc());
 765   }
 766   // just need to return a non-null address
 767   return pc();
 768 }
 769 
</pre>
<hr />
<pre>
4461     }
4462   }
4463 }
4464 
4465 void MacroAssembler::remove_frame(int framesize) {
4466   assert(framesize &gt; 0, &quot;framesize must be &gt; 0&quot;);
4467   if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
4468     ldp(rfp, lr, Address(sp, framesize - 2 * wordSize));
4469     add(sp, sp, framesize);
4470   } else {
4471     if (framesize &lt; ((1 &lt;&lt; 12) + 2 * wordSize))
4472       add(sp, sp, framesize - 2 * wordSize);
4473     else {
4474       mov(rscratch1, framesize - 2 * wordSize);
4475       add(sp, sp, rscratch1);
4476     }
4477     ldp(rfp, lr, Address(post(sp, 2 * wordSize)));
4478   }
4479 }
4480 
<span class="line-removed">4481 #ifdef COMPILER2</span>
<span class="line-removed">4482 typedef void (MacroAssembler::* chr_insn)(Register Rt, const Address &amp;adr);</span>
<span class="line-removed">4483 </span>
<span class="line-removed">4484 // Search for str1 in str2 and return index or -1</span>
<span class="line-removed">4485 void MacroAssembler::string_indexof(Register str2, Register str1,</span>
<span class="line-removed">4486                                     Register cnt2, Register cnt1,</span>
<span class="line-removed">4487                                     Register tmp1, Register tmp2,</span>
<span class="line-removed">4488                                     Register tmp3, Register tmp4,</span>
<span class="line-removed">4489                                     Register tmp5, Register tmp6,</span>
<span class="line-removed">4490                                     int icnt1, Register result, int ae) {</span>
<span class="line-removed">4491   // NOTE: tmp5, tmp6 can be zr depending on specific method version</span>
<span class="line-removed">4492   Label LINEARSEARCH, LINEARSTUB, LINEAR_MEDIUM, DONE, NOMATCH, MATCH;</span>
<span class="line-removed">4493 </span>
<span class="line-removed">4494   Register ch1 = rscratch1;</span>
<span class="line-removed">4495   Register ch2 = rscratch2;</span>
<span class="line-removed">4496   Register cnt1tmp = tmp1;</span>
<span class="line-removed">4497   Register cnt2tmp = tmp2;</span>
<span class="line-removed">4498   Register cnt1_neg = cnt1;</span>
<span class="line-removed">4499   Register cnt2_neg = cnt2;</span>
<span class="line-removed">4500   Register result_tmp = tmp4;</span>
<span class="line-removed">4501 </span>
<span class="line-removed">4502   bool isL = ae == StrIntrinsicNode::LL;</span>
<span class="line-removed">4503 </span>
<span class="line-removed">4504   bool str1_isL = ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UL;</span>
<span class="line-removed">4505   bool str2_isL = ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::LU;</span>
<span class="line-removed">4506   int str1_chr_shift = str1_isL ? 0:1;</span>
<span class="line-removed">4507   int str2_chr_shift = str2_isL ? 0:1;</span>
<span class="line-removed">4508   int str1_chr_size = str1_isL ? 1:2;</span>
<span class="line-removed">4509   int str2_chr_size = str2_isL ? 1:2;</span>
<span class="line-removed">4510   chr_insn str1_load_1chr = str1_isL ? (chr_insn)&amp;MacroAssembler::ldrb :</span>
<span class="line-removed">4511                                       (chr_insn)&amp;MacroAssembler::ldrh;</span>
<span class="line-removed">4512   chr_insn str2_load_1chr = str2_isL ? (chr_insn)&amp;MacroAssembler::ldrb :</span>
<span class="line-removed">4513                                       (chr_insn)&amp;MacroAssembler::ldrh;</span>
<span class="line-removed">4514   chr_insn load_2chr = isL ? (chr_insn)&amp;MacroAssembler::ldrh : (chr_insn)&amp;MacroAssembler::ldrw;</span>
<span class="line-removed">4515   chr_insn load_4chr = isL ? (chr_insn)&amp;MacroAssembler::ldrw : (chr_insn)&amp;MacroAssembler::ldr;</span>
<span class="line-removed">4516 </span>
<span class="line-removed">4517   // Note, inline_string_indexOf() generates checks:</span>
<span class="line-removed">4518   // if (substr.count &gt; string.count) return -1;</span>
<span class="line-removed">4519   // if (substr.count == 0) return 0;</span>
<span class="line-removed">4520 </span>
<span class="line-removed">4521   // We have two strings, a source string in str2, cnt2 and a pattern string</span>
<span class="line-removed">4522   // in str1, cnt1. Find the 1st occurence of pattern in source or return -1.</span>
<span class="line-removed">4523 </span>
<span class="line-removed">4524   // For larger pattern and source we use a simplified Boyer Moore algorithm.</span>
<span class="line-removed">4525   // With a small pattern and source we use linear scan.</span>
<span class="line-removed">4526 </span>
<span class="line-removed">4527   if (icnt1 == -1) {</span>
<span class="line-removed">4528     sub(result_tmp, cnt2, cnt1);</span>
<span class="line-removed">4529     cmp(cnt1, (u1)8);             // Use Linear Scan if cnt1 &lt; 8 || cnt1 &gt;= 256</span>
<span class="line-removed">4530     br(LT, LINEARSEARCH);</span>
<span class="line-removed">4531     dup(v0, T16B, cnt1); // done in separate FPU pipeline. Almost no penalty</span>
<span class="line-removed">4532     subs(zr, cnt1, 256);</span>
<span class="line-removed">4533     lsr(tmp1, cnt2, 2);</span>
<span class="line-removed">4534     ccmp(cnt1, tmp1, 0b0000, LT); // Source must be 4 * pattern for BM</span>
<span class="line-removed">4535     br(GE, LINEARSTUB);</span>
<span class="line-removed">4536   }</span>
<span class="line-removed">4537 </span>
<span class="line-removed">4538 // The Boyer Moore alogorithm is based on the description here:-</span>
<span class="line-removed">4539 //</span>
<span class="line-removed">4540 // http://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm</span>
<span class="line-removed">4541 //</span>
<span class="line-removed">4542 // This describes and algorithm with 2 shift rules. The &#39;Bad Character&#39; rule</span>
<span class="line-removed">4543 // and the &#39;Good Suffix&#39; rule.</span>
<span class="line-removed">4544 //</span>
<span class="line-removed">4545 // These rules are essentially heuristics for how far we can shift the</span>
<span class="line-removed">4546 // pattern along the search string.</span>
<span class="line-removed">4547 //</span>
<span class="line-removed">4548 // The implementation here uses the &#39;Bad Character&#39; rule only because of the</span>
<span class="line-removed">4549 // complexity of initialisation for the &#39;Good Suffix&#39; rule.</span>
<span class="line-removed">4550 //</span>
<span class="line-removed">4551 // This is also known as the Boyer-Moore-Horspool algorithm:-</span>
<span class="line-removed">4552 //</span>
<span class="line-removed">4553 // http://en.wikipedia.org/wiki/Boyer-Moore-Horspool_algorithm</span>
<span class="line-removed">4554 //</span>
<span class="line-removed">4555 // This particular implementation has few java-specific optimizations.</span>
<span class="line-removed">4556 //</span>
<span class="line-removed">4557 // #define ASIZE 256</span>
<span class="line-removed">4558 //</span>
<span class="line-removed">4559 //    int bm(unsigned char *x, int m, unsigned char *y, int n) {</span>
<span class="line-removed">4560 //       int i, j;</span>
<span class="line-removed">4561 //       unsigned c;</span>
<span class="line-removed">4562 //       unsigned char bc[ASIZE];</span>
<span class="line-removed">4563 //</span>
<span class="line-removed">4564 //       /* Preprocessing */</span>
<span class="line-removed">4565 //       for (i = 0; i &lt; ASIZE; ++i)</span>
<span class="line-removed">4566 //          bc[i] = m;</span>
<span class="line-removed">4567 //       for (i = 0; i &lt; m - 1; ) {</span>
<span class="line-removed">4568 //          c = x[i];</span>
<span class="line-removed">4569 //          ++i;</span>
<span class="line-removed">4570 //          // c &lt; 256 for Latin1 string, so, no need for branch</span>
<span class="line-removed">4571 //          #ifdef PATTERN_STRING_IS_LATIN1</span>
<span class="line-removed">4572 //          bc[c] = m - i;</span>
<span class="line-removed">4573 //          #else</span>
<span class="line-removed">4574 //          if (c &lt; ASIZE) bc[c] = m - i;</span>
<span class="line-removed">4575 //          #endif</span>
<span class="line-removed">4576 //       }</span>
<span class="line-removed">4577 //</span>
<span class="line-removed">4578 //       /* Searching */</span>
<span class="line-removed">4579 //       j = 0;</span>
<span class="line-removed">4580 //       while (j &lt;= n - m) {</span>
<span class="line-removed">4581 //          c = y[i+j];</span>
<span class="line-removed">4582 //          if (x[m-1] == c)</span>
<span class="line-removed">4583 //            for (i = m - 2; i &gt;= 0 &amp;&amp; x[i] == y[i + j]; --i);</span>
<span class="line-removed">4584 //          if (i &lt; 0) return j;</span>
<span class="line-removed">4585 //          // c &lt; 256 for Latin1 string, so, no need for branch</span>
<span class="line-removed">4586 //          #ifdef SOURCE_STRING_IS_LATIN1</span>
<span class="line-removed">4587 //          // LL case: (c&lt; 256) always true. Remove branch</span>
<span class="line-removed">4588 //          j += bc[y[j+m-1]];</span>
<span class="line-removed">4589 //          #endif</span>
<span class="line-removed">4590 //          #ifndef PATTERN_STRING_IS_UTF</span>
<span class="line-removed">4591 //          // UU case: need if (c&lt;ASIZE) check. Skip 1 character if not.</span>
<span class="line-removed">4592 //          if (c &lt; ASIZE)</span>
<span class="line-removed">4593 //            j += bc[y[j+m-1]];</span>
<span class="line-removed">4594 //          else</span>
<span class="line-removed">4595 //            j += 1</span>
<span class="line-removed">4596 //          #endif</span>
<span class="line-removed">4597 //          #ifdef PATTERN_IS_LATIN1_AND_SOURCE_IS_UTF</span>
<span class="line-removed">4598 //          // UL case: need if (c&lt;ASIZE) check. Skip &lt;pattern length&gt; if not.</span>
<span class="line-removed">4599 //          if (c &lt; ASIZE)</span>
<span class="line-removed">4600 //            j += bc[y[j+m-1]];</span>
<span class="line-removed">4601 //          else</span>
<span class="line-removed">4602 //            j += m</span>
<span class="line-removed">4603 //          #endif</span>
<span class="line-removed">4604 //       }</span>
<span class="line-removed">4605 //    }</span>
<span class="line-removed">4606 </span>
<span class="line-removed">4607   if (icnt1 == -1) {</span>
<span class="line-removed">4608     Label BCLOOP, BCSKIP, BMLOOPSTR2, BMLOOPSTR1, BMSKIP, BMADV, BMMATCH,</span>
<span class="line-removed">4609         BMLOOPSTR1_LASTCMP, BMLOOPSTR1_CMP, BMLOOPSTR1_AFTER_LOAD, BM_INIT_LOOP;</span>
<span class="line-removed">4610     Register cnt1end = tmp2;</span>
<span class="line-removed">4611     Register str2end = cnt2;</span>
<span class="line-removed">4612     Register skipch = tmp2;</span>
<span class="line-removed">4613 </span>
<span class="line-removed">4614     // str1 length is &gt;=8, so, we can read at least 1 register for cases when</span>
<span class="line-removed">4615     // UTF-&gt;Latin1 conversion is not needed(8 LL or 4UU) and half register for</span>
<span class="line-removed">4616     // UL case. We&#39;ll re-read last character in inner pre-loop code to have</span>
<span class="line-removed">4617     // single outer pre-loop load</span>
<span class="line-removed">4618     const int firstStep = isL ? 7 : 3;</span>
<span class="line-removed">4619 </span>
<span class="line-removed">4620     const int ASIZE = 256;</span>
<span class="line-removed">4621     const int STORED_BYTES = 32; // amount of bytes stored per instruction</span>
<span class="line-removed">4622     sub(sp, sp, ASIZE);</span>
<span class="line-removed">4623     mov(tmp5, ASIZE/STORED_BYTES); // loop iterations</span>
<span class="line-removed">4624     mov(ch1, sp);</span>
<span class="line-removed">4625     BIND(BM_INIT_LOOP);</span>
<span class="line-removed">4626       stpq(v0, v0, Address(post(ch1, STORED_BYTES)));</span>
<span class="line-removed">4627       subs(tmp5, tmp5, 1);</span>
<span class="line-removed">4628       br(GT, BM_INIT_LOOP);</span>
<span class="line-removed">4629 </span>
<span class="line-removed">4630       sub(cnt1tmp, cnt1, 1);</span>
<span class="line-removed">4631       mov(tmp5, str2);</span>
<span class="line-removed">4632       add(str2end, str2, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">4633       sub(ch2, cnt1, 1);</span>
<span class="line-removed">4634       mov(tmp3, str1);</span>
<span class="line-removed">4635     BIND(BCLOOP);</span>
<span class="line-removed">4636       (this-&gt;*str1_load_1chr)(ch1, Address(post(tmp3, str1_chr_size)));</span>
<span class="line-removed">4637       if (!str1_isL) {</span>
<span class="line-removed">4638         subs(zr, ch1, ASIZE);</span>
<span class="line-removed">4639         br(HS, BCSKIP);</span>
<span class="line-removed">4640       }</span>
<span class="line-removed">4641       strb(ch2, Address(sp, ch1));</span>
<span class="line-removed">4642     BIND(BCSKIP);</span>
<span class="line-removed">4643       subs(ch2, ch2, 1);</span>
<span class="line-removed">4644       br(GT, BCLOOP);</span>
<span class="line-removed">4645 </span>
<span class="line-removed">4646       add(tmp6, str1, cnt1, LSL, str1_chr_shift); // address after str1</span>
<span class="line-removed">4647       if (str1_isL == str2_isL) {</span>
<span class="line-removed">4648         // load last 8 bytes (8LL/4UU symbols)</span>
<span class="line-removed">4649         ldr(tmp6, Address(tmp6, -wordSize));</span>
<span class="line-removed">4650       } else {</span>
<span class="line-removed">4651         ldrw(tmp6, Address(tmp6, -wordSize/2)); // load last 4 bytes(4 symbols)</span>
<span class="line-removed">4652         // convert Latin1 to UTF. We&#39;ll have to wait until load completed, but</span>
<span class="line-removed">4653         // it&#39;s still faster than per-character loads+checks</span>
<span class="line-removed">4654         lsr(tmp3, tmp6, BitsPerByte * (wordSize/2 - str1_chr_size)); // str1[N-1]</span>
<span class="line-removed">4655         ubfx(ch1, tmp6, 8, 8); // str1[N-2]</span>
<span class="line-removed">4656         ubfx(ch2, tmp6, 16, 8); // str1[N-3]</span>
<span class="line-removed">4657         andr(tmp6, tmp6, 0xFF); // str1[N-4]</span>
<span class="line-removed">4658         orr(ch2, ch1, ch2, LSL, 16);</span>
<span class="line-removed">4659         orr(tmp6, tmp6, tmp3, LSL, 48);</span>
<span class="line-removed">4660         orr(tmp6, tmp6, ch2, LSL, 16);</span>
<span class="line-removed">4661       }</span>
<span class="line-removed">4662     BIND(BMLOOPSTR2);</span>
<span class="line-removed">4663       (this-&gt;*str2_load_1chr)(skipch, Address(str2, cnt1tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">4664       sub(cnt1tmp, cnt1tmp, firstStep); // cnt1tmp is positive here, because cnt1 &gt;= 8</span>
<span class="line-removed">4665       if (str1_isL == str2_isL) {</span>
<span class="line-removed">4666         // re-init tmp3. It&#39;s for free because it&#39;s executed in parallel with</span>
<span class="line-removed">4667         // load above. Alternative is to initialize it before loop, but it&#39;ll</span>
<span class="line-removed">4668         // affect performance on in-order systems with 2 or more ld/st pipelines</span>
<span class="line-removed">4669         lsr(tmp3, tmp6, BitsPerByte * (wordSize - str1_chr_size));</span>
<span class="line-removed">4670       }</span>
<span class="line-removed">4671       if (!isL) { // UU/UL case</span>
<span class="line-removed">4672         lsl(ch2, cnt1tmp, 1); // offset in bytes</span>
<span class="line-removed">4673       }</span>
<span class="line-removed">4674       cmp(tmp3, skipch);</span>
<span class="line-removed">4675       br(NE, BMSKIP);</span>
<span class="line-removed">4676       ldr(ch2, Address(str2, isL ? cnt1tmp : ch2));</span>
<span class="line-removed">4677       mov(ch1, tmp6);</span>
<span class="line-removed">4678       if (isL) {</span>
<span class="line-removed">4679         b(BMLOOPSTR1_AFTER_LOAD);</span>
<span class="line-removed">4680       } else {</span>
<span class="line-removed">4681         sub(cnt1tmp, cnt1tmp, 1); // no need to branch for UU/UL case. cnt1 &gt;= 8</span>
<span class="line-removed">4682         b(BMLOOPSTR1_CMP);</span>
<span class="line-removed">4683       }</span>
<span class="line-removed">4684     BIND(BMLOOPSTR1);</span>
<span class="line-removed">4685       (this-&gt;*str1_load_1chr)(ch1, Address(str1, cnt1tmp, Address::lsl(str1_chr_shift)));</span>
<span class="line-removed">4686       (this-&gt;*str2_load_1chr)(ch2, Address(str2, cnt1tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">4687     BIND(BMLOOPSTR1_AFTER_LOAD);</span>
<span class="line-removed">4688       subs(cnt1tmp, cnt1tmp, 1);</span>
<span class="line-removed">4689       br(LT, BMLOOPSTR1_LASTCMP);</span>
<span class="line-removed">4690     BIND(BMLOOPSTR1_CMP);</span>
<span class="line-removed">4691       cmp(ch1, ch2);</span>
<span class="line-removed">4692       br(EQ, BMLOOPSTR1);</span>
<span class="line-removed">4693     BIND(BMSKIP);</span>
<span class="line-removed">4694       if (!isL) {</span>
<span class="line-removed">4695         // if we&#39;ve met UTF symbol while searching Latin1 pattern, then we can</span>
<span class="line-removed">4696         // skip cnt1 symbols</span>
<span class="line-removed">4697         if (str1_isL != str2_isL) {</span>
<span class="line-removed">4698           mov(result_tmp, cnt1);</span>
<span class="line-removed">4699         } else {</span>
<span class="line-removed">4700           mov(result_tmp, 1);</span>
<span class="line-removed">4701         }</span>
<span class="line-removed">4702         subs(zr, skipch, ASIZE);</span>
<span class="line-removed">4703         br(HS, BMADV);</span>
<span class="line-removed">4704       }</span>
<span class="line-removed">4705       ldrb(result_tmp, Address(sp, skipch)); // load skip distance</span>
<span class="line-removed">4706     BIND(BMADV);</span>
<span class="line-removed">4707       sub(cnt1tmp, cnt1, 1);</span>
<span class="line-removed">4708       add(str2, str2, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">4709       cmp(str2, str2end);</span>
<span class="line-removed">4710       br(LE, BMLOOPSTR2);</span>
<span class="line-removed">4711       add(sp, sp, ASIZE);</span>
<span class="line-removed">4712       b(NOMATCH);</span>
<span class="line-removed">4713     BIND(BMLOOPSTR1_LASTCMP);</span>
<span class="line-removed">4714       cmp(ch1, ch2);</span>
<span class="line-removed">4715       br(NE, BMSKIP);</span>
<span class="line-removed">4716     BIND(BMMATCH);</span>
<span class="line-removed">4717       sub(result, str2, tmp5);</span>
<span class="line-removed">4718       if (!str2_isL) lsr(result, result, 1);</span>
<span class="line-removed">4719       add(sp, sp, ASIZE);</span>
<span class="line-removed">4720       b(DONE);</span>
<span class="line-removed">4721 </span>
<span class="line-removed">4722     BIND(LINEARSTUB);</span>
<span class="line-removed">4723     cmp(cnt1, (u1)16); // small patterns still should be handled by simple algorithm</span>
<span class="line-removed">4724     br(LT, LINEAR_MEDIUM);</span>
<span class="line-removed">4725     mov(result, zr);</span>
<span class="line-removed">4726     RuntimeAddress stub = NULL;</span>
<span class="line-removed">4727     if (isL) {</span>
<span class="line-removed">4728       stub = RuntimeAddress(StubRoutines::aarch64::string_indexof_linear_ll());</span>
<span class="line-removed">4729       assert(stub.target() != NULL, &quot;string_indexof_linear_ll stub has not been generated&quot;);</span>
<span class="line-removed">4730     } else if (str1_isL) {</span>
<span class="line-removed">4731       stub = RuntimeAddress(StubRoutines::aarch64::string_indexof_linear_ul());</span>
<span class="line-removed">4732        assert(stub.target() != NULL, &quot;string_indexof_linear_ul stub has not been generated&quot;);</span>
<span class="line-removed">4733     } else {</span>
<span class="line-removed">4734       stub = RuntimeAddress(StubRoutines::aarch64::string_indexof_linear_uu());</span>
<span class="line-removed">4735       assert(stub.target() != NULL, &quot;string_indexof_linear_uu stub has not been generated&quot;);</span>
<span class="line-removed">4736     }</span>
<span class="line-removed">4737     trampoline_call(stub);</span>
<span class="line-removed">4738     b(DONE);</span>
<span class="line-removed">4739   }</span>
<span class="line-removed">4740 </span>
<span class="line-removed">4741   BIND(LINEARSEARCH);</span>
<span class="line-removed">4742   {</span>
<span class="line-removed">4743     Label DO1, DO2, DO3;</span>
<span class="line-removed">4744 </span>
<span class="line-removed">4745     Register str2tmp = tmp2;</span>
<span class="line-removed">4746     Register first = tmp3;</span>
<span class="line-removed">4747 </span>
<span class="line-removed">4748     if (icnt1 == -1)</span>
<span class="line-removed">4749     {</span>
<span class="line-removed">4750         Label DOSHORT, FIRST_LOOP, STR2_NEXT, STR1_LOOP, STR1_NEXT;</span>
<span class="line-removed">4751 </span>
<span class="line-removed">4752         cmp(cnt1, u1(str1_isL == str2_isL ? 4 : 2));</span>
<span class="line-removed">4753         br(LT, DOSHORT);</span>
<span class="line-removed">4754       BIND(LINEAR_MEDIUM);</span>
<span class="line-removed">4755         (this-&gt;*str1_load_1chr)(first, Address(str1));</span>
<span class="line-removed">4756         lea(str1, Address(str1, cnt1, Address::lsl(str1_chr_shift)));</span>
<span class="line-removed">4757         sub(cnt1_neg, zr, cnt1, LSL, str1_chr_shift);</span>
<span class="line-removed">4758         lea(str2, Address(str2, result_tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">4759         sub(cnt2_neg, zr, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">4760 </span>
<span class="line-removed">4761       BIND(FIRST_LOOP);</span>
<span class="line-removed">4762         (this-&gt;*str2_load_1chr)(ch2, Address(str2, cnt2_neg));</span>
<span class="line-removed">4763         cmp(first, ch2);</span>
<span class="line-removed">4764         br(EQ, STR1_LOOP);</span>
<span class="line-removed">4765       BIND(STR2_NEXT);</span>
<span class="line-removed">4766         adds(cnt2_neg, cnt2_neg, str2_chr_size);</span>
<span class="line-removed">4767         br(LE, FIRST_LOOP);</span>
<span class="line-removed">4768         b(NOMATCH);</span>
<span class="line-removed">4769 </span>
<span class="line-removed">4770       BIND(STR1_LOOP);</span>
<span class="line-removed">4771         adds(cnt1tmp, cnt1_neg, str1_chr_size);</span>
<span class="line-removed">4772         add(cnt2tmp, cnt2_neg, str2_chr_size);</span>
<span class="line-removed">4773         br(GE, MATCH);</span>
<span class="line-removed">4774 </span>
<span class="line-removed">4775       BIND(STR1_NEXT);</span>
<span class="line-removed">4776         (this-&gt;*str1_load_1chr)(ch1, Address(str1, cnt1tmp));</span>
<span class="line-removed">4777         (this-&gt;*str2_load_1chr)(ch2, Address(str2, cnt2tmp));</span>
<span class="line-removed">4778         cmp(ch1, ch2);</span>
<span class="line-removed">4779         br(NE, STR2_NEXT);</span>
<span class="line-removed">4780         adds(cnt1tmp, cnt1tmp, str1_chr_size);</span>
<span class="line-removed">4781         add(cnt2tmp, cnt2tmp, str2_chr_size);</span>
<span class="line-removed">4782         br(LT, STR1_NEXT);</span>
<span class="line-removed">4783         b(MATCH);</span>
<span class="line-removed">4784 </span>
<span class="line-removed">4785       BIND(DOSHORT);</span>
<span class="line-removed">4786       if (str1_isL == str2_isL) {</span>
<span class="line-removed">4787         cmp(cnt1, (u1)2);</span>
<span class="line-removed">4788         br(LT, DO1);</span>
<span class="line-removed">4789         br(GT, DO3);</span>
<span class="line-removed">4790       }</span>
<span class="line-removed">4791     }</span>
<span class="line-removed">4792 </span>
<span class="line-removed">4793     if (icnt1 == 4) {</span>
<span class="line-removed">4794       Label CH1_LOOP;</span>
<span class="line-removed">4795 </span>
<span class="line-removed">4796         (this-&gt;*load_4chr)(ch1, str1);</span>
<span class="line-removed">4797         sub(result_tmp, cnt2, 4);</span>
<span class="line-removed">4798         lea(str2, Address(str2, result_tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">4799         sub(cnt2_neg, zr, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">4800 </span>
<span class="line-removed">4801       BIND(CH1_LOOP);</span>
<span class="line-removed">4802         (this-&gt;*load_4chr)(ch2, Address(str2, cnt2_neg));</span>
<span class="line-removed">4803         cmp(ch1, ch2);</span>
<span class="line-removed">4804         br(EQ, MATCH);</span>
<span class="line-removed">4805         adds(cnt2_neg, cnt2_neg, str2_chr_size);</span>
<span class="line-removed">4806         br(LE, CH1_LOOP);</span>
<span class="line-removed">4807         b(NOMATCH);</span>
<span class="line-removed">4808       }</span>
<span class="line-removed">4809 </span>
<span class="line-removed">4810     if ((icnt1 == -1 &amp;&amp; str1_isL == str2_isL) || icnt1 == 2) {</span>
<span class="line-removed">4811       Label CH1_LOOP;</span>
<span class="line-removed">4812 </span>
<span class="line-removed">4813       BIND(DO2);</span>
<span class="line-removed">4814         (this-&gt;*load_2chr)(ch1, str1);</span>
<span class="line-removed">4815         if (icnt1 == 2) {</span>
<span class="line-removed">4816           sub(result_tmp, cnt2, 2);</span>
<span class="line-removed">4817         }</span>
<span class="line-removed">4818         lea(str2, Address(str2, result_tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">4819         sub(cnt2_neg, zr, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">4820       BIND(CH1_LOOP);</span>
<span class="line-removed">4821         (this-&gt;*load_2chr)(ch2, Address(str2, cnt2_neg));</span>
<span class="line-removed">4822         cmp(ch1, ch2);</span>
<span class="line-removed">4823         br(EQ, MATCH);</span>
<span class="line-removed">4824         adds(cnt2_neg, cnt2_neg, str2_chr_size);</span>
<span class="line-removed">4825         br(LE, CH1_LOOP);</span>
<span class="line-removed">4826         b(NOMATCH);</span>
<span class="line-removed">4827     }</span>
<span class="line-removed">4828 </span>
<span class="line-removed">4829     if ((icnt1 == -1 &amp;&amp; str1_isL == str2_isL) || icnt1 == 3) {</span>
<span class="line-removed">4830       Label FIRST_LOOP, STR2_NEXT, STR1_LOOP;</span>
<span class="line-removed">4831 </span>
<span class="line-removed">4832       BIND(DO3);</span>
<span class="line-removed">4833         (this-&gt;*load_2chr)(first, str1);</span>
<span class="line-removed">4834         (this-&gt;*str1_load_1chr)(ch1, Address(str1, 2*str1_chr_size));</span>
<span class="line-removed">4835         if (icnt1 == 3) {</span>
<span class="line-removed">4836           sub(result_tmp, cnt2, 3);</span>
<span class="line-removed">4837         }</span>
<span class="line-removed">4838         lea(str2, Address(str2, result_tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">4839         sub(cnt2_neg, zr, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">4840       BIND(FIRST_LOOP);</span>
<span class="line-removed">4841         (this-&gt;*load_2chr)(ch2, Address(str2, cnt2_neg));</span>
<span class="line-removed">4842         cmpw(first, ch2);</span>
<span class="line-removed">4843         br(EQ, STR1_LOOP);</span>
<span class="line-removed">4844       BIND(STR2_NEXT);</span>
<span class="line-removed">4845         adds(cnt2_neg, cnt2_neg, str2_chr_size);</span>
<span class="line-removed">4846         br(LE, FIRST_LOOP);</span>
<span class="line-removed">4847         b(NOMATCH);</span>
<span class="line-removed">4848 </span>
<span class="line-removed">4849       BIND(STR1_LOOP);</span>
<span class="line-removed">4850         add(cnt2tmp, cnt2_neg, 2*str2_chr_size);</span>
<span class="line-removed">4851         (this-&gt;*str2_load_1chr)(ch2, Address(str2, cnt2tmp));</span>
<span class="line-removed">4852         cmp(ch1, ch2);</span>
<span class="line-removed">4853         br(NE, STR2_NEXT);</span>
<span class="line-removed">4854         b(MATCH);</span>
<span class="line-removed">4855     }</span>
<span class="line-removed">4856 </span>
<span class="line-removed">4857     if (icnt1 == -1 || icnt1 == 1) {</span>
<span class="line-removed">4858       Label CH1_LOOP, HAS_ZERO, DO1_SHORT, DO1_LOOP;</span>
<span class="line-removed">4859 </span>
<span class="line-removed">4860       BIND(DO1);</span>
<span class="line-removed">4861         (this-&gt;*str1_load_1chr)(ch1, str1);</span>
<span class="line-removed">4862         cmp(cnt2, (u1)8);</span>
<span class="line-removed">4863         br(LT, DO1_SHORT);</span>
<span class="line-removed">4864 </span>
<span class="line-removed">4865         sub(result_tmp, cnt2, 8/str2_chr_size);</span>
<span class="line-removed">4866         sub(cnt2_neg, zr, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">4867         mov(tmp3, str2_isL ? 0x0101010101010101 : 0x0001000100010001);</span>
<span class="line-removed">4868         lea(str2, Address(str2, result_tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">4869 </span>
<span class="line-removed">4870         if (str2_isL) {</span>
<span class="line-removed">4871           orr(ch1, ch1, ch1, LSL, 8);</span>
<span class="line-removed">4872         }</span>
<span class="line-removed">4873         orr(ch1, ch1, ch1, LSL, 16);</span>
<span class="line-removed">4874         orr(ch1, ch1, ch1, LSL, 32);</span>
<span class="line-removed">4875       BIND(CH1_LOOP);</span>
<span class="line-removed">4876         ldr(ch2, Address(str2, cnt2_neg));</span>
<span class="line-removed">4877         eor(ch2, ch1, ch2);</span>
<span class="line-removed">4878         sub(tmp1, ch2, tmp3);</span>
<span class="line-removed">4879         orr(tmp2, ch2, str2_isL ? 0x7f7f7f7f7f7f7f7f : 0x7fff7fff7fff7fff);</span>
<span class="line-removed">4880         bics(tmp1, tmp1, tmp2);</span>
<span class="line-removed">4881         br(NE, HAS_ZERO);</span>
<span class="line-removed">4882         adds(cnt2_neg, cnt2_neg, 8);</span>
<span class="line-removed">4883         br(LT, CH1_LOOP);</span>
<span class="line-removed">4884 </span>
<span class="line-removed">4885         cmp(cnt2_neg, (u1)8);</span>
<span class="line-removed">4886         mov(cnt2_neg, 0);</span>
<span class="line-removed">4887         br(LT, CH1_LOOP);</span>
<span class="line-removed">4888         b(NOMATCH);</span>
<span class="line-removed">4889 </span>
<span class="line-removed">4890       BIND(HAS_ZERO);</span>
<span class="line-removed">4891         rev(tmp1, tmp1);</span>
<span class="line-removed">4892         clz(tmp1, tmp1);</span>
<span class="line-removed">4893         add(cnt2_neg, cnt2_neg, tmp1, LSR, 3);</span>
<span class="line-removed">4894         b(MATCH);</span>
<span class="line-removed">4895 </span>
<span class="line-removed">4896       BIND(DO1_SHORT);</span>
<span class="line-removed">4897         mov(result_tmp, cnt2);</span>
<span class="line-removed">4898         lea(str2, Address(str2, cnt2, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">4899         sub(cnt2_neg, zr, cnt2, LSL, str2_chr_shift);</span>
<span class="line-removed">4900       BIND(DO1_LOOP);</span>
<span class="line-removed">4901         (this-&gt;*str2_load_1chr)(ch2, Address(str2, cnt2_neg));</span>
<span class="line-removed">4902         cmpw(ch1, ch2);</span>
<span class="line-removed">4903         br(EQ, MATCH);</span>
<span class="line-removed">4904         adds(cnt2_neg, cnt2_neg, str2_chr_size);</span>
<span class="line-removed">4905         br(LT, DO1_LOOP);</span>
<span class="line-removed">4906     }</span>
<span class="line-removed">4907   }</span>
<span class="line-removed">4908   BIND(NOMATCH);</span>
<span class="line-removed">4909     mov(result, -1);</span>
<span class="line-removed">4910     b(DONE);</span>
<span class="line-removed">4911   BIND(MATCH);</span>
<span class="line-removed">4912     add(result, result_tmp, cnt2_neg, ASR, str2_chr_shift);</span>
<span class="line-removed">4913   BIND(DONE);</span>
<span class="line-removed">4914 }</span>
<span class="line-removed">4915 </span>
<span class="line-removed">4916 typedef void (MacroAssembler::* chr_insn)(Register Rt, const Address &amp;adr);</span>
<span class="line-removed">4917 typedef void (MacroAssembler::* uxt_insn)(Register Rd, Register Rn);</span>
<span class="line-removed">4918 </span>
<span class="line-removed">4919 void MacroAssembler::string_indexof_char(Register str1, Register cnt1,</span>
<span class="line-removed">4920                                          Register ch, Register result,</span>
<span class="line-removed">4921                                          Register tmp1, Register tmp2, Register tmp3)</span>
<span class="line-removed">4922 {</span>
<span class="line-removed">4923   Label CH1_LOOP, HAS_ZERO, DO1_SHORT, DO1_LOOP, MATCH, NOMATCH, DONE;</span>
<span class="line-removed">4924   Register cnt1_neg = cnt1;</span>
<span class="line-removed">4925   Register ch1 = rscratch1;</span>
<span class="line-removed">4926   Register result_tmp = rscratch2;</span>
<span class="line-removed">4927 </span>
<span class="line-removed">4928   cmp(cnt1, (u1)4);</span>
<span class="line-removed">4929   br(LT, DO1_SHORT);</span>
<span class="line-removed">4930 </span>
<span class="line-removed">4931   orr(ch, ch, ch, LSL, 16);</span>
<span class="line-removed">4932   orr(ch, ch, ch, LSL, 32);</span>
<span class="line-removed">4933 </span>
<span class="line-removed">4934   sub(cnt1, cnt1, 4);</span>
<span class="line-removed">4935   mov(result_tmp, cnt1);</span>
<span class="line-removed">4936   lea(str1, Address(str1, cnt1, Address::uxtw(1)));</span>
<span class="line-removed">4937   sub(cnt1_neg, zr, cnt1, LSL, 1);</span>
<span class="line-removed">4938 </span>
<span class="line-removed">4939   mov(tmp3, 0x0001000100010001);</span>
<span class="line-removed">4940 </span>
<span class="line-removed">4941   BIND(CH1_LOOP);</span>
<span class="line-removed">4942     ldr(ch1, Address(str1, cnt1_neg));</span>
<span class="line-removed">4943     eor(ch1, ch, ch1);</span>
<span class="line-removed">4944     sub(tmp1, ch1, tmp3);</span>
<span class="line-removed">4945     orr(tmp2, ch1, 0x7fff7fff7fff7fff);</span>
<span class="line-removed">4946     bics(tmp1, tmp1, tmp2);</span>
<span class="line-removed">4947     br(NE, HAS_ZERO);</span>
<span class="line-removed">4948     adds(cnt1_neg, cnt1_neg, 8);</span>
<span class="line-removed">4949     br(LT, CH1_LOOP);</span>
<span class="line-removed">4950 </span>
<span class="line-removed">4951     cmp(cnt1_neg, (u1)8);</span>
<span class="line-removed">4952     mov(cnt1_neg, 0);</span>
<span class="line-removed">4953     br(LT, CH1_LOOP);</span>
<span class="line-removed">4954     b(NOMATCH);</span>
<span class="line-removed">4955 </span>
<span class="line-removed">4956   BIND(HAS_ZERO);</span>
<span class="line-removed">4957     rev(tmp1, tmp1);</span>
<span class="line-removed">4958     clz(tmp1, tmp1);</span>
<span class="line-removed">4959     add(cnt1_neg, cnt1_neg, tmp1, LSR, 3);</span>
<span class="line-removed">4960     b(MATCH);</span>
<span class="line-removed">4961 </span>
<span class="line-removed">4962   BIND(DO1_SHORT);</span>
<span class="line-removed">4963     mov(result_tmp, cnt1);</span>
<span class="line-removed">4964     lea(str1, Address(str1, cnt1, Address::uxtw(1)));</span>
<span class="line-removed">4965     sub(cnt1_neg, zr, cnt1, LSL, 1);</span>
<span class="line-removed">4966   BIND(DO1_LOOP);</span>
<span class="line-removed">4967     ldrh(ch1, Address(str1, cnt1_neg));</span>
<span class="line-removed">4968     cmpw(ch, ch1);</span>
<span class="line-removed">4969     br(EQ, MATCH);</span>
<span class="line-removed">4970     adds(cnt1_neg, cnt1_neg, 2);</span>
<span class="line-removed">4971     br(LT, DO1_LOOP);</span>
<span class="line-removed">4972   BIND(NOMATCH);</span>
<span class="line-removed">4973     mov(result, -1);</span>
<span class="line-removed">4974     b(DONE);</span>
<span class="line-removed">4975   BIND(MATCH);</span>
<span class="line-removed">4976     add(result, result_tmp, cnt1_neg, ASR, 1);</span>
<span class="line-removed">4977   BIND(DONE);</span>
<span class="line-removed">4978 }</span>
<span class="line-removed">4979 </span>
<span class="line-removed">4980 // Compare strings.</span>
<span class="line-removed">4981 void MacroAssembler::string_compare(Register str1, Register str2,</span>
<span class="line-removed">4982     Register cnt1, Register cnt2, Register result, Register tmp1, Register tmp2,</span>
<span class="line-removed">4983     FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3, int ae) {</span>
<span class="line-removed">4984   Label DONE, SHORT_LOOP, SHORT_STRING, SHORT_LAST, TAIL, STUB,</span>
<span class="line-removed">4985       DIFFERENCE, NEXT_WORD, SHORT_LOOP_TAIL, SHORT_LAST2, SHORT_LAST_INIT,</span>
<span class="line-removed">4986       SHORT_LOOP_START, TAIL_CHECK;</span>
<span class="line-removed">4987 </span>
<span class="line-removed">4988   bool isLL = ae == StrIntrinsicNode::LL;</span>
<span class="line-removed">4989   bool isLU = ae == StrIntrinsicNode::LU;</span>
<span class="line-removed">4990   bool isUL = ae == StrIntrinsicNode::UL;</span>
<span class="line-removed">4991 </span>
<span class="line-removed">4992   // The stub threshold for LL strings is: 72 (64 + 8) chars</span>
<span class="line-removed">4993   // UU: 36 chars, or 72 bytes (valid for the 64-byte large loop with prefetch)</span>
<span class="line-removed">4994   // LU/UL: 24 chars, or 48 bytes (valid for the 16-character loop at least)</span>
<span class="line-removed">4995   const u1 stub_threshold = isLL ? 72 : ((isLU || isUL) ? 24 : 36);</span>
<span class="line-removed">4996 </span>
<span class="line-removed">4997   bool str1_isL = isLL || isLU;</span>
<span class="line-removed">4998   bool str2_isL = isLL || isUL;</span>
<span class="line-removed">4999 </span>
<span class="line-removed">5000   int str1_chr_shift = str1_isL ? 0 : 1;</span>
<span class="line-removed">5001   int str2_chr_shift = str2_isL ? 0 : 1;</span>
<span class="line-removed">5002   int str1_chr_size = str1_isL ? 1 : 2;</span>
<span class="line-removed">5003   int str2_chr_size = str2_isL ? 1 : 2;</span>
<span class="line-removed">5004   int minCharsInWord = isLL ? wordSize : wordSize/2;</span>
<span class="line-removed">5005 </span>
<span class="line-removed">5006   FloatRegister vtmpZ = vtmp1, vtmp = vtmp2;</span>
<span class="line-removed">5007   chr_insn str1_load_chr = str1_isL ? (chr_insn)&amp;MacroAssembler::ldrb :</span>
<span class="line-removed">5008                                       (chr_insn)&amp;MacroAssembler::ldrh;</span>
<span class="line-removed">5009   chr_insn str2_load_chr = str2_isL ? (chr_insn)&amp;MacroAssembler::ldrb :</span>
<span class="line-removed">5010                                       (chr_insn)&amp;MacroAssembler::ldrh;</span>
<span class="line-removed">5011   uxt_insn ext_chr = isLL ? (uxt_insn)&amp;MacroAssembler::uxtbw :</span>
<span class="line-removed">5012                             (uxt_insn)&amp;MacroAssembler::uxthw;</span>
<span class="line-removed">5013 </span>
<span class="line-removed">5014   BLOCK_COMMENT(&quot;string_compare {&quot;);</span>
<span class="line-removed">5015 </span>
<span class="line-removed">5016   // Bizzarely, the counts are passed in bytes, regardless of whether they</span>
<span class="line-removed">5017   // are L or U strings, however the result is always in characters.</span>
<span class="line-removed">5018   if (!str1_isL) asrw(cnt1, cnt1, 1);</span>
<span class="line-removed">5019   if (!str2_isL) asrw(cnt2, cnt2, 1);</span>
<span class="line-removed">5020 </span>
<span class="line-removed">5021   // Compute the minimum of the string lengths and save the difference.</span>
<span class="line-removed">5022   subsw(result, cnt1, cnt2);</span>
<span class="line-removed">5023   cselw(cnt2, cnt1, cnt2, Assembler::LE); // min</span>
<span class="line-removed">5024 </span>
<span class="line-removed">5025   // A very short string</span>
<span class="line-removed">5026   cmpw(cnt2, minCharsInWord);</span>
<span class="line-removed">5027   br(Assembler::LE, SHORT_STRING);</span>
<span class="line-removed">5028 </span>
<span class="line-removed">5029   // Compare longwords</span>
<span class="line-removed">5030   // load first parts of strings and finish initialization while loading</span>
<span class="line-removed">5031   {</span>
<span class="line-removed">5032     if (str1_isL == str2_isL) { // LL or UU</span>
<span class="line-removed">5033       ldr(tmp1, Address(str1));</span>
<span class="line-removed">5034       cmp(str1, str2);</span>
<span class="line-removed">5035       br(Assembler::EQ, DONE);</span>
<span class="line-removed">5036       ldr(tmp2, Address(str2));</span>
<span class="line-removed">5037       cmp(cnt2, stub_threshold);</span>
<span class="line-removed">5038       br(GE, STUB);</span>
<span class="line-removed">5039       subsw(cnt2, cnt2, minCharsInWord);</span>
<span class="line-removed">5040       br(EQ, TAIL_CHECK);</span>
<span class="line-removed">5041       lea(str2, Address(str2, cnt2, Address::uxtw(str2_chr_shift)));</span>
<span class="line-removed">5042       lea(str1, Address(str1, cnt2, Address::uxtw(str1_chr_shift)));</span>
<span class="line-removed">5043       sub(cnt2, zr, cnt2, LSL, str2_chr_shift);</span>
<span class="line-removed">5044     } else if (isLU) {</span>
<span class="line-removed">5045       ldrs(vtmp, Address(str1));</span>
<span class="line-removed">5046       ldr(tmp2, Address(str2));</span>
<span class="line-removed">5047       cmp(cnt2, stub_threshold);</span>
<span class="line-removed">5048       br(GE, STUB);</span>
<span class="line-removed">5049       subw(cnt2, cnt2, 4);</span>
<span class="line-removed">5050       eor(vtmpZ, T16B, vtmpZ, vtmpZ);</span>
<span class="line-removed">5051       lea(str1, Address(str1, cnt2, Address::uxtw(str1_chr_shift)));</span>
<span class="line-removed">5052       lea(str2, Address(str2, cnt2, Address::uxtw(str2_chr_shift)));</span>
<span class="line-removed">5053       zip1(vtmp, T8B, vtmp, vtmpZ);</span>
<span class="line-removed">5054       sub(cnt1, zr, cnt2, LSL, str1_chr_shift);</span>
<span class="line-removed">5055       sub(cnt2, zr, cnt2, LSL, str2_chr_shift);</span>
<span class="line-removed">5056       add(cnt1, cnt1, 4);</span>
<span class="line-removed">5057       fmovd(tmp1, vtmp);</span>
<span class="line-removed">5058     } else { // UL case</span>
<span class="line-removed">5059       ldr(tmp1, Address(str1));</span>
<span class="line-removed">5060       ldrs(vtmp, Address(str2));</span>
<span class="line-removed">5061       cmp(cnt2, stub_threshold);</span>
<span class="line-removed">5062       br(GE, STUB);</span>
<span class="line-removed">5063       subw(cnt2, cnt2, 4);</span>
<span class="line-removed">5064       lea(str1, Address(str1, cnt2, Address::uxtw(str1_chr_shift)));</span>
<span class="line-removed">5065       eor(vtmpZ, T16B, vtmpZ, vtmpZ);</span>
<span class="line-removed">5066       lea(str2, Address(str2, cnt2, Address::uxtw(str2_chr_shift)));</span>
<span class="line-removed">5067       sub(cnt1, zr, cnt2, LSL, str1_chr_shift);</span>
<span class="line-removed">5068       zip1(vtmp, T8B, vtmp, vtmpZ);</span>
<span class="line-removed">5069       sub(cnt2, zr, cnt2, LSL, str2_chr_shift);</span>
<span class="line-removed">5070       add(cnt1, cnt1, 8);</span>
<span class="line-removed">5071       fmovd(tmp2, vtmp);</span>
<span class="line-removed">5072     }</span>
<span class="line-removed">5073     adds(cnt2, cnt2, isUL ? 4 : 8);</span>
<span class="line-removed">5074     br(GE, TAIL);</span>
<span class="line-removed">5075     eor(rscratch2, tmp1, tmp2);</span>
<span class="line-removed">5076     cbnz(rscratch2, DIFFERENCE);</span>
<span class="line-removed">5077     // main loop</span>
<span class="line-removed">5078     bind(NEXT_WORD);</span>
<span class="line-removed">5079     if (str1_isL == str2_isL) {</span>
<span class="line-removed">5080       ldr(tmp1, Address(str1, cnt2));</span>
<span class="line-removed">5081       ldr(tmp2, Address(str2, cnt2));</span>
<span class="line-removed">5082       adds(cnt2, cnt2, 8);</span>
<span class="line-removed">5083     } else if (isLU) {</span>
<span class="line-removed">5084       ldrs(vtmp, Address(str1, cnt1));</span>
<span class="line-removed">5085       ldr(tmp2, Address(str2, cnt2));</span>
<span class="line-removed">5086       add(cnt1, cnt1, 4);</span>
<span class="line-removed">5087       zip1(vtmp, T8B, vtmp, vtmpZ);</span>
<span class="line-removed">5088       fmovd(tmp1, vtmp);</span>
<span class="line-removed">5089       adds(cnt2, cnt2, 8);</span>
<span class="line-removed">5090     } else { // UL</span>
<span class="line-removed">5091       ldrs(vtmp, Address(str2, cnt2));</span>
<span class="line-removed">5092       ldr(tmp1, Address(str1, cnt1));</span>
<span class="line-removed">5093       zip1(vtmp, T8B, vtmp, vtmpZ);</span>
<span class="line-removed">5094       add(cnt1, cnt1, 8);</span>
<span class="line-removed">5095       fmovd(tmp2, vtmp);</span>
<span class="line-removed">5096       adds(cnt2, cnt2, 4);</span>
<span class="line-removed">5097     }</span>
<span class="line-removed">5098     br(GE, TAIL);</span>
<span class="line-removed">5099 </span>
<span class="line-removed">5100     eor(rscratch2, tmp1, tmp2);</span>
<span class="line-removed">5101     cbz(rscratch2, NEXT_WORD);</span>
<span class="line-removed">5102     b(DIFFERENCE);</span>
<span class="line-removed">5103     bind(TAIL);</span>
<span class="line-removed">5104     eor(rscratch2, tmp1, tmp2);</span>
<span class="line-removed">5105     cbnz(rscratch2, DIFFERENCE);</span>
<span class="line-removed">5106     // Last longword.  In the case where length == 4 we compare the</span>
<span class="line-removed">5107     // same longword twice, but that&#39;s still faster than another</span>
<span class="line-removed">5108     // conditional branch.</span>
<span class="line-removed">5109     if (str1_isL == str2_isL) {</span>
<span class="line-removed">5110       ldr(tmp1, Address(str1));</span>
<span class="line-removed">5111       ldr(tmp2, Address(str2));</span>
<span class="line-removed">5112     } else if (isLU) {</span>
<span class="line-removed">5113       ldrs(vtmp, Address(str1));</span>
<span class="line-removed">5114       ldr(tmp2, Address(str2));</span>
<span class="line-removed">5115       zip1(vtmp, T8B, vtmp, vtmpZ);</span>
<span class="line-removed">5116       fmovd(tmp1, vtmp);</span>
<span class="line-removed">5117     } else { // UL</span>
<span class="line-removed">5118       ldrs(vtmp, Address(str2));</span>
<span class="line-removed">5119       ldr(tmp1, Address(str1));</span>
<span class="line-removed">5120       zip1(vtmp, T8B, vtmp, vtmpZ);</span>
<span class="line-removed">5121       fmovd(tmp2, vtmp);</span>
<span class="line-removed">5122     }</span>
<span class="line-removed">5123     bind(TAIL_CHECK);</span>
<span class="line-removed">5124     eor(rscratch2, tmp1, tmp2);</span>
<span class="line-removed">5125     cbz(rscratch2, DONE);</span>
<span class="line-removed">5126 </span>
<span class="line-removed">5127     // Find the first different characters in the longwords and</span>
<span class="line-removed">5128     // compute their difference.</span>
<span class="line-removed">5129     bind(DIFFERENCE);</span>
<span class="line-removed">5130     rev(rscratch2, rscratch2);</span>
<span class="line-removed">5131     clz(rscratch2, rscratch2);</span>
<span class="line-removed">5132     andr(rscratch2, rscratch2, isLL ? -8 : -16);</span>
<span class="line-removed">5133     lsrv(tmp1, tmp1, rscratch2);</span>
<span class="line-removed">5134     (this-&gt;*ext_chr)(tmp1, tmp1);</span>
<span class="line-removed">5135     lsrv(tmp2, tmp2, rscratch2);</span>
<span class="line-removed">5136     (this-&gt;*ext_chr)(tmp2, tmp2);</span>
<span class="line-removed">5137     subw(result, tmp1, tmp2);</span>
<span class="line-removed">5138     b(DONE);</span>
<span class="line-removed">5139   }</span>
<span class="line-removed">5140 </span>
<span class="line-removed">5141   bind(STUB);</span>
<span class="line-removed">5142     RuntimeAddress stub = NULL;</span>
<span class="line-removed">5143     switch(ae) {</span>
<span class="line-removed">5144       case StrIntrinsicNode::LL:</span>
<span class="line-removed">5145         stub = RuntimeAddress(StubRoutines::aarch64::compare_long_string_LL());</span>
<span class="line-removed">5146         break;</span>
<span class="line-removed">5147       case StrIntrinsicNode::UU:</span>
<span class="line-removed">5148         stub = RuntimeAddress(StubRoutines::aarch64::compare_long_string_UU());</span>
<span class="line-removed">5149         break;</span>
<span class="line-removed">5150       case StrIntrinsicNode::LU:</span>
<span class="line-removed">5151         stub = RuntimeAddress(StubRoutines::aarch64::compare_long_string_LU());</span>
<span class="line-removed">5152         break;</span>
<span class="line-removed">5153       case StrIntrinsicNode::UL:</span>
<span class="line-removed">5154         stub = RuntimeAddress(StubRoutines::aarch64::compare_long_string_UL());</span>
<span class="line-removed">5155         break;</span>
<span class="line-removed">5156       default:</span>
<span class="line-removed">5157         ShouldNotReachHere();</span>
<span class="line-removed">5158      }</span>
<span class="line-removed">5159     assert(stub.target() != NULL, &quot;compare_long_string stub has not been generated&quot;);</span>
<span class="line-removed">5160     trampoline_call(stub);</span>
<span class="line-removed">5161     b(DONE);</span>
<span class="line-removed">5162 </span>
<span class="line-removed">5163   bind(SHORT_STRING);</span>
<span class="line-removed">5164   // Is the minimum length zero?</span>
<span class="line-removed">5165   cbz(cnt2, DONE);</span>
<span class="line-removed">5166   // arrange code to do most branches while loading and loading next characters</span>
<span class="line-removed">5167   // while comparing previous</span>
<span class="line-removed">5168   (this-&gt;*str1_load_chr)(tmp1, Address(post(str1, str1_chr_size)));</span>
<span class="line-removed">5169   subs(cnt2, cnt2, 1);</span>
<span class="line-removed">5170   br(EQ, SHORT_LAST_INIT);</span>
<span class="line-removed">5171   (this-&gt;*str2_load_chr)(cnt1, Address(post(str2, str2_chr_size)));</span>
<span class="line-removed">5172   b(SHORT_LOOP_START);</span>
<span class="line-removed">5173   bind(SHORT_LOOP);</span>
<span class="line-removed">5174   subs(cnt2, cnt2, 1);</span>
<span class="line-removed">5175   br(EQ, SHORT_LAST);</span>
<span class="line-removed">5176   bind(SHORT_LOOP_START);</span>
<span class="line-removed">5177   (this-&gt;*str1_load_chr)(tmp2, Address(post(str1, str1_chr_size)));</span>
<span class="line-removed">5178   (this-&gt;*str2_load_chr)(rscratch1, Address(post(str2, str2_chr_size)));</span>
<span class="line-removed">5179   cmp(tmp1, cnt1);</span>
<span class="line-removed">5180   br(NE, SHORT_LOOP_TAIL);</span>
<span class="line-removed">5181   subs(cnt2, cnt2, 1);</span>
<span class="line-removed">5182   br(EQ, SHORT_LAST2);</span>
<span class="line-removed">5183   (this-&gt;*str1_load_chr)(tmp1, Address(post(str1, str1_chr_size)));</span>
<span class="line-removed">5184   (this-&gt;*str2_load_chr)(cnt1, Address(post(str2, str2_chr_size)));</span>
<span class="line-removed">5185   cmp(tmp2, rscratch1);</span>
<span class="line-removed">5186   br(EQ, SHORT_LOOP);</span>
<span class="line-removed">5187   sub(result, tmp2, rscratch1);</span>
<span class="line-removed">5188   b(DONE);</span>
<span class="line-removed">5189   bind(SHORT_LOOP_TAIL);</span>
<span class="line-removed">5190   sub(result, tmp1, cnt1);</span>
<span class="line-removed">5191   b(DONE);</span>
<span class="line-removed">5192   bind(SHORT_LAST2);</span>
<span class="line-removed">5193   cmp(tmp2, rscratch1);</span>
<span class="line-removed">5194   br(EQ, DONE);</span>
<span class="line-removed">5195   sub(result, tmp2, rscratch1);</span>
<span class="line-removed">5196 </span>
<span class="line-removed">5197   b(DONE);</span>
<span class="line-removed">5198   bind(SHORT_LAST_INIT);</span>
<span class="line-removed">5199   (this-&gt;*str2_load_chr)(cnt1, Address(post(str2, str2_chr_size)));</span>
<span class="line-removed">5200   bind(SHORT_LAST);</span>
<span class="line-removed">5201   cmp(tmp1, cnt1);</span>
<span class="line-removed">5202   br(EQ, DONE);</span>
<span class="line-removed">5203   sub(result, tmp1, cnt1);</span>
<span class="line-removed">5204 </span>
<span class="line-removed">5205   bind(DONE);</span>
<span class="line-removed">5206 </span>
<span class="line-removed">5207   BLOCK_COMMENT(&quot;} string_compare&quot;);</span>
<span class="line-removed">5208 }</span>
<span class="line-removed">5209 #endif // COMPILER2</span>
5210 
5211 // This method checks if provided byte array contains byte with highest bit set.
5212 void MacroAssembler::has_negatives(Register ary1, Register len, Register result) {
5213     // Simple and most common case of aligned small array which is not at the
5214     // end of memory page is placed here. All other cases are in stub.
5215     Label LOOP, END, STUB, STUB_LONG, SET_RESULT, DONE;
5216     const uint64_t UPPER_BIT_MASK=0x8080808080808080;
5217     assert_different_registers(ary1, len, result);
5218 
5219     cmpw(len, 0);
5220     br(LE, SET_RESULT);
5221     cmpw(len, 4 * wordSize);
5222     br(GE, STUB_LONG); // size &gt; 32 then go to stub
5223 
5224     int shift = 64 - exact_log2(os::vm_page_size());
5225     lsl(rscratch1, ary1, shift);
5226     mov(rscratch2, (size_t)(4 * wordSize) &lt;&lt; shift);
5227     adds(rscratch2, rscratch1, rscratch2);  // At end of page?
5228     br(CS, STUB); // at the end of page then go to stub
5229     subs(len, len, wordSize);
</pre>
</td>
<td>
<hr />
<pre>
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;memory/universe.hpp&quot;
  40 #include &quot;nativeInst_aarch64.hpp&quot;
  41 #include &quot;oops/accessDecorators.hpp&quot;
  42 #include &quot;oops/compressedOops.inline.hpp&quot;
  43 #include &quot;oops/klass.inline.hpp&quot;
  44 #include &quot;runtime/biasedLocking.hpp&quot;
  45 #include &quot;runtime/icache.hpp&quot;
  46 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  47 #include &quot;runtime/jniHandles.inline.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
  49 #include &quot;runtime/signature_cc.hpp&quot;
  50 #include &quot;runtime/thread.hpp&quot;
  51 #include &quot;utilities/powerOfTwo.hpp&quot;
  52 #ifdef COMPILER1
  53 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  54 #endif
  55 #ifdef COMPILER2
  56 #include &quot;oops/oop.hpp&quot;
  57 #include &quot;opto/compile.hpp&quot;

  58 #include &quot;opto/node.hpp&quot;
<span class="line-added">  59 #include &quot;opto/output.hpp&quot;</span>
  60 #endif
  61 
  62 #ifdef PRODUCT
  63 #define BLOCK_COMMENT(str) /* nothing */
  64 #define STOP(error) stop(error)
  65 #else
  66 #define BLOCK_COMMENT(str) block_comment(str)
  67 #define STOP(error) block_comment(error); stop(error)
  68 #endif
  69 
  70 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  71 
  72 // Patch any kind of instruction; there may be several instructions.
  73 // Return the total length (in bytes) of the instructions.
  74 int MacroAssembler::pd_patch_instruction_size(address branch, address target) {
  75   int instructions = 1;
  76   assert((uint64_t)target &lt; (1ul &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);
  77   long offset = (target - branch) &gt;&gt; 2;
  78   unsigned insn = *(unsigned*)branch;
  79   if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b111011) == 0b011000) {
</pre>
<hr />
<pre>
 729 
 730 // Maybe emit a call via a trampoline.  If the code cache is small
 731 // trampolines won&#39;t be emitted.
 732 
 733 address MacroAssembler::trampoline_call(Address entry, CodeBuffer *cbuf) {
 734   assert(JavaThread::current()-&gt;is_Compiler_thread(), &quot;just checking&quot;);
 735   assert(entry.rspec().type() == relocInfo::runtime_call_type
 736          || entry.rspec().type() == relocInfo::opt_virtual_call_type
 737          || entry.rspec().type() == relocInfo::static_call_type
 738          || entry.rspec().type() == relocInfo::virtual_call_type, &quot;wrong reloc type&quot;);
 739 
 740   // We need a trampoline if branches are far.
 741   if (far_branches()) {
 742     bool in_scratch_emit_size = false;
 743 #ifdef COMPILER2
 744     // We don&#39;t want to emit a trampoline if C2 is generating dummy
 745     // code during its branch shortening phase.
 746     CompileTask* task = ciEnv::current()-&gt;task();
 747     in_scratch_emit_size =
 748       (task != NULL &amp;&amp; is_c2_compile(task-&gt;comp_level()) &amp;&amp;
<span class="line-modified"> 749        Compile::current()-&gt;output()-&gt;in_scratch_emit_size());</span>
 750 #endif
 751     if (!in_scratch_emit_size) {
 752       address stub = emit_trampoline_stub(offset(), entry.target());
 753       if (stub == NULL) {
 754         return NULL; // CodeCache is full
 755       }
 756     }
 757   }
 758 
 759   if (cbuf) cbuf-&gt;set_insts_mark();
 760   relocate(entry.rspec());
 761   if (!far_branches()) {
 762     bl(entry.target());
 763   } else {
 764     bl(pc());
 765   }
 766   // just need to return a non-null address
 767   return pc();
 768 }
 769 
</pre>
<hr />
<pre>
4461     }
4462   }
4463 }
4464 
4465 void MacroAssembler::remove_frame(int framesize) {
4466   assert(framesize &gt; 0, &quot;framesize must be &gt; 0&quot;);
4467   if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
4468     ldp(rfp, lr, Address(sp, framesize - 2 * wordSize));
4469     add(sp, sp, framesize);
4470   } else {
4471     if (framesize &lt; ((1 &lt;&lt; 12) + 2 * wordSize))
4472       add(sp, sp, framesize - 2 * wordSize);
4473     else {
4474       mov(rscratch1, framesize - 2 * wordSize);
4475       add(sp, sp, rscratch1);
4476     }
4477     ldp(rfp, lr, Address(post(sp, 2 * wordSize)));
4478   }
4479 }
4480 

























































































































































































































































































































































































































































































































































































































































































































































4481 
4482 // This method checks if provided byte array contains byte with highest bit set.
4483 void MacroAssembler::has_negatives(Register ary1, Register len, Register result) {
4484     // Simple and most common case of aligned small array which is not at the
4485     // end of memory page is placed here. All other cases are in stub.
4486     Label LOOP, END, STUB, STUB_LONG, SET_RESULT, DONE;
4487     const uint64_t UPPER_BIT_MASK=0x8080808080808080;
4488     assert_different_registers(ary1, len, result);
4489 
4490     cmpw(len, 0);
4491     br(LE, SET_RESULT);
4492     cmpw(len, 4 * wordSize);
4493     br(GE, STUB_LONG); // size &gt; 32 then go to stub
4494 
4495     int shift = 64 - exact_log2(os::vm_page_size());
4496     lsl(rscratch1, ary1, shift);
4497     mov(rscratch2, (size_t)(4 * wordSize) &lt;&lt; shift);
4498     adds(rscratch2, rscratch1, rscratch2);  // At end of page?
4499     br(CS, STUB); // at the end of page then go to stub
4500     subs(len, len, wordSize);
</pre>
</td>
</tr>
</table>
<center><a href="interp_masm_aarch64.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
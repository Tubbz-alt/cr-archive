<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/aarch64/aarch64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../../demo/share/jfc/TableExample/TableSorter.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRAssembler_aarch64.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/aarch64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1543,11 +1543,11 @@</span>
    st-&gt;print(&quot;BREAKPOINT&quot;);
  }
  #endif
  
  void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
    __ brk(0);
  }
  
  uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
    return MachNode::size(ra_);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1560,11 +1560,11 @@</span>
      st-&gt;print(&quot;nop \t# %d bytes pad for loops and calls&quot;, _count);
    }
  #endif
  
    void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc*) const {
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      for (int i = 0; i &lt; _count; i++) {
        __ nop();
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1573,11 +1573,11 @@</span>
    }
  
  //=============================================================================
  const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  
<span class="udiff-line-modified-removed">- int Compile::ConstantTable::calculate_table_base_offset() const {</span>
<span class="udiff-line-modified-added">+ int ConstantTable::calculate_table_base_offset() const {</span>
    return 0;  // absolute addressing, no offset
  }
  
  bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1600,13 +1600,13 @@</span>
  
  #ifndef PRODUCT
  void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
    Compile* C = ra_-&gt;C;
  
<span class="udiff-line-modified-removed">-   int framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
<span class="udiff-line-modified-added">+   int framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
  
<span class="udiff-line-modified-removed">-   if (C-&gt;need_stack_bang(framesize))</span>
<span class="udiff-line-modified-added">+   if (C-&gt;output()-&gt;need_stack_bang(framesize))</span>
      st-&gt;print(&quot;# stack bang size=%d\n\t&quot;, framesize);
  
    if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
      st-&gt;print(&quot;sub  sp, sp, #%d\n\t&quot;, framesize);
      st-&gt;print(&quot;stp  rfp, lr, [sp, #%d]&quot;, framesize - 2 * wordSize);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1620,21 +1620,21 @@</span>
  }
  #endif
  
  void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
    Compile* C = ra_-&gt;C;
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    __ verified_entry(C, 0);
    __ bind(*_verified_entry);
  
<span class="udiff-line-modified-removed">-   C-&gt;set_frame_complete(cbuf.insts_size());</span>
<span class="udiff-line-modified-added">+   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());</span>
  
    if (C-&gt;has_mach_constant_base_node()) {
      // NOTE: We set the table base offset here because users might be
      // emitted before MachConstantBaseNode.
<span class="udiff-line-modified-removed">-     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
<span class="udiff-line-modified-added">+     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
      constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
    }
  }
  
  uint MachPrologNode::size(PhaseRegAlloc* ra_) const
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1651,11 +1651,11 @@</span>
  //=============================================================================
  
  #ifndef PRODUCT
  void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
    Compile* C = ra_-&gt;C;
<span class="udiff-line-modified-removed">-   int framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
<span class="udiff-line-modified-added">+   int framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
  
    st-&gt;print(&quot;# pop frame %d\n\t&quot;,framesize);
  
    if (framesize == 0) {
      st-&gt;print(&quot;ldp  lr, rfp, [sp],#%d\n\t&quot;, (2 * wordSize));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1676,12 +1676,12 @@</span>
  }
  #endif
  
  void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
    Compile* C = ra_-&gt;C;
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-removed">-   int framesize = C-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   int framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
  
    __ remove_frame(framesize);
  
    if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
      __ reserved_stack_check();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1778,11 +1778,11 @@</span>
  
    if (bottom_type()-&gt;isa_vect() != NULL) {
      uint ireg = ideal_reg();
      assert(ireg == Op_VecD || ireg == Op_VecX, &quot;must be 64 bit or 128 bit vector&quot;);
      if (cbuf) {
<span class="udiff-line-modified-removed">-       MacroAssembler _masm(cbuf);</span>
<span class="udiff-line-modified-added">+       C2_MacroAssembler _masm(cbuf);</span>
        assert((src_lo_rc != rc_int &amp;&amp; dst_lo_rc != rc_int), &quot;sanity&quot;);
        if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
          // stack-&gt;stack
          assert((src_offset &amp; 7) == 0 &amp;&amp; (dst_offset &amp; 7) == 0, &quot;unaligned stack offset&quot;);
          if (ireg == Op_VecD) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1806,19 +1806,19 @@</span>
        } else {
          ShouldNotReachHere();
        }
      }
    } else if (cbuf) {
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(cbuf);</span>
      switch (src_lo_rc) {
      case rc_int:
        if (dst_lo_rc == rc_int) {  // gpr --&gt; gpr copy
          if (is64) {
              __ mov(as_Register(Matcher::_regEncode[dst_lo]),
                     as_Register(Matcher::_regEncode[src_lo]));
          } else {
<span class="udiff-line-modified-removed">-             MacroAssembler _masm(cbuf);</span>
<span class="udiff-line-modified-added">+             C2_MacroAssembler _masm(cbuf);</span>
              __ movw(as_Register(Matcher::_regEncode[dst_lo]),
                      as_Register(Matcher::_regEncode[src_lo]));
          }
        } else if (dst_lo_rc == rc_float) { // gpr --&gt; fpr copy
          if (is64) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1924,11 +1924,11 @@</span>
              Matcher::regName[reg], offset);
  }
  #endif
  
  void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
    int reg    = ra_-&gt;get_encode(this);
  
    if (Assembler::operand_valid_for_add_sub_immediate(offset)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2001,11 +2001,11 @@</span>
  #endif
  
  void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  {
    // This is the unverified entry point.
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
    Label skip;
  
    // UseCompressedClassPointers logic are inside cmp_klass
    __ cmp_klass(j_rarg0, rscratch2, rscratch1);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2030,11 +2030,11 @@</span>
  {
    // mov rscratch1 #exception_blob_entry_point
    // br rscratch1
    // Note that the code buffer&#39;s insts_mark is always relative to insts.
    // That&#39;s why we must use the macroassembler to generate a handler.
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
    address base = __ start_a_stub(size_exception_handler());
    if (base == NULL) {
      ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
      return 0;  // CodeBuffer::expand failed
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2048,11 +2048,11 @@</span>
  // Emit deopt handler code.
  int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf)
  {
    // Note that the code buffer&#39;s insts_mark is always relative to insts.
    // That&#39;s why we must use the macroassembler to generate a handler.
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
    address base = __ start_a_stub(size_deopt_handler());
    if (base == NULL) {
      ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
      return 0;  // CodeBuffer::expand failed
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2414,11 +2414,11 @@</span>
  
  void Compile::reshape_address(AddPNode* addp) {
  }
  
  #define MOV_VOLATILE(REG, BASE, INDEX, SCALE, DISP, SCRATCH, INSN)      \
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);                                          \</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);                                       \</span>
    {                                                                     \
      guarantee(INDEX == -1, &quot;mode not permitted for volatile&quot;);          \
      guarantee(DISP == 0, &quot;mode not permitted for volatile&quot;);            \
      guarantee(SCALE == 0, &quot;mode not permitted for volatile&quot;);           \
      __ INSN(REG, as_Register(BASE));                                    \
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2459,11 +2459,11 @@</span>
                                    MacroAssembler::SIMD_RegVariant T, const Address &amp;adr);
  
    // Used for all non-volatile memory accesses.  The use of
    // $mem-&gt;opcode() to discover whether this pattern uses sign-extended
    // offsets is something of a kludge.
<span class="udiff-line-modified-removed">-   static void loadStore(MacroAssembler masm, mem_insn insn,</span>
<span class="udiff-line-modified-added">+   static void loadStore(C2_MacroAssembler masm, mem_insn insn,</span>
                          Register reg, int opcode,
                          Register base, int index, int scale, int disp,
                          int size_in_memory)
    {
      Address addr = mem2address(opcode, base, index, scale, disp);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2478,11 +2478,11 @@</span>
        addr = masm.legitimize_address(addr, size_in_memory, rscratch1);
      }
      (masm.*insn)(reg, addr);
    }
  
<span class="udiff-line-modified-removed">-   static void loadStore(MacroAssembler masm, mem_float_insn insn,</span>
<span class="udiff-line-modified-added">+   static void loadStore(C2_MacroAssembler masm, mem_float_insn insn,</span>
                          FloatRegister reg, int opcode,
                          Register base, int index, int size, int disp,
                          int size_in_memory)
    {
      Address::extend scale;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2509,11 +2509,11 @@</span>
        assert(disp == 0, &quot;unsupported address mode: disp = %d&quot;, disp);
        (masm.*insn)(reg, Address(base, as_Register(index), scale));
      }
    }
  
<span class="udiff-line-modified-removed">-   static void loadStore(MacroAssembler masm, mem_vector_insn insn,</span>
<span class="udiff-line-modified-added">+   static void loadStore(C2_MacroAssembler masm, mem_vector_insn insn,</span>
                          FloatRegister reg, MacroAssembler::SIMD_RegVariant T,
                          int opcode, Register base, int index, int size, int disp)
    {
      if (index == -1) {
        (masm.*insn)(reg, T, Address(base, disp));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2562,172 +2562,172 @@</span>
    // fields in an order, so that the adlc can build the emit functions
    // automagically
  
    // catch all for unimplemented encodings
    enc_class enc_unimplemented %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ unimplemented(&quot;C2 catch all&quot;);
    %}
  
    // BEGIN Non-volatile memory access
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrsbw(iRegI dst, memory1 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsbw, dst_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsbw, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrsb(iRegI dst, memory1 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsb, dst_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsb, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrb(iRegI dst, memory1 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrb, dst_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrb, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrb(iRegL dst, memory1 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrb, dst_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrb, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrshw(iRegI dst, memory2 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrshw, dst_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrshw, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrsh(iRegI dst, memory2 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsh, dst_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsh, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrh(iRegI dst, memory2 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrh, dst_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrh, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrh(iRegL dst, memory2 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrh, dst_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrh, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrw(iRegI dst, memory4 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrw, dst_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrw, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrw(iRegL dst, memory4 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrw, dst_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrw, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrsw(iRegL dst, memory4 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsw, dst_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrsw, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldr(iRegL dst, memory8 mem) %{
      Register dst_reg = as_Register($dst$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrs(vRegF dst, memory4 mem) %{
      FloatRegister dst_reg = as_FloatRegister($dst$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrs, dst_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrs, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_ldrd(vRegD dst, memory8 mem) %{
      FloatRegister dst_reg = as_FloatRegister($dst$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrd, dst_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrd, dst_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strb(iRegI src, memory1 mem) %{
      Register src_reg = as_Register($src$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strb, src_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strb, src_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strb0(memory1 mem) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      loadStore(_masm, &amp;MacroAssembler::strb, zr, $mem-&gt;opcode(),
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strh(iRegI src, memory2 mem) %{
      Register src_reg = as_Register($src$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strh, src_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strh, src_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strh0(memory2 mem) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      loadStore(_masm, &amp;MacroAssembler::strh, zr, $mem-&gt;opcode(),
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strw(iRegI src, memory4 mem) %{
      Register src_reg = as_Register($src$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strw, src_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strw, src_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strw0(memory4 mem) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      loadStore(_masm, &amp;MacroAssembler::strw, zr, $mem-&gt;opcode(),
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2735,47 +2735,47 @@</span>
    enc_class aarch64_enc_str(iRegL src, memory8 mem) %{
      Register src_reg = as_Register($src$$reg);
      // we sometimes get asked to store the stack pointer into the
      // current thread -- we cannot do that directly on AArch64
      if (src_reg == r31_sp) {
<span class="udiff-line-modified-removed">-       MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+       C2_MacroAssembler _masm(&amp;cbuf);</span>
        assert(as_Register($mem$$base) == rthread, &quot;unexpected store for sp&quot;);
        __ mov(rscratch2, sp);
        src_reg = rscratch2;
      }
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_str0(memory8 mem) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      loadStore(_masm, &amp;MacroAssembler::str, zr, $mem-&gt;opcode(),
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strs(vRegF src, memory4 mem) %{
      FloatRegister src_reg = as_FloatRegister($src$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strs, src_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strs, src_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strd(vRegD src, memory8 mem) %{
      FloatRegister src_reg = as_FloatRegister($src$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strd, src_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::strd, src_reg, $mem-&gt;opcode(),</span>
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strw_immn(immN src, memory1 mem) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      address con = (address)$src$$constant;
      // need to do this the hard way until we can manage relocs
      // for 32 bit constants
      __ movoop(rscratch2, (jobject)con);
      if (con) __ encode_heap_oop_not_null(rscratch2);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2784,11 +2784,11 @@</span>
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strw_immnk(immN src, memory4 mem) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      address con = (address)$src$$constant;
      // need to do this the hard way until we can manage relocs
      // for 32 bit constants
      __ movoop(rscratch2, (jobject)con);
      __ encode_klass_not_null(rscratch2);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2797,52 +2797,52 @@</span>
    %}
  
    // This encoding class is generated automatically from ad_encode.m4.
    // DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE
    enc_class aarch64_enc_strb0_ordered(memory4 mem) %{
<span class="udiff-line-modified-removed">-       MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+       C2_MacroAssembler _masm(&amp;cbuf);</span>
        __ membar(Assembler::StoreStore);
        loadStore(_masm, &amp;MacroAssembler::strb, zr, $mem-&gt;opcode(),
                 as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 1);
    %}
  
    // END Non-volatile memory access
  
    // Vector loads and stores
    enc_class aarch64_enc_ldrvS(vecD dst, memory mem) %{
      FloatRegister dst_reg = as_FloatRegister($dst$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::S,</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::S,</span>
         $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    %}
  
    enc_class aarch64_enc_ldrvD(vecD dst, memory mem) %{
      FloatRegister dst_reg = as_FloatRegister($dst$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::D,</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::D,</span>
         $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    %}
  
    enc_class aarch64_enc_ldrvQ(vecX dst, memory mem) %{
      FloatRegister dst_reg = as_FloatRegister($dst$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::Q,</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldr, dst_reg, MacroAssembler::Q,</span>
         $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    %}
  
    enc_class aarch64_enc_strvS(vecD src, memory mem) %{
      FloatRegister src_reg = as_FloatRegister($src$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::S,</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::S,</span>
         $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    %}
  
    enc_class aarch64_enc_strvD(vecD src, memory mem) %{
      FloatRegister src_reg = as_FloatRegister($src$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::D,</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::D,</span>
         $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    %}
  
    enc_class aarch64_enc_strvQ(vecX src, memory mem) %{
      FloatRegister src_reg = as_FloatRegister($src$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::Q,</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::str, src_reg, MacroAssembler::Q,</span>
         $mem-&gt;opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);
    %}
  
    // volatile loads and stores
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2940,43 +2940,43 @@</span>
    enc_class aarch64_enc_stlr(iRegL src, memory mem) %{
      Register src_reg = as_Register($src$$reg);
      // we sometimes get asked to store the stack pointer into the
      // current thread -- we cannot do that directly on AArch64
      if (src_reg == r31_sp) {
<span class="udiff-line-modified-removed">-         MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+       C2_MacroAssembler _masm(&amp;cbuf);</span>
        assert(as_Register($mem$$base) == rthread, &quot;unexpected store for sp&quot;);
        __ mov(rscratch2, sp);
        src_reg = rscratch2;
      }
      MOV_VOLATILE(src_reg, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
                   rscratch1, stlr);
    %}
  
    enc_class aarch64_enc_fstlrs(vRegF src, memory mem) %{
      {
<span class="udiff-line-modified-removed">-       MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+       C2_MacroAssembler _masm(&amp;cbuf);</span>
        FloatRegister src_reg = as_FloatRegister($src$$reg);
        __ fmovs(rscratch2, src_reg);
      }
      MOV_VOLATILE(rscratch2, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
                   rscratch1, stlrw);
    %}
  
    enc_class aarch64_enc_fstlrd(vRegD src, memory mem) %{
      {
<span class="udiff-line-modified-removed">-       MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+       C2_MacroAssembler _masm(&amp;cbuf);</span>
        FloatRegister src_reg = as_FloatRegister($src$$reg);
        __ fmovd(rscratch2, src_reg);
      }
      MOV_VOLATILE(rscratch2, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,
                   rscratch1, stlr);
    %}
  
    // synchronized read/update encodings
  
    enc_class aarch64_enc_ldaxr(iRegL dst, memory8 mem) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      Register base = as_Register($mem$$base);
      int index = $mem$$index;
      int scale = $mem$$scale;
      int disp = $mem$$disp;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3001,11 +3001,11 @@</span>
        }
      }
    %}
  
    enc_class aarch64_enc_stlxr(iRegLNoSp src, memory8 mem) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register src_reg = as_Register($src$$reg);
      Register base = as_Register($mem$$base);
      int index = $mem$$index;
      int scale = $mem$$scale;
      int disp = $mem$$disp;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3031,35 +3031,35 @@</span>
      }
      __ cmpw(rscratch1, zr);
    %}
  
    enc_class aarch64_enc_cmpxchg(memory mem, iRegLNoSp oldval, iRegLNoSp newval) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::xword, /*acquire*/ false, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    enc_class aarch64_enc_cmpxchgw(memory mem, iRegINoSp oldval, iRegINoSp newval) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::word, /*acquire*/ false, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    enc_class aarch64_enc_cmpxchgs(memory mem, iRegINoSp oldval, iRegINoSp newval) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::halfword, /*acquire*/ false, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    enc_class aarch64_enc_cmpxchgb(memory mem, iRegINoSp oldval, iRegINoSp newval) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::byte, /*acquire*/ false, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3068,52 +3068,52 @@</span>
    // The only difference between aarch64_enc_cmpxchg and
    // aarch64_enc_cmpxchg_acq is that we use load-acquire in the
    // CompareAndSwap sequence to serve as a barrier on acquiring a
    // lock.
    enc_class aarch64_enc_cmpxchg_acq(memory mem, iRegLNoSp oldval, iRegLNoSp newval) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::xword, /*acquire*/ true, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    enc_class aarch64_enc_cmpxchgw_acq(memory mem, iRegINoSp oldval, iRegINoSp newval) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::word, /*acquire*/ true, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    enc_class aarch64_enc_cmpxchgs_acq(memory mem, iRegINoSp oldval, iRegINoSp newval) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::halfword, /*acquire*/ true, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    enc_class aarch64_enc_cmpxchgb_acq(memory mem, iRegINoSp oldval, iRegINoSp newval) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      guarantee($mem$$index == -1 &amp;&amp; $mem$$disp == 0, &quot;impossible encoding&quot;);
      __ cmpxchg($mem$$base$$Register, $oldval$$Register, $newval$$Register,
                 Assembler::byte, /*acquire*/ true, /*release*/ true,
                 /*weak*/ false, noreg);
    %}
  
    // auxiliary used for CompareAndSwapX to set result register
    enc_class aarch64_enc_cset_eq(iRegINoSp res) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register res_reg = as_Register($res$$reg);
      __ cset(res_reg, Assembler::EQ);
    %}
  
    // prefetch encodings
  
    enc_class aarch64_enc_prefetchw(memory mem) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register base = as_Register($mem$$base);
      int index = $mem$$index;
      int scale = $mem$$scale;
      int disp = $mem$$disp;
      if (index == -1) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3130,33 +3130,33 @@</span>
    %}
  
    /// mov envcodings
  
    enc_class aarch64_enc_movw_imm(iRegI dst, immI src) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      u_int32_t con = (u_int32_t)$src$$constant;
      Register dst_reg = as_Register($dst$$reg);
      if (con == 0) {
        __ movw(dst_reg, zr);
      } else {
        __ movw(dst_reg, con);
      }
    %}
  
    enc_class aarch64_enc_mov_imm(iRegL dst, immL src) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      u_int64_t con = (u_int64_t)$src$$constant;
      if (con == 0) {
        __ mov(dst_reg, zr);
      } else {
        __ mov(dst_reg, con);
      }
    %}
  
    enc_class aarch64_enc_mov_p(iRegP dst, immP src) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      address con = (address)$src$$constant;
      if (con == NULL || con == (address)1) {
        ShouldNotReachHere();
      } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3177,37 +3177,37 @@</span>
        }
      }
    %}
  
    enc_class aarch64_enc_mov_p0(iRegP dst, immP0 src) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      __ mov(dst_reg, zr);
    %}
  
    enc_class aarch64_enc_mov_p1(iRegP dst, immP_1 src) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      __ mov(dst_reg, (u_int64_t)1);
    %}
  
    enc_class aarch64_enc_mov_poll_page(iRegP dst, immPollPage src) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      address page = (address)$src$$constant;
      Register dst_reg = as_Register($dst$$reg);
      unsigned long off;
      __ adrp(dst_reg, Address(page, relocInfo::poll_type), off);
      assert(off == 0, &quot;assumed offset == 0&quot;);
    %}
  
    enc_class aarch64_enc_mov_byte_map_base(iRegP dst, immByteMapBase src) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ load_byte_map_base($dst$$Register);
    %}
  
    enc_class aarch64_enc_mov_n(iRegN dst, immN src) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      address con = (address)$src$$constant;
      if (con == NULL) {
        ShouldNotReachHere();
      } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3216,17 +3216,17 @@</span>
        __ set_narrow_oop(dst_reg, (jobject)con);
      }
    %}
  
    enc_class aarch64_enc_mov_n0(iRegN dst, immN0 src) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      __ mov(dst_reg, zr);
    %}
  
    enc_class aarch64_enc_mov_nk(iRegN dst, immNKlass src) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      address con = (address)$src$$constant;
      if (con == NULL) {
        ShouldNotReachHere();
      } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3237,11 +3237,11 @@</span>
    %}
  
    // arithmetic encodings
  
    enc_class aarch64_enc_addsubw_imm(iRegI dst, iRegI src1, immIAddSub src2) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      Register src_reg = as_Register($src1$$reg);
      int32_t con = (int32_t)$src2$$constant;
      // add has primary == 0, subtract has primary == 1
      if ($primary) { con = -con; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3251,11 +3251,11 @@</span>
        __ addw(dst_reg, src_reg, con);
      }
    %}
  
    enc_class aarch64_enc_addsub_imm(iRegL dst, iRegL src1, immLAddSub src2) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register dst_reg = as_Register($dst$$reg);
      Register src_reg = as_Register($src1$$reg);
      int32_t con = (int32_t)$src2$$constant;
      // add has primary == 0, subtract has primary == 1
      if ($primary) { con = -con; }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3265,78 +3265,78 @@</span>
        __ add(dst_reg, src_reg, con);
      }
    %}
  
    enc_class aarch64_enc_divw(iRegI dst, iRegI src1, iRegI src2) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
     Register dst_reg = as_Register($dst$$reg);
     Register src1_reg = as_Register($src1$$reg);
     Register src2_reg = as_Register($src2$$reg);
      __ corrected_idivl(dst_reg, src1_reg, src2_reg, false, rscratch1);
    %}
  
    enc_class aarch64_enc_div(iRegI dst, iRegI src1, iRegI src2) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
     Register dst_reg = as_Register($dst$$reg);
     Register src1_reg = as_Register($src1$$reg);
     Register src2_reg = as_Register($src2$$reg);
      __ corrected_idivq(dst_reg, src1_reg, src2_reg, false, rscratch1);
    %}
  
    enc_class aarch64_enc_modw(iRegI dst, iRegI src1, iRegI src2) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
     Register dst_reg = as_Register($dst$$reg);
     Register src1_reg = as_Register($src1$$reg);
     Register src2_reg = as_Register($src2$$reg);
      __ corrected_idivl(dst_reg, src1_reg, src2_reg, true, rscratch1);
    %}
  
    enc_class aarch64_enc_mod(iRegI dst, iRegI src1, iRegI src2) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
     Register dst_reg = as_Register($dst$$reg);
     Register src1_reg = as_Register($src1$$reg);
     Register src2_reg = as_Register($src2$$reg);
      __ corrected_idivq(dst_reg, src1_reg, src2_reg, true, rscratch1);
    %}
  
    // compare instruction encodings
  
    enc_class aarch64_enc_cmpw(iRegI src1, iRegI src2) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg1 = as_Register($src1$$reg);
      Register reg2 = as_Register($src2$$reg);
      __ cmpw(reg1, reg2);
    %}
  
    enc_class aarch64_enc_cmpw_imm_addsub(iRegI src1, immIAddSub src2) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg = as_Register($src1$$reg);
      int32_t val = $src2$$constant;
      if (val &gt;= 0) {
        __ subsw(zr, reg, val);
      } else {
        __ addsw(zr, reg, -val);
      }
    %}
  
    enc_class aarch64_enc_cmpw_imm(iRegI src1, immI src2) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg1 = as_Register($src1$$reg);
      u_int32_t val = (u_int32_t)$src2$$constant;
      __ movw(rscratch1, val);
      __ cmpw(reg1, rscratch1);
    %}
  
    enc_class aarch64_enc_cmp(iRegL src1, iRegL src2) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg1 = as_Register($src1$$reg);
      Register reg2 = as_Register($src2$$reg);
      __ cmp(reg1, reg2);
    %}
  
    enc_class aarch64_enc_cmp_imm_addsub(iRegL src1, immL12 src2) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg = as_Register($src1$$reg);
      int64_t val = $src2$$constant;
      if (val &gt;= 0) {
        __ subs(zr, reg, val);
      } else if (val != -val) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3347,57 +3347,57 @@</span>
        __ subs(zr, reg, rscratch1);
      }
    %}
  
    enc_class aarch64_enc_cmp_imm(iRegL src1, immL src2) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg1 = as_Register($src1$$reg);
      u_int64_t val = (u_int64_t)$src2$$constant;
      __ mov(rscratch1, val);
      __ cmp(reg1, rscratch1);
    %}
  
    enc_class aarch64_enc_cmpp(iRegP src1, iRegP src2) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg1 = as_Register($src1$$reg);
      Register reg2 = as_Register($src2$$reg);
      __ cmp(reg1, reg2);
    %}
  
    enc_class aarch64_enc_cmpn(iRegN src1, iRegN src2) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg1 = as_Register($src1$$reg);
      Register reg2 = as_Register($src2$$reg);
      __ cmpw(reg1, reg2);
    %}
  
    enc_class aarch64_enc_testp(iRegP src) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg = as_Register($src$$reg);
      __ cmp(reg, zr);
    %}
  
    enc_class aarch64_enc_testn(iRegN src) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register reg = as_Register($src$$reg);
      __ cmpw(reg, zr);
    %}
  
    enc_class aarch64_enc_b(label lbl) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label *L = $lbl$$label;
      __ b(*L);
    %}
  
    enc_class aarch64_enc_br_con(cmpOp cmp, label lbl) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label *L = $lbl$$label;
      __ br ((Assembler::Condition)$cmp$$cmpcode, *L);
    %}
  
    enc_class aarch64_enc_br_conU(cmpOpU cmp, label lbl) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label *L = $lbl$$label;
      __ br ((Assembler::Condition)$cmp$$cmpcode, *L);
    %}
  
    enc_class aarch64_enc_partial_subtype_check(iRegP sub, iRegP super, iRegP temp, iRegP result)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3406,22 +3406,22 @@</span>
       Register super_reg = as_Register($super$$reg);
       Register temp_reg = as_Register($temp$$reg);
       Register result_reg = as_Register($result$$reg);
  
       Label miss;
<span class="udiff-line-modified-removed">-      MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+      C2_MacroAssembler _masm(&amp;cbuf);</span>
       __ check_klass_subtype_slow_path(sub_reg, super_reg, temp_reg, result_reg,
                                       NULL, &amp;miss,
                                       /*set_cond_codes:*/ true);
       if ($primary) {
         __ mov(result_reg, zr);
       }
       __ bind(miss);
    %}
  
    enc_class aarch64_enc_java_static_call(method meth) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      address addr = (address)$meth$$method;
      address call;
      if (!_method) {
        // A call to a runtime wrapper, e.g. new, new_typeArray_Java, uncommon_trap.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3444,29 +3444,29 @@</span>
        return;
      }
    %}
  
    enc_class aarch64_enc_java_dynamic_call(method meth) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int method_index = resolved_method_index(cbuf);
      address call = __ ic_call((address)$meth$$method, method_index);
      if (call == NULL) {
        ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
        return;
      }
    %}
  
    enc_class aarch64_enc_call_epilog() %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      if (VerifyStackAtCalls) {
        // Check that stack depth is unchanged: find majik cookie on stack
        __ call_Unimplemented();
      }
    %}
  
    enc_class aarch64_enc_java_to_runtime(method meth) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      // some calls to generated routines (arraycopy code) are scheduled
      // by C2 as runtime calls. if so we can call them using a br (they
      // will be in a reachable segment) otherwise we have to use a blr
      // which loads the absolute address into a register.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3489,37 +3489,37 @@</span>
        __ add(sp, sp, 2 * wordSize);
      }
    %}
  
    enc_class aarch64_enc_rethrow() %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ far_jump(RuntimeAddress(OptoRuntime::rethrow_stub()));
    %}
  
    enc_class aarch64_enc_ret() %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ ret(lr);
    %}
  
    enc_class aarch64_enc_tail_call(iRegP jump_target) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register target_reg = as_Register($jump_target$$reg);
      __ br(target_reg);
    %}
  
    enc_class aarch64_enc_tail_jmp(iRegP jump_target) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register target_reg = as_Register($jump_target$$reg);
      // exception oop should be in r0
      // ret addr has been popped into lr
      // callee expects it in r3
      __ mov(r3, lr);
      __ br(target_reg);
    %}
  
    enc_class aarch64_enc_fast_lock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register oop = as_Register($object$$reg);
      Register box = as_Register($box$$reg);
      Register disp_hdr = as_Register($tmp$$reg);
      Register tmp = as_Register($tmp2$$reg);
      Label cont;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3593,11 +3593,11 @@</span>
      // flag == EQ indicates success
      // flag == NE indicates failure
    %}
  
    enc_class aarch64_enc_fast_unlock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register oop = as_Register($object$$reg);
      Register box = as_Register($box$$reg);
      Register disp_hdr = as_Register($tmp$$reg);
      Register tmp = as_Register($tmp2$$reg);
      Label cont;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8086,11 +8086,11 @@</span>
              &quot;cnt    $tmp, $tmp\t# vector (8B)\n\t&quot;
              &quot;addv   $tmp, $tmp\t# vector (8B)\n\t&quot;
              &quot;mov    $dst, $tmp\t# vector (1D)&quot; %}
    ins_encode %{
      FloatRegister tmp_reg = as_FloatRegister($tmp$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrs, tmp_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrs, tmp_reg, $mem-&gt;opcode(),</span>
                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);
      __ cnt($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
      __ addv($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
      __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);
    %}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -8129,11 +8129,11 @@</span>
              &quot;cnt    $tmp, $tmp\t# vector (8B)\n\t&quot;
              &quot;addv   $tmp, $tmp\t# vector (8B)\n\t&quot;
              &quot;mov    $dst, $tmp\t# vector (1D)&quot; %}
    ins_encode %{
      FloatRegister tmp_reg = as_FloatRegister($tmp$$reg);
<span class="udiff-line-modified-removed">-     loadStore(MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrd, tmp_reg, $mem-&gt;opcode(),</span>
<span class="udiff-line-modified-added">+     loadStore(C2_MacroAssembler(&amp;cbuf), &amp;MacroAssembler::ldrd, tmp_reg, $mem-&gt;opcode(),</span>
                as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);
      __ cnt($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
      __ addv($tmp$$FloatRegister, __ T8B, $tmp$$FloatRegister);
      __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);
    %}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -14976,36 +14976,36 @@</span>
    ins_short_branch(1);
  %}
  
  instruct cmpL_branch_bit(cmpOpEqNe cmp, iRegL op1, immL op2, immL0 op3, label labl) %{
    match(If cmp (CmpL (AndL op1 op2) op3));
<span class="udiff-line-modified-removed">-   predicate(is_power_of_2(n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_long()));</span>
<span class="udiff-line-modified-added">+   predicate(is_power_of_2((julong)n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_long()));</span>
    effect(USE labl);
  
    ins_cost(BRANCH_COST);
    format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
    ins_encode %{
      Label* L = $labl$$label;
      Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="udiff-line-modified-removed">-     int bit = exact_log2($op2$$constant);</span>
<span class="udiff-line-modified-added">+     int bit = exact_log2_long($op2$$constant);</span>
      __ tbr(cond, $op1$$Register, bit, *L);
    %}
    ins_pipe(pipe_cmp_branch);
    ins_short_branch(1);
  %}
  
  instruct cmpI_branch_bit(cmpOpEqNe cmp, iRegIorL2I op1, immI op2, immI0 op3, label labl) %{
    match(If cmp (CmpI (AndI op1 op2) op3));
<span class="udiff-line-modified-removed">-   predicate(is_power_of_2(n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_int()));</span>
<span class="udiff-line-modified-added">+   predicate(is_power_of_2((juint)n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_int()));</span>
    effect(USE labl);
  
    ins_cost(BRANCH_COST);
    format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
    ins_encode %{
      Label* L = $labl$$label;
      Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="udiff-line-modified-removed">-     int bit = exact_log2($op2$$constant);</span>
<span class="udiff-line-modified-added">+     int bit = exact_log2((juint)$op2$$constant);</span>
      __ tbr(cond, $op1$$Register, bit, *L);
    %}
    ins_pipe(pipe_cmp_branch);
    ins_short_branch(1);
  %}
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -15041,35 +15041,35 @@</span>
    ins_pipe(pipe_cmp_branch);
  %}
  
  instruct far_cmpL_branch_bit(cmpOpEqNe cmp, iRegL op1, immL op2, immL0 op3, label labl) %{
    match(If cmp (CmpL (AndL op1 op2) op3));
<span class="udiff-line-modified-removed">-   predicate(is_power_of_2(n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_long()));</span>
<span class="udiff-line-modified-added">+   predicate(is_power_of_2((julong)n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_long()));</span>
    effect(USE labl);
  
    ins_cost(BRANCH_COST);
    format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
    ins_encode %{
      Label* L = $labl$$label;
      Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="udiff-line-modified-removed">-     int bit = exact_log2($op2$$constant);</span>
<span class="udiff-line-modified-added">+     int bit = exact_log2_long($op2$$constant);</span>
      __ tbr(cond, $op1$$Register, bit, *L, /*far*/true);
    %}
    ins_pipe(pipe_cmp_branch);
  %}
  
  instruct far_cmpI_branch_bit(cmpOpEqNe cmp, iRegIorL2I op1, immI op2, immI0 op3, label labl) %{
    match(If cmp (CmpI (AndI op1 op2) op3));
<span class="udiff-line-modified-removed">-   predicate(is_power_of_2(n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_int()));</span>
<span class="udiff-line-modified-added">+   predicate(is_power_of_2((juint)n-&gt;in(2)-&gt;in(1)-&gt;in(2)-&gt;get_int()));</span>
    effect(USE labl);
  
    ins_cost(BRANCH_COST);
    format %{ &quot;tb$cmp   $op1, $op2, $labl&quot; %}
    ins_encode %{
      Label* L = $labl$$label;
      Assembler::Condition cond = (Assembler::Condition)$cmp$$cmpcode;
<span class="udiff-line-modified-removed">-     int bit = exact_log2($op2$$constant);</span>
<span class="udiff-line-modified-added">+     int bit = exact_log2((juint)$op2$$constant);</span>
      __ tbr(cond, $op1$$Register, bit, *L, /*far*/true);
    %}
    ins_pipe(pipe_cmp_branch);
  %}
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -17006,11 +17006,11 @@</span>
  
  instruct vmuladdS2I(vecX dst, vecX src1, vecX src2, vecX tmp) %{
    predicate(n-&gt;in(1)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_SHORT);
    match(Set dst (MulAddVS2VI src1 src2));
    ins_cost(INSN_COST);
<span class="udiff-line-modified-removed">-   effect(TEMP tmp);</span>
<span class="udiff-line-modified-added">+   effect(TEMP_DEF dst, TEMP tmp);</span>
    format %{ &quot;smullv  $tmp, $src1, $src2\t# vector (4H)\n\t&quot;
              &quot;smullv  $dst, $src1, $src2\t# vector (8H)\n\t&quot;
              &quot;addpv   $dst, $tmp, $dst\t# vector (4S)\n\t&quot; %}
    ins_encode %{
      __ smullv(as_FloatRegister($tmp$$reg), __ T4H,
</pre>
<center><a href="../../../demo/share/jfc/TableExample/TableSorter.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="c1_LIRAssembler_aarch64.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
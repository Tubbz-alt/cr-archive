<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/jfr/recorder/checkpoint/types/jfrTypeSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  27 #include &quot;classfile/javaClasses.inline.hpp&quot;
  28 #include &quot;classfile/moduleEntry.hpp&quot;
  29 #include &quot;classfile/packageEntry.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;jfr/jfr.hpp&quot;
  32 #include &quot;jfr/jni/jfrGetAllEventClasses.hpp&quot;
  33 #include &quot;jfr/leakprofiler/checkpoint/objectSampleCheckpoint.hpp&quot;
  34 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSet.hpp&quot;
  35 #include &quot;jfr/recorder/checkpoint/types/jfrTypeSetUtils.hpp&quot;
  36 #include &quot;jfr/recorder/checkpoint/types/traceid/jfrTraceId.inline.hpp&quot;
  37 #include &quot;jfr/utilities/jfrHashtable.hpp&quot;
  38 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
  39 #include &quot;jfr/writers/jfrTypeWriterHost.hpp&quot;
  40 #include &quot;memory/iterator.hpp&quot;
  41 #include &quot;memory/resourceArea.hpp&quot;
  42 #include &quot;oops/instanceKlass.hpp&quot;
  43 #include &quot;oops/objArrayKlass.hpp&quot;
  44 #include &quot;oops/oop.inline.hpp&quot;
  45 #include &quot;utilities/accessFlags.hpp&quot;
  46 #include &quot;utilities/bitMap.inline.hpp&quot;
  47 
  48 typedef const Klass* KlassPtr;
  49 typedef const PackageEntry* PkgPtr;
  50 typedef const ModuleEntry* ModPtr;
  51 typedef const ClassLoaderData* CldPtr;
  52 typedef const Method* MethodPtr;
  53 typedef const Symbol* SymbolPtr;
  54 typedef const JfrSymbolId::SymbolEntry* SymbolEntryPtr;
  55 typedef const JfrSymbolId::CStringEntry* CStringEntryPtr;
  56 
  57 static JfrCheckpointWriter* _writer = NULL;
  58 static JfrCheckpointWriter* _leakp_writer = NULL;
  59 static JfrArtifactSet* _artifacts = NULL;
  60 static JfrArtifactClosure* _subsystem_callback = NULL;
  61 static bool _class_unload = false;
  62 static bool _flushpoint = false;
  63 
  64 // incremented on each rotation
  65 static u8 checkpoint_id = 1;
  66 
  67 // creates a unique id by combining a checkpoint relative symbol id (2^24)
  68 // with the current checkpoint id (2^40)
  69 #define CREATE_SYMBOL_ID(sym_id) (((u8)((checkpoint_id &lt;&lt; 24) | sym_id)))
  70 
  71 static traceid create_symbol_id(traceid artifact_id) {
  72   return artifact_id != 0 ? CREATE_SYMBOL_ID(artifact_id) : 0;
  73 }
  74 
  75 static bool current_epoch() {
  76   return _class_unload || _flushpoint;
  77 }
  78 
  79 static bool previous_epoch() {
  80   return !current_epoch();
  81 }
  82 
  83 static bool is_complete() {
  84   return !_artifacts-&gt;has_klass_entries() &amp;&amp; current_epoch();
  85 }
  86 
  87 static traceid mark_symbol(KlassPtr klass, bool leakp) {
  88   return klass != NULL ? create_symbol_id(_artifacts-&gt;mark(klass, leakp)) : 0;
  89 }
  90 
  91 static traceid mark_symbol(Symbol* symbol, bool leakp) {
  92   return symbol != NULL ? create_symbol_id(_artifacts-&gt;mark(symbol, leakp)) : 0;
  93 }
  94 
  95 static traceid get_bootstrap_name(bool leakp) {
  96   return create_symbol_id(_artifacts-&gt;bootstrap_name(leakp));
  97 }
  98 
  99 template &lt;typename T&gt;
 100 static traceid artifact_id(const T* ptr) {
 101   assert(ptr != NULL, &quot;invariant&quot;);
 102   return TRACE_ID(ptr);
 103 }
 104 
 105 static traceid package_id(KlassPtr klass, bool leakp) {
 106   assert(klass != NULL, &quot;invariant&quot;);
 107   PkgPtr pkg_entry = klass-&gt;package();
 108   if (pkg_entry == NULL) {
 109     return 0;
 110   }
 111   if (leakp) {
 112     SET_LEAKP(pkg_entry);
 113   }
 114   // package implicitly tagged already
 115   return artifact_id(pkg_entry);
 116 }
 117 
 118 static traceid module_id(PkgPtr pkg, bool leakp) {
 119   assert(pkg != NULL, &quot;invariant&quot;);
 120   ModPtr module_entry = pkg-&gt;module();
 121   if (module_entry == NULL) {
 122     return 0;
 123   }
 124   if (leakp) {
 125     SET_LEAKP(module_entry);
 126   } else {
 127     SET_TRANSIENT(module_entry);
 128   }
 129   return artifact_id(module_entry);
 130 }
 131 
 132 static traceid method_id(KlassPtr klass, MethodPtr method) {
 133   assert(klass != NULL, &quot;invariant&quot;);
 134   assert(method != NULL, &quot;invariant&quot;);
 135   return METHOD_ID(klass, method);
 136 }
 137 
 138 static traceid cld_id(CldPtr cld, bool leakp) {
 139   assert(cld != NULL, &quot;invariant&quot;);
 140   assert(!cld-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
 141   if (leakp) {
 142     SET_LEAKP(cld);
 143   } else {
 144     SET_TRANSIENT(cld);
 145   }
 146   return artifact_id(cld);
 147 }
 148 
 149 template &lt;typename T&gt;
 150 static s4 get_flags(const T* ptr) {
 151   assert(ptr != NULL, &quot;invariant&quot;);
 152   return ptr-&gt;access_flags().get_flags();
 153 }
 154 
 155 static bool is_unsafe_anonymous(const Klass* klass) {
 156   assert(klass != NULL, &quot;invariant&quot;);
 157   assert(!klass-&gt;is_objArray_klass(), &quot;invariant&quot;);
 158   return klass-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(klass)-&gt;is_unsafe_anonymous();
 159 }
 160 
 161 static ClassLoaderData* get_cld(const Klass* klass) {
 162   assert(klass != NULL, &quot;invariant&quot;);
 163   if (klass-&gt;is_objArray_klass()) {
 164     klass = ObjArrayKlass::cast(klass)-&gt;bottom_klass();
 165   }
 166   return is_unsafe_anonymous(klass) ?
 167     InstanceKlass::cast(klass)-&gt;unsafe_anonymous_host()-&gt;class_loader_data() : klass-&gt;class_loader_data();
 168 }
 169 
 170 template &lt;typename T&gt;
 171 static void set_serialized(const T* ptr) {
 172   assert(ptr != NULL, &quot;invariant&quot;);
 173   SET_SERIALIZED(ptr);
 174   assert(IS_SERIALIZED(ptr), &quot;invariant&quot;);
 175   CLEAR_THIS_EPOCH_CLEARED_BIT(ptr);
 176 }
 177 
 178 /*
 179  * In C++03, functions used as template parameters must have external linkage;
 180  * this restriction was removed in C++11. Change back to &quot;static&quot; and
 181  * rename functions when C++11 becomes available.
 182  *
 183  * The weird naming is an effort to decrease the risk of name clashes.
 184  */
 185 
 186 static int write_klass(JfrCheckpointWriter* writer, KlassPtr klass, bool leakp) {
 187   assert(writer != NULL, &quot;invariant&quot;);
 188   assert(_artifacts != NULL, &quot;invariant&quot;);
 189   assert(klass != NULL, &quot;invariant&quot;);
 190   writer-&gt;write(artifact_id(klass));
 191   writer-&gt;write(cld_id(get_cld(klass), leakp));
 192   writer-&gt;write(mark_symbol(klass, leakp));
 193   writer-&gt;write(package_id(klass, leakp));
 194   writer-&gt;write(get_flags(klass));
 195   return 1;
 196 }
 197 
 198 int write__klass(JfrCheckpointWriter* writer, const void* k) {
 199   assert(k != NULL, &quot;invariant&quot;);
 200   KlassPtr klass = (KlassPtr)k;
 201   set_serialized(klass);
 202   return write_klass(writer, klass, false);
 203 }
 204 
 205 int write__klass__leakp(JfrCheckpointWriter* writer, const void* k) {
 206   assert(k != NULL, &quot;invariant&quot;);
 207   KlassPtr klass = (KlassPtr)k;
 208   return write_klass(writer, klass, true);
 209 }
 210 
 211 static bool is_implied(const Klass* klass) {
 212   assert(klass != NULL, &quot;invariant&quot;);
 213   return klass-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass()) || klass == SystemDictionary::Object_klass();
 214 }
 215 
 216 static void do_implied(Klass* klass) {
 217   assert(klass != NULL, &quot;invariant&quot;);
 218   if (is_implied(klass)) {
 219     if (_leakp_writer != NULL) {
 220       SET_LEAKP(klass);
 221     }
 222     _subsystem_callback-&gt;do_artifact(klass);
 223   }
 224 }
 225 
 226 static void do_unloaded_klass(Klass* klass) {
 227   assert(klass != NULL, &quot;invariant&quot;);
 228   assert(_subsystem_callback != NULL, &quot;invariant&quot;);
 229   if (IS_JDK_JFR_EVENT_SUBKLASS(klass)) {
 230     JfrEventClasses::increment_unloaded_event_class();
 231   }
 232   if (USED_THIS_EPOCH(klass)) {
 233     ObjectSampleCheckpoint::on_klass_unload(klass);
 234     _subsystem_callback-&gt;do_artifact(klass);
 235     return;
 236   }
 237   do_implied(klass);
 238 }
 239 
 240 static void do_klass(Klass* klass) {
 241   assert(klass != NULL, &quot;invariant&quot;);
 242   assert(_subsystem_callback != NULL, &quot;invariant&quot;);
 243   if (_flushpoint) {
 244     if (USED_THIS_EPOCH(klass)) {
 245       _subsystem_callback-&gt;do_artifact(klass);
 246       return;
 247     }
 248   } else {
 249     if (USED_PREV_EPOCH(klass)) {
 250       _subsystem_callback-&gt;do_artifact(klass);
 251       return;
 252     }
 253   }
 254   do_implied(klass);
 255 }
 256 
 257 static void do_klasses() {
 258   if (_class_unload) {
 259     ClassLoaderDataGraph::classes_unloading_do(&amp;do_unloaded_klass);
 260     return;
 261   }
 262   ClassLoaderDataGraph::classes_do(&amp;do_klass);
 263 }
 264 
 265 typedef SerializePredicate&lt;KlassPtr&gt; KlassPredicate;
 266 typedef JfrPredicatedTypeWriterImplHost&lt;KlassPtr, KlassPredicate, write__klass&gt; KlassWriterImpl;
 267 typedef JfrTypeWriterHost&lt;KlassWriterImpl, TYPE_CLASS&gt; KlassWriter;
 268 typedef CompositeFunctor&lt;KlassPtr, KlassWriter, KlassArtifactRegistrator&gt; KlassWriterRegistration;
 269 typedef JfrArtifactCallbackHost&lt;KlassPtr, KlassWriterRegistration&gt; KlassCallback;
 270 
 271 template &lt;&gt;
 272 class LeakPredicate&lt;const Klass*&gt; {
 273 public:
 274   LeakPredicate(bool class_unload) {}
 275   bool operator()(const Klass* klass) {
 276     assert(klass != NULL, &quot;invariant&quot;);
 277     return IS_LEAKP(klass) || is_implied(klass);
 278   }
 279 };
 280 
 281 typedef LeakPredicate&lt;KlassPtr&gt; LeakKlassPredicate;
 282 typedef JfrPredicatedTypeWriterImplHost&lt;KlassPtr, LeakKlassPredicate, write__klass__leakp&gt; LeakKlassWriterImpl;
 283 typedef JfrTypeWriterHost&lt;LeakKlassWriterImpl, TYPE_CLASS&gt; LeakKlassWriter;
 284 
 285 typedef CompositeFunctor&lt;KlassPtr, LeakKlassWriter, KlassWriter&gt; CompositeKlassWriter;
 286 typedef CompositeFunctor&lt;KlassPtr, CompositeKlassWriter, KlassArtifactRegistrator&gt; CompositeKlassWriterRegistration;
 287 typedef JfrArtifactCallbackHost&lt;KlassPtr, CompositeKlassWriterRegistration&gt; CompositeKlassCallback;
 288 
 289 static bool write_klasses() {
 290   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
 291   assert(_writer != NULL, &quot;invariant&quot;);
 292   KlassArtifactRegistrator reg(_artifacts);
 293   KlassWriter kw(_writer, _class_unload);
 294   KlassWriterRegistration kwr(&amp;kw, &amp;reg);
 295   if (_leakp_writer == NULL) {
 296     KlassCallback callback(&amp;kwr);
 297     _subsystem_callback = &amp;callback;
 298     do_klasses();
 299   } else {
 300     LeakKlassWriter lkw(_leakp_writer, _class_unload);
 301     CompositeKlassWriter ckw(&amp;lkw, &amp;kw);
 302     CompositeKlassWriterRegistration ckwr(&amp;ckw, &amp;reg);
 303     CompositeKlassCallback callback(&amp;ckwr);
 304     _subsystem_callback = &amp;callback;
 305     do_klasses();
 306   }
 307   if (is_complete()) {
 308     return false;
 309   }
 310   _artifacts-&gt;tally(kw);
 311   return true;
 312 }
 313 
 314 template &lt;typename T&gt;
 315 static void do_previous_epoch_artifact(JfrArtifactClosure* callback, T* value) {
 316   assert(callback != NULL, &quot;invariant&quot;);
 317   assert(value != NULL, &quot;invariant&quot;);
 318   if (USED_PREV_EPOCH(value)) {
 319     callback-&gt;do_artifact(value);
 320     assert(IS_NOT_SERIALIZED(value), &quot;invariant&quot;);
 321     return;
 322   }
 323   if (IS_SERIALIZED(value)) {
 324     CLEAR_SERIALIZED(value);
 325   }
 326   assert(IS_NOT_SERIALIZED(value), &quot;invariant&quot;);
 327 }
 328 
 329 typedef JfrArtifactCallbackHost&lt;KlassPtr, KlassArtifactRegistrator&gt; RegistrationCallback;
 330 
 331 static void register_klass(Klass* klass) {
 332   assert(klass != NULL, &quot;invariant&quot;);
 333   assert(_subsystem_callback != NULL, &quot;invariant&quot;);
 334   do_previous_epoch_artifact(_subsystem_callback, klass);
 335 }
 336 
 337 static void do_register_klasses() {
 338   ClassLoaderDataGraph::classes_do(&amp;register_klass);
 339 }
 340 
 341 static void register_klasses() {
 342   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
 343   KlassArtifactRegistrator reg(_artifacts);
 344   RegistrationCallback callback(&amp;reg);
 345   _subsystem_callback = &amp;callback;
 346   do_register_klasses();
 347 }
 348 
 349 static int write_package(JfrCheckpointWriter* writer, PkgPtr pkg, bool leakp) {
 350   assert(writer != NULL, &quot;invariant&quot;);
 351   assert(_artifacts != NULL, &quot;invariant&quot;);
 352   assert(pkg != NULL, &quot;invariant&quot;);
 353   writer-&gt;write(artifact_id(pkg));
 354   writer-&gt;write(mark_symbol(pkg-&gt;name(), leakp));
 355   writer-&gt;write(module_id(pkg, leakp));
 356   writer-&gt;write((bool)pkg-&gt;is_exported());
 357   return 1;
 358 }
 359 
 360 int write__package(JfrCheckpointWriter* writer, const void* p) {
 361   assert(p != NULL, &quot;invariant&quot;);
 362   PkgPtr pkg = (PkgPtr)p;
 363   set_serialized(pkg);
 364   return write_package(writer, pkg, false);
 365 }
 366 
 367 int write__package__leakp(JfrCheckpointWriter* writer, const void* p) {
 368   assert(p != NULL, &quot;invariant&quot;);
 369   PkgPtr pkg = (PkgPtr)p;
 370   CLEAR_LEAKP(pkg);
 371   return write_package(writer, pkg, true);
 372 }
 373 
 374 static void do_package(PackageEntry* entry) {
 375   do_previous_epoch_artifact(_subsystem_callback, entry);
 376 }
 377 
 378 static void do_packages() {
 379   ClassLoaderDataGraph::packages_do(&amp;do_package);
 380 }
 381 
 382 class PackageFieldSelector {
 383  public:
 384   typedef PkgPtr TypePtr;
 385   static TypePtr select(KlassPtr klass) {
 386     assert(klass != NULL, &quot;invariant&quot;);
 387     return klass-&gt;package();
 388   }
 389 };
 390 
 391 typedef SerializePredicate&lt;PkgPtr&gt; PackagePredicate;
 392 typedef JfrPredicatedTypeWriterImplHost&lt;PkgPtr, PackagePredicate, write__package&gt; PackageWriterImpl;
 393 typedef JfrTypeWriterHost&lt;PackageWriterImpl, TYPE_PACKAGE&gt; PackageWriter;
 394 typedef CompositeFunctor&lt;PkgPtr, PackageWriter, ClearArtifact&lt;PkgPtr&gt; &gt; PackageWriterWithClear;
 395 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, PackageWriter&gt; KlassPackageWriter;
 396 typedef JfrArtifactCallbackHost&lt;PkgPtr, PackageWriterWithClear&gt; PackageCallback;
 397 
 398 typedef LeakPredicate&lt;PkgPtr&gt; LeakPackagePredicate;
 399 typedef JfrPredicatedTypeWriterImplHost&lt;PkgPtr, LeakPackagePredicate, write__package__leakp&gt; LeakPackageWriterImpl;
 400 typedef JfrTypeWriterHost&lt;LeakPackageWriterImpl, TYPE_PACKAGE&gt; LeakPackageWriter;
 401 
 402 typedef CompositeFunctor&lt;PkgPtr, LeakPackageWriter, PackageWriter&gt; CompositePackageWriter;
 403 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, CompositePackageWriter&gt; KlassCompositePackageWriter;
 404 typedef KlassToFieldEnvelope&lt;PackageFieldSelector, PackageWriterWithClear&gt; KlassPackageWriterWithClear;
 405 typedef CompositeFunctor&lt;PkgPtr, CompositePackageWriter, ClearArtifact&lt;PkgPtr&gt; &gt; CompositePackageWriterWithClear;
 406 typedef JfrArtifactCallbackHost&lt;PkgPtr, CompositePackageWriterWithClear&gt; CompositePackageCallback;
 407 
 408 static void write_packages() {
 409   assert(_writer != NULL, &quot;invariant&quot;);
 410   PackageWriter pw(_writer, _class_unload);
 411   KlassPackageWriter kpw(&amp;pw);
 412   if (current_epoch()) {
 413     _artifacts-&gt;iterate_klasses(kpw);
 414     _artifacts-&gt;tally(pw);
 415     return;
 416   }
 417   assert(previous_epoch(), &quot;invariant&quot;);
 418   if (_leakp_writer == NULL) {
 419     _artifacts-&gt;iterate_klasses(kpw);
 420     ClearArtifact&lt;PkgPtr&gt; clear;
 421     PackageWriterWithClear pwwc(&amp;pw, &amp;clear);
 422     PackageCallback callback(&amp;pwwc);
 423     _subsystem_callback = &amp;callback;
 424     do_packages();
 425   } else {
 426     LeakPackageWriter lpw(_leakp_writer, _class_unload);
 427     CompositePackageWriter cpw(&amp;lpw, &amp;pw);
 428     KlassCompositePackageWriter kcpw(&amp;cpw);
 429     _artifacts-&gt;iterate_klasses(kcpw);
 430     ClearArtifact&lt;PkgPtr&gt; clear;
 431     CompositePackageWriterWithClear cpwwc(&amp;cpw, &amp;clear);
 432     CompositePackageCallback callback(&amp;cpwwc);
 433     _subsystem_callback = &amp;callback;
 434     do_packages();
 435   }
 436   _artifacts-&gt;tally(pw);
 437 }
 438 
 439 typedef JfrArtifactCallbackHost&lt;PkgPtr, ClearArtifact&lt;PkgPtr&gt; &gt; ClearPackageCallback;
 440 
 441 static void clear_packages() {
 442   ClearArtifact&lt;PkgPtr&gt; clear;
 443   ClearPackageCallback callback(&amp;clear);
 444   _subsystem_callback = &amp;callback;
 445   do_packages();
 446 }
 447 
 448 static int write_module(JfrCheckpointWriter* writer, ModPtr mod, bool leakp) {
 449   assert(mod != NULL, &quot;invariant&quot;);
 450   assert(_artifacts != NULL, &quot;invariant&quot;);
 451   writer-&gt;write(artifact_id(mod));
 452   writer-&gt;write(mark_symbol(mod-&gt;name(), leakp));
 453   writer-&gt;write(mark_symbol(mod-&gt;version(), leakp));
 454   writer-&gt;write(mark_symbol(mod-&gt;location(), leakp));
 455   writer-&gt;write(cld_id(mod-&gt;loader_data(), leakp));
 456   return 1;
 457 }
 458 
 459 int write__module(JfrCheckpointWriter* writer, const void* m) {
 460   assert(m != NULL, &quot;invariant&quot;);
 461   ModPtr mod = (ModPtr)m;
 462   set_serialized(mod);
 463   return write_module(writer, mod, false);
 464 }
 465 
 466 int write__module__leakp(JfrCheckpointWriter* writer, const void* m) {
 467   assert(m != NULL, &quot;invariant&quot;);
 468   ModPtr mod = (ModPtr)m;
 469   CLEAR_LEAKP(mod);
 470   return write_module(writer, mod, true);
 471 }
 472 
 473 static void do_module(ModuleEntry* entry) {
 474   do_previous_epoch_artifact(_subsystem_callback, entry);
 475 }
 476 
 477 static void do_modules() {
 478   ClassLoaderDataGraph::modules_do(&amp;do_module);
 479 }
 480 
 481 class ModuleFieldSelector {
 482  public:
 483   typedef ModPtr TypePtr;
 484   static TypePtr select(KlassPtr klass) {
 485     assert(klass != NULL, &quot;invariant&quot;);
 486     PkgPtr pkg = klass-&gt;package();
 487     return pkg != NULL ? pkg-&gt;module() : NULL;
 488   }
 489 };
 490 
 491 typedef SerializePredicate&lt;ModPtr&gt; ModulePredicate;
 492 typedef JfrPredicatedTypeWriterImplHost&lt;ModPtr, ModulePredicate, write__module&gt; ModuleWriterImpl;
 493 typedef JfrTypeWriterHost&lt;ModuleWriterImpl, TYPE_MODULE&gt; ModuleWriter;
 494 typedef CompositeFunctor&lt;ModPtr, ModuleWriter, ClearArtifact&lt;ModPtr&gt; &gt; ModuleWriterWithClear;
 495 typedef JfrArtifactCallbackHost&lt;ModPtr, ModuleWriterWithClear&gt; ModuleCallback;
 496 typedef KlassToFieldEnvelope&lt;ModuleFieldSelector, ModuleWriter&gt; KlassModuleWriter;
 497 
 498 typedef LeakPredicate&lt;ModPtr&gt; LeakModulePredicate;
 499 typedef JfrPredicatedTypeWriterImplHost&lt;ModPtr, LeakModulePredicate, write__module__leakp&gt; LeakModuleWriterImpl;
 500 typedef JfrTypeWriterHost&lt;LeakModuleWriterImpl, TYPE_MODULE&gt; LeakModuleWriter;
 501 
 502 typedef CompositeFunctor&lt;ModPtr, LeakModuleWriter, ModuleWriter&gt; CompositeModuleWriter;
 503 typedef KlassToFieldEnvelope&lt;ModuleFieldSelector, CompositeModuleWriter&gt; KlassCompositeModuleWriter;
 504 typedef CompositeFunctor&lt;ModPtr, CompositeModuleWriter, ClearArtifact&lt;ModPtr&gt; &gt; CompositeModuleWriterWithClear;
 505 typedef JfrArtifactCallbackHost&lt;ModPtr, CompositeModuleWriterWithClear&gt; CompositeModuleCallback;
 506 
 507 static void write_modules() {
 508   assert(_writer != NULL, &quot;invariant&quot;);
 509   ModuleWriter mw(_writer, _class_unload);
 510   KlassModuleWriter kmw(&amp;mw);
 511   if (current_epoch()) {
 512     _artifacts-&gt;iterate_klasses(kmw);
 513     _artifacts-&gt;tally(mw);
 514     return;
 515   }
 516   assert(previous_epoch(), &quot;invariant&quot;);
 517   if (_leakp_writer == NULL) {
 518     _artifacts-&gt;iterate_klasses(kmw);
 519     ClearArtifact&lt;ModPtr&gt; clear;
 520     ModuleWriterWithClear mwwc(&amp;mw, &amp;clear);
 521     ModuleCallback callback(&amp;mwwc);
 522     _subsystem_callback = &amp;callback;
 523     do_modules();
 524   } else {
 525     LeakModuleWriter lmw(_leakp_writer, _class_unload);
 526     CompositeModuleWriter cmw(&amp;lmw, &amp;mw);
 527     KlassCompositeModuleWriter kcpw(&amp;cmw);
 528     _artifacts-&gt;iterate_klasses(kcpw);
 529     ClearArtifact&lt;ModPtr&gt; clear;
 530     CompositeModuleWriterWithClear cmwwc(&amp;cmw, &amp;clear);
 531     CompositeModuleCallback callback(&amp;cmwwc);
 532     _subsystem_callback = &amp;callback;
 533     do_modules();
 534   }
 535   _artifacts-&gt;tally(mw);
 536 }
 537 
 538 typedef JfrArtifactCallbackHost&lt;ModPtr, ClearArtifact&lt;ModPtr&gt; &gt; ClearModuleCallback;
 539 
 540 static void clear_modules() {
 541   ClearArtifact&lt;ModPtr&gt; clear;
 542   ClearModuleCallback callback(&amp;clear);
 543   _subsystem_callback = &amp;callback;
 544   do_modules();
 545 }
 546 
 547 static int write_classloader(JfrCheckpointWriter* writer, CldPtr cld, bool leakp) {
 548   assert(cld != NULL, &quot;invariant&quot;);
 549   assert(!cld-&gt;is_unsafe_anonymous(), &quot;invariant&quot;);
 550   // class loader type
 551   const Klass* class_loader_klass = cld-&gt;class_loader_klass();
 552   if (class_loader_klass == NULL) {
 553     // (primordial) boot class loader
 554     writer-&gt;write(artifact_id(cld)); // class loader instance id
 555     writer-&gt;write((traceid)0);  // class loader type id (absence of)
 556     writer-&gt;write(get_bootstrap_name(leakp)); // maps to synthetic name -&gt; &quot;bootstrap&quot;
 557   } else {
 558     writer-&gt;write(artifact_id(cld)); // class loader instance id
 559     writer-&gt;write(artifact_id(class_loader_klass)); // class loader type id
 560     writer-&gt;write(mark_symbol(cld-&gt;name(), leakp)); // class loader instance name
 561   }
 562   return 1;
 563 }
 564 
 565 int write__classloader(JfrCheckpointWriter* writer, const void* c) {
 566   assert(c != NULL, &quot;invariant&quot;);
 567   CldPtr cld = (CldPtr)c;
 568   set_serialized(cld);
 569   return write_classloader(writer, cld, false);
 570 }
 571 
 572 int write__classloader__leakp(JfrCheckpointWriter* writer, const void* c) {
 573   assert(c != NULL, &quot;invariant&quot;);
 574   CldPtr cld = (CldPtr)c;
 575   CLEAR_LEAKP(cld);
 576   return write_classloader(writer, cld, true);
 577 }
 578 
 579 static void do_class_loader_data(ClassLoaderData* cld) {
 580   do_previous_epoch_artifact(_subsystem_callback, cld);
 581 }
 582 
 583 class KlassCldFieldSelector {
 584  public:
 585   typedef CldPtr TypePtr;
 586   static TypePtr select(KlassPtr klass) {
 587     assert(klass != NULL, &quot;invariant&quot;);
 588     return get_cld(klass);
 589   }
 590 };
 591 
 592 class ModuleCldFieldSelector {
 593 public:
 594   typedef CldPtr TypePtr;
 595   static TypePtr select(KlassPtr klass) {
 596     assert(klass != NULL, &quot;invariant&quot;);
 597     ModPtr mod = ModuleFieldSelector::select(klass);
 598     return mod != NULL ? mod-&gt;loader_data() : NULL;
 599   }
 600 };
 601 
 602 class CLDCallback : public CLDClosure {
 603  public:
 604   CLDCallback() {}
 605   void do_cld(ClassLoaderData* cld) {
 606     assert(cld != NULL, &quot;invariant&quot;);
 607     if (cld-&gt;is_unsafe_anonymous()) {
 608       return;
 609     }
 610     do_class_loader_data(cld);
 611   }
 612 };
 613 
 614 static void do_class_loaders() {
 615   CLDCallback cld_cb;
 616   ClassLoaderDataGraph::loaded_cld_do(&amp;cld_cb);
 617 }
 618 
 619 typedef SerializePredicate&lt;CldPtr&gt; CldPredicate;
 620 typedef JfrPredicatedTypeWriterImplHost&lt;CldPtr, CldPredicate, write__classloader&gt; CldWriterImpl;
 621 typedef JfrTypeWriterHost&lt;CldWriterImpl, TYPE_CLASSLOADER&gt; CldWriter;
 622 typedef CompositeFunctor&lt;CldPtr, CldWriter, ClearArtifact&lt;CldPtr&gt; &gt; CldWriterWithClear;
 623 typedef JfrArtifactCallbackHost&lt;CldPtr, CldWriterWithClear&gt; CldCallback;
 624 typedef KlassToFieldEnvelope&lt;KlassCldFieldSelector, CldWriter&gt; KlassCldWriter;
 625 typedef KlassToFieldEnvelope&lt;ModuleCldFieldSelector, CldWriter&gt; ModuleCldWriter;
 626 typedef CompositeFunctor&lt;KlassPtr, KlassCldWriter, ModuleCldWriter&gt; KlassAndModuleCldWriter;
 627 
 628 typedef LeakPredicate&lt;CldPtr&gt; LeakCldPredicate;
 629 typedef JfrPredicatedTypeWriterImplHost&lt;CldPtr, LeakCldPredicate, write__classloader__leakp&gt; LeakCldWriterImpl;
 630 typedef JfrTypeWriterHost&lt;LeakCldWriterImpl, TYPE_CLASSLOADER&gt; LeakCldWriter;
 631 
 632 typedef CompositeFunctor&lt;CldPtr, LeakCldWriter, CldWriter&gt; CompositeCldWriter;
 633 typedef KlassToFieldEnvelope&lt;KlassCldFieldSelector, CompositeCldWriter&gt; KlassCompositeCldWriter;
 634 typedef KlassToFieldEnvelope&lt;ModuleCldFieldSelector, CompositeCldWriter&gt; ModuleCompositeCldWriter;
 635 typedef CompositeFunctor&lt;KlassPtr, KlassCompositeCldWriter, ModuleCompositeCldWriter&gt; KlassAndModuleCompositeCldWriter;
 636 typedef CompositeFunctor&lt;CldPtr, CompositeCldWriter, ClearArtifact&lt;CldPtr&gt; &gt; CompositeCldWriterWithClear;
 637 typedef JfrArtifactCallbackHost&lt;CldPtr, CompositeCldWriterWithClear&gt; CompositeCldCallback;
 638 
 639 static void write_classloaders() {
 640   assert(_writer != NULL, &quot;invariant&quot;);
 641   CldWriter cldw(_writer, _class_unload);
 642   KlassCldWriter kcw(&amp;cldw);
 643   ModuleCldWriter mcw(&amp;cldw);
 644   KlassAndModuleCldWriter kmcw(&amp;kcw, &amp;mcw);
 645   if (current_epoch()) {
 646     _artifacts-&gt;iterate_klasses(kmcw);
 647     _artifacts-&gt;tally(cldw);
 648     return;
 649   }
 650   assert(previous_epoch(), &quot;invariant&quot;);
 651   if (_leakp_writer == NULL) {
 652     _artifacts-&gt;iterate_klasses(kmcw);
 653     ClearArtifact&lt;CldPtr&gt; clear;
 654     CldWriterWithClear cldwwc(&amp;cldw, &amp;clear);
 655     CldCallback callback(&amp;cldwwc);
 656     _subsystem_callback = &amp;callback;
 657     do_class_loaders();
 658   } else {
 659     LeakCldWriter lcldw(_leakp_writer, _class_unload);
 660     CompositeCldWriter ccldw(&amp;lcldw, &amp;cldw);
 661     KlassCompositeCldWriter kccldw(&amp;ccldw);
 662     ModuleCompositeCldWriter mccldw(&amp;ccldw);
 663     KlassAndModuleCompositeCldWriter kmccldw(&amp;kccldw, &amp;mccldw);
 664     _artifacts-&gt;iterate_klasses(kmccldw);
 665     ClearArtifact&lt;CldPtr&gt; clear;
 666     CompositeCldWriterWithClear ccldwwc(&amp;ccldw, &amp;clear);
 667     CompositeCldCallback callback(&amp;ccldwwc);
 668     _subsystem_callback = &amp;callback;
 669     do_class_loaders();
 670   }
 671   _artifacts-&gt;tally(cldw);
 672 }
 673 
 674 typedef JfrArtifactCallbackHost&lt;CldPtr, ClearArtifact&lt;CldPtr&gt; &gt; ClearCLDCallback;
 675 
 676 static void clear_classloaders() {
 677   ClearArtifact&lt;CldPtr&gt; clear;
 678   ClearCLDCallback callback(&amp;clear);
 679   _subsystem_callback = &amp;callback;
 680   do_class_loaders();
 681 }
 682 
 683 static u1 get_visibility(MethodPtr method) {
 684   assert(method != NULL, &quot;invariant&quot;);
 685   return const_cast&lt;Method*&gt;(method)-&gt;is_hidden() ? (u1)1 : (u1)0;
 686 }
 687 
 688 template &lt;&gt;
 689 void set_serialized&lt;Method&gt;(MethodPtr method) {
 690   assert(method != NULL, &quot;invariant&quot;);
 691   SET_METHOD_SERIALIZED(method);
 692   assert(IS_METHOD_SERIALIZED(method), &quot;invariant&quot;);
 693   CLEAR_THIS_EPOCH_METHOD_CLEARED_BIT(method);
 694 }
 695 
 696 static int write_method(JfrCheckpointWriter* writer, MethodPtr method, bool leakp) {
 697   assert(writer != NULL, &quot;invariant&quot;);
 698   assert(method != NULL, &quot;invariant&quot;);
 699   assert(_artifacts != NULL, &quot;invariant&quot;);
 700   KlassPtr klass = method-&gt;method_holder();
 701   assert(klass != NULL, &quot;invariant&quot;);
 702   writer-&gt;write(method_id(klass, method));
 703   writer-&gt;write(artifact_id(klass));
 704   writer-&gt;write(mark_symbol(method-&gt;name(), leakp));
 705   writer-&gt;write(mark_symbol(method-&gt;signature(), leakp));
 706   writer-&gt;write((u2)get_flags(method));
 707   writer-&gt;write(get_visibility(method));
 708   return 1;
 709 }
 710 
 711 int write__method(JfrCheckpointWriter* writer, const void* m) {
 712   assert(m != NULL, &quot;invariant&quot;);
 713   MethodPtr method = (MethodPtr)m;
 714   set_serialized(method);
 715   return write_method(writer, method, false);
 716 }
 717 
 718 int write__method__leakp(JfrCheckpointWriter* writer, const void* m) {
 719   assert(m != NULL, &quot;invariant&quot;);
 720   MethodPtr method = (MethodPtr)m;
 721   return write_method(writer, method, true);
 722 }
 723 
 724 class BitMapFilter {
 725   ResourceBitMap _bitmap;
 726  public:
 727   explicit BitMapFilter(int length = 0) : _bitmap((size_t)length) {}
 728   bool operator()(size_t idx) {
 729     if (_bitmap.size() == 0) {
 730       return true;
 731     }
 732     if (_bitmap.at(idx)) {
 733       return false;
 734     }
 735     _bitmap.set_bit(idx);
 736     return true;
 737   }
 738 };
 739 
 740 class AlwaysTrue {
 741  public:
 742   explicit AlwaysTrue(int length = 0) {}
 743   bool operator()(size_t idx) {
 744     return true;
 745   }
 746 };
 747 
 748 template &lt;typename MethodCallback, typename KlassCallback, class Filter, bool leakp&gt;
 749 class MethodIteratorHost {
 750  private:
 751   MethodCallback _method_cb;
 752   KlassCallback _klass_cb;
 753   MethodUsedPredicate&lt;leakp&gt; _method_used_predicate;
 754   MethodFlagPredicate&lt;leakp&gt; _method_flag_predicate;
 755  public:
 756   MethodIteratorHost(JfrCheckpointWriter* writer,
 757                      bool current_epoch = false,
 758                      bool class_unload = false,
 759                      bool skip_header = false) :
 760     _method_cb(writer, class_unload, skip_header),
 761     _klass_cb(writer, class_unload, skip_header),
 762     _method_used_predicate(current_epoch),
 763     _method_flag_predicate(current_epoch) {}
 764 
 765   bool operator()(KlassPtr klass) {
 766     if (_method_used_predicate(klass)) {
 767       const InstanceKlass* ik = InstanceKlass::cast(klass);
 768       const int len = ik-&gt;methods()-&gt;length();
 769       Filter filter(ik-&gt;previous_versions() != NULL ? len : 0);
 770       while (ik != NULL) {
 771         for (int i = 0; i &lt; len; ++i) {
 772           MethodPtr method = ik-&gt;methods()-&gt;at(i);
 773           if (_method_flag_predicate(method) &amp;&amp; filter(i)) {
 774             _method_cb(method);
 775           }
 776         }
 777         // There can be multiple versions of the same method running
 778         // due to redefinition. Need to inspect the complete set of methods.
 779         ik = ik-&gt;previous_versions();
 780       }
 781     }
 782     return _klass_cb(klass);
 783   }
 784 
 785   int count() const { return _method_cb.count(); }
 786   void add(int count) { _method_cb.add(count); }
 787 };
 788 
 789 template &lt;typename T, template &lt;typename&gt; class Impl&gt;
 790 class Wrapper {
 791   Impl&lt;T&gt; _t;
 792  public:
 793   Wrapper(JfrCheckpointWriter*, bool, bool) : _t() {}
 794   bool operator()(T const&amp; value) {
 795     return _t(value);
 796   }
 797 };
 798 
 799 template &lt;typename T&gt;
 800 class EmptyStub {
 801  public:
 802   bool operator()(T const&amp; value) { return true; }
 803 };
 804 
 805 typedef SerializePredicate&lt;MethodPtr&gt; MethodPredicate;
 806 typedef JfrPredicatedTypeWriterImplHost&lt;MethodPtr, MethodPredicate, write__method&gt; MethodWriterImplTarget;
 807 typedef Wrapper&lt;KlassPtr, EmptyStub&gt; KlassCallbackStub;
 808 typedef JfrTypeWriterHost&lt;MethodWriterImplTarget, TYPE_METHOD&gt; MethodWriterImpl;
 809 typedef MethodIteratorHost&lt;MethodWriterImpl, KlassCallbackStub, BitMapFilter, false&gt; MethodWriter;
 810 
 811 typedef LeakPredicate&lt;MethodPtr&gt; LeakMethodPredicate;
 812 typedef JfrPredicatedTypeWriterImplHost&lt;MethodPtr, LeakMethodPredicate, write__method__leakp&gt; LeakMethodWriterImplTarget;
 813 typedef JfrTypeWriterHost&lt;LeakMethodWriterImplTarget, TYPE_METHOD&gt; LeakMethodWriterImpl;
 814 typedef MethodIteratorHost&lt;LeakMethodWriterImpl, KlassCallbackStub, BitMapFilter, true&gt; LeakMethodWriter;
 815 typedef MethodIteratorHost&lt;LeakMethodWriterImpl, KlassCallbackStub, BitMapFilter, true&gt; LeakMethodWriter;
 816 typedef CompositeFunctor&lt;KlassPtr, LeakMethodWriter, MethodWriter&gt; CompositeMethodWriter;
 817 
 818 static void write_methods() {
 819   assert(_writer != NULL, &quot;invariant&quot;);
 820   MethodWriter mw(_writer, current_epoch(), _class_unload);
 821   if (_leakp_writer == NULL) {
 822     _artifacts-&gt;iterate_klasses(mw);
 823   } else {
 824     LeakMethodWriter lpmw(_leakp_writer, current_epoch(), _class_unload);
 825     CompositeMethodWriter cmw(&amp;lpmw, &amp;mw);
 826     _artifacts-&gt;iterate_klasses(cmw);
 827   }
 828   _artifacts-&gt;tally(mw);
 829 }
 830 
 831 template &lt;&gt;
 832 void set_serialized&lt;JfrSymbolId::SymbolEntry&gt;(SymbolEntryPtr ptr) {
 833   assert(ptr != NULL, &quot;invariant&quot;);
 834   ptr-&gt;set_serialized();
 835   assert(ptr-&gt;is_serialized(), &quot;invariant&quot;);
 836 }
 837 
 838 template &lt;&gt;
 839 void set_serialized&lt;JfrSymbolId::CStringEntry&gt;(CStringEntryPtr ptr) {
 840   assert(ptr != NULL, &quot;invariant&quot;);
 841   ptr-&gt;set_serialized();
 842   assert(ptr-&gt;is_serialized(), &quot;invariant&quot;);
 843 }
 844 
 845 static int write_symbol(JfrCheckpointWriter* writer, SymbolEntryPtr entry, bool leakp) {
 846   assert(writer != NULL, &quot;invariant&quot;);
 847   assert(entry != NULL, &quot;invariant&quot;);
 848   ResourceMark rm;
 849   writer-&gt;write(create_symbol_id(entry-&gt;id()));
 850   writer-&gt;write(entry-&gt;value()-&gt;as_C_string());
 851   return 1;
 852 }
 853 
 854 int write__symbol(JfrCheckpointWriter* writer, const void* e) {
 855   assert(e != NULL, &quot;invariant&quot;);
 856   SymbolEntryPtr entry = (SymbolEntryPtr)e;
 857   set_serialized(entry);
 858   return write_symbol(writer, entry, false);
 859 }
 860 
 861 int write__symbol__leakp(JfrCheckpointWriter* writer, const void* e) {
 862   assert(e != NULL, &quot;invariant&quot;);
 863   SymbolEntryPtr entry = (SymbolEntryPtr)e;
 864   return write_symbol(writer, entry, true);
 865 }
 866 
 867 static int write_cstring(JfrCheckpointWriter* writer, CStringEntryPtr entry, bool leakp) {
 868   assert(writer != NULL, &quot;invariant&quot;);
 869   assert(entry != NULL, &quot;invariant&quot;);
 870   writer-&gt;write(create_symbol_id(entry-&gt;id()));
 871   writer-&gt;write(entry-&gt;value());
 872   return 1;
 873 }
 874 
 875 int write__cstring(JfrCheckpointWriter* writer, const void* e) {
 876   assert(e != NULL, &quot;invariant&quot;);
 877   CStringEntryPtr entry = (CStringEntryPtr)e;
 878   set_serialized(entry);
 879   return write_cstring(writer, entry, false);
 880 }
 881 
 882 int write__cstring__leakp(JfrCheckpointWriter* writer, const void* e) {
 883   assert(e != NULL, &quot;invariant&quot;);
 884   CStringEntryPtr entry = (CStringEntryPtr)e;
 885   return write_cstring(writer, entry, true);
 886 }
 887 
 888 typedef SymbolPredicate&lt;SymbolEntryPtr, false&gt; SymPredicate;
 889 typedef JfrPredicatedTypeWriterImplHost&lt;SymbolEntryPtr, SymPredicate, write__symbol&gt; SymbolEntryWriterImpl;
 890 typedef JfrTypeWriterHost&lt;SymbolEntryWriterImpl, TYPE_SYMBOL&gt; SymbolEntryWriter;
 891 typedef SymbolPredicate&lt;CStringEntryPtr, false&gt; CStringPredicate;
 892 typedef JfrPredicatedTypeWriterImplHost&lt;CStringEntryPtr, CStringPredicate, write__cstring&gt; CStringEntryWriterImpl;
 893 typedef JfrTypeWriterHost&lt;CStringEntryWriterImpl, TYPE_SYMBOL&gt; CStringEntryWriter;
 894 
 895 typedef SymbolPredicate&lt;SymbolEntryPtr, true&gt; LeakSymPredicate;
 896 typedef JfrPredicatedTypeWriterImplHost&lt;SymbolEntryPtr, LeakSymPredicate, write__symbol__leakp&gt; LeakSymbolEntryWriterImpl;
 897 typedef JfrTypeWriterHost&lt;LeakSymbolEntryWriterImpl, TYPE_SYMBOL&gt; LeakSymbolEntryWriter;
 898 typedef CompositeFunctor&lt;SymbolEntryPtr, LeakSymbolEntryWriter, SymbolEntryWriter&gt; CompositeSymbolWriter;
 899 typedef SymbolPredicate&lt;CStringEntryPtr, true&gt; LeakCStringPredicate;
 900 typedef JfrPredicatedTypeWriterImplHost&lt;CStringEntryPtr, LeakCStringPredicate, write__cstring__leakp&gt; LeakCStringEntryWriterImpl;
 901 typedef JfrTypeWriterHost&lt;LeakCStringEntryWriterImpl, TYPE_SYMBOL&gt; LeakCStringEntryWriter;
 902 typedef CompositeFunctor&lt;CStringEntryPtr, LeakCStringEntryWriter, CStringEntryWriter&gt; CompositeCStringWriter;
 903 
 904 static void write_symbols_with_leakp() {
 905   assert(_leakp_writer != NULL, &quot;invariant&quot;);
 906   SymbolEntryWriter sw(_writer, _class_unload);
 907   LeakSymbolEntryWriter lsw(_leakp_writer, _class_unload);
 908   CompositeSymbolWriter csw(&amp;lsw, &amp;sw);
 909   _artifacts-&gt;iterate_symbols(csw);
 910   CStringEntryWriter ccsw(_writer, _class_unload, true); // skip header
 911   LeakCStringEntryWriter lccsw(_leakp_writer, _class_unload, true); // skip header
 912   CompositeCStringWriter cccsw(&amp;lccsw, &amp;ccsw);
 913   _artifacts-&gt;iterate_cstrings(cccsw);
 914   sw.add(ccsw.count());
 915   lsw.add(lccsw.count());
 916   _artifacts-&gt;tally(sw);
 917 }
 918 
 919 static void write_symbols() {
 920   assert(_writer != NULL, &quot;invariant&quot;);
 921   if (_leakp_writer != NULL) {
 922     write_symbols_with_leakp();
 923     return;
 924   }
 925   SymbolEntryWriter sw(_writer, _class_unload);
 926   _artifacts-&gt;iterate_symbols(sw);
 927   CStringEntryWriter csw(_writer, _class_unload, true); // skip header
 928   _artifacts-&gt;iterate_cstrings(csw);
 929   sw.add(csw.count());
 930   _artifacts-&gt;tally(sw);
 931 }
 932 
 933 typedef Wrapper&lt;KlassPtr, ClearArtifact&gt; ClearKlassBits;
 934 typedef Wrapper&lt;MethodPtr, ClearArtifact&gt; ClearMethodFlag;
 935 typedef MethodIteratorHost&lt;ClearMethodFlag, ClearKlassBits, AlwaysTrue, false&gt; ClearKlassAndMethods;
 936 
 937 static bool clear_artifacts = false;
 938 
 939 static void clear_klasses_and_methods() {
 940   ClearKlassAndMethods clear(_writer);
 941   _artifacts-&gt;iterate_klasses(clear);
 942 }
 943 
 944 static size_t teardown() {
 945   assert(_artifacts != NULL, &quot;invariant&quot;);
 946   const size_t total_count = _artifacts-&gt;total_count();
 947   if (previous_epoch()) {
 948     clear_klasses_and_methods();
 949     clear_artifacts = true;
 950     ++checkpoint_id;
 951   }
 952   return total_count;
 953 }
 954 
 955 static void setup(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer, bool class_unload, bool flushpoint) {
 956   _writer = writer;
 957   _leakp_writer = leakp_writer;
 958   _class_unload = class_unload;
 959   _flushpoint = flushpoint;
 960   if (_artifacts == NULL) {
 961     _artifacts = new JfrArtifactSet(class_unload);
 962   } else {
 963     _artifacts-&gt;initialize(class_unload, clear_artifacts);
 964   }
 965   clear_artifacts = false;
 966   assert(_artifacts != NULL, &quot;invariant&quot;);
 967   assert(!_artifacts-&gt;has_klass_entries(), &quot;invariant&quot;);
 968 }
 969 
 970 /**
 971  * Write all &quot;tagged&quot; (in-use) constant artifacts and their dependencies.
 972  */
 973 size_t JfrTypeSet::serialize(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer, bool class_unload, bool flushpoint) {
 974   assert(writer != NULL, &quot;invariant&quot;);
 975   ResourceMark rm;
 976   setup(writer, leakp_writer, class_unload, flushpoint);
 977   // write order is important because an individual write step
 978   // might tag an artifact to be written in a subsequent step
 979   if (!write_klasses()) {
 980     return 0;
 981   }
 982   write_packages();
 983   write_modules();
 984   write_classloaders();
 985   write_methods();
 986   write_symbols();
 987   return teardown();
 988 }
 989 
 990 /**
 991  * Clear all tags from the previous epoch.
 992  */
 993 void JfrTypeSet::clear() {
 994   clear_artifacts = true;
 995   setup(NULL, NULL, false, false);
 996   register_klasses();
 997   clear_packages();
 998   clear_modules();
 999   clear_classloaders();
1000   clear_klasses_and_methods();
1001 }
    </pre>
  </body>
</html>
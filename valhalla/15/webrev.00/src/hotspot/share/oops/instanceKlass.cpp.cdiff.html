<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/oops/instanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arrayKlass.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 805,11 ***</span>
    }
    return is_linked();
  }
  
  bool InstanceKlass::link_class_impl(TRAPS) {
<span class="line-modified">!   if (DumpSharedSpaces &amp;&amp; is_in_error_state()) {</span>
      // This is for CDS dumping phase only -- we use the in_error_state to indicate that
      // the class has failed verification. Throwing the NoClassDefFoundError here is just
      // a convenient way to stop repeat attempts to verify the same (bad) class.
      //
      // Note that the NoClassDefFoundError is not part of the JLS, and should not be thrown
<span class="line-new-header">--- 805,11 ---</span>
    }
    return is_linked();
  }
  
  bool InstanceKlass::link_class_impl(TRAPS) {
<span class="line-modified">!   if (DumpSharedSpaces &amp;&amp; SystemDictionaryShared::has_class_failed_verification(this)) {</span>
      // This is for CDS dumping phase only -- we use the in_error_state to indicate that
      // the class has failed verification. Throwing the NoClassDefFoundError here is just
      // a convenient way to stop repeat attempts to verify the same (bad) class.
      //
      // Note that the NoClassDefFoundError is not part of the JLS, and should not be thrown
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1285,11 ***</span>
  //   implementor Klass*    - one implementor
  //   self                  - more than one implementor
  //
  // The _implementor field only exists for interfaces.
  void InstanceKlass::add_implementor(Klass* k) {
<span class="line-modified">!   assert_lock_strong(Compile_lock);</span>
    assert(is_interface(), &quot;not interface&quot;);
    // Filter out my subinterfaces.
    // (Note: Interfaces are never on the subklass list.)
    if (InstanceKlass::cast(k)-&gt;is_interface()) return;
  
<span class="line-new-header">--- 1285,13 ---</span>
  //   implementor Klass*    - one implementor
  //   self                  - more than one implementor
  //
  // The _implementor field only exists for interfaces.
  void InstanceKlass::add_implementor(Klass* k) {
<span class="line-modified">!   if (Universe::is_fully_initialized()) {</span>
<span class="line-added">+     assert_lock_strong(Compile_lock);</span>
<span class="line-added">+   }</span>
    assert(is_interface(), &quot;not interface&quot;);
    // Filter out my subinterfaces.
    // (Note: Interfaces are never on the subklass list.)
    if (InstanceKlass::cast(k)-&gt;is_interface()) return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2506,16 ***</span>
  }
  
  void InstanceKlass::remove_unshareable_info() {
    Klass::remove_unshareable_info();
  
<span class="line-modified">!   if (is_in_error_state()) {</span>
      // Classes are attempted to link during dumping and may fail,
      // but these classes are still in the dictionary and class list in CLD.
<span class="line-modified">!     // Check in_error state first because in_error is &gt; linked state, so</span>
<span class="line-removed">-     // is_linked() is true.</span>
<span class="line-removed">-     // If there&#39;s a linking error, there is nothing else to remove.</span>
      return;
    }
  
    // Reset to the &#39;allocated&#39; state to prevent any premature accessing to
    // a shared class at runtime while the class is still being loaded and
<span class="line-new-header">--- 2508,14 ---</span>
  }
  
  void InstanceKlass::remove_unshareable_info() {
    Klass::remove_unshareable_info();
  
<span class="line-modified">!   if (SystemDictionaryShared::has_class_failed_verification(this)) {</span>
      // Classes are attempted to link during dumping and may fail,
      // but these classes are still in the dictionary and class list in CLD.
<span class="line-modified">!     // If the class has failed verification, there is nothing else to remove.</span>
      return;
    }
  
    // Reset to the &#39;allocated&#39; state to prevent any premature accessing to
    // a shared class at runtime while the class is still being loaded and
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2610,43 ***</span>
    if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled() &amp;&amp; !is_value()) {
      set_prototype_header(markWord::biased_locking_prototype());
    }
  }
  
<span class="line-modified">! // returns true IFF is_in_error_state() has been changed as a result of this call.</span>
<span class="line-removed">- bool InstanceKlass::check_sharing_error_state() {</span>
<span class="line-removed">-   assert(DumpSharedSpaces, &quot;should only be called during dumping&quot;);</span>
<span class="line-removed">-   bool old_state = is_in_error_state();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (!is_in_error_state()) {</span>
<span class="line-removed">-     bool bad = false;</span>
<span class="line-removed">-     for (InstanceKlass* sup = java_super(); sup; sup = sup-&gt;java_super()) {</span>
<span class="line-removed">-       if (sup-&gt;is_in_error_state()) {</span>
<span class="line-removed">-         bad = true;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (!bad) {</span>
<span class="line-removed">-       Array&lt;InstanceKlass*&gt;* interfaces = transitive_interfaces();</span>
<span class="line-removed">-       for (int i = 0; i &lt; interfaces-&gt;length(); i++) {</span>
<span class="line-removed">-         InstanceKlass* iface = interfaces-&gt;at(i);</span>
<span class="line-removed">-         if (iface-&gt;is_in_error_state()) {</span>
<span class="line-removed">-           bad = true;</span>
<span class="line-removed">-           break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (bad) {</span>
<span class="line-removed">-       set_in_error_state();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return (old_state != is_in_error_state());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void InstanceKlass::set_class_loader_type(s2 loader_type) {</span>
    switch (loader_type) {
    case ClassLoader::BOOT_LOADER:
      _misc_flags |= _misc_is_shared_boot_class;
      break;
    case ClassLoader::PLATFORM_LOADER:
<span class="line-new-header">--- 2610,11 ---</span>
    if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled() &amp;&amp; !is_value()) {
      set_prototype_header(markWord::biased_locking_prototype());
    }
  }
  
<span class="line-modified">! void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {</span>
    switch (loader_type) {
    case ClassLoader::BOOT_LOADER:
      _misc_flags |= _misc_is_shared_boot_class;
      break;
    case ClassLoader::PLATFORM_LOADER:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2824,28 ***</span>
    dest[dest_index++] = JVM_SIGNATURE_ENDCLASS;
    dest[dest_index] = &#39;\0&#39;;
    return dest;
  }
  
<span class="line-removed">- // Used to obtain the package name from a fully qualified class name.</span>
<span class="line-removed">- Symbol* InstanceKlass::package_from_name(const Symbol* name, TRAPS) {</span>
<span class="line-removed">-   if (name == NULL) {</span>
<span class="line-removed">-     return NULL;</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     if (name-&gt;utf8_length() &lt;= 0) {</span>
<span class="line-removed">-       return NULL;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     ResourceMark rm(THREAD);</span>
<span class="line-removed">-     const char* package_name = ClassLoader::package_from_name((const char*) name-&gt;as_C_string());</span>
<span class="line-removed">-     if (package_name == NULL) {</span>
<span class="line-removed">-       return NULL;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     Symbol* pkg_name = SymbolTable::new_symbol(package_name);</span>
<span class="line-removed">-     return pkg_name;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  ModuleEntry* InstanceKlass::module() const {
    // For an unsafe anonymous class return the host class&#39; module
    if (is_unsafe_anonymous()) {
      assert(unsafe_anonymous_host() != NULL, &quot;unsafe anonymous class must have a host class&quot;);
      return unsafe_anonymous_host()-&gt;module();
<span class="line-new-header">--- 2792,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2863,11 ***</span>
  void InstanceKlass::set_package(ClassLoaderData* loader_data, TRAPS) {
  
    // ensure java/ packages only loaded by boot or platform builtin loaders
    check_prohibited_package(name(), loader_data, CHECK);
  
<span class="line-modified">!   TempNewSymbol pkg_name = package_from_name(name(), CHECK);</span>
  
    if (pkg_name != NULL &amp;&amp; loader_data != NULL) {
  
      // Find in class loader&#39;s package entry table.
      _package_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
<span class="line-new-header">--- 2813,11 ---</span>
  void InstanceKlass::set_package(ClassLoaderData* loader_data, TRAPS) {
  
    // ensure java/ packages only loaded by boot or platform builtin loaders
    check_prohibited_package(name(), loader_data, CHECK);
  
<span class="line-modified">!   TempNewSymbol pkg_name = ClassLoader::package_from_class_name(name());</span>
  
    if (pkg_name != NULL &amp;&amp; loader_data != NULL) {
  
      // Find in class loader&#39;s package entry table.
      _package_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2959,29 ***</span>
  
    {
      ResourceMark rm;
  
      bool bad_class_name = false;
<span class="line-modified">!     const char* other_pkg =</span>
<span class="line-removed">-       ClassLoader::package_from_name((const char*) other_class_name-&gt;as_C_string(), &amp;bad_class_name);</span>
      if (bad_class_name) {
        return false;
      }
<span class="line-modified">!     // Check that package_from_name() returns NULL, not &quot;&quot;, if there is no package.</span>
<span class="line-modified">!     assert(other_pkg == NULL || strlen(other_pkg) &gt; 0, &quot;package name is empty string&quot;);</span>
  
      const Symbol* const this_package_name =
        this-&gt;package() != NULL ? this-&gt;package()-&gt;name() : NULL;
  
      if (this_package_name == NULL || other_pkg == NULL) {
        // One of the two doesn&#39;t have a package.  Only return true if the other
        // one also doesn&#39;t have a package.
<span class="line-modified">!       return (const char*)this_package_name == other_pkg;</span>
      }
  
      // Check if package is identical
<span class="line-modified">!     return this_package_name-&gt;equals(other_pkg);</span>
    }
  }
  
  // Returns true iff super_method can be overridden by a method in targetclassname
  // See JLS 3rd edition 8.4.6.1
<span class="line-new-header">--- 2909,28 ---</span>
  
    {
      ResourceMark rm;
  
      bool bad_class_name = false;
<span class="line-modified">!     TempNewSymbol other_pkg = ClassLoader::package_from_class_name(other_class_name, &amp;bad_class_name);</span>
      if (bad_class_name) {
        return false;
      }
<span class="line-modified">!     // Check that package_from_class_name() returns NULL, not &quot;&quot;, if there is no package.</span>
<span class="line-modified">!     assert(other_pkg == NULL || other_pkg-&gt;utf8_length() &gt; 0, &quot;package name is empty string&quot;);</span>
  
      const Symbol* const this_package_name =
        this-&gt;package() != NULL ? this-&gt;package()-&gt;name() : NULL;
  
      if (this_package_name == NULL || other_pkg == NULL) {
        // One of the two doesn&#39;t have a package.  Only return true if the other
        // one also doesn&#39;t have a package.
<span class="line-modified">!       return this_package_name == other_pkg;</span>
      }
  
      // Check if package is identical
<span class="line-modified">!     return this_package_name-&gt;fast_compare(other_pkg) == 0;</span>
    }
  }
  
  // Returns true iff super_method can be overridden by a method in targetclassname
  // See JLS 3rd edition 8.4.6.1
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3011,11 ***</span>
        !loader_data-&gt;is_platform_class_loader_data() &amp;&amp;
        class_name != NULL) {
      ResourceMark rm(THREAD);
      char* name = class_name-&gt;as_C_string();
      if (strncmp(name, JAVAPKG, JAVAPKG_LEN) == 0 &amp;&amp; name[JAVAPKG_LEN] == &#39;/&#39;) {
<span class="line-modified">!       TempNewSymbol pkg_name = InstanceKlass::package_from_name(class_name, CHECK);</span>
        assert(pkg_name != NULL, &quot;Error in parsing package name starting with &#39;java/&#39;&quot;);
        name = pkg_name-&gt;as_C_string();
        const char* class_loader_name = loader_data-&gt;loader_name_and_id();
        StringUtils::replace_no_expand(name, &quot;/&quot;, &quot;.&quot;);
        const char* msg_text1 = &quot;Class loader (instance of): &quot;;
<span class="line-new-header">--- 2960,11 ---</span>
        !loader_data-&gt;is_platform_class_loader_data() &amp;&amp;
        class_name != NULL) {
      ResourceMark rm(THREAD);
      char* name = class_name-&gt;as_C_string();
      if (strncmp(name, JAVAPKG, JAVAPKG_LEN) == 0 &amp;&amp; name[JAVAPKG_LEN] == &#39;/&#39;) {
<span class="line-modified">!       TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);</span>
        assert(pkg_name != NULL, &quot;Error in parsing package name starting with &#39;java/&#39;&quot;);
        name = pkg_name-&gt;as_C_string();
        const char* class_loader_name = loader_data-&gt;loader_name_and_id();
        StringUtils::replace_no_expand(name, &quot;/&quot;, &quot;.&quot;);
        const char* msg_text1 = &quot;Class loader (instance of): &quot;;
</pre>
<center><a href="arrayKlass.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/method.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="klass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodData.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/method.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1205          |                |  (_cds_entry_table: CODE)                                   |                 |
1206          |                +-&gt;[0]: jmp _entry_table[0] --&gt; (i2i_entry_for &quot;zero_locals&quot;) |                 |
1207          |                |                               (allocated at run time)       |                 |
1208          |                |  ...                           [asm code ...]               |                 |
1209          +-[not compiled]-+  [n]: jmp _entry_table[n]                                   |                 |
1210          |                                                                              |                 |
1211          |                                                                              |                 |
1212          +-[compiled]-------------------------------------------------------------------+                 |
1213                                                                                                           |
1214  _from_compiled_entry------------&gt;  (_c2i_entry_trampoline: CODE)                                         |
1215                                     [jmp c2i_entry] ------------------------------------------------------+
1216 
1217 ***/
1218 
1219 // Called when the method_holder is getting linked. Setup entrypoints so the method
1220 // is ready to be called from interpreter, compiler, and vtables.
1221 void Method::link_method(const methodHandle&amp; h_method, TRAPS) {
1222   // If the code cache is full, we may reenter this function for the
1223   // leftover methods that weren&#39;t linked.
1224   if (is_shared()) {

1225     address entry = Interpreter::entry_for_cds_method(h_method);
1226     assert(entry != NULL &amp;&amp; entry == _i2i_entry,
1227            &quot;should be correctly set during dump time&quot;);

1228     if (adapter() != NULL) {
1229       return;
1230     }
1231     assert(entry == _from_interpreted_entry,
1232            &quot;should be correctly set during dump time&quot;);
1233   } else if (_i2i_entry != NULL) {
1234     return;
1235   }
1236   assert( _code == NULL, &quot;nothing compiled yet&quot; );
1237 
1238   // Setup interpreter entrypoint
1239   assert(this == h_method(), &quot;wrong h_method()&quot; );
1240 
1241   if (!is_shared()) {
1242     assert(adapter() == NULL, &quot;init&#39;d to NULL&quot;);
1243     address entry = Interpreter::entry_for_method(h_method);
1244     assert(entry != NULL, &quot;interpreter entry must be non-null&quot;);
1245     // Sets both _i2i_entry and _from_interpreted_entry
1246     set_interpreter_entry(entry);
1247   }
</pre>
<hr />
<pre>
1751   // Signature-polymorphic methods: MethodHandle.invoke*, InvokeDynamic.*., VarHandle
1752   case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_MethodHandle):
1753   case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_VarHandle):
1754     if (!is_native())  break;
1755     id = MethodHandles::signature_polymorphic_name_id(method_holder(), name());
1756     if (is_static() != MethodHandles::is_signature_polymorphic_static(id))
1757       id = vmIntrinsics::_none;
1758     break;
1759 
1760   default:
1761     break;
1762   }
1763 
1764   if (id != vmIntrinsics::_none) {
1765     // Set up its iid.  It is an alias method.
1766     set_intrinsic_id(id);
1767     return;
1768   }
1769 }
1770 
<span class="line-removed">1771 // These two methods are static since a GC may move the Method</span>
1772 bool Method::load_signature_classes(const methodHandle&amp; m, TRAPS) {
1773   if (!THREAD-&gt;can_call_java()) {
1774     // There is nothing useful this routine can do from within the Compile thread.
1775     // Hopefully, the signature contains only well-known classes.
1776     // We could scan for this and return true/false, but the caller won&#39;t care.
1777     return false;
1778   }
1779   bool sig_is_loaded = true;
<span class="line-removed">1780   Handle class_loader(THREAD, m-&gt;method_holder()-&gt;class_loader());</span>
<span class="line-removed">1781   Handle protection_domain(THREAD, m-&gt;method_holder()-&gt;protection_domain());</span>
1782   ResourceMark rm(THREAD);
<span class="line-modified">1783   Symbol*  signature = m-&gt;signature();</span>
<span class="line-removed">1784   for(SignatureStream ss(signature); !ss.is_done(); ss.next()) {</span>
1785     if (ss.is_reference()) {
<span class="line-modified">1786       Symbol* sym = ss.as_symbol();</span>
<span class="line-modified">1787       Symbol*  name  = sym;</span>
<span class="line-removed">1788       Klass* klass = SystemDictionary::resolve_or_null(name, class_loader,</span>
<span class="line-removed">1789                                              protection_domain, THREAD);</span>
1790       // We are loading classes eagerly. If a ClassNotFoundException or
1791       // a LinkageError was generated, be sure to ignore it.
1792       if (HAS_PENDING_EXCEPTION) {
1793         if (PENDING_EXCEPTION-&gt;is_a(SystemDictionary::ClassNotFoundException_klass()) ||
1794             PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass())) {
1795           CLEAR_PENDING_EXCEPTION;
1796         } else {
1797           return false;
1798         }
1799       }
1800       if( klass == NULL) { sig_is_loaded = false; }
1801     }
1802   }
1803   return sig_is_loaded;
1804 }
1805 
1806 bool Method::has_unloaded_classes_in_signature(const methodHandle&amp; m, TRAPS) {
<span class="line-removed">1807   Handle class_loader(THREAD, m-&gt;method_holder()-&gt;class_loader());</span>
<span class="line-removed">1808   Handle protection_domain(THREAD, m-&gt;method_holder()-&gt;protection_domain());</span>
1809   ResourceMark rm(THREAD);
<span class="line-modified">1810   Symbol*  signature = m-&gt;signature();</span>
<span class="line-removed">1811   for(SignatureStream ss(signature); !ss.is_done(); ss.next()) {</span>
1812     if (ss.type() == T_OBJECT) {
<span class="line-modified">1813       Symbol* name = ss.as_symbol();</span>
<span class="line-modified">1814       Klass* klass = SystemDictionary::find(name, class_loader, protection_domain, THREAD);</span>


1815       if (klass == NULL) return true;
1816     }
1817   }
1818   return false;
1819 }
1820 
1821 // Exposed so field engineers can debug VM
1822 void Method::print_short_name(outputStream* st) {
1823   ResourceMark rm;
1824 #ifdef PRODUCT
1825   st-&gt;print(&quot; %s::&quot;, method_holder()-&gt;external_name());
1826 #else
1827   st-&gt;print(&quot; %s::&quot;, method_holder()-&gt;internal_name());
1828 #endif
1829   name()-&gt;print_symbol_on(st);
1830   if (WizardMode) signature()-&gt;print_symbol_on(st);
1831   else if (MethodHandles::is_signature_polymorphic(intrinsic_id()))
1832     MethodHandles::print_as_basic_type_signature_on(st, signature());
1833 }
1834 
</pre>
</td>
<td>
<hr />
<pre>
1205          |                |  (_cds_entry_table: CODE)                                   |                 |
1206          |                +-&gt;[0]: jmp _entry_table[0] --&gt; (i2i_entry_for &quot;zero_locals&quot;) |                 |
1207          |                |                               (allocated at run time)       |                 |
1208          |                |  ...                           [asm code ...]               |                 |
1209          +-[not compiled]-+  [n]: jmp _entry_table[n]                                   |                 |
1210          |                                                                              |                 |
1211          |                                                                              |                 |
1212          +-[compiled]-------------------------------------------------------------------+                 |
1213                                                                                                           |
1214  _from_compiled_entry------------&gt;  (_c2i_entry_trampoline: CODE)                                         |
1215                                     [jmp c2i_entry] ------------------------------------------------------+
1216 
1217 ***/
1218 
1219 // Called when the method_holder is getting linked. Setup entrypoints so the method
1220 // is ready to be called from interpreter, compiler, and vtables.
1221 void Method::link_method(const methodHandle&amp; h_method, TRAPS) {
1222   // If the code cache is full, we may reenter this function for the
1223   // leftover methods that weren&#39;t linked.
1224   if (is_shared()) {
<span class="line-added">1225 #ifdef ASSERT</span>
1226     address entry = Interpreter::entry_for_cds_method(h_method);
1227     assert(entry != NULL &amp;&amp; entry == _i2i_entry,
1228            &quot;should be correctly set during dump time&quot;);
<span class="line-added">1229 #endif</span>
1230     if (adapter() != NULL) {
1231       return;
1232     }
1233     assert(entry == _from_interpreted_entry,
1234            &quot;should be correctly set during dump time&quot;);
1235   } else if (_i2i_entry != NULL) {
1236     return;
1237   }
1238   assert( _code == NULL, &quot;nothing compiled yet&quot; );
1239 
1240   // Setup interpreter entrypoint
1241   assert(this == h_method(), &quot;wrong h_method()&quot; );
1242 
1243   if (!is_shared()) {
1244     assert(adapter() == NULL, &quot;init&#39;d to NULL&quot;);
1245     address entry = Interpreter::entry_for_method(h_method);
1246     assert(entry != NULL, &quot;interpreter entry must be non-null&quot;);
1247     // Sets both _i2i_entry and _from_interpreted_entry
1248     set_interpreter_entry(entry);
1249   }
</pre>
<hr />
<pre>
1753   // Signature-polymorphic methods: MethodHandle.invoke*, InvokeDynamic.*., VarHandle
1754   case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_MethodHandle):
1755   case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_VarHandle):
1756     if (!is_native())  break;
1757     id = MethodHandles::signature_polymorphic_name_id(method_holder(), name());
1758     if (is_static() != MethodHandles::is_signature_polymorphic_static(id))
1759       id = vmIntrinsics::_none;
1760     break;
1761 
1762   default:
1763     break;
1764   }
1765 
1766   if (id != vmIntrinsics::_none) {
1767     // Set up its iid.  It is an alias method.
1768     set_intrinsic_id(id);
1769     return;
1770   }
1771 }
1772 

1773 bool Method::load_signature_classes(const methodHandle&amp; m, TRAPS) {
1774   if (!THREAD-&gt;can_call_java()) {
1775     // There is nothing useful this routine can do from within the Compile thread.
1776     // Hopefully, the signature contains only well-known classes.
1777     // We could scan for this and return true/false, but the caller won&#39;t care.
1778     return false;
1779   }
1780   bool sig_is_loaded = true;


1781   ResourceMark rm(THREAD);
<span class="line-modified">1782   for (ResolvingSignatureStream ss(m()); !ss.is_done(); ss.next()) {</span>

1783     if (ss.is_reference()) {
<span class="line-modified">1784       // load everything, including arrays &quot;[Lfoo;&quot;</span>
<span class="line-modified">1785       Klass* klass = ss.as_klass(SignatureStream::ReturnNull, THREAD);</span>


1786       // We are loading classes eagerly. If a ClassNotFoundException or
1787       // a LinkageError was generated, be sure to ignore it.
1788       if (HAS_PENDING_EXCEPTION) {
1789         if (PENDING_EXCEPTION-&gt;is_a(SystemDictionary::ClassNotFoundException_klass()) ||
1790             PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass())) {
1791           CLEAR_PENDING_EXCEPTION;
1792         } else {
1793           return false;
1794         }
1795       }
1796       if( klass == NULL) { sig_is_loaded = false; }
1797     }
1798   }
1799   return sig_is_loaded;
1800 }
1801 
1802 bool Method::has_unloaded_classes_in_signature(const methodHandle&amp; m, TRAPS) {


1803   ResourceMark rm(THREAD);
<span class="line-modified">1804   for(ResolvingSignatureStream ss(m()); !ss.is_done(); ss.next()) {</span>

1805     if (ss.type() == T_OBJECT) {
<span class="line-modified">1806       // Do not use ss.is_reference() here, since we don&#39;t care about</span>
<span class="line-modified">1807       // unloaded array component types.</span>
<span class="line-added">1808       Klass* klass = ss.as_klass_if_loaded(THREAD);</span>
<span class="line-added">1809       assert(!HAS_PENDING_EXCEPTION, &quot;as_klass_if_loaded contract&quot;);</span>
1810       if (klass == NULL) return true;
1811     }
1812   }
1813   return false;
1814 }
1815 
1816 // Exposed so field engineers can debug VM
1817 void Method::print_short_name(outputStream* st) {
1818   ResourceMark rm;
1819 #ifdef PRODUCT
1820   st-&gt;print(&quot; %s::&quot;, method_holder()-&gt;external_name());
1821 #else
1822   st-&gt;print(&quot; %s::&quot;, method_holder()-&gt;internal_name());
1823 #endif
1824   name()-&gt;print_symbol_on(st);
1825   if (WizardMode) signature()-&gt;print_symbol_on(st);
1826   else if (MethodHandles::is_signature_polymorphic(intrinsic_id()))
1827     MethodHandles::print_as_basic_type_signature_on(st, signature());
1828 }
1829 
</pre>
</td>
</tr>
</table>
<center><a href="klass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodData.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
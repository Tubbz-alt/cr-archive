<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/oops/method.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="klass.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodData.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/method.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1220,13 ***</span>
<span class="line-new-header">--- 1220,15 ---</span>
  // is ready to be called from interpreter, compiler, and vtables.
  void Method::link_method(const methodHandle&amp; h_method, TRAPS) {
    // If the code cache is full, we may reenter this function for the
    // leftover methods that weren&#39;t linked.
    if (is_shared()) {
<span class="line-added">+ #ifdef ASSERT</span>
      address entry = Interpreter::entry_for_cds_method(h_method);
      assert(entry != NULL &amp;&amp; entry == _i2i_entry,
             &quot;should be correctly set during dump time&quot;);
<span class="line-added">+ #endif</span>
      if (adapter() != NULL) {
        return;
      }
      assert(entry == _from_interpreted_entry,
             &quot;should be correctly set during dump time&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1766,29 ***</span>
      set_intrinsic_id(id);
      return;
    }
  }
  
<span class="line-removed">- // These two methods are static since a GC may move the Method</span>
  bool Method::load_signature_classes(const methodHandle&amp; m, TRAPS) {
    if (!THREAD-&gt;can_call_java()) {
      // There is nothing useful this routine can do from within the Compile thread.
      // Hopefully, the signature contains only well-known classes.
      // We could scan for this and return true/false, but the caller won&#39;t care.
      return false;
    }
    bool sig_is_loaded = true;
<span class="line-removed">-   Handle class_loader(THREAD, m-&gt;method_holder()-&gt;class_loader());</span>
<span class="line-removed">-   Handle protection_domain(THREAD, m-&gt;method_holder()-&gt;protection_domain());</span>
    ResourceMark rm(THREAD);
<span class="line-modified">!   Symbol*  signature = m-&gt;signature();</span>
<span class="line-removed">-   for(SignatureStream ss(signature); !ss.is_done(); ss.next()) {</span>
      if (ss.is_reference()) {
<span class="line-modified">!       Symbol* sym = ss.as_symbol();</span>
<span class="line-modified">!       Symbol*  name  = sym;</span>
<span class="line-removed">-       Klass* klass = SystemDictionary::resolve_or_null(name, class_loader,</span>
<span class="line-removed">-                                              protection_domain, THREAD);</span>
        // We are loading classes eagerly. If a ClassNotFoundException or
        // a LinkageError was generated, be sure to ignore it.
        if (HAS_PENDING_EXCEPTION) {
          if (PENDING_EXCEPTION-&gt;is_a(SystemDictionary::ClassNotFoundException_klass()) ||
              PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass())) {
<span class="line-new-header">--- 1768,23 ---</span>
      set_intrinsic_id(id);
      return;
    }
  }
  
  bool Method::load_signature_classes(const methodHandle&amp; m, TRAPS) {
    if (!THREAD-&gt;can_call_java()) {
      // There is nothing useful this routine can do from within the Compile thread.
      // Hopefully, the signature contains only well-known classes.
      // We could scan for this and return true/false, but the caller won&#39;t care.
      return false;
    }
    bool sig_is_loaded = true;
    ResourceMark rm(THREAD);
<span class="line-modified">!   for (ResolvingSignatureStream ss(m()); !ss.is_done(); ss.next()) {</span>
      if (ss.is_reference()) {
<span class="line-modified">!       // load everything, including arrays &quot;[Lfoo;&quot;</span>
<span class="line-modified">!       Klass* klass = ss.as_klass(SignatureStream::ReturnNull, THREAD);</span>
        // We are loading classes eagerly. If a ClassNotFoundException or
        // a LinkageError was generated, be sure to ignore it.
        if (HAS_PENDING_EXCEPTION) {
          if (PENDING_EXCEPTION-&gt;is_a(SystemDictionary::ClassNotFoundException_klass()) ||
              PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass())) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1802,18 ***</span>
    }
    return sig_is_loaded;
  }
  
  bool Method::has_unloaded_classes_in_signature(const methodHandle&amp; m, TRAPS) {
<span class="line-removed">-   Handle class_loader(THREAD, m-&gt;method_holder()-&gt;class_loader());</span>
<span class="line-removed">-   Handle protection_domain(THREAD, m-&gt;method_holder()-&gt;protection_domain());</span>
    ResourceMark rm(THREAD);
<span class="line-modified">!   Symbol*  signature = m-&gt;signature();</span>
<span class="line-removed">-   for(SignatureStream ss(signature); !ss.is_done(); ss.next()) {</span>
      if (ss.type() == T_OBJECT) {
<span class="line-modified">!       Symbol* name = ss.as_symbol();</span>
<span class="line-modified">!       Klass* klass = SystemDictionary::find(name, class_loader, protection_domain, THREAD);</span>
        if (klass == NULL) return true;
      }
    }
    return false;
  }
<span class="line-new-header">--- 1798,17 ---</span>
    }
    return sig_is_loaded;
  }
  
  bool Method::has_unloaded_classes_in_signature(const methodHandle&amp; m, TRAPS) {
    ResourceMark rm(THREAD);
<span class="line-modified">!   for(ResolvingSignatureStream ss(m()); !ss.is_done(); ss.next()) {</span>
      if (ss.type() == T_OBJECT) {
<span class="line-modified">!       // Do not use ss.is_reference() here, since we don&#39;t care about</span>
<span class="line-modified">!       // unloaded array component types.</span>
<span class="line-added">+       Klass* klass = ss.as_klass_if_loaded(THREAD);</span>
<span class="line-added">+       assert(!HAS_PENDING_EXCEPTION, &quot;as_klass_if_loaded contract&quot;);</span>
        if (klass == NULL) return true;
      }
    }
    return false;
  }
</pre>
<center><a href="klass.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodData.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
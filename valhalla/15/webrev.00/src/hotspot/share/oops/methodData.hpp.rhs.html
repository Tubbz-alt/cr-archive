<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/methodData.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_METHODDATA_HPP
  26 #define SHARE_OOPS_METHODDATA_HPP
  27 
  28 #include &quot;interpreter/bytecodes.hpp&quot;
  29 #include &quot;oops/metadata.hpp&quot;
  30 #include &quot;oops/method.hpp&quot;
  31 #include &quot;oops/oop.hpp&quot;
  32 #include &quot;runtime/atomic.hpp&quot;
  33 #include &quot;utilities/align.hpp&quot;
  34 
  35 class BytecodeStream;
  36 
  37 // The MethodData object collects counts and other profile information
  38 // during zeroth-tier (interpretive) and first-tier execution.
  39 // The profile is used later by compilation heuristics.  Some heuristics
  40 // enable use of aggressive (or &quot;heroic&quot;) optimizations.  An aggressive
  41 // optimization often has a down-side, a corner case that it handles
  42 // poorly, but which is thought to be rare.  The profile provides
  43 // evidence of this rarity for a given method or even BCI.  It allows
  44 // the compiler to back out of the optimization at places where it
  45 // has historically been a poor choice.  Other heuristics try to use
  46 // specific information gathered about types observed at a given site.
  47 //
  48 // All data in the profile is approximate.  It is expected to be accurate
  49 // on the whole, but the system expects occasional inaccuraces, due to
  50 // counter overflow, multiprocessor races during data collection, space
  51 // limitations, missing MDO blocks, etc.  Bad or missing data will degrade
  52 // optimization quality but will not affect correctness.  Also, each MDO
  53 // is marked with its birth-date (&quot;creation_mileage&quot;) which can be used
  54 // to assess the quality (&quot;maturity&quot;) of its data.
  55 //
  56 // Short (&lt;32-bit) counters are designed to overflow to a known &quot;saturated&quot;
  57 // state.  Also, certain recorded per-BCI events are given one-bit counters
  58 // which overflow to a saturated state which applied to all counters at
  59 // that BCI.  In other words, there is a small lattice which approximates
  60 // the ideal of an infinite-precision counter for each event at each BCI,
  61 // and the lattice quickly &quot;bottoms out&quot; in a state where all counters
  62 // are taken to be indefinitely large.
  63 //
  64 // The reader will find many data races in profile gathering code, starting
  65 // with invocation counter incrementation.  None of these races harm correct
  66 // execution of the compiled code.
  67 
  68 // forward decl
  69 class ProfileData;
  70 
  71 // DataLayout
  72 //
  73 // Overlay for generic profiling data.
  74 class DataLayout {
  75   friend class VMStructs;
  76   friend class JVMCIVMStructs;
  77 
  78 private:
  79   // Every data layout begins with a header.  This header
  80   // contains a tag, which is used to indicate the size/layout
  81   // of the data, 8 bits of flags, which can be used in any way,
  82   // 32 bits of trap history (none/one reason/many reasons),
  83   // and a bci, which is used to tie this piece of data to a
  84   // specific bci in the bytecodes.
  85   union {
  86     u8 _bits;
  87     struct {
  88       u1 _tag;
  89       u1 _flags;
  90       u2 _bci;
  91       u4 _traps;
  92     } _struct;
  93   } _header;
  94 
  95   // The data layout has an arbitrary number of cells, each sized
  96   // to accomodate a pointer or an integer.
  97   intptr_t _cells[1];
  98 
  99   // Some types of data layouts need a length field.
 100   static bool needs_array_len(u1 tag);
 101 
 102 public:
 103   enum {
 104     counter_increment = 1
 105   };
 106 
 107   enum {
 108     cell_size = sizeof(intptr_t)
 109   };
 110 
 111   // Tag values
 112   enum {
 113     no_tag,
 114     bit_data_tag,
 115     counter_data_tag,
 116     jump_data_tag,
 117     receiver_type_data_tag,
 118     virtual_call_data_tag,
 119     ret_data_tag,
 120     branch_data_tag,
 121     multi_branch_data_tag,
 122     arg_info_data_tag,
 123     call_type_data_tag,
 124     virtual_call_type_data_tag,
 125     parameters_type_data_tag,
 126     speculative_trap_data_tag,
 127     array_load_store_data_tag
 128   };
 129 
 130   enum {
 131     // The trap state breaks down as [recompile:1 | reason:31].
 132     // This further breakdown is defined in deoptimization.cpp.
 133     // See Deoptimization::trap_state_reason for an assert that
 134     // trap_bits is big enough to hold reasons &lt; Reason_RECORDED_LIMIT.
 135     //
 136     // The trap_state is collected only if ProfileTraps is true.
 137     trap_bits = 1+31,  // 31: enough to distinguish [0..Reason_RECORDED_LIMIT].
 138     trap_mask = -1,
 139     first_flag = 0
 140   };
 141 
 142   // Size computation
 143   static int header_size_in_bytes() {
 144     return header_size_in_cells() * cell_size;
 145   }
 146   static int header_size_in_cells() {
 147     return LP64_ONLY(1) NOT_LP64(2);
 148   }
 149 
 150   static int compute_size_in_bytes(int cell_count) {
 151     return header_size_in_bytes() + cell_count * cell_size;
 152   }
 153 
 154   // Initialization
 155   void initialize(u1 tag, u2 bci, int cell_count);
 156 
 157   // Accessors
 158   u1 tag() {
 159     return _header._struct._tag;
 160   }
 161 
 162   // Return 32 bits of trap state.
 163   // The state tells if traps with zero, one, or many reasons have occurred.
 164   // It also tells whether zero or many recompilations have occurred.
 165   // The associated trap histogram in the MDO itself tells whether
 166   // traps are common or not.  If a BCI shows that a trap X has
 167   // occurred, and the MDO shows N occurrences of X, we make the
 168   // simplifying assumption that all N occurrences can be blamed
 169   // on that BCI.
 170   uint trap_state() const {
 171     return _header._struct._traps;
 172   }
 173 
 174   void set_trap_state(uint new_state) {
 175     assert(ProfileTraps, &quot;used only under +ProfileTraps&quot;);
 176     uint old_flags = _header._struct._traps;
 177     _header._struct._traps = new_state | old_flags;
 178   }
 179 
 180   u1 flags() const {
 181     return _header._struct._flags;
 182   }
 183 
 184   u2 bci() const {
 185     return _header._struct._bci;
 186   }
 187 
 188   void set_header(u8 value) {
 189     _header._bits = value;
 190   }
 191   u8 header() {
 192     return _header._bits;
 193   }
 194   void set_cell_at(int index, intptr_t value) {
 195     _cells[index] = value;
 196   }
 197   void release_set_cell_at(int index, intptr_t value);
 198   intptr_t cell_at(int index) const {
 199     return _cells[index];
 200   }
 201 
 202   void set_flag_at(u1 flag_number) {
 203     _header._struct._flags |= (0x1 &lt;&lt; flag_number);
 204   }
 205   bool flag_at(u1 flag_number) const {
 206     return (_header._struct._flags &amp; (0x1 &lt;&lt; flag_number)) != 0;
 207   }
 208 
 209   // Low-level support for code generation.
 210   static ByteSize header_offset() {
 211     return byte_offset_of(DataLayout, _header);
 212   }
 213   static ByteSize tag_offset() {
 214     return byte_offset_of(DataLayout, _header._struct._tag);
 215   }
 216   static ByteSize flags_offset() {
 217     return byte_offset_of(DataLayout, _header._struct._flags);
 218   }
 219   static ByteSize bci_offset() {
 220     return byte_offset_of(DataLayout, _header._struct._bci);
 221   }
 222   static ByteSize cell_offset(int index) {
 223     return byte_offset_of(DataLayout, _cells) + in_ByteSize(index * cell_size);
 224   }
 225   // Return a value which, when or-ed as a byte into _flags, sets the flag.
 226   static u1 flag_number_to_constant(u1 flag_number) {
 227     DataLayout temp; temp.set_header(0);
 228     temp.set_flag_at(flag_number);
 229     return temp._header._struct._flags;
 230   }
 231   // Return a value which, when or-ed as a word into _header, sets the flag.
 232   static u8 flag_mask_to_header_mask(uint byte_constant) {
 233     DataLayout temp; temp.set_header(0);
 234     temp._header._struct._flags = byte_constant;
 235     return temp._header._bits;
 236   }
 237 
 238   ProfileData* data_in();
 239 
 240   // GC support
 241   void clean_weak_klass_links(bool always_clean);
 242 
 243   // Redefinition support
 244   void clean_weak_method_links();
 245   DEBUG_ONLY(void verify_clean_weak_method_links();)
 246 };
 247 
 248 
 249 // ProfileData class hierarchy
 250 class ProfileData;
 251 class   BitData;
 252 class     CounterData;
 253 class       ReceiverTypeData;
 254 class         VirtualCallData;
 255 class           VirtualCallTypeData;
 256 class       RetData;
 257 class       CallTypeData;
 258 class   JumpData;
 259 class     BranchData;
 260 class   ArrayData;
 261 class     MultiBranchData;
 262 class     ArgInfoData;
 263 class     ParametersTypeData;
 264 class   SpeculativeTrapData;
 265 class   ArrayLoadStoreData;
 266 
 267 // ProfileData
 268 //
 269 // A ProfileData object is created to refer to a section of profiling
 270 // data in a structured way.
 271 class ProfileData : public ResourceObj {
 272   friend class TypeEntries;
 273   friend class SingleTypeEntry;
 274   friend class TypeStackSlotEntries;
 275 private:
 276   enum {
 277     tab_width_one = 16,
 278     tab_width_two = 36
 279   };
 280 
 281   // This is a pointer to a section of profiling data.
 282   DataLayout* _data;
 283 
 284   char* print_data_on_helper(const MethodData* md) const;
 285 
 286 protected:
 287   DataLayout* data() { return _data; }
 288   const DataLayout* data() const { return _data; }
 289 
 290   enum {
 291     cell_size = DataLayout::cell_size
 292   };
 293 
 294 public:
 295   // How many cells are in this?
 296   virtual int cell_count() const {
 297     ShouldNotReachHere();
 298     return -1;
 299   }
 300 
 301   // Return the size of this data.
 302   int size_in_bytes() {
 303     return DataLayout::compute_size_in_bytes(cell_count());
 304   }
 305 
 306 protected:
 307   // Low-level accessors for underlying data
 308   void set_intptr_at(int index, intptr_t value) {
 309     assert(0 &lt;= index &amp;&amp; index &lt; cell_count(), &quot;oob&quot;);
 310     data()-&gt;set_cell_at(index, value);
 311   }
 312   void release_set_intptr_at(int index, intptr_t value);
 313   intptr_t intptr_at(int index) const {
 314     assert(0 &lt;= index &amp;&amp; index &lt; cell_count(), &quot;oob&quot;);
 315     return data()-&gt;cell_at(index);
 316   }
 317   void set_uint_at(int index, uint value) {
 318     set_intptr_at(index, (intptr_t) value);
 319   }
 320   void release_set_uint_at(int index, uint value);
 321   uint uint_at(int index) const {
 322     return (uint)intptr_at(index);
 323   }
 324   void set_int_at(int index, int value) {
 325     set_intptr_at(index, (intptr_t) value);
 326   }
 327   void release_set_int_at(int index, int value);
 328   int int_at(int index) const {
 329     return (int)intptr_at(index);
 330   }
 331   int int_at_unchecked(int index) const {
 332     return (int)data()-&gt;cell_at(index);
 333   }
 334   void set_oop_at(int index, oop value) {
 335     set_intptr_at(index, cast_from_oop&lt;intptr_t&gt;(value));
 336   }
 337   oop oop_at(int index) const {
 338     return cast_to_oop(intptr_at(index));
 339   }
 340 
 341   void set_flag_at(int flag_number) {
 342     data()-&gt;set_flag_at(flag_number);
 343   }
 344   bool flag_at(int flag_number) const {
 345     return data()-&gt;flag_at(flag_number);
 346   }
 347 
 348   // two convenient imports for use by subclasses:
 349   static ByteSize cell_offset(int index) {
 350     return DataLayout::cell_offset(index);
 351   }
 352   static int flag_number_to_constant(int flag_number) {
 353     return DataLayout::flag_number_to_constant(flag_number);
 354   }
 355 
 356   ProfileData(DataLayout* data) {
 357     _data = data;
 358   }
 359 
 360 public:
 361   // Constructor for invalid ProfileData.
 362   ProfileData();
 363 
 364   u2 bci() const {
 365     return data()-&gt;bci();
 366   }
 367 
 368   address dp() {
 369     return (address)_data;
 370   }
 371 
 372   int trap_state() const {
 373     return data()-&gt;trap_state();
 374   }
 375   void set_trap_state(int new_state) {
 376     data()-&gt;set_trap_state(new_state);
 377   }
 378 
 379   // Type checking
 380   virtual bool is_BitData()         const { return false; }
 381   virtual bool is_CounterData()     const { return false; }
 382   virtual bool is_JumpData()        const { return false; }
 383   virtual bool is_ReceiverTypeData()const { return false; }
 384   virtual bool is_VirtualCallData() const { return false; }
 385   virtual bool is_RetData()         const { return false; }
 386   virtual bool is_BranchData()      const { return false; }
 387   virtual bool is_ArrayData()       const { return false; }
 388   virtual bool is_MultiBranchData() const { return false; }
 389   virtual bool is_ArgInfoData()     const { return false; }
 390   virtual bool is_CallTypeData()    const { return false; }
 391   virtual bool is_VirtualCallTypeData()const { return false; }
 392   virtual bool is_ParametersTypeData() const { return false; }
 393   virtual bool is_SpeculativeTrapData()const { return false; }
 394   virtual bool is_ArrayLoadStoreData() const { return false; }
 395 
 396 
 397   BitData* as_BitData() const {
 398     assert(is_BitData(), &quot;wrong type&quot;);
 399     return is_BitData()         ? (BitData*)        this : NULL;
 400   }
 401   CounterData* as_CounterData() const {
 402     assert(is_CounterData(), &quot;wrong type&quot;);
 403     return is_CounterData()     ? (CounterData*)    this : NULL;
 404   }
 405   JumpData* as_JumpData() const {
 406     assert(is_JumpData(), &quot;wrong type&quot;);
 407     return is_JumpData()        ? (JumpData*)       this : NULL;
 408   }
 409   ReceiverTypeData* as_ReceiverTypeData() const {
 410     assert(is_ReceiverTypeData(), &quot;wrong type&quot;);
 411     return is_ReceiverTypeData() ? (ReceiverTypeData*)this : NULL;
 412   }
 413   VirtualCallData* as_VirtualCallData() const {
 414     assert(is_VirtualCallData(), &quot;wrong type&quot;);
 415     return is_VirtualCallData() ? (VirtualCallData*)this : NULL;
 416   }
 417   RetData* as_RetData() const {
 418     assert(is_RetData(), &quot;wrong type&quot;);
 419     return is_RetData()         ? (RetData*)        this : NULL;
 420   }
 421   BranchData* as_BranchData() const {
 422     assert(is_BranchData(), &quot;wrong type&quot;);
 423     return is_BranchData()      ? (BranchData*)     this : NULL;
 424   }
 425   ArrayData* as_ArrayData() const {
 426     assert(is_ArrayData(), &quot;wrong type&quot;);
 427     return is_ArrayData()       ? (ArrayData*)      this : NULL;
 428   }
 429   MultiBranchData* as_MultiBranchData() const {
 430     assert(is_MultiBranchData(), &quot;wrong type&quot;);
 431     return is_MultiBranchData() ? (MultiBranchData*)this : NULL;
 432   }
 433   ArgInfoData* as_ArgInfoData() const {
 434     assert(is_ArgInfoData(), &quot;wrong type&quot;);
 435     return is_ArgInfoData() ? (ArgInfoData*)this : NULL;
 436   }
 437   CallTypeData* as_CallTypeData() const {
 438     assert(is_CallTypeData(), &quot;wrong type&quot;);
 439     return is_CallTypeData() ? (CallTypeData*)this : NULL;
 440   }
 441   VirtualCallTypeData* as_VirtualCallTypeData() const {
 442     assert(is_VirtualCallTypeData(), &quot;wrong type&quot;);
 443     return is_VirtualCallTypeData() ? (VirtualCallTypeData*)this : NULL;
 444   }
 445   ParametersTypeData* as_ParametersTypeData() const {
 446     assert(is_ParametersTypeData(), &quot;wrong type&quot;);
 447     return is_ParametersTypeData() ? (ParametersTypeData*)this : NULL;
 448   }
 449   SpeculativeTrapData* as_SpeculativeTrapData() const {
 450     assert(is_SpeculativeTrapData(), &quot;wrong type&quot;);
 451     return is_SpeculativeTrapData() ? (SpeculativeTrapData*)this : NULL;
 452   }
 453   ArrayLoadStoreData* as_ArrayLoadStoreData() const {
 454     assert(is_ArrayLoadStoreData(), &quot;wrong type&quot;);
 455     return is_ArrayLoadStoreData() ? (ArrayLoadStoreData*)this : NULL;
 456   }
 457 
 458 
 459   // Subclass specific initialization
 460   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo) {}
 461 
 462   // GC support
 463   virtual void clean_weak_klass_links(bool always_clean) {}
 464 
 465   // Redefinition support
 466   virtual void clean_weak_method_links() {}
 467   DEBUG_ONLY(virtual void verify_clean_weak_method_links() {})
 468 
 469   // CI translation: ProfileData can represent both MethodDataOop data
 470   // as well as CIMethodData data. This function is provided for translating
 471   // an oop in a ProfileData to the ci equivalent. Generally speaking,
 472   // most ProfileData don&#39;t require any translation, so we provide the null
 473   // translation here, and the required translators are in the ci subclasses.
 474   virtual void translate_from(const ProfileData* data) {}
 475 
 476   virtual void print_data_on(outputStream* st, const char* extra = NULL) const {
 477     ShouldNotReachHere();
 478   }
 479 
 480   void print_data_on(outputStream* st, const MethodData* md) const;
 481 
 482   void print_shared(outputStream* st, const char* name, const char* extra) const;
 483   void tab(outputStream* st, bool first = false) const;
 484 };
 485 
 486 // BitData
 487 //
 488 // A BitData holds a flag or two in its header.
 489 class BitData : public ProfileData {
 490   friend class VMStructs;
 491   friend class JVMCIVMStructs;
 492 protected:
 493   enum {
 494     // null_seen:
 495     //  saw a null operand (cast/aastore/instanceof)
 496       null_seen_flag              = DataLayout::first_flag + 0
 497 #if INCLUDE_JVMCI
 498     // bytecode threw any exception
 499     , exception_seen_flag         = null_seen_flag + 1
 500 #endif
 501   };
 502   enum { bit_cell_count = 0 };  // no additional data fields needed.
 503 public:
 504   BitData(DataLayout* layout) : ProfileData(layout) {
 505   }
 506 
 507   virtual bool is_BitData() const { return true; }
 508 
 509   static int static_cell_count() {
 510     return bit_cell_count;
 511   }
 512 
 513   virtual int cell_count() const {
 514     return static_cell_count();
 515   }
 516 
 517   // Accessor
 518 
 519   // The null_seen flag bit is specially known to the interpreter.
 520   // Consulting it allows the compiler to avoid setting up null_check traps.
 521   bool null_seen()     { return flag_at(null_seen_flag); }
 522   void set_null_seen()    { set_flag_at(null_seen_flag); }
 523 
 524 #if INCLUDE_JVMCI
 525   // true if an exception was thrown at the specific BCI
 526   bool exception_seen() { return flag_at(exception_seen_flag); }
 527   void set_exception_seen() { set_flag_at(exception_seen_flag); }
 528 #endif
 529 
 530   // Code generation support
 531   static int null_seen_byte_constant() {
 532     return flag_number_to_constant(null_seen_flag);
 533   }
 534 
 535   static ByteSize bit_data_size() {
 536     return cell_offset(bit_cell_count);
 537   }
 538 
 539   void print_data_on(outputStream* st, const char* extra = NULL) const;
 540 };
 541 
 542 // CounterData
 543 //
 544 // A CounterData corresponds to a simple counter.
 545 class CounterData : public BitData {
 546   friend class VMStructs;
 547   friend class JVMCIVMStructs;
 548 protected:
 549   enum {
 550     count_off,
 551     counter_cell_count
 552   };
 553 public:
 554   CounterData(DataLayout* layout) : BitData(layout) {}
 555 
 556   virtual bool is_CounterData() const { return true; }
 557 
 558   static int static_cell_count() {
 559     return counter_cell_count;
 560   }
 561 
 562   virtual int cell_count() const {
 563     return static_cell_count();
 564   }
 565 
 566   // Direct accessor
 567   int count() const {
 568     intptr_t raw_data = intptr_at(count_off);
 569     if (raw_data &gt; max_jint) {
 570       raw_data = max_jint;
 571     } else if (raw_data &lt; min_jint) {
 572       raw_data = min_jint;
 573     }
 574     return int(raw_data);
 575   }
 576 
 577   // Code generation support
 578   static ByteSize count_offset() {
 579     return cell_offset(count_off);
 580   }
 581   static ByteSize counter_data_size() {
 582     return cell_offset(counter_cell_count);
 583   }
 584 
 585   void set_count(int count) {
 586     set_int_at(count_off, count);
 587   }
 588 
 589   void print_data_on(outputStream* st, const char* extra = NULL) const;
 590 };
 591 
 592 // JumpData
 593 //
 594 // A JumpData is used to access profiling information for a direct
 595 // branch.  It is a counter, used for counting the number of branches,
 596 // plus a data displacement, used for realigning the data pointer to
 597 // the corresponding target bci.
 598 class JumpData : public ProfileData {
 599   friend class VMStructs;
 600   friend class JVMCIVMStructs;
 601 protected:
 602   enum {
 603     taken_off_set,
 604     displacement_off_set,
 605     jump_cell_count
 606   };
 607 
 608   void set_displacement(int displacement) {
 609     set_int_at(displacement_off_set, displacement);
 610   }
 611 
 612 public:
 613   JumpData(DataLayout* layout) : ProfileData(layout) {
 614     assert(layout-&gt;tag() == DataLayout::jump_data_tag ||
 615       layout-&gt;tag() == DataLayout::branch_data_tag, &quot;wrong type&quot;);
 616   }
 617 
 618   virtual bool is_JumpData() const { return true; }
 619 
 620   static int static_cell_count() {
 621     return jump_cell_count;
 622   }
 623 
 624   virtual int cell_count() const {
 625     return static_cell_count();
 626   }
 627 
 628   // Direct accessor
 629   uint taken() const {
 630     return uint_at(taken_off_set);
 631   }
 632 
 633   void set_taken(uint cnt) {
 634     set_uint_at(taken_off_set, cnt);
 635   }
 636 
 637   // Saturating counter
 638   uint inc_taken() {
 639     uint cnt = taken() + 1;
 640     // Did we wrap? Will compiler screw us??
 641     if (cnt == 0) cnt--;
 642     set_uint_at(taken_off_set, cnt);
 643     return cnt;
 644   }
 645 
 646   int displacement() const {
 647     return int_at(displacement_off_set);
 648   }
 649 
 650   // Code generation support
 651   static ByteSize taken_offset() {
 652     return cell_offset(taken_off_set);
 653   }
 654 
 655   static ByteSize displacement_offset() {
 656     return cell_offset(displacement_off_set);
 657   }
 658 
 659   // Specific initialization.
 660   void post_initialize(BytecodeStream* stream, MethodData* mdo);
 661 
 662   void print_data_on(outputStream* st, const char* extra = NULL) const;
 663 };
 664 
 665 // Entries in a ProfileData object to record types: it can either be
 666 // none (no profile), unknown (conflicting profile data) or a klass if
 667 // a single one is seen. Whether a null reference was seen is also
 668 // recorded. No counter is associated with the type and a single type
 669 // is tracked (unlike VirtualCallData).
 670 class TypeEntries {
 671 
 672 public:
 673 
 674   // A single cell is used to record information for a type:
 675   // - the cell is initialized to 0
 676   // - when a type is discovered it is stored in the cell
 677   // - bit zero of the cell is used to record whether a null reference
 678   // was encountered or not
 679   // - bit 1 is set to record a conflict in the type information
 680 
 681   enum {
 682     null_seen = 1,
 683     type_mask = ~null_seen,
 684     type_unknown = 2,
 685     status_bits = null_seen | type_unknown,
 686     type_klass_mask = ~status_bits
 687   };
 688 
 689   // what to initialize a cell to
 690   static intptr_t type_none() {
 691     return 0;
 692   }
 693 
 694   // null seen = bit 0 set?
 695   static bool was_null_seen(intptr_t v) {
 696     return (v &amp; null_seen) != 0;
 697   }
 698 
 699   // conflicting type information = bit 1 set?
 700   static bool is_type_unknown(intptr_t v) {
 701     return (v &amp; type_unknown) != 0;
 702   }
 703 
 704   // not type information yet = all bits cleared, ignoring bit 0?
 705   static bool is_type_none(intptr_t v) {
 706     return (v &amp; type_mask) == 0;
 707   }
 708 
 709   // recorded type: cell without bit 0 and 1
 710   static intptr_t klass_part(intptr_t v) {
 711     intptr_t r = v &amp; type_klass_mask;
 712     return r;
 713   }
 714 
 715   // type recorded
 716   static Klass* valid_klass(intptr_t k) {
 717     if (!is_type_none(k) &amp;&amp;
 718         !is_type_unknown(k)) {
 719       Klass* res = (Klass*)klass_part(k);
 720       assert(res != NULL, &quot;invalid&quot;);
 721       return res;
 722     } else {
 723       return NULL;
 724     }
 725   }
 726 
 727   static intptr_t with_status(intptr_t k, intptr_t in) {
 728     return k | (in &amp; status_bits);
 729   }
 730 
 731   static intptr_t with_status(Klass* k, intptr_t in) {
 732     return with_status((intptr_t)k, in);
 733   }
 734 
 735   static void print_klass(outputStream* st, intptr_t k);
 736 
 737 protected:
 738   // ProfileData object these entries are part of
 739   ProfileData* _pd;
 740   // offset within the ProfileData object where the entries start
 741   const int _base_off;
 742 
 743   TypeEntries(int base_off)
 744     : _pd(NULL), _base_off(base_off) {}
 745 
 746   void set_intptr_at(int index, intptr_t value) {
 747     _pd-&gt;set_intptr_at(index, value);
 748   }
 749 
 750   intptr_t intptr_at(int index) const {
 751     return _pd-&gt;intptr_at(index);
 752   }
 753 
 754 public:
 755   void set_profile_data(ProfileData* pd) {
 756     _pd = pd;
 757   }
 758 };
 759 
 760 // Type entries used for arguments passed at a call and parameters on
 761 // method entry. 2 cells per entry: one for the type encoded as in
 762 // TypeEntries and one initialized with the stack slot where the
 763 // profiled object is to be found so that the interpreter can locate
 764 // it quickly.
 765 class TypeStackSlotEntries : public TypeEntries {
 766 
 767 private:
 768   enum {
 769     stack_slot_entry,
 770     type_entry,
 771     per_arg_cell_count
 772   };
 773 
 774   // offset of cell for stack slot for entry i within ProfileData object
 775   int stack_slot_offset(int i) const {
 776     return _base_off + stack_slot_local_offset(i);
 777   }
 778 
 779   const int _number_of_entries;
 780 
 781   // offset of cell for type for entry i within ProfileData object
 782   int type_offset_in_cells(int i) const {
 783     return _base_off + type_local_offset(i);
 784   }
 785 
 786 public:
 787 
 788   TypeStackSlotEntries(int base_off, int nb_entries)
 789     : TypeEntries(base_off), _number_of_entries(nb_entries) {}
 790 
 791   static int compute_cell_count(Symbol* signature, bool include_receiver, int max);
 792 
 793   void post_initialize(Symbol* signature, bool has_receiver, bool include_receiver);
 794 
 795   int number_of_entries() const { return _number_of_entries; }
 796 
 797   // offset of cell for stack slot for entry i within this block of cells for a TypeStackSlotEntries
 798   static int stack_slot_local_offset(int i) {
 799     return i * per_arg_cell_count + stack_slot_entry;
 800   }
 801 
 802   // offset of cell for type for entry i within this block of cells for a TypeStackSlotEntries
 803   static int type_local_offset(int i) {
 804     return i * per_arg_cell_count + type_entry;
 805   }
 806 
 807   // stack slot for entry i
 808   uint stack_slot(int i) const {
 809     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 810     return _pd-&gt;uint_at(stack_slot_offset(i));
 811   }
 812 
 813   // set stack slot for entry i
 814   void set_stack_slot(int i, uint num) {
 815     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 816     _pd-&gt;set_uint_at(stack_slot_offset(i), num);
 817   }
 818 
 819   // type for entry i
 820   intptr_t type(int i) const {
 821     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 822     return _pd-&gt;intptr_at(type_offset_in_cells(i));
 823   }
 824 
 825   // set type for entry i
 826   void set_type(int i, intptr_t k) {
 827     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 828     _pd-&gt;set_intptr_at(type_offset_in_cells(i), k);
 829   }
 830 
 831   static ByteSize per_arg_size() {
 832     return in_ByteSize(per_arg_cell_count * DataLayout::cell_size);
 833   }
 834 
 835   static int per_arg_count() {
 836     return per_arg_cell_count;
 837   }
 838 
 839   ByteSize type_offset(int i) const {
 840     return DataLayout::cell_offset(type_offset_in_cells(i));
 841   }
 842 
 843   // GC support
 844   void clean_weak_klass_links(bool always_clean);
 845 
 846   void print_data_on(outputStream* st) const;
 847 };
 848 
 849 // Type entry used for return from a call. A single cell to record the
 850 // type.
 851 class SingleTypeEntry : public TypeEntries {
 852 
 853 private:
 854   enum {
 855     cell_count = 1
 856   };
 857 
 858 public:
 859   SingleTypeEntry(int base_off)
 860     : TypeEntries(base_off) {}
 861 
 862   void post_initialize() {
 863     set_type(type_none());
 864   }
 865 
 866   intptr_t type() const {
 867     return _pd-&gt;intptr_at(_base_off);
 868   }
 869 
 870   void set_type(intptr_t k) {
 871     _pd-&gt;set_intptr_at(_base_off, k);
 872   }
 873 
 874   static int static_cell_count() {
 875     return cell_count;
 876   }
 877 
 878   static ByteSize size() {
 879     return in_ByteSize(cell_count * DataLayout::cell_size);
 880   }
 881 
 882   ByteSize type_offset() {
 883     return DataLayout::cell_offset(_base_off);
 884   }
 885 
 886   // GC support
 887   void clean_weak_klass_links(bool always_clean);
 888 
 889   void print_data_on(outputStream* st) const;
 890 };
 891 
 892 // Entries to collect type information at a call: contains arguments
 893 // (TypeStackSlotEntries), a return type (SingleTypeEntry) and a
 894 // number of cells. Because the number of cells for the return type is
 895 // smaller than the number of cells for the type of an arguments, the
 896 // number of cells is used to tell how many arguments are profiled and
 897 // whether a return value is profiled. See has_arguments() and
 898 // has_return().
 899 class TypeEntriesAtCall {
 900 private:
 901   static int stack_slot_local_offset(int i) {
 902     return header_cell_count() + TypeStackSlotEntries::stack_slot_local_offset(i);
 903   }
 904 
 905   static int argument_type_local_offset(int i) {
 906     return header_cell_count() + TypeStackSlotEntries::type_local_offset(i);
 907   }
 908 
 909 public:
 910 
 911   static int header_cell_count() {
 912     return 1;
 913   }
 914 
 915   static int cell_count_local_offset() {
 916     return 0;
 917   }
 918 
 919   static int compute_cell_count(BytecodeStream* stream);
 920 
 921   static void initialize(DataLayout* dl, int base, int cell_count) {
 922     int off = base + cell_count_local_offset();
 923     dl-&gt;set_cell_at(off, cell_count - base - header_cell_count());
 924   }
 925 
 926   static bool arguments_profiling_enabled();
 927   static bool return_profiling_enabled();
 928 
 929   // Code generation support
 930   static ByteSize cell_count_offset() {
 931     return in_ByteSize(cell_count_local_offset() * DataLayout::cell_size);
 932   }
 933 
 934   static ByteSize args_data_offset() {
 935     return in_ByteSize(header_cell_count() * DataLayout::cell_size);
 936   }
 937 
 938   static ByteSize stack_slot_offset(int i) {
 939     return in_ByteSize(stack_slot_local_offset(i) * DataLayout::cell_size);
 940   }
 941 
 942   static ByteSize argument_type_offset(int i) {
 943     return in_ByteSize(argument_type_local_offset(i) * DataLayout::cell_size);
 944   }
 945 
 946   static ByteSize return_only_size() {
 947     return SingleTypeEntry::size() + in_ByteSize(header_cell_count() * DataLayout::cell_size);
 948   }
 949 
 950 };
 951 
 952 // CallTypeData
 953 //
 954 // A CallTypeData is used to access profiling information about a non
 955 // virtual call for which we collect type information about arguments
 956 // and return value.
 957 class CallTypeData : public CounterData {
 958 private:
 959   // entries for arguments if any
 960   TypeStackSlotEntries _args;
 961   // entry for return type if any
 962   SingleTypeEntry _ret;
 963 
 964   int cell_count_global_offset() const {
 965     return CounterData::static_cell_count() + TypeEntriesAtCall::cell_count_local_offset();
 966   }
 967 
 968   // number of cells not counting the header
 969   int cell_count_no_header() const {
 970     return uint_at(cell_count_global_offset());
 971   }
 972 
 973   void check_number_of_arguments(int total) {
 974     assert(number_of_arguments() == total, &quot;should be set in DataLayout::initialize&quot;);
 975   }
 976 
 977 public:
 978   CallTypeData(DataLayout* layout) :
 979     CounterData(layout),
 980     _args(CounterData::static_cell_count()+TypeEntriesAtCall::header_cell_count(), number_of_arguments()),
 981     _ret(cell_count() - SingleTypeEntry::static_cell_count())
 982   {
 983     assert(layout-&gt;tag() == DataLayout::call_type_data_tag, &quot;wrong type&quot;);
 984     // Some compilers (VC++) don&#39;t want this passed in member initialization list
 985     _args.set_profile_data(this);
 986     _ret.set_profile_data(this);
 987   }
 988 
 989   const TypeStackSlotEntries* args() const {
 990     assert(has_arguments(), &quot;no profiling of arguments&quot;);
 991     return &amp;_args;
 992   }
 993 
 994   const SingleTypeEntry* ret() const {
 995     assert(has_return(), &quot;no profiling of return value&quot;);
 996     return &amp;_ret;
 997   }
 998 
 999   virtual bool is_CallTypeData() const { return true; }
1000 
1001   static int static_cell_count() {
1002     return -1;
1003   }
1004 
1005   static int compute_cell_count(BytecodeStream* stream) {
1006     return CounterData::static_cell_count() + TypeEntriesAtCall::compute_cell_count(stream);
1007   }
1008 
1009   static void initialize(DataLayout* dl, int cell_count) {
1010     TypeEntriesAtCall::initialize(dl, CounterData::static_cell_count(), cell_count);
1011   }
1012 
1013   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo);
1014 
1015   virtual int cell_count() const {
1016     return CounterData::static_cell_count() +
1017       TypeEntriesAtCall::header_cell_count() +
1018       int_at_unchecked(cell_count_global_offset());
1019   }
1020 
1021   int number_of_arguments() const {
1022     return cell_count_no_header() / TypeStackSlotEntries::per_arg_count();
1023   }
1024 
1025   void set_argument_type(int i, Klass* k) {
1026     assert(has_arguments(), &quot;no arguments!&quot;);
1027     intptr_t current = _args.type(i);
1028     _args.set_type(i, TypeEntries::with_status(k, current));
1029   }
1030 
1031   void set_return_type(Klass* k) {
1032     assert(has_return(), &quot;no return!&quot;);
1033     intptr_t current = _ret.type();
1034     _ret.set_type(TypeEntries::with_status(k, current));
1035   }
1036 
1037   // An entry for a return value takes less space than an entry for an
1038   // argument so if the number of cells exceeds the number of cells
1039   // needed for an argument, this object contains type information for
1040   // at least one argument.
1041   bool has_arguments() const {
1042     bool res = cell_count_no_header() &gt;= TypeStackSlotEntries::per_arg_count();
1043     assert (!res || TypeEntriesAtCall::arguments_profiling_enabled(), &quot;no profiling of arguments&quot;);
1044     return res;
1045   }
1046 
1047   // An entry for a return value takes less space than an entry for an
1048   // argument, so if the remainder of the number of cells divided by
1049   // the number of cells for an argument is not null, a return value
1050   // is profiled in this object.
1051   bool has_return() const {
1052     bool res = (cell_count_no_header() % TypeStackSlotEntries::per_arg_count()) != 0;
1053     assert (!res || TypeEntriesAtCall::return_profiling_enabled(), &quot;no profiling of return values&quot;);
1054     return res;
1055   }
1056 
1057   // Code generation support
1058   static ByteSize args_data_offset() {
1059     return cell_offset(CounterData::static_cell_count()) + TypeEntriesAtCall::args_data_offset();
1060   }
1061 
1062   ByteSize argument_type_offset(int i) {
1063     return _args.type_offset(i);
1064   }
1065 
1066   ByteSize return_type_offset() {
1067     return _ret.type_offset();
1068   }
1069 
1070   // GC support
1071   virtual void clean_weak_klass_links(bool always_clean) {
1072     if (has_arguments()) {
1073       _args.clean_weak_klass_links(always_clean);
1074     }
1075     if (has_return()) {
1076       _ret.clean_weak_klass_links(always_clean);
1077     }
1078   }
1079 
1080   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1081 };
1082 
1083 // ReceiverTypeData
1084 //
1085 // A ReceiverTypeData is used to access profiling information about a
1086 // dynamic type check.  It consists of a counter which counts the total times
1087 // that the check is reached, and a series of (Klass*, count) pairs
1088 // which are used to store a type profile for the receiver of the check.
1089 class ReceiverTypeData : public CounterData {
1090   friend class VMStructs;
1091   friend class JVMCIVMStructs;
1092 protected:
1093   enum {
1094 #if INCLUDE_JVMCI
1095     // Description of the different counters
1096     // ReceiverTypeData for instanceof/checkcast/aastore:
1097     //   count is decremented for failed type checks
1098     //   JVMCI only: nonprofiled_count is incremented on type overflow
1099     // VirtualCallData for invokevirtual/invokeinterface:
1100     //   count is incremented on type overflow
1101     //   JVMCI only: nonprofiled_count is incremented on method overflow
1102 
1103     // JVMCI is interested in knowing the percentage of type checks involving a type not explicitly in the profile
1104     nonprofiled_count_off_set = counter_cell_count,
1105     receiver0_offset,
1106 #else
1107     receiver0_offset = counter_cell_count,
1108 #endif
1109     count0_offset,
1110     receiver_type_row_cell_count = (count0_offset + 1) - receiver0_offset
1111   };
1112 
1113 public:
1114   ReceiverTypeData(DataLayout* layout) : CounterData(layout) {
1115     assert(layout-&gt;tag() == DataLayout::receiver_type_data_tag ||
1116            layout-&gt;tag() == DataLayout::virtual_call_data_tag ||
1117            layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, &quot;wrong type&quot;);
1118   }
1119 
1120   virtual bool is_ReceiverTypeData() const { return true; }
1121 
1122   static int static_cell_count() {
1123     return counter_cell_count + (uint) TypeProfileWidth * receiver_type_row_cell_count JVMCI_ONLY(+ 1);
1124   }
1125 
1126   virtual int cell_count() const {
1127     return static_cell_count();
1128   }
1129 
1130   // Direct accessors
1131   static uint row_limit() {
1132     return TypeProfileWidth;
1133   }
1134   static int receiver_cell_index(uint row) {
1135     return receiver0_offset + row * receiver_type_row_cell_count;
1136   }
1137   static int receiver_count_cell_index(uint row) {
1138     return count0_offset + row * receiver_type_row_cell_count;
1139   }
1140 
1141   Klass* receiver(uint row) const {
1142     assert(row &lt; row_limit(), &quot;oob&quot;);
1143 
1144     Klass* recv = (Klass*)intptr_at(receiver_cell_index(row));
1145     assert(recv == NULL || recv-&gt;is_klass(), &quot;wrong type&quot;);
1146     return recv;
1147   }
1148 
1149   void set_receiver(uint row, Klass* k) {
1150     assert((uint)row &lt; row_limit(), &quot;oob&quot;);
1151     set_intptr_at(receiver_cell_index(row), (uintptr_t)k);
1152   }
1153 
1154   uint receiver_count(uint row) const {
1155     assert(row &lt; row_limit(), &quot;oob&quot;);
1156     return uint_at(receiver_count_cell_index(row));
1157   }
1158 
1159   void set_receiver_count(uint row, uint count) {
1160     assert(row &lt; row_limit(), &quot;oob&quot;);
1161     set_uint_at(receiver_count_cell_index(row), count);
1162   }
1163 
1164   void clear_row(uint row) {
1165     assert(row &lt; row_limit(), &quot;oob&quot;);
1166     // Clear total count - indicator of polymorphic call site.
1167     // The site may look like as monomorphic after that but
1168     // it allow to have more accurate profiling information because
1169     // there was execution phase change since klasses were unloaded.
1170     // If the site is still polymorphic then MDO will be updated
1171     // to reflect it. But it could be the case that the site becomes
1172     // only bimorphic. Then keeping total count not 0 will be wrong.
1173     // Even if we use monomorphic (when it is not) for compilation
1174     // we will only have trap, deoptimization and recompile again
1175     // with updated MDO after executing method in Interpreter.
1176     // An additional receiver will be recorded in the cleaned row
1177     // during next call execution.
1178     //
1179     // Note: our profiling logic works with empty rows in any slot.
1180     // We do sorting a profiling info (ciCallProfile) for compilation.
1181     //
1182     set_count(0);
1183     set_receiver(row, NULL);
1184     set_receiver_count(row, 0);
1185 #if INCLUDE_JVMCI
1186     if (!this-&gt;is_VirtualCallData()) {
1187       // if this is a ReceiverTypeData for JVMCI, the nonprofiled_count
1188       // must also be reset (see &quot;Description of the different counters&quot; above)
1189       set_nonprofiled_count(0);
1190     }
1191 #endif
1192   }
1193 
1194   // Code generation support
1195   static ByteSize receiver_offset(uint row) {
1196     return cell_offset(receiver_cell_index(row));
1197   }
1198   static ByteSize receiver_count_offset(uint row) {
1199     return cell_offset(receiver_count_cell_index(row));
1200   }
1201 #if INCLUDE_JVMCI
1202   static ByteSize nonprofiled_receiver_count_offset() {
1203     return cell_offset(nonprofiled_count_off_set);
1204   }
1205   uint nonprofiled_count() const {
1206     return uint_at(nonprofiled_count_off_set);
1207   }
1208   void set_nonprofiled_count(uint count) {
1209     set_uint_at(nonprofiled_count_off_set, count);
1210   }
1211 #endif // INCLUDE_JVMCI
1212   static ByteSize receiver_type_data_size() {
1213     return cell_offset(static_cell_count());
1214   }
1215 
1216   // GC support
1217   virtual void clean_weak_klass_links(bool always_clean);
1218 
1219   void print_receiver_data_on(outputStream* st) const;
1220   void print_data_on(outputStream* st, const char* extra = NULL) const;
1221 };
1222 
1223 // VirtualCallData
1224 //
1225 // A VirtualCallData is used to access profiling information about a
1226 // virtual call.  For now, it has nothing more than a ReceiverTypeData.
1227 class VirtualCallData : public ReceiverTypeData {
1228 public:
1229   VirtualCallData(DataLayout* layout) : ReceiverTypeData(layout) {
1230     assert(layout-&gt;tag() == DataLayout::virtual_call_data_tag ||
1231            layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, &quot;wrong type&quot;);
1232   }
1233 
1234   virtual bool is_VirtualCallData() const { return true; }
1235 
1236   static int static_cell_count() {
1237     // At this point we could add more profile state, e.g., for arguments.
1238     // But for now it&#39;s the same size as the base record type.
<a name="1" id="anc1"></a><span class="line-modified">1239     return ReceiverTypeData::static_cell_count();</span>
1240   }
1241 
1242   virtual int cell_count() const {
1243     return static_cell_count();
1244   }
1245 
1246   // Direct accessors
1247   static ByteSize virtual_call_data_size() {
1248     return cell_offset(static_cell_count());
1249   }
1250 
<a name="2" id="anc2"></a>






















































1251   void print_method_data_on(outputStream* st) const NOT_JVMCI_RETURN;
1252   void print_data_on(outputStream* st, const char* extra = NULL) const;
1253 };
1254 
1255 // VirtualCallTypeData
1256 //
1257 // A VirtualCallTypeData is used to access profiling information about
1258 // a virtual call for which we collect type information about
1259 // arguments and return value.
1260 class VirtualCallTypeData : public VirtualCallData {
1261 private:
1262   // entries for arguments if any
1263   TypeStackSlotEntries _args;
1264   // entry for return type if any
1265   SingleTypeEntry _ret;
1266 
1267   int cell_count_global_offset() const {
1268     return VirtualCallData::static_cell_count() + TypeEntriesAtCall::cell_count_local_offset();
1269   }
1270 
1271   // number of cells not counting the header
1272   int cell_count_no_header() const {
1273     return uint_at(cell_count_global_offset());
1274   }
1275 
1276   void check_number_of_arguments(int total) {
1277     assert(number_of_arguments() == total, &quot;should be set in DataLayout::initialize&quot;);
1278   }
1279 
1280 public:
1281   VirtualCallTypeData(DataLayout* layout) :
1282     VirtualCallData(layout),
1283     _args(VirtualCallData::static_cell_count()+TypeEntriesAtCall::header_cell_count(), number_of_arguments()),
1284     _ret(cell_count() - SingleTypeEntry::static_cell_count())
1285   {
1286     assert(layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, &quot;wrong type&quot;);
1287     // Some compilers (VC++) don&#39;t want this passed in member initialization list
1288     _args.set_profile_data(this);
1289     _ret.set_profile_data(this);
1290   }
1291 
1292   const TypeStackSlotEntries* args() const {
1293     assert(has_arguments(), &quot;no profiling of arguments&quot;);
1294     return &amp;_args;
1295   }
1296 
1297   const SingleTypeEntry* ret() const {
1298     assert(has_return(), &quot;no profiling of return value&quot;);
1299     return &amp;_ret;
1300   }
1301 
1302   virtual bool is_VirtualCallTypeData() const { return true; }
1303 
1304   static int static_cell_count() {
1305     return -1;
1306   }
1307 
1308   static int compute_cell_count(BytecodeStream* stream) {
1309     return VirtualCallData::static_cell_count() + TypeEntriesAtCall::compute_cell_count(stream);
1310   }
1311 
1312   static void initialize(DataLayout* dl, int cell_count) {
1313     TypeEntriesAtCall::initialize(dl, VirtualCallData::static_cell_count(), cell_count);
1314   }
1315 
1316   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo);
1317 
1318   virtual int cell_count() const {
1319     return VirtualCallData::static_cell_count() +
1320       TypeEntriesAtCall::header_cell_count() +
1321       int_at_unchecked(cell_count_global_offset());
1322   }
1323 
1324   int number_of_arguments() const {
1325     return cell_count_no_header() / TypeStackSlotEntries::per_arg_count();
1326   }
1327 
1328   void set_argument_type(int i, Klass* k) {
1329     assert(has_arguments(), &quot;no arguments!&quot;);
1330     intptr_t current = _args.type(i);
1331     _args.set_type(i, TypeEntries::with_status(k, current));
1332   }
1333 
1334   void set_return_type(Klass* k) {
1335     assert(has_return(), &quot;no return!&quot;);
1336     intptr_t current = _ret.type();
1337     _ret.set_type(TypeEntries::with_status(k, current));
1338   }
1339 
1340   // An entry for a return value takes less space than an entry for an
1341   // argument, so if the remainder of the number of cells divided by
1342   // the number of cells for an argument is not null, a return value
1343   // is profiled in this object.
1344   bool has_return() const {
1345     bool res = (cell_count_no_header() % TypeStackSlotEntries::per_arg_count()) != 0;
1346     assert (!res || TypeEntriesAtCall::return_profiling_enabled(), &quot;no profiling of return values&quot;);
1347     return res;
1348   }
1349 
1350   // An entry for a return value takes less space than an entry for an
1351   // argument so if the number of cells exceeds the number of cells
1352   // needed for an argument, this object contains type information for
1353   // at least one argument.
1354   bool has_arguments() const {
1355     bool res = cell_count_no_header() &gt;= TypeStackSlotEntries::per_arg_count();
1356     assert (!res || TypeEntriesAtCall::arguments_profiling_enabled(), &quot;no profiling of arguments&quot;);
1357     return res;
1358   }
1359 
1360   // Code generation support
1361   static ByteSize args_data_offset() {
1362     return cell_offset(VirtualCallData::static_cell_count()) + TypeEntriesAtCall::args_data_offset();
1363   }
1364 
1365   ByteSize argument_type_offset(int i) {
1366     return _args.type_offset(i);
1367   }
1368 
1369   ByteSize return_type_offset() {
1370     return _ret.type_offset();
1371   }
1372 
1373   // GC support
1374   virtual void clean_weak_klass_links(bool always_clean) {
1375     ReceiverTypeData::clean_weak_klass_links(always_clean);
1376     if (has_arguments()) {
1377       _args.clean_weak_klass_links(always_clean);
1378     }
1379     if (has_return()) {
1380       _ret.clean_weak_klass_links(always_clean);
1381     }
1382   }
1383 
1384   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1385 };
1386 
1387 // RetData
1388 //
1389 // A RetData is used to access profiling information for a ret bytecode.
1390 // It is composed of a count of the number of times that the ret has
1391 // been executed, followed by a series of triples of the form
1392 // (bci, count, di) which count the number of times that some bci was the
1393 // target of the ret and cache a corresponding data displacement.
1394 class RetData : public CounterData {
1395 protected:
1396   enum {
1397     bci0_offset = counter_cell_count,
1398     count0_offset,
1399     displacement0_offset,
1400     ret_row_cell_count = (displacement0_offset + 1) - bci0_offset
1401   };
1402 
1403   void set_bci(uint row, int bci) {
1404     assert((uint)row &lt; row_limit(), &quot;oob&quot;);
1405     set_int_at(bci0_offset + row * ret_row_cell_count, bci);
1406   }
1407   void release_set_bci(uint row, int bci);
1408   void set_bci_count(uint row, uint count) {
1409     assert((uint)row &lt; row_limit(), &quot;oob&quot;);
1410     set_uint_at(count0_offset + row * ret_row_cell_count, count);
1411   }
1412   void set_bci_displacement(uint row, int disp) {
1413     set_int_at(displacement0_offset + row * ret_row_cell_count, disp);
1414   }
1415 
1416 public:
1417   RetData(DataLayout* layout) : CounterData(layout) {
1418     assert(layout-&gt;tag() == DataLayout::ret_data_tag, &quot;wrong type&quot;);
1419   }
1420 
1421   virtual bool is_RetData() const { return true; }
1422 
1423   enum {
1424     no_bci = -1 // value of bci when bci1/2 are not in use.
1425   };
1426 
1427   static int static_cell_count() {
1428     return counter_cell_count + (uint) BciProfileWidth * ret_row_cell_count;
1429   }
1430 
1431   virtual int cell_count() const {
1432     return static_cell_count();
1433   }
1434 
1435   static uint row_limit() {
1436     return BciProfileWidth;
1437   }
1438   static int bci_cell_index(uint row) {
1439     return bci0_offset + row * ret_row_cell_count;
1440   }
1441   static int bci_count_cell_index(uint row) {
1442     return count0_offset + row * ret_row_cell_count;
1443   }
1444   static int bci_displacement_cell_index(uint row) {
1445     return displacement0_offset + row * ret_row_cell_count;
1446   }
1447 
1448   // Direct accessors
1449   int bci(uint row) const {
1450     return int_at(bci_cell_index(row));
1451   }
1452   uint bci_count(uint row) const {
1453     return uint_at(bci_count_cell_index(row));
1454   }
1455   int bci_displacement(uint row) const {
1456     return int_at(bci_displacement_cell_index(row));
1457   }
1458 
1459   // Interpreter Runtime support
1460   address fixup_ret(int return_bci, MethodData* mdo);
1461 
1462   // Code generation support
1463   static ByteSize bci_offset(uint row) {
1464     return cell_offset(bci_cell_index(row));
1465   }
1466   static ByteSize bci_count_offset(uint row) {
1467     return cell_offset(bci_count_cell_index(row));
1468   }
1469   static ByteSize bci_displacement_offset(uint row) {
1470     return cell_offset(bci_displacement_cell_index(row));
1471   }
1472 
1473   // Specific initialization.
1474   void post_initialize(BytecodeStream* stream, MethodData* mdo);
1475 
1476   void print_data_on(outputStream* st, const char* extra = NULL) const;
1477 };
1478 
1479 // BranchData
1480 //
1481 // A BranchData is used to access profiling data for a two-way branch.
1482 // It consists of taken and not_taken counts as well as a data displacement
1483 // for the taken case.
1484 class BranchData : public JumpData {
1485   friend class VMStructs;
1486   friend class JVMCIVMStructs;
1487 protected:
1488   enum {
1489     not_taken_off_set = jump_cell_count,
1490     branch_cell_count
1491   };
1492 
1493   void set_displacement(int displacement) {
1494     set_int_at(displacement_off_set, displacement);
1495   }
1496 
1497 public:
1498   BranchData(DataLayout* layout) : JumpData(layout) {
1499     assert(layout-&gt;tag() == DataLayout::branch_data_tag, &quot;wrong type&quot;);
1500   }
1501 
1502   virtual bool is_BranchData() const { return true; }
1503 
1504   static int static_cell_count() {
1505     return branch_cell_count;
1506   }
1507 
1508   virtual int cell_count() const {
1509     return static_cell_count();
1510   }
1511 
1512   // Direct accessor
1513   uint not_taken() const {
1514     return uint_at(not_taken_off_set);
1515   }
1516 
1517   void set_not_taken(uint cnt) {
1518     set_uint_at(not_taken_off_set, cnt);
1519   }
1520 
1521   uint inc_not_taken() {
1522     uint cnt = not_taken() + 1;
1523     // Did we wrap? Will compiler screw us??
1524     if (cnt == 0) cnt--;
1525     set_uint_at(not_taken_off_set, cnt);
1526     return cnt;
1527   }
1528 
1529   // Code generation support
1530   static ByteSize not_taken_offset() {
1531     return cell_offset(not_taken_off_set);
1532   }
1533   static ByteSize branch_data_size() {
1534     return cell_offset(branch_cell_count);
1535   }
1536 
1537   // Specific initialization.
1538   void post_initialize(BytecodeStream* stream, MethodData* mdo);
1539 
1540   void print_data_on(outputStream* st, const char* extra = NULL) const;
1541 };
1542 
1543 // ArrayData
1544 //
1545 // A ArrayData is a base class for accessing profiling data which does
1546 // not have a statically known size.  It consists of an array length
1547 // and an array start.
1548 class ArrayData : public ProfileData {
1549   friend class VMStructs;
1550   friend class JVMCIVMStructs;
1551 protected:
1552   friend class DataLayout;
1553 
1554   enum {
1555     array_len_off_set,
1556     array_start_off_set
1557   };
1558 
1559   uint array_uint_at(int index) const {
1560     int aindex = index + array_start_off_set;
1561     return uint_at(aindex);
1562   }
1563   int array_int_at(int index) const {
1564     int aindex = index + array_start_off_set;
1565     return int_at(aindex);
1566   }
1567   oop array_oop_at(int index) const {
1568     int aindex = index + array_start_off_set;
1569     return oop_at(aindex);
1570   }
1571   void array_set_int_at(int index, int value) {
1572     int aindex = index + array_start_off_set;
1573     set_int_at(aindex, value);
1574   }
1575 
1576   // Code generation support for subclasses.
1577   static ByteSize array_element_offset(int index) {
1578     return cell_offset(array_start_off_set + index);
1579   }
1580 
1581 public:
1582   ArrayData(DataLayout* layout) : ProfileData(layout) {}
1583 
1584   virtual bool is_ArrayData() const { return true; }
1585 
1586   static int static_cell_count() {
1587     return -1;
1588   }
1589 
1590   int array_len() const {
1591     return int_at_unchecked(array_len_off_set);
1592   }
1593 
1594   virtual int cell_count() const {
1595     return array_len() + 1;
1596   }
1597 
1598   // Code generation support
1599   static ByteSize array_len_offset() {
1600     return cell_offset(array_len_off_set);
1601   }
1602   static ByteSize array_start_offset() {
1603     return cell_offset(array_start_off_set);
1604   }
1605 };
1606 
1607 // MultiBranchData
1608 //
1609 // A MultiBranchData is used to access profiling information for
1610 // a multi-way branch (*switch bytecodes).  It consists of a series
1611 // of (count, displacement) pairs, which count the number of times each
1612 // case was taken and specify the data displacment for each branch target.
1613 class MultiBranchData : public ArrayData {
1614   friend class VMStructs;
1615   friend class JVMCIVMStructs;
1616 protected:
1617   enum {
1618     default_count_off_set,
1619     default_disaplacement_off_set,
1620     case_array_start
1621   };
1622   enum {
1623     relative_count_off_set,
1624     relative_displacement_off_set,
1625     per_case_cell_count
1626   };
1627 
1628   void set_default_displacement(int displacement) {
1629     array_set_int_at(default_disaplacement_off_set, displacement);
1630   }
1631   void set_displacement_at(int index, int displacement) {
1632     array_set_int_at(case_array_start +
1633                      index * per_case_cell_count +
1634                      relative_displacement_off_set,
1635                      displacement);
1636   }
1637 
1638 public:
1639   MultiBranchData(DataLayout* layout) : ArrayData(layout) {
1640     assert(layout-&gt;tag() == DataLayout::multi_branch_data_tag, &quot;wrong type&quot;);
1641   }
1642 
1643   virtual bool is_MultiBranchData() const { return true; }
1644 
1645   static int compute_cell_count(BytecodeStream* stream);
1646 
1647   int number_of_cases() const {
1648     int alen = array_len() - 2; // get rid of default case here.
1649     assert(alen % per_case_cell_count == 0, &quot;must be even&quot;);
1650     return (alen / per_case_cell_count);
1651   }
1652 
1653   uint default_count() const {
1654     return array_uint_at(default_count_off_set);
1655   }
1656   int default_displacement() const {
1657     return array_int_at(default_disaplacement_off_set);
1658   }
1659 
1660   uint count_at(int index) const {
1661     return array_uint_at(case_array_start +
1662                          index * per_case_cell_count +
1663                          relative_count_off_set);
1664   }
1665   int displacement_at(int index) const {
1666     return array_int_at(case_array_start +
1667                         index * per_case_cell_count +
1668                         relative_displacement_off_set);
1669   }
1670 
1671   // Code generation support
1672   static ByteSize default_count_offset() {
1673     return array_element_offset(default_count_off_set);
1674   }
1675   static ByteSize default_displacement_offset() {
1676     return array_element_offset(default_disaplacement_off_set);
1677   }
1678   static ByteSize case_count_offset(int index) {
1679     return case_array_offset() +
1680            (per_case_size() * index) +
1681            relative_count_offset();
1682   }
1683   static ByteSize case_array_offset() {
1684     return array_element_offset(case_array_start);
1685   }
1686   static ByteSize per_case_size() {
1687     return in_ByteSize(per_case_cell_count) * cell_size;
1688   }
1689   static ByteSize relative_count_offset() {
1690     return in_ByteSize(relative_count_off_set) * cell_size;
1691   }
1692   static ByteSize relative_displacement_offset() {
1693     return in_ByteSize(relative_displacement_off_set) * cell_size;
1694   }
1695 
1696   // Specific initialization.
1697   void post_initialize(BytecodeStream* stream, MethodData* mdo);
1698 
1699   void print_data_on(outputStream* st, const char* extra = NULL) const;
1700 };
1701 
1702 class ArgInfoData : public ArrayData {
1703 
1704 public:
1705   ArgInfoData(DataLayout* layout) : ArrayData(layout) {
1706     assert(layout-&gt;tag() == DataLayout::arg_info_data_tag, &quot;wrong type&quot;);
1707   }
1708 
1709   virtual bool is_ArgInfoData() const { return true; }
1710 
1711 
1712   int number_of_args() const {
1713     return array_len();
1714   }
1715 
1716   uint arg_modified(int arg) const {
1717     return array_uint_at(arg);
1718   }
1719 
1720   void set_arg_modified(int arg, uint val) {
1721     array_set_int_at(arg, val);
1722   }
1723 
1724   void print_data_on(outputStream* st, const char* extra = NULL) const;
1725 };
1726 
1727 // ParametersTypeData
1728 //
1729 // A ParametersTypeData is used to access profiling information about
1730 // types of parameters to a method
1731 class ParametersTypeData : public ArrayData {
1732 
1733 private:
1734   TypeStackSlotEntries _parameters;
1735 
1736   static int stack_slot_local_offset(int i) {
1737     assert_profiling_enabled();
1738     return array_start_off_set + TypeStackSlotEntries::stack_slot_local_offset(i);
1739   }
1740 
1741   static int type_local_offset(int i) {
1742     assert_profiling_enabled();
1743     return array_start_off_set + TypeStackSlotEntries::type_local_offset(i);
1744   }
1745 
1746   static bool profiling_enabled();
1747   static void assert_profiling_enabled() {
1748     assert(profiling_enabled(), &quot;method parameters profiling should be on&quot;);
1749   }
1750 
1751 public:
1752   ParametersTypeData(DataLayout* layout) : ArrayData(layout), _parameters(1, number_of_parameters()) {
1753     assert(layout-&gt;tag() == DataLayout::parameters_type_data_tag, &quot;wrong type&quot;);
1754     // Some compilers (VC++) don&#39;t want this passed in member initialization list
1755     _parameters.set_profile_data(this);
1756   }
1757 
1758   static int compute_cell_count(Method* m);
1759 
1760   virtual bool is_ParametersTypeData() const { return true; }
1761 
1762   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo);
1763 
1764   int number_of_parameters() const {
1765     return array_len() / TypeStackSlotEntries::per_arg_count();
1766   }
1767 
1768   const TypeStackSlotEntries* parameters() const { return &amp;_parameters; }
1769 
1770   uint stack_slot(int i) const {
1771     return _parameters.stack_slot(i);
1772   }
1773 
1774   void set_type(int i, Klass* k) {
1775     intptr_t current = _parameters.type(i);
1776     _parameters.set_type(i, TypeEntries::with_status((intptr_t)k, current));
1777   }
1778 
1779   virtual void clean_weak_klass_links(bool always_clean) {
1780     _parameters.clean_weak_klass_links(always_clean);
1781   }
1782 
1783   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1784 
1785   static ByteSize stack_slot_offset(int i) {
1786     return cell_offset(stack_slot_local_offset(i));
1787   }
1788 
1789   static ByteSize type_offset(int i) {
1790     return cell_offset(type_local_offset(i));
1791   }
1792 };
1793 
1794 // SpeculativeTrapData
1795 //
1796 // A SpeculativeTrapData is used to record traps due to type
1797 // speculation. It records the root of the compilation: that type
1798 // speculation is wrong in the context of one compilation (for
1799 // method1) doesn&#39;t mean it&#39;s wrong in the context of another one (for
1800 // method2). Type speculation could have more/different data in the
1801 // context of the compilation of method2 and it&#39;s worthwhile to try an
1802 // optimization that failed for compilation of method1 in the context
1803 // of compilation of method2.
1804 // Space for SpeculativeTrapData entries is allocated from the extra
1805 // data space in the MDO. If we run out of space, the trap data for
1806 // the ProfileData at that bci is updated.
1807 class SpeculativeTrapData : public ProfileData {
1808 protected:
1809   enum {
1810     speculative_trap_method,
1811 #ifndef _LP64
1812     // The size of the area for traps is a multiple of the header
1813     // size, 2 cells on 32 bits. Packed at the end of this area are
1814     // argument info entries (with tag
1815     // DataLayout::arg_info_data_tag). The logic in
1816     // MethodData::bci_to_extra_data() that guarantees traps don&#39;t
1817     // overflow over argument info entries assumes the size of a
1818     // SpeculativeTrapData is twice the header size. On 32 bits, a
1819     // SpeculativeTrapData must be 4 cells.
1820     padding,
1821 #endif
1822     speculative_trap_cell_count
1823   };
1824 public:
1825   SpeculativeTrapData(DataLayout* layout) : ProfileData(layout) {
1826     assert(layout-&gt;tag() == DataLayout::speculative_trap_data_tag, &quot;wrong type&quot;);
1827   }
1828 
1829   virtual bool is_SpeculativeTrapData() const { return true; }
1830 
1831   static int static_cell_count() {
1832     return speculative_trap_cell_count;
1833   }
1834 
1835   virtual int cell_count() const {
1836     return static_cell_count();
1837   }
1838 
1839   // Direct accessor
1840   Method* method() const {
1841     return (Method*)intptr_at(speculative_trap_method);
1842   }
1843 
1844   void set_method(Method* m) {
1845     assert(!m-&gt;is_old(), &quot;cannot add old methods&quot;);
1846     set_intptr_at(speculative_trap_method, (intptr_t)m);
1847   }
1848 
1849   static ByteSize method_offset() {
1850     return cell_offset(speculative_trap_method);
1851   }
1852 
1853   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1854 };
1855 
1856 class ArrayLoadStoreData : public ProfileData {
1857 private:
1858   enum {
1859     flat_array_flag = DataLayout::first_flag,
1860     null_free_array_flag = flat_array_flag + 1,
1861   };
1862 
1863   SingleTypeEntry _array;
1864   SingleTypeEntry _element;
1865 
1866 public:
1867   ArrayLoadStoreData(DataLayout* layout) :
1868     ProfileData(layout),
1869     _array(0),
1870     _element(SingleTypeEntry::static_cell_count()) {
1871     assert(layout-&gt;tag() == DataLayout::array_load_store_data_tag, &quot;wrong type&quot;);
1872     _array.set_profile_data(this);
1873     _element.set_profile_data(this);
1874   }
1875 
1876   const SingleTypeEntry* array() const {
1877     return &amp;_array;
1878   }
1879 
1880   const SingleTypeEntry* element() const {
1881     return &amp;_element;
1882   }
1883 
1884   virtual bool is_ArrayLoadStoreData() const { return true; }
1885 
1886   static int static_cell_count() {
1887     return SingleTypeEntry::static_cell_count() * 2;
1888   }
1889 
1890   virtual int cell_count() const {
1891     return static_cell_count();
1892   }
1893 
1894   void set_flat_array() { set_flag_at(flat_array_flag); }
1895   bool flat_array() const { return flag_at(flat_array_flag); }
1896 
1897   void set_null_free_array() { set_flag_at(null_free_array_flag); }
1898   bool null_free_array() const { return flag_at(null_free_array_flag); }
1899 
1900   // Code generation support
1901   static int flat_array_byte_constant() {
1902     return flag_number_to_constant(flat_array_flag);
1903   }
1904 
1905   static int null_free_array_byte_constant() {
1906     return flag_number_to_constant(null_free_array_flag);
1907   }
1908 
1909   static ByteSize array_offset() {
1910     return cell_offset(0);
1911   }
1912 
1913   static ByteSize element_offset() {
1914     return cell_offset(SingleTypeEntry::static_cell_count());
1915   }
1916 
1917   virtual void clean_weak_klass_links(bool always_clean) {
1918     _array.clean_weak_klass_links(always_clean);
1919     _element.clean_weak_klass_links(always_clean);
1920   }
1921 
1922   static ByteSize array_load_store_data_size() {
1923     return cell_offset(static_cell_count());
1924   }
1925 
1926   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1927 };
1928 
1929 // MethodData*
1930 //
1931 // A MethodData* holds information which has been collected about
1932 // a method.  Its layout looks like this:
1933 //
1934 // -----------------------------
1935 // | header                    |
1936 // | klass                     |
1937 // -----------------------------
1938 // | method                    |
1939 // | size of the MethodData* |
1940 // -----------------------------
1941 // | Data entries...           |
1942 // |   (variable size)         |
1943 // |                           |
1944 // .                           .
1945 // .                           .
1946 // .                           .
1947 // |                           |
1948 // -----------------------------
1949 //
1950 // The data entry area is a heterogeneous array of DataLayouts. Each
1951 // DataLayout in the array corresponds to a specific bytecode in the
1952 // method.  The entries in the array are sorted by the corresponding
1953 // bytecode.  Access to the data is via resource-allocated ProfileData,
1954 // which point to the underlying blocks of DataLayout structures.
1955 //
1956 // During interpretation, if profiling in enabled, the interpreter
1957 // maintains a method data pointer (mdp), which points at the entry
1958 // in the array corresponding to the current bci.  In the course of
1959 // intepretation, when a bytecode is encountered that has profile data
1960 // associated with it, the entry pointed to by mdp is updated, then the
1961 // mdp is adjusted to point to the next appropriate DataLayout.  If mdp
1962 // is NULL to begin with, the interpreter assumes that the current method
1963 // is not (yet) being profiled.
1964 //
1965 // In MethodData* parlance, &quot;dp&quot; is a &quot;data pointer&quot;, the actual address
1966 // of a DataLayout element.  A &quot;di&quot; is a &quot;data index&quot;, the offset in bytes
1967 // from the base of the data entry array.  A &quot;displacement&quot; is the byte offset
1968 // in certain ProfileData objects that indicate the amount the mdp must be
1969 // adjusted in the event of a change in control flow.
1970 //
1971 
1972 class CleanExtraDataClosure : public StackObj {
1973 public:
1974   virtual bool is_live(Method* m) = 0;
1975 };
1976 
1977 
1978 #if INCLUDE_JVMCI
1979 // Encapsulates an encoded speculation reason. These are linked together in
1980 // a list that is atomically appended to during deoptimization. Entries are
1981 // never removed from the list.
1982 // @see jdk.vm.ci.hotspot.HotSpotSpeculationLog.HotSpotSpeculationEncoding
1983 class FailedSpeculation: public CHeapObj&lt;mtCompiler&gt; {
1984  private:
1985   // The length of HotSpotSpeculationEncoding.toByteArray(). The data itself
1986   // is an array embedded at the end of this object.
1987   int   _data_len;
1988 
1989   // Next entry in a linked list.
1990   FailedSpeculation* _next;
1991 
1992   FailedSpeculation(address data, int data_len);
1993 
1994   FailedSpeculation** next_adr() { return &amp;_next; }
1995 
1996   // Placement new operator for inlining the speculation data into
1997   // the FailedSpeculation object.
1998   void* operator new(size_t size, size_t fs_size) throw();
1999 
2000  public:
2001   char* data()         { return (char*)(((address) this) + sizeof(FailedSpeculation)); }
2002   int data_len() const { return _data_len; }
2003   FailedSpeculation* next() const { return _next; }
2004 
2005   // Atomically appends a speculation from nm to the list whose head is at (*failed_speculations_address).
2006   // Returns false if the FailedSpeculation object could not be allocated.
2007   static bool add_failed_speculation(nmethod* nm, FailedSpeculation** failed_speculations_address, address speculation, int speculation_len);
2008 
2009   // Frees all entries in the linked list whose head is at (*failed_speculations_address).
2010   static void free_failed_speculations(FailedSpeculation** failed_speculations_address);
2011 };
2012 #endif
2013 
2014 class MethodData : public Metadata {
2015   friend class VMStructs;
2016   friend class JVMCIVMStructs;
2017 private:
2018   friend class ProfileData;
2019   friend class TypeEntriesAtCall;
2020 
2021   // If you add a new field that points to any metaspace object, you
2022   // must add this field to MethodData::metaspace_pointers_do().
2023 
2024   // Back pointer to the Method*
2025   Method* _method;
2026 
2027   // Size of this oop in bytes
2028   int _size;
2029 
2030   // Cached hint for bci_to_dp and bci_to_data
2031   int _hint_di;
2032 
2033   Mutex _extra_data_lock;
2034 
2035   MethodData(const methodHandle&amp; method, int size, TRAPS);
2036 public:
2037   static MethodData* allocate(ClassLoaderData* loader_data, const methodHandle&amp; method, TRAPS);
2038   MethodData() : _extra_data_lock(Mutex::leaf, &quot;MDO extra data lock&quot;) {}; // For ciMethodData
2039 
2040   bool is_methodData() const volatile { return true; }
2041   void initialize();
2042 
2043   // Whole-method sticky bits and flags
2044   enum {
2045     _trap_hist_limit    = 25 JVMCI_ONLY(+5),   // decoupled from Deoptimization::Reason_LIMIT
2046     _trap_hist_mask     = max_jubyte,
2047     _extra_data_count   = 4     // extra DataLayout headers, for trap history
2048   }; // Public flag values
2049 private:
2050   uint _nof_decompiles;             // count of all nmethod removals
2051   uint _nof_overflow_recompiles;    // recompile count, excluding recomp. bits
2052   uint _nof_overflow_traps;         // trap count, excluding _trap_hist
2053   union {
2054     intptr_t _align;
2055     u1 _array[JVMCI_ONLY(2 *) _trap_hist_limit];
2056   } _trap_hist;
2057 
2058   // Support for interprocedural escape analysis, from Thomas Kotzmann.
2059   intx              _eflags;          // flags on escape information
2060   intx              _arg_local;       // bit set of non-escaping arguments
2061   intx              _arg_stack;       // bit set of stack-allocatable arguments
2062   intx              _arg_returned;    // bit set of returned arguments
2063 
2064   int _creation_mileage;              // method mileage at MDO creation
2065 
2066   // How many invocations has this MDO seen?
2067   // These counters are used to determine the exact age of MDO.
2068   // We need those because in tiered a method can be concurrently
2069   // executed at different levels.
2070   InvocationCounter _invocation_counter;
2071   // Same for backedges.
2072   InvocationCounter _backedge_counter;
2073   // Counter values at the time profiling started.
2074   int               _invocation_counter_start;
2075   int               _backedge_counter_start;
2076   uint              _tenure_traps;
2077   int               _invoke_mask;      // per-method Tier0InvokeNotifyFreqLog
2078   int               _backedge_mask;    // per-method Tier0BackedgeNotifyFreqLog
2079 
2080 #if INCLUDE_RTM_OPT
2081   // State of RTM code generation during compilation of the method
2082   int               _rtm_state;
2083 #endif
2084 
2085   // Number of loops and blocks is computed when compiling the first
2086   // time with C1. It is used to determine if method is trivial.
2087   short             _num_loops;
2088   short             _num_blocks;
2089   // Does this method contain anything worth profiling?
2090   enum WouldProfile {unknown, no_profile, profile};
2091   WouldProfile      _would_profile;
2092 
2093 #if INCLUDE_JVMCI
2094   // Support for HotSpotMethodData.setCompiledIRSize(int)
2095   int                _jvmci_ir_size;
2096   FailedSpeculation* _failed_speculations;
2097 #endif
2098 
2099   // Size of _data array in bytes.  (Excludes header and extra_data fields.)
2100   int _data_size;
2101 
2102   // data index for the area dedicated to parameters. -1 if no
2103   // parameter profiling.
2104   enum { no_parameters = -2, parameters_uninitialized = -1 };
2105   int _parameters_type_data_di;
2106 
2107   // Beginning of the data entries
2108   intptr_t _data[1];
2109 
2110   // Helper for size computation
2111   static int compute_data_size(BytecodeStream* stream);
2112   static int bytecode_cell_count(Bytecodes::Code code);
2113   static bool is_speculative_trap_bytecode(Bytecodes::Code code);
2114   enum { no_profile_data = -1, variable_cell_count = -2 };
2115 
2116   // Helper for initialization
2117   DataLayout* data_layout_at(int data_index) const {
2118     assert(data_index % sizeof(intptr_t) == 0, &quot;unaligned&quot;);
2119     return (DataLayout*) (((address)_data) + data_index);
2120   }
2121 
2122   // Initialize an individual data segment.  Returns the size of
2123   // the segment in bytes.
2124   int initialize_data(BytecodeStream* stream, int data_index);
2125 
2126   // Helper for data_at
2127   DataLayout* limit_data_position() const {
2128     return data_layout_at(_data_size);
2129   }
2130   bool out_of_bounds(int data_index) const {
2131     return data_index &gt;= data_size();
2132   }
2133 
2134   // Give each of the data entries a chance to perform specific
2135   // data initialization.
2136   void post_initialize(BytecodeStream* stream);
2137 
2138   // hint accessors
2139   int      hint_di() const  { return _hint_di; }
2140   void set_hint_di(int di)  {
2141     assert(!out_of_bounds(di), &quot;hint_di out of bounds&quot;);
2142     _hint_di = di;
2143   }
2144   ProfileData* data_before(int bci) {
2145     // avoid SEGV on this edge case
2146     if (data_size() == 0)
2147       return NULL;
2148     int hint = hint_di();
2149     if (data_layout_at(hint)-&gt;bci() &lt;= bci)
2150       return data_at(hint);
2151     return first_data();
2152   }
2153 
2154   // What is the index of the first data entry?
2155   int first_di() const { return 0; }
2156 
2157   ProfileData* bci_to_extra_data_helper(int bci, Method* m, DataLayout*&amp; dp, bool concurrent);
2158   // Find or create an extra ProfileData:
2159   ProfileData* bci_to_extra_data(int bci, Method* m, bool create_if_missing);
2160 
2161   // return the argument info cell
2162   ArgInfoData *arg_info();
2163 
2164   enum {
2165     no_type_profile = 0,
2166     type_profile_jsr292 = 1,
2167     type_profile_all = 2
2168   };
2169 
2170   static bool profile_jsr292(const methodHandle&amp; m, int bci);
2171   static bool profile_unsafe(const methodHandle&amp; m, int bci);
2172   static int profile_arguments_flag();
2173   static bool profile_all_arguments();
2174   static bool profile_arguments_for_invoke(const methodHandle&amp; m, int bci);
2175   static int profile_return_flag();
2176   static bool profile_all_return();
2177   static bool profile_return_for_invoke(const methodHandle&amp; m, int bci);
2178   static int profile_parameters_flag();
2179   static bool profile_parameters_jsr292_only();
2180   static bool profile_all_parameters();
2181 
2182   void clean_extra_data_helper(DataLayout* dp, int shift, bool reset = false);
2183   void verify_extra_data_clean(CleanExtraDataClosure* cl);
2184 
2185 public:
2186   void clean_extra_data(CleanExtraDataClosure* cl);
2187 
2188   static int header_size() {
2189     return sizeof(MethodData)/wordSize;
2190   }
2191 
2192   // Compute the size of a MethodData* before it is created.
2193   static int compute_allocation_size_in_bytes(const methodHandle&amp; method);
2194   static int compute_allocation_size_in_words(const methodHandle&amp; method);
2195   static int compute_extra_data_count(int data_size, int empty_bc_count, bool needs_speculative_traps);
2196 
2197   // Determine if a given bytecode can have profile information.
2198   static bool bytecode_has_profile(Bytecodes::Code code) {
2199     return bytecode_cell_count(code) != no_profile_data;
2200   }
2201 
2202   // reset into original state
2203   void init();
2204 
2205   // My size
2206   int size_in_bytes() const { return _size; }
2207   int size() const    { return align_metadata_size(align_up(_size, BytesPerWord)/BytesPerWord); }
2208 
2209   int      creation_mileage() const  { return _creation_mileage; }
2210   void set_creation_mileage(int x)   { _creation_mileage = x; }
2211 
2212   int invocation_count() {
2213     if (invocation_counter()-&gt;carry()) {
2214       return InvocationCounter::count_limit;
2215     }
2216     return invocation_counter()-&gt;count();
2217   }
2218   int backedge_count() {
2219     if (backedge_counter()-&gt;carry()) {
2220       return InvocationCounter::count_limit;
2221     }
2222     return backedge_counter()-&gt;count();
2223   }
2224 
2225   int invocation_count_start() {
2226     if (invocation_counter()-&gt;carry()) {
2227       return 0;
2228     }
2229     return _invocation_counter_start;
2230   }
2231 
2232   int backedge_count_start() {
2233     if (backedge_counter()-&gt;carry()) {
2234       return 0;
2235     }
2236     return _backedge_counter_start;
2237   }
2238 
2239   int invocation_count_delta() { return invocation_count() - invocation_count_start(); }
2240   int backedge_count_delta()   { return backedge_count()   - backedge_count_start();   }
2241 
2242   void reset_start_counters() {
2243     _invocation_counter_start = invocation_count();
2244     _backedge_counter_start = backedge_count();
2245   }
2246 
2247   InvocationCounter* invocation_counter()     { return &amp;_invocation_counter; }
2248   InvocationCounter* backedge_counter()       { return &amp;_backedge_counter;   }
2249 
2250 #if INCLUDE_JVMCI
2251   FailedSpeculation** get_failed_speculations_address() {
2252     return &amp;_failed_speculations;
2253   }
2254 #endif
2255 
2256 #if INCLUDE_RTM_OPT
2257   int rtm_state() const {
2258     return _rtm_state;
2259   }
2260   void set_rtm_state(RTMState rstate) {
2261     _rtm_state = (int)rstate;
2262   }
2263   void atomic_set_rtm_state(RTMState rstate) {
2264     Atomic::store(&amp;_rtm_state, (int)rstate);
2265   }
2266 
2267   static int rtm_state_offset_in_bytes() {
2268     return offset_of(MethodData, _rtm_state);
2269   }
2270 #endif
2271 
2272   void set_would_profile(bool p)              { _would_profile = p ? profile : no_profile; }
2273   bool would_profile() const                  { return _would_profile != no_profile; }
2274 
2275   int num_loops() const                       { return _num_loops;  }
2276   void set_num_loops(int n)                   { _num_loops = n;     }
2277   int num_blocks() const                      { return _num_blocks; }
2278   void set_num_blocks(int n)                  { _num_blocks = n;    }
2279 
2280   bool is_mature() const;  // consult mileage and ProfileMaturityPercentage
2281   static int mileage_of(Method* m);
2282 
2283   // Support for interprocedural escape analysis, from Thomas Kotzmann.
2284   enum EscapeFlag {
2285     estimated    = 1 &lt;&lt; 0,
2286     return_local = 1 &lt;&lt; 1,
2287     return_allocated = 1 &lt;&lt; 2,
2288     allocated_escapes = 1 &lt;&lt; 3,
2289     unknown_modified = 1 &lt;&lt; 4
2290   };
2291 
2292   intx eflags()                                  { return _eflags; }
2293   intx arg_local()                               { return _arg_local; }
2294   intx arg_stack()                               { return _arg_stack; }
2295   intx arg_returned()                            { return _arg_returned; }
2296   uint arg_modified(int a)                       { ArgInfoData *aid = arg_info();
2297                                                    assert(aid != NULL, &quot;arg_info must be not null&quot;);
2298                                                    assert(a &gt;= 0 &amp;&amp; a &lt; aid-&gt;number_of_args(), &quot;valid argument number&quot;);
2299                                                    return aid-&gt;arg_modified(a); }
2300 
2301   void set_eflags(intx v)                        { _eflags = v; }
2302   void set_arg_local(intx v)                     { _arg_local = v; }
2303   void set_arg_stack(intx v)                     { _arg_stack = v; }
2304   void set_arg_returned(intx v)                  { _arg_returned = v; }
2305   void set_arg_modified(int a, uint v)           { ArgInfoData *aid = arg_info();
2306                                                    assert(aid != NULL, &quot;arg_info must be not null&quot;);
2307                                                    assert(a &gt;= 0 &amp;&amp; a &lt; aid-&gt;number_of_args(), &quot;valid argument number&quot;);
2308                                                    aid-&gt;set_arg_modified(a, v); }
2309 
2310   void clear_escape_info()                       { _eflags = _arg_local = _arg_stack = _arg_returned = 0; }
2311 
2312   // Location and size of data area
2313   address data_base() const {
2314     return (address) _data;
2315   }
2316   int data_size() const {
2317     return _data_size;
2318   }
2319 
2320   int parameters_size_in_bytes() const {
2321     ParametersTypeData* param = parameters_type_data();
2322     return param == NULL ? 0 : param-&gt;size_in_bytes();
2323   }
2324 
2325   // Accessors
2326   Method* method() const { return _method; }
2327 
2328   // Get the data at an arbitrary (sort of) data index.
2329   ProfileData* data_at(int data_index) const;
2330 
2331   // Walk through the data in order.
2332   ProfileData* first_data() const { return data_at(first_di()); }
2333   ProfileData* next_data(ProfileData* current) const;
2334   bool is_valid(ProfileData* current) const { return current != NULL; }
2335 
2336   // Convert a dp (data pointer) to a di (data index).
2337   int dp_to_di(address dp) const {
2338     return dp - ((address)_data);
2339   }
2340 
2341   // bci to di/dp conversion.
2342   address bci_to_dp(int bci);
2343   int bci_to_di(int bci) {
2344     return dp_to_di(bci_to_dp(bci));
2345   }
2346 
2347   // Get the data at an arbitrary bci, or NULL if there is none.
2348   ProfileData* bci_to_data(int bci);
2349 
2350   // Same, but try to create an extra_data record if one is needed:
2351   ProfileData* allocate_bci_to_data(int bci, Method* m) {
2352     ProfileData* data = NULL;
2353     // If m not NULL, try to allocate a SpeculativeTrapData entry
2354     if (m == NULL) {
2355       data = bci_to_data(bci);
2356     }
2357     if (data != NULL) {
2358       return data;
2359     }
2360     data = bci_to_extra_data(bci, m, true);
2361     if (data != NULL) {
2362       return data;
2363     }
2364     // If SpeculativeTrapData allocation fails try to allocate a
2365     // regular entry
2366     data = bci_to_data(bci);
2367     if (data != NULL) {
2368       return data;
2369     }
2370     return bci_to_extra_data(bci, NULL, true);
2371   }
2372 
2373   // Add a handful of extra data records, for trap tracking.
2374   DataLayout* extra_data_base() const  { return limit_data_position(); }
2375   DataLayout* extra_data_limit() const { return (DataLayout*)((address)this + size_in_bytes()); }
2376   DataLayout* args_data_limit() const  { return (DataLayout*)((address)this + size_in_bytes() -
2377                                                               parameters_size_in_bytes()); }
2378   int extra_data_size() const          { return (address)extra_data_limit() - (address)extra_data_base(); }
2379   static DataLayout* next_extra(DataLayout* dp);
2380 
2381   // Return (uint)-1 for overflow.
2382   uint trap_count(int reason) const {
2383     assert((uint)reason &lt; JVMCI_ONLY(2*) _trap_hist_limit, &quot;oob&quot;);
2384     return (int)((_trap_hist._array[reason]+1) &amp; _trap_hist_mask) - 1;
2385   }
2386   // For loops:
2387   static uint trap_reason_limit() { return _trap_hist_limit; }
2388   static uint trap_count_limit()  { return _trap_hist_mask; }
2389   uint inc_trap_count(int reason) {
2390     // Count another trap, anywhere in this method.
2391     assert(reason &gt;= 0, &quot;must be single trap&quot;);
2392     assert((uint)reason &lt; JVMCI_ONLY(2*) _trap_hist_limit, &quot;oob&quot;);
2393     uint cnt1 = 1 + _trap_hist._array[reason];
2394     if ((cnt1 &amp; _trap_hist_mask) != 0) {  // if no counter overflow...
2395       _trap_hist._array[reason] = cnt1;
2396       return cnt1;
2397     } else {
2398       return _trap_hist_mask + (++_nof_overflow_traps);
2399     }
2400   }
2401 
2402   uint overflow_trap_count() const {
2403     return _nof_overflow_traps;
2404   }
2405   uint overflow_recompile_count() const {
2406     return _nof_overflow_recompiles;
2407   }
2408   void inc_overflow_recompile_count() {
2409     _nof_overflow_recompiles += 1;
2410   }
2411   uint decompile_count() const {
2412     return _nof_decompiles;
2413   }
2414   void inc_decompile_count() {
2415     _nof_decompiles += 1;
2416     if (decompile_count() &gt; (uint)PerMethodRecompilationCutoff) {
2417       method()-&gt;set_not_compilable(&quot;decompile_count &gt; PerMethodRecompilationCutoff&quot;, CompLevel_full_optimization);
2418     }
2419   }
2420   uint tenure_traps() const {
2421     return _tenure_traps;
2422   }
2423   void inc_tenure_traps() {
2424     _tenure_traps += 1;
2425   }
2426 
2427   // Return pointer to area dedicated to parameters in MDO
2428   ParametersTypeData* parameters_type_data() const {
2429     assert(_parameters_type_data_di != parameters_uninitialized, &quot;called too early&quot;);
2430     return _parameters_type_data_di != no_parameters ? data_layout_at(_parameters_type_data_di)-&gt;data_in()-&gt;as_ParametersTypeData() : NULL;
2431   }
2432 
2433   int parameters_type_data_di() const {
2434     assert(_parameters_type_data_di != parameters_uninitialized &amp;&amp; _parameters_type_data_di != no_parameters, &quot;no args type data&quot;);
2435     return _parameters_type_data_di;
2436   }
2437 
2438   // Support for code generation
2439   static ByteSize data_offset() {
2440     return byte_offset_of(MethodData, _data[0]);
2441   }
2442 
2443   static ByteSize trap_history_offset() {
2444     return byte_offset_of(MethodData, _trap_hist._array);
2445   }
2446 
2447   static ByteSize invocation_counter_offset() {
2448     return byte_offset_of(MethodData, _invocation_counter);
2449   }
2450 
2451   static ByteSize backedge_counter_offset() {
2452     return byte_offset_of(MethodData, _backedge_counter);
2453   }
2454 
2455   static ByteSize invoke_mask_offset() {
2456     return byte_offset_of(MethodData, _invoke_mask);
2457   }
2458 
2459   static ByteSize backedge_mask_offset() {
2460     return byte_offset_of(MethodData, _backedge_mask);
2461   }
2462 
2463   static ByteSize parameters_type_data_di_offset() {
2464     return byte_offset_of(MethodData, _parameters_type_data_di);
2465   }
2466 
2467   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
2468   virtual MetaspaceObj::Type type() const { return MethodDataType; }
2469 
2470   // Deallocation support - no metaspace pointer fields to deallocate
2471   void deallocate_contents(ClassLoaderData* loader_data) {}
2472 
2473   // GC support
2474   void set_size(int object_size_in_bytes) { _size = object_size_in_bytes; }
2475 
2476   // Printing
2477   void print_on      (outputStream* st) const;
2478   void print_value_on(outputStream* st) const;
2479 
2480   // printing support for method data
2481   void print_data_on(outputStream* st) const;
2482 
2483   const char* internal_name() const { return &quot;{method data}&quot;; }
2484 
2485   // verification
2486   void verify_on(outputStream* st);
2487   void verify_data_on(outputStream* st);
2488 
2489   static bool profile_parameters_for_method(const methodHandle&amp; m);
2490   static bool profile_arguments();
2491   static bool profile_arguments_jsr292_only();
2492   static bool profile_return();
2493   static bool profile_parameters();
2494   static bool profile_return_jsr292_only();
2495 
2496   void clean_method_data(bool always_clean);
2497   void clean_weak_method_links();
2498   DEBUG_ONLY(void verify_clean_weak_method_links();)
2499   Mutex* extra_data_lock() { return &amp;_extra_data_lock; }
2500 };
2501 
2502 #endif // SHARE_OOPS_METHODDATA_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
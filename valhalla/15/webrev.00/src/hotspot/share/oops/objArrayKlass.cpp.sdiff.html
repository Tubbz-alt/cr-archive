<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/objArrayKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodData.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopsHierarchy.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/objArrayKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 73     Klass* element_super = element_klass-&gt;super();
 74     if (element_super != NULL) {
 75       // The element type has a direct super.  E.g., String[] has direct super of Object[].
 76       super_klass = element_super-&gt;array_klass_or_null(ArrayStorageProperties::empty);
 77       bool supers_exist = super_klass != NULL;
 78       // Also, see if the element has secondary supertypes.
 79       // We need an array type for each.
 80       const Array&lt;Klass*&gt;* element_supers = element_klass-&gt;secondary_supers();
 81       for( int i = element_supers-&gt;length()-1; i &gt;= 0; i-- ) {
 82         Klass* elem_super = element_supers-&gt;at(i);
 83         if (elem_super-&gt;array_klass_or_null(ArrayStorageProperties::empty) == NULL) {
 84           supers_exist = false;
 85           break;
 86         }
 87       }
 88       if (!supers_exist) {
 89         // Oops.  Not allocated yet.  Back out, allocate it, and retry.
 90         Klass* ek = NULL;
 91         {
 92           MutexUnlocker mu(MultiArray_lock);
<span class="line-modified"> 93           super_klass = element_super-&gt;array_klass(CHECK_0);</span>
 94           for( int i = element_supers-&gt;length()-1; i &gt;= 0; i-- ) {
 95             Klass* elem_super = element_supers-&gt;at(i);
<span class="line-modified"> 96             elem_super-&gt;array_klass(CHECK_0);</span>
 97           }
 98           // Now retry from the beginning
<span class="line-modified"> 99           ek = element_klass-&gt;array_klass(storage_props, n, CHECK_0);</span>
100         }  // re-lock
101         return ek;
102       }
103     } else {
104       // The element type is already Object.  Object[] has direct super of Object.
105       super_klass = SystemDictionary::Object_klass();
106     }
107   }
108 
109   // Create type name for klass.
110   Symbol* name = ArrayKlass::create_element_klass_array_name(storage_props.is_null_free(), element_klass, CHECK_NULL);
111 
112   // Initialize instance variables
113   ClassLoaderData* loader_data = element_klass-&gt;class_loader_data();
<span class="line-modified">114   ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, CHECK_0);</span>
115 
116   ModuleEntry* module = oak-&gt;module();
117   assert(module != NULL, &quot;No module entry for array&quot;);
118 
119   // Call complete_create_array_klass after all instance variables has been initialized.
<span class="line-modified">120   ArrayKlass::complete_create_array_klass(oak, super_klass, module, CHECK_0);</span>
121 
122   // Add all classes to our internal class loader list here,
123   // including classes in the bootstrap (NULL) class loader.
124   // Do this step after creating the mirror so that if the
125   // mirror creation fails, loaded_classes_do() doesn&#39;t find
126   // an array class without a mirror.
127   loader_data-&gt;add_class(oak);
128 
129   return oak;
130 }
131 
132 ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {
133   this-&gt;set_dimension(n);
134   this-&gt;set_element_klass(element_klass);
135   // decrement refcount because object arrays are not explicitly freed.  The
136   // InstanceKlass array_name() keeps the name counted while the klass is
137   // loaded.
138   name-&gt;decrement_refcount();
139 
140   Klass* bk;
</pre>
<hr />
<pre>
144     bk = ValueArrayKlass::cast(element_klass)-&gt;element_klass();
145   } else {
146     bk = element_klass;
147   }
148   assert(bk != NULL &amp;&amp; (bk-&gt;is_instance_klass()
149       || bk-&gt;is_typeArray_klass()), &quot;invalid bottom klass&quot;);
150   this-&gt;set_bottom_klass(bk);
151   this-&gt;set_class_loader_data(bk-&gt;class_loader_data());
152 
153   this-&gt;set_layout_helper(array_layout_helper(T_OBJECT));
154   assert(this-&gt;is_array_klass(), &quot;sanity&quot;);
155   assert(this-&gt;is_objArray_klass(), &quot;sanity&quot;);
156 }
157 
158 int ObjArrayKlass::oop_size(oop obj) const {
159   assert(obj-&gt;is_objArray(), &quot;must be object array&quot;);
160   return objArrayOop(obj)-&gt;object_size();
161 }
162 
163 objArrayOop ObjArrayKlass::allocate(int length, TRAPS) {
<span class="line-modified">164   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_0);</span>
165   int size = objArrayOopDesc::object_size(length);
166   bool populate_null_free = storage_properties().is_null_free();
167   objArrayOop array =  (objArrayOop)Universe::heap()-&gt;array_allocate(this, size, length,
168                                                        /* do_zero */ true, THREAD);
169   if (populate_null_free) {
170     assert(dimension() == 1, &quot;Can only populate the final dimension&quot;);
171     assert(element_klass()-&gt;is_value(), &quot;Unexpected&quot;);
172     assert(!element_klass()-&gt;is_array_klass(), &quot;ArrayKlass unexpected here&quot;);
173     assert(!ValueKlass::cast(element_klass())-&gt;flatten_array(), &quot;Expected valueArrayOop allocation&quot;);
174     element_klass()-&gt;initialize(CHECK_NULL);
175     // Populate default values...
176     objArrayHandle array_h(THREAD, array);
177     instanceOop value = (instanceOop) ValueKlass::cast(element_klass())-&gt;default_value();
178     for (int i = 0; i &lt; length; i++) {
179       array_h-&gt;obj_at_put(i, value);
180     }
181   }
182   return array;
183 }
184 
</pre>
</td>
<td>
<hr />
<pre>
 73     Klass* element_super = element_klass-&gt;super();
 74     if (element_super != NULL) {
 75       // The element type has a direct super.  E.g., String[] has direct super of Object[].
 76       super_klass = element_super-&gt;array_klass_or_null(ArrayStorageProperties::empty);
 77       bool supers_exist = super_klass != NULL;
 78       // Also, see if the element has secondary supertypes.
 79       // We need an array type for each.
 80       const Array&lt;Klass*&gt;* element_supers = element_klass-&gt;secondary_supers();
 81       for( int i = element_supers-&gt;length()-1; i &gt;= 0; i-- ) {
 82         Klass* elem_super = element_supers-&gt;at(i);
 83         if (elem_super-&gt;array_klass_or_null(ArrayStorageProperties::empty) == NULL) {
 84           supers_exist = false;
 85           break;
 86         }
 87       }
 88       if (!supers_exist) {
 89         // Oops.  Not allocated yet.  Back out, allocate it, and retry.
 90         Klass* ek = NULL;
 91         {
 92           MutexUnlocker mu(MultiArray_lock);
<span class="line-modified"> 93           super_klass = element_super-&gt;array_klass(CHECK_NULL);</span>
 94           for( int i = element_supers-&gt;length()-1; i &gt;= 0; i-- ) {
 95             Klass* elem_super = element_supers-&gt;at(i);
<span class="line-modified"> 96             elem_super-&gt;array_klass(CHECK_NULL);</span>
 97           }
 98           // Now retry from the beginning
<span class="line-modified"> 99           ek = element_klass-&gt;array_klass(storage_props, n, CHECK_NULL);</span>
100         }  // re-lock
101         return ek;
102       }
103     } else {
104       // The element type is already Object.  Object[] has direct super of Object.
105       super_klass = SystemDictionary::Object_klass();
106     }
107   }
108 
109   // Create type name for klass.
110   Symbol* name = ArrayKlass::create_element_klass_array_name(storage_props.is_null_free(), element_klass, CHECK_NULL);
111 
112   // Initialize instance variables
113   ClassLoaderData* loader_data = element_klass-&gt;class_loader_data();
<span class="line-modified">114   ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, CHECK_NULL);</span>
115 
116   ModuleEntry* module = oak-&gt;module();
117   assert(module != NULL, &quot;No module entry for array&quot;);
118 
119   // Call complete_create_array_klass after all instance variables has been initialized.
<span class="line-modified">120   ArrayKlass::complete_create_array_klass(oak, super_klass, module, CHECK_NULL);</span>
121 
122   // Add all classes to our internal class loader list here,
123   // including classes in the bootstrap (NULL) class loader.
124   // Do this step after creating the mirror so that if the
125   // mirror creation fails, loaded_classes_do() doesn&#39;t find
126   // an array class without a mirror.
127   loader_data-&gt;add_class(oak);
128 
129   return oak;
130 }
131 
132 ObjArrayKlass::ObjArrayKlass(int n, Klass* element_klass, Symbol* name) : ArrayKlass(name, ID) {
133   this-&gt;set_dimension(n);
134   this-&gt;set_element_klass(element_klass);
135   // decrement refcount because object arrays are not explicitly freed.  The
136   // InstanceKlass array_name() keeps the name counted while the klass is
137   // loaded.
138   name-&gt;decrement_refcount();
139 
140   Klass* bk;
</pre>
<hr />
<pre>
144     bk = ValueArrayKlass::cast(element_klass)-&gt;element_klass();
145   } else {
146     bk = element_klass;
147   }
148   assert(bk != NULL &amp;&amp; (bk-&gt;is_instance_klass()
149       || bk-&gt;is_typeArray_klass()), &quot;invalid bottom klass&quot;);
150   this-&gt;set_bottom_klass(bk);
151   this-&gt;set_class_loader_data(bk-&gt;class_loader_data());
152 
153   this-&gt;set_layout_helper(array_layout_helper(T_OBJECT));
154   assert(this-&gt;is_array_klass(), &quot;sanity&quot;);
155   assert(this-&gt;is_objArray_klass(), &quot;sanity&quot;);
156 }
157 
158 int ObjArrayKlass::oop_size(oop obj) const {
159   assert(obj-&gt;is_objArray(), &quot;must be object array&quot;);
160   return objArrayOop(obj)-&gt;object_size();
161 }
162 
163 objArrayOop ObjArrayKlass::allocate(int length, TRAPS) {
<span class="line-modified">164   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);</span>
165   int size = objArrayOopDesc::object_size(length);
166   bool populate_null_free = storage_properties().is_null_free();
167   objArrayOop array =  (objArrayOop)Universe::heap()-&gt;array_allocate(this, size, length,
168                                                        /* do_zero */ true, THREAD);
169   if (populate_null_free) {
170     assert(dimension() == 1, &quot;Can only populate the final dimension&quot;);
171     assert(element_klass()-&gt;is_value(), &quot;Unexpected&quot;);
172     assert(!element_klass()-&gt;is_array_klass(), &quot;ArrayKlass unexpected here&quot;);
173     assert(!ValueKlass::cast(element_klass())-&gt;flatten_array(), &quot;Expected valueArrayOop allocation&quot;);
174     element_klass()-&gt;initialize(CHECK_NULL);
175     // Populate default values...
176     objArrayHandle array_h(THREAD, array);
177     instanceOop value = (instanceOop) ValueKlass::cast(element_klass())-&gt;default_value();
178     for (int i = 0; i &lt; length; i++) {
179       array_h-&gt;obj_at_put(i, value);
180     }
181   }
182   return array;
183 }
184 
</pre>
</td>
</tr>
</table>
<center><a href="methodData.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopsHierarchy.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
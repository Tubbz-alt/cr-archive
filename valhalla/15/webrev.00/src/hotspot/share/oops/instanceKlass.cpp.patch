diff a/src/hotspot/share/oops/instanceKlass.cpp b/src/hotspot/share/oops/instanceKlass.cpp
--- a/src/hotspot/share/oops/instanceKlass.cpp
+++ b/src/hotspot/share/oops/instanceKlass.cpp
@@ -805,11 +805,11 @@
   }
   return is_linked();
 }
 
 bool InstanceKlass::link_class_impl(TRAPS) {
-  if (DumpSharedSpaces && is_in_error_state()) {
+  if (DumpSharedSpaces && SystemDictionaryShared::has_class_failed_verification(this)) {
     // This is for CDS dumping phase only -- we use the in_error_state to indicate that
     // the class has failed verification. Throwing the NoClassDefFoundError here is just
     // a convenient way to stop repeat attempts to verify the same (bad) class.
     //
     // Note that the NoClassDefFoundError is not part of the JLS, and should not be thrown
@@ -1285,11 +1285,13 @@
 //   implementor Klass*    - one implementor
 //   self                  - more than one implementor
 //
 // The _implementor field only exists for interfaces.
 void InstanceKlass::add_implementor(Klass* k) {
-  assert_lock_strong(Compile_lock);
+  if (Universe::is_fully_initialized()) {
+    assert_lock_strong(Compile_lock);
+  }
   assert(is_interface(), "not interface");
   // Filter out my subinterfaces.
   // (Note: Interfaces are never on the subklass list.)
   if (InstanceKlass::cast(k)->is_interface()) return;
 
@@ -2506,16 +2508,14 @@
 }
 
 void InstanceKlass::remove_unshareable_info() {
   Klass::remove_unshareable_info();
 
-  if (is_in_error_state()) {
+  if (SystemDictionaryShared::has_class_failed_verification(this)) {
     // Classes are attempted to link during dumping and may fail,
     // but these classes are still in the dictionary and class list in CLD.
-    // Check in_error state first because in_error is > linked state, so
-    // is_linked() is true.
-    // If there's a linking error, there is nothing else to remove.
+    // If the class has failed verification, there is nothing else to remove.
     return;
   }
 
   // Reset to the 'allocated' state to prevent any premature accessing to
   // a shared class at runtime while the class is still being loaded and
@@ -2610,43 +2610,11 @@
   if (UseBiasedLocking && BiasedLocking::enabled() && !is_value()) {
     set_prototype_header(markWord::biased_locking_prototype());
   }
 }
 
-// returns true IFF is_in_error_state() has been changed as a result of this call.
-bool InstanceKlass::check_sharing_error_state() {
-  assert(DumpSharedSpaces, "should only be called during dumping");
-  bool old_state = is_in_error_state();
-
-  if (!is_in_error_state()) {
-    bool bad = false;
-    for (InstanceKlass* sup = java_super(); sup; sup = sup->java_super()) {
-      if (sup->is_in_error_state()) {
-        bad = true;
-        break;
-      }
-    }
-    if (!bad) {
-      Array<InstanceKlass*>* interfaces = transitive_interfaces();
-      for (int i = 0; i < interfaces->length(); i++) {
-        InstanceKlass* iface = interfaces->at(i);
-        if (iface->is_in_error_state()) {
-          bad = true;
-          break;
-        }
-      }
-    }
-
-    if (bad) {
-      set_in_error_state();
-    }
-  }
-
-  return (old_state != is_in_error_state());
-}
-
-void InstanceKlass::set_class_loader_type(s2 loader_type) {
+void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {
   switch (loader_type) {
   case ClassLoader::BOOT_LOADER:
     _misc_flags |= _misc_is_shared_boot_class;
     break;
   case ClassLoader::PLATFORM_LOADER:
@@ -2824,28 +2792,10 @@
   dest[dest_index++] = JVM_SIGNATURE_ENDCLASS;
   dest[dest_index] = '\0';
   return dest;
 }
 
-// Used to obtain the package name from a fully qualified class name.
-Symbol* InstanceKlass::package_from_name(const Symbol* name, TRAPS) {
-  if (name == NULL) {
-    return NULL;
-  } else {
-    if (name->utf8_length() <= 0) {
-      return NULL;
-    }
-    ResourceMark rm(THREAD);
-    const char* package_name = ClassLoader::package_from_name((const char*) name->as_C_string());
-    if (package_name == NULL) {
-      return NULL;
-    }
-    Symbol* pkg_name = SymbolTable::new_symbol(package_name);
-    return pkg_name;
-  }
-}
-
 ModuleEntry* InstanceKlass::module() const {
   // For an unsafe anonymous class return the host class' module
   if (is_unsafe_anonymous()) {
     assert(unsafe_anonymous_host() != NULL, "unsafe anonymous class must have a host class");
     return unsafe_anonymous_host()->module();
@@ -2863,11 +2813,11 @@
 void InstanceKlass::set_package(ClassLoaderData* loader_data, TRAPS) {
 
   // ensure java/ packages only loaded by boot or platform builtin loaders
   check_prohibited_package(name(), loader_data, CHECK);
 
-  TempNewSymbol pkg_name = package_from_name(name(), CHECK);
+  TempNewSymbol pkg_name = ClassLoader::package_from_class_name(name());
 
   if (pkg_name != NULL && loader_data != NULL) {
 
     // Find in class loader's package entry table.
     _package_entry = loader_data->packages()->lookup_only(pkg_name);
@@ -2959,29 +2909,28 @@
 
   {
     ResourceMark rm;
 
     bool bad_class_name = false;
-    const char* other_pkg =
-      ClassLoader::package_from_name((const char*) other_class_name->as_C_string(), &bad_class_name);
+    TempNewSymbol other_pkg = ClassLoader::package_from_class_name(other_class_name, &bad_class_name);
     if (bad_class_name) {
       return false;
     }
-    // Check that package_from_name() returns NULL, not "", if there is no package.
-    assert(other_pkg == NULL || strlen(other_pkg) > 0, "package name is empty string");
+    // Check that package_from_class_name() returns NULL, not "", if there is no package.
+    assert(other_pkg == NULL || other_pkg->utf8_length() > 0, "package name is empty string");
 
     const Symbol* const this_package_name =
       this->package() != NULL ? this->package()->name() : NULL;
 
     if (this_package_name == NULL || other_pkg == NULL) {
       // One of the two doesn't have a package.  Only return true if the other
       // one also doesn't have a package.
-      return (const char*)this_package_name == other_pkg;
+      return this_package_name == other_pkg;
     }
 
     // Check if package is identical
-    return this_package_name->equals(other_pkg);
+    return this_package_name->fast_compare(other_pkg) == 0;
   }
 }
 
 // Returns true iff super_method can be overridden by a method in targetclassname
 // See JLS 3rd edition 8.4.6.1
@@ -3011,11 +2960,11 @@
       !loader_data->is_platform_class_loader_data() &&
       class_name != NULL) {
     ResourceMark rm(THREAD);
     char* name = class_name->as_C_string();
     if (strncmp(name, JAVAPKG, JAVAPKG_LEN) == 0 && name[JAVAPKG_LEN] == '/') {
-      TempNewSymbol pkg_name = InstanceKlass::package_from_name(class_name, CHECK);
+      TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
       assert(pkg_name != NULL, "Error in parsing package name starting with 'java/'");
       name = pkg_name->as_C_string();
       const char* class_loader_name = loader_data->loader_name_and_id();
       StringUtils::replace_no_expand(name, "/", ".");
       const char* msg_text1 = "Class loader (instance of): ";

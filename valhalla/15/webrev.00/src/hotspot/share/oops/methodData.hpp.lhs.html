<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/methodData.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_METHODDATA_HPP
  26 #define SHARE_OOPS_METHODDATA_HPP
  27 
  28 #include &quot;interpreter/bytecodes.hpp&quot;
  29 #include &quot;oops/metadata.hpp&quot;
  30 #include &quot;oops/method.hpp&quot;
  31 #include &quot;oops/oop.hpp&quot;
  32 #include &quot;runtime/atomic.hpp&quot;
  33 #include &quot;utilities/align.hpp&quot;
  34 
  35 class BytecodeStream;
  36 
  37 // The MethodData object collects counts and other profile information
  38 // during zeroth-tier (interpretive) and first-tier execution.
  39 // The profile is used later by compilation heuristics.  Some heuristics
  40 // enable use of aggressive (or &quot;heroic&quot;) optimizations.  An aggressive
  41 // optimization often has a down-side, a corner case that it handles
  42 // poorly, but which is thought to be rare.  The profile provides
  43 // evidence of this rarity for a given method or even BCI.  It allows
  44 // the compiler to back out of the optimization at places where it
  45 // has historically been a poor choice.  Other heuristics try to use
  46 // specific information gathered about types observed at a given site.
  47 //
  48 // All data in the profile is approximate.  It is expected to be accurate
  49 // on the whole, but the system expects occasional inaccuraces, due to
  50 // counter overflow, multiprocessor races during data collection, space
  51 // limitations, missing MDO blocks, etc.  Bad or missing data will degrade
  52 // optimization quality but will not affect correctness.  Also, each MDO
  53 // is marked with its birth-date (&quot;creation_mileage&quot;) which can be used
  54 // to assess the quality (&quot;maturity&quot;) of its data.
  55 //
  56 // Short (&lt;32-bit) counters are designed to overflow to a known &quot;saturated&quot;
  57 // state.  Also, certain recorded per-BCI events are given one-bit counters
  58 // which overflow to a saturated state which applied to all counters at
  59 // that BCI.  In other words, there is a small lattice which approximates
  60 // the ideal of an infinite-precision counter for each event at each BCI,
  61 // and the lattice quickly &quot;bottoms out&quot; in a state where all counters
  62 // are taken to be indefinitely large.
  63 //
  64 // The reader will find many data races in profile gathering code, starting
  65 // with invocation counter incrementation.  None of these races harm correct
  66 // execution of the compiled code.
  67 
  68 // forward decl
  69 class ProfileData;
  70 
  71 // DataLayout
  72 //
  73 // Overlay for generic profiling data.
  74 class DataLayout {
  75   friend class VMStructs;
  76   friend class JVMCIVMStructs;
  77 
  78 private:
  79   // Every data layout begins with a header.  This header
  80   // contains a tag, which is used to indicate the size/layout
  81   // of the data, 8 bits of flags, which can be used in any way,
  82   // 32 bits of trap history (none/one reason/many reasons),
  83   // and a bci, which is used to tie this piece of data to a
  84   // specific bci in the bytecodes.
  85   union {
  86     u8 _bits;
  87     struct {
  88       u1 _tag;
  89       u1 _flags;
  90       u2 _bci;
  91       u4 _traps;
  92     } _struct;
  93   } _header;
  94 
  95   // The data layout has an arbitrary number of cells, each sized
  96   // to accomodate a pointer or an integer.
  97   intptr_t _cells[1];
  98 
  99   // Some types of data layouts need a length field.
 100   static bool needs_array_len(u1 tag);
 101 
 102 public:
 103   enum {
 104     counter_increment = 1
 105   };
 106 
 107   enum {
 108     cell_size = sizeof(intptr_t)
 109   };
 110 
 111   // Tag values
 112   enum {
 113     no_tag,
 114     bit_data_tag,
 115     counter_data_tag,
 116     jump_data_tag,
 117     receiver_type_data_tag,
 118     virtual_call_data_tag,
 119     ret_data_tag,
 120     branch_data_tag,
 121     multi_branch_data_tag,
 122     arg_info_data_tag,
 123     call_type_data_tag,
 124     virtual_call_type_data_tag,
 125     parameters_type_data_tag,
 126     speculative_trap_data_tag,
 127     array_load_store_data_tag
 128   };
 129 
 130   enum {
 131     // The trap state breaks down as [recompile:1 | reason:31].
 132     // This further breakdown is defined in deoptimization.cpp.
 133     // See Deoptimization::trap_state_reason for an assert that
 134     // trap_bits is big enough to hold reasons &lt; Reason_RECORDED_LIMIT.
 135     //
 136     // The trap_state is collected only if ProfileTraps is true.
 137     trap_bits = 1+31,  // 31: enough to distinguish [0..Reason_RECORDED_LIMIT].
 138     trap_mask = -1,
 139     first_flag = 0
 140   };
 141 
 142   // Size computation
 143   static int header_size_in_bytes() {
 144     return header_size_in_cells() * cell_size;
 145   }
 146   static int header_size_in_cells() {
 147     return LP64_ONLY(1) NOT_LP64(2);
 148   }
 149 
 150   static int compute_size_in_bytes(int cell_count) {
 151     return header_size_in_bytes() + cell_count * cell_size;
 152   }
 153 
 154   // Initialization
 155   void initialize(u1 tag, u2 bci, int cell_count);
 156 
 157   // Accessors
 158   u1 tag() {
 159     return _header._struct._tag;
 160   }
 161 
 162   // Return 32 bits of trap state.
 163   // The state tells if traps with zero, one, or many reasons have occurred.
 164   // It also tells whether zero or many recompilations have occurred.
 165   // The associated trap histogram in the MDO itself tells whether
 166   // traps are common or not.  If a BCI shows that a trap X has
 167   // occurred, and the MDO shows N occurrences of X, we make the
 168   // simplifying assumption that all N occurrences can be blamed
 169   // on that BCI.
 170   uint trap_state() const {
 171     return _header._struct._traps;
 172   }
 173 
 174   void set_trap_state(uint new_state) {
 175     assert(ProfileTraps, &quot;used only under +ProfileTraps&quot;);
 176     uint old_flags = _header._struct._traps;
 177     _header._struct._traps = new_state | old_flags;
 178   }
 179 
 180   u1 flags() const {
 181     return _header._struct._flags;
 182   }
 183 
 184   u2 bci() const {
 185     return _header._struct._bci;
 186   }
 187 
 188   void set_header(u8 value) {
 189     _header._bits = value;
 190   }
 191   u8 header() {
 192     return _header._bits;
 193   }
 194   void set_cell_at(int index, intptr_t value) {
 195     _cells[index] = value;
 196   }
 197   void release_set_cell_at(int index, intptr_t value);
 198   intptr_t cell_at(int index) const {
 199     return _cells[index];
 200   }
 201 
 202   void set_flag_at(u1 flag_number) {
 203     _header._struct._flags |= (0x1 &lt;&lt; flag_number);
 204   }
 205   bool flag_at(u1 flag_number) const {
 206     return (_header._struct._flags &amp; (0x1 &lt;&lt; flag_number)) != 0;
 207   }
 208 
 209   // Low-level support for code generation.
 210   static ByteSize header_offset() {
 211     return byte_offset_of(DataLayout, _header);
 212   }
 213   static ByteSize tag_offset() {
 214     return byte_offset_of(DataLayout, _header._struct._tag);
 215   }
 216   static ByteSize flags_offset() {
 217     return byte_offset_of(DataLayout, _header._struct._flags);
 218   }
 219   static ByteSize bci_offset() {
 220     return byte_offset_of(DataLayout, _header._struct._bci);
 221   }
 222   static ByteSize cell_offset(int index) {
 223     return byte_offset_of(DataLayout, _cells) + in_ByteSize(index * cell_size);
 224   }
 225   // Return a value which, when or-ed as a byte into _flags, sets the flag.
 226   static u1 flag_number_to_constant(u1 flag_number) {
 227     DataLayout temp; temp.set_header(0);
 228     temp.set_flag_at(flag_number);
 229     return temp._header._struct._flags;
 230   }
 231   // Return a value which, when or-ed as a word into _header, sets the flag.
 232   static u8 flag_mask_to_header_mask(uint byte_constant) {
 233     DataLayout temp; temp.set_header(0);
 234     temp._header._struct._flags = byte_constant;
 235     return temp._header._bits;
 236   }
 237 
 238   ProfileData* data_in();
 239 
 240   // GC support
 241   void clean_weak_klass_links(bool always_clean);
 242 
 243   // Redefinition support
 244   void clean_weak_method_links();
 245   DEBUG_ONLY(void verify_clean_weak_method_links();)
 246 };
 247 
 248 
 249 // ProfileData class hierarchy
 250 class ProfileData;
 251 class   BitData;
 252 class     CounterData;
 253 class       ReceiverTypeData;
 254 class         VirtualCallData;
 255 class           VirtualCallTypeData;
 256 class       RetData;
 257 class       CallTypeData;
 258 class   JumpData;
 259 class     BranchData;
 260 class   ArrayData;
 261 class     MultiBranchData;
 262 class     ArgInfoData;
 263 class     ParametersTypeData;
 264 class   SpeculativeTrapData;
 265 class   ArrayLoadStoreData;
 266 
 267 // ProfileData
 268 //
 269 // A ProfileData object is created to refer to a section of profiling
 270 // data in a structured way.
 271 class ProfileData : public ResourceObj {
 272   friend class TypeEntries;
 273   friend class SingleTypeEntry;
 274   friend class TypeStackSlotEntries;
 275 private:
 276   enum {
 277     tab_width_one = 16,
 278     tab_width_two = 36
 279   };
 280 
 281   // This is a pointer to a section of profiling data.
 282   DataLayout* _data;
 283 
 284   char* print_data_on_helper(const MethodData* md) const;
 285 
 286 protected:
 287   DataLayout* data() { return _data; }
 288   const DataLayout* data() const { return _data; }
 289 
 290   enum {
 291     cell_size = DataLayout::cell_size
 292   };
 293 
 294 public:
 295   // How many cells are in this?
 296   virtual int cell_count() const {
 297     ShouldNotReachHere();
 298     return -1;
 299   }
 300 
 301   // Return the size of this data.
 302   int size_in_bytes() {
 303     return DataLayout::compute_size_in_bytes(cell_count());
 304   }
 305 
 306 protected:
 307   // Low-level accessors for underlying data
 308   void set_intptr_at(int index, intptr_t value) {
 309     assert(0 &lt;= index &amp;&amp; index &lt; cell_count(), &quot;oob&quot;);
 310     data()-&gt;set_cell_at(index, value);
 311   }
 312   void release_set_intptr_at(int index, intptr_t value);
 313   intptr_t intptr_at(int index) const {
 314     assert(0 &lt;= index &amp;&amp; index &lt; cell_count(), &quot;oob&quot;);
 315     return data()-&gt;cell_at(index);
 316   }
 317   void set_uint_at(int index, uint value) {
 318     set_intptr_at(index, (intptr_t) value);
 319   }
 320   void release_set_uint_at(int index, uint value);
 321   uint uint_at(int index) const {
 322     return (uint)intptr_at(index);
 323   }
 324   void set_int_at(int index, int value) {
 325     set_intptr_at(index, (intptr_t) value);
 326   }
 327   void release_set_int_at(int index, int value);
 328   int int_at(int index) const {
 329     return (int)intptr_at(index);
 330   }
 331   int int_at_unchecked(int index) const {
 332     return (int)data()-&gt;cell_at(index);
 333   }
 334   void set_oop_at(int index, oop value) {
 335     set_intptr_at(index, cast_from_oop&lt;intptr_t&gt;(value));
 336   }
 337   oop oop_at(int index) const {
 338     return cast_to_oop(intptr_at(index));
 339   }
 340 
 341   void set_flag_at(int flag_number) {
 342     data()-&gt;set_flag_at(flag_number);
 343   }
 344   bool flag_at(int flag_number) const {
 345     return data()-&gt;flag_at(flag_number);
 346   }
 347 
 348   // two convenient imports for use by subclasses:
 349   static ByteSize cell_offset(int index) {
 350     return DataLayout::cell_offset(index);
 351   }
 352   static int flag_number_to_constant(int flag_number) {
 353     return DataLayout::flag_number_to_constant(flag_number);
 354   }
 355 
 356   ProfileData(DataLayout* data) {
 357     _data = data;
 358   }
 359 
 360 public:
 361   // Constructor for invalid ProfileData.
 362   ProfileData();
 363 
 364   u2 bci() const {
 365     return data()-&gt;bci();
 366   }
 367 
 368   address dp() {
 369     return (address)_data;
 370   }
 371 
 372   int trap_state() const {
 373     return data()-&gt;trap_state();
 374   }
 375   void set_trap_state(int new_state) {
 376     data()-&gt;set_trap_state(new_state);
 377   }
 378 
 379   // Type checking
 380   virtual bool is_BitData()         const { return false; }
 381   virtual bool is_CounterData()     const { return false; }
 382   virtual bool is_JumpData()        const { return false; }
 383   virtual bool is_ReceiverTypeData()const { return false; }
 384   virtual bool is_VirtualCallData() const { return false; }
 385   virtual bool is_RetData()         const { return false; }
 386   virtual bool is_BranchData()      const { return false; }
 387   virtual bool is_ArrayData()       const { return false; }
 388   virtual bool is_MultiBranchData() const { return false; }
 389   virtual bool is_ArgInfoData()     const { return false; }
 390   virtual bool is_CallTypeData()    const { return false; }
 391   virtual bool is_VirtualCallTypeData()const { return false; }
 392   virtual bool is_ParametersTypeData() const { return false; }
 393   virtual bool is_SpeculativeTrapData()const { return false; }
 394   virtual bool is_ArrayLoadStoreData() const { return false; }
 395 
 396 
 397   BitData* as_BitData() const {
 398     assert(is_BitData(), &quot;wrong type&quot;);
 399     return is_BitData()         ? (BitData*)        this : NULL;
 400   }
 401   CounterData* as_CounterData() const {
 402     assert(is_CounterData(), &quot;wrong type&quot;);
 403     return is_CounterData()     ? (CounterData*)    this : NULL;
 404   }
 405   JumpData* as_JumpData() const {
 406     assert(is_JumpData(), &quot;wrong type&quot;);
 407     return is_JumpData()        ? (JumpData*)       this : NULL;
 408   }
 409   ReceiverTypeData* as_ReceiverTypeData() const {
 410     assert(is_ReceiverTypeData(), &quot;wrong type&quot;);
 411     return is_ReceiverTypeData() ? (ReceiverTypeData*)this : NULL;
 412   }
 413   VirtualCallData* as_VirtualCallData() const {
 414     assert(is_VirtualCallData(), &quot;wrong type&quot;);
 415     return is_VirtualCallData() ? (VirtualCallData*)this : NULL;
 416   }
 417   RetData* as_RetData() const {
 418     assert(is_RetData(), &quot;wrong type&quot;);
 419     return is_RetData()         ? (RetData*)        this : NULL;
 420   }
 421   BranchData* as_BranchData() const {
 422     assert(is_BranchData(), &quot;wrong type&quot;);
 423     return is_BranchData()      ? (BranchData*)     this : NULL;
 424   }
 425   ArrayData* as_ArrayData() const {
 426     assert(is_ArrayData(), &quot;wrong type&quot;);
 427     return is_ArrayData()       ? (ArrayData*)      this : NULL;
 428   }
 429   MultiBranchData* as_MultiBranchData() const {
 430     assert(is_MultiBranchData(), &quot;wrong type&quot;);
 431     return is_MultiBranchData() ? (MultiBranchData*)this : NULL;
 432   }
 433   ArgInfoData* as_ArgInfoData() const {
 434     assert(is_ArgInfoData(), &quot;wrong type&quot;);
 435     return is_ArgInfoData() ? (ArgInfoData*)this : NULL;
 436   }
 437   CallTypeData* as_CallTypeData() const {
 438     assert(is_CallTypeData(), &quot;wrong type&quot;);
 439     return is_CallTypeData() ? (CallTypeData*)this : NULL;
 440   }
 441   VirtualCallTypeData* as_VirtualCallTypeData() const {
 442     assert(is_VirtualCallTypeData(), &quot;wrong type&quot;);
 443     return is_VirtualCallTypeData() ? (VirtualCallTypeData*)this : NULL;
 444   }
 445   ParametersTypeData* as_ParametersTypeData() const {
 446     assert(is_ParametersTypeData(), &quot;wrong type&quot;);
 447     return is_ParametersTypeData() ? (ParametersTypeData*)this : NULL;
 448   }
 449   SpeculativeTrapData* as_SpeculativeTrapData() const {
 450     assert(is_SpeculativeTrapData(), &quot;wrong type&quot;);
 451     return is_SpeculativeTrapData() ? (SpeculativeTrapData*)this : NULL;
 452   }
 453   ArrayLoadStoreData* as_ArrayLoadStoreData() const {
 454     assert(is_ArrayLoadStoreData(), &quot;wrong type&quot;);
 455     return is_ArrayLoadStoreData() ? (ArrayLoadStoreData*)this : NULL;
 456   }
 457 
 458 
 459   // Subclass specific initialization
 460   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo) {}
 461 
 462   // GC support
 463   virtual void clean_weak_klass_links(bool always_clean) {}
 464 
 465   // Redefinition support
 466   virtual void clean_weak_method_links() {}
 467   DEBUG_ONLY(virtual void verify_clean_weak_method_links() {})
 468 
 469   // CI translation: ProfileData can represent both MethodDataOop data
 470   // as well as CIMethodData data. This function is provided for translating
 471   // an oop in a ProfileData to the ci equivalent. Generally speaking,
 472   // most ProfileData don&#39;t require any translation, so we provide the null
 473   // translation here, and the required translators are in the ci subclasses.
 474   virtual void translate_from(const ProfileData* data) {}
 475 
 476   virtual void print_data_on(outputStream* st, const char* extra = NULL) const {
 477     ShouldNotReachHere();
 478   }
 479 
 480   void print_data_on(outputStream* st, const MethodData* md) const;
 481 
 482   void print_shared(outputStream* st, const char* name, const char* extra) const;
 483   void tab(outputStream* st, bool first = false) const;
 484 };
 485 
 486 // BitData
 487 //
 488 // A BitData holds a flag or two in its header.
 489 class BitData : public ProfileData {
 490   friend class VMStructs;
 491   friend class JVMCIVMStructs;
 492 protected:
 493   enum {
 494     // null_seen:
 495     //  saw a null operand (cast/aastore/instanceof)
 496       null_seen_flag              = DataLayout::first_flag + 0
 497 #if INCLUDE_JVMCI
 498     // bytecode threw any exception
 499     , exception_seen_flag         = null_seen_flag + 1
 500 #endif
 501   };
 502   enum { bit_cell_count = 0 };  // no additional data fields needed.
 503 public:
 504   BitData(DataLayout* layout) : ProfileData(layout) {
 505   }
 506 
 507   virtual bool is_BitData() const { return true; }
 508 
 509   static int static_cell_count() {
 510     return bit_cell_count;
 511   }
 512 
 513   virtual int cell_count() const {
 514     return static_cell_count();
 515   }
 516 
 517   // Accessor
 518 
 519   // The null_seen flag bit is specially known to the interpreter.
 520   // Consulting it allows the compiler to avoid setting up null_check traps.
 521   bool null_seen()     { return flag_at(null_seen_flag); }
 522   void set_null_seen()    { set_flag_at(null_seen_flag); }
 523 
 524 #if INCLUDE_JVMCI
 525   // true if an exception was thrown at the specific BCI
 526   bool exception_seen() { return flag_at(exception_seen_flag); }
 527   void set_exception_seen() { set_flag_at(exception_seen_flag); }
 528 #endif
 529 
 530   // Code generation support
 531   static int null_seen_byte_constant() {
 532     return flag_number_to_constant(null_seen_flag);
 533   }
 534 
 535   static ByteSize bit_data_size() {
 536     return cell_offset(bit_cell_count);
 537   }
 538 
 539   void print_data_on(outputStream* st, const char* extra = NULL) const;
 540 };
 541 
 542 // CounterData
 543 //
 544 // A CounterData corresponds to a simple counter.
 545 class CounterData : public BitData {
 546   friend class VMStructs;
 547   friend class JVMCIVMStructs;
 548 protected:
 549   enum {
 550     count_off,
 551     counter_cell_count
 552   };
 553 public:
 554   CounterData(DataLayout* layout) : BitData(layout) {}
 555 
 556   virtual bool is_CounterData() const { return true; }
 557 
 558   static int static_cell_count() {
 559     return counter_cell_count;
 560   }
 561 
 562   virtual int cell_count() const {
 563     return static_cell_count();
 564   }
 565 
 566   // Direct accessor
 567   int count() const {
 568     intptr_t raw_data = intptr_at(count_off);
 569     if (raw_data &gt; max_jint) {
 570       raw_data = max_jint;
 571     } else if (raw_data &lt; min_jint) {
 572       raw_data = min_jint;
 573     }
 574     return int(raw_data);
 575   }
 576 
 577   // Code generation support
 578   static ByteSize count_offset() {
 579     return cell_offset(count_off);
 580   }
 581   static ByteSize counter_data_size() {
 582     return cell_offset(counter_cell_count);
 583   }
 584 
 585   void set_count(int count) {
 586     set_int_at(count_off, count);
 587   }
 588 
 589   void print_data_on(outputStream* st, const char* extra = NULL) const;
 590 };
 591 
 592 // JumpData
 593 //
 594 // A JumpData is used to access profiling information for a direct
 595 // branch.  It is a counter, used for counting the number of branches,
 596 // plus a data displacement, used for realigning the data pointer to
 597 // the corresponding target bci.
 598 class JumpData : public ProfileData {
 599   friend class VMStructs;
 600   friend class JVMCIVMStructs;
 601 protected:
 602   enum {
 603     taken_off_set,
 604     displacement_off_set,
 605     jump_cell_count
 606   };
 607 
 608   void set_displacement(int displacement) {
 609     set_int_at(displacement_off_set, displacement);
 610   }
 611 
 612 public:
 613   JumpData(DataLayout* layout) : ProfileData(layout) {
 614     assert(layout-&gt;tag() == DataLayout::jump_data_tag ||
 615       layout-&gt;tag() == DataLayout::branch_data_tag, &quot;wrong type&quot;);
 616   }
 617 
 618   virtual bool is_JumpData() const { return true; }
 619 
 620   static int static_cell_count() {
 621     return jump_cell_count;
 622   }
 623 
 624   virtual int cell_count() const {
 625     return static_cell_count();
 626   }
 627 
 628   // Direct accessor
 629   uint taken() const {
 630     return uint_at(taken_off_set);
 631   }
 632 
 633   void set_taken(uint cnt) {
 634     set_uint_at(taken_off_set, cnt);
 635   }
 636 
 637   // Saturating counter
 638   uint inc_taken() {
 639     uint cnt = taken() + 1;
 640     // Did we wrap? Will compiler screw us??
 641     if (cnt == 0) cnt--;
 642     set_uint_at(taken_off_set, cnt);
 643     return cnt;
 644   }
 645 
 646   int displacement() const {
 647     return int_at(displacement_off_set);
 648   }
 649 
 650   // Code generation support
 651   static ByteSize taken_offset() {
 652     return cell_offset(taken_off_set);
 653   }
 654 
 655   static ByteSize displacement_offset() {
 656     return cell_offset(displacement_off_set);
 657   }
 658 
 659   // Specific initialization.
 660   void post_initialize(BytecodeStream* stream, MethodData* mdo);
 661 
 662   void print_data_on(outputStream* st, const char* extra = NULL) const;
 663 };
 664 
 665 // Entries in a ProfileData object to record types: it can either be
 666 // none (no profile), unknown (conflicting profile data) or a klass if
 667 // a single one is seen. Whether a null reference was seen is also
 668 // recorded. No counter is associated with the type and a single type
 669 // is tracked (unlike VirtualCallData).
 670 class TypeEntries {
 671 
 672 public:
 673 
 674   // A single cell is used to record information for a type:
 675   // - the cell is initialized to 0
 676   // - when a type is discovered it is stored in the cell
 677   // - bit zero of the cell is used to record whether a null reference
 678   // was encountered or not
 679   // - bit 1 is set to record a conflict in the type information
 680 
 681   enum {
 682     null_seen = 1,
 683     type_mask = ~null_seen,
 684     type_unknown = 2,
 685     status_bits = null_seen | type_unknown,
 686     type_klass_mask = ~status_bits
 687   };
 688 
 689   // what to initialize a cell to
 690   static intptr_t type_none() {
 691     return 0;
 692   }
 693 
 694   // null seen = bit 0 set?
 695   static bool was_null_seen(intptr_t v) {
 696     return (v &amp; null_seen) != 0;
 697   }
 698 
 699   // conflicting type information = bit 1 set?
 700   static bool is_type_unknown(intptr_t v) {
 701     return (v &amp; type_unknown) != 0;
 702   }
 703 
 704   // not type information yet = all bits cleared, ignoring bit 0?
 705   static bool is_type_none(intptr_t v) {
 706     return (v &amp; type_mask) == 0;
 707   }
 708 
 709   // recorded type: cell without bit 0 and 1
 710   static intptr_t klass_part(intptr_t v) {
 711     intptr_t r = v &amp; type_klass_mask;
 712     return r;
 713   }
 714 
 715   // type recorded
 716   static Klass* valid_klass(intptr_t k) {
 717     if (!is_type_none(k) &amp;&amp;
 718         !is_type_unknown(k)) {
 719       Klass* res = (Klass*)klass_part(k);
 720       assert(res != NULL, &quot;invalid&quot;);
 721       return res;
 722     } else {
 723       return NULL;
 724     }
 725   }
 726 
 727   static intptr_t with_status(intptr_t k, intptr_t in) {
 728     return k | (in &amp; status_bits);
 729   }
 730 
 731   static intptr_t with_status(Klass* k, intptr_t in) {
 732     return with_status((intptr_t)k, in);
 733   }
 734 
 735   static void print_klass(outputStream* st, intptr_t k);
 736 
 737 protected:
 738   // ProfileData object these entries are part of
 739   ProfileData* _pd;
 740   // offset within the ProfileData object where the entries start
 741   const int _base_off;
 742 
 743   TypeEntries(int base_off)
 744     : _pd(NULL), _base_off(base_off) {}
 745 
 746   void set_intptr_at(int index, intptr_t value) {
 747     _pd-&gt;set_intptr_at(index, value);
 748   }
 749 
 750   intptr_t intptr_at(int index) const {
 751     return _pd-&gt;intptr_at(index);
 752   }
 753 
 754 public:
 755   void set_profile_data(ProfileData* pd) {
 756     _pd = pd;
 757   }
 758 };
 759 
 760 // Type entries used for arguments passed at a call and parameters on
 761 // method entry. 2 cells per entry: one for the type encoded as in
 762 // TypeEntries and one initialized with the stack slot where the
 763 // profiled object is to be found so that the interpreter can locate
 764 // it quickly.
 765 class TypeStackSlotEntries : public TypeEntries {
 766 
 767 private:
 768   enum {
 769     stack_slot_entry,
 770     type_entry,
 771     per_arg_cell_count
 772   };
 773 
 774   // offset of cell for stack slot for entry i within ProfileData object
 775   int stack_slot_offset(int i) const {
 776     return _base_off + stack_slot_local_offset(i);
 777   }
 778 
 779   const int _number_of_entries;
 780 
 781   // offset of cell for type for entry i within ProfileData object
 782   int type_offset_in_cells(int i) const {
 783     return _base_off + type_local_offset(i);
 784   }
 785 
 786 public:
 787 
 788   TypeStackSlotEntries(int base_off, int nb_entries)
 789     : TypeEntries(base_off), _number_of_entries(nb_entries) {}
 790 
 791   static int compute_cell_count(Symbol* signature, bool include_receiver, int max);
 792 
 793   void post_initialize(Symbol* signature, bool has_receiver, bool include_receiver);
 794 
 795   int number_of_entries() const { return _number_of_entries; }
 796 
 797   // offset of cell for stack slot for entry i within this block of cells for a TypeStackSlotEntries
 798   static int stack_slot_local_offset(int i) {
 799     return i * per_arg_cell_count + stack_slot_entry;
 800   }
 801 
 802   // offset of cell for type for entry i within this block of cells for a TypeStackSlotEntries
 803   static int type_local_offset(int i) {
 804     return i * per_arg_cell_count + type_entry;
 805   }
 806 
 807   // stack slot for entry i
 808   uint stack_slot(int i) const {
 809     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 810     return _pd-&gt;uint_at(stack_slot_offset(i));
 811   }
 812 
 813   // set stack slot for entry i
 814   void set_stack_slot(int i, uint num) {
 815     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 816     _pd-&gt;set_uint_at(stack_slot_offset(i), num);
 817   }
 818 
 819   // type for entry i
 820   intptr_t type(int i) const {
 821     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 822     return _pd-&gt;intptr_at(type_offset_in_cells(i));
 823   }
 824 
 825   // set type for entry i
 826   void set_type(int i, intptr_t k) {
 827     assert(i &gt;= 0 &amp;&amp; i &lt; _number_of_entries, &quot;oob&quot;);
 828     _pd-&gt;set_intptr_at(type_offset_in_cells(i), k);
 829   }
 830 
 831   static ByteSize per_arg_size() {
 832     return in_ByteSize(per_arg_cell_count * DataLayout::cell_size);
 833   }
 834 
 835   static int per_arg_count() {
 836     return per_arg_cell_count;
 837   }
 838 
 839   ByteSize type_offset(int i) const {
 840     return DataLayout::cell_offset(type_offset_in_cells(i));
 841   }
 842 
 843   // GC support
 844   void clean_weak_klass_links(bool always_clean);
 845 
 846   void print_data_on(outputStream* st) const;
 847 };
 848 
 849 // Type entry used for return from a call. A single cell to record the
 850 // type.
 851 class SingleTypeEntry : public TypeEntries {
 852 
 853 private:
 854   enum {
 855     cell_count = 1
 856   };
 857 
 858 public:
 859   SingleTypeEntry(int base_off)
 860     : TypeEntries(base_off) {}
 861 
 862   void post_initialize() {
 863     set_type(type_none());
 864   }
 865 
 866   intptr_t type() const {
 867     return _pd-&gt;intptr_at(_base_off);
 868   }
 869 
 870   void set_type(intptr_t k) {
 871     _pd-&gt;set_intptr_at(_base_off, k);
 872   }
 873 
 874   static int static_cell_count() {
 875     return cell_count;
 876   }
 877 
 878   static ByteSize size() {
 879     return in_ByteSize(cell_count * DataLayout::cell_size);
 880   }
 881 
 882   ByteSize type_offset() {
 883     return DataLayout::cell_offset(_base_off);
 884   }
 885 
 886   // GC support
 887   void clean_weak_klass_links(bool always_clean);
 888 
 889   void print_data_on(outputStream* st) const;
 890 };
 891 
 892 // Entries to collect type information at a call: contains arguments
 893 // (TypeStackSlotEntries), a return type (SingleTypeEntry) and a
 894 // number of cells. Because the number of cells for the return type is
 895 // smaller than the number of cells for the type of an arguments, the
 896 // number of cells is used to tell how many arguments are profiled and
 897 // whether a return value is profiled. See has_arguments() and
 898 // has_return().
 899 class TypeEntriesAtCall {
 900 private:
 901   static int stack_slot_local_offset(int i) {
 902     return header_cell_count() + TypeStackSlotEntries::stack_slot_local_offset(i);
 903   }
 904 
 905   static int argument_type_local_offset(int i) {
 906     return header_cell_count() + TypeStackSlotEntries::type_local_offset(i);
 907   }
 908 
 909 public:
 910 
 911   static int header_cell_count() {
 912     return 1;
 913   }
 914 
 915   static int cell_count_local_offset() {
 916     return 0;
 917   }
 918 
 919   static int compute_cell_count(BytecodeStream* stream);
 920 
 921   static void initialize(DataLayout* dl, int base, int cell_count) {
 922     int off = base + cell_count_local_offset();
 923     dl-&gt;set_cell_at(off, cell_count - base - header_cell_count());
 924   }
 925 
 926   static bool arguments_profiling_enabled();
 927   static bool return_profiling_enabled();
 928 
 929   // Code generation support
 930   static ByteSize cell_count_offset() {
 931     return in_ByteSize(cell_count_local_offset() * DataLayout::cell_size);
 932   }
 933 
 934   static ByteSize args_data_offset() {
 935     return in_ByteSize(header_cell_count() * DataLayout::cell_size);
 936   }
 937 
 938   static ByteSize stack_slot_offset(int i) {
 939     return in_ByteSize(stack_slot_local_offset(i) * DataLayout::cell_size);
 940   }
 941 
 942   static ByteSize argument_type_offset(int i) {
 943     return in_ByteSize(argument_type_local_offset(i) * DataLayout::cell_size);
 944   }
 945 
 946   static ByteSize return_only_size() {
 947     return SingleTypeEntry::size() + in_ByteSize(header_cell_count() * DataLayout::cell_size);
 948   }
 949 
 950 };
 951 
 952 // CallTypeData
 953 //
 954 // A CallTypeData is used to access profiling information about a non
 955 // virtual call for which we collect type information about arguments
 956 // and return value.
 957 class CallTypeData : public CounterData {
 958 private:
 959   // entries for arguments if any
 960   TypeStackSlotEntries _args;
 961   // entry for return type if any
 962   SingleTypeEntry _ret;
 963 
 964   int cell_count_global_offset() const {
 965     return CounterData::static_cell_count() + TypeEntriesAtCall::cell_count_local_offset();
 966   }
 967 
 968   // number of cells not counting the header
 969   int cell_count_no_header() const {
 970     return uint_at(cell_count_global_offset());
 971   }
 972 
 973   void check_number_of_arguments(int total) {
 974     assert(number_of_arguments() == total, &quot;should be set in DataLayout::initialize&quot;);
 975   }
 976 
 977 public:
 978   CallTypeData(DataLayout* layout) :
 979     CounterData(layout),
 980     _args(CounterData::static_cell_count()+TypeEntriesAtCall::header_cell_count(), number_of_arguments()),
 981     _ret(cell_count() - SingleTypeEntry::static_cell_count())
 982   {
 983     assert(layout-&gt;tag() == DataLayout::call_type_data_tag, &quot;wrong type&quot;);
 984     // Some compilers (VC++) don&#39;t want this passed in member initialization list
 985     _args.set_profile_data(this);
 986     _ret.set_profile_data(this);
 987   }
 988 
 989   const TypeStackSlotEntries* args() const {
 990     assert(has_arguments(), &quot;no profiling of arguments&quot;);
 991     return &amp;_args;
 992   }
 993 
 994   const SingleTypeEntry* ret() const {
 995     assert(has_return(), &quot;no profiling of return value&quot;);
 996     return &amp;_ret;
 997   }
 998 
 999   virtual bool is_CallTypeData() const { return true; }
1000 
1001   static int static_cell_count() {
1002     return -1;
1003   }
1004 
1005   static int compute_cell_count(BytecodeStream* stream) {
1006     return CounterData::static_cell_count() + TypeEntriesAtCall::compute_cell_count(stream);
1007   }
1008 
1009   static void initialize(DataLayout* dl, int cell_count) {
1010     TypeEntriesAtCall::initialize(dl, CounterData::static_cell_count(), cell_count);
1011   }
1012 
1013   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo);
1014 
1015   virtual int cell_count() const {
1016     return CounterData::static_cell_count() +
1017       TypeEntriesAtCall::header_cell_count() +
1018       int_at_unchecked(cell_count_global_offset());
1019   }
1020 
1021   int number_of_arguments() const {
1022     return cell_count_no_header() / TypeStackSlotEntries::per_arg_count();
1023   }
1024 
1025   void set_argument_type(int i, Klass* k) {
1026     assert(has_arguments(), &quot;no arguments!&quot;);
1027     intptr_t current = _args.type(i);
1028     _args.set_type(i, TypeEntries::with_status(k, current));
1029   }
1030 
1031   void set_return_type(Klass* k) {
1032     assert(has_return(), &quot;no return!&quot;);
1033     intptr_t current = _ret.type();
1034     _ret.set_type(TypeEntries::with_status(k, current));
1035   }
1036 
1037   // An entry for a return value takes less space than an entry for an
1038   // argument so if the number of cells exceeds the number of cells
1039   // needed for an argument, this object contains type information for
1040   // at least one argument.
1041   bool has_arguments() const {
1042     bool res = cell_count_no_header() &gt;= TypeStackSlotEntries::per_arg_count();
1043     assert (!res || TypeEntriesAtCall::arguments_profiling_enabled(), &quot;no profiling of arguments&quot;);
1044     return res;
1045   }
1046 
1047   // An entry for a return value takes less space than an entry for an
1048   // argument, so if the remainder of the number of cells divided by
1049   // the number of cells for an argument is not null, a return value
1050   // is profiled in this object.
1051   bool has_return() const {
1052     bool res = (cell_count_no_header() % TypeStackSlotEntries::per_arg_count()) != 0;
1053     assert (!res || TypeEntriesAtCall::return_profiling_enabled(), &quot;no profiling of return values&quot;);
1054     return res;
1055   }
1056 
1057   // Code generation support
1058   static ByteSize args_data_offset() {
1059     return cell_offset(CounterData::static_cell_count()) + TypeEntriesAtCall::args_data_offset();
1060   }
1061 
1062   ByteSize argument_type_offset(int i) {
1063     return _args.type_offset(i);
1064   }
1065 
1066   ByteSize return_type_offset() {
1067     return _ret.type_offset();
1068   }
1069 
1070   // GC support
1071   virtual void clean_weak_klass_links(bool always_clean) {
1072     if (has_arguments()) {
1073       _args.clean_weak_klass_links(always_clean);
1074     }
1075     if (has_return()) {
1076       _ret.clean_weak_klass_links(always_clean);
1077     }
1078   }
1079 
1080   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1081 };
1082 
1083 // ReceiverTypeData
1084 //
1085 // A ReceiverTypeData is used to access profiling information about a
1086 // dynamic type check.  It consists of a counter which counts the total times
1087 // that the check is reached, and a series of (Klass*, count) pairs
1088 // which are used to store a type profile for the receiver of the check.
1089 class ReceiverTypeData : public CounterData {
1090   friend class VMStructs;
1091   friend class JVMCIVMStructs;
1092 protected:
1093   enum {
1094 #if INCLUDE_JVMCI
1095     // Description of the different counters
1096     // ReceiverTypeData for instanceof/checkcast/aastore:
1097     //   count is decremented for failed type checks
1098     //   JVMCI only: nonprofiled_count is incremented on type overflow
1099     // VirtualCallData for invokevirtual/invokeinterface:
1100     //   count is incremented on type overflow
1101     //   JVMCI only: nonprofiled_count is incremented on method overflow
1102 
1103     // JVMCI is interested in knowing the percentage of type checks involving a type not explicitly in the profile
1104     nonprofiled_count_off_set = counter_cell_count,
1105     receiver0_offset,
1106 #else
1107     receiver0_offset = counter_cell_count,
1108 #endif
1109     count0_offset,
1110     receiver_type_row_cell_count = (count0_offset + 1) - receiver0_offset
1111   };
1112 
1113 public:
1114   ReceiverTypeData(DataLayout* layout) : CounterData(layout) {
1115     assert(layout-&gt;tag() == DataLayout::receiver_type_data_tag ||
1116            layout-&gt;tag() == DataLayout::virtual_call_data_tag ||
1117            layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, &quot;wrong type&quot;);
1118   }
1119 
1120   virtual bool is_ReceiverTypeData() const { return true; }
1121 
1122   static int static_cell_count() {
1123     return counter_cell_count + (uint) TypeProfileWidth * receiver_type_row_cell_count JVMCI_ONLY(+ 1);
1124   }
1125 
1126   virtual int cell_count() const {
1127     return static_cell_count();
1128   }
1129 
1130   // Direct accessors
1131   static uint row_limit() {
1132     return TypeProfileWidth;
1133   }
1134   static int receiver_cell_index(uint row) {
1135     return receiver0_offset + row * receiver_type_row_cell_count;
1136   }
1137   static int receiver_count_cell_index(uint row) {
1138     return count0_offset + row * receiver_type_row_cell_count;
1139   }
1140 
1141   Klass* receiver(uint row) const {
1142     assert(row &lt; row_limit(), &quot;oob&quot;);
1143 
1144     Klass* recv = (Klass*)intptr_at(receiver_cell_index(row));
1145     assert(recv == NULL || recv-&gt;is_klass(), &quot;wrong type&quot;);
1146     return recv;
1147   }
1148 
1149   void set_receiver(uint row, Klass* k) {
1150     assert((uint)row &lt; row_limit(), &quot;oob&quot;);
1151     set_intptr_at(receiver_cell_index(row), (uintptr_t)k);
1152   }
1153 
1154   uint receiver_count(uint row) const {
1155     assert(row &lt; row_limit(), &quot;oob&quot;);
1156     return uint_at(receiver_count_cell_index(row));
1157   }
1158 
1159   void set_receiver_count(uint row, uint count) {
1160     assert(row &lt; row_limit(), &quot;oob&quot;);
1161     set_uint_at(receiver_count_cell_index(row), count);
1162   }
1163 
1164   void clear_row(uint row) {
1165     assert(row &lt; row_limit(), &quot;oob&quot;);
1166     // Clear total count - indicator of polymorphic call site.
1167     // The site may look like as monomorphic after that but
1168     // it allow to have more accurate profiling information because
1169     // there was execution phase change since klasses were unloaded.
1170     // If the site is still polymorphic then MDO will be updated
1171     // to reflect it. But it could be the case that the site becomes
1172     // only bimorphic. Then keeping total count not 0 will be wrong.
1173     // Even if we use monomorphic (when it is not) for compilation
1174     // we will only have trap, deoptimization and recompile again
1175     // with updated MDO after executing method in Interpreter.
1176     // An additional receiver will be recorded in the cleaned row
1177     // during next call execution.
1178     //
1179     // Note: our profiling logic works with empty rows in any slot.
1180     // We do sorting a profiling info (ciCallProfile) for compilation.
1181     //
1182     set_count(0);
1183     set_receiver(row, NULL);
1184     set_receiver_count(row, 0);
1185 #if INCLUDE_JVMCI
1186     if (!this-&gt;is_VirtualCallData()) {
1187       // if this is a ReceiverTypeData for JVMCI, the nonprofiled_count
1188       // must also be reset (see &quot;Description of the different counters&quot; above)
1189       set_nonprofiled_count(0);
1190     }
1191 #endif
1192   }
1193 
1194   // Code generation support
1195   static ByteSize receiver_offset(uint row) {
1196     return cell_offset(receiver_cell_index(row));
1197   }
1198   static ByteSize receiver_count_offset(uint row) {
1199     return cell_offset(receiver_count_cell_index(row));
1200   }
1201 #if INCLUDE_JVMCI
1202   static ByteSize nonprofiled_receiver_count_offset() {
1203     return cell_offset(nonprofiled_count_off_set);
1204   }
1205   uint nonprofiled_count() const {
1206     return uint_at(nonprofiled_count_off_set);
1207   }
1208   void set_nonprofiled_count(uint count) {
1209     set_uint_at(nonprofiled_count_off_set, count);
1210   }
1211 #endif // INCLUDE_JVMCI
1212   static ByteSize receiver_type_data_size() {
1213     return cell_offset(static_cell_count());
1214   }
1215 
1216   // GC support
1217   virtual void clean_weak_klass_links(bool always_clean);
1218 
1219   void print_receiver_data_on(outputStream* st) const;
1220   void print_data_on(outputStream* st, const char* extra = NULL) const;
1221 };
1222 
1223 // VirtualCallData
1224 //
1225 // A VirtualCallData is used to access profiling information about a
1226 // virtual call.  For now, it has nothing more than a ReceiverTypeData.
1227 class VirtualCallData : public ReceiverTypeData {
1228 public:
1229   VirtualCallData(DataLayout* layout) : ReceiverTypeData(layout) {
1230     assert(layout-&gt;tag() == DataLayout::virtual_call_data_tag ||
1231            layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, &quot;wrong type&quot;);
1232   }
1233 
1234   virtual bool is_VirtualCallData() const { return true; }
1235 
1236   static int static_cell_count() {
1237     // At this point we could add more profile state, e.g., for arguments.
1238     // But for now it&#39;s the same size as the base record type.
<a name="1" id="anc1"></a><span class="line-modified">1239     return ReceiverTypeData::static_cell_count() JVMCI_ONLY(+ (uint) MethodProfileWidth * receiver_type_row_cell_count);</span>
1240   }
1241 
1242   virtual int cell_count() const {
1243     return static_cell_count();
1244   }
1245 
1246   // Direct accessors
1247   static ByteSize virtual_call_data_size() {
1248     return cell_offset(static_cell_count());
1249   }
1250 
<a name="2" id="anc2"></a><span class="line-removed">1251 #if INCLUDE_JVMCI</span>
<span class="line-removed">1252   static ByteSize method_offset(uint row) {</span>
<span class="line-removed">1253     return cell_offset(method_cell_index(row));</span>
<span class="line-removed">1254   }</span>
<span class="line-removed">1255   static ByteSize method_count_offset(uint row) {</span>
<span class="line-removed">1256     return cell_offset(method_count_cell_index(row));</span>
<span class="line-removed">1257   }</span>
<span class="line-removed">1258   static int method_cell_index(uint row) {</span>
<span class="line-removed">1259     return receiver0_offset + (row + TypeProfileWidth) * receiver_type_row_cell_count;</span>
<span class="line-removed">1260   }</span>
<span class="line-removed">1261   static int method_count_cell_index(uint row) {</span>
<span class="line-removed">1262     return count0_offset + (row + TypeProfileWidth) * receiver_type_row_cell_count;</span>
<span class="line-removed">1263   }</span>
<span class="line-removed">1264   static uint method_row_limit() {</span>
<span class="line-removed">1265     return MethodProfileWidth;</span>
<span class="line-removed">1266   }</span>
<span class="line-removed">1267 </span>
<span class="line-removed">1268   Method* method(uint row) const {</span>
<span class="line-removed">1269     assert(row &lt; method_row_limit(), &quot;oob&quot;);</span>
<span class="line-removed">1270 </span>
<span class="line-removed">1271     Method* method = (Method*)intptr_at(method_cell_index(row));</span>
<span class="line-removed">1272     assert(method == NULL || method-&gt;is_method(), &quot;must be&quot;);</span>
<span class="line-removed">1273     return method;</span>
<span class="line-removed">1274   }</span>
<span class="line-removed">1275 </span>
<span class="line-removed">1276   uint method_count(uint row) const {</span>
<span class="line-removed">1277     assert(row &lt; method_row_limit(), &quot;oob&quot;);</span>
<span class="line-removed">1278     return uint_at(method_count_cell_index(row));</span>
<span class="line-removed">1279   }</span>
<span class="line-removed">1280 </span>
<span class="line-removed">1281   void set_method(uint row, Method* m) {</span>
<span class="line-removed">1282     assert((uint)row &lt; method_row_limit(), &quot;oob&quot;);</span>
<span class="line-removed">1283     set_intptr_at(method_cell_index(row), (uintptr_t)m);</span>
<span class="line-removed">1284   }</span>
<span class="line-removed">1285 </span>
<span class="line-removed">1286   void set_method_count(uint row, uint count) {</span>
<span class="line-removed">1287     assert(row &lt; method_row_limit(), &quot;oob&quot;);</span>
<span class="line-removed">1288     set_uint_at(method_count_cell_index(row), count);</span>
<span class="line-removed">1289   }</span>
<span class="line-removed">1290 </span>
<span class="line-removed">1291   void clear_method_row(uint row) {</span>
<span class="line-removed">1292     assert(row &lt; method_row_limit(), &quot;oob&quot;);</span>
<span class="line-removed">1293     // Clear total count - indicator of polymorphic call site (see comment for clear_row() in ReceiverTypeData).</span>
<span class="line-removed">1294     set_nonprofiled_count(0);</span>
<span class="line-removed">1295     set_method(row, NULL);</span>
<span class="line-removed">1296     set_method_count(row, 0);</span>
<span class="line-removed">1297   }</span>
<span class="line-removed">1298 </span>
<span class="line-removed">1299   // GC support</span>
<span class="line-removed">1300   virtual void clean_weak_klass_links(bool always_clean);</span>
<span class="line-removed">1301 </span>
<span class="line-removed">1302   // Redefinition support</span>
<span class="line-removed">1303   virtual void clean_weak_method_links();</span>
<span class="line-removed">1304 #endif // INCLUDE_JVMCI</span>
<span class="line-removed">1305 </span>
1306   void print_method_data_on(outputStream* st) const NOT_JVMCI_RETURN;
1307   void print_data_on(outputStream* st, const char* extra = NULL) const;
1308 };
1309 
1310 // VirtualCallTypeData
1311 //
1312 // A VirtualCallTypeData is used to access profiling information about
1313 // a virtual call for which we collect type information about
1314 // arguments and return value.
1315 class VirtualCallTypeData : public VirtualCallData {
1316 private:
1317   // entries for arguments if any
1318   TypeStackSlotEntries _args;
1319   // entry for return type if any
1320   SingleTypeEntry _ret;
1321 
1322   int cell_count_global_offset() const {
1323     return VirtualCallData::static_cell_count() + TypeEntriesAtCall::cell_count_local_offset();
1324   }
1325 
1326   // number of cells not counting the header
1327   int cell_count_no_header() const {
1328     return uint_at(cell_count_global_offset());
1329   }
1330 
1331   void check_number_of_arguments(int total) {
1332     assert(number_of_arguments() == total, &quot;should be set in DataLayout::initialize&quot;);
1333   }
1334 
1335 public:
1336   VirtualCallTypeData(DataLayout* layout) :
1337     VirtualCallData(layout),
1338     _args(VirtualCallData::static_cell_count()+TypeEntriesAtCall::header_cell_count(), number_of_arguments()),
1339     _ret(cell_count() - SingleTypeEntry::static_cell_count())
1340   {
1341     assert(layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, &quot;wrong type&quot;);
1342     // Some compilers (VC++) don&#39;t want this passed in member initialization list
1343     _args.set_profile_data(this);
1344     _ret.set_profile_data(this);
1345   }
1346 
1347   const TypeStackSlotEntries* args() const {
1348     assert(has_arguments(), &quot;no profiling of arguments&quot;);
1349     return &amp;_args;
1350   }
1351 
1352   const SingleTypeEntry* ret() const {
1353     assert(has_return(), &quot;no profiling of return value&quot;);
1354     return &amp;_ret;
1355   }
1356 
1357   virtual bool is_VirtualCallTypeData() const { return true; }
1358 
1359   static int static_cell_count() {
1360     return -1;
1361   }
1362 
1363   static int compute_cell_count(BytecodeStream* stream) {
1364     return VirtualCallData::static_cell_count() + TypeEntriesAtCall::compute_cell_count(stream);
1365   }
1366 
1367   static void initialize(DataLayout* dl, int cell_count) {
1368     TypeEntriesAtCall::initialize(dl, VirtualCallData::static_cell_count(), cell_count);
1369   }
1370 
1371   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo);
1372 
1373   virtual int cell_count() const {
1374     return VirtualCallData::static_cell_count() +
1375       TypeEntriesAtCall::header_cell_count() +
1376       int_at_unchecked(cell_count_global_offset());
1377   }
1378 
1379   int number_of_arguments() const {
1380     return cell_count_no_header() / TypeStackSlotEntries::per_arg_count();
1381   }
1382 
1383   void set_argument_type(int i, Klass* k) {
1384     assert(has_arguments(), &quot;no arguments!&quot;);
1385     intptr_t current = _args.type(i);
1386     _args.set_type(i, TypeEntries::with_status(k, current));
1387   }
1388 
1389   void set_return_type(Klass* k) {
1390     assert(has_return(), &quot;no return!&quot;);
1391     intptr_t current = _ret.type();
1392     _ret.set_type(TypeEntries::with_status(k, current));
1393   }
1394 
1395   // An entry for a return value takes less space than an entry for an
1396   // argument, so if the remainder of the number of cells divided by
1397   // the number of cells for an argument is not null, a return value
1398   // is profiled in this object.
1399   bool has_return() const {
1400     bool res = (cell_count_no_header() % TypeStackSlotEntries::per_arg_count()) != 0;
1401     assert (!res || TypeEntriesAtCall::return_profiling_enabled(), &quot;no profiling of return values&quot;);
1402     return res;
1403   }
1404 
1405   // An entry for a return value takes less space than an entry for an
1406   // argument so if the number of cells exceeds the number of cells
1407   // needed for an argument, this object contains type information for
1408   // at least one argument.
1409   bool has_arguments() const {
1410     bool res = cell_count_no_header() &gt;= TypeStackSlotEntries::per_arg_count();
1411     assert (!res || TypeEntriesAtCall::arguments_profiling_enabled(), &quot;no profiling of arguments&quot;);
1412     return res;
1413   }
1414 
1415   // Code generation support
1416   static ByteSize args_data_offset() {
1417     return cell_offset(VirtualCallData::static_cell_count()) + TypeEntriesAtCall::args_data_offset();
1418   }
1419 
1420   ByteSize argument_type_offset(int i) {
1421     return _args.type_offset(i);
1422   }
1423 
1424   ByteSize return_type_offset() {
1425     return _ret.type_offset();
1426   }
1427 
1428   // GC support
1429   virtual void clean_weak_klass_links(bool always_clean) {
1430     ReceiverTypeData::clean_weak_klass_links(always_clean);
1431     if (has_arguments()) {
1432       _args.clean_weak_klass_links(always_clean);
1433     }
1434     if (has_return()) {
1435       _ret.clean_weak_klass_links(always_clean);
1436     }
1437   }
1438 
1439   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1440 };
1441 
1442 // RetData
1443 //
1444 // A RetData is used to access profiling information for a ret bytecode.
1445 // It is composed of a count of the number of times that the ret has
1446 // been executed, followed by a series of triples of the form
1447 // (bci, count, di) which count the number of times that some bci was the
1448 // target of the ret and cache a corresponding data displacement.
1449 class RetData : public CounterData {
1450 protected:
1451   enum {
1452     bci0_offset = counter_cell_count,
1453     count0_offset,
1454     displacement0_offset,
1455     ret_row_cell_count = (displacement0_offset + 1) - bci0_offset
1456   };
1457 
1458   void set_bci(uint row, int bci) {
1459     assert((uint)row &lt; row_limit(), &quot;oob&quot;);
1460     set_int_at(bci0_offset + row * ret_row_cell_count, bci);
1461   }
1462   void release_set_bci(uint row, int bci);
1463   void set_bci_count(uint row, uint count) {
1464     assert((uint)row &lt; row_limit(), &quot;oob&quot;);
1465     set_uint_at(count0_offset + row * ret_row_cell_count, count);
1466   }
1467   void set_bci_displacement(uint row, int disp) {
1468     set_int_at(displacement0_offset + row * ret_row_cell_count, disp);
1469   }
1470 
1471 public:
1472   RetData(DataLayout* layout) : CounterData(layout) {
1473     assert(layout-&gt;tag() == DataLayout::ret_data_tag, &quot;wrong type&quot;);
1474   }
1475 
1476   virtual bool is_RetData() const { return true; }
1477 
1478   enum {
1479     no_bci = -1 // value of bci when bci1/2 are not in use.
1480   };
1481 
1482   static int static_cell_count() {
1483     return counter_cell_count + (uint) BciProfileWidth * ret_row_cell_count;
1484   }
1485 
1486   virtual int cell_count() const {
1487     return static_cell_count();
1488   }
1489 
1490   static uint row_limit() {
1491     return BciProfileWidth;
1492   }
1493   static int bci_cell_index(uint row) {
1494     return bci0_offset + row * ret_row_cell_count;
1495   }
1496   static int bci_count_cell_index(uint row) {
1497     return count0_offset + row * ret_row_cell_count;
1498   }
1499   static int bci_displacement_cell_index(uint row) {
1500     return displacement0_offset + row * ret_row_cell_count;
1501   }
1502 
1503   // Direct accessors
1504   int bci(uint row) const {
1505     return int_at(bci_cell_index(row));
1506   }
1507   uint bci_count(uint row) const {
1508     return uint_at(bci_count_cell_index(row));
1509   }
1510   int bci_displacement(uint row) const {
1511     return int_at(bci_displacement_cell_index(row));
1512   }
1513 
1514   // Interpreter Runtime support
1515   address fixup_ret(int return_bci, MethodData* mdo);
1516 
1517   // Code generation support
1518   static ByteSize bci_offset(uint row) {
1519     return cell_offset(bci_cell_index(row));
1520   }
1521   static ByteSize bci_count_offset(uint row) {
1522     return cell_offset(bci_count_cell_index(row));
1523   }
1524   static ByteSize bci_displacement_offset(uint row) {
1525     return cell_offset(bci_displacement_cell_index(row));
1526   }
1527 
1528   // Specific initialization.
1529   void post_initialize(BytecodeStream* stream, MethodData* mdo);
1530 
1531   void print_data_on(outputStream* st, const char* extra = NULL) const;
1532 };
1533 
1534 // BranchData
1535 //
1536 // A BranchData is used to access profiling data for a two-way branch.
1537 // It consists of taken and not_taken counts as well as a data displacement
1538 // for the taken case.
1539 class BranchData : public JumpData {
1540   friend class VMStructs;
1541   friend class JVMCIVMStructs;
1542 protected:
1543   enum {
1544     not_taken_off_set = jump_cell_count,
1545     branch_cell_count
1546   };
1547 
1548   void set_displacement(int displacement) {
1549     set_int_at(displacement_off_set, displacement);
1550   }
1551 
1552 public:
1553   BranchData(DataLayout* layout) : JumpData(layout) {
1554     assert(layout-&gt;tag() == DataLayout::branch_data_tag, &quot;wrong type&quot;);
1555   }
1556 
1557   virtual bool is_BranchData() const { return true; }
1558 
1559   static int static_cell_count() {
1560     return branch_cell_count;
1561   }
1562 
1563   virtual int cell_count() const {
1564     return static_cell_count();
1565   }
1566 
1567   // Direct accessor
1568   uint not_taken() const {
1569     return uint_at(not_taken_off_set);
1570   }
1571 
1572   void set_not_taken(uint cnt) {
1573     set_uint_at(not_taken_off_set, cnt);
1574   }
1575 
1576   uint inc_not_taken() {
1577     uint cnt = not_taken() + 1;
1578     // Did we wrap? Will compiler screw us??
1579     if (cnt == 0) cnt--;
1580     set_uint_at(not_taken_off_set, cnt);
1581     return cnt;
1582   }
1583 
1584   // Code generation support
1585   static ByteSize not_taken_offset() {
1586     return cell_offset(not_taken_off_set);
1587   }
1588   static ByteSize branch_data_size() {
1589     return cell_offset(branch_cell_count);
1590   }
1591 
1592   // Specific initialization.
1593   void post_initialize(BytecodeStream* stream, MethodData* mdo);
1594 
1595   void print_data_on(outputStream* st, const char* extra = NULL) const;
1596 };
1597 
1598 // ArrayData
1599 //
1600 // A ArrayData is a base class for accessing profiling data which does
1601 // not have a statically known size.  It consists of an array length
1602 // and an array start.
1603 class ArrayData : public ProfileData {
1604   friend class VMStructs;
1605   friend class JVMCIVMStructs;
1606 protected:
1607   friend class DataLayout;
1608 
1609   enum {
1610     array_len_off_set,
1611     array_start_off_set
1612   };
1613 
1614   uint array_uint_at(int index) const {
1615     int aindex = index + array_start_off_set;
1616     return uint_at(aindex);
1617   }
1618   int array_int_at(int index) const {
1619     int aindex = index + array_start_off_set;
1620     return int_at(aindex);
1621   }
1622   oop array_oop_at(int index) const {
1623     int aindex = index + array_start_off_set;
1624     return oop_at(aindex);
1625   }
1626   void array_set_int_at(int index, int value) {
1627     int aindex = index + array_start_off_set;
1628     set_int_at(aindex, value);
1629   }
1630 
1631   // Code generation support for subclasses.
1632   static ByteSize array_element_offset(int index) {
1633     return cell_offset(array_start_off_set + index);
1634   }
1635 
1636 public:
1637   ArrayData(DataLayout* layout) : ProfileData(layout) {}
1638 
1639   virtual bool is_ArrayData() const { return true; }
1640 
1641   static int static_cell_count() {
1642     return -1;
1643   }
1644 
1645   int array_len() const {
1646     return int_at_unchecked(array_len_off_set);
1647   }
1648 
1649   virtual int cell_count() const {
1650     return array_len() + 1;
1651   }
1652 
1653   // Code generation support
1654   static ByteSize array_len_offset() {
1655     return cell_offset(array_len_off_set);
1656   }
1657   static ByteSize array_start_offset() {
1658     return cell_offset(array_start_off_set);
1659   }
1660 };
1661 
1662 // MultiBranchData
1663 //
1664 // A MultiBranchData is used to access profiling information for
1665 // a multi-way branch (*switch bytecodes).  It consists of a series
1666 // of (count, displacement) pairs, which count the number of times each
1667 // case was taken and specify the data displacment for each branch target.
1668 class MultiBranchData : public ArrayData {
1669   friend class VMStructs;
1670   friend class JVMCIVMStructs;
1671 protected:
1672   enum {
1673     default_count_off_set,
1674     default_disaplacement_off_set,
1675     case_array_start
1676   };
1677   enum {
1678     relative_count_off_set,
1679     relative_displacement_off_set,
1680     per_case_cell_count
1681   };
1682 
1683   void set_default_displacement(int displacement) {
1684     array_set_int_at(default_disaplacement_off_set, displacement);
1685   }
1686   void set_displacement_at(int index, int displacement) {
1687     array_set_int_at(case_array_start +
1688                      index * per_case_cell_count +
1689                      relative_displacement_off_set,
1690                      displacement);
1691   }
1692 
1693 public:
1694   MultiBranchData(DataLayout* layout) : ArrayData(layout) {
1695     assert(layout-&gt;tag() == DataLayout::multi_branch_data_tag, &quot;wrong type&quot;);
1696   }
1697 
1698   virtual bool is_MultiBranchData() const { return true; }
1699 
1700   static int compute_cell_count(BytecodeStream* stream);
1701 
1702   int number_of_cases() const {
1703     int alen = array_len() - 2; // get rid of default case here.
1704     assert(alen % per_case_cell_count == 0, &quot;must be even&quot;);
1705     return (alen / per_case_cell_count);
1706   }
1707 
1708   uint default_count() const {
1709     return array_uint_at(default_count_off_set);
1710   }
1711   int default_displacement() const {
1712     return array_int_at(default_disaplacement_off_set);
1713   }
1714 
1715   uint count_at(int index) const {
1716     return array_uint_at(case_array_start +
1717                          index * per_case_cell_count +
1718                          relative_count_off_set);
1719   }
1720   int displacement_at(int index) const {
1721     return array_int_at(case_array_start +
1722                         index * per_case_cell_count +
1723                         relative_displacement_off_set);
1724   }
1725 
1726   // Code generation support
1727   static ByteSize default_count_offset() {
1728     return array_element_offset(default_count_off_set);
1729   }
1730   static ByteSize default_displacement_offset() {
1731     return array_element_offset(default_disaplacement_off_set);
1732   }
1733   static ByteSize case_count_offset(int index) {
1734     return case_array_offset() +
1735            (per_case_size() * index) +
1736            relative_count_offset();
1737   }
1738   static ByteSize case_array_offset() {
1739     return array_element_offset(case_array_start);
1740   }
1741   static ByteSize per_case_size() {
1742     return in_ByteSize(per_case_cell_count) * cell_size;
1743   }
1744   static ByteSize relative_count_offset() {
1745     return in_ByteSize(relative_count_off_set) * cell_size;
1746   }
1747   static ByteSize relative_displacement_offset() {
1748     return in_ByteSize(relative_displacement_off_set) * cell_size;
1749   }
1750 
1751   // Specific initialization.
1752   void post_initialize(BytecodeStream* stream, MethodData* mdo);
1753 
1754   void print_data_on(outputStream* st, const char* extra = NULL) const;
1755 };
1756 
1757 class ArgInfoData : public ArrayData {
1758 
1759 public:
1760   ArgInfoData(DataLayout* layout) : ArrayData(layout) {
1761     assert(layout-&gt;tag() == DataLayout::arg_info_data_tag, &quot;wrong type&quot;);
1762   }
1763 
1764   virtual bool is_ArgInfoData() const { return true; }
1765 
1766 
1767   int number_of_args() const {
1768     return array_len();
1769   }
1770 
1771   uint arg_modified(int arg) const {
1772     return array_uint_at(arg);
1773   }
1774 
1775   void set_arg_modified(int arg, uint val) {
1776     array_set_int_at(arg, val);
1777   }
1778 
1779   void print_data_on(outputStream* st, const char* extra = NULL) const;
1780 };
1781 
1782 // ParametersTypeData
1783 //
1784 // A ParametersTypeData is used to access profiling information about
1785 // types of parameters to a method
1786 class ParametersTypeData : public ArrayData {
1787 
1788 private:
1789   TypeStackSlotEntries _parameters;
1790 
1791   static int stack_slot_local_offset(int i) {
1792     assert_profiling_enabled();
1793     return array_start_off_set + TypeStackSlotEntries::stack_slot_local_offset(i);
1794   }
1795 
1796   static int type_local_offset(int i) {
1797     assert_profiling_enabled();
1798     return array_start_off_set + TypeStackSlotEntries::type_local_offset(i);
1799   }
1800 
1801   static bool profiling_enabled();
1802   static void assert_profiling_enabled() {
1803     assert(profiling_enabled(), &quot;method parameters profiling should be on&quot;);
1804   }
1805 
1806 public:
1807   ParametersTypeData(DataLayout* layout) : ArrayData(layout), _parameters(1, number_of_parameters()) {
1808     assert(layout-&gt;tag() == DataLayout::parameters_type_data_tag, &quot;wrong type&quot;);
1809     // Some compilers (VC++) don&#39;t want this passed in member initialization list
1810     _parameters.set_profile_data(this);
1811   }
1812 
1813   static int compute_cell_count(Method* m);
1814 
1815   virtual bool is_ParametersTypeData() const { return true; }
1816 
1817   virtual void post_initialize(BytecodeStream* stream, MethodData* mdo);
1818 
1819   int number_of_parameters() const {
1820     return array_len() / TypeStackSlotEntries::per_arg_count();
1821   }
1822 
1823   const TypeStackSlotEntries* parameters() const { return &amp;_parameters; }
1824 
1825   uint stack_slot(int i) const {
1826     return _parameters.stack_slot(i);
1827   }
1828 
1829   void set_type(int i, Klass* k) {
1830     intptr_t current = _parameters.type(i);
1831     _parameters.set_type(i, TypeEntries::with_status((intptr_t)k, current));
1832   }
1833 
1834   virtual void clean_weak_klass_links(bool always_clean) {
1835     _parameters.clean_weak_klass_links(always_clean);
1836   }
1837 
1838   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1839 
1840   static ByteSize stack_slot_offset(int i) {
1841     return cell_offset(stack_slot_local_offset(i));
1842   }
1843 
1844   static ByteSize type_offset(int i) {
1845     return cell_offset(type_local_offset(i));
1846   }
1847 };
1848 
1849 // SpeculativeTrapData
1850 //
1851 // A SpeculativeTrapData is used to record traps due to type
1852 // speculation. It records the root of the compilation: that type
1853 // speculation is wrong in the context of one compilation (for
1854 // method1) doesn&#39;t mean it&#39;s wrong in the context of another one (for
1855 // method2). Type speculation could have more/different data in the
1856 // context of the compilation of method2 and it&#39;s worthwhile to try an
1857 // optimization that failed for compilation of method1 in the context
1858 // of compilation of method2.
1859 // Space for SpeculativeTrapData entries is allocated from the extra
1860 // data space in the MDO. If we run out of space, the trap data for
1861 // the ProfileData at that bci is updated.
1862 class SpeculativeTrapData : public ProfileData {
1863 protected:
1864   enum {
1865     speculative_trap_method,
1866 #ifndef _LP64
1867     // The size of the area for traps is a multiple of the header
1868     // size, 2 cells on 32 bits. Packed at the end of this area are
1869     // argument info entries (with tag
1870     // DataLayout::arg_info_data_tag). The logic in
1871     // MethodData::bci_to_extra_data() that guarantees traps don&#39;t
1872     // overflow over argument info entries assumes the size of a
1873     // SpeculativeTrapData is twice the header size. On 32 bits, a
1874     // SpeculativeTrapData must be 4 cells.
1875     padding,
1876 #endif
1877     speculative_trap_cell_count
1878   };
1879 public:
1880   SpeculativeTrapData(DataLayout* layout) : ProfileData(layout) {
1881     assert(layout-&gt;tag() == DataLayout::speculative_trap_data_tag, &quot;wrong type&quot;);
1882   }
1883 
1884   virtual bool is_SpeculativeTrapData() const { return true; }
1885 
1886   static int static_cell_count() {
1887     return speculative_trap_cell_count;
1888   }
1889 
1890   virtual int cell_count() const {
1891     return static_cell_count();
1892   }
1893 
1894   // Direct accessor
1895   Method* method() const {
1896     return (Method*)intptr_at(speculative_trap_method);
1897   }
1898 
1899   void set_method(Method* m) {
1900     assert(!m-&gt;is_old(), &quot;cannot add old methods&quot;);
1901     set_intptr_at(speculative_trap_method, (intptr_t)m);
1902   }
1903 
1904   static ByteSize method_offset() {
1905     return cell_offset(speculative_trap_method);
1906   }
1907 
1908   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1909 };
1910 
1911 class ArrayLoadStoreData : public ProfileData {
1912 private:
1913   enum {
1914     flat_array_flag = DataLayout::first_flag,
1915     null_free_array_flag = flat_array_flag + 1,
1916   };
1917 
1918   SingleTypeEntry _array;
1919   SingleTypeEntry _element;
1920 
1921 public:
1922   ArrayLoadStoreData(DataLayout* layout) :
1923     ProfileData(layout),
1924     _array(0),
1925     _element(SingleTypeEntry::static_cell_count()) {
1926     assert(layout-&gt;tag() == DataLayout::array_load_store_data_tag, &quot;wrong type&quot;);
1927     _array.set_profile_data(this);
1928     _element.set_profile_data(this);
1929   }
1930 
1931   const SingleTypeEntry* array() const {
1932     return &amp;_array;
1933   }
1934 
1935   const SingleTypeEntry* element() const {
1936     return &amp;_element;
1937   }
1938 
1939   virtual bool is_ArrayLoadStoreData() const { return true; }
1940 
1941   static int static_cell_count() {
1942     return SingleTypeEntry::static_cell_count() * 2;
1943   }
1944 
1945   virtual int cell_count() const {
1946     return static_cell_count();
1947   }
1948 
1949   void set_flat_array() { set_flag_at(flat_array_flag); }
1950   bool flat_array() const { return flag_at(flat_array_flag); }
1951 
1952   void set_null_free_array() { set_flag_at(null_free_array_flag); }
1953   bool null_free_array() const { return flag_at(null_free_array_flag); }
1954 
1955   // Code generation support
1956   static int flat_array_byte_constant() {
1957     return flag_number_to_constant(flat_array_flag);
1958   }
1959 
1960   static int null_free_array_byte_constant() {
1961     return flag_number_to_constant(null_free_array_flag);
1962   }
1963 
1964   static ByteSize array_offset() {
1965     return cell_offset(0);
1966   }
1967 
1968   static ByteSize element_offset() {
1969     return cell_offset(SingleTypeEntry::static_cell_count());
1970   }
1971 
1972   virtual void clean_weak_klass_links(bool always_clean) {
1973     _array.clean_weak_klass_links(always_clean);
1974     _element.clean_weak_klass_links(always_clean);
1975   }
1976 
1977   static ByteSize array_load_store_data_size() {
1978     return cell_offset(static_cell_count());
1979   }
1980 
1981   virtual void print_data_on(outputStream* st, const char* extra = NULL) const;
1982 };
1983 
1984 // MethodData*
1985 //
1986 // A MethodData* holds information which has been collected about
1987 // a method.  Its layout looks like this:
1988 //
1989 // -----------------------------
1990 // | header                    |
1991 // | klass                     |
1992 // -----------------------------
1993 // | method                    |
1994 // | size of the MethodData* |
1995 // -----------------------------
1996 // | Data entries...           |
1997 // |   (variable size)         |
1998 // |                           |
1999 // .                           .
2000 // .                           .
2001 // .                           .
2002 // |                           |
2003 // -----------------------------
2004 //
2005 // The data entry area is a heterogeneous array of DataLayouts. Each
2006 // DataLayout in the array corresponds to a specific bytecode in the
2007 // method.  The entries in the array are sorted by the corresponding
2008 // bytecode.  Access to the data is via resource-allocated ProfileData,
2009 // which point to the underlying blocks of DataLayout structures.
2010 //
2011 // During interpretation, if profiling in enabled, the interpreter
2012 // maintains a method data pointer (mdp), which points at the entry
2013 // in the array corresponding to the current bci.  In the course of
2014 // intepretation, when a bytecode is encountered that has profile data
2015 // associated with it, the entry pointed to by mdp is updated, then the
2016 // mdp is adjusted to point to the next appropriate DataLayout.  If mdp
2017 // is NULL to begin with, the interpreter assumes that the current method
2018 // is not (yet) being profiled.
2019 //
2020 // In MethodData* parlance, &quot;dp&quot; is a &quot;data pointer&quot;, the actual address
2021 // of a DataLayout element.  A &quot;di&quot; is a &quot;data index&quot;, the offset in bytes
2022 // from the base of the data entry array.  A &quot;displacement&quot; is the byte offset
2023 // in certain ProfileData objects that indicate the amount the mdp must be
2024 // adjusted in the event of a change in control flow.
2025 //
2026 
2027 class CleanExtraDataClosure : public StackObj {
2028 public:
2029   virtual bool is_live(Method* m) = 0;
2030 };
2031 
2032 
2033 #if INCLUDE_JVMCI
2034 // Encapsulates an encoded speculation reason. These are linked together in
2035 // a list that is atomically appended to during deoptimization. Entries are
2036 // never removed from the list.
2037 // @see jdk.vm.ci.hotspot.HotSpotSpeculationLog.HotSpotSpeculationEncoding
2038 class FailedSpeculation: public CHeapObj&lt;mtCompiler&gt; {
2039  private:
2040   // The length of HotSpotSpeculationEncoding.toByteArray(). The data itself
2041   // is an array embedded at the end of this object.
2042   int   _data_len;
2043 
2044   // Next entry in a linked list.
2045   FailedSpeculation* _next;
2046 
2047   FailedSpeculation(address data, int data_len);
2048 
2049   FailedSpeculation** next_adr() { return &amp;_next; }
2050 
2051   // Placement new operator for inlining the speculation data into
2052   // the FailedSpeculation object.
2053   void* operator new(size_t size, size_t fs_size) throw();
2054 
2055  public:
2056   char* data()         { return (char*)(((address) this) + sizeof(FailedSpeculation)); }
2057   int data_len() const { return _data_len; }
2058   FailedSpeculation* next() const { return _next; }
2059 
2060   // Atomically appends a speculation from nm to the list whose head is at (*failed_speculations_address).
2061   // Returns false if the FailedSpeculation object could not be allocated.
2062   static bool add_failed_speculation(nmethod* nm, FailedSpeculation** failed_speculations_address, address speculation, int speculation_len);
2063 
2064   // Frees all entries in the linked list whose head is at (*failed_speculations_address).
2065   static void free_failed_speculations(FailedSpeculation** failed_speculations_address);
2066 };
2067 #endif
2068 
2069 class MethodData : public Metadata {
2070   friend class VMStructs;
2071   friend class JVMCIVMStructs;
2072 private:
2073   friend class ProfileData;
2074   friend class TypeEntriesAtCall;
2075 
2076   // If you add a new field that points to any metaspace object, you
2077   // must add this field to MethodData::metaspace_pointers_do().
2078 
2079   // Back pointer to the Method*
2080   Method* _method;
2081 
2082   // Size of this oop in bytes
2083   int _size;
2084 
2085   // Cached hint for bci_to_dp and bci_to_data
2086   int _hint_di;
2087 
2088   Mutex _extra_data_lock;
2089 
2090   MethodData(const methodHandle&amp; method, int size, TRAPS);
2091 public:
2092   static MethodData* allocate(ClassLoaderData* loader_data, const methodHandle&amp; method, TRAPS);
2093   MethodData() : _extra_data_lock(Mutex::leaf, &quot;MDO extra data lock&quot;) {}; // For ciMethodData
2094 
2095   bool is_methodData() const volatile { return true; }
2096   void initialize();
2097 
2098   // Whole-method sticky bits and flags
2099   enum {
2100     _trap_hist_limit    = 25 JVMCI_ONLY(+5),   // decoupled from Deoptimization::Reason_LIMIT
2101     _trap_hist_mask     = max_jubyte,
2102     _extra_data_count   = 4     // extra DataLayout headers, for trap history
2103   }; // Public flag values
2104 private:
2105   uint _nof_decompiles;             // count of all nmethod removals
2106   uint _nof_overflow_recompiles;    // recompile count, excluding recomp. bits
2107   uint _nof_overflow_traps;         // trap count, excluding _trap_hist
2108   union {
2109     intptr_t _align;
2110     u1 _array[JVMCI_ONLY(2 *) _trap_hist_limit];
2111   } _trap_hist;
2112 
2113   // Support for interprocedural escape analysis, from Thomas Kotzmann.
2114   intx              _eflags;          // flags on escape information
2115   intx              _arg_local;       // bit set of non-escaping arguments
2116   intx              _arg_stack;       // bit set of stack-allocatable arguments
2117   intx              _arg_returned;    // bit set of returned arguments
2118 
2119   int _creation_mileage;              // method mileage at MDO creation
2120 
2121   // How many invocations has this MDO seen?
2122   // These counters are used to determine the exact age of MDO.
2123   // We need those because in tiered a method can be concurrently
2124   // executed at different levels.
2125   InvocationCounter _invocation_counter;
2126   // Same for backedges.
2127   InvocationCounter _backedge_counter;
2128   // Counter values at the time profiling started.
2129   int               _invocation_counter_start;
2130   int               _backedge_counter_start;
2131   uint              _tenure_traps;
2132   int               _invoke_mask;      // per-method Tier0InvokeNotifyFreqLog
2133   int               _backedge_mask;    // per-method Tier0BackedgeNotifyFreqLog
2134 
2135 #if INCLUDE_RTM_OPT
2136   // State of RTM code generation during compilation of the method
2137   int               _rtm_state;
2138 #endif
2139 
2140   // Number of loops and blocks is computed when compiling the first
2141   // time with C1. It is used to determine if method is trivial.
2142   short             _num_loops;
2143   short             _num_blocks;
2144   // Does this method contain anything worth profiling?
2145   enum WouldProfile {unknown, no_profile, profile};
2146   WouldProfile      _would_profile;
2147 
2148 #if INCLUDE_JVMCI
2149   // Support for HotSpotMethodData.setCompiledIRSize(int)
2150   int                _jvmci_ir_size;
2151   FailedSpeculation* _failed_speculations;
2152 #endif
2153 
2154   // Size of _data array in bytes.  (Excludes header and extra_data fields.)
2155   int _data_size;
2156 
2157   // data index for the area dedicated to parameters. -1 if no
2158   // parameter profiling.
2159   enum { no_parameters = -2, parameters_uninitialized = -1 };
2160   int _parameters_type_data_di;
2161 
2162   // Beginning of the data entries
2163   intptr_t _data[1];
2164 
2165   // Helper for size computation
2166   static int compute_data_size(BytecodeStream* stream);
2167   static int bytecode_cell_count(Bytecodes::Code code);
2168   static bool is_speculative_trap_bytecode(Bytecodes::Code code);
2169   enum { no_profile_data = -1, variable_cell_count = -2 };
2170 
2171   // Helper for initialization
2172   DataLayout* data_layout_at(int data_index) const {
2173     assert(data_index % sizeof(intptr_t) == 0, &quot;unaligned&quot;);
2174     return (DataLayout*) (((address)_data) + data_index);
2175   }
2176 
2177   // Initialize an individual data segment.  Returns the size of
2178   // the segment in bytes.
2179   int initialize_data(BytecodeStream* stream, int data_index);
2180 
2181   // Helper for data_at
2182   DataLayout* limit_data_position() const {
2183     return data_layout_at(_data_size);
2184   }
2185   bool out_of_bounds(int data_index) const {
2186     return data_index &gt;= data_size();
2187   }
2188 
2189   // Give each of the data entries a chance to perform specific
2190   // data initialization.
2191   void post_initialize(BytecodeStream* stream);
2192 
2193   // hint accessors
2194   int      hint_di() const  { return _hint_di; }
2195   void set_hint_di(int di)  {
2196     assert(!out_of_bounds(di), &quot;hint_di out of bounds&quot;);
2197     _hint_di = di;
2198   }
2199   ProfileData* data_before(int bci) {
2200     // avoid SEGV on this edge case
2201     if (data_size() == 0)
2202       return NULL;
2203     int hint = hint_di();
2204     if (data_layout_at(hint)-&gt;bci() &lt;= bci)
2205       return data_at(hint);
2206     return first_data();
2207   }
2208 
2209   // What is the index of the first data entry?
2210   int first_di() const { return 0; }
2211 
2212   ProfileData* bci_to_extra_data_helper(int bci, Method* m, DataLayout*&amp; dp, bool concurrent);
2213   // Find or create an extra ProfileData:
2214   ProfileData* bci_to_extra_data(int bci, Method* m, bool create_if_missing);
2215 
2216   // return the argument info cell
2217   ArgInfoData *arg_info();
2218 
2219   enum {
2220     no_type_profile = 0,
2221     type_profile_jsr292 = 1,
2222     type_profile_all = 2
2223   };
2224 
2225   static bool profile_jsr292(const methodHandle&amp; m, int bci);
2226   static bool profile_unsafe(const methodHandle&amp; m, int bci);
2227   static int profile_arguments_flag();
2228   static bool profile_all_arguments();
2229   static bool profile_arguments_for_invoke(const methodHandle&amp; m, int bci);
2230   static int profile_return_flag();
2231   static bool profile_all_return();
2232   static bool profile_return_for_invoke(const methodHandle&amp; m, int bci);
2233   static int profile_parameters_flag();
2234   static bool profile_parameters_jsr292_only();
2235   static bool profile_all_parameters();
2236 
2237   void clean_extra_data_helper(DataLayout* dp, int shift, bool reset = false);
2238   void verify_extra_data_clean(CleanExtraDataClosure* cl);
2239 
2240 public:
2241   void clean_extra_data(CleanExtraDataClosure* cl);
2242 
2243   static int header_size() {
2244     return sizeof(MethodData)/wordSize;
2245   }
2246 
2247   // Compute the size of a MethodData* before it is created.
2248   static int compute_allocation_size_in_bytes(const methodHandle&amp; method);
2249   static int compute_allocation_size_in_words(const methodHandle&amp; method);
2250   static int compute_extra_data_count(int data_size, int empty_bc_count, bool needs_speculative_traps);
2251 
2252   // Determine if a given bytecode can have profile information.
2253   static bool bytecode_has_profile(Bytecodes::Code code) {
2254     return bytecode_cell_count(code) != no_profile_data;
2255   }
2256 
2257   // reset into original state
2258   void init();
2259 
2260   // My size
2261   int size_in_bytes() const { return _size; }
2262   int size() const    { return align_metadata_size(align_up(_size, BytesPerWord)/BytesPerWord); }
2263 
2264   int      creation_mileage() const  { return _creation_mileage; }
2265   void set_creation_mileage(int x)   { _creation_mileage = x; }
2266 
2267   int invocation_count() {
2268     if (invocation_counter()-&gt;carry()) {
2269       return InvocationCounter::count_limit;
2270     }
2271     return invocation_counter()-&gt;count();
2272   }
2273   int backedge_count() {
2274     if (backedge_counter()-&gt;carry()) {
2275       return InvocationCounter::count_limit;
2276     }
2277     return backedge_counter()-&gt;count();
2278   }
2279 
2280   int invocation_count_start() {
2281     if (invocation_counter()-&gt;carry()) {
2282       return 0;
2283     }
2284     return _invocation_counter_start;
2285   }
2286 
2287   int backedge_count_start() {
2288     if (backedge_counter()-&gt;carry()) {
2289       return 0;
2290     }
2291     return _backedge_counter_start;
2292   }
2293 
2294   int invocation_count_delta() { return invocation_count() - invocation_count_start(); }
2295   int backedge_count_delta()   { return backedge_count()   - backedge_count_start();   }
2296 
2297   void reset_start_counters() {
2298     _invocation_counter_start = invocation_count();
2299     _backedge_counter_start = backedge_count();
2300   }
2301 
2302   InvocationCounter* invocation_counter()     { return &amp;_invocation_counter; }
2303   InvocationCounter* backedge_counter()       { return &amp;_backedge_counter;   }
2304 
2305 #if INCLUDE_JVMCI
2306   FailedSpeculation** get_failed_speculations_address() {
2307     return &amp;_failed_speculations;
2308   }
2309 #endif
2310 
2311 #if INCLUDE_RTM_OPT
2312   int rtm_state() const {
2313     return _rtm_state;
2314   }
2315   void set_rtm_state(RTMState rstate) {
2316     _rtm_state = (int)rstate;
2317   }
2318   void atomic_set_rtm_state(RTMState rstate) {
2319     Atomic::store(&amp;_rtm_state, (int)rstate);
2320   }
2321 
2322   static int rtm_state_offset_in_bytes() {
2323     return offset_of(MethodData, _rtm_state);
2324   }
2325 #endif
2326 
2327   void set_would_profile(bool p)              { _would_profile = p ? profile : no_profile; }
2328   bool would_profile() const                  { return _would_profile != no_profile; }
2329 
2330   int num_loops() const                       { return _num_loops;  }
2331   void set_num_loops(int n)                   { _num_loops = n;     }
2332   int num_blocks() const                      { return _num_blocks; }
2333   void set_num_blocks(int n)                  { _num_blocks = n;    }
2334 
2335   bool is_mature() const;  // consult mileage and ProfileMaturityPercentage
2336   static int mileage_of(Method* m);
2337 
2338   // Support for interprocedural escape analysis, from Thomas Kotzmann.
2339   enum EscapeFlag {
2340     estimated    = 1 &lt;&lt; 0,
2341     return_local = 1 &lt;&lt; 1,
2342     return_allocated = 1 &lt;&lt; 2,
2343     allocated_escapes = 1 &lt;&lt; 3,
2344     unknown_modified = 1 &lt;&lt; 4
2345   };
2346 
2347   intx eflags()                                  { return _eflags; }
2348   intx arg_local()                               { return _arg_local; }
2349   intx arg_stack()                               { return _arg_stack; }
2350   intx arg_returned()                            { return _arg_returned; }
2351   uint arg_modified(int a)                       { ArgInfoData *aid = arg_info();
2352                                                    assert(aid != NULL, &quot;arg_info must be not null&quot;);
2353                                                    assert(a &gt;= 0 &amp;&amp; a &lt; aid-&gt;number_of_args(), &quot;valid argument number&quot;);
2354                                                    return aid-&gt;arg_modified(a); }
2355 
2356   void set_eflags(intx v)                        { _eflags = v; }
2357   void set_arg_local(intx v)                     { _arg_local = v; }
2358   void set_arg_stack(intx v)                     { _arg_stack = v; }
2359   void set_arg_returned(intx v)                  { _arg_returned = v; }
2360   void set_arg_modified(int a, uint v)           { ArgInfoData *aid = arg_info();
2361                                                    assert(aid != NULL, &quot;arg_info must be not null&quot;);
2362                                                    assert(a &gt;= 0 &amp;&amp; a &lt; aid-&gt;number_of_args(), &quot;valid argument number&quot;);
2363                                                    aid-&gt;set_arg_modified(a, v); }
2364 
2365   void clear_escape_info()                       { _eflags = _arg_local = _arg_stack = _arg_returned = 0; }
2366 
2367   // Location and size of data area
2368   address data_base() const {
2369     return (address) _data;
2370   }
2371   int data_size() const {
2372     return _data_size;
2373   }
2374 
2375   int parameters_size_in_bytes() const {
2376     ParametersTypeData* param = parameters_type_data();
2377     return param == NULL ? 0 : param-&gt;size_in_bytes();
2378   }
2379 
2380   // Accessors
2381   Method* method() const { return _method; }
2382 
2383   // Get the data at an arbitrary (sort of) data index.
2384   ProfileData* data_at(int data_index) const;
2385 
2386   // Walk through the data in order.
2387   ProfileData* first_data() const { return data_at(first_di()); }
2388   ProfileData* next_data(ProfileData* current) const;
2389   bool is_valid(ProfileData* current) const { return current != NULL; }
2390 
2391   // Convert a dp (data pointer) to a di (data index).
2392   int dp_to_di(address dp) const {
2393     return dp - ((address)_data);
2394   }
2395 
2396   // bci to di/dp conversion.
2397   address bci_to_dp(int bci);
2398   int bci_to_di(int bci) {
2399     return dp_to_di(bci_to_dp(bci));
2400   }
2401 
2402   // Get the data at an arbitrary bci, or NULL if there is none.
2403   ProfileData* bci_to_data(int bci);
2404 
2405   // Same, but try to create an extra_data record if one is needed:
2406   ProfileData* allocate_bci_to_data(int bci, Method* m) {
2407     ProfileData* data = NULL;
2408     // If m not NULL, try to allocate a SpeculativeTrapData entry
2409     if (m == NULL) {
2410       data = bci_to_data(bci);
2411     }
2412     if (data != NULL) {
2413       return data;
2414     }
2415     data = bci_to_extra_data(bci, m, true);
2416     if (data != NULL) {
2417       return data;
2418     }
2419     // If SpeculativeTrapData allocation fails try to allocate a
2420     // regular entry
2421     data = bci_to_data(bci);
2422     if (data != NULL) {
2423       return data;
2424     }
2425     return bci_to_extra_data(bci, NULL, true);
2426   }
2427 
2428   // Add a handful of extra data records, for trap tracking.
2429   DataLayout* extra_data_base() const  { return limit_data_position(); }
2430   DataLayout* extra_data_limit() const { return (DataLayout*)((address)this + size_in_bytes()); }
2431   DataLayout* args_data_limit() const  { return (DataLayout*)((address)this + size_in_bytes() -
2432                                                               parameters_size_in_bytes()); }
2433   int extra_data_size() const          { return (address)extra_data_limit() - (address)extra_data_base(); }
2434   static DataLayout* next_extra(DataLayout* dp);
2435 
2436   // Return (uint)-1 for overflow.
2437   uint trap_count(int reason) const {
2438     assert((uint)reason &lt; JVMCI_ONLY(2*) _trap_hist_limit, &quot;oob&quot;);
2439     return (int)((_trap_hist._array[reason]+1) &amp; _trap_hist_mask) - 1;
2440   }
2441   // For loops:
2442   static uint trap_reason_limit() { return _trap_hist_limit; }
2443   static uint trap_count_limit()  { return _trap_hist_mask; }
2444   uint inc_trap_count(int reason) {
2445     // Count another trap, anywhere in this method.
2446     assert(reason &gt;= 0, &quot;must be single trap&quot;);
2447     assert((uint)reason &lt; JVMCI_ONLY(2*) _trap_hist_limit, &quot;oob&quot;);
2448     uint cnt1 = 1 + _trap_hist._array[reason];
2449     if ((cnt1 &amp; _trap_hist_mask) != 0) {  // if no counter overflow...
2450       _trap_hist._array[reason] = cnt1;
2451       return cnt1;
2452     } else {
2453       return _trap_hist_mask + (++_nof_overflow_traps);
2454     }
2455   }
2456 
2457   uint overflow_trap_count() const {
2458     return _nof_overflow_traps;
2459   }
2460   uint overflow_recompile_count() const {
2461     return _nof_overflow_recompiles;
2462   }
2463   void inc_overflow_recompile_count() {
2464     _nof_overflow_recompiles += 1;
2465   }
2466   uint decompile_count() const {
2467     return _nof_decompiles;
2468   }
2469   void inc_decompile_count() {
2470     _nof_decompiles += 1;
2471     if (decompile_count() &gt; (uint)PerMethodRecompilationCutoff) {
2472       method()-&gt;set_not_compilable(&quot;decompile_count &gt; PerMethodRecompilationCutoff&quot;, CompLevel_full_optimization);
2473     }
2474   }
2475   uint tenure_traps() const {
2476     return _tenure_traps;
2477   }
2478   void inc_tenure_traps() {
2479     _tenure_traps += 1;
2480   }
2481 
2482   // Return pointer to area dedicated to parameters in MDO
2483   ParametersTypeData* parameters_type_data() const {
2484     assert(_parameters_type_data_di != parameters_uninitialized, &quot;called too early&quot;);
2485     return _parameters_type_data_di != no_parameters ? data_layout_at(_parameters_type_data_di)-&gt;data_in()-&gt;as_ParametersTypeData() : NULL;
2486   }
2487 
2488   int parameters_type_data_di() const {
2489     assert(_parameters_type_data_di != parameters_uninitialized &amp;&amp; _parameters_type_data_di != no_parameters, &quot;no args type data&quot;);
2490     return _parameters_type_data_di;
2491   }
2492 
2493   // Support for code generation
2494   static ByteSize data_offset() {
2495     return byte_offset_of(MethodData, _data[0]);
2496   }
2497 
2498   static ByteSize trap_history_offset() {
2499     return byte_offset_of(MethodData, _trap_hist._array);
2500   }
2501 
2502   static ByteSize invocation_counter_offset() {
2503     return byte_offset_of(MethodData, _invocation_counter);
2504   }
2505 
2506   static ByteSize backedge_counter_offset() {
2507     return byte_offset_of(MethodData, _backedge_counter);
2508   }
2509 
2510   static ByteSize invoke_mask_offset() {
2511     return byte_offset_of(MethodData, _invoke_mask);
2512   }
2513 
2514   static ByteSize backedge_mask_offset() {
2515     return byte_offset_of(MethodData, _backedge_mask);
2516   }
2517 
2518   static ByteSize parameters_type_data_di_offset() {
2519     return byte_offset_of(MethodData, _parameters_type_data_di);
2520   }
2521 
2522   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
2523   virtual MetaspaceObj::Type type() const { return MethodDataType; }
2524 
2525   // Deallocation support - no metaspace pointer fields to deallocate
2526   void deallocate_contents(ClassLoaderData* loader_data) {}
2527 
2528   // GC support
2529   void set_size(int object_size_in_bytes) { _size = object_size_in_bytes; }
2530 
2531   // Printing
2532   void print_on      (outputStream* st) const;
2533   void print_value_on(outputStream* st) const;
2534 
2535   // printing support for method data
2536   void print_data_on(outputStream* st) const;
2537 
2538   const char* internal_name() const { return &quot;{method data}&quot;; }
2539 
2540   // verification
2541   void verify_on(outputStream* st);
2542   void verify_data_on(outputStream* st);
2543 
2544   static bool profile_parameters_for_method(const methodHandle&amp; m);
2545   static bool profile_arguments();
2546   static bool profile_arguments_jsr292_only();
2547   static bool profile_return();
2548   static bool profile_parameters();
2549   static bool profile_return_jsr292_only();
2550 
2551   void clean_method_data(bool always_clean);
2552   void clean_weak_method_links();
2553   DEBUG_ONLY(void verify_clean_weak_method_links();)
2554   Mutex* extra_data_lock() { return &amp;_extra_data_lock; }
2555 };
2556 
2557 #endif // SHARE_OOPS_METHODDATA_HPP
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
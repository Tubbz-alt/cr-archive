<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/methodData.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objArrayKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/methodData.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1219   void print_receiver_data_on(outputStream* st) const;
1220   void print_data_on(outputStream* st, const char* extra = NULL) const;
1221 };
1222 
1223 // VirtualCallData
1224 //
1225 // A VirtualCallData is used to access profiling information about a
1226 // virtual call.  For now, it has nothing more than a ReceiverTypeData.
1227 class VirtualCallData : public ReceiverTypeData {
1228 public:
1229   VirtualCallData(DataLayout* layout) : ReceiverTypeData(layout) {
1230     assert(layout-&gt;tag() == DataLayout::virtual_call_data_tag ||
1231            layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, &quot;wrong type&quot;);
1232   }
1233 
1234   virtual bool is_VirtualCallData() const { return true; }
1235 
1236   static int static_cell_count() {
1237     // At this point we could add more profile state, e.g., for arguments.
1238     // But for now it&#39;s the same size as the base record type.
<span class="line-modified">1239     return ReceiverTypeData::static_cell_count() JVMCI_ONLY(+ (uint) MethodProfileWidth * receiver_type_row_cell_count);</span>
1240   }
1241 
1242   virtual int cell_count() const {
1243     return static_cell_count();
1244   }
1245 
1246   // Direct accessors
1247   static ByteSize virtual_call_data_size() {
1248     return cell_offset(static_cell_count());
1249   }
1250 
<span class="line-removed">1251 #if INCLUDE_JVMCI</span>
<span class="line-removed">1252   static ByteSize method_offset(uint row) {</span>
<span class="line-removed">1253     return cell_offset(method_cell_index(row));</span>
<span class="line-removed">1254   }</span>
<span class="line-removed">1255   static ByteSize method_count_offset(uint row) {</span>
<span class="line-removed">1256     return cell_offset(method_count_cell_index(row));</span>
<span class="line-removed">1257   }</span>
<span class="line-removed">1258   static int method_cell_index(uint row) {</span>
<span class="line-removed">1259     return receiver0_offset + (row + TypeProfileWidth) * receiver_type_row_cell_count;</span>
<span class="line-removed">1260   }</span>
<span class="line-removed">1261   static int method_count_cell_index(uint row) {</span>
<span class="line-removed">1262     return count0_offset + (row + TypeProfileWidth) * receiver_type_row_cell_count;</span>
<span class="line-removed">1263   }</span>
<span class="line-removed">1264   static uint method_row_limit() {</span>
<span class="line-removed">1265     return MethodProfileWidth;</span>
<span class="line-removed">1266   }</span>
<span class="line-removed">1267 </span>
<span class="line-removed">1268   Method* method(uint row) const {</span>
<span class="line-removed">1269     assert(row &lt; method_row_limit(), &quot;oob&quot;);</span>
<span class="line-removed">1270 </span>
<span class="line-removed">1271     Method* method = (Method*)intptr_at(method_cell_index(row));</span>
<span class="line-removed">1272     assert(method == NULL || method-&gt;is_method(), &quot;must be&quot;);</span>
<span class="line-removed">1273     return method;</span>
<span class="line-removed">1274   }</span>
<span class="line-removed">1275 </span>
<span class="line-removed">1276   uint method_count(uint row) const {</span>
<span class="line-removed">1277     assert(row &lt; method_row_limit(), &quot;oob&quot;);</span>
<span class="line-removed">1278     return uint_at(method_count_cell_index(row));</span>
<span class="line-removed">1279   }</span>
<span class="line-removed">1280 </span>
<span class="line-removed">1281   void set_method(uint row, Method* m) {</span>
<span class="line-removed">1282     assert((uint)row &lt; method_row_limit(), &quot;oob&quot;);</span>
<span class="line-removed">1283     set_intptr_at(method_cell_index(row), (uintptr_t)m);</span>
<span class="line-removed">1284   }</span>
<span class="line-removed">1285 </span>
<span class="line-removed">1286   void set_method_count(uint row, uint count) {</span>
<span class="line-removed">1287     assert(row &lt; method_row_limit(), &quot;oob&quot;);</span>
<span class="line-removed">1288     set_uint_at(method_count_cell_index(row), count);</span>
<span class="line-removed">1289   }</span>
<span class="line-removed">1290 </span>
<span class="line-removed">1291   void clear_method_row(uint row) {</span>
<span class="line-removed">1292     assert(row &lt; method_row_limit(), &quot;oob&quot;);</span>
<span class="line-removed">1293     // Clear total count - indicator of polymorphic call site (see comment for clear_row() in ReceiverTypeData).</span>
<span class="line-removed">1294     set_nonprofiled_count(0);</span>
<span class="line-removed">1295     set_method(row, NULL);</span>
<span class="line-removed">1296     set_method_count(row, 0);</span>
<span class="line-removed">1297   }</span>
<span class="line-removed">1298 </span>
<span class="line-removed">1299   // GC support</span>
<span class="line-removed">1300   virtual void clean_weak_klass_links(bool always_clean);</span>
<span class="line-removed">1301 </span>
<span class="line-removed">1302   // Redefinition support</span>
<span class="line-removed">1303   virtual void clean_weak_method_links();</span>
<span class="line-removed">1304 #endif // INCLUDE_JVMCI</span>
<span class="line-removed">1305 </span>
1306   void print_method_data_on(outputStream* st) const NOT_JVMCI_RETURN;
1307   void print_data_on(outputStream* st, const char* extra = NULL) const;
1308 };
1309 
1310 // VirtualCallTypeData
1311 //
1312 // A VirtualCallTypeData is used to access profiling information about
1313 // a virtual call for which we collect type information about
1314 // arguments and return value.
1315 class VirtualCallTypeData : public VirtualCallData {
1316 private:
1317   // entries for arguments if any
1318   TypeStackSlotEntries _args;
1319   // entry for return type if any
1320   SingleTypeEntry _ret;
1321 
1322   int cell_count_global_offset() const {
1323     return VirtualCallData::static_cell_count() + TypeEntriesAtCall::cell_count_local_offset();
1324   }
1325 
</pre>
</td>
<td>
<hr />
<pre>
1219   void print_receiver_data_on(outputStream* st) const;
1220   void print_data_on(outputStream* st, const char* extra = NULL) const;
1221 };
1222 
1223 // VirtualCallData
1224 //
1225 // A VirtualCallData is used to access profiling information about a
1226 // virtual call.  For now, it has nothing more than a ReceiverTypeData.
1227 class VirtualCallData : public ReceiverTypeData {
1228 public:
1229   VirtualCallData(DataLayout* layout) : ReceiverTypeData(layout) {
1230     assert(layout-&gt;tag() == DataLayout::virtual_call_data_tag ||
1231            layout-&gt;tag() == DataLayout::virtual_call_type_data_tag, &quot;wrong type&quot;);
1232   }
1233 
1234   virtual bool is_VirtualCallData() const { return true; }
1235 
1236   static int static_cell_count() {
1237     // At this point we could add more profile state, e.g., for arguments.
1238     // But for now it&#39;s the same size as the base record type.
<span class="line-modified">1239     return ReceiverTypeData::static_cell_count();</span>
1240   }
1241 
1242   virtual int cell_count() const {
1243     return static_cell_count();
1244   }
1245 
1246   // Direct accessors
1247   static ByteSize virtual_call_data_size() {
1248     return cell_offset(static_cell_count());
1249   }
1250 























































1251   void print_method_data_on(outputStream* st) const NOT_JVMCI_RETURN;
1252   void print_data_on(outputStream* st, const char* extra = NULL) const;
1253 };
1254 
1255 // VirtualCallTypeData
1256 //
1257 // A VirtualCallTypeData is used to access profiling information about
1258 // a virtual call for which we collect type information about
1259 // arguments and return value.
1260 class VirtualCallTypeData : public VirtualCallData {
1261 private:
1262   // entries for arguments if any
1263   TypeStackSlotEntries _args;
1264   // entry for return type if any
1265   SingleTypeEntry _ret;
1266 
1267   int cell_count_global_offset() const {
1268     return VirtualCallData::static_cell_count() + TypeEntriesAtCall::cell_count_local_offset();
1269   }
1270 
</pre>
</td>
</tr>
</table>
<center><a href="methodData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="objArrayKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
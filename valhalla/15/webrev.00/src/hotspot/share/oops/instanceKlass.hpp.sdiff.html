<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="instanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceMirrorKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 278     _misc_should_verify_class                 = 1 &lt;&lt; 5,  // allow caching of preverification
 279     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 6,  // has embedded _unsafe_anonymous_host field
 280     _misc_is_contended                        = 1 &lt;&lt; 7,  // marked with contended annotation
 281     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 8,  // class/superclass/implemented interfaces has non-static, concrete methods
 282     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 9,  // directly declares non-static, concrete methods
 283     _misc_has_been_redefined                  = 1 &lt;&lt; 10,  // class has been redefined
 284     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 11, // when this class was loaded, the fingerprint computed from its
 285                                                          // code source was found to be matching the value recorded by AOT.
 286     _misc_is_scratch_class                    = 1 &lt;&lt; 12, // class is the redefined scratch class
 287     _misc_is_shared_boot_class                = 1 &lt;&lt; 13, // defining class loader is boot class loader
 288     _misc_is_shared_platform_class            = 1 &lt;&lt; 14, // defining class loader is platform class loader
 289     _misc_is_shared_app_class                 = 1 &lt;&lt; 15, // defining class loader is app class loader
 290     _misc_has_resolved_methods                = 1 &lt;&lt; 16, // resolved methods table entries added for this class
 291     _misc_is_being_redefined                  = 1 &lt;&lt; 17, // used for locking redefinition
 292     _misc_has_contended_annotations           = 1 &lt;&lt; 18, // has @Contended annotation
 293     _misc_has_value_fields                    = 1 &lt;&lt; 19, // has value fields and related embedded section is not empty
 294     _misc_is_empty_value                      = 1 &lt;&lt; 20, // empty value type
 295     _misc_is_naturally_atomic                 = 1 &lt;&lt; 21, // loaded/stored in one instruction
 296     _misc_is_declared_atomic                  = 1 &lt;&lt; 22  // implements jl.NonTearable
 297   };
<span class="line-modified"> 298   u2 loader_type_bits() {</span>
 299     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 300   }
 301   u4              _misc_flags;
 302   u2              _minor_version;        // minor version number of class file
 303   u2              _major_version;        // major version number of class file
 304   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recursive initialization)
 305   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 306   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 307   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 308   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 309   uint64_t        volatile _dep_context_last_cleaned;
 310   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 311 #if INCLUDE_JVMTI
 312   BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
 313   // Linked instanceKlasses of previous versions
 314   InstanceKlass* _previous_versions;
 315   // JVMTI fields can be moved to their own structure - see 6315920
 316   // JVMTI: cached class file, before retransformable agent modified it in CFLH
 317   JvmtiCachedClassFileData* _cached_class_file;
 318 #endif
</pre>
<hr />
<pre>
 372   //   The embedded implementor only exists if the current klass is an
 373   //   iterface. The possible values of the implementor fall into following
 374   //   three cases:
 375   //     NULL: no implementor.
 376   //     A Klass* that&#39;s not itself: one implementor.
 377   //     Itself: more than one implementors.
 378   // embedded unsafe_anonymous_host klass follows here
 379   //   The embedded host klass only exists in an unsafe anonymous class for
 380   //   dynamic language support (JSR 292 enabled). The host class grants
 381   //   its access privileges to this class also. The host class is either
 382   //   named, or a previously loaded unsafe anonymous class. A non-anonymous class
 383   //   or an anonymous class loaded through normal classloading does not
 384   //   have this embedded field.
 385   //
 386 
 387   friend class SystemDictionary;
 388 
 389   static bool _disable_method_binary_search;
 390 
 391  public:
<span class="line-modified"> 392   u2 loader_type() {</span>
<span class="line-removed"> 393     return _misc_flags &amp; loader_type_bits();</span>
<span class="line-removed"> 394   }</span>
<span class="line-removed"> 395 </span>
 396   bool is_shared_boot_class() const {
 397     return (_misc_flags &amp; _misc_is_shared_boot_class) != 0;
 398   }
 399   bool is_shared_platform_class() const {
 400     return (_misc_flags &amp; _misc_is_shared_platform_class) != 0;
 401   }
 402   bool is_shared_app_class() const {
 403     return (_misc_flags &amp; _misc_is_shared_app_class) != 0;
 404   }




 405 
<span class="line-modified"> 406   void clear_class_loader_type() {</span>
<span class="line-modified"> 407     _misc_flags &amp;= ~loader_type_bits();</span>
 408   }
 409 
<span class="line-modified"> 410   void set_class_loader_type(s2 loader_type);</span>
 411 
 412   bool has_nonstatic_fields() const        {
 413     return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
 414   }
 415   void set_has_nonstatic_fields(bool b)    {
 416     if (b) {
 417       _misc_flags |= _misc_has_nonstatic_fields;
 418     } else {
 419       _misc_flags &amp;= ~_misc_has_nonstatic_fields;
 420     }
 421   }
 422 
 423   bool has_value_fields() const          {
 424     return (_misc_flags &amp; _misc_has_value_fields) != 0;
 425   }
 426   void set_has_value_fields()  {
 427     _misc_flags |= _misc_has_value_fields;
 428   }
 429 
 430   bool is_empty_value() const {
</pre>
<hr />
<pre>
1329   static void deallocate_methods(ClassLoaderData* loader_data,
1330                                  Array&lt;Method*&gt;* methods);
1331   void static deallocate_interfaces(ClassLoaderData* loader_data,
1332                                     const Klass* super_klass,
1333                                     Array&lt;InstanceKlass*&gt;* local_interfaces,
1334                                     Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1335   void static deallocate_record_components(ClassLoaderData* loader_data,
1336                                            Array&lt;RecordComponent*&gt;* record_component);
1337 
1338   // The constant pool is on stack if any of the methods are executing or
1339   // referenced by handles.
1340   bool on_stack() const { return _constants-&gt;on_stack(); }
1341 
1342   // callbacks for actions during class unloading
1343   static void unload_class(InstanceKlass* ik);
1344   static void release_C_heap_structures(InstanceKlass* ik);
1345 
1346   // Naming
1347   const char* signature_name() const;
1348   const char* signature_name_of(char c) const;
<span class="line-removed">1349   static Symbol* package_from_name(const Symbol* name, TRAPS);</span>
1350 
1351   // Oop fields (and metadata) iterators
1352   //
1353   // The InstanceKlass iterators also visits the Object&#39;s klass.
1354 
1355   // Forward iteration
1356  public:
1357   // Iterate over all oop fields in the oop maps.
1358   template &lt;typename T, class OopClosureType&gt;
1359   inline void oop_oop_iterate_oop_maps(oop obj, OopClosureType* closure);
1360 
1361   // Iterate over all oop fields and metadata.
1362   template &lt;typename T, class OopClosureType&gt;
1363   inline void oop_oop_iterate(oop obj, OopClosureType* closure);
1364 
1365   // Iterate over all oop fields in one oop map.
1366   template &lt;typename T, class OopClosureType&gt;
1367   inline void oop_oop_iterate_oop_map(OopMapBlock* map, oop obj, OopClosureType* closure);
1368 
1369 
</pre>
<hr />
<pre>
1384 
1385   // Bounded range iteration
1386  public:
1387   // Iterate over all oop fields in the oop maps.
1388   template &lt;typename T, class OopClosureType&gt;
1389   inline void oop_oop_iterate_oop_maps_bounded(oop obj, OopClosureType* closure, MemRegion mr);
1390 
1391   // Iterate over all oop fields and metadata.
1392   template &lt;typename T, class OopClosureType&gt;
1393   inline void oop_oop_iterate_bounded(oop obj, OopClosureType* closure, MemRegion mr);
1394 
1395  private:
1396   // Iterate over all oop fields in one oop map.
1397   template &lt;typename T, class OopClosureType&gt;
1398   inline void oop_oop_iterate_oop_map_bounded(OopMapBlock* map, oop obj, OopClosureType* closure, MemRegion mr);
1399 
1400 
1401  public:
1402   u2 idnum_allocated_count() const      { return _idnum_allocated_count; }
1403 
<span class="line-removed">1404 public:</span>
<span class="line-removed">1405   void set_in_error_state() {</span>
<span class="line-removed">1406     assert(DumpSharedSpaces, &quot;only call this when dumping archive&quot;);</span>
<span class="line-removed">1407     _init_state = initialization_error;</span>
<span class="line-removed">1408   }</span>
<span class="line-removed">1409   bool check_sharing_error_state();</span>
<span class="line-removed">1410 </span>
1411 private:
1412   // initialization state
1413   void set_init_state(ClassState state);
1414   void set_rewritten()                  { _misc_flags |= _misc_rewritten; }
1415   void set_init_thread(Thread *thread)  { _init_thread = thread; }
1416 
1417   // The RedefineClasses() API can cause new method idnums to be needed
1418   // which will cause the caches to grow. Safety requires different
1419   // cache management logic if the caches can grow instead of just
1420   // going from NULL to non-NULL.
1421   bool idnum_can_increment() const      { return has_been_redefined(); }
1422   inline jmethodID* methods_jmethod_ids_acquire() const;
1423   inline void release_set_methods_jmethod_ids(jmethodID* jmeths);
1424 
1425   // Lock during initialization
1426 public:
1427   // Lock for (1) initialization; (2) access to the ConstantPool of this class.
1428   // Must be one per class and it has to be a VM internal object so java code
1429   // cannot lock it (like the mirror).
1430   // It has to be an object not a Mutex because it&#39;s held through java calls.
</pre>
</td>
<td>
<hr />
<pre>
 278     _misc_should_verify_class                 = 1 &lt;&lt; 5,  // allow caching of preverification
 279     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 6,  // has embedded _unsafe_anonymous_host field
 280     _misc_is_contended                        = 1 &lt;&lt; 7,  // marked with contended annotation
 281     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 8,  // class/superclass/implemented interfaces has non-static, concrete methods
 282     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 9,  // directly declares non-static, concrete methods
 283     _misc_has_been_redefined                  = 1 &lt;&lt; 10,  // class has been redefined
 284     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 11, // when this class was loaded, the fingerprint computed from its
 285                                                          // code source was found to be matching the value recorded by AOT.
 286     _misc_is_scratch_class                    = 1 &lt;&lt; 12, // class is the redefined scratch class
 287     _misc_is_shared_boot_class                = 1 &lt;&lt; 13, // defining class loader is boot class loader
 288     _misc_is_shared_platform_class            = 1 &lt;&lt; 14, // defining class loader is platform class loader
 289     _misc_is_shared_app_class                 = 1 &lt;&lt; 15, // defining class loader is app class loader
 290     _misc_has_resolved_methods                = 1 &lt;&lt; 16, // resolved methods table entries added for this class
 291     _misc_is_being_redefined                  = 1 &lt;&lt; 17, // used for locking redefinition
 292     _misc_has_contended_annotations           = 1 &lt;&lt; 18, // has @Contended annotation
 293     _misc_has_value_fields                    = 1 &lt;&lt; 19, // has value fields and related embedded section is not empty
 294     _misc_is_empty_value                      = 1 &lt;&lt; 20, // empty value type
 295     _misc_is_naturally_atomic                 = 1 &lt;&lt; 21, // loaded/stored in one instruction
 296     _misc_is_declared_atomic                  = 1 &lt;&lt; 22  // implements jl.NonTearable
 297   };
<span class="line-modified"> 298   u2 shared_loader_type_bits() const {</span>
 299     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 300   }
 301   u4              _misc_flags;
 302   u2              _minor_version;        // minor version number of class file
 303   u2              _major_version;        // major version number of class file
 304   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recursive initialization)
 305   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 306   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 307   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 308   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 309   uint64_t        volatile _dep_context_last_cleaned;
 310   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 311 #if INCLUDE_JVMTI
 312   BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
 313   // Linked instanceKlasses of previous versions
 314   InstanceKlass* _previous_versions;
 315   // JVMTI fields can be moved to their own structure - see 6315920
 316   // JVMTI: cached class file, before retransformable agent modified it in CFLH
 317   JvmtiCachedClassFileData* _cached_class_file;
 318 #endif
</pre>
<hr />
<pre>
 372   //   The embedded implementor only exists if the current klass is an
 373   //   iterface. The possible values of the implementor fall into following
 374   //   three cases:
 375   //     NULL: no implementor.
 376   //     A Klass* that&#39;s not itself: one implementor.
 377   //     Itself: more than one implementors.
 378   // embedded unsafe_anonymous_host klass follows here
 379   //   The embedded host klass only exists in an unsafe anonymous class for
 380   //   dynamic language support (JSR 292 enabled). The host class grants
 381   //   its access privileges to this class also. The host class is either
 382   //   named, or a previously loaded unsafe anonymous class. A non-anonymous class
 383   //   or an anonymous class loaded through normal classloading does not
 384   //   have this embedded field.
 385   //
 386 
 387   friend class SystemDictionary;
 388 
 389   static bool _disable_method_binary_search;
 390 
 391  public:
<span class="line-modified"> 392   // The three BUILTIN class loader types</span>



 393   bool is_shared_boot_class() const {
 394     return (_misc_flags &amp; _misc_is_shared_boot_class) != 0;
 395   }
 396   bool is_shared_platform_class() const {
 397     return (_misc_flags &amp; _misc_is_shared_platform_class) != 0;
 398   }
 399   bool is_shared_app_class() const {
 400     return (_misc_flags &amp; _misc_is_shared_app_class) != 0;
 401   }
<span class="line-added"> 402   // The UNREGISTERED class loader type</span>
<span class="line-added"> 403   bool is_shared_unregistered_class() const {</span>
<span class="line-added"> 404     return (_misc_flags &amp; shared_loader_type_bits()) == 0;</span>
<span class="line-added"> 405   }</span>
 406 
<span class="line-modified"> 407   void clear_shared_class_loader_type() {</span>
<span class="line-modified"> 408     _misc_flags &amp;= ~shared_loader_type_bits();</span>
 409   }
 410 
<span class="line-modified"> 411   void set_shared_class_loader_type(s2 loader_type);</span>
 412 
 413   bool has_nonstatic_fields() const        {
 414     return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
 415   }
 416   void set_has_nonstatic_fields(bool b)    {
 417     if (b) {
 418       _misc_flags |= _misc_has_nonstatic_fields;
 419     } else {
 420       _misc_flags &amp;= ~_misc_has_nonstatic_fields;
 421     }
 422   }
 423 
 424   bool has_value_fields() const          {
 425     return (_misc_flags &amp; _misc_has_value_fields) != 0;
 426   }
 427   void set_has_value_fields()  {
 428     _misc_flags |= _misc_has_value_fields;
 429   }
 430 
 431   bool is_empty_value() const {
</pre>
<hr />
<pre>
1330   static void deallocate_methods(ClassLoaderData* loader_data,
1331                                  Array&lt;Method*&gt;* methods);
1332   void static deallocate_interfaces(ClassLoaderData* loader_data,
1333                                     const Klass* super_klass,
1334                                     Array&lt;InstanceKlass*&gt;* local_interfaces,
1335                                     Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1336   void static deallocate_record_components(ClassLoaderData* loader_data,
1337                                            Array&lt;RecordComponent*&gt;* record_component);
1338 
1339   // The constant pool is on stack if any of the methods are executing or
1340   // referenced by handles.
1341   bool on_stack() const { return _constants-&gt;on_stack(); }
1342 
1343   // callbacks for actions during class unloading
1344   static void unload_class(InstanceKlass* ik);
1345   static void release_C_heap_structures(InstanceKlass* ik);
1346 
1347   // Naming
1348   const char* signature_name() const;
1349   const char* signature_name_of(char c) const;

1350 
1351   // Oop fields (and metadata) iterators
1352   //
1353   // The InstanceKlass iterators also visits the Object&#39;s klass.
1354 
1355   // Forward iteration
1356  public:
1357   // Iterate over all oop fields in the oop maps.
1358   template &lt;typename T, class OopClosureType&gt;
1359   inline void oop_oop_iterate_oop_maps(oop obj, OopClosureType* closure);
1360 
1361   // Iterate over all oop fields and metadata.
1362   template &lt;typename T, class OopClosureType&gt;
1363   inline void oop_oop_iterate(oop obj, OopClosureType* closure);
1364 
1365   // Iterate over all oop fields in one oop map.
1366   template &lt;typename T, class OopClosureType&gt;
1367   inline void oop_oop_iterate_oop_map(OopMapBlock* map, oop obj, OopClosureType* closure);
1368 
1369 
</pre>
<hr />
<pre>
1384 
1385   // Bounded range iteration
1386  public:
1387   // Iterate over all oop fields in the oop maps.
1388   template &lt;typename T, class OopClosureType&gt;
1389   inline void oop_oop_iterate_oop_maps_bounded(oop obj, OopClosureType* closure, MemRegion mr);
1390 
1391   // Iterate over all oop fields and metadata.
1392   template &lt;typename T, class OopClosureType&gt;
1393   inline void oop_oop_iterate_bounded(oop obj, OopClosureType* closure, MemRegion mr);
1394 
1395  private:
1396   // Iterate over all oop fields in one oop map.
1397   template &lt;typename T, class OopClosureType&gt;
1398   inline void oop_oop_iterate_oop_map_bounded(OopMapBlock* map, oop obj, OopClosureType* closure, MemRegion mr);
1399 
1400 
1401  public:
1402   u2 idnum_allocated_count() const      { return _idnum_allocated_count; }
1403 







1404 private:
1405   // initialization state
1406   void set_init_state(ClassState state);
1407   void set_rewritten()                  { _misc_flags |= _misc_rewritten; }
1408   void set_init_thread(Thread *thread)  { _init_thread = thread; }
1409 
1410   // The RedefineClasses() API can cause new method idnums to be needed
1411   // which will cause the caches to grow. Safety requires different
1412   // cache management logic if the caches can grow instead of just
1413   // going from NULL to non-NULL.
1414   bool idnum_can_increment() const      { return has_been_redefined(); }
1415   inline jmethodID* methods_jmethod_ids_acquire() const;
1416   inline void release_set_methods_jmethod_ids(jmethodID* jmeths);
1417 
1418   // Lock during initialization
1419 public:
1420   // Lock for (1) initialization; (2) access to the ConstantPool of this class.
1421   // Must be one per class and it has to be a VM internal object so java code
1422   // cannot lock it (like the mirror).
1423   // It has to be an object not a Mutex because it&#39;s held through java calls.
</pre>
</td>
</tr>
</table>
<center><a href="instanceKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceMirrorKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
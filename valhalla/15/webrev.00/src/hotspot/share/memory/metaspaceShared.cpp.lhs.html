<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/metaspaceShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/classListParser.hpp&quot;
  29 #include &quot;classfile/classLoaderExt.hpp&quot;
  30 #include &quot;classfile/dictionary.hpp&quot;
  31 #include &quot;classfile/loaderConstraints.hpp&quot;
  32 #include &quot;classfile/javaClasses.inline.hpp&quot;
  33 #include &quot;classfile/placeholders.hpp&quot;
  34 #include &quot;classfile/symbolTable.hpp&quot;
  35 #include &quot;classfile/stringTable.hpp&quot;
  36 #include &quot;classfile/systemDictionary.hpp&quot;
  37 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  38 #include &quot;code/codeCache.hpp&quot;
  39 #include &quot;gc/shared/softRefPolicy.hpp&quot;
  40 #include &quot;interpreter/bytecodeStream.hpp&quot;
  41 #include &quot;interpreter/bytecodes.hpp&quot;
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logMessage.hpp&quot;
  44 #include &quot;memory/archiveUtils.inline.hpp&quot;
  45 #include &quot;memory/dynamicArchive.hpp&quot;
  46 #include &quot;memory/filemap.hpp&quot;
  47 #include &quot;memory/heapShared.inline.hpp&quot;
  48 #include &quot;memory/metaspace.hpp&quot;
  49 #include &quot;memory/metaspaceClosure.hpp&quot;
  50 #include &quot;memory/metaspaceShared.hpp&quot;
  51 #include &quot;memory/resourceArea.hpp&quot;
  52 #include &quot;memory/universe.hpp&quot;
  53 #include &quot;oops/compressedOops.inline.hpp&quot;
  54 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  55 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  56 #include &quot;oops/instanceRefKlass.hpp&quot;
  57 #include &quot;oops/methodData.hpp&quot;
  58 #include &quot;oops/objArrayKlass.hpp&quot;
  59 #include &quot;oops/objArrayOop.hpp&quot;
  60 #include &quot;oops/oop.inline.hpp&quot;
  61 #include &quot;oops/typeArrayKlass.hpp&quot;
  62 #include &quot;oops/valueArrayKlass.hpp&quot;
  63 #include &quot;oops/valueKlass.hpp&quot;
  64 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/os.hpp&quot;
  67 #include &quot;runtime/safepointVerifiers.hpp&quot;
  68 #include &quot;runtime/signature.hpp&quot;
  69 #include &quot;runtime/timerTrace.hpp&quot;
  70 #include &quot;runtime/vmThread.hpp&quot;
  71 #include &quot;runtime/vmOperations.hpp&quot;
  72 #include &quot;utilities/align.hpp&quot;
  73 #include &quot;utilities/bitMap.inline.hpp&quot;
  74 #include &quot;utilities/defaultStream.hpp&quot;
  75 #include &quot;utilities/hashtable.inline.hpp&quot;
  76 #if INCLUDE_G1GC
  77 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
  78 #endif
  79 
  80 ReservedSpace MetaspaceShared::_shared_rs;
  81 VirtualSpace MetaspaceShared::_shared_vs;
  82 MetaspaceSharedStats MetaspaceShared::_stats;
  83 bool MetaspaceShared::_has_error_classes;
  84 bool MetaspaceShared::_archive_loading_failed = false;
  85 bool MetaspaceShared::_remapped_readwrite = false;
  86 address MetaspaceShared::_i2i_entry_code_buffers = NULL;
  87 size_t MetaspaceShared::_i2i_entry_code_buffers_size = 0;
  88 void* MetaspaceShared::_shared_metaspace_static_top = NULL;
  89 intx MetaspaceShared::_relocation_delta;
  90 
  91 // The CDS archive is divided into the following regions:
  92 //     mc  - misc code (the method entry trampolines, c++ vtables)
  93 //     rw  - read-write metadata
  94 //     ro  - read-only metadata and read-only tables
  95 //
  96 //     ca0 - closed archive heap space #0
  97 //     ca1 - closed archive heap space #1 (may be empty)
  98 //     oa0 - open archive heap space #0
  99 //     oa1 - open archive heap space #1 (may be empty)
 100 //
 101 // The mc, rw, and ro regions are linearly allocated, starting from
 102 // SharedBaseAddress, in the order of mc-&gt;rw-&gt;ro. The size of these 3 regions
 103 // are page-aligned, and there&#39;s no gap between any consecutive regions.
 104 //
 105 // These 3 regions are populated in the following steps:
 106 // [1] All classes are loaded in MetaspaceShared::preload_classes(). All metadata are
 107 //     temporarily allocated outside of the shared regions. Only the method entry
 108 //     trampolines are written into the mc region.
 109 // [2] C++ vtables are copied into the mc region.
 110 // [3] ArchiveCompactor copies RW metadata into the rw region.
 111 // [4] ArchiveCompactor copies RO metadata into the ro region.
 112 // [5] SymbolTable, StringTable, SystemDictionary, and a few other read-only data
 113 //     are copied into the ro region as read-only tables.
 114 //
 115 // The s0/s1 and oa0/oa1 regions are populated inside HeapShared::archive_java_heap_objects.
 116 // Their layout is independent of the other 4 regions.
 117 
 118 char* DumpRegion::expand_top_to(char* newtop) {
 119   assert(is_allocatable(), &quot;must be initialized and not packed&quot;);
 120   assert(newtop &gt;= _top, &quot;must not grow backwards&quot;);
 121   if (newtop &gt; _end) {
 122     MetaspaceShared::report_out_of_space(_name, newtop - _top);
 123     ShouldNotReachHere();
 124   }
 125   uintx delta;
 126   if (DynamicDumpSharedSpaces) {
 127     delta = DynamicArchive::object_delta_uintx(newtop);
 128   } else {
 129     delta = MetaspaceShared::object_delta_uintx(newtop);
 130   }
 131   if (delta &gt; MAX_SHARED_DELTA) {
 132     // This is just a sanity check and should not appear in any real world usage. This
 133     // happens only if you allocate more than 2GB of shared objects and would require
 134     // millions of shared classes.
 135     vm_exit_during_initialization(&quot;Out of memory in the CDS archive&quot;,
 136                                   &quot;Please reduce the number of shared classes.&quot;);
 137   }
 138 
 139   MetaspaceShared::commit_shared_space_to(newtop);
 140   _top = newtop;
 141   return _top;
 142 }
 143 
 144 char* DumpRegion::allocate(size_t num_bytes, size_t alignment) {
 145   char* p = (char*)align_up(_top, alignment);
 146   char* newtop = p + align_up(num_bytes, alignment);
 147   expand_top_to(newtop);
 148   memset(p, 0, newtop - p);
 149   return p;
 150 }
 151 
 152 void DumpRegion::append_intptr_t(intptr_t n, bool need_to_mark) {
 153   assert(is_aligned(_top, sizeof(intptr_t)), &quot;bad alignment&quot;);
 154   intptr_t *p = (intptr_t*)_top;
 155   char* newtop = _top + sizeof(intptr_t);
 156   expand_top_to(newtop);
 157   *p = n;
 158   if (need_to_mark) {
 159     ArchivePtrMarker::mark_pointer(p);
 160   }
 161 }
 162 
 163 void DumpRegion::print(size_t total_bytes) const {
 164   log_debug(cds)(&quot;%-3s space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [%5.1f%% used] at &quot; INTPTR_FORMAT,
 165                  _name, used(), percent_of(used(), total_bytes), reserved(), percent_of(used(), reserved()),
 166                  p2i(_base + MetaspaceShared::final_delta()));
 167 }
 168 
 169 void DumpRegion::print_out_of_space_msg(const char* failing_region, size_t needed_bytes) {
 170   log_error(cds)(&quot;[%-8s] &quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT &quot; capacity =%9d, allocated =%9d&quot;,
 171                  _name, p2i(_base), p2i(_top), int(_end - _base), int(_top - _base));
 172   if (strcmp(_name, failing_region) == 0) {
 173     log_error(cds)(&quot; required = %d&quot;, int(needed_bytes));
 174   }
 175 }
 176 
 177 void DumpRegion::pack(DumpRegion* next) {
 178   assert(!is_packed(), &quot;sanity&quot;);
 179   _end = (char*)align_up(_top, Metaspace::reserve_alignment());
 180   _is_packed = true;
 181   if (next != NULL) {
 182     next-&gt;_base = next-&gt;_top = this-&gt;_end;
 183     next-&gt;_end = MetaspaceShared::shared_rs()-&gt;end();
 184   }
 185 }
 186 
 187 static DumpRegion _mc_region(&quot;mc&quot;), _ro_region(&quot;ro&quot;), _rw_region(&quot;rw&quot;);
 188 static size_t _total_closed_archive_region_size = 0, _total_open_archive_region_size = 0;
 189 
 190 void MetaspaceShared::init_shared_dump_space(DumpRegion* first_space, address first_space_bottom) {
 191   // Start with 0 committed bytes. The memory will be committed as needed by
 192   // MetaspaceShared::commit_shared_space_to().
 193   if (!_shared_vs.initialize(_shared_rs, 0)) {
 194     fatal(&quot;Unable to allocate memory for shared space&quot;);
 195   }
 196   first_space-&gt;init(&amp;_shared_rs, (char*)first_space_bottom);
 197 }
 198 
 199 DumpRegion* MetaspaceShared::misc_code_dump_space() {
 200   return &amp;_mc_region;
 201 }
 202 
 203 DumpRegion* MetaspaceShared::read_write_dump_space() {
 204   return &amp;_rw_region;
 205 }
 206 
 207 DumpRegion* MetaspaceShared::read_only_dump_space() {
 208   return &amp;_ro_region;
 209 }
 210 
 211 void MetaspaceShared::pack_dump_space(DumpRegion* current, DumpRegion* next,
 212                                       ReservedSpace* rs) {
 213   current-&gt;pack(next);
 214 }
 215 
 216 char* MetaspaceShared::misc_code_space_alloc(size_t num_bytes) {
 217   return _mc_region.allocate(num_bytes);
 218 }
 219 
 220 char* MetaspaceShared::read_only_space_alloc(size_t num_bytes) {
 221   return _ro_region.allocate(num_bytes);
 222 }
 223 
 224 // When reserving an address range using ReservedSpace, we need an alignment that satisfies both:
 225 // os::vm_allocation_granularity() -- so that we can sub-divide this range into multiple mmap regions,
 226 //                                    while keeping the first range at offset 0 of this range.
 227 // Metaspace::reserve_alignment()  -- so we can pass the region to
 228 //                                    Metaspace::allocate_metaspace_compressed_klass_ptrs.
 229 size_t MetaspaceShared::reserved_space_alignment() {
 230   size_t os_align = os::vm_allocation_granularity();
 231   size_t ms_align = Metaspace::reserve_alignment();
 232   if (os_align &gt;= ms_align) {
 233     assert(os_align % ms_align == 0, &quot;must be a multiple&quot;);
 234     return os_align;
 235   } else {
 236     assert(ms_align % os_align == 0, &quot;must be a multiple&quot;);
 237     return ms_align;
 238   }
 239 }
 240 
 241 ReservedSpace MetaspaceShared::reserve_shared_space(size_t size, char* requested_address) {
 242   return Metaspace::reserve_space(size, reserved_space_alignment(),
 243                                   requested_address, requested_address != NULL);
 244 }
 245 
 246 void MetaspaceShared::initialize_dumptime_shared_and_meta_spaces() {
 247   assert(DumpSharedSpaces, &quot;should be called for dump time only&quot;);
 248   const size_t reserve_alignment = reserved_space_alignment();
 249   char* shared_base = (char*)align_up((char*)SharedBaseAddress, reserve_alignment);
 250 
 251 #ifdef _LP64
 252   // On 64-bit VM, the heap and class space layout will be the same as if
 253   // you&#39;re running in -Xshare:on mode:
 254   //
 255   //                              +-- SharedBaseAddress (default = 0x800000000)
 256   //                              v
 257   // +-..---------+---------+ ... +----+----+----+--------------------+
 258   // |    Heap    | Archive |     | MC | RW | RO |    class space     |
 259   // +-..---------+---------+ ... +----+----+----+--------------------+
 260   // |&lt;--   MaxHeapSize  --&gt;|     |&lt;-- UnscaledClassSpaceMax = 4GB --&gt;|
 261   //
 262   const uint64_t UnscaledClassSpaceMax = (uint64_t(max_juint) + 1);
 263   const size_t cds_total = align_down(UnscaledClassSpaceMax, reserve_alignment);
 264 #else
 265   // We don&#39;t support archives larger than 256MB on 32-bit due to limited virtual address space.
 266   size_t cds_total = align_down(256*M, reserve_alignment);
 267 #endif
 268 
 269   bool use_requested_base = true;
 270   if (ArchiveRelocationMode == 1) {
 271     log_info(cds)(&quot;ArchiveRelocationMode == 1: always allocate class space at an alternative address&quot;);
 272     use_requested_base = false;
 273   }
 274 
 275   // First try to reserve the space at the specified SharedBaseAddress.
 276   assert(!_shared_rs.is_reserved(), &quot;must be&quot;);
 277   if (use_requested_base) {
 278     _shared_rs = reserve_shared_space(cds_total, shared_base);
 279   }
 280   if (_shared_rs.is_reserved()) {
 281     assert(shared_base == 0 || _shared_rs.base() == shared_base, &quot;should match&quot;);
 282   } else {
 283     // Get a mmap region anywhere if the SharedBaseAddress fails.
 284     _shared_rs = reserve_shared_space(cds_total);
 285   }
 286   if (!_shared_rs.is_reserved()) {
 287     vm_exit_during_initialization(&quot;Unable to reserve memory for shared space&quot;,
 288                                   err_msg(SIZE_FORMAT &quot; bytes.&quot;, cds_total));
 289   }
 290 
 291 #ifdef _LP64
 292   // During dump time, we allocate 4GB (UnscaledClassSpaceMax) of space and split it up:
 293   // + The upper 1 GB is used as the &quot;temporary compressed class space&quot; -- preload_classes()
 294   //   will store Klasses into this space.
 295   // + The lower 3 GB is used for the archive -- when preload_classes() is done,
 296   //   ArchiveCompactor will copy the class metadata into this space, first the RW parts,
 297   //   then the RO parts.
 298 
 299   size_t max_archive_size = align_down(cds_total * 3 / 4, reserve_alignment);
 300   ReservedSpace tmp_class_space = _shared_rs.last_part(max_archive_size);
 301   CompressedClassSpaceSize = align_down(tmp_class_space.size(), reserve_alignment);
 302   _shared_rs = _shared_rs.first_part(max_archive_size);
 303 
 304   if (UseCompressedClassPointers) {
 305     // Set up compress class pointers.
 306     CompressedKlassPointers::set_base((address)_shared_rs.base());
 307     // Set narrow_klass_shift to be LogKlassAlignmentInBytes. This is consistent
 308     // with AOT.
 309     CompressedKlassPointers::set_shift(LogKlassAlignmentInBytes);
 310     // Set the range of klass addresses to 4GB.
 311     CompressedKlassPointers::set_range(cds_total);
 312     Metaspace::initialize_class_space(tmp_class_space);
 313   }
 314   log_info(cds)(&quot;narrow_klass_base = &quot; PTR_FORMAT &quot;, narrow_klass_shift = %d&quot;,
 315                 p2i(CompressedKlassPointers::base()), CompressedKlassPointers::shift());
 316 
 317   log_info(cds)(&quot;Allocated temporary class space: &quot; SIZE_FORMAT &quot; bytes at &quot; PTR_FORMAT,
 318                 CompressedClassSpaceSize, p2i(tmp_class_space.base()));
 319 #endif
 320 
 321   init_shared_dump_space(&amp;_mc_region);
 322   SharedBaseAddress = (size_t)_shared_rs.base();
 323   log_info(cds)(&quot;Allocated shared space: &quot; SIZE_FORMAT &quot; bytes at &quot; PTR_FORMAT,
 324                 _shared_rs.size(), p2i(_shared_rs.base()));
 325 }
 326 
 327 // Called by universe_post_init()
 328 void MetaspaceShared::post_initialize(TRAPS) {
 329   if (UseSharedSpaces) {
 330     int size = FileMapInfo::get_number_of_shared_paths();
 331     if (size &gt; 0) {
 332       SystemDictionaryShared::allocate_shared_data_arrays(size, THREAD);
 333       if (!DynamicDumpSharedSpaces) {
 334         FileMapInfo* info;
 335         if (FileMapInfo::dynamic_info() == NULL) {
 336           info = FileMapInfo::current_info();
 337         } else {
 338           info = FileMapInfo::dynamic_info();
 339         }
 340         ClassLoaderExt::init_paths_start_index(info-&gt;app_class_paths_start_index());
 341         ClassLoaderExt::init_app_module_paths_start_index(info-&gt;app_module_paths_start_index());
 342       }
 343     }
 344   }
 345 }
 346 
 347 static GrowableArray&lt;Handle&gt;* _extra_interned_strings = NULL;
 348 
 349 void MetaspaceShared::read_extra_data(const char* filename, TRAPS) {
 350   _extra_interned_strings = new (ResourceObj::C_HEAP, mtInternal)GrowableArray&lt;Handle&gt;(10000, true);
 351 
 352   HashtableTextDump reader(filename);
 353   reader.check_version(&quot;VERSION: 1.0&quot;);
 354 
 355   while (reader.remain() &gt; 0) {
 356     int utf8_length;
 357     int prefix_type = reader.scan_prefix(&amp;utf8_length);
 358     ResourceMark rm(THREAD);
 359     if (utf8_length == 0x7fffffff) {
 360       // buf_len will overflown 32-bit value.
 361       vm_exit_during_initialization(err_msg(&quot;string length too large: %d&quot;, utf8_length));
 362     }
 363     int buf_len = utf8_length+1;
 364     char* utf8_buffer = NEW_RESOURCE_ARRAY(char, buf_len);
 365     reader.get_utf8(utf8_buffer, utf8_length);
 366     utf8_buffer[utf8_length] = &#39;\0&#39;;
 367 
 368     if (prefix_type == HashtableTextDump::SymbolPrefix) {
 369       SymbolTable::new_permanent_symbol(utf8_buffer);
 370     } else{
 371       assert(prefix_type == HashtableTextDump::StringPrefix, &quot;Sanity&quot;);
 372       oop s = StringTable::intern(utf8_buffer, THREAD);
 373 
 374       if (HAS_PENDING_EXCEPTION) {
 375         log_warning(cds, heap)(&quot;[line %d] extra interned string allocation failed; size too large: %d&quot;,
 376                                reader.last_line_no(), utf8_length);
 377         CLEAR_PENDING_EXCEPTION;
 378       } else {
 379 #if INCLUDE_G1GC
 380         if (UseG1GC) {
 381           typeArrayOop body = java_lang_String::value(s);
 382           const HeapRegion* hr = G1CollectedHeap::heap()-&gt;heap_region_containing(body);
 383           if (hr-&gt;is_humongous()) {
 384             // Don&#39;t keep it alive, so it will be GC&#39;ed before we dump the strings, in order
 385             // to maximize free heap space and minimize fragmentation.
 386             log_warning(cds, heap)(&quot;[line %d] extra interned string ignored; size too large: %d&quot;,
 387                                 reader.last_line_no(), utf8_length);
 388             continue;
 389           }
 390         }
 391 #endif
 392         // Interned strings are GC&#39;ed if there are no references to it, so let&#39;s
 393         // add a reference to keep this string alive.
 394         assert(s != NULL, &quot;must succeed&quot;);
 395         Handle h(THREAD, s);
 396         _extra_interned_strings-&gt;append(h);
 397       }
 398     }
 399   }
 400 }
 401 
 402 void MetaspaceShared::commit_shared_space_to(char* newtop) {
 403   Arguments::assert_is_dumping_archive();
 404   char* base = _shared_rs.base();
 405   size_t need_committed_size = newtop - base;
 406   size_t has_committed_size = _shared_vs.committed_size();
 407   if (need_committed_size &lt; has_committed_size) {
 408     return;
 409   }
 410 
 411   size_t min_bytes = need_committed_size - has_committed_size;
 412   size_t preferred_bytes = 1 * M;
 413   size_t uncommitted = _shared_vs.reserved_size() - has_committed_size;
 414 
 415   size_t commit =MAX2(min_bytes, preferred_bytes);
 416   commit = MIN2(commit, uncommitted);
 417   assert(commit &lt;= uncommitted, &quot;sanity&quot;);
 418 
 419   bool result = _shared_vs.expand_by(commit, false);
 420   ArchivePtrMarker::expand_ptr_end((address*)_shared_vs.high());
 421 
 422   if (!result) {
 423     vm_exit_during_initialization(err_msg(&quot;Failed to expand shared space to &quot; SIZE_FORMAT &quot; bytes&quot;,
 424                                           need_committed_size));
 425   }
 426 
 427   log_debug(cds)(&quot;Expanding shared spaces by &quot; SIZE_FORMAT_W(7) &quot; bytes [total &quot; SIZE_FORMAT_W(9)  &quot; bytes ending at %p]&quot;,
 428                  commit, _shared_vs.actual_committed_size(), _shared_vs.high());
 429 }
 430 
 431 void MetaspaceShared::initialize_ptr_marker(CHeapBitMap* ptrmap) {
 432   ArchivePtrMarker::initialize(ptrmap, (address*)_shared_vs.low(), (address*)_shared_vs.high());
 433 }
 434 
 435 // Read/write a data stream for restoring/preserving metadata pointers and
 436 // miscellaneous data from/to the shared archive file.
 437 
 438 void MetaspaceShared::serialize(SerializeClosure* soc) {
 439   int tag = 0;
 440   soc-&gt;do_tag(--tag);
 441 
 442   // Verify the sizes of various metadata in the system.
 443   soc-&gt;do_tag(sizeof(Method));
 444   soc-&gt;do_tag(sizeof(ConstMethod));
 445   soc-&gt;do_tag(arrayOopDesc::base_offset_in_bytes(T_BYTE));
 446   soc-&gt;do_tag(sizeof(ConstantPool));
 447   soc-&gt;do_tag(sizeof(ConstantPoolCache));
 448   soc-&gt;do_tag(objArrayOopDesc::base_offset_in_bytes());
 449   soc-&gt;do_tag(typeArrayOopDesc::base_offset_in_bytes(T_BYTE));
 450   soc-&gt;do_tag(sizeof(Symbol));
 451 
 452   // Dump/restore miscellaneous metadata.
 453   JavaClasses::serialize_offsets(soc);
 454   Universe::serialize(soc);
 455   soc-&gt;do_tag(--tag);
 456 
 457   // Dump/restore references to commonly used names and signatures.
 458   vmSymbols::serialize(soc);
 459   soc-&gt;do_tag(--tag);
 460 
 461   // Dump/restore the symbol/string/subgraph_info tables
 462   SymbolTable::serialize_shared_table_header(soc);
 463   StringTable::serialize_shared_table_header(soc);
 464   HeapShared::serialize_subgraph_info_table_header(soc);
 465   SystemDictionaryShared::serialize_dictionary_headers(soc);
 466 
 467   InstanceMirrorKlass::serialize_offsets(soc);
<a name="1" id="anc1"></a>


 468   soc-&gt;do_tag(--tag);
 469 
 470   serialize_cloned_cpp_vtptrs(soc);
 471   soc-&gt;do_tag(--tag);
 472 
 473   soc-&gt;do_tag(666);
 474 }
 475 
 476 address MetaspaceShared::i2i_entry_code_buffers(size_t total_size) {
 477   if (DumpSharedSpaces) {
 478     if (_i2i_entry_code_buffers == NULL) {
 479       _i2i_entry_code_buffers = (address)misc_code_space_alloc(total_size);
 480       _i2i_entry_code_buffers_size = total_size;
 481     }
 482   } else if (UseSharedSpaces) {
 483     assert(_i2i_entry_code_buffers != NULL, &quot;must already been initialized&quot;);
 484   } else {
 485     return NULL;
 486   }
 487 
 488   assert(_i2i_entry_code_buffers_size == total_size, &quot;must not change&quot;);
 489   return _i2i_entry_code_buffers;
 490 }
 491 
 492 uintx MetaspaceShared::object_delta_uintx(void* obj) {
 493   Arguments::assert_is_dumping_archive();
 494   if (DumpSharedSpaces) {
 495     assert(shared_rs()-&gt;contains(obj), &quot;must be&quot;);
 496   } else {
 497     assert(is_in_shared_metaspace(obj) || DynamicArchive::is_in_target_space(obj), &quot;must be&quot;);
 498   }
 499   address base_address = address(SharedBaseAddress);
 500   uintx deltax = address(obj) - base_address;
 501   return deltax;
 502 }
 503 
 504 // Global object for holding classes that have been loaded.  Since this
 505 // is run at a safepoint just before exit, this is the entire set of classes.
 506 static GrowableArray&lt;Klass*&gt;* _global_klass_objects;
 507 
 508 GrowableArray&lt;Klass*&gt;* MetaspaceShared::collected_klasses() {
 509   return _global_klass_objects;
 510 }
 511 
 512 static void collect_array_classes(Klass* k) {
 513   _global_klass_objects-&gt;append_if_missing(k);
 514   if (k-&gt;is_array_klass()) {
 515     // Add in the array classes too
 516     ArrayKlass* ak = ArrayKlass::cast(k);
 517     Klass* h = ak-&gt;higher_dimension();
 518     if (h != NULL) {
 519       h-&gt;array_klasses_do(collect_array_classes);
 520     }
 521   }
 522 }
 523 
 524 class CollectClassesClosure : public KlassClosure {
 525   void do_klass(Klass* k) {
 526     if (k-&gt;is_instance_klass() &amp;&amp;
 527         SystemDictionaryShared::is_excluded_class(InstanceKlass::cast(k))) {
 528       // Don&#39;t add to the _global_klass_objects
 529     } else {
 530       _global_klass_objects-&gt;append_if_missing(k);
 531     }
 532     if (k-&gt;is_array_klass()) {
 533       // Add in the array classes too
 534       ArrayKlass* ak = ArrayKlass::cast(k);
 535       Klass* h = ak-&gt;higher_dimension();
 536       if (h != NULL) {
 537         h-&gt;array_klasses_do(collect_array_classes);
 538       }
 539     }
 540   }
 541 };
 542 
 543 static void remove_unshareable_in_classes() {
 544   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 545     Klass* k = _global_klass_objects-&gt;at(i);
 546     if (!k-&gt;is_objArray_klass()) {
 547       // InstanceKlass and TypeArrayKlass will in turn call remove_unshareable_info
 548       // on their array classes.
 549       assert(k-&gt;is_instance_klass() || k-&gt;is_typeArray_klass(), &quot;must be&quot;);
 550       k-&gt;remove_unshareable_info();
 551     }
 552   }
 553 }
 554 
 555 static void remove_java_mirror_in_classes() {
 556   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 557     Klass* k = _global_klass_objects-&gt;at(i);
 558     if (!k-&gt;is_objArray_klass()) {
 559       // InstanceKlass and TypeArrayKlass will in turn call remove_unshareable_info
 560       // on their array classes.
 561       assert(k-&gt;is_instance_klass() || k-&gt;is_typeArray_klass(), &quot;must be&quot;);
 562       k-&gt;remove_java_mirror();
 563     }
 564   }
 565 }
 566 
 567 static void clear_basic_type_mirrors() {
 568   assert(!HeapShared::is_heap_object_archiving_allowed(), &quot;Sanity&quot;);
 569   Universe::set_int_mirror(NULL);
 570   Universe::set_float_mirror(NULL);
 571   Universe::set_double_mirror(NULL);
 572   Universe::set_byte_mirror(NULL);
 573   Universe::set_bool_mirror(NULL);
 574   Universe::set_char_mirror(NULL);
 575   Universe::set_long_mirror(NULL);
 576   Universe::set_short_mirror(NULL);
 577   Universe::set_void_mirror(NULL);
 578 }
 579 
 580 static void rewrite_nofast_bytecode(const methodHandle&amp; method) {
 581   BytecodeStream bcs(method);
 582   while (!bcs.is_last_bytecode()) {
 583     Bytecodes::Code opcode = bcs.next();
 584     switch (opcode) {
 585     case Bytecodes::_getfield:      *bcs.bcp() = Bytecodes::_nofast_getfield;      break;
 586     case Bytecodes::_putfield:      *bcs.bcp() = Bytecodes::_nofast_putfield;      break;
 587     case Bytecodes::_aload_0:       *bcs.bcp() = Bytecodes::_nofast_aload_0;       break;
 588     case Bytecodes::_iload: {
 589       if (!bcs.is_wide()) {
 590         *bcs.bcp() = Bytecodes::_nofast_iload;
 591       }
 592       break;
 593     }
 594     default: break;
 595     }
 596   }
 597 }
 598 
 599 // Walk all methods in the class list to ensure that they won&#39;t be modified at
 600 // run time. This includes:
 601 // [1] Rewrite all bytecodes as needed, so that the ConstMethod* will not be modified
 602 //     at run time by RewriteBytecodes/RewriteFrequentPairs
 603 // [2] Assign a fingerprint, so one doesn&#39;t need to be assigned at run-time.
 604 static void rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread* thread) {
 605   for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
 606     Klass* k = _global_klass_objects-&gt;at(i);
 607     if (k-&gt;is_instance_klass()) {
 608       InstanceKlass* ik = InstanceKlass::cast(k);
 609       MetaspaceShared::rewrite_nofast_bytecodes_and_calculate_fingerprints(thread, ik);
 610     }
 611   }
 612 }
 613 
 614 void MetaspaceShared::rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread* thread, InstanceKlass* ik) {
 615   for (int i = 0; i &lt; ik-&gt;methods()-&gt;length(); i++) {
 616     methodHandle m(thread, ik-&gt;methods()-&gt;at(i));
 617     rewrite_nofast_bytecode(m);
 618     Fingerprinter fp(m);
 619     // The side effect of this call sets method&#39;s fingerprint field.
 620     fp.fingerprint();
 621   }
 622 }
 623 
 624 // Objects of the Metadata types (such as Klass and ConstantPool) have C++ vtables.
 625 // (In GCC this is the field &lt;Type&gt;::_vptr, i.e., first word in the object.)
 626 //
 627 // Addresses of the vtables and the methods may be different across JVM runs,
 628 // if libjvm.so is dynamically loaded at a different base address.
 629 //
 630 // To ensure that the Metadata objects in the CDS archive always have the correct vtable:
 631 //
 632 // + at dump time:  we redirect the _vptr to point to our own vtables inside
 633 //                  the CDS image
 634 // + at run time:   we clone the actual contents of the vtables from libjvm.so
 635 //                  into our own tables.
 636 
 637 // Currently, the archive contain ONLY the following types of objects that have C++ vtables.
 638 #define CPP_VTABLE_PATCH_TYPES_DO(f) \
 639   f(ConstantPool) \
 640   f(InstanceClassLoaderKlass) \
 641   f(InstanceKlass) \
 642   f(InstanceMirrorKlass) \
 643   f(InstanceRefKlass) \
 644   f(Method) \
 645   f(ObjArrayKlass) \
 646   f(TypeArrayKlass) \
 647   f(ValueArrayKlass) \
 648   f(ValueKlass)
 649 
 650 class CppVtableInfo {
 651   intptr_t _vtable_size;
 652   intptr_t _cloned_vtable[1];
 653 public:
 654   static int num_slots(int vtable_size) {
 655     return 1 + vtable_size; // Need to add the space occupied by _vtable_size;
 656   }
 657   int vtable_size()           { return int(uintx(_vtable_size)); }
 658   void set_vtable_size(int n) { _vtable_size = intptr_t(n); }
 659   intptr_t* cloned_vtable()   { return &amp;_cloned_vtable[0]; }
 660   void zero()                 { memset(_cloned_vtable, 0, sizeof(intptr_t) * vtable_size()); }
 661   // Returns the address of the next CppVtableInfo that can be placed immediately after this CppVtableInfo
 662   static size_t byte_size(int vtable_size) {
 663     CppVtableInfo i;
 664     return pointer_delta(&amp;i._cloned_vtable[vtable_size], &amp;i, sizeof(u1));
 665   }
 666 };
 667 
 668 template &lt;class T&gt; class CppVtableCloner : public T {
 669   static intptr_t* vtable_of(Metadata&amp; m) {
 670     return *((intptr_t**)&amp;m);
 671   }
 672   static CppVtableInfo* _info;
 673 
 674   static int get_vtable_length(const char* name);
 675 
 676 public:
 677   // Allocate and initialize the C++ vtable, starting from top, but do not go past end.
 678   static intptr_t* allocate(const char* name);
 679 
 680   // Clone the vtable to ...
 681   static intptr_t* clone_vtable(const char* name, CppVtableInfo* info);
 682 
 683   static void zero_vtable_clone() {
 684     assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 685     _info-&gt;zero();
 686   }
 687 
 688   static bool is_valid_shared_object(const T* obj) {
 689     intptr_t* vptr = *(intptr_t**)obj;
 690     return vptr == _info-&gt;cloned_vtable();
 691   }
 692 };
 693 
 694 template &lt;class T&gt; CppVtableInfo* CppVtableCloner&lt;T&gt;::_info = NULL;
 695 
 696 template &lt;class T&gt;
 697 intptr_t* CppVtableCloner&lt;T&gt;::allocate(const char* name) {
 698   assert(is_aligned(_mc_region.top(), sizeof(intptr_t)), &quot;bad alignment&quot;);
 699   int n = get_vtable_length(name);
 700   _info = (CppVtableInfo*)_mc_region.allocate(CppVtableInfo::byte_size(n), sizeof(intptr_t));
 701   _info-&gt;set_vtable_size(n);
 702 
 703   intptr_t* p = clone_vtable(name, _info);
 704   assert((char*)p == _mc_region.top(), &quot;must be&quot;);
 705 
 706   return _info-&gt;cloned_vtable();
 707 }
 708 
 709 template &lt;class T&gt;
 710 intptr_t* CppVtableCloner&lt;T&gt;::clone_vtable(const char* name, CppVtableInfo* info) {
 711   if (!DumpSharedSpaces) {
 712     assert(_info == 0, &quot;_info is initialized only at dump time&quot;);
 713     _info = info; // Remember it -- it will be used by MetaspaceShared::is_valid_shared_method()
 714   }
 715   T tmp; // Allocate temporary dummy metadata object to get to the original vtable.
 716   int n = info-&gt;vtable_size();
 717   intptr_t* srcvtable = vtable_of(tmp);
 718   intptr_t* dstvtable = info-&gt;cloned_vtable();
 719 
 720   // We already checked (and, if necessary, adjusted n) when the vtables were allocated, so we are
 721   // safe to do memcpy.
 722   log_debug(cds, vtables)(&quot;Copying %3d vtable entries for %s&quot;, n, name);
 723   memcpy(dstvtable, srcvtable, sizeof(intptr_t) * n);
 724   return dstvtable + n;
 725 }
 726 
 727 // To determine the size of the vtable for each type, we use the following
 728 // trick by declaring 2 subclasses:
 729 //
 730 //   class CppVtableTesterA: public InstanceKlass {virtual int   last_virtual_method() {return 1;}    };
 731 //   class CppVtableTesterB: public InstanceKlass {virtual void* last_virtual_method() {return NULL}; };
 732 //
 733 // CppVtableTesterA and CppVtableTesterB&#39;s vtables have the following properties:
 734 // - Their size (N+1) is exactly one more than the size of InstanceKlass&#39;s vtable (N)
 735 // - The first N entries have are exactly the same as in InstanceKlass&#39;s vtable.
 736 // - Their last entry is different.
 737 //
 738 // So to determine the value of N, we just walk CppVtableTesterA and CppVtableTesterB&#39;s tables
 739 // and find the first entry that&#39;s different.
 740 //
 741 // This works on all C++ compilers supported by Oracle, but you may need to tweak it for more
 742 // esoteric compilers.
 743 
 744 template &lt;class T&gt; class CppVtableTesterB: public T {
 745 public:
 746   virtual int last_virtual_method() {return 1;}
 747 };
 748 
 749 template &lt;class T&gt; class CppVtableTesterA : public T {
 750 public:
 751   virtual void* last_virtual_method() {
 752     // Make this different than CppVtableTesterB::last_virtual_method so the C++
 753     // compiler/linker won&#39;t alias the two functions.
 754     return NULL;
 755   }
 756 };
 757 
 758 template &lt;class T&gt;
 759 int CppVtableCloner&lt;T&gt;::get_vtable_length(const char* name) {
 760   CppVtableTesterA&lt;T&gt; a;
 761   CppVtableTesterB&lt;T&gt; b;
 762 
 763   intptr_t* avtable = vtable_of(a);
 764   intptr_t* bvtable = vtable_of(b);
 765 
 766   // Start at slot 1, because slot 0 may be RTTI (on Solaris/Sparc)
 767   int vtable_len = 1;
 768   for (; ; vtable_len++) {
 769     if (avtable[vtable_len] != bvtable[vtable_len]) {
 770       break;
 771     }
 772   }
 773   log_debug(cds, vtables)(&quot;Found   %3d vtable entries for %s&quot;, vtable_len, name);
 774 
 775   return vtable_len;
 776 }
 777 
 778 #define ALLOC_CPP_VTABLE_CLONE(c) \
 779   _cloned_cpp_vtptrs[c##_Kind] = CppVtableCloner&lt;c&gt;::allocate(#c); \
 780   ArchivePtrMarker::mark_pointer(&amp;_cloned_cpp_vtptrs[c##_Kind]);
 781 
 782 #define CLONE_CPP_VTABLE(c) \
 783   p = CppVtableCloner&lt;c&gt;::clone_vtable(#c, (CppVtableInfo*)p);
 784 
 785 #define ZERO_CPP_VTABLE(c) \
 786  CppVtableCloner&lt;c&gt;::zero_vtable_clone();
 787 
 788 //------------------------------ for DynamicDumpSharedSpaces - start
 789 #define DECLARE_CLONED_VTABLE_KIND(c) c ## _Kind,
 790 
 791 enum {
 792   // E.g., ConstantPool_Kind == 0, InstanceKlass == 1, etc.
 793   CPP_VTABLE_PATCH_TYPES_DO(DECLARE_CLONED_VTABLE_KIND)
 794   _num_cloned_vtable_kinds
 795 };
 796 
 797 // This is the index of all the cloned vtables. E.g., for
 798 //     ConstantPool* cp = ....; // an archived constant pool
 799 //     InstanceKlass* ik = ....;// an archived class
 800 // the following holds true:
 801 //     _cloned_cpp_vtptrs[ConstantPool_Kind]  == ((intptr_t**)cp)[0]
 802 //     _cloned_cpp_vtptrs[InstanceKlass_Kind] == ((intptr_t**)ik)[0]
 803 static intptr_t** _cloned_cpp_vtptrs = NULL;
 804 
 805 void MetaspaceShared::allocate_cloned_cpp_vtptrs() {
 806   assert(DumpSharedSpaces, &quot;must&quot;);
 807   size_t vtptrs_bytes = _num_cloned_vtable_kinds * sizeof(intptr_t*);
 808   _cloned_cpp_vtptrs = (intptr_t**)_mc_region.allocate(vtptrs_bytes, sizeof(intptr_t*));
 809 }
 810 
 811 void MetaspaceShared::serialize_cloned_cpp_vtptrs(SerializeClosure* soc) {
 812   soc-&gt;do_ptr((void**)&amp;_cloned_cpp_vtptrs);
 813 }
 814 
 815 intptr_t* MetaspaceShared::fix_cpp_vtable_for_dynamic_archive(MetaspaceObj::Type msotype, address obj) {
 816   Arguments::assert_is_dumping_archive();
 817   int kind = -1;
 818   switch (msotype) {
 819   case MetaspaceObj::SymbolType:
 820   case MetaspaceObj::TypeArrayU1Type:
 821   case MetaspaceObj::TypeArrayU2Type:
 822   case MetaspaceObj::TypeArrayU4Type:
 823   case MetaspaceObj::TypeArrayU8Type:
 824   case MetaspaceObj::TypeArrayOtherType:
 825   case MetaspaceObj::ConstMethodType:
 826   case MetaspaceObj::ConstantPoolCacheType:
 827   case MetaspaceObj::AnnotationsType:
 828   case MetaspaceObj::MethodCountersType:
 829   case MetaspaceObj::RecordComponentType:
 830     // These have no vtables.
 831     break;
 832   case MetaspaceObj::ClassType:
 833     {
 834       Klass* k = (Klass*)obj;
 835       assert(k-&gt;is_klass(), &quot;must be&quot;);
 836       if (k-&gt;is_value()) {
 837         kind = ValueKlass_Kind;
 838       } else if (k-&gt;is_instance_klass()) {
 839         InstanceKlass* ik = InstanceKlass::cast(k);
 840         if (ik-&gt;is_class_loader_instance_klass()) {
 841           kind = InstanceClassLoaderKlass_Kind;
 842         } else if (ik-&gt;is_reference_instance_klass()) {
 843           kind = InstanceRefKlass_Kind;
 844         } else if (ik-&gt;is_mirror_instance_klass()) {
 845           kind = InstanceMirrorKlass_Kind;
 846         } else {
 847           kind = InstanceKlass_Kind;
 848         }
 849       } else if (k-&gt;is_typeArray_klass()) {
 850         kind = TypeArrayKlass_Kind;
 851       } else {
 852         assert(k-&gt;is_objArray_klass(), &quot;must be&quot;);
 853         kind = ObjArrayKlass_Kind;
 854       }
 855     }
 856     break;
 857 
 858   case MetaspaceObj::MethodType:
 859     {
 860       Method* m = (Method*)obj;
 861       assert(m-&gt;is_method(), &quot;must be&quot;);
 862       kind = Method_Kind;
 863     }
 864     break;
 865 
 866   case MetaspaceObj::MethodDataType:
 867     // We don&#39;t archive MethodData &lt;-- should have been removed in removed_unsharable_info
 868     ShouldNotReachHere();
 869     break;
 870 
 871   case MetaspaceObj::ConstantPoolType:
 872     {
 873       ConstantPool *cp = (ConstantPool*)obj;
 874       assert(cp-&gt;is_constantPool(), &quot;must be&quot;);
 875       kind = ConstantPool_Kind;
 876     }
 877     break;
 878 
 879   default:
 880     ShouldNotReachHere();
 881   }
 882 
 883   if (kind &gt;= 0) {
 884     assert(kind &lt; _num_cloned_vtable_kinds, &quot;must be&quot;);
 885     return _cloned_cpp_vtptrs[kind];
 886   } else {
 887     return NULL;
 888   }
 889 }
 890 
 891 //------------------------------ for DynamicDumpSharedSpaces - end
 892 
 893 // This can be called at both dump time and run time:
 894 // - clone the contents of the c++ vtables into the space
 895 //   allocated by allocate_cpp_vtable_clones()
 896 void MetaspaceShared::clone_cpp_vtables(intptr_t* p) {
 897   assert(DumpSharedSpaces || UseSharedSpaces, &quot;sanity&quot;);
 898   CPP_VTABLE_PATCH_TYPES_DO(CLONE_CPP_VTABLE);
 899 }
 900 
 901 void MetaspaceShared::zero_cpp_vtable_clones_for_writing() {
 902   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 903   CPP_VTABLE_PATCH_TYPES_DO(ZERO_CPP_VTABLE);
 904 }
 905 
 906 // Allocate and initialize the C++ vtables, starting from top, but do not go past end.
 907 char* MetaspaceShared::allocate_cpp_vtable_clones() {
 908   char* cloned_vtables = _mc_region.top(); // This is the beginning of all the cloned vtables
 909 
 910   assert(DumpSharedSpaces, &quot;dump-time only&quot;);
 911   // Layout (each slot is a intptr_t):
 912   //   [number of slots in the first vtable = n1]
 913   //   [ &lt;n1&gt; slots for the first vtable]
 914   //   [number of slots in the first second = n2]
 915   //   [ &lt;n2&gt; slots for the second vtable]
 916   //   ...
 917   // The order of the vtables is the same as the CPP_VTAB_PATCH_TYPES_DO macro.
 918   CPP_VTABLE_PATCH_TYPES_DO(ALLOC_CPP_VTABLE_CLONE);
 919 
 920   return cloned_vtables;
 921 }
 922 
 923 bool MetaspaceShared::is_valid_shared_method(const Method* m) {
 924   assert(is_in_shared_metaspace(m), &quot;must be&quot;);
 925   return CppVtableCloner&lt;Method&gt;::is_valid_shared_object(m);
 926 }
 927 
 928 void WriteClosure::do_oop(oop* o) {
 929   if (*o == NULL) {
 930     _dump_region-&gt;append_intptr_t(0);
 931   } else {
 932     assert(HeapShared::is_heap_object_archiving_allowed(),
 933            &quot;Archiving heap object is not allowed&quot;);
 934     _dump_region-&gt;append_intptr_t(
 935       (intptr_t)CompressedOops::encode_not_null(*o));
 936   }
 937 }
 938 
 939 void WriteClosure::do_region(u_char* start, size_t size) {
 940   assert((intptr_t)start % sizeof(intptr_t) == 0, &quot;bad alignment&quot;);
 941   assert(size % sizeof(intptr_t) == 0, &quot;bad size&quot;);
 942   do_tag((int)size);
 943   while (size &gt; 0) {
 944     _dump_region-&gt;append_intptr_t(*(intptr_t*)start, true);
 945     start += sizeof(intptr_t);
 946     size -= sizeof(intptr_t);
 947   }
 948 }
 949 
 950 // This is for dumping detailed statistics for the allocations
 951 // in the shared spaces.
 952 class DumpAllocStats : public ResourceObj {
 953 public:
 954 
 955   // Here&#39;s poor man&#39;s enum inheritance
 956 #define SHAREDSPACE_OBJ_TYPES_DO(f) \
 957   METASPACE_OBJ_TYPES_DO(f) \
 958   f(SymbolHashentry) \
 959   f(SymbolBucket) \
 960   f(StringHashentry) \
 961   f(StringBucket) \
 962   f(Other)
 963 
 964   enum Type {
 965     // Types are MetaspaceObj::ClassType, MetaspaceObj::SymbolType, etc
 966     SHAREDSPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_DECLARE)
 967     _number_of_types
 968   };
 969 
 970   static const char * type_name(Type type) {
 971     switch(type) {
 972     SHAREDSPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_NAME_CASE)
 973     default:
 974       ShouldNotReachHere();
 975       return NULL;
 976     }
 977   }
 978 
 979 public:
 980   enum { RO = 0, RW = 1 };
 981 
 982   int _counts[2][_number_of_types];
 983   int _bytes [2][_number_of_types];
 984 
 985   DumpAllocStats() {
 986     memset(_counts, 0, sizeof(_counts));
 987     memset(_bytes,  0, sizeof(_bytes));
 988   };
 989 
 990   void record(MetaspaceObj::Type type, int byte_size, bool read_only) {
 991     assert(int(type) &gt;= 0 &amp;&amp; type &lt; MetaspaceObj::_number_of_types, &quot;sanity&quot;);
 992     int which = (read_only) ? RO : RW;
 993     _counts[which][type] ++;
 994     _bytes [which][type] += byte_size;
 995   }
 996 
 997   void record_other_type(int byte_size, bool read_only) {
 998     int which = (read_only) ? RO : RW;
 999     _bytes [which][OtherType] += byte_size;
1000   }
1001   void print_stats(int ro_all, int rw_all, int mc_all);
1002 };
1003 
1004 void DumpAllocStats::print_stats(int ro_all, int rw_all, int mc_all) {
1005   // Calculate size of data that was not allocated by Metaspace::allocate()
1006   MetaspaceSharedStats *stats = MetaspaceShared::stats();
1007 
1008   // symbols
1009   _counts[RO][SymbolHashentryType] = stats-&gt;symbol.hashentry_count;
1010   _bytes [RO][SymbolHashentryType] = stats-&gt;symbol.hashentry_bytes;
1011 
1012   _counts[RO][SymbolBucketType] = stats-&gt;symbol.bucket_count;
1013   _bytes [RO][SymbolBucketType] = stats-&gt;symbol.bucket_bytes;
1014 
1015   // strings
1016   _counts[RO][StringHashentryType] = stats-&gt;string.hashentry_count;
1017   _bytes [RO][StringHashentryType] = stats-&gt;string.hashentry_bytes;
1018 
1019   _counts[RO][StringBucketType] = stats-&gt;string.bucket_count;
1020   _bytes [RO][StringBucketType] = stats-&gt;string.bucket_bytes;
1021 
1022   // TODO: count things like dictionary, vtable, etc
1023   _bytes[RW][OtherType] += mc_all;
1024   rw_all += mc_all; // mc is mapped Read/Write
1025 
1026   // prevent divide-by-zero
1027   if (ro_all &lt; 1) {
1028     ro_all = 1;
1029   }
1030   if (rw_all &lt; 1) {
1031     rw_all = 1;
1032   }
1033 
1034   int all_ro_count = 0;
1035   int all_ro_bytes = 0;
1036   int all_rw_count = 0;
1037   int all_rw_bytes = 0;
1038 
1039 // To make fmt_stats be a syntactic constant (for format warnings), use #define.
1040 #define fmt_stats &quot;%-20s: %8d %10d %5.1f | %8d %10d %5.1f | %8d %10d %5.1f&quot;
1041   const char *sep = &quot;--------------------+---------------------------+---------------------------+--------------------------&quot;;
1042   const char *hdr = &quot;                        ro_cnt   ro_bytes     % |   rw_cnt   rw_bytes     % |  all_cnt  all_bytes     %&quot;;
1043 
1044   LogMessage(cds) msg;
1045 
1046   msg.debug(&quot;Detailed metadata info (excluding st regions; rw stats include mc regions):&quot;);
1047   msg.debug(&quot;%s&quot;, hdr);
1048   msg.debug(&quot;%s&quot;, sep);
1049   for (int type = 0; type &lt; int(_number_of_types); type ++) {
1050     const char *name = type_name((Type)type);
1051     int ro_count = _counts[RO][type];
1052     int ro_bytes = _bytes [RO][type];
1053     int rw_count = _counts[RW][type];
1054     int rw_bytes = _bytes [RW][type];
1055     int count = ro_count + rw_count;
1056     int bytes = ro_bytes + rw_bytes;
1057 
1058     double ro_perc = percent_of(ro_bytes, ro_all);
1059     double rw_perc = percent_of(rw_bytes, rw_all);
1060     double perc    = percent_of(bytes, ro_all + rw_all);
1061 
1062     msg.debug(fmt_stats, name,
1063                          ro_count, ro_bytes, ro_perc,
1064                          rw_count, rw_bytes, rw_perc,
1065                          count, bytes, perc);
1066 
1067     all_ro_count += ro_count;
1068     all_ro_bytes += ro_bytes;
1069     all_rw_count += rw_count;
1070     all_rw_bytes += rw_bytes;
1071   }
1072 
1073   int all_count = all_ro_count + all_rw_count;
1074   int all_bytes = all_ro_bytes + all_rw_bytes;
1075 
1076   double all_ro_perc = percent_of(all_ro_bytes, ro_all);
1077   double all_rw_perc = percent_of(all_rw_bytes, rw_all);
1078   double all_perc    = percent_of(all_bytes, ro_all + rw_all);
1079 
1080   msg.debug(&quot;%s&quot;, sep);
1081   msg.debug(fmt_stats, &quot;Total&quot;,
1082                        all_ro_count, all_ro_bytes, all_ro_perc,
1083                        all_rw_count, all_rw_bytes, all_rw_perc,
1084                        all_count, all_bytes, all_perc);
1085 
1086   assert(all_ro_bytes == ro_all, &quot;everything should have been counted&quot;);
1087   assert(all_rw_bytes == rw_all, &quot;everything should have been counted&quot;);
1088 
1089 #undef fmt_stats
1090 }
1091 
1092 // Populate the shared space.
1093 
1094 class VM_PopulateDumpSharedSpace: public VM_Operation {
1095 private:
1096   GrowableArray&lt;MemRegion&gt; *_closed_archive_heap_regions;
1097   GrowableArray&lt;MemRegion&gt; *_open_archive_heap_regions;
1098 
1099   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_closed_archive_heap_oopmaps;
1100   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_open_archive_heap_oopmaps;
1101 
1102   void dump_java_heap_objects() NOT_CDS_JAVA_HEAP_RETURN;
1103   void dump_archive_heap_oopmaps() NOT_CDS_JAVA_HEAP_RETURN;
1104   void dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1105                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps);
1106   void dump_symbols();
1107   char* dump_read_only_tables();
1108   void print_class_stats();
<a name="2" id="anc2"></a><span class="line-modified">1109   void print_region_stats();</span>
1110   void print_bitmap_region_stats(size_t size, size_t total_size);
1111   void print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
1112                                const char *name, size_t total_size);
1113   void relocate_to_default_base_address(CHeapBitMap* ptrmap);
1114 
1115 public:
1116 
1117   VMOp_Type type() const { return VMOp_PopulateDumpSharedSpace; }
1118   void doit();   // outline because gdb sucks
1119   bool allow_nested_vm_operations() const { return true; }
1120 }; // class VM_PopulateDumpSharedSpace
1121 
1122 class SortedSymbolClosure: public SymbolClosure {
1123   GrowableArray&lt;Symbol*&gt; _symbols;
1124   virtual void do_symbol(Symbol** sym) {
1125     assert((*sym)-&gt;is_permanent(), &quot;archived symbols must be permanent&quot;);
1126     _symbols.append(*sym);
1127   }
1128   static int compare_symbols_by_address(Symbol** a, Symbol** b) {
1129     if (a[0] &lt; b[0]) {
1130       return -1;
1131     } else if (a[0] == b[0]) {
1132       return 0;
1133     } else {
1134       return 1;
1135     }
1136   }
1137 
1138 public:
1139   SortedSymbolClosure() {
1140     SymbolTable::symbols_do(this);
1141     _symbols.sort(compare_symbols_by_address);
1142   }
1143   GrowableArray&lt;Symbol*&gt;* get_sorted_symbols() {
1144     return &amp;_symbols;
1145   }
1146 };
1147 
1148 // ArchiveCompactor --
1149 //
1150 // This class is the central piece of shared archive compaction -- all metaspace data are
1151 // initially allocated outside of the shared regions. ArchiveCompactor copies the
1152 // metaspace data into their final location in the shared regions.
1153 
1154 class ArchiveCompactor : AllStatic {
1155   static const int INITIAL_TABLE_SIZE = 8087;
1156   static const int MAX_TABLE_SIZE     = 1000000;
1157 
1158   static DumpAllocStats* _alloc_stats;
1159   static SortedSymbolClosure* _ssc;
1160 
1161   typedef KVHashtable&lt;address, address, mtInternal&gt; RelocationTable;
1162   static RelocationTable* _new_loc_table;
1163 
1164 public:
1165   static void initialize() {
1166     _alloc_stats = new(ResourceObj::C_HEAP, mtInternal)DumpAllocStats;
1167     _new_loc_table = new RelocationTable(INITIAL_TABLE_SIZE);
1168   }
1169   static DumpAllocStats* alloc_stats() {
1170     return _alloc_stats;
1171   }
1172 
1173   // Use this when you allocate space with MetaspaceShare::read_only_space_alloc()
1174   // outside of ArchiveCompactor::allocate(). These are usually for misc tables
1175   // that are allocated in the RO space.
1176   class OtherROAllocMark {
1177     char* _oldtop;
1178   public:
1179     OtherROAllocMark() {
1180       _oldtop = _ro_region.top();
1181     }
1182     ~OtherROAllocMark() {
1183       char* newtop = _ro_region.top();
1184       ArchiveCompactor::alloc_stats()-&gt;record_other_type(int(newtop - _oldtop), true);
1185     }
1186   };
1187 
1188   static void allocate(MetaspaceClosure::Ref* ref, bool read_only) {
1189     address obj = ref-&gt;obj();
1190     int bytes = ref-&gt;size() * BytesPerWord;
1191     char* p;
1192     size_t alignment = BytesPerWord;
1193     char* oldtop;
1194     char* newtop;
1195 
1196     if (read_only) {
1197       oldtop = _ro_region.top();
1198       p = _ro_region.allocate(bytes, alignment);
1199       newtop = _ro_region.top();
1200     } else {
1201       oldtop = _rw_region.top();
1202       if (ref-&gt;msotype() == MetaspaceObj::ClassType) {
1203         // Save a pointer immediate in front of an InstanceKlass, so
1204         // we can do a quick lookup from InstanceKlass* -&gt; RunTimeSharedClassInfo*
1205         // without building another hashtable. See RunTimeSharedClassInfo::get_for()
1206         // in systemDictionaryShared.cpp.
1207         Klass* klass = (Klass*)obj;
1208         if (klass-&gt;is_instance_klass()) {
1209           SystemDictionaryShared::validate_before_archiving(InstanceKlass::cast(klass));
1210           _rw_region.allocate(sizeof(address), BytesPerWord);
1211         }
1212       }
1213       p = _rw_region.allocate(bytes, alignment);
1214       newtop = _rw_region.top();
1215     }
1216     memcpy(p, obj, bytes);
1217 
1218     intptr_t* cloned_vtable = MetaspaceShared::fix_cpp_vtable_for_dynamic_archive(ref-&gt;msotype(), (address)p);
1219     if (cloned_vtable != NULL) {
1220       *(address*)p = (address)cloned_vtable;
1221       ArchivePtrMarker::mark_pointer((address*)p);
1222     }
1223 
1224     assert(_new_loc_table-&gt;lookup(obj) == NULL, &quot;each object can be relocated at most once&quot;);
1225     _new_loc_table-&gt;add(obj, (address)p);
1226     log_trace(cds)(&quot;Copy: &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT &quot; %d&quot;, p2i(obj), p2i(p), bytes);
1227     if (_new_loc_table-&gt;maybe_grow(MAX_TABLE_SIZE)) {
1228       log_info(cds, hashtables)(&quot;Expanded _new_loc_table to %d&quot;, _new_loc_table-&gt;table_size());
1229     }
1230     _alloc_stats-&gt;record(ref-&gt;msotype(), int(newtop - oldtop), read_only);
1231   }
1232 
1233   static address get_new_loc(MetaspaceClosure::Ref* ref) {
1234     address* pp = _new_loc_table-&gt;lookup(ref-&gt;obj());
1235     assert(pp != NULL, &quot;must be&quot;);
1236     return *pp;
1237   }
1238 
1239 private:
1240   // Makes a shallow copy of visited MetaspaceObj&#39;s
1241   class ShallowCopier: public UniqueMetaspaceClosure {
1242     bool _read_only;
1243   public:
1244     ShallowCopier(bool read_only) : _read_only(read_only) {}
1245 
1246     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1247       if (read_only == _read_only) {
1248         allocate(ref, read_only);
1249       }
1250       return true; // recurse into ref.obj()
1251     }
1252   };
1253 
1254   // Relocate embedded pointers within a MetaspaceObj&#39;s shallow copy
1255   class ShallowCopyEmbeddedRefRelocator: public UniqueMetaspaceClosure {
1256   public:
1257     virtual bool do_unique_ref(Ref* ref, bool read_only) {
1258       address new_loc = get_new_loc(ref);
1259       RefRelocator refer;
1260       ref-&gt;metaspace_pointers_do_at(&amp;refer, new_loc);
1261       return true; // recurse into ref.obj()
1262     }
1263     virtual void push_special(SpecialRef type, Ref* ref, intptr_t* p) {
1264       assert_valid(type);
1265 
1266       address obj = ref-&gt;obj();
1267       address new_obj = get_new_loc(ref);
1268       size_t offset = pointer_delta(p, obj,  sizeof(u1));
1269       intptr_t* new_p = (intptr_t*)(new_obj + offset);
1270       switch (type) {
1271       case _method_entry_ref:
1272         assert(*p == *new_p, &quot;must be a copy&quot;);
1273         break;
1274       case _internal_pointer_ref:
1275         {
1276           size_t off = pointer_delta(*((address*)p), obj, sizeof(u1));
1277           assert(0 &lt;= intx(off) &amp;&amp; intx(off) &lt; ref-&gt;size() * BytesPerWord, &quot;must point to internal address&quot;);
1278           *((address*)new_p) = new_obj + off;
1279         }
1280         break;
1281       default:
1282         ShouldNotReachHere();
1283       }
1284       ArchivePtrMarker::mark_pointer((address*)new_p);
1285     }
1286   };
1287 
1288   // Relocate a reference to point to its shallow copy
1289   class RefRelocator: public MetaspaceClosure {
1290   public:
1291     virtual bool do_ref(Ref* ref, bool read_only) {
1292       if (ref-&gt;not_null()) {
1293         ref-&gt;update(get_new_loc(ref));
1294         ArchivePtrMarker::mark_pointer(ref-&gt;addr());
1295       }
1296       return false; // Do not recurse.
1297     }
1298   };
1299 
1300 #ifdef ASSERT
1301   class IsRefInArchiveChecker: public MetaspaceClosure {
1302   public:
1303     virtual bool do_ref(Ref* ref, bool read_only) {
1304       if (ref-&gt;not_null()) {
1305         char* obj = (char*)ref-&gt;obj();
1306         assert(_ro_region.contains(obj) || _rw_region.contains(obj),
1307                &quot;must be relocated to point to CDS archive&quot;);
1308       }
1309       return false; // Do not recurse.
1310     }
1311   };
1312 #endif
1313 
1314 public:
1315   static void copy_and_compact() {
1316     ResourceMark rm;
1317     SortedSymbolClosure the_ssc; // StackObj
1318     _ssc = &amp;the_ssc;
1319 
1320     log_info(cds)(&quot;Scanning all metaspace objects ... &quot;);
1321     {
1322       // allocate and shallow-copy RW objects, immediately following the MC region
1323       log_info(cds)(&quot;Allocating RW objects ... &quot;);
1324       _mc_region.pack(&amp;_rw_region);
1325 
1326       ResourceMark rm;
1327       ShallowCopier rw_copier(false);
1328       iterate_roots(&amp;rw_copier);
1329     }
1330     {
1331       // allocate and shallow-copy of RO object, immediately following the RW region
1332       log_info(cds)(&quot;Allocating RO objects ... &quot;);
1333       _rw_region.pack(&amp;_ro_region);
1334 
1335       ResourceMark rm;
1336       ShallowCopier ro_copier(true);
1337       iterate_roots(&amp;ro_copier);
1338     }
1339     {
1340       log_info(cds)(&quot;Relocating embedded pointers ... &quot;);
1341       ResourceMark rm;
1342       ShallowCopyEmbeddedRefRelocator emb_reloc;
1343       iterate_roots(&amp;emb_reloc);
1344     }
1345     {
1346       log_info(cds)(&quot;Relocating external roots ... &quot;);
1347       ResourceMark rm;
1348       RefRelocator ext_reloc;
1349       iterate_roots(&amp;ext_reloc);
1350     }
1351 
1352 #ifdef ASSERT
1353     {
1354       log_info(cds)(&quot;Verifying external roots ... &quot;);
1355       ResourceMark rm;
1356       IsRefInArchiveChecker checker;
1357       iterate_roots(&amp;checker);
1358     }
1359 #endif
1360 
1361 
1362     // cleanup
1363     _ssc = NULL;
1364   }
1365 
1366   // We must relocate the System::_well_known_klasses only after we have copied the
1367   // java objects in during dump_java_heap_objects(): during the object copy, we operate on
1368   // old objects which assert that their klass is the original klass.
1369   static void relocate_well_known_klasses() {
1370     {
1371       log_info(cds)(&quot;Relocating SystemDictionary::_well_known_klasses[] ... &quot;);
1372       ResourceMark rm;
1373       RefRelocator ext_reloc;
1374       SystemDictionary::well_known_klasses_do(&amp;ext_reloc);
1375     }
1376     // NOTE: after this point, we shouldn&#39;t have any globals that can reach the old
1377     // objects.
1378 
1379     // We cannot use any of the objects in the heap anymore (except for the
1380     // shared strings) because their headers no longer point to valid Klasses.
1381   }
1382 
1383   static void iterate_roots(MetaspaceClosure* it) {
1384     GrowableArray&lt;Symbol*&gt;* symbols = _ssc-&gt;get_sorted_symbols();
1385     for (int i=0; i&lt;symbols-&gt;length(); i++) {
1386       it-&gt;push(symbols-&gt;adr_at(i));
1387     }
1388     if (_global_klass_objects != NULL) {
1389       // Need to fix up the pointers
1390       for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1391         // NOTE -- this requires that the vtable is NOT yet patched, or else we are hosed.
1392         it-&gt;push(_global_klass_objects-&gt;adr_at(i));
1393       }
1394     }
<a name="3" id="anc3"></a><span class="line-modified">1395     FileMapInfo::metaspace_pointers_do(it);</span>
1396     SystemDictionaryShared::dumptime_classes_do(it);
1397     Universe::metaspace_pointers_do(it);
1398     SymbolTable::metaspace_pointers_do(it);
1399     vmSymbols::metaspace_pointers_do(it);
1400 
1401     it-&gt;finish();
1402   }
1403 
1404   static Klass* get_relocated_klass(Klass* orig_klass) {
1405     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1406     address* pp = _new_loc_table-&gt;lookup((address)orig_klass);
1407     assert(pp != NULL, &quot;must be&quot;);
1408     Klass* klass = (Klass*)(*pp);
1409     assert(klass-&gt;is_klass(), &quot;must be&quot;);
1410     return klass;
1411   }
1412 };
1413 
1414 DumpAllocStats* ArchiveCompactor::_alloc_stats;
1415 SortedSymbolClosure* ArchiveCompactor::_ssc;
1416 ArchiveCompactor::RelocationTable* ArchiveCompactor::_new_loc_table;
1417 
1418 void VM_PopulateDumpSharedSpace::dump_symbols() {
1419   log_info(cds)(&quot;Dumping symbol table ...&quot;);
1420 
1421   NOT_PRODUCT(SymbolTable::verify());
1422   SymbolTable::write_to_archive();
1423 }
1424 
1425 char* VM_PopulateDumpSharedSpace::dump_read_only_tables() {
1426   ArchiveCompactor::OtherROAllocMark mark;
1427 
1428   log_info(cds)(&quot;Removing java_mirror ... &quot;);
1429   if (!HeapShared::is_heap_object_archiving_allowed()) {
1430     clear_basic_type_mirrors();
1431   }
1432   remove_java_mirror_in_classes();
1433   log_info(cds)(&quot;done. &quot;);
1434 
1435   SystemDictionaryShared::write_to_archive();
1436 
1437   // Write the other data to the output array.
1438   char* start = _ro_region.top();
1439   WriteClosure wc(&amp;_ro_region);
1440   MetaspaceShared::serialize(&amp;wc);
1441 
1442   // Write the bitmaps for patching the archive heap regions
<a name="4" id="anc4"></a>

1443   dump_archive_heap_oopmaps();
1444 
1445   return start;
1446 }
1447 
1448 void VM_PopulateDumpSharedSpace::print_class_stats() {
1449   log_info(cds)(&quot;Number of classes %d&quot;, _global_klass_objects-&gt;length());
1450   {
1451     int num_type_array = 0, num_obj_array = 0, num_inst = 0;
1452     for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1453       Klass* k = _global_klass_objects-&gt;at(i);
1454       if (k-&gt;is_instance_klass()) {
1455         num_inst ++;
1456       } else if (k-&gt;is_objArray_klass()) {
1457         num_obj_array ++;
1458       } else {
1459         assert(k-&gt;is_typeArray_klass(), &quot;sanity&quot;);
1460         num_type_array ++;
1461       }
1462     }
1463     log_info(cds)(&quot;    instance classes   = %5d&quot;, num_inst);
1464     log_info(cds)(&quot;    obj array classes  = %5d&quot;, num_obj_array);
1465     log_info(cds)(&quot;    type array classes = %5d&quot;, num_type_array);
1466   }
1467 }
1468 
1469 void VM_PopulateDumpSharedSpace::relocate_to_default_base_address(CHeapBitMap* ptrmap) {
1470   intx addr_delta = MetaspaceShared::final_delta();
1471   if (addr_delta == 0) {
1472     ArchivePtrMarker::compact((address)SharedBaseAddress, (address)_ro_region.top());
1473   } else {
1474     // We are not able to reserve space at Arguments::default_SharedBaseAddress() (due to ASLR).
1475     // This means that the current content of the archive is based on a random
1476     // address. Let&#39;s relocate all the pointers, so that it can be mapped to
1477     // Arguments::default_SharedBaseAddress() without runtime relocation.
1478     //
1479     // Note: both the base and dynamic archive are written with
1480     // FileMapHeader::_shared_base_address == Arguments::default_SharedBaseAddress()
1481 
1482     // Patch all pointers that are marked by ptrmap within this region,
1483     // where we have just dumped all the metaspace data.
1484     address patch_base = (address)SharedBaseAddress;
1485     address patch_end  = (address)_ro_region.top();
1486     size_t size = patch_end - patch_base;
1487 
1488     // the current value of the pointers to be patched must be within this
1489     // range (i.e., must point to valid metaspace objects)
1490     address valid_old_base = patch_base;
1491     address valid_old_end  = patch_end;
1492 
1493     // after patching, the pointers must point inside this range
1494     // (the requested location of the archive, as mapped at runtime).
1495     address valid_new_base = (address)Arguments::default_SharedBaseAddress();
1496     address valid_new_end  = valid_new_base + size;
1497 
1498     log_debug(cds)(&quot;Relocating archive from [&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot; ] to &quot;
1499                    &quot;[&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot; ]&quot;, p2i(patch_base), p2i(patch_end),
1500                    p2i(valid_new_base), p2i(valid_new_end));
1501 
1502     SharedDataRelocator&lt;true&gt; patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,
1503                                       valid_new_base, valid_new_end, addr_delta, ptrmap);
1504     ptrmap-&gt;iterate(&amp;patcher);
1505     ArchivePtrMarker::compact(patcher.max_non_null_offset());
1506   }
1507 }
1508 
1509 void VM_PopulateDumpSharedSpace::doit() {
1510   CHeapBitMap ptrmap;
1511   MetaspaceShared::initialize_ptr_marker(&amp;ptrmap);
1512 
1513   // We should no longer allocate anything from the metaspace, so that:
1514   //
1515   // (1) Metaspace::allocate might trigger GC if we have run out of
1516   //     committed metaspace, but we can&#39;t GC because we&#39;re running
1517   //     in the VM thread.
1518   // (2) ArchiveCompactor needs to work with a stable set of MetaspaceObjs.
1519   Metaspace::freeze();
1520   DEBUG_ONLY(SystemDictionaryShared::NoClassLoadingMark nclm);
1521 
1522   Thread* THREAD = VMThread::vm_thread();
1523 
1524   FileMapInfo::check_nonempty_dir_in_shared_path_table();
1525 
1526   NOT_PRODUCT(SystemDictionary::verify();)
1527   // The following guarantee is meant to ensure that no loader constraints
1528   // exist yet, since the constraints table is not shared.  This becomes
1529   // more important now that we don&#39;t re-initialize vtables/itables for
1530   // shared classes at runtime, where constraints were previously created.
1531   guarantee(SystemDictionary::constraints()-&gt;number_of_entries() == 0,
1532             &quot;loader constraints are not saved&quot;);
1533   guarantee(SystemDictionary::placeholders()-&gt;number_of_entries() == 0,
1534           &quot;placeholders are not saved&quot;);
1535 
1536   // At this point, many classes have been loaded.
1537   // Gather systemDictionary classes in a global array and do everything to
1538   // that so we don&#39;t have to walk the SystemDictionary again.
1539   SystemDictionaryShared::check_excluded_classes();
1540   _global_klass_objects = new GrowableArray&lt;Klass*&gt;(1000);
1541   CollectClassesClosure collect_classes;
1542   ClassLoaderDataGraph::loaded_classes_do(&amp;collect_classes);
1543 
1544   print_class_stats();
1545 
1546   // Ensure the ConstMethods won&#39;t be modified at run-time
1547   log_info(cds)(&quot;Updating ConstMethods ... &quot;);
1548   rewrite_nofast_bytecodes_and_calculate_fingerprints(THREAD);
1549   log_info(cds)(&quot;done. &quot;);
1550 
1551   // Remove all references outside the metadata
1552   log_info(cds)(&quot;Removing unshareable information ... &quot;);
1553   remove_unshareable_in_classes();
1554   log_info(cds)(&quot;done. &quot;);
1555 
1556   MetaspaceShared::allocate_cloned_cpp_vtptrs();
1557   char* cloned_vtables = _mc_region.top();
1558   MetaspaceShared::allocate_cpp_vtable_clones();
1559 
1560   ArchiveCompactor::initialize();
1561   ArchiveCompactor::copy_and_compact();
1562 
1563   dump_symbols();
1564 
1565   // Dump supported java heap objects
1566   _closed_archive_heap_regions = NULL;
1567   _open_archive_heap_regions = NULL;
1568   dump_java_heap_objects();
1569 
1570   ArchiveCompactor::relocate_well_known_klasses();
1571 
1572   char* serialized_data = dump_read_only_tables();
1573   _ro_region.pack();
1574 
1575   // The vtable clones contain addresses of the current process.
1576   // We don&#39;t want to write these addresses into the archive.
1577   MetaspaceShared::zero_cpp_vtable_clones_for_writing();
1578 
1579   // relocate the data so that it can be mapped to Arguments::default_SharedBaseAddress()
1580   // without runtime relocation.
1581   relocate_to_default_base_address(&amp;ptrmap);
1582 
1583   // Create and write the archive file that maps the shared spaces.
1584 
1585   FileMapInfo* mapinfo = new FileMapInfo(true);
1586   mapinfo-&gt;populate_header(os::vm_allocation_granularity());
1587   mapinfo-&gt;set_serialized_data(serialized_data);
1588   mapinfo-&gt;set_cloned_vtables(cloned_vtables);
1589   mapinfo-&gt;set_i2i_entry_code_buffers(MetaspaceShared::i2i_entry_code_buffers(),
1590                                       MetaspaceShared::i2i_entry_code_buffers_size());
1591   mapinfo-&gt;open_for_write();
<a name="5" id="anc5"></a><span class="line-modified">1592   MetaspaceShared::write_core_archive_regions(mapinfo);</span>
1593   _total_closed_archive_region_size = mapinfo-&gt;write_archive_heap_regions(
1594                                         _closed_archive_heap_regions,
1595                                         _closed_archive_heap_oopmaps,
1596                                         MetaspaceShared::first_closed_archive_heap_region,
1597                                         MetaspaceShared::max_closed_archive_heap_region);
1598   _total_open_archive_region_size = mapinfo-&gt;write_archive_heap_regions(
1599                                         _open_archive_heap_regions,
1600                                         _open_archive_heap_oopmaps,
1601                                         MetaspaceShared::first_open_archive_heap_region,
1602                                         MetaspaceShared::max_open_archive_heap_region);
1603 
1604   mapinfo-&gt;set_final_requested_base((char*)Arguments::default_SharedBaseAddress());
1605   mapinfo-&gt;set_header_crc(mapinfo-&gt;compute_header_crc());
1606   mapinfo-&gt;write_header();
<a name="6" id="anc6"></a>
1607   mapinfo-&gt;close();
1608 
<a name="7" id="anc7"></a><span class="line-removed">1609   print_region_stats();</span>
<span class="line-removed">1610 </span>
1611   if (log_is_enabled(Info, cds)) {
1612     ArchiveCompactor::alloc_stats()-&gt;print_stats(int(_ro_region.used()), int(_rw_region.used()),
1613                                                  int(_mc_region.used()));
1614   }
1615 
1616   if (PrintSystemDictionaryAtExit) {
1617     SystemDictionary::print();
1618   }
1619 
1620   if (AllowArchivingWithJavaAgent) {
1621     warning(&quot;This archive was created with AllowArchivingWithJavaAgent. It should be used &quot;
1622             &quot;for testing purposes only and should not be used in a production environment&quot;);
1623   }
1624 
1625   // There may be other pending VM operations that operate on the InstanceKlasses,
1626   // which will fail because InstanceKlasses::remove_unshareable_info()
1627   // has been called. Forget these operations and exit the VM directly.
1628   vm_direct_exit(0);
1629 }
1630 
<a name="8" id="anc8"></a><span class="line-modified">1631 void VM_PopulateDumpSharedSpace::print_region_stats() {</span>
1632   // Print statistics of all the regions
<a name="9" id="anc9"></a><span class="line-modified">1633   const size_t bitmap_used = ArchivePtrMarker::ptrmap()-&gt;size_in_bytes();</span>
<span class="line-modified">1634   const size_t bitmap_reserved = align_up(bitmap_used, Metaspace::reserve_alignment());</span>
1635   const size_t total_reserved = _ro_region.reserved()  + _rw_region.reserved() +
1636                                 _mc_region.reserved()  +
1637                                 bitmap_reserved +
1638                                 _total_closed_archive_region_size +
1639                                 _total_open_archive_region_size;
1640   const size_t total_bytes = _ro_region.used()  + _rw_region.used() +
1641                              _mc_region.used()  +
1642                              bitmap_used +
1643                              _total_closed_archive_region_size +
1644                              _total_open_archive_region_size;
1645   const double total_u_perc = percent_of(total_bytes, total_reserved);
1646 
1647   _mc_region.print(total_reserved);
1648   _rw_region.print(total_reserved);
1649   _ro_region.print(total_reserved);
1650   print_bitmap_region_stats(bitmap_reserved, total_reserved);
1651   print_heap_region_stats(_closed_archive_heap_regions, &quot;ca&quot;, total_reserved);
1652   print_heap_region_stats(_open_archive_heap_regions, &quot;oa&quot;, total_reserved);
1653 
1654   log_debug(cds)(&quot;total    : &quot; SIZE_FORMAT_W(9) &quot; [100.0%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [%5.1f%% used]&quot;,
1655                  total_bytes, total_reserved, total_u_perc);
1656 }
1657 
1658 void VM_PopulateDumpSharedSpace::print_bitmap_region_stats(size_t size, size_t total_size) {
1659   log_debug(cds)(&quot;bm  space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [100.0%% used] at &quot; INTPTR_FORMAT,
1660                  size, size/double(total_size)*100.0, size, p2i(NULL));
1661 }
1662 
1663 void VM_PopulateDumpSharedSpace::print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
1664                                                          const char *name, size_t total_size) {
1665   int arr_len = heap_mem == NULL ? 0 : heap_mem-&gt;length();
1666   for (int i = 0; i &lt; arr_len; i++) {
1667       char* start = (char*)heap_mem-&gt;at(i).start();
1668       size_t size = heap_mem-&gt;at(i).byte_size();
1669       char* top = start + size;
1670       log_debug(cds)(&quot;%s%d space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [100.0%% used] at &quot; INTPTR_FORMAT,
1671                      name, i, size, size/double(total_size)*100.0, size, p2i(start));
1672 
1673   }
1674 }
1675 
<a name="10" id="anc10"></a><span class="line-modified">1676 void MetaspaceShared::write_core_archive_regions(FileMapInfo* mapinfo) {</span>


1677   // Make sure NUM_CDS_REGIONS (exported in cds.h) agrees with
1678   // MetaspaceShared::n_regions (internal to hotspot).
1679   assert(NUM_CDS_REGIONS == MetaspaceShared::n_regions, &quot;sanity&quot;);
1680 
1681   // mc contains the trampoline code for method entries, which are patched at run time,
1682   // so it needs to be read/write.
1683   write_region(mapinfo, mc, &amp;_mc_region, /*read_only=*/false,/*allow_exec=*/true);
1684   write_region(mapinfo, rw, &amp;_rw_region, /*read_only=*/false,/*allow_exec=*/false);
1685   write_region(mapinfo, ro, &amp;_ro_region, /*read_only=*/true, /*allow_exec=*/false);
<a name="11" id="anc11"></a><span class="line-modified">1686   mapinfo-&gt;write_bitmap_region(ArchivePtrMarker::ptrmap());</span>
1687 }
1688 
1689 void MetaspaceShared::write_region(FileMapInfo* mapinfo, int region_idx, DumpRegion* dump_region, bool read_only,  bool allow_exec) {
1690   mapinfo-&gt;write_region(region_idx, dump_region-&gt;base(), dump_region-&gt;used(), read_only, allow_exec);
1691 }
1692 
1693 // Update a Java object to point its Klass* to the new location after
1694 // shared archive has been compacted.
1695 void MetaspaceShared::relocate_klass_ptr(oop o) {
1696   assert(DumpSharedSpaces, &quot;sanity&quot;);
1697   Klass* k = ArchiveCompactor::get_relocated_klass(o-&gt;klass());
1698   o-&gt;set_klass(k);
1699 }
1700 
1701 Klass* MetaspaceShared::get_relocated_klass(Klass *k, bool is_final) {
1702   assert(DumpSharedSpaces, &quot;sanity&quot;);
1703   k = ArchiveCompactor::get_relocated_klass(k);
1704   if (is_final) {
1705     k = (Klass*)(address(k) + final_delta());
1706   }
1707   return k;
1708 }
1709 
1710 class LinkSharedClassesClosure : public KlassClosure {
1711   Thread* THREAD;
1712   bool    _made_progress;
1713  public:
1714   LinkSharedClassesClosure(Thread* thread) : THREAD(thread), _made_progress(false) {}
1715 
1716   void reset()               { _made_progress = false; }
1717   bool made_progress() const { return _made_progress; }
1718 
1719   void do_klass(Klass* k) {
1720     if (k-&gt;is_instance_klass()) {
1721       InstanceKlass* ik = InstanceKlass::cast(k);
<a name="12" id="anc12"></a><span class="line-modified">1722       // Link the class to cause the bytecodes to be rewritten and the</span>
<span class="line-modified">1723       // cpcache to be created. Class verification is done according</span>
<span class="line-modified">1724       // to -Xverify setting.</span>
<span class="line-modified">1725       _made_progress |= MetaspaceShared::try_link_class(ik, THREAD);</span>
<span class="line-modified">1726       guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);</span>
<span class="line-modified">1727 </span>
<span class="line-modified">1728       ik-&gt;constants()-&gt;resolve_class_constants(THREAD);</span>
<span class="line-modified">1729     }</span>
<span class="line-removed">1730   }</span>
<span class="line-removed">1731 };</span>
<span class="line-removed">1732 </span>
<span class="line-removed">1733 class CheckSharedClassesClosure : public KlassClosure {</span>
<span class="line-removed">1734   bool    _made_progress;</span>
<span class="line-removed">1735  public:</span>
<span class="line-removed">1736   CheckSharedClassesClosure() : _made_progress(false) {}</span>
1737 
<a name="13" id="anc13"></a><span class="line-modified">1738   void reset()               { _made_progress = false; }</span>
<span class="line-modified">1739   bool made_progress() const { return _made_progress; }</span>
<span class="line-modified">1740   void do_klass(Klass* k) {</span>
<span class="line-modified">1741     if (k-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(k)-&gt;check_sharing_error_state()) {</span>
<span class="line-modified">1742       _made_progress = true;</span>


1743     }
1744   }
1745 };
1746 
1747 void MetaspaceShared::link_and_cleanup_shared_classes(TRAPS) {
1748   // We need to iterate because verification may cause additional classes
1749   // to be loaded.
1750   LinkSharedClassesClosure link_closure(THREAD);
1751   do {
1752     link_closure.reset();
1753     ClassLoaderDataGraph::unlocked_loaded_classes_do(&amp;link_closure);
1754     guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1755   } while (link_closure.made_progress());
<a name="14" id="anc14"></a><span class="line-removed">1756 </span>
<span class="line-removed">1757   if (_has_error_classes) {</span>
<span class="line-removed">1758     // Mark all classes whose super class or interfaces failed verification.</span>
<span class="line-removed">1759     CheckSharedClassesClosure check_closure;</span>
<span class="line-removed">1760     do {</span>
<span class="line-removed">1761       // Not completely sure if we need to do this iteratively. Anyway,</span>
<span class="line-removed">1762       // we should come here only if there are unverifiable classes, which</span>
<span class="line-removed">1763       // shouldn&#39;t happen in normal cases. So better safe than sorry.</span>
<span class="line-removed">1764       check_closure.reset();</span>
<span class="line-removed">1765       ClassLoaderDataGraph::unlocked_loaded_classes_do(&amp;check_closure);</span>
<span class="line-removed">1766     } while (check_closure.made_progress());</span>
<span class="line-removed">1767   }</span>
1768 }
1769 
1770 void MetaspaceShared::prepare_for_dumping() {
1771   Arguments::check_unsupported_dumping_properties();
1772   ClassLoader::initialize_shared_path();
1773 }
1774 
1775 // Preload classes from a list, populate the shared spaces and dump to a
1776 // file.
1777 void MetaspaceShared::preload_and_dump(TRAPS) {
1778   { TraceTime timer(&quot;Dump Shared Spaces&quot;, TRACETIME_LOG(Info, startuptime));
1779     ResourceMark rm(THREAD);
1780     char class_list_path_str[JVM_MAXPATHLEN];
1781     // Preload classes to be shared.
1782     const char* class_list_path;
1783     if (SharedClassListFile == NULL) {
1784       // Construct the path to the class list (in jre/lib)
1785       // Walk up two directories from the location of the VM and
1786       // optionally tack on &quot;lib&quot; (depending on platform)
1787       os::jvm_path(class_list_path_str, sizeof(class_list_path_str));
1788       for (int i = 0; i &lt; 3; i++) {
1789         char *end = strrchr(class_list_path_str, *os::file_separator());
1790         if (end != NULL) *end = &#39;\0&#39;;
1791       }
1792       int class_list_path_len = (int)strlen(class_list_path_str);
1793       if (class_list_path_len &gt;= 3) {
1794         if (strcmp(class_list_path_str + class_list_path_len - 3, &quot;lib&quot;) != 0) {
1795           if (class_list_path_len &lt; JVM_MAXPATHLEN - 4) {
1796             jio_snprintf(class_list_path_str + class_list_path_len,
1797                          sizeof(class_list_path_str) - class_list_path_len,
1798                          &quot;%slib&quot;, os::file_separator());
1799             class_list_path_len += 4;
1800           }
1801         }
1802       }
1803       if (class_list_path_len &lt; JVM_MAXPATHLEN - 10) {
1804         jio_snprintf(class_list_path_str + class_list_path_len,
1805                      sizeof(class_list_path_str) - class_list_path_len,
1806                      &quot;%sclasslist&quot;, os::file_separator());
1807       }
1808       class_list_path = class_list_path_str;
1809     } else {
1810       class_list_path = SharedClassListFile;
1811     }
1812 
1813     log_info(cds)(&quot;Loading classes to share ...&quot;);
1814     _has_error_classes = false;
1815     int class_count = preload_classes(class_list_path, THREAD);
1816     if (ExtraSharedClassListFile) {
1817       class_count += preload_classes(ExtraSharedClassListFile, THREAD);
1818     }
1819     log_info(cds)(&quot;Loading classes to share: done.&quot;);
1820 
1821     log_info(cds)(&quot;Shared spaces: preloaded %d classes&quot;, class_count);
1822 
1823     if (SharedArchiveConfigFile) {
1824       log_info(cds)(&quot;Reading extra data from %s ...&quot;, SharedArchiveConfigFile);
1825       read_extra_data(SharedArchiveConfigFile, THREAD);
1826     }
1827     log_info(cds)(&quot;Reading extra data: done.&quot;);
1828 
1829     HeapShared::init_subgraph_entry_fields(THREAD);
1830 
1831     // Rewrite and link classes
1832     log_info(cds)(&quot;Rewriting and linking classes ...&quot;);
1833 
1834     // Link any classes which got missed. This would happen if we have loaded classes that
1835     // were not explicitly specified in the classlist. E.g., if an interface implemented by class K
1836     // fails verification, all other interfaces that were not specified in the classlist but
1837     // are implemented by K are not verified.
1838     link_and_cleanup_shared_classes(CATCH);
1839     log_info(cds)(&quot;Rewriting and linking classes: done&quot;);
1840 
1841     if (HeapShared::is_heap_object_archiving_allowed()) {
1842       // Avoid fragmentation while archiving heap objects.
1843       Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);
1844       Universe::heap()-&gt;collect(GCCause::_archive_time_gc);
1845       Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);
1846     }
1847 
1848     VM_PopulateDumpSharedSpace op;
1849     VMThread::execute(&amp;op);
1850   }
1851 }
1852 
1853 
1854 int MetaspaceShared::preload_classes(const char* class_list_path, TRAPS) {
1855   ClassListParser parser(class_list_path);
1856   int class_count = 0;
1857 
1858   while (parser.parse_one_line()) {
1859     Klass* klass = parser.load_current_class(THREAD);
1860     if (HAS_PENDING_EXCEPTION) {
1861       if (klass == NULL &amp;&amp;
1862           (PENDING_EXCEPTION-&gt;klass()-&gt;name() == vmSymbols::java_lang_ClassNotFoundException())) {
1863         // print a warning only when the pending exception is class not found
1864         log_warning(cds)(&quot;Preload Warning: Cannot find %s&quot;, parser.current_class_name());
1865       }
1866       CLEAR_PENDING_EXCEPTION;
1867     }
1868     if (klass != NULL) {
1869       if (log_is_enabled(Trace, cds)) {
1870         ResourceMark rm(THREAD);
1871         log_trace(cds)(&quot;Shared spaces preloaded: %s&quot;, klass-&gt;external_name());
1872       }
1873 
1874       if (klass-&gt;is_instance_klass()) {
1875         InstanceKlass* ik = InstanceKlass::cast(klass);
1876 
1877         // Link the class to cause the bytecodes to be rewritten and the
1878         // cpcache to be created. The linking is done as soon as classes
1879         // are loaded in order that the related data structures (klass and
1880         // cpCache) are located together.
1881         try_link_class(ik, THREAD);
1882         guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1883       }
1884 
1885       class_count++;
1886     }
1887   }
1888 
1889   return class_count;
1890 }
1891 
1892 // Returns true if the class&#39;s status has changed
1893 bool MetaspaceShared::try_link_class(InstanceKlass* ik, TRAPS) {
<a name="15" id="anc15"></a><span class="line-modified">1894   assert(DumpSharedSpaces, &quot;should only be called during dumping&quot;);</span>
<span class="line-modified">1895   if (ik-&gt;init_state() &lt; InstanceKlass::linked) {</span>

1896     bool saved = BytecodeVerificationLocal;
<a name="16" id="anc16"></a><span class="line-modified">1897     if (ik-&gt;loader_type() == 0 &amp;&amp; ik-&gt;class_loader() == NULL) {</span>
1898       // The verification decision is based on BytecodeVerificationRemote
1899       // for non-system classes. Since we are using the NULL classloader
1900       // to load non-system classes for customized class loaders during dumping,
1901       // we need to temporarily change BytecodeVerificationLocal to be the same as
1902       // BytecodeVerificationRemote. Note this can cause the parent system
1903       // classes also being verified. The extra overhead is acceptable during
1904       // dumping.
1905       BytecodeVerificationLocal = BytecodeVerificationRemote;
1906     }
1907     ik-&gt;link_class(THREAD);
1908     if (HAS_PENDING_EXCEPTION) {
1909       ResourceMark rm(THREAD);
1910       log_warning(cds)(&quot;Preload Warning: Verification failed for %s&quot;,
1911                     ik-&gt;external_name());
1912       CLEAR_PENDING_EXCEPTION;
<a name="17" id="anc17"></a><span class="line-modified">1913       ik-&gt;set_in_error_state();</span>
1914       _has_error_classes = true;
1915     }
1916     BytecodeVerificationLocal = saved;
1917     return true;
1918   } else {
1919     return false;
1920   }
1921 }
1922 
1923 #if INCLUDE_CDS_JAVA_HEAP
1924 void VM_PopulateDumpSharedSpace::dump_java_heap_objects() {
1925   // The closed and open archive heap space has maximum two regions.
1926   // See FileMapInfo::write_archive_heap_regions() for details.
1927   _closed_archive_heap_regions = new GrowableArray&lt;MemRegion&gt;(2);
1928   _open_archive_heap_regions = new GrowableArray&lt;MemRegion&gt;(2);
1929   HeapShared::archive_java_heap_objects(_closed_archive_heap_regions,
1930                                         _open_archive_heap_regions);
1931   ArchiveCompactor::OtherROAllocMark mark;
1932   HeapShared::write_subgraph_info_table();
1933 }
1934 
1935 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps() {
1936   if (HeapShared::is_heap_object_archiving_allowed()) {
1937     _closed_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
1938     dump_archive_heap_oopmaps(_closed_archive_heap_regions, _closed_archive_heap_oopmaps);
1939 
1940     _open_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
1941     dump_archive_heap_oopmaps(_open_archive_heap_regions, _open_archive_heap_oopmaps);
1942   }
1943 }
1944 
1945 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1946                                                            GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps) {
1947   for (int i=0; i&lt;regions-&gt;length(); i++) {
1948     ResourceBitMap oopmap = HeapShared::calculate_oopmap(regions-&gt;at(i));
1949     size_t size_in_bits = oopmap.size();
1950     size_t size_in_bytes = oopmap.size_in_bytes();
<a name="18" id="anc18"></a><span class="line-modified">1951     uintptr_t* buffer = (uintptr_t*)_ro_region.allocate(size_in_bytes, sizeof(intptr_t));</span>
1952     oopmap.write_to(buffer, size_in_bytes);
1953     log_info(cds, heap)(&quot;Oopmap = &quot; INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(6) &quot; bytes) for heap region &quot;
1954                         INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(8) &quot; bytes)&quot;,
1955                         p2i(buffer), size_in_bytes,
1956                         p2i(regions-&gt;at(i).start()), regions-&gt;at(i).byte_size());
1957 
1958     ArchiveHeapOopmapInfo info;
1959     info._oopmap = (address)buffer;
1960     info._oopmap_size_in_bits = size_in_bits;
<a name="19" id="anc19"></a>
1961     oopmaps-&gt;append(info);
1962   }
1963 }
1964 #endif // INCLUDE_CDS_JAVA_HEAP
1965 
1966 void ReadClosure::do_ptr(void** p) {
1967   assert(*p == NULL, &quot;initializing previous initialized pointer.&quot;);
1968   intptr_t obj = nextPtr();
1969   assert((intptr_t)obj &gt;= 0 || (intptr_t)obj &lt; -100,
1970          &quot;hit tag while initializing ptrs.&quot;);
1971   *p = (void*)obj;
1972 }
1973 
1974 void ReadClosure::do_u4(u4* p) {
1975   intptr_t obj = nextPtr();
1976   *p = (u4)(uintx(obj));
1977 }
1978 
1979 void ReadClosure::do_bool(bool* p) {
1980   intptr_t obj = nextPtr();
1981   *p = (bool)(uintx(obj));
1982 }
1983 
1984 void ReadClosure::do_tag(int tag) {
1985   int old_tag;
1986   old_tag = (int)(intptr_t)nextPtr();
1987   // do_int(&amp;old_tag);
1988   assert(tag == old_tag, &quot;old tag doesn&#39;t match&quot;);
1989   FileMapInfo::assert_mark(tag == old_tag);
1990 }
1991 
1992 void ReadClosure::do_oop(oop *p) {
1993   narrowOop o = (narrowOop)nextPtr();
1994   if (o == 0 || !HeapShared::open_archive_heap_region_mapped()) {
1995     p = NULL;
1996   } else {
1997     assert(HeapShared::is_heap_object_archiving_allowed(),
1998            &quot;Archived heap object is not allowed&quot;);
1999     assert(HeapShared::open_archive_heap_region_mapped(),
2000            &quot;Open archive heap region is not mapped&quot;);
2001     *p = HeapShared::decode_from_archive(o);
2002   }
2003 }
2004 
2005 void ReadClosure::do_region(u_char* start, size_t size) {
2006   assert((intptr_t)start % sizeof(intptr_t) == 0, &quot;bad alignment&quot;);
2007   assert(size % sizeof(intptr_t) == 0, &quot;bad size&quot;);
2008   do_tag((int)size);
2009   while (size &gt; 0) {
2010     *(intptr_t*)start = nextPtr();
2011     start += sizeof(intptr_t);
2012     size -= sizeof(intptr_t);
2013   }
2014 }
2015 
2016 void MetaspaceShared::set_shared_metaspace_range(void* base, void *static_top, void* top) {
2017   assert(base &lt;= static_top &amp;&amp; static_top &lt;= top, &quot;must be&quot;);
2018   _shared_metaspace_static_top = static_top;
2019   MetaspaceObj::set_shared_metaspace_range(base, top);
2020 }
2021 
2022 // Return true if given address is in the misc data region
2023 bool MetaspaceShared::is_in_shared_region(const void* p, int idx) {
2024   return UseSharedSpaces &amp;&amp; FileMapInfo::current_info()-&gt;is_in_shared_region(p, idx);
2025 }
2026 
2027 bool MetaspaceShared::is_in_trampoline_frame(address addr) {
2028   if (UseSharedSpaces &amp;&amp; is_in_shared_region(addr, MetaspaceShared::mc)) {
2029     return true;
2030   }
2031   return false;
2032 }
2033 
2034 bool MetaspaceShared::is_shared_dynamic(void* p) {
2035   if ((p &lt; MetaspaceObj::shared_metaspace_top()) &amp;&amp;
2036       (p &gt;= _shared_metaspace_static_top)) {
2037     return true;
2038   } else {
2039     return false;
2040   }
2041 }
2042 
2043 void MetaspaceShared::initialize_runtime_shared_and_meta_spaces() {
2044   assert(UseSharedSpaces, &quot;Must be called when UseSharedSpaces is enabled&quot;);
2045   MapArchiveResult result = MAP_ARCHIVE_OTHER_FAILURE;
2046   FileMapInfo* static_mapinfo = open_static_archive();
2047   FileMapInfo* dynamic_mapinfo = NULL;
2048 
2049   if (static_mapinfo != NULL) {
2050     dynamic_mapinfo = open_dynamic_archive();
2051 
2052     // First try to map at the requested address
2053     result = map_archives(static_mapinfo, dynamic_mapinfo, true);
2054     if (result == MAP_ARCHIVE_MMAP_FAILURE) {
2055       // Mapping has failed (probably due to ASLR). Let&#39;s map at an address chosen
2056       // by the OS.
2057       log_info(cds)(&quot;Try to map archive(s) at an alternative address&quot;);
2058       result = map_archives(static_mapinfo, dynamic_mapinfo, false);
2059     }
2060   }
2061 
2062   if (result == MAP_ARCHIVE_SUCCESS) {
2063     bool dynamic_mapped = (dynamic_mapinfo != NULL &amp;&amp; dynamic_mapinfo-&gt;is_mapped());
2064     char* cds_base = static_mapinfo-&gt;mapped_base();
2065     char* cds_end =  dynamic_mapped ? dynamic_mapinfo-&gt;mapped_end() : static_mapinfo-&gt;mapped_end();
2066     set_shared_metaspace_range(cds_base, static_mapinfo-&gt;mapped_end(), cds_end);
2067     _relocation_delta = static_mapinfo-&gt;relocation_delta();
2068     if (dynamic_mapped) {
2069       FileMapInfo::set_shared_path_table(dynamic_mapinfo);
2070     } else {
2071       FileMapInfo::set_shared_path_table(static_mapinfo);
2072     }
2073   } else {
2074     set_shared_metaspace_range(NULL, NULL, NULL);
2075     UseSharedSpaces = false;
2076     FileMapInfo::fail_continue(&quot;Unable to map shared spaces&quot;);
2077     if (PrintSharedArchiveAndExit) {
2078       vm_exit_during_initialization(&quot;Unable to use shared archive.&quot;);
2079     }
2080   }
2081 
2082   if (static_mapinfo != NULL &amp;&amp; !static_mapinfo-&gt;is_mapped()) {
2083     delete static_mapinfo;
2084   }
2085   if (dynamic_mapinfo != NULL &amp;&amp; !dynamic_mapinfo-&gt;is_mapped()) {
2086     delete dynamic_mapinfo;
2087   }
2088 }
2089 
2090 FileMapInfo* MetaspaceShared::open_static_archive() {
2091   FileMapInfo* mapinfo = new FileMapInfo(true);
2092   if (!mapinfo-&gt;initialize()) {
2093     delete(mapinfo);
2094     return NULL;
2095   }
2096   return mapinfo;
2097 }
2098 
2099 FileMapInfo* MetaspaceShared::open_dynamic_archive() {
2100   if (DynamicDumpSharedSpaces) {
2101     return NULL;
2102   }
2103   if (Arguments::GetSharedDynamicArchivePath() == NULL) {
2104     return NULL;
2105   }
2106 
2107   FileMapInfo* mapinfo = new FileMapInfo(false);
2108   if (!mapinfo-&gt;initialize()) {
2109     delete(mapinfo);
2110     return NULL;
2111   }
2112   return mapinfo;
2113 }
2114 
2115 // use_requested_addr:
2116 //  true  = map at FileMapHeader::_requested_base_address
2117 //  false = map at an alternative address picked by OS.
2118 MapArchiveResult MetaspaceShared::map_archives(FileMapInfo* static_mapinfo, FileMapInfo* dynamic_mapinfo,
2119                                                bool use_requested_addr) {
2120   PRODUCT_ONLY(if (ArchiveRelocationMode == 1 &amp;&amp; use_requested_addr) {
2121       // For product build only -- this is for benchmarking the cost of doing relocation.
2122       // For debug builds, the check is done in FileMapInfo::map_regions for better test coverage.
2123       log_info(cds)(&quot;ArchiveRelocationMode == 1: always map archive(s) at an alternative address&quot;);
2124       return MAP_ARCHIVE_MMAP_FAILURE;
2125     });
2126 
2127   if (ArchiveRelocationMode == 2 &amp;&amp; !use_requested_addr) {
2128     log_info(cds)(&quot;ArchiveRelocationMode == 2: never map archive(s) at an alternative address&quot;);
2129     return MAP_ARCHIVE_MMAP_FAILURE;
2130   };
2131 
2132   if (dynamic_mapinfo != NULL) {
2133     // Ensure that the OS won&#39;t be able to allocate new memory spaces between the two
2134     // archives, or else it would mess up the simple comparision in MetaspaceObj::is_shared().
2135     assert(static_mapinfo-&gt;mapping_end_offset() == dynamic_mapinfo-&gt;mapping_base_offset(), &quot;no gap&quot;);
2136   }
2137 
2138   ReservedSpace main_rs, archive_space_rs, class_space_rs;
2139   MapArchiveResult result = MAP_ARCHIVE_OTHER_FAILURE;
2140   char* mapped_base_address = reserve_address_space_for_archives(static_mapinfo, dynamic_mapinfo,
2141                                                                  use_requested_addr, main_rs, archive_space_rs,
2142                                                                  class_space_rs);
2143   if (mapped_base_address == NULL) {
2144     result = MAP_ARCHIVE_MMAP_FAILURE;
2145   } else {
2146     log_debug(cds)(&quot;Reserved archive_space_rs     [&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot;] (&quot; SIZE_FORMAT &quot;) bytes&quot;,
2147                    p2i(archive_space_rs.base()), p2i(archive_space_rs.end()), archive_space_rs.size());
2148     log_debug(cds)(&quot;Reserved class_space_rs [&quot; INTPTR_FORMAT &quot; - &quot; INTPTR_FORMAT &quot;] (&quot; SIZE_FORMAT &quot;) bytes&quot;,
2149                    p2i(class_space_rs.base()), p2i(class_space_rs.end()), class_space_rs.size());
2150     MapArchiveResult static_result = map_archive(static_mapinfo, mapped_base_address, archive_space_rs);
2151     MapArchiveResult dynamic_result = (static_result == MAP_ARCHIVE_SUCCESS) ?
2152                                      map_archive(dynamic_mapinfo, mapped_base_address, archive_space_rs) : MAP_ARCHIVE_OTHER_FAILURE;
2153 
2154     DEBUG_ONLY(if (ArchiveRelocationMode == 1 &amp;&amp; use_requested_addr) {
2155       // This is for simulating mmap failures at the requested address. In debug builds, we do it
2156       // here (after all archives have possibly been mapped), so we can thoroughly test the code for
2157       // failure handling (releasing all allocated resource, etc).
2158       log_info(cds)(&quot;ArchiveRelocationMode == 1: always map archive(s) at an alternative address&quot;);
2159       if (static_result == MAP_ARCHIVE_SUCCESS) {
2160         static_result = MAP_ARCHIVE_MMAP_FAILURE;
2161       }
2162       if (dynamic_result == MAP_ARCHIVE_SUCCESS) {
2163         dynamic_result = MAP_ARCHIVE_MMAP_FAILURE;
2164       }
2165     });
2166 
2167     if (static_result == MAP_ARCHIVE_SUCCESS) {
2168       if (dynamic_result == MAP_ARCHIVE_SUCCESS) {
2169         result = MAP_ARCHIVE_SUCCESS;
2170       } else if (dynamic_result == MAP_ARCHIVE_OTHER_FAILURE) {
2171         assert(dynamic_mapinfo != NULL &amp;&amp; !dynamic_mapinfo-&gt;is_mapped(), &quot;must have failed&quot;);
2172         // No need to retry mapping the dynamic archive again, as it will never succeed
2173         // (bad file, etc) -- just keep the base archive.
2174         log_warning(cds, dynamic)(&quot;Unable to use shared archive. The top archive failed to load: %s&quot;,
2175                                   dynamic_mapinfo-&gt;full_path());
2176         result = MAP_ARCHIVE_SUCCESS;
2177         // TODO, we can give the unused space for the dynamic archive to class_space_rs, but there&#39;s no
2178         // easy API to do that right now.
2179       } else {
2180         result = MAP_ARCHIVE_MMAP_FAILURE;
2181       }
2182     } else if (static_result == MAP_ARCHIVE_OTHER_FAILURE) {
2183       result = MAP_ARCHIVE_OTHER_FAILURE;
2184     } else {
2185       result = MAP_ARCHIVE_MMAP_FAILURE;
2186     }
2187   }
2188 
2189   if (result == MAP_ARCHIVE_SUCCESS) {
2190     if (!main_rs.is_reserved() &amp;&amp; class_space_rs.is_reserved()) {
2191       MemTracker::record_virtual_memory_type((address)class_space_rs.base(), mtClass);
2192     }
2193     SharedBaseAddress = (size_t)mapped_base_address;
2194     LP64_ONLY({
2195         if (Metaspace::using_class_space()) {
2196           assert(class_space_rs.is_reserved(), &quot;must be&quot;);
2197           char* cds_base = static_mapinfo-&gt;mapped_base();
2198           Metaspace::allocate_metaspace_compressed_klass_ptrs(class_space_rs, NULL, (address)cds_base);
2199           // map_heap_regions() compares the current narrow oop and klass encodings
2200           // with the archived ones, so it must be done after all encodings are determined.
2201           static_mapinfo-&gt;map_heap_regions();
2202           CompressedKlassPointers::set_range(CompressedClassSpaceSize);
2203         }
2204       });
2205   } else {
2206     unmap_archive(static_mapinfo);
2207     unmap_archive(dynamic_mapinfo);
2208     release_reserved_spaces(main_rs, archive_space_rs, class_space_rs);
2209   }
2210 
2211   return result;
2212 }
2213 
2214 char* MetaspaceShared::reserve_address_space_for_archives(FileMapInfo* static_mapinfo,
2215                                                           FileMapInfo* dynamic_mapinfo,
2216                                                           bool use_requested_addr,
2217                                                           ReservedSpace&amp; main_rs,
2218                                                           ReservedSpace&amp; archive_space_rs,
2219                                                           ReservedSpace&amp; class_space_rs) {
2220   const bool use_klass_space = NOT_LP64(false) LP64_ONLY(Metaspace::using_class_space());
2221   const size_t class_space_size = NOT_LP64(0) LP64_ONLY(Metaspace::compressed_class_space_size());
2222 
2223   if (use_klass_space) {
2224     assert(class_space_size &gt; 0, &quot;CompressedClassSpaceSize must have been validated&quot;);
2225   }
2226   if (use_requested_addr &amp;&amp; !is_aligned(static_mapinfo-&gt;requested_base_address(), reserved_space_alignment())) {
2227     return NULL;
2228   }
2229 
2230   // Size and requested location of the archive_space_rs (for both static and dynamic archives)
2231   size_t base_offset = static_mapinfo-&gt;mapping_base_offset();
2232   size_t end_offset  = (dynamic_mapinfo == NULL) ? static_mapinfo-&gt;mapping_end_offset() : dynamic_mapinfo-&gt;mapping_end_offset();
2233   assert(base_offset == 0, &quot;must be&quot;);
2234   assert(is_aligned(end_offset,  os::vm_allocation_granularity()), &quot;must be&quot;);
2235   assert(is_aligned(base_offset, os::vm_allocation_granularity()), &quot;must be&quot;);
2236 
2237   // In case reserved_space_alignment() != os::vm_allocation_granularity()
2238   assert((size_t)os::vm_allocation_granularity() &lt;= reserved_space_alignment(), &quot;must be&quot;);
2239   end_offset = align_up(end_offset, reserved_space_alignment());
2240 
2241   size_t archive_space_size = end_offset - base_offset;
2242 
2243   // Special handling for Windows because it cannot mmap into a reserved space:
2244   //    use_requested_addr: We just map each region individually, and give up if any one of them fails.
2245   //   !use_requested_addr: We reserve the space first, and then os::read in all the regions (instead of mmap).
2246   //                        We&#39;re going to patch all the pointers anyway so there&#39;s no benefit for mmap.
2247 
2248   if (use_requested_addr) {
2249     char* archive_space_base = static_mapinfo-&gt;requested_base_address() + base_offset;
2250     char* archive_space_end  = archive_space_base + archive_space_size;
2251     if (!MetaspaceShared::use_windows_memory_mapping()) {
2252       archive_space_rs = reserve_shared_space(archive_space_size, archive_space_base);
2253       if (!archive_space_rs.is_reserved()) {
2254         return NULL;
2255       }
2256     }
2257     if (use_klass_space) {
2258       // Make sure we can map the klass space immediately following the archive_space space
2259       // Don&#39;t call reserve_shared_space here as that may try to enforce platform-specific
2260       // alignment rules which only apply to the archive base address
2261       char* class_space_base = archive_space_end;
2262       class_space_rs = ReservedSpace(class_space_size, reserved_space_alignment(),
2263                                      false /* large_pages */, class_space_base);
2264       if (!class_space_rs.is_reserved()) {
2265         return NULL;
2266       }
2267     }
2268     return static_mapinfo-&gt;requested_base_address();
2269   } else {
2270     if (use_klass_space) {
2271       main_rs = reserve_shared_space(archive_space_size + class_space_size);
2272       if (main_rs.is_reserved()) {
2273         archive_space_rs = main_rs.first_part(archive_space_size, reserved_space_alignment(), /*split=*/true);
2274         class_space_rs = main_rs.last_part(archive_space_size);
2275       }
2276     } else {
2277       main_rs = reserve_shared_space(archive_space_size);
2278       archive_space_rs = main_rs;
2279     }
2280     if (archive_space_rs.is_reserved()) {
2281       return archive_space_rs.base();
2282     } else {
2283       return NULL;
2284     }
2285   }
2286 }
2287 
2288 void MetaspaceShared::release_reserved_spaces(ReservedSpace&amp; main_rs,
2289                                               ReservedSpace&amp; archive_space_rs,
2290                                               ReservedSpace&amp; class_space_rs) {
2291   if (main_rs.is_reserved()) {
2292     assert(main_rs.contains(archive_space_rs.base()), &quot;must be&quot;);
2293     assert(main_rs.contains(class_space_rs.base()), &quot;must be&quot;);
2294     log_debug(cds)(&quot;Released shared space (archive+classes) &quot; INTPTR_FORMAT, p2i(main_rs.base()));
2295     main_rs.release();
2296   } else {
2297     if (archive_space_rs.is_reserved()) {
2298       log_debug(cds)(&quot;Released shared space (archive) &quot; INTPTR_FORMAT, p2i(archive_space_rs.base()));
2299       archive_space_rs.release();
2300     }
2301     if (class_space_rs.is_reserved()) {
2302       log_debug(cds)(&quot;Released shared space (classes) &quot; INTPTR_FORMAT, p2i(class_space_rs.base()));
2303       class_space_rs.release();
2304     }
2305   }
2306 }
2307 
2308 static int archive_regions[]  = {MetaspaceShared::mc,
2309                                  MetaspaceShared::rw,
2310                                  MetaspaceShared::ro};
2311 static int archive_regions_count  = 3;
2312 
2313 MapArchiveResult MetaspaceShared::map_archive(FileMapInfo* mapinfo, char* mapped_base_address, ReservedSpace rs) {
2314   assert(UseSharedSpaces, &quot;must be runtime&quot;);
2315   if (mapinfo == NULL) {
2316     return MAP_ARCHIVE_SUCCESS; // The dynamic archive has not been specified. No error has happened -- trivially succeeded.
2317   }
2318 
2319   mapinfo-&gt;set_is_mapped(false);
2320 
2321   if (mapinfo-&gt;alignment() != (size_t)os::vm_allocation_granularity()) {
2322     log_error(cds)(&quot;Unable to map CDS archive -- os::vm_allocation_granularity() expected: &quot; SIZE_FORMAT
2323                    &quot; actual: %d&quot;, mapinfo-&gt;alignment(), os::vm_allocation_granularity());
2324     return MAP_ARCHIVE_OTHER_FAILURE;
2325   }
2326 
2327   MapArchiveResult result =
2328     mapinfo-&gt;map_regions(archive_regions, archive_regions_count, mapped_base_address, rs);
2329 
2330   if (result != MAP_ARCHIVE_SUCCESS) {
2331     unmap_archive(mapinfo);
2332     return result;
2333   }
2334 
2335   if (mapinfo-&gt;is_static()) {
2336     if (!mapinfo-&gt;validate_shared_path_table()) {
2337       unmap_archive(mapinfo);
2338       return MAP_ARCHIVE_OTHER_FAILURE;
2339     }
2340   } else {
2341     if (!DynamicArchive::validate(mapinfo)) {
2342       unmap_archive(mapinfo);
2343       return MAP_ARCHIVE_OTHER_FAILURE;
2344     }
2345   }
2346 
2347   mapinfo-&gt;set_is_mapped(true);
2348   return MAP_ARCHIVE_SUCCESS;
2349 }
2350 
2351 void MetaspaceShared::unmap_archive(FileMapInfo* mapinfo) {
2352   assert(UseSharedSpaces, &quot;must be runtime&quot;);
2353   if (mapinfo != NULL) {
2354     mapinfo-&gt;unmap_regions(archive_regions, archive_regions_count);
2355     mapinfo-&gt;set_is_mapped(false);
2356   }
2357 }
2358 
2359 // Read the miscellaneous data from the shared file, and
2360 // serialize it out to its various destinations.
2361 
2362 void MetaspaceShared::initialize_shared_spaces() {
2363   FileMapInfo *static_mapinfo = FileMapInfo::current_info();
2364   _i2i_entry_code_buffers = static_mapinfo-&gt;i2i_entry_code_buffers();
2365   _i2i_entry_code_buffers_size = static_mapinfo-&gt;i2i_entry_code_buffers_size();
2366   char* buffer = static_mapinfo-&gt;cloned_vtables();
2367   clone_cpp_vtables((intptr_t*)buffer);
2368 
2369   // Verify various attributes of the archive, plus initialize the
2370   // shared string/symbol tables
2371   buffer = static_mapinfo-&gt;serialized_data();
2372   intptr_t* array = (intptr_t*)buffer;
2373   ReadClosure rc(&amp;array);
2374   serialize(&amp;rc);
2375 
2376   // Initialize the run-time symbol table.
2377   SymbolTable::create_table();
2378 
2379   static_mapinfo-&gt;patch_archived_heap_embedded_pointers();
2380 
2381   // Close the mapinfo file
2382   static_mapinfo-&gt;close();
2383 
<a name="20" id="anc20"></a>

2384   FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();
2385   if (dynamic_mapinfo != NULL) {
2386     intptr_t* buffer = (intptr_t*)dynamic_mapinfo-&gt;serialized_data();
2387     ReadClosure rc(&amp;buffer);
2388     SymbolTable::serialize_shared_table_header(&amp;rc, false);
2389     SystemDictionaryShared::serialize_dictionary_headers(&amp;rc, false);
2390     dynamic_mapinfo-&gt;close();
2391   }
2392 
2393   if (PrintSharedArchiveAndExit) {
2394     if (PrintSharedDictionary) {
2395       tty-&gt;print_cr(&quot;\nShared classes:\n&quot;);
2396       SystemDictionaryShared::print_on(tty);
2397     }
2398     if (FileMapInfo::current_info() == NULL || _archive_loading_failed) {
2399       tty-&gt;print_cr(&quot;archive is invalid&quot;);
2400       vm_exit(1);
2401     } else {
2402       tty-&gt;print_cr(&quot;archive is valid&quot;);
2403       vm_exit(0);
2404     }
2405   }
2406 }
2407 
2408 // JVM/TI RedefineClasses() support:
2409 bool MetaspaceShared::remap_shared_readonly_as_readwrite() {
2410   assert(SafepointSynchronize::is_at_safepoint(), &quot;must be at safepoint&quot;);
2411 
2412   if (UseSharedSpaces) {
2413     // remap the shared readonly space to shared readwrite, private
2414     FileMapInfo* mapinfo = FileMapInfo::current_info();
2415     if (!mapinfo-&gt;remap_shared_readonly_as_readwrite()) {
2416       return false;
2417     }
2418     if (FileMapInfo::dynamic_info() != NULL) {
2419       mapinfo = FileMapInfo::dynamic_info();
2420       if (!mapinfo-&gt;remap_shared_readonly_as_readwrite()) {
2421         return false;
2422       }
2423     }
2424     _remapped_readwrite = true;
2425   }
2426   return true;
2427 }
2428 
2429 void MetaspaceShared::report_out_of_space(const char* name, size_t needed_bytes) {
2430   // This is highly unlikely to happen on 64-bits because we have reserved a 4GB space.
2431   // On 32-bit we reserve only 256MB so you could run out of space with 100,000 classes
2432   // or so.
2433   _mc_region.print_out_of_space_msg(name, needed_bytes);
2434   _rw_region.print_out_of_space_msg(name, needed_bytes);
2435   _ro_region.print_out_of_space_msg(name, needed_bytes);
2436 
2437   vm_exit_during_initialization(err_msg(&quot;Unable to allocate from &#39;%s&#39; region&quot;, name),
2438                                 &quot;Please reduce the number of shared classes.&quot;);
2439 }
2440 
2441 // This is used to relocate the pointers so that the archive can be mapped at
2442 // Arguments::default_SharedBaseAddress() without runtime relocation.
2443 intx MetaspaceShared::final_delta() {
2444   return intx(Arguments::default_SharedBaseAddress())  // We want the archive to be mapped to here at runtime
2445        - intx(SharedBaseAddress);                      // .. but the archive is mapped at here at dump time
2446 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
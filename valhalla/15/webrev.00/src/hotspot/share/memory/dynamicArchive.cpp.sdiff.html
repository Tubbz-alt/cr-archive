<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/dynamicArchive.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../logging/logPrefix.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="filemap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/dynamicArchive.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 850       m-&gt;set_adapter_trampoline(to_target(adapter_trampoline));
 851     }
 852   }
 853 
 854   guarantee(p &lt;= mc_space-&gt;top(), &quot;Estimate of trampoline size is insufficient&quot;);
 855 }
 856 
 857 void DynamicArchiveBuilder::make_klasses_shareable() {
 858   int i, count = _klasses-&gt;length();
 859 
 860   InstanceKlass::disable_method_binary_search();
 861   for (i = 0; i &lt; count; i++) {
 862     InstanceKlass* ik = _klasses-&gt;at(i);
 863     sort_methods(ik);
 864   }
 865 
 866   for (i = 0; i &lt; count; i++) {
 867     InstanceKlass* ik = _klasses-&gt;at(i);
 868     ClassLoaderData *cld = ik-&gt;class_loader_data();
 869     if (cld-&gt;is_boot_class_loader_data()) {
<span class="line-modified"> 870       ik-&gt;set_class_loader_type(ClassLoader::BOOT_LOADER);</span>
 871     }
 872     else if (cld-&gt;is_platform_class_loader_data()) {
<span class="line-modified"> 873       ik-&gt;set_class_loader_type(ClassLoader::PLATFORM_LOADER);</span>
 874     }
 875     else if (cld-&gt;is_system_class_loader_data()) {
<span class="line-modified"> 876       ik-&gt;set_class_loader_type(ClassLoader::APP_LOADER);</span>
 877     }
 878 
 879     MetaspaceShared::rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread::current(), ik);
 880     ik-&gt;remove_unshareable_info();
 881 
 882     assert(ik-&gt;array_klasses() == NULL, &quot;sanity&quot;);
 883 
 884     if (log_is_enabled(Debug, cds, dynamic)) {
 885       ResourceMark rm;
 886       log_debug(cds, dynamic)(&quot;klasses[%4i] = &quot; PTR_FORMAT &quot; %s&quot;, i, p2i(to_target(ik)), ik-&gt;external_name());
 887     }
 888   }
 889 }
 890 
 891 // The address order of the copied Symbols may be different than when the original
 892 // klasses were created. Re-sort all the tables. See Method::sort_methods().
 893 void DynamicArchiveBuilder::sort_methods(InstanceKlass* ik) const {
 894   assert(ik != NULL, &quot;DynamicArchiveBuilder currently doesn&#39;t support dumping the base archive&quot;);
 895   if (MetaspaceShared::is_in_shared_metaspace(ik)) {
 896     // We have reached a supertype that&#39;s already in the base archive
</pre>
<hr />
<pre>
 965     address* p = _buffer_bottom + offset;
 966     assert(_builder-&gt;is_in_buffer_space(p), &quot;pointer must live in buffer space&quot;);
 967 
 968     address old_ptr = *p;
 969     if (_builder-&gt;is_in_buffer_space(old_ptr)) {
 970       address new_ptr = old_ptr + _buffer_to_target_delta;
 971       log_trace(cds, dynamic)(&quot;Final patch: @%6d [&quot; PTR_FORMAT &quot; -&gt; &quot; PTR_FORMAT &quot;] &quot; PTR_FORMAT &quot; =&gt; &quot; PTR_FORMAT,
 972                               (int)offset, p2i(p), p2i(_builder-&gt;to_target(p)),
 973                               p2i(old_ptr), p2i(new_ptr));
 974       *p = new_ptr;
 975     }
 976 
 977     return true; // keep iterating
 978   }
 979 };
 980 
 981 void DynamicArchiveBuilder::relocate_buffer_to_target() {
 982   RelocateBufferToTarget patcher(this, (address*)_alloc_bottom, _buffer_to_target_delta);
 983   ArchivePtrMarker::ptrmap()-&gt;iterate(&amp;patcher);
 984 
<span class="line-modified"> 985   Array&lt;u8&gt;* table = FileMapInfo::shared_path_table().table();</span>
 986   SharedPathTable runtime_table(to_target(table), FileMapInfo::shared_path_table().size());
 987   _header-&gt;set_shared_path_table(runtime_table);
 988 
 989   address relocatable_base = (address)SharedBaseAddress;
 990   address relocatable_end = (address)(current_dump_space()-&gt;top()) + _buffer_to_target_delta;
 991 
 992   intx addr_delta = MetaspaceShared::final_delta();
 993   if (addr_delta == 0) {
 994     ArchivePtrMarker::compact(relocatable_base, relocatable_end);
 995   } else {
 996     // The base archive is NOT mapped at Arguments::default_SharedBaseAddress() (due to ASLR).
 997     // This means that the current content of the dynamic archive is based on a random
 998     // address. Let&#39;s relocate all the pointers, so that it can be mapped to
 999     // Arguments::default_SharedBaseAddress() without runtime relocation.
1000     //
1001     // Note: both the base and dynamic archive are written with
1002     // FileMapHeader::_shared_base_address == Arguments::default_SharedBaseAddress()
1003 
1004     // Patch all pointers that are marked by ptrmap within this region,
1005     // where we have just dumped all the metaspace data.
</pre>
<hr />
<pre>
1029 
1030     SharedDataRelocator&lt;true&gt; patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,
1031                                       valid_new_base, valid_new_end, addr_delta, ArchivePtrMarker::ptrmap());
1032     ArchivePtrMarker::ptrmap()-&gt;iterate(&amp;patcher);
1033     ArchivePtrMarker::compact(patcher.max_non_null_offset());
1034   }
1035 }
1036 
1037 void DynamicArchiveBuilder::write_archive(char* serialized_data) {
1038   int num_klasses = _klasses-&gt;length();
1039   int num_symbols = _symbols-&gt;length();
1040 
1041   _header-&gt;set_serialized_data(to_target(serialized_data));
1042 
1043   FileMapInfo* dynamic_info = FileMapInfo::dynamic_info();
1044   assert(dynamic_info != NULL, &quot;Sanity&quot;);
1045 
1046   // Now write the archived data including the file offsets.
1047   const char* archive_name = Arguments::GetSharedDynamicArchivePath();
1048   dynamic_info-&gt;open_for_write(archive_name);
<span class="line-modified">1049   MetaspaceShared::write_core_archive_regions(dynamic_info);</span>
1050   dynamic_info-&gt;set_final_requested_base((char*)Arguments::default_SharedBaseAddress());
1051   dynamic_info-&gt;set_header_crc(dynamic_info-&gt;compute_header_crc());
1052   dynamic_info-&gt;write_header();
1053   dynamic_info-&gt;close();
1054 
1055   address base = to_target(_alloc_bottom);
1056   address top  = address(current_dump_space()-&gt;top()) + _buffer_to_target_delta;
1057   size_t file_size = pointer_delta(top, base, sizeof(char));
1058 
1059   base += MetaspaceShared::final_delta();
1060   top += MetaspaceShared::final_delta();
1061   log_info(cds, dynamic)(&quot;Written dynamic archive &quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT
1062                          &quot; [&quot; SIZE_FORMAT &quot; bytes header, &quot; SIZE_FORMAT &quot; bytes total]&quot;,
1063                          p2i(base), p2i(top), _header-&gt;header_size(), file_size);
1064   log_info(cds, dynamic)(&quot;%d klasses; %d symbols&quot;, num_klasses, num_symbols);
1065 }
1066 
1067 
1068 class VM_PopulateDynamicDumpSharedSpace: public VM_Operation {
1069   DynamicArchiveBuilder* _builder;
</pre>
</td>
<td>
<hr />
<pre>
 850       m-&gt;set_adapter_trampoline(to_target(adapter_trampoline));
 851     }
 852   }
 853 
 854   guarantee(p &lt;= mc_space-&gt;top(), &quot;Estimate of trampoline size is insufficient&quot;);
 855 }
 856 
 857 void DynamicArchiveBuilder::make_klasses_shareable() {
 858   int i, count = _klasses-&gt;length();
 859 
 860   InstanceKlass::disable_method_binary_search();
 861   for (i = 0; i &lt; count; i++) {
 862     InstanceKlass* ik = _klasses-&gt;at(i);
 863     sort_methods(ik);
 864   }
 865 
 866   for (i = 0; i &lt; count; i++) {
 867     InstanceKlass* ik = _klasses-&gt;at(i);
 868     ClassLoaderData *cld = ik-&gt;class_loader_data();
 869     if (cld-&gt;is_boot_class_loader_data()) {
<span class="line-modified"> 870       ik-&gt;set_shared_class_loader_type(ClassLoader::BOOT_LOADER);</span>
 871     }
 872     else if (cld-&gt;is_platform_class_loader_data()) {
<span class="line-modified"> 873       ik-&gt;set_shared_class_loader_type(ClassLoader::PLATFORM_LOADER);</span>
 874     }
 875     else if (cld-&gt;is_system_class_loader_data()) {
<span class="line-modified"> 876       ik-&gt;set_shared_class_loader_type(ClassLoader::APP_LOADER);</span>
 877     }
 878 
 879     MetaspaceShared::rewrite_nofast_bytecodes_and_calculate_fingerprints(Thread::current(), ik);
 880     ik-&gt;remove_unshareable_info();
 881 
 882     assert(ik-&gt;array_klasses() == NULL, &quot;sanity&quot;);
 883 
 884     if (log_is_enabled(Debug, cds, dynamic)) {
 885       ResourceMark rm;
 886       log_debug(cds, dynamic)(&quot;klasses[%4i] = &quot; PTR_FORMAT &quot; %s&quot;, i, p2i(to_target(ik)), ik-&gt;external_name());
 887     }
 888   }
 889 }
 890 
 891 // The address order of the copied Symbols may be different than when the original
 892 // klasses were created. Re-sort all the tables. See Method::sort_methods().
 893 void DynamicArchiveBuilder::sort_methods(InstanceKlass* ik) const {
 894   assert(ik != NULL, &quot;DynamicArchiveBuilder currently doesn&#39;t support dumping the base archive&quot;);
 895   if (MetaspaceShared::is_in_shared_metaspace(ik)) {
 896     // We have reached a supertype that&#39;s already in the base archive
</pre>
<hr />
<pre>
 965     address* p = _buffer_bottom + offset;
 966     assert(_builder-&gt;is_in_buffer_space(p), &quot;pointer must live in buffer space&quot;);
 967 
 968     address old_ptr = *p;
 969     if (_builder-&gt;is_in_buffer_space(old_ptr)) {
 970       address new_ptr = old_ptr + _buffer_to_target_delta;
 971       log_trace(cds, dynamic)(&quot;Final patch: @%6d [&quot; PTR_FORMAT &quot; -&gt; &quot; PTR_FORMAT &quot;] &quot; PTR_FORMAT &quot; =&gt; &quot; PTR_FORMAT,
 972                               (int)offset, p2i(p), p2i(_builder-&gt;to_target(p)),
 973                               p2i(old_ptr), p2i(new_ptr));
 974       *p = new_ptr;
 975     }
 976 
 977     return true; // keep iterating
 978   }
 979 };
 980 
 981 void DynamicArchiveBuilder::relocate_buffer_to_target() {
 982   RelocateBufferToTarget patcher(this, (address*)_alloc_bottom, _buffer_to_target_delta);
 983   ArchivePtrMarker::ptrmap()-&gt;iterate(&amp;patcher);
 984 
<span class="line-modified"> 985   Array&lt;u8&gt;* table = FileMapInfo::saved_shared_path_table().table();</span>
 986   SharedPathTable runtime_table(to_target(table), FileMapInfo::shared_path_table().size());
 987   _header-&gt;set_shared_path_table(runtime_table);
 988 
 989   address relocatable_base = (address)SharedBaseAddress;
 990   address relocatable_end = (address)(current_dump_space()-&gt;top()) + _buffer_to_target_delta;
 991 
 992   intx addr_delta = MetaspaceShared::final_delta();
 993   if (addr_delta == 0) {
 994     ArchivePtrMarker::compact(relocatable_base, relocatable_end);
 995   } else {
 996     // The base archive is NOT mapped at Arguments::default_SharedBaseAddress() (due to ASLR).
 997     // This means that the current content of the dynamic archive is based on a random
 998     // address. Let&#39;s relocate all the pointers, so that it can be mapped to
 999     // Arguments::default_SharedBaseAddress() without runtime relocation.
1000     //
1001     // Note: both the base and dynamic archive are written with
1002     // FileMapHeader::_shared_base_address == Arguments::default_SharedBaseAddress()
1003 
1004     // Patch all pointers that are marked by ptrmap within this region,
1005     // where we have just dumped all the metaspace data.
</pre>
<hr />
<pre>
1029 
1030     SharedDataRelocator&lt;true&gt; patcher((address*)patch_base, (address*)patch_end, valid_old_base, valid_old_end,
1031                                       valid_new_base, valid_new_end, addr_delta, ArchivePtrMarker::ptrmap());
1032     ArchivePtrMarker::ptrmap()-&gt;iterate(&amp;patcher);
1033     ArchivePtrMarker::compact(patcher.max_non_null_offset());
1034   }
1035 }
1036 
1037 void DynamicArchiveBuilder::write_archive(char* serialized_data) {
1038   int num_klasses = _klasses-&gt;length();
1039   int num_symbols = _symbols-&gt;length();
1040 
1041   _header-&gt;set_serialized_data(to_target(serialized_data));
1042 
1043   FileMapInfo* dynamic_info = FileMapInfo::dynamic_info();
1044   assert(dynamic_info != NULL, &quot;Sanity&quot;);
1045 
1046   // Now write the archived data including the file offsets.
1047   const char* archive_name = Arguments::GetSharedDynamicArchivePath();
1048   dynamic_info-&gt;open_for_write(archive_name);
<span class="line-modified">1049   MetaspaceShared::write_core_archive_regions(dynamic_info, NULL, NULL);</span>
1050   dynamic_info-&gt;set_final_requested_base((char*)Arguments::default_SharedBaseAddress());
1051   dynamic_info-&gt;set_header_crc(dynamic_info-&gt;compute_header_crc());
1052   dynamic_info-&gt;write_header();
1053   dynamic_info-&gt;close();
1054 
1055   address base = to_target(_alloc_bottom);
1056   address top  = address(current_dump_space()-&gt;top()) + _buffer_to_target_delta;
1057   size_t file_size = pointer_delta(top, base, sizeof(char));
1058 
1059   base += MetaspaceShared::final_delta();
1060   top += MetaspaceShared::final_delta();
1061   log_info(cds, dynamic)(&quot;Written dynamic archive &quot; PTR_FORMAT &quot; - &quot; PTR_FORMAT
1062                          &quot; [&quot; SIZE_FORMAT &quot; bytes header, &quot; SIZE_FORMAT &quot; bytes total]&quot;,
1063                          p2i(base), p2i(top), _header-&gt;header_size(), file_size);
1064   log_info(cds, dynamic)(&quot;%d klasses; %d symbols&quot;, num_klasses, num_symbols);
1065 }
1066 
1067 
1068 class VM_PopulateDynamicDumpSharedSpace: public VM_Operation {
1069   DynamicArchiveBuilder* _builder;
</pre>
</td>
</tr>
</table>
<center><a href="../logging/logPrefix.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="filemap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
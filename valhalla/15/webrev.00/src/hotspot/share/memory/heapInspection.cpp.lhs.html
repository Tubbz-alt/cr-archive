<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/memory/heapInspection.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/classLoaderData.inline.hpp&quot;
 27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
 28 #include &quot;classfile/moduleEntry.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;gc/shared/collectedHeap.hpp&quot;
 31 #include &quot;logging/log.hpp&quot;
 32 #include &quot;logging/logTag.hpp&quot;
 33 #include &quot;memory/heapInspection.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;memory/universe.hpp&quot;
 36 #include &quot;oops/oop.inline.hpp&quot;
 37 #include &quot;oops/reflectionAccessorImplKlassHelper.hpp&quot;
 38 #include &quot;oops/valueKlass.inline.hpp&quot;
 39 #include &quot;runtime/os.hpp&quot;
 40 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
 41 #include &quot;utilities/globalDefinitions.hpp&quot;
 42 #include &quot;utilities/macros.hpp&quot;
 43 #include &quot;utilities/stack.inline.hpp&quot;
 44 
 45 // HeapInspection
 46 
 47 inline KlassInfoEntry::~KlassInfoEntry() {
 48   if (_subclasses != NULL) {
 49     delete _subclasses;
 50   }
 51 }
 52 
 53 inline void KlassInfoEntry::add_subclass(KlassInfoEntry* cie) {
 54   if (_subclasses == NULL) {
 55     _subclasses = new  (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;KlassInfoEntry*&gt;(4, true);
 56   }
 57   _subclasses-&gt;append(cie);
 58 }
 59 
 60 int KlassInfoEntry::compare(KlassInfoEntry* e1, KlassInfoEntry* e2) {
 61   if(e1-&gt;_instance_words &gt; e2-&gt;_instance_words) {
 62     return -1;
 63   } else if(e1-&gt;_instance_words &lt; e2-&gt;_instance_words) {
 64     return 1;
 65   }
 66   // Sort alphabetically, note &#39;Z&#39; &lt; &#39;[&#39; &lt; &#39;a&#39;, but it&#39;s better to group
 67   // the array classes before all the instance classes.
 68   ResourceMark rm;
 69   const char* name1 = e1-&gt;klass()-&gt;external_name();
 70   const char* name2 = e2-&gt;klass()-&gt;external_name();
 71   bool d1 = (name1[0] == JVM_SIGNATURE_ARRAY);
 72   bool d2 = (name2[0] == JVM_SIGNATURE_ARRAY);
 73   if (d1 &amp;&amp; !d2) {
 74     return -1;
 75   } else if (d2 &amp;&amp; !d1) {
 76     return 1;
 77   } else {
 78     return strcmp(name1, name2);
 79   }
 80 }
 81 
 82 const char* KlassInfoEntry::name() const {
 83   const char* name;
 84   if (_klass-&gt;name() != NULL) {
 85     name = _klass-&gt;external_name();
 86   } else {
 87     if (_klass == Universe::boolArrayKlassObj())         name = &quot;&lt;boolArrayKlass&gt;&quot;;         else
 88     if (_klass == Universe::charArrayKlassObj())         name = &quot;&lt;charArrayKlass&gt;&quot;;         else
 89     if (_klass == Universe::floatArrayKlassObj())        name = &quot;&lt;floatArrayKlass&gt;&quot;;        else
 90     if (_klass == Universe::doubleArrayKlassObj())       name = &quot;&lt;doubleArrayKlass&gt;&quot;;       else
 91     if (_klass == Universe::byteArrayKlassObj())         name = &quot;&lt;byteArrayKlass&gt;&quot;;         else
 92     if (_klass == Universe::shortArrayKlassObj())        name = &quot;&lt;shortArrayKlass&gt;&quot;;        else
 93     if (_klass == Universe::intArrayKlassObj())          name = &quot;&lt;intArrayKlass&gt;&quot;;          else
 94     if (_klass == Universe::longArrayKlassObj())         name = &quot;&lt;longArrayKlass&gt;&quot;;         else
 95       name = &quot;&lt;no name&gt;&quot;;
 96   }
 97   return name;
 98 }
 99 
100 void KlassInfoEntry::print_on(outputStream* st) const {
101   ResourceMark rm;
102 
103   // simplify the formatting (ILP32 vs LP64) - always cast the numbers to 64-bit
104   ModuleEntry* module = _klass-&gt;module();
105   if (module-&gt;is_named()) {
<a name="1" id="anc1"></a><span class="line-modified">106     st-&gt;print_cr(INT64_FORMAT_W(13) &quot;  &quot; UINT64_FORMAT_W(13) &quot;  %s (%s@%s)&quot;,</span>
107                  (int64_t)_instance_count,
108                  (uint64_t)_instance_words * HeapWordSize,
109                  name(),
110                  module-&gt;name()-&gt;as_C_string(),
<a name="2" id="anc2"></a>
111                  module-&gt;version() != NULL ? module-&gt;version()-&gt;as_C_string() : &quot;&quot;);
112   } else {
113     st-&gt;print_cr(INT64_FORMAT_W(13) &quot;  &quot; UINT64_FORMAT_W(13) &quot;  %s&quot;,
114                  (int64_t)_instance_count,
115                  (uint64_t)_instance_words * HeapWordSize,
116                  name());
117   }
118 }
119 
120 KlassInfoEntry* KlassInfoBucket::lookup(Klass* const k) {
121   // Can happen if k is an archived class that we haven&#39;t loaded yet.
122   if (k-&gt;java_mirror_no_keepalive() == NULL) {
123     return NULL;
124   }
125 
126   KlassInfoEntry* elt = _list;
127   while (elt != NULL) {
128     if (elt-&gt;is_equal(k)) {
129       return elt;
130     }
131     elt = elt-&gt;next();
132   }
133   elt = new (std::nothrow) KlassInfoEntry(k, list());
134   // We may be out of space to allocate the new entry.
135   if (elt != NULL) {
136     set_list(elt);
137   }
138   return elt;
139 }
140 
141 void KlassInfoBucket::iterate(KlassInfoClosure* cic) {
142   KlassInfoEntry* elt = _list;
143   while (elt != NULL) {
144     cic-&gt;do_cinfo(elt);
145     elt = elt-&gt;next();
146   }
147 }
148 
149 void KlassInfoBucket::empty() {
150   KlassInfoEntry* elt = _list;
151   _list = NULL;
152   while (elt != NULL) {
153     KlassInfoEntry* next = elt-&gt;next();
154     delete elt;
155     elt = next;
156   }
157 }
158 
159 class KlassInfoTable::AllClassesFinder : public LockedClassesDo {
160   KlassInfoTable *_table;
161 public:
162   AllClassesFinder(KlassInfoTable* table) : _table(table) {}
163   virtual void do_klass(Klass* k) {
164     // This has the SIDE EFFECT of creating a KlassInfoEntry
165     // for &lt;k&gt;, if one doesn&#39;t exist yet.
166     _table-&gt;lookup(k);
167   }
168 };
169 
170 
171 KlassInfoTable::KlassInfoTable(bool add_all_classes) {
172   _size_of_instances_in_words = 0;
173   _ref = (HeapWord*) Universe::boolArrayKlassObj();
174   _buckets =
175     (KlassInfoBucket*)  AllocateHeap(sizeof(KlassInfoBucket) * _num_buckets,
176        mtInternal, CURRENT_PC, AllocFailStrategy::RETURN_NULL);
177   if (_buckets != NULL) {
178     for (int index = 0; index &lt; _num_buckets; index++) {
179       _buckets[index].initialize();
180     }
181     if (add_all_classes) {
182       AllClassesFinder finder(this);
183       ClassLoaderDataGraph::classes_do(&amp;finder);
184     }
185   }
186 }
187 
188 KlassInfoTable::~KlassInfoTable() {
189   if (_buckets != NULL) {
190     for (int index = 0; index &lt; _num_buckets; index++) {
191       _buckets[index].empty();
192     }
193     FREE_C_HEAP_ARRAY(KlassInfoBucket, _buckets);
194     _buckets = NULL;
195   }
196 }
197 
198 uint KlassInfoTable::hash(const Klass* p) {
199   return (uint)(((uintptr_t)p - (uintptr_t)_ref) &gt;&gt; 2);
200 }
201 
202 KlassInfoEntry* KlassInfoTable::lookup(Klass* k) {
203   uint         idx = hash(k) % _num_buckets;
204   assert(_buckets != NULL, &quot;Allocation failure should have been caught&quot;);
205   KlassInfoEntry*  e   = _buckets[idx].lookup(k);
206   // Lookup may fail if this is a new klass for which we
207   // could not allocate space for an new entry, or if it&#39;s
208   // an archived class that we haven&#39;t loaded yet.
209   assert(e == NULL || k == e-&gt;klass(), &quot;must be equal&quot;);
210   return e;
211 }
212 
213 // Return false if the entry could not be recorded on account
214 // of running out of space required to create a new entry.
215 bool KlassInfoTable::record_instance(const oop obj) {
216   Klass*        k = obj-&gt;klass();
217   KlassInfoEntry* elt = lookup(k);
218   // elt may be NULL if it&#39;s a new klass for which we
219   // could not allocate space for a new entry in the hashtable.
220   if (elt != NULL) {
221     elt-&gt;set_count(elt-&gt;count() + 1);
222     elt-&gt;set_words(elt-&gt;words() + obj-&gt;size());
223     _size_of_instances_in_words += obj-&gt;size();
224     return true;
225   } else {
226     return false;
227   }
228 }
229 
230 void KlassInfoTable::iterate(KlassInfoClosure* cic) {
231   assert(_buckets != NULL, &quot;Allocation failure should have been caught&quot;);
232   for (int index = 0; index &lt; _num_buckets; index++) {
233     _buckets[index].iterate(cic);
234   }
235 }
236 
237 size_t KlassInfoTable::size_of_instances_in_words() const {
238   return _size_of_instances_in_words;
239 }
240 
241 int KlassInfoHisto::sort_helper(KlassInfoEntry** e1, KlassInfoEntry** e2) {
242   return (*e1)-&gt;compare(*e1,*e2);
243 }
244 
245 KlassInfoHisto::KlassInfoHisto(KlassInfoTable* cit) :
246   _cit(cit) {
247   _elements = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;KlassInfoEntry*&gt;(_histo_initial_size, true);
248 }
249 
250 KlassInfoHisto::~KlassInfoHisto() {
251   delete _elements;
252 }
253 
254 void KlassInfoHisto::add(KlassInfoEntry* cie) {
255   elements()-&gt;append(cie);
256 }
257 
258 void KlassInfoHisto::sort() {
259   elements()-&gt;sort(KlassInfoHisto::sort_helper);
260 }
261 
262 void KlassInfoHisto::print_elements(outputStream* st) const {
263   // simplify the formatting (ILP32 vs LP64) - store the sum in 64-bit
264   int64_t total = 0;
265   uint64_t totalw = 0;
266   for(int i=0; i &lt; elements()-&gt;length(); i++) {
267     st-&gt;print(&quot;%4d: &quot;, i+1);
268     elements()-&gt;at(i)-&gt;print_on(st);
269     total += elements()-&gt;at(i)-&gt;count();
270     totalw += elements()-&gt;at(i)-&gt;words();
271   }
272   st-&gt;print_cr(&quot;Total &quot; INT64_FORMAT_W(13) &quot;  &quot; UINT64_FORMAT_W(13),
273                total, totalw * HeapWordSize);
274 }
275 
276 class HierarchyClosure : public KlassInfoClosure {
277 private:
278   GrowableArray&lt;KlassInfoEntry*&gt; *_elements;
279 public:
280   HierarchyClosure(GrowableArray&lt;KlassInfoEntry*&gt; *_elements) : _elements(_elements) {}
281 
282   void do_cinfo(KlassInfoEntry* cie) {
283     // ignore array classes
284     if (cie-&gt;klass()-&gt;is_instance_klass()) {
285       _elements-&gt;append(cie);
286     }
287   }
288 };
289 
290 void KlassHierarchy::print_class_hierarchy(outputStream* st, bool print_interfaces,
291                                            bool print_subclasses, char* classname) {
292   ResourceMark rm;
293   Stack &lt;KlassInfoEntry*, mtClass&gt; class_stack;
294   GrowableArray&lt;KlassInfoEntry*&gt; elements;
295 
296   // Add all classes to the KlassInfoTable, which allows for quick lookup.
297   // A KlassInfoEntry will be created for each class.
298   KlassInfoTable cit(true);
299   if (cit.allocation_failed()) {
300     st-&gt;print_cr(&quot;ERROR: Ran out of C-heap; hierarchy not generated&quot;);
301     return;
302   }
303 
304   // Add all created KlassInfoEntry instances to the elements array for easy
305   // iteration, and to allow each KlassInfoEntry instance to have a unique index.
306   HierarchyClosure hc(&amp;elements);
307   cit.iterate(&amp;hc);
308 
309   for(int i = 0; i &lt; elements.length(); i++) {
310     KlassInfoEntry* cie = elements.at(i);
311     Klass* super = cie-&gt;klass()-&gt;super();
312 
313     // Set the index for the class.
314     cie-&gt;set_index(i + 1);
315 
316     // Add the class to the subclass array of its superclass.
317     if (super != NULL) {
318       KlassInfoEntry* super_cie = cit.lookup(super);
319       assert(super_cie != NULL, &quot;could not lookup superclass&quot;);
320       super_cie-&gt;add_subclass(cie);
321     }
322   }
323 
324   // Set the do_print flag for each class that should be printed.
325   for(int i = 0; i &lt; elements.length(); i++) {
326     KlassInfoEntry* cie = elements.at(i);
327     if (classname == NULL) {
328       // We are printing all classes.
329       cie-&gt;set_do_print(true);
330     } else {
331       // We are only printing the hierarchy of a specific class.
332       if (strcmp(classname, cie-&gt;klass()-&gt;external_name()) == 0) {
333         KlassHierarchy::set_do_print_for_class_hierarchy(cie, &amp;cit, print_subclasses);
334       }
335     }
336   }
337 
338   // Now we do a depth first traversal of the class hierachry. The class_stack will
339   // maintain the list of classes we still need to process. Start things off
340   // by priming it with java.lang.Object.
341   KlassInfoEntry* jlo_cie = cit.lookup(SystemDictionary::Object_klass());
342   assert(jlo_cie != NULL, &quot;could not lookup java.lang.Object&quot;);
343   class_stack.push(jlo_cie);
344 
345   // Repeatedly pop the top item off the stack, print its class info,
346   // and push all of its subclasses on to the stack. Do this until there
347   // are no classes left on the stack.
348   while (!class_stack.is_empty()) {
349     KlassInfoEntry* curr_cie = class_stack.pop();
350     if (curr_cie-&gt;do_print()) {
351       print_class(st, curr_cie, print_interfaces);
352       if (curr_cie-&gt;subclasses() != NULL) {
353         // Current class has subclasses, so push all of them onto the stack.
354         for (int i = 0; i &lt; curr_cie-&gt;subclasses()-&gt;length(); i++) {
355           KlassInfoEntry* cie = curr_cie-&gt;subclasses()-&gt;at(i);
356           if (cie-&gt;do_print()) {
357             class_stack.push(cie);
358           }
359         }
360       }
361     }
362   }
363 
364   st-&gt;flush();
365 }
366 
367 // Sets the do_print flag for every superclass and subclass of the specified class.
368 void KlassHierarchy::set_do_print_for_class_hierarchy(KlassInfoEntry* cie, KlassInfoTable* cit,
369                                                       bool print_subclasses) {
370   // Set do_print for all superclasses of this class.
371   Klass* super = ((InstanceKlass*)cie-&gt;klass())-&gt;java_super();
372   while (super != NULL) {
373     KlassInfoEntry* super_cie = cit-&gt;lookup(super);
374     super_cie-&gt;set_do_print(true);
375     super = super-&gt;super();
376   }
377 
378   // Set do_print for this class and all of its subclasses.
379   Stack &lt;KlassInfoEntry*, mtClass&gt; class_stack;
380   class_stack.push(cie);
381   while (!class_stack.is_empty()) {
382     KlassInfoEntry* curr_cie = class_stack.pop();
383     curr_cie-&gt;set_do_print(true);
384     if (print_subclasses &amp;&amp; curr_cie-&gt;subclasses() != NULL) {
385       // Current class has subclasses, so push all of them onto the stack.
386       for (int i = 0; i &lt; curr_cie-&gt;subclasses()-&gt;length(); i++) {
387         KlassInfoEntry* cie = curr_cie-&gt;subclasses()-&gt;at(i);
388         class_stack.push(cie);
389       }
390     }
391   }
392 }
393 
394 static void print_indent(outputStream* st, int indent) {
395   while (indent != 0) {
396     st-&gt;print(&quot;|&quot;);
397     indent--;
398     if (indent != 0) {
399       st-&gt;print(&quot;  &quot;);
400     }
401   }
402 }
403 
404 // Print the class name and its unique ClassLoader identifer.
405 static void print_classname(outputStream* st, Klass* klass) {
406   oop loader_oop = klass-&gt;class_loader_data()-&gt;class_loader();
407   st-&gt;print(&quot;%s/&quot;, klass-&gt;external_name());
408   if (loader_oop == NULL) {
409     st-&gt;print(&quot;null&quot;);
410   } else {
411     st-&gt;print(INTPTR_FORMAT, p2i(klass-&gt;class_loader_data()));
412   }
413 }
414 
415 static void print_interface(outputStream* st, InstanceKlass* intf_klass, const char* intf_type, int indent) {
416   print_indent(st, indent);
417   st-&gt;print(&quot;  implements &quot;);
418   print_classname(st, intf_klass);
419   st-&gt;print(&quot; (%s intf)\n&quot;, intf_type);
420 }
421 
422 void KlassHierarchy::print_class(outputStream* st, KlassInfoEntry* cie, bool print_interfaces) {
423   ResourceMark rm;
424   InstanceKlass* klass = (InstanceKlass*)cie-&gt;klass();
425   int indent = 0;
426 
427   // Print indentation with proper indicators of superclass.
428   Klass* super = klass-&gt;super();
429   while (super != NULL) {
430     super = super-&gt;super();
431     indent++;
432   }
433   print_indent(st, indent);
434   if (indent != 0) st-&gt;print(&quot;--&quot;);
435 
436   // Print the class name, its unique ClassLoader identifer, and if it is an interface.
437   print_classname(st, klass);
438   if (klass-&gt;is_interface()) {
439     st-&gt;print(&quot; (intf)&quot;);
440   }
441   // Special treatment for generated core reflection accessor classes: print invocation target.
442   if (ReflectionAccessorImplKlassHelper::is_generated_accessor(klass)) {
443     st-&gt;print(&quot; (invokes: &quot;);
444     ReflectionAccessorImplKlassHelper::print_invocation_target(st, klass);
445     st-&gt;print(&quot;)&quot;);
446   }
447   st-&gt;print(&quot;\n&quot;);
448 
449   // Print any interfaces the class has.
450   if (print_interfaces) {
451     Array&lt;InstanceKlass*&gt;* local_intfs = klass-&gt;local_interfaces();
452     Array&lt;InstanceKlass*&gt;* trans_intfs = klass-&gt;transitive_interfaces();
453     for (int i = 0; i &lt; local_intfs-&gt;length(); i++) {
454       print_interface(st, local_intfs-&gt;at(i), &quot;declared&quot;, indent);
455     }
456     for (int i = 0; i &lt; trans_intfs-&gt;length(); i++) {
457       InstanceKlass* trans_interface = trans_intfs-&gt;at(i);
458       // Only print transitive interfaces if they are not also declared.
459       if (!local_intfs-&gt;contains(trans_interface)) {
460         print_interface(st, trans_interface, &quot;inherited&quot;, indent);
461       }
462     }
463   }
464 }
465 
466 void KlassInfoHisto::print_histo_on(outputStream* st) {
467   st-&gt;print_cr(&quot; num     #instances         #bytes  class name (module)&quot;);
468   st-&gt;print_cr(&quot;-------------------------------------------------------&quot;);
469   print_elements(st);
470 }
471 
472 class HistoClosure : public KlassInfoClosure {
473  private:
474   KlassInfoHisto* _cih;
475  public:
476   HistoClosure(KlassInfoHisto* cih) : _cih(cih) {}
477 
478   void do_cinfo(KlassInfoEntry* cie) {
479     _cih-&gt;add(cie);
480   }
481 };
482 
483 
484 class FindClassByNameClosure : public KlassInfoClosure {
485  private:
486   GrowableArray&lt;Klass*&gt;* _klasses;
487   Symbol* _classname;
488  public:
489   FindClassByNameClosure(GrowableArray&lt;Klass*&gt;* klasses, Symbol* classname) :
490     _klasses(klasses), _classname(classname) { }
491 
492   void do_cinfo(KlassInfoEntry* cie) {
493     if (cie-&gt;klass()-&gt;name() == _classname) {
494       _klasses-&gt;append(cie-&gt;klass());
495     }
496   }
497 };
498 
499 class FieldDesc {
500 private:
501   Symbol* _name;
502   Symbol* _signature;
503   int _offset;
504   int _index;
505   InstanceKlass* _holder;
506   AccessFlags _access_flags;
507  public:
508   FieldDesc() {
509     _name = NULL;
510     _signature = NULL;
511     _offset = -1;
512     _index = -1;
513     _holder = NULL;
514     _access_flags = AccessFlags();
515   }
516   FieldDesc(fieldDescriptor&amp; fd) {
517     _name = fd.name();
518     _signature = fd.signature();
519     _offset = fd.offset();
520     _index = fd.index();
521     _holder = fd.field_holder();
522     _access_flags = fd.access_flags();
523   }
524   const Symbol* name() { return _name;}
525   const Symbol* signature() { return _signature; }
526   const int offset() { return _offset; }
527   const int index() { return _index; }
528   const InstanceKlass* holder() { return _holder; }
529   const AccessFlags&amp; access_flags() { return _access_flags; }
530   const bool is_flattenable() { return _access_flags.is_flattenable(); }
531 };
532 
533 static int compare_offset(FieldDesc* f1, FieldDesc* f2) {
534    return f1-&gt;offset() &gt; f2-&gt;offset() ? 1 : -1;
535 }
536 
537 static void print_field(outputStream* st, int level, int offset, FieldDesc&amp; fd, bool flattenable, bool flattened ) {
538   const char* flattened_msg = &quot;&quot;;
539   if (flattenable) {
540     flattened_msg = flattened ? &quot;and flattened&quot; : &quot;not flattened&quot;;
541   }
542   st-&gt;print_cr(&quot;  @ %d %*s \&quot;%s\&quot; %s %s %s&quot;,
543       offset, level * 3, &quot;&quot;,
544       fd.name()-&gt;as_C_string(),
545       fd.signature()-&gt;as_C_string(),
546       flattenable ? &quot; // flattenable&quot; : &quot;&quot;,
547       flattened_msg);
548 }
549 
550 static void print_flattened_field(outputStream* st, int level, int offset, InstanceKlass* klass) {
551   assert(klass-&gt;is_value(), &quot;Only value classes can be flattened&quot;);
552   ValueKlass* vklass = ValueKlass::cast(klass);
553   GrowableArray&lt;FieldDesc&gt;* fields = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;FieldDesc&gt;(100, true);
554   for (FieldStream fd(klass, false, false); !fd.eos(); fd.next()) {
555     if (!fd.access_flags().is_static()) {
556       fields-&gt;append(FieldDesc(fd.field_descriptor()));
557     }
558   }
559   fields-&gt;sort(compare_offset);
560   for(int i = 0; i &lt; fields-&gt;length(); i++) {
561     FieldDesc fd = fields-&gt;at(i);
562     int offset2 = offset + fd.offset() - vklass-&gt;first_field_offset();
563     print_field(st, level, offset2, fd,
564         fd.is_flattenable(), fd.holder()-&gt;field_is_flattened(fd.index()));
565     if (fd.holder()-&gt;field_is_flattened(fd.index())) {
566       print_flattened_field(st, level + 1, offset2 ,
567           InstanceKlass::cast(fd.holder()-&gt;get_value_field_klass(fd.index())));
568     }
569   }
570 }
571 
572 void PrintClassLayout::print_class_layout(outputStream* st, char* class_name) {
573   KlassInfoTable cit(true);
574   if (cit.allocation_failed()) {
575     st-&gt;print_cr(&quot;ERROR: Ran out of C-heap; hierarchy not generated&quot;);
576     return;
577   }
578 
579   Thread* THREAD = Thread::current();
580 
581   Symbol* classname = SymbolTable::probe(class_name, (int)strlen(class_name));
582 
583   GrowableArray&lt;Klass*&gt;* klasses = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;Klass*&gt;(100, true);
584 
585   FindClassByNameClosure fbnc(klasses, classname);
586   cit.iterate(&amp;fbnc);
587 
588   for(int i = 0; i &lt; klasses-&gt;length(); i++) {
589     Klass* klass = klasses-&gt;at(i);
590     if (!klass-&gt;is_instance_klass()) continue;  // Skip
591     InstanceKlass* ik = InstanceKlass::cast(klass);
592     int tab = 1;
593     st-&gt;print_cr(&quot;Class %s [@%s]:&quot;, klass-&gt;name()-&gt;as_C_string(),
594         klass-&gt;class_loader_data()-&gt;name()-&gt;as_C_string());
595     ResourceMark rm;
596     GrowableArray&lt;FieldDesc&gt;* fields = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;FieldDesc&gt;(100, true);
597     for (FieldStream fd(ik, false, false); !fd.eos(); fd.next()) {
598       if (!fd.access_flags().is_static()) {
599         fields-&gt;append(FieldDesc(fd.field_descriptor()));
600       }
601     }
602     fields-&gt;sort(compare_offset);
603     for(int i = 0; i &lt; fields-&gt;length(); i++) {
604       FieldDesc fd = fields-&gt;at(i);
605       print_field(st, 0, fd.offset(), fd, fd.is_flattenable(), fd.holder()-&gt;field_is_flattened(fd.index()));
606       if (fd.holder()-&gt;field_is_flattened(fd.index())) {
607         print_flattened_field(st, 1, fd.offset(),
608             InstanceKlass::cast(fd.holder()-&gt;get_value_field_klass(fd.index())));
609       }
610     }
611   }
612   st-&gt;cr();
613 }
614 
615 class RecordInstanceClosure : public ObjectClosure {
616  private:
617   KlassInfoTable* _cit;
618   size_t _missed_count;
619   BoolObjectClosure* _filter;
620  public:
621   RecordInstanceClosure(KlassInfoTable* cit, BoolObjectClosure* filter) :
622     _cit(cit), _missed_count(0), _filter(filter) {}
623 
624   void do_object(oop obj) {
625     if (should_visit(obj)) {
626       if (!_cit-&gt;record_instance(obj)) {
627         _missed_count++;
628       }
629     }
630   }
631 
632   size_t missed_count() { return _missed_count; }
633 
634  private:
635   bool should_visit(oop obj) {
636     return _filter == NULL || _filter-&gt;do_object_b(obj);
637   }
638 };
639 
640 size_t HeapInspection::populate_table(KlassInfoTable* cit, BoolObjectClosure *filter) {
641   ResourceMark rm;
642 
643   RecordInstanceClosure ric(cit, filter);
644   Universe::heap()-&gt;object_iterate(&amp;ric);
645   return ric.missed_count();
646 }
647 
648 void HeapInspection::heap_inspection(outputStream* st) {
649   ResourceMark rm;
650 
651   KlassInfoTable cit(false);
652   if (!cit.allocation_failed()) {
653     // populate table with object allocation info
654     size_t missed_count = populate_table(&amp;cit);
655     if (missed_count != 0) {
656       log_info(gc, classhisto)(&quot;WARNING: Ran out of C-heap; undercounted &quot; SIZE_FORMAT
657                                &quot; total instances in data below&quot;,
658                                missed_count);
659     }
660 
661     // Sort and print klass instance info
662     KlassInfoHisto histo(&amp;cit);
663     HistoClosure hc(&amp;histo);
664 
665     cit.iterate(&amp;hc);
666 
667     histo.sort();
668     histo.print_histo_on(st);
669   } else {
670     st-&gt;print_cr(&quot;ERROR: Ran out of C-heap; histogram not generated&quot;);
671   }
672   st-&gt;flush();
673 }
674 
675 class FindInstanceClosure : public ObjectClosure {
676  private:
677   Klass* _klass;
678   GrowableArray&lt;oop&gt;* _result;
679 
680  public:
681   FindInstanceClosure(Klass* k, GrowableArray&lt;oop&gt;* result) : _klass(k), _result(result) {};
682 
683   void do_object(oop obj) {
684     if (obj-&gt;is_a(_klass)) {
685       // obj was read with AS_NO_KEEPALIVE, or equivalent.
686       // The object needs to be kept alive when it is published.
687       Universe::heap()-&gt;keep_alive(obj);
688 
689       _result-&gt;append(obj);
690     }
691   }
692 };
693 
694 void HeapInspection::find_instances_at_safepoint(Klass* k, GrowableArray&lt;oop&gt;* result) {
695   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);
696   assert(Heap_lock-&gt;is_locked(), &quot;should have the Heap_lock&quot;);
697 
698   // Ensure that the heap is parsable
699   Universe::heap()-&gt;ensure_parsability(false);  // no need to retire TALBs
700 
701   // Iterate over objects in the heap
702   FindInstanceClosure fic(k, result);
703   Universe::heap()-&gt;object_iterate(&amp;fic);
704 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
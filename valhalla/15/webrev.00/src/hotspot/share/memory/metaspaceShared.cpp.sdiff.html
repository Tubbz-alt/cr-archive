<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/metaspaceShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="memRegion.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspaceShared.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/metaspaceShared.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 448   soc-&gt;do_tag(objArrayOopDesc::base_offset_in_bytes());
 449   soc-&gt;do_tag(typeArrayOopDesc::base_offset_in_bytes(T_BYTE));
 450   soc-&gt;do_tag(sizeof(Symbol));
 451 
 452   // Dump/restore miscellaneous metadata.
 453   JavaClasses::serialize_offsets(soc);
 454   Universe::serialize(soc);
 455   soc-&gt;do_tag(--tag);
 456 
 457   // Dump/restore references to commonly used names and signatures.
 458   vmSymbols::serialize(soc);
 459   soc-&gt;do_tag(--tag);
 460 
 461   // Dump/restore the symbol/string/subgraph_info tables
 462   SymbolTable::serialize_shared_table_header(soc);
 463   StringTable::serialize_shared_table_header(soc);
 464   HeapShared::serialize_subgraph_info_table_header(soc);
 465   SystemDictionaryShared::serialize_dictionary_headers(soc);
 466 
 467   InstanceMirrorKlass::serialize_offsets(soc);



 468   soc-&gt;do_tag(--tag);
 469 
 470   serialize_cloned_cpp_vtptrs(soc);
 471   soc-&gt;do_tag(--tag);
 472 
 473   soc-&gt;do_tag(666);
 474 }
 475 
 476 address MetaspaceShared::i2i_entry_code_buffers(size_t total_size) {
 477   if (DumpSharedSpaces) {
 478     if (_i2i_entry_code_buffers == NULL) {
 479       _i2i_entry_code_buffers = (address)misc_code_space_alloc(total_size);
 480       _i2i_entry_code_buffers_size = total_size;
 481     }
 482   } else if (UseSharedSpaces) {
 483     assert(_i2i_entry_code_buffers != NULL, &quot;must already been initialized&quot;);
 484   } else {
 485     return NULL;
 486   }
 487 
</pre>
<hr />
<pre>
1089 #undef fmt_stats
1090 }
1091 
1092 // Populate the shared space.
1093 
1094 class VM_PopulateDumpSharedSpace: public VM_Operation {
1095 private:
1096   GrowableArray&lt;MemRegion&gt; *_closed_archive_heap_regions;
1097   GrowableArray&lt;MemRegion&gt; *_open_archive_heap_regions;
1098 
1099   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_closed_archive_heap_oopmaps;
1100   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_open_archive_heap_oopmaps;
1101 
1102   void dump_java_heap_objects() NOT_CDS_JAVA_HEAP_RETURN;
1103   void dump_archive_heap_oopmaps() NOT_CDS_JAVA_HEAP_RETURN;
1104   void dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1105                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps);
1106   void dump_symbols();
1107   char* dump_read_only_tables();
1108   void print_class_stats();
<span class="line-modified">1109   void print_region_stats();</span>
1110   void print_bitmap_region_stats(size_t size, size_t total_size);
1111   void print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
1112                                const char *name, size_t total_size);
1113   void relocate_to_default_base_address(CHeapBitMap* ptrmap);
1114 
1115 public:
1116 
1117   VMOp_Type type() const { return VMOp_PopulateDumpSharedSpace; }
1118   void doit();   // outline because gdb sucks
1119   bool allow_nested_vm_operations() const { return true; }
1120 }; // class VM_PopulateDumpSharedSpace
1121 
1122 class SortedSymbolClosure: public SymbolClosure {
1123   GrowableArray&lt;Symbol*&gt; _symbols;
1124   virtual void do_symbol(Symbol** sym) {
1125     assert((*sym)-&gt;is_permanent(), &quot;archived symbols must be permanent&quot;);
1126     _symbols.append(*sym);
1127   }
1128   static int compare_symbols_by_address(Symbol** a, Symbol** b) {
1129     if (a[0] &lt; b[0]) {
</pre>
<hr />
<pre>
1375     }
1376     // NOTE: after this point, we shouldn&#39;t have any globals that can reach the old
1377     // objects.
1378 
1379     // We cannot use any of the objects in the heap anymore (except for the
1380     // shared strings) because their headers no longer point to valid Klasses.
1381   }
1382 
1383   static void iterate_roots(MetaspaceClosure* it) {
1384     GrowableArray&lt;Symbol*&gt;* symbols = _ssc-&gt;get_sorted_symbols();
1385     for (int i=0; i&lt;symbols-&gt;length(); i++) {
1386       it-&gt;push(symbols-&gt;adr_at(i));
1387     }
1388     if (_global_klass_objects != NULL) {
1389       // Need to fix up the pointers
1390       for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1391         // NOTE -- this requires that the vtable is NOT yet patched, or else we are hosed.
1392         it-&gt;push(_global_klass_objects-&gt;adr_at(i));
1393       }
1394     }
<span class="line-modified">1395     FileMapInfo::metaspace_pointers_do(it);</span>
1396     SystemDictionaryShared::dumptime_classes_do(it);
1397     Universe::metaspace_pointers_do(it);
1398     SymbolTable::metaspace_pointers_do(it);
1399     vmSymbols::metaspace_pointers_do(it);
1400 
1401     it-&gt;finish();
1402   }
1403 
1404   static Klass* get_relocated_klass(Klass* orig_klass) {
1405     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1406     address* pp = _new_loc_table-&gt;lookup((address)orig_klass);
1407     assert(pp != NULL, &quot;must be&quot;);
1408     Klass* klass = (Klass*)(*pp);
1409     assert(klass-&gt;is_klass(), &quot;must be&quot;);
1410     return klass;
1411   }
1412 };
1413 
1414 DumpAllocStats* ArchiveCompactor::_alloc_stats;
1415 SortedSymbolClosure* ArchiveCompactor::_ssc;
</pre>
<hr />
<pre>
1423 }
1424 
1425 char* VM_PopulateDumpSharedSpace::dump_read_only_tables() {
1426   ArchiveCompactor::OtherROAllocMark mark;
1427 
1428   log_info(cds)(&quot;Removing java_mirror ... &quot;);
1429   if (!HeapShared::is_heap_object_archiving_allowed()) {
1430     clear_basic_type_mirrors();
1431   }
1432   remove_java_mirror_in_classes();
1433   log_info(cds)(&quot;done. &quot;);
1434 
1435   SystemDictionaryShared::write_to_archive();
1436 
1437   // Write the other data to the output array.
1438   char* start = _ro_region.top();
1439   WriteClosure wc(&amp;_ro_region);
1440   MetaspaceShared::serialize(&amp;wc);
1441 
1442   // Write the bitmaps for patching the archive heap regions


1443   dump_archive_heap_oopmaps();
1444 
1445   return start;
1446 }
1447 
1448 void VM_PopulateDumpSharedSpace::print_class_stats() {
1449   log_info(cds)(&quot;Number of classes %d&quot;, _global_klass_objects-&gt;length());
1450   {
1451     int num_type_array = 0, num_obj_array = 0, num_inst = 0;
1452     for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1453       Klass* k = _global_klass_objects-&gt;at(i);
1454       if (k-&gt;is_instance_klass()) {
1455         num_inst ++;
1456       } else if (k-&gt;is_objArray_klass()) {
1457         num_obj_array ++;
1458       } else {
1459         assert(k-&gt;is_typeArray_klass(), &quot;sanity&quot;);
1460         num_type_array ++;
1461       }
1462     }
</pre>
<hr />
<pre>
1572   char* serialized_data = dump_read_only_tables();
1573   _ro_region.pack();
1574 
1575   // The vtable clones contain addresses of the current process.
1576   // We don&#39;t want to write these addresses into the archive.
1577   MetaspaceShared::zero_cpp_vtable_clones_for_writing();
1578 
1579   // relocate the data so that it can be mapped to Arguments::default_SharedBaseAddress()
1580   // without runtime relocation.
1581   relocate_to_default_base_address(&amp;ptrmap);
1582 
1583   // Create and write the archive file that maps the shared spaces.
1584 
1585   FileMapInfo* mapinfo = new FileMapInfo(true);
1586   mapinfo-&gt;populate_header(os::vm_allocation_granularity());
1587   mapinfo-&gt;set_serialized_data(serialized_data);
1588   mapinfo-&gt;set_cloned_vtables(cloned_vtables);
1589   mapinfo-&gt;set_i2i_entry_code_buffers(MetaspaceShared::i2i_entry_code_buffers(),
1590                                       MetaspaceShared::i2i_entry_code_buffers_size());
1591   mapinfo-&gt;open_for_write();
<span class="line-modified">1592   MetaspaceShared::write_core_archive_regions(mapinfo);</span>
1593   _total_closed_archive_region_size = mapinfo-&gt;write_archive_heap_regions(
1594                                         _closed_archive_heap_regions,
1595                                         _closed_archive_heap_oopmaps,
1596                                         MetaspaceShared::first_closed_archive_heap_region,
1597                                         MetaspaceShared::max_closed_archive_heap_region);
1598   _total_open_archive_region_size = mapinfo-&gt;write_archive_heap_regions(
1599                                         _open_archive_heap_regions,
1600                                         _open_archive_heap_oopmaps,
1601                                         MetaspaceShared::first_open_archive_heap_region,
1602                                         MetaspaceShared::max_open_archive_heap_region);
1603 
1604   mapinfo-&gt;set_final_requested_base((char*)Arguments::default_SharedBaseAddress());
1605   mapinfo-&gt;set_header_crc(mapinfo-&gt;compute_header_crc());
1606   mapinfo-&gt;write_header();

1607   mapinfo-&gt;close();
1608 
<span class="line-removed">1609   print_region_stats();</span>
<span class="line-removed">1610 </span>
1611   if (log_is_enabled(Info, cds)) {
1612     ArchiveCompactor::alloc_stats()-&gt;print_stats(int(_ro_region.used()), int(_rw_region.used()),
1613                                                  int(_mc_region.used()));
1614   }
1615 
1616   if (PrintSystemDictionaryAtExit) {
1617     SystemDictionary::print();
1618   }
1619 
1620   if (AllowArchivingWithJavaAgent) {
1621     warning(&quot;This archive was created with AllowArchivingWithJavaAgent. It should be used &quot;
1622             &quot;for testing purposes only and should not be used in a production environment&quot;);
1623   }
1624 
1625   // There may be other pending VM operations that operate on the InstanceKlasses,
1626   // which will fail because InstanceKlasses::remove_unshareable_info()
1627   // has been called. Forget these operations and exit the VM directly.
1628   vm_direct_exit(0);
1629 }
1630 
<span class="line-modified">1631 void VM_PopulateDumpSharedSpace::print_region_stats() {</span>
1632   // Print statistics of all the regions
<span class="line-modified">1633   const size_t bitmap_used = ArchivePtrMarker::ptrmap()-&gt;size_in_bytes();</span>
<span class="line-modified">1634   const size_t bitmap_reserved = align_up(bitmap_used, Metaspace::reserve_alignment());</span>
1635   const size_t total_reserved = _ro_region.reserved()  + _rw_region.reserved() +
1636                                 _mc_region.reserved()  +
1637                                 bitmap_reserved +
1638                                 _total_closed_archive_region_size +
1639                                 _total_open_archive_region_size;
1640   const size_t total_bytes = _ro_region.used()  + _rw_region.used() +
1641                              _mc_region.used()  +
1642                              bitmap_used +
1643                              _total_closed_archive_region_size +
1644                              _total_open_archive_region_size;
1645   const double total_u_perc = percent_of(total_bytes, total_reserved);
1646 
1647   _mc_region.print(total_reserved);
1648   _rw_region.print(total_reserved);
1649   _ro_region.print(total_reserved);
1650   print_bitmap_region_stats(bitmap_reserved, total_reserved);
1651   print_heap_region_stats(_closed_archive_heap_regions, &quot;ca&quot;, total_reserved);
1652   print_heap_region_stats(_open_archive_heap_regions, &quot;oa&quot;, total_reserved);
1653 
1654   log_debug(cds)(&quot;total    : &quot; SIZE_FORMAT_W(9) &quot; [100.0%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [%5.1f%% used]&quot;,
</pre>
<hr />
<pre>
1656 }
1657 
1658 void VM_PopulateDumpSharedSpace::print_bitmap_region_stats(size_t size, size_t total_size) {
1659   log_debug(cds)(&quot;bm  space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [100.0%% used] at &quot; INTPTR_FORMAT,
1660                  size, size/double(total_size)*100.0, size, p2i(NULL));
1661 }
1662 
1663 void VM_PopulateDumpSharedSpace::print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
1664                                                          const char *name, size_t total_size) {
1665   int arr_len = heap_mem == NULL ? 0 : heap_mem-&gt;length();
1666   for (int i = 0; i &lt; arr_len; i++) {
1667       char* start = (char*)heap_mem-&gt;at(i).start();
1668       size_t size = heap_mem-&gt;at(i).byte_size();
1669       char* top = start + size;
1670       log_debug(cds)(&quot;%s%d space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [100.0%% used] at &quot; INTPTR_FORMAT,
1671                      name, i, size, size/double(total_size)*100.0, size, p2i(start));
1672 
1673   }
1674 }
1675 
<span class="line-modified">1676 void MetaspaceShared::write_core_archive_regions(FileMapInfo* mapinfo) {</span>


1677   // Make sure NUM_CDS_REGIONS (exported in cds.h) agrees with
1678   // MetaspaceShared::n_regions (internal to hotspot).
1679   assert(NUM_CDS_REGIONS == MetaspaceShared::n_regions, &quot;sanity&quot;);
1680 
1681   // mc contains the trampoline code for method entries, which are patched at run time,
1682   // so it needs to be read/write.
1683   write_region(mapinfo, mc, &amp;_mc_region, /*read_only=*/false,/*allow_exec=*/true);
1684   write_region(mapinfo, rw, &amp;_rw_region, /*read_only=*/false,/*allow_exec=*/false);
1685   write_region(mapinfo, ro, &amp;_ro_region, /*read_only=*/true, /*allow_exec=*/false);
<span class="line-modified">1686   mapinfo-&gt;write_bitmap_region(ArchivePtrMarker::ptrmap());</span>
1687 }
1688 
1689 void MetaspaceShared::write_region(FileMapInfo* mapinfo, int region_idx, DumpRegion* dump_region, bool read_only,  bool allow_exec) {
1690   mapinfo-&gt;write_region(region_idx, dump_region-&gt;base(), dump_region-&gt;used(), read_only, allow_exec);
1691 }
1692 
1693 // Update a Java object to point its Klass* to the new location after
1694 // shared archive has been compacted.
1695 void MetaspaceShared::relocate_klass_ptr(oop o) {
1696   assert(DumpSharedSpaces, &quot;sanity&quot;);
1697   Klass* k = ArchiveCompactor::get_relocated_klass(o-&gt;klass());
1698   o-&gt;set_klass(k);
1699 }
1700 
1701 Klass* MetaspaceShared::get_relocated_klass(Klass *k, bool is_final) {
1702   assert(DumpSharedSpaces, &quot;sanity&quot;);
1703   k = ArchiveCompactor::get_relocated_klass(k);
1704   if (is_final) {
1705     k = (Klass*)(address(k) + final_delta());
1706   }
1707   return k;
1708 }
1709 
1710 class LinkSharedClassesClosure : public KlassClosure {
1711   Thread* THREAD;
1712   bool    _made_progress;
1713  public:
1714   LinkSharedClassesClosure(Thread* thread) : THREAD(thread), _made_progress(false) {}
1715 
1716   void reset()               { _made_progress = false; }
1717   bool made_progress() const { return _made_progress; }
1718 
1719   void do_klass(Klass* k) {
1720     if (k-&gt;is_instance_klass()) {
1721       InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">1722       // Link the class to cause the bytecodes to be rewritten and the</span>
<span class="line-modified">1723       // cpcache to be created. Class verification is done according</span>
<span class="line-modified">1724       // to -Xverify setting.</span>
<span class="line-modified">1725       _made_progress |= MetaspaceShared::try_link_class(ik, THREAD);</span>
<span class="line-modified">1726       guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);</span>
<span class="line-modified">1727 </span>
<span class="line-modified">1728       ik-&gt;constants()-&gt;resolve_class_constants(THREAD);</span>
<span class="line-modified">1729     }</span>
<span class="line-removed">1730   }</span>
<span class="line-removed">1731 };</span>
<span class="line-removed">1732 </span>
<span class="line-removed">1733 class CheckSharedClassesClosure : public KlassClosure {</span>
<span class="line-removed">1734   bool    _made_progress;</span>
<span class="line-removed">1735  public:</span>
<span class="line-removed">1736   CheckSharedClassesClosure() : _made_progress(false) {}</span>
1737 
<span class="line-modified">1738   void reset()               { _made_progress = false; }</span>
<span class="line-modified">1739   bool made_progress() const { return _made_progress; }</span>
<span class="line-modified">1740   void do_klass(Klass* k) {</span>
<span class="line-modified">1741     if (k-&gt;is_instance_klass() &amp;&amp; InstanceKlass::cast(k)-&gt;check_sharing_error_state()) {</span>
<span class="line-modified">1742       _made_progress = true;</span>


1743     }
1744   }
1745 };
1746 
1747 void MetaspaceShared::link_and_cleanup_shared_classes(TRAPS) {
1748   // We need to iterate because verification may cause additional classes
1749   // to be loaded.
1750   LinkSharedClassesClosure link_closure(THREAD);
1751   do {
1752     link_closure.reset();
1753     ClassLoaderDataGraph::unlocked_loaded_classes_do(&amp;link_closure);
1754     guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1755   } while (link_closure.made_progress());
<span class="line-removed">1756 </span>
<span class="line-removed">1757   if (_has_error_classes) {</span>
<span class="line-removed">1758     // Mark all classes whose super class or interfaces failed verification.</span>
<span class="line-removed">1759     CheckSharedClassesClosure check_closure;</span>
<span class="line-removed">1760     do {</span>
<span class="line-removed">1761       // Not completely sure if we need to do this iteratively. Anyway,</span>
<span class="line-removed">1762       // we should come here only if there are unverifiable classes, which</span>
<span class="line-removed">1763       // shouldn&#39;t happen in normal cases. So better safe than sorry.</span>
<span class="line-removed">1764       check_closure.reset();</span>
<span class="line-removed">1765       ClassLoaderDataGraph::unlocked_loaded_classes_do(&amp;check_closure);</span>
<span class="line-removed">1766     } while (check_closure.made_progress());</span>
<span class="line-removed">1767   }</span>
1768 }
1769 
1770 void MetaspaceShared::prepare_for_dumping() {
1771   Arguments::check_unsupported_dumping_properties();
1772   ClassLoader::initialize_shared_path();
1773 }
1774 
1775 // Preload classes from a list, populate the shared spaces and dump to a
1776 // file.
1777 void MetaspaceShared::preload_and_dump(TRAPS) {
1778   { TraceTime timer(&quot;Dump Shared Spaces&quot;, TRACETIME_LOG(Info, startuptime));
1779     ResourceMark rm(THREAD);
1780     char class_list_path_str[JVM_MAXPATHLEN];
1781     // Preload classes to be shared.
1782     const char* class_list_path;
1783     if (SharedClassListFile == NULL) {
1784       // Construct the path to the class list (in jre/lib)
1785       // Walk up two directories from the location of the VM and
1786       // optionally tack on &quot;lib&quot; (depending on platform)
1787       os::jvm_path(class_list_path_str, sizeof(class_list_path_str));
</pre>
<hr />
<pre>
1874       if (klass-&gt;is_instance_klass()) {
1875         InstanceKlass* ik = InstanceKlass::cast(klass);
1876 
1877         // Link the class to cause the bytecodes to be rewritten and the
1878         // cpcache to be created. The linking is done as soon as classes
1879         // are loaded in order that the related data structures (klass and
1880         // cpCache) are located together.
1881         try_link_class(ik, THREAD);
1882         guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1883       }
1884 
1885       class_count++;
1886     }
1887   }
1888 
1889   return class_count;
1890 }
1891 
1892 // Returns true if the class&#39;s status has changed
1893 bool MetaspaceShared::try_link_class(InstanceKlass* ik, TRAPS) {
<span class="line-modified">1894   assert(DumpSharedSpaces, &quot;should only be called during dumping&quot;);</span>
<span class="line-modified">1895   if (ik-&gt;init_state() &lt; InstanceKlass::linked) {</span>

1896     bool saved = BytecodeVerificationLocal;
<span class="line-modified">1897     if (ik-&gt;loader_type() == 0 &amp;&amp; ik-&gt;class_loader() == NULL) {</span>
1898       // The verification decision is based on BytecodeVerificationRemote
1899       // for non-system classes. Since we are using the NULL classloader
1900       // to load non-system classes for customized class loaders during dumping,
1901       // we need to temporarily change BytecodeVerificationLocal to be the same as
1902       // BytecodeVerificationRemote. Note this can cause the parent system
1903       // classes also being verified. The extra overhead is acceptable during
1904       // dumping.
1905       BytecodeVerificationLocal = BytecodeVerificationRemote;
1906     }
1907     ik-&gt;link_class(THREAD);
1908     if (HAS_PENDING_EXCEPTION) {
1909       ResourceMark rm(THREAD);
1910       log_warning(cds)(&quot;Preload Warning: Verification failed for %s&quot;,
1911                     ik-&gt;external_name());
1912       CLEAR_PENDING_EXCEPTION;
<span class="line-modified">1913       ik-&gt;set_in_error_state();</span>
1914       _has_error_classes = true;
1915     }
1916     BytecodeVerificationLocal = saved;
1917     return true;
1918   } else {
1919     return false;
1920   }
1921 }
1922 
1923 #if INCLUDE_CDS_JAVA_HEAP
1924 void VM_PopulateDumpSharedSpace::dump_java_heap_objects() {
1925   // The closed and open archive heap space has maximum two regions.
1926   // See FileMapInfo::write_archive_heap_regions() for details.
1927   _closed_archive_heap_regions = new GrowableArray&lt;MemRegion&gt;(2);
1928   _open_archive_heap_regions = new GrowableArray&lt;MemRegion&gt;(2);
1929   HeapShared::archive_java_heap_objects(_closed_archive_heap_regions,
1930                                         _open_archive_heap_regions);
1931   ArchiveCompactor::OtherROAllocMark mark;
1932   HeapShared::write_subgraph_info_table();
1933 }
1934 
1935 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps() {
1936   if (HeapShared::is_heap_object_archiving_allowed()) {
1937     _closed_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
1938     dump_archive_heap_oopmaps(_closed_archive_heap_regions, _closed_archive_heap_oopmaps);
1939 
1940     _open_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
1941     dump_archive_heap_oopmaps(_open_archive_heap_regions, _open_archive_heap_oopmaps);
1942   }
1943 }
1944 
1945 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1946                                                            GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps) {
1947   for (int i=0; i&lt;regions-&gt;length(); i++) {
1948     ResourceBitMap oopmap = HeapShared::calculate_oopmap(regions-&gt;at(i));
1949     size_t size_in_bits = oopmap.size();
1950     size_t size_in_bytes = oopmap.size_in_bytes();
<span class="line-modified">1951     uintptr_t* buffer = (uintptr_t*)_ro_region.allocate(size_in_bytes, sizeof(intptr_t));</span>
1952     oopmap.write_to(buffer, size_in_bytes);
1953     log_info(cds, heap)(&quot;Oopmap = &quot; INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(6) &quot; bytes) for heap region &quot;
1954                         INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(8) &quot; bytes)&quot;,
1955                         p2i(buffer), size_in_bytes,
1956                         p2i(regions-&gt;at(i).start()), regions-&gt;at(i).byte_size());
1957 
1958     ArchiveHeapOopmapInfo info;
1959     info._oopmap = (address)buffer;
1960     info._oopmap_size_in_bits = size_in_bits;

1961     oopmaps-&gt;append(info);
1962   }
1963 }
1964 #endif // INCLUDE_CDS_JAVA_HEAP
1965 
1966 void ReadClosure::do_ptr(void** p) {
1967   assert(*p == NULL, &quot;initializing previous initialized pointer.&quot;);
1968   intptr_t obj = nextPtr();
1969   assert((intptr_t)obj &gt;= 0 || (intptr_t)obj &lt; -100,
1970          &quot;hit tag while initializing ptrs.&quot;);
1971   *p = (void*)obj;
1972 }
1973 
1974 void ReadClosure::do_u4(u4* p) {
1975   intptr_t obj = nextPtr();
1976   *p = (u4)(uintx(obj));
1977 }
1978 
1979 void ReadClosure::do_bool(bool* p) {
1980   intptr_t obj = nextPtr();
</pre>
<hr />
<pre>
2364   _i2i_entry_code_buffers = static_mapinfo-&gt;i2i_entry_code_buffers();
2365   _i2i_entry_code_buffers_size = static_mapinfo-&gt;i2i_entry_code_buffers_size();
2366   char* buffer = static_mapinfo-&gt;cloned_vtables();
2367   clone_cpp_vtables((intptr_t*)buffer);
2368 
2369   // Verify various attributes of the archive, plus initialize the
2370   // shared string/symbol tables
2371   buffer = static_mapinfo-&gt;serialized_data();
2372   intptr_t* array = (intptr_t*)buffer;
2373   ReadClosure rc(&amp;array);
2374   serialize(&amp;rc);
2375 
2376   // Initialize the run-time symbol table.
2377   SymbolTable::create_table();
2378 
2379   static_mapinfo-&gt;patch_archived_heap_embedded_pointers();
2380 
2381   // Close the mapinfo file
2382   static_mapinfo-&gt;close();
2383 


2384   FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();
2385   if (dynamic_mapinfo != NULL) {
2386     intptr_t* buffer = (intptr_t*)dynamic_mapinfo-&gt;serialized_data();
2387     ReadClosure rc(&amp;buffer);
2388     SymbolTable::serialize_shared_table_header(&amp;rc, false);
2389     SystemDictionaryShared::serialize_dictionary_headers(&amp;rc, false);
2390     dynamic_mapinfo-&gt;close();
2391   }
2392 
2393   if (PrintSharedArchiveAndExit) {
2394     if (PrintSharedDictionary) {
2395       tty-&gt;print_cr(&quot;\nShared classes:\n&quot;);
2396       SystemDictionaryShared::print_on(tty);
2397     }
2398     if (FileMapInfo::current_info() == NULL || _archive_loading_failed) {
2399       tty-&gt;print_cr(&quot;archive is invalid&quot;);
2400       vm_exit(1);
2401     } else {
2402       tty-&gt;print_cr(&quot;archive is valid&quot;);
2403       vm_exit(0);
</pre>
</td>
<td>
<hr />
<pre>
 448   soc-&gt;do_tag(objArrayOopDesc::base_offset_in_bytes());
 449   soc-&gt;do_tag(typeArrayOopDesc::base_offset_in_bytes(T_BYTE));
 450   soc-&gt;do_tag(sizeof(Symbol));
 451 
 452   // Dump/restore miscellaneous metadata.
 453   JavaClasses::serialize_offsets(soc);
 454   Universe::serialize(soc);
 455   soc-&gt;do_tag(--tag);
 456 
 457   // Dump/restore references to commonly used names and signatures.
 458   vmSymbols::serialize(soc);
 459   soc-&gt;do_tag(--tag);
 460 
 461   // Dump/restore the symbol/string/subgraph_info tables
 462   SymbolTable::serialize_shared_table_header(soc);
 463   StringTable::serialize_shared_table_header(soc);
 464   HeapShared::serialize_subgraph_info_table_header(soc);
 465   SystemDictionaryShared::serialize_dictionary_headers(soc);
 466 
 467   InstanceMirrorKlass::serialize_offsets(soc);
<span class="line-added"> 468 </span>
<span class="line-added"> 469   // Dump/restore well known classes (pointers)</span>
<span class="line-added"> 470   SystemDictionaryShared::serialize_well_known_klasses(soc);</span>
 471   soc-&gt;do_tag(--tag);
 472 
 473   serialize_cloned_cpp_vtptrs(soc);
 474   soc-&gt;do_tag(--tag);
 475 
 476   soc-&gt;do_tag(666);
 477 }
 478 
 479 address MetaspaceShared::i2i_entry_code_buffers(size_t total_size) {
 480   if (DumpSharedSpaces) {
 481     if (_i2i_entry_code_buffers == NULL) {
 482       _i2i_entry_code_buffers = (address)misc_code_space_alloc(total_size);
 483       _i2i_entry_code_buffers_size = total_size;
 484     }
 485   } else if (UseSharedSpaces) {
 486     assert(_i2i_entry_code_buffers != NULL, &quot;must already been initialized&quot;);
 487   } else {
 488     return NULL;
 489   }
 490 
</pre>
<hr />
<pre>
1092 #undef fmt_stats
1093 }
1094 
1095 // Populate the shared space.
1096 
1097 class VM_PopulateDumpSharedSpace: public VM_Operation {
1098 private:
1099   GrowableArray&lt;MemRegion&gt; *_closed_archive_heap_regions;
1100   GrowableArray&lt;MemRegion&gt; *_open_archive_heap_regions;
1101 
1102   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_closed_archive_heap_oopmaps;
1103   GrowableArray&lt;ArchiveHeapOopmapInfo&gt; *_open_archive_heap_oopmaps;
1104 
1105   void dump_java_heap_objects() NOT_CDS_JAVA_HEAP_RETURN;
1106   void dump_archive_heap_oopmaps() NOT_CDS_JAVA_HEAP_RETURN;
1107   void dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1108                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps);
1109   void dump_symbols();
1110   char* dump_read_only_tables();
1111   void print_class_stats();
<span class="line-modified">1112   void print_region_stats(FileMapInfo* map_info);</span>
1113   void print_bitmap_region_stats(size_t size, size_t total_size);
1114   void print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
1115                                const char *name, size_t total_size);
1116   void relocate_to_default_base_address(CHeapBitMap* ptrmap);
1117 
1118 public:
1119 
1120   VMOp_Type type() const { return VMOp_PopulateDumpSharedSpace; }
1121   void doit();   // outline because gdb sucks
1122   bool allow_nested_vm_operations() const { return true; }
1123 }; // class VM_PopulateDumpSharedSpace
1124 
1125 class SortedSymbolClosure: public SymbolClosure {
1126   GrowableArray&lt;Symbol*&gt; _symbols;
1127   virtual void do_symbol(Symbol** sym) {
1128     assert((*sym)-&gt;is_permanent(), &quot;archived symbols must be permanent&quot;);
1129     _symbols.append(*sym);
1130   }
1131   static int compare_symbols_by_address(Symbol** a, Symbol** b) {
1132     if (a[0] &lt; b[0]) {
</pre>
<hr />
<pre>
1378     }
1379     // NOTE: after this point, we shouldn&#39;t have any globals that can reach the old
1380     // objects.
1381 
1382     // We cannot use any of the objects in the heap anymore (except for the
1383     // shared strings) because their headers no longer point to valid Klasses.
1384   }
1385 
1386   static void iterate_roots(MetaspaceClosure* it) {
1387     GrowableArray&lt;Symbol*&gt;* symbols = _ssc-&gt;get_sorted_symbols();
1388     for (int i=0; i&lt;symbols-&gt;length(); i++) {
1389       it-&gt;push(symbols-&gt;adr_at(i));
1390     }
1391     if (_global_klass_objects != NULL) {
1392       // Need to fix up the pointers
1393       for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1394         // NOTE -- this requires that the vtable is NOT yet patched, or else we are hosed.
1395         it-&gt;push(_global_klass_objects-&gt;adr_at(i));
1396       }
1397     }
<span class="line-modified">1398     FileMapInfo::metaspace_pointers_do(it, false);</span>
1399     SystemDictionaryShared::dumptime_classes_do(it);
1400     Universe::metaspace_pointers_do(it);
1401     SymbolTable::metaspace_pointers_do(it);
1402     vmSymbols::metaspace_pointers_do(it);
1403 
1404     it-&gt;finish();
1405   }
1406 
1407   static Klass* get_relocated_klass(Klass* orig_klass) {
1408     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1409     address* pp = _new_loc_table-&gt;lookup((address)orig_klass);
1410     assert(pp != NULL, &quot;must be&quot;);
1411     Klass* klass = (Klass*)(*pp);
1412     assert(klass-&gt;is_klass(), &quot;must be&quot;);
1413     return klass;
1414   }
1415 };
1416 
1417 DumpAllocStats* ArchiveCompactor::_alloc_stats;
1418 SortedSymbolClosure* ArchiveCompactor::_ssc;
</pre>
<hr />
<pre>
1426 }
1427 
1428 char* VM_PopulateDumpSharedSpace::dump_read_only_tables() {
1429   ArchiveCompactor::OtherROAllocMark mark;
1430 
1431   log_info(cds)(&quot;Removing java_mirror ... &quot;);
1432   if (!HeapShared::is_heap_object_archiving_allowed()) {
1433     clear_basic_type_mirrors();
1434   }
1435   remove_java_mirror_in_classes();
1436   log_info(cds)(&quot;done. &quot;);
1437 
1438   SystemDictionaryShared::write_to_archive();
1439 
1440   // Write the other data to the output array.
1441   char* start = _ro_region.top();
1442   WriteClosure wc(&amp;_ro_region);
1443   MetaspaceShared::serialize(&amp;wc);
1444 
1445   // Write the bitmaps for patching the archive heap regions
<span class="line-added">1446   _closed_archive_heap_oopmaps = NULL;</span>
<span class="line-added">1447   _open_archive_heap_oopmaps = NULL;</span>
1448   dump_archive_heap_oopmaps();
1449 
1450   return start;
1451 }
1452 
1453 void VM_PopulateDumpSharedSpace::print_class_stats() {
1454   log_info(cds)(&quot;Number of classes %d&quot;, _global_klass_objects-&gt;length());
1455   {
1456     int num_type_array = 0, num_obj_array = 0, num_inst = 0;
1457     for (int i = 0; i &lt; _global_klass_objects-&gt;length(); i++) {
1458       Klass* k = _global_klass_objects-&gt;at(i);
1459       if (k-&gt;is_instance_klass()) {
1460         num_inst ++;
1461       } else if (k-&gt;is_objArray_klass()) {
1462         num_obj_array ++;
1463       } else {
1464         assert(k-&gt;is_typeArray_klass(), &quot;sanity&quot;);
1465         num_type_array ++;
1466       }
1467     }
</pre>
<hr />
<pre>
1577   char* serialized_data = dump_read_only_tables();
1578   _ro_region.pack();
1579 
1580   // The vtable clones contain addresses of the current process.
1581   // We don&#39;t want to write these addresses into the archive.
1582   MetaspaceShared::zero_cpp_vtable_clones_for_writing();
1583 
1584   // relocate the data so that it can be mapped to Arguments::default_SharedBaseAddress()
1585   // without runtime relocation.
1586   relocate_to_default_base_address(&amp;ptrmap);
1587 
1588   // Create and write the archive file that maps the shared spaces.
1589 
1590   FileMapInfo* mapinfo = new FileMapInfo(true);
1591   mapinfo-&gt;populate_header(os::vm_allocation_granularity());
1592   mapinfo-&gt;set_serialized_data(serialized_data);
1593   mapinfo-&gt;set_cloned_vtables(cloned_vtables);
1594   mapinfo-&gt;set_i2i_entry_code_buffers(MetaspaceShared::i2i_entry_code_buffers(),
1595                                       MetaspaceShared::i2i_entry_code_buffers_size());
1596   mapinfo-&gt;open_for_write();
<span class="line-modified">1597   MetaspaceShared::write_core_archive_regions(mapinfo, _closed_archive_heap_oopmaps, _open_archive_heap_oopmaps);</span>
1598   _total_closed_archive_region_size = mapinfo-&gt;write_archive_heap_regions(
1599                                         _closed_archive_heap_regions,
1600                                         _closed_archive_heap_oopmaps,
1601                                         MetaspaceShared::first_closed_archive_heap_region,
1602                                         MetaspaceShared::max_closed_archive_heap_region);
1603   _total_open_archive_region_size = mapinfo-&gt;write_archive_heap_regions(
1604                                         _open_archive_heap_regions,
1605                                         _open_archive_heap_oopmaps,
1606                                         MetaspaceShared::first_open_archive_heap_region,
1607                                         MetaspaceShared::max_open_archive_heap_region);
1608 
1609   mapinfo-&gt;set_final_requested_base((char*)Arguments::default_SharedBaseAddress());
1610   mapinfo-&gt;set_header_crc(mapinfo-&gt;compute_header_crc());
1611   mapinfo-&gt;write_header();
<span class="line-added">1612   print_region_stats(mapinfo);</span>
1613   mapinfo-&gt;close();
1614 


1615   if (log_is_enabled(Info, cds)) {
1616     ArchiveCompactor::alloc_stats()-&gt;print_stats(int(_ro_region.used()), int(_rw_region.used()),
1617                                                  int(_mc_region.used()));
1618   }
1619 
1620   if (PrintSystemDictionaryAtExit) {
1621     SystemDictionary::print();
1622   }
1623 
1624   if (AllowArchivingWithJavaAgent) {
1625     warning(&quot;This archive was created with AllowArchivingWithJavaAgent. It should be used &quot;
1626             &quot;for testing purposes only and should not be used in a production environment&quot;);
1627   }
1628 
1629   // There may be other pending VM operations that operate on the InstanceKlasses,
1630   // which will fail because InstanceKlasses::remove_unshareable_info()
1631   // has been called. Forget these operations and exit the VM directly.
1632   vm_direct_exit(0);
1633 }
1634 
<span class="line-modified">1635 void VM_PopulateDumpSharedSpace::print_region_stats(FileMapInfo *map_info) {</span>
1636   // Print statistics of all the regions
<span class="line-modified">1637   const size_t bitmap_used = map_info-&gt;space_at(MetaspaceShared::bm)-&gt;used();</span>
<span class="line-modified">1638   const size_t bitmap_reserved = map_info-&gt;space_at(MetaspaceShared::bm)-&gt;used_aligned();</span>
1639   const size_t total_reserved = _ro_region.reserved()  + _rw_region.reserved() +
1640                                 _mc_region.reserved()  +
1641                                 bitmap_reserved +
1642                                 _total_closed_archive_region_size +
1643                                 _total_open_archive_region_size;
1644   const size_t total_bytes = _ro_region.used()  + _rw_region.used() +
1645                              _mc_region.used()  +
1646                              bitmap_used +
1647                              _total_closed_archive_region_size +
1648                              _total_open_archive_region_size;
1649   const double total_u_perc = percent_of(total_bytes, total_reserved);
1650 
1651   _mc_region.print(total_reserved);
1652   _rw_region.print(total_reserved);
1653   _ro_region.print(total_reserved);
1654   print_bitmap_region_stats(bitmap_reserved, total_reserved);
1655   print_heap_region_stats(_closed_archive_heap_regions, &quot;ca&quot;, total_reserved);
1656   print_heap_region_stats(_open_archive_heap_regions, &quot;oa&quot;, total_reserved);
1657 
1658   log_debug(cds)(&quot;total    : &quot; SIZE_FORMAT_W(9) &quot; [100.0%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [%5.1f%% used]&quot;,
</pre>
<hr />
<pre>
1660 }
1661 
1662 void VM_PopulateDumpSharedSpace::print_bitmap_region_stats(size_t size, size_t total_size) {
1663   log_debug(cds)(&quot;bm  space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [100.0%% used] at &quot; INTPTR_FORMAT,
1664                  size, size/double(total_size)*100.0, size, p2i(NULL));
1665 }
1666 
1667 void VM_PopulateDumpSharedSpace::print_heap_region_stats(GrowableArray&lt;MemRegion&gt; *heap_mem,
1668                                                          const char *name, size_t total_size) {
1669   int arr_len = heap_mem == NULL ? 0 : heap_mem-&gt;length();
1670   for (int i = 0; i &lt; arr_len; i++) {
1671       char* start = (char*)heap_mem-&gt;at(i).start();
1672       size_t size = heap_mem-&gt;at(i).byte_size();
1673       char* top = start + size;
1674       log_debug(cds)(&quot;%s%d space: &quot; SIZE_FORMAT_W(9) &quot; [ %4.1f%% of total] out of &quot; SIZE_FORMAT_W(9) &quot; bytes [100.0%% used] at &quot; INTPTR_FORMAT,
1675                      name, i, size, size/double(total_size)*100.0, size, p2i(start));
1676 
1677   }
1678 }
1679 
<span class="line-modified">1680 void MetaspaceShared::write_core_archive_regions(FileMapInfo* mapinfo,</span>
<span class="line-added">1681                                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* closed_oopmaps,</span>
<span class="line-added">1682                                                  GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* open_oopmaps) {</span>
1683   // Make sure NUM_CDS_REGIONS (exported in cds.h) agrees with
1684   // MetaspaceShared::n_regions (internal to hotspot).
1685   assert(NUM_CDS_REGIONS == MetaspaceShared::n_regions, &quot;sanity&quot;);
1686 
1687   // mc contains the trampoline code for method entries, which are patched at run time,
1688   // so it needs to be read/write.
1689   write_region(mapinfo, mc, &amp;_mc_region, /*read_only=*/false,/*allow_exec=*/true);
1690   write_region(mapinfo, rw, &amp;_rw_region, /*read_only=*/false,/*allow_exec=*/false);
1691   write_region(mapinfo, ro, &amp;_ro_region, /*read_only=*/true, /*allow_exec=*/false);
<span class="line-modified">1692   mapinfo-&gt;write_bitmap_region(ArchivePtrMarker::ptrmap(), closed_oopmaps, open_oopmaps);</span>
1693 }
1694 
1695 void MetaspaceShared::write_region(FileMapInfo* mapinfo, int region_idx, DumpRegion* dump_region, bool read_only,  bool allow_exec) {
1696   mapinfo-&gt;write_region(region_idx, dump_region-&gt;base(), dump_region-&gt;used(), read_only, allow_exec);
1697 }
1698 
1699 // Update a Java object to point its Klass* to the new location after
1700 // shared archive has been compacted.
1701 void MetaspaceShared::relocate_klass_ptr(oop o) {
1702   assert(DumpSharedSpaces, &quot;sanity&quot;);
1703   Klass* k = ArchiveCompactor::get_relocated_klass(o-&gt;klass());
1704   o-&gt;set_klass(k);
1705 }
1706 
1707 Klass* MetaspaceShared::get_relocated_klass(Klass *k, bool is_final) {
1708   assert(DumpSharedSpaces, &quot;sanity&quot;);
1709   k = ArchiveCompactor::get_relocated_klass(k);
1710   if (is_final) {
1711     k = (Klass*)(address(k) + final_delta());
1712   }
1713   return k;
1714 }
1715 
1716 class LinkSharedClassesClosure : public KlassClosure {
1717   Thread* THREAD;
1718   bool    _made_progress;
1719  public:
1720   LinkSharedClassesClosure(Thread* thread) : THREAD(thread), _made_progress(false) {}
1721 
1722   void reset()               { _made_progress = false; }
1723   bool made_progress() const { return _made_progress; }
1724 
1725   void do_klass(Klass* k) {
1726     if (k-&gt;is_instance_klass()) {
1727       InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">1728       // For dynamic CDS dump, only link classes loaded by the builtin class loaders.</span>
<span class="line-modified">1729       bool do_linking = DumpSharedSpaces ? true : !ik-&gt;is_shared_unregistered_class();</span>
<span class="line-modified">1730       if (do_linking) {</span>
<span class="line-modified">1731         // Link the class to cause the bytecodes to be rewritten and the</span>
<span class="line-modified">1732         // cpcache to be created. Class verification is done according</span>
<span class="line-modified">1733         // to -Xverify setting.</span>
<span class="line-modified">1734         _made_progress |= MetaspaceShared::try_link_class(ik, THREAD);</span>
<span class="line-modified">1735         guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);</span>







1736 
<span class="line-modified">1737         if (DumpSharedSpaces) {</span>
<span class="line-modified">1738           // The following function is used to resolve all Strings in the statically</span>
<span class="line-modified">1739           // dumped classes to archive all the Strings. The archive heap is not supported</span>
<span class="line-modified">1740           // for the dynamic archive.</span>
<span class="line-modified">1741           ik-&gt;constants()-&gt;resolve_class_constants(THREAD);</span>
<span class="line-added">1742         }</span>
<span class="line-added">1743       }</span>
1744     }
1745   }
1746 };
1747 
1748 void MetaspaceShared::link_and_cleanup_shared_classes(TRAPS) {
1749   // We need to iterate because verification may cause additional classes
1750   // to be loaded.
1751   LinkSharedClassesClosure link_closure(THREAD);
1752   do {
1753     link_closure.reset();
1754     ClassLoaderDataGraph::unlocked_loaded_classes_do(&amp;link_closure);
1755     guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1756   } while (link_closure.made_progress());












1757 }
1758 
1759 void MetaspaceShared::prepare_for_dumping() {
1760   Arguments::check_unsupported_dumping_properties();
1761   ClassLoader::initialize_shared_path();
1762 }
1763 
1764 // Preload classes from a list, populate the shared spaces and dump to a
1765 // file.
1766 void MetaspaceShared::preload_and_dump(TRAPS) {
1767   { TraceTime timer(&quot;Dump Shared Spaces&quot;, TRACETIME_LOG(Info, startuptime));
1768     ResourceMark rm(THREAD);
1769     char class_list_path_str[JVM_MAXPATHLEN];
1770     // Preload classes to be shared.
1771     const char* class_list_path;
1772     if (SharedClassListFile == NULL) {
1773       // Construct the path to the class list (in jre/lib)
1774       // Walk up two directories from the location of the VM and
1775       // optionally tack on &quot;lib&quot; (depending on platform)
1776       os::jvm_path(class_list_path_str, sizeof(class_list_path_str));
</pre>
<hr />
<pre>
1863       if (klass-&gt;is_instance_klass()) {
1864         InstanceKlass* ik = InstanceKlass::cast(klass);
1865 
1866         // Link the class to cause the bytecodes to be rewritten and the
1867         // cpcache to be created. The linking is done as soon as classes
1868         // are loaded in order that the related data structures (klass and
1869         // cpCache) are located together.
1870         try_link_class(ik, THREAD);
1871         guarantee(!HAS_PENDING_EXCEPTION, &quot;exception in link_class&quot;);
1872       }
1873 
1874       class_count++;
1875     }
1876   }
1877 
1878   return class_count;
1879 }
1880 
1881 // Returns true if the class&#39;s status has changed
1882 bool MetaspaceShared::try_link_class(InstanceKlass* ik, TRAPS) {
<span class="line-modified">1883   Arguments::assert_is_dumping_archive();</span>
<span class="line-modified">1884   if (ik-&gt;init_state() &lt; InstanceKlass::linked &amp;&amp;</span>
<span class="line-added">1885       !SystemDictionaryShared::has_class_failed_verification(ik)) {</span>
1886     bool saved = BytecodeVerificationLocal;
<span class="line-modified">1887     if (ik-&gt;is_shared_unregistered_class() &amp;&amp; ik-&gt;class_loader() == NULL) {</span>
1888       // The verification decision is based on BytecodeVerificationRemote
1889       // for non-system classes. Since we are using the NULL classloader
1890       // to load non-system classes for customized class loaders during dumping,
1891       // we need to temporarily change BytecodeVerificationLocal to be the same as
1892       // BytecodeVerificationRemote. Note this can cause the parent system
1893       // classes also being verified. The extra overhead is acceptable during
1894       // dumping.
1895       BytecodeVerificationLocal = BytecodeVerificationRemote;
1896     }
1897     ik-&gt;link_class(THREAD);
1898     if (HAS_PENDING_EXCEPTION) {
1899       ResourceMark rm(THREAD);
1900       log_warning(cds)(&quot;Preload Warning: Verification failed for %s&quot;,
1901                     ik-&gt;external_name());
1902       CLEAR_PENDING_EXCEPTION;
<span class="line-modified">1903       SystemDictionaryShared::set_class_has_failed_verification(ik);</span>
1904       _has_error_classes = true;
1905     }
1906     BytecodeVerificationLocal = saved;
1907     return true;
1908   } else {
1909     return false;
1910   }
1911 }
1912 
1913 #if INCLUDE_CDS_JAVA_HEAP
1914 void VM_PopulateDumpSharedSpace::dump_java_heap_objects() {
1915   // The closed and open archive heap space has maximum two regions.
1916   // See FileMapInfo::write_archive_heap_regions() for details.
1917   _closed_archive_heap_regions = new GrowableArray&lt;MemRegion&gt;(2);
1918   _open_archive_heap_regions = new GrowableArray&lt;MemRegion&gt;(2);
1919   HeapShared::archive_java_heap_objects(_closed_archive_heap_regions,
1920                                         _open_archive_heap_regions);
1921   ArchiveCompactor::OtherROAllocMark mark;
1922   HeapShared::write_subgraph_info_table();
1923 }
1924 
1925 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps() {
1926   if (HeapShared::is_heap_object_archiving_allowed()) {
1927     _closed_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
1928     dump_archive_heap_oopmaps(_closed_archive_heap_regions, _closed_archive_heap_oopmaps);
1929 
1930     _open_archive_heap_oopmaps = new GrowableArray&lt;ArchiveHeapOopmapInfo&gt;(2);
1931     dump_archive_heap_oopmaps(_open_archive_heap_regions, _open_archive_heap_oopmaps);
1932   }
1933 }
1934 
1935 void VM_PopulateDumpSharedSpace::dump_archive_heap_oopmaps(GrowableArray&lt;MemRegion&gt;* regions,
1936                                                            GrowableArray&lt;ArchiveHeapOopmapInfo&gt;* oopmaps) {
1937   for (int i=0; i&lt;regions-&gt;length(); i++) {
1938     ResourceBitMap oopmap = HeapShared::calculate_oopmap(regions-&gt;at(i));
1939     size_t size_in_bits = oopmap.size();
1940     size_t size_in_bytes = oopmap.size_in_bytes();
<span class="line-modified">1941     uintptr_t* buffer = (uintptr_t*)NEW_C_HEAP_ARRAY(char, size_in_bytes, mtInternal);</span>
1942     oopmap.write_to(buffer, size_in_bytes);
1943     log_info(cds, heap)(&quot;Oopmap = &quot; INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(6) &quot; bytes) for heap region &quot;
1944                         INTPTR_FORMAT &quot; (&quot; SIZE_FORMAT_W(8) &quot; bytes)&quot;,
1945                         p2i(buffer), size_in_bytes,
1946                         p2i(regions-&gt;at(i).start()), regions-&gt;at(i).byte_size());
1947 
1948     ArchiveHeapOopmapInfo info;
1949     info._oopmap = (address)buffer;
1950     info._oopmap_size_in_bits = size_in_bits;
<span class="line-added">1951     info._oopmap_size_in_bytes = size_in_bytes;</span>
1952     oopmaps-&gt;append(info);
1953   }
1954 }
1955 #endif // INCLUDE_CDS_JAVA_HEAP
1956 
1957 void ReadClosure::do_ptr(void** p) {
1958   assert(*p == NULL, &quot;initializing previous initialized pointer.&quot;);
1959   intptr_t obj = nextPtr();
1960   assert((intptr_t)obj &gt;= 0 || (intptr_t)obj &lt; -100,
1961          &quot;hit tag while initializing ptrs.&quot;);
1962   *p = (void*)obj;
1963 }
1964 
1965 void ReadClosure::do_u4(u4* p) {
1966   intptr_t obj = nextPtr();
1967   *p = (u4)(uintx(obj));
1968 }
1969 
1970 void ReadClosure::do_bool(bool* p) {
1971   intptr_t obj = nextPtr();
</pre>
<hr />
<pre>
2355   _i2i_entry_code_buffers = static_mapinfo-&gt;i2i_entry_code_buffers();
2356   _i2i_entry_code_buffers_size = static_mapinfo-&gt;i2i_entry_code_buffers_size();
2357   char* buffer = static_mapinfo-&gt;cloned_vtables();
2358   clone_cpp_vtables((intptr_t*)buffer);
2359 
2360   // Verify various attributes of the archive, plus initialize the
2361   // shared string/symbol tables
2362   buffer = static_mapinfo-&gt;serialized_data();
2363   intptr_t* array = (intptr_t*)buffer;
2364   ReadClosure rc(&amp;array);
2365   serialize(&amp;rc);
2366 
2367   // Initialize the run-time symbol table.
2368   SymbolTable::create_table();
2369 
2370   static_mapinfo-&gt;patch_archived_heap_embedded_pointers();
2371 
2372   // Close the mapinfo file
2373   static_mapinfo-&gt;close();
2374 
<span class="line-added">2375   static_mapinfo-&gt;unmap_region(MetaspaceShared::bm);</span>
<span class="line-added">2376 </span>
2377   FileMapInfo *dynamic_mapinfo = FileMapInfo::dynamic_info();
2378   if (dynamic_mapinfo != NULL) {
2379     intptr_t* buffer = (intptr_t*)dynamic_mapinfo-&gt;serialized_data();
2380     ReadClosure rc(&amp;buffer);
2381     SymbolTable::serialize_shared_table_header(&amp;rc, false);
2382     SystemDictionaryShared::serialize_dictionary_headers(&amp;rc, false);
2383     dynamic_mapinfo-&gt;close();
2384   }
2385 
2386   if (PrintSharedArchiveAndExit) {
2387     if (PrintSharedDictionary) {
2388       tty-&gt;print_cr(&quot;\nShared classes:\n&quot;);
2389       SystemDictionaryShared::print_on(tty);
2390     }
2391     if (FileMapInfo::current_info() == NULL || _archive_loading_failed) {
2392       tty-&gt;print_cr(&quot;archive is invalid&quot;);
2393       vm_exit(1);
2394     } else {
2395       tty-&gt;print_cr(&quot;archive is valid&quot;);
2396       vm_exit(0);
</pre>
</td>
</tr>
</table>
<center><a href="memRegion.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="metaspaceShared.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/type.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_TYPE_HPP
  26 #define SHARE_OPTO_TYPE_HPP
  27 
  28 #include &quot;ci/ciValueKlass.hpp&quot;
  29 #include &quot;opto/adlcVMDeps.hpp&quot;
  30 #include &quot;runtime/handles.hpp&quot;
  31 #include &quot;runtime/sharedRuntime.hpp&quot;
  32 
  33 // Portions of code courtesy of Clifford Click
  34 
  35 // Optimization - Graph Style
  36 
  37 
  38 // This class defines a Type lattice.  The lattice is used in the constant
  39 // propagation algorithms, and for some type-checking of the iloc code.
  40 // Basic types include RSD&#39;s (lower bound, upper bound, stride for integers),
  41 // float &amp; double precision constants, sets of data-labels and code-labels.
  42 // The complete lattice is described below.  Subtypes have no relationship to
  43 // up or down in the lattice; that is entirely determined by the behavior of
  44 // the MEET/JOIN functions.
  45 
  46 class Dict;
  47 class Type;
  48 class   TypeD;
  49 class   TypeF;
  50 class   TypeInt;
  51 class   TypeLong;
  52 class   TypeNarrowPtr;
  53 class     TypeNarrowOop;
  54 class     TypeNarrowKlass;
  55 class   TypeAry;
  56 class   TypeTuple;
  57 class   TypeValueType;
  58 class   TypeVect;
  59 class     TypeVectS;
  60 class     TypeVectD;
  61 class     TypeVectX;
  62 class     TypeVectY;
  63 class     TypeVectZ;
  64 class   TypePtr;
  65 class     TypeRawPtr;
  66 class     TypeOopPtr;
  67 class       TypeInstPtr;
  68 class       TypeAryPtr;
  69 class     TypeKlassPtr;
  70 class     TypeMetadataPtr;
  71 
  72 //------------------------------Type-------------------------------------------
  73 // Basic Type object, represents a set of primitive Values.
  74 // Types are hash-cons&#39;d into a private class dictionary, so only one of each
  75 // different kind of Type exists.  Types are never modified after creation, so
  76 // all their interesting fields are constant.
  77 class Type {
  78   friend class VMStructs;
  79 
  80 public:
  81   enum TYPES {
  82     Bad=0,                      // Type check
  83     Control,                    // Control of code (not in lattice)
  84     Top,                        // Top of the lattice
  85     Int,                        // Integer range (lo-hi)
  86     Long,                       // Long integer range (lo-hi)
  87     Half,                       // Placeholder half of doubleword
  88     NarrowOop,                  // Compressed oop pointer
  89     NarrowKlass,                // Compressed klass pointer
  90 
  91     Tuple,                      // Method signature or object layout
  92     Array,                      // Array types
  93     VectorS,                    //  32bit Vector types
  94     VectorD,                    //  64bit Vector types
  95     VectorX,                    // 128bit Vector types
  96     VectorY,                    // 256bit Vector types
  97     VectorZ,                    // 512bit Vector types
  98     ValueType,                  // Value type
  99 
 100     AnyPtr,                     // Any old raw, klass, inst, or array pointer
 101     RawPtr,                     // Raw (non-oop) pointers
 102     OopPtr,                     // Any and all Java heap entities
 103     InstPtr,                    // Instance pointers (non-array objects)
 104     AryPtr,                     // Array pointers
 105     // (Ptr order matters:  See is_ptr, isa_ptr, is_oopptr, isa_oopptr.)
 106 
 107     MetadataPtr,                // Generic metadata
 108     KlassPtr,                   // Klass pointers
 109 
 110     Function,                   // Function signature
 111     Abio,                       // Abstract I/O
 112     Return_Address,             // Subroutine return address
 113     Memory,                     // Abstract store
 114     FloatTop,                   // No float value
 115     FloatCon,                   // Floating point constant
 116     FloatBot,                   // Any float value
 117     DoubleTop,                  // No double value
 118     DoubleCon,                  // Double precision constant
 119     DoubleBot,                  // Any double value
 120     Bottom,                     // Bottom of lattice
 121     lastype                     // Bogus ending type (not in lattice)
 122   };
 123 
 124   // Signal values for offsets from a base pointer
 125   enum OFFSET_SIGNALS {
 126     OffsetTop = -2000000000,    // undefined offset
 127     OffsetBot = -2000000001     // any possible offset
 128   };
 129 
 130   class Offset {
 131   private:
 132     int _offset;
 133 
 134   public:
 135     explicit Offset(int offset) : _offset(offset) {}
 136 
 137     const Offset meet(const Offset other) const;
 138     const Offset dual() const;
 139     const Offset add(intptr_t offset) const;
 140     bool operator==(const Offset&amp; other) const {
 141       return _offset == other._offset;
 142     }
 143     bool operator!=(const Offset&amp; other) const {
 144       return _offset != other._offset;
 145     }
 146     int get() const { return _offset; }
 147 
 148     void dump2(outputStream *st) const;
 149 
 150     static const Offset top;
 151     static const Offset bottom;
 152   };
 153 
 154   // Min and max WIDEN values.
 155   enum WIDEN {
 156     WidenMin = 0,
 157     WidenMax = 3
 158   };
 159 
 160 private:
 161   typedef struct {
 162     TYPES                dual_type;
 163     BasicType            basic_type;
 164     const char*          msg;
 165     bool                 isa_oop;
 166     uint                 ideal_reg;
 167     relocInfo::relocType reloc;
 168   } TypeInfo;
 169 
 170   // Dictionary of types shared among compilations.
 171   static Dict* _shared_type_dict;
 172   static const TypeInfo _type_info[];
 173 
 174   static int uhash( const Type *const t );
 175   // Structural equality check.  Assumes that cmp() has already compared
 176   // the _base types and thus knows it can cast &#39;t&#39; appropriately.
 177   virtual bool eq( const Type *t ) const;
 178 
 179   // Top-level hash-table of types
 180   static Dict *type_dict() {
 181     return Compile::current()-&gt;type_dict();
 182   }
 183 
 184   // DUAL operation: reflect around lattice centerline.  Used instead of
 185   // join to ensure my lattice is symmetric up and down.  Dual is computed
 186   // lazily, on demand, and cached in _dual.
 187   const Type *_dual;            // Cached dual value
 188   // Table for efficient dualing of base types
 189   static const TYPES dual_type[lastype];
 190 
 191 #ifdef ASSERT
 192   // One type is interface, the other is oop
 193   virtual bool interface_vs_oop_helper(const Type *t) const;
 194 #endif
 195 
 196   const Type *meet_helper(const Type *t, bool include_speculative) const;
<a name="1" id="anc1"></a>
 197 
 198 protected:
 199   // Each class of type is also identified by its base.
 200   const TYPES _base;            // Enum of Types type
 201 
 202   Type( TYPES t ) : _dual(NULL),  _base(t) {} // Simple types
 203   // ~Type();                   // Use fast deallocation
 204   const Type *hashcons();       // Hash-cons the type
 205   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 206   const Type *join_helper(const Type *t, bool include_speculative) const {
 207     return dual()-&gt;meet_helper(t-&gt;dual(), include_speculative)-&gt;dual();
 208   }
 209 
 210 public:
 211 
 212   inline void* operator new( size_t x ) throw() {
 213     Compile* compile = Compile::current();
 214     compile-&gt;set_type_last_size(x);
 215     return compile-&gt;type_arena()-&gt;Amalloc_D(x);
 216   }
 217   inline void operator delete( void* ptr ) {
 218     Compile* compile = Compile::current();
 219     compile-&gt;type_arena()-&gt;Afree(ptr,compile-&gt;type_last_size());
 220   }
 221 
 222   // Initialize the type system for a particular compilation.
 223   static void Initialize(Compile* compile);
 224 
 225   // Initialize the types shared by all compilations.
 226   static void Initialize_shared(Compile* compile);
 227 
 228   TYPES base() const {
 229     assert(_base &gt; Bad &amp;&amp; _base &lt; lastype, &quot;sanity&quot;);
 230     return _base;
 231   }
 232 
 233   // Create a new hash-consd type
 234   static const Type *make(enum TYPES);
 235   // Test for equivalence of types
 236   static int cmp( const Type *const t1, const Type *const t2 );
 237   // Test for higher or equal in lattice
 238   // Variant that drops the speculative part of the types
 239   bool higher_equal(const Type *t) const {
 240     return !cmp(meet(t),t-&gt;remove_speculative());
 241   }
 242   // Variant that keeps the speculative part of the types
 243   bool higher_equal_speculative(const Type *t) const {
 244     return !cmp(meet_speculative(t),t);
 245   }
 246 
 247   // MEET operation; lower in lattice.
 248   // Variant that drops the speculative part of the types
 249   const Type *meet(const Type *t) const {
 250     return meet_helper(t, false);
 251   }
 252   // Variant that keeps the speculative part of the types
 253   const Type *meet_speculative(const Type *t) const {
 254     return meet_helper(t, true)-&gt;cleanup_speculative();
 255   }
 256   // WIDEN: &#39;widens&#39; for Ints and other range types
 257   virtual const Type *widen( const Type *old, const Type* limit ) const { return this; }
 258   // NARROW: complement for widen, used by pessimistic phases
 259   virtual const Type *narrow( const Type *old ) const { return this; }
 260 
 261   // DUAL operation: reflect around lattice centerline.  Used instead of
 262   // join to ensure my lattice is symmetric up and down.
 263   const Type *dual() const { return _dual; }
 264 
 265   // Compute meet dependent on base type
 266   virtual const Type *xmeet( const Type *t ) const;
 267   virtual const Type *xdual() const;    // Compute dual right now.
 268 
 269   // JOIN operation; higher in lattice.  Done by finding the dual of the
 270   // meet of the dual of the 2 inputs.
 271   // Variant that drops the speculative part of the types
 272   const Type *join(const Type *t) const {
 273     return join_helper(t, false);
 274   }
 275   // Variant that keeps the speculative part of the types
 276   const Type *join_speculative(const Type *t) const {
 277     return join_helper(t, true)-&gt;cleanup_speculative();
 278   }
 279 
 280   // Modified version of JOIN adapted to the needs Node::Value.
 281   // Normalizes all empty values to TOP.  Does not kill _widen bits.
 282   // Currently, it also works around limitations involving interface types.
 283   // Variant that drops the speculative part of the types
 284   const Type *filter(const Type *kills) const {
 285     return filter_helper(kills, false);
 286   }
 287   // Variant that keeps the speculative part of the types
 288   const Type *filter_speculative(const Type *kills) const {
 289     return filter_helper(kills, true)-&gt;cleanup_speculative();
 290   }
 291 
 292 #ifdef ASSERT
 293   // One type is interface, the other is oop
 294   virtual bool interface_vs_oop(const Type *t) const;
 295 #endif
 296 
 297   // Returns true if this pointer points at memory which contains a
 298   // compressed oop references.
 299   bool is_ptr_to_narrowoop() const;
 300   bool is_ptr_to_narrowklass() const;
 301 
 302   // Convenience access
 303   float getf() const;
 304   double getd() const;
 305 
 306   const TypeInt    *is_int() const;
 307   const TypeInt    *isa_int() const;             // Returns NULL if not an Int
 308   const TypeLong   *is_long() const;
 309   const TypeLong   *isa_long() const;            // Returns NULL if not a Long
 310   const TypeD      *isa_double() const;          // Returns NULL if not a Double{Top,Con,Bot}
 311   const TypeD      *is_double_constant() const;  // Asserts it is a DoubleCon
 312   const TypeD      *isa_double_constant() const; // Returns NULL if not a DoubleCon
 313   const TypeF      *isa_float() const;           // Returns NULL if not a Float{Top,Con,Bot}
 314   const TypeF      *is_float_constant() const;   // Asserts it is a FloatCon
 315   const TypeF      *isa_float_constant() const;  // Returns NULL if not a FloatCon
 316   const TypeTuple  *is_tuple() const;            // Collection of fields, NOT a pointer
 317   const TypeAry    *is_ary() const;              // Array, NOT array pointer
 318   const TypeAry    *isa_ary() const;             // Returns NULL of not ary
 319   const TypeVect   *is_vect() const;             // Vector
 320   const TypeVect   *isa_vect() const;            // Returns NULL if not a Vector
 321   const TypePtr    *is_ptr() const;              // Asserts it is a ptr type
 322   const TypePtr    *isa_ptr() const;             // Returns NULL if not ptr type
 323   const TypeRawPtr *isa_rawptr() const;          // NOT Java oop
 324   const TypeRawPtr *is_rawptr() const;           // Asserts is rawptr
 325   const TypeNarrowOop  *is_narrowoop() const;    // Java-style GC&#39;d pointer
 326   const TypeNarrowOop  *isa_narrowoop() const;   // Returns NULL if not oop ptr type
 327   const TypeNarrowKlass *is_narrowklass() const; // compressed klass pointer
 328   const TypeNarrowKlass *isa_narrowklass() const;// Returns NULL if not oop ptr type
 329   const TypeOopPtr   *isa_oopptr() const;        // Returns NULL if not oop ptr type
 330   const TypeOopPtr   *is_oopptr() const;         // Java-style GC&#39;d pointer
 331   const TypeInstPtr  *isa_instptr() const;       // Returns NULL if not InstPtr
 332   const TypeInstPtr  *is_instptr() const;        // Instance
 333   const TypeAryPtr   *isa_aryptr() const;        // Returns NULL if not AryPtr
 334   const TypeAryPtr   *is_aryptr() const;         // Array oop
 335   const TypeValueType* isa_valuetype() const;    // Returns NULL if not Value Type
 336   const TypeValueType* is_valuetype() const;     // Value Type
 337 
 338   const TypeMetadataPtr   *isa_metadataptr() const;   // Returns NULL if not oop ptr type
 339   const TypeMetadataPtr   *is_metadataptr() const;    // Java-style GC&#39;d pointer
 340   const TypeKlassPtr      *isa_klassptr() const;      // Returns NULL if not KlassPtr
 341   const TypeKlassPtr      *is_klassptr() const;       // assert if not KlassPtr
 342 
 343   virtual bool      is_finite() const;           // Has a finite value
 344   virtual bool      is_nan()    const;           // Is not a number (NaN)
 345 
 346   bool is_valuetypeptr() const;
 347   virtual ciValueKlass* value_klass() const;
 348 
 349   // Returns this ptr type or the equivalent ptr type for this compressed pointer.
 350   const TypePtr* make_ptr() const;
 351 
 352   // Returns this oopptr type or the equivalent oopptr type for this compressed pointer.
 353   // Asserts if the underlying type is not an oopptr or narrowoop.
 354   const TypeOopPtr* make_oopptr() const;
 355 
 356   // Returns this compressed pointer or the equivalent compressed version
 357   // of this pointer type.
 358   const TypeNarrowOop* make_narrowoop() const;
 359 
 360   // Returns this compressed klass pointer or the equivalent
 361   // compressed version of this pointer type.
 362   const TypeNarrowKlass* make_narrowklass() const;
 363 
 364   // Special test for register pressure heuristic
 365   bool is_floatingpoint() const;        // True if Float or Double base type
 366 
 367   // Do you have memory, directly or through a tuple?
 368   bool has_memory( ) const;
 369 
 370   // TRUE if type is a singleton
 371   virtual bool singleton(void) const;
 372 
 373   // TRUE if type is above the lattice centerline, and is therefore vacuous
 374   virtual bool empty(void) const;
 375 
 376   // Return a hash for this type.  The hash function is public so ConNode
 377   // (constants) can hash on their constant, which is represented by a Type.
 378   virtual int hash() const;
 379 
 380   // Map ideal registers (machine types) to ideal types
 381   static const Type *mreg2type[];
 382 
 383   // Printing, statistics
 384 #ifndef PRODUCT
 385   void         dump_on(outputStream *st) const;
 386   void         dump() const {
 387     dump_on(tty);
 388   }
 389   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 390   static  void dump_stats();
 391 
 392   static const char* str(const Type* t);
 393 #endif
 394   void typerr(const Type *t) const; // Mixing types error
 395 
 396   // Create basic type
 397   static const Type* get_const_basic_type(BasicType type) {
 398     assert((uint)type &lt;= T_CONFLICT &amp;&amp; _const_basic_type[type] != NULL, &quot;bad type&quot;);
 399     return _const_basic_type[type];
 400   }
 401 
 402   // For two instance arrays of same dimension, return the base element types.
 403   // Otherwise or if the arrays have different dimensions, return NULL.
 404   static void get_arrays_base_elements(const Type *a1, const Type *a2,
 405                                        const TypeInstPtr **e1, const TypeInstPtr **e2);
 406 
 407   // Mapping to the array element&#39;s basic type.
 408   BasicType array_element_basic_type() const;
 409 
 410   // Create standard type for a ciType:
 411   static const Type* get_const_type(ciType* type);
 412 
 413   // Create standard zero value:
 414   static const Type* get_zero_type(BasicType type) {
 415     assert((uint)type &lt;= T_CONFLICT &amp;&amp; _zero_type[type] != NULL, &quot;bad type&quot;);
 416     return _zero_type[type];
 417   }
 418 
 419   // Report if this is a zero value (not top).
 420   bool is_zero_type() const {
 421     BasicType type = basic_type();
 422     if (type == T_VOID || type &gt;= T_CONFLICT)
 423       return false;
 424     else
 425       return (this == _zero_type[type]);
 426   }
 427 
 428   // Convenience common pre-built types.
 429   static const Type *ABIO;
 430   static const Type *BOTTOM;
 431   static const Type *CONTROL;
 432   static const Type *DOUBLE;
 433   static const Type *FLOAT;
 434   static const Type *HALF;
 435   static const Type *MEMORY;
 436   static const Type *MULTI;
 437   static const Type *RETURN_ADDRESS;
 438   static const Type *TOP;
 439 
 440   // Mapping from compiler type to VM BasicType
 441   BasicType basic_type() const       { return _type_info[_base].basic_type; }
 442   uint ideal_reg() const             { return _type_info[_base].ideal_reg; }
 443   const char* msg() const            { return _type_info[_base].msg; }
 444   bool isa_oop_ptr() const           { return _type_info[_base].isa_oop; }
 445   relocInfo::relocType reloc() const { return _type_info[_base].reloc; }
 446 
 447   // Mapping from CI type system to compiler type:
 448   static const Type* get_typeflow_type(ciType* type);
 449 
 450   static const Type* make_from_constant(ciConstant constant,
 451                                         bool require_constant = false,
 452                                         int stable_dimension = 0,
 453                                         bool is_narrow = false,
 454                                         bool is_autobox_cache = false);
 455 
 456   static const Type* make_constant_from_field(ciInstance* holder,
 457                                               int off,
 458                                               bool is_unsigned_load,
 459                                               BasicType loadbt);
 460 
 461   static const Type* make_constant_from_field(ciField* field,
 462                                               ciInstance* holder,
 463                                               BasicType loadbt,
 464                                               bool is_unsigned_load);
 465 
 466   static const Type* make_constant_from_array_element(ciArray* array,
 467                                                       int off,
 468                                                       int stable_dimension,
 469                                                       BasicType loadbt,
 470                                                       bool is_unsigned_load);
 471 
 472   // Speculative type helper methods. See TypePtr.
 473   virtual const TypePtr* speculative() const                                  { return NULL; }
 474   virtual ciKlass* speculative_type() const                                   { return NULL; }
 475   virtual ciKlass* speculative_type_not_null() const                          { return NULL; }
 476   virtual bool speculative_maybe_null() const                                 { return true; }
 477   virtual bool speculative_always_null() const                                { return true; }
 478   virtual const Type* remove_speculative() const                              { return this; }
 479   virtual const Type* cleanup_speculative() const                             { return this; }
 480   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return exact_kls != NULL; }
 481   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return ptr_kind == ProfileAlwaysNull || ptr_kind == ProfileNeverNull; }
 482   const Type* maybe_remove_speculative(bool include_speculative) const;
 483 
 484   virtual bool maybe_null() const { return true; }
<a name="2" id="anc2"></a>
 485 
 486 private:
 487   // support arrays
 488   static const Type*        _zero_type[T_CONFLICT+1];
 489   static const Type* _const_basic_type[T_CONFLICT+1];
 490 };
 491 
 492 //------------------------------TypeF------------------------------------------
 493 // Class of Float-Constant Types.
 494 class TypeF : public Type {
 495   TypeF( float f ) : Type(FloatCon), _f(f) {};
 496 public:
 497   virtual bool eq( const Type *t ) const;
 498   virtual int  hash() const;             // Type specific hashing
 499   virtual bool singleton(void) const;    // TRUE if type is a singleton
 500   virtual bool empty(void) const;        // TRUE if type is vacuous
 501 public:
 502   const float _f;               // Float constant
 503 
 504   static const TypeF *make(float f);
 505 
 506   virtual bool        is_finite() const;  // Has a finite value
 507   virtual bool        is_nan()    const;  // Is not a number (NaN)
 508 
 509   virtual const Type *xmeet( const Type *t ) const;
 510   virtual const Type *xdual() const;    // Compute dual right now.
 511   // Convenience common pre-built types.
 512   static const TypeF *ZERO; // positive zero only
 513   static const TypeF *ONE;
 514   static const TypeF *POS_INF;
 515   static const TypeF *NEG_INF;
 516 #ifndef PRODUCT
 517   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 518 #endif
 519 };
 520 
 521 //------------------------------TypeD------------------------------------------
 522 // Class of Double-Constant Types.
 523 class TypeD : public Type {
 524   TypeD( double d ) : Type(DoubleCon), _d(d) {};
 525 public:
 526   virtual bool eq( const Type *t ) const;
 527   virtual int  hash() const;             // Type specific hashing
 528   virtual bool singleton(void) const;    // TRUE if type is a singleton
 529   virtual bool empty(void) const;        // TRUE if type is vacuous
 530 public:
 531   const double _d;              // Double constant
 532 
 533   static const TypeD *make(double d);
 534 
 535   virtual bool        is_finite() const;  // Has a finite value
 536   virtual bool        is_nan()    const;  // Is not a number (NaN)
 537 
 538   virtual const Type *xmeet( const Type *t ) const;
 539   virtual const Type *xdual() const;    // Compute dual right now.
 540   // Convenience common pre-built types.
 541   static const TypeD *ZERO; // positive zero only
 542   static const TypeD *ONE;
 543   static const TypeD *POS_INF;
 544   static const TypeD *NEG_INF;
 545 #ifndef PRODUCT
 546   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 547 #endif
 548 };
 549 
 550 //------------------------------TypeInt----------------------------------------
 551 // Class of integer ranges, the set of integers between a lower bound and an
 552 // upper bound, inclusive.
 553 class TypeInt : public Type {
 554   TypeInt( jint lo, jint hi, int w );
 555 protected:
 556   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 557 
 558 public:
 559   typedef jint NativeType;
 560   virtual bool eq( const Type *t ) const;
 561   virtual int  hash() const;             // Type specific hashing
 562   virtual bool singleton(void) const;    // TRUE if type is a singleton
 563   virtual bool empty(void) const;        // TRUE if type is vacuous
 564   const jint _lo, _hi;          // Lower bound, upper bound
 565   const short _widen;           // Limit on times we widen this sucker
 566 
 567   static const TypeInt *make(jint lo);
 568   // must always specify w
 569   static const TypeInt *make(jint lo, jint hi, int w);
 570 
 571   // Check for single integer
 572   int is_con() const { return _lo==_hi; }
 573   bool is_con(int i) const { return is_con() &amp;&amp; _lo == i; }
 574   jint get_con() const { assert( is_con(), &quot;&quot; );  return _lo; }
 575 
 576   virtual bool        is_finite() const;  // Has a finite value
 577 
 578   virtual const Type *xmeet( const Type *t ) const;
 579   virtual const Type *xdual() const;    // Compute dual right now.
 580   virtual const Type *widen( const Type *t, const Type* limit_type ) const;
 581   virtual const Type *narrow( const Type *t ) const;
 582   // Do not kill _widen bits.
 583   // Convenience common pre-built types.
 584   static const TypeInt *MINUS_1;
 585   static const TypeInt *ZERO;
 586   static const TypeInt *ONE;
 587   static const TypeInt *BOOL;
 588   static const TypeInt *CC;
 589   static const TypeInt *CC_LT;  // [-1]  == MINUS_1
 590   static const TypeInt *CC_GT;  // [1]   == ONE
 591   static const TypeInt *CC_EQ;  // [0]   == ZERO
 592   static const TypeInt *CC_LE;  // [-1,0]
 593   static const TypeInt *CC_GE;  // [0,1] == BOOL (!)
 594   static const TypeInt *BYTE;
 595   static const TypeInt *UBYTE;
 596   static const TypeInt *CHAR;
 597   static const TypeInt *SHORT;
 598   static const TypeInt *POS;
 599   static const TypeInt *POS1;
 600   static const TypeInt *INT;
 601   static const TypeInt *SYMINT; // symmetric range [-max_jint..max_jint]
 602   static const TypeInt *TYPE_DOMAIN; // alias for TypeInt::INT
 603 
 604   static const TypeInt *as_self(const Type *t) { return t-&gt;is_int(); }
 605 #ifndef PRODUCT
 606   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
 607 #endif
 608 };
 609 
 610 
 611 //------------------------------TypeLong---------------------------------------
 612 // Class of long integer ranges, the set of integers between a lower bound and
 613 // an upper bound, inclusive.
 614 class TypeLong : public Type {
 615   TypeLong( jlong lo, jlong hi, int w );
 616 protected:
 617   // Do not kill _widen bits.
 618   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 619 public:
 620   typedef jlong NativeType;
 621   virtual bool eq( const Type *t ) const;
 622   virtual int  hash() const;             // Type specific hashing
 623   virtual bool singleton(void) const;    // TRUE if type is a singleton
 624   virtual bool empty(void) const;        // TRUE if type is vacuous
 625 public:
 626   const jlong _lo, _hi;         // Lower bound, upper bound
 627   const short _widen;           // Limit on times we widen this sucker
 628 
 629   static const TypeLong *make(jlong lo);
 630   // must always specify w
 631   static const TypeLong *make(jlong lo, jlong hi, int w);
 632 
 633   // Check for single integer
 634   int is_con() const { return _lo==_hi; }
 635   bool is_con(int i) const { return is_con() &amp;&amp; _lo == i; }
 636   jlong get_con() const { assert( is_con(), &quot;&quot; ); return _lo; }
 637 
 638   // Check for positive 32-bit value.
 639   int is_positive_int() const { return _lo &gt;= 0 &amp;&amp; _hi &lt;= (jlong)max_jint; }
 640 
 641   virtual bool        is_finite() const;  // Has a finite value
 642 
 643 
 644   virtual const Type *xmeet( const Type *t ) const;
 645   virtual const Type *xdual() const;    // Compute dual right now.
 646   virtual const Type *widen( const Type *t, const Type* limit_type ) const;
 647   virtual const Type *narrow( const Type *t ) const;
 648   // Convenience common pre-built types.
 649   static const TypeLong *MINUS_1;
 650   static const TypeLong *ZERO;
 651   static const TypeLong *ONE;
 652   static const TypeLong *POS;
 653   static const TypeLong *LONG;
 654   static const TypeLong *INT;    // 32-bit subrange [min_jint..max_jint]
 655   static const TypeLong *UINT;   // 32-bit unsigned [0..max_juint]
 656   static const TypeLong *TYPE_DOMAIN; // alias for TypeLong::LONG
 657 
 658   // static convenience methods.
 659   static const TypeLong *as_self(const Type *t) { return t-&gt;is_long(); }
 660 
 661 #ifndef PRODUCT
 662   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const;// Specialized per-Type dumping
 663 #endif
 664 };
 665 
 666 //------------------------------TypeTuple--------------------------------------
 667 // Class of Tuple Types, essentially type collections for function signatures
 668 // and class layouts.  It happens to also be a fast cache for the HotSpot
 669 // signature types.
 670 class TypeTuple : public Type {
 671   TypeTuple( uint cnt, const Type **fields ) : Type(Tuple), _cnt(cnt), _fields(fields) { }
 672 
 673   const uint          _cnt;              // Count of fields
 674   const Type ** const _fields;           // Array of field types
 675 
 676 public:
 677   virtual bool eq( const Type *t ) const;
 678   virtual int  hash() const;             // Type specific hashing
 679   virtual bool singleton(void) const;    // TRUE if type is a singleton
 680   virtual bool empty(void) const;        // TRUE if type is vacuous
 681 
 682   // Accessors:
 683   uint cnt() const { return _cnt; }
 684   const Type* field_at(uint i) const {
 685     assert(i &lt; _cnt, &quot;oob&quot;);
 686     return _fields[i];
 687   }
 688   void set_field_at(uint i, const Type* t) {
 689     assert(i &lt; _cnt, &quot;oob&quot;);
 690     _fields[i] = t;
 691   }
 692 
 693   static const TypeTuple *make( uint cnt, const Type **fields );
 694   static const TypeTuple *make_range(ciSignature* sig, bool ret_vt_fields = false);
 695   static const TypeTuple *make_domain(ciMethod* method, bool vt_fields_as_args = false);
 696 
 697   // Subroutine call type with space allocated for argument types
 698   // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
 699   static const Type **fields( uint arg_cnt );
 700 
 701   virtual const Type *xmeet( const Type *t ) const;
 702   virtual const Type *xdual() const;    // Compute dual right now.
 703   // Convenience common pre-built types.
 704   static const TypeTuple *IFBOTH;
 705   static const TypeTuple *IFFALSE;
 706   static const TypeTuple *IFTRUE;
 707   static const TypeTuple *IFNEITHER;
 708   static const TypeTuple *LOOPBODY;
 709   static const TypeTuple *MEMBAR;
 710   static const TypeTuple *STORECONDITIONAL;
 711   static const TypeTuple *START_I2C;
 712   static const TypeTuple *INT_PAIR;
 713   static const TypeTuple *LONG_PAIR;
 714   static const TypeTuple *INT_CC_PAIR;
 715   static const TypeTuple *LONG_CC_PAIR;
 716 #ifndef PRODUCT
 717   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 718 #endif
 719 };
 720 
 721 //------------------------------TypeAry----------------------------------------
 722 // Class of Array Types
 723 class TypeAry : public Type {
 724   TypeAry(const Type* elem, const TypeInt* size, bool stable, bool not_flat, bool not_null_free) : Type(Array),
 725       _elem(elem), _size(size), _stable(stable), _not_flat(not_flat), _not_null_free(not_null_free) {}
 726 public:
 727   virtual bool eq( const Type *t ) const;
 728   virtual int  hash() const;             // Type specific hashing
 729   virtual bool singleton(void) const;    // TRUE if type is a singleton
 730   virtual bool empty(void) const;        // TRUE if type is vacuous
 731 
 732 private:
 733   const Type *_elem;            // Element type of array
 734   const TypeInt *_size;         // Elements in array
 735   const bool _stable;           // Are elements @Stable?
 736 
 737   // Value type array properties
 738   const bool _not_flat;         // Array is never flattened
 739   const bool _not_null_free;    // Array is never null-free
 740 
 741   friend class TypeAryPtr;
 742 
 743 public:
 744   static const TypeAry* make(const Type* elem, const TypeInt* size, bool stable = false,
 745                              bool not_flat = false, bool not_null_free = false);
 746 
 747   virtual const Type *xmeet( const Type *t ) const;
 748   virtual const Type *xdual() const;    // Compute dual right now.
 749   bool ary_must_be_exact() const;  // true if arrays of such are never generic
 750   virtual const Type* remove_speculative() const;
 751   virtual const Type* cleanup_speculative() const;
 752 
 753 #ifdef ASSERT
 754   // One type is interface, the other is oop
 755   virtual bool interface_vs_oop(const Type *t) const;
 756 #endif
 757 #ifndef PRODUCT
 758   virtual void dump2( Dict &amp;d, uint, outputStream *st  ) const; // Specialized per-Type dumping
 759 #endif
 760 };
 761 
 762 
 763 //------------------------------TypeValue---------------------------------------
 764 // Class of Value Type Types
 765 class TypeValueType : public Type {
 766 private:
 767   ciValueKlass* _vk;
 768   bool _larval;
 769 
 770 protected:
 771   TypeValueType(ciValueKlass* vk, bool larval)
 772     : Type(ValueType),
 773       _vk(vk), _larval(larval) {
 774   }
 775 
 776 public:
 777   static const TypeValueType* make(ciValueKlass* vk, bool larval = false);
 778   virtual ciValueKlass* value_klass() const { return _vk; }
 779   bool larval() const { return _larval; }
 780 
 781   virtual bool eq(const Type* t) const;
 782   virtual int  hash() const;             // Type specific hashing
 783   virtual bool singleton(void) const;    // TRUE if type is a singleton
 784   virtual bool empty(void) const;        // TRUE if type is vacuous
 785 
 786   virtual const Type* xmeet(const Type* t) const;
 787   virtual const Type* xdual() const;     // Compute dual right now.
 788 
 789   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return false; }
 790   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return false; }
 791 
 792   static const TypeValueType *BOTTOM;
 793 
 794 #ifndef PRODUCT
 795   virtual void dump2(Dict &amp;d, uint, outputStream* st) const; // Specialized per-Type dumping
 796 #endif
 797 };
 798 
 799 //------------------------------TypeVect---------------------------------------
 800 // Class of Vector Types
 801 class TypeVect : public Type {
 802   const Type*   _elem;  // Vector&#39;s element type
 803   const uint  _length;  // Elements in vector (power of 2)
 804 
 805 protected:
 806   TypeVect(TYPES t, const Type* elem, uint length) : Type(t),
 807     _elem(elem), _length(length) {}
 808 
 809 public:
 810   const Type* element_type() const { return _elem; }
 811   BasicType element_basic_type() const { return _elem-&gt;array_element_basic_type(); }
 812   uint length() const { return _length; }
 813   uint length_in_bytes() const {
 814    return _length * type2aelembytes(element_basic_type());
 815   }
 816 
 817   virtual bool eq(const Type *t) const;
 818   virtual int  hash() const;             // Type specific hashing
 819   virtual bool singleton(void) const;    // TRUE if type is a singleton
 820   virtual bool empty(void) const;        // TRUE if type is vacuous
 821 
 822   static const TypeVect *make(const BasicType elem_bt, uint length) {
 823     // Use bottom primitive type.
 824     return make(get_const_basic_type(elem_bt), length);
 825   }
 826   // Used directly by Replicate nodes to construct singleton vector.
 827   static const TypeVect *make(const Type* elem, uint length);
 828 
 829   virtual const Type *xmeet( const Type *t) const;
 830   virtual const Type *xdual() const;     // Compute dual right now.
 831 
 832   static const TypeVect *VECTS;
 833   static const TypeVect *VECTD;
 834   static const TypeVect *VECTX;
 835   static const TypeVect *VECTY;
 836   static const TypeVect *VECTZ;
 837 
 838 #ifndef PRODUCT
 839   virtual void dump2(Dict &amp;d, uint, outputStream *st) const; // Specialized per-Type dumping
 840 #endif
 841 };
 842 
 843 class TypeVectS : public TypeVect {
 844   friend class TypeVect;
 845   TypeVectS(const Type* elem, uint length) : TypeVect(VectorS, elem, length) {}
 846 };
 847 
 848 class TypeVectD : public TypeVect {
 849   friend class TypeVect;
 850   TypeVectD(const Type* elem, uint length) : TypeVect(VectorD, elem, length) {}
 851 };
 852 
 853 class TypeVectX : public TypeVect {
 854   friend class TypeVect;
 855   TypeVectX(const Type* elem, uint length) : TypeVect(VectorX, elem, length) {}
 856 };
 857 
 858 class TypeVectY : public TypeVect {
 859   friend class TypeVect;
 860   TypeVectY(const Type* elem, uint length) : TypeVect(VectorY, elem, length) {}
 861 };
 862 
 863 class TypeVectZ : public TypeVect {
 864   friend class TypeVect;
 865   TypeVectZ(const Type* elem, uint length) : TypeVect(VectorZ, elem, length) {}
 866 };
 867 
 868 //------------------------------TypePtr----------------------------------------
 869 // Class of machine Pointer Types: raw data, instances or arrays.
 870 // If the _base enum is AnyPtr, then this refers to all of the above.
 871 // Otherwise the _base will indicate which subset of pointers is affected,
 872 // and the class will be inherited from.
 873 class TypePtr : public Type {
 874   friend class TypeNarrowPtr;
 875 public:
 876   enum PTR { TopPTR, AnyNull, Constant, Null, NotNull, BotPTR, lastPTR };
 877 protected:
 878   TypePtr(TYPES t, PTR ptr, Offset offset,
 879           const TypePtr* speculative = NULL,
 880           int inline_depth = InlineDepthBottom) :
 881     Type(t), _speculative(speculative), _inline_depth(inline_depth), _offset(offset),
 882     _ptr(ptr) {}
 883   static const PTR ptr_meet[lastPTR][lastPTR];
 884   static const PTR ptr_dual[lastPTR];
 885   static const char * const ptr_msg[lastPTR];
 886 
 887   enum {
 888     InlineDepthBottom = INT_MAX,
 889     InlineDepthTop = -InlineDepthBottom
 890   };
 891 
 892   // Extra type information profiling gave us. We propagate it the
 893   // same way the rest of the type info is propagated. If we want to
 894   // use it, then we have to emit a guard: this part of the type is
 895   // not something we know but something we speculate about the type.
 896   const TypePtr*   _speculative;
 897   // For speculative types, we record at what inlining depth the
 898   // profiling point that provided the data is. We want to favor
 899   // profile data coming from outer scopes which are likely better for
 900   // the current compilation.
 901   int _inline_depth;
 902 
 903   // utility methods to work on the speculative part of the type
 904   const TypePtr* dual_speculative() const;
 905   const TypePtr* xmeet_speculative(const TypePtr* other) const;
 906   bool eq_speculative(const TypePtr* other) const;
 907   int hash_speculative() const;
 908   const TypePtr* add_offset_speculative(intptr_t offset) const;
 909 #ifndef PRODUCT
 910   void dump_speculative(outputStream *st) const;
 911 #endif
 912 
 913   // utility methods to work on the inline depth of the type
 914   int dual_inline_depth() const;
 915   int meet_inline_depth(int depth) const;
 916 #ifndef PRODUCT
 917   void dump_inline_depth(outputStream *st) const;
 918 #endif
 919 
 920 public:
 921   const Offset _offset;         // Offset into oop, with TOP &amp; BOT
 922   const PTR _ptr;               // Pointer equivalence class
 923 
 924   const int offset() const { return _offset.get(); }
 925   const PTR ptr()    const { return _ptr; }
 926 
 927   static const TypePtr* make(TYPES t, PTR ptr, Offset offset,
 928                              const TypePtr* speculative = NULL,
 929                              int inline_depth = InlineDepthBottom);
 930 
 931   // Return a &#39;ptr&#39; version of this type
 932   virtual const Type *cast_to_ptr_type(PTR ptr) const;
 933 
 934   virtual intptr_t get_con() const;
 935 
 936   Offset xadd_offset(intptr_t offset) const;
 937   virtual const TypePtr *add_offset( intptr_t offset ) const;
 938   virtual const int flattened_offset() const { return offset(); }
 939 
 940   virtual bool eq(const Type *t) const;
 941   virtual int  hash() const;             // Type specific hashing
 942 
 943   virtual bool singleton(void) const;    // TRUE if type is a singleton
 944   virtual bool empty(void) const;        // TRUE if type is vacuous
 945   virtual const Type *xmeet( const Type *t ) const;
 946   virtual const Type *xmeet_helper( const Type *t ) const;
 947   Offset meet_offset(int offset) const;
 948   Offset dual_offset() const;
 949   virtual const Type *xdual() const;    // Compute dual right now.
 950 
 951   // meet, dual and join over pointer equivalence sets
 952   PTR meet_ptr( const PTR in_ptr ) const { return ptr_meet[in_ptr][ptr()]; }
 953   PTR dual_ptr()                   const { return ptr_dual[ptr()];      }
 954 
 955   // This is textually confusing unless one recalls that
 956   // join(t) == dual()-&gt;meet(t-&gt;dual())-&gt;dual().
 957   PTR join_ptr( const PTR in_ptr ) const {
 958     return ptr_dual[ ptr_meet[ ptr_dual[in_ptr] ] [ dual_ptr() ] ];
 959   }
 960 
 961   // Speculative type helper methods.
 962   virtual const TypePtr* speculative() const { return _speculative; }
 963   int inline_depth() const                   { return _inline_depth; }
 964   virtual ciKlass* speculative_type() const;
 965   virtual ciKlass* speculative_type_not_null() const;
 966   virtual bool speculative_maybe_null() const;
 967   virtual bool speculative_always_null() const;
 968   virtual const Type* remove_speculative() const;
 969   virtual const Type* cleanup_speculative() const;
 970   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
 971   virtual bool would_improve_ptr(ProfilePtrKind maybe_null) const;
 972   virtual const TypePtr* with_inline_depth(int depth) const;
 973 
 974   virtual bool maybe_null() const { return meet_ptr(Null) == ptr(); }
 975 
 976   virtual bool can_be_value_type() const { return false; }
 977   virtual bool flat_array() const { return false; }
 978 
 979   // Tests for relation to centerline of type lattice:
 980   static bool above_centerline(PTR ptr) { return (ptr &lt;= AnyNull); }
 981   static bool below_centerline(PTR ptr) { return (ptr &gt;= NotNull); }
 982   // Convenience common pre-built types.
 983   static const TypePtr *NULL_PTR;
 984   static const TypePtr *NOTNULL;
 985   static const TypePtr *BOTTOM;
 986 #ifndef PRODUCT
 987   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
 988 #endif
 989 };
 990 
 991 //------------------------------TypeRawPtr-------------------------------------
 992 // Class of raw pointers, pointers to things other than Oops.  Examples
 993 // include the stack pointer, top of heap, card-marking area, handles, etc.
 994 class TypeRawPtr : public TypePtr {
 995 protected:
 996   TypeRawPtr(PTR ptr, address bits) : TypePtr(RawPtr,ptr,Offset(0)), _bits(bits){}
 997 public:
 998   virtual bool eq( const Type *t ) const;
 999   virtual int  hash() const;     // Type specific hashing
1000 
1001   const address _bits;          // Constant value, if applicable
1002 
1003   static const TypeRawPtr *make( PTR ptr );
1004   static const TypeRawPtr *make( address bits );
1005 
1006   // Return a &#39;ptr&#39; version of this type
1007   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1008 
1009   virtual intptr_t get_con() const;
1010 
1011   virtual const TypePtr *add_offset( intptr_t offset ) const;
1012 
1013   virtual const Type *xmeet( const Type *t ) const;
1014   virtual const Type *xdual() const;    // Compute dual right now.
1015   // Convenience common pre-built types.
1016   static const TypeRawPtr *BOTTOM;
1017   static const TypeRawPtr *NOTNULL;
1018 #ifndef PRODUCT
1019   virtual void dump2( Dict &amp;d, uint depth, outputStream *st  ) const;
1020 #endif
1021 };
1022 
1023 //------------------------------TypeOopPtr-------------------------------------
1024 // Some kind of oop (Java pointer), either instance or array.
1025 class TypeOopPtr : public TypePtr {
1026 protected:
1027   TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset, Offset field_offset,
1028              int instance_id, const TypePtr* speculative, int inline_depth);
1029 public:
1030   virtual bool eq( const Type *t ) const;
1031   virtual int  hash() const;             // Type specific hashing
1032   virtual bool singleton(void) const;    // TRUE if type is a singleton
1033   enum {
1034    InstanceTop = -1,   // undefined instance
1035    InstanceBot = 0     // any possible instance
1036   };
1037 protected:
1038 
1039   // Oop is NULL, unless this is a constant oop.
1040   ciObject*     _const_oop;   // Constant oop
1041   // If _klass is NULL, then so is _sig.  This is an unloaded klass.
1042   ciKlass*      _klass;       // Klass object
1043   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
1044   bool          _klass_is_exact;
1045   bool          _is_ptr_to_narrowoop;
1046   bool          _is_ptr_to_narrowklass;
1047   bool          _is_ptr_to_boxed_value;
1048 
1049   // If not InstanceTop or InstanceBot, indicates that this is
1050   // a particular instance of this type which is distinct.
1051   // This is the node index of the allocation node creating this instance.
1052   int           _instance_id;
1053 
1054   static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);
1055 
1056   int dual_instance_id() const;
1057   int meet_instance_id(int uid) const;
1058 
1059   // Do not allow interface-vs.-noninterface joins to collapse to top.
1060   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1061 
1062 public:
1063   // Creates a type given a klass. Correctly handles multi-dimensional arrays
1064   // Respects UseUniqueSubclasses.
1065   // If the klass is final, the resulting type will be exact.
1066   static const TypeOopPtr* make_from_klass(ciKlass* klass) {
1067     return make_from_klass_common(klass, true, false);
1068   }
1069   // Same as before, but will produce an exact type, even if
1070   // the klass is not final, as long as it has exactly one implementation.
1071   static const TypeOopPtr* make_from_klass_unique(ciKlass* klass) {
1072     return make_from_klass_common(klass, true, true);
1073   }
1074   // Same as before, but does not respects UseUniqueSubclasses.
1075   // Use this only for creating array element types.
1076   static const TypeOopPtr* make_from_klass_raw(ciKlass* klass) {
1077     return make_from_klass_common(klass, false, false);
1078   }
1079   // Creates a singleton type given an object.
1080   // If the object cannot be rendered as a constant,
1081   // may return a non-singleton type.
1082   // If require_constant, produce a NULL if a singleton is not possible.
1083   static const TypeOopPtr* make_from_constant(ciObject* o,
1084                                               bool require_constant = false);
1085 
1086   // Make a generic (unclassed) pointer to an oop.
1087   static const TypeOopPtr* make(PTR ptr, Offset offset, int instance_id,
1088                                 const TypePtr* speculative = NULL,
1089                                 int inline_depth = InlineDepthBottom);
1090 
1091   ciObject* const_oop()    const { return _const_oop; }
1092   virtual ciKlass* klass() const { return _klass;     }
1093   bool klass_is_exact()    const { return _klass_is_exact; }
1094 
1095   // Returns true if this pointer points at memory which contains a
1096   // compressed oop references.
1097   bool is_ptr_to_narrowoop_nv() const { return _is_ptr_to_narrowoop; }
1098   bool is_ptr_to_narrowklass_nv() const { return _is_ptr_to_narrowklass; }
1099   bool is_ptr_to_boxed_value()   const { return _is_ptr_to_boxed_value; }
1100   bool is_known_instance()       const { return _instance_id &gt; 0; }
1101   int  instance_id()             const { return _instance_id; }
1102   bool is_known_instance_field() const { return is_known_instance() &amp;&amp; _offset.get() &gt;= 0; }
1103 
1104   virtual bool can_be_value_type() const { return EnableValhalla &amp;&amp; (_klass == NULL || _klass-&gt;can_be_value_klass(_klass_is_exact)); }
1105 
1106   virtual intptr_t get_con() const;
1107 
1108   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1109 
1110   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1111 
1112   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1113 
1114   // corresponding pointer to klass, for a given instance
1115   const TypeKlassPtr* as_klass_type() const;
1116 
1117   virtual const TypePtr *add_offset( intptr_t offset ) const;
1118 
1119   // Speculative type helper methods.
1120   virtual const Type* remove_speculative() const;
1121   virtual const Type* cleanup_speculative() const;
1122   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const;
1123   virtual const TypePtr* with_inline_depth(int depth) const;
1124 
1125   virtual const TypePtr* with_instance_id(int instance_id) const;
1126 
1127   virtual const Type *xdual() const;    // Compute dual right now.
1128   // the core of the computation of the meet for TypeOopPtr and for its subclasses
1129   virtual const Type *xmeet_helper(const Type *t) const;
1130 
1131   // Convenience common pre-built type.
1132   static const TypeOopPtr *BOTTOM;
1133 #ifndef PRODUCT
1134   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1135 #endif
1136 };
1137 
1138 //------------------------------TypeInstPtr------------------------------------
1139 // Class of Java object pointers, pointing either to non-array Java instances
1140 // or to a Klass* (including array klasses).
1141 class TypeInstPtr : public TypeOopPtr {
1142   TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,
1143               bool is_value, int instance_id, const TypePtr* speculative,
1144               int inline_depth);
1145   virtual bool eq( const Type *t ) const;
1146   virtual int  hash() const;             // Type specific hashing
1147 
1148   ciSymbol*  _name;        // class name
1149   bool _flat_array;
1150 
1151   bool meet_flat_array(bool other_flat_array) const {
1152     return (_flat_array &amp;&amp; other_flat_array) ? true : false;
1153   }
1154 
1155  public:
1156   ciSymbol* name()         const { return _name; }
1157 
1158   bool  is_loaded() const { return _klass-&gt;is_loaded(); }
1159 
1160   // Make a pointer to a constant oop.
1161   static const TypeInstPtr *make(ciObject* o) {
1162     return make(TypePtr::Constant, o-&gt;klass(), true, o, Offset(0), o-&gt;klass()-&gt;is_valuetype() &amp;&amp; o-&gt;klass()-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);
1163   }
1164   // Make a pointer to a constant oop with offset.
1165   static const TypeInstPtr* make(ciObject* o, Offset offset) {
1166     return make(TypePtr::Constant, o-&gt;klass(), true, o, offset, o-&gt;klass()-&gt;is_valuetype() &amp;&amp; o-&gt;klass()-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);
1167   }
1168 
1169   // Make a pointer to some value of type klass.
1170   static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {
1171     return make(ptr, klass, false, NULL, Offset(0), klass-&gt;is_valuetype() &amp;&amp; klass-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);
1172   }
1173 
1174   // Make a pointer to some non-polymorphic value of exactly type klass.
1175   static const TypeInstPtr *make_exact(PTR ptr, ciKlass* klass) {
1176     return make(ptr, klass, true, NULL, Offset(0), klass-&gt;is_valuetype() &amp;&amp; klass-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);
1177   }
1178 
1179   // Make a pointer to some value of type klass with offset.
1180   static const TypeInstPtr *make(PTR ptr, ciKlass* klass, Offset offset) {
1181     return make(ptr, klass, false, NULL, offset, klass-&gt;is_valuetype() &amp;&amp; klass-&gt;as_value_klass()-&gt;flatten_array(), InstanceBot);
1182   }
1183 
1184   // Make a pointer to an oop.
1185   static const TypeInstPtr* make(PTR ptr, ciKlass* k, bool xk, ciObject* o, Offset offset,
1186                                  bool flat_array,
1187                                  int instance_id = InstanceBot,
1188                                  const TypePtr* speculative = NULL,
1189                                  int inline_depth = InlineDepthBottom);
1190 
1191   /** Create constant type for a constant boxed value */
1192   const Type* get_const_boxed_value() const;
1193 
1194   // If this is a java.lang.Class constant, return the type for it or NULL.
1195   // Pass to Type::get_const_type to turn it to a type, which will usually
1196   // be a TypeInstPtr, but may also be a TypeInt::INT for int.class, etc.
1197   ciType* java_mirror_type(bool* is_indirect_type = NULL) const;
1198 
1199   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1200 
1201   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1202 
1203   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1204 
1205   virtual const TypePtr *add_offset( intptr_t offset ) const;
1206 
1207   // Speculative type helper methods.
1208   virtual const Type* remove_speculative() const;
1209   virtual const TypePtr* with_inline_depth(int depth) const;
1210   virtual const TypePtr* with_instance_id(int instance_id) const;
1211 
1212   virtual const TypeInstPtr* cast_to_flat_array() const;
1213   virtual bool flat_array() const {
1214     assert(!klass()-&gt;is_valuetype() || !klass()-&gt;as_value_klass()-&gt;flatten_array() || _flat_array, &quot;incorrect value bit&quot;);
1215     assert(!_flat_array || can_be_value_type(), &quot;incorrect value bit&quot;);
1216     return _flat_array;
1217   }
1218 
1219   // the core of the computation of the meet of 2 types
1220   virtual const Type *xmeet_helper(const Type *t) const;
1221   virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;
1222   virtual const Type *xdual() const;    // Compute dual right now.
1223 
1224   // Convenience common pre-built types.
1225   static const TypeInstPtr *NOTNULL;
1226   static const TypeInstPtr *BOTTOM;
1227   static const TypeInstPtr *MIRROR;
1228   static const TypeInstPtr *MARK;
1229   static const TypeInstPtr *KLASS;
1230 #ifndef PRODUCT
1231   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1232 #endif
1233 };
1234 
1235 //------------------------------TypeAryPtr-------------------------------------
1236 // Class of Java array pointers
1237 class TypeAryPtr : public TypeOopPtr {
1238   TypeAryPtr(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk,
1239              Offset offset, Offset field_offset, int instance_id, bool is_autobox_cache,
1240              const TypePtr* speculative, int inline_depth)
1241     : TypeOopPtr(AryPtr, ptr, k, xk, o, offset, field_offset, instance_id, speculative, inline_depth),
1242     _ary(ary),
1243     _is_autobox_cache(is_autobox_cache),
1244     _field_offset(field_offset)
1245  {
1246 #ifdef ASSERT
1247     if (k != NULL) {
1248       // Verify that specified klass and TypeAryPtr::klass() follow the same rules.
1249       ciKlass* ck = compute_klass(true);
1250       if (k != ck) {
1251         this-&gt;dump(); tty-&gt;cr();
1252         tty-&gt;print(&quot; k: &quot;);
1253         k-&gt;print(); tty-&gt;cr();
1254         tty-&gt;print(&quot;ck: &quot;);
1255         if (ck != NULL) ck-&gt;print();
1256         else tty-&gt;print(&quot;&lt;NULL&gt;&quot;);
1257         tty-&gt;cr();
1258         assert(false, &quot;unexpected TypeAryPtr::_klass&quot;);
1259       }
1260     }
1261 #endif
1262   }
1263   virtual bool eq( const Type *t ) const;
1264   virtual int hash() const;     // Type specific hashing
1265   const TypeAry *_ary;          // Array we point into
1266   const bool     _is_autobox_cache;
1267   // For flattened value type arrays, each field of the value type in
1268   // the array has its own memory slice so we need to keep track of
1269   // which field is accessed
1270   const Offset _field_offset;
1271   Offset meet_field_offset(const Type::Offset offset) const;
1272   Offset dual_field_offset() const;
1273 
1274   ciKlass* compute_klass(DEBUG_ONLY(bool verify = false)) const;
1275 
1276 public:
1277   // Accessors
1278   ciKlass* klass() const;
1279   const TypeAry* ary() const  { return _ary; }
1280   const Type*    elem() const { return _ary-&gt;_elem; }
1281   const TypeInt* size() const { return _ary-&gt;_size; }
1282   bool      is_stable() const { return _ary-&gt;_stable; }
1283 
1284   // Value type array properties
1285   bool is_not_flat()      const { return _ary-&gt;_not_flat; }
1286   bool is_not_null_free() const { return _ary-&gt;_not_null_free; }
1287 
1288   bool is_autobox_cache() const { return _is_autobox_cache; }
1289 
1290   static const TypeAryPtr* make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, Offset offset,
1291                                 Offset field_offset = Offset::bottom,
1292                                 int instance_id = InstanceBot,
1293                                 const TypePtr* speculative = NULL,
1294                                 int inline_depth = InlineDepthBottom);
1295   // Constant pointer to array
1296   static const TypeAryPtr* make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, Offset offset,
1297                                 Offset field_offset = Offset::bottom,
1298                                 int instance_id = InstanceBot,
1299                                 const TypePtr* speculative = NULL,
1300                                 int inline_depth = InlineDepthBottom,
1301                                 bool is_autobox_cache = false);
1302 
1303   // Return a &#39;ptr&#39; version of this type
1304   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1305 
1306   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1307 
1308   virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;
1309 
1310   virtual const TypeAryPtr* cast_to_size(const TypeInt* size) const;
1311   virtual const TypeInt* narrow_size_type(const TypeInt* size) const;
1312 
1313   virtual bool empty(void) const;        // TRUE if type is vacuous
1314   virtual const TypePtr *add_offset( intptr_t offset ) const;
1315 
1316   // Speculative type helper methods.
1317   virtual const Type* remove_speculative() const;
1318   virtual const Type* cleanup_speculative() const;
1319   virtual const TypePtr* with_inline_depth(int depth) const;
1320   virtual const TypePtr* with_instance_id(int instance_id) const;
1321 
1322   // the core of the computation of the meet of 2 types
1323   virtual const Type *xmeet_helper(const Type *t) const;
1324   virtual const Type *xdual() const;    // Compute dual right now.
1325 
1326   const TypeAryPtr* cast_to_not_flat(bool not_flat = true) const;
1327   const TypeAryPtr* cast_to_not_null_free(bool not_null_free = true) const;
1328 
1329   const TypeAryPtr* cast_to_stable(bool stable, int stable_dimension = 1) const;
1330   int stable_dimension() const;
1331 
1332   const TypeAryPtr* cast_to_autobox_cache(bool cache) const;
1333 
1334   static jint max_array_length(BasicType etype);
1335 
1336   const int flattened_offset() const;
1337   const Offset field_offset() const { return _field_offset; }
1338   const TypeAryPtr* with_field_offset(int offset) const;
1339   const TypePtr* add_field_offset_and_offset(intptr_t offset) const;
1340 
1341   virtual bool can_be_value_type() const { return false; }
1342 
1343   // Convenience common pre-built types.
1344   static const TypeAryPtr *RANGE;
1345   static const TypeAryPtr *OOPS;
1346   static const TypeAryPtr *NARROWOOPS;
1347   static const TypeAryPtr *BYTES;
1348   static const TypeAryPtr *SHORTS;
1349   static const TypeAryPtr *CHARS;
1350   static const TypeAryPtr *INTS;
1351   static const TypeAryPtr *LONGS;
1352   static const TypeAryPtr *FLOATS;
1353   static const TypeAryPtr *DOUBLES;
1354   static const TypeAryPtr *VALUES;
1355   // selects one of the above:
1356   static const TypeAryPtr *get_array_body_type(BasicType elem) {
1357     assert((uint)elem &lt;= T_CONFLICT &amp;&amp; _array_body_type[elem] != NULL, &quot;bad elem type&quot;);
1358     return _array_body_type[elem];
1359   }
1360   static const TypeAryPtr *_array_body_type[T_CONFLICT+1];
1361   // sharpen the type of an int which is used as an array size
1362 #ifdef ASSERT
1363   // One type is interface, the other is oop
1364   virtual bool interface_vs_oop(const Type *t) const;
1365 #endif
1366 #ifndef PRODUCT
1367   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1368 #endif
1369 };
1370 
1371 //------------------------------TypeMetadataPtr-------------------------------------
1372 // Some kind of metadata, either Method*, MethodData* or CPCacheOop
1373 class TypeMetadataPtr : public TypePtr {
1374 protected:
1375   TypeMetadataPtr(PTR ptr, ciMetadata* metadata, Offset offset);
1376   // Do not allow interface-vs.-noninterface joins to collapse to top.
1377   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1378 public:
1379   virtual bool eq( const Type *t ) const;
1380   virtual int  hash() const;             // Type specific hashing
1381   virtual bool singleton(void) const;    // TRUE if type is a singleton
1382 
1383 private:
1384   ciMetadata*   _metadata;
1385 
1386 public:
1387   static const TypeMetadataPtr* make(PTR ptr, ciMetadata* m, Offset offset);
1388 
1389   static const TypeMetadataPtr* make(ciMethod* m);
1390   static const TypeMetadataPtr* make(ciMethodData* m);
1391 
1392   ciMetadata* metadata() const { return _metadata; }
1393 
1394   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1395 
1396   virtual const TypePtr *add_offset( intptr_t offset ) const;
1397 
1398   virtual const Type *xmeet( const Type *t ) const;
1399   virtual const Type *xdual() const;    // Compute dual right now.
1400 
1401   virtual intptr_t get_con() const;
1402 
1403   // Convenience common pre-built types.
1404   static const TypeMetadataPtr *BOTTOM;
1405 
1406 #ifndef PRODUCT
1407   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1408 #endif
1409 };
1410 
1411 //------------------------------TypeKlassPtr-----------------------------------
1412 // Class of Java Klass pointers
1413 class TypeKlassPtr : public TypePtr {
1414   TypeKlassPtr(PTR ptr, ciKlass* klass, Offset offset, bool flat_array);
1415 
1416 protected:
1417   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1418  public:
1419   virtual bool eq( const Type *t ) const;
1420   virtual int hash() const;             // Type specific hashing
1421   virtual bool singleton(void) const;    // TRUE if type is a singleton
1422  private:
1423 
1424   ciKlass* _klass;
1425 
1426   // Does the type exclude subclasses of the klass?  (Inexact == polymorphic.)
1427   bool          _klass_is_exact;
1428   bool _flat_array;
1429 
1430 public:
1431   ciKlass* klass() const { return  _klass; }
1432   bool klass_is_exact()    const { return _klass_is_exact; }
1433 
1434   virtual bool can_be_value_type() const { return EnableValhalla &amp;&amp; (_klass == NULL || _klass-&gt;can_be_value_klass(_klass_is_exact)); }
1435   virtual bool flat_array() const {
1436     assert(!klass()-&gt;is_valuetype() || !klass()-&gt;as_value_klass()-&gt;flatten_array() || _flat_array, &quot;incorrect value bit&quot;);
1437     assert(!_flat_array || can_be_value_type(), &quot;incorrect value bit&quot;);
1438     return _flat_array;
1439   }
1440 
1441   bool  is_loaded() const { return klass() != NULL &amp;&amp; klass()-&gt;is_loaded(); }
1442 
1443   // ptr to klass &#39;k&#39;
1444   static const TypeKlassPtr* make(ciKlass* k) { return make( TypePtr::Constant, k, Offset(0), k-&gt;is_valuetype() &amp;&amp; k-&gt;as_value_klass()-&gt;flatten_array()); }
1445   // ptr to klass &#39;k&#39; with offset
1446   static const TypeKlassPtr* make(ciKlass* k, Offset offset) { return make( TypePtr::Constant, k, offset, k-&gt;is_valuetype() &amp;&amp; k-&gt;as_value_klass()-&gt;flatten_array()); }
1447   // ptr to klass &#39;k&#39; or sub-klass
1448   static const TypeKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, bool flat_array);
1449 
1450   virtual const Type *cast_to_ptr_type(PTR ptr) const;
1451 
1452   virtual const Type *cast_to_exactness(bool klass_is_exact) const;
1453 
1454   // corresponding pointer to instance, for a given class
1455   const TypeOopPtr* as_instance_type() const;
1456 
1457   virtual const TypePtr *add_offset( intptr_t offset ) const;
1458   virtual const Type    *xmeet( const Type *t ) const;
1459   virtual const Type    *xdual() const;      // Compute dual right now.
1460 
1461   virtual intptr_t get_con() const;
1462 
1463   // Convenience common pre-built types.
1464   static const TypeKlassPtr* OBJECT; // Not-null object klass or below
1465   static const TypeKlassPtr* OBJECT_OR_NULL; // Maybe-null version of same
1466 #ifndef PRODUCT
1467   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1468 #endif
1469 };
1470 
1471 class TypeNarrowPtr : public Type {
1472 protected:
1473   const TypePtr* _ptrtype; // Could be TypePtr::NULL_PTR
1474 
1475   TypeNarrowPtr(TYPES t, const TypePtr* ptrtype): Type(t),
1476                                                   _ptrtype(ptrtype) {
1477     assert(ptrtype-&gt;offset() == 0 ||
1478            ptrtype-&gt;offset() == OffsetBot ||
1479            ptrtype-&gt;offset() == OffsetTop, &quot;no real offsets&quot;);
1480   }
1481 
1482   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const = 0;
1483   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const = 0;
1484   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const = 0;
1485   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const = 0;
1486   // Do not allow interface-vs.-noninterface joins to collapse to top.
1487   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1488 public:
1489   virtual bool eq( const Type *t ) const;
1490   virtual int  hash() const;             // Type specific hashing
1491   virtual bool singleton(void) const;    // TRUE if type is a singleton
1492 
1493   virtual const Type *xmeet( const Type *t ) const;
1494   virtual const Type *xdual() const;    // Compute dual right now.
1495 
1496   virtual intptr_t get_con() const;
1497 
1498   virtual bool empty(void) const;        // TRUE if type is vacuous
1499 
1500   // returns the equivalent ptr type for this compressed pointer
1501   const TypePtr *get_ptrtype() const {
1502     return _ptrtype;
1503   }
1504 
<a name="3" id="anc3"></a>



1505 #ifndef PRODUCT
1506   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1507 #endif
1508 };
1509 
1510 //------------------------------TypeNarrowOop----------------------------------
1511 // A compressed reference to some kind of Oop.  This type wraps around
1512 // a preexisting TypeOopPtr and forwards most of it&#39;s operations to
1513 // the underlying type.  It&#39;s only real purpose is to track the
1514 // oopness of the compressed oop value when we expose the conversion
1515 // between the normal and the compressed form.
1516 class TypeNarrowOop : public TypeNarrowPtr {
1517 protected:
1518   TypeNarrowOop( const TypePtr* ptrtype): TypeNarrowPtr(NarrowOop, ptrtype) {
1519   }
1520 
1521   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1522     return t-&gt;isa_narrowoop();
1523   }
1524 
1525   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const {
1526     return t-&gt;is_narrowoop();
1527   }
1528 
1529   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const {
1530     return new TypeNarrowOop(t);
1531   }
1532 
1533   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const {
1534     return (const TypeNarrowPtr*)((new TypeNarrowOop(t))-&gt;hashcons());
1535   }
1536 
1537 public:
1538 
1539   static const TypeNarrowOop *make( const TypePtr* type);
1540 
1541   static const TypeNarrowOop* make_from_constant(ciObject* con, bool require_constant = false) {
1542     return make(TypeOopPtr::make_from_constant(con, require_constant));
1543   }
1544 
1545   static const TypeNarrowOop *BOTTOM;
1546   static const TypeNarrowOop *NULL_PTR;
1547 
1548   virtual const Type* remove_speculative() const;
1549   virtual const Type* cleanup_speculative() const;
1550 
1551 #ifndef PRODUCT
1552   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1553 #endif
1554 };
1555 
1556 //------------------------------TypeNarrowKlass----------------------------------
1557 // A compressed reference to klass pointer.  This type wraps around a
1558 // preexisting TypeKlassPtr and forwards most of it&#39;s operations to
1559 // the underlying type.
1560 class TypeNarrowKlass : public TypeNarrowPtr {
1561 protected:
1562   TypeNarrowKlass( const TypePtr* ptrtype): TypeNarrowPtr(NarrowKlass, ptrtype) {
1563   }
1564 
1565   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1566     return t-&gt;isa_narrowklass();
1567   }
1568 
1569   virtual const TypeNarrowPtr *is_same_narrowptr(const Type *t) const {
1570     return t-&gt;is_narrowklass();
1571   }
1572 
1573   virtual const TypeNarrowPtr *make_same_narrowptr(const TypePtr *t) const {
1574     return new TypeNarrowKlass(t);
1575   }
1576 
1577   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const {
1578     return (const TypeNarrowPtr*)((new TypeNarrowKlass(t))-&gt;hashcons());
1579   }
1580 
1581 public:
1582   static const TypeNarrowKlass *make( const TypePtr* type);
1583 
1584   // static const TypeNarrowKlass *BOTTOM;
1585   static const TypeNarrowKlass *NULL_PTR;
1586 
1587 #ifndef PRODUCT
1588   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1589 #endif
1590 };
1591 
1592 //------------------------------TypeFunc---------------------------------------
1593 // Class of Array Types
1594 class TypeFunc : public Type {
1595   TypeFunc(const TypeTuple *domain_sig, const TypeTuple *domain_cc, const TypeTuple *range_sig, const TypeTuple *range_cc)
1596     : Type(Function), _domain_sig(domain_sig), _domain_cc(domain_cc), _range_sig(range_sig), _range_cc(range_cc) {}
1597   virtual bool eq( const Type *t ) const;
1598   virtual int  hash() const;             // Type specific hashing
1599   virtual bool singleton(void) const;    // TRUE if type is a singleton
1600   virtual bool empty(void) const;        // TRUE if type is vacuous
1601 
1602   // Domains of inputs: value type arguments are not passed by
1603   // reference, instead each field of the value type is passed as an
1604   // argument. We maintain 2 views of the argument list here: one
1605   // based on the signature (with a value type argument as a single
1606   // slot), one based on the actual calling convention (with a value
1607   // type argument as a list of its fields).
1608   const TypeTuple* const _domain_sig;
1609   const TypeTuple* const _domain_cc;
1610   // Range of results. Similar to domains: a value type result can be
1611   // returned in registers in which case range_cc lists all fields and
1612   // is the actual calling convention.
1613   const TypeTuple* const _range_sig;
1614   const TypeTuple* const _range_cc;
1615 
1616 public:
1617   // Constants are shared among ADLC and VM
1618   enum { Control    = AdlcVMDeps::Control,
1619          I_O        = AdlcVMDeps::I_O,
1620          Memory     = AdlcVMDeps::Memory,
1621          FramePtr   = AdlcVMDeps::FramePtr,
1622          ReturnAdr  = AdlcVMDeps::ReturnAdr,
1623          Parms      = AdlcVMDeps::Parms
1624   };
1625 
1626 
1627   // Accessors:
1628   const TypeTuple* domain_sig() const { return _domain_sig; }
1629   const TypeTuple* domain_cc()  const { return _domain_cc; }
1630   const TypeTuple* range_sig()  const { return _range_sig; }
1631   const TypeTuple* range_cc()   const { return _range_cc; }
1632 
1633   static const TypeFunc* make(ciMethod* method, bool is_osr_compilation = false);
1634   static const TypeFunc *make(const TypeTuple* domain_sig, const TypeTuple* domain_cc,
1635                               const TypeTuple* range_sig, const TypeTuple* range_cc);
1636   static const TypeFunc *make(const TypeTuple* domain, const TypeTuple* range);
1637 
1638   virtual const Type *xmeet( const Type *t ) const;
1639   virtual const Type *xdual() const;    // Compute dual right now.
1640 
1641   BasicType return_type() const;
1642 
1643   bool returns_value_type_as_fields() const { return range_sig() != range_cc(); }
1644 
1645 #ifndef PRODUCT
1646   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const; // Specialized per-Type dumping
1647 #endif
1648   // Convenience common pre-built types.
1649 };
1650 
1651 //------------------------------accessors--------------------------------------
1652 inline bool Type::is_ptr_to_narrowoop() const {
1653 #ifdef _LP64
1654   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowoop_nv());
1655 #else
1656   return false;
1657 #endif
1658 }
1659 
1660 inline bool Type::is_ptr_to_narrowklass() const {
1661 #ifdef _LP64
1662   return (isa_oopptr() != NULL &amp;&amp; is_oopptr()-&gt;is_ptr_to_narrowklass_nv());
1663 #else
1664   return false;
1665 #endif
1666 }
1667 
1668 inline float Type::getf() const {
1669   assert( _base == FloatCon, &quot;Not a FloatCon&quot; );
1670   return ((TypeF*)this)-&gt;_f;
1671 }
1672 
1673 inline double Type::getd() const {
1674   assert( _base == DoubleCon, &quot;Not a DoubleCon&quot; );
1675   return ((TypeD*)this)-&gt;_d;
1676 }
1677 
1678 inline const TypeInt *Type::is_int() const {
1679   assert( _base == Int, &quot;Not an Int&quot; );
1680   return (TypeInt*)this;
1681 }
1682 
1683 inline const TypeInt *Type::isa_int() const {
1684   return ( _base == Int ? (TypeInt*)this : NULL);
1685 }
1686 
1687 inline const TypeLong *Type::is_long() const {
1688   assert( _base == Long, &quot;Not a Long&quot; );
1689   return (TypeLong*)this;
1690 }
1691 
1692 inline const TypeLong *Type::isa_long() const {
1693   return ( _base == Long ? (TypeLong*)this : NULL);
1694 }
1695 
1696 inline const TypeF *Type::isa_float() const {
1697   return ((_base == FloatTop ||
1698            _base == FloatCon ||
1699            _base == FloatBot) ? (TypeF*)this : NULL);
1700 }
1701 
1702 inline const TypeF *Type::is_float_constant() const {
1703   assert( _base == FloatCon, &quot;Not a Float&quot; );
1704   return (TypeF*)this;
1705 }
1706 
1707 inline const TypeF *Type::isa_float_constant() const {
1708   return ( _base == FloatCon ? (TypeF*)this : NULL);
1709 }
1710 
1711 inline const TypeD *Type::isa_double() const {
1712   return ((_base == DoubleTop ||
1713            _base == DoubleCon ||
1714            _base == DoubleBot) ? (TypeD*)this : NULL);
1715 }
1716 
1717 inline const TypeD *Type::is_double_constant() const {
1718   assert( _base == DoubleCon, &quot;Not a Double&quot; );
1719   return (TypeD*)this;
1720 }
1721 
1722 inline const TypeD *Type::isa_double_constant() const {
1723   return ( _base == DoubleCon ? (TypeD*)this : NULL);
1724 }
1725 
1726 inline const TypeTuple *Type::is_tuple() const {
1727   assert( _base == Tuple, &quot;Not a Tuple&quot; );
1728   return (TypeTuple*)this;
1729 }
1730 
1731 inline const TypeAry *Type::is_ary() const {
1732   assert( _base == Array , &quot;Not an Array&quot; );
1733   return (TypeAry*)this;
1734 }
1735 
1736 inline const TypeAry *Type::isa_ary() const {
1737   return ((_base == Array) ? (TypeAry*)this : NULL);
1738 }
1739 
1740 inline const TypeVect *Type::is_vect() const {
1741   assert( _base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ, &quot;Not a Vector&quot; );
1742   return (TypeVect*)this;
1743 }
1744 
1745 inline const TypeVect *Type::isa_vect() const {
1746   return (_base &gt;= VectorS &amp;&amp; _base &lt;= VectorZ) ? (TypeVect*)this : NULL;
1747 }
1748 
1749 inline const TypePtr *Type::is_ptr() const {
1750   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1751   assert(_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr, &quot;Not a pointer&quot;);
1752   return (TypePtr*)this;
1753 }
1754 
1755 inline const TypePtr *Type::isa_ptr() const {
1756   // AnyPtr is the first Ptr and KlassPtr the last, with no non-ptrs between.
1757   return (_base &gt;= AnyPtr &amp;&amp; _base &lt;= KlassPtr) ? (TypePtr*)this : NULL;
1758 }
1759 
1760 inline const TypeOopPtr *Type::is_oopptr() const {
1761   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1762   assert(_base &gt;= OopPtr &amp;&amp; _base &lt;= AryPtr, &quot;Not a Java pointer&quot; ) ;
1763   return (TypeOopPtr*)this;
1764 }
1765 
1766 inline const TypeOopPtr *Type::isa_oopptr() const {
1767   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1768   return (_base &gt;= OopPtr &amp;&amp; _base &lt;= AryPtr) ? (TypeOopPtr*)this : NULL;
1769 }
1770 
1771 inline const TypeRawPtr *Type::isa_rawptr() const {
1772   return (_base == RawPtr) ? (TypeRawPtr*)this : NULL;
1773 }
1774 
1775 inline const TypeRawPtr *Type::is_rawptr() const {
1776   assert( _base == RawPtr, &quot;Not a raw pointer&quot; );
1777   return (TypeRawPtr*)this;
1778 }
1779 
1780 inline const TypeInstPtr *Type::isa_instptr() const {
1781   return (_base == InstPtr) ? (TypeInstPtr*)this : NULL;
1782 }
1783 
1784 inline const TypeInstPtr *Type::is_instptr() const {
1785   assert( _base == InstPtr, &quot;Not an object pointer&quot; );
1786   return (TypeInstPtr*)this;
1787 }
1788 
1789 inline const TypeAryPtr *Type::isa_aryptr() const {
1790   return (_base == AryPtr) ? (TypeAryPtr*)this : NULL;
1791 }
1792 
1793 inline const TypeAryPtr *Type::is_aryptr() const {
1794   assert( _base == AryPtr, &quot;Not an array pointer&quot; );
1795   return (TypeAryPtr*)this;
1796 }
1797 
1798 inline const TypeValueType* Type::isa_valuetype() const {
1799   return (_base == ValueType) ? (TypeValueType*)this : NULL;
1800 }
1801 
1802 inline const TypeValueType* Type::is_valuetype() const {
1803   assert(_base == ValueType, &quot;Not a value type&quot;);
1804   return (TypeValueType*)this;
1805 }
1806 
1807 inline const TypeNarrowOop *Type::is_narrowoop() const {
1808   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1809   assert(_base == NarrowOop, &quot;Not a narrow oop&quot; ) ;
1810   return (TypeNarrowOop*)this;
1811 }
1812 
1813 inline const TypeNarrowOop *Type::isa_narrowoop() const {
1814   // OopPtr is the first and KlassPtr the last, with no non-oops between.
1815   return (_base == NarrowOop) ? (TypeNarrowOop*)this : NULL;
1816 }
1817 
1818 inline const TypeNarrowKlass *Type::is_narrowklass() const {
1819   assert(_base == NarrowKlass, &quot;Not a narrow oop&quot; ) ;
1820   return (TypeNarrowKlass*)this;
1821 }
1822 
1823 inline const TypeNarrowKlass *Type::isa_narrowklass() const {
1824   return (_base == NarrowKlass) ? (TypeNarrowKlass*)this : NULL;
1825 }
1826 
1827 inline const TypeMetadataPtr *Type::is_metadataptr() const {
1828   // MetadataPtr is the first and CPCachePtr the last
1829   assert(_base == MetadataPtr, &quot;Not a metadata pointer&quot; ) ;
1830   return (TypeMetadataPtr*)this;
1831 }
1832 
1833 inline const TypeMetadataPtr *Type::isa_metadataptr() const {
1834   return (_base == MetadataPtr) ? (TypeMetadataPtr*)this : NULL;
1835 }
1836 
1837 inline const TypeKlassPtr *Type::isa_klassptr() const {
1838   return (_base == KlassPtr) ? (TypeKlassPtr*)this : NULL;
1839 }
1840 
1841 inline const TypeKlassPtr *Type::is_klassptr() const {
1842   assert( _base == KlassPtr, &quot;Not a klass pointer&quot; );
1843   return (TypeKlassPtr*)this;
1844 }
1845 
1846 inline const TypePtr* Type::make_ptr() const {
1847   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype() :
1848                               ((_base == NarrowKlass) ? is_narrowklass()-&gt;get_ptrtype() :
1849                                                        isa_ptr());
1850 }
1851 
1852 inline const TypeOopPtr* Type::make_oopptr() const {
1853   return (_base == NarrowOop) ? is_narrowoop()-&gt;get_ptrtype()-&gt;isa_oopptr() : isa_oopptr();
1854 }
1855 
1856 inline const TypeNarrowOop* Type::make_narrowoop() const {
1857   return (_base == NarrowOop) ? is_narrowoop() :
1858                                 (isa_ptr() ? TypeNarrowOop::make(is_ptr()) : NULL);
1859 }
1860 
1861 inline const TypeNarrowKlass* Type::make_narrowklass() const {
1862   return (_base == NarrowKlass) ? is_narrowklass() :
1863                                   (isa_ptr() ? TypeNarrowKlass::make(is_ptr()) : NULL);
1864 }
1865 
1866 inline bool Type::is_floatingpoint() const {
1867   if( (_base == FloatCon)  || (_base == FloatBot) ||
1868       (_base == DoubleCon) || (_base == DoubleBot) )
1869     return true;
1870   return false;
1871 }
1872 
1873 inline bool Type::is_valuetypeptr() const {
1874   return isa_instptr() != NULL &amp;&amp; is_instptr()-&gt;klass()-&gt;is_valuetype();
1875 }
1876 
1877 
1878 inline ciValueKlass* Type::value_klass() const {
1879   assert(is_valuetypeptr(), &quot;must be a value type ptr&quot;);
1880   return is_instptr()-&gt;klass()-&gt;as_value_klass();
1881 }
1882 
1883 
1884 // ===============================================================
1885 // Things that need to be 64-bits in the 64-bit build but
1886 // 32-bits in the 32-bit build.  Done this way to get full
1887 // optimization AND strong typing.
1888 #ifdef _LP64
1889 
1890 // For type queries and asserts
1891 #define is_intptr_t  is_long
1892 #define isa_intptr_t isa_long
1893 #define find_intptr_t_type find_long_type
1894 #define find_intptr_t_con  find_long_con
1895 #define TypeX        TypeLong
1896 #define Type_X       Type::Long
1897 #define TypeX_X      TypeLong::LONG
1898 #define TypeX_ZERO   TypeLong::ZERO
1899 // For &#39;ideal_reg&#39; machine registers
1900 #define Op_RegX      Op_RegL
1901 // For phase-&gt;intcon variants
1902 #define MakeConX     longcon
1903 #define ConXNode     ConLNode
1904 // For array index arithmetic
1905 #define MulXNode     MulLNode
1906 #define AndXNode     AndLNode
1907 #define OrXNode      OrLNode
1908 #define CmpXNode     CmpLNode
1909 #define CmpUXNode    CmpULNode
1910 #define SubXNode     SubLNode
1911 #define LShiftXNode  LShiftLNode
1912 // For object size computation:
1913 #define AddXNode     AddLNode
1914 #define RShiftXNode  RShiftLNode
1915 // For card marks and hashcodes
1916 #define URShiftXNode URShiftLNode
1917 // UseOptoBiasInlining
1918 #define XorXNode     XorLNode
1919 #define StoreXConditionalNode StoreLConditionalNode
1920 #define LoadXNode    LoadLNode
1921 #define StoreXNode   StoreLNode
1922 // Opcodes
1923 #define Op_LShiftX   Op_LShiftL
1924 #define Op_AndX      Op_AndL
1925 #define Op_AddX      Op_AddL
1926 #define Op_SubX      Op_SubL
1927 #define Op_XorX      Op_XorL
1928 #define Op_URShiftX  Op_URShiftL
1929 #define Op_LoadX     Op_LoadL
1930 #define Op_StoreX    Op_StoreL
1931 // conversions
1932 #define ConvI2X(x)   ConvI2L(x)
1933 #define ConvL2X(x)   (x)
1934 #define ConvX2I(x)   ConvL2I(x)
1935 #define ConvX2L(x)   (x)
1936 #define ConvX2UL(x)  (x)
1937 
1938 #else
1939 
1940 // For type queries and asserts
1941 #define is_intptr_t  is_int
1942 #define isa_intptr_t isa_int
1943 #define find_intptr_t_type find_int_type
1944 #define find_intptr_t_con  find_int_con
1945 #define TypeX        TypeInt
1946 #define Type_X       Type::Int
1947 #define TypeX_X      TypeInt::INT
1948 #define TypeX_ZERO   TypeInt::ZERO
1949 // For &#39;ideal_reg&#39; machine registers
1950 #define Op_RegX      Op_RegI
1951 // For phase-&gt;intcon variants
1952 #define MakeConX     intcon
1953 #define ConXNode     ConINode
1954 // For array index arithmetic
1955 #define MulXNode     MulINode
1956 #define AndXNode     AndINode
1957 #define OrXNode      OrINode
1958 #define CmpXNode     CmpINode
1959 #define CmpUXNode    CmpUNode
1960 #define SubXNode     SubINode
1961 #define LShiftXNode  LShiftINode
1962 // For object size computation:
1963 #define AddXNode     AddINode
1964 #define RShiftXNode  RShiftINode
1965 // For card marks and hashcodes
1966 #define URShiftXNode URShiftINode
1967 // UseOptoBiasInlining
1968 #define XorXNode     XorINode
1969 #define StoreXConditionalNode StoreIConditionalNode
1970 #define LoadXNode    LoadINode
1971 #define StoreXNode   StoreINode
1972 // Opcodes
1973 #define Op_LShiftX   Op_LShiftI
1974 #define Op_AndX      Op_AndI
1975 #define Op_AddX      Op_AddI
1976 #define Op_SubX      Op_SubI
1977 #define Op_XorX      Op_XorI
1978 #define Op_URShiftX  Op_URShiftI
1979 #define Op_LoadX     Op_LoadI
1980 #define Op_StoreX    Op_StoreI
1981 // conversions
1982 #define ConvI2X(x)   (x)
1983 #define ConvL2X(x)   ConvL2I(x)
1984 #define ConvX2I(x)   (x)
1985 #define ConvX2L(x)   ConvI2L(x)
1986 #define ConvX2UL(x)  ConvI2UL(x)
1987 
1988 #endif
1989 
1990 #endif // SHARE_OPTO_TYPE_HPP
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/gcm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compile.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/gcm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 690         // Check for call into the runtime using the Java calling
 691         // convention (and from there into a wrapper); it has no
 692         // _method.  Can&#39;t do this optimization for Native calls because
 693         // they CAN write to Java memory.
 694         if (mstore-&gt;ideal_Opcode() == Op_CallStaticJava) {
 695           assert(mstore-&gt;is_MachSafePoint(), &quot;&quot;);
 696           MachSafePointNode* ms = (MachSafePointNode*) mstore;
 697           assert(ms-&gt;is_MachCallJava(), &quot;&quot;);
 698           MachCallJavaNode* mcj = (MachCallJavaNode*) ms;
 699           if (mcj-&gt;_method == NULL) {
 700             // These runtime calls do not write to Java visible memory
 701             // (other than Raw) and so do not require anti-dependence edges.
 702             continue;
 703           }
 704         }
 705         // Same for SafePoints: they read/write Raw but only read otherwise.
 706         // This is basically a workaround for SafePoints only defining control
 707         // instead of control + memory.
 708         if (mstore-&gt;ideal_Opcode() == Op_SafePoint)
 709           continue;
<span class="line-removed"> 710 </span>
<span class="line-removed"> 711         // Check if the store is a membar on which the load is control dependent.</span>
<span class="line-removed"> 712         // Inserting an anti-dependency between that membar and the load would</span>
<span class="line-removed"> 713         // create a cycle that causes local scheduling to fail.</span>
<span class="line-removed"> 714         if (mstore-&gt;isa_MachMemBar()) {</span>
<span class="line-removed"> 715           Node* dom = load-&gt;find_exact_control(load-&gt;in(0));</span>
<span class="line-removed"> 716           while (dom != NULL &amp;&amp; dom != dom-&gt;in(0) &amp;&amp; dom != mstore) {</span>
<span class="line-removed"> 717             dom = dom-&gt;in(0);</span>
<span class="line-removed"> 718           }</span>
<span class="line-removed"> 719           if (dom == mstore) {</span>
<span class="line-removed"> 720             continue;</span>
<span class="line-removed"> 721           }</span>
<span class="line-removed"> 722         }</span>
 723       } else {
 724         // Some raw memory, such as the load of &quot;top&quot; at an allocation,
 725         // can be control dependent on the previous safepoint. See
 726         // comments in GraphKit::allocate_heap() about control input.
 727         // Inserting an anti-dep between such a safepoint and a use
 728         // creates a cycle, and will cause a subsequent failure in
 729         // local scheduling.  (BugId 4919904)
 730         // (%%% How can a control input be a safepoint and not a projection??)
 731         if (mstore-&gt;ideal_Opcode() == Op_SafePoint &amp;&amp; load-&gt;in(0) == mstore)
 732           continue;
 733       }
 734     }
 735 
 736     // Identify a block that the current load must be above,
 737     // or else observe that &#39;store&#39; is all the way up in the
 738     // earliest legal block for &#39;load&#39;.  In the latter case,
 739     // immediately insert an anti-dependence edge.
 740     Block* store_block = get_block_for_node(store);
 741     assert(store_block != NULL, &quot;unused killing projections skipped above&quot;);
 742 
</pre>
<hr />
<pre>
1422     // Bailout without retry
1423     C-&gt;record_method_not_compilable(&quot;early schedule failed&quot;);
1424     return;
1425   }
1426 
1427   // Build Def-Use edges.
1428   // Compute the latency information (via backwards walk) for all the
1429   // instructions in the graph
1430   _node_latency = new GrowableArray&lt;uint&gt;(); // resource_area allocation
1431 
1432   if (C-&gt;do_scheduling()) {
1433     compute_latencies_backwards(visited, stack);
1434   }
1435 
1436   // Now schedule all codes as LATE as possible.  This is the LCA in the
1437   // dominator tree of all USES of a value.  Pick the block with the least
1438   // loop nesting depth that is lowest in the dominator tree.
1439   // ( visited.clear() called in schedule_late()-&gt;Node_Backward_Iterator() )
1440   schedule_late(visited, stack);
1441   if (C-&gt;failing()) {
<span class="line-removed">1442     // schedule_late fails only when graph is incorrect.</span>
<span class="line-removed">1443     assert(!VerifyGraphEdges, &quot;verification should have failed&quot;);</span>
1444     return;
1445   }
1446 
1447 #ifndef PRODUCT
1448   if (trace_opto_pipelining()) {
1449     tty-&gt;print(&quot;\n---- Detect implicit null checks ----\n&quot;);
1450   }
1451 #endif
1452 
1453   // Detect implicit-null-check opportunities.  Basically, find NULL checks
1454   // with suitable memory ops nearby.  Use the memory op to do the NULL check.
1455   // I can generate a memory op if there is not one nearby.
1456   if (C-&gt;is_method_compilation()) {
1457     // By reversing the loop direction we get a very minor gain on mpegaudio.
1458     // Feel free to revert to a forward loop for clarity.
1459     // for( int i=0; i &lt; (int)matcher._null_check_tests.size(); i+=2 ) {
1460     for (int i = _matcher._null_check_tests.size() - 2; i &gt;= 0; i -= 2) {
1461       Node* proj = _matcher._null_check_tests[i];
1462       Node* val  = _matcher._null_check_tests[i + 1];
1463       Block* block = get_block_for_node(proj);
</pre>
</td>
<td>
<hr />
<pre>
 690         // Check for call into the runtime using the Java calling
 691         // convention (and from there into a wrapper); it has no
 692         // _method.  Can&#39;t do this optimization for Native calls because
 693         // they CAN write to Java memory.
 694         if (mstore-&gt;ideal_Opcode() == Op_CallStaticJava) {
 695           assert(mstore-&gt;is_MachSafePoint(), &quot;&quot;);
 696           MachSafePointNode* ms = (MachSafePointNode*) mstore;
 697           assert(ms-&gt;is_MachCallJava(), &quot;&quot;);
 698           MachCallJavaNode* mcj = (MachCallJavaNode*) ms;
 699           if (mcj-&gt;_method == NULL) {
 700             // These runtime calls do not write to Java visible memory
 701             // (other than Raw) and so do not require anti-dependence edges.
 702             continue;
 703           }
 704         }
 705         // Same for SafePoints: they read/write Raw but only read otherwise.
 706         // This is basically a workaround for SafePoints only defining control
 707         // instead of control + memory.
 708         if (mstore-&gt;ideal_Opcode() == Op_SafePoint)
 709           continue;













 710       } else {
 711         // Some raw memory, such as the load of &quot;top&quot; at an allocation,
 712         // can be control dependent on the previous safepoint. See
 713         // comments in GraphKit::allocate_heap() about control input.
 714         // Inserting an anti-dep between such a safepoint and a use
 715         // creates a cycle, and will cause a subsequent failure in
 716         // local scheduling.  (BugId 4919904)
 717         // (%%% How can a control input be a safepoint and not a projection??)
 718         if (mstore-&gt;ideal_Opcode() == Op_SafePoint &amp;&amp; load-&gt;in(0) == mstore)
 719           continue;
 720       }
 721     }
 722 
 723     // Identify a block that the current load must be above,
 724     // or else observe that &#39;store&#39; is all the way up in the
 725     // earliest legal block for &#39;load&#39;.  In the latter case,
 726     // immediately insert an anti-dependence edge.
 727     Block* store_block = get_block_for_node(store);
 728     assert(store_block != NULL, &quot;unused killing projections skipped above&quot;);
 729 
</pre>
<hr />
<pre>
1409     // Bailout without retry
1410     C-&gt;record_method_not_compilable(&quot;early schedule failed&quot;);
1411     return;
1412   }
1413 
1414   // Build Def-Use edges.
1415   // Compute the latency information (via backwards walk) for all the
1416   // instructions in the graph
1417   _node_latency = new GrowableArray&lt;uint&gt;(); // resource_area allocation
1418 
1419   if (C-&gt;do_scheduling()) {
1420     compute_latencies_backwards(visited, stack);
1421   }
1422 
1423   // Now schedule all codes as LATE as possible.  This is the LCA in the
1424   // dominator tree of all USES of a value.  Pick the block with the least
1425   // loop nesting depth that is lowest in the dominator tree.
1426   // ( visited.clear() called in schedule_late()-&gt;Node_Backward_Iterator() )
1427   schedule_late(visited, stack);
1428   if (C-&gt;failing()) {


1429     return;
1430   }
1431 
1432 #ifndef PRODUCT
1433   if (trace_opto_pipelining()) {
1434     tty-&gt;print(&quot;\n---- Detect implicit null checks ----\n&quot;);
1435   }
1436 #endif
1437 
1438   // Detect implicit-null-check opportunities.  Basically, find NULL checks
1439   // with suitable memory ops nearby.  Use the memory op to do the NULL check.
1440   // I can generate a memory op if there is not one nearby.
1441   if (C-&gt;is_method_compilation()) {
1442     // By reversing the loop direction we get a very minor gain on mpegaudio.
1443     // Feel free to revert to a forward loop for clarity.
1444     // for( int i=0; i &lt; (int)matcher._null_check_tests.size(); i+=2 ) {
1445     for (int i = _matcher._null_check_tests.size() - 2; i &gt;= 0; i -= 2) {
1446       Node* proj = _matcher._null_check_tests[i];
1447       Node* val  = _matcher._null_check_tests[i + 1];
1448       Block* block = get_block_for_node(proj);
</pre>
</td>
</tr>
</table>
<center><a href="compile.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
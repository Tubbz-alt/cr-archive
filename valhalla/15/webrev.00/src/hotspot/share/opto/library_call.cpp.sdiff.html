<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/library_call.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="idealKit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopPredicate.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/library_call.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
4555   Node* raw_obj = alloc_obj-&gt;in(1);
4556   assert(alloc_obj-&gt;is_CheckCastPP() &amp;&amp; raw_obj-&gt;is_Proj() &amp;&amp; raw_obj-&gt;in(0)-&gt;is_Allocate(), &quot;&quot;);
4557 
4558   AllocateNode* alloc = NULL;
4559   if (ReduceBulkZeroing) {
4560     // We will be completely responsible for initializing this object -
4561     // mark Initialize node as complete.
4562     alloc = AllocateNode::Ideal_allocation(alloc_obj, &amp;_gvn);
4563     // The object was just allocated - there should be no any stores!
4564     guarantee(alloc != NULL &amp;&amp; alloc-&gt;maybe_set_complete(&amp;_gvn), &quot;&quot;);
4565     // Mark as complete_with_arraycopy so that on AllocateNode
4566     // expansion, we know this AllocateNode is initialized by an array
4567     // copy and a StoreStore barrier exists after the array copy.
4568     alloc-&gt;initialization()-&gt;set_complete_with_arraycopy();
4569   }
4570 
4571   Node* size = _gvn.transform(obj_size);
4572   // Exclude the header but include array length to copy by 8 bytes words.
4573   // Can&#39;t use base_offset_in_bytes(bt) since basic type is unknown.
4574   int base_off = BarrierSetC2::arraycopy_payload_base_offset(is_array);
<span class="line-removed">4575   Node* src_base  = basic_plus_adr(obj,  base_off);</span>
<span class="line-removed">4576   Node* dst_base = basic_plus_adr(alloc_obj, base_off);</span>
<span class="line-removed">4577 </span>
<span class="line-removed">4578   // Compute the length also, if needed:</span>
4579   Node* countx = size;
4580   countx = _gvn.transform(new SubXNode(countx, MakeConX(base_off)));
4581   countx = _gvn.transform(new URShiftXNode(countx, intcon(LogBytesPerLong)));
4582 
<span class="line-modified">4583   access_clone(src_base, dst_base, countx, is_array);</span>
4584 
4585   // Do not let reads from the cloned object float above the arraycopy.
4586   if (alloc != NULL) {
4587     // Do not let stores that initialize this object be reordered with
4588     // a subsequent store that would make this object accessible by
4589     // other threads.
4590     // Record what AllocateNode this StoreStore protects so that
4591     // escape analysis can go from the MemBarStoreStoreNode to the
4592     // AllocateNode and eliminate the MemBarStoreStoreNode if possible
4593     // based on the escape status of the AllocateNode.
4594     insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
4595   } else {
4596     insert_mem_bar(Op_MemBarCPUOrder);
4597   }
4598 }
4599 
4600 //------------------------inline_native_clone----------------------------
4601 // protected native Object java.lang.Object.clone();
4602 //
4603 // Here are the simple edge cases:
</pre>
</td>
<td>
<hr />
<pre>
4555   Node* raw_obj = alloc_obj-&gt;in(1);
4556   assert(alloc_obj-&gt;is_CheckCastPP() &amp;&amp; raw_obj-&gt;is_Proj() &amp;&amp; raw_obj-&gt;in(0)-&gt;is_Allocate(), &quot;&quot;);
4557 
4558   AllocateNode* alloc = NULL;
4559   if (ReduceBulkZeroing) {
4560     // We will be completely responsible for initializing this object -
4561     // mark Initialize node as complete.
4562     alloc = AllocateNode::Ideal_allocation(alloc_obj, &amp;_gvn);
4563     // The object was just allocated - there should be no any stores!
4564     guarantee(alloc != NULL &amp;&amp; alloc-&gt;maybe_set_complete(&amp;_gvn), &quot;&quot;);
4565     // Mark as complete_with_arraycopy so that on AllocateNode
4566     // expansion, we know this AllocateNode is initialized by an array
4567     // copy and a StoreStore barrier exists after the array copy.
4568     alloc-&gt;initialization()-&gt;set_complete_with_arraycopy();
4569   }
4570 
4571   Node* size = _gvn.transform(obj_size);
4572   // Exclude the header but include array length to copy by 8 bytes words.
4573   // Can&#39;t use base_offset_in_bytes(bt) since basic type is unknown.
4574   int base_off = BarrierSetC2::arraycopy_payload_base_offset(is_array);




4575   Node* countx = size;
4576   countx = _gvn.transform(new SubXNode(countx, MakeConX(base_off)));
4577   countx = _gvn.transform(new URShiftXNode(countx, intcon(LogBytesPerLong)));
4578 
<span class="line-modified">4579   access_clone(obj, alloc_obj, countx, is_array);</span>
4580 
4581   // Do not let reads from the cloned object float above the arraycopy.
4582   if (alloc != NULL) {
4583     // Do not let stores that initialize this object be reordered with
4584     // a subsequent store that would make this object accessible by
4585     // other threads.
4586     // Record what AllocateNode this StoreStore protects so that
4587     // escape analysis can go from the MemBarStoreStoreNode to the
4588     // AllocateNode and eliminate the MemBarStoreStoreNode if possible
4589     // based on the escape status of the AllocateNode.
4590     insert_mem_bar(Op_MemBarStoreStore, alloc-&gt;proj_out_or_null(AllocateNode::RawAddress));
4591   } else {
4592     insert_mem_bar(Op_MemBarCPUOrder);
4593   }
4594 }
4595 
4596 //------------------------inline_native_clone----------------------------
4597 // protected native Object java.lang.Object.clone();
4598 //
4599 // Here are the simple edge cases:
</pre>
</td>
</tr>
</table>
<center><a href="idealKit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="loopPredicate.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
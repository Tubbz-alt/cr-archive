<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/output.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="node.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="output.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/output.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.inline.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;code/compiledIC.hpp&quot;
  29 #include &quot;code/debugInfo.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;compiler/compilerDirectives.hpp&quot;
  33 #include &quot;compiler/oopMap.hpp&quot;
  34 #include &quot;gc/shared/barrierSet.hpp&quot;
  35 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;opto/ad.hpp&quot;


  38 #include &quot;opto/callnode.hpp&quot;
  39 #include &quot;opto/cfgnode.hpp&quot;
  40 #include &quot;opto/locknode.hpp&quot;
  41 #include &quot;opto/machnode.hpp&quot;

  42 #include &quot;opto/optoreg.hpp&quot;
  43 #include &quot;opto/output.hpp&quot;
  44 #include &quot;opto/regalloc.hpp&quot;
  45 #include &quot;opto/runtime.hpp&quot;
  46 #include &quot;opto/subnode.hpp&quot;
  47 #include &quot;opto/type.hpp&quot;
  48 #include &quot;runtime/handles.inline.hpp&quot;

  49 #include &quot;utilities/macros.hpp&quot;
  50 #include &quot;utilities/powerOfTwo.hpp&quot;
  51 #include &quot;utilities/xmlstream.hpp&quot;
  52 #ifdef X86
  53 #include &quot;c2_intelJccErratum_x86.hpp&quot;
  54 #endif
  55 
  56 #ifndef PRODUCT
  57 #define DEBUG_ARG(x) , x
  58 #else
  59 #define DEBUG_ARG(x)
  60 #endif
  61 









































































































































































































  62 // Convert Nodes to instruction bits and pass off to the VM
<span class="line-modified">  63 void Compile::Output() {</span>
  64   // RootNode goes
<span class="line-modified">  65   assert( _cfg-&gt;get_root_block()-&gt;number_of_nodes() == 0, &quot;&quot; );</span>
  66 
  67   // The number of new nodes (mostly MachNop) is proportional to
  68   // the number of java calls and inner loops which are aligned.
  69   if ( C-&gt;check_node_count((NodeLimitFudgeFactor + C-&gt;java_calls()*3 +
  70                             C-&gt;inner_loops()*(OptoLoopAlignment-1)),
  71                            &quot;out of nodes before code generation&quot; ) ) {
  72     return;
  73   }
  74   // Make sure I can find the Start Node
<span class="line-modified">  75   Block *entry = _cfg-&gt;get_block(1);</span>
<span class="line-modified">  76   Block *broot = _cfg-&gt;get_root_block();</span>
  77 
  78   const StartNode *start = entry-&gt;head()-&gt;as_Start();
  79 
  80   // Replace StartNode with prolog
  81   Label verified_entry;
  82   MachPrologNode* prolog = new MachPrologNode(&amp;verified_entry);
  83   entry-&gt;map_node(prolog, 0);
<span class="line-modified">  84   _cfg-&gt;map_node_to_block(prolog, entry);</span>
<span class="line-modified">  85   _cfg-&gt;unmap_node_from_block(start); // start is no longer in any block</span>
  86 
  87   // Virtual methods need an unverified entry point
<span class="line-modified">  88   if (is_osr_compilation()) {</span>
  89     if (PoisonOSREntry) {
  90       // TODO: Should use a ShouldNotReachHereNode...
<span class="line-modified">  91       _cfg-&gt;insert( broot, 0, new MachBreakpointNode() );</span>
  92     }
  93   } else {
<span class="line-modified">  94     if (_method) {</span>
<span class="line-modified">  95       if (_method-&gt;has_scalarized_args()) {</span>
  96         // Add entry point to unpack all value type arguments
<span class="line-modified">  97         _cfg-&gt;insert(broot, 0, new MachVEPNode(&amp;verified_entry, /* verified */ true, /* receiver_only */ false));</span>
<span class="line-modified">  98         if (!_method-&gt;is_static()) {</span>
  99           // Add verified/unverified entry points to only unpack value type receiver at interface calls
<span class="line-modified"> 100           _cfg-&gt;insert(broot, 0, new MachVEPNode(&amp;verified_entry, /* verified */ false, /* receiver_only */ false));</span>
<span class="line-modified"> 101           _cfg-&gt;insert(broot, 0, new MachVEPNode(&amp;verified_entry, /* verified */ true,  /* receiver_only */ true));</span>
<span class="line-modified"> 102           _cfg-&gt;insert(broot, 0, new MachVEPNode(&amp;verified_entry, /* verified */ false, /* receiver_only */ true));</span>
 103         }
<span class="line-modified"> 104       } else if (!_method-&gt;is_static()) {</span>
 105         // Insert unvalidated entry point
<span class="line-modified"> 106         _cfg-&gt;insert(broot, 0, new MachUEPNode());</span>
 107       }
 108     }
 109   }
 110 
 111   // Break before main entry point
<span class="line-modified"> 112   if ((_method &amp;&amp; C-&gt;directive()-&gt;BreakAtExecuteOption) ||</span>
<span class="line-modified"> 113       (OptoBreakpoint &amp;&amp; is_method_compilation())       ||</span>
<span class="line-modified"> 114       (OptoBreakpointOSR &amp;&amp; is_osr_compilation())       ||</span>
<span class="line-modified"> 115       (OptoBreakpointC2R &amp;&amp; !_method)                   ) {</span>
<span class="line-modified"> 116     // checking for _method means that OptoBreakpoint does not apply to</span>
 117     // runtime stubs or frame converters
<span class="line-modified"> 118     _cfg-&gt;insert( entry, 1, new MachBreakpointNode() );</span>
 119   }
 120 
 121   // Insert epilogs before every return
<span class="line-modified"> 122   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified"> 123     Block* block = _cfg-&gt;get_block(i);</span>
<span class="line-modified"> 124     if (!block-&gt;is_connector() &amp;&amp; block-&gt;non_connector_successor(0) == _cfg-&gt;get_root_block()) { // Found a program exit point?</span>
 125       Node* m = block-&gt;end();
 126       if (m-&gt;is_Mach() &amp;&amp; m-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Halt) {
 127         MachEpilogNode* epilog = new MachEpilogNode(m-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Return);
 128         block-&gt;add_inst(epilog);
<span class="line-modified"> 129         _cfg-&gt;map_node_to_block(epilog, block);</span>
 130       }
 131     }
 132   }
 133 
 134   // Keeper of sizing aspects
 135   BufferSizingData buf_sizes = BufferSizingData();
 136 
 137   // Initialize code buffer
 138   estimate_buffer_size(buf_sizes._const);
<span class="line-modified"> 139   if (failing()) return;</span>
 140 
 141   // Pre-compute the length of blocks and replace
 142   // long branches with short if machine supports it.
 143   // Must be done before ScheduleAndBundle due to SPARC delay slots
<span class="line-modified"> 144   uint* blk_starts = NEW_RESOURCE_ARRAY(uint, _cfg-&gt;number_of_blocks() + 1);</span>
 145   blk_starts[0] = 0;
 146   shorten_branches(blk_starts, buf_sizes);
 147 
<span class="line-modified"> 148   if (!is_osr_compilation() &amp;&amp; _method &amp;&amp; _method-&gt;has_scalarized_args()) {</span>
 149     // Compute the offsets of the entry points required by the value type calling convention
<span class="line-modified"> 150     if (!_method-&gt;is_static()) {</span>
 151       // We have entries at the beginning of the method, implemented by the first 4 nodes.
 152       // Entry                     (unverified) @ offset 0
 153       // Verified_Value_Entry_RO
 154       // Value_Entry               (unverified)
 155       // Verified_Value_Entry
 156       uint offset = 0;
 157       _code_offsets.set_value(CodeOffsets::Entry, offset);
 158 
<span class="line-modified"> 159       offset += ((MachVEPNode*)broot-&gt;get_node(0))-&gt;size(_regalloc);</span>
 160       _code_offsets.set_value(CodeOffsets::Verified_Value_Entry_RO, offset);
 161 
<span class="line-modified"> 162       offset += ((MachVEPNode*)broot-&gt;get_node(1))-&gt;size(_regalloc);</span>
 163       _code_offsets.set_value(CodeOffsets::Value_Entry, offset);
 164 
<span class="line-modified"> 165       offset += ((MachVEPNode*)broot-&gt;get_node(2))-&gt;size(_regalloc);</span>
 166       _code_offsets.set_value(CodeOffsets::Verified_Value_Entry, offset);
 167     } else {
 168       _code_offsets.set_value(CodeOffsets::Entry, -1); // will be patched later
 169       _code_offsets.set_value(CodeOffsets::Verified_Value_Entry, 0);
 170     }
 171   }
 172 
 173   ScheduleAndBundle();
<span class="line-modified"> 174   if (failing()) {</span>
 175     return;
 176   }
 177 
 178   // Late barrier analysis must be done after schedule and bundle
 179   // Otherwise liveness based spilling will fail
 180   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 181   bs-&gt;late_barrier_analysis();
 182 
 183 #ifdef X86
 184   if (VM_Version::has_intel_jcc_erratum()) {
<span class="line-modified"> 185     int extra_padding = IntelJccErratum::tag_affected_machnodes(this, _cfg, _regalloc);</span>
 186     buf_sizes._code += extra_padding;
 187   }
 188 #endif
 189 
 190   // Complete sizing of codebuffer
 191   CodeBuffer* cb = init_buffer(buf_sizes);
<span class="line-modified"> 192   if (cb == NULL || failing()) {</span>
 193     return;
 194   }
 195 
 196   BuildOopMaps();
 197 
<span class="line-modified"> 198   if (failing())  {</span>
 199     return;
 200   }
 201 
 202   fill_buffer(cb, blk_starts);
 203 }
 204 
<span class="line-modified"> 205 bool Compile::need_stack_bang(int frame_size_in_bytes) const {</span>
 206   // Determine if we need to generate a stack overflow check.
 207   // Do it if the method is not a stub function and
 208   // has java calls or has frame size &gt; vm_page_size/8.
 209   // The debug VM checks that deoptimization doesn&#39;t trigger an
 210   // unexpected stack overflow (compiled method stack banging should
 211   // guarantee it doesn&#39;t happen) so we always need the stack bang in
 212   // a debug VM.
<span class="line-modified"> 213   return (UseStackBanging &amp;&amp; stub_function() == NULL &amp;&amp;</span>
<span class="line-modified"> 214           (has_java_calls() || frame_size_in_bytes &gt; os::vm_page_size()&gt;&gt;3</span>
 215            DEBUG_ONLY(|| true)));
 216 }
 217 
<span class="line-modified"> 218 bool Compile::need_register_stack_bang() const {</span>
 219   // Determine if we need to generate a register stack overflow check.
 220   // This is only used on architectures which have split register
 221   // and memory stacks (ie. IA64).
 222   // Bang if the method is not a stub function and has java calls
<span class="line-modified"> 223   return (stub_function() == NULL &amp;&amp; has_java_calls());</span>
 224 }
 225 
 226 
 227 // Compute the size of first NumberOfLoopInstrToAlign instructions at the top
 228 // of a loop. When aligning a loop we need to provide enough instructions
 229 // in cpu&#39;s fetch buffer to feed decoders. The loop alignment could be
 230 // avoided if we have enough instructions in fetch buffer at the head of a loop.
 231 // By default, the size is set to 999999 by Block&#39;s constructor so that
 232 // a loop will be aligned if the size is not reset here.
 233 //
 234 // Note: Mach instructions could contain several HW instructions
 235 // so the size is estimated only.
 236 //
<span class="line-modified"> 237 void Compile::compute_loop_first_inst_sizes() {</span>
 238   // The next condition is used to gate the loop alignment optimization.
 239   // Don&#39;t aligned a loop if there are enough instructions at the head of a loop
 240   // or alignment padding is larger then MaxLoopPad. By default, MaxLoopPad
 241   // is equal to OptoLoopAlignment-1 except on new Intel cpus, where it is
 242   // equal to 11 bytes which is the largest address NOP instruction.
 243   if (MaxLoopPad &lt; OptoLoopAlignment - 1) {
<span class="line-modified"> 244     uint last_block = _cfg-&gt;number_of_blocks() - 1;</span>
 245     for (uint i = 1; i &lt;= last_block; i++) {
<span class="line-modified"> 246       Block* block = _cfg-&gt;get_block(i);</span>
 247       // Check the first loop&#39;s block which requires an alignment.
 248       if (block-&gt;loop_alignment() &gt; (uint)relocInfo::addr_unit()) {
 249         uint sum_size = 0;
 250         uint inst_cnt = NumberOfLoopInstrToAlign;
<span class="line-modified"> 251         inst_cnt = block-&gt;compute_first_inst_size(sum_size, inst_cnt, _regalloc);</span>
 252 
 253         // Check subsequent fallthrough blocks if the loop&#39;s first
 254         // block(s) does not have enough instructions.
 255         Block *nb = block;
 256         while(inst_cnt &gt; 0 &amp;&amp;
 257               i &lt; last_block &amp;&amp;
<span class="line-modified"> 258               !_cfg-&gt;get_block(i + 1)-&gt;has_loop_alignment() &amp;&amp;</span>
 259               !nb-&gt;has_successor(block)) {
 260           i++;
<span class="line-modified"> 261           nb = _cfg-&gt;get_block(i);</span>
<span class="line-modified"> 262           inst_cnt  = nb-&gt;compute_first_inst_size(sum_size, inst_cnt, _regalloc);</span>
 263         } // while( inst_cnt &gt; 0 &amp;&amp; i &lt; last_block  )
 264 
 265         block-&gt;set_first_inst_size(sum_size);
 266       } // f( b-&gt;head()-&gt;is_Loop() )
 267     } // for( i &lt;= last_block )
 268   } // if( MaxLoopPad &lt; OptoLoopAlignment-1 )
 269 }
 270 
 271 // The architecture description provides short branch variants for some long
 272 // branch instructions. Replace eligible long branches with short branches.
<span class="line-modified"> 273 void Compile::shorten_branches(uint* blk_starts, BufferSizingData&amp; buf_sizes) {</span>
 274   // Compute size of each block, method size, and relocation information size
<span class="line-modified"> 275   uint nblocks  = _cfg-&gt;number_of_blocks();</span>
 276 
 277   uint*      jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
 278   uint*      jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
 279   int*       jmp_nidx   = NEW_RESOURCE_ARRAY(int ,nblocks);
 280 
 281   // Collect worst case block paddings
 282   int* block_worst_case_pad = NEW_RESOURCE_ARRAY(int, nblocks);
 283   memset(block_worst_case_pad, 0, nblocks * sizeof(int));
 284 
 285   DEBUG_ONLY( uint *jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks); )
 286   DEBUG_ONLY( uint *jmp_rule = NEW_RESOURCE_ARRAY(uint,nblocks); )
 287 
 288   bool has_short_branch_candidate = false;
 289 
 290   // Initialize the sizes to 0
 291   int code_size  = 0;          // Size in bytes of generated code
 292   int stub_size  = 0;          // Size in bytes of all stub entries
 293   // Size in bytes of all relocation entries, including those in local stubs.
 294   // Start with 2-bytes of reloc info for the unvalidated entry point
 295   int reloc_size = 1;          // Number of relocation entries
 296 
 297   // Make three passes.  The first computes pessimistic blk_starts,
 298   // relative jmp_offset and reloc_size information.  The second performs
 299   // short branch substitution using the pessimistic sizing.  The
 300   // third inserts nops where needed.
 301 
 302   // Step one, perform a pessimistic sizing pass.
 303   uint last_call_adr = max_juint;
 304   uint last_avoid_back_to_back_adr = max_juint;
<span class="line-modified"> 305   uint nop_size = (new MachNopNode())-&gt;size(_regalloc);</span>
 306   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
<span class="line-modified"> 307     Block* block = _cfg-&gt;get_block(i);</span>
 308 
 309     // During short branch replacement, we store the relative (to blk_starts)
 310     // offset of jump in jmp_offset, rather than the absolute offset of jump.
 311     // This is so that we do not need to recompute sizes of all nodes when
 312     // we compute correct blk_starts in our next sizing pass.
 313     jmp_offset[i] = 0;
 314     jmp_size[i]   = 0;
 315     jmp_nidx[i]   = -1;
 316     DEBUG_ONLY( jmp_target[i] = 0; )
 317     DEBUG_ONLY( jmp_rule[i]   = 0; )
 318 
 319     // Sum all instruction sizes to compute block size
 320     uint last_inst = block-&gt;number_of_nodes();
 321     uint blk_size = 0;
 322     for (uint j = 0; j &lt; last_inst; j++) {
 323       Node* nj = block-&gt;get_node(j);
 324       // Handle machine instruction nodes
 325       if (nj-&gt;is_Mach()) {
 326         MachNode *mach = nj-&gt;as_Mach();
 327         blk_size += (mach-&gt;alignment_required() - 1) * relocInfo::addr_unit(); // assume worst case padding
</pre>
<hr />
<pre>
 363             blk_size += nop_size;
 364           }
 365         }
 366         if (mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 367           // Nop is inserted between &quot;avoid back to back&quot; instructions.
 368           // ScheduleAndBundle() can rearrange nodes in a block,
 369           // check for all offsets inside this block.
 370           if (last_avoid_back_to_back_adr &gt;= blk_starts[i]) {
 371             blk_size += nop_size;
 372           }
 373         }
 374         if (mach-&gt;may_be_short_branch()) {
 375           if (!nj-&gt;is_MachBranch()) {
 376 #ifndef PRODUCT
 377             nj-&gt;dump(3);
 378 #endif
 379             Unimplemented();
 380           }
 381           assert(jmp_nidx[i] == -1, &quot;block should have only one branch&quot;);
 382           jmp_offset[i] = blk_size;
<span class="line-modified"> 383           jmp_size[i]   = nj-&gt;size(_regalloc);</span>
 384           jmp_nidx[i]   = j;
 385           has_short_branch_candidate = true;
 386         }
 387       }
<span class="line-modified"> 388       blk_size += nj-&gt;size(_regalloc);</span>
 389       // Remember end of call offset
 390       if (nj-&gt;is_MachCall() &amp;&amp; !nj-&gt;is_MachCallLeaf()) {
 391         last_call_adr = blk_starts[i]+blk_size;
 392       }
 393       // Remember end of avoid_back_to_back offset
 394       if (nj-&gt;is_Mach() &amp;&amp; nj-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
 395         last_avoid_back_to_back_adr = blk_starts[i]+blk_size;
 396       }
 397     }
 398 
 399     // When the next block starts a loop, we may insert pad NOP
 400     // instructions.  Since we cannot know our future alignment,
 401     // assume the worst.
 402     if (i &lt; nblocks - 1) {
<span class="line-modified"> 403       Block* nb = _cfg-&gt;get_block(i + 1);</span>
 404       int max_loop_pad = nb-&gt;code_alignment()-relocInfo::addr_unit();
 405       if (max_loop_pad &gt; 0) {
 406         assert(is_power_of_2(max_loop_pad+relocInfo::addr_unit()), &quot;&quot;);
 407         // Adjust last_call_adr and/or last_avoid_back_to_back_adr.
 408         // If either is the last instruction in this block, bump by
 409         // max_loop_pad in lock-step with blk_size, so sizing
 410         // calculations in subsequent blocks still can conservatively
 411         // detect that it may the last instruction in this block.
 412         if (last_call_adr == blk_starts[i]+blk_size) {
 413           last_call_adr += max_loop_pad;
 414         }
 415         if (last_avoid_back_to_back_adr == blk_starts[i]+blk_size) {
 416           last_avoid_back_to_back_adr += max_loop_pad;
 417         }
 418         blk_size += max_loop_pad;
 419         block_worst_case_pad[i + 1] = max_loop_pad;
 420       }
 421     }
 422 
 423     // Save block size; update total method size
 424     blk_starts[i+1] = blk_starts[i]+blk_size;
 425   }
 426 
 427   // Step two, replace eligible long jumps.
 428   bool progress = true;
 429   uint last_may_be_short_branch_adr = max_juint;
 430   while (has_short_branch_candidate &amp;&amp; progress) {
 431     progress = false;
 432     has_short_branch_candidate = false;
 433     int adjust_block_start = 0;
 434     for (uint i = 0; i &lt; nblocks; i++) {
<span class="line-modified"> 435       Block* block = _cfg-&gt;get_block(i);</span>
 436       int idx = jmp_nidx[i];
 437       MachNode* mach = (idx == -1) ? NULL: block-&gt;get_node(idx)-&gt;as_Mach();
 438       if (mach != NULL &amp;&amp; mach-&gt;may_be_short_branch()) {
 439 #ifdef ASSERT
 440         assert(jmp_size[i] &gt; 0 &amp;&amp; mach-&gt;is_MachBranch(), &quot;sanity&quot;);
 441         int j;
 442         // Find the branch; ignore trailing NOPs.
 443         for (j = block-&gt;number_of_nodes()-1; j&gt;=0; j--) {
 444           Node* n = block-&gt;get_node(j);
 445           if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con)
 446             break;
 447         }
 448         assert(j &gt;= 0 &amp;&amp; j == idx &amp;&amp; block-&gt;get_node(j) == (Node*)mach, &quot;sanity&quot;);
 449 #endif
 450         int br_size = jmp_size[i];
 451         int br_offs = blk_starts[i] + jmp_offset[i];
 452 
 453         // This requires the TRUE branch target be in succs[0]
 454         uint bnum = block-&gt;non_connector_successor(0)-&gt;_pre_order;
 455         int offset = blk_starts[bnum] - br_offs;
 456         if (bnum &gt; i) { // adjust following block&#39;s offset
 457           offset -= adjust_block_start;
 458         }
 459 
 460         // This block can be a loop header, account for the padding
 461         // in the previous block.
 462         int block_padding = block_worst_case_pad[i];
 463         assert(i == 0 || block_padding == 0 || br_offs &gt;= block_padding, &quot;Should have at least a padding on top&quot;);
 464         // In the following code a nop could be inserted before
 465         // the branch which will increase the backward distance.
 466         bool needs_padding = ((uint)(br_offs - block_padding) == last_may_be_short_branch_adr);
 467         assert(!needs_padding || jmp_offset[i] == 0, &quot;padding only branches at the beginning of block&quot;);
 468 
 469         if (needs_padding &amp;&amp; offset &lt;= 0)
 470           offset -= nop_size;
 471 
<span class="line-modified"> 472         if (_matcher-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {</span>
 473           // We&#39;ve got a winner.  Replace this branch.
 474           MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
 475 
 476           // Update the jmp_size.
<span class="line-modified"> 477           int new_size = replacement-&gt;size(_regalloc);</span>
 478           int diff     = br_size - new_size;
 479           assert(diff &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
 480           // Conservatively take into account padding between
 481           // avoid_back_to_back branches. Previous branch could be
 482           // converted into avoid_back_to_back branch during next
 483           // rounds.
 484           if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 485             jmp_offset[i] += nop_size;
 486             diff -= nop_size;
 487           }
 488           adjust_block_start += diff;
 489           block-&gt;map_node(replacement, idx);
 490           mach-&gt;subsume_by(replacement, C);
 491           mach = replacement;
 492           progress = true;
 493 
 494           jmp_size[i] = new_size;
 495           DEBUG_ONLY( jmp_target[i] = bnum; );
 496           DEBUG_ONLY( jmp_rule[i] = mach-&gt;rule(); );
 497         } else {
 498           // The jump distance is not short, try again during next iteration.
 499           has_short_branch_candidate = true;
 500         }
 501       } // (mach-&gt;may_be_short_branch())
 502       if (mach != NULL &amp;&amp; (mach-&gt;may_be_short_branch() ||
 503                            mach-&gt;avoid_back_to_back(MachNode::AVOID_AFTER))) {
 504         last_may_be_short_branch_adr = blk_starts[i] + jmp_offset[i] + jmp_size[i];
 505       }
 506       blk_starts[i+1] -= adjust_block_start;
 507     }
 508   }
 509 
 510 #ifdef ASSERT
 511   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
 512     if (jmp_target[i] != 0) {
 513       int br_size = jmp_size[i];
 514       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
<span class="line-modified"> 515       if (!_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {</span>
 516         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
 517       }
<span class="line-modified"> 518       assert(_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset), &quot;Displacement too large for short jmp&quot;);</span>
 519     }
 520   }
 521 #endif
 522 
 523   // Step 3, compute the offsets of all blocks, will be done in fill_buffer()
 524   // after ScheduleAndBundle().
 525 
 526   // ------------------
 527   // Compute size for code buffer
 528   code_size = blk_starts[nblocks];
 529 
 530   // Relocation records
 531   reloc_size += 1;              // Relo entry for exception handler
 532 
 533   // Adjust reloc_size to number of record of relocation info
 534   // Min is 2 bytes, max is probably 6 or 8, with a tax up to 25% for
 535   // a relocation index.
 536   // The CodeBuffer will expand the locs array if this estimate is too low.
 537   reloc_size *= 10 / sizeof(relocInfo);
 538 
 539   buf_sizes._reloc = reloc_size;
 540   buf_sizes._code  = code_size;
 541   buf_sizes._stub  = stub_size;
 542 }
 543 
 544 //------------------------------FillLocArray-----------------------------------
 545 // Create a bit of debug info and append it to the array.  The mapping is from
 546 // Java local or expression stack to constant, register or stack-slot.  For
 547 // doubles, insert 2 mappings and return 1 (to tell the caller that the next
 548 // entry has been taken care of and caller should skip it).
 549 static LocationValue *new_loc_value( PhaseRegAlloc *ra, OptoReg::Name regnum, Location::Type l_type ) {
 550   // This should never have accepted Bad before
 551   assert(OptoReg::is_valid(regnum), &quot;location must be valid&quot;);
 552   return (OptoReg::is_reg(regnum))
 553          ? new LocationValue(Location::new_reg_loc(l_type, OptoReg::as_VMReg(regnum)) )
 554          : new LocationValue(Location::new_stk_loc(l_type,  ra-&gt;reg2offset(regnum)));
 555 }
 556 
 557 
 558 ObjectValue*
<span class="line-modified"> 559 Compile::sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id) {</span>
 560   for (int i = 0; i &lt; objs-&gt;length(); i++) {
 561     assert(objs-&gt;at(i)-&gt;is_object(), &quot;corrupt object cache&quot;);
 562     ObjectValue* sv = (ObjectValue*) objs-&gt;at(i);
 563     if (sv-&gt;id() == id) {
 564       return sv;
 565     }
 566   }
 567   // Otherwise..
 568   return NULL;
 569 }
 570 
<span class="line-modified"> 571 void Compile::set_sv_for_object_node(GrowableArray&lt;ScopeValue*&gt; *objs,</span>
 572                                      ObjectValue* sv ) {
 573   assert(sv_for_node_id(objs, sv-&gt;id()) == NULL, &quot;Precondition&quot;);
 574   objs-&gt;append(sv);
 575 }
 576 
 577 
<span class="line-modified"> 578 void Compile::FillLocArray( int idx, MachSafePointNode* sfpt, Node *local,</span>
 579                             GrowableArray&lt;ScopeValue*&gt; *array,
 580                             GrowableArray&lt;ScopeValue*&gt; *objs ) {
 581   assert( local, &quot;use _top instead of null&quot; );
 582   if (array-&gt;length() != idx) {
 583     assert(array-&gt;length() == idx + 1, &quot;Unexpected array count&quot;);
 584     // Old functionality:
 585     //   return
 586     // New functionality:
 587     //   Assert if the local is not top. In product mode let the new node
 588     //   override the old entry.
<span class="line-modified"> 589     assert(local == top(), &quot;LocArray collision&quot;);</span>
<span class="line-modified"> 590     if (local == top()) {</span>
 591       return;
 592     }
 593     array-&gt;pop();
 594   }
 595   const Type *t = local-&gt;bottom_type();
 596 
 597   // Is it a safepoint scalar object node?
 598   if (local-&gt;is_SafePointScalarObject()) {
 599     SafePointScalarObjectNode* spobj = local-&gt;as_SafePointScalarObject();
 600 
<span class="line-modified"> 601     ObjectValue* sv = Compile::sv_for_node_id(objs, spobj-&gt;_idx);</span>
 602     if (sv == NULL) {
 603       ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
 604       assert(cik-&gt;is_instance_klass() ||
 605              cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 606       sv = new ObjectValue(spobj-&gt;_idx,
 607                            new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
<span class="line-modified"> 608       Compile::set_sv_for_object_node(objs, sv);</span>
 609 
 610       uint first_ind = spobj-&gt;first_index(sfpt-&gt;jvms());
 611       for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
 612         Node* fld_node = sfpt-&gt;in(first_ind+i);
 613         (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfpt, fld_node, sv-&gt;field_values(), objs);
 614       }
 615     }
 616     array-&gt;append(sv);
 617     return;
 618   }
 619 
 620   // Grab the register number for the local
<span class="line-modified"> 621   OptoReg::Name regnum = _regalloc-&gt;get_reg_first(local);</span>
 622   if( OptoReg::is_valid(regnum) ) {// Got a register/stack?
 623     // Record the double as two float registers.
 624     // The register mask for such a value always specifies two adjacent
 625     // float registers, with the lower register number even.
 626     // Normally, the allocation of high and low words to these registers
 627     // is irrelevant, because nearly all operations on register pairs
 628     // (e.g., StoreD) treat them as a single unit.
 629     // Here, we assume in addition that the words in these two registers
 630     // stored &quot;naturally&quot; (by operations like StoreD and double stores
 631     // within the interpreter) such that the lower-numbered register
 632     // is written to the lower memory address.  This may seem like
 633     // a machine dependency, but it is not--it is a requirement on
 634     // the author of the &lt;arch&gt;.ad file to ensure that, for every
 635     // even/odd double-register pair to which a double may be allocated,
 636     // the word in the even single-register is stored to the first
 637     // memory word.  (Note that register numbers are completely
 638     // arbitrary, and are not tied to any machine-level encodings.)
 639 #ifdef _LP64
 640     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon ) {
 641       array-&gt;append(new ConstantIntValue((jint)0));
<span class="line-modified"> 642       array-&gt;append(new_loc_value( _regalloc, regnum, Location::dbl ));</span>
 643     } else if ( t-&gt;base() == Type::Long ) {
 644       array-&gt;append(new ConstantIntValue((jint)0));
<span class="line-modified"> 645       array-&gt;append(new_loc_value( _regalloc, regnum, Location::lng ));</span>
 646     } else if ( t-&gt;base() == Type::RawPtr ) {
 647       // jsr/ret return address which must be restored into a the full
 648       // width 64-bit stack slot.
<span class="line-modified"> 649       array-&gt;append(new_loc_value( _regalloc, regnum, Location::lng ));</span>
 650     }
 651 #else //_LP64
 652 #ifdef SPARC
 653     if (t-&gt;base() == Type::Long &amp;&amp; OptoReg::is_reg(regnum)) {
 654       // For SPARC we have to swap high and low words for
 655       // long values stored in a single-register (g0-g7).
<span class="line-modified"> 656       array-&gt;append(new_loc_value( _regalloc,              regnum   , Location::normal ));</span>
<span class="line-modified"> 657       array-&gt;append(new_loc_value( _regalloc, OptoReg::add(regnum,1), Location::normal ));</span>
 658     } else
 659 #endif //SPARC
 660     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon || t-&gt;base() == Type::Long ) {
 661       // Repack the double/long as two jints.
 662       // The convention the interpreter uses is that the second local
 663       // holds the first raw word of the native double representation.
 664       // This is actually reasonable, since locals and stack arrays
 665       // grow downwards in all implementations.
 666       // (If, on some machine, the interpreter&#39;s Java locals or stack
 667       // were to grow upwards, the embedded doubles would be word-swapped.)
<span class="line-modified"> 668       array-&gt;append(new_loc_value( _regalloc, OptoReg::add(regnum,1), Location::normal ));</span>
<span class="line-modified"> 669       array-&gt;append(new_loc_value( _regalloc,              regnum   , Location::normal ));</span>
 670     }
 671 #endif //_LP64
 672     else if( (t-&gt;base() == Type::FloatBot || t-&gt;base() == Type::FloatCon) &amp;&amp;
 673              OptoReg::is_reg(regnum) ) {
<span class="line-modified"> 674       array-&gt;append(new_loc_value( _regalloc, regnum, Matcher::float_in_double()</span>
 675                                                       ? Location::float_in_dbl : Location::normal ));
 676     } else if( t-&gt;base() == Type::Int &amp;&amp; OptoReg::is_reg(regnum) ) {
<span class="line-modified"> 677       array-&gt;append(new_loc_value( _regalloc, regnum, Matcher::int_in_long</span>
 678                                                       ? Location::int_in_long : Location::normal ));
 679     } else if( t-&gt;base() == Type::NarrowOop ) {
<span class="line-modified"> 680       array-&gt;append(new_loc_value( _regalloc, regnum, Location::narrowoop ));</span>
 681     } else {
<span class="line-modified"> 682       array-&gt;append(new_loc_value( _regalloc, regnum, _regalloc-&gt;is_oop(local) ? Location::oop : Location::normal ));</span>
 683     }
 684     return;
 685   }
 686 
 687   // No register.  It must be constant data.
 688   switch (t-&gt;base()) {
 689     case Type::Half:              // Second half of a double
 690       ShouldNotReachHere();       // Caller should skip 2nd halves
 691       break;
 692     case Type::AnyPtr:
 693       array-&gt;append(new ConstantOopWriteValue(NULL));
 694       break;
 695     case Type::AryPtr:
 696     case Type::InstPtr:          // fall through
 697       array-&gt;append(new ConstantOopWriteValue(t-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));
 698       break;
 699     case Type::NarrowOop:
 700       if (t == TypeNarrowOop::NULL_PTR) {
 701         array-&gt;append(new ConstantOopWriteValue(NULL));
 702       } else {
</pre>
<hr />
<pre>
 754     // grow downwards in all implementations.
 755     // (If, on some machine, the interpreter&#39;s Java locals or stack
 756     // were to grow upwards, the embedded doubles would be word-swapped.)
 757     jlong_accessor acc;
 758     acc.long_value = d;
 759     array-&gt;append(new ConstantIntValue(acc.words[1]));
 760     array-&gt;append(new ConstantIntValue(acc.words[0]));
 761 #endif
 762       break;
 763     }
 764     case Type::Top:               // Add an illegal value here
 765       array-&gt;append(new LocationValue(Location()));
 766       break;
 767     default:
 768       ShouldNotReachHere();
 769       break;
 770   }
 771 }
 772 
 773 // Determine if this node starts a bundle
<span class="line-modified"> 774 bool Compile::starts_bundle(const Node *n) const {</span>
 775   return (_node_bundling_limit &gt; n-&gt;_idx &amp;&amp;
 776           _node_bundling_base[n-&gt;_idx].starts_bundle());
 777 }
 778 
 779 //--------------------------Process_OopMap_Node--------------------------------
<span class="line-modified"> 780 void Compile::Process_OopMap_Node(MachNode *mach, int current_offset) {</span>
<span class="line-removed"> 781 </span>
 782   // Handle special safepoint nodes for synchronization
 783   MachSafePointNode *sfn   = mach-&gt;as_MachSafePoint();
 784   MachCallNode      *mcall;
 785 
 786   int safepoint_pc_offset = current_offset;
 787   bool is_method_handle_invoke = false;
 788   bool return_oop = false;
 789   bool return_vt = false;
 790 
 791   // Add the safepoint in the DebugInfoRecorder
 792   if( !mach-&gt;is_MachCall() ) {
 793     mcall = NULL;
<span class="line-modified"> 794     debug_info()-&gt;add_safepoint(safepoint_pc_offset, sfn-&gt;_oop_map);</span>
 795   } else {
 796     mcall = mach-&gt;as_MachCall();
 797 
 798     // Is the call a MethodHandle call?
 799     if (mcall-&gt;is_MachCallJava()) {
 800       if (mcall-&gt;as_MachCallJava()-&gt;_method_handle_invoke) {
<span class="line-modified"> 801         assert(has_method_handle_invokes(), &quot;must have been set during call generation&quot;);</span>
 802         is_method_handle_invoke = true;
 803       }
 804     }
 805 
 806     // Check if a call returns an object.
 807     if (mcall-&gt;returns_pointer() || mcall-&gt;returns_vt()) {
 808       return_oop = true;
 809     }
 810     if (mcall-&gt;returns_vt()) {
 811       return_vt = true;
 812     }
 813     safepoint_pc_offset += mcall-&gt;ret_addr_offset();
<span class="line-modified"> 814     debug_info()-&gt;add_safepoint(safepoint_pc_offset, mcall-&gt;_oop_map);</span>
 815   }
 816 
 817   // Loop over the JVMState list to add scope information
 818   // Do not skip safepoints with a NULL method, they need monitor info
 819   JVMState* youngest_jvms = sfn-&gt;jvms();
 820   int max_depth = youngest_jvms-&gt;depth();
 821 
 822   // Allocate the object pool for scalar-replaced objects -- the map from
 823   // small-integer keys (which can be recorded in the local and ostack
 824   // arrays) to descriptions of the object state.
 825   GrowableArray&lt;ScopeValue*&gt; *objs = new GrowableArray&lt;ScopeValue*&gt;();
 826 
 827   // Visit scopes from oldest to youngest.
 828   for (int depth = 1; depth &lt;= max_depth; depth++) {
 829     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
 830     int idx;
 831     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
 832     // Safepoints that do not have method() set only provide oop-map and monitor info
 833     // to support GC; these do not support deoptimization.
 834     int num_locs = (method == NULL) ? 0 : jvms-&gt;loc_size();
</pre>
<hr />
<pre>
 856             !method-&gt;is_synchronized() ||
 857             method-&gt;is_native() ||
 858             num_mon &gt; 0 ||
 859             !GenerateSynchronizationCode,
 860             &quot;monitors must always exist for synchronized methods&quot;);
 861 
 862     // Build the growable array of ScopeValues for exp stack
 863     GrowableArray&lt;MonitorValue*&gt; *monarray = new GrowableArray&lt;MonitorValue*&gt;(num_mon);
 864 
 865     // Loop over monitors and insert into array
 866     for (idx = 0; idx &lt; num_mon; idx++) {
 867       // Grab the node that defines this monitor
 868       Node* box_node = sfn-&gt;monitor_box(jvms, idx);
 869       Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
 870 
 871       // Create ScopeValue for object
 872       ScopeValue *scval = NULL;
 873 
 874       if (obj_node-&gt;is_SafePointScalarObject()) {
 875         SafePointScalarObjectNode* spobj = obj_node-&gt;as_SafePointScalarObject();
<span class="line-modified"> 876         scval = Compile::sv_for_node_id(objs, spobj-&gt;_idx);</span>
 877         if (scval == NULL) {
 878           const Type *t = spobj-&gt;bottom_type();
 879           ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
 880           assert(cik-&gt;is_instance_klass() ||
 881                  cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 882           ObjectValue* sv = new ObjectValue(spobj-&gt;_idx,
 883                                             new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
<span class="line-modified"> 884           Compile::set_sv_for_object_node(objs, sv);</span>
 885 
 886           uint first_ind = spobj-&gt;first_index(youngest_jvms);
 887           for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
 888             Node* fld_node = sfn-&gt;in(first_ind+i);
 889             (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfn, fld_node, sv-&gt;field_values(), objs);
 890           }
 891           scval = sv;
 892         }
 893       } else if (!obj_node-&gt;is_Con()) {
<span class="line-modified"> 894         OptoReg::Name obj_reg = _regalloc-&gt;get_reg_first(obj_node);</span>
 895         if( obj_node-&gt;bottom_type()-&gt;base() == Type::NarrowOop ) {
<span class="line-modified"> 896           scval = new_loc_value( _regalloc, obj_reg, Location::narrowoop );</span>
 897         } else {
<span class="line-modified"> 898           scval = new_loc_value( _regalloc, obj_reg, Location::oop );</span>
 899         }
 900       } else {
 901         const TypePtr *tp = obj_node-&gt;get_ptr_type();
 902         scval = new ConstantOopWriteValue(tp-&gt;is_oopptr()-&gt;const_oop()-&gt;constant_encoding());
 903       }
 904 
 905       OptoReg::Name box_reg = BoxLockNode::reg(box_node);
<span class="line-modified"> 906       Location basic_lock = Location::new_stk_loc(Location::normal,_regalloc-&gt;reg2offset(box_reg));</span>
 907       bool eliminated = (box_node-&gt;is_BoxLock() &amp;&amp; box_node-&gt;as_BoxLock()-&gt;is_eliminated());
 908       monarray-&gt;append(new MonitorValue(scval, basic_lock, eliminated));
 909     }
 910 
 911     // We dump the object pool first, since deoptimization reads it in first.
<span class="line-modified"> 912     debug_info()-&gt;dump_object_pool(objs);</span>
 913 
 914     // Build first class objects to pass to scope
<span class="line-modified"> 915     DebugToken *locvals = debug_info()-&gt;create_scope_values(locarray);</span>
<span class="line-modified"> 916     DebugToken *expvals = debug_info()-&gt;create_scope_values(exparray);</span>
<span class="line-modified"> 917     DebugToken *monvals = debug_info()-&gt;create_monitor_values(monarray);</span>
 918 
 919     // Make method available for all Safepoints
<span class="line-modified"> 920     ciMethod* scope_method = method ? method : _method;</span>
 921     // Describe the scope here
 922     assert(jvms-&gt;bci() &gt;= InvocationEntryBci &amp;&amp; jvms-&gt;bci() &lt;= 0x10000, &quot;must be a valid or entry BCI&quot;);
 923     assert(!jvms-&gt;should_reexecute() || depth == max_depth, &quot;reexecute allowed only for the youngest&quot;);
 924     // Now we can describe the scope.
 925     methodHandle null_mh;
 926     bool rethrow_exception = false;
<span class="line-modified"> 927     debug_info()-&gt;describe_scope(safepoint_pc_offset, null_mh, scope_method, jvms-&gt;bci(), jvms-&gt;should_reexecute(), rethrow_exception, is_method_handle_invoke, return_oop, return_vt, locvals, expvals, monvals);</span>
 928   } // End jvms loop
 929 
 930   // Mark the end of the scope set.
<span class="line-modified"> 931   debug_info()-&gt;end_safepoint(safepoint_pc_offset);</span>
 932 }
 933 
 934 
 935 
 936 // A simplified version of Process_OopMap_Node, to handle non-safepoints.
 937 class NonSafepointEmitter {
 938     Compile*  C;
 939     JVMState* _pending_jvms;
 940     int       _pending_offset;
 941 
 942     void emit_non_safepoint();
 943 
 944  public:
 945     NonSafepointEmitter(Compile* compile) {
 946       this-&gt;C = compile;
 947       _pending_jvms = NULL;
 948       _pending_offset = 0;
 949     }
 950 
 951     void observe_instruction(Node* n, int pc_offset) {
</pre>
<hr />
<pre>
 999   DebugInformationRecorder* debug_info = C-&gt;debug_info();
1000   assert(debug_info-&gt;recording_non_safepoints(), &quot;sanity&quot;);
1001 
1002   debug_info-&gt;add_non_safepoint(pc_offset);
1003   int max_depth = youngest_jvms-&gt;depth();
1004 
1005   // Visit scopes from oldest to youngest.
1006   for (int depth = 1; depth &lt;= max_depth; depth++) {
1007     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
1008     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
1009     assert(!jvms-&gt;should_reexecute() || depth==max_depth, &quot;reexecute allowed only for the youngest&quot;);
1010     methodHandle null_mh;
1011     debug_info-&gt;describe_scope(pc_offset, null_mh, method, jvms-&gt;bci(), jvms-&gt;should_reexecute());
1012   }
1013 
1014   // Mark the end of the scope set.
1015   debug_info-&gt;end_non_safepoint(pc_offset);
1016 }
1017 
1018 //------------------------------init_buffer------------------------------------
<span class="line-modified">1019 void Compile::estimate_buffer_size(int&amp; const_req) {</span>
1020 
1021   // Set the initially allocated size
1022   const_req = initial_const_capacity;
1023 
1024   // The extra spacing after the code is necessary on some platforms.
1025   // Sometimes we need to patch in a jump after the last instruction,
1026   // if the nmethod has been deoptimized.  (See 4932387, 4894843.)
1027 
1028   // Compute the byte offset where we can store the deopt pc.
<span class="line-modified">1029   if (fixed_slots() != 0) {</span>
<span class="line-modified">1030     _orig_pc_slot_offset_in_bytes = _regalloc-&gt;reg2offset(OptoReg::stack2reg(_orig_pc_slot));</span>
1031   }
1032   if (C-&gt;needs_stack_repair()) {
1033     // Compute the byte offset of the stack increment value
<span class="line-modified">1034     _sp_inc_slot_offset_in_bytes = _regalloc-&gt;reg2offset(OptoReg::stack2reg(_sp_inc_slot));</span>
1035   }
1036 
1037   // Compute prolog code size
1038   _method_size = 0;
<span class="line-modified">1039   _frame_slots = OptoReg::reg2stack(_matcher-&gt;_old_SP) + _regalloc-&gt;_framesize;</span>
1040 #if defined(IA64) &amp;&amp; !defined(AIX)
1041   if (save_argument_registers()) {
1042     // 4815101: this is a stub with implicit and unknown precision fp args.
1043     // The usual spill mechanism can only generate stfd&#39;s in this case, which
1044     // doesn&#39;t work if the fp reg to spill contains a single-precision denorm.
1045     // Instead, we hack around the normal spill mechanism using stfspill&#39;s and
1046     // ldffill&#39;s in the MachProlog and MachEpilog emit methods.  We allocate
1047     // space here for the fp arg regs (f8-f15) we&#39;re going to thusly spill.
1048     //
1049     // If we ever implement 16-byte &#39;registers&#39; == stack slots, we can
1050     // get rid of this hack and have SpillCopy generate stfspill/ldffill
1051     // instead of stfd/stfs/ldfd/ldfs.
1052     _frame_slots += 8*(16/BytesPerInt);
1053   }
1054 #endif
1055   assert(_frame_slots &gt;= 0 &amp;&amp; _frame_slots &lt; 1000000, &quot;sanity check&quot;);
1056 
<span class="line-modified">1057   if (has_mach_constant_base_node()) {</span>
1058     uint add_size = 0;
1059     // Fill the constant table.
1060     // Note:  This must happen before shorten_branches.
<span class="line-modified">1061     for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified">1062       Block* b = _cfg-&gt;get_block(i);</span>
1063 
1064       for (uint j = 0; j &lt; b-&gt;number_of_nodes(); j++) {
1065         Node* n = b-&gt;get_node(j);
1066 
1067         // If the node is a MachConstantNode evaluate the constant
1068         // value section.
1069         if (n-&gt;is_MachConstant()) {
1070           MachConstantNode* machcon = n-&gt;as_MachConstant();
1071           machcon-&gt;eval_constant(C);
1072         } else if (n-&gt;is_Mach()) {
1073           // On Power there are more nodes that issue constants.
1074           add_size += (n-&gt;as_Mach()-&gt;ins_num_consts() * 8);
1075         }
1076       }
1077     }
1078 
1079     // Calculate the offsets of the constants and the size of the
1080     // constant table (including the padding to the next section).
1081     constant_table().calculate_offsets_and_size();
1082     const_req = constant_table().size() + add_size;
1083   }
1084 
1085   // Initialize the space for the BufferBlob used to find and verify
1086   // instruction size in MachNode::emit_size()
1087   init_scratch_buffer_blob(const_req);
1088 }
1089 
<span class="line-modified">1090 CodeBuffer* Compile::init_buffer(BufferSizingData&amp; buf_sizes) {</span>
1091 
1092   int stub_req  = buf_sizes._stub;
1093   int code_req  = buf_sizes._code;
1094   int const_req = buf_sizes._const;
1095 
1096   int pad_req   = NativeCall::instruction_size;
1097 
1098   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1099   stub_req += bs-&gt;estimate_stub_size();
1100 
1101   // nmethod and CodeBuffer count stubs &amp; constants as part of method&#39;s code.
1102   // class HandlerImpl is platform-specific and defined in the *.ad files.
1103   int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; // add marginal slop for handler
1104   int deopt_handler_req     = HandlerImpl::size_deopt_handler()     + MAX_stubs_size; // add marginal slop for handler
1105   stub_req += MAX_stubs_size;   // ensure per-stub margin
1106   code_req += MAX_inst_size;    // ensure per-instruction margin
1107 
1108   if (StressCodeBuffers)
1109     code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  // force expansion
1110 
1111   int total_req =
1112           const_req +
1113           code_req +
1114           pad_req +
1115           stub_req +
1116           exception_handler_req +
1117           deopt_handler_req;               // deopt handler
1118 
<span class="line-modified">1119   if (has_method_handle_invokes())</span>
1120     total_req += deopt_handler_req;  // deopt MH handler
1121 
1122   CodeBuffer* cb = code_buffer();
1123   cb-&gt;initialize(total_req, buf_sizes._reloc);
1124 
1125   // Have we run out of code space?
1126   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1127     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1128     return NULL;
1129   }
1130   // Configure the code buffer.
1131   cb-&gt;initialize_consts_size(const_req);
1132   cb-&gt;initialize_stubs_size(stub_req);
<span class="line-modified">1133   cb-&gt;initialize_oop_recorder(env()-&gt;oop_recorder());</span>
1134 
1135   // fill in the nop array for bundling computations
1136   MachNode *_nop_list[Bundle::_nop_count];
1137   Bundle::initialize_nops(_nop_list);
1138 
1139   return cb;
1140 }
1141 
1142 //------------------------------fill_buffer------------------------------------
<span class="line-modified">1143 void Compile::fill_buffer(CodeBuffer* cb, uint* blk_starts) {</span>
1144   // blk_starts[] contains offsets calculated during short branches processing,
1145   // offsets should not be increased during following steps.
1146 
1147   // Compute the size of first NumberOfLoopInstrToAlign instructions at head
1148   // of a loop. It is used to determine the padding for loop alignment.
1149   compute_loop_first_inst_sizes();
1150 
1151   // Create oopmap set.
1152   _oop_map_set = new OopMapSet();
1153 
1154   // !!!!! This preserves old handling of oopmaps for now
<span class="line-modified">1155   debug_info()-&gt;set_oopmaps(_oop_map_set);</span>
1156 
<span class="line-modified">1157   uint nblocks  = _cfg-&gt;number_of_blocks();</span>
1158   // Count and start of implicit null check instructions
1159   uint inct_cnt = 0;
1160   uint *inct_starts = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1161 
1162   // Count and start of calls
1163   uint *call_returns = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1164 
1165   uint  return_offset = 0;
<span class="line-modified">1166   int nop_size = (new MachNopNode())-&gt;size(_regalloc);</span>
1167 
1168   int previous_offset = 0;
1169   int current_offset  = 0;
1170   int last_call_offset = -1;
1171   int last_avoid_back_to_back_offset = -1;
1172 #ifdef ASSERT
1173   uint* jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks);
1174   uint* jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
1175   uint* jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
1176   uint* jmp_rule   = NEW_RESOURCE_ARRAY(uint,nblocks);
1177 #endif
1178 
1179   // Create an array of unused labels, one for each basic block, if printing is enabled
1180 #if defined(SUPPORT_OPTO_ASSEMBLY)
1181   int *node_offsets      = NULL;
<span class="line-modified">1182   uint node_offset_limit = unique();</span>
1183 
<span class="line-modified">1184   if (print_assembly()) {</span>
1185     node_offsets = NEW_RESOURCE_ARRAY(int, node_offset_limit);
1186   }
1187   if (node_offsets != NULL) {
1188     // We need to initialize. Unused array elements may contain garbage and mess up PrintOptoAssembly.
1189     memset(node_offsets, 0, node_offset_limit*sizeof(int));
1190   }
1191 #endif
1192 
<span class="line-modified">1193   NonSafepointEmitter non_safepoints(this);  // emit non-safepoints lazily</span>
1194 
1195   // Emit the constant table.
<span class="line-modified">1196   if (has_mach_constant_base_node()) {</span>
1197     constant_table().emit(*cb);
1198   }
1199 
1200   // Create an array of labels, one for each basic block
1201   Label *blk_labels = NEW_RESOURCE_ARRAY(Label, nblocks+1);
1202   for (uint i=0; i &lt;= nblocks; i++) {
1203     blk_labels[i].init();
1204   }
1205 
1206   // ------------------
1207   // Now fill in the code buffer
1208   Node *delay_slot = NULL;
1209 
1210   for (uint i = 0; i &lt; nblocks; i++) {
<span class="line-modified">1211     Block* block = _cfg-&gt;get_block(i);</span>
1212     Node* head = block-&gt;head();
1213 
1214     // If this block needs to start aligned (i.e, can be reached other
1215     // than by falling-thru from the previous block), then force the
1216     // start of a new bundle.
1217     if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(head)) {
1218       cb-&gt;flush_bundle(true);
1219     }
1220 
1221 #ifdef ASSERT
1222     if (!block-&gt;is_connector()) {
1223       stringStream st;
<span class="line-modified">1224       block-&gt;dump_head(_cfg, &amp;st);</span>
1225       MacroAssembler(cb).block_comment(st.as_string());
1226     }
1227     jmp_target[i] = 0;
1228     jmp_offset[i] = 0;
1229     jmp_size[i]   = 0;
1230     jmp_rule[i]   = 0;
1231 #endif
1232     int blk_offset = current_offset;
1233 
1234     // Define the label at the beginning of the basic block
1235     MacroAssembler(cb).bind(blk_labels[block-&gt;_pre_order]);
1236 
1237     uint last_inst = block-&gt;number_of_nodes();
1238 
1239     // Emit block normally, except for last instruction.
1240     // Emit means &quot;dump code bits into code buffer&quot;.
1241     for (uint j = 0; j&lt;last_inst; j++) {
1242 
1243       // Get the node
1244       Node* n = block-&gt;get_node(j);
1245 
1246       // See if delay slots are supported
<span class="line-modified">1247       if (valid_bundle_info(n) &amp;&amp;</span>
<span class="line-removed">1248           node_bundling(n)-&gt;used_in_unconditional_delay()) {</span>
1249         assert(delay_slot == NULL, &quot;no use of delay slot node&quot;);
<span class="line-modified">1250         assert(n-&gt;size(_regalloc) == Pipeline::instr_unit_size(), &quot;delay slot instruction wrong size&quot;);</span>
1251 
1252         delay_slot = n;
1253         continue;
1254       }
1255 
1256       // If this starts a new instruction group, then flush the current one
1257       // (but allow split bundles)
1258       if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(n))
1259         cb-&gt;flush_bundle(false);
1260 
1261       // Special handling for SafePoint/Call Nodes
1262       bool is_mcall = false;
1263       if (n-&gt;is_Mach()) {
1264         MachNode *mach = n-&gt;as_Mach();
1265         is_mcall = n-&gt;is_MachCall();
1266         bool is_sfn = n-&gt;is_MachSafePoint();
1267 
1268         // If this requires all previous instructions be flushed, then do so
1269         if (is_sfn || is_mcall || mach-&gt;alignment_required() != 1) {
1270           cb-&gt;flush_bundle(true);
</pre>
<hr />
<pre>
1272         }
1273 
1274         // A padding may be needed again since a previous instruction
1275         // could be moved to delay slot.
1276 
1277         // align the instruction if necessary
1278         int padding = mach-&gt;compute_padding(current_offset);
1279         // Make sure safepoint node for polling is distinct from a call&#39;s
1280         // return by adding a nop if needed.
1281         if (is_sfn &amp;&amp; !is_mcall &amp;&amp; padding == 0 &amp;&amp; current_offset == last_call_offset) {
1282           padding = nop_size;
1283         }
1284         if (padding == 0 &amp;&amp; mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE) &amp;&amp;
1285             current_offset == last_avoid_back_to_back_offset) {
1286           // Avoid back to back some instructions.
1287           padding = nop_size;
1288         }
1289 #ifdef X86
1290         if (mach-&gt;flags() &amp; Node::Flag_intel_jcc_erratum) {
1291           assert(padding == 0, &quot;can&#39;t have contradicting padding requirements&quot;);
<span class="line-modified">1292           padding = IntelJccErratum::compute_padding(current_offset, mach, block, j, _regalloc);</span>
1293         }
1294 #endif
1295 
1296         if (padding &gt; 0) {
1297           assert((padding % nop_size) == 0, &quot;padding is not a multiple of NOP size&quot;);
1298           int nops_cnt = padding / nop_size;
1299           MachNode *nop = new MachNopNode(nops_cnt);
1300           block-&gt;insert_node(nop, j++);
1301           last_inst++;
<span class="line-modified">1302           _cfg-&gt;map_node_to_block(nop, block);</span>
1303           // Ensure enough space.
1304           cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1305           if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1306             C-&gt;record_failure(&quot;CodeCache is full&quot;);
1307             return;
1308           }
<span class="line-modified">1309           nop-&gt;emit(*cb, _regalloc);</span>
1310           cb-&gt;flush_bundle(true);
1311           current_offset = cb-&gt;insts_size();
1312         }
1313 
1314         // Remember the start of the last call in a basic block
1315         if (is_mcall) {
1316           MachCallNode *mcall = mach-&gt;as_MachCall();
1317 
1318           if (mcall-&gt;entry_point() != NULL) {
1319             // This destination address is NOT PC-relative
1320             mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
1321           }
1322 
1323           // Save the return address
1324           call_returns[block-&gt;_pre_order] = current_offset + mcall-&gt;ret_addr_offset();
1325 
1326           if (mcall-&gt;is_MachCallLeaf()) {
1327             is_mcall = false;
1328             is_sfn = false;
1329           }
</pre>
<hr />
<pre>
1344 
1345           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1346                                            current_offset);
1347           Process_OopMap_Node(mach, current_offset);
1348         } // End if safepoint
1349 
1350           // If this is a null check, then add the start of the previous instruction to the list
1351         else if( mach-&gt;is_MachNullCheck() ) {
1352           inct_starts[inct_cnt++] = previous_offset;
1353         }
1354 
1355           // If this is a branch, then fill in the label with the target BB&#39;s label
1356         else if (mach-&gt;is_MachBranch()) {
1357           // This requires the TRUE branch target be in succs[0]
1358           uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1359 
1360           // Try to replace long branch if delay slot is not used,
1361           // it is mostly for back branches since forward branch&#39;s
1362           // distance is not updated yet.
1363           bool delay_slot_is_used = valid_bundle_info(n) &amp;&amp;
<span class="line-modified">1364                                     node_bundling(n)-&gt;use_unconditional_delay();</span>
1365           if (!delay_slot_is_used &amp;&amp; mach-&gt;may_be_short_branch()) {
1366             assert(delay_slot == NULL, &quot;not expecting delay slot node&quot;);
<span class="line-modified">1367             int br_size = n-&gt;size(_regalloc);</span>
1368             int offset = blk_starts[block_num] - current_offset;
1369             if (block_num &gt;= i) {
1370               // Current and following block&#39;s offset are not
1371               // finalized yet, adjust distance by the difference
1372               // between calculated and final offsets of current block.
1373               offset -= (blk_starts[i] - blk_offset);
1374             }
1375             // In the following code a nop could be inserted before
1376             // the branch which will increase the backward distance.
1377             bool needs_padding = (current_offset == last_avoid_back_to_back_offset);
1378             if (needs_padding &amp;&amp; offset &lt;= 0)
1379               offset -= nop_size;
1380 
<span class="line-modified">1381             if (_matcher-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {</span>
1382               // We&#39;ve got a winner.  Replace this branch.
1383               MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
1384 
1385               // Update the jmp_size.
<span class="line-modified">1386               int new_size = replacement-&gt;size(_regalloc);</span>
1387               assert((br_size - new_size) &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
1388               // Insert padding between avoid_back_to_back branches.
1389               if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
1390                 MachNode *nop = new MachNopNode();
1391                 block-&gt;insert_node(nop, j++);
<span class="line-modified">1392                 _cfg-&gt;map_node_to_block(nop, block);</span>
1393                 last_inst++;
<span class="line-modified">1394                 nop-&gt;emit(*cb, _regalloc);</span>
1395                 cb-&gt;flush_bundle(true);
1396                 current_offset = cb-&gt;insts_size();
1397               }
1398 #ifdef ASSERT
1399               jmp_target[i] = block_num;
1400               jmp_offset[i] = current_offset - blk_offset;
1401               jmp_size[i]   = new_size;
1402               jmp_rule[i]   = mach-&gt;rule();
1403 #endif
1404               block-&gt;map_node(replacement, j);
1405               mach-&gt;subsume_by(replacement, C);
1406               n    = replacement;
1407               mach = replacement;
1408             }
1409           }
1410           mach-&gt;as_MachBranch()-&gt;label_set( &amp;blk_labels[block_num], block_num );
1411         } else if (mach-&gt;ideal_Opcode() == Op_Jump) {
1412           for (uint h = 0; h &lt; block-&gt;_num_succs; h++) {
1413             Block* succs_block = block-&gt;_succs[h];
1414             for (uint j = 1; j &lt; succs_block-&gt;num_preds(); j++) {
</pre>
<hr />
<pre>
1456           inct_starts[inct_cnt++] = current_offset;
1457         }
1458       }
1459 
1460       // Verify that there is sufficient space remaining
1461       cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1462       if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1463         C-&gt;record_failure(&quot;CodeCache is full&quot;);
1464         return;
1465       }
1466 
1467       // Save the offset for the listing
1468 #if defined(SUPPORT_OPTO_ASSEMBLY)
1469       if ((node_offsets != NULL) &amp;&amp; (n-&gt;_idx &lt; node_offset_limit)) {
1470         node_offsets[n-&gt;_idx] = cb-&gt;insts_size();
1471       }
1472 #endif
1473 
1474       // &quot;Normal&quot; instruction case
1475       DEBUG_ONLY( uint instr_offset = cb-&gt;insts_size(); )
<span class="line-modified">1476       n-&gt;emit(*cb, _regalloc);</span>
1477       current_offset  = cb-&gt;insts_size();
1478 
1479       // Above we only verified that there is enough space in the instruction section.
1480       // However, the instruction may emit stubs that cause code buffer expansion.
1481       // Bail out here if expansion failed due to a lack of code cache space.
<span class="line-modified">1482       if (failing()) {</span>
1483         return;
1484       }
1485 
1486 #ifdef ASSERT
<span class="line-modified">1487       if (n-&gt;size(_regalloc) &lt; (current_offset-instr_offset)) {</span>
1488         n-&gt;dump();
1489         assert(false, &quot;wrong size of mach node&quot;);
1490       }
1491 #endif
1492       non_safepoints.observe_instruction(n, current_offset);
1493 
1494       // mcall is last &quot;call&quot; that can be a safepoint
1495       // record it so we can see if a poll will directly follow it
1496       // in which case we&#39;ll need a pad to make the PcDesc sites unique
1497       // see  5010568. This can be slightly inaccurate but conservative
1498       // in the case that return address is not actually at current_offset.
1499       // This is a small price to pay.
1500 
1501       if (is_mcall) {
1502         last_call_offset = current_offset;
1503       }
1504 
1505       if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
1506         // Avoid back to back some instructions.
1507         last_avoid_back_to_back_offset = current_offset;
</pre>
<hr />
<pre>
1522 #endif
1523 
1524         // Support a SafePoint in the delay slot
1525         if (delay_slot-&gt;is_MachSafePoint()) {
1526           MachNode *mach = delay_slot-&gt;as_Mach();
1527           // !!!!! Stubs only need an oopmap right now, so bail out
1528           if (!mach-&gt;is_MachCall() &amp;&amp; mach-&gt;as_MachSafePoint()-&gt;jvms()-&gt;method() == NULL) {
1529             // Write the oopmap directly to the code blob??!!
1530             delay_slot = NULL;
1531             continue;
1532           }
1533 
1534           int adjusted_offset = current_offset - Pipeline::instr_unit_size();
1535           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1536                                            adjusted_offset);
1537           // Generate an OopMap entry
1538           Process_OopMap_Node(mach, adjusted_offset);
1539         }
1540 
1541         // Insert the delay slot instruction
<span class="line-modified">1542         delay_slot-&gt;emit(*cb, _regalloc);</span>
1543 
1544         // Don&#39;t reuse it
1545         delay_slot = NULL;
1546       }
1547 
1548     } // End for all instructions in block
1549 
1550     // If the next block is the top of a loop, pad this block out to align
1551     // the loop top a little. Helps prevent pipe stalls at loop back branches.
1552     if (i &lt; nblocks-1) {
<span class="line-modified">1553       Block *nb = _cfg-&gt;get_block(i + 1);</span>
1554       int padding = nb-&gt;alignment_padding(current_offset);
1555       if( padding &gt; 0 ) {
1556         MachNode *nop = new MachNopNode(padding / nop_size);
1557         block-&gt;insert_node(nop, block-&gt;number_of_nodes());
<span class="line-modified">1558         _cfg-&gt;map_node_to_block(nop, block);</span>
<span class="line-modified">1559         nop-&gt;emit(*cb, _regalloc);</span>
1560         current_offset = cb-&gt;insts_size();
1561       }
1562     }
1563     // Verify that the distance for generated before forward
1564     // short branches is still valid.
1565     guarantee((int)(blk_starts[i+1] - blk_starts[i]) &gt;= (current_offset - blk_offset), &quot;shouldn&#39;t increase block size&quot;);
1566 
1567     // Save new block start offset
1568     blk_starts[i] = blk_offset;
1569   } // End of for all blocks
1570   blk_starts[nblocks] = current_offset;
1571 
1572   non_safepoints.flush_at_end();
1573 
1574   // Offset too large?
<span class="line-modified">1575   if (failing())  return;</span>
1576 
1577   // Define a pseudo-label at the end of the code
1578   MacroAssembler(cb).bind( blk_labels[nblocks] );
1579 
1580   // Compute the size of the first block
1581   _first_block_size = blk_labels[1].loc_pos() - blk_labels[0].loc_pos();
1582 
1583 #ifdef ASSERT
1584   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
1585     if (jmp_target[i] != 0) {
1586       int br_size = jmp_size[i];
1587       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
<span class="line-modified">1588       if (!_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {</span>
1589         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
1590         assert(false, &quot;Displacement too large for short jmp&quot;);
1591       }
1592     }
1593   }
1594 #endif
1595 
1596   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1597   bs-&gt;emit_stubs(*cb);
<span class="line-modified">1598   if (failing())  return;</span>
1599 
1600 #ifndef PRODUCT
1601   // Information on the size of the method, without the extraneous code
1602   Scheduling::increment_method_size(cb-&gt;insts_size());
1603 #endif
1604 
1605   // ------------------
1606   // Fill in exception table entries.
1607   FillExceptionTables(inct_cnt, call_returns, inct_starts, blk_labels);
1608 
1609   // Only java methods have exception handlers and deopt handlers
1610   // class HandlerImpl is platform-specific and defined in the *.ad files.
<span class="line-modified">1611   if (_method) {</span>
1612     // Emit the exception handler code.
1613     _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(*cb));
<span class="line-modified">1614     if (failing()) {</span>
1615       return; // CodeBuffer::expand failed
1616     }
1617     // Emit the deopt handler code.
1618     _code_offsets.set_value(CodeOffsets::Deopt, HandlerImpl::emit_deopt_handler(*cb));
1619 
1620     // Emit the MethodHandle deopt handler code (if required).
<span class="line-modified">1621     if (has_method_handle_invokes() &amp;&amp; !failing()) {</span>
1622       // We can use the same code as for the normal deopt handler, we
1623       // just need a different entry point address.
1624       _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(*cb));
1625     }
1626   }
1627 
1628   // One last check for failed CodeBuffer::expand:
1629   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1630     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1631     return;
1632   }
1633 
1634 #if defined(SUPPORT_ABSTRACT_ASSEMBLY) || defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_OPTO_ASSEMBLY)
<span class="line-modified">1635   if (print_assembly()) {</span>
1636     tty-&gt;cr();
1637     tty-&gt;print_cr(&quot;============================= C2-compiled nmethod ==============================&quot;);
1638   }
1639 #endif
1640 
1641 #if defined(SUPPORT_OPTO_ASSEMBLY)
1642   // Dump the assembly code, including basic-block numbers
<span class="line-modified">1643   if (print_assembly()) {</span>
1644     ttyLocker ttyl;  // keep the following output all in one block
1645     if (!VMThread::should_terminate()) {  // test this under the tty lock
1646       // This output goes directly to the tty, not the compiler log.
1647       // To enable tools to match it up with the compilation activity,
1648       // be sure to tag this tty output with the compile ID.
1649       if (xtty != NULL) {
<span class="line-modified">1650         xtty-&gt;head(&quot;opto_assembly compile_id=&#39;%d&#39;%s&quot;, compile_id(),</span>
<span class="line-modified">1651                    is_osr_compilation()    ? &quot; compile_kind=&#39;osr&#39;&quot; :</span>
1652                    &quot;&quot;);
1653       }
<span class="line-modified">1654       if (method() != NULL) {</span>
<span class="line-modified">1655         tty-&gt;print_cr(&quot;----------------------- MetaData before Compile_id = %d ------------------------&quot;, compile_id());</span>
<span class="line-modified">1656         method()-&gt;print_metadata();</span>
<span class="line-modified">1657       } else if (stub_name() != NULL) {</span>
<span class="line-modified">1658         tty-&gt;print_cr(&quot;----------------------------- RuntimeStub %s -------------------------------&quot;, stub_name());</span>
1659       }
1660       tty-&gt;cr();
<span class="line-modified">1661       tty-&gt;print_cr(&quot;------------------------ OptoAssembly for Compile_id = %d -----------------------&quot;, compile_id());</span>
1662       dump_asm(node_offsets, node_offset_limit);
1663       tty-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);
1664       if (xtty != NULL) {
1665         // print_metadata and dump_asm above may safepoint which makes us loose the ttylock.
1666         // Retake lock too make sure the end tag is coherent, and that xmlStream-&gt;pop_tag is done
1667         // thread safe
1668         ttyLocker ttyl2;
1669         xtty-&gt;tail(&quot;opto_assembly&quot;);
1670       }
1671     }
1672   }
1673 #endif
1674 }
1675 
<span class="line-modified">1676 void Compile::FillExceptionTables(uint cnt, uint *call_returns, uint *inct_starts, Label *blk_labels) {</span>
1677   _inc_table.set_size(cnt);
1678 
1679   uint inct_cnt = 0;
<span class="line-modified">1680   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified">1681     Block* block = _cfg-&gt;get_block(i);</span>
1682     Node *n = NULL;
1683     int j;
1684 
1685     // Find the branch; ignore trailing NOPs.
1686     for (j = block-&gt;number_of_nodes() - 1; j &gt;= 0; j--) {
1687       n = block-&gt;get_node(j);
1688       if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con) {
1689         break;
1690       }
1691     }
1692 
1693     // If we didn&#39;t find anything, continue
1694     if (j &lt; 0) {
1695       continue;
1696     }
1697 
1698     // Compute ExceptionHandlerTable subtable entry and add it
1699     // (skip empty blocks)
1700     if (n-&gt;is_Catch()) {
1701 
</pre>
<hr />
<pre>
1706       while (block-&gt;get_node(--j)-&gt;is_MachProj()) ;
1707       assert(block-&gt;get_node(j)-&gt;is_MachCall(), &quot;CatchProj must follow call&quot;);
1708 #endif
1709       // last instruction is a CatchNode, find it&#39;s CatchProjNodes
1710       int nof_succs = block-&gt;_num_succs;
1711       // allocate space
1712       GrowableArray&lt;intptr_t&gt; handler_bcis(nof_succs);
1713       GrowableArray&lt;intptr_t&gt; handler_pcos(nof_succs);
1714       // iterate through all successors
1715       for (int j = 0; j &lt; nof_succs; j++) {
1716         Block* s = block-&gt;_succs[j];
1717         bool found_p = false;
1718         for (uint k = 1; k &lt; s-&gt;num_preds(); k++) {
1719           Node* pk = s-&gt;pred(k);
1720           if (pk-&gt;is_CatchProj() &amp;&amp; pk-&gt;in(0) == n) {
1721             const CatchProjNode* p = pk-&gt;as_CatchProj();
1722             found_p = true;
1723             // add the corresponding handler bci &amp; pco information
1724             if (p-&gt;_con != CatchProjNode::fall_through_index) {
1725               // p leads to an exception handler (and is not fall through)
<span class="line-modified">1726               assert(s == _cfg-&gt;get_block(s-&gt;_pre_order), &quot;bad numbering&quot;);</span>
1727               // no duplicates, please
1728               if (!handler_bcis.contains(p-&gt;handler_bci())) {
1729                 uint block_num = s-&gt;non_connector()-&gt;_pre_order;
1730                 handler_bcis.append(p-&gt;handler_bci());
1731                 handler_pcos.append(blk_labels[block_num].loc_pos());
1732               }
1733             }
1734           }
1735         }
1736         assert(found_p, &quot;no matching predecessor found&quot;);
1737         // Note:  Due to empty block removal, one block may have
1738         // several CatchProj inputs, from the same Catch.
1739       }
1740 
1741       // Set the offset of the return from the call
1742       assert(handler_bcis.find(-1) != -1, &quot;must have default handler&quot;);
1743       _handler_table.add_subtable(call_return, &amp;handler_bcis, NULL, &amp;handler_pcos);
1744       continue;
1745     }
1746 
</pre>
<hr />
<pre>
1778           _available(arena),
1779           _reg_node(arena),
1780           _pinch_free_list(arena),
1781           _next_node(NULL),
1782           _bundle_instr_count(0),
1783           _bundle_cycle_number(0),
1784           _bundle_use(0, 0, resource_count, &amp;_bundle_use_elements[0])
1785 #ifndef PRODUCT
1786         , _branches(0)
1787         , _unconditional_delays(0)
1788 #endif
1789 {
1790   // Create a MachNopNode
1791   _nop = new MachNopNode();
1792 
1793   // Now that the nops are in the array, save the count
1794   // (but allow entries for the nops)
1795   _node_bundling_limit = compile.unique();
1796   uint node_max = _regalloc-&gt;node_regs_max_index();
1797 
<span class="line-modified">1798   compile.set_node_bundling_limit(_node_bundling_limit);</span>
1799 
1800   // This one is persistent within the Compile class
1801   _node_bundling_base = NEW_ARENA_ARRAY(compile.comp_arena(), Bundle, node_max);
1802 
1803   // Allocate space for fixed-size arrays
1804   _node_latency    = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1805   _uses            = NEW_ARENA_ARRAY(arena, short,          node_max);
1806   _current_latency = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1807 
1808   // Clear the arrays
1809   for (uint i = 0; i &lt; node_max; i++) {
1810     ::new (&amp;_node_bundling_base[i]) Bundle();
1811   }
1812   memset(_node_latency,       0, node_max * sizeof(unsigned short));
1813   memset(_uses,               0, node_max * sizeof(short));
1814   memset(_current_latency,    0, node_max * sizeof(unsigned short));
1815 
1816   // Clear the bundling information
1817   memcpy(_bundle_use_elements, Pipeline_Use::elaborated_elements, sizeof(Pipeline_Use::elaborated_elements));
1818 
</pre>
<hr />
<pre>
1854 
1855   // Update the bundle record
1856   if (_bundle_instr_count &gt; 0) {
1857     bundle-&gt;set_instr_count(_bundle_instr_count);
1858     bundle-&gt;set_resources_used(_bundle_use.resourcesUsed());
1859 
1860     _bundle_cycle_number += 1;
1861   }
1862 
1863   // Clear the bundling information
1864   _bundle_instr_count = 0;
1865   _bundle_use.reset();
1866 
1867   memcpy(_bundle_use_elements,
1868          Pipeline_Use::elaborated_elements,
1869          sizeof(Pipeline_Use::elaborated_elements));
1870 }
1871 
1872 // Perform instruction scheduling and bundling over the sequence of
1873 // instructions in backwards order.
<span class="line-modified">1874 void Compile::ScheduleAndBundle() {</span>
1875 
1876   // Don&#39;t optimize this if it isn&#39;t a method
<span class="line-modified">1877   if (!_method)</span>
1878     return;
1879 
1880   // Don&#39;t optimize this if scheduling is disabled
<span class="line-modified">1881   if (!do_scheduling())</span>
1882     return;
1883 
1884   // Scheduling code works only with pairs (16 bytes) maximum.
<span class="line-modified">1885   if (max_vector_size() &gt; 16)</span>
1886     return;
1887 
<span class="line-modified">1888   TracePhase tp(&quot;isched&quot;, &amp;timers[_t_instrSched]);</span>
1889 
1890   // Create a data structure for all the scheduling information
<span class="line-modified">1891   Scheduling scheduling(Thread::current()-&gt;resource_area(), *this);</span>
1892 
1893   // Walk backwards over each basic block, computing the needed alignment
1894   // Walk over all the basic blocks
1895   scheduling.DoScheduling();
1896 
1897 #ifndef PRODUCT
<span class="line-modified">1898   if (trace_opto_output()) {</span>
1899     tty-&gt;print(&quot;\n---- After ScheduleAndBundle ----\n&quot;);
<span class="line-modified">1900     for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
1901       tty-&gt;print(&quot;\nBB#%03d:\n&quot;, i);
<span class="line-modified">1902       Block* block = _cfg-&gt;get_block(i);</span>
1903       for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {
1904         Node* n = block-&gt;get_node(j);
<span class="line-modified">1905         OptoReg::Name reg = _regalloc-&gt;get_reg_first(n);</span>
1906         tty-&gt;print(&quot; %-6s &quot;, reg &gt;= 0 &amp;&amp; reg &lt; REG_COUNT ? Matcher::regName[reg] : &quot;&quot;);
1907         n-&gt;dump();
1908       }
1909     }
1910   }
1911 #endif
1912 }
1913 
1914 // Compute the latency of all the instructions.  This is fairly simple,
1915 // because we already have a legal ordering.  Walk over the instructions
1916 // from first to last, and compute the latency of the instruction based
1917 // on the latency of the preceding instruction(s).
1918 void Scheduling::ComputeLocalLatenciesForward(const Block *bb) {
1919 #ifndef PRODUCT
1920   if (_cfg-&gt;C-&gt;trace_opto_output())
1921     tty-&gt;print(&quot;# -&gt; ComputeLocalLatenciesForward\n&quot;);
1922 #endif
1923 
1924   // Walk over all the schedulable instructions
1925   for( uint j=_bb_start; j &lt; _bb_end; j++ ) {
</pre>
<hr />
<pre>
2427 #endif
2428   }
2429 
2430 #ifndef PRODUCT
2431   if (_cfg-&gt;C-&gt;trace_opto_output())
2432     tty-&gt;print(&quot;# &lt;- ComputeUseCount\n&quot;);
2433 #endif
2434 }
2435 
2436 // This routine performs scheduling on each basic block in reverse order,
2437 // using instruction latencies and taking into account function unit
2438 // availability.
2439 void Scheduling::DoScheduling() {
2440 #ifndef PRODUCT
2441   if (_cfg-&gt;C-&gt;trace_opto_output())
2442     tty-&gt;print(&quot;# -&gt; DoScheduling\n&quot;);
2443 #endif
2444 
2445   Block *succ_bb = NULL;
2446   Block *bb;

2447 
2448   // Walk over all the basic blocks in reverse order
2449   for (int i = _cfg-&gt;number_of_blocks() - 1; i &gt;= 0; succ_bb = bb, i--) {
2450     bb = _cfg-&gt;get_block(i);
2451 
2452 #ifndef PRODUCT
2453     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2454       tty-&gt;print(&quot;#  Schedule BB#%03d (initial)\n&quot;, i);
2455       for (uint j = 0; j &lt; bb-&gt;number_of_nodes(); j++) {
2456         bb-&gt;get_node(j)-&gt;dump();
2457       }
2458     }
2459 #endif
2460 
2461     // On the head node, skip processing
2462     if (bb == _cfg-&gt;get_root_block()) {
2463       continue;
2464     }
2465 
2466     // Skip empty, connector blocks
</pre>
<hr />
<pre>
2514         (last-&gt;is_Mach() &amp;&amp; last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Halt) ) {
2515       // There might be a prior call.  Skip it.
2516       while (_bb_start &lt; _bb_end &amp;&amp; bb-&gt;get_node(--_bb_end)-&gt;is_MachProj());
2517     } else if( last-&gt;is_MachNullCheck() ) {
2518       // Backup so the last null-checked memory instruction is
2519       // outside the schedulable range. Skip over the nullcheck,
2520       // projection, and the memory nodes.
2521       Node *mem = last-&gt;in(1);
2522       do {
2523         _bb_end--;
2524       } while (mem != bb-&gt;get_node(_bb_end));
2525     } else {
2526       // Set _bb_end to point after last schedulable inst.
2527       _bb_end++;
2528     }
2529 
2530     assert( _bb_start &lt;= _bb_end, &quot;inverted block ends&quot; );
2531 
2532     // Compute the register antidependencies for the basic block
2533     ComputeRegisterAntidependencies(bb);
<span class="line-modified">2534     if (_cfg-&gt;C-&gt;failing())  return;  // too many D-U pinch points</span>
2535 
2536     // Compute intra-bb latencies for the nodes
2537     ComputeLocalLatenciesForward(bb);
2538 
2539     // Compute the usage within the block, and set the list of all nodes
2540     // in the block that have no uses within the block.
2541     ComputeUseCount(bb);
2542 
2543     // Schedule the remaining instructions in the block
2544     while ( _available.size() &gt; 0 ) {
2545       Node *n = ChooseNodeToBundle();
2546       guarantee(n != NULL, &quot;no nodes available&quot;);
2547       AddNodeToBundle(n,bb);
2548     }
2549 
2550     assert( _scheduled.size() == _bb_end - _bb_start, &quot;wrong number of instructions&quot; );
2551 #ifdef ASSERT
2552     for( uint l = _bb_start; l &lt; _bb_end; l++ ) {
2553       Node *n = bb-&gt;get_node(l);
2554       uint m;
</pre>
<hr />
<pre>
2574           if (bundle-&gt;instr_count() &gt; 0 || bundle-&gt;flags() &gt; 0) {
2575             tty-&gt;print(&quot;*** Bundle: &quot;);
2576             bundle-&gt;dump();
2577           }
2578           n-&gt;dump();
2579         }
2580       }
2581     }
2582 #endif
2583 #ifdef ASSERT
2584     verify_good_schedule(bb,&quot;after block local scheduling&quot;);
2585 #endif
2586   }
2587 
2588 #ifndef PRODUCT
2589   if (_cfg-&gt;C-&gt;trace_opto_output())
2590     tty-&gt;print(&quot;# &lt;- DoScheduling\n&quot;);
2591 #endif
2592 
2593   // Record final node-bundling array location
<span class="line-modified">2594   _regalloc-&gt;C-&gt;set_node_bundling_base(_node_bundling_base);</span>
2595 
2596 } // end DoScheduling
2597 
2598 // Verify that no live-range used in the block is killed in the block by a
2599 // wrong DEF.  This doesn&#39;t verify live-ranges that span blocks.
2600 
2601 // Check for edge existence.  Used to avoid adding redundant precedence edges.
2602 static bool edge_from_to( Node *from, Node *to ) {
2603   for( uint i=0; i&lt;from-&gt;len(); i++ )
2604     if( from-&gt;in(i) == to )
2605       return true;
2606   return false;
2607 }
2608 
2609 #ifdef ASSERT
2610 void Scheduling::verify_do_def( Node *n, OptoReg::Name def, const char *msg ) {
2611   // Check for bad kills
2612   if( OptoReg::is_valid(def) ) { // Ignore stores &amp; control flow
2613     Node *prior_use = _reg_node[def];
2614     if( prior_use &amp;&amp; !edge_from_to(prior_use,n) ) {
</pre>
<hr />
<pre>
2681     from-&gt;add_prec(to);
2682 }
2683 
2684 void Scheduling::anti_do_def( Block *b, Node *def, OptoReg::Name def_reg, int is_def ) {
2685   if( !OptoReg::is_valid(def_reg) ) // Ignore stores &amp; control flow
2686     return;
2687 
2688   Node *pinch = _reg_node[def_reg]; // Get pinch point
2689   if ((pinch == NULL) || _cfg-&gt;get_block_for_node(pinch) != b || // No pinch-point yet?
2690       is_def ) {    // Check for a true def (not a kill)
2691     _reg_node.map(def_reg,def); // Record def/kill as the optimistic pinch-point
2692     return;
2693   }
2694 
2695   Node *kill = def;             // Rename &#39;def&#39; to more descriptive &#39;kill&#39;
2696   debug_only( def = (Node*)((intptr_t)0xdeadbeef); )
2697 
2698   // After some number of kills there _may_ be a later def
2699   Node *later_def = NULL;
2700 


2701   // Finding a kill requires a real pinch-point.
2702   // Check for not already having a pinch-point.
2703   // Pinch points are Op_Node&#39;s.
2704   if( pinch-&gt;Opcode() != Op_Node ) { // Or later-def/kill as pinch-point?
2705     later_def = pinch;            // Must be def/kill as optimistic pinch-point
2706     if ( _pinch_free_list.size() &gt; 0) {
2707       pinch = _pinch_free_list.pop();
2708     } else {
2709       pinch = new Node(1); // Pinch point to-be
2710     }
2711     if (pinch-&gt;_idx &gt;= _regalloc-&gt;node_regs_max_index()) {
2712       _cfg-&gt;C-&gt;record_method_not_compilable(&quot;too many D-U pinch points&quot;);
2713       return;
2714     }
2715     _cfg-&gt;map_node_to_block(pinch, b);      // Pretend it&#39;s valid in this block (lazy init)
2716     _reg_node.map(def_reg,pinch); // Record pinch-point
<span class="line-modified">2717     //_regalloc-&gt;set_bad(pinch-&gt;_idx); // Already initialized this way.</span>
2718     if( later_def-&gt;outcnt() == 0 || later_def-&gt;ideal_reg() == MachProjNode::fat_proj ) { // Distinguish def from kill
<span class="line-modified">2719       pinch-&gt;init_req(0, _cfg-&gt;C-&gt;top());     // set not NULL for the next call</span>
2720       add_prec_edge_from_to(later_def,pinch); // Add edge from kill to pinch
2721       later_def = NULL;           // and no later def
2722     }
2723     pinch-&gt;set_req(0,later_def);  // Hook later def so we can find it
2724   } else {                        // Else have valid pinch point
2725     if( pinch-&gt;in(0) )            // If there is a later-def
2726       later_def = pinch-&gt;in(0);   // Get it
2727   }
2728 
2729   // Add output-dependence edge from later def to kill
2730   if( later_def )               // If there is some original def
2731     add_prec_edge_from_to(later_def,kill); // Add edge from def to kill
2732 
2733   // See if current kill is also a use, and so is forced to be the pinch-point.
2734   if( pinch-&gt;Opcode() == Op_Node ) {
2735     Node *uses = kill-&gt;is_Proj() ? kill-&gt;in(0) : kill;
2736     for( uint i=1; i&lt;uses-&gt;req(); i++ ) {
2737       if( _regalloc-&gt;get_reg_first(uses-&gt;in(i)) == def_reg ||
2738           _regalloc-&gt;get_reg_second(uses-&gt;in(i)) == def_reg ) {
2739         // Yes, found a use/kill pinch-point
</pre>
<hr />
<pre>
3002                _total_branches, _total_unconditional_delays);
3003     if (_total_branches &gt; 0)
3004       tty-&gt;print(&quot;, for %.2f%%&quot;,
3005                  ((double)_total_unconditional_delays) / ((double)_total_branches) * 100.0);
3006     tty-&gt;print(&quot;\n&quot;);
3007   }
3008 
3009   uint total_instructions = 0, total_bundles = 0;
3010 
3011   for (uint i = 1; i &lt;= Pipeline::_max_instrs_per_cycle; i++) {
3012     uint bundle_count   = _total_instructions_per_bundle[i];
3013     total_instructions += bundle_count * i;
3014     total_bundles      += bundle_count;
3015   }
3016 
3017   if (total_bundles &gt; 0)
3018     tty-&gt;print(&quot;Average ILP (excluding nops) is %.2f\n&quot;,
3019                ((double)total_instructions) / ((double)total_bundles));
3020 }
3021 #endif


























































































































































































































































































































































































</pre>
</td>
<td>
<hr />
<pre>
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.inline.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;code/compiledIC.hpp&quot;
  29 #include &quot;code/debugInfo.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;compiler/compilerDirectives.hpp&quot;
  33 #include &quot;compiler/oopMap.hpp&quot;
  34 #include &quot;gc/shared/barrierSet.hpp&quot;
  35 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;opto/ad.hpp&quot;
<span class="line-added">  38 #include &quot;opto/block.hpp&quot;</span>
<span class="line-added">  39 #include &quot;opto/c2compiler.hpp&quot;</span>
  40 #include &quot;opto/callnode.hpp&quot;
  41 #include &quot;opto/cfgnode.hpp&quot;
  42 #include &quot;opto/locknode.hpp&quot;
  43 #include &quot;opto/machnode.hpp&quot;
<span class="line-added">  44 #include &quot;opto/node.hpp&quot;</span>
  45 #include &quot;opto/optoreg.hpp&quot;
  46 #include &quot;opto/output.hpp&quot;
  47 #include &quot;opto/regalloc.hpp&quot;
  48 #include &quot;opto/runtime.hpp&quot;
  49 #include &quot;opto/subnode.hpp&quot;
  50 #include &quot;opto/type.hpp&quot;
  51 #include &quot;runtime/handles.inline.hpp&quot;
<span class="line-added">  52 #include &quot;runtime/sharedRuntime.hpp&quot;</span>
  53 #include &quot;utilities/macros.hpp&quot;
  54 #include &quot;utilities/powerOfTwo.hpp&quot;
  55 #include &quot;utilities/xmlstream.hpp&quot;
  56 #ifdef X86
  57 #include &quot;c2_intelJccErratum_x86.hpp&quot;
  58 #endif
  59 
  60 #ifndef PRODUCT
  61 #define DEBUG_ARG(x) , x
  62 #else
  63 #define DEBUG_ARG(x)
  64 #endif
  65 
<span class="line-added">  66 //------------------------------Scheduling----------------------------------</span>
<span class="line-added">  67 // This class contains all the information necessary to implement instruction</span>
<span class="line-added">  68 // scheduling and bundling.</span>
<span class="line-added">  69 class Scheduling {</span>
<span class="line-added">  70 </span>
<span class="line-added">  71 private:</span>
<span class="line-added">  72   // Arena to use</span>
<span class="line-added">  73   Arena *_arena;</span>
<span class="line-added">  74 </span>
<span class="line-added">  75   // Control-Flow Graph info</span>
<span class="line-added">  76   PhaseCFG *_cfg;</span>
<span class="line-added">  77 </span>
<span class="line-added">  78   // Register Allocation info</span>
<span class="line-added">  79   PhaseRegAlloc *_regalloc;</span>
<span class="line-added">  80 </span>
<span class="line-added">  81   // Number of nodes in the method</span>
<span class="line-added">  82   uint _node_bundling_limit;</span>
<span class="line-added">  83 </span>
<span class="line-added">  84   // List of scheduled nodes. Generated in reverse order</span>
<span class="line-added">  85   Node_List _scheduled;</span>
<span class="line-added">  86 </span>
<span class="line-added">  87   // List of nodes currently available for choosing for scheduling</span>
<span class="line-added">  88   Node_List _available;</span>
<span class="line-added">  89 </span>
<span class="line-added">  90   // For each instruction beginning a bundle, the number of following</span>
<span class="line-added">  91   // nodes to be bundled with it.</span>
<span class="line-added">  92   Bundle *_node_bundling_base;</span>
<span class="line-added">  93 </span>
<span class="line-added">  94   // Mapping from register to Node</span>
<span class="line-added">  95   Node_List _reg_node;</span>
<span class="line-added">  96 </span>
<span class="line-added">  97   // Free list for pinch nodes.</span>
<span class="line-added">  98   Node_List _pinch_free_list;</span>
<span class="line-added">  99 </span>
<span class="line-added"> 100   // Latency from the beginning of the containing basic block (base 1)</span>
<span class="line-added"> 101   // for each node.</span>
<span class="line-added"> 102   unsigned short *_node_latency;</span>
<span class="line-added"> 103 </span>
<span class="line-added"> 104   // Number of uses of this node within the containing basic block.</span>
<span class="line-added"> 105   short *_uses;</span>
<span class="line-added"> 106 </span>
<span class="line-added"> 107   // Schedulable portion of current block.  Skips Region/Phi/CreateEx up</span>
<span class="line-added"> 108   // front, branch+proj at end.  Also skips Catch/CProj (same as</span>
<span class="line-added"> 109   // branch-at-end), plus just-prior exception-throwing call.</span>
<span class="line-added"> 110   uint _bb_start, _bb_end;</span>
<span class="line-added"> 111 </span>
<span class="line-added"> 112   // Latency from the end of the basic block as scheduled</span>
<span class="line-added"> 113   unsigned short *_current_latency;</span>
<span class="line-added"> 114 </span>
<span class="line-added"> 115   // Remember the next node</span>
<span class="line-added"> 116   Node *_next_node;</span>
<span class="line-added"> 117 </span>
<span class="line-added"> 118   // Use this for an unconditional branch delay slot</span>
<span class="line-added"> 119   Node *_unconditional_delay_slot;</span>
<span class="line-added"> 120 </span>
<span class="line-added"> 121   // Pointer to a Nop</span>
<span class="line-added"> 122   MachNopNode *_nop;</span>
<span class="line-added"> 123 </span>
<span class="line-added"> 124   // Length of the current bundle, in instructions</span>
<span class="line-added"> 125   uint _bundle_instr_count;</span>
<span class="line-added"> 126 </span>
<span class="line-added"> 127   // Current Cycle number, for computing latencies and bundling</span>
<span class="line-added"> 128   uint _bundle_cycle_number;</span>
<span class="line-added"> 129 </span>
<span class="line-added"> 130   // Bundle information</span>
<span class="line-added"> 131   Pipeline_Use_Element _bundle_use_elements[resource_count];</span>
<span class="line-added"> 132   Pipeline_Use         _bundle_use;</span>
<span class="line-added"> 133 </span>
<span class="line-added"> 134   // Dump the available list</span>
<span class="line-added"> 135   void dump_available() const;</span>
<span class="line-added"> 136 </span>
<span class="line-added"> 137 public:</span>
<span class="line-added"> 138   Scheduling(Arena *arena, Compile &amp;compile);</span>
<span class="line-added"> 139 </span>
<span class="line-added"> 140   // Destructor</span>
<span class="line-added"> 141   NOT_PRODUCT( ~Scheduling(); )</span>
<span class="line-added"> 142 </span>
<span class="line-added"> 143   // Step ahead &quot;i&quot; cycles</span>
<span class="line-added"> 144   void step(uint i);</span>
<span class="line-added"> 145 </span>
<span class="line-added"> 146   // Step ahead 1 cycle, and clear the bundle state (for example,</span>
<span class="line-added"> 147   // at a branch target)</span>
<span class="line-added"> 148   void step_and_clear();</span>
<span class="line-added"> 149 </span>
<span class="line-added"> 150   Bundle* node_bundling(const Node *n) {</span>
<span class="line-added"> 151     assert(valid_bundle_info(n), &quot;oob&quot;);</span>
<span class="line-added"> 152     return (&amp;_node_bundling_base[n-&gt;_idx]);</span>
<span class="line-added"> 153   }</span>
<span class="line-added"> 154 </span>
<span class="line-added"> 155   bool valid_bundle_info(const Node *n) const {</span>
<span class="line-added"> 156     return (_node_bundling_limit &gt; n-&gt;_idx);</span>
<span class="line-added"> 157   }</span>
<span class="line-added"> 158 </span>
<span class="line-added"> 159   bool starts_bundle(const Node *n) const {</span>
<span class="line-added"> 160     return (_node_bundling_limit &gt; n-&gt;_idx &amp;&amp; _node_bundling_base[n-&gt;_idx].starts_bundle());</span>
<span class="line-added"> 161   }</span>
<span class="line-added"> 162 </span>
<span class="line-added"> 163   // Do the scheduling</span>
<span class="line-added"> 164   void DoScheduling();</span>
<span class="line-added"> 165 </span>
<span class="line-added"> 166   // Compute the local latencies walking forward over the list of</span>
<span class="line-added"> 167   // nodes for a basic block</span>
<span class="line-added"> 168   void ComputeLocalLatenciesForward(const Block *bb);</span>
<span class="line-added"> 169 </span>
<span class="line-added"> 170   // Compute the register antidependencies within a basic block</span>
<span class="line-added"> 171   void ComputeRegisterAntidependencies(Block *bb);</span>
<span class="line-added"> 172   void verify_do_def( Node *n, OptoReg::Name def, const char *msg );</span>
<span class="line-added"> 173   void verify_good_schedule( Block *b, const char *msg );</span>
<span class="line-added"> 174   void anti_do_def( Block *b, Node *def, OptoReg::Name def_reg, int is_def );</span>
<span class="line-added"> 175   void anti_do_use( Block *b, Node *use, OptoReg::Name use_reg );</span>
<span class="line-added"> 176 </span>
<span class="line-added"> 177   // Add a node to the current bundle</span>
<span class="line-added"> 178   void AddNodeToBundle(Node *n, const Block *bb);</span>
<span class="line-added"> 179 </span>
<span class="line-added"> 180   // Add a node to the list of available nodes</span>
<span class="line-added"> 181   void AddNodeToAvailableList(Node *n);</span>
<span class="line-added"> 182 </span>
<span class="line-added"> 183   // Compute the local use count for the nodes in a block, and compute</span>
<span class="line-added"> 184   // the list of instructions with no uses in the block as available</span>
<span class="line-added"> 185   void ComputeUseCount(const Block *bb);</span>
<span class="line-added"> 186 </span>
<span class="line-added"> 187   // Choose an instruction from the available list to add to the bundle</span>
<span class="line-added"> 188   Node * ChooseNodeToBundle();</span>
<span class="line-added"> 189 </span>
<span class="line-added"> 190   // See if this Node fits into the currently accumulating bundle</span>
<span class="line-added"> 191   bool NodeFitsInBundle(Node *n);</span>
<span class="line-added"> 192 </span>
<span class="line-added"> 193   // Decrement the use count for a node</span>
<span class="line-added"> 194  void DecrementUseCounts(Node *n, const Block *bb);</span>
<span class="line-added"> 195 </span>
<span class="line-added"> 196   // Garbage collect pinch nodes for reuse by other blocks.</span>
<span class="line-added"> 197   void garbage_collect_pinch_nodes();</span>
<span class="line-added"> 198   // Clean up a pinch node for reuse (helper for above).</span>
<span class="line-added"> 199   void cleanup_pinch( Node *pinch );</span>
<span class="line-added"> 200 </span>
<span class="line-added"> 201   // Information for statistics gathering</span>
<span class="line-added"> 202 #ifndef PRODUCT</span>
<span class="line-added"> 203 private:</span>
<span class="line-added"> 204   // Gather information on size of nops relative to total</span>
<span class="line-added"> 205   uint _branches, _unconditional_delays;</span>
<span class="line-added"> 206 </span>
<span class="line-added"> 207   static uint _total_nop_size, _total_method_size;</span>
<span class="line-added"> 208   static uint _total_branches, _total_unconditional_delays;</span>
<span class="line-added"> 209   static uint _total_instructions_per_bundle[Pipeline::_max_instrs_per_cycle+1];</span>
<span class="line-added"> 210 </span>
<span class="line-added"> 211 public:</span>
<span class="line-added"> 212   static void print_statistics();</span>
<span class="line-added"> 213 </span>
<span class="line-added"> 214   static void increment_instructions_per_bundle(uint i) {</span>
<span class="line-added"> 215     _total_instructions_per_bundle[i]++;</span>
<span class="line-added"> 216   }</span>
<span class="line-added"> 217 </span>
<span class="line-added"> 218   static void increment_nop_size(uint s) {</span>
<span class="line-added"> 219     _total_nop_size += s;</span>
<span class="line-added"> 220   }</span>
<span class="line-added"> 221 </span>
<span class="line-added"> 222   static void increment_method_size(uint s) {</span>
<span class="line-added"> 223     _total_method_size += s;</span>
<span class="line-added"> 224   }</span>
<span class="line-added"> 225 #endif</span>
<span class="line-added"> 226 </span>
<span class="line-added"> 227 };</span>
<span class="line-added"> 228 </span>
<span class="line-added"> 229 </span>
<span class="line-added"> 230 PhaseOutput::PhaseOutput()</span>
<span class="line-added"> 231   : Phase(Phase::Output),</span>
<span class="line-added"> 232     _code_buffer(&quot;Compile::Fill_buffer&quot;),</span>
<span class="line-added"> 233     _first_block_size(0),</span>
<span class="line-added"> 234     _handler_table(),</span>
<span class="line-added"> 235     _inc_table(),</span>
<span class="line-added"> 236     _oop_map_set(NULL),</span>
<span class="line-added"> 237     _scratch_buffer_blob(NULL),</span>
<span class="line-added"> 238     _scratch_locs_memory(NULL),</span>
<span class="line-added"> 239     _scratch_const_size(-1),</span>
<span class="line-added"> 240     _in_scratch_emit_size(false),</span>
<span class="line-added"> 241     _frame_slots(0),</span>
<span class="line-added"> 242     _code_offsets(),</span>
<span class="line-added"> 243     _node_bundling_limit(0),</span>
<span class="line-added"> 244     _node_bundling_base(NULL),</span>
<span class="line-added"> 245     _orig_pc_slot(0),</span>
<span class="line-added"> 246     _orig_pc_slot_offset_in_bytes(0),</span>
<span class="line-added"> 247     _sp_inc_slot(0),</span>
<span class="line-added"> 248     _sp_inc_slot_offset_in_bytes(0) {</span>
<span class="line-added"> 249   C-&gt;set_output(this);</span>
<span class="line-added"> 250   if (C-&gt;stub_name() == NULL) {</span>
<span class="line-added"> 251     int fixed_slots = C-&gt;fixed_slots();</span>
<span class="line-added"> 252     if (C-&gt;needs_stack_repair()) {</span>
<span class="line-added"> 253       fixed_slots -= 2;</span>
<span class="line-added"> 254       _sp_inc_slot = fixed_slots;</span>
<span class="line-added"> 255     }</span>
<span class="line-added"> 256     _orig_pc_slot = fixed_slots - (sizeof(address) / VMRegImpl::stack_slot_size);</span>
<span class="line-added"> 257   }</span>
<span class="line-added"> 258 }</span>
<span class="line-added"> 259 </span>
<span class="line-added"> 260 PhaseOutput::~PhaseOutput() {</span>
<span class="line-added"> 261   C-&gt;set_output(NULL);</span>
<span class="line-added"> 262   if (_scratch_buffer_blob != NULL) {</span>
<span class="line-added"> 263     BufferBlob::free(_scratch_buffer_blob);</span>
<span class="line-added"> 264   }</span>
<span class="line-added"> 265 }</span>
<span class="line-added"> 266 </span>
 267 // Convert Nodes to instruction bits and pass off to the VM
<span class="line-modified"> 268 void PhaseOutput::Output() {</span>
 269   // RootNode goes
<span class="line-modified"> 270   assert( C-&gt;cfg()-&gt;get_root_block()-&gt;number_of_nodes() == 0, &quot;&quot; );</span>
 271 
 272   // The number of new nodes (mostly MachNop) is proportional to
 273   // the number of java calls and inner loops which are aligned.
 274   if ( C-&gt;check_node_count((NodeLimitFudgeFactor + C-&gt;java_calls()*3 +
 275                             C-&gt;inner_loops()*(OptoLoopAlignment-1)),
 276                            &quot;out of nodes before code generation&quot; ) ) {
 277     return;
 278   }
 279   // Make sure I can find the Start Node
<span class="line-modified"> 280   Block *entry = C-&gt;cfg()-&gt;get_block(1);</span>
<span class="line-modified"> 281   Block *broot = C-&gt;cfg()-&gt;get_root_block();</span>
 282 
 283   const StartNode *start = entry-&gt;head()-&gt;as_Start();
 284 
 285   // Replace StartNode with prolog
 286   Label verified_entry;
 287   MachPrologNode* prolog = new MachPrologNode(&amp;verified_entry);
 288   entry-&gt;map_node(prolog, 0);
<span class="line-modified"> 289   C-&gt;cfg()-&gt;map_node_to_block(prolog, entry);</span>
<span class="line-modified"> 290   C-&gt;cfg()-&gt;unmap_node_from_block(start); // start is no longer in any block</span>
 291 
 292   // Virtual methods need an unverified entry point
<span class="line-modified"> 293   if (C-&gt;is_osr_compilation()) {</span>
 294     if (PoisonOSREntry) {
 295       // TODO: Should use a ShouldNotReachHereNode...
<span class="line-modified"> 296       C-&gt;cfg()-&gt;insert( broot, 0, new MachBreakpointNode() );</span>
 297     }
 298   } else {
<span class="line-modified"> 299     if (C-&gt;method()) {</span>
<span class="line-modified"> 300       if (C-&gt;method()-&gt;has_scalarized_args()) {</span>
 301         // Add entry point to unpack all value type arguments
<span class="line-modified"> 302         C-&gt;cfg()-&gt;insert(broot, 0, new MachVEPNode(&amp;verified_entry, /* verified */ true, /* receiver_only */ false));</span>
<span class="line-modified"> 303         if (!C-&gt;method()-&gt;is_static()) {</span>
 304           // Add verified/unverified entry points to only unpack value type receiver at interface calls
<span class="line-modified"> 305           C-&gt;cfg()-&gt;insert(broot, 0, new MachVEPNode(&amp;verified_entry, /* verified */ false, /* receiver_only */ false));</span>
<span class="line-modified"> 306           C-&gt;cfg()-&gt;insert(broot, 0, new MachVEPNode(&amp;verified_entry, /* verified */ true,  /* receiver_only */ true));</span>
<span class="line-modified"> 307           C-&gt;cfg()-&gt;insert(broot, 0, new MachVEPNode(&amp;verified_entry, /* verified */ false, /* receiver_only */ true));</span>
 308         }
<span class="line-modified"> 309       } else if (!C-&gt;method()-&gt;is_static()) {</span>
 310         // Insert unvalidated entry point
<span class="line-modified"> 311         C-&gt;cfg()-&gt;insert(broot, 0, new MachUEPNode());</span>
 312       }
 313     }
 314   }
 315 
 316   // Break before main entry point
<span class="line-modified"> 317   if ((C-&gt;method() &amp;&amp; C-&gt;directive()-&gt;BreakAtExecuteOption) ||</span>
<span class="line-modified"> 318       (OptoBreakpoint &amp;&amp; C-&gt;is_method_compilation())       ||</span>
<span class="line-modified"> 319       (OptoBreakpointOSR &amp;&amp; C-&gt;is_osr_compilation())       ||</span>
<span class="line-modified"> 320       (OptoBreakpointC2R &amp;&amp; !C-&gt;method())                   ) {</span>
<span class="line-modified"> 321     // checking for C-&gt;method() means that OptoBreakpoint does not apply to</span>
 322     // runtime stubs or frame converters
<span class="line-modified"> 323     C-&gt;cfg()-&gt;insert( entry, 1, new MachBreakpointNode() );</span>
 324   }
 325 
 326   // Insert epilogs before every return
<span class="line-modified"> 327   for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified"> 328     Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
<span class="line-modified"> 329     if (!block-&gt;is_connector() &amp;&amp; block-&gt;non_connector_successor(0) == C-&gt;cfg()-&gt;get_root_block()) { // Found a program exit point?</span>
 330       Node* m = block-&gt;end();
 331       if (m-&gt;is_Mach() &amp;&amp; m-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Halt) {
 332         MachEpilogNode* epilog = new MachEpilogNode(m-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Return);
 333         block-&gt;add_inst(epilog);
<span class="line-modified"> 334         C-&gt;cfg()-&gt;map_node_to_block(epilog, block);</span>
 335       }
 336     }
 337   }
 338 
 339   // Keeper of sizing aspects
 340   BufferSizingData buf_sizes = BufferSizingData();
 341 
 342   // Initialize code buffer
 343   estimate_buffer_size(buf_sizes._const);
<span class="line-modified"> 344   if (C-&gt;failing()) return;</span>
 345 
 346   // Pre-compute the length of blocks and replace
 347   // long branches with short if machine supports it.
 348   // Must be done before ScheduleAndBundle due to SPARC delay slots
<span class="line-modified"> 349   uint* blk_starts = NEW_RESOURCE_ARRAY(uint, C-&gt;cfg()-&gt;number_of_blocks() + 1);</span>
 350   blk_starts[0] = 0;
 351   shorten_branches(blk_starts, buf_sizes);
 352 
<span class="line-modified"> 353   if (!C-&gt;is_osr_compilation() &amp;&amp; C-&gt;has_scalarized_args()) {</span>
 354     // Compute the offsets of the entry points required by the value type calling convention
<span class="line-modified"> 355     if (!C-&gt;method()-&gt;is_static()) {</span>
 356       // We have entries at the beginning of the method, implemented by the first 4 nodes.
 357       // Entry                     (unverified) @ offset 0
 358       // Verified_Value_Entry_RO
 359       // Value_Entry               (unverified)
 360       // Verified_Value_Entry
 361       uint offset = 0;
 362       _code_offsets.set_value(CodeOffsets::Entry, offset);
 363 
<span class="line-modified"> 364       offset += ((MachVEPNode*)broot-&gt;get_node(0))-&gt;size(C-&gt;regalloc());</span>
 365       _code_offsets.set_value(CodeOffsets::Verified_Value_Entry_RO, offset);
 366 
<span class="line-modified"> 367       offset += ((MachVEPNode*)broot-&gt;get_node(1))-&gt;size(C-&gt;regalloc());</span>
 368       _code_offsets.set_value(CodeOffsets::Value_Entry, offset);
 369 
<span class="line-modified"> 370       offset += ((MachVEPNode*)broot-&gt;get_node(2))-&gt;size(C-&gt;regalloc());</span>
 371       _code_offsets.set_value(CodeOffsets::Verified_Value_Entry, offset);
 372     } else {
 373       _code_offsets.set_value(CodeOffsets::Entry, -1); // will be patched later
 374       _code_offsets.set_value(CodeOffsets::Verified_Value_Entry, 0);
 375     }
 376   }
 377 
 378   ScheduleAndBundle();
<span class="line-modified"> 379   if (C-&gt;failing()) {</span>
 380     return;
 381   }
 382 
 383   // Late barrier analysis must be done after schedule and bundle
 384   // Otherwise liveness based spilling will fail
 385   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 386   bs-&gt;late_barrier_analysis();
 387 
 388 #ifdef X86
 389   if (VM_Version::has_intel_jcc_erratum()) {
<span class="line-modified"> 390     int extra_padding = IntelJccErratum::tag_affected_machnodes(C, C-&gt;cfg(), C-&gt;regalloc());</span>
 391     buf_sizes._code += extra_padding;
 392   }
 393 #endif
 394 
 395   // Complete sizing of codebuffer
 396   CodeBuffer* cb = init_buffer(buf_sizes);
<span class="line-modified"> 397   if (cb == NULL || C-&gt;failing()) {</span>
 398     return;
 399   }
 400 
 401   BuildOopMaps();
 402 
<span class="line-modified"> 403   if (C-&gt;failing())  {</span>
 404     return;
 405   }
 406 
 407   fill_buffer(cb, blk_starts);
 408 }
 409 
<span class="line-modified"> 410 bool PhaseOutput::need_stack_bang(int frame_size_in_bytes) const {</span>
 411   // Determine if we need to generate a stack overflow check.
 412   // Do it if the method is not a stub function and
 413   // has java calls or has frame size &gt; vm_page_size/8.
 414   // The debug VM checks that deoptimization doesn&#39;t trigger an
 415   // unexpected stack overflow (compiled method stack banging should
 416   // guarantee it doesn&#39;t happen) so we always need the stack bang in
 417   // a debug VM.
<span class="line-modified"> 418   return (UseStackBanging &amp;&amp; C-&gt;stub_function() == NULL &amp;&amp;</span>
<span class="line-modified"> 419           (C-&gt;has_java_calls() || frame_size_in_bytes &gt; os::vm_page_size()&gt;&gt;3</span>
 420            DEBUG_ONLY(|| true)));
 421 }
 422 
<span class="line-modified"> 423 bool PhaseOutput::need_register_stack_bang() const {</span>
 424   // Determine if we need to generate a register stack overflow check.
 425   // This is only used on architectures which have split register
 426   // and memory stacks (ie. IA64).
 427   // Bang if the method is not a stub function and has java calls
<span class="line-modified"> 428   return (C-&gt;stub_function() == NULL &amp;&amp; C-&gt;has_java_calls());</span>
 429 }
 430 
 431 
 432 // Compute the size of first NumberOfLoopInstrToAlign instructions at the top
 433 // of a loop. When aligning a loop we need to provide enough instructions
 434 // in cpu&#39;s fetch buffer to feed decoders. The loop alignment could be
 435 // avoided if we have enough instructions in fetch buffer at the head of a loop.
 436 // By default, the size is set to 999999 by Block&#39;s constructor so that
 437 // a loop will be aligned if the size is not reset here.
 438 //
 439 // Note: Mach instructions could contain several HW instructions
 440 // so the size is estimated only.
 441 //
<span class="line-modified"> 442 void PhaseOutput::compute_loop_first_inst_sizes() {</span>
 443   // The next condition is used to gate the loop alignment optimization.
 444   // Don&#39;t aligned a loop if there are enough instructions at the head of a loop
 445   // or alignment padding is larger then MaxLoopPad. By default, MaxLoopPad
 446   // is equal to OptoLoopAlignment-1 except on new Intel cpus, where it is
 447   // equal to 11 bytes which is the largest address NOP instruction.
 448   if (MaxLoopPad &lt; OptoLoopAlignment - 1) {
<span class="line-modified"> 449     uint last_block = C-&gt;cfg()-&gt;number_of_blocks() - 1;</span>
 450     for (uint i = 1; i &lt;= last_block; i++) {
<span class="line-modified"> 451       Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
 452       // Check the first loop&#39;s block which requires an alignment.
 453       if (block-&gt;loop_alignment() &gt; (uint)relocInfo::addr_unit()) {
 454         uint sum_size = 0;
 455         uint inst_cnt = NumberOfLoopInstrToAlign;
<span class="line-modified"> 456         inst_cnt = block-&gt;compute_first_inst_size(sum_size, inst_cnt, C-&gt;regalloc());</span>
 457 
 458         // Check subsequent fallthrough blocks if the loop&#39;s first
 459         // block(s) does not have enough instructions.
 460         Block *nb = block;
 461         while(inst_cnt &gt; 0 &amp;&amp;
 462               i &lt; last_block &amp;&amp;
<span class="line-modified"> 463               !C-&gt;cfg()-&gt;get_block(i + 1)-&gt;has_loop_alignment() &amp;&amp;</span>
 464               !nb-&gt;has_successor(block)) {
 465           i++;
<span class="line-modified"> 466           nb = C-&gt;cfg()-&gt;get_block(i);</span>
<span class="line-modified"> 467           inst_cnt  = nb-&gt;compute_first_inst_size(sum_size, inst_cnt, C-&gt;regalloc());</span>
 468         } // while( inst_cnt &gt; 0 &amp;&amp; i &lt; last_block  )
 469 
 470         block-&gt;set_first_inst_size(sum_size);
 471       } // f( b-&gt;head()-&gt;is_Loop() )
 472     } // for( i &lt;= last_block )
 473   } // if( MaxLoopPad &lt; OptoLoopAlignment-1 )
 474 }
 475 
 476 // The architecture description provides short branch variants for some long
 477 // branch instructions. Replace eligible long branches with short branches.
<span class="line-modified"> 478 void PhaseOutput::shorten_branches(uint* blk_starts, BufferSizingData&amp; buf_sizes) {</span>
 479   // Compute size of each block, method size, and relocation information size
<span class="line-modified"> 480   uint nblocks  = C-&gt;cfg()-&gt;number_of_blocks();</span>
 481 
 482   uint*      jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
 483   uint*      jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
 484   int*       jmp_nidx   = NEW_RESOURCE_ARRAY(int ,nblocks);
 485 
 486   // Collect worst case block paddings
 487   int* block_worst_case_pad = NEW_RESOURCE_ARRAY(int, nblocks);
 488   memset(block_worst_case_pad, 0, nblocks * sizeof(int));
 489 
 490   DEBUG_ONLY( uint *jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks); )
 491   DEBUG_ONLY( uint *jmp_rule = NEW_RESOURCE_ARRAY(uint,nblocks); )
 492 
 493   bool has_short_branch_candidate = false;
 494 
 495   // Initialize the sizes to 0
 496   int code_size  = 0;          // Size in bytes of generated code
 497   int stub_size  = 0;          // Size in bytes of all stub entries
 498   // Size in bytes of all relocation entries, including those in local stubs.
 499   // Start with 2-bytes of reloc info for the unvalidated entry point
 500   int reloc_size = 1;          // Number of relocation entries
 501 
 502   // Make three passes.  The first computes pessimistic blk_starts,
 503   // relative jmp_offset and reloc_size information.  The second performs
 504   // short branch substitution using the pessimistic sizing.  The
 505   // third inserts nops where needed.
 506 
 507   // Step one, perform a pessimistic sizing pass.
 508   uint last_call_adr = max_juint;
 509   uint last_avoid_back_to_back_adr = max_juint;
<span class="line-modified"> 510   uint nop_size = (new MachNopNode())-&gt;size(C-&gt;regalloc());</span>
 511   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
<span class="line-modified"> 512     Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
 513 
 514     // During short branch replacement, we store the relative (to blk_starts)
 515     // offset of jump in jmp_offset, rather than the absolute offset of jump.
 516     // This is so that we do not need to recompute sizes of all nodes when
 517     // we compute correct blk_starts in our next sizing pass.
 518     jmp_offset[i] = 0;
 519     jmp_size[i]   = 0;
 520     jmp_nidx[i]   = -1;
 521     DEBUG_ONLY( jmp_target[i] = 0; )
 522     DEBUG_ONLY( jmp_rule[i]   = 0; )
 523 
 524     // Sum all instruction sizes to compute block size
 525     uint last_inst = block-&gt;number_of_nodes();
 526     uint blk_size = 0;
 527     for (uint j = 0; j &lt; last_inst; j++) {
 528       Node* nj = block-&gt;get_node(j);
 529       // Handle machine instruction nodes
 530       if (nj-&gt;is_Mach()) {
 531         MachNode *mach = nj-&gt;as_Mach();
 532         blk_size += (mach-&gt;alignment_required() - 1) * relocInfo::addr_unit(); // assume worst case padding
</pre>
<hr />
<pre>
 568             blk_size += nop_size;
 569           }
 570         }
 571         if (mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 572           // Nop is inserted between &quot;avoid back to back&quot; instructions.
 573           // ScheduleAndBundle() can rearrange nodes in a block,
 574           // check for all offsets inside this block.
 575           if (last_avoid_back_to_back_adr &gt;= blk_starts[i]) {
 576             blk_size += nop_size;
 577           }
 578         }
 579         if (mach-&gt;may_be_short_branch()) {
 580           if (!nj-&gt;is_MachBranch()) {
 581 #ifndef PRODUCT
 582             nj-&gt;dump(3);
 583 #endif
 584             Unimplemented();
 585           }
 586           assert(jmp_nidx[i] == -1, &quot;block should have only one branch&quot;);
 587           jmp_offset[i] = blk_size;
<span class="line-modified"> 588           jmp_size[i]   = nj-&gt;size(C-&gt;regalloc());</span>
 589           jmp_nidx[i]   = j;
 590           has_short_branch_candidate = true;
 591         }
 592       }
<span class="line-modified"> 593       blk_size += nj-&gt;size(C-&gt;regalloc());</span>
 594       // Remember end of call offset
 595       if (nj-&gt;is_MachCall() &amp;&amp; !nj-&gt;is_MachCallLeaf()) {
 596         last_call_adr = blk_starts[i]+blk_size;
 597       }
 598       // Remember end of avoid_back_to_back offset
 599       if (nj-&gt;is_Mach() &amp;&amp; nj-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
 600         last_avoid_back_to_back_adr = blk_starts[i]+blk_size;
 601       }
 602     }
 603 
 604     // When the next block starts a loop, we may insert pad NOP
 605     // instructions.  Since we cannot know our future alignment,
 606     // assume the worst.
 607     if (i &lt; nblocks - 1) {
<span class="line-modified"> 608       Block* nb = C-&gt;cfg()-&gt;get_block(i + 1);</span>
 609       int max_loop_pad = nb-&gt;code_alignment()-relocInfo::addr_unit();
 610       if (max_loop_pad &gt; 0) {
 611         assert(is_power_of_2(max_loop_pad+relocInfo::addr_unit()), &quot;&quot;);
 612         // Adjust last_call_adr and/or last_avoid_back_to_back_adr.
 613         // If either is the last instruction in this block, bump by
 614         // max_loop_pad in lock-step with blk_size, so sizing
 615         // calculations in subsequent blocks still can conservatively
 616         // detect that it may the last instruction in this block.
 617         if (last_call_adr == blk_starts[i]+blk_size) {
 618           last_call_adr += max_loop_pad;
 619         }
 620         if (last_avoid_back_to_back_adr == blk_starts[i]+blk_size) {
 621           last_avoid_back_to_back_adr += max_loop_pad;
 622         }
 623         blk_size += max_loop_pad;
 624         block_worst_case_pad[i + 1] = max_loop_pad;
 625       }
 626     }
 627 
 628     // Save block size; update total method size
 629     blk_starts[i+1] = blk_starts[i]+blk_size;
 630   }
 631 
 632   // Step two, replace eligible long jumps.
 633   bool progress = true;
 634   uint last_may_be_short_branch_adr = max_juint;
 635   while (has_short_branch_candidate &amp;&amp; progress) {
 636     progress = false;
 637     has_short_branch_candidate = false;
 638     int adjust_block_start = 0;
 639     for (uint i = 0; i &lt; nblocks; i++) {
<span class="line-modified"> 640       Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
 641       int idx = jmp_nidx[i];
 642       MachNode* mach = (idx == -1) ? NULL: block-&gt;get_node(idx)-&gt;as_Mach();
 643       if (mach != NULL &amp;&amp; mach-&gt;may_be_short_branch()) {
 644 #ifdef ASSERT
 645         assert(jmp_size[i] &gt; 0 &amp;&amp; mach-&gt;is_MachBranch(), &quot;sanity&quot;);
 646         int j;
 647         // Find the branch; ignore trailing NOPs.
 648         for (j = block-&gt;number_of_nodes()-1; j&gt;=0; j--) {
 649           Node* n = block-&gt;get_node(j);
 650           if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con)
 651             break;
 652         }
 653         assert(j &gt;= 0 &amp;&amp; j == idx &amp;&amp; block-&gt;get_node(j) == (Node*)mach, &quot;sanity&quot;);
 654 #endif
 655         int br_size = jmp_size[i];
 656         int br_offs = blk_starts[i] + jmp_offset[i];
 657 
 658         // This requires the TRUE branch target be in succs[0]
 659         uint bnum = block-&gt;non_connector_successor(0)-&gt;_pre_order;
 660         int offset = blk_starts[bnum] - br_offs;
 661         if (bnum &gt; i) { // adjust following block&#39;s offset
 662           offset -= adjust_block_start;
 663         }
 664 
 665         // This block can be a loop header, account for the padding
 666         // in the previous block.
 667         int block_padding = block_worst_case_pad[i];
 668         assert(i == 0 || block_padding == 0 || br_offs &gt;= block_padding, &quot;Should have at least a padding on top&quot;);
 669         // In the following code a nop could be inserted before
 670         // the branch which will increase the backward distance.
 671         bool needs_padding = ((uint)(br_offs - block_padding) == last_may_be_short_branch_adr);
 672         assert(!needs_padding || jmp_offset[i] == 0, &quot;padding only branches at the beginning of block&quot;);
 673 
 674         if (needs_padding &amp;&amp; offset &lt;= 0)
 675           offset -= nop_size;
 676 
<span class="line-modified"> 677         if (C-&gt;matcher()-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {</span>
 678           // We&#39;ve got a winner.  Replace this branch.
 679           MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
 680 
 681           // Update the jmp_size.
<span class="line-modified"> 682           int new_size = replacement-&gt;size(C-&gt;regalloc());</span>
 683           int diff     = br_size - new_size;
 684           assert(diff &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
 685           // Conservatively take into account padding between
 686           // avoid_back_to_back branches. Previous branch could be
 687           // converted into avoid_back_to_back branch during next
 688           // rounds.
 689           if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 690             jmp_offset[i] += nop_size;
 691             diff -= nop_size;
 692           }
 693           adjust_block_start += diff;
 694           block-&gt;map_node(replacement, idx);
 695           mach-&gt;subsume_by(replacement, C);
 696           mach = replacement;
 697           progress = true;
 698 
 699           jmp_size[i] = new_size;
 700           DEBUG_ONLY( jmp_target[i] = bnum; );
 701           DEBUG_ONLY( jmp_rule[i] = mach-&gt;rule(); );
 702         } else {
 703           // The jump distance is not short, try again during next iteration.
 704           has_short_branch_candidate = true;
 705         }
 706       } // (mach-&gt;may_be_short_branch())
 707       if (mach != NULL &amp;&amp; (mach-&gt;may_be_short_branch() ||
 708                            mach-&gt;avoid_back_to_back(MachNode::AVOID_AFTER))) {
 709         last_may_be_short_branch_adr = blk_starts[i] + jmp_offset[i] + jmp_size[i];
 710       }
 711       blk_starts[i+1] -= adjust_block_start;
 712     }
 713   }
 714 
 715 #ifdef ASSERT
 716   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
 717     if (jmp_target[i] != 0) {
 718       int br_size = jmp_size[i];
 719       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
<span class="line-modified"> 720       if (!C-&gt;matcher()-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {</span>
 721         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
 722       }
<span class="line-modified"> 723       assert(C-&gt;matcher()-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset), &quot;Displacement too large for short jmp&quot;);</span>
 724     }
 725   }
 726 #endif
 727 
 728   // Step 3, compute the offsets of all blocks, will be done in fill_buffer()
 729   // after ScheduleAndBundle().
 730 
 731   // ------------------
 732   // Compute size for code buffer
 733   code_size = blk_starts[nblocks];
 734 
 735   // Relocation records
 736   reloc_size += 1;              // Relo entry for exception handler
 737 
 738   // Adjust reloc_size to number of record of relocation info
 739   // Min is 2 bytes, max is probably 6 or 8, with a tax up to 25% for
 740   // a relocation index.
 741   // The CodeBuffer will expand the locs array if this estimate is too low.
 742   reloc_size *= 10 / sizeof(relocInfo);
 743 
 744   buf_sizes._reloc = reloc_size;
 745   buf_sizes._code  = code_size;
 746   buf_sizes._stub  = stub_size;
 747 }
 748 
 749 //------------------------------FillLocArray-----------------------------------
 750 // Create a bit of debug info and append it to the array.  The mapping is from
 751 // Java local or expression stack to constant, register or stack-slot.  For
 752 // doubles, insert 2 mappings and return 1 (to tell the caller that the next
 753 // entry has been taken care of and caller should skip it).
 754 static LocationValue *new_loc_value( PhaseRegAlloc *ra, OptoReg::Name regnum, Location::Type l_type ) {
 755   // This should never have accepted Bad before
 756   assert(OptoReg::is_valid(regnum), &quot;location must be valid&quot;);
 757   return (OptoReg::is_reg(regnum))
 758          ? new LocationValue(Location::new_reg_loc(l_type, OptoReg::as_VMReg(regnum)) )
 759          : new LocationValue(Location::new_stk_loc(l_type,  ra-&gt;reg2offset(regnum)));
 760 }
 761 
 762 
 763 ObjectValue*
<span class="line-modified"> 764 PhaseOutput::sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id) {</span>
 765   for (int i = 0; i &lt; objs-&gt;length(); i++) {
 766     assert(objs-&gt;at(i)-&gt;is_object(), &quot;corrupt object cache&quot;);
 767     ObjectValue* sv = (ObjectValue*) objs-&gt;at(i);
 768     if (sv-&gt;id() == id) {
 769       return sv;
 770     }
 771   }
 772   // Otherwise..
 773   return NULL;
 774 }
 775 
<span class="line-modified"> 776 void PhaseOutput::set_sv_for_object_node(GrowableArray&lt;ScopeValue*&gt; *objs,</span>
 777                                      ObjectValue* sv ) {
 778   assert(sv_for_node_id(objs, sv-&gt;id()) == NULL, &quot;Precondition&quot;);
 779   objs-&gt;append(sv);
 780 }
 781 
 782 
<span class="line-modified"> 783 void PhaseOutput::FillLocArray( int idx, MachSafePointNode* sfpt, Node *local,</span>
 784                             GrowableArray&lt;ScopeValue*&gt; *array,
 785                             GrowableArray&lt;ScopeValue*&gt; *objs ) {
 786   assert( local, &quot;use _top instead of null&quot; );
 787   if (array-&gt;length() != idx) {
 788     assert(array-&gt;length() == idx + 1, &quot;Unexpected array count&quot;);
 789     // Old functionality:
 790     //   return
 791     // New functionality:
 792     //   Assert if the local is not top. In product mode let the new node
 793     //   override the old entry.
<span class="line-modified"> 794     assert(local == C-&gt;top(), &quot;LocArray collision&quot;);</span>
<span class="line-modified"> 795     if (local == C-&gt;top()) {</span>
 796       return;
 797     }
 798     array-&gt;pop();
 799   }
 800   const Type *t = local-&gt;bottom_type();
 801 
 802   // Is it a safepoint scalar object node?
 803   if (local-&gt;is_SafePointScalarObject()) {
 804     SafePointScalarObjectNode* spobj = local-&gt;as_SafePointScalarObject();
 805 
<span class="line-modified"> 806     ObjectValue* sv = sv_for_node_id(objs, spobj-&gt;_idx);</span>
 807     if (sv == NULL) {
 808       ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
 809       assert(cik-&gt;is_instance_klass() ||
 810              cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 811       sv = new ObjectValue(spobj-&gt;_idx,
 812                            new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
<span class="line-modified"> 813       set_sv_for_object_node(objs, sv);</span>
 814 
 815       uint first_ind = spobj-&gt;first_index(sfpt-&gt;jvms());
 816       for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
 817         Node* fld_node = sfpt-&gt;in(first_ind+i);
 818         (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfpt, fld_node, sv-&gt;field_values(), objs);
 819       }
 820     }
 821     array-&gt;append(sv);
 822     return;
 823   }
 824 
 825   // Grab the register number for the local
<span class="line-modified"> 826   OptoReg::Name regnum = C-&gt;regalloc()-&gt;get_reg_first(local);</span>
 827   if( OptoReg::is_valid(regnum) ) {// Got a register/stack?
 828     // Record the double as two float registers.
 829     // The register mask for such a value always specifies two adjacent
 830     // float registers, with the lower register number even.
 831     // Normally, the allocation of high and low words to these registers
 832     // is irrelevant, because nearly all operations on register pairs
 833     // (e.g., StoreD) treat them as a single unit.
 834     // Here, we assume in addition that the words in these two registers
 835     // stored &quot;naturally&quot; (by operations like StoreD and double stores
 836     // within the interpreter) such that the lower-numbered register
 837     // is written to the lower memory address.  This may seem like
 838     // a machine dependency, but it is not--it is a requirement on
 839     // the author of the &lt;arch&gt;.ad file to ensure that, for every
 840     // even/odd double-register pair to which a double may be allocated,
 841     // the word in the even single-register is stored to the first
 842     // memory word.  (Note that register numbers are completely
 843     // arbitrary, and are not tied to any machine-level encodings.)
 844 #ifdef _LP64
 845     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon ) {
 846       array-&gt;append(new ConstantIntValue((jint)0));
<span class="line-modified"> 847       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::dbl ));</span>
 848     } else if ( t-&gt;base() == Type::Long ) {
 849       array-&gt;append(new ConstantIntValue((jint)0));
<span class="line-modified"> 850       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::lng ));</span>
 851     } else if ( t-&gt;base() == Type::RawPtr ) {
 852       // jsr/ret return address which must be restored into a the full
 853       // width 64-bit stack slot.
<span class="line-modified"> 854       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::lng ));</span>
 855     }
 856 #else //_LP64
 857 #ifdef SPARC
 858     if (t-&gt;base() == Type::Long &amp;&amp; OptoReg::is_reg(regnum)) {
 859       // For SPARC we have to swap high and low words for
 860       // long values stored in a single-register (g0-g7).
<span class="line-modified"> 861       array-&gt;append(new_loc_value( C-&gt;regalloc(),              regnum   , Location::normal ));</span>
<span class="line-modified"> 862       array-&gt;append(new_loc_value( C-&gt;regalloc(), OptoReg::add(regnum,1), Location::normal ));</span>
 863     } else
 864 #endif //SPARC
 865     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon || t-&gt;base() == Type::Long ) {
 866       // Repack the double/long as two jints.
 867       // The convention the interpreter uses is that the second local
 868       // holds the first raw word of the native double representation.
 869       // This is actually reasonable, since locals and stack arrays
 870       // grow downwards in all implementations.
 871       // (If, on some machine, the interpreter&#39;s Java locals or stack
 872       // were to grow upwards, the embedded doubles would be word-swapped.)
<span class="line-modified"> 873       array-&gt;append(new_loc_value( C-&gt;regalloc(), OptoReg::add(regnum,1), Location::normal ));</span>
<span class="line-modified"> 874       array-&gt;append(new_loc_value( C-&gt;regalloc(),              regnum   , Location::normal ));</span>
 875     }
 876 #endif //_LP64
 877     else if( (t-&gt;base() == Type::FloatBot || t-&gt;base() == Type::FloatCon) &amp;&amp;
 878              OptoReg::is_reg(regnum) ) {
<span class="line-modified"> 879       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Matcher::float_in_double()</span>
 880                                                       ? Location::float_in_dbl : Location::normal ));
 881     } else if( t-&gt;base() == Type::Int &amp;&amp; OptoReg::is_reg(regnum) ) {
<span class="line-modified"> 882       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Matcher::int_in_long</span>
 883                                                       ? Location::int_in_long : Location::normal ));
 884     } else if( t-&gt;base() == Type::NarrowOop ) {
<span class="line-modified"> 885       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::narrowoop ));</span>
 886     } else {
<span class="line-modified"> 887       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, C-&gt;regalloc()-&gt;is_oop(local) ? Location::oop : Location::normal ));</span>
 888     }
 889     return;
 890   }
 891 
 892   // No register.  It must be constant data.
 893   switch (t-&gt;base()) {
 894     case Type::Half:              // Second half of a double
 895       ShouldNotReachHere();       // Caller should skip 2nd halves
 896       break;
 897     case Type::AnyPtr:
 898       array-&gt;append(new ConstantOopWriteValue(NULL));
 899       break;
 900     case Type::AryPtr:
 901     case Type::InstPtr:          // fall through
 902       array-&gt;append(new ConstantOopWriteValue(t-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));
 903       break;
 904     case Type::NarrowOop:
 905       if (t == TypeNarrowOop::NULL_PTR) {
 906         array-&gt;append(new ConstantOopWriteValue(NULL));
 907       } else {
</pre>
<hr />
<pre>
 959     // grow downwards in all implementations.
 960     // (If, on some machine, the interpreter&#39;s Java locals or stack
 961     // were to grow upwards, the embedded doubles would be word-swapped.)
 962     jlong_accessor acc;
 963     acc.long_value = d;
 964     array-&gt;append(new ConstantIntValue(acc.words[1]));
 965     array-&gt;append(new ConstantIntValue(acc.words[0]));
 966 #endif
 967       break;
 968     }
 969     case Type::Top:               // Add an illegal value here
 970       array-&gt;append(new LocationValue(Location()));
 971       break;
 972     default:
 973       ShouldNotReachHere();
 974       break;
 975   }
 976 }
 977 
 978 // Determine if this node starts a bundle
<span class="line-modified"> 979 bool PhaseOutput::starts_bundle(const Node *n) const {</span>
 980   return (_node_bundling_limit &gt; n-&gt;_idx &amp;&amp;
 981           _node_bundling_base[n-&gt;_idx].starts_bundle());
 982 }
 983 
 984 //--------------------------Process_OopMap_Node--------------------------------
<span class="line-modified"> 985 void PhaseOutput::Process_OopMap_Node(MachNode *mach, int current_offset) {</span>

 986   // Handle special safepoint nodes for synchronization
 987   MachSafePointNode *sfn   = mach-&gt;as_MachSafePoint();
 988   MachCallNode      *mcall;
 989 
 990   int safepoint_pc_offset = current_offset;
 991   bool is_method_handle_invoke = false;
 992   bool return_oop = false;
 993   bool return_vt = false;
 994 
 995   // Add the safepoint in the DebugInfoRecorder
 996   if( !mach-&gt;is_MachCall() ) {
 997     mcall = NULL;
<span class="line-modified"> 998     C-&gt;debug_info()-&gt;add_safepoint(safepoint_pc_offset, sfn-&gt;_oop_map);</span>
 999   } else {
1000     mcall = mach-&gt;as_MachCall();
1001 
1002     // Is the call a MethodHandle call?
1003     if (mcall-&gt;is_MachCallJava()) {
1004       if (mcall-&gt;as_MachCallJava()-&gt;_method_handle_invoke) {
<span class="line-modified">1005         assert(C-&gt;has_method_handle_invokes(), &quot;must have been set during call generation&quot;);</span>
1006         is_method_handle_invoke = true;
1007       }
1008     }
1009 
1010     // Check if a call returns an object.
1011     if (mcall-&gt;returns_pointer() || mcall-&gt;returns_vt()) {
1012       return_oop = true;
1013     }
1014     if (mcall-&gt;returns_vt()) {
1015       return_vt = true;
1016     }
1017     safepoint_pc_offset += mcall-&gt;ret_addr_offset();
<span class="line-modified">1018     C-&gt;debug_info()-&gt;add_safepoint(safepoint_pc_offset, mcall-&gt;_oop_map);</span>
1019   }
1020 
1021   // Loop over the JVMState list to add scope information
1022   // Do not skip safepoints with a NULL method, they need monitor info
1023   JVMState* youngest_jvms = sfn-&gt;jvms();
1024   int max_depth = youngest_jvms-&gt;depth();
1025 
1026   // Allocate the object pool for scalar-replaced objects -- the map from
1027   // small-integer keys (which can be recorded in the local and ostack
1028   // arrays) to descriptions of the object state.
1029   GrowableArray&lt;ScopeValue*&gt; *objs = new GrowableArray&lt;ScopeValue*&gt;();
1030 
1031   // Visit scopes from oldest to youngest.
1032   for (int depth = 1; depth &lt;= max_depth; depth++) {
1033     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
1034     int idx;
1035     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
1036     // Safepoints that do not have method() set only provide oop-map and monitor info
1037     // to support GC; these do not support deoptimization.
1038     int num_locs = (method == NULL) ? 0 : jvms-&gt;loc_size();
</pre>
<hr />
<pre>
1060             !method-&gt;is_synchronized() ||
1061             method-&gt;is_native() ||
1062             num_mon &gt; 0 ||
1063             !GenerateSynchronizationCode,
1064             &quot;monitors must always exist for synchronized methods&quot;);
1065 
1066     // Build the growable array of ScopeValues for exp stack
1067     GrowableArray&lt;MonitorValue*&gt; *monarray = new GrowableArray&lt;MonitorValue*&gt;(num_mon);
1068 
1069     // Loop over monitors and insert into array
1070     for (idx = 0; idx &lt; num_mon; idx++) {
1071       // Grab the node that defines this monitor
1072       Node* box_node = sfn-&gt;monitor_box(jvms, idx);
1073       Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
1074 
1075       // Create ScopeValue for object
1076       ScopeValue *scval = NULL;
1077 
1078       if (obj_node-&gt;is_SafePointScalarObject()) {
1079         SafePointScalarObjectNode* spobj = obj_node-&gt;as_SafePointScalarObject();
<span class="line-modified">1080         scval = PhaseOutput::sv_for_node_id(objs, spobj-&gt;_idx);</span>
1081         if (scval == NULL) {
1082           const Type *t = spobj-&gt;bottom_type();
1083           ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
1084           assert(cik-&gt;is_instance_klass() ||
1085                  cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
1086           ObjectValue* sv = new ObjectValue(spobj-&gt;_idx,
1087                                             new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
<span class="line-modified">1088           PhaseOutput::set_sv_for_object_node(objs, sv);</span>
1089 
1090           uint first_ind = spobj-&gt;first_index(youngest_jvms);
1091           for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
1092             Node* fld_node = sfn-&gt;in(first_ind+i);
1093             (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfn, fld_node, sv-&gt;field_values(), objs);
1094           }
1095           scval = sv;
1096         }
1097       } else if (!obj_node-&gt;is_Con()) {
<span class="line-modified">1098         OptoReg::Name obj_reg = C-&gt;regalloc()-&gt;get_reg_first(obj_node);</span>
1099         if( obj_node-&gt;bottom_type()-&gt;base() == Type::NarrowOop ) {
<span class="line-modified">1100           scval = new_loc_value( C-&gt;regalloc(), obj_reg, Location::narrowoop );</span>
1101         } else {
<span class="line-modified">1102           scval = new_loc_value( C-&gt;regalloc(), obj_reg, Location::oop );</span>
1103         }
1104       } else {
1105         const TypePtr *tp = obj_node-&gt;get_ptr_type();
1106         scval = new ConstantOopWriteValue(tp-&gt;is_oopptr()-&gt;const_oop()-&gt;constant_encoding());
1107       }
1108 
1109       OptoReg::Name box_reg = BoxLockNode::reg(box_node);
<span class="line-modified">1110       Location basic_lock = Location::new_stk_loc(Location::normal,C-&gt;regalloc()-&gt;reg2offset(box_reg));</span>
1111       bool eliminated = (box_node-&gt;is_BoxLock() &amp;&amp; box_node-&gt;as_BoxLock()-&gt;is_eliminated());
1112       monarray-&gt;append(new MonitorValue(scval, basic_lock, eliminated));
1113     }
1114 
1115     // We dump the object pool first, since deoptimization reads it in first.
<span class="line-modified">1116     C-&gt;debug_info()-&gt;dump_object_pool(objs);</span>
1117 
1118     // Build first class objects to pass to scope
<span class="line-modified">1119     DebugToken *locvals = C-&gt;debug_info()-&gt;create_scope_values(locarray);</span>
<span class="line-modified">1120     DebugToken *expvals = C-&gt;debug_info()-&gt;create_scope_values(exparray);</span>
<span class="line-modified">1121     DebugToken *monvals = C-&gt;debug_info()-&gt;create_monitor_values(monarray);</span>
1122 
1123     // Make method available for all Safepoints
<span class="line-modified">1124     ciMethod* scope_method = method ? method : C-&gt;method();</span>
1125     // Describe the scope here
1126     assert(jvms-&gt;bci() &gt;= InvocationEntryBci &amp;&amp; jvms-&gt;bci() &lt;= 0x10000, &quot;must be a valid or entry BCI&quot;);
1127     assert(!jvms-&gt;should_reexecute() || depth == max_depth, &quot;reexecute allowed only for the youngest&quot;);
1128     // Now we can describe the scope.
1129     methodHandle null_mh;
1130     bool rethrow_exception = false;
<span class="line-modified">1131     C-&gt;debug_info()-&gt;describe_scope(safepoint_pc_offset, null_mh, scope_method, jvms-&gt;bci(), jvms-&gt;should_reexecute(), rethrow_exception, is_method_handle_invoke, return_oop, return_vt, locvals, expvals, monvals);</span>
1132   } // End jvms loop
1133 
1134   // Mark the end of the scope set.
<span class="line-modified">1135   C-&gt;debug_info()-&gt;end_safepoint(safepoint_pc_offset);</span>
1136 }
1137 
1138 
1139 
1140 // A simplified version of Process_OopMap_Node, to handle non-safepoints.
1141 class NonSafepointEmitter {
1142     Compile*  C;
1143     JVMState* _pending_jvms;
1144     int       _pending_offset;
1145 
1146     void emit_non_safepoint();
1147 
1148  public:
1149     NonSafepointEmitter(Compile* compile) {
1150       this-&gt;C = compile;
1151       _pending_jvms = NULL;
1152       _pending_offset = 0;
1153     }
1154 
1155     void observe_instruction(Node* n, int pc_offset) {
</pre>
<hr />
<pre>
1203   DebugInformationRecorder* debug_info = C-&gt;debug_info();
1204   assert(debug_info-&gt;recording_non_safepoints(), &quot;sanity&quot;);
1205 
1206   debug_info-&gt;add_non_safepoint(pc_offset);
1207   int max_depth = youngest_jvms-&gt;depth();
1208 
1209   // Visit scopes from oldest to youngest.
1210   for (int depth = 1; depth &lt;= max_depth; depth++) {
1211     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
1212     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
1213     assert(!jvms-&gt;should_reexecute() || depth==max_depth, &quot;reexecute allowed only for the youngest&quot;);
1214     methodHandle null_mh;
1215     debug_info-&gt;describe_scope(pc_offset, null_mh, method, jvms-&gt;bci(), jvms-&gt;should_reexecute());
1216   }
1217 
1218   // Mark the end of the scope set.
1219   debug_info-&gt;end_non_safepoint(pc_offset);
1220 }
1221 
1222 //------------------------------init_buffer------------------------------------
<span class="line-modified">1223 void PhaseOutput::estimate_buffer_size(int&amp; const_req) {</span>
1224 
1225   // Set the initially allocated size
1226   const_req = initial_const_capacity;
1227 
1228   // The extra spacing after the code is necessary on some platforms.
1229   // Sometimes we need to patch in a jump after the last instruction,
1230   // if the nmethod has been deoptimized.  (See 4932387, 4894843.)
1231 
1232   // Compute the byte offset where we can store the deopt pc.
<span class="line-modified">1233   if (C-&gt;fixed_slots() != 0) {</span>
<span class="line-modified">1234     _orig_pc_slot_offset_in_bytes = C-&gt;regalloc()-&gt;reg2offset(OptoReg::stack2reg(_orig_pc_slot));</span>
1235   }
1236   if (C-&gt;needs_stack_repair()) {
1237     // Compute the byte offset of the stack increment value
<span class="line-modified">1238     _sp_inc_slot_offset_in_bytes = C-&gt;regalloc()-&gt;reg2offset(OptoReg::stack2reg(_sp_inc_slot));</span>
1239   }
1240 
1241   // Compute prolog code size
1242   _method_size = 0;
<span class="line-modified">1243   _frame_slots = OptoReg::reg2stack(C-&gt;matcher()-&gt;_old_SP) + C-&gt;regalloc()-&gt;_framesize;</span>
1244 #if defined(IA64) &amp;&amp; !defined(AIX)
1245   if (save_argument_registers()) {
1246     // 4815101: this is a stub with implicit and unknown precision fp args.
1247     // The usual spill mechanism can only generate stfd&#39;s in this case, which
1248     // doesn&#39;t work if the fp reg to spill contains a single-precision denorm.
1249     // Instead, we hack around the normal spill mechanism using stfspill&#39;s and
1250     // ldffill&#39;s in the MachProlog and MachEpilog emit methods.  We allocate
1251     // space here for the fp arg regs (f8-f15) we&#39;re going to thusly spill.
1252     //
1253     // If we ever implement 16-byte &#39;registers&#39; == stack slots, we can
1254     // get rid of this hack and have SpillCopy generate stfspill/ldffill
1255     // instead of stfd/stfs/ldfd/ldfs.
1256     _frame_slots += 8*(16/BytesPerInt);
1257   }
1258 #endif
1259   assert(_frame_slots &gt;= 0 &amp;&amp; _frame_slots &lt; 1000000, &quot;sanity check&quot;);
1260 
<span class="line-modified">1261   if (C-&gt;has_mach_constant_base_node()) {</span>
1262     uint add_size = 0;
1263     // Fill the constant table.
1264     // Note:  This must happen before shorten_branches.
<span class="line-modified">1265     for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified">1266       Block* b = C-&gt;cfg()-&gt;get_block(i);</span>
1267 
1268       for (uint j = 0; j &lt; b-&gt;number_of_nodes(); j++) {
1269         Node* n = b-&gt;get_node(j);
1270 
1271         // If the node is a MachConstantNode evaluate the constant
1272         // value section.
1273         if (n-&gt;is_MachConstant()) {
1274           MachConstantNode* machcon = n-&gt;as_MachConstant();
1275           machcon-&gt;eval_constant(C);
1276         } else if (n-&gt;is_Mach()) {
1277           // On Power there are more nodes that issue constants.
1278           add_size += (n-&gt;as_Mach()-&gt;ins_num_consts() * 8);
1279         }
1280       }
1281     }
1282 
1283     // Calculate the offsets of the constants and the size of the
1284     // constant table (including the padding to the next section).
1285     constant_table().calculate_offsets_and_size();
1286     const_req = constant_table().size() + add_size;
1287   }
1288 
1289   // Initialize the space for the BufferBlob used to find and verify
1290   // instruction size in MachNode::emit_size()
1291   init_scratch_buffer_blob(const_req);
1292 }
1293 
<span class="line-modified">1294 CodeBuffer* PhaseOutput::init_buffer(BufferSizingData&amp; buf_sizes) {</span>
1295 
1296   int stub_req  = buf_sizes._stub;
1297   int code_req  = buf_sizes._code;
1298   int const_req = buf_sizes._const;
1299 
1300   int pad_req   = NativeCall::instruction_size;
1301 
1302   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1303   stub_req += bs-&gt;estimate_stub_size();
1304 
1305   // nmethod and CodeBuffer count stubs &amp; constants as part of method&#39;s code.
1306   // class HandlerImpl is platform-specific and defined in the *.ad files.
1307   int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; // add marginal slop for handler
1308   int deopt_handler_req     = HandlerImpl::size_deopt_handler()     + MAX_stubs_size; // add marginal slop for handler
1309   stub_req += MAX_stubs_size;   // ensure per-stub margin
1310   code_req += MAX_inst_size;    // ensure per-instruction margin
1311 
1312   if (StressCodeBuffers)
1313     code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  // force expansion
1314 
1315   int total_req =
1316           const_req +
1317           code_req +
1318           pad_req +
1319           stub_req +
1320           exception_handler_req +
1321           deopt_handler_req;               // deopt handler
1322 
<span class="line-modified">1323   if (C-&gt;has_method_handle_invokes())</span>
1324     total_req += deopt_handler_req;  // deopt MH handler
1325 
1326   CodeBuffer* cb = code_buffer();
1327   cb-&gt;initialize(total_req, buf_sizes._reloc);
1328 
1329   // Have we run out of code space?
1330   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1331     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1332     return NULL;
1333   }
1334   // Configure the code buffer.
1335   cb-&gt;initialize_consts_size(const_req);
1336   cb-&gt;initialize_stubs_size(stub_req);
<span class="line-modified">1337   cb-&gt;initialize_oop_recorder(C-&gt;env()-&gt;oop_recorder());</span>
1338 
1339   // fill in the nop array for bundling computations
1340   MachNode *_nop_list[Bundle::_nop_count];
1341   Bundle::initialize_nops(_nop_list);
1342 
1343   return cb;
1344 }
1345 
1346 //------------------------------fill_buffer------------------------------------
<span class="line-modified">1347 void PhaseOutput::fill_buffer(CodeBuffer* cb, uint* blk_starts) {</span>
1348   // blk_starts[] contains offsets calculated during short branches processing,
1349   // offsets should not be increased during following steps.
1350 
1351   // Compute the size of first NumberOfLoopInstrToAlign instructions at head
1352   // of a loop. It is used to determine the padding for loop alignment.
1353   compute_loop_first_inst_sizes();
1354 
1355   // Create oopmap set.
1356   _oop_map_set = new OopMapSet();
1357 
1358   // !!!!! This preserves old handling of oopmaps for now
<span class="line-modified">1359   C-&gt;debug_info()-&gt;set_oopmaps(_oop_map_set);</span>
1360 
<span class="line-modified">1361   uint nblocks  = C-&gt;cfg()-&gt;number_of_blocks();</span>
1362   // Count and start of implicit null check instructions
1363   uint inct_cnt = 0;
1364   uint *inct_starts = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1365 
1366   // Count and start of calls
1367   uint *call_returns = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1368 
1369   uint  return_offset = 0;
<span class="line-modified">1370   int nop_size = (new MachNopNode())-&gt;size(C-&gt;regalloc());</span>
1371 
1372   int previous_offset = 0;
1373   int current_offset  = 0;
1374   int last_call_offset = -1;
1375   int last_avoid_back_to_back_offset = -1;
1376 #ifdef ASSERT
1377   uint* jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks);
1378   uint* jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
1379   uint* jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
1380   uint* jmp_rule   = NEW_RESOURCE_ARRAY(uint,nblocks);
1381 #endif
1382 
1383   // Create an array of unused labels, one for each basic block, if printing is enabled
1384 #if defined(SUPPORT_OPTO_ASSEMBLY)
1385   int *node_offsets      = NULL;
<span class="line-modified">1386   uint node_offset_limit = C-&gt;unique();</span>
1387 
<span class="line-modified">1388   if (C-&gt;print_assembly()) {</span>
1389     node_offsets = NEW_RESOURCE_ARRAY(int, node_offset_limit);
1390   }
1391   if (node_offsets != NULL) {
1392     // We need to initialize. Unused array elements may contain garbage and mess up PrintOptoAssembly.
1393     memset(node_offsets, 0, node_offset_limit*sizeof(int));
1394   }
1395 #endif
1396 
<span class="line-modified">1397   NonSafepointEmitter non_safepoints(C);  // emit non-safepoints lazily</span>
1398 
1399   // Emit the constant table.
<span class="line-modified">1400   if (C-&gt;has_mach_constant_base_node()) {</span>
1401     constant_table().emit(*cb);
1402   }
1403 
1404   // Create an array of labels, one for each basic block
1405   Label *blk_labels = NEW_RESOURCE_ARRAY(Label, nblocks+1);
1406   for (uint i=0; i &lt;= nblocks; i++) {
1407     blk_labels[i].init();
1408   }
1409 
1410   // ------------------
1411   // Now fill in the code buffer
1412   Node *delay_slot = NULL;
1413 
1414   for (uint i = 0; i &lt; nblocks; i++) {
<span class="line-modified">1415     Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
1416     Node* head = block-&gt;head();
1417 
1418     // If this block needs to start aligned (i.e, can be reached other
1419     // than by falling-thru from the previous block), then force the
1420     // start of a new bundle.
1421     if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(head)) {
1422       cb-&gt;flush_bundle(true);
1423     }
1424 
1425 #ifdef ASSERT
1426     if (!block-&gt;is_connector()) {
1427       stringStream st;
<span class="line-modified">1428       block-&gt;dump_head(C-&gt;cfg(), &amp;st);</span>
1429       MacroAssembler(cb).block_comment(st.as_string());
1430     }
1431     jmp_target[i] = 0;
1432     jmp_offset[i] = 0;
1433     jmp_size[i]   = 0;
1434     jmp_rule[i]   = 0;
1435 #endif
1436     int blk_offset = current_offset;
1437 
1438     // Define the label at the beginning of the basic block
1439     MacroAssembler(cb).bind(blk_labels[block-&gt;_pre_order]);
1440 
1441     uint last_inst = block-&gt;number_of_nodes();
1442 
1443     // Emit block normally, except for last instruction.
1444     // Emit means &quot;dump code bits into code buffer&quot;.
1445     for (uint j = 0; j&lt;last_inst; j++) {
1446 
1447       // Get the node
1448       Node* n = block-&gt;get_node(j);
1449 
1450       // See if delay slots are supported
<span class="line-modified">1451       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;used_in_unconditional_delay()) {</span>

1452         assert(delay_slot == NULL, &quot;no use of delay slot node&quot;);
<span class="line-modified">1453         assert(n-&gt;size(C-&gt;regalloc()) == Pipeline::instr_unit_size(), &quot;delay slot instruction wrong size&quot;);</span>
1454 
1455         delay_slot = n;
1456         continue;
1457       }
1458 
1459       // If this starts a new instruction group, then flush the current one
1460       // (but allow split bundles)
1461       if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(n))
1462         cb-&gt;flush_bundle(false);
1463 
1464       // Special handling for SafePoint/Call Nodes
1465       bool is_mcall = false;
1466       if (n-&gt;is_Mach()) {
1467         MachNode *mach = n-&gt;as_Mach();
1468         is_mcall = n-&gt;is_MachCall();
1469         bool is_sfn = n-&gt;is_MachSafePoint();
1470 
1471         // If this requires all previous instructions be flushed, then do so
1472         if (is_sfn || is_mcall || mach-&gt;alignment_required() != 1) {
1473           cb-&gt;flush_bundle(true);
</pre>
<hr />
<pre>
1475         }
1476 
1477         // A padding may be needed again since a previous instruction
1478         // could be moved to delay slot.
1479 
1480         // align the instruction if necessary
1481         int padding = mach-&gt;compute_padding(current_offset);
1482         // Make sure safepoint node for polling is distinct from a call&#39;s
1483         // return by adding a nop if needed.
1484         if (is_sfn &amp;&amp; !is_mcall &amp;&amp; padding == 0 &amp;&amp; current_offset == last_call_offset) {
1485           padding = nop_size;
1486         }
1487         if (padding == 0 &amp;&amp; mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE) &amp;&amp;
1488             current_offset == last_avoid_back_to_back_offset) {
1489           // Avoid back to back some instructions.
1490           padding = nop_size;
1491         }
1492 #ifdef X86
1493         if (mach-&gt;flags() &amp; Node::Flag_intel_jcc_erratum) {
1494           assert(padding == 0, &quot;can&#39;t have contradicting padding requirements&quot;);
<span class="line-modified">1495           padding = IntelJccErratum::compute_padding(current_offset, mach, block, j, C-&gt;regalloc());</span>
1496         }
1497 #endif
1498 
1499         if (padding &gt; 0) {
1500           assert((padding % nop_size) == 0, &quot;padding is not a multiple of NOP size&quot;);
1501           int nops_cnt = padding / nop_size;
1502           MachNode *nop = new MachNopNode(nops_cnt);
1503           block-&gt;insert_node(nop, j++);
1504           last_inst++;
<span class="line-modified">1505           C-&gt;cfg()-&gt;map_node_to_block(nop, block);</span>
1506           // Ensure enough space.
1507           cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1508           if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1509             C-&gt;record_failure(&quot;CodeCache is full&quot;);
1510             return;
1511           }
<span class="line-modified">1512           nop-&gt;emit(*cb, C-&gt;regalloc());</span>
1513           cb-&gt;flush_bundle(true);
1514           current_offset = cb-&gt;insts_size();
1515         }
1516 
1517         // Remember the start of the last call in a basic block
1518         if (is_mcall) {
1519           MachCallNode *mcall = mach-&gt;as_MachCall();
1520 
1521           if (mcall-&gt;entry_point() != NULL) {
1522             // This destination address is NOT PC-relative
1523             mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
1524           }
1525 
1526           // Save the return address
1527           call_returns[block-&gt;_pre_order] = current_offset + mcall-&gt;ret_addr_offset();
1528 
1529           if (mcall-&gt;is_MachCallLeaf()) {
1530             is_mcall = false;
1531             is_sfn = false;
1532           }
</pre>
<hr />
<pre>
1547 
1548           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1549                                            current_offset);
1550           Process_OopMap_Node(mach, current_offset);
1551         } // End if safepoint
1552 
1553           // If this is a null check, then add the start of the previous instruction to the list
1554         else if( mach-&gt;is_MachNullCheck() ) {
1555           inct_starts[inct_cnt++] = previous_offset;
1556         }
1557 
1558           // If this is a branch, then fill in the label with the target BB&#39;s label
1559         else if (mach-&gt;is_MachBranch()) {
1560           // This requires the TRUE branch target be in succs[0]
1561           uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1562 
1563           // Try to replace long branch if delay slot is not used,
1564           // it is mostly for back branches since forward branch&#39;s
1565           // distance is not updated yet.
1566           bool delay_slot_is_used = valid_bundle_info(n) &amp;&amp;
<span class="line-modified">1567                                     C-&gt;output()-&gt;node_bundling(n)-&gt;use_unconditional_delay();</span>
1568           if (!delay_slot_is_used &amp;&amp; mach-&gt;may_be_short_branch()) {
1569             assert(delay_slot == NULL, &quot;not expecting delay slot node&quot;);
<span class="line-modified">1570             int br_size = n-&gt;size(C-&gt;regalloc());</span>
1571             int offset = blk_starts[block_num] - current_offset;
1572             if (block_num &gt;= i) {
1573               // Current and following block&#39;s offset are not
1574               // finalized yet, adjust distance by the difference
1575               // between calculated and final offsets of current block.
1576               offset -= (blk_starts[i] - blk_offset);
1577             }
1578             // In the following code a nop could be inserted before
1579             // the branch which will increase the backward distance.
1580             bool needs_padding = (current_offset == last_avoid_back_to_back_offset);
1581             if (needs_padding &amp;&amp; offset &lt;= 0)
1582               offset -= nop_size;
1583 
<span class="line-modified">1584             if (C-&gt;matcher()-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {</span>
1585               // We&#39;ve got a winner.  Replace this branch.
1586               MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
1587 
1588               // Update the jmp_size.
<span class="line-modified">1589               int new_size = replacement-&gt;size(C-&gt;regalloc());</span>
1590               assert((br_size - new_size) &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
1591               // Insert padding between avoid_back_to_back branches.
1592               if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
1593                 MachNode *nop = new MachNopNode();
1594                 block-&gt;insert_node(nop, j++);
<span class="line-modified">1595                 C-&gt;cfg()-&gt;map_node_to_block(nop, block);</span>
1596                 last_inst++;
<span class="line-modified">1597                 nop-&gt;emit(*cb, C-&gt;regalloc());</span>
1598                 cb-&gt;flush_bundle(true);
1599                 current_offset = cb-&gt;insts_size();
1600               }
1601 #ifdef ASSERT
1602               jmp_target[i] = block_num;
1603               jmp_offset[i] = current_offset - blk_offset;
1604               jmp_size[i]   = new_size;
1605               jmp_rule[i]   = mach-&gt;rule();
1606 #endif
1607               block-&gt;map_node(replacement, j);
1608               mach-&gt;subsume_by(replacement, C);
1609               n    = replacement;
1610               mach = replacement;
1611             }
1612           }
1613           mach-&gt;as_MachBranch()-&gt;label_set( &amp;blk_labels[block_num], block_num );
1614         } else if (mach-&gt;ideal_Opcode() == Op_Jump) {
1615           for (uint h = 0; h &lt; block-&gt;_num_succs; h++) {
1616             Block* succs_block = block-&gt;_succs[h];
1617             for (uint j = 1; j &lt; succs_block-&gt;num_preds(); j++) {
</pre>
<hr />
<pre>
1659           inct_starts[inct_cnt++] = current_offset;
1660         }
1661       }
1662 
1663       // Verify that there is sufficient space remaining
1664       cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1665       if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1666         C-&gt;record_failure(&quot;CodeCache is full&quot;);
1667         return;
1668       }
1669 
1670       // Save the offset for the listing
1671 #if defined(SUPPORT_OPTO_ASSEMBLY)
1672       if ((node_offsets != NULL) &amp;&amp; (n-&gt;_idx &lt; node_offset_limit)) {
1673         node_offsets[n-&gt;_idx] = cb-&gt;insts_size();
1674       }
1675 #endif
1676 
1677       // &quot;Normal&quot; instruction case
1678       DEBUG_ONLY( uint instr_offset = cb-&gt;insts_size(); )
<span class="line-modified">1679       n-&gt;emit(*cb, C-&gt;regalloc());</span>
1680       current_offset  = cb-&gt;insts_size();
1681 
1682       // Above we only verified that there is enough space in the instruction section.
1683       // However, the instruction may emit stubs that cause code buffer expansion.
1684       // Bail out here if expansion failed due to a lack of code cache space.
<span class="line-modified">1685       if (C-&gt;failing()) {</span>
1686         return;
1687       }
1688 
1689 #ifdef ASSERT
<span class="line-modified">1690       if (n-&gt;size(C-&gt;regalloc()) &lt; (current_offset-instr_offset)) {</span>
1691         n-&gt;dump();
1692         assert(false, &quot;wrong size of mach node&quot;);
1693       }
1694 #endif
1695       non_safepoints.observe_instruction(n, current_offset);
1696 
1697       // mcall is last &quot;call&quot; that can be a safepoint
1698       // record it so we can see if a poll will directly follow it
1699       // in which case we&#39;ll need a pad to make the PcDesc sites unique
1700       // see  5010568. This can be slightly inaccurate but conservative
1701       // in the case that return address is not actually at current_offset.
1702       // This is a small price to pay.
1703 
1704       if (is_mcall) {
1705         last_call_offset = current_offset;
1706       }
1707 
1708       if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
1709         // Avoid back to back some instructions.
1710         last_avoid_back_to_back_offset = current_offset;
</pre>
<hr />
<pre>
1725 #endif
1726 
1727         // Support a SafePoint in the delay slot
1728         if (delay_slot-&gt;is_MachSafePoint()) {
1729           MachNode *mach = delay_slot-&gt;as_Mach();
1730           // !!!!! Stubs only need an oopmap right now, so bail out
1731           if (!mach-&gt;is_MachCall() &amp;&amp; mach-&gt;as_MachSafePoint()-&gt;jvms()-&gt;method() == NULL) {
1732             // Write the oopmap directly to the code blob??!!
1733             delay_slot = NULL;
1734             continue;
1735           }
1736 
1737           int adjusted_offset = current_offset - Pipeline::instr_unit_size();
1738           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1739                                            adjusted_offset);
1740           // Generate an OopMap entry
1741           Process_OopMap_Node(mach, adjusted_offset);
1742         }
1743 
1744         // Insert the delay slot instruction
<span class="line-modified">1745         delay_slot-&gt;emit(*cb, C-&gt;regalloc());</span>
1746 
1747         // Don&#39;t reuse it
1748         delay_slot = NULL;
1749       }
1750 
1751     } // End for all instructions in block
1752 
1753     // If the next block is the top of a loop, pad this block out to align
1754     // the loop top a little. Helps prevent pipe stalls at loop back branches.
1755     if (i &lt; nblocks-1) {
<span class="line-modified">1756       Block *nb = C-&gt;cfg()-&gt;get_block(i + 1);</span>
1757       int padding = nb-&gt;alignment_padding(current_offset);
1758       if( padding &gt; 0 ) {
1759         MachNode *nop = new MachNopNode(padding / nop_size);
1760         block-&gt;insert_node(nop, block-&gt;number_of_nodes());
<span class="line-modified">1761         C-&gt;cfg()-&gt;map_node_to_block(nop, block);</span>
<span class="line-modified">1762         nop-&gt;emit(*cb, C-&gt;regalloc());</span>
1763         current_offset = cb-&gt;insts_size();
1764       }
1765     }
1766     // Verify that the distance for generated before forward
1767     // short branches is still valid.
1768     guarantee((int)(blk_starts[i+1] - blk_starts[i]) &gt;= (current_offset - blk_offset), &quot;shouldn&#39;t increase block size&quot;);
1769 
1770     // Save new block start offset
1771     blk_starts[i] = blk_offset;
1772   } // End of for all blocks
1773   blk_starts[nblocks] = current_offset;
1774 
1775   non_safepoints.flush_at_end();
1776 
1777   // Offset too large?
<span class="line-modified">1778   if (C-&gt;failing())  return;</span>
1779 
1780   // Define a pseudo-label at the end of the code
1781   MacroAssembler(cb).bind( blk_labels[nblocks] );
1782 
1783   // Compute the size of the first block
1784   _first_block_size = blk_labels[1].loc_pos() - blk_labels[0].loc_pos();
1785 
1786 #ifdef ASSERT
1787   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
1788     if (jmp_target[i] != 0) {
1789       int br_size = jmp_size[i];
1790       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
<span class="line-modified">1791       if (!C-&gt;matcher()-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {</span>
1792         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
1793         assert(false, &quot;Displacement too large for short jmp&quot;);
1794       }
1795     }
1796   }
1797 #endif
1798 
1799   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1800   bs-&gt;emit_stubs(*cb);
<span class="line-modified">1801   if (C-&gt;failing())  return;</span>
1802 
1803 #ifndef PRODUCT
1804   // Information on the size of the method, without the extraneous code
1805   Scheduling::increment_method_size(cb-&gt;insts_size());
1806 #endif
1807 
1808   // ------------------
1809   // Fill in exception table entries.
1810   FillExceptionTables(inct_cnt, call_returns, inct_starts, blk_labels);
1811 
1812   // Only java methods have exception handlers and deopt handlers
1813   // class HandlerImpl is platform-specific and defined in the *.ad files.
<span class="line-modified">1814   if (C-&gt;method()) {</span>
1815     // Emit the exception handler code.
1816     _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(*cb));
<span class="line-modified">1817     if (C-&gt;failing()) {</span>
1818       return; // CodeBuffer::expand failed
1819     }
1820     // Emit the deopt handler code.
1821     _code_offsets.set_value(CodeOffsets::Deopt, HandlerImpl::emit_deopt_handler(*cb));
1822 
1823     // Emit the MethodHandle deopt handler code (if required).
<span class="line-modified">1824     if (C-&gt;has_method_handle_invokes() &amp;&amp; !C-&gt;failing()) {</span>
1825       // We can use the same code as for the normal deopt handler, we
1826       // just need a different entry point address.
1827       _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(*cb));
1828     }
1829   }
1830 
1831   // One last check for failed CodeBuffer::expand:
1832   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1833     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1834     return;
1835   }
1836 
1837 #if defined(SUPPORT_ABSTRACT_ASSEMBLY) || defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_OPTO_ASSEMBLY)
<span class="line-modified">1838   if (C-&gt;print_assembly()) {</span>
1839     tty-&gt;cr();
1840     tty-&gt;print_cr(&quot;============================= C2-compiled nmethod ==============================&quot;);
1841   }
1842 #endif
1843 
1844 #if defined(SUPPORT_OPTO_ASSEMBLY)
1845   // Dump the assembly code, including basic-block numbers
<span class="line-modified">1846   if (C-&gt;print_assembly()) {</span>
1847     ttyLocker ttyl;  // keep the following output all in one block
1848     if (!VMThread::should_terminate()) {  // test this under the tty lock
1849       // This output goes directly to the tty, not the compiler log.
1850       // To enable tools to match it up with the compilation activity,
1851       // be sure to tag this tty output with the compile ID.
1852       if (xtty != NULL) {
<span class="line-modified">1853         xtty-&gt;head(&quot;opto_assembly compile_id=&#39;%d&#39;%s&quot;, C-&gt;compile_id(),</span>
<span class="line-modified">1854                    C-&gt;is_osr_compilation()    ? &quot; compile_kind=&#39;osr&#39;&quot; :</span>
1855                    &quot;&quot;);
1856       }
<span class="line-modified">1857       if (C-&gt;method() != NULL) {</span>
<span class="line-modified">1858         tty-&gt;print_cr(&quot;----------------------- MetaData before Compile_id = %d ------------------------&quot;, C-&gt;compile_id());</span>
<span class="line-modified">1859         C-&gt;method()-&gt;print_metadata();</span>
<span class="line-modified">1860       } else if (C-&gt;stub_name() != NULL) {</span>
<span class="line-modified">1861         tty-&gt;print_cr(&quot;----------------------------- RuntimeStub %s -------------------------------&quot;, C-&gt;stub_name());</span>
1862       }
1863       tty-&gt;cr();
<span class="line-modified">1864       tty-&gt;print_cr(&quot;------------------------ OptoAssembly for Compile_id = %d -----------------------&quot;, C-&gt;compile_id());</span>
1865       dump_asm(node_offsets, node_offset_limit);
1866       tty-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);
1867       if (xtty != NULL) {
1868         // print_metadata and dump_asm above may safepoint which makes us loose the ttylock.
1869         // Retake lock too make sure the end tag is coherent, and that xmlStream-&gt;pop_tag is done
1870         // thread safe
1871         ttyLocker ttyl2;
1872         xtty-&gt;tail(&quot;opto_assembly&quot;);
1873       }
1874     }
1875   }
1876 #endif
1877 }
1878 
<span class="line-modified">1879 void PhaseOutput::FillExceptionTables(uint cnt, uint *call_returns, uint *inct_starts, Label *blk_labels) {</span>
1880   _inc_table.set_size(cnt);
1881 
1882   uint inct_cnt = 0;
<span class="line-modified">1883   for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified">1884     Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
1885     Node *n = NULL;
1886     int j;
1887 
1888     // Find the branch; ignore trailing NOPs.
1889     for (j = block-&gt;number_of_nodes() - 1; j &gt;= 0; j--) {
1890       n = block-&gt;get_node(j);
1891       if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con) {
1892         break;
1893       }
1894     }
1895 
1896     // If we didn&#39;t find anything, continue
1897     if (j &lt; 0) {
1898       continue;
1899     }
1900 
1901     // Compute ExceptionHandlerTable subtable entry and add it
1902     // (skip empty blocks)
1903     if (n-&gt;is_Catch()) {
1904 
</pre>
<hr />
<pre>
1909       while (block-&gt;get_node(--j)-&gt;is_MachProj()) ;
1910       assert(block-&gt;get_node(j)-&gt;is_MachCall(), &quot;CatchProj must follow call&quot;);
1911 #endif
1912       // last instruction is a CatchNode, find it&#39;s CatchProjNodes
1913       int nof_succs = block-&gt;_num_succs;
1914       // allocate space
1915       GrowableArray&lt;intptr_t&gt; handler_bcis(nof_succs);
1916       GrowableArray&lt;intptr_t&gt; handler_pcos(nof_succs);
1917       // iterate through all successors
1918       for (int j = 0; j &lt; nof_succs; j++) {
1919         Block* s = block-&gt;_succs[j];
1920         bool found_p = false;
1921         for (uint k = 1; k &lt; s-&gt;num_preds(); k++) {
1922           Node* pk = s-&gt;pred(k);
1923           if (pk-&gt;is_CatchProj() &amp;&amp; pk-&gt;in(0) == n) {
1924             const CatchProjNode* p = pk-&gt;as_CatchProj();
1925             found_p = true;
1926             // add the corresponding handler bci &amp; pco information
1927             if (p-&gt;_con != CatchProjNode::fall_through_index) {
1928               // p leads to an exception handler (and is not fall through)
<span class="line-modified">1929               assert(s == C-&gt;cfg()-&gt;get_block(s-&gt;_pre_order), &quot;bad numbering&quot;);</span>
1930               // no duplicates, please
1931               if (!handler_bcis.contains(p-&gt;handler_bci())) {
1932                 uint block_num = s-&gt;non_connector()-&gt;_pre_order;
1933                 handler_bcis.append(p-&gt;handler_bci());
1934                 handler_pcos.append(blk_labels[block_num].loc_pos());
1935               }
1936             }
1937           }
1938         }
1939         assert(found_p, &quot;no matching predecessor found&quot;);
1940         // Note:  Due to empty block removal, one block may have
1941         // several CatchProj inputs, from the same Catch.
1942       }
1943 
1944       // Set the offset of the return from the call
1945       assert(handler_bcis.find(-1) != -1, &quot;must have default handler&quot;);
1946       _handler_table.add_subtable(call_return, &amp;handler_bcis, NULL, &amp;handler_pcos);
1947       continue;
1948     }
1949 
</pre>
<hr />
<pre>
1981           _available(arena),
1982           _reg_node(arena),
1983           _pinch_free_list(arena),
1984           _next_node(NULL),
1985           _bundle_instr_count(0),
1986           _bundle_cycle_number(0),
1987           _bundle_use(0, 0, resource_count, &amp;_bundle_use_elements[0])
1988 #ifndef PRODUCT
1989         , _branches(0)
1990         , _unconditional_delays(0)
1991 #endif
1992 {
1993   // Create a MachNopNode
1994   _nop = new MachNopNode();
1995 
1996   // Now that the nops are in the array, save the count
1997   // (but allow entries for the nops)
1998   _node_bundling_limit = compile.unique();
1999   uint node_max = _regalloc-&gt;node_regs_max_index();
2000 
<span class="line-modified">2001   compile.output()-&gt;set_node_bundling_limit(_node_bundling_limit);</span>
2002 
2003   // This one is persistent within the Compile class
2004   _node_bundling_base = NEW_ARENA_ARRAY(compile.comp_arena(), Bundle, node_max);
2005 
2006   // Allocate space for fixed-size arrays
2007   _node_latency    = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
2008   _uses            = NEW_ARENA_ARRAY(arena, short,          node_max);
2009   _current_latency = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
2010 
2011   // Clear the arrays
2012   for (uint i = 0; i &lt; node_max; i++) {
2013     ::new (&amp;_node_bundling_base[i]) Bundle();
2014   }
2015   memset(_node_latency,       0, node_max * sizeof(unsigned short));
2016   memset(_uses,               0, node_max * sizeof(short));
2017   memset(_current_latency,    0, node_max * sizeof(unsigned short));
2018 
2019   // Clear the bundling information
2020   memcpy(_bundle_use_elements, Pipeline_Use::elaborated_elements, sizeof(Pipeline_Use::elaborated_elements));
2021 
</pre>
<hr />
<pre>
2057 
2058   // Update the bundle record
2059   if (_bundle_instr_count &gt; 0) {
2060     bundle-&gt;set_instr_count(_bundle_instr_count);
2061     bundle-&gt;set_resources_used(_bundle_use.resourcesUsed());
2062 
2063     _bundle_cycle_number += 1;
2064   }
2065 
2066   // Clear the bundling information
2067   _bundle_instr_count = 0;
2068   _bundle_use.reset();
2069 
2070   memcpy(_bundle_use_elements,
2071          Pipeline_Use::elaborated_elements,
2072          sizeof(Pipeline_Use::elaborated_elements));
2073 }
2074 
2075 // Perform instruction scheduling and bundling over the sequence of
2076 // instructions in backwards order.
<span class="line-modified">2077 void PhaseOutput::ScheduleAndBundle() {</span>
2078 
2079   // Don&#39;t optimize this if it isn&#39;t a method
<span class="line-modified">2080   if (!C-&gt;method())</span>
2081     return;
2082 
2083   // Don&#39;t optimize this if scheduling is disabled
<span class="line-modified">2084   if (!C-&gt;do_scheduling())</span>
2085     return;
2086 
2087   // Scheduling code works only with pairs (16 bytes) maximum.
<span class="line-modified">2088   if (C-&gt;max_vector_size() &gt; 16)</span>
2089     return;
2090 
<span class="line-modified">2091   Compile::TracePhase tp(&quot;isched&quot;, &amp;timers[_t_instrSched]);</span>
2092 
2093   // Create a data structure for all the scheduling information
<span class="line-modified">2094   Scheduling scheduling(Thread::current()-&gt;resource_area(), *C);</span>
2095 
2096   // Walk backwards over each basic block, computing the needed alignment
2097   // Walk over all the basic blocks
2098   scheduling.DoScheduling();
2099 
2100 #ifndef PRODUCT
<span class="line-modified">2101   if (C-&gt;trace_opto_output()) {</span>
2102     tty-&gt;print(&quot;\n---- After ScheduleAndBundle ----\n&quot;);
<span class="line-modified">2103     for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {</span>
2104       tty-&gt;print(&quot;\nBB#%03d:\n&quot;, i);
<span class="line-modified">2105       Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
2106       for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {
2107         Node* n = block-&gt;get_node(j);
<span class="line-modified">2108         OptoReg::Name reg = C-&gt;regalloc()-&gt;get_reg_first(n);</span>
2109         tty-&gt;print(&quot; %-6s &quot;, reg &gt;= 0 &amp;&amp; reg &lt; REG_COUNT ? Matcher::regName[reg] : &quot;&quot;);
2110         n-&gt;dump();
2111       }
2112     }
2113   }
2114 #endif
2115 }
2116 
2117 // Compute the latency of all the instructions.  This is fairly simple,
2118 // because we already have a legal ordering.  Walk over the instructions
2119 // from first to last, and compute the latency of the instruction based
2120 // on the latency of the preceding instruction(s).
2121 void Scheduling::ComputeLocalLatenciesForward(const Block *bb) {
2122 #ifndef PRODUCT
2123   if (_cfg-&gt;C-&gt;trace_opto_output())
2124     tty-&gt;print(&quot;# -&gt; ComputeLocalLatenciesForward\n&quot;);
2125 #endif
2126 
2127   // Walk over all the schedulable instructions
2128   for( uint j=_bb_start; j &lt; _bb_end; j++ ) {
</pre>
<hr />
<pre>
2630 #endif
2631   }
2632 
2633 #ifndef PRODUCT
2634   if (_cfg-&gt;C-&gt;trace_opto_output())
2635     tty-&gt;print(&quot;# &lt;- ComputeUseCount\n&quot;);
2636 #endif
2637 }
2638 
2639 // This routine performs scheduling on each basic block in reverse order,
2640 // using instruction latencies and taking into account function unit
2641 // availability.
2642 void Scheduling::DoScheduling() {
2643 #ifndef PRODUCT
2644   if (_cfg-&gt;C-&gt;trace_opto_output())
2645     tty-&gt;print(&quot;# -&gt; DoScheduling\n&quot;);
2646 #endif
2647 
2648   Block *succ_bb = NULL;
2649   Block *bb;
<span class="line-added">2650   Compile* C = Compile::current();</span>
2651 
2652   // Walk over all the basic blocks in reverse order
2653   for (int i = _cfg-&gt;number_of_blocks() - 1; i &gt;= 0; succ_bb = bb, i--) {
2654     bb = _cfg-&gt;get_block(i);
2655 
2656 #ifndef PRODUCT
2657     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2658       tty-&gt;print(&quot;#  Schedule BB#%03d (initial)\n&quot;, i);
2659       for (uint j = 0; j &lt; bb-&gt;number_of_nodes(); j++) {
2660         bb-&gt;get_node(j)-&gt;dump();
2661       }
2662     }
2663 #endif
2664 
2665     // On the head node, skip processing
2666     if (bb == _cfg-&gt;get_root_block()) {
2667       continue;
2668     }
2669 
2670     // Skip empty, connector blocks
</pre>
<hr />
<pre>
2718         (last-&gt;is_Mach() &amp;&amp; last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Halt) ) {
2719       // There might be a prior call.  Skip it.
2720       while (_bb_start &lt; _bb_end &amp;&amp; bb-&gt;get_node(--_bb_end)-&gt;is_MachProj());
2721     } else if( last-&gt;is_MachNullCheck() ) {
2722       // Backup so the last null-checked memory instruction is
2723       // outside the schedulable range. Skip over the nullcheck,
2724       // projection, and the memory nodes.
2725       Node *mem = last-&gt;in(1);
2726       do {
2727         _bb_end--;
2728       } while (mem != bb-&gt;get_node(_bb_end));
2729     } else {
2730       // Set _bb_end to point after last schedulable inst.
2731       _bb_end++;
2732     }
2733 
2734     assert( _bb_start &lt;= _bb_end, &quot;inverted block ends&quot; );
2735 
2736     // Compute the register antidependencies for the basic block
2737     ComputeRegisterAntidependencies(bb);
<span class="line-modified">2738     if (C-&gt;failing())  return;  // too many D-U pinch points</span>
2739 
2740     // Compute intra-bb latencies for the nodes
2741     ComputeLocalLatenciesForward(bb);
2742 
2743     // Compute the usage within the block, and set the list of all nodes
2744     // in the block that have no uses within the block.
2745     ComputeUseCount(bb);
2746 
2747     // Schedule the remaining instructions in the block
2748     while ( _available.size() &gt; 0 ) {
2749       Node *n = ChooseNodeToBundle();
2750       guarantee(n != NULL, &quot;no nodes available&quot;);
2751       AddNodeToBundle(n,bb);
2752     }
2753 
2754     assert( _scheduled.size() == _bb_end - _bb_start, &quot;wrong number of instructions&quot; );
2755 #ifdef ASSERT
2756     for( uint l = _bb_start; l &lt; _bb_end; l++ ) {
2757       Node *n = bb-&gt;get_node(l);
2758       uint m;
</pre>
<hr />
<pre>
2778           if (bundle-&gt;instr_count() &gt; 0 || bundle-&gt;flags() &gt; 0) {
2779             tty-&gt;print(&quot;*** Bundle: &quot;);
2780             bundle-&gt;dump();
2781           }
2782           n-&gt;dump();
2783         }
2784       }
2785     }
2786 #endif
2787 #ifdef ASSERT
2788     verify_good_schedule(bb,&quot;after block local scheduling&quot;);
2789 #endif
2790   }
2791 
2792 #ifndef PRODUCT
2793   if (_cfg-&gt;C-&gt;trace_opto_output())
2794     tty-&gt;print(&quot;# &lt;- DoScheduling\n&quot;);
2795 #endif
2796 
2797   // Record final node-bundling array location
<span class="line-modified">2798   _regalloc-&gt;C-&gt;output()-&gt;set_node_bundling_base(_node_bundling_base);</span>
2799 
2800 } // end DoScheduling
2801 
2802 // Verify that no live-range used in the block is killed in the block by a
2803 // wrong DEF.  This doesn&#39;t verify live-ranges that span blocks.
2804 
2805 // Check for edge existence.  Used to avoid adding redundant precedence edges.
2806 static bool edge_from_to( Node *from, Node *to ) {
2807   for( uint i=0; i&lt;from-&gt;len(); i++ )
2808     if( from-&gt;in(i) == to )
2809       return true;
2810   return false;
2811 }
2812 
2813 #ifdef ASSERT
2814 void Scheduling::verify_do_def( Node *n, OptoReg::Name def, const char *msg ) {
2815   // Check for bad kills
2816   if( OptoReg::is_valid(def) ) { // Ignore stores &amp; control flow
2817     Node *prior_use = _reg_node[def];
2818     if( prior_use &amp;&amp; !edge_from_to(prior_use,n) ) {
</pre>
<hr />
<pre>
2885     from-&gt;add_prec(to);
2886 }
2887 
2888 void Scheduling::anti_do_def( Block *b, Node *def, OptoReg::Name def_reg, int is_def ) {
2889   if( !OptoReg::is_valid(def_reg) ) // Ignore stores &amp; control flow
2890     return;
2891 
2892   Node *pinch = _reg_node[def_reg]; // Get pinch point
2893   if ((pinch == NULL) || _cfg-&gt;get_block_for_node(pinch) != b || // No pinch-point yet?
2894       is_def ) {    // Check for a true def (not a kill)
2895     _reg_node.map(def_reg,def); // Record def/kill as the optimistic pinch-point
2896     return;
2897   }
2898 
2899   Node *kill = def;             // Rename &#39;def&#39; to more descriptive &#39;kill&#39;
2900   debug_only( def = (Node*)((intptr_t)0xdeadbeef); )
2901 
2902   // After some number of kills there _may_ be a later def
2903   Node *later_def = NULL;
2904 
<span class="line-added">2905   Compile* C = Compile::current();</span>
<span class="line-added">2906 </span>
2907   // Finding a kill requires a real pinch-point.
2908   // Check for not already having a pinch-point.
2909   // Pinch points are Op_Node&#39;s.
2910   if( pinch-&gt;Opcode() != Op_Node ) { // Or later-def/kill as pinch-point?
2911     later_def = pinch;            // Must be def/kill as optimistic pinch-point
2912     if ( _pinch_free_list.size() &gt; 0) {
2913       pinch = _pinch_free_list.pop();
2914     } else {
2915       pinch = new Node(1); // Pinch point to-be
2916     }
2917     if (pinch-&gt;_idx &gt;= _regalloc-&gt;node_regs_max_index()) {
2918       _cfg-&gt;C-&gt;record_method_not_compilable(&quot;too many D-U pinch points&quot;);
2919       return;
2920     }
2921     _cfg-&gt;map_node_to_block(pinch, b);      // Pretend it&#39;s valid in this block (lazy init)
2922     _reg_node.map(def_reg,pinch); // Record pinch-point
<span class="line-modified">2923     //regalloc()-&gt;set_bad(pinch-&gt;_idx); // Already initialized this way.</span>
2924     if( later_def-&gt;outcnt() == 0 || later_def-&gt;ideal_reg() == MachProjNode::fat_proj ) { // Distinguish def from kill
<span class="line-modified">2925       pinch-&gt;init_req(0, C-&gt;top());     // set not NULL for the next call</span>
2926       add_prec_edge_from_to(later_def,pinch); // Add edge from kill to pinch
2927       later_def = NULL;           // and no later def
2928     }
2929     pinch-&gt;set_req(0,later_def);  // Hook later def so we can find it
2930   } else {                        // Else have valid pinch point
2931     if( pinch-&gt;in(0) )            // If there is a later-def
2932       later_def = pinch-&gt;in(0);   // Get it
2933   }
2934 
2935   // Add output-dependence edge from later def to kill
2936   if( later_def )               // If there is some original def
2937     add_prec_edge_from_to(later_def,kill); // Add edge from def to kill
2938 
2939   // See if current kill is also a use, and so is forced to be the pinch-point.
2940   if( pinch-&gt;Opcode() == Op_Node ) {
2941     Node *uses = kill-&gt;is_Proj() ? kill-&gt;in(0) : kill;
2942     for( uint i=1; i&lt;uses-&gt;req(); i++ ) {
2943       if( _regalloc-&gt;get_reg_first(uses-&gt;in(i)) == def_reg ||
2944           _regalloc-&gt;get_reg_second(uses-&gt;in(i)) == def_reg ) {
2945         // Yes, found a use/kill pinch-point
</pre>
<hr />
<pre>
3208                _total_branches, _total_unconditional_delays);
3209     if (_total_branches &gt; 0)
3210       tty-&gt;print(&quot;, for %.2f%%&quot;,
3211                  ((double)_total_unconditional_delays) / ((double)_total_branches) * 100.0);
3212     tty-&gt;print(&quot;\n&quot;);
3213   }
3214 
3215   uint total_instructions = 0, total_bundles = 0;
3216 
3217   for (uint i = 1; i &lt;= Pipeline::_max_instrs_per_cycle; i++) {
3218     uint bundle_count   = _total_instructions_per_bundle[i];
3219     total_instructions += bundle_count * i;
3220     total_bundles      += bundle_count;
3221   }
3222 
3223   if (total_bundles &gt; 0)
3224     tty-&gt;print(&quot;Average ILP (excluding nops) is %.2f\n&quot;,
3225                ((double)total_instructions) / ((double)total_bundles));
3226 }
3227 #endif
<span class="line-added">3228 </span>
<span class="line-added">3229 //-----------------------init_scratch_buffer_blob------------------------------</span>
<span class="line-added">3230 // Construct a temporary BufferBlob and cache it for this compile.</span>
<span class="line-added">3231 void PhaseOutput::init_scratch_buffer_blob(int const_size) {</span>
<span class="line-added">3232   // If there is already a scratch buffer blob allocated and the</span>
<span class="line-added">3233   // constant section is big enough, use it.  Otherwise free the</span>
<span class="line-added">3234   // current and allocate a new one.</span>
<span class="line-added">3235   BufferBlob* blob = scratch_buffer_blob();</span>
<span class="line-added">3236   if ((blob != NULL) &amp;&amp; (const_size &lt;= _scratch_const_size)) {</span>
<span class="line-added">3237     // Use the current blob.</span>
<span class="line-added">3238   } else {</span>
<span class="line-added">3239     if (blob != NULL) {</span>
<span class="line-added">3240       BufferBlob::free(blob);</span>
<span class="line-added">3241     }</span>
<span class="line-added">3242 </span>
<span class="line-added">3243     ResourceMark rm;</span>
<span class="line-added">3244     _scratch_const_size = const_size;</span>
<span class="line-added">3245     int size = C2Compiler::initial_code_buffer_size(const_size);</span>
<span class="line-added">3246 #ifdef ASSERT</span>
<span class="line-added">3247     if (C-&gt;has_scalarized_args()) {</span>
<span class="line-added">3248       // Oop verification for loading object fields from scalarized value types in the new entry point requires lots of space</span>
<span class="line-added">3249       size += 5120;</span>
<span class="line-added">3250     }</span>
<span class="line-added">3251 #endif</span>
<span class="line-added">3252     blob = BufferBlob::create(&quot;Compile::scratch_buffer&quot;, size);</span>
<span class="line-added">3253     // Record the buffer blob for next time.</span>
<span class="line-added">3254     set_scratch_buffer_blob(blob);</span>
<span class="line-added">3255     // Have we run out of code space?</span>
<span class="line-added">3256     if (scratch_buffer_blob() == NULL) {</span>
<span class="line-added">3257       // Let CompilerBroker disable further compilations.</span>
<span class="line-added">3258       C-&gt;record_failure(&quot;Not enough space for scratch buffer in CodeCache&quot;);</span>
<span class="line-added">3259       return;</span>
<span class="line-added">3260     }</span>
<span class="line-added">3261   }</span>
<span class="line-added">3262 </span>
<span class="line-added">3263   // Initialize the relocation buffers</span>
<span class="line-added">3264   relocInfo* locs_buf = (relocInfo*) blob-&gt;content_end() - MAX_locs_size;</span>
<span class="line-added">3265   set_scratch_locs_memory(locs_buf);</span>
<span class="line-added">3266 }</span>
<span class="line-added">3267 </span>
<span class="line-added">3268 </span>
<span class="line-added">3269 //-----------------------scratch_emit_size-------------------------------------</span>
<span class="line-added">3270 // Helper function that computes size by emitting code</span>
<span class="line-added">3271 uint PhaseOutput::scratch_emit_size(const Node* n) {</span>
<span class="line-added">3272   // Start scratch_emit_size section.</span>
<span class="line-added">3273   set_in_scratch_emit_size(true);</span>
<span class="line-added">3274 </span>
<span class="line-added">3275   // Emit into a trash buffer and count bytes emitted.</span>
<span class="line-added">3276   // This is a pretty expensive way to compute a size,</span>
<span class="line-added">3277   // but it works well enough if seldom used.</span>
<span class="line-added">3278   // All common fixed-size instructions are given a size</span>
<span class="line-added">3279   // method by the AD file.</span>
<span class="line-added">3280   // Note that the scratch buffer blob and locs memory are</span>
<span class="line-added">3281   // allocated at the beginning of the compile task, and</span>
<span class="line-added">3282   // may be shared by several calls to scratch_emit_size.</span>
<span class="line-added">3283   // The allocation of the scratch buffer blob is particularly</span>
<span class="line-added">3284   // expensive, since it has to grab the code cache lock.</span>
<span class="line-added">3285   BufferBlob* blob = this-&gt;scratch_buffer_blob();</span>
<span class="line-added">3286   assert(blob != NULL, &quot;Initialize BufferBlob at start&quot;);</span>
<span class="line-added">3287   assert(blob-&gt;size() &gt; MAX_inst_size, &quot;sanity&quot;);</span>
<span class="line-added">3288   relocInfo* locs_buf = scratch_locs_memory();</span>
<span class="line-added">3289   address blob_begin = blob-&gt;content_begin();</span>
<span class="line-added">3290   address blob_end   = (address)locs_buf;</span>
<span class="line-added">3291   assert(blob-&gt;contains(blob_end), &quot;sanity&quot;);</span>
<span class="line-added">3292   CodeBuffer buf(blob_begin, blob_end - blob_begin);</span>
<span class="line-added">3293   buf.initialize_consts_size(_scratch_const_size);</span>
<span class="line-added">3294   buf.initialize_stubs_size(MAX_stubs_size);</span>
<span class="line-added">3295   assert(locs_buf != NULL, &quot;sanity&quot;);</span>
<span class="line-added">3296   int lsize = MAX_locs_size / 3;</span>
<span class="line-added">3297   buf.consts()-&gt;initialize_shared_locs(&amp;locs_buf[lsize * 0], lsize);</span>
<span class="line-added">3298   buf.insts()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 1], lsize);</span>
<span class="line-added">3299   buf.stubs()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 2], lsize);</span>
<span class="line-added">3300   // Mark as scratch buffer.</span>
<span class="line-added">3301   buf.consts()-&gt;set_scratch_emit();</span>
<span class="line-added">3302   buf.insts()-&gt;set_scratch_emit();</span>
<span class="line-added">3303   buf.stubs()-&gt;set_scratch_emit();</span>
<span class="line-added">3304 </span>
<span class="line-added">3305   // Do the emission.</span>
<span class="line-added">3306 </span>
<span class="line-added">3307   Label fakeL; // Fake label for branch instructions.</span>
<span class="line-added">3308   Label*   saveL = NULL;</span>
<span class="line-added">3309   uint save_bnum = 0;</span>
<span class="line-added">3310   bool is_branch = n-&gt;is_MachBranch();</span>
<span class="line-added">3311   if (is_branch) {</span>
<span class="line-added">3312     MacroAssembler masm(&amp;buf);</span>
<span class="line-added">3313     masm.bind(fakeL);</span>
<span class="line-added">3314     n-&gt;as_MachBranch()-&gt;save_label(&amp;saveL, &amp;save_bnum);</span>
<span class="line-added">3315     n-&gt;as_MachBranch()-&gt;label_set(&amp;fakeL, 0);</span>
<span class="line-added">3316   } else if (n-&gt;is_MachProlog()) {</span>
<span class="line-added">3317     saveL = ((MachPrologNode*)n)-&gt;_verified_entry;</span>
<span class="line-added">3318     ((MachPrologNode*)n)-&gt;_verified_entry = &amp;fakeL;</span>
<span class="line-added">3319   } else if (n-&gt;is_MachVEP()) {</span>
<span class="line-added">3320     saveL = ((MachVEPNode*)n)-&gt;_verified_entry;</span>
<span class="line-added">3321     ((MachVEPNode*)n)-&gt;_verified_entry = &amp;fakeL;</span>
<span class="line-added">3322   }</span>
<span class="line-added">3323   n-&gt;emit(buf, C-&gt;regalloc());</span>
<span class="line-added">3324 </span>
<span class="line-added">3325   // Emitting into the scratch buffer should not fail</span>
<span class="line-added">3326   assert (!C-&gt;failing(), &quot;Must not have pending failure. Reason is: %s&quot;, C-&gt;failure_reason());</span>
<span class="line-added">3327 </span>
<span class="line-added">3328   // Restore label.</span>
<span class="line-added">3329   if (is_branch) {</span>
<span class="line-added">3330     n-&gt;as_MachBranch()-&gt;label_set(saveL, save_bnum);</span>
<span class="line-added">3331   } else if (n-&gt;is_MachProlog()) {</span>
<span class="line-added">3332     ((MachPrologNode*)n)-&gt;_verified_entry = saveL;</span>
<span class="line-added">3333   } else if (n-&gt;is_MachVEP()) {</span>
<span class="line-added">3334     ((MachVEPNode*)n)-&gt;_verified_entry = saveL;</span>
<span class="line-added">3335   }</span>
<span class="line-added">3336 </span>
<span class="line-added">3337   // End scratch_emit_size section.</span>
<span class="line-added">3338   set_in_scratch_emit_size(false);</span>
<span class="line-added">3339 </span>
<span class="line-added">3340   return buf.insts_size();</span>
<span class="line-added">3341 }</span>
<span class="line-added">3342 </span>
<span class="line-added">3343 void PhaseOutput::install() {</span>
<span class="line-added">3344   if (C-&gt;stub_function() != NULL) {</span>
<span class="line-added">3345     install_stub(C-&gt;stub_name(),</span>
<span class="line-added">3346                  C-&gt;save_argument_registers());</span>
<span class="line-added">3347   } else {</span>
<span class="line-added">3348     install_code(C-&gt;method(),</span>
<span class="line-added">3349                  C-&gt;entry_bci(),</span>
<span class="line-added">3350                  CompileBroker::compiler2(),</span>
<span class="line-added">3351                  C-&gt;has_unsafe_access(),</span>
<span class="line-added">3352                  SharedRuntime::is_wide_vector(C-&gt;max_vector_size()),</span>
<span class="line-added">3353                  C-&gt;rtm_state());</span>
<span class="line-added">3354   }</span>
<span class="line-added">3355 }</span>
<span class="line-added">3356 </span>
<span class="line-added">3357 void PhaseOutput::install_code(ciMethod*         target,</span>
<span class="line-added">3358                                int               entry_bci,</span>
<span class="line-added">3359                                AbstractCompiler* compiler,</span>
<span class="line-added">3360                                bool              has_unsafe_access,</span>
<span class="line-added">3361                                bool              has_wide_vectors,</span>
<span class="line-added">3362                                RTMState          rtm_state) {</span>
<span class="line-added">3363   // Check if we want to skip execution of all compiled code.</span>
<span class="line-added">3364   {</span>
<span class="line-added">3365 #ifndef PRODUCT</span>
<span class="line-added">3366     if (OptoNoExecute) {</span>
<span class="line-added">3367       C-&gt;record_method_not_compilable(&quot;+OptoNoExecute&quot;);  // Flag as failed</span>
<span class="line-added">3368       return;</span>
<span class="line-added">3369     }</span>
<span class="line-added">3370 #endif</span>
<span class="line-added">3371     Compile::TracePhase tp(&quot;install_code&quot;, &amp;timers[_t_registerMethod]);</span>
<span class="line-added">3372 </span>
<span class="line-added">3373     if (C-&gt;is_osr_compilation()) {</span>
<span class="line-added">3374       _code_offsets.set_value(CodeOffsets::Verified_Entry, 0);</span>
<span class="line-added">3375       _code_offsets.set_value(CodeOffsets::OSR_Entry, _first_block_size);</span>
<span class="line-added">3376     } else {</span>
<span class="line-added">3377       _code_offsets.set_value(CodeOffsets::Verified_Entry, _first_block_size);</span>
<span class="line-added">3378       if (_code_offsets.value(CodeOffsets::Verified_Value_Entry) == -1) {</span>
<span class="line-added">3379         _code_offsets.set_value(CodeOffsets::Verified_Value_Entry, _first_block_size);</span>
<span class="line-added">3380       }</span>
<span class="line-added">3381       if (_code_offsets.value(CodeOffsets::Verified_Value_Entry_RO) == -1) {</span>
<span class="line-added">3382         _code_offsets.set_value(CodeOffsets::Verified_Value_Entry_RO, _first_block_size);</span>
<span class="line-added">3383       }</span>
<span class="line-added">3384       if (_code_offsets.value(CodeOffsets::Entry) == -1) {</span>
<span class="line-added">3385         _code_offsets.set_value(CodeOffsets::Entry, _first_block_size);</span>
<span class="line-added">3386       }</span>
<span class="line-added">3387       _code_offsets.set_value(CodeOffsets::OSR_Entry, 0);</span>
<span class="line-added">3388     }</span>
<span class="line-added">3389 </span>
<span class="line-added">3390     C-&gt;env()-&gt;register_method(target,</span>
<span class="line-added">3391                               entry_bci,</span>
<span class="line-added">3392                               &amp;_code_offsets,</span>
<span class="line-added">3393                               _orig_pc_slot_offset_in_bytes,</span>
<span class="line-added">3394                               code_buffer(),</span>
<span class="line-added">3395                               frame_size_in_words(),</span>
<span class="line-added">3396                               _oop_map_set,</span>
<span class="line-added">3397                               &amp;_handler_table,</span>
<span class="line-added">3398                               &amp;_inc_table,</span>
<span class="line-added">3399                               compiler,</span>
<span class="line-added">3400                               has_unsafe_access,</span>
<span class="line-added">3401                               SharedRuntime::is_wide_vector(C-&gt;max_vector_size()),</span>
<span class="line-added">3402                               C-&gt;rtm_state());</span>
<span class="line-added">3403 </span>
<span class="line-added">3404     if (C-&gt;log() != NULL) { // Print code cache state into compiler log</span>
<span class="line-added">3405       C-&gt;log()-&gt;code_cache_state();</span>
<span class="line-added">3406     }</span>
<span class="line-added">3407   }</span>
<span class="line-added">3408 }</span>
<span class="line-added">3409 void PhaseOutput::install_stub(const char* stub_name,</span>
<span class="line-added">3410                                bool        caller_must_gc_arguments) {</span>
<span class="line-added">3411   // Entry point will be accessed using stub_entry_point();</span>
<span class="line-added">3412   if (code_buffer() == NULL) {</span>
<span class="line-added">3413     Matcher::soft_match_failure();</span>
<span class="line-added">3414   } else {</span>
<span class="line-added">3415     if (PrintAssembly &amp;&amp; (WizardMode || Verbose))</span>
<span class="line-added">3416       tty-&gt;print_cr(&quot;### Stub::%s&quot;, stub_name);</span>
<span class="line-added">3417 </span>
<span class="line-added">3418     if (!C-&gt;failing()) {</span>
<span class="line-added">3419       assert(C-&gt;fixed_slots() == 0, &quot;no fixed slots used for runtime stubs&quot;);</span>
<span class="line-added">3420 </span>
<span class="line-added">3421       // Make the NMethod</span>
<span class="line-added">3422       // For now we mark the frame as never safe for profile stackwalking</span>
<span class="line-added">3423       RuntimeStub *rs = RuntimeStub::new_runtime_stub(stub_name,</span>
<span class="line-added">3424                                                       code_buffer(),</span>
<span class="line-added">3425                                                       CodeOffsets::frame_never_safe,</span>
<span class="line-added">3426                                                       // _code_offsets.value(CodeOffsets::Frame_Complete),</span>
<span class="line-added">3427                                                       frame_size_in_words(),</span>
<span class="line-added">3428                                                       oop_map_set(),</span>
<span class="line-added">3429                                                       caller_must_gc_arguments);</span>
<span class="line-added">3430       assert(rs != NULL &amp;&amp; rs-&gt;is_runtime_stub(), &quot;sanity check&quot;);</span>
<span class="line-added">3431 </span>
<span class="line-added">3432       C-&gt;set_stub_entry_point(rs-&gt;entry_point());</span>
<span class="line-added">3433     }</span>
<span class="line-added">3434   }</span>
<span class="line-added">3435 }</span>
<span class="line-added">3436 </span>
<span class="line-added">3437 // Support for bundling info</span>
<span class="line-added">3438 Bundle* PhaseOutput::node_bundling(const Node *n) {</span>
<span class="line-added">3439   assert(valid_bundle_info(n), &quot;oob&quot;);</span>
<span class="line-added">3440   return &amp;_node_bundling_base[n-&gt;_idx];</span>
<span class="line-added">3441 }</span>
<span class="line-added">3442 </span>
<span class="line-added">3443 bool PhaseOutput::valid_bundle_info(const Node *n) {</span>
<span class="line-added">3444   return (_node_bundling_limit &gt; n-&gt;_idx);</span>
<span class="line-added">3445 }</span>
<span class="line-added">3446 </span>
<span class="line-added">3447 //------------------------------frame_size_in_words-----------------------------</span>
<span class="line-added">3448 // frame_slots in units of words</span>
<span class="line-added">3449 int PhaseOutput::frame_size_in_words() const {</span>
<span class="line-added">3450   // shift is 0 in LP32 and 1 in LP64</span>
<span class="line-added">3451   const int shift = (LogBytesPerWord - LogBytesPerInt);</span>
<span class="line-added">3452   int words = _frame_slots &gt;&gt; shift;</span>
<span class="line-added">3453   assert( words &lt;&lt; shift == _frame_slots, &quot;frame size must be properly aligned in LP64&quot; );</span>
<span class="line-added">3454   return words;</span>
<span class="line-added">3455 }</span>
<span class="line-added">3456 </span>
<span class="line-added">3457 // To bang the stack of this compiled method we use the stack size</span>
<span class="line-added">3458 // that the interpreter would need in case of a deoptimization. This</span>
<span class="line-added">3459 // removes the need to bang the stack in the deoptimization blob which</span>
<span class="line-added">3460 // in turn simplifies stack overflow handling.</span>
<span class="line-added">3461 int PhaseOutput::bang_size_in_bytes() const {</span>
<span class="line-added">3462   return MAX2(frame_size_in_bytes() + os::extra_bang_size_in_bytes(), C-&gt;interpreter_frame_size());</span>
<span class="line-added">3463 }</span>
<span class="line-added">3464 </span>
<span class="line-added">3465 //------------------------------dump_asm---------------------------------------</span>
<span class="line-added">3466 // Dump formatted assembly</span>
<span class="line-added">3467 #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="line-added">3468 void PhaseOutput::dump_asm_on(outputStream* st, int* pcs, uint pc_limit) {</span>
<span class="line-added">3469 </span>
<span class="line-added">3470   int pc_digits = 3; // #chars required for pc</span>
<span class="line-added">3471   int sb_chars  = 3; // #chars for &quot;start bundle&quot; indicator</span>
<span class="line-added">3472   int tab_size  = 8;</span>
<span class="line-added">3473   if (pcs != NULL) {</span>
<span class="line-added">3474     int max_pc = 0;</span>
<span class="line-added">3475     for (uint i = 0; i &lt; pc_limit; i++) {</span>
<span class="line-added">3476       max_pc = (max_pc &lt; pcs[i]) ? pcs[i] : max_pc;</span>
<span class="line-added">3477     }</span>
<span class="line-added">3478     pc_digits  = ((max_pc &lt; 4096) ? 3 : ((max_pc &lt; 65536) ? 4 : ((max_pc &lt; 65536*256) ? 6 : 8))); // #chars required for pc</span>
<span class="line-added">3479   }</span>
<span class="line-added">3480   int prefix_len = ((pc_digits + sb_chars + tab_size - 1)/tab_size)*tab_size;</span>
<span class="line-added">3481 </span>
<span class="line-added">3482   bool cut_short = false;</span>
<span class="line-added">3483   st-&gt;print_cr(&quot;#&quot;);</span>
<span class="line-added">3484   st-&gt;print(&quot;#  &quot;);  C-&gt;tf()-&gt;dump_on(st);  st-&gt;cr();</span>
<span class="line-added">3485   st-&gt;print_cr(&quot;#&quot;);</span>
<span class="line-added">3486 </span>
<span class="line-added">3487   // For all blocks</span>
<span class="line-added">3488   int pc = 0x0;                 // Program counter</span>
<span class="line-added">3489   char starts_bundle = &#39; &#39;;</span>
<span class="line-added">3490   C-&gt;regalloc()-&gt;dump_frame();</span>
<span class="line-added">3491 </span>
<span class="line-added">3492   Node *n = NULL;</span>
<span class="line-added">3493   for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {</span>
<span class="line-added">3494     if (VMThread::should_terminate()) {</span>
<span class="line-added">3495       cut_short = true;</span>
<span class="line-added">3496       break;</span>
<span class="line-added">3497     }</span>
<span class="line-added">3498     Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
<span class="line-added">3499     if (block-&gt;is_connector() &amp;&amp; !Verbose) {</span>
<span class="line-added">3500       continue;</span>
<span class="line-added">3501     }</span>
<span class="line-added">3502     n = block-&gt;head();</span>
<span class="line-added">3503     if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-added">3504       pc = pcs[n-&gt;_idx];</span>
<span class="line-added">3505       st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-added">3506     }</span>
<span class="line-added">3507     st-&gt;fill_to(prefix_len);</span>
<span class="line-added">3508     block-&gt;dump_head(C-&gt;cfg(), st);</span>
<span class="line-added">3509     if (block-&gt;is_connector()) {</span>
<span class="line-added">3510       st-&gt;fill_to(prefix_len);</span>
<span class="line-added">3511       st-&gt;print_cr(&quot;# Empty connector block&quot;);</span>
<span class="line-added">3512     } else if (block-&gt;num_preds() == 2 &amp;&amp; block-&gt;pred(1)-&gt;is_CatchProj() &amp;&amp; block-&gt;pred(1)-&gt;as_CatchProj()-&gt;_con == CatchProjNode::fall_through_index) {</span>
<span class="line-added">3513       st-&gt;fill_to(prefix_len);</span>
<span class="line-added">3514       st-&gt;print_cr(&quot;# Block is sole successor of call&quot;);</span>
<span class="line-added">3515     }</span>
<span class="line-added">3516 </span>
<span class="line-added">3517     // For all instructions</span>
<span class="line-added">3518     Node *delay = NULL;</span>
<span class="line-added">3519     for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {</span>
<span class="line-added">3520       if (VMThread::should_terminate()) {</span>
<span class="line-added">3521         cut_short = true;</span>
<span class="line-added">3522         break;</span>
<span class="line-added">3523       }</span>
<span class="line-added">3524       n = block-&gt;get_node(j);</span>
<span class="line-added">3525       if (valid_bundle_info(n)) {</span>
<span class="line-added">3526         Bundle* bundle = node_bundling(n);</span>
<span class="line-added">3527         if (bundle-&gt;used_in_unconditional_delay()) {</span>
<span class="line-added">3528           delay = n;</span>
<span class="line-added">3529           continue;</span>
<span class="line-added">3530         }</span>
<span class="line-added">3531         if (bundle-&gt;starts_bundle()) {</span>
<span class="line-added">3532           starts_bundle = &#39;+&#39;;</span>
<span class="line-added">3533         }</span>
<span class="line-added">3534       }</span>
<span class="line-added">3535 </span>
<span class="line-added">3536       if (WizardMode) {</span>
<span class="line-added">3537         n-&gt;dump();</span>
<span class="line-added">3538       }</span>
<span class="line-added">3539 </span>
<span class="line-added">3540       if( !n-&gt;is_Region() &amp;&amp;    // Dont print in the Assembly</span>
<span class="line-added">3541           !n-&gt;is_Phi() &amp;&amp;       // a few noisely useless nodes</span>
<span class="line-added">3542           !n-&gt;is_Proj() &amp;&amp;</span>
<span class="line-added">3543           !n-&gt;is_MachTemp() &amp;&amp;</span>
<span class="line-added">3544           !n-&gt;is_SafePointScalarObject() &amp;&amp;</span>
<span class="line-added">3545           !n-&gt;is_Catch() &amp;&amp;     // Would be nice to print exception table targets</span>
<span class="line-added">3546           !n-&gt;is_MergeMem() &amp;&amp;  // Not very interesting</span>
<span class="line-added">3547           !n-&gt;is_top() &amp;&amp;       // Debug info table constants</span>
<span class="line-added">3548           !(n-&gt;is_Con() &amp;&amp; !n-&gt;is_Mach())// Debug info table constants</span>
<span class="line-added">3549           ) {</span>
<span class="line-added">3550         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-added">3551           pc = pcs[n-&gt;_idx];</span>
<span class="line-added">3552           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-added">3553         } else {</span>
<span class="line-added">3554           st-&gt;fill_to(pc_digits);</span>
<span class="line-added">3555         }</span>
<span class="line-added">3556         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="line-added">3557         starts_bundle = &#39; &#39;;</span>
<span class="line-added">3558         st-&gt;fill_to(prefix_len);</span>
<span class="line-added">3559         n-&gt;format(C-&gt;regalloc(), st);</span>
<span class="line-added">3560         st-&gt;cr();</span>
<span class="line-added">3561       }</span>
<span class="line-added">3562 </span>
<span class="line-added">3563       // If we have an instruction with a delay slot, and have seen a delay,</span>
<span class="line-added">3564       // then back up and print it</span>
<span class="line-added">3565       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;use_unconditional_delay()) {</span>
<span class="line-added">3566         // Coverity finding - Explicit null dereferenced.</span>
<span class="line-added">3567         guarantee(delay != NULL, &quot;no unconditional delay instruction&quot;);</span>
<span class="line-added">3568         if (WizardMode) delay-&gt;dump();</span>
<span class="line-added">3569 </span>
<span class="line-added">3570         if (node_bundling(delay)-&gt;starts_bundle())</span>
<span class="line-added">3571           starts_bundle = &#39;+&#39;;</span>
<span class="line-added">3572         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-added">3573           pc = pcs[n-&gt;_idx];</span>
<span class="line-added">3574           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-added">3575         } else {</span>
<span class="line-added">3576           st-&gt;fill_to(pc_digits);</span>
<span class="line-added">3577         }</span>
<span class="line-added">3578         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="line-added">3579         starts_bundle = &#39; &#39;;</span>
<span class="line-added">3580         st-&gt;fill_to(prefix_len);</span>
<span class="line-added">3581         delay-&gt;format(C-&gt;regalloc(), st);</span>
<span class="line-added">3582         st-&gt;cr();</span>
<span class="line-added">3583         delay = NULL;</span>
<span class="line-added">3584       }</span>
<span class="line-added">3585 </span>
<span class="line-added">3586       // Dump the exception table as well</span>
<span class="line-added">3587       if( n-&gt;is_Catch() &amp;&amp; (Verbose || WizardMode) ) {</span>
<span class="line-added">3588         // Print the exception table for this offset</span>
<span class="line-added">3589         _handler_table.print_subtable_for(pc);</span>
<span class="line-added">3590       }</span>
<span class="line-added">3591       st-&gt;bol(); // Make sure we start on a new line</span>
<span class="line-added">3592     }</span>
<span class="line-added">3593     st-&gt;cr(); // one empty line between blocks</span>
<span class="line-added">3594     assert(cut_short || delay == NULL, &quot;no unconditional delay branch&quot;);</span>
<span class="line-added">3595   } // End of per-block dump</span>
<span class="line-added">3596 </span>
<span class="line-added">3597   if (cut_short)  st-&gt;print_cr(&quot;*** disassembly is cut short ***&quot;);</span>
<span class="line-added">3598 }</span>
<span class="line-added">3599 #endif</span>
<span class="line-added">3600 </span>
<span class="line-added">3601 #ifndef PRODUCT</span>
<span class="line-added">3602 void PhaseOutput::print_statistics() {</span>
<span class="line-added">3603   Scheduling::print_statistics();</span>
<span class="line-added">3604 }</span>
<span class="line-added">3605 #endif</span>
</pre>
</td>
</tr>
</table>
<center><a href="node.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="output.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
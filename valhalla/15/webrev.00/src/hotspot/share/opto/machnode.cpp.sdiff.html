<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/machnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="loopnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="machnode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/machnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/collectedHeap.hpp&quot;
 27 #include &quot;memory/universe.hpp&quot;
 28 #include &quot;oops/compressedOops.hpp&quot;
 29 #include &quot;opto/machnode.hpp&quot;

 30 #include &quot;opto/regalloc.hpp&quot;
 31 #include &quot;utilities/vmError.hpp&quot;
 32 
 33 //=============================================================================
 34 // Return the value requested
 35 // result register lookup, corresponding to int_format
 36 int MachOper::reg(PhaseRegAlloc *ra_, const Node *node) const {
 37   return (int)ra_-&gt;get_encode(node);
 38 }
 39 // input register lookup, corresponding to ext_format
 40 int MachOper::reg(PhaseRegAlloc *ra_, const Node *node, int idx) const {
 41   return (int)(ra_-&gt;get_encode(node-&gt;in(idx)));
 42 }
 43 intptr_t  MachOper::constant() const { return 0x00; }
 44 relocInfo::relocType MachOper::constant_reloc() const { return relocInfo::none; }
 45 jdouble MachOper::constantD() const { ShouldNotReachHere(); return 0.0; }
 46 jfloat  MachOper::constantF() const { ShouldNotReachHere(); return 0.0; }
 47 jlong   MachOper::constantL() const { ShouldNotReachHere(); return CONST64(0) ; }
 48 TypeOopPtr *MachOper::oop() const { return NULL; }
 49 int MachOper::ccode() const { return 0x00; }
</pre>
<hr />
<pre>
137   ShouldNotCallThis();
138 }
139 
140 //---------------------------postalloc_expand----------------------------------
141 // Expand node after register allocation.
142 void MachNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {}
143 
144 //------------------------------size-------------------------------------------
145 // Size of instruction in bytes
146 uint MachNode::size(PhaseRegAlloc *ra_) const {
147   // If a virtual was not defined for this specific instruction,
148   // Call the helper which finds the size by emitting the bits.
149   return MachNode::emit_size(ra_);
150 }
151 
152 //------------------------------size-------------------------------------------
153 // Helper function that computes size by emitting code
154 uint MachNode::emit_size(PhaseRegAlloc *ra_) const {
155   // Emit into a trash buffer and count bytes emitted.
156   assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
<span class="line-modified">157   return ra_-&gt;C-&gt;scratch_emit_size(this);</span>
158 }
159 
160 
161 
162 //------------------------------hash-------------------------------------------
163 uint MachNode::hash() const {
164   uint no = num_opnds();
165   uint sum = rule();
166   for( uint i=0; i&lt;no; i++ )
167     sum += _opnds[i]-&gt;hash();
168   return sum+Node::hash();
169 }
170 
171 //-----------------------------cmp---------------------------------------------
172 bool MachNode::cmp( const Node &amp;node ) const {
173   MachNode&amp; n = *((Node&amp;)node).as_Mach();
174   uint no = num_opnds();
175   if( no != n.num_opnds() ) return false;
176   if( rule() != n.rule() ) return false;
177   for( uint i=0; i&lt;no; i++ )    // All operands must match
</pre>
<hr />
<pre>
540   format(ra, st); // access to virtual
541 }
542 #endif
543 
544 //=============================================================================
545 #ifndef PRODUCT
546 void MachTypeNode::dump_spec(outputStream *st) const {
547   if (_bottom_type != NULL) {
548     _bottom_type-&gt;dump_on(st);
549   } else {
550     st-&gt;print(&quot; NULL&quot;);
551   }
552 }
553 #endif
554 
555 
556 //=============================================================================
557 int MachConstantNode::constant_offset() {
558   // Bind the offset lazily.
559   if (_constant.offset() == -1) {
<span class="line-modified">560     Compile::ConstantTable&amp; constant_table = Compile::current()-&gt;constant_table();</span>
561     int offset = constant_table.find_offset(_constant);
562     // If called from Compile::scratch_emit_size return the
563     // pre-calculated offset.
564     // NOTE: If the AD file does some table base offset optimizations
565     // later the AD file needs to take care of this fact.
<span class="line-modified">566     if (Compile::current()-&gt;in_scratch_emit_size()) {</span>
567       return constant_table.calculate_table_base_offset() + offset;
568     }
569     _constant.set_offset(constant_table.table_base_offset() + offset);
570   }
571   return _constant.offset();
572 }
573 
574 int MachConstantNode::constant_offset_unchecked() const {
575   return _constant.offset();
576 }
577 
578 //=============================================================================
579 #ifndef PRODUCT
580 void MachNullCheckNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
581   int reg = ra_-&gt;get_reg_first(in(1)-&gt;in(_vidx));
582   st-&gt;print(&quot;%s %s&quot;, Name(), Matcher::regName[reg]);
583 }
584 #endif
585 
586 void MachNullCheckNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/collectedHeap.hpp&quot;
 27 #include &quot;memory/universe.hpp&quot;
 28 #include &quot;oops/compressedOops.hpp&quot;
 29 #include &quot;opto/machnode.hpp&quot;
<span class="line-added"> 30 #include &quot;opto/output.hpp&quot;</span>
 31 #include &quot;opto/regalloc.hpp&quot;
 32 #include &quot;utilities/vmError.hpp&quot;
 33 
 34 //=============================================================================
 35 // Return the value requested
 36 // result register lookup, corresponding to int_format
 37 int MachOper::reg(PhaseRegAlloc *ra_, const Node *node) const {
 38   return (int)ra_-&gt;get_encode(node);
 39 }
 40 // input register lookup, corresponding to ext_format
 41 int MachOper::reg(PhaseRegAlloc *ra_, const Node *node, int idx) const {
 42   return (int)(ra_-&gt;get_encode(node-&gt;in(idx)));
 43 }
 44 intptr_t  MachOper::constant() const { return 0x00; }
 45 relocInfo::relocType MachOper::constant_reloc() const { return relocInfo::none; }
 46 jdouble MachOper::constantD() const { ShouldNotReachHere(); return 0.0; }
 47 jfloat  MachOper::constantF() const { ShouldNotReachHere(); return 0.0; }
 48 jlong   MachOper::constantL() const { ShouldNotReachHere(); return CONST64(0) ; }
 49 TypeOopPtr *MachOper::oop() const { return NULL; }
 50 int MachOper::ccode() const { return 0x00; }
</pre>
<hr />
<pre>
138   ShouldNotCallThis();
139 }
140 
141 //---------------------------postalloc_expand----------------------------------
142 // Expand node after register allocation.
143 void MachNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {}
144 
145 //------------------------------size-------------------------------------------
146 // Size of instruction in bytes
147 uint MachNode::size(PhaseRegAlloc *ra_) const {
148   // If a virtual was not defined for this specific instruction,
149   // Call the helper which finds the size by emitting the bits.
150   return MachNode::emit_size(ra_);
151 }
152 
153 //------------------------------size-------------------------------------------
154 // Helper function that computes size by emitting code
155 uint MachNode::emit_size(PhaseRegAlloc *ra_) const {
156   // Emit into a trash buffer and count bytes emitted.
157   assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
<span class="line-modified">158   return ra_-&gt;C-&gt;output()-&gt;scratch_emit_size(this);</span>
159 }
160 
161 
162 
163 //------------------------------hash-------------------------------------------
164 uint MachNode::hash() const {
165   uint no = num_opnds();
166   uint sum = rule();
167   for( uint i=0; i&lt;no; i++ )
168     sum += _opnds[i]-&gt;hash();
169   return sum+Node::hash();
170 }
171 
172 //-----------------------------cmp---------------------------------------------
173 bool MachNode::cmp( const Node &amp;node ) const {
174   MachNode&amp; n = *((Node&amp;)node).as_Mach();
175   uint no = num_opnds();
176   if( no != n.num_opnds() ) return false;
177   if( rule() != n.rule() ) return false;
178   for( uint i=0; i&lt;no; i++ )    // All operands must match
</pre>
<hr />
<pre>
541   format(ra, st); // access to virtual
542 }
543 #endif
544 
545 //=============================================================================
546 #ifndef PRODUCT
547 void MachTypeNode::dump_spec(outputStream *st) const {
548   if (_bottom_type != NULL) {
549     _bottom_type-&gt;dump_on(st);
550   } else {
551     st-&gt;print(&quot; NULL&quot;);
552   }
553 }
554 #endif
555 
556 
557 //=============================================================================
558 int MachConstantNode::constant_offset() {
559   // Bind the offset lazily.
560   if (_constant.offset() == -1) {
<span class="line-modified">561     ConstantTable&amp; constant_table = Compile::current()-&gt;output()-&gt;constant_table();</span>
562     int offset = constant_table.find_offset(_constant);
563     // If called from Compile::scratch_emit_size return the
564     // pre-calculated offset.
565     // NOTE: If the AD file does some table base offset optimizations
566     // later the AD file needs to take care of this fact.
<span class="line-modified">567     if (Compile::current()-&gt;output()-&gt;in_scratch_emit_size()) {</span>
568       return constant_table.calculate_table_base_offset() + offset;
569     }
570     _constant.set_offset(constant_table.table_base_offset() + offset);
571   }
572   return _constant.offset();
573 }
574 
575 int MachConstantNode::constant_offset_unchecked() const {
576   return _constant.offset();
577 }
578 
579 //=============================================================================
580 #ifndef PRODUCT
581 void MachNullCheckNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
582   int reg = ra_-&gt;get_reg_first(in(1)-&gt;in(_vidx));
583   st-&gt;print(&quot;%s %s&quot;, Name(), Matcher::regName[reg]);
584 }
585 #endif
586 
587 void MachNullCheckNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
</pre>
</td>
</tr>
</table>
<center><a href="loopnode.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="machnode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
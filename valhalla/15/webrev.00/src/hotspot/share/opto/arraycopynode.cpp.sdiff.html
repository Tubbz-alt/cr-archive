<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/arraycopynode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../oops/oopsHierarchy.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="buildOopMap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/arraycopynode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 41     _arguments_validated(false),
 42     _src_type(TypeOopPtr::BOTTOM),
 43     _dest_type(TypeOopPtr::BOTTOM) {
 44   init_class_id(Class_ArrayCopy);
 45   init_flags(Flag_is_macro);
 46   C-&gt;add_macro_node(this);
 47 }
 48 
 49 uint ArrayCopyNode::size_of() const { return sizeof(*this); }
 50 
 51 ArrayCopyNode* ArrayCopyNode::make(GraphKit* kit, bool may_throw,
 52                                    Node* src, Node* src_offset,
 53                                    Node* dest, Node* dest_offset,
 54                                    Node* length,
 55                                    bool alloc_tightly_coupled,
 56                                    bool has_negative_length_guard,
 57                                    Node* src_klass, Node* dest_klass,
 58                                    Node* src_length, Node* dest_length) {
 59 
 60   ArrayCopyNode* ac = new ArrayCopyNode(kit-&gt;C, alloc_tightly_coupled, has_negative_length_guard);
<span class="line-modified"> 61   Node* prev_mem = kit-&gt;set_predefined_input_for_runtime_call(ac);</span>
 62 
 63   ac-&gt;init_req(ArrayCopyNode::Src, src);
 64   ac-&gt;init_req(ArrayCopyNode::SrcPos, src_offset);
 65   ac-&gt;init_req(ArrayCopyNode::Dest, dest);
 66   ac-&gt;init_req(ArrayCopyNode::DestPos, dest_offset);
 67   ac-&gt;init_req(ArrayCopyNode::Length, length);
 68   ac-&gt;init_req(ArrayCopyNode::SrcLen, src_length);
 69   ac-&gt;init_req(ArrayCopyNode::DestLen, dest_length);
 70   ac-&gt;init_req(ArrayCopyNode::SrcKlass, src_klass);
 71   ac-&gt;init_req(ArrayCopyNode::DestKlass, dest_klass);
 72 
 73   if (may_throw) {
 74     ac-&gt;set_req(TypeFunc::I_O , kit-&gt;i_o());
 75     kit-&gt;add_safepoint_edges(ac, false);
 76   }
 77 
 78   return ac;
 79 }
 80 
 81 void ArrayCopyNode::connect_outputs(GraphKit* kit) {
</pre>
<hr />
<pre>
164 }
165 
166 void ArrayCopyNode::store(BarrierSetC2* bs, PhaseGVN *phase, Node*&amp; ctl, MergeMemNode* mem, Node* adr, const TypePtr* adr_type, Node* val, const Type *type, BasicType bt) {
167   DecoratorSet decorators = C2_WRITE_ACCESS | IN_HEAP | C2_ARRAY_COPY;
168   if (is_alloc_tightly_coupled()) {
169     decorators |= C2_TIGHTLY_COUPLED_ALLOC;
170   }
171   C2AccessValuePtr addr(adr, adr_type);
172   C2AccessValue value(val, type);
173   C2OptAccess access(*phase, ctl, mem, decorators, bt, adr-&gt;in(AddPNode::Base), addr);
174   bs-&gt;store_at(access, value);
175   ctl = access.ctl();
176 }
177 
178 
179 Node* ArrayCopyNode::try_clone_instance(PhaseGVN *phase, bool can_reshape, int count) {
180   if (!is_clonebasic()) {
181     return NULL;
182   }
183 
<span class="line-modified">184   Node* src = in(ArrayCopyNode::Src);</span>
<span class="line-modified">185   Node* dest = in(ArrayCopyNode::Dest);</span>
186   Node* ctl = in(TypeFunc::Control);
187   Node* in_mem = in(TypeFunc::Memory);
188 
<span class="line-modified">189   const Type* src_type = phase-&gt;type(src);</span>
<span class="line-removed">190 </span>
<span class="line-removed">191   assert(src-&gt;is_AddP(), &quot;should be base + off&quot;);</span>
<span class="line-removed">192   assert(dest-&gt;is_AddP(), &quot;should be base + off&quot;);</span>
<span class="line-removed">193   Node* base_src = src-&gt;in(AddPNode::Base);</span>
<span class="line-removed">194   Node* base_dest = dest-&gt;in(AddPNode::Base);</span>
195 
196   MergeMemNode* mem = MergeMemNode::make(in_mem);
197 
198   const TypeInstPtr* inst_src = src_type-&gt;isa_instptr();
199 
200   if (inst_src == NULL) {
201     return NULL;
202   }
203 
204   if (!inst_src-&gt;klass_is_exact()) {
205     ciInstanceKlass* ik = inst_src-&gt;klass()-&gt;as_instance_klass();
206     assert(!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass(), &quot;inconsistent klass hierarchy&quot;);
207     phase-&gt;C-&gt;dependencies()-&gt;assert_leaf_type(ik);
208   }
209 
210   ciInstanceKlass* ik = inst_src-&gt;klass()-&gt;as_instance_klass();
211   assert(ik-&gt;nof_nonstatic_fields() &lt;= ArrayCopyLoadStoreMaxElem, &quot;too many fields&quot;);
212 
213   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
214   for (int i = 0; i &lt; count; i++) {
215     ciField* field = ik-&gt;nonstatic_field_at(i);
<span class="line-removed">216     int fieldidx = phase-&gt;C-&gt;alias_type(field)-&gt;index();</span>
217     const TypePtr* adr_type = phase-&gt;C-&gt;alias_type(field)-&gt;adr_type();
218     Node* off = phase-&gt;MakeConX(field-&gt;offset());
219     Node* next_src = phase-&gt;transform(new AddPNode(base_src,base_src,off));
220     Node* next_dest = phase-&gt;transform(new AddPNode(base_dest,base_dest,off));
221     BasicType bt = field-&gt;layout_type();
222 
223     const Type *type;
224     if (bt == T_OBJECT) {
225       if (!field-&gt;type()-&gt;is_loaded()) {
226         type = TypeInstPtr::BOTTOM;
227       } else {
228         ciType* field_klass = field-&gt;type();
229         type = TypeOopPtr::make_from_klass(field_klass-&gt;as_klass());
230       }
231     } else {
232       type = Type::get_const_basic_type(bt);
233     }
234 
235     Node* v = load(bs, phase, ctl, mem, next_src, adr_type, type, bt);
236     store(bs, phase, ctl, mem, next_dest, adr_type, v, type, bt);
237   }
238 
239   if (!finish_transform(phase, can_reshape, ctl, mem)) {
240     // Return NodeSentinel to indicate that the transform failed
241     return NodeSentinel;
242   }
243 
244   return mem;
245 }
246 
247 bool ArrayCopyNode::prepare_array_copy(PhaseGVN *phase, bool can_reshape,
248                                        Node*&amp; adr_src,
249                                        Node*&amp; base_src,
250                                        Node*&amp; adr_dest,
251                                        Node*&amp; base_dest,
252                                        BasicType&amp; copy_type,
253                                        const Type*&amp; value_type,
254                                        bool&amp; disjoint_bases) {
<span class="line-modified">255   Node* src = in(ArrayCopyNode::Src);</span>
<span class="line-modified">256   Node* dest = in(ArrayCopyNode::Dest);</span>
<span class="line-modified">257   const Type* src_type = phase-&gt;type(src);</span>
258   const TypeAryPtr* ary_src = src_type-&gt;isa_aryptr();
259 



260   if (is_arraycopy() || is_copyofrange() || is_copyof()) {
<span class="line-modified">261     const Type* dest_type = phase-&gt;type(dest);</span>
262     const TypeAryPtr* ary_dest = dest_type-&gt;isa_aryptr();
<span class="line-removed">263     Node* src_offset = in(ArrayCopyNode::SrcPos);</span>
<span class="line-removed">264     Node* dest_offset = in(ArrayCopyNode::DestPos);</span>
265 
266     // newly allocated object is guaranteed to not overlap with source object
267     disjoint_bases = is_alloc_tightly_coupled();
268 
269     if (ary_src  == NULL || ary_src-&gt;klass()  == NULL ||
270         ary_dest == NULL || ary_dest-&gt;klass() == NULL) {
271       // We don&#39;t know if arguments are arrays
272       return false;
273     }
274 
275     BasicType src_elem  = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
276     BasicType dest_elem = ary_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
277     if (src_elem  == T_ARRAY ||
278         (src_elem == T_VALUETYPE &amp;&amp; ary_src-&gt;klass()-&gt;is_obj_array_klass())) {
279       src_elem  = T_OBJECT;
280     }
281     if (dest_elem == T_ARRAY ||
282         (dest_elem == T_VALUETYPE &amp;&amp; ary_dest-&gt;klass()-&gt;is_obj_array_klass())) {
283       dest_elem = T_OBJECT;
284     }
285 
286     if (src_elem != dest_elem || dest_elem == T_VOID) {
287       // We don&#39;t know if arguments are arrays of the same type
288       return false;
289     }
290 
291     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
292     if (bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), dest_elem, false, BarrierSetC2::Optimization) ||
293         (src_elem == T_VALUETYPE &amp;&amp; ary_src-&gt;elem()-&gt;value_klass()-&gt;contains_oops() &amp;&amp;
294          bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), T_OBJECT, false, BarrierSetC2::Optimization))) {
295       // It&#39;s an object array copy but we can&#39;t emit the card marking that is needed
296       return false;
297     }
298 
299     value_type = ary_src-&gt;elem();
300 
<span class="line-removed">301     base_src = src;</span>
<span class="line-removed">302     base_dest = dest;</span>
<span class="line-removed">303 </span>
304     uint shift  = exact_log2(type2aelembytes(dest_elem));
305     if (dest_elem == T_VALUETYPE) {
306       ciValueArrayKlass* vak = ary_src-&gt;klass()-&gt;as_value_array_klass();
307       shift = vak-&gt;log2_element_size();
308     }
309     uint header = arrayOopDesc::base_offset_in_bytes(dest_elem);
310 
<span class="line-removed">311     adr_src = src;</span>
<span class="line-removed">312     adr_dest = dest;</span>
<span class="line-removed">313 </span>
314     src_offset = Compile::conv_I2X_index(phase, src_offset, ary_src-&gt;size());
315     dest_offset = Compile::conv_I2X_index(phase, dest_offset, ary_dest-&gt;size());
316     if (src_offset-&gt;is_top() || dest_offset-&gt;is_top()) {
317       // Offset is out of bounds (the ArrayCopyNode will be removed)
318       return false;
319     }
320 
<span class="line-modified">321     Node* src_scale = phase-&gt;transform(new LShiftXNode(src_offset, phase-&gt;intcon(shift)));</span>
322     Node* dest_scale = phase-&gt;transform(new LShiftXNode(dest_offset, phase-&gt;intcon(shift)));
323 
<span class="line-modified">324     adr_src = phase-&gt;transform(new AddPNode(base_src, adr_src, phase-&gt;MakeConX(header)));</span>
<span class="line-modified">325     adr_dest = phase-&gt;transform(new AddPNode(base_dest, adr_dest, phase-&gt;MakeConX(header)));</span>
326 
<span class="line-modified">327     adr_src = phase-&gt;transform(new AddPNode(base_src, adr_src, src_scale));</span>
<span class="line-modified">328     adr_dest = phase-&gt;transform(new AddPNode(base_dest, adr_dest, dest_scale));</span>
329 
330     copy_type = dest_elem;
331   } else {
332     assert(ary_src != NULL, &quot;should be a clone&quot;);
333     assert(is_clonebasic(), &quot;should be&quot;);
334 
335     disjoint_bases = true;
<span class="line-removed">336     assert(src-&gt;is_AddP(), &quot;should be base + off&quot;);</span>
<span class="line-removed">337     assert(dest-&gt;is_AddP(), &quot;should be base + off&quot;);</span>
<span class="line-removed">338     adr_src = src;</span>
<span class="line-removed">339     base_src = src-&gt;in(AddPNode::Base);</span>
<span class="line-removed">340     adr_dest = dest;</span>
<span class="line-removed">341     base_dest = dest-&gt;in(AddPNode::Base);</span>
<span class="line-removed">342 </span>
<span class="line-removed">343     assert(phase-&gt;type(src-&gt;in(AddPNode::Offset))-&gt;is_intptr_t()-&gt;get_con() == phase-&gt;type(dest-&gt;in(AddPNode::Offset))-&gt;is_intptr_t()-&gt;get_con(), &quot;same start offset?&quot;);</span>
344 
345     if (ary_src-&gt;elem()-&gt;make_oopptr() != NULL &amp;&amp;
346         ary_src-&gt;elem()-&gt;make_oopptr()-&gt;can_be_value_type()) {
347       return false;
348     }
349 



350     BasicType elem = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
351     if (elem == T_ARRAY ||
352         (elem == T_VALUETYPE &amp;&amp; ary_src-&gt;klass()-&gt;is_obj_array_klass())) {
353       elem = T_OBJECT;
354     }
355 
356     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
357     if (bs-&gt;array_copy_requires_gc_barriers(true, elem, true, BarrierSetC2::Optimization) ||
358         (elem == T_VALUETYPE &amp;&amp; ary_src-&gt;elem()-&gt;value_klass()-&gt;contains_oops() &amp;&amp;
359          bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Optimization))) {
360       return false;
361     }
362 
<span class="line-modified">363     int diff = arrayOopDesc::base_offset_in_bytes(elem) - phase-&gt;type(src-&gt;in(AddPNode::Offset))-&gt;is_intptr_t()-&gt;get_con();</span>





364     assert(diff &gt;= 0, &quot;clone should not start after 1st array element&quot;);
365     if (diff &gt; 0) {
366       adr_src = phase-&gt;transform(new AddPNode(base_src, adr_src, phase-&gt;MakeConX(diff)));
367       adr_dest = phase-&gt;transform(new AddPNode(base_dest, adr_dest, phase-&gt;MakeConX(diff)));
368     }
<span class="line-removed">369 </span>
370     copy_type = elem;
371     value_type = ary_src-&gt;elem();
372   }
373   return true;
374 }
375 
376 const TypeAryPtr* ArrayCopyNode::get_address_type(PhaseGVN* phase, const TypePtr* atp, Node* n) {
377   if (atp == TypeOopPtr::BOTTOM) {
378     atp = phase-&gt;type(n)-&gt;isa_ptr();
379   }
380   // adjust atp to be the correct array element address type
381   return atp-&gt;add_offset(Type::OffsetBot)-&gt;is_aryptr();
382 }
383 
384 void ArrayCopyNode::array_copy_test_overlap(GraphKit&amp; kit, bool disjoint_bases, int count, Node*&amp; backward_ctl) {
385   Node* ctl = kit.control();
386   if (!disjoint_bases &amp;&amp; count &gt; 1) {
387     PhaseGVN&amp; gvn = kit.gvn();
388     Node* src_offset = in(ArrayCopyNode::SrcPos);
389     Node* dest_offset = in(ArrayCopyNode::DestPos);
</pre>
<hr />
<pre>
573     return NULL;
574   }
575 
576   // See if it&#39;s a small array copy and we can inline it as
577   // loads/stores
578   // Here we can only do:
579   // - arraycopy if all arguments were validated before and we don&#39;t
580   // need card marking
581   // - clone for which we don&#39;t need to do card marking
582 
583   if (!is_clonebasic() &amp;&amp; !is_arraycopy_validated() &amp;&amp;
584       !is_copyofrange_validated() &amp;&amp; !is_copyof_validated()) {
585     return NULL;
586   }
587 
588   assert(in(TypeFunc::Control) != NULL &amp;&amp;
589          in(TypeFunc::Memory) != NULL &amp;&amp;
590          in(ArrayCopyNode::Src) != NULL &amp;&amp;
591          in(ArrayCopyNode::Dest) != NULL &amp;&amp;
592          in(ArrayCopyNode::Length) != NULL &amp;&amp;
<span class="line-modified">593          ((in(ArrayCopyNode::SrcPos) != NULL &amp;&amp; in(ArrayCopyNode::DestPos) != NULL) ||</span>
<span class="line-modified">594           is_clonebasic()), &quot;broken inputs&quot;);</span>
595 
596   if (in(TypeFunc::Control)-&gt;is_top() ||
597       in(TypeFunc::Memory)-&gt;is_top() ||
598       phase-&gt;type(in(ArrayCopyNode::Src)) == Type::TOP ||
599       phase-&gt;type(in(ArrayCopyNode::Dest)) == Type::TOP ||
600       (in(ArrayCopyNode::SrcPos) != NULL &amp;&amp; in(ArrayCopyNode::SrcPos)-&gt;is_top()) ||
601       (in(ArrayCopyNode::DestPos) != NULL &amp;&amp; in(ArrayCopyNode::DestPos)-&gt;is_top())) {
602     return NULL;
603   }
604 
605   int count = get_count(phase);
606 
607   if (count &lt; 0 || count &gt; ArrayCopyLoadStoreMaxElem) {
608     return NULL;
609   }
610 
611   Node* src = in(ArrayCopyNode::Src);
612   Node* dest = in(ArrayCopyNode::Dest);
613   const Type* src_type = phase-&gt;type(src);
614   const Type* dest_type = phase-&gt;type(dest);
</pre>
<hr />
<pre>
642   SafePointNode* new_map = NULL;
643   if (!is_clonebasic()) {
644     new_jvms = jvms()-&gt;clone_shallow(phase-&gt;C);
645     new_map = new SafePointNode(req(), new_jvms);
646     for (uint i = TypeFunc::FramePtr; i &lt; req(); i++) {
647       new_map-&gt;init_req(i, in(i));
648     }
649     new_jvms-&gt;set_map(new_map);
650   } else {
651     new_jvms = new (phase-&gt;C) JVMState(0);
652     new_map = new SafePointNode(TypeFunc::Parms, new_jvms);
653     new_jvms-&gt;set_map(new_map);
654   }
655   new_map-&gt;set_control(in(TypeFunc::Control));
656   new_map-&gt;set_memory(MergeMemNode::make(in(TypeFunc::Memory)));
657   new_map-&gt;set_i_o(in(TypeFunc::I_O));
658   phase-&gt;record_for_igvn(new_map);
659 
660   const TypeAryPtr* atp_src = get_address_type(phase, _src_type, src);
661   const TypeAryPtr* atp_dest = get_address_type(phase, _dest_type, dest);
<span class="line-removed">662   uint alias_idx_src = phase-&gt;C-&gt;get_alias_index(atp_src);</span>
<span class="line-removed">663   uint alias_idx_dest = phase-&gt;C-&gt;get_alias_index(atp_dest);</span>
664 
665   if (can_reshape) {
666     assert(!phase-&gt;is_IterGVN()-&gt;delay_transform(), &quot;cannot delay transforms&quot;);
667     phase-&gt;is_IterGVN()-&gt;set_delay_transform(true);
668   }
669 
670   GraphKit kit(new_jvms, phase);
671 
672   SafePointNode* backward_map = NULL;
673   SafePointNode* forward_map = NULL;
674   Node* backward_ctl = phase-&gt;C-&gt;top();
675 
676   array_copy_test_overlap(kit, disjoint_bases, count, backward_ctl);
677 
678   {
679     PreserveJVMState pjvms(&amp;kit);
680 
681     array_copy_forward(kit, can_reshape,
682                        atp_src, atp_dest,
683                        adr_src, base_src, adr_dest, base_dest,
</pre>
</td>
<td>
<hr />
<pre>
 41     _arguments_validated(false),
 42     _src_type(TypeOopPtr::BOTTOM),
 43     _dest_type(TypeOopPtr::BOTTOM) {
 44   init_class_id(Class_ArrayCopy);
 45   init_flags(Flag_is_macro);
 46   C-&gt;add_macro_node(this);
 47 }
 48 
 49 uint ArrayCopyNode::size_of() const { return sizeof(*this); }
 50 
 51 ArrayCopyNode* ArrayCopyNode::make(GraphKit* kit, bool may_throw,
 52                                    Node* src, Node* src_offset,
 53                                    Node* dest, Node* dest_offset,
 54                                    Node* length,
 55                                    bool alloc_tightly_coupled,
 56                                    bool has_negative_length_guard,
 57                                    Node* src_klass, Node* dest_klass,
 58                                    Node* src_length, Node* dest_length) {
 59 
 60   ArrayCopyNode* ac = new ArrayCopyNode(kit-&gt;C, alloc_tightly_coupled, has_negative_length_guard);
<span class="line-modified"> 61   kit-&gt;set_predefined_input_for_runtime_call(ac);</span>
 62 
 63   ac-&gt;init_req(ArrayCopyNode::Src, src);
 64   ac-&gt;init_req(ArrayCopyNode::SrcPos, src_offset);
 65   ac-&gt;init_req(ArrayCopyNode::Dest, dest);
 66   ac-&gt;init_req(ArrayCopyNode::DestPos, dest_offset);
 67   ac-&gt;init_req(ArrayCopyNode::Length, length);
 68   ac-&gt;init_req(ArrayCopyNode::SrcLen, src_length);
 69   ac-&gt;init_req(ArrayCopyNode::DestLen, dest_length);
 70   ac-&gt;init_req(ArrayCopyNode::SrcKlass, src_klass);
 71   ac-&gt;init_req(ArrayCopyNode::DestKlass, dest_klass);
 72 
 73   if (may_throw) {
 74     ac-&gt;set_req(TypeFunc::I_O , kit-&gt;i_o());
 75     kit-&gt;add_safepoint_edges(ac, false);
 76   }
 77 
 78   return ac;
 79 }
 80 
 81 void ArrayCopyNode::connect_outputs(GraphKit* kit) {
</pre>
<hr />
<pre>
164 }
165 
166 void ArrayCopyNode::store(BarrierSetC2* bs, PhaseGVN *phase, Node*&amp; ctl, MergeMemNode* mem, Node* adr, const TypePtr* adr_type, Node* val, const Type *type, BasicType bt) {
167   DecoratorSet decorators = C2_WRITE_ACCESS | IN_HEAP | C2_ARRAY_COPY;
168   if (is_alloc_tightly_coupled()) {
169     decorators |= C2_TIGHTLY_COUPLED_ALLOC;
170   }
171   C2AccessValuePtr addr(adr, adr_type);
172   C2AccessValue value(val, type);
173   C2OptAccess access(*phase, ctl, mem, decorators, bt, adr-&gt;in(AddPNode::Base), addr);
174   bs-&gt;store_at(access, value);
175   ctl = access.ctl();
176 }
177 
178 
179 Node* ArrayCopyNode::try_clone_instance(PhaseGVN *phase, bool can_reshape, int count) {
180   if (!is_clonebasic()) {
181     return NULL;
182   }
183 
<span class="line-modified">184   Node* base_src = in(ArrayCopyNode::Src);</span>
<span class="line-modified">185   Node* base_dest = in(ArrayCopyNode::Dest);</span>
186   Node* ctl = in(TypeFunc::Control);
187   Node* in_mem = in(TypeFunc::Memory);
188 
<span class="line-modified">189   const Type* src_type = phase-&gt;type(base_src);</span>





190 
191   MergeMemNode* mem = MergeMemNode::make(in_mem);
192 
193   const TypeInstPtr* inst_src = src_type-&gt;isa_instptr();
194 
195   if (inst_src == NULL) {
196     return NULL;
197   }
198 
199   if (!inst_src-&gt;klass_is_exact()) {
200     ciInstanceKlass* ik = inst_src-&gt;klass()-&gt;as_instance_klass();
201     assert(!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass(), &quot;inconsistent klass hierarchy&quot;);
202     phase-&gt;C-&gt;dependencies()-&gt;assert_leaf_type(ik);
203   }
204 
205   ciInstanceKlass* ik = inst_src-&gt;klass()-&gt;as_instance_klass();
206   assert(ik-&gt;nof_nonstatic_fields() &lt;= ArrayCopyLoadStoreMaxElem, &quot;too many fields&quot;);
207 
208   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
209   for (int i = 0; i &lt; count; i++) {
210     ciField* field = ik-&gt;nonstatic_field_at(i);

211     const TypePtr* adr_type = phase-&gt;C-&gt;alias_type(field)-&gt;adr_type();
212     Node* off = phase-&gt;MakeConX(field-&gt;offset());
213     Node* next_src = phase-&gt;transform(new AddPNode(base_src,base_src,off));
214     Node* next_dest = phase-&gt;transform(new AddPNode(base_dest,base_dest,off));
215     BasicType bt = field-&gt;layout_type();
216 
217     const Type *type;
218     if (bt == T_OBJECT) {
219       if (!field-&gt;type()-&gt;is_loaded()) {
220         type = TypeInstPtr::BOTTOM;
221       } else {
222         ciType* field_klass = field-&gt;type();
223         type = TypeOopPtr::make_from_klass(field_klass-&gt;as_klass());
224       }
225     } else {
226       type = Type::get_const_basic_type(bt);
227     }
228 
229     Node* v = load(bs, phase, ctl, mem, next_src, adr_type, type, bt);
230     store(bs, phase, ctl, mem, next_dest, adr_type, v, type, bt);
231   }
232 
233   if (!finish_transform(phase, can_reshape, ctl, mem)) {
234     // Return NodeSentinel to indicate that the transform failed
235     return NodeSentinel;
236   }
237 
238   return mem;
239 }
240 
241 bool ArrayCopyNode::prepare_array_copy(PhaseGVN *phase, bool can_reshape,
242                                        Node*&amp; adr_src,
243                                        Node*&amp; base_src,
244                                        Node*&amp; adr_dest,
245                                        Node*&amp; base_dest,
246                                        BasicType&amp; copy_type,
247                                        const Type*&amp; value_type,
248                                        bool&amp; disjoint_bases) {
<span class="line-modified">249   base_src = in(ArrayCopyNode::Src);</span>
<span class="line-modified">250   base_dest = in(ArrayCopyNode::Dest);</span>
<span class="line-modified">251   const Type* src_type = phase-&gt;type(base_src);</span>
252   const TypeAryPtr* ary_src = src_type-&gt;isa_aryptr();
253 
<span class="line-added">254   Node* src_offset = in(ArrayCopyNode::SrcPos);</span>
<span class="line-added">255   Node* dest_offset = in(ArrayCopyNode::DestPos);</span>
<span class="line-added">256 </span>
257   if (is_arraycopy() || is_copyofrange() || is_copyof()) {
<span class="line-modified">258     const Type* dest_type = phase-&gt;type(base_dest);</span>
259     const TypeAryPtr* ary_dest = dest_type-&gt;isa_aryptr();


260 
261     // newly allocated object is guaranteed to not overlap with source object
262     disjoint_bases = is_alloc_tightly_coupled();
263 
264     if (ary_src  == NULL || ary_src-&gt;klass()  == NULL ||
265         ary_dest == NULL || ary_dest-&gt;klass() == NULL) {
266       // We don&#39;t know if arguments are arrays
267       return false;
268     }
269 
270     BasicType src_elem  = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
271     BasicType dest_elem = ary_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
272     if (src_elem  == T_ARRAY ||
273         (src_elem == T_VALUETYPE &amp;&amp; ary_src-&gt;klass()-&gt;is_obj_array_klass())) {
274       src_elem  = T_OBJECT;
275     }
276     if (dest_elem == T_ARRAY ||
277         (dest_elem == T_VALUETYPE &amp;&amp; ary_dest-&gt;klass()-&gt;is_obj_array_klass())) {
278       dest_elem = T_OBJECT;
279     }
280 
281     if (src_elem != dest_elem || dest_elem == T_VOID) {
282       // We don&#39;t know if arguments are arrays of the same type
283       return false;
284     }
285 
286     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
287     if (bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), dest_elem, false, BarrierSetC2::Optimization) ||
288         (src_elem == T_VALUETYPE &amp;&amp; ary_src-&gt;elem()-&gt;value_klass()-&gt;contains_oops() &amp;&amp;
289          bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), T_OBJECT, false, BarrierSetC2::Optimization))) {
290       // It&#39;s an object array copy but we can&#39;t emit the card marking that is needed
291       return false;
292     }
293 
294     value_type = ary_src-&gt;elem();
295 



296     uint shift  = exact_log2(type2aelembytes(dest_elem));
297     if (dest_elem == T_VALUETYPE) {
298       ciValueArrayKlass* vak = ary_src-&gt;klass()-&gt;as_value_array_klass();
299       shift = vak-&gt;log2_element_size();
300     }
301     uint header = arrayOopDesc::base_offset_in_bytes(dest_elem);
302 



303     src_offset = Compile::conv_I2X_index(phase, src_offset, ary_src-&gt;size());
304     dest_offset = Compile::conv_I2X_index(phase, dest_offset, ary_dest-&gt;size());
305     if (src_offset-&gt;is_top() || dest_offset-&gt;is_top()) {
306       // Offset is out of bounds (the ArrayCopyNode will be removed)
307       return false;
308     }
309 
<span class="line-modified">310     Node* src_scale  = phase-&gt;transform(new LShiftXNode(src_offset, phase-&gt;intcon(shift)));</span>
311     Node* dest_scale = phase-&gt;transform(new LShiftXNode(dest_offset, phase-&gt;intcon(shift)));
312 
<span class="line-modified">313     adr_src          = phase-&gt;transform(new AddPNode(base_src, base_src, src_scale));</span>
<span class="line-modified">314     adr_dest         = phase-&gt;transform(new AddPNode(base_dest, base_dest, dest_scale));</span>
315 
<span class="line-modified">316     adr_src          = phase-&gt;transform(new AddPNode(base_src, adr_src, phase-&gt;MakeConX(header)));</span>
<span class="line-modified">317     adr_dest         = phase-&gt;transform(new AddPNode(base_dest, adr_dest, phase-&gt;MakeConX(header)));</span>
318 
319     copy_type = dest_elem;
320   } else {
321     assert(ary_src != NULL, &quot;should be a clone&quot;);
322     assert(is_clonebasic(), &quot;should be&quot;);
323 
324     disjoint_bases = true;








325 
326     if (ary_src-&gt;elem()-&gt;make_oopptr() != NULL &amp;&amp;
327         ary_src-&gt;elem()-&gt;make_oopptr()-&gt;can_be_value_type()) {
328       return false;
329     }
330 
<span class="line-added">331     adr_src  = phase-&gt;transform(new AddPNode(base_src, base_src, src_offset));</span>
<span class="line-added">332     adr_dest = phase-&gt;transform(new AddPNode(base_dest, base_dest, dest_offset));</span>
<span class="line-added">333 </span>
334     BasicType elem = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
335     if (elem == T_ARRAY ||
336         (elem == T_VALUETYPE &amp;&amp; ary_src-&gt;klass()-&gt;is_obj_array_klass())) {
337       elem = T_OBJECT;
338     }
339 
340     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
341     if (bs-&gt;array_copy_requires_gc_barriers(true, elem, true, BarrierSetC2::Optimization) ||
342         (elem == T_VALUETYPE &amp;&amp; ary_src-&gt;elem()-&gt;value_klass()-&gt;contains_oops() &amp;&amp;
343          bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Optimization))) {
344       return false;
345     }
346 
<span class="line-modified">347     // The address is offseted to an aligned address where a raw copy would start.</span>
<span class="line-added">348     // If the clone copy is decomposed into load-stores - the address is adjusted to</span>
<span class="line-added">349     // point at where the array starts.</span>
<span class="line-added">350     const Type* toff = phase-&gt;type(src_offset);</span>
<span class="line-added">351     int offset = toff-&gt;isa_long() ? (int) toff-&gt;is_long()-&gt;get_con() : (int) toff-&gt;is_int()-&gt;get_con();</span>
<span class="line-added">352     int diff = arrayOopDesc::base_offset_in_bytes(elem) - offset;</span>
353     assert(diff &gt;= 0, &quot;clone should not start after 1st array element&quot;);
354     if (diff &gt; 0) {
355       adr_src = phase-&gt;transform(new AddPNode(base_src, adr_src, phase-&gt;MakeConX(diff)));
356       adr_dest = phase-&gt;transform(new AddPNode(base_dest, adr_dest, phase-&gt;MakeConX(diff)));
357     }

358     copy_type = elem;
359     value_type = ary_src-&gt;elem();
360   }
361   return true;
362 }
363 
364 const TypeAryPtr* ArrayCopyNode::get_address_type(PhaseGVN* phase, const TypePtr* atp, Node* n) {
365   if (atp == TypeOopPtr::BOTTOM) {
366     atp = phase-&gt;type(n)-&gt;isa_ptr();
367   }
368   // adjust atp to be the correct array element address type
369   return atp-&gt;add_offset(Type::OffsetBot)-&gt;is_aryptr();
370 }
371 
372 void ArrayCopyNode::array_copy_test_overlap(GraphKit&amp; kit, bool disjoint_bases, int count, Node*&amp; backward_ctl) {
373   Node* ctl = kit.control();
374   if (!disjoint_bases &amp;&amp; count &gt; 1) {
375     PhaseGVN&amp; gvn = kit.gvn();
376     Node* src_offset = in(ArrayCopyNode::SrcPos);
377     Node* dest_offset = in(ArrayCopyNode::DestPos);
</pre>
<hr />
<pre>
561     return NULL;
562   }
563 
564   // See if it&#39;s a small array copy and we can inline it as
565   // loads/stores
566   // Here we can only do:
567   // - arraycopy if all arguments were validated before and we don&#39;t
568   // need card marking
569   // - clone for which we don&#39;t need to do card marking
570 
571   if (!is_clonebasic() &amp;&amp; !is_arraycopy_validated() &amp;&amp;
572       !is_copyofrange_validated() &amp;&amp; !is_copyof_validated()) {
573     return NULL;
574   }
575 
576   assert(in(TypeFunc::Control) != NULL &amp;&amp;
577          in(TypeFunc::Memory) != NULL &amp;&amp;
578          in(ArrayCopyNode::Src) != NULL &amp;&amp;
579          in(ArrayCopyNode::Dest) != NULL &amp;&amp;
580          in(ArrayCopyNode::Length) != NULL &amp;&amp;
<span class="line-modified">581          in(ArrayCopyNode::SrcPos) != NULL &amp;&amp;</span>
<span class="line-modified">582          in(ArrayCopyNode::DestPos) != NULL, &quot;broken inputs&quot;);</span>
583 
584   if (in(TypeFunc::Control)-&gt;is_top() ||
585       in(TypeFunc::Memory)-&gt;is_top() ||
586       phase-&gt;type(in(ArrayCopyNode::Src)) == Type::TOP ||
587       phase-&gt;type(in(ArrayCopyNode::Dest)) == Type::TOP ||
588       (in(ArrayCopyNode::SrcPos) != NULL &amp;&amp; in(ArrayCopyNode::SrcPos)-&gt;is_top()) ||
589       (in(ArrayCopyNode::DestPos) != NULL &amp;&amp; in(ArrayCopyNode::DestPos)-&gt;is_top())) {
590     return NULL;
591   }
592 
593   int count = get_count(phase);
594 
595   if (count &lt; 0 || count &gt; ArrayCopyLoadStoreMaxElem) {
596     return NULL;
597   }
598 
599   Node* src = in(ArrayCopyNode::Src);
600   Node* dest = in(ArrayCopyNode::Dest);
601   const Type* src_type = phase-&gt;type(src);
602   const Type* dest_type = phase-&gt;type(dest);
</pre>
<hr />
<pre>
630   SafePointNode* new_map = NULL;
631   if (!is_clonebasic()) {
632     new_jvms = jvms()-&gt;clone_shallow(phase-&gt;C);
633     new_map = new SafePointNode(req(), new_jvms);
634     for (uint i = TypeFunc::FramePtr; i &lt; req(); i++) {
635       new_map-&gt;init_req(i, in(i));
636     }
637     new_jvms-&gt;set_map(new_map);
638   } else {
639     new_jvms = new (phase-&gt;C) JVMState(0);
640     new_map = new SafePointNode(TypeFunc::Parms, new_jvms);
641     new_jvms-&gt;set_map(new_map);
642   }
643   new_map-&gt;set_control(in(TypeFunc::Control));
644   new_map-&gt;set_memory(MergeMemNode::make(in(TypeFunc::Memory)));
645   new_map-&gt;set_i_o(in(TypeFunc::I_O));
646   phase-&gt;record_for_igvn(new_map);
647 
648   const TypeAryPtr* atp_src = get_address_type(phase, _src_type, src);
649   const TypeAryPtr* atp_dest = get_address_type(phase, _dest_type, dest);


650 
651   if (can_reshape) {
652     assert(!phase-&gt;is_IterGVN()-&gt;delay_transform(), &quot;cannot delay transforms&quot;);
653     phase-&gt;is_IterGVN()-&gt;set_delay_transform(true);
654   }
655 
656   GraphKit kit(new_jvms, phase);
657 
658   SafePointNode* backward_map = NULL;
659   SafePointNode* forward_map = NULL;
660   Node* backward_ctl = phase-&gt;C-&gt;top();
661 
662   array_copy_test_overlap(kit, disjoint_bases, count, backward_ctl);
663 
664   {
665     PreserveJVMState pjvms(&amp;kit);
666 
667     array_copy_forward(kit, can_reshape,
668                        atp_src, atp_dest,
669                        adr_src, base_src, adr_dest, base_dest,
</pre>
</td>
</tr>
</table>
<center><a href="../oops/oopsHierarchy.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="buildOopMap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
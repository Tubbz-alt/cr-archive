<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/type.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="type.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vectornode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/type.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 177   virtual bool eq( const Type *t ) const;
 178 
 179   // Top-level hash-table of types
 180   static Dict *type_dict() {
 181     return Compile::current()-&gt;type_dict();
 182   }
 183 
 184   // DUAL operation: reflect around lattice centerline.  Used instead of
 185   // join to ensure my lattice is symmetric up and down.  Dual is computed
 186   // lazily, on demand, and cached in _dual.
 187   const Type *_dual;            // Cached dual value
 188   // Table for efficient dualing of base types
 189   static const TYPES dual_type[lastype];
 190 
 191 #ifdef ASSERT
 192   // One type is interface, the other is oop
 193   virtual bool interface_vs_oop_helper(const Type *t) const;
 194 #endif
 195 
 196   const Type *meet_helper(const Type *t, bool include_speculative) const;

 197 
 198 protected:
 199   // Each class of type is also identified by its base.
 200   const TYPES _base;            // Enum of Types type
 201 
 202   Type( TYPES t ) : _dual(NULL),  _base(t) {} // Simple types
 203   // ~Type();                   // Use fast deallocation
 204   const Type *hashcons();       // Hash-cons the type
 205   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 206   const Type *join_helper(const Type *t, bool include_speculative) const {
 207     return dual()-&gt;meet_helper(t-&gt;dual(), include_speculative)-&gt;dual();
 208   }
 209 
 210 public:
 211 
 212   inline void* operator new( size_t x ) throw() {
 213     Compile* compile = Compile::current();
 214     compile-&gt;set_type_last_size(x);
 215     return compile-&gt;type_arena()-&gt;Amalloc_D(x);
 216   }
</pre>
<hr />
<pre>
 465 
 466   static const Type* make_constant_from_array_element(ciArray* array,
 467                                                       int off,
 468                                                       int stable_dimension,
 469                                                       BasicType loadbt,
 470                                                       bool is_unsigned_load);
 471 
 472   // Speculative type helper methods. See TypePtr.
 473   virtual const TypePtr* speculative() const                                  { return NULL; }
 474   virtual ciKlass* speculative_type() const                                   { return NULL; }
 475   virtual ciKlass* speculative_type_not_null() const                          { return NULL; }
 476   virtual bool speculative_maybe_null() const                                 { return true; }
 477   virtual bool speculative_always_null() const                                { return true; }
 478   virtual const Type* remove_speculative() const                              { return this; }
 479   virtual const Type* cleanup_speculative() const                             { return this; }
 480   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return exact_kls != NULL; }
 481   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return ptr_kind == ProfileAlwaysNull || ptr_kind == ProfileNeverNull; }
 482   const Type* maybe_remove_speculative(bool include_speculative) const;
 483 
 484   virtual bool maybe_null() const { return true; }

 485 
 486 private:
 487   // support arrays
 488   static const Type*        _zero_type[T_CONFLICT+1];
 489   static const Type* _const_basic_type[T_CONFLICT+1];
 490 };
 491 
 492 //------------------------------TypeF------------------------------------------
 493 // Class of Float-Constant Types.
 494 class TypeF : public Type {
 495   TypeF( float f ) : Type(FloatCon), _f(f) {};
 496 public:
 497   virtual bool eq( const Type *t ) const;
 498   virtual int  hash() const;             // Type specific hashing
 499   virtual bool singleton(void) const;    // TRUE if type is a singleton
 500   virtual bool empty(void) const;        // TRUE if type is vacuous
 501 public:
 502   const float _f;               // Float constant
 503 
 504   static const TypeF *make(float f);
</pre>
<hr />
<pre>
1485   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const = 0;
1486   // Do not allow interface-vs.-noninterface joins to collapse to top.
1487   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1488 public:
1489   virtual bool eq( const Type *t ) const;
1490   virtual int  hash() const;             // Type specific hashing
1491   virtual bool singleton(void) const;    // TRUE if type is a singleton
1492 
1493   virtual const Type *xmeet( const Type *t ) const;
1494   virtual const Type *xdual() const;    // Compute dual right now.
1495 
1496   virtual intptr_t get_con() const;
1497 
1498   virtual bool empty(void) const;        // TRUE if type is vacuous
1499 
1500   // returns the equivalent ptr type for this compressed pointer
1501   const TypePtr *get_ptrtype() const {
1502     return _ptrtype;
1503   }
1504 




1505 #ifndef PRODUCT
1506   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1507 #endif
1508 };
1509 
1510 //------------------------------TypeNarrowOop----------------------------------
1511 // A compressed reference to some kind of Oop.  This type wraps around
1512 // a preexisting TypeOopPtr and forwards most of it&#39;s operations to
1513 // the underlying type.  It&#39;s only real purpose is to track the
1514 // oopness of the compressed oop value when we expose the conversion
1515 // between the normal and the compressed form.
1516 class TypeNarrowOop : public TypeNarrowPtr {
1517 protected:
1518   TypeNarrowOop( const TypePtr* ptrtype): TypeNarrowPtr(NarrowOop, ptrtype) {
1519   }
1520 
1521   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1522     return t-&gt;isa_narrowoop();
1523   }
1524 
</pre>
</td>
<td>
<hr />
<pre>
 177   virtual bool eq( const Type *t ) const;
 178 
 179   // Top-level hash-table of types
 180   static Dict *type_dict() {
 181     return Compile::current()-&gt;type_dict();
 182   }
 183 
 184   // DUAL operation: reflect around lattice centerline.  Used instead of
 185   // join to ensure my lattice is symmetric up and down.  Dual is computed
 186   // lazily, on demand, and cached in _dual.
 187   const Type *_dual;            // Cached dual value
 188   // Table for efficient dualing of base types
 189   static const TYPES dual_type[lastype];
 190 
 191 #ifdef ASSERT
 192   // One type is interface, the other is oop
 193   virtual bool interface_vs_oop_helper(const Type *t) const;
 194 #endif
 195 
 196   const Type *meet_helper(const Type *t, bool include_speculative) const;
<span class="line-added"> 197   void check_symmetrical(const Type *t, const Type *mt) const;</span>
 198 
 199 protected:
 200   // Each class of type is also identified by its base.
 201   const TYPES _base;            // Enum of Types type
 202 
 203   Type( TYPES t ) : _dual(NULL),  _base(t) {} // Simple types
 204   // ~Type();                   // Use fast deallocation
 205   const Type *hashcons();       // Hash-cons the type
 206   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
 207   const Type *join_helper(const Type *t, bool include_speculative) const {
 208     return dual()-&gt;meet_helper(t-&gt;dual(), include_speculative)-&gt;dual();
 209   }
 210 
 211 public:
 212 
 213   inline void* operator new( size_t x ) throw() {
 214     Compile* compile = Compile::current();
 215     compile-&gt;set_type_last_size(x);
 216     return compile-&gt;type_arena()-&gt;Amalloc_D(x);
 217   }
</pre>
<hr />
<pre>
 466 
 467   static const Type* make_constant_from_array_element(ciArray* array,
 468                                                       int off,
 469                                                       int stable_dimension,
 470                                                       BasicType loadbt,
 471                                                       bool is_unsigned_load);
 472 
 473   // Speculative type helper methods. See TypePtr.
 474   virtual const TypePtr* speculative() const                                  { return NULL; }
 475   virtual ciKlass* speculative_type() const                                   { return NULL; }
 476   virtual ciKlass* speculative_type_not_null() const                          { return NULL; }
 477   virtual bool speculative_maybe_null() const                                 { return true; }
 478   virtual bool speculative_always_null() const                                { return true; }
 479   virtual const Type* remove_speculative() const                              { return this; }
 480   virtual const Type* cleanup_speculative() const                             { return this; }
 481   virtual bool would_improve_type(ciKlass* exact_kls, int inline_depth) const { return exact_kls != NULL; }
 482   virtual bool would_improve_ptr(ProfilePtrKind ptr_kind) const { return ptr_kind == ProfileAlwaysNull || ptr_kind == ProfileNeverNull; }
 483   const Type* maybe_remove_speculative(bool include_speculative) const;
 484 
 485   virtual bool maybe_null() const { return true; }
<span class="line-added"> 486   virtual bool is_known_instance() const { return false; }</span>
 487 
 488 private:
 489   // support arrays
 490   static const Type*        _zero_type[T_CONFLICT+1];
 491   static const Type* _const_basic_type[T_CONFLICT+1];
 492 };
 493 
 494 //------------------------------TypeF------------------------------------------
 495 // Class of Float-Constant Types.
 496 class TypeF : public Type {
 497   TypeF( float f ) : Type(FloatCon), _f(f) {};
 498 public:
 499   virtual bool eq( const Type *t ) const;
 500   virtual int  hash() const;             // Type specific hashing
 501   virtual bool singleton(void) const;    // TRUE if type is a singleton
 502   virtual bool empty(void) const;        // TRUE if type is vacuous
 503 public:
 504   const float _f;               // Float constant
 505 
 506   static const TypeF *make(float f);
</pre>
<hr />
<pre>
1487   virtual const TypeNarrowPtr *make_hash_same_narrowptr(const TypePtr *t) const = 0;
1488   // Do not allow interface-vs.-noninterface joins to collapse to top.
1489   virtual const Type *filter_helper(const Type *kills, bool include_speculative) const;
1490 public:
1491   virtual bool eq( const Type *t ) const;
1492   virtual int  hash() const;             // Type specific hashing
1493   virtual bool singleton(void) const;    // TRUE if type is a singleton
1494 
1495   virtual const Type *xmeet( const Type *t ) const;
1496   virtual const Type *xdual() const;    // Compute dual right now.
1497 
1498   virtual intptr_t get_con() const;
1499 
1500   virtual bool empty(void) const;        // TRUE if type is vacuous
1501 
1502   // returns the equivalent ptr type for this compressed pointer
1503   const TypePtr *get_ptrtype() const {
1504     return _ptrtype;
1505   }
1506 
<span class="line-added">1507   bool is_known_instance() const {</span>
<span class="line-added">1508     return _ptrtype-&gt;is_known_instance();</span>
<span class="line-added">1509   }</span>
<span class="line-added">1510 </span>
1511 #ifndef PRODUCT
1512   virtual void dump2( Dict &amp;d, uint depth, outputStream *st ) const;
1513 #endif
1514 };
1515 
1516 //------------------------------TypeNarrowOop----------------------------------
1517 // A compressed reference to some kind of Oop.  This type wraps around
1518 // a preexisting TypeOopPtr and forwards most of it&#39;s operations to
1519 // the underlying type.  It&#39;s only real purpose is to track the
1520 // oopness of the compressed oop value when we expose the conversion
1521 // between the normal and the compressed form.
1522 class TypeNarrowOop : public TypeNarrowPtr {
1523 protected:
1524   TypeNarrowOop( const TypePtr* ptrtype): TypeNarrowPtr(NarrowOop, ptrtype) {
1525   }
1526 
1527   virtual const TypeNarrowPtr *isa_same_narrowptr(const Type *t) const {
1528     return t-&gt;isa_narrowoop();
1529   }
1530 
</pre>
</td>
</tr>
</table>
<center><a href="type.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vectornode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
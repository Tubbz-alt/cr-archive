<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/compile.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classes.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 249,11 ***</span>
    { ttyLocker ttyl;
      if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;opto&#39;&quot;);
      Parse::print_statistics();
      PhaseCCP::print_statistics();
      PhaseRegAlloc::print_statistics();
<span class="line-modified">!     Scheduling::print_statistics();</span>
      PhasePeephole::print_statistics();
      PhaseIdealLoop::print_statistics();
      if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
    }
    if (_intrinsic_hist_flags[vmIntrinsics::_none] != 0) {
<span class="line-new-header">--- 249,11 ---</span>
    { ttyLocker ttyl;
      if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;opto&#39;&quot;);
      Parse::print_statistics();
      PhaseCCP::print_statistics();
      PhaseRegAlloc::print_statistics();
<span class="line-modified">!     PhaseOutput::print_statistics();</span>
      PhasePeephole::print_statistics();
      PhaseIdealLoop::print_statistics();
      if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
    }
    if (_intrinsic_hist_flags[vmIntrinsics::_none] != 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 261,21 ***</span>
      print_intrinsic_statistics();
    }
  }
  #endif //PRODUCT
  
<span class="line-removed">- // Support for bundling info</span>
<span class="line-removed">- Bundle* Compile::node_bundling(const Node *n) {</span>
<span class="line-removed">-   assert(valid_bundle_info(n), &quot;oob&quot;);</span>
<span class="line-removed">-   return &amp;_node_bundling_base[n-&gt;_idx];</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool Compile::valid_bundle_info(const Node *n) {</span>
<span class="line-removed">-   return (_node_bundling_limit &gt; n-&gt;_idx);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  void Compile::gvn_replace_by(Node* n, Node* nn) {
    for (DUIterator_Last imin, i = n-&gt;last_outs(imin); i &gt;= imin; ) {
      Node* use = n-&gt;last_out(i);
      bool is_in_table = initial_gvn()-&gt;hash_delete(use);
      uint uses_found = 0;
<span class="line-new-header">--- 261,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 426,28 ***</span>
    remove_useless_late_inlines(&amp;_boxing_late_inlines, useful);
    remove_useless_late_inlines(&amp;_late_inlines, useful);
    debug_only(verify_graph_edges(true/*check for no_dead_code*/);)
  }
  
<span class="line-removed">- //------------------------------frame_size_in_words-----------------------------</span>
<span class="line-removed">- // frame_slots in units of words</span>
<span class="line-removed">- int Compile::frame_size_in_words() const {</span>
<span class="line-removed">-   // shift is 0 in LP32 and 1 in LP64</span>
<span class="line-removed">-   const int shift = (LogBytesPerWord - LogBytesPerInt);</span>
<span class="line-removed">-   int words = _frame_slots &gt;&gt; shift;</span>
<span class="line-removed">-   assert( words &lt;&lt; shift == _frame_slots, &quot;frame size must be properly aligned in LP64&quot; );</span>
<span class="line-removed">-   return words;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // To bang the stack of this compiled method we use the stack size</span>
<span class="line-removed">- // that the interpreter would need in case of a deoptimization. This</span>
<span class="line-removed">- // removes the need to bang the stack in the deoptimization blob which</span>
<span class="line-removed">- // in turn simplifies stack overflow handling.</span>
<span class="line-removed">- int Compile::bang_size_in_bytes() const {</span>
<span class="line-removed">-   return MAX2(frame_size_in_bytes() + os::extra_bang_size_in_bytes(), _interpreter_frame_size);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // ============================================================================
  //------------------------------CompileWrapper---------------------------------
  class CompileWrapper : public StackObj {
    Compile *const _compile;
   public:
<span class="line-new-header">--- 415,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 471,18 ***</span>
    compile-&gt;set_last_tf(NULL, NULL);
    compile-&gt;set_indexSet_arena(NULL);
    compile-&gt;set_indexSet_free_block_list(NULL);
    compile-&gt;init_type_arena();
    Type::Initialize(compile);
<span class="line-removed">-   _compile-&gt;set_scratch_buffer_blob(NULL);</span>
    _compile-&gt;begin_method();
    _compile-&gt;clone_map().set_debug(_compile-&gt;has_method() &amp;&amp; _compile-&gt;directive()-&gt;CloneMapDebugOption);
  }
  CompileWrapper::~CompileWrapper() {
    _compile-&gt;end_method();
<span class="line-removed">-   if (_compile-&gt;scratch_buffer_blob() != NULL)</span>
<span class="line-removed">-     BufferBlob::free(_compile-&gt;scratch_buffer_blob());</span>
    _compile-&gt;env()-&gt;set_compiler_data(NULL);
  }
  
  
  //----------------------------print_compile_messages---------------------------
<span class="line-new-header">--- 442,15 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 523,136 ***</span>
      }
    }
  #endif
  }
  
<span class="line-removed">- </span>
<span class="line-removed">- //-----------------------init_scratch_buffer_blob------------------------------</span>
<span class="line-removed">- // Construct a temporary BufferBlob and cache it for this compile.</span>
<span class="line-removed">- void Compile::init_scratch_buffer_blob(int const_size) {</span>
<span class="line-removed">-   // If there is already a scratch buffer blob allocated and the</span>
<span class="line-removed">-   // constant section is big enough, use it.  Otherwise free the</span>
<span class="line-removed">-   // current and allocate a new one.</span>
<span class="line-removed">-   BufferBlob* blob = scratch_buffer_blob();</span>
<span class="line-removed">-   if ((blob != NULL) &amp;&amp; (const_size &lt;= _scratch_const_size)) {</span>
<span class="line-removed">-     // Use the current blob.</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     if (blob != NULL) {</span>
<span class="line-removed">-       BufferBlob::free(blob);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ResourceMark rm;</span>
<span class="line-removed">-     _scratch_const_size = const_size;</span>
<span class="line-removed">-     int size = C2Compiler::initial_code_buffer_size(const_size);</span>
<span class="line-removed">- #ifdef ASSERT</span>
<span class="line-removed">-     if (C-&gt;has_scalarized_args()) {</span>
<span class="line-removed">-       // Oop verification for loading object fields from scalarized value types in the new entry point requires lots of space</span>
<span class="line-removed">-       size += 5120;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     blob = BufferBlob::create(&quot;Compile::scratch_buffer&quot;, size);</span>
<span class="line-removed">-     // Record the buffer blob for next time.</span>
<span class="line-removed">-     set_scratch_buffer_blob(blob);</span>
<span class="line-removed">-     // Have we run out of code space?</span>
<span class="line-removed">-     if (scratch_buffer_blob() == NULL) {</span>
<span class="line-removed">-       // Let CompilerBroker disable further compilations.</span>
<span class="line-removed">-       record_failure(&quot;Not enough space for scratch buffer in CodeCache&quot;);</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Initialize the relocation buffers</span>
<span class="line-removed">-   relocInfo* locs_buf = (relocInfo*) blob-&gt;content_end() - MAX_locs_size;</span>
<span class="line-removed">-   set_scratch_locs_memory(locs_buf);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- //-----------------------scratch_emit_size-------------------------------------</span>
<span class="line-removed">- // Helper function that computes size by emitting code</span>
<span class="line-removed">- uint Compile::scratch_emit_size(const Node* n) {</span>
<span class="line-removed">-   // Start scratch_emit_size section.</span>
<span class="line-removed">-   set_in_scratch_emit_size(true);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Emit into a trash buffer and count bytes emitted.</span>
<span class="line-removed">-   // This is a pretty expensive way to compute a size,</span>
<span class="line-removed">-   // but it works well enough if seldom used.</span>
<span class="line-removed">-   // All common fixed-size instructions are given a size</span>
<span class="line-removed">-   // method by the AD file.</span>
<span class="line-removed">-   // Note that the scratch buffer blob and locs memory are</span>
<span class="line-removed">-   // allocated at the beginning of the compile task, and</span>
<span class="line-removed">-   // may be shared by several calls to scratch_emit_size.</span>
<span class="line-removed">-   // The allocation of the scratch buffer blob is particularly</span>
<span class="line-removed">-   // expensive, since it has to grab the code cache lock.</span>
<span class="line-removed">-   BufferBlob* blob = this-&gt;scratch_buffer_blob();</span>
<span class="line-removed">-   assert(blob != NULL, &quot;Initialize BufferBlob at start&quot;);</span>
<span class="line-removed">-   assert(blob-&gt;size() &gt; MAX_inst_size, &quot;sanity&quot;);</span>
<span class="line-removed">-   relocInfo* locs_buf = scratch_locs_memory();</span>
<span class="line-removed">-   address blob_begin = blob-&gt;content_begin();</span>
<span class="line-removed">-   address blob_end   = (address)locs_buf;</span>
<span class="line-removed">-   assert(blob-&gt;contains(blob_end), &quot;sanity&quot;);</span>
<span class="line-removed">-   CodeBuffer buf(blob_begin, blob_end - blob_begin);</span>
<span class="line-removed">-   buf.initialize_consts_size(_scratch_const_size);</span>
<span class="line-removed">-   buf.initialize_stubs_size(MAX_stubs_size);</span>
<span class="line-removed">-   assert(locs_buf != NULL, &quot;sanity&quot;);</span>
<span class="line-removed">-   int lsize = MAX_locs_size / 3;</span>
<span class="line-removed">-   buf.consts()-&gt;initialize_shared_locs(&amp;locs_buf[lsize * 0], lsize);</span>
<span class="line-removed">-   buf.insts()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 1], lsize);</span>
<span class="line-removed">-   buf.stubs()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 2], lsize);</span>
<span class="line-removed">-   // Mark as scratch buffer.</span>
<span class="line-removed">-   buf.consts()-&gt;set_scratch_emit();</span>
<span class="line-removed">-   buf.insts()-&gt;set_scratch_emit();</span>
<span class="line-removed">-   buf.stubs()-&gt;set_scratch_emit();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Do the emission.</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Label fakeL; // Fake label for branch instructions.</span>
<span class="line-removed">-   Label*   saveL = NULL;</span>
<span class="line-removed">-   uint save_bnum = 0;</span>
<span class="line-removed">-   bool is_branch = n-&gt;is_MachBranch();</span>
<span class="line-removed">-   if (is_branch) {</span>
<span class="line-removed">-     MacroAssembler masm(&amp;buf);</span>
<span class="line-removed">-     masm.bind(fakeL);</span>
<span class="line-removed">-     n-&gt;as_MachBranch()-&gt;save_label(&amp;saveL, &amp;save_bnum);</span>
<span class="line-removed">-     n-&gt;as_MachBranch()-&gt;label_set(&amp;fakeL, 0);</span>
<span class="line-removed">-   } else if (n-&gt;is_MachProlog()) {</span>
<span class="line-removed">-     saveL = ((MachPrologNode*)n)-&gt;_verified_entry;</span>
<span class="line-removed">-     ((MachPrologNode*)n)-&gt;_verified_entry = &amp;fakeL;</span>
<span class="line-removed">-   } else if (n-&gt;is_MachVEP()) {</span>
<span class="line-removed">-     saveL = ((MachVEPNode*)n)-&gt;_verified_entry;</span>
<span class="line-removed">-     ((MachVEPNode*)n)-&gt;_verified_entry = &amp;fakeL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   n-&gt;emit(buf, this-&gt;regalloc());</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Emitting into the scratch buffer should not fail</span>
<span class="line-removed">-   assert (!failing(), &quot;Must not have pending failure. Reason is: %s&quot;, failure_reason());</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Restore label.</span>
<span class="line-removed">-   if (is_branch) {</span>
<span class="line-removed">-     n-&gt;as_MachBranch()-&gt;label_set(saveL, save_bnum);</span>
<span class="line-removed">-   } else if (n-&gt;is_MachProlog()) {</span>
<span class="line-removed">-     ((MachPrologNode*)n)-&gt;_verified_entry = saveL;</span>
<span class="line-removed">-   } else if (n-&gt;is_MachVEP()) {</span>
<span class="line-removed">-     ((MachVEPNode*)n)-&gt;_verified_entry = saveL;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // End scratch_emit_size section.</span>
<span class="line-removed">-   set_in_scratch_emit_size(false);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return buf.insts_size();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  // ============================================================================
  //------------------------------Compile standard-------------------------------
  debug_only( int Compile::_debug_idx = 100000; )
  
  // Compile a method.  entry_bci is -1 for normal compilations and indicates
  // the continuation bci for on stack replacement.
  
  
<span class="line-modified">! Compile::Compile( ciEnv* ci_env, C2Compiler* compiler, ciMethod* target, int osr_bci,</span>
                    bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing, DirectiveSet* directive)
                  : Phase(Compiler),
                    _compile_id(ci_env-&gt;compile_id()),
                    _save_argument_registers(false),
                    _subsume_loads(subsume_loads),
<span class="line-new-header">--- 491,19 ---</span>
      }
    }
  #endif
  }
  
  // ============================================================================
  //------------------------------Compile standard-------------------------------
  debug_only( int Compile::_debug_idx = 100000; )
  
  // Compile a method.  entry_bci is -1 for normal compilations and indicates
  // the continuation bci for on stack replacement.
  
  
<span class="line-modified">! Compile::Compile( ciEnv* ci_env, ciMethod* target, int osr_bci,</span>
                    bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing, DirectiveSet* directive)
                  : Phase(Compiler),
                    _compile_id(ci_env-&gt;compile_id()),
                    _save_argument_registers(false),
                    _subsume_loads(subsume_loads),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 662,14 ***</span>
                    _entry_bci(osr_bci),
                    _stub_function(NULL),
                    _stub_name(NULL),
                    _stub_entry_point(NULL),
                    _max_node_limit(MaxNodeLimit),
<span class="line-removed">-                   _orig_pc_slot(0),</span>
<span class="line-removed">-                   _orig_pc_slot_offset_in_bytes(0),</span>
<span class="line-removed">-                   _sp_inc_slot(0),</span>
<span class="line-removed">-                   _sp_inc_slot_offset_in_bytes(0),</span>
                    _inlining_progress(false),
                    _inlining_incrementally(false),
                    _do_cleanup(false),
                    _has_reserved_stack_access(target-&gt;has_reserved_stack_access()),
  #ifndef PRODUCT
<span class="line-new-header">--- 513,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 707,16 ***</span>
                    _print_inlining_idx(0),
                    _print_inlining_output(NULL),
                    _replay_inline_data(NULL),
                    _java_calls(0),
                    _inner_loops(0),
<span class="line-modified">!                   _interpreter_frame_size(0),</span>
<span class="line-removed">-                   _node_bundling_limit(0),</span>
<span class="line-removed">-                   _node_bundling_base(NULL),</span>
<span class="line-removed">-                   _code_buffer(&quot;Compile::Fill_buffer&quot;),</span>
<span class="line-removed">-                   _scratch_const_size(-1),</span>
<span class="line-removed">-                   _in_scratch_emit_size(false)</span>
  #ifndef PRODUCT
                    , _in_dump_cnt(0)
  #endif
  {
    C = this;
<span class="line-new-header">--- 554,11 ---</span>
                    _print_inlining_idx(0),
                    _print_inlining_output(NULL),
                    _replay_inline_data(NULL),
                    _java_calls(0),
                    _inner_loops(0),
<span class="line-modified">!                   _interpreter_frame_size(0)</span>
  #ifndef PRODUCT
                    , _in_dump_cnt(0)
  #endif
  {
    C = this;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 928,72 ***</span>
      env()-&gt;dump_inline_data(_compile_id);
    }
  
    // Now that we know the size of all the monitors we can add a fixed slot
    // for the original deopt pc.
<span class="line-modified">! </span>
<span class="line-removed">-   _orig_pc_slot = fixed_slots();</span>
<span class="line-removed">-   int next_slot = _orig_pc_slot + (sizeof(address) / VMRegImpl::stack_slot_size);</span>
<span class="line-removed">- </span>
    if (needs_stack_repair()) {
      // One extra slot for the special stack increment value
<span class="line-removed">-     _sp_inc_slot = next_slot;</span>
      next_slot += 2;
    }
<span class="line-removed">- </span>
    set_fixed_slots(next_slot);
  
    // Compute when to use implicit null checks. Used by matching trap based
    // nodes and NullCheck optimization.
    set_allowed_deopt_reasons();
  
    // Now generate code
    Code_Gen();
<span class="line-removed">-   if (failing())  return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Check if we want to skip execution of all compiled code.</span>
<span class="line-removed">-   {</span>
<span class="line-removed">- #ifndef PRODUCT</span>
<span class="line-removed">-     if (OptoNoExecute) {</span>
<span class="line-removed">-       record_method_not_compilable(&quot;+OptoNoExecute&quot;);  // Flag as failed</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     TracePhase tp(&quot;install_code&quot;, &amp;timers[_t_registerMethod]);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (is_osr_compilation()) {</span>
<span class="line-removed">-       _code_offsets.set_value(CodeOffsets::Verified_Entry, 0);</span>
<span class="line-removed">-       _code_offsets.set_value(CodeOffsets::OSR_Entry, _first_block_size);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       _code_offsets.set_value(CodeOffsets::Verified_Entry, _first_block_size);</span>
<span class="line-removed">-       if (_code_offsets.value(CodeOffsets::Verified_Value_Entry) == -1) {</span>
<span class="line-removed">-         _code_offsets.set_value(CodeOffsets::Verified_Value_Entry, _first_block_size);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (_code_offsets.value(CodeOffsets::Verified_Value_Entry_RO) == -1) {</span>
<span class="line-removed">-         _code_offsets.set_value(CodeOffsets::Verified_Value_Entry_RO, _first_block_size);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (_code_offsets.value(CodeOffsets::Entry) == -1) {</span>
<span class="line-removed">-         _code_offsets.set_value(CodeOffsets::Entry, _first_block_size);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       _code_offsets.set_value(CodeOffsets::OSR_Entry, 0);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     env()-&gt;register_method(_method, _entry_bci,</span>
<span class="line-removed">-                            &amp;_code_offsets,</span>
<span class="line-removed">-                            _orig_pc_slot_offset_in_bytes,</span>
<span class="line-removed">-                            code_buffer(),</span>
<span class="line-removed">-                            frame_size_in_words(), _oop_map_set,</span>
<span class="line-removed">-                            &amp;_handler_table, &amp;_inc_table,</span>
<span class="line-removed">-                            compiler,</span>
<span class="line-removed">-                            has_unsafe_access(),</span>
<span class="line-removed">-                            SharedRuntime::is_wide_vector(max_vector_size()),</span>
<span class="line-removed">-                            rtm_state()</span>
<span class="line-removed">-                            );</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (log() != NULL) // Print code cache state into compiler log</span>
<span class="line-removed">-       log()-&gt;code_cache_state();</span>
<span class="line-removed">-   }</span>
  }
  
  //------------------------------Compile----------------------------------------
  // Compile a runtime stub
  Compile::Compile( ciEnv* ci_env,
<span class="line-new-header">--- 770,23 ---</span>
      env()-&gt;dump_inline_data(_compile_id);
    }
  
    // Now that we know the size of all the monitors we can add a fixed slot
    // for the original deopt pc.
<span class="line-modified">!   int next_slot = fixed_slots() + (sizeof(address) / VMRegImpl::stack_slot_size);</span>
    if (needs_stack_repair()) {
      // One extra slot for the special stack increment value
      next_slot += 2;
    }
    set_fixed_slots(next_slot);
  
    // Compute when to use implicit null checks. Used by matching trap based
    // nodes and NullCheck optimization.
    set_allowed_deopt_reasons();
  
    // Now generate code
    Code_Gen();
  }
  
  //------------------------------Compile----------------------------------------
  // Compile a runtime stub
  Compile::Compile( ciEnv* ci_env,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1015,14 ***</span>
      _entry_bci(InvocationEntryBci),
      _stub_function(stub_function),
      _stub_name(stub_name),
      _stub_entry_point(NULL),
      _max_node_limit(MaxNodeLimit),
<span class="line-removed">-     _orig_pc_slot(0),</span>
<span class="line-removed">-     _orig_pc_slot_offset_in_bytes(0),</span>
<span class="line-removed">-     _sp_inc_slot(0),</span>
<span class="line-removed">-     _sp_inc_slot_offset_in_bytes(0),</span>
      _inlining_progress(false),
      _inlining_incrementally(false),
      _has_reserved_stack_access(false),
  #ifndef PRODUCT
      _trace_opto_output(directive-&gt;TraceOptoOutputOption),
<span class="line-new-header">--- 808,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1056,13 ***</span>
      _print_inlining_output(NULL),
      _replay_inline_data(NULL),
      _java_calls(0),
      _inner_loops(0),
      _interpreter_frame_size(0),
<span class="line-removed">-     _node_bundling_limit(0),</span>
<span class="line-removed">-     _node_bundling_base(NULL),</span>
<span class="line-removed">-     _code_buffer(&quot;Compile::Fill_buffer&quot;),</span>
  #ifndef PRODUCT
      _in_dump_cnt(0),
  #endif
      _allowed_reasons(0) {
    C = this;
<span class="line-new-header">--- 845,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1093,38 ***</span>
      GraphKit kit;
      kit.gen_stub(stub_function, stub_name, is_fancy_jump, pass_tls, return_pc);
    }
  
    NOT_PRODUCT( verify_graph_edges(); )
<span class="line-removed">-   Code_Gen();</span>
<span class="line-removed">-   if (failing())  return;</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Entry point will be accessed using compile-&gt;stub_entry_point();</span>
<span class="line-removed">-   if (code_buffer() == NULL) {</span>
<span class="line-removed">-     Matcher::soft_match_failure();</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     if (PrintAssembly &amp;&amp; (WizardMode || Verbose))</span>
<span class="line-removed">-       tty-&gt;print_cr(&quot;### Stub::%s&quot;, stub_name);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!failing()) {</span>
<span class="line-removed">-       assert(_fixed_slots == 0, &quot;no fixed slots used for runtime stubs&quot;);</span>
  
<span class="line-modified">!       // Make the NMethod</span>
<span class="line-removed">-       // For now we mark the frame as never safe for profile stackwalking</span>
<span class="line-removed">-       RuntimeStub *rs = RuntimeStub::new_runtime_stub(stub_name,</span>
<span class="line-removed">-                                                       code_buffer(),</span>
<span class="line-removed">-                                                       CodeOffsets::frame_never_safe,</span>
<span class="line-removed">-                                                       // _code_offsets.value(CodeOffsets::Frame_Complete),</span>
<span class="line-removed">-                                                       frame_size_in_words(),</span>
<span class="line-removed">-                                                       _oop_map_set,</span>
<span class="line-removed">-                                                       save_arg_registers);</span>
<span class="line-removed">-       assert(rs != NULL &amp;&amp; rs-&gt;is_runtime_stub(), &quot;sanity check&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       _stub_entry_point = rs-&gt;entry_point();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
  }
  
  //------------------------------Init-------------------------------------------
  // Prepare for a single compilation
  void Compile::Init(int aliaslevel) {
<span class="line-new-header">--- 879,12 ---</span>
      GraphKit kit;
      kit.gen_stub(stub_function, stub_name, is_fancy_jump, pass_tls, return_pc);
    }
  
    NOT_PRODUCT( verify_graph_edges(); )
  
<span class="line-modified">!   Code_Gen();</span>
  }
  
  //------------------------------Init-------------------------------------------
  // Prepare for a single compilation
  void Compile::Init(int aliaslevel) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1258,10 ***</span>
<span class="line-new-header">--- 1018,13 ---</span>
    _expensive_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
    _range_check_casts = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
    _opaque4_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
    _value_type_nodes = new (comp_arena()) Unique_Node_List(comp_arena());
    register_library_intrinsics();
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+   _type_verify_symmetry = true;</span>
<span class="line-added">+ #endif</span>
  }
  
  //---------------------------init_start----------------------------------------
  // Install the StartNode on this compile object.
  void Compile::init_start(StartNode* s) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1885,10 ***</span>
<span class="line-new-header">--- 1648,12 ---</span>
          alias_type(idx)-&gt;set_rewritable(false);
        if (flat-&gt;offset() == in_bytes(Klass::java_mirror_offset()))
          alias_type(idx)-&gt;set_rewritable(false);
        if (flat-&gt;offset() == in_bytes(Klass::layout_helper_offset()))
          alias_type(idx)-&gt;set_rewritable(false);
<span class="line-added">+       if (flat-&gt;offset() == in_bytes(Klass::secondary_super_cache_offset()))</span>
<span class="line-added">+         alias_type(idx)-&gt;set_rewritable(false);</span>
      }
      // %%% (We would like to finalize JavaThread::threadObj_offset(),
      // but the base pointer type is not distinctive enough to identify
      // references into JavaThread.)
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1992,12 ***</span>
  //------------------------------can_alias--------------------------------------
  // True if any values of the given address type are in the given alias category.
  bool Compile::can_alias(const TypePtr* adr_type, int alias_idx) {
    if (alias_idx == AliasIdxTop)         return false; // the empty category
    if (adr_type == NULL)                 return false; // NULL serves as TypePtr::TOP
<span class="line-modified">!   if (alias_idx == AliasIdxBot)         return true;  // the universal category</span>
<span class="line-modified">!   if (adr_type-&gt;base() == Type::AnyPtr) return true;  // TypePtr::BOTTOM or its twins</span>
  
    // the only remaining possible overlap is identity
    int adr_idx = get_alias_index(adr_type);
    assert(adr_idx != AliasIdxBot &amp;&amp; adr_idx != AliasIdxTop, &quot;&quot;);
    return adr_idx == alias_idx;
<span class="line-new-header">--- 1757,13 ---</span>
  //------------------------------can_alias--------------------------------------
  // True if any values of the given address type are in the given alias category.
  bool Compile::can_alias(const TypePtr* adr_type, int alias_idx) {
    if (alias_idx == AliasIdxTop)         return false; // the empty category
    if (adr_type == NULL)                 return false; // NULL serves as TypePtr::TOP
<span class="line-modified">!   // Known instance doesn&#39;t alias with bottom memory</span>
<span class="line-modified">!   if (alias_idx == AliasIdxBot)         return !adr_type-&gt;is_known_instance();                   // the universal category</span>
<span class="line-added">+   if (adr_type-&gt;base() == Type::AnyPtr) return !C-&gt;get_adr_type(alias_idx)-&gt;is_known_instance(); // TypePtr::BOTTOM or its twins</span>
  
    // the only remaining possible overlap is identity
    int adr_idx = get_alias_index(adr_type);
    assert(adr_idx != AliasIdxBot &amp;&amp; adr_idx != AliasIdxTop, &quot;&quot;);
    return adr_idx == alias_idx;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2979,158 ***</span>
      cfg.postalloc_expand(_regalloc);
    }
  
    // Convert Nodes to instruction bits in a buffer
    {
<span class="line-modified">!     TraceTime tp(&quot;output&quot;, &amp;timers[_t_output], CITime);</span>
<span class="line-modified">!     Output();</span>
    }
  
    print_method(PHASE_FINAL_CODE);
  
    // He&#39;s dead, Jim.
    _cfg     = (PhaseCFG*)((intptr_t)0xdeadbeef);
    _regalloc = (PhaseChaitin*)((intptr_t)0xdeadbeef);
  }
  
<span class="line-removed">- </span>
<span class="line-removed">- //------------------------------dump_asm---------------------------------------</span>
<span class="line-removed">- // Dump formatted assembly</span>
<span class="line-removed">- #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="line-removed">- void Compile::dump_asm_on(outputStream* st, int* pcs, uint pc_limit) {</span>
<span class="line-removed">- </span>
<span class="line-removed">-   int pc_digits = 3; // #chars required for pc</span>
<span class="line-removed">-   int sb_chars  = 3; // #chars for &quot;start bundle&quot; indicator</span>
<span class="line-removed">-   int tab_size  = 8;</span>
<span class="line-removed">-   if (pcs != NULL) {</span>
<span class="line-removed">-     int max_pc = 0;</span>
<span class="line-removed">-     for (uint i = 0; i &lt; pc_limit; i++) {</span>
<span class="line-removed">-       max_pc = (max_pc &lt; pcs[i]) ? pcs[i] : max_pc;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     pc_digits  = ((max_pc &lt; 4096) ? 3 : ((max_pc &lt; 65536) ? 4 : ((max_pc &lt; 65536*256) ? 6 : 8))); // #chars required for pc</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   int prefix_len = ((pc_digits + sb_chars + tab_size - 1)/tab_size)*tab_size;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool cut_short = false;</span>
<span class="line-removed">-   st-&gt;print_cr(&quot;#&quot;);</span>
<span class="line-removed">-   st-&gt;print(&quot;#  &quot;);  _tf-&gt;dump_on(st);  st-&gt;cr();</span>
<span class="line-removed">-   st-&gt;print_cr(&quot;#&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // For all blocks</span>
<span class="line-removed">-   int pc = 0x0;                 // Program counter</span>
<span class="line-removed">-   char starts_bundle = &#39; &#39;;</span>
<span class="line-removed">-   _regalloc-&gt;dump_frame();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Node *n = NULL;</span>
<span class="line-removed">-   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="line-removed">-     if (VMThread::should_terminate()) {</span>
<span class="line-removed">-       cut_short = true;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     Block* block = _cfg-&gt;get_block(i);</span>
<span class="line-removed">-     if (block-&gt;is_connector() &amp;&amp; !Verbose) {</span>
<span class="line-removed">-       continue;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     n = block-&gt;head();</span>
<span class="line-removed">-     if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-removed">-       pc = pcs[n-&gt;_idx];</span>
<span class="line-removed">-       st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">-     block-&gt;dump_head(_cfg, st);</span>
<span class="line-removed">-     if (block-&gt;is_connector()) {</span>
<span class="line-removed">-       st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">-       st-&gt;print_cr(&quot;# Empty connector block&quot;);</span>
<span class="line-removed">-     } else if (block-&gt;num_preds() == 2 &amp;&amp; block-&gt;pred(1)-&gt;is_CatchProj() &amp;&amp; block-&gt;pred(1)-&gt;as_CatchProj()-&gt;_con == CatchProjNode::fall_through_index) {</span>
<span class="line-removed">-       st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">-       st-&gt;print_cr(&quot;# Block is sole successor of call&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // For all instructions</span>
<span class="line-removed">-     Node *delay = NULL;</span>
<span class="line-removed">-     for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {</span>
<span class="line-removed">-       if (VMThread::should_terminate()) {</span>
<span class="line-removed">-         cut_short = true;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       n = block-&gt;get_node(j);</span>
<span class="line-removed">-       if (valid_bundle_info(n)) {</span>
<span class="line-removed">-         Bundle* bundle = node_bundling(n);</span>
<span class="line-removed">-         if (bundle-&gt;used_in_unconditional_delay()) {</span>
<span class="line-removed">-           delay = n;</span>
<span class="line-removed">-           continue;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         if (bundle-&gt;starts_bundle()) {</span>
<span class="line-removed">-           starts_bundle = &#39;+&#39;;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (WizardMode) {</span>
<span class="line-removed">-         n-&gt;dump();</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if( !n-&gt;is_Region() &amp;&amp;    // Dont print in the Assembly</span>
<span class="line-removed">-           !n-&gt;is_Phi() &amp;&amp;       // a few noisely useless nodes</span>
<span class="line-removed">-           !n-&gt;is_Proj() &amp;&amp;</span>
<span class="line-removed">-           !n-&gt;is_MachTemp() &amp;&amp;</span>
<span class="line-removed">-           !n-&gt;is_SafePointScalarObject() &amp;&amp;</span>
<span class="line-removed">-           !n-&gt;is_Catch() &amp;&amp;     // Would be nice to print exception table targets</span>
<span class="line-removed">-           !n-&gt;is_MergeMem() &amp;&amp;  // Not very interesting</span>
<span class="line-removed">-           !n-&gt;is_top() &amp;&amp;       // Debug info table constants</span>
<span class="line-removed">-           !(n-&gt;is_Con() &amp;&amp; !n-&gt;is_Mach())// Debug info table constants</span>
<span class="line-removed">-           ) {</span>
<span class="line-removed">-         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-removed">-           pc = pcs[n-&gt;_idx];</span>
<span class="line-removed">-           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           st-&gt;fill_to(pc_digits);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="line-removed">-         starts_bundle = &#39; &#39;;</span>
<span class="line-removed">-         st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">-         n-&gt;format(_regalloc, st);</span>
<span class="line-removed">-         st-&gt;cr();</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       // If we have an instruction with a delay slot, and have seen a delay,</span>
<span class="line-removed">-       // then back up and print it</span>
<span class="line-removed">-       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;use_unconditional_delay()) {</span>
<span class="line-removed">-         // Coverity finding - Explicit null dereferenced.</span>
<span class="line-removed">-         guarantee(delay != NULL, &quot;no unconditional delay instruction&quot;);</span>
<span class="line-removed">-         if (WizardMode) delay-&gt;dump();</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (node_bundling(delay)-&gt;starts_bundle())</span>
<span class="line-removed">-           starts_bundle = &#39;+&#39;;</span>
<span class="line-removed">-         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-removed">-           pc = pcs[n-&gt;_idx];</span>
<span class="line-removed">-           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           st-&gt;fill_to(pc_digits);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="line-removed">-         starts_bundle = &#39; &#39;;</span>
<span class="line-removed">-         st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">-         delay-&gt;format(_regalloc, st);</span>
<span class="line-removed">-         st-&gt;cr();</span>
<span class="line-removed">-         delay = NULL;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       // Dump the exception table as well</span>
<span class="line-removed">-       if( n-&gt;is_Catch() &amp;&amp; (Verbose || WizardMode) ) {</span>
<span class="line-removed">-         // Print the exception table for this offset</span>
<span class="line-removed">-         _handler_table.print_subtable_for(pc);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       st-&gt;bol(); // Make sure we start on a new line</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     st-&gt;cr(); // one empty line between blocks</span>
<span class="line-removed">-     assert(cut_short || delay == NULL, &quot;no unconditional delay branch&quot;);</span>
<span class="line-removed">-   } // End of per-block dump</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (cut_short)  st-&gt;print_cr(&quot;*** disassembly is cut short ***&quot;);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  //------------------------------Final_Reshape_Counts---------------------------
  // This class defines counters to help identify when a method
  // may/must be executed using hardware with only 24-bit precision.
  struct Final_Reshape_Counts : public StackObj {
    int  _call_count;             // count non-inlined &#39;common&#39; calls
<span class="line-new-header">--- 2745,24 ---</span>
      cfg.postalloc_expand(_regalloc);
    }
  
    // Convert Nodes to instruction bits in a buffer
    {
<span class="line-modified">!     TracePhase tp(&quot;output&quot;, &amp;timers[_t_output]);</span>
<span class="line-modified">!     PhaseOutput output;</span>
<span class="line-added">+     output.Output();</span>
<span class="line-added">+     if (failing())  return;</span>
<span class="line-added">+     output.install();</span>
    }
  
    print_method(PHASE_FINAL_CODE);
  
    // He&#39;s dead, Jim.
    _cfg     = (PhaseCFG*)((intptr_t)0xdeadbeef);
    _regalloc = (PhaseChaitin*)((intptr_t)0xdeadbeef);
  }
  
  //------------------------------Final_Reshape_Counts---------------------------
  // This class defines counters to help identify when a method
  // may/must be executed using hardware with only 24-bit precision.
  struct Final_Reshape_Counts : public StackObj {
    int  _call_count;             // count non-inlined &#39;common&#39; calls
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3850,10 ***</span>
<span class="line-new-header">--- 3482,13 ---</span>
    case Op_MulReductionVL:
    case Op_MulReductionVF:
    case Op_MulReductionVD:
    case Op_MinReductionV:
    case Op_MaxReductionV:
<span class="line-added">+   case Op_AndReductionV:</span>
<span class="line-added">+   case Op_OrReductionV:</span>
<span class="line-added">+   case Op_XorReductionV:</span>
      break;
  
    case Op_PackB:
    case Op_PackS:
    case Op_PackI:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4488,226 ***</span>
    if (_log != NULL) {
      _log-&gt;done(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39;&quot;, _phase_name, C-&gt;unique(), C-&gt;live_nodes());
    }
  }
  
<span class="line-removed">- //=============================================================================</span>
<span class="line-removed">- // Two Constant&#39;s are equal when the type and the value are equal.</span>
<span class="line-removed">- bool Compile::Constant::operator==(const Constant&amp; other) {</span>
<span class="line-removed">-   if (type()          != other.type()         )  return false;</span>
<span class="line-removed">-   if (can_be_reused() != other.can_be_reused())  return false;</span>
<span class="line-removed">-   // For floating point values we compare the bit pattern.</span>
<span class="line-removed">-   switch (type()) {</span>
<span class="line-removed">-   case T_INT:</span>
<span class="line-removed">-   case T_FLOAT:   return (_v._value.i == other._v._value.i);</span>
<span class="line-removed">-   case T_LONG:</span>
<span class="line-removed">-   case T_DOUBLE:  return (_v._value.j == other._v._value.j);</span>
<span class="line-removed">-   case T_OBJECT:</span>
<span class="line-removed">-   case T_ADDRESS: return (_v._value.l == other._v._value.l);</span>
<span class="line-removed">-   case T_VOID:    return (_v._value.l == other._v._value.l);  // jump-table entries</span>
<span class="line-removed">-   case T_METADATA: return (_v._metadata == other._v._metadata);</span>
<span class="line-removed">-   default: ShouldNotReachHere(); return false;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static int type_to_size_in_bytes(BasicType t) {</span>
<span class="line-removed">-   switch (t) {</span>
<span class="line-removed">-   case T_INT:     return sizeof(jint   );</span>
<span class="line-removed">-   case T_LONG:    return sizeof(jlong  );</span>
<span class="line-removed">-   case T_FLOAT:   return sizeof(jfloat );</span>
<span class="line-removed">-   case T_DOUBLE:  return sizeof(jdouble);</span>
<span class="line-removed">-   case T_METADATA: return sizeof(Metadata*);</span>
<span class="line-removed">-     // We use T_VOID as marker for jump-table entries (labels) which</span>
<span class="line-removed">-     // need an internal word relocation.</span>
<span class="line-removed">-   case T_VOID:</span>
<span class="line-removed">-   case T_ADDRESS:</span>
<span class="line-removed">-   case T_OBJECT:  return sizeof(jobject);</span>
<span class="line-removed">-   default:</span>
<span class="line-removed">-     ShouldNotReachHere();</span>
<span class="line-removed">-     return -1;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- int Compile::ConstantTable::qsort_comparator(Constant* a, Constant* b) {</span>
<span class="line-removed">-   // sort descending</span>
<span class="line-removed">-   if (a-&gt;freq() &gt; b-&gt;freq())  return -1;</span>
<span class="line-removed">-   if (a-&gt;freq() &lt; b-&gt;freq())  return  1;</span>
<span class="line-removed">-   return 0;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Compile::ConstantTable::calculate_offsets_and_size() {</span>
<span class="line-removed">-   // First, sort the array by frequencies.</span>
<span class="line-removed">-   _constants.sort(qsort_comparator);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef ASSERT</span>
<span class="line-removed">-   // Make sure all jump-table entries were sorted to the end of the</span>
<span class="line-removed">-   // array (they have a negative frequency).</span>
<span class="line-removed">-   bool found_void = false;</span>
<span class="line-removed">-   for (int i = 0; i &lt; _constants.length(); i++) {</span>
<span class="line-removed">-     Constant con = _constants.at(i);</span>
<span class="line-removed">-     if (con.type() == T_VOID)</span>
<span class="line-removed">-       found_void = true;  // jump-tables</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-       assert(!found_void, &quot;wrong sorting&quot;);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-   int offset = 0;</span>
<span class="line-removed">-   for (int i = 0; i &lt; _constants.length(); i++) {</span>
<span class="line-removed">-     Constant* con = _constants.adr_at(i);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Align offset for type.</span>
<span class="line-removed">-     int typesize = type_to_size_in_bytes(con-&gt;type());</span>
<span class="line-removed">-     offset = align_up(offset, typesize);</span>
<span class="line-removed">-     con-&gt;set_offset(offset);   // set constant&#39;s offset</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (con-&gt;type() == T_VOID) {</span>
<span class="line-removed">-       MachConstantNode* n = (MachConstantNode*) con-&gt;get_jobject();</span>
<span class="line-removed">-       offset = offset + typesize * n-&gt;outcnt();  // expand jump-table</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       offset = offset + typesize;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Align size up to the next section start (which is insts; see</span>
<span class="line-removed">-   // CodeBuffer::align_at_start).</span>
<span class="line-removed">-   assert(_size == -1, &quot;already set?&quot;);</span>
<span class="line-removed">-   _size = align_up(offset, (int)CodeEntryAlignment);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Compile::ConstantTable::emit(CodeBuffer&amp; cb) {</span>
<span class="line-removed">-   MacroAssembler _masm(&amp;cb);</span>
<span class="line-removed">-   for (int i = 0; i &lt; _constants.length(); i++) {</span>
<span class="line-removed">-     Constant con = _constants.at(i);</span>
<span class="line-removed">-     address constant_addr = NULL;</span>
<span class="line-removed">-     switch (con.type()) {</span>
<span class="line-removed">-     case T_INT:    constant_addr = _masm.int_constant(   con.get_jint()   ); break;</span>
<span class="line-removed">-     case T_LONG:   constant_addr = _masm.long_constant(  con.get_jlong()  ); break;</span>
<span class="line-removed">-     case T_FLOAT:  constant_addr = _masm.float_constant( con.get_jfloat() ); break;</span>
<span class="line-removed">-     case T_DOUBLE: constant_addr = _masm.double_constant(con.get_jdouble()); break;</span>
<span class="line-removed">-     case T_OBJECT: {</span>
<span class="line-removed">-       jobject obj = con.get_jobject();</span>
<span class="line-removed">-       int oop_index = _masm.oop_recorder()-&gt;find_index(obj);</span>
<span class="line-removed">-       constant_addr = _masm.address_constant((address) obj, oop_Relocation::spec(oop_index));</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     case T_ADDRESS: {</span>
<span class="line-removed">-       address addr = (address) con.get_jobject();</span>
<span class="line-removed">-       constant_addr = _masm.address_constant(addr);</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     // We use T_VOID as marker for jump-table entries (labels) which</span>
<span class="line-removed">-     // need an internal word relocation.</span>
<span class="line-removed">-     case T_VOID: {</span>
<span class="line-removed">-       MachConstantNode* n = (MachConstantNode*) con.get_jobject();</span>
<span class="line-removed">-       // Fill the jump-table with a dummy word.  The real value is</span>
<span class="line-removed">-       // filled in later in fill_jump_table.</span>
<span class="line-removed">-       address dummy = (address) n;</span>
<span class="line-removed">-       constant_addr = _masm.address_constant(dummy);</span>
<span class="line-removed">-       // Expand jump-table</span>
<span class="line-removed">-       for (uint i = 1; i &lt; n-&gt;outcnt(); i++) {</span>
<span class="line-removed">-         address temp_addr = _masm.address_constant(dummy + i);</span>
<span class="line-removed">-         assert(temp_addr, &quot;consts section too small&quot;);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     case T_METADATA: {</span>
<span class="line-removed">-       Metadata* obj = con.get_metadata();</span>
<span class="line-removed">-       int metadata_index = _masm.oop_recorder()-&gt;find_index(obj);</span>
<span class="line-removed">-       constant_addr = _masm.address_constant((address) obj, metadata_Relocation::spec(metadata_index));</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     default: ShouldNotReachHere();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     assert(constant_addr, &quot;consts section too small&quot;);</span>
<span class="line-removed">-     assert((constant_addr - _masm.code()-&gt;consts()-&gt;start()) == con.offset(),</span>
<span class="line-removed">-             &quot;must be: %d == %d&quot;, (int) (constant_addr - _masm.code()-&gt;consts()-&gt;start()), (int)(con.offset()));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- int Compile::ConstantTable::find_offset(Constant&amp; con) const {</span>
<span class="line-removed">-   int idx = _constants.find(con);</span>
<span class="line-removed">-   guarantee(idx != -1, &quot;constant must be in constant table&quot;);</span>
<span class="line-removed">-   int offset = _constants.at(idx).offset();</span>
<span class="line-removed">-   guarantee(offset != -1, &quot;constant table not emitted yet?&quot;);</span>
<span class="line-removed">-   return offset;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Compile::ConstantTable::add(Constant&amp; con) {</span>
<span class="line-removed">-   if (con.can_be_reused()) {</span>
<span class="line-removed">-     int idx = _constants.find(con);</span>
<span class="line-removed">-     if (idx != -1 &amp;&amp; _constants.at(idx).can_be_reused()) {</span>
<span class="line-removed">-       _constants.adr_at(idx)-&gt;inc_freq(con.freq());  // increase the frequency by the current value</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   (void) _constants.append(con);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- Compile::Constant Compile::ConstantTable::add(MachConstantNode* n, BasicType type, jvalue value) {</span>
<span class="line-removed">-   Block* b = Compile::current()-&gt;cfg()-&gt;get_block_for_node(n);</span>
<span class="line-removed">-   Constant con(type, value, b-&gt;_freq);</span>
<span class="line-removed">-   add(con);</span>
<span class="line-removed">-   return con;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- Compile::Constant Compile::ConstantTable::add(Metadata* metadata) {</span>
<span class="line-removed">-   Constant con(metadata);</span>
<span class="line-removed">-   add(con);</span>
<span class="line-removed">-   return con;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- Compile::Constant Compile::ConstantTable::add(MachConstantNode* n, MachOper* oper) {</span>
<span class="line-removed">-   jvalue value;</span>
<span class="line-removed">-   BasicType type = oper-&gt;type()-&gt;basic_type();</span>
<span class="line-removed">-   switch (type) {</span>
<span class="line-removed">-   case T_LONG:    value.j = oper-&gt;constantL(); break;</span>
<span class="line-removed">-   case T_FLOAT:   value.f = oper-&gt;constantF(); break;</span>
<span class="line-removed">-   case T_DOUBLE:  value.d = oper-&gt;constantD(); break;</span>
<span class="line-removed">-   case T_OBJECT:</span>
<span class="line-removed">-   case T_ADDRESS: value.l = (jobject) oper-&gt;constant(); break;</span>
<span class="line-removed">-   case T_METADATA: return add((Metadata*)oper-&gt;constant()); break;</span>
<span class="line-removed">-   default: guarantee(false, &quot;unhandled type: %s&quot;, type2name(type));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return add(n, type, value);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- Compile::Constant Compile::ConstantTable::add_jump_table(MachConstantNode* n) {</span>
<span class="line-removed">-   jvalue value;</span>
<span class="line-removed">-   // We can use the node pointer here to identify the right jump-table</span>
<span class="line-removed">-   // as this method is called from Compile::Fill_buffer right before</span>
<span class="line-removed">-   // the MachNodes are emitted and the jump-table is filled (means the</span>
<span class="line-removed">-   // MachNode pointers do not change anymore).</span>
<span class="line-removed">-   value.l = (jobject) n;</span>
<span class="line-removed">-   Constant con(T_VOID, value, next_jump_table_freq(), false);  // Labels of a jump-table cannot be reused.</span>
<span class="line-removed">-   add(con);</span>
<span class="line-removed">-   return con;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Compile::ConstantTable::fill_jump_table(CodeBuffer&amp; cb, MachConstantNode* n, GrowableArray&lt;Label*&gt; labels) const {</span>
<span class="line-removed">-   // If called from Compile::scratch_emit_size do nothing.</span>
<span class="line-removed">-   if (Compile::current()-&gt;in_scratch_emit_size())  return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   assert(labels.is_nonempty(), &quot;must be&quot;);</span>
<span class="line-removed">-   assert((uint) labels.length() == n-&gt;outcnt(), &quot;must be equal: %d == %d&quot;, labels.length(), n-&gt;outcnt());</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Since MachConstantNode::constant_offset() also contains</span>
<span class="line-removed">-   // table_base_offset() we need to subtract the table_base_offset()</span>
<span class="line-removed">-   // to get the plain offset into the constant table.</span>
<span class="line-removed">-   int offset = n-&gt;constant_offset() - table_base_offset();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   MacroAssembler _masm(&amp;cb);</span>
<span class="line-removed">-   address* jump_table_base = (address*) (_masm.code()-&gt;consts()-&gt;start() + offset);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   for (uint i = 0; i &lt; n-&gt;outcnt(); i++) {</span>
<span class="line-removed">-     address* constant_addr = &amp;jump_table_base[i];</span>
<span class="line-removed">-     assert(*constant_addr == (((address) n) + i), &quot;all jump-table entries must contain adjusted node pointer: &quot; INTPTR_FORMAT &quot; == &quot; INTPTR_FORMAT, p2i(*constant_addr), p2i(((address) n) + i));</span>
<span class="line-removed">-     *constant_addr = cb.consts()-&gt;target(*labels.at(i), (address) constant_addr);</span>
<span class="line-removed">-     cb.consts()-&gt;relocate((address) constant_addr, relocInfo::internal_word_type);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  //----------------------------static_subtype_check-----------------------------
  // Shortcut important common cases when superklass is exact:
  // (0) superklass is java.lang.Object (can occur in reflective code)
  // (1) subklass is already limited to a subtype of superklass =&gt; always ok
  // (2) subklass does not overlap with superklass =&gt; always fail
<span class="line-new-header">--- 4123,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4751,13 ***</span>
      if (!ik-&gt;has_subklass() &amp;&amp; !ik-&gt;is_interface()) {
        if (!ik-&gt;is_final()) {
          // Add a dependency if there is a chance of a later subclass.
          dependencies()-&gt;assert_leaf_type(ik);
        }
<span class="line-removed">-       if (ik-&gt;is_abstract()) {</span>
<span class="line-removed">-         return SSC_always_false;</span>
<span class="line-removed">-       }</span>
        return SSC_easy_test;     // (3) caller can do a simple ptr comparison
      }
    } else {
      // A primitive array type has no subtypes.
      return SSC_easy_test;       // (3) caller can do a simple ptr comparison
<span class="line-new-header">--- 4170,10 ---</span>
</pre>
<center><a href="classes.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
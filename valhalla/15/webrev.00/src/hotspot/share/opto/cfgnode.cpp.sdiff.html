<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/cfgnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c2compiler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cfgnode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/cfgnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1769   nstack.push(in); // Start with unique input.
1770   visited.set(in-&gt;_idx);
1771   while (nstack.size() != 0) {
1772     Node* n = nstack.pop();
1773     uint cnt = n-&gt;req();
1774     uint i = (n-&gt;is_Proj() &amp;&amp; !n-&gt;is_CFG()) ? 0 : 1;
1775     for (; i &lt; cnt; i++) {
1776       Node* m = n-&gt;in(i);
1777       if (m == (Node*)this) {
1778         return true;    // Data loop
1779       }
1780       if (m != NULL &amp;&amp; !m-&gt;is_dead_loop_safe()) { // Only look for unsafe cases.
1781         if (!visited.test_set(m-&gt;_idx))
1782           nstack.push(m);
1783       }
1784     }
1785   }
1786   return false; // The phi is not reachable from its inputs
1787 }
1788 





































1789 
1790 //------------------------------Ideal------------------------------------------
1791 // Return a node which is more &quot;ideal&quot; than the current node.  Must preserve
1792 // the CFG, but we can still strip out dead paths.
1793 Node *PhiNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1794   // The next should never happen after 6297035 fix.
1795   if( is_copy() )               // Already degraded to a Copy ?
1796     return NULL;                // No change
1797 
1798   Node *r = in(0);              // RegionNode
1799   assert(r-&gt;in(0) == NULL || !r-&gt;in(0)-&gt;is_Root(), &quot;not a specially hidden merge&quot;);
1800 
1801   // Note: During parsing, phis are often transformed before their regions.
1802   // This means we have to use type_or_null to defend against untyped regions.
1803   if( phase-&gt;type_or_null(r) == Type::TOP ) // Dead code?
1804     return NULL;                // No change
1805 
1806   // If all inputs are value types of the same type, push the value type node down
1807   // through the phi because value type nodes should be merged through their input values.
1808   if (req() &gt; 2 &amp;&amp; in(1) != NULL &amp;&amp; in(1)-&gt;is_ValueTypeBase() &amp;&amp; (can_reshape || in(1)-&gt;is_ValueType())) {
</pre>
<hr />
<pre>
1845         }
1846         // Nuke it down
1847         if (can_reshape) {
1848           set_req_X(j, top, igvn);
1849         } else {
1850           set_req(j, top);
1851         }
1852         progress = this;        // Record progress
1853       }
1854     }
1855   }
1856 
1857   if (can_reshape &amp;&amp; outcnt() == 0) {
1858     // set_req() above may kill outputs if Phi is referenced
1859     // only by itself on the dead (top) control path.
1860     return top;
1861   }
1862 
1863   bool uncasted = false;
1864   Node* uin = unique_input(phase, false);
<span class="line-modified">1865   if (uin == NULL &amp;&amp; can_reshape) {</span>



1866     uncasted = true;
1867     uin = unique_input(phase, true);
1868   }
1869   if (uin == top) {             // Simplest case: no alive inputs.
1870     if (can_reshape)            // IGVN transformation
1871       return top;
1872     else
1873       return NULL;              // Identity will return TOP
1874   } else if (uin != NULL) {
1875     // Only one not-NULL unique input path is left.
1876     // Determine if this input is backedge of a loop.
1877     // (Skip new phis which have no uses and dead regions).
1878     if (outcnt() &gt; 0 &amp;&amp; r-&gt;in(0) != NULL) {
1879       // First, take the short cut when we know it is a loop and
1880       // the EntryControl data path is dead.
1881       // Loop node may have only one input because entry path
1882       // is removed in PhaseIdealLoop::Dominators().
1883       assert(!r-&gt;is_Loop() || r-&gt;req() &lt;= 3, &quot;Loop node should have 3 or less inputs&quot;);
1884       bool is_loop = (r-&gt;is_Loop() &amp;&amp; r-&gt;req() == 3);
1885       // Then, check if there is a data loop when phi references itself directly
</pre>
</td>
<td>
<hr />
<pre>
1769   nstack.push(in); // Start with unique input.
1770   visited.set(in-&gt;_idx);
1771   while (nstack.size() != 0) {
1772     Node* n = nstack.pop();
1773     uint cnt = n-&gt;req();
1774     uint i = (n-&gt;is_Proj() &amp;&amp; !n-&gt;is_CFG()) ? 0 : 1;
1775     for (; i &lt; cnt; i++) {
1776       Node* m = n-&gt;in(i);
1777       if (m == (Node*)this) {
1778         return true;    // Data loop
1779       }
1780       if (m != NULL &amp;&amp; !m-&gt;is_dead_loop_safe()) { // Only look for unsafe cases.
1781         if (!visited.test_set(m-&gt;_idx))
1782           nstack.push(m);
1783       }
1784     }
1785   }
1786   return false; // The phi is not reachable from its inputs
1787 }
1788 
<span class="line-added">1789 // Is this Phi&#39;s region or some inputs to the region enqueued for IGVN</span>
<span class="line-added">1790 // and so could cause the region to be optimized out?</span>
<span class="line-added">1791 bool PhiNode::wait_for_region_igvn(PhaseGVN* phase) {</span>
<span class="line-added">1792   PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
<span class="line-added">1793   Unique_Node_List&amp; worklist = igvn-&gt;_worklist;</span>
<span class="line-added">1794   bool delay = false;</span>
<span class="line-added">1795   Node* r = in(0);</span>
<span class="line-added">1796   for (uint j = 1; j &lt; req(); j++) {</span>
<span class="line-added">1797     Node* rc = r-&gt;in(j);</span>
<span class="line-added">1798     Node* n = in(j);</span>
<span class="line-added">1799     if (rc != NULL &amp;&amp;</span>
<span class="line-added">1800         rc-&gt;is_Proj()) {</span>
<span class="line-added">1801       if (worklist.member(rc)) {</span>
<span class="line-added">1802         delay = true;</span>
<span class="line-added">1803       } else if (rc-&gt;in(0) != NULL &amp;&amp;</span>
<span class="line-added">1804                  rc-&gt;in(0)-&gt;is_If()) {</span>
<span class="line-added">1805         if (worklist.member(rc-&gt;in(0))) {</span>
<span class="line-added">1806           delay = true;</span>
<span class="line-added">1807         } else if (rc-&gt;in(0)-&gt;in(1) != NULL &amp;&amp;</span>
<span class="line-added">1808                    rc-&gt;in(0)-&gt;in(1)-&gt;is_Bool()) {</span>
<span class="line-added">1809           if (worklist.member(rc-&gt;in(0)-&gt;in(1))) {</span>
<span class="line-added">1810             delay = true;</span>
<span class="line-added">1811           } else if (rc-&gt;in(0)-&gt;in(1)-&gt;in(1) != NULL &amp;&amp;</span>
<span class="line-added">1812                      rc-&gt;in(0)-&gt;in(1)-&gt;in(1)-&gt;is_Cmp()) {</span>
<span class="line-added">1813             if (worklist.member(rc-&gt;in(0)-&gt;in(1)-&gt;in(1))) {</span>
<span class="line-added">1814               delay = true;</span>
<span class="line-added">1815             }</span>
<span class="line-added">1816           }</span>
<span class="line-added">1817         }</span>
<span class="line-added">1818       }</span>
<span class="line-added">1819     }</span>
<span class="line-added">1820   }</span>
<span class="line-added">1821   if (delay) {</span>
<span class="line-added">1822     worklist.push(this);</span>
<span class="line-added">1823   }</span>
<span class="line-added">1824   return delay;</span>
<span class="line-added">1825 }</span>
1826 
1827 //------------------------------Ideal------------------------------------------
1828 // Return a node which is more &quot;ideal&quot; than the current node.  Must preserve
1829 // the CFG, but we can still strip out dead paths.
1830 Node *PhiNode::Ideal(PhaseGVN *phase, bool can_reshape) {
1831   // The next should never happen after 6297035 fix.
1832   if( is_copy() )               // Already degraded to a Copy ?
1833     return NULL;                // No change
1834 
1835   Node *r = in(0);              // RegionNode
1836   assert(r-&gt;in(0) == NULL || !r-&gt;in(0)-&gt;is_Root(), &quot;not a specially hidden merge&quot;);
1837 
1838   // Note: During parsing, phis are often transformed before their regions.
1839   // This means we have to use type_or_null to defend against untyped regions.
1840   if( phase-&gt;type_or_null(r) == Type::TOP ) // Dead code?
1841     return NULL;                // No change
1842 
1843   // If all inputs are value types of the same type, push the value type node down
1844   // through the phi because value type nodes should be merged through their input values.
1845   if (req() &gt; 2 &amp;&amp; in(1) != NULL &amp;&amp; in(1)-&gt;is_ValueTypeBase() &amp;&amp; (can_reshape || in(1)-&gt;is_ValueType())) {
</pre>
<hr />
<pre>
1882         }
1883         // Nuke it down
1884         if (can_reshape) {
1885           set_req_X(j, top, igvn);
1886         } else {
1887           set_req(j, top);
1888         }
1889         progress = this;        // Record progress
1890       }
1891     }
1892   }
1893 
1894   if (can_reshape &amp;&amp; outcnt() == 0) {
1895     // set_req() above may kill outputs if Phi is referenced
1896     // only by itself on the dead (top) control path.
1897     return top;
1898   }
1899 
1900   bool uncasted = false;
1901   Node* uin = unique_input(phase, false);
<span class="line-modified">1902   if (uin == NULL &amp;&amp; can_reshape &amp;&amp;</span>
<span class="line-added">1903       // If there is a chance that the region can be optimized out do</span>
<span class="line-added">1904       // not add a cast node that we can&#39;t remove yet.</span>
<span class="line-added">1905       !wait_for_region_igvn(phase)) {</span>
1906     uncasted = true;
1907     uin = unique_input(phase, true);
1908   }
1909   if (uin == top) {             // Simplest case: no alive inputs.
1910     if (can_reshape)            // IGVN transformation
1911       return top;
1912     else
1913       return NULL;              // Identity will return TOP
1914   } else if (uin != NULL) {
1915     // Only one not-NULL unique input path is left.
1916     // Determine if this input is backedge of a loop.
1917     // (Skip new phis which have no uses and dead regions).
1918     if (outcnt() &gt; 0 &amp;&amp; r-&gt;in(0) != NULL) {
1919       // First, take the short cut when we know it is a loop and
1920       // the EntryControl data path is dead.
1921       // Loop node may have only one input because entry path
1922       // is removed in PhaseIdealLoop::Dominators().
1923       assert(!r-&gt;is_Loop() || r-&gt;req() &lt;= 3, &quot;Loop node should have 3 or less inputs&quot;);
1924       bool is_loop = (r-&gt;is_Loop() &amp;&amp; r-&gt;req() == 3);
1925       // Then, check if there is a data loop when phi references itself directly
</pre>
</td>
</tr>
</table>
<center><a href="c2compiler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cfgnode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
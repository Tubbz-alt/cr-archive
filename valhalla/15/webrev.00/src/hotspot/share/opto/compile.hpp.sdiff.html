<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/compile.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gcm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_COMPILE_HPP
  26 #define SHARE_OPTO_COMPILE_HPP
  27 
  28 #include &quot;asm/codeBuffer.hpp&quot;
  29 #include &quot;ci/compilerInterface.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
<span class="line-removed">  31 #include &quot;code/exceptionHandlerTable.hpp&quot;</span>
  32 #include &quot;compiler/compilerOracle.hpp&quot;
  33 #include &quot;compiler/compileBroker.hpp&quot;

  34 #include &quot;libadt/dict.hpp&quot;
  35 #include &quot;libadt/vectset.hpp&quot;
<span class="line-removed">  36 #include &quot;jfr/jfrEvents.hpp&quot;</span>
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;oops/methodData.hpp&quot;
  39 #include &quot;opto/idealGraphPrinter.hpp&quot;
  40 #include &quot;opto/phasetype.hpp&quot;
  41 #include &quot;opto/phase.hpp&quot;
  42 #include &quot;opto/regmask.hpp&quot;
  43 #include &quot;runtime/deoptimization.hpp&quot;
  44 #include &quot;runtime/timerTrace.hpp&quot;
  45 #include &quot;runtime/vmThread.hpp&quot;
  46 #include &quot;utilities/ticks.hpp&quot;
  47 
  48 class AddPNode;
  49 class Block;
  50 class Bundle;
<span class="line-removed">  51 class CallNode;</span>
<span class="line-removed">  52 class C2Compiler;</span>
  53 class CallGenerator;

  54 class CloneMap;
  55 class ConnectionGraph;
  56 class IdealGraphPrinter;
  57 class InlineTree;
  58 class Int_Array;
  59 class Matcher;
  60 class MachConstantNode;
  61 class MachConstantBaseNode;
  62 class MachNode;
  63 class MachOper;
  64 class MachSafePointNode;
  65 class Node;
  66 class Node_Array;
  67 class Node_Notes;
  68 class NodeCloneInfo;
  69 class OptoReg;
  70 class PhaseCFG;
  71 class PhaseGVN;
  72 class PhaseIterGVN;
  73 class PhaseRegAlloc;
  74 class PhaseCCP;
  75 class PhaseCCP_DCE;

  76 class RootNode;
  77 class relocInfo;
  78 class Scope;
  79 class StartNode;
  80 class SafePointNode;
  81 class JVMState;
  82 class Type;
  83 class TypeData;
  84 class TypeInt;
  85 class TypePtr;
  86 class TypeOopPtr;
  87 class TypeFunc;
  88 class ValueTypeBaseNode;
  89 class Unique_Node_List;
  90 class nmethod;
  91 class WarmCallInfo;
  92 class Node_Stack;
  93 struct Final_Reshape_Counts;
  94 
  95 enum LoopOptsMode {
</pre>
<hr />
<pre>
 225     }
 226     void set_element(const Type* e) {
 227       assert(_element == NULL, &quot;&quot;);
 228       _element = e;
 229     }
 230 
 231     BasicType basic_type() const;
 232 
 233     void print_on(outputStream* st) PRODUCT_RETURN;
 234   };
 235 
 236   enum {
 237     logAliasCacheSize = 6,
 238     AliasCacheSize = (1&lt;&lt;logAliasCacheSize)
 239   };
 240   struct AliasCacheEntry { const TypePtr* _adr_type; int _index; };  // simple duple type
 241   enum {
 242     trapHistLength = MethodData::_trap_hist_limit
 243   };
 244 
<span class="line-removed"> 245   // Constant entry of the constant table.</span>
<span class="line-removed"> 246   class Constant {</span>
<span class="line-removed"> 247   private:</span>
<span class="line-removed"> 248     BasicType _type;</span>
<span class="line-removed"> 249     union {</span>
<span class="line-removed"> 250       jvalue    _value;</span>
<span class="line-removed"> 251       Metadata* _metadata;</span>
<span class="line-removed"> 252     } _v;</span>
<span class="line-removed"> 253     int       _offset;         // offset of this constant (in bytes) relative to the constant table base.</span>
<span class="line-removed"> 254     float     _freq;</span>
<span class="line-removed"> 255     bool      _can_be_reused;  // true (default) if the value can be shared with other users.</span>
<span class="line-removed"> 256 </span>
<span class="line-removed"> 257   public:</span>
<span class="line-removed"> 258     Constant() : _type(T_ILLEGAL), _offset(-1), _freq(0.0f), _can_be_reused(true) { _v._value.l = 0; }</span>
<span class="line-removed"> 259     Constant(BasicType type, jvalue value, float freq = 0.0f, bool can_be_reused = true) :</span>
<span class="line-removed"> 260       _type(type),</span>
<span class="line-removed"> 261       _offset(-1),</span>
<span class="line-removed"> 262       _freq(freq),</span>
<span class="line-removed"> 263       _can_be_reused(can_be_reused)</span>
<span class="line-removed"> 264     {</span>
<span class="line-removed"> 265       assert(type != T_METADATA, &quot;wrong constructor&quot;);</span>
<span class="line-removed"> 266       _v._value = value;</span>
<span class="line-removed"> 267     }</span>
<span class="line-removed"> 268     Constant(Metadata* metadata, bool can_be_reused = true) :</span>
<span class="line-removed"> 269       _type(T_METADATA),</span>
<span class="line-removed"> 270       _offset(-1),</span>
<span class="line-removed"> 271       _freq(0.0f),</span>
<span class="line-removed"> 272       _can_be_reused(can_be_reused)</span>
<span class="line-removed"> 273     {</span>
<span class="line-removed"> 274       _v._metadata = metadata;</span>
<span class="line-removed"> 275     }</span>
<span class="line-removed"> 276 </span>
<span class="line-removed"> 277     bool operator==(const Constant&amp; other);</span>
<span class="line-removed"> 278 </span>
<span class="line-removed"> 279     BasicType type()      const    { return _type; }</span>
<span class="line-removed"> 280 </span>
<span class="line-removed"> 281     jint    get_jint()    const    { return _v._value.i; }</span>
<span class="line-removed"> 282     jlong   get_jlong()   const    { return _v._value.j; }</span>
<span class="line-removed"> 283     jfloat  get_jfloat()  const    { return _v._value.f; }</span>
<span class="line-removed"> 284     jdouble get_jdouble() const    { return _v._value.d; }</span>
<span class="line-removed"> 285     jobject get_jobject() const    { return _v._value.l; }</span>
<span class="line-removed"> 286 </span>
<span class="line-removed"> 287     Metadata* get_metadata() const { return _v._metadata; }</span>
<span class="line-removed"> 288 </span>
<span class="line-removed"> 289     int         offset()  const    { return _offset; }</span>
<span class="line-removed"> 290     void    set_offset(int offset) {        _offset = offset; }</span>
<span class="line-removed"> 291 </span>
<span class="line-removed"> 292     float       freq()    const    { return _freq;         }</span>
<span class="line-removed"> 293     void    inc_freq(float freq)   {        _freq += freq; }</span>
<span class="line-removed"> 294 </span>
<span class="line-removed"> 295     bool    can_be_reused() const  { return _can_be_reused; }</span>
<span class="line-removed"> 296   };</span>
<span class="line-removed"> 297 </span>
<span class="line-removed"> 298   // Constant table.</span>
<span class="line-removed"> 299   class ConstantTable {</span>
<span class="line-removed"> 300   private:</span>
<span class="line-removed"> 301     GrowableArray&lt;Constant&gt; _constants;          // Constants of this table.</span>
<span class="line-removed"> 302     int                     _size;               // Size in bytes the emitted constant table takes (including padding).</span>
<span class="line-removed"> 303     int                     _table_base_offset;  // Offset of the table base that gets added to the constant offsets.</span>
<span class="line-removed"> 304     int                     _nof_jump_tables;    // Number of jump-tables in this constant table.</span>
<span class="line-removed"> 305 </span>
<span class="line-removed"> 306     static int qsort_comparator(Constant* a, Constant* b);</span>
<span class="line-removed"> 307 </span>
<span class="line-removed"> 308     // We use negative frequencies to keep the order of the</span>
<span class="line-removed"> 309     // jump-tables in which they were added.  Otherwise we get into</span>
<span class="line-removed"> 310     // trouble with relocation.</span>
<span class="line-removed"> 311     float next_jump_table_freq() { return -1.0f * (++_nof_jump_tables); }</span>
<span class="line-removed"> 312 </span>
<span class="line-removed"> 313   public:</span>
<span class="line-removed"> 314     ConstantTable() :</span>
<span class="line-removed"> 315       _size(-1),</span>
<span class="line-removed"> 316       _table_base_offset(-1),  // We can use -1 here since the constant table is always bigger than 2 bytes (-(size / 2), see MachConstantBaseNode::emit).</span>
<span class="line-removed"> 317       _nof_jump_tables(0)</span>
<span class="line-removed"> 318     {}</span>
<span class="line-removed"> 319 </span>
<span class="line-removed"> 320     int size() const { assert(_size != -1, &quot;not calculated yet&quot;); return _size; }</span>
<span class="line-removed"> 321 </span>
<span class="line-removed"> 322     int calculate_table_base_offset() const;  // AD specific</span>
<span class="line-removed"> 323     void set_table_base_offset(int x)  { assert(_table_base_offset == -1 || x == _table_base_offset, &quot;can&#39;t change&quot;); _table_base_offset = x; }</span>
<span class="line-removed"> 324     int      table_base_offset() const { assert(_table_base_offset != -1, &quot;not set yet&quot;);                      return _table_base_offset; }</span>
<span class="line-removed"> 325 </span>
<span class="line-removed"> 326     void emit(CodeBuffer&amp; cb);</span>
<span class="line-removed"> 327 </span>
<span class="line-removed"> 328     // Returns the offset of the last entry (the top) of the constant table.</span>
<span class="line-removed"> 329     int  top_offset() const { assert(_constants.top().offset() != -1, &quot;not bound yet&quot;); return _constants.top().offset(); }</span>
<span class="line-removed"> 330 </span>
<span class="line-removed"> 331     void calculate_offsets_and_size();</span>
<span class="line-removed"> 332     int  find_offset(Constant&amp; con) const;</span>
<span class="line-removed"> 333 </span>
<span class="line-removed"> 334     void     add(Constant&amp; con);</span>
<span class="line-removed"> 335     Constant add(MachConstantNode* n, BasicType type, jvalue value);</span>
<span class="line-removed"> 336     Constant add(Metadata* metadata);</span>
<span class="line-removed"> 337     Constant add(MachConstantNode* n, MachOper* oper);</span>
<span class="line-removed"> 338     Constant add(MachConstantNode* n, jint i) {</span>
<span class="line-removed"> 339       jvalue value; value.i = i;</span>
<span class="line-removed"> 340       return add(n, T_INT, value);</span>
<span class="line-removed"> 341     }</span>
<span class="line-removed"> 342     Constant add(MachConstantNode* n, jlong j) {</span>
<span class="line-removed"> 343       jvalue value; value.j = j;</span>
<span class="line-removed"> 344       return add(n, T_LONG, value);</span>
<span class="line-removed"> 345     }</span>
<span class="line-removed"> 346     Constant add(MachConstantNode* n, jfloat f) {</span>
<span class="line-removed"> 347       jvalue value; value.f = f;</span>
<span class="line-removed"> 348       return add(n, T_FLOAT, value);</span>
<span class="line-removed"> 349     }</span>
<span class="line-removed"> 350     Constant add(MachConstantNode* n, jdouble d) {</span>
<span class="line-removed"> 351       jvalue value; value.d = d;</span>
<span class="line-removed"> 352       return add(n, T_DOUBLE, value);</span>
<span class="line-removed"> 353     }</span>
<span class="line-removed"> 354 </span>
<span class="line-removed"> 355     // Jump-table</span>
<span class="line-removed"> 356     Constant  add_jump_table(MachConstantNode* n);</span>
<span class="line-removed"> 357     void     fill_jump_table(CodeBuffer&amp; cb, MachConstantNode* n, GrowableArray&lt;Label*&gt; labels) const;</span>
<span class="line-removed"> 358   };</span>
<span class="line-removed"> 359 </span>
 360  private:
 361   // Fixed parameters to this compilation.
 362   const int             _compile_id;
 363   const bool            _save_argument_registers; // save/restore arg regs for trampolines
 364   const bool            _subsume_loads;         // Load can be matched as part of a larger op.
 365   const bool            _do_escape_analysis;    // Do escape analysis.
 366   const bool            _eliminate_boxing;      // Do boxing elimination.
 367   ciMethod*             _method;                // The method being compiled.
 368   int                   _entry_bci;             // entry bci for osr methods.
 369   const TypeFunc*       _tf;                    // My kind of signature
 370   InlineTree*           _ilt;                   // Ditto (temporary).
 371   address               _stub_function;         // VM entry for stub being compiled, or NULL
 372   const char*           _stub_name;             // Name of stub or adapter being compiled, or NULL
 373   address               _stub_entry_point;      // Compile code entry for generated stub, or NULL
 374 
 375   // Control of this compilation.
 376   int                   _max_inline_size;       // Max inline size for this compilation
 377   int                   _freq_inline_size;      // Max hot method inline size for this compilation
 378   int                   _fixed_slots;           // count of frame slots not allocated by the register
 379                                                 // allocator i.e. locks, original deopt pc, etc.
 380   uintx                 _max_node_limit;        // Max unique node count during a single compilation.
<span class="line-removed"> 381   // For deopt</span>
<span class="line-removed"> 382   int                   _orig_pc_slot;</span>
<span class="line-removed"> 383   int                   _orig_pc_slot_offset_in_bytes;</span>
<span class="line-removed"> 384 </span>
<span class="line-removed"> 385   // For value type calling convention</span>
<span class="line-removed"> 386   int                   _sp_inc_slot;</span>
<span class="line-removed"> 387   int                   _sp_inc_slot_offset_in_bytes;</span>
 388 
 389   int                   _major_progress;        // Count of something big happening
 390   bool                  _inlining_progress;     // progress doing incremental inlining?
 391   bool                  _inlining_incrementally;// Are we doing incremental inlining (post parse)
 392   bool                  _do_cleanup;            // Cleanup is needed before proceeding with incremental inlining
 393   bool                  _has_loops;             // True if the method _may_ have some loops
 394   bool                  _has_split_ifs;         // True if the method _may_ have some split-if
 395   bool                  _has_unsafe_access;     // True if the method _may_ produce faults in unsafe loads or stores.
 396   bool                  _has_stringbuilder;     // True StringBuffers or StringBuilders are allocated
 397   bool                  _has_boxed_value;       // True if a boxed object is allocated
 398   bool                  _has_reserved_stack_access; // True if the method or an inlined method is annotated with ReservedStackAccess
 399   uint                  _max_vector_size;       // Maximum size of generated vectors
 400   bool                  _clear_upper_avx;       // Clear upper bits of ymm registers using vzeroupper
 401   uint                  _trap_hist[trapHistLength];  // Cumulative traps
 402   bool                  _trap_can_recompile;    // Have we emitted a recompiling trap?
 403   uint                  _decompile_count;       // Cumulative decompilation counts.
 404   bool                  _do_inlining;           // True if we intend to do inlining
 405   bool                  _do_scheduling;         // True if we intend to do scheduling
 406   bool                  _do_freq_based_layout;  // True if we intend to do frequency based block layout
 407   bool                  _do_count_invocations;  // True if we generate code to count invocations
</pre>
<hr />
<pre>
 449 
 450   // Node management
 451   uint                  _unique;                // Counter for unique Node indices
 452   VectorSet             _dead_node_list;        // Set of dead nodes
 453   uint                  _dead_node_count;       // Number of dead nodes; VectorSet::Size() is O(N).
 454                                                 // So use this to keep count and make the call O(1).
 455   DEBUG_ONLY( Unique_Node_List* _modified_nodes; )  // List of nodes which inputs were modified
 456 
 457   debug_only(static int _debug_idx;)            // Monotonic counter (not reset), use -XX:BreakAtNode=&lt;idx&gt;
 458   Arena                 _node_arena;            // Arena for new-space Nodes
 459   Arena                 _old_arena;             // Arena for old-space Nodes, lifetime during xform
 460   RootNode*             _root;                  // Unique root of compilation, or NULL after bail-out.
 461   Node*                 _top;                   // Unique top node.  (Reset by various phases.)
 462 
 463   Node*                 _immutable_memory;      // Initial memory state
 464 
 465   Node*                 _recent_alloc_obj;
 466   Node*                 _recent_alloc_ctl;
 467 
 468   // Constant table
<span class="line-removed"> 469   ConstantTable         _constant_table;        // The constant table for this compile.</span>
 470   MachConstantBaseNode* _mach_constant_base_node;  // Constant table base node singleton.
 471 
 472 
 473   // Blocked array of debugging and profiling information,
 474   // tracked per node.
 475   enum { _log2_node_notes_block_size = 8,
 476          _node_notes_block_size = (1&lt;&lt;_log2_node_notes_block_size)
 477   };
 478   GrowableArray&lt;Node_Notes*&gt;* _node_note_array;
 479   Node_Notes*           _default_node_notes;  // default notes for new nodes
 480 
 481   // After parsing and every bulk phase we hang onto the Root instruction.
 482   // The RootNode instruction is where the whole program begins.  It produces
 483   // the initial Control and BOTTOM for everybody else.
 484 
 485   // Type management
 486   Arena                 _Compile_types;         // Arena for all types
 487   Arena*                _type_arena;            // Alias for _Compile_types except in Initialize_shared()
 488   Dict*                 _type_dict;             // Intern table
 489   CloneMap              _clone_map;             // used for recording history of cloned nodes
</pre>
<hr />
<pre>
 578 #ifndef PRODUCT
 579   IdealGraphPrinter* printer() { return _printer; }
 580 #endif
 581 
 582   void log_late_inline(CallGenerator* cg);
 583   void log_inline_id(CallGenerator* cg);
 584   void log_inline_failure(const char* msg);
 585 
 586   void* replay_inline_data() const { return _replay_inline_data; }
 587 
 588   // Dump inlining replay data to the stream.
 589   void dump_inline_data(outputStream* out);
 590 
 591  private:
 592   // Matching, CFG layout, allocation, code generation
 593   PhaseCFG*             _cfg;                   // Results of CFG finding
 594   int                   _java_calls;            // Number of java calls in the method
 595   int                   _inner_loops;           // Number of inner loops in the method
 596   Matcher*              _matcher;               // Engine to map ideal to machine instructions
 597   PhaseRegAlloc*        _regalloc;              // Results of register allocation.
<span class="line-removed"> 598   int                   _frame_slots;           // Size of total frame in stack slots</span>
<span class="line-removed"> 599   CodeOffsets           _code_offsets;          // Offsets into the code for various interesting entries</span>
 600   RegMask               _FIRST_STACK_mask;      // All stack slots usable for spills (depends on frame layout)
 601   Arena*                _indexSet_arena;        // control IndexSet allocation within PhaseChaitin
 602   void*                 _indexSet_free_block_list; // free list of IndexSet bit blocks
 603   int                   _interpreter_frame_size;
 604 
<span class="line-modified"> 605   uint                  _node_bundling_limit;</span>
<span class="line-removed"> 606   Bundle*               _node_bundling_base;    // Information for instruction bundling</span>
<span class="line-removed"> 607 </span>
<span class="line-removed"> 608   // Instruction bits passed off to the VM</span>
<span class="line-removed"> 609   int                   _method_size;           // Size of nmethod code segment in bytes</span>
<span class="line-removed"> 610   CodeBuffer            _code_buffer;           // Where the code is assembled</span>
<span class="line-removed"> 611   int                   _first_block_size;      // Size of unvalidated entry point code / OSR poison code</span>
<span class="line-removed"> 612   ExceptionHandlerTable _handler_table;         // Table of native-code exception handlers</span>
<span class="line-removed"> 613   ImplicitExceptionTable _inc_table;            // Table of implicit null checks in native code</span>
<span class="line-removed"> 614   OopMapSet*            _oop_map_set;           // Table of oop maps (one for each safepoint location)</span>
<span class="line-removed"> 615   static int            _CompiledZap_count;     // counter compared against CompileZap[First/Last]</span>
<span class="line-removed"> 616   BufferBlob*           _scratch_buffer_blob;   // For temporary code buffers.</span>
<span class="line-removed"> 617   relocInfo*            _scratch_locs_memory;   // For temporary code buffers.</span>
<span class="line-removed"> 618   int                   _scratch_const_size;    // For temporary code buffers.</span>
<span class="line-removed"> 619   bool                  _in_scratch_emit_size;  // true when in scratch_emit_size.</span>
 620 
 621   void reshape_address(AddPNode* n);
 622 
 623  public:
 624   // Accessors
 625 
 626   // The Compile instance currently active in this (compiler) thread.
 627   static Compile* current() {
 628     return (Compile*) ciEnv::current()-&gt;compiler_data();
 629   }
 630 





 631   // ID for this compilation.  Useful for setting breakpoints in the debugger.
 632   int               compile_id() const          { return _compile_id; }
 633   DirectiveSet*     directive() const           { return _directive; }
 634 
 635   // Does this compilation allow instructions to subsume loads?  User
 636   // instructions that subsume a load may result in an unschedulable
 637   // instruction sequence.
 638   bool              subsume_loads() const       { return _subsume_loads; }
 639   /** Do escape analysis. */
 640   bool              do_escape_analysis() const  { return _do_escape_analysis; }
 641   /** Do boxing elimination. */
 642   bool              eliminate_boxing() const    { return _eliminate_boxing; }
 643   /** Do aggressive boxing elimination. */
 644   bool              aggressive_unboxing() const { return _eliminate_boxing &amp;&amp; AggressiveUnboxing; }
 645   bool              save_argument_registers() const { return _save_argument_registers; }
 646 
 647 
 648   // Other fixed compilation parameters.
 649   ciMethod*         method() const              { return _method; }
 650   int               entry_bci() const           { return _entry_bci; }
 651   bool              is_osr_compilation() const  { return _entry_bci != InvocationEntryBci; }
 652   bool              is_method_compilation() const { return (_method != NULL &amp;&amp; !_method-&gt;flags().is_native()); }
 653   const TypeFunc*   tf() const                  { assert(_tf!=NULL, &quot;&quot;); return _tf; }
 654   void         init_tf(const TypeFunc* tf)      { assert(_tf==NULL, &quot;&quot;); _tf = tf; }
 655   InlineTree*       ilt() const                 { return _ilt; }
 656   address           stub_function() const       { return _stub_function; }
 657   const char*       stub_name() const           { return _stub_name; }
 658   address           stub_entry_point() const    { return _stub_entry_point; }

 659 
 660   // Control of this compilation.
 661   int               fixed_slots() const         { assert(_fixed_slots &gt;= 0, &quot;&quot;);         return _fixed_slots; }
 662   void          set_fixed_slots(int n)          { _fixed_slots = n; }
 663   int               major_progress() const      { return _major_progress; }
 664   void          set_inlining_progress(bool z)   { _inlining_progress = z; }
 665   int               inlining_progress() const   { return _inlining_progress; }
 666   void          set_inlining_incrementally(bool z) { _inlining_incrementally = z; }
 667   int               inlining_incrementally() const { return _inlining_incrementally; }
 668   void          set_do_cleanup(bool z)          { _do_cleanup = z; }
 669   int               do_cleanup() const          { return _do_cleanup; }
 670   void          set_major_progress()            { _major_progress++; }
 671   void          restore_major_progress(int progress) { _major_progress += progress; }
 672   void        clear_major_progress()            { _major_progress = 0; }
 673   int               max_inline_size() const     { return _max_inline_size; }
 674   void          set_freq_inline_size(int n)     { _freq_inline_size = n; }
 675   int               freq_inline_size() const    { return _freq_inline_size; }
 676   void          set_max_inline_size(int n)      { _max_inline_size = n; }
 677   bool              has_loops() const           { return _has_loops; }
 678   void          set_has_loops(bool z)           { _has_loops = z; }
</pre>
<hr />
<pre>
 718   void          set_print_assembly(bool z)       { _print_assembly = z; }
 719   bool              print_inlining() const       { return _print_inlining; }
 720   void          set_print_inlining(bool z)       { _print_inlining = z; }
 721   bool              print_intrinsics() const     { return _print_intrinsics; }
 722   void          set_print_intrinsics(bool z)     { _print_intrinsics = z; }
 723   RTMState          rtm_state()  const           { return _rtm_state; }
 724   void          set_rtm_state(RTMState s)        { _rtm_state = s; }
 725   bool              use_rtm() const              { return (_rtm_state &amp; NoRTM) == 0; }
 726   bool          profile_rtm() const              { return _rtm_state == ProfileRTM; }
 727   uint              max_node_limit() const       { return (uint)_max_node_limit; }
 728   void          set_max_node_limit(uint n)       { _max_node_limit = n; }
 729   bool              clinit_barrier_on_entry()       { return _clinit_barrier_on_entry; }
 730   void          set_clinit_barrier_on_entry(bool z) { _clinit_barrier_on_entry = z; }
 731   void          set_flattened_accesses()         { _has_flattened_accesses = true; }
 732   bool          flattened_accesses_share_alias() const { return _flattened_accesses_share_alias; }
 733   void          set_flattened_accesses_share_alias(bool z) { _flattened_accesses_share_alias = z; }
 734 
 735   // Support for scalarized value type calling convention
 736   bool              has_scalarized_args() const  { return _method != NULL &amp;&amp; _method-&gt;has_scalarized_args(); }
 737   bool              needs_stack_repair()  const  { return _method != NULL &amp;&amp; _method-&gt;get_Method()-&gt;c2_needs_stack_repair(); }
<span class="line-removed"> 738   int               sp_inc_offset()       const  { return _sp_inc_slot_offset_in_bytes; }</span>
 739 
 740   // check the CompilerOracle for special behaviours for this compile
 741   bool          method_has_option(const char * option) {
 742     return method() != NULL &amp;&amp; method()-&gt;has_option(option);
 743   }
 744 
 745 #ifndef PRODUCT
 746   bool          trace_opto_output() const       { return _trace_opto_output; }
 747   bool          print_ideal() const             { return _print_ideal; }
 748   bool              parsed_irreducible_loop() const { return _parsed_irreducible_loop; }
 749   void          set_parsed_irreducible_loop(bool z) { _parsed_irreducible_loop = z; }
 750   int _in_dump_cnt;  // Required for dumping ir nodes.
 751 #endif
 752   bool              has_irreducible_loop() const { return _has_irreducible_loop; }
 753   void          set_has_irreducible_loop(bool z) { _has_irreducible_loop = z; }
 754 
 755   // JSR 292
 756   bool              has_method_handle_invokes() const { return _has_method_handle_invokes;     }
 757   void          set_has_method_handle_invokes(bool z) {        _has_method_handle_invokes = z; }
 758 
</pre>
<hr />
<pre>
 761   void begin_method() {
 762 #ifndef PRODUCT
 763     if (_printer &amp;&amp; _printer-&gt;should_print(1)) {
 764       _printer-&gt;begin_method();
 765     }
 766 #endif
 767     C-&gt;_latest_stage_start_counter.stamp();
 768   }
 769 
 770   bool should_print(int level = 1) {
 771 #ifndef PRODUCT
 772     return (_printer &amp;&amp; _printer-&gt;should_print(level));
 773 #else
 774     return false;
 775 #endif
 776   }
 777 
 778   void print_method(CompilerPhaseType cpt, int level = 1, int idx = 0) {
 779     EventCompilerPhase event;
 780     if (event.should_commit()) {
<span class="line-modified"> 781       event.set_starttime(C-&gt;_latest_stage_start_counter);</span>
<span class="line-removed"> 782       event.set_phase((u1) cpt);</span>
<span class="line-removed"> 783       event.set_compileId(C-&gt;_compile_id);</span>
<span class="line-removed"> 784       event.set_phaseLevel(level);</span>
<span class="line-removed"> 785       event.commit();</span>
 786     }
 787 
 788 #ifndef PRODUCT
 789     if (should_print(level)) {
 790       char output[1024];
 791       if (idx != 0) {
 792         sprintf(output, &quot;%s:%d&quot;, CompilerPhaseTypeHelper::to_string(cpt), idx);
 793       } else {
 794         sprintf(output, &quot;%s&quot;, CompilerPhaseTypeHelper::to_string(cpt));
 795       }
 796       _printer-&gt;print_method(output, level);
 797     }
 798 #endif
 799     C-&gt;_latest_stage_start_counter.stamp();
 800   }
 801 
 802   void end_method(int level = 1) {
 803     EventCompilerPhase event;
 804     if (event.should_commit()) {
<span class="line-modified"> 805       event.set_starttime(C-&gt;_latest_stage_start_counter);</span>
<span class="line-removed"> 806       event.set_phase((u1) PHASE_END);</span>
<span class="line-removed"> 807       event.set_compileId(C-&gt;_compile_id);</span>
<span class="line-removed"> 808       event.set_phaseLevel(level);</span>
<span class="line-removed"> 809       event.commit();</span>
 810     }

 811 #ifndef PRODUCT
 812     if (_printer &amp;&amp; _printer-&gt;should_print(level)) {
 813       _printer-&gt;end_method();
 814     }
 815 #endif
 816   }
 817 
 818   int           macro_count()             const { return _macro_nodes-&gt;length(); }
 819   int           predicate_count()         const { return _predicate_opaqs-&gt;length();}
 820   int           expensive_count()         const { return _expensive_nodes-&gt;length(); }
 821   Node*         macro_node(int idx)       const { return _macro_nodes-&gt;at(idx); }
 822   Node*         predicate_opaque1_node(int idx) const { return _predicate_opaqs-&gt;at(idx);}
 823   Node*         expensive_node(int idx)   const { return _expensive_nodes-&gt;at(idx); }
 824   ConnectionGraph* congraph()                   { return _congraph;}
 825   void set_congraph(ConnectionGraph* congraph)  { _congraph = congraph;}
 826   void add_macro_node(Node * n) {
 827     //assert(n-&gt;is_macro(), &quot;must be a macro node&quot;);
 828     assert(!_macro_nodes-&gt;contains(n), &quot;duplicate entry in expand list&quot;);
 829     _macro_nodes-&gt;append(n);
 830   }
</pre>
<hr />
<pre>
 945                                              _dead_node_count++;
 946                                            }
 947   void         reset_dead_node_list()      { _dead_node_list.reset();
 948                                              _dead_node_count = 0;
 949                                            }
 950   uint          live_nodes() const         {
 951     int  val = _unique - _dead_node_count;
 952     assert (val &gt;= 0, &quot;number of tracked dead nodes %d more than created nodes %d&quot;, _unique, _dead_node_count);
 953             return (uint) val;
 954                                            }
 955 #ifdef ASSERT
 956   uint         count_live_nodes_by_graph_walk();
 957   void         print_missing_nodes();
 958 #endif
 959 
 960   // Record modified nodes to check that they are put on IGVN worklist
 961   void         record_modified_node(Node* n) NOT_DEBUG_RETURN;
 962   void         remove_modified_node(Node* n) NOT_DEBUG_RETURN;
 963   DEBUG_ONLY( Unique_Node_List*   modified_nodes() const { return _modified_nodes; } )
 964 
<span class="line-removed"> 965   // Constant table</span>
<span class="line-removed"> 966   ConstantTable&amp;   constant_table() { return _constant_table; }</span>
<span class="line-removed"> 967 </span>
 968   MachConstantBaseNode*     mach_constant_base_node();
 969   bool                  has_mach_constant_base_node() const { return _mach_constant_base_node != NULL; }
 970   // Generated by adlc, true if CallNode requires MachConstantBase.
 971   bool                      needs_clone_jvms();
 972 
 973   // Handy undefined Node
 974   Node*             top() const                 { return _top; }
 975 
 976   // these are used by guys who need to know about creation and transformation of top:
 977   Node*             cached_top_node()           { return _top; }
 978   void          set_cached_top_node(Node* tn);
 979 
 980   GrowableArray&lt;Node_Notes*&gt;* node_note_array() const { return _node_note_array; }
 981   void set_node_note_array(GrowableArray&lt;Node_Notes*&gt;* arr) { _node_note_array = arr; }
 982   Node_Notes* default_node_notes() const        { return _default_node_notes; }
 983   void    set_default_node_notes(Node_Notes* n) { _default_node_notes = n; }
 984 
 985   Node_Notes*       node_notes_at(int idx) {
 986     return locate_node_notes(_node_note_array, idx, false);
 987   }
</pre>
<hr />
<pre>
1133 
1134   void inc_number_of_mh_late_inlines() { _number_of_mh_late_inlines++; }
1135   void dec_number_of_mh_late_inlines() { assert(_number_of_mh_late_inlines &gt; 0, &quot;_number_of_mh_late_inlines &lt; 0 !&quot;); _number_of_mh_late_inlines--; }
1136   bool has_mh_late_inlines() const     { return _number_of_mh_late_inlines &gt; 0; }
1137 
1138   bool inline_incrementally_one();
1139   void inline_incrementally_cleanup(PhaseIterGVN&amp; igvn);
1140   void inline_incrementally(PhaseIterGVN&amp; igvn);
1141   void inline_string_calls(bool parse_time);
1142   void inline_boxing_calls(PhaseIterGVN&amp; igvn);
1143   bool optimize_loops(PhaseIterGVN&amp; igvn, LoopOptsMode mode);
1144   void remove_root_to_sfpts_edges(PhaseIterGVN&amp; igvn);
1145 
1146   // Matching, CFG layout, allocation, code generation
1147   PhaseCFG*         cfg()                       { return _cfg; }
1148   bool              has_java_calls() const      { return _java_calls &gt; 0; }
1149   int               java_calls() const          { return _java_calls; }
1150   int               inner_loops() const         { return _inner_loops; }
1151   Matcher*          matcher()                   { return _matcher; }
1152   PhaseRegAlloc*    regalloc()                  { return _regalloc; }
<span class="line-removed">1153   int               frame_slots() const         { return _frame_slots; }</span>
<span class="line-removed">1154   int               frame_size_in_words() const; // frame_slots in units of the polymorphic &#39;words&#39;</span>
<span class="line-removed">1155   int               frame_size_in_bytes() const { return _frame_slots &lt;&lt; LogBytesPerInt; }</span>
1156   RegMask&amp;          FIRST_STACK_mask()          { return _FIRST_STACK_mask; }
1157   Arena*            indexSet_arena()            { return _indexSet_arena; }
1158   void*             indexSet_free_block_list()  { return _indexSet_free_block_list; }
<span class="line-modified">1159   uint              node_bundling_limit()       { return _node_bundling_limit; }</span>
<span class="line-removed">1160   Bundle*           node_bundling_base()        { return _node_bundling_base; }</span>
<span class="line-removed">1161   void          set_node_bundling_limit(uint n) { _node_bundling_limit = n; }</span>
<span class="line-removed">1162   void          set_node_bundling_base(Bundle* b) { _node_bundling_base = b; }</span>
<span class="line-removed">1163   bool          starts_bundle(const Node *n) const;</span>
<span class="line-removed">1164   bool          need_stack_bang(int frame_size_in_bytes) const;</span>
<span class="line-removed">1165   bool          need_register_stack_bang() const;</span>
1166 
1167   void  update_interpreter_frame_size(int size) {
1168     if (_interpreter_frame_size &lt; size) {
1169       _interpreter_frame_size = size;
1170     }
1171   }
<span class="line-removed">1172   int           bang_size_in_bytes() const;</span>
1173 
1174   void          set_matcher(Matcher* m)                 { _matcher = m; }
1175 //void          set_regalloc(PhaseRegAlloc* ra)           { _regalloc = ra; }
1176   void          set_indexSet_arena(Arena* a)            { _indexSet_arena = a; }
1177   void          set_indexSet_free_block_list(void* p)   { _indexSet_free_block_list = p; }
1178 
1179   void  set_java_calls(int z) { _java_calls  = z; }
1180   void set_inner_loops(int z) { _inner_loops = z; }
1181 
<span class="line-modified">1182   // Instruction bits passed off to the VM</span>
<span class="line-removed">1183   int               code_size()                 { return _method_size; }</span>
<span class="line-removed">1184   CodeBuffer*       code_buffer()               { return &amp;_code_buffer; }</span>
<span class="line-removed">1185   int               first_block_size()          { return _first_block_size; }</span>
<span class="line-removed">1186   void              set_frame_complete(int off) { if (!in_scratch_emit_size()) { _code_offsets.set_value(CodeOffsets::Frame_Complete, off); } }</span>
<span class="line-removed">1187   ExceptionHandlerTable*  handler_table()       { return &amp;_handler_table; }</span>
<span class="line-removed">1188   ImplicitExceptionTable* inc_table()           { return &amp;_inc_table; }</span>
<span class="line-removed">1189   OopMapSet*        oop_map_set()               { return _oop_map_set; }</span>
<span class="line-removed">1190   DebugInformationRecorder* debug_info()        { return env()-&gt;debug_info(); }</span>
<span class="line-removed">1191   Dependencies*     dependencies()              { return env()-&gt;dependencies(); }</span>
<span class="line-removed">1192   static int        CompiledZap_count()         { return _CompiledZap_count; }</span>
<span class="line-removed">1193   BufferBlob*       scratch_buffer_blob()       { return _scratch_buffer_blob; }</span>
<span class="line-removed">1194   void         init_scratch_buffer_blob(int const_size);</span>
<span class="line-removed">1195   void        clear_scratch_buffer_blob();</span>
<span class="line-removed">1196   void          set_scratch_buffer_blob(BufferBlob* b) { _scratch_buffer_blob = b; }</span>
<span class="line-removed">1197   relocInfo*        scratch_locs_memory()       { return _scratch_locs_memory; }</span>
<span class="line-removed">1198   void          set_scratch_locs_memory(relocInfo* b)  { _scratch_locs_memory = b; }</span>
<span class="line-removed">1199 </span>
<span class="line-removed">1200   // emit to scratch blob, report resulting size</span>
<span class="line-removed">1201   uint              scratch_emit_size(const Node* n);</span>
<span class="line-removed">1202   void       set_in_scratch_emit_size(bool x)   {        _in_scratch_emit_size = x; }</span>
<span class="line-removed">1203   bool           in_scratch_emit_size() const   { return _in_scratch_emit_size;     }</span>
<span class="line-removed">1204 </span>
<span class="line-removed">1205   enum ScratchBufferBlob {</span>
<span class="line-removed">1206     MAX_inst_size       = 2048,</span>
<span class="line-removed">1207     MAX_locs_size       = 128, // number of relocInfo elements</span>
<span class="line-removed">1208     MAX_const_size      = 128,</span>
<span class="line-removed">1209     MAX_stubs_size      = 128</span>
<span class="line-removed">1210   };</span>
1211 
1212   // Major entry point.  Given a Scope, compile the associated method.
1213   // For normal compilations, entry_bci is InvocationEntryBci.  For on stack
1214   // replacement, entry_bci indicates the bytecode for which to compile a
1215   // continuation.
<span class="line-modified">1216   Compile(ciEnv* ci_env, C2Compiler* compiler, ciMethod* target,</span>
1217           int entry_bci, bool subsume_loads, bool do_escape_analysis,
1218           bool eliminate_boxing, DirectiveSet* directive);
1219 
1220   // Second major entry point.  From the TypeFunc signature, generate code
1221   // to pass arguments from the Java calling convention to the C calling
1222   // convention.
1223   Compile(ciEnv* ci_env, const TypeFunc *(*gen)(),
1224           address stub_function, const char *stub_name,
1225           int is_fancy_jump, bool pass_tls,
1226           bool save_arg_registers, bool return_pc, DirectiveSet* directive);
1227 
1228   // From the TypeFunc signature, generate code to pass arguments
1229   // from Compiled calling convention to Interpreter&#39;s calling convention
1230   void Generate_Compiled_To_Interpreter_Graph(const TypeFunc *tf, address interpreter_entry);
1231 
1232   // From the TypeFunc signature, generate code to pass arguments
1233   // from Interpreter&#39;s calling convention to Compiler&#39;s calling convention
1234   void Generate_Interpreter_To_Compiled_Graph(const TypeFunc *tf);
1235 
1236   // Are we compiling a method?
1237   bool has_method() { return method() != NULL; }
1238 
1239   // Maybe print some information about this compile.
1240   void print_compile_messages();
1241 
1242   // Final graph reshaping, a post-pass after the regular optimizer is done.
1243   bool final_graph_reshaping();
1244 
1245   // returns true if adr is completely contained in the given alias category
1246   bool must_alias(const TypePtr* adr, int alias_idx);
1247 
1248   // returns true if adr overlaps with the given alias category
1249   bool can_alias(const TypePtr* adr, int alias_idx);
1250 
<span class="line-removed">1251   // Driver for converting compiler&#39;s IR into machine code bits</span>
<span class="line-removed">1252   void Output();</span>
<span class="line-removed">1253 </span>
<span class="line-removed">1254   // Accessors for node bundling info.</span>
<span class="line-removed">1255   Bundle* node_bundling(const Node *n);</span>
<span class="line-removed">1256   bool valid_bundle_info(const Node *n);</span>
<span class="line-removed">1257 </span>
<span class="line-removed">1258   // Schedule and Bundle the instructions</span>
<span class="line-removed">1259   void ScheduleAndBundle();</span>
<span class="line-removed">1260 </span>
<span class="line-removed">1261   // Build OopMaps for each GC point</span>
<span class="line-removed">1262   void BuildOopMaps();</span>
<span class="line-removed">1263 </span>
<span class="line-removed">1264   // Append debug info for the node &quot;local&quot; at safepoint node &quot;sfpt&quot; to the</span>
<span class="line-removed">1265   // &quot;array&quot;,   May also consult and add to &quot;objs&quot;, which describes the</span>
<span class="line-removed">1266   // scalar-replaced objects.</span>
<span class="line-removed">1267   void FillLocArray( int idx, MachSafePointNode* sfpt,</span>
<span class="line-removed">1268                      Node *local, GrowableArray&lt;ScopeValue*&gt; *array,</span>
<span class="line-removed">1269                      GrowableArray&lt;ScopeValue*&gt; *objs );</span>
<span class="line-removed">1270 </span>
1271   // If &quot;objs&quot; contains an ObjectValue whose id is &quot;id&quot;, returns it, else NULL.
1272   static ObjectValue* sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id);
<span class="line-removed">1273   // Requres that &quot;objs&quot; does not contains an ObjectValue whose id matches</span>
<span class="line-removed">1274   // that of &quot;sv.  Appends &quot;sv&quot;.</span>
<span class="line-removed">1275   static void set_sv_for_object_node(GrowableArray&lt;ScopeValue*&gt; *objs,</span>
<span class="line-removed">1276                                      ObjectValue* sv );</span>
<span class="line-removed">1277 </span>
<span class="line-removed">1278   // Process an OopMap Element while emitting nodes</span>
<span class="line-removed">1279   void Process_OopMap_Node(MachNode *mach, int code_offset);</span>
<span class="line-removed">1280 </span>
<span class="line-removed">1281   class BufferSizingData {</span>
<span class="line-removed">1282   public:</span>
<span class="line-removed">1283     int _stub;</span>
<span class="line-removed">1284     int _code;</span>
<span class="line-removed">1285     int _const;</span>
<span class="line-removed">1286     int _reloc;</span>
<span class="line-removed">1287 </span>
<span class="line-removed">1288       BufferSizingData() :</span>
<span class="line-removed">1289       _stub(0),</span>
<span class="line-removed">1290       _code(0),</span>
<span class="line-removed">1291       _const(0),</span>
<span class="line-removed">1292       _reloc(0)</span>
<span class="line-removed">1293       { };</span>
<span class="line-removed">1294   };</span>
<span class="line-removed">1295 </span>
<span class="line-removed">1296   // Initialize code buffer</span>
<span class="line-removed">1297   void        estimate_buffer_size(int&amp; const_req);</span>
<span class="line-removed">1298   CodeBuffer* init_buffer(BufferSizingData&amp; buf_sizes);</span>
<span class="line-removed">1299 </span>
<span class="line-removed">1300   // Write out basic block data to code buffer</span>
<span class="line-removed">1301   void fill_buffer(CodeBuffer* cb, uint* blk_starts);</span>
<span class="line-removed">1302 </span>
<span class="line-removed">1303   // Determine which variable sized branches can be shortened</span>
<span class="line-removed">1304   void shorten_branches(uint* blk_starts, BufferSizingData&amp; buf_sizes);</span>
<span class="line-removed">1305 </span>
<span class="line-removed">1306   // Compute the size of first NumberOfLoopInstrToAlign instructions</span>
<span class="line-removed">1307   // at the head of a loop.</span>
<span class="line-removed">1308   void compute_loop_first_inst_sizes();</span>
<span class="line-removed">1309 </span>
<span class="line-removed">1310   // Compute the information for the exception tables</span>
<span class="line-removed">1311   void FillExceptionTables(uint cnt, uint *call_returns, uint *inct_starts, Label *blk_labels);</span>
1312 
1313   // Stack slots that may be unused by the calling convention but must
1314   // otherwise be preserved.  On Intel this includes the return address.
1315   // On PowerPC it includes the 4 words holding the old TOC &amp; LR glue.
1316   uint in_preserve_stack_slots();
1317 
1318   // &quot;Top of Stack&quot; slots that may be unused by the calling convention but must
1319   // otherwise be preserved.
1320   // On Intel these are not necessary and the value can be zero.
1321   // On Sparc this describes the words reserved for storing a register window
1322   // when an interrupt occurs.
1323   static uint out_preserve_stack_slots();
1324 
1325   // Number of outgoing stack slots killed above the out_preserve_stack_slots
1326   // for calls to C.  Supports the var-args backing area for register parms.
1327   uint varargs_C_out_slots_killed() const;
1328 
1329   // Number of Stack Slots consumed by a synchronization entry
1330   int sync_stack_slots() const;
1331 
</pre>
<hr />
<pre>
1374     _intrinsic_failed = 2,      // tried it but it failed
1375     _intrinsic_disabled = 4,    // was requested but disabled (e.g., -XX:-InlineUnsafeOps)
1376     _intrinsic_virtual = 8,     // was seen in the virtual form (rare)
1377     _intrinsic_both = 16        // was seen in the non-virtual form (usual)
1378   };
1379   // Update histogram.  Return boolean if this is a first-time occurrence.
1380   static bool gather_intrinsic_statistics(vmIntrinsics::ID id,
1381                                           bool is_virtual, int flags) PRODUCT_RETURN0;
1382   static void print_intrinsic_statistics() PRODUCT_RETURN;
1383 
1384   // Graph verification code
1385   // Walk the node list, verifying that there is a one-to-one
1386   // correspondence between Use-Def edges and Def-Use edges
1387   // The option no_dead_code enables stronger checks that the
1388   // graph is strongly connected from root in both directions.
1389   void verify_graph_edges(bool no_dead_code = false) PRODUCT_RETURN;
1390 
1391   // End-of-run dumps.
1392   static void print_statistics() PRODUCT_RETURN;
1393 
<span class="line-removed">1394   // Dump formatted assembly</span>
<span class="line-removed">1395 #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="line-removed">1396   void dump_asm_on(outputStream* ost, int* pcs, uint pc_limit);</span>
<span class="line-removed">1397   void dump_asm(int* pcs = NULL, uint pc_limit = 0) { dump_asm_on(tty, pcs, pc_limit); }</span>
<span class="line-removed">1398 #else</span>
<span class="line-removed">1399   void dump_asm_on(outputStream* ost, int* pcs, uint pc_limit) { return; }</span>
<span class="line-removed">1400   void dump_asm(int* pcs = NULL, uint pc_limit = 0) { return; }</span>
<span class="line-removed">1401 #endif</span>
<span class="line-removed">1402   void dump_pc(int *pcs, int pc_limit, Node *n);</span>
<span class="line-removed">1403 </span>
1404   // Verify ADLC assumptions during startup
1405   static void adlc_verification() PRODUCT_RETURN;
1406 
1407   // Definitions of pd methods
1408   static void pd_compiler2_init();
1409 
1410   // Static parse-time type checking logic for gen_subtype_check:
1411   enum { SSC_always_false, SSC_always_true, SSC_easy_test, SSC_full_test };
1412   int static_subtype_check(ciKlass* superk, ciKlass* subk);
1413 
1414   static Node* conv_I2X_index(PhaseGVN* phase, Node* offset, const TypeInt* sizetype,
1415                               // Optional control dependency (for example, on range check)
1416                               Node* ctrl = NULL);
1417 
1418   // Convert integer value to a narrowed long type dependent on ctrl (for example, a range check)
1419   static Node* constrained_convI2L(PhaseGVN* phase, Node* value, const TypeInt* itype, Node* ctrl);
1420 
1421   Node* optimize_acmp(PhaseGVN* phase, Node* a, Node* b);
1422 
1423   // Auxiliary method for randomized fuzzing/stressing
</pre>
<hr />
<pre>
1429 
1430   bool needs_clinit_barrier(ciField* ik,         ciMethod* accessing_method);
1431   bool needs_clinit_barrier(ciMethod* ik,        ciMethod* accessing_method);
1432   bool needs_clinit_barrier(ciInstanceKlass* ik, ciMethod* accessing_method);
1433 
1434 #ifdef IA32
1435  private:
1436   bool _select_24_bit_instr;   // We selected an instruction with a 24-bit result
1437   bool _in_24_bit_fp_mode;     // We are emitting instructions with 24-bit results
1438 
1439   // Remember if this compilation changes hardware mode to 24-bit precision.
1440   void set_24_bit_selection_and_mode(bool selection, bool mode) {
1441     _select_24_bit_instr = selection;
1442     _in_24_bit_fp_mode   = mode;
1443   }
1444 
1445  public:
1446   bool select_24_bit_instr() const { return _select_24_bit_instr; }
1447   bool in_24_bit_fp_mode() const   { return _in_24_bit_fp_mode; }
1448 #endif // IA32



1449 };
1450 
1451 #endif // SHARE_OPTO_COMPILE_HPP
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_COMPILE_HPP
  26 #define SHARE_OPTO_COMPILE_HPP
  27 
  28 #include &quot;asm/codeBuffer.hpp&quot;
  29 #include &quot;ci/compilerInterface.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;

  31 #include &quot;compiler/compilerOracle.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
<span class="line-added">  33 #include &quot;compiler/compilerEvent.hpp&quot;</span>
  34 #include &quot;libadt/dict.hpp&quot;
  35 #include &quot;libadt/vectset.hpp&quot;

  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;oops/methodData.hpp&quot;
  38 #include &quot;opto/idealGraphPrinter.hpp&quot;
  39 #include &quot;opto/phasetype.hpp&quot;
  40 #include &quot;opto/phase.hpp&quot;
  41 #include &quot;opto/regmask.hpp&quot;
  42 #include &quot;runtime/deoptimization.hpp&quot;
  43 #include &quot;runtime/timerTrace.hpp&quot;
  44 #include &quot;runtime/vmThread.hpp&quot;
  45 #include &quot;utilities/ticks.hpp&quot;
  46 
  47 class AddPNode;
  48 class Block;
  49 class Bundle;


  50 class CallGenerator;
<span class="line-added">  51 class CallNode;</span>
  52 class CloneMap;
  53 class ConnectionGraph;
  54 class IdealGraphPrinter;
  55 class InlineTree;
  56 class Int_Array;
  57 class Matcher;
  58 class MachConstantNode;
  59 class MachConstantBaseNode;
  60 class MachNode;
  61 class MachOper;
  62 class MachSafePointNode;
  63 class Node;
  64 class Node_Array;
  65 class Node_Notes;
  66 class NodeCloneInfo;
  67 class OptoReg;
  68 class PhaseCFG;
  69 class PhaseGVN;
  70 class PhaseIterGVN;
  71 class PhaseRegAlloc;
  72 class PhaseCCP;
  73 class PhaseCCP_DCE;
<span class="line-added">  74 class PhaseOutput;</span>
  75 class RootNode;
  76 class relocInfo;
  77 class Scope;
  78 class StartNode;
  79 class SafePointNode;
  80 class JVMState;
  81 class Type;
  82 class TypeData;
  83 class TypeInt;
  84 class TypePtr;
  85 class TypeOopPtr;
  86 class TypeFunc;
  87 class ValueTypeBaseNode;
  88 class Unique_Node_List;
  89 class nmethod;
  90 class WarmCallInfo;
  91 class Node_Stack;
  92 struct Final_Reshape_Counts;
  93 
  94 enum LoopOptsMode {
</pre>
<hr />
<pre>
 224     }
 225     void set_element(const Type* e) {
 226       assert(_element == NULL, &quot;&quot;);
 227       _element = e;
 228     }
 229 
 230     BasicType basic_type() const;
 231 
 232     void print_on(outputStream* st) PRODUCT_RETURN;
 233   };
 234 
 235   enum {
 236     logAliasCacheSize = 6,
 237     AliasCacheSize = (1&lt;&lt;logAliasCacheSize)
 238   };
 239   struct AliasCacheEntry { const TypePtr* _adr_type; int _index; };  // simple duple type
 240   enum {
 241     trapHistLength = MethodData::_trap_hist_limit
 242   };
 243 



















































































































 244  private:
 245   // Fixed parameters to this compilation.
 246   const int             _compile_id;
 247   const bool            _save_argument_registers; // save/restore arg regs for trampolines
 248   const bool            _subsume_loads;         // Load can be matched as part of a larger op.
 249   const bool            _do_escape_analysis;    // Do escape analysis.
 250   const bool            _eliminate_boxing;      // Do boxing elimination.
 251   ciMethod*             _method;                // The method being compiled.
 252   int                   _entry_bci;             // entry bci for osr methods.
 253   const TypeFunc*       _tf;                    // My kind of signature
 254   InlineTree*           _ilt;                   // Ditto (temporary).
 255   address               _stub_function;         // VM entry for stub being compiled, or NULL
 256   const char*           _stub_name;             // Name of stub or adapter being compiled, or NULL
 257   address               _stub_entry_point;      // Compile code entry for generated stub, or NULL
 258 
 259   // Control of this compilation.
 260   int                   _max_inline_size;       // Max inline size for this compilation
 261   int                   _freq_inline_size;      // Max hot method inline size for this compilation
 262   int                   _fixed_slots;           // count of frame slots not allocated by the register
 263                                                 // allocator i.e. locks, original deopt pc, etc.
 264   uintx                 _max_node_limit;        // Max unique node count during a single compilation.







 265 
 266   int                   _major_progress;        // Count of something big happening
 267   bool                  _inlining_progress;     // progress doing incremental inlining?
 268   bool                  _inlining_incrementally;// Are we doing incremental inlining (post parse)
 269   bool                  _do_cleanup;            // Cleanup is needed before proceeding with incremental inlining
 270   bool                  _has_loops;             // True if the method _may_ have some loops
 271   bool                  _has_split_ifs;         // True if the method _may_ have some split-if
 272   bool                  _has_unsafe_access;     // True if the method _may_ produce faults in unsafe loads or stores.
 273   bool                  _has_stringbuilder;     // True StringBuffers or StringBuilders are allocated
 274   bool                  _has_boxed_value;       // True if a boxed object is allocated
 275   bool                  _has_reserved_stack_access; // True if the method or an inlined method is annotated with ReservedStackAccess
 276   uint                  _max_vector_size;       // Maximum size of generated vectors
 277   bool                  _clear_upper_avx;       // Clear upper bits of ymm registers using vzeroupper
 278   uint                  _trap_hist[trapHistLength];  // Cumulative traps
 279   bool                  _trap_can_recompile;    // Have we emitted a recompiling trap?
 280   uint                  _decompile_count;       // Cumulative decompilation counts.
 281   bool                  _do_inlining;           // True if we intend to do inlining
 282   bool                  _do_scheduling;         // True if we intend to do scheduling
 283   bool                  _do_freq_based_layout;  // True if we intend to do frequency based block layout
 284   bool                  _do_count_invocations;  // True if we generate code to count invocations
</pre>
<hr />
<pre>
 326 
 327   // Node management
 328   uint                  _unique;                // Counter for unique Node indices
 329   VectorSet             _dead_node_list;        // Set of dead nodes
 330   uint                  _dead_node_count;       // Number of dead nodes; VectorSet::Size() is O(N).
 331                                                 // So use this to keep count and make the call O(1).
 332   DEBUG_ONLY( Unique_Node_List* _modified_nodes; )  // List of nodes which inputs were modified
 333 
 334   debug_only(static int _debug_idx;)            // Monotonic counter (not reset), use -XX:BreakAtNode=&lt;idx&gt;
 335   Arena                 _node_arena;            // Arena for new-space Nodes
 336   Arena                 _old_arena;             // Arena for old-space Nodes, lifetime during xform
 337   RootNode*             _root;                  // Unique root of compilation, or NULL after bail-out.
 338   Node*                 _top;                   // Unique top node.  (Reset by various phases.)
 339 
 340   Node*                 _immutable_memory;      // Initial memory state
 341 
 342   Node*                 _recent_alloc_obj;
 343   Node*                 _recent_alloc_ctl;
 344 
 345   // Constant table

 346   MachConstantBaseNode* _mach_constant_base_node;  // Constant table base node singleton.
 347 
 348 
 349   // Blocked array of debugging and profiling information,
 350   // tracked per node.
 351   enum { _log2_node_notes_block_size = 8,
 352          _node_notes_block_size = (1&lt;&lt;_log2_node_notes_block_size)
 353   };
 354   GrowableArray&lt;Node_Notes*&gt;* _node_note_array;
 355   Node_Notes*           _default_node_notes;  // default notes for new nodes
 356 
 357   // After parsing and every bulk phase we hang onto the Root instruction.
 358   // The RootNode instruction is where the whole program begins.  It produces
 359   // the initial Control and BOTTOM for everybody else.
 360 
 361   // Type management
 362   Arena                 _Compile_types;         // Arena for all types
 363   Arena*                _type_arena;            // Alias for _Compile_types except in Initialize_shared()
 364   Dict*                 _type_dict;             // Intern table
 365   CloneMap              _clone_map;             // used for recording history of cloned nodes
</pre>
<hr />
<pre>
 454 #ifndef PRODUCT
 455   IdealGraphPrinter* printer() { return _printer; }
 456 #endif
 457 
 458   void log_late_inline(CallGenerator* cg);
 459   void log_inline_id(CallGenerator* cg);
 460   void log_inline_failure(const char* msg);
 461 
 462   void* replay_inline_data() const { return _replay_inline_data; }
 463 
 464   // Dump inlining replay data to the stream.
 465   void dump_inline_data(outputStream* out);
 466 
 467  private:
 468   // Matching, CFG layout, allocation, code generation
 469   PhaseCFG*             _cfg;                   // Results of CFG finding
 470   int                   _java_calls;            // Number of java calls in the method
 471   int                   _inner_loops;           // Number of inner loops in the method
 472   Matcher*              _matcher;               // Engine to map ideal to machine instructions
 473   PhaseRegAlloc*        _regalloc;              // Results of register allocation.


 474   RegMask               _FIRST_STACK_mask;      // All stack slots usable for spills (depends on frame layout)
 475   Arena*                _indexSet_arena;        // control IndexSet allocation within PhaseChaitin
 476   void*                 _indexSet_free_block_list; // free list of IndexSet bit blocks
 477   int                   _interpreter_frame_size;
 478 
<span class="line-modified"> 479   PhaseOutput*          _output;</span>














 480 
 481   void reshape_address(AddPNode* n);
 482 
 483  public:
 484   // Accessors
 485 
 486   // The Compile instance currently active in this (compiler) thread.
 487   static Compile* current() {
 488     return (Compile*) ciEnv::current()-&gt;compiler_data();
 489   }
 490 
<span class="line-added"> 491   int interpreter_frame_size() const            { return _interpreter_frame_size; }</span>
<span class="line-added"> 492 </span>
<span class="line-added"> 493   PhaseOutput*      output() const              { return _output; }</span>
<span class="line-added"> 494   void              set_output(PhaseOutput* o)  { _output = o; }</span>
<span class="line-added"> 495 </span>
 496   // ID for this compilation.  Useful for setting breakpoints in the debugger.
 497   int               compile_id() const          { return _compile_id; }
 498   DirectiveSet*     directive() const           { return _directive; }
 499 
 500   // Does this compilation allow instructions to subsume loads?  User
 501   // instructions that subsume a load may result in an unschedulable
 502   // instruction sequence.
 503   bool              subsume_loads() const       { return _subsume_loads; }
 504   /** Do escape analysis. */
 505   bool              do_escape_analysis() const  { return _do_escape_analysis; }
 506   /** Do boxing elimination. */
 507   bool              eliminate_boxing() const    { return _eliminate_boxing; }
 508   /** Do aggressive boxing elimination. */
 509   bool              aggressive_unboxing() const { return _eliminate_boxing &amp;&amp; AggressiveUnboxing; }
 510   bool              save_argument_registers() const { return _save_argument_registers; }
 511 
 512 
 513   // Other fixed compilation parameters.
 514   ciMethod*         method() const              { return _method; }
 515   int               entry_bci() const           { return _entry_bci; }
 516   bool              is_osr_compilation() const  { return _entry_bci != InvocationEntryBci; }
 517   bool              is_method_compilation() const { return (_method != NULL &amp;&amp; !_method-&gt;flags().is_native()); }
 518   const TypeFunc*   tf() const                  { assert(_tf!=NULL, &quot;&quot;); return _tf; }
 519   void         init_tf(const TypeFunc* tf)      { assert(_tf==NULL, &quot;&quot;); _tf = tf; }
 520   InlineTree*       ilt() const                 { return _ilt; }
 521   address           stub_function() const       { return _stub_function; }
 522   const char*       stub_name() const           { return _stub_name; }
 523   address           stub_entry_point() const    { return _stub_entry_point; }
<span class="line-added"> 524   void          set_stub_entry_point(address z) { _stub_entry_point = z; }</span>
 525 
 526   // Control of this compilation.
 527   int               fixed_slots() const         { assert(_fixed_slots &gt;= 0, &quot;&quot;);         return _fixed_slots; }
 528   void          set_fixed_slots(int n)          { _fixed_slots = n; }
 529   int               major_progress() const      { return _major_progress; }
 530   void          set_inlining_progress(bool z)   { _inlining_progress = z; }
 531   int               inlining_progress() const   { return _inlining_progress; }
 532   void          set_inlining_incrementally(bool z) { _inlining_incrementally = z; }
 533   int               inlining_incrementally() const { return _inlining_incrementally; }
 534   void          set_do_cleanup(bool z)          { _do_cleanup = z; }
 535   int               do_cleanup() const          { return _do_cleanup; }
 536   void          set_major_progress()            { _major_progress++; }
 537   void          restore_major_progress(int progress) { _major_progress += progress; }
 538   void        clear_major_progress()            { _major_progress = 0; }
 539   int               max_inline_size() const     { return _max_inline_size; }
 540   void          set_freq_inline_size(int n)     { _freq_inline_size = n; }
 541   int               freq_inline_size() const    { return _freq_inline_size; }
 542   void          set_max_inline_size(int n)      { _max_inline_size = n; }
 543   bool              has_loops() const           { return _has_loops; }
 544   void          set_has_loops(bool z)           { _has_loops = z; }
</pre>
<hr />
<pre>
 584   void          set_print_assembly(bool z)       { _print_assembly = z; }
 585   bool              print_inlining() const       { return _print_inlining; }
 586   void          set_print_inlining(bool z)       { _print_inlining = z; }
 587   bool              print_intrinsics() const     { return _print_intrinsics; }
 588   void          set_print_intrinsics(bool z)     { _print_intrinsics = z; }
 589   RTMState          rtm_state()  const           { return _rtm_state; }
 590   void          set_rtm_state(RTMState s)        { _rtm_state = s; }
 591   bool              use_rtm() const              { return (_rtm_state &amp; NoRTM) == 0; }
 592   bool          profile_rtm() const              { return _rtm_state == ProfileRTM; }
 593   uint              max_node_limit() const       { return (uint)_max_node_limit; }
 594   void          set_max_node_limit(uint n)       { _max_node_limit = n; }
 595   bool              clinit_barrier_on_entry()       { return _clinit_barrier_on_entry; }
 596   void          set_clinit_barrier_on_entry(bool z) { _clinit_barrier_on_entry = z; }
 597   void          set_flattened_accesses()         { _has_flattened_accesses = true; }
 598   bool          flattened_accesses_share_alias() const { return _flattened_accesses_share_alias; }
 599   void          set_flattened_accesses_share_alias(bool z) { _flattened_accesses_share_alias = z; }
 600 
 601   // Support for scalarized value type calling convention
 602   bool              has_scalarized_args() const  { return _method != NULL &amp;&amp; _method-&gt;has_scalarized_args(); }
 603   bool              needs_stack_repair()  const  { return _method != NULL &amp;&amp; _method-&gt;get_Method()-&gt;c2_needs_stack_repair(); }

 604 
 605   // check the CompilerOracle for special behaviours for this compile
 606   bool          method_has_option(const char * option) {
 607     return method() != NULL &amp;&amp; method()-&gt;has_option(option);
 608   }
 609 
 610 #ifndef PRODUCT
 611   bool          trace_opto_output() const       { return _trace_opto_output; }
 612   bool          print_ideal() const             { return _print_ideal; }
 613   bool              parsed_irreducible_loop() const { return _parsed_irreducible_loop; }
 614   void          set_parsed_irreducible_loop(bool z) { _parsed_irreducible_loop = z; }
 615   int _in_dump_cnt;  // Required for dumping ir nodes.
 616 #endif
 617   bool              has_irreducible_loop() const { return _has_irreducible_loop; }
 618   void          set_has_irreducible_loop(bool z) { _has_irreducible_loop = z; }
 619 
 620   // JSR 292
 621   bool              has_method_handle_invokes() const { return _has_method_handle_invokes;     }
 622   void          set_has_method_handle_invokes(bool z) {        _has_method_handle_invokes = z; }
 623 
</pre>
<hr />
<pre>
 626   void begin_method() {
 627 #ifndef PRODUCT
 628     if (_printer &amp;&amp; _printer-&gt;should_print(1)) {
 629       _printer-&gt;begin_method();
 630     }
 631 #endif
 632     C-&gt;_latest_stage_start_counter.stamp();
 633   }
 634 
 635   bool should_print(int level = 1) {
 636 #ifndef PRODUCT
 637     return (_printer &amp;&amp; _printer-&gt;should_print(level));
 638 #else
 639     return false;
 640 #endif
 641   }
 642 
 643   void print_method(CompilerPhaseType cpt, int level = 1, int idx = 0) {
 644     EventCompilerPhase event;
 645     if (event.should_commit()) {
<span class="line-modified"> 646       CompilerEvent::PhaseEvent::post(event, C-&gt;_latest_stage_start_counter, cpt, C-&gt;_compile_id, level);</span>




 647     }
 648 
 649 #ifndef PRODUCT
 650     if (should_print(level)) {
 651       char output[1024];
 652       if (idx != 0) {
 653         sprintf(output, &quot;%s:%d&quot;, CompilerPhaseTypeHelper::to_string(cpt), idx);
 654       } else {
 655         sprintf(output, &quot;%s&quot;, CompilerPhaseTypeHelper::to_string(cpt));
 656       }
 657       _printer-&gt;print_method(output, level);
 658     }
 659 #endif
 660     C-&gt;_latest_stage_start_counter.stamp();
 661   }
 662 
 663   void end_method(int level = 1) {
 664     EventCompilerPhase event;
 665     if (event.should_commit()) {
<span class="line-modified"> 666       CompilerEvent::PhaseEvent::post(event, C-&gt;_latest_stage_start_counter, PHASE_END, C-&gt;_compile_id, level);</span>




 667     }
<span class="line-added"> 668 </span>
 669 #ifndef PRODUCT
 670     if (_printer &amp;&amp; _printer-&gt;should_print(level)) {
 671       _printer-&gt;end_method();
 672     }
 673 #endif
 674   }
 675 
 676   int           macro_count()             const { return _macro_nodes-&gt;length(); }
 677   int           predicate_count()         const { return _predicate_opaqs-&gt;length();}
 678   int           expensive_count()         const { return _expensive_nodes-&gt;length(); }
 679   Node*         macro_node(int idx)       const { return _macro_nodes-&gt;at(idx); }
 680   Node*         predicate_opaque1_node(int idx) const { return _predicate_opaqs-&gt;at(idx);}
 681   Node*         expensive_node(int idx)   const { return _expensive_nodes-&gt;at(idx); }
 682   ConnectionGraph* congraph()                   { return _congraph;}
 683   void set_congraph(ConnectionGraph* congraph)  { _congraph = congraph;}
 684   void add_macro_node(Node * n) {
 685     //assert(n-&gt;is_macro(), &quot;must be a macro node&quot;);
 686     assert(!_macro_nodes-&gt;contains(n), &quot;duplicate entry in expand list&quot;);
 687     _macro_nodes-&gt;append(n);
 688   }
</pre>
<hr />
<pre>
 803                                              _dead_node_count++;
 804                                            }
 805   void         reset_dead_node_list()      { _dead_node_list.reset();
 806                                              _dead_node_count = 0;
 807                                            }
 808   uint          live_nodes() const         {
 809     int  val = _unique - _dead_node_count;
 810     assert (val &gt;= 0, &quot;number of tracked dead nodes %d more than created nodes %d&quot;, _unique, _dead_node_count);
 811             return (uint) val;
 812                                            }
 813 #ifdef ASSERT
 814   uint         count_live_nodes_by_graph_walk();
 815   void         print_missing_nodes();
 816 #endif
 817 
 818   // Record modified nodes to check that they are put on IGVN worklist
 819   void         record_modified_node(Node* n) NOT_DEBUG_RETURN;
 820   void         remove_modified_node(Node* n) NOT_DEBUG_RETURN;
 821   DEBUG_ONLY( Unique_Node_List*   modified_nodes() const { return _modified_nodes; } )
 822 



 823   MachConstantBaseNode*     mach_constant_base_node();
 824   bool                  has_mach_constant_base_node() const { return _mach_constant_base_node != NULL; }
 825   // Generated by adlc, true if CallNode requires MachConstantBase.
 826   bool                      needs_clone_jvms();
 827 
 828   // Handy undefined Node
 829   Node*             top() const                 { return _top; }
 830 
 831   // these are used by guys who need to know about creation and transformation of top:
 832   Node*             cached_top_node()           { return _top; }
 833   void          set_cached_top_node(Node* tn);
 834 
 835   GrowableArray&lt;Node_Notes*&gt;* node_note_array() const { return _node_note_array; }
 836   void set_node_note_array(GrowableArray&lt;Node_Notes*&gt;* arr) { _node_note_array = arr; }
 837   Node_Notes* default_node_notes() const        { return _default_node_notes; }
 838   void    set_default_node_notes(Node_Notes* n) { _default_node_notes = n; }
 839 
 840   Node_Notes*       node_notes_at(int idx) {
 841     return locate_node_notes(_node_note_array, idx, false);
 842   }
</pre>
<hr />
<pre>
 988 
 989   void inc_number_of_mh_late_inlines() { _number_of_mh_late_inlines++; }
 990   void dec_number_of_mh_late_inlines() { assert(_number_of_mh_late_inlines &gt; 0, &quot;_number_of_mh_late_inlines &lt; 0 !&quot;); _number_of_mh_late_inlines--; }
 991   bool has_mh_late_inlines() const     { return _number_of_mh_late_inlines &gt; 0; }
 992 
 993   bool inline_incrementally_one();
 994   void inline_incrementally_cleanup(PhaseIterGVN&amp; igvn);
 995   void inline_incrementally(PhaseIterGVN&amp; igvn);
 996   void inline_string_calls(bool parse_time);
 997   void inline_boxing_calls(PhaseIterGVN&amp; igvn);
 998   bool optimize_loops(PhaseIterGVN&amp; igvn, LoopOptsMode mode);
 999   void remove_root_to_sfpts_edges(PhaseIterGVN&amp; igvn);
1000 
1001   // Matching, CFG layout, allocation, code generation
1002   PhaseCFG*         cfg()                       { return _cfg; }
1003   bool              has_java_calls() const      { return _java_calls &gt; 0; }
1004   int               java_calls() const          { return _java_calls; }
1005   int               inner_loops() const         { return _inner_loops; }
1006   Matcher*          matcher()                   { return _matcher; }
1007   PhaseRegAlloc*    regalloc()                  { return _regalloc; }



1008   RegMask&amp;          FIRST_STACK_mask()          { return _FIRST_STACK_mask; }
1009   Arena*            indexSet_arena()            { return _indexSet_arena; }
1010   void*             indexSet_free_block_list()  { return _indexSet_free_block_list; }
<span class="line-modified">1011   DebugInformationRecorder* debug_info()        { return env()-&gt;debug_info(); }</span>






1012 
1013   void  update_interpreter_frame_size(int size) {
1014     if (_interpreter_frame_size &lt; size) {
1015       _interpreter_frame_size = size;
1016     }
1017   }

1018 
1019   void          set_matcher(Matcher* m)                 { _matcher = m; }
1020 //void          set_regalloc(PhaseRegAlloc* ra)           { _regalloc = ra; }
1021   void          set_indexSet_arena(Arena* a)            { _indexSet_arena = a; }
1022   void          set_indexSet_free_block_list(void* p)   { _indexSet_free_block_list = p; }
1023 
1024   void  set_java_calls(int z) { _java_calls  = z; }
1025   void set_inner_loops(int z) { _inner_loops = z; }
1026 
<span class="line-modified">1027   Dependencies* dependencies() { return env()-&gt;dependencies(); }</span>




























1028 
1029   // Major entry point.  Given a Scope, compile the associated method.
1030   // For normal compilations, entry_bci is InvocationEntryBci.  For on stack
1031   // replacement, entry_bci indicates the bytecode for which to compile a
1032   // continuation.
<span class="line-modified">1033   Compile(ciEnv* ci_env, ciMethod* target,</span>
1034           int entry_bci, bool subsume_loads, bool do_escape_analysis,
1035           bool eliminate_boxing, DirectiveSet* directive);
1036 
1037   // Second major entry point.  From the TypeFunc signature, generate code
1038   // to pass arguments from the Java calling convention to the C calling
1039   // convention.
1040   Compile(ciEnv* ci_env, const TypeFunc *(*gen)(),
1041           address stub_function, const char *stub_name,
1042           int is_fancy_jump, bool pass_tls,
1043           bool save_arg_registers, bool return_pc, DirectiveSet* directive);
1044 
1045   // From the TypeFunc signature, generate code to pass arguments
1046   // from Compiled calling convention to Interpreter&#39;s calling convention
1047   void Generate_Compiled_To_Interpreter_Graph(const TypeFunc *tf, address interpreter_entry);
1048 
1049   // From the TypeFunc signature, generate code to pass arguments
1050   // from Interpreter&#39;s calling convention to Compiler&#39;s calling convention
1051   void Generate_Interpreter_To_Compiled_Graph(const TypeFunc *tf);
1052 
1053   // Are we compiling a method?
1054   bool has_method() { return method() != NULL; }
1055 
1056   // Maybe print some information about this compile.
1057   void print_compile_messages();
1058 
1059   // Final graph reshaping, a post-pass after the regular optimizer is done.
1060   bool final_graph_reshaping();
1061 
1062   // returns true if adr is completely contained in the given alias category
1063   bool must_alias(const TypePtr* adr, int alias_idx);
1064 
1065   // returns true if adr overlaps with the given alias category
1066   bool can_alias(const TypePtr* adr, int alias_idx);
1067 




















1068   // If &quot;objs&quot; contains an ObjectValue whose id is &quot;id&quot;, returns it, else NULL.
1069   static ObjectValue* sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id);







































1070 
1071   // Stack slots that may be unused by the calling convention but must
1072   // otherwise be preserved.  On Intel this includes the return address.
1073   // On PowerPC it includes the 4 words holding the old TOC &amp; LR glue.
1074   uint in_preserve_stack_slots();
1075 
1076   // &quot;Top of Stack&quot; slots that may be unused by the calling convention but must
1077   // otherwise be preserved.
1078   // On Intel these are not necessary and the value can be zero.
1079   // On Sparc this describes the words reserved for storing a register window
1080   // when an interrupt occurs.
1081   static uint out_preserve_stack_slots();
1082 
1083   // Number of outgoing stack slots killed above the out_preserve_stack_slots
1084   // for calls to C.  Supports the var-args backing area for register parms.
1085   uint varargs_C_out_slots_killed() const;
1086 
1087   // Number of Stack Slots consumed by a synchronization entry
1088   int sync_stack_slots() const;
1089 
</pre>
<hr />
<pre>
1132     _intrinsic_failed = 2,      // tried it but it failed
1133     _intrinsic_disabled = 4,    // was requested but disabled (e.g., -XX:-InlineUnsafeOps)
1134     _intrinsic_virtual = 8,     // was seen in the virtual form (rare)
1135     _intrinsic_both = 16        // was seen in the non-virtual form (usual)
1136   };
1137   // Update histogram.  Return boolean if this is a first-time occurrence.
1138   static bool gather_intrinsic_statistics(vmIntrinsics::ID id,
1139                                           bool is_virtual, int flags) PRODUCT_RETURN0;
1140   static void print_intrinsic_statistics() PRODUCT_RETURN;
1141 
1142   // Graph verification code
1143   // Walk the node list, verifying that there is a one-to-one
1144   // correspondence between Use-Def edges and Def-Use edges
1145   // The option no_dead_code enables stronger checks that the
1146   // graph is strongly connected from root in both directions.
1147   void verify_graph_edges(bool no_dead_code = false) PRODUCT_RETURN;
1148 
1149   // End-of-run dumps.
1150   static void print_statistics() PRODUCT_RETURN;
1151 










1152   // Verify ADLC assumptions during startup
1153   static void adlc_verification() PRODUCT_RETURN;
1154 
1155   // Definitions of pd methods
1156   static void pd_compiler2_init();
1157 
1158   // Static parse-time type checking logic for gen_subtype_check:
1159   enum { SSC_always_false, SSC_always_true, SSC_easy_test, SSC_full_test };
1160   int static_subtype_check(ciKlass* superk, ciKlass* subk);
1161 
1162   static Node* conv_I2X_index(PhaseGVN* phase, Node* offset, const TypeInt* sizetype,
1163                               // Optional control dependency (for example, on range check)
1164                               Node* ctrl = NULL);
1165 
1166   // Convert integer value to a narrowed long type dependent on ctrl (for example, a range check)
1167   static Node* constrained_convI2L(PhaseGVN* phase, Node* value, const TypeInt* itype, Node* ctrl);
1168 
1169   Node* optimize_acmp(PhaseGVN* phase, Node* a, Node* b);
1170 
1171   // Auxiliary method for randomized fuzzing/stressing
</pre>
<hr />
<pre>
1177 
1178   bool needs_clinit_barrier(ciField* ik,         ciMethod* accessing_method);
1179   bool needs_clinit_barrier(ciMethod* ik,        ciMethod* accessing_method);
1180   bool needs_clinit_barrier(ciInstanceKlass* ik, ciMethod* accessing_method);
1181 
1182 #ifdef IA32
1183  private:
1184   bool _select_24_bit_instr;   // We selected an instruction with a 24-bit result
1185   bool _in_24_bit_fp_mode;     // We are emitting instructions with 24-bit results
1186 
1187   // Remember if this compilation changes hardware mode to 24-bit precision.
1188   void set_24_bit_selection_and_mode(bool selection, bool mode) {
1189     _select_24_bit_instr = selection;
1190     _in_24_bit_fp_mode   = mode;
1191   }
1192 
1193  public:
1194   bool select_24_bit_instr() const { return _select_24_bit_instr; }
1195   bool in_24_bit_fp_mode() const   { return _in_24_bit_fp_mode; }
1196 #endif // IA32
<span class="line-added">1197 #ifdef ASSERT</span>
<span class="line-added">1198   bool _type_verify_symmetry;</span>
<span class="line-added">1199 #endif</span>
1200 };
1201 
1202 #endif // SHARE_OPTO_COMPILE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="gcm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
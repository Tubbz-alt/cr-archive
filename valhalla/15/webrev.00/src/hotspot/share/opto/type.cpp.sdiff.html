<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="superword.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/type.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 861   // Now check the speculative parts as well
 862   const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()-&gt;speculative() : NULL;
 863   const TypePtr* t_spec = t-&gt;isa_ptr() != NULL ? t-&gt;is_ptr()-&gt;speculative() : NULL;
 864   if (this_spec != NULL &amp;&amp; t_spec != NULL) {
 865     if (this_spec-&gt;interface_vs_oop_helper(t_spec)) {
 866       return true;
 867     }
 868     return false;
 869   }
 870   if (this_spec != NULL &amp;&amp; this_spec-&gt;interface_vs_oop_helper(t)) {
 871     return true;
 872   }
 873   if (t_spec != NULL &amp;&amp; interface_vs_oop_helper(t_spec)) {
 874     return true;
 875   }
 876   return false;
 877 }
 878 
 879 #endif
 880 
<span class="line-modified"> 881 //------------------------------meet-------------------------------------------</span>
<span class="line-removed"> 882 // Compute the MEET of two types.  NOT virtual.  It enforces that meet is</span>
<span class="line-removed"> 883 // commutative and the lattice is symmetric.</span>
<span class="line-removed"> 884 const Type *Type::meet_helper(const Type *t, bool include_speculative) const {</span>
<span class="line-removed"> 885   if (isa_narrowoop() &amp;&amp; t-&gt;isa_narrowoop()) {</span>
<span class="line-removed"> 886     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);</span>
<span class="line-removed"> 887     return result-&gt;make_narrowoop();</span>
<span class="line-removed"> 888   }</span>
<span class="line-removed"> 889   if (isa_narrowklass() &amp;&amp; t-&gt;isa_narrowklass()) {</span>
<span class="line-removed"> 890     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);</span>
<span class="line-removed"> 891     return result-&gt;make_narrowklass();</span>
<span class="line-removed"> 892   }</span>
<span class="line-removed"> 893 </span>
<span class="line-removed"> 894   const Type *this_t = maybe_remove_speculative(include_speculative);</span>
<span class="line-removed"> 895   t = t-&gt;maybe_remove_speculative(include_speculative);</span>
<span class="line-removed"> 896 </span>
<span class="line-removed"> 897   const Type *mt = this_t-&gt;xmeet(t);</span>
<span class="line-removed"> 898   if (isa_narrowoop() || t-&gt;isa_narrowoop()) return mt;</span>
<span class="line-removed"> 899   if (isa_narrowklass() || t-&gt;isa_narrowklass()) return mt;</span>
 900 #ifdef ASSERT
<span class="line-modified"> 901   assert(mt == t-&gt;xmeet(this_t), &quot;meet not commutative&quot;);</span>
 902   const Type* dual_join = mt-&gt;_dual;
 903   const Type *t2t    = dual_join-&gt;xmeet(t-&gt;_dual);
<span class="line-modified"> 904   const Type *t2this = dual_join-&gt;xmeet(this_t-&gt;_dual);</span>
 905 
 906   // Interface meet Oop is Not Symmetric:
 907   // Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull
 908   // Interface:NotNull meet Oop:NotNull == java/lang/Object:NotNull
 909 
<span class="line-modified"> 910   if( !interface_vs_oop(t) &amp;&amp; (t2t != t-&gt;_dual || t2this != this_t-&gt;_dual) ) {</span>

 911     tty-&gt;print_cr(&quot;=== Meet Not Symmetric ===&quot;);
 912     tty-&gt;print(&quot;t   =                   &quot;);              t-&gt;dump(); tty-&gt;cr();
<span class="line-modified"> 913     tty-&gt;print(&quot;this=                   &quot;);         this_t-&gt;dump(); tty-&gt;cr();</span>
 914     tty-&gt;print(&quot;mt=(t meet this)=       &quot;);             mt-&gt;dump(); tty-&gt;cr();
 915 
 916     tty-&gt;print(&quot;t_dual=                 &quot;);       t-&gt;_dual-&gt;dump(); tty-&gt;cr();
<span class="line-modified"> 917     tty-&gt;print(&quot;this_dual=              &quot;);  this_t-&gt;_dual-&gt;dump(); tty-&gt;cr();</span>
 918     tty-&gt;print(&quot;mt_dual=                &quot;);      mt-&gt;_dual-&gt;dump(); tty-&gt;cr();
 919 
 920     tty-&gt;print(&quot;mt_dual meet t_dual=    &quot;); t2t           -&gt;dump(); tty-&gt;cr();
 921     tty-&gt;print(&quot;mt_dual meet this_dual= &quot;); t2this        -&gt;dump(); tty-&gt;cr();
 922 
 923     fatal(&quot;meet not symmetric&quot; );
 924   }










































 925 #endif
 926   return mt;
 927 }
 928 
 929 //------------------------------xmeet------------------------------------------
 930 // Compute the MEET of two types.  It returns a new Type object.
 931 const Type *Type::xmeet( const Type *t ) const {
 932   // Perform a fast test for common case; meeting the same types together.
 933   if( this == t ) return this;  // Meeting same type-rep?
 934 
 935   // Meeting TOP with anything?
 936   if( _base == Top ) return t;
 937 
 938   // Meeting BOTTOM with anything?
 939   if( _base == Bottom ) return BOTTOM;
 940 
 941   // Current &quot;this-&gt;_base&quot; is one of: Bad, Multi, Control, Top,
 942   // Abio, Abstore, Floatxxx, Doublexxx, Bottom, lastype.
 943   switch (t-&gt;base()) {  // Switch on original type
 944 
</pre>
<hr />
<pre>
4684         // Result is flattened
4685         off = Offset(elem()-&gt;isa_valuetype() ? offset() : tap-&gt;offset());
4686         field_off = elem()-&gt;isa_valuetype() ? field_offset() : tap-&gt;field_offset();
4687       } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {
4688         // Result is non-flattened
4689         off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));
4690         field_off = Offset::bottom;
4691       }
4692     } else // Non integral arrays.
4693       // Must fall to bottom if exact klasses in upper lattice
4694       // are not equal or super klass is exact.
4695       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4696           // meet with top[] and bottom[] are processed further down:
4697           tap-&gt;_klass != NULL &amp;&amp; this-&gt;_klass != NULL &amp;&amp;
4698           // both are exact and not equal:
4699           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4700            // &#39;tap&#39; is exact and super or unrelated:
4701            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4702            // &#39;this&#39; is exact and super or unrelated:
4703            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
<span class="line-modified">4704       if (above_centerline(ptr)) {</span>
4705         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4706       }
4707       return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);
4708     }
4709 
4710     bool xk = false;
4711     switch (tap-&gt;ptr()) {
4712     case AnyNull:
4713     case TopPTR:
4714       // Compute new klass on demand, do not use tap-&gt;_klass
4715       if (below_centerline(this-&gt;_ptr)) {
4716         xk = this-&gt;_klass_is_exact;
4717       } else {
4718         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4719       }
4720       return make(ptr, const_oop(), tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4721     case Constant: {
4722       ciObject* o = const_oop();
4723       if( _ptr == Constant ) {
4724         if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
</pre>
</td>
<td>
<hr />
<pre>
 861   // Now check the speculative parts as well
 862   const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()-&gt;speculative() : NULL;
 863   const TypePtr* t_spec = t-&gt;isa_ptr() != NULL ? t-&gt;is_ptr()-&gt;speculative() : NULL;
 864   if (this_spec != NULL &amp;&amp; t_spec != NULL) {
 865     if (this_spec-&gt;interface_vs_oop_helper(t_spec)) {
 866       return true;
 867     }
 868     return false;
 869   }
 870   if (this_spec != NULL &amp;&amp; this_spec-&gt;interface_vs_oop_helper(t)) {
 871     return true;
 872   }
 873   if (t_spec != NULL &amp;&amp; interface_vs_oop_helper(t_spec)) {
 874     return true;
 875   }
 876   return false;
 877 }
 878 
 879 #endif
 880 
<span class="line-modified"> 881 void Type::check_symmetrical(const Type *t, const Type *mt) const {</span>


















 882 #ifdef ASSERT
<span class="line-modified"> 883   assert(mt == t-&gt;xmeet(this), &quot;meet not commutative&quot;);</span>
 884   const Type* dual_join = mt-&gt;_dual;
 885   const Type *t2t    = dual_join-&gt;xmeet(t-&gt;_dual);
<span class="line-modified"> 886   const Type *t2this = dual_join-&gt;xmeet(this-&gt;_dual);</span>
 887 
 888   // Interface meet Oop is Not Symmetric:
 889   // Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull
 890   // Interface:NotNull meet Oop:NotNull == java/lang/Object:NotNull
 891 
<span class="line-modified"> 892   // JDK-8242269: merge issue, disabled for now</span>
<span class="line-added"> 893   if( !interface_vs_oop(t) &amp;&amp; (t2t != t-&gt;_dual || t2this != this-&gt;_dual) &amp;&amp; false) {</span>
 894     tty-&gt;print_cr(&quot;=== Meet Not Symmetric ===&quot;);
 895     tty-&gt;print(&quot;t   =                   &quot;);              t-&gt;dump(); tty-&gt;cr();
<span class="line-modified"> 896     tty-&gt;print(&quot;this=                   &quot;);                 dump(); tty-&gt;cr();</span>
 897     tty-&gt;print(&quot;mt=(t meet this)=       &quot;);             mt-&gt;dump(); tty-&gt;cr();
 898 
 899     tty-&gt;print(&quot;t_dual=                 &quot;);       t-&gt;_dual-&gt;dump(); tty-&gt;cr();
<span class="line-modified"> 900     tty-&gt;print(&quot;this_dual=              &quot;);          _dual-&gt;dump(); tty-&gt;cr();</span>
 901     tty-&gt;print(&quot;mt_dual=                &quot;);      mt-&gt;_dual-&gt;dump(); tty-&gt;cr();
 902 
 903     tty-&gt;print(&quot;mt_dual meet t_dual=    &quot;); t2t           -&gt;dump(); tty-&gt;cr();
 904     tty-&gt;print(&quot;mt_dual meet this_dual= &quot;); t2this        -&gt;dump(); tty-&gt;cr();
 905 
 906     fatal(&quot;meet not symmetric&quot; );
 907   }
<span class="line-added"> 908 #endif</span>
<span class="line-added"> 909 }</span>
<span class="line-added"> 910 </span>
<span class="line-added"> 911 //------------------------------meet-------------------------------------------</span>
<span class="line-added"> 912 // Compute the MEET of two types.  NOT virtual.  It enforces that meet is</span>
<span class="line-added"> 913 // commutative and the lattice is symmetric.</span>
<span class="line-added"> 914 const Type *Type::meet_helper(const Type *t, bool include_speculative) const {</span>
<span class="line-added"> 915   if (isa_narrowoop() &amp;&amp; t-&gt;isa_narrowoop()) {</span>
<span class="line-added"> 916     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);</span>
<span class="line-added"> 917     return result-&gt;make_narrowoop();</span>
<span class="line-added"> 918   }</span>
<span class="line-added"> 919   if (isa_narrowklass() &amp;&amp; t-&gt;isa_narrowklass()) {</span>
<span class="line-added"> 920     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);</span>
<span class="line-added"> 921     return result-&gt;make_narrowklass();</span>
<span class="line-added"> 922   }</span>
<span class="line-added"> 923 </span>
<span class="line-added"> 924   const Type *this_t = maybe_remove_speculative(include_speculative);</span>
<span class="line-added"> 925   t = t-&gt;maybe_remove_speculative(include_speculative);</span>
<span class="line-added"> 926 </span>
<span class="line-added"> 927   const Type *mt = this_t-&gt;xmeet(t);</span>
<span class="line-added"> 928 #ifdef ASSERT</span>
<span class="line-added"> 929   if (isa_narrowoop() || t-&gt;isa_narrowoop()) return mt;</span>
<span class="line-added"> 930   if (isa_narrowklass() || t-&gt;isa_narrowklass()) return mt;</span>
<span class="line-added"> 931   Compile* C = Compile::current();</span>
<span class="line-added"> 932   if (!C-&gt;_type_verify_symmetry) {</span>
<span class="line-added"> 933     return mt;</span>
<span class="line-added"> 934   }</span>
<span class="line-added"> 935   this_t-&gt;check_symmetrical(t, mt);</span>
<span class="line-added"> 936   // In the case of an array, computing the meet above, caused the</span>
<span class="line-added"> 937   // computation of the meet of the elements which at verification</span>
<span class="line-added"> 938   // time caused the computation of the meet of the dual of the</span>
<span class="line-added"> 939   // elements. Computing the meet of the dual of the arrays here</span>
<span class="line-added"> 940   // causes the meet of the dual of the elements to be computed which</span>
<span class="line-added"> 941   // would cause the meet of the dual of the dual of the elements,</span>
<span class="line-added"> 942   // that is the meet of the elements already computed above to be</span>
<span class="line-added"> 943   // computed. Avoid redundant computations by requesting no</span>
<span class="line-added"> 944   // verification.</span>
<span class="line-added"> 945   C-&gt;_type_verify_symmetry = false;</span>
<span class="line-added"> 946   const Type *mt_dual = this_t-&gt;_dual-&gt;xmeet(t-&gt;_dual);</span>
<span class="line-added"> 947   this_t-&gt;_dual-&gt;check_symmetrical(t-&gt;_dual, mt_dual);</span>
<span class="line-added"> 948   assert(!C-&gt;_type_verify_symmetry, &quot;shouldn&#39;t have changed&quot;);</span>
<span class="line-added"> 949   C-&gt;_type_verify_symmetry = true;</span>
 950 #endif
 951   return mt;
 952 }
 953 
 954 //------------------------------xmeet------------------------------------------
 955 // Compute the MEET of two types.  It returns a new Type object.
 956 const Type *Type::xmeet( const Type *t ) const {
 957   // Perform a fast test for common case; meeting the same types together.
 958   if( this == t ) return this;  // Meeting same type-rep?
 959 
 960   // Meeting TOP with anything?
 961   if( _base == Top ) return t;
 962 
 963   // Meeting BOTTOM with anything?
 964   if( _base == Bottom ) return BOTTOM;
 965 
 966   // Current &quot;this-&gt;_base&quot; is one of: Bad, Multi, Control, Top,
 967   // Abio, Abstore, Floatxxx, Doublexxx, Bottom, lastype.
 968   switch (t-&gt;base()) {  // Switch on original type
 969 
</pre>
<hr />
<pre>
4709         // Result is flattened
4710         off = Offset(elem()-&gt;isa_valuetype() ? offset() : tap-&gt;offset());
4711         field_off = elem()-&gt;isa_valuetype() ? field_offset() : tap-&gt;field_offset();
4712       } else if (tary-&gt;_elem-&gt;make_oopptr() != NULL &amp;&amp; tary-&gt;_elem-&gt;make_oopptr()-&gt;isa_instptr() &amp;&amp; below_centerline(ptr)) {
4713         // Result is non-flattened
4714         off = Offset(flattened_offset()).meet(Offset(tap-&gt;flattened_offset()));
4715         field_off = Offset::bottom;
4716       }
4717     } else // Non integral arrays.
4718       // Must fall to bottom if exact klasses in upper lattice
4719       // are not equal or super klass is exact.
4720       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4721           // meet with top[] and bottom[] are processed further down:
4722           tap-&gt;_klass != NULL &amp;&amp; this-&gt;_klass != NULL &amp;&amp;
4723           // both are exact and not equal:
4724           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4725            // &#39;tap&#39; is exact and super or unrelated:
4726            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4727            // &#39;this&#39; is exact and super or unrelated:
4728            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
<span class="line-modified">4729       if (above_centerline(ptr) || (tary-&gt;_elem-&gt;make_ptr() &amp;&amp; above_centerline(tary-&gt;_elem-&gt;make_ptr()-&gt;_ptr))) {</span>
4730         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable, tary-&gt;_not_flat, tary-&gt;_not_null_free);
4731       }
4732       return make(NotNull, NULL, tary, lazy_klass, false, off, field_off, InstanceBot, speculative, depth);
4733     }
4734 
4735     bool xk = false;
4736     switch (tap-&gt;ptr()) {
4737     case AnyNull:
4738     case TopPTR:
4739       // Compute new klass on demand, do not use tap-&gt;_klass
4740       if (below_centerline(this-&gt;_ptr)) {
4741         xk = this-&gt;_klass_is_exact;
4742       } else {
4743         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4744       }
4745       return make(ptr, const_oop(), tary, lazy_klass, xk, off, field_off, instance_id, speculative, depth);
4746     case Constant: {
4747       ciObject* o = const_oop();
4748       if( _ptr == Constant ) {
4749         if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
</pre>
</td>
</tr>
</table>
<center><a href="superword.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="type.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/arraycopynode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/barrierSet.hpp&quot;
 27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
 28 #include &quot;gc/shared/c2/cardTableBarrierSetC2.hpp&quot;
 29 #include &quot;opto/arraycopynode.hpp&quot;
 30 #include &quot;opto/graphKit.hpp&quot;
 31 #include &quot;opto/valuetypenode.hpp&quot;
 32 #include &quot;runtime/sharedRuntime.hpp&quot;
 33 #include &quot;utilities/macros.hpp&quot;
 34 #include &quot;utilities/powerOfTwo.hpp&quot;
 35 
 36 ArrayCopyNode::ArrayCopyNode(Compile* C, bool alloc_tightly_coupled, bool has_negative_length_guard)
 37   : CallNode(arraycopy_type(), NULL, TypePtr::BOTTOM),
 38     _kind(None),
 39     _alloc_tightly_coupled(alloc_tightly_coupled),
 40     _has_negative_length_guard(has_negative_length_guard),
 41     _arguments_validated(false),
 42     _src_type(TypeOopPtr::BOTTOM),
 43     _dest_type(TypeOopPtr::BOTTOM) {
 44   init_class_id(Class_ArrayCopy);
 45   init_flags(Flag_is_macro);
 46   C-&gt;add_macro_node(this);
 47 }
 48 
 49 uint ArrayCopyNode::size_of() const { return sizeof(*this); }
 50 
 51 ArrayCopyNode* ArrayCopyNode::make(GraphKit* kit, bool may_throw,
 52                                    Node* src, Node* src_offset,
 53                                    Node* dest, Node* dest_offset,
 54                                    Node* length,
 55                                    bool alloc_tightly_coupled,
 56                                    bool has_negative_length_guard,
 57                                    Node* src_klass, Node* dest_klass,
 58                                    Node* src_length, Node* dest_length) {
 59 
 60   ArrayCopyNode* ac = new ArrayCopyNode(kit-&gt;C, alloc_tightly_coupled, has_negative_length_guard);
 61   Node* prev_mem = kit-&gt;set_predefined_input_for_runtime_call(ac);
 62 
 63   ac-&gt;init_req(ArrayCopyNode::Src, src);
 64   ac-&gt;init_req(ArrayCopyNode::SrcPos, src_offset);
 65   ac-&gt;init_req(ArrayCopyNode::Dest, dest);
 66   ac-&gt;init_req(ArrayCopyNode::DestPos, dest_offset);
 67   ac-&gt;init_req(ArrayCopyNode::Length, length);
 68   ac-&gt;init_req(ArrayCopyNode::SrcLen, src_length);
 69   ac-&gt;init_req(ArrayCopyNode::DestLen, dest_length);
 70   ac-&gt;init_req(ArrayCopyNode::SrcKlass, src_klass);
 71   ac-&gt;init_req(ArrayCopyNode::DestKlass, dest_klass);
 72 
 73   if (may_throw) {
 74     ac-&gt;set_req(TypeFunc::I_O , kit-&gt;i_o());
 75     kit-&gt;add_safepoint_edges(ac, false);
 76   }
 77 
 78   return ac;
 79 }
 80 
 81 void ArrayCopyNode::connect_outputs(GraphKit* kit) {
 82   kit-&gt;set_all_memory_call(this, true);
 83   kit-&gt;set_control(kit-&gt;gvn().transform(new ProjNode(this,TypeFunc::Control)));
 84   kit-&gt;set_i_o(kit-&gt;gvn().transform(new ProjNode(this, TypeFunc::I_O)));
 85   kit-&gt;make_slow_call_ex(this, kit-&gt;env()-&gt;Throwable_klass(), true);
 86   kit-&gt;set_all_memory_call(this);
 87 }
 88 
 89 #ifndef PRODUCT
 90 const char* ArrayCopyNode::_kind_names[] = {&quot;arraycopy&quot;, &quot;arraycopy, validated arguments&quot;, &quot;clone&quot;, &quot;oop array clone&quot;, &quot;CopyOf&quot;, &quot;CopyOfRange&quot;};
 91 
 92 void ArrayCopyNode::dump_spec(outputStream *st) const {
 93   CallNode::dump_spec(st);
 94   st-&gt;print(&quot; (%s%s)&quot;, _kind_names[_kind], _alloc_tightly_coupled ? &quot;, tightly coupled allocation&quot; : &quot;&quot;);
 95 }
 96 
 97 void ArrayCopyNode::dump_compact_spec(outputStream* st) const {
 98   st-&gt;print(&quot;%s%s&quot;, _kind_names[_kind], _alloc_tightly_coupled ? &quot;,tight&quot; : &quot;&quot;);
 99 }
100 #endif
101 
102 intptr_t ArrayCopyNode::get_length_if_constant(PhaseGVN *phase) const {
103   // check that length is constant
104   Node* length = in(ArrayCopyNode::Length);
105   const Type* length_type = phase-&gt;type(length);
106 
107   if (length_type == Type::TOP) {
108     return -1;
109   }
110 
111   assert(is_clonebasic() || is_arraycopy() || is_copyof() || is_copyofrange(), &quot;unexpected array copy type&quot;);
112 
113   return is_clonebasic() ? length-&gt;find_intptr_t_con(-1) : length-&gt;find_int_con(-1);
114 }
115 
116 int ArrayCopyNode::get_count(PhaseGVN *phase) const {
117   if (is_clonebasic()) {
118     Node* src = in(ArrayCopyNode::Src);
119     const Type* src_type = phase-&gt;type(src);
120 
121     if (src_type == Type::TOP) {
122       return -1;
123     }
124 
125     if (src_type-&gt;isa_instptr()) {
126       const TypeInstPtr* inst_src = src_type-&gt;is_instptr();
127       ciInstanceKlass* ik = inst_src-&gt;klass()-&gt;as_instance_klass();
128       // ciInstanceKlass::nof_nonstatic_fields() doesn&#39;t take injected
129       // fields into account. They are rare anyway so easier to simply
130       // skip instances with injected fields.
131       if ((!inst_src-&gt;klass_is_exact() &amp;&amp; (ik-&gt;is_interface() || ik-&gt;has_subklass())) || ik-&gt;has_injected_fields()) {
132         return -1;
133       }
134       int nb_fields = ik-&gt;nof_nonstatic_fields();
135       return nb_fields;
136     } else {
137       const TypeAryPtr* ary_src = src_type-&gt;isa_aryptr();
138       assert (ary_src != NULL, &quot;not an array or instance?&quot;);
139       // clone passes a length as a rounded number of longs. If we&#39;re
140       // cloning an array we&#39;ll do it element by element. If the
141       // length input to ArrayCopyNode is constant, length of input
142       // array must be too.
143 
144       assert((get_length_if_constant(phase) == -1) == !ary_src-&gt;size()-&gt;is_con() ||
145              (ValueArrayFlatten &amp;&amp; ary_src-&gt;elem()-&gt;make_oopptr() != NULL &amp;&amp; ary_src-&gt;elem()-&gt;make_oopptr()-&gt;can_be_value_type()) ||
146              phase-&gt;is_IterGVN() || phase-&gt;C-&gt;inlining_incrementally() || StressReflectiveCode, &quot;inconsistent&quot;);
147       if (ary_src-&gt;size()-&gt;is_con()) {
148         return ary_src-&gt;size()-&gt;get_con();
149       }
150       return -1;
151     }
152   }
153 
154   return get_length_if_constant(phase);
155 }
156 
157 Node* ArrayCopyNode::load(BarrierSetC2* bs, PhaseGVN *phase, Node*&amp; ctl, MergeMemNode* mem, Node* adr, const TypePtr* adr_type, const Type *type, BasicType bt) {
158   DecoratorSet decorators = C2_READ_ACCESS | C2_CONTROL_DEPENDENT_LOAD | IN_HEAP | C2_ARRAY_COPY;
159   C2AccessValuePtr addr(adr, adr_type);
160   C2OptAccess access(*phase, ctl, mem, decorators, bt, adr-&gt;in(AddPNode::Base), addr);
161   Node* res = bs-&gt;load_at(access, type);
162   ctl = access.ctl();
163   return res;
164 }
165 
166 void ArrayCopyNode::store(BarrierSetC2* bs, PhaseGVN *phase, Node*&amp; ctl, MergeMemNode* mem, Node* adr, const TypePtr* adr_type, Node* val, const Type *type, BasicType bt) {
167   DecoratorSet decorators = C2_WRITE_ACCESS | IN_HEAP | C2_ARRAY_COPY;
168   if (is_alloc_tightly_coupled()) {
169     decorators |= C2_TIGHTLY_COUPLED_ALLOC;
170   }
171   C2AccessValuePtr addr(adr, adr_type);
172   C2AccessValue value(val, type);
173   C2OptAccess access(*phase, ctl, mem, decorators, bt, adr-&gt;in(AddPNode::Base), addr);
174   bs-&gt;store_at(access, value);
175   ctl = access.ctl();
176 }
177 
178 
179 Node* ArrayCopyNode::try_clone_instance(PhaseGVN *phase, bool can_reshape, int count) {
180   if (!is_clonebasic()) {
181     return NULL;
182   }
183 
184   Node* src = in(ArrayCopyNode::Src);
185   Node* dest = in(ArrayCopyNode::Dest);
186   Node* ctl = in(TypeFunc::Control);
187   Node* in_mem = in(TypeFunc::Memory);
188 
189   const Type* src_type = phase-&gt;type(src);
190 
191   assert(src-&gt;is_AddP(), &quot;should be base + off&quot;);
192   assert(dest-&gt;is_AddP(), &quot;should be base + off&quot;);
193   Node* base_src = src-&gt;in(AddPNode::Base);
194   Node* base_dest = dest-&gt;in(AddPNode::Base);
195 
196   MergeMemNode* mem = MergeMemNode::make(in_mem);
197 
198   const TypeInstPtr* inst_src = src_type-&gt;isa_instptr();
199 
200   if (inst_src == NULL) {
201     return NULL;
202   }
203 
204   if (!inst_src-&gt;klass_is_exact()) {
205     ciInstanceKlass* ik = inst_src-&gt;klass()-&gt;as_instance_klass();
206     assert(!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass(), &quot;inconsistent klass hierarchy&quot;);
207     phase-&gt;C-&gt;dependencies()-&gt;assert_leaf_type(ik);
208   }
209 
210   ciInstanceKlass* ik = inst_src-&gt;klass()-&gt;as_instance_klass();
211   assert(ik-&gt;nof_nonstatic_fields() &lt;= ArrayCopyLoadStoreMaxElem, &quot;too many fields&quot;);
212 
213   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
214   for (int i = 0; i &lt; count; i++) {
215     ciField* field = ik-&gt;nonstatic_field_at(i);
216     int fieldidx = phase-&gt;C-&gt;alias_type(field)-&gt;index();
217     const TypePtr* adr_type = phase-&gt;C-&gt;alias_type(field)-&gt;adr_type();
218     Node* off = phase-&gt;MakeConX(field-&gt;offset());
219     Node* next_src = phase-&gt;transform(new AddPNode(base_src,base_src,off));
220     Node* next_dest = phase-&gt;transform(new AddPNode(base_dest,base_dest,off));
221     BasicType bt = field-&gt;layout_type();
222 
223     const Type *type;
224     if (bt == T_OBJECT) {
225       if (!field-&gt;type()-&gt;is_loaded()) {
226         type = TypeInstPtr::BOTTOM;
227       } else {
228         ciType* field_klass = field-&gt;type();
229         type = TypeOopPtr::make_from_klass(field_klass-&gt;as_klass());
230       }
231     } else {
232       type = Type::get_const_basic_type(bt);
233     }
234 
235     Node* v = load(bs, phase, ctl, mem, next_src, adr_type, type, bt);
236     store(bs, phase, ctl, mem, next_dest, adr_type, v, type, bt);
237   }
238 
239   if (!finish_transform(phase, can_reshape, ctl, mem)) {
240     // Return NodeSentinel to indicate that the transform failed
241     return NodeSentinel;
242   }
243 
244   return mem;
245 }
246 
247 bool ArrayCopyNode::prepare_array_copy(PhaseGVN *phase, bool can_reshape,
248                                        Node*&amp; adr_src,
249                                        Node*&amp; base_src,
250                                        Node*&amp; adr_dest,
251                                        Node*&amp; base_dest,
252                                        BasicType&amp; copy_type,
253                                        const Type*&amp; value_type,
254                                        bool&amp; disjoint_bases) {
255   Node* src = in(ArrayCopyNode::Src);
256   Node* dest = in(ArrayCopyNode::Dest);
257   const Type* src_type = phase-&gt;type(src);
258   const TypeAryPtr* ary_src = src_type-&gt;isa_aryptr();
259 
260   if (is_arraycopy() || is_copyofrange() || is_copyof()) {
261     const Type* dest_type = phase-&gt;type(dest);
262     const TypeAryPtr* ary_dest = dest_type-&gt;isa_aryptr();
263     Node* src_offset = in(ArrayCopyNode::SrcPos);
264     Node* dest_offset = in(ArrayCopyNode::DestPos);
265 
266     // newly allocated object is guaranteed to not overlap with source object
267     disjoint_bases = is_alloc_tightly_coupled();
268 
269     if (ary_src  == NULL || ary_src-&gt;klass()  == NULL ||
270         ary_dest == NULL || ary_dest-&gt;klass() == NULL) {
271       // We don&#39;t know if arguments are arrays
272       return false;
273     }
274 
275     BasicType src_elem  = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
276     BasicType dest_elem = ary_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
277     if (src_elem  == T_ARRAY ||
278         (src_elem == T_VALUETYPE &amp;&amp; ary_src-&gt;klass()-&gt;is_obj_array_klass())) {
279       src_elem  = T_OBJECT;
280     }
281     if (dest_elem == T_ARRAY ||
282         (dest_elem == T_VALUETYPE &amp;&amp; ary_dest-&gt;klass()-&gt;is_obj_array_klass())) {
283       dest_elem = T_OBJECT;
284     }
285 
286     if (src_elem != dest_elem || dest_elem == T_VOID) {
287       // We don&#39;t know if arguments are arrays of the same type
288       return false;
289     }
290 
291     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
292     if (bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), dest_elem, false, BarrierSetC2::Optimization) ||
293         (src_elem == T_VALUETYPE &amp;&amp; ary_src-&gt;elem()-&gt;value_klass()-&gt;contains_oops() &amp;&amp;
294          bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), T_OBJECT, false, BarrierSetC2::Optimization))) {
295       // It&#39;s an object array copy but we can&#39;t emit the card marking that is needed
296       return false;
297     }
298 
299     value_type = ary_src-&gt;elem();
300 
301     base_src = src;
302     base_dest = dest;
303 
304     uint shift  = exact_log2(type2aelembytes(dest_elem));
305     if (dest_elem == T_VALUETYPE) {
306       ciValueArrayKlass* vak = ary_src-&gt;klass()-&gt;as_value_array_klass();
307       shift = vak-&gt;log2_element_size();
308     }
309     uint header = arrayOopDesc::base_offset_in_bytes(dest_elem);
310 
311     adr_src = src;
312     adr_dest = dest;
313 
314     src_offset = Compile::conv_I2X_index(phase, src_offset, ary_src-&gt;size());
315     dest_offset = Compile::conv_I2X_index(phase, dest_offset, ary_dest-&gt;size());
316     if (src_offset-&gt;is_top() || dest_offset-&gt;is_top()) {
317       // Offset is out of bounds (the ArrayCopyNode will be removed)
318       return false;
319     }
320 
321     Node* src_scale = phase-&gt;transform(new LShiftXNode(src_offset, phase-&gt;intcon(shift)));
322     Node* dest_scale = phase-&gt;transform(new LShiftXNode(dest_offset, phase-&gt;intcon(shift)));
323 
324     adr_src = phase-&gt;transform(new AddPNode(base_src, adr_src, phase-&gt;MakeConX(header)));
325     adr_dest = phase-&gt;transform(new AddPNode(base_dest, adr_dest, phase-&gt;MakeConX(header)));
326 
327     adr_src = phase-&gt;transform(new AddPNode(base_src, adr_src, src_scale));
328     adr_dest = phase-&gt;transform(new AddPNode(base_dest, adr_dest, dest_scale));
329 
330     copy_type = dest_elem;
331   } else {
332     assert(ary_src != NULL, &quot;should be a clone&quot;);
333     assert(is_clonebasic(), &quot;should be&quot;);
334 
335     disjoint_bases = true;
336     assert(src-&gt;is_AddP(), &quot;should be base + off&quot;);
337     assert(dest-&gt;is_AddP(), &quot;should be base + off&quot;);
338     adr_src = src;
339     base_src = src-&gt;in(AddPNode::Base);
340     adr_dest = dest;
341     base_dest = dest-&gt;in(AddPNode::Base);
342 
343     assert(phase-&gt;type(src-&gt;in(AddPNode::Offset))-&gt;is_intptr_t()-&gt;get_con() == phase-&gt;type(dest-&gt;in(AddPNode::Offset))-&gt;is_intptr_t()-&gt;get_con(), &quot;same start offset?&quot;);
344 
345     if (ary_src-&gt;elem()-&gt;make_oopptr() != NULL &amp;&amp;
346         ary_src-&gt;elem()-&gt;make_oopptr()-&gt;can_be_value_type()) {
347       return false;
348     }
349 
350     BasicType elem = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
351     if (elem == T_ARRAY ||
352         (elem == T_VALUETYPE &amp;&amp; ary_src-&gt;klass()-&gt;is_obj_array_klass())) {
353       elem = T_OBJECT;
354     }
355 
356     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
357     if (bs-&gt;array_copy_requires_gc_barriers(true, elem, true, BarrierSetC2::Optimization) ||
358         (elem == T_VALUETYPE &amp;&amp; ary_src-&gt;elem()-&gt;value_klass()-&gt;contains_oops() &amp;&amp;
359          bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Optimization))) {
360       return false;
361     }
362 
363     int diff = arrayOopDesc::base_offset_in_bytes(elem) - phase-&gt;type(src-&gt;in(AddPNode::Offset))-&gt;is_intptr_t()-&gt;get_con();
364     assert(diff &gt;= 0, &quot;clone should not start after 1st array element&quot;);
365     if (diff &gt; 0) {
366       adr_src = phase-&gt;transform(new AddPNode(base_src, adr_src, phase-&gt;MakeConX(diff)));
367       adr_dest = phase-&gt;transform(new AddPNode(base_dest, adr_dest, phase-&gt;MakeConX(diff)));
368     }
369 
370     copy_type = elem;
371     value_type = ary_src-&gt;elem();
372   }
373   return true;
374 }
375 
376 const TypeAryPtr* ArrayCopyNode::get_address_type(PhaseGVN* phase, const TypePtr* atp, Node* n) {
377   if (atp == TypeOopPtr::BOTTOM) {
378     atp = phase-&gt;type(n)-&gt;isa_ptr();
379   }
380   // adjust atp to be the correct array element address type
381   return atp-&gt;add_offset(Type::OffsetBot)-&gt;is_aryptr();
382 }
383 
384 void ArrayCopyNode::array_copy_test_overlap(GraphKit&amp; kit, bool disjoint_bases, int count, Node*&amp; backward_ctl) {
385   Node* ctl = kit.control();
386   if (!disjoint_bases &amp;&amp; count &gt; 1) {
387     PhaseGVN&amp; gvn = kit.gvn();
388     Node* src_offset = in(ArrayCopyNode::SrcPos);
389     Node* dest_offset = in(ArrayCopyNode::DestPos);
390     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;should be&quot;);
391     Node* cmp = gvn.transform(new CmpINode(src_offset, dest_offset));
392     Node *bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));
393     IfNode *iff = new IfNode(ctl, bol, PROB_FAIR, COUNT_UNKNOWN);
394 
395     gvn.transform(iff);
396 
397     kit.set_control(gvn.transform(new IfFalseNode(iff)));
398     backward_ctl = gvn.transform(new IfTrueNode(iff));
399   }
400 }
401 
402 void ArrayCopyNode::copy(GraphKit&amp; kit,
403                          const TypeAryPtr* atp_src,
404                          const TypeAryPtr* atp_dest,
405                          int i,
406                          Node* base_src,
407                          Node* base_dest,
408                          Node* adr_src,
409                          Node* adr_dest,
410                          BasicType copy_type,
411                          const Type* value_type) {
412   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
413   Node* ctl = kit.control();
414   if (copy_type == T_VALUETYPE) {
415     ciValueArrayKlass* vak = atp_src-&gt;klass()-&gt;as_value_array_klass();
416     ciValueKlass* vk = vak-&gt;element_klass()-&gt;as_value_klass();
417     for (int j = 0; j &lt; vk-&gt;nof_nonstatic_fields(); j++) {
418       ciField* field = vk-&gt;nonstatic_field_at(j);
419       int off_in_vt = field-&gt;offset() - vk-&gt;first_field_offset();
420       Node* off  = kit.MakeConX(off_in_vt + i * vak-&gt;element_byte_size());
421       ciType* ft = field-&gt;type();
422       BasicType bt = type2field[ft-&gt;basic_type()];
423       assert(!field-&gt;is_flattened(), &quot;flattened field encountered&quot;);
424       if (bt == T_VALUETYPE) {
425         bt = T_OBJECT;
426       }
427       const Type* rt = Type::get_const_type(ft);
428       const TypePtr* adr_type = atp_src-&gt;with_field_offset(off_in_vt)-&gt;add_offset(Type::OffsetBot);
429       assert(!bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), bt, false, BarrierSetC2::Optimization), &quot;GC barriers required&quot;);
430       Node* next_src = kit.gvn().transform(new AddPNode(base_src, adr_src, off));
431       Node* next_dest = kit.gvn().transform(new AddPNode(base_dest, adr_dest, off));
432       Node* v = load(bs, &amp;kit.gvn(), ctl, kit.merged_memory(), next_src, adr_type, rt, bt);
433       store(bs, &amp;kit.gvn(), ctl, kit.merged_memory(), next_dest, adr_type, v, rt, bt);
434     }
435   } else {
436     Node* off = kit.MakeConX(type2aelembytes(copy_type) * i);
437     Node* next_src = kit.gvn().transform(new AddPNode(base_src, adr_src, off));
438     Node* next_dest = kit.gvn().transform(new AddPNode(base_dest, adr_dest, off));
439     Node* v = load(bs, &amp;kit.gvn(), ctl, kit.merged_memory(), next_src, atp_src, value_type, copy_type);
440     store(bs, &amp;kit.gvn(), ctl, kit.merged_memory(), next_dest, atp_dest, v, value_type, copy_type);
441   }
442   kit.set_control(ctl);
443 }
444 
445 
446 void ArrayCopyNode::array_copy_forward(GraphKit&amp; kit,
447                                        bool can_reshape,
448                                        const TypeAryPtr* atp_src,
449                                        const TypeAryPtr* atp_dest,
450                                        Node* adr_src,
451                                        Node* base_src,
452                                        Node* adr_dest,
453                                        Node* base_dest,
454                                        BasicType copy_type,
455                                        const Type* value_type,
456                                        int count) {
457   if (!kit.stopped()) {
458     // copy forward
459     if (count &gt; 0) {
460       for (int i = 0; i &lt; count; i++) {
461         copy(kit, atp_src, atp_dest, i, base_src, base_dest, adr_src, adr_dest, copy_type, value_type);
462       }
463     } else if(can_reshape) {
464       PhaseGVN&amp; gvn = kit.gvn();
465       assert(gvn.is_IterGVN(), &quot;&quot;);
466       gvn.record_for_igvn(adr_src);
467       gvn.record_for_igvn(adr_dest);
468     }
469   }
470 }
471 
472 void ArrayCopyNode::array_copy_backward(GraphKit&amp; kit,
473                                         bool can_reshape,
474                                         const TypeAryPtr* atp_src,
475                                         const TypeAryPtr* atp_dest,
476                                         Node* adr_src,
477                                         Node* base_src,
478                                         Node* adr_dest,
479                                         Node* base_dest,
480                                         BasicType copy_type,
481                                         const Type* value_type,
482                                         int count) {
483   if (!kit.stopped()) {
484     // copy backward
485     PhaseGVN&amp; gvn = kit.gvn();
486 
487     if (count &gt; 0) {
488       for (int i = count-1; i &gt;= 0; i--) {
489         copy(kit, atp_src, atp_dest, i, base_src, base_dest, adr_src, adr_dest, copy_type, value_type);
490       }
491     } else if(can_reshape) {
492       PhaseGVN&amp; gvn = kit.gvn();
493       assert(gvn.is_IterGVN(), &quot;&quot;);
494       gvn.record_for_igvn(adr_src);
495       gvn.record_for_igvn(adr_dest);
496     }
497   }
498 }
499 
500 bool ArrayCopyNode::finish_transform(PhaseGVN *phase, bool can_reshape,
501                                      Node* ctl, Node *mem) {
502   if (can_reshape) {
503     PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
504     igvn-&gt;set_delay_transform(false);
505     if (is_clonebasic()) {
506       Node* out_mem = proj_out(TypeFunc::Memory);
507 
508       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
509       if (out_mem-&gt;outcnt() != 1 || !out_mem-&gt;raw_out(0)-&gt;is_MergeMem() ||
510           out_mem-&gt;raw_out(0)-&gt;outcnt() != 1 || !out_mem-&gt;raw_out(0)-&gt;raw_out(0)-&gt;is_MemBar()) {
511         assert(bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Optimization), &quot;can only happen with card marking&quot;);
512         return false;
513       }
514 
515       igvn-&gt;replace_node(out_mem-&gt;raw_out(0), mem);
516 
517       Node* out_ctl = proj_out(TypeFunc::Control);
518       igvn-&gt;replace_node(out_ctl, ctl);
519     } else {
520       // replace fallthrough projections of the ArrayCopyNode by the
521       // new memory, control and the input IO.
522       CallProjections* callprojs = extract_projections(true, false);
523 
524       if (callprojs-&gt;fallthrough_ioproj != NULL) {
525         igvn-&gt;replace_node(callprojs-&gt;fallthrough_ioproj, in(TypeFunc::I_O));
526       }
527       if (callprojs-&gt;fallthrough_memproj != NULL) {
528         igvn-&gt;replace_node(callprojs-&gt;fallthrough_memproj, mem);
529       }
530       if (callprojs-&gt;fallthrough_catchproj != NULL) {
531         igvn-&gt;replace_node(callprojs-&gt;fallthrough_catchproj, ctl);
532       }
533 
534       // The ArrayCopyNode is not disconnected. It still has the
535       // projections for the exception case. Replace current
536       // ArrayCopyNode with a dummy new one with a top() control so
537       // that this part of the graph stays consistent but is
538       // eventually removed.
539 
540       set_req(0, phase-&gt;C-&gt;top());
541       remove_dead_region(phase, can_reshape);
542     }
543   } else {
544     if (in(TypeFunc::Control) != ctl) {
545       // we can&#39;t return new memory and control from Ideal at parse time
546 #ifdef ASSERT
547       Node* src = in(ArrayCopyNode::Src);
548       const Type* src_type = phase-&gt;type(src);
549       const TypeAryPtr* ary_src = src_type-&gt;isa_aryptr();
550       BasicType elem = ary_src != NULL ? ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type() : T_CONFLICT;
551       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
552       assert(!is_clonebasic() || bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Optimization) ||
553              (ary_src != NULL &amp;&amp; elem == T_VALUETYPE &amp;&amp; ary_src-&gt;klass()-&gt;is_obj_array_klass()), &quot;added control for clone?&quot;);
554 #endif
555       assert(!is_clonebasic() || UseShenandoahGC, &quot;added control for clone?&quot;);
556       phase-&gt;record_for_igvn(this);
557       return false;
558     }
559   }
560   return true;
561 }
562 
563 
564 Node *ArrayCopyNode::Ideal(PhaseGVN *phase, bool can_reshape) {
565   // Perform any generic optimizations first
566   Node* result = SafePointNode::Ideal(phase, can_reshape);
567   if (result != NULL) {
568     return result;
569   }
570 
571   if (StressArrayCopyMacroNode &amp;&amp; !can_reshape) {
572     phase-&gt;record_for_igvn(this);
573     return NULL;
574   }
575 
576   // See if it&#39;s a small array copy and we can inline it as
577   // loads/stores
578   // Here we can only do:
579   // - arraycopy if all arguments were validated before and we don&#39;t
580   // need card marking
581   // - clone for which we don&#39;t need to do card marking
582 
583   if (!is_clonebasic() &amp;&amp; !is_arraycopy_validated() &amp;&amp;
584       !is_copyofrange_validated() &amp;&amp; !is_copyof_validated()) {
585     return NULL;
586   }
587 
588   assert(in(TypeFunc::Control) != NULL &amp;&amp;
589          in(TypeFunc::Memory) != NULL &amp;&amp;
590          in(ArrayCopyNode::Src) != NULL &amp;&amp;
591          in(ArrayCopyNode::Dest) != NULL &amp;&amp;
592          in(ArrayCopyNode::Length) != NULL &amp;&amp;
593          ((in(ArrayCopyNode::SrcPos) != NULL &amp;&amp; in(ArrayCopyNode::DestPos) != NULL) ||
594           is_clonebasic()), &quot;broken inputs&quot;);
595 
596   if (in(TypeFunc::Control)-&gt;is_top() ||
597       in(TypeFunc::Memory)-&gt;is_top() ||
598       phase-&gt;type(in(ArrayCopyNode::Src)) == Type::TOP ||
599       phase-&gt;type(in(ArrayCopyNode::Dest)) == Type::TOP ||
600       (in(ArrayCopyNode::SrcPos) != NULL &amp;&amp; in(ArrayCopyNode::SrcPos)-&gt;is_top()) ||
601       (in(ArrayCopyNode::DestPos) != NULL &amp;&amp; in(ArrayCopyNode::DestPos)-&gt;is_top())) {
602     return NULL;
603   }
604 
605   int count = get_count(phase);
606 
607   if (count &lt; 0 || count &gt; ArrayCopyLoadStoreMaxElem) {
608     return NULL;
609   }
610 
611   Node* src = in(ArrayCopyNode::Src);
612   Node* dest = in(ArrayCopyNode::Dest);
613   const Type* src_type = phase-&gt;type(src);
614   const Type* dest_type = phase-&gt;type(dest);
615 
616   if (src_type-&gt;isa_aryptr() &amp;&amp; dest_type-&gt;isa_instptr()) {
617     // clone used for load of unknown value type can&#39;t be optimized at
618     // this point
619     return NULL;
620   }
621 
622   Node* mem = try_clone_instance(phase, can_reshape, count);
623   if (mem != NULL) {
624     return (mem == NodeSentinel) ? NULL : mem;
625   }
626 
627   Node* adr_src = NULL;
628   Node* base_src = NULL;
629   Node* adr_dest = NULL;
630   Node* base_dest = NULL;
631   BasicType copy_type = T_ILLEGAL;
632   const Type* value_type = NULL;
633   bool disjoint_bases = false;
634 
635   if (!prepare_array_copy(phase, can_reshape,
636                           adr_src, base_src, adr_dest, base_dest,
637                           copy_type, value_type, disjoint_bases)) {
638     return NULL;
639   }
640 
641   JVMState* new_jvms = NULL;
642   SafePointNode* new_map = NULL;
643   if (!is_clonebasic()) {
644     new_jvms = jvms()-&gt;clone_shallow(phase-&gt;C);
645     new_map = new SafePointNode(req(), new_jvms);
646     for (uint i = TypeFunc::FramePtr; i &lt; req(); i++) {
647       new_map-&gt;init_req(i, in(i));
648     }
649     new_jvms-&gt;set_map(new_map);
650   } else {
651     new_jvms = new (phase-&gt;C) JVMState(0);
652     new_map = new SafePointNode(TypeFunc::Parms, new_jvms);
653     new_jvms-&gt;set_map(new_map);
654   }
655   new_map-&gt;set_control(in(TypeFunc::Control));
656   new_map-&gt;set_memory(MergeMemNode::make(in(TypeFunc::Memory)));
657   new_map-&gt;set_i_o(in(TypeFunc::I_O));
658   phase-&gt;record_for_igvn(new_map);
659 
660   const TypeAryPtr* atp_src = get_address_type(phase, _src_type, src);
661   const TypeAryPtr* atp_dest = get_address_type(phase, _dest_type, dest);
662   uint alias_idx_src = phase-&gt;C-&gt;get_alias_index(atp_src);
663   uint alias_idx_dest = phase-&gt;C-&gt;get_alias_index(atp_dest);
664 
665   if (can_reshape) {
666     assert(!phase-&gt;is_IterGVN()-&gt;delay_transform(), &quot;cannot delay transforms&quot;);
667     phase-&gt;is_IterGVN()-&gt;set_delay_transform(true);
668   }
669 
670   GraphKit kit(new_jvms, phase);
671 
672   SafePointNode* backward_map = NULL;
673   SafePointNode* forward_map = NULL;
674   Node* backward_ctl = phase-&gt;C-&gt;top();
675 
676   array_copy_test_overlap(kit, disjoint_bases, count, backward_ctl);
677 
678   {
679     PreserveJVMState pjvms(&amp;kit);
680 
681     array_copy_forward(kit, can_reshape,
682                        atp_src, atp_dest,
683                        adr_src, base_src, adr_dest, base_dest,
684                        copy_type, value_type, count);
685 
686     forward_map = kit.stop();
687   }
688 
689   kit.set_control(backward_ctl);
690   array_copy_backward(kit, can_reshape,
691                       atp_src, atp_dest,
692                       adr_src, base_src, adr_dest, base_dest,
693                       copy_type, value_type, count);
694 
695   backward_map = kit.stop();
696 
697   if (!forward_map-&gt;control()-&gt;is_top() &amp;&amp; !backward_map-&gt;control()-&gt;is_top()) {
698     assert(forward_map-&gt;i_o() == backward_map-&gt;i_o(), &quot;need a phi on IO?&quot;);
699     Node* ctl = new RegionNode(3);
700     Node* mem = new PhiNode(ctl, Type::MEMORY, TypePtr::BOTTOM);
701     kit.set_map(forward_map);
702     ctl-&gt;init_req(1, kit.control());
703     mem-&gt;init_req(1, kit.reset_memory());
704     kit.set_map(backward_map);
705     ctl-&gt;init_req(2, kit.control());
706     mem-&gt;init_req(2, kit.reset_memory());
707     kit.set_control(phase-&gt;transform(ctl));
708     kit.set_all_memory(phase-&gt;transform(mem));
709   } else if (!forward_map-&gt;control()-&gt;is_top()) {
710     kit.set_map(forward_map);
711   } else {
712     assert(!backward_map-&gt;control()-&gt;is_top(), &quot;no copy?&quot;);
713     kit.set_map(backward_map);
714   }
715 
716   if (can_reshape) {
717     assert(phase-&gt;is_IterGVN()-&gt;delay_transform(), &quot;should be delaying transforms&quot;);
718     phase-&gt;is_IterGVN()-&gt;set_delay_transform(false);
719   }
720 
721   mem = kit.map()-&gt;memory();
722   if (!finish_transform(phase, can_reshape, kit.control(), mem)) {
723     if (!can_reshape) {
724       phase-&gt;record_for_igvn(this);
725     }
726     return NULL;
727   }
728 
729   return mem;
730 }
731 
732 bool ArrayCopyNode::may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) {
733   Node* dest = in(ArrayCopyNode::Dest);
734   if (dest-&gt;is_top()) {
735     return false;
736   }
737   const TypeOopPtr* dest_t = phase-&gt;type(dest)-&gt;is_oopptr();
738   assert(!dest_t-&gt;is_known_instance() || _dest_type-&gt;is_known_instance(), &quot;result of EA not recorded&quot;);
739   assert(in(ArrayCopyNode::Src)-&gt;is_top() || !phase-&gt;type(in(ArrayCopyNode::Src))-&gt;is_oopptr()-&gt;is_known_instance() ||
740          _src_type-&gt;is_known_instance(), &quot;result of EA not recorded&quot;);
741 
742   if (_dest_type != TypeOopPtr::BOTTOM || t_oop-&gt;is_known_instance()) {
743     assert(_dest_type == TypeOopPtr::BOTTOM || _dest_type-&gt;is_known_instance(), &quot;result of EA is known instance&quot;);
744     return t_oop-&gt;instance_id() == _dest_type-&gt;instance_id();
745   }
746 
747   return CallNode::may_modify_arraycopy_helper(dest_t, t_oop, phase);
748 }
749 
750 bool ArrayCopyNode::may_modify_helper(const TypeOopPtr *t_oop, Node* n, PhaseTransform *phase, CallNode*&amp; call) {
751   if (n != NULL &amp;&amp;
752       n-&gt;is_Call() &amp;&amp;
753       n-&gt;as_Call()-&gt;may_modify(t_oop, phase) &amp;&amp;
754       (n-&gt;as_Call()-&gt;is_ArrayCopy() || n-&gt;as_Call()-&gt;is_call_to_arraycopystub())) {
755     call = n-&gt;as_Call();
756     return true;
757   }
758   return false;
759 }
760 
761 bool ArrayCopyNode::may_modify(const TypeOopPtr *t_oop, MemBarNode* mb, PhaseTransform *phase, ArrayCopyNode*&amp; ac) {
762 
763   Node* c = mb-&gt;in(0);
764 
765   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
766   // step over g1 gc barrier if we&#39;re at e.g. a clone with ReduceInitialCardMarks off
767   c = bs-&gt;step_over_gc_barrier(c);
768 
769   CallNode* call = NULL;
770   guarantee(c != NULL, &quot;step_over_gc_barrier failed, there must be something to step to.&quot;);
771   if (c-&gt;is_Region()) {
772     for (uint i = 1; i &lt; c-&gt;req(); i++) {
773       if (c-&gt;in(i) != NULL) {
774         Node* n = c-&gt;in(i)-&gt;in(0);
775         if (may_modify_helper(t_oop, n, phase, call)) {
776           ac = call-&gt;isa_ArrayCopy();
777           assert(c == mb-&gt;in(0), &quot;only for clone&quot;);
778           return true;
779         }
780       }
781     }
782   } else if (may_modify_helper(t_oop, c-&gt;in(0), phase, call)) {
783     ac = call-&gt;isa_ArrayCopy();
784 #ifdef ASSERT
785     bool use_ReduceInitialCardMarks = BarrierSet::barrier_set()-&gt;is_a(BarrierSet::CardTableBarrierSet) &amp;&amp;
786       static_cast&lt;CardTableBarrierSetC2*&gt;(bs)-&gt;use_ReduceInitialCardMarks();
787     assert(c == mb-&gt;in(0) || (ac != NULL &amp;&amp; ac-&gt;is_clonebasic() &amp;&amp; !use_ReduceInitialCardMarks), &quot;only for clone&quot;);
788 #endif
789     return true;
790   }
791 
792   return false;
793 }
794 
795 // Does this array copy modify offsets between offset_lo and offset_hi
796 // in the destination array
797 // if must_modify is false, return true if the copy could write
798 // between offset_lo and offset_hi
799 // if must_modify is true, return true if the copy is guaranteed to
800 // write between offset_lo and offset_hi
801 bool ArrayCopyNode::modifies(intptr_t offset_lo, intptr_t offset_hi, PhaseTransform* phase, bool must_modify) const {
802   assert(_kind == ArrayCopy || _kind == CopyOf || _kind == CopyOfRange, &quot;only for real array copies&quot;);
803 
804   Node* dest = in(Dest);
805   Node* dest_pos = in(DestPos);
806   Node* len = in(Length);
807 
808   const TypeInt *dest_pos_t = phase-&gt;type(dest_pos)-&gt;isa_int();
809   const TypeInt *len_t = phase-&gt;type(len)-&gt;isa_int();
810   const TypeAryPtr* ary_t = phase-&gt;type(dest)-&gt;isa_aryptr();
811 
812   if (dest_pos_t == NULL || len_t == NULL || ary_t == NULL) {
813     return !must_modify;
814   }
815 
816   ciArrayKlass* klass = ary_t-&gt;klass()-&gt;as_array_klass();
817   BasicType ary_elem = klass-&gt;element_type()-&gt;basic_type();
818   uint header = arrayOopDesc::base_offset_in_bytes(ary_elem);
819   uint elemsize = type2aelembytes(ary_elem);
820   if (klass-&gt;is_value_array_klass()) {
821     elemsize = klass-&gt;as_value_array_klass()-&gt;element_byte_size();
822   }
823 
824   jlong dest_pos_plus_len_lo = (((jlong)dest_pos_t-&gt;_lo) + len_t-&gt;_lo) * elemsize + header;
825   jlong dest_pos_plus_len_hi = (((jlong)dest_pos_t-&gt;_hi) + len_t-&gt;_hi) * elemsize + header;
826   jlong dest_pos_lo = ((jlong)dest_pos_t-&gt;_lo) * elemsize + header;
827   jlong dest_pos_hi = ((jlong)dest_pos_t-&gt;_hi) * elemsize + header;
828 
829   if (must_modify) {
830     if (offset_lo &gt;= dest_pos_hi &amp;&amp; offset_hi &lt; dest_pos_plus_len_lo) {
831       return true;
832     }
833   } else {
834     if (offset_hi &gt;= dest_pos_lo &amp;&amp; offset_lo &lt; dest_pos_plus_len_hi) {
835       return true;
836     }
837   }
838   return false;
839 }
    </pre>
  </body>
</html>
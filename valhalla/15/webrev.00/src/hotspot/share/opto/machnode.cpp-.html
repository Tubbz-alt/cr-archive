<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/machnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1997, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/collectedHeap.hpp&quot;
 27 #include &quot;memory/universe.hpp&quot;
 28 #include &quot;oops/compressedOops.hpp&quot;
 29 #include &quot;opto/machnode.hpp&quot;
 30 #include &quot;opto/regalloc.hpp&quot;
 31 #include &quot;utilities/vmError.hpp&quot;
 32 
 33 //=============================================================================
 34 // Return the value requested
 35 // result register lookup, corresponding to int_format
 36 int MachOper::reg(PhaseRegAlloc *ra_, const Node *node) const {
 37   return (int)ra_-&gt;get_encode(node);
 38 }
 39 // input register lookup, corresponding to ext_format
 40 int MachOper::reg(PhaseRegAlloc *ra_, const Node *node, int idx) const {
 41   return (int)(ra_-&gt;get_encode(node-&gt;in(idx)));
 42 }
 43 intptr_t  MachOper::constant() const { return 0x00; }
 44 relocInfo::relocType MachOper::constant_reloc() const { return relocInfo::none; }
 45 jdouble MachOper::constantD() const { ShouldNotReachHere(); return 0.0; }
 46 jfloat  MachOper::constantF() const { ShouldNotReachHere(); return 0.0; }
 47 jlong   MachOper::constantL() const { ShouldNotReachHere(); return CONST64(0) ; }
 48 TypeOopPtr *MachOper::oop() const { return NULL; }
 49 int MachOper::ccode() const { return 0x00; }
 50 // A zero, default, indicates this value is not needed.
 51 // May need to lookup the base register, as done in int_ and ext_format
 52 int MachOper::base (PhaseRegAlloc *ra_, const Node *node, int idx)  const { return 0x00; }
 53 int MachOper::index(PhaseRegAlloc *ra_, const Node *node, int idx)  const { return 0x00; }
 54 int MachOper::scale()  const { return 0x00; }
 55 int MachOper::disp (PhaseRegAlloc *ra_, const Node *node, int idx)  const { return 0x00; }
 56 int MachOper::constant_disp()  const { return 0; }
 57 int MachOper::base_position()  const { return -1; }  // no base input
 58 int MachOper::index_position() const { return -1; }  // no index input
 59 // Check for PC-Relative displacement
 60 relocInfo::relocType MachOper::disp_reloc() const { return relocInfo::none; }
 61 // Return the label
 62 Label*   MachOper::label()  const { ShouldNotReachHere(); return 0; }
 63 intptr_t MachOper::method() const { ShouldNotReachHere(); return 0; }
 64 
 65 
 66 //------------------------------negate-----------------------------------------
 67 // Negate conditional branches.  Error for non-branch operands
 68 void MachOper::negate() {
 69   ShouldNotCallThis();
 70 }
 71 
 72 //-----------------------------type--------------------------------------------
 73 const Type *MachOper::type() const {
 74   return Type::BOTTOM;
 75 }
 76 
 77 //------------------------------in_RegMask-------------------------------------
 78 const RegMask *MachOper::in_RegMask(int index) const {
 79   ShouldNotReachHere();
 80   return NULL;
 81 }
 82 
 83 //------------------------------dump_spec--------------------------------------
 84 // Print any per-operand special info
 85 #ifndef PRODUCT
 86 void MachOper::dump_spec(outputStream *st) const { }
 87 #endif
 88 
 89 //------------------------------hash-------------------------------------------
 90 // Print any per-operand special info
 91 uint MachOper::hash() const {
 92   ShouldNotCallThis();
 93   return 5;
 94 }
 95 
 96 //------------------------------cmp--------------------------------------------
 97 // Print any per-operand special info
 98 bool MachOper::cmp( const MachOper &amp;oper ) const {
 99   ShouldNotCallThis();
100   return opcode() == oper.opcode();
101 }
102 
103 //------------------------------hash-------------------------------------------
104 // Print any per-operand special info
105 uint labelOper::hash() const {
106   return _block_num;
107 }
108 
109 //------------------------------cmp--------------------------------------------
110 // Print any per-operand special info
111 bool labelOper::cmp( const MachOper &amp;oper ) const {
112   return (opcode() == oper.opcode()) &amp;&amp; (_label == oper.label());
113 }
114 
115 //------------------------------hash-------------------------------------------
116 // Print any per-operand special info
117 uint methodOper::hash() const {
118   return (uint)_method;
119 }
120 
121 //------------------------------cmp--------------------------------------------
122 // Print any per-operand special info
123 bool methodOper::cmp( const MachOper &amp;oper ) const {
124   return (opcode() == oper.opcode()) &amp;&amp; (_method == oper.method());
125 }
126 
127 
128 //=============================================================================
129 //------------------------------MachNode---------------------------------------
130 
131 //------------------------------emit-------------------------------------------
132 void MachNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
133   #ifdef ASSERT
134   tty-&gt;print(&quot;missing MachNode emit function: &quot;);
135   dump();
136   #endif
137   ShouldNotCallThis();
138 }
139 
140 //---------------------------postalloc_expand----------------------------------
141 // Expand node after register allocation.
142 void MachNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {}
143 
144 //------------------------------size-------------------------------------------
145 // Size of instruction in bytes
146 uint MachNode::size(PhaseRegAlloc *ra_) const {
147   // If a virtual was not defined for this specific instruction,
148   // Call the helper which finds the size by emitting the bits.
149   return MachNode::emit_size(ra_);
150 }
151 
152 //------------------------------size-------------------------------------------
153 // Helper function that computes size by emitting code
154 uint MachNode::emit_size(PhaseRegAlloc *ra_) const {
155   // Emit into a trash buffer and count bytes emitted.
156   assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
157   return ra_-&gt;C-&gt;scratch_emit_size(this);
158 }
159 
160 
161 
162 //------------------------------hash-------------------------------------------
163 uint MachNode::hash() const {
164   uint no = num_opnds();
165   uint sum = rule();
166   for( uint i=0; i&lt;no; i++ )
167     sum += _opnds[i]-&gt;hash();
168   return sum+Node::hash();
169 }
170 
171 //-----------------------------cmp---------------------------------------------
172 bool MachNode::cmp( const Node &amp;node ) const {
173   MachNode&amp; n = *((Node&amp;)node).as_Mach();
174   uint no = num_opnds();
175   if( no != n.num_opnds() ) return false;
176   if( rule() != n.rule() ) return false;
177   for( uint i=0; i&lt;no; i++ )    // All operands must match
178     if( !_opnds[i]-&gt;cmp( *n._opnds[i] ) )
179       return false;             // mis-matched operands
180   return true;                  // match
181 }
182 
183 // Return an equivalent instruction using memory for cisc_operand position
184 MachNode *MachNode::cisc_version(int offset) {
185   ShouldNotCallThis();
186   return NULL;
187 }
188 
189 void MachNode::use_cisc_RegMask() {
190   ShouldNotReachHere();
191 }
192 
193 
194 //-----------------------------in_RegMask--------------------------------------
195 const RegMask &amp;MachNode::in_RegMask( uint idx ) const {
196   uint numopnds = num_opnds();        // Virtual call for number of operands
197   uint skipped   = oper_input_base(); // Sum of leaves skipped so far
198   if( idx &lt; skipped ) {
199     assert( ideal_Opcode() == Op_AddP, &quot;expected base ptr here&quot; );
200     assert( idx == 1, &quot;expected base ptr here&quot; );
201     // debug info can be anywhere
202     return *Compile::current()-&gt;matcher()-&gt;idealreg2spillmask[Op_RegP];
203   }
204   uint opcnt     = 1;                 // First operand
205   uint num_edges = _opnds[1]-&gt;num_edges(); // leaves for first operand
206   while( idx &gt;= skipped+num_edges ) {
207     skipped += num_edges;
208     opcnt++;                          // Bump operand count
209     assert( opcnt &lt; numopnds, &quot;Accessing non-existent operand&quot; );
210     num_edges = _opnds[opcnt]-&gt;num_edges(); // leaves for next operand
211   }
212 
213   const RegMask *rm = cisc_RegMask();
214   if( rm == NULL || (int)opcnt != cisc_operand() ) {
215     rm = _opnds[opcnt]-&gt;in_RegMask(idx-skipped);
216   }
217   return *rm;
218 }
219 
220 //-----------------------------memory_inputs--------------------------------
221 const MachOper*  MachNode::memory_inputs(Node* &amp;base, Node* &amp;index) const {
222   const MachOper* oper = memory_operand();
223 
224   if (oper == (MachOper*)-1) {
225     base = NodeSentinel;
226     index = NodeSentinel;
227   } else {
228     base = NULL;
229     index = NULL;
230     if (oper != NULL) {
231       // It has a unique memory operand.  Find its index.
232       int oper_idx = num_opnds();
233       while (--oper_idx &gt;= 0) {
234         if (_opnds[oper_idx] == oper)  break;
235       }
236       int oper_pos = operand_index(oper_idx);
237       int base_pos = oper-&gt;base_position();
238       if (base_pos &gt;= 0) {
239         base = _in[oper_pos+base_pos];
240       }
241       int index_pos = oper-&gt;index_position();
242       if (index_pos &gt;= 0) {
243         index = _in[oper_pos+index_pos];
244       }
245     }
246   }
247 
248   return oper;
249 }
250 
251 //-----------------------------get_base_and_disp----------------------------
252 const Node* MachNode::get_base_and_disp(intptr_t &amp;offset, const TypePtr* &amp;adr_type) const {
253 
254   // Find the memory inputs using our helper function
255   Node* base;
256   Node* index;
257   const MachOper* oper = memory_inputs(base, index);
258 
259   if (oper == NULL) {
260     // Base has been set to NULL
261     offset = 0;
262   } else if (oper == (MachOper*)-1) {
263     // Base has been set to NodeSentinel
264     // There is not a unique memory use here.  We will fall to AliasIdxBot.
265     offset = Type::OffsetBot;
266   } else {
267     // Base may be NULL, even if offset turns out to be != 0
268 
269     intptr_t disp = oper-&gt;constant_disp();
270     int scale = oper-&gt;scale();
271     // Now we have collected every part of the ADLC MEMORY_INTER.
272     // See if it adds up to a base + offset.
273     if (index != NULL) {
274       const Type* t_index = index-&gt;bottom_type();
275       if (t_index-&gt;isa_narrowoop() || t_index-&gt;isa_narrowklass()) { // EncodeN, LoadN, LoadConN, LoadNKlass,
276                                                                     // EncodeNKlass, LoadConNklass.
277         // Memory references through narrow oops have a
278         // funny base so grab the type from the index:
279         // [R12 + narrow_oop_reg&lt;&lt;3 + offset]
280         assert(base == NULL, &quot;Memory references through narrow oops have no base&quot;);
281         offset = disp;
282         adr_type = t_index-&gt;make_ptr()-&gt;add_offset(offset);
283         return NULL;
284       } else if (!index-&gt;is_Con()) {
285         disp = Type::OffsetBot;
286       } else if (disp != Type::OffsetBot) {
287         const TypeX* ti = t_index-&gt;isa_intptr_t();
288         if (ti == NULL) {
289           disp = Type::OffsetBot;  // a random constant??
290         } else {
291           disp += ti-&gt;get_con() &lt;&lt; scale;
292         }
293       }
294     }
295     offset = disp;
296 
297     // In i486.ad, indOffset32X uses base==RegI and disp==RegP,
298     // this will prevent alias analysis without the following support:
299     // Lookup the TypePtr used by indOffset32X, a compile-time constant oop,
300     // Add the offset determined by the &quot;base&quot;, or use Type::OffsetBot.
301     if( adr_type == TYPE_PTR_SENTINAL ) {
302       const TypePtr *t_disp = oper-&gt;disp_as_type();  // only !NULL for indOffset32X
303       if (t_disp != NULL) {
304         offset = Type::OffsetBot;
305         const Type* t_base = base-&gt;bottom_type();
306         if (t_base-&gt;isa_intptr_t()) {
307           const TypeX *t_offset = t_base-&gt;is_intptr_t();
308           if( t_offset-&gt;is_con() ) {
309             offset = t_offset-&gt;get_con();
310           }
311         }
312         adr_type = t_disp-&gt;add_offset(offset);
313       } else if( base == NULL &amp;&amp; offset != 0 &amp;&amp; offset != Type::OffsetBot ) {
314         // Use ideal type if it is oop ptr.
315         const TypePtr *tp = oper-&gt;type()-&gt;isa_ptr();
316         if( tp != NULL) {
317           adr_type = tp;
318         }
319       }
320     }
321 
322   }
323   return base;
324 }
325 
326 
327 //---------------------------------adr_type---------------------------------
328 const class TypePtr *MachNode::adr_type() const {
329   intptr_t offset = 0;
330   const TypePtr *adr_type = TYPE_PTR_SENTINAL;  // attempt computing adr_type
331   const Node *base = get_base_and_disp(offset, adr_type);
332   if( adr_type != TYPE_PTR_SENTINAL ) {
333     return adr_type;      // get_base_and_disp has the answer
334   }
335 
336   // Direct addressing modes have no base node, simply an indirect
337   // offset, which is always to raw memory.
338   // %%%%% Someday we&#39;d like to allow constant oop offsets which
339   // would let Intel load from static globals in 1 instruction.
340   // Currently Intel requires 2 instructions and a register temp.
341   if (base == NULL) {
342     // NULL base, zero offset means no memory at all (a null pointer!)
343     if (offset == 0) {
344       return NULL;
345     }
346     // NULL base, any offset means any pointer whatever
347     if (offset == Type::OffsetBot) {
348       return TypePtr::BOTTOM;
349     }
350     // %%% make offset be intptr_t
351     assert(!Universe::heap()-&gt;is_in(cast_to_oop(offset)), &quot;must be a raw ptr&quot;);
352     return TypeRawPtr::BOTTOM;
353   }
354 
355   // base of -1 with no particular offset means all of memory
356   if (base == NodeSentinel)  return TypePtr::BOTTOM;
357 
358   const Type* t = base-&gt;bottom_type();
359   if (t-&gt;isa_narrowoop() &amp;&amp; CompressedOops::shift() == 0) {
360     // 32-bit unscaled narrow oop can be the base of any address expression
361     t = t-&gt;make_ptr();
362   }
363   if (t-&gt;isa_narrowklass() &amp;&amp; CompressedKlassPointers::shift() == 0) {
364     // 32-bit unscaled narrow oop can be the base of any address expression
365     t = t-&gt;make_ptr();
366   }
367   if (t-&gt;isa_intptr_t() &amp;&amp; offset != 0 &amp;&amp; offset != Type::OffsetBot) {
368     // We cannot assert that the offset does not look oop-ish here.
369     // Depending on the heap layout the cardmark base could land
370     // inside some oopish region.  It definitely does for Win2K.
371     // The sum of cardmark-base plus shift-by-9-oop lands outside
372     // the oop-ish area but we can&#39;t assert for that statically.
373     return TypeRawPtr::BOTTOM;
374   }
375 
376   const TypePtr *tp = t-&gt;isa_ptr();
377 
378   // be conservative if we do not recognize the type
379   if (tp == NULL) {
380     assert(false, &quot;this path may produce not optimal code&quot;);
381     return TypePtr::BOTTOM;
382   }
383   assert(tp-&gt;base() != Type::AnyPtr, &quot;not a bare pointer&quot;);
384 
385   if (tp-&gt;isa_aryptr()) {
386     // In the case of a flattened value type array, each field has its
387     // own slice so we need to extract the field being accessed from
388     // the address computation
389     if (offset == Type::OffsetBot) {
390       Node* base;
391       Node* index;
392       const MachOper* oper = memory_inputs(base, index);
393       if (oper != (MachOper*)-1) {
394         offset = oper-&gt;constant_disp();
395         return tp-&gt;is_aryptr()-&gt;add_field_offset_and_offset(offset)-&gt;add_offset(Type::OffsetBot);
396       }
397     }
398     return tp-&gt;is_aryptr()-&gt;add_field_offset_and_offset(offset);
399   }
400 
401   return tp-&gt;add_offset(offset);
402 }
403 
404 
405 //-----------------------------operand_index---------------------------------
406 int MachNode::operand_index(uint operand) const {
407   if (operand &lt; 1)  return -1;
408   assert(operand &lt; num_opnds(), &quot;oob&quot;);
409   if (_opnds[operand]-&gt;num_edges() == 0)  return -1;
410 
411   uint skipped   = oper_input_base(); // Sum of leaves skipped so far
412   for (uint opcnt = 1; opcnt &lt; operand; opcnt++) {
413     uint num_edges = _opnds[opcnt]-&gt;num_edges(); // leaves for operand
414     skipped += num_edges;
415   }
416   return skipped;
417 }
418 
419 int MachNode::operand_index(const MachOper *oper) const {
420   uint skipped = oper_input_base(); // Sum of leaves skipped so far
421   uint opcnt;
422   for (opcnt = 1; opcnt &lt; num_opnds(); opcnt++) {
423     if (_opnds[opcnt] == oper) break;
424     uint num_edges = _opnds[opcnt]-&gt;num_edges(); // leaves for operand
425     skipped += num_edges;
426   }
427   if (_opnds[opcnt] != oper) return -1;
428   return skipped;
429 }
430 
431 int MachNode::operand_index(Node* def) const {
432   uint skipped = oper_input_base(); // Sum of leaves skipped so far
433   for (uint opcnt = 1; opcnt &lt; num_opnds(); opcnt++) {
434     uint num_edges = _opnds[opcnt]-&gt;num_edges(); // leaves for operand
435     for (uint i = 0; i &lt; num_edges; i++) {
436       if (in(skipped + i) == def) {
437         return opcnt;
438       }
439     }
440     skipped += num_edges;
441   }
442   return -1;
443 }
444 
445 //------------------------------peephole---------------------------------------
446 // Apply peephole rule(s) to this instruction
447 MachNode *MachNode::peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &amp;deleted) {
448   return NULL;
449 }
450 
451 //------------------------------add_case_label---------------------------------
452 // Adds the label for the case
453 void MachNode::add_case_label( int index_num, Label* blockLabel) {
454   ShouldNotCallThis();
455 }
456 
457 //------------------------------method_set-------------------------------------
458 // Set the absolute address of a method
459 void MachNode::method_set( intptr_t addr ) {
460   ShouldNotCallThis();
461 }
462 
463 //------------------------------rematerialize----------------------------------
464 bool MachNode::rematerialize() const {
465   // Temps are always rematerializable
466   if (is_MachTemp()) return true;
467 
468   uint r = rule();              // Match rule
469   if (r &lt;  Matcher::_begin_rematerialize ||
470       r &gt;= Matcher::_end_rematerialize) {
471     return false;
472   }
473 
474   // For 2-address instructions, the input live range is also the output
475   // live range. Remateralizing does not make progress on the that live range.
476   if (two_adr()) return false;
477 
478   // Check for rematerializing float constants, or not
479   if (!Matcher::rematerialize_float_constants) {
480     int op = ideal_Opcode();
481     if (op == Op_ConF || op == Op_ConD) {
482       return false;
483     }
484   }
485 
486   // Defining flags - can&#39;t spill these! Must remateralize.
487   if (ideal_reg() == Op_RegFlags) {
488     return true;
489   }
490 
491   // Stretching lots of inputs - don&#39;t do it.
492   if (req() &gt; 2) {
493     return false;
494   }
495 
496   if (req() == 2 &amp;&amp; in(1) &amp;&amp; in(1)-&gt;ideal_reg() == Op_RegFlags) {
497     // In(1) will be rematerialized, too.
498     // Stretching lots of inputs - don&#39;t do it.
499     if (in(1)-&gt;req() &gt; 2) {
500       return false;
501     }
502   }
503 
504   // Don&#39;t remateralize somebody with bound inputs - it stretches a
505   // fixed register lifetime.
506   uint idx = oper_input_base();
507   if (req() &gt; idx) {
508     const RegMask &amp;rm = in_RegMask(idx);
509     if (rm.is_bound(ideal_reg())) {
510       return false;
511     }
512   }
513 
514   return true;
515 }
516 
517 #ifndef PRODUCT
518 //------------------------------dump_spec--------------------------------------
519 // Print any per-operand special info
520 void MachNode::dump_spec(outputStream *st) const {
521   uint cnt = num_opnds();
522   for( uint i=0; i&lt;cnt; i++ ) {
523     if (_opnds[i] != NULL) {
524       _opnds[i]-&gt;dump_spec(st);
525     } else {
526       st-&gt;print(&quot; _&quot;);
527     }
528   }
529   const TypePtr *t = adr_type();
530   if( t ) {
531     Compile* C = Compile::current();
532     if( C-&gt;alias_type(t)-&gt;is_volatile() )
533       st-&gt;print(&quot; Volatile!&quot;);
534   }
535 }
536 
537 //------------------------------dump_format------------------------------------
538 // access to virtual
539 void MachNode::dump_format(PhaseRegAlloc *ra, outputStream *st) const {
540   format(ra, st); // access to virtual
541 }
542 #endif
543 
544 //=============================================================================
545 #ifndef PRODUCT
546 void MachTypeNode::dump_spec(outputStream *st) const {
547   if (_bottom_type != NULL) {
548     _bottom_type-&gt;dump_on(st);
549   } else {
550     st-&gt;print(&quot; NULL&quot;);
551   }
552 }
553 #endif
554 
555 
556 //=============================================================================
557 int MachConstantNode::constant_offset() {
558   // Bind the offset lazily.
559   if (_constant.offset() == -1) {
560     Compile::ConstantTable&amp; constant_table = Compile::current()-&gt;constant_table();
561     int offset = constant_table.find_offset(_constant);
562     // If called from Compile::scratch_emit_size return the
563     // pre-calculated offset.
564     // NOTE: If the AD file does some table base offset optimizations
565     // later the AD file needs to take care of this fact.
566     if (Compile::current()-&gt;in_scratch_emit_size()) {
567       return constant_table.calculate_table_base_offset() + offset;
568     }
569     _constant.set_offset(constant_table.table_base_offset() + offset);
570   }
571   return _constant.offset();
572 }
573 
574 int MachConstantNode::constant_offset_unchecked() const {
575   return _constant.offset();
576 }
577 
578 //=============================================================================
579 #ifndef PRODUCT
580 void MachNullCheckNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
581   int reg = ra_-&gt;get_reg_first(in(1)-&gt;in(_vidx));
582   st-&gt;print(&quot;%s %s&quot;, Name(), Matcher::regName[reg]);
583 }
584 #endif
585 
586 void MachNullCheckNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
587   // only emits entries in the null-pointer exception handler table
588 }
589 void MachNullCheckNode::label_set(Label* label, uint block_num) {
590   // Nothing to emit
591 }
592 void MachNullCheckNode::save_label( Label** label, uint* block_num ) {
593   // Nothing to emit
594 }
595 
596 const RegMask &amp;MachNullCheckNode::in_RegMask( uint idx ) const {
597   if( idx == 0 ) return RegMask::Empty;
598   else return in(1)-&gt;as_Mach()-&gt;out_RegMask();
599 }
600 
601 //=============================================================================
602 const Type *MachProjNode::bottom_type() const {
603   if( _ideal_reg == fat_proj ) return Type::BOTTOM;
604   // Try the normal mechanism first
605   const Type *t = in(0)-&gt;bottom_type();
606   if( t-&gt;base() == Type::Tuple ) {
607     const TypeTuple *tt = t-&gt;is_tuple();
608     if (_con &lt; tt-&gt;cnt())
609       return tt-&gt;field_at(_con);
610   }
611   // Else use generic type from ideal register set
612   assert((uint)_ideal_reg &lt; (uint)_last_machine_leaf &amp;&amp; Type::mreg2type[_ideal_reg], &quot;in bounds&quot;);
613   return Type::mreg2type[_ideal_reg];
614 }
615 
616 const TypePtr *MachProjNode::adr_type() const {
617   if (bottom_type() == Type::MEMORY) {
618     // in(0) might be a narrow MemBar; otherwise we will report TypePtr::BOTTOM
619     Node* ctrl = in(0);
620     if (ctrl == NULL)  return NULL; // node is dead
621     const TypePtr* adr_type = ctrl-&gt;adr_type();
622     #ifdef ASSERT
623     if (!VMError::is_error_reported() &amp;&amp; !Node::in_dump())
624       assert(adr_type != NULL, &quot;source must have adr_type&quot;);
625     #endif
626     return adr_type;
627   }
628   assert(bottom_type()-&gt;base() != Type::Memory, &quot;no other memories?&quot;);
629   return NULL;
630 }
631 
632 #ifndef PRODUCT
633 void MachProjNode::dump_spec(outputStream *st) const {
634   ProjNode::dump_spec(st);
635   switch (_ideal_reg) {
636   case unmatched_proj:  st-&gt;print(&quot;/unmatched&quot;);                           break;
637   case fat_proj:        st-&gt;print(&quot;/fat&quot;); if (WizardMode) _rout.dump(st); break;
638   }
639 }
640 #endif
641 
642 //=============================================================================
643 #ifndef PRODUCT
644 void MachIfNode::dump_spec(outputStream *st) const {
645   st-&gt;print(&quot;P=%f, C=%f&quot;,_prob, _fcnt);
646 }
647 #endif
648 
649 //=============================================================================
650 uint MachReturnNode::size_of() const { return sizeof(*this); }
651 
652 //------------------------------Registers--------------------------------------
653 const RegMask &amp;MachReturnNode::in_RegMask( uint idx ) const {
654   return _in_rms[idx];
655 }
656 
657 const TypePtr *MachReturnNode::adr_type() const {
658   // most returns and calls are assumed to consume &amp; modify all of memory
659   // the matcher will copy non-wide adr_types from ideal originals
660   return _adr_type;
661 }
662 
663 //=============================================================================
664 const Type *MachSafePointNode::bottom_type() const {  return TypeTuple::MEMBAR; }
665 
666 //------------------------------Registers--------------------------------------
667 const RegMask &amp;MachSafePointNode::in_RegMask( uint idx ) const {
668   // Values in the domain use the users calling convention, embodied in the
669   // _in_rms array of RegMasks.
670   if( idx &lt; TypeFunc::Parms ) return _in_rms[idx];
671 
672   if (SafePointNode::needs_polling_address_input() &amp;&amp;
673       idx == TypeFunc::Parms &amp;&amp;
674       ideal_Opcode() == Op_SafePoint) {
675     return MachNode::in_RegMask(idx);
676   }
677 
678   // Values outside the domain represent debug info
679   assert(in(idx)-&gt;ideal_reg() != Op_RegFlags, &quot;flags register is not spillable&quot;);
680   return *Compile::current()-&gt;matcher()-&gt;idealreg2spillmask[in(idx)-&gt;ideal_reg()];
681 }
682 
683 
684 //=============================================================================
685 
686 bool MachCallNode::cmp( const Node &amp;n ) const
687 { return _tf == ((MachCallNode&amp;)n)._tf; }
688 const Type *MachCallNode::bottom_type() const { return tf()-&gt;range_cc(); }
689 const Type* MachCallNode::Value(PhaseGVN* phase) const { return tf()-&gt;range_cc(); }
690 
691 #ifndef PRODUCT
692 void MachCallNode::dump_spec(outputStream *st) const {
693   st-&gt;print(&quot;# &quot;);
694   if (tf() != NULL)  tf()-&gt;dump_on(st);
695   if (_cnt != COUNT_UNKNOWN)  st-&gt;print(&quot; C=%f&quot;,_cnt);
696   if (jvms() != NULL)  jvms()-&gt;dump_spec(st);
697 }
698 #endif
699 
700 bool MachCallNode::return_value_is_used() const {
701   if (tf()-&gt;range_sig()-&gt;cnt() == TypeFunc::Parms) {
702     // void return
703     return false;
704   }
705 
706   assert(tf()-&gt;returns_value_type_as_fields(), &quot;multiple return values not supported&quot;);
707 
708   // find the projection corresponding to the return value
709   for (DUIterator_Fast imax, i = fast_outs(imax); i &lt; imax; i++) {
710     Node *use = fast_out(i);
711     if (!use-&gt;is_Proj()) continue;
712     if (use-&gt;as_Proj()-&gt;_con == TypeFunc::Parms) {
713       return true;
714     }
715   }
716   return false;
717 }
718 
719 // Similar to cousin class CallNode::returns_pointer
720 // Because this is used in deoptimization, we want the type info, not the data
721 // flow info; the interpreter will &quot;use&quot; things that are dead to the optimizer.
722 bool MachCallNode::returns_pointer() const {
723   const TypeTuple *r = tf()-&gt;range_sig();
724   return (r-&gt;cnt() &gt; TypeFunc::Parms &amp;&amp;
725           r-&gt;field_at(TypeFunc::Parms)-&gt;isa_ptr());
726 }
727 
728 bool MachCallNode::returns_vt() const {
729   return tf()-&gt;returns_value_type_as_fields();
730 }
731 
732 //------------------------------Registers--------------------------------------
733 const RegMask &amp;MachCallNode::in_RegMask(uint idx) const {
734   // Values in the domain use the users calling convention, embodied in the
735   // _in_rms array of RegMasks.
736   if (entry_point() == NULL &amp;&amp; idx == TypeFunc::Parms) {
737     // Null entry point is a special cast where the target of the call
738     // is in a register.
739     return MachNode::in_RegMask(idx);
740   }
741   if (idx &lt; tf()-&gt;domain_sig()-&gt;cnt()) {
742     return _in_rms[idx];
743   }
744   if (idx == mach_constant_base_node_input()) {
745     return MachConstantBaseNode::static_out_RegMask();
746   }
747   // Values outside the domain represent debug info
748   return *Compile::current()-&gt;matcher()-&gt;idealreg2debugmask[in(idx)-&gt;ideal_reg()];
749 }
750 
751 //=============================================================================
752 uint MachCallJavaNode::size_of() const { return sizeof(*this); }
753 bool MachCallJavaNode::cmp( const Node &amp;n ) const {
754   MachCallJavaNode &amp;call = (MachCallJavaNode&amp;)n;
755   return MachCallNode::cmp(call) &amp;&amp; _method-&gt;equals(call._method) &amp;&amp;
756          _override_symbolic_info == call._override_symbolic_info;
757 }
758 #ifndef PRODUCT
759 void MachCallJavaNode::dump_spec(outputStream *st) const {
760   if (_method_handle_invoke)
761     st-&gt;print(&quot;MethodHandle &quot;);
762   if (_method) {
763     _method-&gt;print_short_name(st);
764     st-&gt;print(&quot; &quot;);
765   }
766   MachCallNode::dump_spec(st);
767 }
768 #endif
769 
770 //------------------------------Registers--------------------------------------
771 const RegMask &amp;MachCallJavaNode::in_RegMask(uint idx) const {
772   // Values in the domain use the users calling convention, embodied in the
773   // _in_rms array of RegMasks.
774   if (idx &lt; tf()-&gt;domain_cc()-&gt;cnt()) {
775     return _in_rms[idx];
776   }
777   if (idx == mach_constant_base_node_input()) {
778     return MachConstantBaseNode::static_out_RegMask();
779   }
780   // Values outside the domain represent debug info
781   Matcher* m = Compile::current()-&gt;matcher();
782   // If this call is a MethodHandle invoke we have to use a different
783   // debugmask which does not include the register we use to save the
784   // SP over MH invokes.
785   RegMask** debugmask = _method_handle_invoke ? m-&gt;idealreg2mhdebugmask : m-&gt;idealreg2debugmask;
786   return *debugmask[in(idx)-&gt;ideal_reg()];
787 }
788 
789 //=============================================================================
790 uint MachCallStaticJavaNode::size_of() const { return sizeof(*this); }
791 bool MachCallStaticJavaNode::cmp( const Node &amp;n ) const {
792   MachCallStaticJavaNode &amp;call = (MachCallStaticJavaNode&amp;)n;
793   return MachCallJavaNode::cmp(call) &amp;&amp; _name == call._name;
794 }
795 
796 //----------------------------uncommon_trap_request----------------------------
797 // If this is an uncommon trap, return the request code, else zero.
798 int MachCallStaticJavaNode::uncommon_trap_request() const {
799   if (_name != NULL &amp;&amp; !strcmp(_name, &quot;uncommon_trap&quot;)) {
800     return CallStaticJavaNode::extract_uncommon_trap_request(this);
801   }
802   return 0;
803 }
804 
805 #ifndef PRODUCT
806 // Helper for summarizing uncommon_trap arguments.
807 void MachCallStaticJavaNode::dump_trap_args(outputStream *st) const {
808   int trap_req = uncommon_trap_request();
809   if (trap_req != 0) {
810     char buf[100];
811     st-&gt;print(&quot;(%s)&quot;,
812                Deoptimization::format_trap_request(buf, sizeof(buf),
813                                                    trap_req));
814   }
815 }
816 
817 void MachCallStaticJavaNode::dump_spec(outputStream *st) const {
818   st-&gt;print(&quot;Static &quot;);
819   if (_name != NULL) {
820     st-&gt;print(&quot;wrapper for: %s&quot;, _name );
821     dump_trap_args(st);
822     st-&gt;print(&quot; &quot;);
823   }
824   MachCallJavaNode::dump_spec(st);
825 }
826 #endif
827 
828 //=============================================================================
829 #ifndef PRODUCT
830 void MachCallDynamicJavaNode::dump_spec(outputStream *st) const {
831   st-&gt;print(&quot;Dynamic &quot;);
832   MachCallJavaNode::dump_spec(st);
833 }
834 #endif
835 //=============================================================================
836 uint MachCallRuntimeNode::size_of() const { return sizeof(*this); }
837 bool MachCallRuntimeNode::cmp( const Node &amp;n ) const {
838   MachCallRuntimeNode &amp;call = (MachCallRuntimeNode&amp;)n;
839   return MachCallNode::cmp(call) &amp;&amp; !strcmp(_name,call._name);
840 }
841 #ifndef PRODUCT
842 void MachCallRuntimeNode::dump_spec(outputStream *st) const {
843   st-&gt;print(&quot;%s &quot;,_name);
844   MachCallNode::dump_spec(st);
845 }
846 #endif
847 //=============================================================================
848 // A shared JVMState for all HaltNodes.  Indicates the start of debug info
849 // is at TypeFunc::Parms.  Only required for SOE register spill handling -
850 // to indicate where the stack-slot-only debug info inputs begin.
851 // There is no other JVM state needed here.
852 JVMState jvms_for_throw(0);
853 JVMState *MachHaltNode::jvms() const {
854   return &amp;jvms_for_throw;
855 }
856 
857 uint MachMemBarNode::size_of() const { return sizeof(*this); }
858 
859 const TypePtr *MachMemBarNode::adr_type() const {
860   return _adr_type;
861 }
862 
863 
864 //=============================================================================
865 #ifndef PRODUCT
866 void labelOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
867   st-&gt;print(&quot;B%d&quot;, _block_num);
868 }
869 #endif // PRODUCT
870 
871 //=============================================================================
872 #ifndef PRODUCT
873 void methodOper::int_format(PhaseRegAlloc *ra, const MachNode *node, outputStream *st) const {
874   st-&gt;print(INTPTR_FORMAT, _method);
875 }
876 #endif // PRODUCT
    </pre>
  </body>
</html>
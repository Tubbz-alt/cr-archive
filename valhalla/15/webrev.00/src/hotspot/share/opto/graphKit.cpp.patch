diff a/src/hotspot/share/opto/graphKit.cpp b/src/hotspot/share/opto/graphKit.cpp
--- a/src/hotspot/share/opto/graphKit.cpp
+++ b/src/hotspot/share/opto/graphKit.cpp
@@ -2751,83 +2751,10 @@
   gvn.transform(iff);
   if (!bol->is_Con()) gvn.record_for_igvn(iff);
   return iff;
 }
 
-// Find the memory state for the secondary super type cache load when
-// a subtype check is expanded at macro expansion time. That field is
-// mutable so should not use immutable memory but
-// PartialSubtypeCheckNode that might modify it doesn't produce a new
-// memory state so bottom memory is the most accurate memory state to
-// hook the load with. This follows the implementation used when the
-// subtype check is expanded at parse time.
-static Node* find_bottom_mem(Node* ctrl, Compile* C) {
-  const TypePtr* adr_type = TypeKlassPtr::make(TypePtr::NotNull, C->env()->Object_klass(), Type::Offset::bottom, false);
-  Node_Stack stack(0);
-  VectorSet seen(Thread::current()->resource_area());
-
-  Node* c = ctrl;
-  Node* mem = NULL;
-  uint iter = 0;
-  do {
-    iter++;
-    assert(iter < C->live_nodes(), "infinite loop");
-    if (c->is_Region()) {
-      for (DUIterator_Fast imax, i = c->fast_outs(imax); i < imax && mem == NULL; i++) {
-        Node* u = c->fast_out(i);
-        if (u->is_Phi() && u->bottom_type() == Type::MEMORY &&
-            (u->adr_type() == TypePtr::BOTTOM || u->adr_type() == adr_type)) {
-          mem = u;
-        }
-      }
-      if (mem == NULL) {
-        if (!seen.test_set(c->_idx)) {
-          stack.push(c, 2);
-          c = c->in(1);
-        } else {
-          Node* phi = NULL;
-          uint idx = 0;
-          for (;;) {
-            phi = stack.node();
-            idx = stack.index();
-            if (idx < phi->req()) {
-              break;
-            }
-            stack.pop();
-          }
-          c = phi->in(idx);
-          stack.set_index(idx+1);
-        }
-      }
-    } else if (c->is_Proj() && c->in(0)->adr_type() == TypePtr::BOTTOM) {
-      for (DUIterator_Fast imax, i = c->in(0)->fast_outs(imax); i < imax; i++) {
-        Node* u = c->in(0)->fast_out(i);
-        if (u->bottom_type() == Type::MEMORY && u->as_Proj()->_is_io_use == c->as_Proj()->_is_io_use) {
-          assert(mem == NULL, "");
-          mem = u;
-        }
-      }
-    } else if (c->is_CatchProj() && c->in(0)->in(0)->in(0)->adr_type() == TypePtr::BOTTOM) {
-      Node* call = c->in(0)->in(0)->in(0);
-      assert(call->is_Call(), "CatchProj with no call?");
-      CallProjections* projs = call->as_Call()->extract_projections(false, false);
-      if (projs->catchall_memproj == NULL) {
-        mem = projs->fallthrough_memproj;
-      } else if (c == projs->fallthrough_catchproj) {
-        mem = projs->fallthrough_memproj;
-      } else {
-        assert(c == projs->catchall_catchproj, "strange control");
-        mem = projs->catchall_memproj;
-      }
-    } else {
-      assert(!c->is_Start(), "should stop before start");
-      c = c->in(0);
-    }
-  } while (mem == NULL);
-  return mem;
-}
-
 //-------------------------------gen_subtype_check-----------------------------
 // Generate a subtyping check.  Takes as input the subtype and supertype.
 // Returns 2 values: sets the default control() to the true path and returns
 // the false path.  Only reads invariant memory; sets no (visible) memory.
 // The PartialSubtypeCheckNode sets the hidden 1-word cache in the encoding
@@ -2906,16 +2833,16 @@
   Node *p2 = gvn.transform(new AddPNode(subklass,subklass,chk_off_X));
   // For some types like interfaces the following loadKlass is from a 1-word
   // cache which is mutable so can't use immutable memory.  Other
   // types load from the super-class display table which is immutable.
   Node *kmem = C->immutable_memory();
-  if (might_be_cache) {
-    assert((C->get_alias_index(TypeKlassPtr::make(TypePtr::NotNull, C->env()->Object_klass(), Type::Offset::bottom, false)) ==
-            C->get_alias_index(gvn.type(p2)->is_ptr())), "");
-    if (mem == NULL) {
-      mem = find_bottom_mem(*ctrl, C);
-    }
+  // secondary_super_cache is not immutable but can be treated as such because:
+  // - no ideal node writes to it in a way that could cause an
+  //   incorrect/missed optimization of the following Load.
+  // - it's a cache so, worse case, not reading the latest value
+  //   wouldn't cause incorrect execution
+  if (might_be_cache && mem != NULL) {
     kmem = mem->is_MergeMem() ? mem->as_MergeMem()->memory_at(C->get_alias_index(gvn.type(p2)->is_ptr())) : mem;
   }
   Node *nkls = gvn.transform(LoadKlassNode::make(gvn, NULL, kmem, p2, gvn.type(p2)->is_ptr(), TypeKlassPtr::OBJECT_OR_NULL));
 
   // Compile speed common case: ARE a subtype and we canNOT fail
@@ -4472,11 +4399,11 @@
 }
 
 //----------------------------- loop predicates ---------------------------
 
 //------------------------------add_predicate_impl----------------------------
-void GraphKit::add_predicate_impl(Deoptimization::DeoptReason reason, int nargs) {
+void GraphKit::add_empty_predicate_impl(Deoptimization::DeoptReason reason, int nargs) {
   // Too many traps seen?
   if (too_many_traps(reason)) {
 #ifdef ASSERT
     if (TraceLoopPredicate) {
       int tc = C->trap_count(reason);
@@ -4506,19 +4433,22 @@
   Node* iftrue = _gvn.transform(new IfTrueNode(iff));
   set_control(iftrue);
 }
 
 //------------------------------add_predicate---------------------------------
-void GraphKit::add_predicate(int nargs) {
+void GraphKit::add_empty_predicates(int nargs) {
+  // These loop predicates remain empty. All concrete loop predicates are inserted above the corresponding
+  // empty loop predicate later by 'PhaseIdealLoop::create_new_if_for_predicate'. All concrete loop predicates of
+  // a specific kind (normal, profile or limit check) share the same uncommon trap as the empty loop predicate.
   if (UseLoopPredicate) {
-    add_predicate_impl(Deoptimization::Reason_predicate, nargs);
+    add_empty_predicate_impl(Deoptimization::Reason_predicate, nargs);
   }
   if (UseProfiledLoopPredicate) {
-    add_predicate_impl(Deoptimization::Reason_profile_predicate, nargs);
+    add_empty_predicate_impl(Deoptimization::Reason_profile_predicate, nargs);
   }
   // loop's limit check predicate should be near the loop.
-  add_predicate_impl(Deoptimization::Reason_loop_limit_check, nargs);
+  add_empty_predicate_impl(Deoptimization::Reason_loop_limit_check, nargs);
 }
 
 void GraphKit::sync_kit(IdealKit& ideal) {
   set_all_memory(ideal.merged_memory());
   set_i_o(ideal.i_o());
@@ -4638,11 +4568,11 @@
    * int i_char = start;
    * for (int i_byte = 0; i_byte < count; i_byte++) {
    *   dst[i_char++] = (char)(src[i_byte] & 0xff);
    * }
    */
-  add_predicate();
+  add_empty_predicates();
   RegionNode* head = new RegionNode(3);
   head->init_req(1, control());
   gvn().set_type(head, Type::CONTROL);
   record_for_igvn(head);
 

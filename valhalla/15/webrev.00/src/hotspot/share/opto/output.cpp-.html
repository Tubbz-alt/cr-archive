<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/opto/output.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.inline.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;code/compiledIC.hpp&quot;
  29 #include &quot;code/debugInfo.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;compiler/compilerDirectives.hpp&quot;
  33 #include &quot;compiler/oopMap.hpp&quot;
  34 #include &quot;gc/shared/barrierSet.hpp&quot;
  35 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;opto/ad.hpp&quot;
  38 #include &quot;opto/callnode.hpp&quot;
  39 #include &quot;opto/cfgnode.hpp&quot;
  40 #include &quot;opto/locknode.hpp&quot;
  41 #include &quot;opto/machnode.hpp&quot;
  42 #include &quot;opto/optoreg.hpp&quot;
  43 #include &quot;opto/output.hpp&quot;
  44 #include &quot;opto/regalloc.hpp&quot;
  45 #include &quot;opto/runtime.hpp&quot;
  46 #include &quot;opto/subnode.hpp&quot;
  47 #include &quot;opto/type.hpp&quot;
  48 #include &quot;runtime/handles.inline.hpp&quot;
  49 #include &quot;utilities/macros.hpp&quot;
  50 #include &quot;utilities/powerOfTwo.hpp&quot;
  51 #include &quot;utilities/xmlstream.hpp&quot;
  52 #ifdef X86
  53 #include &quot;c2_intelJccErratum_x86.hpp&quot;
  54 #endif
  55 
  56 #ifndef PRODUCT
  57 #define DEBUG_ARG(x) , x
  58 #else
  59 #define DEBUG_ARG(x)
  60 #endif
  61 
  62 // Convert Nodes to instruction bits and pass off to the VM
  63 void Compile::Output() {
  64   // RootNode goes
  65   assert( _cfg-&gt;get_root_block()-&gt;number_of_nodes() == 0, &quot;&quot; );
  66 
  67   // The number of new nodes (mostly MachNop) is proportional to
  68   // the number of java calls and inner loops which are aligned.
  69   if ( C-&gt;check_node_count((NodeLimitFudgeFactor + C-&gt;java_calls()*3 +
  70                             C-&gt;inner_loops()*(OptoLoopAlignment-1)),
  71                            &quot;out of nodes before code generation&quot; ) ) {
  72     return;
  73   }
  74   // Make sure I can find the Start Node
  75   Block *entry = _cfg-&gt;get_block(1);
  76   Block *broot = _cfg-&gt;get_root_block();
  77 
  78   const StartNode *start = entry-&gt;head()-&gt;as_Start();
  79 
  80   // Replace StartNode with prolog
  81   Label verified_entry;
  82   MachPrologNode* prolog = new MachPrologNode(&amp;verified_entry);
  83   entry-&gt;map_node(prolog, 0);
  84   _cfg-&gt;map_node_to_block(prolog, entry);
  85   _cfg-&gt;unmap_node_from_block(start); // start is no longer in any block
  86 
  87   // Virtual methods need an unverified entry point
  88   if (is_osr_compilation()) {
  89     if (PoisonOSREntry) {
  90       // TODO: Should use a ShouldNotReachHereNode...
  91       _cfg-&gt;insert( broot, 0, new MachBreakpointNode() );
  92     }
  93   } else {
  94     if (_method) {
  95       if (_method-&gt;has_scalarized_args()) {
  96         // Add entry point to unpack all value type arguments
  97         _cfg-&gt;insert(broot, 0, new MachVEPNode(&amp;verified_entry, /* verified */ true, /* receiver_only */ false));
  98         if (!_method-&gt;is_static()) {
  99           // Add verified/unverified entry points to only unpack value type receiver at interface calls
 100           _cfg-&gt;insert(broot, 0, new MachVEPNode(&amp;verified_entry, /* verified */ false, /* receiver_only */ false));
 101           _cfg-&gt;insert(broot, 0, new MachVEPNode(&amp;verified_entry, /* verified */ true,  /* receiver_only */ true));
 102           _cfg-&gt;insert(broot, 0, new MachVEPNode(&amp;verified_entry, /* verified */ false, /* receiver_only */ true));
 103         }
 104       } else if (!_method-&gt;is_static()) {
 105         // Insert unvalidated entry point
 106         _cfg-&gt;insert(broot, 0, new MachUEPNode());
 107       }
 108     }
 109   }
 110 
 111   // Break before main entry point
 112   if ((_method &amp;&amp; C-&gt;directive()-&gt;BreakAtExecuteOption) ||
 113       (OptoBreakpoint &amp;&amp; is_method_compilation())       ||
 114       (OptoBreakpointOSR &amp;&amp; is_osr_compilation())       ||
 115       (OptoBreakpointC2R &amp;&amp; !_method)                   ) {
 116     // checking for _method means that OptoBreakpoint does not apply to
 117     // runtime stubs or frame converters
 118     _cfg-&gt;insert( entry, 1, new MachBreakpointNode() );
 119   }
 120 
 121   // Insert epilogs before every return
 122   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {
 123     Block* block = _cfg-&gt;get_block(i);
 124     if (!block-&gt;is_connector() &amp;&amp; block-&gt;non_connector_successor(0) == _cfg-&gt;get_root_block()) { // Found a program exit point?
 125       Node* m = block-&gt;end();
 126       if (m-&gt;is_Mach() &amp;&amp; m-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Halt) {
 127         MachEpilogNode* epilog = new MachEpilogNode(m-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Return);
 128         block-&gt;add_inst(epilog);
 129         _cfg-&gt;map_node_to_block(epilog, block);
 130       }
 131     }
 132   }
 133 
 134   // Keeper of sizing aspects
 135   BufferSizingData buf_sizes = BufferSizingData();
 136 
 137   // Initialize code buffer
 138   estimate_buffer_size(buf_sizes._const);
 139   if (failing()) return;
 140 
 141   // Pre-compute the length of blocks and replace
 142   // long branches with short if machine supports it.
 143   // Must be done before ScheduleAndBundle due to SPARC delay slots
 144   uint* blk_starts = NEW_RESOURCE_ARRAY(uint, _cfg-&gt;number_of_blocks() + 1);
 145   blk_starts[0] = 0;
 146   shorten_branches(blk_starts, buf_sizes);
 147 
 148   if (!is_osr_compilation() &amp;&amp; _method &amp;&amp; _method-&gt;has_scalarized_args()) {
 149     // Compute the offsets of the entry points required by the value type calling convention
 150     if (!_method-&gt;is_static()) {
 151       // We have entries at the beginning of the method, implemented by the first 4 nodes.
 152       // Entry                     (unverified) @ offset 0
 153       // Verified_Value_Entry_RO
 154       // Value_Entry               (unverified)
 155       // Verified_Value_Entry
 156       uint offset = 0;
 157       _code_offsets.set_value(CodeOffsets::Entry, offset);
 158 
 159       offset += ((MachVEPNode*)broot-&gt;get_node(0))-&gt;size(_regalloc);
 160       _code_offsets.set_value(CodeOffsets::Verified_Value_Entry_RO, offset);
 161 
 162       offset += ((MachVEPNode*)broot-&gt;get_node(1))-&gt;size(_regalloc);
 163       _code_offsets.set_value(CodeOffsets::Value_Entry, offset);
 164 
 165       offset += ((MachVEPNode*)broot-&gt;get_node(2))-&gt;size(_regalloc);
 166       _code_offsets.set_value(CodeOffsets::Verified_Value_Entry, offset);
 167     } else {
 168       _code_offsets.set_value(CodeOffsets::Entry, -1); // will be patched later
 169       _code_offsets.set_value(CodeOffsets::Verified_Value_Entry, 0);
 170     }
 171   }
 172 
 173   ScheduleAndBundle();
 174   if (failing()) {
 175     return;
 176   }
 177 
 178   // Late barrier analysis must be done after schedule and bundle
 179   // Otherwise liveness based spilling will fail
 180   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 181   bs-&gt;late_barrier_analysis();
 182 
 183 #ifdef X86
 184   if (VM_Version::has_intel_jcc_erratum()) {
 185     int extra_padding = IntelJccErratum::tag_affected_machnodes(this, _cfg, _regalloc);
 186     buf_sizes._code += extra_padding;
 187   }
 188 #endif
 189 
 190   // Complete sizing of codebuffer
 191   CodeBuffer* cb = init_buffer(buf_sizes);
 192   if (cb == NULL || failing()) {
 193     return;
 194   }
 195 
 196   BuildOopMaps();
 197 
 198   if (failing())  {
 199     return;
 200   }
 201 
 202   fill_buffer(cb, blk_starts);
 203 }
 204 
 205 bool Compile::need_stack_bang(int frame_size_in_bytes) const {
 206   // Determine if we need to generate a stack overflow check.
 207   // Do it if the method is not a stub function and
 208   // has java calls or has frame size &gt; vm_page_size/8.
 209   // The debug VM checks that deoptimization doesn&#39;t trigger an
 210   // unexpected stack overflow (compiled method stack banging should
 211   // guarantee it doesn&#39;t happen) so we always need the stack bang in
 212   // a debug VM.
 213   return (UseStackBanging &amp;&amp; stub_function() == NULL &amp;&amp;
 214           (has_java_calls() || frame_size_in_bytes &gt; os::vm_page_size()&gt;&gt;3
 215            DEBUG_ONLY(|| true)));
 216 }
 217 
 218 bool Compile::need_register_stack_bang() const {
 219   // Determine if we need to generate a register stack overflow check.
 220   // This is only used on architectures which have split register
 221   // and memory stacks (ie. IA64).
 222   // Bang if the method is not a stub function and has java calls
 223   return (stub_function() == NULL &amp;&amp; has_java_calls());
 224 }
 225 
 226 
 227 // Compute the size of first NumberOfLoopInstrToAlign instructions at the top
 228 // of a loop. When aligning a loop we need to provide enough instructions
 229 // in cpu&#39;s fetch buffer to feed decoders. The loop alignment could be
 230 // avoided if we have enough instructions in fetch buffer at the head of a loop.
 231 // By default, the size is set to 999999 by Block&#39;s constructor so that
 232 // a loop will be aligned if the size is not reset here.
 233 //
 234 // Note: Mach instructions could contain several HW instructions
 235 // so the size is estimated only.
 236 //
 237 void Compile::compute_loop_first_inst_sizes() {
 238   // The next condition is used to gate the loop alignment optimization.
 239   // Don&#39;t aligned a loop if there are enough instructions at the head of a loop
 240   // or alignment padding is larger then MaxLoopPad. By default, MaxLoopPad
 241   // is equal to OptoLoopAlignment-1 except on new Intel cpus, where it is
 242   // equal to 11 bytes which is the largest address NOP instruction.
 243   if (MaxLoopPad &lt; OptoLoopAlignment - 1) {
 244     uint last_block = _cfg-&gt;number_of_blocks() - 1;
 245     for (uint i = 1; i &lt;= last_block; i++) {
 246       Block* block = _cfg-&gt;get_block(i);
 247       // Check the first loop&#39;s block which requires an alignment.
 248       if (block-&gt;loop_alignment() &gt; (uint)relocInfo::addr_unit()) {
 249         uint sum_size = 0;
 250         uint inst_cnt = NumberOfLoopInstrToAlign;
 251         inst_cnt = block-&gt;compute_first_inst_size(sum_size, inst_cnt, _regalloc);
 252 
 253         // Check subsequent fallthrough blocks if the loop&#39;s first
 254         // block(s) does not have enough instructions.
 255         Block *nb = block;
 256         while(inst_cnt &gt; 0 &amp;&amp;
 257               i &lt; last_block &amp;&amp;
 258               !_cfg-&gt;get_block(i + 1)-&gt;has_loop_alignment() &amp;&amp;
 259               !nb-&gt;has_successor(block)) {
 260           i++;
 261           nb = _cfg-&gt;get_block(i);
 262           inst_cnt  = nb-&gt;compute_first_inst_size(sum_size, inst_cnt, _regalloc);
 263         } // while( inst_cnt &gt; 0 &amp;&amp; i &lt; last_block  )
 264 
 265         block-&gt;set_first_inst_size(sum_size);
 266       } // f( b-&gt;head()-&gt;is_Loop() )
 267     } // for( i &lt;= last_block )
 268   } // if( MaxLoopPad &lt; OptoLoopAlignment-1 )
 269 }
 270 
 271 // The architecture description provides short branch variants for some long
 272 // branch instructions. Replace eligible long branches with short branches.
 273 void Compile::shorten_branches(uint* blk_starts, BufferSizingData&amp; buf_sizes) {
 274   // Compute size of each block, method size, and relocation information size
 275   uint nblocks  = _cfg-&gt;number_of_blocks();
 276 
 277   uint*      jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
 278   uint*      jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
 279   int*       jmp_nidx   = NEW_RESOURCE_ARRAY(int ,nblocks);
 280 
 281   // Collect worst case block paddings
 282   int* block_worst_case_pad = NEW_RESOURCE_ARRAY(int, nblocks);
 283   memset(block_worst_case_pad, 0, nblocks * sizeof(int));
 284 
 285   DEBUG_ONLY( uint *jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks); )
 286   DEBUG_ONLY( uint *jmp_rule = NEW_RESOURCE_ARRAY(uint,nblocks); )
 287 
 288   bool has_short_branch_candidate = false;
 289 
 290   // Initialize the sizes to 0
 291   int code_size  = 0;          // Size in bytes of generated code
 292   int stub_size  = 0;          // Size in bytes of all stub entries
 293   // Size in bytes of all relocation entries, including those in local stubs.
 294   // Start with 2-bytes of reloc info for the unvalidated entry point
 295   int reloc_size = 1;          // Number of relocation entries
 296 
 297   // Make three passes.  The first computes pessimistic blk_starts,
 298   // relative jmp_offset and reloc_size information.  The second performs
 299   // short branch substitution using the pessimistic sizing.  The
 300   // third inserts nops where needed.
 301 
 302   // Step one, perform a pessimistic sizing pass.
 303   uint last_call_adr = max_juint;
 304   uint last_avoid_back_to_back_adr = max_juint;
 305   uint nop_size = (new MachNopNode())-&gt;size(_regalloc);
 306   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
 307     Block* block = _cfg-&gt;get_block(i);
 308 
 309     // During short branch replacement, we store the relative (to blk_starts)
 310     // offset of jump in jmp_offset, rather than the absolute offset of jump.
 311     // This is so that we do not need to recompute sizes of all nodes when
 312     // we compute correct blk_starts in our next sizing pass.
 313     jmp_offset[i] = 0;
 314     jmp_size[i]   = 0;
 315     jmp_nidx[i]   = -1;
 316     DEBUG_ONLY( jmp_target[i] = 0; )
 317     DEBUG_ONLY( jmp_rule[i]   = 0; )
 318 
 319     // Sum all instruction sizes to compute block size
 320     uint last_inst = block-&gt;number_of_nodes();
 321     uint blk_size = 0;
 322     for (uint j = 0; j &lt; last_inst; j++) {
 323       Node* nj = block-&gt;get_node(j);
 324       // Handle machine instruction nodes
 325       if (nj-&gt;is_Mach()) {
 326         MachNode *mach = nj-&gt;as_Mach();
 327         blk_size += (mach-&gt;alignment_required() - 1) * relocInfo::addr_unit(); // assume worst case padding
 328 #ifdef X86
 329         if (VM_Version::has_intel_jcc_erratum() &amp;&amp; IntelJccErratum::is_jcc_erratum_branch(block, mach, j)) {
 330           // Conservatively add worst case padding
 331           blk_size += IntelJccErratum::largest_jcc_size();
 332         }
 333 #endif
 334 
 335         reloc_size += mach-&gt;reloc();
 336         if (mach-&gt;is_MachCall()) {
 337           // add size information for trampoline stub
 338           // class CallStubImpl is platform-specific and defined in the *.ad files.
 339           stub_size  += CallStubImpl::size_call_trampoline();
 340           reloc_size += CallStubImpl::reloc_call_trampoline();
 341 
 342           MachCallNode *mcall = mach-&gt;as_MachCall();
 343           // This destination address is NOT PC-relative
 344 
 345           if (mcall-&gt;entry_point() != NULL) {
 346             mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
 347           }
 348 
 349           if (mcall-&gt;is_MachCallJava() &amp;&amp; mcall-&gt;as_MachCallJava()-&gt;_method) {
 350             stub_size  += CompiledStaticCall::to_interp_stub_size();
 351             reloc_size += CompiledStaticCall::reloc_to_interp_stub();
 352 #if INCLUDE_AOT
 353             stub_size  += CompiledStaticCall::to_aot_stub_size();
 354             reloc_size += CompiledStaticCall::reloc_to_aot_stub();
 355 #endif
 356           }
 357         } else if (mach-&gt;is_MachSafePoint()) {
 358           // If call/safepoint are adjacent, account for possible
 359           // nop to disambiguate the two safepoints.
 360           // ScheduleAndBundle() can rearrange nodes in a block,
 361           // check for all offsets inside this block.
 362           if (last_call_adr &gt;= blk_starts[i]) {
 363             blk_size += nop_size;
 364           }
 365         }
 366         if (mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 367           // Nop is inserted between &quot;avoid back to back&quot; instructions.
 368           // ScheduleAndBundle() can rearrange nodes in a block,
 369           // check for all offsets inside this block.
 370           if (last_avoid_back_to_back_adr &gt;= blk_starts[i]) {
 371             blk_size += nop_size;
 372           }
 373         }
 374         if (mach-&gt;may_be_short_branch()) {
 375           if (!nj-&gt;is_MachBranch()) {
 376 #ifndef PRODUCT
 377             nj-&gt;dump(3);
 378 #endif
 379             Unimplemented();
 380           }
 381           assert(jmp_nidx[i] == -1, &quot;block should have only one branch&quot;);
 382           jmp_offset[i] = blk_size;
 383           jmp_size[i]   = nj-&gt;size(_regalloc);
 384           jmp_nidx[i]   = j;
 385           has_short_branch_candidate = true;
 386         }
 387       }
 388       blk_size += nj-&gt;size(_regalloc);
 389       // Remember end of call offset
 390       if (nj-&gt;is_MachCall() &amp;&amp; !nj-&gt;is_MachCallLeaf()) {
 391         last_call_adr = blk_starts[i]+blk_size;
 392       }
 393       // Remember end of avoid_back_to_back offset
 394       if (nj-&gt;is_Mach() &amp;&amp; nj-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
 395         last_avoid_back_to_back_adr = blk_starts[i]+blk_size;
 396       }
 397     }
 398 
 399     // When the next block starts a loop, we may insert pad NOP
 400     // instructions.  Since we cannot know our future alignment,
 401     // assume the worst.
 402     if (i &lt; nblocks - 1) {
 403       Block* nb = _cfg-&gt;get_block(i + 1);
 404       int max_loop_pad = nb-&gt;code_alignment()-relocInfo::addr_unit();
 405       if (max_loop_pad &gt; 0) {
 406         assert(is_power_of_2(max_loop_pad+relocInfo::addr_unit()), &quot;&quot;);
 407         // Adjust last_call_adr and/or last_avoid_back_to_back_adr.
 408         // If either is the last instruction in this block, bump by
 409         // max_loop_pad in lock-step with blk_size, so sizing
 410         // calculations in subsequent blocks still can conservatively
 411         // detect that it may the last instruction in this block.
 412         if (last_call_adr == blk_starts[i]+blk_size) {
 413           last_call_adr += max_loop_pad;
 414         }
 415         if (last_avoid_back_to_back_adr == blk_starts[i]+blk_size) {
 416           last_avoid_back_to_back_adr += max_loop_pad;
 417         }
 418         blk_size += max_loop_pad;
 419         block_worst_case_pad[i + 1] = max_loop_pad;
 420       }
 421     }
 422 
 423     // Save block size; update total method size
 424     blk_starts[i+1] = blk_starts[i]+blk_size;
 425   }
 426 
 427   // Step two, replace eligible long jumps.
 428   bool progress = true;
 429   uint last_may_be_short_branch_adr = max_juint;
 430   while (has_short_branch_candidate &amp;&amp; progress) {
 431     progress = false;
 432     has_short_branch_candidate = false;
 433     int adjust_block_start = 0;
 434     for (uint i = 0; i &lt; nblocks; i++) {
 435       Block* block = _cfg-&gt;get_block(i);
 436       int idx = jmp_nidx[i];
 437       MachNode* mach = (idx == -1) ? NULL: block-&gt;get_node(idx)-&gt;as_Mach();
 438       if (mach != NULL &amp;&amp; mach-&gt;may_be_short_branch()) {
 439 #ifdef ASSERT
 440         assert(jmp_size[i] &gt; 0 &amp;&amp; mach-&gt;is_MachBranch(), &quot;sanity&quot;);
 441         int j;
 442         // Find the branch; ignore trailing NOPs.
 443         for (j = block-&gt;number_of_nodes()-1; j&gt;=0; j--) {
 444           Node* n = block-&gt;get_node(j);
 445           if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con)
 446             break;
 447         }
 448         assert(j &gt;= 0 &amp;&amp; j == idx &amp;&amp; block-&gt;get_node(j) == (Node*)mach, &quot;sanity&quot;);
 449 #endif
 450         int br_size = jmp_size[i];
 451         int br_offs = blk_starts[i] + jmp_offset[i];
 452 
 453         // This requires the TRUE branch target be in succs[0]
 454         uint bnum = block-&gt;non_connector_successor(0)-&gt;_pre_order;
 455         int offset = blk_starts[bnum] - br_offs;
 456         if (bnum &gt; i) { // adjust following block&#39;s offset
 457           offset -= adjust_block_start;
 458         }
 459 
 460         // This block can be a loop header, account for the padding
 461         // in the previous block.
 462         int block_padding = block_worst_case_pad[i];
 463         assert(i == 0 || block_padding == 0 || br_offs &gt;= block_padding, &quot;Should have at least a padding on top&quot;);
 464         // In the following code a nop could be inserted before
 465         // the branch which will increase the backward distance.
 466         bool needs_padding = ((uint)(br_offs - block_padding) == last_may_be_short_branch_adr);
 467         assert(!needs_padding || jmp_offset[i] == 0, &quot;padding only branches at the beginning of block&quot;);
 468 
 469         if (needs_padding &amp;&amp; offset &lt;= 0)
 470           offset -= nop_size;
 471 
 472         if (_matcher-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {
 473           // We&#39;ve got a winner.  Replace this branch.
 474           MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
 475 
 476           // Update the jmp_size.
 477           int new_size = replacement-&gt;size(_regalloc);
 478           int diff     = br_size - new_size;
 479           assert(diff &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
 480           // Conservatively take into account padding between
 481           // avoid_back_to_back branches. Previous branch could be
 482           // converted into avoid_back_to_back branch during next
 483           // rounds.
 484           if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 485             jmp_offset[i] += nop_size;
 486             diff -= nop_size;
 487           }
 488           adjust_block_start += diff;
 489           block-&gt;map_node(replacement, idx);
 490           mach-&gt;subsume_by(replacement, C);
 491           mach = replacement;
 492           progress = true;
 493 
 494           jmp_size[i] = new_size;
 495           DEBUG_ONLY( jmp_target[i] = bnum; );
 496           DEBUG_ONLY( jmp_rule[i] = mach-&gt;rule(); );
 497         } else {
 498           // The jump distance is not short, try again during next iteration.
 499           has_short_branch_candidate = true;
 500         }
 501       } // (mach-&gt;may_be_short_branch())
 502       if (mach != NULL &amp;&amp; (mach-&gt;may_be_short_branch() ||
 503                            mach-&gt;avoid_back_to_back(MachNode::AVOID_AFTER))) {
 504         last_may_be_short_branch_adr = blk_starts[i] + jmp_offset[i] + jmp_size[i];
 505       }
 506       blk_starts[i+1] -= adjust_block_start;
 507     }
 508   }
 509 
 510 #ifdef ASSERT
 511   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
 512     if (jmp_target[i] != 0) {
 513       int br_size = jmp_size[i];
 514       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
 515       if (!_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {
 516         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
 517       }
 518       assert(_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset), &quot;Displacement too large for short jmp&quot;);
 519     }
 520   }
 521 #endif
 522 
 523   // Step 3, compute the offsets of all blocks, will be done in fill_buffer()
 524   // after ScheduleAndBundle().
 525 
 526   // ------------------
 527   // Compute size for code buffer
 528   code_size = blk_starts[nblocks];
 529 
 530   // Relocation records
 531   reloc_size += 1;              // Relo entry for exception handler
 532 
 533   // Adjust reloc_size to number of record of relocation info
 534   // Min is 2 bytes, max is probably 6 or 8, with a tax up to 25% for
 535   // a relocation index.
 536   // The CodeBuffer will expand the locs array if this estimate is too low.
 537   reloc_size *= 10 / sizeof(relocInfo);
 538 
 539   buf_sizes._reloc = reloc_size;
 540   buf_sizes._code  = code_size;
 541   buf_sizes._stub  = stub_size;
 542 }
 543 
 544 //------------------------------FillLocArray-----------------------------------
 545 // Create a bit of debug info and append it to the array.  The mapping is from
 546 // Java local or expression stack to constant, register or stack-slot.  For
 547 // doubles, insert 2 mappings and return 1 (to tell the caller that the next
 548 // entry has been taken care of and caller should skip it).
 549 static LocationValue *new_loc_value( PhaseRegAlloc *ra, OptoReg::Name regnum, Location::Type l_type ) {
 550   // This should never have accepted Bad before
 551   assert(OptoReg::is_valid(regnum), &quot;location must be valid&quot;);
 552   return (OptoReg::is_reg(regnum))
 553          ? new LocationValue(Location::new_reg_loc(l_type, OptoReg::as_VMReg(regnum)) )
 554          : new LocationValue(Location::new_stk_loc(l_type,  ra-&gt;reg2offset(regnum)));
 555 }
 556 
 557 
 558 ObjectValue*
 559 Compile::sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id) {
 560   for (int i = 0; i &lt; objs-&gt;length(); i++) {
 561     assert(objs-&gt;at(i)-&gt;is_object(), &quot;corrupt object cache&quot;);
 562     ObjectValue* sv = (ObjectValue*) objs-&gt;at(i);
 563     if (sv-&gt;id() == id) {
 564       return sv;
 565     }
 566   }
 567   // Otherwise..
 568   return NULL;
 569 }
 570 
 571 void Compile::set_sv_for_object_node(GrowableArray&lt;ScopeValue*&gt; *objs,
 572                                      ObjectValue* sv ) {
 573   assert(sv_for_node_id(objs, sv-&gt;id()) == NULL, &quot;Precondition&quot;);
 574   objs-&gt;append(sv);
 575 }
 576 
 577 
 578 void Compile::FillLocArray( int idx, MachSafePointNode* sfpt, Node *local,
 579                             GrowableArray&lt;ScopeValue*&gt; *array,
 580                             GrowableArray&lt;ScopeValue*&gt; *objs ) {
 581   assert( local, &quot;use _top instead of null&quot; );
 582   if (array-&gt;length() != idx) {
 583     assert(array-&gt;length() == idx + 1, &quot;Unexpected array count&quot;);
 584     // Old functionality:
 585     //   return
 586     // New functionality:
 587     //   Assert if the local is not top. In product mode let the new node
 588     //   override the old entry.
 589     assert(local == top(), &quot;LocArray collision&quot;);
 590     if (local == top()) {
 591       return;
 592     }
 593     array-&gt;pop();
 594   }
 595   const Type *t = local-&gt;bottom_type();
 596 
 597   // Is it a safepoint scalar object node?
 598   if (local-&gt;is_SafePointScalarObject()) {
 599     SafePointScalarObjectNode* spobj = local-&gt;as_SafePointScalarObject();
 600 
 601     ObjectValue* sv = Compile::sv_for_node_id(objs, spobj-&gt;_idx);
 602     if (sv == NULL) {
 603       ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
 604       assert(cik-&gt;is_instance_klass() ||
 605              cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 606       sv = new ObjectValue(spobj-&gt;_idx,
 607                            new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
 608       Compile::set_sv_for_object_node(objs, sv);
 609 
 610       uint first_ind = spobj-&gt;first_index(sfpt-&gt;jvms());
 611       for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
 612         Node* fld_node = sfpt-&gt;in(first_ind+i);
 613         (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfpt, fld_node, sv-&gt;field_values(), objs);
 614       }
 615     }
 616     array-&gt;append(sv);
 617     return;
 618   }
 619 
 620   // Grab the register number for the local
 621   OptoReg::Name regnum = _regalloc-&gt;get_reg_first(local);
 622   if( OptoReg::is_valid(regnum) ) {// Got a register/stack?
 623     // Record the double as two float registers.
 624     // The register mask for such a value always specifies two adjacent
 625     // float registers, with the lower register number even.
 626     // Normally, the allocation of high and low words to these registers
 627     // is irrelevant, because nearly all operations on register pairs
 628     // (e.g., StoreD) treat them as a single unit.
 629     // Here, we assume in addition that the words in these two registers
 630     // stored &quot;naturally&quot; (by operations like StoreD and double stores
 631     // within the interpreter) such that the lower-numbered register
 632     // is written to the lower memory address.  This may seem like
 633     // a machine dependency, but it is not--it is a requirement on
 634     // the author of the &lt;arch&gt;.ad file to ensure that, for every
 635     // even/odd double-register pair to which a double may be allocated,
 636     // the word in the even single-register is stored to the first
 637     // memory word.  (Note that register numbers are completely
 638     // arbitrary, and are not tied to any machine-level encodings.)
 639 #ifdef _LP64
 640     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon ) {
 641       array-&gt;append(new ConstantIntValue((jint)0));
 642       array-&gt;append(new_loc_value( _regalloc, regnum, Location::dbl ));
 643     } else if ( t-&gt;base() == Type::Long ) {
 644       array-&gt;append(new ConstantIntValue((jint)0));
 645       array-&gt;append(new_loc_value( _regalloc, regnum, Location::lng ));
 646     } else if ( t-&gt;base() == Type::RawPtr ) {
 647       // jsr/ret return address which must be restored into a the full
 648       // width 64-bit stack slot.
 649       array-&gt;append(new_loc_value( _regalloc, regnum, Location::lng ));
 650     }
 651 #else //_LP64
 652 #ifdef SPARC
 653     if (t-&gt;base() == Type::Long &amp;&amp; OptoReg::is_reg(regnum)) {
 654       // For SPARC we have to swap high and low words for
 655       // long values stored in a single-register (g0-g7).
 656       array-&gt;append(new_loc_value( _regalloc,              regnum   , Location::normal ));
 657       array-&gt;append(new_loc_value( _regalloc, OptoReg::add(regnum,1), Location::normal ));
 658     } else
 659 #endif //SPARC
 660     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon || t-&gt;base() == Type::Long ) {
 661       // Repack the double/long as two jints.
 662       // The convention the interpreter uses is that the second local
 663       // holds the first raw word of the native double representation.
 664       // This is actually reasonable, since locals and stack arrays
 665       // grow downwards in all implementations.
 666       // (If, on some machine, the interpreter&#39;s Java locals or stack
 667       // were to grow upwards, the embedded doubles would be word-swapped.)
 668       array-&gt;append(new_loc_value( _regalloc, OptoReg::add(regnum,1), Location::normal ));
 669       array-&gt;append(new_loc_value( _regalloc,              regnum   , Location::normal ));
 670     }
 671 #endif //_LP64
 672     else if( (t-&gt;base() == Type::FloatBot || t-&gt;base() == Type::FloatCon) &amp;&amp;
 673              OptoReg::is_reg(regnum) ) {
 674       array-&gt;append(new_loc_value( _regalloc, regnum, Matcher::float_in_double()
 675                                                       ? Location::float_in_dbl : Location::normal ));
 676     } else if( t-&gt;base() == Type::Int &amp;&amp; OptoReg::is_reg(regnum) ) {
 677       array-&gt;append(new_loc_value( _regalloc, regnum, Matcher::int_in_long
 678                                                       ? Location::int_in_long : Location::normal ));
 679     } else if( t-&gt;base() == Type::NarrowOop ) {
 680       array-&gt;append(new_loc_value( _regalloc, regnum, Location::narrowoop ));
 681     } else {
 682       array-&gt;append(new_loc_value( _regalloc, regnum, _regalloc-&gt;is_oop(local) ? Location::oop : Location::normal ));
 683     }
 684     return;
 685   }
 686 
 687   // No register.  It must be constant data.
 688   switch (t-&gt;base()) {
 689     case Type::Half:              // Second half of a double
 690       ShouldNotReachHere();       // Caller should skip 2nd halves
 691       break;
 692     case Type::AnyPtr:
 693       array-&gt;append(new ConstantOopWriteValue(NULL));
 694       break;
 695     case Type::AryPtr:
 696     case Type::InstPtr:          // fall through
 697       array-&gt;append(new ConstantOopWriteValue(t-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));
 698       break;
 699     case Type::NarrowOop:
 700       if (t == TypeNarrowOop::NULL_PTR) {
 701         array-&gt;append(new ConstantOopWriteValue(NULL));
 702       } else {
 703         array-&gt;append(new ConstantOopWriteValue(t-&gt;make_ptr()-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));
 704       }
 705       break;
 706     case Type::Int:
 707       array-&gt;append(new ConstantIntValue(t-&gt;is_int()-&gt;get_con()));
 708       break;
 709     case Type::RawPtr:
 710       // A return address (T_ADDRESS).
 711       assert((intptr_t)t-&gt;is_ptr()-&gt;get_con() &lt; (intptr_t)0x10000, &quot;must be a valid BCI&quot;);
 712 #ifdef _LP64
 713       // Must be restored to the full-width 64-bit stack slot.
 714       array-&gt;append(new ConstantLongValue(t-&gt;is_ptr()-&gt;get_con()));
 715 #else
 716       array-&gt;append(new ConstantIntValue(t-&gt;is_ptr()-&gt;get_con()));
 717 #endif
 718       break;
 719     case Type::FloatCon: {
 720       float f = t-&gt;is_float_constant()-&gt;getf();
 721       array-&gt;append(new ConstantIntValue(jint_cast(f)));
 722       break;
 723     }
 724     case Type::DoubleCon: {
 725       jdouble d = t-&gt;is_double_constant()-&gt;getd();
 726 #ifdef _LP64
 727       array-&gt;append(new ConstantIntValue((jint)0));
 728       array-&gt;append(new ConstantDoubleValue(d));
 729 #else
 730       // Repack the double as two jints.
 731     // The convention the interpreter uses is that the second local
 732     // holds the first raw word of the native double representation.
 733     // This is actually reasonable, since locals and stack arrays
 734     // grow downwards in all implementations.
 735     // (If, on some machine, the interpreter&#39;s Java locals or stack
 736     // were to grow upwards, the embedded doubles would be word-swapped.)
 737     jlong_accessor acc;
 738     acc.long_value = jlong_cast(d);
 739     array-&gt;append(new ConstantIntValue(acc.words[1]));
 740     array-&gt;append(new ConstantIntValue(acc.words[0]));
 741 #endif
 742       break;
 743     }
 744     case Type::Long: {
 745       jlong d = t-&gt;is_long()-&gt;get_con();
 746 #ifdef _LP64
 747       array-&gt;append(new ConstantIntValue((jint)0));
 748       array-&gt;append(new ConstantLongValue(d));
 749 #else
 750       // Repack the long as two jints.
 751     // The convention the interpreter uses is that the second local
 752     // holds the first raw word of the native double representation.
 753     // This is actually reasonable, since locals and stack arrays
 754     // grow downwards in all implementations.
 755     // (If, on some machine, the interpreter&#39;s Java locals or stack
 756     // were to grow upwards, the embedded doubles would be word-swapped.)
 757     jlong_accessor acc;
 758     acc.long_value = d;
 759     array-&gt;append(new ConstantIntValue(acc.words[1]));
 760     array-&gt;append(new ConstantIntValue(acc.words[0]));
 761 #endif
 762       break;
 763     }
 764     case Type::Top:               // Add an illegal value here
 765       array-&gt;append(new LocationValue(Location()));
 766       break;
 767     default:
 768       ShouldNotReachHere();
 769       break;
 770   }
 771 }
 772 
 773 // Determine if this node starts a bundle
 774 bool Compile::starts_bundle(const Node *n) const {
 775   return (_node_bundling_limit &gt; n-&gt;_idx &amp;&amp;
 776           _node_bundling_base[n-&gt;_idx].starts_bundle());
 777 }
 778 
 779 //--------------------------Process_OopMap_Node--------------------------------
 780 void Compile::Process_OopMap_Node(MachNode *mach, int current_offset) {
 781 
 782   // Handle special safepoint nodes for synchronization
 783   MachSafePointNode *sfn   = mach-&gt;as_MachSafePoint();
 784   MachCallNode      *mcall;
 785 
 786   int safepoint_pc_offset = current_offset;
 787   bool is_method_handle_invoke = false;
 788   bool return_oop = false;
 789   bool return_vt = false;
 790 
 791   // Add the safepoint in the DebugInfoRecorder
 792   if( !mach-&gt;is_MachCall() ) {
 793     mcall = NULL;
 794     debug_info()-&gt;add_safepoint(safepoint_pc_offset, sfn-&gt;_oop_map);
 795   } else {
 796     mcall = mach-&gt;as_MachCall();
 797 
 798     // Is the call a MethodHandle call?
 799     if (mcall-&gt;is_MachCallJava()) {
 800       if (mcall-&gt;as_MachCallJava()-&gt;_method_handle_invoke) {
 801         assert(has_method_handle_invokes(), &quot;must have been set during call generation&quot;);
 802         is_method_handle_invoke = true;
 803       }
 804     }
 805 
 806     // Check if a call returns an object.
 807     if (mcall-&gt;returns_pointer() || mcall-&gt;returns_vt()) {
 808       return_oop = true;
 809     }
 810     if (mcall-&gt;returns_vt()) {
 811       return_vt = true;
 812     }
 813     safepoint_pc_offset += mcall-&gt;ret_addr_offset();
 814     debug_info()-&gt;add_safepoint(safepoint_pc_offset, mcall-&gt;_oop_map);
 815   }
 816 
 817   // Loop over the JVMState list to add scope information
 818   // Do not skip safepoints with a NULL method, they need monitor info
 819   JVMState* youngest_jvms = sfn-&gt;jvms();
 820   int max_depth = youngest_jvms-&gt;depth();
 821 
 822   // Allocate the object pool for scalar-replaced objects -- the map from
 823   // small-integer keys (which can be recorded in the local and ostack
 824   // arrays) to descriptions of the object state.
 825   GrowableArray&lt;ScopeValue*&gt; *objs = new GrowableArray&lt;ScopeValue*&gt;();
 826 
 827   // Visit scopes from oldest to youngest.
 828   for (int depth = 1; depth &lt;= max_depth; depth++) {
 829     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
 830     int idx;
 831     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
 832     // Safepoints that do not have method() set only provide oop-map and monitor info
 833     // to support GC; these do not support deoptimization.
 834     int num_locs = (method == NULL) ? 0 : jvms-&gt;loc_size();
 835     int num_exps = (method == NULL) ? 0 : jvms-&gt;stk_size();
 836     int num_mon  = jvms-&gt;nof_monitors();
 837     assert(method == NULL || jvms-&gt;bci() &lt; 0 || num_locs == method-&gt;max_locals(),
 838            &quot;JVMS local count must match that of the method&quot;);
 839 
 840     // Add Local and Expression Stack Information
 841 
 842     // Insert locals into the locarray
 843     GrowableArray&lt;ScopeValue*&gt; *locarray = new GrowableArray&lt;ScopeValue*&gt;(num_locs);
 844     for( idx = 0; idx &lt; num_locs; idx++ ) {
 845       FillLocArray( idx, sfn, sfn-&gt;local(jvms, idx), locarray, objs );
 846     }
 847 
 848     // Insert expression stack entries into the exparray
 849     GrowableArray&lt;ScopeValue*&gt; *exparray = new GrowableArray&lt;ScopeValue*&gt;(num_exps);
 850     for( idx = 0; idx &lt; num_exps; idx++ ) {
 851       FillLocArray( idx,  sfn, sfn-&gt;stack(jvms, idx), exparray, objs );
 852     }
 853 
 854     // Add in mappings of the monitors
 855     assert( !method ||
 856             !method-&gt;is_synchronized() ||
 857             method-&gt;is_native() ||
 858             num_mon &gt; 0 ||
 859             !GenerateSynchronizationCode,
 860             &quot;monitors must always exist for synchronized methods&quot;);
 861 
 862     // Build the growable array of ScopeValues for exp stack
 863     GrowableArray&lt;MonitorValue*&gt; *monarray = new GrowableArray&lt;MonitorValue*&gt;(num_mon);
 864 
 865     // Loop over monitors and insert into array
 866     for (idx = 0; idx &lt; num_mon; idx++) {
 867       // Grab the node that defines this monitor
 868       Node* box_node = sfn-&gt;monitor_box(jvms, idx);
 869       Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
 870 
 871       // Create ScopeValue for object
 872       ScopeValue *scval = NULL;
 873 
 874       if (obj_node-&gt;is_SafePointScalarObject()) {
 875         SafePointScalarObjectNode* spobj = obj_node-&gt;as_SafePointScalarObject();
 876         scval = Compile::sv_for_node_id(objs, spobj-&gt;_idx);
 877         if (scval == NULL) {
 878           const Type *t = spobj-&gt;bottom_type();
 879           ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
 880           assert(cik-&gt;is_instance_klass() ||
 881                  cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 882           ObjectValue* sv = new ObjectValue(spobj-&gt;_idx,
 883                                             new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
 884           Compile::set_sv_for_object_node(objs, sv);
 885 
 886           uint first_ind = spobj-&gt;first_index(youngest_jvms);
 887           for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
 888             Node* fld_node = sfn-&gt;in(first_ind+i);
 889             (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfn, fld_node, sv-&gt;field_values(), objs);
 890           }
 891           scval = sv;
 892         }
 893       } else if (!obj_node-&gt;is_Con()) {
 894         OptoReg::Name obj_reg = _regalloc-&gt;get_reg_first(obj_node);
 895         if( obj_node-&gt;bottom_type()-&gt;base() == Type::NarrowOop ) {
 896           scval = new_loc_value( _regalloc, obj_reg, Location::narrowoop );
 897         } else {
 898           scval = new_loc_value( _regalloc, obj_reg, Location::oop );
 899         }
 900       } else {
 901         const TypePtr *tp = obj_node-&gt;get_ptr_type();
 902         scval = new ConstantOopWriteValue(tp-&gt;is_oopptr()-&gt;const_oop()-&gt;constant_encoding());
 903       }
 904 
 905       OptoReg::Name box_reg = BoxLockNode::reg(box_node);
 906       Location basic_lock = Location::new_stk_loc(Location::normal,_regalloc-&gt;reg2offset(box_reg));
 907       bool eliminated = (box_node-&gt;is_BoxLock() &amp;&amp; box_node-&gt;as_BoxLock()-&gt;is_eliminated());
 908       monarray-&gt;append(new MonitorValue(scval, basic_lock, eliminated));
 909     }
 910 
 911     // We dump the object pool first, since deoptimization reads it in first.
 912     debug_info()-&gt;dump_object_pool(objs);
 913 
 914     // Build first class objects to pass to scope
 915     DebugToken *locvals = debug_info()-&gt;create_scope_values(locarray);
 916     DebugToken *expvals = debug_info()-&gt;create_scope_values(exparray);
 917     DebugToken *monvals = debug_info()-&gt;create_monitor_values(monarray);
 918 
 919     // Make method available for all Safepoints
 920     ciMethod* scope_method = method ? method : _method;
 921     // Describe the scope here
 922     assert(jvms-&gt;bci() &gt;= InvocationEntryBci &amp;&amp; jvms-&gt;bci() &lt;= 0x10000, &quot;must be a valid or entry BCI&quot;);
 923     assert(!jvms-&gt;should_reexecute() || depth == max_depth, &quot;reexecute allowed only for the youngest&quot;);
 924     // Now we can describe the scope.
 925     methodHandle null_mh;
 926     bool rethrow_exception = false;
 927     debug_info()-&gt;describe_scope(safepoint_pc_offset, null_mh, scope_method, jvms-&gt;bci(), jvms-&gt;should_reexecute(), rethrow_exception, is_method_handle_invoke, return_oop, return_vt, locvals, expvals, monvals);
 928   } // End jvms loop
 929 
 930   // Mark the end of the scope set.
 931   debug_info()-&gt;end_safepoint(safepoint_pc_offset);
 932 }
 933 
 934 
 935 
 936 // A simplified version of Process_OopMap_Node, to handle non-safepoints.
 937 class NonSafepointEmitter {
 938     Compile*  C;
 939     JVMState* _pending_jvms;
 940     int       _pending_offset;
 941 
 942     void emit_non_safepoint();
 943 
 944  public:
 945     NonSafepointEmitter(Compile* compile) {
 946       this-&gt;C = compile;
 947       _pending_jvms = NULL;
 948       _pending_offset = 0;
 949     }
 950 
 951     void observe_instruction(Node* n, int pc_offset) {
 952       if (!C-&gt;debug_info()-&gt;recording_non_safepoints())  return;
 953 
 954       Node_Notes* nn = C-&gt;node_notes_at(n-&gt;_idx);
 955       if (nn == NULL || nn-&gt;jvms() == NULL)  return;
 956       if (_pending_jvms != NULL &amp;&amp;
 957           _pending_jvms-&gt;same_calls_as(nn-&gt;jvms())) {
 958         // Repeated JVMS?  Stretch it up here.
 959         _pending_offset = pc_offset;
 960       } else {
 961         if (_pending_jvms != NULL &amp;&amp;
 962             _pending_offset &lt; pc_offset) {
 963           emit_non_safepoint();
 964         }
 965         _pending_jvms = NULL;
 966         if (pc_offset &gt; C-&gt;debug_info()-&gt;last_pc_offset()) {
 967           // This is the only way _pending_jvms can become non-NULL:
 968           _pending_jvms = nn-&gt;jvms();
 969           _pending_offset = pc_offset;
 970         }
 971       }
 972     }
 973 
 974     // Stay out of the way of real safepoints:
 975     void observe_safepoint(JVMState* jvms, int pc_offset) {
 976       if (_pending_jvms != NULL &amp;&amp;
 977           !_pending_jvms-&gt;same_calls_as(jvms) &amp;&amp;
 978           _pending_offset &lt; pc_offset) {
 979         emit_non_safepoint();
 980       }
 981       _pending_jvms = NULL;
 982     }
 983 
 984     void flush_at_end() {
 985       if (_pending_jvms != NULL) {
 986         emit_non_safepoint();
 987       }
 988       _pending_jvms = NULL;
 989     }
 990 };
 991 
 992 void NonSafepointEmitter::emit_non_safepoint() {
 993   JVMState* youngest_jvms = _pending_jvms;
 994   int       pc_offset     = _pending_offset;
 995 
 996   // Clear it now:
 997   _pending_jvms = NULL;
 998 
 999   DebugInformationRecorder* debug_info = C-&gt;debug_info();
1000   assert(debug_info-&gt;recording_non_safepoints(), &quot;sanity&quot;);
1001 
1002   debug_info-&gt;add_non_safepoint(pc_offset);
1003   int max_depth = youngest_jvms-&gt;depth();
1004 
1005   // Visit scopes from oldest to youngest.
1006   for (int depth = 1; depth &lt;= max_depth; depth++) {
1007     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
1008     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
1009     assert(!jvms-&gt;should_reexecute() || depth==max_depth, &quot;reexecute allowed only for the youngest&quot;);
1010     methodHandle null_mh;
1011     debug_info-&gt;describe_scope(pc_offset, null_mh, method, jvms-&gt;bci(), jvms-&gt;should_reexecute());
1012   }
1013 
1014   // Mark the end of the scope set.
1015   debug_info-&gt;end_non_safepoint(pc_offset);
1016 }
1017 
1018 //------------------------------init_buffer------------------------------------
1019 void Compile::estimate_buffer_size(int&amp; const_req) {
1020 
1021   // Set the initially allocated size
1022   const_req = initial_const_capacity;
1023 
1024   // The extra spacing after the code is necessary on some platforms.
1025   // Sometimes we need to patch in a jump after the last instruction,
1026   // if the nmethod has been deoptimized.  (See 4932387, 4894843.)
1027 
1028   // Compute the byte offset where we can store the deopt pc.
1029   if (fixed_slots() != 0) {
1030     _orig_pc_slot_offset_in_bytes = _regalloc-&gt;reg2offset(OptoReg::stack2reg(_orig_pc_slot));
1031   }
1032   if (C-&gt;needs_stack_repair()) {
1033     // Compute the byte offset of the stack increment value
1034     _sp_inc_slot_offset_in_bytes = _regalloc-&gt;reg2offset(OptoReg::stack2reg(_sp_inc_slot));
1035   }
1036 
1037   // Compute prolog code size
1038   _method_size = 0;
1039   _frame_slots = OptoReg::reg2stack(_matcher-&gt;_old_SP) + _regalloc-&gt;_framesize;
1040 #if defined(IA64) &amp;&amp; !defined(AIX)
1041   if (save_argument_registers()) {
1042     // 4815101: this is a stub with implicit and unknown precision fp args.
1043     // The usual spill mechanism can only generate stfd&#39;s in this case, which
1044     // doesn&#39;t work if the fp reg to spill contains a single-precision denorm.
1045     // Instead, we hack around the normal spill mechanism using stfspill&#39;s and
1046     // ldffill&#39;s in the MachProlog and MachEpilog emit methods.  We allocate
1047     // space here for the fp arg regs (f8-f15) we&#39;re going to thusly spill.
1048     //
1049     // If we ever implement 16-byte &#39;registers&#39; == stack slots, we can
1050     // get rid of this hack and have SpillCopy generate stfspill/ldffill
1051     // instead of stfd/stfs/ldfd/ldfs.
1052     _frame_slots += 8*(16/BytesPerInt);
1053   }
1054 #endif
1055   assert(_frame_slots &gt;= 0 &amp;&amp; _frame_slots &lt; 1000000, &quot;sanity check&quot;);
1056 
1057   if (has_mach_constant_base_node()) {
1058     uint add_size = 0;
1059     // Fill the constant table.
1060     // Note:  This must happen before shorten_branches.
1061     for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {
1062       Block* b = _cfg-&gt;get_block(i);
1063 
1064       for (uint j = 0; j &lt; b-&gt;number_of_nodes(); j++) {
1065         Node* n = b-&gt;get_node(j);
1066 
1067         // If the node is a MachConstantNode evaluate the constant
1068         // value section.
1069         if (n-&gt;is_MachConstant()) {
1070           MachConstantNode* machcon = n-&gt;as_MachConstant();
1071           machcon-&gt;eval_constant(C);
1072         } else if (n-&gt;is_Mach()) {
1073           // On Power there are more nodes that issue constants.
1074           add_size += (n-&gt;as_Mach()-&gt;ins_num_consts() * 8);
1075         }
1076       }
1077     }
1078 
1079     // Calculate the offsets of the constants and the size of the
1080     // constant table (including the padding to the next section).
1081     constant_table().calculate_offsets_and_size();
1082     const_req = constant_table().size() + add_size;
1083   }
1084 
1085   // Initialize the space for the BufferBlob used to find and verify
1086   // instruction size in MachNode::emit_size()
1087   init_scratch_buffer_blob(const_req);
1088 }
1089 
1090 CodeBuffer* Compile::init_buffer(BufferSizingData&amp; buf_sizes) {
1091 
1092   int stub_req  = buf_sizes._stub;
1093   int code_req  = buf_sizes._code;
1094   int const_req = buf_sizes._const;
1095 
1096   int pad_req   = NativeCall::instruction_size;
1097 
1098   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1099   stub_req += bs-&gt;estimate_stub_size();
1100 
1101   // nmethod and CodeBuffer count stubs &amp; constants as part of method&#39;s code.
1102   // class HandlerImpl is platform-specific and defined in the *.ad files.
1103   int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; // add marginal slop for handler
1104   int deopt_handler_req     = HandlerImpl::size_deopt_handler()     + MAX_stubs_size; // add marginal slop for handler
1105   stub_req += MAX_stubs_size;   // ensure per-stub margin
1106   code_req += MAX_inst_size;    // ensure per-instruction margin
1107 
1108   if (StressCodeBuffers)
1109     code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  // force expansion
1110 
1111   int total_req =
1112           const_req +
1113           code_req +
1114           pad_req +
1115           stub_req +
1116           exception_handler_req +
1117           deopt_handler_req;               // deopt handler
1118 
1119   if (has_method_handle_invokes())
1120     total_req += deopt_handler_req;  // deopt MH handler
1121 
1122   CodeBuffer* cb = code_buffer();
1123   cb-&gt;initialize(total_req, buf_sizes._reloc);
1124 
1125   // Have we run out of code space?
1126   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1127     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1128     return NULL;
1129   }
1130   // Configure the code buffer.
1131   cb-&gt;initialize_consts_size(const_req);
1132   cb-&gt;initialize_stubs_size(stub_req);
1133   cb-&gt;initialize_oop_recorder(env()-&gt;oop_recorder());
1134 
1135   // fill in the nop array for bundling computations
1136   MachNode *_nop_list[Bundle::_nop_count];
1137   Bundle::initialize_nops(_nop_list);
1138 
1139   return cb;
1140 }
1141 
1142 //------------------------------fill_buffer------------------------------------
1143 void Compile::fill_buffer(CodeBuffer* cb, uint* blk_starts) {
1144   // blk_starts[] contains offsets calculated during short branches processing,
1145   // offsets should not be increased during following steps.
1146 
1147   // Compute the size of first NumberOfLoopInstrToAlign instructions at head
1148   // of a loop. It is used to determine the padding for loop alignment.
1149   compute_loop_first_inst_sizes();
1150 
1151   // Create oopmap set.
1152   _oop_map_set = new OopMapSet();
1153 
1154   // !!!!! This preserves old handling of oopmaps for now
1155   debug_info()-&gt;set_oopmaps(_oop_map_set);
1156 
1157   uint nblocks  = _cfg-&gt;number_of_blocks();
1158   // Count and start of implicit null check instructions
1159   uint inct_cnt = 0;
1160   uint *inct_starts = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1161 
1162   // Count and start of calls
1163   uint *call_returns = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1164 
1165   uint  return_offset = 0;
1166   int nop_size = (new MachNopNode())-&gt;size(_regalloc);
1167 
1168   int previous_offset = 0;
1169   int current_offset  = 0;
1170   int last_call_offset = -1;
1171   int last_avoid_back_to_back_offset = -1;
1172 #ifdef ASSERT
1173   uint* jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks);
1174   uint* jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
1175   uint* jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
1176   uint* jmp_rule   = NEW_RESOURCE_ARRAY(uint,nblocks);
1177 #endif
1178 
1179   // Create an array of unused labels, one for each basic block, if printing is enabled
1180 #if defined(SUPPORT_OPTO_ASSEMBLY)
1181   int *node_offsets      = NULL;
1182   uint node_offset_limit = unique();
1183 
1184   if (print_assembly()) {
1185     node_offsets = NEW_RESOURCE_ARRAY(int, node_offset_limit);
1186   }
1187   if (node_offsets != NULL) {
1188     // We need to initialize. Unused array elements may contain garbage and mess up PrintOptoAssembly.
1189     memset(node_offsets, 0, node_offset_limit*sizeof(int));
1190   }
1191 #endif
1192 
1193   NonSafepointEmitter non_safepoints(this);  // emit non-safepoints lazily
1194 
1195   // Emit the constant table.
1196   if (has_mach_constant_base_node()) {
1197     constant_table().emit(*cb);
1198   }
1199 
1200   // Create an array of labels, one for each basic block
1201   Label *blk_labels = NEW_RESOURCE_ARRAY(Label, nblocks+1);
1202   for (uint i=0; i &lt;= nblocks; i++) {
1203     blk_labels[i].init();
1204   }
1205 
1206   // ------------------
1207   // Now fill in the code buffer
1208   Node *delay_slot = NULL;
1209 
1210   for (uint i = 0; i &lt; nblocks; i++) {
1211     Block* block = _cfg-&gt;get_block(i);
1212     Node* head = block-&gt;head();
1213 
1214     // If this block needs to start aligned (i.e, can be reached other
1215     // than by falling-thru from the previous block), then force the
1216     // start of a new bundle.
1217     if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(head)) {
1218       cb-&gt;flush_bundle(true);
1219     }
1220 
1221 #ifdef ASSERT
1222     if (!block-&gt;is_connector()) {
1223       stringStream st;
1224       block-&gt;dump_head(_cfg, &amp;st);
1225       MacroAssembler(cb).block_comment(st.as_string());
1226     }
1227     jmp_target[i] = 0;
1228     jmp_offset[i] = 0;
1229     jmp_size[i]   = 0;
1230     jmp_rule[i]   = 0;
1231 #endif
1232     int blk_offset = current_offset;
1233 
1234     // Define the label at the beginning of the basic block
1235     MacroAssembler(cb).bind(blk_labels[block-&gt;_pre_order]);
1236 
1237     uint last_inst = block-&gt;number_of_nodes();
1238 
1239     // Emit block normally, except for last instruction.
1240     // Emit means &quot;dump code bits into code buffer&quot;.
1241     for (uint j = 0; j&lt;last_inst; j++) {
1242 
1243       // Get the node
1244       Node* n = block-&gt;get_node(j);
1245 
1246       // See if delay slots are supported
1247       if (valid_bundle_info(n) &amp;&amp;
1248           node_bundling(n)-&gt;used_in_unconditional_delay()) {
1249         assert(delay_slot == NULL, &quot;no use of delay slot node&quot;);
1250         assert(n-&gt;size(_regalloc) == Pipeline::instr_unit_size(), &quot;delay slot instruction wrong size&quot;);
1251 
1252         delay_slot = n;
1253         continue;
1254       }
1255 
1256       // If this starts a new instruction group, then flush the current one
1257       // (but allow split bundles)
1258       if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(n))
1259         cb-&gt;flush_bundle(false);
1260 
1261       // Special handling for SafePoint/Call Nodes
1262       bool is_mcall = false;
1263       if (n-&gt;is_Mach()) {
1264         MachNode *mach = n-&gt;as_Mach();
1265         is_mcall = n-&gt;is_MachCall();
1266         bool is_sfn = n-&gt;is_MachSafePoint();
1267 
1268         // If this requires all previous instructions be flushed, then do so
1269         if (is_sfn || is_mcall || mach-&gt;alignment_required() != 1) {
1270           cb-&gt;flush_bundle(true);
1271           current_offset = cb-&gt;insts_size();
1272         }
1273 
1274         // A padding may be needed again since a previous instruction
1275         // could be moved to delay slot.
1276 
1277         // align the instruction if necessary
1278         int padding = mach-&gt;compute_padding(current_offset);
1279         // Make sure safepoint node for polling is distinct from a call&#39;s
1280         // return by adding a nop if needed.
1281         if (is_sfn &amp;&amp; !is_mcall &amp;&amp; padding == 0 &amp;&amp; current_offset == last_call_offset) {
1282           padding = nop_size;
1283         }
1284         if (padding == 0 &amp;&amp; mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE) &amp;&amp;
1285             current_offset == last_avoid_back_to_back_offset) {
1286           // Avoid back to back some instructions.
1287           padding = nop_size;
1288         }
1289 #ifdef X86
1290         if (mach-&gt;flags() &amp; Node::Flag_intel_jcc_erratum) {
1291           assert(padding == 0, &quot;can&#39;t have contradicting padding requirements&quot;);
1292           padding = IntelJccErratum::compute_padding(current_offset, mach, block, j, _regalloc);
1293         }
1294 #endif
1295 
1296         if (padding &gt; 0) {
1297           assert((padding % nop_size) == 0, &quot;padding is not a multiple of NOP size&quot;);
1298           int nops_cnt = padding / nop_size;
1299           MachNode *nop = new MachNopNode(nops_cnt);
1300           block-&gt;insert_node(nop, j++);
1301           last_inst++;
1302           _cfg-&gt;map_node_to_block(nop, block);
1303           // Ensure enough space.
1304           cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1305           if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1306             C-&gt;record_failure(&quot;CodeCache is full&quot;);
1307             return;
1308           }
1309           nop-&gt;emit(*cb, _regalloc);
1310           cb-&gt;flush_bundle(true);
1311           current_offset = cb-&gt;insts_size();
1312         }
1313 
1314         // Remember the start of the last call in a basic block
1315         if (is_mcall) {
1316           MachCallNode *mcall = mach-&gt;as_MachCall();
1317 
1318           if (mcall-&gt;entry_point() != NULL) {
1319             // This destination address is NOT PC-relative
1320             mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
1321           }
1322 
1323           // Save the return address
1324           call_returns[block-&gt;_pre_order] = current_offset + mcall-&gt;ret_addr_offset();
1325 
1326           if (mcall-&gt;is_MachCallLeaf()) {
1327             is_mcall = false;
1328             is_sfn = false;
1329           }
1330         }
1331 
1332         // sfn will be valid whenever mcall is valid now because of inheritance
1333         if (is_sfn || is_mcall) {
1334 
1335           // Handle special safepoint nodes for synchronization
1336           if (!is_mcall) {
1337             MachSafePointNode *sfn = mach-&gt;as_MachSafePoint();
1338             // !!!!! Stubs only need an oopmap right now, so bail out
1339             if (sfn-&gt;jvms()-&gt;method() == NULL) {
1340               // Write the oopmap directly to the code blob??!!
1341               continue;
1342             }
1343           } // End synchronization
1344 
1345           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1346                                            current_offset);
1347           Process_OopMap_Node(mach, current_offset);
1348         } // End if safepoint
1349 
1350           // If this is a null check, then add the start of the previous instruction to the list
1351         else if( mach-&gt;is_MachNullCheck() ) {
1352           inct_starts[inct_cnt++] = previous_offset;
1353         }
1354 
1355           // If this is a branch, then fill in the label with the target BB&#39;s label
1356         else if (mach-&gt;is_MachBranch()) {
1357           // This requires the TRUE branch target be in succs[0]
1358           uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1359 
1360           // Try to replace long branch if delay slot is not used,
1361           // it is mostly for back branches since forward branch&#39;s
1362           // distance is not updated yet.
1363           bool delay_slot_is_used = valid_bundle_info(n) &amp;&amp;
1364                                     node_bundling(n)-&gt;use_unconditional_delay();
1365           if (!delay_slot_is_used &amp;&amp; mach-&gt;may_be_short_branch()) {
1366             assert(delay_slot == NULL, &quot;not expecting delay slot node&quot;);
1367             int br_size = n-&gt;size(_regalloc);
1368             int offset = blk_starts[block_num] - current_offset;
1369             if (block_num &gt;= i) {
1370               // Current and following block&#39;s offset are not
1371               // finalized yet, adjust distance by the difference
1372               // between calculated and final offsets of current block.
1373               offset -= (blk_starts[i] - blk_offset);
1374             }
1375             // In the following code a nop could be inserted before
1376             // the branch which will increase the backward distance.
1377             bool needs_padding = (current_offset == last_avoid_back_to_back_offset);
1378             if (needs_padding &amp;&amp; offset &lt;= 0)
1379               offset -= nop_size;
1380 
1381             if (_matcher-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {
1382               // We&#39;ve got a winner.  Replace this branch.
1383               MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
1384 
1385               // Update the jmp_size.
1386               int new_size = replacement-&gt;size(_regalloc);
1387               assert((br_size - new_size) &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
1388               // Insert padding between avoid_back_to_back branches.
1389               if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
1390                 MachNode *nop = new MachNopNode();
1391                 block-&gt;insert_node(nop, j++);
1392                 _cfg-&gt;map_node_to_block(nop, block);
1393                 last_inst++;
1394                 nop-&gt;emit(*cb, _regalloc);
1395                 cb-&gt;flush_bundle(true);
1396                 current_offset = cb-&gt;insts_size();
1397               }
1398 #ifdef ASSERT
1399               jmp_target[i] = block_num;
1400               jmp_offset[i] = current_offset - blk_offset;
1401               jmp_size[i]   = new_size;
1402               jmp_rule[i]   = mach-&gt;rule();
1403 #endif
1404               block-&gt;map_node(replacement, j);
1405               mach-&gt;subsume_by(replacement, C);
1406               n    = replacement;
1407               mach = replacement;
1408             }
1409           }
1410           mach-&gt;as_MachBranch()-&gt;label_set( &amp;blk_labels[block_num], block_num );
1411         } else if (mach-&gt;ideal_Opcode() == Op_Jump) {
1412           for (uint h = 0; h &lt; block-&gt;_num_succs; h++) {
1413             Block* succs_block = block-&gt;_succs[h];
1414             for (uint j = 1; j &lt; succs_block-&gt;num_preds(); j++) {
1415               Node* jpn = succs_block-&gt;pred(j);
1416               if (jpn-&gt;is_JumpProj() &amp;&amp; jpn-&gt;in(0) == mach) {
1417                 uint block_num = succs_block-&gt;non_connector()-&gt;_pre_order;
1418                 Label *blkLabel = &amp;blk_labels[block_num];
1419                 mach-&gt;add_case_label(jpn-&gt;as_JumpProj()-&gt;proj_no(), blkLabel);
1420               }
1421             }
1422           }
1423         }
1424 #ifdef ASSERT
1425           // Check that oop-store precedes the card-mark
1426         else if (mach-&gt;ideal_Opcode() == Op_StoreCM) {
1427           uint storeCM_idx = j;
1428           int count = 0;
1429           for (uint prec = mach-&gt;req(); prec &lt; mach-&gt;len(); prec++) {
1430             Node *oop_store = mach-&gt;in(prec);  // Precedence edge
1431             if (oop_store == NULL) continue;
1432             count++;
1433             uint i4;
1434             for (i4 = 0; i4 &lt; last_inst; ++i4) {
1435               if (block-&gt;get_node(i4) == oop_store) {
1436                 break;
1437               }
1438             }
1439             // Note: This test can provide a false failure if other precedence
1440             // edges have been added to the storeCMNode.
1441             assert(i4 == last_inst || i4 &lt; storeCM_idx, &quot;CM card-mark executes before oop-store&quot;);
1442           }
1443           assert(count &gt; 0, &quot;storeCM expects at least one precedence edge&quot;);
1444         }
1445 #endif
1446         else if (!n-&gt;is_Proj()) {
1447           // Remember the beginning of the previous instruction, in case
1448           // it&#39;s followed by a flag-kill and a null-check.  Happens on
1449           // Intel all the time, with add-to-memory kind of opcodes.
1450           previous_offset = current_offset;
1451         }
1452 
1453         // Not an else-if!
1454         // If this is a trap based cmp then add its offset to the list.
1455         if (mach-&gt;is_TrapBasedCheckNode()) {
1456           inct_starts[inct_cnt++] = current_offset;
1457         }
1458       }
1459 
1460       // Verify that there is sufficient space remaining
1461       cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1462       if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1463         C-&gt;record_failure(&quot;CodeCache is full&quot;);
1464         return;
1465       }
1466 
1467       // Save the offset for the listing
1468 #if defined(SUPPORT_OPTO_ASSEMBLY)
1469       if ((node_offsets != NULL) &amp;&amp; (n-&gt;_idx &lt; node_offset_limit)) {
1470         node_offsets[n-&gt;_idx] = cb-&gt;insts_size();
1471       }
1472 #endif
1473 
1474       // &quot;Normal&quot; instruction case
1475       DEBUG_ONLY( uint instr_offset = cb-&gt;insts_size(); )
1476       n-&gt;emit(*cb, _regalloc);
1477       current_offset  = cb-&gt;insts_size();
1478 
1479       // Above we only verified that there is enough space in the instruction section.
1480       // However, the instruction may emit stubs that cause code buffer expansion.
1481       // Bail out here if expansion failed due to a lack of code cache space.
1482       if (failing()) {
1483         return;
1484       }
1485 
1486 #ifdef ASSERT
1487       if (n-&gt;size(_regalloc) &lt; (current_offset-instr_offset)) {
1488         n-&gt;dump();
1489         assert(false, &quot;wrong size of mach node&quot;);
1490       }
1491 #endif
1492       non_safepoints.observe_instruction(n, current_offset);
1493 
1494       // mcall is last &quot;call&quot; that can be a safepoint
1495       // record it so we can see if a poll will directly follow it
1496       // in which case we&#39;ll need a pad to make the PcDesc sites unique
1497       // see  5010568. This can be slightly inaccurate but conservative
1498       // in the case that return address is not actually at current_offset.
1499       // This is a small price to pay.
1500 
1501       if (is_mcall) {
1502         last_call_offset = current_offset;
1503       }
1504 
1505       if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
1506         // Avoid back to back some instructions.
1507         last_avoid_back_to_back_offset = current_offset;
1508       }
1509 
1510       // See if this instruction has a delay slot
1511       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;use_unconditional_delay()) {
1512         guarantee(delay_slot != NULL, &quot;expecting delay slot node&quot;);
1513 
1514         // Back up 1 instruction
1515         cb-&gt;set_insts_end(cb-&gt;insts_end() - Pipeline::instr_unit_size());
1516 
1517         // Save the offset for the listing
1518 #if defined(SUPPORT_OPTO_ASSEMBLY)
1519         if ((node_offsets != NULL) &amp;&amp; (delay_slot-&gt;_idx &lt; node_offset_limit)) {
1520           node_offsets[delay_slot-&gt;_idx] = cb-&gt;insts_size();
1521         }
1522 #endif
1523 
1524         // Support a SafePoint in the delay slot
1525         if (delay_slot-&gt;is_MachSafePoint()) {
1526           MachNode *mach = delay_slot-&gt;as_Mach();
1527           // !!!!! Stubs only need an oopmap right now, so bail out
1528           if (!mach-&gt;is_MachCall() &amp;&amp; mach-&gt;as_MachSafePoint()-&gt;jvms()-&gt;method() == NULL) {
1529             // Write the oopmap directly to the code blob??!!
1530             delay_slot = NULL;
1531             continue;
1532           }
1533 
1534           int adjusted_offset = current_offset - Pipeline::instr_unit_size();
1535           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1536                                            adjusted_offset);
1537           // Generate an OopMap entry
1538           Process_OopMap_Node(mach, adjusted_offset);
1539         }
1540 
1541         // Insert the delay slot instruction
1542         delay_slot-&gt;emit(*cb, _regalloc);
1543 
1544         // Don&#39;t reuse it
1545         delay_slot = NULL;
1546       }
1547 
1548     } // End for all instructions in block
1549 
1550     // If the next block is the top of a loop, pad this block out to align
1551     // the loop top a little. Helps prevent pipe stalls at loop back branches.
1552     if (i &lt; nblocks-1) {
1553       Block *nb = _cfg-&gt;get_block(i + 1);
1554       int padding = nb-&gt;alignment_padding(current_offset);
1555       if( padding &gt; 0 ) {
1556         MachNode *nop = new MachNopNode(padding / nop_size);
1557         block-&gt;insert_node(nop, block-&gt;number_of_nodes());
1558         _cfg-&gt;map_node_to_block(nop, block);
1559         nop-&gt;emit(*cb, _regalloc);
1560         current_offset = cb-&gt;insts_size();
1561       }
1562     }
1563     // Verify that the distance for generated before forward
1564     // short branches is still valid.
1565     guarantee((int)(blk_starts[i+1] - blk_starts[i]) &gt;= (current_offset - blk_offset), &quot;shouldn&#39;t increase block size&quot;);
1566 
1567     // Save new block start offset
1568     blk_starts[i] = blk_offset;
1569   } // End of for all blocks
1570   blk_starts[nblocks] = current_offset;
1571 
1572   non_safepoints.flush_at_end();
1573 
1574   // Offset too large?
1575   if (failing())  return;
1576 
1577   // Define a pseudo-label at the end of the code
1578   MacroAssembler(cb).bind( blk_labels[nblocks] );
1579 
1580   // Compute the size of the first block
1581   _first_block_size = blk_labels[1].loc_pos() - blk_labels[0].loc_pos();
1582 
1583 #ifdef ASSERT
1584   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
1585     if (jmp_target[i] != 0) {
1586       int br_size = jmp_size[i];
1587       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
1588       if (!_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {
1589         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
1590         assert(false, &quot;Displacement too large for short jmp&quot;);
1591       }
1592     }
1593   }
1594 #endif
1595 
1596   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1597   bs-&gt;emit_stubs(*cb);
1598   if (failing())  return;
1599 
1600 #ifndef PRODUCT
1601   // Information on the size of the method, without the extraneous code
1602   Scheduling::increment_method_size(cb-&gt;insts_size());
1603 #endif
1604 
1605   // ------------------
1606   // Fill in exception table entries.
1607   FillExceptionTables(inct_cnt, call_returns, inct_starts, blk_labels);
1608 
1609   // Only java methods have exception handlers and deopt handlers
1610   // class HandlerImpl is platform-specific and defined in the *.ad files.
1611   if (_method) {
1612     // Emit the exception handler code.
1613     _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(*cb));
1614     if (failing()) {
1615       return; // CodeBuffer::expand failed
1616     }
1617     // Emit the deopt handler code.
1618     _code_offsets.set_value(CodeOffsets::Deopt, HandlerImpl::emit_deopt_handler(*cb));
1619 
1620     // Emit the MethodHandle deopt handler code (if required).
1621     if (has_method_handle_invokes() &amp;&amp; !failing()) {
1622       // We can use the same code as for the normal deopt handler, we
1623       // just need a different entry point address.
1624       _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(*cb));
1625     }
1626   }
1627 
1628   // One last check for failed CodeBuffer::expand:
1629   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1630     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1631     return;
1632   }
1633 
1634 #if defined(SUPPORT_ABSTRACT_ASSEMBLY) || defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_OPTO_ASSEMBLY)
1635   if (print_assembly()) {
1636     tty-&gt;cr();
1637     tty-&gt;print_cr(&quot;============================= C2-compiled nmethod ==============================&quot;);
1638   }
1639 #endif
1640 
1641 #if defined(SUPPORT_OPTO_ASSEMBLY)
1642   // Dump the assembly code, including basic-block numbers
1643   if (print_assembly()) {
1644     ttyLocker ttyl;  // keep the following output all in one block
1645     if (!VMThread::should_terminate()) {  // test this under the tty lock
1646       // This output goes directly to the tty, not the compiler log.
1647       // To enable tools to match it up with the compilation activity,
1648       // be sure to tag this tty output with the compile ID.
1649       if (xtty != NULL) {
1650         xtty-&gt;head(&quot;opto_assembly compile_id=&#39;%d&#39;%s&quot;, compile_id(),
1651                    is_osr_compilation()    ? &quot; compile_kind=&#39;osr&#39;&quot; :
1652                    &quot;&quot;);
1653       }
1654       if (method() != NULL) {
1655         tty-&gt;print_cr(&quot;----------------------- MetaData before Compile_id = %d ------------------------&quot;, compile_id());
1656         method()-&gt;print_metadata();
1657       } else if (stub_name() != NULL) {
1658         tty-&gt;print_cr(&quot;----------------------------- RuntimeStub %s -------------------------------&quot;, stub_name());
1659       }
1660       tty-&gt;cr();
1661       tty-&gt;print_cr(&quot;------------------------ OptoAssembly for Compile_id = %d -----------------------&quot;, compile_id());
1662       dump_asm(node_offsets, node_offset_limit);
1663       tty-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);
1664       if (xtty != NULL) {
1665         // print_metadata and dump_asm above may safepoint which makes us loose the ttylock.
1666         // Retake lock too make sure the end tag is coherent, and that xmlStream-&gt;pop_tag is done
1667         // thread safe
1668         ttyLocker ttyl2;
1669         xtty-&gt;tail(&quot;opto_assembly&quot;);
1670       }
1671     }
1672   }
1673 #endif
1674 }
1675 
1676 void Compile::FillExceptionTables(uint cnt, uint *call_returns, uint *inct_starts, Label *blk_labels) {
1677   _inc_table.set_size(cnt);
1678 
1679   uint inct_cnt = 0;
1680   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {
1681     Block* block = _cfg-&gt;get_block(i);
1682     Node *n = NULL;
1683     int j;
1684 
1685     // Find the branch; ignore trailing NOPs.
1686     for (j = block-&gt;number_of_nodes() - 1; j &gt;= 0; j--) {
1687       n = block-&gt;get_node(j);
1688       if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con) {
1689         break;
1690       }
1691     }
1692 
1693     // If we didn&#39;t find anything, continue
1694     if (j &lt; 0) {
1695       continue;
1696     }
1697 
1698     // Compute ExceptionHandlerTable subtable entry and add it
1699     // (skip empty blocks)
1700     if (n-&gt;is_Catch()) {
1701 
1702       // Get the offset of the return from the call
1703       uint call_return = call_returns[block-&gt;_pre_order];
1704 #ifdef ASSERT
1705       assert( call_return &gt; 0, &quot;no call seen for this basic block&quot; );
1706       while (block-&gt;get_node(--j)-&gt;is_MachProj()) ;
1707       assert(block-&gt;get_node(j)-&gt;is_MachCall(), &quot;CatchProj must follow call&quot;);
1708 #endif
1709       // last instruction is a CatchNode, find it&#39;s CatchProjNodes
1710       int nof_succs = block-&gt;_num_succs;
1711       // allocate space
1712       GrowableArray&lt;intptr_t&gt; handler_bcis(nof_succs);
1713       GrowableArray&lt;intptr_t&gt; handler_pcos(nof_succs);
1714       // iterate through all successors
1715       for (int j = 0; j &lt; nof_succs; j++) {
1716         Block* s = block-&gt;_succs[j];
1717         bool found_p = false;
1718         for (uint k = 1; k &lt; s-&gt;num_preds(); k++) {
1719           Node* pk = s-&gt;pred(k);
1720           if (pk-&gt;is_CatchProj() &amp;&amp; pk-&gt;in(0) == n) {
1721             const CatchProjNode* p = pk-&gt;as_CatchProj();
1722             found_p = true;
1723             // add the corresponding handler bci &amp; pco information
1724             if (p-&gt;_con != CatchProjNode::fall_through_index) {
1725               // p leads to an exception handler (and is not fall through)
1726               assert(s == _cfg-&gt;get_block(s-&gt;_pre_order), &quot;bad numbering&quot;);
1727               // no duplicates, please
1728               if (!handler_bcis.contains(p-&gt;handler_bci())) {
1729                 uint block_num = s-&gt;non_connector()-&gt;_pre_order;
1730                 handler_bcis.append(p-&gt;handler_bci());
1731                 handler_pcos.append(blk_labels[block_num].loc_pos());
1732               }
1733             }
1734           }
1735         }
1736         assert(found_p, &quot;no matching predecessor found&quot;);
1737         // Note:  Due to empty block removal, one block may have
1738         // several CatchProj inputs, from the same Catch.
1739       }
1740 
1741       // Set the offset of the return from the call
1742       assert(handler_bcis.find(-1) != -1, &quot;must have default handler&quot;);
1743       _handler_table.add_subtable(call_return, &amp;handler_bcis, NULL, &amp;handler_pcos);
1744       continue;
1745     }
1746 
1747     // Handle implicit null exception table updates
1748     if (n-&gt;is_MachNullCheck()) {
1749       uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1750       _inc_table.append(inct_starts[inct_cnt++], blk_labels[block_num].loc_pos());
1751       continue;
1752     }
1753     // Handle implicit exception table updates: trap instructions.
1754     if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;is_TrapBasedCheckNode()) {
1755       uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1756       _inc_table.append(inct_starts[inct_cnt++], blk_labels[block_num].loc_pos());
1757       continue;
1758     }
1759   } // End of for all blocks fill in exception table entries
1760 }
1761 
1762 // Static Variables
1763 #ifndef PRODUCT
1764 uint Scheduling::_total_nop_size = 0;
1765 uint Scheduling::_total_method_size = 0;
1766 uint Scheduling::_total_branches = 0;
1767 uint Scheduling::_total_unconditional_delays = 0;
1768 uint Scheduling::_total_instructions_per_bundle[Pipeline::_max_instrs_per_cycle+1];
1769 #endif
1770 
1771 // Initializer for class Scheduling
1772 
1773 Scheduling::Scheduling(Arena *arena, Compile &amp;compile)
1774         : _arena(arena),
1775           _cfg(compile.cfg()),
1776           _regalloc(compile.regalloc()),
1777           _scheduled(arena),
1778           _available(arena),
1779           _reg_node(arena),
1780           _pinch_free_list(arena),
1781           _next_node(NULL),
1782           _bundle_instr_count(0),
1783           _bundle_cycle_number(0),
1784           _bundle_use(0, 0, resource_count, &amp;_bundle_use_elements[0])
1785 #ifndef PRODUCT
1786         , _branches(0)
1787         , _unconditional_delays(0)
1788 #endif
1789 {
1790   // Create a MachNopNode
1791   _nop = new MachNopNode();
1792 
1793   // Now that the nops are in the array, save the count
1794   // (but allow entries for the nops)
1795   _node_bundling_limit = compile.unique();
1796   uint node_max = _regalloc-&gt;node_regs_max_index();
1797 
1798   compile.set_node_bundling_limit(_node_bundling_limit);
1799 
1800   // This one is persistent within the Compile class
1801   _node_bundling_base = NEW_ARENA_ARRAY(compile.comp_arena(), Bundle, node_max);
1802 
1803   // Allocate space for fixed-size arrays
1804   _node_latency    = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1805   _uses            = NEW_ARENA_ARRAY(arena, short,          node_max);
1806   _current_latency = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1807 
1808   // Clear the arrays
1809   for (uint i = 0; i &lt; node_max; i++) {
1810     ::new (&amp;_node_bundling_base[i]) Bundle();
1811   }
1812   memset(_node_latency,       0, node_max * sizeof(unsigned short));
1813   memset(_uses,               0, node_max * sizeof(short));
1814   memset(_current_latency,    0, node_max * sizeof(unsigned short));
1815 
1816   // Clear the bundling information
1817   memcpy(_bundle_use_elements, Pipeline_Use::elaborated_elements, sizeof(Pipeline_Use::elaborated_elements));
1818 
1819   // Get the last node
1820   Block* block = _cfg-&gt;get_block(_cfg-&gt;number_of_blocks() - 1);
1821 
1822   _next_node = block-&gt;get_node(block-&gt;number_of_nodes() - 1);
1823 }
1824 
1825 #ifndef PRODUCT
1826 // Scheduling destructor
1827 Scheduling::~Scheduling() {
1828   _total_branches             += _branches;
1829   _total_unconditional_delays += _unconditional_delays;
1830 }
1831 #endif
1832 
1833 // Step ahead &quot;i&quot; cycles
1834 void Scheduling::step(uint i) {
1835 
1836   Bundle *bundle = node_bundling(_next_node);
1837   bundle-&gt;set_starts_bundle();
1838 
1839   // Update the bundle record, but leave the flags information alone
1840   if (_bundle_instr_count &gt; 0) {
1841     bundle-&gt;set_instr_count(_bundle_instr_count);
1842     bundle-&gt;set_resources_used(_bundle_use.resourcesUsed());
1843   }
1844 
1845   // Update the state information
1846   _bundle_instr_count = 0;
1847   _bundle_cycle_number += i;
1848   _bundle_use.step(i);
1849 }
1850 
1851 void Scheduling::step_and_clear() {
1852   Bundle *bundle = node_bundling(_next_node);
1853   bundle-&gt;set_starts_bundle();
1854 
1855   // Update the bundle record
1856   if (_bundle_instr_count &gt; 0) {
1857     bundle-&gt;set_instr_count(_bundle_instr_count);
1858     bundle-&gt;set_resources_used(_bundle_use.resourcesUsed());
1859 
1860     _bundle_cycle_number += 1;
1861   }
1862 
1863   // Clear the bundling information
1864   _bundle_instr_count = 0;
1865   _bundle_use.reset();
1866 
1867   memcpy(_bundle_use_elements,
1868          Pipeline_Use::elaborated_elements,
1869          sizeof(Pipeline_Use::elaborated_elements));
1870 }
1871 
1872 // Perform instruction scheduling and bundling over the sequence of
1873 // instructions in backwards order.
1874 void Compile::ScheduleAndBundle() {
1875 
1876   // Don&#39;t optimize this if it isn&#39;t a method
1877   if (!_method)
1878     return;
1879 
1880   // Don&#39;t optimize this if scheduling is disabled
1881   if (!do_scheduling())
1882     return;
1883 
1884   // Scheduling code works only with pairs (16 bytes) maximum.
1885   if (max_vector_size() &gt; 16)
1886     return;
1887 
1888   TracePhase tp(&quot;isched&quot;, &amp;timers[_t_instrSched]);
1889 
1890   // Create a data structure for all the scheduling information
1891   Scheduling scheduling(Thread::current()-&gt;resource_area(), *this);
1892 
1893   // Walk backwards over each basic block, computing the needed alignment
1894   // Walk over all the basic blocks
1895   scheduling.DoScheduling();
1896 
1897 #ifndef PRODUCT
1898   if (trace_opto_output()) {
1899     tty-&gt;print(&quot;\n---- After ScheduleAndBundle ----\n&quot;);
1900     for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {
1901       tty-&gt;print(&quot;\nBB#%03d:\n&quot;, i);
1902       Block* block = _cfg-&gt;get_block(i);
1903       for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {
1904         Node* n = block-&gt;get_node(j);
1905         OptoReg::Name reg = _regalloc-&gt;get_reg_first(n);
1906         tty-&gt;print(&quot; %-6s &quot;, reg &gt;= 0 &amp;&amp; reg &lt; REG_COUNT ? Matcher::regName[reg] : &quot;&quot;);
1907         n-&gt;dump();
1908       }
1909     }
1910   }
1911 #endif
1912 }
1913 
1914 // Compute the latency of all the instructions.  This is fairly simple,
1915 // because we already have a legal ordering.  Walk over the instructions
1916 // from first to last, and compute the latency of the instruction based
1917 // on the latency of the preceding instruction(s).
1918 void Scheduling::ComputeLocalLatenciesForward(const Block *bb) {
1919 #ifndef PRODUCT
1920   if (_cfg-&gt;C-&gt;trace_opto_output())
1921     tty-&gt;print(&quot;# -&gt; ComputeLocalLatenciesForward\n&quot;);
1922 #endif
1923 
1924   // Walk over all the schedulable instructions
1925   for( uint j=_bb_start; j &lt; _bb_end; j++ ) {
1926 
1927     // This is a kludge, forcing all latency calculations to start at 1.
1928     // Used to allow latency 0 to force an instruction to the beginning
1929     // of the bb
1930     uint latency = 1;
1931     Node *use = bb-&gt;get_node(j);
1932     uint nlen = use-&gt;len();
1933 
1934     // Walk over all the inputs
1935     for ( uint k=0; k &lt; nlen; k++ ) {
1936       Node *def = use-&gt;in(k);
1937       if (!def)
1938         continue;
1939 
1940       uint l = _node_latency[def-&gt;_idx] + use-&gt;latency(k);
1941       if (latency &lt; l)
1942         latency = l;
1943     }
1944 
1945     _node_latency[use-&gt;_idx] = latency;
1946 
1947 #ifndef PRODUCT
1948     if (_cfg-&gt;C-&gt;trace_opto_output()) {
1949       tty-&gt;print(&quot;# latency %4d: &quot;, latency);
1950       use-&gt;dump();
1951     }
1952 #endif
1953   }
1954 
1955 #ifndef PRODUCT
1956   if (_cfg-&gt;C-&gt;trace_opto_output())
1957     tty-&gt;print(&quot;# &lt;- ComputeLocalLatenciesForward\n&quot;);
1958 #endif
1959 
1960 } // end ComputeLocalLatenciesForward
1961 
1962 // See if this node fits into the present instruction bundle
1963 bool Scheduling::NodeFitsInBundle(Node *n) {
1964   uint n_idx = n-&gt;_idx;
1965 
1966   // If this is the unconditional delay instruction, then it fits
1967   if (n == _unconditional_delay_slot) {
1968 #ifndef PRODUCT
1969     if (_cfg-&gt;C-&gt;trace_opto_output())
1970       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: TRUE; is in unconditional delay slot\n&quot;, n-&gt;_idx);
1971 #endif
1972     return (true);
1973   }
1974 
1975   // If the node cannot be scheduled this cycle, skip it
1976   if (_current_latency[n_idx] &gt; _bundle_cycle_number) {
1977 #ifndef PRODUCT
1978     if (_cfg-&gt;C-&gt;trace_opto_output())
1979       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; latency %4d &gt; %d\n&quot;,
1980                  n-&gt;_idx, _current_latency[n_idx], _bundle_cycle_number);
1981 #endif
1982     return (false);
1983   }
1984 
1985   const Pipeline *node_pipeline = n-&gt;pipeline();
1986 
1987   uint instruction_count = node_pipeline-&gt;instructionCount();
1988   if (node_pipeline-&gt;mayHaveNoCode() &amp;&amp; n-&gt;size(_regalloc) == 0)
1989     instruction_count = 0;
1990   else if (node_pipeline-&gt;hasBranchDelay() &amp;&amp; !_unconditional_delay_slot)
1991     instruction_count++;
1992 
1993   if (_bundle_instr_count + instruction_count &gt; Pipeline::_max_instrs_per_cycle) {
1994 #ifndef PRODUCT
1995     if (_cfg-&gt;C-&gt;trace_opto_output())
1996       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; too many instructions: %d &gt; %d\n&quot;,
1997                  n-&gt;_idx, _bundle_instr_count + instruction_count, Pipeline::_max_instrs_per_cycle);
1998 #endif
1999     return (false);
2000   }
2001 
2002   // Don&#39;t allow non-machine nodes to be handled this way
2003   if (!n-&gt;is_Mach() &amp;&amp; instruction_count == 0)
2004     return (false);
2005 
2006   // See if there is any overlap
2007   uint delay = _bundle_use.full_latency(0, node_pipeline-&gt;resourceUse());
2008 
2009   if (delay &gt; 0) {
2010 #ifndef PRODUCT
2011     if (_cfg-&gt;C-&gt;trace_opto_output())
2012       tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]: FALSE; functional units overlap\n&quot;, n_idx);
2013 #endif
2014     return false;
2015   }
2016 
2017 #ifndef PRODUCT
2018   if (_cfg-&gt;C-&gt;trace_opto_output())
2019     tty-&gt;print(&quot;#     NodeFitsInBundle [%4d]:  TRUE\n&quot;, n_idx);
2020 #endif
2021 
2022   return true;
2023 }
2024 
2025 Node * Scheduling::ChooseNodeToBundle() {
2026   uint siz = _available.size();
2027 
2028   if (siz == 0) {
2029 
2030 #ifndef PRODUCT
2031     if (_cfg-&gt;C-&gt;trace_opto_output())
2032       tty-&gt;print(&quot;#   ChooseNodeToBundle: NULL\n&quot;);
2033 #endif
2034     return (NULL);
2035   }
2036 
2037   // Fast path, if only 1 instruction in the bundle
2038   if (siz == 1) {
2039 #ifndef PRODUCT
2040     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2041       tty-&gt;print(&quot;#   ChooseNodeToBundle (only 1): &quot;);
2042       _available[0]-&gt;dump();
2043     }
2044 #endif
2045     return (_available[0]);
2046   }
2047 
2048   // Don&#39;t bother, if the bundle is already full
2049   if (_bundle_instr_count &lt; Pipeline::_max_instrs_per_cycle) {
2050     for ( uint i = 0; i &lt; siz; i++ ) {
2051       Node *n = _available[i];
2052 
2053       // Skip projections, we&#39;ll handle them another way
2054       if (n-&gt;is_Proj())
2055         continue;
2056 
2057       // This presupposed that instructions are inserted into the
2058       // available list in a legality order; i.e. instructions that
2059       // must be inserted first are at the head of the list
2060       if (NodeFitsInBundle(n)) {
2061 #ifndef PRODUCT
2062         if (_cfg-&gt;C-&gt;trace_opto_output()) {
2063           tty-&gt;print(&quot;#   ChooseNodeToBundle: &quot;);
2064           n-&gt;dump();
2065         }
2066 #endif
2067         return (n);
2068       }
2069     }
2070   }
2071 
2072   // Nothing fits in this bundle, choose the highest priority
2073 #ifndef PRODUCT
2074   if (_cfg-&gt;C-&gt;trace_opto_output()) {
2075     tty-&gt;print(&quot;#   ChooseNodeToBundle: &quot;);
2076     _available[0]-&gt;dump();
2077   }
2078 #endif
2079 
2080   return _available[0];
2081 }
2082 
2083 void Scheduling::AddNodeToAvailableList(Node *n) {
2084   assert( !n-&gt;is_Proj(), &quot;projections never directly made available&quot; );
2085 #ifndef PRODUCT
2086   if (_cfg-&gt;C-&gt;trace_opto_output()) {
2087     tty-&gt;print(&quot;#   AddNodeToAvailableList: &quot;);
2088     n-&gt;dump();
2089   }
2090 #endif
2091 
2092   int latency = _current_latency[n-&gt;_idx];
2093 
2094   // Insert in latency order (insertion sort)
2095   uint i;
2096   for ( i=0; i &lt; _available.size(); i++ )
2097     if (_current_latency[_available[i]-&gt;_idx] &gt; latency)
2098       break;
2099 
2100   // Special Check for compares following branches
2101   if( n-&gt;is_Mach() &amp;&amp; _scheduled.size() &gt; 0 ) {
2102     int op = n-&gt;as_Mach()-&gt;ideal_Opcode();
2103     Node *last = _scheduled[0];
2104     if( last-&gt;is_MachIf() &amp;&amp; last-&gt;in(1) == n &amp;&amp;
2105         ( op == Op_CmpI ||
2106           op == Op_CmpU ||
2107           op == Op_CmpUL ||
2108           op == Op_CmpP ||
2109           op == Op_CmpF ||
2110           op == Op_CmpD ||
2111           op == Op_CmpL ) ) {
2112 
2113       // Recalculate position, moving to front of same latency
2114       for ( i=0 ; i &lt; _available.size(); i++ )
2115         if (_current_latency[_available[i]-&gt;_idx] &gt;= latency)
2116           break;
2117     }
2118   }
2119 
2120   // Insert the node in the available list
2121   _available.insert(i, n);
2122 
2123 #ifndef PRODUCT
2124   if (_cfg-&gt;C-&gt;trace_opto_output())
2125     dump_available();
2126 #endif
2127 }
2128 
2129 void Scheduling::DecrementUseCounts(Node *n, const Block *bb) {
2130   for ( uint i=0; i &lt; n-&gt;len(); i++ ) {
2131     Node *def = n-&gt;in(i);
2132     if (!def) continue;
2133     if( def-&gt;is_Proj() )        // If this is a machine projection, then
2134       def = def-&gt;in(0);         // propagate usage thru to the base instruction
2135 
2136     if(_cfg-&gt;get_block_for_node(def) != bb) { // Ignore if not block-local
2137       continue;
2138     }
2139 
2140     // Compute the latency
2141     uint l = _bundle_cycle_number + n-&gt;latency(i);
2142     if (_current_latency[def-&gt;_idx] &lt; l)
2143       _current_latency[def-&gt;_idx] = l;
2144 
2145     // If this does not have uses then schedule it
2146     if ((--_uses[def-&gt;_idx]) == 0)
2147       AddNodeToAvailableList(def);
2148   }
2149 }
2150 
2151 void Scheduling::AddNodeToBundle(Node *n, const Block *bb) {
2152 #ifndef PRODUCT
2153   if (_cfg-&gt;C-&gt;trace_opto_output()) {
2154     tty-&gt;print(&quot;#   AddNodeToBundle: &quot;);
2155     n-&gt;dump();
2156   }
2157 #endif
2158 
2159   // Remove this from the available list
2160   uint i;
2161   for (i = 0; i &lt; _available.size(); i++)
2162     if (_available[i] == n)
2163       break;
2164   assert(i &lt; _available.size(), &quot;entry in _available list not found&quot;);
2165   _available.remove(i);
2166 
2167   // See if this fits in the current bundle
2168   const Pipeline *node_pipeline = n-&gt;pipeline();
2169   const Pipeline_Use&amp; node_usage = node_pipeline-&gt;resourceUse();
2170 
2171   // Check for instructions to be placed in the delay slot. We
2172   // do this before we actually schedule the current instruction,
2173   // because the delay slot follows the current instruction.
2174   if (Pipeline::_branch_has_delay_slot &amp;&amp;
2175       node_pipeline-&gt;hasBranchDelay() &amp;&amp;
2176       !_unconditional_delay_slot) {
2177 
2178     uint siz = _available.size();
2179 
2180     // Conditional branches can support an instruction that
2181     // is unconditionally executed and not dependent by the
2182     // branch, OR a conditionally executed instruction if
2183     // the branch is taken.  In practice, this means that
2184     // the first instruction at the branch target is
2185     // copied to the delay slot, and the branch goes to
2186     // the instruction after that at the branch target
2187     if ( n-&gt;is_MachBranch() ) {
2188 
2189       assert( !n-&gt;is_MachNullCheck(), &quot;should not look for delay slot for Null Check&quot; );
2190       assert( !n-&gt;is_Catch(),         &quot;should not look for delay slot for Catch&quot; );
2191 
2192 #ifndef PRODUCT
2193       _branches++;
2194 #endif
2195 
2196       // At least 1 instruction is on the available list
2197       // that is not dependent on the branch
2198       for (uint i = 0; i &lt; siz; i++) {
2199         Node *d = _available[i];
2200         const Pipeline *avail_pipeline = d-&gt;pipeline();
2201 
2202         // Don&#39;t allow safepoints in the branch shadow, that will
2203         // cause a number of difficulties
2204         if ( avail_pipeline-&gt;instructionCount() == 1 &amp;&amp;
2205              !avail_pipeline-&gt;hasMultipleBundles() &amp;&amp;
2206              !avail_pipeline-&gt;hasBranchDelay() &amp;&amp;
2207              Pipeline::instr_has_unit_size() &amp;&amp;
2208              d-&gt;size(_regalloc) == Pipeline::instr_unit_size() &amp;&amp;
2209              NodeFitsInBundle(d) &amp;&amp;
2210              !node_bundling(d)-&gt;used_in_delay()) {
2211 
2212           if (d-&gt;is_Mach() &amp;&amp; !d-&gt;is_MachSafePoint()) {
2213             // A node that fits in the delay slot was found, so we need to
2214             // set the appropriate bits in the bundle pipeline information so
2215             // that it correctly indicates resource usage.  Later, when we
2216             // attempt to add this instruction to the bundle, we will skip
2217             // setting the resource usage.
2218             _unconditional_delay_slot = d;
2219             node_bundling(n)-&gt;set_use_unconditional_delay();
2220             node_bundling(d)-&gt;set_used_in_unconditional_delay();
2221             _bundle_use.add_usage(avail_pipeline-&gt;resourceUse());
2222             _current_latency[d-&gt;_idx] = _bundle_cycle_number;
2223             _next_node = d;
2224             ++_bundle_instr_count;
2225 #ifndef PRODUCT
2226             _unconditional_delays++;
2227 #endif
2228             break;
2229           }
2230         }
2231       }
2232     }
2233 
2234     // No delay slot, add a nop to the usage
2235     if (!_unconditional_delay_slot) {
2236       // See if adding an instruction in the delay slot will overflow
2237       // the bundle.
2238       if (!NodeFitsInBundle(_nop)) {
2239 #ifndef PRODUCT
2240         if (_cfg-&gt;C-&gt;trace_opto_output())
2241           tty-&gt;print(&quot;#  *** STEP(1 instruction for delay slot) ***\n&quot;);
2242 #endif
2243         step(1);
2244       }
2245 
2246       _bundle_use.add_usage(_nop-&gt;pipeline()-&gt;resourceUse());
2247       _next_node = _nop;
2248       ++_bundle_instr_count;
2249     }
2250 
2251     // See if the instruction in the delay slot requires a
2252     // step of the bundles
2253     if (!NodeFitsInBundle(n)) {
2254 #ifndef PRODUCT
2255       if (_cfg-&gt;C-&gt;trace_opto_output())
2256         tty-&gt;print(&quot;#  *** STEP(branch won&#39;t fit) ***\n&quot;);
2257 #endif
2258       // Update the state information
2259       _bundle_instr_count = 0;
2260       _bundle_cycle_number += 1;
2261       _bundle_use.step(1);
2262     }
2263   }
2264 
2265   // Get the number of instructions
2266   uint instruction_count = node_pipeline-&gt;instructionCount();
2267   if (node_pipeline-&gt;mayHaveNoCode() &amp;&amp; n-&gt;size(_regalloc) == 0)
2268     instruction_count = 0;
2269 
2270   // Compute the latency information
2271   uint delay = 0;
2272 
2273   if (instruction_count &gt; 0 || !node_pipeline-&gt;mayHaveNoCode()) {
2274     int relative_latency = _current_latency[n-&gt;_idx] - _bundle_cycle_number;
2275     if (relative_latency &lt; 0)
2276       relative_latency = 0;
2277 
2278     delay = _bundle_use.full_latency(relative_latency, node_usage);
2279 
2280     // Does not fit in this bundle, start a new one
2281     if (delay &gt; 0) {
2282       step(delay);
2283 
2284 #ifndef PRODUCT
2285       if (_cfg-&gt;C-&gt;trace_opto_output())
2286         tty-&gt;print(&quot;#  *** STEP(%d) ***\n&quot;, delay);
2287 #endif
2288     }
2289   }
2290 
2291   // If this was placed in the delay slot, ignore it
2292   if (n != _unconditional_delay_slot) {
2293 
2294     if (delay == 0) {
2295       if (node_pipeline-&gt;hasMultipleBundles()) {
2296 #ifndef PRODUCT
2297         if (_cfg-&gt;C-&gt;trace_opto_output())
2298           tty-&gt;print(&quot;#  *** STEP(multiple instructions) ***\n&quot;);
2299 #endif
2300         step(1);
2301       }
2302 
2303       else if (instruction_count + _bundle_instr_count &gt; Pipeline::_max_instrs_per_cycle) {
2304 #ifndef PRODUCT
2305         if (_cfg-&gt;C-&gt;trace_opto_output())
2306           tty-&gt;print(&quot;#  *** STEP(%d &gt;= %d instructions) ***\n&quot;,
2307                      instruction_count + _bundle_instr_count,
2308                      Pipeline::_max_instrs_per_cycle);
2309 #endif
2310         step(1);
2311       }
2312     }
2313 
2314     if (node_pipeline-&gt;hasBranchDelay() &amp;&amp; !_unconditional_delay_slot)
2315       _bundle_instr_count++;
2316 
2317     // Set the node&#39;s latency
2318     _current_latency[n-&gt;_idx] = _bundle_cycle_number;
2319 
2320     // Now merge the functional unit information
2321     if (instruction_count &gt; 0 || !node_pipeline-&gt;mayHaveNoCode())
2322       _bundle_use.add_usage(node_usage);
2323 
2324     // Increment the number of instructions in this bundle
2325     _bundle_instr_count += instruction_count;
2326 
2327     // Remember this node for later
2328     if (n-&gt;is_Mach())
2329       _next_node = n;
2330   }
2331 
2332   // It&#39;s possible to have a BoxLock in the graph and in the _bbs mapping but
2333   // not in the bb-&gt;_nodes array.  This happens for debug-info-only BoxLocks.
2334   // &#39;Schedule&#39; them (basically ignore in the schedule) but do not insert them
2335   // into the block.  All other scheduled nodes get put in the schedule here.
2336   int op = n-&gt;Opcode();
2337   if( (op == Op_Node &amp;&amp; n-&gt;req() == 0) || // anti-dependence node OR
2338       (op != Op_Node &amp;&amp;         // Not an unused antidepedence node and
2339        // not an unallocated boxlock
2340        (OptoReg::is_valid(_regalloc-&gt;get_reg_first(n)) || op != Op_BoxLock)) ) {
2341 
2342     // Push any trailing projections
2343     if( bb-&gt;get_node(bb-&gt;number_of_nodes()-1) != n ) {
2344       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2345         Node *foi = n-&gt;fast_out(i);
2346         if( foi-&gt;is_Proj() )
2347           _scheduled.push(foi);
2348       }
2349     }
2350 
2351     // Put the instruction in the schedule list
2352     _scheduled.push(n);
2353   }
2354 
2355 #ifndef PRODUCT
2356   if (_cfg-&gt;C-&gt;trace_opto_output())
2357     dump_available();
2358 #endif
2359 
2360   // Walk all the definitions, decrementing use counts, and
2361   // if a definition has a 0 use count, place it in the available list.
2362   DecrementUseCounts(n,bb);
2363 }
2364 
2365 // This method sets the use count within a basic block.  We will ignore all
2366 // uses outside the current basic block.  As we are doing a backwards walk,
2367 // any node we reach that has a use count of 0 may be scheduled.  This also
2368 // avoids the problem of cyclic references from phi nodes, as long as phi
2369 // nodes are at the front of the basic block.  This method also initializes
2370 // the available list to the set of instructions that have no uses within this
2371 // basic block.
2372 void Scheduling::ComputeUseCount(const Block *bb) {
2373 #ifndef PRODUCT
2374   if (_cfg-&gt;C-&gt;trace_opto_output())
2375     tty-&gt;print(&quot;# -&gt; ComputeUseCount\n&quot;);
2376 #endif
2377 
2378   // Clear the list of available and scheduled instructions, just in case
2379   _available.clear();
2380   _scheduled.clear();
2381 
2382   // No delay slot specified
2383   _unconditional_delay_slot = NULL;
2384 
2385 #ifdef ASSERT
2386   for( uint i=0; i &lt; bb-&gt;number_of_nodes(); i++ )
2387     assert( _uses[bb-&gt;get_node(i)-&gt;_idx] == 0, &quot;_use array not clean&quot; );
2388 #endif
2389 
2390   // Force the _uses count to never go to zero for unscheduable pieces
2391   // of the block
2392   for( uint k = 0; k &lt; _bb_start; k++ )
2393     _uses[bb-&gt;get_node(k)-&gt;_idx] = 1;
2394   for( uint l = _bb_end; l &lt; bb-&gt;number_of_nodes(); l++ )
2395     _uses[bb-&gt;get_node(l)-&gt;_idx] = 1;
2396 
2397   // Iterate backwards over the instructions in the block.  Don&#39;t count the
2398   // branch projections at end or the block header instructions.
2399   for( uint j = _bb_end-1; j &gt;= _bb_start; j-- ) {
2400     Node *n = bb-&gt;get_node(j);
2401     if( n-&gt;is_Proj() ) continue; // Projections handled another way
2402 
2403     // Account for all uses
2404     for ( uint k = 0; k &lt; n-&gt;len(); k++ ) {
2405       Node *inp = n-&gt;in(k);
2406       if (!inp) continue;
2407       assert(inp != n, &quot;no cycles allowed&quot; );
2408       if (_cfg-&gt;get_block_for_node(inp) == bb) { // Block-local use?
2409         if (inp-&gt;is_Proj()) { // Skip through Proj&#39;s
2410           inp = inp-&gt;in(0);
2411         }
2412         ++_uses[inp-&gt;_idx];     // Count 1 block-local use
2413       }
2414     }
2415 
2416     // If this instruction has a 0 use count, then it is available
2417     if (!_uses[n-&gt;_idx]) {
2418       _current_latency[n-&gt;_idx] = _bundle_cycle_number;
2419       AddNodeToAvailableList(n);
2420     }
2421 
2422 #ifndef PRODUCT
2423     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2424       tty-&gt;print(&quot;#   uses: %3d: &quot;, _uses[n-&gt;_idx]);
2425       n-&gt;dump();
2426     }
2427 #endif
2428   }
2429 
2430 #ifndef PRODUCT
2431   if (_cfg-&gt;C-&gt;trace_opto_output())
2432     tty-&gt;print(&quot;# &lt;- ComputeUseCount\n&quot;);
2433 #endif
2434 }
2435 
2436 // This routine performs scheduling on each basic block in reverse order,
2437 // using instruction latencies and taking into account function unit
2438 // availability.
2439 void Scheduling::DoScheduling() {
2440 #ifndef PRODUCT
2441   if (_cfg-&gt;C-&gt;trace_opto_output())
2442     tty-&gt;print(&quot;# -&gt; DoScheduling\n&quot;);
2443 #endif
2444 
2445   Block *succ_bb = NULL;
2446   Block *bb;
2447 
2448   // Walk over all the basic blocks in reverse order
2449   for (int i = _cfg-&gt;number_of_blocks() - 1; i &gt;= 0; succ_bb = bb, i--) {
2450     bb = _cfg-&gt;get_block(i);
2451 
2452 #ifndef PRODUCT
2453     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2454       tty-&gt;print(&quot;#  Schedule BB#%03d (initial)\n&quot;, i);
2455       for (uint j = 0; j &lt; bb-&gt;number_of_nodes(); j++) {
2456         bb-&gt;get_node(j)-&gt;dump();
2457       }
2458     }
2459 #endif
2460 
2461     // On the head node, skip processing
2462     if (bb == _cfg-&gt;get_root_block()) {
2463       continue;
2464     }
2465 
2466     // Skip empty, connector blocks
2467     if (bb-&gt;is_connector())
2468       continue;
2469 
2470     // If the following block is not the sole successor of
2471     // this one, then reset the pipeline information
2472     if (bb-&gt;_num_succs != 1 || bb-&gt;non_connector_successor(0) != succ_bb) {
2473 #ifndef PRODUCT
2474       if (_cfg-&gt;C-&gt;trace_opto_output()) {
2475         tty-&gt;print(&quot;*** bundle start of next BB, node %d, for %d instructions\n&quot;,
2476                    _next_node-&gt;_idx, _bundle_instr_count);
2477       }
2478 #endif
2479       step_and_clear();
2480     }
2481 
2482     // Leave untouched the starting instruction, any Phis, a CreateEx node
2483     // or Top.  bb-&gt;get_node(_bb_start) is the first schedulable instruction.
2484     _bb_end = bb-&gt;number_of_nodes()-1;
2485     for( _bb_start=1; _bb_start &lt;= _bb_end; _bb_start++ ) {
2486       Node *n = bb-&gt;get_node(_bb_start);
2487       // Things not matched, like Phinodes and ProjNodes don&#39;t get scheduled.
2488       // Also, MachIdealNodes do not get scheduled
2489       if( !n-&gt;is_Mach() ) continue;     // Skip non-machine nodes
2490       MachNode *mach = n-&gt;as_Mach();
2491       int iop = mach-&gt;ideal_Opcode();
2492       if( iop == Op_CreateEx ) continue; // CreateEx is pinned
2493       if( iop == Op_Con ) continue;      // Do not schedule Top
2494       if( iop == Op_Node &amp;&amp;     // Do not schedule PhiNodes, ProjNodes
2495           mach-&gt;pipeline() == MachNode::pipeline_class() &amp;&amp;
2496           !n-&gt;is_SpillCopy() &amp;&amp; !n-&gt;is_MachMerge() )  // Breakpoints, Prolog, etc
2497         continue;
2498       break;                    // Funny loop structure to be sure...
2499     }
2500     // Compute last &quot;interesting&quot; instruction in block - last instruction we
2501     // might schedule.  _bb_end points just after last schedulable inst.  We
2502     // normally schedule conditional branches (despite them being forced last
2503     // in the block), because they have delay slots we can fill.  Calls all
2504     // have their delay slots filled in the template expansions, so we don&#39;t
2505     // bother scheduling them.
2506     Node *last = bb-&gt;get_node(_bb_end);
2507     // Ignore trailing NOPs.
2508     while (_bb_end &gt; 0 &amp;&amp; last-&gt;is_Mach() &amp;&amp;
2509            last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Con) {
2510       last = bb-&gt;get_node(--_bb_end);
2511     }
2512     assert(!last-&gt;is_Mach() || last-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con, &quot;&quot;);
2513     if( last-&gt;is_Catch() ||
2514         (last-&gt;is_Mach() &amp;&amp; last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Halt) ) {
2515       // There might be a prior call.  Skip it.
2516       while (_bb_start &lt; _bb_end &amp;&amp; bb-&gt;get_node(--_bb_end)-&gt;is_MachProj());
2517     } else if( last-&gt;is_MachNullCheck() ) {
2518       // Backup so the last null-checked memory instruction is
2519       // outside the schedulable range. Skip over the nullcheck,
2520       // projection, and the memory nodes.
2521       Node *mem = last-&gt;in(1);
2522       do {
2523         _bb_end--;
2524       } while (mem != bb-&gt;get_node(_bb_end));
2525     } else {
2526       // Set _bb_end to point after last schedulable inst.
2527       _bb_end++;
2528     }
2529 
2530     assert( _bb_start &lt;= _bb_end, &quot;inverted block ends&quot; );
2531 
2532     // Compute the register antidependencies for the basic block
2533     ComputeRegisterAntidependencies(bb);
2534     if (_cfg-&gt;C-&gt;failing())  return;  // too many D-U pinch points
2535 
2536     // Compute intra-bb latencies for the nodes
2537     ComputeLocalLatenciesForward(bb);
2538 
2539     // Compute the usage within the block, and set the list of all nodes
2540     // in the block that have no uses within the block.
2541     ComputeUseCount(bb);
2542 
2543     // Schedule the remaining instructions in the block
2544     while ( _available.size() &gt; 0 ) {
2545       Node *n = ChooseNodeToBundle();
2546       guarantee(n != NULL, &quot;no nodes available&quot;);
2547       AddNodeToBundle(n,bb);
2548     }
2549 
2550     assert( _scheduled.size() == _bb_end - _bb_start, &quot;wrong number of instructions&quot; );
2551 #ifdef ASSERT
2552     for( uint l = _bb_start; l &lt; _bb_end; l++ ) {
2553       Node *n = bb-&gt;get_node(l);
2554       uint m;
2555       for( m = 0; m &lt; _bb_end-_bb_start; m++ )
2556         if( _scheduled[m] == n )
2557           break;
2558       assert( m &lt; _bb_end-_bb_start, &quot;instruction missing in schedule&quot; );
2559     }
2560 #endif
2561 
2562     // Now copy the instructions (in reverse order) back to the block
2563     for ( uint k = _bb_start; k &lt; _bb_end; k++ )
2564       bb-&gt;map_node(_scheduled[_bb_end-k-1], k);
2565 
2566 #ifndef PRODUCT
2567     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2568       tty-&gt;print(&quot;#  Schedule BB#%03d (final)\n&quot;, i);
2569       uint current = 0;
2570       for (uint j = 0; j &lt; bb-&gt;number_of_nodes(); j++) {
2571         Node *n = bb-&gt;get_node(j);
2572         if( valid_bundle_info(n) ) {
2573           Bundle *bundle = node_bundling(n);
2574           if (bundle-&gt;instr_count() &gt; 0 || bundle-&gt;flags() &gt; 0) {
2575             tty-&gt;print(&quot;*** Bundle: &quot;);
2576             bundle-&gt;dump();
2577           }
2578           n-&gt;dump();
2579         }
2580       }
2581     }
2582 #endif
2583 #ifdef ASSERT
2584     verify_good_schedule(bb,&quot;after block local scheduling&quot;);
2585 #endif
2586   }
2587 
2588 #ifndef PRODUCT
2589   if (_cfg-&gt;C-&gt;trace_opto_output())
2590     tty-&gt;print(&quot;# &lt;- DoScheduling\n&quot;);
2591 #endif
2592 
2593   // Record final node-bundling array location
2594   _regalloc-&gt;C-&gt;set_node_bundling_base(_node_bundling_base);
2595 
2596 } // end DoScheduling
2597 
2598 // Verify that no live-range used in the block is killed in the block by a
2599 // wrong DEF.  This doesn&#39;t verify live-ranges that span blocks.
2600 
2601 // Check for edge existence.  Used to avoid adding redundant precedence edges.
2602 static bool edge_from_to( Node *from, Node *to ) {
2603   for( uint i=0; i&lt;from-&gt;len(); i++ )
2604     if( from-&gt;in(i) == to )
2605       return true;
2606   return false;
2607 }
2608 
2609 #ifdef ASSERT
2610 void Scheduling::verify_do_def( Node *n, OptoReg::Name def, const char *msg ) {
2611   // Check for bad kills
2612   if( OptoReg::is_valid(def) ) { // Ignore stores &amp; control flow
2613     Node *prior_use = _reg_node[def];
2614     if( prior_use &amp;&amp; !edge_from_to(prior_use,n) ) {
2615       tty-&gt;print(&quot;%s = &quot;,OptoReg::as_VMReg(def)-&gt;name());
2616       n-&gt;dump();
2617       tty-&gt;print_cr(&quot;...&quot;);
2618       prior_use-&gt;dump();
2619       assert(edge_from_to(prior_use,n), &quot;%s&quot;, msg);
2620     }
2621     _reg_node.map(def,NULL); // Kill live USEs
2622   }
2623 }
2624 
2625 void Scheduling::verify_good_schedule( Block *b, const char *msg ) {
2626 
2627   // Zap to something reasonable for the verify code
2628   _reg_node.clear();
2629 
2630   // Walk over the block backwards.  Check to make sure each DEF doesn&#39;t
2631   // kill a live value (other than the one it&#39;s supposed to).  Add each
2632   // USE to the live set.
2633   for( uint i = b-&gt;number_of_nodes()-1; i &gt;= _bb_start; i-- ) {
2634     Node *n = b-&gt;get_node(i);
2635     int n_op = n-&gt;Opcode();
2636     if( n_op == Op_MachProj &amp;&amp; n-&gt;ideal_reg() == MachProjNode::fat_proj ) {
2637       // Fat-proj kills a slew of registers
2638       RegMask rm = n-&gt;out_RegMask();// Make local copy
2639       while( rm.is_NotEmpty() ) {
2640         OptoReg::Name kill = rm.find_first_elem();
2641         rm.Remove(kill);
2642         verify_do_def( n, kill, msg );
2643       }
2644     } else if( n_op != Op_Node ) { // Avoid brand new antidependence nodes
2645       // Get DEF&#39;d registers the normal way
2646       verify_do_def( n, _regalloc-&gt;get_reg_first(n), msg );
2647       verify_do_def( n, _regalloc-&gt;get_reg_second(n), msg );
2648     }
2649 
2650     // Now make all USEs live
2651     for( uint i=1; i&lt;n-&gt;req(); i++ ) {
2652       Node *def = n-&gt;in(i);
2653       assert(def != 0, &quot;input edge required&quot;);
2654       OptoReg::Name reg_lo = _regalloc-&gt;get_reg_first(def);
2655       OptoReg::Name reg_hi = _regalloc-&gt;get_reg_second(def);
2656       if( OptoReg::is_valid(reg_lo) ) {
2657         assert(!_reg_node[reg_lo] || edge_from_to(_reg_node[reg_lo],def), &quot;%s&quot;, msg);
2658         _reg_node.map(reg_lo,n);
2659       }
2660       if( OptoReg::is_valid(reg_hi) ) {
2661         assert(!_reg_node[reg_hi] || edge_from_to(_reg_node[reg_hi],def), &quot;%s&quot;, msg);
2662         _reg_node.map(reg_hi,n);
2663       }
2664     }
2665 
2666   }
2667 
2668   // Zap to something reasonable for the Antidependence code
2669   _reg_node.clear();
2670 }
2671 #endif
2672 
2673 // Conditionally add precedence edges.  Avoid putting edges on Projs.
2674 static void add_prec_edge_from_to( Node *from, Node *to ) {
2675   if( from-&gt;is_Proj() ) {       // Put precedence edge on Proj&#39;s input
2676     assert( from-&gt;req() == 1 &amp;&amp; (from-&gt;len() == 1 || from-&gt;in(1)==0), &quot;no precedence edges on projections&quot; );
2677     from = from-&gt;in(0);
2678   }
2679   if( from != to &amp;&amp;             // No cycles (for things like LD L0,[L0+4] )
2680       !edge_from_to( from, to ) ) // Avoid duplicate edge
2681     from-&gt;add_prec(to);
2682 }
2683 
2684 void Scheduling::anti_do_def( Block *b, Node *def, OptoReg::Name def_reg, int is_def ) {
2685   if( !OptoReg::is_valid(def_reg) ) // Ignore stores &amp; control flow
2686     return;
2687 
2688   Node *pinch = _reg_node[def_reg]; // Get pinch point
2689   if ((pinch == NULL) || _cfg-&gt;get_block_for_node(pinch) != b || // No pinch-point yet?
2690       is_def ) {    // Check for a true def (not a kill)
2691     _reg_node.map(def_reg,def); // Record def/kill as the optimistic pinch-point
2692     return;
2693   }
2694 
2695   Node *kill = def;             // Rename &#39;def&#39; to more descriptive &#39;kill&#39;
2696   debug_only( def = (Node*)((intptr_t)0xdeadbeef); )
2697 
2698   // After some number of kills there _may_ be a later def
2699   Node *later_def = NULL;
2700 
2701   // Finding a kill requires a real pinch-point.
2702   // Check for not already having a pinch-point.
2703   // Pinch points are Op_Node&#39;s.
2704   if( pinch-&gt;Opcode() != Op_Node ) { // Or later-def/kill as pinch-point?
2705     later_def = pinch;            // Must be def/kill as optimistic pinch-point
2706     if ( _pinch_free_list.size() &gt; 0) {
2707       pinch = _pinch_free_list.pop();
2708     } else {
2709       pinch = new Node(1); // Pinch point to-be
2710     }
2711     if (pinch-&gt;_idx &gt;= _regalloc-&gt;node_regs_max_index()) {
2712       _cfg-&gt;C-&gt;record_method_not_compilable(&quot;too many D-U pinch points&quot;);
2713       return;
2714     }
2715     _cfg-&gt;map_node_to_block(pinch, b);      // Pretend it&#39;s valid in this block (lazy init)
2716     _reg_node.map(def_reg,pinch); // Record pinch-point
2717     //_regalloc-&gt;set_bad(pinch-&gt;_idx); // Already initialized this way.
2718     if( later_def-&gt;outcnt() == 0 || later_def-&gt;ideal_reg() == MachProjNode::fat_proj ) { // Distinguish def from kill
2719       pinch-&gt;init_req(0, _cfg-&gt;C-&gt;top());     // set not NULL for the next call
2720       add_prec_edge_from_to(later_def,pinch); // Add edge from kill to pinch
2721       later_def = NULL;           // and no later def
2722     }
2723     pinch-&gt;set_req(0,later_def);  // Hook later def so we can find it
2724   } else {                        // Else have valid pinch point
2725     if( pinch-&gt;in(0) )            // If there is a later-def
2726       later_def = pinch-&gt;in(0);   // Get it
2727   }
2728 
2729   // Add output-dependence edge from later def to kill
2730   if( later_def )               // If there is some original def
2731     add_prec_edge_from_to(later_def,kill); // Add edge from def to kill
2732 
2733   // See if current kill is also a use, and so is forced to be the pinch-point.
2734   if( pinch-&gt;Opcode() == Op_Node ) {
2735     Node *uses = kill-&gt;is_Proj() ? kill-&gt;in(0) : kill;
2736     for( uint i=1; i&lt;uses-&gt;req(); i++ ) {
2737       if( _regalloc-&gt;get_reg_first(uses-&gt;in(i)) == def_reg ||
2738           _regalloc-&gt;get_reg_second(uses-&gt;in(i)) == def_reg ) {
2739         // Yes, found a use/kill pinch-point
2740         pinch-&gt;set_req(0,NULL);  //
2741         pinch-&gt;replace_by(kill); // Move anti-dep edges up
2742         pinch = kill;
2743         _reg_node.map(def_reg,pinch);
2744         return;
2745       }
2746     }
2747   }
2748 
2749   // Add edge from kill to pinch-point
2750   add_prec_edge_from_to(kill,pinch);
2751 }
2752 
2753 void Scheduling::anti_do_use( Block *b, Node *use, OptoReg::Name use_reg ) {
2754   if( !OptoReg::is_valid(use_reg) ) // Ignore stores &amp; control flow
2755     return;
2756   Node *pinch = _reg_node[use_reg]; // Get pinch point
2757   // Check for no later def_reg/kill in block
2758   if ((pinch != NULL) &amp;&amp; _cfg-&gt;get_block_for_node(pinch) == b &amp;&amp;
2759       // Use has to be block-local as well
2760       _cfg-&gt;get_block_for_node(use) == b) {
2761     if( pinch-&gt;Opcode() == Op_Node &amp;&amp; // Real pinch-point (not optimistic?)
2762         pinch-&gt;req() == 1 ) {   // pinch not yet in block?
2763       pinch-&gt;del_req(0);        // yank pointer to later-def, also set flag
2764       // Insert the pinch-point in the block just after the last use
2765       b-&gt;insert_node(pinch, b-&gt;find_node(use) + 1);
2766       _bb_end++;                // Increase size scheduled region in block
2767     }
2768 
2769     add_prec_edge_from_to(pinch,use);
2770   }
2771 }
2772 
2773 // We insert antidependences between the reads and following write of
2774 // allocated registers to prevent illegal code motion. Hopefully, the
2775 // number of added references should be fairly small, especially as we
2776 // are only adding references within the current basic block.
2777 void Scheduling::ComputeRegisterAntidependencies(Block *b) {
2778 
2779 #ifdef ASSERT
2780   verify_good_schedule(b,&quot;before block local scheduling&quot;);
2781 #endif
2782 
2783   // A valid schedule, for each register independently, is an endless cycle
2784   // of: a def, then some uses (connected to the def by true dependencies),
2785   // then some kills (defs with no uses), finally the cycle repeats with a new
2786   // def.  The uses are allowed to float relative to each other, as are the
2787   // kills.  No use is allowed to slide past a kill (or def).  This requires
2788   // antidependencies between all uses of a single def and all kills that
2789   // follow, up to the next def.  More edges are redundant, because later defs
2790   // &amp; kills are already serialized with true or antidependencies.  To keep
2791   // the edge count down, we add a &#39;pinch point&#39; node if there&#39;s more than
2792   // one use or more than one kill/def.
2793 
2794   // We add dependencies in one bottom-up pass.
2795 
2796   // For each instruction we handle it&#39;s DEFs/KILLs, then it&#39;s USEs.
2797 
2798   // For each DEF/KILL, we check to see if there&#39;s a prior DEF/KILL for this
2799   // register.  If not, we record the DEF/KILL in _reg_node, the
2800   // register-to-def mapping.  If there is a prior DEF/KILL, we insert a
2801   // &quot;pinch point&quot;, a new Node that&#39;s in the graph but not in the block.
2802   // We put edges from the prior and current DEF/KILLs to the pinch point.
2803   // We put the pinch point in _reg_node.  If there&#39;s already a pinch point
2804   // we merely add an edge from the current DEF/KILL to the pinch point.
2805 
2806   // After doing the DEF/KILLs, we handle USEs.  For each used register, we
2807   // put an edge from the pinch point to the USE.
2808 
2809   // To be expedient, the _reg_node array is pre-allocated for the whole
2810   // compilation.  _reg_node is lazily initialized; it either contains a NULL,
2811   // or a valid def/kill/pinch-point, or a leftover node from some prior
2812   // block.  Leftover node from some prior block is treated like a NULL (no
2813   // prior def, so no anti-dependence needed).  Valid def is distinguished by
2814   // it being in the current block.
2815   bool fat_proj_seen = false;
2816   uint last_safept = _bb_end-1;
2817   Node* end_node         = (_bb_end-1 &gt;= _bb_start) ? b-&gt;get_node(last_safept) : NULL;
2818   Node* last_safept_node = end_node;
2819   for( uint i = _bb_end-1; i &gt;= _bb_start; i-- ) {
2820     Node *n = b-&gt;get_node(i);
2821     int is_def = n-&gt;outcnt();   // def if some uses prior to adding precedence edges
2822     if( n-&gt;is_MachProj() &amp;&amp; n-&gt;ideal_reg() == MachProjNode::fat_proj ) {
2823       // Fat-proj kills a slew of registers
2824       // This can add edges to &#39;n&#39; and obscure whether or not it was a def,
2825       // hence the is_def flag.
2826       fat_proj_seen = true;
2827       RegMask rm = n-&gt;out_RegMask();// Make local copy
2828       while( rm.is_NotEmpty() ) {
2829         OptoReg::Name kill = rm.find_first_elem();
2830         rm.Remove(kill);
2831         anti_do_def( b, n, kill, is_def );
2832       }
2833     } else {
2834       // Get DEF&#39;d registers the normal way
2835       anti_do_def( b, n, _regalloc-&gt;get_reg_first(n), is_def );
2836       anti_do_def( b, n, _regalloc-&gt;get_reg_second(n), is_def );
2837     }
2838 
2839     // Kill projections on a branch should appear to occur on the
2840     // branch, not afterwards, so grab the masks from the projections
2841     // and process them.
2842     if (n-&gt;is_MachBranch() || (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Jump)) {
2843       for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {
2844         Node* use = n-&gt;fast_out(i);
2845         if (use-&gt;is_Proj()) {
2846           RegMask rm = use-&gt;out_RegMask();// Make local copy
2847           while( rm.is_NotEmpty() ) {
2848             OptoReg::Name kill = rm.find_first_elem();
2849             rm.Remove(kill);
2850             anti_do_def( b, n, kill, false );
2851           }
2852         }
2853       }
2854     }
2855 
2856     // Check each register used by this instruction for a following DEF/KILL
2857     // that must occur afterward and requires an anti-dependence edge.
2858     for( uint j=0; j&lt;n-&gt;req(); j++ ) {
2859       Node *def = n-&gt;in(j);
2860       if( def ) {
2861         assert( !def-&gt;is_MachProj() || def-&gt;ideal_reg() != MachProjNode::fat_proj, &quot;&quot; );
2862         anti_do_use( b, n, _regalloc-&gt;get_reg_first(def) );
2863         anti_do_use( b, n, _regalloc-&gt;get_reg_second(def) );
2864       }
2865     }
2866     // Do not allow defs of new derived values to float above GC
2867     // points unless the base is definitely available at the GC point.
2868 
2869     Node *m = b-&gt;get_node(i);
2870 
2871     // Add precedence edge from following safepoint to use of derived pointer
2872     if( last_safept_node != end_node &amp;&amp;
2873         m != last_safept_node) {
2874       for (uint k = 1; k &lt; m-&gt;req(); k++) {
2875         const Type *t = m-&gt;in(k)-&gt;bottom_type();
2876         if( t-&gt;isa_oop_ptr() &amp;&amp;
2877             t-&gt;is_ptr()-&gt;offset() != 0 ) {
2878           last_safept_node-&gt;add_prec( m );
2879           break;
2880         }
2881       }
2882     }
2883 
2884     if( n-&gt;jvms() ) {           // Precedence edge from derived to safept
2885       // Check if last_safept_node was moved by pinch-point insertion in anti_do_use()
2886       if( b-&gt;get_node(last_safept) != last_safept_node ) {
2887         last_safept = b-&gt;find_node(last_safept_node);
2888       }
2889       for( uint j=last_safept; j &gt; i; j-- ) {
2890         Node *mach = b-&gt;get_node(j);
2891         if( mach-&gt;is_Mach() &amp;&amp; mach-&gt;as_Mach()-&gt;ideal_Opcode() == Op_AddP )
2892           mach-&gt;add_prec( n );
2893       }
2894       last_safept = i;
2895       last_safept_node = m;
2896     }
2897   }
2898 
2899   if (fat_proj_seen) {
2900     // Garbage collect pinch nodes that were not consumed.
2901     // They are usually created by a fat kill MachProj for a call.
2902     garbage_collect_pinch_nodes();
2903   }
2904 }
2905 
2906 // Garbage collect pinch nodes for reuse by other blocks.
2907 //
2908 // The block scheduler&#39;s insertion of anti-dependence
2909 // edges creates many pinch nodes when the block contains
2910 // 2 or more Calls.  A pinch node is used to prevent a
2911 // combinatorial explosion of edges.  If a set of kills for a
2912 // register is anti-dependent on a set of uses (or defs), rather
2913 // than adding an edge in the graph between each pair of kill
2914 // and use (or def), a pinch is inserted between them:
2915 //
2916 //            use1   use2  use3
2917 //                \   |   /
2918 //                 \  |  /
2919 //                  pinch
2920 //                 /  |  \
2921 //                /   |   \
2922 //            kill1 kill2 kill3
2923 //
2924 // One pinch node is created per register killed when
2925 // the second call is encountered during a backwards pass
2926 // over the block.  Most of these pinch nodes are never
2927 // wired into the graph because the register is never
2928 // used or def&#39;ed in the block.
2929 //
2930 void Scheduling::garbage_collect_pinch_nodes() {
2931 #ifndef PRODUCT
2932   if (_cfg-&gt;C-&gt;trace_opto_output()) tty-&gt;print(&quot;Reclaimed pinch nodes:&quot;);
2933 #endif
2934   int trace_cnt = 0;
2935   for (uint k = 0; k &lt; _reg_node.Size(); k++) {
2936     Node* pinch = _reg_node[k];
2937     if ((pinch != NULL) &amp;&amp; pinch-&gt;Opcode() == Op_Node &amp;&amp;
2938         // no predecence input edges
2939         (pinch-&gt;req() == pinch-&gt;len() || pinch-&gt;in(pinch-&gt;req()) == NULL) ) {
2940       cleanup_pinch(pinch);
2941       _pinch_free_list.push(pinch);
2942       _reg_node.map(k, NULL);
2943 #ifndef PRODUCT
2944       if (_cfg-&gt;C-&gt;trace_opto_output()) {
2945         trace_cnt++;
2946         if (trace_cnt &gt; 40) {
2947           tty-&gt;print(&quot;\n&quot;);
2948           trace_cnt = 0;
2949         }
2950         tty-&gt;print(&quot; %d&quot;, pinch-&gt;_idx);
2951       }
2952 #endif
2953     }
2954   }
2955 #ifndef PRODUCT
2956   if (_cfg-&gt;C-&gt;trace_opto_output()) tty-&gt;print(&quot;\n&quot;);
2957 #endif
2958 }
2959 
2960 // Clean up a pinch node for reuse.
2961 void Scheduling::cleanup_pinch( Node *pinch ) {
2962   assert (pinch &amp;&amp; pinch-&gt;Opcode() == Op_Node &amp;&amp; pinch-&gt;req() == 1, &quot;just checking&quot;);
2963 
2964   for (DUIterator_Last imin, i = pinch-&gt;last_outs(imin); i &gt;= imin; ) {
2965     Node* use = pinch-&gt;last_out(i);
2966     uint uses_found = 0;
2967     for (uint j = use-&gt;req(); j &lt; use-&gt;len(); j++) {
2968       if (use-&gt;in(j) == pinch) {
2969         use-&gt;rm_prec(j);
2970         uses_found++;
2971       }
2972     }
2973     assert(uses_found &gt; 0, &quot;must be a precedence edge&quot;);
2974     i -= uses_found;    // we deleted 1 or more copies of this edge
2975   }
2976   // May have a later_def entry
2977   pinch-&gt;set_req(0, NULL);
2978 }
2979 
2980 #ifndef PRODUCT
2981 
2982 void Scheduling::dump_available() const {
2983   tty-&gt;print(&quot;#Availist  &quot;);
2984   for (uint i = 0; i &lt; _available.size(); i++)
2985     tty-&gt;print(&quot; N%d/l%d&quot;, _available[i]-&gt;_idx,_current_latency[_available[i]-&gt;_idx]);
2986   tty-&gt;cr();
2987 }
2988 
2989 // Print Scheduling Statistics
2990 void Scheduling::print_statistics() {
2991   // Print the size added by nops for bundling
2992   tty-&gt;print(&quot;Nops added %d bytes to total of %d bytes&quot;,
2993              _total_nop_size, _total_method_size);
2994   if (_total_method_size &gt; 0)
2995     tty-&gt;print(&quot;, for %.2f%%&quot;,
2996                ((double)_total_nop_size) / ((double) _total_method_size) * 100.0);
2997   tty-&gt;print(&quot;\n&quot;);
2998 
2999   // Print the number of branch shadows filled
3000   if (Pipeline::_branch_has_delay_slot) {
3001     tty-&gt;print(&quot;Of %d branches, %d had unconditional delay slots filled&quot;,
3002                _total_branches, _total_unconditional_delays);
3003     if (_total_branches &gt; 0)
3004       tty-&gt;print(&quot;, for %.2f%%&quot;,
3005                  ((double)_total_unconditional_delays) / ((double)_total_branches) * 100.0);
3006     tty-&gt;print(&quot;\n&quot;);
3007   }
3008 
3009   uint total_instructions = 0, total_bundles = 0;
3010 
3011   for (uint i = 1; i &lt;= Pipeline::_max_instrs_per_cycle; i++) {
3012     uint bundle_count   = _total_instructions_per_bundle[i];
3013     total_instructions += bundle_count * i;
3014     total_bundles      += bundle_count;
3015   }
3016 
3017   if (total_bundles &gt; 0)
3018     tty-&gt;print(&quot;Average ILP (excluding nops) is %.2f\n&quot;,
3019                ((double)total_instructions) / ((double)total_bundles));
3020 }
3021 #endif
    </pre>
  </body>
</html>